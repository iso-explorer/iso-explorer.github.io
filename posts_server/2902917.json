post_cb({"2903001": {"ParentId": "2902917", "CommentCount": "3", "Body": "<p>Perhaps you're confusing C++'s behavior with C, where <code>const int</code> does not represent a true compile-time constant.  Or perhaps your C++ compiler is broken.  If it's truly the latter, use <code>enum</code> instead.</p>\n", "OwnerUserId": "179715", "PostTypeId": "2", "Id": "2903001", "Score": "1", "CreationDate": "2010-05-25T08:12:32.473", "LastActivityDate": "2010-05-25T08:12:32.473"}, "2902917": {"CommentCount": "4", "AcceptedAnswerId": "2902943", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2010-05-25T07:55:49.693", "LastActivityDate": "2012-01-21T22:21:51.143", "LastEditDate": "2012-01-21T22:03:14.987", "ViewCount": "3697", "FavoriteCount": "1", "Title": "static assert for const variables?", "Id": "2902917", "Score": "5", "Body": "<p>Static asserts are very convenient for checking things in compile time. A simple static assert idiom looks like this:</p>\n<pre><code>template&lt;bool&gt; struct StaticAssert;\ntemplate&lt;&gt; struct StaticAssert&lt;true&gt; {};\n\n#define STATIC_ASSERT(condition) do { StaticAssert&lt;(condition)&gt;(); } while(0)\n</code></pre>\n<p>This is good for stuff like</p>\n<pre><code>STATIC_ASSERT(sizeof(float) == 4)\n</code></pre>\n<p>and:</p>\n<pre><code>#define THIS_LIMIT (1000)\n...\nSTATIC_ASSERT(THIS_LIMIT &gt; OTHER_LIMIT);\n</code></pre>\n<p>But using <code>#define</code> is not the \"C++\" way of defining constants. C++ would have you use an anonymous namespace:</p>\n<pre><code>namespace {\n    const int THIS_LIMIT = 1000;\n}\n</code></pre>\n<p>or even:</p>\n<pre><code>static const int THIS_LIMIT = 1000;\n</code></pre>\n<p>The trouble with this is that with a <code>const int</code> you can't use <code>STATIC_ASSERT()</code> and you must resort to a run-time check which is silly.</p>\n<p>Is there a way to properly solve this in current C++?<br>\nI think I've read C++0x has some facility to do this...</br></p>\n<hr>\n<p><strong>EDIT</strong></p>\n<p>Ok so this </p>\n<pre><code>static const int THIS_LIMIT = 1000;\n...\nSTATIC_ASSERT(THIS_LIMIT &gt; 0);\n</code></pre>\n<p>compiles fine<br>\nBut this:</br></p>\n<pre><code>static const float THIS_LIMIT = 1000.0f;\n...\nSTATIC_ASSERT(THIS_LIMIT &gt; 0.0f);\n</code></pre>\n<p>does not.<br>\n(in Visual Studio 2008)</br></p>\n<p>How come?</p>\n</hr>", "Tags": "<c++><static-assert>", "OwnerUserId": "9611", "AnswerCount": "6"}, "8957166": {"ParentId": "2902917", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It seems that you're <em>really</em> asking why the following is the case (and I can confirm that in both GCC 4.3.4 and Visual C++ 2008 Express):</p>\n<pre><code>template&lt;bool&gt; struct StaticAssert;\ntemplate&lt;&gt; struct StaticAssert&lt;true&gt; {};\n\n#define STATIC_ASSERT(condition) do { StaticAssert&lt;(condition)&gt;(); } while(0)\n\n\nstatic const int   AN_INT  = 1000;\nstatic const float A_FLOAT = 1000.0f;\n\nint main()\n{\n   STATIC_ASSERT(AN_INT &gt; 0);     // OK\n   STATIC_ASSERT(A_FLOAT &gt; 0.0f); // Error: A_FLOAT may not appear in a constant expression\n}\n</code></pre>\n<p>There are number of restrictions on using floating-point values statically. Note, for example, that you cannot pass them as template arguments. That is because:</p>\n<blockquote>\n<p id=\"so_2902917_8957166_0\"><code>[C++11: 5.19/2]:</code> <strong>A <em>conditional-expression</em> is a core constant expression unless it involves one of the following as a potentially evaluated subexpression</strong> (3.2), but subexpressions of logical AND (5.14), logical OR (5.15), and conditional (5.16) operations that are not evaluated are not considered [ <em>Note:</em> An overloaded operator invokes a\n  function. <em>\u2014end note</em> ]<strong>:</strong></p>\n<ul>\n<li>[..]</li>\n<li><strong>an lvalue-to-rvalue conversion (4.1) unless it is applied to</strong>\n<ul>\n<li><strong>a glvalue of integral or enumeration type</strong> that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression, or</li>\n<li>a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers to a sub-object of such an object, or</li>\n<li>a glvalue of literal type that refers to a non-volatile temporary object whose lifetime has not ended, initialized with a constant expression;</li>\n</ul></li>\n<li>[..]</li>\n</ul>\n</blockquote>\n<p>(i.e. only integral and enumeration types are allowed; no floating-point types.)</p>\n<p>As for the <em>reason</em> for this rule, I'm not entirely sure, but the following sort of rationale may well have something to do with it:</p>\n<blockquote>\n<p id=\"so_2902917_8957166_1\"><code>[C++11: 5.19/4]:</code> [..] Since this International Standard imposes no restrictions on the\n  accuracy of floating-point operations, <strong>it is unspecified whether the evaluation of a floating-point expression during translation yields the same result as the evaluation of the same expression</strong> (or the same operations on the same values) <strong>during program execution</strong>. [..]</p>\n</blockquote>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2012-01-21T22:21:51.143", "Id": "8957166", "Score": "1", "CreationDate": "2012-01-21T22:10:56.367", "LastActivityDate": "2012-01-21T22:21:51.143"}, "2903118": {"ParentId": "2902917", "CommentCount": "0", "Body": "<p><code>static_assert</code> is a compiler feature in C++0x so as long as you've got a relatively up-to-date compiler you can use that.  Watch out for doing <code>#define static_assert(x) ...</code>, because it's a real keyword in C++0x so you'd be permanently hiding the compiler feature.  Also, C++0x <code>static_assert</code> takes two parameters (eg. <code>static_assert(sizeof(int) == 4, \"Expecting int to be 4 bytes\")</code>), so you could cause yourself problems trying to switch in future if you use that #define.</p>\n", "OwnerUserId": "177222", "PostTypeId": "2", "Id": "2903118", "Score": "4", "CreationDate": "2010-05-25T08:35:49.790", "LastActivityDate": "2010-05-25T08:35:49.790"}, "2903013": {"ParentId": "2902917", "CommentCount": "0", "Body": "<p>This: </p>\n<pre><code>namespace {\n    const int THIS_LIMIT = 1000;\n}\n\ntemplate&lt;bool&gt; struct StaticAssert;\ntemplate&lt;&gt; struct StaticAssert&lt;true&gt; {};\n\n#define STATIC_ASSERT(condition) do { StaticAssert&lt;(condition)&gt;(); } while(0)\n\nint main()\n{\n    STATIC_ASSERT(THIS_LIMIT &gt; 5);\n\n    return (0);\n}\n</code></pre>\n<p>compiles fine with VC and Comeau. </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "2903013", "Score": "1", "CreationDate": "2010-05-25T08:15:48.397", "LastActivityDate": "2010-05-25T08:15:48.397"}, "2903028": {"ParentId": "2902917", "CommentCount": "3", "Body": "<p><code>enum{THIS_LIMIT = 1000};</code></p>\n", "OwnerUserId": "100724", "PostTypeId": "2", "Id": "2903028", "Score": "0", "CreationDate": "2010-05-25T08:19:27.143", "LastActivityDate": "2010-05-25T08:19:27.143"}, "2902943": {"ParentId": "2902917", "CommentCount": "5", "Body": "<p>Why, you can still static assert with const int:</p>\n<pre><code>#define static_assert(e) extern char (*ct_assert(void)) [sizeof(char[1 - 2*!(e)])]\nstatic_assert( THIS_LIMIT &gt; OTHER_LIMIT )\n</code></pre>\n<p>Also, <a href=\"http://www.boost.org/doc/libs/1_43_0/doc/html/boost_staticassert.html\" rel=\"noreferrer\">use boost</a>!</p>\n<pre><code>BOOST_STATIC_ASSERT( THIS_LIMIT &gt; OTHER_LIMIT )\n</code></pre>\n<p>... you'll get a <strong>lot</strong> nicer error messages...</p>\n", "OwnerUserId": "233522", "PostTypeId": "2", "Id": "2902943", "Score": "10", "CreationDate": "2010-05-25T08:00:46.877", "LastActivityDate": "2010-05-25T08:00:46.877"}, "bq_ids": {"n4140": {"so_2902917_8957166_1": {"section_id": 6188, "quality": 0.896551724137931, "length": 26}}, "n3337": {"so_2902917_8957166_1": {"section_id": 5948, "quality": 0.896551724137931, "length": 26}, "so_2902917_8957166_0": {"section_id": 5946, "quality": 0.6666666666666666, "length": 20}}, "n4659": {"so_2902917_8957166_1": {"section_id": 7691, "quality": 0.896551724137931, "length": 26}}}});