post_cb({"10824192": {"Id": "10824192", "PostTypeId": "2", "Body": "<p>I believe GCC is wrong. In the book \"The C++ Programming Language\" by Bjarne Stroustrup, there is a whole chapter devoted to operator overloading. In the section 11.4.1, the first paragraph says this:</p>\n<p>\"An assignment of a value of type V to an object of class X is legal if there is an assignment operator X::operator=(Z) so that V is Z or there is a unique conversion of V to Z. Initialization is treated equivalently.\"</p>\n<p>In your example, GCC accepts \"string s = GenericType();\" yet rejects \"s = GenericType();\", so it is obviously not treating the assignment the same way as the initialization. That was my first clue something is amiss in GCC. </p>\n<p>GCC reports 3 candidates for conversion of GenericType to string in the assignment, all in basic_string.h. One is the correct conversion, one it reports is not valid, and the third causes the ambiguity. This is the operator overload in basic_string.h that causes the ambiguity:</p>\n<pre><code>/**\n*  @brief  Set value to string of length 1.\n*  @param  c  Source character.\n*\n*  Assigning to a character makes this string length 1 and\n*  (*this)[0] == @a c.\n*/\nbasic_string&amp; operator=(_CharT __c) { \n    this-&gt;assign(1, __c); \n    return *this;\n}\n</code></pre>\n<p>This isn't a valid conversion <strike>because it accepts an operand that doesn't match the type of object that is passed to it. In no place is as assignment to a char attempted, therefore this conversion shouldn't be a candidate at all much less one that causes ambiguity. GCC appears to be mixing up the template type with the operand type in its member.</strike></p>\n<p>EDIT: I wasn't aware that assigning an integer to a string was in fact legal, as an integer can be converted to a char, which can be assigned to a string (although a string can't be initialized to a char!). GenericType defines a conversion to an int, thus making this member a valid candidate. However, I still maintain this is not a valid conversion, the reason being that using this conversion would result in two user defined implicit conversions for the assignment, first from GenericType to int, then from int to string. As stated in the same book 11.4.1, \"only one level of user-defined implicit conversion is legal.\"</p>\n", "LastEditorUserId": "1426971", "LastActivityDate": "2012-05-30T23:15:19.573", "Score": "2", "CreationDate": "2012-05-30T21:00:17.477", "ParentId": "10743106", "CommentCount": "9", "OwnerUserId": "1426971", "LastEditDate": "2012-05-30T23:15:19.573"}, "10743106": {"ViewCount": "1986", "Body": "<p>Given the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nstruct GenericType{\n   operator string(){\n      return \"Hello World\";\n   }\n   operator int(){\n      return 111;\n   }\n   operator double(){\n      return 123.4;\n   }\n};\nint main(){\n   int i = GenericType();\n   string s = GenericType();\n   double d = GenericType();\n   cout &lt;&lt; i &lt;&lt; s &lt;&lt; d &lt;&lt; endl;\n   i = GenericType();\n   s = GenericType(); //This is the troublesome line\n   d = GenericType();\n   cout &lt;&lt; i &lt;&lt; s &lt;&lt; d &lt;&lt; endl;\n}\n</code></pre>\n<p>It compiles on Visual Studio 11, but not clang or gcc.  It is having trouble because it wants to implicitly convert from a <code>GenericType</code> to an <code>int</code> to a <code>char</code> but it also could return a <code>string</code> and so there is an ambiguity (<code>operator=(char)</code> and <code>operator=(string)</code> both match <code>GenericType</code>).</p>\n<p>The copy constructor is just fine, however.</p>\n<p>My question is: How do I resolve this ambiguity without modifying the contents of main?  What do I need to do to modify <code>GenericType</code> to handle this situation?</p>\n", "AcceptedAnswerId": "10743255", "Title": "Ambiguous string::operator= call for type with implicit conversion to int and string", "CreationDate": "2012-05-24T18:16:32.017", "Id": "10743106", "CommentCount": "13", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-07-22T00:16:14.403", "LastEditorUserId": "963864", "LastActivityDate": "2012-07-22T00:16:14.403", "Score": "8", "OwnerUserId": "246878", "Tags": "<c++><string><implicit-conversion><overload-resolution><conversion-operator>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_10743106_10743255_1": {"length": 9, "quality": 1.0, "section_id": 639}, "so_10743106_10743255_0": {"length": 11, "quality": 1.0, "section_id": 639}, "so_10743106_10743255_2": {"length": 8, "quality": 1.0, "section_id": 639}}, "n3337": {"so_10743106_10743255_1": {"length": 9, "quality": 1.0, "section_id": 629}, "so_10743106_10743255_0": {"length": 11, "quality": 1.0, "section_id": 629}, "so_10743106_10743255_2": {"length": 8, "quality": 1.0, "section_id": 629}}, "n4659": {"so_10743106_10743255_1": {"length": 9, "quality": 1.0, "section_id": 667}, "so_10743106_10743255_0": {"length": 11, "quality": 1.0, "section_id": 667}, "so_10743106_10743255_2": {"length": 8, "quality": 1.0, "section_id": 667}}}, "10743255": {"Id": "10743255", "PostTypeId": "2", "Body": "<p>I believe that gcc and clang are correct.</p>\n<p>There are two <code>operator=</code> overloads in play:</p>\n<pre><code>string&amp; operator=(string const&amp; str); // (1)\nstring&amp; operator=(char ch);           // (2)\n</code></pre>\n<p>Both of these <code>operator=</code> overloads require a user-defined conversion from your argument of type <code>GenericType</code>.  <strong>(1)</strong> requires the use of the conversion to <code>string</code>. <strong>(2)</strong> requires the use of the conversion to <code>int</code>, followed by a standard conversion to <code>char</code>.</p>\n<p>The important thing is that both overloads require a user-defined conversion.  To determine whether one of these conversions is better than the other, we can look to the overload resolution rules, specifically the following rule from C++11 \u00a713.3.3.2/3 (reformatted for clarity):</p>\n<blockquote>\n<p id=\"so_10743106_10743255_0\">User-defined conversion sequence <code>U1</code> is a better conversion sequence than another user-defined conversion sequence <code>U2</code> if</p>\n<ol>\n<li><p id=\"so_10743106_10743255_1\">they contain the same user-defined conversion function or constructor or aggregate initialization and</p></li>\n<li><p id=\"so_10743106_10743255_2\">the second standard conversion sequence of <code>U1</code> is better than the second standard conversion sequence of <code>U2</code>.</p></li>\n</ol>\n</blockquote>\n<p>Note that an <em>and</em> joins the two parts of the rule, so both parts must be satisfied.  The first part of the rule is not satisfied:  the two user-defined conversion sequences use different user-defined conversion functions.</p>\n<p>Therefore, neither conversion is better, and the call is ambiguous.</p>\n<p>[I don't have a good suggestion on how to fix the problem without changing the definition of <code>main()</code>.  Implicit conversions are usually not a good idea; they are sometimes very useful, but more frequently they are likely to cause overload ambiguities or other weird overloading behavior.]</p>\n<p>There was a gcc bug report in which this problem was described, and resolved as by design:  <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14830\" rel=\"noreferrer\">compiler incorrectly diagnoses ambigous operator overload.</a></p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2012-05-30T22:55:27.917", "Score": "9", "CreationDate": "2012-05-24T18:29:56.860", "ParentId": "10743106", "CommentCount": "3", "OwnerUserId": "151292", "LastEditDate": "2012-05-30T22:55:27.917"}, "10870406": {"Id": "10870406", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10743106_10870406_0\">My question is: How do I resolve this ambiguity without modifying the contents of main? </p>\n</blockquote>\n<p>Create your own class named <code>string</code> that doesn't have an ambiguous <code>operator=</code> and then don't <code>using</code> the <code>std</code> one.</p>\n<p>Obviously this isn't a very good solution, but it works and <code>main</code> doesn't have to change.</p>\n<p>I don't think you can get the behavior you want any other way.</p>\n", "LastActivityDate": "2012-06-03T12:42:54.487", "CommentCount": "1", "CreationDate": "2012-06-03T12:42:54.487", "ParentId": "10743106", "Score": "1", "OwnerUserId": "964135"}});