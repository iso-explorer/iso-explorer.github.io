post_cb({"11016262": {"CommentCount": "0", "ViewCount": "710", "CreationDate": "2012-06-13T13:48:18.037", "LastActivityDate": "2012-06-13T15:12:31.677", "Title": "Does a templated constructor override the implicit copy constructor in C++?", "AcceptedAnswerId": "11016403", "PostTypeId": "1", "Id": "11016262", "Score": "7", "Body": "<p>Does a templated constructor (such as the following) override the implicit copy constructor?</p>\n<pre><code>template &lt;class T&gt;\nstruct Foo\n{\n    T data;\n\n    // ...\n\n    template &lt;class U&gt;\n    Foo(const Foo&lt;U&gt; &amp;other) : data((T)doSomethingWith(other.data)) {}\n\n    // ...\n};\n</code></pre>\n<p>If so, does it still override it if <code>other</code> is passed by value rather than constant reference?</p>\n<p>If so, is there any way around this without explicitly defining a copy constructor?</p>\n", "Tags": "<c++><templates><copy-constructor>", "OwnerUserId": "810671", "AnswerCount": "3"}, "11016416": {"ParentId": "11016262", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_11016262_11016416_0\">Does a templated constructor (such as the following) override the implicit copy constructor?</p>\n</blockquote>\n<p>No. The copy constructor is still implicitly declared, and is chosen in preference to the template.</p>\n<blockquote>\n<p id=\"so_11016262_11016416_1\">Is there any way around this without explicitly defining a copy constructor?</p>\n</blockquote>\n<p>No. If you don't want the implicit copy constructor, then you'll have to define one yourself.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "11016416", "Score": "2", "CreationDate": "2012-06-13T13:55:19.747", "LastActivityDate": "2012-06-13T13:55:19.747"}, "11016422": {"ParentId": "11016262", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A templated constructor or assignment operator which looks like a templated [default constructor/copy constructor/move constructor/copy assignment operator/move assignment operator] is not <em>really</em> a [default constructor/copy constructor/move constructor/copy assignment operator/move assignment operator] and will not replace it or prevent it from being implicitly generated.</p>\n", "OwnerUserId": "369872", "LastEditorUserId": "369872", "LastEditDate": "2012-06-13T15:12:31.677", "Id": "11016422", "Score": "2", "CreationDate": "2012-06-13T13:55:47.863", "LastActivityDate": "2012-06-13T15:12:31.677"}, "11016403": {"ParentId": "11016262", "CommentCount": "0", "Body": "<p>No, that is not a copy constructor.  Section 12.8 (<code>[class.copy]</code>) of the Standard requires that:</p>\n<blockquote>\n<p id=\"so_11016262_11016403_0\">A non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments.</p>\n</blockquote>\n<p>The compiler will still implicitly generate a defaulted one.</p>\n<p>You can make that explicit (requires C++11) by</p>\n<pre><code>Foo(const Foo&lt;T&gt;&amp;) = default;\n</code></pre>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "11016403", "Score": "7", "CreationDate": "2012-06-13T13:54:50.097", "LastActivityDate": "2012-06-13T13:54:50.097"}, "bq_ids": {"n4140": {"so_11016262_11016403_0": {"section_id": 451, "quality": 1.0, "length": 24}, "so_11016262_11016416_1": {"section_id": 5994, "quality": 0.5714285714285714, "length": 4}, "so_11016262_11016416_0": {"section_id": 480, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_11016262_11016403_0": {"section_id": 442, "quality": 1.0, "length": 24}, "so_11016262_11016416_1": {"section_id": 5762, "quality": 0.5714285714285714, "length": 4}, "so_11016262_11016416_0": {"section_id": 471, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_11016262_11016403_0": {"section_id": 474, "quality": 1.0, "length": 24}, "so_11016262_11016416_1": {"section_id": 7496, "quality": 0.5714285714285714, "length": 4}}}});