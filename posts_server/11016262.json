post_cb({"bq_ids": {"n4140": {"so_11016262_11016416_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5994}, "so_11016262_11016416_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 480}, "so_11016262_11016403_0": {"length": 24, "quality": 1.0, "section_id": 451}}, "n3337": {"so_11016262_11016416_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5762}, "so_11016262_11016416_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 471}, "so_11016262_11016403_0": {"length": 24, "quality": 1.0, "section_id": 442}}, "n4659": {"so_11016262_11016416_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 7496}, "so_11016262_11016403_0": {"length": 24, "quality": 1.0, "section_id": 474}}}, "11016416": {"Id": "11016416", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11016262_11016416_0\">Does a templated constructor (such as the following) override the implicit copy constructor?</p>\n</blockquote>\n<p>No. The copy constructor is still implicitly declared, and is chosen in preference to the template.</p>\n<blockquote>\n<p id=\"so_11016262_11016416_1\">Is there any way around this without explicitly defining a copy constructor?</p>\n</blockquote>\n<p>No. If you don't want the implicit copy constructor, then you'll have to define one yourself.</p>\n", "LastActivityDate": "2012-06-13T13:55:19.747", "CommentCount": "0", "CreationDate": "2012-06-13T13:55:19.747", "ParentId": "11016262", "Score": "2", "OwnerUserId": "204847"}, "11016262": {"ViewCount": "710", "Body": "<p>Does a templated constructor (such as the following) override the implicit copy constructor?</p>\n<pre><code>template &lt;class T&gt;\nstruct Foo\n{\n    T data;\n\n    // ...\n\n    template &lt;class U&gt;\n    Foo(const Foo&lt;U&gt; &amp;other) : data((T)doSomethingWith(other.data)) {}\n\n    // ...\n};\n</code></pre>\n<p>If so, does it still override it if <code>other</code> is passed by value rather than constant reference?</p>\n<p>If so, is there any way around this without explicitly defining a copy constructor?</p>\n", "AcceptedAnswerId": "11016403", "Title": "Does a templated constructor override the implicit copy constructor in C++?", "CreationDate": "2012-06-13T13:48:18.037", "Id": "11016262", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-06-13T15:12:31.677", "Score": "7", "OwnerUserId": "810671", "Tags": "<c++><templates><copy-constructor>", "AnswerCount": "3"}, "11016403": {"Id": "11016403", "PostTypeId": "2", "Body": "<p>No, that is not a copy constructor.  Section 12.8 (<code>[class.copy]</code>) of the Standard requires that:</p>\n<blockquote>\n<p id=\"so_11016262_11016403_0\">A non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments.</p>\n</blockquote>\n<p>The compiler will still implicitly generate a defaulted one.</p>\n<p>You can make that explicit (requires C++11) by</p>\n<pre><code>Foo(const Foo&lt;T&gt;&amp;) = default;\n</code></pre>\n", "LastActivityDate": "2012-06-13T13:54:50.097", "CommentCount": "0", "CreationDate": "2012-06-13T13:54:50.097", "ParentId": "11016262", "Score": "7", "OwnerUserId": "103167"}, "11016422": {"Id": "11016422", "PostTypeId": "2", "Body": "<p>A templated constructor or assignment operator which looks like a templated [default constructor/copy constructor/move constructor/copy assignment operator/move assignment operator] is not <em>really</em> a [default constructor/copy constructor/move constructor/copy assignment operator/move assignment operator] and will not replace it or prevent it from being implicitly generated.</p>\n", "LastEditorUserId": "369872", "LastActivityDate": "2012-06-13T15:12:31.677", "Score": "2", "CreationDate": "2012-06-13T13:55:47.863", "ParentId": "11016262", "CommentCount": "2", "OwnerUserId": "369872", "LastEditDate": "2012-06-13T15:12:31.677"}});