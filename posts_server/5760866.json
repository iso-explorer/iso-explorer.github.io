post_cb({"bq_ids": {"n4140": {"so_5760866_5761142_0": {"length": 14, "quality": 1.0, "section_id": 380}, "so_5760866_5761101_0": {"length": 39, "quality": 0.9285714285714286, "section_id": 380}}, "n3337": {"so_5760866_5761142_0": {"length": 14, "quality": 1.0, "section_id": 371}, "so_5760866_5761101_0": {"length": 39, "quality": 0.9285714285714286, "section_id": 371}}, "n4659": {"so_5760866_5761142_0": {"length": 14, "quality": 1.0, "section_id": 395}, "so_5760866_5761101_0": {"length": 39, "quality": 0.9285714285714286, "section_id": 395}}}, "5761101": {"Id": "5761101", "PostTypeId": "2", "Body": "<p>(Quoting the C++03 standard)</p>\n<p>First there's \u00a712.2/3:</p>\n<blockquote>\n<p id=\"so_5760866_5761101_0\">When an implementation introduces a temporary object of a class that has a non-trivial constructor (12.1), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be called for a temporary with a non-trivial destructor (12.4). <strong>Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</strong> This is true even if that evaluation ends in throwing an exception.</p>\n</blockquote>\n<p>I believe this is a red herring, because of \u00a71.9/13:</p>\n<blockquote>\n<p id=\"so_5760866_5761101_1\">[Note: certain contexts in C++ cause the evaluation of a full-expression that results from a syntactic construct other than expression (5.18). For example, in 8.5 one syntax for initializer is</p>\n<p id=\"so_5760866_5761101_2\">\u00a0\u00a0\u00a0\u00a0<code>( expression-list )</code></p>\n<p id=\"so_5760866_5761101_3\">but the resulting construct is a function call upon a constructor function with expression-list as an argument list; such a function call is a full-expression. For example, in 8.5, another syntax for initializer is</p>\n<p id=\"so_5760866_5761101_4\">\u00a0\u00a0\u00a0\u00a0<code>= initializer-clause</code></p>\n<p id=\"so_5760866_5761101_5\">but again <strong>the resulting construct might be a function call upon a constructor function with one assignment-expression as an argument; again, the function call is a full-expression</strong>. ]</p>\n</blockquote>\n<p>This implies to me that <code>A(b).yield()</code> is itself a full expression, rendering \u00a712.2/3 irrelevant here.</p>\n<p>Then we get into sequence points -- \u00a71.9/7:</p>\n<blockquote>\n<p id=\"so_5760866_5761101_6\">Accessing an object designated by a volatile lvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment. Evaluation of an expression might produce side effects. <strong>At certain specified points in the execution sequence called sequence points, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place.</strong></p>\n</blockquote>\n<p>\u00a71.9/16:</p>\n<blockquote>\n<p id=\"so_5760866_5761101_7\"><strong>There is a sequence point at the completion of evaluation of each full-expression.</strong></p>\n</blockquote>\n<p>and \u00a71.9/17:</p>\n<blockquote>\n<p id=\"so_5760866_5761101_8\">When calling a function (whether or not the function is inline), there is a sequence point after the evaluation of all function arguments (if any) which takes place before execution of any expressions or statements in the function body. <strong>There is also a sequence point after the copying of a returned value and before the execution of any expressions outside the function.</strong></p>\n</blockquote>\n<p>Putting it all together, <em>I think</em> Clang is right and GCC (and MSVC 2010 SP1) is wrong -- the temporary that holds the result of the expression (whose lifetime is being extended as per \u00a712.2/4) is the <code>bool</code> returned from <code>A::yield()</code>, not the temporary <code>A</code> on which <code>yield</code> is invoked. Taking into account \u00a71.9, there should be a sequence point after the call to <code>A::yield()</code> during which the temporary <code>A</code> is destroyed.</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2011-04-23T00:15:25.330", "Score": "2", "CreationDate": "2011-04-22T23:49:22.423", "ParentId": "5760866", "CommentCount": "1", "OwnerUserId": "636019", "LastEditDate": "2011-04-23T00:15:25.330"}, "5760866": {"ViewCount": "562", "Body": "<p>I constructed this experiment today, after answering some question</p>\n<pre><code>struct A { \n  bool &amp;b; \n  A(bool &amp;b):b(b) { } \n  ~A() { std::cout &lt;&lt; b; }  \n  bool yield() { return true; } \n}; \n\nbool b = A(b).yield();\n\nint main() { }\n</code></pre>\n<p><code>b</code> has value <code>false</code> (resulting from zero initialization) before setting it to <code>true</code> by the dynamic initialization. If the temporary is destroyed before initialization of <code>b</code> finished, we will print <code>false</code>, otherwise <code>true</code>. </p>\n<p>The spec says that the temporary is destroyed at the end of the full-expression. That does not seem to be ordered with the initialization of <code>b</code>. So I wonder</p>\n<ul>\n<li>Does the spec allow an implementation to print both <code>false</code> and <code>true</code> in different runs?</li>\n</ul>\n<p>Clang prints <code>false</code> for the above, while GCC prints <code>true</code>. This confuses me. Did I miss some spec text defining the order?</p>\n", "Title": "When exactly is an initializer temporary destroyed?", "CreationDate": "2011-04-22T23:06:42.790", "LastActivityDate": "2013-03-04T15:50:29.837", "CommentCount": "17", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-04T15:50:29.837", "LastEditorUserId": "179910", "Id": "5760866", "Score": "16", "OwnerUserId": "34509", "Tags": "<c++><initialization><order><language-lawyer>", "AnswerCount": "3"}, "5761049": {"Id": "5761049", "PostTypeId": "2", "Body": "<p>I think it's allowed to print out true, or false, or for somewhat unrelated reasons, nothing at all.</p>\n<p>The true or false part is (as you've said), that the destruction of the temporary <code>A</code> object is not ordered with respect to the dynamic initialization of <code>b</code>.</p>\n<p>The nothing at all possibility is because the initialization of <code>b</code> is not ordered with respect to the creation/initialization of <code>std::cout</code>; when you try to destroy the temporary, <code>cout</code> may not have been created/initialized yet, so attempting to print something may not work at that point at all. [Edit: this is specific to C++98/03, and does not apply to C++11.]</p>\n<p>Edit: here is how I, at least, see the sequence:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/INTq5.png\"/></p>\n<p>Edit2: After rereading \u00a712.2/4 (yet again), I've changed the diagram again. \u00a712.2/4 says:</p>\n<blockquote>\n<p id=\"so_5760866_5761049_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full expression. The first context is when an expression appears as an initializer for a declarator defining an object. In that context, the temporary that holds the result of the expression shall persist until the object\u2019s initialization is complete. The object is initialized from a copy of the temporary; during this copying, an implementation can call the copy constructor many times; the temporary is destroyed after it has been copied, before or when the initialization completes.</p>\n</blockquote>\n<p>I believe this expression is an initializer for a declarator defining an object, so it's required to initialize the object from a copy of the value of the expression (<code>true</code>, in this case), not directly from the return value. In the case of <code>true</code>, this is probably a distinction without a difference, but I think the diagram is technically more accurate as it stands right now.</p>\n<p>This also makes fairly clear (I think) that the temporary holding <code>true</code> does <em>not</em> have to be destroyed at the end of the full expression, so I've re-drawn the diagram to reflect that as well.</p>\n<p>This section is gone in C++0x/C++11, so I've re-drawn the diagram (yet again) to show the difference between the two (and how much simpler this piece has gotten in C++11).</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2011-04-23T03:50:50.623", "Score": "8", "CreationDate": "2011-04-22T23:40:39.347", "ParentId": "5760866", "CommentCount": "33", "OwnerUserId": "179910", "LastEditDate": "2011-04-23T03:50:50.623"}, "5761142": {"Id": "5761142", "PostTypeId": "2", "Body": "<p>First, just to clear up the paragraph that was previously here, using <code>b</code> in its own (dynamic) initialisation here is not UB. Before the expression is evaluated, <code>b</code> is not uninitialised but zero-initialised.</p>\n<hr>\n<p>The temporary <code>A</code> must live for precisely as long as the full expression:</p>\n<blockquote>\n<p id=\"so_5760866_5761142_0\">Temporary objects are destroyed as the\n  last step in evaluating the\n  full-expression (1.9) that (lexically)\n  contains the point where they were\n  created.</p>\n<p id=\"so_5760866_5761142_1\">[ISO/IEC 14882:2003(E) 12.2/3]</p>\n</blockquote>\n<p>The line <code>bool b =  A(b).yield();</code> is a declaration, which is a statement, which is not an expression. The expression at hand is found only to the RHS of the <code>=</code>.  [ISO/IEC 14882:2003(E) A.6]</p>\n<p>This would mean that the temporary should be destroyed <em>before</em> the dynamic initialisation takes place, no? Sure, the value <code>true</code> is held in the temporary that contains the result of the expression<sup>1</sup> until the initialisation completes, but the original <code>A</code> temporary should be destroyed before <code>b</code> is actually modified.</p>\n<p>Therefore I'd expect the output <code>false</code>, every time.</p>\n<hr>\n<p><sup>1</sup></p>\n<blockquote>\n<p id=\"so_5760866_5761142_2\">The first context is when an\n  expression appears as an initializer\n  for a declarator defining an object.\n  In that context, the temporary that\n  holds the result of the expression\n  shall persist until the object\u2019s\n  initialization is complete\"</p>\n<p id=\"so_5760866_5761142_3\">[ISO/IEC 14882:2003(E) 12.2/4]</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-04-23T00:20:36.930", "Score": "2", "CreationDate": "2011-04-22T23:55:08.253", "ParentId": "5760866", "CommentCount": "8", "OwnerUserId": "560648", "LastEditDate": "2011-04-23T00:20:36.930"}});