post_cb({"46122538": {"ParentId": "46116173", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I think it depends on what a particular phrase means.</p>\n<p>Both conversions are equivalent because we exclude <a href=\"http://eel.is/c++draft/over.ics.rank#3.2.1\" rel=\"nofollow noreferrer\">lvalue transformations</a> (basically, an array effectively is a pointer so it doesn't count as a conversion), so we get into the next tiebreaker that you pointed out in <a href=\"http://eel.is/c++draft/over.ics.rank#3.2.3\" rel=\"nofollow noreferrer\">[over.ics.rank]</a>:</p>\n<blockquote>\n<p id=\"so_46116173_46122538_0\">S1 and S2 are reference bindings and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference <strong>to an rvalue</strong> and S2 binds an lvalue reference</p>\n</blockquote>\n<p>Does this case apply? We do have two reference bindings:</p>\n<pre><code>int arr[6];\nint (&amp;a)[6] = arr;  // #1\nint *&amp;&amp; b = arr;    // #2\n</code></pre>\n<p>Here, #1 binds an lvalue reference. #2 falls into <a href=\"http://eel.is/c++draft/dcl.init.ref#5.2.2.2\" rel=\"nofollow noreferrer\">[dcl.init.ref]</a>:</p>\n<blockquote>\n<p id=\"so_46116173_46122538_1\">Otherwise, the initializer expression is implicitly converted to a prvalue of type \u201ccv1 T1\u201d. The temporary materialization conversion is applied and the reference is bound to the result.</p>\n</blockquote>\n<p><code>arr</code> is implicitly converted to a prvalue of type <code>int*</code>, which is then bound to <code>b</code>. </p>\n<hr/>\n<p>So now the question is - what does the restriction in [over.ics.rank] mean? It could mean:</p>\n<ul>\n<li>an rvalue reference that is, in general, bound to an rvalue. This is apparently clang's interpretation. The rvalue reference is bound to the temporary materialized from the prvalue conversion of <code>arr</code>. </li>\n<li>specifically, the argument expression is an rvalue that is bound to the rvalue reference parameter. This is apprently gcc's interpretation, and since <code>arr</code> is not an rvalue (it is an lvalue), this tiebreaker is skipped and no subsequent tiebreakers apply.</li>\n</ul>\n<p>I am inclined to favor gcc's implementation here. Otherwise, what would the point of the phrase \"binds an rvalue reference to an rvalue\" be? Rvalue references cannot bind to lvalues. It's redundant. That said, it's awkwardly worded for that interpretation too. </p>\n<p>As is, I'll call it a wording bug. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-09-08T18:42:06.447", "Id": "46122538", "Score": "3", "CreationDate": "2017-09-08T18:26:11.973", "LastActivityDate": "2017-09-08T18:42:06.447"}, "46116173": {"CommentCount": "14", "ViewCount": "254", "PostTypeId": "1", "LastEditorUserId": "8314962", "CreationDate": "2017-09-08T12:06:11.927", "LastActivityDate": "2017-09-09T01:31:43.597", "Title": "overload resolution between lvalue reference and rvalue reference", "FavoriteCount": "2", "LastEditDate": "2017-09-09T01:31:43.597", "Id": "46116173", "Score": "16", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid func(int (&amp;ref)[6]) { cout &lt;&lt; \"#1\" &lt;&lt; endl; }\nvoid func(int * &amp;&amp;ref) { cout &lt;&lt; \"#2\" &lt;&lt; endl; }\n\nint main()\n{\n  int arr[6];\n  func(arr); // g++(5.4): ambiguous, clang++(3.8): #2, vc++(19.11): #1\n\n  return 0;\n}\n</code></pre>\n<p>Both functions are exact matches. Below is a quote from the standard:</p>\n<blockquote>\n<p id=\"so_46116173_46116173_0\">Standard conversion sequence S1 is a better conversion sequence than\n  standard conversion sequence S2 if</p>\n<p id=\"so_46116173_46116173_1\">...</p>\n<p id=\"so_46116173_46116173_2\">S1 and S2 are reference bindings (8.5.3) and neither refers to an\n  implicit object parameter of a non-static member function declared\n  without a ref-qualifier, and S1 binds an rvalue reference to an rvalue\n  and S2 binds an lvalue reference.</p>\n</blockquote>\n<p>Doesn't it imply that the second is better?</p>\n<p><strong>Updated:</strong></p>\n<p><a href=\"https://stackoverflow.com/questions/5347444/overload-resolution-and-arrays-which-function-should-be-called\">There</a> is a related question. And the following code is a simplified version of it.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid func(int *&amp;) { cout &lt;&lt; \"#1\" &lt;&lt; endl; }\nvoid func(int *&amp;&amp;) { cout &lt;&lt; \"#2\" &lt;&lt; endl; }\n\nint main()\n{\n  int arr[6];\n  func(arr);  // g++(5.4) and clang++(3.8): #2, vc++(19.11): ambiguous\n\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><overloading><language-lawyer><rvalue-reference>", "OwnerUserId": "8314962", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46116173_46122538_0": {"section_id": 639, "quality": 1.0, "length": 19}, "so_46116173_46116173_2": {"section_id": 639, "quality": 0.95, "length": 19}, "so_46116173_46116173_0": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_46116173_46122538_1": {"section_id": 3191, "quality": 0.5625, "length": 9}, "so_46116173_46122538_0": {"section_id": 629, "quality": 1.0, "length": 19}, "so_46116173_46116173_2": {"section_id": 629, "quality": 0.95, "length": 19}, "so_46116173_46116173_0": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_46116173_46122538_1": {"section_id": 4087, "quality": 0.875, "length": 14}, "so_46116173_46122538_0": {"section_id": 667, "quality": 1.0, "length": 19}, "so_46116173_46116173_2": {"section_id": 667, "quality": 0.95, "length": 19}, "so_46116173_46116173_0": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}}}});