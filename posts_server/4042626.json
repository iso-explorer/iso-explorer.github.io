post_cb({"4042672": {"ParentId": "4042626", "CommentCount": "0", "Body": "<p>I'd believe that is because a <code>const</code> object can be stored into read-only memory. Thus, writing to it can have many various effects: program crash, segmentation fault, or no effect.</p>\n", "OwnerUserId": "212063", "PostTypeId": "2", "Id": "4042672", "Score": "1", "CreationDate": "2010-10-28T12:01:08.213", "LastActivityDate": "2010-10-28T12:01:08.213"}, "4042626": {"CommentCount": "1", "ViewCount": "280", "CreationDate": "2010-10-28T11:55:16.573", "LastActivityDate": "2010-11-12T11:12:23.653", "Title": "const_cast and UB", "AcceptedAnswerId": "4042686", "PostTypeId": "1", "Id": "4042626", "Score": "5", "Body": "<blockquote>\n<p id=\"so_4042626_4042626_0\">$5.2.11/7 - \"[Note: Depending on the\n  type of the object, a write operation\n  through the pointer, lvalue or pointer\n  to data member resulting from a\n  const_cast that casts away a\n  const-qualifier68) <strong>may</strong> produce\n  undefined behavior (7.1.5.1). ]\"</p>\n</blockquote>\n<p>The wordings of this section (C++03) are surprising to me. What is suprising are two things.</p>\n<p>a) Firstly, the use of 'may'. Why is it 'may'? Other places in the Standard are very definitive about the undefined behavior</p>\n<p>b) Why is that the casting away the constness of a originally const object not straight away 'undefined behavior'. Why is it that a write is required for UB to be triggered?</p>\n", "Tags": "<c++><undefined-behavior><const-cast>", "OwnerUserId": "418110", "AnswerCount": "4"}, "4042763": {"ParentId": "4042626", "CommentCount": "3", "Body": "<p>For your first question, if something <em>may</em> produce undefined behavior, then that doesn't make it any less undefined. </p>\n<p>For the second part, I'd imagine it is for interoperability reasons. For example, C doesn't (or didn't, before C99) have a <code>const</code> keyword, so if you want to pass a const object to a C function, the constness would have to be cast away. So the C++ standard specifies that this is allowed as long as no writes are performed. If the C function is read-only, the constness can be safely cast away.</p>\n<p>Even in C++, inconsistent or incomplete const-correctness is pretty common too. So we do occasionally run into situations where we have to cast away const-ness in order to pass a const object to a function which doesn't modify its argument, but takes it by non-const.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "4042763", "Score": "3", "CreationDate": "2010-10-28T12:13:07.070", "LastActivityDate": "2010-10-28T12:13:07.070"}, "4042686": {"ParentId": "4042626", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-10-28T12:02:30.320", "Score": "4", "LastEditorUserId": "168288", "LastEditDate": "2010-10-28T12:10:57.030", "Id": "4042686", "OwnerUserId": "168288", "Body": "<blockquote>\n<p id=\"so_4042626_4042686_0\">a) Firstly, the use of 'may'. Why is\n  it 'may'? Other places in the Standard\n  are very definitive about the\n  undefined behavior</p>\n</blockquote>\n<p>Don't look too deeply into the use of the word <em>may</em> here.  The point is, casting away constness in this case causes undefined behavior.</p>\n<p>The C++ standard uses \"may\" or \"might\" often, as in:</p>\n<blockquote>\n<p id=\"so_4042626_4042686_1\">1.3.12: Undefined behavior <em>may</em> also be expected when this International\n  Standard omits the description of any\n  explicit definition of behavior.</p>\n</blockquote>\n<p>Emphasis mine.  Basically, the standard uses the word \"may\" as in \"<a href=\"http://www.macmillandictionary.com/dictionary/american/may#may_31\" rel=\"nofollow\">is allowed to</a>\".</p>\n<blockquote>\n<p id=\"so_4042626_4042686_2\">b) Why is that the casting away the\n  constness of a originally const object\n  not straight away 'undefined\n  behavior'. Why is it that a write is\n  required for UB to be triggered?</p>\n</blockquote>\n<p>A write triggers UB because it's possible that const objects can be stored in read-only memory on certain platforms.</p>\n", "LastActivityDate": "2010-10-28T12:10:57.030"}, "bq_ids": {"n4140": {"so_4042626_4042626_0": {"section_id": 6057, "quality": 0.8260869565217391, "length": 19}, "so_4042626_4042686_1": {"section_id": 5768, "quality": 0.7142857142857143, "length": 10}}, "n3337": {"so_4042626_4042626_0": {"section_id": 5825, "quality": 0.8260869565217391, "length": 19}, "so_4042626_4042686_1": {"section_id": 5541, "quality": 0.7142857142857143, "length": 10}}, "n4659": {"so_4042626_4042626_0": {"section_id": 7555, "quality": 0.8260869565217391, "length": 19}, "so_4042626_4042686_1": {"section_id": 7225, "quality": 0.7142857142857143, "length": 10}}}, "4042673": {"ParentId": "4042626", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-10-28T12:01:27.400", "Score": "3", "LastEditorUserId": "24913", "LastEditDate": "2010-11-12T11:12:23.653", "Id": "4042673", "OwnerUserId": "24913", "Body": "<p>My understanding is that it will only be UB if the object in question is fundamentally a const object rather than a const pointer or reference to an object which was not originally const.</p>\n<p>The idea being that data that is fundamentally const could be loaded into a read-only portion of memory, and writing to that just isn't going to work.  However, it's guaranteed to work properly if the object in question is fundamentally mutable.</p>\n<p>Ex:</p>\n<pre><code>const int  x = 4;\nconst int *y = x;\n\n*const_cast&lt;int*&gt;(x) = 3; // UB - the pointed-to object may \n                          // be in read-only memory or whatever.\n\nint        a = 7;\nconst int *b = a;\n\n*const_cast&lt;int*&gt;(b) = 6; // Not UB - the pointed-to object is \n                          // fundamentally mutable.\n</code></pre>\n<hr>\n<p>For a comment below, because code looks terrible in comments:</p>\n<p>In \u00a77.1.\u200b5.1/4 of the standard, the example given is:</p>\n<pre><code>int i = 2;\nconst int * cip; // pointer to const int\ncip = &amp;i;        // OK: cv-qualified access path to unqualified\n...\nint* ip;\nip = const_cast &lt;int *&gt;( cip ); // cast needed to convert const int* to int*\n*ip = 4;                        // defined: *ip points to i, a non-const object\n</code></pre>\n<p>So this is specifically allowed.</p>\n</hr>", "LastActivityDate": "2010-11-12T11:12:23.653"}});