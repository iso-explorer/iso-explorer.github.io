post_cb({"12396623": {"Id": "12396623", "PostTypeId": "2", "Body": "<p>You should <strong>never</strong> compare floating point values for equality.</p>\n", "LastActivityDate": "2012-09-12T21:47:17.587", "CommentCount": "10", "CreationDate": "2012-09-12T21:47:17.587", "ParentId": "12396132", "Score": "2", "OwnerUserId": "36565"}, "12396132": {"ViewCount": "1507", "Body": "<p>I am bit confused about implicit type conversion. Given the following program </p>\n<pre><code>   float x = 4.23423451;\n   double y = 4.23423451;\n\n   float z = 101.9876;\n\n   float res1 = x * z;\n   float res2 = y * z;\n\n   std::cout &lt;&lt; \"res1 &amp; res2 \" &lt;&lt; res1 &lt;&lt; \"  &amp; \" &lt;&lt; res2 &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"equality \" &lt;&lt; (res1 == res2) &lt;&lt; std::endl;\n</code></pre>\n<p>The output was</p>\n<pre><code>   res1 &amp; res2 431.839  &amp; 431.839\n   equality 1\n</code></pre>\n<p>My question is \"Will the equality be always true for any value of x, y &amp; z (x = y) and also for any compiler?\"</p>\n<p>In </p>\n<blockquote>\n<p id=\"so_12396132_12396132_0\">res2 = y * z;</p>\n</blockquote>\n<p>Will the variable \"y\" be type-casted to float or variable \"z\" be type-casted to double?</p>\n", "AcceptedAnswerId": "12396208", "Title": "C++ : Implicit type conversion", "CreationDate": "2012-09-12T21:00:33.913", "Id": "12396132", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-09-12T21:47:17.587", "Score": "3", "OwnerUserId": "311148", "Tags": "<c++>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_12396132_12396208_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_12396132_12396208_8": {"length": 10, "quality": 0.5882352941176471, "section_id": 28}, "so_12396132_12396208_10": {"length": 10, "quality": 0.9090909090909091, "section_id": 36}, "so_12396132_12396208_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}, "so_12396132_12396208_9": {"length": 38, "quality": 0.9743589743589743, "section_id": 35}, "so_12396132_12396208_5": {"length": 12, "quality": 1.0, "section_id": 6175}}, "n3337": {"so_12396132_12396208_9": {"length": 38, "quality": 0.9743589743589743, "section_id": 32}, "so_12396132_12396208_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_12396132_12396208_8": {"length": 10, "quality": 0.5882352941176471, "section_id": 25}, "so_12396132_12396208_10": {"length": 10, "quality": 0.9090909090909091, "section_id": 33}, "so_12396132_12396208_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}, "so_12396132_12396208_5": {"length": 12, "quality": 1.0, "section_id": 5936}}, "n4659": {"so_12396132_12396208_9": {"length": 34, "quality": 0.8717948717948718, "section_id": 35}, "so_12396132_12396208_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_12396132_12396208_8": {"length": 10, "quality": 0.5882352941176471, "section_id": 28}, "so_12396132_12396208_10": {"length": 6, "quality": 0.5454545454545454, "section_id": 34}, "so_12396132_12396208_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 0}, "so_12396132_12396208_5": {"length": 12, "quality": 1.0, "section_id": 7677}}}, "12396207": {"Id": "12396207", "PostTypeId": "2", "Body": "<p>The casting should remain the same; however, I have seen processor and os impact the actual mathematics at high precision.</p>\n<p>But, all that aside, use <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">static_cast</a> to be explicit:</p>\n<pre><code>float res2 = static_cast&lt;float&gt;(y * static_cast&lt;double&gt;(z));\n</code></pre>\n<p>This way everyone knows what you mean and that you mean to be casting things about.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-09-12T21:23:47.310", "Score": "0", "CreationDate": "2012-09-12T21:06:48.593", "ParentId": "12396132", "CommentCount": "6", "OwnerUserId": "1663621", "LastEditDate": "2012-09-12T21:23:47.310"}, "12396208": {"Id": "12396208", "PostTypeId": "2", "Body": "<p>See <a href=\"https://stackoverflow.com/questions/12396132/c-implicit-type-conversion#comment16656609_12396132\">my comments</a>.</p>\n<blockquote>\n<p id=\"so_12396132_12396208_0\">This is well-defined. The intermediate expression for <code>z</code> will undergo widening into <code>double</code>, so <code>y * z</code> will be a <code>double</code> expression. An implicit narrowing conversion will then convert it to <code>float</code> for storing in <code>res2</code>. This same narrowing applies to <code>res1</code>.</p>\n</blockquote>\n<p>This is reflected by <strong>\u00a75\u00b69 Expressions [expr]</strong> of the C++11 standard.</p>\n<blockquote>\n<p id=\"so_12396132_12396208_1\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>\n<p id=\"so_12396132_12396208_2\">...</p>\n<ul>\n<li>Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</li>\n<li>Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.</li>\n</ul>\n<p id=\"so_12396132_12396208_3\">...</p>\n</blockquote>\n<p>This, however, does not sure that the equality will hold.</p>\n<blockquote>\n<p id=\"so_12396132_12396208_4\">That being said, <code>res1</code> need not necessarily be equivalent to <code>res2</code> -- it is highly dependent on the precision of <code>float</code> and <code>double</code> in the environment. The two literals could potentially not even be equal -- <code>4.23423451f</code> not need even be equivalent to <code>4.23423451</code>. You can not be sure that <code>static_cast&lt;double&gt;(static_cast&lt;float&gt;(4.23423451))</code> will be equal to <code>4.23423451</code>. </p>\n</blockquote>\n<p>See <strong>\u00a75.17\u00b63 Assignment and compound assignment operators [expr.ass]</strong>.</p>\n<blockquote>\n<p id=\"so_12396132_12396208_5\">If the left operand is not of class type, the expression is implicitly converted (Clause 4) to the cv-unqualified type of the left operand.</p>\n</blockquote>\n<p><strong>\u00a74 Standard conversions [conv]</strong> states as follows:</p>\n<blockquote>\n<p id=\"so_12396132_12396208_6\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions. A <em>standard conversion sequence</em> is a sequence of standard conversions in the following order:</p>\n<p id=\"so_12396132_12396208_7\">...</p>\n<ul>\n<li>Zero or one conversion from the following set: integral promotions, floating point promotion, integral conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to member conversions, and boolean conversions.</li>\n</ul>\n</blockquote>\n<p>As elaborated in <strong>\u00a74.6 Floating point promotion [conv.fpprom]</strong>,</p>\n<blockquote id=\"so_12396132_12396208_8\">\n<ol>\n<li>A prvalue of type <code>float</code> can be converted to a prvalue of type <code>double</code>. The value is unchanged.</li>\n<li>This conversion is called <em>floating point promotion</em>.</li>\n</ol>\n</blockquote>\n<p>... and <strong>\u00a74.8 Floating point conversions [conv.double]</strong>,</p>\n<blockquote>\n<ol>\n<li><p id=\"so_12396132_12396208_9\">A prvalue of floating point type can be converted to a prvalue of another floating point type. If the source value can be exactly represented in the destination type, the result of the conversion is that exact representation. If the source value is between two adjacent destination values, the result of the conversion is an implementation-defined choice of either of those values. Otherwise, the behavior is undefined.</p></li>\n<li><p id=\"so_12396132_12396208_10\">The conversions allowed as floating point promotions are excluded from the set of floating point conversions.</p></li>\n</ol>\n</blockquote>\n<p>The problem here is that we have multiple cases where our conversion is not <em>promotion</em>, but rather narrowing to a potentially lower-precision type (<code>double</code> to <code>float</code>).</p>\n<p>Essentially, any time you convert <code>double</code> to <code>float</code>, you may potentially lose precision.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-12T21:28:52.393", "Score": "7", "CreationDate": "2012-09-12T21:06:55.717", "ParentId": "12396132", "CommentCount": "0", "OwnerUserId": "591495", "LastEditDate": "2017-05-23T12:07:11.813"}, "12396212": {"Id": "12396212", "PostTypeId": "2", "Body": "<p>No, this is not guaranteed. <code>x</code> and <code>y</code> do not necessarily have the same value. <s>It is true that both are promoted to <code>double</code> in the expressions <code>x * z</code> and <code>y * z</code>, but the result of promoting <code>x</code> to a double need not equal the value of <code>y</code>.</s> Whereas <code>x * z</code> is evaluated as a <code>float</code>, the expression <code>y * z</code> promotes <code>z</code> to double, and the results of the multiplications needn't be equal, so that the conversion back to the narrower type may result in different values.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-09-12T21:33:19.377", "Score": "1", "CreationDate": "2012-09-12T21:07:27.607", "ParentId": "12396132", "CommentCount": "7", "OwnerUserId": "596781", "LastEditDate": "2012-09-12T21:33:19.377"}});