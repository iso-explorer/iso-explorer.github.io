post_cb({"bq_ids": {"n4140": {"so_27698056_27698576_0": {"length": 6, "quality": 1.0, "section_id": 3292}}, "n3337": {"so_27698056_27698576_0": {"length": 6, "quality": 1.0, "section_id": 3162}}, "n4659": {"so_27698056_27698576_0": {"length": 6, "quality": 1.0, "section_id": 4054}}}, "27698179": {"Id": "27698179", "PostTypeId": "2", "Body": "<p>The <code>std::array&lt;SomeThing, 64&gt;</code> class clearly doesn't have access to the <code>private</code> default constructor when it tries to define the instance. You can give it the necessary access by adding</p>\n<pre><code>friend class std::array&lt;SomeThing, 64&gt;;\n</code></pre>\n<p>to the definition of <code>SomeThing</code>.</p>\n", "LastActivityDate": "2014-12-30T00:51:55.547", "Score": "5", "CreationDate": "2014-12-30T00:51:55.547", "ParentId": "27698056", "CommentCount": "0", "OwnerUserId": "1120273"}, "27698056": {"ViewCount": "728", "Body": "<p>Sorry if title is confusing, I couldn't find an easy way to write it in a simple sentence. Anyways, the issue I'm facing:</p>\n<pre><code> // header:\nclass SomeThing\n{\n private:\n   SomeThing() {} // &lt;- so users of this class can't come up\n                  //    with non-initialized instances, but\n                  //    but the implementation can.\n\n   int some_data; // &lt;- a few bytes of memory, the default\n                  //    constructor SomeThing() doesn't initialize it\n public:\n   SomeThing(blablabla ctor arguments);\n\n   static SomeThing getThatThing(blablabla arguments);\n\n   static void generateLookupTables();\n private:\n\n   // declarations of lookup tables\n   static std::array&lt;SomeThing, 64&gt; lookup_table_0;\n   static SomeThing lookup_table_1[64];\n};\n</code></pre>\n<p>The <code>getThatThing</code> function is meant to return an instance from a lookup table.</p>\n<pre><code> // in the implementation file - definitions of lookup tables\n\n std::array&lt;SomeThing, 64&gt; SomeThing::lookup_table_0; // error\n\n SomeThing Something::lookup_table_1[64]; // &lt;- works fine\n</code></pre>\n<p>I just can't use a <code>std::array</code> of <code>Something</code>, unless I add a public ctor <code>SomeThing()</code> in  the class. It works fine with old-style arrays, I can define the array, and fill it up in the <code>SomeThing::generateLookupTables()</code> function. Apparently the type <code>std::array&lt;SomeThing, 64&gt;</code> does not have a constructor. Any ideas on how to make it work, or maybe a better structure for this concept?</p>\n<p>============= EDIT =======</p>\n<p>The <code>friend std::array&lt;SomeThing, 64&gt;</code> approach seems like a nice idea, but:</p>\n<p>It is going to be used in arrays in other places as well. I would like to guarantee this class to always keep certain invariants towards to external users. With this friendly array, a user can accidentally create an uninitialised array of <code>SomeThing</code>.</p>\n<p>Also, the lookup tables are generated using a rather complicated process, can't be done per inline, as in <code>std::array&lt;SomeThing, 64&gt; SomeThing::lookup_table_0(some value)</code></p>\n", "AcceptedAnswerId": "27698576", "Title": "Class with private constructor and static array of itself", "CreationDate": "2014-12-30T00:37:26.523", "Id": "27698056", "CommentCount": "5", "LastEditDate": "2014-12-30T02:57:55.350", "PostTypeId": "1", "LastEditorUserId": "1505939", "LastActivityDate": "2014-12-30T02:57:55.350", "Score": "7", "OwnerUserId": "875023", "Tags": "<c++><c++11><initialization><static-initialization><stdarray>", "AnswerCount": "3"}, "27698172": {"Id": "27698172", "PostTypeId": "2", "Body": "<p>As your constructor is private, <code>std::array</code> can't use it.</p>\n<p>You may add <code>friend class std::array&lt;SomeThing, 64&gt;;</code> in <code>SomeThing</code> to give access to the constructor.</p>\n<p>An alternative is to use the available public constructor to initialize the element of array:</p>\n<pre><code>std::array&lt;SomeThing, 64&gt; SomeThing::lookup_table_0{\n    SomeThing(blablabla_ctor_arguments), ..\n};\n</code></pre>\n<p>EDIT:</p>\n<p>You can even do, if you have your move or copy constructor available:</p>\n<pre><code>std::array&lt;SomeThing, 64&gt; SomeThing::lookup_table_0{ SomeThing() };\n</code></pre>\n<p>to have your whole array default initialized.</p>\n", "LastEditorUserId": "2684539", "LastActivityDate": "2014-12-30T01:44:04.463", "Score": "4", "CreationDate": "2014-12-30T00:50:58.790", "ParentId": "27698056", "CommentCount": "9", "LastEditDate": "2014-12-30T01:44:04.463", "OwnerUserId": "2684539"}, "27698576": {"Id": "27698576", "PostTypeId": "2", "Body": "<p>The solution:</p>\n<pre><code>std::array&lt;SomeThing, 64&gt; SomeThing::lookup_table_0 {{ }};\n</code></pre>\n<p><strong>Note:</strong> as explained <a href=\"https://stackoverflow.com/questions/14178264/c11-correct-stdarray-initialization\">here</a>,  <code>{{}}</code> is required to value-initialize the <code>std::array</code> without warnings in gcc. <code>= {}</code> and <code>{}</code> are correct but gcc warns anyway.  </p>\n<p>The key to the solution is that some form of initializer must be present.</p>\n<hr>\n<p>A terminology check first: all objects are initialized in C++. There are three forms of this, <em>default</em>, <em>value</em> and <em>zero</em>. There are no \"non-initialized\" objects ; objects with no explicit initializer are called <em>default-initialized</em>. In some circumstances this means the member variables of the object may be indeterminate (\"garbage\").</p>\n<p>What is the problem with the no-initializer version? Firstly, the constructor for <code>std::array&lt;SomeThing, 64&gt;</code> is <em>defined as deleted</em> because the declaration <code>std::array&lt;SomeThing, 64&gt; x;</code> would be ill-formed (due to lack of an accessible default constructor for <code>SomeThing</code>, of course).</p>\n<p>That means that any code which attempts to use the default constructor for <code>std::array&lt;SomeThing, 64&gt;</code> is in turn ill-formed. The definition:</p>\n<pre><code>std::array&lt;SomeThing, 64&gt; SomeThing::lookup_table_0;\n</code></pre>\n<p>does attempt to use the default constructor, so it is ill-formed. However once you start introducing initializers, then the default constructor for <code>std::array</code> is no longer in play; since <code>std::array</code> is an <em>aggregate</em> then <em>aggregate initialization</em> occurs which bypasses the implicitly-generated constructor(s).  (If there were any user-declared constructors then it would no longer be an aggregate).</p>\n<p>The version with initializers works because of [dcl.init]/13 (n3936):</p>\n<blockquote>\n<p id=\"so_27698056_27698576_0\">An initializer for a static member is in the scope of the member\u2019s class</p>\n</blockquote>\n<p>The definition of list-initialization transforms <code>{ }</code> to <code>{ SomeThing() }</code> here.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-30T02:50:19.667", "Score": "4", "CreationDate": "2014-12-30T01:44:34.623", "ParentId": "27698056", "CommentCount": "5", "LastEditDate": "2017-05-23T10:33:40.793", "OwnerUserId": "1505939"}});