post_cb({"7138590": {"ParentId": "7134261", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Imagine this code:</p>\n<pre><code>struct B { int data; };\nstruct C { int data; };\n\nstruct A : B, C {\n  void f() {\n    // error: converting \"int B::*\" to \"int*\" ?\n    int *bData = &amp;B::data;\n\n    // OK: a normal pointer\n    int *bData = &amp;(B::data);\n  }\n};\n</code></pre>\n<p>Without the trick with the parentheses, you would not be able to take a pointer directly to B's data member (you would need base-class casts and games with <code>this</code> - not nice). </p>\n<hr>\n<p>From the ARM:</p>\n<blockquote>\n<p id=\"so_7134261_7138590_0\">Note that the address-of operator must be explicitly used to get a pointer to member; there is no implicit conversion ... Had there been, we would have an ambiguity in the context of a member function ... For example, </p>\n<pre><code>void B::f() {\n    int B::* p = &amp;B::i; // OK\n    p = B::i; // error: B::i is an int\n    p = &amp;i; // error: '&amp;i'means '&amp;this-&gt;i' which is an 'int*'\n\n    int *q = &amp;i; // OK\n    q = B::i; // error: 'B::i is an int\n    q = &amp;B::i; // error: '&amp;B::i' is an 'int B::*'\n}\n</code></pre>\n</blockquote>\n<p>The IS just kept this pre-Standard concept and explicitly mentioned that parentheses make it so that you don't get a pointer to member. </p>\n</hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-08-21T14:17:17.253", "Id": "7138590", "Score": "3", "CreationDate": "2011-08-21T13:43:34.430", "LastActivityDate": "2011-08-21T14:17:17.253"}, "7135001": {"ParentId": "7134261", "CommentCount": "7", "Body": "<p>This is just a personal opinion.\nIf <code>&amp;(qualified-id)</code> is allowed as <code>&amp;(unary-expression)</code>,\nqualified-id has to be an expression, and an expression is expected to have a type\n(even if it is incomplete).\nHowever, C++ didn't have a type which denotes a member, had only\na pointer to member.\nFor example, the following code cannot be compiled.</p>\n<pre><code>struct A { int i; };\n\ntemplate&lt; class T &gt; void f( T* );\n\nint main() {\n  (void) typeid( A::i );\n  f( &amp;A::i );\n}\n</code></pre>\n<p>In order to make <code>&amp;(qualified-id)</code> be valid, the compiler has to hold\na member type internally.\nHowever, if we abandon <code>&amp;(qualified-id)</code> notation, the compiler doesn't need\nto handle member type.\nAs member type was always handled in the form of a pointer to it,\nI guess the standard gave priority to simplify the compiler's type\nsystem a little.</p>\n", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "7135001", "Score": "27", "CreationDate": "2011-08-20T22:06:46.340", "LastActivityDate": "2011-08-20T22:06:46.340"}, "bq_ids": {"n4140": {"so_7134261_7134261_1": {"section_id": 6067, "quality": 1.0, "length": 10}}, "n3337": {"so_7134261_7134261_1": {"section_id": 5835, "quality": 1.0, "length": 10}}, "n4659": {"so_7134261_7134261_1": {"section_id": 7563, "quality": 1.0, "length": 10}}}, "7134261": {"CommentCount": "8", "AcceptedAnswerId": "7135001", "PostTypeId": "1", "ClosedDate": "2011-08-21T14:21:53.297", "LastEditorUserId": "-1", "CreationDate": "2011-08-20T19:51:24.173", "LastActivityDate": "2011-08-21T14:17:17.253", "LastEditDate": "2017-05-23T12:16:36.027", "ViewCount": "1754", "FavoriteCount": "4", "Title": "Strange C++ rule for member function pointers?", "Id": "7134261", "Score": "19", "Body": "<blockquote>\n<p id=\"so_7134261_7134261_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/7134197/error-with-address-of-parenthesized-member-function\">Error with address of parenthesized member function</a> </br></p>\n</blockquote>\n<p>In <a href=\"https://stackoverflow.com/questions/7134197/function-pointers/7134218#7134218\">this recent question</a> the OP ran into a strange provision of the C++ language that makes it illegal to take the address of a member function if that member function name is parenthesized.  For example, this code is illegal:</p>\n<pre><code>struct X {\n    void foo();\n};\n\nint main() {\n    void (X::* ptr)();\n    ptr = &amp;(X::foo);   // Illegal; must be &amp;X::foo\n}\n</code></pre>\n<p>I looked this up and found that it's due to \u00a75.3.1/3 of the C++ ISO spec, which reads</p>\n<blockquote>\n<p id=\"so_7134261_7134261_1\">A pointer to member is only formed when an explicit &amp; is used and its operand is a qualified-id not enclosed in parentheses [...]</p>\n</blockquote>\n<p>Does anyone have any idea why the spec has this rule?  It's specific to pointers-to-member, so I would suspect that there is some grammatical ambiguity that this resolves, but I honestly haven't the faintest idea what it might be.</p>\n", "Tags": "<c++><language-lawyer><pointer-to-member>", "OwnerUserId": "501557", "AnswerCount": "2"}});