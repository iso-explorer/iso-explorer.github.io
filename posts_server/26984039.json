post_cb({"26984039": {"ViewCount": "31", "Body": "<p>How can you write all but the first N lines of a stream without corrupting the destination stream?</p>\n<p>For example, the following works fine when the source has n-1 or less lines and when source has n+1 or more lines, but sometimes fails when the source has exactly n lines:</p>\n<pre><code>void copy_all_but_first_n_lines(std::ifstream&amp; source, std::ofstream&amp; dest, size_t n)\n{\n    for (size_t i=0; i&lt;n; ++i)\n    {\n        std::string line;\n        std::getline(source, line);\n    }\n\n    if (source.good()) dest &lt;&lt; source.rdbuf();\n\n    if (!dest.good()) throw std::runtime_error(\"destination turned bad after writing remainder of source\");\n}\n</code></pre>\n<p>With a source with exactly n lines, destination sometimes has the failbit set.</p>\n<p>This failbit is only set when the source has a trailing newline.  I am testing this on Windows, and in a hex editor I see that files with a trailing newline and exactly n lines cause the destination stream to have the failbit set, but files with exactly n lines without a trailing end of line don't result in the failbit set.  All the files I'm testing with have newlines as \"\\r\\n\".</p>\n<p>I tried opening the streams in both text and binary mode, but that didn't change the behavior.</p>\n<hr>\n<p>If I change the code to use <code>std::copy</code> instead of writing the <code>rdbuf</code>, it works regardless of whether or not there is a trailing newline.  According to <a href=\"https://stackoverflow.com/questions/10195343/copy-a-file-in-an-sane-safe-and-efficient-way/10195497\">this</a>, these two should be equivalent -- why is writing rdbuf failing while std::copy succeeds?</p>\n<pre><code>void copy_all_but_first_n_lines(std::ifstream&amp; source, std::ofstream&amp; dest, size_t n)\n{\n    for (size_t i=0; i&lt;n; ++i)\n    {\n        std::string line;\n        std::getline(source, line);\n    }\n\n    if (source.good())\n    {\n        std::istreambuf_iterator&lt;char&gt; begin(source);\n        std::istreambuf_iterator&lt;char&gt; end;\n        std::ostreambuf_iterator&lt;char&gt; destination(dest);\n        std::copy(begin, end, destination);\n    }\n\n    if (!dest.good()) throw std::runtime_error(\"destination turned bad after writing remainder of source\");\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "26984171", "Title": "Write All But First N Lines of Stream Without Corrupting Destination Stream", "CreationDate": "2014-11-17T23:39:55.603", "Id": "26984039", "CommentCount": "0", "LastEditDate": "2017-05-23T12:20:31.120", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-17T23:52:50.557", "Score": "0", "OwnerUserId": "1007353", "Tags": "<c++><windows><newline>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26984039_26984171_1": {"length": 23, "quality": 0.92, "section_id": 2301}, "so_26984039_26984171_0": {"length": 18, "quality": 0.6428571428571429, "section_id": 2205}}, "n3337": {"so_26984039_26984171_1": {"length": 23, "quality": 0.92, "section_id": 2288}, "so_26984039_26984171_0": {"length": 18, "quality": 0.6428571428571429, "section_id": 2193}}, "n4659": {"so_26984039_26984171_1": {"length": 23, "quality": 0.92, "section_id": 2574}, "so_26984039_26984171_0": {"length": 16, "quality": 0.5714285714285714, "section_id": 2478}}}, "26984171": {"Id": "26984171", "PostTypeId": "2", "Body": "<p>Take a look at the standard:</p>\n<blockquote>\n<pre><code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_streambuf&lt;charT,traits&gt;* sb);\n</code></pre>\n<p id=\"so_26984039_26984171_0\">7 <em>Effects:</em> Behaves as an unformatted output function (as described in 27.7.3.7, paragraph 1). After\n  the sentry object is constructed, if <code>sb</code> is null calls <code>setstate(badbit)</code> (which may throw <code>ios_base::failure</code>).<br>\n  8 Gets characters from <code>sb</code> and inserts them in <code>*this</code>. Characters are read from <code>sb</code> and inserted until any of the following occurs:</br></p>\n<ul>\n<li>end-of-file occurs on the input sequence;</li>\n<li>inserting in the output sequence fails (in which case the character to be inserted is not extracted);</li>\n<li>an exception occurs while getting a character from sb.</li>\n</ul>\n<p id=\"so_26984039_26984171_1\">9 If the function inserts no characters, it calls <code>setstate(failbit)</code> (which may throw <code>ios_base::failure</code> (27.5.5.4)). If an exception was thrown while extracting a character, the function sets <code>failbit</code> in error state, and if <code>failbit</code> is on in <code>exceptions()</code> the caught exception is rethrown.</p>\n</blockquote>\n<p>So, they are only equivalent if at least one character will be copied.</p>\n", "LastActivityDate": "2014-11-17T23:52:50.557", "CommentCount": "0", "CreationDate": "2014-11-17T23:52:50.557", "ParentId": "26984039", "Score": "2", "OwnerUserId": "3204551"}});