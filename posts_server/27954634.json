post_cb({"bq_ids": {"n4140": {"so_27954634_27954691_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5974}}, "n3337": {"so_27954634_27954691_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5742}}, "n4659": {"so_27954634_27954691_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7473}}}, "27954634": {"ViewCount": "2164", "Body": "<p>How is it possible that this example works? It prints <code>6</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\nvoid scopeIt(std::function&lt;int()&gt; &amp;fun) {\n    int val = 6;\n    fun = [=](){return val;}; //&lt;-- this\n}\n\nint main() {\n    std::function&lt;int()&gt; fun;\n\n    scopeIt(fun);\n\n    cout &lt;&lt; fun();\n\n    return 0;\n}\n</code></pre>\n<p>Where is the value <code>6</code> stored after <code>scopeIt</code> is done being called? If I replace the <code>[=]</code> with a <code>[&amp;]</code>, it prints <code>0</code> instead of <code>6</code>.</p>\n", "AcceptedAnswerId": "27954672", "Title": "Where are lambda captured variables stored?", "CreationDate": "2015-01-14T23:53:16.463", "Id": "27954634", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2016-11-02T14:24:06.280", "Score": "22", "OwnerUserId": "2159051", "Tags": "<c++><memory><lambda>", "AnswerCount": "4"}, "27954672": {"Id": "27954672", "PostTypeId": "2", "Body": "<p>It is stored within the closure, which - in your code - is then stored within <code>std::function&lt;int()&gt; &amp;fun</code>.</p>\n<p>A lambda generates what's equivalent to an instance of a compiler generated class.</p>\n<p>This code:</p>\n<pre><code>[=](){return val;}\n</code></pre>\n<p>Generates what's effectively equivalent to this... this would be the \"closure\":</p>\n<pre><code>struct UNNAMED_TYPE\n{\n  UNNAMED_TYPE(int val) : val(val) {}\n  const int val;\n  // Above, your [=] \"equals/copy\" syntax means \"find what variables\n  //           are needed by the lambda and copy them into this object\"\n\n  int operator() () const { return val; }\n  // Above, here is the code you provided\n\n} (val);\n// ^^^ note that this DECLARED type is being INSTANTIATED (constructed) too!!\n</code></pre>\n", "LastEditorUserId": "16287", "LastActivityDate": "2016-11-02T14:24:06.280", "Score": "19", "CreationDate": "2015-01-14T23:57:17.180", "ParentId": "27954634", "CommentCount": "10", "OwnerUserId": "16287", "LastEditDate": "2016-11-02T14:24:06.280"}, "27954711": {"Id": "27954711", "PostTypeId": "2", "Body": "<p>Lambdas in C++ are really just \"anonymous\" struct functors. So when you write this:</p>\n<pre><code>int val = 6;\nfun = [=](){return val;};\n</code></pre>\n<p>What the compiler is translating that into is this:</p>\n<pre><code>int val = 6;\nstruct __anonymous_struct_line_8 {\n    int val;\n    __anonymous_struct_line_8(int v) : val(v) {}\n\n    int operator() () const {\n        return val; // returns this-&gt;val\n    }\n};\n\nfun = __anonymous_struct_line_8(val);\n</code></pre>\n<p>Then, <code>std::function</code> stores that functor via <a href=\"http://www.cplusplus.com/articles/oz18T05o/\">type erasure</a>.</p>\n<p>When you use <code>[&amp;]</code> instead of <code>[=]</code>, it changes the struct to:</p>\n<pre><code>struct __anonymous_struct_line_8 {\n    int&amp; val; // Notice this is a reference now!\n    ...\n</code></pre>\n<p>So now the object stores a reference to the function's <code>val</code> object, which becomes a dangling (invalid) reference after the function exits (and you get undefined behavior).</p>\n", "LastActivityDate": "2015-01-15T00:01:31.143", "CommentCount": "1", "CreationDate": "2015-01-15T00:01:31.143", "ParentId": "27954634", "Score": "13", "OwnerUserId": "1287251"}, "27954699": {"Id": "27954699", "PostTypeId": "2", "Body": "<p>The so-called <em>closure type</em> (which is the class type of the lambda expression) has members for each captured entity. Those members are objects for capture by value, and references for capture by reference. They are initialized with the captured entities and live independently within the <em>closure object</em> (the particular object of closure type that this lambda designates).</p>\n<p>The unnamed member that corresponds to the value capture of <code>val</code> is initialized with <code>val</code> and accessed from the inside of the closure types <code>operator()</code>, which is fine. The closure object may easily have been copied or moved multiple times until that happens, and that's fine too - closure types have implicitly defined move and copy constructors just as normal classes do.<br>\nHowever, when capturing by reference, the lvalue-to-rvalue conversion that is implicitly performed when calling <code>fun</code> in <code>main</code> induces undefined behavior as <strong>the object which the reference member referred to has already been destroyed</strong> - i.e. we are using a dangling reference.</br></p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-15T00:10:43.633", "Score": "7", "CreationDate": "2015-01-14T23:59:39.480", "ParentId": "27954634", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-01-15T00:10:43.633"}, "27954691": {"Id": "27954691", "PostTypeId": "2", "Body": "<p>The value of a lambda expression is an object of <em>class</em> type, and</p>\n<blockquote>\n<p id=\"so_27954634_27954691_0\">For each entity\n  captured by copy, an unnamed non-static data member is declared in the closure type.</p>\n</blockquote>\n<p>([expr.prim.lambda]/14 in C++11)</p>\n<p>That is, the object created by the lambda</p>\n<pre><code>[=](){return val;}\n</code></pre>\n<p>actually contains a non-static member of <code>int</code> type, whose value is 6, and this object is copied into the <code>std::function</code> object.</p>\n", "LastActivityDate": "2015-01-14T23:58:56.667", "CommentCount": "0", "CreationDate": "2015-01-14T23:58:56.667", "ParentId": "27954634", "Score": "2", "OwnerUserId": "481267"}});