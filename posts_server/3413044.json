post_cb({"3413044": {"CommentCount": "3", "ViewCount": "1885", "CreationDate": "2010-08-05T08:42:28.197", "LastActivityDate": "2010-08-05T09:44:06.043", "Title": "Declaring and defining a function object inside a class member function", "AcceptedAnswerId": "3413386", "PostTypeId": "1", "Id": "3413044", "Score": "0", "Body": "<p>I wonder if and how it is possible to define a function object inside a classes member function to use it directly with, for example, the std::transform function.<br>\nI know the example is a bit stupid, it's just to show the problem I'm confronted with.  </br></p>\n<p>File \"example.h\"</p>\n<pre><code>class Example {\n  public:\n  //.. constructor and destructor stuff\n    std::string toString() const; //Converts 'mVal' to a std::string\n\n  private:\n    std::vector&lt;int&gt; mVal; //Only one digit numbers are allowed ([0-9])\n}\n</code></pre>\n<p>File \"example.cpp\"</p>\n<pre><code>std::string Example::toString() const\n{ \n  //The functor which should be used in std::transform\n  struct {\n    char operator()(const int number) {\n      char c;\n      //\"Convert\" 'number' to a char\n      return c;\n    };\n  } functor;\n\n  //Transform the integers to char\n  std::string str(mVal.size(), '0'); //Allocate enough space\n  std::transform(mVal.begin(), mVal.end(), str.begin(), functor);\n  return str;\n\n};//toString()\n</code></pre>\n<p>Ever since I tried to implement a function object directly inside a member function like in \"example.cpp\", the code doesn't get compiled. The error message I get is:</p>\n<pre><code>error: no matching function for call to \u2018transform(__gnu_cxx::__normal_iterator&lt;const int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;const int*, std::vector&lt;int, std::allocator&lt;int&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;char*, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, Example::toString() const::&lt;anonymous struct&gt;&amp;)\u2019\n</code></pre>\n<p>So I think the problem comes up when using the struct \"functor\" in std::transform. Can someone tell me what the problem is?</p>\n<p>Using:<br>\ngcc-4.2 compiler under Ubuntu Linux.</br></p>\n<p>Thanks in advance,<br>\nRen\u00e9.</br></p>\n", "Tags": "<c++><stl><stl-algorithm><function-object>", "OwnerUserId": "411641", "AnswerCount": "2"}, "3413386": {"ParentId": "3413044", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-08-05T09:29:36.557", "Score": "4", "LastEditorUserId": "385433", "LastEditDate": "2010-08-05T09:44:06.043", "Id": "3413386", "OwnerUserId": "385433", "Body": "<p>As Alexandre already pointed out, you can't use an type with function scope (or no name at all) as a template parameter. You can however use a static member function of a local type as a functor parameter: </p>\n<pre><code>int main()\n{\n    struct F {\n        static int fn(int x)\n        {\n            return x+x;\n        }\n    }; \n\n    int v[5]={1,2,3,4,5};\n    std::transform(v+0,v+5,v+0,F::fn);\n}\n</code></pre>\n<p>If you need to a local state in your function and don't want to resort to the type erasure idiom, then you can cheat with casting the local type away: </p>\n<pre><code>int main()\n{\n    struct F {\n        int k;\n        int call (int n) const \n        {\n\n            return n+k;\n        }\n        static int fn(void *p, int x)\n        {\n            return ((F*)p)-&gt;call(x); \n        }\n    }; \n\n    int v[5]={1,2,3,4,5};\n    F f;\n    f.k=123;\n    std::transform(v+0,v+5,v+0,std::bind1st(std::ptr_fun(F::fn),(void*)&amp;f));\n}\n</code></pre>\n", "LastActivityDate": "2010-08-05T09:44:06.043"}, "3413155": {"ParentId": "3413044", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-08-05T08:59:03.703", "Score": "2", "LastEditorUserId": "373025", "LastEditDate": "2010-08-05T09:31:30.890", "Id": "3413155", "OwnerUserId": "373025", "Body": "<p>Sadly, this won't work. Standard disallows local classes to be used as template arguments, so the approach fails <strike>(please someone, quote the relevant part of the Standard)</strike>:</p>\n<blockquote>\n<p id=\"so_3413044_3413155_0\">14.3.1/2: \"A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types\n  shall not be used as a\n  template-argument for a template\n  type-parameter.\"</p>\n</blockquote>\n<p>If you have access to a C++0x compiler this works though.</p>\n<p>Local classes could have been powerful, but their use is somewhat limited to the \"type erasure idiom\":</p>\n<pre><code>struct abstract_foo { ... };\n\ntemplate &lt;typename T&gt;\nabstract_foo* make_concrete_foo(...)\n{\n    struct foo : abstract_foo\n    {\n        // Depends on T\n    };\n\n    return new foo(...);\n}\n</code></pre>\n", "LastActivityDate": "2010-08-05T09:31:30.890"}, "bq_ids": {"n4140": {"so_3413044_3413155_0": {"section_id": 7141, "quality": 0.6153846153846154, "length": 8}}, "n3337": {"so_3413044_3413155_0": {"section_id": 6885, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_3413044_3413155_0": {"section_id": 8642, "quality": 0.6153846153846154, "length": 8}}}});