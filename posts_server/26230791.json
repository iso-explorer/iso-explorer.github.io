post_cb({"26230791": {"ViewCount": "4028", "Body": "<p><sub>(<em>Note: This is intended to be a <a class=\"post-tag\" href=\"/questions/tagged/language-lawyer\" rel=\"tag\" title=\"show questions tagged 'language-lawyer'\">language-lawyer</a> question; I'm not referring to any particular existing compilers.</em>)</sub></p>\n<p>When, if ever, is the compiler allowed to degrade the time complexity of a program?<br>\nUnder what circumstances (if any) is this considered \"observable behavior\", and why?<br>\n(For example, can the compiler legally \"reduce\" a polynomial-time program to an exponential-time one?)</br></br></p>\n<p>If the answer differs in C and C++, or in different versions of either, then please explain the differences.</p>\n", "AcceptedAnswerId": "26231031", "Title": "Is it legal for the compiler to degrade the time complexity of a program? Is this considered observable behavior?", "CreationDate": "2014-10-07T07:32:34.510", "Id": "26230791", "CommentCount": "24", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-10-07T07:35:38.360", "LastEditorUserId": "204690", "LastActivityDate": "2014-10-08T09:57:40.677", "Score": "42", "OwnerUserId": "541686", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "4"}, "26234699": {"Id": "26234699", "PostTypeId": "2", "Body": "<p>5.1.2.3 in the C standard says </p>\n<blockquote>\n<p id=\"so_26230791_26234699_0\">The semantic descriptions in this International Standard describe the behavior of an\n  abstract machine in which issues of optimization are irrelevant.</p>\n</blockquote>\n<p>The C++ standard has similar wording in 1.9 [intro.execution]</p>\n<p>Both standards have the same definition of observable behaviour:</p>\n<blockquote>\n<p id=\"so_26230791_26234699_1\">The least requirements on a conforming implementation are:<br>\n  \u2014 Accesses to volatile objects are evaluated strictly according to the rules of the abstract\n  machine.<br>\n  \u2014 At program termination, all data written into files shall be identical to the result that\n  execution of the program according to the abstract semantics would have produced.<br>\n  \u2014 The input and output dynamics of interactive devices shall take place as specified in\n  7.21.3. The intent of these requirements is that unbuffered or line-buffered output\n  appear as soon as possible, to ensure that prompting messages actually appear prior to\n  a program waiting for input.<br>\n  This is the <em>observable behavior</em> of the program.</br></br></br></br></p>\n</blockquote>\n<p>So anything else, e.g. performance of a <code>for</code> loop, or the number of reads/writes done for non-volatile variables, is not considered observable and so there are no corresponding performance requirements on the compiler.</p>\n<p>If the compiler wanted to re-evaluate a block of code 100 times (assuming it had no observable side-effects, only altering the state of non-volatile variables) and check that the same results were obtained every time (and not affected by cosmic rays or faulty hardware) that would be allowed by the standard.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2014-10-07T11:18:09.640", "Score": "16", "CreationDate": "2014-10-07T11:12:42.370", "ParentId": "26230791", "CommentCount": "2", "OwnerUserId": "981959", "LastEditDate": "2014-10-07T11:18:09.640"}, "26231121": {"Id": "26231121", "PostTypeId": "2", "Body": "<p>Performance of the code is not considered observable behavior and could potentially be modified by the compiler in either direction. In practical terms, for <em>quality of implementation</em> (QoI) reasons compilers don't degrade your programs, but there are cases where QoI is not performance.</p>\n<p>A compiler, given the appropriate flags, could add instrumentation to the program it is building for debugging purposes (this is often the case in library implementations, for example with checked iterators).</p>\n<p>Note that the simple answer to <em>when</em> the compiler would degrade your program is twofold: when the client asks for it, or when the implementor doesn't want to have users for the compiler.</p>\n", "LastEditorUserId": "815724", "LastActivityDate": "2014-10-07T09:14:52.290", "Score": "24", "CreationDate": "2014-10-07T07:52:27.193", "ParentId": "26230791", "CommentCount": "0", "OwnerUserId": "36565", "LastEditDate": "2014-10-07T09:14:52.290"}, "bq_ids": {"n4140": {"so_26230791_26234699_1": {"length": 36, "quality": 0.6101694915254238, "section_id": 5804}, "so_26230791_26231031_0": {"length": 14, "quality": 1.0, "section_id": 6224}}, "n3337": {"so_26230791_26231031_0": {"length": 14, "quality": 1.0, "section_id": 5984}, "so_26230791_26234699_1": {"length": 36, "quality": 0.6101694915254238, "section_id": 5577}}, "n4659": {"so_26230791_26231031_0": {"length": 14, "quality": 1.0, "section_id": 7727}, "so_26230791_26234699_1": {"length": 36, "quality": 0.6101694915254238, "section_id": 7262}}}, "26231031": {"Id": "26231031", "PostTypeId": "2", "Body": "<p>The C standard doesn't actually have a time complexity model, neither for its primitive operations, nor its library functions, so compilers are allowed to do pretty much anything that preserves program semantics (observable behavior).</p>\n<p>The C++ standard only gives complexity guarantees only for some its library functions, and says (17.5.1.4 [structure.specifications]):</p>\n<blockquote>\n<p id=\"so_26230791_26231031_0\">Complexity requirements specified in the library clauses are upper bounds, and implementations that provide better complexity guarantees satisfy the requirements.</p>\n</blockquote>\n<p>A compiler better preserve these bounds (and since many of the functions are templated/may be inlined, the compiler is involved), but the bounds are in terms of the number of elements in containers and restrict the number of calls to comparison operators and the like. Otherwise, the compiler is again free to do as it pleases.</p>\n", "LastEditorUserId": "166749", "LastActivityDate": "2014-10-08T09:57:40.677", "Score": "42", "CreationDate": "2014-10-07T07:46:37.810", "ParentId": "26230791", "CommentCount": "5", "OwnerUserId": "166749", "LastEditDate": "2014-10-08T09:57:40.677"}, "26240281": {"Id": "26240281", "PostTypeId": "2", "Body": "<p>Others have pointed out that the standard doesn't constrain how the C runtime works, only its observable behaviour. There is no reason why you can't have interpreted or JIT-compiled C, for example.</p>\n<p>Consider a C implementation where all memory cells are stored in a linked list on some underlying system. Pointers are then an index into this linked list. All pointer operations would function as normal, except the runtime would have to iterate over the linked list on every memory access. All sorts of common algorithms would suddenly gain an extra factor of N in their complexity, for example the common null-terminated string operations.</p>\n", "LastActivityDate": "2014-10-07T15:59:23.437", "CommentCount": "0", "CreationDate": "2014-10-07T15:59:23.437", "ParentId": "26230791", "Score": "9", "OwnerUserId": "108719"}});