post_cb({"bq_ids": {"n4140": {"so_27713666_27714133_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 170}, "so_27713666_27713666_5": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_27713666_27713666_3": {"length": 11, "quality": 0.55, "section_id": 6105}, "so_27713666_27713666_11": {"length": 5, "quality": 1.0, "section_id": 198}, "so_27713666_27713666_10": {"length": 13, "quality": 1.0, "section_id": 198}, "so_27713666_27714133_3": {"length": 13, "quality": 1.0, "section_id": 198}, "so_27713666_27713666_13": {"length": 10, "quality": 1.0, "section_id": 203}, "so_27713666_27714133_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 198}, "so_27713666_27714133_5": {"length": 10, "quality": 1.0, "section_id": 203}}, "n3337": {"so_27713666_27714133_3": {"length": 13, "quality": 1.0, "section_id": 192}, "so_27713666_27713666_5": {"length": 10, "quality": 1.0, "section_id": 5946}, "so_27713666_27713666_3": {"length": 18, "quality": 0.9, "section_id": 5871}, "so_27713666_27713666_11": {"length": 5, "quality": 1.0, "section_id": 192}, "so_27713666_27713666_10": {"length": 13, "quality": 1.0, "section_id": 192}, "so_27713666_27714133_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 164}, "so_27713666_27713666_13": {"length": 10, "quality": 1.0, "section_id": 197}, "so_27713666_27714133_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 192}, "so_27713666_27714133_5": {"length": 10, "quality": 1.0, "section_id": 197}}, "n4659": {"so_27713666_27714133_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 175}, "so_27713666_27713666_3": {"length": 11, "quality": 0.55, "section_id": 7602}, "so_27713666_27713666_11": {"length": 5, "quality": 1.0, "section_id": 204}, "so_27713666_27713666_10": {"length": 13, "quality": 1.0, "section_id": 204}, "so_27713666_27714133_3": {"length": 13, "quality": 1.0, "section_id": 204}, "so_27713666_27713666_13": {"length": 10, "quality": 1.0, "section_id": 209}, "so_27713666_27714133_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 204}, "so_27713666_27714133_5": {"length": 10, "quality": 1.0, "section_id": 209}}}, "27713666": {"ViewCount": "143", "Body": "<p>Both gcc 5.0 and clang 3.6 require the <code>typename</code> keyword in the following example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    typedef int Type;\n};\n\ntemplate&lt;int n&gt;\nstruct A\n{\n    typedef typename B&lt;decltype(throw (int*)n)&gt;::Type Throw;\n    typedef typename B&lt;decltype(delete (int*)n)&gt;::Type Delete;\n};\n</code></pre>\n<p>This is covered by the following wording in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_27713666_27713666_0\">[except]/2</p>\n<p id=\"so_27713666_27713666_1\">A throw-expression is of type void.</p>\n<p id=\"so_27713666_27713666_2\">[expr.delete]/1</p>\n<p id=\"so_27713666_27713666_3\">The operand shall have a pointer to object type, or a class type having a single non-explicit conversion\n  function to a pointer to object type. The result has type void.</p>\n</blockquote>\n<p>So I'm assuming <code>decltype</code> produces <code>void</code> in both cases.</p>\n<blockquote>\n<p id=\"so_27713666_27713666_4\">[expr.const]/2</p>\n<p id=\"so_27713666_27713666_5\">A conditional-expression is a core constant expression unless it involves one of the following as a potentially\n  evaluated subexpression</p>\n<ul>\n<li><p id=\"so_27713666_27713666_6\">a new-expression</p></li>\n<li><p id=\"so_27713666_27713666_7\">a throw-expression</p></li>\n</ul>\n</blockquote>\n<p>This suggests that an expression involving either <code>throw</code> or <code>delete</code> cannot be a constant expression.</p>\n<blockquote>\n<p id=\"so_27713666_27713666_8\">[temp.dep.type]/8</p>\n<p id=\"so_27713666_27713666_9\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_27713666_27713666_10\">a simple-template-id in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent</p></li>\n<li><p id=\"so_27713666_27713666_11\">denoted by <code>decltype(expression)</code>, where expression is type-dependent</p></li>\n</ul>\n</blockquote>\n<p>So <code>B&lt;decltype(..)&gt;</code> is dependent only if the expression is type-dependent.</p>\n<blockquote>\n<p id=\"so_27713666_27713666_12\">[temp.dep.expr]/4</p>\n<p id=\"so_27713666_27713666_13\">Expressions of the following forms are never type-dependent (because the type of the expression cannot be\n  dependent):</p>\n<pre><code>delete cast-expression\nthrow assignment-expression\n</code></pre>\n</blockquote>\n<p>This suggests that neither expression can be type-dependent.</p>\n<p>Are gcc and clang both wrong? </p>\n", "AcceptedAnswerId": "27714133", "Title": "Can a throw or delete expression ever be dependent?", "CreationDate": "2014-12-30T22:46:02.683", "Id": "27713666", "CommentCount": "3", "LastEditDate": "2014-12-31T11:07:08.840", "PostTypeId": "1", "LastEditorUserId": "1690864", "LastActivityDate": "2014-12-31T11:07:08.840", "Score": "7", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><dependent-type><compiler-bug>", "AnswerCount": "1"}, "27714133": {"Id": "27714133", "PostTypeId": "2", "Body": "<p>Let's go back to when <code>typename</code> is required. \u00a714.6 [temp.res]/p3, all quotes are from N4140:</p>\n<blockquote>\n<p id=\"so_27713666_27714133_0\">When a <em>qualified-id</em> is intended to refer to a type that is not a\n  member of the current instantiation (14.6.2.1) and its\n  <em>nested-name-specifier</em> refers to a dependent type, it shall be prefixed by the keyword <code>typename</code>, forming a <em>typename-specifier</em>.</p>\n</blockquote>\n<p>The <em>qualified-id</em> in this case is <code>B&lt;decltype(throw (int*)n)&gt;::Type</code> (and the <code>delete</code> version, for which the analysis is exactly the same). So <code>typename</code> is required if the <em>nested-name-specifier</em>, or <code>B&lt;decltype(throw (int*)n)&gt;::</code>, refers to a dependent type. </p>\n<p>\u00a714.6.2.1 [temp.dep.type]/p8 says, with six unrelated bullets omitted, that</p>\n<blockquote>\n<p id=\"so_27713666_27714133_1\">A type is dependent if it is</p>\n<p id=\"so_27713666_27714133_2\">[...]</p>\n<p id=\"so_27713666_27714133_3\">(8.7) \u2014 a <em>simple-template-id</em> in which either the template name is a\n  template parameter or any of the template arguments is a dependent\n  type or an expression that is type-dependent or value-dependent, or</p>\n<p id=\"so_27713666_27714133_4\">(8.8) \u2014 denoted by <code>decltype(</code><em>expression</em><code>)</code>, where <em>expression</em> is type-dependent (14.6.2.2).</p>\n</blockquote>\n<p><code>B&lt;decltype(throw (int*)n)&gt;</code> is a <em>simple-template-id</em>. The template name, <code>B</code>, is not a template parameter. The only template argument, <code>decltype(throw (int*)n)</code>, is not an expression, so <code>B&lt;decltype(throw (int*)n)&gt;</code> is dependent only if <code>decltype(throw (int*)n)</code> is a dependent type. <code>decltype(throw (int*)n)</code>, in turn, per bullet 8.8, is only dependent if <code>throw (int*)n</code> is type-dependent. But we know that, per \u00a714.6.2.2 [temp.dep.expr]/p4:</p>\n<blockquote>\n<p id=\"so_27713666_27714133_5\">Expressions of the following forms are never type-dependent (because\n  the type of the expression cannot be dependent):</p>\n<p id=\"so_27713666_27714133_6\">[...]</p>\n<p id=\"so_27713666_27714133_7\"><code>::</code><sub><em>opt</em></sub> <code>delete</code> <em>cast-expression</em></p>\n<p id=\"so_27713666_27714133_8\">[...]</p>\n<p id=\"so_27713666_27714133_9\"><code>throw</code> <em>assignment-expression<sub>opt</sub></em></p>\n<p id=\"so_27713666_27714133_10\">[...]</p>\n</blockquote>\n<p>Therefore, <code>throw (int*)n</code> is not type-dependent, and so <code>decltype(throw (int*)n)</code> is not a dependent type, and so <code>B&lt;decltype(throw (int*)n)&gt;</code> is not a dependent type, and so <code>typename</code> is not required for <code>B&lt;decltype(throw (int*)n)&gt;::Type</code>, and so yes, this is a compiler bug.</p>\n", "LastActivityDate": "2014-12-30T23:33:28.360", "Score": "7", "CreationDate": "2014-12-30T23:33:28.360", "ParentId": "27713666", "CommentCount": "1", "OwnerUserId": "2756719"}});