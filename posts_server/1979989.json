post_cb({"1979989": {"CommentCount": "0", "ViewCount": "150", "CreationDate": "2009-12-30T12:36:12.223", "LastActivityDate": "2009-12-30T12:40:48.910", "Title": "Is using \"operator &\" on a reference a portable C++ construct?", "AcceptedAnswerId": "1980011", "PostTypeId": "1", "Id": "1979989", "Score": "2", "Body": "<p>Suppose I have:</p>\n<pre><code>void function1( Type* object ); //whatever implementation\nvoid function2( Type&amp; object )\n{\n    function1( &amp;object );\n}\n</code></pre>\n<p>supposing <code>Type</code> doesn't have an overloaded <code>operator &amp;()</code> will this construct - using <code>operator &amp;</code> on a reference - obtain the actual address of the object (variable of <code>Type</code> type) on all decently standard-compliant C++ compilers?</p>\n", "Tags": "<c++><pointers><reference>", "OwnerUserId": "57428", "AnswerCount": "3"}, "1980000": {"ParentId": "1979989", "CommentCount": "0", "CreationDate": "2009-12-30T12:38:23.407", "OwnerUserId": "204046", "PostTypeId": "2", "Id": "1980000", "Score": "2", "Body": "<p>Yes, in 15 characters or more.</p>\n", "LastActivityDate": "2009-12-30T12:38:23.407"}, "1980008": {"ParentId": "1979989", "CommentCount": "2", "Body": "<p>Yes, it takes the address of the object referred to. Once you have an initialised reference, ALL operations on it are performed on the referred to object.</p>\n<p>This is actually a fairly frequently used trope:</p>\n<pre><code>struct A {\n    A( X &amp; x ) : myx( &amp;x ) {}\n    X * myx;\n};\n</code></pre>\n", "Id": "1980008", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "4", "CreationDate": "2009-12-30T12:40:16.150", "LastActivityDate": "2009-12-30T12:40:16.150"}, "bq_ids": {"n4140": {"so_1979989_1980011_0": {"section_id": 5938, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_1979989_1980011_0": {"section_id": 5710, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_1979989_1980011_0": {"section_id": 7422, "quality": 0.8947368421052632, "length": 17}}}, "1980011": {"ParentId": "1979989", "CommentCount": "0", "CreationDate": "2009-12-30T12:40:48.910", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "1980011", "Score": "6", "Body": "<p>Yes, and the reason is that on the very beginning of evaluating any expression, references are being replaced by the object that's referenced, as defined at <code>5[expr]/6</code> in the Standard. That will make it so the <code>&amp;</code>-operator doesn't see any difference:</p>\n<blockquote>\n<p id=\"so_1979989_1980011_0\">If an expression initially has the type \"reference to T\" (8.3.2, 8.5.3), the type is adjusted to \"T\" prior to any further analysis, the expression designates the object or function denoted by the reference, and the expression is an lvalue.</p>\n</blockquote>\n<p>This makes it so that any operator that operates on an expression \"sees through\" the reference. </p>\n", "LastActivityDate": "2009-12-30T12:40:48.910"}});