post_cb({"bq_ids": {"n4140": {"so_33863069_33878015_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 177}}, "n3337": {"so_33863069_33878015_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 171}}, "n4659": {"so_33863069_33878015_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 182}}}, "33863191": {"Id": "33863191", "PostTypeId": "2", "Body": "<p>It is not unusual with templates that when writing them, you <em>assume</em> something about the template arguments. i.e:</p>\n<pre><code>Template&lt;class T&gt;\nclass C\n{ \n    void foo() { T.bar(); }\n};\n</code></pre>\n<p>Even though we dont know if <code>T</code> will actually have a method <code>bar()</code>, the compiler accepts it at the moment, because it is just a \"template\", not actual code. At the time when you <em>instantiate</em> a template, with some arguments, the compiler will check for the correctness of what you assumed, because now it has to generate code.</p>\n<p>In the case of functions it is the same. <strong>The same logic must apply unless somebody finds an explicit statement about it in the standard</strong>, which I tried to find and didn't.</p>\n<p>If we follow this logic, when you wrote the template of <code>LoadLight</code>, you <em>assumed</em> that there exists such a function called <code>LoadLightSpecific&lt;T&gt;</code>. In other words,</p>\n<p><strong>Why would <code>T.bar()</code> and <code>bar&lt;T&gt;()</code> be accepted in a class template, but not in a function template?</strong></p>\n<p>The templated function is not translated at the place of its templated definition, but when it is actually called (similar to the <em>instantiation</em> of a templated class) with some specific template argument. If at that place, all what is needed is available (<code>LoadLightSpecific</code> declared), then it will work fine.</p>\n<p>However, I think that it is good practice to, as much as possible, have things declared at the place of the template definition. This will make it easier to track the dependencies.</p>\n", "LastEditorUserId": "4926357", "LastActivityDate": "2015-11-23T18:40:05.613", "Score": "4", "CreationDate": "2015-11-23T03:11:01.320", "ParentId": "33863069", "CommentCount": "5", "OwnerUserId": "4926357", "LastEditDate": "2015-11-23T18:40:05.613"}, "33863069": {"ViewCount": "122", "Body": "<p>I am trying to create an abstraction about Lights (I'm building a game in C++) and I'm using templates to do that. A part of my code right now is:</p>\n<pre><code>// Light.hpp\ntemplate &lt;typename LightType&gt;\nvoid LoadLight(GLuint shaderId, const LightType&amp; light, const std::string&amp; glslUniformName)\n{\n    // Load common light attributes\n    glUniform3f(glGetUniformLocation(lightingShader.GetProgID(), (glslUniformName + \".ambient\").c_str()),  light.ambient.x,  light.ambient.y,  light.ambient.z);\n    glUniform3f(glGetUniformLocation(lightingShader.GetProgID(), (glslUniformName + \".diffuse\").c_str()),  light.diffuse.x,  light.diffuse.y,  light.diffuse.z);\n    glUniform3f(glGetUniformLocation(lightingShader.GetProgID(), (glslUniformName + \".specular\").c_str()), light.specular.x, light.specular.y, light.specular.z);\n\n    // Load specific light attributes\n    LoadLightSpecific&lt;LightType&gt;(shaderId, light, glslUniformName); // ???\n}\n\ntemplate &lt;typename LightType&gt;\nvoid LoadLightSpecific(GLuint shaderId, const LightType&amp; light, const std::string&amp; glslUniformName);\n</code></pre>\n<p>The specializations for <code>LoadLightSpecific</code> is on a separate <code>.cpp</code> file which is irrelevant with my question.</p>\n<p>My problem is in the line with the <code>???</code>.\nI am using <code>LoadLightSpecific</code> before I define it! I thought that this would give me a <code>undeclared identifier</code> (or something like that) compile error but no. It works normally.</p>\n<p>Why is that happening? I feel like I am missing something obvious.</p>\n<p><strong>Update 23/11/2015</strong></p>\n<p>So, as people recommended in comments I used Wandbox to recreate the problem with minimal code. I ended up <a href=\"http://melpon.org/wandbox/permlink/bXlDn2sjwC8360qw\" rel=\"nofollow\">here</a>. Apparently, the answer to my question seems to be:</p>\n<p>\"The code <strong>should</strong> not compile but somehow MSVC works his way around the problem\"</p>\n", "Title": "Why my C++ templated function does not produce `undeclared identified` compile error?", "CreationDate": "2015-11-23T02:53:49.770", "LastActivityDate": "2015-11-23T18:40:05.613", "CommentCount": "15", "LastEditDate": "2015-11-23T14:19:18.123", "PostTypeId": "1", "LastEditorUserId": "3671272", "Id": "33863069", "Score": "3", "OwnerUserId": "3671272", "Tags": "<c++><templates>", "AnswerCount": "2"}, "33878015": {"Id": "33878015", "PostTypeId": "2", "Body": "<p>For this particular code:</p>\n<p>If there's a function template called <code>LoadLightSpecific</code> in scope at the point of definition, then this template definition is valid by itself. (It doesn't have to have that signature; even <code>template&lt;int&gt; void LoadLightSpecific();</code> will do.)</p>\n<p>The reason for this is that the compiler must know <code>LoadLightSpecific</code> is a template in order to parse the <code>&lt;</code> as the start of a template argument list, rather than the less-than operator. </p>\n<p>Since <code>LoadLightSpecific&lt;LightType&gt;</code>, if parsed as a <em>template-id</em>, is dependent on a template parameter, name lookup for <code>LoadLightSpecific</code> is postponed until instantiation. (Note that this does not mean instantiation will necessarily succeed: a declaration that is not in the template definition context can only be found in the instantiation context by ADL, not by normal unqualified lookup.)</p>\n<hr>\n<p>In the more general case, the standard <a href=\"http://eel.is/c++draft/temp.res\" rel=\"nofollow\">specifies</a> what names are considered dependent on a template parameter and what aren't. Non-dependent names are looked up and bound at the point of template definition:</p>\n<blockquote>\n<p id=\"so_33863069_33878015_0\">If a name does not depend on a <em>template-parameter</em> (as defined in\n  14.6.2), a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template\n  definition; the name is bound to the declaration (or declarations)\n  found at that point and this binding is not affected by declarations\n  that are visible at the point of instantiation. </p>\n</blockquote>\n<hr>\n<p>MSVC is well-known for its nonconformance in this area.</p>\n</hr></hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2015-11-23T18:33:47.070", "Score": "0", "CreationDate": "2015-11-23T18:28:41.313", "ParentId": "33863069", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2015-11-23T18:33:47.070"}});