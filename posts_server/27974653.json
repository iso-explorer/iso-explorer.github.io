post_cb({"27974653": {"ViewCount": "1421", "Body": "<p>I read about the inheritance mechanism in C++ and about virtual functions.</p>\n<p>according to my knowlendge (in all examples I have encountered), inherited methods had the same signature as the parent class'.</p>\n<p>My question is the following: \nI know that function default parameter value is not a part of function signature.</p>\n<p>Can I define this value to be some constant in the parent Class virtual function, and in the derived class declare and implement the overriding method without this default value.</p>\n<p>In this case, when I call the derived object's method using a pointer to parent class, will the function be called with/without this default initializion?</p>\n<p>thanks </p>\n", "AcceptedAnswerId": "27974932", "Title": "default parameter in virtual functions C++", "CreationDate": "2015-01-15T23:06:19.077", "Id": "27974653", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-01-15T23:33:05.050", "Score": "4", "OwnerUserId": "324922", "Tags": "<c++><inheritance><virtual-functions>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27974653_27974956_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 3261}}, "n3337": {"so_27974653_27974956_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 3133}}, "n4659": {"so_27974653_27974956_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 4019}}}, "27974956": {"Id": "27974956", "PostTypeId": "2", "Body": "<p>This is what I found from the C++ Draft Standard N3337:</p>\n<blockquote>\n<p id=\"so_27974653_27974956_0\"><strong>8.3.6 Default arguments</strong></p>\n<p id=\"so_27974653_27974956_1\">10 A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object. An overriding function in a derived class does not acquire default arguments from the function it overrides. [ <em>Example:</em></p>\n<pre><code>struct A {\n   virtual void f(int a = 7);\n  };\n  struct B : public A {\n    void f(int a);\n  };\n void m() {\n   B* pb = new B;\n   A* pa = pb;\n   pa-&gt;f(); // OK, calls pa-&gt;B::f(7)\n   pb-&gt;f(); // error: wrong number of arguments for B::f()\n }\n</code></pre>\n</blockquote>\n<p>\u2014<em>end example</em> ]</p>\n<p>Coming to your question:</p>\n<blockquote>\n<p id=\"so_27974653_27974956_2\">Can I define this value to be some constant in the parent Class virtual function,</p>\n</blockquote>\n<p>Yes</p>\n<blockquote>\n<p id=\"so_27974653_27974956_3\">and in the derived class declare and implement the overriding method without this default value</p>\n</blockquote>\n<p>Yes.</p>\n<p>However, when you call the function using a derived class pointer, you'll have to provide an argument. When you call the function using a base class pointer, you don't need to provide an argument.</p>\n", "LastActivityDate": "2015-01-15T23:33:05.050", "CommentCount": "1", "CreationDate": "2015-01-15T23:33:05.050", "ParentId": "27974653", "Score": "2", "OwnerUserId": "434551"}, "27974932": {"Id": "27974932", "PostTypeId": "2", "Body": "<p>Default arguments are mostly syntactic sugar and get determined at compile time.  Virtual dispatch, on the other hand, is a run-time feature.  It would probably be least surprising to have that default parameter chosen that was defined alongside with the function that actually gets called but this is not possible (at least not without additional run-time overhead) for the reason stated above.</p>\n<p>Therefore, the default parameter is selected by the compiler using the <em>static</em> type of the object a member function is called upon.  Let's see an example.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Base\n{\n\npublic:\n\n  virtual void\n  f(int a, int b = 1)\n  {\n    std::cout &lt;&lt; \"Base: a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n  }\n};\n\nclass Derived : public Base\n{\n\npublic:\n\n  virtual void\n  f(int a = 1, int b = 2) override\n  {\n    std::cout &lt;&lt; \"Derived: a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n  }\n};\n\nint\nmain()\n{\n  std::unique_ptr&lt;Base&gt; base_as_base {new Base {}};\n  std::unique_ptr&lt;Base&gt; derived_as_base {new Derived {}};\n  std::unique_ptr&lt;Derived&gt; derived_as_derived {new Derived {}};\n  base_as_base-&gt;f(0);        // Base:    a = 0, b = 1\n  derived_as_base-&gt;f(0);     // Derived: a = 0, b = 1\n  // derived_as_base-&gt;f();   // compiler error\n  derived_as_derived-&gt;f(0);  // Derived: a = 0, b = 2\n  derived_as_derived-&gt;f();   // Derived: a = 1, b = 2\n}\n</code></pre>\n<p>I agree that this is confusing.  Please don't write code like this.  Fortunately, there is a simple workaround.  Apart from not using default parameters at all, we can use an idiom called <em>non-virtual interfaces</em>.  The virtual function is made <code>protected</code> and not given any default parameters.  It is then only called indirectly by a non-<code>virtual</code> function from the base class.  That function can have all default parameters defined in a single place.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nclass Base\n{\n\npublic:\n\n  void\n  f(int a, int b = 1)\n  {\n    this-&gt;impl(a, b);\n  }\n\nprotected:\n\n  virtual void\n  impl(int a, int b)\n  {\n    std::cout &lt;&lt; \"Base: a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n  }\n};\n\nclass Derived : public Base\n{\n\nprotected:\n\n  virtual void\n  impl(int a, int b) override\n  {\n    std::cout &lt;&lt; \"Derived: a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; \"\\n\";\n  }\n};\n\nint\nmain()\n{\n  std::unique_ptr&lt;Base&gt; base_as_base {new Base {}};\n  std::unique_ptr&lt;Base&gt; derived_as_base {new Derived {}};\n  std::unique_ptr&lt;Derived&gt; derived_as_derived {new Derived {}};\n  base_as_base-&gt;f(0);        // Base:    a = 0, b = 1\n  derived_as_base-&gt;f(0);     // Derived: a = 0, b = 1\n  derived_as_derived-&gt;f(0);  // Derived: a = 0, b = 1\n}\n</code></pre>\n", "LastActivityDate": "2015-01-15T23:31:18.017", "CommentCount": "1", "CreationDate": "2015-01-15T23:31:18.017", "ParentId": "27974653", "Score": "6", "OwnerUserId": "1392132"}});