post_cb({"bq_ids": {"n4140": {"so_33418573_33418573_0": {"length": 23, "quality": 1.0, "section_id": 257}}, "n3337": {"so_33418573_33418573_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 248}}, "n4659": {"so_33418573_33418573_0": {"length": 23, "quality": 1.0, "section_id": 264}}}, "33418573": {"ViewCount": "131", "Body": "<p>Assume I have a class <code>Module&lt;Setting&gt;</code> that I want to instantiate externally. (reducing compilation time...)\nI created a <code>Module.cpp</code> that contains <code>template class Module&lt;Setting&gt;;</code> and added the <code>extern</code> declaration in the header. This works fine.</p>\n<p>Now I want to wrap this <code>Module</code> instantiation in another class, for example like this:</p>\n<pre><code>    template&lt;template&lt;typename&gt; class M, typename First&gt;\n    struct TrivialInstantiator {\n      typedef M&lt;First&gt; type;\n    };\n</code></pre>\n<p>This does not seem to work, i.e. the compilation time for other compilation units does not change (in comparison to not using the extern declaration at all). My question: Why is that so? Can I somehow make it work?\n(I tried to read the relevant sections of the standard, but I couldn't quite figure it out...)</p>\n<p>Rationale for my question:\nI have a larger number of Settings, and people may create new Settings that are not familiar with these details. If I simply create a list of extern template declarations for <code>Module&lt;Setting1&gt;</code>, <code>Module&lt;Setting2&gt;</code>, etc., this is not only tedious but will also tend to produce errors when users forget to add the template instantiation in the cpp file for example.\nTherefore I tried to create a list of Settings (with <code>boost::mpl</code>) at one point and use this list of Settings to instantiate all of them at once.</p>\n<p>Edit: This <a href=\"https://stackoverflow.com/questions/8130602/using-extern-template-c0x\">other question</a> is about how extern works altogether, it's not about how it handles nested types or typedefs.</p>\n<p>Update: I read \u00a714.7.2.8 several times again:</p>\n<blockquote>\n<p id=\"so_33418573_33418573_0\">An explicit instantiation that names a class template specialization is\n  also an explicit instantiation of the same kind (declaration or definition) \n  of each of its members (not including members inherited from base\n  classes and members that are templates) [...].</p>\n</blockquote>\n<p>I tried the following:</p>\n<pre><code>    template&lt;template&lt;typename&gt; class M, typename First&gt;\n    struct TrivialInstantiator {\n      M&lt;First&gt; member;\n    };\n</code></pre>\n<p>As this does not work either: Is this member considered a template as in <em>not including members [...] that are templates</em>? (Isn't it a fully instantiated template that is something different...? Is there any way to workaround that?)</p>\n", "Title": "Using extern template instantiation for nested types / typedefs", "CreationDate": "2015-10-29T15:37:00.603", "LastActivityDate": "2015-10-30T11:07:39.007", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:58.783", "LastEditorUserId": "-1", "Id": "33418573", "Score": "1", "OwnerUserId": "2375725", "Tags": "<c++><templates><extern>", "AnswerCount": "0"}});