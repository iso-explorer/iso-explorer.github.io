post_cb({"906734": {"CreationDate": "2009-05-25T13:23:43.780", "ViewCount": "1131", "FavoriteCount": "7", "Id": "906734", "AcceptedAnswerId": "906794", "Score": "9", "Title": "Does C++ do value initialization of a POD typedef?", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>Does C++ do value initialization on simple <a href=\"https://stackoverflow.com/questions/146452/\">POD</a> typedefs?</p>\n<p>Assuming</p>\n<pre><code>typedef T* Ptr;\n</code></pre>\n<p>does</p>\n<pre><code>Ptr()\n</code></pre>\n<p>do value-initialization and guarantee to equal <code>(T*)0</code>?</p>\n<p>e.g.</p>\n<pre><code>Ptr p = Ptr();\nreturn Ptr();\n</code></pre>\n", "Tags": "<c++><pointers>", "LastEditDate": "2017-05-23T12:19:22.737", "LastActivityDate": "2010-06-13T06:43:20.463", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "111129"}, "bq_ids": {"n4140": {"so_906734_906794_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 6000}}, "n3337": {"so_906734_906794_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5768}}}, "906794": {"CommentCount": "3", "Body": "<p>It does. For a type <code>T</code>, <code>T()</code> value-initializes an \"object\" of type <code>T</code> and yields an rvalue expression.</p>\n<pre><code>int a = int();\nassert(a == 0);\n</code></pre>\n<p>Same for pod-classes:</p>\n<pre><code>struct A { int a; };\nassert(A().a == 0);\n</code></pre>\n<p>Also true for some non-POD classes that have no user declared constructor:</p>\n<pre><code>struct A { ~A() { } int a; };\nassert(A().a == 0);\n</code></pre>\n<p>Since you cannot do <code>A a()</code> (creates a function declaration instead), boost has a class <a href=\"http://www.boost.org/doc/libs/1_39_0/libs/utility/value_init.htm\" rel=\"nofollow noreferrer\"><code>value_initialized</code></a>, allowing to work around that, and C++1x will have the following, alternative, syntax</p>\n<pre><code>int a{};\n</code></pre>\n<p>In the dry words of the Standard, this sounds like</p>\n<blockquote>\n<p id=\"so_906734_906794_0\">The expression T(), where T is a simple-type-specifier (7.1.5.2) for a non-array complete object type or the (possibly cv-qualified) void type, creates an rvalue of the specified type, which is value-initialized </p>\n</blockquote>\n<p>Since a typedef-name is a type-name, which is a simple-type-specifier itself, this works just fine.</p>\n", "CreationDate": "2009-05-25T13:44:25.220", "ParentId": "906734", "Id": "906794", "LastActivityDate": "2009-05-25T13:44:25.220", "PostTypeId": "2", "Score": "17", "OwnerUserId": "34509"}, "906869": {"LastActivityDate": "2009-05-25T14:34:51.797", "CommentCount": "0", "Body": "<pre><code>#include &lt;iostream&gt;\nstruct Foo {\n    char bar;\n    char baz;\n    char foobar;\n    // the struct is a POD\n    //virtual void a() { bar='b'; }\n};\n\nint main() {\n    Foo o1;\n    Foo o2 = Foo();\n\n    std::cout &lt;&lt; \"O1: \" &lt;&lt; (int)o1.bar &lt;&lt;\" \"&lt;&lt; (int)o1.baz &lt;&lt;\" \"&lt;&lt; (int)o1.foobar &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"O2: \" &lt;&lt; (int)o2.bar &lt;&lt;\" \"&lt;&lt; (int)o2.baz &lt;&lt;\" \"&lt;&lt; (int)o2.foobar &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_906734_906869_0\">O1: -27 -98 0</p>\n<p id=\"so_906734_906869_1\">O2: 0 0 0</p>\n</blockquote>\n<p>Adding () propagates initializer calls to all POD members. Uncomenting the virtual method changes output to:</p>\n<blockquote>\n<p id=\"so_906734_906869_2\">O1: -44 -27 -98</p>\n<p id=\"so_906734_906869_3\">O2: -71 -120 4</p>\n</blockquote>\n<p>However adding destructor ~Foo() does not suppress the initialization, although it creates non-POD object (output similar to first one).</p>\n", "CreationDate": "2009-05-25T14:07:37.420", "OwnerDisplayName": "anon", "LastEditDate": "2009-05-25T14:34:51.797", "ParentId": "906734", "Id": "906869", "LastEditorDisplayName": "anon", "PostTypeId": "2", "Score": "2"}});