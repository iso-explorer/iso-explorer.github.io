post_cb({"18543255": {"ParentId": "18534101", "CommentCount": "0", "CreationDate": "2013-08-31T00:32:08.147", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "18543255", "Score": "3", "Body": "<p>It seems like it's not a widely known feature, but you can specialize non-template member functions of class templates (that's what you tried to do).</p>\n<p>As I've written in the comments, you just have to tell the compiler <em>that there's such a specialization available in another TU</em> so that it doesn't try to instantiate the function from the template.</p>\n<p><em>Matrix.hpp</em></p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt; typename T &gt;\nstruct Matrix\n{\n    void multiply()\n    {\n        std::cout &lt;&lt; \"non-specialized\" &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;&gt;\nvoid Matrix&lt;float&gt;::multiply();\n</code></pre>\n<p><em>Matrix.cpp</em></p>\n<pre><code>#include &lt;iostream&gt;\n#include \"Matrix.hpp\"\n\ntemplate &lt;&gt;\nvoid Matrix&lt;float&gt;::multiply();\n{\n    std::cout &lt;&lt; \"specialized for float\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p><em>some_other.cpp</em></p>\n<pre><code>#include \"Matrix.hpp\"\n\nint main()\n{\n    Matrix&lt;int&gt;{}.multiply();\n    Matrix&lt;float&gt;{}.multiply();\n}\n</code></pre>\n<p>The relevant passage in the Standard may be [temp.inst]/2:</p>\n<blockquote>\n<p id=\"so_18534101_18543255_0\">Unless a member of a class template or a member template has been explicitly instantiated or <strong>explicitly specialized</strong>, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; [...]</p>\n</blockquote>\n<p>That is, you need the declaration <code>template &lt;&gt; void Matrix&lt;float&gt;::multiply();</code> to prevent instantiation. If instantiation is prevented, then there's no definition of <code>void Matrix&lt;float&gt;::multiply()</code> other than the explicit specialization, so the ODR is not violated.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/view?id=dc3db004e3\" rel=\"nofollow\">Live example</a></p>\n", "LastActivityDate": "2013-08-31T00:32:08.147"}, "18536085": {"ParentId": "18534101", "CommentCount": "0", "CreationDate": "2013-08-30T15:03:18.860", "OwnerUserId": "1137388", "PostTypeId": "2", "Id": "18536085", "Score": "1", "Body": "<p>Here is another approach based on SFINAE:</p>\n<pre><code>// matrix.h\n#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct matrix {\n\n    // This is active only for U == T == float.\n    // Otherwise, it does not participate in overload resolution.\n    // Essentially this declaration is equivalent to:\n    // matrix&lt;float&gt;&amp; multiply(const matrix&lt;float&gt;&amp; other);\n    template &lt;typename U&gt;\n    typename std::enable_if&lt;\n        std::is_same&lt;U, T&gt;::value &amp;&amp;\n        std::is_same&lt;U, float&gt;::value,\n        matrix&amp;\n    &gt;::type\n    multiply(const matrix&lt;U&gt;&amp; other); // no definition here (convenient but not required)\n\n    // This is active only for U == T != float\n    // Otherwise, it does not participate in overload resolution.\n    // Essentially this declaration is equivalent to:\n    // matrix&lt;T&gt;&amp; multiply(const matrix&lt;T&gt;&amp; other); // for T != float\n    template &lt;typename U&gt;\n    typename std::enable_if&lt;\n        std::is_same&lt;U, T&gt;::value &amp;&amp;\n        !std::is_same&lt;U, float&gt;::value,\n        matrix&amp;\n    &gt;::type\n    multiply(const matrix&lt;U&gt;&amp;) {\n        std::cout &lt;&lt; \"generic multiplication\\n\";\n        return *this;\n    }\n\n};\n</code></pre>\n<p>Then</p>\n<pre><code>// matrix.cpp\n#include \"matrix.h\"\n\n// The definition of\n// matrix&lt;float&gt;&amp; multiply(const matrix&lt;float&gt;&amp; other);\ntemplate &lt;&gt;\ntemplate &lt;&gt;\nmatrix&lt;float&gt;&amp;\nmatrix&lt;float&gt;::multiply&lt;float&gt;(const matrix&lt;float&gt;&amp; other) {\n    std::cout &lt;&lt; \"specific multiplication\\n\";\n    return *this;\n}\n</code></pre>\n<p>Finally, in client code:</p>\n<pre><code>#include \"matrix.h\"\n\nint main() {\n\n    matrix&lt;int&gt; mi1, mi2;\n    mi1.multiply(mi2); // outputs 'generic multiplication'\n\n    matrix&lt;float&gt; mf1, mf2;\n    mf1.multiply(mf2); // outputs 'specific multiplication'\n}\n</code></pre>\n", "LastActivityDate": "2013-08-30T15:03:18.860"}, "18534101": {"CommentCount": "12", "AcceptedAnswerId": "18543255", "PostTypeId": "1", "LastEditorUserId": "1448212", "CreationDate": "2013-08-30T13:27:41.607", "LastActivityDate": "2013-08-31T00:32:08.147", "LastEditDate": "2013-08-30T13:43:08.030", "ViewCount": "175", "FavoriteCount": "1", "Title": "How to create a function that only exists for a particular template specialization", "Id": "18534101", "Score": "1", "Body": "<p>I have a generic <code>Matrix</code> class. I have SSE-optimized matrix multiplication functions for when I'm dealing with a matrix of <code>Float</code> values. Currently, my methodology includes a function named \"doSSE_mulMM\" which does a matrix by matrix multiplication including a couple of checks, but which is only relevant for <code>Matrix&lt;Float&gt;</code> (it partly exists because I make a check for SSE capability in the code and move to a less efficient multiplication if SSE is not available).</p>\n<p>For the version of GCC that our build server is running, I get this error:</p>\n<blockquote>\n<p id=\"so_18534101_18534101_0\"><code>error: specialization of \u2018MTI::Matrix&lt;float&gt;&amp; MTI::Matrix&lt;BT&gt;::doSSE_MulMM(const MTI::Matrix&lt;float&gt;&amp;, const MTI::Matrix&lt;float&gt;&amp;, bool) [with BT = float]\u2019 after instantiation</code></p>\n</blockquote>\n<p>The same code compiles fine in Visual Studio and in the older version of GCC on our Linux host.</p>\n<p>I can't provide the full code, but these are the signatures of the functions:</p>\n<p><strong>Matrix.h</strong></p>\n<pre><code>template &lt;class BT&gt; \nclass Matrix {\n    ....\n    Matrix&lt;Float&gt;&amp;  doSSE_MulMM      (const Matrix&lt;Float&gt;&amp; mat1, const Matrix&lt;Float&gt;&amp; mat2, bool softmax);\n    ....\n}\n</code></pre>\n<p><strong>Matrix.cpp</strong></p>\n<pre><code>template &lt;&gt; \nMatrix&lt;Float&gt;&amp;  Matrix&lt;Float&gt;::doSSE_MulMM (const Matrix&lt;Float&gt;&amp; mat1, \n                                 const Matrix&lt;Float&gt;&amp; mat2,\n                                 bool softmax) {\n    ....\n}\n</code></pre>\n<p>The function of <code>doSSE_MulMM</code> only really makes sense for Float matrices, but I would much prefer making it a member function because it operates on private data members of the Matrix. Is there a good way of specializing the function to only exist in one specialization of the Matrix class? I suppose I could introduce a general version that raises an exception for the other data types, but that seems messy.</p>\n", "Tags": "<c++><templates><template-specialization>", "OwnerUserId": "901083", "AnswerCount": "4"}, "18534254": {"ParentId": "18534101", "CommentCount": "2", "CreationDate": "2013-08-30T13:35:44.297", "OwnerUserId": "602037", "PostTypeId": "2", "Id": "18534254", "Score": "0", "Body": "<p>In order to do that, you need to specialize the full template Matrix.\nYou cannot specialize just one member function of a class template.\nThen, you can add private members as much as you want.\nIf you are careful to fulfill the template contract in the specialization, generic algorithms on Matrix would not know the difference.</p>\n", "LastActivityDate": "2013-08-30T13:35:44.297"}, "bq_ids": {"n4140": {"so_18534101_18543255_0": {"section_id": 234, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_18534101_18543255_0": {"section_id": 227, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_18534101_18543255_0": {"section_id": 244, "quality": 0.9565217391304348, "length": 22}}}, "18535338": {"ParentId": "18534101", "CommentCount": "0", "CreationDate": "2013-08-30T14:28:08.577", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "18535338", "Score": "1", "Body": "<p>An easy way to have the function exist for only one type would be CRTP, and specialize there.  The CRTP gives you access to the full type at the point where you implement the function, and the specialization lets you have the function only exist for certain types.</p>\n<p>Here is a toy example:</p>\n<pre><code>template&lt;typename D, typename T&gt;\nstruct foo_for_float {};\ntemplate&lt;typename D&gt;\nstruct foo_for_float&lt;D, float&gt; {\n  D* self() {\n    static_assert( std::is_base&lt; foo_for_float&lt;D, float&gt;, D &gt;::value, \"CRTP error\" );\n    return static_cast&lt;D*&gt;(this);\n  }\n  D const* self() const {\n    static_assert( std::is_base&lt; foo_for_float&lt;D, float&gt;, D &gt;::value, \"CRTP error\" );\n    return static_cast&lt;D const*&gt;(this);\n  }\n  void foo() { // const if you want to\n    // use self() in this method instead of this\n  }\n};\n// The usual CRTP magic \"pass my own type to my parent\":\ntemplate&lt;typename T&gt;\nstruct test : foo_for_float&lt;test&lt;T&gt;, T&gt; {\n  void bar() {}\n}\nint main() {\n  test&lt;int&gt; a;\n  test&lt;float&gt; b;\n  a.bar(); // valid\n  b.bar(); // valid\n  b.foo(); // valid\n  a.foo(); // not found\n}\n</code></pre>\n", "LastActivityDate": "2013-08-30T14:28:08.577"}});