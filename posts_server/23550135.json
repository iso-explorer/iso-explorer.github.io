post_cb({"23550135": {"CommentCount": "2", "ViewCount": "501", "PostTypeId": "1", "LastEditorUserId": "3043539", "CreationDate": "2014-05-08T18:48:13.670", "LastActivityDate": "2014-05-10T14:33:14.293", "Title": "Variadic Template Constructor to build Parent", "AcceptedAnswerId": "23553430", "LastEditDate": "2014-05-10T14:33:14.293", "Id": "23550135", "Score": "1", "Body": "<p>I'm trying to inherit from a bunch of classes of which I know an interface, but however they may have very different constructors. To do so I decided to use variadic templates into the derived class constructor, so that it may get the arbitrary parameters that will in the end feed the parent class.</p>\n<p>My code is the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    A(int) { std::cout &lt;&lt; \"This is int\\n\"; }\n    A(unsigned) { std::cout &lt;&lt; \"This is unsigned\\n\"; }\n};\n\nstruct B {\n    B(char) { std::cout &lt;&lt; \"This is char\\n\"; }\n};\n\ntemplate &lt;typename T&gt;\nstruct C : public T {\n    template &lt;typename... Args&gt;\n    C(double, Args&amp;&amp;... params) : T(std::forward&lt;Args&gt;(params)...) { std::cout &lt;&lt; \"This is double\\n\"; }\n    // But what about this?\n    // C(Args&amp;&amp;... params, double) : T(std::forward&lt;Args&gt;(params)...) { std::cout &lt;&lt; \"This is double\\n\"; }\n};\n\nint main() {\n    C&lt;A&gt; p(1.0, 1);\n    C&lt;A&gt; r(1.0, 1u);\n    C&lt;B&gt; q(1.0, 'c');\n\n    // Which would work as following\n    // C&lt;A&gt; p(1,   1.0);\n    // C&lt;A&gt; r(1u,  1.0);\n    // C&lt;B&gt; q('c', 1.0);\n    return 0;\n}\n</code></pre>\n<p>My questions are:</p>\n<ul>\n<li>Is this code correct? This is my first attempt with variadic templates in constructors, so I'd love to hear your opinion if I missed something.</li>\n<li>I'd prefer to leave the parameters of the child class <code>C</code> at the end, however as far as I understand this is not possible since in a constructor you are not allowed to specify the template parameters, and in that case the variadic arguments would swallow all the parameters, leaving none for the actual child. Is there a way to do this by any chance?</li>\n</ul>\n", "Tags": "<c++><templates><constructor><variadic-templates><argument-passing>", "OwnerUserId": "1356926", "AnswerCount": "1"}, "23553430": {"ParentId": "23550135", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>14.8.2.1 Deducing template arguments from a function call</strong></p>\n<blockquote>\n<p id=\"so_23550135_23553430_0\">1 [...] For a function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em>, the type of the parameter pack is a non-deduced context.</p>\n<p id=\"so_23550135_23553430_1\">5 [...] [ <em>Note:</em> If a <em>template-parameter</em> is not used in any of the function parameters of a function template, or is used only in a non-deduced context, its corresponding\n  <em>template-argument</em> cannot be deduced from a function call and the <em>template-argument</em> must be explicitly specified. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p><strong>14.8.2.5 Deducing template arguments from a type</strong></p>\n<blockquote>\n<p id=\"so_23550135_23553430_2\">If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails.</p>\n</blockquote>\n<p>So, as you observe, <code>Args...</code> should be explicitly specified, but since this is not possible for a constructor, this is not going to work.</p>\n<p>What <em>can work</em> is to pack all arguments meant for the base constructor in a tuple (<a href=\"http://coliru.stacked-crooked.com/a/7417bf987f2efde7\" rel=\"nofollow\">live example</a>), followed by the remaining arguments for the derived class:</p>\n<pre><code>template &lt;typename T&gt;\nclass C : public T\n{\n    template&lt;typename... A, size_t... I&gt;\n    C(std::tuple&lt;A...&gt;&amp;&amp; a, sizes&lt;I...&gt;, double x) :\n        T(std::get&lt;I&gt;(std::move(a))...) { std::cout &lt;&lt; \"This is double\\n\"; }\n\npublic:\n    template&lt;typename... A&gt;\n    C(std::tuple&lt;A...&gt;&amp;&amp; a, double x) :\n        C(std::move(a), idx&lt;sizeof...(A)&gt;{}, x) { }\n};\n</code></pre>\n<p>to be used as</p>\n<pre><code>int main() {\n    C&lt;A&gt; p(std::forward_as_tuple(1),      1.0);\n    C&lt;A&gt; r(std::forward_as_tuple(1u, 2.), 1.0);\n    C&lt;B&gt; q(std::forward_as_tuple('c', 0), 1.0);\n}\n</code></pre>\n<p>where I have made your example a bit richer:</p>\n<pre><code>struct A {\n    A(int) { std::cout &lt;&lt; \"This is int\\n\"; }\n    A(unsigned, double) { std::cout &lt;&lt; \"This is unsigned, double\\n\"; }\n};\n\nstruct B {\n    B(char, int) { std::cout &lt;&lt; \"This is char, int\\n\"; }\n};\n</code></pre>\n<p>and the remaining boilerplate</p>\n<pre><code>template&lt;size_t... I&gt; struct sizes { using type = sizes&lt;I...&gt;; };\n\ntemplate&lt;size_t N, size_t K = 0, size_t... I&gt;\nstruct idx_t : idx_t&lt;N, K+1, I..., K&gt; {};\n\ntemplate&lt;size_t N, size_t... I&gt;\nstruct idx_t&lt;N, N, I...&gt; : sizes&lt;I...&gt; {};\n\ntemplate&lt;size_t N&gt;\nusing idx = typename idx_t&lt;N&gt;::type;\n</code></pre>\n<p>is there just until <a href=\"http://en.cppreference.com/w/cpp/utility/integer_sequence\" rel=\"nofollow\">std::integer_sequence</a> is available.</p>\n<p>If you find <code>std::forward_as_tuple</code> too long a name, it's not hard to define you own e.g. <code>pack</code>:</p>\n<pre><code>template&lt;typename... A&gt;\nconstexpr std::tuple&lt;A&amp;&amp;...&gt;\npack(A&amp;&amp;... a) { return std::tuple&lt;A&amp;&amp;...&gt;{std::forward&lt;A&gt;(a)...}; }\n</code></pre>\n<p>Even so, syntax</p>\n<pre><code>C&lt;B&gt; q(pack('c', 0), 1.0);\n</code></pre>\n<p>does add a little overhead, but I find it natural that the end user has a hint of what is going on. Flattening to <code>C&lt;B&gt; q('c', 0, 1.0);</code> would not only be nearly impossible to implement if more parameters are added to the derived class constructor, but also ambiguous and confusing to the user. What would be really cool is a syntax like</p>\n<pre><code>C&lt;B&gt; q('c', 0; 1.0);\n</code></pre>\n<p>(also e.g. to separate input/output parameters in functions), but I haven't seen this in any language, only in textbooks.</p>\n", "OwnerUserId": "2644390", "LastEditorUserId": "2644390", "LastEditDate": "2014-05-09T15:39:54.180", "Id": "23553430", "Score": "1", "CreationDate": "2014-05-08T22:09:03.820", "LastActivityDate": "2014-05-09T15:39:54.180"}, "bq_ids": {"n4140": {"so_23550135_23553430_1": {"section_id": 306, "quality": 0.8571428571428571, "length": 18}, "so_23550135_23553430_2": {"section_id": 335, "quality": 1.0, "length": 10}, "so_23550135_23553430_0": {"section_id": 302, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_23550135_23553430_1": {"section_id": 297, "quality": 0.8571428571428571, "length": 18}, "so_23550135_23553430_2": {"section_id": 325, "quality": 1.0, "length": 10}, "so_23550135_23553430_0": {"section_id": 293, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_23550135_23553430_1": {"section_id": 313, "quality": 0.8571428571428571, "length": 18}, "so_23550135_23553430_2": {"section_id": 344, "quality": 1.0, "length": 10}, "so_23550135_23553430_0": {"section_id": 309, "quality": 0.7692307692307693, "length": 10}}}});