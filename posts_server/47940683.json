post_cb({"47940929": {"Id": "47940929", "PostTypeId": "2", "Body": "<p>If <code>x &lt;&lt; y</code> is undefined, all bets are off.<br>\nThe only safe way is to check that it's a valid shift before attempting it.</br></p>\n<pre><code>uint32_t safe_shl(uint32_t x, uint8_t y) {\n    assert (y &lt; 32);\n    if (y &lt; 32)\n    {\n        uint32_t z = x &lt;&lt; y;\n        assert((z &gt;&gt; y) == x);\n        return z;\n    }\n    return 0;\n}\n</code></pre>\n<p>Note that you need the condition \u2013 shifting unconditionally lets the compiler assume that <code>y &lt; 32</code> is true.</p>\n", "LastEditorUserId": "404970", "LastActivityDate": "2017-12-22T11:48:16.087", "Score": "4", "CreationDate": "2017-12-22T11:41:38.153", "ParentId": "47940683", "CommentCount": "9", "OwnerUserId": "404970", "LastEditDate": "2017-12-22T11:48:16.087"}, "47941769": {"Id": "47941769", "PostTypeId": "2", "Body": "<p>In C, <code>x &lt;&lt; y</code> if defined for <code>uint32_t</code> provided <code>y &lt; 32</code>. From the n1570 draft for C11 in 6.5.7 Bitwise shift operators:</p>\n<blockquote>\n<p id=\"so_47940683_47941769_0\">If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.</p>\n</blockquote>\n<p>The result in then required to be:  x \u00d7 2<sup>y</sup>, <em>reduced modulo\none more than the maximum value representable in the result type</em></p>\n<p>Let call that value <code>z</code> like it is in your proposed code. Like you use an unsigned type the value of <code>z &gt;&gt; y</code> is required to be <em>the integral part of z/2<sup>y</sup></em>.</p>\n<p>That means that <em>provided y &lt; 32</em> if there is an overflow, the value of <code>z &gt;&gt; y</code> will be strictly less than x because of the modulo, and if there is non overflow, you get exactly x</p>\n<p>Full reference from 6.5.7 Bitwise shift operators:</p>\n<blockquote>\n<p id=\"so_47940683_47941769_1\">...<br>4 The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are filled with\n  zeros. If E1 has an unsigned type, the value of the result is E1 \u00d7 2E2, reduced modulo\n  one more than the maximum value representable in the result type. If E1 has a signed\n  type and nonnegative value, and E1 \u00d7 2E2 is representable in the result type, then that is\n  the resulting value; otherwise, the behavior is undefined.</br></p>\n<p id=\"so_47940683_47941769_2\">5 The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type\n  or if E1 has a signed type and a nonnegative value, the value of the result is the integral\n  part of the quotient of E1 / 2E2. If E1 has a signed type and a negative value, the\n  resulting value is implementation-defined.</p>\n</blockquote>\n<hr>\n<p>It is exactly the same in C++ from n4296 draft for C++14 in 5.8 Shift operators [expr.shift]:</p>\n<blockquote>\n<p id=\"so_47940683_47941769_3\">...The behavior is undefined if the right operand\n  is negative, or greater than or equal to the length in bits of the promoted left operand.</p>\n<p id=\"so_47940683_47941769_4\">2 The value of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned\n  type, the value of the result is E1 \u00d7 2E2, reduced modulo one more than the maximum value representable\n  in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1\u00d72E2 is representable\n  in the corresponding unsigned type of the result type, then that value, converted to the result type, is the\n  resulting value; otherwise, the behavior is undefined.</p>\n<p id=\"so_47940683_47941769_5\">3 The value of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed\n  type and a non-negative value, the value of the result is the integral part of the quotient of E1/2E2. If E1\n  has a signed type and a negative value, the resulting value is implementation-defined.</p>\n</blockquote>\n<hr>\n<p>So in both languages, and assuming that <em>the assert function registers an error in [your] system</em>, code should be:</p>\n<pre><code>uint32_t safe_shl(uint32_t x, uint8_t y) {\n    assert(y&lt;32);\n    uint32_t z = x &lt;&lt; y;\n    assert((z &gt;&gt; y) == x);\n    return z;\n}\n</code></pre>\n</hr></hr>", "LastActivityDate": "2017-12-22T12:42:41.710", "Score": "1", "CreationDate": "2017-12-22T12:42:41.710", "ParentId": "47940683", "CommentCount": "1", "OwnerUserId": "3545273"}, "47941107": {"Id": "47941107", "PostTypeId": "2", "Body": "<p>Are you asking to assert if the shift would cause a carry?</p>\n<p>In which case it's a bit nasty in c++ without resorting to intrinsics or assembler.</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n\nbool shl_would_carry(uint32_t x, uint8_t y)\n{\n    constexpr auto nof_bits = std::numeric_limits&lt;decltype(x)&gt;::digits;\n    if (y &gt;= nof_bits)\n    {\n        if (x != 0) return true;\n    }\n    else\n    {\n        auto limit = decltype(x)(1) &lt;&lt; (nof_bits - y);\n        if (x &gt;= limit) return true;\n    }\n    return false;\n}\n\nuint32_t safe_shl(uint32_t x, uint8_t y) \n{\n    assert(!shl_would_carry(x, y));\n    return x &lt;&lt; y;\n}\n</code></pre>\n<p>I think that's right.</p>\n<p>This might be better:</p>\n<pre><code>std::tuple&lt;uint32_t, uint32_t&gt; shl(uint32_t x, uint8_t y)\n{\n    uint32_t overflow, result;\n    constexpr auto nof_bits = std::numeric_limits&lt;decltype(x)&gt;::digits;\n    overflow = x &gt;&gt; (nof_bits - y); \n    result = x &lt;&lt; y;\n    return std::make_tuple(overflow, result);\n}\n\nuint32_t safe_shl(uint32_t x, uint8_t y) \n{\n    auto t = shl(x, y);\n    assert(!std::get&lt;0&gt;(t));\n    return std::get&lt;1&gt;(t);\n}\n</code></pre>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2017-12-22T12:00:08.233", "Score": "1", "CreationDate": "2017-12-22T11:54:48.377", "ParentId": "47940683", "CommentCount": "1", "OwnerUserId": "2015579", "LastEditDate": "2017-12-22T12:00:08.233"}, "47940683": {"ViewCount": "101", "Body": "<p>I would like to implement a shift-left function that would trigger a failure upon overflow.</p>\n<p>Here is my code:</p>\n<pre><code>uint32_t safe_shl(uint32_t x, uint8_t y) {\n    uint32_t z = x &lt;&lt; y;\n    assert((z &gt;&gt; y) == x);\n    return z;\n}\n</code></pre>\n<p>Please assume that I the <code>assert</code> function registers an error in my system.</p>\n<p>I would like to ensure that my method is bullet-proof (i.e., fails on every erroneous input and only on erroneous input).</p>\n<p>And I would also like to ask if you know of a more efficient way to implement this (assuming that it is indeed bullet-proof).</p>\n<p>Thank you very much!!!</p>\n", "AcceptedAnswerId": "47942065", "Title": "Implementing safe shift-left", "CreationDate": "2017-12-22T11:23:31.767", "Id": "47940683", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2017-12-22T15:04:20.560", "Score": "1", "OwnerUserId": "7400903", "Tags": "<c++><c><bit-shift><integer-overflow>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_47940683_47941769_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 6148}, "so_47940683_47941769_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 6146}, "so_47940683_47941769_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 6147}, "so_47940683_47942065_0": {"length": 9, "quality": 0.6, "section_id": 6146}, "so_47940683_47941769_5": {"length": 21, "quality": 0.875, "section_id": 6148}, "so_47940683_47941769_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 6146}, "so_47940683_47941769_4": {"length": 42, "quality": 0.9333333333333333, "section_id": 6147}, "so_47940683_47942065_1": {"length": 14, "quality": 0.875, "section_id": 6147}}, "n3337": {"so_47940683_47941769_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 5911}, "so_47940683_47941769_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 5909}, "so_47940683_47941769_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 5910}, "so_47940683_47942065_0": {"length": 9, "quality": 0.6, "section_id": 5909}, "so_47940683_47941769_5": {"length": 21, "quality": 0.875, "section_id": 5911}, "so_47940683_47941769_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 5909}, "so_47940683_47941769_4": {"length": 35, "quality": 0.7777777777777778, "section_id": 5910}, "so_47940683_47942065_1": {"length": 14, "quality": 0.875, "section_id": 5910}}, "n4659": {"so_47940683_47941769_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 7644}, "so_47940683_47941769_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 7642}, "so_47940683_47941769_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 7643}, "so_47940683_47942065_0": {"length": 9, "quality": 0.6, "section_id": 7642}, "so_47940683_47941769_5": {"length": 21, "quality": 0.875, "section_id": 7644}, "so_47940683_47941769_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 7642}, "so_47940683_47941769_4": {"length": 42, "quality": 0.9333333333333333, "section_id": 7643}, "so_47940683_47942065_1": {"length": 14, "quality": 0.875, "section_id": 7643}}}, "47942065": {"Id": "47942065", "PostTypeId": "2", "Body": "<p>Step 1.  If <code>x == 0</code>and any shift amount, the result is conceptually still 0 and is not a problem.</p>\n<p>Step 2.  Do not attempt excessive shifts.</p>\n<blockquote>\n<p id=\"so_47940683_47942065_0\">If the value of the right operand is negative or greater than or equal to the width of the promoted left operand, the behavior is undefined.  C11 \u00a76.5.7 3</p>\n</blockquote>\n<p>Step 3.  Insure unsigned math while shifting.</p>\n<p>If <code>int/unsigned</code> is wider than <code>uintN_t x</code>,  then <code>x &lt;&lt; y</code> is done with <code>int</code> math.  This is rare with <code>N==32</code> yet possible.  Signed math overflow is possible and leads to UB.  By <code>1u*x</code> or <code>(0u+x)</code>, code can insure the shift uses the wider of <code>unsigned</code> and <code>uintN_t</code> math.  Good compilers will still make optimal code.</p>\n<p>Step 4.  Detect if a reduction occurred.</p>\n<blockquote>\n<p id=\"so_47940683_47942065_1\">If E1 has an unsigned type, the value of the result is E1 \u00d7 2E2, reduced modulo\n  one more than the maximum value representable in the result type \u00a76.5.7 4</p>\n</blockquote>\n<pre><code>uint32_t safe_shl(uint32_t x, uint8_t y) {\n  if (x == 0) {\n    return 0;\n  } \n  assert(y &lt; 32);\n  uint32_t z = (1u*x) &lt;&lt; y;\n  assert((z &gt;&gt; y) == x);\n  return z;\n}\n</code></pre>\n", "LastEditorUserId": "2410359", "LastActivityDate": "2017-12-22T15:04:20.560", "Score": "1", "CreationDate": "2017-12-22T13:05:39.187", "ParentId": "47940683", "CommentCount": "0", "OwnerUserId": "2410359", "LastEditDate": "2017-12-22T15:04:20.560"}, "47942007": {"Id": "47942007", "PostTypeId": "2", "Body": "<p>In order to write a safe function, you must first identify what isn't safe. If you don't do this, the task is nonsense. The kind of \"overflow\" you mention is actually well-defined. But the following cases of dangerous behavior exist:</p>\n<ul>\n<li>Left-shifting further than the size of the variable, including shifting data into the sign bit of a signed variable. (Undefined behavior)</li>\n<li>The the right operator is a negative number. (Undefined behavior)</li>\n<li>Right-shifting a negative number. (Impl.-defined behavior)</li>\n<li>Implicit integer promotion of the left operand causing it to silently change signedness and thereby invoking one of the above errors.</li>\n</ul>\n<p>To avoid this, you need to ensure that:</p>\n<ol>\n<li>The left operand must be unsigned.</li>\n<li>The right operand must be valid and in range of the type of the left operand.</li>\n<li>The left operand must not be a small integer type.</li>\n</ol>\n<p>1) and 3) are solved by using <code>uint32_t</code>. There exist no system where <code>uint32_t</code> is smaller than <code>int</code>.</p>\n<p>2) is solved by using an unsigned type and checking that it isn't too large.</p>\n<p>In addition, you seem to have a requirement that shifting out of bounds of the left operand should not be allowed. This is weird, but ok, lets implement that too. It can be done by checking if the MSB bit position plus the number of shifts are larger than 31.</p>\n<pre><code>uint8_t msb_pos32 (uint32_t data)\n{\n  uint8_t result = 0;\n  while(data&gt;&gt;=1 &gt; 0)\n  {\n    result++;\n  }\n  return result;\n}\n\nuint32_t safe_LSL32 (uint32_t x, uint8_t y) \n{\n  if(y &gt; 31 || y+msb_pos32(x) &gt; 31)\n  {\n    __asm HCF;               // error handling here\n  }\n  return x &lt;&lt; y;\n}\n</code></pre>\n<p>Note that this code can be further optimized.</p>\n", "LastActivityDate": "2017-12-22T13:02:23.670", "Score": "1", "CreationDate": "2017-12-22T13:02:23.670", "ParentId": "47940683", "CommentCount": "0", "OwnerUserId": "584518"}});