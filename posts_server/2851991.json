post_cb({"2853070": {"ParentId": "2851991", "CommentCount": "0", "Body": "<pre><code>#define FACTORY_CLASS(classtype) \\\nclass classtype; \\\nextern const char classtype##_name_[] = #classtype; \\\ntemplate detail_::registerHelper_&lt;FactoryBase&lt;classtype,classtype##_name_&gt;,classtype##_name_&gt; FactoryBase&lt;classtype,classtype##_name_&gt;::factory_helper_; \\\nclass classtype : FactoryBase&lt;classtype,classtype##_name_&gt;\n</code></pre>\n<p>explicitly instantiating factory_helper_ fixed the issue.</p>\n", "OwnerUserId": "231717", "PostTypeId": "2", "Id": "2853070", "Score": "0", "CreationDate": "2010-05-17T21:45:02.870", "LastActivityDate": "2010-05-17T21:45:02.870"}, "2852234": {"ParentId": "2851991", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The problem is not related to initialization order, but rather to template instantiation.</p>\n<p>Templated code is instantiated on demand, that is, the compiler will not instantiate any templated code that is not used in your program. In particular, in your case the static class member <code>FactoryBase&lt;&gt;::factory_helper_</code> is not being instantiated and thus it does not exist in the final binary, it does not register itself... (you can check this with 'nm' from the gnu toolchain, that will show the list of symbols present in your executable)</p>\n<p>Try changing the <code>FactoryBase</code> constructor to this:</p>\n<pre><code>template &lt;class TClass, const char* ClassName&gt;\nclass FactoryBase {\n   //...\n   FactoryBase(){\n      factory_helper_;\n   }\n   //...\n};\n</code></pre>\n<p>This will force the compiler into actually instantiating the static member in the binary and you should be set. There is no need to create an empty method and calling it. </p>\n<p><strong>EDIT</strong>: As an answer to the comment, towards the end of paragraph <em>\u00a714.7.1[temp.inst]/1</em> in the current standard:</p>\n<blockquote>\n<p id=\"so_2851991_2852234_0\">Unless a member of a class template or\n  a member template has been explicitly\n  instantiated or explicitly\n  specialized, the specialization of the\n  member is implicitly instantiated when\n  the specialization is referenced in a\n  context that requires the member\n  definition to exist; in particular,\n  the initialization (and any associated\n  side-effects) of a static data member\n  does not occur unless the static data\n  member is itself used in a way that\n  requires the definition of the static\n  data member to exist.</p>\n</blockquote>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2010-05-18T07:44:16.267", "Id": "2852234", "Score": "7", "CreationDate": "2010-05-17T19:47:09.580", "LastActivityDate": "2010-05-18T07:44:16.267"}, "bq_ids": {"n4140": {"so_2851991_2852234_0": {"section_id": 234, "quality": 0.9767441860465116, "length": 42}}, "n3337": {"so_2851991_2852234_0": {"section_id": 227, "quality": 0.9767441860465116, "length": 42}}, "n4659": {"so_2851991_2852234_0": {"section_id": 244, "quality": 0.9534883720930233, "length": 41}}}, "2851991": {"CommentCount": "1", "AcceptedAnswerId": "2852234", "PostTypeId": "1", "LastEditorUserId": "231717", "CreationDate": "2010-05-17T19:10:12.517", "LastActivityDate": "2010-05-18T07:44:16.267", "LastEditDate": "2010-05-17T21:14:02.590", "ViewCount": "842", "FavoriteCount": "2", "Title": "(static initialization/template instantiation) problems with factory pattern", "Id": "2851991", "Score": "3", "Body": "<p>Why does following code raise an exception (in createObjects call to <code>map::at</code>)\nalternativly the code (and its output) can be viewed <a href=\"http://codepad.org/UFFflN2A\" rel=\"nofollow noreferrer\">here</a></p>\n<p>intererestingly the code works as expected if the commented lines are uncommented with both microsoft and gcc compiler (see <a href=\"http://codepad.org/zNMfSbkx\" rel=\"nofollow noreferrer\">here</a>), this even works with initMap as ordinary static variable instead of static getter.</p>\n<p>The only reason for this i can think of is that the order of initialization of the static registerHelper_ object (<code>factory_helper_</code>)and the <code>std::map</code> object (<code>initMap</code>) are wrong, however i cant see how that could happen, because the map object is constructed on first usage and thats in factory_helper_ constructor, so everything should be alright shouldnt it ?\nI am even more suprised that those doNothing() lines fix the issue, because that call to doNothing() would happen after the critical section (which currently fails) is passed anyway.</p>\n<p><strong>EDIT:</strong> debugging showed, that without the call to factory_helper_.doNothing(), the constructor of factory_helper_ is never called.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n\n#define FACTORY_CLASS(classtype) \\\nextern const char classtype##_name_[] = #classtype; \\\nclass classtype : FactoryBase&lt;classtype,classtype##_name_&gt;\n\nnamespace detail_\n{\n    class registerHelperBase\n    {\n    public:\n        registerHelperBase(){}\n    protected:\n        static std::map&lt;std::string, void * (*)(void)&gt;&amp; getInitMap() {\n            static std::map&lt;std::string, void * (*)(void)&gt;* initMap = 0;\n            if(!initMap)\n                initMap= new std::map&lt;std::string, void * (*)(void)&gt;();\n            return *initMap;\n        }\n    };\n\n    template&lt;class TParent, const char* ClassName&gt;\n    class registerHelper_ : registerHelperBase {\n        static registerHelper_ help_;\n    public:\n        //void doNothing(){}\n        registerHelper_(){\n            getInitMap()[std::string(ClassName)]=&amp;TParent::factory_init_;\n        }\n    };\n    template&lt;class TParent, const char* ClassName&gt;\n    registerHelper_&lt;TParent,ClassName&gt; registerHelper_&lt;TParent,ClassName&gt;::help_;\n}\n\nclass Factory : detail_::registerHelperBase\n{\nprivate:\n    Factory();\npublic:\n    static void* createObject(const std::string&amp; objclassname) {\n        return getInitMap().at(objclassname)();\n    }\n};\n\n\ntemplate &lt;class TClass, const char* ClassName&gt;\nclass FactoryBase {\n    private:\n        static detail_::registerHelper_&lt;FactoryBase&lt;TClass,ClassName&gt;,ClassName&gt; factory_helper_;\n        static void* factory_init_(){ return new TClass();}\n    public:\n        friend class detail_::registerHelper_&lt;FactoryBase&lt;TClass,ClassName&gt;,ClassName&gt;;\n        FactoryBase(){\n            //factory_helper_.doNothing();\n        }\n        virtual ~FactoryBase(){};\n};\n\ntemplate &lt;class TClass, const char* ClassName&gt;\ndetail_::registerHelper_&lt;FactoryBase&lt;TClass,ClassName&gt;,ClassName&gt; FactoryBase&lt;TClass,ClassName&gt;::factory_helper_;\n\n\nFACTORY_CLASS(Test) {\npublic:\n    Test(){}\n};\n\nint main(int argc, char** argv) {\n    try {\n        Test* test = (Test*) Factory::createObject(\"Test\");\n    }\n    catch(const std::exception&amp; ex) {\n        std::cerr &lt;&lt; \"caught std::exception: \"&lt;&lt; ex.what() &lt;&lt; std::endl;\n    }\n    #ifdef _MSC_VER\n        system(\"pause\");\n    #endif\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><static><factory>", "OwnerUserId": "231717", "AnswerCount": "2"}});