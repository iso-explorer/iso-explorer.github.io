post_cb({"39078877": {"ParentId": "39078682", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-22T11:53:37.473", "Score": "0", "LastEditorUserId": "597607", "LastEditDate": "2016-08-22T13:12:29.460", "Id": "39078877", "OwnerUserId": "6710316", "Body": "<p>The default allocation and deallocation functions are special components of the standard library; They have the following unique properties:</p>\n<blockquote>\n<p id=\"so_39078682_39078877_0\"><strong>Global:</strong> All three versions of operator new are declared in the global namespace, not within the std namespace.<br>\n<strong>Implicit:</strong> The allocating versions ((1) and (2)) are implicitly declared in every translation unit of a C++ program, no matter whether header  is included or not.<br>\n<strong>Replaceable:</strong> The allocating versions ((1) and (2)) are also replaceable: A program may provide its own definition that replaces the one provided by default to produce the result described above, or can overload it for specific types.</br></br></p>\n</blockquote>\n<p>Source: <a href=\"http://www.cplusplus.com/reference/new/operator%20new/\" rel=\"nofollow\">http://www.cplusplus.com/reference/new/operator%20new/</a></p>\n", "LastActivityDate": "2016-08-22T13:12:29.460"}, "39078788": {"ParentId": "39078682", "CommentCount": "0", "Body": "<p>The header only provides declarations for all variants of the global <code>operator new</code>. You can still override them without including the header, as long as you get the operator signature right.</p>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "39078788", "Score": "0", "CreationDate": "2016-08-22T11:50:00.800", "LastActivityDate": "2016-08-22T11:50:00.800"}, "39078799": {"ParentId": "39078682", "CommentCount": "0", "Body": "<p>Yes <code>operator new</code> is part of the standard.  The implementation is required to supply the operator at the global scope in each translation unit in your program.  From [basic.stc.dynamic]/2</p>\n<blockquote>\n<p id=\"so_39078682_39078799_0\">The library provides default definitions for the global allocation and deallocation functions. Some global allocation and deallocation functions are replaceable (18.6.1). A C++ program shall provide at most one definition of a replaceable allocation or deallocation function. Any such function definition replaces the default version provided in the library (17.6.4.6). <strong>The following allocation and deallocation functions (18.6) are implicitly declared in global scope in each translation unit of a program.</strong></p>\n<pre><code>void* operator new(std::size_t);\nvoid* operator new[](std::size_t);\nvoid operator delete(void*);\nvoid operator delete[](void*);\nvoid operator delete(void*, std::size_t) noexcept;\nvoid operator delete[](void*, std::size_t) noexcept;\n</code></pre>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>This is why you do not need to include anything to use <code>new</code>/<code>new[]</code> and <code>delete</code>/<code>delete[]</code>.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "39078799", "Score": "4", "CreationDate": "2016-08-22T11:50:48.300", "LastActivityDate": "2016-08-22T11:50:48.300"}, "39078751": {"ParentId": "39078682", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-22T11:48:16.630", "Score": "3", "LastEditorUserId": "485343", "LastEditDate": "2016-08-22T12:08:00.140", "Id": "39078751", "OwnerUserId": "485343", "Body": "<p>Yes, <code>operator new</code> is part of the C++ standard.</p>\n<p>See <a href=\"http://eel.is/c++draft/expr.new\" rel=\"nofollow\">[expr.new]</a>.</p>\n<p>Most of <code>#include &lt;new&gt;</code> is <a href=\"http://eel.is/c++draft/basic.stc.dynamic#2\" rel=\"nofollow\">implicitly declared</a>. But <code>#include &lt;new&gt;</code> declares some more versions of <code>operator new</code>, which are not implicit, for example <em>placement new*</em>:</p>\n<pre><code>void* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\n</code></pre>\n<p>* <em>placement new</em> is not recommended for daily use.</p>\n", "LastActivityDate": "2016-08-22T12:08:00.140"}, "39079027": {"ParentId": "39078682", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-22T12:01:15.607", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:37.963", "Id": "39079027", "OwnerUserId": "186193", "Body": "<p>I agree, this tends to be confusing, but there are a lot of news in C++ (pun intended):</p>\n<ol>\n<li>One of them is the \"<code>new</code> operator\" </li>\n<li>Another one is \"operator <code>new</code>\" a function doing the actual memory allocation</li>\n<li>There is placement <code>new</code></li>\n<li>and some might not like the name, but there is also array <code>new</code>s (<code>new[]</code>)</li>\n</ol>\n<p>Not considering 3, 4 because they are worth a post of their own (<a href=\"https://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new\">What uses are there for \"placement new\"?</a>  and <a href=\"https://stackoverflow.com/questions/4810664/how-do-i-use-arrays-in-c\">How do I use arrays in C++?</a>), the first one (\"<code>new</code> operator\") resides in the global namespace, and it is accessible with the the scope-resolution operator (<code>::</code>), and the second one is the one you can overload in your classes. However regarding the relation of these two, there is an excellent explanation in MSDN (<a href=\"https://msdn.microsoft.com/en-us/library/kewsb8ba.aspx\" rel=\"nofollow noreferrer\">https://msdn.microsoft.com/en-us/library/kewsb8ba.aspx</a>) I just paste it here:</p>\n<blockquote>\n<p id=\"so_39078682_39079027_0\">The new operator invokes the function operator new. For arrays of any type, and for objects that are not of class, struct, or union types, a global function, ::operator new, is called to allocate storage. Class-type objects can define their own operator new static member function on a per-class basis.\n  When the compiler encounters the new operator to allocate an object of type type, it issues a call to type::operator new( sizeof( type ) ) or, if no user-defined operator new is defined, ::operator new( sizeof( type ) ). Therefore, the new operator can allocate the correct amount of memory for the object.</p>\n</blockquote>\n", "LastActivityDate": "2016-08-22T12:01:15.607"}, "39078682": {"CommentCount": "1", "ViewCount": "127", "CreationDate": "2016-08-22T11:44:45.357", "LastActivityDate": "2016-08-22T13:12:29.460", "Title": "Is `operator new` a part of C++ core language?", "AcceptedAnswerId": "39078799", "PostTypeId": "1", "Id": "39078682", "Score": "3", "Body": "<p>I have been told that \"new-expression will call <code>operator new</code> to manage dynamic storage and initialize the object at the same time\" many times. And I don't doubt about that. But I'm wondering that since <code>operator new</code> is declared in standard library header <code>&lt;new&gt;</code>, how could we still using new-expression even if we include no header files.</p>\n<p>Is <code>operator new</code> a part of C++ core language or the compiler includes <code>&lt;new&gt;</code> implicitly?</p>\n", "Tags": "<c++><new-operator>", "OwnerUserId": "5845611", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_39078682_39078799_0": {"section_id": 7174, "quality": 0.8723404255319149, "length": 41}}, "n3337": {"so_39078682_39078799_0": {"section_id": 6918, "quality": 0.8723404255319149, "length": 41}}, "n4659": {"so_39078682_39078799_0": {"section_id": 8682, "quality": 0.8723404255319149, "length": 41}}}});