post_cb({"1403512": {"ParentId": "1403465", "CommentCount": "3", "CreationDate": "2009-09-10T05:29:33.120", "OwnerUserId": "45262", "PostTypeId": "2", "Id": "1403512", "Score": "29", "Body": "<p>It is useful when you want to share a class member and an instance of the class is already a shared_ptr, like the following:</p>\n<pre><code>struct A\n{\n  int *B; // managed inside A\n};\n\nshared_ptr&lt;A&gt;   a( new A );\nshared_ptr&lt;int&gt; b( a, a-&gt;B );\n</code></pre>\n<p>they share the use count and stuff. It is optimization for memory usage.</p>\n", "LastActivityDate": "2009-09-10T05:29:33.120"}, "1403521": {"ParentId": "1403465", "CommentCount": "0", "CreationDate": "2009-09-10T05:32:29.540", "OwnerUserId": "72784", "PostTypeId": "2", "Id": "1403521", "Score": "2", "Body": "<p>You might have a pointer to some driver or a lower level api's data structure that may allocate additional data by its lower level api or other means. In this case it might be interesting to increase the use_count but return the additional data if the first pointer owns the other data pointers.</p>\n", "LastActivityDate": "2009-09-10T05:32:29.540"}, "17631936": {"ParentId": "1403465", "CommentCount": "0", "CreationDate": "2013-07-13T16:11:28.533", "OwnerUserId": "1829943", "PostTypeId": "2", "Id": "17631936", "Score": "0", "Body": "<p>I have put shared_ptr's aliasing constructor in use in my little library:</p>\n<p><a href=\"http://code.google.com/p/infectorpp/\" rel=\"nofollow\">http://code.google.com/p/infectorpp/</a> (just my simple IoC container)</p>\n<p>The point is that since I needed a shared_ptr of known type to be returned from a polymorphic class (that does not know the type). I was not able to implicitly  convert the shared_ptr to the type I needed.</p>\n<p>In the file \"<a href=\"http://code.google.com/p/infectorpp/source/browse/trunk/include/Infectorpp/InfectorHelpers.hpp\" rel=\"nofollow\">InfectorHelpers.hpp</a>\" (line 72-99) you can see that in action for the type IAnyShared.</p>\n<p>Aliasing constructor creates shared_ptr that does not delete the pointers they are actually pointing to, but <strong>they still increase the reference counter</strong> to the original object and that can be tremendously usefull.</p>\n<p>Basically you can create a pointer to anything using aliasing constructor and threat it as a reference counter.</p>\n<pre><code>//my class\nstd::shared_ptr&lt;T&gt; ist;\nint a; //dummy variable. I need its adress\n\nvirtual std::shared_ptr&lt;int&gt; getReferenceCounter(){\n    return std::shared_ptr&lt;int&gt;(ist,&amp;a); //not intended for dereferencing\n}\n\nvirtual void* getPtr(); //return raw pointer to T\n</code></pre>\n<p>now we have both \"a reference counter\" and a pointer to a istance of T, enough data to create something with the aliasing constructor</p>\n<pre><code>std::shared_ptr&lt;T&gt; aPtr( any-&gt;getReferenceCounter(), //share same ref counter \n               static_cast&lt;T*&gt;(any-&gt;getPtr()) ); //potentially unsafe cast!\n</code></pre>\n<p>I don't pretend to have invented this use for the aliasing constructor, but I never seen someone else doing the same. If you are guessing if that dirty code works the answer is yes.</p>\n", "LastActivityDate": "2013-07-13T16:11:28.533"}, "bq_ids": {"n4140": {"so_1403465_1403539_18": {"section_id": 4393, "quality": 0.5384615384615384, "length": 7}, "so_1403465_1403539_17": {"section_id": 4392, "quality": 0.8333333333333334, "length": 15}, "so_1403465_1403539_14": {"section_id": 4390, "quality": 0.7142857142857143, "length": 5}, "so_1403465_1403539_8": {"section_id": 4390, "quality": 0.7142857142857143, "length": 5}, "so_1403465_1403539_11": {"section_id": 4392, "quality": 0.8333333333333334, "length": 15}, "so_1403465_1403539_12": {"section_id": 4393, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_1403465_1403539_18": {"section_id": 4230, "quality": 0.6153846153846154, "length": 8}, "so_1403465_1403539_17": {"section_id": 4229, "quality": 0.8333333333333334, "length": 15}, "so_1403465_1403539_14": {"section_id": 4227, "quality": 0.7142857142857143, "length": 5}, "so_1403465_1403539_8": {"section_id": 4227, "quality": 0.7142857142857143, "length": 5}, "so_1403465_1403539_11": {"section_id": 4229, "quality": 0.8333333333333334, "length": 15}, "so_1403465_1403539_12": {"section_id": 4230, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_1403465_1403539_14": {"section_id": 5655, "quality": 0.8571428571428571, "length": 6}, "so_1403465_1403539_18": {"section_id": 5658, "quality": 0.6153846153846154, "length": 8}, "so_1403465_1403539_8": {"section_id": 5655, "quality": 0.8571428571428571, "length": 6}, "so_1403465_1403539_17": {"section_id": 5657, "quality": 0.8333333333333334, "length": 15}, "so_1403465_1403539_11": {"section_id": 5657, "quality": 0.8333333333333334, "length": 15}, "so_1403465_1403539_12": {"section_id": 5658, "quality": 0.6153846153846154, "length": 8}}}, "1403465": {"CommentCount": "2", "AcceptedAnswerId": "1403512", "CreationDate": "2009-09-10T05:06:28.260", "LastActivityDate": "2014-09-30T20:51:47.443", "PostTypeId": "1", "ViewCount": "2392", "FavoriteCount": "9", "Title": "What is boost's shared_ptr(shared_ptr<Y> const & r, T * p) used for?", "Id": "1403465", "Score": "26", "Body": "<p><code>boost::shared_ptr</code> has an unusual constructor</p>\n<pre><code>template&lt;class Y&gt; shared_ptr(shared_ptr&lt;Y&gt; const &amp; r, T * p);\n</code></pre>\n<p>and I am a little puzzled as to what this would be useful for. Basically it shares ownership with <code>r</code>, but <code>.get()</code> will return <code>p</code>. <strong>not</strong> <code>r.get()</code>!</p>\n<p>This means you can do something like this:</p>\n<pre><code>int main() {\n    boost::shared_ptr&lt;int&gt; x(new int);\n    boost::shared_ptr&lt;int&gt; y(x, new int);\n\n    std::cout &lt;&lt; x.get() &lt;&lt; std::endl;\n    std::cout &lt;&lt; y.get() &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; x.use_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; y.use_count() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And you will get this:</p>\n<pre><code>0x8c66008\n0x8c66030\n2\n2\n</code></pre>\n<p>Note that the pointers are separate, but they both claim to have a <code>use_count</code> of 2 (since they share ownership of the same object).</p>\n<p>So, the <code>int</code> owned by <code>x</code> will exist as long as <code>x</code> <strong>or</strong> <code>y</code> is around. And if I understand the docs correct, the second <code>int</code> never gets destructed. I've confirmed this with the following test program:</p>\n<pre><code>struct T {\n    T() { std::cout &lt;&lt; \"T()\" &lt;&lt; std::endl; }\n    ~T() { std::cout &lt;&lt; \"~T()\" &lt;&lt; std::endl; }\n};\n\nint main() {\n    boost::shared_ptr&lt;T&gt; x(new T);\n    boost::shared_ptr&lt;T&gt; y(x, new T);\n\n    std::cout &lt;&lt; x.get() &lt;&lt; std::endl;\n    std::cout &lt;&lt; y.get() &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; x.use_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; y.use_count() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This outputs (as expected):</p>\n<pre><code>T()\nT()\n0x96c2008\n0x96c2030\n2\n2\n~T()\n</code></pre>\n<p>So... what is the usefulness of this unusual construct which shares ownership of one pointer, but <strong>acts</strong> like another pointer (which it does not own) when used.</p>\n", "Tags": "<c++><boost><shared-ptr><smart-pointers>", "OwnerUserId": "13430", "AnswerCount": "6"}, "3457576": {"ParentId": "1403465", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-08-11T11:00:10.860", "Score": "4", "LastEditorUserId": "178761", "LastEditDate": "2010-08-11T11:18:19.310", "Id": "3457576", "OwnerUserId": "241460", "Body": "<p>You can also use this to keep dynamic casted pointers, i.e.:</p>\n<pre><code>class A {};\nclass B: public A {};\n\nshared_ptr&lt;A&gt; a(new B);\nshared_ptr&lt;B&gt; b(a, dynamic_cast&lt;B*&gt;(a.get()));\n</code></pre>\n", "LastActivityDate": "2010-08-11T11:18:19.310"}, "1403539": {"ParentId": "1403465", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2009-09-10T05:39:23.947", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:19:40.007", "Id": "1403539", "OwnerUserId": "12711", "Body": "<p>To expand on <a href=\"https://stackoverflow.com/questions/1403465/what-is-boosts-sharedptrsharedptry-const-r-t-p-used-for/1403512#1403512\">leiz's</a> and <a href=\"https://stackoverflow.com/questions/1403465/what-is-boosts-sharedptrsharedptry-const-r-t-p-used-for/1403521#1403521\">piotr's</a> answers, this description of <code>shared_ptr&lt;&gt;</code> 'aliasing' is from a WG21 paper, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2351.htm#aliasing\" rel=\"nofollow noreferrer\">\"Improving <code>shared_ptr</code> for C++0x, Revision 2\"</a>:</p>\n<blockquote>\n<p id=\"so_1403465_1403539_0\"><strong>III. Aliasing Support</strong></p>\n<p id=\"so_1403465_1403539_1\">Advanced users often require the\n  ability to create a <code>shared_ptr</code>\n  instance <code>p</code> that shares ownership with\n  another (master) <code>shared_ptr</code> <code>q</code> but\n  points to an object that is not a base\n  of <code>*q</code>. <code>*p</code> may be a member or an\n  element of <code>*q</code>, for example. This\n  section proposes an additional\n  constructor that can be used for this\n  purpose.</p>\n<p id=\"so_1403465_1403539_2\">An interesting side effect of this\n  increase of expressive power is that\n  now the <code>*_pointer_cast</code> functions can\n  be implemented in user code. The\n  <code>make_shared</code> factory function presented\n  later in this document can also be\n  implemented using only the public\n  interface of <code>shared_ptr</code> via the\n  aliasing constructor.</p>\n<p id=\"so_1403465_1403539_3\"><strong>Impact:</strong></p>\n<p id=\"so_1403465_1403539_4\">This feature extends the interface of\n  <code>shared_ptr</code> in a backward-compatible\n  way that increases its expressive\n  power and is therefore strongly\n  recommended to be added to the C++0x\n  standard. It introduces no source- and\n  binary compatibility issues.</p>\n<p id=\"so_1403465_1403539_5\"><strong>Proposed text:</strong></p>\n<p id=\"so_1403465_1403539_6\">Add to <code>shared_ptr</code>\n  [util.smartptr.shared] the following\n  constructor:</p>\n<blockquote id=\"so_1403465_1403539_13\">\n<pre><code>template&lt;class Y&gt; shared_ptr( shared_ptr&lt;Y&gt; const &amp; r, T * p );\n</code></pre>\n</blockquote>\n<p id=\"so_1403465_1403539_7\">Add the following to\n  [util.smartptr.shared.const]:</p>\n<blockquote>\n<pre><code>template&lt;class Y&gt; shared_ptr( shared_ptr&lt;Y&gt; const &amp; r, T * p );\n</code></pre>\n<p id=\"so_1403465_1403539_14\"><em>Effects:</em> Constructs a <code>shared_ptr</code> instance that stores <code>p</code> and <em>shares ownership with</em> <code>r</code>.</p>\n<p id=\"so_1403465_1403539_15\"><em>Postconditions:</em> <code>get() == p &amp;&amp; use_count() == r.use_count()</code>.</p>\n<p id=\"so_1403465_1403539_16\"><em>Throws:</em> nothing.</p>\n<p id=\"so_1403465_1403539_17\"><em>[Note:</em> To avoid the possibility of a dangling pointer, the user \n    of this constructor must ensure that <code>p</code> remains valid at least \n    until the ownership group of <code>r</code> is destroyed. <em>--end note.]</em></p>\n<p id=\"so_1403465_1403539_18\"><em>[Note:</em> This constructor allows creation of an <em>empty</em> <code>shared_ptr</code>\n    instance with a non-NULL stored pointer. <em>--end note.]</em></p>\n</blockquote>\n</blockquote>\n", "LastActivityDate": "2014-09-24T18:58:34.190"}, "4690530": {"ParentId": "1403465", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-01-14T11:25:38.357", "Score": "0", "LastEditorUserId": "13430", "LastEditDate": "2014-09-30T20:51:47.443", "Id": "4690530", "OwnerUserId": "573974", "Body": "<p>For \"<code>shared_ptr&lt;B&gt; b(a, dynamic_cast&lt;B*&gt;(a.get()));</code>\"</p>\n<p>I think it is not the recommended way using smart pointer.</p>\n<p>The recommended way of doing this type conversion should be:</p>\n<pre><code>shared_ptr&lt;B&gt; b(a);\n</code></pre>\n<p>Since in Boost document it is mentioned that:</p>\n<blockquote>\n<p id=\"so_1403465_4690530_0\"><code>shared_ptr&lt;T&gt;</code> can be implicitly\n  converted to <code>shared_ptr&lt;U&gt;</code> whenever T*\n  can be implicitly converted to U*. In\n  particular, <code>shared_ptr&lt;T&gt;</code> is\n  implicitly convertible to <code>shared_ptr&lt;T&gt; const</code>, \n  to <code>shared_ptr&lt;U&gt;</code> where U is an\n  accessible base of T, and to\n  <code>shared_ptr&lt;void&gt;</code>.</p>\n</blockquote>\n<p>In addition to that, we also have <strong>dynamic_pointer_cast</strong>\nwhich could directly do conversion on Smart Pointer object and both of these two methods would be much safer than the manually casting raw pointer way.</p>\n", "LastActivityDate": "2014-09-30T20:51:47.443"}});