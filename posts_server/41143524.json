post_cb({"41155578": {"ParentId": "41143524", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think you could simplify your code - this has nothing to do with type_traits. You'll get the same results with following one:</p>\n<pre><code>template &lt;typename T&gt;\nstruct C;\n\ntemplate&lt;typename T&gt;\nusing first = T;\n\ntemplate &lt;typename T&gt;\nstruct C&lt;first&lt;T&gt;&gt;  // OK only in 5.1\n{\n};\n\nint main ()\n{\n}\n</code></pre>\n<p>Check in online compiler (compiles under 5.1 but not with 5.2 or 4.9 so it's probably a bug) - <a href=\"https://godbolt.org/g/iVCbdm\" rel=\"nofollow noreferrer\">https://godbolt.org/g/iVCbdm</a></p>\n<p>I think that int GCC 5 they moved around template functionality and it's even possible to create two specializations of the same type. It will compile until you try to use it.</p>\n<pre><code>template &lt;typename T&gt;\nstruct C;\n\ntemplate&lt;typename T1, typename T2&gt;\nusing first = T1;\n\ntemplate&lt;typename T1, typename T2&gt;\nusing second = T2;\n\ntemplate &lt;typename T&gt;\nstruct C&lt;first&lt;T, T&gt;&gt;  // OK on 5.1+\n{\n};\n\ntemplate &lt;typename T&gt;\nstruct C&lt;second&lt;T, T&gt;&gt;  // OK on 5.1+\n{\n};\n\nint main ()\n{\n   C&lt;first&lt;int, int&gt;&gt; dummy; // error: ambiguous template instantiation for 'struct C&lt;int&gt;'\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/6oNGDP\" rel=\"nofollow noreferrer\">https://godbolt.org/g/6oNGDP</a></p>\n<p>It might be somehow related to added support for C++14 variable templates. <a href=\"https://isocpp.org/files/papers/N3651.pdf\" rel=\"nofollow noreferrer\">https://isocpp.org/files/papers/N3651.pdf</a></p>\n", "OwnerUserId": "5521126", "LastEditorUserId": "5521126", "LastEditDate": "2016-12-15T20:51:49.353", "Id": "41155578", "Score": "1", "CreationDate": "2016-12-15T02:45:13.710", "LastActivityDate": "2016-12-15T20:51:49.353"}, "41143524": {"CommentCount": "4", "ViewCount": "493", "PostTypeId": "1", "LastEditorUserId": "6451573", "CreationDate": "2016-12-14T13:10:54.957", "LastActivityDate": "2016-12-16T13:00:58.507", "Title": "Should the following code compile according to C++ standard?", "FavoriteCount": "5", "LastEditDate": "2016-12-14T13:15:08.643", "Id": "41143524", "Score": "16", "Body": "<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nstruct C;\n\ntemplate&lt;typename T1, typename T2&gt;\nusing first = T1;\n\ntemplate &lt;typename T&gt;\nstruct C&lt;first&lt;T, std::enable_if_t&lt;std::is_same&lt;T, int&gt;::value&gt;&gt;&gt;\n{\n};\n\nint main ()\n{\n}\n</code></pre>\n<p>Results of compilation by different compilers:</p>\n<p>MSVC:</p>\n<blockquote>\n<p id=\"so_41143524_41143524_0\">error C2753: 'C': partial specialization cannot match argument list for primary template</p>\n</blockquote>\n<p>gcc-4.9:</p>\n<blockquote>\n<p id=\"so_41143524_41143524_1\">error: partial specialization 'C' does not specialize any template arguments</p>\n</blockquote>\n<p>clang all versions:</p>\n<blockquote>\n<p id=\"so_41143524_41143524_2\">error: class template partial specialization does not specialize any template argument; to define the primary template, remove the template argument list</p>\n</blockquote>\n<p>gcc-5+:\nsuccessfully compiles</p>\n<p>And additionaly I want to point out that trivial specialization like:</p>\n<pre><code>template&lt;typename T&gt;\nstruct C&lt;T&gt;\n{\n};\n</code></pre>\n<p>successfully fails to be compiled by gcc. So it seems like it figures out that specialization in my original example is non-trivial. So my question is - is pattern like this explicitly forbidden by C++ standard or not?</p>\n", "Tags": "<c++><templates><gcc><language-lawyer><sfinae>", "OwnerUserId": "1269661", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41143524_41184810_0": {"section_id": 332, "quality": 1.0, "length": 35}, "so_41143524_41143524_0": {"section_id": 149, "quality": 0.7, "length": 7}, "so_41143524_41143524_2": {"section_id": 142, "quality": 0.6875, "length": 11}, "so_41143524_41143524_1": {"section_id": 135, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_41143524_41184810_0": {"section_id": 322, "quality": 1.0, "length": 35}, "so_41143524_41143524_0": {"section_id": 143, "quality": 0.7, "length": 7}, "so_41143524_41143524_2": {"section_id": 136, "quality": 0.6875, "length": 11}, "so_41143524_41143524_1": {"section_id": 129, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_41143524_41184810_0": {"section_id": 341, "quality": 1.0, "length": 35}, "so_41143524_41143524_0": {"section_id": 153, "quality": 0.7, "length": 7}, "so_41143524_41143524_2": {"section_id": 146, "quality": 0.625, "length": 10}, "so_41143524_41143524_1": {"section_id": 98, "quality": 0.5714285714285714, "length": 4}}}, "41184810": {"ParentId": "41143524", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The crucial  paragraph is <a href=\"http://eel.is/c++draft/temp.class.spec#8.2\" rel=\"nofollow noreferrer\">[temp.class.spec]/(8.2)</a>, which requires the partial specialization to be more specialized than the primary template. What Clang actually complains about is the argument list being identical to the primary template's: this has been removed from <a href=\"https://timsong-cpp.github.io/cppwp/n4140/temp.class.spec#8.3\" rel=\"nofollow noreferrer\">[temp.class.spec]/(8.3)</a> by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2033\" rel=\"nofollow noreferrer\">issue 2033</a> (which stated that the requirement was redundant) fairly recently, so hasn't been implemented in Clang yet. However, it apparently has been implemented in GCC, given that it accepts your snippet; it even <a href=\"http://melpon.org/wandbox/permlink/R3ULDAqcqAi3bAjg\" rel=\"nofollow noreferrer\">compiles the following</a>, perhaps for the same reason it compiles your code (it also only works from version 5 onwards):</p>\n<pre><code>template &lt;typename T&gt;\nvoid f( C&lt;T&gt; ) {}\n\ntemplate &lt;typename T&gt;\nvoid f( C&lt;first&lt;T, std::enable_if_t&lt;std::is_same&lt;T, int&gt;::value&gt;&gt;&gt; ) {}\n</code></pre>\n<p>I.e. it acknowledges that the declarations are distinct, so must have implemented some resolution of issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1980\" rel=\"nofollow noreferrer\">1980</a>. It does not find that the second overload is more specialized (see the Wandbox link), however, which is inconsistent, because it should've diagnosed your code according to the aforementioned constraint in (8.2).</p>\n<p>Arguably, the current wording makes your example's partial ordering work as desired<sup>\u2020</sup>: <a href=\"http://eel.is/c++draft/temp.deduct.type#1\" rel=\"nofollow noreferrer\">[temp.deduct.type]/1</a> mentions that in deduction from types,</p>\n<blockquote>\n<p id=\"so_41143524_41184810_0\">Template arguments can be deduced in several different contexts, but in each case a type that is specified in terms of template parameters (call it <code>P</code>) is compared with an actual type (call it <code>A</code>), and an attempt is made to find template argument values [\u2026] that will make <code>P</code>, <strong>after substitution of the deduced values</strong> (call it the deduced <code>A</code>), compatible with <code>A</code>.</p>\n</blockquote>\n<p>Now via <a href=\"http://eel.is/c++draft/temp.alias#3\" rel=\"nofollow noreferrer\">[temp.alias]/3</a>, this would mean that during the partial ordering step in which the partial specialization's function template is the parameter template, the substitution into <code>is_same</code> yields false (since common library implementations just use a partial specialization that must fail), and <code>enable_if</code> fails.<sup>\u2021</sup> But this semantics is not satisfying in the general case, because we could construct a condition that generally succeeds, so a unique synthesized type meets it, and deduction succeeds both ways.</p>\n<p>Presumably, the simplest and most robust solution is to ignore discarded arguments during partial ordering (making your example ill-formed). One can also orientate oneself towards implementations' behaviors in this case (analogous to issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1157\" rel=\"nofollow noreferrer\">1157</a>):</p>\n<pre><code>template &lt;typename...&gt; struct C {};\n\ntemplate &lt;typename T&gt;\nvoid f( C&lt;T, int&gt; ) = delete;\n\ntemplate &lt;typename T&gt;\nvoid f( C&lt;T, std::enable_if_t&lt;sizeof(T) == sizeof(int), int&gt;&gt; ) {}\n\nint main() {f&lt;int&gt;({});}\n</code></pre>\n<p>Both <a href=\"http://melpon.org/wandbox/permlink/ZQLxmGmibhyknyJE\" rel=\"nofollow noreferrer\">Clang</a> and <a href=\"http://melpon.org/wandbox/permlink/ZQLxmGmibhyknyJE#wandbox-resultwindow-code-body-24\" rel=\"nofollow noreferrer\">GCC</a> diagnose this as calling the deleted function, i.e. agree that the first overload is more specialized than the other. The critical property of #2 seems to be that the second template argument is dependent yet <code>T</code> appears solely in non-deduced contexts (if we change <code>int</code> to <code>T</code> in #1, nothing changes). So we could use the existence of discarded (and dependent?) template arguments as tie-breakers: this way we don't have to reason about the nature of synthesized values, which is the status quo, and also get reasonable behavior in your case, which would be well-formed.</p>\n<hr>\n<p><sup>\u2020</sup> @T.C. mentioned that the templates generated through [temp.class.order] would currently be interpreted as one multiply declared entity\u2014again, see issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1980\" rel=\"nofollow noreferrer\">1980</a>. That's not directly relevant to the standardese in this case, because the wording never mentions that these function templates are declared, let alone in the same program; it just specifies them and then falls back to the procedure for function templates.</p>\n<p><sup>\u2021</sup> It isn't entirely clear with what depth implementations are required to perform this analysis. Issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1157\" rel=\"nofollow noreferrer\">1157</a> demonstrates what level of detail is required to \"correctly\" determine whether a template's domain is a proper subset of the other's. It's neither practical nor reasonable to implement partial ordering to be this sophisticated. However, the footnoted section just goes to show that this topic isn't necessarily underspecified, but defective.</p>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-12-16T13:00:58.507", "Id": "41184810", "Score": "4", "CreationDate": "2016-12-16T12:49:36.953", "LastActivityDate": "2016-12-16T13:00:58.507"}});