post_cb({"bq_ids": {"n4140": {"so_16253207_16253207_5": {"length": 9, "quality": 0.75, "section_id": 6892}, "so_16253207_16253207_3": {"length": 4, "quality": 1.0, "section_id": 4896}, "so_16253207_16253207_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 6891}}, "n3337": {"so_16253207_16253207_5": {"length": 9, "quality": 0.75, "section_id": 6638}, "so_16253207_16253207_3": {"length": 4, "quality": 1.0, "section_id": 6636}, "so_16253207_16253207_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 6637}}, "n4659": {"so_16253207_16253207_5": {"length": 9, "quality": 0.75, "section_id": 8392}, "so_16253207_16253207_3": {"length": 4, "quality": 1.0, "section_id": 6288}, "so_16253207_16253207_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 8391}}}, "16253290": {"Id": "16253290", "PostTypeId": "2", "Body": "<p>The meaning looks pretty clear to me: it's not an absolute requirement because it may be impossible to meet under some circumstances, but the implementation <em>should</em> attempt to produce unique values to the extent possible.</p>\n<p>I'd note that the same is true of hash codes in general -- you try to produce values that are unique, but it's not always possible.</p>\n<p>The standard contains a <em>lot</em> of information that's not enforceable. Quite a bit (but certainly not all) is in the form of explicit <code>Note</code>s, but that doesn't mean everything non-normative outside a Note is a defect.</p>\n<p>Edit: in case anybody wants to know what the ISO says about how standards should be written, they have a <a href=\"http://www.iso.org/iso/home/standards_development/resources-for-technical-work/iso_iec_directives_and_iso_supplement.htm\" rel=\"nofollow\">page of guidelines</a>.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2013-04-27T14:42:07.203", "Score": "5", "CreationDate": "2013-04-27T14:33:44.283", "ParentId": "16253207", "CommentCount": "12", "LastEditDate": "2013-04-27T14:42:07.203", "OwnerUserId": "179910"}, "16253207": {"ViewCount": "1477", "Body": "<p>Is it meant to be guaranteed that same <code>std::type_info::hash_code()</code> values imply same types?</p>\n<p><a href=\"http://www.cplusplus.com/reference/typeinfo/type_info/hash_code/\" rel=\"nofollow\">Cplusplus.com</a> seems to claim so:</p>\n<blockquote>\n<p id=\"so_16253207_16253207_0\">This function returns the same value for any two type_info objects that compare equal, and <strong>different values for distinct types</strong> that do not. <em>[Emphasis mine]</em></p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/type_info/hash_code\" rel=\"nofollow\">Cppreference</a> seems to claim otherwise:</p>\n<blockquote>\n<p id=\"so_16253207_16253207_1\">Returns an unspecified value, which is identical for objects, referring to the same type. <strong>No other guarantees are given</strong>, in particular, the value can change between invocations of the same program. <em>[Emphasis mine]</em></p>\n</blockquote>\n<p>The relevant standards paragraphs are:</p>\n<blockquote>\n<p id=\"so_16253207_16253207_2\">\u00a7 p18.7.1 p7-8</p>\n<p id=\"so_16253207_16253207_3\">size_t hash_code() const noexcept;</p>\n<p id=\"so_16253207_16253207_4\">7 Returns: An unspecified value, except that within a single execution of the program, it shall return the same value for any two type_info objects which compare equal.</p>\n<p id=\"so_16253207_16253207_5\">8 Remark: an implementation <strong>should</strong> return different values for two type_info objects which do not compare equal. <em>[Emphasis mine]</em></p>\n</blockquote>\n<p>What's the meaning of \"<strong>should</strong>\" supposed to be in the context above? If paragraph 8 is meant to be a requirement, then it seems impossible to fulfill unless the runtime does some kind of global uniquing over all symbol names in a program to ensure lack of hash collision, which seems to be a pretty big burden for the standard to foist upon implementations, especially for a function called <code>hash_code()</code>. (Itanium actually requires this, but it's explicitly an extra requirement above the standard.)</p>\n<p>If \"<strong>should</strong>\" is not meant to be binding, then the remark seems to be a pointless one and a defect in the standard, since asking implementations to try to fulfill a difficult requirement that cannot be relied upon anyway provides no value and only invites confusion and fragmentation. Anyone know why it's there?</p>\n<p><strong>EDIT</strong>: Maybe \"defect\" was too strong a word, but at least it's a point of possible confusion that should be clarified, since it's apparently misled at least one reference site and transitively misled anyone relying upon it. Furthermore, it actually <strong>is</strong> possible to fulfill the requirement (as long as the number of types supported by the implementation is smaller than the range of <code>size_t</code>) if global uniquing is done at runtime, and it's unclear if the standard is trying to suggest this as the ideal implementation strategy or not. </p>\n", "AcceptedAnswerId": "16253290", "Title": "std::type_info::hash_code() uniqueness and the meaning of \"should\"", "CreationDate": "2013-04-27T14:25:12.403", "Id": "16253207", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-06-13T05:55:49.137", "LastEditorUserId": "2008149", "LastActivityDate": "2013-06-13T05:55:49.137", "Score": "10", "OwnerUserId": "2008149", "Tags": "<c++><language-lawyer><rtti><abi>", "AnswerCount": "1"}});