post_cb({"44694730": {"ParentId": "44694574", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_44694574_44694730_0\">but the declaration of y should be rejected if I want my code to be\n  portable</p>\n</blockquote>\n<p>Be reassured that your code will be portable: but sadly there is no way of getting <code>std::size_t</code> without <code>size_t</code>. That's because <code>#include &lt;cstddef&gt;</code> is required to bring in the C types defined in <code>&lt;stdint.h&gt;</code>.</p>\n<p>Since you can't \"undefine\" a type in C++, your only recourse is the use of static analysis tools: then you can enforce any style rule that tickles your fancy.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2017-06-22T08:59:59.027", "Id": "44694730", "Score": "0", "CreationDate": "2017-06-22T08:56:29.303", "LastActivityDate": "2017-06-22T08:59:59.027"}, "44694661": {"ParentId": "44694574", "CommentCount": "6", "Body": "<p>Unfortunately these headers must also define all the types from corresponding c header.</p>\n<blockquote>\n<p id=\"so_44694574_44694661_0\"><strong>18.4.1 Header  synopsis</strong> [cstdint.syn]</p>\n<p id=\"so_44694574_44694661_1\">2 The header defines all types and macros the same as the C standard library header <code>&lt;stdint.h&gt;</code>.</p>\n</blockquote>\n", "OwnerUserId": "7860670", "PostTypeId": "2", "Id": "44694661", "Score": "3", "CreationDate": "2017-06-22T08:53:32.713", "LastActivityDate": "2017-06-22T08:53:32.713"}, "46076180": {"ParentId": "44694574", "CommentCount": "0", "Body": "<p>The rule is that <code>#include &lt;xxx.h&gt;</code> (where <code>xxx.h</code> is the name of a standard C header) is <strong>required</strong> to define all the names required by the C standard for that header in the global namespace, and is <strong>allowed</strong> to also define those names (with the same meaning) in namespace <code>std</code>. Similarly, <code>#include &lt;cxxx&gt;</code> (where <code>cxxx</code> is the name of one of the standard C++ headers for the standard C library) is <strong>required</strong> to define all the names from the corresponding C header (with the same meaning) in the namespace <code>std</code>, and is <strong>allowed</strong> to also define those names in the global namespace.</p>\n<p>Back in C++ 98 those headers were not allowed to add names to the other namespace. Some compiler couldn't do that. For example, if the C++ library writers don't control the C headers, the usual implementation technique is for the C++ header to <code>#include</code> the C header and hoist the C names into <code>std</code> with using declarations. So the rule was changed to reflect reality.</p>\n<p>The language definition does <strong>not</strong> require those headers to put the names in both places; if it did, then the <code>cxxx</code> headers wouldn't be needed.</p>\n<p>In short, you can't count on <code>#include &lt;cxxx&gt;</code> putting C names into the global namespace, but you also can't count on it not putting them there.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "46076180", "Score": "2", "CreationDate": "2017-09-06T13:09:38.503", "LastActivityDate": "2017-09-06T13:09:38.503"}, "bq_ids": {"n4140": {"so_44694574_44694661_1": {"section_id": 3396, "quality": 0.6, "length": 6}}, "n3337": {"so_44694574_44694661_1": {"section_id": 3265, "quality": 0.6, "length": 6}}, "n4659": {"so_44694574_44694661_1": {"section_id": 8287, "quality": 0.9, "length": 9}}}, "44694574": {"CommentCount": "6", "ViewCount": "148", "PostTypeId": "1", "LastEditorUserId": "4850040", "CreationDate": "2017-06-22T08:49:28.707", "LastActivityDate": "2017-09-06T13:09:38.503", "Title": "Can I stop GCC including standard library names into the global namespace?", "AcceptedAnswerId": "46076180", "LastEditDate": "2017-06-22T09:13:02.880", "Id": "44694574", "Score": "3", "Body": "<p>When I use Standard C headers in C++, I generally prefer the forms which place identifiers into the <code>std</code> namespace, such as <code>&lt;cstdlib&gt;</code>.  However, when I use these, GCC also places the names into the global namespace, which means that it will accept programs such as this:</p>\n<pre><code>#include &lt;cstddef&gt;\n\nstd::size_t x;\nsize_t y;\n\nint main() {}\n</code></pre>\n<p>Here, the declaration of <code>x</code> is correct, but the declaration of <code>y</code> should be rejected if I want my code to be portable.  (Note that if I included <code>&lt;stddef.h&gt;</code> instead of <code>&lt;cstddef&gt;</code>, GCC <em>will</em> correctly reject the declaration of <code>x</code>).</p>\n<p>Can I get GCC to reject the declaration <code>y</code> above?</p>\n<p>I compiled with all the pedantry and warnings I could think of:</p>\n<pre><code>-std=c++17 -pedantic -Wall -Wextra -Wpedantic -Weffc++\n</code></pre>\n<p>None of those seem to prevent GCC from accepting the non-portable form.</p>\n<hr>\n<p>I'm now unsure whether I understand the rules correctly; my knowledge comes from this section in CPP Reference:</p>\n<blockquote>\n<h2>C compatibility headers</h2>\n<p id=\"so_44694574_44694574_0\">For some of the C standard library headers of the form <code>xxx.h</code>, the C++ standard library both includes an\n  identically-named header and another header of the form <code>cxxx</code>.</p>\n<p id=\"so_44694574_44694574_1\">With the exception of <code>complex.h</code>, each <code>xxx.h</code> header included in the C++\n  standard library places in the global namespace each name that the\n  corresponding <code>cxxx</code> header would have placed in the <code>std</code> namespace.</p>\n<p id=\"so_44694574_44694574_2\">These headers are allowed to also declare the same names in the <code>std</code>\n  namespace, and the corresponding <code>cxxx</code> headers are allowed to also\n  declare the same names in the global namespace: including <code>&lt;cstdlib&gt;</code>\n  definitely provides <code>std::malloc</code> and may also provide <code>::malloc</code>.\n  Including <code>&lt;stdlib.h&gt;</code> definitely provides <code>::malloc</code> and may also provide\n  <code>std::malloc</code>. This applies even to functions and function overloads\n  that are not part of C standard library.</p>\n</blockquote>\n<p>To me, that last paragraph indicates that GCC's behaviour is permitted but not required, and therefore it's wrong to depend on it.</p>\n</hr>", "Tags": "<c++><gcc><namespaces>", "OwnerUserId": "4850040", "AnswerCount": "3"}});