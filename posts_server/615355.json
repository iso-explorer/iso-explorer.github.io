post_cb({"bq_ids": {"n4140": {"so_615355_10259714_0": {"section_id": 6106, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_615355_10259714_0": {"section_id": 5872, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_615355_10259714_0": {"section_id": 7603, "quality": 0.6666666666666666, "length": 6}}}, "615408": {"CommentCount": "6", "CreationDate": "2009-03-05T15:59:28.677", "LastEditorUserId": "1968", "LastActivityDate": "2009-03-09T12:27:33.410", "ParentId": "615355", "PostTypeId": "2", "LastEditorDisplayName": "Konrad Rudolph", "LastEditDate": "2009-03-09T12:27:33.410", "Id": "615408", "Score": "35", "Body": "<p>This would be very bad, but since <code>operator delete</code> can be overloaded a sloppy programmer might have omitted the test for null pointers, thus requiring the client to check for it. This <em>might</em> be a reason for it here.</p>\n<p>Another point, setting the pointer explicitly to null after deleting might actually make sense depending on the architecture of the code, precisely to <em>prevent</em> double-deletes. Since this only saves double-deletes on the same pointer though, it's highly questionable whether this is a good design. I wouldn't ever rely on it.</p>\n<h3>An explanation of overloaded <code>operator delete</code>:</h3>\n<p><code>operator delete</code> is (despite its name) a function that may be overloaded like any other function. This function gets called internally for every call of <code>operator delete</code> with matching arguments. The same is true for <code>operator new</code>.</p>\n<p>Overloading <code>operator new</code> (and then also <code>operator delete</code>) makes sense in some situations when you want to control precisely how memory is allocated. Doing this isn't even very hard, but a few precautions must be made to ensure correct behaviour. Scott Meyers describes this in great detail <em>Effective C++</em>.</p>\n<p>For now, let's just say that we want to overload the global version of <code>operator new</code> for debugging. Before we do this, one short notice about what happens in the following code:</p>\n<pre><code>klass* pobj = new klass;\n// \u2026 use pobj.\ndelete pobj;\n</code></pre>\n<p>What actually happens here? Well the above can be roughly translated to the following code:</p>\n<pre><code>// 1st step: allocate memory\nklass* pobj = static_cast&lt;klass*&gt;(operator new(sizeof(klass)));\n// 2nd step: construct object in that memory, using placement new:\nnew (pobj) klass();\n\n// \u2026 use pobj.\n\n// 3rd step: call destructor on pobj:\npobj-&gt;~klass();\n// 4th step: free memory\noperator delete(pobj);\n</code></pre>\n<p>Notice step 2 where we call <code>new</code> with a slightly odd syntax. This is a call to so-called <em>placement <code>new</code></em> which takes an address and constructs an object at that address. This operator can be overloaded as well. In this case, it just serves to call the constructor of the class <code>klass</code>.</p>\n<p>Now, without further ado here's the code for an overloaded version of the operators:</p>\n<pre><code>void* operator new(size_t size) {\n    // See Effective C++, Item 8 for an explanation.\n    if (size == 0)\n        size = 1;\n\n    cerr &lt;&lt; \"Allocating \" &lt;&lt; size &lt;&lt; \" bytes of memory:\";\n\n    while (true) {\n        void* ret = malloc(size);\n\n        if (ret != 0) {\n            cerr &lt;&lt; \" @ \" &lt;&lt; ret &lt;&lt; endl;\n            return ret;\n        }\n\n        // Retrieve and call new handler, if available.\n        new_handler handler = set_new_handler(0);\n        set_new_handler(handler);\n\n        if (handler == 0)\n            throw bad_alloc();\n        else\n            (*handler)();\n    }\n}\n\nvoid operator delete(void* p) {\n    cerr &lt;&lt; \"Freeing pointer @ \" &lt;&lt; p &lt;&lt; \".\" &lt;&lt; endl;\n    free(p);\n}\n</code></pre>\n<p>This code just uses <code>malloc</code>/<code>free</code> internally, much as most default implementations. It also creates a debugging output. Consider the following code:</p>\n<pre><code>int main() {\n    int* pi = new int(42);\n    cout &lt;&lt; *pi &lt;&lt; endl;\n    delete pi;\n}\n</code></pre>\n<p>It yielded the following output:</p>\n<pre><code>Allocating 4 bytes of memory: @ 0x100160\n42\nFreeing pointer @ 0x100160.\n</code></pre>\n<p>Now, this code does something fundamentally different than the standard implementation of <code>operator delete</code>: <strong>It didn't test for null pointers!</strong> The compiler doesn't check this so the above code compiles but it may give nasty errors at run-time when you try to delete null pointers.</p>\n<p>However, as I said before, this behaviour is actually unexpected and a library writer <strong>should</strong> take care to check for null pointers in the <code>operator delete</code>. This version is much improved:</p>\n<pre><code>void operator delete(void* p) {\n    if (p == 0) return;\n    cerr &lt;&lt; \"Freeing pointer @ \" &lt;&lt; p &lt;&lt; \".\" &lt;&lt; endl;\n    free(p);\n}\n</code></pre>\n<p>In conclusion, although a sloppy implementation of <code>operator delete</code> may require explicit null checks in the client code, this is non-standard behaviour and should only be tolerated in legacy support (<em>if at all</em>).</p>\n", "OwnerUserId": "1968", "OwnerDisplayName": "Konrad Rudolph"}, "615405": {"ParentId": "615355", "CommentCount": "1", "CreationDate": "2009-03-05T15:58:52.500", "OwnerUserId": "23424", "Id": "615405", "PostTypeId": "2", "OwnerDisplayName": "VoidPointer", "Score": "0", "Body": "<p>There is no reason to check for NULL prior to delete.\nAssigning NULL after delete might be necessary if somewhere in the code checks are made whether some object is already allocated by performing a NULL check. An example would be some sort of cached data that is allocated on demand. Whenever you clear out the cache-object you assign NULL to the pointer so the code that allocates the object knows that it needs to perform an allocation.</p>\n", "LastActivityDate": "2009-03-05T15:58:52.500"}, "1242419": {"ParentId": "615355", "CommentCount": "1", "CreationDate": "2009-08-07T01:21:06.747", "Id": "1242419", "PostTypeId": "2", "OwnerDisplayName": "aaaa", "Score": "-5", "Body": "<p>As for my observations, deleting a null pointer using delete is safe in unix based machines ike PARISC and itanium.  But is quite unsafe for Linux systems as the process would crash then.</p>\n", "LastActivityDate": "2009-08-07T01:21:06.747"}, "615368": {"ParentId": "615355", "CommentCount": "2", "CreationDate": "2009-03-05T15:50:15.593", "OwnerUserId": "52443", "Id": "615368", "PostTypeId": "2", "OwnerDisplayName": "Welbog", "Score": "6", "Body": "<p>Deleting null is a no-op. There's no reason to check for null before calling delete.</p>\n<p>You might want to check for null for other reasons if the pointer being null carries some additional information you care about.</p>\n", "LastActivityDate": "2009-03-05T15:50:15.593"}, "615427": {"CommentCount": "1", "CreationDate": "2009-03-05T16:04:03.627", "LastEditorUserId": "41283", "LastActivityDate": "2009-03-05T16:09:54.407", "ParentId": "615355", "PostTypeId": "2", "LastEditorDisplayName": "Hosam Aly", "LastEditDate": "2009-03-05T16:09:54.407", "Id": "615427", "Score": "0", "Body": "<p>It depends on what you are doing.  Some older implementations of <code>free</code>, for example, will not be happy if they are passed a <code>NULL</code> pointer.  Some libraries still have this problem.  For example, <code>XFree</code> in the Xlib library says:</p>\n<blockquote>\n<p id=\"so_615355_615427_0\">DESCRIPTION</p>\n<p id=\"so_615355_615427_1\">The XFree function is a\n  general-purpose Xlib routine that\n  frees the specified data.  You must\n  use it to free any objects that were\n  allocated by Xlib, unless an alternate\n  function is explicitly specified for\n  the object. A NULL pointer cannot be\n  passed to this function.</p>\n</blockquote>\n<p>So consider freeing <code>NULL</code> pointers as a bug and you'll be safe.</p>\n", "OwnerUserId": "26534", "OwnerDisplayName": "Michael Trausch"}, "615366": {"ParentId": "615355", "CommentCount": "10", "CreationDate": "2009-03-05T15:50:03.083", "OwnerUserId": "12716", "Id": "615366", "PostTypeId": "2", "OwnerDisplayName": "Randolpho", "Score": "60", "Body": "<p>It's perfectly \"safe\" to delete a null pointer; it effectively amounts to a no-op. </p>\n<p>The reason you might want to check for null before you delete is that trying to delete a null pointer could indicate a bug in your program. </p>\n", "LastActivityDate": "2009-03-05T15:50:03.083"}, "616535": {"ParentId": "615355", "CommentCount": "4", "CreationDate": "2009-03-05T20:46:17.347", "OwnerUserId": "21258", "Id": "616535", "PostTypeId": "2", "OwnerDisplayName": "Joe Pineda", "Score": "0", "Body": "<p>I believe the previous developer coded it \"redundantly\" to save some milliseconds:\nIt's a good thing to have the pointer be set to NULL upon being deleted, so you could use a line like the following right after deleting the object:</p>\n<pre><code>if(pSomeObject1!=NULL) pSomeObject1=NULL;\n</code></pre>\n<p>But then delete is doing that exact comparison anyway (doing nothing if it's NULL). Why do this twice? You can always assign pSomeObject to NULL after calling delete, regardless of its current value - but this would be slightly redundant if it had that value already.</p>\n<p>So my bet is the author of those lines tried to ensure pSomeObject1 would always be NULL after being deleted, without incurring the cost of a potentially unnecessary test and assignation.</p>\n", "LastActivityDate": "2009-03-05T20:46:17.347"}, "615378": {"CommentCount": "2", "CreationDate": "2009-03-05T15:51:22.830", "LastEditorUserId": "12567", "LastActivityDate": "2009-11-11T21:19:00.563", "ParentId": "615355", "LastEditDate": "2009-11-11T21:19:00.563", "OwnerDisplayName": "Joe", "PostTypeId": "2", "Id": "615378", "Score": "3", "Body": "<p>If pSomeObject is NULL, delete won't do anything. So no, you don't have to check for NULL.</p>\n<p>We consider it good practice to assign NULL to the pointer after deleting it if it's at all possible that some knucklehead can attempt to use the pointer. Using a NULL pointer is slightly better than using a pointer to who knows what (the NULL pointer will cause a crash, the pointer to deleted memory may not)</p>\n", "OwnerUserId": "12567"}, "10259714": {"ParentId": "615355", "CommentCount": "2", "Body": "<p>According to C++03 5.3.5/2, it's safe to delete a null pointer.\nThis following is quoted from the standard:</p>\n<blockquote>\n<p id=\"so_615355_10259714_0\">In either alternative, if the value of the operand of delete is the\n  null pointer the operation has no effect.</p>\n</blockquote>\n", "OwnerUserId": "1348273", "PostTypeId": "2", "Id": "10259714", "Score": "4", "CreationDate": "2012-04-21T14:20:26.203", "LastActivityDate": "2012-04-21T14:20:26.203"}, "615355": {"CommentCount": "1", "AcceptedAnswerId": "615366", "PostTypeId": "1", "LastEditorUserId": "2246344", "LastEditorDisplayName": "EvilTeach", "CreationDate": "2009-03-05T15:47:00.577", "LastActivityDate": "2014-08-23T10:10:41.567", "AnswerCount": "10", "LastEditDate": "2014-08-23T10:10:41.567", "ViewCount": "27267", "FavoriteCount": "13", "Title": "Is there any reason to check for a NULL pointer before deleting?", "Id": "615355", "Score": "46", "Body": "<p>I often see legacy code checking for <code>NULL</code> before deleting a pointer, similar to,</p>\n<pre><code>if (NULL != pSomeObject) \n{\n    delete pSomeObject;\n    pSomeObject = NULL;\n}\n</code></pre>\n<p>Is there any reason to checking for a <code>NULL</code> pointer before deleting it? What is the reason for setting the pointer to <code>NULL</code> afterwards?</p>\n", "Tags": "<c++><pointers><null><delete-operator>", "OwnerUserId": "22076", "OwnerDisplayName": "rajKumar"}, "615410": {"ParentId": "615355", "CommentCount": "4", "CreationDate": "2009-03-05T15:59:31.873", "OwnerUserId": "7734", "Id": "615410", "PostTypeId": "2", "OwnerDisplayName": "EvilTeach", "Score": "5", "Body": "<p>Delete checks for NULL internally.  Your test is redundent</p>\n", "LastActivityDate": "2009-03-05T15:59:31.873"}});