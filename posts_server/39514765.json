post_cb({"39515239": {"ParentId": "39514765", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The relevant clause for this is 13.3.1.2/9 [over.match.oper] in N4140:</p>\n<blockquote>\n<p id=\"so_39514765_39515239_0\">If the operator is the operator <code>,</code>, the unary operator <code>&amp;</code>, or the operator <code>-&gt;</code>, and there are no viable functions,\n  then the operator is assumed to be the built-in operator and interpreted according to Clause 5.</p>\n</blockquote>\n<p>As <code>void()</code> is never a valid function argument (see 5.2.2/7 [expr.call]), there never is a viable function and thus the built-in <code>,</code> will be used.</p>\n<p>So no, what you are trying to do is not possible. </p>\n<p>In fact, writing an iterator loop like this</p>\n<pre><code>for(...; ++it1, (void)++it2)\n</code></pre>\n<p>is a standard way to prevent users from breaking your code by overloading <code>,</code> for their iterator types by enforcing the built-in operator <code>,</code> to be used. (Note that I am not saying you need to do this in your everyday code. It very much depends on its actual use. This is standard library level of paranoid.)</p>\n<hr>\n<p>Regarding the standard clause you linked:</p>\n<blockquote>\n<p id=\"so_39514765_39515239_1\">The meaning of the operators =, (unary) &amp;, and , (comma), predefined for each type, can be changed for specific class and enumeration types <strong>by defining operator functions that implement these operators</strong>.</p>\n</blockquote>\n<p>But such a function cannot by defined because, as I said above, <code>void()</code> is never a valid function argument.</p>\n<p>Now whether or not this is an oversight/problem in the standard is open to debate.</p>\n</hr>", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2016-09-19T22:35:53.743", "Id": "39515239", "Score": "19", "CreationDate": "2016-09-15T15:43:56.903", "LastActivityDate": "2016-09-19T22:35:53.743"}, "39514765": {"CommentCount": "9", "AcceptedAnswerId": "39515239", "CreationDate": "2016-09-15T15:19:12.997", "LastActivityDate": "2016-09-19T22:35:53.743", "PostTypeId": "1", "ViewCount": "390", "FavoriteCount": "2", "Title": "The void(), the comma operator (operator,) and the impossible (?) overloading", "Id": "39514765", "Score": "15", "Body": "<p>Consider the following struct:</p>\n<pre><code>struct S {};\n</code></pre>\n<p>In C++14, the definition below is valid:</p>\n<pre><code>constexpr auto f() { return S{}, 'c'; }\n</code></pre>\n<p>As well as the following one:</p>\n<pre><code>constexpr auto f() { return S{}, void(); }\n</code></pre>\n<p>Now, consider the following, working snippet that involves the first of the two definitions:</p>\n<pre><code>#include&lt;type_traits&gt;\n\nstruct S {};\n\nconstexpr int operator,(S, char) { return 42; }\nconstexpr auto f() { return S{}, 'c'; }\n\nint main() {\n    constexpr int i{f()};\n    static_assert(i == 42, \"!\");\n    static_assert(std::is_same&lt;decltype(f()), int&gt;::value, \"!\");\n}\n</code></pre>\n<p>Speaking not so technically, the overload of the comma operator <em>intercepts</em> the couple <code>S{}, 'c'</code> and returns an integer, as correctly verified in the <code>main</code> function.</p>\n<p>Now, suppose I want to do the same with the second definition of <code>f</code>:</p>\n<pre><code>constexpr auto f() { return S{}, void(); }\n</code></pre>\n<p>In this case, the comma operator should <em>intercept</em> the form <code>S{}, void()</code>.<br>\nNeither the following definition works (for obvious reasons):</br></p>\n<pre><code>constexpr int operator,(S, void) { return 42; }\n</code></pre>\n<p>Nor the one below (that would have worked in the previous case):</p>\n<pre><code>template&lt;typename T&gt; constexpr int operator,(S, T &amp;&amp;) { return 42; }\n</code></pre>\n<p>Is there any way to overload the comma operator so as to deal with <code>S{}, void()</code>?<br>\nIsn't it otherwise a lack in the standard, for it allows to use the comma operator that way, but doesn't give you the chance to overload the same operator (even if <a href=\"http://eel.is/c++draft/over.oper#6\">the standard mentions that overloaded functions involving <code>S</code> are allowed</a>)?</br></p>\n<hr>\n<p><sub><strong>Note</strong>: this question is made for the sake of curiosity. Please, avoid comments like <em>do not do that</em> or <em>it is not good practice</em>. I'm not planning to do that in production environments. Thank you.</sub></p>\n</hr>", "Tags": "<c++><operator-overloading><language-lawyer><void><comma-operator>", "OwnerUserId": "4987285", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39514765_39515239_0": {"section_id": 590, "quality": 1.0, "length": 16}, "so_39514765_39515239_1": {"section_id": 653, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_39514765_39515239_0": {"section_id": 580, "quality": 1.0, "length": 16}, "so_39514765_39515239_1": {"section_id": 643, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_39514765_39515239_0": {"section_id": 613, "quality": 1.0, "length": 16}, "so_39514765_39515239_1": {"section_id": 681, "quality": 0.9473684210526315, "length": 18}}}});