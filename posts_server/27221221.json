post_cb({"27221221": {"CommentCount": "1", "ViewCount": "153", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2014-12-01T03:21:00.020", "LastActivityDate": "2017-05-01T18:02:15.040", "Title": "Assignment operator requirement for Key type in std::map", "LastEditDate": "2017-05-01T18:02:15.040", "Id": "27221221", "Score": "5", "Body": "<p>It seems to suggest here <a href=\"https://stackoverflow.com/questions/6573225/what-requirements-must-stdmap-key-classes-meet-to-be-valid-keys\">What requirements must std::map key classes meet to be valid keys?</a>, and in a few other posts, that the Key type of an srd::map must have an assignment operator. However I have not been able to find that requirement in the standard.</p>\n<pre><code>#include &lt;map&gt;\n\nstruct Foo\n{\n    Foo&amp; operator=( const Foo&amp; ) = delete;\n\n    int id;\n};\n\nbool operator&lt;( const Foo&amp;, const Foo&amp; ) { return( false ); }\n\nint main( int, char** )\n{\n    std::map&lt;Foo,int&gt; a;\n    std::map&lt;Foo,int&gt; b;\n\n    a = b;   // Should this work if Foo does not have an assignment operator?\n\n    return( false );\n}\n</code></pre>\n<p>The above compiles with GCC 4.9 and Visual Studio 2013 but fails, complaining about the lack of an assignment operator, with clang 3.5 on an Ubuntu 14.10 box running the following command \"clang++ -std=c++11 -stdlib=libc++ code.cpp\". Clang does succeed when using the GCC standard library. I suspect the clang standard library is broken here.</p>\n", "Tags": "<c++><c++11><clang++>", "OwnerUserId": "849856", "AnswerCount": "1"}, "27221313": {"ParentId": "27221221", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-12-01T03:34:35.757", "Score": "4", "LastEditorUserId": "2756719", "LastEditDate": "2015-04-05T02:07:24.863", "Id": "27221313", "OwnerUserId": "2756719", "Body": "<p>\u00a723.1 [container.requirements.general]/p15 &amp; Table 99:</p>\n<blockquote>\n<p id=\"so_27221221_27221313_0\">In Table 99, <code>X</code> denotes an allocator-aware container class with a\n  <code>value_type</code> of <code>T</code> using allocator of type <code>A</code>, <code>u</code> denotes a\n  variable, <code>a</code> and <code>b</code> denote non-const lvalues of type <code>X</code>, <code>t</code>\n  denotes an lvalue or a const rvalue of type <code>X</code>, <code>rv</code> denotes a\n  non-const rvalue of type <code>X</code>, and <code>m</code> is a value of type <code>A</code>.</p>\n</blockquote>\n<p>The relevant part of Table 99 (Allocator-aware container requirements) is:</p>\n<pre class=\"lang-none prettyprint-override\"><code>+-----------+-------------+--------------------------------+------------+\n|Expression | Return type |   Assertion/note               | Complexity |\n|           |             | pre-/post-condition            |            |\n|-----------+-------------+--------------------------------+------------+\n|   a = t   |      X&amp;     | Requires: T is CopyInsertable  | linear     |\n|           |             | into X and CopyAssignable.     |            |\n|           |             | post: a == t                   |            |\n+-----------+-------------+--------------------------------+------------+\n</code></pre>\n<p>And then \u00a723.2.4 [associative.reqmts]/p7 says</p>\n<blockquote>\n<p id=\"so_27221221_27221313_1\">The associative containers meet all the requirements of\n  Allocator-aware containers (23.2.1), except that for <code>map</code> and\n  <code>multimap</code>, the requirements placed on <code>value_type</code> in Table 96 apply\n  instead to <code>key_type</code> and <code>mapped_type</code>. [ <em>Note</em>: For example, in some\n  cases <code>key_type</code> and <code>mapped_type</code> are required to be <code>CopyAssignable</code>\n  even though the associated <code>value_type</code>, <code>pair&lt;const key_type, mapped_type&gt;</code>, is not <code>CopyAssignable</code>. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>Note that this references Table 96, but given the note the intent is clearly to cover Table 99 as well, since nothing in Table 96 actually requires <code>CopyAssignable</code>. Since the <code>value_type</code>, <code>pair&lt;const key_type, mapped_type&gt;</code>, is never <code>CopyAssignable</code>, reading the Table 99 requirements to refer to it would be rather absurd.</p>\n", "LastActivityDate": "2015-04-05T02:07:24.863"}, "bq_ids": {"n4140": {"so_27221221_27221313_0": {"section_id": 716, "quality": 0.9615384615384616, "length": 25}, "so_27221221_27221313_1": {"section_id": 743, "quality": 0.8205128205128205, "length": 32}}, "n3337": {"so_27221221_27221313_0": {"section_id": 705, "quality": 0.9615384615384616, "length": 25}, "so_27221221_27221313_1": {"section_id": 732, "quality": 0.8205128205128205, "length": 32}}, "n4659": {"so_27221221_27221313_0": {"section_id": 746, "quality": 0.9615384615384616, "length": 25}, "so_27221221_27221313_1": {"section_id": 801, "quality": 0.8205128205128205, "length": 32}}}});