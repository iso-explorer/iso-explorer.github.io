post_cb({"bq_ids": {"n4140": {"so_30201414_30201574_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7112}, "so_30201414_30201574_2": {"length": 6, "quality": 1.0, "section_id": 7112}}, "n3337": {"so_30201414_30201574_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6856}, "so_30201414_30201574_2": {"length": 6, "quality": 1.0, "section_id": 6856}}, "n4659": {"so_30201414_30201574_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8613}, "so_30201414_30201574_2": {"length": 6, "quality": 1.0, "section_id": 8613}}}, "30201414": {"ViewCount": "240", "Body": "<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n\n\ntemplate&lt;typename... T&gt; struct test {\n\n    using args_type = std::tuple&lt;T...&gt;;\n\n    args_type x;\n\n    template&lt;std::size_t... I&gt;\n    void callme(std::index_sequence&lt;I...&gt;) {\n        int _[] = {(std::get&lt;I&gt;(x).std::tuple_element&lt;I, args_type&gt;::type::~type(), true)...};\n    }\n};\n\nint main() {\n}\n</code></pre>\n<p>The error message is</p>\n<pre><code>clang-3.7  -std=gnu++1y  -Wc++14-extensions test.cpp\ntest.cpp:15:56: error: expected ')'\n        int _[] = {(std::get&lt;I&gt;(x).std::tuple_element&lt;I, args_type&gt;::type::~type(), true)...};\n                                                       ^\ntest.cpp:15:20: note: to match this '('\n        int _[] = {(std::get&lt;I&gt;(x).std::tuple_element&lt;I, args_type&gt;::type::~type(), true)...};\n                   ^\n1 error generated.\n</code></pre>\n<p>The same code seems to compile just fine with G++ 4.9.2. I couldn't find any relevant bug report on Clang yet.</p>\n", "AcceptedAnswerId": "30201574", "Title": "Why does Clang++ compiler fail to compile the following variadic template code?", "CreationDate": "2015-05-12T21:07:02.553", "Id": "30201414", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-05-19T04:25:31.260", "Score": "8", "OwnerUserId": "1093147", "Tags": "<c++><c++14><clang++>", "AnswerCount": "2"}, "30201574": {"Id": "30201574", "PostTypeId": "2", "Body": "<p>Appears to be a Clang bug, though the lookup of such pseudo-destructor-names is probably defected and subject of open CWG issues, specifically 555 and 399.</p>\n<p>The significant bit of the expansion pattern is</p>\n<pre><code>std::get&lt;I&gt;(x).std::tuple_element&lt;I, args_type&gt;::type::~type()\n</code></pre>\n<p>Here, the bit between <code>.</code> and <code>()</code> is a <em>pseudo-destructor-name</em>; Qualified name lookup then mandates that</p>\n<blockquote>\n<p id=\"so_30201414_30201574_0\">If a <em>pseudo-destructor-name</em> (5.2.4) contains a <em>nested-name-specifier</em>,\n  the <em>type-name</em>s are looked up as types in the scope designated by the\n  <em>nested-name-specifier</em>. Similarly, in a <em>qualified-id</em> of the form:</p>\n<p id=\"so_30201414_30201574_1\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>nested-name-specifier<sub>opt</sub>\u00a0 class-name</em> <code>:: ~</code> <em>class-name</em></p>\n<p id=\"so_30201414_30201574_2\">the second <em>class-name</em> is looked up in the same scope as the first.</p>\n</blockquote>\n<p>I.e. <code>type</code> is looked up in  <code>std::tuple_element&lt;I, args_type&gt;</code>, where it's found to refer to some type. Note that <em>class-name</em> is a grammatical name for identifiers (and <em>simple-template-id</em>s), and need not refer to an actual class. <code>std::get&lt;I&gt;(x).std::tuple_element&lt;I, args_type&gt;::type::~type</code> then refers to the destructor of <code>type</code>. </p>\n<p>Workaround with an auxiliary function:</p>\n<pre><code>template &lt;typename T&gt;\nvoid destroy(T&amp; p) {p.~T();}\n\ntemplate&lt;typename... T&gt; struct test {\n    using args_type = std::tuple&lt;T...&gt;;\n\n    args_type x;\n\n    template&lt;std::size_t... I&gt;\n    void callme(std::index_sequence&lt;I...&gt;) {\n        int _[] = {(destroy(std::get&lt;I&gt;(x)), 0)...};\n    }\n};\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-05-12T21:40:52.057", "Score": "10", "CreationDate": "2015-05-12T21:16:30.050", "ParentId": "30201414", "CommentCount": "8", "OwnerUserId": "3647361", "LastEditDate": "2015-05-12T21:40:52.057"}, "30316750": {"Id": "30316750", "PostTypeId": "2", "Body": "<p>Interestingly, hstong from IBM <a href=\"https://llvm.org/bugs/show_bug.cgi?id=23523\" rel=\"nofollow\">mentioned</a> a <a href=\"http://melpon.org/wandbox/permlink/a9zfr8dPCz9CFVrM\" rel=\"nofollow\">couple</a> <a href=\"http://melpon.org/wandbox/permlink/76Cf7oRFNEjLnr3L\" rel=\"nofollow\">workarounds</a> that work better. </p>\n<pre><code>int _[] = {(std::get&lt;I&gt;(x).::std::tuple_element&lt;I, args_type&gt;::type::~type(), true)...};\n</code></pre>\n<p>or </p>\n<pre><code>int _[] = {(std::get&lt;I&gt;(x).std::template tuple_element&lt;I, args_type&gt;::type::~type(), true)...};\n</code></pre>\n", "LastActivityDate": "2015-05-19T04:25:31.260", "CommentCount": "0", "CreationDate": "2015-05-19T04:25:31.260", "ParentId": "30201414", "Score": "0", "OwnerUserId": "1093147"}});