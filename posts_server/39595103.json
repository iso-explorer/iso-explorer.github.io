post_cb({"39595592": {"ParentId": "39595103", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-09-20T13:34:03.493", "Score": "1", "LastEditorUserId": "2079303", "LastEditDate": "2016-09-20T14:04:11.380", "Id": "39595592", "OwnerUserId": "2079303", "Body": "<p>The C++ standard delegates to C standard:</p>\n<blockquote>\n<p id=\"so_39595103_39595592_0\">The contents and meaning of the header <code>&lt;cstring&gt;</code> are the same as the C standard library header <code>&lt;string.h&gt;</code>.</p>\n</blockquote>\n<p>The C standard specifies:</p>\n<blockquote>\n<p id=\"so_39595103_39595592_1\">7.24.1/3 For all functions in this subclause, each character shall be interpreted as if it had the type unsigned char (and therefore every possible object representation is valid and has a different value).</p>\n</blockquote>\n<p>So, to answer your question: Yes, the behaviour is defined.</p>\n<p>Yes, <code>uint16_t*</code> is appropriate because <code>uint16_t</code> is the type of the object.</p>\n<hr>\n<p>No, the type of the source doesn't matter.</p>\n<p>C++ standard doesn't specify such thing as object without declared type or how it would behave. I interpret that to mean that the effective type is implementation defined for objects with no declared type.</p>\n<p>Even in C, the source doesn't matter in this case. A more complete version of quote from C standard (draft, N1570) that you are concerned about, emphasis mine:</p>\n<blockquote>\n<p id=\"so_39595103_39595592_2\">6.5/6 [...] If a value is copied <strong>into an object having no declared type</strong> using memcpy or memmove, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one. [...]</p>\n</blockquote>\n<p>This rule doesn't apply, because objects in <code>u16</code> do have a declared type</p>\n</hr>", "LastActivityDate": "2016-09-20T14:04:11.380"}, "39595307": {"ParentId": "39595103", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-09-20T13:20:57.023", "Score": "0", "LastEditorUserId": "2069064", "LastEditDate": "2016-09-20T13:47:57.903", "Id": "39595307", "OwnerUserId": "2069064", "Body": "<blockquote>\n<p id=\"so_39595103_39595307_0\">Is this defined behavio[u]r? </p>\n</blockquote>\n<p>Yes. <code>memcpy</code>ing into a pod is well-defined and you ensured that the sizing is the correct. </p>\n<blockquote>\n<p id=\"so_39595103_39595307_1\">Must we use <code>uint16_t*</code>, because that suitable for the declared type of <code>u16</code>?</p>\n</blockquote>\n<p>Yes, of course. <code>u16</code> is an array of two <code>uint16_t</code>s so it must be accessed as such. Accessing it via a <code>uint32_t*</code> would be undefined behavior by the strict-aliasing rule.</p>\n<p>It doesn't matter what the source type was. What matters is that you have an object of type <code>uint16_t[2]</code>. </p>\n<hr/>\n<p>On the other hand, <em>this</em>:</p>\n<pre><code>uint32_t p;\nnew (&amp;p) uint16_t(42);\nstd::cout &lt;&lt; p;\n</code></pre>\n<p>is undefined behavior, because now there is an object of a different type whose lifetime has begin at <code>&amp;p</code> and we're accessing it through the wrong type. </p>\n", "LastActivityDate": "2016-09-20T13:47:57.903"}, "bq_ids": {"n4140": {"so_39595103_39595592_0": {"section_id": 4275, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_39595103_39595592_0": {"section_id": 4116, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_39595103_39595592_0": {"section_id": 2158, "quality": 0.8888888888888888, "length": 8}}}, "39595103": {"CommentCount": "5", "ViewCount": "69", "PostTypeId": "1", "LastEditorUserId": "146041", "CreationDate": "2016-09-20T13:12:52.513", "LastActivityDate": "2016-09-20T14:04:11.380", "Title": "memcpy from one type to another type. How do we access the destination afterwards?", "AcceptedAnswerId": "39595592", "LastEditDate": "2016-09-20T13:16:41.653", "Id": "39595103", "Score": "1", "Body": "<pre><code>uint32_t u32 = 0;\nuint16_t u16[2];\nstatic_assert(sizeof(u32) == sizeof(u16), \"\");\nmemcpy(u16, &amp;u32, sizeof(u32)); // defined?\n// if defined, how to we access the data from here on?\n</code></pre>\n<p>Is this defined behaviour? And, if so, what type of pointer may we use to access the target data after the <code>memcpy</code>?</p>\n<p>Must we use <code>uint16_t*</code>, because that suitable for the <em>declared</em> type of <code>u16</code>?</p>\n<p>Or must we use <code>uint32_t*</code>, because the type of the source data (the source data copied from by <code>memcpy</code>) is <code>uint_32</code>?</p>\n<p>(Personally interested in C++11/C++14. But a discussion of related languages like C would be interesting also.)</p>\n", "Tags": "<c++11><strict-aliasing>", "OwnerUserId": "146041", "AnswerCount": "2"}});