post_cb({"bq_ids": {"n4140": {"so_13643649_13644612_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 380}, "so_13643649_13644612_1": {"length": 13, "quality": 1.0, "section_id": 3884}}, "n3337": {"so_13643649_13644612_1": {"length": 13, "quality": 1.0, "section_id": 3744}, "so_13643649_13644612_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 371}}, "n4659": {"so_13643649_13644612_1": {"length": 13, "quality": 1.0, "section_id": 4763}, "so_13643649_13644612_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 395}}}, "13644878": {"Id": "13644878", "PostTypeId": "2", "Body": "<p>This is what I found in \"The Design and Evolution of C++\" on page 145:</p>\n<pre><code>void h(String s1, String s2)\n{\n    const char* p;\n    if (p = s1+s2) {\n        // ...\n    }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_13643649_13644878_0\">Does the destruction of the object holding <code>s1+s2</code> take place at the end of the condition or at the end of the whole <code>if</code> statement? The answer is that the object holding <code>s1+s2</code> will be destroyed at the end of the condition.</p>\n</blockquote>\n", "LastActivityDate": "2012-11-30T12:02:47.613", "CommentCount": "0", "CreationDate": "2012-11-30T12:02:47.613", "ParentId": "13643649", "Score": "2", "OwnerUserId": "252000"}, "13645181": {"Id": "13645181", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13643649_13645181_0\">However Visual C++ destroys that temporary object as if it was named.</p>\n</blockquote>\n<p>No it doesn't...</p>\n<p>Given the code</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct S {\n    S() { std::cout &lt;&lt; \"S()\" &lt;&lt; std::endl; }\n    S(const S&amp;) { std::cout &lt;&lt; \"S(const S&amp;)\" &lt;&lt; std::endl; }\n    ~S() { std::cout &lt;&lt; \"~S()\" &lt;&lt; std::endl; }\n    operator bool() const { return true; }\n};\n\nint main() {\n    std::cout &lt;&lt; \"main 1\" &lt;&lt; std::endl;\n\n    if (S s = S()) {\n        std::cout &lt;&lt; \"if 1\" &lt;&lt; std::endl;\n    }\n    else {\n        std::cout &lt;&lt; \"else 1\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"main 2\" &lt;&lt; std::endl;\n\n    if (S()) {\n        std::cout &lt;&lt; \"if 2\" &lt;&lt; std::endl;\n    }\n    else {\n        std::cout &lt;&lt; \"else 2\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"main 3\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>GNU g++ 4.5.1 and g++ 4.7.0 and VC++ 2010 and VC++ 2012 have the exact same output:</p>\n<pre><code>main 1\nS()\nif 1\n~S()\nmain 2\nS()\n~S()\nif 2\nmain 3\n</code></pre>\n<p>where the named temporary is destroyed after the if/else and the unnamed temporary is destroyed at the end of the condition.</p>\n", "LastActivityDate": "2012-11-30T12:22:57.900", "CommentCount": "1", "CreationDate": "2012-11-30T12:22:57.900", "ParentId": "13643649", "Score": "8", "OwnerUserId": "145919"}, "13643649": {"ViewCount": "827", "Body": "<p>How Standard defines the life time of a temporary object constructed during evaluation of an <code>if</code> condition expression?</p>\n<p>I looked for this information and found something similar in an example to point [10] in $1.9, page 10. (I'm referring here to Final Draft of the new specification.) Yet still it wasn't clear (enough) for me and since Visual C++ acted differently than my understanding of that example I decided to ask.</p>\n<p>Please provide proper references to specification.</p>\n<hr>\n<p>If you name the object it persists for the entire <code>if</code> (so both <code>true</code> block and <code>false</code> block but is destroyed before <code>if</code> ends).</p>\n<p>For example:</p>\n<pre><code>if ( MyClass x = f() ) { /* ... */ } else { /* ... */ }\nnextInstruction();\n</code></pre>\n<p><code>x</code> can be used in both <code>if</code> blocks but gets destroyed before <code>nextInstruction</code> gets called.</p>\n<p>But what if you don't name it?</p>\n<pre><code>if ( f() ) { /* ... */ } else { /* ... */ }\nnextInstruction();\n</code></pre>\n<p>In my understanding of the referenced part of specification the value returned by <code>f()</code> will be destroyed before execution enters one of the blocks (either for <code>true</code> or for <code>false</code>).</p>\n<p>However Visual C++ destroys that temporary object as if it was named. <em>(<strong>EDIT:</strong> as Tino Didriksen pointed out Visual C++ does work well here. And indeed now I confirm that as well. I must have made a mistake when looking at initial tests results!)</em></p>\n<hr>\n<p>This does matter in some edge cases (lets not discuss here how likely they are or whether it is good to write code that way...).</p>\n<p>For example lets have:</p>\n<pre><code>class ScopedLock {\npublic:\n  ~ScopedLock() { if ( isLocked() ) unlock(); }\n\n  operator bool() const { return isLocked(); }\n\n  /* ... */\n\n};\n</code></pre>\n<p>Now if we have code like:</p>\n<pre><code>if ( ScopedLock lock = resource.lock() ) { /* ... */ }\n</code></pre>\n<p>we can be sure that when execution enters the <code>true</code> block we own the resource and that it will not be unlocked before we leave that block.</p>\n<p>But what if someone wrote it like this:</p>\n<pre><code>if ( resource.lock() ) { /* ... */ }\n</code></pre>\n<p>Now it is crucial at which point the destructor for the temporary <code>ScopedLock</code> will be called. Because it determines whether this code is correct or not (in the sens of resource usage). (Again lets skip discussing whether writing such code is bad in general. That is not the point of this question...)</p>\n</hr></hr>", "AcceptedAnswerId": "13644612", "Title": "Life time of an unnamed temporary constructed in if condition expression", "CreationDate": "2012-11-30T10:46:21.817", "Id": "13643649", "CommentCount": "1", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2012-11-30T13:55:33.227", "LastEditorUserId": "422489", "LastActivityDate": "2012-11-30T13:55:33.227", "Score": "25", "OwnerUserId": "422489", "Tags": "<c++>", "AnswerCount": "3"}, "13644612": {"Id": "13644612", "PostTypeId": "2", "Body": "<p>As far as I can tell, Visual C++ is wrong in this regard.</p>\n<p>Indeed, a temporary is (almost always) destroyed at the end of the full expression in which it is created:</p>\n<blockquote>\n<p id=\"so_13643649_13644612_0\">\u00a712.2/3: [...]Temporary objects are destroyed as the last step in evaluating the\n  full-expression that (lexically) contains the point where they\n  were created</p>\n</blockquote>\n<p>Looking at the definition of a selection statement (<code>if</code> and <code>switch</code>), we can see that the condition is an expression:</p>\n<pre><code>\u00a76.4:\nselection-statement:\n  if ( condition ) statement\n  if ( condition) statement else statement\n  switch ( condition ) statement\n\ncondition:\n  expression\n  type-specifier-seq declarator = assignment-expression\n</code></pre>\n<p>So any temporaries created in the condition should be destroyed before executing the following statement (unless bound to a reference-to-const).</p>\n<p>The behavior when introducing a new name in the condition is specified in \u00a76.4/3:</p>\n<blockquote>\n<p id=\"so_13643649_13644612_1\">A name introduced by a declaration in a condition [...] is in\n  scope from its point of declaration until the end of the substatements\n  controlled by the condition.</p>\n</blockquote>\n<p>So in your example, <code>x</code> is in scope in the two branches of the <code>if</code>, and destroyed before evaluating <code>nextInstruction()</code>.</p>\n", "LastActivityDate": "2012-11-30T11:43:31.823", "CommentCount": "0", "CreationDate": "2012-11-30T11:43:31.823", "ParentId": "13643649", "Score": "6", "OwnerUserId": "20984"}});