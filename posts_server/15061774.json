post_cb({"15061774": {"CommentCount": "1", "AcceptedAnswerId": "15061929", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-02-25T07:09:30.627", "LastActivityDate": "2013-02-26T15:07:27.470", "LastEditDate": "2017-05-23T12:10:17.723", "ViewCount": "1145", "FavoriteCount": "3", "Title": "Template class member specialization without declaration in header", "Id": "15061774", "Score": "11", "Body": "<p>I have a template class that I declare in a header with one method and no definition of that method in the header. In a .cc file, I define specializations of that method <em>without ever declaring them in the header</em>. In a different .cc file, I call the method for different template parameters for which specializations exist. It looks like this:</p>\n<p>foo.h:</p>\n<pre><code>template&lt;typename T&gt;\nclass Foo {\npublic:\n  static int bar();\n};\n</code></pre>\n<p>foo.cc:</p>\n<pre><code>#include \"foo.h\"\n\ntemplate&lt;&gt;\nint Foo&lt;int&gt;::bar() {\n  return 1;\n}\n\ntemplate&lt;&gt;\nint Foo&lt;double&gt;::bar() {\n  return 2;\n}\n</code></pre>\n<p>main.cc:</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"foo.h\"\n\nint main(int argc, char **argv) {\n  std::cout &lt;&lt; Foo&lt;int&gt;::bar() &lt;&lt; std::endl;\n  std::cout &lt;&lt; Foo&lt;double&gt;::bar() &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>This program compiles and links successfully with gcc 4.7.2 for all C++ standards (c++98, gnu++98, c++11, and gnu++11). The output is:</p>\n<pre><code>1\n2\n</code></pre>\n<p>This makes sense to me. Because the main.cc translation unit does not see a definition of <code>bar()</code> or any specializations of it, it expects the calls to <code>bar()</code> to use explicit instantiations of an unspecialized definition of <code>bar()</code> in some other translation unit. But since name mangling is predictable, the specializations in foo.cc have the same symbol names as explicit instantiations of an unspecialized definition would, so main.cc is able to use those specializations without them ever being declared in that translation unit.</p>\n<p>My question is this: is this an accident, or is this behaviour mandated by the C++ standard? In other words, is this code portable?</p>\n<p>The most relevant prior question that I could find is <a href=\"https://stackoverflow.com/questions/2498435/declaration-of-template-class-member-specialization\">Declaration of template class member specialization</a>, but it doesn't cover this particular case.</p>\n<p>(In case you're wondering why this matters to me, it's because I'm using code like this as a sort of compile-time look-up table and it's a lot shorter if I don't declare the specializations.)</p>\n", "Tags": "<c++><templates><declaration><template-specialization>", "OwnerUserId": "2106037", "AnswerCount": "1"}, "15061929": {"ParentId": "15061774", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The Standard (C++11) requires that explicit specializations be declared (but not necessarily defined) before they are first used:</p>\n<blockquote>\n<p id=\"so_15061774_15061929_0\">(14.7.3/6) If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. If the program does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, the\n  program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit specialization that is declared but not defined. [...]</p>\n</blockquote>\n<p>I believe that this will in practice only have an effect when your primary template definition includes the definition of the non-specialized version of one of the member functions. Because in that case, when the explicit specialization isn't declared, the existing primary definition may be used to compile the function inline into the code, and the specialization would end up not being used at link-time.</p>\n<p>In other words, if there is no definition of the member function included in the primary template definition, your linker trick can probably be expected to work in practice, but it wouldn't conform with what the Standard says, and it can get you into real trouble as soon as you add an inline function definition to the primary template.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-02-26T15:07:27.470", "Id": "15061929", "Score": "8", "CreationDate": "2013-02-25T07:21:29.857", "LastActivityDate": "2013-02-26T15:07:27.470"}, "bq_ids": {"n4140": {"so_15061774_15061929_0": {"section_id": 268, "quality": 0.9833333333333333, "length": 59}}, "n3337": {"so_15061774_15061929_0": {"section_id": 259, "quality": 0.9833333333333333, "length": 59}}, "n4659": {"so_15061774_15061929_0": {"section_id": 275, "quality": 0.9833333333333333, "length": 59}}}});