post_cb({"46034235": {"ParentId": "46029612", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As per <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">C++ language open standard draft n3690.pdf</a> \nregarding vector capacity. Please see the bold italicized statement.</p>\n<blockquote>\n<p id=\"so_46029612_46034235_0\">23.3.7.3 vector capacity [vector.capacity]\n  size_type capacity() const noexcept;\n  1 Returns: The total number of elements that the vector can hold without requiring reallocation.\n  void reserve(size_type n);\n  2 Requires: T shall be MoveInsertable into *this.\n  3 Effects: A directive that informs a vector of a planned change in size, so that it can manage the storage\n  allocation accordingly. After reserve(), capacity() is greater or equal to the argument of reserve if\n  reallocation happens; and equal to the previous value of capacity() otherwise. \"<strong><em>Reallocation happens\n  at this point if and only if the current capacity is less than the argument of reserve()</em></strong>\". If an exception\n  is thrown other than by the move constructor of a non-CopyInsertable type, there are no effects</p>\n</blockquote>\n<p>Also from Scott Meyers \"<strong>Effective C++ Digital Collection: 140 Ways to Improve Your Programming</strong>\", under item 14\nItem 14. </p>\n<blockquote>\n<p id=\"so_46029612_46034235_1\">Use reserve to avoid unnecessary reallocations.\n  One of the most marvelous things about STL containers is that they automatically grow to accommodate as much data as you put into them, provided only that you don't exceed their maximum size. (To discover this maximum, just call the aptly named max_size member function.) For vector and string, growth is handled by doing the moral equivalent of a realloc whenever more space is needed. This realloc-like operation has four parts:\n  1. Allocate a new block of memory that is some multiple of the container's current capacity. \n  <strong>In most implementations, vector and string capacities grow by a factor of between 1.5 and 2 each time</strong>. </p>\n</blockquote>\n<p>As suggested by \"<strong>songyuanyao</strong>\" one should reserve the size(if it is known in advance) to avoid frequent reallocation.</p>\n", "OwnerUserId": "6127904", "LastEditorUserId": "6099429", "LastEditDate": "2017-09-04T11:07:04.690", "Id": "46034235", "Score": "0", "CreationDate": "2017-09-04T09:35:55.623", "LastActivityDate": "2017-09-04T11:07:04.690"}, "46029647": {"ParentId": "46029612", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>When the <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow noreferrer\">push_back</a> is called at the 2nd time, reallocation happened. (More precisely it happens when the new <code>size()</code> is greater than <code>capacity()</code>.) Then the old underlying storage of the <code>vector</code> will be destroyed and the new one will be allocated, and elements need to be copied to the new storage, which cause the copy constructor to be called.</p>\n<p>You can use <a href=\"http://en.cppreference.com/w/cpp/container/vector/reserve\" rel=\"nofollow noreferrer\">reserve</a> to avoid reallocation. e.g.</p>\n<pre><code>vector&lt;Quote&gt; basket;\nbasket.reserve(2);\nbasket.push_back(Quote(\"0-201-82470-1\", 50));\nbasket.push_back(Quote(\"0-201-82XXXXX\", 30)); // no reallocation here\n</code></pre>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2017-09-04T02:52:26.307", "Id": "46029647", "Score": "2", "CreationDate": "2017-09-04T02:46:28.200", "LastActivityDate": "2017-09-04T02:52:26.307"}, "bq_ids": {"n4140": {"so_46029612_46034235_0": {"section_id": 969, "quality": 0.6470588235294118, "length": 44}}, "n3337": {"so_46029612_46034235_0": {"section_id": 958, "quality": 0.6470588235294118, "length": 44}}, "n4659": {"so_46029612_46034235_0": {"section_id": 1031, "quality": 0.6470588235294118, "length": 44}}}, "46029612": {"CommentCount": "7", "ViewCount": "54", "CreationDate": "2017-09-04T02:40:14.603", "LastActivityDate": "2017-09-04T11:07:04.690", "Title": "Why vector hold a class type will call the copy constructor one more time when push_back()?", "AcceptedAnswerId": "46029647", "PostTypeId": "1", "Id": "46029612", "Score": "2", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cin; using std::cout; using std::endl;\n#include &lt;vector&gt;\nusing std::vector;\n\nclass Quote {\npublic:\n    Quote() = default;\n    Quote(const std::string &amp;book, double sales_price):\n                     bookNo(book), price(sales_price) {  }\n    // Quote(const Quote&amp;) = default;  // memberwise copy\n    Quote(const Quote &amp;orig): bookNo(orig.bookNo), price(orig.price) {\n        cout &lt;&lt; orig.isbn() &lt;&lt; endl;\n        cout &lt;&lt; \"called Quote(const Quote &amp;)\" &lt;&lt; endl;\n    }\n    Quote&amp; operator=(const Quote&amp;) = default;   // copy assign\n\n    std::string isbn() const { return bookNo; }\n    virtual double net_price(std::size_t n) const\n                { cout &lt;&lt; \"Quote::net_price\\n\"; return n * price; }\n    virtual void debug() const { cout &lt;&lt; bookNo &lt;&lt; ' ' &lt;&lt; price &lt;&lt; endl; }\n    virtual ~Quote() = default;\nprivate:\n    std::string bookNo; // ISBN number of this item\nprotected:\n    double price = 0.0; // normal, undiscouted price\n};\n\nint main(int argc, char *argv[]) {\n    vector&lt;Quote&gt; basket;\n    basket.push_back(Quote(\"0-201-82470-1\", 50));\n    basket.push_back(Quote(\"0-201-82XXXXX\", 30));\n    cout &lt;&lt; \"\\ntraverse bakset\" &lt;&lt; endl;\n    for (const auto &amp;v : basket)\n        v.debug();\n}\n</code></pre>\n<p>After I compile the above code and run, the result is:</p>\n<pre><code>0-201-82470-1\ncalled Quote(const Quote &amp;)\n0-201-82XXXXX\ncalled Quote(const Quote &amp;)\n0-201-82470-1\ncalled Quote(const Quote &amp;)\n\ntraverse bakset\n0-201-82470-1 50\n0-201-82XXXXX 30\n</code></pre>\n<p>According to when copy constructor is called, it will <em>be called twice</em> because I just have pushed two elements when I <code>push_back()</code> to a vector. But why it is <em>called three times</em> displayed in the above result.<br>\nHowever, according to the for-loop in <code>main</code>, the element of the vector is right.    </br></p>\n<p>Why the copy constructor is called one more time when pushed to a vector? And is there anything wrong with my defined copy constructor?</p>\n", "Tags": "<c++><vector><copy-constructor><push-back>", "OwnerUserId": "6099429", "AnswerCount": "2"}});