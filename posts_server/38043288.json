post_cb({"38072268": {"ParentId": "38043288", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is not an answer, rather <strong>a note</strong> on the different behavior of <em>g++</em> and <em>clang</em> in this case, depending on the <code>-O</code> optimization flag.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\nstruct S {\n    int i;\n    S(int _i): i(_i) { \n        int* p = print(\"from ctor\");\n        printf(\"about to put 5 in %p\\n\", (void *)&amp;i);        \n        *p = 5;\n    }\n    int* print(const char* s) { \n        printf(\"%s: %p %d %p\\n\", s, (void *) this, i, (void *)&amp;i);\n        return &amp;i;\n    }\n};\nS f() { return {3}; }\nint main() { \n    f().print(\"from main\");\n}\n</code></pre>\n<p>We can see that clang (3.8) and g++ (6.1) are taking it a bit differently, but both get to the right answer.</p>\n<h2>clang (for no -O, -O1, -O2) and g++ (for no -O, -O1)</h2>\n<pre><code>from ctor: 0x7fff9d5e86b8 3 0x7fff9d5e86b8\nabout to put 5 in 0x7fff9d5e86b8\nfrom main: 0x7fff9d5e86b0 5 0x7fff9d5e86b0\n</code></pre>\n<h2>g++ (for -O2)</h2>\n<pre><code>from ctor: 0x7fff52a36010 3 0x7fff52a36010\nabout to put 5 in 0x7fff52a36010\nfrom main: 0x7fff52a36010 5 0x7fff52a36010\n</code></pre>\n<p>It seems that they both do it right in both cases - when they decide to skip the register optimization (g++ -O2) and when they go with the register optimization but copy the value to the actual i on time (all other cases).</p>\n", "OwnerUserId": "2085626", "LastEditorUserId": "2085626", "LastEditDate": "2016-06-28T10:18:56.447", "Id": "38072268", "Score": "1", "CreationDate": "2016-06-28T09:27:00.620", "LastActivityDate": "2016-06-28T10:18:56.447"}, "38084759": {"ParentId": "38043288", "CommentCount": "1", "Body": "<p>T.C. pointed out in the comments that this is a defect in the standard. It's <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1590\" rel=\"nofollow\">core language issue 1590</a>. It's a subtly different issue than my example, but the same root cause:</p>\n<blockquote>\n<p id=\"so_38043288_38084759_0\">Some ABIs require that an object of certain class types be passed in a register [...]. The Standard should be changed to permit this usage.</p>\n</blockquote>\n<p>The <a href=\"https://rawgit.com/zygoloid/wg21papers/master/wip/d0135r1.html\" rel=\"nofollow\">current suggested wording</a> would cover this by adding a new rule to the standard:</p>\n<blockquote>\n<p id=\"so_38043288_38084759_1\">When an object of class type <code>X</code> is passed to or returned from a function, if each copy constructor, move constructor, and destructor of <code>X</code> is either trivial or deleted, and <code>X</code> has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object. [...]</p>\n</blockquote>\n<p>For the most part, this would permit the current GCC/clang behaviour.</p>\n<p>There is a small corner case: currently, when a type has only a deleted copy or move constructor that would be trivial if defaulted, by the current rules of the standard, that constructor is still trivial if deleted:</p>\n<blockquote>\n<p id=\"so_38043288_38084759_2\"><strong>12.8 Copying and moving class objects [class.copy]</strong></p>\n<p id=\"so_38043288_38084759_3\">12 A copy/move constructor for class <code>X</code> is trivial if it is not user-provided [...]</p>\n</blockquote>\n<p>A deleted copy constructor is not user-provided, and nothing of what follows would render such a copy constructor non-trivial. So as specified by the standard, such a constructor is trivial, and <a href=\"https://mentorembedded.github.io/cxx-abi/abi.html#return-value\" rel=\"nofollow\">as specified by my platform's ABI</a>, because of the trivial constructor, GCC and clang create an extra copy in that case too. A one-line addition to my test program demonstrates this:</p>\n<pre><code>#include &lt;stdio.h&gt;\nstruct S {\n  S() { print(); }\n  S(const S &amp;) = delete;\n  void print() { printf(\"%p\\n\", (void *) this); }\n};\nS f() { return {}; }\nint main() { f().print(); }\n</code></pre>\n<p>This prints two different addresses with both GCC and clang, even though even the proposed resolution would require the same address to be printed twice. This appears to suggest that while we will get an update to the standard to not require a radically incompatible ABI, we will still need to get an update to the ABI to handle the corner case in a manner compatible with what the standard will require.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "38084759", "Score": "5", "CreationDate": "2016-06-28T19:29:49.540", "LastActivityDate": "2016-06-28T19:29:49.540"}, "38043288": {"CommentCount": "12", "AcceptedAnswerId": "38084759", "PostTypeId": "1", "LastEditorUserId": "743382", "CreationDate": "2016-06-26T21:19:44.157", "LastActivityDate": "2016-06-28T19:29:49.540", "LastEditDate": "2016-06-26T22:11:31.370", "ViewCount": "398", "FavoriteCount": "8", "Title": "Does the C++ standard guarantee that a function return value has a constant address?", "Id": "38043288", "Score": "16", "Body": "<p>Consider this program:</p>\n<pre><code>#include &lt;stdio.h&gt;\nstruct S {\n  S() { print(); }\n  void print() { printf(\"%p\\n\", (void *) this); }\n};\nS f() { return {}; }\nint main() { f().print(); }\n</code></pre>\n<p>As far as I can tell, there is exactly one <code>S</code> object constructed here. There is no copy elision taking place: there is no copy to be elided in the first place, and indeed, if I explicitly delete the copy and/or move constructor, compilers continue to accept the program.</p>\n<p>However, I see two different pointer values printed. This happens because my platform's ABI returns trivially copyable types such as this one in CPU registers, so there is no way with that ABI of avoiding a copy. clang preserves this behaviour even when optimising away the function call altogether. If I give <code>S</code> a non-trivial copy constructor, even if it's inaccessible, then I do see the same value printed twice.</p>\n<p>The initial call to <code>print()</code> happens during construction, which is before the start of the object's lifetime, but using <code>this</code> inside a constructor is normally valid so long as it isn't used in a way that requires the construction to have finished -- no casting to a derived class, for instance -- and as far as I know, printing or storing its value doesn't require the construction to have finished.</p>\n<p>Does the standard allow this program to print two different pointer values?</p>\n<p><sub>Note: I'm aware that the standard allows this program to print two different representations of the same pointer value, and technically, I haven't ruled that out. I could create a different program that avoids comparing pointer representations, but it would be more difficult to understand, so I would like to avoid that if possible.</sub></p>\n", "Tags": "<c++><c++11><return-value><language-lawyer><abi>", "OwnerUserId": "743382", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_38043288_38084759_3": {"section_id": 461, "quality": 1.0, "length": 5}}, "n3337": {"so_38043288_38084759_3": {"section_id": 452, "quality": 1.0, "length": 5}}, "n4659": {"so_38043288_38084759_1": {"section_id": 394, "quality": 1.0, "length": 32}, "so_38043288_38084759_3": {"section_id": 484, "quality": 1.0, "length": 5}}}});