post_cb({"13897441": {"ParentId": "13897394", "CommentCount": "1", "Body": "<p>No - you can't have a virtual operator delete - class-specific <code>new</code> and <code>delete</code> overloads must be static member functions - specific to the class, not to the object.</p>\n<p>You can't have virtual static member functions.</p>\n<p>See section 12.5.7 of the standard, which states \"Since member allocation and deallocation functions are static they cannot be virtual.\"</p>\n", "OwnerUserId": "992490", "PostTypeId": "2", "Id": "13897441", "Score": "4", "CreationDate": "2012-12-16T00:21:25.943", "LastActivityDate": "2012-12-16T00:21:25.943"}, "13897420": {"ParentId": "13897394", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>1) Yes, of course you can overload delete.  No, the overload cannot be a virtual function.</p>\n<p>2) \"Pros and Cons\" depend on entirely what you're trying to do.</p>\n<p>3) Of course, the whole idea of operator overloading - like so much in C++ - is arguably stupid, unnecessary and dangerous.</p>\n<p>SOOOOOO .....</p>\n<p>4) If you don't NEED it, then don't DO IT :)</p>\n<p>IMHO...</p>\n", "OwnerUserId": "421195", "LastEditorUserId": "421195", "LastEditDate": "2012-12-16T01:17:29.923", "Id": "13897420", "Score": "-3", "CreationDate": "2012-12-16T00:17:09.417", "LastActivityDate": "2012-12-16T01:17:29.923"}, "13897394": {"CommentCount": "4", "AcceptedAnswerId": "13897423", "CreationDate": "2012-12-16T00:10:54.397", "LastActivityDate": "2014-11-26T13:42:41.273", "PostTypeId": "1", "ViewCount": "3044", "FavoriteCount": "4", "Title": "C++ Virtual operator delete?", "Id": "13897394", "Score": "13", "Body": "<p>Is it possible to have a virtual delete operator?  I'm not talking destructor, I mean the actual operator overload.</p>\n<p>Minus the fact that it is (in most cases) a big bad idea to overload new and delete (Yes, I already know it's heresy), I want to know what kind of implications come from using a virtual delete operator.</p>\n<p>I'm thinking about trying to use a virtual delete, as sometimes I might have a child class that overloads delete, stored in a base class pointer.  Technically, I don't really ever see this case coming to too much fruition, unless I have a tree of different node types (potentially dangerous idea in the first place if you ask me).</p>\n<p>I just want to know what would be the potential pros and cons of a virtual, or non virtual, delete operator override.</p>\n", "Tags": "<c++><inheritance><operator-overloading><virtual><delete-operator>", "OwnerUserId": "1079635", "AnswerCount": "4"}, "13897421": {"ParentId": "13897394", "CommentCount": "0", "Body": "<p>No -- even if you don't mark it as such, when/if you overload <code>new</code>/<code>delete</code> for a class, they end up as static member functions<sup>1</sup>, and static member functions can't be virtual.</p>\n<p>To work, they really need to be static -- they're used to allocate/free the memory for an object, so have to happen before the object starts construction/after it finishes destruction. You clearly can't have it allocate the memory for what will eventually become an instance of a class, and at the same time have it depend on that already <em>being</em> an instance of the class (which a virtual function does).</p>\n<hr>\n<ol>\n<li>\u00a712.5/1: </li>\n</ol>\n<blockquote>\n<p id=\"so_13897394_13897421_0\">Any allocation function for a class T is a static member (even if not explicitly declared static).</p>\n</blockquote>\n<p>and \u00a712.5/6:</p>\n<blockquote>\n<p id=\"so_13897394_13897421_1\">Any deallocation function for a class X is a static member (even if not explicitly declared static).</p>\n</blockquote>\n<p>...for anybody who cares about the official statements. Interesting how it's a \"class T\" when you're allocating, and a \"class X\" when you're freeing.</p>\n</hr>", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "13897421", "Score": "7", "CreationDate": "2012-12-16T00:17:21.103", "LastActivityDate": "2012-12-16T00:17:21.103"}, "13897423": {"ParentId": "13897394", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You can\u2019t explicitly declare <code>operator delete</code> as <code>virtual</code>.</p>\n<p>It is a static member function, even if you do not supply the keyword <code>static</code>.</p>\n<p>But <code>operator delete</code> <strong><em>is already virtual</em></strong> in the sense that the one defined in the most derived class is used. You might choose to think of it as if it's called by the destructor. It might even be. ;-)</p>\n<hr>\n<blockquote>\n<p id=\"so_13897394_13897423_0\"><strong>C++11 \u00a712.4/12</strong>:<br>\n  \u201cAt the point of definition of a virtual destructor (including an implicit definition (12.8)), the non-array\n  deallocation function is looked up in the scope of the destructor\u2019s class (10.2), and, if no declaration is\n  found, the function is looked up in the global scope.\u201d</br></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_13897394_13897423_1\"><strong>C++11 \u00a712.5/4</strong>:<br>\n  \u201cIf a <em>delete-expression</em> begins with a unary <code>::</code> operator, the deallocation function\u2019s name is looked up in\n  global scope. Otherwise, if the <em>delete-expression</em> is used to deallocate a class object whose static type has\n  a virtual destructor, the deallocation function is the one selected at the point of definition of the dynamic\n  type\u2019s virtual destructor (12.4).<sup>117</sup> Otherwise, if the <em>delete-expression</em> is used to deallocate an object of\n  class <code>T</code> or array thereof, the static and dynamic types of the object shall be identical and the deallocation\n  function\u2019s name is looked up in the scope of <code>T</code>. If this lookup fails to find the name, the name is looked up in\n  the global scope. If the result of the lookup is ambiguous or inaccessible, or if the lookup selects a placement\n  deallocation function, the program is ill-formed.\u201d</br></p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2012-12-16T00:34:47.423", "Id": "13897423", "Score": "14", "CreationDate": "2012-12-16T00:17:32.580", "LastActivityDate": "2012-12-16T00:34:47.423"}, "bq_ids": {"n4140": {"so_13897394_13897423_1": {"section_id": 416, "quality": 0.75, "length": 51}, "so_13897394_13897423_0": {"section_id": 408, "quality": 0.8333333333333334, "length": 20}, "so_13897394_13897421_0": {"section_id": 413, "quality": 0.9, "length": 9}, "so_13897394_13897421_1": {"section_id": 417, "quality": 0.9, "length": 9}}, "n3337": {"so_13897394_13897423_1": {"section_id": 407, "quality": 0.9558823529411765, "length": 65}, "so_13897394_13897421_1": {"section_id": 409, "quality": 0.9, "length": 9}, "so_13897394_13897421_0": {"section_id": 404, "quality": 0.9, "length": 9}, "so_13897394_13897423_0": {"section_id": 399, "quality": 0.8333333333333334, "length": 20}}, "n4659": {"so_13897394_13897423_1": {"section_id": 434, "quality": 0.75, "length": 51}, "so_13897394_13897421_1": {"section_id": 435, "quality": 0.9, "length": 9}, "so_13897394_13897421_0": {"section_id": 431, "quality": 0.9, "length": 9}, "so_13897394_13897423_0": {"section_id": 426, "quality": 0.5416666666666666, "length": 13}}}});