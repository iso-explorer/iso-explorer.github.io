post_cb({"9754233": {"ParentId": "9754084", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-03-17T22:12:54.527", "Score": "1", "LastEditorUserId": "245265", "LastEditDate": "2012-03-17T22:42:14.747", "Id": "9754233", "OwnerUserId": "245265", "Body": "<p>I don't know the standardese behind your error (refer to Xeo's answer), but I did find a workaround for C++03.\nInstead of making <code>T</code> a friend, make one of <code>T</code>'s member functions a friend:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class A {\n  private:\n    int n1;\n  public:\n    friend int T::getN1(const A&amp; a) const;\n    A(const int n0 = 0) : n1(n0) {}\n};\n\nclass B {\n  public:\n    int f(const A&lt;B&gt; a) const { return getN1(a); }\n    B() {}\n  private:\n    int getN1(const A&lt;B&gt;&amp; a) const {return a.n1;}\n};\n\nclass C {\n  public:\n    int f(const A&lt;B&gt; a) const { return getN1(a); }\n    C() {}\n  private:\n    // Error, n1 is a private member of A&lt;B&gt;\n    int getN1(const A&lt;B&gt;&amp; a) const {return a.n1;}\n};\n\nint main() {\n    const A&lt;B&gt; a(5);\n    const B b;\n    const int m = b.f(a);\n    std::cout &lt;&lt; m &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<hr>\n<p>Alternatively, you can make a nested class/struct of T be a friend of A. This may be more convenient if there are several private members of A that you want T to have access to.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class A {\n  private:\n    int n1;\n  public:\n    friend class T::AccessToA;\n    A(const int n0 = 0) : n1(n0) {}\n};\n\nclass B {\n  public:\n    int f(const A&lt;B&gt; a) const { return AccessToA::getN1(a); }\n    B() {};\n  private:\n    friend class A&lt;B&gt;;\n    struct AccessToA\n    {\n        static int getN1(const A&lt;B&gt;&amp; a) {return a.n1;}\n    };\n};\n\nclass C {\n  public:\n    int f(const A&lt;B&gt; a) const { return AccessToA::getN1(a); }\n    C() {};\n\n  private:\n    friend class A&lt;C&gt;;\n    struct AccessToA\n    {\n        // Error, n1 is a private member of A&lt;B&gt;\n        static int getN1(const A&lt;B&gt;&amp; a) {return a.n1;}\n    };\n};\n\nint main() {\n    const A&lt;B&gt; a(5);\n    const B b;\n    const int m = b.f(a);\n    std::cout &lt;&lt; m &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n</hr>", "LastActivityDate": "2012-03-17T22:42:14.747"}, "9754084": {"CommentCount": "0", "AcceptedAnswerId": "9754233", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-03-17T21:52:11.560", "LastActivityDate": "2012-03-18T05:42:18.367", "LastEditDate": "2017-05-23T12:20:14.883", "ViewCount": "192", "FavoriteCount": "1", "Title": "How to hide a datum from everyone but class T", "Id": "9754084", "Score": "5", "Body": "<p>I want a type <em>A</em> that will yield its hidden datum to an object of type <em>T</em> but hide the datum from everyone else.  My C++ compiler happens to be GCC 4.4, but that shouldn't matter.  Why won't this work?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class A {\n  private:\n    int n1;\n  public:\n    friend class T;\n    A(const int n0 = 0) : n1(n0) {}\n};\n\nclass B {\n  public:\n    int f(const A&lt;B&gt; a) const { return a.n1; }\n    B() {}\n};\n\nint main() {\n    const A&lt;B&gt; a(5);\n    const B b;\n    const int m = b.f(a);\n    std::cout &lt;&lt; m &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>Incidentally, this works fine, except that it fails to hide the datum:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class A {\n  private:\n    int n1;\n  public:\n    int n() const { return n1; }\n    A(const int n0 = 0) : n1(n0) {}\n};\n\nclass B {\n  public:\n    int f(const A&lt;B&gt; a) const { return a.n(); }\n    B() {}\n};\n\nint main() {\n    const A&lt;B&gt; a(5);\n    const B b;\n    const int m = b.f(a);\n    std::cout &lt;&lt; m &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>Does C++ really not allow a friend class to be specified at compile time as a template parameter?  Why not?  If not, then what alternate technique should I use to hide the datum?  (One would prefer a compile-time technique if possible.)</p>\n<p>What is my misunderstanding here, please?</p>\n<p>(I see some answers to related questions <a href=\"https://stackoverflow.com/questions/922545/how-to-allow-template-function-to-have-friend-like-access\">here</a> and <a href=\"https://stackoverflow.com/questions/1993482/compiler-error-in-declaring-template-friend-class-within-a-template-class\">here,</a> but either they don't answer my particular question or I fail to understand that they do so.  At any rate, maybe I am using the wrong technique altogether.  Though I remain interested in why the <em>friend class T</em> fails, what I really want to know is how to hide the datum, whether with a friend or by other means.)</p>\n<p>Thanks.</p>\n", "Tags": "<c++><templates><friend><information-hiding><access-protection>", "OwnerUserId": "1275653", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_9754084_9754329_1": {"section_id": 6686, "quality": 1.0, "length": 16}, "so_9754084_9754329_0": {"section_id": 6686, "quality": 1.0, "length": 9}}, "n3337": {"so_9754084_9754329_1": {"section_id": 6441, "quality": 1.0, "length": 16}, "so_9754084_9754329_0": {"section_id": 6441, "quality": 1.0, "length": 9}}, "n4659": {"so_9754084_9754329_1": {"section_id": 8161, "quality": 1.0, "length": 16}, "so_9754084_9754329_0": {"section_id": 8161, "quality": 1.0, "length": 9}}}, "9754329": {"ParentId": "9754084", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-03-17T22:28:46.993", "Score": "4", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:29.003", "Id": "9754329", "OwnerUserId": "500104", "Body": "<p>Your compiler is simply too old. C++11 allows you to declare template parameters as friends.</p>\n<p><code>\u00a711.3 [class.friend] p3</code></p>\n<blockquote>\n<p id=\"so_9754084_9754329_0\">A friend declaration that does not declare a function shall have one of the following forms:</p>\n<ul>\n<li><code>friend</code> <em><code>elaborated-type-specifier</code></em> <code>;</code></li>\n<li><code>friend</code> <em><code>simple-type-specifier</code></em> <code>;</code></li>\n<li><code>friend</code> <em><code>typename-specifier</code></em> <code>;</code></li>\n</ul>\n<p id=\"so_9754084_9754329_1\">If the type specifier in a <code>friend</code> declaration designates a (possibly cv-qualified) class type, that class is declared as a <code>friend</code>; otherwise, the friend declaration is ignored.</p>\n</blockquote>\n<p>And it even contains an example of a template parameter as a friend:</p>\n<pre><code>class C;\n// [...]\ntemplate &lt;typename T&gt; class R {\n  friend T;\n};\n\nR&lt;C&gt; rc;   // class C is a friend of R&lt;C&gt;\nR&lt;int&gt; ri; // OK: \"friend int;\" is ignored\n</code></pre>\n<p>C++03 sadly has no way to do this, however you can simply friend a single free function and let that act as \"glue\" code that takes the data from one class and passes it to the other. Another way might be the <a href=\"https://stackoverflow.com/q/3324898/500104\">passkey pattern</a>.</p>\n", "LastActivityDate": "2012-03-17T22:28:46.993"}});