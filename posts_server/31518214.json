post_cb({"31518798": {"ParentId": "31518214", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I guess the reason is that the member function is not really part of the derived class, but rather of the base class. This can be shown somehow empirically by inspecting the type of the member function pointer and comparing it with a pointer to the base member function:</p>\n<pre><code>cout &lt;&lt; typeid(&amp;Derived::doStuff).name() &lt;&lt; endl\n  &lt;&lt; typeid(&amp; Base::doStuff).name() &lt;&lt; endl;\n</code></pre>\n<p><a href=\"http://ideone.com/drOodA\" rel=\"nofollow\">Live here.</a></p>\n<p><s>I'm currently searching the standard for some background on this.</s>\nBarry's answer holds the respective parts of the standard.</p>\n", "OwnerUserId": "1116364", "LastEditorUserId": "1116364", "LastEditDate": "2015-07-20T14:26:58.613", "Id": "31518798", "Score": "3", "CreationDate": "2015-07-20T14:13:02.473", "LastActivityDate": "2015-07-20T14:26:58.613"}, "31518214": {"CommentCount": "9", "AcceptedAnswerId": "31518760", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-07-20T13:47:57.777", "LastActivityDate": "2015-07-20T14:28:10.067", "LastEditDate": "2015-07-20T14:28:10.067", "ViewCount": "473", "FavoriteCount": "5", "Title": "Public access declaration does not affect member function pointers?", "Id": "31518214", "Score": "17", "Body": "<p>I have an issue regarding access declarations under g++ (version 5.1).</p>\n<pre><code>class Base\n{\npublic:\n    void doStuff() {}\n};\n\nclass Derived : private Base\n{\npublic:\n    // Using older access declaration (without using) shoots a warning\n    // and results in the same compilation error\n    using Base::doStuff;\n};\n\ntemplate&lt;class C, typename Func&gt;\nvoid exec(C *c, Func func)\n{\n    (c-&gt;*func)();\n}\n\nint main()\n{\n    Derived d;\n    // Until here, everything compiles fine\n    d.doStuff();\n    // For some reason, I can't access the function pointer\n    exec(&amp;d,&amp;Derived::doStuff);\n}\n</code></pre>\n<p>g++ fails to compile the above code with:</p>\n<blockquote>\n<p id=\"so_31518214_31518214_0\">test.cpp: In instantiation of \u2018void exec(C*, Func) [with C = Derived; Func = void (Base::*)()]\u2019:\n  test.cpp:24:27:   required from here<br>\n  test.cpp:17:4: error: \u2018Base\u2019 is an inaccessible base of \u2018Derived\u2019\n    (c-&gt;*func)();</br></p>\n</blockquote>\n<p>Even when the function itself can be called (<code>d.doStuff();</code>) the pointer can't be used even though I declared the function as accessible from the outside.\nPrivate inheritance is also important, to some extent, because the <code>Derived</code> class chooses to expose only a certain set of members from base(s) which are interface implementations IRL.</p>\n<p>NB : this is a question about the language, not class design.</p>\n", "Tags": "<c++><inheritance><language-lawyer>", "OwnerUserId": "1394947", "AnswerCount": "4"}, "31519018": {"ParentId": "31518214", "CommentCount": "1", "Body": "<p>From the C++11 Standard, \u00a77.3.3 [namespace.udecl], 18:</p>\n<pre><code>class A\n{\nprivate:\n    void f( char );\npublic:\n    void f( int );\nprotected:\n    void g();\n};\nclass B : public A\n{\n    using A::f; // error: A::f(char) is inaccessible\npublic:\n    using A::g;\n    // B::g is a public synonym for A::g\n};\n</code></pre>\n<p>Note the <strong>B::g is a public synonym for A::g</strong> part. When you take the address of <code>Derived::doStuff</code>, GCC is creating a pointer to member function of type <code>void(Base::*)()</code>, and the standard says it's doing well. So, I think the compile time error is fair.</p>\n", "OwnerUserId": "2508150", "PostTypeId": "2", "Id": "31519018", "Score": "1", "CreationDate": "2015-07-20T14:23:52.723", "LastActivityDate": "2015-07-20T14:23:52.723"}, "31518990": {"ParentId": "31518214", "CommentCount": "0", "Body": "<p>According to the stardard [namespace.udecl]:</p>\n<blockquote>\n<p id=\"so_31518214_31518990_0\">A using-declaration introduces a name into the declarative region in which the using-declaration appears.</p>\n<p id=\"so_31518214_31518990_1\">If a using-declaration names a constructor (3.4.3.1), it implicitly\n  declares a set of constructors in the class in which the\n  using-declaration appears (12.9); otherwise the name specified in a\n  using-declaration is a synonym for a set of declarations in another\n  namespace or class.</p>\n</blockquote>\n<p>So you're just introducing <code>Base::doStuff</code> into the <code>Derived</code> region, it's still a member function of <code>Base</code>.</p>\n<p>Then <code>exec</code> is instantiated as <code>exec&lt;Derived, void (Base::*)()&gt;</code>, but it can't cast a <code>Derived*</code> to <code>Base*</code> because of the private inheritance.</p>\n", "OwnerUserId": "3309790", "PostTypeId": "2", "Id": "31518990", "Score": "1", "CreationDate": "2015-07-20T14:22:26.957", "LastActivityDate": "2015-07-20T14:22:26.957"}, "bq_ids": {"n4140": {"so_31518214_31518760_0": {"section_id": 6066, "quality": 0.8928571428571429, "length": 25}, "so_31518214_31518760_1": {"section_id": 5505, "quality": 0.9444444444444444, "length": 17}, "so_31518214_31518760_2": {"section_id": 43, "quality": 0.9428571428571428, "length": 33}, "so_31518214_31518990_0": {"section_id": 5490, "quality": 1.0, "length": 8}, "so_31518214_31518990_1": {"section_id": 5490, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_31518214_31518990_0": {"section_id": 5276, "quality": 1.0, "length": 8}, "so_31518214_31518760_0": {"section_id": 5834, "quality": 0.8928571428571429, "length": 25}, "so_31518214_31518760_1": {"section_id": 5291, "quality": 0.9444444444444444, "length": 17}, "so_31518214_31518990_1": {"section_id": 5276, "quality": 0.6818181818181818, "length": 15}, "so_31518214_31518760_2": {"section_id": 40, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_31518214_31518760_0": {"section_id": 7562, "quality": 0.9285714285714286, "length": 26}, "so_31518214_31518760_1": {"section_id": 6939, "quality": 0.8888888888888888, "length": 16}, "so_31518214_31518990_0": {"section_id": 6924, "quality": 0.875, "length": 7}, "so_31518214_31518760_2": {"section_id": 43, "quality": 0.9428571428571428, "length": 33}}}, "31518760": {"ParentId": "31518214", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The problem is that <code>&amp;Derived::doStuff</code> isn't actually a pointer to a member of class <code>Derived</code>. From [expr.unary.op]:</p>\n<blockquote>\n<p id=\"so_31518214_31518760_0\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a <em>qualified-id</em>.\n  If the operand is a <em>qualified-id</em> naming a non-static or variant member <code>m</code> of some class <code>C</code> with type <code>T</code>,\n  the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating <code>C::m</code>.</p>\n</blockquote>\n<p><code>doStuff</code> is not a member of <code>Derived</code>. It is a member of <code>Base</code>. Hence it has type pointer to member of <code>Base</code>, or <code>void (Base::*)()</code>. What the <em>using-declaration</em> does here is simply an aid to overload resolution, from [namespace.udecl]:</p>\n<blockquote>\n<p id=\"so_31518214_31518760_1\">For the purpose of overload resolution, the functions which are introduced by a <em>using-declaration</em> into a\n  derived class will be treated as though they were members of the derived class.</p>\n</blockquote>\n<p>That's why <code>d.doStuff()</code> works. However, through the function pointer, you're trying to call a <code>Base</code> member function on a <code>Derived</code> object. There's no overload resolution here since you're using a function pointer directly, so the base class function would be inaccessible. </p>\n<p>You might think you could just cast <code>&amp;Derived::doStuff</code> to the \"correct\" type:</p>\n<pre><code>exec(&amp;d, static_cast&lt;void (Derived::*)()&gt;(&amp;Derived::doStuff));\n</code></pre>\n<p>But you can't do that either according to [conv.mem], since again <code>Base</code> is an inaccessible base of <code>Derived</code>:</p>\n<blockquote>\n<p id=\"so_31518214_31518760_2\">A prvalue of type \u201cpointer to member of <code>B</code> of type <em>cv</em> <code>T</code>\u201d, where <code>B</code> is a class type, can be converted to a\n  prvalue of type \u201cpointer to member of <code>D</code> of type <em>cv</em> <code>T</code>\u201d, where <code>D</code> is a derived class (Clause 10) of <code>B</code>. If <code>B</code> is an\n  <strong>inaccessible (Clause 11)</strong>, ambiguous (10.2), or virtual (10.1) base class of <code>D</code>, or a base class of a virtual base\n  class of <code>D</code>, a program that necessitates this conversion is ill-formed.</p>\n</blockquote>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-20T14:16:41.480", "Id": "31518760", "Score": "18", "CreationDate": "2015-07-20T14:11:12.280", "LastActivityDate": "2015-07-20T14:16:41.480"}});