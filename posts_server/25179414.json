post_cb({"bq_ids": {"n4140": {"so_25179414_25184733_2": {"length": 45, "quality": 0.9574468085106383, "section_id": 5451}, "so_25179414_25184733_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 336}}, "n3337": {"so_25179414_25184733_2": {"length": 31, "quality": 0.6595744680851063, "section_id": 5245}, "so_25179414_25184733_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 326}}, "n4659": {"so_25179414_25184733_2": {"length": 35, "quality": 0.7446808510638298, "section_id": 6889}, "so_25179414_25184733_0": {"length": 13, "quality": 0.6190476190476191, "section_id": 345}}}, "25184733": {"Id": "25184733", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow\"><code>std::make_shared</code></a> deduces its second template parameter from the arguments to the function call. A braced-init-list is not an expression, and as such, has no type. Hence template argument deduction cannot deduce a type from it. </p>\n<p>From <em>\u00a714.8.2.5/5 [temp.deduct.type]</em></p>\n<blockquote>\n<p id=\"so_25179414_25184733_0\">The non-deduced contexts are:<br/>\n  \u00a0 \u2014 <code>...</code><br/>\n  \u00a0 \u2014 A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter does not have <code>std::initializer_list</code> or reference to possibly cv-qualified <code>std::initializer_list</code> type. [ <em>Example:</em></p>\n<pre><code> template&lt;class T&gt; void g(T);\n g({1,2,3}); // error: no argument deduced for T\n</code></pre>\n<p id=\"so_25179414_25184733_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p><code>auto</code>, however, is a special case that is allowed to deduce <code>std::initializer_list&lt;T&gt;</code> from a braced-init-list.</p>\n<p><em>\u00a77.1.6.4/7 [dcl.spec.auto]</em></p>\n<blockquote>\n<p id=\"so_25179414_25184733_2\"><code>...</code> <strong>Otherwise, obtain <code>P</code> from <code>T</code> by replacing the occurrences of <code>auto</code></strong> with either a new invented type template parameter U or, <strong>if the initializer is a <em>braced-init-list</em>, with <code>std::initializer_list&lt;U&gt;</code>. Deduce a value for <code>U</code> using the rules of template argument deduction from a function call</strong> (14.8.2.1), where <code>P</code> is a function template parameter type and the initializer is the corresponding argument. If the deduction fails, the declaration is ill-formed. Otherwise, the type deduced for the variable or return type is obtained by substituting the deduced <code>U</code> into <code>P</code>. [ <em>Example:</em></p>\n<pre><code> auto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list&lt;int&gt;\n auto x2 = { 1, 2.0 }; // error: cannot deduce element type\n</code></pre>\n<p id=\"so_25179414_25184733_3\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>In your example, the variable <code>list</code> has the type <code>initializer_list&lt;shared_ptr&lt;int&gt;&gt;</code>, and when you pass it to <code>make_shared</code>, a <code>vector</code> can be constructed from it, which is then used to direct-initialize the <code>A</code> instance.</p>\n<p>Other options are to construct a <code>vector</code></p>\n<pre><code>auto res = std::make_shared&lt;A&gt;(std::vector&lt;std::shared_ptr&lt;int&gt;&gt;{x, y});\n</code></pre>\n<p>construct an <code>A</code>, which will then be moved</p>\n<pre><code>auto res = std::make_shared&lt;A&gt;(A{{x, y}});\n</code></pre>\n<p>or specify the template parameters for <code>make_shared</code> explicitly</p>\n<pre><code>auto res = std::make_shared&lt;A, std::initializer_list&lt;std::shared_ptr&lt;int&gt;&gt;&gt;({x, y});\n</code></pre>\n", "LastActivityDate": "2014-08-07T14:09:48.670", "CommentCount": "0", "CreationDate": "2014-08-07T14:09:48.670", "ParentId": "25179414", "Score": "1", "OwnerUserId": "241631"}, "25179414": {"ViewCount": "111", "Body": "<p>I have the following code:</p>\n<pre><code>    class A {\n        public: \n        A(std::vector&lt;std::shared_ptr&lt;int&gt;&gt;){}\n    };\n\n    auto x = std::make_shared&lt;int&gt;(0);\n    auto y = std::make_shared&lt;int&gt;(1);\n\n    auto list = {x, y};\n    auto res = std::make_shared&lt;A&gt;({x, y});\n</code></pre>\n<p>In the example if I pass to res variable list it compiles, otherwise as in the case of using initializer list directly it fails <a href=\"http://ideone.com/8jYsDY\" rel=\"nofollow\">http://ideone.com/8jYsDY</a></p>\n<p>I guess it has to do with the way type deduction works when initializer_list are involved. If this is standard conformant some reference would be good. </p>\n", "AcceptedAnswerId": "25184733", "Title": "Issue with object initialization from initializer list", "CreationDate": "2014-08-07T09:53:43.300", "Id": "25179414", "CommentCount": "0", "LastEditDate": "2014-08-07T14:10:50.867", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-08-07T14:10:50.867", "Score": "1", "OwnerUserId": "413766", "Tags": "<c++><c++11><initializer-list><brace-initialization>", "AnswerCount": "1"}});