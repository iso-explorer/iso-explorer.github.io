post_cb({"33058919": {"ParentId": "33058717", "PostTypeId": "2", "CommentCount": "3", "Body": "<h3>Introduction</h3>\n<p>The snippet you have shown is perfectly safe; you are legally allowed to initialize <strong>one</strong> non-static data-member when initializing your <em>union-like class</em>.</p>\n<hr>\n<h3>Example</h3>\n<p>The wikipedia article has an example where <em>placement-new</em> is used because they are writing to a member after the point in which it is possible to directly initialize a certain member.</p>\n<pre><code>union A {\n   A () { new (&amp;s1) std::string (\"hello world\"); }\n  ~A () { s1.~basic_string&lt;char&gt; (); }\n  int         n1;\n  std::string s1;\n};\n</code></pre>\n<p>The previous snippet is however semantically equivalent to the following, where we explicitly state that <code>A::s1</code> shall be initialized when constructing <code>A</code>.</p>\n<pre><code>union A {\n   A () : s1 (\"hello world\") { }\n  ~A () { s1.~basic_string&lt;char&gt; (); }\n  int         n1;\n  std::string s1;\n};\n</code></pre>\n<hr>\n<h3>Elaboration</h3>\n<p>In your snippet you have an <em>anonymous union</em> inside your class (which makes your class a <em>union-like class</em>), which means that unless you initialize <strong>one</strong> of the members of the <code>union</code> during initialization of the class \u2014 you must use <em>placement-new</em> to initialize them at a later time.</p>\n<hr>\n<h3>What does the Standard say?</h3>\n<blockquote>\n<pre><code>9.5/1 -- <b>Unions</b> -- [class.union]p1</code></pre>\n<blockquote>\n<p id=\"so_33058717_33058919_1\">In a union, at most one of the non-static data members can be active at any \n    time, that is, the value of at most one of the non-static data members can \n    be stored in a union at any time.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<pre><code>3.8/1 -- <b>Object lifetime</b> -- [basic.life]p1</code></pre>\n<blockquote>\n<p id=\"so_33058717_33058919_4\">[...]<br/><br/>\n    The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and </li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n<p id=\"so_33058717_33058919_5\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n</blockquote>\n</hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2015-10-12T18:30:44.617", "Id": "33058919", "Score": "7", "CreationDate": "2015-10-10T20:58:14.723", "LastActivityDate": "2015-10-12T18:30:44.617"}, "33058844": {"ParentId": "33058717", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>No, placement new is not required here. The standard says that in case of unrestricted unions, the field constructors should be called explicitly, otherwise the fields will be uninitialized.</p>\n<p>You can call the constructor using traditional way</p>\n<pre><code>U(): p() {}\n</code></pre>\n<p>and exotic way </p>\n<pre><code>U() { new(&amp;p) Point(); }\n</code></pre>\n<p>The second variant may be useful if it is not possible to construct the field before calling the constructor of <code>U</code>.</p>\n<p>Don't also forget about placement destructors in this case.</p>\n", "OwnerUserId": "5380314", "LastEditorUserId": "5380314", "LastEditDate": "2015-10-10T21:31:54.273", "Id": "33058844", "Score": "1", "CreationDate": "2015-10-10T20:49:33.380", "LastActivityDate": "2015-10-10T21:31:54.273"}, "33058717": {"CommentCount": "5", "AcceptedAnswerId": "33058919", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2015-10-10T20:36:20.290", "LastActivityDate": "2016-05-02T16:31:08.840", "LastEditDate": "2016-05-02T16:31:08.840", "ViewCount": "777", "FavoriteCount": "1", "Title": "Do unrestricted unions require placement new and a constructor definition?", "Id": "33058717", "Score": "6", "Body": "<p>The examples I've seen of unrestricted unions always seem to use placement new when constructing. The Wikipedia article for C++11 features uses placement new in the constructor of a union.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Unrestricted_unions\">https://en.wikipedia.org/wiki/C%2B%2B11#Unrestricted_unions</a></p>\n<pre><code>#include &lt;new&gt; // Required for placement 'new'.\n\nstruct Point {\n    Point() {}\n    Point(int x, int y): x_(x), y_(y) {} \n    int x_, y_;\n};\n\nunion U {\n    int z;\n    double w;\n    Point p; // Illegal in C++03; legal in C++11.\n    U() {new(&amp;p) Point();} // Due to the Point member, a constructor definition is now required.\n};\n</code></pre>\n<p>Is it necessary to use placement new here? For example, this piece of code compiles without warnings with gcc and valgrind shows no memory leaks when the union is used to hold a string:</p>\n<pre><code>struct HasUnresUnion\n{\n    enum { Int, String } tag;\n\n    HasUnresUnion(int i)\n      : tag(Int),\n        as_int(i)\n    {}\n\n    HasUnresUnion(std::string str)\n      : tag(String),\n        as_str(std::move(str))\n    {}\n\n    ~HasUnresUnion()\n    {\n        using std::string;\n        if (tag == String)\n            as_str.~string();\n    }\n\n    union\n    {\n        int as_int;\n        std::string as_str;\n    };\n};\n</code></pre>\n<p>It doesn't seem like there's any ambiguity here so I don't see why the standard would outlaw this. Is this legal code? Is placement new necessary when the union is <em>uninitialized</em> (rather than being assigned to)? Is the constructor in the union required? I've definitely seen unrestricted unions without their own constructors but Wikipedia explicitly states it's required.</p>\n", "Tags": "<c++><c++11><unions>", "OwnerUserId": "1128289", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33058717_33058919_0": {"section_id": 5913, "quality": 1.0, "length": 19}, "so_33058717_33058919_5": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_2": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_1": {"section_id": 5913, "quality": 1.0, "length": 19}, "so_33058717_33058919_4": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_3": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_33058717_33058919_0": {"section_id": 5685, "quality": 1.0, "length": 19}, "so_33058717_33058919_5": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_2": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_1": {"section_id": 5685, "quality": 1.0, "length": 19}, "so_33058717_33058919_4": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_3": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_33058717_33058919_0": {"section_id": 7404, "quality": 1.0, "length": 19}, "so_33058717_33058919_5": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_2": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_1": {"section_id": 7404, "quality": 1.0, "length": 19}, "so_33058717_33058919_4": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_33058717_33058919_3": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}});