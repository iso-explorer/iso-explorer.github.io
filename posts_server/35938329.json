post_cb({"35938555": {"ParentId": "35938329", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If the vector is resized, the iterator will become invalid.</p>\n<p>You could do it if you reserve in advance. </p>\n<p>Keep in mind that <code>for range</code> will operate on the iterator bounds defined before any changes are made. So will only get a copy of your list appended.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; a{1,2,3};\n\n    a.reserve(10);           // 10 should be enough to get a copy without reallocating\n    for( auto const &amp; item : a)\n        a.push_back(item);\n\n    for( auto const &amp; item : a)\n        std::cout&lt;&lt;item&lt;&lt;',';\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>1,2,3,1,2,3,\n</code></pre>\n<p>I would not recommend an approach like this because I don't consider it clean or clear. However, if you refer to the standard, this behaviour is expected:</p>\n<blockquote>\n<p id=\"so_35938329_35938555_0\">23.3.6.5 vector modifiers</p>\n</blockquote>\n<p>With respect to the use of <code>insert</code>,<code>emplace</code>,<code>emplace_back</code>, <code>push_back</code>. </p>\n<blockquote>\n<p id=\"so_35938329_35938555_1\">Remarks: Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>That is, if no reallocation happens, you can trust your iterators before the insertion point. So as long as the capacity of your vector is high enough, you can append with no problems.</p>\n", "OwnerUserId": "157726", "LastEditorUserId": "157726", "LastEditDate": "2016-03-11T11:43:42.323", "Id": "35938555", "Score": "3", "CreationDate": "2016-03-11T11:02:40.773", "LastActivityDate": "2016-03-11T11:43:42.323"}, "35938442": {"ParentId": "35938329", "CommentCount": "2", "Body": "<p>In C++ adding elements to a vector may cause reallocation of the contained data, which will invalidate all iterators. That means you can't loop over the vector using iterators (which is what the range-based for loop does) while also inserting new elements.</p>\n<p>You <em>can</em> however iterate using indexes and use the vector size as condition, since indexes will always be the same.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "35938442", "Score": "6", "CreationDate": "2016-03-11T10:57:18.397", "LastActivityDate": "2016-03-11T10:57:18.397"}, "35938329": {"CommentCount": "4", "ViewCount": "452", "PostTypeId": "1", "LastEditorUserId": "4373992", "CreationDate": "2016-03-11T10:52:37.910", "LastActivityDate": "2016-03-11T11:49:03.907", "Title": "C++: push_back in std::vector while iterating it", "LastEditDate": "2016-03-11T11:49:03.907", "Id": "35938329", "Score": "3", "Body": "<p>Following code snippet provides a  very weird output. I was expecting an overflow( Python gives a MemoryError)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; a{1,2,3};\n\n    for( auto const &amp; item : a)\n        a.push_back(item);\n\n\n    for( auto const &amp; item : a)\n        std::cout&lt;&lt;item&lt;&lt;',';\n\n    return 0;\n}\n</code></pre>\n<p><strong>Output: 1,2,3,1,0,3,</strong></p>\n<p>How do I interpret this result?</p>\n<p>If you do a similar thing in Python, it gives a memory error.</p>\n<pre><code>&gt;&gt;&gt; a = range(0,20)\n&gt;&gt;&gt; for i in a:\n    a.append(i)\n\n\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#3&gt;\", line 2, in &lt;module&gt;\n    a.append(i)\nMemoryError\n\n&gt;&gt;&gt; \n</code></pre>\n<p>This question came to my mind, because above way of writing code is considered to be bound-safe. And for bound safety container should not grow/shrink during <code>foreach type iteration</code>. So, this is a leaky abstraction.</p>\n<p>Is there a way one can wrap this <code>foreach</code> loop so that any operation causing size-modification/reallocation is not allowed in  the loop body.</p>\n", "Tags": "<python><c++><vector><leaky-abstraction>", "OwnerUserId": "4373992", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_35938329_35938555_1": {"section_id": 986, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_35938329_35938555_1": {"section_id": 971, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_35938329_35938555_1": {"section_id": 1049, "quality": 0.9473684210526315, "length": 18}}}});