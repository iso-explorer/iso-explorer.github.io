post_cb({"36665206": {"ParentId": "36665029", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Your code has undefined behavior, so almost any question about why it does anything is meaningless and unanswerable. To the extent it does any particular thing at all, it's basically just luck.</p>\n<p>You have things basically backwards of what you probably intended (or of what you should have intended in any case), which would have a <code>main</code> something on this order:</p>\n<pre><code>int main(int argc, char** argv)\n{\n    Base *bptr = new Layer2;\n    bptr-&gt;func();       \n\n    Layer2 *l2ptr = dynamic_cast&lt;Layer2 *&gt;(bptr);\n\n    if (l2ptr)\n        l2ptr-&gt;func2();\n\n    delete bptr;\n}\n</code></pre>\n<p>Here we use a <code>pointer to Base</code> to refer to an object of type <code>Layer2</code>, rather than vice versa. Since Layer2 is derived from <code>Base</code>, this is allowed and the behavior is meaningful.</p>\n<p>That lets us talk about the details of why it does what it does.</p>\n<p>The destructor not being marked <code>virtual</code> in <code>Layer2</code> is basically irrelevant: since it's marked <code>virtual</code> in a base class, it remains <code>virtual</code> in all derived classes:</p>\n<p>C++ standard, \u00a7[class.virtual]/2:</p>\n<blockquote>\n<p id=\"so_36665029_36665206_0\">If a virtual member function vf is declared in a class Base and in a class Derived, derived directly or indirectly from Base, a member function vf with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as Base::vf is declared, then Derived::vf is also virtual (whether or not it is so declared) and it <em>overrides</em> <sup>111</sup> Base::vf.</p>\n</blockquote>\n<p>C++ standard, \u00a7[class.virtual]/6:</p>\n<blockquote>\n<p id=\"so_36665029_36665206_1\">Even though destructors are not inherited, a destructor in a derived class overrides a base class destructor declared virtual;</p>\n</blockquote>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2016-04-16T14:39:45.280", "Id": "36665206", "Score": "4", "CreationDate": "2016-04-16T14:08:53.543", "LastActivityDate": "2016-04-16T14:39:45.280"}, "36665029": {"CommentCount": "4", "ViewCount": "69", "PostTypeId": "1", "LastEditorUserId": "4599151", "CreationDate": "2016-04-16T13:51:35.370", "LastActivityDate": "2016-04-16T14:39:45.280", "Title": "Calling destructor by object pointer", "LastEditDate": "2016-04-16T13:56:03.613", "Id": "36665029", "Score": "0", "Body": "<p>Can you please explain why the following code does not crash and how it is handled not to.</p>\n<pre><code>class Base\n{\npublic:\n    Base() {cout &lt;&lt; \"Base constr\" &lt;&lt; endl;}\n    virtual void func() {cout &lt;&lt; \"Base func()\" &lt;&lt; endl;}\n    virtual ~Base() {cout &lt;&lt; \"Base destr\" &lt;&lt; endl;}\n};\n\nclass Layer1 : public Base\n{\npublic:\n    Layer1() {cout &lt;&lt; \"Layer1 constr\" &lt;&lt; endl;}\n    virtual void func() {cout &lt;&lt; \"Layer1 func()\" &lt;&lt; endl;}\n    virtual ~Layer1() {cout &lt;&lt; \"Layer1 destr\" &lt;&lt; endl;}\n};\n\nclass Layer2 : public Layer1\n{\npublic:\n    Layer2() {cout &lt;&lt; \"Layer2 constr\" &lt;&lt; endl;}\n    virtual void func() {cout &lt;&lt; \"Layer2 func()\" &lt;&lt; endl;}\n    ~Layer2() {cout &lt;&lt; \"Layer2 destr\" &lt;&lt; endl;}\n};\n\nint main(int argc, char** argv)\n{\n    Layer2 * l2ptr = (Layer2 *) new Base;\n    l2ptr-&gt;func();\n    delete l2ptr;\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Base constr\nBase func()\nBase destr\n</code></pre>\n<p>I mean at the point where delete l2ptr is called. From the first look it seems that <code>Layer2</code> destructor should be called, but no <code>Layer2</code> object has been created. Also, <code>Layer2</code> destructor is not <code>virtual</code>. When I make it virtual the output is the same. Why?<br><br>\nAnd the next question: what issues and considerations there are on accesing parent class object by it's child class pointer?<br><br/></br></br></br></p>\n<p>EDIT:\nIf I change <code>Layer2</code> class to this</p>\n<pre><code>class Layer2 : public Layer1\n{\npublic:\n    Layer2() {cout &lt;&lt; \"Layer2 constr\" &lt;&lt; endl;}\n    virtual void func() {cout &lt;&lt; \"Layer2 func()\" &lt;&lt; endl;}\n    void func2() {cout &lt;&lt; \"Layer2 func2()\" &lt;&lt; endl;}\n    virtual ~Layer2() {cout &lt;&lt; \"Layer2 destr\" &lt;&lt; endl;}\n};\n</code></pre>\n<p>And <code>main()</code> like this:</p>\n<pre><code>int main(int argc, char** argv)\n{\n    Layer2 * l2ptr = (Layer2 *) new Base;\n    l2ptr-&gt;func();\n    l2ptr-&gt;func2();\n    delete l2ptr;\n\n    return 0;\n}\n</code></pre>\n<p>It still works and the output is:</p>\n<pre><code>Base constr\nBase func()\nLayer2 func2()\nBase destr\n</code></pre>\n<p>Again, why?</p>\n", "Tags": "<c++><vtable><virtual-destructor>", "OwnerUserId": "4599151", "AnswerCount": "3"}, "36665149": {"ParentId": "36665029", "CommentCount": "5", "Body": "<p>Your code has undefined behaviour as has been pointed out - for example when you access a <code>Base</code> object via a pointer to <code>Layer2</code>.</p>\n<p>Undefined behaviour includes appearing to work (and indeed anything else). In this case it happens that the layout of the objects is sufficiently similar that nothing goes too badly wrong. The vtable pointers are in the same place; calls to virtual functions correctly go to the <code>Base</code> versions, because the object is a <code>Base</code> and contains a pointer to the <code>Base</code> vtable. Non-virtual functions go to the type you told the compiler the object was.</p>\n<p>(Implementations don't have to use a vtable, but they usually do.)</p>\n<p>But it's all still undefined behaviour; don't do this, and most definitely don't rely on it.</p>\n", "OwnerUserId": "212870", "PostTypeId": "2", "Id": "36665149", "Score": "0", "CreationDate": "2016-04-16T14:03:06.473", "LastActivityDate": "2016-04-16T14:03:06.473"}, "36665250": {"ParentId": "36665029", "CommentCount": "0", "Body": "<p>Correct me if I'm wrong but you never construct an object of either <code>Layer2</code> or <code>Layer1</code>; only a <code>Base</code> object which you casts (in C style, mind you, not C++) to a pointer to a <code>Layer2</code> type. That is to say, <code>func2</code> won't be available to the object your pointer points to, but the compiler accepts it because it only checkes the static type of your pointer. </p>\n", "OwnerUserId": "5935250", "PostTypeId": "2", "Id": "36665250", "Score": "0", "CreationDate": "2016-04-16T14:13:12.563", "LastActivityDate": "2016-04-16T14:13:12.563"}, "bq_ids": {"n4140": {"so_36665029_36665206_0": {"section_id": 7003, "quality": 0.9090909090909091, "length": 30}, "so_36665029_36665206_1": {"section_id": 7007, "quality": 1.0, "length": 13}}, "n3337": {"so_36665029_36665206_0": {"section_id": 6749, "quality": 0.9090909090909091, "length": 30}, "so_36665029_36665206_1": {"section_id": 6753, "quality": 1.0, "length": 13}}, "n4659": {"so_36665029_36665206_0": {"section_id": 8500, "quality": 0.9090909090909091, "length": 30}, "so_36665029_36665206_1": {"section_id": 8504, "quality": 1.0, "length": 13}}}});