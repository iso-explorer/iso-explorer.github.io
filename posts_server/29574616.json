post_cb({"29574616": {"CommentCount": "8", "ViewCount": "455", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorDisplayName": "user2953119", "CreationDate": "2015-04-11T05:55:12.107", "LastActivityDate": "2015-05-21T05:20:09.073", "LastEditDate": "2015-05-21T05:20:09.073", "AcceptedAnswerId": "29575182", "FavoriteCount": "1", "Title": "Friend functions and static data members", "Id": "29574616", "Score": "6", "Body": "<p>How is unqualified name lookup being performed for names using within the friend's function body? Let's consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo();\n\nclass A\n{\n    friend void foo(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n    static int a;\n};\n\nint A::a = 10;\n\nint main(){ foo(); }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1b971d65efc00821\" rel=\"nofollow noreferrer\"><strong>DEMO</strong></a></p>\n<p>The Standard states in the <code>N4296::7.3.1.2/3 [namespace.memdef]</code>:</p>\n<blockquote>\n<p id=\"so_29574616_29574616_0\">If a friend declaration in a non-local class first declares a class,\n  function, class template or function template the friend is a member\n  of the innermost enclosing namespace.</p>\n</blockquote>\n<p>So, I expected unqualified name lookup didn't find <code>A::a</code>, but it did. I deliberately put the <code>A::a</code> declaration after the friend's function definition in hope it wouldn't be found. What's the actual rule for the friend's unqualified name lookup?</p>\n", "Tags": "<c++><friend>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29574616_29575182_2": {"section_id": 187, "quality": 0.8333333333333334, "length": 5}, "so_29574616_29575182_0": {"section_id": 7094, "quality": 0.9230769230769231, "length": 24}, "so_29574616_29574616_0": {"section_id": 5485, "quality": 1.0, "length": 17}, "so_29574616_29575182_4": {"section_id": 7095, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_29574616_29575182_2": {"section_id": 181, "quality": 0.8333333333333334, "length": 5}, "so_29574616_29575182_0": {"section_id": 6838, "quality": 0.5384615384615384, "length": 14}, "so_29574616_29574616_0": {"section_id": 5271, "quality": 0.8823529411764706, "length": 15}, "so_29574616_29575182_4": {"section_id": 6839, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_29574616_29575182_2": {"section_id": 192, "quality": 0.8333333333333334, "length": 5}, "so_29574616_29575182_0": {"section_id": 8595, "quality": 0.8846153846153846, "length": 23}, "so_29574616_29574616_0": {"section_id": 6920, "quality": 1.0, "length": 17}, "so_29574616_29575182_4": {"section_id": 8596, "quality": 0.9444444444444444, "length": 17}}}, "29575182": {"ParentId": "29574616", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The answer was quite simple:</p>\n<p><code>N4296::3.4.1/8 [basic.lookup.unqual]</code> :</p>\n<blockquote>\n<p id=\"so_29574616_29575182_0\">For the members of a class X, a name <strong><em>used in a member function\n  body</em></strong>, in a default argument, in an exceptionspecification, in the\n  brace-or-equal-initializer of a non-static data member (9.2), or in\n  the definition of a class member outside of the definition of X,\n  following the member\u2019s declarator-id31, shall be declared in one of\n  the following ways:</p>\n<p id=\"so_29574616_29575182_1\">[...]</p>\n<p id=\"so_29574616_29575182_2\">(8.2) \u2014 shall be a member of class X or be a member of a base class of\n  X (10.2), </p>\n<p id=\"so_29574616_29575182_3\">[...]</p>\n</blockquote>\n<p><code>N4296::3.4.1/9 [basic.lookup.unqual]</code> :</p>\n<blockquote>\n<p id=\"so_29574616_29575182_4\">Name lookup for a name used in the definition of a <strong><em>friend function</em></strong>\n  (11.3) <strong><em>defined inline</em></strong> in the class granting friendship shall proceed\n  as described for <strong><em>lookup in member function definitions</em></strong>.</p>\n</blockquote>\n<p>That's it.</p>\n<p>UPD:</p>\n<p><strong><em>Inlining</em></strong> is important here. That's why the friend function defined outside the class defintion cannot use static members of the class directly. For instance, the following code pritns compile-time error:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\n    static int a;\n    friend void foo();\n};\n\nint A::a = 10;\n\nvoid foo(){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n\n\n\nint main(){ foo(); }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/2229b5698e968fbb\" rel=\"nofollow\">DEMO</a></strong></p>\n", "Id": "29575182", "LastEditDate": "2015-04-12T07:20:58.013", "OwnerDisplayName": "user2953119", "Score": "4", "CreationDate": "2015-04-11T07:14:43.570", "LastActivityDate": "2015-04-12T07:20:58.013", "LastEditorUserId": "1968182"}});