post_cb({"25291603": {"CommentCount": "0", "ViewCount": "195", "PostTypeId": "1", "LastEditorUserId": "472610", "CreationDate": "2014-08-13T16:37:18.710", "LastActivityDate": "2014-08-17T20:22:47.490", "Title": "Inherited template assignment operator", "AcceptedAnswerId": "25291647", "LastEditDate": "2014-08-17T20:22:47.490", "Id": "25291603", "Score": "2", "Body": "<p>I often run into compiling issues when writing a child class using one of its parent's template method. For example, I wrote this, but I don't know why it compiles:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;algorithm&gt;\n\n        /********************     **********     ********************/\n\ntemplate &lt;class T, unsigned N&gt;\nstruct A\n{\n    T data[N];\n\n    template &lt;class U&gt;\n    inline auto operator= ( const U&amp; other ) -&gt; decltype(*this)\n        { this-&gt;assign(other); return *this; }\n\n    template &lt;class U&gt;\n    void assign( const U&amp; other )\n        { assign_impl( other, std::is_arithmetic&lt;U&gt;() ); }\n\n    template &lt;class U&gt;\n    void assign_impl( const U&amp; val, std::true_type const )\n        { std::fill( data, data+N, static_cast&lt;T&gt;(val) ); }\n};\n\n// ------------------------------------------------------------------------\n\ntemplate &lt;class T, unsigned N&gt;\nstruct B\n    : public A&lt;T,N&gt;\n{\n    // Needed in order to compile\n    using A&lt;T,N&gt;::operator=;\n\n    void show()\n    {\n        for (unsigned i=0; i&lt;N; ++i)\n            std::cout&lt;&lt; this-&gt;data[i] &lt;&lt; \" \";\n            std::cout&lt;&lt; std::endl;\n    }\n};\n\n// ------------------------------------------------------------------------\n\nint main()\n{\n    B&lt;double,5&gt; b;\n    b = -5.1; \n    b.show();\n\n    b.assign(3.14159);\n    b.show();\n}\n</code></pre>\n<p>Including the statement <code>using A&lt;T,N&gt;::operator=;</code> is necessary if I want to use this operator with instances of <code>B&lt;T,N&gt;</code>, but I never specified that the method <code>assign</code> should be visible. Is it visible because <code>operator=</code> uses it?</p>\n", "Tags": "<c++><templates><inheritance><c++11><using>", "OwnerUserId": "472610", "AnswerCount": "1"}, "25291647": {"ParentId": "25291603", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The method <code>assign</code> is visible in your class <code>B</code> because you are using <code>struct</code> which has public default encapsulation and <code>public</code> inheritance.</p>\n<p>As for <code>operator=</code> :</p>\n<blockquote>\n<p id=\"so_25291603_25291647_0\">(13.5.3 Assignment) An assignment operator shall be implemented by a\n  non-static member function with exactly one parameter. Because a copy\n  assignment operator operator= is implicitly declared for a class if\n  not declared by the user, a base class assignment operator is always\n  hidden by the copy assignment operator of the derived class.</p>\n</blockquote>\n", "OwnerUserId": "1147772", "LastEditorUserId": "1147772", "LastEditDate": "2014-08-13T16:45:18.903", "Id": "25291647", "Score": "2", "CreationDate": "2014-08-13T16:39:21.923", "LastActivityDate": "2014-08-13T16:45:18.903"}, "bq_ids": {"n4140": {"so_25291603_25291647_0": {"section_id": 660, "quality": 0.9375, "length": 30}}, "n3337": {"so_25291603_25291647_0": {"section_id": 650, "quality": 0.9375, "length": 30}}, "n4659": {"so_25291603_25291647_0": {"section_id": 688, "quality": 0.9375, "length": 30}}}});