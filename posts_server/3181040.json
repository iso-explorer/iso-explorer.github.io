post_cb({"bq_ids": {"n4140": {"so_3181040_3181233_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 3360}, "so_3181040_3181233_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 3356}}, "n3337": {"so_3181040_3181233_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 3230}, "so_3181040_3181233_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 3226}}, "n4659": {"so_3181040_3181233_0": {"length": 9, "quality": 0.6, "section_id": 4110}}}, "3181070": {"Id": "3181070", "PostTypeId": "2", "Body": "<p>To answer your actual question, any time an exception occurs during construction, execution stops right there (the object being constructed is never constructed) and control passes to the nearest exception handler (<code>catch</code>).</p>\n<p>You're right that a memory leak will occur only when <code>d</code> causes an exception, and in that case, the outer <code>catch</code> needs to clean up.</p>\n<p>If <code>new C</code> itself throws, the object is never constructed, so you don't need to worry about deleting it.</p>\n", "LastEditorUserId": "381345", "LastActivityDate": "2010-07-05T16:55:18.900", "Score": "0", "CreationDate": "2010-07-05T16:49:51.140", "ParentId": "3181040", "CommentCount": "2", "LastEditDate": "2010-07-05T16:55:18.900", "OwnerUserId": "381345"}, "3181111": {"Id": "3181111", "PostTypeId": "2", "Body": "<p>Try/catch function blocks are frowned upon, in the same way as goto --there might be some corner case where they make sense, but they are better avoided: when an object fails to be constructed, best thing you can do is fail and fail fast.</p>\n<p>On you specific questions, when an exception is thrown in a constructor, all fully constructed subobjects will be destroyed. That means that in the case of <code>b</code> it will be destroyed, in the case of <code>c</code>, it being a raw pointer, nothing is done. The simplest solution is changing <code>c</code> to be a smart pointer that handles the allocated memory. That way, if <code>d</code> throws, the smart pointer will be destroyed and the object released. This is not related to the try/catch block, but rather to how constructors work.</p>\n<p>It is also, in general, unsafe to delete the pointer from the catch block, as there is no guarantee of the actual value of the pointer <em>before</em> the initialization is performed. That is, if <code>b</code> or <code>c</code> throw, it might be the case that <code>c</code> is not 0, but is not a valid pointer either, and deleting it would be undefined behavior. As always there are cases, as if you have a guarantee that neither <code>b</code> nor <code>c</code> will throw, and assuming that a <code>bad_alloc</code> is not something you usually recover from, then it might be safe.</p>\n<p>Note that if you need to keep a pointer with a raw pointer for some specific reason, it is better to initialize it to 0 in the initialization list, and then create the object inside the construction block to avoid this problem. Remember also that holding more than one resource directly in a class makes it really hard to ensure that no resource is leaked -- if first resource is created and assigned, and the second one fails, the destructor will not be called and the resource will leak. Again, if you can use a smart pointer you will have one less problem to deal with.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2010-07-05T18:44:29.457", "Score": "7", "CreationDate": "2010-07-05T17:02:18.893", "ParentId": "3181040", "CommentCount": "7", "LastEditDate": "2010-07-05T18:44:29.457", "OwnerUserId": "36565"}, "3181040": {"ViewCount": "2352", "Body": "<p>Early today I discovered function try-catch blocks (from <a href=\"https://stackoverflow.com/questions/75538/hidden-features-of-c/152659#152659\">here</a> in fact) and then went on a bit of a research spree - apparently they're main use is it catch exceptions throw in by a constructor initialiser list.</p>\n<p>Anyway, this sent me thinking about failing constructors and I've got to a stage where I just need a little clarification. This is all just me trying to learn more about the language, so I don't have a <em>practical</em> example, but here goes...</p>\n<hr>\n<p>Given this example code:</p>\n<pre><code>class A\n{\nprivate:\n    B b\n    C *c;    //classes B, C &amp; D omitted for brevity as not really relevant\n    D d;\npublic\n    A(int x, int y, int z)\n};\n\nA::A(int x, int y, int z)\ntry\n    : b( x )\n    , c( new C(y) )\n    , d( z )\n{\n    //omitted\n}\ncatch(...)\n{\n    //omitted\n}\n</code></pre>\n<p>What happens in these cases:</p>\n<ol>\n<li>The initialisation of <code>b</code> throws an exception.</li>\n<li>The initialisation of <code>c</code> throws an exception.</li>\n<li>The initialisation of <code>d</code> throws an exception.</li>\n</ol>\n<p>Specifically, I want to know at least:</p>\n<ul>\n<li>what will/may cause a memory leak from <code>new C(y)</code>. <em>I'm thinking only 3? (see <a href=\"https://stackoverflow.com/questions/1674980/who-deletes-the-memory-allocated-during-a-new-operation-which-has-exception-in\">here</a>)</em></li>\n<li>could you just <code>delete b</code> in the catch? <em>Is dangerous in cases 1 and 2?</em></li>\n</ul>\n<p>Obviously, I guess the safest thing to do is to make <code>c</code> a smart pointer. But disregarding that option for the moment, what's the best course of action?  </p>\n<p>Is it safe to set <code>c</code> to <code>NULL</code> in the initialiser, and then place the call to <code>new</code> in the constructor body?  </p>\n<p>That would then mean a <code>delete c</code> must be placed in the catch in case something else throws in the constructor body? Are there safety issues doing that (ie, if it's the <code>c = new C(y);</code> itself that throws)?</p>\n</hr>", "AcceptedAnswerId": "3181111", "Title": "Dynamic memory and constructor exceptions", "CreationDate": "2010-07-05T16:42:11.010", "Id": "3181040", "CommentCount": "2", "LastEditDate": "2017-05-23T11:47:37.667", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2010-07-05T18:44:29.457", "Score": "4", "OwnerUserId": "360632", "Tags": "<c++><exception><constructor>", "AnswerCount": "3"}, "3181233": {"Id": "3181233", "PostTypeId": "2", "Body": "<p>You cannot do anything in the function-try-block handler, except translate one exception to another. You cannot prevent exception from being thrown. You cannot do anything to class members. So no, you cannot do <code>delete c</code> in the constructor's function-try-block.</p>\n<blockquote>\n<p id=\"so_3181040_3181233_0\">The fully constructed base classes and\n  members of an object shall be\n  destroyed before entering the handler\n  of a function-try-block of a\n  constructor or destructor for that\n  object.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_3181040_3181233_1\">The currently handled exception is\n  rethrown if control reaches the end of\n  a handler of the function-try-block of\n  a constructor or destructor.\n  Otherwise, a function returns when\n  control reaches the end of a handler\n  for the function-try-block (6.6.3).\n  Flowing off the end of a\n  function-try-block is equivalent to a\n  return with no value; this results in\n  unde\ufb01ned behavior in a value-returning\n  function.</p>\n</blockquote>\n<p>(15.3 [except.handle] from the C++ Standard)</p>\n", "LastActivityDate": "2010-07-05T17:33:10.410", "Score": "2", "CreationDate": "2010-07-05T17:33:10.410", "ParentId": "3181040", "CommentCount": "2", "OwnerUserId": "23252"}});