post_cb({"42638847": {"CommentCount": "0", "ViewCount": "253", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-03-07T02:00:59.273", "LastActivityDate": "2017-03-08T22:32:06.707", "Title": "What is the maximum value I can pass to std::thread::sleep_for() and sleep_until()?", "AcceptedAnswerId": "42657900", "LastEditDate": "2017-05-23T12:31:49.560", "Id": "42638847", "Score": "1", "Body": "<p><a href=\"https://stackoverflow.com/q/36711131/4885801\">This question</a> on sleeping forever has an answer that mentions this:</p>\n<pre><code>std::this_thread::sleep_until(\n    std::chrono::time_point&lt;std::chrono::system_clock&gt;::max());\n</code></pre>\n<p>and this:</p>\n<pre><code>std::this_thread::sleep_for(\n    std::chrono::system_clock::durat\u200c\u200bion::max());\n</code></pre>\n<p>Running this code on Visual C++ 2017 RC actually doesn't sleep at all. I haven't checked out the <code>sleep_until()</code> case, so I'm not sure what's going on there.</p>\n<p>In the <code>sleep_for()</code> case, the given <code>duration</code> seems to be converted to an absolute time by adding it to <code>system_clock::now()</code>which is then forwarded to <code>sleep_until()</code>. The problem is that the addition overflows, giving a time in the past.</p>\n<p>Looking at the C++17 draft in 30.3.2, neither <code>sleep_until()</code> nor <code>sleep_for()</code> seem to mention limits. There is nothing relevant in <em>Timing specifications</em> (30.2.4). As for <code>duration::max()</code>, it is described in <em><code>duration_values</code></em> (20.17.4.3) as: \"The value returned shall compare greater than <code>zero()</code>\", which isn't helpful at all.</p>\n<p>Honestly, I was rather surprised to see <code>sleep_for()</code> fail for <code>system_clock::duration::max()</code>, as it is a construct that make perfect sense to me.</p>\n<p>What is the highest value I can pass to those functions that has a well-defined behaviour?</p>\n", "Tags": "<c++><sleep><chrono>", "OwnerUserId": "4885801", "AnswerCount": "2"}, "42657900": {"ParentId": "42638847", "PostTypeId": "2", "CommentCount": "0", "Body": "<h2>It's unspecified, and it will overflow</h2>\n<p>I've had discussions with Billy O'Neal, one of the Visual C++ standard library developers, and Howard Hinnant, lead author of libc++. My conclusion is that <strong>the <code>_for</code> and <code>_until</code> family from the threading library will overflow in unspecified ways</strong> and you should not try to pass largish values to them. Whether the standard is under-specified on that subject is unclear to me.</p>\n<h2>The problem</h2>\n<p>All timed functions<sup>1</sup> take either a <code>duration</code> or a <code>time_point</code>. Both are defined by their underlying type (<em>representation</em>) and ratio (<em>period</em>). The period can also be considered a \"unit\", such as a second or nanosecond.</p>\n<p>There are two main places where overflow can happen:</p>\n<ol>\n<li>Before the platform-specific call, and</li>\n<li>During the conversion to a platform-specific type</li>\n</ol>\n<h3>Before the call</h3>\n<p>It is possible to avoid overflow in this situation, like Howard mentions in his answer, but \"implementors are still learning how to deal with overflow induced by <code>chrono</code> conversions among durations of different precisions\". </p>\n<p>Visual C++ 2017, for example, implements <code>sleep_for()</code> in terms of <code>sleep_until()</code> by adding the given duration to the current time returned by \n<code>system_clock::now()</code>. If the duration is too large, this will overflow. Other libraries, such as libstdc++, don't seem to have this problem.</p>\n<h3>The system call</h3>\n<p>Once you go deep enough, you'll have to interact with whatever platform you're on to do the actual work. This is where it gets messy.</p>\n<p>On libstdc++, for example, the call to <code>sleep_for()</code> ends up in <a href=\"http://man7.org/linux/man-pages/man2/nanosleep.2.html\" rel=\"nofollow noreferrer\"><code>nanosleep()</code></a>, which takes a a <code>timespec</code>. This is a simplified version of it:</p>\n<pre><code>auto s = duration_cast&lt;seconds&gt;(time);\nauto ns = duration_cast&lt;nanoseconds&gt;(time - s);\n\ntimespec ts = { s.count(), ns.count() };\nnanosleep(&amp;ts, &amp;ts);\n</code></pre>\n<p>It's easy to overflow this: you just have to pass a time that is longer than LLONG_MAX seconds:</p>\n<pre><code>std::this_thread::sleep_for(hours::max());\n</code></pre>\n<p>This overflows the <code>duration_cast</code> into <code>seconds</code> and sets <code>ts.tv_sec</code> to -3600, which doesn't sleep at all because <code>nanosleep()</code> fails on negative values. It gets even better with <code>sleep_until()</code>, which tries to call <code>nanosleep()</code> in a loop, but it keeps failing, so it takes 100% of the processor for the duration of the wait.</p>\n<p>The same thing happens in the Visual C++ 2017 library. Ignoring the overflow in <code>sleep_for()</code> because it adds the duration to the current time, it ends up calling <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms686298(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>Sleep</code></a>, which takes an unsigned 32-bit value in milliseconds.</p>\n<p>Even if it called something more flexible like <a href=\"https://msdn.microsoft.com/en-us/library/ms648412(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>NtWaitForSingleObject()</code></a> (which it might in the future), it's still only a signed 64-bit value in 100-nanosecond increments and can still overflow.</p>\n<h3>Bugs and limitations</h3>\n<p>I personally consider an overflow in the <code>&lt;chrono&gt;</code> library itself to be a bug, such as Visual C++'s implementation of <code>sleep_for()</code> in terms of <code>sleep_until()</code>. I think whatever value you give should end up untouched right up to the final conversion before calling into a platform-specific function.</p>\n<p>Once you get there though, if the platform doesn't support sleeping for the duration you're asking for, there is no real solution. As <code>&lt;chrono&gt;</code> is prohibited from throwing exceptions, I accept than overflowing is a possibility. Although this then becomes undefined behaviour, I wish implementations would be a bit more careful treating overflows, such as libstdc++'s various failings of handling EINVAL and spinning in a tight loop.</p>\n<h3>Visual C++</h3>\n<p>I'm quoting a few things from the emails I got from Billy O'Neal because they add the point of view of a standard library developer:</p>\n<blockquote>\n<p id=\"so_42638847_42657900_0\">As far as I can tell, yes. It's kind of a grey area -- no maximum allowable range is really specified for these functions, but given their nature of accepting arbitrary <code>time_point</code>/<code>duration</code>, which may be backed by some user-supplied bignum type of which the standard library has no knowledge, a conversion to some underlying <code>time_point</code>/<code>duration</code> type is essentially mandated. <code>&lt;chrono&gt;</code>'s design treats dealing with overflows as a non-goal (see <a href=\"http://en.cppreference.com/w/cpp/chrono/duration/duration_cast\" rel=\"nofollow noreferrer\"><code>duration_cast</code></a>, for example, which outright prohibits implementing \"as if infinity\" and similar).</p>\n<p id=\"so_42638847_42657900_1\">The standard [...] doesn't give us any way to report failure to convert here -- the behavior is literally undefined. We are explicitly prohibited from throwing exceptions, we have no way of reasoning about what happens if you exceed <code>LLONG_MAX</code>, and so our only possible responses are \"as if infinity\" or go directly to <code>std::terminate()</code>, do not pass go, do not collect $200.</p>\n<p id=\"so_42638847_42657900_2\">libstdc++ and libc++ are targeting platforms for which <code>system_clock</code> actually maps to something the platform understands, where Unix timestamps are the law of the land. We are not targeting such a platform, and are obligated to map to/from \"<code>DWORD</code> milliseconds\" and/or <code>FILETIME</code>.</p>\n<p id=\"so_42638847_42657900_3\">About the only thing I can think of might be a reasonable use case for this thing would be to have some kind of sentinel value which means \"infinity,\" but if we want to go there the standard should introduce a named constant and describe the behavior thereof.</p>\n<p id=\"so_42638847_42657900_4\">I'd rather solve your direct problem (wanting a time value to be a sentinel for infinity) rather than attempting to mandate overflow checking. Overflow checking when you don't know anything about the types involved can get really expensive (in both complexity and run time), but checking for a magic constant (e.g. <code>chrono::duration&lt;rep, period&gt;::max()</code> or <code>chrono::time_point&lt;clock, duration&gt;::max()</code>) should be cheap.</p>\n</blockquote>\n<p>It also looks like a future update (ABI incompatible) would make major changes to <code>&lt;thread&gt;</code> so it doesn't overflow in <code>sleep_for()</code> anymore, but it is still limited by what the Windows API supports. Something like <a href=\"https://msdn.microsoft.com/en-us/library/ms648412(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>NtWaitForSingleObject()</code></a> does support 64-bit values, but <em>signed</em>, because it supports both relative (negative) and absolute (positive) times.</p>\n<p><sup><sup>1</sup> By \"timed functions\", I mean any function for which <em>30.2.4 [thread.req.timing]</em> applies, such as <code>this_thread::sleep_for()</code> and <code>this_thread::sleep_until()</code>, but also stuff in <code>timed_mutex</code>, <code>recursive_timed_mutex</code>, <code>condition_variable</code>, etc.</sup></p>\n", "OwnerUserId": "4885801", "LastEditorUserId": "4885801", "LastEditDate": "2017-03-08T22:32:06.707", "Id": "42657900", "Score": "1", "CreationDate": "2017-03-07T20:40:10.243", "LastActivityDate": "2017-03-08T22:32:06.707"}, "bq_ids": {"n4140": {"so_42638847_42639024_0": {"section_id": 2743, "quality": 0.7777777777777778, "length": 7}, "so_42638847_42639024_2": {"section_id": 2664, "quality": 0.896551724137931, "length": 26}, "so_42638847_42639024_1": {"section_id": 2663, "quality": 0.9574468085106383, "length": 45}}, "n3337": {"so_42638847_42639024_0": {"section_id": 2704, "quality": 0.7777777777777778, "length": 7}, "so_42638847_42639024_2": {"section_id": 2628, "quality": 0.896551724137931, "length": 26}, "so_42638847_42639024_1": {"section_id": 2627, "quality": 0.9574468085106383, "length": 45}}, "n4659": {"so_42638847_42639024_0": {"section_id": 3481, "quality": 0.7777777777777778, "length": 7}, "so_42638847_42639024_2": {"section_id": 3404, "quality": 0.896551724137931, "length": 26}, "so_42638847_42639024_1": {"section_id": 3403, "quality": 0.9574468085106383, "length": 45}}}, "42639024": {"ParentId": "42638847", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Technically speaking <code>std::chrono::system_clock::durat\u200c\u200bion::max()</code> should sleep for a very long time (longer than you will or your grandchildren will live).  And the standard enforces that.</p>\n<p>But practically, implementors are still learning how to deal with overflow induced by <code>chrono</code> conversions among durations of different precisions.  So bugs are common.</p>\n<p>It might be more practical to sleep for <code>9'000h</code> (a little over a year).  There's no way this is going to cause overflow.  And it is surely \"forever\" for your application.</p>\n<p>However, don't hesitate to send a bug report to your vendor complaining that <code>std::chrono::system_clock::durat\u200c\u200bion::max()</code> doesn't work.  It should.  It is just tricky to make it work correctly.  And making it work isn't portable, so it isn't reasonable to ask you to write some wrapper to do it.</p>\n<hr>\n<p>Motivated by <a href=\"https://stackoverflow.com/users/4885801/isanae\">isanae</a>'s excellent comment below which asks for references:</p>\n<p>30.3.3 [thread.thread.this]/p7 which describes <code>sleep_for</code> says:</p>\n<blockquote>\n<p id=\"so_42638847_42639024_0\">Effects: Blocks the calling thread for the relative timeout (30.2.4) specified by <code>rel_time</code>.</p>\n</blockquote>\n<p>30.2.4 [thread.req.timing] which is a specification of all the timing requirements in the thread support library, says:</p>\n<blockquote>\n<p id=\"so_42638847_42639024_1\">2 Implementations necessarily have some delay in returning from a timeout. Any overhead in interrupt response, function return, and scheduling induces a \u201cquality of implementation\u201d delay, expressed as duration <code>D</code><sub>i</sub>. Ideally, this delay would be zero. Further, any contention for processor and memory resources induces a \u201cquality of management\u201d delay, expressed as duration <code>D</code><sub>m</sub>. The delay durations may vary from timeout to timeout, but in all cases shorter is better.</p>\n<p id=\"so_42638847_42639024_2\">3 The member functions whose names end in <code>_for</code> take an argument that specifies a duration. These functions produce relative timeouts. Implementations should use a steady clock to measure time for these functions.<sup>330</sup> Given a duration argument <code>D</code><sub>t</sub>, the real-time duration of the timeout is <code>D</code><sub>t</sub><code>+ D</code><sub>i</sub><code>+ D</code><sub>m</sub><code></code>.</p>\n</blockquote>\n<p>Ok, so now I'm amused, because we aren't talking about a member function.  We're talking about a namespace-scope function.  This is a defect.  Feel free to <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#submit_issue\" rel=\"nofollow noreferrer\">submit one</a>.</p>\n<p>But the spec provides no grace to overflow.  The spec (nearly) clearly says that the implementation can't return until <em>after</em> the specified delay.  It is vague on <em>how much</em> after, but clear on that it can't return before.</p>\n<p>If you \"bug\" STL and he isn't cooperative, just refer him to me, and we will work it out. :-)  Perhaps there is a standards bug I'm not seeing, and should be fixed.  If so, I can help you file the bug against the standard instead of against VS.  Or maybe VS has already addressed this issue, and the fix is available in an upgrade.</p>\n<p>If this is a bug in VS, please let STL know that I am more than happy to assist in fixing it.  There are different tradeoffs in addressing this issue on different platforms.</p>\n<p>At the moment, I can't swear that there isn't a bug of this class in my own implementation (libc++).  So no high-horse here.  It is a difficult area for a std::lib to get right.</p>\n<p><strong>Update</strong></p>\n<p>I've looked at the libc++ <code>sleep_for</code> and <code>sleep_until</code>.  <code>sleep_for</code> correctly handles the overflow by sleeping for a \"long time\" (as much as the OS can handle).  <code>sleep_until</code> has the overflow bug.</p>\n<p>Here is a very lightly tested fixed <code>sleep_until</code>:</p>\n<pre><code>template &lt;class _Clock, class _Duration&gt;\nvoid\nsleep_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __t)\n{\n    using namespace chrono;\n    using __ldsec = duration&lt;long double&gt;;\n    _LIBCPP_CONSTEXPR time_point&lt;_Clock, __ldsec&gt; _Max =\n                          time_point&lt;_Clock, nanoseconds&gt;::max();\n    time_point&lt;_Clock, nanoseconds&gt; __ns;\n    if (__t &lt; _Max)\n    {\n        __ns = time_point_cast&lt;nanoseconds&gt;(__t);\n        if (__ns &lt; __t)\n            __ns += nanoseconds{1};\n    }\n    else\n        __ns = time_point&lt;_Clock, nanoseconds&gt;::max();\n    mutex __mut;\n    condition_variable __cv;\n    unique_lock&lt;mutex&gt; __lk(__mut);\n    while (_Clock::now() &lt; __ns)\n        __cv.wait_until(__lk, __ns);\n}\n</code></pre>\n<p>The basic strategy is to do the overflow check using a <code>long double</code> representation which not only has a very large maximum representable value, but also uses saturation arithmetic (has an infinity).  If the input value is too big for the OS to handle, truncate it down to something the OS can handle.</p>\n<p>On some platforms it might not be desirable to resort to floating point arithmetic.  One might use <code>__int128_t</code> instead.  Or there is a more involved trick of converting to the \"least common multiple\" of the input and the native duration before doing the comparison.  That conversion will only involve division (not multiplication) and so can't overflow.  However it will not always give accurate answers for two values that are nearly equal.  But it should work well enough for this use case.</p>\n<p>For those interested in the latter (<code>lcm</code>) strategy, here is how to compute that type:</p>\n<pre><code>namespace detail\n{\n\ntemplate &lt;class Duration0, class ...Durations&gt;\nstruct lcm_type;\n\ntemplate &lt;class Duration&gt;\nstruct lcm_type&lt;Duration&gt;\n{\n    using type = Duration;\n};\n\ntemplate &lt;class Duration1, class Duration2&gt;\nstruct lcm_type&lt;Duration1, Duration2&gt;\n{\n    template &lt;class D&gt;\n    using invert = std::chrono::duration\n                   &lt;\n                       typename D::rep,\n                       std::ratio_divide&lt;std::ratio&lt;1&gt;, typename D::period&gt;\n                   &gt;;\n\n    using type = invert&lt;typename std::common_type&lt;invert&lt;Duration1&gt;,\n                                                  invert&lt;Duration2&gt;&gt;::type&gt;;\n};\n\ntemplate &lt;class Duration0, class Duration1, class Duration2, class ...Durations&gt;\nstruct lcm_type&lt;Duration0, Duration1, Duration2, Durations...&gt;\n{\n    using type = typename lcm_type&lt;\n                     typename lcm_type&lt;Duration0, Duration1&gt;::type,\n                     Duration2, Durations...&gt;::type;\n};\n\n}  // namespace detail\n</code></pre>\n<p>One can think of <code>lcm_type&lt;duration1, duration2&gt;</code> as the opposite of <code>common_type&lt;duration1, duration2&gt;</code>.  The former finds a duration which the conversion to only divides.  The latter finds a duration which the conversion to only multiplies.</p>\n</hr>", "OwnerUserId": "576911", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:21.113", "Id": "42639024", "Score": "2", "CreationDate": "2017-03-07T02:22:48.310", "LastActivityDate": "2017-03-07T22:28:34.123"}});