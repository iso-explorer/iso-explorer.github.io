post_cb({"41900490": {"ParentId": "41897427", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are potentially multiple issues here.</p>\n<ol>\n<li>You're casting away the <code>const</code>.</li>\n</ol>\n<p>In a pedantic world, this can lead to undefined behavior.  To be absolutely correct, assuming you can't change BSP_SD_WriteBlocks to take a const pointer, you would have to make a copy of the data and use a non-const pointer to your copy.  The bonus is that, in making the copy, you can solve all the other problems.  The downside is that making a copy takes time and memory.</p>\n<p>In a practical world, if you know that BSP_SD_WriteBlocks never tries to write through that pointer, you're probably fine.  But this is a big deal, so I would use a C++-style <code>const_cast&lt;&gt;</code> to make it clear that you're doing this intentionally.</p>\n<ol start=\"2\">\n<li>Alignment.</li>\n</ol>\n<p>In a pedantic world, the cast from <code>std::uint8_t *</code> to <code>std::uint32_t *</code> may not be safe, at least not portably, depending on whether you know the original pointer is suitably aligned or whether your platform allows unaligned access.  Note that the copying suggested in #1 can solve this, as you could easily ensure that your temporary buffer is suitably aligned.</p>\n<p>In a practical world, if you know that the source buffer will always be suitably aligned, which seems likely, then this isn't a big deal.  Again, though, I'd suggest a C++-style cast.  I'd also recommend an assertion that the buffer address is a multiple of the size of a std::uint32_t.</p>\n", "OwnerUserId": "1386054", "LastEditorUserId": "1386054", "LastEditDate": "2017-01-27T19:16:07.437", "Id": "41900490", "Score": "1", "CreationDate": "2017-01-27T18:16:40.563", "LastActivityDate": "2017-01-27T19:16:07.437"}, "41897885": {"ParentId": "41897427", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The trick is simply to use initially a <code>uint32_t</code> array of appropriate size (it can be dynamically allocated, see below my first idea, but not necessarily). Any object can be accessed at the byte level, so you can cast that <code>uint32_t *</code> to a <code>uint8_t *</code> and process it normally as a character buffer: you are accessing the original <code>uint32_t</code> array at the byte level which is allowed by the strict aliasing rule.</p>\n<p>When you need an <code>uint32_t *</code> just cast back. As you only accessed the original array at the byte level, the lifetime of the array has not ended and the <code>uint32_t *</code> point to a valid array.</p>\n<hr>\n<p>Older and not so good solution</p>\n<p>The trick here would be to have the buffer allocated by <code>malloc</code>. The C standard says in the part referencing the C standard library explicitely accessible from a C++ program (*): 7.20.3 Memory management functions</p>\n<blockquote>\n<p id=\"so_41897427_41897885_0\">... The pointer returned if the allocation\n  succeeds is suitably aligned so that it may be assigned to a pointer to any type of object\n  and then used to access such an object or an array of such objects in the space allocated...</p>\n</blockquote>\n<p>That means that provided <code>buffer</code> is the return value of a <code>malloc</code> call, the standard guarantees that it can safely be casted to any other pointer type.</p>\n<p>If you do not, you are in risk of an alignment problem because alignment for <code>uint32_t</code> is higher than for <code>uint8_t</code>, and using a bad aligned pointer is explicitly Undefined Behaviour.</p>\n<p>One could argue that we are violating the strict aliasing rule here. But any common implementation will be fine with it (it would break too much existing code to reject that) and the only strictly conformant way would be to use a full memcopy of the buffer... to end with the exact same sequence of bytes with a compatible alignment!</p>\n<hr>\n<p>(*) I know that C and C++ are different languages but C++ standard reference manual says in 1.2 Normative references [intro.refs]</p>\n<blockquote>\n<p id=\"so_41897427_41897885_1\">1 The following referenced documents are indispensable for the application of this document... <br/>\n  \u2014 ISO/IEC 9899:1999, Programming languages \u2014 C<br/>...<br/>\n  2 The library described in Clause 7 of ISO/IEC 9899:1999 and Clause 7 of ISO/IEC 9899:1999/Cor.1:2001\n  and Clause 7 of ISO/IEC 9899:1999/Cor.2:2003 is hereinafter called the C standard library.1\n  <br/>...</p>\n<p id=\"so_41897427_41897885_2\">1) With the qualifications noted in Clauses 18 through 30 and in C.3, the C standard library is a subset of the C++ standard\n  library.</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2017-01-27T17:54:36.033", "Id": "41897885", "Score": "1", "CreationDate": "2017-01-27T15:49:57.520", "LastActivityDate": "2017-01-27T17:54:36.033"}, "bq_ids": {"n4140": {"so_41897427_41897885_2": {"section_id": 5762, "quality": 0.875, "length": 7}}, "n3337": {"so_41897427_41897885_2": {"section_id": 5535, "quality": 0.875, "length": 7}}, "n4659": {"so_41897427_41897885_2": {"section_id": 7218, "quality": 0.875, "length": 7}}}, "41897427": {"CommentCount": "2", "ViewCount": "576", "CreationDate": "2017-01-27T15:26:41.013", "LastActivityDate": "2017-01-27T19:16:07.437", "Title": "Casting an uint8_t* to uint32_t* in c++", "PostTypeId": "1", "Id": "41897427", "Score": "0", "Body": "<p>I am trying to implement an interface function of the FATFS library. The implementation expects an uint8_t* to the data that has to be written to an internal SD card by a different library. The data should be written to the library using the function BSP_SD_WriteBlocks(uint32_t*, uint64_t, uint32_t, uint32_t). (See Below)</p>\n<pre><code>/*\n * Write data from a specific sector\n */\nint SDMMC::disk_write(const uint8_t *buffer, uint32_t sector, uint32_t count)\n{\n    int res = BSP_SD_WriteBlocks((uint32_t*)buffer, (uint64_t)sector, 512, count);\n\n    if (res == MSD_OK) {\n        return RES_OK;\n    } else {\n        return RES_ERROR;\n    }\n}\n</code></pre>\n<p>As you can see I am trying to cast an 8-bit memory address to a 32-bit memory address and don't think that this is the correct way to do so.</p>\n<p>Unfortunately, I cannot change the function arguments so the disk_write function must accept uint8_t* and the BSP_SD_WriteBlocks merely accepts uint32_t*.</p>\n<p>What is the best - and fasted way - to do so? </p>\n", "Tags": "<c++><pointers><casting><fatfs>", "OwnerUserId": "959394", "AnswerCount": "2"}});