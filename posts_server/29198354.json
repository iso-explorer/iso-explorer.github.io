post_cb({"29198354": {"ViewCount": "166", "Body": "<p>I'm in doubt about the first comment in the Example at \u00a73.4.4/3 (C++14):</p>\n<pre><code>struct Node {\n    struct Node* Next; // OK: Refers to Node at global scope\n    struct Data* Data; // OK: Declares type Data\n                       // at global scope and member Data\n};\n</code></pre>\n<p>From \u00a73.3.2/7 (see below), one concludes that the comment is correct, because the global namespace is the smallest namespace containing the declaration <code>struct Node* Next;</code>.  </p>\n<p>\u00a73.3.2/7 (my emphasis)</p>\n<blockquote>\n<p id=\"so_29198354_29198354_0\">The point of declaration of a class first declared in an\n  elaborated-type-specifier is as follows:</p>\n<ul>\n<li><p id=\"so_29198354_29198354_1\">for a declaration of the form</p>\n<p id=\"so_29198354_29198354_2\"><em>class-key attribute-specifier-seq<sub>opt</sub> identifier</em> ;</p>\n<p id=\"so_29198354_29198354_3\">the identifier is declared to be a <em>class-name</em> in the scope that\n  contains the declaration, otherwise</p></li>\n<li><p id=\"so_29198354_29198354_4\">for an <em>elaborated-type-specifier</em> of the form</p>\n<p id=\"so_29198354_29198354_5\"><em>class-key identifier</em></p>\n<p id=\"so_29198354_29198354_6\">if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a function defined in namespace scope, the <em>identifier</em> is declared as a\n  <em>class-name</em> in the namespace that contains the declaration; <strong>otherwise</strong>, except as a friend declaration, <strong>the <em>identifier</em> is declared in the smallest namespace or block scope that contains the\n  declaration</strong>. [ Note: These rules also apply within templates. \u2014end\n  note ] [ Note: Other forms of <em>elaborated-type-specifier</em> do not\n  declare a new name, and therefore must refer to an existing\n  <em>type-name</em>. See 3.4.4 and 7.1.6.3. \u2014end note ]</p></li>\n</ul>\n</blockquote>\n<p>However from \u00a73.4.4/2 (see below) I get the impression that the lookup for the name <code>Node</code> finds the injected-class-name <code>Node</code>, so it can't refer to <code>Node</code> in the global scope.</p>\n<p>\u00a73.4.4/2 (my emphasis)  </p>\n<blockquote>\n<p id=\"so_29198354_29198354_7\">If the <em>elaborated-type-specifier</em> has no <em>nested-name-specifier</em>, and\n  unless the <em>elaborated-type-specifier</em> appears in a declaration with\n  the following form:</p>\n<p id=\"so_29198354_29198354_8\"><em>class-key attribute-specifier-seq<sub>opt</sub> identifier</em> ;  </p>\n<p id=\"so_29198354_29198354_9\"><strong>the <em>identifier</em> is looked up according to 3.4.1 but ignoring any non-type names that have been declared</strong>. If the\n  <em>elaborated-type-specifier</em> is introduced by the enum keyword and this lookup does not find a previously declared <em>type-name</em>, the\n  <em>elaborated-type-specifier</em> is ill-formed. If the <em>elaborated-type-specifier</em> is introduced by the <em>class-key</em> and this lookup does not find a previously declared <em>type-name</em>, or if the\n  <em>elaborated-type-specifier</em> appears in a declaration with the form:  </p>\n<p id=\"so_29198354_29198354_10\"><em>class-key attribute-specifier-seq<sub>opt</sub> identifier</em> ;  </p>\n<p id=\"so_29198354_29198354_11\">the <em>elaborated-type-specifier</em> is a declaration that introduces the\n  <em>class-name</em> as described in 3.3.2.</p>\n</blockquote>\n", "AcceptedAnswerId": "29202693", "Title": "Where am I wrong here? The lookup for the name Node finds the injected-class-name for the struct Node", "CreationDate": "2015-03-22T18:44:46.230", "Id": "29198354", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-03-22T18:50:03.897", "LastEditorUserId": "1042389", "LastActivityDate": "2015-03-23T03:04:31.447", "Score": "1", "OwnerUserId": "1042389", "Tags": "<c++><language-lawyer><lookup><c++14>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29198354_29198354_11": {"length": 5, "quality": 0.8333333333333334, "section_id": 7124}, "so_29198354_29198354_3": {"length": 7, "quality": 1.0, "section_id": 7055}, "so_29198354_29198354_7": {"length": 7, "quality": 1.0, "section_id": 7124}, "so_29198354_29198354_0": {"length": 7, "quality": 0.875, "section_id": 7055}, "so_29198354_29198354_6": {"length": 42, "quality": 0.8235294117647058, "section_id": 7055}, "so_29198354_29198354_9": {"length": 35, "quality": 0.9722222222222222, "section_id": 7124}}, "n3337": {"so_29198354_29198354_7": {"length": 7, "quality": 1.0, "section_id": 6868}, "so_29198354_29198354_11": {"length": 5, "quality": 0.8333333333333334, "section_id": 6868}, "so_29198354_29198354_0": {"length": 7, "quality": 0.875, "section_id": 6799}, "so_29198354_29198354_9": {"length": 35, "quality": 0.9722222222222222, "section_id": 6868}, "so_29198354_29198354_3": {"length": 7, "quality": 1.0, "section_id": 6799}, "so_29198354_29198354_6": {"length": 42, "quality": 0.8235294117647058, "section_id": 6799}}, "n4659": {"so_29198354_29198354_7": {"length": 7, "quality": 1.0, "section_id": 8625}, "so_29198354_29198354_11": {"length": 5, "quality": 0.8333333333333334, "section_id": 8625}, "so_29198354_29198354_0": {"length": 7, "quality": 0.875, "section_id": 8552}, "so_29198354_29198354_9": {"length": 35, "quality": 0.9722222222222222, "section_id": 8625}, "so_29198354_29198354_3": {"length": 7, "quality": 1.0, "section_id": 8552}, "so_29198354_29198354_6": {"length": 42, "quality": 0.8235294117647058, "section_id": 8552}}}, "29202693": {"Id": "29202693", "PostTypeId": "2", "Body": "<p>The first sentence of [basic.scope.pdecl]/7 makes clear that that paragraph deals with <strong>a class first declared in an <em>elaborated-type-specifier</em></strong>; it is therefore not applicable to the <code>struct Node</code> in <code>struct Node* Next;</code>, because <code>Node</code> is not first declared in that <em>elaborated-type-specifier</em>.</p>\n<p>Instead, the unqualified name lookup for <code>Node</code> does find the <em>injected-class-name</em> (see [basic.lookup.unqual]/p1 and 7.1) rather than <code>::Node</code>. You'll need to write some rather contrived code for this to matter, though. For example:</p>\n<pre><code>struct A {};\nstruct B : private A {};\nstruct C : public B {\n    struct A m_a; // error: A is the inaccessible injected-class-name, not ::A\n    struct ::A m_a2; // OK\n};\n</code></pre>\n<p>Note that GCC accepts this code, which I believe is a bug.</p>\n", "LastActivityDate": "2015-03-23T03:04:31.447", "CommentCount": "11", "CreationDate": "2015-03-23T03:04:31.447", "ParentId": "29198354", "Score": "1", "OwnerUserId": "2756719"}, "29198765": {"Id": "29198765", "PostTypeId": "2", "Body": "<p>The passage from 3.3.2 is about declaring classes, not objects.</p>\n<p>Your declaration <code>struct Node* Next</code> cannot possibly match \"<em>class-key identifier</em>\"; the latter only matches literally half of the tokens in the former.</p>\n", "LastActivityDate": "2015-03-22T19:20:58.187", "CommentCount": "2", "CreationDate": "2015-03-22T19:20:58.187", "ParentId": "29198354", "Score": "-1", "OwnerUserId": "560648"}});