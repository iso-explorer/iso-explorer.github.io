post_cb({"5849248": {"ViewCount": "549", "Body": "<p>I heard in a talk that the keys in C++0x <em>associative containers</em> are no longer <em>mutable</em>. Before, in C++03, they have been mutable, and only the Standard's text said, that the order or keys must stay the same.</p>\n<p>Now, luckily, this is illegal:</p>\n<pre><code>std::set&lt;int&gt; ss { 2,5,1,6,8,5,8,0,2,4,9 };\nauto it = ss.find(4);\n*it = 7;  // 'ERROR: assignment of read-only location'\n</code></pre>\n<p><strong>Where is this change reflected in C++0x?</strong> I looked Final Draft, but still see that <code>find()</code> and such returns <code>iterator</code> -- that sounds modifiable. (And why this is and must be I gan guess: containers like <code>map</code> want to allow the <em>value</em> beeing modified. What exacly changed to make the <em>key</em>-part const?)</p>\n", "AcceptedAnswerId": "5849508", "Title": "Immutable set-keys in c++0x, where?", "CreationDate": "2011-05-01T15:17:43.400", "Id": "5849248", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-05-01T15:59:14.617", "Score": "3", "OwnerUserId": "472245", "Tags": "<stl><iterator><c++11><containers>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5849248_5849508_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 742}, "so_5849248_5849508_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 741}}, "n3337": {"so_5849248_5849508_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 731}, "so_5849248_5849508_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 730}}, "n4659": {"so_5849248_5849508_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 800}, "so_5849248_5849508_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 799}}}, "5849342": {"Id": "5849342", "PostTypeId": "2", "Body": "<p>Basically, <code>iterator</code> and <code>const_iterator</code> are now specified to be the same. That's the lowdown, not the technicalities, of course, but it's perfectly legal for <code>set</code> containers to typedef <code>iterator</code> as <code>const_iterator</code> in C++0x.</p>\n<p>For <code>map</code>, of course, then it was a <code>pair&lt;const K, V&gt;</code>, so it never had a problem.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2011-05-01T15:34:33.863", "Score": "1", "CreationDate": "2011-05-01T15:29:07.993", "ParentId": "5849248", "CommentCount": "3", "LastEditDate": "2011-05-01T15:34:33.863", "OwnerUserId": "298661"}, "5849508": {"Id": "5849508", "PostTypeId": "2", "Body": "<p>For your information, 23.2.4/5 in N3290 says:</p>\n<blockquote>\n<p id=\"so_5849248_5849508_0\">For <code>set</code> and <code>multiset</code> the value\n  type is the same as the key type. For\n  <code>map</code> and <code>multimap</code> it is equal to\n  <code>pair&lt;const Key, T&gt;</code>. Keys in an\n  associative container are immutable.</p>\n</blockquote>\n<p>and 23.2.4/6 says:</p>\n<blockquote>\n<p id=\"so_5849248_5849508_1\">For associative containers where the\n  value type is the same as the key\n  type, both <code>iterator</code> and\n  <code>const_iterator</code> are constant\n  iterators.<br> ...<br> Note:\n  <code>iterator</code> and <code>const_iterator</code> have\n  identical semantics in this case</br></br></p>\n</blockquote>\n<p>Does this quote solve your question?</p>\n", "LastActivityDate": "2011-05-01T15:59:14.617", "CommentCount": "6", "CreationDate": "2011-05-01T15:59:14.617", "ParentId": "5849248", "Score": "5", "OwnerUserId": "547710"}});