post_cb({"bq_ids": {"n4140": {"so_8752587_8753091_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 5485}}, "n3337": {"so_8752587_8753091_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5271}}, "n4659": {"so_8752587_8753091_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 6920}}}, "8752587": {"ViewCount": "93", "Body": "<p>I have a simple template example that is as follow:</p>\n<pre><code>template&lt;class T&gt; class A {\n   friend int f(T);\n}\n\nint main(){\n   A&lt;int&gt; a;\n   return 0;\n}\n</code></pre>\n<p>That code compile and execute without warning in VS2008 (except for the unused variable). I believe there should be a problem since we obtain many versions of a non-template function in the same class with only one definition. Did I miss something?</p>\n", "AcceptedAnswerId": "8753091", "Title": "Why VS 2008 compile with no warning with an erroneous template logic?", "CreationDate": "2012-01-06T02:09:28.580", "Id": "8752587", "CommentCount": "0", "LastEditDate": "2012-12-30T17:22:33.490", "PostTypeId": "1", "LastEditorUserId": "445746", "LastActivityDate": "2012-12-30T17:22:33.490", "Score": "1", "OwnerUserId": "445746", "Tags": "<c++><templates>", "AnswerCount": "2"}, "8752625": {"Id": "8752625", "PostTypeId": "2", "Body": "<p>According to the C++ standard, the degree of syntax checking for unused template functions is up to the implementation. The compiler does not do any semantic checking\u2014for example, symbols are not looked up. </p>\n", "LastActivityDate": "2012-01-06T02:14:49.390", "CommentCount": "3", "CreationDate": "2012-01-06T02:14:49.390", "ParentId": "8752587", "Score": "1", "OwnerUserId": "1122607"}, "8753091": {"Id": "8753091", "PostTypeId": "2", "Body": "<p>Why should this code produce an error? For every <code>T</code> you instantiate <code>A</code> with, a new function will be declared and friended. There will never be two identical functions, since you can't instantiate a template twice for the same type (you will just reuse the old instantiation). </p>\n<p>Also, even if it was somehow possible to generate two equal declarations, there would be no ambiguity, since the functions are first declared inside the class. As such, they can never be found by anything other than argument dependant lookup. (Basically, those functions are useless as they cannot be called)</p>\n<p><code>\u00a77.3.1.2 [namespace.memdef] p3</code></p>\n<blockquote>\n<p id=\"so_8752587_8753091_0\">[...] If a <code>friend</code> declaration in a nonlocal class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. <strong>The name of the friend is not found by unqualified lookup or by qualified lookup until a matching declaration is provided in that namespace scope</strong> (either before or after the class definition granting friendship). [...]</p>\n</blockquote>\n<p><a href=\"http://ideone.com/qbiRl\" rel=\"nofollow\">Also, see this</a>.</p>\n", "LastActivityDate": "2012-01-06T03:39:44.950", "CommentCount": "6", "CreationDate": "2012-01-06T03:39:44.950", "ParentId": "8752587", "Score": "1", "OwnerUserId": "500104"}});