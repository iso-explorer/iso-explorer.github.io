post_cb({"bq_ids": {"n4140": {"so_394854_394867_0": {"length": 48, "quality": 0.8421052631578947, "section_id": 473}}, "n3337": {"so_394854_394867_0": {"length": 48, "quality": 0.8421052631578947, "section_id": 464}}, "n4659": {"so_394854_394867_0": {"length": 48, "quality": 0.8421052631578947, "section_id": 496}}}, "394854": {"ViewCount": "2772", "Body": "<p>I have several classes that I don't want to be copyable, some of these classes have pointer data members. To make these classes uncopyable I privately inherit the following class template:</p>\n<pre><code>template &lt;class T&gt;\nclass Uncopyable\n{\n  protected:\n    Uncopyable() {}\n    virtual ~Uncopyable() {}\n  private:\n    Uncopyable(const Uncopyable &amp;);\n    T &amp; operator=(const T&amp;);\n};\n</code></pre>\n<p>Which I used like so:</p>\n<pre><code>class Entity : private Uncopyable&lt;Entity&gt; { }\n</code></pre>\n<p>This works fine, however when I compile with -Weffc++ I still get the following warning:</p>\n<pre><code>class Entity has pointer data members\nbut does not override Entity(const Entity&amp;)\nor operator=(const Entity&amp;)\n</code></pre>\n<p>Why is it still giving me this warning?</p>\n", "AcceptedAnswerId": "394867", "Title": "Silencing GCC warnings when using an \"Uncopyable\" class", "CreationDate": "2008-12-27T10:15:28.780", "Id": "394854", "CommentCount": "2", "LastEditDate": "2010-05-15T18:45:32.973", "PostTypeId": "1", "LastEditorUserId": "21234", "LastActivityDate": "2010-05-15T18:45:32.973", "Score": "1", "OwnerUserId": "48362", "Tags": "<c++><effective-c++>", "AnswerCount": "1"}, "394867": {"Body": "<p>C++ says</p>\n<blockquote>\n<p id=\"so_394854_394867_0\">Because a copy assignment operator is\n  implicitly declared for a class if not declared by the user, a base class copy assignment operator is always\n  hidden by the copy assignment operator of a derived class (13.5.3). A using-declaration (7.3.3) that brings\n  in from a base class an assignment operator with a parameter type that could be that of a copy-assignment\n  operator for the derived class is not considered an explicit declaration of a copy-assignment operator and\n  does not suppress the implicit declaration of the derived class copy-assignment operator; the operator introduced by the using-declaration is hidden by the implicitly-declared copy-assignment operator in the\n  derived class.</p>\n</blockquote>\n<p>The bug in the code is that your base class declares the <code>operator=</code> to accept a reference of type of the derived class. That won't prevent an implicit public declaration of an operator= for the base. Thus, your derived class <strong>and</strong> your base class are still assignable. Try changing your noncopyable class into a non-template, which should suffice:</p>\n<pre><code>class Uncopyable\n{\n  protected:\n    Uncopyable() {}\n    virtual ~Uncopyable() {}\n  private:\n    Uncopyable(const Uncopyable &amp;);\n    Uncopyable &amp; operator=(const Uncopyable&amp;);\n};\n</code></pre>\n<p>One more thing i have just figured in that code: Don't make the destructor of Uncopyable virtual. The reason is, no-one (apart from the derived class itself) can call delete on a pointer to Uncopyable (because 1: the destructor is protected, 2: you derive privately). So it's not the concern of Uncopyable to make the destructor of the derived class implicitly virtual. If the derived class needs to have a virtual destructor, put virtual in there instead, and leave Uncopyables' destructor non-virtual. </p>\n", "CreationDate": "2008-12-27T10:29:00.670", "ParentId": "394854", "CommentCount": "4", "LastEditDate": "2008-12-27T21:51:19.187", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastActivityDate": "2008-12-27T21:51:19.170", "LastEditorUserId": "15168", "Id": "394867", "OwnerDisplayName": "litb", "Score": "9", "OwnerUserId": "34509"}});