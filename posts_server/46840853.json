post_cb({"46841038": {"ParentId": "46840853", "Score": "4", "CreationDate": "2017-10-20T01:13:12.707", "Id": "46841038", "OwnerUserId": "2069064", "LastActivityDate": "2017-10-20T01:13:12.707", "Body": "<p>The wording has changed a bit, but the general idea remains the same. From <a href=\"http://eel.is/c++draft/intro.object#1.sentence-2\" rel=\"nofollow noreferrer\">intro.object</a>:</p>\n<blockquote>\n<p id=\"so_46840853_46841038_0\">An <em>object</em> is created by a definition, by a <em>new-expression</em>, when implicitly changing the active member of a union, or when a temporary object is created ([conv.rval], [class.temporary]).</p>\n</blockquote>\n<p>Those are the <em>only</em> four ways to create an object in C++. <code>memcpy</code> does not fall into any of those four conditions and hence it does not now (and never has before) create lifetime (implicitly changing the active member of a union can be done <a href=\"http://eel.is/c++draft/class.union#5\" rel=\"nofollow noreferrer\">via <code>=</code> only</a>, not via <code>memcpy</code>). </p>\n<p>The quote refers to a hypothetical future change to the standard that would bless <code>memcpy</code> with such ability in certain situations. There was a <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/rt2ivJnc4hg/Lr541AYgCQAJ\" rel=\"nofollow noreferrer\">very long thread</a> on the subject earlier in the year as well. </p>\n", "PostTypeId": "2", "CommentCount": "2"}, "46840853": {"Tags": "<c++><language-lawyer><c++1z><memcpy>", "ViewCount": "105", "LastEditDate": "2017-10-20T00:51:07.163", "CreationDate": "2017-10-20T00:43:48.760", "LastEditorUserId": "149138", "Title": "What are the changes, if any, to the memcpy lifetime initalization rules in the new standard?", "CommentCount": "1", "AnswerCount": "1", "Score": "2", "OwnerUserId": "149138", "Id": "46840853", "LastActivityDate": "2017-10-20T01:13:12.707", "Body": "<p>As far as I am aware, <code>memcpy</code> into uninitialized storage <a href=\"https://stackoverflow.com/q/30114397/149138\">cannot</a> safely be used to create an copy of the source object.</p>\n<p>However, in <a href=\"http://www.open-std.org/pipermail/ub/2016-January/000546.html\" rel=\"nofollow noreferrer\">this thread</a> from last year on the open-std WG21 \"ub\" list, a participant refers to <em>the new memcpy lifetime-initiation rules</em>:</p>\n<blockquote>\n<p id=\"so_46840853_46840853_0\">This doesn\u2019t seem to rise to the level of a bug report, but it might\n  be relevant to the new memcpy lifetime-initiation rules. Will they\n  ascribe some static type to the source and destination bytes?</p>\n</blockquote>\n<p>Based on the context of the question and small amount of type-erasure example code, it appears that it may be related to creating new objects in <code>aligned_storage</code> via <code>memcpy</code>.</p>\n<p>Search as I might, I can't find a reference to the new rules. I'm particularly curious if they only apply to replacing the contents of an already created object, or if they change the situation around the potential creation of an object in uninitialized memory.</p>\n", "PostTypeId": "1", "FavoriteCount": "1"}, "bq_ids": {"n4659": {"so_46840853_46841038_0": {"length": 13, "section_id": 7247, "quality": 0.8125}}}});