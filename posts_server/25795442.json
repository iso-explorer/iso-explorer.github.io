post_cb({"bq_ids": {"n4140": {"so_25795442_25795685_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 3295}, "so_25795442_25795685_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 3294}, "so_25795442_25795685_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 389}}, "n3337": {"so_25795442_25795685_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 3165}, "so_25795442_25795685_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 3164}, "so_25795442_25795685_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 380}}, "n4659": {"so_25795442_25795685_4": {"length": 10, "quality": 0.5555555555555556, "section_id": 4057}, "so_25795442_25795685_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 4056}, "so_25795442_25795685_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 406}}}, "25795685": {"Id": "25795685", "PostTypeId": "2", "Body": "<p>The syntax <code>Vector c = a;</code> you are using is called a <strong>copy-initialization</strong>:</p>\n<blockquote>\n<h3>\u00a7 8.5 Initializers <code>[dcl.init]</code> / p15</h3>\n<p id=\"so_25795442_25795685_0\">The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_25795442_25795685_1\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called <strong>copy-initialization.</strong></p>\n</blockquote>\n<p>The problem is, your copy constructor is marked as <code>explicit</code>:</p>\n<blockquote>\n<h3>\u00a7 12.3.1 Conversion by constructor <code>[class.conv.ctor]</code> / p2</h3>\n<p id=\"so_25795442_25795685_2\">An explicit constructor constructs objects just like non-explicit constructors, but does so <strong>only where the\n  direct-initialization syntax</strong> (8.5) or where casts (5.2.9, 5.4) are explicitly used.</p>\n</blockquote>\n<p>And what is a <em>direct-initialization</em>?</p>\n<blockquote>\n<h3>\u00a7 8.5 Initializers <code>[dcl.init]</code> / p16</h3>\n<p id=\"so_25795442_25795685_3\">The initialization that occurs in the forms</p>\n<pre><code>T x(a);\nT x{a};\n</code></pre>\n<p id=\"so_25795442_25795685_4\">as well as in new expressions (5.3.4), static_cast expressions (5.2.9), functional notation type conversions\n  (5.2.3), and base and member initializers (12.6.2) is called <strong>direct-initialization.</strong></p>\n</blockquote>\n<p>Please change your copy-constructor declaration from:</p>\n<pre><code>explicit Vector(const Vector&amp; src);\n</code></pre>\n<p>into:</p>\n<pre><code>Vector(const Vector&amp; src);\n</code></pre>\n<p>if you want to utilize the copy constructor using a copy-initialization syntax.</p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-28T15:21:32.423", "Score": "3", "CreationDate": "2014-09-11T19:37:17.640", "ParentId": "25795442", "CommentCount": "0", "OwnerUserId": "3953764", "LastEditDate": "2015-06-28T15:21:32.423"}, "25795490": {"Id": "25795490", "PostTypeId": "2", "Body": "<p>That is actually calling the copy assignment operator, not the copy constructor.</p>\n<p>You can make one by defining void <code>Vector::operator=(const Vector&amp; param);</code></p>\n", "LastEditorUserId": "426662", "LastActivityDate": "2015-01-05T09:36:17.503", "Score": "-1", "CreationDate": "2014-09-11T19:20:53.400", "ParentId": "25795442", "CommentCount": "2", "OwnerUserId": "4032370", "LastEditDate": "2015-01-05T09:36:17.503"}, "25795442": {"ViewCount": "144", "Body": "<p>I am implementing a <code>Vector</code> class. These are my source files.</p>\n<p><code> vector.h </code></p>\n<pre><code>#ifndef VECTOR_H\n#define VECTOR_H\n\nclass Vector\n{\n public:\n    Vector();\n    explicit Vector(const Vector&amp; src);\n};\n#endif // VECTOR_H\n</code></pre>\n<p><code> vector.cpp </code></p>\n<pre><code>#include \"vector.h\"\n\nVector::Vector()\n{\n}\n\nVector::Vector(const Vector &amp;src)\n{\n}\n</code></pre>\n<p>And the test program, <code> main.cpp</code></p>\n<pre><code>#include \"vector.h\"\nint main()\n{\n   Vector a;      // calls default constructor\n   Vector b(a);   // calls copy-constructor, compiles and works fine\n   Vector c = a;  // should call copy-constructor, but does not compile\n   return 0;\n}\n</code></pre>\n<p>When compiling, I get the following error: <code>\"no matching function for call to 'Vector::Vector(Vector&amp;)'\" </code>.</p>\n<p>What can be going wrong here?</p>\n<p>EDIT: Added the complete code for a minimum working example.\nThanks!</p>\n", "Title": "Copy-constructor c++: compiler can't find it when using a = b", "CreationDate": "2014-09-11T19:17:40.897", "LastActivityDate": "2015-06-28T15:21:32.423", "CommentCount": "6", "LastEditDate": "2014-09-11T19:35:42.847", "PostTypeId": "1", "LastEditorUserId": "1011113", "Id": "25795442", "Score": "0", "OwnerUserId": "1011113", "Tags": "<c++><c++11><copy-constructor>", "AnswerCount": "2"}});