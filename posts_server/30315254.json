post_cb({"30315254": {"CommentCount": "0", "AcceptedAnswerId": "30315317", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2015-05-19T01:19:27.253", "LastActivityDate": "2015-05-19T01:53:00.857", "LastEditDate": "2015-05-19T01:41:29.217", "ViewCount": "44", "FavoriteCount": "1", "Title": "Constructing a value through two implicit constructors?", "Id": "30315254", "Score": "3", "Body": "<p><strong>TLDR</strong>: I have two templatized classes <code>Outer</code> and <code>Inner</code>. <code>Inner&lt;X&gt;</code> can be implicitly constructed from <code>X</code>, and <code>Outer&lt;Y&gt;</code> can be implicitly constructed from <code>Y</code>. Should <code>Outer&lt;Inner&lt;X&gt;&gt; = X()</code> work?</p>\n<p><strong>More details:</strong></p>\n<p>Suppose I have the following two classes:</p>\n<pre><code>template&lt;typename T&gt; \nclass Inner {\n  public: \n    Inner(const T&amp; value) {}\n    Inner(T&amp;&amp; value) {}\n};\n\ntemplate&lt;typename T&gt;\nclass Outer {\n  public:\n    Outer(const T&amp; value) {}\n    Outer(T&amp;&amp; value) {}\n};\n</code></pre>\n<p>Consider the following function:</p>\n<pre><code>struct SomeType{};\nOuter&lt;Inner&lt;SomeType&gt;&gt; DoSomethingFails() {\n  SomeType value;\n  return value;      \n}\n</code></pre>\n<p>g++ complains:</p>\n<pre><code>no viable conversion from 'SomeType' to 'Outer&lt;Inner&lt;SomeType&gt; &gt;'\nnote: candidate constructor not viable: no known conversion from 'SomeType' to 'const Inner&lt;SomeType&gt; &amp;' for 1st argument\n</code></pre>\n<p>But if I do the following instead:</p>\n<pre><code>Outer&lt;Inner&lt;SomeType&gt;&gt; DoSomethingWorks() {\n  SomeType value;\n  return Inner&lt;SomeType&gt;(value);      \n}\n</code></pre>\n<p>It works. Is it reasonable to expect <code>DoSomethingFails</code> to work? If not, why? And can the code be changed in a way that <code>DoSomethingFails</code> works?</p>\n", "Tags": "<c++><constructor><implicit>", "OwnerUserId": "4914214", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30315254_30315317_0": {"section_id": 383, "quality": 0.8695652173913043, "length": 20}, "so_30315254_30315317_1": {"section_id": 386, "quality": 1.0, "length": 11}}, "n3337": {"so_30315254_30315317_0": {"section_id": 374, "quality": 0.8695652173913043, "length": 20}, "so_30315254_30315317_1": {"section_id": 377, "quality": 1.0, "length": 11}}, "n4659": {"so_30315254_30315317_0": {"section_id": 400, "quality": 0.8695652173913043, "length": 20}, "so_30315254_30315317_1": {"section_id": 403, "quality": 1.0, "length": 11}}}, "30315317": {"ParentId": "30315254", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your first example requires two user defined conversions to compile \u2014 <code>SomeType -&gt; Inner -&gt; Outer</code>. However, at most one user defined conversion can be applied implicitly.</p>\n<p>Quoting N3337, <em>\u00a712.3 [class.conv]</em></p>\n<blockquote>\n<p id=\"so_30315254_30315317_0\">1 \u00a0 Type conversions of class objects can be specified by constructors and by conversion functions. These conversions are called user-defined conversions and are used for implicit type conversions (Clause 4), for initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n<p id=\"so_30315254_30315317_1\">4 \u00a0 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value.</p>\n</blockquote>\n<hr>\n<p>If the goal is to avoid having to mention <code>Inner&lt;SomeType&gt;</code> in the return statement, you can use list initialization.</p>\n<pre><code>Outer&lt;Inner&lt;SomeType&gt;&gt; DoSomethingWorks2() {\n  SomeType value;\n  return {std::move(value)};\n}\n</code></pre>\n</hr>", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2015-05-19T01:53:00.857", "Id": "30315317", "Score": "6", "CreationDate": "2015-05-19T01:27:59.670", "LastActivityDate": "2015-05-19T01:53:00.857"}});