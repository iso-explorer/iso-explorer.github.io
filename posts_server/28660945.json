post_cb({"bq_ids": {"n4140": {"so_28660945_28661719_0": {"length": 6, "quality": 1.0, "section_id": 3271}}, "n3337": {"so_28660945_28661719_0": {"length": 6, "quality": 1.0, "section_id": 3143}}, "n4659": {"so_28660945_28661719_0": {"length": 6, "quality": 1.0, "section_id": 4029}}}, "28660945": {"ViewCount": "1064", "Body": "<p>Especially in connection with <code>std::vector</code> it is important that types are <code>noexcept</code> movable when possible.</p>\n<p>So when declaring a move constructor <code>= default</code> like in</p>\n<pre><code>struct Object1\n{\n    Object1(Object1 &amp;&amp;other) = default;\n};\n</code></pre>\n<p><code>std::is_nothrow_move_constructible&lt;Object1&gt;::value</code> will be <code>true</code> as every member (0 here) of <code>Object1</code> is nothrow-move-constructible, which is answered <a href=\"https://stackoverflow.com/questions/18290523/does-a-default-move-constructor-equals-to-a-member-wise-move-constructor\">here</a>.</p>\n<p>Yet what happens if the move copy constructor is only declared and then later <code>= default</code> defined like in the following code?</p>\n<pre><code>struct Object2\n{\n    Object2(Object2 &amp;&amp;other);\n};\nObject2::Object2(Object2 &amp;&amp;other) = default;\n</code></pre>\n<p>With g++ 4.9.2 <code>std::is_nothrow_move_constructible&lt;Object2&gt;::value</code> is <code>false</code> and I have to mark both the declaration and the definition as <code>noexcept</code> to make it <code>true</code>.</p>\n<p>Now what I am interested in is what the actual rules are.\nEspecially since Item 22 in <a href=\"http://rads.stackoverflow.com/amzn/click/1491903996\" rel=\"nofollow noreferrer\">Effective Modern C++</a> (Scott Meyers) seems to give ill advice by suggesting to implement the pimpl-idiom move constructor like I did with <code>Object2</code>.</p>\n", "AcceptedAnswerId": "28661719", "Title": "What are the rules for noexcept on default defined move constructors?", "CreationDate": "2015-02-22T17:33:59.717", "Id": "28660945", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:02:22.183", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-22T19:15:02.793", "Score": "14", "OwnerUserId": "3893186", "Tags": "<c++><c++11><move-semantics><pimpl-idiom><noexcept>", "AnswerCount": "1"}, "28661719": {"Id": "28661719", "PostTypeId": "2", "Body": "<p>[dcl.fct.def.default]/p2:</p>\n<blockquote>\n<p id=\"so_28660945_28661719_0\">If a function is explicitly defaulted on its first declaration,</p>\n<ul>\n<li>it is implicitly considered to be <code>constexpr</code> if the implicit declaration would be, and,</li>\n<li>it has the same exception specification as if it had been implicitly declared (15.4).</li>\n</ul>\n</blockquote>\n<p>These rules do not apply if the function is explicitly defaulted on a later declaration, as in your later example, so instead, except for destructors, the function is considered <code>noexcept(false)</code> by default like most other functions.</p>\n<p>Since the explicit defaulting can be in a different translation unit - and in the pimpl case, <em>is</em> in a different TU - there's no general way for the compiler to figure out after seeing the class definition only whether the move constructor will throw, unless the function is explicitly defaulted in the class definition (i.e., at its first declaration).</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-02-22T19:15:02.793", "Score": "10", "CreationDate": "2015-02-22T18:41:21.607", "ParentId": "28660945", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2015-02-22T19:15:02.793"}});