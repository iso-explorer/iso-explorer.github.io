post_cb({"32770395": {"CommentCount": "1", "ViewCount": "63", "OwnerDisplayName": "John Kar", "CreationDate": "2015-09-24T20:00:03.377", "LastActivityDate": "2015-09-25T01:08:23.033", "PostTypeId": "1", "AcceptedAnswerId": "32773247", "Title": "mutex.try_lock() lets multiple threads hold the lock simultaneously", "Id": "32770395", "Score": "0", "Body": "<p>After hours tearing my hair out, it appears I've been savagely mauled by unexpected behaviour from c++11's <code>unique_lock</code>.  I must have horribly misunderstood something :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n\n#define N_THREADS 4\n#define N_ITERATIONS 10000\n#define N_LOOPS 1000000\n\nclass ThingMaJigger\n{\npublic:\n    void fight()    {\n        if(m.try_lock()) {\n            // more then one thread ends up here??!?!?\n            printf(\"I'm the winner!\\n\" );\n            m.unlock();\n        } else {\n            printf(\"Sleeping \\n\" );\n        }\n    }\nprivate:\n    std::mutex m;\n};\n\nvoid worker(ThingMaJigger* ar,int tIdx)\n{\n    ar-&gt;fight();\n}\n\nint main(int argc, char const *argv[])\n{\n    for (int _loop = 0; _loop &lt; N_LOOPS; ++_loop) {\n        std::vector&lt;std::thread&gt; ts;\n        ThingMaJigger t;\n        for (int i = 0; i &lt; N_THREADS; ++i)\n        {\n            ts.emplace_back(worker,&amp;t,i);\n        }\n\n        for (int i = 0; i &lt; N_THREADS; ++i)\n        {\n            ts[i].join();\n        }\n\n        printf(\"\\n\");\n\n    }\n        return 0;\n}\n</code></pre>\n<p>Compile with <code>clang++ -std=c++11 -O2 -lpthread ./unique_lock.cpp</code></p>\n<p>clang 3.7.0, g++ 5.1.1, both behave in the same way.</p>\n<h1>Example output:</h1>\n<pre><code>I'm the winner!\nSleeping \nSleeping \nI'm the winner!\n\nI'm the winner!\nSleeping \nI'm the winner!\nSleeping \n\nI'm the winner!\nI'm the winner!\nSleeping \nSleeping \n</code></pre>\n<p>Kinda looks like multiple workers holding the same lock\nat the same time, don't it?</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/thread/mutex/try_lock\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/thread/mutex/try_lock</a> says:</p>\n<blockquote>\n<h3>Return value</h3>\n<p id=\"so_32770395_32770395_0\">true if the lock was acquired successfully, otherwise false. </p>\n</blockquote>\n<p>Note: <code>try_lock</code> is allowed to return false even if no one else \nhas the lock. That's not what this is about.</p>\n", "Tags": "<concurrency><c++11>", "OwnerUserId": "5377312", "AnswerCount": "2"}, "32773247": {"ParentId": "32770395", "CommentCount": "1", "Body": "<p>This is working as intended.</p>\n<p>Immediately after printing \"I'm the winner,\" you're unlocking the lock.  This gives the other threads a chance to acquire it as well.</p>\n<p>If you want only one thread to \"win,\" you should also have a variable indicating whether someone has won yet.  Set it to false before creating the threads.  Any thread which acquires the lock sucessfully checks that variable to see if anyone else has won.</p>\n<pre><code>bool somebodyWon = false; // make sure this is set to false before\n                          // threads get created\n\n    if(m.try_lock()) {\n        if (somebodyWon) {\n            printf(\"Darn, someone beat me to it!\\n\");\n        } else {\n            printf(\"I'm the winner!\\n\");\n            somebodyWon = true;\n        }\n        m.unlock();\n    } else {\n        printf(\"I didn't even get a chance! \\n\" );\n    }\n</code></pre>\n<p>The other approach, which is also legal, is to change from using a mutex to a semaphore so that one thread can lock the object, but let the parent thread release it after all threads have joined.</p>\n", "OwnerUserId": "2728148", "PostTypeId": "2", "Id": "32773247", "Score": "3", "CreationDate": "2015-09-25T01:08:23.033", "LastActivityDate": "2015-09-25T01:08:23.033"}, "32770396": {"ParentId": "32770395", "CommentCount": "0", "Body": "<p>Conccurency is confusing. Let's go shopping!</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;unistd.h&gt;\n\n#define N_THREADS 4\n#define N_ITERATIONS 10000\n#define N_LOOPS 1000000\n\nclass ThingMaJigger\n{\npublic:\n    void fight()    {\n        if(m.try_lock()) {\n            // more then one thread ends up here??!?!?\n            printf(\"I'm the winner!\\n\");\n            usleep(1000000); // &lt;&lt;&lt;&lt; this. \n                             // or can unlock() before other's try_lock()\n            m.unlock();\n        } else {\n            printf(\"Sleeping \\n\" );\n        }\n    }\nprivate:\n    std::mutex m;\n};\n\nvoid worker(ThingMaJigger* ar,int tIdx)\n{\n    ar-&gt;fight();\n}\n\nint main(int argc, char const *argv[])\n{\n    for (int _loop = 0; _loop &lt; N_LOOPS; ++_loop) {\n        std::vector&lt;std::thread&gt; ts;\n        ThingMaJigger t;\n        for (int i = 0; i &lt; N_THREADS; ++i)\n        {\n            ts.emplace_back(worker,&amp;t,i);\n        }\n\n        for (int i = 0; i &lt; N_THREADS; ++i)\n        {\n            ts[i].join();\n        }\n\n        printf(\"\\n\");\n\n    }\n        return 0;\n}\n</code></pre>\n", "OwnerUserId": "5377312", "Id": "32770396", "PostTypeId": "2", "OwnerDisplayName": "John Kar", "Score": "0", "CreationDate": "2015-09-24T20:03:24.683", "LastActivityDate": "2015-09-24T20:03:24.683"}, "bq_ids": {"n4140": {"so_32770395_32770395_0": {"section_id": 2681, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_32770395_32770395_0": {"section_id": 2643, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_32770395_32770395_0": {"section_id": 3421, "quality": 0.7142857142857143, "length": 5}}}});