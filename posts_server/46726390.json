post_cb({"46742542": {"ParentId": "46726390", "PostTypeId": "2", "CommentCount": "19", "Body": "<p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.inline\" rel=\"nofollow noreferrer\">[dcl.inline]/6</a> states:</p>\n<blockquote>\n<p id=\"so_46726390_46742542_0\">If a function or variable with external linkage is declared inline in\n  one translation unit, it shall be declared inline in all translation\n  units in which it appears; no diagnostic is required.</p>\n</blockquote>\n<p>So as you pointed out, <em>if</em> we can show that <code>constexpr</code> implicitly implies <code>inline</code>, it would explain the undefined reference error of your example.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/dcl.constexpr\" rel=\"nofollow noreferrer\">[dcl.constexpr]/1</a> states [emphasis mine]:</p>\n<blockquote>\n<p id=\"so_46726390_46742542_1\">The constexpr specifier shall be applied <strong>only to the definition</strong> of\n  a variable or variable template or the declaration of a function or\n  function template.</p>\n</blockquote>\n<p>As well as:</p>\n<blockquote>\n<p id=\"so_46726390_46742542_2\">A function or static data member declared with the constexpr specifier\n  is implicitly an inline function or variable (<a href=\"https://timsong-cpp.github.io/cppwp/dcl.inline\" rel=\"nofollow noreferrer\">[dcl.inline]</a>).</p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/basic.def\" rel=\"nofollow noreferrer\">[basic.def]/1</a> states [emphasis mine]:</p>\n<blockquote>\n<p id=\"so_46726390_46742542_3\">A declaration may introduce one or more names into a translation unit\n  <strong>or redeclare names introduced by previous declarations</strong>.</p>\n</blockquote>\n<p>as well as (/2):</p>\n<blockquote>\n<p id=\"so_46726390_46742542_4\">A declaration is a definition unless:</p>\n<p id=\"so_46726390_46742542_5\">[... none applies for <code>constexpr int const S::i = 42;</code>]</p>\n</blockquote>\n<p>The essence here being that definitions <em>are declarations</em> (that fully define the entity introduced by the declaration), so <code>constexpr int const S::i = 42;</code> is also (in addition to being a definition) a (re-)declaration, in which case [dcl.constexpr]/1 applies, and <code>S::i</code> is inline in the translation unit of <code>S.cpp</code>, ergo, by [dcl.inline]/6, in all other translations units in which it appears. Conversely, by [dcl.constexpr]/1, the <code>constexpr</code> specifier, e.g. specifically in this context of static data members, can only appear in declarations that are definitions.</p>\n<p>Somewhat relevant in the context of the latter is that a <code>constexpr</code> static data member declaration with initialization is, also, as of C++17, a definition, allowing for the specification that <code>constexpr</code> shall only be applied to the variable definition (i.e., never to a non-initializing declaration). See <a href=\"https://timsong-cpp.github.io/cppwp/depr.static_constexpr\" rel=\"nofollow noreferrer\">[depr.static_constexpr]/1</a>.</p>\n", "OwnerUserId": "4573247", "LastEditorUserId": "4573247", "LastEditDate": "2017-10-14T08:59:18.960", "Id": "46742542", "Score": "0", "CreationDate": "2017-10-14T08:35:56.023", "LastActivityDate": "2017-10-14T08:59:18.960"}, "46727446": {"ParentId": "46726390", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_46726390_46727446_0\">Yet the definition of S::i seems to have internal linkage in C++17\n  mode as if constexpr means inline. Is this correct? If so where is the\n  proof in the standard?</p>\n</blockquote>\n<p>Yes, it is correct. <a href=\"http://en.cppreference.com/w/cpp/language/inline\" rel=\"nofollow noreferrer\">cppreference</a> :</p>\n<blockquote>\n<p id=\"so_46726390_46727446_1\">The inline specifier, when used in a decl-specifier-seq of a variable\n  with static storage duration (static class member or namespace-scope\n  variable), declares the variable to be an inline variable.</p>\n<p id=\"so_46726390_46727446_2\"><strong>A static member variable (but not a namespace-scope variable) declared constexpr is implicitly an inline variable.</strong> <strong>(since C++17)</strong></p>\n</blockquote>\n", "OwnerUserId": "6935629", "PostTypeId": "2", "Id": "46727446", "Score": "1", "CreationDate": "2017-10-13T10:08:12.573", "LastActivityDate": "2017-10-13T10:08:12.573"}, "46726390": {"CommentCount": "0", "ViewCount": "127", "PostTypeId": "1", "LastEditorUserId": "8731417", "CreationDate": "2017-10-13T09:12:44.733", "LastActivityDate": "2017-10-15T09:04:05.687", "Title": "constexpr defining static data member of literal type that is declared const", "LastEditDate": "2017-10-15T09:04:05.687", "Id": "46726390", "Score": "0", "Body": "<p>I  have a question about constexpr defining a static data member of literal type that is declared const (and not specified inline or constexpr) in the class definition:</p>\n<p>// S.h</p>\n<pre><code>struct S\n{\n  static int const i; // not specified inline or constexpr\n};\n</code></pre>\n<p>// S.cpp</p>\n<pre><code>#include \"S.h\"\nconstexpr int const S::i = 42; // definition, not declaration\n</code></pre>\n<p>// main.cpp</p>\n<pre><code>#include \"S.h\"\nint main()\n{\n  return S::i;\n}\n</code></pre>\n<p>Clang/gcc return 42 in C++11/14 mode, but report an error (undefined reference to S::i) in C++17 mode. If I comment out constexpr both return 42 in C++17 mode, too.</p>\n<p>S::i has external linkage because S has external linkage. S::i is not declared constexpr and so (if I'm not mistaken) C++17 10.1.5 p1 does not apply:</p>\n<blockquote>\n<p id=\"so_46726390_46726390_0\">A function or static data member declared with the constexpr\n  specifier is implicitly an inline function or variable</p>\n</blockquote>\n<p>I understand this sentence as if it means (bold my understanding):\nA static data member declared with the constexpr specifier <strong>in the class definition</strong> is implicitly an inline variable</p>\n<p>S::i is thus not an inline variable.\nYet the definition of S::i seems to have internal linkage in C++17 mode as if constexpr means inline. Is this correct? If so where is the proof in the standard?</p>\n<p>Or do I misunderstand 10.1.5 p1 and it really means (bold my misunderstanding):\nA static data member declared with the constexpr specifier <strong>in the class definition and the definition in namespace scope</strong> is implicitly an inline variable?</p>\n", "Tags": "<c++><gcc><clang><c++1z>", "OwnerUserId": "8731417", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_46726390_46742542_0": {"section_id": 5404, "quality": 0.9411764705882353, "length": 16}, "so_46726390_46742542_3": {"section_id": 7033, "quality": 1.0, "length": 14}, "so_46726390_46742542_1": {"section_id": 5417, "quality": 0.9166666666666666, "length": 11}, "so_46726390_46726390_0": {"section_id": 48, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_46726390_46742542_0": {"section_id": 5199, "quality": 0.9411764705882353, "length": 16}, "so_46726390_46742542_3": {"section_id": 6779, "quality": 1.0, "length": 14}, "so_46726390_46742542_1": {"section_id": 5212, "quality": 0.8333333333333334, "length": 10}, "so_46726390_46726390_0": {"section_id": 254, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_46726390_46742542_2": {"section_id": 6839, "quality": 0.9166666666666666, "length": 11}, "so_46726390_46742542_0": {"section_id": 6853, "quality": 1.0, "length": 17}, "so_46726390_46742542_3": {"section_id": 8530, "quality": 1.0, "length": 14}, "so_46726390_46742542_1": {"section_id": 6839, "quality": 0.9166666666666666, "length": 11}, "so_46726390_46727446_2": {"section_id": 6839, "quality": 0.5384615384615384, "length": 7}, "so_46726390_46726390_0": {"section_id": 6839, "quality": 1.0, "length": 11}}}});