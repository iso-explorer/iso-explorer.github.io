post_cb({"bq_ids": {"n4140": {"so_25524668_25525214_1": {"section_id": 7223, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_25524668_25525214_1": {"section_id": 6967, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_25524668_25525214_1": {"section_id": 8732, "quality": 0.6363636363636364, "length": 7}}}, "25525214": {"ParentId": "25524668", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>C has a hard requirement that all pointers to all structure types have the same representation and alignment.</p>\n<blockquote>\n<p id=\"so_25524668_25525214_0\"><strong>6.2.5 Types</strong></p>\n<p id=\"so_25524668_25525214_1\">27 [...] All pointers to structure types shall have the same representation and alignment requirements as each other. [...]</p>\n</blockquote>\n<p>C++ effectively requires binary compatibility with a C implementation, because of the standard's requirements for <code>extern \"C\"</code>, so indirectly, this requires all pointers to structure types that are valid in C (POD types, pretty much) to have the same representation and alignment in C++ too.</p>\n<p>No such requirement seems to have been made for non-POD types, so an implementation would be allowed to use different pointer sizes in that case. You suggest that that cannot work, but to follow your example,</p>\n<pre><code>struct G { };\nstruct H : G { };\n\nstruct W\n{\n  virtual G* f() { ... }\n};\nstruct X : W\n{\n  virtual H* f() { ... }\n};\n</code></pre>\n<p>could be translated to (pseudo-code)</p>\n<pre><code>struct W\n{\n  virtual G* f() { ... }\n};\nstruct X : W\n{\n  override G* f() { ... }\n  inline H* __X_f() { return static_cast&lt;H *&gt;(f()); }\n};\n</code></pre>\n<p>which would still match the requirements of the language.</p>\n<p>A valid reason why two pointers to structure types might not be identical is when a C++ compiler would be ported to a platform that has an existing C compiler with a poorly-designed ABI. <code>G</code> is a POD type, so <code>G *</code> needs to be exactly what it is in C. <code>H</code> is not a POD type, so <code>H *</code> does not need to match any C type.</p>\n<p>For alignment, that can actually happen: something that really happened is that the x86-32 ABI on a typical GNU/Linux system requires 64-bit integer types to be 32-bit aligned, even though the processor's preferred alignment is actually 64-bit. Now comes another implementer, and they decide that they do want to require 64-bit alignment, but are stuck if they want to remain compatible with the existing implementation.</p>\n<p>For sizes, I cannot think of a reasonable scenario in which it would happen, but I am unsure whether that might be a lack of imagination on my part.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2014-08-27T13:52:59.530", "Id": "25525214", "Score": "4", "CreationDate": "2014-08-27T10:49:44.903", "LastActivityDate": "2014-08-27T13:52:59.530"}, "25524907": {"ParentId": "25524668", "CommentCount": "0", "Body": "<p>As far as I understand C and C++ assume memory to be linearly byte addressable. Certain platforms (early ARM) however insist on word aligned loads and stores. In such a case, it is the compiler's responsibility to round the pointer to the word boundary and then perform the necessary bit shift operations when fetching say a char.</p>\n<p>But since this is all done only on loads and stores, all pointers still all look the same.</p>\n", "OwnerUserId": "232918", "PostTypeId": "2", "Id": "25524907", "Score": "0", "CreationDate": "2014-08-27T10:35:38.773", "LastActivityDate": "2014-08-27T10:35:38.773"}, "25524668": {"CommentCount": "3", "AcceptedAnswerId": "25525214", "PostTypeId": "1", "LastEditorUserId": "923854", "CreationDate": "2014-08-27T10:24:04.393", "LastActivityDate": "2014-08-27T13:52:59.530", "LastEditDate": "2014-08-27T11:05:26.247", "ViewCount": "189", "FavoriteCount": "2", "Title": "Can size of pointers to non-union classes differ?", "Id": "25524668", "Score": "7", "Body": "<p>I understand there are HW platforms where you need more information to point to a <code>char</code> than you need to point to an <code>int</code> (the platform having non-addressable bytes, so a pointer to <code>char</code> needs to store a pointer to a word and also an index of a byte in the word). So it is possible that <code>sizeof(int*) &lt; sizeof(char*)</code> on such platforms.</p>\n<p>Can something similar happen with pointers to non-union classes? C++ allows covariant returns types on virtual functions. Let's say we have classes like this:</p>\n<pre><code>struct Gadget\n{\n  // some content\n};\n\n\nstruct Widget\n{\n  virtual Gadget* getGadget();\n};\n</code></pre>\n<p>Any code which calls <code>getGadget()</code> has to work when receiving a <code>Gadget*</code>, but the same code (actually the same <em>compiled binary</em> code) has to work when it receives a pointer to a type derived from <code>Gadget</code> as well (perhaps one which is defined in a totally different library). The only way I can reasonably see this happening is <code>sizeof(T*) == sizeof(U*)</code> for all non-union class types <code>T</code> and <code>U</code>.</p>\n<p>So my question is, given one particular <em>practical</em> compiler (that excludes hypothetical Hell++) on one particular platform, is it reasonable to expect that all pointers to non-union class types will be of the same size? Or is there a <em>practical</em> reason why a compiler might want to use different sizes while remaining compliant with covariant return types?</p>\n<p>On platforms where different \"levels\" of pointer exist (such as <code>__near</code> and <code>__far</code>), assume the <em>same</em> attribute applied to both.</p>\n", "Tags": "<c++><pointers><sizeof><language-lawyer>", "OwnerUserId": "1782465", "AnswerCount": "2"}});