post_cb({"2726165": {"Id": "2726165", "PostTypeId": "2", "Body": "<p>You don't.</p>\n<p><code>this</code> is a <code>Foo* const</code>, meaning it is a <code>const</code> pointer to a non-<code>const</code> <code>Foo</code>. Your reference is non-const, so the correct declaration would be a <code>Foo* const &amp;</code>.</p>\n<p>But it doesn't make any sense to do this, so don't.</p>\n", "LastActivityDate": "2010-04-28T00:52:11.860", "CommentCount": "0", "CreationDate": "2010-04-28T00:52:11.860", "ParentId": "2726146", "Score": "0", "OwnerUserId": "33345"}, "bq_ids": {"n4140": {"so_2726146_2726159_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5895}}, "n3337": {"so_2726146_2726159_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5666}}, "n4659": {"so_2726146_2726159_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 7378}}}, "2726155": {"Id": "2726155", "PostTypeId": "2", "Body": "<p>You can't. </p>\n<p>Firstly, <code>this</code> is not necessarily a <code>const Foo *</code>. <code>this</code> would be a <code>const Foo *</code> is a const method of the class <code>Foo</code>. In a non-const method <code>this</code> is just <code>Foo *</code>. (Actually your error message mentions <code>Foo* const</code>. Where did you see <code>const Foo *</code>?)</p>\n<p>Secondly, and more importantly, <code>this</code> is not an lvalue. You can't have a pointer to <code>this</code>. You can't have a non-constant reference to <code>this</code>. The only thing that you can have is a const reverence to <code>this</code>, i.e. a reference of type <code>Foo *const &amp;</code>.</p>\n<p>It (<code>Foo *const &amp;</code>) will work in your case. </p>\n<pre><code>void do_baz(Foo* const&amp; pFoo) { \n   pFoo-&gt;p_sub_foo = new Foo;\n} \n</code></pre>\n<p>But I don't see the point of all this. Just declare a normal <code>Foo *</code> pointer as parameter for your <code>do_baz</code> method</p>\n<pre><code>void do_baz(Foo* pFoo) { \n   pFoo-&gt;p_sub_foo = new Foo;\n} \n</code></pre>\n<p>and get the same result. What do you think you need that reference for?</p>\n<p><strong>EDIT</strong>: Taking into account your edit, what you are trying to do cannot be done with a single <code>do_baz</code> function, since in the first call you'd potentially (semantically) attempt to modify <code>this</code>, which is impossible (even if the modifying code will never be executed in practice). Whether you want it or not, you can't have a non-const reference to <code>this</code>, even if you don't intend to write anything through it. You'll probably have to implement the very first call with a different function</p>\n<pre><code>void do_baz(Foo*&amp; pFoo) { \n  if (pFoo == NULL) { \n    pFoo = new Foo; \n    return; \n  } \n  //other stuff \n  do_baz(pFoo-&gt;p_sub_foo); \n  //more stuff \n} \n\nvoid do_baz_root(Foo* pFoo) { \n  assert(pFoo != NULL);\n  //other stuff \n  do_baz(pFoo-&gt;p_sub_foo); \n  //more stuff \n} \n</code></pre>\n<p>and then make the first call as</p>\n<pre><code>void bar() {\n  do_baz_root(this);\n}\n</code></pre>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-04-28T01:47:39.753", "Score": "7", "CreationDate": "2010-04-28T00:50:28.723", "ParentId": "2726146", "CommentCount": "6", "OwnerUserId": "187690", "LastEditDate": "2010-04-28T01:47:39.753"}, "2726146": {"ViewCount": "4606", "Body": "<p>Let's say I have a struct</p>\n<pre><code>struct Foo {\n    void bar () {\n       do_baz(this);\n    }\n    /* See edit below\n    void do_baz(Foo*&amp; pFoo) {\n       pFoo-&gt;p_sub_foo = new Foo; // for example\n    }\n    */\n\n    Foo* p_sub_foo;\n}\n</code></pre>\n<p>GCC tells me that</p>\n<pre><code>temp.cpp: In member function \u2018void Foo::bar()\u2019:\ntemp.cpp:3: error: no matching function for call to \u2018Foo::do_baz(Foo* const)\u2019\ntemp.cpp:5: note: candidates are: void Foo::do_baz(Foo*&amp;)\n</code></pre>\n<p>So, how do I convert what is apparently a <code>const Foo*</code> to a <code>Foo*&amp;</code>?</p>\n<p><strong>EDIT</strong>: I didn't use a very good example. <code>do_baz</code> should read</p>\n<pre><code>void do_baz(Foo*&amp; pFoo) {\n    if (pFoo == NULL) {\n        pFoo = new Foo;\n        return;\n    }\n    //other stuff\n    do_baz(pFoo-&gt;p_sub_foo);\n    //more stuff\n}\n</code></pre>\n", "AcceptedAnswerId": "2726155", "Title": "Convert \"this\" to a reference-to-pointer", "CreationDate": "2010-04-28T00:47:21.293", "Id": "2726146", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-06-30T04:23:29.990", "LastEditorUserId": "918414", "LastActivityDate": "2012-06-30T04:23:29.990", "Score": "5", "OwnerUserId": "130442", "Tags": "<c++><pointers><reference>", "AnswerCount": "4"}, "2726159": {"Id": "2726159", "PostTypeId": "2", "Body": "<p>The keyword <code>this</code> is not an lvalue so <code>this</code> can't be assigned to/changed (regardless of whether what it points to is <code>const</code> or not).  In other words, you might be able to change what <code>this</code> points to, but you can't change the value of <code>this</code> itself. The C++ standard 9.3.2 \"The <code>this</code> pointer\":</p>\n<blockquote>\n<p id=\"so_2726146_2726159_0\">In the body of a nonstatic (9.3) member function, the keyword <code>this</code> is a non-lvalue expression</p>\n</blockquote>\n<p>Only const references can bind to non-lvalue objects, so you'd need to bind it to a <code>Foo* const&amp;</code> if you want to bind the <code>this</code> pointer to a reference.</p>\n<p>Change the signature of the function to:</p>\n<pre><code>void do_baz(Foo* const&amp; pFoo);\n</code></pre>\n", "LastEditorUserId": "56338", "LastActivityDate": "2010-04-28T01:13:17.003", "Score": "0", "CreationDate": "2010-04-28T00:50:49.607", "ParentId": "2726146", "CommentCount": "0", "OwnerUserId": "12711", "LastEditDate": "2010-04-28T01:13:17.003"}, "2726164": {"Id": "2726164", "PostTypeId": "2", "Body": "<p>Give the variable a name, and then you will have a pointer reference type:</p>\n<pre>\nvoid bar () {\n   Foo* me = this;\n   do_baz(me);\n}\n</pre>\n<p>I should also point out that your do_baz function isn't making use of the fact that its parameter is a reference (you are not assigning to the pointer, itself, only to what is being pointed to by the pointer). Consequently, it really makes more sense to change the type of the parameter to Foo* instead of Foo*&amp;, or to make it a Foo&amp;, in which case you would use dot (.) instead of arrow (-&gt;) when dereferencing the parameter's member.</p>\n<p><b>Edit</b><br/>\nYour new version of do_baz now makes use of the fact that the parameter is a reference. The solution above (simply using a named pointer) will still work for your new version of the problem. That said, I would advise against what you are doing. It seems you are trying to insert an element at the end of a linked list...</p>\n<p>Firstly, I would advise that if you are implementing a linked list that you maintain not only a pointer to the first node in the list, but also a pointer to the last node in the list at all times, so that insertion at the end of the list may be performed in constant-time. If, however, that is not a possibility, I would nevertheless advise you to use an iterative implementation rather than a recursive one as it is cleaner and simpler. It would look like:</p>\n<pre>\nFoo* current=this;\nwhile (current-&gt;next != NULL){\n    current=current-&gt;next;\n}\ncurrent-&gt;next = new Foo;\n</pre>\n", "LastEditorUserId": "136540", "LastActivityDate": "2010-04-28T01:50:47.693", "Score": "4", "CreationDate": "2010-04-28T00:51:44.940", "ParentId": "2726146", "CommentCount": "0", "OwnerUserId": "136540", "LastEditDate": "2010-04-28T01:50:47.693"}});