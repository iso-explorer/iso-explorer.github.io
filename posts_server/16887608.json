post_cb({"16915869": {"Id": "16915869", "PostTypeId": "2", "Body": "<p><code>f</code> is a member of <code>S</code>, which is a template, so any use of <code>f</code> within <code>S</code> is dependent on the template parameters of <code>S</code>.</p>\n<p>14.6.2.3 [temp.dep.constexpr] paragraph 2:</p>\n<blockquote>\n<p id=\"so_16887608_16915869_0\">An id-expression is value-dependent if:</p>\n<p id=\"so_16887608_16915869_1\">...</p>\n<p id=\"so_16887608_16915869_2\">\u2014 it names a static member function that is a dependent member of the current instantiation</p>\n</blockquote>\n<p>This applies to 'f' here, which is a dependent member of the current instantiation. 14.6.2.1 [temp.dep.types] paragraph 4:</p>\n<blockquote>\n<p id=\"so_16887608_16915869_3\">...</p>\n<p id=\"so_16887608_16915869_4\">A name is a dependent member of the current instantiation if it is a member of the current instantiation that, when looked up, refers to at least one member of a class that is the current instantiation.</p>\n</blockquote>\n<p>Consequently <code>sizeof(f(0))</code> is dependent, <code>I&lt;sizeof(f(0))&gt;</code> is dependent, and <code>I&lt;sizeof(f(0))&gt;::Type</code> needs <code>typename</code> to identify it as a type and not a data member.</p>\n<p>gcc is therefore right to complain.</p>\n<p>MSVC does late lookup with templates, so doesn't complain. This is a bug, but I don't think they ever intend to fix it.</p>\n<p>Clang appears to have a bug here.</p>\n", "LastEditorUserId": "5597", "LastActivityDate": "2013-06-04T14:03:33.313", "Score": "0", "CreationDate": "2013-06-04T10:47:47.987", "ParentId": "16887608", "CommentCount": "8", "OwnerUserId": "5597", "LastEditDate": "2013-06-04T14:03:33.313"}, "bq_ids": {"n4140": {"so_16887608_16915869_4": {"length": 17, "quality": 1.0, "section_id": 194}, "so_16887608_16888165_2": {"length": 7, "quality": 1.0, "section_id": 200}, "so_16887608_16888165_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 198}, "so_16887608_16888165_1": {"length": 7, "quality": 0.875, "section_id": 206}, "so_16887608_16915869_2": {"length": 8, "quality": 1.0, "section_id": 206}}, "n3337": {"so_16887608_16915869_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 188}, "so_16887608_16888165_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 192}, "so_16887608_16915869_2": {"length": 5, "quality": 0.625, "section_id": 67}, "so_16887608_16888165_1": {"length": 7, "quality": 0.875, "section_id": 200}, "so_16887608_16888165_2": {"length": 7, "quality": 1.0, "section_id": 194}}, "n4659": {"so_16887608_16915869_4": {"length": 17, "quality": 1.0, "section_id": 200}, "so_16887608_16888165_2": {"length": 7, "quality": 1.0, "section_id": 206}, "so_16887608_16888165_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 204}, "so_16887608_16888165_1": {"length": 7, "quality": 0.875, "section_id": 214}, "so_16887608_16915869_2": {"length": 8, "quality": 1.0, "section_id": 214}}}, "16888165": {"Id": "16888165", "PostTypeId": "2", "Body": "<p>Dependent names are defined in 14.6.2. gcc complains about <code>I&lt;sizeof(f(0))&gt;</code> being dependent, let's figure that.\n14.6.2.1 last bullet:</p>\n<blockquote>\n<p id=\"so_16887608_16888165_0\">a template-id in which either the template name is a template parameter\n  or any of the template arguments is a dependent type or an expression\n  that is type-dependent or value-dependent</p>\n</blockquote>\n<p>so <code>sizeof(f(0))</code> must be value-dependent. 14.6.2.3p2:</p>\n<blockquote>\n<p id=\"so_16887608_16888165_1\">Expressions of the following form are value-dependent if the unary-expression\n  is type-dependent ...\n  sizeof unary-expression</p>\n</blockquote>\n<p>so we're dependent if f(0) considered dependent. (Little experimenting shows gcc treats member any function dependent and free functions not dependent.) 14.6.2.2:</p>\n<blockquote>\n<p id=\"so_16887608_16888165_2\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n</blockquote>\n<p>And I don't see either type dependent subexpressions or anything relevant in the exception list.</p>\n", "LastEditorUserId": "2422194", "LastActivityDate": "2013-06-02T23:23:13.443", "Score": "2", "CreationDate": "2013-06-02T23:08:25.987", "ParentId": "16887608", "CommentCount": "2", "OwnerUserId": "2422194", "LastEditDate": "2013-06-02T23:23:13.443"}, "16887608": {"ViewCount": "260", "Body": "<p>Compiling with Clang 3.0 -std=c++98, the following code is accepted:</p>\n<pre><code>template&lt;int&gt;\nstruct I\n{\n    typedef int Type;\n};\n\ntemplate&lt;class&gt;\nstruct S\n{\n    static int f(int);\n    //static int f(int*);\n\n    // implicitly instantiates I&lt;sizeof(int)&gt;\n    typedef I&lt;sizeof(f(0))&gt;::Type Type; \n};\n\nS&lt;int&gt;::Type s;\n</code></pre>\n<p>Uncommenting the overload of 'f' causes Clang to report an error \"missing 'typename' prior to dependent type name\". G++ 4.8 reports the same error with or without the overload. msvc10 does not give any errors with or without the overload.</p>\n<p>Where does the standard say whether or not 'f' is dependent and 'typename' is required? If 'typename' is not required, where does the standard say whether or not overload resolution should be performed in this scenario?</p>\n<p>EDIT:</p>\n<p>To clarify: the reason I mention overload resolution is that it may be necessary to perform overload resolution to determine the value of the constant-expression 'sizeof(f(0))'. If (as I assume) overload resolution is not performed when determining whether an expression is type-dependent, the value of the constant-expression 'sizeof(f(0))' is impossible to determine (at parse time) when a dependent overload of 'f' exists: e.g.</p>\n<pre><code>template&lt;int&gt;\nstruct I\n{\n    typedef int Type;\n};\n\ntemplate&lt;class T&gt;\nstruct S\n{\n    static T f(int);\n\n    typedef typename I&lt;sizeof(f(0))&gt;::Type Type; \n};\n\nS&lt;int&gt;::Type t;\n</code></pre>\n<p>Compiling with Clang 3.0 -std=c++98, this produces no errors. This seems correct to me, because the standard deems an expression to be type-dependent if it is an id-expression naming an object declared with a dependent type.</p>\n", "AcceptedAnswerId": "16898231", "Title": "Where does the C++98 standard specify when a call to a static member is dependent within a template?", "CreationDate": "2013-06-02T21:43:16.590", "Id": "16887608", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-01T01:27:11.103", "LastEditorUserId": "321731", "LastActivityDate": "2014-05-01T01:27:11.103", "Score": "4", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><c++98>", "AnswerCount": "3"}, "16898231": {"Id": "16898231", "PostTypeId": "2", "Body": "<p>The paragraph of the C++98 standard that covers this scenario is found in [temp.dep.expr]</p>\n<blockquote>\n<p id=\"so_16887608_16898231_0\">An id-expression is type-dependent if it contains:</p>\n<ul>\n<li>an identifier that was declared with a dependent type,</li>\n</ul>\n</blockquote>\n<p>This wording is somewhat vague about identifiers that are overloaded and potentially declared with more than one type, as reported in DR 541 : <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html</a></p>\n<p>This was resolved (in a more recent draft) by changing the paragraph to read:</p>\n<blockquote>\n<p id=\"so_16887608_16898231_1\">An id-expression is type-dependent if it contains:</p>\n<ul>\n<li>an identifier <strong>associated by name lookup with one or more declarations</strong> declared with a  dependent type,</li>\n</ul>\n</blockquote>\n<p>When considering the following code:</p>\n<pre><code>template&lt;class T&gt;\nstruct S\n{\n    static int f(int);\n    static int f(int*);\n\n    static T g(int*);\n    static int g(int);\n\n    static const int x = sizeof(f(0));\n    static const int y = sizeof(g(0));\n};\n</code></pre>\n<p>My interpretation is that the identifier <code>f</code> in the expression <code>f(0)</code> is not dependent, while the identifier <code>g</code> in the expression <code>g(0)</code> is dependent.</p>\n<p>When determining if a function-call expression is dependent - though overload resolution is not performed - all overloads of the function are considered.</p>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2013-06-04T22:13:43.847", "Score": "2", "CreationDate": "2013-06-03T13:44:21.557", "ParentId": "16887608", "CommentCount": "3", "OwnerUserId": "1690864", "LastEditDate": "2013-06-04T22:13:43.847"}});