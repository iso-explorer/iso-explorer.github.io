post_cb({"42491502": {"ParentId": "42491290", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Originally, in C++11, this was legal because the wording was:</p>\n<blockquote>\n<p id=\"so_42491290_42491502_0\">A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero </p>\n</blockquote>\n<p>But, as of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#903\" rel=\"nofollow noreferrer\">CWG defect 903</a>, which is a defect against C++11, it became not legal:</p>\n<blockquote>\n<p id=\"so_42491290_42491502_1\">A null pointer constant is an integer literal (2.13.2 [lex.icon]) with value zero</p>\n</blockquote>\n<p><code>(int)0</code> is an integral constant expression prvalue of integer type that evalutes to zero, but it's not literally an integer literal with value <code>0</code>. </p>\n<p>As this is a defect against C++11, the code itself should be ill-formed in C++11.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-03-06T13:04:13.313", "Id": "42491502", "Score": "6", "CreationDate": "2017-02-27T17:01:22.690", "LastActivityDate": "2017-03-06T13:04:13.313"}, "42491290": {"CommentCount": "8", "ViewCount": "161", "CreationDate": "2017-02-27T16:51:44.480", "LastActivityDate": "2017-03-06T13:04:13.313", "Title": "`type *var = (int)0`, legal or not?", "AcceptedAnswerId": "42491502", "PostTypeId": "1", "Id": "42491290", "Score": "4", "Body": "<p>The following example:</p>\n<pre><code>char *var = (int)0;\n</code></pre>\n<p>Compiles on gcc and cl.exe, but causes an error in clang:</p>\n<blockquote>\n<p id=\"so_42491290_42491290_0\">cannot initialize a variable of type 'char *' with an rvalue of type 'int'</p>\n</blockquote>\n<p>Who is correct here?</p>\n<hr>\n<p>For what it's worth, C++11 says (emphasis mine)</p>\n<blockquote>\n<p id=\"so_42491290_42491290_1\">4.10/1 </p>\n<p id=\"so_42491290_42491290_2\">A null pointer constant is an <strong>integral constant expression</strong> (5.19) prvalue of integer type that evaluates to zero or a prvalue of type std::nullptr_t. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type and ...</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_42491290_42491290_3\">5.19/3</p>\n<p id=\"so_42491290_42491290_4\">An integral constant expression is a literal constant expression of integral or unscoped enumeration type. [ Note: Such expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field lengths (9.6), as enumerator initializers if the underlying type is not fixed (7.2), as null pointer constants (4.10), and as alignments (7.6.2). \u2014 end note ]</p>\n</blockquote>\n<p>From what I understand, the above code should be illegal. cl.exe notoriously violates the standard (so I don't trust it a bit), but gcc also accepts the above code. Are there other parts of the standard relevant that I'm missing or is that outright a gcc bug?</p>\n</hr>", "Tags": "<c++><gcc><visual-c++><clang><language-lawyer>", "OwnerUserId": "912144", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42491290_42491290_2": {"section_id": 39, "quality": 0.6666666666666666, "length": 18}, "so_42491290_42491290_4": {"section_id": 6186, "quality": 0.6060606060606061, "length": 20}, "so_42491290_42491502_1": {"section_id": 39, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_42491290_42491290_2": {"section_id": 36, "quality": 0.8888888888888888, "length": 24}, "so_42491290_42491290_4": {"section_id": 5947, "quality": 0.7575757575757576, "length": 25}, "so_42491290_42491502_1": {"section_id": 5947, "quality": 0.5555555555555556, "length": 5}, "so_42491290_42491502_0": {"section_id": 36, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_42491290_42491290_2": {"section_id": 39, "quality": 0.6666666666666666, "length": 18}, "so_42491290_42491290_4": {"section_id": 7688, "quality": 0.5454545454545454, "length": 18}, "so_42491290_42491502_1": {"section_id": 39, "quality": 0.6666666666666666, "length": 6}}}});