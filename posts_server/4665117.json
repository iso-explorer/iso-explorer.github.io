post_cb({"4665155": {"ParentId": "4665117", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2011-01-12T03:44:27.387", "Score": "44", "LastEditorUserId": "33732", "LastEditDate": "2011-01-12T06:21:09.460", "Id": "4665155", "OwnerUserId": "33732", "Body": "<p>Yes. The return types are allowed to be different as long as they are <a href=\"http://www.lwithers.me.uk/articles/covariant.html\"><em>covariant</em></a>. The C++ standard describes it like this (\u00a710.3/5):</p>\n<blockquote>\n<p id=\"so_4665117_4665155_0\">The return type of an overriding function shall be either identical to the return type of the overridden function or <em>covariant</em> with the classes of the functions. If a function <code>D::f</code> overrides a function <code>B::f</code>, the return type of the functions are covariant if the satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes or references to classes<sup>98)</sup></li>\n<li>the class in the return type of <code>B::f</code> is the same class as the class in the return type of <code>D::f</code> or, is an unambiguous direct or indirect base class of the class in the return type of <code>D::f</code> and is accessible in <code>D</code></li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of <code>D::f</code> has the same cv-qualification as or less cv-qualification than the class type in the return type of <code>B::f</code>.</li>\n</ul>\n</blockquote>\n<p>Footnote 98 points out that \"multi-level pointers to classes or references to multi-level pointers to classes are not allowed.\"</p>\n<p>In short, if <code>D</code> is a subtype of <code>B</code>, then the return type of the function in <code>D</code> needs to be a subtype of the return type of the function in <code>B</code>. The most common example is when the return types are themselves based on <code>D</code> and <code>B</code>, but they don't have to be. Consider this, where we two separate type hierarchies:</p>\n<pre><code>struct Base { /* ... */ };\nstruct Derived: public Base { /* ... */ };\n\nstruct B {\n  virtual Base* func() { return new Base; }\n  virtual ~B() { }\n};\nstruct D: public B {\n  Derived* func() { return new Derived; }\n};\n\nint main() {\n  B* b = new D;\n  Base* base = b-&gt;func();\n  delete base;\n  delete b;\n}\n</code></pre>\n<p>The reason this works is because any caller of <code>func</code> is expecting a <code>Base</code> pointer. Any <code>Base</code> pointer will do. So, if <code>D::func</code> promises to always return a <code>Derived</code> pointer, then it will always satisfy the contract laid out by the ancestor class because any <code>Derived</code> pointer can be implicitly converted to a <code>Base</code> pointer. Thus, callers will always get what they expect.</p>\n<hr>\n<p>In addition to allowing the return type to vary, some languages allow the <em>parameter types</em> of the overriding function to vary, too. When they do that, they usually need to be <em>contravariant</em>. That is, if <code>B::f</code> accepts a <code>Derived*</code>, then <code>D::f</code> would be allowed to accept a <code>Base*</code>. Descendants are allowed to be <em>looser</em> in what they'll accept, and <em>stricter</em> in what they return. C++ does not allow parameter-type contravariance. If you change the parameter types, C++ considers it a brand new function, so you start getting into overloading and hiding. For more on this topic, see <a href=\"http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29\"><em>Covariance and contravariance (computer science)</em></a> in Wikipedia.</p>\n</hr>", "LastActivityDate": "2011-01-12T06:21:09.460"}, "4665117": {"CommentCount": "0", "AcceptedAnswerId": "4665163", "PostTypeId": "1", "LastEditorUserId": "501557", "CreationDate": "2011-01-12T03:35:54.103", "LastActivityDate": "2017-05-05T19:49:01.493", "LastEditDate": "2013-01-07T05:31:52.623", "ViewCount": "30834", "FavoriteCount": "27", "Title": "C++ virtual function return type", "Id": "4665117", "Score": "59", "Body": "<p>Is it possible for an inherited class to implement a virtual function with a different return type (not using a template as return)?</p>\n", "Tags": "<c++><inheritance><virtual-functions><override><return-type>", "OwnerUserId": "464277", "AnswerCount": "3"}, "4665163": {"ParentId": "4665117", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-01-12T03:45:39.527", "Score": "64", "LastEditorUserId": "501557", "LastEditDate": "2017-05-05T19:49:01.493", "Id": "4665163", "OwnerUserId": "501557", "Body": "<p>In some cases, yes, it is legal for a derived class to override a virtual function using a different return type as long as the return type is <em>covariant</em> with the original return type.  For example, consider the following:</p>\n<pre><code>class Base {\npublic:\n    virtual ~Base() {}\n\n    virtual Base* clone() const = 0;\n};\n\nclass Derived: public Base {\npublic:\n    virtual Derived* clone() const {\n        return new Derived(*this);\n    }\n};\n</code></pre>\n<p>Here, <code>Base</code> defines a pure virtual function called <code>clone</code> that returns a <code>Base *</code>.  In the derived implementation, this virtual function is overridden using a return type of <code>Derived *</code>.  Although the return type is not the same as in the base, this is perfectly safe because any time you would write</p>\n<pre><code>Base* ptr = /* ... */\nBase* clone = ptr-&gt;clone();\n</code></pre>\n<p>The call to <code>clone()</code> will always return a pointer to a <code>Base</code> object, since even if it returns a <code>Derived*</code>, this pointer is implicitly convertible to a <code>Base*</code> and the operation is well-defined.</p>\n<p>More generally, a function's return type is never considered part of its signature. You can override a member function with any return type as long as the return type is covariant.</p>\n", "LastActivityDate": "2017-05-05T19:49:01.493"}, "4665161": {"ParentId": "4665117", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-01-12T03:45:05.840", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2015-10-21T00:31:36.287", "Id": "4665161", "OwnerUserId": "106671", "Body": "<p>A derived class implementation of the virtual function can have a <a href=\"https://isocpp.org/wiki/faq/virtual-functions#virtual-ctors\" rel=\"nofollow\"><strong>Covariant Return Type</strong></a>.</p>\n", "LastActivityDate": "2015-10-21T00:31:36.287"}, "bq_ids": {"n4140": {"so_4665117_4665155_0": {"section_id": 7008, "quality": 0.875, "length": 21}}, "n3337": {"so_4665117_4665155_0": {"section_id": 6754, "quality": 0.875, "length": 21}}, "n4659": {"so_4665117_4665155_0": {"section_id": 8505, "quality": 0.875, "length": 21}}}});