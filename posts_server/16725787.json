post_cb({"16745536": {"ParentId": "16725787", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, you should not generally call delete (in some cases like when operator delete is overleaded it may be ok).</p>\n<pre><code>char *buffer = new char[1024];\nMyStruct *p = new(buffer) MyStruct(); //placement new \"i'm just calling constructor\"\np-&gt;~MyStruct();  //destroy the object.\n\n//delete p; // WHAT? even if you override operator delete it may be opaque to reader.\ndelete [] buffer; // THIS DELETE IS OK (if you have first destroyed MyStruct)\n</code></pre>\n", "OwnerUserId": "1829943", "LastEditorUserId": "1012936", "LastEditDate": "2013-05-25T02:23:05.753", "Id": "16745536", "Score": "0", "CreationDate": "2013-05-25T01:21:03.410", "LastActivityDate": "2013-05-25T02:23:05.753"}, "16725798": {"ParentId": "16725787", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>[Revised] It's not generally OK, and you can only generally <code>delete</code> something that was obtained with the matching plain <code>new</code> expression. Otherwise it is up to you to guarantee that the deallocation function matches the allocation function (so using <code>::delete p;</code> would be the safer general solution, assuming your original <code>operator new</code> was in the global namespace). In particular when the class in question (or one of its derived classes) overload <code>operator new</code> you have to be careful.</p>\n<p>Since you're using a placement-new expression to create <code>*p</code>, and since there is no such thing as a \"placement-delete expression\", you have to destroy the object manually and then release the memory:</p>\n<pre><code>p-&gt;~MyStruct();\n\noperator delete(buffer);\n</code></pre>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2013-05-24T00:57:22.970", "Id": "16725798", "Score": "12", "CreationDate": "2013-05-23T23:59:29.210", "LastActivityDate": "2013-05-24T00:57:22.970"}, "16725884": {"ParentId": "16725787", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><code>delete p</code> is equivalent to </p>\n<pre><code>p-&gt;~MyStruct();\noperator delete(p);\n</code></pre>\n<p>unless <code>MyStruct</code> has an alternative <code>operator delete</code>, so your example should be well-defined with the expected semantics.</p>\n<p><code>[expr.delete]/2</code> states:</p>\n<blockquote>\n<p id=\"so_16725787_16725884_0\">the value of the operand of delete may be ... a pointer to a non-array object created by a previous <em>new-expression</em>.</p>\n</blockquote>\n<p>Placement new is a type of <em>new-expression</em>. <code>[expr.new]/1</code>:</p>\n<blockquote>\n<p id=\"so_16725787_16725884_1\"><i>new-expression</i>:<br>\n  \u00a0\u00a0\u00a0\u00a0::<i><sub>opt</sub></i> <b>new</b> <i>new-placement<sub>opt</sub> new-type-id new-initializer<sub>opt</sub></i><br>\n  \u00a0\u00a0\u00a0\u00a0::<i><sub>opt</sub></i> <b>new</b> <i>new-placement<sub>opt</sub></i> ( <i>type-id</i> ) <i>new-initializer<sub>opt</sub></i></br></br></p>\n</blockquote>\n<p><code>delete</code> is defined to be a call to the destructor of the object and then a call to the deallocation function for the memory. <code>[expr.delete]/6,7</code>:</p>\n<blockquote>\n<p id=\"so_16725787_16725884_2\">... the <i>delete-expression</i> will invoke the destructor (if any) for the object ...</p>\n<p id=\"so_16725787_16725884_3\">... the <i>delete-expression</i> will call a deallocation function ...</p>\n</blockquote>\n<p>As long as the deallocation function matches the allocation function (which it should, as long as you haven't overloaded <code>operator delete</code> for your class), then this should all be well defined.</p>\n", "OwnerUserId": "485561", "LastEditorUserId": "1760345", "LastEditDate": "2013-05-24T01:12:40.937", "Id": "16725884", "Score": "13", "CreationDate": "2013-05-24T00:09:18.860", "LastActivityDate": "2013-05-24T01:12:40.937"}, "bq_ids": {"n4140": {"so_16725787_16725884_2": {"section_id": 6110, "quality": 1.0, "length": 5}, "so_16725787_16725884_0": {"section_id": 6106, "quality": 1.0, "length": 10}, "so_16725787_16725884_3": {"section_id": 6111, "quality": 1.0, "length": 5}}, "n3337": {"so_16725787_16725884_2": {"section_id": 5876, "quality": 1.0, "length": 5}, "so_16725787_16725884_0": {"section_id": 5872, "quality": 1.0, "length": 10}, "so_16725787_16725884_3": {"section_id": 5877, "quality": 1.0, "length": 5}}, "n4659": {"so_16725787_16725884_2": {"section_id": 7607, "quality": 1.0, "length": 5}, "so_16725787_16725884_0": {"section_id": 7603, "quality": 1.0, "length": 10}, "so_16725787_16725884_3": {"section_id": 7608, "quality": 1.0, "length": 5}}}, "16725787": {"CommentCount": "2", "CreationDate": "2013-05-23T23:57:23.557", "PostTypeId": "1", "AcceptedAnswerId": "16725884", "LastEditorUserId": "4370109", "LastActivityDate": "2015-07-07T21:14:46.783", "LastEditDate": "2015-07-07T21:14:46.783", "ViewCount": "264", "FavoriteCount": "2", "Title": "Is calling delete on the result of a placement delete which used operator new okay?", "Id": "16725787", "Score": "12", "Body": "<p>If I do</p>\n<pre><code>struct MyStruct { ~MyStruct() { } };\n\nvoid *buffer = operator new(1024);\nMyStruct *p = new(buffer) MyStruct();\n// ...\ndelete p;     //    &lt;---------- is this okay?\n</code></pre>\n<p>is the <code>delete</code> guaranteed to take care of <em>both</em> calling <code>~MyStruct()</code> <em>as well as</em> <code>operator delete</code>?</p>\n", "Tags": "<c++><new-operator><delete-operator><placement-new>", "OwnerUserId": "541686", "AnswerCount": "3"}});