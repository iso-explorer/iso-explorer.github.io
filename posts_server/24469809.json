post_cb({"24469809": {"ViewCount": "885", "Body": "<p>I never use clang.</p>\n<p>And I accidentally discovered that this piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid \u0444\u0443\u043d\u043a\u0446\u0438\u044f(int \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f)\n{\n    std::cout &lt;&lt; \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f &lt;&lt; std::endl;\n}\n\nint main()\n{\n    int \u0440\u0443\u0441\u0441\u043a\u0430\u044f_\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 0;\n    \u0444\u0443\u043d\u043a\u0446\u0438\u044f(\u0440\u0443\u0441\u0441\u043a\u0430\u044f_\u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f);\n}\n</code></pre>\n<p>will compiles fine: <a href=\"http://rextester.com/NFXBL38644\" rel=\"nofollow\">http://rextester.com/NFXBL38644</a> (clang 3.4 (clang++ -Wall -std=c++11 -O2)).</p>\n<p>Is it a clang extension ?? And why ?\nThanks.</p>\n<p><strong>UPD</strong>: I'm more asking why clang make such decision ? Because I never found the discussion that someone want more characters then c++ standard have now (2.3, rev. 3691)</p>\n", "AcceptedAnswerId": "24469850", "Title": "identifier character set (clang)", "CreationDate": "2014-06-28T18:36:33.583", "Id": "24469809", "CommentCount": "4", "LastEditDate": "2014-06-28T19:27:02.350", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2016-09-03T19:45:13.657", "Score": "5", "OwnerUserId": "2451677", "Tags": "<c++><clang><identifier>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24469809_24469850_9": {"length": 6, "quality": 0.6, "section_id": 5315}, "so_24469809_24469850_12": {"length": 6, "quality": 0.6, "section_id": 6242}, "so_24469809_24470424_2": {"length": 35, "quality": 0.875, "section_id": 5313}}, "n3337": {"so_24469809_24469850_9": {"length": 6, "quality": 0.6, "section_id": 5112}, "so_24469809_24469850_12": {"length": 6, "quality": 0.6, "section_id": 6002}, "so_24469809_24470424_2": {"length": 35, "quality": 0.875, "section_id": 5110}}, "n4659": {"so_24469809_24470424_1": {"length": 47, "quality": 0.8245614035087719, "section_id": 6754}, "so_24469809_24469850_9": {"length": 6, "quality": 0.6, "section_id": 6739}, "so_24469809_24469850_12": {"length": 6, "quality": 0.6, "section_id": 7746}, "so_24469809_24470424_2": {"length": 35, "quality": 0.875, "section_id": 6737}}}, "24469850": {"Id": "24469850", "PostTypeId": "2", "Body": "<p>It's not so much an extension as it is Clang's interpretation of the <strong>Multibyte characters</strong> part of the standard.  Clang supports UTF-8 source code files.</p>\n<p>As to why, I guess \"why not?\" is the only real answer; it seems useful and reasonable to me to support a larger character set.</p>\n<p>Here are the relevant parts of the standard (C11 draft):</p>\n<blockquote>\n<p id=\"so_24469809_24469850_0\"><strong>5.2.1 Character sets</strong></p>\n<p id=\"so_24469809_24469850_1\">1 Two sets of characters and their associated collating sequences shall be defined: the set in which source files are written (the <em>source character set</em>), and the set interpreted in the execution environment (the <em>execution character set</em>). Each set is further divided into a <em>basic character set</em>, whose contents are given by this subclause, and a set of zero or more locale-specific members (which are not members of the basic character set) called <em>extended characters</em>. The combined set is also called the <em>extended character set</em>. The values of the members of the execution character set are implementation-defined.</p>\n<p id=\"so_24469809_24469850_2\">2 In a character constant or string literal, members of the execution character set shall be represented by corresponding members of the source character set or by <em>escape sequences</em> consisting of the backslash <strong><code>\\</code></strong> followed by one or more characters. A byte with all bits set to 0, called the <em>null character</em>, shall exist in the basic execution character set; it is used to terminate a character string.</p>\n<p id=\"so_24469809_24469850_3\">3 Both the basic source and basic execution character sets shall have the following members: the 26 <em>uppercase letters</em> of the Latin alphabet</p>\n<pre><code>A B C D E F G H I J K L M\nN O P Q R S T U V W X Y Z\n</code></pre>\n<p id=\"so_24469809_24469850_4\">the 26 <em>lowercase letters</em> of the Latin alphabet</p>\n<pre><code>a b c d e f g h i j k l m\nn o p q r s t u v w x y z\n</code></pre>\n<p id=\"so_24469809_24469850_5\">the 10 decimal <em>digits</em></p>\n<pre><code>0 1 2 3 4 5 6 7 8 9\n</code></pre>\n<p id=\"so_24469809_24469850_6\">the following 29 graphic characters</p>\n<pre><code>! \" # % &amp; ' ( ) * + , - . / :\n; &lt; = &gt; ? [ \\ ] ^ _ { | } ~\n</code></pre>\n<p id=\"so_24469809_24469850_7\">the space character, and control characters representing horizontal tab, vertical tab, and form feed. The representation of each member of the source and execution basic character sets shall fit in a byte. In both the source and execution basic character sets, the value of each character after <strong><code>0</code></strong> in the above list of decimal digits shall be one greater than the value of the previous. In source files, there shall be some way of indicating the end of each line of text; this International Standard treats such an end-of-line indicator as if it were a single new-line character. In the basic execution character set, there shall be control characters representing alert, backspace, carriage return, and new line. If any other characters are encountered in a source file (except in an identifier, a character constant, a string literal, a header name, a comment, or a preprocessing token that is never\n  converted to a token), the behavior is undefined.</p>\n<p id=\"so_24469809_24469850_8\">4 A <em>letter</em> is an uppercase letter or a lowercase letter as defined above; in this International Standard the term does not include other characters that are letters in other alphabets.</p>\n<p id=\"so_24469809_24469850_9\">5 The universal character name construct provides a way to name other characters.</p>\n</blockquote>\n<p>And also:</p>\n<blockquote>\n<p id=\"so_24469809_24469850_10\"><strong>5.2.1.2 Multibyte characters</strong></p>\n<p id=\"so_24469809_24469850_11\">1 The source character set may contain multibyte characters, used to represent members of the extended character set. The execution character set may also contain multibyte characters, which need not have the same encoding as for the source character set. For both character sets, the following shall hold:</p>\n<p id=\"so_24469809_24469850_12\">\u2014 The basic character set shall be present and each character shall be encoded as a single byte.</p>\n<p id=\"so_24469809_24469850_13\">\u2014 The presence, meaning, and representation of any additional members is locale- specific.</p>\n<p id=\"so_24469809_24469850_14\">\u2014 A multibyte character set may have a <em>state-dependent encoding</em>, wherein each sequence of multibyte characters begins in an <em>initial shift state</em> and enters other locale-specific <em>shift states</em> when specific multibyte characters are encountered in the sequence. While in the initial shift state, all single-byte characters retain their usual interpretation and do not alter the shift state. The interpretation for subsequent bytes in the sequence is a function of the current shift state.</p>\n<p id=\"so_24469809_24469850_15\">\u2014 A byte with all bits zero shall be interpreted as a null character independent of shift state. Such a byte shall not occur as part of any other multibyte character.</p>\n<p id=\"so_24469809_24469850_16\">2 For source files, the following shall hold:</p>\n<p id=\"so_24469809_24469850_17\">\u2014 An identifier, comment, string literal, character constant, or header name shall begin and end in the initial shift state.</p>\n<p id=\"so_24469809_24469850_18\">\u2014 An identifier, comment, string literal, character constant, or header name shall consist of a sequence of valid multibyte characters.</p>\n</blockquote>\n", "LastEditorUserId": "116908", "LastActivityDate": "2014-06-28T18:48:24.230", "Score": "3", "CreationDate": "2014-06-28T18:41:49.523", "ParentId": "24469809", "CommentCount": "5", "LastEditDate": "2014-06-28T18:48:24.230", "OwnerUserId": "116908"}, "24470424": {"Id": "24470424", "PostTypeId": "2", "Body": "<p>Given clang's usage of UTF-8 as the source encoding, this behavior is mandated by the standard:</p>\n<p>C++ defines an identifier as the following:</p>\n<blockquote>\n<p id=\"so_24469809_24470424_0\"><em>identifier:<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0identifier-nondigit<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0identifier identifier-nondigit<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0identifier digit<br/>\n  identifier-nondigit:<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nondigit<br/>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0universal-character-name<br/></em>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0other <em>implementation-defined characters</em></p>\n</blockquote>\n<p>The important part here is that identifiers can include <em>unversal-character-name</em>s. The specifications also lists allowed UCNs:</p>\n<blockquote id=\"so_24469809_24470424_1\">\n<h1>Annex E (normative)</h1>\n<h1>Universal character names for identifier characters [charname]</h1>\n<h3>E.1 Ranges of characters allowed [charname.allowed]</h3>\n<pre><code>00A8, 00AA, 00AD, 00AF, 00B2-00B5, 00B7-00BA, 00BC-00BE, 00C0-00D6, 00D8-00F6, 00F8-00FF\n\n0100-167F, 1681-180D, 180F-1FFF\n\n200B-200D, 202A-202E, 203F-2040, 2054, 2060-206F\n\n2070-218F, 2460-24FF, 2776-2793, 2C00-2DFF, 2E80-2FFF\n\n3004-3007, 3021-302F, 3031-303F\n\n3040-D7FF\n\nF900-FD3D, FD40-FDCF, FDF0-FE44, FE47-FFFD\n\n10000-1FFFD, 20000-2FFFD, 30000-3FFFD, 40000-4FFFD, 50000-5FFFD,\n  60000-6FFFD, 70000-7FFFD, 80000-8FFFD, 90000-9FFFD, A0000-AFFFD,\n  B0000-BFFFD, C0000-CFFFD, D0000-DFFFD, E0000-EFFFD\n</code></pre>\n</blockquote>\n<p>The cyrillic characters in your identifier are in the range 0100-167F.</p>\n<p>The C++ specification further mandates that characters encoded in the source encoding be handled identically to UCNs:</p>\n<blockquote>\n<p id=\"so_24469809_24470424_2\">Any source file character not in the basic source character set (2.3) is replaced by the universal-character-name that designates that character. (An implementation may use any internal encoding, so long as an actual extended character encountered in the source file, and the same extended character expressed in the source file as a universal-character-name (i.e., using the \\uXXXX notation), are handled equivalently\n  <em>\u2014 n3337 \u00a72.2 Phases of translation [lex.phases]/1</em></p>\n</blockquote>\n<p>So given clang's choice of UTF-8 as the source encoding, the spec mandates that these characters be converted to UCNs (or that clang's behavior be indistinguishable from performing such a conversion), and these UCNs are permitted by the spec to appear in identifiers.</p>\n<p>It goes even further. Emoji characters happen to be in the ranges allowed by the C++ spec, so if you've seen some of those examples of <a href=\"http://www.globalnerdy.com/2014/06/03/swift-fun-fact-1-you-can-use-emoji-characters-in-variable-constant-function-and-class-names/\" rel=\"nofollow\">Swift code with emoji identifiers</a> and were surprised by such capability you might be even more surprised to know that C++ has exactly the same capability:</p>\n<p><a href=\"http://rextester.com/EPYJ41676\" rel=\"nofollow\">http://rextester.com/EPYJ41676</a></p>\n<p><a href=\"http://imgur.com/EN6uanB\" rel=\"nofollow\">http://imgur.com/EN6uanB</a></p>\n<hr>\n<p>Another fact that may be surprising is that this behavior isn't new with C++11; C++ has mandated this behavior since C++98. It's just that compilers ignored this for a long time: Clang implemented this feature in version 3.3 in 2013. According to <a href=\"https://msdn.microsoft.com/en-us/library/565w213d(v=vs.140).aspx\" rel=\"nofollow\">this documentation</a> Microsoft Visual Studio supports this in 2015.</p>\n<p>Even today GCC 6.1 only supports UCNs in identifiers when they are written literally, and does not obey the mandate that any character in its extended source character set must be treated identically with the corresponding universal-character-name. E.g. gcc allows <code>int \\u043a\\u043e\\u0448\\043a\\u0430 = 10;</code> but will not allow <code>int \u043a\u043e\u0448\u043a\u0430 = 10;</code> even with -finput-charset=utf-8.</p>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2016-09-03T19:45:13.657", "Score": "2", "CreationDate": "2014-06-28T19:56:17.390", "ParentId": "24469809", "CommentCount": "0", "LastEditDate": "2016-09-03T19:45:13.657", "OwnerUserId": "365496"}});