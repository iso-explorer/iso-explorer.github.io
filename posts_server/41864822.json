post_cb({"bq_ids": {"n4140": {"so_41864822_41864990_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 3921}}, "n3337": {"so_41864822_41864990_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 3781}}, "n4659": {"so_41864822_41864990_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 4807}}}, "41864990": {"Id": "41864990", "PostTypeId": "2", "Body": "<p>The \"canonical\" meaning of the \"<a href=\"https://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow noreferrer\">most vexing parse</a>\" refers to the ambiguity between object declaration and function declaration.</p>\n<p>What you have in your case is a different ambiguity: an ambiguity between object declaration and functional-style cast (more formally: functional notation of explicit type conversion, see 5.2.3). This latter ambiguity is resolved in favor of object declaration. Hence the error. Your code is seen by the compiler as a simple</p>\n<pre><code>ScopeLock m_;\n</code></pre>\n<p>which makes it to complain about missing default constructor.</p>\n<blockquote>\n<p id=\"so_41864822_41864990_0\"><strong>6.8 Ambiguity resolution [stmt.ambig]</strong></p>\n<p id=\"so_41864822_41864990_1\"><strong>1</strong> There is an ambiguity in the grammar involving expression-statements and declarations: An expression statement with a function-style explicit type conversion (5.2.3) as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a (. In those cases the statement is a declaration.</p>\n</blockquote>\n<p>Whether you want to call it another flavor of \"most vexing parse\" is up to you.</p>\n<p>There are many different ways to make the compiler to interpret it as an expression instead of declaration. You can also do it as</p>\n<pre><code>0, ScopeLock(m_);\n</code></pre>\n<p>or as</p>\n<pre><code>(ScopeLock(m_));\n</code></pre>\n", "LastEditorUserId": "187690", "LastActivityDate": "2017-01-26T19:15:44.827", "Score": "2", "CreationDate": "2017-01-26T02:21:29.717", "ParentId": "41864822", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2017-01-26T19:15:44.827"}, "41864862": {"Id": "41864862", "PostTypeId": "2", "Body": "<p>Try to replace\n<code>ScopeLock(m_);</code> to <code>ScopeLock s(m_);</code>. The object needed its name.</p>\n<p>-</p>\n<p>Maybe compiler was seeing <code>ScopeLock(m_)</code> as <code>ScopeLock m_</code>. I compiled with clang, and it showed similar error message.</p>\n<p>Following line compiles without any complaint : </p>\n<pre><code>void Func()\n{\n  ScopeLock(m)(m_);\n  std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastEditorUserId": "1488216", "LastActivityDate": "2017-01-26T02:13:01.513", "Score": "0", "CreationDate": "2017-01-26T02:06:30.957", "ParentId": "41864822", "CommentCount": "1", "OwnerUserId": "1488216", "LastEditDate": "2017-01-26T02:13:01.513"}, "41864901": {"Id": "41864901", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41864822_41864901_0\">Why is line 37 not interpreted as creation of an anonymous <code>ScopeLock</code> object with ctor argument <code>m_</code>?</p>\n</blockquote>\n<p>It's because the Standard has a rule that if code has structure that can be interpreted as either a declaration or a function call, treatment as the declaration is chosen.</p>\n<p>It doesn't worry about whether treatment as a declaration causes an error later.</p>\n<p>If you think about it, having a fallback to an entirely different interpretation would cause some very nasty action-at-a-distance results during code maintenance.  Imagine if you wrote this code and it was accepted as a function-style-cast, and later someone added a default constructor...</p>\n", "LastActivityDate": "2017-01-26T02:10:48.087", "CommentCount": "4", "CreationDate": "2017-01-26T02:10:48.087", "ParentId": "41864822", "Score": "2", "OwnerUserId": "103167"}, "41864822": {"ViewCount": "82", "Body": "<p>Is this an example of a vexing parse in C++?</p>\n<pre><code>#include &lt;pthread.h&gt;\n#include &lt;iostream&gt;\n\nclass ScopeLock\n{\npublic:\n  ScopeLock(pthread_mutex_t&amp; m)\n    : mrMutex(m)\n  {\n    pthread_mutex_lock(&amp;mrMutex);\n  }\n\n  ~ScopeLock()\n  {\n    pthread_mutex_unlock(&amp;mrMutex);\n  }\n\nprotected:\n  pthread_mutex_t&amp; mrMutex;\n};\n\nclass Foo\n{\npublic:\n  Foo()\n  {\n    pthread_mutex_init(&amp;m_, NULL);\n  }\n\n  ~Foo()\n  {\n    pthread_mutex_destroy(&amp;m_);\n  }\n\n  void Func()\n  {\n    ScopeLock(m_); // Is this a vexing parse?\n    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;\n  }\n\nprotected:\n  pthread_mutex_t m_;\n};\n\nint main(int argc, char* argv[])\n{\n  Foo foo;\n  foo.Func();\n\n  return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>&gt;g++ main.cpp \nmain.cpp: In member function \\u2018void Foo::Func():\nmain.cpp:37:17: error: no matching function for call to 'ScopeLock::ScopeLock()'\n     ScopeLock(m_);\n                 ^\nmain.cpp:37:17: note: candidates are:\nmain.cpp:7:3: note: ScopeLock::ScopeLock(pthread_mutex_t&amp;)\n   ScopeLock(pthread_mutex_t&amp; m)\n   ^\nmain.cpp:7:3: note:   candidate expects 1 argument, 0 provided\nmain.cpp:4:7: note: ScopeLock::ScopeLock(const ScopeLock&amp;)\n class ScopeLock\n       ^\nmain.cpp:4:7: note:   candidate expects 1 argument, 0 provided\n</code></pre>\n<p>I think the compiler fails because it is trying to create a <code>ScopeLock</code> object (named m_) with no ctor arguments, and correctly identifies that the only <code>ScopeLock</code> ctor takes one <code>pthread_mutex_t&amp;</code> as argument -- is that correct?</p>\n<p>Why is this a vexing parse, though (if it is)? Why is line 37 not interpreted as creation of an anonymous <code>ScopeLock</code> object with ctor argument <code>m_</code>?</p>\n<p>If the above is an example of a vexing parse, why is the below not a vexing parse?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Foo\n{\npublic:\n  Foo()\n  {\n    pStr = \"Foo\";\n  }\n\n  ~Foo()\n  {\n  }\n\n  void Func()\n  {\n    const std::string&amp; rStr = std::string(pStr);\n    std::cout &lt;&lt; rStr &lt;&lt; std::endl;\n  }\n\nprotected:\n  const char* pStr;\n};\n\nint main(int argc, char* argv[])\n{\n  Foo foo;\n  foo.Func();\n\n  return 0;\n}\n</code></pre>\n<p>Compilation and output:</p>\n<pre><code>&gt;g++ main.cpp\n&gt;./a.out\nFoo\n&gt;\n</code></pre>\n<p>The second code block seems very analogous to the first. Why, then does the compiler not treat line 18 as creation of a <code>std::string</code> named <code>pStr</code> with no ctor arguments? The <code>cout</code> of <code>rStr</code> resulting in \"Foo\" actually shows that an anonymous <code>std::string</code> was created with <code>const char*</code> argument.</p>\n<p>I'd be grateful if anyone could shed light here. Thank you.</p>\n<p><strong>Update</strong>\nI just noticed that in the first code block changing this:</p>\n<pre><code>ScopeLock(m_); // Is this a vexing parse?\n</code></pre>\n<p>to this:</p>\n<pre><code>const ScopeLock&amp; rSl = ScopeLock(m_); // Is this a vexing parse?\n</code></pre>\n<p>results in compilation passing. So something about turning the anonymous object to an rvalue fixes the vexing parse problem? I'm unclear.</p>\n<p>On the flip side, in the second code block, changing this:</p>\n<pre><code>const std::string&amp; rStr = std::string(pStr);\n</code></pre>\n<p>to this:</p>\n<pre><code>std::string(pStr);\n</code></pre>\n<p>compiles just fine. However the resulting <code>cout</code> of <code>pStr</code> is empty. I think this confirms that the compiler is actually creating a <code>std::string</code> named <code>pStr</code> using the default constructor. So actually that is analogous to what it was trying to do in the first code block.</p>\n<p>I'd still be grateful if someone could confirm if what I've surmised is correct.</p>\n", "AcceptedAnswerId": "41864990", "Title": "(Why) Is this an example of a vexing parse?", "CreationDate": "2017-01-26T02:01:22.197", "Id": "41864822", "CommentCount": "4", "LastEditDate": "2017-01-26T02:26:05.487", "PostTypeId": "1", "LastEditorUserId": "5437543", "LastActivityDate": "2017-01-26T19:15:44.827", "Score": "-2", "OwnerUserId": "5437543", "Tags": "<c++><most-vexing-parse>", "AnswerCount": "3"}});