post_cb({"bq_ids": {"n4140": {"so_17479427_17504137_3": {"length": 49, "quality": 0.9074074074074074, "section_id": 6038}, "so_17479427_17504137_1": {"length": 48, "quality": 0.9230769230769231, "section_id": 43}}, "n3337": {"so_17479427_17504137_3": {"length": 52, "quality": 0.9629629629629629, "section_id": 5806}, "so_17479427_17504137_1": {"length": 48, "quality": 0.9230769230769231, "section_id": 40}}, "n4659": {"so_17479427_17504137_3": {"length": 42, "quality": 0.7777777777777778, "section_id": 7537}, "so_17479427_17504137_1": {"length": 48, "quality": 0.9230769230769231, "section_id": 43}}}, "17479427": {"ViewCount": "204", "Body": "<p>I\u2019m trying to make a custom collision engine for academic purposes and I got stuck on a general c++ programming issue. I already have all the geometries which work properly and the collision test also working properly.</p>\n<p>The engine uses those 2 classes to create a queue of geometries to test :</p>\n<pre><code>class collidable;\n\ntemplate&lt;typename geometry_type&gt;\nclass collidable_object : public collidable;\n</code></pre>\n<p>Since multiple geometry types are possible, I didn't want to have to specify manually any collisions to be tested.</p>\n<p>Instead I used this \"technique\" to implement the double-dispatching:</p>\n<pre><code>class collidable\n{\npublic:\n    typedef bool (collidable::*collidable_hit_function)(const collidable&amp; ) const;\n\n    virtual ~collidable() = 0 {}\n\n    virtual collidable_hit_function get_hit_function() const = 0;\n};\n\ntemplate&lt;typename geometry_type&gt;\nclass collidable_object : public collidable\n{\npublic:\n    explicit collidable_object( geometry_type&amp; geometry ) :\n        m_geometry( geometry )\n    {}\n\n    ~collidable_object(){}\n\n    virtual collidable_hit_function get_hit_function() const\n{\n    return static_cast&lt;collidable_hit_function&gt;( &amp;collidable_object&lt;geometry_type&gt;::hit_function&lt;geometry_type&gt; );\n}\n\ntemplate&lt;typename rhs_geometry_type&gt;\nbool hit_function( const collidable&amp; rhs ) const\n{\n    return check_object_collision&lt;geometry_type, rhs_geometry_type&gt;( *this, rhs );\n}\n\nconst geometry_type&amp; geometry() const\n{\n    return m_geometry;\n}\n\nprivate:\n    geometry_type&amp; m_geometry;\n};\n\nbool check_collision( const collidable&amp; lhs, const collidable&amp; rhs )\n{\n    collidable::collidable_hit_function hit_func = lhs.get_hit_function();\n\n    return (lhs.*hit_func)( rhs );\n}\n</code></pre>\n<p>where the function <code>check_object_collision</code> is a template function which tests for collision and has been tested.</p>\n<p>My question is as follows: the cast in the function <code>get_hit_function</code> does compile but seems suspicious... am I doing something horribly wrong which will lead to undefined behavior and multiple nightmares or is it OK to cast template member function pointers from one derived class to another.</p>\n<p>what confuses me is that in visual c++ 2012 this compiles and <strong>seems</strong> to work properly...</p>\n<p>What could make this cast go horribly wrong?</p>\n<p>I don't really understand what casting function pointers implies...</p>\n<p>As a follow up question, would there be a way to implement this in a safe way</p>\n", "Title": "templated double-dispatching using function pointers", "CreationDate": "2013-07-05T00:00:52.673", "LastActivityDate": "2013-07-09T10:12:58.770", "CommentCount": "6", "PostTypeId": "1", "Id": "17479427", "Score": "0", "OwnerUserId": "2157349", "Tags": "<c++><templates><c++11><function-pointers><double-dispatch>", "AnswerCount": "3"}, "17504137": {"Id": "17504137", "PostTypeId": "2", "Body": "<p>Yes, <code>static_cast</code> from <code>bool (collidable_object&lt;geometry_type&gt;::*)() const</code> to <code>bool (collidable::*)() const</code> is explicitly allowed by the standard, because <code>collidable</code> is an accessible unambiguous non-virtual base-class of <code>collidable_object&lt;geometry_type&gt;</code>.</p>\n<p>When converting a pointer-to-member in the opposite direction - from derived to base - <code>static_cast</code> is not required. This is because there exists a valid 'standard conversion' from <code>bool (collidable::*)() const</code> to <code>bool (collidable_object&lt;geometry_type&gt;::*)() const</code>.</p>\n<blockquote>\n<p id=\"so_17479427_17504137_0\">[conv.mem]</p>\n<p id=\"so_17479427_17504137_1\">An rvalue of type \u201cpointer to member of B of type cv T,\u201d where B is a class type, can be converted to an rvalue of type \u201cpointer to member of D of type cv T,\u201d where D is a derived class of B. If B is an inaccessible, ambiguous or virtual base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers to the same member as the pointer to member before the conversion took place, but it refers to the base class member as if it were a member of the derived class. The result refers to the member in D\u2019s instance of B. [...]</p>\n</blockquote>\n<p>Because this valid standard conversion exists, and <code>collidable</code> is an accessible unambiguous non-virtual base-class of <code>collidable_object&lt;geometry_type&gt;</code> it is possible to use <code>static_cast</code> to convert from base to derived.</p>\n<blockquote>\n<p id=\"so_17479427_17504137_2\">[expr.static.cast]</p>\n<p id=\"so_17479427_17504137_3\">An rvalue of type \u201cpointer to member of D of type cv1 T\u201d can be converted to an rvalue of type \u201cpointer to member of B of type cv2 T\u201d, where B is a base class of D, if a valid standard conversion from \u201cpointer to member of B of type T\u201d to \u201cpointer to member of D of type T\u201d exists, and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. [...] If class B contains the original member, or is a base or derived class of the class containing the original member, the resulting pointer to member points to the original member. Otherwise, the result of the cast is undefined. [...]</p>\n</blockquote>\n<p>When you call a derived-class member-function through a pointer-to-member-of-base, you must ensure that the base-class object you call it with is an instance of the derived-class. Otherwise, undefined behaviour!</p>\n<p>Here's a <a href=\"http://coliru.stacked-crooked.com/view?id=994eeaf5af634414543ce8dbf439122d-e54ee7a04e4b807da0930236d4cc94dc\" rel=\"nofollow\">working example</a>. Uncommenting the last line of main demonstrates the undefined behaviour - which unfortunately breaks the viewer.</p>\n<p>What does the compiler do under the hood to make this work? That's a whole different question ;).</p>\n<p>Regarding the follow up question, the canonical way to implement double-dispatch is using the Visitor pattern. Here's a <a href=\"http://coliru.stacked-crooked.com/view?id=3de2140ab1b7685129076ce97456d57f-e54ee7a04e4b807da0930236d4cc94dc\" rel=\"nofollow\">working example</a> of how this could be applied to your scenario:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Geom\n{\n    virtual void accept(Geom&amp; visitor) = 0;\n    virtual void visit(struct GeomA&amp;) = 0;\n    virtual void visit(struct GeomB&amp;) = 0;\n};\n\nstruct GeomA : Geom\n{\n    void accept(Geom&amp; visitor)\n    {\n        visitor.visit(*this);\n    }\n    void visit(GeomA&amp; a)\n    {\n        std::cout &lt;&lt; \"a -&gt; a\" &lt;&lt; std::endl;\n    }\n    void visit(GeomB&amp; b)\n    {\n        std::cout &lt;&lt; \"a -&gt; b\" &lt;&lt; std::endl;\n    }\n};\n\nstruct GeomB : Geom\n{\n    void accept(Geom&amp; visitor)\n    {\n        visitor.visit(*this);\n    }\n    void visit(GeomA&amp; a)\n    {\n        std::cout &lt;&lt; \"b -&gt; a\" &lt;&lt; std::endl;\n    }\n    void visit(GeomB&amp; b)\n    {\n        std::cout &lt;&lt; \"b -&gt; b\" &lt;&lt; std::endl;\n    }\n};\n\nvoid collide(Geom&amp; l, Geom&amp; r)\n{\n    l.accept(r);\n}\n\n\nint main()\n{\n    GeomA a;\n    GeomB b;\n\n    collide(a, a);\n    collide(a, b);\n    collide(b, a);\n    collide(b, b);\n}\n</code></pre>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2013-07-09T10:12:58.770", "Score": "0", "CreationDate": "2013-07-06T15:03:17.463", "ParentId": "17479427", "CommentCount": "5", "OwnerUserId": "1690864", "LastEditDate": "2013-07-09T10:12:58.770"}, "17479979": {"Id": "17479979", "PostTypeId": "2", "Body": "<p>It is OK to cast pointer to a method from base class to derived class. In opposite direction it's very bad idea. Think what will happen if somebody will use your code like this:</p>\n<pre><code>collidable_object&lt;A&gt; a;\ncollidable_hit_function f = a.get_hit_function();\n\ncollidable_object&lt;B&gt; b;\nb.*f(...);\n</code></pre>\n<p>Yuor <code>hit_function</code> (pointed to by <code>f</code>) will expect <code>this</code> to be <code>collidable_object&lt;A&gt;</code>, but insted it will get <code>collidable_object&lt;B&gt;</code>. If those two classes are similar enough you will not get errors, but your code is probably already doing something else than it should. You can cas it like that if you really have to, but then you must take care that youuse this pointer only on the right class.</p>\n<p>More importantly however, what you are doing is most likely conceptually wrong. If you have two geometry types <code>A</code> and <code>B</code>, and you check for collision with</p>\n<pre><code>collidable_object&lt;A&gt; a;\ncollidable_object&lt;B&gt; b;\ncheck_collision(a,b);\n</code></pre>\n<p>then what you do is eventually call:</p>\n<pre><code>check_object_collision&lt;A, A&gt;();\n</code></pre>\n<p>so you are checking for collision as if both <code>collidable</code>s were of geometry <code>A</code> - I am guessing it's not what you want to do.</p>\n<p>This is problem that you will probably not solve with any single language construct, as it requires 2-dimensionall array of different collision-checks, one for each pair of geometry AND you need type-erasure to be able to manipulate generic <code>collidable</code>s.</p>\n", "LastActivityDate": "2013-07-05T01:39:28.713", "CommentCount": "2", "CreationDate": "2013-07-05T01:39:28.713", "ParentId": "17479427", "Score": "1", "OwnerUserId": "455304"}, "17479453": {"Id": "17479453", "PostTypeId": "2", "Body": "<p>Q: Is it OK to cast template member function pointers from one derived class to another?</p>\n<p>A: Yes, if get_hit_function() is truly compatible.</p>\n<p>If this were Java or C#, I'd just declare an interface :)</p>\n", "LastActivityDate": "2013-07-05T00:05:47.853", "CommentCount": "1", "CreationDate": "2013-07-05T00:05:47.853", "ParentId": "17479427", "Score": "0", "OwnerUserId": "421195"}});