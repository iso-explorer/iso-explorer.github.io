post_cb({"31220154": {"CommentCount": "14", "AcceptedAnswerId": "31220649", "PostTypeId": "1", "LastEditorUserId": "1272610", "CreationDate": "2015-07-04T11:36:09.010", "LastActivityDate": "2015-07-06T04:47:35.983", "LastEditDate": "2015-07-04T20:39:50.553", "ViewCount": "417", "FavoriteCount": "2", "Title": "Class declaration in same scope as using declaration compiles in GCC but not MSVS", "Id": "31220154", "Score": "5", "Body": "<p>Is the following program well-formed according to the c++ standard?</p>\n<pre><code>namespace X { class A; }\n\nnamespace Y { using X::A; class A {}; }\n\nint main() {}\n</code></pre>\n<p>I'm getting different results with different compilers:</p>\n<ul>\n<li>gcc compiles it without errors.</li>\n<li>visual c++ gives error C2888: 'X::A': symbol cannot be defined within namespace 'Y'</li>\n</ul>\n<p>I don't find any rule in the c++ standard that my program violates.</p>\n<p>If the program is well-formed, why does visual studio give an error?</p>\n<p>If the program is not well-formed, what rule in the c++ standard did it violate and why doesn't gcc give an error?</p>\n<p>I'm not trying to make my program compile. I'm just trying to find out if it is well-formed according to the c++ standard and why the two compilers I tested behave differently.</p>\n", "Tags": "<c++><declaration><language-lawyer><using-declaration>", "OwnerUserId": "1272610", "AnswerCount": "2"}, "31220248": {"ParentId": "31220154", "LastEditDate": "2015-07-06T04:47:35.983", "CommentCount": "1", "CreationDate": "2015-07-04T11:44:56.893", "OwnerUserId": "5075107", "LastEditorUserId": "2659313", "PostTypeId": "2", "Id": "31220248", "Score": "-2", "Body": "<p>Not too sure but you can try something like this :</p>\n<pre><code>namespace X { class A; }\n\nnamespace Y \n{\n  class X::A {}; \n}\n\nint main() \n{\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-07-06T04:47:35.983"}, "bq_ids": {"n4140": {"so_31220154_31220649_2": {"section_id": 7047, "quality": 1.0, "length": 28}, "so_31220154_31220649_0": {"section_id": 7047, "quality": 1.0, "length": 11}, "so_31220154_31220649_1": {"section_id": 7047, "quality": 1.0, "length": 10}}, "n3337": {"so_31220154_31220649_2": {"section_id": 6792, "quality": 1.0, "length": 28}, "so_31220154_31220649_0": {"section_id": 6792, "quality": 1.0, "length": 11}, "so_31220154_31220649_1": {"section_id": 6792, "quality": 1.0, "length": 10}}, "n4659": {"so_31220154_31220649_2": {"section_id": 8544, "quality": 1.0, "length": 28}, "so_31220154_31220649_0": {"section_id": 8544, "quality": 1.0, "length": 11}, "so_31220154_31220649_1": {"section_id": 8544, "quality": 1.0, "length": 10}}}, "31220649": {"ParentId": "31220154", "CommentCount": "9", "Body": "<p>I believe the program is ill formed. [basic.scope.declarative]/4 says:</p>\n<blockquote>\n<p id=\"so_31220154_31220649_0\">Given a set of declarations in a single declarative region, each of which specifies the same unqualified name,</p>\n<p id=\"so_31220154_31220649_1\">\u2014 they shall all refer to the same entity, or all refer to functions and function templates; or</p>\n<p id=\"so_31220154_31220649_2\">\u2014 exactly one declaration shall declare a class name or enumeration name that is not a typedef name and the other declarations shall all refer to the same variable or enumerator, or all refer to functions and function templates; in this case the class name or enumeration name is hidden</p>\n</blockquote>\n<p>The two declarations of unqualified name <code>A</code> refer to different entities, both of which are classes.</p>\n<p>(Interestingly, neither GCC 6.0 nor Clang 3.7 seem to diagnose it that way. Both accept the code as written (not diagnosing the declaration of two distinct classes with the same name). If you add <code>X::A a;</code> to the body of <code>main</code>, then Clang complains about the incomplete type of <code>X::A</code>.)</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "31220649", "Score": "4", "CreationDate": "2015-07-04T12:31:47.390", "LastActivityDate": "2015-07-04T12:31:47.390"}});