post_cb({"5082643": {"Id": "5082643", "PostTypeId": "2", "Body": "<p>I don't know the exact rationale, but as the iterator also has to support operator*(), it will have to cache the values it reads. Allowing the iterator to cache the first value at construction simplifies this. It also helps in detecting end-of-stream when the stream is initially empty.</p>\n<p>Perhaps your use case is one the committee didn't consider?</p>\n", "LastEditorUserId": "635976", "LastActivityDate": "2011-02-27T07:52:33.917", "Score": "1", "CreationDate": "2011-02-22T19:03:44.087", "ParentId": "5074122", "CommentCount": "12", "OwnerUserId": "597607", "LastEditDate": "2011-02-27T07:52:33.917"}, "5130444": {"Id": "5130444", "PostTypeId": "2", "Body": "<p>Unfortunately the implementer of copy_n has failed to account for the read ahead in the copy loop. The Visual C++ implementation works as you expect on both stringstream and std::cin. I also checked the case from the original example where the istream_iterator is constructed in line.</p>\n<p>Here is the key piece of code from the STL implementation.</p>\n<pre><code>template&lt;class _InIt,\n    class _Diff,\n    class _OutIt&gt; inline\n    _OutIt _Copy_n(_InIt _First, _Diff _Count,\n        _OutIt _Dest, input_iterator_tag)\n    {   // copy [_First, _First + _Count) to [_Dest, ...), arbitrary input\n    *_Dest = *_First;   // 0 &lt; _Count has been guaranteed\n    while (0 &lt; --_Count)\n        *++_Dest = *++_First;\n    return (++_Dest);\n    }\n</code></pre>\n<p>Here is the test code</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;istream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    std::stringstream ss;\n    ss &lt;&lt; 1 &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; std::endl;\n    ss.seekg(0);\n    std::vector&lt;int&gt; numbers(2);\n    std::istream_iterator&lt;int&gt; ii(ss);\n    std::cout &lt;&lt; *ii &lt;&lt; std::endl;  // shows that read ahead happened.\n    std::copy_n(ii, 2, numbers.begin());\n    int i = 0;\n    ss &gt;&gt; i;\n    std::cout &lt;&lt; numbers[0] &lt;&lt; ' ' &lt;&lt; numbers[1] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; std::endl;\n\n    std::istream_iterator&lt;int&gt; ii2(std::cin);\n    std::cout &lt;&lt; *ii2 &lt;&lt; std::endl;  // shows that read ahead happened.\n    std::copy_n(ii2, 2, numbers.begin());\n    std::cin &gt;&gt; i;\n    std::cout &lt;&lt; numbers[0] &lt;&lt; ' ' &lt;&lt; numbers[1] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; std::endl;\n\n    return 0;\n}\n\n\n/* Output\n1\n1 2 3\n4 5 6\n4\n4 5 6\n*/\n</code></pre>\n", "LastEditorUserId": "635976", "LastActivityDate": "2011-02-27T07:52:01.157", "Score": "9", "CreationDate": "2011-02-26T23:31:50.243", "ParentId": "5074122", "CommentCount": "2", "OwnerUserId": "635976", "LastEditDate": "2011-02-27T07:52:01.157"}, "bq_ids": {"n4140": {"so_5074122_5074122_0": {"length": 8, "quality": 1.0, "section_id": 5694}, "so_5074122_5074122_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5698}}, "n3337": {"so_5074122_5074122_0": {"length": 8, "quality": 1.0, "section_id": 5477}, "so_5074122_5074122_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5481}}, "n4659": {"so_5074122_5074122_0": {"length": 8, "quality": 1.0, "section_id": 7139}, "so_5074122_5074122_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7143}}}, "5074122": {"ViewCount": "1609", "Body": "<p>The snippet below reads three integers from <code>std::cin</code>; it writes two into <code>numbers</code> and discards the third:</p>\n<pre><code>std::vector&lt;int&gt; numbers(2);\ncopy_n(std::istream_iterator&lt;int&gt;(std::cin), 2, numbers.begin());\n</code></pre>\n<p>I'd expect the code to read exactly two integers from <code>std::cin</code>, but it turns out this is a correct, standard-conforming behaviour. Is this an oversight in the standard? What is the rationale for this behaviour?</p>\n<hr>\n<p>From 24.5.1/1 in the C++03 standard:</p>\n<blockquote>\n<p id=\"so_5074122_5074122_0\">After it is constructed, and every\n  time ++ is used, the iterator reads\n  and stores a value of <code>T</code>.</p>\n</blockquote>\n<p>So in the code above at the point of call the stream iterator already reads one integer. From that point onward every read by the iterator in the algorithm is a read-ahead, yielding the value cached from the previous read.</p>\n<p>The latest draft of the next standard, <a href=\"http://std.dkuug.dk/jtc1/sc2/wg2/docs/n3225.pdf\">n3225</a>, doesn't seem to bear any change here (24.6.1/1).</p>\n<p>On a related note, 24.5.1.1/2 of the current standard in reference to the <code>istream_iterator(istream_type&amp; s)</code> constructor reads</p>\n<blockquote>\n<p id=\"so_5074122_5074122_1\">Effects: Initializes <code>in_stream</code> with\n  <code>s</code>. <code>value</code> may be initialized during\n  construction or the first time it is\n  referenced.</p>\n</blockquote>\n<p>With emphasis on \"<code>value</code> <strong>may</strong> be initialized ...\" as opposed to \"<strong>shall</strong> be initialized\". This sounds contradicting with 24.5.1/1, but maybe that deserves a question of its own.</p>\n</hr>", "AcceptedAnswerId": "5130444", "Title": "std::istream_iterator<> with copy_n() and friends", "CreationDate": "2011-02-22T04:49:23.487", "Id": "5074122", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-03-13T12:46:30.133", "Score": "25", "OwnerUserId": "456", "Tags": "<c++><istream-iterator>", "AnswerCount": "3"}, "15385763": {"Id": "15385763", "PostTypeId": "2", "Body": "<p>Today I encountered very similar problem, and here is the example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;string&gt;\n\nstruct A\n{\n    float a[3];\n    unsigned short int b[6];\n};\n\nvoid ParseLine( const std::string &amp; line, A &amp; a )\n{\n    std::stringstream ss( line );\n\n    std::copy_n( std::istream_iterator&lt;float&gt;( ss ), 3, a.a );\n    std::copy_n( std::istream_iterator&lt;unsigned short int&gt;( ss ), 6, a.b );\n}\n\nvoid PrintValues( const A &amp; a )\n{\n    for ( int i =0;i&lt;3;++i)\n    {\n        std::cout&lt;&lt;a.a[i]&lt;&lt;std::endl;\n    }\n    for ( int i =0;i&lt;6;++i)\n    {\n        std::cout&lt;&lt;a.b[i]&lt;&lt;std::endl;\n    }\n}\n\nint main()\n{\n    A a;\n\n    const std::string line( \"1.1 2.2 3.3  8 7 6 3 2 1\" );\n\n    ParseLine( line, a );\n\n    PrintValues( a );\n}\n</code></pre>\n<p>Compiling the above example with g++ 4.6.3 produces one:</p>\n<pre><code>1.1 2.2 3.3 7 6 3 2 1 1\n</code></pre>\n<p>, and compiling with g++ 4.7.2 produces another result :</p>\n<pre><code>1.1 2.2 3.3 8 7 6 3 2 1\n</code></pre>\n<hr>\n<p>The c++11 standard tells this about <code>copy_n</code> :</p>\n<pre><code>template&lt;class InputIterator, class Size, class OutputIterator&gt;\nOutputIterator copy_n(InputIterator first, Size n, OutputIterator result);\n</code></pre>\n<blockquote>\n<p id=\"so_5074122_15385763_0\">Effects: For each non-negative integer i &lt; n, performs *(result + i) = *(first + i).<br>\n  Returns: result + n.<br>\n  Complexity: Exactly n assignments.  </br></br></p>\n</blockquote>\n<p>As you can see, it is not specified what exactly happens with the iterators, which means it is implementation dependent.</p>\n<p>My opinion is that your example should not read the 3rd value, which means this is a small flaw in the standard that they haven't specified the behavior.</p>\n</hr>", "LastActivityDate": "2013-03-13T12:46:30.133", "CommentCount": "0", "CreationDate": "2013-03-13T12:46:30.133", "ParentId": "5074122", "Score": "3", "OwnerUserId": "476681"}});