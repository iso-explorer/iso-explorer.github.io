post_cb({"4855219": {"CommentCount": "8", "AcceptedAnswerId": "4868535", "PostTypeId": "1", "LastEditorUserId": "418738", "CreationDate": "2011-01-31T19:39:18.863", "LastActivityDate": "2011-02-02T23:24:05.000", "LastEditDate": "2011-01-31T22:35:31.340", "ViewCount": "947", "FavoriteCount": "5", "Title": "Binding class member function to c-function", "Id": "4855219", "Score": "5", "Body": "<p>Below I have a concept of binding class member function to a global function. The main purpose of this is using C++ for C-style callback function implementation. Can this be done in a better way (for example, without final macro or <code>typeof</code>, or using C++0x features)?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate&lt;typename MF&gt; struct mf_wrapper_helper;\n\ntemplate&lt;typename R, typename T&gt;\nstruct mf_wrapper_helper&lt;R (T::*)()&gt;\n{\n    template &lt;R (T::*F)()&gt;\n    static R wrapper(T *foo) { return (foo-&gt;*F)(); }\n};\n\ntemplate&lt;typename R, typename T, typename T1&gt;\nstruct mf_wrapper_helper&lt;R (T::*)(T1)&gt;\n{\n    template &lt;R (T::*F)(T1)&gt;\n    static R wrapper(T *foo, T1 arg1) { return (foo-&gt;*F)(arg1); }\n};\n\n#define BIND_MF(mf) \\\n    mf_wrapper_helper&lt;typeof(mf)&gt;::wrapper&lt;mf&gt;\n\n\nstruct Foo\n{\n    void x() { cout &lt;&lt; \"Foo::x()\" &lt;&lt; endl; }\n    void x1(int i) { cout &lt;&lt; \"Foo::x1(\" &lt;&lt; i &lt;&lt; \")\" &lt;&lt; endl; }\n};\n\nint\nmain()\n{\n    typedef void (*f_t)(Foo *);\n    typedef void (*f1_t)(Foo *, int i);\n\n    Foo foo;\n\n    f_t f_p = BIND_MF(&amp;Foo::x);\n    (*f_p)(&amp;foo);\n\n    f1_t f1_p = BIND_MF(&amp;Foo::x1);\n    (*f1_p)(&amp;foo, 314);\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "418738", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_4855219_4868535_1": {"section_id": 5965, "quality": 0.95, "length": 38}, "so_4855219_4868535_0": {"section_id": 5988, "quality": 1.0, "length": 18}}, "n3337": {"so_4855219_4868535_1": {"section_id": 5734, "quality": 0.95, "length": 38}, "so_4855219_4868535_0": {"section_id": 5756, "quality": 1.0, "length": 18}}, "n4659": {"so_4855219_4868535_1": {"section_id": 7456, "quality": 0.85, "length": 34}, "so_4855219_4868535_0": {"section_id": 7488, "quality": 0.7777777777777778, "length": 14}}}, "4868535": {"ParentId": "4855219", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-02-01T22:09:36.833", "Score": "1", "LastEditorUserId": "196844", "LastEditDate": "2011-02-02T23:24:05.000", "Id": "4868535", "OwnerUserId": "196844", "Body": "<p>I think that the only technique which will work perfectly is to write a C wrapper function for each member function that you wish to invoke within a C callback; i.e.:</p>\n<pre><code>extern \"C\" void Foo_x(Foo *foo)\n{\n    foo-&gt;x();\n}\n\nextern \"C\" void Foo_x1(Foo *foo, int i)\n{\n    foo-&gt;x1(i);\n}\n</code></pre>\n<p>You could also use lambda expressions of C++0x, which implicitly convert to a pointer to function having the same parameter and return types as the closure type\u2019s function call operator. But, keep in mind that the language linkage of the function type is \"C++\", not \"C\".</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Foo\n{\n    void x() { cout &lt;&lt; \"Foo::x()\" &lt;&lt; endl; }\n    void x1(int i) { cout &lt;&lt; \"Foo::x1(\" &lt;&lt; i &lt;&lt; \")\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    typedef void (*f_t)(Foo*); // default (\"C++\") language linkage\n    typedef void (*f1_t)(Foo*, int);\n\n    Foo foo;\n\n    Foo_x(&amp;foo);\n    Foo_x1(&amp;foo, -10);\n\n    f_t fn = [] (Foo *foo) {\n        foo-&gt;x();\n    };\n    fn(&amp;foo);\n\n    f1_t fn1 = [] (Foo *foo, int i) {\n        foo-&gt;x1(i);\n    };\n    fn1(&amp;foo, 314);\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Note that Section 5.2.2, Function call, of the C++ Standard states:</p>\n<blockquote>\n<p id=\"so_4855219_4868535_0\">Calling a function through an expression whose function type has a language linkage that is different from the language linkage of the function type of the called function\u2019s definition is undefined.</p>\n</blockquote>\n<p>So the following technically invokes undefined behavior:</p>\n<pre><code>extern \"C\" typedef void (*f_t)(Foo*);\n\nint main()\n{\n    Foo foo;\n\n    f_t fn = [] (Foo *foo) {\n        foo-&gt;x();\n    };\n    fn(&amp;foo); // `fn` is a pointer to a function that uses \"C++\" language linkage,\n            // but it is erroneously called through \"C\" language linkage.\n\n//...\n</code></pre>\n<p><strong>EDIT:</strong> After a bit of experimentation, I came up with the following template functions which return lambdas that call the given member function:</p>\n<pre><code>template &lt;typename return_t, class base, typename... arg_types&gt;\nstd::function&lt;return_t (base*, arg_types...)&gt; make_lambda_to_call_member_function(return_t (base::*mem_fn)(arg_types...)) \n{\n    return [mem_fn] (base *o, arg_types... args) -&gt; return_t {\n        (o-&gt;*mem_fn)(args...);\n    };\n}\n\ntemplate &lt;typename return_t, class base, typename... arg_types&gt;\nstd::function&lt;return_t (const base*, arg_types...)&gt; make_lambda_to_call_member_function(return_t (base::*cmem_fn)(arg_types...) const) \n{\n    return [cmem_fn] (const base *o, arg_types... args) -&gt; return_t {\n        (o-&gt;*cmem_fn)(args...);\n    };\n}\n</code></pre>\n<p>If <code>Foo</code> is defined as:</p>\n<pre><code>struct Foo\n{\n    void x() { cout &lt;&lt; \"Foo::x()\" &lt;&lt; endl; }\n    void x1(int i) { cout &lt;&lt; \"Foo::x1(\" &lt;&lt; i &lt;&lt; \")\" &lt;&lt; endl; }\n    void cx1(float f) const { cout &lt;&lt; \"Foo::cx1(\" &lt;&lt; f &lt;&lt; \")\" &lt;&lt; endl; }\n};\n</code></pre>\n<p>Then you use the template <code>make_lambda_to_call_member_function</code> like:</p>\n<pre><code>auto fn = make_lambda_to_call_member_function(&amp;Foo::x);\nfn(&amp;foo);\n\nauto fn1 = make_lambda_to_call_member_function(&amp;Foo::x1);\nfn1(&amp;foo, 314);\n\nauto fn2 = make_lambda_to_call_member_function(&amp;Foo::cx1);\nfn2(&amp;foo, 44.832f);\n</code></pre>\n<p>Note, however, that the returned lambda objects will not implicitly convert to a function pointer because the lambda expression uses a lambda-capture.</p>\n<p>The latest draft of C++0x, n3225, states:</p>\n<blockquote>\n<p id=\"so_4855219_4868535_1\">The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type's function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type's function call operator.</p>\n</blockquote>\n<p>The following is illegal:</p>\n<pre><code>void (*fn5)(Foo*) = make_lambda_to_call_member_function(&amp;Foo::x);\n</code></pre>\n", "LastActivityDate": "2011-02-02T23:24:05.000"}});