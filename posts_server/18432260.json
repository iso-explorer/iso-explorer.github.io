post_cb({"18432260": {"CommentCount": "2", "AcceptedAnswerId": "18432569", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2013-08-25T18:27:22.973", "LastActivityDate": "2015-09-07T14:28:07.853", "LastEditDate": "2013-08-25T18:45:52.080", "ViewCount": "3992", "FavoriteCount": "18", "Title": "Lambda functions as base classes", "Id": "18432260", "Score": "66", "Body": "<p>Playing around with Lambdas I found an interesting behaviour that I do not fully understand.</p>\n<p>Supose I have a <code>struct Overload</code> that derives from 2 template parameters, and has a <code>using F1::operator();</code> clause.</p>\n<p>Now if I derive from two functors I can only access the operator() of F1 (as I would expect)</p>\n<p>If I derive from two Lambda Functions this is no longer true: I can access the operator() from F2 too.</p>\n<pre><code>#include &lt;iostream&gt;\n\n// I compiled with g++ (GCC) 4.7.2 20121109 (Red Hat 4.7.2-8)\n//\n// g++ -Wall -std=c++11 -g main.cc\n// g++ -Wall -std=c++11 -DFUNCTOR -g main.cc\n// \n// or clang clang version 3.3 (tags/RELEASE_33/rc2)\n// \n// clang++ -Wall -std=c++11 -g main.cc\n// clang++ -Wall -std=c++11 -DFUNCTOR -g main.cc\n// \n// on a Linux localhost.localdomain 3.9.6-200.fc18.i686 #1 SMP Thu Jun 13 \n// 19:29:40 UTC 2013 i686 i686 i386 GNU/Linux box\n\n\nstruct Functor1\n{\n    void operator()() { std::cout &lt;&lt; \"Functor1::operator()()\\n\"; }\n};\n\nstruct Functor2\n{\n    void operator()(int) { std::cout &lt;&lt; \"Functor2::operator()(int)\\n\"; }\n};\n\ntemplate &lt;typename F1, typename F2&gt;\nstruct Overload : public F1, public F2\n{\n    Overload()\n        : F1()\n        , F2() {}\n\n    Overload(F1 x1, F2 x2)\n        : F1(x1)\n        , F2(x2) {}\n\n    using F1::operator(); \n};\n\ntemplate &lt;typename F1, typename F2&gt;\nauto get(F1 x1, F2 x2) -&gt; Overload&lt;F1, F2&gt;\n{\n   return Overload&lt;F1, F2&gt;(x1, x2);\n}\n\n\nint main(int argc, char *argv[])\n{\n    auto f = get(Functor1(), Functor2());\n\n    f();\n#ifdef FUNCTOR\n    f(2); // this one doesn't work IMHO correctly\n#endif\n\n    auto f1 = get(\n                  []() { std::cout &lt;&lt; \"lambda1::operator()()\\n\"; },\n                  [](int) { std::cout &lt;&lt; \"lambda2::operator()(int)\\n\"; }\n                  );\n    f1();\n    f1(2); // this one works but I don't know why\n\n\n  return 0;\n}\n</code></pre>\n<p>The standard states that:</p>\n<blockquote>\n<p id=\"so_18432260_18432260_0\">The type of the lambda-expression (which is also the type of the closure object) \n  is a unique, unnamed non- union class type</p>\n</blockquote>\n<p>So every Lambda's types should be unique.</p>\n<p>I cannot explain why this is so: can anyone shed some light on this please?</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "2715978", "AnswerCount": "2"}, "18432618": {"ParentId": "18432260", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-08-25T19:08:25.620", "Score": "14", "LastEditorUserId": "85371", "LastEditDate": "2013-09-11T22:19:11.383", "Id": "18432618", "OwnerUserId": "85371", "Body": "<p>A lambda generates a functor class.</p>\n<p>Indeed, you can derive from lambdas and have polymorphic lambdas!</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    auto overload = make_overload(\n        [](int i)          { return '[' + std::to_string(i) + ']'; },\n        [](std::string s)  { return '[' + s + ']'; },\n        []                 { return \"[void]\"; }\n        );\n\n    std::cout &lt;&lt; overload(42)              &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; overload(\"yay for c++11\") &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; overload()                &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Prints</p>\n<pre><code>[42]\n[yay for c++11]\n[void]\n</code></pre>\n<p>How?</p>\n<pre><code>template &lt;typename... Fs&gt;\n   Overload&lt;Fs...&gt; make_overload(Fs&amp;&amp;... fs)\n{\n    return { std::forward&lt;Fs&gt;(fs)... };\n}\n</code></pre>\n<p>Of course... this still hides the magic. It is the <code>Overload</code> class that 'magically' derives from all the lambdas and exposes the corresponding <code>operator()</code>:</p>\n<pre><code>#include &lt;functional&gt;\n\ntemplate &lt;typename... Fs&gt; struct Overload;\n\ntemplate &lt;typename F&gt; struct Overload&lt;F&gt; {\n    Overload(F&amp;&amp; f) : _f(std::forward&lt;F&gt;(f)) { }\n\n    template &lt;typename... Args&gt;\n    auto operator()(Args&amp;&amp;... args) const \n    -&gt; decltype(std::declval&lt;F&gt;()(std::forward&lt;Args&gt;(args)...)) {\n        return _f(std::forward&lt;Args&gt;(args)...);\n    }\n\n  private:\n    F _f;\n};\n\ntemplate &lt;typename F, typename... Fs&gt;\n   struct Overload&lt;F, Fs...&gt; : Overload&lt;F&gt;, Overload&lt;Fs...&gt;\n{\n    using Overload&lt;F&gt;::operator();\n    using Overload&lt;Fs...&gt;::operator();\n\n    Overload(F&amp;&amp; f, Fs&amp;&amp;... fs) :  \n        Overload&lt;F&gt;(std::forward&lt;F&gt;(f)),\n        Overload&lt;Fs...&gt;(std::forward&lt;Fs&gt;(fs)...)\n    {\n    }\n};\n\ntemplate &lt;typename... Fs&gt;\n   Overload&lt;Fs...&gt; make_overload(Fs&amp;&amp;... fs)\n{\n    return { std::forward&lt;Fs&gt;(fs)... };\n}\n</code></pre>\n<p>See it <strong><a href=\"http://coliru.stacked-crooked.com/a/32189b2c93d21880\">Live on Coliru</a></strong></p>\n", "LastActivityDate": "2013-09-11T22:19:11.383"}, "18432569": {"ParentId": "18432260", "CommentCount": "15", "CreationDate": "2013-08-25T19:01:49.857", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "18432569", "Score": "32", "Body": "<p>In addition to <code>operator()</code>, a the class defined by a lambda can (under the right circumstances) provide a conversion to a pointer to function. The circumstance (or at least the primary one) is that the lambda can't capture anything.</p>\n<p>If you add a capture:</p>\n<pre><code>auto f1 = get(\n              []() { std::cout &lt;&lt; \"lambda1::operator()()\\n\"; },\n              [i](int) { std::cout &lt;&lt; \"lambda2::operator()(int)\\n\"; }\n              );\nf1();\nf1(2);\n</code></pre>\n<p>...the conversion to <code>pointer to function</code> is no longer provided, so trying to compile the code above gives the error you probably expected all along:</p>\n<pre><code>trash9.cpp: In function 'int main(int, char**)':\ntrash9.cpp:49:9: error: no match for call to '(Overload&lt;main(int, char**)::&lt;lambda()&gt;, main(int, char**)::&lt;lambda(int)&gt; &gt;) (int)'\ntrash9.cpp:14:8: note: candidate is:\ntrash9.cpp:45:23: note: main(int, char**)::&lt;lambda()&gt;\ntrash9.cpp:45:23: note:   candidate expects 0 arguments, 1 provided\n</code></pre>\n", "LastActivityDate": "2013-08-25T19:01:49.857"}, "bq_ids": {"n4140": {"so_18432260_18432260_0": {"section_id": 5962, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_18432260_18432260_0": {"section_id": 5731, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_18432260_18432260_0": {"section_id": 7451, "quality": 0.7692307692307693, "length": 10}}}});