post_cb({"6703795": {"CommentCount": "1", "Body": "<p>On g++ 4.6.1 on the same Linux machine, <code>-Wall -ansi -pedantic</code> does not bring up any warnings.</p>\n<p>This point might not have been so high on compiler writers' agenda.  It looks so to me, looking at VS2003's and VS2008's behaviours, and, looking at g++ 3.3.3's behaviour you posted and g++ 4.6.1's behaviour I observed.</p>\n<p>Can you consider changing the <code>const</code> to a <code>private:</code>, non const?  That way, you will still have some control over who writes to it by not exporting a setter for it while, not generating compiler errors.</p>\n", "CreationDate": "2011-07-15T07:22:43.273", "ParentId": "6703288", "Id": "6703795", "LastActivityDate": "2011-07-15T07:22:43.273", "PostTypeId": "2", "Score": "1", "OwnerUserId": "346725"}, "6703484": {"CommentCount": "1", "Body": "<p>The standard is pretty clear. Having a <code>const</code> member doesn't bar a class from being an aggregate.</p>\n<p>8.5.1 [dcl.init.aggr]</p>\n<blockquote>\n<p id=\"so_6703288_6703484_0\">An <em>aggregate</em> is an array or a class (clause 9) with no user-declared constructors (12.1), no private or protected non-static data members (clause 11), no base classes (clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>It is legal to <em>copy-intialize</em> a <code>const</code> object and this is the initialization that aggregate initialization performs on the members of the aggregate. The restrictions on not naming a <code>const</code> object with no user-declared constructor in the <em>mem-initializer-list</em> in 12.6.2 apply only to initialization by a constructor which doesn't apply because aggregate initialization happens instead.</p>\n<p>As to why the older compilers fail, I don't know. I can only say that they don't conform to the standard in this respect.</p>\n", "CreationDate": "2011-07-15T06:33:35.203", "ParentId": "6703288", "Id": "6703484", "LastActivityDate": "2011-07-15T06:33:35.203", "PostTypeId": "2", "Score": "7", "OwnerUserId": "19563"}, "bq_ids": {"n4140": {"so_6703288_6703484_0": {"length": 12, "quality": 0.631578947368421, "section_id": 3298}}, "n3337": {"so_6703288_6703484_0": {"length": 12, "quality": 0.631578947368421, "section_id": 3168}}}, "6703486": {"CommentCount": "1", "Body": "<p>Question 1:</p>\n<p>Compilers published at different times implement different versions of C++. They are different approximations to a standard. All have vendor-specific \"additions\", i.e. allow non-portable code.</p>\n<ul>\n<li>BCC 5.2 was created before first C++ standard (ISO 14882:1998). </li>\n<li>VC++2003 is close to ISO 14882:1998, but also has some deficiencies, especially concerning templates.</li>\n<li>VC++2008 nearly implements ISO 14882:2003.</li>\n</ul>\n<p>Question 2:</p>\n<ul>\n<li>Try to get a modern compiler to your legacy system, if it's 32bit Windows.</li>\n<li>Try to compile on a modern machine and deploy the executable on your legacy system.</li>\n<li>If the legacy system is 16bit Windows, I don't see a solution.</li>\n</ul>\n", "CreationDate": "2011-07-15T06:34:15.313", "ParentId": "6703288", "Id": "6703486", "LastActivityDate": "2011-07-15T06:34:15.313", "PostTypeId": "2", "Score": "2", "OwnerUserId": "831725"}, "6703288": {"CreationDate": "2011-07-15T06:06:01.173", "ViewCount": "2657", "FavoriteCount": "1", "Id": "6703288", "AcceptedAnswerId": "6703484", "Score": "5", "Title": "Initializing const members of structs in C/C++... compiler dependent?", "LastEditorUserId": "845904", "CommentCount": "1", "Body": "<p>Recently I ran into a compiler error in a legacy environment using Borland C++ 5.2. I had a .cpp file which included a header from some C source which I don't control.  The header contained a struct definition which included const members, and the compiler complained about a \"constant member in class without constructors\". On investigation, this error seems to be compiler-dependent. Here's some sample code w/ results from various compilers:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct {\n   const float a;\n} _floater;\n\nint main()\n{\n   _floater f = {5.1F};\n\n   printf(\"%f\\r\\n\",f.a);\n\n   return 0;\n}\n</code></pre>\n<p><strong>Borland 5.2</strong></p>\n<pre class=\"none prettyprint-override\"><code>E:\\Projects\\Scratchpad&gt;bcc32 -P const_float.c\nBorland C++ 5.2 for Win32 Copyright (c) 1993, 1997 Borland International\nconst_float.c:\nError const_float.c 13: Constant member ' ::a' in class without constructors\n*** 1 errors in Compile ***\n</code></pre>\n<p><strong>Microsoft VS 2003 .NET:</strong></p>\n<pre class=\"none prettyprint-override\"><code>E:\\Projects\\Scratchpad&gt;cl /TP const_float.c\nMicrosoft (R) 32-bit C/C++ Optimizing Compiler Version 12.00.8804 for 80x86\nCopyright (C) Microsoft Corp 1984-1998. All rights reserved.\n\nconst_float.c\nconst_float.c(19) : error C2552: 'f' : non-aggregates cannot be initialized with\ninitializer list\n</code></pre>\n<p><strong>Microsoft VS 2008:</strong></p>\n<pre class=\"none prettyprint-override\"><code>C:\\Projects\\Scratchpad&gt;cl /TP const_float.c\nMicrosoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.21022.08 for 80x86\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nconst_float.c\nMicrosoft (R) Incremental Linker Version 9.00.21022.08\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n/out:const_float.exe\nconst_float.obj\n\nC:\\Projects\\Scratchpad&gt;const_float.exe\n5.100000\n</code></pre>\n<p><strong>G++ 3.3.3</strong></p>\n<pre class=\"none prettyprint-override\"><code>$ g++ const_float.c -o const_float.exe\nconst_float.c:25:2: warning: no newline at end of file\n\n$ ./const_float.exe\n5.100000\n</code></pre>\n<p>Note that Borland fails at the declaration of the struct, because it has a const member but no constructors, while VS 2003 is ok w/ the declaration, but complains when you try to instantiate it with an initializer list \u2013 considering the struct a non-aggregate type.  VS2008 and g++ are perfectly happy.\n[Apologies.. I just realized that the line #s in the errors are wrong because I stripped some commented-out lines before posting.]</p>\n<p>Microsoft\u2019s definition of aggregates is here: <a href=\"http://msdn.microsoft.com/en-us/library/0s6730bb.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/0s6730bb.aspx</a>. It\u2019s not apparent to me that const members would make a struct non-aggregate, but maybe they did back in 2003.</p>\n<p>It also appears that the latest Borland (Embarcadero) compiler treats this as a warning rather than an error: <a href=\"http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/devwin32/wrnmembnocons_xml.html\" rel=\"nofollow\">http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/devwin32/wrnmembnocons_xml.html</a> .</p>\n<p>So, 2 questions I guess:</p>\n<ol>\n<li>Why the variance in compilers? Is the standard ambiguous on this point?</li>\n<li>Any workarounds? Given that I'm stuck w/ the compiler version and the header file, I don't see any.</li>\n</ol>\n<p>Thanks!</p>\n", "Tags": "<c++>", "LastEditDate": "2011-07-15T06:38:49.027", "LastActivityDate": "2012-01-06T04:18:37.173", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "845904"}, "8753315": {"LastActivityDate": "2012-01-06T04:18:37.173", "CommentCount": "0", "Body": "<p>Just to add some extra information on the subject for MSVC and G++, and echoing exactly what @Charles Bailey, and @Ren\u00e9 Richter said; Its acceptable C++03, and C++11 but depending on the age and implementation state of your compiler you are going to get differing errors if at all.</p>\n<p>Actually I tried <a href=\"http://www.dinkumware.com/exam/\" rel=\"nofollow noreferrer\">Dinkum's online test compilers</a> for EDG, MSVC2008, and G++ and all compile the sample you gave but NOT the sample I give below.</p>\n<p>So in short <strong>fully initialized</strong> <em>structs with const members</em> will successfully compile on MSVC2008 and G++4.5, however of the tested compilers <strong>none can compile</strong> <em>\"partially initialized\" (or partially aggregate initialized)</em> POD structures even though that too is allowable in the C++ standard - I even contacted some G++ bug maintainers to make sure I was reading that standard correctly and they confirmed it should work even in current C++03 compilers.</p>\n<p>You can see related bugs for this on both <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=49132\" rel=\"nofollow noreferrer\">GNU Bugzilla</a> and over at <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/488660/improper-issuance-of-c4610\" rel=\"nofollow noreferrer\">Microsoft's Visual Studio help pages</a> which was actually linked from this <a href=\"https://stackoverflow.com/questions/7151298/why-do-i-get-these-warnings-in-visual-c-2008-when-building-a-struct\">other stackoverflow article titles \"why do I get this warnings in Visual Studio when building a struct?</a> which is also related to <a href=\"http://msdn.microsoft.com/en-us/library/yhh8tk4w.aspx\" rel=\"nofollow noreferrer\">Microsoft's Error C3852 as a known behavior of even MSVC2010</a></p>\n<pre><code>// All sections refer to Draft C++03 (brackets refer to draft C++11)\n//\n// 3.9.3 CV (const/volatile) definition as \"const data-type [= optional init]\"\n\n// 7.1.5.1/1 The cv-qualifiers  [ 7.1.6.1/1 in C++11 ]\n//    \"init-declarator-list of the declaration shall not be empty\"\nconst int constval = 10 ;\n\n// HOWEVER:\n// 7.1.5.1/2 The cv-qualifiers  [ 7.1.6.1 in C++11 ]\n//  [Note: as described in 8.5, the definition of an object or subobject\n//  of const-qualified type must specify an initializer or be subject to \n//  default-initialization. ]\n\n// 8.5 Initializers\n// 8.5/9  (C++11 8.5/11)\n//   Otherwise, if no initializer is specified for a non-static\n//   object, the object and its sub-objects, if any, have an indeterminate \n//   initial value(*90); if the object or any of its sub-objects are of \n//   const-qualified type, the program is ill-formed.\n//\n// *90: This does not apply to aggregate objects with automatic storage \n//      duration initialized with an incomplete brace-enclosed initializer list\n//      see 8.5.1.\n// [ C++11 this sub-clause has been removed, however the list-initializer section\n//   pretty much covers the same topic - see 8.5.1/7 below ]\n// \n// 8.5.1 Aggregate definition\n// 8.5.1/7 (C++11 8.5.1/7)\n//   If there are fewer initializers in the list than there are members in the \n//   aggregate, then each member not explicitly initialized shall be \n//   value-initialized (8.5).\n//\n//   8.5/5 value initialization\n//     if T is a class type (clause 9) with a user-declared constructor \n//     (12.1), then the default constructor for T is called (and the \n//     initialization is ill-formed if T has no accessible default constructor)\n//     ...\n//     otherwise, the object is zero-initialized\n//\n//   8.5/5 zero initialization\n//     if T is a scalar type (3.9), the object is set to the value of 0 (zero) converted to T;\n//\n\n// POD type\nstruct A {\n  int n ;\n  const int m ;  // \"const\" causes failure in MSVC to make default constructor\n} ;\n\n\n// Example of non-POD\nstruct B {\n  int bbb ;\n  B(){}\n} ;\n\n#include &lt;stdio.h&gt;\nint main() {\n  // C++03/11 ill formed code, fails as expected\n  const int c0 ;                        // per 7.1.5.1 \"not allowed to be default init\"\n\n  // OK\n  const int c = *new int ;              // A default initialized constant\n  const int c2 = *new int();            // A zero-init, above is DEFAULT-INIT\n  printf( \"c: %i\\n\", c ) ;              // should be an undef-value\n  printf( \"c2: %i\\n\", c2 ) ;            // should be 0\n\n  // OK ; Array example making sure it works\n  const int aa[5] = {}; // all items value-&gt;zero-initialized per the above 8.5.1/7\n  printf( \"aa: %i %i %i\\n\", aa[0], aa[2], aa[4] ) ;\n\n  // C++03/11 ill formed code, no initializer (G++/MSVC should fail)\n  A a0 ;                // Correct error - no default constructor or initializer (8.5/9)\n\n  // C++03/11 correctly formed code, full initializer list (G++/MSVC should pass)\n  A a1 = {1,2};         // Explicit initialization OK, G++/MSVC pass\n\n  // C++03/11 correctly formed code; copy initialized from a value-initialized A()\n  A a2 = A();           // G++ OK, MSVC FAIL\n\n  // C++03/11 correctly formed code; aggregate partial intializer (8.5.1/7 agg list init)\n  A a3 = {};            // G++/MSVC FAIL\n\n  A a4{};               // C++11 only - doesnt work in G++ (didnt try MSVC2010)\n\n  printf( \"a0.m=%i\\n\", a0.m ) ; // a0 should not exist due compile errors\n  printf( \"a1.m=%i\\n\", a1.m ) ; // a1.m should be 2\n  printf( \"a2.m=%i\\n\", a2.m ) ; // a2.m should be 0\n  printf( \"a3.m=%i\\n\", a3.m ) ; // a3.m should be 0\n\n  // C++03/11 correctly formed code; user-default constructor supplied.\n  const B bee1 ;         // Default constructor marks bbb as \"initialized\"\n  const B bee2 = {} ;    // CORRECTLY flagged error; init of non-aggregate\n  printf( \"%i\\n\", bee1.bbb ) ;  \n}\n</code></pre>\n", "CreationDate": "2012-01-06T04:18:37.173", "LastEditDate": "2017-05-23T12:16:34.657", "ParentId": "6703288", "Id": "8753315", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1120779"}});