post_cb({"bq_ids": {"n4140": {"so_29609955_29621984_1": {"length": 21, "quality": 1.0, "section_id": 191}, "so_29609955_29621984_0": {"length": 4, "quality": 1.0, "section_id": 72}}, "n3337": {"so_29609955_29621984_1": {"length": 21, "quality": 1.0, "section_id": 185}, "so_29609955_29621984_0": {"length": 4, "quality": 1.0, "section_id": 67}}, "n4659": {"so_29609955_29621984_1": {"length": 21, "quality": 1.0, "section_id": 196}, "so_29609955_29621984_0": {"length": 4, "quality": 1.0, "section_id": 200}}}, "29609955": {"ViewCount": "76", "Body": "<p>I have a problem with generalize my Interpreter design pattern. The BNF I would like to implement is:<br>\n&lt;expression&gt; ::= &lt;expression&gt; \" AND \" &lt;expression&gt; | &lt;literal&gt;<br>\n&lt;literal&gt; ::= \"A\" | \"B\" | 1 | 2  </br></br></p>\n<p>I'm talking about the following design pattern: <a href=\"https://sourcemaking.com/design_patterns/interpreter\" rel=\"nofollow\">Interpreter</a> </p>\n<p>The trick was that, I wanted to allow for LiteralExpression for return both int, and string type, but only string for Expression. That doesn't work, because that violates <a href=\"http://en.wikipedia.org/wiki/Liskov_substitution_principle\" rel=\"nofollow\">Liskov substitution principle</a>.  Next I tried to make the base class more generic. That looked good, and the \"only string\" version was compiling, I have added the int instances of LiteralExpression to the main. The code doesn't compile saying<br>\nno matching function for call to <code>Expression&lt;std::string&gt;::Expression(LiteralExpression&lt;int&gt;&amp;, LiteralExpression&lt;int&gt;&amp;)</code></br></p>\n<p>I think the problem is that, the<br>\n<code>Expression(Expression const &amp;leftExpression, Expression const rightExpression)</code><br>\nconstructor doesn't allow to have different template type of left and right expression than the <code>T</code> it was constructed with. I would have to exactly implement  </br></br></p>\n<pre><code>Expression(Expression&lt;int&gt; const &amp;leftExpression,\n           Expression&lt;int&gt; const &amp;rightExpression)  \nExpression(Expression&lt;int&gt; const &amp;leftExpression,\n           Expression&lt;string&gt; const &amp;rightExpression)  \nExpression(Expression&lt;string&gt; const &amp;leftExpression,\n           Expression&lt;int&gt; const &amp;rightExpression)  \nExpression(Expression&lt;string&gt; const &amp;leftExpression,\n           Expression&lt;string&gt; const &amp;rightExpression)  \n</code></pre>\n<p>versions. That is what I want to avoid. How can I do that?<br>\nIn the constructor the &lt;&lt; should take care of different types for me.  </br></p>\n<p>I have checked on the stack overflow comments that are somewhat related to my problem. I tried to understand and apply type erasure, but couldn't make it.</p>\n<p>I tried to make GetResult()'s type in Expression and LiteralExpression covariant (standard \u00a710.3 [class.virtual]/p7), so it's pointer. Didn't help (Is it totally unrelated?).</p>\n<p>Sorry for the long post. Please help.</p>\n<p>My code looks like this:  </p>\n<pre><code>// main.cpp  \n\n#include &lt;iostream&gt;\n#include \"LiteralExpression.h\"\nusing std::cout;\nusing std::endl;\nint main() {\n    LiteralExpression&lt;string&gt; a(\"A\");\n    LiteralExpression&lt;string&gt; b(\"B\");\n    Expression&lt;string&gt; shortExpression(a, b);\n    cout &lt;&lt; *shortExpression.GetResult() &lt;&lt; endl;\n    LiteralExpression&lt;int&gt; one(1);\n    LiteralExpression&lt;int&gt; two(2);\n    Expression&lt;string&gt; shortExpression2(one, two);\n    cout &lt;&lt; *shortExpression2.GetResult() &lt;&lt; endl;\n    return 0;\n}\n\n// LiteralExpression.h\n\n#ifndef LITERALEXPRESSION_H_\n#define LITERALEXPRESSION_H_\n#include \"Expression.h\"\n\ntemplate&lt;class T&gt;\nclass LiteralExpression: public Expression&lt;T&gt; {\npublic:\n    LiteralExpression(string literal) {\n        this-&gt;_result = (literal == \"A\" || literal == \"B\") ?  new string(literal) : new string(\"\");\n    }\n\n    LiteralExpression(int literal) {\n        this-&gt;_result = (literal == 1 || literal == 2) ? new int(literal) : new int(0);\n    }\n    virtual ~LiteralExpression() {\n        delete this-&gt;_result;\n    }\n    virtual T *GetResult() const {\n        return this-&gt;_result;\n    }\nprotected:\n    T *_result;\n};\n\n#endif /* LITERALEXPRESSION_H_ */\n\n// Expression.h:\n\n#ifndef EXPRESSION_H_\n#define EXPRESSION_H_\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing std::string;\nusing std::stringstream;\n\ntemplate&lt;class T&gt;\nclass Expression {\npublic:\n    virtual ~Expression() {\n        delete this-&gt;_result;\n    }\n\n    Expression(Expression const &amp;leftExpression, Expression const &amp;rightExpression) {\n        stringstream result;\n        result &lt;&lt; *(leftExpression.GetResult()) &lt;&lt; \" AND \" &lt;&lt; *(rightExpression.GetResult());\n        this-&gt;_result = new string(result.str());\n    }\n\n    // making it more generic by changing from\n    // virtual string *GetResult() const {\n    // to\n    virtual T *GetResult() const {\n        return this-&gt;_result;\n    }\n\nprotected:\n    T *_result;\n    Expression() {\n        this-&gt;_result = 0;\n    }\n};\n\n#endif /* EXPRESSION_H_ */\n</code></pre>\n", "AcceptedAnswerId": "29621984", "Title": "templated c++ arguments cannot find out type properly", "CreationDate": "2015-04-13T16:05:03.963", "Id": "29609955", "CommentCount": "4", "LastEditDate": "2015-04-13T16:31:17.603", "PostTypeId": "1", "LastEditorUserId": "434551", "LastActivityDate": "2015-04-14T08:06:35.273", "Score": "1", "OwnerUserId": "1859959", "Tags": "<c++><function><templates><arguments><matching>", "AnswerCount": "1"}, "29621984": {"Id": "29621984", "PostTypeId": "2", "Body": "<p>Your <code>LiteralExpression</code> class uses <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow\">CRTP</a></p>\n<pre><code>template&lt;class T&gt;\nclass LiteralExpression : public Expression&lt;T&gt;\n</code></pre>\n<p>and both <code>one</code> and <code>two</code> have <code>Expression&lt;int&gt;</code> as base class</p>\n<pre><code>LiteralExpression&lt;int&gt; one(1);\nLiteralExpression&lt;int&gt; two(2);\n</code></pre>\n<p>When passing them to an <code>Expression&lt;string&gt;</code> constructor</p>\n<pre><code>Expression&lt;string&gt; shortExpression2(one, two);\n\n// where\n\ntemplate&lt;class T&gt;\nclass Expression {\n  Expression(Expression const &amp;leftExpression, Expression const &amp;rightExpression) {\n</code></pre>\n<p>you're asking the same thing as:</p>\n<pre><code>template&lt;class T&gt;\nclass Expression {\n  Expression(Expression&lt;T&gt; const &amp;leftExpression, Expression&lt;T&gt; const &amp;rightExpression) {\n</code></pre>\n<p>since 14.6.2.1/1 says</p>\n<blockquote>\n<p id=\"so_29609955_29621984_0\">A name refers to the current instantiation if it is</p>\n<p id=\"so_29609955_29621984_1\">\u2014 in the definition of a class template, a nested class of a class\n  template, a member of a class template, or a member of a nested class\n  of a class template, the injected-class-name (Clause 9) of the class\n  template or nested class, [...]</p>\n</blockquote>\n<p>and obviously <code>Expression&lt;int&gt; != Expression&lt;string&gt;</code>.</p>\n<p>As a solution, in addition to resorting to a simpler inheritance design, regarding templates you could rather do something like</p>\n<pre><code>template&lt;class U, class V&gt; // Base classes could be anything and this works\nExpression(Expression&lt;U&gt; const &amp;leftExpression, Expression&lt;V&gt; const &amp;rightExpression) {\n</code></pre>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2015-04-14T08:06:35.273", "Score": "0", "CreationDate": "2015-04-14T07:56:56.713", "ParentId": "29609955", "CommentCount": "1", "LastEditDate": "2015-04-14T08:06:35.273", "OwnerUserId": "1938163"}});