post_cb({"bq_ids": {"n4140": {"so_34863148_34863709_1": {"length": 9, "quality": 1.0, "section_id": 5804}, "so_34863148_34863709_2": {"length": 17, "quality": 1.0, "section_id": 5804}, "so_34863148_34863709_9": {"length": 29, "quality": 0.90625, "section_id": 5834}, "so_34863148_34863709_8": {"length": 7, "quality": 1.0, "section_id": 5834}, "so_34863148_34863709_7": {"length": 4, "quality": 1.0, "section_id": 5834}, "so_34863148_34863709_6": {"length": 4, "quality": 1.0, "section_id": 5834}, "so_34863148_34863709_0": {"length": 4, "quality": 0.8, "section_id": 5804}, "so_34863148_34863709_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5804}}, "n3337": {"so_34863148_34863709_0": {"length": 4, "quality": 0.8, "section_id": 5577}, "so_34863148_34863709_1": {"length": 9, "quality": 1.0, "section_id": 5577}, "so_34863148_34863709_2": {"length": 17, "quality": 1.0, "section_id": 5577}, "so_34863148_34863709_9": {"length": 20, "quality": 0.625, "section_id": 5605}, "so_34863148_34863709_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 5577}}, "n4659": {"so_34863148_34863709_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7262}, "so_34863148_34863709_2": {"length": 17, "quality": 1.0, "section_id": 7262}, "so_34863148_34863709_9": {"length": 29, "quality": 0.90625, "section_id": 7296}, "so_34863148_34863709_8": {"length": 7, "quality": 1.0, "section_id": 7296}, "so_34863148_34863709_7": {"length": 4, "quality": 1.0, "section_id": 7296}, "so_34863148_34863709_6": {"length": 4, "quality": 1.0, "section_id": 7296}, "so_34863148_34863709_0": {"length": 4, "quality": 0.8, "section_id": 7262}, "so_34863148_34863709_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 7262}}}, "34863709": {"Id": "34863709", "PostTypeId": "2", "Body": "<ol>\n<li><p>Yes, the speculative assignment is possible. Modification of a non-volatile variable is not part of the observable behaviour of the program and thus a spurious write is allowed. (See below for the definition of \"observable behaviour\", which does not actually include all behaviour which you might observe.)</p></li>\n<li><p>No. If <code>output</code> is <code>volatile</code>, speculative or spurious mutations are not permitted because the mutation <em>is</em> part of observable behaviour. (Writing to -- or reading from -- a hardware register may have consequences other than just storing a value. This is one of the primary use cases of <code>volatile</code>.)</p></li>\n<li><p>(<strong>Edited</strong>) No, the speculative assignment is not possible with <code>atomic</code> <code>output</code>. Loads and stores of <code>atomic</code> variables are synchronized operations, so it should not be possible to load a value of such a variable which was not explicitly stored into the variable.</p></li>\n</ol>\n<h3>Observable behaviour</h3>\n<p>Although a program can do lots of obviously observable things (for example, abruptly terminating because of a segfault), the C and C++ standards only guarantee a limited set of results. <i>Observable behaviour</i> is defined in the C11 draft at \u00a75.1.2.3p6 and in the current C++14 draft at \u00a71.9p8 [intro.execution] with very similar wording:</p>\n<blockquote>\n<p id=\"so_34863148_34863709_0\">The least requirements on a conforming implementation are:</p>\n<p id=\"so_34863148_34863709_1\">\u2014 Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</p>\n<p id=\"so_34863148_34863709_2\">\u2014 At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.</p>\n<p id=\"so_34863148_34863709_3\">\u2014 The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-defined.</p>\n<p id=\"so_34863148_34863709_4\">These collectively are referred to as the <i>observable behavior</i> of the program.</p>\n</blockquote>\n<p>The above is taken from the C++ standard; the C standard differs in that in the second point it does not allow multiple possible results, and in the third point it explicitly references a relevant section of the standard library requirements. But details aside, the definitions are co-ordinated; for the purpose of this question, the relevant point is that only access to <em>volatile</em> variables is observable (up to the point that the value of a non-volatile variable is sent to an output device or file).</p>\n<h3>Data Races</h3>\n<p>This paragraph needs also to be read in the overall context of the C and C++ standards, which free the implementation from all requirements if the program engenders undefined behaviour. That's why the segfault is not considered in the definition of <em>observable behaviour</em> above: the segfault is a possible undefined behaviour but not a possible behaviour in a conformant program. So in the universe of only conformant programs and conformant implementations, there are no segfaults.</p>\n<p>That's important because a program with a data race is <em>not</em> conformant. A data race has undefined behaviour, even if it seems innocuous. And since it is the responsibility of the programmer to avoid undefined behaviour, the implementation may optimize without regard to data races.</p>\n<p>The exposition of the memory model in the C and C++ standards is dense and technical, and probably not suitable as an introduction to the concepts. (Browsing around the material on <a href=\"http://www.hboehm.info/\" rel=\"nofollow\">Hans Boehm's site</a> will probably prove less difficult.) Extracting quotes from the standard is risky, because the details are important. But here is a small leap into the morass, from the current C++14 standard, \u00a71.10 [intro.multithread]:</p>\n<blockquote>\n<ol start=\"6\">\n<li>Two expression evaluations conflict if one of them modifies a memory location and the other one reads or modifies the same memory location.</li>\n</ol>\n<p id=\"so_34863148_34863709_5\">\u2026</p>\n<ol start=\"23\">\n<li><p id=\"so_34863148_34863709_6\">Two actions are potentially concurrent if</p>\n<p id=\"so_34863148_34863709_7\">\u2014 they are performed by different threads, or</p>\n<p id=\"so_34863148_34863709_8\">\u2014 they are unsequenced, and at least one is performed by a signal handler.</p>\n<p id=\"so_34863148_34863709_9\">The execution of a program contains a data race if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other, except for the special case for signal handlers described below. Any such data race results in undefined behavior.</p></li>\n</ol>\n</blockquote>\n<p>The take-away here is that a read and a write of the same variable need to be synchronized; otherwise it is a data race and the result is undefined behaviour. Some programmers might object to the strictness of this prohibition, arguing that some data races are \"benign\". This is the topic of <a href=\"http://www.usenix.org/events/hotpar11/tech/final_files/Boehm.pdf\" rel=\"nofollow\">Hans Boehm's 2011 HotPar paper \"How to miscompile programs with \"benign\" data races\" (pdf)</a> (author's summary: \"There are no benign data races\"), and he explains it all much better than I could.</p>\n<p>Synchronization here includes the use of <code>atomic</code> types, so it is not a data race to concurrently read and modify an <code>atomic</code> variable. (The result of the read is unpredictable, but it must be either the value before the modification or the value afterwards.) This prevents the compiler from performing \"piecemeal\" modification of an atomic variable without some explicit synchronization.</p>\n<p>After some thought and more research, my conclusion is that the compiler cannot perform speculative writes to atomic variables either. Consequently, I modified the answer to question 3, which I had originally answered \"no\".</p>\n<p>Other useful references:</p>\n<ul>\n<li><p>Bartosz Milewski: <a href=\"http://bartoszmilewski.com/2014/10/25/dealing-with-benign-data-races-the-c-way/\" rel=\"nofollow\">Dealing with Benign Data Races the C++ Way</a></p>\n<p>Milewski deals with the precise issue of speculative writes to atomic variables, and concludes:</p>\n<blockquote>\n<p id=\"so_34863148_34863709_10\">Can\u2019t the compiler still do the same dirty trick, and momentarily store 42 in the <code>owner</code> variable? No, it can\u2019t! Since the variable is declared <code>atomic</code> the compiler can no longer assume that the write can\u2019t be observed by other threads.</p>\n</blockquote></li>\n<li><p>Herb Sutter on <a href=\"http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/\" rel=\"nofollow\">Thread Safety and Synchronization</a></p>\n<p>As usual, an accessible and well-written explanation.</p></li>\n</ul>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2016-01-19T17:23:45.550", "Score": "11", "CreationDate": "2016-01-18T20:42:09.253", "ParentId": "34863148", "CommentCount": "11", "OwnerUserId": "1566221", "LastEditDate": "2016-01-19T17:23:45.550"}, "34863148": {"ViewCount": "440", "Body": "<p>Please see the following code valid in C and C++:</p>\n<pre><code>extern int output;\nextern int input;\nextern int error_flag;\n\nvoid func(void)\n{\n  if (0 != error_flag)\n  {\n    output = -1;\n  }\n  else\n  {\n    output = input;\n  }\n}\n</code></pre>\n<ol>\n<li><p>Is the compiler allowed to compile the above code in the same way as if it looked like below?</p>\n<pre><code>extern int output;\nextern int input;\nextern int error_flag;\n\nvoid func(void)\n{\n  output = -1;\n  if (0 == error_flag)\n  {\n    output = input;\n  }\n}\n</code></pre>\n<p>In other words, is the compiler allowed to generate (from the first snippet) code that always makes a temporary assignment of -1 to <code>output</code> and then assign <code>input</code> value to <code>output</code> depending on <code>error_flag</code> status?</p></li>\n<li><p>Would the compiler be allowed to do it if <code>output</code> would be declared as volatile?</p></li>\n<li><p>Would the compiler be allowed to do it if <code>output</code> would be declared as <code>atomic_int</code> (stdatomic.h)?</p></li>\n</ol>\n<p>Update after David Schwartz's comment:</p>\n<p>If the compiler is free to add additional writes to a variable, it seems it is not possible to tell from the C code whether a data race exists or not. How to determine this?</p>\n", "AcceptedAnswerId": "34863709", "Title": "Compiler optimizations and temporary assignments in C and C++", "CreationDate": "2016-01-18T20:05:16.867", "Id": "34863148", "CommentCount": "11", "LastEditDate": "2016-01-19T09:22:27.200", "PostTypeId": "1", "LastEditorUserId": "1784168", "LastActivityDate": "2016-01-19T17:23:45.550", "Score": "10", "OwnerUserId": "1784168", "Tags": "<c++><c><concurrency><embedded>", "AnswerCount": "2"}, "34863911": {"Id": "34863911", "PostTypeId": "2", "Body": "<p>Yes, the compiler is allowed to do that kind of optimization. In general, you can assume that the compiler (and the CPU too) can reorder your code assuming it is running in a single thread. If you have more than one thread, you need to synchronize. If you don't synchronize and your code writes to a memory location that is written to or read by another thread, your code contains a data race, in C++ this is undefined behavior.</p>\n<p><code>volatile</code> doesn't change the data race problem. However IIRC, the compiler is not allowed to reorder reads and writes to a <code>volatile</code> variable.</p>\n<p>When using <code>atomic_int</code>, the compiler can still perform certain optimizations. I don't think that the compiler can invent writes though (that could break a multithreaded program). However, it can still reorder operations, so be careful.</p>\n", "LastActivityDate": "2016-01-18T20:55:54.340", "CommentCount": "4", "CreationDate": "2016-01-18T20:55:54.340", "ParentId": "34863148", "Score": "2", "OwnerUserId": "808241"}});