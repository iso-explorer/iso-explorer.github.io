post_cb({"bq_ids": {"n4140": {"so_21389403_21389563_0": {"length": 7, "quality": 1.0, "section_id": 252}, "so_21389403_21389685_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 264}}, "n3337": {"so_21389403_21389563_0": {"length": 7, "quality": 1.0, "section_id": 243}, "so_21389403_21389685_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 255}}, "n4659": {"so_21389403_21389563_0": {"length": 7, "quality": 1.0, "section_id": 259}, "so_21389403_21389403_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 180}}}, "21389563": {"Id": "21389563", "PostTypeId": "2", "Body": "<p>Bug in MSVC and Xcode.</p>\n<p>From 14.7.2 Explicit instantiation:</p>\n<blockquote>\n<p id=\"so_21389403_21389563_0\">An explicit instantiation shall appear in an enclosing namespace of\n  its template.</p>\n</blockquote>\n", "LastActivityDate": "2014-01-27T19:12:19.600", "CommentCount": "4", "CreationDate": "2014-01-27T19:12:19.600", "ParentId": "21389403", "Score": "1", "OwnerUserId": "2249683"}, "21389403": {"ViewCount": "137", "Body": "<p>I have this code:</p>\n<p>In A.h</p>\n<pre><code>namespace MyUtils \n{\n    class A \n    {\n       public:\n          A();\n          ~A();\n\n         template &lt;typename T&gt; Set(T val);\n         template &lt;typename T&gt; Set(T * val);\n\n    }\n\n    template &lt;typename T&gt;\n    void A::Set(T * val)\n    {\n\n    }\n}\n</code></pre>\n<p>In A.cpp, I have this</p>\n<pre><code>using namespace MyUtils;\n\ntemplate &lt;&gt;\nvoid A::Set&lt;int&gt;(int val)\n{\n}\n\ntemplate &lt;&gt;\nvoid A::Set&lt;char *&gt;(char * val)\n{\n\n}\n</code></pre>\n<p>This kind of logic compiles OK In MSVC or in Xcode. But on Linux, using gcc (g++), I got </p>\n<blockquote>\n<p id=\"so_21389403_21389403_0\">error: specialization of \u2018template void MyUtils::A::Set(T)\u2019\n  in different namespace</p>\n</blockquote>\n", "AcceptedAnswerId": "21389563", "Title": "Class - namespace and template member function specialisation", "CreationDate": "2014-01-27T19:03:10.277", "Id": "21389403", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-01-27T19:19:19.817", "Score": "0", "OwnerUserId": "1130231", "Tags": "<c++><templates><gcc>", "AnswerCount": "2"}, "21389685": {"Id": "21389685", "PostTypeId": "2", "Body": "<p>I also consider this as a bug because according to the C++ Standard ( section 14.7.3 Explicit specialization )</p>\n<blockquote>\n<p id=\"so_21389403_21389685_0\">2 An explicit specialization shall be declared in a namespace\n  enclosing the specialized template. An explicit specialization whose\n  declarator-id is not qualified shall be declared in the nearest\n  enclosing namespace of the template, or, if the namespace is inline\n  (7.3.1), any namespace from its enclosing namespace set. Such a\n  declaration may also be a definition. If the declaration is not a\n  definition, the specialization may be defined later (7.3.1.2).</p>\n</blockquote>\n<p>So you should use the fully qualified name</p>\n<pre><code>template &lt;&gt;\nvoid MyUtils::A::Set&lt;int&gt;(int val)\n{\n}\n</code></pre>\n", "LastActivityDate": "2014-01-27T19:19:19.817", "CommentCount": "1", "CreationDate": "2014-01-27T19:19:19.817", "ParentId": "21389403", "Score": "0", "OwnerUserId": "2877241"}});