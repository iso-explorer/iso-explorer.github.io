post_cb({"6170891": {"ParentId": "6170867", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-05-29T22:41:51.820", "Score": "12", "LastEditorUserId": "103167", "LastEditDate": "2011-05-30T00:48:54.473", "Id": "6170891", "OwnerUserId": "103167", "Body": "<p>It's because inside the body of class <code>Test&lt;Writer&gt;</code>, naming <code>Test</code> without providing the template arguments automatically assumes the same arguments (e.g. <code>Writer</code>).</p>\n<p>For example, this allows you to write the copy constructor as:</p>\n<pre><code>Test(const Test&amp;);\n</code></pre>\n<p>instead of</p>\n<pre><code>Test::Test(const Test&lt;Writer&gt;&amp;);\n</code></pre>\n<p>You can overcome this by qualifying <code>Test</code> with its namespace, e.g.</p>\n<pre><code> typedef TestHelper&lt; ::Test &gt;  Helper;\n</code></pre>\n<hr>\n<p>NOTE: As Tomalek suggests, the original usage is valid in C++0x.  Here is the relevant paragraph of the standard (emphasis mine), from section 14.6.1 (<code>[temp.local]</code>):</p>\n<blockquote>\n<p id=\"so_6170867_6170891_0\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9).  The injected-class-name can be used as a <em>template-name</em> or a <em>type-name</em>. <strong>When it is used</strong> with a <em>template-argument-list</em>, <strong>as a <em>template-argument</em> for a template <em>template-parameter</em></strong>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, <strong>it refers to the class template itself</strong>. Otherwise, it is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in &lt;&gt;.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2011-05-30T00:48:54.473"}, "6170867": {"CommentCount": "1", "ViewCount": "918", "CreationDate": "2011-05-29T22:37:22.013", "LastActivityDate": "2011-05-30T00:48:54.473", "Title": "c++ (g++-4.x) problem with templates", "AcceptedAnswerId": "6170891", "PostTypeId": "1", "Id": "6170867", "Score": "8", "Body": "<p>I have this simple code:</p>\n<pre><code>template&lt;template &lt;class&gt; class Generator&gt;\nclass TestHelper {};\n\ntemplate&lt;class Writer&gt;\nclass Test\n{\n    typedef TestHelper&lt; Test &gt;  Helper;  \n};\n</code></pre>\n<p>It's works great on last g++ versions, but, in 4.4 or 4.5, I get this error:</p>\n<pre><code>test.cpp:7: error: type/value mismatch at argument 1 in template parameter list for 'template&lt;template&lt;class&gt; class Generator&gt; class TestHelper' \ntest.cpp:7: error:   expected a class template, got 'Test&lt;Writer&gt;'\n</code></pre>\n<p>What I'm doing wrong?</p>\n", "Tags": "<c++><templates><g++>", "OwnerUserId": "305259", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_6170867_6170891_0": {"section_id": 179, "quality": 0.9736842105263158, "length": 37}}, "n3337": {"so_6170867_6170891_0": {"section_id": 173, "quality": 0.9736842105263158, "length": 37}}, "n4659": {"so_6170867_6170891_0": {"section_id": 184, "quality": 0.9736842105263158, "length": 37}}}, "6171316": {"ParentId": "6170867", "CommentCount": "2", "Body": "<p>@Ben is probably right, but here's a totally different way to get it to compile, that doesn't use templates as args to templates.</p>\n<pre><code>template&lt;class Generator&gt; // changed this to a simpler template\nclass TestHelper {};\n\ntemplate&lt;class Writer&gt;\nclass Test\n{\n            typedef TestHelper&lt; typename Test :: Writer &gt;  Helper; // 2nd change\n};\n</code></pre>\n<p>I made two changes. @Hugo, maybe this is what you wanted, and maybe this is what older versions of g++ did?</p>\n<p>It's easy to get code to compile, but that doesn't mean that it does what you think it does!</p>\n", "OwnerUserId": "146041", "PostTypeId": "2", "Id": "6171316", "Score": "1", "CreationDate": "2011-05-30T00:20:37.573", "LastActivityDate": "2011-05-30T00:20:37.573"}});