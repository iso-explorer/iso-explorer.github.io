post_cb({"bq_ids": {"n4140": {"so_39936865_39937432_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 585}}, "n3337": {"so_39936865_39937432_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 575}}, "n4659": {"so_39936865_39937432_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 608}}}, "39936865": {"ViewCount": "335", "Body": "<p>Consider this snippet of C++ code:</p>\n<pre><code>struct Foo {\n    float value;\n\n    operator float&amp; () {\n        return this-&gt;value;\n    }\n};\n\nint main() {\n    Foo foo;\n    foo=1.0f;   //Doesn't compile, foo isn't implicitly converted to a float&amp;\n\n    return 0;\n}\n</code></pre>\n<p>Why doesn't this compile? Is there a specific reason this wasn't included in the C++ standard? Or an equivalent does indeed exist and I'm just using it wrong?</p>\n", "AcceptedAnswerId": "39937432", "Title": "C++ Assign to implicitly converted lvalue", "CreationDate": "2016-10-08T20:07:39.177", "Id": "39936865", "CommentCount": "11", "LastEditDate": "2016-10-09T11:23:49.897", "PostTypeId": "1", "LastEditorUserId": "5884836", "LastActivityDate": "2016-10-09T11:32:30.653", "Score": "13", "OwnerUserId": "5884836", "Tags": "<c++><c++14>", "AnswerCount": "2"}, "39936989": {"Id": "39936989", "PostTypeId": "2", "Body": "<p>Implicit conversion is only done in the following cases:</p>\n<blockquote>\n<p id=\"so_39936865_39936989_0\">Implicit conversions are performed whenever an expression of some type\n  T1 is used in context that does not accept that type, but accepts some\n  other type T2; in particular:</p>\n<ul>\n<li>when the expression is used as the argument when calling a function that is declared with T2 as parameter;</li>\n<li>when the expression is used as an operand with an operator that expects T2;</li>\n<li>when initializing a new object of type T2, including return statement in a function returning T2;</li>\n<li>when the expression is used in a switch statement (T2 is integral type);</li>\n<li>when the expression is used in an if statement or a loop (T2 is bool).</li>\n</ul>\n</blockquote>\n<p>None of those is the case here. Instead the compiler is trying to find a suitable <code>operator=</code> to work with a <code>double</code>. To have this compile you need to overload that operator ( you actually want a <code>float</code> as seen in the code ):</p>\n<pre><code>Foo&amp; operator=(float other)\n{\n  value = f;\n  return *this;\n}\n</code></pre>\n<p>And change your assignment to <code>foo = 1.0f;</code></p>\n<p>Your conversion function would work with for example:</p>\n<pre><code>float f = foo;\n</code></pre>\n", "LastEditorUserId": "1870760", "LastActivityDate": "2016-10-08T20:25:20.517", "Score": "6", "CreationDate": "2016-10-08T20:22:15.730", "ParentId": "39936865", "CommentCount": "10", "OwnerUserId": "1870760", "LastEditDate": "2016-10-08T20:25:20.517"}, "39937432": {"Id": "39937432", "PostTypeId": "2", "Body": "<p>For pretty much all other operators, your conversion operator would do exactly what you want, and it would continue to do exactly what you want even if you add custom operators.</p>\n<pre><code>struct Foo {\n    float value;\n    operator float&amp; () { return this-&gt;value; }\n    Foo &amp;operator+=(Foo);\n};\nint main() {\n    Foo foo {};\n    foo+=1.0; // compiles and works\n    // equivalent to foo.operator float&amp;()+=1.0;\n}\n</code></pre>\n<p>However, <code>=</code> is special, the rules for <code>=</code> are different compared to most other operators. As identified by T.C.:</p>\n<blockquote>\n<p id=\"so_39936865_39937432_0\"><strong>13.3.1.2 Operators in expressions [over.match.oper]</strong></p>\n<p id=\"so_39936865_39937432_1\">4 For the built-in assignment operators, conversions of the left operand are restricted as follows:<br>\n  (4.1) -- no temporaries are introduced to hold the left operand, and<br>\n  (4.2) -- no user-defined conversions are applied to the left operand to achieve a type match with the left-most parameter of a built-in candidate.</br></br></p>\n</blockquote>\n<p>Together with the fact that any custom <code>operator=</code> is not allowed to be defined as a global function, this makes sure that <code>foo=bar;</code> where <code>foo</code> is a class type always means <code>foo.operator=(bar);</code>, nothing else.</p>\n<p>The fact that this one operator is singled out doesn't explain the reason, but does make it quite clear that it's an intentional decision, and making sure that <code>foo=bar;</code> always means <code>foo.operator=(bar);</code>, nothing else, by itself already seems like a valid reason.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2016-10-09T11:32:30.653", "Score": "7", "CreationDate": "2016-10-08T21:11:48.333", "ParentId": "39936865", "CommentCount": "9", "OwnerUserId": "743382", "LastEditDate": "2016-10-09T11:32:30.653"}});