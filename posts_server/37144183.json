post_cb({"37144875": {"ParentId": "37144183", "CommentCount": "2", "Body": "<p>I think the comments in the questions have the answer, and I'm not looking to claim credit here. </p>\n<p>I thought you might be interested in a 'nicer' way of performing the static cast's job without actually invoking a static cast or even needing to know the base class:</p>\n<p>first define this useful free function:</p>\n<pre><code>template&lt;class T&gt;\nauto shared_from_that(T* p)\n{\n  return std::shared_ptr&lt;T&gt;(p-&gt;shared_from_this(), p);\n}\n</code></pre>\n<p>Then get your correctly typed shared pointer in terms of it:</p>\n<pre><code>auto foo() {\n    return [ptr = shared_from_that(this)](){ \n      return ptr-&gt;bar(); \n    };\n}\n</code></pre>\n<p>Synopsis:</p>\n<p>Invokes the (seemingly widely unknown) 2-argument constructor of <code>std::shared_ptr</code> which uses the control block from the shared_ptr in arg1 and the pointer to the controlled object in arg2.</p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "37144875", "Score": "3", "CreationDate": "2016-05-10T17:09:43.560", "LastActivityDate": "2016-05-10T17:09:43.560"}, "37144183": {"CommentCount": "11", "ViewCount": "112", "PostTypeId": "1", "LastEditorUserId": "4987285", "CreationDate": "2016-05-10T16:30:23.497", "LastActivityDate": "2016-05-10T17:21:34.477", "Title": "Lambda expression, shared pointer and the type of this", "AcceptedAnswerId": "37144558", "LastEditDate": "2016-05-10T16:42:50.207", "Id": "37144183", "Score": "1", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;cassert&gt;\n\nstruct S: std::enable_shared_from_this&lt;S&gt; {\nprotected:\n    S() = default;\n\n    int bar() { return 42; }\n};\n\nstruct T: S {\n    static std::shared_ptr&lt;T&gt; create() {\n        return std::shared_ptr&lt;T&gt;(new T{});\n    }\n\n    auto foo() {\n        auto ptr = std::static_pointer_cast&lt;T&gt;(shared_from_this());\n        return [ptr](){ return ptr-&gt;bar(); };\n    }\n\nprivate:\n    T() = default;\n};\n\nint main() {\n    std::shared_ptr&lt;T&gt; ptr = T::create();\n    auto lambda = ptr-&gt;foo();\n    assert(lambda() == 42);\n}\n</code></pre>\n<p>The code above compiles. It does not if the method <code>foo</code> is modified as it follows:</p>\n<pre><code>auto foo() {\n    // In this case, there is no explicit cast\n    // The type of ptr is no longer std::shared_ptr&lt;T&gt;\n    // It is std::shared_ptr&lt;S&gt; instead \n    auto ptr = shared_from_this();\n    return [ptr](){ return ptr-&gt;bar(); };\n}\n</code></pre>\n<p>In this case, the code no longer compiles (neither with GCC nor with clang).</p>\n<p>Obviously it would compile after a cast (that is what I did in the first example), but I expected <code>bar</code> to be visible to the lambda even in this case, for it is reachable in its context and part of the interface of <code>S</code> as well.</p>\n<p>I suspect that it is due to <a href=\"http://eel.is/c++draft/expr.prim.lambda#8\" rel=\"nofollow\">5.1.5p8</a>, in particular:</p>\n<blockquote>\n<p id=\"so_37144183_37144183_0\">The lambda-expression's compound-statement yields the function-body [...] of the function call operator, but for [...], determining the type and value of <em>this</em> [...], the compound-statement is considered in the context of the lambda-expression.</p>\n</blockquote>\n<p>In fact, the error returned by clang is quite clear:</p>\n<blockquote>\n<p id=\"so_37144183_37144183_1\">main.cpp:8:9: note: can only access <em>this</em> member on an object of type <code>T</code></p>\n</blockquote>\n<p>Is my deduction right?<br>\nIs it due to the mentioned paragraph, thus to a problem of determined type for the <code>this</code> pointer that does not match with the one of the shared pointer?  </br></p>\n<p>The fact that a <code>shared_ptr</code> takes its part in the game makes it a bit harder to me to understand.<br>\nHonestly, I'd expect both the examples would compile or both would fail.</br></p>\n", "Tags": "<c++><lambda><c++14><shared-ptr>", "OwnerUserId": "4987285", "AnswerCount": "2"}, "37144558": {"ParentId": "37144183", "LastEditDate": "2016-05-10T17:21:34.477", "CommentCount": "1", "CreationDate": "2016-05-10T16:50:45.100", "OwnerUserId": "187690", "LastEditorUserId": "4987285", "PostTypeId": "2", "Id": "37144558", "Score": "3", "Body": "<p>It looks like you are simply violating the basic rules of protected access. I.e. the whole thing has nothing to do with lambdas or shared pointers. The good-old rules of protected access that have been around since the beginning of times say that protected members of base class are only accessible through objects of derived class. Contrary to what you stated above, in your context protected members of <code>S</code> are not accessible through objects of type <code>S</code>, but they are accessible through objects of type <code>T</code>.</p>\n<p>The whole thing can be reduced the the following simple example</p>\n<pre><code>struct S\n{\nprotected:\n  int i;\n};\n\nstruct T : S\n{\n    void foo()\n    {\n        this-&gt;i = 5; // OK, access through `T`\n\n        T t;\n        t.i = 5; // OK, access through `T`\n\n        S s;\n        s.i = 5; // ERROR: access through `S`, inaccessible\n\n        S *ps = this;\n        ps-&gt;i = 5; // ERROR: access through `S`, inaccessible\n    }\n};\n</code></pre>\n", "LastActivityDate": "2016-05-10T17:21:34.477"}, "bq_ids": {"n4140": {"so_37144183_37144183_1": {"section_id": 3260, "quality": 0.7142857142857143, "length": 5}, "so_37144183_37144183_0": {"section_id": 5966, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_37144183_37144183_1": {"section_id": 3132, "quality": 0.7142857142857143, "length": 5}, "so_37144183_37144183_0": {"section_id": 5735, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_37144183_37144183_1": {"section_id": 4018, "quality": 0.7142857142857143, "length": 5}, "so_37144183_37144183_0": {"section_id": 7460, "quality": 0.9333333333333333, "length": 14}}}});