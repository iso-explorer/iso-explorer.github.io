post_cb({"bq_ids": {"n4140": {"so_43852065_43852811_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 6173}}, "n3337": {"so_43852065_43852811_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 5934}}, "n4659": {"so_43852065_43852811_1": {"length": 12, "quality": 1.0, "section_id": 7408}, "so_43852065_43852811_3": {"length": 41, "quality": 0.6949152542372882, "section_id": 7408}}}, "43852065": {"ViewCount": "114", "Body": "<p>Consider the following types:</p>\n<pre><code>struct A { int x; };\nstruct B { int y; char z; };\nunion U { A a; B b; };\n</code></pre>\n<p>And this code fragment:</p>\n<pre><code>U u;\nnew (&amp;u.b) B;\nb.y = 42;\nb.z = 'x';\n</code></pre>\n<p>At this point, reading from <code>u.a.x</code> is well-defined behavior (and will yield <code>42</code>) because it's in the common initial sequence. <em>Writing</em> to <code>u.a.x</code> is undefined behavior. </p>\n<p>But gcc allows type-punning through a union - the docs explicitly allow reading the inactive member, regardless of member sequencing. Does gcc allow writing to an inactive member, even the common initial sequence, or would this still be undefined behavior on gcc? That is, if at this point, I had:</p>\n<pre><code>void write(A&amp; arg) { a.x = 17; }\nwrite(&amp;u.a); // generally undefined behavior, since active member is u.b\n             // but does gcc allow it?\nf(u.b.y);    // is this definitely f(17)?\ng(u.b.z);    // ... and is this definitely g('x')?\n</code></pre>\n", "Title": "Writing to Unions, with gcc", "CreationDate": "2017-05-08T15:52:25.457", "LastActivityDate": "2017-05-09T13:44:09.813", "CommentCount": "6", "LastEditDate": "2017-05-09T13:44:09.813", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "43852065", "Score": "7", "OwnerUserId": "2069064", "Tags": "<c++><gcc><g++><unions>", "AnswerCount": "1"}, "43852811": {"Id": "43852811", "PostTypeId": "2", "Body": "<p>The behavior you are describing (called \u201c<em>type-punning</em>\u201d) is allowed but is undefined by the C++ specification (see the note below). It might be defined under specific compiler and hardware.\nMore specifically, on gcc and x86 with simple types (char, short, float, double, ...) this will act as <em>reinterpret cast</em> between the different fields.</p>\n<blockquote>\n<p id=\"so_43852065_43852811_0\">...The practice of reading from a different union member than the one most recently written to (called \u201ctype-punning\u201d) is common. Even with <code>-fstrict-aliasing</code>, type-punning is allowed, provided the memory is accessed through the union type. (<a href=\"https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc/Optimize-Options.html\" rel=\"nofollow noreferrer\">source</a>)</p>\n</blockquote>\n<p>Furthermore, sometimes it is useful, for example when reading from a device (e.g. socket):</p>\n<pre><code>union {\n    struct {\n        int a;\n        char b;\n        short c;\n    } data;\n\n    char buf[128];\n} u;\n\nread_from_device(u.buf, 128);\nprintf(\"Data (a,b,c): (%d,%d,%d)\\n\", u.data.a, u.data.b, u.data.c);\n</code></pre>\n<p>First, we read the raw data from the device, then we use the struct to reinterpret it as numbers.\nWe often use <code>#pragma pack</code> on a <code>struct</code> to ensure the data is packed the same way it is packed on the device.</p>\n<h2>Note on Active Member</h2>\n<p>The determination of the active member is implicit and determined solely by the programmer, not the compiler. It is up to you to know which member is active.\nThe lifetime of the field starts when you assign to it.</p>\n<blockquote>\n<p id=\"so_43852065_43852811_1\">...the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment.</p>\n</blockquote>\n<p>The fact that the manual specifies that writing to a non-active field makes it active suggest that this is allowed.</p>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/union\" rel=\"nofollow noreferrer\">this</a> for more information:</p>\n<blockquote>\n<h1>Member lifetime</h1>\n<p id=\"so_43852065_43852811_2\">The lifetime of a union member begins when the member\n  is made active. If another member was active previously, its lifetime\n  ends.</p>\n<p id=\"so_43852065_43852811_3\">When active member of a union is switched by an assignment expression\n  of the form E1 = E2 that uses either the built-in assignment operator\n  or a trivial assignment operator, for each union member X that appears\n  in the member access and array subscript subexpressions of E1 that is\n  not a class with non-trivial or deleted default constructors, if\n  modification of X would have undefined behavior under type aliasing\n  rules, an object of the type of X is implicitly created in the\n  nominated storage; no initialization is performed and the beginning of\n  its lifetime is sequenced after the value computation of the left and\n  right operands and before the assignment.</p>\n</blockquote>\n<pre><code>union A { int x; int y[4]; };\nstruct B { A a; };\nunion C { B b; int k; };\nint f() {\n  C c;               // does not start lifetime of any union member\n  c.b.a.y[3] = 4;    // OK: \"c.b.a.y[3]\", names union members c.b and c.b.a.y;\n                     // This creates objects to hold union members c.b and c.b.a.y\n  return c.b.a.y[3]; // OK: c.b.a.y refers to newly created object\n}\n\nstruct X { const int a; int b; };\nunion Y { X x; int k; };\nvoid g() {\n  Y y = { { 1, 2 } }; // OK, y.x is active union member (9.2)\n  int n = y.x.a;\n  y.k = 4;   // OK: ends lifetime of y.x, y.k is active member of union\n  y.x.b = n; // undefined behavior: y.x.b modified outside its lifetime,\n             // \"y.x.b\" names y.x, but X's default constructor is deleted,\n             // so union member y.x's lifetime does not implicitly start\n}\n</code></pre>\n", "LastEditorUserId": "2570677", "LastActivityDate": "2017-05-09T13:41:09.963", "Score": "1", "CreationDate": "2017-05-08T16:31:56.033", "ParentId": "43852065", "CommentCount": "6", "OwnerUserId": "2570677", "LastEditDate": "2017-05-09T13:41:09.963"}});