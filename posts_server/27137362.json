post_cb({"27139030": {"ParentId": "27137362", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>(In my answer I use C++14 standard draft (N4140), which is a bit different from C++11 with regard to relevant quotes)</p>\n<p><code>reinterpret_cast&lt;const int*&gt;(values.data())</code> is fine because of <code>[class.mem]/19</code>:</p>\n<blockquote>\n<p id=\"so_27137362_27139030_0\">If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member. (...) [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>And regarding dereferencing, <code>[expr.reinterpret.cast]/7</code>:</p>\n<blockquote>\n<p id=\"so_27137362_27139030_1\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of object pointer type is converted to the object pointer type \u201cpointer to cv <code>T</code>\u201d, the result is <code>static_cast&lt;cv T*&gt;(static_cast&lt;cv void*&gt;(v))</code>.</p>\n</blockquote>\n<p>First <code>static_cast</code> is covered by <code>[conv.ptr]/2</code>:</p>\n<blockquote>\n<p id=\"so_27137362_27139030_2\">A prvalue of type \u201cpointer to cv <code>T</code>,\u201d where <code>T</code> is an object type, can be converted to a prvalue of type \u201cpointer\n  to cv <code>void</code>\u201d. The result of converting a non-null pointer value of a pointer to object type to a \u201cpointer to\n  cv <code>void</code>\u201d represents the address of the same byte in memory as the original pointer value.</p>\n</blockquote>\n<p>Second <code>static_cast</code> - <code>[expr.static.cast]/13</code>:</p>\n<blockquote>\n<p id=\"so_27137362_27139030_3\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue of type \u201cpointer to cv2 T,\u201d  (...) If the original pointer value represents the address A of a byte in memory and A satisfies the alignment requirement of T, then the resulting pointer value represents the same address as the original pointer value, that is, A.</p>\n</blockquote>\n<p>Alignment requirement is satisfied because of <code>[class.mem]/19</code>, so the cast works fine.</p>\n<hr>\n<p>But the problem is that there seem to be no guarantee that <code>sizeof(foo) == sizeof(int)</code> except aforementioned requirement for <code>std::complex</code>. One can interpret the note about unnamed padding from <code>[class.mem]/19</code> as allowing padding only if it's needed for alignment, so there must not be any padding in your case, but in my opinion that note is too vague in this regard.</p>\n<p>What you can do is put in your code</p>\n<pre><code>static_assert(sizeof(foo) == sizeof(int), \"\");\n// this may be paranoic but won't hurt\nstatic_assert(alignof(foo) == alignof(int), \"\");\n</code></pre>\n<p>So at least your code won't compile if the requirements are violated.</p>\n</hr>", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "LastEditDate": "2014-11-26T00:06:57.490", "Id": "27139030", "Score": "5", "CreationDate": "2014-11-25T23:57:25.317", "LastActivityDate": "2014-11-26T00:06:57.490"}, "27137362": {"CommentCount": "4", "ViewCount": "127", "PostTypeId": "1", "LastEditorUserId": "3959454", "CreationDate": "2014-11-25T21:47:34.143", "LastActivityDate": "2014-11-26T00:17:15.507", "Title": "Cast a pointer to struct to a pointer to the only member of that struct", "AcceptedAnswerId": "27139030", "LastEditDate": "2014-11-26T00:17:15.507", "Id": "27137362", "Score": "2", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct foo {\n    foo(int value)\n    : value_(value)\n    {\n        // perform range checks\n    }\n\n    int value() const {\n        return value_;\n    }\n\nprivate:\n    int value_;\n};\n\nint main() {\n    std::vector&lt;foo&gt; values{0, 1, 2, 3, 4, 5};\n\n    std::for_each(std::begin(values), std::end(values), \n                  [](foo&amp; f){ std::cout &lt;&lt; f.value(); });\n\n    std::cout &lt;&lt; std::endl;\n\n    std::for_each(reinterpret_cast&lt;const int*&gt;(values.data()),\n                  reinterpret_cast&lt;const int*&gt;(values.data()) + values.size(),\n                  [](int i){ std::cout &lt;&lt; i; });\n}\n</code></pre>\n<p>After compiling it with Apple LLVM version 6.0 (clang-600.0.54) (based on LLVM 3.5svn), it produces the following output (which is exactly what I want):</p>\n<pre><code>012345\n012345\n</code></pre>\n<p>The first iteration is trivial. The second iteration however is performed not through iterators, but through <em>pointers to the underlying storage which have been cast to <code>const int*</code></em>. </p>\n<p>My question is: <em>Is that code legal?</em></p>\n<p>My intuition is that it is. According to \u00a75.2.10/7 of the C++11 standard (final working draft):</p>\n<blockquote>\n<p id=\"so_27137362_27137362_0\">When a prvalue v of type \u201cpointer to <code>T1</code>\u201d is converted to the type\n  \u201cpointer to <em>cv</em><code>T2</code>\u201d, the result is <code>static_cast&lt;cvT2*&gt;(static_cast&lt;cvvoid*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are\n  standard-layout types (3.9) and the alignment requirements of <code>T2</code> are\n  no stricter than those of <code>T1</code></p>\n</blockquote>\n<p>If I interpret this correctly, then the code above should be correct, right? If not, can it be made to work?</p>\n", "Tags": "<c++><pointers><c++11><struct><strict-aliasing>", "OwnerUserId": "160206", "AnswerCount": "2"}, "27138452": {"ParentId": "27137362", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It is correct. A pointer to a struct may be cast to a pointer to it's first member, under certain conditions which are met here. It's a legacy holdover from C, as this was how totally-not-inheritance was implemented back then.</p>\n<p>This is specified in \u00a79.2/18 [class.mem]:</p>\n<blockquote>\n<p id=\"so_27137362_27138452_0\">A pointer to a standard-layout struct object, suitably converted using\n  a <code>reinterpret_cast</code>, points to its initial member (or if that member is\n  a bit-field, then to the unit in which it resides) and vice versa. [\n  <em>Note</em>: There might therefore be unnamed padding within a\n  standard-layout struct object, but not at its beginning, as necessary\n  to achieve appropriate alignment. \u2014 <em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "298661", "LastEditorUserId": "160206", "LastEditDate": "2014-11-25T23:51:37.320", "Id": "27138452", "Score": "2", "CreationDate": "2014-11-25T23:04:18.153", "LastActivityDate": "2014-11-25T23:51:37.320"}, "bq_ids": {"n4140": {"so_27137362_27139030_2": {"section_id": 40, "quality": 0.967741935483871, "length": 30}, "so_27137362_27139030_3": {"section_id": 6039, "quality": 0.9354838709677419, "length": 29}, "so_27137362_27137362_0": {"section_id": 6046, "quality": 0.7222222222222222, "length": 13}, "so_27137362_27139030_0": {"section_id": 5879, "quality": 0.9117647058823529, "length": 31}, "so_27137362_27138452_0": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}, "so_27137362_27139030_1": {"section_id": 6046, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_27137362_27139030_2": {"section_id": 37, "quality": 0.6129032258064516, "length": 19}, "so_27137362_27139030_3": {"section_id": 6967, "quality": 0.5161290322580645, "length": 16}, "so_27137362_27137362_0": {"section_id": 5814, "quality": 0.8888888888888888, "length": 16}, "so_27137362_27139030_0": {"section_id": 5650, "quality": 0.5588235294117647, "length": 19}, "so_27137362_27138452_0": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}, "so_27137362_27139030_1": {"section_id": 5814, "quality": 0.7391304347826086, "length": 17}}, "n4659": {"so_27137362_27139030_2": {"section_id": 7538, "quality": 0.5806451612903226, "length": 18}, "so_27137362_27139030_3": {"section_id": 7538, "quality": 0.8064516129032258, "length": 25}, "so_27137362_27137362_0": {"section_id": 7545, "quality": 0.7222222222222222, "length": 13}, "so_27137362_27139030_0": {"section_id": 7363, "quality": 0.9117647058823529, "length": 31}, "so_27137362_27138452_0": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}, "so_27137362_27139030_1": {"section_id": 7545, "quality": 0.8695652173913043, "length": 20}}}});