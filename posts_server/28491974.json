post_cb({"bq_ids": {"n4140": {"so_28491974_28492090_0": {"length": 23, "quality": 0.92, "section_id": 558}, "so_28491974_28492090_2": {"length": 39, "quality": 0.975, "section_id": 558}}, "n3337": {"so_28491974_28492090_0": {"length": 23, "quality": 0.92, "section_id": 549}, "so_28491974_28492090_2": {"length": 39, "quality": 0.975, "section_id": 549}}, "n4659": {"so_28491974_28492090_0": {"length": 23, "quality": 0.92, "section_id": 581}, "so_28491974_28492090_2": {"length": 39, "quality": 0.975, "section_id": 581}}}, "28491974": {"ViewCount": "100", "Body": "<p>case 1:\nyou can overload two functions namely:</p>\n<pre><code>void foo(int *);\nvoid foo(const int *);\n</code></pre>\n<p>while in ,\ncase 2:\nyou can not overload two functions:</p>\n<pre><code>void foo(int);\nvoid foo(const int);\n</code></pre>\n<p>I have coded and checked this concept and yet unable to find out the reason to this variation in overloading.</p>\n", "AcceptedAnswerId": "28492090", "Title": "concept of overloading in C++", "CreationDate": "2015-02-13T03:27:35.903", "Id": "28491974", "CommentCount": "3", "LastEditDate": "2015-02-13T04:04:48.817", "PostTypeId": "1", "LastEditorUserId": "207421", "LastActivityDate": "2015-02-13T04:04:48.817", "Score": "0", "OwnerUserId": "4264158", "Tags": "<c++><function><oop><overloading>", "AnswerCount": "3"}, "28492046": {"Id": "28492046", "PostTypeId": "2", "Body": "<p>In the second case, because integers are primitive type, the <code>int</code> or <code>const int</code> is passed by value, and the function makes a copy of the variable. Therefore, the function definition is the same. </p>\n<p>In the first case, the first function takes in an integer pointer as a parameter, whereas the second function takes in a pointer to a constant integer. These are different data types, as the value of the integer is not copied by the value of the pointer is, and therefore the data is passed by reference. </p>\n", "LastActivityDate": "2015-02-13T03:35:29.867", "CommentCount": "1", "CreationDate": "2015-02-13T03:35:29.867", "ParentId": "28491974", "Score": "0", "OwnerUserId": "4086967"}, "28491986": {"Id": "28491986", "PostTypeId": "2", "Body": "<p>Top level CV qualifications for formal arguments are ignored wrt. determining the function's type.</p>\n<p>(CV: <code>const</code> or <code>volatile</code>)</p>\n<p>One way to understand it is, there is no way a top level CV qualification of a formal argument can affect a caller of the function, and it can't affect the machine code. It's only about restrictions on the implementation. So given a declaration <code>void foo( int )</code> you can use <code>void foo( const int )</code> for the implementation, or vice versa, if you want.</p>\n", "LastActivityDate": "2015-02-13T03:29:11.050", "CommentCount": "2", "CreationDate": "2015-02-13T03:29:11.050", "ParentId": "28491974", "Score": "1", "OwnerUserId": "464581"}, "28492090": {"Id": "28492090", "PostTypeId": "2", "Body": "<p>From Standard \u00a713.1</p>\n<blockquote>\n<p id=\"so_28491974_28492090_0\">Parameter declarations that differ only in the <strong><em>presence or absence of\n  const and/or volatile are equivalent</em></strong>. That is, the const and volatile\n  type-specifiers for each parameter type are ignored when determining\n  which function is being declared, defined, or called. [ Example:</p>\n</blockquote>\n<pre><code>typedef const int cInt;\nint f (int);\nint f (const int); // redeclaration of f(int)\nint f (int) { /* ... */ } // definition of f(int)\nint f (cInt) { /* ... */ } // error: redefinition of f(int)\n</code></pre>\n<blockquote>\n<p id=\"so_28491974_28492090_1\">\u2014end example ]</p>\n<p id=\"so_28491974_28492090_2\">Only the const and volatile type-specifiers at the outermost level of\n  the parameter type specification are ignored in this fashion; const\n  and volatile type-specifiers buried within a parameter type\n  specification are significant and can be used to distinguish\n  overloaded function declarations. In particular, for any type T,\n  <strong><em>\u201cpointer to T,\u201d \u201cpointer to const T,\u201d</em></strong> and \u201cpointer to volatile T\u201d <strong><em>are\n  considered distinct parameter types,</em></strong> as are \u201creference to T,\u201d\n  \u201creference to const T,\u201d and \u201creference to volatile T.\u201d</p>\n</blockquote>\n", "LastActivityDate": "2015-02-13T03:40:18.613", "CommentCount": "0", "CreationDate": "2015-02-13T03:40:18.613", "ParentId": "28491974", "Score": "1", "OwnerUserId": "1870232"}});