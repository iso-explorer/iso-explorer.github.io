post_cb({"3179812": {"ParentId": "3179494", "PostTypeId": "2", "CommentCount": "13", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_3179494_3179812_1\">Are there any other circumstances where they[destructors] will not be called?</p>\n</blockquote>\n</blockquote>\n<ol>\n<li>Long jumps: these interfere with the natural stack unwinding process and often lead to undefined behavior in C++.</li>\n<li>Premature exits (you already pointed these out, though it's worth noting that throwing while already stack unwinding as a result of an exception being thrown leads to undefined behavior and this is why we should never throw out of dtors)</li>\n<li>Throwing from a constructor does not invoke the dtor for a class. This is why, if you allocate multiple memory blocks managed by several different pointers (and not smart pointers) in a ctor, you need to use function-level try blocks or avoid using the initializer list and have a try/catch block in the ctor body (or better yet, just use a smart pointer like scoped_ptr since any member successfully initialized so far in an initializer list will be destroyed even though the class dtor will not be called).</li>\n<li>As pointed out, failing to make a dtor virtual when a class is deleted through a base pointer could fail to invoke the subclass dtors (undefined behavior).</li>\n<li>Failing to call matching operator delete/delete[] for an operator new/new[] call (undefined behavior - may fail to invoke dtor).</li>\n<li>Failing to manually invoke the dtor when using placement new with a custom memory allocator in the deallocate section.</li>\n<li>Using functions like memcpy which only copies one memory block to another without invoking copy ctors. mem* functions are deadly in C++ as they bulldoze over the private data of a class, overwrite vtables, etc. The result is typically undefined behavior.</li>\n<li>Instantiation of some of smart pointers (auto_ptr) on an incomplete type, see this <a href=\"https://stackoverflow.com/questions/12323028/c-destructor-not-being-called-depending-on-the-linking-order\">discussion</a></li>\n</ol>\n", "OwnerUserId": "374980", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:57.707", "Id": "3179812", "Score": "44", "CreationDate": "2010-07-05T13:23:48.070", "LastActivityDate": "2012-09-10T08:32:39.313"}, "3179738": {"ParentId": "3179494", "CommentCount": "1", "Body": "<p>Another case they won't be called is if you are using polymorphism and have not made your base destructors virtual.</p>\n", "OwnerUserId": "141985", "PostTypeId": "2", "Id": "3179738", "Score": "3", "CreationDate": "2010-07-05T13:14:04.070", "LastActivityDate": "2010-07-05T13:14:04.070"}, "3179588": {"ParentId": "3179494", "CommentCount": "0", "Body": "<p>There are basically two situations, where destructors are called: On stack unwind at the end of function (or at exceptions), if someone (or a reference counter) calls delete.</p>\n<p>One special situation is to be found in static objects - they are destructed at the end of the program via at_exit, but this is still the 2nd situation.</p>\n<p>Which signal leaves at_exit going through may depend, kill -9 will kill the process immediately, other signals will tell it to exit but how exactly is dependent on the signal callback.</p>\n", "OwnerUserId": "335385", "PostTypeId": "2", "Id": "3179588", "Score": "1", "CreationDate": "2010-07-05T12:53:41.700", "LastActivityDate": "2010-07-05T12:53:41.700"}, "3180040": {"ParentId": "3179494", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If a function or method has a throws specification, and throws something NOT covered by the specification, the default behavior is to exit immediately.  The stack is not unwound and destructors are not called.</p>\n<p>POSIX signals are an operating system specific construct and have no notion of C++ object scope.  Generally you can't do anything with a signal except maybe, trap it, set a global flag variable, and then handle it later on in your C++ code after the signal handler exits.  </p>\n<p>Recent versions of GCC allow you to throw an exception from within synchronous signal handlers, which does result in the expected unwinding and destruction process. This is very operating system and compiler specific, though</p>\n", "OwnerUserId": "60191", "LastEditorUserId": "60191", "LastEditDate": "2010-07-05T14:09:50.930", "Id": "3180040", "Score": "2", "CreationDate": "2010-07-05T13:59:17.103", "LastActivityDate": "2010-07-05T14:09:50.930"}, "3179546": {"ParentId": "3179494", "CommentCount": "0", "Body": "<p><a href=\"http://www.cplusplus.com/reference/clibrary/cstdlib/abort/\" rel=\"nofollow noreferrer\"><code>abort</code></a> terminates program without executing destructors for objects of automatic or static storage duration as Standard says. For other situations you should read implementation specific documents.</p>\n", "OwnerUserId": "123111", "PostTypeId": "2", "Id": "3179546", "Score": "2", "CreationDate": "2010-07-05T12:47:24.217", "LastActivityDate": "2010-07-05T12:47:24.217"}, "21346442": {"ParentId": "3179494", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A lot of answers here but still incomplete!</p>\n<p>I found another case where destructors are not executed. This happens always when the exception is catched across a library boundary.</p>\n<p>See more details here:</p>\n<p><a href=\"https://stackoverflow.com/questions/21346400/destructors-not-executed-no-stack-unwinding-when-exception-is-thrown\">Destructors not executed (no stack unwinding) when exception is thrown</a></p>\n", "OwnerUserId": "1487529", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:49.353", "Id": "21346442", "Score": "2", "CreationDate": "2014-01-25T04:02:55.903", "LastActivityDate": "2014-02-01T02:19:12.123"}, "3179559": {"CommentCount": "9", "CreationDate": "2010-07-05T12:49:11.033", "LastEditorUserId": "1094609", "LastActivityDate": "2017-02-15T01:56:43.053", "ParentId": "3179494", "LastEditDate": "2017-02-15T01:56:43.053", "LastEditorDisplayName": "anon", "PostTypeId": "2", "Id": "3179559", "Score": "7", "Body": "<p>The C++ standard says nothing about how specific signals must be handled - many implementations may not support <code>SIGINT</code>, etc. Destructors will not be called if <code>exit()</code> or <code>abort()</code> or <code>terminate()</code> are called. </p>\n<p><strong>Edit:</strong> I've just had a quick search through the C++ Standard and I can't find anything that specifies how signals interact with object lifetimes - perhaps someone with better standards-fu than me could find something? </p>\n<p><strong>Further edit:</strong> While answering another question, I found this in the Standard:</p>\n<blockquote>\n<p id=\"so_3179494_3179559_0\">On exit from a scope (however\n  accomplished), destructors (12.4) are\n  called for all constructed objects\n  with automatic storage duration\n  (3.7.2) (named objects or temporaries)\n  that are declared in that scope, in\n  the reverse order of their\n  declaration. </p>\n</blockquote>\n<p>So it seems that destructors must be called on receipt of a signal.</p>\n", "OwnerDisplayName": "anon"}, "3179558": {"ParentId": "3179494", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A signal <em>by itself</em> won't affect the execution of <em>the current thread</em> and hence the invocation of destructors, because it is a different execution context with its own stack, where your objects do not exist. It's like an interrupt: it is handled somewhere outside of your execution context, and, if handled, the control is returned to your program.</p>\n<p>Same as with multithreading, C++ <em>the language</em> does not know a notion of signals. These two are completely orthogonal to each other and are specified by two unrelated standards. How they interact is up to the implementation, as long as it does not break either of the standards.</p>\n<p>As a side note, another case is when object's destructor won't be called is when its constructor throws an exception. Members' destructors will still be called, though.</p>\n", "OwnerUserId": "23643", "LastEditorUserId": "23643", "LastEditDate": "2010-07-05T23:27:13.703", "Id": "3179558", "Score": "3", "CreationDate": "2010-07-05T12:49:05.953", "LastActivityDate": "2010-07-05T23:27:13.703"}, "bq_ids": {"n4140": {"so_3179494_3179559_0": {"section_id": 3909, "quality": 0.5217391304347826, "length": 12}}, "n3337": {"so_3179494_3179559_0": {"section_id": 3769, "quality": 0.5217391304347826, "length": 12}}, "n4659": {"so_3179494_3179559_0": {"section_id": 4795, "quality": 0.5217391304347826, "length": 12}}}, "3179494": {"CommentCount": "3", "AcceptedAnswerId": "3179812", "CreationDate": "2010-07-05T12:39:52.107", "LastActivityDate": "2017-02-15T01:56:43.053", "PostTypeId": "1", "ViewCount": "12457", "FavoriteCount": "19", "Title": "Under what circumstances are C++ destructors not going to be called?", "Id": "3179494", "Score": "39", "Body": "<p>I know that my destructors are called on normal unwind of stack and when exceptions are thrown, but not when exit() is called.</p>\n<p>Are there any other cases where my destructors are not going to get called?  What about signals such as SIGINT or SIGSEGV?  I presume that for SIGSEGV, they are not called, but for SIGNINT they are, how do I know which signals will unwind the stack?</p>\n<p>Are there any other circumstances where they will not be called?</p>\n", "Tags": "<c++><exception><signals><destructor><exit>", "OwnerUserId": "115751", "AnswerCount": "8"}});