post_cb({"bq_ids": {"n4140": {"so_15443675_15443758_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 336}}, "n3337": {"so_15443675_15443758_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 326}}, "n4659": {"so_15443675_15443758_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 345}}}, "15443758": {"Id": "15443758", "PostTypeId": "2", "Body": "<p>You are trying to deduce type <code>T</code> from a <strong>non-deduced context</strong>. </p>\n<p>The presence of the double colon in the parameter's dependent type usually gives you hint that you won't be able to deduce the type of that parameter (unless you have other deduced contexts in the same function call that help, but here you have just one argument). </p>\n<p>From Paragraph 14.8.2.5/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15443675_15443758_0\">The non-deduced contexts are:</p>\n<p id=\"so_15443675_15443758_1\">\u2014 The nested-name-specifier of a type that was specified using a qualified-id.</p>\n<p id=\"so_15443675_15443758_2\">[...]</p>\n</blockquote>\n<p>If you need a concrete example, <strong><a href=\"https://stackoverflow.com/questions/6060824/c-template-argument-can-not-be-deduced\">this Q&amp;A on StackOverflow</a></strong> provides a pretty good one. In this case, you could provide the type argument explicitly:</p>\n<pre><code>myfunc&lt;Byref&lt;int&gt;&gt;(arg);\n</code></pre>\n<p>Alternatively, you can choose one of the two workarounds proposed in <a href=\"https://stackoverflow.com/questions/8308213/workaround-for-non-deduced-context\"><strong>this second Q&amp;A</strong></a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-03-15T23:34:56.490", "Score": "1", "CreationDate": "2013-03-15T23:34:56.490", "ParentId": "15443675", "CommentCount": "1", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T11:50:09.677"}, "15443675": {"ViewCount": "145", "Body": "<p>I am new to c++ templates. I am writing a set of functions that can manipulate two different template classes. One needs to always be passed by value, the other must be passed by reference because it represents a huge amount of data.</p>\n<p>Here is a simplified example. If the arg is tagged a ref type, I want the function signature to be defined as taking it by const ref.</p>\n<pre><code>template&lt;bool B, typename, typename T2&gt;\nstruct if_ {};\n\ntemplate&lt;typename T1, typename T2&gt;\nstruct if_&lt;true, T1, T2&gt; {\n    typedef T1 type;\n};\n\ntemplate&lt;typename T1, typename T2&gt;\nstruct if_&lt;false, T1, T2&gt; {\n    typedef T2 type;\n};\n\nstruct ByvalTypeTag {};\ntemplate&lt;typename T&gt;\nclass Byval : public ByvalTypeTag \n{\n    T somedata;\n};\n\nstruct ByrefTypeTag {};\ntemplate&lt;typename T&gt;\nclass Byref : public ByrefTypeTag\n{\n    T somedata;\n};\n\ntemplate&lt;typename T&gt;\nvoid myfunc(typename if_&lt;std::is_base_of&lt;ByrefTypeTag, T&gt;::value, const T&amp;, T&gt;::type arg)\n{\n\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    Byref&lt;int&gt; arg;\n    myfunc( arg );\n    return 0;\n}\n</code></pre>\n<p>The error I get is:</p>\n<p>error C2783: 'void myfunc(if_::value,const T&amp;,T&gt;::type)' : could not deduce template argument for 'T'</p>\n<p>Maybe this is the wrong way of going about it. If possible I am trying to cut down on the number of relatively duplicate templates I am writing for the same function.</p>\n", "Title": "selection of c template function parameter type", "CreationDate": "2013-03-15T23:26:41.803", "LastActivityDate": "2013-03-15T23:48:21.460", "CommentCount": "1", "PostTypeId": "1", "Id": "15443675", "Score": "0", "OwnerUserId": "2175242", "Tags": "<c++><function><templates>", "AnswerCount": "3"}, "15443883": {"Id": "15443883", "PostTypeId": "2", "Body": "<p>You can forward the parameter with this implementation.</p>\n<pre><code>template&lt;typename T&gt;\nvoid myfunc_impl(T arg)\n{\n    // Do the work here.\n}\n\ntemplate&lt;typename T&gt;\nvoid myfunc(const T &amp;arg, typename std::enable_if&lt;std::is_base_of&lt;ByrefTypeTag, T&gt;::value&gt;::type* = 0)\n{\n  myfunc_impl&lt;const T&amp;&gt;( arg ); // Pass a const ref\n}\n\ntemplate&lt;typename T&gt;\nvoid myfunc(const T &amp;arg, typename std::enable_if&lt;std::is_base_of&lt;ByvalTypeTag, T&gt;::value&gt;::type* = 0)\n{\n  myfunc_impl&lt;T&gt;( arg );        // Pass a copy\n}\n</code></pre>\n", "LastActivityDate": "2013-03-15T23:48:21.460", "CommentCount": "1", "CreationDate": "2013-03-15T23:48:21.460", "ParentId": "15443675", "Score": "0", "OwnerUserId": "16287"}, "15443751": {"Id": "15443751", "PostTypeId": "2", "Body": "<p>Yeah, compiler cannot deduce the type.  You'll need to provide it with T yourself:</p>\n<pre><code>myfunc&lt;ByRef&lt;int&gt;&gt;(arg);\n</code></pre>\n<p>Alternatively you can use the more usual tag-dispatching system:</p>\n<pre><code>class byref\n{\n    typedef byref_tag tag;\n    ...\n};\n\ntemplate &lt; typename T &gt;\nvoid fun(T const&amp; t, byref_tag) { ... }\n\ntemplate &lt; typename T &gt;\nvoid fun(T t, byval_tag) { ... }\n\ntemplate &lt; typename T &gt;\nvoid fun(T const&amp; t)\n{\n    typedef typename T::tag tag;\n    fun(t,tag());\n}\n</code></pre>\n<p>Yet another alternative would involve a wrapper function and class template.  Either way though the outer function has to be by ref.</p>\n", "LastActivityDate": "2013-03-15T23:34:06.287", "CommentCount": "0", "CreationDate": "2013-03-15T23:34:06.287", "ParentId": "15443675", "Score": "1", "OwnerUserId": "301883"}});