post_cb({"8549489": {"ParentId": "8549406", "CommentCount": "2", "Body": "<p>A complete solution to your problem probably is impossible. But I can suggest you a solution, if you want to restrict <code>K</code> to be a specific type you can define your class as follows</p>\n<pre><code>template &lt;class K, bool = std::is_same&lt;K,int&gt;::value&gt;\nclass Foo { ... };\n\ntemplate &lt;class K&gt;\nclass Foo&lt;K,false&gt; { Foo(); };\n</code></pre>\n<p>So if <code>K</code> is <code>int</code> your class works as expected. Otherwise you can not costruct object of type <code>Foo&lt;K&gt;</code>. Obviously you can refine the condition.</p>\n<p>To check if <code>K</code> has the <code>operator&lt;</code> you can use <code>boost::has_less</code>, but as you can check in the <a href=\"http://www.boost.org/doc/libs/1_48_0/libs/type_traits/doc/html/boost_typetraits/reference/has_less.html\" rel=\"nofollow\">documentation</a> this traits doesn't work properly always.</p>\n", "OwnerUserId": "235120", "PostTypeId": "2", "Id": "8549489", "Score": "2", "CreationDate": "2011-12-18T02:46:30.627", "LastActivityDate": "2011-12-18T02:46:30.627"}, "8549777": {"ParentId": "8549406", "CommentCount": "7", "Body": "<p>It depends on what you mean by \"complies.\"  If you want to verify that <code>K</code> has a <code>&lt;</code> operator then you might try the <a href=\"http://www.boost.org/doc/libs/release/libs/concept_check/concept_check.htm\">Boost Concept Checking Library</a>.</p>\n<pre><code>#include \"boost/concept_check.hpp\"\n\ntemplate&lt; typename K &gt;\nclass Foo\n{\n  BOOST_CONCEPT_ASSERT((boost::LessThanComparable&lt; K &gt;));\n\n  // lots of other code here...\n\n  private:\n    std::map&lt; K, size_t &gt; m_map;\n};\n</code></pre>\n<p>However if you want to verify that <code>&lt;</code> defines a StrictWeakOrdering on <code>K</code>, that would require testing run-time behaviour under all possible inputs.</p>\n", "OwnerUserId": "484307", "PostTypeId": "2", "Id": "8549777", "Score": "6", "CreationDate": "2011-12-18T04:16:07.253", "LastActivityDate": "2011-12-18T04:16:07.253"}, "8549406": {"CommentCount": "3", "AcceptedAnswerId": "8549777", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2011-12-18T02:25:29.677", "LastActivityDate": "2012-04-06T10:52:43.243", "LastEditDate": "2012-04-06T10:52:43.243", "ViewCount": "389", "FavoriteCount": "1", "Title": "How do I constrain a template parameter to comply to a Key in std::map?", "Id": "8549406", "Score": "2", "Body": "<p>I have a class template that intends to use its parameter K as the key to a map.</p>\n<p><strong>Is there any way to restrict the template parameter to be a type that complies with the Key in std::map?</strong></p>\n<p>I realize that even without such constraint, the compiler would spit out a pile of template errors like K having no <code>operator &lt; ()</code>, but it would be nice if I can make my code more obvious in specifying requirements.</p>\n<p>C++11 solutions are welcome.</p>\n<pre><code>template&lt; typename K &gt;\nclass Foo\n{\n  // lots of other code here...\n\n  private:\n    std::map&lt; K, size_t &gt; m_map;\n};\n</code></pre>\n", "Tags": "<c++><templates><c++11><constraints><stdmap>", "OwnerUserId": "975129", "AnswerCount": "4"}, "8549824": {"ParentId": "8549406", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>C++11 version:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class T&gt;\nstruct satisfies_key_req{\n  struct nat{};\n\n  template&lt;class K&gt; static auto test(K* k) -&gt; decltype(*k &lt; *k);\n  template&lt;class K&gt; static nat  test(...);\n\n  static bool const value = !std::is_same&lt;decltype(test&lt;T&gt;(0)), nat&gt;::value;\n};\n\n#include &lt;iostream&gt;\n\nstruct foo{};\n\nint main(){\n    static bool const b = satisfies_key_req&lt;int&gt;::value;\n    std::cout &lt;&lt; b &lt;&lt; '\\n';\n    static bool const b2 = satisfies_key_req&lt;foo&gt;::value;\n    std::cout &lt;&lt; b2 &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>1\n0\n</code></pre>\n<hr>\n<p>The key point I used here is <em>expression SFINAE</em>: <code>auto test(K* k) -&gt; decltype(*k &lt; *k)</code>. If the expression in the trailing-return-type is not valid, then this particular overload of <code>test</code> is removed from the overload set. In other words, it's SFINAE'd.</p>\n<p><code>\u00a714.8.2 [temp.deduct]</code></p>\n<blockquote>\n<p id=\"so_8549406_8549824_0\">p6 <strong>At certain points in the template argument deduction process it is necessary to take a function type that makes use of template parameters and replace those template parameters with the corresponding template arguments.</strong> This is done at the beginning of template argument deduction when any explicitly specified template arguments are substituted into the function type, and <strong>again at the end of template argument deduction when any template arguments that were deduced or obtained from default arguments are substituted</strong>.</p>\n<p id=\"so_8549406_8549824_1\">p7 <strong>The substitution occurs in all types and expressions</strong> that are used in the function type and in template parameter declarations. <strong>The expressions include not only constant expressions</strong> such as those that appear in array bounds or as nontype template arguments <strong>but also general expressions</strong> (i.e., non-constant expressions) <strong>inside</strong> <code>sizeof</code>, <strong><code>decltype</code></strong>, and other contexts that allow non-constant expressions.</p>\n<p id=\"so_8549406_8549824_2\">p8 If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments. [...]</p>\n</blockquote>\n<hr>\n<p>You can use it in three flavors for your <code>Foo</code> class to trigger an error.</p>\n<pre><code>// static_assert, arguably the best choice\ntemplate&lt; typename K &gt;\nclass Foo\n{\n  static_assert&lt;satisfies_key_req&lt;K&gt;::value, \"K does not satisfy key requirements\");\n  // lots of other code here...\n\n  private:\n    std::map&lt; K, size_t &gt; m_map;\n};\n\n// new-style SFINAE'd, maybe not really clear\ntemplate&lt;\n  typename K,\n  typename = typename std::enable_if&lt;\n               satisfies_key_req&lt;K&gt;::value\n             &gt;::type\n&gt;\nclass Foo\n{\n  // lots of other code here...\n\n  private:\n    std::map&lt; K, size_t &gt; m_map;\n};\n\n// partial specialization, clarity similar to SFINAE approach\ntemplate&lt; \n  typename K,\n  bool = satisfies_key_req&lt;K&gt;::value\n&gt;\nclass Foo\n{\n  // lots of other code here...\n\n  private:\n    std::map&lt; K, size_t &gt; m_map;\n};\n\ntemplate&lt;typename K&gt;\nclass Foo&lt;K, false&gt;;\n</code></pre>\n</hr></hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-12-18T17:36:27.493", "Id": "8549824", "Score": "4", "CreationDate": "2011-12-18T04:31:04.983", "LastActivityDate": "2011-12-18T17:36:27.493"}, "bq_ids": {"n4140": {"so_8549406_8549824_2": {"section_id": 300, "quality": 1.0, "length": 18}, "so_8549406_8549824_1": {"section_id": 299, "quality": 0.9473684210526315, "length": 36}, "so_8549406_8549824_0": {"section_id": 298, "quality": 0.98, "length": 49}}, "n3337": {"so_8549406_8549824_2": {"section_id": 291, "quality": 1.0, "length": 18}, "so_8549406_8549824_1": {"section_id": 290, "quality": 0.9473684210526315, "length": 36}, "so_8549406_8549824_0": {"section_id": 289, "quality": 0.98, "length": 49}}, "n4659": {"so_8549406_8549824_0": {"section_id": 305, "quality": 0.98, "length": 49}, "so_8549406_8549824_1": {"section_id": 306, "quality": 0.9473684210526315, "length": 36}, "so_8549406_8549824_2": {"section_id": 307, "quality": 1.0, "length": 18}}}, "8549810": {"ParentId": "8549406", "CommentCount": "1", "Body": "<p>From your question, I guess you want one suitable error instead of loads of errors.</p>\n<p>Following code finds, if a type has a valid <code>operator &lt;</code> or not:</p>\n<pre><code>namespace OperatorExist\n{\n  typedef char no[3]; // '3' can be any awkward number\n  template&lt;typename T&gt; no&amp; operator &lt; (const T&amp;, const T&amp;);\n\n  template&lt;typename T&gt;\n  struct LessThan {\n    static const bool value = (sizeof(*(T*)(0) &lt; *(T*)(0)) != sizeof(no));\n  };\n}\n</code></pre>\n<p>Now, you can specialize <code>class Foo</code> using the above construct:</p>\n<pre><code>template&lt;typename K, bool = OperatorExist::LessThan&lt;K&gt;::value&gt;\nclass Foo \n{\n  // lots of other code here...\n  private:\n    std::map&lt;K, size_t&gt; m_map;\n};\n\ntemplate&lt;typename K&gt;\nclass Foo&lt;K, false&gt;; // unimplemented for types not suitable for 'std::map'\n</code></pre>\n<p>As soon as you use some type <code>A</code> which doesn't have compatibility with <code>std::map</code>, the compiler will complain with single error:</p>\n<pre><code>error: aggregate \u2018Foo&lt;A&gt; oa\u2019 has incomplete type and cannot be defined\n</code></pre>\n<p><a href=\"http://www.ideone.com/vEKyp\" rel=\"nofollow\">Demo</a></p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "8549810", "Score": "1", "CreationDate": "2011-12-18T04:26:36.907", "LastActivityDate": "2011-12-18T04:26:36.907"}});