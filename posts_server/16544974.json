post_cb({"16544974": {"ViewCount": "3338", "Body": "<p>I've done some reseach like:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/10651161/overloading-operator-cannot-bind-lvalue-to-stdbasic-ostreamchar\">Overloading operator&lt;&lt;: cannot bind lvalue to \u2018std::basic_ostream&amp;&amp;\u2019</a></li>\n<li><a href=\"https://stackoverflow.com/questions/15625042/overloading-operator-cannot-bind-stdbasic-ostreamchar-lvalue-to-stdb\">Overloading operator&lt;&lt;: cannot bind \u2018std::basic_ostream\u2019 lvalue to \u2018std::basic_ostream&amp;&amp;\u2019</a></li>\n<li><a href=\"https://stackoverflow.com/questions/13347530/error-cannot-bind-stdbasic-ostreamchar-lvalue-to-stdbasic-ostreamchar\">error: cannot bind \u2018std::basic_ostream\u2019 lvalue to \u2018std::basic_ostream&amp;&amp;\u2019</a></li>\n</ul>\n<p>Tell me if I misunderstood some.</p>\n<p>I was trying to input std::pair from a file and I wanted to use std::istream_iterator &gt;</p>\n<p>Here comes the code:</p>\n<pre><code>std::ifstream in(\"file.in\");\n\nstd::map&lt;int, int&gt; pp; \npp.insert((std::istream_iterator&lt;std::pair&lt;int, int&gt; &gt;(in)),\n        std::istream_iterator&lt;std::pair&lt;int, int&gt; &gt;());\n</code></pre>\n<p>I did the overloading as following:</p>\n<pre><code>std::istream &amp; operator&gt;&gt;(std::istream &amp; in, std::pair&lt;int, int&gt; &amp; pa)\n{ in &gt;&gt; pa.first &gt;&gt; pa.second; return in; }\n\nstd::istream &amp; operator&gt;&gt;(std::istream &amp;&amp; in, std::pair&lt;int, int&gt; &amp; pa)\n{ in &gt;&gt; pa.first &gt;&gt; pa.second; return in; }\n</code></pre>\n<p>Here's the Error:</p>\n<pre><code>In file included from /usr/include/c++/4.8/iterator:66:0,\n                 from No_12.cpp:7:\n/usr/include/c++/4.8/bits/stream_iterator.h: In instantiation of \u2018void std::istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;::_M_read() [with _Tp = std::pair&lt;int, int&gt;; _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Dist = long int]\u2019:\n/usr/include/c++/4.8/bits/stream_iterator.h:70:17:   required from \u2018std::istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;::istream_iterator(std::istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;::istream_type&amp;) [with _Tp = std::pair&lt;int, int&gt;; _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Dist = long int; std::istream_iterator&lt;_Tp, _CharT, _Traits, _Dist&gt;::istream_type = std::basic_istream&lt;char&gt;]\u2019\nNo_12.cpp:23:59:   required from here\n/usr/include/c++/4.8/bits/stream_iterator.h:121:17: error: cannot bind \u2018std::istream_iterator&lt;std::pair&lt;int, int&gt; &gt;::istream_type {aka std::basic_istream&lt;char&gt;}\u2019 lvalue to \u2018std::basic_istream&lt;char&gt;&amp;&amp;\u2019\n      *_M_stream &gt;&gt; _M_value;\n                 ^   \nIn file included from /usr/include/c++/4.8/iostream:40:0,\n                 from /files/Nutstore/000/CPPWorkSpace/SHUCourse/DataStructures/BinarySearchTree/20130514/src/BinarySearchTree.hpp:6,\n                 from /files/Nutstore/000/CPPWorkSpace/SHUCourse/DataStructures/BinarySearchTree/20130514/BinarySearchTree:3,\n                 from No_12.cpp:1:\n/usr/include/c++/4.8/istream:872:5: error:   initializing argument 1 of \u2018std::basic_istream&lt;_CharT, _Traits&gt;&amp; std::operator&gt;&gt;(std::basic_istream&lt;_CharT, _Traits&gt;&amp;&amp;, _Tp&amp;) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Tp = std::pair&lt;int, int&gt;]\u2019\n     operator&gt;&gt;(basic_istream&lt;_CharT, _Traits&gt;&amp;&amp; __is, _Tp&amp; __x)\n</code></pre>\n<p>I don't know what I can do now...\nHope that someone can give me some advice.\nThanks.</p>\n", "Title": "Overloading istream_iterator ---- cannot bind lvalue to \u2018std::basic_istream<char>&&\u2019", "CreationDate": "2013-05-14T13:47:09.043", "LastActivityDate": "2013-05-14T16:20:27.893", "CommentCount": "13", "LastEditDate": "2017-05-23T12:15:00.503", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "16544974", "Score": "2", "OwnerUserId": "2381889", "Tags": "<c++>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16544974_16546151_0": {"length": 6, "quality": 1.0, "section_id": 215}}, "n3337": {"so_16544974_16546151_0": {"length": 6, "quality": 1.0, "section_id": 209}}, "n4659": {"so_16544974_16546151_0": {"length": 6, "quality": 1.0, "section_id": 223}}}, "16546151": {"Id": "16546151", "PostTypeId": "2", "Body": "<p>To understand what's the problem, we have to take a look at an exemplary implementation of <code>istream_iterator</code> (the problem arises from the requirements of the Standard, which are implicitly shown here):</p>\n<pre><code>template &lt; class T, class CharT, class Traits, class Distance &gt;\nclass istream_iterator\n{\n    /* ... */\n    typedef std::basic_istream&lt;CharT, Traits&gt;  istream_type;\n    istream_type* stored_istream_ptr;\n    T value;\n\npublic:\n    /* ... */\n    istream_iterator&amp; operator++()\n    {\n        *stored_istream_ptr &gt;&gt; value; // (A)\n        return *this;\n    }\n    T const&amp; operator*() const\n    {\n        return value;\n    }\n    /* ... */\n};\n</code></pre>\n<p>In line (A), an operator is applied to objects of dependent types:</p>\n<ul>\n<li><code>value</code> is of type <code>T</code></li>\n<li><code>stored_istream_ptr</code> is of type <code>istream_type</code>, see the typedef</li>\n</ul>\n<p>According to [temp.dep.type]/8, both types are dependent.</p>\n<p>For the expression <code>A &gt;&gt; B</code> as well as for any other function call, first the name of the function is looked up (here: <code>operator&gt;&gt;</code>) -&gt; <em>name lookup</em>, then, from the set of found functions (overloads), the most viable is chosen and called -&gt; <em>overload resolution</em>.</p>\n<p>For an operator, both member and non-member functions (such as your operators) are looked up.</p>\n<p>In this case, the involved types are dependent, therefore special rules for <strong>name</strong> lookup apply [temp.dep.res]/1:</p>\n<blockquote>\n<p id=\"so_16544974_16546151_0\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li>Declarations that are visible at the point of definition of the template.</li>\n<li>Declarations from namespaces associated with the types of the function arguments both from the instantiation context (14.6.4.1) and from the definition context.</li>\n</ul>\n</blockquote>\n<p>Your operators have been defined in the global namespace, which is not associated to neither <code>std::basic_istream</code> nor <code>std::pair</code>. Therefore, <strong>name</strong> resolution does not find your operators and <strong>overload</strong> resolution for the expression in line (A) fails.</p>\n<hr>\n<p>This would explain clang 3.2's error message:</p>\n<blockquote>\n<p id=\"so_16544974_16546151_1\">stream_iterator.h:120:17: error: invalid operands to binary expression ('istream_type' (aka 'basic_istream &lt; char, std::char_traits &gt;') and 'std::pair')</p>\n<pre><code>       *_M_stream &gt;&gt; _M_value;\n       ~~~~~~~~~~ ^  ~~~~~~~~\n</code></pre>\n</blockquote>\n<p>And it explains why the workarounds work.</p>\n<p>g++ on the other hand seems to only show one overload found by name resolution and the reason it's rejecting it (whereas clang++ shows <strong>all</strong> overloads found by name resolution with a reason for every single one why it has been rejected). The one g++ shows might be the \"best fitting\":</p>\n<pre><code>template&lt; class CharT, class Traits, class T &gt;\nbasic_istream&lt;CharT,Traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;CharT,Traits&gt;&amp;&amp;, T&amp;);\n</code></pre>\n<p>Which is, AFAIK, just a wrapper to call the other <code>operator&gt;&gt;</code> in the case the expression <code>istream_obj &gt;&gt; value</code> operates on a rvalue (like <code>get_istream() &gt;&gt; value</code>).</p>\n<p>This is unrelated to your problem (and confusing).</p>\n<hr>\n<p>Two workarounds:</p>\n<ul>\n<li>use a wrapper type to wrap <code>std::pair</code> such that you can define the <code>operator&gt;&gt;</code> in a namespace associated with that wrapper type</li>\n<li>inject your operators in namespace std (not recommended??)</li>\n</ul>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-05-14T16:20:27.893", "Score": "2", "CreationDate": "2013-05-14T14:40:04.160", "ParentId": "16544974", "CommentCount": "3", "OwnerUserId": "420683", "LastEditDate": "2013-05-14T16:20:27.893"}});