post_cb({"18486996": {"ParentId": "18486598", "CommentCount": "0", "CreationDate": "2013-08-28T11:46:51.523", "OwnerUserId": "947836", "PostTypeId": "2", "Id": "18486996", "Score": "5", "Body": "<p>It is an optimization, the only one that is allowed to alter observable behaviour of a program.</p>\n<p>Here's the paragraph <code>12.8./31</code>, taken from standard draft n3337 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18486598_18486996_0\">When certain criteria are met, <strong>an implementation is allowed to omit the copy/move construction of a class\n  object, even if the copy/move constructor and/or destructor for the object have side effects.</strong> In such cases,\n  the implementation treats the source and target of the omitted copy/move operation as simply two different\n  ways of referring to the same object, and the destruction of that object occurs at the later of the times\n  when the two objects would have been destroyed without the optimization.\n  This elision of copy/move\n  operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to \n  eliminate multiple copies):  </p>\n<blockquote>\n<p id=\"so_18486598_18486996_6\">\u2014 in a return statement in a function with a class return type, when the expression is the name of a\n    non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-\n    unquali\ufb01ed type as the function return type, the copy/move operation can be omitted by constructing\n    the automatic object directly into the function\u2019s return value  </p>\n<p id=\"so_18486598_18486996_7\">\u2014 in a throw-expression, when the operand is the name of a non-volatile automatic object (other than a\n    function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n    enclosing try-block (if there is one), the copy/move operation from the operand to the exception\n    object (15.1) can be omitted by constructing the automatic object directly into the exception object  </p>\n<p id=\"so_18486598_18486996_8\">\u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n    to a class object with the same cv-unquali\ufb01ed type, the copy/move operation can be omitted by\n    constructing the temporary object directly into the target of the omitted copy/move  </p>\n<p id=\"so_18486598_18486996_9\">\u2014 when the exception-declaration of an exception handler (Clause 15) declares an object of the same type\n    (except for cv-quali\ufb01cation) as the exception object (15.1), the copy/move operation can be omitted\n    by treating the exception-declaration as an alias for the exception object if the meaning of the program\n    will be unchanged except for the execution of constructors and destructors for the object declared by\n    the exception-declaration.  </p>\n</blockquote>\n<p id=\"so_18486598_18486996_5\">[Example... omitted]</p>\n</blockquote>\n<p>The semantics of a copy/move constructor are just that, copying/moving the contents of an object while initializing another one. If your copy constructors send emails with invitations to your birthday party you should not be surprised if you end up partying alone :)</p>\n<p>OK, some copy constructors do other things, too. Think reference counting of a smart pointer. But if that gets optimized away, it's fine. There was no copy and nothing needed to be counted.</p>\n", "LastActivityDate": "2013-08-28T11:46:51.523"}, "18487088": {"ParentId": "18486598", "CommentCount": "0", "CreationDate": "2013-08-28T11:51:08.343", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "18487088", "Score": "2", "Body": "<p>Since copying/moving temporary objects has a cost, compilers are explicitly allowed to elide temporary objects, even if the corresponding constructors or destructors have side-effects. Copy/move elision is typically not considered an optimization and most compilers elide construction of temporary objects even in debug mode (which is reasonable as you don't want to have different behavior between debug and optimized builds).</p>\n<p>The relevant clause in the C++11 standard is 12.8 [class.copy] paragraph 31:</p>\n<blockquote>\n<p id=\"so_18486598_18487088_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects. ...</p>\n</blockquote>\n<p>The cases where copy/move elision is allowed are:</p>\n<ul>\n<li>in return statements</li>\n<li>in <code>throw</code> expressions</li>\n<li>when a temporary is not bound to a reference</li>\n<li>in the <code>catch</code> clause</li>\n</ul>\n<p>The exact rules have a few extra conditions.</p>\n", "LastActivityDate": "2013-08-28T11:51:08.343"}, "18486767": {"ParentId": "18486598", "CommentCount": "0", "CreationDate": "2013-08-28T11:36:30.943", "OwnerUserId": "24913", "PostTypeId": "2", "Id": "18486767", "Score": "3", "Body": "<p>I believe you are experiencing Copy Elision.  And thus yes, it is optimizations.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Copy_elision</a></p>\n<blockquote>\n<p id=\"so_18486598_18486767_0\">In C++ computer programming, copy elision refers to a compiler\n  optimization technique that eliminates unnecessary copying of objects.\n  The C++ language standard generally allows implementations to perform\n  any optimization, provided the resulting program's observable behavior\n  is the same as if, i.e. pretending, the program was executed exactly\n  as mandated by the standard.</p>\n<p id=\"so_18486598_18486767_1\">The standard also describes a few situations where copying can be\n  eliminated <strong>even if this would alter the program's behavior</strong>, the most\n  common being the return value optimization.</p>\n</blockquote>\n<p>The emphasis is mine.</p>\n", "LastActivityDate": "2013-08-28T11:36:30.943"}, "18487073": {"ParentId": "18486598", "CommentCount": "2", "CreationDate": "2013-08-28T11:50:32.427", "OwnerUserId": "2722567", "PostTypeId": "2", "Id": "18487073", "Score": "0", "Body": "<p>To prevent copy illision implement the assignment operator with the copy/swap algorithm like:</p>\n<pre><code>Object &amp;operator =(Object other)\n{\n    std::swap(*this, other);\n    return *this;\n}\n</code></pre>\n<p>And then try:</p>\n<pre><code>Object a;\na = test();\n</code></pre>\n<p>That way the copy (or move) ctor will be called by the compiler when it passes the object into the assignment operator.</p>\n", "LastActivityDate": "2013-08-28T11:50:32.427"}, "18486598": {"CommentCount": "9", "ViewCount": "493", "PostTypeId": "1", "LastEditorUserId": "2112028", "CreationDate": "2013-08-28T11:28:22.343", "LastActivityDate": "2013-08-28T11:51:08.343", "Title": "C++ unexpected behaviour (where are my temporaries!?)", "LastEditDate": "2013-08-28T11:44:07.483", "Id": "18486598", "Score": "4", "Body": "<p>This was an r-value experiment but it mutated when gcc whined to me about lack of move-constructor (I'd deleted it) and didn't fall-back to the copy constructor (as I expected)\nI then removed -std=c++11 from the flags and tried what you see below, it has a lot of output (it didn't initially) because I am trying to work out why exactly it doesn't work (I know how to debug but I find messages on stdout to be a good indicator of something happening)</p>\n<p>Here's my code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Object {\npublic:\n    Object() { id=nextId; std::cout &lt;&lt; \"Creating object: \"&lt;&lt;id&lt;&lt;\"\\n\"; nextId++; }\n    Object(const Object&amp; from) {\n         id=nextId; std::cout &lt;&lt; \"Creating object: \"&lt;&lt;id&lt;&lt;\"\\n\"; nextId++;\n        std::cout&lt;&lt;\"(Object: \"&lt;&lt;id&lt;&lt;\" created from Object: \"&lt;&lt;from.id&lt;&lt;\")\\n\";\n    }\n    Object&amp; operator=(const Object&amp; from) {\n        std::cout&lt;&lt;\"Assigning to \"&lt;&lt;id&lt;&lt;\" from \"&lt;&lt;from.id&lt;&lt;\"\\n\";\n        return *this;\n    }\n    ~Object() { std::cout&lt;&lt;\"Deconstructing object: \"&lt;&lt;id&lt;&lt;\"\\n\";}\n\nprivate:\n    static int nextId;\n    int id;\n};\n\nint Object::nextId = 0;\n\nObject test();\n\nint main(int,char**) {\n    Object a;\n    std::cout&lt;&lt;\"A ought to exist\\n\";\n    Object b(test());\n    std::cout&lt;&lt;\"B ought to exist\\n\";\n    Object c = test();\n    std::cout&lt;&lt;\"C ought to exist\\n\";\n    return 0;\n}\n\n\nObject test() {\n    std::cout&lt;&lt;\"In test\\n\";\n    Object tmp;\n    std::cout&lt;&lt;\"Test's tmp ought to exist\\n\";\n    return tmp;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Creating object: 0\nA ought to exist\nIn test\nCreating object: 1\nTest's tmp ought to exist\nB ought to exist\nIn test\nCreating object: 2\nTest's tmp ought to exist\nC ought to exist\nDeconstructing object: 2\nDeconstructing object: 1\nDeconstructing object: 0\n</code></pre>\n<p>I use deconstructing, because deconstruction is already a word, sometimes I use destructor, I'm never quite happy with the word, I favour destructor as the noun.</p>\n<p>Here's what I expected:</p>\n<pre><code>A to be constructed\ntmp in test to be constructed, a temporary to be created from that \n    tmp, tmp to be destructed(?) \nthat temporary to be the argument to B's copy constructor\nthe temporary to be destructed.\nC's default constructor to be used\n\"\" with a temporary from `test`\nC's assignment operator to be used\nthe temporary to be destructed\nc,b,a to be destructed.\n</code></pre>\n<p>I have been called \"die-hard C\" and I am trying to learn to use C++ as more than \"C with namespaces\".</p>\n<p>Someone might say \"the compiler optimises it out\" I'd like that person never to answer a question with such an answer now or ever, optimisations must not alter the program state, it must be <em>as if</em> everything happened as the specification says, so the compiler may humor me by putting a message on cout that includes the number, it may not bother to even increase the number and such, but the output of the program would be the same as if it did do everything the code describes.</p>\n<p>So it's not optimisations, what's going on? </p>\n", "Tags": "<c++>", "OwnerUserId": "2112028", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_18486598_18486996_1": {"section_id": 480, "quality": 0.9714285714285714, "length": 34}, "so_18486598_18486996_8": {"section_id": 480, "quality": 0.9259259259259259, "length": 25}, "so_18486598_18486996_7": {"section_id": 480, "quality": 0.9473684210526315, "length": 36}, "so_18486598_18487088_0": {"section_id": 480, "quality": 1.0, "length": 22}, "so_18486598_18486996_2": {"section_id": 480, "quality": 0.9473684210526315, "length": 36}, "so_18486598_18486996_4": {"section_id": 480, "quality": 0.8181818181818182, "length": 27}, "so_18486598_18486996_0": {"section_id": 480, "quality": 0.96875, "length": 62}, "so_18486598_18486996_6": {"section_id": 480, "quality": 0.9714285714285714, "length": 34}, "so_18486598_18486996_3": {"section_id": 480, "quality": 0.9259259259259259, "length": 25}, "so_18486598_18486996_9": {"section_id": 480, "quality": 0.8181818181818182, "length": 27}}, "n3337": {"so_18486598_18486996_1": {"section_id": 471, "quality": 0.9714285714285714, "length": 34}, "so_18486598_18486996_8": {"section_id": 471, "quality": 0.9259259259259259, "length": 25}, "so_18486598_18486996_7": {"section_id": 471, "quality": 0.9473684210526315, "length": 36}, "so_18486598_18487088_0": {"section_id": 471, "quality": 0.8636363636363636, "length": 19}, "so_18486598_18486996_0": {"section_id": 471, "quality": 0.984375, "length": 63}, "so_18486598_18486996_4": {"section_id": 471, "quality": 0.8484848484848485, "length": 28}, "so_18486598_18486996_2": {"section_id": 471, "quality": 0.9473684210526315, "length": 36}, "so_18486598_18486996_6": {"section_id": 471, "quality": 0.9714285714285714, "length": 34}, "so_18486598_18486996_3": {"section_id": 471, "quality": 0.9259259259259259, "length": 25}, "so_18486598_18486996_9": {"section_id": 471, "quality": 0.8484848484848485, "length": 28}}, "n4659": {"so_18486598_18486996_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_18486598_18486996_8": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}, "so_18486598_18486996_9": {"section_id": 502, "quality": 0.9090909090909091, "length": 30}, "so_18486598_18487088_0": {"section_id": 502, "quality": 1.0, "length": 22}, "so_18486598_18486996_4": {"section_id": 502, "quality": 0.9090909090909091, "length": 30}, "so_18486598_18486996_7": {"section_id": 502, "quality": 0.9736842105263158, "length": 37}, "so_18486598_18486996_2": {"section_id": 502, "quality": 0.9736842105263158, "length": 37}, "so_18486598_18486996_3": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}, "so_18486598_18486996_6": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_18486598_18486996_0": {"section_id": 502, "quality": 0.96875, "length": 62}}}});