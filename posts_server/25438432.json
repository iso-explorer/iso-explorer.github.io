post_cb({"25438592": {"Id": "25438592", "PostTypeId": "2", "Body": "<p>Note that polymorphism only works with pointers or references to instances of a class, not with the instances directly. This is at the root of your problem.</p>\n<p>You might consider using <code>std::vector&lt;A*&gt;</code> instead of an array.</p>\n", "Score": "0", "LastActivityDate": "2014-08-22T02:06:48.970", "CreationDate": "2014-08-22T02:06:48.970", "ParentId": "25438432", "CommentCount": "0", "OwnerUserId": "1440565"}, "25438612": {"Id": "25438612", "PostTypeId": "2", "Body": "<p>In an object of type <code>B</code>, you have an array of <code>A</code> objects. You return a pointer to the first element of the array in both the member functions <code>B::Get1()</code> and <code>B::Get2()</code>.</p>\n<p>Let's say the lay out the array is:</p>\n<pre><code>+--------------+--------------+--------------+--------------+\n|    mA[0]     |    mA[1]     |    mA[2]     |    mA[3]     |         \n+--------------+--------------+--------------+--------------+\n</code></pre>\n<p>When you execute </p>\n<pre><code>IA *tmpInterface = mainClass.Get1();\nA *tmpClass = mainClass.Get2();\n</code></pre>\n<p>You have <code>tempInterface</code> and <code>tmpClass</code> pointing to the first element of <code>mA</code>.</p>\n<pre><code>+--------------+--------------+--------------+--------------+\n|    mA[0]     |    mA[1]     |    mA[2]     |    mA[3]     |         \n+--------------+--------------+--------------+--------------+\n^\n| \ntmpInterface as well as tmpClass\n</code></pre>\n<p>When you do arithmetic operations on <code>tmpInterface</code> and <code>tmpClass</code>, you will see very different results.</p>\n<p>Where do <code>tmpInterface+1</code> and <code>tmpClass+1</code> point?</p>\n<pre><code>+--------------+--------------+--------------+--------------+\n|    mA[0]     |    mA[1]     |    mA[2]     |    mA[3]     |         \n+--------------+--------------+--------------+--------------+\n      ^        ^\n      |        | \n      |        tmpClass+1\n      tmpInterface+1\n</code></pre>\n<p>Since <code>tmpClass</code> is of type <code>A*</code>,  <code>tmpClass+1</code> points to the next object in the array. However, since the type of <code>tmpInterface</code> is <code>IA*</code>, and <code>sizeof(IA)</code> is not the same as <code>sizeof(A)</code>, <code>tmpInterface+1</code> points to something in the middle. It does not point to an object of type <code>IA</code>. If you try to access <code>tmpInterface+1</code> as a <code>IA*</code>, you are going to get undefined behavior.</p>\n", "Score": "0", "LastActivityDate": "2014-08-22T02:10:58.927", "CreationDate": "2014-08-22T02:10:58.927", "ParentId": "25438432", "CommentCount": "0", "OwnerUserId": "434551"}, "25438480": {"Id": "25438480", "PostTypeId": "2", "LastEditDate": "2014-08-22T01:58:19.873", "CommentCount": "1", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-22T01:58:19.873", "CreationDate": "2014-08-22T01:49:12.270", "ParentId": "25438432", "Score": "0", "Body": "<p>The subscript operator uses pointer arithmetic, and performing pointer arithmetic on a pointer whose type is different from the actual type of the object it points to is undefined behavior. \u00a75.7 [expr.add]/p7:</p>\n<blockquote>\n<p id=\"so_25438432_25438480_0\">For addition or subtraction, if the expressions <code>P</code> or <code>Q</code> have type\n  \u201cpointer to cv <code>T</code>\u201d, where <code>T</code> is different from the cv-unqualified\n  array element type, the behavior is undefined. [ <em>Note</em>: In\n  particular, a pointer to a base class cannot be used for pointer\n  arithmetic when the array contains objects of a derived class type.\n  \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>So, to index into an array of <code>A</code>s, you need an <code>A*</code>. If you want to use <code>IA</code> only, then you'd need to apply some programmer's panacea - indirection. Return an <code>IA **</code> pointing to the first element of an array of <code>IA *</code>, whose members each point to an <code>A</code>.</p>\n", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_25438432_25438480_0": {"length": 28, "quality": 0.875, "section_id": 6144}}, "n4659": {"so_25438432_25438480_0": {"length": 26, "quality": 0.8125, "section_id": 7640}}}, "25438432": {"ViewCount": "54", "LastEditDate": "2014-08-22T02:09:32.217", "AcceptedAnswerId": "25438480", "Title": "how do I return a pointer to an array from a function using a struct as the interface", "CreationDate": "2014-08-22T01:42:23.900", "LastActivityDate": "2014-08-22T02:13:25.500", "CommentCount": "0", "Body": "<p>I am trying to create an interface to an array in C++.<br/></p>\n<p><br/>\nIn the code below <br/>\n<code>tmpClass[1].GetA()</code> returns 'w'<br/>\n<code>tmpInterface[1]</code> causes an error.<br/>\n<br/>\nIs there any way to define an interface so it can access the elements of the array?<br/>\nHow to I get <code>tmpInterface</code> to behave like <code>tmpClass</code>?\n<br/><br/></p>\n<pre><code>struct IA\n{\n    virtual char GetA() = 0;\n    virtual void SetA(char pA) = 0;\n};\n\nclass A:public IA\n{\n    public:\n        A(){ var = 0; }\n        A(char pVar){ var = pVar; }\n        char GetA(){ return var; }\n        void SetA(char pA){ var = pA; }\n    private:\n    int var;\n};\n\nclass B\n{\n    public:\n        B(){ \n            mA[0].SetA('c');\n            mA[1].SetA('w');\n            mA[2].SetA('6');\n            mA[3].SetA('$');\n        }\n\n        int GetCount(){}\n        IA* Get1(){ return mA; }\n        A* Get2(){ return mA; }\n    protected:\n        A mA[4];\n};\n\n\nint main()\n{\n    B mainClass;\n    IA *tmpInterface = mainClass.Get1();\n    A *tmpClass = mainClass.Get2();\n\n    for (int i = 0; i &lt; 4; i++)\n    {\n        //once i&gt;0 then tmpInterface no longer points to a valid character\n        //and program crashes\n        System::Console::Write(\n            \"A = \"+tmpClass[i].GetA()+\n            \" IA = \"+tmpInterface[i].GetA()); \n    }\n    return 0;\n}\n</code></pre>\n", "PostTypeId": "1", "LastEditorUserId": "2679518", "Id": "25438432", "Score": "0", "OwnerUserId": "3140515", "Tags": "<c++><arrays><pointers><struct><interface>", "AnswerCount": "4"}, "25438598": {"Id": "25438598", "PostTypeId": "2", "LastEditDate": "2014-08-22T02:13:25.500", "CommentCount": "1", "LastEditorUserId": "3886594", "LastActivityDate": "2014-08-22T02:13:25.500", "CreationDate": "2014-08-22T02:07:57.873", "ParentId": "25438432", "Score": "0", "Body": "<p>In effective C++,it says don't use polymorphism on array;\nYou can add a virtual function behave like operator [],eg:</p>\n<pre><code>struct IA\n{\n    //...\n    virtual IA* Offset(int index)\n    {\n        return this + index;\n    }\n};\n\nclass A:public IA\n{\npublic:\n    //...\n    virtual A* Offset(int index)\n    {\n        return this + index;\n    }\n};\n</code></pre>\n<p>then it works fine.</p>\n<pre><code>cout &lt;&lt; \"A = \" &lt;&lt; tmpClass-&gt;Offset(i)-&gt;GetA();\ncout &lt;&lt; \" IA = \" &lt;&lt; tmpInterface-&gt;Offset(i)-&gt;GetA() &lt;&lt; endl;\n</code></pre>\n<p>Besides,what is System::Console::Write in C++?</p>\n", "OwnerUserId": "3886594"}});