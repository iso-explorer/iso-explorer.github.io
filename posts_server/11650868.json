post_cb({"bq_ids": {"n4140": {"so_11650868_11651082_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 640}, "so_11650868_11651082_4": {"length": 16, "quality": 1.0, "section_id": 640}}, "n3337": {"so_11650868_11651082_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 630}, "so_11650868_11651082_4": {"length": 16, "quality": 1.0, "section_id": 630}}, "n4659": {"so_11650868_11651082_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 668}, "so_11650868_11651082_4": {"length": 16, "quality": 1.0, "section_id": 668}}}, "11650868": {"ViewCount": "421", "Body": "<p>Okay, this is a bit complicated so please bear with me. :)</p>\n<h2>We have this simple class hierarchy:</h2>\n<pre><code>class A {};\nclass DA : public A {};\nclass DDA : public DA {};\n</code></pre>\n<h2>And we have the following functions operating on these classes:</h2>\n<pre><code>void f(A x) {\n  std::cout &lt;&lt; \"f A\" &lt;&lt; std::endl;\n}\nvoid f(DA x) {\n  std::cout &lt;&lt; \"f DA\" &lt;&lt; std::endl;\n}\nvoid f(DDA x) {\n  std::cout &lt;&lt; \"f DDA\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Now we want to add another function that treats DA a little differently.</p>\n<h2>(1) A first attempt could look like this:</h2>\n<pre><code>void g(A t) {\n  std::cout &lt;&lt; \"generic treatment of A\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"called from g: \";\n  f(t);\n}\nvoid g(DA t) {\n  std::cout &lt;&lt; \"special treatment of DA\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"called from g: \";\n  f(t);\n}\n</code></pre>\n<p>But calling this with an object of each of the classes clearly does not have the desired effect.</p>\n<p>Call:</p>\n<pre><code>  A a; DA b; DDA c;\n  g(a); g(b); g(c)\n</code></pre>\n<p>Result:</p>\n<pre><code>generic treatment of A\ncalled from g: f A\nspecial treatment of DA\ncalled from g: f DA\nspecial treatment of DA\ncalled from g: f DA        //PROBLEM: g forgot that this DA was actually a DDA\n</code></pre>\n<h2>(2) So instead we might try to use templates:</h2>\n<pre><code>template&lt;typename T&gt;\nvoid h(T t) {\n  std::cout &lt;&lt; \"generic treatment of A\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"called from h: \";\n  f(t);\n}\n\ntemplate&lt;&gt;\nvoid h&lt;&gt;(DA t) {\n  std::cout &lt;&lt; \"special treatment of DA\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"called from h: \";\n  f(t);\n}\n</code></pre>\n<p>which results in:</p>\n<pre><code>generic treatment of A\ncalled from h: f A\nspecial treatment of DA\ncalled from h: f DA\ngeneric treatment of A    //PROBLEM: template specialization is not used\ncalled from h: f DDA\n</code></pre>\n<p>Well, how about we don't use template specialization but define a non-template function for the special case? (<a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\" title=\"[Sutter]\">Article</a> on the very confusing matter.) It turns out it behaves in exactly the same way because the non-template function which is according to the article a \"first class citizen\", seems to lose because a type conversion is necessary to use it. And if it would be used, well then we would just be back at the first solution (I assume) and it would forget the type of DDA.</p>\n<h2>(3) Now I came across this code at work which seems rather fancy to me:</h2>\n<pre><code>template&lt;typename T&gt;\nvoid i(T t, void* magic) {\n  std::cout &lt;&lt; \"generic treatment of A\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"called from i: \";\n  f(t);\n}\n\ntemplate&lt;typename T&gt;\nvoid i(T t, DA* magic) {\n  std::cout &lt;&lt; \"special treatment of DA\" &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"called from i: \";\n  f(t);\n}\n</code></pre>\n<p>But it seems to do exactly what I want:</p>\n<pre><code>generic treatment of A\ncalled from i: f A\nspecial treatment of DA\ncalled from i: f DA\nspecial treatment of DA\ncalled from i: f DDA\n</code></pre>\n<p>Even though it needs to be called in a weird way:\n  i(a, &amp;a); i(b, &amp;b); i(c, &amp;c);</p>\n<p>Now I have several questions:</p>\n<ol>\n<li>Why the hell does this work?</li>\n<li>Do you think it is a good idea? Where are possible pitfalls?</li>\n<li>Which other ways of doing this kind of specialization would you suggest?</li>\n<li>(How do type conversions fit into the madness that is template partial ordering and such...)</li>\n</ol>\n<p>I hope this was reasonably clear. :) </p>\n", "AcceptedAnswerId": "11651082", "Title": "Is this way of function overloading for class hierarchies using templates safe?", "CreationDate": "2012-07-25T13:30:23.893", "Id": "11650868", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-07-25T13:37:44.620", "LastEditorUserId": "1994377", "LastActivityDate": "2012-07-25T14:01:44.957", "Score": "5", "OwnerUserId": "1994377", "Tags": "<c++><class><templates><overloading>", "AnswerCount": "1"}, "11651082": {"Id": "11651082", "PostTypeId": "2", "Body": "<p>The function template overload</p>\n<pre><code>template&lt;typename T&gt;\nvoid i(T t, DA* magic) {\n</code></pre>\n<p>will only be available if the parameter <code>magic</code> is convertible to type <code>DA *</code>.  This is obviously the case for <code>&amp;b</code> but also for <code>&amp;c</code> as pointer-to-derived is convertible to pointer-to-base.  The <code>void *</code> function template overload is always available but <code>DA *</code> is preferred to <code>void *</code>, per \u00a713.3.3.2:4:</p>\n<blockquote>\n<p id=\"so_11650868_11651082_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</h3>\n<p id=\"so_11650868_11651082_1\">[...]</p>\n<p id=\"so_11650868_11651082_2\"><em>4</em> Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a\n  Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank\n  are indistinguishable unless one of the following rules applies:</p>\n<p id=\"so_11650868_11651082_3\">[...]</p>\n<p id=\"so_11650868_11651082_4\">\u2014 If class <code>B</code> is derived directly or indirectly from class <code>A</code>, conversion of <code>B*</code> to <code>A*</code> is better than conversion\n  of <code>B*</code> to <code>void*</code>, and conversion of <code>A*</code> to <code>void*</code> is better than conversion of <code>B*</code> to <code>void*</code>.</p>\n</blockquote>\n<p>As you've noted, it's a perfectly workable scheme; it would make more sense to wrap the magic in another template function that takes care of calling <code>i</code> with <code>(a, &amp;a)</code>:</p>\n<pre><code>template&lt;typename T&gt;\nvoid j(T t) {\n    i(t, &amp;t);\n}\n</code></pre>\n<p>In terms of safety, it's fine; if the <code>DA *</code> overload is lost then the <code>void *</code> overload will be selected silently; it's up to you to decide whether this is desirable.</p>\n<p>As an alternative, you can use <code>std::enable_if</code> to select between templates:</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::enable_if&lt;!std::is_base_of&lt;DA, T&gt;::value&gt;::type g(T t) {\n  std::cout &lt;&lt; \"generic treatment of A\" &lt;&lt; std::endl;\n  f(t);\n}\ntemplate&lt;typename T&gt;\ntypename std::enable_if&lt;std::is_base_of&lt;DA, T&gt;::value&gt;::type g(T t) {\n  std::cout &lt;&lt; \"special treatment of DA\" &lt;&lt; std::endl;\n  f(t);\n}\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-07-25T14:01:44.957", "Score": "4", "CreationDate": "2012-07-25T13:40:07.390", "ParentId": "11650868", "CommentCount": "2", "OwnerUserId": "567292", "LastEditDate": "2012-07-25T14:01:44.957"}});