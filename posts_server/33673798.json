post_cb({"33674168": {"Id": "33674168", "PostTypeId": "2", "Body": "<p><code>DWORD</code> is defined as an unsigned 32 bits integer [<a href=\"https://msdn.microsoft.com/en-us/library/cc230318.aspx\" rel=\"nofollow\">MSDN</a>].</p>\n<p><code>unsigned long</code> is guaranteed to be at least a 32 bits unsigned integer [<a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow\">cppreference</a>].</p>\n<p>Therefore, you can always assign a <code>DWORD</code> to an <code>unsigned long</code> without loss of precision, so you can use the unsigned long specifier with <code>printf</code> and the likes along with an explicit conversion an the argument to unsigned long.</p>\n<p>The alternative is that you use <code>std::uint32_t</code> which is guaranteed to be equal to <code>DWORD</code> and use that format specifier in <code>printf</code>.</p>\n", "LastActivityDate": "2015-11-12T14:48:18.867", "CommentCount": "2", "CreationDate": "2015-11-12T14:48:18.867", "ParentId": "33673798", "Score": "0", "OwnerUserId": "2718186"}, "bq_ids": {"n4140": {"so_33673798_33673798_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 7212}, "so_33673798_33673798_5": {"length": 5, "quality": 0.625, "section_id": 7043}, "so_33673798_33673798_3": {"length": 7, "quality": 0.875, "section_id": 5946}}, "n3337": {"so_33673798_33673798_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 6956}, "so_33673798_33673798_5": {"length": 5, "quality": 0.625, "section_id": 6788}, "so_33673798_33673798_3": {"length": 7, "quality": 0.875, "section_id": 5913}}, "n4659": {"so_33673798_33673798_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 8721}, "so_33673798_33673798_5": {"length": 5, "quality": 0.625, "section_id": 7612}, "so_33673798_33673798_3": {"length": 7, "quality": 0.875, "section_id": 7432}}}, "33673798": {"ViewCount": "102", "Body": "<p>It is my third attempt to clarify my confusion around this topic. But this time I have different question.</p>\n<p>I have this code</p>\n<pre><code>  DWORD v1, v2, v3, Build;\n  GetVersion(&amp;v1, &amp;v2, &amp;v3, &amp;Build);\n  sprintf(VersionStr, \"%d.%d.%d.%d\", v1, v2, v3, Build);\n</code></pre>\n<p>which was written using Visual Studio maybe 10 years ago. I know <code>DWORD</code> is always <code>unsigned</code>-is this true?.</p>\n<p>Now, <a href=\"https://stackoverflow.com/questions/5851524/does-this-invoke-undefined-behaviour\">here</a>, one of the answer cites some version of standard (does this standard version apply to my code?) which says about <code>va_arg</code>:</p>\n<blockquote>\n<p id=\"so_33673798_33673798_0\">The standard isn't 100% clear on this point. On one hand, you get the\n  specification for <strong>va_arg</strong>, which says (\u00a77.15.1.1/2):</p>\n<p id=\"so_33673798_33673798_1\">If there is no actual next argument, or if type is not compatible with\n  the type of the actual next argument (as promoted according to the\n  default argument promotions), the behavior is undefined, except for\n  the following cases:</p>\n<p id=\"so_33673798_33673798_2\">one type is a signed integer type, the other type is the\n  corresponding unsigned integer type, <strong>and the value is representable in\n  both types;</strong></p>\n<p id=\"so_33673798_33673798_3\">one type is pointer to void and the other is a pointer to a character\n  type.</p>\n</blockquote>\n<p>On the other hand that answer also says about <code>printf</code></p>\n<blockquote>\n<p id=\"so_33673798_33673798_4\">On the other hand, you get the specification of <strong>printf</strong> (\u00a77.19.6.1/9):</p>\n<p id=\"so_33673798_33673798_5\">If any argument is not the correct type for the corresponding\n  conversion specification, the behavior is undefined.\"</p>\n</blockquote>\n<p>So first he cites quote about <code>va_arg</code> then about <code>printf</code>. It seems he is unclear too. Another answer mentions this violates <code>printf</code> contract anyway despite <code>va_arg</code> documentation. Please look at the thread. I am confused.</p>\n<hr>\n<p>So my question is basically <strong>is the code I presented undefined behaviour in any case</strong>? Or for example <strong>for values of <code>v1</code> which can be represented in <code>int</code></strong>, this is not undefined behaviour (as claimed in one of the answers I cited)?</p>\n<p>Also can it be that since my code is old maybe for older versions of standard that is not undefined behaviour?</p>\n</hr>", "AcceptedAnswerId": "33673905", "Title": "Is this DWORD related code undefined behaviour?", "CreationDate": "2015-11-12T14:30:29.313", "LastActivityDate": "2015-12-14T17:33:14.603", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:59:28.787", "LastEditorDisplayName": "user5528169", "OwnerDisplayName": "user5528169", "LastEditorUserId": "-1", "Id": "33673798", "Score": "4", "Tags": "<c++><undefined-behavior>", "AnswerCount": "2"}, "33673905": {"Id": "33673905", "PostTypeId": "2", "Body": "<p>It really is quite simple: The format specifiers in <code>sprintf</code> <strong>must</strong> match the types of the arguments passed. Please don't try to conject exceptions to this rule.</p>\n<p>Since a DWORD is an <code>unsigned long</code> and <code>%d</code> is <strong>not</strong> the correct format specifier for an <code>unsigned long</code>, the behaviour of your program is undefined. You <strong>must</strong> use <code>%lu</code>. Since <code>DWORD</code> is not a standard type you ought to include a line</p>\n<pre><code>static_assert(std::is_same&lt;DWORD, unsigned long&gt;::value, \"DWORD is not an unsigned long\");\n</code></pre>\n<p>somewhere in your program.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2015-11-12T14:53:30.110", "Score": "6", "CreationDate": "2015-11-12T14:35:59.010", "ParentId": "33673798", "CommentCount": "5", "OwnerUserId": "2380830", "LastEditDate": "2015-11-12T14:53:30.110"}});