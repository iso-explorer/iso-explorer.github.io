post_cb({"6784138": {"ParentId": "6783993", "CommentCount": "4", "Body": "<p>There are two separate notions in C++:</p>\n<ol>\n<li><p>The new/delete <strong>operators</strong>.</p></li>\n<li><p>New/Delete <strong>expressions</strong>.</p></li>\n</ol>\n<p>The operators allocate and deallocate memory. The <code>new</code> expression constructs objects. The <code>delete</code> expression sometimes destroys an object and calls the operator.</p>\n<p>Why \"sometimes\"? Because it depends on the expression. The naked, global <code>new</code> first calls operator-new to allocate memory and then constructs the object; the global <code>delete</code> calls the destructor and deallocates the memory. But all other overloads of <code>new</code> and <code>delete</code> are different:</p>\n<ul>\n<li>An overloaded new <em>expression</em> calls an overloaded new <em>operator</em> to allocate memory and then proceeds to construct the object.</li>\n<li>However, there is no such thing as an overloaded delete expression, in particular there is no \"placement-delete\": Instead, you have to call the destructor manually.</li>\n</ul>\n<p>New/Delete operators still have to be overloaded in matching pairs, because the matching delete operator is called when an object constructor throws an exception. However, there is no automatic way to invoke the destructor for an object that has been allocated with an overloaded <code>new</code> operator, so you have to do that yourself.</p>\n<p>As the first and most basic example, consider the placement-new <em>operator</em>, which is mandated to take the form  <code>void * operator new (size_t, void * p) throw() { return p; }</code>. The matching <code>delete</code> operator is thus mandated to do nothing: <code>void operator delete (void *, void *) throw() { }</code>. Usage:</p>\n<pre><code>void * p = ::operator new(5); // allocate only!\nT * q = new (p) T();          // construct\nq-&gt;~T();                      // deconstruct: YOUR responsibility\n// delete (p) q;   &lt;-- does not exist!! It would invoke the following line:\n::operator delete(p, q);      // does nothing!\n::operator delete(q);         // deallocate\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "6784138", "Score": "20", "CreationDate": "2011-07-21T23:38:26.967", "LastActivityDate": "2011-07-21T23:38:26.967"}, "16888463": {"ParentId": "6783993", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Assuming there's no such thing as <code>Buffer::operator delete</code>, the <code>delete buf;</code> version is correct and will do all the appropriate cleanup.  To be a bit safer, you can say <code>::delete buf;</code>.</p>\n<p>Language-lawyer debate material follows.</p>\n<p>5.3.5/1</p>\n<blockquote>\n<p id=\"so_6783993_16888463_0\">The <em>delete-expression</em> operator destroys a most derived object (1.8) or array created by a <em>new-expression</em>.</p>\n<p id=\"so_6783993_16888463_1\"><em>delete-expression:</em></p>\n<ul>\n<li><code>::</code><sub><em>opt</em></sub> <code>delete</code> <em>cast-expression</em></li>\n<li><code>::</code><sub><em>opt</em></sub> <code>delete [ ]</code> <em>cast-expression</em></li>\n</ul>\n<p id=\"so_6783993_16888463_2\">The first alternative is for non-array objects, and the second is for arrays. ...</p>\n</blockquote>\n<p>5.3.5/2</p>\n<blockquote>\n<p id=\"so_6783993_16888463_3\">... In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10).  If not, the behavior is undefined.</p>\n</blockquote>\n<p>So the pointer must point at an object created by a <em>new-expression</em>, which is defined:</p>\n<p>5.3.4/1</p>\n<blockquote>\n<p id=\"so_6783993_16888463_4\"><em>new-expression:</em></p>\n<ul>\n<li><code>::</code><sub><em>opt</em></sub> <code>new</code> <em>new-placement</em><sub><em>opt</em></sub> <em>new-type-id</em> _new-initializer_<sub><em>opt</em></sub></li>\n<li><code>::</code><sub><em>opt</em></sub> <code>new</code> <em>new-placement</em><sub><em>opt</em></sub> <code>(</code> <em>type-id</em> <code>)</code> <em>new-initializer</em><sub><em>opt</em></sub></li>\n</ul>\n<p id=\"so_6783993_16888463_5\"><em>new-placement:</em></p>\n<ul>\n<li><code>(</code> <em>expression-list</em> <code>)</code></li>\n</ul>\n</blockquote>\n<p>So a \"placement new\" does count as a <em>new-expression</em>.  Nothing forbidding a <em>delete-expression</em> there.</p>\n<p>Also, it turns out the <em>delete-expression</em> does exactly the right things to clean up the object despite the custom creation.</p>\n<p>5.3.5/6-9</p>\n<blockquote>\n<p id=\"so_6783993_16888463_6\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will invoke the destructor (if any) for the object or the elements of the array being deleted. ...</p>\n<p id=\"so_6783993_16888463_7\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will call a <em>deallocation function</em> (3.7.4.2).  Otherwise, it is unspecified whether the deallocation function will be called.  [<em>Note:</em> The deallocation function is called regardless of whether the destructor for the object or some element of the array throws an exception. - <em>end note</em>]</p>\n<p id=\"so_6783993_16888463_8\">When the keyword <code>delete</code> in a <em>delete-expression</em> is preceded by the unary <code>::</code> operator, the global deallocation function is used to deallocate the storage.</p>\n</blockquote>\n<p>So <code>::delete buf;</code> is entirely equivalent to:</p>\n<pre><code>try {\n    buf-&gt;~Buffer();\n} catch(...) {\n    ::operator delete(mem);\n    throw;\n}\n</code></pre>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2013-06-03T15:07:26.260", "Id": "16888463", "Score": "2", "CreationDate": "2013-06-02T23:59:06.067", "LastActivityDate": "2013-06-03T15:07:26.260"}, "6784035": {"ParentId": "6783993", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The correct method is:</p>\n<pre><code>buf-&gt;~Buffer();\n::operator delete(mem);\n</code></pre>\n<p>You can only delete with the <code>delete</code> <em>operator</em> what you received from the <code>new</code> <em>operator</em>. If you directly call the <code>operator new</code> function, you must also directly call the <code>operator delete</code> function, and must manually call the destructor as well.</p>\n", "OwnerUserId": "36723", "LastEditorUserId": "36723", "LastEditDate": "2011-07-21T23:51:49.380", "Id": "6784035", "Score": "38", "CreationDate": "2011-07-21T23:24:12.490", "LastActivityDate": "2011-07-21T23:51:49.380"}, "6783993": {"CommentCount": "1", "AcceptedAnswerId": "6784035", "CreationDate": "2011-07-21T23:17:56.457", "LastActivityDate": "2013-06-03T15:07:26.260", "PostTypeId": "1", "ViewCount": "21702", "FavoriteCount": "22", "Title": "placement new and delete", "Id": "6783993", "Score": "36", "Body": "<p>What is the right method to delete all the memory allocated here?</p>\n<pre><code>  const char* charString = \"Hello, World\";\n  void *mem = ::operator new(sizeof(Buffer) + strlen(charString) + 1);\n  Buffer* buf = new(mem) Buffer(strlen(charString));\n\n  delete (char*)buf;\n</code></pre>\n<p>OR</p>\n<pre><code>  const char* charString = \"Hello, World\";\n  void *mem = ::operator new(sizeof(Buffer) + strlen(charString) + 1);\n  Buffer* buf = new(mem) Buffer(strlen(charString));\n\n  delete buf;\n</code></pre>\n<p>or are they both same?</p>\n", "Tags": "<c++><visual-c++><new-operator><placement>", "OwnerUserId": "663318", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_6783993_16888463_0": {"section_id": 6105, "quality": 0.9, "length": 9}, "so_6783993_16888463_7": {"section_id": 6111, "quality": 0.8285714285714286, "length": 29}, "so_6783993_16888463_8": {"section_id": 6113, "quality": 0.8333333333333334, "length": 10}, "so_6783993_16888463_6": {"section_id": 6110, "quality": 1.0, "length": 15}, "so_6783993_16888463_2": {"section_id": 6105, "quality": 0.8571428571428571, "length": 6}, "so_6783993_16888463_3": {"section_id": 6106, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_6783993_16888463_0": {"section_id": 5871, "quality": 0.9, "length": 9}, "so_6783993_16888463_7": {"section_id": 5877, "quality": 0.8285714285714286, "length": 29}, "so_6783993_16888463_8": {"section_id": 5879, "quality": 1.0, "length": 12}, "so_6783993_16888463_6": {"section_id": 5876, "quality": 1.0, "length": 15}, "so_6783993_16888463_2": {"section_id": 5871, "quality": 0.8571428571428571, "length": 6}, "so_6783993_16888463_3": {"section_id": 5872, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_6783993_16888463_0": {"section_id": 7602, "quality": 0.9, "length": 9}, "so_6783993_16888463_8": {"section_id": 7610, "quality": 0.8333333333333334, "length": 10}, "so_6783993_16888463_7": {"section_id": 7608, "quality": 0.7142857142857143, "length": 25}, "so_6783993_16888463_6": {"section_id": 7607, "quality": 1.0, "length": 15}, "so_6783993_16888463_2": {"section_id": 7602, "quality": 0.8571428571428571, "length": 6}, "so_6783993_16888463_3": {"section_id": 7603, "quality": 0.9615384615384616, "length": 25}}}});