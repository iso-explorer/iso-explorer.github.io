post_cb({"24224115": {"CommentCount": "13", "AcceptedAnswerId": "24225154", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-06-14T20:41:08.213", "LastActivityDate": "2014-06-16T20:00:29.137", "LastEditDate": "2014-06-16T17:41:41.600", "ViewCount": "408", "FavoriteCount": "1", "Title": "Interdependent initialization with commas?", "Id": "24224115", "Score": "8", "Body": "<p>Is the following perfectly defined:</p>\n<pre><code>int x = 42, y = x;\n</code></pre>\n<p>i.e. strictly equivalent to:</p>\n<pre><code>int x = 42;\nint y = x;\n</code></pre>\n<p>EDIT : the question is not about style (I know that it's wrong...), the question is \"theoretical\"</p>\n", "Tags": "<c++><c++11><initialization><language-lawyer><undefined-behavior>", "OwnerUserId": "882932", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24224115_24225154_0": {"section_id": 3196, "quality": 1.0, "length": 8}, "so_24224115_24225154_1": {"section_id": 3196, "quality": 0.9166666666666666, "length": 11}, "so_24224115_24226345_5": {"section_id": 5810, "quality": 0.9444444444444444, "length": 17}, "so_24224115_24226345_6": {"section_id": 3326, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_24224115_24225154_0": {"section_id": 3070, "quality": 1.0, "length": 8}, "so_24224115_24225154_1": {"section_id": 3070, "quality": 0.9166666666666666, "length": 11}, "so_24224115_24226345_5": {"section_id": 5583, "quality": 0.9444444444444444, "length": 17}, "so_24224115_24226345_6": {"section_id": 3196, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_24224115_24225154_0": {"section_id": 3958, "quality": 1.0, "length": 8}, "so_24224115_24225154_1": {"section_id": 3958, "quality": 0.9166666666666666, "length": 11}, "so_24224115_24226345_5": {"section_id": 7271, "quality": 0.9444444444444444, "length": 17}, "so_24224115_24226345_6": {"section_id": 4092, "quality": 0.9230769230769231, "length": 12}}}, "24225154": {"ParentId": "24224115", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2014-06-14T23:20:42.440", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:17.563", "Id": "24225154", "OwnerUserId": "2352671", "Body": "<p>The correct answer is that </p>\n<pre><code>int x = 42, y = x;\n</code></pre>\n<p>and </p>\n<pre><code>int x = 42;\nint y = x;\n</code></pre>\n<p><strong>are usually equivalent (not strictly).</strong></p>\n<hr>\n<p>Considering the standard <strong>\u00a7 8 Declarators [dcl.decl]</strong>:</p>\n<blockquote>\n<p id=\"so_24224115_24225154_0\"><em><code>3</code> Each init-declarator in a declaration is analyzed separately as if it was in a declaration by itself.</em></p>\n</blockquote>\n<p>and in the footnote [100] further explains:</p>\n<blockquote>\n<p id=\"so_24224115_24225154_1\"><em>A declaration with several declarators is usually equivalent to the corresponding sequence of declarations each with a single\n  declarator. That is</em></p>\n<p id=\"so_24224115_24225154_2\"><em>T D1, D2, ... Dn;</em></p>\n<p id=\"so_24224115_24225154_3\"><strong>is usually equivalent to</strong></p>\n<p id=\"so_24224115_24225154_4\"><em>T D1; T D2; ... T Dn;</em></p>\n<p id=\"so_24224115_24225154_5\"><em>where T is a decl-speci\ufb01er-seq and each Di is an init-declarator.</em></p>\n</blockquote>\n<ul>\n<li><p>The above guarantees that <code>x = 42</code> and <code>y = x</code> will be evaluated separately. However, as <a href=\"https://stackoverflow.com/users/241631/praetorian\">@Praetorian</a> correctly pointed out in the comments, footnotes are not normative. </p></li>\n<li><p>This means that the order of evaluation is not well defined and an implementer could as well implement the evaluation of the declarations in the reverse order (i.e,. <code>T Dn; ...T D2; T D1;</code>).</p></li>\n<li><p>One might argue that the comma operator is guaranteed left to right evaluation. However, this not the case. According to the K &amp; R [K &amp; R II, 3.6 p.63], that also applies to C++:</p></li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n<p id=\"so_24224115_24225154_8\"><em>The commas that separate function arguments, variables in declarations, etc., are not comma operators, and do not guarantee left to right evaluation.</em></p>\n</blockquote>\n</blockquote>\n</blockquote>\n</hr>", "LastActivityDate": "2014-06-15T00:31:44.173"}, "24226345": {"ParentId": "24224115", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2014-06-15T03:43:03.430", "Score": "4", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:33.343", "Id": "24226345", "OwnerUserId": "1708801", "Body": "<p>This question came up in <a href=\"https://groups.google.com/forum/#!forum/comp.lang.c++.moderated\" rel=\"nofollow noreferrer\">comp.lang.c++.moderated</a> a long time ago under the topic <a href=\"https://groups.google.com/forum/#!msg/comp.lang.c++.moderated/vR-BEaEYKII/0f07LEXIC9IJ\" rel=\"nofollow noreferrer\">init-declarator-list analysis order</a> and the conclusion there was <code>Yes</code>.</p>\n<p>Although I see the <em>full-expression</em> argument but I do not see the order of evaluation argument. So I think this is unspecified.</p>\n<p>The relevant part of the question is:</p>\n<blockquote>\n<p id=\"so_24224115_24226345_0\">In this declaration and definition:</p>\n<p id=\"so_24224115_24226345_1\">int a = 2, b = a;</p>\n<p id=\"so_24224115_24226345_2\">Is it guaranteed that b will always be initialized as 2 ? If yes, then\n  can we say that a = 2 is always analysed(or evaluated?) before b = a ?</p>\n</blockquote>\n<p>and the relevant part of the answer is:</p>\n<blockquote>\n<p id=\"so_24224115_24226345_3\">Yes.  Strictly stated, the observable behavior of the program must be\n  as if all of the side effects of the 'a = 2' part of the declaration\n  took place before the evaluation of the 'b = a' part starts.  (In\n  practice, of course, in this simple example, a compiler could assign 2\n  to both a and b in any order, or even in parallel, because doing so\n  would result in the same observable behavior.)</p>\n</blockquote>\n<p>and further down:</p>\n<blockquote>\n<p id=\"so_24224115_24226345_4\">In this particular case, however, it does separate the declarator\n  list into separate declarators; each declarator contains a complete\n  expression, and the declarators are evaluated in order.</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>What makes each <em>init-declator</em> a <em>full expression</em> is subtle but as far as I can tell follows the same logic I used in <a href=\"https://stackoverflow.com/questions/19881803/are-multiple-mutations-of-the-same-variable-within-initializer-lists-undefined-b\">Are multiple mutations of the same variable within initializer lists undefined behavior pre C++11</a>. In this case we start from the grammar defined in ection <em>8</em>:</p>\n<pre><code>init-declarator-list:\n  init-declarator\n  init-declarator-list , init-declarator\ninit-declarator:\n  declarator initializeropt\n</code></pre>\n<p>The next point of focus is the <em>initializer</em> grammar which is covered in section <code>8.5</code>:</p>\n<pre><code>initializer:\n  brace-or-equal-initializer\n  ( expression-list )\nbrace-or-equal-initializer:\n  = initializer-clause\n  braced-init-list\ninitializer-clause:\n  assignment-expression\n  braced-init-list\n</code></pre>\n<p>In both cases we have <em>= initializer-clause</em> which bring us to <em>assignment-expression</em> which if we follow the grammar in section <em>5</em> bring us back to <em>primary-expression</em> which can give us either a <em>literal</em> or <em>id-expression</em>.</p>\n<p>So we do indeed have full-expressions separated by a grammatical comma so we have:</p>\n<pre><code>int x = 42, y = x;\n          ^      ^\n          |      end full-expression\n          end full-expression\n</code></pre>\n<p>and according to section <code>1.9</code> paragraph <em>14</em> we see that:</p>\n<blockquote>\n<p id=\"so_24224115_24226345_5\">Every value computation and side effect associated with a\n  full-expression is sequenced before every value computation and side\n  effect associated with the next full-expression to be evaluated.<sup>8.</sup></p>\n</blockquote>\n<p>As for the order of evaluation, I think this is not specified, the same logic that applies to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#430\" rel=\"nofollow noreferrer\">defect report 430</a> for initializer lists would seem to apply here as well. In C++11 the language for initializer lists was fixed with the following addition in section <code>8.5.4</code>:</p>\n<blockquote>\n<p id=\"so_24224115_24226345_6\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), are evaluated in the order in which they appear. [...]</p>\n</blockquote>\n<p>there is no such equivalent for <em>initializer</em>.</p>\n", "LastActivityDate": "2014-06-16T20:00:29.137"}});