post_cb({"bq_ids": {"n4140": {"so_39856970_39856970_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_39856970_39863945_5": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_39856970_39863945_3": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_39856970_39863945_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 5943}, "so_39856970_39863945_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 6138}}, "n3337": {"so_39856970_39856970_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}, "so_39856970_39863945_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 5714}, "so_39856970_39863945_5": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}, "so_39856970_39863945_3": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_39856970_39863945_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5902}}, "n4659": {"so_39856970_39863945_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7635}, "so_39856970_39863945_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 7428}, "so_39856970_39863945_5": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_39856970_39863945_3": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_39856970_39856970_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}}, "39863945": {"Id": "39863945", "PostTypeId": "2", "Body": "<p>Yes, the result is deterministic, not (compiler's) implementation defined. Here follows the motivation for C++11 (it should be possible to do the same for other), following the document <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">here</a> (link suggested <a href=\"https://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents/4653479#4653479\">here</a>)</p>\n<p>It's necessary to combine all of the following:</p>\n<blockquote>\n<p id=\"so_39856970_39863945_0\">5.9 Relational operators</p>\n<ol>\n<li><p id=\"so_39856970_39863945_1\">[...]</p></li>\n<li><p id=\"so_39856970_39863945_2\">The <em>usual arithmetic conversions</em> are performed on operands of arithmetic or enumeration type. </p></li>\n</ol>\n</blockquote>\n<p>To find the <em>usual arithmetic conversion</em> we need to go to the incipit of Chapter 5, paragraph 9:</p>\n<blockquote>\n<p id=\"so_39856970_39863945_3\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result.\n  This pattern is called <strong>the usual arithmetic conversions</strong>, which are defined as follows:</p>\n<ul>\n<li>[...] (Enumeration and floating point types)</li>\n<li><p id=\"so_39856970_39863945_4\">Otherwise, the <strong>integral promotions (4.5) shall be performed on both</strong>\n<strong>operands</strong>.[59] Then the following rules shall be applied to the <em>promoted</em>\n  operands: </p>\n<ul>\n<li>If both operands have the same type, no further conversion is needed.</li>\n<li>[...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So, integral promotion, citing from 4.5:</p>\n<blockquote>\n<p id=\"so_39856970_39863945_5\">A prvalue of an integer type <em>other than</em> bool, char16_t, char32_t, or wchar_t whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned\n  int.</p>\n</blockquote>\n<p>So:<br/>\nWe have a relational operator, the usual arithmetic conversions will be used. These <em>oblige</em> to apply integral promotion. An integral promotion for <code>uint8_t</code> and <code>int8_t</code> is possible to <code>int</code>, so it is <em>obligatorily</em> applied.</p>\n<p><strong>Therefore the comparison between a <code>uint8_t</code> and <code>int8_t</code> is transformed by the compiler into a comparison between 2 <code>int</code>. There is no undeterministic behaviour.</strong></p>\n<p>There was a similar Q/A <a href=\"https://stackoverflow.com/q/23635240/2436175\">here</a> (about <code>short</code> type though), which led me to the right path.</p>\n<p><strong>Note the following contradiction though</strong>: Relational operators return a boolean value (5.9.1), yet they use the usual arithmetic conversions which is used to obtain 2 operands of the same type. But, here lays the problem, the definition of usual arithmetic conversion says that the common type will be also the type of the result, which isn't the case for relational operators!!</p>\n<p>The contradiction is not there for C11, where the result returned by relational operators is indeed an <code>int</code>. (Thanks chux)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-05T08:17:51.823", "Score": "2", "CreationDate": "2016-10-05T01:04:21.007", "ParentId": "39856970", "CommentCount": "8", "OwnerUserId": "2436175", "LastEditDate": "2017-05-23T12:06:51.347"}, "39856970": {"ViewCount": "206", "Body": "<p>I run <a href=\"http://coliru.stacked-crooked.com/a/d5d2876f81e6e938\" rel=\"nofollow noreferrer\">this simple program</a>:</p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;iostream&gt;\nint main() {\n    uint8_t x = 100;\n    int8_t y = -128;\n    if (x &lt; y) {\n        std::cout &lt;&lt; (int) x &lt;&lt; \" is less than \" &lt;&lt; (int) y &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; (int) y &lt;&lt; \" is less than \" &lt;&lt; (int) x &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>With output, correctly:</p>\n<pre><code>-128 is less than 100\n</code></pre>\n<p>I was at first surprised to see no signedness warning was generated.<br/>\nI was then surprised not to have a wrong conversion going on (-128 -&gt; 255) and therefore not getting a wrong result.<br/>\nThen I read <a href=\"https://stackoverflow.com/a/20192160/2436175\">this</a>:</p>\n<blockquote>\n<p id=\"so_39856970_39856970_0\"><sup>1</sup> A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int. [\u00a7 4.5]</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/open/n2356/conv.html\" rel=\"nofollow noreferrer\">Link to standard n2356</a><br/>\nWhat does it mean \"<em>Can</em> be converted\"? Is it up to the compiler implementation if this conversion will happen and therefore if this expression will return a correct value?</p>\n<p>The point is that the compiler <em>shall</em> search for a common type to which convert the 2 operands, but I don't find any obligation in the standard to <em>do its best</em> so that this common type is able to represent all possible values of both the 2 input types.</p>\n<p>Note: I tagged also C as this case seems to be also applicable to it.<br/>\nRelated question: <a href=\"https://stackoverflow.com/questions/21027305/comparison-signed-and-unsigned-char\">Comparison signed and unsigned char</a>. Also <a href=\"https://stackoverflow.com/a/25918087/2436175\">this</a>.</p>\n", "AcceptedAnswerId": "39863945", "Title": "Comparing 8 bits types of different signedness (int8_t, uint8_t): is result deterministic?", "CreationDate": "2016-10-04T16:03:06.657", "Id": "39856970", "CommentCount": "13", "LastEditDate": "2017-05-23T12:06:49.940", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-05T08:17:51.823", "Score": "2", "OwnerUserId": "2436175", "Tags": "<c++><c><gcc4.9>", "AnswerCount": "1"}});