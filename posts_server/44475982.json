post_cb({"bq_ids": {"n4140": {"so_44475982_44476033_0": {"length": 11, "quality": 1.0, "section_id": 480}}, "n3337": {"so_44475982_44476033_0": {"length": 11, "quality": 1.0, "section_id": 471}}, "n4659": {"so_44475982_44476033_0": {"length": 11, "quality": 1.0, "section_id": 502}}}, "44475982": {"ViewCount": "191", "Body": "<p>I know that NRVO allows a function to construct an object and return that object by value without the cost of a copy or even move operation. It found that it also works with nested function calls, allowing you to construct the object from the return value of another function call.</p>\n<p>Please consider the following program and it's output as shown in the comments:<br>\n(Output from Visual Studio 2017, version 15.2, release build.)</br></p>\n<pre><code>#include &lt;stdio.h&gt;\nclass W\n{\npublic:\n  W() { printf( \"W::W()\\n\" ); }\n  W( const W&amp; ) { printf( \"W::W( const W&amp; )\\n\" ); }\n  W( W&amp;&amp; ) { printf( \"W::W( W&amp;&amp; )\\n\" ); }\n  W&amp; operator=( const W&amp; ) { printf( \"W::operator=( const W&amp; )\\n\" ); }\n  W&amp; operator=( W&amp;&amp; ) { printf( \"W::operator=( W&amp;&amp; )\\n\" ); }\n  ~W() { printf( \"W::~W()\\n\" ); }\n  void Transform() { printf( \"W::Transform()\\n\" ); }\n  void Run() { printf( \"W::Run()\\n\" ); }\n};\n\nW make()\n{\n  W w;\n  return w;\n}\n\nW transform_make()\n{\n  W w{ make() };\n  w.Transform();\n  return w;\n}\n\nW transform1( W w )\n{\n  w.Transform();\n  return w;\n}\n\nW&amp;&amp; transform2( W&amp;&amp; w )\n{\n  w.Transform();\n  return std::move(w);\n}\n\nint main()                         // Program output:\n{\n  printf( \"TestM:\\n\" );            //TestM:\n  {                                //W::W()\n    W w{ make() };                 //W::Run()\n    w.Run();                       //W::~W()\n  }\n                                   //TestTM:\n  printf( \"TestTM:\\n\" );           //W::W()\n  {                                //W::Transform()\n    W w{ transform_make() };       //W::Run()\n    w.Run();                       //W::~W()\n  }\n                                   //TestT1:\n  printf( \"TestT1:\\n\" );           //W::W()\n  {                                //W::Transform()\n    W w{ transform1( make() ) };   //W::W( W&amp;&amp; )\n    w.Run();                       //W::~W()\n  }                                //W::Run()\n                                   //W::~W()\n\n  printf( \"TestT2:\\n\" );           //TestT2:\n  {                                //W::W()\n    W&amp;&amp; w{ transform2( make() ) }; //W::Transform()\n    w.Run();                       //W::~W()\n  }                                //W::Run()\n}\n</code></pre>\n<p><code>TestM</code> is the normal NRVO case. The object <code>W</code> is constructed and destructed only once.\n<code>TestTM</code> is the nested NRVO case. Again the object is constructed only once and never copied or moved. So far so good.</p>\n<p>Now getting to my question - how can I make <code>TestT1</code> work with the same efficiency as <code>TestTM</code>? As you can see in <code>TestT1</code> a second object is move constructed - this is something I would like to avoid. How can I change the function <code>transform1()</code> to avoid any additional copies or moves? If you think about it, <code>TestT1</code> is not that much different from <code>TestTM</code>, so I have a feeling that this is something that must be possible.</p>\n<p>For my second attempt, <code>TestT2</code>, I tried passing the object via RValue reference. This eliminated the extra move constructor, but unfortunately this causes the destructor to be called before I am done with the object, which is not always ideal.</p>\n<p><strong>Update:</strong><br>\nI also note that it is possible to make it work using references, as long as you make sure not to use the object beyond the end of the statement:</br></p>\n<pre><code>W&amp;&amp; transform2( W&amp;&amp; w )\n{\n  w.Transform();\n  return std::move(w);\n}\n\nvoid run( W&amp;&amp; w )\n{\n  w.Run();\n}\n\nprintf( \"TestT3:\\n\" );           //TestT3:\n{                                //W::W()\n  run( transform2( make() ) );   //W::Transform()\n}                                //W::Run()\n                                 //W::~W()\n</code></pre>\n<p>Is this safe to do?</p>\n", "AcceptedAnswerId": "44476033", "Title": "C++ Named Return Value Optimization with nested function calls", "CreationDate": "2017-06-10T17:13:28.713", "Id": "44475982", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-06-10T18:40:51.000", "LastEditorUserId": "254722", "LastActivityDate": "2017-06-10T18:40:51.000", "Score": "4", "OwnerUserId": "254722", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "44476033": {"Id": "44476033", "PostTypeId": "2", "Body": "<p>This happens in <code>Test1</code> because the compiler is explicitly disallowed to apply NRVO from by value parameters from a function's argument list.  And in <code>Test1</code> you are accepting a <code>W</code> instance by value as a function parameter, so the compiler cannot elide the move on return. </p>\n<p>See <a href=\"https://stackoverflow.com/questions/6009278/why-are-by-value-parameters-excluded-from-nrvo\">Why are by-value parameters excluded from NRVO?</a> and my discussion with Howard Hinnant about the issue here <a href=\"https://stackoverflow.com/questions/43163801/why-does-for-each-return-function-by-move\">Why does for_each return function by move</a> in the comments</p>\n<p>You cannot make <code>Test1</code> work as efficiently as you did in the earlier case because of this. </p>\n<hr>\n<p>The relevant quote from the standard </p>\n<p><strong>15.8.3 Copy/move elision [class.copy.elision]</strong></p>\n<blockquote>\n<ol>\n<li><p id=\"so_44475982_44476033_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, ...</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, when the <em>expression</em> is the name of a non-volatile automatic object (other than a function parameter or a variable introduced by the <em>exception-declaration</em> of a <em>handler</em> (18.3)) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function call\u2019s return object</li>\n</ul></li>\n</ol>\n</blockquote>\n</hr>", "LastEditorUserId": "5501675", "LastActivityDate": "2017-06-10T17:31:52.897", "Score": "1", "CreationDate": "2017-06-10T17:18:43.503", "ParentId": "44475982", "CommentCount": "3", "LastEditDate": "2017-06-10T17:31:52.897", "OwnerUserId": "5501675"}});