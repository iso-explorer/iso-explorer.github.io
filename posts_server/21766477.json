post_cb({"21766477": {"ViewCount": "1110", "Body": "<p>The C++ Standard library provides the following guarantees about its types unless stated otherwise:</p>\n<p>(1) Read operations (i.e. working on a <code>const</code> object) are thread-safe. That means multiple threads may read from an object at the same time without race conditions as long as no thread is writing (applying a non-<code>const</code> operation) to the object at the same time. </p>\n<p>(2) Multiple threads may read and write arbitrary objects at the same time as long as each object is only accessed by at most one thread at a time. </p>\n<p>The standard library requires the same guarantees by user types. (You can read about this stuff in <a href=\"http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/\" rel=\"nofollow\">GotW #95</a> or watch <a href=\"http://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank\" rel=\"nofollow\">Herb at C++ and Beyond 2012</a> explaining about this.)</p>\n<p>Now my question is, if the following conclusion is correct: Since the <code>operator()</code> of <code>std::function</code> is a <code>const</code> member function, it is required to be thread-safe. If the functor passed in at construction has a const <code>operator()</code> member function, then the <code>std::function</code> object can assume it to be thread-safe and just forward the call. However, if the functor passed to it at construction has a mutable <code>operator()</code>, then this operation does not need to be thread-safe, but <code>std::function</code> still needs to be, because the call operator remains const. Hence <code>std::function</code> must externally synchronize calls to the stored mutable functor and hence use a mutex. This implies a performance overhead in case of passing mutable lambdas to the constructor of an <code>std::function</code>. </p>\n<p>Is this reasoning correct? If so, are current implementations compliant? </p>\n", "AcceptedAnswerId": "21767867", "Title": "Does std::function lock a mutex when calling an internal mutable lambda?", "CreationDate": "2014-02-13T22:02:35.890", "Id": "21766477", "CommentCount": "1", "LastEditDate": "2014-03-20T02:55:42.953", "PostTypeId": "1", "LastEditorUserId": "701092", "LastActivityDate": "2014-03-20T02:55:42.953", "Score": "3", "OwnerUserId": "1335865", "Tags": "<c++><c++11><locking><mutex><functor>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21766477_21767867_8": {"length": 17, "quality": 0.8947368421052632, "section_id": 6353}, "so_21766477_21767867_5": {"length": 23, "quality": 1.0, "section_id": 6350}, "so_21766477_21767867_7": {"length": 16, "quality": 1.0, "section_id": 6352}, "so_21766477_21767867_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 6348}, "so_21766477_21767867_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 6347}, "so_21766477_21767867_4": {"length": 22, "quality": 0.8461538461538461, "section_id": 6349}, "so_21766477_21767867_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 6346}, "so_21766477_21767867_9": {"length": 8, "quality": 0.6666666666666666, "section_id": 6354}, "so_21766477_21767867_6": {"length": 25, "quality": 0.8928571428571429, "section_id": 6351}}, "n3337": {"so_21766477_21767867_6": {"length": 25, "quality": 0.8928571428571429, "section_id": 6108}, "so_21766477_21767867_8": {"length": 17, "quality": 0.8947368421052632, "section_id": 6110}, "so_21766477_21767867_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 6104}, "so_21766477_21767867_5": {"length": 23, "quality": 1.0, "section_id": 6107}, "so_21766477_21767867_4": {"length": 22, "quality": 0.8461538461538461, "section_id": 6106}, "so_21766477_21767867_7": {"length": 16, "quality": 1.0, "section_id": 6109}, "so_21766477_21767867_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 6103}, "so_21766477_21767867_9": {"length": 8, "quality": 0.6666666666666666, "section_id": 6111}, "so_21766477_21767867_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 6105}}, "n4659": {"so_21766477_21767867_8": {"length": 17, "quality": 0.8947368421052632, "section_id": 7862}, "so_21766477_21767867_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 7857}, "so_21766477_21767867_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 7856}, "so_21766477_21767867_5": {"length": 23, "quality": 1.0, "section_id": 7859}, "so_21766477_21767867_6": {"length": 25, "quality": 0.8928571428571429, "section_id": 7860}, "so_21766477_21767867_7": {"length": 16, "quality": 1.0, "section_id": 7861}, "so_21766477_21767867_4": {"length": 22, "quality": 0.8461538461538461, "section_id": 7858}, "so_21766477_21767867_9": {"length": 8, "quality": 0.6666666666666666, "section_id": 7863}, "so_21766477_21767867_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 7855}}}, "21767867": {"Id": "21767867", "PostTypeId": "2", "Body": "<p>The behavior that Herb is talking about with respect to the standard library's guarantees on data race safety is specified in C++11 \u00a717.6.5.9:</p>\n<blockquote>\n<p id=\"so_21766477_21767867_0\"><strong>17.6.5.9 Data race avoidance [res.on.data.races]</strong></p>\n<p id=\"so_21766477_21767867_1\">1 This section specifies requirements that implementations shall meet to prevent data races (1.10). Every standard library function shall meet each requirement unless otherwise specified. Implementations may prevent data races in cases other than those specified below.</p>\n<p id=\"so_21766477_21767867_2\">2 A C++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s arguments, including <code>this</code>.</p>\n<p id=\"so_21766477_21767867_3\">3 A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const arguments, including <code>this</code>.</p>\n<p id=\"so_21766477_21767867_4\">4 [ Note: This means, for example, that implementations can\u2019t use a static object for internal purposes without synchronization because it could cause a data race even in programs that do not explicitly share objects between threads. \u2014end note ]</p>\n<p id=\"so_21766477_21767867_5\">5 A C++ standard library function shall not access objects indirectly accessible via its arguments or via elements of its container arguments except by invoking functions required by its specification on those container elements.</p>\n<p id=\"so_21766477_21767867_6\">6 Operations on iterators obtained by calling a standard library container or string member function may access the underlying container, but shall not modify it. [ Note: In particular, container operations that invalidate iterators conflict with operations on iterators associated with that container. \u2014end note ]</p>\n<p id=\"so_21766477_21767867_7\">7 Implementations may share their own internal objects between threads if the objects are not visible to users and are protected against data races.</p>\n<p id=\"so_21766477_21767867_8\">8 Unless otherwise specified, C++ standard library functions shall perform all operations solely within the current thread if those operations have effects that are visible (1.10) to users.</p>\n<p id=\"so_21766477_21767867_9\">9 [ Note: This allows implementations to parallelize operations if there are no visible side effects. \u2014end note ]</p>\n</blockquote>\n<p>Say you pass a lambda closure to <code>std::function</code> - via, e.g., the constructor or assignment operator - and then invoke that <code>function</code>'s <code>operator()</code>. By paragraph 1, <code>operator ()</code> is allowed to access the closure object \"directly or indirectly via the function\u2019s arguments, including <code>this</code>.\" By paragraph 2, it may not change the state of the <code>std::function</code> object itself or the closure object since they are both \"accessed directly or indirectly via the function\u2019s non-const arguments, including <code>this</code>.\" This behavior is easily achieved without any kind of protection against simultaneous thread accesses, i.e., locking.</p>\n<p><code>operator ()</code> then invokes the lambda closure's <code>operator()</code>, and the rules change: your lambda's <code>operator ()</code> is NOT a standard library function, and hence not subject to the rules that specify the behavior of standard library functions. You can do whatever you like to the closure object subject to the rules of the language.</p>\n<p>The Standard Library guarantees that it won't introduce any data races through its actions, but you are responsible for any data races that might be introduced by your code.</p>\n", "LastActivityDate": "2014-02-13T23:29:43.787", "CommentCount": "1", "CreationDate": "2014-02-13T23:29:43.787", "ParentId": "21766477", "Score": "5", "OwnerUserId": "923854"}});