post_cb({"bq_ids": {"n4140": {"so_17905265_17905422_1": {"length": 35, "quality": 1.0, "section_id": 438}, "so_17905265_17905422_0": {"length": 17, "quality": 0.6538461538461539, "section_id": 435}, "so_17905265_17905430_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 435}}, "n3337": {"so_17905265_17905430_1": {"length": 17, "quality": 0.5666666666666667, "section_id": 451}, "so_17905265_17905430_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 427}, "so_17905265_17905422_1": {"length": 35, "quality": 1.0, "section_id": 429}, "so_17905265_17905422_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 427}}, "n4659": {"so_17905265_17905422_1": {"length": 35, "quality": 1.0, "section_id": 458}, "so_17905265_17905422_0": {"length": 17, "quality": 0.6538461538461539, "section_id": 454}, "so_17905265_17905430_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 454}}}, "17905265": {"ViewCount": "927", "Body": "<p>I know that default initialization for non-POD types will also default initialize non-static non-POD member variables by calling their default constructor. But I'm not sure exactly how this happens. Here is an example of what I mean:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Test2 {\n  public:\n    Test2() {cout &lt;&lt;\"Here\";}\n};\n\nclass Test {\n  public:\n    Test() {}\n    Test2 i;\n};\n\nint main() {\n  Test foo;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>Here\n</code></pre>\n<p>Based on the C++ standard on initializers (8.5), for default initialization:</p>\n<pre><code>\u2014 if T is a non-POD class type (clause 9), the default constructor\nfor T is called (and the initialization is ill-formed if T has no\naccessible default constructor);\n</code></pre>\n<p>So given this, I do expect that the default constructor <code>Test()</code> will get called, but my empty default constructor for the class <code>Test</code> does not initialize <code>Test2 i</code> explicitly yet clearly, <code>Test2()</code> is getting called implicitly somehow. What I'm wondering is how this happens?</p>\n<p>Similarly, for value initialization (not related to example above), if an empty user defined default constructor does not explicitly zero initialize a POD non-static member variable, how does that variable get zero initialized (which I know it does do)? Since based on the standard, it seems that for value initialization, all that happens when you have a user defined default constructor is that the constructor gets called.</p>\n<p>The corresponding part of the C++ standard for value initialization is the following:</p>\n<pre><code>\u2014 if T is a class type (clause 9) with a user-declared constructor (12.1), then the   \ndefault constructor for T is called (and the initialization is ill-formed if T has no \naccessible default constructor);\n</code></pre>\n<p>This question is similar to <a href=\"https://stackoverflow.com/questions/15151164/c-empty-constructor-and-member-initialization\">c++ empty constructor and member initialization</a>\nBut the difference is that instead of asking what the end result behavior is, I'd like to know why the end result behavior happens.</p>\n", "AcceptedAnswerId": "17905422", "Title": "Confused on how empty user defined constructor will initialize non-static non-POD member variables", "CreationDate": "2013-07-28T05:24:45.233", "Id": "17905265", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:30:09.167", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-28T18:40:15.220", "Score": "2", "OwnerUserId": "1082160", "Tags": "<c++><initialization><default-constructor><value-initialization>", "AnswerCount": "3"}, "17905422": {"Id": "17905422", "PostTypeId": "2", "Body": "<p>In the C++11 standard, section 12.6 paragraph 8:</p>\n<blockquote>\n<p id=\"so_17905265_17905422_0\">In a non-delegating constructor, if a given non-static data member or base class is not designated by a mem-initializer-id (including the case where there is no mem-initializer-list because the constructor has no ctor-initializer) and the entity is not a virtual base class of an abstract class (10.4), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized\n  as specified in 8.5;</li>\n<li>otherwise, if the entity is a variant member (9.5), no initialization is performed;</li>\n<li>otherwise, the entity is default-initialized (8.5).</li>\n</ul>\n</blockquote>\n<p>You are encountering the third case, where there is no initializer for the member and the member isn't a variant member, so in that case it is default-initialized.</p>\n<p>Also, from paragraph 10:</p>\n<blockquote>\n<p id=\"so_17905265_17905422_1\">In a non-delegating constructor, initialization proceeds in the following order:\n  - First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</p>\n<ul>\n<li>Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers).</li>\n<li>Then, non-static data members are initialized in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers).</li>\n<li>Finally, the compound-statement of the constructor body is executed.</li>\n</ul>\n</blockquote>\n<p>Regardless of what you specify in your constructor, the members are going to be initialized just before the body of the constructor is executed.</p>\n<p>A mem-initializer-id is the identifier used to refer to a member in a constructor initializer list:</p>\n<pre><code>class Test {\n  public:\n    Test() : i() {} // Here `i` is a mem-initializer-id\n    Test2 i;\n};\n</code></pre>\n", "LastEditorUserId": "951890", "LastActivityDate": "2013-07-28T06:05:19.367", "Score": "2", "CreationDate": "2013-07-28T05:50:34.583", "ParentId": "17905265", "CommentCount": "8", "LastEditDate": "2013-07-28T06:05:19.367", "OwnerUserId": "951890"}, "17911416": {"Id": "17911416", "PostTypeId": "2", "Body": "<p>Value initialization of a type with a user-defined default constructor performs no initialization on non-static POD members if they are not explicitly initialized in the constructor. E.g., in <a href=\"http://coliru.stacked-crooked.com/view?id=47f33b7aa7d96fa244ca240673864c33-e1204655eaff68246b392dc70c5a32c9\" rel=\"nofollow\">this program</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Foo {\n    // Foo has a user-defined default constructor\n    // that does not initialize i\n    Foo() {}\n    int i;\n};\n\nint main() {\n    Foo x{}; // value-initialize x\n    cout &lt;&lt; x.i &lt;&lt; endl;\n}\n</code></pre>\n<p><code>x.i</code> is uninitialized. The program therefore technically has undefined behavior, but in this case \"undefined behavior\" most likely means that it will print an unspecified integer value that is likely not 0.</p>\n<p>Language lawyer argument:</p>\n<ul>\n<li>\u00a712.6.1p2: \"An object of class type can also be initialized by a <em>braced-init-list</em>. List-initialization semantics apply; see 8.5 and 8.5.4.\"</li>\n<li>\u00a78.5.4p3: \"List-initialization of an object or reference of type <code>T</code> is defined as follows: ... If the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.\"</li>\n<li>\u00a78.5p7: \"To <em>value-initialize</em> an object of type <code>T</code> means: ... if <code>T</code> is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor)</li>\n</ul>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-07-28T18:40:15.220", "Score": "2", "CreationDate": "2013-07-28T18:28:41.427", "ParentId": "17905265", "CommentCount": "0", "LastEditDate": "2013-07-28T18:40:15.220", "OwnerUserId": "923854"}, "17905430": {"Id": "17905430", "PostTypeId": "2", "Body": "<p>According to the draft of the C++ standard found at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf</a>, section 12.6.2:</p>\n<blockquote>\n<p id=\"so_17905265_17905430_0\">If a given non-static data member or base class is not named by a mem-initializer-id (including the case where there is no mem-initializer-list because the constructor has no ctor-initializer), then</p>\n<p id=\"so_17905265_17905430_1\">\u2014 If the entity is a non-static data member of (possibly cv-quali\ufb01ed) class type (or array thereof) or a base class, and the entity class is a non-POD class, the entity is default-initialized (8.5). If the entity is a non-static data member of a const-quali\ufb01ed type, the entity class shall have a user-declared default constructor.</p>\n<p id=\"so_17905265_17905430_2\">\u2014 Otherwise, the entity is not initialized. If the entity is of const-quali\ufb01ed type or reference type, or of a (possibly cv-quali\ufb01ed) POD class type (or array thereof) containing (directly or indirectly) a member of a const-quali\ufb01ed type, the program is ill-formed.</p>\n</blockquote>\n<p>In other words, if an object of a non-POD class type does not appear in an initializer list, the compiler interprets this as if the object <em>had</em> appeared with its default constructor being called.</p>\n<p>Also, note that other types (i.e. primitives and POD types) are not initialized, which is different from what you indicated in your question. Global objects are zero-initialized, but the same isn't true for objects on the stack. Here is a small program I put together to test this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass T\n{\npublic:\n    T() {}\n\n    void put(std::ostream &amp;out)\n    {\n        out &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; std::endl;\n        out &lt;&lt; \"b = \" &lt;&lt; b &lt;&lt; std::endl;\n        out &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; std::endl;\n    }\nprivate:\n    int a;\n    int b;\n    int c;\n};\n\nT t2;\n\nint main()\n{\n    T t;\n    t.put(std::cout);\n    t2.put(std::cout);\n\n    return 0;\n}\n</code></pre>\n<p>Compiling with g++ 4.5.2, I got the following output:</p>\n<pre><code>a = 8601256\nb = 3\nc = 2130567168\na = 0\nb = 0\nc = 0\n</code></pre>\n", "LastActivityDate": "2013-07-28T05:51:53.623", "Score": "0", "CreationDate": "2013-07-28T05:51:53.623", "ParentId": "17905265", "CommentCount": "1", "OwnerUserId": "2332809"}});