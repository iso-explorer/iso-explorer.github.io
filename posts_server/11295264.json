post_cb({"11295264": {"CommentCount": "7", "ViewCount": "170", "CreationDate": "2012-07-02T14:02:02.813", "LastActivityDate": "2012-07-02T14:25:28.960", "Title": "Get last item from input iterator", "PostTypeId": "1", "Id": "11295264", "Score": "0", "Body": "<p>Is this correct behaviour for an input iterator, with regard to accessing the last item:</p>\n<pre><code>for(i=being();i!=end();i++){}\nstd::string s = i-&gt;toString();\nreturn s;\n</code></pre>\n<p>Or should it throw an exception if I try to do this?</p>\n<p>My iterator makes use of two c function calls: getFirst(...) and getNext(...)</p>\n", "Tags": "<c++>", "OwnerUserId": "607846", "AnswerCount": "4"}, "11295390": {"ParentId": "11295264", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is not a correct behavior. The standard convention in C++ is that, <code>end()</code> should point to the place beyond the last item. Dereferencing it will cause undefined behavior (C++11 \u00a724.2.2/5) in general. </p>\n<p>You may make your own iterator to forgive dereferencing <code>end()</code> and exploit this, but it deviates from the standard practice, and make it hard for people to understand your code. I suggest you to throw an exception instead of returning the last item.</p>\n<hr>\n<p>In standard C++, if all you have is a non-reproducible input iterator, it's not possible to \"get the last item\" unless you extract it every time:</p>\n<pre><code>auto it = begin();\nauto val;\nwhile (it != end()) {\n    val = *it;\n    ++ it;\n}\nreturn val;\n</code></pre>\n<p>But if you can create a <em>forward</em> iterator, then you could use</p>\n<pre><code>auto iter = begin();\ndecltype(iter) last_iter;\nwhile (true) {\n    last_iter = iter++;\n    if (iter == end())\n        break;\n}\nreturn last_iter;\n</code></pre>\n<p>Or if you creating the input iterator twice is cheap, you could do the iteration twice:</p>\n<pre><code>auto dist = std::distance(begin(), end());\nauto last_iter = begin();\nstd::advance(last_iter, dist - 1);\nreturn last_iter;\n</code></pre>\n</hr>", "OwnerUserId": "224671", "LastEditorUserId": "224671", "LastEditDate": "2012-07-02T14:20:56.717", "Id": "11295390", "Score": "2", "CreationDate": "2012-07-02T14:09:30.223", "LastActivityDate": "2012-07-02T14:20:56.717"}, "11295394": {"ParentId": "11295264", "CommentCount": "10", "Body": "<p>as far as stl containers are concerned, it is not correct behavior.</p>\n<p>end()</p>\n<blockquote>\n<p id=\"so_11295264_11295394_0\">Returns an iterator referring to the past-the-end element in the list\n  container.</p>\n</blockquote>\n<p>which would mean that after your loop, i does not point to a correct object (NOT the last element), but rather to a special defined end value, which would result in a access violation on calling i-&gt;toString().</p>\n", "OwnerUserId": "554028", "PostTypeId": "2", "Id": "11295394", "Score": "0", "CreationDate": "2012-07-02T14:09:48.560", "LastActivityDate": "2012-07-02T14:09:48.560"}, "11295619": {"ParentId": "11295264", "CommentCount": "0", "Body": "<p>The behavior is undefined, and you needn't do anything about it while implementing your iterator (no need to even throwing an exception). When implementing InputIterators, you only have to implement the operations</p>\n<ul>\n<li><code>iter == iter2</code>, <code>iter != iter2</code></li>\n<li><code>*iter</code>, <code>iter-&gt;...</code></li>\n<li><code>++iter</code>, <code>(void)iter++</code></li>\n<li><code>*r++</code></li>\n</ul>\n<p>Of those, only the last one is hard (you have to return data from the previous position, while the iterator is moved to the next). It is typically implemented by a proxy, that remembers the old data.</p>\n", "OwnerUserId": "51831", "PostTypeId": "2", "Id": "11295619", "Score": "0", "CreationDate": "2012-07-02T14:25:28.960", "LastActivityDate": "2012-07-02T14:25:28.960"}, "bq_ids": {"n4140": {"so_11295264_11295394_0": {"section_id": 763, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_11295264_11295394_0": {"section_id": 750, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_11295264_11295394_0": {"section_id": 823, "quality": 0.7142857142857143, "length": 5}}}, "11295341": {"ParentId": "11295264", "CommentCount": "0", "Body": "<p>No, this is not OK, you'll be dereferencing <code>end()</code> and invoking undefined behaviour. Consider:</p>\n<pre><code>int main()\n{\n    int i = 0;\n    for (; i &lt; 42; ++i) ;\n    std::cout &lt;&lt; i;    // prints 42, did you expect 41?\n}\n</code></pre>\n<p>Unless of course, you implemented your iterator class to do something sensible in this case. This not ok for standard library iterators, however.</p>\n", "OwnerUserId": "947836", "PostTypeId": "2", "Id": "11295341", "Score": "0", "CreationDate": "2012-07-02T14:05:59.857", "LastActivityDate": "2012-07-02T14:05:59.857"}});