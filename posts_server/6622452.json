post_cb({"14050604": {"ParentId": "6622452", "CommentCount": "2", "Body": "<p>I am not sure if I understand the question, but in any case I tried to simulate specialization of alias template. </p>\n<p>I assume that the idea is to restrict the alias template to certain (pattern matched type); something that we used to do with this sort of code:</p>\n<pre><code>template&lt;class Vector&gt; struct old_style;\ntemplate&lt;class T&gt; struct old_style&lt;std::vector&lt;T&gt; &gt;{\n   typedef typename std::vector&lt;T&gt;::value_type type;\n};\n</code></pre>\n<p>(this is just an example, there are other way to extract the <code>value_type</code> of a generic <code>std::vector</code>).</p>\n<p>Now to the aliases:</p>\n<pre><code>template&lt;class Vector&gt; using new_style = typename Vector::value_type;\n</code></pre>\n<p>It does the same work, but this does not replace <code>old_stype&lt;...&gt;::type</code>, since it is not as restrictive. The first try to have a perfect alias replacement is this hypothetical code:</p>\n<pre><code>//template&lt;class Vector&gt; using new_style2; // error already here\n//template&lt;class T&gt; using new_style2&lt;std::vector&lt;T&gt; &gt; = typename Vector::value_type;\n</code></pre>\n<p>Unfortunately it doesn't compile (in theory because of nominal reasons stated in other answers and in the standard, in practice I guess there is no fundamental reason for this to be a limitation). Fortunately one can fallback to the old fashioned <code>struct::type</code> way of doing it an only use the new alias template feature to forward the work,</p>\n<pre><code>template&lt;class Vector&gt; struct new_style2_aux;\ntemplate&lt;class T&gt; struct new_style2_aux&lt;std::vector&lt;T&gt; &gt;{\n   typedef typename std::vector&lt;T&gt;::value_type type;\n};\ntemplate&lt;class Vector&gt; using new_style2 = typename new_style2_aux&lt;Vector&gt;::type;\n</code></pre>\n<p>One can make it automatic with a <code>define</code></p>\n<pre><code>#define SPECIALIZED_ALIAS_TEMPLATE(NamE, Pattern_arG, PatterN_expR, DefinitioN) \\\ntemplate&lt;class&gt; struct NamE ## _aux; \\\ntemplate&lt;Pattern_arG&gt; struct NamE ## _aux&lt;PatterN_expR&gt;{ \\\n    typedef DefinitioN type; \\\n}; \\\ntemplate&lt;class NamE ## _dummy&gt; using NamE = typename NamE ## _aux&lt; NamE ## _dummy &gt;::type; \n</code></pre>\n<p>Which can be used as:</p>\n<pre><code>SPECIALIZED_ALIAS_TEMPLATE(new_style3, class T, std::vector&lt;T&gt;, typename std::vector&lt;T&gt;::value_type);\n</code></pre>\n<p>If one needs an arbitrary number of specializations (or non local in the code), one has to use a more complicated <code>define</code> in two parts, one for declaring and one for specializing (as it should be):</p>\n<pre><code>#define DECLARE_ALIAS_TEMPLATE(NamE)\\\ntemplate&lt;class&gt; struct NamE ## _aux;\\\ntemplate&lt;class NamE ## _dummy&gt; using NamE = typename NamE ## _aux&lt; NamE ## _dummy &gt;::type; \n\n#define SPECIALIZE_ALIAS_TEMPLATE(NamE, Pattern_arG, PatterN_expR, DefinitioN)\\\ntemplate&lt;Pattern_arG&gt; struct NamE ## _aux&lt;PatterN_expR&gt;{ \\\n    typedef DefinitioN type; \\\n};\n</code></pre>\n<p>Used as follows:</p>\n<pre><code>DECLARE_ALIAS_TEMPLATE(new_style4);\n\nSPECIALIZE_ALIAS_TEMPLATE(new_style4, class T, std::vector&lt;T&gt;, typename std::vector&lt;T&gt;::value_type);\nSPECIALIZE_ALIAS_TEMPLATE(new_style4, class T, std::set&lt;T&gt;, typename std::set&lt;T&gt;::value_type);\n</code></pre>\n<p>All the code above can be copied and pasted to test:</p>\n<pre><code>#include&lt;vector&gt;\n#include&lt;map&gt;\n// ... paste code above //\nint main(){\n    old_style&lt;std::vector&lt;double&gt; &gt;::type a; // is a double\n//  old_style&lt;std::set&lt;double&gt; &gt;::type a; // error (should work only for std::vector)\n    new_style2&lt;std::vector&lt;double&gt; &gt; b; // is double\n//  new_style2&lt;std::set&lt;double&gt; &gt; c; // error (should work only for std::vector)\n    new_style3&lt;std::vector&lt;double&gt; &gt; d; // is double\n//  new_style3&lt;std::set&lt;double&gt; &gt; d; // error (should work only for std::vector)\n    new_style4&lt;std::vector&lt;double&gt; &gt; e; // is double\n    new_style4&lt;std::set&lt;double&gt; &gt; f; // is double, this is another specialization\n    return 0;\n}\n</code></pre>\n<p>Sorry if this is not what you are looking for. I believe it can be used with variadic templates, and with extra template arguments (in the specialization) but didn't test it.</p>\n<p>Improvements are very welcomed.</p>\n", "OwnerUserId": "225186", "PostTypeId": "2", "Id": "14050604", "Score": "4", "CreationDate": "2012-12-27T06:48:54.663", "LastActivityDate": "2012-12-27T06:48:54.663"}, "6622494": {"ParentId": "6622452", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Bjarne <a href=\"http://www.stroustrup.com/C++11FAQ.html#template-alias\" rel=\"nofollow\">says</a>:</p>\n<blockquote>\n<p id=\"so_6622452_6622494_0\">Specialization works (you can alias a set of specializations but you cannot specialize an alias)</p>\n</blockquote>\n<p>And, whilst not an explicit rule, \"alias templates\" are missing from the following list at 14.7.3/1:</p>\n<blockquote>\n<p id=\"so_6622452_6622494_1\">An explicit specialization of any of the following:</p>\n<ul>\n<li>function template</li>\n<li>class template</li>\n<li>member function of a class template </li>\n<li>static data member of a class template</li>\n<li>member class of a class template</li>\n<li>member class template of a class or class template</li>\n<li>member function template of a class or class template</li>\n</ul>\n<p id=\"so_6622452_6622494_2\">can be declared[...]</p>\n</blockquote>\n<p>I think that this is the best guarantee you'll get.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "225186", "LastEditDate": "2014-01-03T09:12:08.900", "Id": "6622494", "Score": "7", "CreationDate": "2011-07-08T09:28:44.690", "LastActivityDate": "2014-01-03T09:12:08.900"}, "6622452": {"CommentCount": "6", "AcceptedAnswerId": "6623089", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-07-08T09:25:32.083", "LastActivityDate": "2014-01-03T09:12:08.900", "LastEditDate": "2011-10-02T10:31:04.137", "ViewCount": "9272", "FavoriteCount": "5", "Title": "Alias template specialisation", "Id": "6622452", "Score": "18", "Body": "<p>Can alias templates (14.5.7) be explicitly specialised (14.7.3)?</p>\n<p>My standard-fu fails me, and I can't find a compiler to test on.</p>\n<p>The text \"when a template-id refers to the specialization of an alias template\" implies <em>yes</em>, but then the example appears to refer to something else, implying <em>no</em>.</p>\n<p><sub><strong>NB.</strong> I'm working from n3242, one behind the FDIS, in which the title of this section is \"Aliase templates\". Lol.</sub></p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "560648", "AnswerCount": "3"}, "6623089": {"ParentId": "6622452", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>What the Standard means by \"specialization\" is the transformation of a generic template to a <em>more specialized</em> entity. For example, instantiating a non-member class template yields a class that's not a template anymore. The term \"specialization\" is two fold, and can refer to a generated specialization (which is a specialization that was instantiated, possibly from a partial specialization) and to an explicit specialization (which is what you referred to). </p>\n<p>Alias templates aren't instantiated and there aren't specializations of them. There is nothing they could instantiate to. Instead, whenever their name is followed by a template argument list, the type denoted is the type you get by replacing the name and argument list by the alias'ed type, replacing all template parameter references with the arguments given in the argument list. That is, rather than the specialization of it being an alias, the alias template itself serves as an alias, without the need to instantiate anything. This replacement is done very early. Consider:</p>\n<pre><code>template&lt;typename T&gt; using ref = T&amp;;\ntemplate&lt;typename T&gt; void f(ref&lt;T&gt; x) { x = 10; }\nint main() { int a; f(a); return a; /* 10 */ }\n</code></pre>\n<p>The replacement is done at the time <code>ref&lt;T&gt;</code> is named (such a names are used to refer to class or function template specializations; hence the spec describes such names to \"refer to the specialization of an alias template\"). That is, the parameter of <code>f</code> has type <code>T&amp;</code>, and thus, <code>T</code> can be deduced. This property is preventing explicit or partial specializations of alias templates. Because in order to pick the correct specialization of <code>ref</code>, it needs to know <code>T</code>. But to know it, it needs to compare <code>ref&lt;T&gt;</code> against the argument type to deduce <code>T</code>. It's summarized in the paper <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2002/n1406.pdf\" rel=\"noreferrer\">N1406, \"Proposed addition to C++: Typedef Templates\"</a>, section 2.2</p>\n<blockquote>\n<p id=\"so_6622452_6623089_0\"><strong>2.2 The Main Choice: Specialization vs. Everything Else</strong></p>\n<p id=\"so_6622452_6623089_1\">After discussion on the reflectors and in the Evolution WG, it turns out that we have to choose between two mutually exclusive models:</p>\n<ol>\n<li><p id=\"so_6622452_6623089_2\">A typedef template is not itself an alias; only the (possibly-specialized) instantiations of the typedef template are aliases. This choice allows us to have specialization of typedef templates.</p></li>\n<li><p id=\"so_6622452_6623089_3\">A typedef template is itself an alias; it cannot be specialized. This choice would allow:</p>\n<ul>\n<li>deduction on typedef template function parameters (see 2.4)</li>\n<li>a declaration expressed using typedef templates be the same as the declaration without\n  typedef templates (see 2.5)</li>\n<li>typedef templates to match template template parameters (see 2.6)</li>\n</ul></li>\n</ol>\n</blockquote>\n<p>It should be noted that the quoted paper, which favors option 1, did not make it into C++0x.</p>\n<hr>\n<p>EDIT: Because you desperately want to have a spec quote saying so explicitly. 14.5p3 is one that does</p>\n<blockquote>\n<p id=\"so_6622452_6623089_4\">Because an alias-declaration cannot declare a template-id, it is not possible to partially or explicitly specialize an alias template.</p>\n</blockquote>\n</hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2012-03-18T02:10:07.443", "Id": "6623089", "Score": "21", "CreationDate": "2011-07-08T10:19:08.900", "LastActivityDate": "2012-03-18T02:10:07.443"}, "bq_ids": {"n4140": {"so_6622452_6623089_4": {"section_id": 99, "quality": 1.0, "length": 11}}, "n3337": {"so_6622452_6623089_4": {"section_id": 94, "quality": 1.0, "length": 11}}, "n4659": {"so_6622452_6623089_4": {"section_id": 103, "quality": 1.0, "length": 11}}}});