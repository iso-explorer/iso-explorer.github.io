post_cb({"21606198": {"ParentId": "21606073", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes, the check for non-null is required by the standard (C++11, <code>[unique.ptr.single.modifiers]\u00a74</code>):</p>\n<blockquote>\n<pre><code>void reset(pointer p = pointer()) noexcept;\n</code></pre>\n<p id=\"so_21606073_21606198_0\"><em>4 Effects:</em> assigns <code>p</code> to the stored pointer, and then <strong>if the old value of the stored pointer, <code>old_p</code>, was not equal to <code>nullptr</code>, calls <code>get_deleter()(old_p)</code></strong>. [ <em>Note:</em> The order of these operations is significant because the call to get_deleter() may destroy <code>*this</code>. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p><strong>Discussion:</strong> An alternative way to standardise it would be to put the \"burden\" on the user of the class, i.e. require all deleters (the default one <em>and</em> any custom ones) to work fine when invoked on a null pointer.</p>\n<p>However, I understand the idea was to enable functions like <code>free()</code> and even things like a hypothetical <code>unlock_mutex(Mutex*)</code> to work as deleters out-of-the-box, regardless of how/if they handle null pointers. So putting this check into the <code>unique_ptr</code> itself broadens the selection of deleters which can be used directly.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2014-02-06T15:14:44.667", "Id": "21606198", "Score": "6", "CreationDate": "2014-02-06T14:54:19.697", "LastActivityDate": "2014-02-06T15:14:44.667"}, "21606240": {"ParentId": "21606073", "CommentCount": "2", "Body": "<p>What if your deleter does not do a simple delete operation ? What if your unique_ptr has a custom deleter that does something else, would you like your deleter to be called with nullptr as a parameter ? :D</p>\n", "OwnerUserId": "1147772", "PostTypeId": "2", "Id": "21606240", "Score": "2", "CreationDate": "2014-02-06T14:55:48.797", "LastActivityDate": "2014-02-06T14:55:48.797"}, "21606073": {"CommentCount": "1", "AcceptedAnswerId": "21606198", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2014-02-06T14:48:36.213", "LastActivityDate": "2015-08-28T16:15:31.243", "LastEditDate": "2015-08-28T16:15:31.243", "ViewCount": "1251", "FavoriteCount": "1", "Title": "std::unique_ptr::reset checks for managed pointer nullity?", "Id": "21606073", "Score": "5", "Body": "<p>I've been reading about the C++11 smart pointers in order to use them on my sources, the documentation I've been reading is the one on cppreference.com; while reading about the <code>std::unique_ptr</code>, on the <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/reset\" rel=\"nofollow\"><code>reset</code> function</a> there's a documentation that seems incorrect to me (emphasis mine):</p>\n<blockquote>\n<p id=\"so_21606073_21606073_0\">Replaces the managed object.</p>\n<ul>\n<li><p id=\"so_21606073_21606073_1\">Given <code>current_ptr</code>, the pointer that was managed by <code>*this</code>, performs the following actions, in this order:</p>\n<ol>\n<li>Saves a copy of the current pointer <code>old_ptr = current_ptr</code>.</li>\n<li>Overwrites the current pointer with the argument <code>current_ptr = ptr</code>.</li>\n<li><strong>If the old pointer was non-empty, deletes the previously managed object <code>if(old_ptr != nullptr) get_deleter()(old_ptr)</code></strong>.</li>\n</ol></li>\n</ul>\n</blockquote>\n<p>In the C++ standard documentation, we can read the well known delete null pointer feature:</p>\n<p>Extract from <code>n3690</code> standard <strong>5.3.5 Delete</strong> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_21606073_21606073_2\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, then:</p>\n<p id=\"so_21606073_21606073_3\">\u2014 If the allocation call for the new-expression for the object to be deleted was not omitted, the <em>delete-expression</em> shall call a deallocation function. The value returned from the allocation call of the new-expression shall be passed as the first argument to the deallocation function.</p>\n<p id=\"so_21606073_21606073_4\">\u2014 <strong>Otherwise, the <em>delete-expression</em> will not call a deallocation function</strong>.</p>\n</blockquote>\n<p>So, I'm wondering why cppreference says that the <code>unique_ptr::reset</code> function checks for the nullity of the managed pointer before it's deletion even while te standard says that no deallocation function would be called over a null pointer (that's why the cppreference documentation seems incorrect to me).</p>\n<p>Is kind of obvious that I must be mistaken and there must be a reason to do things this way, but I'm unable to imagine what reason it could be. Any hints?</p>\n<p>PS: Where in the standard is defined how the <code>std::unique_ptr</code> must be implemented or behave? In the <strong>20.9.1 Class template <code>unique_ptr</code></strong> I cannot found anything about the <em>check-for-nullity</em> stuff.</p>\n", "Tags": "<c++><c++11><language-lawyer><unique-ptr><delete-operator>", "OwnerUserId": "499359", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_21606073_21606073_4": {"section_id": 6111, "quality": 1.0, "length": 6}, "so_21606073_21606073_3": {"section_id": 6111, "quality": 0.9545454545454546, "length": 21}, "so_21606073_21606198_0": {"section_id": 4341, "quality": 0.8148148148148148, "length": 22}, "so_21606073_21606073_2": {"section_id": 6111, "quality": 1.0, "length": 7}}, "n3337": {"so_21606073_21606073_4": {"section_id": 407, "quality": 0.6666666666666666, "length": 4}, "so_21606073_21606198_0": {"section_id": 4182, "quality": 0.8148148148148148, "length": 22}, "so_21606073_21606073_2": {"section_id": 5876, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_21606073_21606073_4": {"section_id": 7608, "quality": 1.0, "length": 6}, "so_21606073_21606198_0": {"section_id": 5598, "quality": 0.7777777777777778, "length": 21}, "so_21606073_21606073_3": {"section_id": 7608, "quality": 0.9545454545454546, "length": 21}, "so_21606073_21606073_2": {"section_id": 7608, "quality": 1.0, "length": 7}}}});