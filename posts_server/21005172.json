post_cb({"bq_ids": {"n4140": {"so_21005172_21005338_1": {"length": 7, "quality": 1.0, "section_id": 7087}, "so_21005172_21005338_0": {"length": 12, "quality": 1.0, "section_id": 584}, "so_21005172_21005338_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 587}}, "n3337": {"so_21005172_21005338_1": {"length": 7, "quality": 1.0, "section_id": 6831}, "so_21005172_21005338_0": {"length": 12, "quality": 1.0, "section_id": 574}, "so_21005172_21005338_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 577}}, "n4659": {"so_21005172_21005338_1": {"length": 7, "quality": 1.0, "section_id": 8588}, "so_21005172_21005338_0": {"length": 12, "quality": 1.0, "section_id": 607}, "so_21005172_21005338_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 610}}}, "21005338": {"Id": "21005338", "PostTypeId": "2", "Body": "<p>First off, note that being declared as <code>delete</code>d is irrelevant, since deleted functions still take part in overload resolution.</p>\n<p>Now, on to overload resolution. Cf. 13.3.1.2/3:</p>\n<blockquote>\n<p id=\"so_21005172_21005338_0\">three sets of candidate functions, designated <em>member candidates</em>, <em>nonmember\n  candidates</em> and <em>built-in candidates</em>, are constructed</p>\n</blockquote>\n<p>(There are no member candidates, since <code>E</code> is not a class type.) We know from  that the operator overload is found by <em>unqualified lookup</em>. So when we consult 3.4.1 (\"Unqualified lookup\"), we find that</p>\n<blockquote>\n<p id=\"so_21005172_21005338_1\">name lookup ends as soon as a declaration is found for the name.</p>\n</blockquote>\n<p>Since you introduce the second operator overload within the namespace <code>N</code>, it is found first, and name lookup stops. At this point, the overload set consists of your <code>int N::operator|(N::F, int)</code> and the built-in operators. Continuing in 13.3.1.2/6:</p>\n<blockquote>\n<p id=\"so_21005172_21005338_2\">The set of candidate functions for overload resolution is the union of the member candidates, the non-member candidates, and the built-in candidates.</p>\n</blockquote>\n<p>Only the builtin is viable (since you cannot convert <code>E</code> to <code>F</code> implicitly), and thus it is chosen.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2014-01-08T21:56:01.633", "Score": "5", "CreationDate": "2014-01-08T20:00:21.107", "ParentId": "21005172", "CommentCount": "7", "OwnerUserId": "596781", "LastEditDate": "2014-01-08T21:56:01.633"}, "21005172": {"ViewCount": "112", "Body": "<p>I came across a strange situation today, where declaring a deleted operator with certain arguments changed the behaviour of seemingly unrelated code.</p>\n<p>I reduced it to the following. Start with this:</p>\n<pre><code>namespace N \n{\n    enum E { A, B };\n\n    struct C \n    {   \n        C(E);\n    private:\n        C(int);\n    };  \n}\n\nN::E operator|(N::E, N::E);\n\nnamespace N\n{\n    void Waldo()\n    {   \n        C(A | B); \n    }   \n}\n</code></pre>\n<p>Notice that C has two constructors, a public one and a private one. This code compiles, indicating that the public overload is being chosen, so the expression <code>A | B</code> has type <code>E</code>. In turn this means that the <code>operator|(N::E, N::E)</code> has been matched (otherwise <code>A</code> and <code>B</code> would undergo implicit conversion to integers, the type of <code>A | B</code> would be <code>int</code>, and the private constructor would be matched.</p>\n<p>So far so good. Now I define a new enumeration type <code>F</code>, and a deleted <code>operator|</code> that involves F:</p>\n<pre><code>namespace N \n{\n    enum E { A, B };\n\n    struct C \n    {   \n        C(E);\n    private:\n        C(int);\n    };  \n}\n\nN::E operator|(N::E, N::E);\n\nnamespace N\n{\n    enum F {};\n    int operator|(F, int) = delete; \n\n    void Waldo()\n    {   \n        C(A | B); \n    }   \n}\n</code></pre>\n<p>Now the code doesn't compile, saying that <code>C(int)</code> is private. This indicates that now <code>A | B</code> has type <code>int</code>, which means <code>operator|(N::E, N::E)</code> is no longer being matched.</p>\n<p><strong>Why did the addition of the deleted <code>operator|(F, int)</code> stop <code>operator|(N::E, N::E)</code> from being matched?</strong></p>\n", "AcceptedAnswerId": "21005338", "Title": "Unrelated deleted operator changes behaviour of overload resolution", "CreationDate": "2014-01-08T19:50:03.427", "Id": "21005172", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-01-09T01:31:18.733", "Score": "3", "OwnerUserId": "141719", "Tags": "<c++><c++11><enums><namespaces><overload-resolution>", "AnswerCount": "2"}, "21010086": {"Id": "21010086", "PostTypeId": "2", "Body": "<p>The solution to your problem is simple.</p>\n<p>Put your <code>operator|</code> in the same namespace as the type.  Now, ADL (argument dependent lookup) kicks in, and it is found <em>even if</em> there is the unrelated <code>operator|</code> also visible.</p>\n<p><a href=\"http://ideone.com/FepAte\" rel=\"nofollow\">Live example</a>.  Note that <code>N::operator|</code> is found despite the <code>|</code> being used in <code>namespace Z</code>.</p>\n<p>The proper place to overload free operators for a type is the <code>namespace</code> that the type lives in, not the global namespace.</p>\n", "LastActivityDate": "2014-01-09T01:31:18.733", "CommentCount": "0", "CreationDate": "2014-01-09T01:31:18.733", "ParentId": "21005172", "Score": "1", "OwnerUserId": "1774667"}});