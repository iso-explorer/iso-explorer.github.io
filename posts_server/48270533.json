post_cb({"bq_ids": {"n4140": {"so_48270533_48278470_0": {"length": 10, "quality": 1.0, "section_id": 6692}}, "n3337": {"so_48270533_48278470_0": {"length": 10, "quality": 1.0, "section_id": 6447}}, "n4659": {"so_48270533_48278470_0": {"length": 10, "quality": 1.0, "section_id": 8167}}}, "48270533": {"ViewCount": "64", "Body": "<p>When declaring a class <code>A</code> as friend of a class <code>B</code>, while <code>A</code> is defined inside an anonymous namespace and <code>B</code> outside, some compilers produce an error \"<em>protected member inaccessible</em>\" while others do not produce any error or warning. The situation changes if either <code>A</code> or <code>B</code> or both are templates:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace {\n  template &lt;class T&gt;\n  struct A {\n    template &lt;class BB&gt;\n    void foo(BB const&amp; b) { b.bar(); }\n  };\n} // end anonymous namespace\n\ntemplate &lt;class T&gt;\nclass B {\n  template &lt;class&gt; friend struct A;\n\nprotected:\n  void bar() const {}\n};\n\nint main() {\n  A&lt;int&gt; a;\n  a.foo(B&lt;int&gt;{});\n}\n</code></pre>\n<ol>\n<li><code>A</code> and <code>B</code> are both templates. Then Intel icc 18: <strong>error</strong> <code>#308: function \"B&lt;T&gt;::bar [with T=int]\" is inaccessible</code>, gcc 7.2: no error, clang 5.0: no error</li>\n<li><code>A</code> is no template while <code>B</code> is template: Intel icc 18: no error, gcc 7.2: <strong>error</strong>: <code>'void B&lt;T&gt;::bar() const [with T = int]' is protected within this context</code>, clang 5: no error</li>\n<li><code>A</code> is a template while <code>B</code> is not: Intel icc 18: <strong>error</strong> <code>#308</code>, gcc 7.2: <strong>error</strong>, clang 5: no error</li>\n<li>neither <code>A</code> nor <code>B</code> are templates: Intel icc 18: no error, gcc 7.2: <strong>error</strong>, clang 5: no error</li>\n<li>neither <code>A</code> nor <code>B</code> are templates (as in 4.) but location of <code>A</code> and <code>B</code> exchanged: Intel icc 18: <strong>error</strong> <code>#308</code>, gcc 7.2: <strong>error</strong>, clang 5: <strong>error</strong>: <code>'bar' is a protected member of 'B'</code></li>\n<li><code>A</code> and <code>B</code> are both templates (as in 1.) but location of <code>A</code> and <code>B</code> exchanged: Intel icc 18: <strong>error</strong> <code>#308</code>, gcc 7.2: no error, clang 5: <strong>error</strong> </li>\n</ol>\n<p>See the example in the compiler explorer: <a href=\"https://godbolt.org/g/6Zdr3c\" rel=\"nofollow noreferrer\">https://godbolt.org/g/6Zdr3c</a> and <a href=\"https://godbolt.org/g/BRqf78\" rel=\"nofollow noreferrer\">https://godbolt.org/g/BRqf78</a> for the case 6.</p>\n<p>So, what is the correct behavior? Which compiler is correct?</p>\n", "AcceptedAnswerId": "48278470", "Title": "friend of templated class in anonymous namespace", "CreationDate": "2018-01-15T20:55:58.407", "LastActivityDate": "2018-01-16T17:18:01.287", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2018-01-16T17:18:01.287", "LastEditorUserId": "2708773", "Id": "48270533", "Score": "4", "OwnerUserId": "2708773", "Tags": "<c++><templates><namespaces><language-lawyer><friend>", "AnswerCount": "1"}, "48278470": {"Id": "48278470", "PostTypeId": "2", "Body": "<p>As far as I can judge from the standard the given code is correct in cases 1-4 and should compile without diagnostics:</p>\n<p>The definition of unnamed namespaces (7.3.1.1:1) state that an unnamed namespace definition is equivalent to defining a named namespace with a name unique to the translation unit and then importing this namespace with a using directive.</p>\n<p>This will make the declaration of <code>A</code> accessible in the global scope, and according to paragraph 11.3:9</p>\n<blockquote>\n<p id=\"so_48270533_48278470_0\">A name nominated by a friend declaration shall be accessible in the scope of the class containing the friend declaration.</p>\n</blockquote>\n<p>Thus the parameterized class <code>A</code> is a friend of <code>B</code> and should be able to access <code>B::bar</code></p>\n<p>In case 5 there is a difference. As far as I can see, the friend declaration declares a new parameterized class <code>A</code> in the enclosing scope which is different from the class <code>A</code> in the unnamed namespace.</p>\n", "LastEditorUserId": "3668462", "LastActivityDate": "2018-01-16T10:18:00.967", "Score": "1", "CreationDate": "2018-01-16T09:55:02.663", "ParentId": "48270533", "CommentCount": "2", "OwnerUserId": "3668462", "LastEditDate": "2018-01-16T10:18:00.967"}});