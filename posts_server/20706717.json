post_cb({"20706849": {"Id": "20706849", "PostTypeId": "2", "Body": "<p>K&amp;R second edition (ANSI C) in chapter 6.4 (page 138) says: </p>\n<blockquote>\n<p id=\"so_20706717_20706849_0\">Don't assume, however, that the size of a structure is the sum of the sizes of its memebers. Because of alignment requirements for different objects, there may be unnamed \"holes\" in a structure.</p>\n</blockquote>\n<p>So no, ANSI C does not guarantee that <code>b</code> is at offset 1.</p>\n<p>It is even likely that the compiler puts <code>b</code> at offset <code>sizeof(int)</code> so that it's aligned on the size of a machine word, which is easier to deal with.</p>\n<p>Some compilers support <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Structure-Packing-Pragmas.html\" rel=\"nofollow\">pack-pragmas</a> so that you can force that there are no such \"holes\" in the <code>struct</code>, but that is not portable.</p>\n", "LastEditorUserId": "249237", "LastActivityDate": "2013-12-20T15:32:32.330", "Score": "0", "CreationDate": "2013-12-20T15:25:41.160", "ParentId": "20706717", "CommentCount": "0", "OwnerUserId": "249237", "LastEditDate": "2013-12-20T15:32:32.330"}, "20709664": {"Id": "20709664", "PostTypeId": "2", "Body": "<p>What is guaranteed by the C-Standard already had been mentioned by other answers.</p>\n<p>However, to make sure <code>b</code> <strong>is</strong> at offset <code>1</code> your compiler might offer options to \"pack\" the structure, will say to explicitly add <strong>no</strong> padding.</p>\n<p>For gcc this can be achieved by the <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Structure-Packing-Pragmas.html#Structure-Packing-Pragmas\" rel=\"nofollow\"><code>#pragma</code> <code>pack()</code></a>.  </p>\n<pre><code>#pragma pack(1)\nstruct\n{\n  uint8_t a; /* Guaranteed to be at offset 0. */\n  uint8_t b; /* Guaranteed to be at offset 1. */\n  /* other members are guaranteed to start at offset 2. */\n} test_packed;\n#pragma pack()\n\nstruct\n{\n  uint8_t a; /* Guaranteed to by at offset 0. */\n  uint8_t b; /* NOT guaranteed to be at offset 1. */\n  /* other members are NOT guaranteed to start at offset 2. */\n} test_unpacked;\n</code></pre>\n<hr>\n<p>A portable (and save) solution would be to simply use an array:</p>\n<pre><code>struct\n{\n  uint8_t ab[2]; /* ab[0] is guaranteed to be at offset 0. */\n                 /* ab[1] is guaranteed to be at offset 1. */\n  /* other members are NOT guaranteed to start at offset 2. */\n} test_packed;\n</code></pre>\n</hr>", "LastEditorUserId": "694576", "LastActivityDate": "2013-12-20T18:34:13.177", "Score": "0", "CreationDate": "2013-12-20T18:17:46.463", "ParentId": "20706717", "CommentCount": "2", "OwnerUserId": "694576", "LastEditDate": "2013-12-20T18:34:13.177"}, "20706804": {"Id": "20706804", "PostTypeId": "2", "Body": "<p><em>C11 6.7.2.1 Structure and union specifiers</em> p14 says</p>\n<blockquote>\n<p id=\"so_20706717_20706804_0\">Each non-bit-field member of a structure or union object is aligned in\n  an implementation- defined manner appropriate to its type.</p>\n</blockquote>\n<p>meaning that you can't make any portable assumptions about the difference between the addresses of <code>a</code> and <code>b</code>.</p>\n", "LastActivityDate": "2013-12-20T15:23:07.940", "CommentCount": "0", "CreationDate": "2013-12-20T15:23:07.940", "ParentId": "20706717", "Score": "1", "OwnerUserId": "311966"}, "bq_ids": {"n4140": {"so_20706717_20706824_3": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}, "so_20706717_20706824_2": {"length": 41, "quality": 0.9761904761904762, "section_id": 5873}}, "n3337": {"so_20706717_20706824_3": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}, "so_20706717_20706824_1": {"length": 23, "quality": 0.575, "section_id": 5650}, "so_20706717_20706824_2": {"length": 40, "quality": 0.9523809523809523, "section_id": 5644}}, "n4659": {"so_20706717_20706824_3": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}, "so_20706717_20706824_2": {"length": 41, "quality": 0.9761904761904762, "section_id": 7356}}}, "20706824": {"Id": "20706824", "PostTypeId": "2", "Body": "<p>It should be possible to use <a href=\"http://en.cppreference.com/w/cpp/types/offsetof\" rel=\"nofollow\">offsetof</a> to determine the offset of members.</p>\n<p>For C the alignment is implementation defined, we can see that in the draft C99 standard section <code>6.7.2.1</code> <em>Structure and union specifiers</em> paragraph <em>12</em>(In C11 it would be paragraph 14) which says:</p>\n<blockquote>\n<p id=\"so_20706717_20706824_0\">Each non-bit-field member of a structure or union object is aligned in an implementation defined manner appropriate to its type.</p>\n</blockquote>\n<p>and paragraph <em>13</em> says:</p>\n<blockquote>\n<p id=\"so_20706717_20706824_1\">Within a structure object, the non-bit-field members and the units in which bit-fields\n  reside have addresses that increase in the order in which they are declared. A pointer to a\n  structure object, suitably converted, points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides), and vice versa. There may be unnamed\n  padding within a structure object, but not at its beginning.</p>\n</blockquote>\n<p>and for <em>C++</em> we have the following similar quotes from the draft standard section  <code>9.2</code> <em>Class members</em> paragraph <em>13</em> says:</p>\n<blockquote>\n<p id=\"so_20706717_20706824_2\">Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with different access control is unspecified (Clause 11). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other;</p>\n</blockquote>\n<p>and paragraph <em>19</em> says:</p>\n<blockquote>\n<p id=\"so_20706717_20706824_3\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:\n  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,\n  as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-12-20T15:40:27.203", "Score": "1", "CreationDate": "2013-12-20T15:24:05.100", "ParentId": "20706717", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-12-20T15:40:27.203"}, "20706815": {"Id": "20706815", "PostTypeId": "2", "Body": "<p>the case you're using is not really an edge case, both uint_8 are small enough to fit in the same word in memory and it would be no use to put each uint_8 in a uint_16.</p>\n<p>A more critical case would be something like : </p>\n<pre><code>{\n    uint8_t a;\n    uint8_t b;\n\n    uint_32 c; // where is C, at &amp;a+2 or &amp;a+4 ?\n    /* other members */\n} test;\n</code></pre>\n<p>and anyway this will always depend on the target architecture and your compiler...</p>\n", "LastEditorUserId": "311966", "LastActivityDate": "2013-12-20T15:29:22.433", "Score": "0", "CreationDate": "2013-12-20T15:23:33.310", "ParentId": "20706717", "CommentCount": "0", "OwnerUserId": "3114823", "LastEditDate": "2013-12-20T15:29:22.433"}, "20706746": {"Id": "20706746", "PostTypeId": "2", "Body": "<p>The standard (as of C99) doesn't really say anything.</p>\n<p>The only real guarantees are that <code>(void *)&amp;test == (void *)&amp;a</code>, and that <code>a</code> is at a lower address than <code>b</code>.  Everything else is up to the implementation.</p>\n", "LastEditorUserId": "129570", "LastActivityDate": "2013-12-20T15:33:50.287", "Score": "7", "CreationDate": "2013-12-20T15:19:33.423", "ParentId": "20706717", "CommentCount": "3", "OwnerUserId": "129570", "LastEditDate": "2013-12-20T15:33:50.287"}, "20706717": {"ViewCount": "408", "Body": "<p>just a simple question... what the standard says about the structure members alignment?\nfor example with this one:</p>\n<pre><code>struct\n{\n    uint8_t a;\n    uint8_t b;\n    /* other members */\n} test;\n</code></pre>\n<p>It is guarateed that b is at offset 1 from the struct start?\nThanks</p>\n", "Title": "C struct elements alignment (ansi)", "CreationDate": "2013-12-20T15:17:48.550", "LastActivityDate": "2013-12-20T18:34:13.177", "CommentCount": "1", "LastEditDate": "2013-12-20T18:26:28.023", "PostTypeId": "1", "LastEditorUserId": "694576", "Id": "20706717", "Score": "4", "OwnerUserId": "2520001", "Tags": "<c++><c><standards><ansi><memory-alignment>", "AnswerCount": "6"}});