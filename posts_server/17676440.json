post_cb({"bq_ids": {"n4140": {"so_17676440_17676499_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 3296}, "so_17676440_17676499_2": {"length": 14, "quality": 1.0, "section_id": 3296}}, "n3337": {"so_17676440_17676499_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 3166}, "so_17676440_17676499_2": {"length": 14, "quality": 1.0, "section_id": 3166}}, "n4659": {"so_17676440_17676499_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 4058}, "so_17676440_17676499_2": {"length": 14, "quality": 1.0, "section_id": 4058}}}, "17676440": {"ViewCount": "118", "Body": "<p>I have a helper class for freeing MYSQL_RES handles.</p>\n<pre><code>class auto_mysqlres\n{\npublic:\n  auto_mysqlres(MYSQL_RES *res) : m_res(res)\n  {\n  }\n\n  ~auto_mysqlres()\n  {\n    if (m_res != NULL)\n      mysql_free_result(m_res);\n  }\n\n  operator MYSQL_RES* ()\n  {\n    return m_res;\n  }\n\nprivate:\n  auto_mysqlres&amp; operator= (const auto_mysqlres &amp;res);\n  auto_mysqlres (const auto_mysqlres &amp;res);\n\nprivate:\n  MYSQL_RES *m_res;\n};\n</code></pre>\n<p>when I try to use it this way\n<code>auto_mysqlres result = return_pointer_to_mysql_res();</code>\nI get the error in <code>GCC 4.6.3: auto_mysqlres::auto_mysqlres(const auto_mysqlres&amp;) is private</code>. no errors in MSVC 2008, though.</p>\n<p><code>return_pointer_to_mysql_res</code> returns <code>MYSQL_RES*</code>, of course\nI have fixed the problem with this line <code>auto_mysqlres result (return_pointer_to_mysql_res());</code></p>\n<p>but I want to find out why I get that error. I can't understand why GCC creates a temporary object there.</p>\n", "AcceptedAnswerId": "17676631", "Title": "why do I need copy constructor here", "CreationDate": "2013-07-16T12:24:02.917", "Id": "17676440", "CommentCount": "1", "LastEditDate": "2013-07-16T12:32:53.297", "PostTypeId": "1", "LastEditorUserId": "1774667", "LastActivityDate": "2013-07-16T12:48:11.733", "Score": "1", "OwnerUserId": "1417782", "Tags": "<c++><gcc><gcc4>", "AnswerCount": "2"}, "17676499": {"Id": "17676499", "PostTypeId": "2", "Body": "<p>Well.. @myself: Learning never stops. :)</p>\n<p>Your constructor is not explicit and therefore a way to implicitly convert a <code>MYSQL_RES*</code> into as <code>auto_mysqlres</code>. This is what gcc does here. It converts the <code>MYSQL_RES*</code> into a <code>auto_mysqlres</code> and then tries to call the copy constructor. This is required here.</p>\n<h3>\u00a7 8.5 [dcl.init] / 14</h3>\n<blockquote>\n<p id=\"so_17676440_17676499_0\">The initialization that occurs in the form</p>\n<ul>\n<li>T x = a;</li>\n</ul>\n<p id=\"so_17676440_17676499_1\">[...] is called copy-initialization.</p>\n</blockquote>\n<p>You copy-inititalize your object.</p>\n<h3>\u00a7 8.5 [dcl.init] / 16</h3>\n<blockquote>\n<p id=\"so_17676440_17676499_2\">[... If the initialization] is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. [...]</p>\n<p id=\"so_17676440_17676499_3\">Otherwise (i.e., <strong>for the remaining copy-initialization cases</strong>), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution.</p>\n</blockquote>\n<p>In your case <code>MYSQL_RES*</code> is not the same class as, or a derived class of the destination class (<code>auto_mysqlres</code>) so a conversion is required since the constructor isn't considered.</p>\n<p>You'll either </p>\n<ul>\n<li><p>have to do direct initialization</p>\n<p><code>auto_mysqlres result(return_pointer_to_mysql_res());</code></p></li>\n<li><p>or provide a (move) copy constructor.</p></li>\n</ul>\n<p><sub>PS: Wasn't quite aware of <code>where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination</code>.</sub></p>\n", "LastEditorUserId": "951423", "LastActivityDate": "2013-07-16T12:48:11.733", "Score": "0", "CreationDate": "2013-07-16T12:26:45.077", "ParentId": "17676440", "CommentCount": "3", "OwnerUserId": "951423", "LastEditDate": "2013-07-16T12:48:11.733"}, "17676631": {"Id": "17676631", "PostTypeId": "2", "Body": "<p>You are performing <em>copy initialization</em> here:</p>\n<pre><code>auto_mysqlres result = return_pointer_to_mysql_res();\n</code></pre>\n<p>This requires that a copy constructor be available, even if copies are elided. Semantically, you are constructing a temporary <code>auto_mysqlres</code> from a pointer on the RHS, and copy constructing from it on the LHS.</p>\n<p>You can use <em>direct initialization</em> instead:</p>\n<pre><code>auto_mysqlres result(return_pointer_to_mysql_res());\n</code></pre>\n<p>see more on <a href=\"http://www.gotw.ca/gotw/036.htm\" rel=\"nofollow\">copy initialization and direct initializazion here</a>.</p>\n<p>As @Rapptz points out in a comment, in C++11, you could decide to make your class move copyable (and possibly move assignable), in which case the move copy constructor would be picked up in the copy initialization.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2013-07-16T12:39:52.837", "Score": "4", "CreationDate": "2013-07-16T12:33:10.617", "ParentId": "17676440", "CommentCount": "1", "OwnerUserId": "661519", "LastEditDate": "2013-07-16T12:39:52.837"}});