post_cb({"bq_ids": {"n4140": {"so_34323791_34323857_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5505}}, "n3337": {"so_34323791_34323857_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5291}}, "n4659": {"so_34323791_34323857_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6939}}}, "34323857": {"Id": "34323857", "PostTypeId": "2", "Body": "<p>This is indeed ambiguity according to the standard, but you can use <code>using</code> or specify the base class explicitly:</p>\n<pre><code>class join_1_2 : public virtual base_1, public virtual base_2\n{\npublic:\n    using base_1::foo;\n    using base_2::foo;\n};\n\nvoid sink(join_1_2 &amp;param)\n{\n    param.base_2::foo(42, 3.14);\n}\n</code></pre>\n<p><strong>7.3.3 The using declaration</strong></p>\n<blockquote>\n<p id=\"so_34323791_34323857_0\">For the purpose of overload resolution, the functions which are introduced by a using-declaration into a\n  derived class will be treated as though they were members of the derived class.</p>\n</blockquote>\n", "LastEditorUserId": "3246555", "LastActivityDate": "2015-12-16T23:27:59.397", "Score": "4", "CreationDate": "2015-12-16T23:06:53.090", "ParentId": "34323791", "CommentCount": "0", "LastEditDate": "2015-12-16T23:27:59.397", "OwnerUserId": "3246555"}, "34323993": {"Id": "34323993", "PostTypeId": "2", "Body": "<p>The rule of thumb is that functions in different scopes don't overload - here our <code>foo</code>s are in different scopes. If you want them to overload, you'll want to bring them in with a <em>using-declaration</em>:</p>\n<pre><code>class join_1_2 : public virtual base_1, public virtual base_2\n{\npublic:\n    using base_1::foo;\n    using base_2::foo;\n};\n</code></pre>\n", "LastActivityDate": "2015-12-16T23:18:09.477", "CommentCount": "1", "CreationDate": "2015-12-16T23:18:09.477", "ParentId": "34323791", "Score": "4", "OwnerUserId": "2069064"}, "34323791": {"ViewCount": "100", "Body": "<p>Visual Studio 2013.</p>\n<p>Given:</p>\n<pre><code>class base_1\n{\npublic:\n    virtual void foo(int) = 0;\n};\n\nclass base_2\n{\npublic:\n    virtual void foo(int, double) = 0;\n};\n\nclass join_1_2 : public virtual base_1, public virtual base_2\n{};\n</code></pre>\n<p>I have a sink:</p>\n<pre><code>void sink(join_1_2 &amp;param)\n{\n    param.foo(42, 3.14);\n}\n</code></pre>\n<p>But I get the following compiler errors:</p>\n<blockquote>\n<p id=\"so_34323791_34323791_0\">error C2385: ambiguous access of 'foo'</p>\n<p id=\"so_34323791_34323791_1\">could be the 'foo' in base 'base_1'</p>\n<p id=\"so_34323791_34323791_2\">or could be the 'foo' in base 'base_2'</p>\n<p id=\"so_34323791_34323791_3\">error C2660: 'base_1::foo' : function does not take 2 arguments</p>\n<p id=\"so_34323791_34323791_4\">error C3861: 'foo': identifier not found</p>\n</blockquote>\n<p>I know I can resolve this issue with:</p>\n<pre><code>param.base_2::foo(42, 3.14);\n</code></pre>\n<p>But as you can imagine, virtual inheritance is already one sin too many I have to live with. I'm probably going to write an adapter. But I don't understand what is preventing the compiler from trying to resolve foo in base_2. My colleague believes it to be a compiler error, but I'm not so quick to blame the vendor.</p>\n<p>What does the C++ spec say about resolving overloaded virtual methods across base classes?</p>\n", "AcceptedAnswerId": "34323857", "Title": "Resolving virtual method overloads across base classes", "CreationDate": "2015-12-16T23:01:42.347", "Id": "34323791", "CommentCount": "0", "LastEditDate": "2015-12-19T19:59:07.537", "PostTypeId": "1", "LastEditorUserId": "963864", "LastActivityDate": "2015-12-19T19:59:07.537", "Score": "4", "OwnerUserId": "855367", "Tags": "<c++><multiple-inheritance><name-lookup><ambiguous-call>", "AnswerCount": "2"}});