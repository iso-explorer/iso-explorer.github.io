post_cb({"34323857": {"ParentId": "34323791", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-12-16T23:06:53.090", "Score": "4", "LastEditorUserId": "3246555", "LastEditDate": "2015-12-16T23:27:59.397", "Id": "34323857", "OwnerUserId": "3246555", "Body": "<p>This is indeed ambiguity according to the standard, but you can use <code>using</code> or specify the base class explicitly:</p>\n<pre><code>class join_1_2 : public virtual base_1, public virtual base_2\n{\npublic:\n    using base_1::foo;\n    using base_2::foo;\n};\n\nvoid sink(join_1_2 &amp;param)\n{\n    param.base_2::foo(42, 3.14);\n}\n</code></pre>\n<p><strong>7.3.3 The using declaration</strong></p>\n<blockquote>\n<p id=\"so_34323791_34323857_0\">For the purpose of overload resolution, the functions which are introduced by a using-declaration into a\n  derived class will be treated as though they were members of the derived class.</p>\n</blockquote>\n", "LastActivityDate": "2015-12-16T23:27:59.397"}, "34323993": {"ParentId": "34323791", "CommentCount": "1", "Body": "<p>The rule of thumb is that functions in different scopes don't overload - here our <code>foo</code>s are in different scopes. If you want them to overload, you'll want to bring them in with a <em>using-declaration</em>:</p>\n<pre><code>class join_1_2 : public virtual base_1, public virtual base_2\n{\npublic:\n    using base_1::foo;\n    using base_2::foo;\n};\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "34323993", "Score": "4", "CreationDate": "2015-12-16T23:18:09.477", "LastActivityDate": "2015-12-16T23:18:09.477"}, "34323791": {"CommentCount": "0", "ViewCount": "100", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2015-12-16T23:01:42.347", "LastActivityDate": "2015-12-19T19:59:07.537", "Title": "Resolving virtual method overloads across base classes", "AcceptedAnswerId": "34323857", "LastEditDate": "2015-12-19T19:59:07.537", "Id": "34323791", "Score": "4", "Body": "<p>Visual Studio 2013.</p>\n<p>Given:</p>\n<pre><code>class base_1\n{\npublic:\n    virtual void foo(int) = 0;\n};\n\nclass base_2\n{\npublic:\n    virtual void foo(int, double) = 0;\n};\n\nclass join_1_2 : public virtual base_1, public virtual base_2\n{};\n</code></pre>\n<p>I have a sink:</p>\n<pre><code>void sink(join_1_2 &amp;param)\n{\n    param.foo(42, 3.14);\n}\n</code></pre>\n<p>But I get the following compiler errors:</p>\n<blockquote>\n<p id=\"so_34323791_34323791_0\">error C2385: ambiguous access of 'foo'</p>\n<p id=\"so_34323791_34323791_1\">could be the 'foo' in base 'base_1'</p>\n<p id=\"so_34323791_34323791_2\">or could be the 'foo' in base 'base_2'</p>\n<p id=\"so_34323791_34323791_3\">error C2660: 'base_1::foo' : function does not take 2 arguments</p>\n<p id=\"so_34323791_34323791_4\">error C3861: 'foo': identifier not found</p>\n</blockquote>\n<p>I know I can resolve this issue with:</p>\n<pre><code>param.base_2::foo(42, 3.14);\n</code></pre>\n<p>But as you can imagine, virtual inheritance is already one sin too many I have to live with. I'm probably going to write an adapter. But I don't understand what is preventing the compiler from trying to resolve foo in base_2. My colleague believes it to be a compiler error, but I'm not so quick to blame the vendor.</p>\n<p>What does the C++ spec say about resolving overloaded virtual methods across base classes?</p>\n", "Tags": "<c++><multiple-inheritance><name-lookup><ambiguous-call>", "OwnerUserId": "855367", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34323791_34323857_0": {"section_id": 5505, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_34323791_34323857_0": {"section_id": 5291, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_34323791_34323857_0": {"section_id": 6939, "quality": 0.8888888888888888, "length": 16}}}});