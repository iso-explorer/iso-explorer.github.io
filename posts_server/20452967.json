post_cb({"bq_ids": {"n4140": {"so_20452967_20453967_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 3308}, "so_20452967_20453967_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 3308}, "so_20452967_20453967_3": {"length": 7, "quality": 1.0, "section_id": 6098}, "so_20452967_20453967_0": {"length": 48, "quality": 0.9795918367346939, "section_id": 3308}}, "n3337": {"so_20452967_20453967_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 3178}, "so_20452967_20453967_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 3178}, "so_20452967_20453967_3": {"length": 7, "quality": 1.0, "section_id": 5864}, "so_20452967_20453967_0": {"length": 47, "quality": 0.9591836734693877, "section_id": 3178}}, "n4659": {"so_20452967_20453967_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 4074}, "so_20452967_20453967_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 4074}, "so_20452967_20453967_3": {"length": 7, "quality": 1.0, "section_id": 7595}, "so_20452967_20453967_0": {"length": 43, "quality": 0.8775510204081632, "section_id": 4074}}}, "20453967": {"Id": "20453967", "PostTypeId": "2", "Body": "<p><strong>Update:</strong> Thanks to Faisal Vali and Richard Smith, this bug has been corrected in Clang ToT; see the <a href=\"http://llvm.org/viewvc/llvm-project/cfe/trunk/test/CodeGenCXX/cxx11-initializer-array-new.cpp?revision=196995&amp;view=markup&amp;pathrev=196995\">test file</a> introduced by the commit.</p>\n<hr>\n<p>According to <strong>\u00a78.5.1 [dcl.init.aggr]</strong> it appears that Clang is wrong:</p>\n<blockquote>\n<p id=\"so_20452967_20453967_0\">11/ Braces can be elided in an <em>initializer-list</em> as follows. If the <em>initializer-list</em> begins with a left brace, then the succeeding comma-separated list of <em>initializer-clauses</em> initializes the members of a subaggregate; it is erroneous for there to be more <em>initializer-clauses</em> than members. If, however, the <em>initializer-list</em> for a subaggregate does not begin with a left brace, then only enough <em>initializer-clauses</em> from the list are taken to initialize the members of the subaggregate; any remaining <em>initializer-clauses</em> are left to initialize the next member of the aggregate of which the current subaggregate is a member. [ <em>Example:</em></p>\n<pre><code>float y[4][3] = {\n    { 1, 3, 5 },\n    { 2, 4, 6 },\n    { 3, 5, 7 },\n};\n</code></pre>\n<p id=\"so_20452967_20453967_1\">is a completely-braced initialization: 1, 3, and 5 initialize the first row of the array <code>y[0]</code>, namely <code>y[0][0]</code>, <code>y[0][1]</code>, and <code>y[0][2]</code>. Likewise the next two lines initialize <code>y[1]</code> and <code>y[2]</code>. The initializer ends early and therefore <code>y[3]</code>s elements are initialized as if explicitly initialized with an expression of the form <code>float()</code>, that is, are initialized with <code>0.0</code>. In the following example, braces in the <em>initializer-list</em> are elided; however the <em>initializer-list</em> has the same effect as the completely-braced <em>initializer-list</em> of the above example,</p>\n<pre><code>float y[4][3] = {\n    1, 3, 5, 2, 4, 6, 3, 5, 7\n};\n</code></pre>\n<p id=\"so_20452967_20453967_2\">The initializer for y begins with a left brace, but the one for <code>y[0]</code> does not, therefore three elements from the list are used. Likewise the next three are taken successively for <code>y[1]</code> and <code>y[2]</code>. \u2014<em>end example</em> ]</p>\n</blockquote>\n<p>Which I think applies because of <strong>\u00a75.3.4 [expr.new]</strong>:</p>\n<blockquote>\n<p id=\"so_20452967_20453967_3\">15/ A <em>new-expression</em> that creates an object of type T initializes that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is default-initialized (<strong>\u00a78.5</strong>); if no initialization is performed, the object has indeterminate value.</li>\n<li>Otherwise, the <em>new-initializer</em> is interpreted according to the initialization rules of <strong>\u00a78.5</strong> for direct initialization.</li>\n</ul>\n</blockquote>\n</hr>", "LastEditorUserId": "147192", "LastActivityDate": "2013-12-11T17:24:35.953", "Score": "20", "CreationDate": "2013-12-08T13:30:53.937", "ParentId": "20452967", "CommentCount": "5", "OwnerUserId": "147192", "LastEditDate": "2013-12-11T17:24:35.953"}, "20452967": {"ViewCount": "2505", "Body": "<p>I'm trying to understand whether the different behavior exposed by gcc vs. clang in the output of this simple C++11 program is due to a bug in clang (Xcode 5.0.2, OS X 10.8.5). The code is as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n\n\n    int matrix[][3]{{1,2,3}, {4,5,6}, {7,8,9}};\n    auto dyn_matrix = new int[3][3]{{1,2,3}, {4,5,6}, {7,8,9}};\n\n    std::cout &lt;&lt; matrix[0][1] &lt;&lt; std::endl;\n    std::cout &lt;&lt; dyn_matrix[0][1] &lt;&lt; std::endl;\n\n    return 0;   \n}\n</code></pre>\n<p>As shown, I'm trying to use uniform initialization to initialize an anonymous (resp. named) multidimensional array of size <code>3x3</code>. When compiling with gcc 4.7 from MacPorts the expected output is obtained:</p>\n<pre><code>$g++-mp-4.7 -std=c++11 dyn_matrix.cpp -o dyn_matrix \n$ ./dyn_matrix\n2\n2\n$\n</code></pre>\n<p>Conversely, in case clang is used the output reads:</p>\n<pre><code>$ clang++ -std=c++11 -stdlib=libc++ dyn_matrix.cpp -o dyn_matrix_clang\n$ ./dyn_matrix_clang \n2\n4\n$  \n</code></pre>\n<p>In this case the result is (apparently) wrong. <code>clang --version</code> reports:</p>\n<pre><code>Apple LLVM version 5.0 (clang-500.2.75) (based on LLVM 3.3svn)\nTarget: x86_64-apple-darwin12.5.0\nThread model: posix\n</code></pre>\n<p>Who's to blame? me, gcc or clang?</p>\n<p><strong>UPDATE Dec 11th, 2013:</strong> The bug should have been fixed in r196995. Unfortunately, we still do not know how long it will take before Apple updates the version of clang that ships with Xcode. </p>\n<p><strong>UPDATE Dec 9th, 2013:</strong> I submitted a bug report on the LLVM bugzilla platform. It has indeed been recognized as a bug, a patch is currently under review, see <a href=\"http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20131209/095099.html\" rel=\"noreferrer\">http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20131209/095099.html</a>. </p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "20453967", "Title": "Different results between gcc and clang when compiling a rather simple c++11 program", "CreationDate": "2013-12-08T11:37:16.180", "Id": "20452967", "CommentCount": "8", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2013-12-12T09:39:55.200", "LastEditorUserId": "1849221", "LastActivityDate": "2013-12-12T09:39:55.200", "Score": "56", "OwnerUserId": "1849221", "Tags": "<c++><gcc><c++11><clang>", "AnswerCount": "1"}});