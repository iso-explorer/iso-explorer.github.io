post_cb({"32602805": {"ViewCount": "926", "Body": "<p>Reading <a href=\"https://stackoverflow.com/a/18399065/455304\">this answer</a>, I was surprised enough to try out for myself if it really works as described:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\npublic:\n    virtual void foo() = 0;\n};\n\nclass B {\npublic:\n    virtual void foo() = 0;\n};\n\nclass C : public A, public B {\npublic:\n    virtual void foo();\n};\n\nvoid C::foo(){\n  std::cout &lt;&lt; \"C\" &lt;&lt; std::endl;\n}\nvoid C::A::foo(){\n  std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\nvoid C::B::foo(){\n  std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n}\n\nint main() {\n    C c;\n    static_cast&lt;A*&gt;(&amp;c)-&gt;foo();\n    static_cast&lt;B*&gt;(&amp;c)-&gt;foo();\n    c.foo();\n    return 0;\n}\n</code></pre>\n<p>I really did not think that it was possible to override a virtual method from two different base classes, that have the same name and signature. And, as I expected, above program prints:</p>\n<pre><code>C\nC\nC\n</code></pre>\n<p>So the answer is wrong - as I felt from the start. Surprising part is: why does my gcc accept this syntax: <code>void C::A::foo(){</code>? I could not find anything on what that could mean. Is this a gcc bug/feature? Is it some obscure standard C++ syntax? Or am I misinterpreting the situation completely?</p>\n<p>EDIT:</p>\n<p>It seems that <code>void C::A::foo(){}</code> is just a definition for <code>A::foo</code> in this context. But why? Is this GCC bug? Or is this somehow permitted by the standard? If so, is it specific rule for this kind of thing, or some kind of generic clause (say: if an identifier doesn't make sense - like 'C::A::foo', then compiler is free to do what it wants). </p>\n", "AcceptedAnswerId": "32603265", "Title": "Weird syntax when overriding virtual functions", "CreationDate": "2015-09-16T07:56:52.483", "Id": "32602805", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:31:34.140", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-16T08:40:34.283", "Score": "16", "OwnerUserId": "455304", "Tags": "<c++><syntax><override><language-lawyer>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32602805_32603265_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 5846}}, "n3337": {"so_32602805_32603265_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 5616}}, "n4659": {"so_32602805_32603265_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 7325}}}, "32603265": {"Id": "32603265", "PostTypeId": "2", "Body": "<p>I think the fact that <code>C::A::foo</code> defines <code>A::foo</code> is due to the <em>injected-class-name</em>.</p>\n<blockquote>\n<p id=\"so_32602805_32603265_0\"><code>N3337 [class]/2:</code> A class-name is inserted into the scope in which it is declared immediately after the class-name is seen.\n  The class-name is also inserted into the scope of the class itself; this is known as the injected-class-name.\n  For purposes of access checking, the injected-class-name is treated as if it were a public member name. [...]</p>\n</blockquote>\n<p>Since <code>A</code> is a base class of <code>C</code> and the name <code>A</code> is injected into the scope of <code>A</code>, <code>A</code> is also visible from <code>C</code>.</p>\n<p>Given the above, we can do horribly perverse things like:</p>\n<pre><code>void C::C::C::A::A::A::foo(){\n    std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3581c111288b4a66\" rel=\"noreferrer\"><kbd>Live Demo</kbd></a></p>\n", "LastActivityDate": "2015-09-16T08:22:50.787", "CommentCount": "1", "CreationDate": "2015-09-16T08:22:50.787", "ParentId": "32602805", "Score": "17", "OwnerUserId": "496161"}, "32602942": {"Id": "32602942", "PostTypeId": "2", "Body": "<p>Interestingly enough, </p>\n<pre><code>void C::A::foo(){\n  std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>defines <code>A::foo()</code> (you can provide an implementation for a pure virtual function if you want to). You can check that this is really the case by adding an additional definition:</p>\n<pre><code>void A::foo(){\n  std::cout &lt;&lt; \"Base A\" &lt;&lt; std::endl;\n}\nvoid C::A::foo(){\n  std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>GCC will report a multiple definition error. This probably makes sense, because you can look at <code>C::A</code> as a name alias for <code>A</code>. </p>\n<p>In terms of what the standard says, I'm currently struggling to find the exact definition of when this is appropriate in the sea of standardese, but I can see a related example in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">Paragraph 3.4.3.1.2</a>:</p>\n<pre><code>struct A { A(); };\nstruct B: public A { B(); };\nA::A() { }\nB::B() { }\nB::A ba; // object of type A // &lt;-- here\nA::A a; // error, A::A is not a type name\nstruct A::A a2; // object of type A\n</code></pre>\n<p>The example is to do with constructor resolution, but constructor is ultimately a method, so my guess is that GCC used the same mechanism for every scope resolution. </p>\n", "LastEditorUserId": "4765374", "LastActivityDate": "2015-09-16T08:40:34.283", "Score": "7", "CreationDate": "2015-09-16T08:03:00.777", "ParentId": "32602805", "CommentCount": "3", "OwnerUserId": "4765374", "LastEditDate": "2015-09-16T08:40:34.283"}, "32603505": {"Id": "32603505", "PostTypeId": "2", "Body": "<p>The Visual Studio compiler (2008) does not allow</p>\n<pre><code>void C::A::foo(){\n  std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\nvoid C::B::foo(){\n  std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n</code></pre>\n<p>but only </p>\n<pre><code>void A::foo(){\n  std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\nvoid B::foo(){\n  std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n</code></pre>\n<p>as it is completely valid to provide a definition for pure virtual methods. </p>\n<blockquote>\n<p id=\"so_32602805_32603505_0\">\"Effective C++\" Meyers mentions a reason for a pure virtual function\n  to have a body: Derived classes that implement this pure virtual\n  function may call this implementation smwhere in their code. If part\n  of the code of two different derived classes is similar then it makes\n  sense to move it up in the hierarchy, even if the function should be\n  pure virtual.</p>\n</blockquote>\n<p>See <a href=\"http://forums.codeguru.com/showthread.php?356281-C-why-pure-virtual-function-has-definition-Please-look-into-sample-code-here\" rel=\"nofollow\">here (forum.codeguru.com)</a>.</p>\n<p>A pure virtual function cannot be called dynamically, but statically:</p>\n<pre><code>C c;\nstatic_cast&lt;A*&gt;(&amp;c)-&gt;foo(); // prints C\nstatic_cast&lt;B*&gt;(&amp;c)-&gt;foo(); // prints C, dynamic dispatch\nc.foo();                    // prints C, dynamic dispatch\nc.A::foo();                 // prints A, static dispatch\nc.B::foo();                 // prints B, static dispatch\n</code></pre>\n<p>Explanation:</p>\n<blockquote>\n<p id=\"so_32602805_32603505_1\">When you call a virtual function using its fully-qualified name (the\n  class-name followed by \u201c::\u201d), the compiler does not use the virtual\n  call mechanism, but instead uses the same mechanism as if you called a\n  non-virtual function. Said another way, it calls the function by name\n  rather than by slot-number. So if you want code within derived class\n  Der to call Base::f(), that is, the version of f() defined in its base\n  class Base, you should write:</p>\n</blockquote>\n<pre><code>void Derived::f()\n{ Base::f(); }\n</code></pre>\n<p>See <a href=\"https://isocpp.org/wiki/faq/virtual-functions#fully-qualified-calls-to-base\" rel=\"nofollow\">here (isocpp.org)</a>.</p>\n", "LastActivityDate": "2015-09-16T08:35:15.660", "CommentCount": "2", "CreationDate": "2015-09-16T08:35:15.660", "ParentId": "32602805", "Score": "2", "OwnerUserId": "1066891"}});