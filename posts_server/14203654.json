post_cb({"14218945": {"Id": "14218945", "PostTypeId": "2", "Body": "<p>I suggest that is_exact is true iff all literals of that type have their exact value. So is_exact is false for the floating types because the value of literal 0.1 is not exactly 0.1.</p>\n<p>Per Christian Rau's comment, we can instead define is_exact to be true when the results of the four arithmetic operations between any two values of the type are either out of range or can be represented exactly, using the definitions of the operations for that type (i.e., truncating integer division, unsigned wraparound). With this definition you can cavil that floating-point operations are <em>defined</em> to produce the nearest representable value. Don't :-)</p>\n", "LastEditorUserId": "197411", "LastActivityDate": "2013-01-08T20:59:35.107", "Score": "5", "CreationDate": "2013-01-08T15:55:44.073", "ParentId": "14203654", "CommentCount": "3", "OwnerUserId": "197411", "LastEditDate": "2013-01-08T20:59:35.107"}, "14203676": {"Id": "14203676", "PostTypeId": "2", "Body": "<p>The definition given in the C++ standard seems fairly unambiguous:</p>\n<blockquote>\n<p id=\"so_14203654_14203676_0\"><code>static constexpr bool is_exact;</code></p>\n<p id=\"so_14203654_14203676_1\">True if the type uses an exact representation. All integer types are exact, but not all exact types are\n  integer. For example, rational and \ufb01xed-exponent representations are exact but not integer.</p>\n<p id=\"so_14203654_14203676_2\">Meaningful for all specializations.</p>\n</blockquote>\n", "LastActivityDate": "2013-01-07T20:40:28.927", "CommentCount": "22", "CreationDate": "2013-01-07T20:40:28.927", "ParentId": "14203654", "Score": "3", "OwnerUserId": "367273"}, "14203654": {"ViewCount": "1103", "Body": "<p>As I interpret it, <a href=\"http://msdn.microsoft.com/en-us/library/97ss307d%28v=vs.110%29.aspx\" rel=\"nofollow noreferrer\">MSDN's definition</a> of <code>numeric_limits::is_exact</code>is almost always false:</p>\n<blockquote>\n<p id=\"so_14203654_14203654_0\">[all] calculations done on [this] type are free of rounding errors.</p>\n</blockquote>\n<p>And <a href=\"http://publib.boulder.ibm.com/infocenter/zos/v1r11/index.jsp?topic=/com.ibm.zos.r11.cbcsl01/header_limits_classes.htm\" rel=\"nofollow noreferrer\">IBM's definition</a> is almost always true: (Or a circular definition, depending on how you read it)</p>\n<blockquote>\n<p id=\"so_14203654_14203654_1\">a type that has exact representations for all its values</p>\n</blockquote>\n<p>What I'm certain of is that I could store a <code>2</code> in both a <code>double</code> and a <code>long</code> and they would both be represented <em>exactly</em>.  </p>\n<p>I could then divide them both by <code>10</code> and neither would hold the mathematical result <em>exactly</em>.</p>\n<p><strong>Given any numeric data type <code>T</code>, what is the correct way to define <code>std::numeric_limits&lt;T&gt;::is_exact</code>?</strong></p>\n<p><em>Edit:\nI've posted <a href=\"https://stackoverflow.com/a/14297563/16287\">what I think is an accurate answer</a> to this question from details supplied in many answers.  <a href=\"https://meta.stackexchange.com/questions/54998/i-just-awarded-myself-a-bounty\">This answer is not a contender for the bounty</a>.</em></p>\n", "AcceptedAnswerId": "14205392", "Title": "std::numeric_limits::is_exact ... what is a usable definition?", "CreationDate": "2013-01-07T20:38:08.410", "Id": "14203654", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:54:02.577", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-17T14:34:26.780", "Score": "9", "OwnerUserId": "16287", "Tags": "<c++><numeric-limits>", "AnswerCount": "6"}, "14270790": {"Id": "14270790", "PostTypeId": "2", "Body": "<p>In C++ the int type is used to represent a mathematical integer type (i.e. one of the set of {..., -1, 0, 1, ...}). Due to the practical limitation of implementation, the language defines the <a href=\"http://www.cplusplus.com/doc/tutorial/variables/\" rel=\"nofollow\">minimum range of values</a> that should be held by that type, and all valid values in that range must be represented without ambiguity on all known architectures.</p>\n<p>The standard also defines types that are used to hold floating point numbers, each with their own range of valid values. What you won't find is the list of valid floating point numbers. Again, due to practical limitations the standard allows for approximations of these types. Many people try to say that only numbers that can be represented by the IEEE floating point standard are exact values for those types, but that's not part of the standard. Though it is true that the implementation of the language on binary computers has a standard for how double and float are represented, there is nothing in the language that says it has to be implemented on a binary computer. In other words float isn't defined by the IEEE standard, the IEEE standard is just an acceptable implementation. As such, if there were an implementation that could hold any value in the range of values that define double and float without rounding rules or estimation, you could say that is_exact is true for that platform. </p>\n<p>Strictly speaking, T can't be your only argument to tell whether a type \"is_exact\", but we can infer some of the other arguments. Because you're probably using a binary computer with standard hardware and any publicly available C++ compiler, when you assign a double the value of .1 (which is in the acceptable range for the floating point types), that's not the number the computer will use in calculations with that variable. It uses the closest approximation as defined by the IEEE standard. Granted, if you compare a literal with itself your compiler should return true, because the IEEE standard is pretty explicit. We know that computers don't have infinite precision and therefore calculations that we expect to have a value of .1 won't necessarily end up with the same approximate representation that the literal value has. Enter the dreaded epsilon comparison.</p>\n<p>To practically answer your question, I would say that for any type which requires an epsilon comparison to test for approximate equality, is_exact should return false. If strict comparison is sufficient for that type, it should return true.</p>\n", "LastActivityDate": "2013-01-11T02:36:38.073", "CommentCount": "5", "CreationDate": "2013-01-11T02:36:38.073", "ParentId": "14203654", "Score": "2", "OwnerUserId": "1968586"}, "14205392": {"Id": "14205392", "PostTypeId": "2", "Body": "<p>The definition in the standard (see NPE's answer) isn't very exact, is it? Instead, it's circular and vague.</p>\n<p>Given that the IEC floating point standard has a concept of \"inexact\" numbers (and an inexact exception when a computation yields an inexact number), I suspect that this is the origin of the name <code>is_exact</code>. Note that of the standard types, <code>is_exact</code> is false only for <code>float</code>, <code>double</code>, and <code>long double</code>.</p>\n<p>The intent is to indicate whether the type <em>exactly</em> represents all of the numbers of the underlying mathematical type. For integral types, the underlying mathematical type is some finite subset of the integers. Since each integral types exactly represents each and every one of the members of the subset of the integers targeted by that type, <code>is_exact</code> is true for all of the integral types. For floating point types, the underlying mathematical type is some finite range subset of the real numbers. (An example of a finite range subset is \"all real numbers between 0 and 1\".) There's no way to represent even a finite range subset of the reals exactly; almost all are uncomputable. The IEC/IEEE format makes matters even worse. With that format, computers can't even represent a finite range subset of the rational numbers exactly (let alone a finite range subset of the computable numbers).</p>\n<p>I suspect that the origin of the term <code>is_exact</code> is the long-standing concept of \"inexact\" numbers in various floating point representation models. Perhaps a better name would have been <code>is_complete</code>.</p>\n<p><strong>Addendum</strong>\n<br>\nThe numeric types defined by the language aren't the be-all and end-all of representations of \"numbers\". A fixed point representation is essentially the integers, so they too would be exact (no holes in the representation). Representing the rationals as a pair of standard integral types (e.g., <code>int/int</code>) would not be exact, but a class that represented the rationals as a <code>Bignum</code> pair would, at least theoretically, be \"exact\".</br></p>\n<p>What about the reals? There's no way to represent the reals exactly because almost all of the reals are not computable. The best we could possibly do with computers is the computable numbers. That would require representing a number as some algorithm. While this might be useful theoretically, from a practical standpoint, it's not that useful at all.</p>\n<p><strong>Second Addendum</strong>\n<br>\nThe place to start is with the standard. Both C++03 and C++11 define <code>is_exact</code> as being</br></p>\n<blockquote>\n<p id=\"so_14203654_14205392_0\">True if the type uses an exact representation.</p>\n</blockquote>\n<p>That is both vague and circular. It's meaningless. Not quite so meaningless is that integer types (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, etc.) are \"exact\" by fiat:</p>\n<blockquote>\n<p id=\"so_14203654_14205392_1\">All integer types are exact, ...</p>\n</blockquote>\n<p>What about other arithmetic types? The first thing to note is that the only other arithmetic types are the floating point types <code>float</code>, <code>double</code>, and <code>long double</code> (3.9.1/8):</p>\n<blockquote>\n<p id=\"so_14203654_14205392_2\">There are three floating point types: <code>float</code>, <code>double</code>, and <code>long double</code>. ... The value representation of floating-point types is implementation-defined. Integral and floating types are collectively called arithmetic types.</p>\n</blockquote>\n<p>The meaning of the floating point types in C++ is markedly murky. Compare with Fortran:</p>\n<blockquote>\n<p id=\"so_14203654_14205392_3\">A real datum is a processor approximation to the value of a real number.</p>\n</blockquote>\n<p>Compare with ISO/IEC 10967-1, Language independent arithmetic (which the C++ standards reference in footnotes, but never as a normative reference):</p>\n<blockquote>\n<p id=\"so_14203654_14205392_4\">A floating point type <em>F</em> shall be a finite subset of \u211d.</p>\n</blockquote>\n<p>C++ on the other hand is moot with regard to what the floating point types are supposed to represent. As far as I can tell, an implementation could get away with making <code>float</code> a synonym for <code>int</code>, <code>double</code> a synonym for <code>long</code>, and <code>long double</code> a synonym for <code>long long</code>. </p>\n<p>Once more from the standards on <code>is_exact</code>:</p>\n<blockquote>\n<p id=\"so_14203654_14205392_5\">... but not all exact types are integer. For example, rational and fixed-exponent representations are exact but not integer.</p>\n</blockquote>\n<p>This obviously doesn't apply to user-developed extensions for the simple reason that users are not allowed to define <code>std::whatever&lt;MyType&gt;</code>. Do that and you're invoking undefined behavior. This final clause can only pertain to implementations that</p>\n<ul>\n<li>Define <code>float</code>, <code>double</code>, and <code>long double</code> in some peculiar way, or</li>\n<li>Provide some non-standard rational or fixed point type as an arithmetic type and decide to provide a <code>std::numeric_limits&lt;non_standard_type&gt;</code> for these non-standard extensions.</li>\n</ul>\n", "LastEditorUserId": "774499", "LastActivityDate": "2013-01-17T14:34:26.780", "Score": "6", "CreationDate": "2013-01-07T22:41:38.790", "ParentId": "14203654", "CommentCount": "4", "OwnerUserId": "774499", "LastEditDate": "2013-01-17T14:34:26.780"}, "14269266": {"Id": "14269266", "PostTypeId": "2", "Body": "<p>The problem of exactnes is not restricted to C, so lets look further.</p>\n<p>Germane dicussion about redaction of standards apart, inexact has to apply to mathematical operations that require rounding for representing the result with the same type. For example, Scheme has such kind of definition of exactness/inexactness by mean of exact operations and exact literal constants see R5RS \u00a76. standard procedures from <a href=\"http://www.schemers.org/Documents/Standards/R5RS/HTML\" rel=\"nofollow\">http://www.schemers.org/Documents/Standards/R5RS/HTML</a></p>\n<p>For case of <code>double x=0.1</code> we either consider that 0.1 is a well defined double literal, or as in Scheme, that the literal is an inexact constant formed by an inexact compile time operation (rounding to the nearest double the result of operation 1/10 which is well defined in Q). So we always end up on operations.</p>\n<p>Let's concentrate on +, the others can be defined mathematically by mean of + and group property.</p>\n<p>A possible definition of inexactness could then be:</p>\n<pre><code>If there exists any pair of values (a,b) of a type such that a+b-a-b != 0,\nthen this type is inexact (in the sense that + operation is inexact).\n</code></pre>\n<p>For every floating point representation we know of (trivial case of nan and inf apart) there obviously exist such pair, so we can tell that float (operations) are inexact.</p>\n<p>For well defined unsigned arithmetic model, + is exact.</p>\n<p>For signed int, we have the problem of UB in case of overflow, so no warranty of exactness... Unless we refine the rule to cope with this broken arithmetic model:</p>\n<pre><code>If there exists any pair (a,b) such that (a+b) is well defined\nand a+b-a-b != 0,\nthen the + operation is inexact.\n</code></pre>\n<p>Above well definedness could help us extend to other operations as well, but it's not really necessary.<br>\nWe would then have to consider the case of / as false polymorphism rather than inexactness<br>\n(/ being defined as the quotient of Euclidean division for int).</br></br></p>\n<p>Of course, this is not an official rule, validity of this answer is limited to the effort of rational thinking</p>\n", "LastActivityDate": "2013-01-10T23:37:55.717", "CommentCount": "0", "CreationDate": "2013-01-10T23:37:55.717", "ParentId": "14203654", "Score": "2", "OwnerUserId": "1396822"}, "bq_ids": {"n4140": {"so_14203654_14203654_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 22}, "so_14203654_14205392_1": {"length": 4, "quality": 1.0, "section_id": 6737}, "so_14203654_14203676_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 6737}, "so_14203654_14205392_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 7217}, "so_14203654_14205392_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 6737}, "so_14203654_14205392_0": {"length": 5, "quality": 1.0, "section_id": 6737}, "so_14203654_14203676_0": {"length": 4, "quality": 1.0, "section_id": 6736}, "so_14203654_14205392_4": {"length": 4, "quality": 0.8, "section_id": 7217}}, "n3337": {"so_14203654_14205392_0": {"length": 5, "quality": 1.0, "section_id": 6492}, "so_14203654_14203654_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 19}, "so_14203654_14205392_1": {"length": 4, "quality": 1.0, "section_id": 6492}, "so_14203654_14203676_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 6492}, "so_14203654_14205392_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6961}, "so_14203654_14205392_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 6492}, "so_14203654_14205392_4": {"length": 4, "quality": 0.8, "section_id": 6961}, "so_14203654_14203676_0": {"length": 4, "quality": 1.0, "section_id": 6491}}, "n4659": {"so_14203654_14203654_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 22}, "so_14203654_14205392_1": {"length": 4, "quality": 1.0, "section_id": 8231}, "so_14203654_14203676_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 8231}, "so_14203654_14205392_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 8726}, "so_14203654_14205392_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 8231}, "so_14203654_14205392_0": {"length": 4, "quality": 0.8, "section_id": 8231}, "so_14203654_14203676_0": {"length": 4, "quality": 1.0, "section_id": 8230}}}, "14297563": {"Id": "14297563", "PostTypeId": "2", "Body": "<p><strong><code>std::numeric_limits&lt;T&gt;::is_exact</code> should be <code>false</code> if and only if <code>T</code>'s definition allows values that may be unstorable.</strong></p>\n<p>C++ considers any floating point literal to be a valid value for its type. And implementations are allowed to decide which values have exact stored representation.</p>\n<p>So for every real number in the allowed range (such as <code>2.0</code> or <code>0.2</code>), C++ <strong>always</strong> promises that the number is a valid <code>double</code> and <strong>never</strong> promises that the value can be stored exactly.</p>\n<p><em>This means that two assumptions made in the question - while true for the ubiquitous <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"nofollow\">IEEE floating point</a> standard - are <strong>incorrect for the C++ definition:</strong></em></p>\n<blockquote>\n<p id=\"so_14203654_14297563_0\">I'm certain that I could store a <code>2</code> in a double exactly.</p>\n<p id=\"so_14203654_14297563_1\">I could then divide [it] by <code>10</code> and [the double would <strong>not</strong>] hold the\n  mathematical result <em>exactly</em>.</p>\n</blockquote>\n", "LastEditorUserId": "16287", "LastActivityDate": "2013-01-16T22:33:58.827", "Score": "1", "CreationDate": "2013-01-12T20:18:10.857", "ParentId": "14203654", "CommentCount": "3", "OwnerUserId": "16287", "LastEditDate": "2013-01-16T22:33:58.827"}});