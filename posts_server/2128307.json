post_cb({"bq_ids": {"n4140": {"so_2128307_2128328_0": {"length": 12, "quality": 0.631578947368421, "section_id": 3298}}, "n3337": {"so_2128307_2128328_0": {"length": 12, "quality": 0.631578947368421, "section_id": 3168}}}, "2128363": {"CommentCount": "0", "Body": "<p>No, no need for getters and setters yet. It is still a plain data structure where no methods implement actions modifying the data structure - compare, assign, swap are no 'behaviour' here, they're stub needed by the language to perform basic operations and to make the data structure actually usable. </p>\n<p>You need to decide whether there are any dependencies or invariants to be hold between the fields of structure. If they exist (or may exist in future), use getters or setters to ensure them (i.e. adjust attribute a if attribute b is changed). If not, declare everything public. <code>name</code> and <code>age</code> are decoupled properties of a human being, I don't think accessors are really necessary here. Of course it's a matter of taste.</p>\n", "CreationDate": "2010-01-24T19:17:45.333", "ParentId": "2128307", "Id": "2128363", "LastActivityDate": "2010-01-24T19:17:45.333", "PostTypeId": "2", "Score": "1", "OwnerUserId": "234053"}, "2128307": {"CreationDate": "2010-01-24T19:07:11.207", "ViewCount": "128", "Id": "2128307", "AcceptedAnswerId": "2128363", "Score": "0", "Title": "Ok to provide constructor + trivial operators for behaviorless aggregates?", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>This is a follow-up question to <a href=\"https://stackoverflow.com/questions/2043381/ok-to-provide-constructor-for-behaviorless-aggregates-bundle-o-data-in-c\">2043381</a>.</p>\n<p>Consider the following:</p>\n<pre><code>struct DataBundle\n{\n   std::string name;\n   int age;\n\n   DataBundle() : age(0) {}\n   DataBundle(const std::string&amp; name, int age)\n       : name(name), age(age) {}\n   void swap(DataBundle&amp; rhs)\n       {name.swap(rhs.name); std::swap(age, rhs.age);}\n   DataBundle&amp; operator=(DataBundle rhs) {swap(rhs); return *this;}\n   bool operator==(const DataBundle&amp; rhs) const\n       {return (name == rhs.name) &amp;&amp; (age == rhs.age);}\n   bool operator!=(const DataBundle&amp; rhs) const {return !(*this == rhs);}\n}\n</code></pre>\n<p>In the spirit of rule #41 of C++ Coding Standards (see related <a href=\"http://www.gotw.ca/gotw/070.htm\" rel=\"nofollow noreferrer\">article</a>), would this still be considered a behaviorless aggregate? I don't like writing \"dumb\" classes with mostly getters/setters, and would rather use an all-public struct to indicate it's just a \"bundle-o-data\". But in the above example, am I at the point where I should make DataBundle a class with getters/setters?</p>\n", "Tags": "<c++><aggregate><pod>", "LastEditDate": "2017-05-23T12:07:05.263", "LastActivityDate": "2010-01-24T19:17:45.333", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "245265"}, "2128328": {"CommentCount": "2", "Body": "<p>Well it's not an aggregate in C++ Standard terms - see section <strong>8.5.1 Aggregates</strong>:</p>\n<blockquote>\n<p id=\"so_2128307_2128328_0\">An aggregate is an array or a class\n  (clause 9) with no user-declared\n  constructors (12.1), no private or\n  protected non-static data members\n  (clause 11), no base classes (clause\n  10), and no virtual functions (10.3).</p>\n</blockquote>\n", "CreationDate": "2010-01-24T19:11:23.053", "OwnerDisplayName": "anon", "ParentId": "2128307", "Id": "2128328", "LastActivityDate": "2010-01-24T19:11:23.053", "PostTypeId": "2", "Score": "1"}});