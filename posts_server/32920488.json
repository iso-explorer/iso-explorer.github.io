post_cb({"bq_ids": {"n4140": {"so_32920488_32920640_0": {"length": 18, "quality": 1.0, "section_id": 175}}, "n3337": {"so_32920488_32920640_0": {"length": 18, "quality": 1.0, "section_id": 169}}}, "32920824": {"Id": "32920824", "PostTypeId": "2", "Body": "<p>The <code>x</code> in your code is a non-dependent name, and the Standard renders a template that cannot be validly instantiated whatever you provide as template parameter as ill-formed, no diagnostic required (actually this also applies to \"temploids\", as an example in the Standard shows. That is, the rules apply equally well to members of class templates).</p>\n<p>Your code is as invalid as any normal class that accesses a name of a surrounding class. Notice that the direction is important here. The following would <em>not</em> be ill-formed (because you <em>can</em> specialize <code>A&lt;T&gt;::B</code> such that <code>x</code> for <code>A&lt;int&gt;::B</code> is a static member, for example.</p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n    struct B {\n       int x;\n    };\n\n    void f() {\n       B::x = 1;\n    }\n};\n</code></pre>\n<p>However, an <em>enclosing</em> class template's type is called <em>the current instantiation</em>, which means that its meaning always stays the same and cannot change depending on template parameters. Therefore the template definition itself can be rendered ill-formed by certain uses such as yours.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2015-10-03T09:26:48.403", "CommentCount": "7", "CreationDate": "2015-10-03T09:09:07.460", "ParentId": "32920488", "Score": "2", "OwnerUserId": "34509", "LastEditDate": "2015-10-03T09:26:48.403"}, "32920640": {"PostTypeId": "2", "Body": "<p>[temp.res]/8 says:</p>\n<blockquote>\n<p id=\"so_32920488_32920640_0\">No diagnostic\n  shall be issued for a template for which a valid specialization can be generated. If no valid specialization can\n  be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>I believe the second sentence applies to unused parts of <code>B</code>. If the function is not instantiated, the compiler is not required to realize that it cannot be instantiated, ever.</p>\n", "LastActivityDate": "2015-10-03T08:48:29.190", "Id": "32920640", "CommentCount": "0", "CreationDate": "2015-10-03T08:48:29.190", "ParentId": "32920488", "Score": "1", "OwnerUserId": "597607"}, "32920488": {"ViewCount": "53", "Body": "<p>I accidentally found that g++ (5.2.0) compiles the following</p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n    int x;\n    struct B {\n        void foo() {\n            x = 1;\n        }\n    };\n};\n</code></pre>\n<p>even istantiating <code>A</code> and <code>A::B</code>, provided the member <code>B::foo</code> is not used. You reasonably get instead a compile error for <code>x</code> being a non-static member of <code>A</code> even by just compiling the no-op statement <code>&amp;A&lt;int&gt;::B::foo;</code>.</p>\n<p>clang (3.6.2) however refuses the template even if <code>A</code> is not instantiated at all because it says that the non-static member name <code>x</code> cannot be used inside <code>B</code> while just reading the template definition.</p>\n<p>Is this a bug in g++ or clang is being too strict about template members that are not instantiated?</p>\n", "AcceptedAnswerId": "32920824", "Title": "Can a template be instantiated if there is nested type (not accessed) with a method that cannot be compiled?", "CreationDate": "2015-10-03T08:29:31.463", "Id": "32920488", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-10-03T09:26:48.403", "Score": "4", "OwnerUserId": "320726", "Tags": "<c++><templates><g++><clang++>", "AnswerCount": "2"}});