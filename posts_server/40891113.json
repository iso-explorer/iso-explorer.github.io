post_cb({"bq_ids": {"n4140": {"so_40891113_40891838_1": {"length": 23, "quality": 1.0, "section_id": 5943}, "so_40891113_40891838_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}}, "n3337": {"so_40891113_40891838_1": {"length": 23, "quality": 1.0, "section_id": 5714}, "so_40891113_40891838_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}}, "n4659": {"so_40891113_40891838_1": {"length": 23, "quality": 1.0, "section_id": 7428}, "so_40891113_40891838_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}}}, "40891838": {"Id": "40891838", "PostTypeId": "2", "Body": "<p>See Clause 5 Expressions [expr]. Point 10 starts</p>\n<blockquote>\n<p id=\"so_40891113_40891838_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a <strong>common type</strong>, which is also the type of the result. This pattern is called the usual arithmetic conversions, which are defined as follows:</p>\n</blockquote>\n<p>The sub-points that follow say things like \"If <strong>either</strong> operand is...\", \"...the <strong>other</strong> shall...\", \"If <strong>both</strong> operands ...\" etc.</p>\n<p>For your specific example, see 10.5.2</p>\n<blockquote>\n<p id=\"so_40891113_40891838_1\">Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank shall be converted to the type of the operand with greater rank.</p>\n</blockquote>\n", "LastActivityDate": "2016-11-30T15:13:03.140", "CommentCount": "0", "CreationDate": "2016-11-30T15:13:03.140", "ParentId": "40891113", "Score": "2", "OwnerUserId": "583195"}, "40891113": {"ViewCount": "125", "Body": "<p>I was trying to read through the C/C++ standard for this but I can't find the answer.</p>\n<p>Say you have the following snippet:</p>\n<pre><code>int8_t m;\nint64_t n;\n</code></pre>\n<p>And that at some point you perform <code>m + n</code>, the addition itself is a binary operator and I think the most likely think that happen in such a case is:</p>\n<ol>\n<li>Wide <code>m</code> to the same size of <code>n</code>, call the widening result <code>m_prime</code></li>\n<li>Perform <code>m_prime + n</code></li>\n<li>Return a result of type <code>int64_t</code></li>\n</ol>\n<p>I was trying to understand however if instead of performing <code>m+n</code> I had performed <code>n+m</code> the result would change (because maybe there could be a narrowing operations instead of a widening).</p>\n<p>I cannot find the part of the standard that clarify this point (which I understand it could sound trivial).</p>\n<p>Can anyone point me where I can find this in the standard? or what happens in general in situations like the one I exposed?</p>\n<p>Personally I've been looking at the section \"Additive operators\" but it doesn't seem to me to explain what happens, pointer arithmetic is covered a bit, but there's no reference to some casting rule implicitly applied.</p>\n<p>You can assume I'm talking about C++11, but any other standard I guess would apply the same rules.</p>\n", "AcceptedAnswerId": "40891838", "Title": "Widening and narrowing rules in C/C++", "CreationDate": "2016-11-30T14:38:25.483", "Id": "40891113", "CommentCount": "14", "PostTypeId": "1", "LastActivityDate": "2016-11-30T15:13:03.140", "Score": "3", "OwnerUserId": "4792660", "Tags": "<c++><standards>", "AnswerCount": "1"}});