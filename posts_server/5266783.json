post_cb({"5266783": {"CommentCount": "2", "AcceptedAnswerId": "5267706", "PostTypeId": "1", "LastEditorUserId": "576911", "CreationDate": "2011-03-10T22:41:09.720", "LastActivityDate": "2011-03-11T01:42:16.930", "LastEditDate": "2011-03-11T01:11:14.610", "ViewCount": "1518", "FavoriteCount": "4", "Title": "Classes, Rvalues and Rvalue References", "Id": "5266783", "Score": "12", "Body": "<p>An lvalue is a value bound to a definitive region of memory whereas an rvalue is an expression value whose existence is temporary and who does not necessarily refer to a definitive region of memory. Whenever an lvalue is used in a position in which an rvalue is expected, the compiler performs an lvalue-to-rvalue conversion and then proceeds with evaluation.</p>\n<p><a href=\"http://www.eetimes.com/discussion/programming-pointers/4023341/Lvalues-and-Rvalues\">http://www.eetimes.com/discussion/programming-pointers/4023341/Lvalues-and-Rvalues</a></p>\n<p>Whenever we construct a temporary (anonymous) class object or return a temporary class object from a function, although the object is temporary, it is addressable. However, the object still is a valid rvalue. This means that the object is a) an addressable rvalue or b) is being implicitly converted from an lvalue to an rvalue when the compiler expects an lvalue to be used.</p>\n<p>For instance:</p>\n<pre><code>class A\n{\npublic:\n    int x;\n    A(int a) { x = a; std::cout &lt;&lt; \"int conversion ctor\\n\"; }\n    A(A&amp;) { std::cout &lt;&lt; \"lvalue copy ctor\\n\"; }\n    A(A&amp;&amp;) { std::cout &lt;&lt; \"rvalue copy ctor\\n\"; }\n};\nA ret_a(A a) \n{\n    return a;\n}\n\nint main(void)\n{\n    &amp;A(5); // A(5) is an addressable object\n    A&amp;&amp; rvalue = A(5); // A(5) is also an rvalue\n}\n</code></pre>\n<p>We also know that temporary objects <strong>returned</strong> (in the following case <code>a</code>) by functions are lvalues as this code segment:</p>\n<pre><code>int main(void)\n{\n    ret_a(A(5));\n}\n</code></pre>\n<p>yields the following output:</p>\n<p><code>int conversion ctor</code></p>\n<p><code>lvalue copy ctor</code></p>\n<p>Indicating that the call to the function <code>ret_a</code> using actual argument <code>A(5)</code> calls the conversion constructor <code>A::A(int)</code> which constructs the function's formal argument <code>a</code> with the value 5.</p>\n<p>When the function completes execution, it then constructs a temporary <code>A</code> object using <code>a</code> as its argument, which invokes <code>A::A(A&amp;)</code>. However, if we were to remove <code>A::A(A&amp;)</code> from the list of overloaded constructors, the returned temporary object would still match the rvalue-reference constructor <code>A::A(A&amp;&amp;)</code>.</p>\n<p>This is what I'm not quite understanding: how can the object <code>a</code> match both an rvalue reference and an lvalue reference? It is clear that <code>A::A(A&amp;)</code> is a better match than <code>A::A(A&amp;&amp;)</code> (and therefore <code>a</code> must be an lvalue). But, because an rvalue reference cannot be initialized to an lvalue, given that the formal argument <code>a</code> is an lvalue, it should not be able to match the call to <code>A::A(A&amp;&amp;)</code>. If the compiler is making an lvalue-to-rvalue conversion it would be trivial. The fact that a conversion from 'A' to 'A&amp;' is also trivial, both functions should have identical implicit conversion sequence ranks and therefore, the compiler should not be able to deduce the best-matching function when both <code>A::A(A&amp;)</code> and <code>A::A(A&amp;&amp;)</code> are in the overloaded function candidate set.</p>\n<p>Moreover, the question (which I previously asked) is:</p>\n<p>How can a given object match both an rvalue reference and an lvalue reference?</p>\n", "Tags": "<c++><reference><rvalue-reference><rvalue><lvalue>", "OwnerUserId": "654419", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_5266783_5267706_2": {"section_id": 3321, "quality": 0.6, "length": 6}, "so_5266783_5267706_1": {"section_id": 481, "quality": 0.8311688311688312, "length": 64}}, "n3337": {"so_5266783_5267706_2": {"section_id": 3191, "quality": 0.6, "length": 6}, "so_5266783_5267706_1": {"section_id": 472, "quality": 0.948051948051948, "length": 73}}, "n4659": {"so_5266783_5267706_2": {"section_id": 4087, "quality": 0.6, "length": 6}, "so_5266783_5267706_1": {"section_id": 504, "quality": 0.7792207792207793, "length": 60}}}, "5267706": {"ParentId": "5266783", "PostTypeId": "2", "CommentCount": "16", "CreationDate": "2011-03-11T00:36:32.660", "Score": "6", "LastEditorUserId": "576911", "LastEditDate": "2011-03-11T01:42:16.930", "Id": "5267706", "OwnerUserId": "576911", "Body": "<p>For me:</p>\n<pre><code>int main(void)\n{\n    ret_a(A(5));\n}\n</code></pre>\n<p>Yields:</p>\n<pre><code>int conversion ctor\nrvalue copy ctor\n</code></pre>\n<p>(i.e. rvalue, not lvalue).  This is a bug in your compiler.  However it is understandable as the rules for this behavior changed only a few months ago (Nov. 2010).  More on this below.</p>\n<blockquote>\n<p id=\"so_5266783_5267706_0\">When the function completes execution,\n  it then constructs a temporary <code>A</code>\n  object using <code>a</code> as its argument, which\n  invokes <code>A::A(A&amp;)</code>.</p>\n</blockquote>\n<p>Actually no.  When the function <code>ret_a</code> completes execution, it then constructs a temporary <code>A</code> object using <code>a</code> as its argument, which invokes <code>A:A(A&amp;&amp;)</code>.  This is due to [class.copy]/p33]<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">1</a>:</p>\n<blockquote>\n<p id=\"so_5266783_5267706_1\">When the criteria for elision of a\n  copy operation are met or would be met\n  save for the fact that the source\n  object is a function parameter, and\n  the object to be copied is designated\n  by an lvalue, overload resolution to\n  select the constructor for the copy is\n  first performed as if the object were\n  designated by an rvalue. If overload\n  resolution fails, or if the type of\n  the first parameter of the selected\n  constructor is not an rvalue reference\n  to the object\u2019s type (possibly\n  cv-qualified), overload resolution is\n  performed again, considering the\n  object as an lvalue. [ Note: This\n  two-stage overload resolution must be\n  performed regardless of whether copy\n  elision will occur. It determines the\n  constructor to be called if elision is\n  not performed, and the selected\n  constructor must be accessible even if\n  the call is elided. \u2014 end note ]</p>\n</blockquote>\n<p>However if you remove the <code>A::A(A&amp;&amp;)</code> constructor, then <code>A::A(&amp;)</code> will be chosen for the return. Although in this case, then the construction of the argument <code>a</code> will fail because you can't construct it using an rvalue.   However ignoring that for the moment, I believe your ultimate question is:</p>\n<blockquote>\n<p id=\"so_5266783_5267706_2\">How can a given object match both an\n  rvalue reference and an lvalue\n  reference?</p>\n</blockquote>\n<p>in referring to the statement:</p>\n<pre><code>return a;\n</code></pre>\n<p>And the answer is in the above quoted paragraph from the draft standard:  First overload resolution is tried as if <code>a</code> is an rvalue.  And if that fails, overload resolution is tried again using <code>a</code> as an lvalue.  This two-stage process is tried only in the context wherein copy elision is permissible (such as a return statement).</p>\n<p>The C++0x draft has just recently been changed to allow the two-stage overload resolution process when returning arguments that have been passed by value (as in your example).  And that is the reason for the varying behavior from different compilers that we are seeing.</p>\n", "LastActivityDate": "2011-03-11T01:42:16.930"}});