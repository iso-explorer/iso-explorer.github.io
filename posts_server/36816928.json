post_cb({"36816928": {"CommentCount": "1", "AcceptedAnswerId": "36817064", "CreationDate": "2016-04-23T21:57:15.083", "LastActivityDate": "2016-04-23T22:26:48.653", "PostTypeId": "1", "ViewCount": "302", "FavoriteCount": "1", "Title": "Why C++ async run sequentially without future?", "Id": "36816928", "Score": "7", "Body": "<pre><code>#include &lt;future&gt;\n#include &lt;iostream&gt;\n\nvoid main()\n{\n    std::async(std::launch::async,[] {std::cout &lt;&lt; \"async...\" &lt;&lt; std::endl; while (1);});\n    std::cout &lt;&lt; \"runing main...\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In this code, only \"async...\" will be outputted, which means the code is blocked at async. However, if I add future and let the statement become:</p>\n<pre><code>std::future&lt;bool&gt; fut = std::async([] \n{std::cout &lt;&lt; \"async...\" &lt;&lt; std::endl; while (1); return false; });\n</code></pre>\n<p>Then everything runs smoothly (it will not be blocked). I am not sure why it happen in this way. I think async is supposed to run in a separate thread.</p>\n", "Tags": "<c++><multithreading><c++11><asynchronous>", "OwnerUserId": "4672312", "AnswerCount": "1"}, "36817064": {"ParentId": "36816928", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-04-23T22:14:10.640", "Score": "11", "LastEditorUserId": "2666289", "LastEditDate": "2016-04-23T22:26:48.653", "Id": "36817064", "OwnerUserId": "2666289", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/thread/async\" rel=\"noreferrer\"><code>encppreference.com</code></a>:</p>\n<blockquote>\n<p id=\"so_36816928_36817064_0\">If the <code>std::future</code> obtained from <code>std::async</code> is not moved from or bound to a reference, the destructor of the <code>std::future</code> will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous: </p>\n<pre><code>std::async(std::launch::async, []{ f(); }); // temporary's dtor waits for f()\nstd::async(std::launch::async, []{ g(); }); // does not start until f() completes\n</code></pre>\n</blockquote>\n<p>If I did get that right, it comes from these parts of the standard (N4527):</p>\n<p><em>\u00a730.6.6 [futures.unique_future]:</em></p>\n<blockquote>\n<p id=\"so_36816928_36817064_1\"><code>~future();</code></p>\n<p id=\"so_36816928_36817064_2\">Effects:</p>\n<p id=\"so_36816928_36817064_3\">\u2014 releases any shared state (30.6.4);</p>\n</blockquote>\n<p><em>\u00a730.6.4#5 [futures.state]</em> (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_36816928_36817064_4\">When an asynchronous return object or an asynchronous provider is said to release its shared state, it means:</p>\n<p id=\"so_36816928_36817064_5\">[...].</p>\n<p id=\"so_36816928_36817064_6\">\u2014 these actions will not block for the shared state to become ready, <strong>except that it may block if all of the following are true: the shared state was created by a call to std::async, the shared state is not yet ready, and this was the last reference to the shared state</strong>.</p>\n</blockquote>\n<p>Since you did not store the result of your first <code>std::async</code> call, the destructor of <code>std::future</code> is called and since all 3 conditions are met:</p>\n<ul>\n<li>the <code>std::future</code> was created via <code>std::async</code>;</li>\n<li>the shared state is not yet ready (due to your infinite loop);</li>\n<li>there is no remaining reference to this future</li>\n</ul>\n<p>...then the call is blocking.</p>\n", "LastActivityDate": "2016-04-23T22:26:48.653"}, "bq_ids": {"n4140": {"so_36816928_36817064_4": {"section_id": 3071, "quality": 1.0, "length": 12}, "so_36816928_36817064_6": {"section_id": 3071, "quality": 1.0, "length": 28}}, "n3337": {"so_36816928_36817064_4": {"section_id": 2948, "quality": 1.0, "length": 12}}, "n4659": {"so_36816928_36817064_4": {"section_id": 3831, "quality": 1.0, "length": 12}, "so_36816928_36817064_6": {"section_id": 3831, "quality": 1.0, "length": 28}}}});