post_cb({"bq_ids": {"n4140": {"so_28821786_28821799_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5313}, "so_28821786_28821799_3": {"length": 56, "quality": 0.8888888888888888, "section_id": 5313}, "so_28821786_28821799_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 5313}, "so_28821786_28821799_1": {"length": 69, "quality": 0.92, "section_id": 5313}, "so_28821786_28821799_5": {"length": 29, "quality": 1.0, "section_id": 5313}, "so_28821786_28821799_2": {"length": 60, "quality": 0.9523809523809523, "section_id": 5313}}, "n3337": {"so_28821786_28821799_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5110}, "so_28821786_28821799_1": {"length": 69, "quality": 0.92, "section_id": 5110}, "so_28821786_28821799_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 5110}, "so_28821786_28821799_3": {"length": 56, "quality": 0.8888888888888888, "section_id": 5110}, "so_28821786_28821799_5": {"length": 29, "quality": 1.0, "section_id": 5110}, "so_28821786_28821799_2": {"length": 62, "quality": 0.9841269841269841, "section_id": 5110}}, "n4659": {"so_28821786_28821799_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6737}, "so_28821786_28821799_1": {"length": 63, "quality": 0.84, "section_id": 6737}, "so_28821786_28821799_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 6737}, "so_28821786_28821799_3": {"length": 56, "quality": 0.8888888888888888, "section_id": 6737}, "so_28821786_28821799_5": {"length": 29, "quality": 1.0, "section_id": 6737}, "so_28821786_28821799_2": {"length": 60, "quality": 0.9523809523809523, "section_id": 6737}}}, "28821786": {"ViewCount": "144", "Body": "<p>I have an array defined as follows:</p>\n<pre><code>extern const char config_reg[] = {  \n  0x05, //comment\n  0x00, //comment\n  0x00, //  \\\\    &lt;-- double backslash\n  0x01, //comment\n  0x03\n}\n</code></pre>\n<p>As you can see, there is a double backslash inside a comment (the <code>&lt;-- double backslash</code> and preceding spaces do not appear in the actual source file). When I compile this code (minus the \"&lt;-- double backslash\") it acts as if the <strong>following</strong> line is non existent - i.e. equivalent to writing:</p>\n<pre><code>extern const char config_reg[] = {  \n  0x05, //comment\n  0x00, //comment\n  0x00, //  \n\n  0x03\n}\n</code></pre>\n<p>Is this intended C++ behaviour? If so, what is its intended purpose?</p>\n<p>I am compiling using the Parallax Propeller Simple IDE to compile my code - not a particularly good compiler, by all accounts. Is it likely that the compiler implementation is causing this behaviour? </p>\n", "AcceptedAnswerId": "28821838", "Title": "Double backslash in comment inside array", "CreationDate": "2015-03-03T00:10:37.330", "Id": "28821786", "CommentCount": "2", "LastEditDate": "2015-03-03T00:20:32.383", "PostTypeId": "1", "LastEditorUserId": "15168", "LastActivityDate": "2015-03-03T00:32:05.743", "Score": "3", "OwnerUserId": "3660420", "Tags": "<c++><arrays><comments>", "AnswerCount": "3"}, "28821838": {"Id": "28821838", "PostTypeId": "2", "Body": "<p>Yes, the second phase of translation involves \"splicing physical source lines to form logical source lines\"; if a line ends with a backslash, the following line is considered to be a continuation of that line. This is the standard behaviour. This occurs <strong>before</strong> the removal of comments in the third phase, so the fact that the backslash occurs in a comment doesn't change anything.</p>\n<p>Line splicing is used quite frequently in C to split macros over multiple lines, since a preprocessor directive extends to the end of the line. It is much rarer in C++, which relies much less on macros than C.</p>\n<p>I believe the original purpose in C was to work around restrictions on line length that existed on some now-archaic systems.</p>\n", "LastActivityDate": "2015-03-03T00:17:11.160", "CommentCount": "1", "CreationDate": "2015-03-03T00:17:11.160", "ParentId": "28821786", "Score": "1", "OwnerUserId": "481267"}, "28821799": {"Id": "28821799", "PostTypeId": "2", "Body": "<p>That's correct, assuming that the <code>&lt;-- double backslash</code> and preceding spaces aren't actually in the code.</p>\n<p>A single backslash would also produce the same effect.</p>\n<p>The newline splicing for backslash-newline occurs before comment analysis, so the <code>0x01</code> line is part of the same line as the <code>// \\\\</code> comment, so it isn't seen when the comment analysis is done.</p>\n<p>The ISO/IEC 14882:2011 (C++11) standard says:</p>\n<blockquote>\n<h3>2.2 Phases of translation [lex.phases]</h3>\n<p id=\"so_28821786_28821799_0\">\u00b61 The precedence among the syntax rules of translation is specified by the following phases.<sup>11</sup></p>\n<ol>\n<li><p id=\"so_28821786_28821799_1\">Physical source file characters are mapped, in an implementation-defined manner, to the basic source\n  character set (introducing new-line characters for end-of-line indicators) if necessary. The set of physical\n  source file characters accepted is implementation-defined. Trigraph sequences (2.4) are replaced\n  by corresponding single-character internal representations. Any source file character not in the basic\n  source character set (2.3) is replaced by the universal-character-name that designates that character.\n  (An implementation may use any internal encoding, so long as an actual extended character\n  encountered in the source file, and the same extended character expressed in the source file as a\n  universal-character-name (i.e., using the <code>\\uXXXX</code> notation), are handled equivalently except where this\n  replacement is reverted in a raw string literal.)</p></li>\n<li><p id=\"so_28821786_28821799_2\">Each instance of a backslash character (<code>\\</code>) immediately followed by a new-line character is deleted,\n  splicing physical source lines to form logical source lines. Only the last backslash on any physical\n  source line shall be eligible for being part of such a splice. If, as a result, a character sequence that\n  matches the syntax of a universal-character-name is produced, the behavior is undefined. A source file\n  that is not empty and that does not end in a new-line character, or that ends in a new-line character\n  immediately preceded by a backslash character before any such splicing takes place, shall be processed\n  as if an additional new-line character were appended to the file.</p></li>\n<li><p id=\"so_28821786_28821799_3\">The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters\n  (including comments). A source file shall not end in a partial preprocessing token or in a partial comment.<sup>12</sup> Each comment is replaced by one space character. New-line characters are retained. Whether\n  each nonempty sequence of white-space characters other than new-line is retained or replaced by one\n  space character is unspecified. The process of dividing a source file\u2019s characters into preprocessing tokens\n  is context-dependent. [ <em>Example:</em> see the handling of <code>&lt;</code> within a <code>#include</code> preprocessing directive.\n  \u2014<em>end example</em> ]</p></li>\n</ol>\n<p id=\"so_28821786_28821799_4\"><sup>11)</sup> Implementations must behave as if these separate phases occur, although in practice different phases might be folded\n  together.</p>\n<p id=\"so_28821786_28821799_5\"><sup>12)</sup> A partial preprocessing token would arise from a source file ending in the first portion of a multi-character token that\n  requires a terminating sequence of characters, such as a header-name that is missing the closing <code>\"</code> or <code>&gt;</code>. A partial comment\n  would arise from a source file ending with an unclosed <code>/*</code> comment.</p>\n</blockquote>\n", "LastEditorUserId": "15168", "LastActivityDate": "2015-03-03T00:27:53.297", "Score": "2", "CreationDate": "2015-03-03T00:12:39.853", "ParentId": "28821786", "CommentCount": "0", "OwnerUserId": "15168", "LastEditDate": "2015-03-03T00:27:53.297"}, "28821857": {"Id": "28821857", "PostTypeId": "2", "Body": "<p>A <code>\\</code> at the end of a line escapes the newline character.</p>\n<p>Thus in your example, it will extend the comment to the next line. The writer of the snippet probably used <code>\\\\</code> instead of just <code>\\</code> for aesthetic purposes. But it doesn't only work with comments. For example this is allowed (but redundant):</p>\n<pre><code>int a; \\\nint b;\n</code></pre>\n<p>Some compilers allow whitespace between the <code>\\</code> and the newline but may issue a warning.</p>\n", "LastEditorUserId": "3425536", "LastActivityDate": "2015-03-03T00:32:05.743", "Score": "1", "CreationDate": "2015-03-03T00:19:17.603", "ParentId": "28821786", "CommentCount": "0", "OwnerUserId": "3425536", "LastEditDate": "2015-03-03T00:32:05.743"}});