post_cb({"15403": {"ParentId": "15254", "CommentCount": "0", "CreationDate": "2008-08-19T00:03:57.933", "OwnerUserId": "1739", "Id": "15403", "PostTypeId": "2", "OwnerDisplayName": "James Sutherland", "Score": "1", "Body": "<p>Thanks for the replies. Using placement new for each item in the array was the solution I ended up using when I ran into this (sorry, should have mentioned that in the question). I just felt that there must have been something I was missing about doing it with placement new[]. As it is, it seems like placement new[] is essentially unusable thanks to the standard allowing the compiler to add an additional unspecified overhead to the array. I don't see how you could ever use it safely and portably.</p>\n<p>I'm not even really clear why it needs the additional data, as you wouldn't call delete[] on the array anyway, so I don't entirely see why it needs to know how many items are in it.</p>\n", "LastActivityDate": "2008-08-19T00:03:57.933"}, "15343": {"CommentCount": "7", "CreationDate": "2008-08-18T22:53:05.003", "LastEditorUserId": "106104", "LastActivityDate": "2015-03-13T06:52:31.727", "ParentId": "15254", "PostTypeId": "2", "LastEditorDisplayName": "OJ", "LastEditDate": "2015-03-13T06:52:31.727", "Id": "15343", "Score": "22", "Body": "<p>Personally I'd go with the option of not using placement new on the array and instead use placement new on each item in the array individually. For example:</p>\n<pre><code>int main(int argc, char* argv[])\n{\n  const int NUMELEMENTS=20;\n\n  char *pBuffer = new char[NUMELEMENTS*sizeof(A)];\n  A *pA = (A*)pBuffer;\n\n  for(int i = 0; i &lt; NUMELEMENTS; ++i)\n  {\n    pA[i] = new (pA + i) A();\n  }\n\n  printf(\"Buffer address: %x, Array address: %x\\n\", pBuffer, pA);\n\n  // dont forget to destroy!\n  for(int i = 0; i &lt; NUMELEMENTS; ++i)\n  {\n    pA[i].~A();\n  }    \n\n  delete[] pBuffer;\n\n  return 0;\n}\n</code></pre>\n<p>Regardless of the method you use, make sure you manually destroy each of those items in the array before you delete pBuffer, as you could end up with leaks ;)</p>\n<p><em>Note</em>: I haven't compiled this, but I think it should work (I'm on a machine that doesn't have a C++ compiler installed). It still indicates the point :) Hope it helps in some way!</p>\n<hr>\n<p>Edit:</p>\n<p>The reason it needs to keep track of the number of elements is so that it can iterate through them when you call delete on the array and make sure the destructors are called on each of the objects. If it doesn't know how many there are it wouldn't be able to do this.</p>\n</hr>", "OwnerUserId": "611", "OwnerDisplayName": "OJ"}, "15372": {"ParentId": "15254", "CommentCount": "1", "CreationDate": "2008-08-18T23:26:37.463", "OwnerUserId": "1043", "Id": "15372", "PostTypeId": "2", "OwnerDisplayName": "Andrew", "Score": "1", "Body": "<p>Similar to how you would use a single element to calculate the size for one placement-new, use an array of those elements to calculate the size required for an array.</p>\n<p>If you require the size for other calculations where the number of elements may not be known you can use sizeof(A[1]) and multiply by your required element count.</p>\n<p>e.g</p>\n<pre><code>char *pBuffer = new char[ sizeof(A[NUMELEMENTS]) ];\nA *pA = (A*)pBuffer;\n\nfor(int i = 0; i &lt; NUMELEMENTS; ++i)\n{\n    pA[i] = new (pA + i) A();\n}\n</code></pre>\n", "LastActivityDate": "2008-08-18T23:26:37.463"}, "15948": {"ParentId": "15254", "CommentCount": "2", "CreationDate": "2008-08-19T10:16:44.577", "OwnerUserId": "1739", "Id": "15948", "PostTypeId": "2", "OwnerDisplayName": "James Sutherland", "Score": "4", "Body": "<p>@Derek</p>\n<p>5.3.4, section 12 talks about the array allocation overhead and, unless I'm misreading it, it seems to suggest to me that it is valid for the compiler to add it on placement new as well:</p>\n<blockquote>\n<p id=\"so_15254_15948_0\">This overhead may be applied in all array new-expressions, including those referencing the library function operator new[](std::size_t, void*) and other placement allocation functions. The amount of overhead may vary from one invocation of new to another.</p>\n</blockquote>\n<p>That said, I think VC was the only compiler that gave me trouble with this, out of it, GCC, Codewarrior and ProDG. I'd have to check again to be sure, though.</p>\n", "LastActivityDate": "2008-08-19T10:16:44.577"}, "17011": {"CommentCount": "1", "CreationDate": "2008-08-19T21:36:16.077", "LastEditorUserId": "142162", "LastActivityDate": "2012-07-03T14:51:43.403", "ParentId": "15254", "LastEditDate": "2012-07-03T14:51:43.403", "OwnerDisplayName": "Mat Noguchi", "PostTypeId": "2", "Id": "17011", "Score": "3", "Body": "<p>Placement new itself is portable, but the assumptions you make about what it does with a specified block of memory are not portable. Like what was said before, if you were a compiler and were given a chunk of memory, how would you know how to allocate an array and properly destruct each element if all you had was a pointer? (See the interface of operator delete[].)</p>\n<p>Edit:</p>\n<p>And there actually is a placement delete, only it is only called when a constructor throws an exception while allocating an array with placement new[].</p>\n<p>Whether new[] actually needs to keep track of the number of elements somehow is something that is left up to the standard, which leaves it up to the compiler. Unfortunately, in this case.</p>\n", "OwnerUserId": "1799"}, "15547": {"ParentId": "15254", "CommentCount": "1", "CreationDate": "2008-08-19T02:14:14.067", "OwnerUserId": "872", "Id": "15547", "PostTypeId": "2", "OwnerDisplayName": "Derek Park", "Score": "2", "Body": "<p>@James</p>\n<blockquote>\n<p id=\"so_15254_15547_0\">I'm not even really clear why it needs the additional data, as you wouldn't call delete[] on the array anyway, so I don't entirely see why it needs to know how many items are in it.</p>\n</blockquote>\n<p>After giving this some thought, I agree with you.  There is no reason why placement new should need to store the number of elements, because there is no placement delete.  Since there's no placement delete, there's no reason for placement new to store the number of elements.</p>\n<p>I also tested this with gcc on my Mac, using a class with a destructor.  On my system, placement new was <em>not</em> changing the pointer.  This makes me wonder if this is a VC++ issue, and whether this might violate the standard (the standard doesn't specifically address this, so far as I can find).</p>\n", "LastActivityDate": "2008-08-19T02:14:14.067"}, "15254": {"CommentCount": "3", "ViewCount": "7458", "PostTypeId": "1", "LastEditorUserId": "1561378", "LastEditorDisplayName": "Lance Fisher", "CreationDate": "2008-08-18T21:33:35.863", "LastActivityDate": "2015-03-13T06:52:31.727", "AnswerCount": "7", "LastEditDate": "2012-09-01T23:25:54.560", "AcceptedAnswerId": "15343", "FavoriteCount": "13", "Title": "Can placement new for arrays be used in a portable way?", "Id": "15254", "Score": "30", "Body": "<p>Is it possible to actually make use of placement new in portable code when using it for arrays?</p>\n<p>It appears that the pointer you get back from new[] is not always the same as the address you pass in (5.3.4, note 12 in the standard seems to confirm that this is correct), but I don't see how you can allocate a buffer for the array to go in if this is the case.</p>\n<p>The following example shows the problem. Compiled with Visual Studio, this example results in memory corruption:</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;stdio.h&gt;\n\nclass A\n{\n    public:\n\n    A() : data(0) {}\n    virtual ~A() {}\n    int data;\n};\n\nint main()\n{\n    const int NUMELEMENTS=20;\n\n    char *pBuffer = new char[NUMELEMENTS*sizeof(A)];\n    A *pA = new(pBuffer) A[NUMELEMENTS];\n\n    // With VC++, pA will be four bytes higher than pBuffer\n    printf(\"Buffer address: %x, Array address: %x\\n\", pBuffer, pA);\n\n    // Debug runtime will assert here due to heap corruption\n    delete[] pBuffer;\n\n    return 0;\n}\n</code></pre>\n<p>Looking at the memory, the compiler seems to be using the first four bytes of the buffer to store a count of the number of items in it. This means that because the buffer is only <code>sizeof(A)*NUMELEMENTS</code> big, the last element in the array is written into unallocated heap.</p>\n<p>So the question is can you find out how much additional overhead your implementation wants in order to use placement new[] safely? Ideally, I need a technique that's portable between different compilers. Note that, at least in VC's case, the overhead seems to differ for different classes. For instance, if I remove the virtual destructor in the example, the address returned from new[] is the same as the address I pass in.</p>\n", "Tags": "<c++><arrays><compiler-construction><portability><overhead>", "OwnerUserId": "1739", "OwnerDisplayName": "James Sutherland"}, "15273": {"ParentId": "15254", "CommentCount": "1", "CreationDate": "2008-08-18T21:45:14.640", "OwnerUserId": "1648", "Id": "15273", "PostTypeId": "2", "OwnerDisplayName": "Yossi Kreinin", "Score": "1", "Body": "<p>I think gcc does the same thing as MSVC, but of course this doesn't make it \"portable\".</p>\n<p>I think you can work around the problem when NUMELEMENTS is indeed a compile time constant, like so:</p>\n<p><code>\ntypedef A Arr[NUMELEMENTS];</code></p>\n<p>A* p = new (buffer) Arr;\n</p>\n<p>This should use the scalar placement new.</p>\n", "LastActivityDate": "2008-08-18T21:45:14.640"}, "bq_ids": {"n4140": {"so_15254_15948_0": {"section_id": 6095, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_15254_15948_0": {"section_id": 5861, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_15254_15948_0": {"section_id": 7592, "quality": 0.9285714285714286, "length": 26}}}});