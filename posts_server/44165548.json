post_cb({"44166698": {"ParentId": "44165548", "CommentCount": "2", "Body": "<p>As @PasserBy hinted in a comment, <code>constexpr</code> doesn't affect as much as you'd hope. After <code>static constexpr int a = 10;</code>, code that reads <code>a</code>'s value can be optimised at compile time to use <code>10</code> directly, and the compiler will ensure that the initialiser <code>10</code> is a compile-time constant, but there is still an object there that in some cases might need actual storage at run-time, including initialisation. For instance when its address is taken.</p>\n<p>Initialisation of block-scope <code>static</code>s may happen early, the same way as for file scope objects, or it may happen when the execution reaches the declaration:</p>\n<p>N4140 [dcl.stmt]p4:</p>\n<blockquote>\n<p id=\"so_44165548_44166698_0\">[...] An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize\n  a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. [...]</p>\n</blockquote>\n<p>Now, @MartinBonner's deleted answer quoted [dcl.stmt]p3:</p>\n<blockquote>\n<p id=\"so_44165548_44166698_1\">It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A program that jumps<sup>90</sup> from a point where a variable with automatic storage duration is not in scope to a\n  point where it is in scope is ill-formed unless the variable has scalar type, class type with a trivial default constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the\n  preceding types and is declared without an initializer (8.5).</p>\n</blockquote>\n<p>The second sentence only addresses objects with automatic storage duration, but the first doesn't. You're transferring into a block in a way that <em>does</em> potentially bypass a declaration with initialisation. The only thing is, it doesn't <em>necessary</em> bypass a declaration with initialisation: if the initialisation is performed early, no initialisation gets bypassed.</p>\n<p>In this particular case, I would hope that all sensible implementations perform early initialisation, but it's not required, and because of that I think the error message is allowed. But I do suspect this isn't MSVC's intended behaviour:</p>\n<p>Here's an example where you'd definitely want an error:</p>\n<pre><code>int &amp;f() { static int i; return i; }\n\nint main() {\n  switch (0) {\n    static int &amp;i = f();\n  case 0:\n    return i;\n  }\n}\n</code></pre>\n<p>Here, the initialisation of the variable <code>i</code> is skipped, and as a result, an uninitialised reference is accessed, triggering a segmentation fault on multiple compilers. Yet in this case, MSVC does <em>not</em> show a compilation error. (Nor do other compilers.) It doesn't make sense for the error message to be issued in a situation where the error is harmless, but omitted where the error is harmful. Because of that, I suspect the error message you're receiving is not intended, and worth reporting as a bug.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "44166698", "Score": "4", "CreationDate": "2017-05-24T19:09:16.060", "LastActivityDate": "2017-05-24T19:09:16.060"}, "44165548": {"CommentCount": "5", "ViewCount": "87", "PostTypeId": "1", "LastEditorUserId": "955978", "CreationDate": "2017-05-24T18:00:26.057", "LastActivityDate": "2017-05-24T19:10:19.387", "Title": "static constexpr in function scope - is MSVC's behavior a compiler bug?", "LastEditDate": "2017-05-24T18:21:55.130", "Id": "44165548", "Score": "2", "Body": "<p>My understanding is that a function scope <code>static constexpr</code> is evaluated at compile time.  If this is the case, what justification, if any, does MSVC have for the following error:</p>\n<pre><code>int main()\n{\n    int i = 5;\n\n    switch (i)\n    {\n        // Original question:\n        static constexpr int j = 7; // legal?\n        // My actual use case, which may not be legal.\n        static constexpr int k[2] = { 7, 4 };\n\n    default:\n    case 0:\n        break;\n    }\n    return 0;\n}\n</code></pre>\n<p>testapp.cpp(10) : error C2360 : initialization of 'j' is skipped by 'case' label</p>\n<p>If that were a non-constexpr then yes, this is a valid complaint.  However since the constexpr is evaluated at compile time, there should be no need to execute anything at the declaration site.</p>\n<p>-- Edit --</p>\n<p>With apologies to Martin Bonner whose answer was deleted since it did not apply to my original question.</p>\n<p>My actual use case is the second: a constexpr array with an initializer list.  From what I saw in the standard that was cited, my first case of a static constexpr scalar int is not prohibited.  However it appears that what I'm trying to do is ill-formed.</p>\n<p>If this is indeed true, then why?  Isn't the whole point of constexpr to evaluate things at compile time, <em>therefore it should not matter if control ever actually passes the declaration.</em></p>\n", "Tags": "<c++><function><scope><static><constexpr>", "OwnerUserId": "955978", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_44165548_44166698_0": {"section_id": 3919, "quality": 0.9777777777777777, "length": 44}, "so_44165548_44165799_0": {"section_id": 3894, "quality": 1.0, "length": 5}, "so_44165548_44166698_1": {"section_id": 3918, "quality": 0.9512195121951219, "length": 39}, "so_44165548_44165799_1": {"section_id": 3918, "quality": 1.0, "length": 9}}, "n3337": {"so_44165548_44166698_0": {"section_id": 3779, "quality": 0.9777777777777777, "length": 44}, "so_44165548_44165799_0": {"section_id": 3754, "quality": 1.0, "length": 5}, "so_44165548_44166698_1": {"section_id": 3778, "quality": 0.9512195121951219, "length": 39}, "so_44165548_44165799_1": {"section_id": 3778, "quality": 1.0, "length": 9}}, "n4659": {"so_44165548_44165799_0": {"section_id": 4780, "quality": 0.8, "length": 4}, "so_44165548_44166698_1": {"section_id": 4804, "quality": 0.975609756097561, "length": 40}, "so_44165548_44165799_1": {"section_id": 4804, "quality": 1.0, "length": 9}}}, "44165799": {"ParentId": "44165548", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It's a MSVC bug.</p>\n<p>It's illegal to jump into the scope of a variable declaration+initializer  (e.g. <code>case 0: int j = 5;</code>), but the rules also say that a <code>static</code> is initialized the first time control passes through their declaration. And declarations, however, are allowed to exist within a switch statement body, according to \u00a76.4.2/6 [stmt.switch] </p>\n<blockquote>\n<p id=\"so_44165548_44165799_0\">\"...Declarations can appear in the substatement of a\n  switch-statement.\"</p>\n</blockquote>\n<p>So <code>static</code> is what makes everything okay in this instance.</p>\n<p>You could be totally fine if you had a non-static declaration (without initialization) at the beginning of a switch statement; it's the skipping over of declaration with initialization that makes the compiler bug out.</p>\n<pre><code>switch (i)\n{\n    int j;\n    case 0:\n        j = 2;\n        std::cout &lt;&lt; 0 &lt;&lt; std::endl;\n    break;\n    default:\n        j = 3;\n      std::cout &lt;&lt; j &lt;&lt; std::endl;\n    break;\n}\n</code></pre>\n<p>even this is fine (although dangerous):</p>\n<pre><code>case 0:\n    int j;\n    j = 5;\nbreak;\ndefault:\n    /*..*/\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/goto\" rel=\"nofollow noreferrer\">Because of the rules surrounding control transfer</a>: \u00a76.7/3 [stmt.dcl]:</p>\n<blockquote>\n<p id=\"so_44165548_44165799_1\">It is possible to transfer into a block, but not in a way that bypasses declarations with initialization.</p>\n</blockquote>\n<p>I think <a href=\"http://en.cppreference.com/w/cpp/language/goto\" rel=\"nofollow noreferrer\">cppreference</a> explains it better:</p>\n<blockquote>\n<p id=\"so_44165548_44165799_2\">If transfer of control enters the scope of any automatic variables (e.g. by jumping forward over a declaration statement), the program is ill-formed (cannot be compiled), unless all variables whose scope is entered have</p>\n<p id=\"so_44165548_44165799_3\">1) scalar types declared without initializers</p>\n<p id=\"so_44165548_44165799_4\">...</p>\n</blockquote>\n", "OwnerUserId": "27678", "LastEditorUserId": "27678", "LastEditDate": "2017-05-24T19:10:19.387", "Id": "44165799", "Score": "2", "CreationDate": "2017-05-24T18:13:50.453", "LastActivityDate": "2017-05-24T19:10:19.387"}});