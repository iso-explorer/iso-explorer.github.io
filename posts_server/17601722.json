post_cb({"17602136": {"Id": "17602136", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17601722_17602136_0\">I'm wondering if it's allowed to concurrently get values for some keys and in the same time inserting new key-value pairs to the STL map in Visual C++ 2010, if I guarantee that each thread accesses/inserts a different key.</p>\n</blockquote>\n<p>No, it is not allowed. Lookup involves traversal of internal data structures (for std::map common approach for internal representation is <a href=\"http://en.wikipedia.org/wiki/Binary_search_tree\" rel=\"nofollow\">binary search tree</a> like <a href=\"http://en.wikipedia.org/wiki/Red%E2%80%93black_tree\" rel=\"nofollow\">Red\u2013black tree</a>). On the other hand insert modifies internal structures.</p>\n<p>If simultaneous lookups and inserts would be thread-safe, then each access, even in single-thread environment, would involve high syncronization cost for operations, which contradicts C++ princple - \"you do pay for what you don't use\".</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/vstudio/c9ceah3b%28v=vs.100%29.aspx\" rel=\"nofollow\">Thread Safety in MSVC 2010</a>:</p>\n<blockquote>\n<p id=\"so_17601722_17602136_1\">If a single object is being written to by one thread, then all reads and writes to that object on the same or other threads must be protected. For example, given an object A, if thread 1 is writing to A, then thread 2 must be prevented from reading from or writing to A.</p>\n</blockquote>\n<p>That said, if you already have reference to element before insert operations in other thread - it would be safe to access element via that reference, because object is not moved during internal rebalancing.</p>\n<p>ISO C++11 23.2.4/9:</p>\n<blockquote>\n<p id=\"so_17601722_17602136_2\">The insert and emplace members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<hr>\n<p>MSVC 2012 (but not MSVC 2010) has <a href=\"http://msdn.microsoft.com/en-us/library/hh750089.aspx\" rel=\"nofollow\"><code>concurrency::concurrent_unordered_map</code></a> associative container (note it is <em>unordered</em> which makes it similar to <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map\" rel=\"nofollow\"><code>std::unordered_map</code></a>, i.e. it requires hash and equality for keys rather than strict weak ordering):</p>\n<blockquote>\n<p id=\"so_17601722_17602136_3\">The <code>concurrent_unordered_map</code> class is a concurrency-safe container that controls a varying-length sequence of elements of type s<code>td::pair&lt;const _Key_type, _Element_type&gt;</code>. The sequence is represented in a way that enables concurrency-safe append, element access, iterator access, and iterator traversal operations.</p>\n</blockquote>\n<hr>\n<p><a href=\"http://threadingbuildingblocks.org/\" rel=\"nofollow\">Intel TBB</a> library has similar container - <a href=\"http://threadingbuildingblocks.org/docs/help/reference/containers_overview/concurrent_unordered_map_cls.htm\" rel=\"nofollow\"><code>tbb::concurrent_unordered_map</code></a>:</p>\n<blockquote>\n<p id=\"so_17601722_17602136_4\">Template class for associative container that supports concurrent insertion and traversal.</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "1762344", "LastActivityDate": "2013-11-03T14:17:14.457", "Score": "5", "CreationDate": "2013-07-11T19:47:58.160", "ParentId": "17601722", "CommentCount": "0", "OwnerUserId": "1762344", "LastEditDate": "2013-11-03T14:17:14.457"}, "bq_ids": {"n4140": {"so_17601722_17602136_2": {"length": 15, "quality": 0.9375, "section_id": 745}}, "n3337": {"so_17601722_17602136_2": {"length": 15, "quality": 0.9375, "section_id": 734}}, "n4659": {"so_17601722_17602136_2": {"length": 15, "quality": 0.9375, "section_id": 803}}}, "17601722": {"ViewCount": "529", "Body": "<p>I know that it's allowed to read some cells and concurrently write to different cells of an STL vector as long as no resizing is needed. I'm wondering if it's allowed to concurrently get values for some keys and in the same time inserting new key-value pairs to the STL map in Visual C++ 2010, if I guarantee that each thread accesses/inserts a different key.</p>\n<p>From http://www.cplusplus.com/reference/map/map/operator[]/:</p>\n<blockquote>\n<p id=\"so_17601722_17601722_0\">Data races:</p>\n<p id=\"so_17601722_17601722_1\">The container is accessed, and potentially modified. The function\n  accesses an element and returns a reference that can be used to modify\n  its mapped value. Concurrently accessing other elements is safe. If\n  the function inserts a new element, concurrently iterating ranges in\n  the container is not safe.</p>\n</blockquote>\n<p>So this says that if I insert a new element, I can't iterate over the container. The question is whether accessing a different element requires iterating over the container or not. Is that safe then?</p>\n<p>Will it be safe if I guarantee that the size of the container never exceeds N? Then maybe the internal data structures of the map could be pre-allocated and stay constant - like vector's internals as long as the vector isn't resized.</p>\n<p>I know that there are thread-safe implementations of map available, but they're much slower probably, so I'm wondering if the standard map is enough in my case, because the code I'm modifying is a hotspot in my app.</p>\n<p>Thanks,\nMichal</p>\n", "AcceptedAnswerId": "17602136", "Title": "STL map implementation in Visual C++ 2010 and thread safety", "CreationDate": "2013-07-11T19:25:38.480", "Id": "17601722", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-11-03T14:17:14.457", "Score": "1", "OwnerUserId": "304522", "Tags": "<c++><map><concurrency><stl><thread-safety>", "AnswerCount": "1"}});