post_cb({"38930793": {"ParentId": "38929950", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There doesn't exist a lot of information about this topic on the internet. Though looking at some sources, I would conclude the following:</p>\n<p><code>extern template</code> should prevent implicit instantiations, though in all examples, the <code>explicit</code> instantiation doesn't have this <code>extern template</code> definition.</p>\n<p>From what I can read, especially on the proposal and the GCC mailing list (see references below), the <code>extern template</code> doesn't prevent <code>implicit</code> instantiations, though ALL instantiations of the template. This would include your <code>explicit</code> instantiation.</p>\n<blockquote>\n<p id=\"so_38929950_38930793_0\">If an entity is the subject of both an explicit instantiation \n  declaration and an explicit instantiation definition\n  in the same translation unit, the definition shall follow the declaration. - John Spicer on GCC mailing list</p>\n</blockquote>\n<p>From this, I would conclude that you should remove the <code>extern template</code> in the translation unit where you want the explicit instantiation.</p>\n<p>References:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/8130602/using-extern-template-c11\">SO: Using extern templace C++11</a></li>\n<li><a href=\"http://www.stroustrup.com/C++11FAQ.html#extern-templates\" rel=\"nofollow noreferrer\">Stroustrup: C++11FAQ</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1448.pdf\" rel=\"nofollow noreferrer\">Standard proposal</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/class_template\" rel=\"nofollow noreferrer\">CppReference: Class Template</a></li>\n<li><a href=\"https://gcc.gnu.org/ml/gcc-bugs/2008-12/msg02979.html\" rel=\"nofollow noreferrer\">GCC Mailing list: extern template declaration accepted after explicit instantiation</a></li>\n</ul>\n", "OwnerUserId": "2466431", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:33:44.093", "Id": "38930793", "Score": "2", "CreationDate": "2016-08-13T08:26:58.793", "LastActivityDate": "2016-08-13T08:26:58.793"}, "38929950": {"CommentCount": "5", "AcceptedAnswerId": "38931484", "PostTypeId": "1", "LastEditorUserId": "1488940", "CreationDate": "2016-08-13T06:35:06.367", "LastActivityDate": "2017-09-18T00:22:11.963", "LastEditDate": "2016-08-13T08:14:37.793", "ViewCount": "376", "FavoriteCount": "2", "Title": "Automatic constructor in explicitly instantiated class template", "Id": "38929950", "Score": "7", "Body": "<p>I have a <code>template&lt;bool VAR&gt; struct Obj</code> template declared in a header file (<code>obj.h</code>) with explicit automatic move constructor (<code>= default</code>).</p>\n<pre><code>// obj.h\n#pragma once\n#include &lt;vector&gt;\n\ntemplate&lt;bool VAR&gt;\nstruct Obj {\n  std::vector&lt;int&gt; member;\n  Obj(int m): member(m) { }\n  Obj(Obj&amp;&amp;) = default;\n  int member_fun() const;\n};\n\nextern template struct Obj&lt;false&gt;;\nextern template struct Obj&lt;true&gt;;\n</code></pre>\n<p>The member function of the template is defined in another file (<code>obj.cpp</code>) with explicit instantiation of the template:</p>\n<pre><code>// obj.cpp\n#include \"obj.h\"\n\ntemplate&lt;bool VAR&gt;\nint Obj&lt;VAR&gt;::member_fun() const {\n  return 42;\n}\n\ntemplate struct Obj&lt;false&gt;;\ntemplate struct Obj&lt;true&gt;;\n</code></pre>\n<p>This template is then used from the main file (<code>main.cpp</code>):</p>\n<pre><code>// main.cpp\n#include &lt;utility&gt;\n#include \"obj.h\"\n\nint main() {\n  Obj&lt;true&gt; o1(20);\n  Obj&lt;true&gt; o2(std::move(o1));\n  return o2.member_fun();\n}\n</code></pre>\n<p>The <code>.cpp</code>s are then compiled and linked together with the following <code>Makefile</code>:</p>\n<pre><code>#CXX=clang++\nCXX=g++\nCXXFLAGS=-Wall -Wextra -std=c++14\n\na.out: obj.o main.o\n    $(CXX) $(CXXFLAGS) $^ -o a.out\n\nobj.o: obj.cpp obj.h\n    $(CXX) $(CXXFLAGS) -c $&lt; -o $@\nmain.o: main.cpp obj.h\n    $(CXX) $(CXXFLAGS) -c $&lt; -o $@\n</code></pre>\n<p>However, I get a linker error: <code>undefined reference to 'Obj&lt;true&gt;::Obj(Obj&lt;true&gt;&amp;&amp;)'</code> -- the compiler apparently did not instantiate the constructor. </p>\n<ul>\n<li><code>Obj&lt;true&gt;::member_fun()</code> is defined and the program indeed links successfully if I remove the reference to the move constructor from <code>main.cpp</code>.</li>\n<li>If I remove <code>extern template</code> from the header, the program compiles.</li>\n<li>If I use <code>int</code> instead of <code>std::vector&lt;int&gt;</code> for the type of <code>member</code>, the program also compiles.</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/move_constructor\" rel=\"nofollow\">cppreference.com</a> claims that \"the compiler will declare a move constructor as a non-explicit <em>inline</em> public member of its class\". However, the manually defined <code>Obj(int)</code> constructor is also inline, but it is correctly instantiated.</li>\n</ul>\n<p>(I received this error with Clang in a project that compiled fine with GCC, so I thought this was a Clang bug. However, when I reduced the problem to this simple case, both GCC 5.4.0 and Clang 3.8.0 produce the same results.)</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "1488940", "AnswerCount": "3"}, "46270051": {"ParentId": "38929950", "CommentCount": "0", "Body": "<p>It's possible that you are hitting a compiler bug.</p>\n<p>See <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60796\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60796</a>.</p>\n<p>I'm hitting similar behavior on CLang, but can't find a bug report.</p>\n", "OwnerUserId": "407731", "PostTypeId": "2", "Id": "46270051", "Score": "0", "CreationDate": "2017-09-18T00:22:11.963", "LastActivityDate": "2017-09-18T00:22:11.963"}, "bq_ids": {"n4140": {"so_38929950_38931484_2": {"section_id": 259, "quality": 0.8888888888888888, "length": 56}, "so_38929950_38931484_0": {"section_id": 3274, "quality": 1.0, "length": 14}, "so_38929950_38930793_0": {"section_id": 260, "quality": 0.75, "length": 15}, "so_38929950_38931484_1": {"section_id": 5881, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_38929950_38931484_2": {"section_id": 250, "quality": 0.6666666666666666, "length": 42}, "so_38929950_38931484_0": {"section_id": 3145, "quality": 1.0, "length": 14}, "so_38929950_38930793_0": {"section_id": 251, "quality": 0.75, "length": 15}, "so_38929950_38931484_1": {"section_id": 5652, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_38929950_38931484_2": {"section_id": 266, "quality": 0.9047619047619048, "length": 57}, "so_38929950_38931484_0": {"section_id": 4032, "quality": 1.0, "length": 14}, "so_38929950_38930793_0": {"section_id": 267, "quality": 0.75, "length": 15}, "so_38929950_38931484_1": {"section_id": 7364, "quality": 0.7692307692307693, "length": 10}}}, "38931484": {"ParentId": "38929950", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Interesting. I think your code is correct, because:</p>\n<p>Your defaulted move-constructor is implicitly <code>inline</code> because of:</p>\n<p><a href=\"http://eel.is/c++draft/dcl.fct.def.default#5\" rel=\"nofollow\">[dcl.fct.def.default]/5</a>:</p>\n<blockquote>\n<p id=\"so_38929950_38931484_0\">... A user-provided explicitly-defaulted function (i.e., explicitly\n  defaulted after its first declaration) is defined at the point where\n  it is explicitly defaulted.</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/class.mfct#1\" rel=\"nofollow\">[class.mfct]/1</a>:</p>\n<blockquote>\n<p id=\"so_38929950_38931484_1\">A member function may be defined ([dcl.fct.def]) in its class\n  definition, in which case it is an inline member function\n  ([dcl.fct.spec])</p>\n</blockquote>\n<p>And thus is exempt from explicit template instantiation according to <a href=\"http://eel.is/c++draft/temp.explicit#10\" rel=\"nofollow\">[temp.explicit]/10</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_38929950_38931484_2\"><strong>Except for inline functions and variables</strong>, declarations with types\n  deduced from their initializer or return value ([dcl.spec.auto]),\n  const variables of literal types, variables of reference types, and\n  class template specializations, explicit instantiation declarations\n  have the effect of suppressing the implicit instantiation of the\n  entity to which they refer. [ Note: The intent is that an inline\n  function that is the subject of an explicit instantiation declaration\n  will still be implicitly instantiated when odr-used ([basic.def.odr])\n  so that the body can be considered for inlining, but that no\n  out-of-line copy of the inline function would be generated in the\n  translation unit. \u2014 end note ]</p>\n</blockquote>\n<p>In fact, if you try any optimization mode other than <code>-O0</code>, the problem disappears.</p>\n<p><code>-O0</code> is a special mode in which inlined functions are not inlined. But it shouldn't matter, the compiler must in that case generate the <code>inline</code> defaulted move-constructor like it does with the other constructor.</p>\n<p>So to me this looks like a compiler bug. Also look at <a href=\"https://llvm.org/bugs/show_bug.cgi?id=22763\" rel=\"nofollow\">LLVM#22763</a> and <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60796\" rel=\"nofollow\">GCC#60796</a>.</p>\n<p>I see at least 2 possible workarounds:</p>\n<p><strong>Solution 1</strong></p>\n<p>Do not use <code>extern template ...</code> for now (compilation times will suffer but otherwise no big deal).</p>\n<p><strong>Solution 2</strong></p>\n<p>Trick the compiler into generating the suppressed constructor in <code>obj.cpp</code></p>\n<pre><code>template&lt;&gt; Obj&lt;true&gt;::Obj(Obj&amp;&amp;) noexcept = default;\n</code></pre>\n<p>This one will only be used in <code>-O0</code> mode. In production code the inlined version will be used instead.</p>\n", "OwnerUserId": "485343", "LastEditorUserId": "485343", "LastEditDate": "2016-08-15T11:49:06.247", "Id": "38931484", "Score": "4", "CreationDate": "2016-08-13T09:52:00.470", "LastActivityDate": "2016-08-15T11:49:06.247"}});