post_cb({"bq_ids": {"n4140": {"so_11677188_11677315_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 293}}, "n3337": {"so_11677188_11677315_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 284}}, "n4659": {"so_11677188_11677315_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 300}}}, "11677231": {"Id": "11677231", "PostTypeId": "2", "Body": "<p>When calling a function template template parameters, which are the type of the function arguments can be automatically deduced from the type of the arguments, the function is called with:</p>\n<pre><code>object.Set&lt;ACTIVE&gt;(true); //same as object.Set&lt;Active,bool&gt;(true);\nobject.Set&lt;ACTIVE&gt;(5);    //same as object.Set&lt;Active,int&gt;(5);\n</code></pre>\n<p>This is the reason one can use template functions from the standardlibrary, like <code>std::max</code> or <code>std::copy</code> without explicitely mentioning the types of the arguments.</p>\n", "LastEditorUserId": "201270", "LastActivityDate": "2012-07-26T20:13:27.870", "Score": "1", "CreationDate": "2012-07-26T20:07:31.120", "ParentId": "11677188", "CommentCount": "5", "LastEditDate": "2012-07-26T20:13:27.870", "OwnerUserId": "201270"}, "11677315": {"Id": "11677315", "PostTypeId": "2", "Body": "<p>Read this.<br/></p>\n<blockquote>\n<p id=\"so_11677188_11677315_0\">When a function template specialization is referenced, all of the\n  template arguments shall have values. The values can be explicitly\n  specified or, in some cases, be deduced from the use or obtained from\n  default template-arguments.</p>\n</blockquote>\n<pre><code>[ Example:\nvoid f(Array&lt;dcomplex&gt;&amp; cv, Array&lt;int&gt;&amp; ci) {\nsort(cv); // calls sort(Array&lt;dcomplex&gt;&amp;)\nsort(ci); // calls sort(Array&lt;int&gt;&amp;)\n}\nand\nvoid g(double d) {\nint i = convert&lt;int&gt;(d); // calls convert&lt;int,double&gt;(double)\nint c = convert&lt;char&gt;(d); // calls convert&lt;char,double&gt;(double)\n}\n\u2014end example ]\n</code></pre>\n<p>and 14.8.2 par of this doc. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></p>\n", "LastActivityDate": "2012-07-26T20:14:15.130", "Score": "1", "CreationDate": "2012-07-26T20:14:15.130", "ParentId": "11677188", "CommentCount": "0", "OwnerUserId": "1498580"}, "11677209": {"Id": "11677209", "PostTypeId": "2", "Body": "<p>The second one is deduced fom the type of argument passed to a function, in this case <code>bool</code>.</p>\n", "LastActivityDate": "2012-07-26T20:06:42.190", "Score": "2", "CreationDate": "2012-07-26T20:06:42.190", "ParentId": "11677188", "CommentCount": "1", "OwnerUserId": "1554020"}, "11677188": {"ViewCount": "322", "Body": "<p>While working on a project I came upon this code, which I'm trying to figure out:</p>\n<pre><code>enum Attributes { ACTIVE, COMPLETE, POSITION }\ntemplate&lt;Attributes NN,typename TT&gt;  \nTT&amp; Set(TT&amp;&amp; t) \n{ \n    return typeList.get&lt;NN&gt;()=t; //typeList is a boost tuple\n}\n</code></pre>\n<p>This is called later on with </p>\n<pre><code>object.Set&lt;ACTIVE&gt;(true);\n</code></pre>\n<p>There's only one template parameter in there! \nHow is possible to specify a template with two parameters, and then call it with only one? I would think the Set method supposed to take 2 template parameters (Attributes and typename), like an std::map.</p>\n", "AcceptedAnswerId": "11677231", "Title": "C++ - Defining 2 template parameters but calling with only 1", "CreationDate": "2012-07-26T20:05:18.690", "Id": "11677188", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-07-26T20:14:15.130", "Score": "1", "OwnerUserId": "1232685", "Tags": "<c++><templates>", "AnswerCount": "3"}});