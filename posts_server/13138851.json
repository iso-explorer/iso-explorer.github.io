post_cb({"13138851": {"CommentCount": "4", "AcceptedAnswerId": "13139229", "CreationDate": "2012-10-30T12:20:45.760", "LastActivityDate": "2012-10-30T12:59:35.050", "PostTypeId": "1", "ViewCount": "2142", "FavoriteCount": "3", "Title": "Why do I need to use std::move in the initialization list of a move-constructor?", "Id": "13138851", "Score": "14", "Body": "<p>Let's say I have a (trivial) class, which is move-constructible and move-assignable but not copy-constructable or copy-assignable:</p>\n<pre><code>class movable\n{\n  public:\n    explicit movable(int) {}\n    movable(movable&amp;&amp;) {}\n    movable&amp; operator=(movable&amp;&amp;) { return *this; }\n    movable(const movable&amp;) = delete;\n    movable&amp; operator=(const movable&amp;) = delete;\n};\n</code></pre>\n<p>This works fine:</p>\n<pre><code>movable m1(movable(17));\n</code></pre>\n<p>This, of course, does not work, because <code>m1</code> is not an rvalue:</p>\n<pre><code>movable m2(m1);\n</code></pre>\n<p>But, I can wrap <code>m1</code> in <code>std::move</code>, which casts it to an rvalue-reference, to make it work:</p>\n<pre><code>movable m2(std::move(m1));\n</code></pre>\n<p>So far, so good. Now, let's say I have a (equally trivial) container class, which holds a single value:</p>\n<pre><code>template &lt;typename T&gt;\nclass container\n{\n  public:\n    explicit container(T&amp;&amp; value) : value_(value) {}\n  private:\n    T value_;\n};\n</code></pre>\n<p>This, however, does not work:</p>\n<pre><code>container&lt;movable&gt; c(movable(17));\n</code></pre>\n<p>The compiler (I've tried clang 4.0 and g++ 4.7.2) complains that I'm trying to use <code>movable</code>'s deleted copy-constructor in <code>container</code>'s initialization list. Again, wrapping <code>value</code> in <code>std::move</code> makes it work:</p>\n<pre><code>    explicit container(T&amp;&amp; value) : value_(std::move(value)) {}\n</code></pre>\n<p>But why is <code>std::move</code> needed in this case? Isn't <code>value</code> already of type <code>movable&amp;&amp;</code>? How is <code>value_(value)</code> different from <code>movable m1(movable(42))</code>?</p>\n", "Tags": "<c++><c++11><rvalue-reference><move-semantics><move-constructor>", "OwnerUserId": "103522", "AnswerCount": "2"}, "13139295": {"ParentId": "13138851", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_13138851_13139295_0\">How is <code>value_(value)</code> different from <code>movable m1(movable(42))</code>?</p>\n</blockquote>\n<p>A named rvalue reference is an lvalue (and will thus bind to the deleted copy ctor), while a temporary is, well, an rvalue (a prvalue to be specific).</p>\n<p><code>\u00a75 [expr] p6</code></p>\n<blockquote>\n<p id=\"so_13138851_13139295_1\">[...] In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references to objects are treated as xvalues [...]</p>\n</blockquote>\n<p>Aswell as from the example:</p>\n<pre><code>A&amp;&amp; ar = static_cast&lt;A&amp;&amp;&gt;(a);\n</code></pre>\n<blockquote>\n<p id=\"so_13138851_13139295_2\">The expression <code>ar</code> is an lvalue.</p>\n</blockquote>\n<p>The above quotes are from non-normative notes, but are an adequate explanation, since the rest of clause 5 goes and explains which expressions <em>only</em> create xvalues<sup>\u2020</sup> (aka, only the specified expressions and none else will create xvalues). See also <a href=\"https://stackoverflow.com/q/11581903/500104\">here</a> for an exhaustive list.</p>\n<p>\u2020 xvalues are one subgroup of rvalues, with prvalues being the other subgroup. See <a href=\"https://stackoverflow.com/q/3601602/500104\">this question</a> for an explanation.</p>\n", "OwnerUserId": "500104", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:28.723", "Id": "13139295", "Score": "5", "CreationDate": "2012-10-30T12:47:01.650", "LastActivityDate": "2012-10-30T12:59:35.050"}, "13139229": {"ParentId": "13138851", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>That's because <code>value</code> is a named variable, and thus an lvalue. The <code>std::move</code> is required to cast it back into an rvalue, so that it will cause move-constructor overload of <code>T</code> to match.</p>\n<p>To say it another way: An rvalue reference can <em>bind</em> to an rvalue, but it is not itself an rvalue. It's just a reference, and in an expression it is an lvalue. The only way to create from it an expression that is an rvalue is by casting.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-10-30T12:49:34.037", "Id": "13139229", "Score": "16", "CreationDate": "2012-10-30T12:43:20.957", "LastActivityDate": "2012-10-30T12:49:34.037"}, "bq_ids": {"n4140": {"so_13138851_13139295_1": {"section_id": 5940, "quality": 1.0, "length": 14}}, "n3337": {"so_13138851_13139295_1": {"section_id": 5711, "quality": 1.0, "length": 14}}, "n4659": {"so_13138851_13139295_1": {"section_id": 7424, "quality": 1.0, "length": 14}}}});