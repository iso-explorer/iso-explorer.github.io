post_cb({"bq_ids": {"n4140": {"so_5135734_5136535_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6797}, "so_5135734_5136535_0": {"length": 19, "quality": 0.95, "section_id": 4907}}, "n3337": {"so_5135734_5136535_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6552}, "so_5135734_5136535_0": {"length": 19, "quality": 0.95, "section_id": 4702}}, "n4659": {"so_5135734_5136535_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 8287}, "so_5135734_5136535_0": {"length": 19, "quality": 0.95, "section_id": 6316}}}, "5136535": {"Id": "5136535", "PostTypeId": "2", "Body": "<p>So far as I can tell, I think this could be argued an implementation bug (or actually, since C++0x isn't published, not a bug <em>per se</em> but an incomplete implementation of the current state of the upcoming standard).</p>\n<p>Here's why, referring to n3225 for the expected behavior of <code>-std=c++0x</code>:</p>\n<p>D.7 says </p>\n<blockquote>\n<p id=\"so_5135734_5136535_0\">Every C header, each of which has a\n  name of the form name.h, behaves as if\n  each name placed in the standard\n  library namespace by the corresponding\n  cname header is placed within the\n  global namespace scope</p>\n</blockquote>\n<p>OK, so far so easy. What does <code>&lt;cstdint&gt;</code> place in the standard library namespace?</p>\n<p>18.4.1:</p>\n<pre><code>typedef unsigned integer type uint64_t; // optional\n</code></pre>\n<p>How optional? 18.4.1/2:</p>\n<blockquote>\n<p id=\"so_5135734_5136535_1\">The header de\ufb01nes all functions,\n  types, and macros the same as 7.18 in\n  the C standard</p>\n</blockquote>\n<p>Drat. What does the C standard say? Taking out n1256, 7.18.1.1/3:</p>\n<blockquote>\n<p id=\"so_5135734_5136535_2\">These types are optional. However,\n  if an implementation provides integer\n  types with widths of 8, 16, 32, or 64\n  bits, no padding bits, and (for the\n  signed types) that have a\n  two's complement representation, it\n  shall de\ufb01ne the corresponding typedef\n  names</p>\n</blockquote>\n<p>But hang on, surely on Android with <code>-std=c++0x</code> GCC <em>does</em> provide a 64 bit unsigned type with no padding bits: <code>unsigned long long</code>. So <code>&lt;cstdint&gt;</code> is required to provide <code>std::uint64_t</code> and hence <code>stdint.h</code> is required to provide <code>uint64_t</code> in the global namespace.</p>\n<p>Go on, someone tell me why I'm wrong :-) One possibility is that C++0x refers to \"ISO/IEC 9899:1999 Programming languages \u2014 C\" without specifying a version. Can it really be that (a) 7.18.1.1/3 was added in one of the TCs, and also (b) C++0x intends to reference the original standard as of 1999, not the amendments since then? I doubt either of these is the case, but I don't have the original C99 on hand to check (a) and I'm not even sure how to check (b).</p>\n<p>Edit: oh, as for which one should be used <code>-std=c++0x</code> isn't really a strict standards-compliant mode yet, since there isn't a strict standard yet. And even if there was a standard, gcc 4.4.3 certainly isn't a finished implementation of it. So I see no great need to use it if <code>-std=gnu++0x</code> is actually <em>more complete</em>, at least in this respect for your combination of gcc version and platform. </p>\n<p>However, <code>gnu++0x</code> will enable other GNU extensions, that you might not want your code to use. If you're aiming to write portable C++0x, then eventually you'd want to switch to <code>-std=c++0x</code>. But I don't think GCC 4.4 or any other C++0x implementation-in-progress is complete enough yet for it to be practical to write code from the (draft) standard, such that you could say with a straight face \"I'm programming C++0x, and it's only 2011!\". So I'd say, use whichever one works, and understand that whichever one you use now, you'll probably be switching to <code>-std=c++11</code> eventually anyway.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-02-27T23:29:42.953", "Score": "20", "CreationDate": "2011-02-27T22:35:53.743", "ParentId": "5135734", "CommentCount": "1", "OwnerUserId": "13005", "LastEditDate": "2011-02-27T23:29:42.953"}, "5135734": {"ViewCount": "9991", "Body": "<p>I'm having troubles with <code>&lt;stdint.h&gt;</code> when using <code>-std=c++0x</code> in GCC 4.4.3 (for Android):</p>\n<pre><code>// using -std=c++0x\n#include &lt;stdint.h&gt;\nuint64_t value;  // error: 'uint64_t' does not name a type\n</code></pre>\n<p>But using <code>-std=gnu++0x</code> works:</p>\n<pre><code>// using -std=gnu++0x\n#include &lt;stdint.h&gt;\nuint64_t value;  // OK\n</code></pre>\n<p>Is <code>&lt;stdint.h&gt;</code> incompatible with C++0x?</p>\n", "AcceptedAnswerId": "5136535", "Title": "What's the difference in GCC between -std=gnu++0x and -std=c++0x and which one should be used?", "CreationDate": "2011-02-27T20:30:29.857", "Id": "5135734", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-01-03T08:55:52.147", "LastEditorUserId": "880054", "LastActivityDate": "2013-01-03T08:55:52.147", "Score": "27", "OwnerUserId": "212865", "Tags": "<android><c++><gcc><c++11><compiler-options>", "AnswerCount": "1"}});