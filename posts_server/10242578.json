post_cb({"10242671": {"ParentId": "10242578", "CommentCount": "0", "Body": "<p>Write a test program to find out.</p>\n<pre><code>void func(const int&amp; a)\n{\n    std::cout &lt;&lt; \"func(const)\" &lt;&lt; std::endl;\n}\n\nvoid func(const volatile int&amp; a)\n{\n    std::cout &lt;&lt; \"func(const volatile)\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    const int a = 0;\n    const volatile int b = 0;\n    func(a);\n    func(b);\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>will output:</p>\n<pre><code>func(const)\nfunc(const volatile)\n</code></pre>\n", "OwnerUserId": "853665", "PostTypeId": "2", "Id": "10242671", "Score": "3", "CreationDate": "2012-04-20T08:22:10.997", "LastActivityDate": "2012-04-20T08:22:10.997"}, "bq_ids": {"n4140": {"so_10242578_10242660_3": {"section_id": 558, "quality": 0.9230769230769231, "length": 24}, "so_10242578_10242660_0": {"section_id": 558, "quality": 0.92, "length": 23}, "so_10242578_10242660_2": {"section_id": 558, "quality": 0.95, "length": 38}}, "n3337": {"so_10242578_10242660_3": {"section_id": 549, "quality": 0.9230769230769231, "length": 24}, "so_10242578_10242660_0": {"section_id": 549, "quality": 0.92, "length": 23}, "so_10242578_10242660_2": {"section_id": 549, "quality": 0.95, "length": 38}}, "n4659": {"so_10242578_10242660_3": {"section_id": 581, "quality": 0.9230769230769231, "length": 24}, "so_10242578_10242660_0": {"section_id": 581, "quality": 0.92, "length": 23}, "so_10242578_10242660_2": {"section_id": 581, "quality": 0.95, "length": 38}}}, "10242578": {"CommentCount": "5", "CreationDate": "2012-04-20T08:14:51.557", "PostTypeId": "1", "AcceptedAnswerId": "10242660", "LastEditorUserId": "472698", "LastActivityDate": "2016-02-18T14:18:20.047", "LastEditDate": "2014-03-26T19:07:43.903", "ViewCount": "907", "FavoriteCount": "6", "Title": "volatile overloading?", "Id": "10242578", "Score": "10", "Body": "<p>I heard that volatile is factor of overloading like const.</p>\n<p>If a function is overloaded by volatile parameter,\nwhen is the volatile-version called?</p>\n<p>I can't imagine a situation when the volatile-version is called.\u00a0</p>\n", "Tags": "<c++><overloading><volatile>", "OwnerUserId": "1321576", "AnswerCount": "3"}, "10242645": {"ParentId": "10242578", "CommentCount": "6", "Body": "<p>Here's an example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    void foo() {\n        std::cout &lt;&lt; \"in non-volatile\" &lt;&lt; std::endl;\n    }\n    void foo() volatile {\n        std::cout &lt;&lt; \"in volatile\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    A a;\n    a.foo();\n    volatile A b;\n    b.foo();\n}\n</code></pre>\n<p><code>b.foo()</code> will call the <code>volatile</code> overload. If <code>struct A</code> didn't have a volatile overload for <code>foo</code>, <code>b.foo()</code> would be invalid.</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "10242645", "Score": "10", "CreationDate": "2012-04-20T08:20:01.380", "LastActivityDate": "2012-04-20T08:20:01.380"}, "10242660": {"ParentId": "10242578", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Volatile can be applied to parameters, but it is not a factor of overloading when applied directly to the parameter.  It is however possible to use it to distinguish types of the parameter.  For example, this is legal:</p>\n<pre><code>void f(int &amp;p) {}; //reference to int\nvoid f(volatile int &amp;p) {}; //reference to volatile int\n</code></pre>\n<p>This is not:</p>\n<pre><code>void f(int p) {};\nvoid f(volatile int p) {};\n</code></pre>\n<p>The reason is that in the first example the reference is not what is volatile, but the integer.  In the second example, both types are integers and therefore the same type.</p>\n<p>There are also volatile methods.  They are akin to declaring <code>this</code> to be volatile.  Because <code>this</code> is a pointer and not the containing type itself, the following is also legal:</p>\n<pre><code>void c::f(int p) {};\nvoid c::f(int p) volatile {};\n</code></pre>\n<p>It is all the same as for overloading by <code>const</code>.</p>\n<p>This relevant part of the C++ standard is \u00a713.1 <em>Overloadable declarations</em>. From C++11 draft n3290:</p>\n<blockquote>\n<p id=\"so_10242578_10242660_0\">Parameter declarations that differ only in the presence or absence of const and/or volatile are equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called. [ Example:</p>\n</blockquote>\n<pre><code>typedef const int cInt;\nint f(int);\nint f(const int);          // redeclaration of f(int)\nint f(int) { /* ... */ }   // definition of f(int)\nint f(cInt) { /* ... */ }  // error: redefinition of f(int)\n</code></pre>\n<blockquote>\n<p id=\"so_10242578_10242660_1\">\u2014 end example ]</p>\n<p id=\"so_10242578_10242660_2\">Only the const and volatile type-specifiers at the outermost level of the parameter type specification are ignored in this fashion; const and volatile type-specifiers buried within a parameter type specification are significant and can be used to distinguish overloaded function declarations<sup>124</sup>. In particular, for any type T, <code>pointer to T</code>, <code>pointer to const T</code>, and <code>pointer to volatile T</code> are considered distinct parameter types, as are <code>reference to T</code>, <code>reference to const T</code>, and <code>reference to volatile T</code>.</p>\n<p id=\"so_10242578_10242660_3\"><sub>124) When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the\n  const and volatile type-specifiers at the outermost level of the parameter type specifications for the inner function type are\n  also ignored.</sub></p>\n</blockquote>\n", "OwnerUserId": "1235565", "LastEditorUserId": "2575399", "LastEditDate": "2016-02-18T14:18:20.047", "Id": "10242660", "Score": "8", "CreationDate": "2012-04-20T08:21:07.323", "LastActivityDate": "2016-02-18T14:18:20.047"}});