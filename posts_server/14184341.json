post_cb({"14184398": {"ParentId": "14184341", "LastEditDate": "2013-01-06T16:58:39.303", "CommentCount": "6", "CreationDate": "2013-01-06T16:53:02.200", "OwnerUserId": "129570", "LastEditorUserId": "129570", "PostTypeId": "2", "Id": "14184398", "Score": "7", "Body": "<blockquote>\n<p id=\"so_14184341_14184398_0\"><strong>Q1:</strong> What I also know from practice, is that you cannot initialize a derived object with the same prototype than it's parent constructor without explicitly defining a constructor for the derived class, is that correct?</p>\n</blockquote>\n<p>Other than the trivial case where you've defined a default constructor in the superclass, yes you are correct.</p>\n<hr>\n<blockquote>\n<p id=\"so_14184341_14184398_1\"><strong>Q2:</strong> Can anybody who thinks it's not inherited please explain that?</p>\n</blockquote>\n<p>This may be a matter of definitions of terminology.  Whilst it's clear that virtual destructors exist and work \"as expected\", we see in the C++ standard ([class.virtual]):</p>\n<blockquote>\n<p id=\"so_14184341_14184398_2\"><strong>Even though destructors are not inherited</strong>, a destructor in a derived class overrides a base class destructor declared virtual</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<hr>\n<blockquote>\n<p id=\"so_14184341_14184398_3\"><strong>Q3:</strong> So what happens when you call the constructor of a subclass with inputs? Is the \"empty constructor\" of the superclass called as well?</p>\n</blockquote>\n<p>If you don't explicitly invoke a specific superclass constructor, then the default superclass constructor will be called (assuming it's visible).</p>\n</hr></hr>", "LastActivityDate": "2013-01-06T16:58:39.303"}, "14184533": {"ParentId": "14184341", "LastEditDate": "2013-01-06T18:36:56.107", "CommentCount": "3", "CreationDate": "2013-01-06T17:07:42.813", "OwnerUserId": "399317", "LastEditorUserId": "147192", "PostTypeId": "2", "Id": "14184533", "Score": "27", "Body": "<p>Terminology, terminology...</p>\n<p>OK, what do we mean by \"Foo is inherited\"? We mean that if objects of class <code>A</code> have <code>Foo</code> in its interface, then objects of class <code>B</code> which is a subclass of <code>A</code> also have <code>Foo</code> in its interface.</p>\n<ul>\n<li><p><strong>Constructors</strong> aren't a part of objects' interface. They belong directly to classes. Classes <code>A</code> and <code>B</code> may provide completely different sets of constructors. No \"being inherited\" here.</p>\n<p>(<em>Implementation detail: each B's constructors calls some A's constructor.</em>)</p></li>\n<li><p><strong>Destructors</strong> indeed are a part of each object's interface, since the object's user is responsible for calling them (i.e. directly with <code>delete</code> or indirectly by letting an object out of scope). <strong>Each object has exactly one destructor</strong>: its own destructor, which might optionally be a virtual one. It is always its own, and it's not inherited.</p>\n<p><em>(Implementation detail: B's destructor calls A's destructor.)</em></p></li>\n</ul>\n<p>So: there's a connection between base and derived constructors and destructors, but it's not like \"they're inherited\".</p>\n<p>I hope this answers what you have in mind.</p>\n", "LastActivityDate": "2013-01-06T18:36:56.107"}, "14184341": {"CommentCount": "0", "CreationDate": "2013-01-06T16:46:06.440", "PostTypeId": "1", "AcceptedAnswerId": "14184533", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-13T16:21:16.937", "LastEditDate": "2017-05-23T11:46:53.447", "ViewCount": "50175", "FavoriteCount": "20", "Title": "C++ Constructor/Destructor inheritance", "Id": "14184341", "Score": "48", "Body": "<p><strong>EDIT : Summary of answers</strong></p>\n<p>In the following, B is a subclass of A.</p>\n<p>It's a matter of terminology; ctors and dtors are <strong>not</strong> inherited, in the sense that the ctor/dtor of B will <em>not</em> be borrowed from A's interface. A class has at least one constructor, and has exactly one destructor.</p>\n<ul>\n<li><strong>Constructors</strong>: \n\n<ul>\n<li>B does not inherit constructors from A;</li>\n<li>Unless B's ctor explicitely calls <em>one of</em> A's ctor, the default ctor from A will be called automatically <em>before</em> B's ctor body (the idea being that A needs to be initialized before B gets created).</li>\n</ul></li>\n<li><strong>Destructors</strong>:\n\n<ul>\n<li>B does not inherit A's dtor;</li>\n<li><em>After</em> it exits, B's destructor will automatically call A's destructor.</li>\n</ul></li>\n</ul>\n<p><em>Acknowledgements:</em>\nI would like to thank especially Oli Charlesworth and Kos for their answers, I set Kos' answer as the solution because it was the one I understood best.</p>\n<hr>\n<p><strong>ORIGINAL POST</strong></p>\n<p>When you search for \"C++ destructor inheritance site:stackoverflow.com\" on Google, you currently find the following posts:</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/8103805/constructor-and-destructor-inheritance\">Constructor and Destructor Inheritance</a>: two users with 30k+ reputation say that it is inherited, and that it's not</li>\n<li><a href=\"https://stackoverflow.com/questions/2198379/are-virtual-destructors-inherited\">Are virtual destructors inherited?</a>: here nothing is mentioned that would point to destructors not being inherited</li>\n<li><a href=\"https://stackoverflow.com/questions/6856488/destructors-and-inheritance-in-c\">Destructors and inheritance in C++?</a>: The comments seem to indicate the destructors are inherited</li>\n</ol>\n<p><strong>Q1:</strong> What I also know from practice, is that you cannot initialize a derived object with the same prototype than it's parent constructor without explicitely defining a constructor for the derived class, is that correct?</p>\n<hr>\n<p>Even though it's rather clear from the posts that destructors seem to be inherited, I'm still puzzled by the fact that a user with 32k reputation would say its not. I wrote a little example that should clarify everyone's mind:</p>\n<pre><code>#include &lt;cstdio&gt;\n\n/******************************/\n\n// Base class\nstruct A\n{\n    A() { printf( \"\\tInstance counter = %d (ctor)\\n\", ++instance_counter ); }\n    ~A() { printf( \"\\tInstance counter = %d (dtor)\\n\", --instance_counter ); }\n\n    static int instance_counter;\n};\n\n// Inherited class with default ctor/dtor\nclass B : public A {};\n\n// Inherited class with defined ctor/dtor\nstruct C : public A\n{\n    C() { printf(\"\\tC says hi!\\n\"); }\n    ~C() { printf(\"\\tC says bye!\\n\"); }\n};\n\n/******************************/\n\n// Initialize counter\nint A::instance_counter = 0;\n\n/******************************/\n\n// A few tests\nint main()\n{\n    printf(\"Create A\\n\"); A a;\n    printf(\"Delete A\\n\"); a.~A();\n\n    printf(\"Create B\\n\"); B b;\n    printf(\"Delete B\\n\"); b.~B();\n\n    printf(\"Create new B stored as A*\\n\"); A *a_ptr = new B();\n    printf(\"Delete previous pointer\\n\"); delete a_ptr;\n\n    printf(\"Create C\\n\"); C c;\n    printf(\"Delete C\\n\"); c.~C();\n\n}\n</code></pre>\n<p>and here is the output (compiled with g++ 4.4.3):</p>\n<pre><code>Create A\n    Instance counter = 1 (ctor)\nDelete A\n    Instance counter = 0 (dtor)\nCreate B\n    Instance counter = 1 (ctor)\nDelete B\n    Instance counter = 0 (dtor)\nCreate new B stored as A*\n    Instance counter = 1 (ctor)\nDelete previous pointer\n    Instance counter = 0 (dtor)\nCreate C\n    Instance counter = 1 (ctor)\n    C says hi!\nDelete C\n    C says bye!\n    Instance counter = 0 (dtor)  // We exit main() now\n    C says bye! \n    Instance counter = -1 (dtor)\n    Instance counter = -2 (dtor)\n    Instance counter = -3 (dtor)\n</code></pre>\n<p><strong>Q2:</strong> Can anybody who thinks it's not inherited please explain that?</p>\n<p><strong>Q3:</strong> So what happens when you call the constructor of a subclass with inputs? Is the \"empty constructor\" of the superclass called as well?</p>\n</hr></hr>", "Tags": "<c++><inheritance><constructor><destructor>", "OwnerUserId": "472610", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_14184341_14184398_2": {"section_id": 7007, "quality": 1.0, "length": 13}}, "n3337": {"so_14184341_14184398_2": {"section_id": 6753, "quality": 1.0, "length": 13}}, "n4659": {"so_14184341_14184398_2": {"section_id": 8504, "quality": 1.0, "length": 13}}}, "22720112": {"ParentId": "14184341", "CommentCount": "3", "Body": "<p>In your example, you're explicitly calling the destructor functions. This is legal (obviously, since it compiled and ran) but almost always incorrect.</p>\n<p>For dynamically-allocated objects created with <code>new</code>, the destructor will be run when the objected is removed with <code>delete</code>.</p>\n<p>For statically-allocated objects, which are created simply by declaring the object within the scope of a function, the destructor is run when the object's scope disappears. That is, when <code>main()</code> exits, the objects' destructors will be run. But you've already run the destructors for those objects by calling them manually! This is why your example's output shows the count decreasing to -3... you've run the destructors for <code>a</code>, <code>b</code>, and <code>c</code> twice.</p>\n<p>Here's the same code, annotated to show when destructors will be automatically run:</p>\n<pre><code>int main()\n{\n    printf(\"Create A\\n\"); A a;\n    printf(\"Delete A\\n\"); a.~A();\n\n    printf(\"Create B\\n\"); B b;\n    printf(\"Delete B\\n\"); b.~B();\n\n    printf(\"Create new B stored as A*\\n\"); A *a_ptr = new B();\n    printf(\"Delete previous pointer\\n\");\n    delete a_ptr;   // Implicitly calls destructor for a_ptr.  a_ptr is class B,\n       // so it would call a_ptr-&gt;~B() if it existed. Because B is an A, after\n       // its destructor is called, it calls the superclass's destructor,\n       // a_ptr-&gt;~A().\n\n    printf(\"Create C\\n\"); C c;\n    printf(\"Delete C\\n\"); c.~C();\n}\n// Function exits here at the close brace, so anything declared in its scope is\n// deallocated from the stack and their destructors run.\n// First `c` is destroyed, which calls c.~C(), then because C is a subclass of A\n// calls c.~B() (which doesn't exist, so a blank implementation is used), then\n// because B is a subclass of A calls c.~A().  This decrements the counter, but\n// the count is wrong because you already manually called c.~C(), which you\n// ordinarily shouldn't have done.\n// Then `b` is destroyed, in a similar manner.  Now the count is off by 2,\n// because you had already called b.~B().\n// Lastly `a` is destroyed, just as above.  And again, because you had already\n// called a.~A(), the count is now off by 3.\n</code></pre>\n", "OwnerUserId": "3473711", "PostTypeId": "2", "Id": "22720112", "Score": "1", "CreationDate": "2014-03-28T18:04:28.733", "LastActivityDate": "2014-03-28T18:04:28.733"}, "14186866": {"ParentId": "14184341", "CommentCount": "2", "Body": "<p>Technically, destructors ARE inherited.  But in normal circumstances, the inherited destructors are not directly used for a derived class; they're invoked because the derived class's own destructor calls them in order to destroy its own \"base class subobjects\" as a step within destroying the larger object.  And in the unusual circumstances where you do directly use a base class destructor on a derived object, it's very difficult to avoid Undefined Behavior.</p>\n<p>This example comes straight from the C++ Standard (12.4p12).</p>\n<pre><code>struct B {\n  virtual ~B() { }\n};\nstruct D : B {\n  ~D() { }\n};\n\nD D_object;\ntypedef B B_alias;\nB* B_ptr = &amp;D_object;\n\nvoid f() {\n  D_object.B::~B();              // calls B's destructor\n  B_ptr-&gt;~B();                   // calls D's destructor\n  B_ptr-&gt;~B_alias();             // calls D's destructor\n  B_ptr-&gt;B_alias::~B();          // calls B's destructor\n  B_ptr-&gt;B_alias::~B_alias();    // calls B's destructor\n}\n</code></pre>\n<p>If <code>~B</code> were not an inherited member of <code>D</code>, the first statement in <code>f</code> would be ill-formed.  As it is, it's legal C++, though extremely dangerous.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "14186866", "Score": "3", "CreationDate": "2013-01-06T21:21:15.620", "LastActivityDate": "2013-01-06T21:21:15.620"}, "14184654": {"ParentId": "14184341", "LastEditDate": "2013-01-06T17:27:43.423", "CommentCount": "0", "CreationDate": "2013-01-06T17:18:35.577", "OwnerUserId": "1896815", "LastEditorUserId": "1896815", "PostTypeId": "2", "Id": "14184654", "Score": "3", "Body": "<p><strong>Inheritance is what :</strong> mechanism of reusing and extending existing classes without modifying them, thus producing hierarchical relationships between them.</p>\n<p><strong>Inheritance</strong> is almost like embedding an object into a class.</p>\n<p>when class is inheriting a base class then the base class's constructor is <strong>called</strong> first then derived class's ,and the destructor's <strong>call</strong> is in reverse order.</p>\n<p><strong>So Why Base Class Constructor is called (called not inherited may be with parameters/default) :</strong> to guarantees that the base class is properly constructed when the constructor for the derived class is executed.</p>\n<p><strong>Now Calling of Destructor (calling not inherit) :</strong> when base object get out of scope then the destructor is called on its own.so there is np issue of inheritance of destructor.</p>\n<p><strong>now your questions:</strong></p>\n<p><strong>ans 1 -</strong> yes you are correct for first question.<br>\n<strong>ans 2</strong> - so destructor is called not inherited after the scope of object goes out.<br>\n&amp; <strong>ans 3 -</strong>  if in derived class you are giving the call with parameters then only that constructor would get called , with it no other constructor would get called.\n<br>\nthere is no point of issuse that 2 constructor of same object would get called on object creation,as\nconstructor called at the creation of an object. It prepares the new object for use.so there is no logic of preparing the object twice with different constructors.</br></br></br></p>\n", "LastActivityDate": "2013-01-06T17:27:43.423"}, "14184575": {"ParentId": "14184341", "CommentCount": "4", "Body": "<p>Destructors are <strong>not</strong> inherited. If a class doesn't define one, the compiler <strong>generates</strong> one. For trivial cases that destructor just calls the base class' destructor, and often that means that there is no explicit code for its destructor (which imitates inheritance). But if a class has members with destructors, the generated destructor calls destructors for those members before calling the base class' destructor. That's something that an inherited function would not do.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "14184575", "Score": "4", "CreationDate": "2013-01-06T17:11:03.533", "LastActivityDate": "2013-01-06T17:11:03.533"}});