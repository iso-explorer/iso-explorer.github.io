post_cb({"bq_ids": {"n4140": {"so_23875523_23875561_1": {"length": 29, "quality": 1.0, "section_id": 438}, "so_23875523_23875561_3": {"length": 15, "quality": 1.0, "section_id": 438}, "so_23875523_23875561_4": {"length": 5, "quality": 1.0, "section_id": 438}, "so_23875523_23875561_5": {"length": 11, "quality": 0.7333333333333333, "section_id": 438}, "so_23875523_23875561_2": {"length": 13, "quality": 1.0, "section_id": 438}, "so_23875523_23875561_0": {"length": 6, "quality": 1.0, "section_id": 438}}, "n3337": {"so_23875523_23875561_1": {"length": 29, "quality": 1.0, "section_id": 429}, "so_23875523_23875561_2": {"length": 13, "quality": 1.0, "section_id": 429}, "so_23875523_23875561_4": {"length": 5, "quality": 1.0, "section_id": 429}, "so_23875523_23875561_5": {"length": 11, "quality": 0.7333333333333333, "section_id": 429}, "so_23875523_23875561_3": {"length": 15, "quality": 1.0, "section_id": 429}, "so_23875523_23875561_0": {"length": 6, "quality": 1.0, "section_id": 429}}, "n4659": {"so_23875523_23875561_1": {"length": 29, "quality": 1.0, "section_id": 458}, "so_23875523_23875561_2": {"length": 13, "quality": 1.0, "section_id": 458}, "so_23875523_23875561_4": {"length": 5, "quality": 1.0, "section_id": 458}, "so_23875523_23875561_5": {"length": 11, "quality": 0.7333333333333333, "section_id": 458}, "so_23875523_23875561_3": {"length": 15, "quality": 1.0, "section_id": 458}, "so_23875523_23875561_0": {"length": 6, "quality": 1.0, "section_id": 458}}}, "23875523": {"ViewCount": "128", "Body": "<pre><code>Vector::Vector(const Vector&amp; a) : elem{new double[sz]}, sz{a.sz}\n{\n  for(int i = 0; i!= sz; ++i)\n      elem[i] = a.elem[i];\n}\n</code></pre>\n<p>The interesting part here is that\n    elem{new double[sz]}\ncomes before</p>\n<pre><code>sz{a.sz}\n</code></pre>\n<p>so that is, before</p>\n<pre><code>sz\n</code></pre>\n<p>is initialized.</p>\n<p>But it doesn't throw any error, right?</p>\n<p>Can someone tell me something about the corresponding part in the standard, a deeper insight in the inner workings, or how in any other way this is regulated?</p>\n", "AcceptedAnswerId": "23875561", "Title": "copy constructor initialization", "CreationDate": "2014-05-26T17:58:28.537", "Id": "23875523", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-05-26T18:08:50.387", "Score": "1", "OwnerUserId": "3547831", "Tags": "<c++><c++11><copy-constructor>", "AnswerCount": "1"}, "23875561": {"Id": "23875561", "PostTypeId": "2", "Body": "<p>The important thing about initialization list is that members are not initialized in order of their appearance in initialization list but in order of declaration in class.</p>\n<p>C++ Standard n3337 <strong>\u00a7</strong> 12.6.2/10 Initializing bases and members</p>\n<blockquote>\n<p id=\"so_23875523_23875561_0\">In a non-delegating constructor, initialization proceeds in the\n  following order:</p>\n<p id=\"so_23875523_23875561_1\">\u2014 First, and only for the constructor of the most derived class (1.8),\n  virtual base classes are initialized in the order they appear on a\n  depth-first left-to-right traversal of the directed acyclic graph of\n  base classes, where \u201cleft-to-right\u201d is the order of appearance of the\n  base classes in the derived class base-specifier-list.</p>\n<p id=\"so_23875523_23875561_2\">\u2014 Then, direct base classes are initialized in declaration order as\n  they appear in the base-specifier-list (regardless of the order of the\n  mem-initializers).</p>\n<p id=\"so_23875523_23875561_3\">\u2014 Then, non-static data members are initialized in the order they were\n  declared in the class definition (again regardless of the order of the\n  mem-initializers).</p>\n<p id=\"so_23875523_23875561_4\">\u2014 Finally, the compound-statement of the constructor body is executed.</p>\n<p id=\"so_23875523_23875561_5\">[ Note: The declaration order is mandated to ensure that base and\n  member subobjects are destroyed in the reverse order of\n  initialization. \u2014 end note ]</p>\n</blockquote>\n<p>( now I will repeat my other answer but I think this won't hurt anyone) This is important. Remember this to avoid errors like </p>\n<pre><code>/* trying to allocate (possibly) very large block of memory\n   as a result of initializing a vector with\n   uninitialized integer: std::vector&lt;int&gt; v( N)\n*/\nclass SearchEngine {\n    std::vector&lt;int&gt; v;\n    int N;\n    explicit SearchEngine( std::vector&lt;int&gt; const&amp; keys)\n                  : N( keys.size()), v( N), {\n</code></pre>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2014-05-26T18:08:50.387", "Score": "9", "CreationDate": "2014-05-26T18:01:11.953", "ParentId": "23875523", "CommentCount": "2", "OwnerUserId": "1141471", "LastEditDate": "2014-05-26T18:08:50.387"}});