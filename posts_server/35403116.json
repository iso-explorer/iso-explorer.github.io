post_cb({"bq_ids": {"n4140": {"so_35403116_35403116_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 340}}, "n3337": {"so_35403116_35403116_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 330}}, "n4659": {"so_35403116_35403116_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 349}}}, "35403175": {"Id": "35403175", "PostTypeId": "2", "Body": "<pre><code>std::initializer_list&lt;std::size_t&gt; list = { Object&lt;A1&gt;::getIndex(), Object&lt;A2&gt;::getIndex()... } );\n</code></pre>\n<p>when you put <code>...</code> after a function call, it looks for parameter packs inside of that to expand, but <code>A2</code> isn't a parameter pack, <code>Ax</code> is.</p>\n<p>Why even have the A1 and A2?</p>\n<pre><code>template &lt;typename...Ax&gt;\nFoo createFoo() {\n</code></pre>\n<p>Then you can just say <code>Object&lt;Ax&gt;::getIndex()...</code></p>\n<p>Or if you must enforce a certain number of parameters, then:</p>\n<pre><code>std::initializer_list&lt;std::size_t&gt; list = { Object&lt;A1&gt;::getIndex(),Object&lt;A2&gt;::getIndex(), Object&lt;Ax&gt;::getIndex()... } );\n</code></pre>\n<p>The <code>...</code> expansion accepts an empty parameter pack, so this will work for 2 or more types.</p>\n", "LastEditorUserId": "493106", "LastActivityDate": "2016-02-15T06:59:30.737", "Score": "4", "CreationDate": "2016-02-15T06:55:21.220", "ParentId": "35403116", "CommentCount": "4", "OwnerUserId": "493106", "LastEditDate": "2016-02-15T06:59:30.737"}, "35403116": {"ViewCount": "221", "Body": "<p>I have a function:</p>\n<pre><code>template &lt;typename A&gt;\nFoo createFoo() {\n\n    std::initializer_list&lt;std::size_t&gt; list = { Object&lt;A&gt;::getIndex() } );\n    return Foo(list);\n}\n</code></pre>\n<p>It is invoked like:</p>\n<pre><code>Foo foo = createFoo&lt;Bar&gt;();\n</code></pre>\n<p>It works correct, returning me an object of class <code>Foo</code>.</p>\n<p>Is it possible to write a specialized function in case there're more than one parameter argument, something like this?</p>\n<pre><code>template &lt;typename A1, typename A2, typename...Ax&gt;\nFoo createFoo() {\n\n    std::initializer_list&lt;std::size_t&gt; list = { Object&lt;A1&gt;::getIndex(), Object&lt;A2&gt;::getIndex()... } );\n    return Foo(list);\n}\n</code></pre>\n<p>So that I invoke it this way:</p>\n<pre><code>Foo foo = createFoo&lt;Bar, Fred, Wilma&gt;();\n</code></pre>\n<p>It gives me an error:</p>\n<blockquote>\n<p id=\"so_35403116_35403116_0\">error: expansion pattern \u2018Object::getIndex()\u2019 contains no argument packs</p>\n</blockquote>\n<p>and points to the \"...\" part of the code.</p>\n<p>I don't want to have a single function declared as</p>\n<pre><code>template &lt;typename ...A&gt;\nFoo createFoo() {\n\n    std::initializer_list&lt;std::size_t&gt; list = { Object&lt;A&gt;::getIndex() } );\n    return Foo(list);\n}\n</code></pre>\n<p>because, let's suppose the <code>Foo</code> class has optimized logics in case there's only one <code>std::size_t</code> item in the initializer_list and I want to utilize that in my API.</p>\n<p>I use GCC version 4.8.4 with <code>-std=c++11</code> option</p>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "35403175", "Title": "C++11 parameters pack overload", "CreationDate": "2016-02-15T06:50:22.093", "Id": "35403116", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-02-15T07:06:50.367", "Score": "3", "OwnerUserId": "194547", "Tags": "<c++><c++11>", "AnswerCount": "1"}});