post_cb({"22243721": {"CommentCount": "0", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "2485710", "CreationDate": "2014-03-07T07:05:39.877", "LastActivityDate": "2014-03-07T07:36:24.363", "Title": "What it is going to be evaluated in a boolean expression?", "AcceptedAnswerId": "22243785", "LastEditDate": "2014-03-07T07:15:03.100", "Id": "22243721", "Score": "-1", "Body": "<p>assuming that I have the following variables</p>\n<pre><code>bool b;\nint i;\nT* ptr;\n</code></pre>\n<p>when I put <code>b</code>, <code>i</code> or <code>ptr</code>, or whatever other variables I have, in a boolean expression like</p>\n<pre><code>var1 &amp;&amp; var2\n</code></pre>\n<p>What is going to be evaluated to solve this expression ? The C++11 standard says something about what is the part from <code>var1</code> and <code>var2</code> that contributes to determine the boolean result ? There are implicit casting ?</p>\n<p>It's not clear to me what the standard says about this.</p>\n<hr>\n<p>EDIT</p>\n<p>I'm interested in how a generic <code>T</code> type is converted into a <code>bool</code> and how a boolean expression is solved according to the standard </p>\n</hr>", "Tags": "<c++><c++11><boolean-expression>", "OwnerUserId": "2485710", "AnswerCount": "2"}, "22243757": {"ParentId": "22243721", "PostTypeId": "2", "CommentCount": "26", "CreationDate": "2014-03-07T07:08:03.500", "Score": "4", "LastEditorUserId": "207421", "LastEditDate": "2014-03-07T07:36:24.363", "Id": "22243757", "OwnerUserId": "207421", "Body": "<p>It's not clear to me what you're asking about. A variable is true in C and C++ if it is non-zero. The &amp;&amp; operator only evaluates the right operand if the left operand is true. The truth value of an instance of a class T doesn't exist unless there is a conversion function. This is all in the standard.</p>\n", "LastActivityDate": "2014-03-07T07:36:24.363"}, "22243785": {"ParentId": "22243721", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2014-03-07T07:09:23.907", "Score": "3", "LastEditorUserId": "481267", "LastEditDate": "2014-03-07T07:24:12.660", "Id": "22243785", "OwnerUserId": "481267", "Body": "<p>\u00a75.14/1</p>\n<blockquote>\n<p id=\"so_22243721_22243785_0\">The <code>&amp;&amp;</code> operator groups left-to-right. The operands are both contextually converted to type <code>bool</code> (Clause 4)... Unlike <code>&amp;</code>, <code>&amp;&amp;</code> guarantees left-to-right\n  evaluation: the second operand is not evaluated if the first operand is <code>false</code>.</p>\n</blockquote>\n<p>\u00a74/2</p>\n<blockquote>\n<p id=\"so_22243721_22243785_1\">[<em>Note:</em> expressions with a given type will be implicitly converted to other types in several contexts:</p>\n<p id=\"so_22243721_22243785_2\">\u2014 When used as operands of operators. The operator\u2019s requirements for its operands dictate the destination type (Clause 5).</p>\n<p id=\"so_22243721_22243785_3\">...</p>\n</blockquote>\n<p>This is about as clear as the standard gets. First <code>var1</code> will be implicitly converted to <code>bool</code>, and then, if it is <code>true</code>, <code>var2</code> will be implicitly converted to <code>bool</code>.</p>\n<p><strong>Edit:</strong> I'll quote also \u00a74.12/1</p>\n<blockquote>\n<p id=\"so_22243721_22243785_4\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a\n  prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code>. A prvalue of type <code>std::nullptr_t</code> can be converted to a prvalue of\n  type <code>bool</code>; the resulting value is <code>false</code>.</p>\n</blockquote>\n<p><strong>Edit 2:</strong> For some arbitrary type <code>T</code>, see \u00a74/3,</p>\n<blockquote>\n<p id=\"so_22243721_22243785_5\">... Certain language constructs require that an expression be\n  converted to a Boolean value. An expression <code>e</code> appearing in such a context is said to be <em>contextually\n  converted to <code>bool</code></em> and is well-formed if and only if the declaration <code>bool t(e);</code> is well-formed, for some\n  invented temporary variable <code>t</code> (8.5).</p>\n</blockquote>\n<p>For the meaning of this initialization, see \u00a78.5/16</p>\n<blockquote>\n<p id=\"so_22243721_22243785_6\">\u2014 Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered.\n  The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through\n  overload resolution (13.3). The user-defined conversion so selected is called to convert the initializer\n  expression into the object being initialized. If the conversion cannot be done or is ambiguous, the\n  initialization is ill-formed.</p>\n</blockquote>\n<p>There is even more detail in \u00a713.3.1.5 and \u00a713.3, but you will be reading all night and then some. But the bottom line is that if <code>T</code> is a class type, then there has to be a conversion function. The best practice would be to define <code>explicit operator bool</code> for the class. However you could also do something like <code>operator void*</code>, which is what <code>std::ios</code> and its derived classes define, because <code>void*</code> can then be converted to <code>bool</code> in a standard conversion sequence. (This should be regarded as a deprecated idiom in C++11.)</p>\n", "LastActivityDate": "2014-03-07T07:24:12.660"}, "bq_ids": {"n4140": {"so_22243721_22243785_4": {"section_id": 44, "quality": 1.0, "length": 39}, "so_22243721_22243785_0": {"section_id": 6163, "quality": 0.8636363636363636, "length": 19}, "so_22243721_22243785_2": {"section_id": 1, "quality": 0.9166666666666666, "length": 11}, "so_22243721_22243785_1": {"section_id": 1, "quality": 0.9090909090909091, "length": 10}, "so_22243721_22243785_5": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}, "so_22243721_22243785_6": {"section_id": 3296, "quality": 0.9, "length": 36}}, "n3337": {"so_22243721_22243785_4": {"section_id": 41, "quality": 1.0, "length": 39}, "so_22243721_22243785_0": {"section_id": 5924, "quality": 0.9090909090909091, "length": 20}, "so_22243721_22243785_2": {"section_id": 1, "quality": 0.9166666666666666, "length": 11}, "so_22243721_22243785_1": {"section_id": 1, "quality": 0.9090909090909091, "length": 10}, "so_22243721_22243785_5": {"section_id": 2, "quality": 0.9583333333333334, "length": 23}, "so_22243721_22243785_6": {"section_id": 3166, "quality": 0.9, "length": 36}}, "n4659": {"so_22243721_22243785_4": {"section_id": 45, "quality": 1.0, "length": 39}, "so_22243721_22243785_0": {"section_id": 7660, "quality": 0.8636363636363636, "length": 19}, "so_22243721_22243785_2": {"section_id": 1, "quality": 0.9166666666666666, "length": 11}, "so_22243721_22243785_1": {"section_id": 1, "quality": 0.8181818181818182, "length": 9}, "so_22243721_22243785_5": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}, "so_22243721_22243785_6": {"section_id": 4058, "quality": 0.9, "length": 36}}}});