post_cb({"12732042": {"CommentCount": "7", "ViewCount": "1502", "CreationDate": "2012-10-04T16:52:45.453", "LastActivityDate": "2012-10-04T17:27:10.710", "Title": "\"Explicit specialization of std::iterator_traits<char *> after instantiation\" (CLang)", "AcceptedAnswerId": "12732136", "PostTypeId": "1", "Id": "12732042", "Score": "1", "Body": "<p>I've got some code that compiles fine under MSVC (or so say the Windows developers who sent me it), but gives an error under CLang. Having looked around I've found that CLang is indeed more strict about resolving template specializations, but I'm not sure where I should put the specializations in my case. Basically one of my files has a struct like this:</p>\n<pre><code>template&lt;&gt;\nstruct iterator_traits&lt; char * &gt;   // error is here\n{\n    typedef random_access_iterator_tag iterator_category;\n    typedef char value_type;\n    typedef ptrdiff_t difference_type;\n    typedef difference_type distance_type;\n    typedef char * pointer;\n    typedef char &amp; reference;\n};\n</code></pre>\n<p>This is within a <code>namespace std</code> block. The error message is:</p>\n<pre><code>Explicit specialization of 'std::iterator_traits&lt;char *&gt;' after instantiation\n</code></pre>\n<p>Another part of the same error message (viewed by 'expanding' the error message in Xcode) says <code>Implicit instantiation first required here</code>, and clicking on that takes me to <code>stl_iterator.h</code>, specifically this line (line 642):</p>\n<pre><code>typedef typename iterator_traits&lt;_Iterator&gt;::iterator_category\n                                                         iterator_category;\n</code></pre>\n<p>Does anyone know what the correct thing to do would be in this case? I've seen examples involving classes but never one involving a struct.</p>\n", "Tags": "<c++><xcode><osx><clang><template-specialization>", "OwnerUserId": "49128", "AnswerCount": "1"}, "12732136": {"ParentId": "12732042", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The compiler is complaining that you're trying to specialize a template after instantiating the generic template -- by that point in time, the compiler has already used the generic template for the instantiation, and it can't go back and use your specialization instead.  In other words, something like this:</p>\n<pre><code>template &lt;typename T&gt;\nstruct X\n{\n    // Generic implementation\n};\n\n// Instantiate template by using it in any way\nX&lt;int&gt; foo;\n\ntemplate&lt;&gt;\nstruct X&lt;int&gt;\n{\n    // Specialization implementation for int\n};\n</code></pre>\n<p>The fix is to define the specialization <em>before</em> it's instantiated, so in this example, you'd move the <code>X&lt;int&gt;</code> specialization to before where <code>X&lt;int&gt;</code> is used.</p>\n<p>Note that the STL already defines specializations of <code>std::iterator_trait</code> for pointer types, so there's no need to define your own specialization here for <code>char*</code>.  You'd typically only do that for user-defined iterator types which are not pointers.  See \u00a724.3.1/2 of the C++03 standard:</p>\n<blockquote>\n<p id=\"so_12732042_12732136_0\">[The template <code>iterator_traits&lt;Iterator&gt;</code>] is specialized for pointers as</p>\n<pre><code>template&lt;class T&gt; struct iterator_traits&lt;T*&gt; {\n  typedef ptrdiff_t difference_type;\n  typedef T value_type;\n  typedef T* pointer;\n  typedef T&amp; reference;\n  typedef random_access_iterator_tag iterator_category;\n};\n</code></pre>\n<p id=\"so_12732042_12732136_1\">and for pointers to <code>const</code> as</p>\n<pre><code>template&lt;class T&gt; struct iterator_traits&lt;const T*&gt; {\n  typedef ptrdiff_t difference_type;\n  typedef T value_type;\n  typedef const T* pointer;\n  typedef const T&amp; reference;\n  typedef random_access_iterator_tag iterator_category;\n};\n</code></pre>\n</blockquote>\n<p>So there's no point to providing your own <code>std::iterator_traits&lt;char*&gt;</code> specialization.  Since <code>char*</code> is not a user-defined type, it's also undefined behavior according to the standard.  \u00a717.4.3.1/1 says:</p>\n<blockquote>\n<p id=\"so_12732042_12732136_2\">It is undefined for a C + + program to add declarations or definitions to namespace std or namespaces\n  within namespace <code>std</code> unless otherwise specified. A program may add template specializations for any\n  standard library template to namespace <code>std</code>. Such a specialization (complete or partial) of a standard\n  library template results in undefined behavior unless the declaration depends on a user-defined name of\n  external linkage and unless the specialization meets the standard library requirements for the original template.<sup>163)</sup></p>\n<p id=\"so_12732042_12732136_3\">163) Any library code that instantiates other library templates must be prepared to work adequately with any user-supplied specialization\n  that meets the minimum requirements of the Standard</p>\n</blockquote>\n", "OwnerUserId": "9530", "LastEditorUserId": "743214", "LastEditDate": "2012-10-04T17:27:10.710", "Id": "12732136", "Score": "7", "CreationDate": "2012-10-04T16:59:20.710", "LastActivityDate": "2012-10-04T17:27:10.710"}, "bq_ids": {"n4140": {"so_12732042_12732136_2": {"section_id": 6299, "quality": 0.5853658536585366, "length": 24}, "so_12732042_12732136_3": {"section_id": 6299, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_12732042_12732136_2": {"section_id": 6056, "quality": 0.5853658536585366, "length": 24}, "so_12732042_12732136_3": {"section_id": 6056, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_12732042_12732136_2": {"section_id": 7808, "quality": 0.5853658536585366, "length": 24}, "so_12732042_12732136_3": {"section_id": 7808, "quality": 0.8333333333333334, "length": 15}}}});