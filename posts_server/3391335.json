post_cb({"3391335": {"CommentCount": "4", "AcceptedAnswerId": "3392172", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-08-02T20:06:16.347", "LastActivityDate": "2015-07-08T22:41:48.257", "LastEditDate": "2017-05-23T10:27:42.873", "ViewCount": "606", "FavoriteCount": "3", "Title": "Where in the C++ Standard does it say ::delete can change lvalues?", "Id": "3391335", "Score": "8", "Body": "<p>I ran into my first compiler that changes the lvalue passed to ::delete, but doesn't zero out the lvalue. That is the following is true:</p>\n<pre><code> Foo * p = new Foo();\n Foo * q = p;\n assert(p != 0);\n assert(p == q);\n ::delete p;\n assert(p != q);\n assert(p != 0);\n</code></pre>\n<p>Note that p is not zero after the delete operation, and it has changed from it's old value. A coworker told me that this is not unusual in his experience having worked with some mainframe C++ compilers that would change p to 0xFFFFFFFF, as well as other compilers that would change p to 0.</p>\n<p>Where in the C++ Standard does it say that a compiler is allowed to do this?</p>\n<p>Searching through StackOverflow, I found this question: <a href=\"https://stackoverflow.com/questions/704466/why-doesnt-delete-set-the-pointer-to-null\">Why doesn\u2019t delete set the pointer to NULL?</a> which had an answer that referred to <a href=\"http://www2.research.att.com/~bs/bs_faq2.html#delete-zero\" rel=\"nofollow noreferrer\">Bjarne Stroustrup's response</a> that includes the statement: </p>\n<blockquote>\n<p id=\"so_3391335_3391335_0\">C++ explicitly allows an implementation of delete to zero out an lvalue operand, and I had hoped that implementations would do that, but that idea doesn't seem to have become popular with implementers.</p>\n</blockquote>\n<p>I've read and re-read section 5.3.5 and 12.5 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">final committee draft C++0x standard</a>, but I'm not seeing the \"explicit\" part. Am I just looking in the wrong sections of the standard? Or is there a chain of logic that is in the sections but I'm just not connecting together properly.</p>\n<p>I don't have my copy of the Annotated C++ Reference Manual anymore. Was it in the ARM that a compiler could do this?</p>\n<p>[Edit: Correcting the section reference from 3.5.3 to 5.3.5. I'm also adding an interesting paradox as a counterpoint to Henk's assertion that p is undefined after delete.]</p>\n<p>There is an interesting paradox if p is initialized to null.</p>\n<pre><code> Foo * p = 0;\n Foo * q = p;\n assert(p == 0);\n assert(p == q);\n ::delete p;\n assert(p == q);\n assert(p == 0);\n</code></pre>\n<p>In this case though, the behavior is well documented. When delete gets a null pointer, it is suppose to do nothing, so p remains unchanged.</p>\n", "Tags": "<c++><pointers><c++11><lvalue><delete-operator>", "OwnerUserId": "56987", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_3391335_3392172_1": {"section_id": 7183, "quality": 0.8055555555555556, "length": 29}, "so_3391335_3392172_2": {"section_id": 6111, "quality": 0.8285714285714286, "length": 29}, "so_3391335_3392172_0": {"section_id": 6111, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_3391335_3392172_1": {"section_id": 6927, "quality": 0.8611111111111112, "length": 31}, "so_3391335_3392172_2": {"section_id": 5877, "quality": 0.8285714285714286, "length": 29}, "so_3391335_3392172_0": {"section_id": 5877, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_3391335_3392172_2": {"section_id": 7608, "quality": 0.7142857142857143, "length": 25}, "so_3391335_3392172_0": {"section_id": 7608, "quality": 0.7142857142857143, "length": 5}}}, "3392172": {"ParentId": "3391335", "LastEditDate": "2010-08-02T22:11:45.640", "CommentCount": "4", "CreationDate": "2010-08-02T22:05:13.267", "OwnerUserId": "36565", "LastEditorUserId": "36565", "PostTypeId": "2", "Id": "3392172", "Score": "8", "Body": "<p>It might not be so explicit. In 5.3.5/7 it says that the delete expression will call a deallocator function. Then in 3.7.3.2/4 it says that using a pointer that has been deallocated is undefined. Since the value of the pointer cannot be used after the deallocation, then whether the pointer keeps the value or the value is changed by the implementation does not make a difference.</p>\n<p>5.3.5/7</p>\n<blockquote>\n<p id=\"so_3391335_3392172_0\"><strong>The delete-expression will call a deallocation function</strong> (3.7.3.2).</p>\n</blockquote>\n<p>3.7.3.2/4</p>\n<blockquote>\n<p id=\"so_3391335_3392172_1\">If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, render- ing invalid all pointers referring to any part of the deallocated storage. <strong>The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined</strong>.</p>\n</blockquote>\n<p>The references are from the current standard. In the upcoming standard 5.3.5/7 has been reworded:</p>\n<p>C++0x FD 5.3.5/7</p>\n<blockquote>\n<p id=\"so_3391335_3392172_2\">If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will call a deallocation function (3.7.4.2). Otherwise, it is unspecified whether the deallocation function will be called. [ Note: The deallocation function is called regardless of whether the destructor for the object or some element of the array throws an exception. \u2014 end note ]</p>\n</blockquote>\n", "LastActivityDate": "2010-08-02T22:11:45.640"}});