post_cb({"bq_ids": {"n4140": {"so_23498746_23502492_1": {"length": 51, "quality": 0.9107142857142857, "section_id": 6981}, "so_23498746_23502492_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5795}, "so_23498746_23499592_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5791}, "so_23498746_23502492_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 5795}, "so_23498746_23499592_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 6981}}, "n3337": {"so_23498746_23502492_1": {"length": 51, "quality": 0.9107142857142857, "section_id": 6727}, "so_23498746_23502492_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 5568}, "so_23498746_23499592_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 5564}, "so_23498746_23502492_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 5568}, "so_23498746_23499592_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 6727}}, "n4659": {"so_23498746_23502492_1": {"length": 51, "quality": 0.9107142857142857, "section_id": 8479}, "so_23498746_23502492_2": {"length": 37, "quality": 0.9487179487179487, "section_id": 7254}, "so_23498746_23499592_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7248}, "so_23498746_23502492_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 7254}, "so_23498746_23499592_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 8479}}}, "23537877": {"Id": "23537877", "PostTypeId": "2", "Body": "<p>thank you guys for quick response!!! I modified my code a bit with template trick so that actual object's data are the same but template types are different - works perfectly!!! for those who interested, now it looks something like this (T must not equal zero):</p>\n<pre><code>template&lt;int T&gt; struct A { enum{ val = T &lt; 0 ? -T : T}; };\nstruct B1 : A&lt;1&gt; { union { A&lt;-1&gt; a;}; };\n</code></pre>\n<p>thank you</p>\n", "LastActivityDate": "2014-05-08T09:30:52.147", "CommentCount": "0", "CreationDate": "2014-05-08T09:30:52.147", "ParentId": "23498746", "Score": "0", "OwnerUserId": "3608817"}, "23499592": {"Id": "23499592", "PostTypeId": "2", "Body": "<p>I think that there will be helpful two quotes from the C++ Standard. The first one defines what is subobject.</p>\n<blockquote>\n<p id=\"so_23498746_23499592_0\">2 Objects can contain other objects, called subobjects. A subobject\n  can be a member subobject (9.2), a base class subobject (Clause 10),\n  or an array element.</p>\n</blockquote>\n<p>The second one says that two subobjects of the same type may not have the same address</p>\n<blockquote>\n<p id=\"so_23498746_23499592_1\">A base class subobject may be of zero size (Clause 9); however, two\n  subobjects that have the same class type and that belong to the same\n  most derived object must not be allocated at the same address (5.10).\n  \u2014end note ]</p>\n</blockquote>\n<p>So in this class definition</p>\n<pre><code>struct B1 : A { union { A a;}; };\n</code></pre>\n<p>there are two subobjects of type A: base class subobject and member subobject a.</p>\n<p>Also it is important to add that every member of every anonymous union is a member of the class containing the anonymous unions.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-05-06T16:08:15.427", "Score": "2", "CreationDate": "2014-05-06T16:02:04.030", "ParentId": "23498746", "CommentCount": "11", "OwnerUserId": "2877241", "LastEditDate": "2014-05-06T16:08:15.427"}, "23498746": {"ViewCount": "555", "Body": "<p>Compiling my code as C++11 with <code>gcc 4.8.2</code> and <code>llvm/clang 3.4</code> on fedora-linux, I got strange results that I couldn't really explain...\nhere is a similar program fedora.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A {};\nstruct C {};\nstruct B1 : A { union { A a;}; };\nstruct B2 : A { union { C c;}; };\n\nint main()\n{\n    cout &lt;&lt; sizeof(B1) &lt;&lt; \" \" &lt;&lt; sizeof(B2) &lt;&lt; endl;\n}\n</code></pre>\n<p><code>sizeof(B1) = 2</code> and <code>sizeof(B2) = 1</code></p>\n<p>But why are the sizes different? Actually I have an idea \"why\", but I want to find the exact explanation or C++ rule.</p>\n", "Title": "Empty struct and anonymous union weird case", "CreationDate": "2014-05-06T15:22:52.313", "LastActivityDate": "2014-05-08T09:30:52.147", "CommentCount": "13", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-05-06T19:29:22.860", "LastEditorUserId": "3204551", "Id": "23498746", "Score": "14", "OwnerUserId": "3608817", "Tags": "<c++><struct><sizeof><unions>", "AnswerCount": "4"}, "23499281": {"Id": "23499281", "PostTypeId": "2", "Body": "<p>The <code>B1</code> child has both a parent and sub-object of type <code>A</code>. Two distinct objects of the same type cannot exist at the same address, and the union separately contains an additional <code>A</code> to the parent <code>A</code>.</p>\n<p>With <code>B2</code>, the empty base optimization allows the empty <code>A</code> parent and <code>C</code> member to share the single address of the child.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2014-05-06T15:57:24.170", "Score": "6", "CreationDate": "2014-05-06T15:47:57.537", "ParentId": "23498746", "CommentCount": "3", "OwnerUserId": "251738", "LastEditDate": "2014-05-06T15:57:24.170"}, "23502492": {"Id": "23502492", "PostTypeId": "2", "Body": "<p>The C++11 standard can be interpreted to allow size 1 for both examples:</p>\n<blockquote>\n<h3>1.8 The C++ object model \u00a76:</h3>\n<p id=\"so_23498746_23502492_0\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two distinct objects that are neither bit-fields nor base class subobjects of zero size shall have distinct addresses.</p>\n</blockquote>\n<p>There's at least one non-normative notice disallowing it for case 1, but it is non-normative:</p>\n<blockquote>\n<h3>10 Derived classes \u00a78:</h3>\n<p id=\"so_23498746_23502492_1\">[ Note: A base class subobject might have a layout (3.7) different from the layout of a most derived object of the same type. A base class subobject might have a polymorphic behavior (12.7) different from the polymorphic behavior of a most derived object of the same type. A base class subobject may be of zero size (Clause 9); however, two subobjects that have the same class type and that belong to the same most derived object must not be allocated at the same address (5.10). \u2014end note ]</p>\n</blockquote>\n<p>The latest publicly available draft (n3797 dated 2013-10-13) though disallows the first example to have size 1:</p>\n<blockquote>\n<h3>1.8 The C++ object model \u00a76:</h3>\n<p id=\"so_23498746_23502492_2\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses.</p>\n</blockquote>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2014-05-06T18:57:43.617", "Score": "1", "CreationDate": "2014-05-06T18:41:43.687", "ParentId": "23498746", "CommentCount": "0", "OwnerUserId": "3204551", "LastEditDate": "2014-05-06T18:57:43.617"}});