post_cb({"35872378": {"ParentId": "35872045", "CommentCount": "0", "Body": "<p>Clang is correct here, this is a gcc bug. According to <a href=\"http://eel.is/c++draft/basic.scope.class#1\" rel=\"noreferrer\">[basic.scope.class]</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_35872045_35872378_0\">The potential scope of a name declared in a class consists not only of the declarative region following the\n  name\u2019s point of declaration, but also of all function bodies, default arguments, <strong>exception-specifications</strong>, and <em>brace-or-equal-initializers</em> of non-static data members in that class (including such things in nested\n  classes).</p>\n</blockquote>\n<p>The scope of <code>m_elements</code> includes the <em>noexcept-specification</em> for <code>size()</code>.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "35872378", "Score": "5", "CreationDate": "2016-03-08T16:13:12.693", "LastActivityDate": "2016-03-08T16:13:12.693"}, "35872045": {"CommentCount": "1", "ViewCount": "196", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-03-08T15:58:28.527", "LastActivityDate": "2016-03-08T19:01:12.520", "Title": "Can we refer to member variables in a noexcept specification?", "FavoriteCount": "3", "LastEditDate": "2016-03-08T19:01:12.520", "Id": "35872045", "Score": "7", "Body": "<p>Please consider the following code snippet:</p>\n<pre><code>template&lt;class Tuple&gt;\nclass vector\n{\npublic:\n    typename Tuple::size_type size() const noexcept(noexcept(m_elements.size())) {\n        return m_elements.size();\n    }\n\nprivate:\n    Tuple m_elements;\n};\n\nclass tuple\n{\npublic:\n    using size_type = std::size_t;\n\n    size_type size() const { return 0; }\n    size_type size() noexcept { return 0; }\n};    \n\nint main()\n{\n    vector&lt;tuple&gt; x;\n    static_assert(noexcept(x.size()), \"x.size() might throw\");\n\n    return 0;\n}\n</code></pre>\n<p>Is the use of the member variable <code>m_elements</code> inside the <code>noexcept</code> specifier legal? <a href=\"http://coliru.stacked-crooked.com/view?id=7d2a18fa7e70f9e0\" rel=\"nofollow\">GCC 5.2 (C++17) yields the compiler error</a> <em><code>m_elements</code> was not declared in this scope</em>. while <a href=\"http://coliru.stacked-crooked.com/view?id=13b213cf8de3b9b1\" rel=\"nofollow\">clang 3.6 (C++17) compiles without any error</a>.</p>\n<p>Both compilers yield no error if I use <code>noexcept(std::declval&lt;Tuple const&amp;&gt;().size())</code> instead. However, as you can see, I've created a simple example class <code>tuple</code> where it's crucial whether or not <code>Tuple</code> has qualified overloads of <code>size</code>.</p>\n<p>From my point of view, it's more intuitive to write <code>noexcept(m_elements.size())</code> cause it's exactly the call in the function body and it takes into account that the <code>size</code> method of <code>vector</code> is <code>const</code> qualified (which makes <code>m_elements</code> a const object in the scope of the function).</p>\n<p>So, what's the legal usage? If both are equivalent, which should I use? Should I use <code>noexcept</code> qualifiers at all in this scenario? The problem is that whether or not the <code>vector</code> functions will throw depends in all most every case on <code>Tuple</code>.</p>\n", "Tags": "<c++><language-lawyer><c++14><c++1z><noexcept>", "OwnerUserId": "547231", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35872045_35872378_0": {"section_id": 7070, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_35872045_35872378_0": {"section_id": 6814, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_35872045_35872378_0": {"section_id": 8567, "quality": 0.9354838709677419, "length": 29}}}});