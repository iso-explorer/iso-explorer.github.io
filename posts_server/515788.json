post_cb({"bq_ids": {"n4140": {"so_515788_516742_0": {"length": 60, "quality": 1.0, "section_id": 333}}, "n3337": {"so_515788_516742_0": {"length": 60, "quality": 1.0, "section_id": 323}}, "n4659": {"so_515788_516742_0": {"length": 60, "quality": 1.0, "section_id": 342}}}, "515788": {"ViewCount": "1166", "Body": "<p>Do I have to explicitly instantiate a function template's type when it comes to reference type deduction. If that is the case, where is the ambiguity? Let's compare following 2 code snippets:</p>\n<p>1st: <a href=\"http://codepad.org/2H5QY3sW\" rel=\"nofollow noreferrer\">link for the code</a> </p>\n<pre><code>template &lt;typename T&gt; \nvoid foo(T&amp; var, void(*func)(T&amp;)) // T must be instantiated with int and it does .\n{\n ++var;\n} \nvoid ret(int &amp; var){}\nint main()\n{int k =7; \nfoo(k, &amp;ret);\ncout&lt;&lt;k;//prints 8\n}\n</code></pre>\n<p>Now let's remove &amp;'s in foo()'s decleration and we have an error.</p>\n<p>2nd: <a href=\"http://codepad.org/jz6qJoAG\" rel=\"nofollow noreferrer\">link for the code</a></p>\n<pre><code>template &lt;typename T&gt; \nvoid foo(T var, void(*func)(T)) // T must be instantiated with int&amp; but it doesn't.\n{\n ++var;\n} \n\nvoid ret(int &amp; var){}\n\nint main()\n{int k =7; \n\nfoo(k, &amp;ret); //error: no matching function for call to 'foo(int&amp;, void (*)(int&amp;))'\ncout&lt;&lt;k;\n}\n</code></pre>\n<p>However, If I call foo by explicitly instantiating with <code>&lt;int&amp;&gt;</code> \"<code>foo&lt;int&amp;&gt;(k,&amp;ret);</code>\", the code gives the same output as the former one. What is the reason of this error? Where is the ambiguity?</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "516742", "Title": "Deduction of reference types in template functions", "CreationDate": "2009-02-05T12:57:08.980", "Id": "515788", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-02-05T13:10:45.177", "LastEditorDisplayName": "litb", "OwnerDisplayName": "Comptrol", "LastEditorUserId": "34509", "LastActivityDate": "2009-02-05T16:47:42.353", "Score": "3", "OwnerUserId": "12652", "Tags": "<c++><templates>", "AnswerCount": "2"}, "515805": {"Body": "<p>Second version of the answer, just misinterpreted the question:</p>\n<p>The problem with the second version is that the compiler just can't know if you want to pass by reference or pass by value.</p>\n<p>The calling syntax for both is exactly the same, but you obviously want to pass by reference - else the increment doesn't make any sense.</p>\n<p>Here an example to show there is no difference how you call an function with a pass by reference and one with a pass by value argument:</p>\n<pre><code>void Incr1(int &amp;value) { value++; }\nvoid Incr2(int value) { value++ } //Completely useless but for demonstration\n\n//Now the calling of both functions\nint x = 1;\nIncr1(x);\nIncr2(x);\n</code></pre>\n<p>If you use a pointer instead of a reference, the compiler knows what to do because you explicitly tell it that you pass a pointer to int.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; \nvoid foo(T var, void(*func)(T))\n{\n    ++(*var);\n} \n\nvoid ret(int *var){}\n\nint main()\n{\n    int k =7; \n\n    foo(&amp;k, &amp;ret); \n    std::cout&lt;&lt;k;\n}\n</code></pre>\n<hr>\n<p>This will make it compile but there is not much sense in it:</p>\n<p>The error is that your function still takes a T&amp; and not a T.</p>\n<p>So you just need this little modification:</p>\n<pre><code>template &lt;typename T&gt; \nvoid foo(T var, void(*func)(T&amp;))\n{\n ++var;\n} \n\nvoid ret(int &amp; var){}\n\nint main()\n{\n    int k =7; \n\n    foo(k, &amp;ret);\n    std::cout&lt;&lt;k;\n}\n</code></pre>\n</hr>", "CreationDate": "2009-02-05T13:04:21.117", "ParentId": "515788", "CommentCount": "3", "LastEditDate": "2009-02-05T14:07:42.423", "PostTypeId": "2", "LastEditorDisplayName": "Fionn", "LastActivityDate": "2009-02-05T14:07:42.423", "LastEditorUserId": "21566", "Id": "515805", "OwnerDisplayName": "Fionn", "Score": "1", "OwnerUserId": "21566"}, "516742": {"Body": "<p>As highlighted in Fionn's <a href=\"https://stackoverflow.com/questions/515788/deduction-of-reference-types-in-template-functions/515805#515805\">answer</a>, the problem is that the compiler deduces two distinct types for <em>T</em>, <em>int</em> and <em>int&amp;</em>.  18.8.2.4/2 has the following:</p>\n<blockquote>\n<p id=\"so_515788_516742_0\">In some cases, the deduction is done using a single set of types P and A, in other cases, there will be a set of\n  corresponding types P and A. Type deduction is done independently for each P/A pair, and the deduced\n  template argument values are then combined. If type deduction cannot be done for any P/A pair, or <strong>if for\n  any pair the deduction leads to more than one possible set of deduced values</strong>, or if different pairs yield different\n  deduced values, or if any template argument remains neither deduced nor explicitly specified, template\n  argument deduction fails.</p>\n</blockquote>\n<p>The highlighted text I believe covers your example.  You didn't ask, but one option you potentially have is to use two template parameters in your example.  Both of these cases can be deduced, so you could then use some other template trickery possibly via enable if to create a new type which represents the version you want, ie. with reference or without.</p>\n", "CreationDate": "2009-02-05T16:47:42.367", "ParentId": "515788", "CommentCount": "3", "LastEditDate": "2017-05-23T11:48:38.623", "PostTypeId": "2", "OwnerDisplayName": "Richard Corden", "LastEditorUserId": "-1", "LastActivityDate": "2009-02-05T16:47:42.367", "Id": "516742", "Score": "3", "OwnerUserId": "11698"}});