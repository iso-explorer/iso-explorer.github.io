post_cb({"bq_ids": {"n4140": {"so_47253655_47253655_0": {"length": 37, "quality": 0.925, "section_id": 5436}}, "n3337": {"so_47253655_47253655_0": {"length": 25, "quality": 0.625, "section_id": 5231}}, "n4659": {"so_47253655_47253655_0": {"length": 37, "quality": 0.925, "section_id": 6863}}}, "47254427": {"Id": "47254427", "PostTypeId": "2", "Body": "<p><code>static_cast&lt;volatile void&gt; (foo())</code> doesn't work as a way to require the compiler to actually compute <code>foo()</code> in any of gcc / clang / MSVC / ICC, with optimization enabled.</p>\n<pre><code>#include &lt;bitset&gt;\n\nvoid foo() {\n    for (int i = 0; i &lt; 10000; ++i)\n      for (int j = 0; j &lt; 10000; ++j) {\n        std::bitset&lt;64&gt; std_set(i + j);\n        //volatile const auto c = std_set.count();     // real work happens\n        static_cast&lt;volatile void&gt; (std_set.count());  // optimizes away\n      }\n}\n</code></pre>\n<p><strong>compiles to just a <code>ret</code> with all 4 major x86 compilers</strong>.  (MSVC emits asm for stand-alone definitions of <code>std::bitset::count()</code> or something, but scroll down for its trivial definition of <code>foo()</code>.</p>\n<p><strong>(Source + asm output for this and the next example on <a href=\"https://gcc.godbolt.org/#z:OYLghAFBqd5TKALEBjA9gEwKYFFMCWALugE4A0BIEAViAIzkDO6ArqatiAOQCkATAGYCAO1QAbVjgDUvQQGEARsSbYic3LwAMAQW06AbugKZpAM3ToIASlkB2AEL7pL82WkRRRaQVmCAItJacg4%2BfvLS9FrRwYKhAk78DgTWzq4uFqQeXtI0foGxoXlyEVExIbJJCTS2vI5p6S5MRJggIMpEquoKAGwALBrSzZgA%2Bl2elUWpcQ2NAPRzRuIAhkQE4tjSGCLN0susJFv5Qy1jagB0GKwiRDYhs%2BnNqwSoI6jLzSVLzxvSRiaDCDDM5ES5sG42aZOXSNez%2BfR1eG6BHIoQEMw4MzSEYjADiADkAKryHH6OYAKjJc2krFUeyY0mwTHeAAdsBABD0DMtSLZDplOH8edJDopNqJpABbbCSsgAT3O%2Biea1Qf2MpiZrPZ/0w5OkLNq9Rh9MlapWaw2HP4/AE/GkIHtlX4wFtEANjtt0tlpDltqhCLsSJ0ypeapMW3E6EUYtINns0J0Lg%2Bpu%2BFvZtttjodDs9MvlfvuyMD%2BnJcxROgWuVp3gFmyISE23MkdfQ0jFPhEUrzPvI0lI2GABGa2Ao0nc2AM2E7BEl0sIq2wSqIz1VOsZzOWbJGXgHI88Nz2hoTSaYKfQ5vW6etAkEQubxwEAFZgtas06XdaIMtrP6i0H9GuRBMkQ9BxnUx6uJk2QHr4cgFBUsEKJEMSFJMCQpPGDyuMMbQdF0JT9IMwLjCkhaJrCHbeFcB5wScoxdGC1y3L%2B5Gwpqm7YNuNy7rG1FECx6SIgG/5CFOhBmNw1jkOIPCPtw5AiDwWjyegPDyAkCRDGwHCbDe9DyUQSmSVJADWICCI%2B5x9IIWj0HY/AABx2AAnI%2B/B9I%2BDl9NJPB9PJkogI%2BfTnM5Xl2H0WiPs50Q2W5PQKUZ5Cqdw8lMCAWjkIZ3DKVJcCwCgGCSiyl4UFQECFcVGykGg4j0M5Iz9OQZjrEBpBpRAiiJcoIg8nKPD6eQhXSjcADyIjiH12XyTgkrLCIwAbIlhD9qgayTmlU3kNgAAe2CoAcXDcANO4yZtRCkDO/WSdJBCKGlkBSegLJrOgOw8AAtCN22pdpnAMFJp1yQlm3JdtDk9O9/TSAAsgAygAaqUznSPwtl2NIABKAAqADqHj4MQ7h6b28joEVJWVII9DWAZRk/uQDbLDg1U2D53B%2BeQAUeectluVFEXOc5PTOX0DnA8pSU8Kl6WZXTpnmZZ9A9GUdiRfwj72Vozls4I8mKSDUuy1NuWIHlyBoGTlUjpQ1AVSVIDAEwPUskwSDoEQTUtSO7WdZt3W9Vdg1k8NRBjRNgczXNC2HRLy17WtTKJTte0HYHJ2Jedl1Hdd4i3fdrNPS9b3cO9OPLOI4jSJ9t7vbNHBIHBIjYEg5cyj97B/dTbNA/rEug%2BDkN9NIwCoKqEDndcJm2BABMkFkxPSKT5NVZT/A00bOXy4I/DnO5ggOfQFnOfQz6C5FbMcwFPQ9Lv6sOYIzn8D0dhBff/DiyphtpRlWU5eQZsQBQGwIgLIDg23Kpbe279sCEDnv9buetErJRvHaAA7sQJA0gwYQyhiPMeE8RBT1psbKSjNmbUABr5fy5lBDnDsOFJWWg7Dbw8krOw8Ve6fxSswGWv9jLkDMtvXe1kD5HxPlraKj4daIINtwvhJt4AAIKpAqq4C7ZVRAC8VA9AxbNXEK1H2XVRAB2zkHWcU5Q7jUmrHGUUdFqbTjqtAg60k67X2kBNO3FToS0zgFbOAM87wEes9Agr0NrVyrmXCuVc66oAbgEFuTBUHYAru3HS8DAYyL7jwbBg8fCj0iA5fGsCiZCEYIvFRI5KaCHXvIreO8tB9BPo/cGoVBAWUEBfahj56DnAcgfQW%2B8hZCB6LZD%2BktuHfw3tdJRFtl7WzKuokcNUo7Pgynogx1BfYS39j6QOQ0LFh0mgNSO817GxwICtBOG0JbJ3cYdY6XiM4XT8fpAJd0glJRCWEj6I0a7DDgsAEQrANJJHoEPUu5dK61x5HExuzdW6SjSZ3Sh3Ae5IJyQPKGEgo7SEsloHmxTCbzzKSTSpJLBB9FqXLLpnMQCi3OPQHR0RlZaEEOwh%2B2tOETOlj/Glgid5RR6S5CyUVmWMFOrrcZyViGbzZvwLJXDZX8MnG1UJik%2BhAA%3D%3D%3D\" rel=\"nofollow noreferrer\">Matt Godbolt's compiler explorer</a>)</strong></p>\n<hr>\n<p>Maybe there are some compilers where <code>static_cast&lt;volatile void&gt;()</code> does do something, in which case it could be a lighter-weight way to write a repeat-loop that doesn't spend instructions storing the result to memory, only computing it.  (This may sometimes be what you want in a microbenchmark).</p>\n<p>Accumulating the result with <code>tmp += foo()</code> (or <code>tmp |=</code>) and returning it from <code>main()</code> or printing it with <code>printf</code> can also be useful, instead of storing into a <code>volatile</code> variable.  Or various compiler-specific things like using an empty inline <code>asm</code> statement to break the compiler's ability to optimize without actually adding any instructions.</p>\n<hr>\n<p>See <a href=\"https://youtu.be/nXaxk27zwlk?t=40m33s\" rel=\"nofollow noreferrer\">Chandler Carruth's CppCon2015 talk on using <code>perf</code> to investigate compiler optimizations</a>, where he shows an <a href=\"https://gist.github.com/daniel-j-h/0a1c1414a68d4a67d4b4\" rel=\"nofollow noreferrer\">optimizer-escape function for GNU C</a>.  But his <code>escape()</code> function is written to require the value to be in memory (passing the asm a <code>void*</code> to it, with a <code>\"memory\"</code> clobber).  We don't need that, we just need the compiler to have the value in a register or memory, or even an immediate constant.  (It's unlikely to fully unroll our loop because it doesn't know that the asm statement is zero instructions.)</p>\n<hr>\n<p><strong>This code compiles to <em>just</em> the popcnt without any extra stores, on gcc</strong>.</p>\n<pre><code>// just force the value to be in memory, register, or even immediate\n// instead of empty inline asm, use the operand in a comment so we can see what the compiler chose.  Absolutely no effect on optimization.\nstatic void escape_integer(int a) {\n  asm volatile(\"# value = %0\" : : \"g\"(a));\n}\n\n// simplified with just one inner loop\nvoid test1() {\n    for (int i = 0; i &lt; 10000; ++i) {\n        std::bitset&lt;64&gt; std_set(i);\n        int count = std_set.count();\n        escape_integer(count);\n    }\n}\n</code></pre>\n<p></p>\n<pre><code>#gcc8.0 20171110 nightly -O3 -march=nehalem  (for popcnt instruction):\n\ntest1():\n        # value = 0              # it peels the first iteration with an immediate 0 for the inline asm.\n        mov     eax, 1\n.L4:\n        popcnt  rdx, rax\n        # value = edx            # the inline-asm comment has the %0 filled in to show where gcc put the value\n        add     rax, 1\n        cmp     rax, 10000\n        jne     .L4\n        ret\n</code></pre>\n<p>Clang chooses to put the value in memory to satisfy the <code>\"g\"</code> constraint, which is pretty dumb.  But clang does tend to do that when you give it an inline-asm constraint that includes memory as an option.  So it's no better than Chandler's <code>escape</code> function for this.</p>\n<pre><code># clang5.0 -O3 -march=nehalem\ntest1(): \n    xor     eax, eax\n    #DEBUG_VALUE: i &lt;- 0\n.LBB1_1:                                # =&gt;This Inner Loop Header: Depth=1\n    popcnt  rcx, rax\n    mov     dword ptr [rsp - 4], ecx\n    # value = -4(%rsp)                # inline asm gets a value in memory\n    inc     rax\n    cmp     rax, 10000\n    jne     .LBB1_1\n    ret\n</code></pre>\n<p>ICC18 with <code>-march=haswell</code> does this:</p>\n<pre><code>test1():\n    xor       eax, eax                                      #30.16\n..B2.2:                         # Preds ..B2.2 ..B2.1\n            # optimization report\n            # %s was not vectorized: ASM code cannot be vectorized\n    xor       rdx, rdx              # breaks popcnt's false dep on the destination\n    popcnt    rdx, rax                                      #475.16\n    inc       rax                                           #30.34\n    # value = edx\n    cmp       rax, 10000                                    #30.25\n    jl        ..B2.2        # Prob 99%                      #30.25\n    ret                                                     #35.1\n</code></pre>\n<p>That's weird, ICC used <code>xor rdx,rdx</code> instead of <code>xor eax,eax</code>.  That wastes a REX prefix and isn't recognized as dependency-breaking on Silvermont/KNL.</p>\n</hr></hr></hr>", "LastActivityDate": "2017-11-12T21:54:14.420", "CommentCount": "0", "CreationDate": "2017-11-12T21:54:14.420", "ParentId": "47253655", "Score": "1", "OwnerUserId": "224132"}, "47253655": {"ViewCount": "147", "Body": "<p>When people are trying to perform rigorous benchmarks in various libraries, I sometimes see code like this:</p>\n<pre><code>auto std_start = std::chrono::steady_clock::now();\nfor (int i = 0; i &lt; 10000; ++i)\n  for (int j = 0; j &lt; 10000; ++j)\n    volatile const auto __attribute__((unused)) c = std_set.count(i + j);\nauto std_stop = std::chrono::steady_clock::now();\n</code></pre>\n<p>The <code>volatile</code> is used here to prevent the optimizer from noticing that the result of the code under test is discarded, and then discarding the entire computation.</p>\n<p>When the code under test doesn't return a value, say it is <code>void do_something(int)</code>, then sometimes I see code like this:</p>\n<pre><code>auto std_start = std::chrono::steady_clock::now();\nfor (int i = 0; i &lt; 10000; ++i)\n  for (int j = 0; j &lt; 10000; ++j)\n    static_cast&lt;volatile void&gt; (do_something(i + j));\nauto std_stop = std::chrono::steady_clock::now();\n</code></pre>\n<p>Is this correct usage of <code>volatile</code>? What is <code>volatile void</code>? What does it mean from the point of view of the compiler and the standard?</p>\n<p>In the standard (N4296) at <code>[dcl.type.cv]</code> it says:</p>\n<blockquote>\n<p id=\"so_47253655_47253655_0\">7 [ Note: volatile is a hint to the implementation to avoid aggressive optimization involving the object\n  because the value of the object might be changed by means undetectable by an implementation. Furthermore,\n  for some implementations, volatile might indicate that special hardware instructions are required to access\n  the object. See 1.9 for detailed semantics. In general, the semantics of volatile are intended to be the\n  same in C ++ as they are in C. \u2014 end note ]</p>\n</blockquote>\n<p>In section 1.9 it specifies a lot of guidance about the execution model, but as far as volatile is concerned, it's about \"accessing a <code>volatile</code> object\". It's not clear to me what <em>executing a statement</em> that has been casted to <code>volatile void</code> means, assuming I understand the code correctly, and exactly what if any optimization barrier is produced.</p>\n", "AcceptedAnswerId": "47254427", "Title": "What does `static_cast<volatile void>` mean for the optimizer?", "CreationDate": "2017-11-12T20:34:01.860", "Id": "47253655", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-11-12T21:54:14.420", "Score": "5", "OwnerUserId": "3598119", "Tags": "<c++><benchmarking><void><volatile><microbenchmark>", "AnswerCount": "1"}});