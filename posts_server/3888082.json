post_cb({"3888082": {"ViewCount": "904", "Body": "<p>The last question I asked was something I stumbled upon when trying to understanding another thing... that I also can't understand (not my day).</p>\n<p>This is quite a long question statement, but at least I hope this question might prove useful to many people and not only me.</p>\n<p>The code I have is the following:</p>\n<pre><code>template &lt;typename T&gt; class V;\ntemplate &lt;typename T&gt; class S;\n\ntemplate &lt;typename T&gt;\nclass V\n{\npublic:\n T x;\n\n explicit V(const T &amp; _x)\n :x(_x){}\n\n V(const S&lt;T&gt; &amp; s)\n :x(s.x){}\n};\n\ntemplate &lt;typename T&gt;\nclass S\n{\npublic:\n T &amp;x;\n\n explicit S(V&lt;T&gt; &amp; v)\n :x(v.x)\n {}\n};\n\ntemplate &lt;typename T&gt;\nV&lt;T&gt; operator+(const V&lt;T&gt; &amp; a, const V&lt;T&gt; &amp; b)\n{\n return V&lt;T&gt;(a.x + b.x);\n}\n\nint main()\n{\n V&lt;float&gt; a(1);\n V&lt;float&gt; b(2);\n S&lt;float&gt; c( b );\n\n b = a + V&lt;float&gt;(c); // 1 -- compiles\n b = a + c;           // 2 -- fails\n b = c;               // 3 -- compiles\n\n return 0;\n}\n</code></pre>\n<p>Expressions 1 and 3 work perfectly, while expression 2 does not compile.</p>\n<p>If I have understood properly, what happens is:</p>\n<p><strong>Expression 1</strong></p>\n<ol>\n<li><em>c</em> is is implicitly converted to <code>const</code> by using a standard conversion sequence (consisting on just one <em>qualification conversion</em>).</li>\n<li><code>V&lt;float&gt;(const S&lt;T&gt; &amp; s)</code> is called and a temporal the <code>const V&lt;float&gt;</code> object generated (let's call it <em>t</em>). It is already const-qualified because it is a temporal value.</li>\n<li><em>a</em> is converted to const similarly to <em>c</em>.</li>\n<li><code>operator+(const V&lt;float&gt; &amp; a, const V&lt;float&gt; &amp; b)</code> is called, resulting in a temporal of type <code>const V&lt;float&gt;</code> that we can call <em>q</em>.</li>\n<li>the default <code>V&lt;float&gt;::operator=(const &amp; V&lt;float&gt;)</code> is called.</li>\n</ol>\n<p>Am I OK up to here? If I made even the most subtle mistake please, let me know, for I am trying to gain an understanding about implicit casting as deep as possible...</p>\n<p><strong>Expression 3</strong></p>\n<ol>\n<li><em>c</em> is converted to <code>V&lt;float&gt;</code>. For that, we have a user-defined conversion sequence:<br>\n1.1. first standard conversion: <code>S&lt;float&gt;</code> to <code>const S&lt;float&gt;</code> via qualification conversion.<br>\n1.2. user-defined conversion: <code>const S&lt;float&gt;</code> to <code>V&lt;float&gt;</code> via <code>V&lt;float&gt;(const S&lt;T&gt; &amp; s)</code> constructor.<br>\n1.3  second standard conversion: <code>V&lt;float&gt;</code> to <code>const V&lt;float&gt;</code> via qualification conversion.</br></br></br></li>\n<li>the default <code>V&lt;float&gt;::operator=(const &amp; V&lt;float&gt;)</code> is called.</li>\n</ol>\n<p><strong>Expression 2?</strong></p>\n<p>What I do not understand is why there is a problem with the second expression. Why is the following sequence not possible?</p>\n<ol>\n<li><em>c</em> is converted to <code>V&lt;float&gt;</code>. For that, we have a user-defined conversion sequence:<br>\n1.1. initial standard conversion: <code>S&lt;float&gt;</code> to <code>const S&lt;float&gt;</code> via qualification conversion.<br>\n1.2. user-defined conversion: <code>const S&lt;float&gt;</code> to <code>V&lt;float&gt;</code> via <code>V&lt;float&gt;(const S&lt;T&gt; &amp; s)</code> constructor.<br>\n1.3. final standard conversion: <code>V&lt;float&gt;</code> to <code>const V&lt;float&gt;</code> via qualification conversion.  </br></br></br></li>\n<li>Steps 2 to 6 are the same as in case of expression 1.</li>\n</ol>\n<p>After reading the C++ standard I though: 'hey! maybe the problem has to to with 13.3.3.1.2.3!' which states:</p>\n<blockquote>\n<p id=\"so_3888082_3888082_0\">If the user-defined conversion is specified by a template conversion function, the second standard conversion sequence must have exact match rank.</p>\n</blockquote>\n<p>But that cannot be the case since the qualification conversion has exact match rank... </p>\n<p>I really have no clue...</p>\n<p>Well, whether you have the answer or not, thanks you for reading up to here :)</p>\n", "AcceptedAnswerId": "3888237", "Title": "Implicit conversion not happening", "CreationDate": "2010-10-08T06:06:39.000", "Id": "3888082", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastActivityDate": "2010-10-08T06:43:53.807", "Score": "6", "OwnerUserId": "469837", "Tags": "<c++><templates><implicit-conversion>", "AnswerCount": "3"}, "3888135": {"Id": "3888135", "PostTypeId": "2", "Body": "<p>Just a guess, but perhaps the compiler cannot distinguish between the conversion from V-&gt;S or from S-&gt;V while trying to figure out how to add a + c in expression 2. You're assuming the compiler will be smart enough to pick the one which allows the compilation to proceed because of the rest of the available functions, but the compiler is probably not \"reading ahead\" (so to speak), and is getting confused with the ambiguity of the up-conversion before trying to find the '+' operator.</p>\n<p>Of course, if you added the compilation error, it might help clarify the problem too...</p>\n", "LastActivityDate": "2010-10-08T06:18:45.317", "CommentCount": "3", "CreationDate": "2010-10-08T06:18:45.317", "ParentId": "3888082", "Score": "0", "OwnerUserId": "26240"}, "3888237": {"Id": "3888237", "PostTypeId": "2", "Body": "<p>As Edric pointed out, conversions are not considered during template argument deduction. Here, you have two contexts where the template parameter T can be deduced from the type of the arguments:</p>\n<pre><code>template&lt;class T&gt;\nv&lt;T&gt; operator+(V&lt;T&gt; const&amp;, V&lt;T&gt; const&amp;);\n               ~~~~~~~~~~~  ~~~~~~~~~~~~\n</code></pre>\n<p>But you try to invoke this function template with a <code>V&lt;float&gt;</code> on the left-hand side and an S on the right hand side. Template argument deduction results in T=float for the left hand side and you'll get an error for the right hand side because there is no T so that <code>V&lt;T&gt;</code> equals <code>S&lt;T&gt;</code>. This qualifies as a template argument deduction failure and the template is simply ignored.</p>\n<p>If you want to allow conversions your operator+ shouldn't be a template. There is the following trick: You can define it as an inline friend inside of the class template for V:</p>\n<pre><code>template&lt;class T&gt;\nclass V\n{\npublic:\n   V();\n   V(S&lt;T&gt; const&amp;); // &lt;-- note: no explicit keyword here\n\n   friend V&lt;T&gt; operator+(V&lt;T&gt; const&amp; lhs, V&lt;T&gt; const&amp; rhs) {\n      ...\n   }\n};\n</code></pre>\n<p>This way, the operator is not a template anymore. So, there is no need for template argument deduction and your invocation should work. The operator is found through ADL (argument dependent lookup) because the left-hand side is a <code>V&lt;float&gt;</code>. The right-hand side is properly converted to a <code>V&lt;float&gt;</code> as well.</p>\n<p>It is also possible to disable template argument deduction for a specific argument. For example:</p>\n<pre><code>template&lt;class T&gt;\nstruct id {typedef T type;};\n\ntemplate&lt;class T&gt;\nT clip(\n   typename id&lt;T&gt;::type min,\n   T value,\n   typename id&lt;T&gt;::type max )\n{\n   if (value&lt;min) value=min;\n   if (value&gt;max) value=max;\n   return value;\n}\n\nint main() {\n   double x = 3.14;\n   double y = clip(1,x,3); // works, T=double\n}\n</code></pre>\n<p>Even though the type of the first and last argument is an int, they are not considered during template argument deduction because <code>id&lt;T&gt;::type</code> is not a so-called  *deducible context`. So, T is only deduced according to the second argument, which results in T=double with no contradictions.</p>\n", "LastEditorUserId": "172531", "LastActivityDate": "2010-10-08T06:43:53.807", "Score": "9", "CreationDate": "2010-10-08T06:37:09.017", "ParentId": "3888082", "CommentCount": "6", "OwnerUserId": "172531", "LastEditDate": "2010-10-08T06:43:53.807"}, "bq_ids": {"n4140": {"so_3888082_3888082_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 622}}, "n3337": {"so_3888082_3888082_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 612}}, "n4659": {"so_3888082_3888082_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 648}}}, "3888143": {"Id": "3888143", "PostTypeId": "2", "Body": "<p>When considering template matches, implicit conversions are not used. Therefore, in the following simple example:</p>\n<pre><code>template &lt; typename T &gt;\nvoid foo( T t1, T t2 ) { /* do stuff */ }\n\nint main( int argc, char ** argv ) {\n    foo( 1, 1.0 );\n    return 0;\n}\n</code></pre>\n<p>That will not compile even though either argument could be implicitly converted to the other type (int &lt;-&gt; double).</p>\n", "LastActivityDate": "2010-10-08T06:19:47.250", "CommentCount": "4", "CreationDate": "2010-10-08T06:19:47.250", "ParentId": "3888082", "Score": "4", "OwnerUserId": "88076"}});