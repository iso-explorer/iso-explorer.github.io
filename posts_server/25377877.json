post_cb({"25377970": {"Id": "25377970", "PostTypeId": "2", "Body": "<p>This holds only true if your class is of standard_layout type. This you can test using the type trait <a href=\"http://en.cppreference.com/w/cpp/types/is_standard_layout\" rel=\"nofollow noreferrer\">is_standard_layout</a></p>\n<pre><code> std::cout &lt;&lt; std::is_standard_layout&lt;A&gt;::value &lt;&lt; '\\n';\n std::cout &lt;&lt; std::is_standard_layout&lt;B&gt;::value &lt;&lt; '\\n';\n</code></pre>\n<p>For other classes, you have additional information stored in memory, which is compiler specific and not standardized. You can have a look at <a href=\"https://stackoverflow.com/questions/1632600/memory-layout-c-objects\">This question</a> where some memory layouts are discussed and showed.</p>\n<p>For your second example/question the standard has the following quote (5.2.10/7, N3337 draft):</p>\n<blockquote>\n<p id=\"so_25377877_25377970_0\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, \n  the result is static_cast(static_cast(v)) if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1, \n  or if either type is void. Converting a prvalue of type\u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are \n  no stricter than those of T1) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>If i read and interpret this correctly, then your example is unspecified, as the alignment requirements of A are bigger that those of B. However, the other way should be ok, e.g:</p>\n<pre><code>int main()\n{\n    A *pa=new A();\n    B *pb=reinterpret_cast&lt;B*&gt;(pa);\n    pb-&gt;x++;\n    std::cout &lt;&lt; pa-&gt;a;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-19T08:04:52.713", "Score": "4", "CreationDate": "2014-08-19T07:36:48.143", "ParentId": "25377877", "CommentCount": "4", "OwnerUserId": "1810521", "LastEditDate": "2017-05-23T12:14:27.877"}, "bq_ids": {"n4140": {"so_25377877_25377970_0": {"length": 37, "quality": 0.6379310344827587, "section_id": 6046}}, "n3337": {"so_25377877_25377970_0": {"length": 55, "quality": 0.9482758620689655, "section_id": 5814}}, "n4659": {"so_25377877_25377970_0": {"length": 37, "quality": 0.6379310344827587, "section_id": 7545}}}, "25377954": {"Id": "25377954", "PostTypeId": "2", "Body": "<p>Yes you are absolutely wrong, you can never take anything like that for granted, those are compiler specific contracts that C++ does not guarantee.</p>\n<p>I believe you confused classes with C++ arrays: For example the pointer to the first member of a char array is the same as the pointer to that array.  </p>\n", "LastActivityDate": "2014-08-19T07:35:28.733", "CommentCount": "7", "CreationDate": "2014-08-19T07:35:28.733", "ParentId": "25377877", "Score": "-1", "OwnerUserId": "1249278"}, "25377877": {"ViewCount": "130", "Body": "<p>I know the following is bad but i was under the impression that the first member of class is the starting address of the class. Is it wrong ?</p>\n<pre><code>   class A{\n      public:\n       int a;\n       int b;\n   };\n\n   class B{\n     public :\n       int x;\n   };\n\n   int main()\n   {\n        B *pb=new B();\n        A *pa=(A*)pb;\n        pa-&gt;a++;\n   }\n</code></pre>\n<p>I was under the impression that pb-&gt;x would be incremented by 1. Is it always true or undefined ? Why does it change when we have user defined constructors or virtual functions ?</p>\n", "Title": "First member of class", "CreationDate": "2014-08-19T07:30:56.587", "LastActivityDate": "2014-08-19T08:04:52.713", "CommentCount": "2", "PostTypeId": "1", "Id": "25377877", "Score": "1", "OwnerUserId": "3942304", "Tags": "<c++>", "AnswerCount": "3"}, "25377999": {"Id": "25377999", "PostTypeId": "2", "Body": "<p>You've violated strict aliasing by casting the pointer to another class. You can only cast it to the type of the first member, if your class is standard-layout.</p>\n", "LastActivityDate": "2014-08-19T07:38:26.690", "CommentCount": "0", "CreationDate": "2014-08-19T07:38:26.690", "ParentId": "25377877", "Score": "2", "OwnerUserId": "298661"}});