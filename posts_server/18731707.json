post_cb({"45772324": {"ParentId": "18731707", "CommentCount": "1", "Body": "<p>Designated initializer are currently included in C++20 body of work: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0329r4.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0329r4.pdf</a> so we might finally see them!</p>\n", "OwnerUserId": "5245033", "PostTypeId": "2", "Id": "45772324", "Score": "7", "CreationDate": "2017-08-19T13:48:45.667", "LastActivityDate": "2017-08-19T13:48:45.667"}, "30434688": {"ParentId": "18731707", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><a href=\"http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=550\" rel=\"noreferrer\">Two Core C99 Features</a> that C++11 Lacks mentions \u201cDesignated Initializers and C++\u201d.</p>\n<p>I think the \u2018designated initializer\u2019 related with potential optimization. Here I use \u201cgcc/g++\u201d 5.1 as an example.</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;    \nstruct point {\n    int x;\n    int y;\n};\nconst struct point a_point = {.x = 0, .y = 0};\nint foo() {\n    if(a_point.x == 0){\n        printf(\"x == 0\");\n        return 0;\n    }else{\n        printf(\"x == 1\");\n        return 1;\n    }\n}\nint main(int argc, char *argv[])\n{\n    return foo();\n}\n</code></pre>\n<p>We knew at compilation time, <code>a_point.x</code> is zero, so we could expected that <code>foo</code> is optimized into a single <code>printf</code>.</p>\n<pre><code>$ gcc -O3 a.c\n$ gdb a.out\n(gdb) disassemble foo\nDump of assembler code for function foo:\n   0x00000000004004f0 &lt;+0&gt;: sub    $0x8,%rsp\n   0x00000000004004f4 &lt;+4&gt;: mov    $0x4005bc,%edi\n   0x00000000004004f9 &lt;+9&gt;: xor    %eax,%eax\n   0x00000000004004fb &lt;+11&gt;:    callq  0x4003a0 &lt;printf@plt&gt;\n   0x0000000000400500 &lt;+16&gt;:    xor    %eax,%eax\n   0x0000000000400502 &lt;+18&gt;:    add    $0x8,%rsp\n   0x0000000000400506 &lt;+22&gt;:    retq   \nEnd of assembler dump.\n(gdb) x /s 0x4005bc\n0x4005bc:   \"x == 0\"\n</code></pre>\n<p><code>foo</code> is optimized to print <code>x == 0</code> only.</p>\n<p>For C++ version,</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\nstruct point {\n    point(int _x,int _y):x(_x),y(_y){}\n    int x;\n    int y;\n};\nconst struct point a_point(0,0);\nint foo() {\n    if(a_point.x == 0){\n        printf(\"x == 0\");\n        return 0;\n    }else{\n        printf(\"x == 1\");\n        return 1;\n    }\n}\nint main(int argc, char *argv[])\n{\n    return foo();\n}\n</code></pre>\n<p>And this is output of the optimized assemble code.</p>\n<pre><code>g++ -O3 a.cc\n$ gdb a.out\n(gdb) disassemble foo\nDump of assembler code for function _Z3foov:\n0x00000000004005c0 &lt;+0&gt;:    push   %rbx\n0x00000000004005c1 &lt;+1&gt;:    mov    0x200489(%rip),%ebx        # 0x600a50 &lt;_ZL7a_point&gt;\n0x00000000004005c7 &lt;+7&gt;:    test   %ebx,%ebx\n0x00000000004005c9 &lt;+9&gt;:    je     0x4005e0 &lt;_Z3foov+32&gt;\n0x00000000004005cb &lt;+11&gt;:   mov    $0x1,%ebx\n0x00000000004005d0 &lt;+16&gt;:   mov    $0x4006a3,%edi\n0x00000000004005d5 &lt;+21&gt;:   xor    %eax,%eax\n0x00000000004005d7 &lt;+23&gt;:   callq  0x400460 &lt;printf@plt&gt;\n0x00000000004005dc &lt;+28&gt;:   mov    %ebx,%eax\n0x00000000004005de &lt;+30&gt;:   pop    %rbx\n0x00000000004005df &lt;+31&gt;:   retq   \n0x00000000004005e0 &lt;+32&gt;:   mov    $0x40069c,%edi\n0x00000000004005e5 &lt;+37&gt;:   xor    %eax,%eax\n0x00000000004005e7 &lt;+39&gt;:   callq  0x400460 &lt;printf@plt&gt;\n0x00000000004005ec &lt;+44&gt;:   mov    %ebx,%eax\n0x00000000004005ee &lt;+46&gt;:   pop    %rbx\n0x00000000004005ef &lt;+47&gt;:   retq   \n</code></pre>\n<p>We can see that <code>a_point</code> is not really a compile time constant value.</p>\n", "OwnerUserId": "203329", "LastEditorUserId": "203329", "LastEditDate": "2015-05-25T09:15:42.057", "Id": "30434688", "Score": "5", "CreationDate": "2015-05-25T09:04:41.793", "LastActivityDate": "2015-05-25T09:15:42.057"}, "18731707": {"CommentCount": "8", "AcceptedAnswerId": "18731820", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2013-09-11T02:26:45.493", "LastActivityDate": "2017-10-06T19:12:37.853", "LastEditDate": "2017-10-06T19:12:37.853", "ViewCount": "22372", "FavoriteCount": "19", "Title": "Why does C++11 not support designated initializer lists as C99?", "Id": "18731707", "Score": "69", "Body": "<p>Consider:</p>\n<pre><code>struct Person\n{\n    int height;\n    int weight;\n    int age;\n};\n\nint main()\n{\n    Person p { .age = 18 };\n}\n</code></pre>\n<p>The code above is legal in C99, but not legal in C++11.</p>\n<p><strong>What's the rationale that C++11 doesn't support such a handy feature?</strong></p>\n", "Tags": "<c++><c><c++11><initialization><c99>", "OwnerUserId": "508343", "AnswerCount": "4"}, "18731820": {"ParentId": "18731707", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>C++ has constructors. If it makes sense to initialize just one member then that can be expressed in the program by implementing an appropriate constructor. This is the sort of abstraction C++ promotes.</p>\n<p>On the other hand the designated initializers feature is more about exposing and making members easy to access directly in client code. This leads to things like having a person of age 18 (years?) but with height and weight of zero.</p>\n<hr>\n<p>In other words, designated initializers support a programming style where internals are exposed, and the client is given flexibility to decide how they want to use the  type.</p>\n<p>C++ is more interested in putting the flexibility on the side of the <strong><em>designer</em></strong> of a type instead, so designers can make it easy to use a type correctly and difficult to use incorrectly. Putting the designer in control of how a type can be initialized is part of this: the designer determines constructors, in-class initializers, etc.</p>\n</hr>", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2015-10-02T02:25:58.283", "Id": "18731820", "Score": "22", "CreationDate": "2013-09-11T02:42:42.193", "LastActivityDate": "2015-10-02T02:25:58.283"}, "29337570": {"ParentId": "18731707", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>Boost actually has <a href=\"http://www.boost.org/doc/libs/1_64_0/libs/parameter/doc/html/index.html\" rel=\"noreferrer\">support for Designated Intializers</a> and there have been numerous proposals to add support to the <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> standard, for example: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4172.htm\" rel=\"noreferrer\">n4172</a> and <a href=\"http://htmlpreview.github.io/?https://raw.github.com/CTMacUser/multiarray-iso-proposal/master/designation-proposal.html\" rel=\"noreferrer\">Daryle Walker's Proposal to Add Designation to Initializers</a>. The proposals cite implementation of <a class=\"post-tag\" href=\"/questions/tagged/c99\" rel=\"tag\" title=\"show questions tagged 'c99'\">c99</a>'s Designated Initializers in Visual C++, gcc, and Clang claiming:</p>\n<blockquote>\n<p id=\"so_18731707_29337570_0\">We believe the changes will be relatively straightforward to implement</p>\n</blockquote>\n<p>But the standard committee repeatedly <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4327.html#150\" rel=\"noreferrer\">rejects such proposals</a>, stating:</p>\n<blockquote>\n<p id=\"so_18731707_29337570_1\">EWG found various problems with the proposed approach, and didn't think it's feasible to try solving the problem, as it has been tried many times and every time it has failed</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/34614308/is-there-a-way-to-get-warned-about-misbehaving-designated-initializers?noredirect=1#comment57025198_34614308\">Ben Voigt's comments</a> have helped me to see the insurmountable problems with this approach; given:</p>\n<pre><code>struct X {\n    int c;\n    char a;\n    float b;\n};\n</code></pre>\n<p>What order would these functions be called in in <a class=\"post-tag\" href=\"/questions/tagged/c99\" rel=\"tag\" title=\"show questions tagged 'c99'\">c99</a>: <code>struct X foo = {.a = (char)f(), .b = g(), .c = h()}</code>? Suprisingly, in <a class=\"post-tag\" href=\"/questions/tagged/c99\" rel=\"tag\" title=\"show questions tagged 'c99'\">c99</a>:</p>\n<blockquote>\n<p id=\"so_18731707_29337570_2\">The order of evaluation of the subexpressions in any initializer is indeterminately sequenced <sup>[<a href=\"http://en.cppreference.com/w/c/language/struct_initialization#Notes\" rel=\"noreferrer\">1</a>]</sup></p>\n</blockquote>\n<p>(Visual C++, <a href=\"http://ideone.com/WO3NEt\" rel=\"noreferrer\">gcc</a>, and Clang seem to have an agreed upon behavior as they will all make the calls in this order:) <strike></strike></p>\n<ol>\n<li><code>h()</code></li>\n<li><code>f()</code></li>\n<li><code>g()</code></li>\n</ol>\n<p></p> But the indeterminate nature of the standard means that if these functions had any interaction the resulting program state would also be indeterminate, <em>and the compiler wouldn't warn you</em>: <a href=\"https://stackoverflow.com/q/34614308/2642059\">Is there a Way to Get Warned about Misbehaving Designated Initializers?</a>\n<p><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> <em>does</em> have stringent initializer-list requirements 11.6.4[dcl.init.list]4:</p>\n<blockquote>\n<p id=\"so_18731707_29337570_3\">Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack expansions (17.5.3), are evaluated in the order in which they appear. That is, every value computation and side e\ufb00ect associated with a given initializer-clause is sequenced before every value computation and side effect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list.</p>\n</blockquote>\n<p>So <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> support would have required this to be executed in the order:</p>\n<ol>\n<li><code>f()</code></li>\n<li><code>g()</code></li>\n<li><code>h()</code></li>\n</ol>\n<p>Breaking compatibility with previous <a class=\"post-tag\" href=\"/questions/tagged/c99\" rel=\"tag\" title=\"show questions tagged 'c99'\">c99</a> implementations. What is needed here is an explicit behavior governing the execution order of Designated Intializers. A more promising proposal to the Core Working Group is <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0329r3.pdf\" rel=\"noreferrer\">P0329R3</a> which proposes Designated Intialization with the following limitations:</p>\n<p><a href=\"https://i.stack.imgur.com/iSmX0.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/iSmX0.png\"/></a></p>\n<p>[<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0329r0.pdf\" rel=\"noreferrer\">source</a>]</p>\n", "OwnerUserId": "2642059", "LastEditorUserId": "2642059", "LastEditDate": "2017-08-03T15:59:20.570", "Id": "29337570", "Score": "31", "CreationDate": "2015-03-30T02:39:36.867", "LastActivityDate": "2017-08-03T15:59:20.570"}, "bq_ids": {"n4140": {"so_18731707_29337570_3": {"section_id": 3326, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_18731707_29337570_3": {"section_id": 3196, "quality": 0.9142857142857143, "length": 32}}, "n4659": {"so_18731707_29337570_3": {"section_id": 4092, "quality": 0.9142857142857143, "length": 32}}}});