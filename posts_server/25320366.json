post_cb({"25320366": {"ViewCount": "1091", "Body": "<p>I would like to modify an existing class constructor:</p>\n<pre><code>template&lt; typename T, typename... Ts &gt;\nMyClass( std::vector&lt;T&gt;&amp; head, Ts&amp; ...tail );\n</code></pre>\n<p>So that a processing flag can be specified:</p>\n<pre><code>template&lt; typename T, typename... Ts &gt;\nMyClass( MyEnum myEnum, std::vector&lt;T&gt;&amp; head, Ts&amp; ...tail );\n</code></pre>\n<p>This works fine, however I was wondering if there is a way for it to be specified as the right-most argument, and possibly with a default value. I've never seen variadic templates declared like that, but then again, I can't find anything explicitly stating that they can't be. I tried:</p>\n<pre><code>template&lt; typename T, typename... Ts &gt;\nMyClass( std::vector&lt;T&gt;&amp; head, Ts&amp; ...tail, MyEnum myEnum );\n\n...\n\nMyClass myClass( dataA, dataB, dataC, MyEnum::VALUE );\n</code></pre>\n<p>But the compiler does not like it, I'm assuming it is due to how variadic templates are resolved and that they must be the right-most parameter?</p>\n<p>Is this possible in C++11?</p>\n", "AcceptedAnswerId": "25320622", "Title": "Variadic template argument order, must they always be the right most argument?", "CreationDate": "2014-08-15T02:17:10.740", "Id": "25320366", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-08-17T09:17:46.537", "LastEditorUserId": "3043539", "LastActivityDate": "2014-08-17T09:17:46.537", "Score": "16", "OwnerUserId": "785259", "Tags": "<c++><templates><c++11><variadic-templates>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25320366_25320622_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 114}}, "n3337": {"so_25320366_25320622_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 109}}, "n4659": {"so_25320366_25320622_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 118}}}, "25320622": {"Id": "25320622", "PostTypeId": "2", "Body": "<p>It's not illegal to have a function parameter pack in the middle, but you run into a gigantic hurdle when you try to do this with a constructor: a function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em> is a non-deduced context (\u00a714.8.2.5 [temp.deduct.type]/p5, last bullet point), and constructor templates must be called using template argument deduction - you can't explicit specify their template parameters.</p>\n<p>That is, to have a function parameter pack in the middle, you must explicitly specify the template parameters when you call the function:</p>\n<pre><code>template&lt; typename T, typename... Ts &gt;\nvoid test( const std::vector&lt;T&gt;&amp; head, const Ts&amp; ...tail, MyEnum myEnum ) { }\n\ntest&lt;double, int&gt;(std::vector&lt;double&gt;(), 10, MyEnum()); // legal\n</code></pre>\n<p>But this will not compile:</p>\n<pre><code>test(std::vector&lt;double&gt;(), 10, MyEnum()); // No deduction performed for the parameter pack\n</code></pre>\n<p>There is, however, no way in the language to explicitly specify the template parameters of a constructor template when you call it (\u00a714.8.1 [temp.arg.explicit]/p7):</p>\n<blockquote>\n<p id=\"so_25320366_25320622_0\">[ <em>Note</em>: Because the explicit template argument list follows the\n  function template name, and because conversion member function\n  templates and constructor member function templates are called without\n  using a function name, there is no way to provide an explicit template\n  argument list for these function templates. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>Thus, for constructors, you have to rely on template argument deduction - which doesn't work if your function parameter pack is not at the end.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-15T03:47:10.017", "Score": "21", "CreationDate": "2014-08-15T02:55:44.477", "ParentId": "25320366", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-08-15T03:47:10.017"}, "25320425": {"Id": "25320425", "PostTypeId": "2", "Body": "<p>You can \"wrap\" the variadic in an <code>std::tuple</code>:</p>\n<pre><code>template&lt; typename T, typename... Ts &gt;\nMyClass( std::vector&lt;T&gt;&amp; head, std::tuple&lt;Ts&amp; ...&gt; tail, MyEnum myEnum );\n\n...\n\nMyClass myClass( dataA, std::tie( dataB, dataC ), MyEnum::VALUE );\n// NOTE:                ^^^^^^^^^              ^\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/011ec84847f5e94b\">Live example</a> (rev 2)</p>\n", "LastEditorUserId": "1619294", "LastActivityDate": "2014-08-15T02:32:36.113", "Score": "9", "CreationDate": "2014-08-15T02:26:33.213", "ParentId": "25320366", "CommentCount": "1", "OwnerUserId": "1619294", "LastEditDate": "2014-08-15T02:32:36.113"}});