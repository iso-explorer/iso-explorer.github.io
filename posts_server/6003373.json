post_cb({"6003414": {"ParentId": "6003373", "CommentCount": "0", "Body": "<p>Try writing out <code>friend struct ::S;</code>.</p>\n<p>At the moment, the non-existent <code>N::S</code> is assumed. This fix specifies the global namespace, a bit like how the leading <code>/</code> on a Linux path specifies the filesystem root.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "6003414", "Score": "4", "CreationDate": "2011-05-14T17:04:22.730", "LastActivityDate": "2011-05-14T17:04:22.730"}, "6003415": {"ParentId": "6003373", "CommentCount": "0", "Body": "<p>Because <code>friend struct S;</code> declares <code>N::S</code> class but you need <code>::S</code> class.</p>\n", "OwnerUserId": "425086", "PostTypeId": "2", "Id": "6003415", "Score": "5", "CreationDate": "2011-05-14T17:04:26.383", "LastActivityDate": "2011-05-14T17:04:26.383"}, "6003373": {"CommentCount": "0", "ViewCount": "704", "CreationDate": "2011-05-14T16:59:49.550", "LastActivityDate": "2011-05-14T17:52:55.757", "Title": "Why can't I change a private member of a class from a friend class in a different namespace?", "AcceptedAnswerId": "6003411", "PostTypeId": "1", "Id": "6003373", "Score": "8", "Body": "<p>I am finding trouble accessing a private member of a class from a friend class.</p>\n<p>The class that holds the private member I want to change and the class where the change is made are in different namespaces.</p>\n<p>The friend class is defined after the class holding the data, so I've tried to forward declare the friend class outside the namespace.</p>\n<p>g++ says that I can't modify the member because it's private, visual studio seems to think it's fine.</p>\n<p>Am I doing some weird non-standard thing here? Why can't I change the member? Here is a simplified snippet that represents my problem:</p>\n<pre><code>struct S;\n\nnamespace N\n{\n    class A\n    {\n        int m;\n    public:\n        A():m(5){};\n        friend struct S;\n    };\n\n}\n\nusing namespace N;\n\nstruct S\n{\n    A&amp; a;\n    S(A&amp; a):a(a) {}\n    void changeA(){ a.m = 9; }\n};\n\nint main()\n{\n    A a;\n    S s(a);\n    s.changeA();\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "116957", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_6003373_6003411_0": {"section_id": 5485, "quality": 0.8, "length": 24}}, "n3337": {"so_6003373_6003411_0": {"section_id": 5271, "quality": 0.7666666666666667, "length": 23}}, "n4659": {"so_6003373_6003411_0": {"section_id": 6920, "quality": 0.8, "length": 24}}}, "6003411": {"ParentId": "6003373", "PostTypeId": "2", "CommentCount": "6", "Body": "<pre><code>friend struct ::S;\n</code></pre>\n<p>what you are really doing with</p>\n<pre><code>friend struct S;\n</code></pre>\n<p>is declaring as friend the class N::S (which is defined nowhere).</p>\n<p>Edit: To back up my idea that gcc behavior is correct and VC++ has a bug.</p>\n<p>7.3.1.2/3</p>\n<blockquote>\n<p id=\"so_6003373_6003411_0\">If a <code>friend</code> declaration in a non-local class first declares a class or\n  function the friend class or function is a member of the innermost\n  enclosing namespace. [...]  When looking for a prior declaration of a\n  class or function introduced by a friend declaration, scopes outside the\n  innermost enclosing namespace scope are not considered.</p>\n</blockquote>\n", "OwnerUserId": "136208", "LastEditorUserId": "136208", "LastEditDate": "2011-05-14T17:52:55.757", "Id": "6003411", "Score": "9", "CreationDate": "2011-05-14T17:03:48.327", "LastActivityDate": "2011-05-14T17:52:55.757"}});