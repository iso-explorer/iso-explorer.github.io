post_cb({"24293443": {"ParentId": "24293311", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This phrase</p>\n<blockquote>\n<p id=\"so_24293311_24293443_0\">A name used in the definition of a class X outside of a member\n  function body...</p>\n</blockquote>\n<p>considers all names that are used in the definition of a class that is starting from the class head and ending in the closing brace excluding names used in member functions (names used in member functions are considered in other paragraph).</p>\n<p>For example</p>\n<pre><code>class B : public A\n{\n   int x;\n   int a[i];\n   C z;\n   //..\n};\n</code></pre>\n<p>So these names are A, x, a, i, C, z.</p>\n<p>Take into account that though names x, a, and z are defined in the class their names can be used in other member definitions of the class. </p>\n<p>As for your code example</p>\n<pre><code>class A { static const int a = 4; }\n\nint b = A::a;\n\nThe name a after the nested-name-specifier used into the global scope or it used into the class scope?\n</code></pre>\n<p>then name a is searched in the class scope of class A but its qualified name used in the global scope to initialize variable b.</p>\n<p>Consider another example though it has nothing common with the phrase you cited but has a relation with your code.</p>\n<pre><code>struct A\n{\n    static int a;\n    static int b;\n};\n\nint A::a = 10;\nint A::b = a;\n</code></pre>\n<p>Here is used name a without nested name specifier. It is one more rule how names are searched in the class scope.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-06-18T19:47:41.023", "Id": "24293443", "Score": "0", "CreationDate": "2014-06-18T19:17:13.970", "LastActivityDate": "2014-06-18T19:47:41.023"}, "24313401": {"ParentId": "24293311", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Disclaimer: Warning, language-laywer answer.</p>\n<h2>What is a \"scope\"?</h2>\n<p>Generally, I'd say that a scope is understood as the part of the program text enclosed by <code>{}</code> other than the initializer-brackets. TC++PLv4 p157 \"A declaration introduces a name into a scope\".</p>\n<h3>Declarative region</h3>\n<p>In [basic.scope.declarative]/1, we find the definition of a <em>declarative region</em>:</p>\n<blockquote>\n<p id=\"so_24293311_24313401_0\">Every name is introduced in some portion of program text called a <em>declarative region</em>, which is the largest part of the program in which that name is <em>valid</em>, that is, in which that name may be used as an unqualified name to refer to the same entity.</p>\n</blockquote>\n<p>I think we can see the part after \"that is\" as a definition of the <em>validity of a name</em>.</p>\n<h3>Scope</h3>\n<p>[basic.scope.declarative]/1 continues with the definition of <em>scope</em>:</p>\n<blockquote>\n<p id=\"so_24293311_24313401_1\">In general, each particular name is valid only within some possibly discontiguous\n  portion of program text called its <em>scope</em>.</p>\n</blockquote>\n<p>This only defines what <em>the scope of a name</em> is. In the phrases \"used in global scope\" or \"used in the scope of the class\", the term <em>scope</em> is used not related to a specific name. Similarly, [basic.scope.declarative]/3</p>\n<blockquote>\n<p id=\"so_24293311_24313401_2\">The names declared by a declaration are introduced into the scope in which the declaration occurs, except [...].</p>\n</blockquote>\n<p>Here, the term <em>scope</em> is also used in that second meaning, unrelated to a specific name.</p>\n<h2>Defining the second meaning of \"scope\"</h2>\n<p>Several language features such as block statements, namespaces and classes <em>introduce a new scope</em>. E.g. [stmt.block]/1</p>\n<blockquote>\n<p id=\"so_24293311_24313401_3\">A compound statement defines a block scope.</p>\n</blockquote>\n<p><em>Scope</em> in its second meaning is used at least in three different contexts:</p>\n<ul>\n<li>looked up in the scope of X</li>\n<li>used in the scope of X</li>\n<li>is in the scope of X</li>\n</ul>\n<h3>Looked up in the scope of X</h3>\n<p>Example: 3.4.3/1</p>\n<blockquote>\n<p id=\"so_24293311_24313401_4\">If the <em>nested-name-specifier</em> of a <em>qualified-id</em> nominates a class, the name specified after the <em>nested-name-specifier</em> is looked up in the scope of the class, except for the cases listed below.</p>\n</blockquote>\n<pre><code>class X\n{\n    int m;\n    void foo() { int n; }\n};\n\ndecltype(X::m) v; // legal\ndecltype(X::n) w; // illegal\n</code></pre>\n<p>In this context, the <em>scope of class <code>X</code></em> does not extend to any nested scopes such as member functions or nested classes.</p>\n<h3>Used in the scope of X</h3>\n<p>Example: 3.3.7/2</p>\n<blockquote>\n<p id=\"so_24293311_24313401_5\">The name of a class member shall only be used as follows:</p>\n<ul>\n<li>in the scope of its class (as described above) or a class derived from its class,</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<pre><code>class X\n{\n    int m;\n    void foo()\n    {\n        decltype(m) n;\n    }\n    static int o;\n};\nint X::o = decltype(m)();\n</code></pre>\n<p>Here, the <em>scope of class <code>X</code></em> extends to nested scopes and other parts of the program, such as definitions of members outside of the class body.</p>\n<p>Note that the initializers of static data members, nested classes and local classes are explicitly defined <em>to be in the scope of</em> wherever the static data member / class has been declared. For member functions, I can only find non-normative notes such as 9.3/5</p>\n<blockquote>\n<p id=\"so_24293311_24313401_6\">The member function <code>f</code> of class <code>X</code> is defined in global scope; the notation <code>X::f</code> specifies that the function <code>f</code> is a member of class <code>X</code> and in the scope of class <code>X</code>.</p>\n</blockquote>\n<p>As I understand it, this \"is in the scope of\" for member functions and nested/local classes says that those newly introduced scopes are nested scopes.</p>\n<p>\"Used in the scope of X\" does not occur very often in the Standard. One could argue that 3.3.7/2 should be extended to nested scopes, to make \"used in the scope of\" consistent with \"looked up in the scope of\".</p>\n<h3>To be in the scope of X</h3>\n<p>Example: 8.5/13</p>\n<blockquote>\n<p id=\"so_24293311_24313401_7\">An initializer for a static member is in the scope of the member's class.</p>\n</blockquote>\n<pre><code>class X\n{\n    static int m;\n    static int n;\n};\n\nint n;\nint o;\n\nint X::m = n; // X::n\nint X::n = o; // ::o\n</code></pre>\n<p>Name lookup for unqualified names searches <em>the scopes</em> (plural) \"in the order listed in each of the respective categories\" [basic.lookup.unqual]/1. For the initializers of the two static data members, the scope of class <code>X</code> is searched first, then any base classes, then the enclosing scope (here: the global scope), [basic.lookup.unqual]/7.</p>\n<p>What is meant with \"to be in the scope of <code>X</code>\" seems to me that for unqualified lookup, <em>the scopes searched are the ones that are searched for names used inside <code>X</code></em>, maybe plus access rules (initializers of static data members may access private members etc). As said above, this effectively nests scope of member functions and nested classes defined outside their enclosing class' body in the scope of that enclosing class.</p>\n<h2>Trying to define the scope of X</h2>\n<p>Not including the weird extensions of \"used in the scope of X\".</p>\n<p>3.3.3 to 3.3.9 categorize various kinds of <em>scopes of names</em>. We can use these categories to categorize the parts of our program where names can be declared: A part of a program where names with block scope can be declared <em>is a block scope</em>. A part of the program where names with class scope can be declared <em>is a class scope</em>. We still need to differentiate different scopes of the same kind:</p>\n<pre><code>void foo()\n{                   // begin scope A\n    int a;          // \n    {               // begin scope B\n        int b;      // \n        int c;      //\n    }               // end scope B\n    int d;          //\n}                   // end scope A\n</code></pre>\n<p>The Standard calls <code>A</code> an outer scope of <code>B</code> (in name lookup). However, the scope <code>B</code> is not part of the scope <code>A</code>. Maybe something like \"<code>B</code> is in the scope of <code>A</code>, but the names declared inside <code>B</code> are not in the scope of <code>A</code>\". Consider:</p>\n<pre><code>class A\n{\n    int m;\n    class B\n    {\n        int n;\n    };\n};\n</code></pre>\n<p>Here, name lookup \"in the scope of the class <code>A</code>\" won't find members of the nested class <code>B</code> with unqualified lookup. Also relevant: anonymous unions.</p>\n<p>I think the best way to perform this separation is to look at the individual language features which can introduce a scope. For example, [stmt.block]/1 \"A compound statement defines a block scope.\" We can then look at any part X of the program, find the closest previous language feature that introduced a scope which has not ended yet(*), take all the regions of the program where newly declared names are in the same scope (**), and call this the <em>enclosing scope of X</em>.</p>\n<p>(*) <em>not ended yet:</em> for a block, the end of the block etc. (i.e., as specified by the language feature) Alternatively, <em>not ended yet</em> = where a name could have been declared that is still valid<br/>\n(**) <em>in the same scope:</em> searching, beginning from this new declaration, the closest previous language feature that introduced a scope which has not ended yet, shall find the same part of the program</p>\n<p>This seems to comply with what has been intended as the definition of <em>declarative region</em> as used in [basic.scope.declarative]/4:</p>\n<blockquote>\n<p id=\"so_24293311_24313401_8\">Given a set of declarations in a single declarative region, each of which specifies the same unqualified name, they shall all refer to the same entity, or [... = be function overloads], or [... = various exceptions].</p>\n</blockquote>\n<p>This, as far as I can see, contradicts the definition given in [basic.scope.declarative]/1:</p>\n<pre><code>int main()\n{\n    int x;\n    {\n        int x;\n    }\n}\n</code></pre>\n<p>Here, we have two declarations specifying the same unqualified name. The outer <code>x</code> as a name is valid also inside the inner <code>{}</code>; yet, this is a perfectly legal C++ program. I suspect that <em>declarative region</em> in fact shouldn't be associated with a single name.</p>\n<p>I think it is possible to simplify this definition of <em>scope</em> by using the terminals <code>{</code> and <code>}</code>.</p>\n", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-06-20T14:57:52.680", "Id": "24313401", "Score": "1", "CreationDate": "2014-06-19T18:02:16.947", "LastActivityDate": "2014-06-20T14:57:52.680"}, "24293311": {"CommentCount": "6", "AcceptedAnswerId": "24313401", "OwnerDisplayName": "user2953119", "CreationDate": "2014-06-18T19:08:53.093", "LastActivityDate": "2014-06-20T14:57:52.680", "PostTypeId": "1", "ViewCount": "123", "FavoriteCount": "1", "Title": "The meaning of the name used in the scope word combinantion", "Id": "24293311", "Score": "4", "Body": "<p>I don't understand sense of the <code>name used in...</code>. What does it mean? For example (3.4.1/7):</p>\n<blockquote>\n<p id=\"so_24293311_24293311_0\">A name used in the definition of a class X outside of a member\n  function body...</p>\n</blockquote>\n<p>Consider the following example:</p>\n<pre><code>class A { static const int a = 4; }\n\nint b = A::a;\n</code></pre>\n<p>The name <code>a</code> after the nested-name-specifier used into the global scope or it used into the class scope?</p>\n<p>The namespace analog is defined pretty clear in the 7.3.1/6:</p>\n<blockquote>\n<p id=\"so_24293311_24293311_1\">The enclosing namespaces of a declaration are those namespaces in\n  which the declaration lexically appears, except for a redeclaration of\n  a namespace member outside its original namespace (e.g., a definition\n  as specified in 7.3.1.2).</p>\n</blockquote>\n", "Tags": "<c++><class><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24293311_24313401_0": {"section_id": 7044, "quality": 0.9, "length": 18}, "so_24293311_24293311_0": {"section_id": 7093, "quality": 1.0, "length": 7}, "so_24293311_24313401_1": {"section_id": 7044, "quality": 1.0, "length": 14}, "so_24293311_24293311_1": {"section_id": 5478, "quality": 0.85, "length": 17}, "so_24293311_24293443_0": {"section_id": 7093, "quality": 1.0, "length": 7}, "so_24293311_24313401_7": {"section_id": 3292, "quality": 1.0, "length": 6}, "so_24293311_24313401_6": {"section_id": 5884, "quality": 0.9285714285714286, "length": 13}, "so_24293311_24313401_3": {"section_id": 3881, "quality": 1.0, "length": 5}, "so_24293311_24313401_4": {"section_id": 7113, "quality": 1.0, "length": 15}, "so_24293311_24313401_5": {"section_id": 7071, "quality": 0.8, "length": 4}, "so_24293311_24313401_8": {"section_id": 7047, "quality": 0.85, "length": 17}, "so_24293311_24313401_2": {"section_id": 7046, "quality": 0.9, "length": 9}}, "n3337": {"so_24293311_24313401_0": {"section_id": 6789, "quality": 0.9, "length": 18}, "so_24293311_24293311_0": {"section_id": 6837, "quality": 1.0, "length": 7}, "so_24293311_24313401_1": {"section_id": 6789, "quality": 1.0, "length": 14}, "so_24293311_24293311_1": {"section_id": 5264, "quality": 0.85, "length": 17}, "so_24293311_24293443_0": {"section_id": 6837, "quality": 1.0, "length": 7}, "so_24293311_24313401_7": {"section_id": 3162, "quality": 1.0, "length": 6}, "so_24293311_24313401_6": {"section_id": 5655, "quality": 0.9285714285714286, "length": 13}, "so_24293311_24313401_3": {"section_id": 3741, "quality": 1.0, "length": 5}, "so_24293311_24313401_4": {"section_id": 6857, "quality": 1.0, "length": 15}, "so_24293311_24313401_5": {"section_id": 6815, "quality": 0.8, "length": 4}, "so_24293311_24313401_8": {"section_id": 6792, "quality": 0.85, "length": 17}, "so_24293311_24313401_2": {"section_id": 6791, "quality": 0.9, "length": 9}}, "n4659": {"so_24293311_24313401_0": {"section_id": 8541, "quality": 0.9, "length": 18}, "so_24293311_24293311_0": {"section_id": 8594, "quality": 1.0, "length": 7}, "so_24293311_24313401_1": {"section_id": 8541, "quality": 1.0, "length": 14}, "so_24293311_24293311_1": {"section_id": 6911, "quality": 0.85, "length": 17}, "so_24293311_24293443_0": {"section_id": 8594, "quality": 1.0, "length": 7}, "so_24293311_24313401_7": {"section_id": 4054, "quality": 1.0, "length": 6}, "so_24293311_24313401_6": {"section_id": 7367, "quality": 0.9285714285714286, "length": 13}, "so_24293311_24313401_3": {"section_id": 4770, "quality": 1.0, "length": 5}, "so_24293311_24313401_4": {"section_id": 8614, "quality": 1.0, "length": 15}, "so_24293311_24313401_5": {"section_id": 8572, "quality": 0.8, "length": 4}, "so_24293311_24313401_8": {"section_id": 8544, "quality": 0.85, "length": 17}, "so_24293311_24313401_2": {"section_id": 8543, "quality": 0.9, "length": 9}}}});