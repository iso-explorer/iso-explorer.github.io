post_cb({"47531235": {"ParentId": "47531139", "PostTypeId": "2", "CommentCount": "14", "Body": "<h3>What the standard says</h3>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/intro.abstract#1\" rel=\"noreferrer\"><code>[intro.abstract]/1</code></a>:</h3>\n<p id=\"so_47531139_47531235_0\">The semantic descriptions in this document define a parameterized nondeterministic abstract machine.\n  This document places no requirement on the structure of conforming implementations.\n  In particular, they need not copy or emulate the structure of the abstract machine.\n  Rather, conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.</p>\n</blockquote>\n<p>C++ could not define an endianness qualifier since it has no concept of endianness.</p>\n<h3>Discussion</h3>\n<p>About the difference between signness and endianness, OP wrote</p>\n<blockquote>\n<p id=\"so_47531139_47531235_1\">In my understanding, endianness is just a variation of the same principle [(signness)]: a different interpretation of a binary pattern based on compile-time information about the memory in which it will be stored.</p>\n</blockquote>\n<p>I'd argue signness both have a semantic and a representative aspect<sup>1</sup>. What <code>[intro.abstract]/1</code> implies is that C++ only care about <em>semantic</em>, and never addresses the way a signed number should be represented in memory<sup>2</sup>. Actually, <a href=\"http://eel.is/c++draft/numeric.limits.members#10\" rel=\"noreferrer\"><em>\"sign bit\"</em> only appears once in the C++ specs</a> and refer to an implementation-defined value.<br>\nOn the other hand, endianness only have a representative aspect: <em>endianness conveys no meaning</em>.</br></p>\n<hr>\n<p><sup>1)</sup> Semantic aspect: an signed integer can represent values below zero; representative aspect: one need to, for example,  reserve a bit to convey the positive/negative sign.<br>\n<sup>2)</sup> In the same vein, C++ never describe how a floating point number should be represented, IEEE-754 is often used, but this is a choice made by the implementation, in any case enforced by the standard: <a href=\"http://eel.is/c++draft/basic.fundamental#8\" rel=\"noreferrer\"><code>[basic.fundamental]/8</code></a> <em>\"The value representation of floating-point types is implementation-defined\"</em>.</br></p>\n</hr>", "OwnerUserId": "5470596", "LastEditorUserId": "3529323", "LastEditDate": "2017-11-29T15:47:55.257", "Id": "47531235", "Score": "51", "CreationDate": "2017-11-28T12:06:29.900", "LastActivityDate": "2017-11-29T15:47:55.257"}, "47534029": {"ParentId": "47531139", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>Because nobody has proposed to add it to the standard, and/or because compiler implementer have never felt a need for it.</p>\n<p>Maybe you could propose it to the committee. I do not think it is difficult to implement it in a compiler: compilers already propose fundamental types that are not fundamental types for the target machine.</p>\n<p>The development of C++ is an affair of all C++ coders.</p>\n<p>@Schimmel. Do not listen to people who justify the status quo! All the cited arguments to justify this absence are more than fragile. A student logician could find their inconsistence without knowing anything about computer science. Just propose it, and just don't care about pathological conservatives. (Advise: propose new types rather than a qualifier because the <code>unsigned</code> and <code>signed</code> keywords are considered mistakes).</p>\n", "OwnerUserId": "5632316", "LastEditorUserId": "14114", "LastEditDate": "2017-11-29T03:09:34.730", "Id": "47534029", "Score": "0", "CreationDate": "2017-11-28T14:30:37.307", "LastActivityDate": "2017-11-29T03:09:34.730"}, "47541560": {"ParentId": "47531139", "CommentCount": "0", "Body": "<p>Integers (as a mathematical concept) have the concept of positive and negative numbers.  This abstract concept of sign has a number of different implementations in hardware.</p>\n<p>Endianness is not a mathematical concept.  Little-endian is a hardware implementation trick to improve the performance of multi-byte twos-complement integer arithmetic on a microprocessor with 16 or 32 bit registers and an 8-bit memory bus.  Its creation required using the term big-endian to describe everything else that had the same byte-order in registers and in memory.</p>\n<p>The C abstract machine includes the concept of signed and unsigned integers, without details -- without requiring twos-complement arithmetic, 8-bit bytes or how to store a binary number in memory.</p>\n<p>PS: I agree that binary data compatibility on the net or in memory/storage is a PIA.</p>\n", "OwnerUserId": "6378078", "PostTypeId": "2", "Id": "47541560", "Score": "3", "CreationDate": "2017-11-28T21:55:52.863", "LastActivityDate": "2017-11-28T21:55:52.863"}, "47531139": {"CommentCount": "31", "ViewCount": "4876", "PostTypeId": "1", "ClosedDate": "2017-11-29T19:08:56.280", "LastEditorUserId": "956198", "CreationDate": "2017-11-28T12:02:10.453", "LastActivityDate": "2017-12-02T15:01:43.630", "LastEditDate": "2017-12-02T15:01:43.630", "FavoriteCount": "4", "Title": "Why isn't there an endianness modifier in C++ like there is for signedness?", "Id": "47531139", "Score": "46", "Body": "<p><em>(I guess this question could apply to many typed languages, but I chose to use C++ as an example.)</em></p>\n<p>Why is there no way to just write:</p>\n<pre><code>struct foo {\n    little int x;   // little-endian\n    big long int y; // big-endian\n    short z;        // native endianness\n};\n</code></pre>\n<p>to specify the endianness for specific members, variables and parameters?</p>\n<h2>Comparison to signedness</h2>\n<p>I understand that the type of a variable not only determines how many bytes are used to store a value but also how those bytes are interpreted when performing computations.</p>\n<p>For example, these two declarations each allocate one byte, and for both bytes, every possible 8-bit sequence is a valid value:</p>\n<pre><code>signed char s;\nunsigned char u;\n</code></pre>\n<p>but the same binary sequence might be interpreted differently, e.g. <code>11111111</code> would mean -1 when assigned to <code>s</code> but 255 when assigned to <code>u</code>. When signed and unsigned variables are involved in the same computation, the compiler (mostly) takes care of proper conversions.</p>\n<p>In my understanding, endianness is just a variation of the same principle: a different interpretation of a binary pattern based on compile-time information about the memory in which it will be stored.</p>\n<p>It seems obvious to have that feature in a typed language that allows low-level programming. However, this is not a part of C, C++ or any other language I know, and I did not find any discussion about this online.</p>\n<h1>Update</h1>\n<p>I'll try to summarize some takeaways from the many comments that I got in the first hour after asking:</p>\n<ol>\n<li>signedness is strictly binary (either signed or unsigned) and will always be, in contrast to endianness, which also has two well-known variants (big and little), but also lesser-known variants such as mixed/middle endian. New variants might be invented in the future.</li>\n<li>endianness matters when accessing multiple-byte values byte-wise. There are many aspects beyond just endianness that affect the memory layout of multi-byte structures, so this kind of access is mostly discouraged.</li>\n<li>C++ aims to target an <a href=\"http://eel.is/c++draft/intro.abstract#1\" rel=\"nofollow noreferrer\">abstract machine</a> and minimize the number of assumptions about the implementation. This abstract machine does not have <em>any</em> endianness.</li>\n</ol>\n<p>Also, now I realize that signedness and endianness are not a perfect analogy, because:</p>\n<ul>\n<li>endianness only defines <em>how</em> something is represented as a binary sequence, but now <em>what can be</em> represented. Both <code>big int</code> and <code>little int</code> would have the exact same value range.</li>\n<li>signedness defines <em>how</em> bits and actual values map to each other, but also affects <em>what can be</em> represented, e.g. -3 can't be represented by an <code>unsigned char</code> and (assuming that <code>char</code> has 8 bits) 130 can't be represented by a <code>signed char</code>.</li>\n</ul>\n<p>So that changing the endianness of some variables would never change the behavior of the program (except for byte-wise access), whereas a change of signedness usually would.</p>\n", "Tags": "<c++><endianness><language-features><static-typing>", "OwnerUserId": "39946", "AnswerCount": "9"}, "47557268": {"ParentId": "47531139", "CommentCount": "0", "Body": "<p>From a pragmatic programmer perspective searching Stack Overflow, it's worth noting that the spirit of this question can be answered with a utility library.  Boost has such a library:</p>\n<p><a href=\"http://www.boost.org/doc/libs/1_65_1/libs/endian/doc/index.html\" rel=\"nofollow noreferrer\">http://www.boost.org/doc/libs/1_65_1/libs/endian/doc/index.html</a></p>\n<p>The feature of the library most like the language feature under discussion is a set of arithmetic types such as <code>big_int16_t</code>.</p>\n", "OwnerUserId": "1401351", "PostTypeId": "2", "Id": "47557268", "Score": "1", "CreationDate": "2017-11-29T16:18:56.817", "LastActivityDate": "2017-11-29T16:18:56.817"}, "47556553": {"ParentId": "47531139", "CommentCount": "0", "Body": "<p>Endianness is not inherently a part of a data type but rather of its storage layout.</p>\n<p>As such, it would not be really akin to signed/unsigned but rather more like bit field widths in structs.  Similar to those, they could be used for defining binary APIs.</p>\n<p>So you'd have something like</p>\n<pre><code>int ip : big 32;\n</code></pre>\n<p>which would define both storage layout and integer size, leaving it to the compiler to do the best job of matching use of the field to its access.  It's not obvious to me what the allowed declarations should be.</p>\n", "Id": "47556553", "PostTypeId": "2", "OwnerDisplayName": "user9026597", "Score": "2", "CreationDate": "2017-11-29T15:41:19.557", "LastActivityDate": "2017-11-29T15:41:19.557"}, "47541644": {"ParentId": "47531139", "CommentCount": "0", "Body": "<p>Endianness is compiler specific as a result of being machine specific, not as a support mechanism for platform independence. The standard -- is an abstraction that has no regard for imposing rules that make things \"easy\" -- its task is to create similarity between compilers that allows the programmer to create \"platform independence\" for their code -- if they choose to do so.</p>\n<p>Initially, there was a lot of competition between platforms for market share and also -- compilers were most often written as proprietary tools by microprocessor manufacturers and to support operating systems on specific hardware platforms. Intel was likely not very concerned about writing compilers that supported Motorola microprocessors.</p>\n<p>C was -- after all -- invented by Bell Labs to rewrite Unix.</p>\n", "OwnerUserId": "3843815", "PostTypeId": "2", "Id": "47541644", "Score": "-1", "CreationDate": "2017-11-28T22:01:48.840", "LastActivityDate": "2017-11-28T22:01:48.840"}, "47532217": {"ParentId": "47531139", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>In addition to YSC's answer, let's take your sample code, and consider what it might aim to achieve</p>\n<pre><code>struct foo {\n    little int x;   // little-endian\n    big long int y; // big-endian\n    short z;        // native endianness\n};\n</code></pre>\n<p>You might hope that this would exactly specify layout for architecture-independent data interchange (file, network, whatever)</p>\n<p>But this can't possibly work, because several things are still unspecified:</p>\n<ul>\n<li>data type size: you'd have to use <code>little int32_t</code>, <code>big int64_t</code> and <code>int16_t</code> respectively, if that's what you want</li>\n<li>padding and alignment, which cannot be controlled strictly within the language: use <code>#pragma</code> or <code>__attribute__((packed))</code> or some other compiler-specific extension</li>\n<li>actual format (1s- or 2s-complement signedness, floating-point type layout, trap representations)</li>\n</ul>\n<p>Alternatively, you might simply want to reflect the endianness of some specified hardware - but <code>big</code> and <code>little</code> don't cover all the possibilities here (just the two most common).</p>\n<p>So, the proposal is incomplete (it doesn't distinguish all reasonable byte-ordering arrangements), ineffective (it doesn't achieve what it sets out to), and has additional drawbacks:</p>\n<ul>\n<li><p>Performance</p>\n<p>Changing the endianness of a variable from the native byte ordering should either disable arithmetic, comparisons etc (since the hardware <em>cannot</em> correctly perform them on this type), or must silently inject more code, creating natively-ordered temporaries to work on.</p>\n<p>The argument here isn't that manually converting to/from native byte order is <em>faster</em>, it's that controlling it explicitly makes it easier to minimise the number of unnecessary conversions, and much easier to reason about how code will behave, than if the conversions are implicit.</p></li>\n<li><p>Complexity</p>\n<p>Everything overloaded or specialized for integer types now needs twice as many versions, to cope with the rare event that it gets passed a non-native-endianness value. Even if that's just a forwarding wrapper (with a couple of casts to translate to/from native ordering), it's still a lot of code for no discernible benefit.</p></li>\n</ul>\n<p>The final argument against changing the language to support this is that you can easily do it in code. Changing the language syntax is a big deal, and doesn't offer any obvious benefit over something like a type wrapper:</p>\n<pre><code>// store T with reversed byte order\ntemplate &lt;typename T&gt;\nclass Reversed {\n    T val_;\n    static T reverse(T); // platform-specific implementation\npublic:\n    explicit Reversed(T t) : val_(reverse(t)) {}\n    Reversed(Reversed const &amp;other) : val_(other.val_) {}\n    // assignment, move, arithmetic, comparison etc. etc.\n    operator T () const { return reverse(val_); }\n};\n</code></pre>\n", "OwnerUserId": "212858", "LastEditorUserId": "212858", "LastEditDate": "2017-11-29T10:22:07.840", "Id": "47532217", "Score": "34", "CreationDate": "2017-11-28T12:58:45.477", "LastActivityDate": "2017-11-29T10:22:07.840"}, "47543039": {"ParentId": "47531139", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Short Answer: if it should not be possible to use objects in arithmetic expressions (with no overloaded operators) involving ints, then these objects should not be integer types.  And there is no point in allowing addition and multiplication of big-endian and little-endian ints in the same expression.</p>\n<p>Longer Answer:</p>\n<p>As someone mentioned, endianness is processor-specific.  Which really means that this is how numbers are represented when they are used as numbers in the machine language (as addresses and as operands/results of arithmetic operations).</p>\n<p>The same is \"sort of\" true of signage.  But not to the same degree.  Conversion from language-semantic signage to processor-accepted signage is something that needs to be done to use numbers as numbers.  Conversion from big-endian to little-endian and reverse is something that needs to be done to use numbers as data (send them over the network or represent metadata about data sent over the network such as payload lengths).  </p>\n<p>Having said that, this decision appears to be mostly driven by use cases.  The flip side is that there is a good pragmatic reason to ignore certain use cases.  The pragmatism arises out of the fact that endianness conversion is more expensive than most arithmetic operations. </p>\n<p>If a language had semantics for keeping numbers as little-endian, it would allow developers to shoot themselves in the foot by forcing little-endianness of numbers in a program which does a lot of arithmetic.  If developed on a little-endian machine, this enforcing of endianness would be a no-op.  But when ported to a big-endian machine, there would a lot of unexpected slowdowns.  And if the variables in question were used both for arithmetic and as network data, it would make the code completely non-portable.  </p>\n<p>Not having these endian semantics or forcing them to be explicitly compiler-specific forces the developers to go through the mental step of thinking of the numbers as being \"read\" or \"written\" to/from the network format.  This would make the code which converts back and forth between network and host byte order, in the middle of arithmetic operations, cumbersome and less likely to be the preferred way of writing by a lazy developer.  </p>\n<p>And since development is a human endeavor, making bad choices uncomfortable is a Good Thing(TM).</p>\n<p><strong>Edit</strong>:  here's an example of how this can go badly:\n<em>Assume</em> that <code>little_endian_int32</code> and <code>big_endian_int32</code> types are introduced.  Then <code>little_endian_int32(7) % big_endian_int32(5)</code> is a constant expression.  What is its result?  Do the numbers get implicitly converted to the native format?  If not, what is the type of the result?  Worse yet, what is the value of the result (which in this case should probably be the same on every machine)?  </p>\n<p>Again, if multi-byte numbers are used as plain data, then char arrays are just as good.  Even if they are \"ports\" (which are really lookup values into tables or their hashes), they are just sequences of bytes rather than integer types (on which one can do arithmetic).  </p>\n<p>Now if you limit the allowed arithmetic operations on explicitly-endian numbers to only those operations allowed for pointer types, then you might have a better case for predictability.  Then <code>myPort + 5</code> actually makes sense even if <code>myPort</code> is declared as something like <code>little_endian_int16</code> on a big endian machine.  Same for <code>lastPortInRange - firstPortInRange + 1</code>.  If the arithmetic works as it does for pointer types, then this would do what you'd expect, but <code>firstPort * 10000</code> would be illegal.  </p>\n<p>Then, of course, you get into the argument of whether the feature bloat is justified by any possible benefit.</p>\n", "OwnerUserId": "1219722", "LastEditorUserId": "1219722", "LastEditDate": "2017-11-30T00:34:16.047", "Id": "47543039", "Score": "0", "CreationDate": "2017-11-29T00:12:43.233", "LastActivityDate": "2017-11-30T00:34:16.047"}, "bq_ids": {"n4140": {"so_47531139_47531235_0": {"section_id": 5797, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_47531139_47531235_0": {"section_id": 5570, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_47531139_47531235_0": {"section_id": 7256, "quality": 0.8857142857142857, "length": 31}}}, "47531409": {"ParentId": "47531139", "CommentCount": "2", "Body": "<p>That's a good question and I have often thought something like this would be useful. However you need to remember that C aims for platform independence and endianness is only important when a structure like this is converted into some underlying memory layout. This conversion can happen when you cast a uint8_t buffer into an int for example. While an endianness modifier looks neat the programmer still needs to consider other platform differences such as int sizes and structure alignment and packing.\nFor defensive programming when you want find grain control over how some variables or structures are represented in a memory buffer then it is best to code  explicit conversion functions and then let the compiler optimiser generate the most efficient code for each supported platform.</p>\n", "OwnerUserId": "6736863", "PostTypeId": "2", "Id": "47531409", "Score": "2", "CreationDate": "2017-11-28T12:15:55.757", "LastActivityDate": "2017-11-28T12:15:55.757"}});