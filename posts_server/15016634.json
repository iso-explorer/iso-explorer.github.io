post_cb({"bq_ids": {"n4140": {"so_15016634_15016634_2": {"length": 45, "quality": 0.9782608695652174, "section_id": 6106}, "so_15016634_15016634_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 6105}}, "n3337": {"so_15016634_15016634_2": {"length": 45, "quality": 0.9782608695652174, "section_id": 5872}, "so_15016634_15016634_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 5871}, "so_15016634_15016634_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5871}}, "n4659": {"so_15016634_15016634_2": {"length": 45, "quality": 0.9782608695652174, "section_id": 7603}, "so_15016634_15016634_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7602}}}, "15016634": {"ViewCount": "89", "Body": "<p>I can't understand what standard need to do with calling operator delete for void* == nullptr.</p>\n<p>Something like this:</p>\n<pre><code>void foo(void* ptr) // ptr == nullptr here\n{\n    delete ptr;\n}\n</code></pre>\n<p>On the one hand, we have the following statement in standard:</p>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<p>5.3.5 Delete [expr.delete]</p>\n<blockquote>\n<p id=\"so_15016634_15016634_0\">1 ... The operand shall have a pointer to object type, or a class type\n  having a single non-explicit conversion function (12.3.2) to a pointer\n  to object type. The result has type void.78</p>\n<p id=\"so_15016634_15016634_1\">78) <strong>This implies that an object cannot be deleted using a pointer of\n  type void* because void is not an object type</strong>.</p>\n</blockquote>\n<p>which makes code with deleting void* ill-formed. On the other hand, we have another statement about nullptr in delete:</p>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<p>5.3.5 Delete [expr.delete]</p>\n<blockquote>\n<p id=\"so_15016634_15016634_2\">2 ... In the first alternative (delete object), <strong>the value of the\n  operand of delete may be a null pointer value</strong>, a pointer to a\n  non-array object created by a previous new-expression, or a pointer to\n  a subobject (1.8) representing a base class of such an object (Clause\n  10). If not, the behavior is undefined. In the second alternative\n  (delete array), <strong>the value of the operand of delete may be a null\n  pointer value</strong> or a pointer value that resulted from a previous array\n  new-expression.79 If not, the behavior is undefined.</p>\n</blockquote>\n<p>What implementation need to do in such kind of situation?</p>\n", "AcceptedAnswerId": "15016687", "Title": "operator delete standard behavior", "CreationDate": "2013-02-22T04:03:59.740", "Id": "15016634", "CommentCount": "3", "LastEditDate": "2013-02-22T04:09:49.393", "PostTypeId": "1", "LastEditorUserId": "1608835", "LastActivityDate": "2013-02-22T04:47:57.750", "Score": "1", "OwnerUserId": "1608835", "Tags": "<c++>", "AnswerCount": "1"}, "15016687": {"Id": "15016687", "PostTypeId": "2", "Body": "<p>Null and <code>void*</code> are two different things:</p>\n<pre><code>delete static_cast&lt;int*&gt;(nullptr); // deleting null pointer, of int*\n</code></pre>\n<p>Your given code would be ill-formed, but it has nothing to do with the <em>value</em> of the pointer (which may be null), but its <em>type</em> (which cannot be <code>void*</code>).</p>\n", "LastEditorUserId": "1053", "LastActivityDate": "2013-02-22T04:47:57.750", "Score": "3", "CreationDate": "2013-02-22T04:10:17.960", "ParentId": "15016634", "CommentCount": "3", "OwnerUserId": "87234", "LastEditDate": "2013-02-22T04:47:57.750"}});