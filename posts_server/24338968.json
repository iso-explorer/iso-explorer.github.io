post_cb({"bq_ids": {"n4140": {"so_24338968_24339068_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 5768}, "so_24338968_24339068_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 3291}}, "n3337": {"so_24338968_24339068_1": {"length": 14, "quality": 1.0, "section_id": 5}, "so_24338968_24339068_0": {"length": 14, "quality": 1.0, "section_id": 3161}}, "n4659": {"so_24338968_24339068_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 7225}, "so_24338968_24339068_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 4053}}}, "24338968": {"ViewCount": "63", "Body": "<p>In  <strong>C++ Primer Plus (6th. edition)</strong>, page 73, it states:</p>\n<blockquote>\n<p id=\"so_24338968_24338968_0\">If you don't initialize a variable that is defined inside a function,\n  the variable's value is <em>indeterminate</em>. That means the value of\n  whatever happened to be sitting at that memory location prior to the\n  creation of that variable.</p>\n</blockquote>\n<p>Does that mean I can use an uninitialized variable to get data on the memory location at that point in the program? If true, are there any instances where this property is useful?</p>\n", "AcceptedAnswerId": "24339068", "Title": "Are there any uses with unitialized variables?", "CreationDate": "2014-06-21T06:27:24.117", "Id": "24338968", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-06-21T08:28:08.287", "Score": "1", "OwnerUserId": "2317532", "Tags": "<c++><memory><initialization>", "AnswerCount": "2"}, "24339783": {"Id": "24339783", "PostTypeId": "2", "Body": "<p>While the standard effectively forbids ever using the value of an uninitialized variable, you are usually able to read it anyway, and it will usually indeed contain whatever value was last stored at that location.</p>\n<p>However, this information is not useful in any way. Since your program always runs in its own private virtual address space, anything you might read <em>has been written by your own program</em>. I. e., it's information that you have already anyway, and which you can pass around in much more secure ways. This is especially true if you are using an uninitialized variable within a function: all you will ever be able to see that way is information that was written to a local variable by some function that you called earlier.</p>\n<p>You might be able to find out some internals of the standard C library and other libraries that you use because their code runs within your address space. But most information will not be stored on the stack anyway, so you would need to read data from some other memory locations than an uninitialized variable. You would need to dereference pointers to stuff that you don't own, and that is really deep down in undefined behaviour. If you try this, you will most likely get segfaults.</p>\n<p>So, yes, it's possible, but...</p>\n", "LastActivityDate": "2014-06-21T08:28:08.287", "CommentCount": "0", "CreationDate": "2014-06-21T08:28:08.287", "ParentId": "24338968", "Score": "1", "OwnerUserId": "2445184"}, "24339068": {"Id": "24339068", "PostTypeId": "2", "Body": "<p>The standard's wording for what you quoted is as follows (<em>\u00a78.5 [dcl.init]</em>):</p>\n<blockquote>\n<p id=\"so_24338968_24339068_0\">If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value.</p>\n</blockquote>\n<p>The book is a little misleading about the previous value being available at that location. It is often true, but not necessarily.</p>\n<p>The important point is that accessing the value of such a object results in <em>undefined behaviour</em>. Accessing the value of a object is formally known as lvalue-to-rvalue conversion, which says this (<em>\u00a74.1 [conv.lval]</em>):</p>\n<blockquote>\n<p id=\"so_24338968_24339068_1\">If the object to which the glvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior.</p>\n</blockquote>\n<p>This occurs only when an operator in an expression requires an rvalue operand, which is usually the case. However, the unary <code>&amp;</code> operator requires an lvalue operand, so lvalue-to-rvalue conversion is not applied. That means taking the address of an uninitialized variable is fine. This makes logical sense, because the object exists and has a valid address, it just isn't initialized. Taking the address doesn't require accessing the object's value.</p>\n<p>Why would you do this? It's hard to think of a specific example because the idea is very broad and because we don't often leave our variables uninitialized (if at all). If you needed to store the address of an object before you assigned a value to it though, this is what you would need to do. You could later access the object through that pointer (once it has been assigned to). In fact, you could assign to it through the pointer.</p>\n", "LastActivityDate": "2014-06-21T06:38:56.223", "CommentCount": "9", "CreationDate": "2014-06-21T06:38:56.223", "ParentId": "24338968", "Score": "4", "OwnerUserId": "150634"}});