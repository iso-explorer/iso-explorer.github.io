post_cb({"16214483": {"Id": "16214483", "PostTypeId": "2", "Body": "<p>There are two types of templates: Templates for generic types, and templates with specified types.</p>\n<p>The templates for generic types like like</p>\n<pre><code>template&lt;typename T&gt;\n</code></pre>\n<p>or</p>\n<pre><code>template&lt;class T&gt;\n</code></pre>\n<p>These templates can be used with just about any type. The actual usage of these types may limit the actual types that can be use though.</p>\n<p>Templates with specified types are like the one you have in your question:</p>\n<pre><code>template&lt;int VAL&gt;\n</code></pre>\n<p>They can only be used with template arguments matching the specified type. In this case only integer literals can be used.</p>\n", "LastEditorUserId": "440558", "LastActivityDate": "2013-04-25T12:20:49.073", "Score": "0", "CreationDate": "2013-04-25T12:15:24.317", "ParentId": "16214422", "CommentCount": "2", "OwnerUserId": "440558", "LastEditDate": "2013-04-25T12:20:49.073"}, "16214550": {"Id": "16214550", "PostTypeId": "2", "Body": "<p>You can only pass integral values as non-type template parameters. That's a limitation of the language. You probably want something as follows:</p>\n<pre><code>template&lt;class T&gt;\nvoid printVAL(const T&amp; t)\n{\n    for (auto&amp; x : t) {\n        cout &lt;&lt; \" x value is \"&lt;&lt; x &lt;&lt; '\\n';\n    }\n}\n</code></pre>\n<p>This would print anything: containers, strings, arrays, etc.</p>\n", "OwnerDisplayName": "user283145", "LastActivityDate": "2013-04-25T12:18:19.730", "Score": "0", "CreationDate": "2013-04-25T12:18:19.730", "ParentId": "16214422", "CommentCount": "0"}, "16214422": {"ViewCount": "458", "Body": "<p>I tried the following code.</p>\n<pre><code>template &lt;int VAL&gt;\nvoid printVAL()\n{\n    for(int i=0;i&lt;VAL; i++){\n        cout &lt;&lt; \" i value is \"&lt;&lt;i&lt;&lt;endl;\n    }\n}\n</code></pre>\n<p>instantiation:\n    printVAL&lt;100&gt;()</p>\n<p>When i use (<strong>std::string s</strong> )  as  a non type template parameter, the compiler shouted at me with the following error</p>\n<pre><code>\"class std::basic_str&lt;char&gt;' is not a valid type for a template non-type parameter.\n</code></pre>\n<p>What i know is we should use only constant integral values only. Not even double.</p>\n<p><strong>Question:</strong></p>\n<p>1)  why we should not use std::string, what bothers ? </p>\n<p>2) What is the meaning of 'pointers to objects with external linkage can be used'. can i get any sample code for it?</p>\n", "AcceptedAnswerId": "16214727", "Title": "pointers to object with external linkage to Nontype template parameters", "CreationDate": "2013-04-25T12:12:57.903", "Id": "16214422", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-25T19:38:31.500", "Score": "1", "OwnerUserId": "916439", "Tags": "<c++><templates>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_16214422_16214727_0": {"length": 8, "quality": 1.0, "section_id": 57}}, "n3337": {"so_16214422_16214727_0": {"length": 8, "quality": 1.0, "section_id": 52}, "so_16214422_16215019_2": {"length": 133, "quality": 0.875, "section_id": 5947}}, "n4659": {"so_16214422_16214727_0": {"length": 8, "quality": 1.0, "section_id": 59}}}, "16215019": {"Id": "16215019", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16214422_16215019_0\">1) why we should not use std::string, what bothers ?</p>\n</blockquote>\n<p>Compiler must be able to deduce and substitute template parameters at compile time. This can't be done with a <code>std::string</code> object, it could (and usualy does) change at runtime.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/5687540/non-type-template-parameters\">this Q&amp;A</a>.</p>\n<blockquote>\n<p id=\"so_16214422_16215019_1\">2) What is the meaning of 'pointers to objects with external linkage can be used'. can i get any sample code for it?</p>\n</blockquote>\n<p>That's because the address of an object with static storage duration (which object declared <code>extern</code> are) is a constant expression.</p>\n<p>n3337 5.19/3, emphasis mine:</p>\n<blockquote>\n<p id=\"so_16214422_16215019_2\">A literal constant expression is a prvalue core constant expression of literal type, but not pointer type. An\n  integral constant expression is a literal constant expression of integral or unscoped enumeration type. [ Note:\n  Such expressions may be used as array bounds (8.3.4, 5.3.4), as bit-\ufb01eld lengths (9.6), as enumerator initializ-\n  ers if the underlying type is not \ufb01xed (7.2), as null pointer constants (4.10), and as alignments (7.6.2). \u2014end\n  note ] A converted constant expression of type T is a literal constant expression, implicitly converted to type T,\n  where the implicit conversion (if any) is permitted in a literal constant expression and the implicit conversion\n  sequence contains only user-de\ufb01ned conversions, lvalue-to-rvalue conversions (4.1), integral promotions (4.5),\n  and integral conversions (4.7) other than narrowing conversions (8.5.4). [ Note: such expressions may be used\n  as case expressions (6.4.2), as enumerator initializers if the underlying type is \ufb01xed (7.2), and as integral or\n  enumeration non-type template arguments (14.3). \u2014end note ] A reference constant expression is an lvalue\n  core constant expression that designates an object with static storage duration or a function. <strong>An address\n  constant expression is a prvalue core constant expression of pointer type that evaluates to the address of an\n  object with static storage duration</strong>, to the address of a function, or to a null pointer value, or a prvalue core\n  constant expression of type std::nullptr_t. Collectively, literal constant expressions, reference constant\n  expressions, and address constant expressions are called constant expressions.</p>\n</blockquote>\n<p>Example you ask for:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nextern std::string str; // not really neccesary\n\nstd::string str;\n\ntemplate&lt;std::string* ptr&gt;\nstruct S {\n    S() { std::cout &lt;&lt; ptr-&gt;length() &lt;&lt; '\\n'; }\n    ~S() { std::cout &lt;&lt; *ptr; }\n};\n\nint main()\n{\n    S&lt;&amp;str&gt; s;\n    str = \"Hello world!\";\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-25T19:38:31.500", "Score": "0", "CreationDate": "2013-04-25T12:39:15.177", "ParentId": "16214422", "CommentCount": "0", "OwnerUserId": "947836", "LastEditDate": "2017-05-23T12:18:56.493"}, "16214727": {"Id": "16214727", "PostTypeId": "2", "Body": "<p>According to 14.1/4,</p>\n<blockquote>\n<p id=\"so_16214422_16214727_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>\n<ul>\n<li>integral or enumeration type,</li>\n<li>pointer to object or pointer to function,</li>\n<li>lvalue reference to object or lvalue reference to function,</li>\n<li>pointer to member,</li>\n<li><code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n<p>Your <code>std::string</code> is none of those.</p>\n", "LastActivityDate": "2013-04-25T12:25:23.593", "CommentCount": "0", "CreationDate": "2013-04-25T12:25:23.593", "ParentId": "16214422", "Score": "0", "OwnerUserId": "596781"}});