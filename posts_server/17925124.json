post_cb({"bq_ids": {"n4140": {"so_17925124_17925216_1": {"length": 19, "quality": 1.0, "section_id": 6126}, "so_17925124_17925216_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 6126}}, "n3337": {"so_17925124_17925216_1": {"length": 19, "quality": 1.0, "section_id": 5890}, "so_17925124_17925216_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 5890}}, "n4659": {"so_17925124_17925216_1": {"length": 19, "quality": 1.0, "section_id": 7623}, "so_17925124_17925216_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 7623}}}, "17925301": {"Id": "17925301", "PostTypeId": "2", "Body": "<p>Base on your question title, the answere depends. But for your case in your source code, the answere is yes.</p>\n<p>There are two factor which will impact the answere:</p>\n<ol>\n<li><p>If you using C style cast, it will yes, because cast will call re-interpert cast if no conversion availible. You can cast any type of pointer to the target type of pointer. But if there is MI, the result may be incorrect for most C++ language implementation.</p></li>\n<li><p>If you do the cast (without C style cast) inside the memeber function, the answere will be yes, because the base class is accessable inside the member function. If the expression is in the location where the base class is inaccessable, you will got compile error.</p></li>\n</ol>\n<p>There are more detail about standard converstion in the C++ standard</p>\n<pre><code>A prvalue of type \u201cpointer to cv D\u201d, where D is a class type, can be converted to a prvalue of type \u201cpointer to cv B\u201d, where B is a base class (Clause 10) of D. \nIf B is an inaccessible (Clause 11) or ambiguous (10.2) base class of D, a program that necessitates this conversion is ill-formed. \nThe result of the conversion is a pointer to the base class subobject of the derived class object. The null pointer value is converted to the null pointer value of the destination type.\n</code></pre>\n<p>Edit 2: make the answere more detail.</p>\n", "LastEditorUserId": "2428052", "LastActivityDate": "2013-07-29T13:42:03.527", "Score": "-5", "CreationDate": "2013-07-29T13:24:34.460", "ParentId": "17925124", "CommentCount": "3", "OwnerUserId": "2428052", "LastEditDate": "2013-07-29T13:42:03.527"}, "17925216": {"Id": "17925216", "PostTypeId": "2", "Body": "<p>Yes you can: \u00a75.4/7 of the standard:</p>\n<blockquote>\n<p id=\"so_17925124_17925216_0\">... the following static_cast and reinterpret_cast operations\n  (optionally followed by a const_cast operation) may be performed using\n  the cast notation of explicit type conversion, even if the base class\n  type is not accessible:</p>\n<p id=\"so_17925124_17925216_1\">a pointer to an object of derived class type or an lvalue of derived\n  class type may be explicitly converted to a pointer or reference to an\n  unambiguous base class type, respectively;</p>\n</blockquote>\n<p>But <em>try not to</em> as it defeats the purpose of private inheritance.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2013-07-29T13:31:56.097", "Score": "14", "CreationDate": "2013-07-29T13:21:22.107", "ParentId": "17925124", "CommentCount": "6", "OwnerUserId": "2380830", "LastEditDate": "2013-07-29T13:31:56.097"}, "17925124": {"ViewCount": "2037", "Body": "<p>Can I do this?</p>\n<pre><code>class A { ... };\n\nclass B : private A\n{\n    const A &amp;foo() const\n    {\n        return *((const A *)this);\n    }\n};\n</code></pre>\n<p>Can I take a subclass that inherits privately from a base class and cast it to a public version of its base class? Can I do this without it having virtual methods?</p>\n<p>My guess is yes, but I wanted to make sure it's safe / portable.</p>\n", "AcceptedAnswerId": "17925216", "Title": "Can I cast a derived class to a private base class, using C-style cast?", "CreationDate": "2013-07-29T13:16:39.400", "Id": "17925124", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-03-31T08:43:12.680", "LastEditorUserId": "1505939", "LastActivityDate": "2016-03-31T08:43:12.680", "Score": "15", "OwnerUserId": "125189", "Tags": "<c++><casting><upcasting><private-inheritance>", "AnswerCount": "3"}, "17925319": {"Id": "17925319", "PostTypeId": "2", "Body": "<p>Yes, that is explicitly allowed. Alexandrescu uses this extensively in <a href=\"http://books.google.de/books/about/Modern_C++_Design.html?id=GPL1r8rQU6wC&amp;redir_esc=y\">Modern C++ Design</a> for his approach of policy based design:</p>\n<pre><code>template &lt;typename Policy&gt;\nclass foo : Policy\n{\n    public:\n        void do_something()\n        {\n            Policy &amp; p = *this;\n            p.do_something();\n        }\n};\n</code></pre>\n<p>So while the use cases may be limited, there are some out there.</p>\n", "LastActivityDate": "2013-07-29T13:25:06.753", "CommentCount": "3", "CreationDate": "2013-07-29T13:25:06.753", "ParentId": "17925124", "Score": "8", "OwnerUserId": "1056003"}});