post_cb({"6562786": {"PostTypeId": "2", "Body": "<p>One can only <code>delete</code> exactly what is returned from <code>new</code>, and same applies to <code>new[]</code> and <code>delete[]</code>.</p>\n<p>It is <strong><em>Undefined Behavior</em></strong> to pass any address to delete which was not returned by new.\nHere is the quote from the C++ Standard.</p>\n<p><strong>\u00a7 3.7.4.2-3</strong></p>\n<blockquote>\n<p id=\"so_6562771_6562786_0\"><em>If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect. Otherwise, the value supplied to operator <code>delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either operator <code>new(std::size_t)</code> or operator <code>new(std::size_t, const std::nothrow_-t&amp;)</code> in the standard library, and the value supplied to operator <code>delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either operator <code>new[](std::size_t)</code> or operator <code>new[](std::size_t, const std::nothrow_t&amp;)</code> in the standard library.</em></p>\n</blockquote>\n", "LastActivityDate": "2011-07-03T12:19:38.653", "LastEditorUserId": "452307", "Id": "6562786", "CommentCount": "2", "CreationDate": "2011-07-03T12:14:31.367", "ParentId": "6562771", "Score": "2", "OwnerUserId": "452307", "LastEditDate": "2011-07-03T12:19:38.653"}, "6562793": {"PostTypeId": "2", "Body": "<pre><code>k = new char*;\n</code></pre>\n<p>This allocated storage for only a single <code>char*</code>.</p>\n<pre><code>*(k + 1) = k2;\n</code></pre>\n<p>This tries to pretend there are two <code>char*</code>s allocated. This may not be the site of the segfault, but it is the error.</p>\n<pre><code>delete [] (k + 1);\n</code></pre>\n<p>Here you're trying to <code>delete[]</code> something you did not <code>new[]</code>, another error.</p>\n<p><strong>EDIT:</strong> Deep down, memory is allocated in large chunks, such as pages. So when you allocate a small bit of storage, it's very likely that the memory around it is also valid. It's still very invalid to access it, though.</p>\n<p>More to the point, when you say something like <code>new char*</code>, this turns into a call to <code>operator new(sizeof(char*))</code>. Let's say the OS allocates a new 4K page of physical RAM for that at address <code>0x12340000</code>. The memory manager needs a small structure in there to keep track of the block, something like:</p>\n<pre><code>struct mem_block_info {\n    void* next_block;\n    size_t block_size;\n};\n</code></pre>\n<p>So it puts this structure at <code>0x12340000</code>. Immediately after that, it puts the storage you requested, so (assuming this is a 32-bit machine) it returns a pointer of <code>0x12340008</code>, since <code>sizeof(void*) == sizeof(size_t) == 4</code>. Then it needs to put a header after your storage to track the unused part of that 4K page, so it doesn't waste memory by allocating another 4K page when you want another <code>char*</code>. That header goes at the address right past the end of your allocated block, <code>0x1234000C</code>. Once the dust settles, that <code>new char*</code> has put this in memory:</p>\n<pre><code>Address    Data\n0x12340000 0x00000000\n0x12340004 0x00000001\n0x12340008 uninitialized; could be anything\n0x1234000C 0x00000000\n0x12340010 0x00000FF4\n</code></pre>\n<p>The null pointers indicate the end of the allocated and free block linked lists.</p>\n<p>So when you do:</p>\n<pre><code>*(k + 1) = k2;\n</code></pre>\n<p><code>k + 1 == 0x1234000C</code> is the <code>next_block</code> pointer for the free block, and you just overwrote it with an invalid value (the address of a string in read-only memory, most likely). This does not immediately cause a segmentation fault, but when the memory manager tries to traverse the free block list, it will wind up looking at that string and misinterpreting it as a block header, then going to the <code>next_block</code> from there which is an invalid address, and boom, segfault.</p>\n", "LastActivityDate": "2011-07-03T12:34:52.800", "LastEditorUserId": "2624511", "Id": "6562793", "CommentCount": "6", "CreationDate": "2011-07-03T12:15:02.647", "ParentId": "6562771", "Score": "3", "OwnerUserId": "2624511", "LastEditDate": "2011-07-03T12:34:52.800"}, "bq_ids": {"n4140": {"so_6562771_6562786_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 7182}}, "n3337": {"so_6562771_6562786_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 6926}}}, "6562788": {"PostTypeId": "2", "Body": "<p><code>k + 1</code> isn't created using <code>new[]</code>. How can you then <code>delete[]</code> it?</p>\n<p>They always come in pairs.</p>\n", "LastActivityDate": "2011-07-03T12:14:39.783", "Id": "6562788", "CommentCount": "0", "CreationDate": "2011-07-03T12:14:39.783", "ParentId": "6562771", "Score": "1", "OwnerUserId": "597607"}, "6562771": {"ViewCount": "155", "Body": "<pre><code>int main() {\n\n  char** k;\n\n  k = new char*;\n\n  char* k1 = \"abc\";\n  char* k2 = \"def\";\n\n  *k = k1;\n  *(k + 1) = k2;\n  delete [] (k + 1);\n\n\n}\n</code></pre>\n<p>Error: segmentation fault</p>\n<p>Could someone explain why I get segmentation fault when freeing (k + 1)? I was able to free k with no problems.</p>\n<p><strong>ADD:</strong> In the answers it has been said that I can't <code>delete [] (k + 1)</code> since I haven't used new on it; But how do you explain the fact that <code>cout&lt;&lt;*(k + 1)&lt;&lt;endl;</code> printed correctly?</p>\n", "AcceptedAnswerId": "6562793", "Title": "Memory allocation question in C++", "CreationDate": "2011-07-03T12:10:57.407", "Id": "6562771", "CommentCount": "0", "LastEditDate": "2011-07-03T12:28:50.910", "PostTypeId": "1", "LastEditorUserId": "295128", "LastActivityDate": "2011-07-03T12:34:52.800", "Score": "-4", "OwnerUserId": "295128", "Tags": "<c++><memory-management>", "AnswerCount": "4"}, "6562790": {"PostTypeId": "2", "Body": "<p>You can <code>delete</code> only the exact pointers returned by <code>new</code>. Everything else is illegal.</p>\n", "LastActivityDate": "2011-07-03T12:14:47.263", "Id": "6562790", "CommentCount": "0", "CreationDate": "2011-07-03T12:14:47.263", "ParentId": "6562771", "Score": "1", "OwnerUserId": "16102"}});