post_cb({"36813760": {"ViewCount": "63", "Body": "<p>I have been writing in c++ for a few months, and i am comfortable enough with it now to begin implementing my own library, consisting of things that i have found myself reusing again and again. One thing that nagged me was the fact that you always had to provide a beginning and end iterator for functions like <code>std::accumulate</code>,<code>std::fill</code> etc...</p>\n<p>The option to provide a qualified container was completely absent and it was simply an annoyance to write begin and end over and over. So, I decided to add this functionality to my library, but i came across problem, i couldn't figure out the best approach of doing so. Here were my general solutions:</p>\n<p><strong>1. Macros</strong> <br><br>\n        - A macro that encapsulates an entire function call<br>\n              ex. <code>QUICK_STL(FCall)</code> <br><br>\n        - A macro that takes the container, function name, and optional args<br>\n              ex. <code>QUICK_STL(C,F,Args...)</code> </br></br></br></br></br></br></p>\n<p><strong>2. Wrapper Function/Functor</strong> <br><br>\n        - A class that takes the container, function name, and optional args<br>\n              ex. <code>quick_stl(F, C, Args...)</code> <br/></br></br></br></p>\n<p><strong>3. Overload Functions</strong><br><br>\n        - Overload every function in namespace <code>std</code> OR my library namespace<br>\nex           </br></br></br></p>\n<pre><code>namespace std { // or my library root namespace 'cherry' \n    template &lt;typename C, typename T&gt;\n    decltype(auto) count(const C&amp; container, const T&amp; value);\n}\n</code></pre>\n<p><br><br/></br></p>\n<p>I usually steer clear of macros, but in this case it could certainty save <em>alot</em>\nof lines of code from being written. With regards to function overloading, every single function that i want to use i must overload, which wouldn't really scale. The upside to that approach though is that you retain the names of the functions. With perfect forwarding and <code>decltype(auto)</code> overloading becomes alot easier, but still will take time to implement, and would have to be modified if ever another function was added. As to whether or not i should overload the <code>std</code> namespace i am rather skeptical on whether or not it would be appropriate in this case. </p>\n<p><em>What would be the most appropriate way of going about overloading functions in the STD namespace (note these functions will only serve as proxy's to the original functions)?</em></p>\n", "Title": "STL Extension/Modification Best Practice", "CreationDate": "2016-04-23T16:57:47.250", "LastActivityDate": "2016-04-23T17:23:31.167", "CommentCount": "1", "PostTypeId": "1", "Id": "36813760", "Score": "1", "OwnerUserId": "6162032", "Tags": "<c++><visual-c++><c++14>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36813760_36813965_5": {"length": 33, "quality": 0.9428571428571428, "section_id": 6299}}, "n3337": {"so_36813760_36813965_5": {"length": 33, "quality": 0.9428571428571428, "section_id": 6056}}, "n4659": {"so_36813760_36813965_5": {"length": 33, "quality": 0.9428571428571428, "section_id": 7808}}}, "36813965": {"Id": "36813965", "PostTypeId": "2", "Body": "<p>You need to read this: <a href=\"https://softwareengineering.stackexchange.com/questions/231336/why-do-all-algorithm-functions-take-only-ranges-not-containers\">Why do all  functions take only ranges, not containers?</a> </p>\n<p>And This: <a href=\"https://stackoverflow.com/questions/14003627/stl-algorithms-why-no-additional-interface-for-containers-additional-to-iterat\">STL algorithms: Why no additional interface for containers (additional to iterator pairs)?</a> </p>\n<blockquote>\n<p id=\"so_36813760_36813965_0\">I have been writing in c++ for a <strong>few months</strong>, and i am comfortable\n  enough with it now to begin implementing my own library...</p>\n</blockquote>\n<p>Let me look on the brighter side and just say... Some of us have been there before.... :-)</p>\n<blockquote>\n<p id=\"so_36813760_36813965_1\">One thing that nagged me was the fact that you always had to provide a\n  beginning and end iterator for functions like\n  std::accumulate,std::fill etc...</p>\n</blockquote>\n<p>That's why you have <a href=\"http://www.boost.org/doc/libs/1_60_0/libs/range/doc/html/index.html\" rel=\"nofollow noreferrer\">Boost.Ranges</a> and the Eric's proposed <a href=\"https://github.com/ericniebler/range-v3\" rel=\"nofollow noreferrer\">ranges</a> that seems like it isn't gonna make it to C++17.</p>\n<blockquote id=\"so_36813760_36813965_2\">\n<ol>\n<li>Macros</li>\n</ol>\n</blockquote>\n<p>See <a href=\"https://isocpp.org/wiki/faq/inline-functions#inline-vs-macros\" rel=\"nofollow noreferrer\">Macros</a></p>\n<blockquote id=\"so_36813760_36813965_3\">\n<ol start=\"2\">\n<li>Wrapper Function/Functor</li>\n</ol>\n</blockquote>\n<p>Not too bad...Provided you do it correctly, You can do that, that's what essentially Ranges do for Containers... See the aforementioned implementations</p>\n<blockquote>\n<ol start=\"3\">\n<li><p id=\"so_36813760_36813965_4\">Overload Functions</p>\n<ul>\n<li>Overload every function in namespace <code>std</code> ...</li>\n</ul></li>\n</ol>\n</blockquote>\n<p>Don't do that... The C++ standard doesn't like it.</p>\n<p>See what the standard has to say</p>\n<blockquote>\n<p id=\"so_36813760_36813965_5\"><a href=\"http://eel.is/c++draft/namespace.constraints#namespace.std-1\" rel=\"nofollow noreferrer\"><strong>$17.6.4.2.1</strong></a> The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within\n  namespace std unless otherwise specified. A program may add a template\n  specialization for any standard library template to namespace std only\n  if the declaration depends on a user-defined type and the\n  specialization meets the standard library requirements for the\n  original template and is not explicitly prohibited.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-23T17:23:31.167", "Score": "1", "CreationDate": "2016-04-23T17:15:48.283", "ParentId": "36813760", "CommentCount": "0", "OwnerUserId": "1621391", "LastEditDate": "2017-05-23T12:25:34.067"}});