post_cb({"bq_ids": {"n4140": {"so_13662441_13662441_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 435}}, "n3337": {"so_13662441_13662441_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 427}}, "n4659": {"so_13662441_13662441_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 454}}}, "37661858": {"Id": "37661858", "PostTypeId": "2", "Body": "<p>In theory <code>So why do these inconvenient restrictions exist?...</code> reason is valid but it can rather be easily bypassed and this is exactly what C++ 11 does.</p>\n<p>When you <em>include</em> a file, it simply includes the file and disregards any initialization. The members are initialized only when you <em>instantiate</em> the class.</p>\n<p>In other words, the initialization is still tied with constructor, just the notation is different and is more convenient. If the constructor is not called, the values are not initialized. </p>\n<p>If the constructor is called, the values are initialized with in-class initialization if present or the constructor can override that with own initialization. The path of initialization is essentially the same, that is, via the constructor.</p>\n<p>This is evident from Stroustrup own <a href=\"http://www.stroustrup.com/C++11FAQ.html#member-init\" rel=\"nofollow\">FAQ</a> on C++ 11.</p>\n", "LastEditorUserId": "841330", "LastActivityDate": "2016-06-06T16:57:32.603", "Score": "3", "CreationDate": "2016-06-06T15:56:15.383", "ParentId": "13662441", "CommentCount": "0", "OwnerUserId": "841330", "LastEditDate": "2016-06-06T16:57:32.603"}, "35091533": {"Id": "35091533", "PostTypeId": "2", "Body": "<p>I guess that reasoning might have been written before templates were finalized. After all the \"complicated linker rule(s)\" necessary for in-class initializers of static members was/were already necessary for C++11 to support static members of templates.</p>\n<p>Consider</p>\n<pre><code>struct A { static int s = ::ComputeSomething(); }; // NOTE: This isn't even allowed,\n                                                   // thanks @Kapil for pointing that out\n\n// vs.\n\ntemplate &lt;class T&gt;\nstruct B { static int s; }\n\ntemplate &lt;class T&gt;\nint B&lt;T&gt;::s = ::ComputeSomething();\n\n// or\n\ntemplate &lt;class T&gt;\nvoid Foo()\n{\n    static int s = ::ComputeSomething();\n    s++;\n    std::cout &lt;&lt; s &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>The problem for the compiler is the same in all three cases: in which translation-unit should it emit the definition of <code>s</code> and the code necessary to initialize it? The simple solution is to emit it everywhere and let the linker sort it out. That's why the linkers already supported things like <code>__declspec(selectany)</code>. It just wouldn't have been possible to implement C++03 without it. And that's why it wasn't necessary to extend the linker.</p>\n<p>To put it more bluntly: I think the reasoning given in the old standard is just plain wrong.</p>\n<hr>\n<p><strong>UPDATE</strong></p>\n<p>As Kapil pointed out, my first example isn't even allowed in the current standard (C++14). I left it in anyway, because it IMO is the hardest case for the implementation (compiler, linker). My point is: even <em>that</em> case is not any harder than what's already allowed e.g. when using templates.</p>\n</hr>", "LastEditorUserId": "454519", "LastActivityDate": "2016-05-30T16:38:06.967", "Score": "6", "CreationDate": "2016-01-29T18:29:34.943", "ParentId": "13662441", "CommentCount": "4", "OwnerUserId": "454519", "LastEditDate": "2016-05-30T16:38:06.967"}, "13662441": {"ViewCount": "58020", "Body": "<p>Before C++11, we could only perform in-class initialization on static const members of integral or enumeration type. <a href=\"http://www.stroustrup.com/bs_faq2.html#in-class\" rel=\"noreferrer\">Stroustrup discusses this in his C++ FAQ</a>, giving the following example:</p>\n<pre><code>class Y {\n  const int c3 = 7;           // error: not static\n  static int c4 = 7;          // error: not const\n  static const float c5 = 7;  // error: not integral\n};\n</code></pre>\n<p>And the following reasoning:</p>\n<blockquote>\n<p id=\"so_13662441_13662441_0\">So why do these inconvenient restrictions exist? A class is typically declared in a header file and a header file is typically included into many translation units. However, to avoid complicated linker rules, C++ requires that every object has a unique definition. That rule would be broken if C++ allowed in-class definition of entities that needed to be stored in memory as objects.</p>\n</blockquote>\n<p>However, C++11 relaxes these restrictions, allowing in-class initialization of non-static members (\u00a712.6.2/8):</p>\n<blockquote>\n<p id=\"so_13662441_13662441_1\">In a non-delegating constructor, if a given non-static data member or base class is not designated by a <em>mem-initializer-id</em> (including the case where there is no <em>mem-initializer-list</em> because the constructor has no <em>ctor-initializer</em>) and the entity is not a virtual base class of an abstract class (10.4), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a <em>brace-or-equal-initializer</em>, the entity is initialized as specified in 8.5;  </li>\n<li>otherwise, if the entity is a variant member (9.5), no initialization is performed;  </li>\n<li>otherwise, the entity is default-initialized (8.5).</li>\n</ul>\n</blockquote>\n<p>Section 9.4.2 also allows in-class initialization of non-const static members if they are marked with the <code>constexpr</code> specifier.</p>\n<p>So what happened to the reasons for the restrictions we had in C++03? Do we just simply accept the \"complicated linker rules\" or has something else changed that makes this easier to implement?</p>\n", "Title": "C++11 allows in-class initialization of non-static and non-const members. What changed?", "CreationDate": "2012-12-01T18:35:02.690", "LastActivityDate": "2016-06-06T16:57:32.603", "CommentCount": "1", "FavoriteCount": "21", "PostTypeId": "1", "Id": "13662441", "Score": "56", "OwnerUserId": "150634", "Tags": "<c++><class><c++11><initialization><class-members>", "AnswerCount": "3"}, "13662599": {"Id": "13662599", "PostTypeId": "2", "Body": "<p>The short answer is that they kept the linker about the same, at the expense of making the compiler still more complicated than previously.</p>\n<p>I.e., instead of this resulting in multiple definitions for the linker to sort out, it still only results in one definition, and the compiler has to sort it out.</p>\n<p>It also leads to somewhat more complex rules for the <em>programmer</em> to keep sorted out as well, but it's mostly simple enough that it's not a big deal. The extra rules come in when you have two different initializers specified for a single member:</p>\n<pre><code>class X { \n    int a = 1234;\npublic:\n    X() = default;\n    X(int z) : a(z) {}\n};\n</code></pre>\n<p>Now, the extra rules at this point deal with what value is used to initialize <code>a</code> when you use the non-default constructor. The answer to that is fairly simple: if you use a constructor that doesn't specify any other value, then the <code>1234</code> would be used to initialize <code>a</code> -- but if you use a constructor that specifies some other value, then the <code>1234</code> is basically ignored.</p>\n<p>For example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass X { \n    int a = 1234;\npublic:\n    X() = default;\n    X(int z) : a(z) {}\n\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, X const &amp;x) { \n        return os &lt;&lt; x.a;\n    }\n};\n\nint main() { \n    X x;\n    X y{5678};\n\n    std::cout &lt;&lt; x &lt;&lt; \"\\n\" &lt;&lt; y;\n    return 0;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>1234\n5678\n</code></pre>\n", "LastActivityDate": "2012-12-01T18:51:40.480", "CommentCount": "2", "CreationDate": "2012-12-01T18:51:40.480", "ParentId": "13662441", "Score": "48", "OwnerUserId": "179910"}});