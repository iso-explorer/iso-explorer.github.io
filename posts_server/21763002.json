post_cb({"21763002": {"CommentCount": "0", "ViewCount": "584", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2014-02-13T18:50:58.757", "LastActivityDate": "2014-02-13T19:20:25.763", "Title": "Is it safe to put an std::array<POD, N> in a union?", "AcceptedAnswerId": "21763025", "LastEditDate": "2014-02-13T19:20:25.763", "Id": "21763002", "Score": "3", "Body": "<p>I have a union declared like that:</p>\n<pre><code>union\n{\n    int all[4];\n    struct\n    {\n        int a, b, c, d;\n    };\n};\n</code></pre>\n<p>The point of the <code>all</code> array is simply to make iteration over the 4 fields simpler.</p>\n<p>To make it even simpler, I'd like to replace it with an <code>std::array&lt;int, 4&gt;</code>. Would that expose me to <a href=\"http://www.catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow\">nasal demons</a>?</p>\n", "Tags": "<c++><arrays><c++11><stl>", "OwnerUserId": "251153", "AnswerCount": "1"}, "21763025": {"ParentId": "21763002", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>First, it's important to note that merely having two objects of different types in a union is <em>never</em> undefined. What's undefined is to write to one and read from another, with one exception:</p>\n<blockquote>\n<p id=\"so_21763002_21763025_0\"><code>[C++11: 9.5/1]:</code> <em>[ Note:</em> One special guarantee is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout structs that share a common initial sequence (9.2), and if an object of this standard-layout union type contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of standard-layout struct members; see 9.2. \u2014<em>end note ] [..]</em></p>\n</blockquote>\n<p>Now, although it's not written out specifically anywhere that <code>std::array</code> fits this rule, the fact that it's an aggregate with only element members seems enough of a guarantee:</p>\n<blockquote>\n<p id=\"so_21763002_21763025_1\"><code>[C++11: 23.3.2.1/2]:</code> An array is an aggregate (8.5.1) that can be initialized with the syntax:</p>\n<p id=\"so_21763002_21763025_2\">\u00a0\u00a0\u00a0<code>array&lt;T, N&gt; a = {</code> <em>initializer-list</em> <code>};</code></p>\n<p id=\"so_21763002_21763025_3\">where <em>initializer-list</em> is a comma-separated list of up to <code>N</code> elements whose types are convertible to <code>T</code>.</p>\n</blockquote>\n<p>So, it's safe not only to have the union exist in the first place, but also to read and write to either member at will.</p>\n<p>Therefore, my conclusion is: <strong>yes; it is safe</strong>.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2014-02-13T18:54:36.287", "Id": "21763025", "Score": "3", "CreationDate": "2014-02-13T18:52:17.417", "LastActivityDate": "2014-02-13T18:54:36.287"}, "bq_ids": {"n4140": {"so_21763002_21763025_0": {"section_id": 5913, "quality": 0.875, "length": 35}, "so_21763002_21763025_1": {"section_id": 775, "quality": 0.625, "length": 5}, "so_21763002_21763025_3": {"section_id": 775, "quality": 0.875, "length": 7}}, "n3337": {"so_21763002_21763025_0": {"section_id": 5685, "quality": 0.875, "length": 35}, "so_21763002_21763025_1": {"section_id": 762, "quality": 0.625, "length": 5}, "so_21763002_21763025_3": {"section_id": 762, "quality": 0.875, "length": 7}}, "n4659": {"so_21763002_21763025_0": {"section_id": 7404, "quality": 0.85, "length": 34}}}});