post_cb({"12691011": {"ParentId": "12690698", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2012-10-02T13:16:13.883", "Score": "5", "LastEditorUserId": "147192", "LastEditDate": "2012-10-02T14:13:42.560", "Id": "12691011", "OwnerUserId": "147192", "Body": "<p>From my understanding of the Standard, it is legitimate. However I would note that the rethrow <em>does not duplicate</em> the exception, and therefore the shared exception object itself is submitted to data races should you modify it and access it from other threads meantime. If the exception is read-only (once thrown), then you should not have any issue.</p>\n<p>Regarding storage duration:</p>\n<blockquote>\n<p id=\"so_12690698_12691011_0\"><strong>15.1 Throwing an exception [except.throw]</strong></p>\n<p id=\"so_12690698_12691011_1\"><em>4</em> The memory for the exception object is allocated in an unspecified way, except as noted in 3.7.4.1. If a handler exits by rethrowing, control is passed to another handler for the same exception. The exception object is destroyed after either the last remaining active handler for the exception exits by any means other than rethrowing, or the last object of type <code>std::exception_ptr</code> (18.8.5) that refers to the exception object is\n  destroyed, whichever is later. In the former case, the destruction occurs when the handler exits, immediately after the destruction of the object declared in the exception-declaration in the handler, if any. In the latter case, the destruction occurs before the destructor of <code>std::exception_ptr</code> returns.</p>\n</blockquote>\n<p>Regarding data races:</p>\n<blockquote>\n<p id=\"so_12690698_12691011_2\"><strong>18.8.5 Exception propagation [propagation]</strong></p>\n<p id=\"so_12690698_12691011_3\"><em>7</em> For purposes of determining the presence of a data race, operations on <code>exception_ptr</code> objects shall access and modify only the <code>exception_ptr</code> objects themselves and not the exceptions they refer to. Use of <code>rethrow_exception</code> on <code>exception_ptr</code> objects that refer to the same exception object shall not introduce a data race. [ Note: if <code>rethrow_exception</code> rethrows the same exception object (rather than a copy), concurrent access to that rethrown exception object may introduce a data race. Changes in the number of <code>exception_ptr</code> objects that refer to a particular exception do not introduce a data\n  race. \u2014end note ]</p>\n</blockquote>\n<p>Regarding <code>rethrow</code>:</p>\n<blockquote>\n<p id=\"so_12690698_12691011_4\"><code>[[noreturn]] void rethrow_exception(exception_ptr p);</code></p>\n<p id=\"so_12690698_12691011_5\"><em>9 Requires</em>: <code>p</code> shall not be a null pointer.</p>\n<p id=\"so_12690698_12691011_6\"><em>10 Throws</em>: the exception object to which p refers.</p>\n</blockquote>\n", "LastActivityDate": "2012-10-02T14:13:42.560"}, "bq_ids": {"n4140": {"so_12690698_12691011_1": {"section_id": 3337, "quality": 0.9411764705882353, "length": 64}, "so_12690698_12691011_3": {"section_id": 6939, "quality": 0.9310344827586207, "length": 54}}, "n3337": {"so_12690698_12691011_1": {"section_id": 3207, "quality": 0.9411764705882353, "length": 64}, "so_12690698_12691011_3": {"section_id": 6687, "quality": 0.9310344827586207, "length": 54}}, "n4659": {"so_12690698_12691011_1": {"section_id": 4104, "quality": 0.5294117647058824, "length": 36}, "so_12690698_12691011_3": {"section_id": 8436, "quality": 0.9310344827586207, "length": 54}}}, "12690698": {"CommentCount": "6", "AcceptedAnswerId": "12691011", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2012-10-02T12:56:25.437", "LastActivityDate": "2012-10-02T14:13:42.560", "LastEditDate": "2012-10-02T13:03:13.183", "ViewCount": "508", "FavoriteCount": "1", "Title": "Can exceptions be \"duplicated\" via exception pointers?", "Id": "12690698", "Score": "13", "Body": "<p>For some multithreaded code, I would like to capture all exceptions and pass a them to a single exception handling thread. Here's the message passing framework:</p>\n<pre><code>#include &lt;exception&gt;\n\nstruct message\n{\n    virtual ~message() = default;\n    virtual void act() = 0;\n};\n\nstruct exception_message : message\n{\n    std::exception_ptr ep;\n\n    virtual void act()\n    {\n        std::rethrow_exception(ep);\n    }\n\n    // ...\n};\n</code></pre>\n<p>Here's the use case:</p>\n<pre><code>try\n{\n    // ...\n}\ncatch (...)\n{\n    exception_message em { std::current_exception(); }\n    handler_thread.post_message(em);\n}\n</code></pre>\n<p>The handler thread goes through all its messages and calls <code>act()</code>, and it can install its own try/catch block to handle all the posted exceptions.</p>\n<p>Now I was wondering what happens if I send copies this message to multiple receivers. In general, mes\u00adsa\u00adges may have any number of recipients, and so I don't want to put arbitrary restrictions on exception pro\u00adpa\u00adga\u00adtion messages. The <code>exception_ptr</code> is documented as a \"shared-ownership\" smart pointer, and <code>rethrow_exception</code> \"does not introduce a data race\".</p>\n<p>So my question: Is it legitimate to duplicate an active exception by storing it in an <code>exception_ptr</code>, copy\u00ading the pointer, and calling <code>rethrow_exception</code> multiple times?</p>\n", "Tags": "<c++><exception-handling><c++11>", "OwnerUserId": "596781", "AnswerCount": "1"}});