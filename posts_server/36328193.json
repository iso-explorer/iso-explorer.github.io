post_cb({"bq_ids": {"n4140": {"so_36328193_36328312_0": {"length": 14, "quality": 0.875, "section_id": 380}}, "n3337": {"so_36328193_36328312_0": {"length": 14, "quality": 0.875, "section_id": 371}}, "n4659": {"so_36328193_36328312_0": {"length": 14, "quality": 0.875, "section_id": 395}}}, "36328193": {"ViewCount": "70", "Body": "<p>I stumbled upon a code similar to this while debugging a crash due to de-referencing a dangling piece of memory. </p>\n<pre><code>template&lt;typename RaiiObject, typename HandleType&gt;\nconst HandleType&amp; ExtractHandle(const RaiiObject &amp;value){\n\n    const HandleType* val = value.get(); // get underlying managed object\n    return static_cast&lt;const HandleType&amp;&gt;(*val);\n}\n</code></pre>\n<p>On the caller side the code looked like this:</p>\n<pre><code>const auto &amp;x = ExtractHandle(GetAHandle()); \n</code></pre>\n<p>This is a definitely a problem because the reference to the underlying object that we will be getting from <code>ExtractHandle</code> will be dangling since the Raii object managing it would have expired.</p>\n<p>Now the dev fixing this issue replaced the capture by reference to capture by value.</p>\n<pre><code>auto x = ExtractHandle(GetAHandle());\n</code></pre>\n<p>His claim is that since we are making a copy, we are safe <strong>since the x-value returned by GetAHandle will not die till the copy constructor for Handle is invoked</strong>. Is this assumption correct? Is it well defined by standard that the above proposed fix is not UB? </p>\n<p>Note: While the correctness and utility of this design can definitely be questioned, the point is more around whether copying by value guarantees a well defined behavior</p>\n", "AcceptedAnswerId": "36328312", "Title": "Copying x-value by value returned by a function", "CreationDate": "2016-03-31T08:36:19.977", "Id": "36328193", "CommentCount": "6", "LastEditDate": "2016-03-31T09:12:07.663", "PostTypeId": "1", "LastEditorUserId": "1043773", "LastActivityDate": "2016-03-31T09:12:07.663", "Score": "2", "OwnerUserId": "1043773", "Tags": "<c++><c++11><memory-management>", "AnswerCount": "2"}, "36328430": {"Id": "36328430", "PostTypeId": "2", "Body": "<p>Do it properly. Return a copy and be done with it:</p>\n<pre><code>template&lt;typename RaiiObject, typename HandleType&gt;\nHandleType ExtractHandle(const RaiiObject &amp;value){\n\n    return *value.get(); // get underlying managed object\n}\n</code></pre>\n<p>In which case, either of these will be valid:</p>\n<pre><code>const auto &amp;x = ExtractHandle(GetAHandle()); \nauto x = ExtractHandle(GetAHandle());\n</code></pre>\n<p>because there is a special rule that keeps a temporary alive bound to a const reference alive for the lifetime of the reference.</p>\n", "LastActivityDate": "2016-03-31T08:46:46.513", "CommentCount": "2", "CreationDate": "2016-03-31T08:46:46.513", "ParentId": "36328193", "Score": "2", "OwnerUserId": "2015579"}, "36328312": {"Id": "36328312", "PostTypeId": "2", "Body": "<p><strong>This is fine.</strong></p>\n<p>The temporary created by <code>GetAHandle()</code> will only be destroyed at the end of that statement, so as long as your copy constructor doesn't retain any handles to the innards of that object, you're fine.</p>\n<blockquote>\n<p id=\"so_36328193_36328312_0\"><code>(N3337) [class.temporary]/3:</code> [...] Temporary objects are destroyed as the last step\n  in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. [...]</p>\n</blockquote>\n", "LastActivityDate": "2016-03-31T08:41:57.857", "CommentCount": "0", "CreationDate": "2016-03-31T08:41:57.857", "ParentId": "36328193", "Score": "2", "OwnerUserId": "496161"}});