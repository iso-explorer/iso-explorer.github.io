post_cb({"32863623": {"ParentId": "32863272", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, this is consistent with the standard. <code>sizeof (X)</code> is basically defined as the offset in bytes between the starting addresses of two consecutive <code>X</code> objects in an array. If such objects cannot follow each other tightly due to alignment restrictions, <code>sizeof</code> increases accordingly.</p>\n<p>Quoting C++14, 5.3.3/2:</p>\n<blockquote>\n<p id=\"so_32863272_32863623_0\">... When applied\n  to a class, the result is the number of bytes in an object of that class <strong>including any padding required for\n  placing objects of that type in an array</strong>. ... When applied\n  to an array, the result is the total number of bytes in the array. This implies that the size of an array of <em>n</em>\n  elements is <em>n</em> times the size of an element.</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2015-09-30T10:26:14.333", "Id": "32863623", "Score": "9", "CreationDate": "2015-09-30T10:20:57.740", "LastActivityDate": "2015-09-30T10:26:14.333"}, "32863706": {"ParentId": "32863272", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The result of <code>sizeof</code>, for any type (except <code>char</code> types, which have size <code>1</code> by definition), is implementation defined, and is affected by alignment.   However, if</p>\n<ul>\n<li><code>sizeof(float)</code> is <code>4</code>;</li>\n<li>your struct contains three <code>floats</code>; AND</li>\n<li>both beginning and end of the struct are aligned to 32 byte boundaries.</li>\n</ul>\n<p>then you can expect the behaviour you see.</p>\n", "OwnerUserId": "4706785", "LastEditorUserId": "4706785", "LastEditDate": "2015-09-30T11:48:37.910", "Id": "32863706", "Score": "1", "CreationDate": "2015-09-30T10:24:35.423", "LastActivityDate": "2015-09-30T11:48:37.910"}, "32863272": {"CommentCount": "0", "ViewCount": "132", "CreationDate": "2015-09-30T10:02:54.253", "LastActivityDate": "2015-09-30T11:48:37.910", "Title": "Does type alignment modify type size?", "AcceptedAnswerId": "32863623", "PostTypeId": "1", "Id": "32863272", "Score": "4", "Body": "<p>I wrote following code and tested it on gcc:</p>\n<pre><code>// firstly some platform-specific workarounds\n#if _MSC_VER\n#define ALN_BEGIN(x) __declspec(align(x)) \n#define ALN_END(x)\n#define alignof(x) __alignof(x)\n#else\n#define ALN_BEGIN(x)\n#define ALN_END(x) __attribute__((aligned(x)))\n#define alignof(x) __alignof__(x)\n#endif\n\n// struct have three 4-byte members, but aligned at 32 byte\nALN_BEGIN(32) struct Foo\n{\n    float a;\n    float b;\n    float c;\n} ALN_END(32);\n\n// show its size and alignment\nint main(int argc, char** argv)\n{\n    printf(\"size %d, alignment%d\\n\", sizeof(Foo), alignof(Foo));\n}\n</code></pre>\n<p>When I compile it using gcc and run, although Foo only has 12 bytes for all its members, <code>sizeof(Foo)</code> got 32 which is alignment size. So does the size expansion is according to language standard \uff08which is reliable) or it is only a feature for GCC?</p>\n<p>I'm making an object pool class, so I have to precisely work with type size and alignment.</p>\n", "Tags": "<c++>", "OwnerUserId": "1484850", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32863272_32863623_0": {"section_id": 6077, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_32863272_32863623_0": {"section_id": 5845, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_32863272_32863623_0": {"section_id": 7573, "quality": 0.967741935483871, "length": 30}}}});