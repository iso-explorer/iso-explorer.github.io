post_cb({"47230580": {"ParentId": "47196863", "CommentCount": "14", "Body": "<p>From <a href=\"http://eel.is/c++draft/temp#inst-3\" rel=\"nofollow noreferrer\">[temp.inst]/3</a>:</p>\n<blockquote>\n<p id=\"so_47196863_47230580_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in particular, <strong>the initialization (and any associated side effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</strong></p>\n</blockquote>\n<p>Simply writing <code>A&lt;int&gt; a;</code> does noes not use <code>A&lt;int&gt;::x</code> in a way that requires its definition to exist, so its initialization should not occur. gcc is correct. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "47230580", "Score": "2", "CreationDate": "2017-11-10T20:24:39.197", "LastActivityDate": "2017-11-10T20:24:39.197"}, "bq_ids": {"n4140": {"so_47196863_47230580_0": {"section_id": 234, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_47196863_47230580_0": {"section_id": 227, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_47196863_47230580_0": {"section_id": 244, "quality": 0.9772727272727273, "length": 43}}}, "47196863": {"CommentCount": "3", "ViewCount": "211", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2017-11-09T08:10:47.330", "LastActivityDate": "2017-11-10T20:24:39.197", "Title": "Initializer \"sizeof(T)\" of inline static auto... Does it need instantiation?", "FavoriteCount": "2", "LastEditDate": "2017-11-10T19:28:33.027", "Id": "47196863", "Score": "5", "Body": "<p>What should happen if an expression's type is not dependent, but we use it to initialize a static auto variable? GCC and Clang differ in their behavior </p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n   static inline auto x = sizeof(T{}.f);\n};\n\nA&lt;int&gt; a;\n</code></pre>\n<p>GCC doesn't raise an error. But Clang thinks that this is invalid because it instantiates the operand of \"sizeof\". GCC appears to skip that step because <code>sizeof(T{}.f)</code> always has type <code>size_t</code> (not type dependent), so it already knows type of <code>x</code> without instantiation. Both compilers conformly reject the program if we refer to <code>x</code>, for example by <code>(void) a.x;</code>.</p>\n<p>Does it even have to resolve the type of <code>x</code> at all? With C++14 upwards the language allows keeping things (like functions) with a \"placeholder type\" and doing delayed instantiation to find out about the actual return type later on, if I remember correctly. Does it have to apply this to <code>x</code> aswell, so keeping <code>x</code> with a placeholder type till we refer to <code>a.x</code>?</p>\n<p>What compiler is correct according to the Standards?</p>\n<hr>\n<p><strong>EDIT</strong></p>\n<p>Someone asked</p>\n<blockquote>\n<p id=\"so_47196863_47196863_0\">uhm, shouldnt' this be equivalent to this ?</p>\n<pre><code>template&lt;typename T&gt;\nstruct A {\n   static const std::size_t x;\n};\n\ntemplate&lt;typename T&gt;\ninline constexpr std::size_t A&lt;T&gt;::x = sizeof(T{}.f);\n</code></pre>\n</blockquote>\n<p>The difference, and what concerns me in my question, is that the static data member in my question is <code>auto</code>. Therefore, in order to know the type of <code>x</code>, you need to know the type of the initializer. Clang appears to instantiate the initializer eagerly in order to get the type. But GCC doesn't, apparently? I would like to understand what's going on.</p>\n</hr>", "Tags": "<c++><gcc><clang><c++1z><inline-variable>", "OwnerUserId": "34509", "AnswerCount": "1"}});