post_cb({"2496919": {"Id": "2496919", "PostTypeId": "2", "Body": "<p>You've invoked undefined behaviour, all bets are off. </p>\n", "LastActivityDate": "2010-03-23T01:16:30.067", "CommentCount": "0", "CreationDate": "2010-03-23T01:16:30.067", "ParentId": "2496902", "Score": "2", "OwnerUserId": "59379"}, "2496932": {"Id": "2496932", "PostTypeId": "2", "Body": "<p>Expressly calling the destructor, as you do in <code>destroy()</code>, and directly in <code>main()</code> doesn't actually cause an object to be destroyed in C++. Only the <code>delete</code> statement in this code does that. Since T's destructor is benign (it just prints), this has almost no effect.</p>\n<p>Since none of the member functions are virtual, calling them after the destruction will still get to the right code to execute. Once there, the <code>this</code> pointer may be invalid (after your call to <code>delete</code>), but that doesn't stop the code from dereferencing the pointer and returning the value of the <code>int</code> member value.</p>\n", "LastActivityDate": "2010-03-23T01:20:26.333", "CommentCount": "3", "CreationDate": "2010-03-23T01:20:26.333", "ParentId": "2496902", "Score": "1", "OwnerUserId": "138311"}, "2496909": {"Id": "2496909", "PostTypeId": "2", "Body": "<p>This is an exhibit of undefined behavior.  Call a member function through a pointer that's been deleted and anything goes - the compiler and runtime aren't required to check for this error, but you certainly can't count on this working.</p>\n<p>This falls into a similar category as using memory that's been freed - you might find your old data there (or you might not).  You might cause the program to crash (or not).  You might even be able to change the data without anything complaining.</p>\n<p>But in any case, it's a programming error.</p>\n", "LastActivityDate": "2010-03-23T01:15:25.950", "CommentCount": "7", "CreationDate": "2010-03-23T01:15:25.950", "ParentId": "2496902", "Score": "16", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_2496902_2496917_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 411}}, "n3337": {"so_2496902_2496917_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 402}}, "n4659": {"so_2496902_2496917_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 429}}}, "2496912": {"Id": "2496912", "PostTypeId": "2", "Body": "<p>Just because you are accessing a not longer valid object doesn't mean your program <em>has</em> to explode, it just means your program <em>can</em> explode.</p>\n<p>It is undefined behavior, which means anything can happen, it might even appear to do the correct thing.</p>\n", "LastActivityDate": "2010-03-23T01:15:43.923", "CommentCount": "3", "CreationDate": "2010-03-23T01:15:43.923", "ParentId": "2496902", "Score": "6", "OwnerUserId": "56338"}, "2496928": {"Id": "2496928", "PostTypeId": "2", "Body": "<p>You really shouldn't call a class' destructor (unless you used placement new) however to answer your question, once memory has been deleted accessing pointers to that memory results in undefined behavior.  In your case it appears as though the memory you are using has been freed for future use but it hasn't yet been overwritten.  So you are still able to access it but there are no guarantees as to when that memory is going to be used by something else.</p>\n", "LastActivityDate": "2010-03-23T01:19:44.493", "CommentCount": "1", "CreationDate": "2010-03-23T01:19:44.493", "ParentId": "2496902", "Score": "2", "OwnerUserId": "117539"}, "2496902": {"ViewCount": "1003", "Body": "<p>I have a piece of code where I can call the destructor multiple times and access member functions even the destructor was called with member variables' values preserved. I was still able to access member functions after I called <code>delete</code> but the member variables were nullified (all to 0). And I can't double <code>delete</code>. Please kindly explain this.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nvoid destroy(T* ptr)\n{\n    ptr-&gt;~T();\n}\n\nclass Testing\n{\npublic:\n    Testing() : test(20)\n    {\n\n    }\n\n    ~Testing()\n    {\n        printf(\"Testing is being killed!\\n\");\n    }\n\n    int getTest() const\n    {\n        return test;\n    }\n\nprivate:\n    int test;\n};\n\nint main()\n{\n    Testing *t = new Testing();\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    destroy(t);\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    t-&gt;~Testing();\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    delete t;\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    destroy(t);\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    t-&gt;~Testing();\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    //delete t; // &lt;======== Don't do it! Double free/delete!\n    cout &lt;&lt; \"t-&gt;getTest() = \" &lt;&lt; t-&gt;getTest() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "2496909", "Title": "An interesting case of delete and destructor (C++)", "CreationDate": "2010-03-23T01:12:27.983", "Id": "2496902", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-11T10:04:33.817", "LastEditorUserId": "3622940", "LastActivityDate": "2014-08-11T10:04:33.817", "Score": "2", "OwnerUserId": "128028", "Tags": "<c++><memory-management><destructor>", "AnswerCount": "6"}, "2496917": {"Id": "2496917", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2496902_2496917_0\">\"Once a destructor is invoked for an\n  object, the object no longer exists;\n  the behavior is unde\ufb01ned if the\n  destructor is invoked for an object\n  whose lifetime has ended\"</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2798.pdf\" rel=\"nofollow noreferrer\">C++ draft standard</a> \u00a712.4.12</p>\n<p>As noted by others, this doesn't mean the implementation will always do something obviously unwanted (like a segmentation fault).  It means it can do whatever is most convenient.</p>\n", "LastEditorUserId": "47773", "LastActivityDate": "2010-03-23T01:21:57.183", "Score": "5", "CreationDate": "2010-03-23T01:16:19.083", "ParentId": "2496902", "CommentCount": "1", "OwnerUserId": "47773", "LastEditDate": "2010-03-23T01:21:57.183"}});