post_cb({"40735519": {"ParentId": "40735379", "CommentCount": "0", "Body": "<p>The condition in <code>if (b[2])</code> including the <code>operator bool()</code> is a single expression and temporaries are valid for the whole lifetime of an expression.</p>\n", "OwnerUserId": "426288", "PostTypeId": "2", "Id": "40735519", "Score": "1", "CreationDate": "2016-11-22T06:53:20.860", "LastActivityDate": "2016-11-22T06:53:20.860"}, "40735379": {"CommentCount": "0", "ViewCount": "61", "PostTypeId": "1", "LastEditorUserId": "5735010", "CreationDate": "2016-11-22T06:42:29.000", "LastActivityDate": "2016-11-22T11:30:28.780", "Title": "Lifetime of std::bitset::reference object created in std::bitset::operator[]?", "AcceptedAnswerId": "40735526", "LastEditDate": "2016-11-22T07:02:15.567", "Id": "40735379", "Score": "3", "Body": "<p>I have been looking at header file of <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-3.4/bitset-source.html\" rel=\"nofollow noreferrer\">bitset</a> standard C++ library header. I found out that overloaded operator[] <code>operator[](size_t ndx)</code> (defined in class <code>bitset</code>) returns a temproray object of class <code>reference</code>. </p>\n<pre><code>reference\n    operator[](size_t __position)\n{ return reference(*this,__position); }\n</code></pre>\n<p>This overloaded operator encapsulates the concept of a single bit. An instance of this class is a proxy for an actual bit. It can be useful in expressions like</p>\n<pre><code>bitset&lt;10&gt; b;\nb[2] = true;\n</code></pre>\n<p>The <code>reference</code> class has defined overloaded <code>=</code> operator member function so that above example can work:</p>\n<pre><code> //For b[i] = __x;\n reference&amp;\n     operator=(bool __x)\n {\n   if (__x)\n     *_M_wp |= _Base::_S_maskbit(_M_bpos);\n   else\n     *_M_wp &amp;= ~_Base::_S_maskbit(_M_bpos);\n   return *this;\n}\n</code></pre>\n<p>However, i am confused over this expression:</p>\n<pre><code>if (b[2]) {\n    //Do something\n}\n</code></pre>\n<p>The <code>b[2]</code> first returns a temporary object of class <code>reference</code> and then overloaded operator (<code>operator bool() const</code>) is called on that returned temporary object to convert it to <code>bool</code> data type.</p>\n<pre><code>// For __x = b[i];\noperator bool() const\n{ return (*(_M_wp) &amp; _Base::_S_maskbit(_M_bpos)) != 0; }\n</code></pre>\n<p>If temporary objects (object having automatic storage class) are created on stacks, then calling an another function  (<code>operator bool() const</code>) shouldn't destroys the temporary object returned by the first function call (<code>reference</code> object returned by <code>reference operator[](size_t __position)</code>)?</p>\n<p>What is the lifetime of temporary objects in C and C++?</p>\n", "Tags": "<c++><bitset>", "OwnerUserId": "5735010", "AnswerCount": "2"}, "40735526": {"ParentId": "40735379", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From <a href=\"http://eel.is/c++draft/class.temporary#4\" rel=\"nofollow noreferrer\">class.temporary#4</a>, emphasized is mine.</p>\n<blockquote>\n<p id=\"so_40735379_40735526_0\">When an implementation introduces a temporary object of a class that has a non-trivial constructor ([class.ctor], [class.copy]), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be called for a temporary with a non-trivial destructor ([class.dtor]). <strong>Temporary objects are destroyed as the last step in evaluating the full-expression ([intro.execution]) that (lexically) contains the point where they were created.</strong> This is true even if that evaluation ends in throwing an exception. The value computations and side effects of destroying a temporary object are associated only with the full-expression, not with any specific subexpression.</p>\n</blockquote>\n<p>That temporary object will be destroyed at the last step of that given expression.</p>\n<p>In fact, C++ relies on it for this very common expression can be work correctly:</p>\n<pre><code>int x = 0, y = 0, z = 0, t = 0;\nint a = x + y + z + t;\n</code></pre>\n<p>Because <code>x+y</code> is a temporary, <code>x+y+z</code> is another temporary.</p>\n<hr>\n<p>The lifetime of temporary will be shortened following rules in <a href=\"http://eel.is/c++draft/class.temporary#5\" rel=\"nofollow noreferrer\">class.temporary#5</a> </p>\n<blockquote>\n<p id=\"so_40735379_40735526_1\">There are three contexts in which temporaries are destroyed at a different point than the end of the full-expression. The first context is when a default constructor is called to initialize an element of an array with no corresponding initializer ([dcl.init]). The second context is when a copy constructor is called to copy an element of an array while the entire array is copied ([expr.prim.lambda], [class.copy]). In either case, if the constructor has one or more default arguments, the destruction of every temporary created in a default argument is sequenced before the construction of the next array element, if any.</p>\n</blockquote>\n<p>and it will be prolonged following rule in <a href=\"http://eel.is/c++draft/class.temporary#6\" rel=\"nofollow noreferrer\">class.temporary#6</a>:</p>\n<blockquote>\n<p id=\"so_40735379_40735526_2\">The third context is when a reference is bound to a temporary.116 The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n<ul>\n<li><p id=\"so_40735379_40735526_3\">A temporary object bound to a reference parameter in a function call ([expr.call]) persists until the completion of the full-expression containing the call.</p></li>\n<li><p id=\"so_40735379_40735526_4\">The lifetime of a temporary bound to the returned value in a function return statement ([stmt.return]) is not extended; the temporary is destroyed at the end of the full-expression in the return statement.</p></li>\n<li><p id=\"so_40735379_40735526_5\">A temporary bound to a reference in a new-initializer ([expr.new]) persists until the completion of the full-expression containing the new-initializer. </p></li>\n</ul>\n</blockquote>\n<p>The first context can be seen in this example:</p>\n<pre><code>struct bar {\n    bar() { std::cout &lt;&lt; __func__ &lt;&lt; '\\n'; }\n    bar(const bar&amp;) { std::cout &lt;&lt; __func__ &lt;&lt; \"__\\n\"; }\n    ~bar() { std::cout &lt;&lt; __func__ &lt;&lt; '\\n'; }\n};\n\nstruct foo {\n    foo(const bar&amp; b = bar()) { std::cout &lt;&lt; __func__ &lt;&lt; '\\n'; }\n};\n\nint main() {\n    foo f[] = {foo(), foo()};\n}\n</code></pre>\n<p>Above program should output:</p>\n<pre><code>bar\nfoo\n~bar\nbar\nfoo\n~bar\n</code></pre>\n<p>The second context will be added to C++17, from then this program:</p>\n<pre><code>struct bar {\n    bar() { std::cout &lt;&lt; __func__ &lt;&lt; '\\n'; }\n    bar(const bar&amp;) { std::cout &lt;&lt; __func__ &lt;&lt; \"__\\n\"; }\n    ~bar() { std::cout &lt;&lt; __func__ &lt;&lt; '\\n'; }\n};\n\nstruct foo {\n    foo() {}\n    foo(const foo&amp;, const bar&amp; b = bar()) { std::cout &lt;&lt; __func__ &lt;&lt; \"__\\n\"; }\n};\n\nstruct foox {\n    foo f[2];\n};\n\nint main() {\n    foox fx;\n    foox yx = fx;\n}\n</code></pre>\n<p>must output:</p>\n<pre><code>bar\nfoo__\n~bar\nbar\nfoo__\n~bar\n</code></pre>\n<p>For the third context, you can find the answer in <a href=\"https://stackoverflow.com/a/36982822/4115625\">here</a>, and <a href=\"https://stackoverflow.com/a/19865679/4115625\">here</a></p>\n</hr>", "OwnerUserId": "4115625", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:13:43.013", "Id": "40735526", "Score": "2", "CreationDate": "2016-11-22T06:53:39.093", "LastActivityDate": "2016-11-22T11:30:28.780"}, "bq_ids": {"n4140": {"so_40735379_40735526_3": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_40735379_40735526_4": {"section_id": 382, "quality": 0.8823529411764706, "length": 15}, "so_40735379_40735526_2": {"section_id": 382, "quality": 0.8095238095238095, "length": 17}, "so_40735379_40735526_5": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_40735379_40735526_0": {"section_id": 380, "quality": 0.8928571428571429, "length": 50}, "so_40735379_40735526_1": {"section_id": 381, "quality": 0.603448275862069, "length": 35}}, "n3337": {"so_40735379_40735526_3": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_40735379_40735526_4": {"section_id": 373, "quality": 0.8823529411764706, "length": 15}, "so_40735379_40735526_2": {"section_id": 373, "quality": 0.8095238095238095, "length": 17}, "so_40735379_40735526_5": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_40735379_40735526_0": {"section_id": 371, "quality": 0.8928571428571429, "length": 50}, "so_40735379_40735526_1": {"section_id": 372, "quality": 0.603448275862069, "length": 35}}, "n4659": {"so_40735379_40735526_3": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}, "so_40735379_40735526_5": {"section_id": 397, "quality": 0.9090909090909091, "length": 10}, "so_40735379_40735526_2": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_40735379_40735526_4": {"section_id": 397, "quality": 0.8823529411764706, "length": 15}, "so_40735379_40735526_0": {"section_id": 395, "quality": 0.8928571428571429, "length": 50}, "so_40735379_40735526_1": {"section_id": 396, "quality": 0.9137931034482759, "length": 53}}}});