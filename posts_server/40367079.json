post_cb({"40367079": {"CommentCount": "6", "AcceptedAnswerId": "40884748", "PostTypeId": "1", "LastEditorUserId": "3167040", "CreationDate": "2016-11-01T19:14:57.563", "LastActivityDate": "2016-11-30T09:35:48.650", "LastEditDate": "2016-11-06T02:56:13.873", "ViewCount": "372", "FavoriteCount": "4", "Title": "Does standard C++11 guarantee that `volatile atomic<T>` has both semantics (volatile + atomic)?", "Id": "40367079", "Score": "16", "Body": "<p>As known, <code>std::atomic</code> and <code>volatile</code> are different things.</p>\n<p>There are 2 main differences:</p>\n<ol>\n<li><p>Two optimizations can be for <code>std::atomic&lt;int&gt; a;</code>, but can't be for <code>volatile int a;</code>:</p>\n<ul>\n<li>fused operations: <code>a = 1; a = 2;</code> can be replaced by the compiler on <code>a = 2;</code></li>\n<li>constant propagation: <code>a = 1; local = a;</code> can be replaced by the compiler on<code>a = 1; local = 1;</code></li>\n</ul></li>\n<li><p>Reordering of ordinary reads/writes across atomic/volatile operations:</p>\n<ul>\n<li>for <code>volatile int a;</code> any volatile-read/write-operations can't be reordered. But nearby ordinary reads/writes can still be reordered around volatile reads/writes.</li>\n<li>for <code>std::atomic a;</code> reordering of nearby ordinary reads/writes restricted based on the memory barrier used for atomic operation <code>a.load(std::memory_order_...);</code></li>\n</ul></li>\n</ol>\n<p>I.e. <code>volatile</code> don't introduce a memory fences, but <code>std::atomic</code> can do it. </p>\n<p>As is well described in the article:</p>\n<ul>\n<li>Herb Sutter, January 08, 2009 - part 1: <a href=\"http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484\" rel=\"nofollow noreferrer\">http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484</a></li>\n<li>Herb Sutter, January 08, 2009 - part 2: <a href=\"http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484?pgno=2\" rel=\"nofollow noreferrer\">http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484?pgno=2</a></li>\n</ul>\n<p>For example, <code>std::atomic</code> should be used for concurrent multi-thread programs (CPU-Core &lt;-&gt; CPU-Core), but <code>volatile</code> should be used for access to Mamory Mapped Regions on devices (CPU-Core &lt;-&gt; Device).</p>\n<hr>\n<p>But if required, both have unusual semantics and has any or all of the atomicity and/or ordering guarantees needed for lock-free coding, i.e. if required <code>volatile std::atomic&lt;&gt;</code>, require for several reasons:</p>\n<ul>\n<li><strong>ordering</strong>: to prevent reordering of ordinary reads/writes, for example, for reads from CPU-RAM, to which the data been written using the Device DMA-controller</li>\n</ul>\n<p>For example:</p>\n<pre><code>char cpu_ram_data_written_by_device[1024];\ndevice_dma_will_write_here( cpu_ram_data_written_by_device );\n\n// physically mapped to device register\nvolatile bool *device_ready = get_pointer_device_ready_flag();\n\n//... somewhere much later\nwhile(!device_ready); // spin-lock (here should be memory fence!!!)\nfor(auto &amp;i : cpu_ram_data_written_by_device) std::cout &lt;&lt; i;\n</code></pre>\n<ul>\n<li><strong>spilling</strong>: CPU write to CPU-RAM and then Device DMA-controller read from this memory: <a href=\"https://en.wikipedia.org/wiki/Register_allocation#Spilling\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Register_allocation#Spilling</a></li>\n</ul>\n<p>example:</p>\n<pre><code>char cpu_ram_data_will_read_by_device[1024];\ndevice_dma_will_read_it( cpu_ram_data_written_by_device );\n\n// physically mapped to device register\nvolatile bool *data_ready = get_pointer_data_ready_flag();\n\n//... somewhere much later\nfor(auto &amp;i : cpu_ram_data_will_read_by_device) i = 10;\ndata_ready=true; //spilling cpu_ram_data_will_read_by_device to RAM, should be memory fence\n</code></pre>\n<ul>\n<li><strong>atomic</strong>: to guarantee that the volatile operation will be atomic - i.e. It will consist of a single operation instead of multiple - i.e. one 8-byte-operation instead of two 4-byte-operations</li>\n</ul>\n<p>For this, Herb Sutter said about <code>volatile atomic&lt;T&gt;</code>, January 08, 2009: <a href=\"http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484?pgno=2\" rel=\"nofollow noreferrer\">http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484?pgno=2</a></p>\n<blockquote>\n<p id=\"so_40367079_40367079_0\">Finally, to express a variable that both has unusual semantics and has\n  any or all of the atomicity and/or ordering guarantees needed for\n  lock-free coding, only the ISO C++0x draft Standard provides a direct\n  way to spell it: volatile atomic.</p>\n</blockquote>\n<p>But do <strong>modern</strong> standards C++11 (not C++0x draft), C++14, and C++17 guarantee that <code>volatile atomic&lt;T&gt;</code> has both semantics (volatile + atomic)?</p>\n<p>Does <code>volatile atomic&lt;T&gt;</code> guarantee the most stringent guarantees from both volatile and atomic?</p>\n<ol>\n<li>As in <code>volatile</code>: Avoids fused-operations and constant-propagation as described in the beginning of the question</li>\n<li>As in <code>std::atomic</code>: Introduces memory fences to provide ordering, spilling, and being atomic.</li>\n</ol>\n<p>And can we do <code>reinterpret_cast</code> from <code>volatile int *ptr;</code> to <code>volatile std::atomic&lt;int&gt;*</code>?</p>\n</hr>", "Tags": "<c++><multithreading><c++11><concurrency><volatile>", "OwnerUserId": "1558037", "AnswerCount": "1"}, "40884748": {"ParentId": "40367079", "CommentCount": "0", "CreationDate": "2016-11-30T09:35:48.650", "OwnerUserId": "5489178", "PostTypeId": "2", "Id": "40884748", "Score": "3", "Body": "<p>Yes, it does.</p>\n<p>Section 29.6.5, <em>\"Requirements for operations on atomic types\"</em></p>\n<blockquote>\n<p id=\"so_40367079_40884748_0\">Many operations are volatile-qualified. The \u201cvolatile as device register\u201d semantics have not changed in the standard. This qualification means that volatility is preserved when applying these operations to volatile objects.</p>\n</blockquote>\n<p>I checked working drafts 2008 through 2016, and the same text is in all of them. Therefore it should apply C++11, C++14, and C++17.</p>\n", "LastActivityDate": "2016-11-30T09:35:48.650"}, "bq_ids": {"n4140": {"so_40367079_40884748_0": {"section_id": 1182, "quality": 0.9, "length": 18}}, "n3337": {"so_40367079_40884748_0": {"section_id": 1180, "quality": 0.9, "length": 18}}, "n4659": {"so_40367079_40884748_0": {"section_id": 1263, "quality": 0.9, "length": 18}}}});