post_cb({"bq_ids": {"n4140": {"so_40765232_40765401_1": {"length": 10, "quality": 0.625, "section_id": 5999}}, "n3337": {"so_40765232_40765401_1": {"length": 10, "quality": 0.625, "section_id": 5767}}, "n4659": {"so_40765232_40765401_1": {"length": 14, "quality": 0.875, "section_id": 7499}}}, "40765232": {"ViewCount": "1903", "Body": "<p>Why is the following illegal in C++?</p>\n<pre><code>auto x = unsigned int(0);\n</code></pre>\n<p>Whereas the following are all OK:</p>\n<pre><code>auto y = int(0);\nauto z = unsigned(0);\nauto w = float(0);\n</code></pre>\n<p>or in general:</p>\n<pre><code>auto t = Type(... c-tor-args ...);\n</code></pre>\n<p>(with the exception of <code>Type</code> being <code>unsigned int</code>).</p>\n", "AcceptedAnswerId": "40765401", "Title": "Why can constructor syntax not be used with the \"unsigned int\" type?", "CreationDate": "2016-11-23T12:59:22.453", "Id": "40765232", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-11-23T17:15:42.517", "LastEditorUserId": "366904", "LastActivityDate": "2017-01-09T00:12:11.083", "Score": "35", "OwnerUserId": "984786", "Tags": "<c++><type-conversion><language-lawyer>", "AnswerCount": "2"}, "40765401": {"Id": "40765401", "PostTypeId": "2", "Body": "<p>The syntax is <a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast#Explanation\" rel=\"nofollow noreferrer\">Explicit type conversion (functional notation)</a> here. According to the grammatical rule, it only works with simple type specifier or typedef specifier (i.e. a single-word type name).</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_40765232_40765401_0\">2) The functional cast expression consists of a simple type specifier or a typedef specifier (<strong>in other words, a single-word type name: <code>unsigned int(expression)</code> or <code>int*(expression)</code> are not valid</strong>), followed by a single expression in parentheses. This cast expression is exactly equivalent to the corresponding C-style cast expression.</p>\n</blockquote>\n<p>You can change it to c-style cast expression or <code>static_cast</code>, or use it with typedef specifier as @Jean-Fran\u00e7oisFabre suggested.</p>\n<pre><code>auto x1 = (unsigned int)(0);\nauto x2 = static_cast&lt;unsigned int&gt;(0);\n</code></pre>\n<p>Quotes from the standard, <a href=\"http://eel.is/c++draft/expr.type.conv#1\" rel=\"nofollow noreferrer\">$5.2.3/1 Explicit type conversion (functional notation) [expr.type.conv]</a></p>\n<blockquote>\n<p id=\"so_40765232_40765401_1\">A simple-type-specifier ([dcl.type.simple]) or typename-specifier ([temp.res]) followed by a parenthesized optional expression-list or by a braced-init-list (the initializer) constructs a value of the specified type given the initializer.</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/dcl.type.simple#1\" rel=\"nofollow noreferrer\">$7.1.7.2/1 Simple type specifiers [dcl.type.simple]</a></p>\n<blockquote>\n<p id=\"so_40765232_40765401_2\">The simple type specifiers are</p>\n<pre><code>simple-type-specifier:\n    nested-name-specifieropt type-name\n    nested-name-specifier template simple-template-id\n    nested-name-specifieropt template-name\n    char\n    char16_t\n    char32_t\n    wchar_t\n    bool\n    short\n    int\n    long\n    signed\n    unsigned\n    float\n    double\n    void\n    auto\n    decltype-specifier\ntype-name:\n    class-name\n    enum-name\n    typedef-name\n    simple-template-id\ndecltype-specifier:\n  decltype ( expression )\n  decltype ( auto )\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-11-30T04:08:41.103", "Score": "32", "CreationDate": "2016-11-23T13:07:19.957", "ParentId": "40765232", "CommentCount": "4", "OwnerUserId": "3309790", "LastEditDate": "2016-11-30T04:08:41.103"}, "40765270": {"Id": "40765270", "PostTypeId": "2", "Body": "<p>Because of parsing priority. The compiler is lost because <code>int(0)</code> is matched before <code>unsigned int</code>.</p>\n<p>You have to enclose your type in parentheses:</p>\n<pre><code>auto x = (unsigned int)(0);\n</code></pre>\n<p>or use a typedef:</p>\n<pre><code>typedef unsigned int uint;\nauto x = uint(0);\n</code></pre>\n", "LastEditorUserId": "2411320", "LastActivityDate": "2017-01-09T00:12:11.083", "Score": "20", "CreationDate": "2016-11-23T13:01:15.893", "ParentId": "40765232", "CommentCount": "3", "OwnerUserId": "6451573", "LastEditDate": "2017-01-09T00:12:11.083"}});