post_cb({"45071876": {"ViewCount": "1615", "Body": "<p>In C++, you can declare many things as <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"noreferrer\"><code>constexpr</code></a>: variables, functions (including member functions and operators), constructors, and since C++1z, also <a href=\"http://en.cppreference.com/w/cpp/language/if\" rel=\"noreferrer\"><code>if</code> statements</a> and <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"noreferrer\">lambda expressions</a>. However, declaring a <a href=\"http://en.cppreference.com/w/cpp/language/destructor\" rel=\"noreferrer\">destructor</a> <code>constexpr</code> results in an error:</p>\n<pre><code>struct X {\n    constexpr ~X() = default; // error: a destructor cannot be 'constexpr'\n};\n</code></pre>\n<p>My questions:</p>\n<ol>\n<li>Why can't a destructor be marked <code>constexpr</code>?</li>\n<li>If I do not provide a destructor, is the implicitly generated destructor <code>constexpr</code>?</li>\n<li>If I declare a defaulted destructor (<code>~X() = default;</code>), is it automatically <code>constexpr</code>?</li>\n</ol>\n", "AcceptedAnswerId": "45072047", "Title": "Why can't a destructor be marked constexpr?", "CreationDate": "2017-07-13T05:12:03.133", "Id": "45071876", "CommentCount": "3", "LastEditDate": "2017-07-13T08:03:26.710", "PostTypeId": "1", "LastEditorUserId": "2072269", "LastActivityDate": "2017-07-13T09:49:26.773", "Score": "23", "OwnerUserId": "2580955", "Tags": "<c++><language-lawyer><constexpr>", "AnswerCount": "4"}, "45072033": {"Id": "45072033", "PostTypeId": "2", "Body": "<p>A destructor can't be <code>constexpr</code> because <code>constexpr</code> functions can't have side effects and destructors by definition are only useful through side effects. In short, it would be useless to have a destructor that is <code>constexpr</code>.</p>\n<p>A object cannot be <code>constexpr</code> if its destructor is non-trivial. A defaulted one, if trivial, will be considered <code>constexpr</code></p>\n<p><a href=\"https://godbolt.org/g/g696WQ\" rel=\"nofollow noreferrer\">Live</a></p>\n<p>From <a href=\"http://eel.is/c++draft/class.dtor#1.3\" rel=\"nofollow noreferrer\">[class.dtor]</a></p>\n<blockquote>\n<p id=\"so_45071876_45072033_0\">Each decl-specifier of the decl-specifier-seq of a destructor declaration (if any) shall be <code>friend</code>, <code>inline</code>, or <code>virtual</code>.</p>\n</blockquote>\n<p>Missing from it, <code>constexpr</code>. So you could just take it as: because the standard says so<sup>TM</sup></p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-07-13T09:49:26.773", "Score": "2", "CreationDate": "2017-07-13T05:25:34.747", "ParentId": "45071876", "CommentCount": "7", "OwnerUserId": "4832499", "LastEditDate": "2017-07-13T09:49:26.773"}, "bq_ids": {"n4140": {"so_45071876_45072047_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 7208}, "so_45071876_45072047_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4706}, "so_45071876_45072047_7": {"length": 9, "quality": 1.0, "section_id": 401}, "so_45071876_45072047_8": {"length": 15, "quality": 1.0, "section_id": 401}, "so_45071876_45072047_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 7208}, "so_45071876_45072047_2": {"length": 12, "quality": 0.631578947368421, "section_id": 7208}, "so_45071876_45072033_0": {"length": 5, "quality": 0.625, "section_id": 397}}, "n3337": {"so_45071876_45072047_4": {"length": 9, "quality": 0.75, "section_id": 6952}, "so_45071876_45072047_8": {"length": 15, "quality": 1.0, "section_id": 392}, "so_45071876_45072047_7": {"length": 9, "quality": 1.0, "section_id": 392}, "so_45071876_45072047_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 4515}, "so_45071876_45072047_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 6952}, "so_45071876_45072047_2": {"length": 12, "quality": 0.631578947368421, "section_id": 6952}}, "n4659": {"so_45071876_45072047_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 8717}, "so_45071876_45072047_8": {"length": 15, "quality": 1.0, "section_id": 419}, "so_45071876_45072047_7": {"length": 9, "quality": 1.0, "section_id": 419}, "so_45071876_45072047_0": {"length": 7, "quality": 1.0, "section_id": 8717}, "so_45071876_45072047_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 8717}, "so_45071876_45072047_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 8717}, "so_45071876_45072033_0": {"length": 8, "quality": 1.0, "section_id": 414}}}, "45072201": {"Id": "45072201", "PostTypeId": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html\" rel=\"nofollow noreferrer\">Reference</a> say's:</p>\n<blockquote>\n<p id=\"so_45071876_45072201_0\"><strong>constexpr destructors</strong></p>\n<p id=\"so_45071876_45072201_1\">In most cases, in order to create an object of a type T in a constant\n  expression, the destruction of T must be trivial. However, non-trivial\n  destructors are an important component of modern C++, partly due to\n  widespread usage of the RAII idiom, which is also applicable in\n  constexpr evaluations. Non-trivial destructors could be supported in\n  constant expressions, as follows:</p>\n<ul>\n<li>Allow destructors to be marked as constexpr</li>\n<li>Make defaulted destructors constexpr if they only invoke constexpr destructors</li>\n<li>For constexpr variables, require that evaluating the destructor is a constant expression (except that the object being destroyed may be\n  modified in its own destructor</li>\n</ul>\n<p id=\"so_45071876_45072201_2\">However, no compelling use cases are known for such a feature, and\n  there would be a non-trivial implementation cost ensuring that\n  destructors are run at the right times.</p>\n</blockquote>\n", "LastActivityDate": "2017-07-13T05:38:15.763", "CommentCount": "1", "CreationDate": "2017-07-13T05:38:15.763", "ParentId": "45071876", "Score": "2", "OwnerUserId": "6935629"}, "45072156": {"Id": "45072156", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45071876_45072156_0\">Why a destructor cannot be marked as constexpr?</p>\n</blockquote>\n<p>The C++11 standard is specific about use of <code>constexpr</code> for consructors and non-static member function. It does not say anything specific about destructor. One may assume that destructors are to be treated as non-static member functions.</p>\n<p><code>constexpr</code> can be used only for <code>const</code> member functions. Since a destructor cannot be <code>const</code> member function, it cannot be qualified as a <code>constexpr</code> member function.</p>\n<blockquote>\n<p id=\"so_45071876_45072156_1\">If I do not provide a destructor, is the implicitly generated destructor <code>constexpr</code>.</p>\n</blockquote>\n<p>Since use of</p>\n<pre><code>constexpr ~X() = default;\n</code></pre>\n<p>is an error, it makes sense to me that the compiler generated destructor is not a <code>constexpr</code> function. I can't find anything in the standard to justify my statement. I am guessing.</p>\n<blockquote>\n<p id=\"so_45071876_45072156_2\">If I declare a defaulted destructor (<code>~X() = default;</code>), is it automatically <code>constexpr</code></p>\n</blockquote>\n<p>I think not. Once again, I can't find anything in the standard to justify my statement. I am guessing.</p>\n<hr>\n<p>FWIW, g++ compiles and builds the following program just fine.</p>\n<pre><code>struct X {\n   constexpr X(int i) : i_(i) {}\n   ~X() = default;\n   int i_;\n};\n\nint main()\n{\n   const X x(10);\n}\n</code></pre>\n</hr>", "LastEditorUserId": "434551", "LastActivityDate": "2017-07-13T05:59:33.090", "Score": "3", "CreationDate": "2017-07-13T05:35:34.423", "ParentId": "45071876", "CommentCount": "2", "OwnerUserId": "434551", "LastEditDate": "2017-07-13T05:59:33.090"}, "45072047": {"Id": "45072047", "PostTypeId": "2", "Body": "<p>As per the <a href=\"http://eel.is/c++draft/basic.types#10\" rel=\"nofollow noreferrer\">draft basic.types#10</a> possibly cv-qualified class type that has all of the following properties:</p>\n<blockquote>\n<p id=\"so_45071876_45072047_0\">A possibly cv-qualified class type that has all of the following properties:</p>\n<p id=\"so_45071876_45072047_1\">(10.5.1) - it has a trivial destructor,</p>\n<p id=\"so_45071876_45072047_2\">(10.5.2) - it is either a closure type, an aggregate type, or has at\n  least one constexpr constructor or constructor template (possibly\n  inherited from a base class) that is not a copy or move constructor,</p>\n<p id=\"so_45071876_45072047_3\">(10.5.3) - if it is a union, at least one of its non-static data\n  members is of non-volatile literal type</p>\n<p id=\"so_45071876_45072047_4\">(10.5.4) - if it is not\n  a union, all of its non-static data members and base classes are of\n  non-volatile literal types.</p>\n</blockquote>\n<p><strong>Ques 1: Why a destructor cannot be marked as constexpr?</strong></p>\n<p>Because only trivial destructors are qualified for constexpr\nFollowing is the relevant section of the <a href=\"http://eel.is/c++draft/class.dtor#5\" rel=\"nofollow noreferrer\">draft</a></p>\n<blockquote>\n<p id=\"so_45071876_45072047_5\">A destructor is trivial if it is not user-provided and if:</p>\n<p id=\"so_45071876_45072047_6\">(5.4) \u2014 the destructor is not virtual,</p>\n<p id=\"so_45071876_45072047_7\">(5.5) \u2014 all of the direct base classes of its class have trivial\n  destructors, and</p>\n<p id=\"so_45071876_45072047_8\">(5.6) \u2014 for all of the non-static data members of its class that are\n  of class type (or array thereof), each such class has a trivial\n  destructor.</p>\n<p id=\"so_45071876_45072047_9\">Otherwise, the destructor is non-trivial.</p>\n</blockquote>\n<p><strong>Ques 2: If I do not provide a destructor, is the implicitly generated destructor constexpr?</strong></p>\n<p>Yes, because implicitly generated destructor is trivial type, so it is qualified for constexpr</p>\n<p><strong>Ques 3: If I declare a defaulted destructor (~X() = default;), is it automatically constexpr?</strong></p>\n<p>Indeed, this destructor is user-declared and implicitly-generated and thus it is qualified for constexpr.</p>\n<hr>\n<p>I'm not able to find any direct reference that only trivial <code>destructors</code> are qualified for <code>constexpr</code> but if the destructor is not trivial then it is for sure that class type is not <code>cv-qualified.</code> So it kind of implicit as you can't define a <code>destructor</code> for <code>cv-qualified</code> class.</p>\n</hr>", "LastEditorUserId": "3980929", "LastActivityDate": "2017-07-13T07:38:21.503", "Score": "9", "CreationDate": "2017-07-13T05:26:54.990", "ParentId": "45071876", "CommentCount": "1", "OwnerUserId": "4006617", "LastEditDate": "2017-07-13T07:38:21.503"}});