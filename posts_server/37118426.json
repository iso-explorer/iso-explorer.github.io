post_cb({"37118426": {"CommentCount": "6", "AcceptedAnswerId": "37118638", "PostTypeId": "1", "LastEditorUserId": "1741477", "CreationDate": "2016-05-09T14:31:10.680", "LastActivityDate": "2016-05-17T23:42:22.510", "LastEditDate": "2016-05-17T23:42:22.510", "ViewCount": "607", "FavoriteCount": "3", "Title": "Does reinterpret_cast lead to undefined behavior?", "Id": "37118426", "Score": "6", "Body": "<p>I have a class template <code>A</code> which contains a container of pointers (<code>T*</code>):</p>\n<pre><code>template &lt;typename T&gt;\nclass A {\npublic:\n   // ... \nprivate:\n   std::vector&lt;T*&gt; data;\n};\n</code></pre>\n<p>and a bunch of functions like:</p>\n<pre><code>void f(const A&lt;const T&gt;&amp;);\nvoid g(const A&lt;const T&gt;&amp;);\n</code></pre>\n<p>Is it OK to call these functions via a cast from <code>A&lt;const T&gt;</code> to <code>A&lt;T&gt;</code>? </p>\n<pre><code>A&lt;double&gt; a;\n... \nauto&amp; ac = reinterpret_cast&lt;const A&lt;const double&gt;&amp;&gt;(a);\nf(ac);\n</code></pre>\n<p>I'm pretty sure that this code has undefined behaviour. </p>\n<p>Is it dangerous to use such conversions in real life? </p>\n", "Tags": "<c++><templates><reinterpret-cast>", "OwnerUserId": "1741477", "AnswerCount": "2"}, "37118638": {"ParentId": "37118426", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-05-09T14:39:49.873", "Score": "4", "LastEditorUserId": "251738", "LastEditDate": "2016-05-09T14:47:07.410", "Id": "37118638", "OwnerUserId": "251738", "Body": "<p>As <code>A&lt;double&gt;</code> and <code>A&lt;const double&gt;</code> are unrelated types, it's actually unspecified (originally I thought undefined) behavior and correspondingly yes it's a bad idea to use in real life: You never know what system(s) or compiler(s) you may port to that change the behavior is strange ways.</p>\n<p>Reference:</p>\n<p>5.2.10/11:</p>\n<blockquote>\n<p id=\"so_37118426_37118638_0\">An lvalue expression of type T1 can be cast to the type \u201creference to\n  T2\u201d if an expression of type \u201cpointer to T1\u201d can be explicitly\n  converted to the type \u201cpointer to T2\u201d using a reinterpret_cast. That\n  is, a reference cast reinterpret_cast(x) has the same effect as\n  the conversion *reinterpret_cast(&amp;x) with the built-in &amp; and *\n  operators (and similarly for reinterpret_cast(x)).</p>\n</blockquote>\n<p>So they've redirected us to an earlier section 5.2.10/7:</p>\n<blockquote>\n<p id=\"so_37118426_37118638_1\">An object pointer can be explicitly converted to an object pointer of\n  a different type. ... ... Converting a prvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields the\n  original pointer value. The result of any other such pointer\n  conversion is unspecified.</p>\n</blockquote>\n<p>If <code>f</code> and <code>g</code> are algorithms that work on containers, the easy solution is to change them to template algorithms that work on ranges (iterator pairs).</p>\n", "LastActivityDate": "2016-05-09T14:47:07.410"}, "bq_ids": {"n4140": {"so_37118426_37119041_4": {"section_id": 7239, "quality": 1.0, "length": 8}, "so_37118426_37119041_6": {"section_id": 7239, "quality": 0.9130434782608695, "length": 21}, "so_37118426_37119041_2": {"section_id": 7239, "quality": 1.0, "length": 5}, "so_37118426_37119041_0": {"section_id": 7239, "quality": 0.875, "length": 14}, "so_37118426_37119041_5": {"section_id": 7239, "quality": 1.0, "length": 10}, "so_37118426_37119041_7": {"section_id": 7239, "quality": 1.0, "length": 9}, "so_37118426_37118638_0": {"section_id": 6050, "quality": 0.8275862068965517, "length": 24}, "so_37118426_37119041_8": {"section_id": 45, "quality": 1.0, "length": 4}, "so_37118426_37119041_3": {"section_id": 7239, "quality": 1.0, "length": 6}, "so_37118426_37118638_1": {"section_id": 6046, "quality": 0.8205128205128205, "length": 32}}, "n3337": {"so_37118426_37119041_4": {"section_id": 6983, "quality": 1.0, "length": 8}, "so_37118426_37119041_6": {"section_id": 6983, "quality": 0.9130434782608695, "length": 21}, "so_37118426_37119041_2": {"section_id": 6983, "quality": 1.0, "length": 5}, "so_37118426_37119041_0": {"section_id": 6983, "quality": 0.875, "length": 14}, "so_37118426_37119041_5": {"section_id": 6983, "quality": 1.0, "length": 10}, "so_37118426_37119041_7": {"section_id": 6983, "quality": 1.0, "length": 9}, "so_37118426_37118638_0": {"section_id": 5818, "quality": 0.8620689655172413, "length": 25}, "so_37118426_37119041_8": {"section_id": 42, "quality": 1.0, "length": 4}, "so_37118426_37119041_3": {"section_id": 6983, "quality": 1.0, "length": 6}, "so_37118426_37118638_1": {"section_id": 5814, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_37118426_37119041_4": {"section_id": 8748, "quality": 1.0, "length": 8}, "so_37118426_37119041_6": {"section_id": 8748, "quality": 0.9130434782608695, "length": 21}, "so_37118426_37119041_2": {"section_id": 8748, "quality": 1.0, "length": 5}, "so_37118426_37119041_0": {"section_id": 8748, "quality": 0.875, "length": 14}, "so_37118426_37119041_5": {"section_id": 8748, "quality": 1.0, "length": 10}, "so_37118426_37119041_7": {"section_id": 8748, "quality": 1.0, "length": 9}, "so_37118426_37118638_0": {"section_id": 7549, "quality": 0.8275862068965517, "length": 24}, "so_37118426_37119041_8": {"section_id": 46, "quality": 1.0, "length": 4}, "so_37118426_37119041_3": {"section_id": 8748, "quality": 1.0, "length": 6}, "so_37118426_37118638_1": {"section_id": 7545, "quality": 0.8205128205128205, "length": 32}}}, "37119041": {"ParentId": "37118426", "CommentCount": "1", "CreationDate": "2016-05-09T14:59:33.503", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "37119041", "Score": "4", "Body": "<p>Although the <code>reinterpret_cast</code> itself might be unspecified behaviour, attempting to access the parameters once you've done the cast is undefined behaviour.</p>\n<blockquote>\n<p id=\"so_37118426_37119041_0\"><code>N3337 [basic.lval]/10:</code>\n  If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined</p>\n<p id=\"so_37118426_37119041_1\">\u2014 the dynamic type of the object,</p>\n<p id=\"so_37118426_37119041_2\">\u2014 a cv-qualified version of the dynamic type of the object,</p>\n<p id=\"so_37118426_37119041_3\">\u2014 a type similar (as defined in 4.4) to the dynamic type of the object,</p>\n<p id=\"so_37118426_37119041_4\">\u2014 a type that is the signed or unsigned type corresponding to the dynamic type of the object,</p>\n<p id=\"so_37118426_37119041_5\">\u2014 a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type\n  of the object,</p>\n<p id=\"so_37118426_37119041_6\">\u2014 an aggregate or union type that includes one of the aforementioned types among its elements or non-\n  static data members (including, recursively, an element or non-static data member of a subaggregate\n  or contained union),</p>\n<p id=\"so_37118426_37119041_7\">\u2014 a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</p>\n<p id=\"so_37118426_37119041_8\">\u2014 a char or unsigned char type.</p>\n</blockquote>\n<p>Your example is none of the above.</p>\n", "LastActivityDate": "2016-05-09T14:59:33.503"}});