post_cb({"47020276": {"CommentCount": "9", "ViewCount": "112", "PostTypeId": "1", "LastEditorUserId": "2195807", "CreationDate": "2017-10-30T16:42:15.590", "LastActivityDate": "2017-10-30T17:41:14.537", "Title": "n={0,1,...,n-1} in C++", "AcceptedAnswerId": "47020785", "LastEditDate": "2017-10-30T17:14:02.470", "Id": "47020276", "Score": "-1", "Body": "<p>The formal definition (in set theory) of a natural number n is as follows:</p>\n<ul>\n<li>0 is the empty set</li>\n<li>1 = {0}</li>\n<li>n = {0,1,...,n-1}</li>\n</ul>\n<p>I think this would make some C++ code much simpler, if I was allowed to do this:</p>\n<pre><code>for (int n : 10)\n    cout &lt;&lt; n &lt;&lt; endl;\n</code></pre>\n<p>and it printed numbers from 0 to 9.</p>\n<p>So I tried doing the following, which doesn't compile:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;boost/iterator/counting_iterator.hpp&gt;\n\n\n    boost::counting_iterator&lt;int&gt; begin(int t)\n    {\n        return boost::counting_iterator&lt;int&gt;(0);\n    }\n\n    boost::counting_iterator&lt;int&gt; end(int t)\n    {\n        return boost::counting_iterator&lt;int&gt;(t);\n    }\n\n\n\nint main() \n{\n    for (int t : 10)\n        std::cout &lt;&lt; t &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Any suggestions on how to achieve this? I get the following error with clang++:</p>\n<pre><code>main.cpp:22:20: error: invalid range expression of type 'int'; no viable 'begin' function available\n        for (int t : 10)\n                ^ ~~\n</code></pre>\n<p>but I think I should be allowed to do this! :)</p>\n<p><em>Edit</em>: I know I can \"fake\" it if I add the word \"range\" (or some other word) in the for loop, but I'm wondering if it's possible to do it without.</p>\n", "Tags": "<c++><c++14><set-theory>", "OwnerUserId": "2195807", "AnswerCount": "4"}, "47020824": {"ParentId": "47020276", "CommentCount": "4", "Body": "<p>Just for fun...</p>\n<p>You have tagged this question C++14 so you can use <code>std::integer_sequence</code> and <code>std::make_integer_sequence</code>.</p>\n<p>If the natural number is known compile time (as <code>10</code> in your example), you can write a simple <code>constexpr</code> function <code>getArray()</code> (with helper function <code>getArrayH</code>) the get an <code>std::array</code> of values from zero to <code>N-1</code></p>\n<pre><code>template &lt;typename T, T ... Vals&gt;\nconstexpr std::array&lt;T, sizeof...(Vals)&gt;\n   getArrayH (std::integer_sequence&lt;T, Vals...&gt; const &amp;)\n { return { { Vals... } }; }\n\ntemplate &lt;typename T, T Val&gt;\nconstexpr auto getArray ()\n { return getArrayH(std::make_integer_sequence&lt;T, Val&gt;{}); }\n</code></pre>\n<p>and call it </p>\n<pre><code>for ( auto const &amp; i : getArray&lt;int, 10&gt;() )\n</code></pre>\n<p>The following is a full working example</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T, T ... Vals&gt;\nconstexpr std::array&lt;T, sizeof...(Vals)&gt;\n   getArrayH (std::integer_sequence&lt;T, Vals...&gt; const &amp;)\n { return { { Vals... } }; }\n\ntemplate &lt;typename T, T Val&gt;\nconstexpr auto getArray ()\n { return getArrayH(std::make_integer_sequence&lt;T, Val&gt;{}); }\n\nint main ()\n {\n   for ( auto const &amp; i : getArray&lt;int, 10&gt;() )\n      std::cout &lt;&lt; i &lt;&lt; std::endl;\n }\n</code></pre>\n", "OwnerUserId": "6022656", "PostTypeId": "2", "Id": "47020824", "Score": "0", "CreationDate": "2017-10-30T17:14:39.667", "LastActivityDate": "2017-10-30T17:14:39.667"}, "47020888": {"ParentId": "47020276", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If you look at <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow noreferrer\">the cppreference page for range-based <code>for</code> loops</a>, or better yet the relevant section of the standard (<a href=\"https://timsong-cpp.github.io/cppwp/n4140/stmt.ranged#1\" rel=\"nofollow noreferrer\" title=\"Relevant section of C++14 draft standard\">[stmt.ranged]p1</a>), you see how it determines the <em><code>begin_expr</code></em> to use for the loop. The relevant one for <code>int</code> is</p>\n<blockquote>\n<p id=\"so_47020276_47020888_0\"><a href=\"https://timsong-cpp.github.io/cppwp/n4140/stmt.ranged#1.3\" rel=\"nofollow noreferrer\">(1.3)</a> otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where begin and end are looked up in the associated namespaces (<a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.lookup.argdep\" rel=\"nofollow noreferrer\">[basic.lookup.argdep]</a>). <strong>[ <em>Note</em>: Ordinary unqualified lookup (<a href=\"https://timsong-cpp.github.io/cppwp/n4140/basic.lookup.unqual\" rel=\"nofollow noreferrer\">[basic.lookup.unqual]</a>) is not performed.  \u2014 <em>end note</em> ]</strong></p>\n</blockquote>\n<p>(<strong>emphasis</strong> added)</p>\n<p>Unfortunately for use case, for fundamental types such as <code>int</code>, argument-dependent lookup never returns anything.</p>\n<p>Instead, what you can do is declare a class to act as the range expression, and give it <code>begin</code> and <code>end</code> methods:</p>\n<pre><code>struct Range {\n    using value_type = unsigned int;\n    using iterator = boost::counting_iterator&lt;value_type&gt;;\n\n    unsigned int max;\n\n    iterator begin() const\n    {\n        return iterator(0);\n    }\n\n    iterator end() const\n    {\n        return iterator(max);\n    }\n};\n</code></pre>\n<p>Potential improvements to this class include:</p>\n<ul>\n<li>Making the <code>begin</code> and <code>end</code> methods <code>constexpr</code> (this requires writing your own version of <code>boost::counting_iterator</code>, or getting Boost to make their version <code>constexpr</code>)</li>\n<li>Adding a user-defined literal option like <code>Range operator\"\"_range</code></li>\n<li>Making it work for types other than just <code>unsigned int</code>.</li>\n</ul>\n<p><a href=\"https://godbolt.org/g/rsRHb6\" rel=\"nofollow noreferrer\">live demo</a></p>\n", "OwnerUserId": "27302", "LastEditorUserId": "27302", "LastEditDate": "2017-10-30T17:41:14.537", "Id": "47020888", "Score": "1", "CreationDate": "2017-10-30T17:19:06.817", "LastActivityDate": "2017-10-30T17:41:14.537"}, "47020429": {"ParentId": "47020276", "CommentCount": "4", "Body": "<p>You may use some syntax close to what you want, but you would need an array with the numbers through which you want to iterate.</p>\n<pre><code>int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nfor (int n : a)\n    std::cout &lt;&lt; n &lt;&lt; std::endl;\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/range-for</a></p>\n<p><strong>Edit</strong>: to create the array without declaring each value you may check this question: <a href=\"https://stackoverflow.com/questions/13152252/is-there-a-compact-equivalent-to-python-range-in-c-stl\">Is there a compact equivalent to Python range() in C++/STL</a></p>\n", "OwnerUserId": "2862952", "PostTypeId": "2", "Id": "47020429", "Score": "-1", "CreationDate": "2017-10-30T16:52:31.310", "LastActivityDate": "2017-10-30T16:52:31.310"}, "47020785": {"ParentId": "47020276", "CommentCount": "2", "Body": "<p>It can't be done.  From section 6.5.4 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"noreferrer\">draft of the C++ 14 standard</a> (but C++11 will be very similar)</p>\n<blockquote>\n<p id=\"so_47020276_47020785_0\"><em>begin-expr</em> and <em>end-expr</em> are determined as follows:</p>\n<p id=\"so_47020276_47020785_1\">(1.1) \u2014 if _<code>RangeT</code> is an array type, [...];</p>\n</blockquote>\n<p>Well, this one obviously doesn't apply.  An <code>int</code> isn't an array</p>\n<blockquote>\n<p id=\"so_47020276_47020785_2\">(1.2) \u2014 if _RangeT is a class type, [...]</p>\n</blockquote>\n<p>Nope, this doesn't apply either.</p>\n<blockquote>\n<p id=\"so_47020276_47020785_3\">(1.3) \u2014 otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, </p>\n</blockquote>\n<p>Oo!  This looks hopeful.  You may need to move <code>begin</code> and <code>end</code> into the global namespace, but still...</p>\n<blockquote>\n<p id=\"so_47020276_47020785_4\">where <code>begin</code>\n  and <code>end</code> are looked up in the associated namespaces (3.4.2). <strong>[ Note: Ordinary unqualified lookup (3.4.1)\n  is not performed. \u2014 end note ]</strong></p>\n</blockquote>\n<p>(emphasis mine).  Bother!  There aren't any namespaces associated with <code>int</code>.  Specifically, from section 3.4.2</p>\n<blockquote>\n<p id=\"so_47020276_47020785_5\">\u2014 If T [<code>int</code> in our case] is a fundamental type, its associated sets of namespaces and classes are both empty.</p>\n</blockquote>\n<p>The only workround is to write a class <code>range</code> which has a suitable begin and end method.  Then you could write the very pythonic:</p>\n<pre><code>for (int i : range(5))\n</code></pre>\n", "OwnerUserId": "771073", "PostTypeId": "2", "Id": "47020785", "Score": "9", "CreationDate": "2017-10-30T17:12:50.773", "LastActivityDate": "2017-10-30T17:12:50.773"}, "bq_ids": {"n4140": {"so_47020276_47020785_3": {"section_id": 3906, "quality": 0.8333333333333334, "length": 5}, "so_47020276_47020888_0": {"section_id": 3906, "quality": 0.7142857142857143, "length": 15}, "so_47020276_47020785_5": {"section_id": 7104, "quality": 0.75, "length": 9}, "so_47020276_47020785_4": {"section_id": 3906, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_47020276_47020785_3": {"section_id": 3766, "quality": 0.8333333333333334, "length": 5}, "so_47020276_47020785_5": {"section_id": 6848, "quality": 0.75, "length": 9}}, "n4659": {"so_47020276_47020785_3": {"section_id": 4792, "quality": 0.8333333333333334, "length": 5}, "so_47020276_47020888_0": {"section_id": 4792, "quality": 0.7142857142857143, "length": 15}, "so_47020276_47020785_5": {"section_id": 8605, "quality": 0.75, "length": 9}, "so_47020276_47020785_4": {"section_id": 4792, "quality": 0.6666666666666666, "length": 10}, "so_47020276_47020785_0": {"section_id": 4792, "quality": 1.0, "length": 4}}}});