post_cb({"bq_ids": {"n4140": {"so_27695528_27698437_0": {"length": 88, "quality": 0.946236559139785, "section_id": 481}, "so_27695528_27698437_1": {"length": 12, "quality": 1.0, "section_id": 480}, "so_27695528_27698437_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 480}}, "n3337": {"so_27695528_27698437_0": {"length": 64, "quality": 0.6881720430107527, "section_id": 472}, "so_27695528_27698437_1": {"length": 12, "quality": 1.0, "section_id": 471}, "so_27695528_27698437_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 471}}, "n4659": {"so_27695528_27698437_0": {"length": 77, "quality": 0.8279569892473119, "section_id": 504}, "so_27695528_27698437_1": {"length": 12, "quality": 1.0, "section_id": 502}, "so_27695528_27698437_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 502}}}, "27698437": {"Id": "27698437", "PostTypeId": "2", "Body": "<ol>\n<li><p>Despite the fact that the move might be elided, Yes. A copy will never happen if a move constructor is available. I'll quote the paragraph again for clarity. [class.copy]/32:</p>\n<blockquote>\n<p id=\"so_27695528_27698437_0\"><strong>When the criteria for elision of a copy/move operation are met</strong>, but\n  not for an <em>exception-declaration</em>, <strong>and the object to be copied is\n  designated by an lvalue, or when the expression in a <code>return</code>\n  statement is a (possibly parenthesized) <em>id-expression</em> that names an\n  object with automatic storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em>,</strong> <strong>overload resolution to select the constructor for the copy is first performed as if the object were designated by an\n  rvalue</strong>.   If the first overload resolution fails or was not\n  performed, or if the type of the first parameter of the selected\n  constructor is not an rvalue reference to the object\u2019s type (possibly\n  cv-qualified), overload resolution is performed again, considering the\n  object as an lvalue. [<em>Note:</em> This two-stage overload resolution must\n  be performed regardless of whether copy elision will occur. It\n  determines the constructor to be called if elision is not performed,\n  and the selected constructor must be accessible even if the call is\n  elided. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>Applying <code>std::move</code> is not superfluous but actually <strong>prevents</strong> copy elision from being performed, [class.copy]/31:</p>\n<blockquote>\n<p id=\"so_27695528_27698437_1\">\u2014 in a <code>return</code> statement in a function with a class return type, when\n  the expression is <strong>the name of a non-volatile automatic object</strong> [..]</p>\n</blockquote></li>\n<li><p>Yes, one situation - Again I assume you meant that if copy elision isn't performed, a move is done (Copy elision must be applicable if the lvalue is moved, s.a.).<br>\nConsider this:</br></p>\n<pre><code>A a;\nthrow a;\n</code></pre>\n<p>The criteria are met:</p>\n<blockquote>\n<p id=\"so_27695528_27698437_2\">\u2014 in a <em>throw-expression</em>, when the operand is the name of a\n  non-volatile automatic object (other than a function or catch-clause\n  parameter) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from\n  the operand to the exception object (15.1) can be omitted by\n  constructing the automatic object directly into the exception object</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9a0f51e88400f458\" rel=\"nofollow\"><strong>Demo</strong></a>.<br>\nThis is the only other case where an lvalue is moved instead of copied; The other two cases for copy elision solely include temporaries not bound to a reference (which must therefore be designated by prvalues) and the exception-declaration thingy, which is uninteresting here as it covers the exception object we don't see.</br></p></li>\n</ol>\n", "LastEditorUserId": "701092", "LastActivityDate": "2014-12-30T02:10:09.117", "Score": "4", "CreationDate": "2014-12-30T01:24:41.617", "ParentId": "27695528", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-12-30T02:10:09.117"}, "27698074": {"Id": "27698074", "PostTypeId": "2", "Body": "<p>I think this is a case of return value optimization.\n<a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Return_value_optimization</a>\nThe compiler will not copy or move the object at all but identify it.\nSo, no, I would not write <code>return std::move(result)</code> it may even keep the compiler from optimizing.</p>\n", "LastActivityDate": "2014-12-30T00:39:28.057", "CommentCount": "0", "CreationDate": "2014-12-30T00:39:28.057", "ParentId": "27695528", "Score": "0", "OwnerUserId": "414934"}, "27695528": {"ViewCount": "150", "Body": "<p>Given the following:</p>\n<pre><code>Foo getFoo()\n{\n    Foo result = doSomeWork();\n    return result;\n}\n</code></pre>\n<ul>\n<li><p>Does C++ guarantee that <code>result</code> will be moved, instead of copied? Or to put it another way, is writing <code>return std::move(result)</code> superfluous? </p></li>\n<li><p>Are there any (other) situations where the standard specifies that a lvalue will be silently moved instead of copied, in the absence of an explicit <code>std::move</code> cast?</p></li>\n</ul>\n<p><strong>Notes:</strong></p>\n<ul>\n<li><p>Assume <code>Foo</code> is move-constructible.</p></li>\n<li><p>Disregarding copy/move elision, which may apply in addition.</p></li>\n</ul>\n", "AcceptedAnswerId": "27698437", "Title": "When are lvalues moved instead of copied in C++?", "CreationDate": "2014-12-29T20:26:46.273", "Id": "27695528", "CommentCount": "13", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-30T12:13:26.963", "LastEditorUserId": "598465", "LastActivityDate": "2014-12-30T12:13:26.963", "Score": "6", "OwnerUserId": "598465", "Tags": "<c++><move><move-semantics>", "AnswerCount": "2"}});