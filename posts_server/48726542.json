post_cb({"48726542": {"ViewCount": "57", "Body": "<p>In a legacy project I am maintaining in my freetime, operators <code>delete</code>/<code>new</code> and <code>delete[]</code>/<code>new[]</code> were overloaded to spot mismatches (<code>new[]</code> allocated object <code>delete</code>d and vice versa).</p>\n<p>The original prefix had a length of 9 bytes. It has not led to issues since at least VS2010, and possibly even since VS6.</p>\n<p>I have recently tackled rewriting this piece of code and to that end asked a question at <a href=\"https://codereview.stackexchange.com/q/186750/159753\">codereview.stackexchange</a>. The old prefixes had ended with one identical character which I removed, so my prefix was only 8 bytes long. Two people noted that this might break alignment and one referred to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">C++ standard paragraph 6.11 Alignment</a>... Unfortunately I fail to grasp the issue from reading it.</p>\n<p>The second sentence there reads as follows:</p>\n<blockquote>\n<p id=\"so_48726542_48726542_0\">An alignment is an implementation-defined integer value representing\n  the number of bytes between successive addresses at which a given object can be allocated.</p>\n</blockquote>\n<p>... And as far as I understand this definition means that all is well:</p>\n<ol>\n<li>If I allocate a single object, the OS has to handle distance to the previous and next objects in dynamic memory. Distance to the previous object will only increase by length of the prefix. Such distances are presumably not part of alignment. So, okay.</li>\n<li>If I allocate an array, alignment between its elements has been handled before <code>operator new[]</code> gets its <code>size</code> parameter. I do not change this, so okay.\n\n<ul>\n<li>For begin and end of the array, considerations at 1) apply.</li>\n</ul></li>\n</ol>\n<p>All seems to be perfectly fine. Yet, questions such as <a href=\"https://stackoverflow.com/questions/2366879/operator-new-overloading-and-alignment\">this one</a> clearly signal that special alignment handling must be necessary in <em>some cases</em>.</p>\n<ul>\n<li>What characterises these cases?</li>\n<li>How can I generate such cases?</li>\n<li>What invalidates my assumption that all is fine?</li>\n</ul>\n<p>Or am I right and this is a perfectly harmless state of affairs?</p>\n<p>Here is a code snippet illustrating the principle behind the overloads in question. Refer to my <a href=\"https://codereview.stackexchange.com/q/186750/159753\">original question</a> for a complete (and safer) example.</p>\n<pre><code>constexpr char PREFIX[] = \"str1med\";\nconstexpr std::size_t OFFSET = sizeof(PREFIX);\n\nvoid * operator new(std::size_t size)\n{\n  void * pointer = std::malloc(size + OFFSET);\n  std::memcpy(pointer, PREFIX, OFFSET);\n  return reinterpret_cast&lt;std::byte*&gt;(pointer) + OFFSET;\n}\n\nvoid operator delete(void * untypedPointer)\n{\n  std::byte * pointer = reinterpret_cast&lt;std::byte*&gt;(untypedPointer);\n  pointer -= OFFSET;\n  assert(std::memcmp(pointer, prefix, OFFSET) == 0);\n  std::free(pointer);\n}\n</code></pre>\n", "Title": "When an overloaded operator new offsets a pointer by an additional prefix, how does the class of problematic cases look like", "CreationDate": "2018-02-10T23:08:59.357", "LastActivityDate": "2018-02-17T12:34:58.633", "CommentCount": "5", "LastEditDate": "2018-02-10T23:16:36.483", "PostTypeId": "1", "LastEditorUserId": "3434465", "Id": "48726542", "Score": "0", "OwnerUserId": "3434465", "Tags": "<c++><language-lawyer><new-operator><memory-alignment>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_48726542_48726542_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7240}, "so_48726542_48841332_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 7189}, "so_48726542_48841332_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7240}}, "n3337": {"so_48726542_48841332_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6984}, "so_48726542_48726542_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6984}, "so_48726542_48841332_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 6933}}, "n4659": {"so_48726542_48841332_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 8749}, "so_48726542_48726542_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 8749}, "so_48726542_48841332_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 8697}}}, "48726674": {"Id": "48726674", "PostTypeId": "2", "Body": "<p>You can generally infer the alignment requirement as being the largest power of two which is a factor of the requested size (this may be overly pessimistic at times).  The occasions I'm aware of that require alignment better than 8 bytes on Windows are SIMD types and pointers used with <code>FILE_FLAG_NO_BUFFERING</code>.</p>\n<p>Example:</p>\n<pre><code>auto required_alignment = size &amp; (size ^ (size-1));\n</code></pre>\n<p>Unfortunately, the deallocator in most cases doesn't receive the size parameter, so you can't retrieve the offset using the same rule.  However, if you encode the actual offset used during allocation in some fashion in the canary bytes immediately before the object, you can check the minimum size canary first, and from that recover the actual offset, original pointer, and check the full canary.</p>\n<p>In your case, probably support for 16 byte alignment will suffice.  Then you just need</p>\n<pre><code>auto align_16b = !(size &amp; 0x0F);\n</code></pre>\n<p>and have a different canary for 16 byte aligned allocations.  <code>operator delete()</code> then tests the preceding 8 bytes against both the 8 byte canary and the latter half of the 16 byte canary.</p>\n<p><strong>Important note</strong>: When the alignment requirement is greater than the alignment the underlying allocator provides, the offset may end up being different from the alignment.  In this case <strong><code>operator delete()</code> only needs to figure out the offset and doesn't care about the alignment requirement.</strong></p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2018-02-11T01:56:12.983", "Score": "2", "CreationDate": "2018-02-10T23:27:46.653", "ParentId": "48726542", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2018-02-11T01:56:12.983"}, "48841332": {"Id": "48841332", "PostTypeId": "2", "Body": "<p>[Note: This answer references Standard draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"nofollow noreferrer\">n4659</a>.]</p>\n<hr>\n<p>Given the quote of $6.11 from the question:</p>\n<blockquote>\n<p id=\"so_48726542_48841332_0\">An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated.</p>\n</blockquote>\n<p>it is easy to find that, <em>should alignment requirements be violated</em>, the most basic concept of <em>object lifetime</em> becomes undefined: Under $6.8.1.1 we can read</p>\n<blockquote>\n<p id=\"so_48726542_48841332_1\">[The lifetime of an object of type T begins when] storage with the proper alignment and size for type T is obtained, [...]</p>\n</blockquote>\n<p>An incorrectly aligned object therefore never begins its lifetime. It then stands to reason that the following behaviours would be \"okay\" for a Standard-compliant compiler:</p>\n<ul>\n<li>never calling the constructor</li>\n<li>immediately calling the destructor</li>\n<li>Nasal Demons</li>\n</ul>\n<p>Thus, alignment must be correct for the program to be wellformed.</p>\n<hr>\n<p>But <em>when</em> is alignment incorrect?</p>\n<p>As seen in the question, one possible interpretation of $6.11 is the following:</p>\n<pre><code>Be A the alignment required of class C.\n- then objects Oi of class C must have at least A bytes between them\n- if Oi have exactly A between them, they form an array\n</code></pre>\n<p>Under this interpretation, adding a prefix of arbitrary size to the memory to be occupied by a single object is always okay. Similarly, adding such a prefix to the memory to be occupied by an array of objects is always okay.</p>\n<p>There is however a more strict interpretation of the same paragraph:</p>\n<pre><code>Be A the alignment required of class C.\n- then objects Oi of class C must have exactly a multiple of A between them\n- if Oi have exactly A between them, they form an array\n</code></pre>\n<p>This interpretation would mean that alignment A describes exactly the memory adresses where an object O may reside via the term <code>0 + A * j = &amp;Oi for i, j in N</code>. Given that memory is virtual and even if allocated may or may not physically exist, this is at least somewhat surprising.</p>\n<p>However, @Peter has commented that this is indeed the correct interpretation. It immediately follows, that prefixing the memory allocated for any object must ensure that <code>A + sizeof(prefix) % A = 0</code> or else Nasal Demons.</p>\n<p>[Note: This answer could be improved by providing a quote from the standard which supports the later interpretation. Sadly even after a token amount of scanning I have not yet been able to come up with a fitting passage.]</p>\n</hr></hr>", "LastActivityDate": "2018-02-17T12:34:58.633", "CommentCount": "4", "CreationDate": "2018-02-17T12:34:58.633", "ParentId": "48726542", "Score": "0", "OwnerUserId": "3434465"}, "48727122": {"Id": "48727122", "PostTypeId": "2", "Body": "<p><a href=\"https://wandbox.org/permlink/rPY6yj4uvOFRUDv9\" rel=\"nofollow noreferrer\">Check it out:</a></p>\n<pre><code>#define PREFIX \"str1med\"  // canary size = 8\n\nconstexpr std::size_t OFFSET = sizeof(PREFIX);\n\nvoid *operator new(std::size_t size) {\n  void * pointer = std::malloc(size + OFFSET);\n  std::memcpy(pointer, PREFIX, OFFSET);\n  return reinterpret_cast&lt;char*&gt;(pointer) + OFFSET;\n}\n\nvoid operator delete(void * untypedPointer) {\n  char * pointer = reinterpret_cast&lt;char*&gt;(untypedPointer);\n  pointer -= OFFSET;\n  assert(std::memcmp(pointer, PREFIX, OFFSET) == 0);\n  std::free(pointer);\n}\n\nint main() {\n    int *p = new int;\n    printf(\"%p\\n\", p);\n}\n</code></pre>\n<p>This should print an 8-byte-aligned pointer value, which is suitably aligned for an <code>int</code>.\nBut now change the canary string value from <code>\"str1med\"</code> to, let's say, <a href=\"https://wandbox.org/permlink/3VOUkmi2EFPAfXUF\" rel=\"nofollow noreferrer\"><code>\"str10med\"</code></a>.</p>\n<pre><code>int main() {\n    int *p = new int;\n    printf(\"%p\\n\", p);\n}\n</code></pre>\n<p>Now this prints a pointer value whose low-order four bits are <code>0x9</code>. It's not suitably aligned for an <code>int</code> anymore!</p>\n<p>The problem with your original code is that if a maintainer or refactorer changes the <em>length</em> of the string <code>PREFIX</code>, it breaks <code>operator new</code>. This is highly unexpected behavior to most programmers; we're not used to thinking of the <em>length</em> of a string as \"significant\" unless it's called out explicitly. You could mitigate this problem in your code by calling out the dependency explicitly:</p>\n<pre><code>constexpr std::size_t OFFSET = sizeof(PREFIX);\nstatic_assert(OFFSET % 8 == 0, \"preserve 8-byte alignment of new'ed chunks\");\n</code></pre>\n<p>(This would also tell the reader that 16-byte alignment of new'ed chunks is explicitly <em>not</em> one of your goals.)</p>\n", "LastActivityDate": "2018-02-11T00:48:14.200", "CommentCount": "2", "CreationDate": "2018-02-11T00:48:14.200", "ParentId": "48726542", "Score": "1", "OwnerUserId": "1424877"}});