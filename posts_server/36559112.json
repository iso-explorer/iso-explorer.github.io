post_cb({"bq_ids": {"n4140": {"so_36559112_36559135_1": {"length": 15, "quality": 0.9375, "section_id": 5986}}, "n4659": {"so_36559112_36559135_1": {"length": 15, "quality": 0.9375, "section_id": 7486}}}, "36559135": {"Id": "36559135", "PostTypeId": "2", "LastEditDate": "2017-05-23T11:51:32.040", "CommentCount": "5", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-11T21:39:22.027", "CreationDate": "2016-04-11T21:00:39.680", "ParentId": "36559112", "Score": "7", "Body": "<p>Assuming no operator overloading, they are nearly the same.</p>\n<p><strong>[C] 6.5.2.1 Array subscripting</strong>:</p>\n<blockquote>\n<p id=\"so_36559112_36559135_0\"><code>E1[E2]</code> is identical to <code>(*((E1)+(E2)))</code></p>\n</blockquote>\n<p><strong>[C++] 5.2.1 Subscripting</strong>:</p>\n<blockquote>\n<p id=\"so_36559112_36559135_1\">The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code> ...  , except that in the case of an array operand, the result is an\n  lvalue if that operand is an lvalue and an xvalue otherwise.</p>\n</blockquote>\n<p>See the great <a href=\"https://stackoverflow.com/a/36559374/3246555\">answer</a> of <strong>@T.C</strong> regarding the last part. </p>\n", "OwnerUserId": "3246555"}, "36559374": {"Id": "36559374", "PostTypeId": "2", "Body": "<p>Ignoring overloaded operators, there's one case there is a difference, and that's array rvalues post-<a href=\"http://wg21.link/cwg1213\">DR1213</a>:</p>\n<pre><code>using arr = int[2];\narr&amp;&amp; f();\nint&amp;&amp; b = *f(); // error, *f() is an lvalue, doesn't bind to int&amp;&amp;\nint&amp;&amp; c = f()[0]; // OK, subscript applied to array rvalue results in an xvalue\n</code></pre>\n<p>I don't know of any compiler that implements that resolution, though. But it should be implemented eventually.</p>\n", "Score": "11", "LastActivityDate": "2016-04-11T21:15:08.373", "CreationDate": "2016-04-11T21:15:08.373", "ParentId": "36559112", "CommentCount": "1", "OwnerUserId": "2756719"}, "36559161": {"Id": "36559161", "PostTypeId": "2", "Body": "<p>For pointers, they should give the same result.</p>\n<p>The only time that they could differ is if you are applying them on a user-defined type that overloads <code>operator*()</code> and <code>operator[](int)</code> differently (or one and not the other, in which case you would get a compile error).</p>\n", "Score": "4", "LastActivityDate": "2016-04-11T21:02:19.433", "CreationDate": "2016-04-11T21:02:19.433", "ParentId": "36559112", "CommentCount": "0", "OwnerUserId": "5298959"}, "36559112": {"ViewCount": "180", "LastEditDate": "2016-04-11T21:04:57.027", "AcceptedAnswerId": "36559374", "Title": "In C++, do dereferencing and getting index zero do the same tihng?", "CreationDate": "2016-04-11T20:58:38.497", "LastActivityDate": "2016-04-11T21:39:22.027", "CommentCount": "5", "Body": "<p>I just tried this code:</p>\n<pre><code>int i = 33;\nint * pi = &amp;i;\ncout &lt;&lt; \"i: \" &lt;&lt; *pi &lt;&lt; endl;\ncout &lt;&lt; \"i: \" &lt;&lt; pi[0] &lt;&lt; endl;\n</code></pre>\n<p>Both lines return the same thing.</p>\n<p>Essentially, if I get index zero of any pointer, I'll get the value of the correct type at the location of the pointer. Isn't that the same thing as dereferencing?</p>\n<p>Every time a pointer is dereferenced in C++, wouldn't getting index zero also work? I'm not suggesting anyone should actually <em>do</em> that, but I think it would <em>work</em>. Wouldn't it?</p>\n", "PostTypeId": "1", "LastEditorUserId": "4082723", "Id": "36559112", "Score": "6", "OwnerUserId": "313273", "Tags": "<c++><pointers><dereference>", "AnswerCount": "3"}});