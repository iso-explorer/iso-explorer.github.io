post_cb({"bq_ids": {"n4140": {"so_41583524_41584059_0": {"section_id": 7043, "quality": 1.0, "length": 32}}, "n3337": {"so_41583524_41584059_0": {"section_id": 6788, "quality": 1.0, "length": 32}}, "n4659": {"so_41583524_41584059_0": {"section_id": 8540, "quality": 1.0, "length": 32}}}, "41583524": {"CommentCount": "1", "ViewCount": "294", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2017-01-11T05:46:37.353", "LastActivityDate": "2017-01-23T16:56:03.477", "Title": "How does a class vtable work across shared libraries?", "AcceptedAnswerId": "41584059", "LastEditDate": "2017-01-23T16:56:03.477", "Id": "41583524", "Score": "2", "Body": "<p>Let's suppose I have a shared library named <code>libplugin</code>. In this shared library, there is a class:</p>\n<pre><code>class Plugin\n{\n    public:\n        virtual void doStuff();\n};\n</code></pre>\n<p>Let's also suppose that there is another shared library named <code>libspecialplugin</code>. It contains the following class and function:</p>\n<pre><code>class SpecialPlugin : public Plugin\n{\n    public:\n        virtual void doStuff();\n};\n\nPlugin *createSpecialPlugin()\n{\n    return new SpecialPlugin;\n}\n</code></pre>\n<p>Now, suppose I change <code>Plugin</code> and add the following method:</p>\n<pre><code>virtual void doMoreStuff();\n</code></pre>\n<p>I <em>do not</em> recompile <code>libspecialplugin</code>.</p>\n<p>What happens when I do this:</p>\n<pre><code>Plugin *plugin = createSpecialPlugin();\nplugin-&gt;doMoreStuff();\n</code></pre>\n<p>I'm guessing one of the following happens:</p>\n<ol>\n<li>the application crashes</li>\n<li>the <code>Plugin::doMoreStuff()</code> method is invoked</li>\n</ol>\n<p>Does the <code>libspecialplugin</code> library contain information that <code>libplugin</code> can use to determine which of its methods are overridden - even at runtime? I'm a little fuzzy on what exactly is supposed to happen here.</p>\n", "Tags": "<c++><vtable><virtual-method><one-definition-rule>", "OwnerUserId": "193619", "AnswerCount": "2"}, "41584055": {"ParentId": "41583524", "LastEditDate": "2017-01-11T06:36:06.177", "CommentCount": "0", "CreationDate": "2017-01-11T06:25:29.583", "OwnerUserId": "13422", "LastEditorUserId": "13422", "PostTypeId": "2", "Id": "41584055", "Score": "0", "Body": "<p>I have to add the giant disclaimer that \"Everything to do with vtables is implementation defined.\"</p>\n<p>This will work fine <em>provided that</em> the Plugin constructor and destructor are not declared inline in the header. It has to be an actual function call to the Plugin constructor in the libplugin.so library. This means the header has to declare the constructor and destructor but not define them in order to avoid generating the compiler's automatic versions. </p>\n<p>It would look like:</p>\n<pre><code>class Plugin\n{\n    public:\n        Plugin();\n        ~Plugin();\n        virtual void doStuff();\n};\n</code></pre>\n<p>Also provided that the new virtual function is added at the end of the class. If it causes any of the other functions in the vtable to move, that will ruin the ABI. </p>\n<p>Then when the Plugin base class is constructed it will create the new vtable with the extra function. Then SpecialPlugin will adjust its one virtual function and complete the construction.</p>\n<p>Some of this may depend on particular compiler implementations of vtbl pointers, but I have seen it done.</p>\n", "LastActivityDate": "2017-01-11T06:36:06.177"}, "41584059": {"ParentId": "41583524", "CommentCount": "1", "Body": "<p>You are effectively violating the \"One Definition Rule\" by having the same class (<code>Plugin</code>) defined differently in two different translation units within any program that uses the two libraries.</p>\n<p>The standard says (C++11 ISO 14882:2011, \u00a73.2 para 5):</p>\n<blockquote>\n<p id=\"so_41583524_41584059_0\">There can be more than one definition of a class type (Clause 9) ...\n  in a program provided that each definition appears in a different\n  translation unit, and provided the definitions satisfy the following\n  requirements. Given such an entity named D defined in more than one\n  translation unit, then:</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n</ul>\n<p id=\"so_41583524_41584059_1\">...</p>\n</blockquote>\n<p>Your class <code>Plugin</code> has two different definitions, one baked into libplugin and the other in libspecialplugin, so it does not comply with the standard. </p>\n<p>The outcome of this is not defined by the standard, so anything could happen.</p>\n", "OwnerUserId": "1411457", "PostTypeId": "2", "Id": "41584059", "Score": "6", "CreationDate": "2017-01-11T06:25:43.117", "LastActivityDate": "2017-01-11T06:25:43.117"}});