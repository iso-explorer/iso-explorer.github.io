post_cb({"bq_ids": {"n4140": {"so_12431495_12431603_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 336}, "so_12431495_12431810_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 336}}, "n3337": {"so_12431495_12431603_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 326}, "so_12431495_12431810_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 326}}, "n4659": {"so_12431495_12431603_0": {"length": 11, "quality": 0.6470588235294118, "section_id": 345}, "so_12431495_12431810_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 345}}}, "12431810": {"Id": "12431810", "PostTypeId": "2", "Body": "<p>Your first line <code>printme({'a', 'b', 'c'})</code> is illegal because the template argument <code>T</code> could not be inferred. If you explicitly specify the template argument it will work, e.g. <code>printme&lt;vector&lt;char&gt;&gt;({'a', 'b', 'c'})</code> or <code>printme&lt;initializer_list&lt;char&gt;&gt;({'a', 'b', 'c'})</code>.</p>\n<p>The other ones you listed are legal because the argument has a well-defined type, so the template argument <code>T</code> can be deduced just fine.</p>\n<p>Your snippet with <code>auto</code> also works because <code>il</code> is considered to be of type <code>std::initializer_list&lt;char&gt;</code>, and therefore the template argument to <code>printme()</code> can be deduced.</p>\n<hr>\n<p>The only \"funny\" part here is that <code>auto</code> will pick the type <code>std::initializer_list&lt;char&gt;</code> but the template argument will not. This is because \u00a7 14.8.2.5/5 of the C++11 standard explicitly states that this is a non-deduced context for a template argument:</p>\n<blockquote>\n<p id=\"so_12431495_12431810_0\">A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter does not have std::initializer_list or reference to possibly cv-qualified std::initializer_list type. <em>[Example:</em></p>\n<pre><code>template&lt;class T&gt; void g(T);\ng({1,2,3}); // error: no argument deduced for T\n</code></pre>\n<p id=\"so_12431495_12431810_1\"><em>\u2014 end example ]</em></p>\n</blockquote>\n<p>However with <code>auto</code>, \u00a7 7.1.6.4/6 has explicit support for <code>std::initializer_list&lt;&gt;</code></p>\n<blockquote>\n<p id=\"so_12431495_12431810_2\">if the initializer is a <em>braced-init-list</em> (8.5.4), with <code>std::initializer_list&lt;U&gt;</code>.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "582", "LastActivityDate": "2012-09-14T20:59:36.533", "Score": "29", "CreationDate": "2012-09-14T20:51:49.847", "ParentId": "12431495", "CommentCount": "4", "LastEditDate": "2012-09-14T20:59:36.533", "OwnerUserId": "582"}, "12431495": {"ViewCount": "3941", "Body": "<p>Consider the function:</p>\n<pre><code>template&lt;typename T&gt;\nvoid printme(T&amp;&amp; t) {\n  for (auto i : t)\n    std::cout &lt;&lt; i;\n}\n</code></pre>\n<p>or any other function that expects one parameter with a begin()/end() - enabled type.</p>\n<p><strong>Why is the following illegal?</strong></p>\n<p><code>printme({'a', 'b', 'c'});</code></p>\n<p>When all these are legitimate:</p>\n<pre><code>printme(std::vector&lt;char&gt;({'a', 'b', 'c'}));\nprintme(std::string(\"abc\"));\nprintme(std::array&lt;char, 3&gt; {'a', 'b', 'c'});\n</code></pre>\n<p>We can even write this:</p>\n<pre><code>const auto il = {'a', 'b', 'c'};\nprintme(il);\n</code></pre>\n<p>or</p>\n<pre><code>printme&lt;std::initializer_list&lt;char&gt;&gt;({'a', 'b', 'c'});\n</code></pre>\n", "AcceptedAnswerId": "12431810", "Title": "initializer_list and template type deduction", "CreationDate": "2012-09-14T20:23:58.027", "Id": "12431495", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2012-09-14T20:55:21.600", "LastEditorUserId": "241631", "LastActivityDate": "2012-09-14T23:11:49.787", "Score": "24", "OwnerUserId": "448481", "Tags": "<c++><templates><c++11><initializer-list>", "AnswerCount": "3"}, "12431603": {"Id": "12431603", "PostTypeId": "2", "Body": "<p>This is specifically covered under \u00a7 14.8.2.5/5</p>\n<blockquote>\n<p id=\"so_12431495_12431603_0\">A function parameter for which the associated argument is an\n  initializer list but the parameter does not have\n  <code>std::initializer_list</code> or reference to possibly cv-qualified\n  <code>std::initializer_list</code> type. [ Example: </p>\n<pre><code>template&lt;class T&gt; void g(T);\ng({1,2,3}); // error: no argument deduced for T\n</code></pre>\n<p id=\"so_12431495_12431603_1\">\u2014end example ]</p>\n</blockquote>\n<p>To make it work, you can specify the template argument type explicitly.</p>\n<pre><code>printme&lt;std::initializer_list&lt;int&gt;&gt;( {1,2,3,4} );\n</code></pre>\n", "LastEditorUserId": "241631", "LastActivityDate": "2012-09-14T20:57:18.807", "Score": "4", "CreationDate": "2012-09-14T20:33:19.800", "ParentId": "12431495", "CommentCount": "0", "LastEditDate": "2012-09-14T20:57:18.807", "OwnerUserId": "241631"}, "12433112": {"Id": "12433112", "PostTypeId": "2", "Body": "<p>You can also overload the function to explicitly take an argument of type initializer_list.</p>\n<pre><code>template&lt;typename T&gt;\nvoid printme(std::initializer_list&lt;T&gt; t) {\n  for (auto i : t)\n    std::cout &lt;&lt; i;\n}\n</code></pre>\n", "LastActivityDate": "2012-09-14T23:11:49.787", "Score": "6", "CreationDate": "2012-09-14T23:11:49.787", "ParentId": "12431495", "CommentCount": "5", "OwnerUserId": "1672626"}});