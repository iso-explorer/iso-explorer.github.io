post_cb({"24278084": {"Id": "24278084", "PostTypeId": "2", "Body": "<p>This works for me:</p>\n<pre><code>template &lt;typename It, typename Pred,\n          typename Comp = std::less&lt;decltype(*std::declval&lt;It&gt;())&gt;&gt;\nIt minElementWhere(\n    It begin,\n    It end,\n    Pred pred = Pred(),\n    Comp comp = Comp()\n) {\n    It minElement = end;\n\n    for (It it = begin; it != end; ++it) {\n        if (!pred(*it)) {\n            continue;\n        }\n\n        if (comp(*it, *minElement)) {\n            minElement = it;\n        }\n    }\n\n    return minElement;\n}\n</code></pre>\n", "LastActivityDate": "2014-06-18T06:01:25.143", "CommentCount": "0", "CreationDate": "2014-06-18T06:01:25.143", "ParentId": "24277974", "Score": "1", "OwnerUserId": "434551"}, "bq_ids": {"n4140": {"so_24277974_24278483_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 336}}, "n3337": {"so_24277974_24278483_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 326}}, "n4659": {"so_24277974_24278483_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 345}}}, "24278483": {"Id": "24278483", "PostTypeId": "2", "Body": "<p>You're expecting the template parameter <code>Comp</code> to be deduced from the default argument you provided for the corresponding function parameter. However, this is explicitly listed as a non-deduced context, meaning template argument deduction will fail for that template parameter (unless it can be deduced from elsewhere).</p>\n<p>From <em>\u00a714.8.2.5/5 [temp.deduct.type]</em></p>\n<blockquote>\n<p id=\"so_24277974_24278483_0\">The non-deduced contexts are:<br/>\n  \u2014 ... <br/> \n  \u2014 A template parameter used in the parameter type of a\n  function parameter that has a default argument that is being used in\n  the call for which argument deduction is being done.</p>\n</blockquote>\n<p>To have template argument deduction succeed, provide a default argument for the template parameter, instead of the function parameter.</p>\n<pre><code>template &lt;typename It, \n          typename Pred, \n          typename Comp = std::less&lt;decltype(*std::declval&lt;It&gt;())&gt;&gt;\nIt minElementWhere(\n    It begin,\n    It end,\n    Pred pred = Pred(),\n    Comp comp = Comp()\n) {\n...\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ffa9d6178cf10ddb\" rel=\"noreferrer\">Live demo</a></p>\n", "LastActivityDate": "2014-06-18T06:30:08.357", "CommentCount": "0", "CreationDate": "2014-06-18T06:30:08.357", "ParentId": "24277974", "Score": "8", "OwnerUserId": "241631"}, "24277974": {"ViewCount": "5835", "Body": "<p>I'm trying to make a function which finds the minimum element in a range which satisfies a given condition:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename It, typename Pred, typename Comp&gt;\nIt minElementWhere(\n    It begin,\n    It end,\n    Pred pred = Pred(),\n\n    // Use less-than as the default comparator.\n    Comp comp = std::less&lt;decltype(*std::declval&lt;It&gt;())&gt;()\n) {\n    It minElement = end;\n\n    for (It it = begin; it != end; ++it) {\n        if (!pred(*it)) {\n            continue;\n        }\n\n        if (comp(*it, *minElement)) {\n            minElement = it;\n        }\n    }\n\n    return minElement;\n}\n\nint main() {\n    std::vector&lt;double&gt; foo;\n    foo.push_back(6);\n    foo.push_back(10);\n    foo.push_back(-3);\n    foo.push_back(7);\n\n    std::cout &lt;&lt; *minElementWhere(\n        foo.begin(),\n        foo.end(),\n        [](double val) {\n            return val &gt;= 0;\n        }\n    ) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>But I get this error:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:40:5: error: no matching function for call to 'minElementWhere(std::vector&lt;double&gt;::iterator, std::vector&lt;double&gt;::iterator, main()::__lambda0)'\n     ) &lt;&lt; std::endl;\n     ^\nmain.cpp:40:5: note: candidate is:\nmain.cpp:6:4: note: template&lt;class It, class Pred, class Comp&gt; It minElementWhere(It, It, Pred, Comp)\n It minElementWhere(\n    ^\nmain.cpp:6:4: note:   template argument deduction/substitution failed:\nmain.cpp:40:5: note:   couldn't deduce template parameter 'Comp'\n     ) &lt;&lt; std::endl;\n</code></pre>\n<p><code>Comp</code> isn't the return type, so it's not trying to deduce the return type, and it doesn't seem to me like there are ambiguous overloads of <code>Comp</code> (since there can only be one return type of dereferencing an <code>It</code>). Why am I getting this error, and how can I fix it?</p>\n", "AcceptedAnswerId": "24278483", "Title": "Couldn't deduce template parameter from function parameter's default argument", "CreationDate": "2014-06-18T05:53:16.273", "Id": "24277974", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-24T01:36:28.407", "LastEditorUserId": "241631", "LastActivityDate": "2014-06-24T01:36:28.407", "Score": "5", "OwnerUserId": "344643", "Tags": "<c++><templates><c++11>", "AnswerCount": "3"}, "24278343": {"Id": "24278343", "PostTypeId": "2", "Body": "<p>You may want the following:</p>\n<pre><code>#include &lt;iterator&gt;\nstruct always_true{\n    template&lt;typename T&gt;\n    bool operator()(T&amp;&amp; val) const{\n        return true;\n    }\n};\n\ntemplate &lt;\n    typename It, \n    typename Pred = always_true,\n    typename Comp = std::less&lt;typename std::iterator_traits&lt;It&gt;::value_type &gt;\n&gt;\nIt minElementWhere(\n    It begin,\n    It end,\n    Pred pred = Pred(),\n    Comp comp = Comp()\n    ){\n    It minElement = end;\n\n    for (It it = begin; it != end; ++it) {\n        if (pred(*it) &amp;&amp; (minElement == end || comp(*it, *minElement))){\n            minElement = it;\n        }\n    }\n\n    return minElement;\n}\n</code></pre>\n", "LastActivityDate": "2014-06-18T06:21:33.390", "CommentCount": "0", "CreationDate": "2014-06-18T06:21:33.390", "ParentId": "24277974", "Score": "2", "OwnerUserId": "1535111"}});