post_cb({"33020532": {"ViewCount": "173", "Body": "<p>Consider following program:</p>\n<pre><code>struct Test\n{\n    virtual void foo()=NULL;\n};\nint main()\n{ }\n</code></pre>\n<p>g++ 4.8.1 gives an expected error as following:</p>\n<pre><code>[Error] invalid pure specifier (only '= 0' is allowed) before ';' token\n</code></pre>\n<p>Clang gives following error:</p>\n<pre><code>error: initializer on function does not look like a pure-specifier\n</code></pre>\n<p>But when I tried it on MSVS 2010 it compiles &amp; runs fine. I think g++ &amp;  clang is right in this case. What the standard says about this? I've disabled compiler extensions also using \\Za command line option but MSVS still accepts that code. Why it isn't giving any error?</p>\n<p>I also tried it on Online VC++ Compiler <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow\">here</a> that has been last updated on July 8, 2015. Is this really bug in MSVS 2010 &amp; 2015?</p>\n", "AcceptedAnswerId": "33020664", "Title": "why MSVS allows NULL as pure virtual function specifier?", "CreationDate": "2015-10-08T15:53:29.730", "Id": "33020532", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-10-08T19:48:42.693", "Score": "4", "OwnerUserId": "3777958", "Tags": "<c++><visual-studio-2010><syntax><pure-virtual><function-declaration>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_33020532_33020942_0": {"length": 7, "quality": 0.7, "section_id": 2515}, "so_33020532_33020942_2": {"length": 7, "quality": 0.875, "section_id": 39}, "so_33020532_33020942_1": {"length": 4, "quality": 0.8, "section_id": 6705}}, "n3337": {"so_33020532_33020942_0": {"length": 7, "quality": 0.7, "section_id": 6460}, "so_33020532_33020942_2": {"length": 5, "quality": 0.625, "section_id": 36}, "so_33020532_33020942_1": {"length": 4, "quality": 0.8, "section_id": 6460}}, "n4659": {"so_33020532_33020942_0": {"length": 6, "quality": 0.6, "section_id": 3249}, "so_33020532_33020942_2": {"length": 7, "quality": 0.875, "section_id": 39}, "so_33020532_33020942_1": {"length": 4, "quality": 0.8, "section_id": 8180}}}, "33020760": {"Id": "33020760", "PostTypeId": "2", "Body": "<p><code>NULL</code> is specified to be an implementation-defined C++ null pointer constant, which is an integral constant expression evaluating to zero or a prvalue of type <code>std::nullptr_t</code>. As such, <code>0</code>, <code>0L</code> or <code>nullptr</code> are all valid implementations of <code>NULL</code>. </p>\n<p>Your versions of Clang and GCC probably define it as <code>0L</code> or <code>nullptr</code>, whereas your MSVC version defines it as <code>0</code>. In that case, the preprocessor will replace <code>NULL</code> with <code>0</code>, making your program well-formed.</p>\n", "LastActivityDate": "2015-10-08T16:03:59.043", "CommentCount": "0", "CreationDate": "2015-10-08T16:03:59.043", "ParentId": "33020532", "Score": "2", "OwnerUserId": "496161"}, "33020664": {"Id": "33020664", "PostTypeId": "2", "Body": "<p>According to <a href=\"https://msdn.microsoft.com/en-us/library/vstudio/43t8xk57(v=vs.100).aspx\" rel=\"nofollow\">MSDN</a>, <code>NULL</code> is defined as something that is close enough to <code>0</code> for MSVC++ to swallow. That's it.</p>\n<p>Try doing <code>#undef NULL</code> before that code, and it should properly break compilation.</p>\n", "LastActivityDate": "2015-10-08T15:59:10.970", "CommentCount": "6", "CreationDate": "2015-10-08T15:59:10.970", "ParentId": "33020532", "Score": "2", "OwnerUserId": "752976"}, "33020942": {"Id": "33020942", "PostTypeId": "2", "Body": "<p>The grammar in section <code>9.2</code> <em>Class members</em> says the following:</p>\n<pre><code>[...]\nmember-declarator:\n declarator virt-specifier-seqopt pure-specifieropt\n[...]\npure-specifier:\n  = 0\n  ^^^\n</code></pre>\n<p>So the pure-specifier has to be a literal <code>0</code>. Most likely <code>NULL</code> is defined as <code>0</code> for MSVC but it does not have to be defined as <code>0</code>, another possibility is <code>0L</code> which is not allowed by the grammar and this is possibly what gcc and clang use.</p>\n<p>We can see this from section <code>18.2</code>:</p>\n<blockquote>\n<p id=\"so_33020532_33020942_0\">The macro NULL is an implementation-defined C++ null pointer constant in this International Standard 194</p>\n</blockquote>\n<p>the footnote says:</p>\n<blockquote>\n<p id=\"so_33020532_33020942_1\">Possible definitions include 0 and 0L, but not (void*)0.</p>\n</blockquote>\n<p>and section <code>4.10</code> says:</p>\n<blockquote>\n<p id=\"so_33020532_33020942_2\">A null pointer constant is an integer literal (2.14.2) with value zero</p>\n</blockquote>\n<p>which rules out <code>(void*)0</code>.</p>\n<p>Earlier versions of clang and MSVC <a href=\"https://stackoverflow.com/a/20861416/1708801\">accepted other integer literals</a> but it looks like clang fixed this in the latest revision.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-08T19:48:42.693", "Score": "1", "CreationDate": "2015-10-08T16:12:52.770", "ParentId": "33020532", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:06:37.503"}});