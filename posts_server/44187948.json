post_cb({"44188225": {"ParentId": "44187948", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The code is valid at least according to the C++ 2017 Standard (and the C++ 2014 Standard for which a bug report was written.). It seems that the used compiler just does not support this feature. If so then copy the string literal to the allocated memory</p>\n<pre><code>#include &lt;cstring&gt;\n\n//...\n// m_data = new char[14]{\"Hello, World!\"};   \nm_data = new char[14];\nstd::strcpy( m_data, \"Hello, World!\" );   \n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2017-05-26T14:20:10.537", "Id": "44188225", "Score": "2", "CreationDate": "2017-05-25T19:16:52.823", "LastActivityDate": "2017-05-26T14:20:10.537"}, "44190304": {"ParentId": "44187948", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The original code is supposed to work. Section C++14 [expr.new]/7.4 even explicitly mentions this exact case, to say that it's an error if the string literal is too long for the array:</p>\n<blockquote>\n<p id=\"so_44187948_44190304_0\">The expression in a <em>noptr-new-declarator</em> is erroneous if: [...]</p>\n<ul>\n<li>the <em>new-initializer</em> is a <em>braced-init-list</em> and the number of array elements for which initializers are provided <strong>(including the terminating <code>'\\0'</code> in a string literal)</strong> exceeds the number of elements\n  to initialize.</li>\n</ul>\n</blockquote>\n<hr>\n<p>In the latest standard draft, the definition of list-initialization in [dcl.init.list]/3 says:</p>\n<blockquote>\n<p id=\"so_44187948_44190304_1\">Otherwise, if <code>T</code> is a character array and the initializer list has a single element that is an appropriately-typed string literal, initialization is performed as described in that section.</p>\n</blockquote>\n<p>(and the previous point before \"Otherwise\" was not triggered for this case).</p>\n<p>Other comments mention some confusion about initialization rules. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467\" rel=\"nofollow noreferrer\">DR 1490</a> - the C++11 text could be read as saying <code>char s[4]{\"abc\"};</code> is ill-formed because it attempts to take the string literal as initializer for <code>s[0]</code>.   However, the intent was that this code work -- any wording suggesting otherwise would be defective wording.</p>\n<p>This was accepted as a defect, but the resolution process (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1467\" rel=\"nofollow noreferrer\">DR 1467</a>) did not complete until after the publication of C++14.  </p>\n<p>Defect resolutions are considered to retroactively replace the text they resolved; so code conforming to C++14 should use the rule as I quoted above, which is clear and unambiguous.  Common sense would also use the same rule for C++11 conformance.</p>\n</hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2017-05-25T22:07:39.953", "Id": "44190304", "Score": "2", "CreationDate": "2017-05-25T21:45:14.860", "LastActivityDate": "2017-05-25T22:07:39.953"}, "44187948": {"CommentCount": "13", "AcceptedAnswerId": "44188225", "LastEditDate": "2017-08-01T14:28:08.757", "LastEditorUserId": "8054407", "CreationDate": "2017-05-25T18:59:49.277", "LastActivityDate": "2017-08-01T14:28:08.757", "PostTypeId": "1", "ViewCount": "137", "Title": "Char array initialization within a class", "Id": "44187948", "OwnerUserId": "8054407", "Body": "<p>I am following a turorial and one of the answers contains the following snippet:</p>\n<pre><code>    private:\n      char *m_data;\n\n     public:\n      HelloWorld() {\n        m_data = new char[14]{\"Hello, World!\"};   // should work in c++14\n                                          // ^ the error points here\n\n}\n</code></pre>\n<p>which according to the author should work in c++14, yet when I try to compile I receive the following error: </p>\n<pre><code>\"invalid conversion from 'const char*' to 'char'\n</code></pre>\n<p>Where is the problem and how to fix it?</p>\n", "Tags": "<c++><gcc><c++14>", "Score": "1", "AnswerCount": "4"}, "44188146": {"ParentId": "44187948", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The problem is that your tutorial is pointing you in a wrong direction; as indicated in some comments, the fix is to use <a href=\"http://en.cppreference.com/w/cpp/string/basic_string\" rel=\"nofollow noreferrer\"><code>std::string</code></a>:</p>\n<pre><code>private:\n  std::string m_data;\n\n public:\n  HelloWorld() {\n    m_data = \"Hello, World!\";\n  }  \n</code></pre>\n<p>Using <code>std::string</code> instead of <code>char*</code> and avoiding <code>new</code> are both strongly preferred in C++; you should avoid writing \"C-style\" C++, C is a <em>different</em> language.</p>\n<p>Using <code>std::string</code> also frees you from having to write a destructor (which you haven't shown) to <code>delete[] m_data</code>.  It also makes the default implementations of copy/assignment work, which is not the case with <code>char*</code>.  There are a lot of good reasons to use <code>std::string</code>.</p>\n", "OwnerUserId": "8877", "LastEditorUserId": "8877", "LastEditDate": "2017-05-25T20:35:39.133", "Id": "44188146", "Score": "-3", "CreationDate": "2017-05-25T19:11:42.270", "LastActivityDate": "2017-05-25T20:35:39.133"}, "44188239": {"ParentId": "44187948", "CommentCount": "4", "Body": "<p>The tutorial is mistaken. You need to type in a literal character array initializer like this:</p>\n<pre><code>m_data = new char[14]{'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\0'};\n</code></pre>\n<p>Remember that you have to <em>manually</em> add the <em>null terminator</em> <code>'\\0'</code> at the end!</p>\n", "OwnerUserId": "3807729", "PostTypeId": "2", "Id": "44188239", "Score": "1", "CreationDate": "2017-05-25T19:18:14.387", "LastActivityDate": "2017-05-25T19:18:14.387"}, "bq_ids": {"n4659": {"so_44187948_44190304_1": {"section_id": 4091, "quality": 1.0, "length": 14}}}});