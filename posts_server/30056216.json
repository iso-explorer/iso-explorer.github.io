post_cb({"30056216": {"CreationDate": "2015-05-05T14:46:28.270", "ViewCount": "329", "PostTypeId": "1", "AcceptedAnswerId": "30056521", "Score": "5", "Title": "copy list initialization vs direct list initialization of temporary", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>Given the following struct:</p>\n<pre><code>struct ABC\n{\n    ABC(){cout &lt;&lt; \"ABC\" &lt;&lt; endl;}\n    ~ABC() noexcept {cout &lt;&lt; \"~ABC\" &lt;&lt; endl;}\n    ABC(ABC const&amp;) {cout &lt;&lt; \"copy\" &lt;&lt; endl;}\n    ABC(ABC&amp;&amp;) noexcept {cout &lt;&lt; \"move\" &lt;&lt; endl;}\n    ABC&amp; operator=(ABC const&amp;){cout &lt;&lt; \"copy=\" &lt;&lt; endl;}\n    ABC&amp; operator=(ABC&amp;&amp;) noexcept {cout &lt;&lt; \"move=\" &lt;&lt; endl;}\n};\n</code></pre>\n<p>The output of:</p>\n<pre><code>std::pair&lt;std::string, ABC&gt; myPair{{}, {}};\n</code></pre>\n<p>is:</p>\n<pre><code>ABC\ncopy\n~ABC\n~ABC\n</code></pre>\n<p>While the output of:</p>\n<pre><code>std::pair&lt;std::string, ABC&gt; myPair{{}, ABC{}};\n</code></pre>\n<p>is:</p>\n<pre><code>ABC\nmove\n~ABC\n~ABC\n</code></pre>\n<p>In attempting to understand the difference between the two I think I have identified that the first case is using copy-list-initialization, while the second one uses direct-list-initialization of an unnamed temporary (numbers 7 and 2, respectively, in here: <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/list_initialization</a>).</p>\n<p>Searching for similar questions I've found this: <a href=\"https://stackoverflow.com/questions/13461027/why-does-the-standard-differentiate-between-direct-list-initialization-and-copy\">Why does the standard differentiate between direct-list-initialization and copy-list-initialization?</a> and this: <a href=\"https://stackoverflow.com/questions/26964221/does-copy-list-initialization-invoke-copy-ctor-conceptually\">Does copy list initialization invoke copy ctor conceptually?</a>.</p>\n<p>The answers in those questions discuss the fact that for copy-list-initialization, the use of an explicit constructor would render the code ill-formed. In fact, if I make ABC's default constructor explicit, my first example won't compile but that is (perhaps) a different matter.</p>\n<p>So, the question is: Why is the temporary copied in the first case but moved in the second? What prevents it from being moved in the case of copy-list-initialization?</p>\n<p>As a note, the following code:</p>\n<pre><code>std::pair&lt;std::string, ABC&gt; myPair = std::make_pair&lt;string, ABC&gt;({}, {});\n</code></pre>\n<p>Also results in a call to ABC's move constructor (and no copy constructor call), but different mechanisms may be involved.</p>\n<p>You can try the code out (using gcc-4.9.2 in C++14 mode) at: <a href=\"https://ideone.com/Kc8xIn\" rel=\"nofollow noreferrer\">https://ideone.com/Kc8xIn</a></p>\n", "Tags": "<c++11><move><temporary-objects><list-initialization>", "Id": "30056216", "LastEditDate": "2017-05-23T12:06:32.680", "LastActivityDate": "2015-05-05T19:37:23.093", "FavoriteCount": "1", "AnswerCount": "1", "OwnerUserId": "4605289"}, "bq_ids": {"n4140": {"so_30056216_30056521_3": {"length": 4, "quality": 1.0, "section_id": 3961}}}, "30056521": {"CommentCount": "6", "Body": "<p>In general, <em>braced-init-lists</em> like <code>{}</code> are not expressions and do not have a type. If you have a function template</p>\n<pre><code>template&lt;typename T&gt; void f(T);\n</code></pre>\n<p>and call <code>f( {} )</code>, no type will be deduced for <code>T</code>, and type deduction will fail.</p>\n<p>On the other hand, <code>ABC{}</code> is a prvalue expression of type <code>ABC</code> (an \"explicit type conversion in functional notation\"). For a call like <code>f( ABC{} )</code>, the function template can deduce the type <code>ABC</code> from this expression.</p>\n<hr>\n<p>In C++14, as well as in C++11, <code>std::pair</code> has the following constructors [pairs.pair]; <code>T1</code> and <code>T2</code> are the names of the template parameter of the <code>std::pair</code> class template:</p>\n<blockquote id=\"so_30056216_30056521_0\">\n<pre><code>pair(const pair&amp;) = default;\npair(pair&amp;&amp;) = default;\nconstexpr pair();\nconstexpr pair(const T1&amp; x, const T2&amp; y);\ntemplate&lt;class U, class V&gt; constexpr pair(U&amp;&amp; x, V&amp;&amp; y);\ntemplate&lt;class U, class V&gt; constexpr pair(const pair&lt;U, V&gt;&amp; p);\ntemplate&lt;class U, class V&gt; constexpr pair(pair&lt;U, V&gt;&amp;&amp; p);\ntemplate &lt;class... Args1, class... Args2&gt;\npair(piecewise_construct_t, tuple&lt;Args1...&gt;, tuple&lt;Args2...&gt;);\n</code></pre>\n</blockquote>\n<p>Note that there is a constructor</p>\n<blockquote id=\"so_30056216_30056521_1\">\n<pre><code>constexpr pair(const T1&amp; x, const T2&amp; y); // (C)\n</code></pre>\n</blockquote>\n<p>But no</p>\n<blockquote id=\"so_30056216_30056521_2\">\n<pre><code>constexpr pair(T1&amp;&amp; x, T2&amp;&amp; y);\n</code></pre>\n</blockquote>\n<p>instead, there is a perfectly forwarding</p>\n<blockquote id=\"so_30056216_30056521_3\">\n<pre><code>template&lt;class U, class V&gt; constexpr pair(U&amp;&amp; x, V&amp;&amp; y); // (P)\n</code></pre>\n</blockquote>\n<p>If you try to initialize a <code>std::pair</code> with two initializers where at least one of them is a <em>braced-init-list</em>, the constructor (P) is not viable since it cannot deduce its template arguments.</p>\n<p>(C) is not a constructor template. Its parameter types <code>T1 const&amp;</code> and <code>T2 const&amp;</code> are fixed by the class template parameters. A reference to a constant type can be initialized from an empty <em>braced-init-list</em>. This creates a temporary object that is bound to the reference. As the type referred to is const, the (C) constructor will copy its arguments into the class' data members.</p>\n<hr>\n<p>When you initialize a pair via <code>std::pair&lt;T,U&gt;{ T{}, U{} }</code>, the <code>T{}</code> and <code>U{}</code> are prvalue-expressions. The constructor template (P) can deduce their types and is viable. The instantiation produced after type deduction is a better match than the (C) constructor, because (P) will produce rvalue-reference parameters and bind the prvalue arguments to them. (C) on the other hand binds the prvalue arguments to lvalue-references.</p>\n<hr>\n<p>Why then does the live example move the second argument when called via <code>std::pair&lt;T,U&gt;{ {}, U{} }</code>?</p>\n<p>libstdc++ defines additional constructors. Below is an extract of its <code>std::pair</code> implementation from 78536ab78e, omitting function definitions, some comments, and SFINAE. <code>_T1</code> and <code>_T2</code> are the names of the template parameters of the <code>std::pair</code> class template.</p>\n<pre><code>  _GLIBCXX_CONSTEXPR pair();\n\n  _GLIBCXX_CONSTEXPR pair(const _T1&amp; __a, const _T2&amp; __b); // (C)\n\n  template&lt;class _U1, class _U2&gt;\nconstexpr pair(const pair&lt;_U1, _U2&gt;&amp; __p);\n\n  constexpr pair(const pair&amp;) = default;\n  constexpr pair(pair&amp;&amp;) = default;\n\n  // DR 811.\n  template&lt;class _U1&gt;\nconstexpr pair(_U1&amp;&amp; __x, const _T2&amp; __y); // (X)\n\n  template&lt;class _U2&gt;\nconstexpr pair(const _T1&amp; __x, _U2&amp;&amp; __y); // (E) &lt;=====================\n\n  template&lt;class _U1, class _U2&gt;\nconstexpr pair(_U1&amp;&amp; __x, _U2&amp;&amp; __y);      // (P)\n\n  template&lt;class _U1, class _U2&gt;\nconstexpr pair(pair&lt;_U1, _U2&gt;&amp;&amp; __p);\n\n  template&lt;typename... _Args1, typename... _Args2&gt;\n    pair(piecewise_construct_t, tuple&lt;_Args1...&gt;, tuple&lt;_Args2...&gt;);\n</code></pre>\n<p>Note the (E) constructor template: It will copy the first argument and perfectly forward the second. For an initialization like <code>std::pair&lt;T,U&gt;{ {}, U{} }</code>, it is viable because it only needs to deduce a type from the second argument. It is also a better match than (C) for the second argument, and hence a better match overall.</p>\n<p>The \"DR 811\" comment is in the libstdc++ sources. It refers to <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-defects.html#811\" rel=\"nofollow\">LWG DR 811</a> which adds some SFINAE, but no new constructors.</p>\n<p>The constructors (E) and (X) are a libstdc++ extension. I'm not sure if it's compliant, though.</p>\n<p>libc++ on the other hand does not have this additional constructors. For the example <code>std::pair&lt;T,U&gt;{ {}, U{} }</code>, it will <a href=\"http://coliru.stacked-crooked.com/a/c6f0777bf7cc2f36\" rel=\"nofollow\">copy the second argument</a>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8d4a6a920bbf1845\" rel=\"nofollow\">Live demo with both library implementations</a></p>\n</hr></hr></hr>", "LastEditorUserId": "420683", "PostTypeId": "2", "LastEditDate": "2015-05-05T19:37:23.093", "ParentId": "30056216", "Id": "30056521", "LastActivityDate": "2015-05-05T19:37:23.093", "Score": "8", "CreationDate": "2015-05-05T14:58:25.740", "OwnerUserId": "420683"}});