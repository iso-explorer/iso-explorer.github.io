post_cb({"13299742": {"ViewCount": "182", "Body": "<p>Here is an example code:</p>\n<pre><code>enum Foo // or enum class whatever\n{   BAR\n,   STUFF\n};\n\ninline const char* to_string( const Foo&amp; foo )\n{\n    static const char* const NAMES[] = \n    {    \"BAR\"\n    ,    \"STUFF\"\n    };\n    // let's assume I have some boundary checks here, it's not the point\n    return NAMES[foo];\n};\n</code></pre>\n<p>This function is inline, is in a header used in several compilation units.\nThe goal here is to make the compiler do nothing if there is no use of this function.</p>\n<p>Questions:</p>\n<ol>\n<li>Does the C++ standard guarantee that NAMES will exists in only one object file, or is it left to the compiler to decide or does it guarantee that every object file will have it's copy?</li>\n<li>If there will be multiple copies, will it be a linking problem (I'm assuming I can't test enough compilers to check that).</li>\n<li>Will gcc, msvc and clang all optimize out this case by making the final binary have only one instance of NAMES?</li>\n</ol>\n", "AcceptedAnswerId": "13299913", "Title": "Are inline function static constants unique?", "CreationDate": "2012-11-08T23:31:10.920", "Id": "13299742", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-11-08T23:37:26.300", "LastEditorUserId": "560648", "LastActivityDate": "2012-11-08T23:50:26.403", "Score": "10", "OwnerUserId": "2368", "Tags": "<c++>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13299742_13299913_0": {"length": 20, "quality": 1.0, "section_id": 5404}}, "n3337": {"so_13299742_13299913_0": {"length": 20, "quality": 1.0, "section_id": 5199}}, "n4659": {"so_13299742_13299913_0": {"length": 13, "quality": 0.65, "section_id": 6853}}}, "13299859": {"Id": "13299859", "PostTypeId": "2", "Body": "<p>The standard guarantees that only one copy will be <em>used</em>. It doesn't guarantee that there won't be unused copies taking up space in the code.</p>\n<p>The linker is generally responsible for consolidating all the references to use the same instance.</p>\n", "LastActivityDate": "2012-11-08T23:41:12.827", "CommentCount": "0", "CreationDate": "2012-11-08T23:41:12.827", "ParentId": "13299742", "Score": "1", "OwnerUserId": "5987"}, "13299913": {"Id": "13299913", "PostTypeId": "2", "Body": "<p>Yes, the standard guarantees that there will be only one object.  From C++03 \u00a77.1.2/4:</p>\n<blockquote>\n<p id=\"so_13299742_13299913_0\">[...] A <code>static</code>\n  local variable in an <code>extern inline</code> function always refers to the same object. A string literal in an\n  extern inline function is the same object in different translation units.</p>\n</blockquote>\n<p>(Note that an <code>extern inline</code> function is an <code>inline</code> function with external linkage, i.e. an <code>inline</code> function not marked as <code>static</code>.)</p>\n<p>Exactly which object file it appears in will depend on the compiler, but what I suspect happens is that each object file that uses it will get a copy, and the linker will arbitrarily choose one of the symbols and discard the rest.</p>\n", "LastActivityDate": "2012-11-08T23:46:41.363", "CommentCount": "3", "CreationDate": "2012-11-08T23:46:41.363", "ParentId": "13299742", "Score": "7", "OwnerUserId": "9530"}});