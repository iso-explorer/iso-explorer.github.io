post_cb({"43545452": {"Id": "43545452", "PostTypeId": "2", "Body": "<p>The only types that have guarantees about size are standard layout types. Being polymorphic (amongst others) specifically precludes this.</p>\n<p>However, you can do what you want (I am assuming you want to allocate sufficient space to create any kind of a set of WrapperOf's):</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;tuple&gt;\n\nstruct Dummy { void* get(); };\nstruct Real { int* get(); };\nstruct UnReal { float* get(); };\n\ntemplate &lt;typename T&gt;\nstruct Wrapper {\n    Wrapper(void* c) : c_(c) {}\n    virtual T* get() const = 0;\n    void* get_c() { return c_; }\n    void* get_c() const { return c_; }\nprotected:\n    void *c_;\n};\n\n\ntemplate &lt;typename C, typename T&gt;\nstruct WrapperOf: Wrapper&lt;T&gt; {\n\n    WrapperOf(C *c = 0) : Wrapper&lt;T&gt;(c) { }\n\n    virtual T* get() const {\n        C *c = static_cast&lt;C*&gt;(this-&gt;get_c());\n        return static_cast&lt;T*&gt;(c-&gt;get());\n    }\n};\n\ntemplate &lt;&gt;\nstruct WrapperOf&lt;void, void&gt;: Wrapper&lt;void&gt; {\n    virtual void* get() const { return 0; }\n};\n\ntemplate&lt;class Type, class...Rest&gt;\nstruct largest_of\n{\n    static constexpr auto x = sizeof(Type);\n    static constexpr auto y = largest_of&lt;Rest...&gt;::size;\n    static constexpr std::size_t size = x &gt; y ? x : y;\n\n    static constexpr auto q = alignof(Type);\n    static constexpr auto p = largest_of&lt;Rest...&gt;::alignment;\n    static constexpr std::size_t alignment = q &gt; p ? q : p;\n};\n\ntemplate&lt;class T&gt; struct largest_of&lt;T&gt;\n{\n    static constexpr std::size_t size = sizeof(T); \n    static constexpr std::size_t alignment = alignof(T);\n};\n\ntemplate&lt;class...Ts&gt; struct largest_of&lt;std::tuple&lt;Ts...&gt;&gt; {\n    static constexpr std::size_t size = largest_of&lt;Ts...&gt;::size; \n    static constexpr std::size_t alignment =largest_of&lt;Ts...&gt;::alignment;\n};\n\nusing candidates = std::tuple&lt;\n    WrapperOf&lt;Real, int&gt;,\n    WrapperOf&lt;UnReal, float&gt;,\n    WrapperOf&lt;Dummy, void&gt;,\n    WrapperOf&lt;void, void&gt;\n&gt;;\n\nusing largest = largest_of&lt;candidates&gt;;\nstd::aligned_storage&lt;largest::size, largest::alignment&gt; storage;\n\nint main()\n{\n    auto p1 = new (std::addressof(storage)) WrapperOf&lt;Real,int&gt;();\n    p1-&gt;~WrapperOf&lt;Real,int&gt;();\n\n    auto p2 = new (std::addressof(storage)) WrapperOf&lt;UnReal, float&gt;();\n    p2-&gt;~WrapperOf&lt;UnReal,float&gt;();\n}\n</code></pre>\n", "LastActivityDate": "2017-04-21T14:37:33.333", "CommentCount": "0", "CreationDate": "2017-04-21T14:37:33.333", "ParentId": "43544550", "Score": "0", "OwnerUserId": "2015579"}, "43544550": {"ViewCount": "58", "Body": "<p>Let's say I have the following structure:</p>\n<pre><code>template &lt;typename T&gt;\nstruct Wrapper {\n    virtual T* get() const = 0;\nprotected:\n    void *c_;\n};\n\ntemplate &lt;typename C, typename T&gt;\nstruct WrapperOf: Wrapper&lt;T&gt; {\n\n    WrapperOf(C *c = 0) : c_(c) { }\n\n    virtual T* get() const {\n        C *c = static_cast&lt;C*&gt;(c_);\n        return static_cast&lt;T*&gt;(c-&gt;get());\n    }\n};\n</code></pre>\n<p>Is it guaranteed by the standard that the size of any <code>WrapperOf</code> will be the same? Typically, could I do the following:</p>\n<pre><code>struct Dummy { void* get(); };\nstruct Real { int* get(); };\n\nchar storage[sizeof(WrapperOf&lt;Dummy, void&gt;)];\nWrapper&lt;int&gt; *wp = \n    new(storage) WrapperOf&lt;Real, int&gt;();\n</code></pre>\n<p>And if I specialize <code>WrapperOf</code>, typically:</p>\n<pre><code>template &lt;&gt;\nstruct WrapperOf&lt;void, void&gt;: Wrapper&lt;void&gt; {\n    virtual void* get() const { return 0; }\n};\n</code></pre>\n<p>To use it to initialize the storage (to avoid having a <code>Dummy</code> class):</p>\n<pre><code>char storage[sizeof(WrapperOf&lt;void, void&gt;)];\n</code></pre>\n<p>Would this still be valid?</p>\n", "Title": "Size of templated polymorphic derived classes without new members", "CreationDate": "2017-04-21T13:53:06.470", "LastActivityDate": "2017-04-21T14:47:13.593", "CommentCount": "6", "PostTypeId": "1", "Id": "43544550", "Score": "1", "OwnerUserId": "2666289", "Tags": "<c++><templates><polymorphism><sizeof><placement-new>", "AnswerCount": "3"}, "43545065": {"Id": "43545065", "PostTypeId": "2", "Body": "<p>No, it is not guaranteed in standard anywhere, since standard doesn't really make any guarantees about object sizes, except for some narrow cases.</p>\n<p>It also worth noting that Standard doesn't say anything about virtual functions implementations (things like vptr do not exist in standard). </p>\n", "LastActivityDate": "2017-04-21T14:19:20.523", "CommentCount": "0", "CreationDate": "2017-04-21T14:19:20.523", "ParentId": "43544550", "Score": "0", "OwnerUserId": "5245033"}, "bq_ids": {"n4140": {"so_43544550_43545676_1": {"length": 9, "quality": 0.9, "section_id": 6076}, "so_43544550_43545676_2": {"length": 15, "quality": 1.0, "section_id": 6077}, "so_43544550_43545676_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 6076}}, "n3337": {"so_43544550_43545676_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 5844}, "so_43544550_43545676_2": {"length": 15, "quality": 1.0, "section_id": 5845}, "so_43544550_43545676_1": {"length": 9, "quality": 0.9, "section_id": 5844}}, "n4659": {"so_43544550_43545676_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 7572}, "so_43544550_43545676_2": {"length": 15, "quality": 1.0, "section_id": 7573}, "so_43544550_43545676_1": {"length": 9, "quality": 0.9, "section_id": 7572}}}, "43545676": {"Id": "43545676", "PostTypeId": "2", "Body": "<p>From the current working draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4640.pdf\" rel=\"nofollow noreferrer\">N4640</a> (2017-02-06)</p>\n<blockquote>\n<p id=\"so_43544550_43545676_0\"><strong>5.3.3 Sizeof [expr.sizeof]</strong></p>\n<ol>\n<li><p id=\"so_43544550_43545676_1\">The sizeof operator yields the number of bytes in the object representation of its operand.</p></li>\n<li><p id=\"so_43544550_43545676_2\">... When applied\n  to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array.</p></li>\n</ol>\n</blockquote>\n<p>So there's no guaranty about anything, just that it takes so much bytes as it takes.</p>\n<p>Even for most fundamental types, the standard says it is <em>implementation-defined</em></p>\n<blockquote id=\"so_43544550_43545676_3\">\n<ol>\n<li>... sizeof(char), sizeof(signed char) and sizeof(unsigned char) are 1. The result of sizeof applied to any other fundamental type (3.9.1) is implementation-defined.</li>\n</ol>\n</blockquote>\n<p>One can infer that it takes N bytes for some class and empirically see that it is the same for a range of derived classes in a given implementation. There is just no guaranty.</p>\n", "LastActivityDate": "2017-04-21T14:47:13.593", "CommentCount": "0", "CreationDate": "2017-04-21T14:47:13.593", "ParentId": "43544550", "Score": "0", "OwnerUserId": "1741542"}});