post_cb({"bq_ids": {"n4140": {"so_27584999_27585055_0": {"length": 11, "quality": 1.0, "section_id": 3286}, "so_27584999_27585071_0": {"length": 11, "quality": 1.0, "section_id": 3286}}, "n3337": {"so_27584999_27585055_0": {"length": 11, "quality": 1.0, "section_id": 3156}, "so_27584999_27585071_0": {"length": 11, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_27584999_27585055_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 382}, "so_27584999_27585071_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 382}}}, "27584999": {"ViewCount": "138", "Body": "<p>Consider the code:</p>\n<pre><code>struct Foo\n{\n    int x = 10;\n};\n\nint main()\n{\n    const Foo foo;\n}\n</code></pre>\n<p>It compiles under g++ <a href=\"http://coliru.stacked-crooked.com/a/99bd8006e10b47ef\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/99bd8006e10b47ef</a>, however spits an error under clang++ <a href=\"http://coliru.stacked-crooked.com/a/93f94f7d9625b579\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/93f94f7d9625b579</a> : </p>\n<pre><code>error: default initialization of an object of const type\n      'const Foo' requires a user-provided default constructor\n</code></pre>\n<p>I am not sure who's right here. Why do we need a default ctor since we perform in-class initialization?</p>\n", "AcceptedAnswerId": "27585055", "Title": "discrepancy between clang and g++ in dealing with const objects", "CreationDate": "2014-12-20T22:39:42.347", "Id": "27584999", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-20T22:46:55.530", "LastEditorUserId": "234175", "LastActivityDate": "2014-12-20T22:56:54.037", "ClosedDate": "2014-12-20T23:15:34.183", "Score": "6", "OwnerUserId": "3093378", "Tags": "<c++><c++11><const>", "AnswerCount": "2"}, "27585071": {"Id": "27585071", "PostTypeId": "2", "Body": "<p><a href=\"http://clang.llvm.org\" rel=\"nofollow\">clang</a> seems to be right according to 8.5 [dcl.init] paragraph 7 last sentence:</p>\n<blockquote>\n<p id=\"so_27584999_27585071_0\">If a program calls for the default initialization of an object of a <code>const</code>-qualified type <code>T</code>, <code>T</code> shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>Clearly, the type doesn't have a user-provided default constructor.</p>\n", "LastActivityDate": "2014-12-20T22:49:58.497", "CommentCount": "0", "CreationDate": "2014-12-20T22:49:58.497", "ParentId": "27584999", "Score": "3", "OwnerUserId": "1120273"}, "27585055": {"Id": "27585055", "PostTypeId": "2", "Body": "<p>An object of class type may only be default-initialized if it has a user-provided default constructor. From [dcl.init]/7:</p>\n<blockquote>\n<p id=\"so_27584999_27585055_0\">If a program calls for the default initialization of an object of a const-qualified type <code>T</code>, <code>T</code> shall be a class type with a user-provided default constructor.</p>\n</blockquote>\n<p>Your class <code>Foo</code> doesn't have that; the presence of a <em>brace-or-equals-initializer</em> does not create a user-provided default constructor. Rather, your class has an <em>implicitly defined</em> default constructor, whose action incorporates the initialization as requested by the <em>brace-or-equals-initializer</em>. (Clang is right.)</p>\n<p>([dcl.fct.def.default], in particular paragraph 5, relates the definitions of \"user-provided\", \"explicitly defaulted\", \"implicitly declared\" and \"defined as deleted\". The entire section is worth knowing.)</p>\n<p>By the way, it's easy to avoid default-initialization in C++11:</p>\n<pre><code>const Foo foo {};  // hunky-dory\n</code></pre>\n", "LastEditorUserId": "596781", "LastActivityDate": "2014-12-20T22:56:54.037", "Score": "7", "CreationDate": "2014-12-20T22:48:15.213", "ParentId": "27584999", "CommentCount": "7", "OwnerUserId": "596781", "LastEditDate": "2014-12-20T22:56:54.037"}});