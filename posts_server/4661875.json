post_cb({"4661939": {"Id": "4661939", "PostTypeId": "2", "Body": "<p>I don't believe that it can be done- lambdas aren't really anything new semantically, they're just compiler-generated functors and thus will look identical to regular functors.</p>\n", "LastActivityDate": "2011-01-11T19:54:05.553", "CommentCount": "0", "CreationDate": "2011-01-11T19:54:05.553", "ParentId": "4661875", "Score": "6", "OwnerUserId": "298661"}, "bq_ids": {"n4140": {"so_4661875_4661946_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5961}}, "n3337": {"so_4661875_4661946_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5730}}, "n4659": {"so_4661875_4661946_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 7448}}}, "22724275": {"Id": "22724275", "PostTypeId": "2", "Body": "<p>It's possible to define some macro code that determines if an expression is a lambda <em>expression</em> (but that's not very useful as it doesn't tell you if an expression is of a lambda <em>type</em>).</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T, typename U&gt;\nstruct SameType {\n    static_assert(!std::is_same&lt;T, U&gt;::value, \"Must use Lambda\");\n    static T pass(T t) { return t; }\n};\n\ntemplate &lt;typename T, typename U&gt;\nT NotLambda(T t, U u) { return SameType&lt;T, U&gt;::pass(t); }\n\n#define ASSERT_LAMBDA(x) NotLambda(x,x)\n\n/////////////////////////////////////\n\nint fn() { return 0; }\n\nint main() {\n    auto l = []{ return 0; };\n    return ASSERT_LAMBDA(fn)() +             // &lt;&lt; fails\n           ASSERT_LAMBDA(l)() +              // &lt;&lt; fails\n           ASSERT_LAMBDA([]{ return 0; })(); // &lt;&lt; passes\n}\n</code></pre>\n<p>This depends on section 5.1.2.3 which specifies that each lambda expression has a distinct type (which I think is a property unique to lambdas).</p>\n", "LastEditorUserId": "1343", "LastActivityDate": "2014-03-29T03:50:41.373", "Score": "1", "CreationDate": "2014-03-28T22:31:11.013", "ParentId": "4661875", "CommentCount": "1", "OwnerUserId": "1343", "LastEditDate": "2014-03-29T03:50:41.373"}, "4661875": {"ViewCount": "1416", "Body": "<p>I have a question regarding C++0x lambdas. In my code, it would be beneficial to know whether or not a given type is the type of a C++0x lambda expression. To give an example:</p>\n<pre><code>struct foobar\n{\n  void operator()()\n  {\n  }\n};\n\nauto lambda = []{};\ntypedef is_lambda &lt; decltype(lambda) &gt; ::type T; // T would be a true_type\ntypedef is_lambda &lt; foobar &gt; ::type T; // T would be a false_type\n</code></pre>\n<p>It is rather easy to distinguish lambda expressions from function and member function types. Functors are another matter.</p>\n<p>The problem I see here is the definition of lambda expressions according to the upcoming C++0x standard; the only thing that must be defined is a public call operator. However, this is true for a functor as well; testing for the presence of the call operator is not enough for distinguishing lambda expressions from functors. Furthermore, if the operator of a functor is <em>not</em> present, a compiler error will occur, since SFINAE does not apply. When does this happen? The functor's call operator may be templated.\nSo, such a code:</p>\n<pre><code>typedef decltype(&amp;T::operator()) call_type;\n</code></pre>\n<p>will work for both lambda expressions and functors with non-templated call operator, and generate a compiler error for templated call operators.</p>\n<p>I believe an <code>is_lambda &lt; &gt;</code> trait can only be created using intrinsic compiler features. Do you see a way how to implement this trait?</p>\n", "AcceptedAnswerId": "4661946", "Title": "Is a C++ is_lambda trait, purely implemented as a library, impossible?", "CreationDate": "2011-01-11T19:45:42.480", "Id": "4661875", "CommentCount": "3", "LastEditDate": "2011-01-12T09:27:22.517", "PostTypeId": "1", "LastEditorUserId": "3848", "LastActivityDate": "2014-03-29T03:50:41.373", "Score": "9", "OwnerUserId": "560774", "Tags": "<c++><lambda><c++11><traits>", "AnswerCount": "3"}, "4661946": {"Id": "4661946", "PostTypeId": "2", "Body": "<p>Since evaluation of lambda results in creating closure object, there isn't any difference as soon as the object passed to a function or copied. And, frankly, I can't imagine a problem that would require to know whether an object came from lambda.</p>\n<p>Edit. A standard even has a note in 5.1.2/2: </p>\n<blockquote>\n<p id=\"so_4661875_4661946_0\">Note: a closure object behaves like a function object (20.8).\u2014end note</p>\n</blockquote>\n", "LastEditorUserId": "3848", "LastActivityDate": "2011-01-12T09:32:33.680", "Score": "8", "CreationDate": "2011-01-11T19:55:08.493", "ParentId": "4661875", "CommentCount": "1", "OwnerUserId": "491591", "LastEditDate": "2011-01-12T09:32:33.680"}});