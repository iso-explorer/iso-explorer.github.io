post_cb({"32949403": {"CommentCount": "4", "ViewCount": "114", "PostTypeId": "1", "LastEditorUserId": "246342", "CreationDate": "2015-10-05T13:04:27.623", "LastActivityDate": "2015-10-05T14:28:35.107", "Title": "Array initialization", "AcceptedAnswerId": "32949464", "LastEditDate": "2015-10-05T13:06:07.760", "Id": "32949403", "Score": "1", "Body": "<p>I have two types of array initialisation that will be used in string constructor</p>\n<pre><code>int main() {\n    //char foo [] = { 'a', 'd' }; \n    char foo[] = \"ad\";\n\n    std::string s = foo;\n\n    cout&lt;&lt;s;\n\n    int i;\n    cin &gt;&gt; i;\n}\n</code></pre>\n<p>Why in <code>char foo [] = { 'a', 'd' };</code>  case i have output:</p>\n<pre><code>ad\u2560\u2560\u2560\u2560\u2560\u2560R8$1\u2191\u25a0\u256c\n</code></pre>\n<p>And when array is initialized like <code>char foo [] = \"ad\";</code> I have normal output -<code>ad</code>- that was expected in first case.</p>\n<p>What is difference in these two array initialization and why I have garbage in output in first one?</p>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "1501700", "AnswerCount": "4"}, "32949535": {"ParentId": "32949403", "PostTypeId": "2", "CommentCount": "3", "Body": "<pre><code>char foo[] = \"ad\";\n</code></pre>\n<p>Actually creates a <code>char</code> array of</p>\n<pre><code>char foo[] = { 'a', 'd', '\\0' };\n</code></pre>\n<p>The <code>'\\0'</code> is important as it is used to signal the end of a char array.  When you create the string <code>s</code> the contents of <code>foo</code> are read until the <code>'\\0'</code> is reached.  When you output <code>s</code> you get <code>ad</code> .  When you do </p>\n<pre><code>char foo [] = { 'a', 'd' };\n</code></pre>\n<p>there is no <code>'\\0'</code> so when you create the string <code>s</code> the constructor will keep going until it reaches a <code>'\\0'</code>.  This is undefined behavior as we are using memory we have not allocated.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2015-10-05T13:19:24.450", "Id": "32949535", "Score": "1", "CreationDate": "2015-10-05T13:10:54.620", "LastActivityDate": "2015-10-05T13:19:24.450"}, "32949527": {"ParentId": "32949403", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>When you write </p>\n<pre><code>std::string = foo; // copy ctor --  for std::string will be called\n</code></pre>\n<p>Which expects a null terminated ( C style) string. But in case of following you don't have a null character to terminate the C style string.</p>\n<pre><code>char foo [] = { 'a', 'd' }; // Incorrect\nchar foo[] =  { 'a', 'd' ,'\\0'}; //Correct\n</code></pre>\n<p>It is fine in case of following as compiler will generate a null terminate C string for you.</p>\n<pre><code>char foo[] = \"ad\";\n</code></pre>\n<p>Also one thing to note that \"ad\" is a string literal, and { 'a', 'd' ,'\\0'} is an array initializer. Following is notable here</p>\n<pre><code>char[] foo = \"ad\";\nfoo[1] = 'M'; // Undefined behavior \n\nchar[] foo = { 'a', 'd' ,'\\0'};\nfoo[1] = 'M'; // Is OK \n</code></pre>\n", "OwnerUserId": "4373992", "LastEditorUserId": "4373992", "LastEditDate": "2015-10-05T14:28:35.107", "Id": "32949527", "Score": "0", "CreationDate": "2015-10-05T13:10:31.517", "LastActivityDate": "2015-10-05T14:28:35.107"}, "32949469": {"ParentId": "32949403", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In the case of <code>char foo [] = { 'a', 'd' };</code> you're declaring an array of characters which has two elements, i.e. not a null terminated string.  So when you try to print it as a string, the <code>&lt;&lt;</code> operator keeps reading whatever characters happen to follow until if finds a null byte.  This is undefined behavior.</p>\n<p>In the case of <code>char foo [] = \"ad\";</code> you're initializing a character array with a string constant.  This constant has 3 characters, namely \"a\", \"d\", and a null byte, so the array is 3 characters long.  So when you print this, it prints properly.</p>\n", "OwnerUserId": "1687119", "LastEditorUserId": "1687119", "LastEditDate": "2015-10-05T13:12:38.210", "Id": "32949469", "Score": "1", "CreationDate": "2015-10-05T13:07:32.533", "LastActivityDate": "2015-10-05T13:12:38.210"}, "bq_ids": {"n4140": {"so_32949403_32949464_2": {"section_id": 5363, "quality": 1.0, "length": 16}, "so_32949403_32949464_1": {"section_id": 5356, "quality": 1.0, "length": 26}}, "n3337": {"so_32949403_32949464_2": {"section_id": 5159, "quality": 1.0, "length": 16}, "so_32949403_32949464_1": {"section_id": 5153, "quality": 1.0, "length": 26}}, "n4659": {"so_32949403_32949464_2": {"section_id": 6787, "quality": 1.0, "length": 16}, "so_32949403_32949464_1": {"section_id": 6781, "quality": 1.0, "length": 26}}}, "32949464": {"ParentId": "32949403", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You need the string to be null terminated</p>\n<pre><code>char foo [] = { 'a', 'd', '\\0' };\n</code></pre>\n<p>String literals are already null terminated.</p>\n<blockquote>\n<p id=\"so_32949403_32949464_0\"><strong>\u00a7 2.14.5 String Literals</strong> </p>\n<p id=\"so_32949403_32949464_1\">8 Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. <strong>A narrow string literal has type \u201carray of n <code>const char</code>\u201d</strong>, where n is the size of the string as defined below, and has static storage duration    </p>\n<p id=\"so_32949403_32949464_2\">14 After any necessary concatenation, in translation phase 7, <strong><code>'\\0'</code> is appended to every string literal so that programs that scan a string can find its end</strong>.</p>\n</blockquote>\n", "OwnerUserId": "2296458", "LastEditorUserId": "2296458", "LastEditDate": "2015-10-05T13:22:02.420", "Id": "32949464", "Score": "3", "CreationDate": "2015-10-05T13:07:22.703", "LastActivityDate": "2015-10-05T13:22:02.420"}});