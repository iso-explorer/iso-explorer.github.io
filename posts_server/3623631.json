post_cb({"3623644": {"ParentId": "3623631", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Don't add to the standard namespace. \nReason : If everybody did this, the standard namespace would have heaps of name clashes, which defeats the purpose of a namespace.</p>\n<p>Your objective is for your class to be \"ostream-able\". It does not need to be in the standard namespace to do that. As long as it is in whatever namepsace your class is declared in, you're fine. Putting it in the standard namespace would be bad practice. </p>\n", "OwnerUserId": "13760", "LastEditorUserId": "13760", "LastEditDate": "2010-09-02T05:44:03.140", "Id": "3623644", "Score": "6", "CreationDate": "2010-09-02T03:30:38.630", "LastActivityDate": "2010-09-02T05:44:03.140"}, "3623631": {"CommentCount": "0", "ViewCount": "1872", "PostTypeId": "1", "LastEditorUserId": "151292", "CreationDate": "2010-09-02T03:26:16.537", "LastActivityDate": "2010-10-08T14:25:18.987", "Title": "Where should non-member operator overloads be placed?", "AcceptedAnswerId": "3623643", "LastEditDate": "2010-10-08T14:25:18.987", "Id": "3623631", "Score": "13", "Body": "<p>I want to overload <code>operator&lt;&lt;</code> for my class. Should I add this overloaded definition to the <code>std</code> namespace? (since the <code>ostream operator&lt;&lt;</code> is part of the <code>std</code> namespace) Or should I just leave it in the global namespace?</p>\n<p>In short:</p>\n<pre><code>class MyClass {\n\n};\n\nnamespace std {\n    ostream&amp; operator&lt;&lt; ( ostream&amp; Ostr, const MyClass&amp; MyType ) {}\n}\n</code></pre>\n<p><strong>OR</strong></p>\n<pre><code>class MyClass {\n\n};\n\nstd::ostream&amp; operator&lt;&lt; ( std::ostream&amp; Ostr, const MyClass&amp; MyType ) {}\n</code></pre>\n<p>Which is more appropriate and why? Thanks in advance for your responses.</p>\n", "Tags": "<c++><namespaces><operator-overloading>", "OwnerUserId": "241631", "AnswerCount": "3"}, "3623643": {"ParentId": "3623631", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You should put the operator overload in the same namespace as your class.  </p>\n<p>This will allow the operator to be found during overload resolution using argument-dependent lookup (well, actually, since <code>ostream</code> is in namespace <code>std</code>, the overload overload would also be found if you put it in namespace <code>std</code>, but there is no reason to do that).</p>\n<p>From the point of view of good design practices, the operator overload is more a part of your class's interface than the interface of <code>ostream</code>, so it belongs in the same namespace as your class (see also Herb Sutter's <a href=\"http://www.gotw.ca/publications/mill08.htm\" rel=\"noreferrer\"><em>Namespaces and the Interface Principle</em></a>).</p>\n<p>From the point of view of writing standards-compliant and portable code, you can't put the operator overload into namespace <code>std</code>.  While you can add template specializations for user-defined entities to namespace <code>std</code>, you can't add additional function overloads.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2010-09-02T03:39:46.120", "Id": "3623643", "Score": "25", "CreationDate": "2010-09-02T03:30:04.733", "LastActivityDate": "2010-09-02T03:39:46.120"}, "bq_ids": {"n4140": {"so_3623631_3623647_1": {"section_id": 6299, "quality": 0.6097560975609756, "length": 25}}, "n3337": {"so_3623631_3623647_1": {"section_id": 6056, "quality": 0.6097560975609756, "length": 25}}, "n4659": {"so_3623631_3623647_1": {"section_id": 7808, "quality": 0.6097560975609756, "length": 25}}}, "3623647": {"ParentId": "3623631", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Don't add it to the <code>std</code> namespace, place it in the same namespace as your class. The purpose of a namespace is to prevent collisions. The standard says</p>\n<blockquote>\n<p id=\"so_3623631_3623647_0\"><strong>17.4.3.1 Reserved names</strong></p>\n<p id=\"so_3623631_3623647_1\">It is undefined for a C++ program to\n  add declarations or definitions to\n  namespace std or namespaces within\n  namespace std unless otherwise\n  specified. A program may add template\n  specializations for any standard\n  library template to namespace std.\n  Such a specialization (complete or\n  partial) of a standard library\n  template results in undefined behavior\n  unless the declaration depends on a\n  user-defined name of external linkage\n  and unless the specialization meets\n  the standard library requirements for\n  the original template.</p>\n</blockquote>\n", "OwnerUserId": "283302", "LastEditorUserId": "283302", "LastEditDate": "2010-09-02T03:40:23.857", "Id": "3623647", "Score": "6", "CreationDate": "2010-09-02T03:31:23.403", "LastActivityDate": "2010-09-02T03:40:23.857"}});