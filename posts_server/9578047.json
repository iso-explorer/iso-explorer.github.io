post_cb({"9578101": {"ParentId": "9578047", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In my compiler, with and without optimizations, the extra copy constructor was optimized away.</p>\n<pre><code>[10:53pm][wlynch@orange /tmp] c++ --version\nApple clang version 3.1 (tags/Apple/clang-318.0.45) (based on LLVM 3.1svn)\nTarget: x86_64-apple-darwin11.3.0\nThread model: posix\n[10:54pm][wlynch@orange /tmp] c++ -O0 -std=gnu++11 foo.cc -o foo\n[10:54pm][wlynch@orange /tmp] ./foo\nUsing std::make_pair()\n    Copy constructor called\n    Copy constructor called\nUsing MAKE_PAIR()\n    Copy constructor called\n    Copy constructor called\nUsing a typedef\n    Copy constructor called\n    Copy constructor called\n</code></pre>\n<p>If I add the parameter <code>-fno-elide-constructors</code>, then we see the extra constructors.</p>\n<pre><code>[10:57pm][wlynch@orange /tmp] c++ -std=gnu++11 -fno-elide-constructors foo.cc -o foo\n[10:57pm][wlynch@orange /tmp] ./foo\nUsing std::make_pair()\n    Copy constructor called\n    Copy constructor called\n    Copy constructor called\n    Copy constructor called\nUsing MAKE_PAIR()\n    Copy constructor called\n    Copy constructor called\nUsing a typedef\n    Copy constructor called\n    Copy constructor called\n</code></pre>\n<p>The C++ Spec has this to say on skipping copy constructors in [class.copy.15] of the 2003 Spec:</p>\n<blockquote>\n<p id=\"so_9578047_9578101_0\">When certain criteria are met, an implementation is allowed to omit the copy construction of a class object, even if the copy constructor and/or destructor for the object have side effects. In such cases, the implemen- tation treats the source and target of the omitted copy operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.) This elision of copy operations is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object with the same cv-unqualified type as the function return type, the copy operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied to a class object with the same cv-unqualified type, the copy operation can be omitted by constructing the temporary object directly into the target of the omitted copy</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "47453", "LastEditorUserId": "47453", "LastEditDate": "2012-03-06T05:01:21.850", "Id": "9578101", "Score": "3", "CreationDate": "2012-03-06T04:53:48.177", "LastActivityDate": "2012-03-06T05:01:21.850"}, "9578047": {"CommentCount": "4", "ViewCount": "643", "CreationDate": "2012-03-06T04:46:44.067", "LastActivityDate": "2012-03-06T05:01:21.850", "Title": "Are templated wrapper functions for classes (e.g. std::make_pair())` considered slow?", "AcceptedAnswerId": "9578101", "PostTypeId": "1", "Id": "9578047", "Score": "2", "Body": "<p>I'm using <code>std::make_pair()</code> for this example because pretty much any C++ programmer ought to be familiar with it, but more generally I'm wondering about the pattern it uses.</p>\n<p>It occurred to me that, although I enjoy the convenience of <code>std::make_pair()</code> it makes an \"extra\" copy of each argument, since it creates a pair and returns it by value.  If I then use that to insert into an STL container that means that actually each parameter is copied a total of 3 times... I wrote this code snippet to illustrate (along with some attempts to improve it without losing too much convenience):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;list&gt;\n\nusing namespace std;\n// C++11 only:\n#define MAKE_PAIR(a,b) pair&lt;decltype(a),decltype(b)&gt;((a),(b))\n\nclass A {\npublic:\n  A () { }\n  A (const A&amp; a) {\n    cout &lt;&lt; \"\\tCopy constructor called\" &lt;&lt; endl;\n  }\n};\n\nint main()\n{\n  list&lt;pair&lt;int,A&gt; &gt; l;\n\n  cout &lt;&lt; \"Using std::make_pair()\" &lt;&lt; endl;\n  l.push_back(make_pair(10,A()));\n\n  cout &lt;&lt; \"Using MAKE_PAIR()\" &lt;&lt; endl;\n  l.push_back(MAKE_PAIR(10,A()));\n\n  typedef pair&lt;int, A&gt; my_pair;\n  cout &lt;&lt; \"Using a typedef\" &lt;&lt; endl;\n  l.push_back(my_pair(10,A()));\n}\n</code></pre>\n<p>which produces the output:</p>\n<pre><code>Using std::make_pair()\n    Copy constructor called\n    Copy constructor called\n    Copy constructor called\nUsing MAKE_PAIR()\n    Copy constructor called\n    Copy constructor called\nUsing a typedef\n    Copy constructor called\n    Copy constructor called\n</code></pre>\n<p>I realize there are a couple other copies here that can probably be eliminated (or rather reduced to pointer/smart pointer copies), for example by using A * or a smart pointer in the pair instead, and allocating it myself.</p>\n<p>The macro idea (which requires C++11) seemed interesting to me, although I know many are not fond of macros.  The typedef works fine too, but then you have to create a separate typedef for each set of template args, and so it's more convenient than specifying the template args explicitly each time, it's still not quite as nice as the wrapper function.</p>\n<p>I'm wondering does anybody actually avoid <code>make_pair()</code> in practice for this reason? Does C++/C++11 offer any other interesting solutions?</p>\n<p>I like this idea of creating a templated function wrapper around a constructor so that we can deduce the template arguments, but I'm not as crazy about causing a runtime impact because of it.</p>\n", "Tags": "<c++><performance><templates><copy><c++11>", "OwnerUserId": "1172428", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9578047_9578101_0": {"section_id": 480, "quality": 0.8870967741935484, "length": 55}}, "n3337": {"so_9578047_9578101_0": {"section_id": 471, "quality": 0.8870967741935484, "length": 55}}, "n4659": {"so_9578047_9578101_0": {"section_id": 502, "quality": 0.8870967741935484, "length": 55}}}});