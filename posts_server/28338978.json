post_cb({"bq_ids": {"n4140": {"so_28338978_28351087_0": {"length": 12, "quality": 0.75, "section_id": 4503}}, "n3337": {"so_28338978_28351087_0": {"length": 12, "quality": 0.75, "section_id": 4334}}}, "28351087": {"PostTypeId": "2", "Body": "<p>[util.smartptr.enab]/7 describes the preconditions for <code>shared_from_this</code>:</p>\n<blockquote>\n<p id=\"so_28338978_28351087_0\"><em>Requires:</em> <code>enable_shared_from_this&lt;T&gt;</code> shall be an accessible base class of <code>T</code>. <code>*this</code> shall be a subobject of an object <code>t</code> of type <code>T</code>. <strong>There shall be at least one <code>shared_ptr</code> instance <code>p</code> that owns <code>&amp;t</code>.</strong> [emph. added]</p>\n</blockquote>\n<p>Since your object is being destroyed, it must be the case that there is no <code>shared_ptr</code> that owns it. Consequently, you cannot call <code>shared_from_this</code> without violating that requirement resulting in undefined behavior.</p>\n", "LastActivityDate": "2015-02-05T18:12:50.320", "Id": "28351087", "CommentCount": "4", "CreationDate": "2015-02-05T18:12:50.320", "ParentId": "28338978", "Score": "9", "OwnerUserId": "923854"}, "42237490": {"Id": "42237490", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28338978_42237490_0\">I don't see a reason why it would be technically impossible to get the pointer here, since the shared pointer object obviously still exists and can be used. </p>\n</blockquote>\n<p>There's a very good technical reason why it's not possible.</p>\n<p>The <code>shared_ptr</code> might exist, but the reference count for the <code>A</code> object has reached zero, that's why the destructor is being run. Once the reference count reaches zero it cannot be increased again (otherwise you could get a <code>shared_ptr</code> that refers to an object that is either in the middle of running its destructor, or has already been destroyed).</p>\n<p>Calling <code>shared_from_this()</code> tries to increase the reference count and return a <code>shared_ptr</code> that shares ownership with the current owner(s), but you can't increase the counter from zero to one, so it fails.</p>\n<p>In <em>this very specific case</em> (inside the object's destructor) you know the object hasn't been completely destroyed yet, but <code>enable_shared_from_this&lt;A&gt;</code> has no way to know who is calling the <code>shared_from_this()</code> function, so can't know if it's happening in <em>this very specific case</em> or in some other piece of code outside the object's destructor (e.g. in another thread that will keep going after the destructor). </p>\n<p>If you could somehow make it work for this specific case and you got a <code>shared_ptr&lt;A&gt;</code> that referred to the object currently being destroyed, you could give that <code>shared_ptr</code> to something outside the destructor that stored it for later use. That would allow that other piece of code to access a dangling <code>shared_ptr</code>, after the object has been destroyed. That would be a big hole in the <code>shared_ptr</code> and <code>weak_ptr</code> type system.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2017-02-15T09:49:43.023", "CommentCount": "1", "CreationDate": "2017-02-14T22:34:42.153", "ParentId": "28338978", "Score": "6", "OwnerUserId": "981959", "LastEditDate": "2017-02-15T09:49:43.023"}, "28338978": {"ViewCount": "1649", "Body": "<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nstruct A : public std::enable_shared_from_this&lt;A&gt;\n{\n    ~A()\n    {\n        auto this_ptr = shared_from_this(); // std::bad_weak_ptr exception here. \n        std::cout &lt;&lt; \"this: \" &lt;&lt; this_ptr;\n    }\n};\n\nint main()\n{\n    auto a = std::make_shared&lt;A&gt;();\n    a.reset();\n    return 0;\n}\n</code></pre>\n<p>I'm getting <code>std::bad_weak_ptr</code> exception when calling <code>shared_from_this()</code>. Is it by design? Yes, it might be dangerous as this pointer can't be used after the destructor returns, but I don't see a reason why it would be technically impossible to get the pointer here, since the shared pointer object obviously still exists and can be used. Is there any way to circumvent this, short of writing my own <code>enable_shared_from_this</code> analog (which I would rather not do)?</p>\n", "AcceptedAnswerId": "42237490", "Title": "std::enable_shared_from_this: is it allowed to call shared_from_this() in destructor?", "CreationDate": "2015-02-05T08:05:22.530", "Id": "28338978", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-02-15T13:07:02.333", "LastEditorUserId": "963864", "LastActivityDate": "2017-02-15T13:07:02.333", "Score": "6", "OwnerUserId": "634821", "Tags": "<c++><c++11><destructor><shared-ptr><weak-ptr>", "AnswerCount": "3"}, "28341490": {"PostTypeId": "2", "Body": "<p><code>shared_ptr::reset</code>'s implementation is often <code>shared_ptr().swap(*this)</code>. </p>\n<p>Which means the <code>shared_ptr</code> you are trying to copy is already in its destructor state which in turns decrement the shared count before calling your destructor. When you call <code>enable_shared_from_this</code> it will try to promote the <code>weak_ptr</code> stored within it by constructing a <code>shared_ptr</code> from that <code>weak_ptr</code> which results in an exception when the count is 0.</p>\n<p>So to answer your question, there is no standard way of doing what you want if your standard library implementation doesn't behave in a way that authorise it (i don't know is it is mandated by the standard or not).</p>\n<p>Now, here is a hack that works on my machine (clang/libc++):</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nclass   hack_tag\n{\n};\n\nnamespace std\n{\n\n  template&lt;&gt;\n  class shared_ptr&lt;hack_tag&gt;\n  {\n  public:\n    template&lt;typename T&gt;\n    weak_ptr&lt;T&gt;        extract_weak(const enable_shared_from_this&lt;T&gt;&amp; shared)\n    {\n      return shared.__weak_this_;\n    }\n  };\n\n};\n\nusing weak_ptr_extractor = std::shared_ptr&lt;hack_tag&gt;;\n\nclass   test : public std::enable_shared_from_this&lt;test&gt;\n{\npublic:\n  test()\n  {\n    std::cout &lt;&lt; \"ctor\" &lt;&lt; std::endl;\n  }\n\n  ~test()\n  {\n    std::cout &lt;&lt; \"dtor\" &lt;&lt; std::endl;\n    weak_ptr_extractor  hacker;\n    auto weak = hacker.extract_weak(*this);\n    std::cout &lt;&lt; weak.use_count() &lt;&lt; std::endl;\n    auto shared = weak.lock();\n  }\n};\n\n\nint     main(void)\n{\n  std::shared_ptr&lt;test&gt;  ptr = std::make_shared&lt;test&gt;();\n\n  ptr.reset();\n}\n</code></pre>\n<p>But i'm not sure you can do anything useful with that since your owning <code>shared_ptr</code> that you copied is about to die and that copy doesn't share things with the new clean <code>shared_ptr</code> you get after the <code>reset</code> call.</p>\n", "LastActivityDate": "2015-02-05T10:26:14.903", "Id": "28341490", "CommentCount": "0", "CreationDate": "2015-02-05T10:26:14.903", "ParentId": "28338978", "Score": "0", "OwnerUserId": "1147772"}});