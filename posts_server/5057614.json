post_cb({"8465952": {"ParentId": "5057614", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_5057614_8465952_0\">Essentially, what it comes down to is that the result of a pointer-to-pointer <code>reinterpret_cast</code> operation can't safely be used for anything other than being cast back to the original pointer type.</p>\n</blockquote>\n<p>You are right, the standard was broken, but N3242 tries to fix that:</p>\n<p>Definition of the value of <code>reinterpret_cast&lt;T*&gt;</code></p>\n<p>N3242, [expr.reinterpret.cast]:</p>\n<blockquote>\n<p id=\"so_5057614_8465952_1\">When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1.</p>\n</blockquote>\n<p>This still defines nothing; for fun, the less irrelevant text about <code>static_cast</code>:</p>\n<blockquote>\n<p id=\"so_5057614_8465952_2\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue of type \u201cpointer to cv2 T,\u201d where T is an object type and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. The null pointer value is converted to the null pointer value of the destination type. A value of type pointer to object converted to \u201cpointer to cv void\u201d and back, possibly with different cv-qualification, shall have its original value.</p>\n</blockquote>\n<p><em>\"Suitably converted\"</em></p>\n<p>N3242, [class.mem]:</p>\n<blockquote>\n<p id=\"so_5057614_8465952_3\">A pointer to a standard-layout struct object, <strong>suitably</strong> converted using a <code>reinterpret_cast</code>, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>What kind of style is that? \"<strong>suitably</strong>\"? lol</p>\n<p>Clearly, these guys don't know how to write a specification.</p>\n<blockquote>\n<p id=\"so_5057614_8465952_4\">C-style casts the only safe option here?</p>\n</blockquote>\n<p>It doesn't help.</p>\n<p>The standard is broken, broken, broken.</p>\n<p>But everybody understands what it really means. The subtext of the standard says:</p>\n<blockquote>\n<p id=\"so_5057614_8465952_5\">When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result <del>is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code></del>points to the memory address as v if both T1 and T2 are standard-layout types (3.9) and the alignment requirements of T2 are no stricter than those of T1.</p>\n</blockquote>\n<p>That's certainly not perfect (but not worse than many others parts of the standard), but in 2 mn I wrote a better spec than the committee did in a decade.</p>\n", "OwnerUserId": "963864", "LastEditorUserId": "384985", "LastEditDate": "2012-11-04T16:38:26.157", "Id": "8465952", "Score": "4", "CreationDate": "2011-12-11T17:26:34.807", "LastActivityDate": "2012-11-04T16:38:26.157"}, "5057614": {"CommentCount": "10", "AcceptedAnswerId": "5064073", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-02-20T14:32:18.907", "LastActivityDate": "2012-11-04T16:38:26.157", "LastEditDate": "2017-05-23T11:45:49.150", "ViewCount": "3285", "FavoriteCount": "4", "Title": "Is reinterpret_cast mostly useless?", "Id": "5057614", "Score": "16", "Body": "<p>I've read various previous questions about <a href=\"https://stackoverflow.com/questions/573294/when-to-use-reinterpret-cast\">the use of <code>reinterpret_cast</code></a>, and I've also read the relevant wording in the C++ standard.  Essentially, what it comes down to is that the result of a pointer-to-pointer <code>reinterpret_cast</code> operation can't safely be used for <em>anything</em> other than being cast back to the original pointer type.</p>\n<p>In practice, however, most real-world uses of <code>reinterpret_cast</code> seem to be based on the (wrong) assumption that a <code>reinterpret_cast</code> is the same as a C-style cast.  For example, I've seen lots of code which uses <code>reinterpret_cast</code> to cast from <code>char*</code> to <code>unsigned char*</code> for the purpose of character set conversion routines.  This is completely harmless, yet strictly speaking it's not portable - there's no guarantee that a <code>reinterpret_cast</code> from <code>char*</code> to <code>unsigned char*</code> won't crash your program when you try to dereference the <code>unsigned char*</code> pointer.</p>\n<p>It's seems the <em>only</em> other real use of <code>reinterpret_cast</code> that has any real guarantees, according to the standard, is converting from pointer to integer, and vice-versa.  </p>\n<p>And yet there are many cases where we'd <em>want</em> (and should be able to) safely convert between different pointer types.  For example: <code>uint16_t*</code> to the new C++0x <code>char16_t*</code>, or really any pointer to a basic data type that is the same size/alignment as the original type.  Yet <code>reinterpret_cast</code> provides no guarantees this should work.  </p>\n<p><strong>Question:</strong> How can we safely convert between pointers to basic data-types of the same size/alignment, such as <code>char*</code> --&gt; <code>unsigned char*</code>?  Since <code>reinterpret_cast</code> doesn't seem to guarantee this actually works, are C-style casts the only safe option here?</p>\n", "Tags": "<c++><pointers><casting><reinterpret-cast><type-punning>", "OwnerUserId": "469408", "AnswerCount": "5"}, "5057673": {"ParentId": "5057614", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_5057614_5057673_0\">the result of a pointer-to-pointer reinterpret_cast operation can't safely be used for anything other than being cast back to the original pointer type.</p>\n</blockquote>\n<p>That does not sound right. Assuming <code>sizeof(void *) &gt; sizeof(int *)</code>, <code>void *foo; reinterpret_cast&lt;void *&gt;(reinterpret_cast&lt;int *&gt;(foo))</code> could leave you with a truncated pointer value.</p>\n<p>Is it not that <code>reinterpret_cast</code> is\u00a0\u2014 in practice\u00a0\u2014 simply the equivalent to C's default cast?</p>\n", "OwnerUserId": "611775", "PostTypeId": "2", "Id": "5057673", "Score": "0", "CreationDate": "2011-02-20T14:41:31.257", "LastActivityDate": "2011-02-20T14:41:31.257"}, "5057677": {"ParentId": "5057614", "CommentCount": "0", "Body": "<p>The standard specifies what has to happen on <strong>all</strong> platforms, you don't have to do that. If you limit your portability requirements to platforms where your reinterpret_cast actually works, that's fine. </p>\n<p>On platforms that actually support a uint16_t, the cast is likely to work. On platforms where char16_t is 18, 24, 32, or 36 bits wide, it might not do the right thing. The question is, do you have to support such platforms? The language standard wants to.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "5057677", "Score": "2", "CreationDate": "2011-02-20T14:42:37.630", "LastActivityDate": "2011-02-20T14:42:37.630"}, "5057765": {"ParentId": "5057614", "CommentCount": "0", "Body": "<p>There are some guarantees elsewhere in the standard (see the section on type representation which, IIRC, mandates that corresponding unsigned and signed types share the representation for the common values, still IIRC, there is also some text guaranteeing that you can read anything as characters).  But note also that there are some places which lessen even the section you are reading (which states that things are implementation defined and unspecified): some forms of type punning are undefined behavior.</p>\n", "OwnerUserId": "136208", "PostTypeId": "2", "Id": "5057765", "Score": "3", "CreationDate": "2011-02-20T14:57:12.827", "LastActivityDate": "2011-02-20T14:57:12.827"}, "5064073": {"ParentId": "5057614", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_5057614_5064073_0\">there's no guarantee that a reinterpret_cast from char* to unsigned char* won't crash your program when you try to dereference the unsigned char* pointer.</p>\n</blockquote>\n<p>You can't do such a cast in any other way, so you have to have to trust what your compiler does with this completely reasonable cast.</p>\n<blockquote>\n<p id=\"so_5057614_5064073_1\">Since reinterpret_cast doesn't seem to guarantee this actually works, are C-style casts the only safe option here?</p>\n</blockquote>\n<p>The C-style cast will just map to <code>reinterpret_cast</code> so it will be exactly the same. At some point you have to trust your compiler. The Standard has a limit on which it simply says \"no. read your compiler's manual\". When it comes to cross-casting pointers, this is such a point. It allows you to read a <code>char</code> using an <code>unsigned char</code> lvalue. A compiler that cannot cast a <code>char*</code> to a usable <code>unsigned char*</code> to do such is just about unusable and doesn't exist for that reason.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5064073", "Score": "11", "CreationDate": "2011-02-21T09:09:32.020", "LastActivityDate": "2011-02-21T09:09:32.020"}, "bq_ids": {"n4140": {"so_5057614_8465952_2": {"section_id": 6039, "quality": 0.8913043478260869, "length": 41}, "so_5057614_8465952_1": {"section_id": 6046, "quality": 0.7368421052631579, "length": 14}, "so_5057614_8465952_5": {"section_id": 6046, "quality": 0.6190476190476191, "length": 13}}, "n3337": {"so_5057614_8465952_2": {"section_id": 5807, "quality": 0.8913043478260869, "length": 41}, "so_5057614_8465952_1": {"section_id": 5814, "quality": 0.8947368421052632, "length": 17}, "so_5057614_8465952_5": {"section_id": 5814, "quality": 0.7619047619047619, "length": 16}, "so_5057614_8465952_3": {"section_id": 5650, "quality": 1.0, "length": 19}}, "n4659": {"so_5057614_8465952_2": {"section_id": 7536, "quality": 0.5652173913043478, "length": 26}, "so_5057614_8465952_1": {"section_id": 7545, "quality": 0.6842105263157895, "length": 13}, "so_5057614_8465952_5": {"section_id": 7545, "quality": 0.6190476190476191, "length": 13}}}});