post_cb({"25864615": {"ParentId": "25864206", "CommentCount": "1", "Body": "<p>What you've done is perfectly legal C++. So, if it works for you and is maintainable and understandable by anybody else who works with the code, it's fine. Joachim Pileborg's sample is clearer to me though. </p>\n<p>One problem with initializing global variables like this can occur if they use each other during initialization. In that case it can be tricky to ensure that variables are initialized in the correct order. For that reason, I prefer to create InitializeX, InitializeY, etc functions, and explicitly call them in the correct order from the Main function.</p>\n<p>Wrong ordering can also cause problems during program exit where globals still try to use each other when some of them may have been destroyed. Again, some explicit destruction calls in the correct order before Main returns can make it clearer.</p>\n<p>So, go for it if it works for you, but be aware of the pitfalls. The same advice applies to pretty much every feature in C++!</p>\n<p>You said in your question that you yourself think the code is 'tricky'. There is no need to overcomplicate things for the sake of it. So, if you have an alternative that appears less 'tricky' to you... that might be better.</p>\n", "OwnerUserId": "11898", "PostTypeId": "2", "Id": "25864615", "Score": "2", "CreationDate": "2014-09-16T09:01:27.550", "LastActivityDate": "2014-09-16T09:01:27.550"}, "bq_ids": {"n4140": {"so_25864206_25864379_0": {"section_id": 3281, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_25864206_25864379_0": {"section_id": 3152, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_25864206_25864379_0": {"section_id": 4043, "quality": 0.9583333333333334, "length": 23}}}, "25864473": {"ParentId": "25864206", "CommentCount": "2", "Body": "<p>You don't need a fake class... you can initialize using a lambda</p>\n<pre><code>auto myMap = []{\n    std::map&lt;int, string&gt; m;\n    m[\"test\"] = 222;\n    return m;\n}();\n</code></pre>\n<p>Or, if it's just plain data, initialize the map:</p>\n<pre><code>std::map&lt;std::string, int&gt; myMap { { \"test\", 222 } };\n</code></pre>\n", "OwnerUserId": "11898", "PostTypeId": "2", "Id": "25864473", "Score": "10", "CreationDate": "2014-09-16T08:54:07.727", "LastActivityDate": "2014-09-16T08:54:07.727"}, "25864314": {"ParentId": "25864206", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-16T08:45:20.343", "Score": "1", "LastEditorUserId": "2032021", "LastEditDate": "2014-09-16T08:50:34.887", "Id": "25864314", "OwnerUserId": "2032021", "Body": "<p>In C++, you cannot have statements outside any function. However, you have global objects declared, and constructor (initializer) call for these global objects are automatic before main starts. In your example, fakeVar is a global pointer that gets initialized through a function of class static scope, this is absolutely fine.<br>\nEven a global object would do provide that global object constructor does the desired initializaton.\nFor example,</br></p>\n<pre><code>class Fake\n{\npublic:\n    Fake()     {\n        myMap[\"test\"]=222;\n        // Do whatever with your global Variables\n    }\n};\nFake fake; \n</code></pre>\n", "LastActivityDate": "2014-09-16T08:50:34.887"}, "25864379": {"ParentId": "25864206", "CommentCount": "0", "Body": "<p>\u00a7 8.5.2 states</p>\n<blockquote>\n<p id=\"so_25864206_25864379_0\">Except for objects declared with the constexpr specifier, for which\n  see 7.1.5, an initializer in the definition of a variable can consist\n  of arbitrary expressions involving literals and previously declared\n  variables and <strong>functions</strong>, regardless of the variable\u2019s storage duration</p>\n</blockquote>\n<p>therefore what you're doing is perfectly allowed by the C++ standard. That said, if you need to perform \"initialization operations\" it might be better to just use a class constructor (e.g. a wrapper).</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "25864379", "Score": "4", "CreationDate": "2014-09-16T08:49:00.660", "LastActivityDate": "2014-09-16T08:49:00.660"}, "25864322": {"ParentId": "25864206", "CommentCount": "6", "Body": "<p>One way of solving it is to have a class with a constructor that does things, then declare a dummy variable of that class. Like</p>\n<pre><code>struct Initializer\n{\n    Initializer()\n    {\n        // Do pre-main initialization here\n    }\n};\n\nInitializer initializer;\n</code></pre>\n<p>You can of course have multiple such classes doing miscellaneous initialization. The order in each translation unit is specified to be top-down, but the order between translation units is not specified.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "25864322", "Score": "11", "CreationDate": "2014-09-16T08:45:33.173", "LastActivityDate": "2014-09-16T08:45:33.173"}, "41625884": {"ParentId": "25864206", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-01-13T01:12:25.703", "Score": "0", "LastEditorUserId": "3185819", "LastEditDate": "2017-07-06T19:14:58.460", "Id": "41625884", "OwnerUserId": "3185819", "Body": "<p>This is a case where unity builds (single translation unit builds) can be very powerful. The <code>__COUNTER__</code> macro is a de facto standard among C and C++ compilers, and with it you can write arbitrary imperative code at global scope:</p>\n<pre><code>// At the beginning of the file...\ntemplate &lt;uint64_t N&gt; void global_function() { global_function&lt;N - 1&gt;(); } // This default-case skips \"gaps\" in the specializations, in case __COUNTER__ is used for some other purpose.\ntemplate &lt;&gt; void global_function&lt;__COUNTER__&gt;() {} // This is the base case.\n\nvoid run_global_functions();\n\n#define global_n(N, ...) \\\ntemplate &lt;&gt; void global_function&lt;N&gt;() { \\\n    global_function&lt;N - 1&gt;(); /* Recurse and call the previous specialization */ \\\n    __VA_ARGS__; /* Run the user code. */ \\\n}\n#define global(...) global_n(__COUNTER__, __VA_ARGS__)\n\n// ...\n\nstd::map&lt;std::string, int&gt; myMap;\n\nglobal({\n    myMap[\"test\"]=222;\n    // Do whatever with your global variables\n})\nglobal(myMap[\"Error\"] = 111);\n\nint main() {\n    run_global_functions();\n    std::cout &lt;&lt; \"Map size: \" &lt;&lt; myMap.size() &lt;&lt; std::endl; // Show myMap has initialized correctly :)\n}\n\nglobal(std::cout &lt;&lt; \"This will be the last global code run before main!\");\n\n\n// ...At the end of the file\n\nvoid run_global_functions() {\n    global_function&lt;__COUNTER__ - 1&gt;();\n}\n</code></pre>\n<p>This is especially powerful once you realize that you can use it to initialize static variables without a dependency on the C runtime. This means you can generate very small executables without having to eschew non-zero global variables:</p>\n<pre><code>// At the beginning of the file...\nextern bool has_static_init;\n#define default_construct(x) x{}; global(if (!has_static_init()) new (&amp;x) decltype(x){})\n// Or if you don't want placement new:\n// #define default_construct(x) x{}; global(if (!has_static_init()) x = decltype(x){})\n\nclass Complicated {\n    int x = 42;\n    Complicated() { std::cout &lt;&lt; \"Constructor!\"; }\n}\nComplicated default_construct(my_complicated_instance); // Will be zero-initialized if the CRT is not linked into the program.\n\nint main() {\n    run_global_functions();\n}\n\n// ...At the end of the file\nstatic bool get_static_init() {\n    volatile bool result = true; // This function can't be inlined, so the CRT *must* run it.\n    return result;\n}\nhas_static_init = get_static_init(); // Will stay zero without CRT\n</code></pre>\n", "LastActivityDate": "2017-07-06T19:14:58.460"}, "25864422": {"ParentId": "25864206", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_25864206_25864422_0\">Is it a good idea...?</p>\n</blockquote>\n<p>Not really.  What if someone decides that in their \"tricky initialisation\" they want to use your map, but on some system or other, or for not obvious reason after a particular relink, your map ends up being initialised after their attempted use?  If you instead have them call a static function that returns a reference to the map, then it can initialise it on first call.  Make the map a static local variable inside that function and you stop any accidental use without this protection.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "25864422", "Score": "5", "CreationDate": "2014-09-16T08:51:25.293", "LastActivityDate": "2014-09-16T08:51:25.293"}, "25864206": {"CommentCount": "4", "AcceptedAnswerId": "25864322", "CreationDate": "2014-09-16T08:39:33.150", "LastActivityDate": "2017-07-06T19:14:58.460", "PostTypeId": "1", "ViewCount": "3920", "FavoriteCount": "3", "Title": "Running C++ code outside of functions scope", "Id": "25864206", "Score": "13", "Body": "<p><strong>(I know)</strong> In c++ I <strong>can</strong> <code>declare variable</code> out of scope and I <strong>can't</strong> run any code/statement, except for initializing global/static variables.</p>\n<hr>\n<p><strong>IDEA</strong></p>\n<p>Is it a good idea to use below <strong>tricky code</strong> in order to (for example) do some  <code>std::map</code> manipulation ?</p>\n<p>Here I use <code>void *fakeVar</code> and initialize it through <code>Fake::initializer()</code> and do whatever I want in it !</p>\n<pre><code>std::map&lt;std::string, int&gt; myMap;\n\nclass Fake\n{\npublic:\n    static void* initializer()\n    {\n        myMap[\"test\"]=222;\n        // Do whatever with your global Variables\n\n        return NULL;\n    }\n};\n\n// myMap[\"Error\"] = 111;                  =&gt; Error\n// Fake::initializer();                   =&gt; Error\nvoid *fakeVar = Fake::initializer();    //=&gt; OK\n\nvoid main()\n{\n    std::cout&lt;&lt;\"Map size: \" &lt;&lt; myMap.size() &lt;&lt; std::endl; // Show myMap has initialized correctly :)\n}\n</code></pre>\n</hr>", "Tags": "<c++><static><initialization><initializer>", "OwnerUserId": "550478", "AnswerCount": "9"}, "25878907": {"ParentId": "25864206", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-09-16T21:43:34.910", "Score": "2", "LastEditorUserId": "1339615", "LastEditDate": "2014-09-16T22:21:05.943", "Id": "25878907", "OwnerUserId": "1339615", "Body": "<p>When I hear \"tricky code\", I immediately think of code smells and maintenance nightmares. To answer your question, no, it isn't a good idea. While it is valid C++ code, it is bad practice. There are other, much more explicit and meaningful alternatives to this problem. To elaborate, the fact that your <em>initializer</em>() method returns void* NULL is meaningless as far as the intention of your program goes (i.e. each line of your code should have meaningful purpose), and you now have yet another unnecessary global variable <em>fakeVar</em>, which needlessly points to NULL.</p>\n<p>Let's consider some less \"tricky\" alternatives:</p>\n<ol>\n<li><p>If it's extremely important that you only ever have one global instance of <em>myMap</em>, perhaps using the <strong>Singleton Pattern</strong> would be more fitting, and you would be able to lazily initialize the contents of <em>myMap</em> when they are needed. Keep in mind that the Singleton Pattern has issues of its own.</p></li>\n<li><p>Have a <strong>static method create and return the map</strong> or use a global namespace. For example, something along the lines of this:</p>\n<pre><code>// global.h\nnamespace Global\n{\n    extern std::map&lt;std::string, int&gt; myMap;\n};\n\n// global.cpp\nnamespace Global\n{\n    std::map&lt;std::string, int&gt; initMap()\n    {\n        std::map&lt;std::string, int&gt; map;\n        map[\"test\"] = 222;\n        return map;\n    }\n\n    std::map&lt;std::string, int&gt; myMap = initMap();\n};\n\n// main.cpp\n#include \"global.h\"\n\nint main()\n{\n   std::cout &lt;&lt; Global::myMap.size() &lt;&lt; std::endl;\n   return 0;\n}\n</code></pre></li>\n<li><p>If this is a map with specialized functionality, <strong>create your own class</strong> (best option)! While this isn't a complete example, you get the idea:</p>\n<pre><code>class MyMap\n{\nprivate:\n    std::map&lt;std::string, int&gt; map;\n\npublic:\n\n    MyMap()\n    {\n        map[\"test\"] = 222;\n    }\n\n    void put(std::string key, int value)\n    {\n        map[key] = value;\n    }\n\n    unsigned int size() const\n    {\n        return map.size();\n    }\n\n    // Overload operator[] and create any other methods you need\n    // ...\n};\n\nMyMap myMap;\n\nint main()\n{\n   std::cout &lt;&lt; myMap.size() &lt;&lt; std::endl;\n   return 0;\n}\n</code></pre></li>\n</ol>\n", "LastActivityDate": "2014-09-16T22:21:05.943"}, "25864596": {"ParentId": "25864206", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25864206_25864596_0\">Is it a good idea to use below tricky code in order to (for example)\n  do some std::map manipulation ?</p>\n</blockquote>\n<p>No. </p>\n<p>Any solution entailing mutable non-local variables is a terrible idea.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "25864596", "Score": "6", "CreationDate": "2014-09-16T09:00:11.057", "LastActivityDate": "2014-09-16T09:00:11.057"}});