post_cb({"28995825": {"ParentId": "28995673", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>These two rules together (both in 14.6.2.1) yield the observed behavior:</p>\n<p>First, that</p>\n<blockquote>\n<p id=\"so_28995673_28995825_0\">A name refers to the current instantiation if it is</p>\n<ul>\n<li><p id=\"so_28995673_28995825_1\">in the de\ufb01nition of a class template, a nested class of a class template, a member of a class template, or a member of a nested class of a class template, the <em>injected-class-name</em> (Clause 9) of the class template or nested class,</p></li>\n<li><p id=\"so_28995673_28995825_2\">in  the  de\ufb01nition  of  a  primary  class  template  or  a  member  of  a  primary  class  template,  the  name  of  the class template followed by the template argument list of the primary template (as described below)\n  enclosed in <code>&lt;&gt;</code> (or an equivalent template alias specialization),</p></li>\n<li><p id=\"so_28995673_28995825_3\">in  the  de\ufb01nition  of  a  nested  class  of  a  class  template,  the  name  of  the  nested  class  referenced  as  a\n  member of the current instantiation, or</p></li>\n</ul>\n</blockquote>\n<p>and one more unrelated bullet point.</p>\n<p>Then,</p>\n<blockquote>\n<p id=\"so_28995673_28995825_4\">A name is a member of the current instantiation if it is</p>\n<ul>\n<li>An  unqualified  name  that,  when  looked  up,  refers  to  at  least  one  member  of  a  class  that  is  the  current instantiation or a non-dependent base class thereof.  [ Note:  <strong>This can only occur when looking up a name in a scope enclosed by the definition of a class template.</strong>  \u2014 end note ]</li>\n</ul>\n</blockquote>\n<p>and two unrelated bullet points.</p>\n<p>Therefore, in both cases, <code>ClassWithSubType&lt;T&gt;</code> refers to the current instantiation.  But as the note explains, <code>Sub</code> refers to a member of the current instantiation only when used inside the class template body.  In the out-of-class definition, it becomes a \"member of an unknown specialization\".</p>\n<p>As a member of the current instantiation, the compiler determines that <code>Sub</code> is a class type.</p>\n<p>Outside the class body, the compiler doesn't know this and the <code>typename</code> keyword is needed.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2015-03-11T19:43:56.440", "Id": "28995825", "Score": "2", "CreationDate": "2015-03-11T19:38:17.250", "LastActivityDate": "2015-03-11T19:43:56.440"}, "28995673": {"CommentCount": "3", "ViewCount": "52", "CreationDate": "2015-03-11T19:30:38.627", "LastActivityDate": "2015-03-11T19:43:56.440", "Title": "Why does the C++ compiler require a \"typename\" keyword in this particular case?", "AcceptedAnswerId": "28995825", "PostTypeId": "1", "Id": "28995673", "Score": "0", "Body": "<p>I just figured out that C++ requires a typename in the following code (see the member function definition at the end of the code fragment):</p>\n<pre><code>template &lt;typename T&gt; struct ClassWithSubtype\n{\n    struct Sub\n    {\n        //static void check( const ClassWithSubtype&lt;T&gt;::Sub&amp; sub );\n        ClassWithSubtype&lt;T&gt;::Sub&amp; operator=( const ClassWithSubtype&lt;T&gt;::Sub&amp; other );\n    };\n};\n\n/*\n//Here C++ does not require a typename for the argument type\ntemplate &lt;typename T&gt; void ClassWithSubtype&lt;T&gt;::Sub::check( const ClassWithSubtype&lt;T&gt;::Sub&amp; sub )\n{\n    //do sth.\n}\n*/\n\n//Here C++ requires a typename for the return type\ntemplate &lt;typename T&gt; typename ClassWithSubtype&lt;T&gt;::Sub&amp; ClassWithSubtype&lt;T&gt;::Sub::operator=( const ClassWithSubtype&lt;T&gt;::Sub&amp; other )\n{\n    //do sth.\n}\n</code></pre>\n<p>I can completely understand that C++ requires the keyword <code>typename</code> for the return type. What I do not understand is why NO <code>typename</code> is needed for the argument type of the example function <code>check</code> (which is commented out). Furthermore, why is a <code>typename</code> required in the definition of the assignment operator, but not in its declaration?</p>\n", "Tags": "<c++>", "OwnerUserId": "3910671", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28995673_28995825_1": {"section_id": 191, "quality": 0.9523809523809523, "length": 20}, "so_28995673_28995825_0": {"section_id": 72, "quality": 1.0, "length": 4}, "so_28995673_28995825_4": {"section_id": 72, "quality": 1.0, "length": 4}, "so_28995673_28995825_3": {"section_id": 191, "quality": 0.9166666666666666, "length": 11}, "so_28995673_28995825_2": {"section_id": 191, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_28995673_28995825_0": {"section_id": 67, "quality": 1.0, "length": 4}, "so_28995673_28995825_4": {"section_id": 67, "quality": 1.0, "length": 4}, "so_28995673_28995825_1": {"section_id": 185, "quality": 0.9523809523809523, "length": 20}, "so_28995673_28995825_2": {"section_id": 185, "quality": 0.9583333333333334, "length": 23}, "so_28995673_28995825_3": {"section_id": 185, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_28995673_28995825_0": {"section_id": 200, "quality": 1.0, "length": 4}, "so_28995673_28995825_3": {"section_id": 196, "quality": 0.9166666666666666, "length": 11}, "so_28995673_28995825_1": {"section_id": 196, "quality": 0.9523809523809523, "length": 20}, "so_28995673_28995825_2": {"section_id": 196, "quality": 0.9583333333333334, "length": 23}, "so_28995673_28995825_4": {"section_id": 196, "quality": 1.0, "length": 4}}}});