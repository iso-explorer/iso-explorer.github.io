post_cb({"42590018": {"ParentId": "42579031", "LastEditDate": "2017-05-23T11:53:53.227", "CommentCount": "5", "CreationDate": "2017-03-03T23:17:04.167", "OwnerUserId": "5563916", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "42590018", "Score": "1", "Body": "<p>Creating object with <code>new</code> always implicitly calls constructor, it's a part of the standard and this approach is quite handy. So writing <code>neirons[i] = new Neiron[this-&gt;eachLayerCount[i]];</code> means \"create array with N objects of Neiron class and store pointer to that array into <code>neirons[i]</code>\". As a result, dynamic buffer is allocated, N objects are created in it(constructor is called).</p>\n<p>Current case doesn't differ much from creating a single object <code>neirons[i] = new Neiron;</code>, where you might get used to implicit constructor calling.</p>\n<p>Related part of C++ standard:</p>\n<blockquote>\n<p id=\"so_42579031_42590018_0\">Default constructors ... are called to create class objects of dynamic\n  storage duration (3.7.4) created by a new-expression in which the new-initializer is omitted (5.3.4) ...</p>\n</blockquote>\n<h2>EDIT</h2>\n<p>I might have misinterpreted the question. It looks like you are wondering on some fields being initialized by the time when only default constructor is called, which doesn't do anything on them. There should be no magic, not initialized variable gets its value from the garbage left on dynamic memory. If you see some meaningful values instead of random stuff or zeroes, you might have put your new object into the memory, which has just been freed from being used for the same purpose. If you aren't convinced with this explanation, please create <a href=\"https://stackoverflow.com/help/mcve\">MCVE</a>, so we can reproduce and explain scenario step by step.</p>\n<h2>EDIT 2</h2>\n<p>Thanks to clarifications, I see the concern now. Here is what is going within the MCVE:</p>\n<pre><code>test[i] = new Test[layers[i]];\n</code></pre>\n<p>Dynamic buffer is allocated and filled with <code>layers[i]</code> objects. Objects are created with default constructor, so their fields aren't initialized, but contain garbage left on the heap (e.g. <code>fieldA</code> of these objects is set to -842150451 or any other meaningless value).</p>\n<pre><code>for (int j = 0;j &lt; layers[i];++j)\n{\n    test[i][j] = Test(counter);\n    counter++;\n}\n</code></pre>\n<p>This sample uses anonymous object in the right side, so it is actually an equivalent of this one:</p>\n<pre><code>for (int j = 0;j &lt; layers[i];++j)\n{\n    Test temporaryObject(counter);\n    test[i][j] = temporaryObject;\n    counter++;\n}\n</code></pre>\n<p>Program creates temporary object on stack using parametrized constructor, then initializes test[i][j] with it, destroys temporary object and repeats it for next i/j.</p>\n<p>First iteration (i=0, j=0) allocates uninitialized buffer in stack to store temporary object and calls parametrized constructor for it, so you can see fieldA modified in constructor from garbage to zero. Then temporary object is used to init <code>test[i][j]</code> and is destroyed, freeing memory.</p>\n<p>Second iteration (i=0, j=1) allocates exactly the same area of memory to store temporary object (you can verify it by inspecting <code>&amp;temporaryObject</code> or checking <code>this</code> in parametrized constructor). Since this memory contains leftovers from previous usage as temporary object, you see constructor changing <code>fieldA</code> from 0 (left from previous iteration) to 1. And so on.</p>\n<p>I want to stress, that process above is related to temporary object only. <code>test[i][j]</code> are initialized twice only:</p>\n<ol>\n<li>with random garbage during creation with <code>test[i] = new Test[layers[i]];</code></li>\n<li>with actual value from temporary object with <code>test[i][j] = Test(counter);</code></li>\n</ol>\n", "LastActivityDate": "2017-03-06T10:48:18.807"}, "42579031": {"CommentCount": "4", "ViewCount": "82", "PostTypeId": "1", "LastEditorUserId": "4826390", "CreationDate": "2017-03-03T12:34:42.710", "LastActivityDate": "2017-03-06T10:48:18.807", "Title": "Auto initialized objects in two-dimensional array?", "AcceptedAnswerId": "42590018", "LastEditDate": "2017-03-06T08:06:02.193", "Id": "42579031", "Score": "0", "Body": "<p>When I sought for memory leaks I found this interesting peculiarity.\nI have</p>\n<pre><code>class Perseptron :\npublic Neiron\n{\nprivate:\n Neiron** neirons;\n }\n</code></pre>\n<p>in header file of class.\nWhen <code>neirons[i][0]</code> initialized then I see in debugger that <code>neirons[i][1,2...n]</code> fields already initialized such values as <code>neirons[i][0]</code> field values before constructor <code>neirons[i][1,2...n]</code> initialization.</p>\n<pre><code>neirons = new Neiron*[layerCount];\nfor (int i=0;i&lt;layerCount;++i)\n{\n    neirons[i] = new Neiron[this-&gt;eachLayerCount[i]];\n    for (int j=0;j&lt;this-&gt;eachLayerCount[i];++j)\n    {\n        if (i == 0) {\n            neirons[i][j] = Neiron(2, this-&gt;inCount, this-&gt;eachLayerCount[i + 1], i, j);\n            neirons[i][j].inX = this-&gt;inX;\n        }\n        else if(i!=layerCount-1) \n            neirons[i][j] = Neiron(2, this-&gt;eachLayerCount[i - 1], this-&gt;eachLayerCount[i + 1],i,j);\n        else \n            neirons[i][j] = Neiron(2, this-&gt;eachLayerCount[i - 1], 1,i,j);\n    } \n}\n</code></pre>\n<p>My <code>Neiron</code> constructors:</p>\n<pre><code>Neiron::Neiron(int limit,int inCount,int outCount,int layerN,int neironN)\n\nNeiron::Neiron(){}\n</code></pre>\n<p>Why is that?</p>\n<p><strong>EDIT</strong></p>\n<p>MCVE</p>\n<pre><code>class Test{\npublic:\nint fieldA;\nTest(int a)\n{\n    fieldA = a;//when a=3, why already fieldA=2 ?\n}\nTest()\n{\n\n}\n };\n\nint main()\n{\nint layers[] = { 3,4,2 };\nint counter = 0;\nTest** test=new Test*[3];\nfor (int i = 0;i &lt; 3;++i)\n{\n    test[i] = new Test[layers[i]];\n    for (int j = 0;j &lt; layers[i];++j)\n    {\n        test[i][j] = Test(counter);\n        counter++;\n    }\n}\nfor (int i = 0;i &lt; 3;++i) delete[] test[i];\ndelete[] test;\nreturn 0;\n}\n</code></pre>\n", "Tags": "<c++><arrays><pointers><object><dynamic>", "OwnerUserId": "4826390", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42579031_42590018_0": {"section_id": 371, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_42579031_42590018_0": {"section_id": 361, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_42579031_42590018_0": {"section_id": 385, "quality": 0.8666666666666667, "length": 13}}}});