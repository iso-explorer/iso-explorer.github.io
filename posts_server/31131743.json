post_cb({"31131743": {"CommentCount": "5", "ViewCount": "2551", "PostTypeId": "1", "LastEditorUserId": "2864740", "CreationDate": "2015-06-30T07:07:09.763", "LastActivityDate": "2015-07-29T07:28:02.680", "Title": "Is std::vector thread-safe and concurrent by default? Why or why not?", "LastEditDate": "2015-06-30T07:10:05.537", "Id": "31131743", "Score": "5", "Body": "<p>what does it mean to make an dynamic array thread safe and concurrent?\nSay for ex: std::vector.</p>\n<ol>\n<li>two threads may want to insert at the same position. No synchronization needed as it will be done as per thread scheduling.</li>\n<li>one thread erasing and other walking to access the same element? This is not a data structure issue i believe, it is the usage problem.</li>\n</ol>\n<p>So is there anything that needs to be done over std::vector to make it thread safe ad concurrent or it is by default thread safe and concurrent?</p>\n", "Tags": "<c++><vector><data-structures><concurrency><lock-free>", "OwnerUserId": "1987142", "AnswerCount": "2"}, "31131915": {"ParentId": "31131743", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>C++11 says the following about the thread safetly of containers in the standard library:</p>\n<blockquote>\n<p id=\"so_31131743_31131915_0\">23.2.2 Container data races [container.requirements.dataraces]</p>\n<p id=\"so_31131743_31131915_1\">For purposes of avoiding data races (17.6.5.9), implementations shall\n  consider the following functions to be const: <code>begin</code>, <code>end</code>,\n  <code>rbegin</code>, <code>rend</code>, <code>front</code>, <code>back</code>, <code>data</code>, <code>find</code>, <code>lower_bound</code>,\n  <code>upper_bound</code>, <code>equal_range</code>, <code>at</code> and, except in associative or\n  unordered associative containers, <code>operator[]</code>.</p>\n<p id=\"so_31131743_31131915_2\">Notwithstanding (17.6.5.9), implementations are required to avoid data\n  races when the contents of the contained object in different elements\n  in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified\n  concurrently.</p>\n</blockquote>\n<p>So, basically reading from a container from multiple threads is fine, and modifying elements that are already in the container is fine (as long as they are different elements).</p>\n<p>So, neither of your two more specific questions are thread safe for <code>std::vector</code>:</p>\n<p>1) Two threads inserting into the vector is modifying the vector itself - not existing separate elements.</p>\n<p>2) One thread erasing and other walking to access the same element is not safe because erasing an element from the vector isn't an operation that is promised to be thread safe (or \"free from data races\", as the standard puts it).</p>\n<p>To perform those operations safely will require that the program impose some external synchronization itself.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2015-06-30T15:09:20.467", "Id": "31131915", "Score": "14", "CreationDate": "2015-06-30T07:16:52.087", "LastActivityDate": "2015-06-30T15:09:20.467"}, "bq_ids": {"n4140": {"so_31131743_31131915_2": {"section_id": 718, "quality": 0.8947368421052632, "length": 17}, "so_31131743_31131915_1": {"section_id": 717, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_31131743_31131915_2": {"section_id": 707, "quality": 0.9473684210526315, "length": 18}, "so_31131743_31131915_1": {"section_id": 706, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_31131743_31131915_2": {"section_id": 749, "quality": 0.8947368421052632, "length": 17}, "so_31131743_31131915_1": {"section_id": 748, "quality": 0.9259259259259259, "length": 25}}}, "31132250": {"ParentId": "31131743", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The only concurrent operations on a single object in the standard library that are safe by default are\n - Only accessing <code>const</code>-member functions \n - All accesses to synchronization primitives (like mutex lock and unlock or atomic operations) \nEverything else has to be externally synchronized. In particular, the standard library doesn't have any thread safe containers yet (as of c++14)</p>\n<p>So the answer to both of your examples is no, they both require a form of external synchronization.</p>\n<p>What you can do of course is modifying the value of two different elements in the container.</p>\n", "OwnerUserId": "2881849", "LastEditorUserId": "2881849", "LastEditDate": "2015-07-29T07:28:02.680", "Id": "31132250", "Score": "2", "CreationDate": "2015-06-30T07:34:19.000", "LastActivityDate": "2015-07-29T07:28:02.680"}});