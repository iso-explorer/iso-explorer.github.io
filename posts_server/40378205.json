post_cb({"bq_ids": {"n4140": {"so_40378205_40378370_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 436}, "so_40378205_40378370_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 436}}, "n3337": {"so_40378205_40378370_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 428}, "so_40378205_40378370_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 428}}, "n4659": {"so_40378205_40378370_3": {"length": 12, "quality": 0.8, "section_id": 455}, "so_40378205_40378339_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 382}, "so_40378205_40378370_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 455}}}, "40381520": {"Id": "40381520", "PostTypeId": "2", "Body": "<p>The two are identical.</p>\n<p>One rule of software engineering is DRY -- don't repeat yourself.  DRY states that if you can avoid repeating the same token twice, or having two identical lists, you should.</p>\n<p>This is for a few reasons.  Maintaining two identical lists is surprisingly error prone; one gets modified, or has a typo, and the other does not.  It makes code longer, which can make it harder to read.  And avoiding copy-paste coding encourages using some very powerful and expressive techniques that can make what you are doing clearer than doing it manually 17 times.</p>\n<pre><code>struct foo {\n  int a;\n  foo():a(7) {}\n};\n</code></pre>\n<p>here we have repeated ourselves -- the list of member variables, in particular, is listed twice.  Once in the definition of <code>foo</code>, and again in the initializer list of <code>foo::foo</code>.  If it is missing somewhere, you get uninitialized data.</p>\n<pre><code>struct foo {\n  int a = 7;\n  foo() {}\n};\n</code></pre>\n<p>Here we do not repeat ourselves.</p>\n<pre><code>struct foo {\n  int a = 7;\n  foo() {}\n  foo(int i):a(i) {}\n};\n</code></pre>\n<p>Here there is some repetition, but the repetition is unavoidable.  It is, however, minimized.</p>\n<p>There is some cost here, because someone might interpret <code>a=7</code> to mean \"it always starts at 7\", and not \"the default is 7\".</p>\n<pre><code>struct foo {\n  int a = 7;\n  foo():a(3) {}\n  foo(int i):a(i) {}\n};\n</code></pre>\n<p>And the above is a horrible anti-pattern.</p>\n", "LastActivityDate": "2016-11-02T13:44:59.517", "CommentCount": "0", "CreationDate": "2016-11-02T13:44:59.517", "ParentId": "40378205", "Score": "6", "OwnerUserId": "1774667"}, "40378339": {"Id": "40378339", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/data_members#Member_initialization\" rel=\"noreferrer\">cppreference - Non-static data members</a></p>\n<blockquote>\n<p id=\"so_40378205_40378339_0\"><strong>Member initialization</strong><br>\n  1) In the member initializer list of the constructor.<br>\n  2) Through a default member initializer, which is simply a brace or equals initializer included in the member declaration, which is used if the member is omitted in the member initializer list.</br></br></p>\n<p id=\"so_40378205_40378339_1\">If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</p>\n</blockquote>\n<hr>\n<p>To conclude, both initializers are equivalent and do what they are supposed to do.</p>\n<p>I would prefer the default member initializer, if I'd use the default constructor anyway, or if all or most constructors would initialize the member to the same value.</p>\n<pre><code>class Foo {\nprivate:\n    int a = 0;\n};\n</code></pre>\n<p>If all constructors initialize the member to some different value however, using the default member initializer makes less sense, and then an explicit initialization in the respective constructors would be more clear</p>\n<pre><code>class Foo {\nprivate:\n    int a;\npublic:\n    Foo() : a(3) {}\n    Foo(int i) : a(i) {}\n};\n</code></pre>\n</hr>", "LastEditorUserId": "1741542", "LastActivityDate": "2016-11-02T13:15:52.230", "Score": "16", "CreationDate": "2016-11-02T11:02:23.627", "ParentId": "40378205", "CommentCount": "0", "OwnerUserId": "1741542", "LastEditDate": "2016-11-02T13:15:52.230"}, "40378370": {"Id": "40378370", "PostTypeId": "2", "Body": "<p>The first set of examples are identical to each other.</p>\n<p>For the last example, the C++ standard specifies as follows:</p>\n<blockquote>\n<p id=\"so_40378205_40378370_0\">12.6.2 Initializing bases and members</p>\n<p id=\"so_40378205_40378370_1\">[ ... ]</p>\n<p id=\"so_40378205_40378370_2\">If a given non-static data member has both a\n  brace-or-equal-initializer and a mem-initializer, the initialization\n  specified by the mem-initializer is performed, and the non-static data\n  member\u2019s brace-or-equal-initializer is ignored. [ Example: Given</p>\n<pre><code>struct A {\nint i = /\u2217 some integer expression with side effects \u2217/ ;\nA(int arg) : i(arg) { }\n// ...\n};\n</code></pre>\n<p id=\"so_40378205_40378370_3\">the A(int) constructor will simply initialize i to the value of arg,\n  and the side effects in i\u2019s brace-or-equal-initializer will not take\n  place. \u2014 end example ]</p>\n</blockquote>\n", "LastActivityDate": "2016-11-02T11:03:56.900", "CommentCount": "0", "CreationDate": "2016-11-02T11:03:56.900", "ParentId": "40378205", "Score": "9", "OwnerUserId": "3943312"}, "40378205": {"ViewCount": "1156", "Body": "<p>I'd like to know if there is a difference between this code:</p>\n<pre><code>class Foo{\n private:\n    int a = 0;\n public:\n    Foo(){}\n}\n</code></pre>\n<p>And:</p>\n<pre><code>class Foo{\n private:\n    int a;\n public:\n    Foo(): a(0) {}\n}\n</code></pre>\n<p>And, if so, which should be preferred?\nI know it's preferable to use an initialiser list than assigning in the constructor body, but what about initialiser list vs directly initialising in field declaration (for primitive types, at least, as is the case here)?</p>\n<p>Also, what of the case below:</p>\n<pre><code>class Foo{\n private:\n   int a = 0;\n public:\n   Foo(){}\n   Foo(int i): a(i) {}\n}\n</code></pre>\n<p>When the non-default constructor is called: is \"a\" initialised twice, first to 0 then to \"i\", or directly to \"i\"?</p>\n", "AcceptedAnswerId": "40378339", "Title": "C++ Initialising fields directly vs initialisation list in default constructor", "CreationDate": "2016-11-02T10:56:19.907", "Id": "40378205", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-11-02T13:44:59.517", "Score": "20", "OwnerUserId": "6864750", "Tags": "<c++>", "AnswerCount": "3"}});