post_cb({"10533894": {"CreationDate": "2012-05-10T12:21:59.203", "CommentCount": "4", "Body": "<p>The short (slightly over-simplified) answer is, \"it will fail for anything other than a simple-type-specifier\".</p>\n<p>5.2.3/1 says:</p>\n<blockquote>\n<p id=\"so_10533500_10533894_0\">A <em>simple-type-speci\ufb01er</em> (7.1.6.2) or <em>typename-speci\ufb01er</em> (14.6) followed\n  by a parenthesized <em>expression-list</em> constructs a value of the speci\ufb01ed\n  type given the expression list.</p>\n</blockquote>\n<p>A <em>simple-type-specifier</em> can be either a one-word name for a type (optionally plus some <code>::</code> stuff for the scope, and/or template arguments which themselves need not be simple type specifiers) or a <code>decltype</code> expression. The possibilities are listed in 7.1.6.2.</p>\n<p><code>unsigned int</code> and <code>int*</code> aren't <em>simple-type-specifiers</em>. Any compound type specifier will fail, so cv-qualification, array types, function types, pointer types including pointer-to-function and pointer-to-member would all need a typedef.</p>\n<p>Also ruled out are the multi-word type identifiers like <code>unsigned char</code>, <code>long double</code>. For your first example, <code>unsigned</code> would work in place of <code>unsigned int</code>.</p>\n<p>A <em>typename-specifier</em> is a type preceded by <code>typename</code>, used in templates to assert that a dependent name is indeed a type, not a data member or member function.</p>\n<p>Finally of course, once you get past this restriction the type has to actually be constructible or convertible from the <em>expression-list</em>. So for example you can't create a temporary of function type using this or any other syntax.</p>\n", "Id": "10533894", "OwnerUserId": "13005", "LastEditDate": "2012-05-10T13:58:48.173", "ParentId": "10533500", "LastActivityDate": "2012-05-10T13:58:48.173", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "13005"}, "bq_ids": {"n4140": {"so_10533500_10533894_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 5999}}, "n3337": {"so_10533500_10533894_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 5767}}}, "10533500": {"CreationDate": "2012-05-10T11:59:12.370", "ViewCount": "116", "Id": "10533500", "AcceptedAnswerId": "10533894", "Score": "4", "Title": "Which temporaries cannot be initialized with `someType()` in c++11?", "LastEditorUserId": "516138", "CommentCount": "3", "Body": "<p>I have some macros which operate on types and initial values. I need to cast the initial value <code>vIni</code> to the <code>vType</code> (<code>vIni</code> is always convertible to <code>vType</code>, sometimes it has the same type). The <code>vIni</code> might be empty as well, in which case <code>vType</code> should be uninitialized or default-initialized. The reult is passed to templated function. </p>\n<p>In short,</p>\n<pre><code>template&lt;typename T&gt; void foo(const T&amp; o);\n\nfoo(vType(vIni));\nfoo(vType());\n</code></pre>\n<p>must compile.</p>\n<p>I already discovered that <code>foo(unsigned int())</code> or <code>foo(int*())</code> will not compile, but it can be worked around with a typedef.</p>\n<p>What are other cases (besides built-in types with spaces and pointers) which will fail?</p>\n", "Tags": "<c++><c++11><initialization>", "LastEditDate": "2012-05-10T12:17:18.517", "LastActivityDate": "2012-05-10T13:58:48.173", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "761090"}});