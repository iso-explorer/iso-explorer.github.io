post_cb({"bq_ids": {"n4140": {"so_14156640_14157336_0": {"length": 14, "quality": 1.0, "section_id": 6005}, "so_14156640_14157511_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7128}}, "n3337": {"so_14156640_14157336_0": {"length": 14, "quality": 1.0, "section_id": 5773}, "so_14156640_14157511_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6872}}, "n4659": {"so_14156640_14157336_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7504}, "so_14156640_14157511_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 8629}}}, "14156640": {"ViewCount": "346", "Body": "<p>During Andrei Alexandrescu's talk on error handling:</p>\n<p>See <a href=\"http://channel9.msdn.com/Shows/Going+Deep/C-and-Beyond-2012-Andrei-Alexandrescu-Systematic-Error-Handling-in-C\">C++ and Beyond 2012: Andrei Alexandrescu - Systematic Error Handling in C++</a> (about 30 minutes in)</p>\n<p>Andrei presents the following piece of code:</p>\n<pre><code>~Expected()\n{\n    using std::exception_ptr;\n    if (gotHam) ham.~T();\n    else spam.~exception_ptr();\n}\n</code></pre>\n<p>This destructor is cleaning up a <code>union</code> which contains either some type <code>T</code> or a <code>std::exception_ptr</code>. The union is populated using <code>placement new</code>.</p>\n<p>Andrei then explains that the <code>using std::exception_ptr;</code> is necessary because the following code does not parse:</p>\n<pre><code>    else spam.~std::exception_ptr();\n</code></pre>\n<p>This means that it is always necessary to have a using directive if you need to explicitly call the destructor of a class in a different namespace.</p>\n<p>Why doesn't the second example parse?</p>\n<p>Would the followng code be a valid alternative? </p>\n<pre><code>    else delete spam;\n</code></pre>\n<p>Does this have the same affect as explicitly calling the destructor of <code>std::exception_ptr</code> </p>\n", "AcceptedAnswerId": "14157511", "Title": "Why doesn't ~ followed by :: parse", "CreationDate": "2013-01-04T11:49:44.043", "Id": "14156640", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-01-04T12:10:28.613", "LastEditorUserId": "25824", "LastActivityDate": "2013-01-04T13:00:18.317", "Score": "14", "OwnerUserId": "926751", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "14157336": {"Id": "14157336", "PostTypeId": "2", "Body": "<p>The syntax <code>spam.~std::exception_ptr</code> isn't allowed because the grammar ask for an id-expression and <code>~std::exception_ptr</code> isn't one, as Gorpik pointed, you need <code>spam.std::exception_ptr::~exception_ptr()</code>. But I'm not understanding the reason why qualification is needed, in the clause describing the syntax, it is reminded that</p>\n<blockquote>\n<p id=\"so_14156640_14157336_0\">because the name of a class is inserted in its class scope (Clause 9), the name of a class is also considered a nested member of that class.</p>\n</blockquote>\n<p>so I think that <code>spam.~exception_ptr()</code> should be valid even without a using clause.  BTW</p>\n<pre><code>namespace ns {\nstruct Foo {};\n}\n\nvoid f()\n{\n    ns::Foo x;\n    x.~Foo();\n}\n</code></pre>\n<p>compile cleanly with all g++ I've access to (included the very old 2.95).  That seems to confirm my opinion that if it doesn't work in the context of the updated union types of C++11, it's a bug in the implementation.</p>\n<p>Edit, with  g++ 4.7.1, the following compiles as well with -std=c++11.</p>\n<pre><code>namespace ns {\nstruct Foo {};\n}\n\nstruct Bar {};\n\nunion U {\n    ns::Foo f;\n    Bar b;\n};\n\nstruct C {\n    bool b;\n    U u;\n    ~C() {\n        if (b)\n            u.f.~Foo();\n        else\n            u.b.~Bar();\n    }                \n};\n\nvoid f()\n{\n    C c;\n}\n</code></pre>\n<p>so Andrei has be side-tracked (either by a bug in the compiler he was using or by forgetting the fact that class names are imported in the scope of a class) trying a problem which didn't need to be solved.</p>\n", "LastEditorUserId": "136208", "LastActivityDate": "2013-01-04T12:43:31.813", "Score": "3", "CreationDate": "2013-01-04T12:36:47.210", "ParentId": "14156640", "CommentCount": "2", "OwnerUserId": "136208", "LastEditDate": "2013-01-04T12:43:31.813"}, "14157214": {"Id": "14157214", "PostTypeId": "2", "Body": "<p>The problem here is that <code>~std::exception_ptr()</code> is not really the name of the function you are trying to call, but just <code>~exception_ptr()</code>. And, since it belongs to a class in a different namespace, it is inaccessible (EDIT: though it should be accessible according to \u00a73.4.5/3 in the C++11 standard, as n.m. points out in his answer, but Microsoft compiler behaves this way).</p>\n<p>You have an alternative to bringing the class into your namespace: do an explicit call using the qualified class name:</p>\n<pre><code>else spam.std::exception_ptr::~exception_ptr(); // This is legal\n</code></pre>\n<p>As for your second question, as R. Martinho Fernandes correctly explained in a comment, calling the <code>delete</code> operator is not equivalent to just calling the destructor: it also calls the awkwardly named function <code>operator delete()</code>.</p>\n", "LastEditorUserId": "25824", "LastActivityDate": "2013-01-04T13:00:18.317", "Score": "8", "CreationDate": "2013-01-04T12:27:03.833", "ParentId": "14156640", "CommentCount": "1", "OwnerUserId": "25824", "LastEditDate": "2013-01-04T13:00:18.317"}, "14157511": {"Id": "14157511", "PostTypeId": "2", "Body": "<p>Andrei probably uses <code>using std::exception_ptr;</code> because his compiler is broken.</p>\n<p>There's no need. <code>spam.~exception_ptr();</code> should compile just fine without it.</p>\n<blockquote>\n<p id=\"so_14156640_14157511_0\">3.4.5/3. If the unqualified-id is ~type-name, the type-name is looked up in the context of the entire postfix-expression. If the type T of the object expression is of a class type C, the type-name is also looked up in the scope of class C.</p>\n</blockquote>\n<p>It indeed compiles with gcc.</p>\n<p>If you need to use qualified-name for some reason, <code>spam.std::exception_ptr::~exception_ptr();</code> also compiles.</p>\n", "LastActivityDate": "2013-01-04T12:50:45.730", "CommentCount": "1", "CreationDate": "2013-01-04T12:50:45.730", "ParentId": "14156640", "Score": "10", "OwnerUserId": "775806"}});