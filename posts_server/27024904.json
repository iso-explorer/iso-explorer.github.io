post_cb({"27024904": {"CommentCount": "6", "ViewCount": "71", "PostTypeId": "1", "LastEditorUserId": "2820379", "CreationDate": "2014-11-19T19:04:38.057", "LastActivityDate": "2014-11-19T19:28:14.787", "Title": "Is it safe to secure a racy variable with another racy variable?", "LastEditDate": "2014-11-19T19:28:14.787", "Id": "27024904", "Score": "1", "Body": "<pre><code>void foo(volatile int&amp; a, volatile int&amp; b, bool threadOne) {\n    if (threadOne) {\n        //EDIT: switched the following two lines\n        b = 10;\n        a = 5;\n    } else {\n        while(a == 0);\n        cout &lt;&lt; a &lt;&lt; b;\n    }\n}\n\n//somewhere else\nint a = 0;\nint b = 0;\nstd::thread th1(foo, a, b, true);\nstd::thread th2(foo, a, b, false);\n</code></pre>\n<p>Is this safe on x86 i.e. every legal interleaving of instructions according to the c++ standard and the x86 reference will print \"510\"? My hypothesis is that it actually is safe.</p>\n", "Tags": "<c++><multithreading><caching><x86><volatile>", "OwnerUserId": "2820379", "AnswerCount": "2"}, "27025161": {"ParentId": "27024904", "CommentCount": "20", "Body": "<p><strong>tl;dr</strong> No, no, no, a thousand times no.</p>\n<p>As far as the C++11 standard is concerned, the program has undefined behavior because it has a data race (<code>a</code> is read and written by concurrent executions without synchronization). So no, it won't always print 510. <code>volatile</code> has no effect at all on that, it doesn't mean what <code>volatile</code> in C# and Java means.</p>\n<p>I also suspect (but can't assert with full confidence) that, independently, the x86 chip can also break this program, though perhaps not due to <em>interleaving</em>. However,</p>\n<ol>\n<li>The new value of <code>a</code> may come into effect before the new value of <code>b</code> becomes visible (since no memory fence prevents the chip from reordering the writes).</li>\n<li>The new value of either variable may never become visible to the second thread. Check out cache coherence protocols.</li>\n</ol>\n<p>You're playing with fire. For no good reason to boot, condition variables are cheap. If the expected delay is small enough for a condition variable to <em>not</em> be cheap, then a spinlock (with proper synchronization, i.e. atomics) will be cheap instead.</p>\n", "OwnerUserId": "395760", "PostTypeId": "2", "Id": "27025161", "Score": "4", "CreationDate": "2014-11-19T19:19:04.287", "LastActivityDate": "2014-11-19T19:19:04.287"}, "bq_ids": {"n4140": {"so_27024904_27025260_2": {"section_id": 5834, "quality": 0.90625, "length": 29}, "so_27024904_27025260_0": {"section_id": 5817, "quality": 0.9375, "length": 15}, "so_27024904_27025260_1": {"section_id": 5834, "quality": 1.0, "length": 4}}, "n3337": {"so_27024904_27025260_2": {"section_id": 5605, "quality": 0.625, "length": 20}, "so_27024904_27025260_0": {"section_id": 5588, "quality": 0.9375, "length": 15}}, "n4659": {"so_27024904_27025260_2": {"section_id": 7296, "quality": 0.90625, "length": 29}, "so_27024904_27025260_0": {"section_id": 7278, "quality": 0.875, "length": 14}, "so_27024904_27025260_1": {"section_id": 7296, "quality": 1.0, "length": 4}}}, "27025260": {"ParentId": "27024904", "CommentCount": "0", "Body": "<p>\u00a71.10 [intro.multithread] (quoting N4140):</p>\n<blockquote>\n<p id=\"so_27024904_27025260_0\">6 Two expression evaluations <em>conflict</em> if one of them modifies a\n  memory location (1.7) and the other one accesses or modifies the same\n  memory location.</p>\n<p id=\"so_27024904_27025260_1\">23 Two actions are <em>potentially concurrent</em> if</p>\n<ul>\n<li>they are performed by different threads, or</li>\n<li>they are unsequenced, and at least one is performed by a signal handler.</li>\n</ul>\n<p id=\"so_27024904_27025260_2\">The execution of a program contains a <em>data race</em> if it contains two\n  potentially concurrent conflicting actions, at least one of which is\n  not atomic, and neither happens before the other, except for the\n  special case for signal handlers described below. Any such data race\n  results in undefined behavior.</p>\n</blockquote>\n<p>One of your threads reads from <code>a</code>, another writes to <code>a</code>, neither is atomic, and neither of these two potentially concurrent conflicting actions happens before the other. Hence, you have a data race and undefined behavior.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "27025260", "Score": "5", "CreationDate": "2014-11-19T19:25:01.343", "LastActivityDate": "2014-11-19T19:25:01.343"}});