post_cb({"24992436": {"ParentId": "24992091", "LastEditDate": "2014-09-03T13:25:16.807", "CommentCount": "5", "CreationDate": "2014-07-28T09:40:31.643", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "PostTypeId": "2", "Id": "24992436", "Score": "1", "Body": "<p>From what I can make out, this looks something typical of the C to C++ and vice-versa API mapping.</p>\n<p>Given that you can't change the C header file, the definition of <code>Opaque</code> is constrained and essentially can't be typed to any C++ constructs contained in C++ header file.</p>\n<p>It's a little ugly in a purist sense, but you can use <code>reinterpret_cast</code> for this.</p>\n<p>In the cppheader;</p>\n<pre><code>struct internal_data {};\n\ntemplate&lt;typename T&gt;\nstruct Internal {\n    T data;\n};\n\ntemplate &lt;typename T&gt;\nOpaque map_internal(Internal&lt;T&gt;* p)\n{\n  return reinterpret_cast&lt;Opaque&gt;(p);\n}\n\ntemplate &lt;typename T&gt;\nInternal&lt;T&gt;* remap_internal(Opaque p)\n{\n  return reinterpret_cast&lt;Internal&lt;T&gt;*&gt;(p);\n}\n</code></pre>\n<p>And then the internal <code>Initialise</code> changes to;</p>\n<pre><code>template&lt;typename T&gt;\nOpaque Initialise(T data) {\n    Internal&lt;T&gt;* t = new Internal&lt;T&gt;();\n    t-&gt;data = data;\n    return map_internal(t);\n}\n</code></pre>\n<p>You don't mention anything around resource management, but the reverse of <code>map_internal</code> can be used to cast the <code>Opaque</code> back to <code>Internal&lt;T&gt;</code> for the corresponding <code>delete</code> when required.</p>\n<p>Note: type safety is a concern here (w.r.t. the <code>reinterpret_cast</code>), but in this case the trade-off is type safety vs. interoperability. Because of strict aliasing, you should <em>not</em> attempt to access any data that may (in future) be in <code>internal_data</code>, it is there just to convert from and back to <code>Internal&lt;T&gt;</code>.</p>\n<p>Worth noting here is <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\">cppreference</a>, conversion 5, related to the C++ specification 5.2.10.</p>\n<blockquote>\n<p id=\"so_24992091_24992436_0\">Any pointer to object of type T1 can be converted to pointer to object of another type cv T2. This is exactly equivalent to</p>\n<p id=\"so_24992091_24992436_1\"><code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(expression))</code>.</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4180f3c0392a3dd2\" rel=\"nofollow\">Live sample</a></p>\n", "LastActivityDate": "2014-09-03T13:25:16.807"}, "24995265": {"ParentId": "24992091", "CommentCount": "2", "Body": "<p>If you don't want to <code>reinterpret_cast&lt;&gt;</code>, you can inherit from a dummy <code>internal_data</code>, i.e.</p>\n<pre><code>struct internal_data {};\ntemplate&lt;typename T&gt;\nstruct Internal: internal_data {\n    T data;\n};\n</code></pre>\n<p>When you need to access the data just down-cast from the pointer to your template type.</p>\n", "OwnerUserId": "3716988", "PostTypeId": "2", "Id": "24995265", "Score": "1", "CreationDate": "2014-07-28T12:27:19.650", "LastActivityDate": "2014-07-28T12:27:19.650"}, "25001302": {"ParentId": "24992091", "CommentCount": "0", "Body": "<p>Maybe union would help?</p>\n<pre><code>template&lt;typename T&gt;\nunion InternalExtend\n{\n    Internal&lt;T&gt;* internal;\n    Opaque opaque;\n};\n\ntemplate&lt;typename T&gt;\nOpaque Initialise(T data) {\n    InternalExtend&lt;T&gt; ret;\n    ret.internal = new Internal&lt;T&gt;();\n    ret.internal-&gt;data = data;\n    return ret.opaque;\n}\n</code></pre>\n", "OwnerUserId": "1284053", "PostTypeId": "2", "Id": "25001302", "Score": "0", "CreationDate": "2014-07-28T17:56:41.373", "LastActivityDate": "2014-07-28T17:56:41.373"}, "bq_ids": {"n4140": {"so_24992091_24992436_0": {"section_id": 39, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_24992091_24992436_0": {"section_id": 37, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_24992091_24992436_0": {"section_id": 8732, "quality": 0.6153846153846154, "length": 8}}}, "24992091": {"CommentCount": "3", "ViewCount": "243", "PostTypeId": "1", "LastEditorUserId": "454906", "CreationDate": "2014-07-28T09:22:00.377", "LastActivityDate": "2014-09-03T13:25:16.807", "Title": "How to define C-forward declared opaque struct with a templated C++ struct", "LastEditDate": "2014-07-28T09:39:19.343", "Id": "24992091", "Score": "1", "Body": "<p>Given the C declaration of opaque type (cheader.h)</p>\n<pre><code>typedef struct internal_data * Opaque;\n</code></pre>\n<p>I want to declare \"internal_data\" as an instance of the template (cppheader.h)</p>\n<pre><code>namespace Lib {\ntemplate&lt;typename T&gt;\nstruct Internal {\n    T data;\n};\n\ntemplate&lt;typename T&gt;\nInternal&lt;T&gt;* Initialise(T data) {\n    Internal&lt;T&gt;* t = new Internal&lt;T&gt;();\n    t-&gt;data = data;\n    return t;\n}\n}\n</code></pre>\n<p>So that the following function compiles:</p>\n<pre><code>#include \"cppheader.h\"\n#include \"cheader.h\"\n\nint main(int argc, char** argv)\n{\n    Opaque o = Lib::Initialise(argc);\n    return 0;\n}\n</code></pre>\n<p>I can't modify the C header. The C++ header isn't exposed, so I can modify that one at will. The instantiated template needs to be POD.\nThere are multiple opaque types on the C header that I omitted for simplicity. They are all supposed to dereference to instantiations of the C++ template.</p>\n<p>I've tried</p>\n<pre><code>typedef Lib::Internal&lt;int&gt; internal_data;\n</code></pre>\n<p>and </p>\n<pre><code>struct internal_data : Lib::Internal&lt;int&gt; {};\n</code></pre>\n<p>but neither compiles.</p>\n", "Tags": "<c++><c><templates>", "OwnerUserId": "454906", "AnswerCount": "3"}});