post_cb({"8697182": {"ParentId": "8697105", "LastEditDate": "2012-01-02T15:56:26.123", "CommentCount": "8", "CreationDate": "2012-01-02T03:34:07.387", "OwnerUserId": "103167", "LastEditorUserId": "103167", "PostTypeId": "2", "Id": "8697182", "Score": "13", "Body": "<p>TL;DR version: <strong>MSVC's behavior is actually correct, although the warning is incorrect (it should say <em>value-initialized</em>).</strong></p>\n<hr>\n<p>For <code>new (p) buf_type;</code>, MSVC is correct to perform default initialization, because the standard (5.3.4 <code>[expr.new]</code>) demands:</p>\n<blockquote>\n<p id=\"so_8697105_8697182_0\">A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is <em>default-initialized</em> (8.5); if no initialization is performed, the object has indeterminate value.</li>\n<li>Otherwise,  the <em>new-initializer</em> is interpreted according to the initialization rules  of  8.5 for direct-initialization.</li>\n</ul>\n</blockquote>\n<p><code>std::array</code> is a class type.  For class types (8.5 <code>[dcl.init]</code>):</p>\n<blockquote>\n<p id=\"so_8697105_8697182_1\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type, the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>\n</ul>\n</blockquote>\n<p>default-initialization leaves the memory unchanged only for primitive types (and raw arrays thereof)</p>\n<p>On the other hand, <code>std::array</code> has a defaulted default constructor, so the members themselves ought to be default-initialized.  And in fact you observed that.</p>\n<hr>\n<p>Then according to the same section, the <code>new (p) buf_type();</code> version causes direct-initialization.</p>\n<p><strike>\n<code>std::array</code> is an aggregate, so I think this rule (8.5.1 <code>[dcl.init.aggr]</code>) then applies:</strike></p>\n<blockquote>\n<p id=\"so_8697105_8697182_2\">If there are fewer <em>initializer-clauses</em> in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from an empty initializer list (8.5.4).</p>\n</blockquote>\n<p>And that means value-initialization for all elements.\n</p></hr></hr>\n<p>Nope, here's the rule (8.5 <code>[dcl.init]</code>):</p>\n<blockquote>\n<p id=\"so_8697105_8697182_3\">An object whose initializer is an empty set of parentheses, i.e., <code>()</code>, shall be value-initialized.</p>\n</blockquote>\n<p>Value initialization of an aggregate means value initialization of all elements, since the elements are primitive, that means zero fill.</p>\n<p>So MSVC's behavior is actually correct, although the warning is incorrect (it should say <em>value-initialized</em>).</p>\n<p>It's already been reported, see</p>\n<ul>\n<li><a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/335987/vc9-erroneously-generates-c4345-when-compiling-value-initialized-placement-new-expressions\" rel=\"noreferrer\">VC9 erroneously generates C4345 when compiling value-initialized placement new expressions</a></li>\n</ul>\n", "LastActivityDate": "2012-01-02T15:56:26.123"}, "8697105": {"CommentCount": "1", "ViewCount": "3971", "LastActivityDate": "2012-01-02T15:56:26.123", "Body": "<p>The following code triggers <a href=\"http://msdn.microsoft.com/en-us/library/wewb47ee.aspx\" rel=\"noreferrer\">C4345</a> on the marked line:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;iostream&gt;\n\nint main(){\n    static unsigned const buf_size = 5;\n    typedef std::array&lt;char, buf_size&gt; buf_type;\n\n    char buf[] = { 5, 5, 5, 5, 5 };\n    void* p = &amp;buf[0];\n    buf_type* pbuf = new (p) buf_type(); // &lt;=== #10\n\n    for(unsigned i=0; i &lt; buf_size; ++i)\n        std::cout &lt;&lt; (char)((*pbuf)[i] + 0x30) &lt;&lt; ' ';\n}\n</code></pre>\n<blockquote>\n<p id=\"so_8697105_8697105_0\">main.cpp(10): warning C4345: behavior change: an object of POD type constructed with an initializer of the form () will be default-initialized</p>\n</blockquote>\n<p>So, according to their warning, line 10 should have the same behaviour as if it was written as </p>\n<pre><code>buf_type* pbuf = new (p) buf_type; // note the missing '()'\n</code></pre>\n<p>However, the output differes. Namely, the first version will print five <code>0</code>s, while the second version will print five <code>5</code>s. As such, the first version is indeed value-initialized (and the underlying buffer zero-initialized), even though MSVC says it won't.</p>\n<p>Can this be considered a bug in MSVC? Or did I misinterpret the warning / is my test code faulty?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "8697182", "FavoriteCount": "2", "Title": "Is the C4345 warning of Visual Studio wrong?", "Id": "8697105", "Score": "19", "CreationDate": "2012-01-02T03:11:23.087", "Tags": "<c++><visual-c++><initialization><c++11>", "OwnerUserId": "500104", "AnswerCount": "3"}, "8697171": {"ParentId": "8697105", "CommentCount": "2", "Body": "<p>Here is how I read the MS article <a href=\"http://msdn.microsoft.com/en-us/library/wewb47ee%28v=vs.80%29.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/wewb47ee%28v=vs.80%29.aspx</a></p>\n<p>Under the old version of VS (your original syntax) - in this article, VS 2003 - a POD initialize would default initialize with 0s.  Your code would support this.</p>\n<p>Under the new version of VS - in this article, that would be VS 2005 - it was up to the programmer to initializes the POD explicitly as no default initialization was performed.  In your case, as shown in your code, it correctly displays 5s.</p>\n<p>Thus, as I read it, the old syntax initialized the POD to 0s even if your code had already explicitly initialized it.  I do add a disclaimer that it is very late here and I am tired, so this may all be babbling.</p>\n", "OwnerUserId": "1125166", "PostTypeId": "2", "Id": "8697171", "Score": "1", "CreationDate": "2012-01-02T03:32:23.783", "LastActivityDate": "2012-01-02T03:32:23.783"}, "bq_ids": {"n4140": {"so_8697105_8697182_3": {"section_id": 3290, "quality": 1.0, "length": 7}, "so_8697105_8697182_2": {"section_id": 3304, "quality": 0.9444444444444444, "length": 17}, "so_8697105_8697182_1": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_8697105_8697182_0": {"section_id": 6098, "quality": 1.0, "length": 7}}, "n3337": {"so_8697105_8697182_3": {"section_id": 3160, "quality": 1.0, "length": 7}, "so_8697105_8697182_2": {"section_id": 3174, "quality": 0.9444444444444444, "length": 17}, "so_8697105_8697182_1": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_8697105_8697182_0": {"section_id": 5864, "quality": 1.0, "length": 7}}, "n4659": {"so_8697105_8697182_3": {"section_id": 4052, "quality": 1.0, "length": 7}, "so_8697105_8697182_2": {"section_id": 4070, "quality": 0.8333333333333334, "length": 15}, "so_8697105_8697182_0": {"section_id": 7595, "quality": 1.0, "length": 7}}}, "8697395": {"ParentId": "8697105", "LastEditDate": "2012-01-02T04:32:29.023", "CommentCount": "7", "CreationDate": "2012-01-02T04:27:15.970", "OwnerUserId": "1110687", "LastEditorUserId": "1110687", "PostTypeId": "2", "Id": "8697395", "Score": "-1", "Body": "<p>This warning refers strictly to a change that occurred in the way Visual Studio would interpret and compile that statement from a previous version. \"Behavior change\" means that \"if you wrote this with an older VC++, watch out, things have changed.\" It is not meant to say that the first example is equivalent to the second.</p>\n<p>In fact, this is the compiler conforming closer to the C++ standard. It isn't a warning that those things WILL be equivalent - it is a warning that they ONCE WERE but now, aren't. You extrapolated what \"default initialized\" means incorrectly.</p>\n<p>Normally, a POD object that is placement-new'd SHOULD NOT be default initialized, so this warning is correct in telling you that () will make it happen. However, it isn't a warning against doing this per se, but as I said, Microsoft noting a change.</p>\n<p>An std::array is guaranteed (so says MSDN documentation) to be a POD type when the type supplied is POD (such as char). A POD type is basically plain-old-data: the compiler treats it as if it were just an object. Even though it is a class, no initialization is performed on it unless explicitly called for, the same as it wouldn't initialize a standard C array pointer (and, in fact, cannot).</p>\n<p>Let's go to some C code for some illumination.</p>\n<pre><code>// POD version.\n// buf_type = new (p) buf_type;\ntypedef char buf_type;\nbuf_type *pbuf = p;             // Pointer is assigned\n</code></pre>\n<p>And,</p>\n<pre><code>// Constructed version.\n// buf_type = new (p) buf_type();\nvoid construct_buf_type(buf_type *what);\n\ntypedef char buf_type;\nbuf_type *pbuf = p;             // Pointer is assigned\nconstruct_buf_type(buf_type);   // Constructor is called which default-initializes it\n</code></pre>\n<p>What happens behind the scenes is a little bit different, but this is conceptually <em>exactly</em> what happens. Both statements tell the compiler to place the object at that location; the one with the () at the end tells it to call the default constructor afterwards.</p>\n<p>Yes, this can be an annoying syntactic ambiguity if you forget your ()'s in your new's when you're writing POD objects. But almost nobody ever does, which is part of why PODs are often mis-understood.</p>\n", "LastActivityDate": "2012-01-02T04:32:29.023"}});