post_cb({"8452218": {"ParentId": "5458204", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can try and define the following macro:</p>\n<pre><code>#define for_range(_type, _param, _A1, _B1) \\\n    for (_type _param = _A1, _finish = _B1,\\\n    _step = static_cast&lt;_type&gt;(2*(((int)_finish)&gt;(int)_param)-1),\\\n    _stop = static_cast&lt;_type&gt;(((int)_finish)+(int)_step); _param != _stop; \\\n_param = static_cast&lt;_type&gt;(((int)_param)+(int)_step))\n</code></pre>\n<p>Now you can use it:</p>\n<pre><code>for_range (unsigned, i, 10,0)\n{\n    cout &lt;&lt; \"backwards i: \" &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre>\n<p>It can be used to iterate backwards and forwards through unsigned, integers, enums and chars:</p>\n<pre><code>for_range (char, c, 'z','a')\n{\n    cout &lt;&lt; c &lt;&lt; endl;\n}\n\nenum Count { zero, one, two, three }; \n\nfor_range (Count, c, zero, three)\n{\n    cout &lt;&lt; \"forward: \" &lt;&lt; c &lt;&lt; endl;\n}\n</code></pre>\n<p>Despite its awkward definition it is optimized very well. I looked at disassembler in VC++.\nThe code is extremely efficient. Don't be put off but the three for statements: the compiler will produce only one loop after optimization! You can even define enclosed loops:</p>\n<pre><code>unsigned p[4][5];\n\nfor_range (Count, i, zero,three)\n    for_range(unsigned int, j, 4, 0)\n    {   \n        p[i][j] = static_cast&lt;unsigned&gt;(i)+j;\n    }\n</code></pre>\n<p>You obviously cannot iterate through enumerated types with gaps. </p>\n", "OwnerUserId": "653772", "LastEditorUserId": "653772", "LastEditDate": "2011-12-20T12:52:04.590", "Id": "8452218", "Score": "0", "CreationDate": "2011-12-09T21:58:28.940", "LastActivityDate": "2011-12-20T12:52:04.590"}, "5458739": {"ParentId": "5458204", "CommentCount": "0", "Body": "<p>My pattern for this is usually...</p>\n<pre><code>for( unsigned int i_plus_one = n; i_plus_one &gt; 0; --i_plus_one )\n{\n    const unsigned int i = i_plus_one - 1;\n    // ...\n}\n</code></pre>\n", "OwnerUserId": "205587", "PostTypeId": "2", "Id": "5458739", "Score": "2", "CreationDate": "2011-03-28T12:05:38.047", "LastActivityDate": "2011-03-28T12:05:38.047"}, "5458272": {"ParentId": "5458204", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I would use two variables:</p>\n<pre><code>unsigned int start = 10;\nfor (unsigned int j = 0, i = start; j &lt;= start; ++ j, -- i) {\n    // ...\n}\n</code></pre>\n<p>You can also use a while loop:</p>\n<pre><code>unsigned int start = 10;\nunsigned int i = start + 1;\nwhile (i --) {\n    // ...\n}\n</code></pre>\n", "OwnerUserId": "5353", "LastEditorUserId": "5353", "LastEditDate": "2011-03-28T11:35:54.563", "Id": "5458272", "Score": "1", "CreationDate": "2011-03-28T11:24:17.257", "LastActivityDate": "2011-03-28T11:35:54.563"}, "5458283": {"ParentId": "5458204", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You can use</p>\n<pre><code>for (unsigned int j = n; j-- &gt; 0; ) {}\n</code></pre>\n<p>It iterates from <code>n-1</code> down to <code>0</code>.</p>\n", "OwnerUserId": "569852", "LastEditorUserId": "149482", "LastEditDate": "2011-03-28T12:44:06.910", "Id": "5458283", "Score": "20", "CreationDate": "2011-03-28T11:25:10.867", "LastActivityDate": "2011-03-28T12:44:06.910"}, "5459720": {"ParentId": "5458204", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Are you really iterating down from some number greater than <code>std::numeric_limits&lt;int&gt;::max()</code>? If not, I would actually suggest just using a normal <code>int</code> as your loop variable and <code>static_cast</code> it to <code>unsigned</code> in the places in your code that expect it to be unsigned. This way you can use the intuitive <code>&gt;= 0</code> or <code>&gt; -1</code> condition and in general I would expect it to be more readable than any of the unsigned alternatives.</p>\n<p>The <code>static_cast</code> would just be to tell the compiler how to operate on the variable and have no performance implications at all.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2014-11-06T15:22:44.843", "Id": "5459720", "Score": "2", "CreationDate": "2011-03-28T13:31:46.760", "LastActivityDate": "2014-11-06T15:22:44.843"}, "5458404": {"ParentId": "5458204", "CommentCount": "1", "Body": "<p>I can think the two options are either cast or singed numbers (can be done implicitly be comparing to -1, for example) or use the loop condition to check for overflow like this:</p>\n<pre><code>for(unsigned i=10;i&gt;i-1;--i){ } // i = 10, 9, ... , 1\nfor(unsigned i=10;i+1&gt;i;--i){ } // i = 10, 9, ... , 1,0\n</code></pre>\n<p>This loop will continue until i overflows (meaning that it reached zero). Note that is important that i iterates by 1, or you might end-up with an infinite loop.</p>\n", "OwnerUserId": "672872", "PostTypeId": "2", "Id": "5458404", "Score": "1", "CreationDate": "2011-03-28T11:36:22.980", "LastActivityDate": "2011-03-28T11:36:22.980"}, "44205064": {"ParentId": "5458204", "CommentCount": "0", "Body": "<p>One more way:</p>\n<pre><code>for(unsigned i = n-1; i &lt; n ; --i) \n{       \n    // Iterates from n-1 to 0\n}\n</code></pre>\n<p>Simillarly for <strong><em>size_t</em></strong> (unsigned integer type) use the same trick</p>\n<pre><code>for(std::size_t i = n-1; i &lt; n ; --i) \n{       \n    // Iterates from n-1 to 0\n}\n</code></pre>\n", "OwnerUserId": "1308589", "PostTypeId": "2", "Id": "44205064", "Score": "0", "CreationDate": "2017-05-26T15:20:12.153", "LastActivityDate": "2017-05-26T15:20:12.153"}, "bq_ids": {"n4140": {"so_5458204_5458251_0": {"section_id": 31, "quality": 1.0, "length": 18}, "so_5458204_5458251_1": {"section_id": 7213, "quality": 0.875, "length": 14}}, "n3337": {"so_5458204_5458251_0": {"section_id": 28, "quality": 1.0, "length": 18}, "so_5458204_5458251_1": {"section_id": 6957, "quality": 1.0, "length": 16}}, "n4659": {"so_5458204_5458251_0": {"section_id": 31, "quality": 1.0, "length": 18}, "so_5458204_5458251_1": {"section_id": 8722, "quality": 0.875, "length": 14}}}, "5458323": {"ParentId": "5458204", "CommentCount": "0", "Body": "<pre><code>for(unsigned i = x ; i != 0 ; i--){ ...\n</code></pre>\n<p>And if you want to execute the loop body when i == 0 and stop after that. Just start with <code>i = x+1;</code></p>\n<p>BTW, why i must be unsigned ?</p>\n", "OwnerUserId": "282815", "PostTypeId": "2", "Id": "5458323", "Score": "1", "CreationDate": "2011-03-28T11:29:04.447", "LastActivityDate": "2011-03-28T11:29:04.447"}, "5458204": {"CommentCount": "8", "AcceptedAnswerId": "5458283", "PostTypeId": "1", "LastEditorUserId": "431528", "CreationDate": "2011-03-28T11:18:37.203", "LastActivityDate": "2017-05-26T15:20:12.153", "LastEditDate": "2011-03-28T11:33:18.097", "ViewCount": "5685", "FavoriteCount": "10", "Title": "Unsigned int reverse iteration with for loops", "Id": "5458204", "Score": "24", "Body": "<p>I want the iterator variable in a for loop to reverse iterate to 0 as an <code>unsigned int</code>, and I cannot think of a similar comparison to <code>i &gt; -1</code>, as you would do if it was a <code>signed int</code>. </p>\n<pre><code>for (unsigned int i = 10; i &lt;= 10; --i) { ... }\n</code></pre>\n<p>But this seems very unclear, as it is relying on the numerical overflow of the unsigned integer to be above 10. </p>\n<p>Maybe I just don't have a clear head, but whats a better way to do this...</p>\n<p><strong>Disclaimer:</strong> this is just a simple use case, the upper limit of 10 is trivial, it could be anything, and <code>i</code> must be an <code>unsigned int</code>. </p>\n", "Tags": "<c++><loops><for-loop><overflow><iteration>", "OwnerUserId": "431528", "AnswerCount": "10"}, "5458251": {"ParentId": "5458204", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The following does what you want:</p>\n<pre><code>for (unsigned i = 10; i != static_cast&lt;unsigned&gt;(-1); --i)\n{\n    // ...\n}\n</code></pre>\n<p>This is <strong>perfectly defined</strong> and actually works. Arithmetic on signed types is accurately defined by the standard. Indeed:</p>\n<p>From <strong>4.7/2</strong> (regarding casting to an unsigned type):</p>\n<blockquote>\n<p id=\"so_5458204_5458251_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2^n where n is the number of bits used to represent the unsigned type)</p>\n</blockquote>\n<p>and <strong>3.9.1/4</strong></p>\n<blockquote>\n<p id=\"so_5458204_5458251_1\">Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2^n where n is the number of bits in the value representation of that particular size of integer</p>\n</blockquote>\n", "OwnerUserId": "373025", "LastEditorUserId": "373025", "LastEditDate": "2011-03-28T11:34:56.850", "Id": "5458251", "Score": "10", "CreationDate": "2011-03-28T11:22:58.597", "LastActivityDate": "2011-03-28T11:34:56.850"}, "5460181": {"ParentId": "5458204", "CommentCount": "0", "Body": "<p>Just:</p>\n<pre><code>int start = 10;\nfor(unsigned int iPlus1 = start + 1 ; iPlus1 &gt; 0 ; iPlus1--) {\n  // use iPlus1 - 1 if you need (say) an array index\n  a[iPlus1 - 1] = 123; // ...\n}\n</code></pre>\n<p>No?</p>\n", "OwnerUserId": "240837", "PostTypeId": "2", "Id": "5460181", "Score": "0", "CreationDate": "2011-03-28T14:08:02.027", "LastActivityDate": "2011-03-28T14:08:02.027"}});