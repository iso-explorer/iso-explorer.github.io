post_cb({"3631672": {"CommentCount": "0", "AcceptedAnswerId": "3631724", "PostTypeId": "1", "LastEditorUserId": "252000", "CreationDate": "2010-09-02T22:12:22.870", "LastActivityDate": "2010-11-22T00:39:55.190", "LastEditDate": "2010-11-22T00:39:55.190", "ViewCount": "1036", "FavoriteCount": "1", "Title": "ADL and friend injection", "Id": "3631672", "Score": "6", "Body": "<p>Consider this code:</p>\n<pre><code>template &lt;int N&gt;\nstruct X\n{\n friend void f(X *) {}\n};\n\nint main()\n{\n f((X&lt;0&gt; *)0); // Error?\n}\n</code></pre>\n<p>compilers seem to heavily disagree. (MSVC08/10 says no, GCC&lt;4.5 says yes, but 4.5 says no, sun 5.1 says yes, intel 11.1 says yes too but comeau says no (both are EDG)).</p>\n<p>According to \"C++ Templates - The complete guide\": </p>\n<blockquote>\n<p id=\"so_3631672_3631672_0\">... it is assumed that a call\n  involving a lookup for friends in\n  associated classes actually causes the\n  class to be instantiated ... Although\n  this was clearly intended by those who\n  wrote the C++ standard, it is not\n  clearly spelled out in the standard.</p>\n</blockquote>\n<p>I couldn't find the relevant section in the standard. Any reference?</p>\n<p>Consider this variation:</p>\n<pre><code>template &lt;int N&gt;\nstruct X\n{\n template &lt;int M&gt;\n friend void f(X&lt;M&gt; *) {}\n};\n\ntemplate &lt;&gt;\nstruct X&lt;0&gt;\n{\n};\n\nint main()\n{\n X&lt;1&gt;();\n f((X&lt;0&gt; *)0); // Error?\n}\n</code></pre>\n<p>The key issue here is wether the viable function injected by <code>X&lt;1&gt;</code> should be visible during ADL for <code>X&lt;0&gt;</code>? Are they associated? All compilers mentioned above accept this code, except for Comeau which only accepts it in relaxed mode. Not sure what the standard has to say about this either.</p>\n<p>What's your take on that?</p>\n", "Tags": "<c++><templates><friend-function><argument-dependent-lookup>", "OwnerUserId": "366240", "AnswerCount": "1"}, "3631724": {"ParentId": "3631672", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The Standard says at <code>14.7.1/4</code></p>\n<blockquote>\n<p id=\"so_3631672_3631724_0\">A class template specialization is implicitly instantiated if the class type is used in a context that requires a completely-defined object type or if the completeness of the class type affects the semantics of the program; in particular, if an expression whose type is a class template specialization is involved in overload resolution, pointer conversion, pointer to member conversion, the class template specialization is implicitly instantiated (3.2);</p>\n</blockquote>\n<p>Note that Vandervoorde made an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#34\" rel=\"nofollow noreferrer\">issue report here</a>, and the committee found</p>\n<blockquote>\n<p id=\"so_3631672_3631724_1\">The standard already specifies that this creates a point of instantiation.</p>\n</blockquote>\n<p>For your second case - you need to consider the associated classes and namespaces of the argument <code>f(X&lt;0&gt;*)</code>. These are, since this is a pointer to a class template specialization (note that \"template-id\" below is not quite correct - C++0x corrected that to use the correct term) and also a pointer to a class (this confusing split was also corrected in C++0x - it lists these two cases in one bullet point).</p>\n<blockquote>\n<ul>\n<li><p id=\"so_3631672_3631724_2\">If T is a template-id, its associated namespaces and classes are the namespace in which the template is\n  defined; [... lots of noise ...]</p></li>\n<li><p id=\"so_3631672_3631724_3\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces in which its associated classes are defined.</p></li>\n</ul>\n</blockquote>\n<p>So to summary, we have as associated classes are <code>X&lt;0&gt;</code> and the associated namespaces are the global namespace. Now the friend functions that are visible are</p>\n<blockquote id=\"so_3631672_3631724_4\">\n<ul>\n<li>Any namespace-scope friend functions declared in associated classes are visible within their respective namespaces even if they are not visible during an ordinary lookup</li>\n</ul>\n</blockquote>\n<p>There is no friend function declared in <code>X&lt;0&gt;</code> so the friend function declaration is not visible when looking into the global namespace. Note that <code>X&lt;0&gt;</code> is an entirely different class-type than <code>X&lt;1&gt;</code>. The implicit instantiation of <code>X&lt;1&gt;</code> you do there has no effect on this call - it just adds a non-visible name into the global namespace that refers to a friend function of class <code>X&lt;1&gt;</code>. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-09-02T22:33:17.403", "Id": "3631724", "Score": "4", "CreationDate": "2010-09-02T22:20:02.203", "LastActivityDate": "2010-09-02T22:33:17.403"}, "bq_ids": {"n4140": {"so_3631672_3631724_3": {"section_id": 7104, "quality": 0.9583333333333334, "length": 23}, "so_3631672_3631724_0": {"section_id": 238, "quality": 0.6756756756756757, "length": 25}, "so_3631672_3631724_4": {"section_id": 7106, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_3631672_3631724_2": {"section_id": 6848, "quality": 0.6, "length": 6}, "so_3631672_3631724_3": {"section_id": 6848, "quality": 1.0, "length": 24}, "so_3631672_3631724_0": {"section_id": 230, "quality": 0.6756756756756757, "length": 25}, "so_3631672_3631724_4": {"section_id": 6850, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_3631672_3631724_3": {"section_id": 8605, "quality": 0.9583333333333334, "length": 23}, "so_3631672_3631724_0": {"section_id": 242, "quality": 0.6756756756756757, "length": 25}, "so_3631672_3631724_4": {"section_id": 8607, "quality": 0.9444444444444444, "length": 17}}}});