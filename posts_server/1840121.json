post_cb({"1840182": {"ParentId": "1840121", "CommentCount": "1", "Body": "<p>C++ Standard ISO/IEC 14882:2003</p>\n<blockquote>\n<p id=\"so_1840121_1840182_0\"><strong>25.3.1.1 sort</strong></p>\n<pre><code>template&lt;class RandomAccessIterator&gt;\n   void sort(RandomAccessIterator first, RandomAccessIterator last);\ntemplate&lt;class RandomAccessIterator, class Compare&gt;\n   void sort(RandomAccessIterator first, RandomAccessIterator last,\n          Compare comp);\n</code></pre>\n<p id=\"so_1840121_1840182_1\">1 <strong>Effects</strong>: Sorts the elements in the\n  range [first, last). </p>\n<p id=\"so_1840121_1840182_2\">2 <strong>Complexity</strong>:\n  Approximately N log N (where N == last\n  - first) comparisons on the average. </p>\n</blockquote>\n<p>There is no information about method but <em>complexity</em> is always <code>N log N</code>.</p>\n", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "1840182", "Score": "9", "CreationDate": "2009-12-03T14:26:56.290", "LastActivityDate": "2009-12-03T14:26:56.290"}, "1840121": {"CommentCount": "3", "AcceptedAnswerId": "1840131", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2009-12-03T14:17:20.350", "LastActivityDate": "2017-09-01T13:49:36.157", "LastEditDate": "2016-08-28T08:28:11.633", "ViewCount": "4061", "FavoriteCount": "2", "Title": "Which type of sorting is used in the std::sort()?", "Id": "1840121", "Score": "20", "Body": "<p>Can anyone please tell me that which type of sorting technique (bubble, insertion, selection, quick, merge, count...) is implemented in the <code>std::sort()</code> function defined in the <code>&lt;algorithm&gt;</code> header file?</p>\n", "Tags": "<c++><sorting><stl>", "OwnerUserId": "172543", "AnswerCount": "6"}, "32230449": {"ParentId": "1840121", "CommentCount": "0", "Body": "<p>Just some empirical results:</p>\n<p>I translated a python script using numpy 1.9.2 sort to C++ using std::sort (VS2008 toolchain).</p>\n<p>I only get the same exact results in the python and C++ sides when I use numpy.sort argument kind='mergesort'. I get different relative ordering for elements with same key when kind='quicksort' or kind='heapsort'. So I guess that at least for the version of STL that comes with VS2008 std::sort uses mergesort.</p>\n", "OwnerUserId": "874829", "PostTypeId": "2", "Id": "32230449", "Score": "0", "CreationDate": "2015-08-26T15:15:26.173", "LastActivityDate": "2015-08-26T15:15:26.173"}, "33141984": {"ParentId": "1840121", "CommentCount": "0", "Body": "<p>There are three algorithms that are used in MSVC2013 STL, referring to the source code of <code>std::sort</code>.</p>\n<blockquote>\n<p id=\"so_1840121_33141984_0\">It is most likely to use <code>QuickSort</code>, or a variation over <code>QuickSort</code> called <code>IntroSort</code>.</p>\n<p id=\"so_1840121_33141984_1\">If the recursion goes too deep, the <code>HeapSort</code> will be used here.</p>\n<p id=\"so_1840121_33141984_2\">Otherwise <code>InsertSort</code> will be used.</p>\n</blockquote>\n", "OwnerUserId": "3011380", "PostTypeId": "2", "Id": "33141984", "Score": "4", "CreationDate": "2015-10-15T07:04:43.113", "LastActivityDate": "2015-10-15T07:04:43.113"}, "1840142": {"ParentId": "1840121", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Do you mean std::sort?  If so it can be implemented any way they want.  Its probably Quick sort but could be radix or something else.  As long as it produces you a sorted list in at least O(n log n) the implementation is fine, afaik.</p>\n", "OwnerUserId": "131140", "LastEditorUserId": "131140", "LastEditDate": "2009-12-03T14:31:13.067", "Id": "1840142", "Score": "0", "CreationDate": "2009-12-03T14:20:09.470", "LastActivityDate": "2009-12-03T14:31:13.067"}, "1840131": {"ParentId": "1840121", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Most implementations of <code>std::sort</code> use quicksort, (or usually a hybrid algorithm like introsort, which combines quicksort, heapsort and insertion sort).</p>\n<p>The only thing the standard requires is that <code>std::sort</code> somehow sort the data according to the specified ordering with a complexity of approximately O(N log(N)); it is not guaranteed to be stable.  Technically, introsort better meets the complexity requirement than quicksort, because quicksort has quadratic worst-case time.</p>\n", "OwnerUserId": "168288", "LastEditorUserId": "168288", "LastEditDate": "2013-06-02T03:34:59.203", "Id": "1840131", "Score": "22", "CreationDate": "2009-12-03T14:18:11.737", "LastActivityDate": "2013-06-02T03:34:59.203"}, "bq_ids": {"n4140": {"so_1840121_1840182_1": {"section_id": 1286, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_1840121_1840182_1": {"section_id": 1281, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_1840121_1840182_1": {"section_id": 1409, "quality": 0.6666666666666666, "length": 4}}}, "45998880": {"ParentId": "1840121", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Probably all implementations of <code>std::sort</code> use <em>introsort</em> (aka <em>introspection sort</em>), a hybrid algorithm that combines quicksort and heapsort. Actually, <em>introsort</em> was particularly invented in 1997 for the purpose of a performant sort implemenation in C++ STL.</p>\n<p>The only thing the standard requires is that <code>std::sort</code> somehow sort the data according to the specified ordering with a complexity of <em>O(N log(N))</em>; it is not guaranteed to be stable (there is a separate <code>std::stable_sort</code> algorithms available, if this should be required).</p>\n<p>Technically, introsort better meets the complexity requirement than quicksort: This is because heapsort has guaranteed <em>O(N log(N))</em> complexity in the worst case, whereas quicksort has quadratic worst-case time.</p>\n<p>However, heapsort is 'slower' than quicksort in the average case, in the sense that heapsort performs <em>C*N log(N)</em> whereas quicksort has <em>D*N log(n)</em> performance, with <em>D</em> being significantly smaller than <em>C</em> (the numbers <em>C</em> and <em>D</em> are constants). In other words, the per-comparison-overhead of heapsort is higher than the one of quicksort.</p>\n<p>To get the best of both worlds, introsort starts with quicksort \u2014a recursive algorithm\u2014, but when recursion depth gets too high (which means it gets into a <em>degenerated</em> worst-case behaviour), it switches to heapsort.</p>\n<p>See also <a href=\"https://en.wikipedia.org/wiki/Introsort\" rel=\"nofollow noreferrer\">the Wikipedia entry for introsort</a> or the <a href=\"http://www.cs.rpi.edu/~musser/gp/introsort.ps\" rel=\"nofollow noreferrer\">original paper</a> from David Musser, who invented introsort particularly for STL.</p>\n", "OwnerUserId": "1885002", "LastEditorUserId": "1885002", "LastEditDate": "2017-09-01T13:49:36.157", "Id": "45998880", "Score": "1", "CreationDate": "2017-09-01T11:03:56.640", "LastActivityDate": "2017-09-01T13:49:36.157"}});