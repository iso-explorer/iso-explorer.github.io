post_cb({"25874409": {"CommentCount": "4", "ViewCount": "78", "PostTypeId": "1", "LastEditorUserId": "315052", "CreationDate": "2014-09-16T16:54:27.120", "LastActivityDate": "2014-09-18T03:32:18.817", "Title": "Confusion over argument dependent lookup and friend function definition", "AcceptedAnswerId": "25903351", "LastEditDate": "2014-09-16T17:05:48.260", "Id": "25874409", "Score": "0", "Body": "<p>I have the following program:</p>\n<pre><code>struct Foo {\n    friend void foo (int) {}\n    operator int () const { return 0; }\n};\n\nint main() {\n    foo(Foo());  // This compiles fine\n    foo(0);      // This fails to find `foo()`\n    return 0;\n}\n</code></pre>\n<p>I could not figure out what part of the standard defines the ADL rule that says the call to <code>foo(0)</code> should fail, while the call to <code>foo(Foo())</code> should succeed. Can someone shed some light?</p>\n", "Tags": "<c++><c++11><language-lawyer><argument-dependent-lookup>", "OwnerUserId": "315052", "AnswerCount": "2"}, "25903737": {"ParentId": "25874409", "CommentCount": "1", "Body": "<p>Looking at your code:</p>\n<pre><code>int main() {\n    foo(Foo());  // This declares a global function \"foo\" taking a \"Foo\" as an argument\n    foo(0);      // \"foo\" takes a \"Foo\" above, and theres no way to convert an int to a Foo...\n</code></pre>\n", "OwnerUserId": "16406", "PostTypeId": "2", "Id": "25903737", "Score": "0", "CreationDate": "2014-09-18T03:32:18.817", "LastActivityDate": "2014-09-18T03:32:18.817"}, "25903351": {"ParentId": "25874409", "CommentCount": "0", "Body": "<p>Reopened over my own deletion, eh? Well, after some prompting from juanchopanza, I read over the relevant part of the standard, C++11 \u00a73.4.2, more carefully. I browsed it way too quickly before. To wit, paragraph 2 spells out:</p>\n<blockquote>\n<p id=\"so_25874409_25903351_0\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument). Typedef names and <em>using-declarations</em> used to specify the types do not contribute to this set. The sets of namespaces and classes are determined in the following way:</p>\n<ul>\n<li>If T is a fundamental type, its associated sets of namespaces and classes are both empty.</li>\n<li>If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces of which its associated classes are members. Furthermore, if T is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters (excluding template template parameters); the namespaces of which any template template arguments are members; and the classes of which any member templates used as template template arguments are members.</li>\n</ul>\n<p id=\"so_25874409_25903351_1\">...</p>\n</blockquote>\n<p>The first bullet explains why passing in an <code>int</code> argument fails. The second bullet explains why passing in a <code>Foo</code> instance works.</p>\n", "OwnerUserId": "315052", "PostTypeId": "2", "Id": "25903351", "Score": "1", "CreationDate": "2014-09-18T02:42:13.757", "LastActivityDate": "2014-09-18T02:42:13.757"}, "bq_ids": {"n4140": {"so_25874409_25903351_0": {"section_id": 7104, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_25874409_25903351_0": {"section_id": 6848, "quality": 0.9318181818181818, "length": 41}}, "n4659": {"so_25874409_25903351_0": {"section_id": 8605, "quality": 0.8409090909090909, "length": 37}}}});