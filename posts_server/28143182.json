post_cb({"28143182": {"CommentCount": "5", "AcceptedAnswerId": "28143328", "PostTypeId": "1", "ClosedDate": "2015-01-26T01:25:04.547", "LastEditorUserId": "2069064", "CreationDate": "2015-01-26T00:19:39.467", "LastActivityDate": "2015-01-26T01:20:53.893", "LastEditDate": "2015-01-26T00:25:11.387", "ViewCount": "435", "FavoriteCount": "1", "Title": "How C++ compiler knows the length of an array", "Id": "28143182", "Score": "3", "Body": "<p>For example, in the main function, I can write <code>int arr[42]</code>, and I can use range for loop without indicating its length <code>for (auto i : arr)</code>. It works well. Compiler will know its length.</p>\n<p>If I pass this array to another function, such as <code>void foo(int arr[])</code>, I cannot use range for loop because the compiler doesn't know its length.</p>\n<p>After all, if I have this template <code>template&lt;class T, size_t N&gt; void arr_init(T (&amp;foo)[N])</code>, I can call it by <code>arr_init(x)</code>. Obviously, the compiler calls <code>arr_init(int (&amp;)[42])</code>.</p>\n<p>I guess the compiler knows the length of array through its declaration <code>int[42]</code>. Am I right? I've got this question when I use range for loop and learn templates. I haven't met such problem before, when I was using C.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4133517", "AnswerCount": "3"}, "28143449": {"ParentId": "28143182", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-01-26T01:02:11.047", "Score": "0", "LastEditorUserId": "3093378", "LastEditDate": "2015-01-26T01:20:53.893", "Id": "28143449", "OwnerUserId": "3093378", "Body": "<p>Whenever you pass an array by reference, you can deduce it's size (remember that arrays <strong>are not pointers</strong>). So the functions <code>std::begin()</code> and <code>std::end()</code>, which are used by the range-based for, are probably overloaded like this for arrays</p>\n<pre><code>namespace std\n{\n    template&lt;typename T, std::size_t N&gt;\n    T* std::begin(T (&amp;arr)[N])\n    {\n        return arr;\n    }\n\n    template&lt;typename T, std::size_t N&gt;\n    T* std::end(T (&amp;arr)[N])\n    {\n        return arr + N;\n    }\n}\n</code></pre>\n<p>Arrays decay to pointers only when passed by value, like</p>\n<pre><code>void f(int arr[256]){...}\n</code></pre>\n<p>which is syntactic sugar for</p>\n<pre><code>void f(int* arr){...}\n</code></pre>\n<p>PS: it looks like the range-based <code>for</code> doesn't use <code>std::begin</code> and <code>std::end</code>, since the compiler knows the size of the array at compile time (as mentioned by @T.C.). So the above code is just for demonstration purposes ;) </p>\n<p>See <strong>6.5.4</strong> of the standard for more details about the range-based <code>for</code>:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_28143182_28143449_1\">In each case, a range-based for statement is equivalent to</p>\n</blockquote>\n</blockquote>\n<pre><code>    {\n       auto &amp;&amp; __range = range-init;\n       for ( auto __begin = begin-expr,\n                  __end = end-expr;\n             __begin != __end;\n              ++__begin ) { \n           for-range-declaration = *__begin; \n           statement\n       } \n    }\n</code></pre>\n<blockquote>\n<p id=\"so_28143182_28143449_2\"><strong>6.4.3/1</strong> if _RangeT is an array type, <em>begin-expr</em> and <em>end-expr</em> are <em>__range</em> and <em>__range + __bound</em>, respectively, where <em>__bound</em> is the array bound. If <em>_RangeT</em> is an array of unknown size or an array of incomplete type, the program is ill-formed;</p>\n</blockquote>\n", "LastActivityDate": "2015-01-26T01:20:53.893"}, "28143328": {"ParentId": "28143182", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-01-26T00:42:55.347", "Score": "2", "LastEditorUserId": "862351", "LastEditDate": "2015-01-26T01:18:13.347", "Id": "28143328", "OwnerUserId": "862351", "Body": "<p>The array type <code>T[N]</code> is distinct from the array type <code>T[M]</code> for a type <code>T</code> and two distinct sizes <code>N</code> and <code>M</code>. So, the length of an array is built into the type.</p>\n<p>OTOH, arrays are automatically <a href=\"http://en.cppreference.com/w/cpp/language/array#Array_to_pointer_decay\" rel=\"nofollow\">decayed</a> to pointers in a function calls argument list. In other words, there is no distinction between these three function signatures:</p>\n<pre><code>int func(int []);\nint func(int[5]);\nint func(int[10]);\nint func(int*);\n</code></pre>\n<p>All the above signatures are simply taking an <code>int*</code>. If you want to preserve the array type, you need to create a function which takes an array reference as an argument. That is exactly what you achieve in your example <code>template&lt;class T, size_t N&gt; void arr_init(T (&amp;foo)[N])</code>. Inside <code>arr_init</code>, <code>foo</code> behaves like an array because it is a reference to an array type.</p>\n<p>For an array <code>arr</code> of type <code>T[N]</code>, the <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow\">range-based <code>for</code></a> uses the expressions <code>arr</code> and <code>arr+N</code> as the start and end points, respectively.</p>\n<p>For class types, member functions <code>begin</code> and <code>end</code>, if present, are used to determine the endpoints, failing which the non-member overloads, <code>begin</code> and <code>end</code> are used.</p>\n<p>(<code>begin</code> and <code>end</code>, as opposed to <code>std::begin</code> and <code>std::end</code>, since the generic usage of <code>begin</code> and <code>end</code> in the standard library is like this:</p>\n<pre><code>using std::begin;\nbegin(...);\nusing std::end;\nend(...);\n</code></pre>\n<p>This allows ADL to find user-defined <code>begin</code> and <code>end</code> overloads.)</p>\n", "LastActivityDate": "2015-01-26T01:18:13.347"}, "bq_ids": {"n4140": {"so_28143182_28143449_0": {"section_id": 3906, "quality": 1.0, "length": 5}, "so_28143182_28143449_1": {"section_id": 3906, "quality": 1.0, "length": 5}, "so_28143182_28143449_2": {"section_id": 3906, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_28143182_28143449_0": {"section_id": 3766, "quality": 1.0, "length": 5}, "so_28143182_28143449_1": {"section_id": 3766, "quality": 1.0, "length": 5}, "so_28143182_28143449_2": {"section_id": 3766, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_28143182_28143449_2": {"section_id": 4792, "quality": 0.7272727272727273, "length": 16}}}, "28143216": {"ParentId": "28143182", "CommentCount": "2", "CreationDate": "2015-01-26T00:25:18.950", "OwnerUserId": "242814", "PostTypeId": "2", "Id": "28143216", "Score": "1", "Body": "<p>Yes, you're right. This is because the compiler knows the size of objects defined in the same translation unit.</p>\n<p>In fact, you don't need to use a range for loop to see similar behavior; you can use plain <code>sizeof</code>.</p>\n<p>foo.c:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nextern int a[];\n\nint main()\n{\n    printf(\"%d\\n\", sizeof(a));\n}\n</code></pre>\n<p>bar.c:</p>\n<pre><code>int a[50];\n</code></pre>\n<p>Now to test:</p>\n<pre><code>gcc foo.c bar.c\n&gt; foo.c: In function 'main':\n&gt; foo.c:7:23: error: invalid application of 'sizeof' to incomplete type 'int[]' \n</code></pre>\n", "LastActivityDate": "2015-01-26T00:25:18.950"}});