post_cb({"15938077": {"CommentCount": "11", "AcceptedAnswerId": "15956145", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-10T23:07:39.200", "LastActivityDate": "2013-04-14T14:38:13.670", "LastEditDate": "2017-05-23T12:16:00.387", "ViewCount": "2024", "FavoriteCount": "2", "Title": "To what extent is C++ a statically-typed language?", "Id": "15938077", "Score": "21", "Body": "<p>I used to think that the answer to this question was \"<em>100%</em>\", but I've recently been pointed to an example that makes it worth thinking twice. Consider a C array declared as an object with automatic storage duration:</p>\n<pre><code>int main()\n{\n    int foo[42] = { 0 };\n}\n</code></pre>\n<p>Here, the type of <code>foo</code> is clearly <code>int[42]</code>. Consider, instead, this case:</p>\n<pre><code>int main()\n{\n    int* foo = new int[rand() % 42];\n    delete[] foo;\n}\n</code></pre>\n<p>Here, the type of <code>foo</code> is <code>int*</code>, but how can one tell the type of the <strong>object created by the <code>new</code> expression</strong> at compile-time? (Emphasis is meant to stress the fact that I am not talking about the pointer returned by the <code>new</code> expression, but rather about the <em>array object</em> created by the <code>new</code> expression).</p>\n<p>This is what Paragraph 5.3.4/1 of the C++11 Standard specifies about the result of a <code>new</code> expression:</p>\n<blockquote>\n<p id=\"so_15938077_15938077_0\">[...] Entities created by a <em>new-expression</em> have dynamic storage duration (3.7.4). [ Note: the lifetime of such\n  an entity is not necessarily restricted to the scope in which it is created. \u2014end note ] If the entity is a non-array\n  object, the <em>new-expression</em> returns a pointer to the object created. If it is an array, the <em>new-expression</em>\n  returns a pointer to the initial element of the array.</p>\n</blockquote>\n<p>I used to think that in C++ the type of all objects is determined at compile-time, but the above example seems to disprove that belief. Also, per Paragraph 1.8/1:</p>\n<blockquote>\n<p id=\"so_15938077_15938077_1\">[...] The properties of an object are determined <strong>when the object\n  is created</strong>. An object can have a name (Clause 3). An object has a storage duration (3.7) which influences\n  its lifetime (3.8). An object has a type (3.9). [...]</p>\n</blockquote>\n<p>So my questions are:</p>\n<ol>\n<li>What is meant by \"<em>properties</em>\" in the last quoted paragraph? Clearly, the name of an object cannot count as something which is determined \"<em>when the object is created</em>\"- unless \"<em>created</em>\" here means something different than I think;</li>\n<li>Are there other examples of objects whose type is determined only at run-time?</li>\n<li>To what extent is it correct to say that C++ is a statically-typed language? Or rather, what is the most proper way of classifying C++ in this respect?</li>\n</ol>\n<p>It would be great if anybody could elaborate at least on one of the above points.</p>\n<p><strong>EDIT:</strong></p>\n<p>The Standard seems to make it clear that the <code>new</code> expression does indeed create an <strong>array object</strong>, and not just several objects laid out as an array as pointed out by some. Per Paragraph 5.3.4/5 (courtesy of <a href=\"https://stackoverflow.com/users/500104/xeo\">Xeo</a>):</p>\n<blockquote>\n<p id=\"so_15938077_15938077_2\"><strong>When the allocated object is an array</strong> (that is, the <em>noptr-new-declarator</em> syntax is used or the <em>new-type-id</em> or\n  <em>type-id</em> denotes an array type), the new-expression yields a pointer to the initial element (if any) of the array.\n  [ Note: both <code>new int</code> and <code>new int[10]</code> have type <code>int*</code> and the type of <code>new int[i][10]</code> is <code>int (*)[10]</code>\n  \u2014end note ] The <em>attribute-specifier-seq</em> in a <em>noptr-new-declarator</em> appertains <strong>to the associated array type</strong>.</p>\n</blockquote>\n", "Tags": "<c++><c++11><language-lawyer><static-typing><dynamic-typing>", "OwnerUserId": "1932150", "AnswerCount": "3"}, "15956145": {"ParentId": "15938077", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-04-11T18:27:21.543", "Score": "8", "LastEditorUserId": "365496", "LastEditDate": "2013-04-14T14:38:13.670", "Id": "15956145", "OwnerUserId": "365496", "Body": "<p>The terms 'static type' and 'dynamic type' apply to expressions.</p>\n<blockquote>\n<p id=\"so_15938077_15956145_0\"><strong>static type</strong></p>\n<p id=\"so_15938077_15956145_1\">type of an expression (3.9) resulting from analysis of the program without considering execution semantics</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<p id=\"so_15938077_15956145_2\"><strong>dynamic type</strong></p>\n<p id=\"so_15938077_15956145_3\">&lt;glvalue&gt; type of the most derived object (1.8) to which the glvalue denoted by a glvalue expression refers</p>\n</blockquote>\n<p>Additionally, you can see that a dynamic type only differs from a static type when the static type can be derived from, which means a dynamic array type is always the same as the expression's static type. </p>\n<p>So your question:</p>\n<blockquote>\n<p id=\"so_15938077_15956145_4\">but how can one tell the type of the object created by the new expression at compile-time?</p>\n</blockquote>\n<p>Objects have types, but they're not 'static' or 'dynamic' types absent an expression that refers to the object. Given an expression, the static type is always known at compile time. In the absence of derivation the dynamic type is the same as the static type.</p>\n<p>But you're asking about objects' types independent of expressions. In the example you give you've asked for an object to be created but you don't specify the type of object you want to have created at compile time. You can look at it like this:</p>\n<pre><code>template&lt;typename T&gt;\nT *create_array(size_t s) {\n    switch(s) {\n        case 1: return &amp;(*new std::array&lt;T, 1&gt;)[0];\n        case 2: return &amp;(*new std::array&lt;T, 2&gt;)[0];\n        // ...\n    }\n}\n</code></pre>\n<p>There's little special or unique about this. Another possibility is:</p>\n<pre><code>struct B { virtual ~B() {}};\nstruct D : B {};\nstruct E : B {};\n\nB *create() {\n    if (std::bernoulli_distribution(0.5)(std::default_random_engine())) {\n        return new D;\n    }\n    return new E;\n}\n</code></pre>\n<p>Or:</p>\n<pre><code>void *create() {\n    if (std::bernoulli_distribution(0.5)(std::default_random_engine())) {\n        return reinterpret_cast&lt;void*&gt;(new int);\n    }\n    return reinterpret_cast&lt;void*&gt;(new float);\n}\n</code></pre>\n<p>The only difference with <code>new int[]</code> is that you can't see into its implementation to see it selecting between different types of objects to create.</p>\n", "LastActivityDate": "2013-04-14T14:38:13.670"}, "15938128": {"ParentId": "15938077", "PostTypeId": "2", "CommentCount": "23", "CreationDate": "2013-04-10T23:11:58.333", "Score": "9", "LastEditorUserId": "103167", "LastEditDate": "2013-04-11T16:09:29.903", "Id": "15938128", "OwnerUserId": "103167", "Body": "<p>The <em>new-expression</em> doesn't create an object with runtime-varying array type.  It creates many objects, each of static type <code>int</code>.  The number of these objects is not known statically.</p>\n<hr>\n<p>C++ provides two cases (section 5.2.8) for dynamic type:</p>\n<ul>\n<li>Same as the static type of the expression</li>\n<li>When the static type is polymorphic, the runtime type of the most-derived object</li>\n</ul>\n<p>Neither of these gives any object created by <code>new int[N]</code> a dynamic array type.</p>\n<hr>\n<p>Pedantically, evaluation of the <em>new-expression</em> creates an infinite number of overlapping array objects.  From 3.8p2:</p>\n<blockquote>\n<p id=\"so_15938077_15938128_0\">[ Note: The lifetime of an array object starts as soon as storage with proper size and alignment is obtained, and its lifetime ends when the storage which the array occupies is reused or released. 12.6.2 describes the lifetime of base and member subobjects. \u2014 end note ]</p>\n</blockquote>\n<p>So if you want to talk about the \"array object\" created by <code>new int[5]</code>, you have to give it not only type <code>int[5]</code> but also <code>int[4]</code>, <code>int[1]</code>, <code>char[5*sizeof(int)]</code>, and <code>struct s { int x; }[5]</code>.</p>\n<p>I submit that this is equivalent to saying that array types do not exist at runtime.  The <em>type</em> of an object is supposed to be restrictive, information, and tell you something about its properties.  Allowing a memory area to be treated as an infinite number of overlapping array objects with different type in effect means that the array object is completely typeless.  The notion of runtime type only makes sense for the element objects stored within the array.</p>\n</hr></hr>", "LastActivityDate": "2013-04-11T16:09:29.903"}, "15938135": {"ParentId": "15938077", "CommentCount": "8", "CreationDate": "2013-04-10T23:13:09.527", "OwnerUserId": "82320", "PostTypeId": "2", "Id": "15938135", "Score": "2", "Body": "<blockquote>\n<p id=\"so_15938077_15938135_0\">I used to think that in C++ the type of all objects is determined at compile-time, but the above example seems to disprove that belief.</p>\n</blockquote>\n<p>The example you cite is talking about storage duration of the item. C++ recognizes three storage durations:</p>\n<ol>\n<li>Static storage duration is the duration of global and local static variables.</li>\n<li>Automatic storage duration is the duration for \"stack allocated\" function-local variables.</li>\n<li>Dynamic storage duration is the duration for dynamically allocated memory such as that with <code>new</code> or <code>malloc</code>.</li>\n</ol>\n<p>The use of the word \"dynamic\" here has nothing to do with the object's type. It refers to how an implementation must store the data that makes up an object.</p>\n<blockquote>\n<p id=\"so_15938077_15938135_1\">I used to think that in C++ the type of all objects is determined at compile-time, but the above example seems to disprove that belief.</p>\n</blockquote>\n<p>In your example, there is one variable, which has type <code>int*</code>. There is not an actual array type for the underlying array which can be recovered in any meaningful way to the program. There is no dynamic typing going on.</p>\n", "LastActivityDate": "2013-04-10T23:13:09.527"}, "bq_ids": {"n4140": {"so_15938077_15938077_0": {"section_id": 6082, "quality": 0.8787878787878788, "length": 29}, "so_15938077_15956145_1": {"section_id": 5768, "quality": 1.0, "length": 7}, "so_15938077_15938077_1": {"section_id": 5790, "quality": 0.75, "length": 15}, "so_15938077_15956145_3": {"section_id": 5768, "quality": 1.0, "length": 10}, "so_15938077_15938128_0": {"section_id": 7190, "quality": 0.8275862068965517, "length": 24}, "so_15938077_15956145_4": {"section_id": 3321, "quality": 0.5454545454545454, "length": 6}, "so_15938077_15938077_2": {"section_id": 6086, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_15938077_15938077_0": {"section_id": 5850, "quality": 0.8787878787878788, "length": 29}, "so_15938077_15956145_1": {"section_id": 5541, "quality": 1.0, "length": 7}, "so_15938077_15938077_1": {"section_id": 5563, "quality": 0.75, "length": 15}, "so_15938077_15956145_3": {"section_id": 5541, "quality": 1.0, "length": 10}, "so_15938077_15938128_0": {"section_id": 6934, "quality": 0.8275862068965517, "length": 24}, "so_15938077_15956145_4": {"section_id": 3191, "quality": 0.5454545454545454, "length": 6}, "so_15938077_15938077_2": {"section_id": 5854, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_15938077_15938077_0": {"section_id": 7578, "quality": 0.8787878787878788, "length": 29}, "so_15938077_15956145_1": {"section_id": 7225, "quality": 1.0, "length": 7}, "so_15938077_15938077_1": {"section_id": 7247, "quality": 0.85, "length": 17}, "so_15938077_15956145_3": {"section_id": 7520, "quality": 0.7, "length": 7}, "so_15938077_15956145_4": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}, "so_15938077_15938077_2": {"section_id": 7582, "quality": 0.8717948717948718, "length": 34}}}});