post_cb({"8713490": {"ViewCount": "1070", "Body": "<p>I'm getting results from left shift to which I could not find an explanation.</p>\n<pre><code>unsigned char value = 0xff; // 1111 1111\nunsigned char  = 0x01; // 0000 0001\n\nstd::cout &lt;&lt; \"SIZEOF value \" &lt;&lt; sizeof(value) &lt;&lt; \"\\n\"; // prints 1 as expected\nstd::cout &lt;&lt; \"SIZEOF shift \" &lt;&lt; sizeof(shift) &lt;&lt; \"\\n\"; // prints 1 as expected\n\nstd::cout &lt;&lt; \"result \" &lt;&lt; (value &lt;&lt; shift) &lt;&lt; \"\\n\"; // prints 510 ???\n\nstd::cout &lt;&lt; \"SIZEOF result \" &lt;&lt;  sizeof(value &lt;&lt; shift) &lt;&lt; \"\\n\"; // prints 4 ???\n</code></pre>\n<p>I was expecting result to be <code>1111 1110</code> but instead I get <code>int</code>(?) with value of <code>1 1111 1110</code>.</p>\n<p>How can the bits of an unsigned char be shifted to the left so that bits are truncated and the result is 1111 1110?</p>\n<p>What I'm trying to do is to read series of bytes and interpret them as integers of varying lengths (1-32 bits).</p>\n<pre><code>F0        F5\n1111 0000 1111 0101 \n</code></pre>\n<p>could be</p>\n<pre><code>0F (first 4 bits)\n0F (next 8 bits)\n05 (last 4 bits)\n</code></pre>\n<p>Has this something to do with the fact that arithmetic is not done with types smaller than int?</p>\n", "AcceptedAnswerId": "8713579", "Title": "Why result of unsigned char << unsigned char is not unsigned char", "CreationDate": "2012-01-03T14:10:05.557", "Id": "8713490", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-01-03T14:23:58.877", "Score": "7", "OwnerUserId": "1124809", "Tags": "<c++><bit-manipulation>", "AnswerCount": "3"}, "8713577": {"Id": "8713577", "PostTypeId": "2", "Body": "<p>Just cast it back to an unsigned char:</p>\n<pre><code>std::cout &lt;&lt; \"result \" &lt;&lt; static_cast&lt;unsigned char&gt;(value &lt;&lt; shift) &lt;&lt; \"\\n\";\n</code></pre>\n<p>Or, use bitwise-AND:</p>\n<pre><code>std::cout &lt;&lt; \"result \" &lt;&lt; ((value &lt;&lt; shift) &amp; 0xFF) &lt;&lt; \"\\n\";\n</code></pre>\n", "LastActivityDate": "2012-01-03T14:16:11.200", "CommentCount": "0", "CreationDate": "2012-01-03T14:16:11.200", "ParentId": "8713490", "Score": "2", "OwnerUserId": "562766"}, "8713579": {"Id": "8713579", "PostTypeId": "2", "Body": "<p>Quoting some draft of the 2011 standard:</p>\n<blockquote>\n<p id=\"so_8713490_8713579_0\">5.8 Shift operators [expr.shift]</p>\n<p id=\"so_8713490_8713579_1\">...</p>\n<p id=\"so_8713490_8713579_2\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed.\n  The type of the result is that of the promoted left operand.</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_8713490_8713579_3\">4.5 Integral Promotions [conv.prom]</p>\n<p id=\"so_8713490_8713579_4\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned\n  int</p>\n<p id=\"so_8713490_8713579_5\">...</p>\n</blockquote>\n<p>So, <code>value</code> is promoted to <code>int</code>, and the type of <code>value &lt;&lt; shift</code> is the type of the promoted left operand, i.e. <code>int</code>.</p>\n<p>You can achieve your desired result one of these ways:</p>\n<pre><code>std::cout &lt;&lt; \"result \" &lt;&lt; ((unsigned char)(value &lt;&lt; shift)) &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"result \" &lt;&lt; ((value &lt;&lt; shift)&amp;0xff) &lt;&lt; \"\\n\";\n</code></pre>\n", "LastEditorUserId": "8747", "LastActivityDate": "2012-01-03T14:23:58.877", "Score": "9", "CreationDate": "2012-01-03T14:16:14.080", "ParentId": "8713490", "CommentCount": "0", "OwnerUserId": "8747", "LastEditDate": "2012-01-03T14:23:58.877"}, "8713595": {"Id": "8713595", "PostTypeId": "2", "Body": "<p>You could mask the bits you're interested in:</p>\n<pre><code>(value &lt;&lt; shift) &amp; 0xff\n</code></pre>\n<p>What you are seeing is a result of integer promotion, and is a part of the language. Imagine you're composing a 16-bit integer from 2 8-bit ones - you wouldn't want to manually promote to a higher width integer to get the high and low bits into the right place, right?</p>\n", "LastActivityDate": "2012-01-03T14:17:07.140", "CommentCount": "0", "CreationDate": "2012-01-03T14:17:07.140", "ParentId": "8713490", "Score": "2", "OwnerUserId": "457598"}, "bq_ids": {"n4140": {"so_8713490_8713579_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 6146}, "so_8713490_8713579_4": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}, "n3337": {"so_8713490_8713579_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 5909}, "so_8713490_8713579_4": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}}, "n4659": {"so_8713490_8713579_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 7642}, "so_8713490_8713579_4": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}}});