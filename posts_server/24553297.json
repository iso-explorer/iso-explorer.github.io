post_cb({"24553297": {"CommentCount": "10", "CreationDate": "2014-07-03T12:07:12.420", "PostTypeId": "1", "AcceptedAnswerId": "24557347", "LastEditorUserId": "3801408", "LastActivityDate": "2014-07-03T15:08:15.857", "LastEditDate": "2014-07-03T12:51:38.063", "ViewCount": "402", "FavoriteCount": "1", "Title": "Linker error with implicit instantiation of private C++ template with LLVM-Clang", "Id": "24553297", "Score": "3", "Body": "<p><strong>Disclaimer: I know that templates are <em>usually</em> implemented in the header file. Please read through.</strong></p>\n<p>I have a C++ template-related issue. My code builds with MSVC under Windows but doesn't with LLVM-Clang under Mac OSX, but I'm not sure which one is wrong.</p>\n<p>Here is a simple test case, composed of three source files:</p>\n<ul>\n<li><p>main.cpp</p>\n<pre><code>#include \"templ.h\"\n\nint main()\n{\n   templ(1);\n   return 0;\n}\n</code></pre></li>\n<li><p>templ.h</p>\n<pre><code>template&lt;typename T&gt;\nT templ(const T&amp;);\n</code></pre></li>\n<li><p>templ.cpp</p>\n<pre><code>#include \"templ.h\"\n\ntemplate&lt;typename T&gt;\nT templ(const T&amp; t)\n{\n   return t;\n}\n\n//explicit instantiation\ntemplate int templ(const int&amp;);\n\n//implicit instantiation\nvoid f()\n{\n   templ(1);\n}\n</code></pre></li>\n</ul>\n<p>As you can see, I want the implementation of the function template to be private (i.e. hidden in the .cpp file). To allow this, I must instantiate my template in the same translation unit as its definition. In the above example, I only instantiate <code>templ&lt;int&gt;</code>. AFAIK, this is unusual, but perfectly cromulent C++.</p>\n<p>As is, this code builds with both the compilers. However, if I comment out the explicit instantiation and only leave the implicit instantiation, the compilers behave differently. MSVC builds successfuly, but LLVM-Clang fails with the following linker error:</p>\n<pre><code>Undefined symbols for architecture x86_64:\n  \"int templ&lt;int&gt;(int const&amp;)\", referenced from:\n      _main in main.cpp.o\nld: symbol(s) not found for architecture x86_64\n</code></pre>\n<p>Besides, that error occurs only when the optimization is enabled (e.g. <code>-02</code>).</p>\n<p>What does the standard say about this? Is this a known behavior/bug of LLVM-Clang?</p>\n<p>My version of LLVM-Clang is:</p>\n<pre><code>Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)\nTarget: x86_64-apple-darwin13.0.0\nThread model: posix\n</code></pre>\n<p>Sorry if this is a duplicate. It's very hard to pick the correct keywords.</p>\n", "Tags": "<c++><templates><visual-c++><llvm-clang>", "OwnerUserId": "3801408", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24553297_24557347_0": {"section_id": 53, "quality": 0.9032258064516129, "length": 28}}, "n3337": {"so_24553297_24557347_0": {"section_id": 48, "quality": 0.8387096774193549, "length": 26}}, "n4659": {"so_24553297_24557347_0": {"section_id": 55, "quality": 0.9032258064516129, "length": 28}}}, "24557347": {"ParentId": "24553297", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-07-03T15:08:15.857", "OwnerUserId": "775806", "CommunityOwnedDate": "2014-07-03T15:08:15.857", "Id": "24557347", "Score": "5", "Body": "<p>This is normal and expected.</p>\n<blockquote>\n<p id=\"so_24553297_24557347_0\">14 Templates<br>\n  6 A function template, member function of a class template, variable template, or static data member of a class template shall be defined in every translation unit in which it is implicitly instantiated (14.7.1) unless the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is required.</br></p>\n</blockquote>\n<p>As applied to your case, this means that when the explicit instantiation of <code>templ</code> is removed, the compiler can either </p>\n<ol>\n<li>generate an instantiation normally because of the implicit instantiation in the same TU; or</li>\n<li>inline the call to <code>templ</code>  and not generate any externally usable entity. </li>\n</ol>\n<p>Either behaviour is permitted for a conforming implementation. If you make sure there's an explicit instantiation somewhere, either will produce valid object code. If you don't, you may or may not get an error and it's your own fault.</p>\n", "LastActivityDate": "2014-07-03T15:08:15.857"}});