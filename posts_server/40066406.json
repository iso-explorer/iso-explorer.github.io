post_cb({"40066406": {"CommentCount": "0", "ViewCount": "106", "PostTypeId": "1", "LastEditorUserId": "1698612", "CreationDate": "2016-10-16T03:05:25.447", "LastActivityDate": "2016-10-16T07:36:05.060", "Title": "unique_ptr not generating delete instruction in Compiler Explorer?", "AcceptedAnswerId": "40066451", "LastEditDate": "2016-10-16T07:36:05.060", "Id": "40066406", "Score": "5", "Body": "<p>I've been playing around with the <a href=\"https://godbolt.org/\" rel=\"nofollow\">Compiler Explorer</a> recently. I loaded one of their examples that takes pointer parameters and changed it to instead take unique_ptr parameters. But I noticed that in the output assembly, calls to operator delete were conspicuously absent. I'm curious if anyone knows why.</p>\n<p>Here's an example you can paste into the explorer. Be sure to also put <code>-O3</code> in the compiler options.</p>\n<pre><code>#include &lt;memory&gt;\n\nusing std::unique_ptr;\n\nvoid maxArray(unique_ptr&lt;double[]&gt; x, unique_ptr&lt;double[]&gt; y) {\n    for (int i = 0; i &lt; 65536; i++) {\n        if (y[i] &gt; x[i]) x[i] = y[i];\n    }\n}\n</code></pre>\n<hr>\n<p>EDIT: Also for comparison, if instead I paste in one of the code examples from cppreference, then I <em>do</em> get operator delete in the output.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstruct Foo\n{\n    Foo()      { std::cout &lt;&lt; \"Foo::Foo\\n\";  }\n    ~Foo()     { std::cout &lt;&lt; \"Foo::~Foo\\n\"; }\n    void bar() { std::cout &lt;&lt; \"Foo::bar\\n\";  }\n};\n\nvoid f(const Foo &amp;)\n{\n    std::cout &lt;&lt; \"f(const Foo&amp;)\\n\";\n}\n\nint main()\n{\n    std::unique_ptr&lt;Foo&gt; p1(new Foo);  // p1 owns Foo\n    if (p1) p1-&gt;bar();\n\n    {\n        std::unique_ptr&lt;Foo&gt; p2(std::move(p1));  // now p2 owns Foo\n        f(*p2);\n\n        p1 = std::move(p2);  // ownership returns to p1\n        std::cout &lt;&lt; \"destroying p2...\\n\";\n    }\n\n    if (p1) p1-&gt;bar();\n\n    // Foo instance is destroyed when p1 goes out of scope\n}\n</code></pre>\n<hr>\n<p>EDIT: +1 to krzaq. It's the caller, not the callee, that constructs and destroys parameters.</p>\n</hr></hr>", "Tags": "<c++>", "OwnerUserId": "1698612", "AnswerCount": "1"}, "40066451": {"ParentId": "40066406", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2016-10-16T03:13:16.717", "Score": "6", "LastEditorUserId": "2456565", "LastEditDate": "2016-10-16T05:30:59.920", "Id": "40066451", "OwnerUserId": "2456565", "Body": "<p>This problem boils down to:</p>\n<pre><code>void foo(unique_ptr&lt;int&gt;)\n{\n}\n\nfoo(make_unique&lt;int&gt;());\n</code></pre>\n<p>Where does <code>foo</code>'s parameter live?</p>\n<p>The following standardese is pertinent to this question:</p>\n<blockquote>\n<p id=\"so_40066406_40066451_0\">N4140 \u00a75.2.2 [expr.call]/4</p>\n<p id=\"so_40066406_40066451_1\">The lifetime of a parameter ends when the function in which it is\n  defined returns. The initialization and destruction of each parameter\n  occurs within the context of the calling function.</p>\n</blockquote>\n<p>In other words: your <code>maxArray</code> is not required to be responsible for calling <code>x</code> and <code>y</code>'s destructors; gcc implements it this way, and that's why there are no <code>delete</code> calls in the codegen.</p>\n", "LastActivityDate": "2016-10-16T05:30:59.920"}, "bq_ids": {"n4140": {"so_40066406_40066451_1": {"section_id": 5991, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_40066406_40066451_1": {"section_id": 5759, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_40066406_40066451_1": {"section_id": 7491, "quality": 0.8888888888888888, "length": 16}}}});