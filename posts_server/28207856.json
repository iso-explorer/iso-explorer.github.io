post_cb({"bq_ids": {"n4140": {"so_28207856_28208832_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 7210}, "so_28207856_28208832_4": {"length": 13, "quality": 1.0, "section_id": 5937}, "so_28207856_28208832_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 7202}, "so_28207856_28208832_3": {"length": 6, "quality": 1.0, "section_id": 7215}}, "n3337": {"so_28207856_28208832_1": {"length": 24, "quality": 0.8888888888888888, "section_id": 6954}, "so_28207856_28208832_4": {"length": 13, "quality": 1.0, "section_id": 5709}, "so_28207856_28208832_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 6946}, "so_28207856_28208832_3": {"length": 6, "quality": 1.0, "section_id": 6959}}, "n4659": {"so_28207856_28208832_1": {"length": 20, "quality": 0.7407407407407407, "section_id": 8719}, "so_28207856_28208832_4": {"length": 13, "quality": 1.0, "section_id": 7421}, "so_28207856_28208832_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 8711}, "so_28207856_28208832_3": {"length": 6, "quality": 1.0, "section_id": 8724}}}, "28207932": {"Id": "28207932", "PostTypeId": "2", "Body": "<p><code>true</code> means <code>1</code> </p>\n<p>But 123 is also considered as  true (Generally all  integers except zero)</p>\n<p>if you say </p>\n<pre><code>if (b) printf(\"b is true\");\n</code></pre>\n<p>you must get the output <code>b is true</code></p>\n", "LastActivityDate": "2015-01-29T06:02:30.717", "CommentCount": "1", "CreationDate": "2015-01-29T06:02:30.717", "ParentId": "28207856", "Score": "0", "OwnerUserId": "2412816"}, "28207856": {"ViewCount": "123", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    bool b;\n\n    // Set b to 123\n    char *p = (char*)&amp;b;\n    *p = 123;\n\n    // Check if b is considered to be true\n    if (b == true) printf(\"b is true\");\n\n    return 0;\n}\n</code></pre>\n<p><code>b</code> is not considered to be <code>true</code>, so what does <code>true</code> means exactly, is <code>true</code> equals to <code>1</code>?</p>\n<hr>\n<p><strong><em>Edit:</em></strong> Forgot to say that I'm using Visual C++.</p></hr>\n", "AcceptedAnswerId": "28208140", "Title": "Changing a bool to a value other than 0 or 1?", "CreationDate": "2015-01-29T05:56:01.097", "Id": "28207856", "CommentCount": "6", "LastEditDate": "2015-01-29T06:17:39.663", "PostTypeId": "1", "LastEditorDisplayName": "user4420637", "OwnerDisplayName": "user4420637", "LastActivityDate": "2015-01-29T07:32:02.923", "Score": "1", "Tags": "<c++><visual-studio-2010><visual-c++>", "AnswerCount": "3"}, "28208140": {"Id": "28208140", "PostTypeId": "2", "Body": "<pre><code>bool b;\n\n// Set b to 123\nchar *p = (char*)&amp;b;\n*p = 123;\n</code></pre>\n<p>The C++ Standard leaves it unspecified how <code>bool</code> are stored... e.g. entirely legal for one compiler to use one byte and another to use four.  Further, one compiler might store say <code>0</code> for <code>false</code> and all-bits-on for <code>true</code> and another <code>0</code> and <code>1</code> or whatever other values.  All that mattered is that when used in a boolean context the logic works correctly, and that when converted to or from an <code>int</code>:</p>\n<ul>\n<li><p><code>int(b)</code> is <code>1</code> if <code>b</code> is <code>true</code>, and <code>0</code> if <code>b</code> is <code>false</code>, and</p></li>\n<li><p><code>bool(n)</code> is <code>true</code> if-and-only-if <code>n</code> was not <code>0</code>.</p></li>\n</ul>\n<p>Because of this, the character at the lowest memory address in the <code>bool</code> representation may or may not be consulted when testing the value of the boolean: it could be one compiler's generated code uses a four-byte <code>int</code> that is read then has only the least significant bit or byte tested, which - depending on endianness - may not have been touched by the <code>*p = 123</code>.  Similarly, the compiler might read the value into a signed integer register and test for negativeness (expecting an all-bits-on value when <code>true</code>), which could also fail even if <code>*p = 123</code> had written to the only or most significant byte.</p>\n<p>Consequently - even if there was nothing else at play - the line below might not report \"b is true\"...</p>\n<pre><code>// Check if b is considered to be true\nif (b == true) printf(\"b is true\");\n</code></pre>\n<p>...but that test is further flawed by...</p>\n<ul>\n<li><p>possibly reading from other bytes in the <code>bool</code> representation that haven't been initialised (uninitialised memory reads have undefined behaviour)</p></li>\n<li><p>fiddling with the <code>bool</code> value alone inherently has \"undefined behaviour\"; in terms of \"binary writing\" to the <code>bool</code>'s memory, only a full byte-for-byte copy from another properly initialised <code>bool</code> is guaranteed to leave this <code>bool</code> is a usable state.</p></li>\n</ul>\n", "LastEditorUserId": "410767", "LastActivityDate": "2015-01-29T07:25:27.730", "Score": "3", "CreationDate": "2015-01-29T06:18:36.613", "ParentId": "28207856", "CommentCount": "3", "OwnerUserId": "410767", "LastEditDate": "2015-01-29T07:25:27.730"}, "28208832": {"Id": "28208832", "PostTypeId": "2", "Body": "<p>C++11 says (3.9 \"Types\" [basic.types]):</p>\n<blockquote>\n<p id=\"so_28207856_28208832_0\">The value representation of an object is the set of bits that hold the\n  value of type T. For trivially copyable types, the value\n  representation is a set of bits in the object representation that\n  determines a value, which is one discrete element of an\n  implementation-defined set of values</p>\n</blockquote>\n<p>And (3.9.1 \"Fundamental types\" [basic.fundamental]):</p>\n<blockquote>\n<p id=\"so_28207856_28208832_1\">For character types, all bits of the object representation participate\n  in the value representation. For unsigned character types, all\n  possible bit patterns of the value representation represent numbers.\n  <strong>These requirements do not hold for other types</strong>.</p>\n<p id=\"so_28207856_28208832_2\">...</p>\n<p id=\"so_28207856_28208832_3\">Values of type bool are either true or false</p>\n</blockquote>\n<p>And finally, 5 \"Expressions\" [expr] says:</p>\n<blockquote>\n<p id=\"so_28207856_28208832_4\">If during the evaluation of an expression, the result is not\n  mathematically defined or <strong>not in the range of representable values</strong> for\n  its type, the behavior is undefined.</p>\n</blockquote>\n<p>What is happening is that when you write the value 123 to the memory that the <code>bool</code> object occupies (through the <code>char* p</code>), you're writing something that can't be represented in the <code>bool</code> object's 'value representation'.  So when you subsequently access that object through the lvalue <code>b</code> the program exhibits undefined behavior and you have a <code>bool</code> object that is neither <code>true</code> nor <code>false</code>.</p>\n<p>And to answer your question about what the value of <code>true</code> is: the standard never actually specifies.  It does specify that the <code>true</code> is one of the two values a <code>bool</code> type can represent (the other being <code>false</code> of course).  The standard also specifies that <code>true</code> readily converts to 1 and vice versa, 1 readily converts to <code>true</code>. These conversion happen so naturally and easily that I think that nearly everyone considers <code>true</code> to have the value 1.</p>\n<p>One thing to remember is that nearly any non-zero integral value will readily convert to <code>true</code> - not just 1. However that doesn't happen in your example for the value 123 because in that expression it is being written to an lvalue with <code>char</code> type so no conversion to <code>bool</code> occurs.</p>\n", "LastEditorUserId": "12711", "LastActivityDate": "2015-01-29T07:32:02.923", "Score": "1", "CreationDate": "2015-01-29T07:06:45.830", "ParentId": "28207856", "CommentCount": "1", "OwnerUserId": "12711", "LastEditDate": "2015-01-29T07:32:02.923"}});