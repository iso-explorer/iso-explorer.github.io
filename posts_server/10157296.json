post_cb({"10157466": {"ParentId": "10157296", "CommentCount": "0", "Body": "<p>You can do it like this:</p>\n<pre><code>typedef decltype (a) AT;\ntypedef AT::t T;\nf&lt;T&gt;();\nT somevar;\n</code></pre>\n<p>decltype is specific for C++11</p>\n", "OwnerUserId": "1274850", "PostTypeId": "2", "Id": "10157466", "Score": "1", "CreationDate": "2012-04-14T21:20:40.640", "LastActivityDate": "2012-04-14T21:20:40.640"}, "10157296": {"CommentCount": "2", "ViewCount": "2817", "PostTypeId": "1", "LastEditorUserId": "1073006", "CreationDate": "2012-04-14T20:57:20.947", "LastActivityDate": "2012-04-14T21:26:54.780", "Title": "how to reference a typedef within a class with an instance of such class?", "AcceptedAnswerId": "10157328", "LastEditDate": "2012-04-14T21:04:53.893", "Id": "10157296", "Score": "1", "Body": "<p>Is there a way to get this code work, just like it does when calling a <em>static</em> function with the dot notation?</p>\n<pre><code>struct A{\n    static void f(){ }\n    typedef int t;\n};\n\ntemplate&lt;typename T&gt; void f(){}\n\nint main(){\n    A a;\n    a.f();          //legit\n    f&lt;a.t&gt;();       //\u2018a\u2019 cannot appear in a constant-expression, \u2018.\u2019 cannot appear in a constant-expression\n    a.t somevar;    //invalid use of \u2018A::t\u2019\n    f&lt;a::t&gt;();      //\u2018a\u2019 cannot appear in a constant-expression\n    a::t somevar;   //\u2018a\u2019 is not a class, namespace, or enumeration\n}\n</code></pre>\n<p>EDIT:\nGuys, please read the question and test your code before posting. The point here is NOT to use <code>A::t</code> but \"invoke\" <code>t</code> through an <em>instance</em> of <code>A</code>, like you can do with static methods.</p>\n", "Tags": "<c++><static><typedef>", "OwnerUserId": "1073006", "AnswerCount": "4"}, "10157330": {"ParentId": "10157296", "CommentCount": "0", "Body": "<p>You will need to use the scope resolution operator, so the could would need to be</p>\n<pre><code>f&lt;A::t&gt;();\nA::t somevar;\n</code></pre>\n<p>For more information on the scope resolution operator, take a look at <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=/com.ibm.vacpp7a.doc/language/ref/clrc05cplr175.htm\" rel=\"nofollow\">C++ Scope Resolution Operator ::</a>.</p>\n", "OwnerUserId": "1157214", "PostTypeId": "2", "Id": "10157330", "Score": "0", "CreationDate": "2012-04-14T21:01:08.247", "LastActivityDate": "2012-04-14T21:01:08.247"}, "10157328": {"ParentId": "10157296", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>You have to use <code>A::t</code> instead of <code>a.t</code> because the typedef is like <code>static</code> and <code>a</code> is an instance of <code>A</code>.</p>\n<hr>\n<p><strong>EDIT</strong>: In contrast to what I said above, it is not always \"like <code>static</code>\".  For static members, there is this special rule:</p>\n<blockquote>\n<p id=\"so_10157296_10157328_0\">A static member s of class X may be referred to using the qualified-id expression X::s; it is not necessary to\n  use the class member access syntax (5.2.5) to refer to a static member. A static member may be referred\n  to using the class member access syntax, in which case the object expression is evaluated. \n     [ Example:</p>\n<pre><code>struct process {\n  static void reschedule();\n};\nprocess&amp; g();\n\nvoid f() {\n  process::reschedule(); // OK: no object necessary\n  g().reschedule();      // g() is called\n}\n</code></pre>\n</blockquote>\n<p>Since a <code>typedef</code> is <em>not</em> a static member, this syntax is invalid.</p>\n<p>Given the instance <code>a</code> and not this syntactic sugar, the only way to get <code>t</code> is to get the type of it.  C++11 gives us a tool for that:</p>\n<pre><code>typedef decltype(a) a_type;\nf&lt;a_type::t&gt;();\na_type::t somevar;\n</code></pre>\n<p>However, I see no practical use of it (ok, maybe in macros, but everyone knows that templates are better).</p>\n</hr>", "OwnerUserId": "1333488", "LastEditorUserId": "1333488", "LastEditDate": "2012-04-14T21:26:54.780", "Id": "10157328", "Score": "6", "CreationDate": "2012-04-14T21:00:31.093", "LastActivityDate": "2012-04-14T21:26:54.780"}, "10157368": {"ParentId": "10157296", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You need to use scope resolution operator (and return int value from <code>main</code>):</p>\n<pre><code>int main()\n{\n    A a;\n    A::t somevar = 0;\n    return 0;    \n}\n</code></pre>\n<p>Note that type alias introduced with <code>typedef</code> must be publicly visible if you want to use it outside the class. If you had:</p>\n<pre><code>class A\n{\n    static void f(){}\n    typedef int t;\n};\n</code></pre>\n<p>Then using A::t like in the above example would yield compiler error (<em>\"cannot access private typedef...\"</em>). You would need to use <code>public</code> accessor specifier:</p>\n<pre><code>class A\n{\n    static void f(){}\npublic:\n    typedef int t;\n};\n</code></pre>\n", "OwnerUserId": "404421", "LastEditorUserId": "404421", "LastEditDate": "2012-04-14T21:11:41.153", "Id": "10157368", "Score": "1", "CreationDate": "2012-04-14T21:05:32.187", "LastActivityDate": "2012-04-14T21:11:41.153"}, "bq_ids": {"n4140": {"so_10157296_10157328_0": {"section_id": 5900, "quality": 0.9375, "length": 30}}, "n3337": {"so_10157296_10157328_0": {"section_id": 5672, "quality": 0.9375, "length": 30}}, "n4659": {"so_10157296_10157328_0": {"section_id": 7382, "quality": 0.9375, "length": 30}}}});