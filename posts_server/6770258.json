post_cb({"6770275": {"ParentId": "6770258", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>This is outlined explicitly in \u00a75/9:</p>\n<blockquote>\n<p id=\"so_6770258_6770275_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>\n<ul>\n<li>If either operand is of type <code>long double</code>, the other shall be converted to <code>long double</code>.</li>\n<li>Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</li>\n<li>Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.</li>\n<li>Otherwise, the integral promotions shall be performed on both operands.</li>\n<li>Then, if either operand is <code>unsigned long</code> the other shall be converted to <code>unsigned long</code>.</li>\n<li>Otherwise, if one operand is a <code>long int</code> and the other <code>unsigned int</code>, then if a <code>long int</code> can represent all the values of an <code>unsigned int</code>, the <code>unsigned int</code> shall be converted to a <code>long int</code>; otherwise both operands shall be converted to <code>unsigned long int</code>.</li>\n<li>Otherwise, if either operand is <code>long</code>, the other shall be converted to <code>long</code>.</li>\n<li>Otherwise, if either operand is <code>unsigned</code>, the other shall be converted to <code>unsigned</code>.</li>\n</ul>\n<p id=\"so_6770258_6770275_1\">[<em>Note</em>: otherwise, the only remaining case is that both operands are <code>int</code>]</p>\n</blockquote>\n<p>In both of your scenarios, the result of <code>operator+</code> is <code>unsigned</code>. Consequently, the second scenario is effectively:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>int result = static_cast&lt;int&gt;(us + static_cast&lt;unsigned&gt;(neg));\n</code></pre>\n<p>Because in this case the value of <code>us + neg</code> is not representable by <code>int</code>, the value of <code>result</code> is implementation-defined \u2013 \u00a74.7/3:</p>\n<blockquote>\n<p id=\"so_6770258_6770275_2\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2012-10-15T04:33:06.433", "Id": "6770275", "Score": "31", "CreationDate": "2011-07-21T01:06:23.130", "LastActivityDate": "2012-10-15T04:33:06.433"}, "6770268": {"ParentId": "6770258", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>It's choosing whatever type you put your result into or at least cout is honoring that type during output.</p>\n<p>I don't remember for sure but I think C++ compilers generate the same arithmetic code for both, it's only compares and output that care about sign.</p>\n", "OwnerUserId": "278836", "LastEditorUserId": "278836", "LastEditDate": "2011-07-21T01:19:35.873", "Id": "6770268", "Score": "2", "CreationDate": "2011-07-21T01:04:07.437", "LastActivityDate": "2011-07-21T01:19:35.873"}, "6770371": {"ParentId": "6770258", "CommentCount": "15", "Body": "<p>Before C was standardized, there were differences between compilers -- some followed \"value preserving\" rules, and others \"sign preserving\" rules. Sign preserving meant that if either operand was unsigned, the result was unsigned. This was simple, but at times gave rather surprising results (especially when a negative number was converted to an unsigned).</p>\n<p>C standardized on the rather more complex \"value preserving\" rules. Under the value preserving rules, promotion can/does depend on the actual ranges of the types, so you can get different results on different compilers. For example, on most MS-DOS compilers, <code>int</code> is the same size as <code>short</code> and <code>long</code> is different from either. On many current systems <code>int</code> is the same size as <code>long</code>, and <code>short</code> is different from either. With value preserving rules, these can lead to the promoted type being different between the two.</p>\n<p>The basic idea of value preserving rules is that it'll promote to a larger signed type if that can represent all the values of the smaller type. For example, a 16-bit <code>unsigned short</code> can be promoted to a 32-bit <code>signed int</code>, because every possible value of <code>unsigned short</code> can be represented as a <code>signed int</code>. The types will be promoted to an unsigned type if and only if that's necessary to preserve the values of the smaller type (e.g., if <code>unsigned short</code> and <code>signed int</code> are both 16 bits, then a <code>signed int</code> can't represent all possible values of <code>unsigned short</code>, so an <code>unsigned short</code> will be promoted to <code>unsigned int</code>).</p>\n<p>When you assign the result as you have, the result will get converted to the destination type anyway, so most of this makes relatively little difference -- at least in most typical cases, where it'll just copy the bits into the result, and it's up to you to decide whether to interpret that as signed or unsigned.</p>\n<p>When you <em>don't</em> assign the result such as in a comparison, things can get pretty ugly though. For example:</p>\n<pre><code>unsigned int a = 5;\nsigned int b = -5;\n\nif (a &gt; b)\n    printf(\"Of course\");\nelse\n    printf(\"What!\");\n</code></pre>\n<p>Under sign preserving rules, <code>b</code> would be promoted to unsigned, and in the process become equal to <code>UINT_MAX - 4</code>, so the \"What!\" leg of the <code>if</code> would be taken. With value preserving rules, you <em>can</em> manage to produce some strange results a bit like this as well, but 1) primarily on the DOS-like systems where <code>int</code> is the same size as <code>short</code>, and 2) it's generally harder to do it anyway.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "6770371", "Score": "10", "CreationDate": "2011-07-21T01:24:45.753", "LastActivityDate": "2011-07-21T01:24:45.753"}, "bq_ids": {"n4140": {"so_6770258_6770275_0": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_6770258_6770275_2": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_6770258_6770275_0": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_6770258_6770275_2": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_6770258_6770275_2": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}, "so_6770258_6770275_0": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}}}, "6770258": {"CommentCount": "2", "AcceptedAnswerId": "6770275", "PostTypeId": "1", "LastEditorUserId": "2932052", "CreationDate": "2011-07-21T01:00:54.207", "LastActivityDate": "2014-12-17T10:51:46.577", "LastEditDate": "2014-12-17T10:51:46.577", "ViewCount": "5530", "FavoriteCount": "16", "Title": "How do promotion rules work when the signedness on either side of a binary operator differ?", "Id": "6770258", "Score": "21", "Body": "<p>Consider the following programs:</p>\n<pre><code>// http://ideone.com/4I0dT\n#include &lt;limits&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    int max = std::numeric_limits&lt;int&gt;::max();\n    unsigned int one = 1;\n    unsigned int result = max + one;\n    std::cout &lt;&lt; result;\n}\n</code></pre>\n<p>and</p>\n<pre><code>// http://ideone.com/UBuFZ\n#include &lt;limits&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    unsigned int us = 42;\n    int neg = -43;\n    int result = us + neg;\n    std::cout &lt;&lt; result;\n}\n</code></pre>\n<p>How does the + operator \"know\" which is the correct type to return? The general rule is to convert all of the arguments to the widest type, but here there's no clear \"winner\" between <code>int</code> and <code>unsigned int</code>. In the first case, <code>unsigned int</code> must be being chosen as the result of <code>operator+</code>, because I get a result of <code>2147483648</code>. In the second case, it must be choosing <code>int</code>, because I get a result of <code>-1</code>. Yet I don't see in the general case how this is decidable. Is this undefined behavior I'm seeing or something else?</p>\n", "Tags": "<c++><overflow><arithmetic-expressions><integer-promotion>", "OwnerUserId": "82320", "AnswerCount": "3"}});