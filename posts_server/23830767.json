post_cb({"bq_ids": {"n4140": {"so_23830767_23831467_3": {"length": 30, "quality": 0.967741935483871, "section_id": 455}, "so_23830767_23831467_2": {"length": 25, "quality": 0.7352941176470589, "section_id": 455}, "so_23830767_23831467_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 378}, "so_23830767_23831467_0": {"length": 24, "quality": 1.0, "section_id": 451}}, "n3337": {"so_23830767_23831467_3": {"length": 30, "quality": 0.967741935483871, "section_id": 446}, "so_23830767_23831467_2": {"length": 25, "quality": 0.7352941176470589, "section_id": 446}, "so_23830767_23831467_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 369}, "so_23830767_23831467_0": {"length": 24, "quality": 1.0, "section_id": 442}}, "n4659": {"so_23830767_23831467_3": {"length": 30, "quality": 0.967741935483871, "section_id": 478}, "so_23830767_23831467_2": {"length": 25, "quality": 0.7352941176470589, "section_id": 478}, "so_23830767_23831467_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 392}, "so_23830767_23831467_0": {"length": 24, "quality": 1.0, "section_id": 474}}}, "23831467": {"Id": "23831467", "PostTypeId": "2", "Body": "<h2>What is a copy constructor?</h2>\n<p>Quoting the C++11 standard, \u00a712.8/2:</p>\n<blockquote>\n<p id=\"so_23830767_23831467_0\">\u201cA non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>,\n  <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters\n  have default arguments\u201d</p>\n</blockquote>\n<p>So there are 4 different forms. Of these the <code>X const&amp;</code> form is the one most often used. This is also the form of the <strong>implicit copy constructor</strong> that is generated (if possible) if no copy constructor is declared for the class.</p>\n<p>A copy constructor is used for copying an object to a new instance of the class. A default copy constructor performs a member-wise copy, which is different from and more safe than just copying the bits. In particular a copy constructor or move constructor is logically used for a <em>copy initialization</em>, an initialization using the <code>=</code> sign like</p>\n<pre><code>Some_type x = expression;\n</code></pre>\n<p>In some circumstances the compiler is allowed to assume that copying is all that a copy constructor does, regardless of what it actually does.  Logically needless copy constructions can then be removed, or as the standard calls it, <em>elided</em>. For example, if the expression above is the number 42, then instead of using that argument to construct a temporary and copying or moving that to <code>x</code>, the argument may be used to initialize <code>x</code> directly.</p>\n<p>However, even when that is done, so that the copy constructor is not used, if the copy constructor <em>would</em> have been used except for the optimization then a copy constructor must exist and be accessible.</p>\n<p>C++11 \u00a712.2/1:</p>\n<blockquote>\n<p id=\"so_23830767_23831467_1\">\u201cEven when the creation of the temporary object is unevaluated (Clause 5)\n  or otherwise avoided (12.8), all the semantic restrictions shall be respected as if the temporary object had\n  been created and later destroyed.\u201d</p>\n</blockquote>\n<p><hr/></p>\n<h2>Is it necessary to call a destructor?</h2>\n<p>Re \u201cIs it necessary to call a destructor if we [use a copy constructor]? \u201d.</p>\n<p>Generally no.</p>\n<p>Destructors in C++ are called automatically when an object goes out of scope or when it's indirectly or directly destroyed via <code>delete</code>. The only exception is for placement new, which is a low level feature that has nothing in particular to do with copy constructors. Although placement new can involve copy construction.</p>\n<hr>\n<h2>A difference between C++03 and C++11 copy constructors.</h2>\n<p>To understand the difference between C++03 and C++11 regarding copy constructors you must be aware of three facts:</p>\n<ul>\n<li><p>If a copy constructor isn\u2019t declared, then it\u2019s generated if possible. Hence by default every class has a copy constructor. It\u2019s there.</p></li>\n<li><p>Access is independent of overload resolution.<br>\nOverload resolution chooses between all member functions, regardless of whether they\u2019re accessible or not. Then access is checked. At that point you may get an error message about calling an inaccessible function, despite an expectation that overload resolution ideally should choose only from the accessible functions\u2026</br></p></li>\n<li><p>An ordinary function (or just function) is a better match than a an instantiation of a function template with the same signature.</p></li>\n</ul>\n<p>Here is an example of overloading resolution choosing a <code>private</code> member function, in spite of a <code>public</code> function that <em>could</em> be called:</p>\n<p>\nFile [<i>access_versus_overload_resolution.cpp</i>]<br>\n</br></p>\n\n\u00a0\n\n<pre><code>class C\n{\npublic:\n    void foo( double );\n    void foo( int );\n\n    void bar( double );\nprivate:\n    void bar( int );\n};\n\nint main()\n{\n    C().foo( 42 );      // OK.\n    C().bar( 42 );      //! Uh oh, inaccessible.\n}\n</code></pre>\n<p>And here is an example of an ordinary function trumping a template instantiation:</p>\n<p>\nFile [<i>function_versus_template.cpp</i>]<br>\n</br></p>\n\n\u00a0\n\n<pre><code>using One = char[1];\nusing Two = char[2];\n\nauto foo( char const* ) -&gt; One&amp;;\nauto foo( char const (&amp;)[10] ) -&gt; Two&amp;;\n\nauto bar( char const* ) -&gt; One&amp;;\n\ntemplate&lt; int n &gt;\nauto bar( char const (&amp;)[n] ) -&gt; Two&amp;;\n\n#include &lt;iostream&gt;\nauto main() -&gt; int\n{\n    using namespace std;\n    //cout &lt;&lt; sizeof( foo( \"Blah blah\" ) ) &lt;&lt; endl;       //! Ambiguous\n    cout &lt;&lt; sizeof( bar( \"Blah blah\" ) ) &lt;&lt; endl;       // \"1\"\n}\n</code></pre>\n<p>With these facts at hand:</p>\n<ul>\n<li><p>An inaccessible copy constructor will be chosen even if there is an accessible member function template that is just as good a match.<br>\n(As a logical consequence of the general overload resolution rules.)</br></p></li>\n<li><p>In C++11, a member function template instantiation will therefore be chosen only if it is a better match than the copy constructor, if any.</p></li>\n<li><p>But in C++03 there was a special rule that ensured that <em>with a conforming compiler</em> a function member template would never be used to copy an object.</p></li>\n</ul>\n<p>Here\u2019s the C++03 wording, \u00a712.8/3 in that standard, where I\u2019ve added suitable emphasis:</p>\n<blockquote>\n<p id=\"so_23830767_23831467_2\">\u201cA declaration of a constructor for a class <code>X</code> is ill-formed if its first parameter is of type (optionally cv-\n  qualified) <code>X</code> and either there are no other parameters or else all other parameters have default arguments. <b><i>A\n  member function template is never instantiated to perform the copy of a class object to an object of its class\n  type.</i></b></p>\n</blockquote>\n<p>while in C++11 the wording is subtly changed, in that standard\u2019s \u00a712.8/6, where again I\u2019ve added suitable emphasis:</p>\n<blockquote>\n<p id=\"so_23830767_23831467_3\">\u201cA declaration of a constructor for a class <code>X</code>is ill-formed if its first parameter is of type (optionally cv-qualified)\n  <code>X</code> and either there are no other parameters or else all other parameters have default arguments. <b><i>A member\n  function template is never instantiated to produce such a constructor signature.</i></b>\u201d</p>\n</blockquote>\n<p>I.e. no special injunction against function templates being used to copy objects in C++11.</p>\n<p>Unfortunately for history buffs, the most readily available C++03 compiler for Windows, namely MinGW g++ of some old version such as 3.2, does not enforce the C++03 rule.</p>\n<p>\nFile [<i>template_versus_cc.cpp</i>]<br>\n</br></p>\n\n\u00a0\n\n<pre><code>class S\n{\nprivate:\n    S( S const&amp; );  // No such.\n\npublic:\n    S() {}\n\n    template&lt; class T &gt;\n    S( T&amp; ) {}\n};\n\nint main()\n{\n    S sm;\n    S const sc;\n\n    S s1( sm );     // OK in C++11, template is better match.\n    S s2( sc );     //! Line 19. Copy constructor is selected, inaccessible.\n}\n</code></pre>\n<p>Compiling with old g++:</p>\n<pre>\n[H:\\dev\\test\\copy_construction]\n&gt; <b>\\bin\\MinGW_3_1\\bin\\g++ --version | find \"++\"</b>\ng++ (GCC) 3.2.3 (mingw special 20030504-1)\n\n[H:\\dev\\test\\copy_construction]\n&gt; <b>\\bin\\MinGW_3_1\\bin\\g++ -std=c++98 -pedantic template_versus_cc.cpp</b>\ntemplate_versus_cc.cpp: In function `int main()':\ntemplate_versus_cc.cpp:4: `S::S(const S&amp;)' is private\ntemplate_versus_cc.cpp:19: within this context\n\n[H:\\dev\\test\\copy_construction]\n&gt; _\n</pre>\n<p>By the C++03/C++98 rules the compiler should have flagged both copy initializations, at lines 18 and 19, but only flagged the latter, behaving as a C++11 compiler in this respect.</p>\n<p>This is also what the more modern g++ 4.8.2 does, as well as Visual C++ 12.0. But a conforming C++03-compiler must diagnose both initializations.</p>\n<p>Scott Meyers has <a href=\"http://scottmeyers.blogspot.no/2012/10/copying-constructors-in-c11.html\" rel=\"nofollow\">written about this</a>, citing two of the SO C++ Lounge dwellers as sources. Unfortunately the article yields the impressions that (1) it\u2019s all about universal reference template arguments in C++11, and (2) there\u2019s is no bug in g++. The former is wrong, as shown above, while the latter is literally correct. There <em>was</em> a bug, but as the standard has evolved, with C++11 the g++ behavior is now conforming\u2026</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-05-23T22:04:19.317", "Score": "1", "CreationDate": "2014-05-23T14:10:26.020", "ParentId": "23830767", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2014-05-23T22:04:19.317"}, "23830767": {"ViewCount": "189", "Body": "<p>What are copy constructors? </p>\n<p>Why do we use them? Is it necessary to call a destructor if we do?  </p>\n", "AcceptedAnswerId": "23831467", "Title": "How are copy constructors used and why are they important?", "CreationDate": "2014-05-23T13:38:11.473", "LastActivityDate": "2014-05-23T22:04:19.317", "CommentCount": "6", "LastEditDate": "2014-05-23T14:12:36.140", "PostTypeId": "1", "Tags": "<c++>", "Id": "23830767", "AnswerCount": "2", "Score": "-9", "OwnerUserId": "3540733", "ClosedDate": "2014-05-23T14:37:11.837", "LastEditorUserId": "1783614"}, "23831327": {"Id": "23831327", "PostTypeId": "2", "Body": "<p>Copy constructors are important for quite the same reasons as a regular constructor would be, and that is to properly initialize the constructed object. Construction is not always trivial, and it doesn't matter where do you take the data from and in what form - other object of the same class or a set of simpler arguments.</p>\n<p>Therefore copy constructor is there to solve problems like initializing const fields, but also when you use pointers, to decide on ownership of the pointed resource. You may want to share, or duplicate the data. </p>\n", "LastActivityDate": "2014-05-23T14:03:50.990", "CommentCount": "0", "CreationDate": "2014-05-23T14:03:50.990", "ParentId": "23830767", "Score": "0", "OwnerUserId": "2511124"}});