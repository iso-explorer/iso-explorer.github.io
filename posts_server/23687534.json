post_cb({"23687534": {"CommentCount": "0", "ViewCount": "143", "CreationDate": "2014-05-15T19:58:40.103", "LastActivityDate": "2014-05-15T20:24:15.623", "Title": "How do I prevent implict conversion to boost::variant types with multiple types of integers?", "AcceptedAnswerId": "23687636", "PostTypeId": "1", "Id": "23687534", "Score": "1", "Body": "<p>I am trying to work with boost::variant and am running into a bit of a problem with the way I am using it.  I was hoping someone could shed some light on the situation.</p>\n<p>I have created a boost::variant and templatized it with both an <code>int</code> and an <code>unsigned int</code>.  When I assign a numeric value, (ie. 4) to the variant, I would expect the compiler to complain since plain old 4 cannot have it's type inferred unambiguously.  How does this even compile?! How does the compiler choose the type?</p>\n<p>Is there a way to make the compiler complain about these sorts of things?</p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;boost/variant.hpp&gt;\n#include &lt;boost/scoped_ptr.hpp&gt;\n#include &lt;cxxabi.h&gt;\n\nstruct MyComplexType\n{\n    int myInt;\n    uint32_t myUint;\n};\n\nint main()\n{\n    boost::variant&lt; MyComplexType, int, uint32_t, float, std::string&gt; myAmbiguousVar;\n\n    myAmbiguousVar = 4; // &lt;- ?? My compiler chooses this to be an int\n\n    int status;\n    boost::scoped_ptr&lt;char&gt; pDemangled(__cxxabiv1::__cxa_demangle(myAmbiguousVar.type().name(), 0, 0, &amp;status));\n    std::cout &lt;&lt; std::string(pDemangled.get()) &lt;&lt; std::endl;\n}\n</code></pre>\n", "Tags": "<c++><templates><boost>", "OwnerUserId": "267471", "AnswerCount": "2"}, "23687636": {"ParentId": "23687534", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-05-15T20:05:36.913", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:21:25.433", "Id": "23687636", "OwnerUserId": "89999", "Body": "<p>The type of a numeric literal is <a href=\"https://stackoverflow.com/a/8108715/89999\">not ambiguous</a>, and is largely implicitly convertible. In short, <code>4</code> is an <code>int</code>, and <code>4U</code> is an <code>unsigned int</code>. Unless your compiler has a specific warning for such things, it's unlikely you will get it to warn.</p>\n", "LastActivityDate": "2014-05-15T20:05:36.913"}, "23687929": {"ParentId": "23687534", "CommentCount": "0", "Body": "<p>Based on Michael Urman's response, I wanted to fill this answer in a bit more completely.</p>\n<p>The C++ standard states the following(2.14.2.2):</p>\n<blockquote>\n<p id=\"so_23687534_23687929_0\">The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be represented.</p>\n</blockquote>\n<p>Table 6 lists the the order of integer literals as roughly, int, unsigned int, long int, unsigned long int, ... etc</p>\n<p>Based on the above, that is why the compiler is assigning boost::variant an int type.</p>\n", "OwnerUserId": "267471", "PostTypeId": "2", "Id": "23687929", "Score": "0", "CreationDate": "2014-05-15T20:24:15.623", "LastActivityDate": "2014-05-15T20:24:15.623"}, "bq_ids": {"n4140": {"so_23687534_23687929_0": {"section_id": 5341, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_23687534_23687929_0": {"section_id": 5138, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_23687534_23687929_0": {"section_id": 6762, "quality": 0.8333333333333334, "length": 10}}}});