post_cb({"32415678": {"ParentId": "32415552", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Take a look at the initialization of your atomic variables. Clang for instance brings up a warning.</p>\n<pre><code>volatile atomic_int opDone = 0;\n// error: copying variable of type 'atomic_int' (aka '__atomic_base') invokes deleted constructor\n</code></pre>\n<p>The working draft (current N4527) says the following in \u00a78.5.15.</p>\n<blockquote>\n<p id=\"so_32415552_32415678_0\"><strong>The initialization that occurs in the = form of a</strong>\n<strong>brace-or-equal-initializer</strong> or condition (6.4), as well as in argument\n  passing, function return, throwing an exception (15.1), handling an\n  exception (15.3), and aggregate member initialization (8.5.1), <strong>is\n  called copy-initialization</strong>. [ Note: Copy-initialization may invoke a\n  move (12.8). \u2014 end note ]</p>\n</blockquote>\n<p>The reason is you can't copy atomics. All loads and stores must happen with an explicit call. A fix to the following way should fix the issue:</p>\n<pre><code>static atomic_int opDone(0);\n</code></pre>\n", "OwnerUserId": "1385931", "LastEditorUserId": "1385931", "LastEditDate": "2015-09-05T17:15:39.797", "Id": "32415678", "Score": "0", "CreationDate": "2015-09-05T17:09:59.287", "LastActivityDate": "2015-09-05T17:15:39.797"}, "32415552": {"CommentCount": "0", "ViewCount": "54", "CreationDate": "2015-09-05T16:54:22.680", "LastActivityDate": "2015-09-05T17:15:39.797", "Title": "Synchronization in Windows C++", "AcceptedAnswerId": "32415678", "PostTypeId": "1", "Id": "32415552", "Score": "0", "Body": "<p>I need to implement the following system: 1 writer and 3 readers in mutual-exclusion, but the 3 readers could read in the same time. The writer writes on a shared variable called dato a random number, the readers must print it to the console. The output expected is: \nI wrote: 7; I read: 7 ; I read: 7 ; I read: 7\nI wrote: 1; I read: 1 ; I read: 1 ; I read: 1\nI wrote: 9; I read: 9 ; I read: 9 ; I read: 9</p>\n<p>I used two unique_lock on the mutex m, and two condition_variables: cv1 for the readers (they can read only if writer already wrote) and cv2 for the writer (it could write just if all readers have read). </p>\n<p>In order to guarantee parallel read, after the wait I unlocked, and I take the lock after the cout instruction. I think that writer could not take the lock because when they're reading, he is on the wait, and the condition opDone == 3 isn't valid. </p>\n<p>Instead, the output is: \nI wrote: 1\nI read: 1\nI read: I read: 1\nI read: 1\nI read: 1\n1</p>\n<p>This is the code: </p>\n<pre><code>// nreader1writer.cpp : Defines the entry point for the console application.\n\n#include \"stdafx.h\"\n\ncondition_variable cv1, cv2;\nmutex m;\nvolatile atomic_int opDone = 0;\nvolatile atomic_bool iWrote = false;\nvolatile atomic_bool flag = false;\n\nvolatile atomic_int dato;\n\nvoid writer();\nvoid reader();\n\nint _tmain()\n{\n    thread t1(reader);\n    thread t2(reader);\n    thread t3(reader);\n    thread t4(writer);\n\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    return 0;\n}\n\nvoid writer() {\n    unique_lock &lt;mutex&gt; ulw (m, defer_lock);\n    while (opDone.load() != 3); //In this way, writer starts just when all readers are already waiting \n    ulw.lock();\n    opDone.store(0);\n    iWrote.store(false);\n\n    while (1) { \n        dato.store( (int) rand()%10);\n        cout &lt;&lt; \"I wrote: \" &lt;&lt; dato.load() &lt;&lt; endl;\n        iWrote.store(true);\n        cv1.notify_all();\n        cv2.wait(ulw, []() {\n            return (opDone.load() == 3);\n        });\n        opDone.store(0);\n        iWrote.store(false);\n    }\n}\n\nvoid reader() {\n    unique_lock &lt;mutex&gt; ulr (m, defer_lock);\n    ulr.lock();\n    opDone.fetch_add(1);\n\n    while (1) {\n        cv1.wait(ulr, []() {\n            return (iWrote.load() == true &amp;&amp; opDone.load() &lt; 3);\n        });\n        ulr.unlock();\n        cout &lt;&lt; \"I read: \" &lt;&lt; dato &lt;&lt; endl;\n        ulr.lock();\n        opDone.fetch_add(1);\n        cv2.notify_one();\n    }\n}\n</code></pre>\n<p>The code perfectly run if I don't unlock( ) before read, but in this way the reading operation are not parallel.. Any suggestion?</p>\n", "Tags": "<c++><multithreading><visual-studio><mutex><condition-variable>", "OwnerUserId": "2626084", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32415552_32415678_0": {"section_id": 3294, "quality": 0.6451612903225806, "length": 20}}, "n3337": {"so_32415552_32415678_0": {"section_id": 3164, "quality": 0.6451612903225806, "length": 20}}, "n4659": {"so_32415552_32415678_0": {"section_id": 4056, "quality": 0.7096774193548387, "length": 22}}}});