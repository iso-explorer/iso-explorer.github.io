post_cb({"30036548": {"ParentId": "30036255", "CommentCount": "6", "Body": "<p>There's a note in [namespace.udecl]/p17 that addresses this situation directly:</p>\n<blockquote>\n<p id=\"so_30036255_30036548_0\">[ <em>Note</em>: Because a <em>using-declaration</em> designates a base class member\n  (and not a member subobject or a member function of a base class\n  subobject), a <em>using-declaration</em> cannot be used to resolve inherited\n  member ambiguities. For example,</p>\n<pre><code>struct A { int x(); };\nstruct B : A { };\nstruct C : A {\n    using A::x;\n    int x(int);\n};\nstruct D : B, C {\n    using C::x;\n    int x(double);\n};\nint f(D* d) {    \n    return d-&gt;x(); // ambiguous: B::x or C::x\n}\n</code></pre>\n<p id=\"so_30036255_30036548_1\">\u2014<em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "30036548", "Score": "28", "CreationDate": "2015-05-04T17:48:24.667", "LastActivityDate": "2015-05-04T17:48:24.667"}, "30036645": {"ParentId": "30036255", "CommentCount": "2", "Body": "<p>Someone else can find the standard quote but I'm going to explain conceptually.</p>\n<p>It doesn't work because a <em>using-declaration</em> <strong>only affects name lookup.</strong></p>\n<p>Your <em>using-declaration</em> causes name lookup to succeed where it would otherwise fail, that is, it tells the compiler <em>where to find the function <code>f</code>.</em> But it does not tell it <em>which <code>A</code> subobject <code>f</code> acts on</em>, that is, which one will be passed as the implicit <code>this</code> parameter when <code>f</code> is called.</p>\n<p>There is only a single function <code>A::f</code> even though there are two <code>A</code> subobjects of <code>C</code>, and it takes an implicit <code>this</code> argument of type <code>A*</code>. In order to call it on a <code>C</code> object, <code>C*</code> must be implicitly converted to <code>A*</code>. This is always ambiguous, and is not affected by any <em>using-declarations</em>.</p>\n<p>(This makes more sense if you put data members inside <code>A</code>. Then <code>C</code> would have two of each such data member. When <code>f</code> is called, if it accesses data members, does it access the ones in the <code>A</code> subobject inherited from <code>B1</code>, or the ones in the <code>A</code> subobject inherited from <code>B2</code>?)</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "30036645", "Score": "56", "CreationDate": "2015-05-04T17:53:58.323", "LastActivityDate": "2015-05-04T17:53:58.323"}, "30036255": {"CommentCount": "12", "AcceptedAnswerId": "30036645", "PostTypeId": "1", "LastEditorUserId": "671092", "CreationDate": "2015-05-04T17:31:26.673", "LastActivityDate": "2015-05-06T19:34:29.037", "LastEditDate": "2015-05-06T19:34:29.037", "ViewCount": "3302", "FavoriteCount": "7", "Title": "Why doesn't a using-declaration work to solve the diamond proble\u200bm?", "Id": "30036255", "Score": "50", "Body": "<p>Please consider the following code:</p>\n<pre><code>struct A\n{\n    void f()\n    {\n    }\n};\n\nstruct B1 : A\n{\n};\n\nstruct B2 : A\n{\n};\n\nstruct C : B1, B2\n{\n    void f() // works\n    {\n        B1::f();\n    }\n    //using B1::f; // does not work\n    //using B1::A::f; // does not work as well\n};\n\nint main()\n{\n    C c;\n    c.f();\n\n    return 0;\n}\n</code></pre>\n<p>I kindly ask you not to copy paste a standard reply on how to solve the diamond problem (\"use virtual inheritance\"). What I am asking here is why doesn't a using-declaration work in this case. The exact compiler error is:</p>\n<pre><code>In function 'int main()':\nprog.cpp:31:6: error: 'A' is an ambiguous base of 'C'\n  c.f();\n</code></pre>\n<p>I got the impression a using-declaration should work from this example:</p>\n<pre><code>struct A\n{\n    void f()\n    {\n    }\n};\n\nstruct B\n{\n    void f()\n    {\n    }\n};\n\nstruct C : A, B\n{\n    using A::f;\n};\n\nint main()\n{\n    C c;\n    c.f(); // will call A::f\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><inheritance><subclass><using-directives><diamond-problem>", "OwnerUserId": "671092", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30036255_30036657_0": {"section_id": 6991, "quality": 0.825, "length": 33}, "so_30036255_30036548_0": {"section_id": 5506, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_30036255_30036657_0": {"section_id": 6737, "quality": 0.875, "length": 35}, "so_30036255_30036548_0": {"section_id": 5292, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_30036255_30036657_0": {"section_id": 8489, "quality": 0.825, "length": 33}, "so_30036255_30036548_0": {"section_id": 6941, "quality": 0.7727272727272727, "length": 17}}}, "30036657": {"ParentId": "30036255", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>In addition to T.C.'s answer, I'd like to add that the name lookup in derived class is explained in the standard pretty much in detail in section 10.2.  </p>\n<p>Here what is said about processing of using-declarations :  </p>\n<blockquote>\n<p id=\"so_30036255_30036657_0\"><strong>10.2/3:</strong> The lookup set (...) consists of two component sets: the declaration set, a set of members named f; and the subobject set, a set of subobjects where declarations of these members (possibly including\n  using-declarations) were found. In the declaration set, <strong>using-declarations are replaced</strong> by the members they designate, and type declarations (including\n  injected-class-names) are replaced by the types they designate.</p>\n</blockquote>\n<p>So when you try to declare in <code>struct C</code> </p>\n<pre><code>using B1::f; // you hope to make clear that B1::f is to be used\n</code></pre>\n<p>according to the lookup rules, your compiler nevertheless finds the possible candidates:  <code>B1::f</code> and <code>B2::f</code> so that it's still ambiguous.  </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2015-05-04T18:20:51.143", "Id": "30036657", "Score": "5", "CreationDate": "2015-05-04T17:54:46.037", "LastActivityDate": "2015-05-04T18:20:51.143"}});