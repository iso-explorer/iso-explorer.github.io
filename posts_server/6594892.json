post_cb({"bq_ids": {"n4140": {"so_6594892_6595333_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6046}}, "n3337": {"so_6594892_6595333_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5814}}, "n4659": {"so_6594892_6595333_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 41}}}, "6594892": {"ViewCount": "507", "Body": "<p>There's a set of questions regarding cross-casts (cast from <code>T1*</code> to unrelated <code>T2*</code>), for example <a href=\"https://stackoverflow.com/q/1863069/57428\">this</a> and <a href=\"https://stackoverflow.com/q/6594395/57428\">this</a>. The answer usually goes like this: <code>reinterpret_cast</code> is implementation defined and conversion to <code>void*</code> followed by <code>static_cast</code> is well-defined. Yet I haven't see any real examples of what can go wrong when <code>reinterpret_cast</code> is used.</p>\n<p>What are real-life examples where casting through <code>void*</code> works and <code>reinterpret_cast</code> doesn't?</p>\n", "Title": "May I have a real life example where casting through void* works and reinterpret_cast doesn't?", "CreationDate": "2011-07-06T10:24:47.783", "LastActivityDate": "2011-07-06T11:02:56.793", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:24:31.680", "LastEditorUserId": "-1", "Id": "6594892", "Score": "8", "OwnerUserId": "57428", "Tags": "<c++><casting><reinterpret-cast><static-cast>", "AnswerCount": "2"}, "6595333": {"Id": "6595333", "PostTypeId": "2", "Body": "<p>casting from T1* to unrelated T2* with reinterpret_cast is not less defined than with static_cast. Actually, when both T1 and T2 are standard layout types it works the same (see 5.2.10/7):</p>\n<blockquote>\n<p id=\"so_6594892_6595333_0\">When a prvalue v of type \u201cpointer to\n  T1\u201d is converted to the type \u201cpointer\n  to cv T2\u201d, the result is\n  static_cast&lt;cv T2*&gt;(static_cast&lt;cv\n  void*&gt;(v))</p>\n</blockquote>\n<p>For non-standard layout types the result of conversion is unspecified, but it's unspecified for static_cast as well.</p>\n<p>I guess, you can get a difference only when casting non-pointer types in artificial cases like this:</p>\n<pre>\n<code>\nstruct Foo\n{\n};\n\nstruct Bar\n{\n    operator void*()\n    {\n        return 0;\n    }\n};\n\nint main ()\n{\n  Bar b;\n  Foo * p1 = static_cast&lt;Foo*&gt;(static_cast&lt;void *&gt;(b)); // ok, Bar::operator void* -&gt; static_cast\n  Foo * p2 = reinterpret_cast&lt;Foo*&gt;(b); // error, no conversion from Bar to Foo*.\n}\n</code>\n</pre>\n", "LastActivityDate": "2011-07-06T11:02:56.793", "CommentCount": "1", "CreationDate": "2011-07-06T11:02:56.793", "ParentId": "6594892", "Score": "0", "OwnerUserId": "381333"}, "6595080": {"Id": "6595080", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6594892_6595080_0\">real-life examples where casting\n  through void* works and\n  reinterpret_cast doesn't</p>\n</blockquote>\n<p>If I interpret this sentence as, casting through <code>void*</code> works <strong>to help me avoid undefined behavior</strong> and <code>reinterpret_cast</code> doesn't then following is an example.</p>\n<p><code>reinterpret_cast&lt;TYPE*&amp;&gt;</code> (pointer reference) may break strict aliasing rule (it happens for g++ at least) and leads you to an undefined behavior. <a href=\"http://www.ideone.com/nBklh\" rel=\"nofollow\">Demo</a>.</p>\n<p>However, <code>static_cast&lt;void*&amp;&gt;</code> will result in compiler error and save you from such undefined behavior. <a href=\"http://www.ideone.com/IckaX\" rel=\"nofollow\">Demo</a>.</p>\n<p>I have seen such use in a smart pointer:</p>\n<pre><code>template&lt;class TYPE&gt;\nstruct SmartPointer\n{\n  void *p;\n  TYPE&amp; operator ++ ()\n  {\n    (reinterpret_cast&lt;TYPE*&amp;&gt;(p))++;  // breaking strict aliasing rule\n    return *this;\n  }\n}\n</code></pre>\n", "LastActivityDate": "2011-07-06T10:41:24.587", "CommentCount": "8", "CreationDate": "2011-07-06T10:41:24.587", "ParentId": "6594892", "Score": "1", "OwnerUserId": "514235"}});