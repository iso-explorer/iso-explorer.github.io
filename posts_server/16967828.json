post_cb({"bq_ids": {"n4140": {"so_16967828_16967892_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5047}, "so_16967828_16967892_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5047}}, "n3337": {"so_16967828_16967892_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 1368}, "so_16967828_16967892_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 1368}}, "n4659": {"so_16967828_16967892_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 1506}}}, "16968342": {"Id": "16968342", "PostTypeId": "2", "Body": "<p>Unfortunately, if we use srand we change internal seed-value. I mean, the next random numbers will be predetermined. And, first decision:</p>\n<pre><code>std::srand ( 42 );\nstd::random_shuffle ( vector1.begin(), vector1.end() );\nstd::srand ( 42 );\nstd::random_shuffle ( vector2.begin(), vector2.end() );\nstd::srand ( unsigned ( std::time(0) ) );\n// Post-code.\n</code></pre>\n<p>To save rand for post-code.</p>\n<p>Second decision - it's Mark Ransom solution - it doesn't call std::srand at all (and, I just notice, it has a higher performance).</p>\n", "LastEditorUserId": "1606848", "LastActivityDate": "2013-06-06T17:28:00.920", "Score": "0", "CreationDate": "2013-06-06T17:22:17.167", "ParentId": "16967828", "CommentCount": "0", "OwnerUserId": "1606848", "LastEditDate": "2013-06-06T17:28:00.920"}, "16969267": {"Id": "16969267", "PostTypeId": "2", "Body": "<p>As other's have shown, re-seeding with the same seed should allow you to replicate the same shuffle multiple times. However, if you can use C++11 I'd recommend implementing this without using <code>srand()</code> and <code>random_shuffle()</code>; instead you should use the <code>&lt;random&gt;</code> library with <code>std::shuffle</code>.</p>\n<p>First, if possible <code>rand</code> should be avoided. Aside from the fact that it isn't usually a very good pRNG, it also has problems with thread safety due to shared state. The <code>&lt;random&gt;</code> library fixes both these problems by giving the programmer explicit control over pRNG state and by providing several options with guaranteed performance, size, and quality characteristics.</p>\n<p>Secondly, <code>random_shuffle</code> isn't actually specified to use <code>rand</code> so it's theoretically legal for reseeding using <code>srand</code> not to have the effect you want. To get guaranteed results with <code>random_shuffle</code> you have to write your own generator. Moving to <code>shuffle</code> fixes that, as you can directly use standard engines.</p>\n<pre><code>#include &lt;algorithm&gt; // shuffle, copy\n#include &lt;iostream&gt;  // cout\n#include &lt;iterator&gt;  // begin, end, ostream_iterator\n#include &lt;numeric&gt;   // iota\n#include &lt;random&gt;    // default_random_engine, random_device\n#include &lt;vector&gt;    // vector\n\nint main() {\n  std::vector&lt;int&gt; v1(10);\n  std::iota(begin(v1), end(v1), 1);\n  auto v2 = v1;\n\n  std::random_device r;\n  std::seed_seq seed{r(), r(), r(), r(), r(), r(), r(), r()};\n\n  // create two random engines with the same state\n  std::mt19937 eng1(seed);\n  auto eng2 = eng1;\n\n  std::shuffle(begin(v1), end(v1), eng1);\n  std::shuffle(begin(v2), end(v2), eng2);\n\n  std::copy(begin(v1), end(v1), std::ostream_iterator&lt;int&gt;(std::cout, \" \"));\n  std::cout &lt;&lt; \"\\n\\n\";\n  std::copy(begin(v2), end(v2), std::ostream_iterator&lt;int&gt;(std::cout, \" \"));\n  std::cout &lt;&lt; \"\\n\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "365496", "LastActivityDate": "2016-01-21T18:55:55.277", "Score": "4", "CreationDate": "2013-06-06T18:16:49.287", "ParentId": "16967828", "CommentCount": "1", "OwnerUserId": "365496", "LastEditDate": "2016-01-21T18:55:55.277"}, "16967828": {"ViewCount": "2749", "Body": "<p>I have two vectors:</p>\n<blockquote>\n<p id=\"so_16967828_16967828_0\">vector1 = [1 2 3 4 5 6 7 8 9]</p>\n<p id=\"so_16967828_16967828_1\">vector2 = [1 2 3 4 5 6 7 8 9]</p>\n</blockquote>\n<p>I want to ensure, that when I shuffle both using <strong>random_shuffle</strong> they should be shuffled in the same corresponding order. For example:</p>\n<p>Output after shuffling should be like:</p>\n<blockquote>\n<p id=\"so_16967828_16967828_2\">vector1 = [1 9 3 4 2 7 8 5 6]</p>\n<p id=\"so_16967828_16967828_3\">vector2 = [1 9 3 4 2 7 8 5 6]</p>\n</blockquote>\n<p>But I am getting output like:</p>\n<blockquote>\n<p id=\"so_16967828_16967828_4\">vector1 = [5 1 7 4 2 3 9 8 6]</p>\n<p id=\"so_16967828_16967828_5\">vector2 = [3 4 1 9 8 2 5 7 6]</p>\n</blockquote>\n<p>Heres my code:</p>\n<pre><code>int main () \n{\n  std::srand ( unsigned ( std::time(0) ) );\n  std::vector&lt;int&gt; vector1, vector2;\n\n  // set some values:\n  for (int i=1; i&lt;10; ++i)\n  {\n    vector1.push_back(i);\n    vector2.push_back(i);\n  }\n\n  // using built-in random generator:\n  std::random_shuffle ( vector1.begin(), vector1.end() );\n  std::random_shuffle ( vector2.begin(), vector2.end() );\n\n  // print out content:\n  std::cout &lt;&lt; \"vector1 contains:\";\n  for ( std::vector&lt;int&gt;::iterator it1 = vector1.begin(); it1 != vector1.end(); ++it1 )\n    std::cout &lt;&lt; ' ' &lt;&lt; *it1;\n\n  std::cout &lt;&lt; '\\n';\n  std::cout &lt;&lt; '\\n';\n\n  std::cout &lt;&lt; \"vector2 contains:\";\n  for ( std::vector&lt;int&gt;::iterator it2 = vector2.begin(); it2 != vector2.end(); ++it2 )\n    std::cout &lt;&lt; ' ' &lt;&lt; *it2;\n\n  std::cout &lt;&lt; '\\n';\n  std::cout &lt;&lt; '\\n';\n\n  return 0;\n}\n</code></pre>\n<p><strong>EDIT</strong> This is an example case that I tried to implement. In practise, I have one vector of images and one vector of corresponding labels. I need them to be shuffled in the same manner. Could anybody please help......\nthanks a lot!!</p>\n", "AcceptedAnswerId": "16968081", "Title": "How to ensure two different vectors are shuffled in the same order in C++?", "CreationDate": "2013-06-06T16:53:12.403", "Id": "16967828", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-06-06T16:57:37.610", "LastEditorUserId": "2346085", "LastActivityDate": "2016-01-21T18:55:55.277", "ClosedDate": "2013-06-07T06:41:45.123", "Score": "14", "OwnerUserId": "2346085", "Tags": "<c++><random><vector>", "AnswerCount": "8"}, "16968100": {"Id": "16968100", "PostTypeId": "2", "Body": "<p>Why don't you write your own shuffle:</p>\n<pre><code>for( size_t i = 0 ; i &lt; numitems; ++i )\n{\n    size_t next = random() % numitems ;\n    swap( v1[i], v1[next] );\n    swap( v2[i], v2[next] );\n}\n</code></pre>\n", "LastActivityDate": "2013-06-06T17:08:41.973", "CommentCount": "5", "CreationDate": "2013-06-06T17:08:41.973", "ParentId": "16967828", "Score": "-2", "OwnerUserId": "2165677"}, "16968328": {"Id": "16968328", "PostTypeId": "2", "Body": "<p>If both have to have the same order, why are they separate\nvectors?  The logical solution would be something like:</p>\n<pre><code>struct ImageData\n{\n    Image myImage;\n    std::string myLabel;\n    //  ...\n};\n</code></pre>\n<p>You then have a single vector of <code>ImageData</code> which you shuffle. </p>\n", "LastActivityDate": "2013-06-06T17:21:16.870", "CommentCount": "0", "CreationDate": "2013-06-06T17:21:16.870", "ParentId": "16967828", "Score": "2", "OwnerUserId": "649665"}, "16968081": {"Id": "16968081", "PostTypeId": "2", "Body": "<p>Instead of shuffling the vectors themselves, shuffle a vector of indexes into the other vectors. Since you'll be using the same indexes for both, they're guaranteed to be in the same order.</p>\n<pre><code>std::vector&lt;int&gt; indexes;\nindexes.reserve(vector1.size());\nfor (int i = 0; i &lt; vector1.size(); ++i)\n    indexes.push_back(i);\nstd::random_shuffle(indexes.begin(), indexes.end());\n\nstd::cout &lt;&lt; \"vector1 contains:\";\nfor ( std::vector&lt;int&gt;::iterator it1 = indexes.begin(); it1 != indexes.end(); ++it1 )\n    std::cout &lt;&lt; ' ' &lt;&lt; vector1[*it1];\n</code></pre>\n", "LastActivityDate": "2013-06-06T17:07:34.047", "CommentCount": "8", "CreationDate": "2013-06-06T17:07:34.047", "ParentId": "16967828", "Score": "25", "OwnerUserId": "5987"}, "16968230": {"Id": "16968230", "PostTypeId": "2", "Body": "<p>You could create an random access iterator which if its dereferenced returns a std::tuple to references of elements of the corresponding vectors. So you could shuffle them inplace. Or you look at <a href=\"http://www.boost.org/doc/libs/1_53_0/libs/iterator/doc/zip_iterator.html\" rel=\"nofollow\">the boost version</a>.\nSo it should look something like this:</p>\n<pre><code>std::random_shuffle(\n  boost::make_zip_iterator(\n    boost::make_tuple(vector1.begin(), vector2.begin())\n  ),\n  boost::make_zip_iterator(\n    boost::make_tuple(vector1.end(), vector2.end()\n  ),\n</code></pre>\n<p>);</p>\n<p>This shuffles your data inplace, works with more than two vectors and is self documenting if you know what <code>make_zip_iterator</code> does. Of course it should be faster than shuffle two times or use a third vector.</p>\n", "LastEditorUserId": "1918154", "LastActivityDate": "2013-06-06T17:42:13.900", "Score": "2", "CreationDate": "2013-06-06T17:16:15.200", "ParentId": "16967828", "CommentCount": "2", "OwnerUserId": "1918154", "LastEditDate": "2013-06-06T17:42:13.900"}, "16967892": {"Id": "16967892", "PostTypeId": "2", "Body": "<p>Make sure you use the same seed for both calls to <code>random_shuffle()</code>:</p>\n<pre><code>auto seed = unsigned ( std::time(0) );\n\n// ...\n\nstd::srand ( seed );\nstd::random_shuffle ( vector1.begin(), vector1.end() );\n\nstd::srand ( seed );\nstd::random_shuffle ( vector2.begin(), vector2.end() );\n</code></pre>\n<p>Notice, however, that the Standard does not specify that <code>random_shuffle()</code> should use the <code>rand()</code> function to generate a random permutation - this is implementation-defined. Therefore, <code>srand()</code> will not affect the result of <code>random_shuffle()</code> on implementations that do not use <code>rand()</code>.</p>\n<p>Paragraph 25.3.12/4 of the C++11 Standard on <code>random_shuffle()</code> specifies:</p>\n<blockquote>\n<p id=\"so_16967828_16967892_0\"><em>Remarks</em>: To the extent that the implementation of these functions makes use of random numbers, the\n  implementation shall use the following sources of randomness:</p>\n<p id=\"so_16967828_16967892_1\">The underlying source of random numbers for the first form of the function is implementation-defined.\n  An implementation <strong>may</strong> use the <code>rand</code> function from the standard C library. [...]</p>\n</blockquote>\n<p>Therefore, if you want to make sure you are writing portable code, use the version of <code>random_shuffle()</code> that accepts a random number generator as a third argument, so that you have control over the seeding.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-06T17:03:48.013", "Score": "14", "CreationDate": "2013-06-06T16:56:27.523", "ParentId": "16967828", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-06-06T17:03:48.013"}, "16967880": {"Id": "16967880", "PostTypeId": "2", "Body": "<p>Seed the pseudo-random number generator with a reproducible value before each time you shuffle.</p>\n<pre><code>std::srand ( 42 );\nstd::random_shuffle ( vector1.begin(), vector1.end() );\nstd::srand ( 42 );\nstd::random_shuffle ( vector2.begin(), vector2.end() );\n</code></pre>\n", "LastActivityDate": "2013-06-06T16:55:24.007", "CommentCount": "0", "CreationDate": "2013-06-06T16:55:24.007", "ParentId": "16967828", "Score": "2", "OwnerUserId": "817643"}});