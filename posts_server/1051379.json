post_cb({"1051379": {"CreationDate": "2009-06-26T21:36:19.087", "ViewCount": "33399", "FavoriteCount": "119", "Id": "1051379", "AcceptedAnswerId": "1051468", "Score": "180", "Title": "Is there a difference in C++ between copy initialization and direct initialization?", "LastEditorUserId": "2246380", "CommentCount": "1", "Body": "<p>Suppose I have this function:</p>\n<pre><code>void my_test()\n{\n    A a1 = A_factory_func();\n    A a2(A_factory_func());\n\n    double b1 = 0.5;\n    double b2(0.5);\n\n    A c1;\n    A c2 = A();\n    A c3(A());\n}\n</code></pre>\n<p>In each grouping, are these statements identical? Or is there an extra (possibly optimizable) copy in some of the initializations?</p>\n<p>I have seen people say both things. Please <strong>cite</strong> text as proof. Also add other cases please.</p>\n", "Tags": "<c++><initialization>", "LastEditDate": "2016-05-12T20:19:39.667", "LastActivityDate": "2016-11-14T15:34:08.010", "PostTypeId": "1", "AnswerCount": "7", "OwnerUserId": "72631"}, "1051420": {"LastActivityDate": "2009-06-26T22:03:25.630", "CommentCount": "3", "Body": "<p>A lot of these cases are subject to an object's implementation so it's hard to give you a concrete answer.</p>\n<p>Consider the case</p>\n<pre><code>A a = 5;\nA a(5);\n</code></pre>\n<p>In this case assuming a proper assignment operator &amp; initializing constructor which accept a single integer argument, how I implement said methods affects the behavior of each line. It is common practice however for one of those to call the other in the implementation as to eliminate duplicate code (although in a case as simple as this there would be no real purpose.)</p>\n<p>Edit: As mentioned in other responses, the first line will in fact call the copy constructor. Consider the comments relating to the assignment operator as behavior pertaining to a stand alone assignment.</p>\n<p>That said, how the compiler optimizes the code will then have it's own impact. If I have the initializing constructor calling the \"=\" operator - if the compiler makes no optimizations, the top line would then perform 2 jumps as opposed to one in the bottom line. </p>\n<p>Now, for the most common situations, your compiler will optimize through these cases and eliminate this type of inefficiencies. So effectively all the different situations you describe will turn out the same. If you want to see exactly what is being done, you can look at the object code or an assembly output of your compiler.</p>\n", "CreationDate": "2009-06-26T21:52:40.223", "LastEditDate": "2009-06-26T22:03:25.630", "ParentId": "1051379", "Id": "1051420", "LastEditorUserId": "127883", "PostTypeId": "2", "Score": "0", "OwnerUserId": "127883"}, "7692479": {"CommentCount": "0", "Body": "<p>Of note:</p>\n<p>[12.2/1] <code>Temporaries of class type are created in various contexts: ... and in some initializations (8.5).</code></p>\n<p>I.e., for copy-initialization.</p>\n<p>[12.8/15] <code>When certain criteria are met, an implementation is allowed to omit the copy construction of a class object ...</code></p>\n<p>In other words, a good compiler will <em>not</em> create a copy for copy-initialization when it can be avoided; instead it will just call the constructor directly -- ie, just like for direct-initialization.</p>\n<p>In other words, copy-initialization is just like direct-initialization in most cases &lt;opinion&gt; where understandable code has been written.  Since direct-initialization potentially causes arbitrary (and therefore probably unknown) conversions, I prefer to always use copy-initialization when possible.  (With the bonus that it actually looks like initialization.)&lt;/opinion&gt;</p>\n<p>Technical goriness:\n[12.2/1 cont from above] <code>Even when the creation of the temporary object is avoided (12.8), all the semantic restrictions must be respected as if the temporary object was created.</code></p>\n<p>Glad I'm not writing a C++ compiler.</p>\n", "CreationDate": "2011-10-07T20:20:08.413", "ParentId": "1051379", "Id": "7692479", "LastActivityDate": "2011-10-07T20:20:08.413", "PostTypeId": "2", "Score": "3", "OwnerUserId": "890753"}, "1051395": {"LastActivityDate": "2009-07-08T19:47:10.017", "CommentCount": "6", "Body": "<p><strong>Assignment</strong> is different from <strong>initialization</strong>.</p>\n<p>Both of the following lines do <em>initialization</em>. A single constructor call is done:</p>\n<pre><code>A a1 = A_factory_func();  // calls copy constructor\nA a1(A_factory_func());   // calls copy constructor\n</code></pre>\n<p>but it's not equivalent to:</p>\n<pre><code>A a1;                     // calls default constructor\na1 = A_factory_func();    // (assignment) calls operator =\n</code></pre>\n<p>I don't have a text at the moment to prove this but it's very easy to experiment:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    A() { \n        cout &lt;&lt; \"default constructor\" &lt;&lt; endl;\n    }\n\n    A(const A&amp; x) { \n        cout &lt;&lt; \"copy constructor\" &lt;&lt; endl;\n    }\n\n    const A&amp; operator = (const A&amp; x) {\n        cout &lt;&lt; \"operator =\" &lt;&lt; endl;\n        return *this;\n    }\n};\n\nint main() {\n    A a;       // default constructor\n    A b(a);    // copy constructor\n    A c = a;   // copy constructor\n    c = b;     // operator =\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2009-06-26T21:42:36.063", "LastEditDate": "2009-07-08T19:47:10.017", "ParentId": "1051379", "Id": "1051395", "LastEditorUserId": "33708", "PostTypeId": "2", "Score": "36", "OwnerUserId": "33708"}, "1051468": {"LastActivityDate": "2016-11-14T15:34:08.010", "CommentCount": "24", "Body": "<pre><code>A a1 = A_factory_func();\nA a2(A_factory_func());\n</code></pre>\n<p>Depends on what type <code>A_factory_func()</code> returns. I assume it returns an <code>A</code> - then it's doing the same - except that when the copy constructor is explicit, then the first one will fail. Read <a href=\"http://eel.is/c++draft/dcl.init#14\" rel=\"noreferrer\">8.6/14</a></p>\n<pre><code>double b1 = 0.5;\ndouble b2(0.5);\n</code></pre>\n<p>This is doing the same because it's a built-in type (this means not a class type here). Read <a href=\"http://eel.is/c++draft/dcl.init#14\" rel=\"noreferrer\">8.6/14</a>. </p>\n<pre><code>A c1;\nA c2 = A();\nA c3(A());\n</code></pre>\n<p>This is not doing the same. The first default-initializes if <code>A</code> is a non-POD, and doesn't do any initialization for a POD (Read <a href=\"http://eel.is/c++draft/dcl.init#9\" rel=\"noreferrer\">8.6/9</a>). The second copy initializes: Value-initializes a temporary and then copies that value into <code>c2</code> (Read <a href=\"http://eel.is/c++draft/expr.type.conv#2\" rel=\"noreferrer\">5.2.3/2</a> and <a href=\"http://eel.is/c++draft/dcl.init#14\" rel=\"noreferrer\">8.6/14</a>). This of course will require a non-explicit copy constructor (Read <a href=\"http://eel.is/c++draft/dcl.init#14\" rel=\"noreferrer\">8.6/14</a> and <a href=\"http://eel.is/c++draft/class.conv.ctor#3\" rel=\"noreferrer\">12.3.1/3</a> and <a href=\"http://eel.is/c++draft/over.match.ctor#1\" rel=\"noreferrer\">13.3.1.3/1</a> ). The third creates a function declaration for a function <code>c3</code> that returns an <code>A</code> and that takes a function pointer to a function returning a <code>A</code> (Read <a href=\"http://eel.is/c++draft/dcl.ambig.res\" rel=\"noreferrer\">8.2</a>).</p>\n<hr>\n<p><strong>Delving into Initializations</strong> Direct and Copy initialization</p>\n<p>While they look identical and are supposed to do the same, these two forms are remarkably different in certain cases. The two forms of initialization are direct and copy initialization:</p>\n<pre><code>T t(x);\nT t = x;\n</code></pre>\n<p>There is behavior we can attribute to each of them:</p>\n<ul>\n<li>Direct initialization behaves like a function call to an overloaded function: The functions, in this case, are the constructors of <code>T</code> (including <code>explicit</code> ones), and the argument is <code>x</code>. Overload resolution will find the best matching constructor, and when needed will do any implicit conversion required. </li>\n<li>Copy initialization constructs an implicit conversion sequence: It tries to convert <code>x</code> to an object of type <code>T</code>. (It then may copy over that object into the to-initialized object, so a copy constructor is needed too - but this is not important below)</li>\n</ul>\n<p>As you see, <em>copy initialization</em> is in some way a part of direct initialization with regard to possible implicit conversions: While direct initialization has all constructors available to call, and <em>in addition</em> can do any implicit conversion it needs to match up argument types, copy initialization can just set up one implicit conversion sequence. </p>\n<p>I tried hard and <a href=\"http://coliru.stacked-crooked.com/a/708ae8b380c63ba8\" rel=\"noreferrer\">got the following code to output different text for each of those forms</a>, without using the \"obvious\" through <code>explicit</code> constructors.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct B;\nstruct A { \n  operator B();\n};\n\nstruct B { \n  B() { }\n  B(A const&amp;) { std::cout &lt;&lt; \"&lt;direct&gt; \"; }\n};\n\nA::operator B() { std::cout &lt;&lt; \"&lt;copy&gt; \"; return B(); }\n\nint main() { \n  A a;\n  B b1(a);  // 1)\n  B b2 = a; // 2)\n}\n// output: &lt;direct&gt; &lt;copy&gt;\n</code></pre>\n<p>How does it work, and why does it output that result? </p>\n<ol>\n<li><p><strong>Direct initialization</strong></p>\n<p>It first doesn't know anything about conversion. It will just try to call a constructor. In this case, the following constructor is available and is an <em>exact match</em>: </p>\n<pre><code>B(A const&amp;)\n</code></pre>\n<p>There is no conversion, much less a user defined conversion, needed to call that constructor (note that no const qualification conversion happens here either). And so direct initialization will call it. </p></li>\n<li><p><strong>Copy initialization</strong></p>\n<p>As said above, copy initialization will construct a conversion sequence when <code>a</code> has not type <code>B</code> or derived from it (which is clearly the case here). So it will look for ways to do the conversion, and will find the following candidates</p>\n<pre><code>B(A const&amp;)\noperator B(A&amp;);\n</code></pre>\n<p>Notice how I rewrote the conversion function: The parameter type reflects the type of the <code>this</code> pointer, which in a non-const member function is to non-const. Now, we call these candidates with <code>x</code> as argument. The winner is the conversion function: Because if we have two candidate functions both accepting a reference to the same type, then the <em>less const</em> version wins (this is, by the way, also the mechanism that prefers non-const member function calls for non-const objects). </p>\n<p>Note that if we change the conversion function to be a const member function, then the conversion is ambiguous (because both have a parameter type of <code>A const&amp;</code> then): The Comeau compiler rejects it properly, but GCC accepts it in non-pedantic mode. Switching to <code>-pedantic</code> makes it output the proper ambiguity warning too, though. </p></li>\n</ol>\n<p>I hope this helps somewhat to make it clearer how these two forms differ!</p>\n</hr>", "CreationDate": "2009-06-26T22:04:02.820", "LastEditDate": "2016-11-14T15:34:08.010", "ParentId": "1051379", "Id": "1051468", "LastEditorUserId": "5614968", "PostTypeId": "2", "Score": "207", "OwnerUserId": "34509"}, "1051441": {"LastActivityDate": "2009-06-26T22:08:45.527", "CommentCount": "0", "Body": "<p>First grouping: it depends on what <code>A_factory_func</code> returns. The first line is an example of <em>copy initialization</em>, the second line is <em>direct initialization</em>. If <code>A_factory_func</code> returns an <code>A</code> object then they are equivalent, they both call the copy constructor for <code>A</code>, otherwise the first version creates an rvalue of type <code>A</code> from an available conversion operators for the return type of <code>A_factory_func</code> or appropriate <code>A</code> constructors, and then calls the copy constructor to construct <code>a1</code> from this temporary. The second version attempts to find a suitable constructor that takes whatever <code>A_factory_func</code> returns, or that takes something that the return value can be implicitly converted to.</p>\n<p>Second grouping: exactly the same logic holds, except that built in types don't have any exotic constructors so they are, in practice, identical.</p>\n<p>Third grouping: <code>c1</code> is default initialized, <code>c2</code> is copy-initialized from a value initialized temporary. Any members of <code>c1</code> that have pod-type (or members of members, etc., etc.) may not be initialized if the user supplied default constructors (if any) do not explicitly initialize them. For <code>c2</code>, it depends on whether there is a user supplied copy constructor and whether that appropriately initializes those members, but the members of the temporary will all be initialized (zero-initialized if not otherwise explicitly initialized). As litb spotted, <code>c3</code> is a trap. It's actually a function declaration.</p>\n", "CreationDate": "2009-06-26T21:55:51.403", "LastEditDate": "2009-06-26T22:08:45.527", "ParentId": "1051379", "Id": "1051441", "LastEditorUserId": "19563", "PostTypeId": "2", "Score": "3", "OwnerUserId": "19563"}, "bq_ids": {"n4140": {"so_1051379_30295099_1": {"length": 59, "quality": 0.9516129032258065, "section_id": 5999}}, "n3337": {"so_1051379_30295099_1": {"length": 59, "quality": 0.9516129032258065, "section_id": 5767}}}, "1051431": {"CommentCount": "1", "Body": "<p><code>double b1 = 0.5;</code> is implicit call of constructor.</p>\n<p><code>double b2(0.5);</code> is explicit call. </p>\n<p>Look at the following code to see the difference:</p>\n<pre><code>#include &lt;iostream&gt;\nclass sss { \npublic: \n  explicit sss( int ) \n  { \n    std::cout &lt;&lt; \"int\" &lt;&lt; std::endl;\n  };\n  sss( double ) \n  {\n    std::cout &lt;&lt; \"double\" &lt;&lt; std::endl;\n  };\n};\n\nint main() \n{ \n  sss ddd( 7 ); // calls int constructor \n  sss xxx = 7;  // calls double constructor \n  return 0;\n}\n</code></pre>\n<p>If your class has no explicit constuctors than explicit and implicit calls are identical.</p>\n", "CreationDate": "2009-06-26T21:54:20.483", "ParentId": "1051379", "Id": "1051431", "LastActivityDate": "2009-06-26T21:54:20.483", "PostTypeId": "2", "Score": "10", "OwnerUserId": "123111"}, "30295099": {"LastActivityDate": "2015-05-18T11:06:10.457", "CommentCount": "1", "Body": "<p>Answering with respect to this part:</p>\n<blockquote>\n<p id=\"so_1051379_30295099_0\">A c2 = A(); A c3(A());</p>\n</blockquote>\n<p>Since most of the answers are pre-c++11 I am adding what c++11 has to say about this:</p>\n<blockquote>\n<p id=\"so_1051379_30295099_1\">A simple-type-specifier (7.1.6.2) or typename-specifier (14.6)\n  followed by a parenthesized expression-list constructs a value of the\n  specified type given the expression list. If the expression list is a\n  single expression, the type conversion expression is equivalent (in\n  definedness, and if defined in meaning) to the corresponding cast\n  expression (5.4). If the type specified is a class type, the class\n  type shall be complete. <strong>If the expression list specifies more than a\n  single value, the type shall be a class with a suitably declared\n  constructor (8.5, 12.1), and the expression T(x1, x2, ...) is\n  equivalent in effect to the declaration T t(x1, x2, ...);</strong> for some\n  invented temporary variable t, with the result being the value of t as\n  a prvalue.</p>\n</blockquote>\n<p>So optimization or not they are equivalent as per the standard.\nNote that this is in accordance with what other answers have mentioned. Just quoting what the standard has to say for sake of correctness.   </p>\n", "CreationDate": "2015-05-18T04:26:26.437", "LastEditDate": "2015-05-18T11:06:10.457", "ParentId": "1051379", "Id": "30295099", "LastEditorUserId": "1043773", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1043773"}});