post_cb({"24106820": {"ParentId": "24106502", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-06-08T13:51:53.860", "Score": "6", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-08T14:07:58.773", "Id": "24106820", "OwnerUserId": "1090079", "Body": "<h3>Long story; short.</h3>\n<p>You are actually not instantiating <code>foo&lt;bool&gt;</code> in the following expression:</p>\n<pre><code>std::is_same&lt;ok, foo&lt;bool&gt;&gt;::value;\n</code></pre>\n<hr>\n<h3>When does <em>implicit instantiation</em> occur?</h3>\n<blockquote>\n<p id=\"so_24106502_24106820_0\"><code>14.7.1</code> <strong>Implicit instantiation</strong> <code>[templ.inst]</code></p>\n<blockquote>\n<p id=\"so_24106502_24106820_3\"><code>5)</code> A class template specialization is implicitly instantiated if the class type is used in a context that requires a completely-defined object type or if the completeness of the class type might affect the semantics of the program.</p>\n<p id=\"so_24106502_24106820_4\"><code>7)</code> If an implicit instantiation of a class template specialization is required and the template is declared but not defined, the program is ill-formed.</p>\n</blockquote>\n</blockquote>\n<p>What the above text says is that a class template is only implicitly instantiated when it is used in a context that requires it to be fully defined, such as when declaring an object of said template, or when trying to access something inside it.</p>\n<p>Checking if one type is the same as another does not count as such context, since we are merely comparing two <em>names</em>.</p>\n<hr>\n<h3>When is a completely-defined object required?</h3>\n<p>The Standard makes a reference to <em>\"completely-defined\"</em> in several different locations, mostly when it explicitly says that such an object is required.</p>\n<p>The easiest definition of when we need a <em>completely-defined</em> object is by reading the following, which explains what it isn't.</p>\n<blockquote>\n<p id=\"so_24106502_24106820_5\"><code>3.9p5</code> <strong>Types</strong> <code>[basic.types]</code></p>\n<blockquote>\n<p id=\"so_24106502_24106820_7\">A class that has been declared but not defined, or an array of unknown size or of incomplete element type, is an incompletely defined object type. Incompletely-defined object types and the void types are incomplete types (3.9.1). Objects shall not be defined to have an incomplete type.</p>\n</blockquote>\n</blockquote>\n<p>The wording above states that as long as we don't declare an object to be of an <em>incomplete-type</em>, we are in the clear; ie. our template will not be implicitly instantiated.</p>\n<p>See the below example where (<em>C</em>) and (<em>D</em>) tries to create an object of <em>incomplete-type</em>, both (<em>A</em>) and (<em>B</em>) are legal since they don't cause <em>implicit instantiation</em>.</p>\n<pre><code>template&lt;class T&gt; struct A;\n\ntypedef A&lt;int&gt; A_int; // (A), legal\nA&lt;int&gt; *     ptr;     // (B), legal\nA&lt;int&gt;       foo;     // (C), ill-formed; trying to declare an object of incomplete-type\nA&lt;int&gt;::type baz;     // (D), ill-formed; trying to reach into the definition of `A&lt;int&gt;`\n</code></pre>\n</hr></hr>", "LastActivityDate": "2014-06-08T14:07:58.773"}, "24106502": {"CommentCount": "5", "ViewCount": "130", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-08T13:11:57.053", "LastActivityDate": "2014-06-10T17:55:58.750", "Title": "Invalid template instantation and the metaprogram compiles fine?", "AcceptedAnswerId": "24106820", "LastEditDate": "2017-05-23T12:27:25.830", "Id": "24106502", "Score": "2", "Body": "<p>I was working on a simple solution to the common <em>\"Conditional on ill-formed types\"</em> problem (Like <a href=\"https://stackoverflow.com/questions/24098278/stdconditional-compile-time-branch-evaluation\">this</a> yesterday question). </p>\n<p>In my codebase I have a template to hold uninstanced templates and instance them later. Something like this:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class F&gt;\nstruct lazy\n{};\n\nnamespace impl\n{\n    template&lt;typename L , typename... ARGS&gt;\n    struct lazy_instance;\n\n    template&lt;template&lt;typename...&gt; class F , typename... ARGS&gt;\n    struct lazy_instance&lt;lazy&lt;F&gt;,ARGS...&gt; : public identity&lt;F&lt;ARGS...&gt;&gt;\n    {};\n}\n\ntemplate&lt;typename L , typename... ARGS&gt;\nusing lazy_instance = typename impl::lazy_instance&lt;L,ARGS...&gt;::type;\n</code></pre>\n<p>Where <code>identity</code> is the identity metafunction.<br>\nThis could be used as follows:</br></p>\n<pre><code>using vector = lazy&lt;std::vector&gt;;\nusing int_vector = lazy_instance&lt;vector,int&gt;;\n</code></pre>\n<p>So the solution which comes to my mind is to wrap the two targets of the conditional on that way, and instantiate the result of the conditional, so only the selected template is instanced. For that purpose, I have modified <code>lazy</code> and <code>impl::lazy_instance</code> to allow us to pass the template parameters at the <code>lazy</code> instantation point:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class F , typename... ARGS&gt;\nstruct lazy\n{};\n\nnamespace impl\n{\n    template&lt;typename L , typename... ARGS&gt;\n    struct lazy_instance;\n\n    template&lt;template&lt;typename...&gt; class F , typename... ARGS , typename... IARGS&gt;\n    struct lazy_instance&lt;lazy&lt;F,ARGS...&gt;,IARGS...&gt; : public identity&lt;F&lt;ARGS...&gt;&gt;\n    {};\n}\n</code></pre>\n<p><em>Note that in this case <code>lazy_instance</code> takes template parameters too, but they are ignored. I have donde this on that way to have the same interface for both usage cases.</em></p>\n<p>So our main problem, the evaluation of conditional selection of potentially ill-formed types could be achieved as follows:</p>\n<pre><code>using ok = lazy_instance&lt;typename std::conditional&lt;true,\n                                                   lazy&lt;foo,int&gt;,\n                                                   lazy&lt;foo,bool&gt;\n                                                  &gt;::type\n                        &gt;;\n</code></pre>\n<p>Where <code>foo</code> is a template where the <code>bool</code> instantation is ill-formed, for example:</p>\n<pre><code>template&lt;typename T&gt;\nstruct foo;\n\ntemplate&lt;&gt;\nstruct foo&lt;int&gt;\n{};\n</code></pre>\n<p>It seems to work, isn't? Great. But a couple of minutes later I changed the boolean flag to <code>false</code>, and surprisingly it works too! Even if <code>foo&lt;bool&gt;</code> specialization is not defined!</p>\n<p>Also the metaprogram has a <code>static_assert</code> bellow to check if the evaluation of the conditional was successfull:</p>\n<pre><code>static_assert( std::is_same&lt;ok,foo&lt;int&gt;&gt;::value , \"Mmmmm...\" );\n</code></pre>\n<p>When I changed the condition from <code>true</code> to <code>false</code>, I changed the test to see whats happening there:</p>\n<pre><code>static_assert( std::is_same&lt;ok,foo&lt;bool&gt;&gt;::value , \"Mmmmm...\" );\n</code></pre>\n<p>And the metaprogram passes the test too! Even with the explicit instantation of <code>foo&lt;bool&gt;</code>, and <code>ok</code>, which should be an alias to that instance.<br>\nFinally I have checked that there is no <em>\"No matching specialization for <code>foo&lt;bool&gt;</code>\"</em> until I declare a variable of type <code>ok</code>: <code>ok anok;</code></br></p>\n<p>I'm working with CLang 3.4, on C++11 mode (<code>-std=c++11</code>). My question is: <strong>Whats happening here? Is that behaviour correct or its a LLVM bug?</strong></p>\n<p><strong>EDIT:</strong> <a href=\"https://ideone.com/VRV2D2\" rel=\"nofollow noreferrer\">Here</a> is a SSCCE running at ideone. It uses GCC 4.8.1, but seems like it has the same behaviour.</p>\n", "Tags": "<c++><templates><c++11><template-meta-programming><llvm-clang>", "OwnerUserId": "1609356", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24106502_24106820_6": {"section_id": 7203, "quality": 0.8571428571428571, "length": 24}, "so_24106502_24106820_3": {"section_id": 238, "quality": 1.0, "length": 18}, "so_24106502_24106820_7": {"section_id": 7203, "quality": 0.8571428571428571, "length": 24}, "so_24106502_24106820_4": {"section_id": 240, "quality": 1.0, "length": 11}, "so_24106502_24106820_2": {"section_id": 240, "quality": 1.0, "length": 11}, "so_24106502_24106820_1": {"section_id": 238, "quality": 1.0, "length": 18}}, "n3337": {"so_24106502_24106820_6": {"section_id": 6947, "quality": 0.8928571428571429, "length": 25}, "so_24106502_24106820_3": {"section_id": 230, "quality": 1.0, "length": 18}, "so_24106502_24106820_7": {"section_id": 6947, "quality": 0.8928571428571429, "length": 25}, "so_24106502_24106820_4": {"section_id": 232, "quality": 1.0, "length": 11}, "so_24106502_24106820_2": {"section_id": 232, "quality": 1.0, "length": 11}, "so_24106502_24106820_1": {"section_id": 230, "quality": 1.0, "length": 18}}, "n4659": {"so_24106502_24106820_3": {"section_id": 242, "quality": 0.7777777777777778, "length": 14}, "so_24106502_24106820_7": {"section_id": 8712, "quality": 0.7142857142857143, "length": 20}, "so_24106502_24106820_6": {"section_id": 8712, "quality": 0.7142857142857143, "length": 20}, "so_24106502_24106820_4": {"section_id": 242, "quality": 0.7272727272727273, "length": 8}, "so_24106502_24106820_2": {"section_id": 242, "quality": 0.7272727272727273, "length": 8}, "so_24106502_24106820_1": {"section_id": 242, "quality": 0.7777777777777778, "length": 14}}}});