post_cb({"26089189": {"CommentCount": "1", "ViewCount": "342", "CreationDate": "2014-09-28T20:14:28.927", "LastActivityDate": "2014-09-28T20:42:55.227", "Title": "Recursive Class Template with overloaded ostream<< operator", "AcceptedAnswerId": "26089329", "PostTypeId": "1", "Id": "26089189", "Score": "1", "Body": "<p>I'm trying to implement a simple N-dimensional array. This seems to be working more or less properly but I just can't get its overloaded ostream operator work. Here's my current implementation:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename Type, int Dimension&gt;\nstruct Array {\n    typedef std::vector&lt;typename Array&lt;Type, Dimension - 1&gt;::type&gt; type;\n\n    template &lt;typename cType, int cDimension&gt;\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;stream, const Array&lt;cType, cDimension&gt;::type &amp;object) {\n        if (cDimension == 0) {\n            stream &lt;&lt; object &lt;&lt; ' ';\n        } else {\n            typedef typename Array&lt;cType, cDimension&gt;::type::iterator ArrayIterator;\n            for (ArrayIterator it = object.begin(); it != object.end(); ++it) {\n                typedef typename Array&lt;cType, cDimension - 1&gt;::type NestedArray;\n\n                NestedArray nArray = (NestedArray)(*it);\n                stream &lt;&lt; nArray &lt;&lt; std::endl;\n            }\n        }\n\n        return stream;\n    }\n};\n\ntemplate &lt;typename Type&gt;\nstruct Array &lt; Type, 0 &gt; {\n    typedef Type type;\n};\n\nint main() {\n    Array&lt;int, 1&gt;::type c00 = { 1, 2, 3 };\n    Array&lt;int, 1&gt;::type c01 = { 2, 3, 4 };\n    Array&lt;int, 1&gt;::type c02 = { 3, 4, 5 };\n    Array&lt;int, 2&gt;::type c10 = { c00, c01 };\n    Array&lt;int, 2&gt;::type c11 = { c01, c02 };\n    Array&lt;int, 3&gt;::type c20 = { c10, c11 };\n\n    std::cout &lt;&lt; c20 &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>I'm getting the following compilation errors:</p>\n<pre><code>1&gt;------ Build started: Project: NDepthArray, Configuration: Debug Win32 ------\n1&gt;  Source.cpp\n1&gt;c:\\users\\Administrator\\documents\\visual studio 2013\\projects\\cppmaterials\\ndeptharray\\source.cpp(10): warning C4346: 'Array&lt;Type,Dimension&gt;::type' : dependent name is not a type\n1&gt;          prefix with 'typename' to indicate a type\n1&gt;          c:\\users\\Administrator\\documents\\visual studio 2013\\projects\\cppmaterials\\ndeptharray\\source.cpp(25) : see reference to class template instantiation 'Array&lt;Type,Dimension&gt;' being compiled\n1&gt;c:\\users\\Administrator\\documents\\visual studio 2013\\projects\\cppmaterials\\ndeptharray\\source.cpp(10): error C2061: syntax error : identifier 'type'\n1&gt;c:\\users\\Administrator\\documents\\visual studio 2013\\projects\\cppmaterials\\ndeptharray\\source.cpp(10): error C2805: binary 'operator &lt;&lt;' has too few parameters\n1&gt;c:\\users\\Administrator\\documents\\visual studio 2013\\projects\\cppmaterials\\ndeptharray\\source.cpp(10): fatal error C1903: unable to recover from previous error(s); stopping compilation\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n</code></pre>\n<p>I literally tried all my ideas already, which includes removing friend keyword and the actual class parameter but nothing changes. How can we overload operators for such class templates?</p>\n<p>Cheers,\n Joey</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "1263522", "AnswerCount": "1"}, "26089329": {"ParentId": "26089189", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The problem with your approach is that the <code>cType</code> cannot be inferred:</p>\n<pre><code>template &lt;typename Type, int Dimension&gt; // Asking for Type as cType\nstruct Array {\n   typedef std::vector&lt;typename Array&lt;Type, Dimension - 1&gt;::type&gt; type;\n}\n\ntemplate &lt;typename cType, int cDimension&gt;                     \u2193\u2193\u2193\u2193\u2193\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;stream, typename Array&lt;cType, cDimension&gt;::type &amp;object)\n\nArray&lt;int, 3&gt;::type c20 = { c10, c11 };\nstd::cout &lt;&lt; c20 // Deduction failure\n</code></pre>\n<p>You can find more info here: <a href=\"https://stackoverflow.com/a/12566268/1938163\">https://stackoverflow.com/a/12566268/1938163</a></p>\n<p>14.8.2.5/4</p>\n<blockquote>\n<p id=\"so_26089189_26089329_0\">In certain contexts, however, the value does not participate in type\n  deduction, but instead uses the values of template arguments that were\n  either deduced elsewhere or explicitly specified. If a template\n  parameter is used only in non-deduced contexts and is not explicitly\n  specified, <strong>template argument deduction fails</strong>.</p>\n</blockquote>\n<p><em>As a sidenote</em>: implementing complex structures for multidimensional arrays or vectors with templated recursive code is a not-very-maintainable and surely hard-to-read path to achieve something that could have been done faster, more efficient (less allocations) and clearer with only a contiguous block of memory indexed in different strides.</p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:05:32.437", "Id": "26089329", "Score": "2", "CreationDate": "2014-09-28T20:29:52.047", "LastActivityDate": "2014-09-28T20:42:55.227"}, "bq_ids": {"n4140": {"so_26089189_26089329_0": {"section_id": 335, "quality": 1.0, "length": 30}}, "n3337": {"so_26089189_26089329_0": {"section_id": 325, "quality": 1.0, "length": 30}}, "n4659": {"so_26089189_26089329_0": {"section_id": 344, "quality": 1.0, "length": 30}}}});