post_cb({"bq_ids": {"n4140": {"so_38131945_38131963_3": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_38131945_38131963_4": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_38131945_38131963_8": {"length": 8, "quality": 1.0, "section_id": 599}, "so_38131945_38131963_6": {"length": 5, "quality": 1.0, "section_id": 3285}, "so_38131945_38131963_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}, "so_38131945_38131963_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 3323}, "so_38131945_38131963_0": {"length": 6, "quality": 1.0, "section_id": 3252}, "so_38131945_38131963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 3256}, "so_38131945_38131963_5": {"length": 4, "quality": 1.0, "section_id": 3286}}, "n3337": {"so_38131945_38131963_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}, "so_38131945_38131963_8": {"length": 8, "quality": 1.0, "section_id": 589}, "so_38131945_38131963_4": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_38131945_38131963_6": {"length": 5, "quality": 1.0, "section_id": 3155}, "so_38131945_38131963_0": {"length": 6, "quality": 1.0, "section_id": 3124}, "so_38131945_38131963_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 3193}, "so_38131945_38131963_3": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_38131945_38131963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 3128}, "so_38131945_38131963_5": {"length": 4, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_38131945_38131963_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}, "so_38131945_38131963_8": {"length": 8, "quality": 1.0, "section_id": 622}, "so_38131945_38131963_6": {"length": 4, "quality": 0.8, "section_id": 653}, "so_38131945_38131963_0": {"length": 6, "quality": 1.0, "section_id": 4010}, "so_38131945_38131963_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 4089}, "so_38131945_38131963_3": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_38131945_38131963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 4014}}}, "38131945": {"ViewCount": "1813", "Body": "<p>One might want to declare a function with an argument, and specify that the default value for the argument is the result of the type's default constructor:</p>\n<pre><code>void foo(a::really::long::type::name arg = a::really::long::type::name());\n</code></pre>\n<p>Is there a nicer syntax for this that doesn't involve entering the type name twice? Something like:</p>\n<pre><code>void foo(a::really::long::type::name arg = default);\n</code></pre>\n<p>I realize I can <code>typedef</code> the type name to make it prettier, but I'm curious whether such a syntax exists.</p>\n", "AcceptedAnswerId": "38131963", "Title": "Nicer syntax for setting default argument value to default constructor", "CreationDate": "2016-06-30T19:44:25.367", "Id": "38131945", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-07-01T13:47:14.057", "Score": "35", "OwnerUserId": "1274314", "Tags": "<c++><c++11><optional-parameters><default-constructor>", "AnswerCount": "2"}, "38135176": {"Id": "38135176", "PostTypeId": "2", "Body": "<p>A pedestrian approach is possible, if you control the class of <code>arg</code>. Use a conversion constructor overloaded for an <code>enum</code>:</p>\n<pre><code>// Define this enum, and then write constructors which take dfl\nenum dfl { dflval };\n\nclass a_really_long_type_name {\npublic:\n  a_really_long_type_name(dfl arg = dflval);\n};\n</code></pre>\n<p>Now foo can be:</p>\n<pre><code>void foo(a_really_long_type_name arg = dflval);\n</code></pre>\n<p>If you can apply this, a benefit is portability; this should work fine in a twenty-five-year-old C++ compiler.</p>\n<p>Multiple classes can all share this <code>dfl</code> <code>enum</code> and its <code>dflval</code>-flavored zero; it's like having a new keyword.</p>\n<p>Because an <code>enum</code> is a distinct type, this doesn't interfere with constructor overloads for integer types or characters and so on.</p>\n<p>The downside is working it into some classes which already have default construction provided via argument defaulting, which leads to duplicate constructor code.</p>\n", "LastActivityDate": "2016-07-01T00:14:09.653", "CommentCount": "0", "CreationDate": "2016-07-01T00:14:09.653", "ParentId": "38131945", "Score": "3", "OwnerUserId": "1250772"}, "38131963": {"Id": "38131963", "PostTypeId": "2", "Body": "<p>Yes:</p>\n<pre><code>void foo(a::really::long::type::name arg = {});\n</code></pre>\n<p>To sum up the following standard definitions:</p>\n<p>This is list initialization. Depending of the type, aggregate initialization is performed or the object is value initialized, which in turn implies default initialized or zero initialized.</p>\n<p>Some \"corner\" cases are when the type is a specialization of <code>std::initializer_list</code> or when the type has a <code>std::initializer_list</code> constructor (it is called if it has no default constructor)</p>\n<hr>\n<p>The relevant standard quotes (in order we encounter definitions):</p>\n<p>\u00a78.3.6 Default arguments [dcl.fct.default]</p>\n<blockquote>\n<p id=\"so_38131945_38131963_0\">1 If an initializer-clause is specified in a parameter-declaration this\n  initializer-clause is used as a default argument</p>\n<p id=\"so_38131945_38131963_1\">5 The default argument has the same semantic constraints as the\n  initializer in a declaration of a variable of the parameter type,\n  using the copy-initialization semantics (8.5)</p>\n</blockquote>\n<p>\u00a78.5.4 List-initialization [dcl.init.list]</p>\n<blockquote>\n<p id=\"so_38131945_38131963_2\">1 List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is called an initializer\n  list, [...]. An initializer list may be empty. List-initialization can\n  occur in direct-initialization or copy initialization contexts;\n  [..] list-initialization in a\n  copy-initialization context is called copy-list-initialization.</p>\n<p id=\"so_38131945_38131963_3\">3 List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If T is an aggregate, <strong>aggregate initialization is performed</strong> (8.5.1)</li>\n<li>Otherwise, if the initializer list has no elements and T is a class\n  type with a default constructor, the object is <strong>value-initialized</strong>.</li>\n<li>Otherwise, if T is a specialization of std::initializer_list, a prvalue initializer_list object is constructed as described below and\n  used to initialize the object according to the rules for\n  initialization of an object from a class of the same type (8.5).</li>\n<li>Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7) [...]</li>\n<li>...</li>\n<li>Otherwise, if the initializer list has no elements, the object is <strong>value-initialized</strong>.</li>\n</ul>\n</blockquote>\n<p>\u00a7 8.5 Initializers  [dcl.init]</p>\n<blockquote>\n<p id=\"so_38131945_38131963_4\">8 To <strong>value-initialize</strong> an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is\n  user-provided or deleted, then the object is <strong>default-initialized</strong>;</li>\n<li>if T is a (possibly cv-qualified) class type without a user-provided or deleted default constructor, then the object is <strong>zero-initialized</strong>\n  and the semantic constraints for default-initialization are checked,\n  and if T has a non-trivial default constructor, the object is\n  <strong>default-initialized</strong>;</li>\n<li>if T is an array type, then each element is <strong>value-initialized</strong>;</li>\n<li>otherwise, the object is <strong>zero-initialized</strong></li>\n</ul>\n<p id=\"so_38131945_38131963_5\">7  To <strong>default-initialize</strong> an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9), <strong>the default constructor (12.1) for T is called</strong> (and the initialization is\n  ill-formed if T has no default constructor or overload resolution\n  (13.3) results in an ambiguity or in a function that is deleted or\n  inaccessible from the context of the initialization);</li>\n<li>if T is an array type, each element is <strong>default-initialized</strong>;</li>\n<li>otherwise, no initialization is performed.</li>\n</ul>\n<p id=\"so_38131945_38131963_6\">6 To <strong>zero-initialize</strong> an object or reference of type T means:</p>\n<ul>\n<li>if T is a scalar type (3.9), the object is initialized to the value obtained by converting the integer literal 0 (zero) to T;</li>\n<li>if T is a (possibly cv-qualified) non-union class type, each non-static data member and each base-class subobject is\n  zero-initialized and padding is initialized to zero bits;</li>\n<li>if T is a (possibly cv-qualified) union type, the object\u2019s first non-static named data member is zero-initialized and padding is\n  initialized to zero bits;</li>\n<li>if T is an array type, each element is zero-initialized;</li>\n<li>if T is a reference type, no initialization is performed.</li>\n</ul>\n</blockquote>\n<p>\u00a713.3.1.7 Initialization by list-initialization [over.match.list]</p>\n<blockquote>\n<p id=\"so_38131945_38131963_7\">1 When objects of non-aggregate class type T are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<ul>\n<li>Initially, the candidate functions are the <strong>initializer-list constructors</strong> (8.5.4) of the class T and the argument list consists of\n  the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all\n  the constructors of the class T and the argument list consists of the\n  elements of the initializer list.</li>\n</ul>\n<p id=\"so_38131945_38131963_8\">If the initializer list has no elements and T has a default\n  constructor, the first phase is omitted. [...]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "2805305", "LastActivityDate": "2016-07-01T13:47:14.057", "Score": "53", "CreationDate": "2016-06-30T19:45:25.970", "ParentId": "38131945", "CommentCount": "4", "OwnerUserId": "2805305", "LastEditDate": "2016-07-01T13:47:14.057"}});