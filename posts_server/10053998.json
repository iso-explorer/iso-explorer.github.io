post_cb({"10053998": {"CommentCount": "2", "AcceptedAnswerId": "10054118", "PostTypeId": "1", "LastEditorUserId": "1030301", "CreationDate": "2012-04-07T11:19:48.827", "LastActivityDate": "2012-04-07T11:38:16.980", "LastEditDate": "2012-04-07T11:24:41.873", "ViewCount": "470", "FavoriteCount": "0", "Title": "Cheapest way of binding local variable to closure", "Id": "10053998", "Score": "5", "Body": "<p>I believe following to be a cheapest way of binding local variable to closure:</p>\n<pre><code>void ByRValueReference(A&amp;&amp; a) {\n}\n\nstd::function&lt;void ()&gt; CreateClosureByRValueReference() {\n  A a;\n  std::function&lt;void ()&gt; f = std::bind(&amp;ByRValueReference, std::move(a)); // !!!\n  return f;\n}\n</code></pre>\n<p>However, it does not compile under Clang 3.1:</p>\n<pre><code>error: no viable conversion from '__bind&lt;void (*)(A &amp;&amp;), A&gt;' to 'std::function&lt;void ()&gt;'\n</code></pre>\n<p>and gcc 4.6.1:</p>\n<pre><code>/usr/include/c++/4.6/functional:1778:2: error: no match for call to \u2018(std::_Bind&lt;void (*(A))(A&amp;&amp;)&gt;) ()\u2019\n</code></pre>\n<p>Am I violating the standard or it's just broken standard libraries?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1318869", "AnswerCount": "1"}, "10054118": {"ParentId": "10053998", "CommentCount": "8", "Body": "<p>This is by design of <code>std::bind</code>. The full specification is in 20.8.9.1.2 Function template bind [func.bind.bind] but in this case the last bullet of paragraph 10 (which describes how the bound parameters are used) applies:</p>\n<blockquote>\n<p id=\"so_10053998_10054118_0\">\u2014 otherwise, the value is <code>tid</code> and its type <code>Vi</code> is <code>TiD cv &amp;</code></p>\n</blockquote>\n<p>So in other words, <code>std::move(a)</code> will result in the call wrapper storing an <code>A</code> (from move construction), and then when <code>operator()</code> is used this member will be forwarded <em>as an lvalue</em> (with additional cv-qualifiers matching the cv-qualifiers of the call wrapper, but I digress). Even though it was passed as an rvalue.</p>\n<p>This kind of mismatch can be solved via a lambda:</p>\n<pre><code>std::bind([](A&amp; a) { ByRValueReference(std::move(a)); }, std::move(a))\n</code></pre>\n<p>This can be argued that it's more explicit that further calls to the resulting call wrapped are dubious (since the <code>A</code> member is liable to have been moved from), but I'm not overly fond of the behaviour of <code>std::bind</code> as a whole.</p>\n", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "10054118", "Score": "3", "CreationDate": "2012-04-07T11:38:16.980", "LastActivityDate": "2012-04-07T11:38:16.980"}, "bq_ids": {"n4140": {"so_10053998_10054118_0": {"section_id": 4641, "quality": 1.0, "length": 6}}, "n3337": {"so_10053998_10054118_0": {"section_id": 4452, "quality": 1.0, "length": 6}}, "n4659": {"so_10053998_10054118_0": {"section_id": 6011, "quality": 0.6666666666666666, "length": 4}}}});