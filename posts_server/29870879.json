post_cb({"29870879": {"CommentCount": "1", "AcceptedAnswerId": "29871321", "CreationDate": "2015-04-25T21:21:24.747", "LastActivityDate": "2015-04-25T22:13:17.720", "PostTypeId": "1", "ViewCount": "358", "FavoriteCount": "1", "Title": "What level are fread thread locks on? What level do they need to be on?", "Id": "29870879", "Score": "5", "Body": "<p>Visual Studio's fread \"locks out other threads.\"  There is an alternate version _fread_nolock, which reads \"without locking other threads\", which should only be used \"in thread-safe contexts such as single-threaded applications or where the calling scope already handles thread isolation.\"</p>\n<p>Even after reading other somewhat relevant discussions on the two, I'm confused if the locking fread implements is on a specific FILE struct, a specific actual file, or on all fread calls on totally different files.</p>\n<p>If you use the nolock versions, what level of locking do you need to provide?  Can multiple threads in parallel be reading separate files without any locking?  Can multiple threads in parallel be writing separate files without any locking?  Or are there global or static variables involved that would be corrupted?</p>\n<p>So, by using the nolock versions, are you able to potentially achieve better I/O throughput (if you aren't needlessly moving heads, like reading off separate drives, or a SSD drive), or is the potential gain just reducing redundant locks to a single lock (which should be negligible.)</p>\n<p>Does VS' ifstream.read function work just like the regular fread?  (I don't see a nolock version of it.)</p>\n", "Tags": "<c++><c><multithreading><io><locking>", "OwnerUserId": "1902689", "AnswerCount": "2"}, "29871089": {"ParentId": "29870879", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>fread_no_lock() appears to be used once you make sure that the file is locked with an external mechanism (some form of mutex, probably), and then you use it to reduce overhead: related: <a href=\"https://stackoverflow.com/questions/1890448/whats-the-intended-use-of-fread-nolock-fseek-nolock\">What's the intended use of _fread_nolock, _fseek_nolock?</a></p>\n<p>This may also answer any further questions you might have: it may or may not be possible for your hard-drive to actually perform more than I/O operation at the same time depending on what type of hard drive you have: <a href=\"https://superuser.com/questions/252959/which-is-faster-copying-everything-at-once-or-one-thing-at-a-time\">https://superuser.com/questions/252959/which-is-faster-copying-everything-at-once-or-one-thing-at-a-time</a></p>\n", "OwnerUserId": "3325075", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:33.667", "Id": "29871089", "Score": "0", "CreationDate": "2015-04-25T21:45:22.487", "LastActivityDate": "2015-04-25T21:45:22.487"}, "bq_ids": {"n4140": {"so_29870879_29871321_1": {"section_id": 1908, "quality": 1.0, "length": 26}, "so_29870879_29871321_0": {"section_id": 1907, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_29870879_29871321_1": {"section_id": 1897, "quality": 1.0, "length": 26}, "so_29870879_29871321_0": {"section_id": 1896, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_29870879_29871321_1": {"section_id": 2178, "quality": 1.0, "length": 26}, "so_29870879_29871321_0": {"section_id": 2177, "quality": 0.9444444444444444, "length": 17}}}, "29871321": {"ParentId": "29870879", "CommentCount": "0", "Body": "<p>The MS standard library implementation fully supports multi-threading.  The C++ standard explain this requirement:  </p>\n<blockquote>\n<p id=\"so_29870879_29871321_0\"><strong>27.2.3:</strong> Concurrent access to a stream object, stream buffer object, or C Library stream by multiple threads may result in a data\n  race unless otherwise specified. </p>\n<p id=\"so_29870879_29871321_1\">If one thread makes a library call a that writes a value to a stream\n  and, as a result, another thread reads this value from the stream\n  through a library call b such that this does not result in a data\n  race, then a\u2019s write synchronizes with b\u2019s read.</p>\n</blockquote>\n<p>This means that if you write on a stream, a locking (not file locking, but concurrent access locking to the in-memory stream data structure) is done, to be sure that concurrency is well manageged for all the other threads using the same stream.    </p>\n<p>This locking overhead is always there, even if not needed.  This could have a performance aspect, according to Microsoft:  </p>\n<blockquote>\n<p id=\"so_29870879_29871321_2\">the performance of the multithreaded libraries has been improved and\n  is <strong>close to the performance</strong> of the now-eliminated single-threaded\n  libraries. For those situations when even higher performance is\n  required, there are several new features.</p>\n</blockquote>\n<p>This is why _nolock functions are provided.  They access the stream directly without thread locking. It must be used with extreme care, for example: </p>\n<ul>\n<li>if your application is single threaded (another process using the same stream has its own data structure, and OS manageds concurrency here)</li>\n<li>if you're sure that no two threads use the same stream (for example if you have only one reader thread and writing is done outside your porgramme).</li>\n<li>if you have other synchronisation mechasnism that protect a critical section of your code.  For example, if you use a mutex lock, or an thread safe non blocking algorithm that makes use of atomics.  </li>\n</ul>\n<p>In such cases, the additional lock for stream access is not needed/redundant. For file intensive functions, it could be worth using the no_lock then. </p>\n<p><strong>Note:</strong> as you've pointed out: it's only worth using the nolock for intensive file accesses where you make millions of accesses.    </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "29871321", "Score": "3", "CreationDate": "2015-04-25T22:13:17.720", "LastActivityDate": "2015-04-25T22:13:17.720"}});