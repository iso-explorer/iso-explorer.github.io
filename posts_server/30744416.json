post_cb({"30744596": {"ParentId": "30744416", "CommentCount": "0", "CreationDate": "2015-06-09T23:28:18.230", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "30744596", "Score": "5", "Body": "<p>Virtual base classes can only be initialized by the most derived class. Calls to a constructor of a virtual base from a non most-derived class are ignored and replaced with default constructor calls. This is to ensure that the virtual base subobject is initialized only once:</p>\n<p>The correct code should place the constructor call in the most derived class' <em>ctor-initializer</em>:</p>\n<pre><code>Child(Child const&amp; other)\n    : Abstract(other) // indirect virtual bases are\n                      // initialized first\n    , Parent(other) // followed by direct bases\n{ }\n</code></pre>\n", "LastActivityDate": "2015-06-09T23:28:18.230"}, "30744416": {"CommentCount": "7", "ViewCount": "321", "PostTypeId": "1", "LastEditorUserId": "97248", "CreationDate": "2015-06-09T23:11:58.503", "LastActivityDate": "2015-06-09T23:45:57.963", "Title": "C++ virtual base classes: parent's copy constructor doesn't get called", "AcceptedAnswerId": "30744596", "LastEditDate": "2015-06-09T23:22:28.203", "Id": "30744416", "Score": "1", "Body": "<p>I have three classes as you can see in the code below. Notice how I have written the copy constructors.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Abstract\n{\npublic:\n    Abstract(){};\n    Abstract( const Abstract&amp; other ): mA(other.mA){};\n    virtual ~Abstract(){};\n\n    void setA(double inA){mA = inA;};\n    double getA(){return mA;};\n\n    virtual void isAbstract() = 0;\nprotected:\n    double mA;\n};\n\nclass Parent : public virtual Abstract\n{\npublic:\n    Parent(){};\n    Parent( const Parent&amp; other ): Abstract(other){};\n    virtual ~Parent(){};\n\n};\n\n\nclass Child : public virtual Parent\n{\npublic:\n    Child(){};\n    Child( const Child&amp; other ): Parent(other){};\n    virtual ~Child(){};\n\n    void isAbstract(){};\n};\n\n\nint main()\n{\n    Child child1;\n    child1.setA(5);\n\n    Child childCopy(child1);\n    std::cout &lt;&lt; childCopy.getA() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Now why <code>Abstract()</code> gets called instead of the copy constructor <code>Abstract( const Abstract&amp; other )</code> when <code>childCopy</code> is being constructed?</p>\n<p>Shouldn't <code>Child(other)</code> call <code>Parent(other)</code>? And shouldn't <code>Parent(other)</code> in turn call <code>Abstract(other)</code>?</p>\n", "Tags": "<c++><class><copy-constructor>", "OwnerUserId": "2294360", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30744416_30744619_1": {"section_id": 438, "quality": 1.0, "length": 6}}, "n3337": {"so_30744416_30744619_1": {"section_id": 429, "quality": 1.0, "length": 6}}, "n4659": {"so_30744416_30744619_1": {"section_id": 458, "quality": 1.0, "length": 6}}}, "30744619": {"ParentId": "30744416", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-06-09T23:30:10.573", "Score": "1", "LastEditorUserId": "2412846", "LastEditDate": "2015-06-09T23:45:57.963", "Id": "30744619", "OwnerUserId": "2412846", "Body": "<p>In order to have correctly called <code>Abstract</code>'s copy constructor, you need to specify that in the initializer list of <code>Child</code>'s copy constructor.</p>\n<pre><code>Child( const Child&amp; other ): Abstract(other), Parent(other) {};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5e3a961be8fd4d2c\" rel=\"nofollow\">DEMO</a></p>\n<p>Here is the relevant quote from the standard, which states that the constructor of a virtual base class is called only in the most derived class. If it is missing, the default constructor is called instead (--if it exists).</p>\n<blockquote>\n<p id=\"so_30744416_30744619_0\">\u00a712.6.2, (13.1):</p>\n<p id=\"so_30744416_30744619_1\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<ul>\n<li>First, and only for the constructor of the most derived class (1.8),\n  virtual base classes are initialized in the order they appear on a\n  depth-first left-to-right traversal of the directed acyclic graph of\n  base classes, where \u201cleft-to-right\u201d is the order of appearance of the\n  base classes in the derived class base-specifier-list.</li>\n</ul>\n</blockquote>\n<p>In particular, this is why you notice <code>Abstract</code>'s default constructor being called.</p>\n<p>In order to avoid this pitfall, however, you can drop all user-defined copy constructors and rely on the copy constructor which is implicitly defined (which is always a good idea). <a href=\"http://coliru.stacked-crooked.com/a/cf5e0a7f82bb88ad\" rel=\"nofollow\">DEMO 2</a></p>\n", "LastActivityDate": "2015-06-09T23:45:57.963"}});