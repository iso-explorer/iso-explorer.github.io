post_cb({"27486581": {"CommentCount": "1", "ViewCount": "459", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-12-15T14:44:47.143", "LastActivityDate": "2014-12-15T19:17:14.003", "Title": "Void as a literal type?", "LastEditDate": "2014-12-15T19:17:14.003", "Id": "27486581", "Score": "13", "Body": "<p>In C++14 <code>void</code> is a literal type</p>\n<blockquote>\n<p id=\"so_27486581_27486581_0\">A type is a literal type if it is:</p>\n<p id=\"so_27486581_27486581_1\">\u2014 void; or</p>\n<p id=\"so_27486581_27486581_2\">\u2014 a scalar type; or</p>\n<p id=\"so_27486581_27486581_3\">\u2014 a reference type; or</p>\n<p id=\"so_27486581_27486581_4\">\u2014 an array of literal type; or</p>\n<p id=\"so_27486581_27486581_5\">\u2014 a class type (Clause 9) that has all of the following properties: \u2014\n  it has a trivial destructor,</p>\n<p id=\"so_27486581_27486581_6\">\u2014 it is an aggregate type (8.5.1) or has at least one constexpr\n  constructor or constructor template that is not a copy or move\n  constructor, and</p>\n<p id=\"so_27486581_27486581_7\">\u2014 all of its non-static data members and base classes are of\n  non-volatile literal types.</p>\n</blockquote>\n<p>In C++11 <code>void</code> is not a literal type</p>\n<blockquote>\n<p id=\"so_27486581_27486581_8\">A type is a literal type if it is:</p>\n<p id=\"so_27486581_27486581_9\">\u2014 a scalar type; or</p>\n<p id=\"so_27486581_27486581_10\">\u2014 a reference type referring to a literal type; or</p>\n<p id=\"so_27486581_27486581_11\">\u2014 an array of literal type; or</p>\n<p id=\"so_27486581_27486581_12\">\u2014 a class type (Clause 9) that has all of the following properties: \u2014\n  it has a trivial destructor,</p>\n<p id=\"so_27486581_27486581_13\">\u2014 every constructor call and full-expression in the\n  brace-or-equal-initializers for non-static data members (if any) is a\n  constant expression (5.19),</p>\n<p id=\"so_27486581_27486581_14\">\u2014 it is an aggregate type (8.5.1) or has at least one constexpr\n  constructor or constructor template that is not a copy or move\n  constructor, and</p>\n<p id=\"so_27486581_27486581_15\">\u2014 all of its non-static data members and base classes are of literal\n  types.</p>\n</blockquote>\n<p>So why is <code>void</code> a literal type? What benefits does it offer?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "4362611", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27486581_27486581_6": {"section_id": 7208, "quality": 0.9166666666666666, "length": 11}, "so_27486581_27486581_14": {"section_id": 7208, "quality": 0.9166666666666666, "length": 11}, "so_27486581_27486581_5": {"section_id": 7208, "quality": 1.0, "length": 8}, "so_27486581_27486581_15": {"section_id": 7208, "quality": 1.0, "length": 9}, "so_27486581_27486581_12": {"section_id": 7208, "quality": 1.0, "length": 8}, "so_27486581_27486581_10": {"section_id": 3285, "quality": 0.8, "length": 4}, "so_27486581_27486581_7": {"section_id": 7208, "quality": 1.0, "length": 10}}, "n3337": {"so_27486581_27486581_6": {"section_id": 6952, "quality": 0.9166666666666666, "length": 11}, "so_27486581_27486581_13": {"section_id": 6895, "quality": 0.9090909090909091, "length": 10}, "so_27486581_27486581_14": {"section_id": 6952, "quality": 0.9166666666666666, "length": 11}, "so_27486581_27486581_5": {"section_id": 6952, "quality": 1.0, "length": 8}, "so_27486581_27486581_15": {"section_id": 6952, "quality": 1.0, "length": 9}, "so_27486581_27486581_7": {"section_id": 6952, "quality": 0.9, "length": 9}, "so_27486581_27486581_10": {"section_id": 6952, "quality": 1.0, "length": 5}, "so_27486581_27486581_12": {"section_id": 6952, "quality": 1.0, "length": 8}}, "n4659": {"so_27486581_27486581_7": {"section_id": 8717, "quality": 1.0, "length": 10}, "so_27486581_27486581_14": {"section_id": 8717, "quality": 0.9166666666666666, "length": 11}, "so_27486581_27486581_5": {"section_id": 8717, "quality": 1.0, "length": 8}, "so_27486581_27486581_15": {"section_id": 8717, "quality": 1.0, "length": 9}, "so_27486581_27486581_6": {"section_id": 8717, "quality": 0.9166666666666666, "length": 11}, "so_27486581_27486581_10": {"section_id": 4047, "quality": 0.8, "length": 4}, "so_27486581_27486581_12": {"section_id": 8717, "quality": 1.0, "length": 8}}}, "27486631": {"ParentId": "27486581", "CommentCount": "1", "Body": "<p>Since <code>void</code> is <code>literal type</code>, <code>constexpr</code> functions can have return type <code>void</code> in C++14.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3444.html\" rel=\"noreferrer\">It's covered in this proposal.</a></p>\n<p>Quote from proposal:</p>\n<blockquote>\n<p id=\"so_27486581_27486631_0\">An arbitrary expression-statement is permitted, in order to allow\n  calls to functions performing checks and to allow assert-like\n  constructs. <strong>void also becomes a literal type, so that constexpr\n  functions which exist only to perform such checks may return void.</strong></p>\n</blockquote>\n<pre><code>#define ASSERT(expr) \\\n  (void)((expr) || assert_failed(#expr, __LINE__, __FILE__))\nvoid assert_failed(...); // not constexpr\nstruct S {\n  std::array a&lt;int, 100&gt;;\n  size_t i;\n\n  constexpr void check_invariants() const {\n    ASSERT(i &lt; a.size());\n    ASSERT(a[i] == 0);\n  }\n  S(std::array&lt;int, 100&gt; a_, size_t i_) : a(a_), i(i_) {\n    check_invariants();\n  }\n};\n</code></pre>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "27486631", "Score": "18", "CreationDate": "2014-12-15T14:48:24.390", "LastActivityDate": "2014-12-15T14:48:24.390"}});