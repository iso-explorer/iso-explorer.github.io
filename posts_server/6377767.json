post_cb({"6377797": {"ParentId": "6377767", "CommentCount": "0", "Body": "<p>Automatic variables are automatically destroyed at the end of their enclosing scope.</p>\n", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "6377797", "Score": "2", "CreationDate": "2011-06-16T19:56:20.357", "LastActivityDate": "2011-06-16T19:56:20.357"}, "6378064": {"ParentId": "6377767", "CommentCount": "0", "Body": "<p>As per <strong>3.7.2</strong> objects with automatic storage duration <em>last until the exit of the block in which they were created</em>, There are more details in <strong>6.6.2</strong> :</p>\n<blockquote>\n<p id=\"so_6377767_6378064_0\">On exit from a scope (<strong>however accomplished</strong>), destructors (12.4) are called for all constructed objects with\n  automatic  storage  duration  (3.7.2)  (named  objects  or  temporaries)  that  are  declared  in  that  scope,  in  the\n  reverse order of their declaration.  Transfer out of a loop, out of a block, or back past an initialized variable\n  with automatic storage duration involves the destruction of variables with automatic storage duration that\n  are  in  scope  at  the  point  transferred  from  but  not  at  the  point  transferred  to.</p>\n</blockquote>\n", "OwnerUserId": "722973", "PostTypeId": "2", "Id": "6378064", "Score": "3", "CreationDate": "2011-06-16T20:17:08.973", "LastActivityDate": "2011-06-16T20:17:08.973"}, "6377767": {"CommentCount": "0", "ViewCount": "256", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2011-06-16T19:54:03.307", "LastActivityDate": "2015-08-07T10:54:17.640", "Title": "Deletion of stack variable in C++", "AcceptedAnswerId": "6377826", "LastEditDate": "2015-08-07T10:54:17.640", "Id": "6377767", "Score": "2", "Body": "<p>In C++, if we declare a stack variable inside of a function, is it automatically deleted at the end of the function or is it deleted at the end of the program execution?</p>\n<p>Also, is the answer to this question the same for the <strong>C</strong> language? </p>\n", "Tags": "<c++><variables><scope><stack>", "OwnerUserId": "794436", "AnswerCount": "6"}, "6377791": {"ParentId": "6377767", "CommentCount": "1", "Body": "<p>It is destroyed when it goes out of scope. Same for C.</p>\n", "OwnerUserId": "10077", "PostTypeId": "2", "Id": "6377791", "Score": "2", "CreationDate": "2011-06-16T19:55:57.357", "LastActivityDate": "2011-06-16T19:55:57.357"}, "6377826": {"ParentId": "6377767", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>For stack-declared variables, the destructor is called and the memory reclaimed as it falls out of scope.</p>\n<p>Note that this doesn't mean at the end of the function if the variable is declared in an inner block, like an if-statement or loop.</p>\n<pre><code>int main(int argc, char **argv)\n{\n    int a = 3;\n\n    if (argc &gt; 1)\n    {\n        int b = 5;\n        ++b;\n    } // b is destructed here\n\n    // a is destructed here\n    // argv and argc are destructed here (or with a)\n}\n</code></pre>\n<p><strong>EDIT</strong>: A good point was made about the fact that it doesn't matter how the scope is exited. So...</p>\n<pre><code>#include &lt;vector&gt;\n# include &lt;exception&gt;\n\nint main(int argc, char **argv)\n{\n    std::vector&lt;int&gt; myVector(10);\n\n    try\n    {\n        if (argc)\n        {\n            int a = 10;\n            int b = 12;\n            for (int c = 0; c &lt; b; c++) // lol\n            {\n                int c_squared = c*c;\n                int theEleventhElement = myVector.at(c);\n                // the above will throw std::out_of_range at some point!\n            }\n        }\n    }\n    catch (std::out_of_range &amp;ex)\n    {\n        // do nothing\n    }\n}\n</code></pre>\n<p>When the above throws, the stack will unwind as part of the exception handling. Thus, the variables will be destroyed in the following order:</p>\n<ul>\n<li><code>c_squared</code></li>\n<li><code>c</code></li>\n<li><code>b</code> and <code>a</code> (I think in that order, but I don't know if that's mandated in the standard)</li>\n</ul>\n<p>At this point, there is finally a catch handler with only <code>myVector</code> still in scope. That block ignores the exception, and then <code>main</code> ends-- at THAT point <code>myVector</code> is destructed.</p>\n", "OwnerUserId": "129655", "LastEditorUserId": "129655", "LastEditDate": "2011-06-16T20:32:11.273", "Id": "6377826", "Score": "6", "CreationDate": "2011-06-16T19:57:54.923", "LastActivityDate": "2011-06-16T20:32:11.273"}, "6377805": {"ParentId": "6377767", "CommentCount": "0", "Body": "<p>To avoid the ambiguity with the <code>new</code> operator, it might be more appropriate to say that the variable is \"popped\" when leaving a function: see <a href=\"http://en.wikipedia.org/wiki/Stack-based_memory_allocation\" rel=\"nofollow\">stack-based memory allocation</a>.The same goes for C.</p>\n", "OwnerUserId": "118160", "PostTypeId": "2", "Id": "6377805", "Score": "0", "CreationDate": "2011-06-16T19:56:50.197", "LastActivityDate": "2011-06-16T19:56:50.197"}, "bq_ids": {"n4140": {"so_6377767_6378064_0": {"section_id": 3909, "quality": 0.7446808510638298, "length": 35}}, "n3337": {"so_6377767_6378064_0": {"section_id": 3769, "quality": 0.7446808510638298, "length": 35}}, "n4659": {"so_6377767_6378064_0": {"section_id": 4795, "quality": 0.7446808510638298, "length": 35}}}, "6377846": {"ParentId": "6377767", "CommentCount": "0", "Body": "<p>A stack variable is more or less a couple of bytes shaved off the stack by decrementing the stack pointer, it is deleted at the end of the function, however, not simply moving the stack pointer up again (the case of user-defined types) in C++ because of the extra destruction stuff.</p>\n<p>In C, it is the simple case of moving up the stack pointer to get rid of the variables held.</p>\n", "OwnerUserId": "612665", "PostTypeId": "2", "Id": "6377846", "Score": "0", "CreationDate": "2011-06-16T19:59:34.443", "LastActivityDate": "2011-06-16T19:59:34.443"}});