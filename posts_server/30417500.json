post_cb({"bq_ids": {"n4140": {"so_30417500_30417581_0": {"length": 7, "quality": 1.0, "section_id": 5573}}, "n3337": {"so_30417500_30417581_0": {"length": 7, "quality": 1.0, "section_id": 5355}}, "n4659": {"so_30417500_30417581_0": {"length": 7, "quality": 1.0, "section_id": 7020}}}, "30417500": {"ViewCount": "80", "Body": "<p>I'm trying to figure out exactly what requirements are made on forward_iterators' <code>reference</code> types.  In the obvious cases you'll have <code>value_type = T;</code> and <code>reference = T&amp;;</code>.  Reading the <a href=\"http://en.cppreference.com/w/cpp/concept/ForwardIterator\" rel=\"nofollow\">cppreference page</a> on forward iterator requirements, I saw </p>\n<pre><code>Expression  Return      Equivalent expression\n*i++        reference   value_type&amp; temp=*i; ++i; return temp;\n</code></pre>\n<p><code>std::vector&lt;bool&gt;</code> shows that the \"equivalent expression\" isn't always valid since it returns a proxy object:</p>\n<pre><code>std::vector&lt;bool&gt; v(10);\nauto i = v.begin();\nstd::vector&lt;bool&gt;::iterator::value_type&amp; temp = *i; // error\n// can't bind bool&amp; to std::_Bit_reference\n</code></pre>\n<p>The equivalent expression isn't mentioned in the standard that I saw.  The proxy object allows assignment though, which might be the key to conformance.</p>\n<p>Outside of just all around trying to nail down the requirements, my specific question concerns knowing whether or not having <code>value_type</code> == <code>reference</code> where neither is a reference or supports assignment, would work with the standard libraries.</p>\n<p>Would some <code>Container&lt;int&gt;</code> with an <code>iterator</code> tagged as <code>forward_iterator_tag</code> and <code>reference == int</code> be valid?</p>\n", "AcceptedAnswerId": "30417581", "Title": "Requirements for forward iterator iterator_traits::reference", "CreationDate": "2015-05-23T20:55:20.630", "Id": "30417500", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-05-23T21:09:13.370", "Score": "0", "OwnerUserId": "1013719", "Tags": "<c++><iterator>", "AnswerCount": "1"}, "30417581": {"Id": "30417581", "PostTypeId": "2", "Body": "<p>The requirements are enumerated in [forward.iterators]:</p>\n<blockquote>\n<p id=\"so_30417500_30417581_0\">A class or pointer type <code>X</code> satisfies the requirements of a forward iterator if  </p>\n<ul>\n<li><code>X</code> satisfies the requirements of an input iterator (24.2.3),</li>\n<li><code>X</code> satisfies the DefaultConstructible requirements (17.6.3.1),</li>\n<li>if <code>X</code> is a mutable iterator, <code>reference</code> is a reference to <code>T</code>; if <code>X</code> is a const iterator, reference is a reference\n  to <code>const T</code>,</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>So if your container has <code>reference</code> == <code>int</code>, then it does not meet the requirements of forward iterator. Which I suppose technically makes <code>vector&lt;bool&gt;::iterator</code> just an input iterator, even though it's tagged as a random access iterator.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-23T21:09:13.370", "Score": "3", "CreationDate": "2015-05-23T21:03:43.973", "ParentId": "30417500", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2015-05-23T21:09:13.370"}});