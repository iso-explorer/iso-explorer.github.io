post_cb({"12997621": {"ParentId": "12997600", "CommentCount": "0", "Body": "<p>You can and you should use <code>typename some_container::size_type</code> for this, even most STL compilers typedef <code>size_type</code> as <code>size_t</code> but as you say using this technique you can support custom containers</p>\n", "OwnerUserId": "1425813", "PostTypeId": "2", "Id": "12997621", "Score": "0", "CreationDate": "2012-10-21T12:03:07.190", "LastActivityDate": "2012-10-21T12:03:07.190"}, "12997832": {"ParentId": "12997600", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Following is one way to determine if a <code>class</code> contains a type (e.g. <code>size_type</code>) or not:</p>\n<pre><code>template &lt;typename T&gt; \nstruct Has_size_type\n{\n  typedef char (&amp;yes)[2];\n\n  template &lt;typename C&gt; static yes test(typename C::size_type*);\n  template &lt;typename&gt; static char test(...);\n\n  static const bool value = sizeof(test&lt;T&gt;(0)) == sizeof(yes);\n};\n</code></pre>\n<p>And following is the way to choose between 2 types:</p>\n<pre><code>template&lt;bool&gt; struct Bool;\ntemplate&lt;typename T, typename = Bool&lt;true&gt; &gt;\nstruct Set { typedef size_type type; };\ntemplate&lt;typename T&gt;\nstruct Set&lt;T,Bool&lt;Has_size_type&lt;T&gt;::value&gt; &gt; { typedef typename T::size_type type; };\n</code></pre>\n<p><strong>Edit start</strong>: Here is another simpler approach:</p>\n<pre><code>template&lt;typename T&gt;\nstruct void_ { typedef void type; };\n\ntemplate&lt;typename T, typename = void&gt;\nstruct Set \n{ typedef size_type type; };\n\ntemplate&lt;typename T&gt;\nstruct Set&lt;T,typename void_&lt;typename T::size_type&gt;::type&gt;\n{ typedef typename T::size_type type; };\n</code></pre>\n<p><strong>Edit end</strong>.</p>\n<p>So finally, use as below:</p>\n<pre><code>template&lt;typename some_container&gt;\nint func(some_container&amp; input)\n{\n  typedef typename Set&lt;some_container&gt;::type type;\n}\n</code></pre>\n<p>So now <code>type</code> is either <code>size_type</code> or <code>some_container::size_type</code>, if it has that.</p>\n", "OwnerUserId": "514235", "LastEditorUserId": "514235", "LastEditDate": "2012-10-21T12:48:49.163", "Id": "12997832", "Score": "4", "CreationDate": "2012-10-21T12:31:47.830", "LastActivityDate": "2012-10-21T12:48:49.163"}, "12997600": {"CommentCount": "2", "CreationDate": "2012-10-21T12:00:18.343", "PostTypeId": "1", "AcceptedAnswerId": "12997832", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-29T14:11:56.773", "LastEditDate": "2017-05-23T12:27:56.583", "ViewCount": "941", "FavoriteCount": "1", "Title": "Choosing between size_t and container::size_type in compile time", "Id": "12997600", "Score": "2", "Body": "<p>I was thinking to be more pedantic in choosing data type in a block of code where I would need to choose between <strike><code>size_type</code></strike> <code>size_t</code> in general or <code>container::size_type</code> for container types. My problem is that if I have the following block of code, I don't know how to do it. Can anybody there help?</p>\n<pre><code>template&lt;typename some_container&gt;\nint func(some_container&amp; input)\n{\n    //Some code...\n    //...\n    decltype(input.size()) variable_x; //Choose this if defined,\n    size_t                 variable_x; //otherwise choose this\n    //... Some more code...\n}\n</code></pre>\n<p>In this case <code>some_container</code> may be a <em>custom container</em> and does not provide <code>size()</code> function. What led me to this thinking was reading the difference between <code>size_t</code> and <code>container::size_type</code> at <a href=\"https://stackoverflow.com/questions/918567/size-t-vs-containersize-type\">size_t vs container::size_type</a>. I also read <a href=\"https://stackoverflow.com/questions/9407367/determine-if-a-type-is-an-stl-container-at-compile-time\">Determine if a type is an STL container at compile time</a>, but the approach feels a bit heavy-handed for my situation.</p>\n", "Tags": "<c++><c++11><visual-studio-2012><typetraits><size-type>", "OwnerUserId": "1332416", "AnswerCount": "5"}, "23935447": {"ParentId": "12997600", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Using @<a href=\"https://stackoverflow.com/users/147192/\">Matthieu M.</a>'s answer as a starting point, I use SFINAE to determine if T::size_type exists, rather than checking for <code>size()</code>. Very similar, just avoids the <code>auto</code>:</p>\n<pre><code>/** Fails if T::size_type isn't defined. */ \ntemplate &lt;class T&gt;\ntypename T::size_type SizeType(const T &amp;&amp;t);\n\n/** Fallback to a known size. */\ntemplate &lt;class T&gt;\nstd::size_t SizeType(const T &amp;t);\n\n...\n\nusing size_type = decltype(SizeType&lt;T&gt;(std::declval&lt;T&gt;()));\n</code></pre>\n<p>Like Matthieu did as well, the parameters to the methods must be different in this case to avoid ambiguity.</p>\n", "OwnerUserId": "277718", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:50:26.050", "Id": "23935447", "Score": "0", "CreationDate": "2014-05-29T14:11:56.773", "LastActivityDate": "2014-05-29T14:11:56.773"}, "12998028": {"ParentId": "12997600", "CommentCount": "4", "Body": "<p>You are on the right way using <code>decltype</code>, the trick is to use SFINAE which is easily done using either template classes or functions overloads. I will show the function way since it's so easy in C++11:</p>\n<pre><code>// One helper per size_type source\ntemplate &lt;typename T&gt;\nauto size_type_alt(T const&amp; t) -&gt; decltype(t.size());\n\nauto size_type_alt(...) -&gt; std::size_t;\n\n// The switch between helpers\ntemplate &lt;typename T&gt;\nauto size_type_switch() -&gt; decltype(size_type_alt(std::declval&lt;T&gt;{}));\n\n// And syntactic sugar\ntemplate &lt;typename T&gt;\nusing size_type = decltype(size_type_switch&lt;T&gt;());\n</code></pre>\n<p>Usage:</p>\n<pre><code>template &lt;typename T&gt;\nvoid some_algorithm(T const&amp; t) {\n    size_type&lt;T&gt; const size = 0;\n    // ...\n}\n</code></pre>\n<p><em>Note: the switch and sugar coating layer could be blended together, however I thought you might appreciate seeing the steps separately.</em></p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "12998028", "Score": "5", "CreationDate": "2012-10-21T13:00:20.797", "LastActivityDate": "2012-10-21T13:00:20.797"}, "bq_ids": {"n4140": {"so_12997600_12997720_0": {"section_id": 705, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_12997600_12997720_0": {"section_id": 695, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_12997600_12997720_0": {"section_id": 734, "quality": 0.7058823529411765, "length": 12}}}, "12997720": {"ParentId": "12997600", "CommentCount": "7", "Body": "<p>If it does not have a <code>size_type</code> then it is not a container. Period.</p>\n<p>The standard requires that all containers shall define a type named <code>size_type</code>. From N3337, 23.2.1 General container requirements [container.requirements.general]:</p>\n<blockquote>\n<p id=\"so_12997600_12997720_0\"><strong>Expression:</strong> <code>X::size_type</code><br>\n<strong>Return type:</strong> unsigned integer type<br>\n<strong>Assertion:</strong> <code>size_type</code> can represent any non-negative value of\n  <code>difference_type</code><br>\n<strong>Complexity:</strong> compile time</br></br></br></p>\n</blockquote>\n<p>So your code can look simply as:</p>\n<pre><code>typename some_container::size_type variable_x;\n</code></pre>\n", "OwnerUserId": "277176", "PostTypeId": "2", "Id": "12997720", "Score": "2", "CreationDate": "2012-10-21T12:15:23.050", "LastActivityDate": "2012-10-21T12:15:23.050"}});