post_cb({"bq_ids": {"n4140": {"so_12164061_12164116_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 3304}, "so_12164061_12164116_2": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_12164061_12164116_4": {"length": 12, "quality": 0.75, "section_id": 3287}, "so_12164061_12164116_3": {"length": 12, "quality": 0.7058823529411765, "section_id": 3286}, "so_12164061_12164116_5": {"length": 6, "quality": 1.0, "section_id": 3287}}, "n3337": {"so_12164061_12164116_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 3174}, "so_12164061_12164116_4": {"length": 16, "quality": 1.0, "section_id": 3157}, "so_12164061_12164116_2": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_12164061_12164116_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 3157}, "so_12164061_12164116_5": {"length": 6, "quality": 1.0, "section_id": 3157}}, "n4659": {"so_12164061_12164116_1": {"length": 15, "quality": 0.7142857142857143, "section_id": 4070}, "so_12164061_12164116_4": {"length": 11, "quality": 0.6875, "section_id": 4049}, "so_12164061_12164116_3": {"length": 11, "quality": 0.6470588235294118, "section_id": 4049}, "so_12164061_12164116_5": {"length": 6, "quality": 1.0, "section_id": 4049}}}, "12164116": {"Id": "12164116", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12164061_12164116_0\">Where did I get this idea? </p>\n</blockquote>\n<p>It's apparently a relatively common misconception, as I've heard the same thing from a number of other people recently. Perhaps you picked it up from somebody else with this wrong idea, or perhaps the idea is just 'intuitive'.</p>\n<p><code>{}</code> Initialization has worked as it does at least as far back as C89. I'm not aware of it ever working differently, or any compilers that ever did it differently.</p>\n<p>For initializer lists when initializing an aggregate type (like an array):</p>\n<blockquote>\n<p id=\"so_12164061_12164116_1\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from an empty initializer list (8.5.4). <em>\u2014 Aggregates [dcl.init.aggr] 8.5.1p7</em></p>\n</blockquote>\n<p>In C++ terms, when you use an empty initializer the object is value-initialized.</p>\n<blockquote>\n<p id=\"so_12164061_12164116_2\">To <em>value-initialize</em> an object of type T means:</p>\n<p id=\"so_12164061_12164116_3\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9) with a\n  user-provided constructor (12.1), then the default constructor for T\n  is called (and the initialization is ill-formed if T has no accessible\n  default constructor);</p>\n<p id=\"so_12164061_12164116_4\">\u2014 if T is a (possibly cv-qualified) non-union class type without a\n  user-provided constructor, then the object is zero-initialized and, if\n  T\u2019s implicitly-declared default constructor is non-trivial, that\n  constructor is called.</p>\n<p id=\"so_12164061_12164116_5\">\u2014 if T is an array type, then each element is value-initialized;</p>\n<p id=\"so_12164061_12164116_6\">\u2014 otherwise, the object is zero-initialized.</p>\n<p id=\"so_12164061_12164116_7\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 Initializers [dcl.init] 8.5p7</em></p>\n</blockquote>\n", "LastEditorUserId": "365496", "LastActivityDate": "2012-08-28T17:18:04.480", "Score": "2", "CreationDate": "2012-08-28T17:04:00.983", "ParentId": "12164061", "CommentCount": "2", "LastEditDate": "2012-08-28T17:18:04.480", "OwnerUserId": "365496"}, "12164085": {"Id": "12164085", "PostTypeId": "2", "Body": "<p>It's been this way forever, as long as initializers existed. C89 says:</p>\n<blockquote>\n<p id=\"so_12164061_12164085_0\">If there are fewer initializers in a list than there are members of an\n  aggregate, the remainder of the aggregate shall be initialized\n  implicitly the same as objects that have static storage duration.</p>\n</blockquote>\n", "LastActivityDate": "2012-08-28T17:01:32.913", "Score": "10", "CreationDate": "2012-08-28T17:01:32.913", "ParentId": "12164061", "CommentCount": "1", "OwnerUserId": "714501"}, "12164061": {"ViewCount": "230", "Body": "<p>For some reason I had this idea that C and C++ worked like this:</p>\n<pre><code>int foo[10] = {57};\nfor (int i=0; i&lt;10; ++i)\n    assert (foo[i] == 57);\n</code></pre>\n<p>Turns out the remaining ints are initialized to 0, not 57. Where did I get this idea? Was this true at one point? Was it ever true for structure initializer lists? When did arrays and structures neatly and correctly start initializing themselves to 0 values when assigned to = {} and = {0}? I always thought they'd initialize to garbage unless explicitly told otherwise.</p>\n", "AcceptedAnswerId": "12164085", "Title": "initializer lists in C and C++", "CreationDate": "2012-08-28T16:59:49.700", "Id": "12164061", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-08-28T17:18:04.480", "Score": "3", "OwnerUserId": "1325084", "Tags": "<c++><c><initializer-list>", "AnswerCount": "2"}});