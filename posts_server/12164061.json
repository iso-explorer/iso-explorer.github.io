post_cb({"12164116": {"ParentId": "12164061", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-08-28T17:04:00.983", "Score": "2", "LastEditorUserId": "365496", "LastEditDate": "2012-08-28T17:18:04.480", "Id": "12164116", "OwnerUserId": "365496", "Body": "<blockquote>\n<p id=\"so_12164061_12164116_0\">Where did I get this idea? </p>\n</blockquote>\n<p>It's apparently a relatively common misconception, as I've heard the same thing from a number of other people recently. Perhaps you picked it up from somebody else with this wrong idea, or perhaps the idea is just 'intuitive'.</p>\n<p><code>{}</code> Initialization has worked as it does at least as far back as C89. I'm not aware of it ever working differently, or any compilers that ever did it differently.</p>\n<p>For initializer lists when initializing an aggregate type (like an array):</p>\n<blockquote>\n<p id=\"so_12164061_12164116_1\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from an empty initializer list (8.5.4). <em>\u2014 Aggregates [dcl.init.aggr] 8.5.1p7</em></p>\n</blockquote>\n<p>In C++ terms, when you use an empty initializer the object is value-initialized.</p>\n<blockquote>\n<p id=\"so_12164061_12164116_2\">To <em>value-initialize</em> an object of type T means:</p>\n<p id=\"so_12164061_12164116_3\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9) with a\n  user-provided constructor (12.1), then the default constructor for T\n  is called (and the initialization is ill-formed if T has no accessible\n  default constructor);</p>\n<p id=\"so_12164061_12164116_4\">\u2014 if T is a (possibly cv-qualified) non-union class type without a\n  user-provided constructor, then the object is zero-initialized and, if\n  T\u2019s implicitly-declared default constructor is non-trivial, that\n  constructor is called.</p>\n<p id=\"so_12164061_12164116_5\">\u2014 if T is an array type, then each element is value-initialized;</p>\n<p id=\"so_12164061_12164116_6\">\u2014 otherwise, the object is zero-initialized.</p>\n<p id=\"so_12164061_12164116_7\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 Initializers [dcl.init] 8.5p7</em></p>\n</blockquote>\n", "LastActivityDate": "2012-08-28T17:18:04.480"}, "12164085": {"ParentId": "12164061", "CommentCount": "1", "CreationDate": "2012-08-28T17:01:32.913", "OwnerUserId": "714501", "PostTypeId": "2", "Id": "12164085", "Score": "10", "Body": "<p>It's been this way forever, as long as initializers existed. C89 says:</p>\n<blockquote>\n<p id=\"so_12164061_12164085_0\">If there are fewer initializers in a list than there are members of an\n  aggregate, the remainder of the aggregate shall be initialized\n  implicitly the same as objects that have static storage duration.</p>\n</blockquote>\n", "LastActivityDate": "2012-08-28T17:01:32.913"}, "bq_ids": {"n4140": {"so_12164061_12164116_5": {"section_id": 3287, "quality": 1.0, "length": 6}, "so_12164061_12164116_3": {"section_id": 3286, "quality": 0.7058823529411765, "length": 12}, "so_12164061_12164116_2": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_12164061_12164116_4": {"section_id": 3287, "quality": 0.75, "length": 12}, "so_12164061_12164116_1": {"section_id": 3304, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_12164061_12164116_4": {"section_id": 3157, "quality": 1.0, "length": 16}, "so_12164061_12164116_3": {"section_id": 3157, "quality": 0.9411764705882353, "length": 16}, "so_12164061_12164116_2": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_12164061_12164116_5": {"section_id": 3157, "quality": 1.0, "length": 6}, "so_12164061_12164116_1": {"section_id": 3174, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_12164061_12164116_5": {"section_id": 4049, "quality": 1.0, "length": 6}, "so_12164061_12164116_3": {"section_id": 4049, "quality": 0.6470588235294118, "length": 11}, "so_12164061_12164116_4": {"section_id": 4049, "quality": 0.6875, "length": 11}, "so_12164061_12164116_1": {"section_id": 4070, "quality": 0.7142857142857143, "length": 15}}}, "12164061": {"CommentCount": "5", "ViewCount": "230", "CreationDate": "2012-08-28T16:59:49.700", "LastActivityDate": "2012-08-28T17:18:04.480", "Title": "initializer lists in C and C++", "AcceptedAnswerId": "12164085", "PostTypeId": "1", "Id": "12164061", "Score": "3", "Body": "<p>For some reason I had this idea that C and C++ worked like this:</p>\n<pre><code>int foo[10] = {57};\nfor (int i=0; i&lt;10; ++i)\n    assert (foo[i] == 57);\n</code></pre>\n<p>Turns out the remaining ints are initialized to 0, not 57. Where did I get this idea? Was this true at one point? Was it ever true for structure initializer lists? When did arrays and structures neatly and correctly start initializing themselves to 0 values when assigned to = {} and = {0}? I always thought they'd initialize to garbage unless explicitly told otherwise.</p>\n", "Tags": "<c++><c><initializer-list>", "OwnerUserId": "1325084", "AnswerCount": "2"}});