post_cb({"bq_ids": {"n4140": {"so_5188434_5188545_0": {"section_id": 142, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_5188434_5188545_0": {"section_id": 136, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_5188434_5188545_0": {"section_id": 146, "quality": 0.8333333333333334, "length": 10}}}, "5195250": {"ParentId": "5188434", "CommentCount": "0", "Body": "<p>You can make the parameter a type parameter to work this around</p>\n<pre><code>template&lt; bool &gt; struct bool_ { };\n\ntemplate&lt; class T, T i, typename = bool_&lt;true&gt; &gt;\nstruct printDown {\n    static void run(void) {\n        std::cout &lt;&lt; i &lt;&lt; \"\\n\";\n        printDown&lt; T, i - 1 &gt;::run();\n    }\n};\n\ntemplate&lt; class T, T i &gt;\nstruct printDown&lt; T, i, bool_&lt;i == 0&gt; &gt; {\n    static void run(void) {\n        std::cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n    }\n};\n\nint main(void) {\n    printDown&lt; int, 10 &gt;::run();\n    return 0;\n}\n</code></pre>\n<p>This way you can specify any conditions you want in the partial specializations. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5195250", "Score": "0", "CreationDate": "2011-03-04T14:50:18.753", "LastActivityDate": "2011-03-04T14:50:18.753"}, "5191606": {"ParentId": "5188434", "CommentCount": "3", "Body": "<p>As pointed out by <code>phooji</code> your implementation suffers from a small issue: it quickly generates a long list of calls, which will make compilers choke quickly.</p>\n<p>You could work around this by implementing a slightly more complicated version, using binary decomposition. I'll make it generic on a functor too, cause I am lazy.</p>\n<pre><code>// Signature\ntemplate &lt;Functor F, unsigned N&gt;\nstruct UnrolledLoop;\n</code></pre>\n<p>We need a helper template, which keeps an offset of the parameter to pass</p>\n<pre><code>template &lt;Functor F, unsigned N, unsigned OffSet&gt;\nstruct UnrolledImpl;\n\ntemplate &lt;Functor F, unsigned OffSet&gt;\nstruct UnrolledImpl&lt;F, 0, OffSet&gt;\n{\n  static F run(F f) { return f; }\n};\n\ntemplate &lt;Functor F, unsigned OffSet&gt;\nstruct UnrolledImpl&lt;F, 1, OffSet&gt;\n{\n  static F run(F f) { f(OffSet); return f; }\n};\n\ntemplate &lt;Functor F, unsigned N, unsigned OffSet&gt;\nstruct UnrolledImpl\n{\n  static F run(F f) {\n    F f2 = UnrolledImpl&lt;F, N/2, OffSet&gt;::run(f);\n    return UnrolledImpl&lt;F, N - N/2, OffSet + N/2&gt;::run(f2);\n  }\n};\n</code></pre>\n<p>And you can implement <code>UnrolledLoop</code> simply:</p>\n<pre><code>template &lt;Functor F, unsigned N&gt;\nstruct UnrolledLoop\n{\n  static F run(F f) { return UnrolledImpl&lt;F, N, 0&gt;::run(f); }\n}\n</code></pre>\n<p>Note that you could provide specialization for more values of <code>N</code> (3, 4 for example) to be nicer on the compiler.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "5191606", "Score": "1", "CreationDate": "2011-03-04T08:57:02.860", "LastActivityDate": "2011-03-04T08:57:02.860"}, "5188479": {"ParentId": "5188434", "CommentCount": "0", "Body": "<p>What about adding this to your example:</p>\n<pre><code>template struct printDown&lt; int, 0 &gt;{\n    static void run(void) {\n    std::cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n} };\n</code></pre>\n<p>The compiler cannot cast 0 to int automatically without knowing T's type in advance.</p>\n", "OwnerUserId": "92529", "PostTypeId": "2", "Id": "5188479", "Score": "0", "CreationDate": "2011-03-04T00:53:11.773", "LastActivityDate": "2011-03-04T00:53:11.773"}, "5188471": {"ParentId": "5188434", "CommentCount": "7", "Body": "<p>Have you tried <code>int i</code> instead of <code>T i</code>?</p>\n", "OwnerUserId": "569266", "PostTypeId": "2", "Id": "5188471", "Score": "5", "CreationDate": "2011-03-04T00:51:11.797", "LastActivityDate": "2011-03-04T00:51:11.797"}, "5188434": {"CommentCount": "0", "ViewCount": "362", "PostTypeId": "1", "LastEditorUserId": "211160", "CreationDate": "2011-03-04T00:45:37.663", "LastActivityDate": "2012-11-14T18:50:36.610", "Title": "Unrolling loops using templates in C++ with partial specialization", "LastEditDate": "2012-11-14T18:50:36.610", "Id": "5188434", "Score": "6", "Body": "<p>I'm trying to use templates to unroll a loop in C++ as follows.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; class T, T i &gt;\nstruct printDown {\n    static void run(void) {\n        std::cout &lt;&lt; i &lt;&lt; \"\\n\";\n        printDown&lt; T, i - 1 &gt;::run();\n    }\n};\n\ntemplate&lt; class T &gt;\nstruct printDown&lt; T, 0 &gt; {\n    static void run(void) {\n        std::cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n    }\n};\n\nint main(void) {\n    printDown&lt; int, 10 &gt;::run();\n    return 0;\n}\n</code></pre>\n<p>When I compile w/ g++ 3.4.4 in Cygwin, I get the following error.</p>\n<blockquote>\n<p id=\"so_5188434_5188434_0\">tmp.cpp:12: error: type <code>T' of\n  template argument</code>0' depends on\n  template parameter(s)</p>\n</blockquote>\n<p>What am I doing wrong?  Do I need to somehow annotate the 0 to say that it's of type T?</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><templates><specialization><partial-specialization><loop-unrolling>", "OwnerUserId": "643913", "AnswerCount": "6"}, "5188545": {"ParentId": "5188434", "CommentCount": "2", "Body": "<p>Why this happens? From 14.5.5/8,</p>\n<blockquote>\n<p id=\"so_5188434_5188545_0\">\u2014 The type of a template parameter\n  corresponding to a specialized\n  non-type argument shall not be\n  dependent on a parameter of the\n  specialization. [ Example:</p>\n</blockquote>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\ntemplate&lt; int X, int (*array_ptr)[X] &gt; class A {};\nint array[5];\ntemplate&lt; int X &gt; class A&lt;X,&amp;array&gt; { }; // error\n</code></pre>\n<blockquote>\n<p id=\"so_5188434_5188545_1\">\u2014end example ]</p>\n</blockquote>\n<p>Therefore when you apply partial specialization, the type of 0 is T (dependent on a parameter of the specialization). There are two choices, one is to make it none dependent, e.g., change T i to int i, and second is to apply explicit specialization rather than partial specialization.</p>\n<p>Both solutions have been given out by others, so I'm not gonna to repost them here. At least you know the reason. It's defined by standard.</p>\n", "OwnerUserId": "534498", "PostTypeId": "2", "Id": "5188545", "Score": "4", "CreationDate": "2011-03-04T01:05:05.187", "LastActivityDate": "2011-03-04T01:05:05.187"}, "5195083": {"ParentId": "5188434", "CommentCount": "0", "Body": "<p>Just found this out.  Apparently one can do something like this.</p>\n<pre><code>template&lt; class T, T i, bool b = (i == 0) &gt;\nstruct printDown {\n    static void run(void) {\n        std::cout &lt;&lt; i &lt;&lt; \"\\n\";\n        printDown&lt; T, i - 1 &gt;::run();\n    }\n};\n\ntemplate&lt; class T, T i &gt;\nstruct printDown&lt; T, i, true &gt; {\n    static void run(void) {\n        std::cout &lt;&lt; 0 &lt;&lt; \"\\n\";\n    }\n};\n</code></pre>\n<p>I had no idea that could be done.  Very Prologish &amp; very nice.</p>\n", "OwnerUserId": "643913", "PostTypeId": "2", "Id": "5195083", "Score": "0", "CreationDate": "2011-03-04T14:33:32.673", "LastActivityDate": "2011-03-04T14:33:32.673"}});