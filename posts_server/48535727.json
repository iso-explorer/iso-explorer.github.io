post_cb({"bq_ids": {"n4140": {"so_48535727_48538153_2": {"length": 34, "quality": 0.9714285714285714, "section_id": 969}}, "n3337": {"so_48535727_48538153_2": {"length": 34, "quality": 0.9714285714285714, "section_id": 958}}, "n4659": {"so_48535727_48538153_2": {"length": 34, "quality": 0.9714285714285714, "section_id": 1031}}}, "48535727": {"ViewCount": "396", "Body": "<p>I've run into a strange situation.</p>\n<p>In my program I have a loop that combines a bunch of data together in a giant vector. I was trying to figure out why it was running so slowly, even though it seemed like I was doing everything right to allocate memory in an efficient manner on the go.</p>\n<p>In my program it is difficult to determine how big the final vector of combined data should be, but the size of each piece of data is known as it is processed. So instead of <strong>reserving</strong> and <strong>resizing</strong> the combined data vector in one go, I was reserving enough space for each data chunk as it is added to the larger vector. That's when I ran into this issue that is repeatable using the simple snippet below:</p>\n<pre><code>std::vector&lt;float&gt; arr1;\nstd::vector&lt;float&gt; arr2;\nstd::vector&lt;float&gt; arr3;\nstd::vector&lt;float&gt; arr4;\nint numLoops = 10000;\nint numSubloops = 50;\n\n{\n    // Test 1\n    // Naive test where no pre-allocation occurs\n\n    for (int q = 0; q &lt; numLoops; q++)\n    {\n        for (int g = 0; g &lt; numSubloops; g++)\n        {\n            arr1.push_back(q * g);\n        }\n    }\n}\n\n{\n    // Test 2\n    // Ideal situation where total amount of data is reserved beforehand\n\n    arr2.reserve(numLoops * numSubloops);\n    for (int q = 0; q &lt; numLoops; q++)\n    {\n        for (int g = 0; g &lt; numSubloops; g++)\n        {\n            arr2.push_back(q * g);\n        }\n    }\n}\n\n{\n    // Test 3\n    // Total data is not known beforehand, so allocations made for each\n    // data chunk as they are processed using 'resize' method\n\n    int arrInx = 0;\n    for (int q = 0; q &lt; numLoops; q++)\n    {\n        arr3.resize(arr3.size() + numSubloops);\n        for (int g = 0; g &lt; numSubloops; g++)\n        {\n            arr3[arrInx++] = q * g;\n        }\n    }\n}\n\n{\n    // Test 4\n    // Total data is not known beforehand, so allocations are made for each\n    // data chunk as they are processed using the 'reserve' method\n\n    for (int q = 0; q &lt; numLoops; q++)\n    {\n        arr4.reserve(arr4.size() + numSubloops);\n        for (int g = 0; g &lt; numSubloops; g++)\n        {\n            arr4.push_back(q * g);\n        }\n    }\n}\n</code></pre>\n<p>The results of this test, after compilation in Visual\u00a0Studio\u00a02017, are as follows:</p>\n<pre><code>Test 1: 7 ms\nTest 2: 3 ms\nTest 3: 4 ms\nTest 4: 4000 ms\n</code></pre>\n<p>Why is there the huge discrepancy in running times?</p>\n<p>Why does calling <code>reserve</code> a bunch of times, followed by <code>push_back</code> take 1000x times longer than calling <code>resize</code> a bunch of times, followed by direct index access?</p>\n<p>How does it make any sense that it could take 500x longer than the naive approach which includes no pre-allocations at all?</p>\n", "AcceptedAnswerId": "48535836", "Title": "Why are C++ STL vectors 1000x slower when doing many reserves?", "CreationDate": "2018-01-31T06:23:03.610", "LastActivityDate": "2018-01-31T12:35:16.560", "CommentCount": "13", "LastEditDate": "2018-01-31T12:35:16.560", "PostTypeId": "1", "LastEditorUserId": "63550", "Id": "48535727", "Score": "6", "OwnerUserId": "613979", "Tags": "<c++><vector><stl><resize>", "AnswerCount": "2"}, "48535836": {"Id": "48535836", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48535727_48535836_0\">How does it make any sense that it could take 500x longer than the\n  naive approach which includes no pre-allocations at all?</p>\n</blockquote>\n<p>That's where you're mistaken. The 'naive' approach you speak of does do pre-allocations. They're just done behind the scenes, and infrequently, in the call to <code>push_back</code>. It doesn't just allocate room for one more element every time you call <code>push_back</code>. It allocates some amount that is a factor (usually between 1.5x and 2x) of the current capacity. And then it doesn't need to allocate again until that capacity runs out. This is much more efficient than your loop which does an allocation every time 50 elements are added, with no regard for the current capacity.</p>\n", "LastEditorUserId": "440119", "LastActivityDate": "2018-01-31T06:33:49.993", "Score": "16", "CreationDate": "2018-01-31T06:30:58.493", "ParentId": "48535727", "CommentCount": "10", "OwnerUserId": "440119", "LastEditDate": "2018-01-31T06:33:49.993"}, "48538153": {"Id": "48538153", "PostTypeId": "2", "Body": "<p>@Benjamin Lindley's answer explains the capacity of <code>std::vector</code>. However, for exactly why the 4th test case is that slow, in fact it's an implementation detail of the standard library.</p>\n<p><a href=\"http://www.eel.is/c++draft/vector.capacity#itemdecl:2\" rel=\"nofollow noreferrer\">[vector.capacity]</a></p>\n<blockquote>\n<p id=\"so_48535727_48538153_0\">void reserve(size_type n);</p>\n<p id=\"so_48535727_48538153_1\">...</p>\n<p id=\"so_48535727_48538153_2\">Effects: A directive that informs a vector of a planned change in size, so that it can manage the storage allocation accordingly. <strong>After reserve(), capacity() is greater or equal to the argument of reserve if reallocation happens</strong>; and equal to the previous value of capacity() otherwise. Reallocation happens at this point if and only if the current capacity is less than the argument of reserve(). </p>\n</blockquote>\n<p>Thus it is <strong>not</strong> guaranteed by C++ standard that after <code>reserve()</code> for a larger capacity, the actual capacity should be the requested one. Personally I think it's not unreasonable for an implementation to follow some specific policy when such larger capacity request is received. However, I also tested on my machine, it seems the STL just does the simplest thing.</p>\n", "LastActivityDate": "2018-01-31T08:58:24.377", "Score": "3", "CreationDate": "2018-01-31T08:58:24.377", "ParentId": "48535727", "CommentCount": "0", "OwnerUserId": "8605791"}});