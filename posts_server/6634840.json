post_cb({"bq_ids": {"n4140": {"so_6634840_6635848_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 7230}}, "n3337": {"so_6634840_6635848_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 6974}}}, "6635848": {"PostTypeId": "2", "Body": "<p>Per ISO/IEC 9899:1999 (E) \u00a76.5/7:</p>\n<blockquote>\n<p id=\"so_6634840_6635848_0\">\u00a07. An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>[...]</li>\n<li>a character type</li>\n</ul>\n</blockquote>\n<p>So it is legal (in C) to dereference and examine a (valid) pointer via <code>unsigned char</code>. However, the contents you'll find there are unspecified; <code>tryToFigureOutWhatThisIs</code> has no well-defined way of actually figuring out what it's looking at. I don't have a copy of the C++ spec here, but I suspect it uses the same definition, in order to maintain compatibility.</p>\n", "LastActivityDate": "2011-07-09T15:55:56.023", "Id": "6635848", "CommentCount": "1", "CreationDate": "2011-07-09T15:55:56.023", "ParentId": "6634840", "Score": "2", "OwnerUserId": "36723"}, "6634885": {"PostTypeId": "2", "Body": "<p>C++ assumes strict aliasing, which means that two pointers of fundamentally different type do not alias the same value.</p>\n<p>However, as correctly pointed out by bdonlan, the standard makes an exception for <code>char</code> and <code>unsigned char</code> pointers.</p>\n<p>Thus, in general this is undefined behaviour for any pointer type to read <em>any deliberate</em> address (which might be any type), but for the particular case of <code>unsigned char</code> as in the question it is <strong>allowed</strong> (ISO 14882:2003 3.10(15)).</p>\n<p><code>static_cast</code> does compile-time type checking, so it is unlikely to always work. In such a case, you will want <code>reinterpret_cast</code>.</p>\n", "LastActivityDate": "2011-07-09T18:04:25.253", "LastEditorUserId": "572743", "Id": "6634885", "CommentCount": "6", "CreationDate": "2011-07-09T13:02:04.690", "ParentId": "6634840", "Score": "6", "OwnerUserId": "572743", "LastEditDate": "2011-07-09T18:04:25.253"}, "6634840": {"ViewCount": "289", "Body": "<p>My search foo seems lacking today.</p>\n<p>I would like to know if it is <em>legal</em> according to std C++ to inspect \"any\" memory location via an (unsigned(?)) char*. By <em>any</em> location I mean any <em>valid</em> address of an object or array (or inside an array) inside the program.</p>\n<p>By way of example:</p>\n<pre><code>void passAnyObjectOrArrayOrSomethingElseValid(void* pObj) {\n   unsigned char* pMemory = static_cast&lt;unsigned char*&gt;(pObj)\n   MyTypeIdentifyier x = tryToFigureOutWhatThisIs(pMemory);\n}\n</code></pre>\n<p><strong>Disclaimer</strong>: This question is purely academical. I do not intend to put this into production code! By <em>legal</em> I mean if it's really <em>legal</em> according to the standard, that is if it would work on 100% of all implementations. (Not just on x86 or some common hardware.)</p>\n<p>Sub-question: Is <code>static_cast</code> the right tool to get from the void* address to the char* pointer?</p>\n", "AcceptedAnswerId": "6634885", "Title": "Can I read any readable valid memory location via a (unsigned) char* in C++?", "CreationDate": "2011-07-09T12:51:56.650", "Id": "6634840", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-09-07T19:29:11.617", "LastEditorUserId": "50776", "LastActivityDate": "2012-09-07T19:29:11.617", "Score": "5", "OwnerUserId": "321013", "Tags": "<c++><string><pointers><void-pointers><memory-access>", "AnswerCount": "3"}, "6634906": {"PostTypeId": "2", "Body": "<p>You can only use a <code>char*</code>, not an <code>unsigned char*</code>. Using an <code>unsigned char*</code> will break strict aliasing rules and invoke undefined behaviour, but there is an exception for <code>char*</code>. However, trying to actually do anything with the memory you read is very highly dubious and very likely to do something undefined. That's why it's rarely done in idiomatic C++ code.</p>\n", "LastActivityDate": "2011-07-09T13:06:03.380", "Id": "6634906", "CommentCount": "5", "CreationDate": "2011-07-09T13:06:03.380", "ParentId": "6634840", "Score": "0", "OwnerUserId": "298661"}});