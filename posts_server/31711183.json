post_cb({"31711699": {"ParentId": "31711183", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"https://stackoverflow.com/a/31711422/2069064\">bogdan</a> already has to the answer, but to build on why your intuition is incorrect, you cited:</p>\n<blockquote>\n<p id=\"so_31711183_31711699_0\">If name lookup finds a declaration for a name in <strong>two different namespaces</strong>, and the declarations do not declare the same entity and do not declare functions, the use of the name is ill-formed.</p>\n</blockquote>\n<p>But in the example, we have:</p>\n<pre><code>namespace M { \n    struct i {};           // declares M::i, entity class type\n}\nnamespace N { \n    static int i = 1;      // declares N::i, entity variable\n}\nusing M::i;                // declares ::i, synonym of M::i\nusing N::i;                // declares ::i, synonym of N::i\n                           // hides (*) the other ::i\nint main() { \n    sizeof (i); \n}\n</code></pre>\n<p>To elaborate on <code>(*)</code>, we have two declaration of <code>i</code> in the global namespace <code>::</code>. From [basic.scope.hiding]:</p>\n<blockquote>\n<p id=\"so_31711183_31711699_1\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member,\n  function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data\n  member, function, or enumerator are declared in the same scope (in any order) with the same name, the\n  class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is\n  visible.</p>\n</blockquote>\n<p>So with the two <code>i</code>s in the same scope, the class is hidden (<strong>irrespective</strong> of the ordering of the <em>using-declarations</em>!), and <code>sizeof(i)</code> refers to the <code>::i</code> that is the synonym of <code>N::i</code>. Both <code>i</code>s were in the <em>same</em> namespace (<code>::</code>), which is why your quote doesn't apply. This differs from your <a href=\"https://stackoverflow.com/q/31702956/2069064\">earlier question</a>, where you had <em>using-directives</em> instead:</p>\n<pre><code>using namespace M;\nusing namespace N;\n</code></pre>\n<p>There <code>i</code> would be found in two different namespaces, referring to two different non-function entities. Hence, the error. Here, Clang is wrong and GCC is correct. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:21:42.520", "Id": "31711699", "Score": "1", "CreationDate": "2015-07-29T21:42:45.217", "LastActivityDate": "2015-07-29T21:42:45.217"}, "31711422": {"ParentId": "31711183", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>N4527 [7.3.3p13]:</p>\n<blockquote>\n<p id=\"so_31711183_31711422_0\">Since a <em>using-declaration</em> is a declaration, the restrictions on\n  declarations of the same name in the same declarative region (3.3)\n  also apply to <em>using-declarations</em>. [ <em>Example:</em></p>\n<pre><code>namespace A {\n   int x;\n}\n\nnamespace B {\n   int i;\n   struct g { };\n   struct x { };\n   void f(int);\n   void f(double);\n   void g(char);    // OK: hides struct g\n}\n\nvoid func() {\n   int i;\n   using B::i;      // error: i declared twice\n   void f(char);\n   using B::f;      // OK: each f is a function\n   f(3.5);          // calls B::f(double)\n   using B::g;\n   g(\u2019a\u2019);          // calls B::g(char)\n   struct g g1;     // g1 has class type B::g\n   using B::x;\n   using A::x;      // OK: hides struct B::x\n   x = 99;          // assigns to A::x\n   struct x x1;     // x1 has class type B::x\n}\n</code></pre>\n<p id=\"so_31711183_31711422_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>Note the <em>using-declarations</em> for the two different <code>x</code>s - it's the same case as your example.</p>\n<hr>\n<p>Your first quote is referring to <em>using-directives</em>, not <em>using-declarations</em>.</p>\n<p>Unqualified name lookup for the <code>i</code> in <code>sizeof(i)</code> finds the <code>i</code>s in the global namespace. Since they are declarations in the same scope, according to [3.3.10p2] (quote below), the variable <code>i</code> hides the <code>struct</code>.</p>\n<blockquote>\n<p id=\"so_31711183_31711422_2\">A class name (9.1) or enumeration name (7.2) can be hidden by the name\n  of a variable, data member, function, or enumerator declared in the\n  same scope. If a class or enumeration name and a variable, data\n  member, function, or enumerator are declared in the same scope (in any\n  order) with the same name, the class or enumeration name is hidden\n  wherever the variable, data member, function, or enumerator name is\n  visible.</p>\n</blockquote>\n<p>So, the code is well-formed and Clang is wrong to reject it.</p>\n<p>MSVC (12 and 14) accepts the example.</p>\n<hr>\n<p>Basically, think of the name introduced by a <em>using-declaration</em> as just another name for some entity, which is also named somewhere else (the place designated by the <em>nested-name-specifier</em> of the <em>qualified-id</em> in the <em>using-declaration</em>). This is different from what a <em>using-directive</em> does; I tend to think of <em>using-directives</em> as \"name lookup tweaks\".</p>\n</hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2015-07-29T21:44:32.633", "Id": "31711422", "Score": "1", "CreationDate": "2015-07-29T21:24:52.157", "LastActivityDate": "2015-07-29T21:44:32.633"}, "31711183": {"CommentCount": "3", "ViewCount": "239", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2015-07-29T21:10:38.643", "LastActivityDate": "2015-07-29T21:57:08.860", "Title": "How does unqualified name lookup work when using using-declarations?", "AcceptedAnswerId": "31711699", "LastEditDate": "2015-07-29T21:57:08.860", "Id": "31711183", "Score": "2", "Body": "<p>Is this ill-formed or well-formed according to the c++ standard?</p>\n<pre><code>namespace M { struct i {}; }\nnamespace N { static int i = 1; }\nusing M::i;\nusing N::i;\nint main() { sizeof (i); }\n</code></pre>\n<p>Clang rejects it and GCC accepts it.</p>\n<p>According to [namespace.udir-6] (<a href=\"http://eel.is/c++draft/basic.namespace#namespace.udir-6\" rel=\"nofollow\">http://eel.is/c++draft/basic.namespace#namespace.udir-6</a>):</p>\n<blockquote>\n<p id=\"so_31711183_31711183_0\">If name lookup finds a declaration for a name in two different\n  namespaces, and the declarations do not declare the same entity and do\n  not declare functions, the use of the name is ill-formed.</p>\n</blockquote>\n<p>How should we interpret this? Remember that each using-declaration are declaring a name by [namespace.udecl]p1 (<a href=\"http://eel.is/c++draft/namespace.udecl#1\" rel=\"nofollow\">http://eel.is/c++draft/namespace.udecl#1</a>):</p>\n<blockquote>\n<p id=\"so_31711183_31711183_1\">A using-declaration introduces a name into the declarative region in\n  which the using-declaration appears.</p>\n<p id=\"so_31711183_31711183_2\"><em>using-declaration</em>:<br>\n  \u00a0\u00a0\u00a0<code>using typename</code><sub>opt</sub> <em>nested-name-specifier</em> <em>unqualified-id</em> <code>;</code></br></p>\n<p id=\"so_31711183_31711183_3\">The member name specified in a using-declaration is declared in the\n  declarative region in which the using-declaration appears. [ Note:\n  Only the specified name is so declared; specifying an enumeration name\n  in a using-declaration does not declare its enumerators in the\n  using-declaration's declarative region.  \u2014 end note ] If a\n  using-declaration names a constructor ([class.qual]), it implicitly\n  declares a set of constructors in the class in which the\n  using-declaration appears ([class.inhctor]); otherwise the name\n  specified in a using-declaration is a synonym for a set of\n  declarations in another namespace or class.</p>\n</blockquote>\n<p>So we have 4 declarations of the name i.</p>\n<p>Which of these does unqualified name lookup of <code>i</code> in <code>sizeof(i)</code> find?  </p>\n<p>Does it only find <code>using  M::i;</code> and <code>using N::i;</code> which are both in the same namespace (the global namespace) so the program is well-formed?</p>\n<p>Or does it only find <code>struct i {};</code> and <code>static int i = 1;</code> which are in different namespaces so the program is ill-formed?</p>\n<p>Or do we have some other alternative?</p>\n", "Tags": "<c++><language-lawyer><name-lookup><using-declaration><name-hiding>", "OwnerUserId": "1272610", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31711183_31711183_3": {"section_id": 5490, "quality": 0.86, "length": 43}, "so_31711183_31711699_1": {"section_id": 7079, "quality": 1.0, "length": 41}, "so_31711183_31711699_0": {"section_id": 5514, "quality": 1.0, "length": 17}, "so_31711183_31711183_0": {"section_id": 5514, "quality": 1.0, "length": 17}, "so_31711183_31711422_0": {"section_id": 5502, "quality": 0.9285714285714286, "length": 13}, "so_31711183_31711183_1": {"section_id": 5490, "quality": 1.0, "length": 8}, "so_31711183_31711422_2": {"section_id": 7079, "quality": 1.0, "length": 41}}, "n3337": {"so_31711183_31711183_3": {"section_id": 5276, "quality": 0.76, "length": 38}, "so_31711183_31711699_1": {"section_id": 6823, "quality": 1.0, "length": 41}, "so_31711183_31711699_0": {"section_id": 5300, "quality": 1.0, "length": 17}, "so_31711183_31711183_0": {"section_id": 5300, "quality": 1.0, "length": 17}, "so_31711183_31711422_0": {"section_id": 5288, "quality": 0.9285714285714286, "length": 13}, "so_31711183_31711183_1": {"section_id": 5276, "quality": 1.0, "length": 8}, "so_31711183_31711422_2": {"section_id": 6823, "quality": 1.0, "length": 41}}, "n4659": {"so_31711183_31711699_0": {"section_id": 6949, "quality": 1.0, "length": 17}, "so_31711183_31711699_1": {"section_id": 8580, "quality": 1.0, "length": 41}, "so_31711183_31711183_3": {"section_id": 6924, "quality": 0.54, "length": 27}, "so_31711183_31711183_0": {"section_id": 6949, "quality": 1.0, "length": 17}, "so_31711183_31711422_0": {"section_id": 6936, "quality": 0.9285714285714286, "length": 13}, "so_31711183_31711183_1": {"section_id": 6924, "quality": 0.875, "length": 7}, "so_31711183_31711422_2": {"section_id": 8580, "quality": 1.0, "length": 41}}}});