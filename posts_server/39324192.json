post_cb({"39324192": {"CommentCount": "9", "ViewCount": "211", "CreationDate": "2016-09-05T05:00:28.697", "LastActivityDate": "2016-09-05T06:01:46.310", "Title": "Why is an STL deque not implemented as just a circular vector?", "AcceptedAnswerId": "39324326", "PostTypeId": "1", "Id": "39324192", "Score": "5", "Body": "<p>I always thought that in C++ standard template library (STL), a double-ended queue (deque) is a size-variable array (like a vector) with circular boundary conditions, meaning there's a head pointer <code>i</code> and a tail pointer <code>j</code> both pointing to some position of an array <code>a[0..L-1]</code>. A push_front is <code>i--</code>, a push_back is <code>j++</code>, a pop_front is <code>i++</code>, and a pop_back is <code>j--</code>. When either pointer <code>i</code> or <code>j</code> reaches <code>L</code> or <code>-1</code>, it reappears on the other end of the array (<code>0</code> and <code>L-1</code> respectively). If the array size gets exhausted (pointers <code>i==j</code> after insering a new element), a larger space with double the original size is reallocated to <code>a[]</code> and data gets copied just like in a vector. There's also <code>O(1)</code> time random access taking into account the circular boundary condition. But someone tells me that inside an STL deque there's actually a pointer array pointing to many fixed-length array segments. It's much more complicated than a circular vector. What's the benefit of not using a simple circular vector to implement the functions of a deque? Will the random access get slower?</p>\n", "Tags": "<c++><stl><deque>", "OwnerUserId": "6750410", "AnswerCount": "4"}, "39324446": {"ParentId": "39324192", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The main advantage of the <code>std::deque</code> approach is that elements once inserted in the container are never moved if you add or remove elements from either of the two ends. Thus references (and pointers) to elements are not invalidated when performing those operations (note that, quite surprisingly, <strong>iterators</strong> to <code>deque</code> elements are instead invalidated when doing insertions or deletions on the ends).</p>\n<p>This, while making the implementation more complex, can be done without affecting the formal big-O complexity and makes <code>std::deque</code> a very useful container.</p>\n<p>You can have an <code>std::deque</code> of \"fat\" objects without having to use an extra level of indirection to avoid moving operations and maintain efficiency.</p>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2016-09-05T06:01:46.310", "Id": "39324446", "Score": "3", "CreationDate": "2016-09-05T05:35:16.550", "LastActivityDate": "2016-09-05T06:01:46.310"}, "39324326": {"ParentId": "39324192", "CommentCount": "6", "Body": "<p>As <a href=\"http://en.cppreference.com/w/cpp/container/deque\" rel=\"nofollow\">cppreference</a> writes</p>\n<blockquote>\n<p id=\"so_39324192_39324326_0\">As opposed to std::vector, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays. </p>\n</blockquote>\n<p>This means that the large internal reallocations <code>std::vector</code> occasionally does, are not performed by <code>std::deque</code>. When space runs out, only a small fixed-size array is added. (The same but reverse happens when space becomes too large because of erasing.)</p>\n<p>Here is a small test:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;deque&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n\n\nusing namespace std;\n\n\nint main()\n{\n    {\n        const auto start = chrono::high_resolution_clock::now();\n\n        vector&lt;string&gt; v;\n        for(size_t i = 0; i &lt; 9999999; ++i)\n            v.push_back(string(\"hello\"));\n\n        cout &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::high_resolution_clock::now() - start).count() &lt;&lt; endl;\n    }\n\n    {\n        const auto start = chrono::high_resolution_clock::now();\n\n        deque&lt;string&gt; v;\n        for(size_t i = 0; i &lt; 9999999; ++i)\n            v.push_back(string(\"hello\"));\n\n        cout &lt;&lt; chrono::duration_cast&lt;chrono::milliseconds&gt;(chrono::high_resolution_clock::now() - start).count() &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>On my machine, it shows deque is twice as fast as vector for this case:</p>\n<pre><code>$ ./a.out \n301\n164\n</code></pre>\n", "OwnerUserId": "3510736", "PostTypeId": "2", "Id": "39324326", "Score": "2", "CreationDate": "2016-09-05T05:19:42.967", "LastActivityDate": "2016-09-05T05:19:42.967"}, "39324473": {"ParentId": "39324192", "CommentCount": "2", "Body": "<p><a href=\"http://eel.is/c++draft/deque.modifiers\" rel=\"nofollow\">23.3.8.4 [deque.modifiers]</a> (emphasis is mine)</p>\n<blockquote>\n<p id=\"so_39324192_39324473_0\">An insertion in the middle of the <code>deque</code> invalidates all the iterators\n  and references to elements of the <code>deque</code>. An insertion at either end of\n  the <code>deque</code> invalidates all the iterators to the <code>deque</code>, <strong><em>but has no\n  effect on the validity of references to elements of the</em></strong> <code>deque</code>.</p>\n</blockquote>\n<p>This is not possible with a circular-vector-like implementation.</p>\n", "OwnerUserId": "6394138", "PostTypeId": "2", "Id": "39324473", "Score": "1", "CreationDate": "2016-09-05T05:37:41.970", "LastActivityDate": "2016-09-05T05:37:41.970"}, "39324274": {"ParentId": "39324192", "CommentCount": "0", "Body": "<p><code>std::deque</code> (double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.</p>\n<p>As opposed to <code>std::vector</code>, the elements of a deque are not stored contiguously: typical implementations use a sequence of individually allocated fixed-size arrays.</p>\n<p>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a <code>std::vector</code> because it does not involve copying of the existing elements to a new memory location. </p>\n<p>The complexity (efficiency) of common operations on deques is as follows:</p>\n<ul>\n<li>Random access - constant O(1)</li>\n<li>Insertion or removal of elements at the end or beginning - constant O(1)</li>\n<li>Insertion or removal of elements - linear O(n) </li>\n</ul>\n<p>Source : <a href=\"http://en.cppreference.com/w/cpp/container/deque\" rel=\"nofollow\">std::deque</a></p>\n", "OwnerUserId": "1691223", "PostTypeId": "2", "Id": "39324274", "Score": "0", "CreationDate": "2016-09-05T05:12:40.917", "LastActivityDate": "2016-09-05T05:12:40.917"}, "bq_ids": {"n4140": {"so_39324192_39324473_0": {"section_id": 817, "quality": 1.0, "length": 23}}, "n3337": {"so_39324192_39324473_0": {"section_id": 806, "quality": 1.0, "length": 23}}, "n4659": {"so_39324192_39324473_0": {"section_id": 876, "quality": 1.0, "length": 23}}}});