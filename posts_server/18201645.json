post_cb({"bq_ids": {"n4140": {"so_18201645_18201697_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 582}, "so_18201645_18201697_1": {"length": 33, "quality": 1.0, "section_id": 583}}, "n3337": {"so_18201645_18201697_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 572}, "so_18201645_18201697_1": {"length": 33, "quality": 1.0, "section_id": 573}}, "n4659": {"so_18201645_18201697_0": {"length": 40, "quality": 0.9090909090909091, "section_id": 605}, "so_18201645_18201697_1": {"length": 33, "quality": 1.0, "section_id": 606}}}, "18201645": {"ViewCount": "80", "Body": "<p>All the authors write that, by default, the compiler generates</p>\n<pre><code>1. the default constructor\n2. copy constructor\n3. assignment operator\n4. destructor\n</code></pre>\n<p>The other day a friend of mine invited for an interview and there he was told that by default, the compiler generates still one  function reference operator (operator &amp;()). it is in fact so? </p>\n", "Title": "Defaul compiler generates the reference operator (In C++)?", "CreationDate": "2013-08-13T05:55:00.373", "LastActivityDate": "2013-08-13T06:15:10.540", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-08-13T06:03:32.560", "LastEditorUserId": "1886376", "Id": "18201645", "Score": "2", "OwnerUserId": "1886376", "Tags": "<c++><compiler-construction><reference><operator-overloading><default>", "AnswerCount": "1"}, "18201697": {"Id": "18201697", "PostTypeId": "2", "Body": "<p>No, that is not true. If there is no <code>operator&amp;</code> present, then the one in the core language is used.</p>\n<p>N3485 13.3.1.2 [over.match.oper]/1-2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18201645_18201697_0\">If no operand of an operator in an expression has a type that is a class or an enumeration, <strong>the operator is assumed to be a built-in operator</strong> and interpreted according to Clause 5. [ Note: Because <code>.</code>, <code>.*</code>, and <code>::</code> cannot be overloaded, these operators are always built-in operators interpreted according to Clause 5. <code>?:</code> cannot be overloaded, but the rules in this subclause are used to determine the conversions to be applied to the second and third operands when they have class or enumeration type (5.16). \u2014end note ]</p>\n<p id=\"so_18201645_18201697_1\">If either operand has a type that is a class or an enumeration, a user-defined operator function <strong>might be declared</strong> that implements this operator or a user-defined conversion can be necessary to convert the operand to a type that is appropriate for a built-in operator. <strong>In this case</strong>, overload resolution is used to determine which operator function or built-in operator is to be invoked to implement the operator.</p>\n</blockquote>\n<p>You can also see this in that the functions implicitly declared for you are listed as the \"Special Member Functions (Clause 12), which makes no reference to <code>operator&amp;</code>.</p>\n", "LastEditorUserId": "82320", "LastActivityDate": "2013-08-13T06:15:10.540", "Score": "4", "CreationDate": "2013-08-13T05:58:06.337", "ParentId": "18201645", "CommentCount": "4", "OwnerUserId": "82320", "LastEditDate": "2013-08-13T06:15:10.540"}});