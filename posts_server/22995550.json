post_cb({"bq_ids": {"n4140": {"so_22995550_22995687_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 709}}, "n3337": {"so_22995550_22995687_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 698}}, "n4659": {"so_22995550_22995687_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 738}}}, "22995550": {"ViewCount": "676", "Body": "<p>I am getting a crash when trying to move a <code>std::vector&lt;T&gt;</code> where <code>T</code> is clearly not movable (no move constructor/assignment operator was defined, and it contains internal pointers)</p>\n<p>But why would the move functions of vector want to call the move functions of <code>T</code>? It should not be necessary.</p>\n<p>So my question from the title: Is a <code>std::vector&lt;T&gt;</code> movable if <code>T</code> is not movable?</p>\n", "AcceptedAnswerId": "22995765", "Title": "Is a std::vector<T> movable if T is not movable?", "CreationDate": "2014-04-10T17:57:14.507", "Id": "22995550", "CommentCount": "7", "LastEditDate": "2014-04-10T17:59:52.947", "PostTypeId": "1", "LastEditorUserId": "2684539", "LastActivityDate": "2014-04-10T19:37:36.857", "Score": "3", "OwnerUserId": "2042388", "Tags": "<c++><c++11><vector><move-semantics>", "AnswerCount": "2"}, "22995765": {"Id": "22995765", "PostTypeId": "2", "Body": "<ol>\n<li><p>Yes, <code>std::vector&lt;T&gt;</code> is movable even if <code>T</code> is not movable.  The left side merely takes ownership from the vector on the right, no elements are touched. (With one exception, listed in #2)</p></li>\n<li><p>The move assignment of a <code>vector</code> would only call the move constructor or move assignment of <code>T</code> if the and their allocators compare as equal and the left side's allocator's <code>propagate_on_container_move_assignment</code> is <code>false</code>.  (Note that if your move constructor might throw or doesn't exist, the copy constructor will be used instead)  However, it is unlikely that you are encountering either of these.  </p>\n<p>Reworded: if <code>propagate_on_container_move_assignment</code> is <code>true</code> (it usually is), then the <code>vector</code> is always movable, and does so without touching individual elements.  If it's <code>false</code>, but the allocators compare equal, the vector will be moved without touching individual elements.  If it's false and the allocators compare inequal, the individual elements will be transferred.  If a nothrow move assignment exists, that's used.  Otherwise, if a copy constructor exists, that's used.  Otherwise the throwing move assignment is used.  If it's neither movable nor copiable, then that's undefined behavior.</p></li>\n<li>Having no move assignment operator defined, and the class containing internal pointers, does <em>not</em> mean your class is not movable.  In fact, it sounds like the compiler thinks it <em>is</em> movable.  If you want to disable moves, use <code>T(T&amp;&amp;) = delete;</code> and <code>T&amp; operator=(T&amp;&amp;) =delete</code>, but I don't recommend that.  Instead, add a correctly working move constructor and move assignemnt.  They tend to be easy, and quite useful.</li>\n</ol>\n", "LastEditorUserId": "845092", "LastActivityDate": "2014-04-10T19:37:36.857", "Score": "4", "CreationDate": "2014-04-10T18:09:58.697", "ParentId": "22995550", "CommentCount": "18", "LastEditDate": "2014-04-10T19:37:36.857", "OwnerUserId": "845092"}, "22995687": {"Id": "22995687", "PostTypeId": "2", "Body": "<p>Table 99 in [container.requirements.general] of n3797 about \"Allocator-aware container requirements\" says about move construction:</p>\n<blockquote>\n<p id=\"so_22995550_22995687_0\"><em>Requires:</em> move construction of <code>A</code> shall not exit via an exception.</p>\n</blockquote>\n<p>Where <code>A</code> is the allocator type. It does not require <em>MoveInsertable</em> for the value type.</p>\n<p>The time complexity requirement is: <em>\"constant\"</em>, btw.</p>\n<hr>\n<p><code>std::vector</code> typically stores some pointers plus the allocator. When move-constructing a <code>std::vector</code>, only pointers and the allocator have to be moved. The elements don't need to be touched.</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2014-04-10T18:46:45.453", "Score": "5", "CreationDate": "2014-04-10T18:05:17.510", "ParentId": "22995550", "CommentCount": "1", "LastEditDate": "2014-04-10T18:46:45.453", "OwnerUserId": "420683"}});