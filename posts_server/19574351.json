post_cb({"19574913": {"ParentId": "19574351", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_19574351_19574913_0\"><strong>8.5.4/3</strong> List-initialization of an object or reference of type T is defined as follows:<br>\n  ...</br></p>\n<ul>\n<li>Otherwise, if T is a reference type, a prvalue temporary of the type referenced by T is list-initialized, and the reference is bound to\n  that temporary.</li>\n</ul>\n</blockquote>\n<p>In your example, <code>a1</code> does not bind directly to <code>a</code>, but to a temporary copy-constructed from <code>a</code>.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "19574913", "Score": "1", "CreationDate": "2013-10-24T19:30:28.587", "LastActivityDate": "2013-10-24T19:30:28.587"}, "19574935": {"ParentId": "19574351", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The definition of list-initialization has changed quite a bit since the publication of the C++11 Standard due to defect reports.</p>\n<p>From draft n3485 (after the Standard has been published, with some corrections but without C++1y features) [dcl.init.list]/3</p>\n<blockquote>\n<p id=\"so_19574351_19574935_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>If <code>T</code> is an aggregate [...]</li>\n<li>Otherwise, if the initializer list has no elements [...]</li>\n<li>Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code> [...]</li>\n<li>Otherwise, if <code>T</code> is a class type [...]</li>\n<li>Otherwise, if the initializer list has a single element of type <code>E</code> and either <code>T</code> is not a reference type or its referenced type is reference-related to <code>E</code>, the object or reference is initialized from that element; if a narrowing conversion is required to convert the element to <code>T</code>, the program is ill-formed.</li>\n<li>Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code> is list-initialized, and the reference is bound to that temporary</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>In the latest draft from the Committee's github repo (ce016c64dc), only a slight change applies here to one point [dcl.init.list]/3:</p>\n<blockquote id=\"so_19574351_19574935_1\">\n<ul>\n<li>Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code> is copy-list-initialized or direct-list-initialized, depending on the kind of initialization for the reference, and the reference is bound to that temporary.</li>\n</ul>\n</blockquote>\n<p>From draft n3242 (before the Standard) [dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_19574351_19574935_2\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>If the initializer list has no elements [...]</li>\n<li>Otherwise, if <code>T</code> is an aggregate [...]</li>\n<li>Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code> [...]</li>\n<li>Otherwise, if <code>T</code> is a class type [...]</li>\n<li>Otherwise, if <code>T</code> is a reference to class type or if <code>T</code> is any reference type and the initializer list has no elements, a prvalue temporary of the type referenced by <code>T</code> is list-initialized, and the reference is bound to that temporary.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>(I don't have a copy of the Standard itself right now.)</p>\n<hr>\n<p>Let's assume your compiler implements the proposed resolutions to the defect reports. Then, the first example</p>\n<pre><code>const A&amp; a1 = { a };\n</code></pre>\n<p>initializes like <code>const A&amp; a1 = a;</code> (no temporary); and the second example</p>\n<pre><code>const A&amp; a2 = { a, 1 };\n</code></pre>\n<p>initializes like <code>const A&amp; a2 = A(a,1);</code>.</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-10-24T19:48:28.633", "Id": "19574935", "Score": "5", "CreationDate": "2013-10-24T19:31:28.413", "LastActivityDate": "2013-10-24T19:48:28.633"}, "bq_ids": {"n4140": {"so_19574351_19574935_1": {"section_id": 3325, "quality": 1.0, "length": 16}, "so_19574351_19574913_0": {"section_id": 3325, "quality": 0.8571428571428571, "length": 6}, "so_19574351_19574935_2": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_19574351_19574935_0": {"section_id": 3325, "quality": 1.0, "length": 6}}, "n3337": {"so_19574351_19574935_1": {"section_id": 3195, "quality": 0.625, "length": 10}, "so_19574351_19574935_2": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_19574351_19574913_0": {"section_id": 3195, "quality": 0.8571428571428571, "length": 6}, "so_19574351_19574935_0": {"section_id": 3195, "quality": 1.0, "length": 6}}, "n4659": {"so_19574351_19574935_1": {"section_id": 4091, "quality": 0.6875, "length": 11}, "so_19574351_19574935_2": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_19574351_19574913_0": {"section_id": 4091, "quality": 0.8571428571428571, "length": 6}, "so_19574351_19574935_0": {"section_id": 4091, "quality": 1.0, "length": 6}}}, "19574351": {"CommentCount": "5", "ViewCount": "213", "PostTypeId": "1", "LastEditorUserId": "866022", "CreationDate": "2013-10-24T19:01:16.750", "LastActivityDate": "2013-11-06T14:54:48.890", "Title": "Single value in constructs vs argument list for construction", "AcceptedAnswerId": "19574935", "LastEditDate": "2013-11-06T14:54:48.890", "Id": "19574351", "Score": "9", "Body": "<p>This question pertains to this <a href=\"http://coliru.stacked-crooked.com/a/d64a2752a07dc380\" rel=\"nofollow\">code snippet</a> reproduced below:</p>\n<pre><code>struct A { \n    A():b(0) { } \n    A(const A&amp;, int b = 0):b(b) { } \n    int b; \n};\n\nint main() {\n  A a;\n\n  const A&amp; a1 = { a };  \n  const A&amp; a2 = { a, 1 };\n  a.b = 2;   \n  std::cout &lt;&lt; a1.b &lt;&lt; a2.b &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The right hand side of the assignment of a1 can be a single value in constructs or an argument list for construction.  Is there anywhere in the standard that specifies which interpretation takes precedence?  For a2, it is a construction of a temporary A whose address is assigned to a2, if I did not misunderstand.</p>\n<p>BTW, compiling this code by clang++ in Coliru produced output 21.  gcc++-4.8 output 01.  </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "264140", "AnswerCount": "2"}});