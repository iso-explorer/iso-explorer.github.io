post_cb({"17876141": {"ParentId": "17874122", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The declaration of <code>template std::basic_ifstream</code> is:</p>\n<pre><code>template&lt; \n    class CharT, \n    class Traits = std::char_traits&lt;CharT&gt;\n&gt; class basic_ifstream;\n</code></pre>\n<p>The C++03 Standard (21.1/1) requires the library to define specializations\nof <code>std::char_traits&lt;CharT&gt;</code> for <code>CharT</code> = <code>char</code>, <code>wchar_t</code>.</p>\n<p>The C++11 Standard (C++11 21.2/1) requires the library to define specializations\nof <code>std::char_traits&lt;CharT&gt;</code> for <code>CharT</code> = <code>char</code>,<code>char16_t</code>,<code>char32_t</code>,<code>wchar_t</code>.</p>\n<p>If you instantiate <code>std::basic_ifstream&lt;Other&gt;</code> with <code>Other</code> not one of\nthe 2[4] types nominated by the Standard to which you are compiling then\nthe behaviour will be undefined, unless you yourself\ndefine <code>my_char_traits&lt;Other&gt;</code> as you require and then instantiate\n<code>std::basic_ifstream&lt;Other,my_char_traits&lt;Other&gt;&gt;</code>.</p>\n<p><strong>CONTINUED</strong> in response to OP's comments.</p>\n<p>Requesting an <code>std::char_traits&lt;Other&gt;</code> will not provoke template instantiation\nerrors: the template is defined <em>so that you may specialize it</em>, but the\ndefault (unspecialized) instantiation is very likely to be <em>wrong</em> for <code>Other</code> \nor indeed for any given <code>CharT</code>, where <em>wrong</em> means <em>does not satisfy the\nthe Standard's requirements for a character traits class per C++03 \u00a7 21.1.1/C++11 \u00a7 21.2.1</em>. </p>\n<p>You suspect that a typedef might thwart the choice of a template specialization \nfor the <code>typedef</code>-ed type, i.e. that the fact that <code>uint8_t</code> and <code>int8_t</code>\nare typedefs for fundamentals character types might result in <code>std::basic_ifstream&lt;byte&gt;</code>\nnot being the same as <code>std::basic_ifstream&lt;FCT&gt;</code>, where <em>FCT</em>\nis the aliased fundamental character type.</p>\n<p>Forget that suspicion.<code>typedef</code> is transparent. It seems you believe <em>one</em> of \nthe typedefs <code>int8_t</code> and <code>uint8_t</code> must be <code>char</code>,  in which case - unless\nthe typedef was somehow intefering with template resolution - \none of the misbehaving <code>basic_ifstream</code> instantiations you have tested would\nhave to be <code>std::basic_ifstream&lt;char&gt;</code></p>\n<p>But what about the fact that <code>typedef char byte</code> is harmless? That belief that\neither <code>int8_t</code> or <code>uint8_t</code> = <code>char</code> is false. You will find that <code>int8_t</code> \nis an alias for <code>signed char</code>  while <code>uint8_t</code> is an alias for <code>unsigned char</code>. \nBut neither <code>signed char</code> nor <code>unsigned char</code> is the same type as <code>char</code>:</p>\n<p>C++03/11 \u00a7 3.9.1/1</p>\n<blockquote>\n<p id=\"so_17874122_17876141_0\">Plain char, signed char, and unsigned char are three distinct types</p>\n</blockquote>\n<p>So both <code>char_traits&lt;int8_t&gt;</code> and <code>char_traits&lt;uint8_t&gt;</code> are default,\nunspecialized, instantiations of template <code>char_traits</code> and you have\nno right to expect that they fulfill that Standard's requirements of\n<em>character traits</em>.</p>\n<p>The one test case in which you found no misbehaviour was for <code>byte</code> = <code>char</code>.\nThat is because <code>char_traits&lt;char&gt;</code> is a Standard specialization provided\nby the library.</p>\n<p>The connection between all the misbehaviour you have observed and the\ntypes that you have substituted for <code>SOMECAST</code> in:</p>\n<pre><code>std::cout &lt;&lt; (SOMECAST)buff; // &lt;------- interesting\n</code></pre>\n<p>is none. Since your testfile contains ASCII text, <code>basic_ifstream&lt;char&gt;</code>\nis the one and only instantiation of <code>basic_ifstream</code> that the Standard warrants\nfor reading it. If you read the file using <code>typedef char byte</code> in your program\nthen none of the casts that you say you substituted will have an unexpected\nresult: <code>SOMECAST</code> = <code>char</code> or <code>unsigned char</code> will output <code>a</code>, and\n<code>SOMECAST</code> = <code>int</code> or <code>unsigned int</code> will output <code>97</code>.</p>\n<p>All the misbehaviour arises from instantiating <code>basic_ifstream&lt;CharT&gt;</code> with <code>CharT</code>\nsome type that the Standard does not warrant.</p>\n", "OwnerUserId": "1362568", "LastEditorUserId": "1362568", "LastEditDate": "2013-07-30T21:38:41.810", "Id": "17876141", "Score": "2", "CreationDate": "2013-07-26T08:06:44.053", "LastActivityDate": "2013-07-30T21:38:41.810"}, "17874122": {"CommentCount": "5", "ViewCount": "2257", "PostTypeId": "1", "ClosedDate": "2013-07-26T14:06:22.333", "LastEditorUserId": "1577658", "CreationDate": "2013-07-26T06:09:33.920", "LastActivityDate": "2013-07-30T21:38:41.810", "Title": "Why doesn't uint8_t and int8_t work with file and console streams?", "AcceptedAnswerId": "17876141", "LastEditDate": "2013-07-27T08:56:35.350", "Id": "17874122", "Score": "-1", "Body": "<pre><code>$ file testfile.txt\ntestfile.txt: ASCII text\n\n$ cat testfile.txt \naaaabbbbccddef\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;cstdint&gt;\ntypedef uint8_t byte; // &lt;-------- interesting\ntypedef std::basic_ifstream&lt;byte&gt; FileStreamT;\nstatic const std::string FILENAME = \"testfile.txt\";\nint main(){\n    FileStreamT file(FILENAME, std::ifstream::in | std::ios::binary);\n    if(!file.is_open())\n        std::cout &lt;&lt; \"COULD NOT OPEN FILE\" &lt;&lt; std::endl;\n    else{\n        FileStreamT::char_type buff;\n        file.read(&amp;buff,1);\n        std::cout &lt;&lt; (SOMECAST)buff; // &lt;------- interesting\n    }\n    std::cout &lt;&lt; \"done\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Depending on what is in the typedef and what is it casted to (or not casted), it does all sorts of stupid things.</p>\n<p>It happens to work with 'typedef char' and no cast. (97 when casted to int, as expected)</p>\n<p>Both uint8_t and int8_t will print</p>\n<ul>\n<li><p>nothing without cast</p></li>\n<li><p>nothing when casted to char or unsigned char</p></li>\n<li><p>8 when casted to int or unsigned (although ASCII 'a' should be 97)</p></li>\n</ul>\n<p>I somehow managed to print a \"\ufffd\" character, but forgot which case it was.</p>\n<p>Why do I get these strange results?</p>\n<h2>notes for the future reader:</h2>\n<p>takeaway from the answer given: only instantiate streams with char (or one of the wide characters also mentioned by the standard), otherwise you get no compiler warning and silent failure</p>\n<p>it is very sad that the standard warrants these things</p>\n<h1>moral of the story: avoid C++</h1>\n", "Tags": "<c++><types><type-conversion><ifstream><uint8t>", "OwnerUserId": "1577658", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17874122_17876141_0": {"section_id": 7210, "quality": 1.0, "length": 9}}, "n3337": {"so_17874122_17876141_0": {"section_id": 6954, "quality": 1.0, "length": 9}}, "n4659": {"so_17874122_17876141_0": {"section_id": 8719, "quality": 1.0, "length": 9}}}});