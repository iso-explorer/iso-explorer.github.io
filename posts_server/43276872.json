post_cb({"bq_ids": {"n4140": {"so_43276872_43277929_2": {"section_id": 7152, "quality": 1.0, "length": 36}, "so_43276872_43277929_1": {"section_id": 7151, "quality": 0.7692307692307693, "length": 50}}, "n3337": {"so_43276872_43277929_2": {"section_id": 6896, "quality": 1.0, "length": 36}, "so_43276872_43277929_1": {"section_id": 6895, "quality": 0.7692307692307693, "length": 50}}, "n4659": {"so_43276872_43277929_2": {"section_id": 8653, "quality": 1.0, "length": 36}}}, "43277929": {"ParentId": "43276872", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>That just happens to be a side effect of the initialization of non-local variables. The standard says:</p>\n<blockquote>\n<p id=\"so_43276872_43277929_0\">3.6.2 Initialization of non-local variables [basic.start.init]</p>\n<p id=\"so_43276872_43277929_1\">...<br/>... Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5)\n  before any other initialization takes place...<br/>... Static initialization shall be performed before any dynamic initialization takes place.\n  Dynamic initialization of a non-local variable with static storage duration is unordered if the variable is an\n  implicitly or explicitly instantiated specialization, and otherwise is ordered [ Note: an explicitly specialized\n  static data member or variable template specialization has ordered initialization. \u2014end note ] Variables\n  with ordered initialization defined within a single translation unit shall be initialized in the order of their\n  definitions in the translation unit.</p>\n</blockquote>\n<p>That's exactly what happens here:</p>\n<ul>\n<li><code>A&lt;int&gt;::a</code> and <code>A&lt;float&gt;::a</code> are both 0 initialized</li>\n<li>they are then initialized in the order of their definitions\n\n<ul>\n<li>first <code>A&lt;int&gt;::a</code> reads what lies in <code>A&lt;float&gt;::a</code> which is 0 because of the previous 0 initialization, adds 1 and is fully initialized with 1</li>\n<li>then <code>A&lt;float&gt;::a</code> gets the value of the now fully initialized <code>A&lt;int&gt;::a</code> which is 1, adds 1 and is fully initialized with 2</li>\n</ul></li>\n</ul>\n<p>That means that this is a well formed program.</p>\n<p>But same paragraph says later:</p>\n<blockquote>\n<p id=\"so_43276872_43277929_2\">if the initialization of an object obj1 refers to an object obj2 of namespace scope\n  potentially requiring dynamic initialization and defined later in the same translation unit, it is unspecified\n  whether the value of obj2 used will be the value of the fully initialized obj2 (because obj2 was statically\n  initialized) or will be the value of obj2 merely zero-initialized</p>\n</blockquote>\n<p>So I am unsure whether the output is required to be 1 2, or whether it could be 2, 1 if the dynamic initialization of <code>A&lt;int&gt;::a</code> first triggers the dynamic initialization of <code>A&lt;float&gt;::a</code></p>\n", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2017-04-07T12:41:16.130", "Id": "43277929", "Score": "4", "CreationDate": "2017-04-07T12:16:34.243", "LastActivityDate": "2017-04-07T12:41:16.130"}, "43276872": {"CommentCount": "1", "AcceptedAnswerId": "43277929", "CreationDate": "2017-04-07T11:21:08.127", "LastActivityDate": "2017-04-07T12:41:16.130", "PostTypeId": "1", "ViewCount": "58", "FavoriteCount": "1", "Title": "Why is this circular template instantiation legal?", "Id": "43276872", "Score": "3", "Body": "<p>I don't understand what the compiler's doing here:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// non-default-constructable struct\nstruct X\n{\n    X(int v) : x(v) {}\n    const int x;\n};\n\ntemplate&lt; typename T&gt;\nstruct A\n{\n    static const X a;\n};\n\n// trigger a compiler error if we try to instantiate the default template\ntemplate&lt; typename T &gt;\nconst X A&lt;T&gt;::a;\n\n\ntemplate&lt;&gt;\nstruct A&lt;int&gt;\n{\n    static const X a;\n};\n\ntemplate&lt;&gt;\nstruct A&lt;float&gt;\n{\n    static const X a;\n};\n\n// is this not infinitely circular?\nconst X A&lt;int&gt;::a = X(A&lt;float&gt;::a.x + 1);\nconst X A&lt;float&gt;::a = X(A&lt;int&gt;::a.x + 1);\n\nint main() {\n    // error as expected, A&lt;bool&gt;::a cannot be default-constructed\n    // cout &lt;&lt; A&lt;bool&gt;::a.x &lt;&lt; endl; \n\n    // this compiles and prints \"1 2\"\n    cout &lt;&lt; A&lt;int&gt;::a.x &lt;&lt; \" \" &lt;&lt; A&lt;float&gt;::a.x &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>I would have expected the two specialized definitions of <code>a</code> to generate a compiler error, since they are both initialized using the value of the other, and there isn't even a default constructor to fall back on. But apparently, this compiles in ideone and prints <code>1 2</code>. So how did the compiler arrive to the conclusion that the two instances of <code>X</code> should be initialized with these values?</p>\n", "Tags": "<c++><templates><instantiation><circular>", "OwnerUserId": "143642", "AnswerCount": "1"}});