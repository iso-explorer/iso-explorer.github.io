post_cb({"bq_ids": {"n4140": {"so_11497252_11497781_1": {"length": 44, "quality": 0.8, "section_id": 3376}, "so_11497252_11497781_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 3374}}, "n3337": {"so_11497252_11497781_1": {"length": 47, "quality": 0.8545454545454545, "section_id": 3246}, "so_11497252_11497781_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 3244}, "so_11497252_11497781_2": {"length": 8, "quality": 0.5714285714285714, "section_id": 3143}}}, "11497252": {"ViewCount": "3119", "Body": "<p>The following code doesn't compile under gcc-4.7.1 but compile under clang-3.2.  Which one follows the C++11 standard?</p>\n<pre><code>struct X {\n  virtual ~X() = default;\n};\n\nstruct Y : X {\n  virtual ~Y() = default;\n};\n</code></pre>\n<p>gcc-4.7.1 complains that:</p>\n<pre><code>looser throw specifier for 'virtual Y::~Y()'\nerror: overriding 'virtual X::~X() noexcept(true)'\n</code></pre>\n<p>Obviously, gcc-4.7.1 thinks X's default destructor nothrow, but Y's default destructor is not nothrow.  Why is this?  Can anyone refer to the correct place in standard?  Thanks.</p>\n<p>I saw similar questions on stackoverflow, but I didn't see the answers refering to the standard.</p>\n", "AcceptedAnswerId": "11497781", "Title": "Default destructor nothrow", "CreationDate": "2012-07-16T01:50:46.110", "Id": "11497252", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-10-12T16:05:01.247", "Score": "29", "OwnerUserId": "875044", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "11497781": {"PostTypeId": "2", "Body": "<p><strong>The compilers are caught in a dilemma here</strong>, for the following reasons:</p>\n<p>(1) <strong>Not specifying any exceptions</strong> in a function declaration (i.e. not using <code>throw</code> nor <code>noexcept</code> (which is equivalent to <code>noexcept(true)</code> )) means to allow that function to throw <strong>all possible exceptions</strong>:</p>\n<blockquote>\n<p id=\"so_11497252_11497781_0\">(\u00a715.4/12, emphasis mine) A function with <strong>no exception-speci\ufb01cation</strong> or with an exception-speci\ufb01cation of the form <code>noexcept(constant-expression)</code> where the <code>constant-expression</code> yields <code>false</code> <strong>allows all exceptions.</strong> [...]</p>\n</blockquote>\n<p>(2) A <strong>default destructor</strong> must allow exactly the exceptions that are allowed by the functions directly invoked by its implicit definition:</p>\n<blockquote>\n<p id=\"so_11497252_11497781_1\">(\u00a715.4/14, emphasis mine) An implicitly declared special member function (Clause 12) shall have an exception-speci\ufb01cation. <strong>If f is an implicitly declared</strong> default constructor, copy constructor, move constructor, <strong>destructor</strong>, copy assignment operator, or move assignment operator, <strong>its implicit exception-speci\ufb01cation speci\ufb01es the type-id T if and only if T is allowed by the exception-speci\ufb01cation of a function directly invoked by f\u2019s implicit de\ufb01nition</strong>; f shall allow all exceptions if any function it directly invokes allows all exceptions, and f shall allow no exceptions if every function it directly invokes allows no exceptions.</p>\n</blockquote>\n<p>(3) When a special member (such as a destructor) is <em>explicitly defaulted</em>, i.e. when you use <code>= default</code>, the exception specification is <strong>optional</strong> (see the use of \"<em>may</em> have\" below):</p>\n<blockquote>\n<p id=\"so_11497252_11497781_2\">(8.4.2/2, emphasis mine) An <strong>explicitly-defaulted function</strong> [...] <strong>may have</strong> an explicit exception-speci\ufb01cation only if it is compatible (15.4) with the exception-speci\ufb01cation on the implicit declaration. [...]</p>\n</blockquote>\n<p>There is no statement in the Standard that requires the exception specification in an explicitly defaulted destructor.</p>\n<p><strong>Conclusion:</strong> Therefore, <strong>not specifiying the exceptions</strong> of an explicitly defaulted destructor can be interpreted in two ways:</p>\n<ul>\n<li>To mean that <em>all exceptions are allowed</em> (according to (1) above)</li>\n<li>Or, alternatively, to mean that <em>exactly the same exceptions are allowed as are allowed by the implicit default definition of the destructor</em> (according to (3) above), which in your case means to allow <em>no exceptions</em> (according to (2) above).</li>\n</ul>\n<p>Unfortunately, GCC resolves this dilemma in one way (in favor of \"no exceptions\") in the case of your base class declaration, and in a different way in the case of the derived class (in favor of \"all exceptions\" there).</p>\n<p><strong>I believe the most natural interpretation of this admittedly ambiguous situation is to assume that (2) and (3) override (1).</strong> The Standard does not say so, but it should. Under that interpretation, Clang seems to be right here.</p>\n", "LastActivityDate": "2017-10-12T16:05:01.247", "LastEditorUserId": "415784", "Id": "11497781", "CommentCount": "1", "CreationDate": "2012-07-16T03:27:51.303", "ParentId": "11497252", "Score": "34", "OwnerUserId": "777186", "LastEditDate": "2017-10-12T16:05:01.247"}});