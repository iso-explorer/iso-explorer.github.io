post_cb({"27888730": {"CommentCount": "4", "ViewCount": "91", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-01-11T15:27:37.860", "LastActivityDate": "2016-03-18T11:27:30.533", "Title": "Is this syntax illegal?", "AcceptedAnswerId": "27888957", "LastEditDate": "2016-03-18T11:27:30.533", "Id": "27888730", "Score": "1", "Body": "<p>The following will not compile on GCC 4.8.1:</p>\n<pre><code>//struct Tag {};  // Program compiles if I use this.\n\ntemplate &lt;typename T&gt;\nstruct Base {\n    struct Tag {};\n    Base(Tag) {}\n};\n\ntemplate &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt; {\n    Derived(Tag tag) : Base&lt;T&gt;(tag) {}\n//  Derived(Base&lt;T&gt;::Tag tag) : Base&lt;T&gt;(tag) {}\n};\n\nint main() {}\n</code></pre>\n<p>complaining [Error] expected ')' before 'tag'.  It compiles on Visual Studio 2013 though, and I wanted to know if VS2013 is correct in accepting it.  It does compile when I declare <code>Tag</code> outside of <code>Base&lt;T&gt;</code>, but I want to declare <code>Tag</code> inside of <code>Base&lt;T&gt;</code> where it belongs.  Using <code>Derived(Base&lt;T&gt;::Tag tag) : Base&lt;T&gt;(tag) {}</code> didn't help either.  Any way to fix the above so that both compilers accept this, while keeping <code>Tag</code> inside of <code>Base&lt;T&gt;</code>.</p>\n", "Tags": "<c++><templates><language-lawyer><name-lookup>", "OwnerUserId": "3089350", "AnswerCount": "1"}, "27888957": {"ParentId": "27888730", "CommentCount": "0", "Body": "<p>[temp.dep]/3:</p>\n<blockquote>\n<p id=\"so_27888730_27888957_0\">In the definition of a class or class template, <strong>if a base class\n  depends on a template-parameter, the base class scope is not examined\n  during unqualified name lookup</strong> either at the point of definition of\n  the class template or member or during an instantiation of the class\n  template or member.</p>\n</blockquote>\n<p><code>Tag</code> is used as an unqualified name - thus it can never designate the member of a depedent base class. However, <code>Tag</code> is also not dependent, so lookup must be resolved at definition time (prior to instantiation), which makes the program ill-formed. That can be diagnosed at either definition or instantiation time.</p>\n<p>However, when the name is dependent (like <code>Base&lt;T&gt;::Tag</code>), name lookup is postponed and considers members of dependent base classes at instantiation time.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "27888957", "Score": "3", "CreationDate": "2015-01-11T15:48:08.163", "LastActivityDate": "2015-01-11T15:48:08.163"}, "bq_ids": {"n4140": {"so_27888730_27888957_0": {"section_id": 190, "quality": 1.0, "length": 27}}, "n3337": {"so_27888730_27888957_0": {"section_id": 184, "quality": 1.0, "length": 27}}, "n4659": {"so_27888730_27888957_0": {"section_id": 195, "quality": 0.8148148148148148, "length": 22}}}});