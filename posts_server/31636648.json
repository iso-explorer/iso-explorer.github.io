post_cb({"bq_ids": {"n4140": {"so_31636648_31654890_0": {"length": 30, "quality": 0.967741935483871, "section_id": 7201}, "so_31636648_31654890_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7200}}, "n3337": {"so_31636648_31654890_0": {"length": 30, "quality": 0.967741935483871, "section_id": 6945}, "so_31636648_31654890_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6944}}, "n4659": {"so_31636648_31654890_0": {"length": 30, "quality": 0.967741935483871, "section_id": 8710}, "so_31636648_31654890_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8709}}}, "31636648": {"ViewCount": "214", "Body": "<p>Here is some implementation details of the std::copy function(from vs2015):</p>\n<pre><code>template&lt;class _InIt,\n    class _OutIt&gt; inline\n    _OutIt _Copy_impl(_InIt _First, _InIt _Last,\n        _OutIt _Dest, _Scalar_ptr_iterator_tag)\n    {   // copy [_First, _Last) to [_Dest, ...), pointers to scalars\n    ptrdiff_t _Count = _Last - _First;\n    _CSTD memmove(&amp;*_Dest, &amp;*_First,\n        _Count * sizeof (*_First));\n    return (_Dest + _Count);\n    }\n</code></pre>\n<p>It seems that we can just use the memmove in case of scalar type.But why can't we use memmove if it is POD type (C++11)?As far as I know, it's both trivial and\nstandard layout.</p>\n", "Title": "implementation of stl copy function?", "CreationDate": "2015-07-26T11:53:31.097", "LastActivityDate": "2015-07-27T13:47:37.170", "CommentCount": "4", "LastEditDate": "2015-07-26T12:26:14.823", "PostTypeId": "1", "LastEditorUserId": "420683", "Id": "31636648", "Score": "5", "OwnerUserId": "1773108", "Tags": "<c++><c++11><visual-studio-2015><c++-standard-library>", "AnswerCount": "1"}, "31654890": {"Id": "31654890", "PostTypeId": "2", "Body": "<p>The particular requirement is \"trivially copyable\".</p>\n<blockquote>\n<p id=\"so_31636648_31654890_0\">For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to\n  distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor\n  <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making\n  up <code>obj1</code> are copied into <code>obj2</code>, 43 <code>obj2</code> shall subsequently hold\n  the same value as <code>obj1</code>.</p>\n<p id=\"so_31636648_31654890_1\"><sub>43) By using, for example, the library functions (17.6.1.2)\n  <code>std::memcpy</code> or <code>std::memmove</code>.</sub></p>\n</blockquote>\n<p>This is, amongst others, met by PODs and scalars. But VC++' requirement is narrower than necessary. So is libstdc++', who requires the type to be entirely trivial. Solely libc++ tests for <code>is_trivially_copy_assignable</code>.</p>\n", "LastActivityDate": "2015-07-27T13:47:37.170", "CommentCount": "0", "CreationDate": "2015-07-27T13:47:37.170", "ParentId": "31636648", "Score": "3", "OwnerUserId": "3647361"}});