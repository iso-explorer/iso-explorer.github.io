post_cb({"21408559": {"ParentId": "21408173", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>operator[]</code> modifies the container, and is therefore not safe to access concurrently. Your program has a data race. Generally, non-<code>const</code> member functions of standard library objects are not safe for simultaneous access. C++11 \u00a723.2.2 lists some special exceptions for containers:</p>\n<blockquote>\n<p id=\"so_21408173_21408559_0\"><sup>1</sup> For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be <code>const</code>: <code>begin</code>, <code>end</code>, <code>rbegin</code>, <code>rend</code>, <code>front</code>, <code>back</code>, <code>data</code>, <code>find</code>, <code>lower_bound</code>, <code>upper_bound</code>, <code>equal_range</code>, <code>at</code> and, except in associative or unordered associative containers, <code>operator[]</code>.</p>\n<p id=\"so_21408173_21408559_1\"><sup>2</sup> Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently.</p>\n</blockquote>\n<p>So for <code>unordered_map</code>, it's unsafe for multiple threads to simultaneously call <code>operator[]</code> - but it is safe for them to access distinct objects in the container simultaneously. Protecting the lookup of elements is sufficient, e.g.:</p>\n<pre><code>std::unique_lock&lt;std::mutex&gt; lk(some_mutex);\nauto&amp; foo = my_map[\"key\"];\nlk.unlock();\nfoo += 42;\n</code></pre>\n<p>Alternatively, if you only want to access existing elements in the map - and not add new default constructed elements - you can use <code>find</code> without external synchronization per the standard quote above.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-01-28T16:48:04.240", "Id": "21408559", "Score": "2", "CreationDate": "2014-01-28T14:38:47.147", "LastActivityDate": "2014-01-28T16:48:04.240"}, "bq_ids": {"n4140": {"so_21408173_21408559_1": {"section_id": 718, "quality": 0.8947368421052632, "length": 17}, "so_21408173_21408559_0": {"section_id": 717, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_21408173_21408559_1": {"section_id": 707, "quality": 0.9473684210526315, "length": 18}, "so_21408173_21408559_0": {"section_id": 706, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_21408173_21408559_1": {"section_id": 749, "quality": 0.8947368421052632, "length": 17}, "so_21408173_21408559_0": {"section_id": 748, "quality": 0.9259259259259259, "length": 25}}}, "21408173": {"CommentCount": "3", "ViewCount": "231", "PostTypeId": "1", "LastEditorUserId": "997112", "CreationDate": "2014-01-28T14:23:28.177", "LastActivityDate": "2014-01-28T16:48:04.240", "Title": "Multithreading error within boost::shared_ptr code", "LastEditDate": "2014-01-28T14:35:55.203", "Id": "21408173", "Score": "0", "Body": "<p>I am using visual studio and I keep getting an exception on the following line of the boost::shared_ptr code:</p>\n<pre><code>void release() // nothrow\n{\n    if( BOOST_INTERLOCKED_DECREMENT( &amp;use_count_ ) == 0 )\n    {\n        dispose();\n        weak_release();\n    }\n}\n</code></pre>\n<p>I think it is multithreading because it is very random when it occurs.I'm struggling to get more details.</p>\n<p>I share an <code>unordered_map&lt;std::string, boost::shared_ptr&lt;MyClass&gt;&gt;</code> amongst several threads. I think the error is due to different threads accessing the unordered_map at the same time (the threads don't access the same elements of the unordered_map).</p>\n<p>MyClass contains an unordered_map and a set. The threads add numbers to these data structures. So if I had:</p>\n<pre><code>class MyClass{\npublic:\n    void addToMap(double a, long b);\n    void addToSet(double c);\nprivate:\n    unordered_map&lt;double, long&gt; a;\n    set&lt;double&gt; b;\n}\n</code></pre>\n<ul>\n<li>Thread 1: processes element 1 of <code>std::unordered_map&lt;std::string, boost::shared_ptr&lt;MyClass&gt; &gt;</code></li>\n<li>Thread 2: processes element 2 of <code>std::unordered_map&lt;std::string, boost::shared_ptr&lt;MyClass&gt; &gt;</code></li>\n<li>Thread 3: processes element 3 of <code>std::unordered_map&lt;std::string, boost::shared_ptr&lt;MyClass&gt; &gt;</code></li>\n<li>Thread 4: processes element 4 of <code>std::unordered_map&lt;std::string, boost::shared_ptr&lt;MyClass&gt; &gt;</code></li>\n</ul>\n<p>I do not have any locks in my code. Could someone please advise how I could potentially solve this problem (even if it means making the code slower)? Do I just need to insert mutexes inside each MyClass object? However it seems to be the boost::shared_ptr of the MyClass object which is causing the exception?</p>\n<p>I do not pass any <code>boost::shared_ptr</code> objects by reference/pointer.</p>\n", "Tags": "<c++><multithreading><boost><concurrency>", "OwnerUserId": "997112", "AnswerCount": "1"}});