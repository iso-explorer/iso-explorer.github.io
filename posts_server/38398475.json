post_cb({"bq_ids": {"n4140": {"so_38398475_38401144_2": {"length": 11, "quality": 1.0, "section_id": 6185}, "so_38398475_38401144_0": {"length": 15, "quality": 0.9375, "section_id": 6004}, "so_38398475_38401144_1": {"length": 21, "quality": 1.0, "section_id": 6004}}, "n3337": {"so_38398475_38401144_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5946}, "so_38398475_38401144_0": {"length": 15, "quality": 0.9375, "section_id": 5772}, "so_38398475_38401144_1": {"length": 21, "quality": 1.0, "section_id": 5772}}, "n4659": {"so_38398475_38401144_2": {"length": 11, "quality": 1.0, "section_id": 7687}, "so_38398475_38401144_0": {"length": 15, "quality": 0.9375, "section_id": 7503}, "so_38398475_38401144_1": {"length": 21, "quality": 1.0, "section_id": 7503}}}, "38398475": {"ViewCount": "178", "Body": "<p>The following code uses enum member <code>m</code> as a constant expression, i.e. as a template parameter. The code compiles under gcc but not under clang (<a href=\"http://coliru.stacked-crooked.com/a/79f0d052864fec19%20live%20demo\">live demo</a>). Clang says \"error: non-type template argument is not a constant expression\".</p>\n<p>The problem can be solved by exchanging line <code>// 1</code> by <code>A&lt;tst&lt;p&gt;::m&gt; a</code>. Therefore, my question is not how to fix this issue but which compiler is right.</p>\n<pre><code>template&lt;size_t n&gt; struct A{};\n\ntemplate&lt;size_t n&gt;\nstruct tst\n{   enum : size_t { m= n % 15 };\n\n    template&lt;size_t p&gt;\n    void\n    call( tst&lt;p&gt; const &amp;t2 ) {\n        A&lt;t2.m&gt;  a; // 1\n    }\n};\n</code></pre>\n", "AcceptedAnswerId": "38401144", "Title": "Using an enum as a constant expression. Which compiler is right?", "CreationDate": "2016-07-15T14:20:35.810", "Id": "38398475", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-07-15T16:37:31.100", "Score": "6", "OwnerUserId": "3876684", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "38401144": {"Id": "38401144", "PostTypeId": "2", "Body": "<p>According to the Standard, Clang is right to reject the code.</p>\n<p><code>t2.m</code> is a class member access expression. [expr.ref]/1 says:</p>\n<blockquote>\n<p id=\"so_38398475_38401144_0\">[...] The postfix expression before the dot or arrow is evaluated; the\n  result of that evaluation, together with the <em>id-expression</em>,\n  determines the result of the entire postfix expression.</p>\n</blockquote>\n<p>There's also a note:</p>\n<blockquote>\n<p id=\"so_38398475_38401144_1\">If the class member access expression is evaluated, the subexpression\n  evaluation happens even if the result is unnecessary to determine the\n  value of the entire postfix expression, for example if the\n  <em>id-expression</em> denotes a static member.</p>\n</blockquote>\n<p>So, the subexpression <code>t2</code> is evaluated. [expr.const]/2.9 says that an expression <code>e</code> cannot be a core constant expression if evaluating it results in the evaluation of</p>\n<blockquote>\n<p id=\"so_38398475_38401144_2\">an <em>id-expression</em> that refers to a variable or data member of reference\n  type unless the reference has a preceding initialization and either</p>\n<ul>\n<li>it is initialized with a constant expression or</li>\n<li>its lifetime began within the evaluation of <code>e</code>;</li>\n</ul>\n</blockquote>\n<p><code>t2</code> refers to a variable of reference type that doesn't satisfy the bullets, so <code>t2.m</code> is not a constant expression because it isn't a core constant expression.</p>\n<hr>\n<p>All quotes from N4594, the current published working draft. The text has changed slightly since C++11, but the meaning in this case is the same.</p>\n</hr>", "LastActivityDate": "2016-07-15T16:37:31.100", "CommentCount": "5", "CreationDate": "2016-07-15T16:37:31.100", "ParentId": "38398475", "Score": "3", "OwnerUserId": "4326278"}});