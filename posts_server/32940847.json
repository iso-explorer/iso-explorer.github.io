post_cb({"32941074": {"ParentId": "32940847", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>From [dcl.init.aggr] 8.5.1(2)</p>\n<blockquote>\n<p id=\"so_32940847_32941074_0\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. <strong>Each member is copy-initialized from the corresponding initializer-clause.</strong></p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>And </p>\n<blockquote>\n<p id=\"so_32940847_32941074_1\">Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and side effect associated with a given initializer-clause is sequenced before every value computation and side effect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list.</p>\n</blockquote>\n<p>Leads me to believe that each member of the class will be initialized in the order they are declared in the initializer-list and since <code>foo.i</code> is initialized before we evaluate it to initialize <code>j</code> this should be defined behavior.</p>\n<p>This is also backed up with [intro.execution] 1.9(12)</p>\n<blockquote>\n<p id=\"so_32940847_32941074_2\">Accessing an object designated by a volatile glvalue (3.10), <strong>modifying an object</strong>, calling a library I/O function, or calling a function that does any of those operations <strong>are all side effects</strong>, which are changes in the state of the execution environment.</p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>In your second example we are not using aggregate initialization but list initialization.  [dcl.init.list] 8.5.4(3) has</p>\n<blockquote>\n<p id=\"so_32940847_32941074_3\">List-initialization of an object or reference of type T is defined as follows:<br>\n  [...]<br>\n  - Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated\n  and the best one is chosen through overload resolution (13.3, 13.3.1.7).</br></br></p>\n</blockquote>\n<p>So now we would call your constructor.  When calling the constructor <code>foo.i</code> has not been initialized so we are copying an uninitialized variable which is undefined behavior.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2015-10-06T13:50:59.270", "Id": "32941074", "Score": "12", "CreationDate": "2015-10-05T04:00:08.887", "LastActivityDate": "2015-10-06T13:50:59.270"}, "32940847": {"CommentCount": "5", "AcceptedAnswerId": "32945791", "PostTypeId": "1", "LastEditorUserId": "15055", "CreationDate": "2015-10-05T03:26:50.003", "LastActivityDate": "2015-10-10T13:25:45.873", "LastEditDate": "2015-10-06T01:40:01.847", "ViewCount": "665", "FavoriteCount": "7", "Title": "Is it defined behavior to reference an early member from a later member expression during aggregate initialization?", "Id": "32940847", "Score": "32", "Body": "<p>Consider the following:</p>\n<pre><code>struct mystruct\n{\n    int i;\n    int j;\n};\n\nint main(int argc, char* argv[])\n{\n    mystruct foo{45, foo.i};   \n\n    std::cout &lt;&lt; foo.i &lt;&lt; \", \" &lt;&lt; foo.j &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Note the use of <code>foo.i</code> in the aggregate-initializer list. </p>\n<p><code>g++ 5.2.0</code> outputs </p>\n<blockquote>\n<p id=\"so_32940847_32940847_0\">45, 45</p>\n</blockquote>\n<p>Is this well-defined behavior? Is <code>foo.i</code> in this aggregate-initializer always guaranteed to refer to the being-created structure's <code>i</code> element (and <code>&amp;foo.i</code> would refer to that memory address, for example)?</p>\n<p>If I add an explicit constructor to <code>mystruct</code>:</p>\n<pre><code>mystruct(int i, int j) : i(i), j(j) { }\n</code></pre>\n<p>Then I get the following warnings:</p>\n<pre><code>main.cpp:15:20: warning: 'foo.a::i' is used uninitialized in this function [-Wuninitialized]\n     a foo{45, foo.i};\n                ^\nmain.cpp:19:34: warning: 'foo.a::i' is used uninitialized in this function [-Wuninitialized]\n     cout &lt;&lt; foo.i &lt;&lt; \", \" &lt;&lt; foo.j &lt;&lt; endl;\n</code></pre>\n<p>The code compiles and the output is:</p>\n<blockquote>\n<p id=\"so_32940847_32940847_1\">45, 0</p>\n</blockquote>\n<p>Clearly this does something different, and I'm assuming this is undefined behavior. Is it? If so, why the difference between this and when there was no constructor? And, how can I get the initial behavior (if it was well-defined behavior) with a user-defined constructor?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14><undefined-behavior>", "OwnerUserId": "15055", "AnswerCount": "4"}, "32941831": {"ParentId": "32940847", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_32940847_32941831_0\">how can I get the initial behavior (if it was well-defined behavior) with a user-defined constructor?<br/></p>\n</blockquote>\n<p>Passing parameter by reference for that parameter which refers to previously initialized parameter of being constructed object, as follows:</p>\n<pre><code> mystruct(int i, int&amp; j):i(i),j(j)\n</code></pre>\n", "OwnerUserId": "5371616", "LastEditorUserId": "1708801", "LastEditDate": "2015-10-05T18:42:21.037", "Id": "32941831", "Score": "-2", "CreationDate": "2015-10-05T05:29:27.813", "LastActivityDate": "2015-10-05T18:42:21.037"}, "32945791": {"ParentId": "32940847", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Your second case is undefined behavior, you are no longer using aggregate initialization, it is still list initialization but in this case you have a user defined constructor which is being called. In order to pass the second argument to your constructor it needs to evaluate <code>foo.i</code> but it is not initialized yet since you have not yet entered the constructor and therefore you are producing an indeterminate value and <a href=\"https://stackoverflow.com/q/23415661/1708801\">producing an indeterminate value is undefined behavior</a>.</p>\n<p>We also have section <code>12.7</code> Construction and destruction [class.cdtor] which says:</p>\n<blockquote>\n<p id=\"so_32940847_32945791_0\">For an object with a non-trivial constructor, referring to any non-static member or base class of the object\n  before the constructor begins execution results in undefined behavior [...]</p>\n</blockquote>\n<p>So I don't see a way of getting your second example to work like your first example, assuming the first example is indeed valid. </p>\n<p>Your first case seems like it should be well defined but I can not find a reference in the draft standard that seems to make that explicit. Perhaps it is defect but otherwise it would be undefined behavior since the standard does not define the behavior. What the standard does tell us is that the initializers are evaluated in order and the side effects are sequenced, from section <code>8.5.4</code> <em>[dcl.init.list]</em>:</p>\n<blockquote>\n<p id=\"so_32940847_32945791_1\">Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack\n  expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and\n  side effect associated with a given initializer-clause is sequenced before every value computation and side\n  effect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list. [...]</p>\n</blockquote>\n<p>but we don't have an explicit text saying the members are initialized after each element is evaluated.</p>\n<p>MSalters argues that section <code>1.9</code> which says:</p>\n<blockquote>\n<p id=\"so_32940847_32945791_2\">Accessing an object designated by a volatile glvalue (3.10), <strong>modifying an object</strong>, calling a library I/O\n  function, or calling a function that does any of those operations <strong>are all side effects</strong>, which are changes in the\n  state of the execution environment. [...]</p>\n</blockquote>\n<p>combined with:</p>\n<blockquote>\n<p id=\"so_32940847_32945791_3\">[...]very value computation and side effect associated with a given initializer-clause is sequenced before every value computation and side effect associated with any initializer-clause that follows it [...]</p>\n</blockquote>\n<p>Is sufficient to guarantee each member of the aggregate is initialized as the elements of the initializer list are evaluated. Although this would be not apply prior to C++11 since <a href=\"https://stackoverflow.com/a/19881804/1708801\">the order of evaluation of the initializer list was unspecified</a>.</p>\n<p>For reference if the standard does not impose a requirement the behavior is undefined from section <code>1.3.24</code> which defines undefined behavior:</p>\n<blockquote>\n<p id=\"so_32940847_32945791_4\">behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of\n  behavior or [...]</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>Johannes Schaub points out <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1343\" rel=\"nofollow noreferrer\">defect report 1343: Sequencing of non-class initialization</a> and std-discussion threads <a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/lH86B0MhbAc/JPi2P7dj1y8J\" rel=\"nofollow noreferrer\">Is aggregate member copy-initialization associated with the corresponding initializer-clause?</a> and <a href=\"https://groups.google.com/a/isocpp.org/forum/#!search/initializer-clause$20Johannes$20Schaub/std-discussion/YpUgHq-52mE/5IK123NqWMoJ\" rel=\"nofollow noreferrer\">Is copy-initialization of an aggregate member associated with the corresponding initializer-clause?</a> which are all relevant.</p>\n<p>They basically point out that the first case is currently unspecified, I will <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/lH86B0MhbAc/Kedqd0qwEMgJ\" rel=\"nofollow noreferrer\">quote Richard Smith</a>:</p>\n<blockquote>\n<p id=\"so_32940847_32945791_5\">So the only question is, is the side-effect of initializing s.i\n  \"associated with\" the evaluation of the full-expression \"5\"? I think\n  the only reasonable assumption is that it is: if 5 were initializing a\n  member of class type, the constructor call would obviously be part of\n  the full-expression by the definition in [intro.execution]p10, so it\n  is natural to assume that the same is true for scalar types.</p>\n<p id=\"so_32940847_32945791_6\">However, I don't think the standard actually explicitly says this\n  anywhere.</p>\n</blockquote>\n<p>So although as indicated in several places it looks like current implementations do what we expect, it seems unwise to rely on it until this is officially clarified or the implementations provide a guarantee. </p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:49.660", "Id": "32945791", "Score": "13", "CreationDate": "2015-10-05T09:58:58.590", "LastActivityDate": "2015-10-10T13:25:45.873"}, "32946270": {"ParentId": "32940847", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>My first idea was UB, but you are fully in the aggregate initialization case. Draft n4296 for C++ 11 specification is explicit in the 8.5.1 Aggregates [dcl.init.aggr] paragraph:</p>\n<blockquote>\n<p id=\"so_32940847_32946270_0\">An aggregate is an array or a class with no user-provided constructors , no private or protected non-static data members, no base classes, and no virtual functions</p>\n</blockquote>\n<p>Later:</p>\n<blockquote>\n<p id=\"so_32940847_32946270_1\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list\n  are taken as initializers for the members of the aggregate, <strong>in increasing subscript or member order</strong></p>\n</blockquote>\n<p>(emphasize mine)</p>\n<p>My understanding is that <code>mystruct foo{45, foo.i};</code> first initializes <code>foo.i</code> with 45, then <code>foo.j</code> with <code>foo.i</code>.</p>\n<p>I would not dare to use that in real code anyway, because even if I <em>believe</em> it is defined by standard, I would be afraid that a compiler programmer has thought differently... </p>\n", "OwnerUserId": "3545273", "LastEditorUserId": "4850040", "LastEditDate": "2015-10-05T15:08:13.663", "Id": "32946270", "Score": "1", "CreationDate": "2015-10-05T10:23:22.477", "LastActivityDate": "2015-10-05T15:08:13.663"}, "bq_ids": {"n4140": {"so_32940847_32941074_2": {"section_id": 5808, "quality": 0.9130434782608695, "length": 21}, "so_32940847_32946270_0": {"section_id": 3298, "quality": 0.9285714285714286, "length": 13}, "so_32940847_32945791_3": {"section_id": 3326, "quality": 0.9444444444444444, "length": 17}, "so_32940847_32941074_1": {"section_id": 3326, "quality": 0.9428571428571428, "length": 33}, "so_32940847_32945791_2": {"section_id": 5808, "quality": 0.9130434782608695, "length": 21}, "so_32940847_32941074_3": {"section_id": 3325, "quality": 0.8636363636363636, "length": 19}, "so_32940847_32945791_0": {"section_id": 444, "quality": 0.9411764705882353, "length": 16}, "so_32940847_32946270_1": {"section_id": 3299, "quality": 0.9444444444444444, "length": 17}, "so_32940847_32945791_1": {"section_id": 3326, "quality": 0.9428571428571428, "length": 33}, "so_32940847_32945791_4": {"section_id": 5768, "quality": 0.8235294117647058, "length": 14}, "so_32940847_32941074_0": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_32940847_32941074_2": {"section_id": 5581, "quality": 0.9130434782608695, "length": 21}, "so_32940847_32946270_0": {"section_id": 3168, "quality": 0.9285714285714286, "length": 13}, "so_32940847_32941074_1": {"section_id": 3196, "quality": 0.9428571428571428, "length": 33}, "so_32940847_32945791_3": {"section_id": 3196, "quality": 0.9444444444444444, "length": 17}, "so_32940847_32945791_2": {"section_id": 5581, "quality": 0.9130434782608695, "length": 21}, "so_32940847_32941074_3": {"section_id": 3195, "quality": 0.8636363636363636, "length": 19}, "so_32940847_32945791_0": {"section_id": 435, "quality": 0.9411764705882353, "length": 16}, "so_32940847_32946270_1": {"section_id": 3169, "quality": 0.9444444444444444, "length": 17}, "so_32940847_32945791_1": {"section_id": 3196, "quality": 0.9428571428571428, "length": 33}, "so_32940847_32945791_4": {"section_id": 5541, "quality": 0.8235294117647058, "length": 14}, "so_32940847_32941074_0": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_32940847_32946270_0": {"section_id": 4063, "quality": 0.7142857142857143, "length": 10}, "so_32940847_32941074_1": {"section_id": 4092, "quality": 0.9428571428571428, "length": 33}, "so_32940847_32945791_3": {"section_id": 4092, "quality": 0.9444444444444444, "length": 17}, "so_32940847_32941074_3": {"section_id": 4091, "quality": 0.8636363636363636, "length": 19}, "so_32940847_32945791_2": {"section_id": 7269, "quality": 0.8695652173913043, "length": 20}, "so_32940847_32945791_4": {"section_id": 7225, "quality": 0.8235294117647058, "length": 14}, "so_32940847_32945791_0": {"section_id": 467, "quality": 0.9411764705882353, "length": 16}, "so_32940847_32946270_1": {"section_id": 4065, "quality": 0.7222222222222222, "length": 13}, "so_32940847_32945791_1": {"section_id": 4092, "quality": 0.9428571428571428, "length": 33}, "so_32940847_32941074_2": {"section_id": 7269, "quality": 0.8695652173913043, "length": 20}, "so_32940847_32941074_0": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}}}});