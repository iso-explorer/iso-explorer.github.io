post_cb({"42309444": {"CommentCount": "5", "ViewCount": "935", "PostTypeId": "1", "LastEditorUserId": "2090317", "CreationDate": "2017-02-18T00:03:12.907", "LastActivityDate": "2017-02-18T13:32:25.323", "Title": "How to in-place initialize an array?", "AcceptedAnswerId": "42309695", "LastEditDate": "2017-02-18T01:12:28.753", "Id": "42309444", "Score": "2", "Body": "<p>How can I initialize an array without copy or move-constructing temporary elements? When the element has an explicitly <code>delete</code>d copy or move constructor, I can initialize the array only if the element has a default ctor or a ctor with all default arguments and I do one of the following: (a) plainly declare the array, (b) direct initialize and zero initialize the array, or (c) copy initialize and zero initialize the array. Neither direct (but not zero) initialization nor copy (but not zero) initialization compiles.</p>\n<pre><code>struct Foo\n{\n    Foo(int n = 5) : num(n) {}\n    Foo(const Foo&amp;) = delete;\n    //Foo(Foo&amp;&amp;) = delete;  // &lt;-- gives same effect\n    int num;\n};\n\nint main()\n{\n    // Resultant arrays for 'a1', 'a2', and 'a3' are two\n    // 'Foo' elements each with 'num' values of '5':\n\n    Foo a1[2];          // plain declaration\n    Foo a2[2] {};       // direct initialization and zero initialization\n    Foo a3[2] = {};     // copy initialization and zero initialization\n    Foo a4[2] {5, 5};   // direct initialization -&gt; ERROR\n    Foo a5[2] = {5, 5}; // copy initialization   -&gt; ERROR\n}\n</code></pre>\n<ol>\n<li>Are those 3 ways the <em>only</em> ways to initialize arrays without copying/moving temporary elements?</li>\n<li>Do <code>a1</code>, <code>a2</code>, and <code>a3</code> count as initializations? e.g. <code>a1</code> is a declaration, but its elements get initial, albeit default, values.</li>\n<li>Are any of them bugs? I did this GCC 6.3.0 with C++14 flag.</li>\n<li>Why does copy initialization combined with zero initialization work if it is still under the category of <em>copy</em> initialization?</li>\n<li>In general, are <em>all</em> array initializations with curly braces just construction of temporary elements (unless elided when there is no deletion of copy or move constructors (or does elision not apply to arrays?)) followed by per-element copy, move, or mix of copy and move construction?</li>\n</ol>\n", "Tags": "<c++><arrays><in-place><copy-elision><deleted-functions>", "OwnerUserId": "2090317", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_42309444_42309695_0": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}, "so_42309444_42309695_1": {"section_id": 3304, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_42309444_42309695_0": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}, "so_42309444_42309695_1": {"section_id": 3174, "quality": 0.7391304347826086, "length": 17}}, "n4659": {"so_42309444_42309695_0": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}, "so_42309444_42309695_1": {"section_id": 4070, "quality": 0.6956521739130435, "length": 16}}}, "42309695": {"ParentId": "42309444", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The code declaration <code>Foo a2[2];</code> declares an array. The only way to initialize an array is via list-initialization (i.e. a brace-enclosed list of zero or more elements), and the behaviour is described by the section of the Standard titled <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">aggregate initialization</a>.  (The term <em>aggregate</em> refers to arrays, and classes that meet certain criteria).</p>\n<p>In aggregate initialization, the presence of <code>=</code> makes no difference. The basic definition of it is in C++14 [dcl.init.aggr]/2:</p>\n<blockquote>\n<p id=\"so_42309444_42309695_0\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each member is copy-initialized from the corresponding initializer-clause.</p>\n</blockquote>\n<p>Also, /7:</p>\n<blockquote>\n<p id=\"so_42309444_42309695_1\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its brace-or-equal-initializer or, if there is no brace-or-equal-\n  initializer, from an empty initializer list (8.5.4).</p>\n</blockquote>\n<p>You can see from this that copy-initialization is always used for each provided initializer.  Therefore, when the initializer is an expression, an accessible copy/move-constructor must exist for the class.</p>\n<p>However (as suggested by Anty) you can make the initializer be another list. Copy-initialization using a list is called copy-list-initialization:</p>\n<pre><code>Foo a6[2] = {{6}, {6}};\n</code></pre>\n<p>When a single <code>Foo</code> is list-initialized, it is not aggregate initialization (since <code>Foo</code> is not an aggregate). So the rules are different to those discussed above.  Copy-list-initialization of a non-aggregate class comes under list-initialization, in [dcl.init.list]/3.4, which specifies for <code>Foo</code> that the initializers in the list are matched to constructor arguments using overload resolution. At this stage the <code>Foo(int)</code> constructor will be chosen, meaning the copy-constructor is not required.</p>\n<hr>\n<p>For completeness I'll mention the <a href=\"https://stackoverflow.com/questions/28187732/placement-new-in-stdaligned-storage\">nuclear option</a>:</p>\n<pre><code>typename std::aligned_storage&lt; sizeof(Foo), alignof(Foo) &gt;::type buf[2];\n::new ((void *)::std::addressof(buf[0])) Foo(5);\n::new ((void *)::std::addressof(buf[1])) Foo(5);\nFoo *a7 = reinterpret_cast&lt;Foo *&gt;(buf);\n\n// ...\na7[0].~Foo();\na7[1].~Foo();\n</code></pre>\n<p>Obviously this is a last resort for when you can't achieve your goal by any other means.</p>\n<hr>\n<p>Note 1: The above applies to C++14.  In C++17 I believe the so-called \"guaranteed copy elision\" will change copy-initialization to not actually require a copy/move constructor.  I will hopefully update this answer once the standard is published. There has also been some fiddling with aggregate initialization in the drafts.</p>\n</hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:16:50.650", "Id": "42309695", "Score": "3", "CreationDate": "2017-02-18T00:34:33.813", "LastActivityDate": "2017-02-18T01:51:46.470"}, "42309736": {"ParentId": "42309444", "CommentCount": "0", "Body": "<p>In your case you still may use those constructs:</p>\n<pre><code>Foo a4[2] = {{4},{3}};\n</code></pre>\n<p>or</p>\n<pre><code>Foo a5[2] {{4},{3}};\n</code></pre>\n", "OwnerUserId": "4381807", "PostTypeId": "2", "Id": "42309736", "Score": "4", "CreationDate": "2017-02-18T00:41:05.463", "LastActivityDate": "2017-02-18T00:41:05.463"}, "42315812": {"ParentId": "42309444", "CommentCount": "0", "Body": "<p>I don't have the C++ standard at hand, and citing it would probably be the only way to prove my words. So to answer each of your questions I can only say:</p>\n<ol>\n<li>No this is not all. I cannot provide you wit an exhaustive list of possiblities, but I definitely have used the following before:</li>\n</ol>\n<p>xx</p>\n<pre><code> struct Foo\n {\n     Foo(int n = 5) : num(n) {}\n     Foo(const Foo&amp;) = delete;\n     Foo(Foo&amp;&amp;) = delete;\n     int num;\n };\n\nint main()\n{    \n    Foo a1[2];          // plain declaration\n    Foo a2[2] {};       // direct initialization\n    Foo a3[2] = {};     // also direct initialization\n    Foo a4[2] { {5}, {5} };   // also direct initialization\n    Foo a5[2] = { {5}, {5} }; // also direct initialization \n}\n</code></pre>\n<ol start=\"2\">\n<li><p>Brace initalization is not declare-and-copy, it's separate language construct. It might very well just in-place construct the elements. The only situation where i am not sure if this applies is <code>{ Foo(5), Foo(5) }</code> initialization, as it explicitly requests creation of temporaries. The  <code>{ 5, 5}</code> variant is just the same, because in order to initialize an array you need a brace-initalized list of <code>Foo</code> objects. Since you don't create any, it will use the constructor for temporaries to obtain <code>{ Foo(5), Foo(5) }</code>. The <code>{ { 5 }, { 5 } }</code> variant compiles because compiler knows that it can construct <code>Foo</code> object out of provided <code>{ 5 }</code> initializer and therefore needs no temporaries - although I don't know exact standard wording that allows this.</p></li>\n<li><p>No, I don't think any of these are bugs.</p></li>\n<li><p>I remember a line in C++ standard that basically says that a compiler can always replace assignment initialization by direct initialization when creating a new variable.</p></li>\n</ol>\n<p>xx</p>\n<pre><code>Foo x( 5 );\nFoo x { 5 };\nFoo x = { 5 }; // Same as above\n</code></pre>\n<ol start=\"5\">\n<li>As I already pointed out above: No, you can in-place initialize the array, you just need a proper element initializers. <code>{ 5 }</code> will be intepreted as \"an initializer for Foo object\", whereas plain <code>5</code> will be understud as \"a value that can be converted to a temporary Foo object\". Initializer lists generally have to contain either a initializer lists for the elements, or items of the exact type of the elements. If something different is given, a temporary will be created.</li>\n</ol>\n", "OwnerUserId": "455304", "PostTypeId": "2", "Id": "42315812", "Score": "1", "CreationDate": "2017-02-18T13:32:25.323", "LastActivityDate": "2017-02-18T13:32:25.323"}, "42309543": {"ParentId": "42309444", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You can also create a pointer with malloc and then use array syntax on it (if the class is a POD). Ex:</p>\n<pre><code>class A {\npublic:\n      int var1;\n      int var2;\n      public int add(int firstNum, int secondNum) {\n          return firstNum + secondNum;\n      }\n}\nA * p = 0;\nwhile(!p) {\n    p = (A*)malloc(sizeof(A) * 2);\n}\np[0] = {2, 3};\np[1] = {2, 5};\n</code></pre>\n<p>There is also a way to initialize an array as a temporary value, but I forgot how to do that.</p>\n<p>You can directly initialize an array of objects if the class is a POD (plain old data). In order for a class to be a POD, it must have no constructors, destructors, or virtual methods. Everything in the class must also be declared public in order for it to be a POD. Basically, a POD class is just a c-style struct that can have methods in it.</p>\n", "Id": "42309543", "LastEditDate": "2017-02-18T01:05:40.720", "OwnerDisplayName": "user7551751", "Score": "2", "CreationDate": "2017-02-18T00:14:50.303", "LastActivityDate": "2017-02-18T01:05:40.720", "LastEditorDisplayName": "user7551751"}});