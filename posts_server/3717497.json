post_cb({"3717497": {"CommentCount": "5", "AcceptedAnswerId": "3717667", "CreationDate": "2010-09-15T12:18:34.673", "LastActivityDate": "2010-09-15T13:36:40.460", "PostTypeId": "1", "ViewCount": "377", "FavoriteCount": "2", "Title": "Compiler detection of returning reference to local variable", "Id": "3717497", "Score": "5", "Body": "<p>I've just been bitten by a nasty undefined behavior due the returning a reference to a local variable.</p>\n<p>We know it's evil, and generally the compiler prints a nice <code>warning</code> to tell us so... well gcc (3.4.2) does not seem to push the checks too far though.</p>\n<pre><code>std::string get_env_value(std::string const&amp; key);\n\nstd::string const&amp; get_phase()\n{\n  std::string const&amp; phase = get_env_value(\"PHASE\"); // [1]\n  std::cout &lt;&lt; \"get_phase - \" &lt;&lt; phase &lt;&lt; '\\n';\n  return phase;                                      // [2]\n}\n</code></pre>\n<p>This compiles without a glitch, and yet we fall in the nasty realm of undefined behavior.</p>\n<p>Line <code>[1]</code> is okay because the standard specifies that the lifetime of a variable bound to a const reference should be extended to match the lifetime of the const reference.</p>\n<p>Line <code>[2]</code> seems okay too...</p>\n<ul>\n<li>Do the C++ specifications cover this case ?</li>\n<li>Does anyone know if this is usually diagnosed ? (I may miss a flag or something...)</li>\n</ul>\n<p>It seems to me that static analysis should be able to tell that having use a \"lifetime extension\" for <code>[1]</code>, <code>[2]</code> is not safe, but it could get ugly rapidly I guess...</p>\n", "Tags": "<c++><gcc-warning>", "OwnerUserId": "147192", "AnswerCount": "2"}, "3717844": {"ParentId": "3717497", "PostTypeId": "2", "CommentCount": "1", "Body": "<ol>\n<li><p>No, I don't think Standard mentions / covers this specific case.</p></li>\n<li><p>VS 2010 gives compilation warnings (/Za, /W4).</p></li>\n</ol>\n<p>So, definitely it looks to be a diagnosable condition.</p>\n<p>So, I tweaked the function slightly as follows, just to create multiple return paths:</p>\n<pre><code>std::string const&amp; get_phase() \n{ \n    std::string const&amp; phase = get_env_value(\"PHASE\"); // [1] \n    std::cout &lt;&lt; \"get_phase - \" &lt;&lt; phase &lt;&lt; '\\n'; \n\n    if(1){\n        while(1){\n            return phase;\n        }\n    }\n    return phase;                                      // [2] \n} \n</code></pre>\n<p>Now, VS does not report the warning as earlier.</p>\n<p>As an example, at a first glance, it looks that it should be easy for the compiler to detect and catch that not all paths return a value. But compilers (e.g. VS) do not.</p>\n<pre><code>int get_phase() \n{\n    char ch;\n    if(ch){\n        return 0;\n    }\n     // nothing returned from here.\n} \n</code></pre>\n<p>So, I guess the code in OP has probably the same complexities to diagnose the condition as the example shown just above, though I am not sure. The only good thing is that the Standard is clear on this case.</p>\n<blockquote>\n<p id=\"so_3717497_3717844_0\">$6.6.3/2 - \"Flowing off the\n  end of a function is equivalent to a\n  return with no value; this results in\n  undefined behavior in a\n  value-returning function.\"</p>\n</blockquote>\n<p>Coming back to the code in OP, I guess the standard does not mandate this condition to be a diagnosable condition, and hence compilers are free to do as they please. It is basically understood that the returned reference points to an object which is already destructed. So accessing such an object will lead to an undefined behavior</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-09-15T13:36:40.460", "Id": "3717844", "Score": "2", "CreationDate": "2010-09-15T13:05:15.347", "LastActivityDate": "2010-09-15T13:36:40.460"}, "3717667": {"ParentId": "3717497", "CommentCount": "2", "Body": "<p>The standard does not cover <code>[2]</code>. It allows an rvalue to be bound to a const reference, but that doesn't allow you to return a const reference and have the lifetime of the rvalue it is bound to extended as well.</p>\n<p>And true, static analysis <em>could</em> catch this, but as always it's a trade-off. C++ compilation is slow enough as it is, so compiler writers have to weigh the benefits of further static analysis which might allow them to produce better diagnostics, against the increased compilation time.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "3717667", "Score": "5", "CreationDate": "2010-09-15T12:44:04.177", "LastActivityDate": "2010-09-15T12:44:04.177"}, "bq_ids": {"n4140": {"so_3717497_3717844_0": {"section_id": 3913, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_3717497_3717844_0": {"section_id": 3773, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_3717497_3717844_0": {"section_id": 4799, "quality": 0.6923076923076923, "length": 9}}}});