post_cb({"bq_ids": {"n4140": {"so_10466096_10469611_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 6312}, "so_10466096_10466167_0": {"length": 38, "quality": 0.926829268292683, "section_id": 4907}, "so_10466096_10466096_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 6259}, "so_10466096_10469611_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 4907}}, "n3337": {"so_10466096_10469611_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 6069}, "so_10466096_10466167_0": {"length": 38, "quality": 0.926829268292683, "section_id": 4702}, "so_10466096_10466096_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 6019}, "so_10466096_10469611_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 4702}}, "n4659": {"so_10466096_10469611_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 7822}, "so_10466096_10466167_0": {"length": 38, "quality": 0.926829268292683, "section_id": 6316}, "so_10466096_10466096_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 7763}, "so_10466096_10469611_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 6316}}}, "10466096": {"ViewCount": "288", "Body": "<p>Is this code <em>standard conforming</em>?</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;cstdio&gt;\n\nint main() {\n    FILE *f1 = 0;\n    std::FILE *f2 = f1;\n}\n</code></pre>\n<p><strong>Explanation:</strong> The standard says [headers]:</p>\n<blockquote>\n<p id=\"so_10466096_10466096_0\">[...] the contents of each header <code>cname</code> shall be the same as that of the corresponding header <code>name.h</code> [...] as if by inclusion. In the C++ standard library, however, the declarations [...] are within namespace scope (3.3.6) of the namespace <code>std</code>. <strong>It is unspecified whether these names are first declared within the global namespace scope and are then injected into namespace <code>std</code> by explicit <em>using-declarations</em> (7.3.3).</strong></p>\n</blockquote>\n<p>So in case they aren't injected by explicit using-declaration, may they be <em>different</em> type? I don't think the \"as if by inclusion\" phrase is conclusive since the other half of the text clearly contradicts this requirement, requiring the names are within the <code>std</code> namespace.</p>\n", "AcceptedAnswerId": "10469611", "Title": "Can types in `cname` and `name.h` be different types?", "CreationDate": "2012-05-05T21:21:31.457", "Id": "10466096", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-05-06T09:50:17.757", "Score": "5", "OwnerUserId": "277176", "Tags": "<c++><standards-compliance><language-lawyer><standard-library>", "AnswerCount": "3"}, "10469611": {"Id": "10469611", "PostTypeId": "2", "Body": "<p>I don't believe that paragraph says that they have to be identical. It is just a revision of the original (C++98) paragraph which said:</p>\n<blockquote>\n<p id=\"so_10466096_10469611_0\">Every C header, each of which has a name of the form <em>name.h</em> behaves as if each name placed in the Standard library namespace by the corresponding <em>cname</em> header is also placed within the namespace scope of namespace <code>std</code> and is followed by an explicit <em>using-declaration</em> (7.3.3)</p>\n</blockquote>\n<p>This was between hard and impossible to follow, because it conflicted with the existing <em>real</em> C headers on most systems. So, in C++11 the text was changed to the one you quote. It allows implementations to it the other way round, like they <em>in practice</em> have done all along - use existing system provided C headers and import the names to namespace <code>std</code>.</p>\n<p>However, there is another paragraph saying that whichever way the implementation does this, the names in the headers must mean the same thing:</p>\n<blockquote>\n<p id=\"so_10466096_10469611_1\">For each type <code>T</code> from the Standard C library, the types <code>::T</code> and <code>std::T</code> are reserved to the implementation and, when defined, <code>::T</code> shall be identical to <code>std::T</code>. ([extern.types], 17.6.4.3.4)</p>\n</blockquote>\n", "LastActivityDate": "2012-05-06T09:50:17.757", "CommentCount": "0", "CreationDate": "2012-05-06T09:50:17.757", "ParentId": "10466096", "Score": "2", "OwnerUserId": "597607"}, "10466115": {"Id": "10466115", "PostTypeId": "2", "Body": "<p>Yes, they can be different types. Use the C++ types; the C headers are only there for compatibility.</p>\n<p>Consider if as the comment to the answer above suggests, the C++ header were implemented as <code>namespace std { #include \"stdio.h\" }</code>; then <code>::FILE</code> and <code>std::FILE</code> would represent different types.</p>\n", "LastEditorUserId": "1377349", "LastActivityDate": "2012-05-05T22:07:02.300", "Score": "1", "CreationDate": "2012-05-05T21:24:47.310", "ParentId": "10466096", "CommentCount": "2", "OwnerUserId": "1377349", "LastEditDate": "2012-05-05T22:07:02.300"}, "10466167": {"Id": "10466167", "PostTypeId": "2", "Body": "<p>Yes, that's standard conforming: <code>FILE*</code> is declared in <code>stdio.h</code>, <code>std::FILE*</code> in <code>cstdio</code>, and the two are the same because of the paragraph you cited.</p>\n<p>(The only thing that's unspecified is whether, if you <em>only</em> include <code>&lt;cstdio&gt;</code>, you also have the same <code>FILE*</code> in the global namespace or not.)</p>\n<hr>\n<p>Update: I believe that the types <em>are</em> actually the same on the nose, and that each type is declared only once and then injected in to the other namespace via a <code>using</code> declaration.  The only thing that's unspecified is which one comes first. The corresponding opposite standard quote is D.5(2):</p>\n<blockquote>\n<p id=\"so_10466096_10466167_0\">Every C header, each of which has a name of the form name.h, behaves as if each name placed in the standard library namespace by the corresponding cname header is placed within the global namespace scope. It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace std and are then injected into the global namespace scope by explicit using-declarations (7.3.3).</p>\n</blockquote>\n<p>Basically, that means that two implementations are possible:</p>\n<p><strong>\"C came first\":</strong></p>\n<pre><code>// foo.h\n\nstruct Gizmo { /* ... */ };\n</code></pre>\n<p></p>\n<pre><code>// cfoo\n\n#include \"foo.h\"\nnamespace std { using ::Gizmo; }\n</code></pre>\n<p><br/></p>\n<p><strong>\"C++ with C-compatibility:</strong></p>\n<pre><code>// cfoo\n\nnamespace std \n{\n    struct Gizmo { /* ... */ };\n}\n</code></pre>\n<p></p>\n<pre><code>// foo.h\n\n#include &lt;cfoo&gt;\nusing std::Gizmo;\n</code></pre>\n</hr>", "LastEditorUserId": "596781", "LastActivityDate": "2012-05-05T22:36:51.240", "Score": "3", "CreationDate": "2012-05-05T21:32:14.763", "ParentId": "10466096", "CommentCount": "7", "OwnerUserId": "596781", "LastEditDate": "2012-05-05T22:36:51.240"}});