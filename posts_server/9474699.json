post_cb({"9474799": {"ParentId": "9474699", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>For your question, the important part of the quote you've included is this:</p>\n<blockquote>\n<p id=\"so_9474699_9474799_0\">The negative of an unsigned quantity is computed by subtracting its\n  value from 2\u207f, where n is the number of bits in the promoted operand.</p>\n</blockquote>\n<p>So, to know what the value of <code>-0x80000000u</code> is, we need to know <code>n</code>, the number of bits in the type of <code>0x80000000u</code>.  This is at least 32, but this is all we know (without further information about the sizes of types in your implementation).  Given some values of <code>n</code>, we can calculate what the result will be:</p>\n<pre><code>n   | -0x80000000u \n----+--------------\n32  | 0x80000000\n33  | 0x180000000\n34  | 0x380000000\n48  | 0xFFFF80000000\n64  | 0xFFFFFFFF80000000\n</code></pre>\n<p>(For example, an implementation where <code>unsigned int</code> is 16 bits and <code>unsigned long</code> is 64 bits would have an <code>n</code> of 64).</p>\n<hr>\n<p>C99 has equivalent wording hidden away in \u00a76.2.5 Types p9:</p>\n<blockquote>\n<p id=\"so_9474699_9474799_1\">A computation involving unsigned operands can never overflow, because\n  a result that cannot be represented by the resulting unsigned integer\n  type is reduced modulo the number that is one greater than the largest\n  value that can be represented by the resulting type.</p>\n</blockquote>\n<p>The result of the unary <code>-</code> operator on an unsigned operand other than zero will always be caught by this rule.</p>\n<p>With a 32 bit <code>int</code>, the type of <code>0x80000000</code> will be <code>unsigned int</code>, regardless of the lack of a <code>u</code> suffix, so the result will still be the value <code>0x80000000</code> with type <code>unsigned int</code>.</p>\n<p>If instead you use the decimal constant <code>2147483648</code>, it will have type <code>long</code> and the calculation will be signed.  The result will be the value <code>-2147483648</code> with type <code>long</code>.</p>\n</hr>", "OwnerUserId": "134633", "LastEditorUserId": "134633", "LastEditDate": "2012-02-28T03:56:21.060", "Id": "9474799", "Score": "5", "CreationDate": "2012-02-28T00:52:57.973", "LastActivityDate": "2012-02-28T03:56:21.060"}, "9474790": {"ParentId": "9474699", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In n1336, 6.3.1.3 Signed and Unsigned Integers, paragraph 2 defines the conversion to an unsigned integer:</p>\n<blockquote>\n<p id=\"so_9474699_9474790_0\">Otherwise, if the new type is unsigned, the value is converted by\n  repeatedly adding or subtracting one more than the maximum value that\n  can be represented in the new type until the value is in the range of\n  the new type.</p>\n</blockquote>\n<p>So for 32-bit unsigned int, <code>-0x80000000u==-0x80000000 + 0x100000000==0x80000000u</code>.</p>\n", "OwnerUserId": "6210", "LastEditorUserId": "6210", "LastEditDate": "2012-02-28T03:17:44.613", "Id": "9474790", "Score": "2", "CreationDate": "2012-02-28T00:51:52.717", "LastActivityDate": "2012-02-28T03:17:44.613"}, "bq_ids": {"n4140": {"so_9474699_9474699_0": {"section_id": 6071, "quality": 0.9210526315789473, "length": 35}, "so_9474699_9474799_1": {"section_id": 7213, "quality": 0.8148148148148148, "length": 22}, "so_9474699_9474799_0": {"section_id": 6071, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_9474699_9474699_0": {"section_id": 5839, "quality": 0.9210526315789473, "length": 35}, "so_9474699_9474799_1": {"section_id": 6957, "quality": 0.8148148148148148, "length": 22}, "so_9474699_9474799_0": {"section_id": 5839, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_9474699_9474799_1": {"section_id": 8722, "quality": 0.8148148148148148, "length": 22}, "so_9474699_9474699_0": {"section_id": 7567, "quality": 0.9210526315789473, "length": 35}, "so_9474699_9474799_0": {"section_id": 7567, "quality": 0.9230769230769231, "length": 12}}}, "9474699": {"CommentCount": "7", "ViewCount": "2087", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-02-28T00:41:32.773", "LastActivityDate": "2013-11-24T01:51:48.443", "Title": "unary minus for 0x80000000 (signed and unsigned)", "AcceptedAnswerId": "9474799", "LastEditDate": "2017-05-23T11:55:53.187", "Id": "9474699", "Score": "2", "Body": "<p>The n3337.pdf draft, 5.3.1.8, states that:</p>\n<blockquote>\n<p id=\"so_9474699_9474699_0\">The operand of the unary <code>-</code> operator shall have arithmetic or  unscoped enumeration type and the result is the negation of its   operand. Integral promotion is performed on integral or enumeration   operands. The negative of an unsigned quantity is computed by    subtracting its value from 2\u207f, where n is the number of bits in the   promoted operand. The type of the result is the type of the promoted    operand.</p>\n</blockquote>\n<p>For some cases it is enough. Suppose unsigned int is 32 bits wide, then <code>(-(0x80000000u)) == 0x80000000u</code>, isn't it? </p>\n<p>Still, I can not find anything about unary minus on unsigned 0x80000000. Also, C99 standard draft n1336.pdf, 6.5.3.3 seems to say nothing about it:</p>\n<blockquote>\n<p id=\"so_9474699_9474699_1\">The result of the unary - operator is the negative of its (promoted) operand. The integer promotions are performed on the operand, and the result has the promoted type.</p>\n</blockquote>\n<p>UPDATE2: Let us suppose that unsigned int is 32 bits wide. So, the question is: what about unary minus in C (signed and unsigned), and unary minus in C++ (signed only)?</p>\n<p>UPDATE1: both run-time behavior and compile-time behavior (i.e. constant-folding) are interesting.</p>\n<p>(related: <a href=\"https://stackoverflow.com/questions/2539178/why-is-abs0x80000000-0x80000000\">Why is abs(0x80000000) == 0x80000000?</a>)</p>\n", "Tags": "<c++><c><standards><unary-operator>", "OwnerUserId": "1123502", "AnswerCount": "2"}});