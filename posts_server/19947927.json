post_cb({"bq_ids": {"n4140": {"so_19947927_19948361_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6989}}, "n3337": {"so_19947927_19948361_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6735}}, "n4659": {"so_19947927_19948361_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 8487}}}, "19957419": {"Id": "19957419", "PostTypeId": "2", "Body": "<p>This is not specific to template:</p>\n<pre><code>#include &lt;string&gt;\n\nclass HandlerString\n{\npublic:\n    void Handle(const std::string&amp; event) {}\n};\n\nclass HandlerInt\n{\npublic:\n    void Handle(int event) {}\n};\n\nclass ConcreteHandler : public HandlerString, public HandlerInt {};\n\nint main(int argc, char const *argv[])\n{\n    ConcreteHandler handler;\n\n    handler.Handle(std::string(\"foo\"));\n    handler.Handle(1);\n    return 0;\n}\n</code></pre>\n<p>Output of g++ 4.8.1: </p>\n<pre><code>test.cpp: In function 'int main(int, const char**)':\ntest.cpp:21:10: error: request for member 'Handle' is ambiguous\n  handler.Handle(std::string(\"foo\"));\n          ^\ntest.cpp:12:7: note: candidates are: void HandlerInt::Handle(int)\n  void Handle(int event) {}\n       ^\ntest.cpp:6:7: note:                 void HandlerString::Handle(const string&amp;)\n  void Handle(const std::string&amp; event) {}\n       ^\ntest.cpp:22:10: error: request for member 'Handle' is ambiguous\n  handler.Handle(1);\n          ^\ntest.cpp:12:7: note: candidates are: void HandlerInt::Handle(int)\n  void Handle(int event) {}\n       ^\ntest.cpp:6:7: note:                 void HandlerString::Handle(const string&amp;)\n  void Handle(const std::string&amp; event) {}\n       ^\n</code></pre>\n", "LastEditorUserId": "2439734", "LastActivityDate": "2013-11-13T16:08:29.113", "Score": "0", "CreationDate": "2013-11-13T15:16:10.570", "ParentId": "19947927", "CommentCount": "0", "OwnerUserId": "2439734", "LastEditDate": "2013-11-13T16:08:29.113"}, "19947927": {"ViewCount": "173", "Body": "<p>I'm not sure if template type deduction enters the fray here. But let me explain. </p>\n<p>I have a template <code>class EventProducer</code> from which objects that raise events derive, <em>once</em> for every event type, so that I can have something like this: <code>class HellRaiser: public EventProducer&lt;MouseMoveEvent&gt;, public EventProducer&lt;MouseButtonEvent&gt;</code>. This seems to work just fine, except that you have to qualify the <code>EventProducer</code> calls with the base type when calling through an object of the derived class. But shouldn't the compiler automatically deduce the base <code>EventProducer</code>?</p>\n<p>This is the definition:</p>\n<pre><code>template &lt;typename TEvent&gt;\nclass EventProducer\n{\npublic:\n    typedef function&lt;typename TEvent::HandlerSignature&gt; HandlerFunction;\n\n    //  Methods.\n    connection Subscribe(const HandlerFunction&amp; callback);\n    void Trigger(TEvent&amp; event);\n\nprotected:\n    // ...\n};\n</code></pre>\n<p>Where <code>TEvent::HandlerSignature</code> is defined in the event class.</p>\n<ol>\n<li>Why is this call ambiguous: <code>hellRaiserObject-&gt;Trigger(MouseMoveEvent(11, -4));</code> assuming the object derives from <code>EventProducer&lt;MouseMoveEvent&gt;</code> and <code>EventProducer&lt;MouseButtonEvent&gt;</code>?</li>\n<li>Can I do something to help the compiler decide which to call, without explicitly specifying the base?</li>\n<li>The same happens with this call: <code>hellRaiserObject-&gt;Subscribe(mouseCallback);</code>. I understand it may be a bit harder to deduce the type here, but <code>mouseCallback</code> has a specific signature that can be compared to the template specializations, and it only fits one of them, I think.</li>\n</ol>\n<p>Just in case it makes a difference, events are defined like this: <code>class MouseMoveEvent: public Event&lt;MouseMoveEvent&gt;</code>, where the base template is</p>\n<pre><code>template &lt;typename TEventArgs&gt;\nclass Event\n{\npublic:\n    typedef TEventArgs EventArgs;\n    typedef void HandlerSignature(TEventArgs&amp;);\n\n    // ...\n};\n</code></pre>\n<p>Help much appreciated.</p>\n", "AcceptedAnswerId": "19948361", "Title": "Base resolution/template type deduction", "CreationDate": "2013-11-13T07:32:54.220", "Id": "19947927", "CommentCount": "0", "LastEditDate": "2013-11-13T08:36:53.133", "PostTypeId": "1", "LastEditorUserId": "374253", "LastActivityDate": "2013-11-13T16:08:29.113", "Score": "3", "OwnerUserId": "374253", "Tags": "<c++><templates><c++11><template-meta-programming>", "AnswerCount": "2"}, "19948361": {"Id": "19948361", "PostTypeId": "2", "Body": "<p>Name lookup from multiple base classes has to be unambiguous</p>\n<p><strong>10.2 Member name lookup [class.member.lookup]</strong></p>\n<blockquote>\n<p id=\"so_19947927_19948361_0\">1 Member name lookup determines the meaning of a name (id-expression)\n  in a class scope (3.3.7). Name lookup can result in an ambiguity, in\n  which case the program is ill-formed.</p>\n</blockquote>\n<p>There are a bunch of technical details in that section of the Standard about how the names from the various base classes are to be merged, but in the end, if an ambiguity occurs, the program is ill-formed. Hence, you need to qualify your name in order to resolve this.</p>\n<p>Note that the best matching signature of the various functions would come into play during overload resolution, but that occurs only after a successful and unambiguous name lookup.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2013-11-13T10:48:01.967", "Score": "3", "CreationDate": "2013-11-13T07:57:59.987", "ParentId": "19947927", "CommentCount": "4", "OwnerUserId": "819272", "LastEditDate": "2013-11-13T10:48:01.967"}});