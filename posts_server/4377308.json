post_cb({"4377469": {"CommentCount": "0", "Body": "<p>There's no need to cast to <code>ptrdiff_t</code>.  Pointer arithmetic is well-defined for all integral types, including <code>size_t</code>, and if <code>size_t</code> wasn't big enough to hold the value, the cast to <code>ptrdiff_t</code> comes too late anyway.</p>\n<p>Here is the relevant language from the Standard (C++0x FCD, section <code>[expr.add]</code>):</p>\n<blockquote>\n<p id=\"so_4377308_4377469_0\">When an expression that has integral\n  type is added to or subtracted from a\n  pointer, the result has the type of\n  the pointer operand.  If the pointer\n  operand points to an element of an\n  array object, and the array is large\n  enough, the result points to an\n  element offset from the original\n  element such that the difference of\n  the subscripts of the resulting and\n  original array elements equals the\n  integral expression. In other words,\n  if the expression P points to the i\n  -th element of an array object, the expressions (P)+N (equivalently,\n  N+(P)) and (P)-N (where N has the\n  value n ) point to, respectively, the\n  i + n -th and i \u2212 n -th elements of\n  the array object, provided they exist.\n  Moreover, if the expression P points\n  to the last element of an array\n  object, the expression (P)+1 points\n  one past the last element of the array\n  object, and if the expression Q points\n  one past the last element of an array\n  object, the expression (Q)-1 points to\n  the last element of the array object. \n  If both the pointer operand and the\n  result point to elements of the same\n  array object, or one past the last\n  element of the array object, the\n  evaluation shall not produce an\n  overflow; otherwise, the behavior is\n  undefined.</p>\n</blockquote>\n", "CreationDate": "2010-12-07T14:08:08.103", "ParentId": "4377308", "Id": "4377469", "LastActivityDate": "2010-12-07T14:08:08.103", "PostTypeId": "2", "Score": "2", "OwnerUserId": "103167"}, "4377308": {"CreationDate": "2010-12-07T13:51:16.113", "ViewCount": "9106", "FavoriteCount": "4", "Id": "4377308", "AcceptedAnswerId": "4377401", "Score": "8", "Title": "C++ size_t or ptrdiff_t", "LastEditorUserId": "451980", "CommentCount": "9", "Body": "<p>If you have the following code where p is a pointer:</p>\n<pre><code>p = p + strlen(p) + size_t(1);\n</code></pre>\n<p>Since <code>strlen()</code> and <code>size_t</code> are both <code>size_t</code>, should I cast the code to <code>ptrdiff_t</code> ?</p>\n<pre><code>p = p + (ptrdiff_t)(strlen(p) + size_t(1));\n</code></pre>\n<p>If so why?</p>\n<p>Thanks,\nGreg</p>\n", "Tags": "<c++>", "LastEditDate": "2010-12-07T14:00:04.750", "LastActivityDate": "2013-08-28T12:45:25.067", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "361992"}, "4377401": {"LastActivityDate": "2013-08-28T12:45:25.067", "CommentCount": "1", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/ptrdiff_t\">std::ptrdiff_t</a> is signed. <a href=\"http://en.cppreference.com/w/cpp/types/size_t\">std::size_t</a> is unsigned. Casting <code>strlen(p)</code> to <code>ptrdiff_t</code> would make sense if <code>p</code> could have a negative length, which is not possible.</p>\n<p>However, that cast could overflow the resulting signed value if <code>p</code> is large enough (for instance, larger than 2,147,483,647 bytes on most 32-bit platforms). So it could introduce an error in your pointer arithmetic.</p>\n<p>Best to stick with <code>size_t</code> here.</p>\n", "CreationDate": "2010-12-07T14:01:31.947", "LastEditDate": "2013-08-28T12:45:25.067", "ParentId": "4377308", "Id": "4377401", "LastEditorUserId": "464709", "PostTypeId": "2", "Score": "14", "OwnerUserId": "464709"}, "bq_ids": {"n4140": {"so_4377308_4377469_0": {"length": 105, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_4377308_4377469_0": {"length": 105, "quality": 1.0, "section_id": 5906}}}});