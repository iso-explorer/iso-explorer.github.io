post_cb({"bq_ids": {"n4140": {"so_27933307_27935812_1": {"length": 41, "quality": 0.8913043478260869, "section_id": 7104}, "so_27933307_27935812_0": {"length": 16, "quality": 0.5517241379310345, "section_id": 3906}}, "n3337": {"so_27933307_27935812_1": {"length": 41, "quality": 0.8913043478260869, "section_id": 6848}, "so_27933307_27935812_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 3766}}, "n4659": {"so_27933307_27935812_1": {"length": 37, "quality": 0.8043478260869565, "section_id": 8605}}}, "27935812": {"Id": "27935812", "PostTypeId": "2", "Body": "<p>Per C++11 [stmt.ranged]/1, your loop:</p>\n<pre><code>for (auto a : A::All) {\n    std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>{\n    auto &amp;&amp; __range = (A::All);\n    for ( auto __begin = begin-expr,\n               __end = end-expr;\n          __begin != __end;\n          ++__begin ) {\n        auto a = *__begin;\n        {\n            std::cout &lt;&lt; a &lt;&lt; std::endl;\n        }\n    }\n}\n</code></pre>\n<p>where the determination of the expressions <code>begin-expr</code> and <code>end-expr</code> depends on the type <code>_RangeT</code> of the initializer expression <code>A::All</code> (<code>bool</code> in this case):</p>\n<blockquote id=\"so_27933307_27935812_0\">\n<ul>\n<li>if <code>_RangeT</code> is an array type, ...</li>\n<li>if <code>_RangeT</code> is a class type, ...</li>\n<li>otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <strong><code>begin</code> and <code>end</code> are looked up with argument-dependent lookup (3.4.2)</strong> [<em>emphasis added</em>]. For the purposes of this name lookup, namespace <code>std</code> is an associated namespace.</li>\n</ul>\n</blockquote>\n<p>Since <code>bool</code> is neither an array or class type, the third bullet applies; the expressions are <code>begin(__range)</code> and <code>end(__range)</code>, but <code>begin</code> and <code>end</code> are resolved using ADL with <code>std</code> as an associated namespace. Per 3.4.2 [basic.lookup.argdep]/2:</p>\n<blockquote>\n<p id=\"so_27933307_27935812_1\">For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument). <strong>Typedef names and using-declarations used to specify the types do not contribute to this set.</strong> [<em>emphasis added</em>] The sets of namespaces and classes are determined in the following way:</p>\n<ul>\n<li>If T is a fundamental type, its associated sets of namespaces and classes are both empty.</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>So <code>begin</code> and <code>end</code> are looked up only in the <code>std</code> namespace, where several declarations are found, but none that can accept an argument of type <code>bool</code>. The program is ill-formed.</p>\n", "LastActivityDate": "2015-01-14T04:20:31.423", "CommentCount": "1", "CreationDate": "2015-01-14T04:20:31.423", "ParentId": "27933307", "Score": "5", "OwnerUserId": "923854"}, "27933307": {"ViewCount": "1468", "Body": "<p>Consider:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass A\n{\npublic:\n    typedef bool TAll;\n    static TAll All;\n\n    typedef std::vector&lt;int&gt; TVec;\n    static TVec m_sVec;\n\n    static TVec::iterator begin() { return m_sVec.begin(); }\n    static TVec::iterator end() { return m_sVec.end(); }\n};\n\nA::TVec A::m_sVec;\nA::TAll A::All;\n\nA::TVec::iterator begin(A::TAll&amp; all) { return A::begin(); }\nA::TVec::iterator end(A::TAll&amp; all) { return A::end(); }\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    A::m_sVec.push_back(1);\n    A::m_sVec.push_back(2);\n    A::m_sVec.push_back(3);\n\n    for (auto a : A::All) {\n    //for (auto a = begin(A::All); a != end(A::All); a++) {\n        std::cout &lt;&lt; a &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>The version with the range based for loop (so this code as-is) gives me the following error in MSVC2013:</p>\n<pre><code>1&gt;&lt;snip&gt;: error C3312: no callable 'begin' function found for type 'A::TAll'\n1&gt;&lt;snip&gt;: error C3312: no callable 'end' function found for type 'A::TAll'\n</code></pre>\n<p>GCC (4.8.3) says (last two lines):</p>\n<pre><code>/usr/include/c++/4.8.3/initializer_list:99:5: note: template&lt;class _Tp&gt; constexpr cons\nt _Tp* std::end(std::initializer_list&lt;_Tp&gt;)                                           \n     end(initializer_list&lt;_Tp&gt; __ils) noexcept                                        \n     ^                                                                                \n/usr/include/c++/4.8.3/initializer_list:99:5: note:   template argument deduction/subs\ntitution failed:                                                                      \nmain.cpp:31:18: note:   mismatched types 'std::initializer_list&lt;_Tp&gt;' and 'bool'      \n  for (int a : A::All) { \n</code></pre>\n<p>The 'normal' for loop that uses the functions (the one that is commented out) works (well, after dereferencing 'a' inside the loop of course); it is my understanding of the standard and the Stroustroup that they should be equivalent. But I guess not. So what is the problem here? Thanks.</p>\n", "AcceptedAnswerId": "27935812", "Title": "Range based for loop - why are these begin/end functions not found?", "CreationDate": "2015-01-13T23:20:45.983", "Id": "27933307", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-01-14T14:48:53.663", "LastEditorUserId": "241631", "LastActivityDate": "2015-01-14T14:48:53.663", "Score": "2", "OwnerUserId": "11449", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "27940250": {"Id": "27940250", "PostTypeId": "2", "Body": "<p>For those above wondering what the point is, consider the following slightly less abstract example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;xfunctional&gt;\n\n#include &lt;boost/iterator/filter_iterator.hpp&gt;\n\nstruct Employee\n{\n    std::string name;\n    int age;\n    operator int() { return age; }\n};\n\nclass Employees\n{\npublic:\n    struct TOlderThan {\n        int m_MinimumAge;\n        TOlderThan&amp; operator()(int age)\n        {\n            m_MinimumAge = age;\n            return *this;\n        }\n    };\n    static TOlderThan OlderThan;\n\n    typedef std::vector&lt;Employee&gt; TEmployees;\n    static TEmployees sEmployees;\n\n    static TEmployees::iterator begin() { return sEmployees.begin(); }\n    static TEmployees::iterator end() { return sEmployees.end(); }\n};\n\nEmployees::TEmployees Employees::sEmployees;\nEmployees::TOlderThan Employees::OlderThan;\n\ntypedef boost::filter_iterator&lt;std::binder1st&lt;std::less&lt;int&gt;&gt;, Employees::TEmployees::iterator&gt; TFilter;\nTFilter begin(const Employees::TOlderThan&amp; min_age) { return boost::make_filter_iterator(std::bind1st(std::less&lt;int&gt;(), min_age.m_MinimumAge), Employees::begin(), Employees::end()); }\nTFilter end(const Employees::TOlderThan&amp; min_age) { return boost::make_filter_iterator(std::bind1st(std::less&lt;int&gt;(), min_age.m_MinimumAge), Employees::end(), Employees::end()); }\n\nint main(int argc, _char* argv[])\n{\n    Employees::sEmployees.push_back({\"John\", 34});\n    Employees::sEmployees.push_back({\"Pete\", 48});\n    Employees::sEmployees.push_back({\"Jake\", 59});\n\n    for (Employee&amp; e : Employees::OlderThan(40)) {\n        std::cout &lt;&lt; e.name &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Outputs, as expected</p>\n<pre><code>Pete\nJake\n</code></pre>\n<p>Basically, this feature lets you build almost DSL-style behaviour into your API's with less than 10 lines of code. Pretty cool.</p>\n", "LastActivityDate": "2015-01-14T10:03:59.697", "CommentCount": "0", "CreationDate": "2015-01-14T10:03:59.697", "ParentId": "27933307", "Score": "0", "OwnerUserId": "11449"}});