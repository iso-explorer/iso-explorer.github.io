post_cb({"25552822": {"ViewCount": "1563", "Body": "<p>The C++ Draft Standard (N3337) has the following about conversion of pointers:</p>\n<blockquote>\n<p id=\"so_25552822_25552822_0\"><strong>4.10 Pointer conversions</strong></p>\n<p id=\"so_25552822_25552822_1\">2 An rvalue of type \u201cpointer to <em>cv</em> <code>T</code>,\u201d where <code>T</code> is an object type, can be converted to an rvalue of type \u201cpointer to <em>cv</em> <code>void</code>.\u201d The result of converting a \u201cpointer to <em>cv</em> <code>T</code>\u201d to a \u201cpointer to <em>cv</em> <code>void</code>\u201d points to the start of the storage location where the object of type <code>T</code> resides, as if the object is a most derived object (1.8) of type <code>T</code> (that is, not a base class subobject).</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_25552822_25552822_2\"><strong>4.12 Boolean conversions</strong></p>\n<p id=\"so_25552822_25552822_3\">1 An rvalue of arithmetic, enumeration, pointer, or pointer to member type can be converted to an rvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true</p>\n</blockquote>\n<p>Based on the above, it is perfectly OK to convert a function pointer or a pointer to an <code>int</code> to a <code>void*</code> as well as <code>bool</code>.</p>\n<p>However, given the choice of both, which one should a pointer convert to?</p>\n<p>And then, why does a pointer to a function convert to a <code>bool</code> and a pointer to an <code>int</code> convert to a <code>void*</code>?</p>\n<p>Program:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nvoid foo(const void* ptr)\n{\n   std::cout &lt;&lt; \"In foo(void*)\" &lt;&lt; std::endl;\n}\n\nvoid foo(bool b)\n{\n   std::cout &lt;&lt; \"In foo(bool)\" &lt;&lt; std::endl;\n}\n\nvoid bar()\n{\n}\n\nint main()\n{\n   int i = 0;\n   foo(&amp;bar);\n   foo(&amp;i);\n   return 0;\n}\n</code></pre>\n<p>Output, using g++ 4.7.3:</p>\n<pre>\nIn foo(bool)\nIn foo(void*)\n</pre>\n", "AcceptedAnswerId": "25553119", "Title": "Why does pointer to int convert to void* but pointer to function convert to bool?", "CreationDate": "2014-08-28T15:40:19.580", "Id": "25552822", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-08-28T16:31:35.400", "Score": "23", "OwnerUserId": "434551", "Tags": "<c++><pointers><c++11>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25552822_25553119_8": {"length": 25, "quality": 0.9615384615384616, "section_id": 640}, "so_25552822_25553119_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 563}, "so_25552822_25553119_2": {"length": 15, "quality": 1.0, "section_id": 563}, "so_25552822_25553119_9": {"length": 12, "quality": 1.0, "section_id": 640}, "so_25552822_25553119_6": {"length": 46, "quality": 0.9019607843137255, "section_id": 617}, "so_25552822_25553119_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 563}, "so_25552822_25553119_7": {"length": 16, "quality": 0.9411764705882353, "section_id": 618}, "so_25552822_25552822_3": {"length": 25, "quality": 0.9259259259259259, "section_id": 44}, "so_25552822_25553119_5": {"length": 15, "quality": 0.8333333333333334, "section_id": 608}, "so_25552822_25553119_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 6143}}, "n3337": {"so_25552822_25553119_8": {"length": 25, "quality": 0.9615384615384616, "section_id": 630}, "so_25552822_25553119_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 554}, "so_25552822_25553119_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5907}, "so_25552822_25553119_9": {"length": 12, "quality": 1.0, "section_id": 630}, "so_25552822_25553119_6": {"length": 46, "quality": 0.9019607843137255, "section_id": 607}, "so_25552822_25553119_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 554}, "so_25552822_25553119_7": {"length": 16, "quality": 0.9411764705882353, "section_id": 608}, "so_25552822_25552822_3": {"length": 25, "quality": 0.9259259259259259, "section_id": 41}, "so_25552822_25552822_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 37}, "so_25552822_25553119_5": {"length": 15, "quality": 0.8333333333333334, "section_id": 598}, "so_25552822_25553119_2": {"length": 15, "quality": 1.0, "section_id": 554}}, "n4659": {"so_25552822_25553119_8": {"length": 25, "quality": 0.9615384615384616, "section_id": 668}, "so_25552822_25553119_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 586}, "so_25552822_25553119_2": {"length": 15, "quality": 1.0, "section_id": 586}, "so_25552822_25553119_9": {"length": 12, "quality": 1.0, "section_id": 668}, "so_25552822_25553119_6": {"length": 46, "quality": 0.9019607843137255, "section_id": 643}, "so_25552822_25553119_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 586}, "so_25552822_25553119_7": {"length": 16, "quality": 0.9411764705882353, "section_id": 644}, "so_25552822_25552822_3": {"length": 25, "quality": 0.9259259259259259, "section_id": 45}, "so_25552822_25553119_5": {"length": 15, "quality": 0.8333333333333334, "section_id": 634}}}, "25553119": {"Id": "25553119", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25552822_25553119_0\">Based on the above, it is perfectly OK to convert a function pointer or a pointer to an <code>int</code> to a <code>void*</code> as well as <code>bool</code>.</p>\n</blockquote>\n<p>The quotation states that a pointer to an <em>object</em> can be converted to <code>cv void *</code>. Functions are not objects, and this disqualifies the conversion to <code>cv void *</code>, leaving only <code>bool</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_25552822_25553119_1\">However, given the choice of both, which one should a pointer convert to?</p>\n</blockquote>\n<p>It should convert to <code>const void *</code> over <code>bool</code>. Why? Well, prepare for a journey that starts in Overload Resolution (\u00a713.3 [over.match]/2). Emphasis mine, of course.</p>\n<blockquote>\n<p id=\"so_25552822_25553119_2\">But, once the candidate functions and argument lists have been identified, the selection of the best function is the same in all cases:  </p>\n<p id=\"so_25552822_25553119_3\">\u2014 First, a subset of the candidate functions (those that have the proper number of arguments and meet\n  certain other conditions) is selected to form a set of viable functions (13.3.2).  </p>\n<p id=\"so_25552822_25553119_4\">\u2014 Then the best viable function is selected <strong>based on the implicit conversion sequences (13.3.3.1)</strong> needed to match each argument to the corresponding parameter of each viable function.</p>\n</blockquote>\n<h3>So what about these implicit conversion sequences?</h3>\n<p>Let's jump over to \u00a713.3.3.1 [over.best.ics]/3 and see just what an implicit conversion sequence is:</p>\n<blockquote>\n<p id=\"so_25552822_25553119_5\">A well-formed implicit conversion sequence is one of the following forms:<br>\n  \u2014 a standard conversion sequence (13.3.3.1.1),<br>\n  \u2014 a user-defined conversion sequence (13.3.3.1.2), or<br>\n  \u2014 an ellipsis conversion sequence (13.3.3.1.3).</br></br></br></p>\n</blockquote>\n<p>We're interested in standard conversions sequences. Let's pop over to Standard Conversion Sequences (\u00a713.3.3.1.1 [over.ics.scs]):</p>\n<blockquote>\n<p id=\"so_25552822_25553119_6\">1 Table 12 summarizes the conversions defined in Clause 4 and partitions them into four disjoint categories: Lvalue Transformation, Qualification Adjustment, Promotion, and Conversion. [ Note: These categories are orthogonal with respect to value category, cv-qualification, and data representation: the Lvalue Transformations do not change the cv-qualification or data representation of the type; the Qualification Adjustments do not change the value category or data representation of the type; and the Promotions and Conversions do not change the value category or cv-qualification of the type. \u2014 end note ]</p>\n<p id=\"so_25552822_25553119_7\">2 [ Note: As described in Clause 4, a standard conversion sequence is either the Identity conversion by itself (that is, no conversion) or consists of one to three conversions from the other four categories.</p>\n</blockquote>\n<p>The important part is in /2. A standard conversion sequence is allowed to be a single standard conversion. These standard conversions are listed in Table 12, shown below. Notice that both your Pointer Conversions and Boolean Conversions are in there.</p>\n<p><img alt=\"Table of standard conversions and their categories and ranks\" src=\"https://i.imgur.com/qNCaopQ.png\"/></p>\n<p>From here, we learn something important: Pointer conversions and boolean conversions have the same rank. Remember that as we head to Ranking Implicit Conversion Sequences (\u00a713.3.3.2 [over.ics.rank]).</p>\n<p>Looking at /4, we see:</p>\n<blockquote>\n<p id=\"so_25552822_25553119_8\">Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank are indistinguishable unless one of the following rules applies:</p>\n<p id=\"so_25552822_25553119_9\">\u2014 A conversion that does not convert a pointer, a pointer to member, or std::nullptr_t to bool is\n  better than one that does.</p>\n</blockquote>\n<p>We've found our answer in the form of a very explicit statement. Hooray!</p>\n</hr>", "LastEditorUserId": "962089", "LastActivityDate": "2014-08-28T16:17:28.233", "Score": "27", "CreationDate": "2014-08-28T15:56:10.967", "ParentId": "25552822", "CommentCount": "2", "OwnerUserId": "962089", "LastEditDate": "2014-08-28T16:17:28.233"}});