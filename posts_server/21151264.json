post_cb({"21151590": {"ParentId": "21151264", "CommentCount": "0", "Body": "<p>Apart from the C++ FAQ link from leemes, C++ standard prevent it to be called, I will quote the standard.</p>\n<p>The following says that, virtual member functions can be called within constructor/destructor, but they act as \"not virtual\", which you already know in the C++ FAQ.</p>\n<blockquote>\n<p id=\"so_21151264_21151590_0\">Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2). When a virtual function\n  is called directly or indirectly from a constructor or from a\n  destructor, including during the construction or destruction of the\n  class\u2019s non-static data members, and the object to which the call\n  applies is the object (call it x) under construction or destruction,\n  the function called is the final overrider in the constructor\u2019s or\n  destructor\u2019s class and not one overriding it in a more-derived class.\n  If the virtual function call uses an explicit class member access\n  (5.2.5) and the object expression refers to the complete object of x\n  or one of that object\u2019s base class subobjects but not x or one of its\n  base class subobjects, the behavior is undefined.</p>\n</blockquote>\n<p>It actually also says that, when calling virtual function from a pointer (to itself) with a type that is not direct base class of itself (in multiple inheritance), the behaviour is undefined.</p>\n<p>Example (from standard)</p>\n<pre><code>struct V {\n  virtual void f();\n  virtual void g();\n};\nstruct A : virtual V {\n  virtual void f();\n};\nstruct B : virtual V {\n  virtual void g();\n  B(V*, A*);\n};\nstruct D : A, B {\n  virtual void f();\n  virtual void g();\n  D() : B((A*)this, this) { }\n};\nB::B(V* v, A* a) {\n  f(); // calls V::f, not A::f\n  g(); // calls B::g, not D::g\n  v-&gt;g(); // v is base of B, the call is well-defined, calls B::g\n  a-&gt;f(); // undefined behavior, a\u2019s type not a base of B\n}\n</code></pre>\n<p>The above rules apply to other dynamic binding stuff, including typeid, meaning that you can't use typeid to differentiate derived class type in base constructor.</p>\n<blockquote>\n<p id=\"so_21151264_21151590_1\">The typeid operator (5.2.8) can be used during construction or\n  destruction (12.6.2). When typeid is used in a constructor (including\n  the mem-initializer or brace-or-equal-initializer for a non-static\n  data member) or in a destructor, or used in a function called\n  (directly or indirectly) from a constructor or destructor, if the\n  operand of typeid refers to the object under construction or\n  destruction, typeid yields the std::type_info object representing the\n  constructor or destructor\u2019s class. If the operand of typeid refers to\n  the object under construction or destruction and the static type of\n  the operand is neither the constructor or destructor\u2019s class nor one\n  of its bases, the result of typeid is undefined.</p>\n</blockquote>\n", "OwnerUserId": "534498", "PostTypeId": "2", "Id": "21151590", "Score": "1", "CreationDate": "2014-01-16T01:08:44.817", "LastActivityDate": "2014-01-16T01:08:44.817"}, "21151390": {"ParentId": "21151264", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>While it's possible and sometimes a good choice, it's most of the time a bad idea to call virtual functions in a constructor. Only do this if you really understand what that means. The same applies for calling virtual functions in destructors.</p>\n<p>When the instance of class <code>B</code> is constructed, it first constructs an <code>A</code>. During this phase, the object is only identified as an instance of <code>A</code> rather than <code>B</code>. So at that time, the object has a virtual function table of class <code>A</code>. This means that every virtual function call will resolve to functions of class <code>A</code> (or super classes); the same rules apply as if you would only construct an instance of <code>A</code>.</p>\n<p>For a full explanation, please read <a href=\"http://www.parashift.com/c++-faq/calling-virtuals-from-ctors.html\" rel=\"nofollow\">When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?</a></p>\n<p>Even if it was possible to call the function <code>B::get()</code> within the constructor of <code>A</code> (example: <a href=\"http://ideone.com/sF3411\" rel=\"nofollow\">http://ideone.com/sF3411</a>), that would be undefined behavior, since when the constructor of <code>A</code> is executed, the <code>this</code> pointer is not yet pointing to an instance of <code>B</code>, it's only \"in preparation\" if you will. The linked code might work, but it's a hack and exposes undefined behavior.</p>\n", "OwnerUserId": "592323", "LastEditorUserId": "592323", "LastEditDate": "2014-01-16T01:07:50.600", "Id": "21151390", "Score": "2", "CreationDate": "2014-01-16T00:47:56.773", "LastActivityDate": "2014-01-16T01:07:50.600"}, "bq_ids": {"n4140": {"so_21151264_21151590_0": {"section_id": 447, "quality": 0.9594594594594594, "length": 71}, "so_21151264_21151590_1": {"section_id": 448, "quality": 0.9508196721311475, "length": 58}}, "n3337": {"so_21151264_21151590_0": {"section_id": 438, "quality": 0.9594594594594594, "length": 71}, "so_21151264_21151590_1": {"section_id": 439, "quality": 0.9508196721311475, "length": 58}}, "n4659": {"so_21151264_21151590_0": {"section_id": 469, "quality": 0.9594594594594594, "length": 71}, "so_21151264_21151590_1": {"section_id": 470, "quality": 0.9016393442622951, "length": 55}}}, "21151264": {"CommentCount": "0", "ViewCount": "456", "PostTypeId": "1", "ClosedDate": "2014-03-18T08:15:37.767", "LastEditorUserId": "1611986", "CreationDate": "2014-01-16T00:36:54.463", "LastActivityDate": "2014-01-16T01:08:44.817", "Title": "Base method is being called instead of derive method from constructor", "LastEditDate": "2014-01-16T00:52:28.330", "Id": "21151264", "Score": "1", "Body": "<p>I was expecting derived method <code>get()</code> will be called from constructor of A. Wondering why is this not happening?</p>\n<p>Method <code>get()</code> is virtual in base class so derive class <code>B</code> will override this method.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\nprotected:\n\n    virtual int get() {\n        cout&lt;&lt;\" in A::get \"&lt;&lt;endl;\n        return 0;\n    }\npublic:\n    A() {\n        get();\n    }\n};\n\nclass B : public A {\npublic:\n    B():A() {}\n\nprotected:  \n    int get() override{\n        cout&lt;&lt;\"in B:get() \"&lt;&lt;endl;\n        return 0;\n    }\n};\n\n\nint main() {\nA *a;  a = new B();\nreturn 0;\n}\n</code></pre>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "921195", "AnswerCount": "2"}});