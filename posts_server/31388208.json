post_cb({"31388257": {"ParentId": "31388208", "CommentCount": "13", "Body": "<p>The active member is the last member you wrote to. Simple as that.</p>\n<p>The term is not defined by C++ because it is defined by English.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "31388257", "Score": "0", "CreationDate": "2015-07-13T16:07:41.470", "LastActivityDate": "2015-07-13T16:07:41.470"}, "31390380": {"ParentId": "31388208", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Your concern about the lack of a rigorous definition of <em>the active member of a union</em> is shared by (at least some of) the members of the standardization committee - see the latest note (dated May 2015) in the description of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1116\" rel=\"nofollow\">active issue 1116</a>:</p>\n<blockquote>\n<p id=\"so_31388208_31390380_0\">We never say what the active member of a union is, how it can be changed, and so on. [...]</p>\n</blockquote>\n<p>I think we can expect some sort of clarification in future versions of the working draft. That note also indicates that the best we have so far is the note in the paragraph you quoted in your question, [9.5p4].</p>\n<p>That being said, let's look at your other questions. </p>\n<p>First of all, there are no anonymous structs in standard C++ (only anonymous unions); <code>struct {char a,b,c,d;};</code> will give you warnings if compiled with reasonably strict options (<code>-std=c++1z -Wall -Wextra -pedantic</code> for Clang and GCC, for example). Going forward, I'll assume we have a declaration like <code>struct { char a, b, c, d; } s;</code> and everything else is adjusted accordingly.</p>\n<p>The implicitly defaulted default constructor in your first example doesn't perform any initialization according to [12.6.2p9.2]:</p>\n<blockquote>\n<p id=\"so_31388208_31390380_1\">In a non-delegating constructor, if a given potentially constructed\n  subobject is not designated by a <em>mem-initializer-id</em> (including the\n  case where there is no <em>mem-initializer-list</em> because the constructor\n  has no <em>ctor-initializer</em>), then  </p>\n<p id=\"so_31388208_31390380_2\">(9.1) - if the entity is a non-static data member that has a <em>brace-or-equal-initializer</em> and either  </p>\n<blockquote>\n<p id=\"so_31388208_31390380_7\">(9.1.1) - the constructor\u2019s class is a union (9.5), and no other variant member of that union is designated by a <em>mem-initializer-id</em> or<br>\n    (9.1.2) - the constructor\u2019s class is not a union, and, if the entity is a member of an anonymous union, no other member of that union is designated by a <em>mem-initializer-id</em>,  </br></p>\n</blockquote>\n<p id=\"so_31388208_31390380_4\">the entity is initialized as specified in 8.5;  </p>\n<p id=\"so_31388208_31390380_5\">(9.2) - otherwise, if the entity is an anonymous union or a variant member (9.5), no initialization is performed;  </p>\n<p id=\"so_31388208_31390380_6\">(9.3) - otherwise, the entity is default-initialized (8.5).</p>\n</blockquote>\n<p>I suppose we could say that <code>f</code> has no active member after its default constructor has finished executing, but I don't know of any standard wording that clearly indicates that. What can be said in practice is that it makes no sense to attempt to read the value of any of <code>f</code>'s members, since they're indeterminate.</p>\n<p>In your next example, you're using <em>aggregate initialization</em>, which is reasonably well-defined for unions according to [8.5.1p16]:</p>\n<blockquote>\n<p id=\"so_31388208_31390380_8\">When a union is initialized with a brace-enclosed initializer, the\n  braces shall only contain an <em>initializer-clause</em> for the first\n  non-static data member of the union. [ <em>Example:</em></p>\n<pre><code>union u { int a; const char* b; }; \nu a = { 1 }; \nu b = a; \nu c = 1;               // error \nu d = { 0, \"asdf\" };   // error \nu e = { \"asdf\" };      // error \n</code></pre>\n<p id=\"so_31388208_31390380_9\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>That, together with <em>brace elision</em> for the initialization of the nested struct, as specified in [8.5.1p12], makes the struct the active member. It answers your next question as well: you can only initialize the first union member using that syntax.</p>\n<p>Your next question:</p>\n<blockquote>\n<p id=\"so_31388208_31390380_10\">If I want to activate one or the other union member, should I provide a constructor activating it?</p>\n</blockquote>\n<p>Yes, or a <em>brace-or-equal-initializer</em> for exactly one member according to [12.6.2p9.1.1] quoted above; something like this:</p>\n<pre><code>union Foo\n{\n    struct { char a, b, c, d; } s;\n    char array[4];\n    int integer = 7;\n};\n\nFoo f;\n</code></pre>\n<p>After the above, the active member will be <code>integer</code>. All of the above should also answer your question about <code>#2</code> (the members are not already constructed when we reach the body of the constructor - <code>#2</code> is fine as well).</p>\n<p>Wrapping up, both <code>Foo{}</code> and <code>Foo{1}</code> perform aggregate initialization; they're interpreted as <code>Foo{{}}</code> and <code>Foo{{1}}</code>, respectively, (because of brace elision), and initialize the struct; the first one sets all the struct members to <code>0</code> and the second one sets the first member to <code>1</code> and the rest to <code>0</code>, according to [8.5.1p7].</p>\n<hr>\n<p>All standard quotes are from the current working draft, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a>.</p>\n<hr>\n<p>Paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4430.html\" rel=\"nofollow\">N4430</a>, which deals with somewhat related issues, but hasn't been integrated into the working draft yet, provides a definition for <em>active member</em>:</p>\n<blockquote>\n<p id=\"so_31388208_31390380_11\">In a union, a non-static data member is active if its name refers to an object whose lifetime has begun and has not ended ([basic.life]).</p>\n</blockquote>\n<p>This effectively passes the buck to the definition of lifetime in [3.8], which also has a few issues open against it, including the aforementioned <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1116\" rel=\"nofollow\">issue 1116</a>, so I think we'll have to wait for several such issues to be resolved in order to have a complete and consistent definition. The definition of lifetime as it currently stands doesn't seem to be quite ready.</p>\n</hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2015-07-14T19:14:10.880", "Id": "31390380", "Score": "2", "CreationDate": "2015-07-13T18:06:03.260", "LastActivityDate": "2015-07-14T19:14:10.880"}, "31388208": {"CommentCount": "0", "ViewCount": "379", "CreationDate": "2015-07-13T16:05:08.667", "LastActivityDate": "2015-07-14T19:14:10.880", "Title": "Active member of an union, uniform initialization and constructors", "AcceptedAnswerId": "31390380", "PostTypeId": "1", "Id": "31388208", "Score": "4", "Body": "<p>As the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">(Working Draft of) C++ Standard</a> says:</p>\n<blockquote>\n<h3>9.5.1 [class.union]</h3>\n<p id=\"so_31388208_31388208_0\">In a union, at most <strong>one of the non-static data members can be active at any time</strong>, that is, the value of at most one of the non-static data members can be stored in a union at any time. [...] The size of a union is sufficient to contain the largest of its non-static data members. Each non-static data member is allocated as if it were the sole member of a struct. All non-static data members of a union object have the same address.</p>\n</blockquote>\n<p>But I don't know how to identify which is the active member of an union and I'm not used enough to dive into the standard to locate what the standard says about it, I've tried to figure how the active member is setted but I've found how it is swapped:</p>\n<blockquote>\n<h3>9.5.4 [class.union]</h3>\n<p id=\"so_31388208_31388208_1\">[ <em>Note</em>: In general, one must use explicit destructor calls and placement new operators to change the active member of a union. \u2014<em>end note</em> ] [<em>Example</em>: Consider an object <code>u</code> of a <code>union type U</code> having non-static data members m of type <code>M</code> and <code>n</code> of type <code>N</code>. If <code>M</code> has a non-trivial destructor and <code>N</code> has a non-trivial constructor (for instance, if they declare or inherit virtual functions), the active member of u can be safely switched from <code>m</code> to <code>n</code> using the destructor and placement new operator as follows:</p>\n<pre><code>u.m.~M();\nnew (&amp;u.n) N;\n</code></pre>\n<p id=\"so_31388208_31388208_2\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>So my guess is that the active member of an union is the one first asigned, used, constructed or placement-new'ed; but this becomes kind of tricky with uniform initialization, consider the following code:</p>\n<pre><code>union Foo\n{\n    struct {char a,b,c,d;};\n    char array[4];\n    int integer;\n};\n\nFoo f; // default ctor\nstd::cout &lt;&lt; f.a &lt;&lt; f.b &lt;&lt; f.c &lt;&lt; f.d &lt;&lt; '\\n';\n</code></pre>\n<p>Which is the active member of the union on the code above? Is <code>std::cout</code> reading from the active member of the union? What about the code below?</p>\n<pre><code>Foo f{0,1,2,3}; // uniform initialization\nstd::cout &lt;&lt; f.a &lt;&lt; f.b &lt;&lt; f.c &lt;&lt; f.d &lt;&lt; '\\n';\n</code></pre>\n<p>With the lines above we can initialize the nested anonymous struct or either the array, if I provide only an integer I can initialize <code>Foo::a</code> or <code>Foo::array</code> or <code>Foo::integer</code>... which one would be the active member?</p>\n<pre><code>Foo f{0}; // uniform initialization\nstd::cout &lt;&lt; f.integer &lt;&lt; '\\n';\n</code></pre>\n<p>I guess that the active member would be the aninymous struct in all of the above cases but I'm not sure.</p>\n<p>If I want to activate one or the other union member, should I provide a constructor activating it?</p>\n<pre><code>union Bar\n{\n    // #1 Activate anonymous struct\n    Bar(char x, char y, char z, char t) : a(x),b(y),c(z),d(t) {}\n    // #2 Activate array\n    Bar(char (&amp;a)[4]) { std::copy(std::begin(a), std::end(a), std::begin(array)); }\n    // #3 Activate integer\n    Bar(int i) : integer(i) {}\n\n    struct {char a,b,c,d;};\n    char array[4];\n    int integer;\n};\n</code></pre>\n<p>I'm almost sure that #1 and #3 will mark as active union the anonymous struct and the integer but I don't know about the #2 because in the moment we reach the body of the constructor the members are already constructed! so are we calling <code>std::copy</code> over an inactive union member?</p>\n<p>Questions:</p>\n<ul>\n<li>Which are the active union members of <code>Foo</code> if it is constructed with the following uniform initialization:\n\n<ul>\n<li><code>Foo{};</code></li>\n<li><code>Foo{1,2,3,4};</code></li>\n<li><code>Foo{1};</code></li>\n</ul></li>\n<li>In the #2 constructor of <code>Bar</code> the <code>Bar::array</code> is the active union member?</li>\n<li>Where in the standard can I read about which is exactly the active union member and how to set it without placement new?</li>\n</ul>\n", "Tags": "<c++><constructor><unions><uniform-initialization>", "OwnerUserId": "499359", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31388208_31388208_0": {"section_id": 5913, "quality": 0.9787234042553191, "length": 46}, "so_31388208_31390380_2": {"section_id": 435, "quality": 1.0, "length": 6}, "so_31388208_31390380_7": {"section_id": 435, "quality": 0.9130434782608695, "length": 21}, "so_31388208_31390380_5": {"section_id": 435, "quality": 1.0, "length": 8}, "so_31388208_31390380_8": {"section_id": 3312, "quality": 0.9285714285714286, "length": 13}, "so_31388208_31390380_1": {"section_id": 435, "quality": 1.0, "length": 17}, "so_31388208_31390380_11": {"section_id": 6185, "quality": 0.5714285714285714, "length": 8}, "so_31388208_31390380_3": {"section_id": 435, "quality": 0.9130434782608695, "length": 21}, "so_31388208_31388208_1": {"section_id": 5916, "quality": 0.8979591836734694, "length": 44}}, "n3337": {"so_31388208_31388208_0": {"section_id": 5685, "quality": 0.7872340425531915, "length": 37}, "so_31388208_31390380_2": {"section_id": 427, "quality": 0.8333333333333334, "length": 5}, "so_31388208_31390380_5": {"section_id": 427, "quality": 0.625, "length": 5}, "so_31388208_31390380_8": {"section_id": 3182, "quality": 0.9285714285714286, "length": 13}, "so_31388208_31390380_1": {"section_id": 427, "quality": 0.8235294117647058, "length": 14}, "so_31388208_31390380_11": {"section_id": 5946, "quality": 0.5714285714285714, "length": 8}, "so_31388208_31388208_1": {"section_id": 5688, "quality": 0.8979591836734694, "length": 44}}, "n4659": {"so_31388208_31388208_0": {"section_id": 7405, "quality": 0.5531914893617021, "length": 26}, "so_31388208_31390380_2": {"section_id": 382, "quality": 0.8333333333333334, "length": 5}, "so_31388208_31390380_11": {"section_id": 7404, "quality": 0.8571428571428571, "length": 12}, "so_31388208_31390380_5": {"section_id": 454, "quality": 1.0, "length": 8}, "so_31388208_31390380_8": {"section_id": 4078, "quality": 0.9285714285714286, "length": 13}, "so_31388208_31388208_1": {"section_id": 7409, "quality": 0.8163265306122449, "length": 40}, "so_31388208_31390380_7": {"section_id": 454, "quality": 0.9130434782608695, "length": 21}, "so_31388208_31390380_3": {"section_id": 454, "quality": 0.9130434782608695, "length": 21}, "so_31388208_31390380_1": {"section_id": 454, "quality": 1.0, "length": 17}}}});