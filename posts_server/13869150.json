post_cb({"19198730": {"ParentId": "13869150", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>concerning your question part 2</p>\n<p>here is a quote from standard c++11 concerning ADL $3.4.2:</p>\n<blockquote>\n<p id=\"so_13869150_19198730_0\">Let X be the lookup set produced by unqualified lookup (3.4.1) and let Y be the lookup set produced by argument dependent lookup (defined as follows). If X contains</p>\n<ul>\n<li>a declaration of a class member, or</li>\n<li>a block-scope function declaration that is not a using-declaration, or</li>\n<li>a declaration that is neither a function or a function template </li>\n</ul>\n<p id=\"so_13869150_19198730_1\">then Y is empty.</p>\n<p id=\"so_13869150_19198730_2\">...</p>\n</blockquote>\n<p>it seems, that answers your question</p>\n", "OwnerUserId": "1708247", "LastEditorUserId": "1708247", "LastEditDate": "2013-10-05T15:42:51.810", "Id": "19198730", "Score": "0", "CreationDate": "2013-10-05T14:13:32.933", "LastActivityDate": "2013-10-05T15:42:51.810"}, "13869150": {"CommentCount": "1", "AcceptedAnswerId": "13872036", "PostTypeId": "1", "LastEditorUserId": "1566221", "CreationDate": "2012-12-13T21:54:47.203", "LastActivityDate": "2013-10-05T15:42:51.810", "LastEditDate": "2012-12-14T00:46:55.253", "ViewCount": "454", "FavoriteCount": "2", "Title": "Rules for lookup of operators in C++11", "Id": "13869150", "Score": "15", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">N3337</a>, \"Working Draft, Standard for Programming Language C++,\" gives the following example in clause 13.3.1.2, p. 10:</p>\n<pre><code>struct A { };\nvoid operator + (A, A);\nstruct B {\n  void operator + (B);\n  void f ();\n};\nA a;\nvoid B::f() {\n  operator+ (a,a);   // error: global operator hidden by member\n  a + a;             // OK: calls global operator+\n}\n</code></pre>\n<p>However, this is just a note:</p>\n<blockquote>\n<p id=\"so_13869150_13869150_0\">Note: The lookup rules for operators in expressions are different than the lookup rules for operator function names in a function call, as shown in the following example:</p>\n</blockquote>\n<p>My question is where in the standard does it say that this is what has to happen as opposed to just having the note with an example?</p>\n<p>As far as I can tell, according to clause 13.3.1.2, p. 2, operator expressions are converted to operator function calls. So why and how should there be a difference in the example above?</p>\n<h2>Edit:</h2>\n<p>After looking into the problem, I think that I may have overlooked p. 3 and p.6 in the same clause that together state that global candidates and member candidates are considered equally when looking up operators (thus lookup rules are different as the note says). However, my inquiry into this subject was stemmed by this example that compiles in the same way with GCC 4.8 and Clang:</p>\n<pre><code>struct X {};  struct Y {};\n\nvoid operator+(X, X) { }\nvoid operator+(X, Y) { }\n\nvoid test() {\n  void operator+(X, X);\n  X x; Y y;\n\n  x + x;  // OK\n  x + y;  // OK\n\n  operator+(x, y);  // error\n  operator+(x, x);  // OK\n}\n</code></pre>\n<p>Why is there shadowing by the block scope declaration when the operator function is called directly but not when it is called by operator expression?</p>\n<p>Here are the errors from GCC:</p>\n<pre><code>operators-main-ss.cpp: In function \u2018void test()\u2019:\noperators-main-ss.cpp:13:17: error: could not convert \u2018y\u2019 from \u2018Y\u2019 to \u2018X\u2019\n   operator+(x, y);  // error\n                 ^\n</code></pre>\n<p>And here from Clang:</p>\n<pre><code>operators-main-ss.cpp:13:16: error: no viable conversion from 'Y' to 'X'\n  operator+(x, y);  // error\n               ^\noperators-main-ss.cpp:1:8: note: candidate constructor (the implicit copy constructor) not viable: no\n      known conversion from 'Y' to 'const X &amp;' for 1st argument;\nstruct X {};  struct Y {};\n       ^\noperators-main-ss.cpp:7:22: note: passing argument to parameter here\n  void operator+(X, X);\n                     ^\n</code></pre>\n<p>Are the compilers correct to have the block declaration shadow the global name in one case but not the other?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "594274", "AnswerCount": "3"}, "13872036": {"ParentId": "13869150", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_13869150_13872036_0\">Are the compilers correct to have the block declaration shadow the\n  global name in one case but not the other?</p>\n</blockquote>\n<p>I have come to the conclusion that both compilers are wrong. I believe <code>x + y;</code> should also fail. 13.3.1.2p3 states it clearly:</p>\n<blockquote>\n<p id=\"so_13869150_13872036_1\">The set of non-member candidates is the result of the unqualified\n  lookup of operator@ in the context of the expression according to the\n  usual rules for name lookup in unqualified function calls (3.4.2)\n  except that all member functions are ignored.</p>\n</blockquote>\n<p>As a result, there should be no difference between <code>x + y;</code> and <code>operator+(x, y);</code> in your example. <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow\">Commeau online</a> produces the following errors with the code:</p>\n<pre><code>\"ComeauTest.c\", line 11: error: no operator \"+\" matches these operands\n            operand types are: X + Y\n    x + y;  // OK\n      ^\n\"ComeauTest.c\", line 13: error: no suitable user-defined conversion from \"Y\"\n to \"X\"\n          exists\n    operator+(x, y);  // error\n</code></pre>\n", "OwnerUserId": "906773", "PostTypeId": "2", "Id": "13872036", "Score": "1", "CreationDate": "2012-12-14T03:01:20.200", "LastActivityDate": "2012-12-14T03:01:20.200"}, "bq_ids": {"n4140": {"so_13869150_13872036_1": {"section_id": 584, "quality": 0.9166666666666666, "length": 22}, "so_13869150_13869150_0": {"section_id": 591, "quality": 0.8888888888888888, "length": 16}, "so_13869150_19198730_0": {"section_id": 7105, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_13869150_13872036_1": {"section_id": 574, "quality": 0.9166666666666666, "length": 22}, "so_13869150_13869150_0": {"section_id": 581, "quality": 0.8888888888888888, "length": 16}, "so_13869150_19198730_0": {"section_id": 6849, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_13869150_13872036_1": {"section_id": 607, "quality": 0.9166666666666666, "length": 22}, "so_13869150_13869150_0": {"section_id": 614, "quality": 0.8888888888888888, "length": 16}, "so_13869150_19198730_0": {"section_id": 8606, "quality": 0.9411764705882353, "length": 16}}}, "13871570": {"ParentId": "13869150", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Your original question:</p>\n<p>Your conclusion is correct.</p>\n<p><code>operator+(a, a);</code> is a simple function call so the compiler searches for potential matches in the standard order, finds the member function and never looks any further. The member function doesn't match and the expression is ill formed.</p>\n<p><code>a + a;</code> uses a slightly different set of rules as defined in 13.3.1.2 p3. First a set of possible overloads is produced from <code>A::operator+(a)</code>. Then a list of possible overloads is produced from a standard unqualified lookup but member functions are ignored. A list of builtin operators is then created. These 3 lists are then used to decide the best match. Normally, unqualified lookup would stop after the first step if it found something which is why this works where it would normally fail.</p>\n<p>Question part 2:</p>\n<p>In theory this should be the same. No member functions involved and builtin operators are irrelevant so they should all result in a standard unqualified lookup. I can't find anything in the standard to suggest they should be in any way different. I don't see much mention of block scope function declarations in the standard aside from \"they exist\". They are mostly just a relic of C after all. I also don't see any specific rules in the standard that state one way or the other about whether this should work or not. The standard does suggest very strongly that <code>x + y</code> and <code>operator+(x, y)</code> should either both work or both fail since they both use the same method for name lookup.</p>\n<p>I also have yet to find a valid use case for nested function declarations.</p>\n", "OwnerUserId": "365460", "LastEditorUserId": "365460", "LastEditDate": "2012-12-14T23:29:22.603", "Id": "13871570", "Score": "4", "CreationDate": "2012-12-14T01:53:31.823", "LastActivityDate": "2012-12-14T23:29:22.603"}});