post_cb({"20870233": {"ViewCount": "1206", "Body": "<p>When computing constant expressions to initialize a <code>constexpr</code> it is possible to throw exceptions. For example here is an example where the computation of a constant expression is guarded against overflow:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nconstexpr int g(int n, int n0, int n1) {\n    return n == 0? n1: g(n - 1, n1, n0 + n1);\n}\n\nconstexpr int f(int n) {\n    return n &lt; 42? g(n, 0, 1): throw std::out_of_range(\"too big\");\n}\n\nint main()\n{\n    try {\n        constexpr int f41 = f(41); // OK: constexpr\n        int           f43 = f(43); // OK: throws an exception\n        constexpr int f42 = f(42); // not OK but what happens?\n    }\n    catch (std::exception const&amp; ex) {\n        std::cout &lt;&lt; \"ERROR: \" &lt;&lt; ex.what() &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>\n<p>The first call to <code>f()</code> just shows that a <code>constexpr</code> can be computed. The second call to <code>f()</code> isn't used to initialize a <code>constexpr</code> and throws a run-time exception. The third call to <code>f()</code> is used to initialize a <code>constexpr</code> but that point won't ever reached because an exception is thrown. However, what should happen in this case? I would expect the handler in the <code>catch</code>-clause is executed but both <a href=\"http://gcc.gnu.org/\">gcc</a> and <a href=\"http://clang.llvm.org/\">clang</a> produce a compile-time error.</p>\n", "AcceptedAnswerId": "20870343", "Title": "What happens when an exception is thrown while computing a constexpr?", "CreationDate": "2014-01-01T15:40:31.943", "Id": "20870233", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-01-01T16:24:30.157", "Score": "13", "OwnerUserId": "1120273", "Tags": "<c++><exception><c++11><language-lawyer><constexpr>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20870233_20870343_0": {"length": 28, "quality": 1.0, "section_id": 5425}, "so_20870233_20870343_1": {"length": 8, "quality": 0.5333333333333333, "section_id": 6185}}, "n3337": {"so_20870233_20870343_0": {"length": 28, "quality": 1.0, "section_id": 5220}, "so_20870233_20870343_6": {"length": 37, "quality": 0.9736842105263158, "section_id": 5216}, "so_20870233_20870343_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 5946}, "so_20870233_20870343_1": {"length": 15, "quality": 1.0, "section_id": 5946}}, "n4659": {"so_20870233_20870343_0": {"length": 18, "quality": 0.6428571428571429, "section_id": 6847}, "so_20870233_20870343_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 7687}}}, "20870343": {"Id": "20870343", "PostTypeId": "2", "Body": "<p>The initialiser for a <code>constexpr</code> variable must be a constant expression (C++11 \u00a77.1.5/9):</p>\n<blockquote>\n<p id=\"so_20870233_20870343_0\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have literal type and shall be initialized. If it is initialized by a constructor call, [...]. Otherwise, or if a <code>constexpr</code> specifier is used in a reference declaration, every full-expression that appears in its initializer shall be a constant expression.</p>\n</blockquote>\n<p>Note the following requirements for a constant expression (\u00a75.19/2):</p>\n<blockquote>\n<p id=\"so_20870233_20870343_1\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it involves one of the following as a potentially evaluated subexpression, but subexpressions of [...] conditional operations that are not evaluated are not considered</p>\n<ul>\n<li><p id=\"so_20870233_20870343_2\">[...]</p></li>\n<li><p id=\"so_20870233_20870343_3\">an invocation of a <code>constexpr</code> function with arguments that, when substituted by function invocation substitution (7.1.5), do not produce a constant expression;</p></li>\n<li><p id=\"so_20870233_20870343_4\">[...]</p></li>\n<li><p id=\"so_20870233_20870343_5\">a <em>throw-expression</em> (15.1).</p></li>\n</ul>\n</blockquote>\n<p>Function invocation substitution for a <code>constexpr</code> function is defined as follows (\u00a77.1.5/5):</p>\n<blockquote>\n<p id=\"so_20870233_20870343_6\"><em>Function invocation substitution</em> for a call of a <code>constexpr</code> function [...] means implicitly converting each argument to the corresponding parameter type as if by copy-initialization, substituting that converted expression for each use of the corresponding parameter in the <em>function-body</em>, and [...] implicitly converting the resulting returned expression or <em>braced-init-list</em> to the return type of the function as if by copy-initialization. Such substitution does not change the meaning.</p>\n</blockquote>\n<p>As we saw above (\u00a75.19/2), subexpressions of conditional operations that are not evaluated are not considered. <code>f(42)</code> is not a constant expression because when you perform function invocation substitution on <code>f</code>, it results in an expression with a <code>throw</code> expression on the side of the conditional operation that is evaluated. On the other hand, for <code>f(41)</code>, the <code>throw</code> ends up on the side that <em>isn't</em> evaluated.</p>\n<p>So the program is ill-formed. It doesn't matter whether the initialiser is actually reached or not because the program shouldn't compile.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2014-01-01T16:24:30.157", "Score": "11", "CreationDate": "2014-01-01T15:53:14.937", "ParentId": "20870233", "CommentCount": "3", "OwnerUserId": "150634", "LastEditDate": "2014-01-01T16:24:30.157"}});