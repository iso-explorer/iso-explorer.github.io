post_cb({"bq_ids": {"n4140": {"so_24501388_24503971_0": {"length": 18, "quality": 1.0, "section_id": 134}}, "n3337": {"so_24501388_24503971_0": {"length": 18, "quality": 1.0, "section_id": 128}}, "n4659": {"so_24501388_24503971_0": {"length": 18, "quality": 1.0, "section_id": 138}}}, "24501388": {"ViewCount": "151", "Body": "<p>I get a compiler error in clang++. MSVC++ is happy. I believe my declarations are correct.</p>\n<p>Am I incorrect in my beliefs and I am \"lucky\" in MSVC?\nIs there a non <code>#ifndef _MSC_VER ... public:</code> way to make this work in both compilers?</p>\n<p>I'd like to keep the constructor private. The real code is slightly more complex. (additional template meta-programming and \"perfect forwarding\") The following is a distilled version for the question and to isolate the issue as much as possible. I've tried a number of variations for the friend declaration. The one that \"seems best\" is shown in the example.</p>\n<pre><code>#include&lt;type_traits&gt;\n\ntemplate&lt;typename T&gt; class Wrap;\n\ntemplate&lt;typename T, \n    typename std::enable_if&lt;std::is_class&lt;T&gt;::value, T&gt;::type* = nullptr &gt;\nWrap&lt;T&gt; make_wrapper( T i )\n{\n    return Wrap&lt;T&gt;( i );\n}\n\ntemplate&lt;typename T&gt;\nclass Wrap : T\n{\n    friend Wrap&lt;T&gt; make_wrapper&lt;T,nullptr&gt;( T );\nprivate:\n    Wrap( T v ) : T( v ) {}\n};\n\ntemplate&lt;typename T&gt;\nclass Imp\n{\n    T x;\npublic:\n    Imp( T v ) {}\n};\n\nint main()\n{\n    auto wrap = make_wrapper( Imp&lt;int&gt;( 1 ) );\n    return 0;\n}\n</code></pre>\n<p>clang++:</p>\n<pre><code>$ clang++ --version\nDebian clang version 3.5-1~exp1 (trunk) (based on LLVM 3.5)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n\n$ clang++ -std=c++11 test.cpp\ntest.cpp:8 : 12 : error : calling a private constructor of class 'Wrap&lt;Imp&lt;int&gt; &gt;'\nreturn Wrap&lt;T&gt;( i );\n^\ntest.cpp:30 : 17 : note : in instantiation of function template specialization 'make_wrapper&lt;Imp&lt;int&gt;, nullptr&gt;' requested here\nauto wrap = make_wrapper( Imp&lt;int&gt;( 1 ) );\n^\ntest.cpp:16 : 5 : note : declared private here\nWrap( T v ) : T( v ) { }\n^\n1 error generated.\n</code></pre>\n<p>cl</p>\n<pre><code>Microsoft Visual Studio Professional 2013\nVersion 12.0.30501.00 Update 2\n\n1&gt;------ Build started: Project: Test1, Configuration: Debug Win32 ------\n1&gt;  Test1.cpp\n1&gt;  Test1.vcxproj -&gt; C:\\cygwin64\\home\\username\\Test1\\Debug\\Test1.exe\n========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========\n</code></pre>\n", "AcceptedAnswerId": "24503971", "Title": "Issue with friend template functions clang++ / msvc++ and enable_if", "CreationDate": "2014-07-01T01:48:57.133", "Id": "24501388", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-07-01T06:46:08.180", "Score": "2", "OwnerUserId": "1855568", "Tags": "<templates><visual-c++><c++11><friend><clang++>", "AnswerCount": "1"}, "24503971": {"Id": "24503971", "PostTypeId": "2", "Body": "<p>Template friends are <a href=\"http://www.drdobbs.com/befriending-templates/184403853\" rel=\"nofollow\"><strong>notoriously complicated</strong></a>. I don't know for sure whether Clang is right, but it could be that your SFINAE trick inside the function template arguments runs afoul of </p>\n<p><strong>14.5.4 Friends [temp.friend]</strong></p>\n<blockquote>\n<p id=\"so_24501388_24503971_0\">9 When a friend declaration refers to a specialization of a function\n  template, the function parameter declarations <strong>shall not include\n  default arguments</strong>, nor shall the inline specifier be used in such a\n  declaration.</p>\n</blockquote>\n<p>C++11 introduced default template arguments for function templates, and it could be that clang interprets the above differently as g++/MSVC. It is fixable by doing SFINAE on the return type instead:</p>\n<pre><code>#include&lt;type_traits&gt;\n\ntemplate&lt;typename T&gt; class Wrap;\n\ntemplate&lt;typename T&gt;\nusing WrapRet = typename std::enable_if&lt;std::is_class&lt;T&gt;::value, Wrap&lt;T&gt;&gt;::type;\n\ntemplate&lt;typename T&gt;\nWrapRet&lt;T&gt; make_wrapper( T i )\n{\n    return Wrap&lt;T&gt;( i );\n}\n\ntemplate&lt;typename T&gt;\nclass Wrap : T\n{\n    friend WrapRet&lt;T&gt; make_wrapper&lt;T&gt;( T );\nprivate:\n    Wrap( T v ) : T( v ) {}\n};\n\ntemplate&lt;typename T&gt;\nclass Imp\n{\n    T x;\npublic:\n    Imp( T v ) {}\n};\n\nint main()\n{\n    auto wrap = make_wrapper( Imp&lt;int&gt;( 1 ) );\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/979241d26bfe678f\" rel=\"nofollow\"><strong>Live Example</strong></a> that works with both clang and g++.</p>\n", "LastActivityDate": "2014-07-01T06:46:08.180", "CommentCount": "5", "CreationDate": "2014-07-01T06:46:08.180", "ParentId": "24501388", "Score": "1", "OwnerUserId": "819272"}});