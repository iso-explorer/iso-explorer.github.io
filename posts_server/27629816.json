post_cb({"bq_ids": {"n4140": {"so_27629816_27630346_4": {"length": 11, "quality": 1.0, "section_id": 5770}, "so_27629816_27630346_5": {"length": 33, "quality": 0.9705882352941176, "section_id": 5776}, "so_27629816_27630346_2": {"length": 16, "quality": 1.0, "section_id": 5457}}, "n3337": {"so_27629816_27630346_5": {"length": 33, "quality": 0.9705882352941176, "section_id": 5549}, "so_27629816_27630346_4": {"length": 11, "quality": 1.0, "section_id": 5543}}, "n4659": {"so_27629816_27630346_5": {"length": 33, "quality": 0.9705882352941176, "section_id": 7233}, "so_27629816_27630346_4": {"length": 11, "quality": 1.0, "section_id": 7227}, "so_27629816_27630346_2": {"length": 16, "quality": 1.0, "section_id": 6883}}}, "27630346": {"Id": "27630346", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27629816_27630346_0\">1). Is the code below valid C++ with respect to the C++14 standard?</p>\n</blockquote>\n<p>Yes, as far as I can tell. It's sometimes a bit hard to prove, since often there's simply nothing forbidding it. However, we can look at an example in a recent draft (post-N4296), [dcl.spec.auto]/13:</p>\n<blockquote id=\"so_27629816_27630346_1\">\n<pre><code>template &lt;typename T&gt; auto g(T t) { return t; } // #1\ntemplate auto g(int);                           // OK, return type is int\ntemplate char g(char);                          // error, no matching template\ntemplate&lt;&gt; auto g(double);                      // OK, forward declaration with\n                                                // unknown return type\n</code></pre>\n</blockquote>\n<p>The same paragraph specifies:</p>\n<blockquote>\n<p id=\"so_27629816_27630346_2\">Redeclarations or specializations of a function or function template with a declared return type that uses a placeholder type shall also use that placeholder, not a deduced type.</p>\n</blockquote>\n<p>So the explicit specializations of a function template <em>must</em> use return type deduction.\nI cannot find anything that forbids different return types for different specializations. Similarly, in C++98, different return types for function template specializations (of the same primary template) can be achieved by making the return type dependent on the template arguments. By using metaprogramming, you can basically achieve the same as when using return type deduction to specify unrelated return types for the different specializations.</p>\n<hr>\n<blockquote>\n<p id=\"so_27629816_27630346_3\">3). Why does the code below seem to compile and work (sometimes) using C++11 compilers? </p>\n</blockquote>\n<p>The code in the OP is ill-formed in C++11. Return type deduction for ordinary functions (non-lamdas) is a feature introduced in C++14. A program that contains this code snippet is <em>ill-formed</em>. However, the Standard does not mandate that implementations (compilers) must reject ill-formed programs. It merely states in [intro.compliance]/2.2:</p>\n<blockquote>\n<p id=\"so_27629816_27630346_4\">If a program contains a violation of any diagnosable rule [...] a conforming implementation shall issue at least one diagnostic message.</p>\n</blockquote>\n<p>and in /8</p>\n<blockquote>\n<p id=\"so_27629816_27630346_5\">A conforming implementation may have extensions (including additional library functions), provided they do not alter the behavior of any well-formed program. Implementations are required to diagnose programs that use such extensions that are ill-formed according to this International Standard. Having done so, however, they can compile and execute such programs.</p>\n</blockquote>\n<p>(So implementations can accept this program <em>as an extension</em>.)</p>\n<p>g++4.8.3 issues a warning, which counts as a diagnostic message. g++4.9 issues an error, which is also a diagnostic message. Both are compliant. By specifying <code>-Werror</code>, you could tell a g++4.8.3 to reject this program. (You'd have to ask the gcc developers why they've changed that from a warning to an error.)</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2014-12-24T01:37:09.143", "Score": "6", "CreationDate": "2014-12-24T01:31:18.283", "ParentId": "27629816", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2014-12-24T01:37:09.143"}, "27629816": {"ViewCount": "300", "Body": "<p>This is a follow up on this question: <a href=\"https://stackoverflow.com/questions/27629039/c-explicit-return-type-template-specialisation\">previous question</a>.</p>\n<p>I repeat the code from the previous question just to make this question self-contained. The code below compiles and does not issue any warnings if compiled using gcc 4.8.3. with <code>-std=c++1y</code>. However, it does issue warnings if compiled with <code>-std=c++0x</code> flag. In the context of the previous question it was pointed out (see comments) that the code does not compile using gcc 4.9.0. Coming from high level programming (engineering/science) background, I have to admit that, at present, I do not fully understand the mechanics behind the implementation of <code>auto</code>. Thus, I would appreciate if anyone could answer the following questions:</p>\n<p>1). Is the code below valid C++ with respect to the C++14 standard?</p>\n<p>2). If yes, would this code be considered a good style? If not, why not?</p>\n<p>3). Why does the code below seem to compile and work (sometimes) using C++11 compilers? Alternatively, why does it not always work? Are there any specific flags/options/settings/os settings that could prevent it from working?</p>\n<pre><code>template&lt;int N&gt; auto getOutputPort2();\ntemplate&lt;&gt; auto getOutputPort2&lt;0&gt;();\ntemplate&lt;&gt; auto getOutputPort2&lt;1&gt;();\n\ntemplate&lt;&gt;\nauto getOutputPort2&lt;0&gt;()\n{\n    return std::unique_ptr&lt;int&gt;(new int(10));\n}\n\ntemplate&lt;&gt;\nauto getOutputPort2&lt;1&gt;()\n{\n    return std::unique_ptr&lt;string&gt;(new string(\"qwerty\"));\n}\n</code></pre>\n", "AcceptedAnswerId": "27630346", "Title": "Is it valid to do explicit template specialisation with auto return 'type' in C++14?", "CreationDate": "2014-12-24T00:06:06.307", "Id": "27629816", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-09-05T19:28:40.797", "LastEditorUserId": "1391279", "LastActivityDate": "2017-09-05T19:28:40.797", "Score": "4", "OwnerUserId": "1391279", "Tags": "<c++><c++11><auto><c++14><explicit-specialization>", "AnswerCount": "1"}});