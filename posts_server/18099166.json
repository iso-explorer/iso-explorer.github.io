post_cb({"18100355": {"ParentId": "18099166", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>First of all, the basic premise of your <code>friend</code> declaration is sound:</p>\n<blockquote>\n<p id=\"so_18099166_18100355_0\"><code>[C++11: 14.5.4/1]:</code> A friend of a class or class template can be a function template or class template, a specialization of a function template or class template, or an ordinary (non-template) function or class. For a friend function declaration that is not a template declaration:</p>\n<ul>\n<li><strong>if the name of the friend is a qualified or unqualified <em>template-id</em>, the friend declaration refers to a specialization of a function template</strong>, otherwise</li>\n<li>if the name of the friend is a <em>qualified-id</em> and a matching non-template function is found in the specified class or namespace, the friend declaration refers to that function, otherwise,</li>\n<li>if the name of the friend is a <em>qualified-id</em> and a matching function template is found in the specified class or namespace, the friend declaration refers to the deduced specialization of that function template (14.8.2.6), otherwise,</li>\n<li>the name shall be an <em>unqualified-id</em> that declares (or redeclares) an ordinary (non-template) function.</li>\n</ul>\n<p id=\"so_18099166_18100355_1\"><em>[ Example:</em></p>\n<pre><code>template&lt;class T&gt; class task;\ntemplate&lt;class T&gt; task&lt;T&gt;* preempt(task&lt;T&gt;*);\ntemplate&lt;class T&gt; class task {\nfriend void next_time();\nfriend void process(task&lt;T&gt;*);\nfriend task&lt;T&gt;* preempt&lt;T&gt;(task&lt;T&gt;*);\ntemplate&lt;class C&gt; friend int func(C);\nfriend class task&lt;int&gt;;\ntemplate&lt;class P&gt; friend class frd;\n};\n</code></pre>\n<p id=\"so_18099166_18100355_2\"><em>[..] \u2014end example ]</em></p>\n</blockquote>\n<p>You can run into problems because the name <code>overloadedMethod</code> from the base class <em>hides</em> the global one \u2014 irrespective of the different argument list, and the fact that the base name does not represent a template:</p>\n<blockquote>\n<p id=\"so_18099166_18100355_3\"><code>[C++11: 3.4.1/9]:</code> Name lookup for a name used in the definition of a friend function (11.3) defined inline in the class granting friendship shall proceed as described for lookup in member function definitions. <strong>If the friend function is not defined in the class granting friendship, name lookup in the friend function definition shall proceed as\n  described for lookup in namespace member function definitions.</strong></p>\n<p id=\"so_18099166_18100355_4\"><code>[C++11: 3.4.1/10]:</code> <strong>In a <code>friend</code> declaration naming a member function, a name used in the function declarator and not part of a <em>template-argument</em> in the <em>declarator-id</em> is first looked up in the scope of the member function\u2019s class</strong> (10.2). If it is not found, or if the name is part of a <em>template-argument</em> in the <em>declarator-id</em>, the look up is as described for unqualified names in the definition of the class granting friendship.</p>\n</blockquote>\n<p>The \"if it is not found\" clause can never be triggered in this case.</p>\n<p>In GCC 4.8.1 <a href=\"http://ideone.com/k5Ygaq\" rel=\"nofollow\">this results in the following diagnostic</a>:</p>\n<blockquote>\n<p id=\"so_18099166_18100355_5\">error: field \u2018overloadedMethod\u2019 has incomplete type</p>\n</blockquote>\n<p>I'm sure that the specific contents of this diagnostic are slightly erroneous \u2014 you've basically confused the heck out of your compiler, by applying the <em>template-parameter-list</em> <code>&lt;A&gt;</code> to something that it does not believe is a template.</p>\n<p>You cannot fix this, <a href=\"http://ideone.com/bVAZee\" rel=\"nofollow\">even by qualifying the <code>friend</code> declaration</a>:</p>\n<pre><code>friend const A ::overloadedMethod&lt;A&gt;(const A&amp; lhs, const A&amp; rhs);\n</code></pre>\n<p>The following does work:</p>\n<pre><code>friend auto ::overloadedMethod&lt;A&gt;(const A&amp;, const A&amp;) -&gt; const A;\n</code></pre>\n<p>But I think that this is actually a compiler bug, based on the above rules.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-08-07T10:08:18.750", "Id": "18100355", "Score": "4", "CreationDate": "2013-08-07T09:58:37.973", "LastActivityDate": "2013-08-07T10:08:18.750"}, "bq_ids": {"n4140": {"so_18099166_18100355_4": {"section_id": 7096, "quality": 0.9090909090909091, "length": 30}, "so_18099166_18100355_0": {"section_id": 126, "quality": 0.8461538461538461, "length": 22}, "so_18099166_18100355_3": {"section_id": 7095, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_18099166_18100355_4": {"section_id": 6840, "quality": 0.9090909090909091, "length": 30}, "so_18099166_18100355_0": {"section_id": 120, "quality": 0.8846153846153846, "length": 23}, "so_18099166_18100355_3": {"section_id": 6839, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_18099166_18100355_4": {"section_id": 8597, "quality": 0.9090909090909091, "length": 30}, "so_18099166_18100355_0": {"section_id": 131, "quality": 0.8461538461538461, "length": 22}, "so_18099166_18100355_3": {"section_id": 8596, "quality": 0.9210526315789473, "length": 35}}}, "18099166": {"CommentCount": "9", "AcceptedAnswerId": "18100355", "CreationDate": "2013-08-07T09:06:48.403", "LastActivityDate": "2013-08-07T10:08:18.750", "PostTypeId": "1", "ViewCount": "248", "FavoriteCount": "1", "Title": "Most Vexing Friend ? Friend-ing a specialized free-function template raises compilation error (when overloading a method)", "Id": "18099166", "Score": "4", "Body": "<h2>Code</h2>\n<p>I reduced the problem to this example (pasted as a single block for ease of compilation)</p>\n<pre><code>/// \\brief The free-function template,\n/// which is overloading a method with the same name in AbstractA below.\ntemplate &lt;class T&gt;\ninline const T overloadedMethod(const T&amp; lhs, const T&amp; rhs)\n{\n    return T(lhs.value+rhs.value);\n}\n\n/// \\brief AbstractA class\nclass AbstractA\n{\npublic:\n    AbstractA (int aVal):\n      value(aVal)\n      {}\n\n\n      inline const AbstractA overloadedMethod(const AbstractA &amp;rhs) const\n      {\n          return AbstractA(value+rhs.value);            \n      }\n\nprotected:\n    int value;\n};\n\n/// \\brief A class, deriving from AbstractA,\n/// and friending the free-function template.\nclass A : public AbstractA\n{   \n    friend const A overloadedMethod &lt;A&gt;(const A&amp; lhs, const A&amp; rhs);\n        /// This one gives me compilation error\n    //template&lt;class T&gt; friend const T overloadedMethod(const T&amp; lhs, const T&amp; rhs);\n        /// This one would be okay\n\npublic:\n    A (int aVal):\n      AbstractA(aVal)\n      {}\n};\n\nint main()\n{\n   A a1(1), a2(2);\n   overloadedMethod(a1, a2);\n\n   return 0;\n}\n</code></pre>\n<h2>Details</h2>\n<p>Basically, the compilers I tried (VS 2010 and G++ 4.7.2) give me an error on the line</p>\n<pre><code>friend const A overloadedMethod &lt;A&gt;(const A&amp; lhs, const A&amp; rhs);\n</code></pre>\n<p>They seem to think I am declaring a data member named <em>overloadedMethod</em>.</p>\n<p>The compilation error is not raised if :</p>\n<ul>\n<li>I give the non-specialized version of the free-function template as a friend (commented line of code)</li>\n<li>I remove the member function <strong>overloadedMethod()</strong> from class <strong>AbstractA</strong></li>\n</ul>\n<h2>Questions</h2>\n<p>I am not able to explain this behavior of the langage, so my questions would be :</p>\n<ul>\n<li>What is the C++ rule that is leading to this error ? (Why would compilers think I am declaring a data member here ?)</li>\n<li>Do you know a rationale behind it ? (I am especially curious to know why it seems to be working if I remove the <strong>overloadedMethod()</strong> from class <strong>AbstractA</strong>. Or is it an UB ?)</li>\n</ul>\n", "Tags": "<c++><templates><friend>", "OwnerUserId": "1027706", "AnswerCount": "1"}});