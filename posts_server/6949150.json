post_cb({"bq_ids": {"n4140": {"so_6949150_6949202_0": {"section_id": 5361, "quality": 0.875, "length": 14}, "so_6949150_6949288_0": {"section_id": 5356, "quality": 0.6666666666666666, "length": 20}}, "n3337": {"so_6949150_6949202_0": {"section_id": 5157, "quality": 0.875, "length": 14}, "so_6949150_6949288_0": {"section_id": 5153, "quality": 0.6666666666666666, "length": 20}}, "n4659": {"so_6949150_6949202_0": {"section_id": 6789, "quality": 0.875, "length": 14}, "so_6949150_6949288_0": {"section_id": 6781, "quality": 0.6666666666666666, "length": 20}}}, "6949215": {"ParentId": "6949150", "CommentCount": "0", "Body": "<p>This gets created in the code segment:</p>\n<pre><code>char *a = \"abcde\";\n</code></pre>\n<p>Essentially it's const.</p>\n<p>If you wish to edit it, try:</p>\n<pre><code>char a[] = \"abcde\";\n</code></pre>\n", "OwnerUserId": "839436", "PostTypeId": "2", "Id": "6949215", "Score": "3", "CreationDate": "2011-08-04T22:11:32.073", "LastActivityDate": "2011-08-04T22:11:32.073"}, "6949187": {"ParentId": "6949150", "CommentCount": "0", "Body": "<p>Even though <code>\"abcde\"</code> is a string literal, which should not be modified, you've told the compiler that you don't care about that by having a non-const <code>char*</code> point to it.</p>\n<p>The compiler will happily assume that you know what you're doing, and not throw an error. However, there's a good chance that the code will fail at runtime when you do indeed try to modify the string literal.</p>\n", "OwnerUserId": "822669", "PostTypeId": "2", "Id": "6949187", "Score": "0", "CreationDate": "2011-08-04T22:09:52.853", "LastActivityDate": "2011-08-04T22:09:52.853"}, "6949150": {"CommentCount": "1", "ViewCount": "1246", "PostTypeId": "1", "LastEditorUserId": "15168", "CreationDate": "2011-08-04T22:05:35.783", "LastActivityDate": "2014-09-02T04:02:38.653", "Title": "Why a segmentation fault for changing a non-const char*?", "AcceptedAnswerId": "6949288", "LastEditDate": "2011-08-04T22:19:14.823", "Id": "6949150", "Score": "2", "Body": "<p>With this code, I get a segmentation fault:</p>\n<pre><code>   char* inputStr = \"abcde\";\n   *(inputStr+1)='f';\n</code></pre>\n<p>If the code was:</p>\n<pre><code>   const char* inputStr = \"abcde\";\n   *(inputStr+1)='f';\n</code></pre>\n<p>I will get compile error for \"assigning read-only location\".\nHowever, for the first case, there is no compile error; just the segmentation fault when the assign operation actually happened.</p>\n<p>Can anyone explain this?</p>\n", "Tags": "<c++><pointers><char><const>", "OwnerUserId": "196975", "AnswerCount": "9"}, "6949288": {"ParentId": "6949150", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-08-04T22:19:24.513", "Score": "5", "LastEditorUserId": "252000", "LastEditDate": "2011-08-05T07:50:06.407", "Id": "6949288", "OwnerUserId": "671858", "Body": "<p>Here is what the standard says about string literals in section [2.13.4/2]:</p>\n<blockquote>\n<p id=\"so_6949150_6949288_0\">A string literal that does not begin with u, U, or L is an ordinary string literal, also referred to as a narrow string literal. An ordinary string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below; it has static storage duration (3.7) and is initialized with the given characters.</p>\n</blockquote>\n<p>So, strictly speaking, \"abcde\" has type </p>\n<pre><code>const char[6]\n</code></pre>\n<p>Now what happens in your code is an implicit cast to </p>\n<pre><code>char*\n</code></pre>\n<p>so that the assignment is allowed. The reason why it is so is, likely, compatibility with C. Have a look also at the discussion here: <a href=\"http://learningcppisfun.blogspot.com/2009/07/string-literals-in-c.html\" rel=\"nofollow\">http://learningcppisfun.blogspot.com/2009/07/string-literals-in-c.html</a></p>\n<p>Once the cast is done, you are syntactically free to modify the literal, but it fails because the compiler stores the literal in a non writable segment of memory, as the standard itself allow.</p>\n", "LastActivityDate": "2011-08-05T07:50:06.407"}, "6949208": {"ParentId": "6949150", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-08-04T22:10:58.760", "Score": "1", "LastEditorUserId": "774499", "LastEditDate": "2011-08-04T22:17:57.547", "Id": "6949208", "OwnerUserId": "774499", "Body": "<p>What happened is that the compiler put the constant <code>\"abcde\"</code> in some read-only memory segment. You pointed your (non-const) <code>char* inputStr</code> at that constant, and kaboom, segfault.</p>\n<p>Lesson to be learned: Don't invoke undefined behavior.</p>\n<p><strong>Edit (elaboration)</strong> </p>\n<blockquote>\n<p id=\"so_6949150_6949208_0\">However, for the first case, there is no compile error, just segmentation fault when the assign operation actually happened.</p>\n</blockquote>\n<p>You need to enabled your compiler warnings. Always set your compiler warnings as high as possible.</p>\n", "LastActivityDate": "2011-08-04T22:17:57.547"}, "6949209": {"ParentId": "6949150", "CommentCount": "0", "Body": "<p>String literals, while officially non-const, are almost always stored in read-only memory. In your setup, this is apparently only the case if it is declared as const char array.</p>\n<p>Note that the standard forbids you to modify any string literal.</p>\n", "OwnerUserId": "95954", "PostTypeId": "2", "Id": "6949209", "Score": "0", "CreationDate": "2011-08-04T22:11:10.263", "LastActivityDate": "2011-08-04T22:11:10.263"}, "6949197": {"ParentId": "6949150", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-08-04T22:10:11.937", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:19:50.857", "Id": "6949197", "OwnerUserId": "198164", "Body": "<p>String literals are typically stored in read-only memory. Trying to change this memory will kill your program.</p>\n<p>Here's a good explanation: <a href=\"https://stackoverflow.com/questions/349025/is-a-string-literal-in-c-created-in-static-memory/349030#349030\">Is a string literal in c++ created in static memory?</a></p>\n", "LastActivityDate": "2011-08-04T22:10:11.937"}, "6949206": {"ParentId": "6949150", "CommentCount": "0", "Body": "<p>It is mostly ancient history; once upon a long time ago, string literals were not constant.</p>\n<p>However, most modern compilers place string literals into read-only memory (typically, the text segment of your program, where your code also lives), and any attempt to change a string literal will yield a core dump or equivalent.</p>\n<p>With G++, you can most certainly get the compilation warning (<code>-Wall</code> if it is not enabled by default).  For example, G++ 4.6.0 compiled on MacOS X 10.6.7 (but running on 10.7) yields:</p>\n<pre><code>$ cat xx.cpp\nint main()\n{\n    char* inputStr = \"abcde\";\n   *(inputStr+1)='f';\n}\n$ g++ -c xx.cpp\nxx.cpp: In function \u2018int main()\u2019:\nxx.cpp:3:22: warning: deprecated conversion from string constant to \u2018char*\u2019 [-Wwrite-strings]\n$\n</code></pre>\n<p>So the warning is enabled by default.</p>\n", "OwnerUserId": "15168", "PostTypeId": "2", "Id": "6949206", "Score": "1", "CreationDate": "2011-08-04T22:10:47.680", "LastActivityDate": "2011-08-04T22:10:47.680"}, "6949202": {"ParentId": "6949150", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-08-04T22:10:26.053", "Score": "2", "LastEditorUserId": "14860", "LastEditDate": "2011-08-04T22:29:03.003", "Id": "6949202", "OwnerUserId": "14860", "Body": "<p>The standard states that you are not allowed to modify string  literals directly, regardless of whether you mark them <code>const</code> or not:</p>\n<blockquote>\n<p id=\"so_6949150_6949202_0\">Whether all string literals are distinct (that is, are stored in nonoverlapping\n  objects) is implementation-defined. The effect of attempting to modify a string literal is undefined.</p>\n</blockquote>\n<p>In fact, in C (unlike C++), string literals are <em>not</em> <code>const</code> but you're still not allowed to write to them.</p>\n<p>This restriction on writing allows certain optimisations to take place, such as sharing of literals along the lines of:</p>\n<pre><code>char *ermsg = \"invalid option\";\nchar *okmsg =   \"valid option\";\n</code></pre>\n<p>where <code>okmsg</code> can actually point to the <code>'v'</code> character in <code>ermsg</code>, rather than being a distinct string.</p>\n", "LastActivityDate": "2011-08-04T22:29:03.003"}, "25615644": {"ParentId": "6949150", "CommentCount": "0", "Body": "<p>a little bit of history of string literals in Ritchie's words.\nmostly about the orgin and the evolution of string literals from K&amp;R 1.\nHope this might clarify a thing or two about const and string literals.</p>\n<p>\"From: Dennis Ritchie \nSubject: Re: History question: String literals.\nDate: 02 Jun 1998\nNewsgroups: comp.std.c</p>\n<p>At the time that the C89 committee was working, writable\nstring literals weren't \"legacy code\" (Margolin) and what standard\nthere existed (K&amp;R 1) was quite explicit (A.2.5) that\nstrings were just a way of initializing a static array.\nAnd as Barry pointed out there were some (mktemp) routines\nthat used this fact.</p>\n<p>I wasn't around for the committee's deliberations on the\npoint, but I suspect that the BSD utility for fiddling\nthe assembler code to move the initialization of strings\nto text instead of data, and the realization that most\nliteral strings were not in fact overwritten, was more\nimportant than some very early version of gcc.</p>\n<p>Where I think the committee might have missed something\nis in failure to find a formulation that explained\nthe behavior of string literals in terms of const.\nThat is, if \"abc\" is an anonymous literal of type\n  const char [4]\nthen just about all of its properties (including the\nability to make read-only, and even to share its storage\nwith other occurrences of the same literal) are nearly\nexplained.</p>\n<p>The problem with this was not only the relatively few\nplaces that string literals were actually written on, but much\nmore important, working out feasible rules for assignments\nto pointers-to-const, in particular for function's actual\narguments.  Realistically the committee knew that whatever\nrules they formulated could not require a mandatory\ndiagnostic for every func(\"string\") in the existing world.</p>\n<p>So they decided to leave \"...\" of ordinary char array\ntype, but say one was required not to write over it.</p>\n<p>This note, BTW, isn't intended to be read as a snipe\nat the formulation in C89.  It is very hard to get things\nboth right (coherent and correct) and usable (consistent\nenough, attractive enough).</p>\n<pre><code>Dennis\n</code></pre>\n<p>\"</p>\n", "OwnerUserId": "3522564", "PostTypeId": "2", "Id": "25615644", "Score": "0", "CreationDate": "2014-09-02T04:02:38.653", "LastActivityDate": "2014-09-02T04:02:38.653"}});