post_cb({"2953611": {"CommentCount": "5", "AcceptedAnswerId": "2953925", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-06-01T21:49:37.800", "LastActivityDate": "2012-03-09T02:54:55.857", "LastEditDate": "2017-05-23T10:28:45.337", "ViewCount": "2351", "FavoriteCount": "6", "Title": "Are variadic constructors supposed to hide the implicitly generated ones?", "Id": "2953611", "Score": "26", "Body": "<p>Are variadic constructors supposed to hide the implicitly generated ones, i.e. the default constructor and the copy constructor?</p>\n<pre><code>struct Foo\n{\n    template&lt;typename... Args&gt; Foo(Args&amp;&amp;... x)\n    {\n        std::cout &lt;&lt; \"inside the variadic constructor\\n\";\n    }\n};\n\nint main()\n{\n    Foo a;\n    Foo b(a);\n}\n</code></pre>\n<p>Somehow I was expecting this to print nothing after reading <a href=\"https://stackoverflow.com/questions/598913/most-important-things-about-c-templates-lesson-learned/604022#604022\">this answer</a>, but it prints <code>inside the variadic constructor</code> twice on g++ 4.5.0 :( Is this behavior correct?</p>\n<hr>\n<p>It also happens without variadic templates:</p>\n<pre><code>struct Foo\n{\n    Foo()\n    {\n        std::cout &lt;&lt; \"inside the nullary constructor\\n\";\n    }\n\n    template&lt;typename A&gt; Foo(A&amp;&amp; x)\n    {\n        std::cout &lt;&lt; \"inside the unary constructor\\n\";\n    }\n};\n\nint main()\n{\n    Foo a;\n    Foo b(a);\n}\n</code></pre>\n<p>Again, both lines are printed.</p>\n</hr>", "Tags": "<c++><templates><c++11><copy-constructor><variadic-templates>", "OwnerUserId": "252000", "AnswerCount": "1"}, "2953925": {"ParentId": "2953611", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2010-06-01T22:50:37.270", "Score": "19", "LastEditorUserId": "151292", "LastEditDate": "2010-06-02T00:17:20.880", "Id": "2953925", "OwnerUserId": "151292", "Body": "<p>Declaration of the implicitly declared copy constructor is not, in fact, being suppressed.  It's just not being called due to the rules of overload resolution.</p>\n<p>The implicitly declared copy constructor has the form <code>Foo(const Foo&amp;)</code>.  The important part of this is that it takes a const reference.  Your constructor template takes a non-const reference.</p>\n<p><code>a</code> is not const, so the non-const user-declared constructor template is preferred over the implicitly-declared copy constructor.  To call the implicitly-declared copy constructor, you can make <code>a</code> const:</p>\n<pre><code>const Foo a;\nFoo b(a);\n</code></pre>\n<p>or you can use <code>static_cast</code> to obtain a const reference to <code>a</code>:</p>\n<pre><code>Foo a;\nFoo b(static_cast&lt;const Foo&amp;&gt;(a));\n</code></pre>\n<p>The overload resolution rules that describe this are found mostly in \u00a713.3.3.2/3 of the C++0x FCD.  This particular scenario, with a combination of lvalue and rvalue references, is sort of described by the various examples on page 303.</p>\n<hr>\n<p>A variadic constructor template will suppress the implicitly declared default constructor because a variadic constructor template is user-declared and the implicitly declared default constructor is only provided if there are no user-declared constructors (C++0x FCD \u00a712.1/5):</p>\n<blockquote>\n<p id=\"so_2953611_2953925_0\">If there is no user-declared constructor for class <code>X</code>, a constructor having no parameters is implicitly declared as defaulted.</p>\n</blockquote>\n<p>A variadic constructor template will not suppress the implicitly declared copy constructor because only a non-template constructor can be a copy constructor (C++0x FCD \u00a712.8/2, 3, and 8):</p>\n<blockquote>\n<p id=\"so_2953611_2953925_1\">A non-template constructor for class <code>X</code> is a copy constructor if its \ufb01rst parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments.</p>\n<p id=\"so_2953611_2953925_2\">A non-template constructor for class <code>X</code> is a move constructor if its \ufb01rst parameter is of type <code>X&amp;&amp;</code>, <code>const X&amp;&amp;</code>, <code>volatile X&amp;&amp;</code>, or <code>const volatile X&amp;&amp;</code>, and either there are no other parameters or else all other parameters have default arguments.</p>\n<p id=\"so_2953611_2953925_3\">If the class de\ufb01nition does not explicitly declare a copy constructor and there is no user-declared move constructor, a copy constructor is implicitly declared as defaulted.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2010-06-02T00:17:20.880"}, "bq_ids": {"n4140": {"so_2953611_2953925_0": {"section_id": 369, "quality": 1.0, "length": 10}, "so_2953611_2953925_2": {"section_id": 452, "quality": 0.9583333333333334, "length": 23}, "so_2953611_2953925_3": {"section_id": 469, "quality": 0.8125, "length": 13}, "so_2953611_2953925_1": {"section_id": 451, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_2953611_2953925_0": {"section_id": 359, "quality": 1.0, "length": 10}, "so_2953611_2953925_2": {"section_id": 443, "quality": 0.9583333333333334, "length": 23}, "so_2953611_2953925_3": {"section_id": 460, "quality": 0.75, "length": 12}, "so_2953611_2953925_1": {"section_id": 442, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_2953611_2953925_0": {"section_id": 381, "quality": 1.0, "length": 10}, "so_2953611_2953925_2": {"section_id": 475, "quality": 0.9583333333333334, "length": 23}, "so_2953611_2953925_1": {"section_id": 474, "quality": 0.9583333333333334, "length": 23}, "so_2953611_2953925_3": {"section_id": 492, "quality": 0.8125, "length": 13}}}});