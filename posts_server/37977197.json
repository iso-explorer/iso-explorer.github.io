post_cb({"bq_ids": {"n4140": {"so_37977197_37977647_0": {"length": 19, "quality": 0.95, "section_id": 6064}}, "n3337": {"so_37977197_37977647_0": {"length": 19, "quality": 0.95, "section_id": 5832}}, "n4659": {"so_37977197_37977647_0": {"length": 18, "quality": 0.9, "section_id": 7560}}}, "37977647": {"Id": "37977647", "PostTypeId": "2", "Body": "<p><code>this</code> is a prvalue, but <code>*this</code> is a lvalue, naturally it will call lvalue ref-qualifiers:</p>\n<pre><code>\u00a7 5.3.1 Unary operators [expr.unary.op]\n</code></pre>\n<blockquote>\n<p id=\"so_37977197_37977647_0\">The unary * operator performs <em>indirection</em>: the expression to which it is applied shall be a pointer to an\n  object type, or a pointer to a function type and the result is an <strong>lvalue</strong> referring to the object or function\n  to which the expression points.</p>\n</blockquote>\n<p>From cppreference, <a href=\"http://en.cppreference.com/w/cpp/language/this\" rel=\"nofollow\">this pointer</a>:</p>\n<blockquote>\n<p id=\"so_37977197_37977647_1\">When a non-static class member is used in any of the contexts where the this keyword is allowed (non-static member function bodies, member initializer lists, default member initializers), <strong>the implicit this-&gt; is automatically added before the name</strong>, resulting in a member access expression (which, if the member is a virtual member function, results in a virtual function call).</p>\n</blockquote>\n<p><em>Note</em>: calling this-&gt; is equivalent to calling (*this).</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct foo\n{\n    void bar( ) &amp;  { std::cout &lt;&lt; \"lvalue\\n\"; x(); }\n    void bar( ) &amp;&amp; { std::cout &lt;&lt; \"rvalue\\n\"; x(); }\n\n    void x( ) &amp; { std::cout &lt;&lt; \"x lvalue\\n\"; }\n    void x( ) &amp;&amp; { std::cout &lt;&lt; \"x rvalue\\n\"; }\n\n    ~foo( ) { bar( ); }\n};\n\n\nint main( int arg, char **argv )\n{\n    foo{ }.bar();\n}\n</code></pre>\n<p>Prints:</p>\n<pre><code>rvalue\nx lvalue\nlvalue\nx lvalue\n</code></pre>\n<p>If, for some reason, you really want to call a rvalue function, you could cast the this pointer to a rvalue reference:</p>\n<pre><code>~foo( ) { static_cast&lt;foo&amp;&amp;&gt;(*this).bar( ); }\n</code></pre>\n<p>Or using <code>std::move</code>:</p>\n<pre><code>~foo( ) { std::move(*this).bar( ); }\n</code></pre>\n", "LastEditorUserId": "3658660", "LastActivityDate": "2016-06-22T20:57:13.427", "Score": "0", "CreationDate": "2016-06-22T20:26:28.147", "ParentId": "37977197", "CommentCount": "4", "OwnerUserId": "3658660", "LastEditDate": "2016-06-22T20:57:13.427"}, "37977197": {"ViewCount": "46", "Body": "<p>I have the following setup:</p>\n<pre><code>struct foo\n{\n    void bar( ) &amp;  { std::cout &lt;&lt; \"lvalue\\n\"; }\n    void bar( ) &amp;&amp; { std::cout &lt;&lt; \"rvalue\\n\"; }\n\n    ~foo( ) { bar( ); }\n};\n\n\nint main( int arg, char **argv )\n{\n    foo{ }.bar();\n}\n</code></pre>\n<p>which leads to the output of</p>\n<pre><code>rvalue\nlvalue\n</code></pre>\n<p>I do not understand the output of the dtor which is always <code>lvalue</code> \nno matter how hard I try. While I agree that taking the address\nsimilar to</p>\n<pre><code>(*this).bar( ); // sure enough this will print lvalue\n</code></pre>\n<p>calls the lvalue-overload I do not understand why I can never get an output of <code>rvalue</code>for the dtor.</p>\n<p>I find this strange since the object is an rvalue first and somehow binds to an lvalue before being destructed. What's the matter here?</p>\n", "AcceptedAnswerId": "37977647", "Title": "confusion overloading memberfunctions on rvalues and lvalues", "CreationDate": "2016-06-22T19:59:57.470", "Id": "37977197", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-06-22T20:57:13.427", "Score": "2", "OwnerUserId": "2660747", "Tags": "<c++><lvalue><rvalue><overload-resolution>", "AnswerCount": "1"}});