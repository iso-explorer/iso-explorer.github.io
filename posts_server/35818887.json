post_cb({"bq_ids": {"n4140": {"so_35818887_35820028_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 215}}, "n3337": {"so_35818887_35820028_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 209}}, "n4659": {"so_35818887_35820028_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 223}}}, "35820028": {"Id": "35820028", "PostTypeId": "2", "Body": "<p>I believe this is a gcc bug, filed as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70099\" rel=\"nofollow\">70099</a>. From [temp.dep.res]:</p>\n<blockquote>\n<p id=\"so_35818887_35820028_0\">In resolving dependent names, names from the following sources are considered:<br>\n  (1.1) \u2014 Declarations that are visible at the point of definition of the template.<br>\n  (1.2) \u2014 Declarations from namespaces associated with the types of the function arguments both from the instantiation context (14.6.4.1) and from the definition context.</br></br></p>\n</blockquote>\n<p><code>foo::operator&lt;()</code> isn't visible at the point of definition of the template, and isn't in an associated namespace from the function arguments (<code>X</code>'s associated namespace is just the global namespace <code>::</code>). So I think gcc is wrong to find <code>foo::operator&lt;</code> and clang is correct to reject the code. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-16T15:24:33.177", "Score": "6", "CreationDate": "2016-03-05T21:18:21.213", "ParentId": "35818887", "CommentCount": "0", "LastEditDate": "2016-03-16T15:24:33.177", "OwnerUserId": "2069064"}, "35819114": {"Id": "35819114", "PostTypeId": "2", "Body": "<p>GCC is wrong Clang is correct. The fact that GCC swallows invalid code as the one that you showed is also mentioned in CLANG's compatibility page <a href=\"http://clang.llvm.org/compatibility.html#dep_lookup\">here</a>. </p>\n<p>Unqualified names are looked up in the following ways.</p>\n<ol>\n<li>The compiler conducts unqualified lookup in the scope where the name was written. <strong>For a template, this means the lookup is done at the point where the template is defined, not where it's instantiated.</strong> Since <code>operator&lt;</code> hasn't been declared yet at this point, unqualified lookup won't find it.</li>\n<li>If the name is called like a function, then the compiler also does argument-dependent lookup (ADL). (Sometimes unqualified lookup can suppress ADL; see [basic.lookup.argdep] paragraph 3 for more information.) In ADL, the compiler looks at the types of all the arguments to the call. When it finds a class type, it looks up the name in that class's namespace; the result is all the declarations it finds in those namespaces, plus the declarations from unqualified lookup. However, the compiler doesn't do ADL until it knows all the argument types.</li>\n</ol>\n", "LastActivityDate": "2016-03-05T19:56:34.337", "Score": "5", "CreationDate": "2016-03-05T19:56:34.337", "ParentId": "35818887", "CommentCount": "0", "OwnerUserId": "2352671"}, "35818887": {"ViewCount": "147", "Body": "<p>Consider the following fragment:</p>\n<pre><code>struct X { };\n\nnamespace foo {\n    template &lt;class T&gt;\n    void bar() { T{} &lt; T{}; }\n\n    void operator&lt;(const X&amp;, const X&amp;) {}\n}\n\nint main() {\n    foo::bar&lt;X&gt;();\n}\n</code></pre>\n<p>clang rejects this code, gcc accepts it. Is this a gcc bug or is this a clang bug?</p>\n", "Title": "Dependent name lookup in function template: clang rejects, gcc accepts", "CreationDate": "2016-03-05T19:37:14.243", "LastActivityDate": "2016-03-16T15:24:33.177", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-05T21:18:19.273", "LastEditorUserId": "2069064", "Id": "35818887", "Score": "8", "OwnerUserId": "2069064", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "2"}});