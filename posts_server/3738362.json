post_cb({"3738362": {"ViewCount": "739", "Body": "<p>I recent wrote this post:<br>\n<a href=\"https://stackoverflow.com/questions/3737138/how-best-to-store-very-large-2d-list-of-floats-in-c-error-handling\">How best to store VERY large 2D list of floats in c++? Error-handling?</a></br></p>\n<p>Some suggested that I implemented my 2D list-like structure of floats as a vector, others said a deque.</p>\n<p>From what I gather vector requires continuous memory, but is hence more efficient.  Obviously this would be desirable if possible.</p>\n<p>Thus my question is what's a good rule of how long a basic structure can be in terms of...<br><br>\n1. float<br>\n2. int</br></br></br></p>\n<p>...before you should switch from a vector to a deque to avoid memory problems?</p>\n<p>e.g. I'm looking for answer like \"At around 4 million floats or 8 million ints, you should switch...\" ...if possible.</p>\n", "AcceptedAnswerId": "3738579", "Title": "What's generally the size limit to switch from a vector to a deque?", "CreationDate": "2010-09-17T19:28:35.107", "Id": "3738362", "CommentCount": "6", "LastEditDate": "2017-05-23T12:01:17.083", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2010-09-19T04:39:05.073", "Score": "1", "OwnerUserId": "375828", "Tags": "<c++><memory><stl><vector><deque>", "AnswerCount": "7"}, "3738579": {"Id": "3738579", "PostTypeId": "2", "Body": "<p>There are so many factors to consider that it's impossible to give a clear answer.  The amount of memory on the machine, how fragmented it is, how fragmented it may become, etc.  My suggestion is to just choose one and use it.  If it causes problems switch.  Chances are you aren't going to hit those edge cases anyway.</p>\n<p>If you are truly worried, then you could probably implement a sort of pseudo PIMPL:</p>\n<pre><code>template&lt;typename T&gt;\nclass VectorDeque\n{\nprivate:\n  enum TYPE { NONE, DEQUE, VECTOR };\n  std::deque&lt;T&gt; m_d;\n  std::vector&lt;T&gt; m_v;\n  TYPE m_type;\n  ...\npublic:\n  void resize(size_t n)\n  {\n    switch(m_type)\n    {\n      case NONE:\n      try\n      {\n        m_v.resize(n);\n        m_type = VECTOR;\n      }\n      catch(std::bad_alloc &amp;ba)\n      {\n        m_d.resize(n);\n        m_type = DEQUE;\n      }\n      break;\n    }\n  }\n};\n</code></pre>\n<p>But this seems like total overkill.  Have you done any benchmarking or tests?  Do you have any reason to believe that memory allocations will fail or that deques will be too slow?</p>\n", "LastActivityDate": "2010-09-17T20:00:21.827", "CommentCount": "0", "CreationDate": "2010-09-17T20:00:21.827", "ParentId": "3738362", "Score": "1", "OwnerUserId": "117539"}, "bq_ids": {"n4140": {"so_3738362_3738416_0": {"length": 4, "quality": 1.0, "section_id": 721}, "so_3738362_3738416_1": {"length": 8, "quality": 1.0, "section_id": 721}, "so_3738362_3738416_2": {"length": 13, "quality": 1.0, "section_id": 721}}, "n3337": {"so_3738362_3738416_0": {"length": 4, "quality": 1.0, "section_id": 710}, "so_3738362_3738416_2": {"length": 13, "quality": 1.0, "section_id": 710}, "so_3738362_3738416_1": {"length": 8, "quality": 1.0, "section_id": 710}}, "n4659": {"so_3738362_3738416_0": {"length": 4, "quality": 1.0, "section_id": 752}, "so_3738362_3738416_2": {"length": 13, "quality": 1.0, "section_id": 752}, "so_3738362_3738416_1": {"length": 8, "quality": 1.0, "section_id": 752}}}, "3738722": {"Id": "3738722", "PostTypeId": "2", "Body": "<p>Well, regarding memory, I can share some experience that may help you decide when contiguous memory blocks (malloc or std::vector) may become too large:</p>\n<p>The application I work with does record measurement data, mostly 4byte <code>float</code>, and for this it allocates internal buffers to store the data. These buffers heavily vary in size, but the typical range may be say, several dozen of 1-10MB and a very few of &gt;100MB. The buffers are allways allocated with <code>calloc</code>, i.e. one big chunk of memory. If a buffer-allocation fails, an error is logged and the user has the choice to try again.</p>\n<p>Buffer sizes: Say you want to record 1000 channels at 100Hz for 10 Minutes: 4byte x 1000 x 100 x 60x10 == 228 MB (approx.) ... or 100 channels at 10Hz for 12 hours == 41 MB</p>\n<p>We (nearly) never had any problems allocating 40MB buffers (and that's about 10 millon floats) and the 200-300 MB buffers fail from time to time -- all this on normal WinXP/32bit boxes with 4GB RAM.</p>\n", "LastActivityDate": "2010-09-17T20:17:24.063", "CommentCount": "0", "CreationDate": "2010-09-17T20:17:24.063", "ParentId": "3738362", "Score": "0", "OwnerUserId": "321013"}, "3738493": {"Id": "3738493", "PostTypeId": "2", "Body": "<p>Again, there is no size limit above which deque is or not better than vector. Memory fragmentation implications are pretty much the same in either case, except when you have already done a huge load of allocations/deallocations and there is not enough contiguous space left for a big vector. But this case is very rare. Remember that memory space is <em>per process</em> (google for <em>virtual memory</em>). And you can remedy it by allocating the memory for the vector (by the <code>reserve</code> method) before the cluttering takes place.</p>\n<p>The tradeoff is in term of <em>what you want to do with it</em>. If the structure is basically immutable and you only want to access it / overwrite it by index access, go for vector.</p>\n<p>Deque is when you need to do insertions either at the end, the beginning or in the middle, something vector cannot handle naturally (except for inserting at the end).</p>\n<p>Herb Sutter's articles are in general of great quality, but you'll notice that when you do \"number crunching\" in C++, most of the stuff you're taught in \"general C++\" books must be taken with an extra word of caution. The poor indexing performance you experience with deques is perhaps important for your application. In this case, don't use deque.</p>\n", "LastActivityDate": "2010-09-17T19:46:26.070", "CommentCount": "1", "CreationDate": "2010-09-17T19:46:26.070", "ParentId": "3738362", "Score": "2", "OwnerUserId": "373025"}, "3738533": {"Id": "3738533", "PostTypeId": "2", "Body": "<p>If you need insertions at the beginning, then go with deque. </p>\n<p>Otherwise, I always like to point to this article on <a href=\"http://www.codeproject.com/KB/stl/vector_vs_deque.aspx\" rel=\"nofollow noreferrer\">vector vs. deque</a> (in addition to those linked by James McNellis here). <em>Assuming an implementation of deque that uses page-based allocation</em>, this article has good comparisons of allocation time (&amp; deallocation time) for vector with &amp; without reserve() vs. deque. Basically, using reserve() makes vector allocation time very similar to deque. Informative, and useful if you can guess the right value to reserve ahead of time.</p>\n", "LastEditorUserId": "12622", "LastActivityDate": "2010-09-17T20:32:53.270", "Score": "2", "CreationDate": "2010-09-17T19:52:15.590", "ParentId": "3738362", "CommentCount": "6", "OwnerUserId": "12622", "LastEditDate": "2010-09-17T20:32:53.270"}, "3738416": {"Id": "3738416", "PostTypeId": "2", "Body": "<p>Well, here are two opinions.  The C++ standard says (23.1.1/2):</p>\n<blockquote>\n<p id=\"so_3738362_3738416_0\"><code>vector</code> is the type of sequence that should be used by default. </p>\n<p id=\"so_3738362_3738416_1\"><code>list</code> should be used when there are frequent insertions and deletions from the middle of the sequence. </p>\n<p id=\"so_3738362_3738416_2\"><code>deque</code> is the data structure of choice when most insertions and deletions take place at the beginning or at the end of the sequence.</p>\n</blockquote>\n<p><a href=\"http://www.gotw.ca/gotw/054.htm\" rel=\"nofollow noreferrer\">Herb Sutter argues the following</a> (the article contains his rationale and a performance analysis):</p>\n<blockquote>\n<p id=\"so_3738362_3738416_3\">I'd like to present an amiably dissenting point of view:  I recommend that you consider preferring deque by default instead of vector, especially when the contained type is a class or struct and not a builtin type, unless you really need the container's memory to be contiguous.</p>\n</blockquote>\n", "LastActivityDate": "2010-09-17T19:36:07.197", "CommentCount": "5", "CreationDate": "2010-09-17T19:36:07.197", "ParentId": "3738362", "Score": "4", "OwnerUserId": "151292"}, "3738738": {"Id": "3738738", "PostTypeId": "2", "Body": "<p>Given that you don't insert after creation, you should probably either use plain old <code>std::vector</code>, or if fragmentation really does become an issue, a custom vector-like <a href=\"http://www.sgi.com/tech/stl/Sequence.html\" rel=\"nofollow noreferrer\">Sequence</a> implemented as a vector or array of pointers to fixed-size arrays.</p>\n", "LastEditorUserId": "294313", "LastActivityDate": "2010-09-17T20:35:57.493", "Score": "0", "CreationDate": "2010-09-17T20:20:32.300", "ParentId": "3738362", "CommentCount": "0", "OwnerUserId": "294313", "LastEditDate": "2010-09-17T20:35:57.493"}, "3738764": {"Id": "3738764", "PostTypeId": "2", "Body": "<p>You switch after testing and profiling indicate that one is worse than the other for your application. There is no \"around N floats or M ints\" universal answer.</p>\n", "LastActivityDate": "2010-09-17T20:23:32.360", "CommentCount": "0", "CreationDate": "2010-09-17T20:23:32.360", "ParentId": "3738362", "Score": "1", "OwnerUserId": "101225"}});