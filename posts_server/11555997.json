post_cb({"11555997": {"ViewCount": "27906", "Body": "<p>I know that arrays in C are just pointers to sequentially stored data. But what differences imply the difference in notation [] and *. I mean in ALL possible usage context.\nFor example:</p>\n<pre><code>char c[] = \"test\";\n</code></pre>\n<p>if you provide this instruction in a function body it will allocate the string on a stack while</p>\n<pre><code>char* c = \"test\";\n</code></pre>\n<p>will point to a data (readonly) segment.</p>\n<p>Can you list all the differences between these two notations in ALL usage contexts to form a clear general view.</p>\n", "AcceptedAnswerId": "11556702", "Title": "C/C++ int[] vs int* (pointers vs. array notation). What is the difference?", "CreationDate": "2012-07-19T07:35:58.253", "Id": "11555997", "CommentCount": "5", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2012-07-19T08:44:15.017", "LastEditorUserId": "1065190", "LastActivityDate": "2014-12-10T15:22:27.590", "Score": "28", "OwnerUserId": "1239729", "Tags": "<c++><c><arrays><pointers><standards>", "AnswerCount": "5"}, "11556723": {"Id": "11556723", "PostTypeId": "2", "Body": "<p><code>char []</code> denotes the type \"array of unknown bound of char\", while <code>char *</code> denotes the type \"pointer to char\".  As you've observed, when a definition of a variable of type \"array of unknown bound of char\" is initialised with a string literal, the type is converted to \"array[N] of char\" where N is the appropriate size.  The same applies in general to initialisation from array aggregate:</p>\n<pre><code>int arr[] = { 0, 1, 2 };\n</code></pre>\n<p>arr is converted to type \"array[3] of int\".</p>\n<p>In a user-defined type definition (<code>struct</code>, <code>class</code> or <code>union</code>), array-of-unknown-bound types are prohibited in C++, although in some versions of C they are allowed as the <em>last</em> member of a struct, where they can be used to access allocated memory past the end of the struct; this usage is called \"flexible arrays\".</p>\n<p>Recursive type construction is another difference; one can construct pointers to and arrays of <code>char *</code> (e.g. <code>char **</code>, <code>char (*)[10]</code>) but this is illegal for arrays of unknown bound; one cannot write <code>char []*</code> or <code>char [][10]</code> (although <code>char (*)[]</code> and <code>char [10][]</code> are fine).</p>\n<p>Finally, cv-qualification operates differently; given <code>typedef char *ptr_to_char</code> and <code>typedef char array_of_unknown_bound_of_char[]</code>, cv-qualifiying the pointer version will behave as expected, while cv-qualifying the array version will migrate the cv-qualification to the element type: that is, <code>const array_of_unknown_bound_of_char</code> is equivalent to <code>const char []</code> and not the fictional <code>char (const) []</code>.  This means that in a function definition, where array-to-pointer decay operates on the arguments prior to constructing the prototype,</p>\n<pre><code>void foo (int const a[]) {\n    a = 0;\n}\n</code></pre>\n<p>is legal; there is no way to make the array-of-unknown-bound parameter non-modifiable.</p>\n", "LastActivityDate": "2012-07-19T08:20:28.200", "CommentCount": "0", "CreationDate": "2012-07-19T08:20:28.200", "ParentId": "11555997", "Score": "2", "OwnerUserId": "567292"}, "11556566": {"Id": "11556566", "PostTypeId": "2", "Body": "<p>Actually arrays are equivalent to <em>constant pointers</em>.</p>\n<p>Also, char c[] allocates memory for the array, whose base address is c itself. No separate memory is allocated for storing that address.</p>\n<p>Writing char *c allocates memory for the string whose base address is stored in c. Also, a separate memory location is used to store c.</p>\n", "LastActivityDate": "2012-07-19T08:11:47.197", "CommentCount": "3", "CreationDate": "2012-07-19T08:11:47.197", "ParentId": "11555997", "Score": "0", "OwnerUserId": "1434837"}, "bq_ids": {"n4140": {"so_11555997_11556702_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 3233}}, "n3337": {"so_11555997_11556702_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 3106}}, "n4659": {"so_11555997_11556702_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 3990}}}, "11556702": {"Id": "11556702", "PostTypeId": "2", "Body": "<p>According to the C99 standard:</p>\n<blockquote>\n<p id=\"so_11555997_11556702_0\">An array type describes a contiguously allocated nonempty set of\n  objects with a particular member object type, called the element\n  type.36) Array types are characterized by their element type and by\n  the number of elements in the array. An array type is said to be\n  derived from its element type, and if its element type is T, the array\n  type is sometimes called \u2018\u2018array of T\u2019\u2019. The construction of an array\n  type from an element type is called \u2018\u2018array type derivation\u2019\u2019.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_11555997_11556702_1\">A pointer type may be derived from a function type, an object type, or\n  an incomplete type, called the referenced type. A pointer type\n  describes an object whose value provides a reference to an entity of\n  the referenced type. A pointer type derived from the referenced type T\n  is sometimes called \u2018\u2018pointer to T\u2019\u2019. The construction of a pointer\n  type from a referenced type is called \u2018\u2018pointer type derivation\u2019\u2019.</p>\n</blockquote>\n<p>According to the standard declarations</p>\n<pre><code>char s[] = \"abc\", t[3] = \"abc\";\nchar s[] = { 'a', 'b', 'c', '\\0' }, t[] = { 'a', 'b', 'c' };\n</code></pre>\n<p>are identical. The contents of the arrays are modifiable. On the other hand, the declaration\n<code>const char *p = \"abc\";</code> defines p with type \u2018\u2018pointer to constant char\u2019\u2019 and initializes it to point to an object with type \u2018\u2018constant array of char\u2019\u2019 (in C++) with length 4 whose elements are initialized with a character string literal. If an attempt is made to use p to modify the contents of the array, the behavior is undefined.</p>\n<p>According to <code>6.3.2.1 Array subscripting</code> dereferencing and array subscripting are identical:</p>\n<blockquote>\n<p id=\"so_11555997_11556702_2\">The definition of the subscript operator [] is that E1[E2] is\n  identical to (*((E1)+(E2))).</p>\n</blockquote>\n<p>The differences of arrays vs pointers are:</p>\n<ul>\n<li>pointer has no information of the memory size behind it (there is no portable way to get it)</li>\n<li>an array of incomplete type cannot be constructed</li>\n<li>a pointer type may be derived from a an incomplete type</li>\n<li>a pointer can define a recursive structure (this one is the consequence of the previous two)</li>\n</ul>\n<p>These links may be useful to the subject:</p>\n<ul>\n<li><a href=\"http://support.microsoft.com/kb/44463\" rel=\"noreferrer\">http://support.microsoft.com/kb/44463</a></li>\n<li><a href=\"http://www.cplusplus.com/forum/articles/9/\" rel=\"noreferrer\">http://www.cplusplus.com/forum/articles/9/</a></li>\n</ul>\n</hr>", "LastEditorUserId": "1065190", "LastActivityDate": "2012-07-19T15:26:02.810", "Score": "18", "CreationDate": "2012-07-19T08:19:41.120", "ParentId": "11555997", "CommentCount": "3", "OwnerUserId": "1065190", "LastEditDate": "2012-07-19T15:26:02.810"}, "11556728": {"Id": "11556728", "PostTypeId": "2", "Body": "<p>The whole lot become clear if you know that </p>\n<p><code>Declaring a pointer variable does not create the type of variable, it points at. It creates a pointer variable.</code> </p>\n<p>So in usage, if you need to a string then you need to specify an array of characters and a pointer can be used later on. </p>\n", "LastActivityDate": "2012-07-19T08:21:02.640", "CommentCount": "0", "CreationDate": "2012-07-19T08:21:02.640", "ParentId": "11555997", "Score": "1", "OwnerUserId": "1145138"}, "11556898": {"Id": "11556898", "PostTypeId": "2", "Body": "<pre><code>char c[] = \"test\";\n</code></pre>\n<p>This will create an array containing the string test so you can modify/change any character, say</p>\n<pre><code>c[2] = 'p';\n</code></pre>\n<p>but, </p>\n<pre><code>char * c = \"test\"\n</code></pre>\n<p>It is a string literal -- it's a const char.<br/>\nSo doing any modification to this string literal gives us segfault. So </p>\n<pre><code>c[2] = 'p';\n</code></pre>\n<p>is illegal now and gives us segfault.</p>\n", "LastActivityDate": "2012-07-19T08:33:54.490", "CommentCount": "2", "CreationDate": "2012-07-19T08:33:54.490", "ParentId": "11555997", "Score": "7", "OwnerUserId": "1215889"}});