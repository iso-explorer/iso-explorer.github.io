post_cb({"12262754": {"CommentCount": "1", "ViewCount": "180", "PostTypeId": "1", "LastEditorUserId": "1497596", "CreationDate": "2012-09-04T11:41:04.863", "LastActivityDate": "2012-09-04T12:49:49.197", "Title": "Macro Name and Replacement-list are Same", "AcceptedAnswerId": "12263618", "LastEditDate": "2012-09-04T12:24:45.467", "Id": "12262754", "Score": "3", "Body": "<p>I have found some preprocessing directives in which macro name and replacement-list are same. For example, some preprocessing directives in stdbool.h provided by gcc.</p>\n<pre><code>#else /* __cplusplus */\n\n/* Supporting &lt;stdbool.h&gt; in C++ is a GCC extension.  */\n#define _Bool   bool\n#define bool    bool\n#define false   false\n#define true    true\n\n#endif /* __cplusplus */\n</code></pre>\n<p>I don't understand why the programmer wrote these preprocessing directives. They are useless, and the replacements will waste time. I know that this don't cause infinite recursion. How to avoid infinite recursion? What's the related provisions in C standard?</p>\n", "Tags": "<c++><macros><replace>", "OwnerUserId": "1548476", "AnswerCount": "4"}, "12263566": {"ParentId": "12262754", "CommentCount": "3", "Body": "<p>Macro expansions do not recurse, so they will terminate.</p>\n<p>One advantage of having a macro is that you can test it in the preprocessor</p>\n<pre><code>#if defined bool\n...\n#endif\n</code></pre>\n<p>only works if <code>bool</code> is a macro.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "12263566", "Score": "1", "CreationDate": "2012-09-04T12:30:57.250", "LastActivityDate": "2012-09-04T12:30:57.250"}, "12263618": {"ParentId": "12262754", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Infinite recursion during macro replacement is prevented by C++11 standard section 16.3.4 paragraph 2:</p>\n<blockquote>\n<p id=\"so_12262754_12263618_0\">If the name of the macro being replaced is found during this scan of the replacement list (not including the\n    rest of the source \ufb01le\u2019s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements\n    encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts\n    in which that macro name preprocessing token would otherwise have been replaced.</p>\n</blockquote>\n<p>Basically, this means that a macro which appears inside its own expansion won't be replaced again.</p>\n<p>The reason that <code>true</code>, <code>bool</code>, and <code>false</code> are defined as macros by the GCC extension is to make C++ code more compatible with C99. In C99, these are defined as macros in stdbool.h, so code may check if they are defined using e.g. <code>#ifdef bool</code>.</p>\n", "OwnerUserId": "189205", "LastEditorUserId": "189205", "LastEditDate": "2012-09-04T12:49:49.197", "Id": "12263618", "Score": "5", "CreationDate": "2012-09-04T12:34:01.297", "LastActivityDate": "2012-09-04T12:49:49.197"}, "12263543": {"ParentId": "12262754", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Sometimes the standard says \"<code>X</code> must be a macro.\" If your language already has an intrinsic <code>X</code>, you must say <code>#define X X</code> to be standard compliant. (For example, a user could say <code>#ifdef X</code> and expect this to be true.)</p>\n<p>Example (C11, 7.2/2):</p>\n<blockquote>\n<p id=\"so_12262754_12263543_0\">The <code>assert</code> macro shall be implemented as a macro, not as an actual function. If the\n  macro definition is suppressed in order to access an actual function, the behavior is\n  undefined.</p>\n</blockquote>\n<p>It is entirely plausible for your implementation to have an actual <code>assert</code> function.</p>\n<p>For fun, here are some things which are \"unspecified\" as to whether they are macros or identifiers with external linkage:</p>\n<ul>\n<li><p><code>errno</code></p></li>\n<li><p><code>setjmp</code></p></li>\n<li><p><code>va_copy</code>, <code>va_end</code></p></li>\n<li><p><code>putc</code>, <code>getc</code></p></li>\n</ul>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-09-04T12:35:19.543", "Id": "12263543", "Score": "1", "CreationDate": "2012-09-04T12:29:59.993", "LastActivityDate": "2012-09-04T12:35:19.543"}, "12263647": {"ParentId": "12262754", "CommentCount": "0", "Body": "<p>In addition to the other answers, defining these macros will help the compiler generate \"macro redefinition\" error messages if anyone, anywhere has the brilliant idea of redefining bool, true or false.</p>\n<p>See standard section 16.3  - only identical replacement lists are allowed in macro redefinitions.</p>\n", "OwnerUserId": "33987", "PostTypeId": "2", "Id": "12263647", "Score": "2", "CreationDate": "2012-09-04T12:36:07.657", "LastActivityDate": "2012-09-04T12:36:07.657"}, "bq_ids": {"n4140": {"so_12262754_12263618_0": {"section_id": 531, "quality": 0.9591836734693877, "length": 47}}, "n3337": {"so_12262754_12263618_0": {"section_id": 522, "quality": 0.9591836734693877, "length": 47}}, "n4659": {"so_12262754_12263618_0": {"section_id": 552, "quality": 0.9591836734693877, "length": 47}}}});