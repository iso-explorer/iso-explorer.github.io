post_cb({"bq_ids": {"n4140": {"so_42573771_42574950_4": {"length": 6, "quality": 0.75, "section_id": 603}, "so_42573771_42574950_2": {"length": 11, "quality": 1.0, "section_id": 639}, "so_42573771_42574950_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 639}, "so_42573771_42574950_0": {"length": 48, "quality": 0.9795918367346939, "section_id": 562}, "so_42573771_42574950_3": {"length": 18, "quality": 0.9, "section_id": 603}}, "n3337": {"so_42573771_42574950_4": {"length": 6, "quality": 0.75, "section_id": 593}, "so_42573771_42574950_2": {"length": 11, "quality": 1.0, "section_id": 629}, "so_42573771_42574950_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 629}, "so_42573771_42574950_0": {"length": 48, "quality": 0.9795918367346939, "section_id": 553}, "so_42573771_42574950_3": {"length": 18, "quality": 0.9, "section_id": 593}}, "n4659": {"so_42573771_42574950_4": {"length": 6, "quality": 0.75, "section_id": 629}, "so_42573771_42574950_2": {"length": 11, "quality": 1.0, "section_id": 667}, "so_42573771_42574950_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 667}, "so_42573771_42574950_0": {"length": 48, "quality": 0.9795918367346939, "section_id": 585}, "so_42573771_42574950_3": {"length": 18, "quality": 0.9, "section_id": 629}}}, "42573843": {"Id": "42573843", "PostTypeId": "2", "Body": "<p>When a function is overloaded, the overload resolution takes place first. The program is ill-formed if the deleted function is the best match and is selected.</p>\n<p>Therefore, your program would produce the same error as the following, because there is an implicit conversion from int to double and the compiler does not know what function you intend to call:</p>\n<pre><code>class Base{\npublic:\n    void func(double a) {}\n    void func(int a) const {}\n};\n</code></pre>\n", "LastActivityDate": "2017-03-03T08:20:27.110", "CommentCount": "1", "CreationDate": "2017-03-03T08:20:27.110", "ParentId": "42573771", "Score": "0", "OwnerUserId": "648078"}, "42573922": {"Id": "42573922", "PostTypeId": "2", "Body": "<p>It because of the <code>const</code> modifier in <code>func(int)</code>. The <code>base</code> instance is not const. C++ compilers seem to find the <code>non-const</code> method first if the instance is not const. And then, compilers found that method has been deleted. So the compiler gives a warning.</p>\n<p>Try to remove the <code>const</code> modifier, or move the <code>const</code> modifier to <code>func(double)</code> will get rid of the warning.</p>\n<p>It seems that this warning is not about implicit conversion. Even you invoke <code>func</code> by <code>func((int)(1))</code> is not good either.</p>\n", "LastEditorUserId": "1258380", "LastActivityDate": "2017-03-03T08:27:42.943", "Score": "-1", "CreationDate": "2017-03-03T08:25:01.620", "ParentId": "42573771", "CommentCount": "1", "OwnerUserId": "1258380", "LastEditDate": "2017-03-03T08:27:42.943"}, "42573771": {"ViewCount": "840", "Body": "<p>Consider this class:</p>\n<pre><code>class Base{\npublic:\n    void func(double a) = delete;\n    void func(int a) const {}\n};\n\nint main(){\n    Base base;\n\n    base.func(1);\n    return 0;\n}\n</code></pre>\n<p>When compiled using clang++, it produces the following error:</p>\n<pre class=\"lang-none prettyprint-override\"><code>clang++ --std=c++11 test.cpp \ntest.cpp:22:7: error: call to member function 'func' is ambiguous\n    base.func(1);\n</code></pre>\n<p>With g++, a warning is produced:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ -std=c++11 test.cpp \ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:22:13: warning: ISO C++ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for the second: base.func(1);\n</code></pre>\n<p>Why is this code ambiguous ? </p>\n", "AcceptedAnswerId": "42574950", "Title": "Why is this call to member function ambiguous?", "CreationDate": "2017-03-03T08:14:10.130", "Id": "42573771", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-03-03T10:32:13.307", "LastEditorUserId": "560648", "LastActivityDate": "2017-03-03T16:46:51.700", "Score": "10", "OwnerUserId": "7652115", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "3"}, "42574950": {"Id": "42574950", "PostTypeId": "2", "Body": "<p>Non-static member functions, like the two:</p>\n<pre><code>void func(double);    // #1\nvoid func(int) const; // #2\n</code></pre>\n<p>accept also an <a href=\"http://eel.is/c++draft/over.match.funcs#4\" rel=\"nofollow noreferrer\">implicit object parameter</a> which is considered in overload resolution (<a href=\"http://eel.is/c++draft/over.match#1\" rel=\"nofollow noreferrer\">[over.match]/p1</a>) as any other argument:</p>\n<blockquote>\n<p id=\"so_42573771_42574950_0\">Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are to be the arguments of the call and a set of candidate functions that can be called based on the context of the call. The selection criteria for the best function are the number of arguments, how well the arguments match the parameter-type-list of the candidate function, <strong>how well (for non-static member functions) the object matches the implicit object parameter</strong>, and certain other properties of the candidate function.</p>\n</blockquote>\n<p>After incorporating the implicit object parameter into the member functions signatures, the compiler sees two overloads:</p>\n<pre><code>void func(Base&amp;, double);    // #1\nvoid func(const Base&amp;, int); // #2\n</code></pre>\n<p>and tries to select the best viable function based on the call:</p>\n<pre><code>Base base;\nbase.func(1);\n</code></pre>\n<p>The conversion from <code>base</code> (which is a non-const lvalue of type <code>Base</code>) to <code>Base&amp;</code> has an <em>Exact Match</em> rank (direct reference binding yields an <a href=\"http://eel.is/c++draft/over.ics.ref#1\" rel=\"nofollow noreferrer\"><em>Identity conversion</em></a>) -- see <a href=\"http://eel.is/c++draft/over.best.ics#tab:over.conversions\" rel=\"nofollow noreferrer\">Table 13</a>. The conversion from <code>base</code> to <code>const Base&amp;</code> is also of an <em>Exact Match</em> rank, however, <a href=\"http://eel.is/c++draft/over.ics.rank#3.2.6\" rel=\"nofollow noreferrer\">[over.ics.rank]/p3.2.6</a> declares <code>#1</code> to have a better conversion sequence:</p>\n<blockquote>\n<p id=\"so_42573771_42574950_1\">\u2014 S1 and S2 are reference bindings (<a href=\"http://eel.is/c++draft/dcl.init.ref\" rel=\"nofollow noreferrer\">[dcl.init.ref]</a>), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers. [\u2009<em>Example</em>:</p>\n<pre><code>int f(const int &amp;);\nint f(int &amp;);\nint g(const int &amp;);\nint g(int);\n\nint i;\nint j = f(i);    // calls f(int &amp;)\nint k = g(i);    // ambiguous\n</code></pre>\n</blockquote>\n<p>Now for the second parameter, a conversion from an integral prvalue <code>1</code> to <code>double</code> is a <em>Floating-integral conversion</em> (<a href=\"http://eel.is/c++draft/conv.fpint#2\" rel=\"nofollow noreferrer\">[conv.fpint]</a>) which is given a <em>Conversion</em> rank. On the other hand, <code>1</code> to <code>int</code> is an <em>Identity conversion</em> which is of an <em>Exact Match</em> rank. For this argument, <code>#2</code> is considered to have a better conversion sequence (<a href=\"http://eel.is/c++draft/over.ics.rank#3.2.2\" rel=\"nofollow noreferrer\">[over.ics.rank]/p3.2.2</a>):</p>\n<blockquote>\n<p id=\"so_42573771_42574950_2\">\u2014 the rank of S1 is better than the rank of S2, or S1 and S2 have the same rank and are distinguishable by the rules in the paragraph below, or, if not that, [...]</p>\n</blockquote>\n<p>Overload resolution to succeed requires that there exists at most one parameter for which conversion sequences differ (<a href=\"http://eel.is/c++draft/over.match.best#1\" rel=\"nofollow noreferrer\">[over.match.best]</a>):</p>\n<blockquote>\n<p id=\"so_42573771_42574950_3\">Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICS<sub>i</sub>(F1) is not a worse conversion sequence than ICS<sub>i</sub>(F2), and then</p>\n<p id=\"so_42573771_42574950_4\">\u2014 for some argument j, ICS<sub>j</sub>(F1) is a better conversion sequence than ICS<sub>j</sub>(F2), or, if not that, [...]</p>\n</blockquote>\n<p>Here, ICS<sub>0</sub>(#1) is better than ICS<sub>0</sub>(#2), but in turn, ICS<sub>1</sub>(#2) is better than ICS<sub>1</sub>(#1), so the compiler can't choose between the two overloads and detects ambiguity.</p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2017-03-03T16:46:51.700", "Score": "10", "CreationDate": "2017-03-03T09:20:14.387", "ParentId": "42573771", "CommentCount": "3", "OwnerUserId": "3953764", "LastEditDate": "2017-03-03T16:46:51.700"}});