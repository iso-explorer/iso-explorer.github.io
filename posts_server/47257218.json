post_cb({"bq_ids": {"n4140": {"so_47257218_47260043_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 4503}}, "n3337": {"so_47257218_47260043_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 4334}}, "n4659": {"so_47257218_47260043_2": {"length": 4, "quality": 0.8, "section_id": 5660}}}, "47259119": {"Id": "47259119", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47257218_47259119_0\">The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a shared_ptr using the raw pointer overload for an object that is already managed by a shared_ptr, such as by <code>shared_ptr(ptr.get())</code> is likely to lead to undefined behavior, even if the object is of a type derived from <code>std::enable_shared_from_this</code>.\n  -- <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr</a></p>\n</blockquote>\n<p>In your case you get to shared pointers that have two different ownership information blocks but always increment the ref count of the first shared pointer instance of the class.</p>\n<p>If you remove the 'fake deleter' you'l get a double free problem.</p>\n", "LastEditorUserId": "8918119", "LastActivityDate": "2017-11-15T08:53:09.460", "Score": "1", "CreationDate": "2017-11-13T07:31:25.417", "ParentId": "47257218", "CommentCount": "0", "OwnerUserId": "8918119", "LastEditDate": "2017-11-15T08:53:09.460"}, "47260043": {"Id": "47260043", "PostTypeId": "2", "Body": "<h3><strong>On C++11 (and more generally, before C++17)</strong></h3>\n<p>the only thing we know is that:</p>\n<blockquote>\n<p id=\"so_47257218_47260043_0\"><strong>[util.smartptr.enab]</strong> shared_from_this();:</p>\n<p id=\"so_47257218_47260043_1\"><em>Requires:</em> enable_shared_from_this shall be an accessible base class of T. *this shall be a subobject of an object t of type T. <strong>There shall be at least one shared_ptr instance p that owns &amp;t.</strong></p>\n<p id=\"so_47257218_47260043_2\"><em>Returns:</em> A shared_ptr object r that shares ownership with p.</p>\n<p id=\"so_47257218_47260043_3\"><em>Postconditions:</em> r.get() == this.</p>\n</blockquote>\n<p>that if read literally, <strong>implies that it's unspecified if fc-&gt;shared_from_this() returns a copy of <code>rc</code> or <code>fc</code></strong> (although sane implementations will simply assign to the internal weak_ptr once, hence the behaviour should be the same as in the c++17 case, as you observed).</p>\n<hr>\n<h3><strong>From C++17 on</strong></h3>\n<p>the situation is clear: <code>enable_shared_from_this</code> is essentially a <code>weak_ptr</code> that gets assigned by the first <code>shared_ptr</code> constructor (or <code>make_shared</code> factory) that sees it's in an expired state.</p>\n<p>Hence, <code>rc</code> sets the <code>weak_ptr</code>, <code>fc</code> doesn't, <code>fc-&gt;shared_from_this()</code> returns a copy of <code>rc</code>. <code>fc.get()</code> will return a zombie pointer as soon as all <code>rc</code> copies get destroyed. <strong>Your observed behaviour is the right one</strong>.</p>\n<p>Note that all shared_ptr constructors taking a non null pointer (and at most a deleter and/or an allocator) will own the pointer and manage its lifetime, as if it were constructed anew, the only difference being that only the first one will assign to enable_shared_from_this's weak_ptr, if any.</p>\n</hr>", "LastEditorUserId": "8631381", "LastActivityDate": "2017-11-14T07:36:54.883", "Score": "0", "CreationDate": "2017-11-13T08:40:28.993", "ParentId": "47257218", "CommentCount": "0", "OwnerUserId": "8631381", "LastEditDate": "2017-11-14T07:36:54.883"}, "47257218": {"ViewCount": "117", "Body": "<p>Given this class which is <em>enable_shared_from_this</em>:</p>\n<pre><code>class connection : public std::enable_shared_from_this&lt;connection&gt;\n{\n   //...\n};\n</code></pre>\n<p>Suppose I create two instances of <code>std::shared_ptr</code> from the <em>same</em> <code>connection*</code> as follows:</p>\n<pre><code>std::shared_ptr&lt;connection&gt; rc(new connection);\n\nstd::shared_ptr&lt;connection&gt; fc(rc.get(), [](connection const * c) {\n                                   std::cout &lt;&lt; \"fake delete\" &lt;&lt; std::endl;\n                               });\n</code></pre>\n<p>So far its good, as  the resource { <code>connection*</code> } is owned by a <em>single</em> <code>shared_ptr</code> \u2014 <code>rc</code> to be precise, and <code>fc</code> just have a fake deleter.</p>\n<p>After that, I do this:</p>\n<pre><code>auto sc = fc-&gt;shared_from_this();\n//OR auto sc = rc-&gt;shared_from_this(); //does not make any difference!\n</code></pre>\n<p>Now which <code>shared_ptr</code> \u2014 <code>rc</code> or <code>fc</code> \u2014 would <code>sc</code>  share its <em>reference-count</em> with? In other words,</p>\n<pre><code>std::cout &lt;&lt; rc-&gt;use_count() &lt;&lt; std::endl;\nstd::cout &lt;&lt; fc-&gt;use_count() &lt;&lt; std::endl;\n</code></pre>\n<p>What should these print? I tested this code and <a href=\"http://coliru.stacked-crooked.com/a/b4b580257fb65b85\" rel=\"noreferrer\">found</a> <code>rc</code> seems to have <code>2</code> references while <code>fc</code> just <code>1</code>. </p>\n<p>My question is, why is that? and what should be the <em>correct</em> behavior and its <em>rationale</em>?</p>\n<p><strong>I'm using C++11 and GCC 4.7.3</strong>.</p>\n", "Title": "two shared_ptr from same enable_shared_from_this instance", "CreationDate": "2017-11-13T04:46:33.347", "LastActivityDate": "2017-11-15T08:53:09.460", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-11-13T06:20:41.483", "LastEditorUserId": "415784", "Id": "47257218", "Score": "6", "OwnerUserId": "415784", "Tags": "<c++><c++11><shared-ptr><reference-counting><weak-ptr>", "AnswerCount": "2"}});