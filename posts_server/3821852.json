post_cb({"3822007": {"ParentId": "3821852", "LastEditDate": "2010-09-29T14:29:06.663", "CommentCount": "3", "CreationDate": "2010-09-29T13:25:14.863", "OwnerUserId": "103167", "LastEditorUserId": "103167", "PostTypeId": "2", "Id": "3822007", "Score": "18", "Body": "<p>The language in the upcoming C++0x standard (section 5.3.5 <code>[expr.delete]</code>) is as follows:</p>\n<blockquote>\n<p id=\"so_3821852_3822007_0\">If the value of the operand of\n  the delete-expression is not a null\n  pointer value, the delete-expression\n  will call a  deallocation function\n  (3.7.4.2). Otherwise, it is\n  unspecified whether the deallocation\n  function will be called. [ Note: The\n  deallocation function is called\n  regardless of whether the destructor\n  for the object or some element of the\n  array throws an exception.  \u2014 end note ]</p>\n</blockquote>\n<p>So it is unspecified behavior, some compilers may call <code>operator delete</code> when a NULL pointer is deleted and others may not.</p>\n<p>EDIT: The term <em>deallocation function</em> used by the standard seems to be causing some confusion.  It comes with a reference.  Some key language from 3.7.4.2 <code>[basic.stc.dynamic.deallocation]</code> which may help clarify:</p>\n<blockquote>\n<p id=\"so_3821852_3822007_1\">If a class <code>T</code> has a member deallocation function named <code>operator delete</code>\n  with exactly one parameter, then that function is a usual (non-placement) deallocation function.</p>\n</blockquote>\n<p>The standard is also very clear that user-defined <code>operator delete</code> needs to accept a parameter which is a null pointer value:</p>\n<blockquote>\n<p id=\"so_3821852_3822007_2\">The value of the\n  first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation\n  function  is  one  supplied  in  the  standard  library,  the  call  has  no  effect.</p>\n</blockquote>\n<p>But because of the unspecified behavior 5.3.5, you shouldn't rely on your <code>operator delete</code> being called when the pointer is null.</p>\n", "LastActivityDate": "2010-09-29T14:29:06.663"}, "bq_ids": {"n4140": {"so_3821852_3822007_1": {"section_id": 7181, "quality": 1.0, "length": 16}, "so_3821852_3822007_0": {"section_id": 6111, "quality": 0.8285714285714286, "length": 29}, "so_3821852_3822007_2": {"section_id": 7182, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_3821852_3822007_1": {"section_id": 6925, "quality": 1.0, "length": 16}, "so_3821852_3822007_0": {"section_id": 5877, "quality": 0.8285714285714286, "length": 29}, "so_3821852_3822007_2": {"section_id": 6926, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_3821852_3822007_1": {"section_id": 8537, "quality": 0.5625, "length": 9}, "so_3821852_3822007_0": {"section_id": 7608, "quality": 0.7142857142857143, "length": 25}, "so_3821852_3822007_2": {"section_id": 8690, "quality": 0.9444444444444444, "length": 17}}}, "3821869": {"ParentId": "3821852", "CommentCount": "4", "Body": "<p>Operator delete is just like any other operator, why wouldn't it be invoked? It can't examine its arguments <em>before</em> being invoked.</p>\n<p>This is like asking why <code>operator+</code> is invoked when you're adding 0.</p>\n", "OwnerUserId": "39375", "PostTypeId": "2", "Id": "3821869", "Score": "10", "CreationDate": "2010-09-29T13:07:58.260", "LastActivityDate": "2010-09-29T13:07:58.260"}, "3821852": {"CommentCount": "4", "CreationDate": "2010-09-29T13:05:56.157", "PostTypeId": "1", "AcceptedAnswerId": "3822007", "LastEditorUserId": "-1", "LastActivityDate": "2010-09-29T14:29:06.663", "LastEditDate": "2017-05-23T12:22:26.663", "ViewCount": "621", "FavoriteCount": "1", "Title": "Why is \"operator delete\" invoked when I call \"delete\" on a null pointer?", "Id": "3821852", "Score": "16", "Body": "<p>While reading answers to <a href=\"https://stackoverflow.com/questions/3821261/null-check-before-deleting-an-object\">this question</a> I noticed that answers (<a href=\"https://stackoverflow.com/questions/3821261/null-check-before-deleting-an-object/3821277#3821277\">this</a> for example) imply that <code>operator delete</code> can be called even when <code>delete</code> statement is executed on a null pointer.</p>\n<p>So I wrote a small snippet:</p>\n<pre><code>class Test {\npublic:\n    void* operator new( size_t ) { /*doesn't matter*/ return 0; }\n    void operator delete( void* ptr ) {\n        ptr; //to suppress warning and have a line to put breakpoint on\n    }\n};\n\nint main()\n{\n    Test* ptr = 0;\n    delete ptr;\n}\n</code></pre>\n<p>and - surprisingly for me - <code>Test::operator delete()</code> is invoked with <code>ptr</code> holding a null pointer.</p>\n<p>As I understand it <code>operator new</code> allocates memory and <code>operator delete</code> returns memory to the allocator. If I call <code>delete</code> statement on a null pointer it means there was no object behind the pointer and there's no memory to return to the allocator.</p>\n<p><code>delete</code> statement includes invoking a destructor. When I pass a null pointer the destructor is surely not invoked - C++ takes care of that. Then why is <code>operator delete</code> invoked in this case?</p>\n", "Tags": "<c++><pointers><memory-management>", "OwnerUserId": "57428", "AnswerCount": "2"}});