post_cb({"18521108": {"Id": "18521108", "PostTypeId": "2", "Body": "<p>I think you are misunderstanding the scope of the deadlock avoidance. That's understandable since the text seems to mention <code>lock</code> in two different contexts, the \"multi-lock\" <code>std::lock</code> and the individual locks carried out by that \"multi-lock\" (however the lockables implement it). The text for <code>std::lock</code> states:</p>\n<blockquote>\n<p id=\"so_18520983_18521108_0\">All <strong>arguments</strong> are locked via a sequence of calls to lock(), try_lock(),or unlock() <strong>on each argument.</strong> The sequence of calls shall not result in deadlock</p>\n</blockquote>\n<p>If you call <code>std::lock</code> passing ten different lockables, the standard guarantees no deadlock <em>for that call.</em> It's not guaranteed that deadlock is avoided if you lock the lockables outside the control of <code>std::lock</code>. That means thread 1 locking A then B can deadlock against thread 2 locking B then A. That was the case in your original third example, which had (pseudo-code):</p>\n<pre><code>Thread 1     Thread 2\nlock A       lock B\nlock B       lock A\n</code></pre>\n<p>As that couldn't have been <code>std::lock</code> (it only locked one resource), it must have been something like <code>unique_lock</code>.</p>\n<p>The deadlock avoidance <em>will</em> occur if both threads attempt to lock A/B and B/A in a <em>single</em> call to <code>std::lock</code>, as per your first example. Your second example won't deadlock either since thread 1 will be backing off if the second lock is needed by a thread 2 already having the first lock. Your updated third example:</p>\n<pre><code>Thread 1                  Thread 2\nstd::lock(lock1,lock2);   std::lock(lock3,lock4);\nstd::lock(lock3,lock4);   std::lock(lock1,lock2);\n</code></pre>\n<p>still has the possibility of deadlock since the atomicity of the lock is a <em>single</em> call to <code>std::lock</code>. For example, if thread 1 successfully locks <code>lock1</code> and <code>lock2</code>, then thread 2 successfully locks <code>lock3</code> and <code>lock4</code>, deadlock will ensue as both threads attempt to lock the resource held by the other.</p>\n<p>So, in answer to your specific questions:</p>\n<p>1/ Yes, I think you've misunderstood what the standard is saying. The sequence it talks about is clearly the sequence of locks carried out on the individual lockables passed to a <em>single</em> <code>std::lock</code>.</p>\n<p>2/ As to what they were thinking, it's sometimes hard to tell :-) But I would posit that they wanted to give us capabilities that we would otherwise have to write ourselves. Yes, back-off-and-retry may not be an ideal strategy but, if you <em>need</em> the deadlock avoidance functionality, you may have to pay the price. Better for the implementation to provide it rather than it having to be written over and over again by developers.</p>\n<p>3/ No, there's no need to avoid it. I don't think I've ever found myself in a situation where simple manual ordering of locks wasn't possible but I don't discount the possibility. If you do find yourself in that situation, this can assist (so you don't have to code up your own deadlock avoidance stuff).</p>\n<hr>\n<p>In regard to the comments that back-off-and-retry is a problematic strategy, yes, that's correct. But you may be missing the point that it may be <em>necessary</em> if, for example, you cannot enforce the ordering of the locks before-hand.</p>\n<p>And it doesn't <em>have</em> to be as bad as you think. Because the locks can be done in any order by <code>std::lock</code>, there's nothing stopping the implementation from re-ordering after each backoff to  bring the \"failing\" lockable to the front of the list. That would mean those that were locked would tend to gather at the front, so that the <code>std::lock</code> would be less likely to be claiming resources unnecessarily.</p>\n<p>Consider the call <code>std::lock (a, b, c, d, e, f)</code> in which <code>f</code> was the only lockable that was already locked. In the first lock attempt, that call would lock <code>a</code> through <code>e</code> then \"fail\" on <code>f</code>.</p>\n<p>Following the back-off (unlocking <code>a</code> through <code>e</code>), the list to lock would be changed to <code>f, a, b, c, d, e</code> so that subsequent iterations would be less likely to unnecessarily lock. That's not fool-proof since other resources may be locked or unlocked between iterations, but it <em>tends</em> towards success.</p>\n<p>In fact, it may even order the list initially by checking the states of all lockables so that all those currently locked are up the front. That would start the \"tending toward success\" operation earlier in the process.</p>\n<p>That's just <em>one</em> strategy, there may well be others, even better. That's why the standard didn't mandate <em>how</em> it was to be done, on the off-chance there may be some genius out there who comes up with a better way.</p>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2013-08-31T04:04:47.287", "Score": "30", "CreationDate": "2013-08-29T21:16:03.633", "ParentId": "18520983", "CommentCount": "5", "OwnerUserId": "14860", "LastEditDate": "2013-08-31T04:04:47.287"}, "18520983": {"ViewCount": "3778", "Body": "<p>(Note: Much of this is redundant with commentary on <a href=\"https://stackoverflow.com/questions/13667810/\">Massive CPU load using std::lock (c++11)</a>, but I think this topic deserves its own question and answers.)</p>\n<p>I recently encountered some sample C++11 code that looked something like this:</p>\n<pre><code>std::unique_lock&lt;std::mutex&gt; lock1(from_acct.mutex, std::defer_lock);\nstd::unique_lock&lt;std::mutex&gt; lock2(to_acct.mutex, std::defer_lock);\nstd::lock(lock1, lock2); // avoid deadlock\ntransfer_money(from_acct, to_acct, amount);\n</code></pre>\n<p>Wow, I thought, <code>std::lock</code> sounds interesting. I wonder what the standard says it does?</p>\n<p>C++11 section 30.4.3 [thread.lock.algorithm], paragraphs (4) and (5):</p>\n<blockquote>\n<p id=\"so_18520983_18520983_0\"><strong>template  void lock(L1&amp;, L2&amp;, L3&amp;...);</strong></p>\n<p id=\"so_18520983_18520983_1\">4 <em>Requires:</em> Each template parameter type shall meet the Lockable\n  requirements, [ Note: The <code>unique_lock</code> class template meets these\n  requirements when suitably instantiated. \u2014 end note ]</p>\n<p id=\"so_18520983_18520983_2\">5 <em>Effects:</em> All arguments are locked via a sequence of calls to <code>lock()</code>,\n  <code>try_lock()</code>, or <code>unlock()</code> on each argument. The sequence of calls shall\n  not result in deadlock, but is otherwise unspecifed. [ Note: A\n  deadlock avoidance algorithm such as try-and-back-off must be used, but\n  the specifc algorithm is not specifed to avoid over-constraining\n  implementations. \u2014 end note ] If a call to <code>lock()</code> or <code>try_lock()</code> throws\n  an exception, <code>unlock()</code> shall be called for any argument that had been\n  locked by a call to <code>lock()</code> or <code>try_lock()</code>.</p>\n</blockquote>\n<p>Consider the following example. Call it \"Example 1\":</p>\n<pre><code>Thread 1                    Thread 2\nstd::lock(lock1, lock2);    std::lock(lock2, lock1);\n</code></pre>\n<p>Can this deadlock?</p>\n<p>A plain reading of the standard says \"no\". Great! Maybe the compiler can order my locks for me, which would be kind of neat.</p>\n<p>Now try Example 2:</p>\n<pre><code>Thread 1                                  Thread 2\nstd::lock(lock1, lock2, lock3, lock4);    std::lock(lock3, lock4);\n                                          std::lock(lock1, lock2);\n</code></pre>\n<p>Can this deadlock?</p>\n<p>Here again, a plain reading of the standard says \"no\". Uh oh. The only way to do that is with some kind of back-off-and-retry loop. More on that below.</p>\n<p>Finally, Example 3:</p>\n<pre><code>Thread 1                          Thread 2\nstd::lock(lock1,lock2);           std::lock(lock3,lock4);\nstd::lock(lock3,lock4);           std::lock(lock1,lock2);\n</code></pre>\n<p>Can this deadlock?</p>\n<p>Once again, a plain reading of the standard says \"no\". (If the \"sequence of calls to <code>lock()</code>\" in one of these invocations is not \"resulting in deadlock\", what is, exactly?) However, I am pretty sure this is unimplementable, so I suppose it's not what they meant.</p>\n<p>This appears to be one of the worst things I have ever seen in a C++ standard. I am guessing it started out as an interesting idea: Let the compiler assign a lock ordering. But once the committee chewed it up, the result is either unimplementable or requires a retry loop. And yes, that is a bad idea.</p>\n<p>You can argue that \"back off and retry\" is sometimes useful. That is true, but only when you do not know which locks you are trying to grab up front. For example, if the identity of the second lock depends on data protected by the first (say because you are traversing some hierarchy), then you might have to do some grab-release-grab spinning. But in that case you cannot use this gadget, because you do not know all of the locks up front. On the other hand, if you <em>do</em> know which locks you want up front, then you (almost) always want simply to impose an ordering, not to loop.</p>\n<p>Also, note that Example 1 can live-lock if the implementation simply grabs the locks in order, backs off, and retries.</p>\n<p>In short, this gadget strikes me as useless at best. Just a bad idea all around.</p>\n<p>OK, questions. (1) Are any of my claims or interpretations wrong? (2) If not, what the heck were they thinking? (3) Should we all agree that \"best practice\" is to avoid <code>std::lock</code> completely?</p>\n<p>[Update]</p>\n<p>Some answers say I am misinterpreting the standard, then go on to interpret it the same way I did, then confuse the specification with the implementation.</p>\n<p>So, just to be clear:</p>\n<p>In my reading of the standard, Example 1 and Example 2 cannot deadlock. Example 3 can, but only because avoiding deadlock in that case is unimplementable.</p>\n<p>The entire point of my question is that avoiding deadlock for Example 2 requires a back-off-and-retry loop, and such loops are extremely poor practice. (Yes, some sort of static analysis on this trivial example could make that avoidable, but not in the general case.) Also note that GCC implements this thing as a busy loop.</p>\n<p>[Update 2]</p>\n<p>I think a lot of the disconnect here is a basic difference in philosophy.</p>\n<p>There are two approaches to writing software, especially multi-threaded software.</p>\n<p>In one approach, you throw a bunch of stuff together and run it to see how well it works. You are never convinced that your code has a problem unless someone can demonstrate that problem on a real system, right now, today.</p>\n<p>In the other approach, you write code that can be rigorously analyzed to prove that it has no data races, that all of its loops terminate with probability 1, and so forth. You perform this analysis strictly within the machine model guaranteed by the language spec, not on any particular implementation.</p>\n<p>Advocates of the latter approach are not impressed by any demonstrations on particular CPUs, compilers, compiler minor versions, operating systems, runtimes, etc. Such demonstrations are barely interesting and totally irrelevant. If your <em>algorithm</em> has a data race, it is broken, no matter what happens when you run it. If your <em>algorithm</em> has a livelock, it is broken, no matter what happens when you run it. And so forth.</p>\n<p>In my world, the second approach is called \"Engineering\". I am not sure what the first approach is called.</p>\n<p>As far as I can tell, the <code>std::lock</code> interface is useless for Engineering. I would love to be proven wrong.</p>\n", "AcceptedAnswerId": "18521108", "Title": "Is std::lock() ill-defined, unimplementable, or useless?", "CreationDate": "2013-08-29T21:06:55.683", "Id": "18520983", "CommentCount": "34", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:47:21.150", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-30T12:54:55.167", "Score": "20", "OwnerUserId": "768469", "Tags": "<c++><multithreading><c++11><language-lawyer>", "AnswerCount": "4"}, "18521611": {"Id": "18521611", "PostTypeId": "2", "Body": "<p>Perhaps it would help if you thought of each individual call to <code>std::lock(x, y, ...)</code> as atomic.  It will block until it can lock all of its arguments.  If you don't know all of the mutexes you need to lock a-priori, do not use this function.  If you do know, then you can safely use this function, without having to order your locks.</p>\n<p>But by all means order your locks if that is what you prefer to do.</p>\n<pre><code>Thread 1                    Thread 2\nstd::lock(lock1, lock2);    std::lock(lock2, lock1);\n</code></pre>\n<p>The above will not deadlock.  One of the threads will get both locks, and the other thread will block until the first one has released the locks.</p>\n<pre><code>Thread 1                                  Thread 2\nstd::lock(lock1, lock2, lock3, lock4);    std::lock(lock3, lock4);\n                                          std::lock(lock1, lock2);\n</code></pre>\n<p>The above will not deadlock.  Though this is tricky.  If Thread 2 gets lock3 and lock4 before Thread1 does, then Thread 1 will block until Thread 2 releases all 4 locks.  If Thread 1 gets the four locks first, then Thread 2 will block at the point of locking lock3 and lock4 until Thread 1 releases all 4 locks.</p>\n<pre><code>Thread 1                          Thread 2\nstd::lock(lock1,lock2);           std::lock(lock3,lock4);\nstd::lock(lock3,lock4);           std::lock(lock1,lock2);\n</code></pre>\n<p>Yes, the above can deadlock.  You can view the above as exactly equivalent to:</p>\n<pre><code>Thread 1                          Thread 2\nlock12.lock();                    lock34.lock();\nlock34.lock();                    lock12.lock();\n</code></pre>\n<p><strong>Update</strong></p>\n<p>I believe a misunderstanding is that dead-lock and live-lock are both correctness issues.</p>\n<p>In actual practice, dead-lock is a correctness issue, as it causes the process to freeze.  And live-lock is a performance issue, as it causes the process to slow down, but it still completes its task correctly.  The reason is that live-lock will not (in practice) sustain itself indefinitely.</p>\n<p><code>&lt;disclaimer&gt;</code>\nThere are forms of live-lock that can be created which are permanent, and thus equivalent to dead-lock.  This answer does not address such code, and such code is not relevant to this issue.\n<code>&lt;/disclaimer&gt;</code></p>\n<p>The yield shown in <a href=\"https://stackoverflow.com/a/14525010/576911\">this answer</a> is a significant performance optimization which significantly decreases live-lock, and thus significantly increases the performance of <code>std::lock(x, y, ...)</code>.</p>\n<p><strong>Update 2</strong></p>\n<p>After a long delay, I have written a first draft of a paper on this subject.  The paper compares 4 different ways of getting this job done.  It contains software you can copy and paste into your own code and test yourself:</p>\n<p><a href=\"http://howardhinnant.github.io/dining_philosophers.html\" rel=\"nofollow noreferrer\">http://howardhinnant.github.io/dining_philosophers.html</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-21T20:02:26.737", "Score": "17", "CreationDate": "2013-08-29T21:55:29.550", "ParentId": "18520983", "CommentCount": "10", "OwnerUserId": "576911", "LastEditDate": "2017-05-23T12:26:25.580"}, "bq_ids": {"n4140": {"so_18520983_18520983_1": {"length": 15, "quality": 0.75, "section_id": 2964}, "so_18520983_18521108_0": {"length": 14, "quality": 0.875, "section_id": 2968}, "so_18520983_18520983_2": {"length": 42, "quality": 0.84, "section_id": 2968}, "so_18520983_18521272_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 2968}}, "n3337": {"so_18520983_18520983_1": {"length": 15, "quality": 0.75, "section_id": 2833}, "so_18520983_18521108_0": {"length": 14, "quality": 0.875, "section_id": 2837}, "so_18520983_18520983_2": {"length": 42, "quality": 0.84, "section_id": 2837}, "so_18520983_18521272_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 2837}}, "n4659": {"so_18520983_18520983_1": {"length": 15, "quality": 0.75, "section_id": 3722}, "so_18520983_18521108_0": {"length": 14, "quality": 0.875, "section_id": 3726}, "so_18520983_18520983_2": {"length": 42, "quality": 0.84, "section_id": 3726}, "so_18520983_18521272_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 3726}}}, "18521272": {"Id": "18521272", "PostTypeId": "2", "Body": "<p>Your confusion with the standardese seems to be due to this statement</p>\n<blockquote>\n<p id=\"so_18520983_18521272_0\">5 <em>Effects:</em> All arguments are locked via a sequence of calls to <code>lock()</code>,\n  <code>try_lock()</code>, or <code>unlock()</code> on each argument.</p>\n</blockquote>\n<p>That does not imply that <code>std::lock</code> will recursively call itself with each argument to the original call. </p>\n<p>Objects that satisfy the <em>Lockable</em> concept (<em>\u00a730.2.5.4</em> [thread.req.lockable.req]) must implement all 3 of those member functions. <code>std::lock</code> will invoke these member functions on each argument, in an unspecified order, to attempt to acquire a lock on all objects, while doing something implementation defined to avoid deadlock.</p>\n<p>Your example 3 has a potential for deadlock because you're not issuing a single call to <code>std::lock</code> with all objects that you want to acquire a lock on.</p>\n<p>Example 2 will <em>not</em> cause a deadlock, Howard's <a href=\"https://stackoverflow.com/a/18521611/241631\">answer</a> explains why.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-30T11:04:00.193", "Score": "4", "CreationDate": "2013-08-29T21:29:39.443", "ParentId": "18520983", "CommentCount": "3", "OwnerUserId": "241631", "LastEditDate": "2017-05-23T11:47:21.150"}, "29968333": {"Id": "29968333", "PostTypeId": "2", "Body": "<p>Did C++11 adopt this function from Boost?</p>\n<p>If so, Boost's description is instructive (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18520983_29968333_0\"><em>Effects:</em> Locks the Lockable objects supplied as arguments in an unspecified and\n  indeterminate order in a way that avoids deadlock. <strong>It is safe to call\n  this function concurrently from multiple threads with the same mutexes\n  (or other lockable objects) in different orders without risk of\n  deadlock.</strong> If any of the lock() or try_lock() operations on the\n  supplied Lockable objects throws an exception any locks acquired by\n  the function will be released before the function exits.</p>\n</blockquote>\n", "LastActivityDate": "2015-04-30T12:54:55.167", "CommentCount": "5", "CreationDate": "2015-04-30T12:54:55.167", "ParentId": "18520983", "Score": "1", "OwnerUserId": "193887"}});