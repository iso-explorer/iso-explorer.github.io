post_cb({"13630331": {"ParentId": "13629552", "CommentCount": "8", "Body": "<p>Apologies for the earlier, incorrect answer. The example does indeed seem to be correct, and there is actually a similar example in the standard itself (C++11, 14.5.6.1/1-2). Let me just quote it in its entirety:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_13629552_13630331_0\">It is possible to overload function templates so that two different function template specializations have the same type. [ <em>Example:</em></p>\n<pre><code>// file1.c\n\ntemplate&lt;class T&gt; void f(T*);\n\nvoid g(int* p) {\n    f(p); // calls f&lt;int&gt;(int*)\n}\n\n\n// file2.c\n\ntemplate&lt;class T&gt; void f(T);\n\nvoid h(int* p) {\n    f(p); // calls f&lt;int*&gt;(int*)\n}\n</code></pre>\n<p id=\"so_13629552_13630331_1\">\u2014 <em>end example</em> ]</p></li>\n<li>Such specializations are distinct functions and do not violate the one definition rule (3.2).</li>\n</ol>\n</blockquote>\n<p>In your case, you have two different function templates, both called <code>f1</code> (which is fine because you can overload function templates), and they happen to have specializations which have the same type.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "13630331", "Score": "8", "CreationDate": "2012-11-29T16:32:26.837", "LastActivityDate": "2012-11-29T16:32:26.837"}, "bq_ids": {"n4140": {"so_13629552_13629552_0": {"section_id": 147, "quality": 0.7777777777777778, "length": 7}, "so_13629552_13630331_0": {"section_id": 153, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_13629552_13629552_0": {"section_id": 141, "quality": 0.7777777777777778, "length": 7}, "so_13629552_13630331_0": {"section_id": 147, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_13629552_13630331_0": {"section_id": 157, "quality": 0.9230769230769231, "length": 12}, "so_13629552_13629552_0": {"section_id": 350, "quality": 0.7777777777777778, "length": 7}}}, "13629552": {"CommentCount": "11", "AcceptedAnswerId": "13630331", "PostTypeId": "1", "LastEditorUserId": "368896", "CreationDate": "2012-11-29T15:53:13.807", "LastActivityDate": "2012-11-29T21:06:51.407", "LastEditDate": "2012-11-29T21:06:51.407", "ViewCount": "1008", "FavoriteCount": "7", "Title": "From Josuttis: Do different template functions, that instantiate to the same function signature given particular types, result in ODR invalidity?", "Id": "13629552", "Score": "13", "Body": "<p>In Josuttis' and Vandevoorde's well-known book on templates, <a href=\"http://amzn.com/0201734842\" rel=\"noreferrer\">C++ Templates: The Complete Guide</a>, they discuss details regarding the overloading of function templates.</p>\n<p>In one of their examples, related to a discussion of function signatures and overloaded function templates, they present code that they describe in the following terms:</p>\n<pre><code>This program is valid and produces the following output:\n\n(Note: Output shown below)\n</code></pre>\n<p>However, when I build and compile the identical code in Visual Studio 2010, I get a different result.  This leads me to believe that either the VS 2010 compiler is producing incorrect code, or that Josuttis is incorrect that the code is valid.</p>\n<p>Here is the code.  (Josuttis 2003, Section 12.2.1)</p>\n<pre><code>// File1.cpp\n\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T1, typename T2&gt;\nvoid f1(T2, T1)\n{\n    std::cout &lt;&lt; \"f1(T2, T1)\" &lt;&lt; std::endl;\n}\n\nextern void g();\n\nint main()\n{\n    f1&lt;char, char&gt;('a', 'b');\n    g();\n}\n</code></pre>\n<p>...</p>\n<pre><code>// File2.cpp\n\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T1, typename T2&gt;\nvoid f1(T1, T2)\n{\n    std::cout &lt;&lt; \"f1(T1, T2)\" &lt;&lt; std::endl;\n}\n\nvoid g()\n{\n    f1&lt;char, char&gt;('a', 'b');\n}\n</code></pre>\n<p>(Notice the reversal of type arguments in the two template function definitions.  Note also that this reversal has no effect when the two type arguments are the same, as they are for the two functions <code>f1()</code> in this code example.)</p>\n<p>According to Josuttis:</p>\n<pre><code>This program is valid and produces the following output:\n\nf1(T2, T1)\nf1(T1, T2)\n</code></pre>\n<p>When I build and run the identical code, unchanged, in the Visual Studio 2010 compiler, here is my result:</p>\n<pre><code>f1(T1, T2)\nf1(T1, T2)\n</code></pre>\n<p>Further, I was wondering how it is possible for the compiler/linker to distinguish between the function <code>f1</code> as instantiated in file1.cpp, and the function <code>f1</code> as instantiated in file2.cpp, given that (I think) the compiler strips away all \"knowledge\" of the fact that these functions were created from templates, and has only the information (I think) of the function signature itself: <code>void (char, char)</code>, which is the same for both <code>f1</code> functions.</p>\n<p>Since (if I'm correct) the function signature is identical in the two translation units, I would think that this is an example of a violation of the <a href=\"http://en.wikipedia.org/wiki/One_definition_rule\" rel=\"noreferrer\">One Definition Rule</a> (ODR), and that it would therefore be invalid C++.</p>\n<p>However, as I've just noted, Josuttis and Vandevoorde claim that this is <em>valid</em> C++.</p>\n<p>But since my compiled version of the same code gives <em>different</em> results than Josuttis claims is the output, this seems to be an indication that either VS 2010 is producing incorrect code, or Josuttis is incorrect in this case (i.e., the code is invalid and violates the ODR).</p>\n<p>Are Josuttis and Vandevoorde incorrect, or is VS 2010 producing incorrect output?  Or is there some other explanation that explains the discrepancy between the output VS 2010 produces, and the output Josuttis reports?</p>\n<p>It might be of interest to show the VS 2010 disassembly at the point that each <code>f1()</code> is called.</p>\n<p>The first call of <code>f1()</code> (directly within <code>main()</code>):</p>\n<p><img alt=\"f1() called directly from within main()\" src=\"https://i.stack.imgur.com/8QJAN.png\"/></p>\n<p>The second call of <code>f1()</code> (from within <code>g()</code>):</p>\n<p><img alt=\"f1() called from within g()\" src=\"https://i.stack.imgur.com/xM4y6.png\"/></p>\n<p>Note that the address of <code>f1()</code> chosen by the compiler in both cases is the same - 13E11EAh.  To me, this indicates that in fact, the compiler cannot distinguish between the two instantiated function signatures, and this is a case where the ODR is being violated, so the code is <em>invalid C++</em> and Josuttis has an error in his book.  But it's just that - an indication.  I don't know.</p>\n<p>(I have checked the errata on the book's website, and there is no mention of this example.)</p>\n<p><strong>ADDENDUM</strong> Per a request from a comment, I am attaching relevant output from the .map file for this program that shows the mangled name/s being used for <code>f1</code>:</p>\n<p><img alt=\".map file output showing mangled names for &lt;code&gt;f1&lt;/code&gt;\" src=\"https://i.stack.imgur.com/GI4tB.png\"/></p>\n<p><strong>ADDENDUM 2</strong> Now that the question is answered - Josuttis' book is correct - I want to note that in the Josuttis text, in the same section (12.2.1), it is explicitly outlined exactly what determines a unique function signature, <em>including the template aspect</em>.</p>\n<p>From the text (among the other, expected things that define a function signature), the TRANSLATION UNIT is part of the function signature; for template functions (only) the RETURN TYPE is part of the function signature, and</p>\n<blockquote>\n<p id=\"so_13629552_13629552_0\">.6. The template parameters and the template arguments, if the function is generated from a function template.</p>\n</blockquote>\n<p>Therefore - it is clear.  Template information must be maintained and tracked by the compiler even after a function template has been instantiated, in order for the compiler/linker to obey the necessary, special rules for templates (as in the case of the code example in my question).</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "368896", "AnswerCount": "1"}});