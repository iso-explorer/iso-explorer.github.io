post_cb({"bq_ids": {"n4140": {"so_24109737_24109800_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 5446}, "so_24109737_24109800_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 5445}}, "n4659": {"so_24109737_24109800_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 6873}, "so_24109737_24109800_0": {"length": 16, "quality": 0.6666666666666666, "section_id": 6872}}}, "24109944": {"Id": "24109944", "PostTypeId": "2", "LastEditDate": "2014-06-09T00:12:30.760", "CommentCount": "6", "LastEditorUserId": "2352671", "LastActivityDate": "2014-06-09T00:12:30.760", "CreationDate": "2014-06-08T19:22:05.327", "ParentId": "24109737", "Score": "18", "Body": "<p>Quoting stuff from <a href=\"https://isocpp.org/wiki/faq/cpp14-language#decltype-auto\">here</a>:</p>\n<ul>\n<li><p><code>decltype(auto)</code> is primarily useful for <strong>deducing the return type of forwarding functions and similar wrappers</strong>, where you want the type to exactly \u201ctrack\u201d some expression you\u2019re invoking. </p></li>\n<li><p>For example, given the functions below:</p></li>\n</ul>\n<hr>\n<pre><code>   string  lookup1();\n   string&amp; lookup2();\n</code></pre>\n<hr>\n<ul>\n<li>In C++11 we could write the following wrapper functions which remember to preserve the reference-ness of the return type:</li>\n</ul>\n<hr>\n<pre><code>   string  look_up_a_string_1() { return lookup1(); }\n   string&amp; look_up_a_string_2() { return lookup2(); }\n</code></pre>\n<hr>\n<ul>\n<li>In C++14, we can automate that:</li>\n</ul>\n<hr>\n<pre><code>   decltype(auto) look_up_a_string_1() { return lookup1(); }\n   decltype(auto) look_up_a_string_2() { return lookup2(); }\n</code></pre>\n<hr>\n<ul>\n<li><p>However, <code>decltype(auto)</code> is not intended to be a widely used feature beyond that. </p></li>\n<li><p>In particular, although it can be used to <strong>declare local variables</strong>, doing that is probably just an antipattern since a local variable\u2019s reference-ness should not depend on the initialization expression. </p></li>\n<li><p>Also, it is sensitive to how you write the return statement.</p></li>\n<li><p>For example, the two functions below have different return types:</p></li>\n</ul>\n<hr>\n<pre><code>   decltype(auto) look_up_a_string_1() { auto str = lookup1(); return str; }\n   decltype(auto) look_up_a_string_2() { auto str = lookup2(); return(str); }\n</code></pre>\n<hr>\n<ul>\n<li>The first returns <code>string</code>, the second returns <code>string&amp;</code>, which is a reference to the local variable <code>str</code>.</li>\n</ul>\n<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html\">proposal</a> you can see more intended uses.</p>\n</hr></hr></hr></hr></hr></hr></hr></hr>", "OwnerUserId": "2352671"}, "24109800": {"Id": "24109800", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:02:21.550", "CommentCount": "5", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-08T19:55:50.397", "CreationDate": "2014-06-08T19:07:49.103", "ParentId": "24109737", "Score": "87", "Body": "<h2>Return type forwarding in generic code</h2>\n<p>For non-generic code, like the initial example you gave, you can manually select to get a reference as a return type:</p>\n<pre><code>auto const&amp; Example(int const&amp; i) \n{ \n    return i; \n}\n</code></pre>\n<p>but in <strong>generic code</strong> you want to be able to <strong>perfectly forward a return type</strong> without knowing whether you are dealing with a reference or a value. <code>decltype(auto)</code> gives you that ability:</p>\n<pre><code>template&lt;class Fun, class... Args&gt;\ndecltype(auto) Example(Fun fun, Args&amp;&amp;... args) \n{ \n    return fun(std::forward&lt;Args&gt;(args)...); \n}\n</code></pre>\n<h2>Delaying return type deduction in recursive templates</h2>\n<p>In <a href=\"https://stackoverflow.com/q/24036357/819272\"><strong>this Q&amp;A</strong></a> a few days ago, an infinite recursion during template instantiation was encountered when the return type of the template was specified as <code>decltype(iter(Int&lt;i-1&gt;{}))</code> instead of <code>decltype(auto)</code>.</p>\n<pre><code>template&lt;int i&gt; \nstruct Int {};\n\nconstexpr auto iter(Int&lt;0&gt;) -&gt; Int&lt;0&gt;;\n\ntemplate&lt;int i&gt;\nconstexpr auto iter(Int&lt;i&gt;) -&gt; decltype(auto) \n{ return iter(Int&lt;i-1&gt;{}); }\n\nint main() { decltype(iter(Int&lt;10&gt;{})) a; }\n</code></pre>\n<p><code>decltype(auto)</code> is used here to <strong>delay the return type deduction</strong> after the dust of template instantiation has settled.</p>\n<h2>Other uses</h2>\n<p>You can also use <code>decltype(auto)</code> in other contexts, e.g. the draft Standard <a href=\"https://github.com/cplusplus/draft/blob/master/papers/N3936.pdf\" rel=\"noreferrer\"><strong>N3936</strong></a> also states</p>\n<p><strong>7.1.6.4 auto speci\ufb01er [dcl.spec.auto]</strong></p>\n<blockquote>\n<p id=\"so_24109737_24109800_0\">1 The <code>auto</code> and <code>decltype(auto)</code> type-speci\ufb01ers designate a placeholder\n  type that will be replaced later, either by deduction from an\n  initializer or by explicit speci\ufb01cation with a trailing-return-type.\n  The <code>auto</code> type-speci\ufb01er is also used to signify that a lambda is a\n  generic lambda.</p>\n<p id=\"so_24109737_24109800_1\">2 The placeholder type <strong>can appear</strong> with a function declarator in the decl-specifier-seq, type-specifier-seq,\n  conversion-function-id, or trailing-return-type, <strong>in any context where such a declarator is valid</strong>. If the function\n  declarator includes a trailing-return-type (8.3.5), that specifies the declared return type of the function.\n  If the declared return type of the function contains a placeholder type, the return type of the function is\n  deduced from return statements in the body of the function, if any.</p>\n</blockquote>\n<p>The draft also contains this example of variable initialization:</p>\n<pre><code>int i;\nint&amp;&amp; f();\nauto x3a = i;                  // decltype(x3a) is int\ndecltype(auto) x3d = i;        // decltype(x3d) is int\nauto x4a = (i);                // decltype(x4a) is int\ndecltype(auto) x4d = (i);      // decltype(x4d) is int&amp;\nauto x5a = f();                // decltype(x5a) is int\ndecltype(auto) x5d = f();      // decltype(x5d) is int&amp;&amp;\nauto x6a = { 1, 2 };           // decltype(x6a) is std::initializer_list&lt;int&gt;\ndecltype(auto) x6d = { 1, 2 }; // error, { 1, 2 } is not an expression\nauto *x7a = &amp;i;                // decltype(x7a) is int*\ndecltype(auto)*x7d = &amp;i;       // error, declared type is not plain decltype(auto)\n</code></pre>\n", "OwnerUserId": "819272"}, "24109737": {"ViewCount": "23926", "LastEditDate": "2015-08-22T13:40:28.757", "AcceptedAnswerId": "24109800", "Title": "What are some uses of decltype(auto)?", "CreationDate": "2014-06-08T19:00:32.220", "LastActivityDate": "2015-08-22T13:40:28.757", "CommentCount": "6", "Body": "<p>In c++14 the <code>decltype(auto)</code> idiom is introduced. </p>\n<p>Typically its use is to <strong>allow <code>auto</code> declarations to use the <code>decltype</code> rules on the given expression</strong>. </p>\n<p>Searching for examples of \"good\" usage of the idiom I can only think of things like the following (by <a href=\"http://scottmeyers.blogspot.gr/2013/07/when-decltype-meets-auto.html\" rel=\"noreferrer\">Scott Meyers</a>), namely for <strong>a function's return type deduction</strong>:</p>\n<pre><code>template&lt;typename ContainerType, typename IndexType&gt;                // C++14\ndecltype(auto) grab(ContainerType&amp;&amp; container, IndexType&amp;&amp; index)\n{\n  authenticateUser();\n  return std::forward&lt;ContainerType&gt;(container)[std::forward&lt;IndexType&gt;(index)];\n}\n</code></pre>\n<p>Are there any other examples where this new language feature is useful?</p>\n<hr>\n<p>My initial example was like this : </p>\n<pre><code>decltype(auto) Example(int const&amp; i) { \n    return i; // return type will be \"int const&amp;\"\n}\n</code></pre>\n</hr>", "PostTypeId": "1", "LastEditorUserId": "2567683", "Id": "24109737", "AnswerCount": "2", "Score": "79", "OwnerUserId": "2567683", "Tags": "<c++><auto><c++14><decltype><return-type-deduction>", "FavoriteCount": "46"}});