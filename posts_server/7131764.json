post_cb({"bq_ids": {"n4140": {"so_7131764_7131815_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 21}}, "n3337": {"so_7131764_7131815_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 18}}, "n4659": {"so_7131764_7131815_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 21}}}, "7131814": {"Id": "7131814", "PostTypeId": "2", "Body": "<p>Left-shifting a negative value results in undefined behaviour.  So I'm not sure you can draw many conclusions from what the compiler chooses to do in this scenario.</p>\n", "LastActivityDate": "2011-08-20T12:41:08.037", "CommentCount": "3", "CreationDate": "2011-08-20T12:41:08.037", "ParentId": "7131764", "Score": "1", "OwnerUserId": "129570"}, "7131764": {"ViewCount": "646", "Body": "<p>I'm working with Visual C++ 2008 here (9.x) and I was preparing a fixed point value when I ran into the compiler generating a DIV instead of an IDIV. I collapsed the code into a tiny piece to exactly reproduce:</p>\n<pre><code>short a = -255;\nshort divisor16 = 640; // unsigned, 16-bit\nunsigned int divisor32 = 640; // unsigned, 32-bit\nunsigned short s_divisor16 = 640; // signed, 16-bit\nint s_divisor32 = 640; // signed, 32-bit\nint16_t test1 = (a&lt;&lt;8)/divisor16; // == -102, generates IDIV -&gt; OK\nint16_t test2 = (a&lt;&lt;8)/s_divisor16; // == -102, generates IDIV -&gt; OK\nint16_t test3 = (a&lt;&lt;8)/divisor32; // == bogus, generates DIV -&gt; FAIL!\nint16_t test4 = (a&lt;&lt;8)/s_divisor32; // == -102, generates IDIV -&gt; OK\n\nint bitte_ein_breakpoint=1;\n</code></pre>\n<p>I won't bother you with the simple disassembly.</p>\n<p>Now instead of taking the shortcut and just changing the divisor's type (it is a function parameter, unsigned int numPixels), I wonder what makes the compiler pick DIV over IDIV in the third (test3) case, since it does not do so with an unsigned 16-bit divisor and there really isn't  anything that would call for unsigned arithmetic anyway. At least that's what I think and I hope I'm wrong :)</p>\n", "AcceptedAnswerId": "7131815", "Title": "Visual C++ generates DIV instead of IDIV (x86, integer arithmetic)", "CreationDate": "2011-08-20T12:31:03.150", "Id": "7131764", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-08-20T13:32:49.653", "Score": "3", "OwnerUserId": "149746", "Tags": "<c++><assembly><visual-c++-2008><integer-division>", "AnswerCount": "2"}, "7131815": {"Id": "7131815", "PostTypeId": "2", "Body": "<p>The code that is generated for the <code>/</code> operator depends on the operands.</p>\n<p>First, the expression <code>(a &lt;&lt; 8)</code> has type <code>int</code>, since <em>the integer promotions are performed on each of the operands</em> (ISO C99, 6.5.7p3), and then the operation is <code>int &lt;&lt; int</code>, which results in an <code>int</code>.</p>\n<p>Now there are four expressions:</p>\n<ol>\n<li><code>int / short</code>: the right hand side is promoted to <code>int</code>, therefore the <code>idiv</code> instruction.</li>\n<li><code>int / unsigned short</code>: the right hand side is promoted to <code>int</code>, therefore the <code>idiv</code> instruction.</li>\n<li><code>int / unsigned int</code>: the <em>left</em> hand side is promoted to <code>unsigned int</code>, therefore the <code>div</code> instruction.</li>\n<li><code>int / int</code>: nothing is promoted, therefore the <code>idiv</code> instruction is appropriate.</li>\n</ol>\n<p>The <em>integer promotions</em> are defined in ISO C99 6.3.1.1p3:</p>\n<blockquote>\n<p id=\"so_7131764_7131815_0\">If an <code>int</code> can represent all values of the original type, the value is converted to an <code>int</code>; otherwise, it is converted to an <code>unsigned int</code>. These are called the <em>integer promotions.</em>.</p>\n</blockquote>\n", "LastActivityDate": "2011-08-20T12:41:55.773", "CommentCount": "1", "CreationDate": "2011-08-20T12:41:55.773", "ParentId": "7131764", "Score": "7", "OwnerUserId": "225757"}});