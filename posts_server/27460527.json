post_cb({"47613669": {"ParentId": "27460527", "CommentCount": "0", "Body": "<p>That would not be possible since the variables declared in the block are local in that block.\nHowever, the variable <code>i</code> could be declared before the do-while loop.\nBut because we don't want to extend the scope from the loop onwards, we can use a little trick:</p>\n<p>First, add this line</p>\n<pre><code>#define do(cond) switch (cond) do default:\n</code></pre>\n<p>at the beginning of your code.</p>\n<p>Now, you can write</p>\n<pre><code>do (int i = get_data()) {\n    // whatever you want to do with i;\n} while ((i = get_data()) != 0);\n</code></pre>\n<p>or</p>\n<pre><code>do (int i = 0) {\n    i = get_data();\n    // whatever you want to do with i;\n} while (i != 0);\n</code></pre>\n<p>The scope of the <code>i</code> is limited to the loop.\nThe <code>#define</code> does not break the original usage of do-while loop.\nSo the following syntax is still valid:</p>\n<pre><code>int j = 0;\ndo {\n    // whatever you want to do with j;\n} while (j != 0);\n</code></pre>\n", "OwnerUserId": "1729784", "PostTypeId": "2", "Id": "47613669", "Score": "0", "CreationDate": "2017-12-02T23:22:23.330", "LastActivityDate": "2017-12-02T23:22:23.330"}, "27460527": {"CommentCount": "0", "AcceptedAnswerId": "27462301", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-12-13T15:35:20.860", "LastActivityDate": "2017-12-02T23:22:23.330", "LastEditDate": "2017-05-23T11:53:27.663", "ViewCount": "507", "FavoriteCount": "1", "Title": "Scope of declarations in the body of a do-while statement", "Id": "27460527", "Score": "5", "Body": "<p>In <a href=\"https://stackoverflow.com/q/27430640/1708801\">Why can't you declare a variable inside a do while loop?</a> the OP asks why a declaration in the while-condition of a do-while loop isn't in scope in the do-statement. That would be very unnatural as C/C++ generally follow a \"declaration-at-top-of-scope\" pattern. But what about the converse - why not extend the scope of any declaration in the do-statement to the while-condition. That would allow </p>\n<pre><code>int i;\ndo {\n  i = get_data();\n  // whatever you want to do with i;\n} while (i != 0);\n</code></pre>\n<p>to be shortened to</p>\n<pre><code>do {\n  int i = get_data();\n  // whatever you want to do with i;\n} while (i != 0);\n</code></pre>\n<p>which gives a tidy syntax for limiting the scope of the control variable. (Note: I'm aware that this isn't valid syntax - that's the point of the question, why not extend the language to allow this syntax.) </p>\n<p>As I note in a comment below, this extension would not break existing code, and would be very much in then spirit of the introduction of for-init (and while-init) scoping. </p>\n", "Tags": "<c++><declaration><language-lawyer><do-while>", "OwnerUserId": "2587908", "AnswerCount": "5"}, "27460577": {"ParentId": "27460527", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In your proposal, the while statement <code>while (i != 0);</code> is out of the scope<br> of the inner block <code>{ int i = get_data(); }</code></br></p>\n<p>It doesn't \"see\" the variable <code>i</code>, so it doesn't work.</p>\n<p>Changing the language to support that would break one of its rules. Scoping is more important than the problem you show, which has a simple solution of declaring the variable before the block.</p>\n<p>Also introducing your rule would break existing code as this valid example shows:</p>\n<pre><code>int i = 0 ;\ndo {\n  int i = 1 ;\n} while (i) ;\n</code></pre>\n", "OwnerUserId": "4082723", "LastEditorUserId": "4082723", "LastEditDate": "2014-12-13T15:59:16.670", "Id": "27460577", "Score": "2", "CreationDate": "2014-12-13T15:40:10.097", "LastActivityDate": "2014-12-13T15:59:16.670"}, "27460985": {"ParentId": "27460527", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You following example will not work because, you are initializing the integer value inside the while loop. Initializing the integer value inside the while loop ensures that the while loop doesn't find i value and will fail.</p>\n<pre><code>do {\n  int i = get_data();\n  // whatever you want to do with i;\n} while (i != 0);\n</code></pre>\n<p>To show you an example:</p>\n<pre><code>do {\nint i = i+1;\n\n}while(i = 0) \n</code></pre>\n<p>will give you error: </p>\n<pre><code>prog.cpp:8:12: error: \u2018i\u2019 was not declared in this scope\n     }while(i = 0);\n</code></pre>\n<p>Rationale:\nSee this logic map for help</p>\n<p><img alt=\"C++ do...while loop\" src=\"https://www.tutorialspoint.com/images/cpp_do_while_loop.jpg\"/></p>\n<p>Standard - The do-while loop is an exit-condition loop.  This means that the body of the loop is always executed first.  Then, the test condition is evaluated.  If the test condition is TRUE, the program executes the body of the loop again. Except that condition is evaluated after the execution of statement instead of before, guaranteeing at least one execution of statement, even if condition is never fulfilled.</p>\n<p>But, initializing the conditional statement variable inside the do while loop ensures that conditional statement variable's scope only spans inside the do-while loop and the condition statement in only takes global and local variables giving you a scope error.</p>\n<p>Rationale Explanation:\nWhy we shouldn't change:</p>\n<p>Not beneficial to making a more efficent program, this is pretty useless not to mention  this style of coding is bad because your messing around with scopes. Let say you initialized a variable inside do-while loop then it would cause problems with other functions like loop statements. For example let us say there is two i variables which variable takes part in the conditional statement and loop statement? This extension would causes a logic error.</p>\n<pre><code>int i = 0;\ndo\n{\n    int i = 0;\n    i = i+1;\n}\nwhile(i &lt; 10);\nfor(i; i &lt; 20;i++)\n{\n    code...\n}\n</code></pre>\n<p>People only need one way to do things why make two different ways?</p>\n<p>Conclusion: Adding this extension to the C++ language would cause all kinds of ruckus and errors once people start to mess around with it. So the best solution would be to stick to the standard.</p>\n", "OwnerUserId": "4305751", "LastEditorUserId": "-1", "LastEditDate": "2017-02-08T14:58:49.080", "Id": "27460985", "Score": "2", "CreationDate": "2014-12-13T16:20:20.007", "LastActivityDate": "2014-12-13T17:02:01.787"}, "27460938": {"ParentId": "27460527", "CommentCount": "0", "Body": "<p>Some conjecture:</p>\n<p>The c++ standards committee is know to be conservative - c++ is a complex language and they are keen to keep as many confusing edge cases out of the language and standard library as possible.</p>\n<p>The rationale is that if there is already a way to express some logic, a language change to support some other way of expressing the logic is unnecessary and potentially confusing.</p>\n<p>the loop can already be expressed more safely, with no uninitialised variables like this:</p>\n<pre><code>for(;;) {\n  int i = get_data(); \n  // whatever you want to do with i;\n  if (!i)\n    break;\n}\n</code></pre>\n<p>so making the argument to extend the scope of variables in a <code>do {} while();</code> block would be quickly dismissed by the committee as \"un-necessary, at risk of adding potentially confusing additions of corner cases\" </p>\n<p>Beyond that, there is also the issue of lifetime management and destruction order. At the moment, any object created in the <code>do</code> block will be destroyed (in deterministic order) before the <code>while</code> clause is evaluated. If you are going to extend the lifetime of <code>i</code>, would you also extend the lifetime of all objects in the block, thus delaying the execution of destructors? What if <code>i</code> was an object holding a reference to another variable declared in the block? What if the code in the <code>while()</code> depended on a side-effect in the destructor of i?</p>\n<p>example (does not compile):</p>\n<pre><code>do {\n  object1 o1;\n  object2 i(o1); // holds reference to o1 \n  object3 x;\n  ...\n} while(i.test_for_end()); // implicit scope extension. \n// what if test_for_end() depends on the destructor of x?\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "27460938", "Score": "1", "CreationDate": "2014-12-13T16:15:37.553", "LastActivityDate": "2014-12-13T16:15:37.553"}, "bq_ids": {"n4140": {"so_27460527_27462301_1": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}, "so_27460527_27462301_0": {"section_id": 7061, "quality": 0.88, "length": 22}}, "n3337": {"so_27460527_27462301_1": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}, "so_27460527_27462301_0": {"section_id": 6805, "quality": 0.88, "length": 22}}, "n4659": {"so_27460527_27462301_1": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}, "so_27460527_27462301_0": {"section_id": 8558, "quality": 0.88, "length": 22}}}, "27462301": {"ParentId": "27460527", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>So currently as a the do while exists the body of the loop is a block:</p>\n<pre><code>do \n{  // begin block\n   int i = get_data();\n  //    whatever you want to do with i;\n}  //end block\nwhile (i != 0);\n</code></pre>\n<p>so how does a block scope work, from section <code>3.3.3</code> <em>Block scope</em>:</p>\n<blockquote>\n<p id=\"so_27460527_27462301_0\">A name declared in a block (6.3) is local to that block; it has block scope. Its potential scope begins at its\n  point of declaration (3.3.2) and ends at the end of its block. A variable declared at block scope is a local\n  variable.</p>\n</blockquote>\n<p>So clearly the scope of <code>i</code> is the block, so you want a rule that would create some sort of special do while block scope. How would that practically work? It would seem the simplest equivalent would be to hoist the declaration to a newly created outer block:  </p>\n<pre><code>{\n  int i = get_data(); // hoist declaration outside\n  do \n  {  // begin block\n    //    whatever you want to do with i;\n  }  //end block\n  while (i != 0);\n}\n</code></pre>\n<p>which could possibly work fine if all the declarations where at the start of the body, but what about a scenario like this:</p>\n<pre><code>int k = 0 ;\ndo \n{\n   int i = get_data();\n   k++ ;        // side effect before declaration\n   int j = k ;  // j it set to 1\n}\nwhile (i != 0);\n</code></pre>\n<p>after hoisting:</p>\n<pre><code>int k = 0 ;\n{\n  int i = get_data();\n  int j = k ;  // j is set to 0\n  do \n  {\n     k++ ;   \n  }\n  while (i != 0);\n}\n</code></pre>\n<p>Another alternative would be to extend the scope from the do while onwards but that would break all sorts of expected behavior. It would break how name hiding works in block scope from section <code>3.3.10</code> <em>Name hiding</em>:</p>\n<blockquote>\n<p id=\"so_27460527_27462301_1\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived\n  class (10.2).</p>\n</blockquote>\n<p>and example from <code>3.3.1</code> shows this:</p>\n<pre><code>int j = 24;\nint main() {\n    int i = j, j;\n    j = 42;\n}\n</code></pre>\n<p>the <code>j</code> in <code>main</code> hides the global <code>j</code> but how would work for our special do while scope?:</p>\n<pre><code>int j = 24;\ndo {\n    int i = j, j;\n    j = 42;\n} while( j != 0 )\n</code></pre>\n<p>Extending the scope of the inner <code>j</code> from the do while forwards would surely break a lot of existing code and looking at the previous example there is no intuitive way to hoist the declaration out.</p>\n<p>We could play with this an eventually and find something that works but it seems like a lot of work for very little gain and it is completely unintuitive. </p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-12-14T17:45:47.480", "Id": "27462301", "Score": "0", "CreationDate": "2014-12-13T18:38:58.480", "LastActivityDate": "2014-12-14T17:45:47.480"}});