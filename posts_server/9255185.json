post_cb({"9255612": {"ParentId": "9255185", "CommentCount": "4", "CreationDate": "2012-02-13T04:27:59.890", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "9255612", "Score": "3", "Body": "<p>The standard is pretty clear on what is allowed in a <code>constexpr</code> function:</p>\n<p><code>\u00a77.1.5 [dcl.constexpr] p3</code></p>\n<blockquote>\n<p id=\"so_9255185_9255612_0\">The definition of a <code>constexpr</code> function shall satisfy the following constraints:</p>\n<ul>\n<li>[...]  </li>\n<li>its return type shall be a literal type;  </li>\n<li>each of its parameter types shall be a literal type;</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p><code>\u00a73.9 [basic.types] p10</code></p>\n<blockquote>\n<p id=\"so_9255185_9255612_1\">A type is a <em>literal type</em> if it is:</p>\n<ul>\n<li>a scalar type; or</li>\n<li><strong>a reference type;</strong> or</li>\n<li>a class type (Clause 9) that has all of the following properties:</li>\n<li>it has a trivial destructor,\n  <ul>\n<li>every constructor call and full-expression in the brace-or-equal-initializers for non-static data\n  members (if any) is a constant expression (5.19),</li>\n<li>it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template\n  that is not a copy or move constructor, and</li>\n<li>it has all non-static data members and base classes of literal types; or</li>\n</ul></li>\n<li>an array of literal type.</li>\n</ul>\n</blockquote>\n<p>As such, yes, you can have reference parameters, even reference-to-non-const ones. The parameters of a <code>constexpr</code> function are restricted in another way. The complete, exhaustive list can be found under <code>\u00a75.19 [expr.const] p2</code>. Here's an excerpt of what makes a <code>constexpr</code> declared function not-so-<code>constexpr</code> anymore:</p>\n<blockquote>\n<p id=\"so_9255185_9255612_2\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it involves one of the following as a potentially evaluated subexpression (3.2), but subexpressions of logical AND (5.14), logical OR (5.15), and conditional (5.16) operations that are not evaluated are not considered [ <em>Note:</em> An overloaded operator invokes a function. <em>\u2014end note</em> ]:</p>\n</blockquote>\n<p>(The last bit about the logical operators just means that the unevaluated part of it (due to short-circuit evaluation) is not part of the operations that determine whether the function is truly <code>constexpr</code>.)</p>\n<blockquote id=\"so_9255185_9255612_3\">\n<ul>\n<li>[...]</li>\n<li>a dynamic cast (5.2.7);</li>\n<li>a <code>reinterpret_cast</code> (5.2.10);</li>\n<li>a pseudo-destructor call (5.2.4);</li>\n<li>increment or decrement operations (5.2.6, 5.3.2);</li>\n<li>a typeid expression (5.2.8) whose operand is of a polymorphic class type;</li>\n<li>a <em>new-expression</em> (5.3.4);</li>\n<li>a <em>delete-expression</em> (5.3.5);</li>\n<li>a subtraction (5.7) where both operands are pointers;</li>\n<li>a relational (5.9) or equality (5.10) operator where the result is unspecified;</li>\n<li>an assignment or a compound assignment (5.17); or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2012-02-13T04:27:59.890"}, "9255185": {"CommentCount": "0", "ViewCount": "449", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-02-13T03:23:30.000", "LastActivityDate": "2012-03-02T06:18:36.360", "Title": "When are \"return-by-reference\" or \"pass-by-reference\" parameter compatible with constexpr?", "FavoriteCount": "2", "LastEditDate": "2017-05-23T09:59:22.280", "Id": "9255185", "Score": "2", "Body": "<p>Functions marked constexpr are supposed to be immutable pure functions.  From the <a href=\"https://stackoverflow.com/questions/5605142/stdmax-and-stdmin-not-constexpr\">\"std::max() and std::min() not constexpr\"</a> post, you can't re-channel a const-reference input as an output, since that would require the parameter to have permanence.  But can you take a parameter by <code>const</code>-reference, as long as you don't re-channel it?</p>\n<pre><code>// Is this still constexpr?\n// (Assuming that std::complex is constexpr-safe, as it's supposed to be.)\nconstexpr\nint  MySum( std::complex&lt;double&gt; const &amp;a, std::complex&lt;double&gt; const &amp;b )\n{ return static_cast&lt;int&gt;( a.real() + b.real() ); }\n</code></pre>\n<p>Conversely, can you return a const-reference to a sub-object of a <code>constexpr</code>-enabled type?</p>\n<pre><code>template &lt;typename T&gt;\nclass MyComplex\n{\n    T  c_[ 2 ];\npublic:\n    constexpr MyComplex( T r = T(), T i = T() )\n    : c_{ r, i }\n    {}\n\n    // Is this actually constexpr?\n    constexpr T const &amp;  operator[]( unsigned l ) //const\n    { return c_[ l ]; }\n\n    // Can't be constexpr\n    T &amp;  operator[]( unsigned l )  { return c_[ l ]; }\n};\n</code></pre>\n<p>Or do even sub-object returns have to be by value?</p>\n<p>(Sorry if this is basic, but everything I've found dances around this point without actually being definitive.)</p>\n", "Tags": "<c++><c++11><pass-by-reference><constexpr>", "OwnerUserId": "1010226", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_9255185_9255612_0": {"section_id": 5419, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_9255185_9255612_0": {"section_id": 5214, "quality": 0.8571428571428571, "length": 6}, "so_9255185_9255612_3": {"section_id": 5946, "quality": 0.7560975609756098, "length": 31}, "so_9255185_9255612_2": {"section_id": 5946, "quality": 0.7142857142857143, "length": 20}}, "n4659": {"so_9255185_9255612_0": {"section_id": 6841, "quality": 0.7142857142857143, "length": 5}}}, "9528911": {"ParentId": "9255185", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-03-02T06:18:36.360", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:24:24.453", "Id": "9528911", "OwnerUserId": "1041090", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1454\" rel=\"nofollow noreferrer\">Core issue 1454</a>'s resolution changes the rule which Johannes is referencing in his answer to <a href=\"https://stackoverflow.com/questions/5605142/stdmax-and-stdmin-not-constexpr\">the std::max question</a>. With the current resolution of that issue (which is implemented by both g++ and clang), <code>constexpr</code> functions are allowed to return, by reference, any lvalue which they can compute.</p>\n", "LastActivityDate": "2012-03-02T06:18:36.360"}});