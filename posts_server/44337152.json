post_cb({"bq_ids": {"n4140": {"so_44337152_44337477_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5408}, "so_44337152_44337477_1": {"length": 14, "quality": 1.0, "section_id": 5407}}, "n3337": {"so_44337152_44337477_2": {"length": 30, "quality": 0.967741935483871, "section_id": 5203}, "so_44337152_44337477_1": {"length": 14, "quality": 1.0, "section_id": 5202}}, "n4659": {"so_44337152_44337477_2": {"length": 28, "quality": 0.9032258064516129, "section_id": 6830}, "so_44337152_44337477_1": {"length": 14, "quality": 1.0, "section_id": 6829}}}, "44337477": {"Id": "44337477", "PostTypeId": "2", "Body": "<p>The class definition <code>class B { typedef A classA; }</code> does not define any data member in class <code>B</code>; with <code>typedef</code>, it introduces a new name <code>classA</code> as a synonym for type <code>class A</code>). Because this typedef-name is defined within <code>class B</code>, it is in the namespace of class <code>B</code>, such that you need to refer to this new type as <code>B::classA</code>, which is then equivalent to <code>A</code>.  Confer, for example, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">C++ standard</a>:</p>\n<blockquote>\n<p id=\"so_44337152_44337477_0\">7.1.3 The typedef specifier</p>\n<p id=\"so_44337152_44337477_1\">(1) Declarations containing the decl-specifier typedef declare identifiers that can be used later for naming. ... \n  A typedef-name is thus a synonym for another type.\n  ...</p>\n</blockquote>\n<p>BTW: A common way for introducing aliases is also the <code>using</code>-statement:</p>\n<pre><code>using classA = A;\n</code></pre>\n<blockquote>\n<p id=\"so_44337152_44337477_2\">(2) A typedef-name can also be introduced by an alias-declaration. The\n  identifier following the using keyword becomes a typedef-name and the\n  optional attribute-specifier-seq following the identifier appertains\n  to that typedef-name. It has the same semantics as if it were\n  introduced by the typedef specifier. In particular, it does not define\n  a new type and it shall not appear in the type-id.</p>\n</blockquote>\n", "LastEditorUserId": "2630032", "LastActivityDate": "2017-06-02T22:47:23.103", "Score": "1", "CreationDate": "2017-06-02T21:09:46.577", "ParentId": "44337152", "CommentCount": "2", "OwnerUserId": "2630032", "LastEditDate": "2017-06-02T22:47:23.103"}, "44337152": {"ViewCount": "103", "Body": "<pre><code>class A{\n\n  public:\n    A(){ letter = 66; }\n    void display(void){ cout &lt;&lt; \"A = \" &lt;&lt; letter; }\n\n  private:\n    int letter;\n\n};\n\n\nclass B{\n\n  public:\n    typedef A classA;\n};\n\nint main(void){\n\n   B::classA objA;\n\n   objA.display();\n\n   return 0;\n\n}\n</code></pre>\n<p>This code runs properly ;however, I cannot understand what we do in this code.\nI have never seen something like this before. It seems like class A is a member of class B. If it is so, why do not we use classA through object of class B ?</p>\n", "Title": "Typedef With A Class In Another Class", "CreationDate": "2017-06-02T20:42:52.447", "LastActivityDate": "2017-06-02T22:47:23.103", "CommentCount": "1", "PostTypeId": "1", "ClosedDate": "2017-06-02T21:10:34.447", "Id": "44337152", "Score": "-5", "OwnerUserId": "7632067", "Tags": "<c++><class><oop><typedef>", "AnswerCount": "2"}, "44337413": {"Id": "44337413", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44337152_44337413_0\">It seems like class A is a member of class B. If it is so, why do not we use classA through object of class B ?</p>\n</blockquote>\n<p>No. What you have there is a <em>name</em> (a type in this case) declared in <code>class B</code> as <code>classA</code> which stands as a typedef to a class, <code>A</code>. In C++, the name of a class is also a namespace. so the typedef, lets you access a name <code>classA</code> within <code>class B</code>.</p>\n<blockquote>\n<p id=\"so_44337152_44337413_1\">I have never seen something like this before.</p>\n</blockquote>\n<p>For your specific example, it may be an overkill. But having type aliases is very useful and you will find it a lot in many <em>class templates</em> codes.</p>\n<p>Consider:</p>\n<pre><code>template&lt;typename T&gt;\nclass B{\n  public:\n    typedef T classA;\n};\n</code></pre>\n<p>Without the <code>typedef</code> above, it would be very difficult to tell what type the above class was instantiated with.</p>\n<p>A typical example is how STL algorithms can tell the category of a given iterator by accessing the name <a href=\"http://en.cppreference.com/w/cpp/iterator/iterator_traits\" rel=\"nofollow noreferrer\"><code>iterator_category</code></a> from the iterator's type via <code>std::iterator_traits</code></p>\n", "LastEditorUserId": "1621391", "LastActivityDate": "2017-06-02T21:21:49.657", "Score": "1", "CreationDate": "2017-06-02T21:04:34.677", "ParentId": "44337152", "CommentCount": "0", "OwnerUserId": "1621391", "LastEditDate": "2017-06-02T21:21:49.657"}});