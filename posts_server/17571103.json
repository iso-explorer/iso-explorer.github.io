post_cb({"18892571": {"ParentId": "17571103", "CommentCount": "2", "Body": "<p>A very interesting question (and subsequent answer), thanks for sharing.</p>\n<p>From my point of view (not based on anything in particular), I'd expect placement new to return a null pointer on failure, rather than calling a constructor on a null object. In this way, it's the same behaviour as malloc.</p>\n<p>What you propose is a great idea - I tested this out with gcc 4.4.6, and I do indeed see the null pointer check disappear if I override placement new with a version that throws.</p>\n<p>One question - doesn't \u00a718.6.1.3,1 say that placement new can not be displaced (despite gcc and vc++ being happy to allow displacement)?</p>\n", "OwnerUserId": "1943413", "PostTypeId": "2", "Id": "18892571", "Score": "1", "CreationDate": "2013-09-19T10:47:15.113", "LastActivityDate": "2013-09-19T10:47:15.113"}, "17571103": {"CommentCount": "16", "AcceptedAnswerId": "17573387", "PostTypeId": "1", "LastEditorUserId": "981959", "CreationDate": "2013-07-10T12:50:49.147", "LastActivityDate": "2015-07-10T10:09:51.583", "LastEditDate": "2015-07-10T10:09:51.583", "ViewCount": "2582", "FavoriteCount": "10", "Title": "Passing null pointer to placement new", "Id": "17571103", "Score": "37", "Body": "<p>The default placement <code>new</code> operator is declared in 18.6 [support.dynamic] \u00b61 with a non-throwing exception-specification:</p>\n<pre><code>void* operator new (std::size_t size, void* ptr) noexcept;\n</code></pre>\n<p>This function does nothing except <code>return ptr;</code> so it is reasonable for it to be <code>noexcept</code>, however according to 5.3.4 [expr.new] \u00b615 this means that the compiler must check it doesn't return null before invoking the object's constructor:</p>\n<blockquote>\n<p id=\"so_17571103_17571103_0\">-15-<br>\n  [<em>Note:</em> unless an allocation function is declared with a non-throwing exception-specification (15.4), it indicates failure to allocate storage by throwing a <code>std::bad_alloc</code> exception (Clause 15, 18.6.2.1); it returns a non-null pointer otherwise. If the allocation function is declared with a non-throwing exception-specification, it returns null to indicate failure to allocate storage and a non-null pointer otherwise. <em>\u2014end note</em>] If the allocation function returns null, initialization shall not be done, the deallocation function shall not be called, and the value of the new-expression shall be null.</br></p>\n</blockquote>\n<p>It seems to me that (specifically for placement <code>new</code>, not in general) this null check is an unfortunate performance hit, albeit small.</p>\n<p>I've been debugging some code where placement <code>new</code> was being used in a very performance-sensitive code path to improve the compiler's code generation and the check for null was observed in the assembly.  By providing a class-specific placement <code>new</code> overload that is declared with a throwing exception-specification (even though it can't possibly throw) the conditional branch was removed, which also allowed the compiler to generate smaller code for the surrounding inlined functions.  The result of saying the placement <code>new</code> function <em>could</em> throw, even though it <em>couldn't</em>, was measurably better code.</p>\n<p>So I've been wondering whether the null check is really required for the placement <code>new</code> case. The only way it can return null is if you pass it null. Although it's possible, and apparently legal, to write:</p>\n<pre><code>void* ptr = nullptr;\nObj* obj = new (ptr) Obj();\nassert( obj == nullptr );\n</code></pre>\n<p>I can't see why that would be useful, I suggest it would be better if the programmer had to check for null explicitly before using placement <code>new</code> e.g.</p>\n<pre><code>Obj* obj = ptr ? new (ptr) Obj() : nullptr;\n</code></pre>\n<p>Has anyone ever needed placement <code>new</code> to correctly handle the null pointer case?  (i.e. without adding an explicit check that <code>ptr</code> is a valid memory location.)</p>\n<p>I'm wondering whether it would be reasonable to forbid passing a null pointer to the default placement <code>new</code> function, and if not whether there is some better way to avoid the unnecessary branch, other than trying to tell the compiler the value is not null e.g.</p>\n<pre><code>void* ptr = getAddress();\n(void) *(Obj*)ptr;   // inform the optimiser that dereferencing pointer is valid\nObj* obj = new (ptr) Obj();\n</code></pre>\n<p>Or:</p>\n<pre><code>void* ptr = getAddress();\nif (!ptr)\n  __builtin_unreachable();  // same, but not portable\nObj* obj = new (ptr) Obj();\n</code></pre>\n<p><strong>N.B.</strong> This question is intentionally tagged micro-optimisation, I am <strong>not</strong> suggesting that you go around overloading placement <code>new</code> for all your types to \"improve\" performance. This effect was noticed in a very specific performance-critical case and based on profiling and measurement.</p>\n<p><strong>Update:</strong> <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1748\">DR 1748</a> makes it undefined behaviour to use a null pointer with placement new, so compilers are no longer required to do the check.</p>\n", "Tags": "<c++><micro-optimization><placement-new><noexcept>", "OwnerUserId": "981959", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17571103_17573387_2": {"section_id": 6097, "quality": 0.8518518518518519, "length": 23}, "so_17571103_17573387_1": {"section_id": 7177, "quality": 0.9523809523809523, "length": 40}, "so_17571103_17573387_3": {"section_id": 6857, "quality": 0.8181818181818182, "length": 9}, "so_17571103_17571103_0": {"section_id": 6096, "quality": 0.8958333333333334, "length": 43}, "so_17571103_17573387_0": {"section_id": 6096, "quality": 1.0, "length": 15}}, "n3337": {"so_17571103_17573387_2": {"section_id": 5863, "quality": 0.8518518518518519, "length": 23}, "so_17571103_17573387_1": {"section_id": 6921, "quality": 0.9523809523809523, "length": 40}, "so_17571103_17573387_3": {"section_id": 6603, "quality": 0.8181818181818182, "length": 9}, "so_17571103_17571103_0": {"section_id": 5862, "quality": 0.8958333333333334, "length": 43}, "so_17571103_17573387_0": {"section_id": 5862, "quality": 1.0, "length": 15}}, "n4659": {"so_17571103_17573387_2": {"section_id": 7594, "quality": 0.8148148148148148, "length": 22}, "so_17571103_17573387_1": {"section_id": 8685, "quality": 0.8809523809523809, "length": 37}, "so_17571103_17573387_3": {"section_id": 8349, "quality": 0.8181818181818182, "length": 9}, "so_17571103_17571103_0": {"section_id": 7593, "quality": 0.8125, "length": 39}, "so_17571103_17573387_0": {"section_id": 7593, "quality": 0.8666666666666667, "length": 13}}}, "17573387": {"ParentId": "17571103", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>While I can't see much of a question in there except \"Has anyone ever needed placement new to correctly handle the null pointer case?\" (I haven't), I think the case is interesting enough to spill some thoughts on the issue.</p>\n<p>I consider the standard broken or incomplete wrt the placement new function and requirements to allocation functions in general. </p>\n<p>If you look closely at the quoted \u00a75.3.4,13, it implies that <em>every</em> allocation function has to be checked for a returned nullpointer, even if it is not <code>noexcept</code>. Therefore, it should be rewritten to </p>\n<blockquote>\n<p id=\"so_17571103_17573387_0\">If the allocation function <strong>is declared with a non-throwing exception-specification and</strong> returns null, initialization shall not be done, the deallocation function shall not be called, and the value of the new-expression shall be null.  </p>\n</blockquote>\n<p>That would not harm the validity of allocation functions throwing exceptions, since they have to obey <strong>\u00a73.7.4.1</strong>:</p>\n<blockquote>\n<p id=\"so_17571103_17573387_1\">[...] If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size. [...] The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p>And <strong>\u00a75.3.4,14</strong>: </p>\n<blockquote>\n<p id=\"so_17571103_17573387_2\">[ Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned and of the requested size. [...] -end note ]</p>\n</blockquote>\n<p>Obviously, a placement new that just returns the given pointer, cannot reasonably check avilable storage size and alignment. Therefore, </p>\n<p><strong>\u00a718.6.1.3,1</strong> about placement new says</p>\n<blockquote>\n<p id=\"so_17571103_17573387_3\">[...] The provisions of (3.7.4) do not apply to these reserved placement forms of operator new and operator delete.</p>\n</blockquote>\n<p>(I guess they missed to mention \u00a75.3.4,14 at that place.)</p>\n<p>However, together these paragraphs say <em>indirectly</em> \"if you pass a garbage pointer to the palcement functions, you get UB, because \u00a75.3.4,14 is violated\". So it's up to you to check the sanity of any poitner given to placement new.  </p>\n<p>In that spirit, and with the rewritten \u00a75.3.4,13, the standard could strip the <code>noexcept</code> from placement new, leading to an addition to that indirect conclusion: \"...and if you pass null, you get UB as well\". On the other hand, its much less likely to have a misaligned pointer or pointer to too few memory than having a null pointer.</p>\n<p>However, this would remove the need for checking against null, and it would fit well to the philosophy \"don't pay for what you don't need\". The allocation function itself would not need to check, because \u00a718.6.1.3,1 explicitly says so.</p>\n<p>To round things up, one could consider adding a second overload</p>\n<pre><code> void* operator new(std::size_t size, void* ptr, const std::nothrow_t&amp;) noexcept;\n</code></pre>\n<p>Sadly, proposing this to the committee is unlikely to result in a change, because it would break existing code relying on placement new being ok with null pointers.</p>\n", "OwnerUserId": "1838266", "LastEditorUserId": "1838266", "LastEditDate": "2013-07-10T14:40:25.780", "Id": "17573387", "Score": "11", "CreationDate": "2013-07-10T14:31:25.970", "LastActivityDate": "2013-07-10T14:40:25.780"}});