post_cb({"bq_ids": {"n4140": {"so_21340801_21341177_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3325}, "so_21340801_21341177_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}}, "n3337": {"so_21340801_21341177_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3195}, "so_21340801_21341177_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}}, "n4659": {"so_21340801_21341177_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 4091}, "so_21340801_21341177_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "21340801": {"ViewCount": "286", "Body": "<p>In updating some code to use uniform initialization, I thought it would be a drop-in modern substitue for the now \"old style\" parentheses style.  I know this isn't always the case (obvious example, <code>vector&lt;int&gt;</code>) but I've stumbled over another difference that I don't understand.</p>\n<pre><code>class Object {\n    public:\n        Object() = default;\n        Object(const Object&amp;) = default;\n};\n\nint main() {\n    Object o;\n    Object copy{o}; // error\n    Object copy2(o); // OK\n}\n</code></pre>\n<p>fails to compile under clang3.5 with the error: (also fails under gcc)</p>\n<pre><code>error: excess elements in struct initializer\n</code></pre>\n<p>There are two different changes to <code>Object</code> that make this work.  Either adding a data member to it, or giving it an empty copy constructor body</p>\n<pre><code>class Object {\n    private:\n        int i; // this fixes it\n    public:\n        Object() = default;\n        Object(const Object&amp;) { } // and/or this fixes it as well\n};\n</code></pre>\n<p>I don't see why these should make a difference.</p>\n", "AcceptedAnswerId": "21341177", "Title": "Uniform initialization fails to copy when object has no data members", "CreationDate": "2014-01-24T19:23:49.753", "Id": "21340801", "CommentCount": "8", "LastEditDate": "2016-03-22T19:16:33.770", "PostTypeId": "1", "LastEditorUserId": "1013719", "LastActivityDate": "2016-03-22T19:16:33.770", "Score": "9", "OwnerUserId": "1013719", "Tags": "<c++><c++11><copy-constructor><uniform-initialization>", "AnswerCount": "2"}, "21341177": {"Id": "21341177", "PostTypeId": "2", "Body": "<p>Johannes's answer is useful, but let me elaborate on why it currently happens.</p>\n<p>Both of the changes you describe affect your class by making it go from an aggregate to not an aggregate. See C++11 (N3485) \u00a7 8.5.1/1:</p>\n<blockquote>\n<p id=\"so_21340801_21341177_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1),  no <em>brace-or-equal-initializers</em> for non-static data members (9.2), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>A constructor with a definition of <code>= default</code> is considered not user-defined.</p>\n<p>Then, going down to list-initialization in \u00a7 8.5.4, we see:</p>\n<blockquote>\n<p id=\"so_21340801_21341177_1\">List-initialization of an object or reference of type T is de\ufb01ned as follows:  </p>\n<ul>\n<li>If T is an aggregate, aggregate initialization is performed</li>\n</ul>\n</blockquote>\n<p>And then a bunch of \"Otherwise...\" sections. Thus, changing either of these allows a constructor to be called instead of performing aggregate initialization. </p>\n<p>The new proposed standardese for the list-initialization definition (as viewable in Johannes's link) provides a prioritized case of a single element in the list, and it having a type of (or really close to) the type of the object being initialized. Aggregate initialization would then be top priority after that.</p>\n", "LastEditorUserId": "962089", "LastActivityDate": "2014-01-24T19:51:07.347", "Score": "3", "CreationDate": "2014-01-24T19:44:56.337", "ParentId": "21340801", "CommentCount": "0", "OwnerUserId": "962089", "LastEditDate": "2014-01-24T19:51:07.347"}, "21340989": {"Id": "21340989", "PostTypeId": "2", "Body": "<p>This is a known bug and will hopefully be fixed in C++17 (not for C++14, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1467\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1467</a>). Your struct is an aggregate, so to initialize it with <code>{someElement}</code> there needs to be at least one data member, as you have discovered. Try providing an <code>operator int();</code> and you will see it compiles. </p>\n", "LastActivityDate": "2014-01-24T19:34:09.647", "CommentCount": "1", "CreationDate": "2014-01-24T19:34:09.647", "ParentId": "21340801", "Score": "6", "OwnerUserId": "34509"}});