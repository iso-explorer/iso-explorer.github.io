post_cb({"46529605": {"Id": "46529605", "PostTypeId": "2", "Body": "<p>Yes, this is a minor wording defect in the standard. You can find that sentence (nearly) unchanged all the way back in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">N1905</a>:</p>\n<blockquote>\n<p id=\"so_46527754_46529605_0\">A <em>literal</em> is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other literals are rvalues.</p>\n</blockquote>\n<p>This standard predates user-defined literals by a few years (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2765.pdf\" rel=\"nofollow noreferrer\">N2765</a> is from mid-2008), and this particular wording wasn't change to reflect that the \"all other literals are [p]rvalues\" part shouldn't include user-defined literals.</p>\n<p>However, it's pretty clear that since a user-defined-literal is simply syntax sugar for a <a href=\"http://eel.is/c++draft/lex.literal#lex.ext-2.sentence-1\" rel=\"nofollow noreferrer\">function call</a>, its value category should be derived from the function call as well. That's the point of the language feature. There's no confusion that the value category of <code>5_a</code> in your example is lvalue and not prvalue (all compilers agree), so a defect report for this wording would get pretty low precedence, if any. </p>\n", "LastActivityDate": "2017-10-02T16:21:20.520", "CommentCount": "0", "CreationDate": "2017-10-02T16:21:20.520", "ParentId": "46527754", "Score": "4", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_46527754_46527754_0": {"length": 15, "quality": 0.9375, "section_id": 5947}, "so_46527754_46529605_0": {"length": 14, "quality": 0.875, "section_id": 5947}}, "n3337": {"so_46527754_46527754_0": {"length": 15, "quality": 0.9375, "section_id": 5717}, "so_46527754_46529605_0": {"length": 14, "quality": 0.875, "section_id": 5717}}, "n4659": {"so_46527754_46527754_0": {"length": 15, "quality": 0.9375, "section_id": 7433}, "so_46527754_46529605_0": {"length": 14, "quality": 0.875, "section_id": 7433}}}, "46527754": {"ViewCount": "119", "Body": "<p>I'm not sure if I'm missing something, but, user-defined literals, which invokes user-defined functions that could return anything, are also a kind of literals.</p>\n<p>The standard says that a literal is always a prvalue, unless it is a string literal, <a href=\"http://coliru.stacked-crooked.com/a/226d76a618817823\" rel=\"nofollow noreferrer\">but</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint&amp; operator\"\"_a(unsigned long long c);\n\nint main()\n{\n    std::cout &lt;&lt; std::is_same&lt;decltype(5_a), int&amp;&gt;::value;\n} \n</code></pre>\n<p>prints 1 in both GCC and Clang, which proofs that the literal <code>5_a</code> (which is not a string literal) is being treated as a lvalue instead of an rvalue:</p>\n<blockquote>\n<p id=\"so_46527754_46527754_0\"><a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr#prim.literal-1\" rel=\"nofollow noreferrer\"><strong>[expr.prim.literal]/1</strong></a> A <em>literal</em> is a primary expression. Its type depends on its form. A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p>and user-defined literals are <strong><a href=\"https://timsong-cpp.github.io/cppwp/n4659/lex.literal.kinds#1\" rel=\"nofollow noreferrer\">literals too</a></strong>.</p>\n<p>What is what I'm missing?</p>\n", "AcceptedAnswerId": "46529605", "Title": "Non-string literals are prvalues?", "CreationDate": "2017-10-02T14:39:02.137", "Id": "46527754", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-10-02T16:21:20.520", "Score": "3", "OwnerUserId": "1794803", "Tags": "<c++><c++14><c++1z><lvalue><user-defined-literals>", "AnswerCount": "1"}});