post_cb({"32812049": {"CommentCount": "12", "AcceptedAnswerId": "32812491", "PostTypeId": "1", "LastEditorUserId": "1042389", "CreationDate": "2015-09-27T19:37:27.040", "LastActivityDate": "2015-09-28T12:06:29.177", "LastEditDate": "2015-09-28T12:06:29.177", "ViewCount": "237", "FavoriteCount": "2", "Title": "Is there any special reason why the move constructor is not elided in the snippet shown below?", "Id": "32812049", "Score": "14", "Body": "<p><a href=\"http://coliru.stacked-crooked.com/a/19d414d2bc28ba48\" rel=\"nofollow\">gcc</a>, clang and VS2015 don't elide the call to the move constructor in the code below, after throwing object <code>a</code>. It seems to me the conditions established in bullet point (31.2) of \u00a78.12[class.copy]/31 (N4140) are satisfied.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    A() { std::cout &lt;&lt; \"Default ctor \" &lt;&lt; '\\n'; }\n    A(const A&amp; a) { std::cout &lt;&lt; \"Copy ctor\" &lt;&lt; '\\n'; }\n    A(A&amp;&amp; a) { std::cout &lt;&lt; \"Move ctor\" &lt;&lt; '\\n'; }\n    ~A() { std::cout &lt;&lt; \"Destructor \" &lt;&lt; '\\n'; }\n};\n\nint main()\n{\n    try\n    {\n        A a;\n        throw a;\n    }\n    catch(A&amp; a) { std::cout &lt;&lt; \"Caught\" &lt;&lt; '\\n'; }\n}\n</code></pre>\n<p>Note that <code>a</code> is an lvalue, but according to \u00a712.8/32, overload resolution\nto select the constructor for the copy is first performed as if the object were designated by an rvalue. That is, the call to the move constructor is OK. If you erase the definition of the move constructor above, the copy constructor is invoked, but again, it is not elided!</p>\n<p>I understand the copy-elision is not mandated by the Standard, but I'm curious to know if there is any special condition that could justify the fact, that the three compilers mentioned above avoid this optimization, in this particular example.</p>\n<p>An example output for gcc, from the link above:</p>\n<blockquote>\n<p id=\"so_32812049_32812049_0\">g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out</p>\n<p id=\"so_32812049_32812049_1\">Default ctor </p>\n<p id=\"so_32812049_32812049_2\">Move ctor</p>\n<p id=\"so_32812049_32812049_3\">Destructor </p>\n<p id=\"so_32812049_32812049_4\">Caught</p>\n<p id=\"so_32812049_32812049_5\">Destructor </p>\n</blockquote>\n", "Tags": "<c++><exception><c++14><copy-elision>", "OwnerUserId": "1042389", "AnswerCount": "1"}, "32812491": {"ParentId": "32812049", "CommentCount": "4", "CreationDate": "2015-09-27T20:26:27.523", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "32812491", "Score": "3", "Body": "<p>According to 12.8 [class.copy] paragraph 31, second bullet the copy of a local variable being thrown can be elided:</p>\n<blockquote>\n<p id=\"so_32812049_32812491_0\">in a <em>throw-expression</em>, when the operand is the name of a non-volatile automatic object (other than a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing <em>try-block</em> (if there is one), the copy/move operation from the operand to the exception object (15.1) can be omitted by constructing the automatic object directly into the exception object</p>\n</blockquote>\n<p>It seems none of the compilers makes use of this optimization. One reason could be that it is simply not worth doing so far as the effort is better spent on other optimizations. I don't think there is anything in the standard prohibiting this optimization.</p>\n", "LastActivityDate": "2015-09-27T20:26:27.523"}, "bq_ids": {"n4140": {"so_32812049_32812491_0": {"section_id": 480, "quality": 0.9473684210526315, "length": 36}}, "n3337": {"so_32812049_32812491_0": {"section_id": 471, "quality": 0.9473684210526315, "length": 36}}, "n4659": {"so_32812049_32812491_0": {"section_id": 502, "quality": 0.9736842105263158, "length": 37}}}});