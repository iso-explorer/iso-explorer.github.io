post_cb({"39545271": {"ParentId": "39545246", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You're comparing pointer values, not strings (note: <code>\"cose\"</code> is a different literal than <code>\"code\"</code>, \u00b9guaranteed giving a different pointer).</p>\n<p>Use <code>std::string</code> from the <code>&lt;string&gt;</code> header to get meaningful string operations.</p>\n<p>Then you can also use literals like <code>\"code\"s</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nauto main() -&gt; int\n{\n    cout &lt;&lt; boolalpha;\n    cout &lt;&lt; (\"t\"s &lt; \"c\"s) &lt;&lt; endl;\n    cout &lt;&lt; (\"c\"s &lt; \"t\"s) &lt;&lt; endl;\n    cout &lt;&lt; (\"code\"s &lt; \"test\"s) &lt;&lt; endl;\n    cout &lt;&lt; (\"test\"s &lt; \"cose\"s) &lt;&lt; endl;\n}\n</code></pre>\n<hr>\n<p>Formally the code in the question,</p>\n<pre><code>cout&lt;&lt;(\"t\"&lt;\"c\")&lt;&lt;endl;\ncout&lt;&lt;(\"c\"&lt;\"t\")&lt;&lt;endl;\ncout&lt;&lt;(\"code\"&lt;\"test\")&lt;&lt;endl;\ncout&lt;&lt;(\"test\"&lt;\"cose\")&lt;&lt;endl;\n</code></pre>\n<p>\u2026 has implementation defined behavior, because</p>\n<i>C++11 \u00a75.9/2 2<sup>nd</sup> dash (expr.rel):</i>\n<blockquote>\n<p id=\"so_39545246_39545271_0\"><strong>\u201d</strong>  If two pointers <code>p</code> and <code>q</code> of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspecified.</p>\n</blockquote>\n<p>You can however compare such pointers in a well-defined way via <code>std::less</code> and family, because</p>\n<i>C++11 20.8.5/8 (comparisons):</i>\n<blockquote>\n<p id=\"so_39545246_39545271_1\"><strong>\u201d</strong> For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p>\n</blockquote>\n<p>But on the third and gripping hand, while the pointer comparisons can be useful in some situations, you probably wanted to compare the string literals. The standard library offers e.g. <code>strcmp</code> in order to do that. But preferably use <code>std::string</code>, as noted at the start.</p>\n<hr>\n<p>The literal <code>\"code\"</code> denotes an immutable null-terminated string of <code>char</code> values. With the final null-byte it's a total of five <code>char</code> values. Hence the type is <code>char const[5]</code>.</p>\n<p>As an expression used in a context where a pointer is expected, the expression denoting this array (namely, the <code>\"code\"</code> literal) decays to a pointer to the first item, a <code>char const*</code> pointer.</p>\n<p>This is the usual decay of array expression to pointer, but in C++03 and earlier there was also a special rule for literals that allowed a decay to just <code>char*</code> (no <code>const</code>).</p>\n<hr>\n<p><sup>\n<em>Notes:</em><br>\n\u00b9 Two identical string literals can give different pointers, or the same pointer, depending on the compiler and options used.\n</br></sup></p>\n</hr></hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2016-09-17T11:32:29.717", "Id": "39545271", "Score": "4", "CreationDate": "2016-09-17T09:40:42.233", "LastActivityDate": "2016-09-17T11:32:29.717"}, "39545246": {"CommentCount": "0", "ViewCount": "82", "PostTypeId": "1", "LastEditorUserId": "418066", "CreationDate": "2016-09-17T09:38:10.760", "LastActivityDate": "2016-09-17T11:32:29.717", "Title": "Unexpected results when comparing strings", "AcceptedAnswerId": "39545271", "LastEditDate": "2016-09-17T09:46:15.243", "Id": "39545246", "Score": "1", "Body": "<p>I am comparing these two strings: <code>\"code\"</code> and <code>\"test\"</code></p>\n<p>When I type this in Visual Studio:</p>\n<pre><code>cout&lt;&lt;(\"t\"&lt;\"c\")&lt;&lt;endl;\ncout&lt;&lt;(\"c\"&lt;\"t\")&lt;&lt;endl;\ncout&lt;&lt;(\"code\"&lt;\"test\")&lt;&lt;endl;\ncout&lt;&lt;(\"test\"&lt;\"cose\")&lt;&lt;endl;\n</code></pre>\n<p>The result is:</p>\n<pre><code>1\n0\n1\n1\n</code></pre>\n<p>Which does not make sense, when I tried to try it on ideone.com, the result becomes:</p>\n<pre><code>0\n1\n1\n1\n</code></pre>\n<p>What is going wrong here?</p>\n", "Tags": "<c++><string><compare>", "OwnerUserId": "3120649", "AnswerCount": "2"}, "39545301": {"ParentId": "39545246", "CommentCount": "1", "Body": "<p>String literals, like e.g. <code>\"t\"</code> are actually constant arrays of characters (including terminator).</p>\n<p>When you use a string literal then what you get is a pointer to its first character.</p>\n<p>So when you do <code>\"t\" &lt; \"c\"</code> you are comparing two unrelated pointers. If <code>\"t\" &lt; \"c\"</code> is true or not depends on where the compiler have decided to put the string literal arrays.</p>\n<p>If you want to compare strings, you either should use <a href=\"http://en.cppreference.com/w/cpp/string/basic_string\" rel=\"nofollow\"><code>std::string</code></a>, or the old C-function <a href=\"http://en.cppreference.com/w/cpp/string/byte/strcmp\" rel=\"nofollow\"><code>strcmp</code></a>.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "39545301", "Score": "2", "CreationDate": "2016-09-17T09:43:30.867", "LastActivityDate": "2016-09-17T09:43:30.867"}, "bq_ids": {"n4140": {"so_39545246_39545271_1": {"section_id": 4605, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_39545246_39545271_1": {"section_id": 4423, "quality": 0.9333333333333333, "length": 14}, "so_39545246_39545271_0": {"section_id": 5913, "quality": 1.0, "length": 20}}, "n4659": {"so_39545246_39545271_1": {"section_id": 5962, "quality": 0.7333333333333333, "length": 11}}}});