post_cb({"bq_ids": {"n4140": {"so_42913556_42913797_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 175}}, "n3337": {"so_42913556_42913797_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 169}}, "n4659": {"so_42913556_42913797_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 180}}}, "42913797": {"Id": "42913797", "PostTypeId": "2", "Body": "<p>Writing <code>static_assert(false)</code> is simply ill-formed, because it runs afoul of [temp.res]:</p>\n<blockquote>\n<p id=\"so_42913556_42913797_0\">The program is ill-formed, no diagnostic required, if:<br>\n  \u2014 no valid specialization can be generated for a template or a substatement of a <code>constexpr if</code> statement (6.4.1) within a template and the template is not instantiated</br></p>\n</blockquote>\n<p>You can think of it as - since the <code>static_assert</code>'s constant expression isn't dependent, the compiler can just immediately see that it's ill-formed and fire.  </p>\n<hr/>\n<p>You can either just not provide a definition of <code>fn()</code> for that specialization, or you could do something like:</p>\n<pre><code>template &lt;class T&gt; struct always_false : std::false_type { };\nstatic_assert(always_false&lt;some_dependent_type&gt;::value, \"...\");\n</code></pre>\n<p>This would make it hypothetically possible for a valid specialization to be generated, even if nobody should ever specialize <code>always_false</code>. </p>\n", "LastActivityDate": "2017-03-20T20:55:39.870", "Score": "4", "CreationDate": "2017-03-20T20:55:39.870", "ParentId": "42913556", "CommentCount": "0", "OwnerUserId": "2069064"}, "42913556": {"ViewCount": "55", "Body": "<p>I'm thought I understood how a <code>static_assert</code> worked.  But when I tried this on a g++ compiler, I started to wonder:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n#define ENABLE_IF(...) std::enable_if_t&lt;__VA_ARGS__, int&gt; = 0\n\ntemplate&lt;typename...Ts&gt;\nstruct list{};\n\ntemplate&lt;typename...Ts&gt;\nstruct is_one_of;\n\ntemplate&lt;template &lt;typename...&gt; class TT, typename T, typename T1, typename...Ts&gt;\nstruct is_one_of&lt;T, TT&lt;T1, Ts...&gt;&gt; : is_one_of&lt;T, TT&lt;Ts...&gt;&gt; {};\n\ntemplate&lt;template &lt;typename...&gt; class TT, typename T, typename...Ts&gt;\nstruct is_one_of&lt;T, TT&lt;T, Ts...&gt;&gt; : std::true_type {};\n\ntemplate&lt;template &lt;typename...&gt; class TT, typename T&gt;\nstruct is_one_of&lt;T, TT&lt;&gt;&gt; : std::false_type {};\n\n\ntemplate&lt;typename...Ts&gt;\nstruct X;\n\ntemplate&lt;typename P, typename T, typename...Ts&gt;\nstruct X&lt;P, T, Ts...&gt; : X&lt;P, Ts...&gt;\n{\n  using X&lt;P, Ts...&gt;::fn;\n\n  template&lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value)&gt;\n  constexpr auto fn(R&amp;&amp; x)\n  {\n    return x;\n  }\n};\n\ntemplate&lt;template &lt;typename...&gt; class TT, typename...Ts&gt;\nstruct X&lt;TT&lt;Ts...&gt;&gt;\n{\n  template&lt;typename R, ENABLE_IF(!is_one_of&lt;R, TT&lt;Ts...&gt;&gt;::value)&gt;\n  constexpr auto fn(R&amp;&amp; x)\n  {\n    static_assert(false, \"Type R didn't match\");\n  }\n};\n\n\ntemplate&lt;typename...Ts&gt;\nstruct XX : X&lt;list&lt;Ts...&gt;, Ts...&gt; {};\n\n\nint main() {\n    XX&lt;int, float&gt; x;\n    std::cout &lt;&lt; x.fn(int(3)) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Now I would have thought that there wouldn't be any way that the base type <code>X&lt;TT&lt;Ts...&gt;&gt;</code> could have ever been instantiated because it is never called.  And through this reasoning, it should not cause a <code>static_assert</code> failure.</p>\n<p>This fails on g++ (5.4.0) and clang (3.9.1) but worked on VC++ 2015.</p>\n<p>Is this a defect or am I missing something?</p>\n", "AcceptedAnswerId": "42913797", "Title": "Are static_asserts to be evaluated if a member template isn't instantiated?", "CreationDate": "2017-03-20T20:41:04.547", "Id": "42913556", "CommentCount": "0", "LastEditDate": "2017-03-20T21:04:03.510", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-20T21:04:03.510", "Score": "1", "OwnerUserId": "1366368", "Tags": "<c++><c++14>", "AnswerCount": "1"}});