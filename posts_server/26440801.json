post_cb({"26440829": {"ParentId": "26440801", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Aggregate initialization - as the name implies - only works for aggregates. Adding a non-trivial constructor to a class makes it a non-aggregate. [dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_26440801_26440829_0\">List-initialization of an object or reference of type T is defined as\n  follows:<br> \u2014 If the initializer list has no elements and T is a class\n  type with a default constructor, the object is value-initialized.<br> \u2014\n  Otherwise, if T is an aggregate, aggregate initialization is performed\n  (8.5.1). <br>\u2014 Otherwise, [\u2026]</br></br></br></p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_26440801_26440829_1\">An <em>aggregate</em> is an array or a class (Clause 9) with <strong>no user-provided\n  constructors</strong> (12.1), [\u2026] <br>\n  When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list\n  are taken as initializers for the members of the aggregate, in increasing subscript or member order.</br></p>\n</blockquote>\n<p>Once your class isn't an aggregate anymore, list-initialization will look for a constructor to call, not the members to initialize.</p>\n<p>The reason is quite simple: If a class has non-trivial constructors, the <em>only way</em> to validly initialize an object of that class type is to call one of the constructors for that object. Initializing a class object without a corresponding constructor would be a devastating design failure.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-10-18T14:42:07.443", "Id": "26440829", "Score": "7", "CreationDate": "2014-10-18T14:30:41.813", "LastActivityDate": "2014-10-18T14:42:07.443"}, "bq_ids": {"n4140": {"so_26440801_26440829_0": {"section_id": 3325, "quality": 0.8181818181818182, "length": 18}, "so_26440801_26440829_1": {"section_id": 3299, "quality": 0.68, "length": 17}}, "n3337": {"so_26440801_26440829_0": {"section_id": 3195, "quality": 0.9545454545454546, "length": 21}, "so_26440801_26440829_1": {"section_id": 3169, "quality": 0.68, "length": 17}}, "n4659": {"so_26440801_26440829_0": {"section_id": 4091, "quality": 0.8181818181818182, "length": 18}, "so_26440801_26440829_1": {"section_id": 4065, "quality": 0.52, "length": 13}}}, "26440853": {"ParentId": "26440801", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is supposed that it is the explicit defined constructor that will initialize the structure.  So when an initializer list is used then the compiler searches an appropriate constructor. As you already pointed out yourself if to declare a constructor with two parameters of type int then you can use the initializer list to initialize data members of the structure because this constructor will be called. Or you could provide a constructor that has one parameter of type std::initializer_list.</p>\n<p>For example</p>\n<pre><code>S( std::initializer_list&lt;int&gt; );\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-10-21T06:40:46.417", "Id": "26440853", "Score": "1", "CreationDate": "2014-10-18T14:32:38.187", "LastActivityDate": "2014-10-21T06:40:46.417"}, "26440801": {"CommentCount": "0", "ViewCount": "1015", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-10-18T14:27:08.070", "LastActivityDate": "2016-03-18T00:58:48.893", "Title": "Why does an explicitly declared constructor prevent member initialisation with a C++ 11 initialisation list?", "AcceptedAnswerId": "26440829", "LastEditDate": "2016-03-18T00:58:48.893", "Id": "26440801", "Score": "2", "Body": "<p>I want to initialize a struct with an initialisation list like this:</p>\n<pre><code>struct S\n{\n    int a;\n    int b;\n\n    // S() : a(0), b(0){}  // uncommenting will cause compile error: \n                           // error C2440: 'initializing' : cannot convert from 'initializer-list' to 'S'\n\n    // S(int aArg, int bArg) : a(aArg), b(bArg) {}    // adding this removes the error\n}\n\nint main()\n{\n    S s{1,2};   // initialise with list\n}\n</code></pre>\n<p>Is there a good reason, why the explicitly declared default constructor will cause the error? I thought the initialisation lists where introduced to spare the programmer from writing tedious code like the second constructor. </p>\n", "Tags": "<c++><c++11><language-lawyer><initializer-list>", "OwnerUserId": "2466043", "AnswerCount": "2"}});