post_cb({"27349679": {"CommentCount": "0", "ViewCount": "1060", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-12-08T00:38:03.123", "LastActivityDate": "2014-12-08T00:57:41.990", "Title": "Is value initialization part of the C++98 standard? If not, why was it added in the C++03 standard?", "AcceptedAnswerId": "27349771", "LastEditDate": "2017-05-23T12:07:31.310", "Id": "27349679", "Score": "11", "Body": "<p>Cheers and hth. - Alf made a comment in this <a href=\"https://stackoverflow.com/a/8287020/1128289\">answer</a> that value initialization is arguably a new feature of C++03 compared to C++98. I wonder what he meant.</p>\n<p>Is <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow noreferrer\">value initialization</a> part of C++98? Is it present in concept but not in name? Why was it added to the C++03 standard?</p>\n<p>I have a copy of the '03 standard but not the '98 standard. Here's the definition of default initialization and value initialization.</p>\n<blockquote>\n<p id=\"so_27349679_27349679_0\">To default-initialize an object of type T means:</p>\n<p id=\"so_27349679_27349679_1\">\u2014 if T is a non-POD class type (clause 9), the default constructor for\n  T is called (and the initialization is ill-formed if T has no\n  accessible default constructor);</p>\n<p id=\"so_27349679_27349679_2\">\u2014 if T is an array type, each element is default-initialized;</p>\n<p id=\"so_27349679_27349679_3\">\u2014 otherwise, the object is zero-initialized.</p>\n<p id=\"so_27349679_27349679_4\">To value-initialize an object of type T means:</p>\n<p id=\"so_27349679_27349679_5\">\u2014 if T is a class type\n  (clause 9) with a user-declared constructor (12.1), then the default\n  constructor for T is called (and the initialization is ill-formed if T\n  has no accessible default constructor);</p>\n<p id=\"so_27349679_27349679_6\">\u2014 if T is a non-union class\n  type without a user-declared constructor, then every non-static data\n  member and base-class component of T is value-initialized;</p>\n<p id=\"so_27349679_27349679_7\">\u2014 if T is\n  an array type, then each element is value-initialized;</p>\n<p id=\"so_27349679_27349679_8\">\u2014 otherwise,\n  the object is zero-initialized</p>\n</blockquote>\n<p>My guess is that '98 had default initialization but not value initialization and that there's some key difference between the two. To be honest I'm having trouble parsing the standardese here and I don't understand the difference between the definitions.</p>\n", "Tags": "<c++><language-lawyer><c++03><c++98><value-initialization>", "OwnerUserId": "1128289", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27349679_27349679_0": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_27349679_27349771_1": {"section_id": 3290, "quality": 0.8571428571428571, "length": 6}, "so_27349679_27349679_1": {"section_id": 3286, "quality": 0.75, "length": 9}, "so_27349679_27349679_4": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_27349679_27349679_2": {"section_id": 3286, "quality": 1.0, "length": 5}, "so_27349679_27349679_7": {"section_id": 3287, "quality": 1.0, "length": 6}, "so_27349679_27349679_6": {"section_id": 369, "quality": 0.5384615384615384, "length": 7}, "so_27349679_27349771_3": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_27349679_27349679_5": {"section_id": 3286, "quality": 0.6, "length": 9}, "so_27349679_27349771_0": {"section_id": 3286, "quality": 1.0, "length": 4}}, "n3337": {"so_27349679_27349679_0": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_27349679_27349771_1": {"section_id": 3160, "quality": 0.8571428571428571, "length": 6}, "so_27349679_27349679_1": {"section_id": 3156, "quality": 0.8333333333333334, "length": 10}, "so_27349679_27349679_4": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_27349679_27349679_2": {"section_id": 3156, "quality": 1.0, "length": 5}, "so_27349679_27349679_7": {"section_id": 3157, "quality": 1.0, "length": 6}, "so_27349679_27349679_6": {"section_id": 359, "quality": 0.5384615384615384, "length": 7}, "so_27349679_27349771_3": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_27349679_27349679_5": {"section_id": 3157, "quality": 0.8, "length": 12}, "so_27349679_27349771_0": {"section_id": 3156, "quality": 1.0, "length": 4}}, "n4659": {"so_27349679_27349679_7": {"section_id": 4049, "quality": 1.0, "length": 6}, "so_27349679_27349771_1": {"section_id": 4052, "quality": 0.8571428571428571, "length": 6}, "so_27349679_27349679_2": {"section_id": 4048, "quality": 1.0, "length": 5}, "so_27349679_27349679_1": {"section_id": 384, "quality": 0.5833333333333334, "length": 7}, "so_27349679_27349679_5": {"section_id": 384, "quality": 0.5333333333333333, "length": 8}, "so_27349679_27349679_6": {"section_id": 7358, "quality": 0.5384615384615384, "length": 7}}}, "27349771": {"ParentId": "27349679", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Quoting <a href=\"http://sites.cs.queensu.ca/gradresources/stuff/cpp98.pdf\" rel=\"noreferrer\">the ISO/IEC 14882:1998 standard document</a> (that was withdrawn from ISO):</p>\n<blockquote>\n<p id=\"so_27349679_27349771_0\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if T is a non-POD class type (clause 9), the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no\n  accessible default constructor);</li>\n<li>if T is an array type, each element is default-initialized;</li>\n<li>otherwise, the storage for the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>And in paragraph 7:</p>\n<blockquote>\n<p id=\"so_27349679_27349771_1\">An object whose initializer is an empty set of parentheses, i.e., <code>()</code>, shall be default-initialized.</p>\n</blockquote>\n<p>Details on the rationale behind the change can be found in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1999/n1191.pdf\" rel=\"noreferrer\">the defect report</a> that made it happen:</p>\n<blockquote>\n<p id=\"so_27349679_27349771_2\">This definition is appropriate for local variables, but not for\n  objects that are initialized as a result of executing expressions of\n  the form <code>T()</code>, because the objects yielded by such expressions will\n  be copied immediately, and should therefore have values that are\n  assured of being copyable.<br> To this end, I propose adding the\n  following new text to 8.5, paragraph 5:</br></p>\n<p id=\"so_27349679_27349771_3\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if T is a class type (clause 9 [class]) with a user-declared constructor (12.1), then the default constructor for T is called (and\n  the initialization is ill-formed if T has no accessible default\n  constructor);</li>\n<li>if T is a class type without a user-declared constructor, then every non-static data member and base-class component of T is\n  value-initialized;</li>\n<li>if T is an array type, then each element is value-initialized;</li>\n<li>otherwise, the storage for the object is zero-initialized.</li>\n</ul>\n<p id=\"so_27349679_27349771_4\">In addition, I propose to change \u2018\u2018default-initialization\u2019\u2019 to\n  \u2018\u2018value-initialization\u2019\u2019 in 5.2.3 paragraph 2.</p>\n</blockquote>\n<p>And, following that, a historical explanation:</p>\n<blockquote>\n<p id=\"so_27349679_27349771_5\">Ancient history</p>\n<p id=\"so_27349679_27349771_6\">Once upon a time, an AT&amp;T compiler developer named Laura Eaves asked\n  me: \u2018\u2018What should be the value of <code>int()</code>?\u2019\u2019 My first thought was that\n  it should be the same value as <code>x</code> has after saying</p>\n<pre><code>int x;\n</code></pre>\n<p id=\"so_27349679_27349771_7\">but I soon realized that that definition would not do. The reason is\n  that x has an indeterminate value (assuming that it is a local\n  variable), but we don\u2019t mind that <code>x</code> is indeterminate, because we are\n  presumably going to assign a value to <code>x</code> before we use it. In contrast,\n  <code>int()</code> had better not have an indeterminate value, because copying\n  such a value has an undefined effect. It would be silly to forbid a\n  compiler from flagging <code>int()</code> during compilation, only to allow it to\n  flag it during execution! [\u2026]</p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-12-08T00:57:41.990", "Id": "27349771", "Score": "9", "CreationDate": "2014-12-08T00:50:35.273", "LastActivityDate": "2014-12-08T00:57:41.990"}});