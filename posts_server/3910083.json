post_cb({"12101976": {"ParentId": "3910083", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><a href=\"https://stackoverflow.com/a/3910420/1424877\">flownt got it right</a>, but I want to point out that in the final C++11 draft (N3337), the corresponding language has moved to section 10.3#16:</p>\n<blockquote>\n<p id=\"so_3910083_12101976_0\">A function with a deleted definition shall not override a function\n  that does not have a deleted definition. Likewise, a function that\n  does not have a deleted definition shall not override a function with\n  a deleted definition.<sup><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">2</a></sup></p>\n</blockquote>\n<p>It seems fairly clear <em>to me</em> (section 8.4.3#1) that a <em>deleted definition</em> does in fact count as a <em>definition</em>, and in fact an inline definition, which means a deleted definition satisfies 10.3#11:</p>\n<blockquote>\n<p id=\"so_3910083_12101976_1\">A virtual function declared in a class shall be defined, or declared\n  pure in that class, or both; but no diagnostic is required.<sup><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">2</a></sup></p>\n</blockquote>\n<p>However, it seems that current implementations disagree. Here's my test case:</p>\n<pre><code>struct Base {\n    virtual void bar();\n    virtual void foo() = delete;\n};\n\nvoid Base::bar() { }  // a definition of the first non-inline virtual function\nint main() { Base b; }\n</code></pre>\n<ul>\n<li><p>Clang produces an unlinkable program: <code>Base::foo</code> is mentioned in the vtable for <code>Base</code>. And if you swap the order of <code>foo</code> and <code>bar</code>, the linker complains that the entire vtable is missing (because Clang thinks <code>foo</code> is a non-inline function with no definition). <a href=\"http://llvm.org/bugs/show_bug.cgi?id=13684\" rel=\"nofollow noreferrer\">I filed this as a bug</a>; we'll see what the developers think.</p></li>\n<li><p>GCC complains about a \"use\" of <code>foo</code> at the end of the translation unit, when it creates the vtable; but it does correctly identify <code>bar</code> as the first non-inline virtual member function, no matter the order of <code>foo</code> and <code>bar</code>.</p></li>\n</ul>\n", "OwnerUserId": "1424877", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:31:14.013", "Id": "12101976", "Score": "4", "CreationDate": "2012-08-24T00:59:18.570", "LastActivityDate": "2012-08-24T00:59:18.570"}, "3910083": {"CommentCount": "3", "ViewCount": "3985", "PostTypeId": "1", "OwnerDisplayName": "user34537", "LastEditorDisplayName": "Roger Pate", "CreationDate": "2010-10-11T21:25:27.877", "LastActivityDate": "2014-12-13T06:53:46.100", "LastEditDate": "2010-10-12T16:12:02.273", "AcceptedAnswerId": "3910420", "FavoriteCount": "5", "Title": "Deleting virtual functions in C++0x", "Id": "3910083", "Score": "19", "Body": "<p>It isn't clear what happens if I delete a virtual method in C++0x:</p>\n<pre><code> virtual int derive_func() = delete;\n</code></pre>\n<p>Does this mean this class and everything that inherits from it can not define/implement the <code>derive_func()</code> method? Or is this illegal/compile error?</p>\n", "Tags": "<c++><c++11><virtual-functions><deleted-functions>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_3910083_12101976_1": {"section_id": 7012, "quality": 0.9166666666666666, "length": 11}, "so_3910083_12101976_0": {"section_id": 7017, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_3910083_12101976_1": {"section_id": 6758, "quality": 0.9166666666666666, "length": 11}, "so_3910083_12101976_0": {"section_id": 6763, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_3910083_12101976_1": {"section_id": 8509, "quality": 0.8333333333333334, "length": 10}, "so_3910083_12101976_0": {"section_id": 8514, "quality": 0.9473684210526315, "length": 18}}}, "3910420": {"ParentId": "3910083", "CommentCount": "7", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html#delete\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html#delete</a>\n<code>A deleted virtual function may not override a non-deleted virtual function and vice-versa.</code>\nmeaning its pretty useless (as i read  it at least) the only valid use would be:</p>\n<pre><code>struct A{\n     virtual void b() = delete;\n};\nstruct B:A{\n     virtual void b() = delete;\n};\n</code></pre>\n<p>which is completely useless, since the function can never be called. for non virtual functions the use is more justified</p>\n<p>EDIT\nto be completely clear this is the ONLY possible relation, children may not implement and you may not delete a non-deleted inherited virtual.</p>\n", "OwnerUserId": "323285", "PostTypeId": "2", "Id": "3910420", "Score": "14", "CreationDate": "2010-10-11T22:33:54.927", "LastActivityDate": "2010-10-11T22:33:54.927"}});