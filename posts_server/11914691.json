post_cb({"bq_ids": {"n4140": {"so_11914691_11915906_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}, "so_11914691_11914691_0": {"length": 64, "quality": 0.8311688311688312, "section_id": 481}, "so_11914691_11915906_0": {"length": 14, "quality": 1.0, "section_id": 6170}}, "n3337": {"so_11914691_11915906_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_11914691_11915906_0": {"length": 14, "quality": 1.0, "section_id": 5931}, "so_11914691_11914691_0": {"length": 73, "quality": 0.948051948051948, "section_id": 472}}, "n4659": {"so_11914691_11915906_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 502}, "so_11914691_11915906_0": {"length": 14, "quality": 1.0, "section_id": 7668}, "so_11914691_11914691_0": {"length": 60, "quality": 0.7792207792207793, "section_id": 504}}}, "11915906": {"Id": "11915906", "PostTypeId": "2", "Body": "<p>The specification for the conditional operator is so complicated it is scary.  But I believe that your compiler is correct in its behavior.  See 5.16 [expr.cond]/p4:</p>\n<blockquote>\n<p id=\"so_11914691_11915906_0\">If the second and third operands are glvalues of the same value\n  category and have the same type, the result is of that type and value\n  category ...</p>\n</blockquote>\n<p>Also see 12.8 [class.copy], p31, b1 which describes when copy elision is allowed:</p>\n<blockquote>\n<p id=\"so_11914691_11915906_1\">in a <code>return</code> statement in a function with a class return type, when\n  the expression is the name of a non-volatile automatic object (other\n  than a function or catch-clause parameter) with the same cv-\n  unqualified type as the function return type, the copy/move operation\n  can be omitted ...</p>\n</blockquote>\n<p>The expression is not the name of an automatic object, but is a conditional expression (and that conditional expression is an lvalue).  So copy elision is not allowed here, and there is nothing else that says that the lvalue expression can pretend to be an rvalue for overload resolution.</p>\n", "LastActivityDate": "2012-08-11T15:27:35.687", "Score": "10", "CreationDate": "2012-08-11T15:27:35.687", "ParentId": "11914691", "CommentCount": "3", "OwnerUserId": "576911"}, "11914691": {"ViewCount": "648", "Body": "<p>Consider the following example:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;cstdio&gt;\n\nclass object\n{\npublic:\n    object()\n    {\n        printf(\"constructor\\n\");\n    }\n\n    object(const object &amp;)\n    {\n        printf(\"copy constructor\\n\");\n    }\n\n    object(object &amp;&amp;)\n    {\n        printf(\"move constructor\\n\");\n    }\n};\n\nstatic object create_object()\n{\n    object a;\n    object b;\n\n    volatile int i = 1;\n\n// With #if 0, object's copy constructor is called; otherwise, its move constructor.\n#if 0\n    if (i)\n        return b; // moves because of the copy elision rules\n    else\n        return a; // moves because of the copy elision rules\n#else\n    // Seems equivalent to the above, but behaves differently.\n    return i ? b : a; // copies (with g++ 4.7)\n#endif\n}\n\nint main()\n{\n    auto data(create_object());\n\n    return 0;\n}\n</code></pre>\n<p>And consider this bit from the C++11 Working Draft, n3337.pdf, 12.8 [class.copy], point 32:</p>\n<blockquote>\n<p id=\"so_11914691_11914691_0\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, <strong>and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [Note: This two-stage overload resolution must be performed regardless of whether copy  elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. \u2014end note ]</p>\n</blockquote>\n<p>Thus, if we use <code>#if 1</code> in the example, the move constructor is first tried when returning the object, and then the copy constructor. Since we have a move constructor, it is used instead of the copy constructor.</p>\n<p>In the last <code>return</code> statement in <code>create_object()</code> however, we've observed that the move constructor is not used. Is or is this not a violation of the language rules? Does the language require that the move constructor is used in the last <code>return</code> statement?</p>\n", "AcceptedAnswerId": "11915906", "Title": "copy elision: move constructor not called when using ternary expression in return statement?", "CreationDate": "2012-08-11T12:26:32.440", "Id": "11914691", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-02-19T20:22:56.717", "LastEditorUserId": "1774667", "LastActivityDate": "2013-02-19T20:22:56.717", "Score": "9", "OwnerUserId": "1043205", "Tags": "<c++><c++11>", "AnswerCount": "1"}});