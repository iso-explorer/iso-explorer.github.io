post_cb({"23712025": {"CommentCount": "2", "ViewCount": "128", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2014-05-17T13:42:09.107", "LastActivityDate": "2014-05-18T22:22:28.103", "Title": "Nested enum and nested class have different behavior", "OwnerDisplayName": "user3374795", "LastEditDate": "2014-05-17T13:50:23.043", "Id": "23712025", "Score": "2", "Body": "<p>Consider these two examples:</p>\n<pre><code>struct X\n{\n    class E { static const int z = 16 };\n    static const int b = X::z;   // X has no member z\n};\n\nstruct Y \n{\n    enum E { z = 16 };\n    static const int b = Y::z;   // OK\n};\n</code></pre>\n<p>Is there a section of the standard that explains this behavior?</p>\n", "Tags": "<c++>", "AnswerCount": "3"}, "23712633": {"ParentId": "23712025", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, there are such sections in the C++ Standard.</p>\n<p>The first one is</p>\n<p><strong>9.9 Nested type names</strong></p>\n<blockquote>\n<p id=\"so_23712025_23712633_0\">1 Type names obey exactly the same scope rules as other names. In\n  particular, type names defined within a class definition <strong>cannot be\n  used outside their class without qualification</strong>.</p>\n</blockquote>\n<p>It would be more precisely to cite the following quote</p>\n<blockquote>\n<p id=\"so_23712025_23712633_1\">2 The name of a class member shall only be used as follows: \u2014 in the\n  scope of its class (as described above) or a class derived (Clause 10)\n  from its class, \u2014 after the . operator applied to an expression of the\n  type of its class (5.2.5) or a class derived from its class, \u2014 after\n  the -&gt; operator applied to a pointer to an object of its class (5.2.5)\n  or a class derived from its class, \u2014 after the :: scope resolution\n  operator (5.1) applied to the name of its class or a class derived\n  from its class.</p>\n</blockquote>\n<p>and the second one is</p>\n<p><strong>11.7 Nested classes</strong></p>\n<blockquote>\n<p id=\"so_23712025_23712633_2\">1 A nested class is a member and as such has the same access rights as\n  any other member. The members of an enclosing class have no special\n  access to members of a nested class; <strong>the usual access rules (Clause 11)\n  shall be obeyed</strong>.</p>\n</blockquote>\n<p>In this definition if do not take into account a typo (the absence of a semicolon after the definition of z)</p>\n<pre><code>struct X\n{\n    class E { static const int z = 16 };\n    static const int b = X::z;   // X has no member z\n};\n</code></pre>\n<p>You are trying to access z 1) without qualification and 2) that has private access control. </p>\n<p>The correct definition could look as</p>\n<pre><code>struct X\n{\n    class E { public: static const int z = 16; };\n    static const int b = E::z;\n};\n</code></pre>\n<p>As for the enumeration then enumerators of an unscopped enumeration are members of the class where the enumeration is defined.</p>\n<p><strong>9.2 Class members</strong></p>\n<blockquote>\n<p id=\"so_23712025_23712633_3\">1 The member-specification in a class definition declares the full set\n  of members of the class; no member can be added elsewhere. Members of\n  a class are data members, member functions (9.3), nested types, and\n  <strong>enumerators</strong>.</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-05-17T16:23:55.907", "Id": "23712633", "Score": "5", "CreationDate": "2014-05-17T14:47:31.773", "LastActivityDate": "2014-05-17T16:23:55.907"}, "23712077": {"ParentId": "23712025", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_23712025_23712077_0\"><code>[C++11: 7.2/10]:</code> Each <em>enum-name</em> and each <em>unscoped</em> enumerator is declared in the scope that immediately contains the <em>enum-specifier</em>. <em>[..]</em></p>\n</blockquote>\n<p>No such rule exists for classes.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "23712077", "Score": "3", "CreationDate": "2014-05-17T13:47:52.383", "LastActivityDate": "2014-05-17T13:47:52.383"}, "bq_ids": {"n4140": {"so_23712025_23712633_2": {"section_id": 6700, "quality": 0.9583333333333334, "length": 23}, "so_23712025_23712633_1": {"section_id": 7071, "quality": 0.9411764705882353, "length": 48}, "so_23712025_23712633_0": {"section_id": 5933, "quality": 1.0, "length": 21}, "so_23712025_23712633_3": {"section_id": 5861, "quality": 0.9545454545454546, "length": 21}, "so_23712025_23712077_0": {"section_id": 5470, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_23712025_23712633_2": {"section_id": 6455, "quality": 0.9583333333333334, "length": 23}, "so_23712025_23712633_1": {"section_id": 6815, "quality": 0.9411764705882353, "length": 48}, "so_23712025_23712633_0": {"section_id": 5705, "quality": 1.0, "length": 21}, "so_23712025_23712633_3": {"section_id": 5631, "quality": 0.9545454545454546, "length": 21}, "so_23712025_23712077_0": {"section_id": 5256, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_23712025_23712633_2": {"section_id": 8174, "quality": 0.9583333333333334, "length": 23}, "so_23712025_23712633_1": {"section_id": 8572, "quality": 0.9411764705882353, "length": 48}, "so_23712025_23712633_3": {"section_id": 7340, "quality": 0.9545454545454546, "length": 21}, "so_23712025_23712633_0": {"section_id": 7403, "quality": 1.0, "length": 21}, "so_23712025_23712077_0": {"section_id": 6904, "quality": 0.8333333333333334, "length": 10}}}, "23720987": {"ParentId": "23712025", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You asked for citations from the Standard, and you've got the right ones, but it seems they don't help:</p>\n<blockquote>\n<p id=\"so_23712025_23720987_0\">How this implies that enum members can be accessed from the outer declarative region? \u2013  St.Antario</p>\n<p id=\"so_23712025_23720987_1\">+1 to St.Antario. I don't understand it to. \u2013  zavhoz</p>\n</blockquote>\n<p>So I'll try the investigative approach. If we fix the irrelevant bugs in your\nexample <code>struct X</code>:</p>\n<ul>\n<li>Missing <code>;</code> after 16.</li>\n<li><code>E::z</code> is priviate.</li>\n</ul>\n<p>We have:</p>\n<pre><code>struct X\n{\n    struct E { static const int z = 16; };\n    static const int b = X::z;\n};\n</code></pre>\n<p>Compiling your code thus fixed, clang 3.4 complains:</p>\n<pre><code>error: no member named 'z' in 'X'; did you mean 'E::z'?\nstatic const int b = X::z;\n                     ^~~~\n                     E::z\n</code></pre>\n<p>(gcc 4.9.0 and VC++ 2013 gives errors at the same line, but with less helpful\ndiagnostics)</p>\n<p>No such complaint about <code>Y::z</code>, however. The lesson seems to be:</p>\n<ul>\n<li><p>A class definition does <em>not</em> declare the class members in the enclosing\nscope.</p></li>\n<li><p>A plain old enum definition <em>does</em> declare the enumerators in the\nenclosing scope.</p></li>\n</ul>\n<p>I say <em>plain old enum</em> here, because as of C++11 we have also got a new fancier\nkind of enum, but <code>Y::E</code> is a plain old one.</p>\n<p>If that's the lesson, it does not appear to have anything in particular \nto do with <em>nesting</em>.</p>\n<p>Vlad from Moscow has cited you a paragraph of the Standard from <strong>11.7 Nested classes</strong>\nfrom which he presumably wants you to gather that nesting is irrelevant to your\npuzzle. But the fact that the compiler barfs at the qualified name <code>X::z</code>\nand does not barf at the qualified name <code>Y::z</code> makes it look as if the\nnesting of <em>struct</em> <code>E</code> in struct <code>X</code> has some significance that the nesting of\n<em>enum</em> <code>E</code> in struct <code>Y</code> does not.</p>\n<p>Recall that for any name <code>N</code> that is declared in a scope <code>S</code>, the\nqualification <code>S::N</code> is <em>redundant</em> within the scope of <code>S</code>, just as the\nqualification <code>::N</code> is redundant at global scope for a global name <code>N</code>.</p>\n<p><em>If</em> there is something declared <code>z</code> in the scope of <code>X</code>[<code>Y</code>], then within the scope of\n<code>X</code>[<code>Y</code>] you can refer to it as just <code>z</code>. So let's delete the superfluous\nqualifications from the example code:</p>\n<pre><code>struct X\n{\n    struct E { static const int z = 16; };\n    static const int b = z;\n};\n\nstruct Y \n{\n    enum E { z = 16 };\n    static const int b = z;\n};\n</code></pre>\n<p>and see what clang makes of it now:</p>\n<pre><code>error: use of undeclared identifier 'z'; did you mean 'E::z'?\nstatic const int b = z;\n                     ^\n                     E::z\n</code></pre>\n<p>It has just the same problem in <code>X</code>; still has no problem in <code>Y</code>. But since\nwe've got rid of the superfluous qualification, <code>X</code> <em>isn't mentioned at all.</em></p>\n<p>And <code>Y</code> has <em>never</em> been mentioned. So maybe now it no longer looks as if\nnesting has something to do with the puzzle.</p>\n<p>So next let's go ahead and get rid of <code>X</code> and <code>Y</code>. Here's the program:</p>\n<pre><code>struct E { static const int z = 16; };\nstatic const int b = z;\nenum E1 { z = 16 };\nstatic const int b = z;\n\nint main()\n{\n    return 0;\n}\n</code></pre>\n<p>And clang says:</p>\n<pre><code>error: use of undeclared identifier 'z'; did you mean 'E::z'?\nstatic const int b = z;\n                     ^\n                     E::z\n</code></pre>\n<p>No change at all.</p>\n<p>So nesting has, indeed, nothing to do with the puzzle. The fact of the matter <em>is</em>\nthat struct|class members are declared in the struct|class scope, <em>not</em>\nin the enclosing scope, and the enumerators of a plain old enum are declared in the\n<em>enclosing scope</em>. Lightness Races in Orbit has given you the Standard reference\nfor the latter fact.</p>\n<p>Does this still surprise you? It can hardly suprise you that:</p>\n<pre><code>struct E { static const int z = 16; };\nstatic const int b = z;\n</code></pre>\n<p>does not declare <code>z</code> in the same scope as <code>b</code>. So possibly it suprises you that:</p>\n<pre><code>enum E1 { z = 16 };\nstatic const int b = z;\n</code></pre>\n<p><em>does</em> declare <code>z</code> in the same scope as <code>b</code>? Well, that is how plain old enums\nhave always been, since C++ inherited them and C. That is largely what makes\nthem <em>plain old</em> enums.</p>\n<p>This scope-hoisting trait of plain old enums is the reason why, in C++11\njargon, plain old enums are called <em>unscoped enums</em>. And this trait, as\nwell as the readiness of unscoped enumerators to decay to <code>int</code>, has\nmade unscoped enums long a source of discomfort in C++.</p>\n<p>Hence in C++11 we now have a more strictly behaved alternative, called a <em>scoped enum</em> or\n<em>enum class</em> which goes something like this:</p>\n<pre><code>enum struct SE : short {\n    z = 16\n};\n//const int b = z; &lt;- Undeclared identifier\n//const short b = SE::z; &lt;- No implicit conversion\nSE b = SE::z; //OK\nconst int c = static_cast&lt;int&gt;(SE::z); //OK\n</code></pre>\n<p>It looks as if scoped enums would not surprise you as to the scoping\nof their enumerators but <em>would</em> suprise you by resisting implicit\nintegral conversions.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/enum\" rel=\"nofollow\">Further reading</a>.</p>\n", "OwnerUserId": "1362568", "LastEditorUserId": "1362568", "LastEditDate": "2014-05-18T22:22:28.103", "Id": "23720987", "Score": "0", "CreationDate": "2014-05-18T10:35:49.237", "LastActivityDate": "2014-05-18T22:22:28.103"}});