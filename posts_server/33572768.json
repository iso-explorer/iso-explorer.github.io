post_cb({"33572822": {"ParentId": "33572768", "CommentCount": "7", "Body": "<p>From [over.oper]:</p>\n<blockquote>\n<p id=\"so_33572768_33572822_0\">An operator function shall either be a non-static member function or be a non-member function that has\n  <strong>at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an\n  enumeration</strong>.</p>\n</blockquote>\n<p>So you can't overload an operator whose parameters are both builtins. Furthermore, in order for <code>operator*(int, std::string)</code> to be found, it'd have to be in <code>namespace std</code> and it's ill-formed to add definitions to that namespace.</p>\n<p>Instead, you could simply provide a small wrapper:</p>\n<pre><code>struct Mult { int value; };\n</code></pre>\n<p>and provide overloads for it:</p>\n<pre><code>std::string operator*(const Mult&amp;, const char* );\nstd::string operator*(const char*, const Mult&amp; );\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "33572822", "Score": "5", "CreationDate": "2015-11-06T17:57:42.893", "LastActivityDate": "2015-11-06T17:57:42.893"}, "33573046": {"ParentId": "33572768", "CommentCount": "0", "Body": "<p>You neither can nor must overload that op;</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow\">string ctor (2)</a> does the job for you</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::cout &lt;&lt; \"here's a message:\\n\" \n              &lt;&lt; std::string(5, '\\n') \n              &lt;&lt; \"EOF\" &lt;&lt; std::endl;\n} \n</code></pre>\n<p>output:</p>\n<pre><code>here's a message:\n\n\n\n\n\n\nEOF\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b2c401b8264984b3\" rel=\"nofollow\">(live at Coliru)</a></p>\n", "OwnerUserId": "5397699", "PostTypeId": "2", "Id": "33573046", "Score": "0", "CreationDate": "2015-11-06T18:11:56.210", "LastActivityDate": "2015-11-06T18:11:56.210"}, "33573065": {"ParentId": "33572768", "CommentCount": "3", "Body": "<p>You should be able to achive it with user-defined literals. For instance:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n\nstd::string operator\"\" _s(const char* s) { return std::string(s); }\n\nstd::string operator\"\" _s(const char* s, std::size_t len) { return std::string(s, len); }\n\nstd::string operator* (unsigned int k, std::string s) {\n    std::string t;\n    for (unsigned int i = 0; i &lt; k; ++i) \n        t += s;\n\n    return t;\n}\n\nstd::string operator* (std::string s, unsigned int k) { return k * s; }\n\nint main() {\n    std::cout &lt;&lt; \"Jump!\"_s * 5 &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "OwnerUserId": "5245033", "PostTypeId": "2", "Id": "33573065", "Score": "0", "CreationDate": "2015-11-06T18:12:38.990", "LastActivityDate": "2015-11-06T18:12:38.990"}, "33572824": {"ParentId": "33572768", "CommentCount": "0", "Body": "<p>From C++ FAQ <a href=\"https://isocpp.org/wiki/faq/intrinsic-types#intrinsics-and-operator-overloading\" rel=\"nofollow\">here</a>,</p>\n<blockquote>\n<p id=\"so_33572768_33572824_0\">C++ language requires that your operator overloads take at least one\n  operand of a \u201cclass type\u201d or enumeration type. The C++ language will\n  not let you define an operator all of whose operands / parameters are\n  of primitive types.</p>\n</blockquote>\n", "OwnerUserId": "2328763", "PostTypeId": "2", "Id": "33572824", "Score": "3", "CreationDate": "2015-11-06T17:58:02.433", "LastActivityDate": "2015-11-06T17:58:02.433"}, "33572768": {"CommentCount": "10", "ViewCount": "152", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-06T17:53:37.493", "LastActivityDate": "2015-11-06T18:12:38.990", "Title": "Possible to overload operator* to multiple an int and a char*?", "AcceptedAnswerId": "33573065", "LastEditDate": "2017-05-23T12:23:08.370", "Id": "33572768", "Score": "0", "Body": "<p>I would like to get functionality so I can do this:</p>\n<pre><code>std::cout &lt;&lt; \"here's a message\" &lt;&lt; 5*\"\\n\";\n</code></pre>\n<p>I tried the following:</p>\n<pre><code>std::string operator* (int lhs, const char* rhs) {\n  std::string r = \"\";\n  for(int i = 0; i &lt; lhs; i++) {\n    r += rhs;\n  }\n  return r;\n}\n</code></pre>\n<p>And I got this error message:</p>\n<pre><code>error: \u2018std::string operator*(int, const char*)\u2019 must have an argument of class or enumerated type\n</code></pre>\n<p>According to the answers in this SO post <a href=\"https://stackoverflow.com/questions/17139490/what-does-must-have-an-argument-of-class-or-enumerated-type-actually-mean\">What does 'must have an argument of class or enumerated type' actually mean</a> it almost seems like I can't do this period. Is that really the case? If not, how do I fix this or arrange a workaround?</p>\n<p>What I know I can do is have <code>rhs</code> as a <code>std::string</code>, but then the whole point of the exercise is half foregone, as <code>5*std::string(\"\\n\")</code> is quite clunky.</p>\n", "Tags": "<c++><overloading>", "OwnerUserId": "4678042", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_33572768_33572822_0": {"section_id": 653, "quality": 1.0, "length": 19}}, "n3337": {"so_33572768_33572822_0": {"section_id": 643, "quality": 1.0, "length": 19}}, "n4659": {"so_33572768_33572822_0": {"section_id": 681, "quality": 1.0, "length": 19}}}});