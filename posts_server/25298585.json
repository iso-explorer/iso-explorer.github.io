post_cb({"28490097": {"ParentId": "25298585", "CommentCount": "3", "Body": "<p>What you're looking for is the <a href=\"http://en.cppreference.com/w/cpp/numeric/random/independent_bits_engine\"><code>std::independent_bits_engine</code></a> adaptor:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;random&gt;\n#include &lt;climits&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n\nusing random_bytes_engine = std::independent_bits_engine&lt;\n    std::default_random_engine, CHAR_BIT, unsigned char&gt;;\n\nint main()\n{\n    random_bytes_engine rbe;\n    std::vector&lt;unsigned char&gt; data(1000);\n    std::generate(begin(data), end(data), std::ref(rbe));\n}\n</code></pre>\n<p>Note that the accepted answer is not strictly correct in a general case \u2013 random engines produce unsigned values belonging to a range [<code>min()</code>, <code>max()</code>], which doesn't necessarily cover all possible values of the result type (for instance, <code>std::minstd_rand0::min() == 1</code>) and thus you may get random bytes that are not uniformly distributed if using an engine directly. However, for <code>std::random_device</code> the range is [<code>std::numeric_limits&lt;result_type&gt;::min()</code>, <code>std::numeric_limits&lt;result_type&gt;::max()</code>], so this particular engine would also work well without the adaptor.</p>\n", "OwnerUserId": "4561393", "PostTypeId": "2", "Id": "28490097", "Score": "18", "CreationDate": "2015-02-12T23:48:31.873", "LastActivityDate": "2015-02-12T23:48:31.873"}, "25298790": {"ParentId": "25298585", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Distributions take random bits and turn them into numbers. If you actually want random bits then you want to use an engine:</p>\n<blockquote>\n<p id=\"so_25298585_25298790_0\">In particular, those requirements specify the algorithmic interface for types and objects that produce sequences of bits in which each possible bit value is uniformly likely.<sup>3</sup> </p>\n<p id=\"so_25298585_25298790_1\">A single call to a URNG object is allowed to produce and deliver many (typically 32 or more) bits, returning these bits as a single packaged value of an unsigned integer type.<sup>4</sup>\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3847.pdf\" rel=\"nofollow noreferrer\">N3847</a></p>\n</blockquote>\n<p><code>random_device</code> happens to be specified such that accessing uniformly distributed bits is easy:</p>\n<pre><code>std::random_device engine;\nunsigned x = engine(); // sizeof(unsigned) * CHAR_BIT random bits\n</code></pre>\n<p>Note that other engines may not make it quite as easy to get uniformly random bits as <code>random_device</code>, due to returning fewer bits than their result_type can hold or even by effectively returning fractional bits.</p>\n<p>If your concern is that <code>unsigned</code>'s size is implementation defined and so <code>random_device</code> returns an implementation defined number of bits, you can write an adapter that either collects enough bits before giving them to you, or one that will give you just enough bits and cache the rest for your next request. (You can also do this to handle other engines which exhibit the previously mentioned issues.)</p>\n", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2015-04-03T22:30:52.127", "Id": "25298790", "Score": "13", "CreationDate": "2014-08-14T01:42:27.583", "LastActivityDate": "2015-04-03T22:30:52.127"}, "25298621": {"ParentId": "25298585", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>To answer your question: You can't.</p>\n<p>The standard does not allow <code>std::uniform_int_distribution</code> to be templated on <code>char</code>, <code>signed char</code>, or <code>unsigned char</code>.  Some believe that this is a defect in the standard, but it is the case.</p>\n<p>You can simply template <code>std::uniform_int_distribution</code> on <code>unsigned short</code>, and set its min/max range to <code>std::numeric_limits&lt;unsigned char&gt;::min()</code> and <code>std::numeric_limits&lt;unsigned char&gt;::max()</code>, and then simply assign the result to an <code>unsigned char</code>.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_25298585_25298621_0\">Throughout this subclause 26.5, the effect of instantiating a template:</p>\n<p id=\"so_25298585_25298621_1\">[...]</p>\n<p id=\"so_25298585_25298621_2\">e) that has a template type parameter named <code>IntType</code> is undefined unless the corresponding template argument is cv-unqualified and is one of <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code>, or <code>unsigned long long</code>.</p>\n<p id=\"so_25298585_25298621_3\">\u00a726.5.1.1 [rand.req.genl]</p>\n</blockquote>\n<p>Moreover:</p>\n<p>You should use <a href=\"http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine\" rel=\"nofollow noreferrer\"><code>std::mt19937</code></a> to actually generate your random bytes.  <code>std::random_device</code> is liable to be slow, and likely produces entropy with statistical properties (i.e. suitability for use in cryptography) that you don't need.</p>\n<p>That said, you will need to seed your <code>std::mt19937</code>.  You can do this with a <code>std::random_device</code> and a <a href=\"http://en.cppreference.com/w/cpp/numeric/random/seed_seq\" rel=\"nofollow noreferrer\"><code>std::seed_seq</code></a>.</p>\n<p>Note that if you don't use a <code>std::seed_seq</code> to seed your <code>std::mt19937</code>, your <code>std::mt19937</code> will be left with many, many zeroes in its internal state, and it will therefore take it quite a while to \"warm up\".</p>\n<p>For more information on \"warm up\", <a href=\"https://stackoverflow.com/a/15509942/1007504\">see here</a>.</p>\n", "OwnerUserId": "1007504", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:33:17.283", "Id": "25298621", "Score": "4", "CreationDate": "2014-08-14T01:16:27.510", "LastActivityDate": "2014-08-14T01:16:27.510"}, "bq_ids": {"n4140": {"so_25298585_25298621_2": {"section_id": 3487, "quality": 1.0, "length": 25}, "so_25298585_25298621_0": {"section_id": 3487, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_25298585_25298621_2": {"section_id": 3352, "quality": 1.0, "length": 25}, "so_25298585_25298621_0": {"section_id": 3352, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_25298585_25298621_2": {"section_id": 4250, "quality": 1.0, "length": 25}, "so_25298585_25298621_0": {"section_id": 4250, "quality": 0.8333333333333334, "length": 5}}}, "25298585": {"CommentCount": "10", "AcceptedAnswerId": "25298790", "CreationDate": "2014-08-14T01:10:04.510", "LastActivityDate": "2015-04-03T22:30:52.127", "PostTypeId": "1", "ViewCount": "5995", "FavoriteCount": "2", "Title": "Efficiently generating random bytes of data in C++11/14", "Id": "25298585", "Score": "9", "Body": "<p>My requirement is to generate random bytes of data <em>(not random numbers)</em> aka uniformly distributed bits.</p>\n<p>As such I was wondering what are the correct/efficient ways of doing this using C++11/14 random facilities. I've had a look around at the examples, but they <strong><em>all</em></strong> seem to focus on number generation <em>(ints, floats etc)</em></p>\n<p>Current solution I'm using is the following:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;random&gt;\n\nint main()\n{\n   std::random_device rd;\n   std::uniform_int_distribution&lt;int&gt; dist(0,255);\n   std::vector&lt;char&gt; data(1000);\n   for (char&amp; d : data)\n   {\n      d = static_cast&lt;char&gt;(dist(rd) &amp; 0xFF);\n   }\n   return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><random><distribution>", "OwnerUserId": "765234", "AnswerCount": "3"}});