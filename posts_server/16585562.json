post_cb({"16586237": {"ParentId": "16585562", "CommentCount": "0", "CreationDate": "2013-05-16T11:28:00.743", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "16586237", "Score": "18", "Body": "<p><code>this</code> is an rvalue (you cannot take its address), so it doesn't\n(necessarily) occupy memory at all.  Depending on the compiler\nand the target architecture, it will often be in a register: i0\non a Sparc, ECX with MSVC on Intel, etc.  When the optimizer is\nactive, it can even move around. (I've seen it in different\nregisters with MSVC). </p>\n", "LastActivityDate": "2013-05-16T11:28:00.743"}, "16585619": {"ParentId": "16585562", "CommentCount": "0", "CreationDate": "2013-05-16T10:57:12.580", "OwnerUserId": "1468366", "PostTypeId": "2", "Id": "16585619", "Score": "9", "Body": "<p><code>this</code> behaves mostly like a function argument, and as such will be stored on the stack or - if the binary calling conventions of the architecture allow that - in a register.</p>\n", "LastActivityDate": "2013-05-16T10:57:12.580"}, "16585562": {"CommentCount": "0", "AcceptedAnswerId": "16592164", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2013-05-16T10:54:55.253", "LastActivityDate": "2013-05-22T20:04:26.830", "LastEditDate": "2013-05-22T20:04:26.830", "ViewCount": "7965", "FavoriteCount": "11", "Title": "Where is the 'this' pointer stored in computer memory?", "Id": "16585562", "Score": "63", "Body": "<p>Where exactly is the 'this' pointer stored in memory? Is it allocated on the stack, in the heap, or in the data segment?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass ClassA\n{\n    int a, b;\n\n    public:\n        void add()\n        {\n            a = 10;\n            b = 20;\n            cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;\n        }\n};\n\nint main()\n{\n    ClassA obj;\n    obj.add();\n    return 0;\n}\n</code></pre>\n<p>In the above code I am calling the member function <code>add()</code> and the receiver object is passed implicitly as the 'this' pointer. Where is <code>this</code> stored in memory?</p>\n", "Tags": "<c++><this-pointer>", "OwnerUserId": "1890764", "AnswerCount": "6"}, "16591152": {"ParentId": "16585562", "CommentCount": "0", "CreationDate": "2013-05-16T15:08:28.583", "OwnerUserId": "1250772", "PostTypeId": "2", "Id": "16591152", "Score": "0", "Body": "<p><code>this</code> isn't stored at a well-defined location! The object that it points to is stored somewhere, and has a well-defined address, but the address itself does not have a specific home address. It is communicated around in the program. Not only that, but there can be many copies of that pointer.</p>\n<p>In the following imaginary <code>init</code> function, the object registers itself to receive events and timer callbacks (using imaginary event source objects). So after the registration, there are two additional copies of <code>this</code>:</p>\n<pre><code>void foo_listener::init()\n{\n   g_usb_events.register(this); // register to receive USB events\n   g_timer.register(this, 5);   // register for a 5 second timer\n}\n</code></pre>\n<p>I a function activation chain, there will also be multiple copies of the this pointer. Suppose we have an object <code>obj</code> and call its <code>foo</code> function. That function calls the same object's <code>bar</code> function, and <code>bar</code> calls another function called <code>update</code>. Each function activation level has the <code>this</code> pointer. It's stored in a machine register, or in a memory location in the stack frame of the function activation.</p>\n", "LastActivityDate": "2013-05-16T15:08:28.583"}, "16585669": {"ParentId": "16585562", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-05-16T10:59:57.880", "Score": "33", "LastEditorUserId": "453803", "LastEditDate": "2013-05-17T04:05:17.173", "Id": "16585669", "OwnerUserId": "453803", "Body": "<p><code>this</code> is usually passed as a hidden argument of the method (the only difference throughout different calling conventions is <em>how</em>).</p>\n<p>If you call:</p>\n<pre><code>myClass.Method(1, 2, 3);\n</code></pre>\n<p>Compiler generates the following code:</p>\n<pre><code>Method(&amp;myClass, 1, 2, 3);\n</code></pre>\n<p>Where the first parameter is actually the pointer to <code>this</code>.</p>\n<p>Let's check the following code:</p>\n<pre><code>class MyClass\n{\nprivate:\n    int a;\n\npublic:\n    void __stdcall Method(int i)\n    {\n        a = i;\n    }\n};\n\nint main(int argc, char *argv[]) \n{\n    MyClass myClass;\n    myClass.Method(5);\n\n    return 0;\n}\n</code></pre>\n<p>By using <code>__stdcall</code> I forced the compiler to pass all parameters through the stack. If you then start the debugger and inspect the assembly code, you'll find something like the following:</p>\n<pre class=\"lang-none prettyprint-override\"><code>     myClass.Method(5);\n00AA31BE  push        5  \n00AA31C0  lea         eax,[myClass]  \n00AA31C3  push        eax  \n00AA31C4  call        MyClass::Method (0AA1447h)  \n</code></pre>\n<p>As you see, the parameter of the method is passed through the stack, then address of myClass is loaded to eax register and again pushed on the stack. In other words, <code>this</code> is treated as a regular parameter of this method.</p>\n", "LastActivityDate": "2013-05-17T04:05:17.173"}, "16585615": {"ParentId": "16585562", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2013-05-16T10:56:56.827", "Score": "78", "LastEditorUserId": "28169", "LastEditDate": "2013-05-17T07:35:15.273", "Id": "16585615", "OwnerUserId": "28169", "Body": "<p>The easiest way is to think of <code>this</code> as being a hidden extra argument that is always passed automatically.</p>\n<p>So, a fictional method like:</p>\n<pre><code>size_t String::length(void) const\n{\n  return strlen(m_string);\n}\n</code></pre>\n<p>is actually more like this under the hood:</p>\n<pre><code>size_t String__length(const String *this)\n{\n  return strlen(this-&gt;m_string);\n}\n</code></pre>\n<p>and a call like:</p>\n<pre><code>{\n  String example(\"hello\");\n  cout &lt;&lt; example.length();\n}\n</code></pre>\n<p>becomes something like:</p>\n<pre><code>cout &lt;&lt; String__length(&amp;example);\n</code></pre>\n<p>Note that the above transformation is simplified, hopefully to make my point a bit clearer. No need to fill up the comments with \"whaaa, where's the marshalling for method overloading, huh?\"-type objection, please. :)</p>\n<p>That transforms the question into \"where are arguments stored?\", and the answer is of course \"it depends\". :)</p>\n<p>It's often on the stack, but it could be in registers too, or any other mechanism that the compiler considers is good for the target architecture.</p>\n", "LastActivityDate": "2013-05-17T07:35:15.273"}, "bq_ids": {"n4140": {"so_16585562_16592164_0": {"section_id": 5895, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_16585562_16592164_0": {"section_id": 5666, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_16585562_16592164_0": {"section_id": 7378, "quality": 0.9230769230769231, "length": 12}}}, "16592164": {"ParentId": "16585562", "CommentCount": "1", "CreationDate": "2013-05-16T15:54:43.997", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "16592164", "Score": "63", "Body": "<p>Other answers have done a very good job explaining how a typical compiler implements <code>this</code> (by passing it as an implicit first parameter to the function).</p>\n<p>I think it's also useful to see what the C++ ISO spec explicitly says about this.  According to the C++03 ISO spec, \u00a79.3.2/1:</p>\n<blockquote>\n<p id=\"so_16585562_16592164_0\">In the body of a nonstatic (9.3) member function, the keyword <code>this</code> is a non-lvalue expression whose value is the address of the object for which the function is called.</p>\n</blockquote>\n<p>It's important to note that <code>this</code> is <strong>not</strong> a variable - it's an <em>expression</em>, much in the same way that the expression <code>1 + 2 * 3</code> is an expression.  The value of this expression is permitted to be stored pretty much anywhere.  The compiler <em>might</em> put it on the stack and pass it as an implicit parameter to a function, or it <em>might</em> put it in a register, and it conceivably could put it in the heap or in the data segment.  The C++ specification deliberately gives the implementation some flexibility here.</p>\n<p>I think that the \"language-lawyer\" answer is \"this is completely implementation-defined, and moreover <code>this</code> is technically not a pointer, but an expression that evaluates to a pointer.\"</p>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2013-05-16T15:54:43.997"}});