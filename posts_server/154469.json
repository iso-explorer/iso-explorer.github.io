post_cb({"155734": {"ParentId": "154469", "CommentCount": "2", "Body": "<p>I recently began replacing static keywords with anonymous namespaces in my code but immediately ran into a problem where the variables in the namespace were no longer available for inspection in my debugger. I was using VC60, so I don't know if that is a non-issue with other debuggers. My workaround was to define a 'module' namespace, where I gave it the name of my cpp file.</p>\n<p>For example, in my XmlUtil.cpp file, I define a namespace XmlUtil_I { ... } for all of my module variables and functions. That way I can apply the XmlUtil_I:: qualification  in the debugger to access the variables. In this case, the '_I' distinguishes it from a public namespace such as XmlUtil that I may want to use elsewhere.</p>\n<p>I suppose a potential disadvantage of this approach compared to a truly anonymous one is that someone could violate the desired static scope by using the namespace qualifier in other modules. I don't know if that is a major concern though.</p>\n", "Id": "155734", "PostTypeId": "2", "OwnerDisplayName": "William Knight", "Score": "10", "CreationDate": "2008-10-01T00:39:12.090", "LastActivityDate": "2008-10-01T00:39:12.090"}, "154488": {"ParentId": "154469", "CommentCount": "3", "Body": "<p>Having learned of this feature only just now while reading your question, I can only speculate. This seems to provide several advantages over a file-level static variable:</p>\n<ul>\n<li>Anonymous namespaces can be nested within one another, providing multiple levels of protection from which symbols can not escape.</li>\n<li>Several anonymous namespaces could be placed in the same source file, creating in effect different static-level scopes within the same file.</li>\n</ul>\n<p>I'd be interested in learning if anyone has used anonymous namespaces in real code.</p>\n", "OwnerUserId": "4659", "Id": "154488", "PostTypeId": "2", "OwnerDisplayName": "Commodore Jaeger", "Score": "2", "CreationDate": "2008-09-30T19:09:26.597", "LastActivityDate": "2008-09-30T19:09:26.597"}, "154469": {"CommentCount": "1", "CreationDate": "2008-09-30T19:02:00.437", "PostTypeId": "1", "AcceptedAnswerId": "154482", "LastEditorUserId": "12193", "LastActivityDate": "2017-04-18T06:16:55.587", "AnswerCount": "9", "LastEditDate": "2010-10-21T15:15:19.957", "ViewCount": "142646", "FavoriteCount": "122", "Title": "Unnamed/anonymous namespaces vs. static functions", "Id": "154469", "Score": "382", "Body": "<p>A little-used feature of C++ is the ability to create unnamed (anonymous) namespaces, like so:</p>\n<pre><code>namespace {\n    int cannotAccessOutsideThisFile() { ... }\n} // namespace\n</code></pre>\n<p>You would think that such a feature would be useless -- since you can't specify the name of the namespace, it's impossible to access anything within it from outside. But these unnamed namespaces <em>are</em> accessible within the file they're created in, as if you had an implicit using-clause to them.</p>\n<p>My question is, why or when would this be preferable to using static functions? Or are they essentially two ways of doing the exact same thing?</p>\n", "Tags": "<c++><namespaces>", "OwnerUserId": "12193", "OwnerDisplayName": "Head Geek"}, "238584": {"ParentId": "154469", "CommentCount": "0", "Body": "<p>From experience I'll just note that while it is the C++ way to put formerly-static functions into the anonymous namespace, older compilers can sometimes have problems with this. I currently work with a few compilers for our target platforms, and the more modern Linux compiler is fine with placing functions into the anonymous namespace.</p>\n<p>But an older compiler running on Solaris, which we are wed to until an unspecified future release, will sometimes accept it, and other times flag it as an error. The error is not what worries me, it's what it <em>might</em> be doing when it <em>accepts</em> it. So until we go modern across the board, we are still using static (usually class-scoped) functions where we'd prefer the anonymous namespace.</p>\n", "OwnerUserId": "3778", "Id": "238584", "PostTypeId": "2", "OwnerDisplayName": "Don Wakefield", "Score": "6", "CreationDate": "2008-10-26T20:43:26.557", "LastActivityDate": "2008-10-26T20:43:26.557"}, "154508": {"ParentId": "154469", "CommentCount": "3", "Body": "<p>Use of static keyword for that purpose is deprecated by the C++98 standard. The problem with static is that it doesn't apply to type definition. It's also an overloaded keyword used in different ways in different contexts, so unnamed namespaces simplify things a bit.</p>\n", "OwnerUserId": "23153", "Id": "154508", "PostTypeId": "2", "OwnerDisplayName": "Firas Assad", "Score": "7", "CreationDate": "2008-09-30T19:13:35.273", "LastActivityDate": "2008-09-30T19:13:35.273"}, "154482": {"CommentCount": "8", "CreationDate": "2008-09-30T19:06:19.613", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-26T12:39:16.007", "ParentId": "154469", "PostTypeId": "2", "LastEditorDisplayName": "Roger Pate", "LastEditDate": "2017-05-23T12:17:55.067", "Id": "154482", "Score": "264", "Body": "<p><s>The C++ Standard reads in section 7.3.1.1 Unnamed namespaces, paragraph 2:</s>\n<s></s></p>\n<blockquote>\n<p id=\"so_154469_154482_0\">The use of the static keyword is\n  deprecated when declaring objects in a\n  namespace scope, the unnamed-namespace\n  provides a superior alternative.\n  </p></blockquote>\n<p>Static only applies to names of objects, functions, and anonymous unions, not to type declarations.</p>\n<p><strong>Edit:</strong></p>\n<p>The decision to deprecate this use of the static keyword (affect visibility of a variable declaration in a translation unit) has been reversed (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1012\" rel=\"noreferrer\">ref</a>).  In this case using a static or an unnamed namespace are back to being essentially two ways of doing the exact same thing.  For more discussion please see <a href=\"https://stackoverflow.com/questions/4726570/deprecation-of-the-static-keyword-no-more\">this</a> SO question.</p>\n<p>Unnamed namespaces still have the advantage of allowing you to define translation-unit-local types.  Please see <a href=\"https://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static\">this</a> SO question for more details.</p>\n<p>Credit goes to <a href=\"https://stackoverflow.com/users/1220179/mike-percy\">Mike Percy</a> for bringing this to my attention.</p>\n", "OwnerUserId": "16434", "OwnerDisplayName": "luke"}, "8436207": {"ParentId": "154469", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In addition if one uses static keyword on a variable like this example:</p>\n<pre><code>namespace {\n   static int flag;\n}\n</code></pre>\n<p>It would not be seen in the mapping file</p>\n", "OwnerUserId": "1009377", "LastEditorUserId": "1009377", "LastEditDate": "2011-12-10T20:27:10.700", "Id": "8436207", "Score": "2", "CreationDate": "2011-12-08T19:02:23.557", "LastActivityDate": "2011-12-10T20:27:10.700"}, "155556": {"CommentCount": "4", "CreationDate": "2008-09-30T23:20:49.690", "LastEditorUserId": "5066", "LastActivityDate": "2008-09-30T23:56:57.403", "ParentId": "154469", "PostTypeId": "2", "LastEditorDisplayName": "hazzen", "LastEditDate": "2008-09-30T23:56:57.403", "Id": "155556", "Score": "50", "Body": "<p>Putting methods in an anonymous namespace prevents you from accidentally violating the <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"noreferrer\">One Definition Rule</a>, allowing you to never worry about naming your helper methods the same as some other method you may link in.</p>\n<p>And, as pointed out by luke, anonymous namespaces are preferred by the standard over static members.</p>\n", "OwnerUserId": "5066", "OwnerDisplayName": "hazzen"}, "156834": {"CommentCount": "6", "CreationDate": "2008-10-01T09:15:19.370", "LastEditorUserId": "11698", "LastActivityDate": "2015-07-24T12:34:34.520", "ParentId": "154469", "PostTypeId": "2", "LastEditorDisplayName": "Roger Pate", "LastEditDate": "2015-07-24T12:34:34.520", "Id": "156834", "Score": "30", "Body": "<p>There is one edge case where static has a surprising affect (at least it was to me).  The C++03 Standard states in 14.6.4.2/1:</p>\n<blockquote>\n<p id=\"so_154469_156834_0\">For a function call that depends on a template parameter, if the function name is an <em>unqualified-id</em> but not a <em>template-id</em>, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1), only function declarations with external linkage from the template definition context are found.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations with external linkage found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_154469_156834_1\">...</p>\n</blockquote>\n<p>The below code will call <code>foo(void*)</code> and not <code>foo(S const &amp;)</code> as you might expect.</p>\n<pre><code>template &lt;typename T&gt;\nint b1 (T const &amp; t)\n{\n  foo(t);\n}\n\nnamespace NS\n{\n  namespace\n  {\n    struct S\n    {\n    public:\n      operator void * () const;\n    };\n\n    void foo (void*);\n    static void foo (S const &amp;);   // Not considered 14.6.4.2(b1)\n  }\n\n}\n\nvoid b2()\n{\n  NS::S s;\n  b1 (s);\n}\n</code></pre>\n<p>In itself this is probably not that big a deal, but it does highlight that for a fully compliant C++ compiler (ie. one with support for <code>export</code>) the <code>static</code> keyword will still have functionality that is not available in any other way.</p>\n<pre><code>// bar.h\nexport template &lt;typename T&gt;\nint b1 (T const &amp; t);\n\n// bar.cc\n#include \"bar.h\"\ntemplate &lt;typename T&gt;\nint b1 (T const &amp; t)\n{\n  foo(t);\n}\n\n// foo.cc\n#include \"bar.h\"\nnamespace NS\n{\n  namespace\n  {\n    struct S\n    {\n    };\n\n    void foo (S const &amp; s);  // Will be found by different TU 'bar.cc'\n  }\n}\n\nvoid b2()\n{\n  NS::S s;\n  b1 (s);\n}\n</code></pre>\n<p>The only way to ensure that the function in our unnamed namespace will not be found in templates using ADL is to make it <code>static</code>.</p>\n<p><strong>Update for Modern C++</strong></p>\n<p>As of C++ '11, members of an unnamed namespace have internal linkage implicitly (3.5/4):</p>\n<blockquote>\n<p id=\"so_154469_156834_2\">An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has internal linkage.</p>\n</blockquote>\n<p>But at the same time, 14.6.4.2/1 was updated to remove mention of linkage (this taken from C++ '14):</p>\n<blockquote>\n<p id=\"so_154469_156834_3\">For a function call where the postfix-expression is a dependent name, the candidate functions are found using\n  the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li><p id=\"so_154469_156834_4\">For the part of the lookup using unqualified name lookup (3.4.1), only function declarations from the template definition context are found.</p></li>\n<li><p id=\"so_154469_156834_5\">For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n</blockquote>\n<p>The result is that this particular difference between static and unnamed namespace members no longer exists.</p>\n", "OwnerUserId": "11698", "OwnerDisplayName": "Richard Corden"}, "43464911": {"ParentId": "154469", "CommentCount": "0", "Body": "<p>A compiler specific difference between anonymous namespaces and static functions can be seen compiling the following code.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace\n{\n    void unreferenced()\n    {\n        std::cout &lt;&lt; \"Unreferenced\";\n    }\n\n    void referenced()\n    {\n        std::cout &lt;&lt; \"Referenced\";\n    }\n}\n\nstatic void static_unreferenced()\n{\n    std::cout &lt;&lt; \"Unreferenced\";\n}\n\nstatic void static_referenced()\n{\n    std::cout &lt;&lt; \"Referenced\";\n}\n\nint main()\n{\n    referenced();\n    static_referenced();\n    return 0;\n}\n</code></pre>\n<p>Compiling this code with VS 2017 (specifying the level 4 warning flag /W4 to enable <a href=\"https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4505\" rel=\"nofollow noreferrer\">warning C4505: unreferenced local function has been removed</a>) and gcc 4.9 with the -Wunused-function or -Wall flag shows that VS 2017 will only produce a warning for the unused static function. gcc 4.9 and higher, as well as clang 3.3 and higher, will produce warnings for the unreferenced function in the namespace and also a warning for the unused static function.</p>\n<p><a href=\"https://godbolt.org/g/53ubwO\" rel=\"nofollow noreferrer\">Live demo of gcc 4.9 and MSVC 2017</a></p>\n", "OwnerUserId": "1181561", "PostTypeId": "2", "Id": "43464911", "Score": "1", "CreationDate": "2017-04-18T06:16:55.587", "LastActivityDate": "2017-04-18T06:16:55.587"}, "bq_ids": {"n4140": {"so_154469_156834_2": {"section_id": 7137, "quality": 1.0, "length": 11}, "so_154469_156834_3": {"section_id": 224, "quality": 0.8235294117647058, "length": 14}, "so_154469_156834_5": {"section_id": 224, "quality": 0.8888888888888888, "length": 16}, "so_154469_156834_4": {"section_id": 224, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_154469_156834_2": {"section_id": 6881, "quality": 1.0, "length": 11}, "so_154469_156834_0": {"section_id": 217, "quality": 0.6190476190476191, "length": 13}, "so_154469_156834_5": {"section_id": 217, "quality": 0.8888888888888888, "length": 16}, "so_154469_156834_4": {"section_id": 217, "quality": 0.8571428571428571, "length": 12}, "so_154469_156834_3": {"section_id": 217, "quality": 0.5882352941176471, "length": 10}}, "n4659": {"so_154469_156834_5": {"section_id": 232, "quality": 0.8888888888888888, "length": 16}, "so_154469_156834_4": {"section_id": 232, "quality": 0.8571428571428571, "length": 12}, "so_154469_156834_2": {"section_id": 8638, "quality": 1.0, "length": 11}, "so_154469_156834_3": {"section_id": 232, "quality": 0.8235294117647058, "length": 14}}}});