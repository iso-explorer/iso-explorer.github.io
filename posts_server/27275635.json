post_cb({"27275635": {"CommentCount": "1", "AcceptedAnswerId": "27275705", "CreationDate": "2014-12-03T15:36:02.417", "LastActivityDate": "2014-12-03T17:47:56.547", "PostTypeId": "1", "ViewCount": "2234", "FavoriteCount": "5", "Title": "Why is 'int x = + \"foo\";' a type error but not a syntax error?", "Id": "27275635", "Score": "21", "Body": "<p>All compilers I tried correctly reject the code</p>\n<pre><code>int main() {\n  int x = \"foo\";\n}\n</code></pre>\n<p>with a type error: <code>const char[4]</code> cannot be converted to <code>int</code>. Why is it that the same compilers (including <a href=\"http://ideone.com/Mh2Qe4\">Ideone.com</a>) give the <em>same</em> error for</p>\n<pre><code>int main() {\n  int x = + \"foo\";\n}\n</code></pre>\n<p>instead of (as I would have thought) a syntax error becaus of the <code>+</code> sign? My first idea was that <code>const char[4]</code> decays to a pointer, which in turn is treated as an integral value so the <code>+</code> denotes \"positive\". Seems a little far-fetched though, and I would have expected to see <code>const char*</code> appear in the error message.</p>\n", "Tags": "<c++>", "OwnerUserId": "91757", "AnswerCount": "4"}, "27275713": {"ParentId": "27275635", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Unary <code>+</code> applies to pointers and it just returns the value of the type and does not perform integral promotions on pointers so the result is a pointer not an integral type, from the draft C++ standard section <code>5.3.1</code> <em>Unary operators</em>:</p>\n<blockquote>\n<p id=\"so_27275635_27275713_0\">The operand of the unary + operator shall have arithmetic, unscoped\n  enumeration, or pointer type and the result is the value of the\n  argument. Integral promotion is performed on integral or enumeration\n  operands. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>a string literal is an array of const char, from <code>2.14.5</code> <em>String literals</em>:</p>\n<blockquote>\n<p id=\"so_27275635_27275713_1\">[...]A narrow string literal has type \u201carray of n const char\u201d,[...]</p>\n</blockquote>\n<p>which will decay to pointer in this context.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-12-03T15:57:10.063", "Id": "27275713", "Score": "9", "CreationDate": "2014-12-03T15:39:28.480", "LastActivityDate": "2014-12-03T15:57:10.063"}, "27275705": {"ParentId": "27275635", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Syntax doesn't involve types in the type system sense (ints and chars and pointers), only types in the syntactic sense of keywords, operators, expressions. In C++ syntax, <code>+</code> is a unary prefix operator that can precede an expression. <code>\"foo\"</code> is an expression. Therefore, <code>+\"foo\"</code> is a valid expression as far as the parser is concerned.</p>\n<p>Your idea that the string constant decays into a pointer and <code>+</code> is a no-op on pointers is correct, and the following program even compiles and runs:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    const char *message = +\"Hello!\\n\";\n    std::cout &lt;&lt; message;\n}\n</code></pre>\n<p>... but that's irrelevant. What you're seeing is a type error, not a syntax error.</p>\n<p><strong>EDIT</strong> Perhaps even more convincing is the fact that you can overload unary <code>+</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct SomeType {\n    const char *operator+() const\n    {\n        return \"Hello, world!\\n\";\n    }\n};\n\nint main()\n{\n    SomeType x;\n    std::cout &lt;&lt; +x;\n}\n</code></pre>\n", "OwnerUserId": "166749", "LastEditorUserId": "1048572", "LastEditDate": "2014-12-03T17:47:56.547", "Id": "27275705", "Score": "34", "CreationDate": "2014-12-03T15:38:55.140", "LastActivityDate": "2014-12-03T17:47:56.547"}, "27275862": {"ParentId": "27275635", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_27275635_27275862_0\">Why is 'int x = + \u201cfoo\u201d;' a type error but not a syntax error?</p>\n</blockquote>\n<p>Because there is no syntax error. There is a semantic error.</p>\n<p>After parsing the statement the compiler determines whether such initialization is posiible. In fact syntaxically  the statement looks like</p>\n<pre><code>int x = + ( expression );\n</code></pre>\n<p>Syntaxically this statement is correct. Moreover the unary plus may be applied to pointers. </p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-12-03T15:52:18.710", "Id": "27275862", "Score": "4", "CreationDate": "2014-12-03T15:46:11.967", "LastActivityDate": "2014-12-03T15:52:18.710"}, "27275780": {"ParentId": "27275635", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The unary <code>+</code> operator can be applied to pointer types:</p>\n<blockquote>\n<p id=\"so_27275635_27275780_0\">C++11 5.3.1 [expr.unary.op]/7: The operand of the unary + operator shall have arithmetic, unscoped enumeration, or <strong>pointer type</strong> and the result is the value of the argument.</p>\n</blockquote>\n<p>So the literal array is converted to <code>const char *</code>, and the operator applied to that pointer, before failing to assign the pointer to an <code>int</code> just as in the first example.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2014-12-03T15:52:08.973", "Id": "27275780", "Score": "7", "CreationDate": "2014-12-03T15:42:26.633", "LastActivityDate": "2014-12-03T15:52:08.973"}, "bq_ids": {"n4140": {"so_27275635_27275713_1": {"section_id": 5356, "quality": 1.0, "length": 7}, "so_27275635_27275713_0": {"section_id": 6070, "quality": 0.92, "length": 23}, "so_27275635_27275780_0": {"section_id": 6070, "quality": 0.75, "length": 12}}, "n3337": {"so_27275635_27275713_1": {"section_id": 5153, "quality": 1.0, "length": 7}, "so_27275635_27275713_0": {"section_id": 5838, "quality": 0.92, "length": 23}, "so_27275635_27275780_0": {"section_id": 5838, "quality": 0.75, "length": 12}}, "n4659": {"so_27275635_27275713_1": {"section_id": 6781, "quality": 1.0, "length": 7}, "so_27275635_27275713_0": {"section_id": 7566, "quality": 0.92, "length": 23}, "so_27275635_27275780_0": {"section_id": 7566, "quality": 0.75, "length": 12}}}});