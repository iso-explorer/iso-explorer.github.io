post_cb({"37206941": {"ParentId": "37206557", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since the name X is ambiguous due to being defined in two base classes, this causes template deduction to fail for <code>B_</code> in <code>has_typedef</code>.</p>\n<p>Your belief that typedefs are not inherited might have come from some C++ specialties during unqualified name lookup, where base classes are not considered.\nSee <a href=\"https://stackoverflow.com/questions/1643035/propagating-typedef-from-based-to-derived-class-for-template\">Propagating 'typedef' from based to derived class for 'template'</a></p>\n", "OwnerUserId": "4050460", "LastEditorUserId": "4050460", "LastEditDate": "2016-05-13T10:10:39.753", "Id": "37206941", "Score": "2", "CreationDate": "2016-05-13T09:57:18.223", "LastActivityDate": "2016-05-13T10:10:39.753"}, "37206557": {"CommentCount": "3", "ViewCount": "1835", "PostTypeId": "1", "LastEditorUserId": "1475287", "CreationDate": "2016-05-13T09:41:10.000", "LastActivityDate": "2016-05-13T10:30:29.607", "Title": "Is 'typedef' automatically inherited in C++ class?", "AcceptedAnswerId": "37207250", "LastEditDate": "2016-05-13T09:48:32.367", "Id": "37206557", "Score": "14", "Body": "<p>I used to believe that 'typedef' is not automatically inherited. But the code snap below suggests something different.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct A\n{\n    typedef int X;\n};\n\nstruct A_ \n{\n    typedef char X;\n};\n\nstruct B : A {};\nstruct B_ : A, A_ {};\n\ntemplate&lt; typename ... Ts &gt;\nusing void_t = void;\n\ntemplate&lt; typename T, typename = void &gt;\nstruct has_typedef_X : std::false_type {};\n\ntemplate&lt; typename T &gt;\nstruct has_typedef_X&lt; T, void_t&lt;typename T::X&gt; &gt; : std::true_type {};\n\nint main()\n{\n    std::cout &lt;&lt; std::boolalpha;\n    std::cout &lt;&lt; has_typedef_X&lt;A&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_typedef_X&lt;A_&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_typedef_X&lt;B&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; has_typedef_X&lt;B_&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>The output is 'true true true false'. \nBut in my point of view,  '<code>has_typedef_X&lt;B&gt;::value</code>' giving 'true' implies that in struct B, X is 'typedef'ed.</p>\n<p>So if anyone can please explain this problem or correct me?</p>\n<p>A online version is available at <a href=\"http://melpon.org/wandbox/permlink/iwZ6eZ3PoBPgyFBj\" rel=\"noreferrer\">http://melpon.org/wandbox/permlink/iwZ6eZ3PoBPgyFBj</a> [URL corrected]</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1475287", "AnswerCount": "3"}, "37206737": {"ParentId": "37206557", "CommentCount": "2", "Body": "<p><code>X</code> is in scope for both <code>B</code> and <code>B_</code>, the issue with <code>B_</code> is that <code>B_::X</code> is ambiguous, so template deduction fails for the truthy <code>has_typedef</code> leaving the false one as the only match.</p>\n", "OwnerUserId": "657267", "PostTypeId": "2", "Id": "37206737", "Score": "2", "CreationDate": "2016-05-13T09:49:11.330", "LastActivityDate": "2016-05-13T09:49:11.330"}, "bq_ids": {"n4140": {"so_37206557_37207250_1": {"section_id": 6997, "quality": 0.9523809523809523, "length": 20}, "so_37206557_37207250_0": {"section_id": 5933, "quality": 1.0, "length": 9}}, "n3337": {"so_37206557_37207250_1": {"section_id": 6743, "quality": 0.9523809523809523, "length": 20}, "so_37206557_37207250_0": {"section_id": 5705, "quality": 1.0, "length": 9}}, "n4659": {"so_37206557_37207250_1": {"section_id": 8495, "quality": 0.9523809523809523, "length": 20}, "so_37206557_37207250_0": {"section_id": 7403, "quality": 1.0, "length": 9}}}, "37207250": {"ParentId": "37206557", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Nested type names (i.e. member types) of parents are visible in the scope of a derived class  and accessible as long as the access specifier of is not private. If there are multiple types with the same name from <em>different</em> base classes, then the unqualified name is ambiguous.</p>\n<p>The most relevant standard quotes that I found regarding this are:</p>\n<p><a href=\"http://eel.is/c++draft/class.nested.type#1\" rel=\"noreferrer\">[class.nested.type] \u00a71</a></p>\n<blockquote>\n<p id=\"so_37206557_37207250_0\">Type names obey exactly the same scope rules as other names. [...]</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/class.member.lookup#9\" rel=\"noreferrer\">[class.member.lookup] \u00a79</a></p>\n<blockquote>\n<p id=\"so_37206557_37207250_1\">[ Note: A static member, <strong>a nested type</strong> or an enumerator <strong>defined in a base class T can unambiguously be found</strong> even if an object has more than one base class subobject of type T. [...]</p>\n</blockquote>\n<p>In fact, an example of using this is the standard which specifies that the iterators of standard containers inherit <code>std::iterator</code> template, which contains nothing but nested type names. The whole point of the inheritance is to get these nested type names to the iterator. (This example will become outdated in the next standard version (c++17), where <code>std::iterator</code> is proposed not to be used anymore.)</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-05-13T10:30:29.607", "Id": "37207250", "Score": "8", "CreationDate": "2016-05-13T10:10:37.190", "LastActivityDate": "2016-05-13T10:30:29.607"}});