post_cb({"645994": {"ViewCount": "21789", "Body": "<p>I was reading the answers to this question <a href=\"https://stackoverflow.com/questions/385297/whats-wrong-with-c-compared-to-other-languages\">C++ pros and cons</a> and got this doubt while reading the comments. </p>\n<blockquote>\n<p id=\"so_645994_645994_0\">programmers frequently find it confusing that \"this\" is a pointer but not a reference. another confusion is why \"hello\" is not of type std::string but evaluates to a char const* (pointer) (after array to pointer conversion) \u2013 Johannes Schaub - litb Dec 22 '08 at 1:56</p>\n<p id=\"so_645994_645994_1\">That only shows that it doesn't use the same conventions as other (later) languages. \u2013 le dorfier Dec 22 '08 at 3:35</p>\n<p id=\"so_645994_645994_2\">I'd call the \"this\" thing a pretty trivial issue though. And oops, thanks for catching a few errors in my examples of undefined behavior. :) Although I don't understand what info about size has to do with anything in the first one. A pointer is simply not allowed to point outside allocated memory \u2013 jalf Dec 22 '08 at 4:18</p>\n<p id=\"so_645994_645994_3\">Is this a constant poiner? \u2013 yesraaj Dec 22 '08 at 6:35</p>\n<p id=\"so_645994_645994_4\">this can be constant if the method is const int getFoo() const; &lt;- in the scope of getFoo, \"this\" is constant, and is therefore readonly. This prevents bugs and provides some level of guarantee to the caller that the object won't change. \u2013 Doug T. Dec 22 '08 at 16:42</p>\n<p id=\"so_645994_645994_5\">you can't reassign \"this\". i.e you cannot do \"this = &amp;other;\", because this is an rvalue. but this is of type T*, not of type T const . i.e it's a non-constant pointer. if you are in a const method, then it's a pointer to const. T const . but the pointer itself is nonconst \u2013 Johannes Schaub - litb Dec 22 '08 at 17:53</p>\n<p id=\"so_645994_645994_6\">think of \"this\" like this: #define this (this_ + 0) where the compiler creates \"this_\" as a pointer to the object and makes \"this\" a keyword. you can't assign \"this\" because (this_ + 0) is an rvalue. of course that's not how it is (there is no such macro), but it can help understand it \u2013 Johannes Schaub - litb Dec 22 '08 at 17:55</p>\n</blockquote>\n<p>My question is, why <code>this</code> is a pointer a not a reference? Any particular reason for making it a pointer?</p>\n<hr>\n<p>Some further arguments why <code>this</code> being a reference would make sense:</p>\n<ul>\n<li>Consider <code>Item 1</code> from <code>More Effective C++</code>: use references when it is guaranteed that we have a valid object i.e. not a NULL (my interpretation). </li>\n<li>Furthermore, references are considered safer than pointers (because we can't screw the memory up with a stray pointer). </li>\n<li>Thirdly, the syntax for accessing references (<code>.</code>) is a little bit nicer and shorter than accessing pointers (<code>-&gt;</code> or <code>(*)</code>).</li>\n</ul>\n</hr>", "AcceptedAnswerId": "646001", "Title": "Why 'this' is a pointer and not a reference?", "CreationDate": "2009-03-14T14:37:04.163", "LastActivityDate": "2016-03-20T19:54:43.400", "CommentCount": "9", "FavoriteCount": "29", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:26:35.987", "OwnerDisplayName": "Naveen", "LastEditorUserId": "-1", "Id": "645994", "Score": "140", "OwnerUserId": "39742", "Tags": "<c++><pointers><reference><this><c++-faq>", "AnswerCount": "4"}, "3899282": {"Id": "3899282", "PostTypeId": "2", "Body": "<p>The C++ standard states that </p>\n<blockquote>\n<p id=\"so_645994_3899282_0\">9.3.2/1</p>\n<p id=\"so_645994_3899282_1\">In the body of a nonstatic (9.3)\n  member function, the keyword this is a\n  non-lvalue expression whose value is\n  the address of the object for which\n  the function is called. The type of\n  this in a member function of a class X\n  is X*. If the member function is\n  declared const, the type of this is\n  const X*, if the member function is\n  declared volatile, the type of this is\n  volatile X*, and if the member\n  function is declared const volatile,\n  the type of this is const volatile X*.</p>\n</blockquote>\n<p>But in other references , it was found something else.. so someone took initiative and shot a mail to <a href=\"http://www2.research.att.com/~bs/homepage.html\" rel=\"nofollow\">Mr. Stroustrup</a>. The conversation that followed can be found <strong><a href=\"http://zamanbakshifirst.blogspot.com/search/label/this%20pointer\" rel=\"nofollow\">here</a></strong>. </p>\n", "LastEditorUserId": "1288", "LastActivityDate": "2012-12-01T14:17:03.063", "Score": "-3", "CreationDate": "2010-10-10T06:27:04.267", "ParentId": "645994", "CommentCount": "1", "OwnerUserId": "398802", "LastEditDate": "2012-12-01T14:17:03.063"}, "bq_ids": {"n4140": {"so_645994_3899282_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 5895}}, "n3337": {"so_645994_3899282_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 5666}}, "n4659": {"so_645994_3899282_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 7378}}}, "648422": {"Body": "<p>A little late to the party...  Straight from the horse's mouth, <a href=\"http://www.stroustrup.com/bs_faq2.html#this\" rel=\"noreferrer\">here's what Stroupstrup has to say</a> (which is essentially repeated in or taken from the \"Design and Evolution of C++\" book):</p>\n<blockquote>\n<p id=\"so_645994_648422_0\">Why is \"this\" not a reference?</p>\n<p id=\"so_645994_648422_1\">Because \"this\" was introduced into C++ (really into C with Classes) before references were added. Also, I chose \"this\" to follow Simula usage, rather than the (later) Smalltalk use of \"self\". </p>\n</blockquote>\n", "CreationDate": "2009-03-15T19:52:22.367", "ParentId": "645994", "CommentCount": "1", "LastEditDate": "2016-03-20T19:54:43.400", "PostTypeId": "2", "OwnerDisplayName": "Michael Burr", "LastEditorUserId": "2630827", "LastActivityDate": "2016-03-20T19:54:43.400", "Id": "648422", "Score": "86", "OwnerUserId": "12711"}, "650088": {"Id": "650088", "PostTypeId": "2", "Body": "<p>Irrespective of how we got here, I think it's lucky that <em>this</em> is a pointer and not a reference as this helps it \"make sense\" that you can <em>delete</em> it:</p>\n<pre><code>void A::f () {\n  delete &amp;this;\n}\n</code></pre>\n<p>I think this is a case where without necessarily being by design, C++ is better as it is.</p>\n", "OwnerDisplayName": "Richard Corden", "LastActivityDate": "2009-03-16T11:52:54.507", "Score": "-4", "CreationDate": "2009-03-16T11:52:54.507", "ParentId": "645994", "CommentCount": "8", "OwnerUserId": "11698"}, "646001": {"Body": "<p>When the language was first evolving, in early releases with real users, there were no references, only pointers. References were added when operator overloading was added, as it requires references to work consistently.</p>\n<p>One of the uses of <code>this</code> is for an object to get a pointer to itself. If it was a reference, we'd have to write <code>&amp;this</code>. On the other hand, when we write an assignment operator we have to <code>return *this</code>, which would look simpler as <code>return this</code>. So if you had a blank slate, you could argue it either way. But C++ evolved gradually in response to feedback from a community of users (like most successful things). The value of backward compatibility totally overwhelms the minor advantages/disadvantages stemming from <code>this</code> being a reference or a pointer.</p>\n", "CreationDate": "2009-03-14T14:41:27.303", "ParentId": "645994", "CommentCount": "13", "LastEditDate": "2009-03-14T16:36:33.487", "PostTypeId": "2", "LastEditorDisplayName": "Earwicker", "LastActivityDate": "2009-03-14T16:36:33.487", "LastEditorUserId": "27423", "Id": "646001", "OwnerDisplayName": "Earwicker", "Score": "139", "OwnerUserId": "27423"}});