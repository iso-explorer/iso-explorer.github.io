post_cb({"bq_ids": {"n4140": {"so_47915034_47915255_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 2665}}, "n3337": {"so_47915034_47915255_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 2629}}, "n4659": {"so_47915034_47915255_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 3405}}}, "47915034": {"ViewCount": "154", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;chrono&gt;\n#include &lt;thread&gt;\n\nint main() {\n    std::this_thread::sleep_until(std::chrono::steady_clock::now() - std::chrono::seconds(10));\n\n    return 0;\n}\n</code></pre>\n<p>When compiled with GCC 4.8.5, it will hang. When compiled with GCC 4.9 and above or clang3.4 and above, it returns immediately, </p>\n<p>Why would it hang? As I understand, GCC 4.8.5 fully supports C++11 standard.</p>\n", "AcceptedAnswerId": "47915242", "Title": "C++11 std::this_thread::sleep_until() hangs when compiled with GCC 4.8.5", "CreationDate": "2017-12-20T22:06:27.243", "LastActivityDate": "2017-12-21T05:52:34.153", "CommentCount": "3", "LastEditDate": "2017-12-21T05:52:34.153", "PostTypeId": "1", "LastEditorUserId": "9124671", "Id": "47915034", "Score": "4", "OwnerUserId": "9124671", "Tags": "<c++><c++11><gcc4.8>", "AnswerCount": "2"}, "47915242": {"Id": "47915242", "PostTypeId": "2", "Body": "<p>This is a confirmed bug that was fixed in gcc 4.9.</p>\n<p><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58038\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58038</a></p>\n<blockquote>\n<p id=\"so_47915034_47915242_0\">When using sleep_until() I get an bug with unsigned long scalar representations of a duration. If this duratoiin is in past, then you get an overflow in the length of the argument for sleep_for(). This causes an almost infinte sleep, instead of a fast return.</p>\n</blockquote>\n", "LastActivityDate": "2017-12-20T22:26:21.857", "Score": "4", "CreationDate": "2017-12-20T22:26:21.857", "ParentId": "47915034", "CommentCount": "0", "OwnerUserId": "16287"}, "47915255": {"Id": "47915255", "PostTypeId": "2", "Body": "<p>This case is considered by the Standard and according to it <code>sleep_until</code> should move on. Seems its a bug in GCC 4.8.5</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/thread.req.timing\" rel=\"nofollow noreferrer\">[33.2.4  Timing specifications]</a></p>\n<blockquote>\n<p id=\"so_47915034_47915255_0\">The member functions whose names end in _until take an argument that specifies a time point. \n  These functions produce absolute timeouts. Implementations should use the clock specified in \n  the time point to measure time for these functions. Given a clock time point argument Ct, the \n  clock time point of the return from timeout should be <code>Ct + Di + Dm</code> when the clock is not \n  adjusted during the timeout. If the clock is adjusted to the time Ca during the timeout, the \n  behavior should be as follows: </p>\n<ul>\n<li>if Ca &gt; Ct, <strong>the waiting function should wake as soon as possible</strong>, (...), since the timeout\n  is already satisfied. [ Note: This specification may result in the total duration of the wait decreasing when measured against a steady clock. \u2014 end note ]\n  \u2014 if <code>Ca &lt; Ct</code>, ...</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2017-12-20T22:26:57.073", "Score": "2", "CreationDate": "2017-12-20T22:26:57.073", "ParentId": "47915034", "CommentCount": "0", "OwnerUserId": "5945883"}});