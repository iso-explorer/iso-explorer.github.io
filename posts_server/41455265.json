post_cb({"bq_ids": {"n4140": {"so_41455265_41455322_0": {"length": 15, "quality": 1.0, "section_id": 7211}, "so_41455265_41455322_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 500}}, "n3337": {"so_41455265_41455322_0": {"length": 15, "quality": 1.0, "section_id": 6955}, "so_41455265_41455322_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 491}}, "n4659": {"so_41455265_41455322_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8720}, "so_41455265_41455322_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 521}}}, "41455322": {"Id": "41455322", "PostTypeId": "2", "Body": "<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4618.pdf\" rel=\"nofollow noreferrer\">3.9.1</a></p>\n<blockquote>\n<p id=\"so_41455265_41455322_0\">There are five standard signed integer types : \u201csigned char\u201d, \u201cshort\n  int\u201d, \u201cint\u201d, \u201clong int\u201d, and \u201clong long int\"</p>\n</blockquote>\n<p>[18.4.1] of the same says that </p>\n<blockquote>\n<p id=\"so_41455265_41455322_1\">using int64_t = signed integer type ; // optional</p>\n</blockquote>\n<p>So you are looking at two distinct basic types and comparing them to the type alias. \nIn your case its <code>int64_t</code> is aliased with <code>long</code> however there could be an implementation when its aliased with <code>long long int</code></p>\n<hr>\n<p>As for you extra question, it depends what do you mean by interchangeability,  <code>long long</code> is at least as long as a <code>long</code> but in theory or in future could be 'longer', using these types interchangeably would still required type casting</p>\n</hr>", "LastEditorUserId": "6592023", "LastActivityDate": "2017-01-04T02:44:28.797", "Score": "0", "CreationDate": "2017-01-04T02:31:45.807", "ParentId": "41455265", "CommentCount": "1", "OwnerUserId": "6592023", "LastEditDate": "2017-01-04T02:44:28.797"}, "41455320": {"Id": "41455320", "PostTypeId": "2", "Body": "<p><code>long</code> and <code>long long</code> are built-in types defined by the core language.</p>\n<p><code>int64_t</code> is defined by the <code>&lt;cstdint&gt;</code> header (in practice include <code>&lt;stdint.h&gt;</code>). It's defined as an alias for some built-in type. In your case it's defined as an alias for <code>long</code>.</p>\n<hr>\n<p>Built in types that <em>can</em> be the same size on some platform still need to be regarded as distinct types in order to not create ambiguous calls of overloaded functions.</p>\n<p>There are even built in numerical types that guaranteed have the same size and signedness, but still are distinct. Namely, all three of <code>unsigned char</code>, <code>char</code> and <code>signed char</code> are distinct and of size 1, but <code>char</code> must be the same signedness as one of the others. Although I don't recommend doing it, technically you can freely overload functions based on just this difference.</p>\n<hr>\n<p>Re</p>\n<blockquote>\n<p id=\"so_41455265_41455320_0\"><strong>\u201d</strong> Can I use <code>long long</code> and <code>int64_t</code> interchangeably on my machine, given that they are both integer types and have same size?</p>\n</blockquote>\n<p>That depends on what you mean by \u201cinterchangeably\u201d.</p>\n<p>Since <code>int64_t</code> with your compiler is an alias for <code>long</code>, you can't call a function expecting an <code>int64_t*</code>, with a <code>long long*</code> pointer.</p>\n<p>But <code>long long</code> is guaranteed to be at least 64 bits, and in this sense it's only with respect to readability that it matters which of <code>long long</code> and <code>int64_t</code> you choose.</p>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2017-01-04T02:42:37.347", "Score": "6", "CreationDate": "2017-01-04T02:31:39.543", "ParentId": "41455265", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2017-01-04T02:42:37.347"}, "41455265": {"ViewCount": "240", "Body": "<p>I tried this on my computer </p>\n<pre><code>std::cout &lt;&lt; std::is_same&lt;int64_t, long long&gt;::value;\nstd::cout &lt;&lt; std::is_same&lt;int64_t,  long&gt;::value;\nstd::cout &lt;&lt; sizeof(long);\nstd::cout &lt;&lt; sizeof(long long);\nstd::cout &lt;&lt; sizeof(int64_t);\n</code></pre>\n<p>and the result is <code>false, true, 8, 8, 8</code></p>\n<p>I know <code>int64_t</code> is exactly 64 bit, and it shows <code>long</code> is same as <code>int64_t</code>, but <code>long long</code> is different from <code>int64_t</code> and it is also 64bit. Why could this happen?</p>\n<p><strong>EDIT</strong></p>\n<p>Can I use <code>long long</code> and <code>int64_t</code> interchangeably on my machine, given that they are both integer types and have same size?</p>\n", "AcceptedAnswerId": "41455320", "Title": "why long long is not int64_t but they have same size?", "CreationDate": "2017-01-04T02:23:48.403", "LastActivityDate": "2017-01-04T02:44:28.797", "CommentCount": "4", "LastEditDate": "2017-01-04T02:36:17.657", "PostTypeId": "1", "Tags": "<c++><typetraits>", "Id": "41455265", "AnswerCount": "2", "Score": "1", "OwnerUserId": "6243820", "ClosedDate": "2017-01-04T11:49:27.827", "LastEditorUserId": "6243820"}});