post_cb({"23428685": {"ParentId": "23428684", "LastEditDate": "2014-05-02T13:19:12.250", "CommentCount": "12", "CreationDate": "2014-05-02T12:53:36.850", "OwnerUserId": "560648", "LastEditorUserId": "560648", "PostTypeId": "2", "Id": "23428685", "Score": "0", "Body": "<p><strong>No, it is not <em>odr-used</em>.</strong></p>\n<p>First, both your array and its elements are of <em>literal</em> type:</p>\n<blockquote>\n<p id=\"so_23428684_23428685_0\"><code>[C++11: 3.9/10]:</code> A type is a literal type if it is:</p>\n<ul>\n<li><strong>a scalar type; or</strong></li>\n<li>a class type (Clause 9) with</li>\n<li>a trivial copy constructor,</li>\n<li>no non-trivial move constructor,</li>\n<li>a trivial destructor,</li>\n<li>a trivial default constructor or at least one constexpr constructor other than the copy or move constructor, and</li>\n<li>all non-static data members and base classes of literal types; or</li>\n<li><strong>an array of literal type</strong>.</li>\n</ul>\n</blockquote>\n<p>Now we look up the <em>odr-used</em> rules:</p>\n<blockquote>\n<p id=\"so_23428684_23428685_1\"><code>[C++11: 3.2/2]:</code> <em>[..]</em> A variable or non-overloaded function whose name appears as a potentially-evaluated expression is <em>odr-used</em> unless it is an object that satis\ufb01es the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is immediately applied. <em>[..]</em></p>\n</blockquote>\n<p>And here we've been referred to the rules on constant expressions, which contain nothing prohibiting your initialiser from being a constant expression; the pertinent passages are:</p>\n<blockquote>\n<p id=\"so_23428684_23428685_2\"><code>[C++11: 5.19/2]:</code> <strong>A <em>conditional-expression</em> is a constant expression unless it involves one of the following as a potentially evaluated subexpression <em>[..]</em>:</strong></p>\n<ul>\n<li><em>[..]</em></li>\n<li><strong>an lvalue-to-rvalue conversion (4.1) unless it is applied to</strong>\n<ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression, or</li>\n<li><strong>a glvalue of literal type that refers to a non-volatile object de\ufb01ned with <code>constexpr</code>, or that refers to a sub-object of such an object</strong>, or</li>\n<li>a glvalue of literal type that refers to a non-volatile temporary object initialized with a constant expression;</li>\n</ul></li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p><sup>(Don't be put off by the name of the production, \"<em>conditional-expression</em>\": it is the only production of <em>constant-expression</em> and is thus the one we're looking for.)</sup></p>\n<p>Then, thinking about the equivalence of <code>A::a[0]</code> to <code>*(A::a + 0)</code>, after the array-to-pointer conversion you have an <em>rvalue</em>:</p>\n<blockquote>\n<p id=\"so_23428684_23428685_3\"><code>[C++11: 4.2/1]:</code> An lvalue or rvalue of type \"array of <code>N</code> <code>T</code>\" or \"array of unknown bound of <code>T</code>\" can be converted to a prvalue of type \"pointer to <code>T</code>\". The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>Your pointer arithmetic is then performed on this rvalue and the result is also an <em>rvalue</em>, used to initialise <code>a</code>. No lvalue-to-rvalue conversion here whatsoever, so still nothing violating \"the requirements for appearing in a constant expression\".</p>\n", "LastActivityDate": "2014-05-02T13:19:12.250"}, "23428684": {"CommentCount": "0", "ViewCount": "1025", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-26T00:46:19.987", "Body": "<p>Given the following code:</p>\n<pre><code>struct A { static constexpr int a[3] = {1,2,3}; };\n\nint main () {\n  int a = A::a[0];\n  int b  [A::a[1]];\n}\n</code></pre>\n<p>is <code>A::a</code> necessarily <a href=\"https://stackoverflow.com/questions/19630570/what-does-it-mean-to-odr-use-something\"><em>odr-used</em></a> in <code>int a = A::a[0]</code>?</p>\n<hr>\n<p><sup><strong><em>Note:</em></strong> This question represents a less flamey/illogical/endless version of <a href=\"http://chat.stackoverflow.com/transcript/message/16217165#16217165\">a debate in the Lounge</a>.</sup></p></hr>\n", "Title": "Is a constexpr array necessarily odr-used when subscripted?", "FavoriteCount": "8", "LastEditDate": "2017-05-23T11:53:57.677", "Id": "23428684", "Score": "15", "CreationDate": "2014-05-02T12:53:36.850", "Tags": "<c++><c++11><language-lawyer><constexpr>", "OwnerUserId": "560648", "AnswerCount": "3"}, "23436665": {"ParentId": "23428684", "LastEditDate": "2014-05-02T21:19:52.220", "CommentCount": "11", "CreationDate": "2014-05-02T20:45:37.257", "OwnerUserId": "1041090", "LastEditorUserId": "1041090", "PostTypeId": "2", "Id": "23436665", "Score": "19", "Body": "<h2>First use of <code>A::a</code>:</h2>\n<pre><code>int a = A::a[0];\n</code></pre>\n<p>The initializer is a constant expression, but that doesn't stop <code>A::a</code> from being <em>odr-used</em> here. And, indeed, <code>A::a</code> is <em>odr-used</em> by this expression.</p>\n<p>Starting from the expression <code>A::a[0]</code>, let's walk through <strong>[basic.def.odr](3.2)/3</strong> (for future readers, I'm using the wording from N3936):</p>\n<blockquote>\n<p id=\"so_23428684_23436665_0\">A variable <code>x</code> [in our case, <code>A::a</code>] whose name appears as a potentially-evaluated expression ex [in our case, the <em>id-expression</em> <code>A::a</code>] is <em>odr-used</em> unless</p>\n<ul>\n<li><p id=\"so_23428684_23436665_1\">applying the lvalue-to-rvalue conversion to <code>x</code> yields a constant expression [it does]\n  that does not invoke any non-trivial functions [it does not] and,</p></li>\n<li><p id=\"so_23428684_23436665_2\">if <code>x</code> is an object [it is],</p>\n<ul>\n<li><code>ex</code> is an element of the set of <em>potential results</em> of an expression <code>e</code>, where either the lvalue-to-rvalue conversion is applied to <code>e</code>, or <code>e</code> is a discarded-value expression.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So: what possible values of <code>e</code> are there? The set of <em>potential results</em> of an expression is a set of subexpressions of the expression (you can check this by reading through <strong>[basic.def.odr](3.2)/2</strong>), so we only need to consider expressions of which <code>ex</code> is a subexpression. Those are:</p>\n<pre><code>A::a\nA::a[0]\n</code></pre>\n<p>Of these, the lvalue-to-rvalue conversion is <strong>not</strong> applied immediately to <code>A::a</code>, so we only consider <code>A::a[0]</code>. Per <strong>[basic.def.odr](3.2)/2</strong>, the set of potential results of <code>A::a[0]</code> is empty, so <code>A::a</code> is <em>odr-used</em> by this expression.</p>\n<p>Now, you could argue that we first rewrite <code>A::a[0]</code> to <code>*(A::a + 0)</code>. But that changes nothing: the possible values of <code>e</code> are then</p>\n<pre><code>A::a\nA::a + 0\n(A::a + 0)\n*(A::a + 0)\n</code></pre>\n<p>Of these, only the fourth has an lvalue-to-rvalue conversion applied to it, and again, <strong>[basic.def.odr](3.2)/2</strong> says that the set of potential results of <code>*(A::a + 0)</code> is empty. In particular, note that array-to-pointer decay is <strong>not</strong> an lvalue-to-rvalue conversion (<strong>[conv.lval](4.1)</strong>), even though it converts an array lvalue to a pointer rvalue -- it's an array-to-pointer conversion (<strong>[conv.array](4.2)</strong>).</p>\n<h2>Second use of <code>A::a</code>:</h2>\n<pre><code>int b  [A::a[1]];\n</code></pre>\n<p>This is no different from the first case, according to the standard. Again, <code>A::a[1]</code> is a constant expression, thus this is a valid array bound, but a compiler is still permitted to emit code at runtime to compute this value, and the array bound still <em>odr-uses</em> <code>A::a</code>.</p>\n<p>Note in particular that constant expressions are (by default) potentially-evaluated expressions. Per <strong>[basic.def.odr](3.2)/2</strong>:</p>\n<blockquote>\n<p id=\"so_23428684_23436665_3\">An expression is <em>potentially evaluated</em> unless it is an unevaluated operand (Clause 5) or a subexpression thereof.</p>\n</blockquote>\n<p><strong>[expr](5)/8</strong> just redirects us to other subclauses:</p>\n<blockquote>\n<p id=\"so_23428684_23436665_4\">In some contexts, unevaluated operands appear (5.2.8, 5.3.3, 5.3.7, 7.1.6.2). An unevaluated operand is not evaluated.</p>\n</blockquote>\n<p>These subclauses say that (respectively) the operand of some <code>typeid</code> expressions, the operand of <code>sizeof</code>, the operand of <code>noexcept</code>, and the operand of <code>decltype</code> are unevaluated operands. There are no other kinds of unevaluated operand.</p>\n", "LastActivityDate": "2014-05-02T21:19:52.220"}, "23763205": {"ParentId": "23428684", "LastEditDate": "2017-05-23T11:46:30.963", "CommentCount": "0", "CreationDate": "2014-05-20T14:52:47.843", "OwnerUserId": "567292", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "23763205", "Score": "5", "Body": "<h2>Yes, <code>A::a</code> is <em>odr-used</em>.</h2>\n<p>In C++11, the relevant wording is 3.2p2 <strong>[basic.def.odr]</strong>:</p>\n<blockquote>\n<p id=\"so_23428684_23763205_0\">[...] A variable whose name appears as a potentially-evaluated expression is <em>odr-used</em> unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is immediately applied. [...]</p>\n</blockquote>\n<p>The name of the variable <code>A::a</code> appears in the declaration <code>int a = A::a[0]</code>, in the full-expression <code>A::a[0]</code>, which is a potentially-evaluated expression. <code>A::a</code> is:</p>\n<ul>\n<li>an object</li>\n<li>that satisfies the requirements for appearing in a constant expression</li>\n</ul>\n<p>However, the lvalue-to-rvalue conversion is <em>not</em> immediately applied to <code>A::a</code>; it is applied to the expression <code>A::a[0]</code>. Indeed, lvalue-to-rvalue conversion may not apply to an object of array type (4.1p1).</p>\n<p>So <code>A::a</code> is <em>odr-used</em>.</p>\n<hr>\n<p>Since C++11, the rules have been broadened somewhat.  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#712\" rel=\"nofollow noreferrer\">DR712</a> <strong>Are integer constant operands of a <em>conditional-expression</em> \"used?\"</strong> introduces the concept of the <em>set of potential results</em> of an expression, which allows expressions such as <code>x ? S::a : S::b</code> to avoid <em>odr-use</em>.  However, while the <em>set of potential results</em> respects such operators as the conditional operator and comma operator, it does not respect indexing or indirection; so <code>A::a</code> is still <em>odr-used</em> in the current drafts for C++14 (n3936 as of date).</p>\n<p>[I believe this is a condensed equivalent to Richard Smith's answer, which however does not mention the change since C++11.]</p>\n<p>At <a href=\"https://stackoverflow.com/questions/23491781/when-is-a-variable-odr-used-in-c14\">When is a variable odr-used in C++14?</a> we discuss this issue and possible wording changes to section 3.2 to allow indexing or indirecting an array to avoid <em>odr-use</em>.</p>\n</hr>", "LastActivityDate": "2014-05-21T15:19:00.163"}, "bq_ids": {"n4140": {"so_23428684_23436665_0": {"section_id": 7040, "quality": 0.5833333333333334, "length": 7}, "so_23428684_23428685_3": {"section_id": 11, "quality": 0.85, "length": 17}, "so_23428684_23428685_2": {"section_id": 6185, "quality": 0.5454545454545454, "length": 6}, "so_23428684_23436665_1": {"section_id": 7040, "quality": 0.8333333333333334, "length": 10}, "so_23428684_23436665_3": {"section_id": 7039, "quality": 0.875, "length": 7}, "so_23428684_23763205_0": {"section_id": 7040, "quality": 0.5555555555555556, "length": 10}}, "n3337": {"so_23428684_23436665_0": {"section_id": 6785, "quality": 0.5833333333333334, "length": 7}, "so_23428684_23428685_3": {"section_id": 8, "quality": 0.85, "length": 17}, "so_23428684_23428685_2": {"section_id": 5946, "quality": 0.8181818181818182, "length": 9}, "so_23428684_23436665_3": {"section_id": 6785, "quality": 0.875, "length": 7}, "so_23428684_23763205_0": {"section_id": 6785, "quality": 0.8888888888888888, "length": 16}, "so_23428684_23428685_1": {"section_id": 6785, "quality": 0.6818181818181818, "length": 15}}, "n4659": {"so_23428684_23436665_1": {"section_id": 8537, "quality": 0.8333333333333334, "length": 10}, "so_23428684_23428685_3": {"section_id": 12, "quality": 0.85, "length": 17}, "so_23428684_23436665_3": {"section_id": 8536, "quality": 0.875, "length": 7}, "so_23428684_23436665_0": {"section_id": 8537, "quality": 0.5833333333333334, "length": 7}, "so_23428684_23763205_0": {"section_id": 8537, "quality": 0.5555555555555556, "length": 10}}}});