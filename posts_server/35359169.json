post_cb({"bq_ids": {"n4140": {"so_35359169_35359225_0": {"length": 8, "quality": 1.0, "section_id": 986}, "so_35359169_35359296_1": {"length": 8, "quality": 1.0, "section_id": 986}}, "n3337": {"so_35359169_35359225_0": {"length": 8, "quality": 1.0, "section_id": 971}, "so_35359169_35359296_1": {"length": 8, "quality": 1.0, "section_id": 971}}, "n4659": {"so_35359169_35359225_0": {"length": 8, "quality": 1.0, "section_id": 1049}, "so_35359169_35359296_1": {"length": 8, "quality": 1.0, "section_id": 1049}}}, "35359169": {"ViewCount": "1079", "Body": "<p>When calling the <code>insert</code> member function on a <code>std::vector</code>, will it <code>reserve</code> before \"pushing back\" the new items? I mean does the standard guarantee that or not?</p>\n<p>In other words, should I do it like this:</p>\n<pre><code>std::vector&lt;int&gt; a{1,2,3,4,5};\nstd::vector&lt;int&gt; b{6,7,8,9,10};\na.insert(a.end(),b.begin(),b.end());\n</code></pre>\n<p>or like this:</p>\n<pre><code>std::vector&lt;int&gt; a{1,2,3,4,5};\nstd::vector&lt;int&gt; b{6,7,8,9,10};\na.reserve(a.size()+b.size());\na.insert(a.end(),b.begin(),b.end());\n</code></pre>\n<p>or another better approach?</p>\n", "AcceptedAnswerId": "35359472", "Title": "Does std::vector::insert reserve by definition?", "CreationDate": "2016-02-12T09:37:26.910", "Id": "35359169", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-02-12T10:27:57.253", "LastEditorUserId": "3747990", "LastActivityDate": "2016-02-12T15:26:04.423", "Score": "6", "OwnerUserId": "4523099", "Tags": "<c++><c++11><vector>", "AnswerCount": "3"}, "35359296": {"Id": "35359296", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35359169_35359296_0\">Does <code>std::vector::insert</code> reserve by definition?</p>\n</blockquote>\n<p>Yes, no; depends on the current capacity.</p>\n<p>From the draft N4567, \u00a723.3.6.5/1 ([vector.modifiers]):</p>\n<blockquote>\n<p id=\"so_35359169_35359296_1\">Causes reallocation if the <strong>new size is greater than the old capacity</strong>.</p>\n</blockquote>\n<p>If the allocated memory capacity in the <code>vector</code> is large enough to contain the new elements, no additional allocations for the <code>vector</code> are needed. So no, then it won't reserve memory.</p>\n<p>If the <code>vector</code> capacity is not large enough, then a new block is allocated, the current contents moved/copied over and the new elements are inserted. The exact allocation algorithm is not specified, but typically it would be as used in the <code>reserve()</code> method.</p>\n<blockquote>\n<p id=\"so_35359169_35359296_2\">... or another better approach?</p>\n</blockquote>\n<p>If you are concerned about too many allocations whilst inserting elements into the <code>vector</code>, then calling the <code>reserve</code> method with the size of the number of expected elements to be added does minimise the allocations.</p>\n<blockquote>\n<p id=\"so_35359169_35359296_3\">Does the <code>vector</code> call <code>reserve</code> before the/any insertions? I.e. does it allocate enough capacity in a single allocation?</p>\n</blockquote>\n<p>No guarantees. How would it know the distance between the to input iterators? Given that the <a href=\"http://en.cppreference.com/w/cpp/container/vector/insert\" rel=\"nofollow\"><code>insert</code></a> method can take an <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\" rel=\"nofollow\">InputIterator</a> (i.e. single pass iterator), it has no why of calculating the expected size. <em>Could the method calculate the size if the iterators where something else (e.g. pointers or <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\" rel=\"nofollow\">RandomAccessIterator</a>)</em>? Yes it could. <em>Would it</em>? Depends on the implementation and the optimisations that are made.</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2016-02-12T15:26:04.423", "Score": "1", "CreationDate": "2016-02-12T09:44:13.830", "ParentId": "35359169", "CommentCount": "4", "OwnerUserId": "3747990", "LastEditDate": "2016-02-12T15:26:04.423"}, "35359225": {"Id": "35359225", "PostTypeId": "2", "Body": "<p>From the <a href=\"http://en.cppreference.com/w/cpp/container/vector/insert\" rel=\"nofollow\">documentation</a>, it seems that:</p>\n<blockquote>\n<p id=\"so_35359169_35359225_0\">Causes reallocation if the new\u00a0size()\u00a0is greater than the old capacity().</p>\n</blockquote>\n<p>Be aware also that in such a case all the iterators and references are invalidated.</p>\n<p>It goes without saying thus that reallocations are in charge of the <code>insert</code> and, if you look at those operations one at the time, it's as a consistent <em>reserve-size-plus-one</em> operation is made at each step.<br>\nYou can argue that a <code>reserve</code> call at the top of the insertion would speed up everything in those cases when more than one reallocation takes place... Well, right, it could help, but it mostly depends on your actual problem.</br></p>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2016-02-12T09:59:00.080", "Score": "1", "CreationDate": "2016-02-12T09:40:02.937", "ParentId": "35359169", "CommentCount": "5", "OwnerUserId": "4987285", "LastEditDate": "2016-02-12T09:59:00.080"}, "35359472": {"Id": "35359472", "PostTypeId": "2", "Body": "<p>Regarding the complexity of the function <a href=\"http://www.cplusplus.com/reference/vector/vector/insert/\" rel=\"noreferrer\">[link]</a>:</p>\n<blockquote>\n<p id=\"so_35359169_35359472_0\">Linear on the number of elements inserted (copy/move construction)\n  plus the number of elements after position (moving).</p>\n<p id=\"so_35359169_35359472_1\">Additionally, if InputIterator in the range insert (3) is not at least\n  of a forward iterator category (i.e., just an input iterator) the new\n  capacity cannot be determined beforehand and the insertion incurs in\n  additional logarithmic complexity in size (reallocations).</p>\n</blockquote>\n<p>Hence, there is two cases :</p>\n<ul>\n<li>The new capacity can be determined, therefore you won't need to call reserve</li>\n<li>The new capacity can't be determined, hence a call to <code>reserve</code> should be useful.</li>\n</ul>\n", "LastEditorUserId": "1013504", "LastActivityDate": "2016-02-12T09:59:40.860", "Score": "12", "CreationDate": "2016-02-12T09:53:06.907", "ParentId": "35359169", "CommentCount": "2", "OwnerUserId": "1013504", "LastEditDate": "2016-02-12T09:59:40.860"}});