post_cb({"bq_ids": {"n4140": {"so_28746372_35578374_0": {"length": 72, "quality": 0.9113924050632911, "section_id": 6364}, "so_28746372_35578374_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 2576}}, "n3337": {"so_28746372_35578374_0": {"length": 72, "quality": 0.9113924050632911, "section_id": 6121}, "so_28746372_35578374_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 2541}}, "n4659": {"so_28746372_35578374_0": {"length": 72, "quality": 0.9113924050632911, "section_id": 7875}, "so_28746372_35578374_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 3314}}}, "40063005": {"Id": "40063005", "PostTypeId": "2", "Body": "<p>I have to admit to a bit of surprise at the confusion regarding &lt;system_error&gt; given Chris summarised exactly how it works at <a href=\"http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html\" rel=\"noreferrer\">http://blog.think-async.com/2010/04/system-error-support-in-c0x-part-1.html</a> and I personally find the C++ standard text above perfectly clear. But to summarise in very succinct words:</p>\n<p><strong>If on POSIX:</strong></p>\n<p><code>generic_category</code> =&gt; POSIX standard errno space</p>\n<p><code>system_category</code> =&gt; Local POSIX errno space (usually extends POSIX with proprietary errno codes). Use <code>strerror()</code> to expand codes into string descriptions returned by <code>message()</code>.</p>\n<p>In practice on POSIX both implementations are the same underneath and map the native errno space.</p>\n<p><strong>If on Windows:</strong></p>\n<p><code>generic_category</code> =&gt; POSIX standard errno space which is returned by various POSIX emulation functions in the MSVCRT like <code>fopen()</code> etc</p>\n<p><code>system_category</code> =&gt; The Win32 <code>GetLastError()</code> space. Use <code>FormatMessage()</code> to expand codes into string descriptions returned by <code>message()</code>.</p>\n<p><strong>How to use &lt;system_error&gt; portably</strong>\n</p>\n<pre><code>std::error_code ec;\n#ifdef _WIN32\nif((HANDLE)-1 == CreateFile(...))\n  ec = std::error_code(GetLastError(), std::system_category());\n#else\nif(-1 == open(...))\n  ec = std::error_code(errno, std::system_category());\n#endif\n// To test using portable code\nif(ec == std::errc::no_such_file_or_directory)\n   ...\n// To convert into nearest portable error condition (lossy, may fail)\nstd::error_condition ec2(ec.default_error_condition())\n</code></pre>\n<p><strong>Other thoughts:</strong></p>\n<p>Some commentators have said that &lt;system_error&gt; is poorly designed and shouldn't be used. This is simply not true, it's pretty optimal given the C++ 03 idiomatic practice of the time of its design, it generates very tight high quality fixed latency code on all major STLs except Dinkumware's. It's user extensible to any arbitrary error code system, and standardises unifying into a single system disparate third party library error handling.</p>\n<p>It is true it would look quite different today had constexpr global variables been available at the time of its design, and maybe that might get rectified in a C++ standard coming after 17. But if you are a programmer who needs to move around error codes from third party libraries <strong>without losing information</strong> through code not written to know about those third party libraries, then &lt;system_error&gt; is an <strong>excellent</strong> solution.</p>\n<p>Consider it as similar to the <code>virtual</code> keyword for third party library error code handling - it erases the need for code transporting third party codes from needing to understand those codes. If you have that problem in your code base - and most large code bases do - then absolutely you should be using &lt;system_error&gt; instead of whatever error code mapping or translation system you're currently using.</p>\n", "LastActivityDate": "2016-10-15T18:57:36.187", "CommentCount": "0", "CreationDate": "2016-10-15T18:57:36.187", "ParentId": "28746372", "Score": "10", "OwnerUserId": "805579"}, "35578374": {"Id": "35578374", "PostTypeId": "2", "Body": "<h2>In the C++ standard:</h2>\n<h3><code>system_category</code></h3>\n<p>The <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf\" rel=\"nofollow noreferrer\">current C++17 draft</a> states that:</p>\n<blockquote>\n<p id=\"so_28746372_35578374_0\"><b>Certain functions in the C ++ standard library report errors\n  via a <code>std::error_code</code> (19.5.2.1) object. That\n  object\u2019s <code>category()</code> member shall return <code>std::system_category()</code>\n  for errors originating from the operating system,</b>\n  or a reference to an implementation-defined <code>error_category</code>\n  object for errors originating elsewhere. The implementation\n  shall define the possible values of value() for each of these\n  error &gt; categories.\n  [ Example: <b>For operating systems that are based on POSIX,\n  implementations are encouraged to define the <code>std::system_category()</code>\n  values as identical to the POSIX <code>errno</code> values, with additional\n  values as defined by the operating system\u2019s documentation.</b>\n  Implementations for operating systems that are not based on POSIX\n  are encouraged to define values identical to the operating\n  system\u2019s values. For errors that do not originate from the\n  operating system, the implementation may provide enums for the\n  associated values.</p>\n</blockquote>\n<p>It's not so clear:</p>\n<ul>\n<li><p>what is supposed to happen to <code>errno</code> values on Windows?</p></li>\n<li><p>is an <code>errno</code> from a POSIX call \"originating from the operating system\" or is this supposed to be restricted to non POSIX calls?</p></li>\n</ul>\n<h3><code>generic_category</code></h3>\n<ul>\n<li><p><code>std::errc</code> is an enumeration with the same values as the C/POSIX <code>EFOOBAR</code> errors code;</p>\n<blockquote>\n<p id=\"so_28746372_35578374_1\">The value of each <code>enum errc</code> constant shall be the same as the\n  value of the <code>&lt;cerrno&gt;</code> macro shown in the above synopsis.\n  Whether or not the  implementation exposes the\n  <code>&lt;cerrno&gt;</code> macros is unspecified.</p>\n</blockquote></li>\n<li><p><code>make_error_code(std::errc)</code> generates an <code>erro_code</code> using <code>generic_category</code></p>\n<blockquote>\n<p id=\"so_28746372_35578374_2\"><code>error_code make_error_code(errc e) noexcept;</code></p>\n<p id=\"so_28746372_35578374_3\">Returns: <code>error_code(static_cast&lt;int&gt;(e), generic_category())</code>.</p>\n</blockquote></li>\n</ul>\n<p>This means that POSIX error code can be used with <code>generic_category</code>. Non POSIX values might possibly not work correctly with <code>generic_catgeory</code>. In practice, they seem to be supported by the implementations I've been using.</p>\n<h2>In Boost</h2>\n<h3>Boost system itself</h3>\n<p>The Boost documentation is quite terse about this feature:</p>\n<blockquote>\n<p id=\"so_28746372_35578374_4\">The original proposal viewed error categories as a binary choice\n  between errno (i.e. POSIX-style) and the native operating system's\n  error codes.</p>\n</blockquote>\n<p>Moreover you can find legacy declaration such as:</p>\n<blockquote>\n<p id=\"so_28746372_35578374_5\"><code>static const error_category &amp;  errno_ecat     = generic_category();</code></p>\n</blockquote>\n<p>In <code>linux_error.hpp</code>:</p>\n<blockquote>\n<p id=\"so_28746372_35578374_6\">To construct an error_code after a API error: <code>error_code( errno, system_category() )</code></p>\n</blockquote>\n<p>In <code>windows_error.hpp</code>:</p>\n<blockquote>\n<p id=\"so_28746372_35578374_7\">To construct an error_code after a API error: <code>error_code( ::GetLastError(), system_category() )</code></p>\n</blockquote>\n<p>In <code>cygwin_error.hpp</code>:</p>\n<blockquote>\n<p id=\"so_28746372_35578374_8\">To construct an error_code after a API error:  error_code( errno, system_category() )</p>\n</blockquote>\n<p>For Windows, Boost uses <code>system_category</code> for non <code>errno</code> errors:</p>\n<pre><code>ec = error_code( ERROR_ACCESS_DENIED, system_category() );\nec = error_code( ERROR_ALREADY_EXISTS, system_category() );\nec = error_code( ERROR_BAD_UNIT, system_category() );\nec = error_code( ERROR_WRITE_PROTECT, system_category() );\nec = error_code( WSAEWOULDBLOCK, system_category() );\n</code></pre>\n<h3>In ASIO</h3>\n<p>We find this kind of code in ASIO:</p>\n<pre><code>template &lt;typename ReturnType&gt;\ninline ReturnType error_wrapper(ReturnType return_value,\n    boost::system::error_code&amp; ec)\n{\n#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)\n  ec = boost::system::error_code(WSAGetLastError(),\n      boost::asio::error::get_system_category());\n#else\n  ec = boost::system::error_code(errno,\n      boost::asio::error::get_system_category());\n#endif\n  return return_value;\n}\n</code></pre>\n<p>We find <code>errno</code> as <code>system_category</code> in POSIX code:</p>\n<pre><code>int error = ::pthread_cond_init(&amp;cond_, 0);\nboost::system::error_code ec(error,\n    boost::asio::error::get_system_category());\n</code></pre>\n<h3>Filesystem</h3>\n<p>We find <code>errno</code> with <code>generic_category</code> in POSIX code:</p>\n<pre><code>if (::chmod(p.c_str(), mode_cast(prms)))\n{\n  if (ec == 0)\n    BOOST_FILESYSTEM_THROW(filesystem_error(\n      \"boost::filesystem::permissions\", p,\n      error_code(errno, system::generic_category())));\n  else\n    ec-&gt;assign(errno, system::generic_category());\n\n}\n</code></pre>\n<h2>In GNU libstdc++</h2>\n<h3>Filesystem</h3>\n<p>We find <code>errno</code> with <code>generic_category</code>:</p>\n<pre><code>if (char* rp = ::realpath(pa.c_str(), buf.get())) {\n  [...]\n}\nif (errno != ENAMETOOLONG) {\n  ec.assign(errno, std::generic_category());\n  return result;\n}\n</code></pre>\n<p>and no usage of <code>system_category</code>.</p>\n<h3>Using libstdc++</h3>\n<p>In practice, it seems you can use <code>generic_category</code> for non-POSIX <code>errno</code> with libstdc++:</p>\n<pre><code>std::error_code a(EADV, std::generic_category());\nstd::error_code b(EADV, std::system_category());\nstd::cerr &lt;&lt; a.message() &lt;&lt; '\\n';\nstd::cerr &lt;&lt; b.message() &lt;&lt; '\\n';\n</code></pre>\n<p>Gives:</p>\n<pre><code>Advertise error\nAdvertise error\n</code></pre>\n<h2>Libc++</h2>\n<p>We find <code>errno</code> with <code>system_category</code>:</p>\n<pre><code>int ec = pthread_join(__t_, 0);\nif (ec)\n  throw system_error(error_code(ec, system_category()), \"thread::join failed\");\n</code></pre>\n<p>but no usage of <code>generic_category</code>.</p>\n<h2>Conclusion</h2>\n<p>I don't find any consistent pattern here but apparently:</p>\n<ul>\n<li><p>you are expected to use <code>system_category</code> when using Windows error on Windows;</p></li>\n<li><p>you can safely use <code>generic_category</code> for POSIX values of <code>errno</code>;</p></li>\n<li><p>you are not supposed to be able to use <code>std::generic_category</code> for non-POSIX vales of <code>errno</code> (it might not work);</p></li>\n<li><p>If you do not want to check if your <code>errno</code> value is a POSIX one: <del>on POSIX-based systems you are expected to be able to use <code>system_error</code> with <code>errno</code> (strictly speaking the support for this is not mandated, only encouraged).</del>  on POSIX-based systems you can use <code>system_error</code> with <code>errno</code>.</p></li>\n</ul>\n", "LastEditorUserId": "637866", "LastActivityDate": "2017-09-23T15:00:30.907", "Score": "10", "CreationDate": "2016-02-23T13:03:56.183", "ParentId": "28746372", "CommentCount": "7", "OwnerUserId": "637866", "LastEditDate": "2017-09-23T15:00:30.907"}, "28746372": {"ViewCount": "2073", "Body": "<p>C++11 introduced the <code>&lt;system_error&gt;</code> header containing a generic system to handle error codes. An <code>std::error_code</code> is a tuple containing an <code>int</code>, the error code, and a reference to an <code>std::error_category</code>, which defines the error domain and handling of the error code. The standard library comes with four categories: <code>std::generic_category</code>, <code>std::system_category</code>, <code>std::future_category</code>, and <code>std::iostream_category</code>.</p>\n<p>There are conflicts on which category to use, both here on SO and on C++ reference sites, when creating <code>std::error_code</code>s/throwing <code>std::system_error</code>s with <code>errno</code> and WinAPI error codes:</p>\n<ul>\n<li><code>errno</code> with <code>std::generic_category</code>: <a href=\"https://stackoverflow.com/questions/7542822/should-i-use-system-category-or-generic-category-for-errno-on-unix\">SO answer</a>, <a href=\"http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140609/220875.html\" rel=\"nofollow noreferrer\">llvm-commits</a>, <a href=\"http://www.cplusplus.com/reference/system_error/error_code/error_code/\" rel=\"nofollow noreferrer\">cplusplus.com</a></li>\n<li><code>errno</code> with <code>std::system_category</code>: <a href=\"https://stackoverflow.com/a/12171615/275196\">SO answer</a>, <a href=\"http://en.cppreference.com/w/cpp/error/system_error/system_error\" rel=\"nofollow noreferrer\">cppreference.com</a></li>\n<li><code>GetLastError()</code> with <code>std::generic_category</code>: <a href=\"https://stackoverflow.com/a/18666849/275196\">SO answer</a></li>\n<li><code>GetLastError()</code> with <code>std::system_category</code>: <a href=\"https://stackoverflow.com/a/15855015/275196\">SO answer</a>, <a href=\"https://stackoverflow.com/questions/13950938/construct-stderror-code-from-errno-on-posix-and-getlasterror-on-windows/13951278#comment19241253_13951278\">SO comment</a></li>\n</ul>\n<p>However, <code>errno</code> and <code>GetLastError()</code> can't use the same category, otherwise some error codes would be ambiguous. Error code 33 is one example, as it is both <code>EDOM</code> and <code>ERROR_LOCK_VIOLATION</code>.</p>\n<p>There are even some places advocating a user-made category for the WinAPI, but I can't find any references to that at the moment. This alternative would be specially painful.</p>\n<p>Which category should be used with <code>errno</code>, and which should be used with <code>GetLastError()</code> so that</p>\n<ul>\n<li><code>std::error_code::default_error_condition()</code></li>\n<li><code>std::error_code::message()</code></li>\n</ul>\n<p>are unambinguous and appropriate to the underlying error code?</p>\n", "AcceptedAnswerId": "35578374", "Title": "<system_error> categories and standard/system error codes", "CreationDate": "2015-02-26T15:27:36.397", "Id": "28746372", "CommentCount": "4", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:57.963", "LastEditorUserId": "-1", "LastActivityDate": "2017-09-23T15:00:30.907", "Score": "21", "OwnerUserId": "275196", "Tags": "<c++><c++11><winapi><posix><system-error>", "AnswerCount": "2"}});