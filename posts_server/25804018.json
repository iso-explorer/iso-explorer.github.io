post_cb({"25804088": {"ParentId": "25804018", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As far as <code>std::allocate_shared</code> is concerned, the behaviour you're seeing is correct. Quoting C++11 [util.smartptr.shared.create]:</p>\n<blockquote>\n<pre><code>template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);\ntemplate&lt;class T, class A, class... Args&gt;\nshared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_25804018_25804088_0\">2 <em>Effects:</em> Allocates memory suitable for an object of type <code>T</code> and constructs an object in that memory\n  via the placement new expression <code>::new (pv) T(std::forward&lt;Args&gt;(args)...)</code>. The template\n  <code>allocate_shared</code> uses a copy of <code>a</code> to allocate memory. If an exception is thrown, the functions have\n  no effect.</p>\n</blockquote>\n<p>Since the standard library shared pointer support is largely based on the Boost implementations, I would say it makes sense that Boost behaves likewise.</p>\n<p>As @KerrekSB pointed out in comments, there is apparently a standard library <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2070\" rel=\"nofollow\">active issue 2070</a> about this.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2014-09-12T08:50:18.863", "Id": "25804088", "Score": "1", "CreationDate": "2014-09-12T08:40:32.633", "LastActivityDate": "2014-09-12T08:50:18.863"}, "25804018": {"CommentCount": "1", "ViewCount": "108", "CreationDate": "2014-09-12T08:35:49.690", "LastActivityDate": "2014-09-12T08:50:18.863", "Title": "Why does boost::allocate_shared<T> (alloc) ignore alloc.construct() and does std::allocate_shared<T> (alloc) behave alike?", "AcceptedAnswerId": "25804088", "PostTypeId": "1", "Id": "25804018", "Score": "2", "Body": "<p>I want to write a custom allocator which invokes a <code>createHook()</code> just after object construction and a symmetrical <code>destroyHook()</code> just before object destruction. I am using my allocator this way:</p>\n<pre><code>class Object {};\nclass CustomAllocator { /* ... */ };\n\nboost::shared_ptr&lt;Object&gt; object = boost::allocate_shared&lt;Object&gt; (CustomAllocator ());\n</code></pre>\n<p>While <code>allocate_shared&lt;&gt;</code> correctly calls <code>allocate()</code> on my allocator, it does use an in-place <code>new</code> statement rather than calling <code>construct()</code> on my allocator.</p>\n<p>I know how to circumvent this problem in general by writing a custom <code>my_allocate_shared()</code> version which invokes the <code>createHook()</code> and returns a <code>shared_ptr&lt;&gt;</code> instance with a custom deleter (which in turn invokes the <code>destroyHook()</code>), but i am loosing the <code>allocate_shared&lt;&gt;</code> optimization then.</p>\n<p>My coding environment is restricted to C++03, so i don't know how <code>std::allocate_shared()</code> in a C++11 context behaves (or should behave).</p>\n", "Tags": "<c++><boost><shared-ptr><allocator>", "OwnerUserId": "2266052", "AnswerCount": "2"}, "25804086": {"ParentId": "25804018", "CommentCount": "2", "Body": "<p>\u00a720.8.2.2.6 [util.smartptr.shared.create]/p1-2:</p>\n<blockquote>\n<pre><code>template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared(Args&amp;&amp;... args);\ntemplate&lt;class T, class A, class... Args&gt;\nshared_ptr&lt;T&gt; allocate_shared(const A&amp; a, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_25804018_25804086_0\"><em>Requires</em>: The expression <code>::new (pv) T(std::forward&lt;Args&gt;(args)...)</code>, where <code>pv</code> has type <code>void*</code> and\n  points to storage suitable to hold an object of type <code>T</code>, shall be\n  well formed. <code>A</code> shall be an allocator (17.6.3.5). The copy\n  constructor and destructor of <code>A</code> shall not throw exceptions.</p>\n<p id=\"so_25804018_25804086_1\"><em>Effects:</em> Allocates memory suitable for an object of type <code>T</code> and constructs an object in that memory via the placement new expression\n  <code>::new (pv) T(std::forward&lt;Args&gt;(args)...)</code>. The template\n  <code>allocate_shared</code> uses a copy of <code>a</code> to allocate memory. If an\n  exception is thrown, the functions have no effect.</p>\n</blockquote>\n<p>In short, <code>std::allocate_shared</code> uses placement new directly rather than the allocator's <code>construct</code>.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25804086", "Score": "1", "CreationDate": "2014-09-12T08:40:27.907", "LastActivityDate": "2014-09-12T08:40:27.907"}, "bq_ids": {"n4140": {"so_25804018_25804086_1": {"section_id": 4439, "quality": 0.9259259259259259, "length": 25}, "so_25804018_25804086_0": {"section_id": 4438, "quality": 0.7916666666666666, "length": 19}, "so_25804018_25804088_0": {"section_id": 4439, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_25804018_25804086_1": {"section_id": 4276, "quality": 0.9259259259259259, "length": 25}, "so_25804018_25804086_0": {"section_id": 4275, "quality": 0.7916666666666666, "length": 19}, "so_25804018_25804088_0": {"section_id": 4276, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_25804018_25804086_1": {"section_id": 5704, "quality": 0.8518518518518519, "length": 23}, "so_25804018_25804086_0": {"section_id": 5703, "quality": 0.8333333333333334, "length": 20}, "so_25804018_25804088_0": {"section_id": 5704, "quality": 0.8518518518518519, "length": 23}}}});