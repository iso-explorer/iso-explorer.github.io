post_cb({"6423346": {"Id": "6423346", "PostTypeId": "2", "Body": "<p>Semantically and conceptually and with respect to The Holy Standard, it will be created every time. </p>\n<p>The rest is up to your compiler and how you support her:</p>\n<p><strong>Possibly</strong> the compiler can inline the call and then move deduced invariants outside\nto a single point of initialization. </p>\n<p><strong>Possibly</strong> the compiler dislikes that your\nfunction has external linkage and so does not inline it, then having a hard time\nseeing that invariant from other functions. </p>\n<p><strong>Possibly</strong> the compiler will always check a variables constness and use one-time-initialization\nwhen it can look inside and verify that <code>boost::assign::map_list_of( A, \"A\" )( B, \"B\" )( C, \"C\" )</code>\ndoes not mutate global state.</p>\n<p>Many factors, and the only way to be sure is to look at generated code.</p>\n<hr>\n<p>In response to a request for quotation:</p>\n<p><strong>3.7.2.3 [basic.std.auto]:</strong> </p>\n<blockquote>\n<p id=\"so_6423210_6423346_0\">If a named automatic object has initialization or a destructor with side effects, it shall not be destroyed before the end of its block, nor shall it be eliminated as an optimization even if it appears to be unused, except that a class object or its copy may be eliminated as specified in\"  </p>\n</blockquote>\n<p>This basically means that either it has side effects, in which case it won't be eliminated, or it hasn't, in which case it is hardly observable within C++; this means effectively: </p>\n<p><em>The observed behaviour is always <strong>as if it is called every time</strong>.</em></p>\n<p>In other words: <em>There is no way to guarantee that initialization only happens once with automatic storage, so never assume the opposite</em>.</p>\n</hr>", "LastEditorUserId": "76722", "LastActivityDate": "2011-06-21T10:33:59.390", "Score": "5", "CreationDate": "2011-06-21T09:47:45.570", "ParentId": "6423210", "CommentCount": "5", "OwnerUserId": "76722", "LastEditDate": "2011-06-21T10:33:59.390"}, "bq_ids": {"n4140": {"so_6423210_6423346_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 7172}}, "n3337": {"so_6423210_6423346_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 6916}}, "n4659": {"so_6423210_6423346_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 8680}}}, "6423210": {"ViewCount": "405", "Body": "<p>Considering the example at the end of the question, is the map object going to be created every time the function <code>GetName()</code> is called?<br>\nOr is the creation going to be optimized away and created as some lookup table?</br></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;boost/assign/list_of.hpp&gt;\n\nenum abc\n{\n    A = 1,\n    B,\n    C\n};\n\nstd::string GetName( const abc v )\n{\n    const std::map&lt; abc, std::string &gt; values =\n        boost::assign::map_list_of( A, \"A\" )( B, \"B\" )( C, \"C\" );\n    std::map&lt; abc, std::string &gt;::const_iterator it = values.find( v );\n    if ( values.end() == it )\n    {\n        std::stringstream ss;\n        ss &lt;&lt; \"invalid value (\" &lt;&lt; static_cast&lt; int &gt;( v ) &lt;&lt; \")\";\n        return ss.str();\n    }\n    return it-&gt;second;\n}\n\nint main()\n{\n    const abc a = A;\n    const abc b = B;\n    const abc c = C;\n    const abc d = static_cast&lt; abc &gt;( 123 );\n\n    std::cout&lt;&lt;\"a=\"&lt;&lt;GetName(a)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"b=\"&lt;&lt;GetName(b)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"c=\"&lt;&lt;GetName(c)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"d=\"&lt;&lt;GetName(d)&lt;&lt;std::endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "6423346", "Title": "Is std::map table initialization optimized?", "CreationDate": "2011-06-21T09:36:24.520", "Id": "6423210", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-06-21T10:36:13.280", "Score": "3", "OwnerUserId": "476681", "Tags": "<c++><optimization><lookup-tables>", "AnswerCount": "2"}, "6423916": {"Id": "6423916", "PostTypeId": "2", "Body": "<p>Why not use a functor?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;boost/assign/list_of.hpp&gt;\n\n\nenum abc\n{\n    A = 1,\n    B,\n    C\n};\n\nclass LookupTable\n{\n    typedef std::map&lt;abc, std::string&gt; map_type;\n\npublic:\n    LookupTable(const map_type &amp;values)\n    : table(values)\n    {}\n\n    std::string operator()(abc v) const\n    {\n         map_type::const_iterator it = table.find(v);\n         if (table.end() == it)\n         {\n             std::stringstream ss;\n            ss &lt;&lt; \"invalid value (\" &lt;&lt; static_cast&lt; int &gt;( v ) &lt;&lt; \")\";\n            return ss.str();\n         }\n         return it-&gt;second;\n    }\n\nprivate:\n    const map_type table;\n};\n\n\nint main()\n{\n    std::map&lt;abc, std::string&gt; values = boost::assign::map_list_of( A, \"A\" )( B, \"B\" )( C, \"C\" );\n    LookupTable GetName(values);\n\n    const abc a = A;\n    const abc b = B;\n    const abc c = C;\n    const abc d = static_cast&lt; abc &gt;( 123 );\n\n    std::cout&lt;&lt;\"a=\"&lt;&lt;GetName(a)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"b=\"&lt;&lt;GetName(b)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"c=\"&lt;&lt;GetName(c)&lt;&lt;std::endl;\n    std::cout&lt;&lt;\"d=\"&lt;&lt;GetName(d)&lt;&lt;std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2011-06-21T10:36:13.280", "CommentCount": "2", "CreationDate": "2011-06-21T10:36:13.280", "ParentId": "6423210", "Score": "0", "OwnerUserId": "808241"}});