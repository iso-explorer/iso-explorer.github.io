post_cb({"bq_ids": {"n4140": {"so_28811034_28811449_18": {"section_id": 4605, "quality": 0.9333333333333333, "length": 14}, "so_28811034_28811449_13": {"section_id": 6151, "quality": 0.7857142857142857, "length": 11}, "so_28811034_28811449_3": {"section_id": 6145, "quality": 0.5833333333333334, "length": 14}, "so_28811034_28811449_10": {"section_id": 6145, "quality": 0.5833333333333334, "length": 14}, "so_28811034_28811449_6": {"section_id": 6151, "quality": 0.7857142857142857, "length": 11}, "so_28811034_28811449_5": {"section_id": 6151, "quality": 0.9375, "length": 30}, "so_28811034_28811449_17": {"section_id": 4605, "quality": 0.9333333333333333, "length": 14}, "so_28811034_28811449_12": {"section_id": 6151, "quality": 0.9375, "length": 30}}, "n3337": {"so_28811034_28811449_18": {"section_id": 4423, "quality": 0.9333333333333333, "length": 14}, "so_28811034_28811449_13": {"section_id": 5913, "quality": 1.0, "length": 14}, "so_28811034_28811449_14": {"section_id": 5913, "quality": 1.0, "length": 32}, "so_28811034_28811449_3": {"section_id": 5913, "quality": 1.0, "length": 24}, "so_28811034_28811449_10": {"section_id": 5913, "quality": 1.0, "length": 24}, "so_28811034_28811449_6": {"section_id": 5913, "quality": 1.0, "length": 14}, "so_28811034_28811449_7": {"section_id": 5913, "quality": 1.0, "length": 32}, "so_28811034_28811449_4": {"section_id": 5913, "quality": 1.0, "length": 20}, "so_28811034_28811449_15": {"section_id": 5913, "quality": 1.0, "length": 4}, "so_28811034_28811449_11": {"section_id": 5913, "quality": 1.0, "length": 20}, "so_28811034_28811449_9": {"section_id": 5913, "quality": 1.0, "length": 13}, "so_28811034_28811449_8": {"section_id": 5913, "quality": 1.0, "length": 4}, "so_28811034_28811449_2": {"section_id": 5913, "quality": 1.0, "length": 13}, "so_28811034_28811449_5": {"section_id": 5913, "quality": 1.0, "length": 32}, "so_28811034_28811449_17": {"section_id": 4423, "quality": 0.9333333333333333, "length": 14}, "so_28811034_28811449_12": {"section_id": 5913, "quality": 1.0, "length": 32}}, "n4659": {"so_28811034_28811449_18": {"section_id": 5962, "quality": 0.7333333333333333, "length": 11}, "so_28811034_28811449_13": {"section_id": 7648, "quality": 0.7857142857142857, "length": 11}, "so_28811034_28811449_9": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}, "so_28811034_28811449_17": {"section_id": 5962, "quality": 0.7333333333333333, "length": 11}, "so_28811034_28811449_2": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}, "so_28811034_28811449_5": {"section_id": 7648, "quality": 0.9375, "length": 30}, "so_28811034_28811449_6": {"section_id": 7648, "quality": 0.7857142857142857, "length": 11}, "so_28811034_28811449_12": {"section_id": 7648, "quality": 0.9375, "length": 30}}}, "28811449": {"ParentId": "28811034", "PostTypeId": "2", "CommentCount": "2", "Body": "<h3>Introduction</h3>\n<p>This question really boils down to whether the use of the <em>less-than</em> relational operator on pointer types where one operand is a <code>nullptr</code> will yield the <em>\"expected\"</em> result; which sadly isn't the case.</p>\n<p>The result is <em>unspecified</em>.</p>\n<blockquote>\n<p id=\"so_28811034_28811449_0\"><strong>Note:</strong> Do mind that <code>std::less</code> guarantees a <em>total order</em>; meaning that even if the result, when using the function object, is <em>unspecified</em>, it must yield the same <em>unspecified</em> value on each invocation.</p>\n</blockquote>\n<hr>\n<h3>What does the International Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a>) say?</h3>\n<blockquote>\n<p id=\"so_28811034_28811449_1\">5.9p2 <strong>Relational operators</strong> <code>[expr.rel]</code></p>\n<blockquote>\n<p id=\"so_28811034_28811449_9\">Pointers to objects or functions of the same type (after pointer conversions) can be compared, with a result defined as follows:</p>\n<ul>\n<li><p id=\"so_28811034_28811449_10\">If two pointers <code>p</code> and <code>q</code> of the same type point to the same object or function, or both point one past the end of the same array, or are both null, then <code>p&lt;=q</code> and <code>p&gt;=q</code> both yield <code>true</code> and <code>p&lt;q</code> and <code>p&gt;q</code> both yield <code>false</code>.</p></li>\n<li><p id=\"so_28811034_28811449_11\">If two pointers <code>p</code> and <code>q</code> of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspecified.</p></li>\n<li><p id=\"so_28811034_28811449_12\">If two pointers point to non-static data members of the same object, or to subobjects or array elements of such members, recursively, the pointer to the later declared member compares greater provided the two members have the same access control (Clause 11) and provided their class is not a union.</p></li>\n<li><p id=\"so_28811034_28811449_13\">If two pointers point to non-static data members of the same object with different access control (Clause 11) the result is unspecified.</p></li>\n<li><p id=\"so_28811034_28811449_14\">If two pointers point to non-static data members of the same union object, they compare equal (after conversion to <code>void*</code>, if necessary). If two pointers point to elements of the same array or one beyond the end of the array, the pointer to the object with the higher subscript compares higher.</p></li>\n<li><p id=\"so_28811034_28811449_15\">Other pointer comparisons are unspecified.</p></li>\n</ul>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_28811034_28811449_16\"><code>20.8.5p8</code> <strong>Comparison</strong> <code>[comparision]</code></p>\n<blockquote>\n<p id=\"so_28811034_28811449_18\">For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>So, what is the standard really saying?</h3>\n<pre><code>T * p = new T;\nT * q = nullptr;\n</code></pre>\n<p><br/></p>\n<p><sup><strong>What is the verdict for <code>p &lt; q</code>?</strong> <br/></sup>\nSince <code>p</code> and <code>q</code> don't point to different elements of the same array (including the element one past the last element of an array), and both don't point to non-static data members of the same object; the result when doing <code>p &lt; q</code> (and <code>p &gt; q</code>) is <em>unspecified</em>.</p>\n<pre><code>bool a = p &lt; q;  // unspecified\nbool b = p &lt; q;  // unspecified\n\nassert (a == b); // can fire\n</code></pre>\n<p><br/></p>\n<p><sup><strong>What about <code>std::less</code>?</strong><br/></sup>\nHowever, when using <code>std::less</code> we are guaranteed a total order - which effectively means that the below assertion <strong>cannot</strong> fire (<em>standard-20.8.5p8</em>).</p>\n<pre><code>std::less&lt;T*&gt; comp;\n\nbool a = comp (p, q);  // unspecified\nbool b = comp (p, q);  // unspecified\n\nassert (a == b);       // can not fire\n</code></pre>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "2756719", "LastEditDate": "2015-03-02T17:10:42.033", "Id": "28811449", "Score": "17", "CreationDate": "2015-03-02T13:51:25.950", "LastActivityDate": "2015-03-02T17:10:42.033"}, "28811034": {"CommentCount": "1", "AcceptedAnswerId": "28811449", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2015-03-02T13:30:58.447", "LastActivityDate": "2015-03-02T18:11:48.317", "LastEditDate": "2015-03-02T18:11:48.317", "ViewCount": "806", "FavoriteCount": "3", "Title": "Using std::less with nullptr", "Id": "28811034", "Score": "11", "Body": "<p>Does the assertion in the following code snippet always hold?</p>\n<pre><code>std::less&lt;Object *&gt; lessPtr;\nObject * o = new Object();\nassert(lessPtr (o, nullptr) == false);\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3012136", "AnswerCount": "2"}, "28811388": {"ParentId": "28811034", "CommentCount": "1", "Body": "<p>No, the ordering of a null pointer relative to any non-null pointer is unspecified.</p>\n<p>The result of the comparision operators is unspecified if the operands \"point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null\". </p>\n<p><code>std::less</code> and friends extend this to specify that there's a total order, but don't specify where null pointers occur in that order. So it's guaranteed that <code>null</code> will consistently be either greater than, or less than, any given non-null pointer. But it's not specified to be either less than, or greater than, all non-null pointers.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "28811388", "Score": "4", "CreationDate": "2015-03-02T13:48:14.880", "LastActivityDate": "2015-03-02T13:48:14.880"}});