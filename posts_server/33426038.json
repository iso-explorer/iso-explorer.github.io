post_cb({"bq_ids": {"n4140": {"so_33426038_33436621_0": {"length": 10, "quality": 1.0, "section_id": 327}, "so_33426038_33426038_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 304}, "so_33426038_33426038_2": {"length": 24, "quality": 0.5853658536585366, "section_id": 340}, "so_33426038_33426038_0": {"length": 16, "quality": 1.0, "section_id": 331}}, "n3337": {"so_33426038_33426038_0": {"length": 16, "quality": 1.0, "section_id": 321}, "so_33426038_33436621_0": {"length": 10, "quality": 1.0, "section_id": 317}, "so_33426038_33426038_2": {"length": 24, "quality": 0.5853658536585366, "section_id": 330}, "so_33426038_33426038_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 295}}, "n4659": {"so_33426038_33426038_0": {"length": 16, "quality": 1.0, "section_id": 340}, "so_33426038_33436621_0": {"length": 8, "quality": 0.8, "section_id": 335}, "so_33426038_33426038_2": {"length": 24, "quality": 0.5853658536585366, "section_id": 349}, "so_33426038_33426038_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 311}}}, "33436621": {"Id": "33436621", "PostTypeId": "2", "Body": "<p>First step in overload resolution is finding all the candidates. For the call <code>g(Tuple&lt;int&gt;())</code>, there are three viable candidates:</p>\n<pre><code>g(Tuple&lt;int&gt;); // #1: [Types = {int}]\ng(Tuple&lt;int&gt;); // #2: [T1 = int, Types = {}]\ng(Tuple&lt;int&gt;); // #3: [T1 = int, Types = {}]\n</code></pre>\n<p>All three are equally viable candidates from the perspective of conversion sequences (since, of course, they all take the same argument which is an Exact Match for the input). They are all function template specializations, so we can't differentiate on that basis either.</p>\n<p>So we're left with function template partial ordering. We synthesize types for each of the overloads and attempt to perform template deduction with our synthesized types against each of the other overloads. The simpler comparison is (1) vs (2) and (1) vs (3). There, we have [temp.deduct.partial]:</p>\n<blockquote>\n<p id=\"so_33426038_33436621_0\">If A was transformed from a function parameter pack and P is not a parameter pack, type deduction fails.</p>\n</blockquote>\n<p>Since we transform <code>Types...</code> into <code>UniqA...</code>, and the first parameter is <code>T1</code>, type deduction fails. That makes (2) and (3) both more specialized than (1). So now we compare (2) and (3).</p>\n<p>First, can we deduce (2) from (3)?</p>\n<pre><code>template &lt;class T1, class... Types&gt; void g(Tuple&lt;T1, Types...&gt; );\n\ng(Tuple&lt;Uniq3, Uniq3Pack&amp;...&gt;());\n</code></pre>\n<p>Sure, no problem <code>T1 == Uniq3</code> and <code>Types... == Uniq3Pack&amp;...</code>. Next, we try the other direction:</p>\n<pre><code>template &lt;class T1, class... Types&gt; void g(Tuple&lt;T1, Types&amp;...&gt; );\n\ng(Tuple&lt;Uniq2, Uniq2Pack...&gt;());\n</code></pre>\n<p>This fails, since <code>Uniq2Pack</code> isn't a pack of reference types and <code>Types&amp;...</code> is. Since deduction only succeeds in one direction, that makes (3) the more specialized overload. </p>\n<p>As it's the last one standing, (3) is the best viable candidate. It may seem counterintuitive, since we're not actually calling it with a reference type - but it's still the best choice.</p>\n", "LastEditorUserId": "678093", "LastActivityDate": "2015-10-30T13:02:51.403", "Score": "2", "CreationDate": "2015-10-30T13:00:40.730", "ParentId": "33426038", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2015-10-30T13:02:51.403"}, "33426038": {"ViewCount": "102", "Body": "<blockquote>\n<p id=\"so_33426038_33426038_0\">Partial ordering of function templates containing template parameter packs is independent of the number of deduced arguments for those template parameter packs.</p>\n</blockquote>\n<pre><code>template&lt;class...&gt; struct Tuple { };\ntemplate&lt;          class... Types&gt; void g(Tuple&lt;Types ...&gt;);        // #1\ntemplate&lt;class T1, class... Types&gt; void g(Tuple&lt;T1, Types ...&gt;);    // #2\ntemplate&lt;class T1, class... Types&gt; void g(Tuple&lt;T1, Types&amp; ...&gt;);   // #3\n\ng(Tuple&lt;&gt;());                     // calls #1\ng(Tuple&lt;int, float&gt;());           // calls #2\ng(Tuple&lt;int, float&amp;&gt;());          // calls #3\ng(Tuple&lt;int&gt;());                  // calls #3\n</code></pre>\n<p>The above is quoted from <a href=\"http://en.cppreference.com/w/cpp/language/function_template#Function_template_overloading\" rel=\"nofollow noreferrer\">partial ordering of overload function templates</a>. I don't quite understand why <code>g(Tuple&lt;int&gt;());                  // calls #3</code>. Specifically, why can't <code>#2</code> be called? The following are my reasoning, please point out any mistakes :</p>\n<p><strong>Note</strong>: I will ignore <code>#1</code> b/c it is explained well <a href=\"https://stackoverflow.com/q/32373979/1021388\">here</a></p>\n<p><strong>Step 1</strong>: Deduction and substitution and overload resolution come up with these:</p>\n<ul>\n<li>void(Tuple&lt; int&gt;) [T1 = int, Types is empty] #2</li>\n<li>void(Tuple&lt; int&gt;) [T1 = int, Types&amp; is empty] #3</li>\n</ul>\n<p><strong>Step 2</strong>: Transform both function templates:</p>\n<ul>\n<li>void g(Tuple&lt; C1, Pack1...&gt;);</li>\n<li>void g(Tuple&lt; C2, Pack2&amp;...&gt;);</li>\n</ul>\n<p><strong>Step3</strong>: This is a function call context, the types are those function parameter types for which the function call has arguments:</p>\n<ul>\n<li>Deduce Tuple&lt; T1, Types...&gt; from Tuple&lt; C2, Pack&amp;...&gt; OK [T1 = C2; Types... = Pack&amp;...]</li>\n<li>Deduce Tuple&lt; T1, Types&amp;...&gt; from Tuple&lt; C1, Pack1...&gt;) OK? [T1 = C1; what about Types&amp;...? Can it be deduced from Pack1...? Are reference dropped here?]</li>\n</ul>\n<blockquote>\n<p id=\"so_33426038_33426038_1\">3) If P is a reference type, the type referred to by P is used for deduction.<a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction#Deduction_from_a_type\" rel=\"nofollow noreferrer\">This</a> seems fine.</p>\n<p id=\"so_33426038_33426038_2\">If P has one of the forms that include a template parameter list &lt; T&gt; or &lt; I&gt;, then each element Pi of that template argument list is matched against the corresponding template argument Ai of its A. If the last Pi is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of A. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</p>\n</blockquote>\n<p><strong>Step4</strong>\uff1aIf the last step is correct. Then it means #3 is not more specialized than #2. So it is ambiguous as to which function template should be resolved to.</p>\n<p><strong>Update</strong>: I think I misunderstood the relevant quotes above. When we match up template parameters in P with template arguments in A, they are matched up verbatim, which means that all the transforms and analysis done on <strong>function call</strong> parameters and arguments do not apply again when we match up template parameters/arguments in P/A(actually <strong>function call</strong> parameter/arguments). Then it will fail in <strong>Step 3</strong> above to deduce <code>Tuple&lt; T1, Types&amp;...&gt;</code> from <code>Tuple&lt; C1, Pack1...&gt;)</code>. So <code>#3</code> is more specialized. </p>\n", "AcceptedAnswerId": "33436621", "Title": "Partial ordering of function templates containing template parameter packs", "CreationDate": "2015-10-29T22:53:40.250", "Id": "33426038", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:51:57.130", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-30T13:02:51.403", "Score": "1", "OwnerUserId": "1021388", "Tags": "<c++><templates><overload-resolution>", "AnswerCount": "1"}});