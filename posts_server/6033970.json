post_cb({"6034042": {"Id": "6034042", "PostTypeId": "2", "Body": "<p>When you receive an array parameter, the compiler understands it as a pointer to the array's first element. There's no difference between arrays of different sizes at runtime. That's why you need to know the size you are working with to avoid accessing memory that does not belong to your program..</p>\n", "LastActivityDate": "2011-05-17T16:25:58.900", "CommentCount": "0", "CreationDate": "2011-05-17T16:25:58.900", "ParentId": "6033970", "Score": "2", "OwnerUserId": "693716"}, "6034193": {"Id": "6034193", "PostTypeId": "2", "Body": "<p><code>Char10</code> and <code>char*</code> are indeed different types..</p>\n<p>Try </p>\n<pre><code>if(typeid(a) == typeid(char*))\n    throw 0;  // happens\n</code></pre>\n<p><a href=\"http://www.ideone.com/vE5AK\" rel=\"nofollow\">Online demo</a></p>\n<p>P.S: </p>\n<p>The following declarations are equivalent</p>\n<pre><code>void fun(Char10 a);\nvoid fun(char a[]);\nvoid fun(char *a);\n</code></pre>\n", "LastActivityDate": "2011-05-17T16:42:13.753", "CommentCount": "0", "CreationDate": "2011-05-17T16:42:13.753", "ParentId": "6033970", "Score": "4", "OwnerUserId": "165520"}, "6034096": {"Id": "6034096", "PostTypeId": "2", "Body": "<p>You can, however, accept a reference to an array of the correct size, at which point the compiler <em>will</em> object to it.</p>\n", "LastActivityDate": "2011-05-17T16:31:44.803", "CommentCount": "1", "CreationDate": "2011-05-17T16:31:44.803", "ParentId": "6033970", "Score": "1", "OwnerUserId": "298661"}, "6034240": {"Id": "6034240", "PostTypeId": "2", "Body": "<p>For your edit: the types <em>per se</em> are different, but in C++ you cannot pass an array by value as an argument to a function, and the array type decays to the corresponding pointer type when you use it as a function argument.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nusing namespace std;\n\ntypedef char Char10[10];\nvoid fun (Char10 a) // &lt;-- actually Char10 here is read as char *\n{\n    Char10 test;\n    cout&lt;&lt;(typeid(Char10) == typeid(char*))&lt;&lt;'\\n'\n        &lt;&lt;(typeid(Char10) == typeid(test))&lt;&lt;'\\n'\n        &lt;&lt;(typeid(char *) == typeid(a))&lt;&lt;endl;\n}\n\nint main ()\n{\n  char b[11];  fun(b);  // why works ?\n}\n</code></pre>\n<p>This outputs</p>\n<pre><code>0\n1\n1\n</code></pre>\n<p>Because</p>\n<ul>\n<li><code>char *</code> and <code>char[10]</code> are different types;</li>\n<li><code>test</code> is a <code>char[10]</code></li>\n<li><code>a</code> is actually a <code>char *</code>, because in function declarations the array declaration decays to the corresponding pointer declaration.</li>\n</ul>\n<p>This is a stupid thing that is here for historical reasons, but we're stuck with it.</p>\n<hr/>\n<p>Found in the standard: at \u00a78.3.5 \u00b63:</p>\n<blockquote>\n<p id=\"so_6033970_6034240_0\">After determining the type of each parameter, any parameter of type \u201carray of <code>T</code>\u201d or \u201cfunction returning <code>T</code>\u201d is adjusted to be \u201cpointer to <code>T</code>\u201d or \u201cpointer to function returning <code>T</code>,\u201d respectively.</p>\n</blockquote>\n", "LastActivityDate": "2011-05-17T16:45:56.310", "CommentCount": "2", "CreationDate": "2011-05-17T16:45:56.310", "ParentId": "6033970", "Score": "2", "OwnerUserId": "214671"}, "bq_ids": {"n4140": {"so_6033970_6034240_0": {"length": 16, "quality": 1.0, "section_id": 3241}}, "n3337": {"so_6033970_6034240_0": {"length": 16, "quality": 1.0, "section_id": 3114}}, "n4659": {"so_6033970_6034240_0": {"length": 12, "quality": 0.75, "section_id": 3997}}}, "6034199": {"Id": "6034199", "PostTypeId": "2", "Body": "<p>You cannot pass array by value neither in C nor in C++. Arrays in C/C++ are non copyable, so regardless of what you do, you will never achieve \"pass by value\" semantics with array type. </p>\n<p>It looks like you hoped that hiding the array type behind a typedef-name will let you work around this limitation. It won't. Your </p>\n<pre><code>void fun(Char10 a)\n</code></pre>\n<p>declaration is equivalent to </p>\n<pre><code>void fun(char a[10])\n</code></pre>\n<p>declaration, which is in turn equivalent to </p>\n<pre><code>void fun(char a[])\n</code></pre>\n<p>and to</p>\n<pre><code>void fun(char *a)\n</code></pre>\n<p>So, your <code>a</code> parameter has pointer type. When you pass an array like that</p>\n<pre><code>char a[10]; fun(a); \n</code></pre>\n<p>you are simply passing a <code>char *</code> pointer to the first element of the array. The size of the array does not matter, which is why you are able to pass arrays of different sizes using this method.</p>\n<p>Inside the <code>fun</code> function, if you want to analyze the type of parameter <code>a</code>, you are supposed to apply <code>typeid</code> to <code>a</code> </p>\n<pre><code>if(typeid(a) == typeid(char*))\n  throw 0;\n</code></pre>\n<p>This will show you that the types match. Why you are applying the <code>typeid</code> directly to <code>Char10</code> and what you are expecting to derive from it is not clear to me. Array types decay to pointer types in function parameter declaration, but they don't decay to pointer types in <code>typed</code> operator, meaning that your version of <code>if</code> is absolutely unrelated to what happens in parameter declaration.</p>\n", "LastActivityDate": "2011-05-17T16:42:27.747", "CommentCount": "4", "CreationDate": "2011-05-17T16:42:27.747", "ParentId": "6033970", "Score": "0", "OwnerUserId": "187690"}, "6034056": {"Id": "6034056", "PostTypeId": "2", "Body": "<p>In both cases, the arrays <em>decay</em> to the pointer type, and your function is <em>actually</em> this:</p>\n<pre><code>void fun (char *a); \n</code></pre>\n<p>That is why its working. </p>\n<p>I would like to emphasize that <code>void fun(char*)</code> is exactly same as <code>void fun(char[10])</code>. The <code>10</code> doesn't make any difference at all. In fact, <code>10</code> is so unimportant and useless that you can even omit it completely as:</p>\n<pre><code>void fun (char a[]); //exactly same as `char*` or `char[10]`.\n</code></pre>\n<p>That means, <strong>all</strong> the following function declarations are <em>exactly</em> same:</p>\n<pre><code>void fun(char a[10]);   \nvoid fun(char a[]);  //10 is unimportant in the above declaration\nvoid fun(char *a);   //same as above two declarations!\n</code></pre>\n<p>Hope that clarifies your doubt.</p>\n<hr>\n<p>However, if you write this:</p>\n<pre><code>void fun (Char10 &amp; a) ; //note &amp;\n</code></pre>\n<p>then, its actually this:</p>\n<pre><code>void fun (char (&amp;a)[10]) ; //equivalent!\n</code></pre>\n<p>Then <code>fun(b)</code> wouldn't compile, as now <code>fun</code> will accept ONLY array of EXACTLY size 10. And the array will <strong>not</strong> decay to <em>pointer</em>, it will be passed by <em>reference</em>. </p>\n<pre><code>char a[10], b[11];\nchar *c=new char[10];\nfun(a); //okay\nfun(b); //error - type mismatch due to size of the array\nfun(c); //error - type mismatch due to c being pointer.\n</code></pre>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2012-03-29T06:39:12.227", "Score": "21", "CreationDate": "2011-05-17T16:27:24.903", "ParentId": "6033970", "CommentCount": "5", "OwnerUserId": "415784", "LastEditDate": "2012-03-29T06:39:12.227"}, "9919672": {"Id": "9919672", "PostTypeId": "2", "Body": "<pre><code>struct char10 {\n    char c[10];\n};\n\nint foo(char10 param){\n...\n</code></pre>\n<p>You can emulate passing fixed-size arrays by value like this.</p>\n", "LastEditorUserId": "771663", "LastActivityDate": "2012-10-29T07:50:31.857", "Score": "1", "CreationDate": "2012-03-29T05:40:22.097", "ParentId": "6033970", "CommentCount": "0", "OwnerUserId": "1299912", "LastEditDate": "2012-10-29T07:50:31.857"}, "6034027": {"Id": "6034027", "PostTypeId": "2", "Body": "<p>They are different types, you're right.</p>\n<p>It's a misleading quirk of C++ that you can be seen to have a function</p>\n<pre><code>void fun(char a[10])\n</code></pre>\n<p>Since you cannot pass arrays by value, and C++ is silly, this is <em>actually</em> the function</p>\n<pre><code>void fun(char* a)\n</code></pre>\n<p>And, of course, both inputs degrade happily to <code>char*</code>.</p>\n<p>It would be nice if C++ did not let you even pretend to accept an array by value, but it is silly in this way.. inherited from C.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2012-10-29T10:00:19.393", "Score": "9", "CreationDate": "2011-05-17T16:25:04.750", "ParentId": "6033970", "CommentCount": "6", "OwnerUserId": "560648", "LastEditDate": "2012-10-29T10:00:19.393"}, "6033970": {"ViewCount": "6216", "Body": "<p>I am having hard time understanding <code>typedef</code> pattern for arrays.</p>\n<pre><code>typedef char Char10[10];\nvoid fun (Char10 a)  // not passing reference (interested in pass by value)\n{\n  if(typeid(Char10) == typeid(char*))\n    throw 0;  // &lt;--- never happens\n}\n\nint main ()\n{\n  char a[10];  fun(a);  // ok\n  char b[11];  fun(b);  // why works ?\n}\n</code></pre>\n<p>Why the different sizes of array by value are accepted by <code>fun()</code> ? Are <code>char[10]</code> and <code>char[11]</code> not different types ?</p>\n<p><strong>Edit</strong>: For those who says it decays to pointer, see my edited code. <code>char[10]</code> and <code>char*</code> doesn't seem to match.</p>\n", "AcceptedAnswerId": "6034027", "Title": "passing typedef (fixed sized) array by value", "CreationDate": "2011-05-17T16:21:13.497", "Id": "6033970", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-05-17T16:32:11.153", "LastEditorUserId": "514235", "LastActivityDate": "2012-10-29T10:00:19.393", "Score": "4", "OwnerUserId": "514235", "Tags": "<c++><arrays><typedef>", "AnswerCount": "8"}});