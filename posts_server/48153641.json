post_cb({"bq_ids": {"n4140": {"so_48153641_48176214_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6353}}, "n3337": {"so_48153641_48176214_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6110}}, "n4659": {"so_48153641_48153641_0": {"length": 20, "quality": 0.8, "section_id": 1340}, "so_48153641_48176214_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7862}}}, "48176214": {"Id": "48176214", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48153641_48176214_0\"><a href=\"http://eel.is/c++draft/res.on.data.races#8\" rel=\"nofollow noreferrer\"><strong>[res.on.data.races]/8</strong></a> Unless otherwise specified, C++ standard library functions shall perform all operations solely within the current thread if those operations have effects that are visible (4.7) to users.</p>\n</blockquote>\n<p>This precludes any kind of behind-the-scenes multithreading that touches any user-defined entities.</p>\n<p>I suppose, in principle, something like <code>std::sort</code> working on a <code>vector&lt;int&gt;</code> can prove that no user-defined class is involved, and send work to multiple threads. That's rather far-fetched, it's difficult to imagine any implementation doing this in practice.</p>\n", "LastActivityDate": "2018-01-09T20:30:19.670", "Score": "3", "CreationDate": "2018-01-09T20:30:19.670", "ParentId": "48153641", "CommentCount": "0", "OwnerUserId": "1670129"}, "48153641": {"ViewCount": "154", "Body": "<p>In C++17 parallel std algorithms were introduced (overloads with ExecutionPolicy arguments), where strict rules of execution order, interleaving and paralelization were defined, for example ([algorithm.parallel.exec/3]):</p>\n<blockquote>\n<p id=\"so_48153641_48153641_0\">The invocations of element access functions in parallel algorithms invoked with an execution policy object of\n  type execution::sequenced_policy all occur in the calling thread of execution. [ Note: The invocations are not interleaved; see 4.6. \u2014 end note ]</p>\n</blockquote>\n<p>(same thing in <a href=\"http://eel.is/c++draft/algorithms.parallel#exec-4\" rel=\"noreferrer\">current draft</a>)</p>\n<p>The problem is that I can't find any such requirement for old, non-parallel overloads of these algorithms.</p>\n<p><strong>Question:</strong> Can this mean that library implementers can, since C++11 when <em>thread of execution</em> term was introduced, implement std::transform and std::generate using SIMD/multithreading/other(?)? Is there a reason for that?</p>\n", "AcceptedAnswerId": "48176214", "Title": "Can std::transform or std::generate without ExecutionPolicy be parallel?", "CreationDate": "2018-01-08T15:47:53.413", "Id": "48153641", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2018-01-09T20:30:19.670", "Score": "6", "OwnerUserId": "8556993", "Tags": "<c++><c++11><language-lawyer><c++17>", "AnswerCount": "1"}});