post_cb({"bq_ids": {"n4140": {"so_11336507_11373917_0": {"length": 16, "quality": 0.8, "section_id": 56}, "so_11336507_11373917_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 5412}, "so_11336507_11373917_2": {"length": 14, "quality": 0.875, "section_id": 184}, "so_11336507_11373917_4": {"length": 15, "quality": 0.75, "section_id": 110}}, "n3337": {"so_11336507_11373917_0": {"length": 16, "quality": 0.8, "section_id": 51}, "so_11336507_11373917_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 5207}, "so_11336507_11373917_2": {"length": 14, "quality": 0.875, "section_id": 178}, "so_11336507_11373917_4": {"length": 15, "quality": 0.75, "section_id": 105}}, "n4659": {"so_11336507_11373917_0": {"length": 14, "quality": 0.7, "section_id": 58}, "so_11336507_11373917_1": {"length": 10, "quality": 0.7692307692307693, "section_id": 6834}, "so_11336507_11373917_2": {"length": 14, "quality": 0.875, "section_id": 189}, "so_11336507_11373917_4": {"length": 15, "quality": 0.75, "section_id": 114}}}, "11336507": {"ViewCount": "1257", "Body": "<p>My first code fragment compiles and works fine:</p>\n<pre><code>template &lt;class x&gt; struct B1\n{\n    template &lt;class x&gt; struct B2     { int getX() { return(16); } };\n    template &lt;class x&gt; struct B2&lt;x*&gt; { int getX() { return(20); } };\n};\n\nvoid main(int argc, char* argv[])\n{\n    B1&lt;int&gt;::B2&lt;int&gt;  a1;\n    B1&lt;int&gt;::B2&lt;int*&gt; a2;\n    printf(\"a1=%d, a2=%d.\\r\\n\", a1.getX(), a2.getX());\n}\n</code></pre>\n<p>Note that the name of template param is <code>x</code> in both templates and this is not confusing the compiler. The second example fails with the compiler crash (MSVC 2008), i.e. without giving any syntax error:</p>\n<pre><code>template &lt;class x&gt; struct B1\n{\n    template &lt;class x&gt; struct B2 { int getX() { return(16); } };\n    template &lt;class x&gt; struct B2&lt;x*&gt;;\n};\n\ntemplate &lt;class x&gt; template &lt;class x&gt;\nstruct B1&lt;x&gt;::B2&lt;x*&gt;\n{\n    int getX() { return(3); }\n};\n</code></pre>\n<p>My question is <strong>not on how to fix this example</strong>, this is obvious.</p>\n<p>I looked in the standard (C++2003) on the rules of accessing params of template headers and I cannot find anything relevant. Maybe I am missing something.</p>\n<p>While processing <code>B1&lt;x&gt;</code>, should compiler consider only params from the first template header? More likely yes. Then while processing <code>B2&lt;x&gt;</code>, should it consider both? More complex case is especially interesting when params of B1/B2 contain qualified identifiers themselves and these identifiers want to access params of the template header. For simplicity I am not giving the full example for this.</p>\n<p>If anybody came across this and can comment or know some artickles/books, YouTube videos, etc, I would love to hear this.</p>\n<p><strong>UPDATE</strong>: I just tried the following with MSVC:</p>\n<pre><code>template &lt;class x&gt; struct B1\n{\n    x qq1;\n\n    struct B2\n    {\n        int x;\n    };\n};\n</code></pre>\n<p>This compiles and works as expected. I also tried an exe that accesses the inner data field <code>x</code>. This shows that MS compiler implemented hiding template params in the inner scopes. For me this is logical even if this does not comply with the standard.</p>\n", "AcceptedAnswerId": "11373917", "Title": "Accessing template parameters of the member templates", "CreationDate": "2012-07-05T00:03:37.867", "Id": "11336507", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-01-12T04:53:08.290", "LastEditorUserId": "1459996", "LastActivityDate": "2016-01-12T04:55:43.813", "Score": "2", "OwnerUserId": "1459996", "Tags": "<c++><templates><template-specialization>", "AnswerCount": "1"}, "11373917": {"Id": "11373917", "PostTypeId": "2", "Body": "<p>Although the question has been considered answered by the comments, I'll provide some further details below. Note that my answer is based on C++11 (ISO/IEC 14882-2011) only.</p>\n<p><strong>Part 1: Can a template parameter be re-used as template-parameter of a nested member template?</strong></p>\n<p>There are two key statements in the standard about the <strong>status of template parameters</strong> (specifically, type-parameters \u2013 which are the only kind relevant to the question). The <strong>first statement</strong> describes them as having the same status as <strong>typedef-names</strong>:</p>\n<blockquote>\n<p id=\"so_11336507_11373917_0\">(\u00a714.1/3) A type-parameter whose identi\ufb01er does not follow an ellipsis de\ufb01nes its identi\ufb01er to be a typedef-name (if declared with class or typename) or template-name (if declared with template) in the scope of the template declaration. [...]</p>\n</blockquote>\n<p>And regarding the possible redeclaration of typedef-names, we have:</p>\n<blockquote>\n<p id=\"so_11336507_11373917_1\">(\u00a77.1.3/6) In a given scope, a typedef speci\ufb01er shall not be used to rede\ufb01ne the name of any type declared in that scope to refer to a different type. [...]</p>\n</blockquote>\n<p><em>(Remark: The rule above seems to apply to the use of typedef specifiers only, although alias declarations (\u00a77.1.3/2) and template parameter declarations (\u00a714.1/3) can be used to declare typedef-names as well. That is, the rule above does not explicitly rule out the use of an alias declaration or indeed a template parameter to redeclare a typedef-name within the same scope, although that is clearly the intended meaning. The wording should be \"no typedef-name declaration shall be used\" instead of \"a typedef specifier shall not be used\".)</em></p>\n<p>What it means is that you cannot do this:</p>\n<pre><code>{\n  typedef int   T;\n  typedef float T;\n}\n</code></pre>\n<p>because the second declaration occurs in the same scope in which <code>T</code> was originally declared. However, this:</p>\n<pre><code>{\n  typedef int   T;\n  {\n    typedef float T;\n  }\n}\n</code></pre>\n<p>is perfectly legally according to the rule above, because the second declaration is in a block scope which (although the first <code>T</code> is still valid there) is not the scope in which <code>T</code> was originally declared.</p>\n<p>Due to \u00a714.1/3 quoted above, we must assume that the rule applies to template parameter declarations as well, hence something like</p>\n<pre><code>template &lt;typename X&gt; template &lt;typename X&gt;\nstruct Outer&lt;X&gt;::Inner&lt;X&gt; {\n\n};\n</code></pre>\n<p>is illegal even on the simple basis that it implies the declaration of the same typedef-name twice within the same scope.</p>\n<p>However, in a case like</p>\n<pre><code>template &lt;typename X&gt;\nstruct Outer {\n\n  template &lt;typename X&gt;\n  struct Inner {\n  };\n\n};\n</code></pre>\n<p>one may argue that the second declaration of <code>template &lt;typename X&gt;</code> applies to a nested scope. Fortunately, the standard does provide the following <strong>second statement</strong> about the status of template parameters:</p>\n<blockquote>\n<p id=\"so_11336507_11373917_2\">(\u00a714.6.1/6) A template-parameter shall not be redeclared within its scope (including nested scopes). A template-parameter shall not have the same name as the template name.\n  [Example:</p>\n</blockquote>\n<pre><code>template&lt;class T, int i&gt; class Y {\n  int T; // error: template-parameter redeclared\n\n  void f() {\n    char T; // error: template-parameter redeclared\n  }\n};\n\ntemplate&lt;class X&gt; class X; // error: template-parameter redeclared\n</code></pre>\n<blockquote>\n<p id=\"so_11336507_11373917_3\">\u2014 end example ]</p>\n</blockquote>\n<p>As clearly stated, the no-redeclaration rule that applies to any typedef-name within the declaration scope, applies to <strong>nested scopes</strong> as well in the case of template parameters.</p>\n<p>Here is an example to motivate why I think that rule is actually useful, too. Consider:</p>\n<pre><code>template &lt;typename T1&gt;\nstruct Outer\n{\n  static const int outerID = 5;\n\n  template &lt;typename T2&gt;\n  struct Inner\n  {\n    int id1() { return Outer&lt;T1&gt;::outerID; }\n    int id2() { return Outer::outerID; }\n    int id3() { return outerID; }\n  };\n};\n</code></pre>\n<p>The three functions of the inner template all refer to the same static member of the outer class, but in three different ways. <code>id2()</code> and <code>id3()</code> do this because \u00a714.6.2.1/4 requires <code>Outer::outerID</code> and <code>outerID</code> to be interpreted as referring to the <em>current instantiation</em>, which is <code>Outer&lt;T1&gt;::outerID</code>.</p>\n<p>If we now replace the template parameter of the inner template with <code>T1</code>, the same as for the outer template, the meaning of <code>id1()</code> would change (because <code>Outer&lt;T1&gt;</code> would now refer to whatever the definition of <code>T1</code> in the inner template is), but <code>id2()</code> and <code>id3()</code> would \u2013 most naturally \u2013 still refer to the current instantiation of the template <code>outerID</code> belongs to. Therefore, <code>id1()</code> may return a different value than <code>id2()</code> and <code>id3()</code>, which would be most awkward.</p>\n<p><strong>Part 2: In a partial specialization of a member template, can template parameters of the member be used as template arguments of the enclosing class, and vice versa?</strong></p>\n<p>Another problem addressed by the question is whether in a specialization or outside-of-class definition of a member template, such as</p>\n<pre><code>template &lt;typename A&gt; template &lt;typename B&gt;\nstruct Outer&lt;A&gt;::Inner&lt;B&gt; {\n  // ...\n};\n</code></pre>\n<p>the template argument list of the outer template (i.e. <code>&lt;A&gt;</code> in this case) could make use of parameters defined for the inner template (i.e. <code>B</code> in this case), and vice versa.</p>\n<p>Let's first consider the special case given in the question, where the two parameters are identical:</p>\n<pre><code>template &lt;typename A&gt; template &lt;typename A&gt;\nstruct Outer&lt;A&gt;::Inner&lt;A&gt; {\n  // ...\n};\n</code></pre>\n<p>Although we have ruled this out in Part 1 already due to the re-declaration problem, we can still consider the <em>intended meaning</em> of this syntax, which is: Define an explicit specialization of the inner class template, in which the template argument is assumed to be same as for the outer template. The syntactically correct way to write that is</p>\n<pre><code>template &lt;typename A&gt; template &lt;&gt;\nstruct Outer&lt;A&gt;::Inner&lt;A&gt; {\n  // ...\n};\n</code></pre>\n<p>i.e. the second parameter list would be empty. Unfortunately, this would amount to an <em>explicit specialization</em> of a member template, which is illegal unless the enclosing template is also explicitly specialised (\u00a714.7.3/16).</p>\n<p>However, if we consider a partial, rather than an explicit specialization of a member template with two or more parameters, the declaration becomes legal:</p>\n<pre><code>// Primary declaration\ntemplate &lt;typename A&gt;\nstruct Outer {\n  template &lt;typename A, typename B&gt;\n  struct Inner {\n    // ...\n  };\n};\n\n// Partial specialization of member template\ntemplate &lt;typename A&gt; template &lt;typename B&gt;\nstruct Outer&lt;A&gt;::Inner&lt;B,A&gt; {\n  // ...\n};\n</code></pre>\n<p>We have now used the template argument <code>A</code> of the enclosing template as specialised second argument for the inner template as well. Any instantiation of the template that uses the same data type for the template argument of the outer class as well as the second template argument of the inner class, e.g.</p>\n<pre><code>Outer&lt;int&gt;::Inner&lt;float,int&gt; myvar;\n</code></pre>\n<p>will instantiate the specialization defined above.</p>\n<p>Hence, using template parameters of an enclosing class in the template argument list of a member template is without problems, and the reason is that by the time <code>Inner&lt;B,A&gt;</code> is evaluated, <code>A</code> already has the status of a typedef-name defined at the scope level of <code>Outer</code>.</p>\n<p>But doing it reversely, e.g.</p>\n<pre><code>template &lt;typename A&gt; template &lt;typename B&gt;\nstruct Outer&lt;B&gt;::Inner&lt;B,A&gt; {\n  // ...\n};\n</code></pre>\n<p>will not work, because <code>B</code> is a typedef-name of the <code>Inner</code> scope only. The Standard states:</p>\n<blockquote>\n<p id=\"so_11336507_11373917_4\">(\u00a714.5.2/1) [...] A member template of a class template that is de\ufb01ned outside of its class template de\ufb01nition shall be speci\ufb01ed with the template-parameters of the class template followed by the template-parameters of the member template.\n  [Example:</p>\n</blockquote>\n<pre><code>    template&lt;class T&gt; struct string {\n      template&lt;class T2&gt; int compare(const T2&amp;);\n      template&lt;class T2&gt; string(const string&lt;T2&gt;&amp; s) { /\u2217 ... \u2217/ }\n    };\n    template&lt;class T&gt; template&lt;class T2&gt; int string&lt;T&gt;::compare(const T2&amp; s) {\n    }\n</code></pre>\n<blockquote>\n<p id=\"so_11336507_11373917_5\">\u2014 end example ]</p>\n</blockquote>\n<p>I interpret this to mean that the two template parameter lists (<em>one followed by the other</em>) are kept separately, not considered as one combined list of template parameters. Hence in</p>\n<pre><code>template &lt;typename A&gt; template &lt;typename B&gt;\nstruct Outer&lt;B&gt;::Inner&lt;B,A&gt;\n</code></pre>\n<p>the interpretation of <code>Outer&lt;B&gt;</code> cannot make use of the second template parameter list, and <code>B</code> will be undefined, whereas in the previous case</p>\n<pre><code>template &lt;typename A&gt; template &lt;typename B&gt;\nstruct Outer&lt;A&gt;::Inner&lt;B,A&gt;\n</code></pre>\n<p>the interpretation of <code>Inner&lt;B,A&gt;</code> is possible because <code>A</code> has the status of a typedef-name <strong>declared in a scope that <code>Inner</code> is part of</strong>, i.e. it will be successfully interpreted as <code>Inner&lt;B,Outer::A&gt;</code>, which in turn is the same as <code>Inner&lt;B,Outer&lt;A&gt;::A&gt;</code>.</p>\n", "LastEditorUserId": "1459996", "LastActivityDate": "2016-01-12T04:55:43.813", "Score": "4", "CreationDate": "2012-07-07T09:41:46.293", "ParentId": "11336507", "CommentCount": "1", "OwnerUserId": "777186", "LastEditDate": "2016-01-12T04:55:43.813"}});