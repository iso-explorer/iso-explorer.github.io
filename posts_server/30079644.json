post_cb({"30080040": {"ParentId": "30079644", "CommentCount": "4", "Body": "<p>In C++11, the code is well-defined, but may not do what you expect. The exact effects are, as per 21.4.5/2:</p>\n<blockquote>\n<p id=\"so_30079644_30080040_0\"><em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value\n  <code>charT()</code>; the referenced value shall not be modified.</p>\n</blockquote>\n<p>So if the string is non-empty, it returns a reference to the internal buffer's start. If it's empty, it returns a reference to a <code>char</code> with value <code>0</code>, whose location is memory is an implementation details.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "30080040", "Score": "7", "CreationDate": "2015-05-06T14:43:45.040", "LastActivityDate": "2015-05-06T14:43:45.040"}, "30080050": {"ParentId": "30079644", "CommentCount": "2", "Body": "<p>I think this will give you an address somewhere on your stack. Due to the small-string optimization in most implementations.</p>\n<p><a href=\"http://www.cplusplus.com/reference/string/string/operator[]/\" rel=\"nofollow\">http://www.cplusplus.com/reference/string/string/operator[]/</a> says:</p>\n<blockquote>\n<p id=\"so_30079644_30080050_0\">If pos is equal to the string length, the function returns a reference to the null character that follows the last character in the string, which shall not be modified.</p>\n</blockquote>\n<p>You may get problems in form of undefined behavior as soon as your index-parameter is greater than the size of string.</p>\n", "OwnerUserId": "3017079", "PostTypeId": "2", "Id": "30080050", "Score": "0", "CreationDate": "2015-05-06T14:44:01.923", "LastActivityDate": "2015-05-06T14:44:01.923"}, "bq_ids": {"n4140": {"so_30079644_30080040_0": {"section_id": 1617, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_30079644_30080040_0": {"section_id": 1613, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_30079644_30080040_0": {"section_id": 1770, "quality": 0.7142857142857143, "length": 10}}}, "30079644": {"CommentCount": "2", "ViewCount": "87", "PostTypeId": "1", "LastEditorUserId": "1514922", "CreationDate": "2015-05-06T14:26:58.477", "LastActivityDate": "2015-05-06T14:44:01.923", "Title": "C++ string's internal buffer address undefined behaviour", "AcceptedAnswerId": "30080040", "LastEditDate": "2015-05-06T14:39:52.177", "Id": "30079644", "Score": "3", "Body": "<p>Is the following undefined behaviour under c++11 standard:</p>\n<p>(trying to get the address of the internal buffer of a string)</p>\n<pre><code>std::string s;\n... = &amp;s[0];\n</code></pre>\n<p>for example when <code>s</code> is empty?</p>\n<p>I know that we have <code>c_str(), data()</code>, but nevertheless.</p>\n<h2>Note</h2>\n<p>this is coming from a debate with someone, this is not intended to promote hacky coding</p>\n", "Tags": "<c++11>", "OwnerUserId": "1514922", "AnswerCount": "2"}});