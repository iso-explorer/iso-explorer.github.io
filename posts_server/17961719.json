post_cb({"17961719": {"CommentCount": "2", "AcceptedAnswerId": "17961890", "CreationDate": "2013-07-31T04:38:06.030", "LastActivityDate": "2013-07-31T05:30:34.303", "PostTypeId": "1", "ViewCount": "2911", "FavoriteCount": "16", "Title": "Overload resolution between object, rvalue reference, const reference", "Id": "17961719", "Score": "53", "Body": "<p>Given all three functions, this call is ambiguous.</p>\n<pre><code>int f( int );\nint f( int &amp;&amp; );\nint f( int const &amp; );\n\nint q = f( 3 );\n</code></pre>\n<p>Removing <code>f( int )</code> causes both Clang and GCC to prefer the rvalue reference over the lvalue reference. But instead removing either reference overload results in ambiguity with <code>f( int )</code>.</p>\n<p>Overload resolution is usually done in terms of a strict partial ordering, but <code>int</code> seems to be equivalent to two things which are not equivalent to each other. What are the rules here? I seem to recall a defect report about this.</p>\n<p>Is there any chance <code>int &amp;&amp;</code> may be preferred over <code>int</code> in a future standard? The reference must bind to an initializer, whereas the object type is not so constrained. So overloading between <code>T</code> and <code>T &amp;&amp;</code> could effectively mean \"use the existing object if I've been given ownership, otherwise make a copy.\" (This is similar to pure pass-by-value, but saves the overhead of moving.) As these compilers currently work, this must be done by overloading <code>T const &amp;</code> and <code>T &amp;&amp;</code>, and explicitly copying. But I'm not even sure even that is strictly standard.</p>\n", "Tags": "<c++><c++11><overloading><rvalue-reference><c++14>", "OwnerUserId": "153285", "AnswerCount": "1"}, "17961890": {"ParentId": "17961719", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_17961719_17961890_0\">What are the rules here?</p>\n</blockquote>\n<p>As there is only one parameter, the rule is that one of the three viable parameter initializations of that parameter must be <strong>a better match</strong> than <strong>both</strong> the other two.  When two initializations are compared, either one is better than the other, or neither is better (they are indistinguishable).</p>\n<p>Without special rules about direct reference binding, all three initializations mentioned would be indistinguishable (in all three comparisons).</p>\n<p>The special rules about direct reference binding make <code>int&amp;&amp;</code> better than <code>const int&amp;</code>, but neither is better or worse than <code>int</code>.  Therefore there is no best match:</p>\n<pre><code>S1    S2\nint   int&amp;&amp;         indistinguishable\nint   const int&amp;    indistinguishable\nint&amp;&amp; const int&amp;    S1 better\n</code></pre>\n<p><code>int&amp;&amp;</code> is better than <code>const int&amp;</code> because of 13.3.3.2:</p>\n<blockquote>\n<p id=\"so_17961719_17961890_1\">S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.</p>\n</blockquote>\n<p>But this rule does not apply when one of the initializations is not a reference binding.</p>\n<blockquote>\n<p id=\"so_17961719_17961890_2\">Is there any chance int &amp;&amp; may be preferred over int in a future standard? The reference must bind to an initializer, whereas the object type is not so constrained. So overloading between T and T &amp;&amp; could effectively mean \"use the existing object if I've been given ownership, otherwise make a copy.\"</p>\n</blockquote>\n<p>You propose to make a reference binding a better match than a non-reference binding.   Why not post your idea to <a href=\"https://groups.google.com/a/isocpp.org/forum/?fromgroups#!forum/std-proposals\" rel=\"noreferrer\">isocpp future proposals</a>.  SO is not the best for subjective discussion / opinion.</p>\n", "OwnerUserId": "1131467", "LastEditorUserId": "1131467", "LastEditDate": "2013-07-31T05:30:34.303", "Id": "17961890", "Score": "42", "CreationDate": "2013-07-31T04:54:59.843", "LastActivityDate": "2013-07-31T05:30:34.303"}, "bq_ids": {"n4140": {"so_17961719_17961890_1": {"section_id": 639, "quality": 0.95, "length": 19}}, "n3337": {"so_17961719_17961890_1": {"section_id": 629, "quality": 0.95, "length": 19}}, "n4659": {"so_17961719_17961890_1": {"section_id": 667, "quality": 0.95, "length": 19}}}});