post_cb({"bq_ids": {"n4140": {"so_7006202_7006249_9": {"length": 27, "quality": 0.9310344827586207, "section_id": 389}, "so_7006202_7006249_7": {"length": 15, "quality": 0.6521739130434783, "section_id": 388}, "so_7006202_7006249_1": {"length": 11, "quality": 0.5238095238095238, "section_id": 3294}, "so_7006202_7006249_2": {"length": 19, "quality": 0.6785714285714286, "section_id": 3296}}, "n3337": {"so_7006202_7006249_9": {"length": 27, "quality": 0.9310344827586207, "section_id": 380}, "so_7006202_7006249_2": {"length": 19, "quality": 0.6785714285714286, "section_id": 3166}, "so_7006202_7006249_1": {"length": 11, "quality": 0.5238095238095238, "section_id": 3164}, "so_7006202_7006249_7": {"length": 15, "quality": 0.6521739130434783, "section_id": 379}}, "n4659": {"so_7006202_7006249_9": {"length": 27, "quality": 0.9310344827586207, "section_id": 406}, "so_7006202_7006249_2": {"length": 19, "quality": 0.6785714285714286, "section_id": 4058}, "so_7006202_7006249_1": {"length": 11, "quality": 0.5238095238095238, "section_id": 4056}, "so_7006202_7006249_7": {"length": 15, "quality": 0.6521739130434783, "section_id": 405}}}, "7006202": {"ViewCount": "335", "Body": "<p>In the following code, I expect <em>A</em>'s constructor is called, followed by <em>A</em>'s copy constructor. However, It turns out only constructor is get called.</p>\n<pre><code>// MSVC++ 2008\nclass A\n{\npublic:\n   A(int i):m_i(i)\n   {\n      cout &lt;&lt; \"constructor\\n\";\n   }\n   A(const A&amp; a)\n   {\n      m_i = a.m_i;\n      cout &lt;&lt; \"copy constructor\\n\";\n   }\n\nprivate:\n   int m_i;\n};\n\nint main()\n{\n   // only A::A() is called\n   A a = 1;\n   return 0;\n}\n</code></pre>\n<p>I guess the compiler is smart enough to optimize away the second call, to initialize the object <em>a</em> directly with the constructor. So is it a standard-defined behavior or just implementation-defined?</p>\n", "AcceptedAnswerId": "7006249", "Title": "Compiler optimization of implicit constructor conversion", "CreationDate": "2011-08-10T05:15:12.560", "Id": "7006202", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-08-10T06:11:56.657", "Score": "2", "OwnerUserId": "419391", "Tags": "<c++><constructor><implicit-conversion>", "AnswerCount": "2"}, "7006243": {"Id": "7006243", "PostTypeId": "2", "Body": "<p>No optimization here.  When <code>=</code> is used in the initialization, it is eqivalent(nearly) to calling the constructor with the right hand side as an argument.  So this:</p>\n<pre><code>A a = 1;\n</code></pre>\n<p>Is (mostly) equivalent to this:</p>\n<pre><code>A a(1);\n</code></pre>\n", "LastActivityDate": "2011-08-10T05:22:09.620", "CommentCount": "1", "CreationDate": "2011-08-10T05:22:09.620", "ParentId": "7006202", "Score": "2", "OwnerUserId": "440119"}, "7006249": {"Id": "7006249", "PostTypeId": "2", "Body": "<p><strike>It's standard, but there's no optimization involved.</strike></p>\n<p>Actually, I believe there is an optimization involved, but it's still entirely standard.<sup>\u2020</sup></p>\n<p>This code:</p>\n<pre><code>A a = 1;\n</code></pre>\n<p>invokes the <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=%2Fcom.ibm.vacpp7a.doc%2Flanguage%2Fref%2Fclrc15cplr384.htm\" rel=\"nofollow\">converting constructor</a><sup>\u2020\u2020</sup> of <code>A</code>. <code>A</code> has a single converting constructor <code>A(int i)</code> that allows an <em>implicit conversion</em> from <code>int</code> to <code>A</code>.</p>\n<p>If you prepend the constructor declaration with <code>explicit</code>, you'll find the code won't compile.</p>\n<pre><code>class A\n{\npublic:\n    explicit A(int i) : m_i(i) // Note \"explicit\"\n    {\n        cout &lt;&lt; \"constructor\\n\";\n    }\n\n    A(const A&amp; a)\n    {\n        m_i = a.m_i;\n        cout &lt;&lt; \"copy constructor\\n\";\n    }\n\nprivate:\n    int m_i;\n};\n\nvoid TakeA(A a)\n{\n}\n\nint main()\n{\n    A a = 1;     // Doesn't compile\n    A a(1);      // Does compile\n    TakeA(1);    // Doesn't compile\n    TakeA(A(1)); // Does compile\n    return 0;\n}\n</code></pre>\n<hr>\n<p>\u2020 After looking at the standard again, I may have been initially wrong.</p>\n<blockquote>\n<p id=\"so_7006202_7006249_0\"><strong>8.5 Initializers [dcl.init]</strong></p>\n<p id=\"so_7006202_7006249_1\"><em>12.</em> The initialization that occurs in argument passing, function\n  return, throwing an exception (15.1), handling an exception (15.3),\n  and brace-enclosed initializer lists (8.5.1) is called\n  <em>copy-initialization</em> and is equivalent to the form</p>\n<pre><code>   T x = a;\n</code></pre>\n<p id=\"so_7006202_7006249_2\"><em>14.</em> The semantics of initializers are as follows. The <em>destination</em>\n  type is the type of the object or reference being initialized and the\n  <em>source</em> type is the type of the initializer expression. The source type\n  is not defined when the initializer is brace-enclosed or when it is a\n  parenthesized list of expressions.</p>\n<p id=\"so_7006202_7006249_3\">...</p>\n<ul>\n<li>If the destination type is a (possibly cv-qualified) class type:\n  <ul>\n<li>If the class is an aggregate (8.5.1), and the initializer is a brace-enclosed list, see 8.5.1.</li>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression(s) as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed. The function selected is called with the initializer expression as its argument; <strong>if the function is a constructor, the call initializes a temporary of the destination type. The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization. In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized</strong>; see 12.2, 12.8.</li>\n</ul></li>\n</ul>\n<p id=\"so_7006202_7006249_4\">...</p>\n</blockquote>\n<p>So in one sense it is very much an optimization. But I wouldn't worry about it since it is explicitly allowed by the standard and just about every compiler nowadays does the elison.</p>\n<p>For a much more thorough treatment on initialization, see <a href=\"http://www.gotw.ca/gotw/036.htm\" rel=\"nofollow\">this GotW article (#36)</a>. The article seems to agree with the above interpretation of the standard:</p>\n<blockquote>\n<p id=\"so_7006202_7006249_5\">NOTE: In the last case (\"T t3 = u;\") the compiler could call both the\n  user-defined conversion (to create a temporary object) and the T copy\n  constructor (to construct t3 from the temporary), or it could choose\n  to elide the temporary and construct t3 directly from u (which would\n  end up being equivalent to \"T t3(u);\"). Since July 1997 and in the\n  final draft standard, the compiler's latitude to elide temporary\n  objects has been restricted, but it is still allowed for this\n  optimization and for the return value optimization.</p>\n</blockquote>\n<p>\u2020\u2020 <h3>ISO/IEC 14882:2003 C++ Standard reference</h3></p>\n<blockquote>\n<p id=\"so_7006202_7006249_6\"><strong>12.3.1 Conversion by constructor [class.conv.ctor]</strong></p>\n<p id=\"so_7006202_7006249_7\"><em>1.</em> A constructor declared without the <em>function-specifier</em> <code>explicit</code>\n  that can be called with a single parameter specifies a conversion from\n  the type of its first parameter to the type of its class. Such a\n  constructor is called a converting constructor. <em>[Example:</em></p>\n<pre><code>     class X {\n         // ...\n     public:\n         X(int);\n         X(const char*, int =0);\n     };\n\n     void f(X arg)\n     {\n         X a = 1;        // a = X(1)\n         X b = \"Jessie\"; // b = X(\"Jessie\",0)\n         a = 2;          // a = X(2)\n         f(3);           // f(X(3))\n     }\n</code></pre>\n<p id=\"so_7006202_7006249_8\"><em>\u2014end example]</em></p>\n<p id=\"so_7006202_7006249_9\"><em>2.</em> An explicit constructor constructs objects just like non-explicit\n  constructors, but does so only where the direct-initialization syntax\n  (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default\n  constructor may be an explicit constructor; such a constructor will be\n  used to perform default-initialization or valueinitialization (8.5).\n  <em>[Example:</em></p>\n<pre><code>     class Z {\n     public:\n         explicit Z();\n         explicit Z(int);\n         // ...\n     };\n\n     Z a;                      // OK: default-initialization performed\n     Z a1 = 1;                 // error: no implicit conversion\n     Z a3 = Z(1);              // OK: direct initialization syntax used\n     Z a2(1);                  // OK: direct initialization syntax used\n     Z* p = new Z(1);          // OK: direct initialization syntax used\n     Z a4 = (Z)1;              // OK: explicit cast used\n     Z a5 = static_cast&lt;Z&gt;(1); // OK: explicit cast used\n</code></pre>\n<p id=\"so_7006202_7006249_10\"><em>\u2014end example]</em></p>\n</blockquote>\n</hr>", "LastEditorUserId": "308661", "LastActivityDate": "2011-08-10T06:11:56.657", "Score": "6", "CreationDate": "2011-08-10T05:22:34.820", "ParentId": "7006202", "CommentCount": "1", "OwnerUserId": "308661", "LastEditDate": "2011-08-10T06:11:56.657"}});