post_cb({"bq_ids": {"n4140": {"so_46263697_46263908_2": {"length": 10, "quality": 1.0, "section_id": 7193}, "so_46263697_46263908_1": {"length": 67, "quality": 0.9178082191780822, "section_id": 7193}, "so_46263697_46263908_0": {"length": 40, "quality": 0.7547169811320755, "section_id": 7189}}, "n3337": {"so_46263697_46263908_2": {"length": 10, "quality": 1.0, "section_id": 6937}, "so_46263697_46263908_1": {"length": 63, "quality": 0.863013698630137, "section_id": 6937}, "so_46263697_46263908_0": {"length": 40, "quality": 0.7547169811320755, "section_id": 6933}}, "n4659": {"so_46263697_46263908_2": {"length": 10, "quality": 1.0, "section_id": 8702}, "so_46263697_46263908_1": {"length": 69, "quality": 0.9452054794520548, "section_id": 8702}, "so_46263697_46263908_0": {"length": 46, "quality": 0.8679245283018868, "section_id": 8697}}}, "46264086": {"Id": "46264086", "PostTypeId": "2", "Body": "<p>The code is really confusing. I'll try to explain the first part as I understand it. The intention definitely was to create a (structured) char buffer to send it over. This was probably initially created in <code>c</code>, or by a <code>c</code> programmer.</p>\n<pre><code> MessageHdr *msg;\n</code></pre>\n<p>this calculates size of the resulting send buffer</p>\n<pre><code> size_t msgsize = sizeof(MessageHdr) + sizeof(joinaddr-&gt;addr) + sizeof(long) + 1;\n</code></pre>\n<p>allocates the buffer. The cast is needed to allow c++ to compile it, otherwise it will error-out.</p>\n<pre><code> msg = (MessageHdr *) malloc(msgsize * sizeof(char));\n</code></pre>\n<p>This is used to set up a field in the buffer. Since it is of Type MessageHdr, it writes the value in  the correct place of the buffer</p>\n<pre><code>// create JOINREQ message: format of data is {struct Address myaddr}\nmsg-&gt;msgType = JOINREQ;\n</code></pre>\n<p>These commands use pointer arithmetic with (MessageHdr) type to write data in the buffer beyond the MessagHdr itself. <code>msg + 1</code> will skip the size of the MessageHdf in the char* buffer.</p>\n<pre><code>memcpy((char *)(msg+1), &amp;memberNode-&gt;addr.addr, sizeof(memberNode-&gt;addr.addr));\nmemcpy((char *)(msg+1) + 1 + sizeof(memberNode-&gt;addr.addr), &amp;memberNode-&gt;heartbeat, sizeof(long));\n</code></pre>\n<p>this will send the buffer by casting it to <code>char*</code> first, as a simple set of bytes.</p>\n<pre><code>emulNet-&gt;ENsend(&amp;memberNode-&gt;addr, joinaddr, (char *)msg, msgsize);\n</code></pre>\n<p>The receiving code seems to add yet  address header to the data to send it further (tcp-ip like)</p>\n<p>This allocates another buffer with the size of the <code>en_msg</code> header + size of the data.</p>\n<pre><code>em = (en_msg *)malloc(sizeof(en_msg) + size);\nem-&gt;size = size; // keeps data size in the en_msg struct\n</code></pre>\n<p>fills out address fields in the en_msg part of the buffer</p>\n<pre><code>memcpy(&amp;(em-&gt;from.addr), &amp;(myaddr-&gt;addr), sizeof(em-&gt;from.addr));\nmemcpy(&amp;(em-&gt;to.addr), &amp;(toaddr-&gt;addr), sizeof(em-&gt;from.addr));\n</code></pre>\n<p>and this copies the data in the buffer starting just beyond the en_msg header</p>\n<pre><code>memcpy(em + 1, data, size);\n</code></pre>\n<p>.</p>\n", "LastEditorUserId": "1143850", "LastActivityDate": "2017-09-17T13:08:26.397", "Score": "2", "CreationDate": "2017-09-17T12:30:16.590", "ParentId": "46263697", "CommentCount": "0", "LastEditDate": "2017-09-17T13:08:26.397", "OwnerUserId": "1143850"}, "46263965": {"Id": "46263965", "PostTypeId": "2", "Body": "<p>You didnt give details about <code>MessageHdr</code>, <code>Address</code> and <code>en_msg</code>. But some of them might be <code>struct</code>s, and not simple types.</p>\n<p>For the first question:\n<code>malloc</code> returns a <code>void*</code>, but in line 3 the allocated memory is assigned to a pointer of type <code>MessageHdr*</code>, thus the return value of <code>malloc</code> needs to be casted to the correct type.</p>\n<p>It is quite common to use <code>struct</code>s in this way, as it provides a simple way of dealing with lets say multiple variables of different type, which shall belong together (e. g. <code>Address</code> could be a <code>struct</code> with some <code>int</code> variable for the port, and a <code>char[]</code> for the hostname).</p>\n<p>Example:</p>\n<pre><code>struct Data\n{\n   int something;\n   char somethingElse[10];\n};\n\nvoid* foo = malloc(100);                  // allocate 100 bytes of memory\nvoid* bar = malloc(sizeof(struct Data));  // allocate a piece of memory with the size of struct Data\n\nData* data = (Data*)bar;                  // use the piece of memory\ndata-&gt;something = 10;                     // as Data struct\nstrcpy(data-&gt;something, \"bla\");\n</code></pre>\n<p>Note that of course you could use the piece of allocated memory in any way you want. E. g. in the above you could just do <code>memcpy(foo, someSource, 100)</code> to copy 100 bytes into the allocated buffer.</p>\n<p>In C++ you would use the <code>new</code> operator, which works slightly different. In addition to allocating memory for a given class, it would also call the classes constructor.</p>\n<p>For question 2:\nAgain you didn't give details about <code>MessageHdr</code>. In case it is not a <code>struct</code>, but only a typedef to e. g. <code>char[10]</code>, you are right in that you <em>could</em> just use char[10] instead.<br>\nHowever, imagine throughout your program or library you need to deal with \"MessageHdr\" (Message-Header?) over and over again, and every time it is a char array with the length 10. Using a typedef you gain the benefit of:    </br></p>\n<ol>\n<li>Having a named type, which others might instantly recognize and understand what it does.</li>\n<li>The possibility to easily change the size of the char array in case at some later point it needs to change.</li>\n</ol>\n", "LastActivityDate": "2017-09-17T12:15:54.633", "Score": "0", "CreationDate": "2017-09-17T12:15:54.633", "ParentId": "46263697", "CommentCount": "0", "OwnerUserId": "826955"}, "46263908": {"Id": "46263908", "PostTypeId": "2", "Body": "<p>This code is invalid C++ code. The pointer is cast to `(MessageHDR*) in order that the compiler does not complain about this code: </p>\n<pre><code>msg-&gt;msgtype=JOINREQ\n</code></pre>\n<p>But this code is undefined behaviour if MessageHDR has vacuous initialization(see below): this is invalid C++ code (access object member out of its life-time period). n.m. in is comment propose you to read a book, this is the best solution, and if you read code, it would be better to read well written C++ code: stdlibc++, libc++ for exemple.</p>\n<hr>\n<p>According to the c++ standard [basic.life]/1</p>\n<blockquote>\n<p id=\"so_46263697_46263908_0\">The lifetime of an object or reference is a runtime property of the object or reference. An object is said to have\n  non-vacuous initialization if it is of a class or aggregate type and it or one of its subobjects is initialized by a\n  constructor other than a trivial default constructor. [ Note: Initialization by a trivial copy/move constructor\n  is non-vacuous initialization. \u2014 end note ] The lifetime of an object of type T begins when:\n  (1.1) \u2014 storage with the proper alignment and size for type T is obtained, and\n  (1.2) \u2014 if the object has non-vacuous initialization, its initialization is complete</p>\n</blockquote>\n<p>So if <code>MessageHDR</code> has a non-vacuous initialization (which is the point of using C++) then [basic.life]/6</p>\n<blockquote>\n<p id=\"so_46263697_46263908_1\">Before the lifetime of an object has started but after the storage which the object will occupy has been\n  allocated or, after the lifetime of an object has ended and before the storage which the object occupied is\n  reused or released, any pointer that represents the address of the storage location where the object will be or\n  was located may be used but only in limited ways. For an object under construction or destruction, see 15.7.\n  Otherwise, such a pointer refers to allocated storage (6.7.4.2), and using the pointer as if the pointer were of\n  type void*, is well-defined. Indirection through such a pointer is permitted but the resulting lvalue may only\n  be used in limited ways, as described below. The program has undefined behavior if:[...]</p>\n<p id=\"so_46263697_46263908_2\">(6.2) \u2014 the pointer is used to access a non-static data member or call a non-static member function of the\n  object, o</p>\n</blockquote>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2017-09-17T14:27:07.160", "Score": "-1", "CreationDate": "2017-09-17T12:09:34.457", "ParentId": "46263697", "CommentCount": "2", "LastEditDate": "2017-09-17T14:27:07.160", "OwnerUserId": "5632316"}, "46263697": {"ViewCount": "98", "Body": "<p>I'm not sure if this is a good question by community standards (let me know if there is a better way or place for this question please).</p>\n<p>I'm working on understanding a piece of code which I've come across while trying to learn C++. Code is as follows:</p>\n<pre><code>MessageHdr *msg;\nsize_t msgsize = sizeof(MessageHdr) + sizeof(joinaddr-&gt;addr) + sizeof(long) + 1;\nmsg = (MessageHdr *) malloc(msgsize * sizeof(char));\n\n// create JOINREQ message: format of data is {struct Address myaddr}\nmsg-&gt;msgType = JOINREQ;\nmemcpy((char *)(msg+1), &amp;memberNode-&gt;addr.addr, sizeof(memberNode-&gt;addr.addr));\nmemcpy((char *)(msg+1) + 1 + sizeof(memberNode-&gt;addr.addr), &amp;memberNode-&gt;heartbeat, sizeof(long));\nemulNet-&gt;ENsend(&amp;memberNode-&gt;addr, joinaddr, (char *)msg, msgsize);\n</code></pre>\n<ol>\n<li>What is the point of casting to <code>MessageHdr *</code> in line 3? </li>\n<li>I feel like we're building a <code>char[]</code>. We're just using <code>MessageHdr*</code> to refer (to point) to it but I am not sure why? Wouldn't a <code>char*</code> be a better choice?</li>\n</ol>\n<p>Receiving code is as follows (shortened):</p>\n<pre><code>int EmulNet::ENsend(Address *myaddr, Address *toaddr, char *data, int size) {\nen_msg *em;\n...\nem = (en_msg *)malloc(sizeof(en_msg) + size);\nem-&gt;size = size;\n\nmemcpy(&amp;(em-&gt;from.addr), &amp;(myaddr-&gt;addr), sizeof(em-&gt;from.addr));\nmemcpy(&amp;(em-&gt;to.addr), &amp;(toaddr-&gt;addr), sizeof(em-&gt;from.addr));\nmemcpy(em + 1, data, size);\n...\n</code></pre>\n<p>I'm beyond confused at this point - sorry for the vague question. Is this idiomatic C++? I feel as if this could have been done in much cleaner ways instead of passing around a <code>char[]</code> and referencing it via pointers of random struct types. </p>\n<p>I guess what I'm ultimately trying to ask is, while I kind of understand the code, it feels very unnatural. Is this a valid/common approach of doing things?</p>\n<p>EDIT</p>\n<hr>\n<p>MessageHdr is a struct as follows:</p>\n<pre><code>typedef struct MessageHdr {\n    enum MsgTypes msgType;\n}MessageHdr;\n</code></pre>\n<p>joinaddr is a class intances:</p>\n<pre><code>class Address {\npublic:\n    char addr[6];\n    Address() {}\n    // Copy constructor\n    Address(const Address &amp;anotherAddress);\n     // Overloaded = operator\n    Address&amp; operator =(const Address &amp;anotherAddress);\n    bool operator ==(const Address &amp;anotherAddress);\n    Address(string address) {\n        size_t pos = address.find(\":\");\n        int id = stoi(address.substr(0, pos));\n        short port = (short)stoi(address.substr(pos + 1, address.size()-pos-1));\n        memcpy(&amp;addr[0], &amp;id, sizeof(int));\n        memcpy(&amp;addr[4], &amp;port, sizeof(short));\n    }\n    string getAddress() {\n        int id = 0;\n        short port;\n        memcpy(&amp;id, &amp;addr[0], sizeof(int));\n        memcpy(&amp;port, &amp;addr[4], sizeof(short));\n        return to_string(id) + \":\" + to_string(port);\n    }\n    void init() {\n        memset(&amp;addr, 0, sizeof(addr));\n    }\n};\n</code></pre>\n</hr>", "Title": "Understanding how malloc() is used in this context", "CreationDate": "2017-09-17T11:44:55.030", "LastActivityDate": "2017-09-17T14:27:07.160", "CommentCount": "13", "LastEditDate": "2017-09-17T12:07:56.090", "PostTypeId": "1", "LastEditorUserId": "285828", "Id": "46263697", "Score": "0", "OwnerUserId": "285828", "Tags": "<c++>", "AnswerCount": "3"}});