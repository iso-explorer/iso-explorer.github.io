post_cb({"34017482": {"ParentId": "33872039", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2015-12-01T09:58:18.660", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:27.293", "Id": "34017482", "OwnerUserId": "3216312", "Body": "<p>As there is no answer for a week, I will post my vision. I am far from being an expert at language-laywering, actually I would consider myself a complete novice, but still. The following is based on my reading of standard, as well on my recent <a href=\"https://stackoverflow.com/questions/33957274/type-conversion-at-template-non-type-argument-without-constexpr\">question</a>.</p>\n<p>So, first of all let's rewrite the code the following way:</p>\n<pre><code>struct A {\n    constexpr operator int() const { return 42; }\n};\n\ntemplate &lt;int&gt;\nvoid foo() {}\n\nvoid test(const A&amp; value) {\n    foo&lt;value&gt;();\n}\n\nint main() {\n    A a{};\n    test(a);\n}\n</code></pre>\n<p>It exhibits the same behavior (builds with gcc and fails with similar error with clang), but:</p>\n<ul>\n<li>is free from template type deduction at <code>test()</code>, to make sure the problem has nothing to do with type deduction,</li>\n<li>uses 'mocks' instead of <code>std</code> members to make sure this is not a problem with their implementation,</li>\n<li>and has an explicit variable <code>a</code>, not a temporary, to be explained later.</li>\n</ul>\n<p>What does happen here? I will quote <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a>.</p>\n<p>We have a template <code>foo</code> with a non-type parameter.</p>\n<p>[14.3.2(temp.arg.nontype)]/1:</p>\n<blockquote>\n<p id=\"so_33872039_34017482_0\">A template-argument for a non-type template-parameter shall be a\n  converted constant expression (5.20) of the type of the\n  template-parameter.</p>\n</blockquote>\n<p>So template argument, i.e. <code>value</code>, should be a converted constant expression of type <code>int</code>.</p>\n<p>[5.20(expr.const)]/4:</p>\n<blockquote>\n<p id=\"so_33872039_34017482_1\">A converted constant expression of type T is an expression, implicitly\n  converted to type T, where the converted expression is a constant\n  expression and the implicit conversion sequence contains only </p>\n<ul>\n<li>user-defined conversions,</li>\n<li>... (irrelevant bullets dropped)</li>\n</ul>\n<p id=\"so_33872039_34017482_2\">and where the reference binding (if any) binds directly. </p>\n</blockquote>\n<p>Our expression (<code>value</code>) can be implicitly converted to type <code>int</code>, and the conversion sequence contains only user-defined conversions. So the two questions remain: whether \"the converted expression is a constant expression\" and whether \"the reference binding (if any) binds directly\".</p>\n<p>For the first question, the phrase \"the converted expression\", I think, means the expression as already converted to <code>int</code>, that is something like <code>static_cast&lt;int&gt;(value)</code>, not the original expression (<code>value</code>). For that,</p>\n<p>[5.20(expr.const)]/2:</p>\n<blockquote>\n<p id=\"so_33872039_34017482_3\">A conditional-expression <code>e</code> is a core constant expression unless the\n  evaluation of <code>e</code>, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:</p>\n<ul>\n<li>... (a long list omitted)</li>\n</ul>\n</blockquote>\n<p>Evaluation of our expression, <code>static_cast&lt;int&gt;(value)</code>, leads only to evaluation of <code>A::operator int()</code>, which is <code>constexpr</code>, and thus is explicitly allowed. No members of <code>A</code> (if there were any) are evaluated, neither anything else is evaluated.</p>\n<p>Therefore, <code>static_cast&lt;int&gt;(value)</code> is a constant expression.</p>\n<p>For the second question, about reference binding, it is not clear for me to which process this refers at all. However, anyway we have only one reference in our code (<code>const A&amp; value</code>), and it binds directly to the variable <code>a</code> of <code>main</code> (and this is the reason why I introduced <code>a</code>).</p>\n<p>Indeed, direct binding is defined at the end of [8.5.3(dcl.init.ref)]/5:</p>\n<blockquote>\n<p id=\"so_33872039_34017482_4\">In all cases except the last (i.e., creating and initializing a\n  temporary from the initializer expression), the reference is said to\n  bind directly to the initializer expression.</p>\n</blockquote>\n<p>This \"last\" case seem to refer to 5.2, and non-direct binding means initialization from a temporary (like <code>const int&amp; i = 42;</code>), not our case when we have a non-temporary <code>a</code>.</p>\n<p><strong>UPD</strong>: I asked <a href=\"https://stackoverflow.com/questions/34018046/clarification-of-converted-constant-expression-definition\">a separate question</a> to check whether my understanding of the standard, presented above, is correct.</p>\n<hr>\n<p>So the bottomline is that the code should be valid, and clang is wrong. I suggest you filing a bug to clang bug tracker, with a reference to this question. Or if for whatever reason you will not file a bug, let me know, I will file it.</p>\n<p><strong>UPD</strong>: filed <a href=\"https://llvm.org/bugs/show_bug.cgi?id=25693\" rel=\"nofollow noreferrer\">a bug report</a></p>\n</hr>", "LastActivityDate": "2017-03-28T07:52:56.887"}, "33872039": {"CommentCount": "15", "AcceptedAnswerId": "34017482", "PostTypeId": "1", "LastEditorUserId": "673852", "CreationDate": "2015-11-23T13:16:16.303", "LastActivityDate": "2017-03-28T07:52:56.887", "LastEditDate": "2015-11-23T14:06:46.283", "ViewCount": "2017", "FavoriteCount": "2", "Title": "Invalid explicitly-specified argument in clang but successful compilation in gcc \u2014 who's wrong?", "Id": "33872039", "Score": "7", "Body": "<p>The following code compiles without problems in g++:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt;typename T&gt;\nvoid test(const T&amp; value)\n{\n    std::tuple&lt;int, double&gt; x;\n    std::cout &lt;&lt; std::get&lt;value&gt;(x);\n}\n\nint main() {\n    test(std::integral_constant&lt;std::size_t,1&gt;());\n}\n</code></pre>\n<p>I used this command:</p>\n<pre><code>g++ test.cpp -o test -std=c++14 -pedantic -Wall -Wextra\n</code></pre>\n<p>But when I switch <code>g++</code> to <code>clang++</code> (with g++ 5.1.0 and clang++ 3.6.0), I get the following errors:</p>\n<pre><code>test.cpp:9:18: error: no matching function for call to 'get'\n    std::cout &lt;&lt; std::get&lt;value&gt;(x);\n                 ^~~~~~~~~~~~~~~\ntest.cpp:13:5: note: in instantiation of function template specialization 'test&lt;std::integral_constant&lt;unsigned long, 1&gt; &gt;' requested here\n    test(std::integral_constant&lt;std::size_t,1&gt;());\n         ^~~~~~~~~~~~~~~\n&lt;skipped&gt;\n\n/usr/bin/../lib/gcc/x86_64-linux-gnu/5.1.0/../../../../include/c++/5.1.0/tuple:867:5: note: candidate template ignored: invalid explicitly-specified argument for template parameter '_Tp'\n    get(tuple&lt;_Types...&gt;&amp; __t) noexcept\n    ^\n</code></pre>\n<p>And similar <code>note:</code> entries for other overloads of <code>std::get</code>.</p>\n<p>But I'm passing <code>std::integral_constant</code> to <code>test()</code>, which is a constant-expression, why would it be an \"invalid explicitly-specified argument\" for the template parameter? Is it a clang bug or am I doing something wrong here?</p>\n<p>I've noticed that if I change parameter for <code>test()</code> from <code>const T&amp;</code> to <code>const T</code>, then clang compiles successfully. Do I somehow lose <code>constexpr</code> quality of <code>integral_constant</code> by passing it by reference?</p>\n", "Tags": "<c++><templates><gcc><clang>", "OwnerUserId": "673852", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33872039_34017482_4": {"section_id": 3321, "quality": 0.9333333333333333, "length": 14}, "so_33872039_34017482_1": {"section_id": 6186, "quality": 1.0, "length": 17}, "so_33872039_34017482_3": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_33872039_34017482_0": {"section_id": 87, "quality": 0.8888888888888888, "length": 8}, "so_33872039_34017482_2": {"section_id": 3321, "quality": 0.8, "length": 4}}, "n3337": {"so_33872039_34017482_4": {"section_id": 3191, "quality": 0.9333333333333333, "length": 14}, "so_33872039_34017482_1": {"section_id": 5947, "quality": 0.8235294117647058, "length": 14}, "so_33872039_34017482_0": {"section_id": 82, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_33872039_34017482_3": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_33872039_34017482_1": {"section_id": 7689, "quality": 0.8823529411764706, "length": 15}, "so_33872039_34017482_4": {"section_id": 4087, "quality": 0.7333333333333333, "length": 11}, "so_33872039_34017482_0": {"section_id": 90, "quality": 0.8888888888888888, "length": 8}, "so_33872039_34017482_2": {"section_id": 7689, "quality": 1.0, "length": 5}}}});