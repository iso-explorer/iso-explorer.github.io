post_cb({"2969383": {"ViewCount": "559", "Body": "<p>Do interfaces need a virtual destructor, or is the auto-generated one fine? For example, which of the following two code snippets is best, and why? Please note that these are the WHOLE class. There are no other methods, variables, etc. In Java-speak, this is an \"interface\".</p>\n<pre><code>class Base\n{\npublic:\n    virtual void foo() = 0;\n    virtual ~Base() {}\n};\n</code></pre>\n<p>OR...</p>\n<pre><code>class Base\n{\npublic:\n    virtual void foo() = 0;\n    ~Base() {} // This line can be omitted, but included for clarity.\n};\n</code></pre>\n<p><strong>EDIT DUE TO \"NOT WHAT I'M LOOKING FOR\" ANSWERS:</strong></p>\n<p>Exactly what are the consequences of each route. Please don't give vague answers like \"it won't be destructed properly\". Please tell me exactly what will happen. I'm a bit of an assembly nerd.</p>\n<p><strong>Edit 2:</strong></p>\n<p>I am well aware that the \"virtual\" tag means that the destructor won't get called if deleted through a pointer to derived, but (I think) this question ultimately boils down to \"is it safe to omit that destructor, for is it truly trivial?\"</p>\n<p><strong>EDIT 3:</strong></p>\n<p>My second edit is just plain wrong and disinformation. Please read the comments by actual smart people for more info.</p>\n", "AcceptedAnswerId": "2969432", "Title": "Virtual destructors for interfaces", "CreationDate": "2010-06-03T20:09:02.837", "Id": "2969383", "CommentCount": "6", "LastEditDate": "2012-11-13T15:35:28.170", "PostTypeId": "1", "LastEditorUserId": "101258", "LastActivityDate": "2012-11-13T15:35:28.170", "Score": "10", "OwnerUserId": "105760", "Tags": "<c++><polymorphism>", "AnswerCount": "6"}, "2969422": {"Id": "2969422", "PostTypeId": "2", "Body": "<p>You should use a virtual destructor if you expect people to try to delete objects of a derived class via pointers or references of the parent class. If this is the case, then without a virtual destructor, the derived class will never be properly destructed.</p>\n<p>For example,</p>\n<pre><code>Derived::~Derived() { // important stuff }\nBase *foo = new Derived();\ndelete foo;\n</code></pre>\n<p>Without a virtual destructor in Base, Derived's destructor will never be called, and important stuff will therefore never happen.</p>\n", "LastEditorUserId": "73632", "LastActivityDate": "2010-06-03T20:19:55.500", "Score": "3", "CreationDate": "2010-06-03T20:14:44.357", "ParentId": "2969383", "CommentCount": "1", "OwnerUserId": "73632", "LastEditDate": "2010-06-03T20:19:55.500"}, "2969506": {"Id": "2969506", "PostTypeId": "2", "Body": "<p>If you delete a derived class object via a base class pointer in C++, the result is undefined behaviour. UB is something you really want to avoid, so you must give base classes a virtual destructor. To quote from the C++ Standard, section 5.3.5:</p>\n<blockquote>\n<p id=\"so_2969383_2969506_0\">if the static type of the operand is\n  different from its dynamic type, the\n  static type shall be a base class of\n  the operand\u2019s dynamic type and the\n  static type shall have a virtual\n  destructor or the behavior is\n  undefined.</p>\n</blockquote>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2010-06-03T20:25:09.930", "Score": "7", "CreationDate": "2010-06-03T20:25:09.930", "ParentId": "2969383", "CommentCount": "0"}, "2969490": {"Id": "2969490", "PostTypeId": "2", "Body": "<p>In general, a destructor should be either <strong>(1)</strong> public and virtual, or <strong>(2)</strong> protected and non-virtual.</p>\n<p>Assuming you never expect anyone to delete a class instance via an interface pointer, a protected non-virtual destructor is 100% safe.</p>\n<p>If someone tries to delete an interface pointer in case (2), they'll get a compile-time error.</p>\n", "LastActivityDate": "2010-06-03T20:23:10.220", "CommentCount": "2", "CreationDate": "2010-06-03T20:23:10.220", "ParentId": "2969383", "Score": "2", "OwnerUserId": "66341"}, "bq_ids": {"n4140": {"so_2969383_2969506_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6107}}, "n3337": {"so_2969383_2969506_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 5873}}, "n4659": {"so_2969383_2969506_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7604}}}, "2969432": {"Id": "2969432", "PostTypeId": "2", "Body": "<p>Consider the following case:</p>\n<pre><code>   Base *Var = new Derived();\n   delete Var;\n</code></pre>\n<p>You need the virtual destructor, otherwise when you delete <code>Var</code>, the derived class' destructor will never be called.</p>\n", "LastActivityDate": "2010-06-03T20:15:47.200", "CommentCount": "8", "CreationDate": "2010-06-03T20:15:47.200", "ParentId": "2969383", "Score": "13", "OwnerUserId": "101258"}, "2969413": {"Id": "2969413", "PostTypeId": "2", "Body": "<p>No... virtual destructors are not auto generated. You have to declare them explicitely in your base class. \nBut you won't need to declare your destructors virtual for the child classes of Base. This is done by the compiler. \nThe compiler will also make sure that the destructors are called in reversed order of construction (from derived to base). </p>\n<pre><code>public class Base \n{\n //...\n}\n\npublic class Derived\n{\n   int i = 0;\n   //...\n}\n\n//...\n\nBase* b = new Derived();\n</code></pre>\n<p>If you didn't have a virtual destructor</p>\n<pre><code>delete b;\n</code></pre>\n<p>would cause memory leaks (at least 4 bytes for the integer field), because it would destruct only <code>Base</code> and not <code>Derived</code>. The virtuality makes sure that the derived classes are destroyed, too. You won't have to declare a virtual constructor in <code>Derived</code>, this will be inferred by the compiler, if you declared a virtual destructor in <code>Base</code>.</p>\n", "LastEditorUserId": "241022", "LastActivityDate": "2010-06-03T20:25:49.980", "Score": "0", "CreationDate": "2010-06-03T20:13:24.563", "ParentId": "2969383", "CommentCount": "0", "OwnerUserId": "241022", "LastEditDate": "2010-06-03T20:25:49.980"}, "2969554": {"Id": "2969554", "PostTypeId": "2", "Body": "<p>Replying mostly to the edit:</p>\n<p>Nobody can tell you what will happen because the result is \"undefined behavior\".  When you delete a derived class through a pointer to a base that has no virtual destructor, the implementation is free to break down in any number of ways.</p>\n", "LastActivityDate": "2010-06-03T20:34:11.020", "CommentCount": "0", "CreationDate": "2010-06-03T20:34:11.020", "ParentId": "2969383", "Score": "3", "OwnerUserId": "301883"}});