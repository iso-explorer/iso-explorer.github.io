post_cb({"14750180": {"Id": "14750180", "PostTypeId": "2", "Body": "<p>According to the standard</p>\n<blockquote>\n<p id=\"so_14749461_14750180_0\">When looking for the declaration of a name used in a template\n  definition, the usual lookup rules (3.4.1, 3.4.2) are used for\n  nondependent names. The lookup of names dependent on the template\n  parameters is postponed until the actual template argument is known\n  (14.6.2).</p>\n</blockquote>\n<p>It means, that you have to tell to the compiler, that <code>base_type</code> in the <code>Base</code> class, that depends of <code>C</code>. You can use, for example, this:</p>\n<pre><code>template&lt;class C&gt;\nstruct Derived : public Base&lt;C&gt;\n{\n    using typename Base&lt;C&gt;::base_type;\n\n    Derived() : base_type() {}\n};\n</code></pre>\n<p>or this</p>\n<pre><code>template&lt;class C&gt;\nstruct Derived : public Base&lt;C&gt;\n{\n    Derived() : Derived&lt;C&gt;::base_type() {} \n\n    // or, as you already told, Base&lt;C&gt;::base_type()\n};\n</code></pre>\n", "LastActivityDate": "2013-02-07T11:36:40.863", "CommentCount": "0", "CreationDate": "2013-02-07T11:36:40.863", "ParentId": "14749461", "Score": "2", "OwnerUserId": "1532460"}, "bq_ids": {"n4140": {"so_14749461_14750180_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 176}}, "n3337": {"so_14749461_14750180_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 170}}, "n4659": {"so_14749461_14750180_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 181}}}, "14749461": {"ViewCount": "2139", "Body": "<p>The next code works fine (this is a oversimplified version of other problem of mine, with types longer, deeper and more templates):</p>\n<pre><code>template&lt;class C&gt;\nstruct Base\n{};\n\ntemplate&lt;class C&gt;\nstruct Derived : public Base&lt;C&gt;\n{\n   Derived() : Base&lt;C&gt;()\n   {}\n};\n</code></pre>\n<p>But, how could I call to the base class constructor without \"write\" the complete type of its base class? For example, I tried something like:</p>\n<pre><code>template&lt;class C&gt;\nstruct Base\n{\n   typedef Base base_type;\n};\n\ntemplate&lt;class C&gt;\nstruct Derived : public Base&lt;C&gt;\n{\n   Derived() : base_type() {}\n};\n\nint main()\n{\n   Derived&lt;void&gt; b;\n}\n</code></pre>\n<p>But \"base_type\" isn't recognized. The message that gcc throws is:</p>\n<pre><code>test3.cpp: In constructor 'Derived&lt;C&gt;::Derived()':\n  test3.cpp:100:17: error: class 'Derived&lt;C&gt;' does not have any field\n  named 'base_type'\n</code></pre>\n<p>To solve it I have to write <code>Base&lt;C&gt;::base_type</code> in the constructor but this would make the existence of <code>base_type</code> itself irrelevant.</p>\n<p>Is it my campaign of writting-saving impossible?</p>\n<p>And, why <code>base_type</code> in the constructor isn't found, and however this works fine?</p>\n<pre><code>int main()\n{\n   Derived&lt;void&gt;::base_type b;\n}\n</code></pre>\n<p><strong>EDIT:</strong> With the comment of <a href=\"https://stackoverflow.com/users/1502345/jack-aidley\">@Jack Aidley</a> the best form I've found to get the type of the base class with a simple alias is:</p>\n<pre><code>template&lt;typename C&gt; struct Base {};\n\ntemplate&lt;typename C, typename Base&gt;\nstruct Derived_impl : public Base\n{\n    Derived_impl() : Base()\n    {}\n};\n\ntemplate&lt;typename C&gt;\nusing Derived = Derived_impl&lt;C, Base&lt;C&gt; &gt;;\n\nint main()\n{\n   Derived&lt;void&gt; b;\n}\n</code></pre>\n", "AcceptedAnswerId": "14750180", "Title": "Get type of template base class", "CreationDate": "2013-02-07T10:58:21.350", "Id": "14749461", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:31:21.183", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-07T13:23:06.960", "Score": "1", "OwnerUserId": "1794803", "Tags": "<c++><templates><inheritance>", "AnswerCount": "2"}, "14750421": {"Id": "14750421", "PostTypeId": "2", "Body": "<p>You can always do this:</p>\n<pre><code>template&lt;class C&gt;\nstruct Base\n{\n};\n\ntemplate&lt;class C&gt;\nstruct Derived : public Base&lt;C&gt;\n{\n   typedef Base&lt;C&gt; base_type;  // define here\n\n   Derived() : base_type() {}\n};\n</code></pre>\n<p>Makes sense if you will refer to the base type in <code>Derived</code>...</p>\n", "LastActivityDate": "2013-02-07T11:48:38.903", "CommentCount": "0", "CreationDate": "2013-02-07T11:48:38.903", "ParentId": "14749461", "Score": "2", "OwnerUserId": "266198"}});