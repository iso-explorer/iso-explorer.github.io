post_cb({"14395333": {"ParentId": "14395192", "CommentCount": "10", "Body": "<p>First, the function declaration <em>is</em> legal.  The <code>extern \"C\"</code>,\nhowever, is ignored for class members, so if <code>g</code> expects an\n<code>extern \"C\" void (*)()</code>, you can't pass it <code>callback</code>.</p>\n<p>As to the why of this, I suspect that originally, it was mainly \na question of orthogonality: it makes no sense for a class\nmember function to be <code>extern \"C\"</code> in general, and orthogonality\n(or simply no one considered the case of static members) means\nthat this applies to static member functions as well, although\nallowing them to be <code>extern \"C\"</code> would have been useful.  Today\n(i.e. C++11), it would be problematic to change the rule,\nbecause it could break existing code.  IMHO, the change would\nbe acceptable, because the amount of code it would break is\nprobably very small, and the breakage results in a compile time\nerror\u2014not a change in runtime semantics\u2014so is easily\ndetected and fixed.  Still, as far as I know, no one made\na proposal to change this, so it didn't get changed.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "14395333", "Score": "3", "CreationDate": "2013-01-18T08:54:42.800", "LastActivityDate": "2013-01-18T08:54:42.800"}, "14395192": {"CommentCount": "12", "ViewCount": "5645", "PostTypeId": "1", "LastEditorUserId": "508343", "CreationDate": "2013-01-18T08:44:46.683", "LastActivityDate": "2013-01-20T04:21:15.873", "Title": "Why does C++11 not support declaring extern \"C\" on a static member function?", "FavoriteCount": "3", "LastEditDate": "2013-01-18T09:02:57.443", "Id": "14395192", "Score": "12", "Body": "<p>Provided that I have a C library containing a function declared as <code>void g(void (*callback)());</code> The following code is elegant yet illegal:</p>\n<pre><code>struct A\n{\n    // error C2159: more than one storage class specified (VC++ Nov 2012 CTP)\n    static extern \"C\" void callback()\n    {}\n};\n\ng(A::callback); \n</code></pre>\n<p>Why does C++11 not support this?</p>\n", "Tags": "<c++><c><static><c++11><extern>", "OwnerUserId": "508343", "AnswerCount": "2"}, "14396177": {"ParentId": "14395192", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is a particularly confusing topic to wade into. Let's attack \u00a77.5 \"Linkage specifications\" [dcl.link].</p>\n<blockquote>\n<p id=\"so_14395192_14396177_0\">1) All function types, function names with external linkage, and variable names with external linkage have a <em>language linkage</em>. </p>\n</blockquote>\n<p>Note that the property of language linkage applies to two completely different kinds of entities: <em>types</em> and <em>names</em>.</p>\n<p>A function has a generally-invisible bit of information in its type which identifies which ABI it conforms to: C calling conventions, Pascal, Fortran, all might be specified to use the stack in different ways, so calling them through a pointer requires knowing the invisible language-tag.</p>\n<p>The <em>name</em> of a variable or function from another language can be accessed syntactically through C++, or from the other language referring to a C++ declaration. But not every language can match up with C++'s naming scheme and OO model. So interfaces in this scheme don't include classes.</p>\n<p>Because these things are managed separately, it's possible to have something with different linkage in its type (calling conventions) and its name (linker symbol).</p>\n<blockquote>\n<p id=\"so_14395192_14396177_1\">4) Linkage specifications nest. When linkage specifications nest, the innermost one determines the language\n  linkage. A linkage specification does not establish a scope. A <em>linkage-specification</em> shall occur only in namespace scope (3.3). In a <em>linkage-specification</em>, the specified language linkage applies to the function types of all function declarators, function names with external linkage, and variable names with external linkage declared within the <em>linkage-specification.</em> A C language linkage is ignored in determining the language linkage of the names of class members and the function type of class member functions.</p>\n</blockquote>\n<p>The <code>extern \"C\" {}</code> affects all function declarations, including pointers and references, except member functions. Since a function may only be defined in a namespace or as a member, C functions can only be defined at namespace scope.</p>\n<p>The standard gives an example here:</p>\n<pre><code>extern \"C\" typedef void FUNC_c();\n\nclass C {\n   // the name of the function mf1 and the member \n   // function\u2019s type have C++ language linkage; the \n   // parameter has type pointer to C function\n   void mf1(FUNC_c*);\n\n   // the name of the function mf2 and the member\n   // function\u2019s type have C++ language linkage\n   FUNC_c mf2;\n\n   // the name of the data member q has C++ language\n   // linkage and the data member\u2019s type is pointer to\n   // C function\n   static FUNC_c* q;\n};\n</code></pre>\n<p>You can emulate the behavior you want using a <code>typedef</code>, though. From another example in \u00a77.5/4,</p>\n<pre><code>extern \"C\" typedef void FUNC();\n\n// the name f2 has C++ language linkage and the \n// function\u2019s type has C language linkage\nFUNC f2;\n</code></pre>\n<p>Combining these examples with yours, you can have</p>\n<pre><code>extern \"C\" typedef void callback_t();\n\ncallback_t A_callback; // declare function with C++ name and C type\n\nstruct A\n{\n    static callback_t &amp;callback; // not a member function\n};\n\n// in source file:\n\n// definition matches semantics of declaration, although not syntax\nvoid A_callback() { ... }\n\n// define static member reference\ncallback_t &amp;A::callback = A_callback;\n\ng(A::callback); // call syntax is emulated\n</code></pre>\n<p>In practice, it seldom makes a difference. C and C++ use compatible calling conventions on most platforms (see Jonathan Wakely's comments on this page for exceptions), as long as you don't try to pass or return a non-POD C++ class type. This is a less-implemented feature of C++, due to the confusing overloading of terms and conceptual distinctions ranging from subtle to academic.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-01-20T04:21:15.873", "Id": "14396177", "Score": "13", "CreationDate": "2013-01-18T09:46:55.987", "LastActivityDate": "2013-01-20T04:21:15.873"}, "bq_ids": {"n4140": {"so_14395192_14396177_0": {"section_id": 5517, "quality": 1.0, "length": 14}, "so_14395192_14396177_1": {"section_id": 5520, "quality": 1.0, "length": 56}}, "n3337": {"so_14395192_14396177_0": {"section_id": 5303, "quality": 1.0, "length": 14}, "so_14395192_14396177_1": {"section_id": 5306, "quality": 1.0, "length": 56}}, "n4659": {"so_14395192_14396177_0": {"section_id": 6952, "quality": 1.0, "length": 14}, "so_14395192_14396177_1": {"section_id": 6955, "quality": 1.0, "length": 56}}}});