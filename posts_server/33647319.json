post_cb({"33647319": {"CommentCount": "0", "ViewCount": "350", "PostTypeId": "1", "LastEditorUserId": "4774918", "CreationDate": "2015-11-11T09:11:42.573", "LastActivityDate": "2015-11-11T10:45:20.790", "Title": "Does the address of the array equal to that of its first element in C++?", "AcceptedAnswerId": "33648901", "LastEditDate": "2015-11-11T10:27:28.593", "Id": "33647319", "Score": "3", "Body": "<p>This can be guaranteed in C because of the following sentence in WG14/N1570:</p>\n<blockquote>\n<p id=\"so_33647319_33647319_0\">6.2.5/20 ... An array type describes a contiguously allocated nonempty set of objects with a particular member object type, called the element type.</p>\n</blockquote>\n<p>But in WG21/N4527, i.e. in C++, the corresponding sentence becomes</p>\n<blockquote>\n<p id=\"so_33647319_33647319_1\">8.3.4/1 ...An object of array type contains a contiguously allocated non-empty set of N subobjects of type T.</p>\n</blockquote>\n<p>while the word \"describes\" is changed to \"contains\", which cannot guarantee that the address of the array equals to that of its first element. Is this change intentional or unintentional? If it is intentional, does the address of the array equal to that of its first element in C++? If it does, which paragraph in the C++ standard can guarantee this?</p>\n", "Tags": "<c++><arrays><language-lawyer><memory-address>", "OwnerUserId": "5376789", "AnswerCount": "3"}, "33648901": {"ParentId": "33647319", "CommentCount": "1", "Body": "<p>I don't think it's stated explicitly anywhere, but I believe it follows from <code>5.3.3 Sizeof</code>:</p>\n<blockquote>\n<p id=\"so_33647319_33648901_0\">the size of an array of n elements is n times the size of an element</p>\n</blockquote>\n<p>that the only thing that can be stored at the array's starting address is the array's first element.</p>\n", "OwnerUserId": "404970", "PostTypeId": "2", "Id": "33648901", "Score": "3", "CreationDate": "2015-11-11T10:45:20.790", "LastActivityDate": "2015-11-11T10:45:20.790"}, "33647779": {"ParentId": "33647319", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In C++ it is guaranteed by 4.2/1 Array-to-pointer conversion [conv.array], (bold by me)</p>\n<blockquote>\n<p id=\"so_33647319_33647779_0\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound\n  of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. <strong>The result\n  is a pointer to the first element of the array.</strong></p>\n</blockquote>\n<p>That means if you want to take the address of an array in C++, you would get a pointer which points to the first element of the array. i.e.</p>\n<pre><code>int a[10];\nint* p1 = a;     // take the address of array\nint* p2 = &amp;a[0]; // take the address of the first element of the array\n</code></pre>\n<p>The standard guarantees that <code>p1</code> and <code>p2</code> will point to same address.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2015-11-11T09:59:41.820", "Id": "33647779", "Score": "4", "CreationDate": "2015-11-11T09:38:00.040", "LastActivityDate": "2015-11-11T09:59:41.820"}, "bq_ids": {"n4140": {"so_33647319_33647779_0": {"section_id": 11, "quality": 0.9444444444444444, "length": 17}, "so_33647319_33647319_1": {"section_id": 3228, "quality": 0.9090909090909091, "length": 10}, "so_33647319_33648901_0": {"section_id": 6077, "quality": 1.0, "length": 6}, "so_33647319_33647319_0": {"section_id": 3228, "quality": 0.5625, "length": 9}}, "n3337": {"so_33647319_33647779_0": {"section_id": 8, "quality": 0.9444444444444444, "length": 17}, "so_33647319_33647319_1": {"section_id": 3101, "quality": 0.9090909090909091, "length": 10}, "so_33647319_33648901_0": {"section_id": 5845, "quality": 1.0, "length": 6}, "so_33647319_33647319_0": {"section_id": 3101, "quality": 0.5625, "length": 9}}, "n4659": {"so_33647319_33647779_0": {"section_id": 12, "quality": 0.9444444444444444, "length": 17}, "so_33647319_33647319_1": {"section_id": 3985, "quality": 0.9090909090909091, "length": 10}, "so_33647319_33648901_0": {"section_id": 7573, "quality": 1.0, "length": 6}, "so_33647319_33647319_0": {"section_id": 3985, "quality": 0.5625, "length": 9}}}, "33648349": {"ParentId": "33647319", "CommentCount": "4", "Body": "<p>It depends what you mean by \"address of array\".</p>\n<p>If you are asking if an array, when converted to a pointer, gives a result equal to the address of its first element, then the answer is yes.   For example;</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid func(int *x, int *y)\n{\n     std::cout &lt;&lt; \"x and y are \";\n     if (p != q) std::cout &lt;&lt; \"NOT \";\n     std::cout &lt;&lt; \" equal\\n\";\n}\n\nint main()\n{\n    int x[2];\n\n    func(x, &amp;x[0]);\n}\n</code></pre>\n<p>This will always report that the two pointers are equal.  songyuanyao has explained why.</p>\n<p>However, <code>x</code> is not actually a pointer to an array (and nor is it converted to one in this code).    If you change the call of <code>func()</code> in <code>main()</code> to</p>\n<pre><code>  func(&amp;x, &amp;x[0]);\n</code></pre>\n<p>then that statement will not even compile.   The reason is that <code>&amp;x</code> (the address of the array <code>x</code>) is not a pointer to an <code>int</code> - it is a pointer to an array of two <code>int</code>, and that cannot be implicitly converted into a pointer to <code>int</code>.</p>\n<p>The value, however, will be the same, as may be demonstrated by running this code.</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid func2(void *x, void *y)\n{\n     std::cout &lt;&lt; \"x and y are \";\n     if (p != q) std::cout &lt;&lt; \"NOT \";\n     std::cout &lt;&lt; \" equal\\n\";\n}\n\nint main()\n{\n    int x[2];\n\n    func2(&amp;x, &amp;x[0]);     // both pointers implicitly converted to void * when calling func2()\n}\n</code></pre>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "33648349", "Score": "0", "CreationDate": "2015-11-11T10:11:18.823", "LastActivityDate": "2015-11-11T10:11:18.823"}});