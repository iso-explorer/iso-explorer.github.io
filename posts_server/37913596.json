post_cb({"37913618": {"ParentId": "37913596", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_37913596_37913618_0\">why <code>const</code> is ignored in the first case and not so in the second one?</p>\n</blockquote>\n<p>In the 1st case, <code>const</code> is qualified for the parameter itself, while in the 2nd case, <code>const</code> is qualified for the pointee, not the pointer itself. <strong>Const pointer</strong> and <strong>pointer to const</strong> are not the same thing. </p>\n<p>In the 2nd case, pointer to const and pointer to non-const are different and acceptable for overloading. If you make the pointer itself <code>const</code>, i.e. <code>int* const p</code> vs <code>int* p</code>, you'll get the same result as the 1st case.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-06-20T01:50:31.207", "Id": "37913618", "Score": "0", "CreationDate": "2016-06-20T01:43:14.340", "LastActivityDate": "2016-06-20T01:50:31.207"}, "37913644": {"ParentId": "37913596", "CommentCount": "2", "CreationDate": "2016-06-20T01:47:01.937", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "37913644", "Score": "0", "Body": "<p>Because when you declare</p>\n<pre><code>void foo(const int n)\n{\n}\n</code></pre>\n<p>All that the <code>const</code> modifier does is prevent <code>n</code> from being modified inside the <code>foo()</code> function. The parameter to this <code>foo()</code> function is still an <code>int</code>. The <code>const</code> modifier does not modify the parameter's type. So both</p>\n<pre><code>void foo(int n)\n</code></pre>\n<p>and</p>\n<pre><code>void foo(const int n)\n</code></pre>\n<p>are functions that take an <code>int</code> parameter. The only difference between them is that the second one cannot modify it's parameter, while the first one can modify it, like any other non-<code>const</code> variable inside the function.</p>\n<p>However, there is a difference between</p>\n<pre><code>void foo(const int *p)\n</code></pre>\n<p>and</p>\n<pre><code>void foo(int *p)\n</code></pre>\n<p>One is a pointer to a <code>const</code> integer, the other one is a pointer to a mutable integer. They are different types.</p>\n<p>Bonus answer:</p>\n<p>Both</p>\n<pre><code>void foo(int *p)\n</code></pre>\n<p>and</p>\n<pre><code>void foo(int * const p)\n</code></pre>\n<p>have the same parameter type. Both functions' parameter is a pointer to an <code>int</code>. Except that the second one's parameter is <code>const</code> value, and the function cannot modify it.</p>\n<p>Confused yet?</p>\n", "LastActivityDate": "2016-06-20T01:47:01.937"}, "37914489": {"ParentId": "37913596", "CommentCount": "0", "CreationDate": "2016-06-20T04:03:58.427", "OwnerUserId": "540815", "PostTypeId": "2", "Id": "37914489", "Score": "1", "Body": "<p>During overload resolution, <code>const</code> and <code>volatile</code> specifies on parameters are significant except when they occur at the outermost level of the of the parameter type specification. From the C++ standard, \u00a7 13.1.3.4:</p>\n<blockquote>\n<p id=\"so_37913596_37914489_0\">Parameter declarations that differ only in the presence or absence of\n  const and/or volatile are equivalent. That is, the const and\n  volatile type-specifiers for each parameter type are ignored when\n  determining which function is being declared, defined, or called. [\n  Example:</p>\n</blockquote>\n<pre><code>typedef const int cInt;\nint f (int);\nint f (const int); // redeclaration of f(int)\nint f (int) { /* ... */ } // definition of f(int)\nint f (cInt) { /* ... */ } // error: redefinition of f(int)\n</code></pre>\n<blockquote>\n<p id=\"so_37913596_37914489_1\">\u2014end example ] Only the const and volatile type-specifiers at the\n  outermost level of the parameter type specification  are ignored in \n  this fashion; const and volatile type-specifiers buried within a \n  parameter type specification are significant and can be used to \n  distinguish overloaded function declarations. In particular, for  any\n  type T, \u201cpointer to T,\u201d \u201cpointer to const T,\u201d and \u201cpointer to \n  volatile T\u201d are considered distinct parameter types, as are \u201creference\n  to T,\u201d \u201creference to const T,\u201d and \u201creference to volatile T.\u201d</p>\n</blockquote>\n", "LastActivityDate": "2016-06-20T04:03:58.427"}, "37913678": {"ParentId": "37913596", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>const int* p\n</code></pre>\n<p>is <em>not</em> a constant pointer to an integer, it's a pointer to a constant integer (i.e., <code>[const int] * p</code> rather than <code>const [int * p]</code>). This is why you sometimes see code like:</p>\n<pre><code>const int * const p;\n</code></pre>\n<p>which may <em>seem</em> redundant to the uninitiated but is really not - <code>p</code> in that case is a pointer you're not allowed to change, which points to an integer you're <em>also</em> not allowed to change.</p>\n<p>Hence the two functions you have in your second case are considered different in terms of the parameters accepted. That's also why you're calling the second function, since <code>i</code> is most definitely not a <code>const</code> integer.</p>\n<p>In other words, while <code>const</code>-ing a parameter does not change it in terms of the function signature, that's not what you're doing here. Changing a parameter from \"pointer to int\" to \"pointer to const int\" <em>does</em> affect the signature.</p>\n<p>The equivalent case to your first code snippet would be providing both of:</p>\n<pre><code>void foo_ptr (int * const p)\nvoid foo_ptr (int * p)\n</code></pre>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2016-06-20T02:11:20.913", "Id": "37913678", "Score": "3", "CreationDate": "2016-06-20T01:53:03.467", "LastActivityDate": "2016-06-20T02:11:20.913"}, "bq_ids": {"n4140": {"so_37913596_37914489_0": {"section_id": 558, "quality": 0.92, "length": 23}, "so_37913596_37914489_1": {"section_id": 558, "quality": 0.9285714285714286, "length": 39}}, "n3337": {"so_37913596_37914489_0": {"section_id": 549, "quality": 0.92, "length": 23}, "so_37913596_37914489_1": {"section_id": 549, "quality": 0.9285714285714286, "length": 39}}, "n4659": {"so_37913596_37914489_0": {"section_id": 581, "quality": 0.92, "length": 23}, "so_37913596_37914489_1": {"section_id": 581, "quality": 0.9285714285714286, "length": 39}}}, "37913596": {"CommentCount": "2", "ViewCount": "233", "CreationDate": "2016-06-20T01:38:50.463", "LastActivityDate": "2016-06-20T04:03:58.427", "Title": "Function Overloading in C++ (const pointers)", "PostTypeId": "1", "Id": "37913596", "Score": "4", "Body": "<p>Consider the following code snippets:</p>\n<pre><code>void foo(const int i) // First foo\n{\n   std::cout &lt;&lt; \"First \" &lt;&lt; i &lt;&lt; endl;\n}\n\nvoid foo(int i)       // Second foo\n{\n   std::cout &lt;&lt; \"Second \" &lt;&lt; i &lt;&lt; endl;\n}\n\nint main() \n{\n   int i = 5;\n   foo(i);      \n}\n</code></pre>\n<p>Compilation Error:\n<code>redefinition of 'void foo(int)'</code></p>\n<p>Since <code>const</code>s can be initialized with non-<code>const</code> objects, the above behaviour seems reasonable. Now consider this:</p>\n<pre><code>void foo_ptr(const int* p)  // First foo_ptr\n{\n   std::cout &lt;&lt; \"First \" &lt;&lt; *p &lt;&lt; endl;\n}\n\nvoid foo_ptr(int* p)        // Second foo_ptr\n{\n   std::cout &lt;&lt; \"Second \" &lt;&lt; *p &lt;&lt; endl;\n}\n\nint main()\n{\n   int i = 5;\n   foo_ptr(&amp;i);             // Second foo_ptr gets called; prints 'Second 5'\n}\n</code></pre>\n<p>As it might be clear, my question is - If the two definitions of <code>foo</code> in the first case are considered the same then why it is not so for <code>foo_ptr</code> in the second case? Or in other words, why <code>const</code> is ignored in the first case and not so in the second one?</p>\n", "Tags": "<c++><pointers><const><function-overloading>", "OwnerUserId": "4653746", "AnswerCount": "4"}});