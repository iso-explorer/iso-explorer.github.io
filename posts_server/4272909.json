post_cb({"bq_ids": {"n4140": {"so_4272909_4272909_0": {"length": 77, "quality": 0.875, "section_id": 6038}, "so_4272909_4273271_2": {"length": 6, "quality": 1.0, "section_id": 6038}, "so_4272909_4273271_3": {"length": 24, "quality": 0.8, "section_id": 43}, "so_4272909_4273271_0": {"length": 4, "quality": 1.0, "section_id": 6038}, "so_4272909_4273271_1": {"length": 5, "quality": 1.0, "section_id": 6038}}, "n3337": {"so_4272909_4272909_0": {"length": 80, "quality": 0.9090909090909091, "section_id": 5806}, "so_4272909_4273271_2": {"length": 6, "quality": 1.0, "section_id": 5806}, "so_4272909_4273271_3": {"length": 24, "quality": 0.8, "section_id": 40}, "so_4272909_4273271_0": {"length": 4, "quality": 1.0, "section_id": 5806}, "so_4272909_4273271_1": {"length": 5, "quality": 1.0, "section_id": 5806}}, "n4659": {"so_4272909_4272909_0": {"length": 69, "quality": 0.7840909090909091, "section_id": 7537}, "so_4272909_4273271_2": {"length": 6, "quality": 1.0, "section_id": 7537}, "so_4272909_4273271_3": {"length": 24, "quality": 0.8, "section_id": 43}, "so_4272909_4273271_0": {"length": 4, "quality": 1.0, "section_id": 7537}, "so_4272909_4273271_1": {"length": 5, "quality": 1.0, "section_id": 7537}}}, "4273271": {"Id": "4273271", "PostTypeId": "2", "Body": "<p>It's valid.</p>\n<blockquote>\n<p id=\"so_4272909_4273271_0\">If class B contains the original member,</p>\n</blockquote>\n<p>B doesn't contain D::Foo, so no.</p>\n<blockquote>\n<p id=\"so_4272909_4273271_1\">or is a base [...] of the class containing the original member</p>\n</blockquote>\n<p>B is a base of D, so this holds. As a result:</p>\n<blockquote>\n<p id=\"so_4272909_4273271_2\">the resulting pointer to member points to the original member</p>\n</blockquote>\n<p>Clause 5.2.9 9 says you can upcast only if you can also downcast, as specified in \u00a7 4.11:</p>\n<blockquote>\n<p id=\"so_4272909_4273271_3\">An rvalue of type \u201cpointer to member of B of type cv T,\u201d where B is a class type, can be converted to an rvalue of type \u201cpointer to member of D of type cv T,\u201d where D is a derived class (clause 10) of B. If B is an inaccessible (clause 11), ambiguous (10.2) or virtual (10.1) base class of D, a program that necessitates this conversion is ill-formed.</p>\n</blockquote>\n<p>This just says you can downcast as long as B is accessible, isn't virtual and only appears once in D's inheritance diagram.</p>\n<p>The danger inherent in upcasting method pointers is that you could call <code>mp</code> on an object whose actual type is B. As long as a code block that deals with D::* also deals with D*, you can avoid this.</p>\n", "LastEditorUserId": "90527", "LastActivityDate": "2010-11-25T02:48:46.747", "Score": "8", "CreationDate": "2010-11-25T02:31:51.733", "ParentId": "4272909", "CommentCount": "3", "OwnerUserId": "90527", "LastEditDate": "2010-11-25T02:48:46.747"}, "4272909": {"ViewCount": "1202", "Body": "<p>Let's say I have a pointer type that can hold the address of a base class method. Can I assign the address of a subclass method to it and expect it to work correctly? In my case I'm using it with a base class pointer and the dynamic type of the object is the derived class.</p>\n<pre><code>struct B\n{\n    typedef void (B::*MethodPtr)();\n};\n\nstruct D: public B\n{\n    void foo() { cout&lt;&lt;\"foo\"&lt;&lt;endl; }\n};\n\nint main(int argc, char* argv[])\n{\n    D d;\n    B* pb = &amp;d;\n\n    //is the following ok, or undefined behavior?\n    B::MethodPtr mp = static_cast&lt;B::MethodPtr&gt;(&amp;D::foo);\n    (pb-&gt;*mp)();\n}\n</code></pre>\n<p>The standard says this when talking about static_cast:</p>\n<blockquote id=\"so_4272909_4272909_0\"> <b>5.2.9.9</b> An rvalue of type \u201cpointer to member of D of type cv1 T\u201d can be converted to an rvalue of type \u201cpointer to member of B of type cv2 T\u201d, where B is a base class (clause 10) of D, if a valid standard conversion from \u201cpointer to member of B of type T\u201d to \u201cpointer to member of D of type T\u201d exists (4.11), and cv2 is the same\ncv-qualification as, or greater cv-qualification than, cv1. 63) The null member pointer value (4.11) is converted to the null member pointer value of the destination type.  If class B contains the original member, or is a base or derived class of the class containing the original member, the resulting pointer to member points to the original member.  Otherwise, the result of the cast is undefined.  [Note: although class B need\nnot contain the original member, the dynamic type of the object on which the pointer to member is dereferenced must contain the original member; see 5.5.] </blockquote>\n<p>As always, I'm having such a hard time deciphering the standard. It kinda says that it is ok, but I'm not 100% sure if the above text really applies to the situation in my example code.</p>\n", "AcceptedAnswerId": "4273271", "Title": "Is it safe to \"upcast\" a method pointer and use it with base class pointer?", "CreationDate": "2010-11-25T01:04:19.757", "Id": "4272909", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2010-11-25T02:48:46.747", "Score": "9", "OwnerUserId": "458825", "Tags": "<c++><polymorphism><member-function-pointers>", "AnswerCount": "1"}});