post_cb({"38408380": {"Id": "38408380", "PostTypeId": "2", "Body": "<p>I found my self having to identify types fulfilling this feature many times. I don't know if inventing such a special \"concept\" is elegant (imagine that it is a concept that involves memory, which is not very abstract) but I agree something like this will be useful.</p>\n<p>Meanwhile to be practical and <em>translate this concept/requirement into a pure syntax requirement</em>, let's walk backwards. If we restrict ourselves to the standard, what are the classes that guarantee (or almost guarantee) contiguity? in order of relevance:</p>\n<pre><code>std::vector&lt;T&gt;\nT[N] // !!\nstd::array&lt;T, N&gt;\nstd::string\nstd::initializer_list&lt;T&gt;\nstd::valarray&lt;T&gt;\n</code></pre>\n<p>Of all these, <code>std::vector</code>, <code>std::array</code>, <code>std::string</code> have a member function called <code>.data()</code>. So, if this is enough for you, could rely on the presence of member <code>.data() -&gt; T*</code> to indicate contiguous memory.</p>\n<p>You have two options:</p>\n<p>1) Make the <em>effort</em> to use the member function <code>.data()</code> to raise a syntax error if the type is not contiguous. (Not hard if you replace for example <code>t[0]</code> by <code>*t.data()</code>)</p>\n<p>2) Use some kind of SFINAE on <code>.data()</code>.</p>\n<pre><code>template&lt;class ContiguousSequence, typename = decltype(std::declval&lt;ContigiousSequence&gt;().data())&gt;\nvoid fun(ContiguousSequence&amp;&amp; s){...} // this function will only work with contiguous data\n</code></pre>\n<p>Moreover, C++17 has <a href=\"http://en.cppreference.com/w/cpp/iterator/data\" rel=\"nofollow\"><code>std::data</code></a> which generalizes it to all types with <code>.data()</code> and additionally overloads for <code>T[N]</code> and <code>std::initializer_list&lt;T&gt;</code>.\nSo, you can replace <code>....data()</code> by <code>std::data(...)</code> above.</p>\n<blockquote>\n<p id=\"so_15188747_38408380_0\">The conclusion, I think it is a good convention is that\n  if a type has a <code>data</code> function (or <code>.data()</code> in C++11) that returns a pointer to the value type then the elements\n  are contiguous.</p>\n</blockquote>\n<p>(Ok, what about <code>std::valarray&lt;T&gt;</code>? It doesn't work, unless you overload <code>std::data(std::valarray&lt;T&gt;&amp;)</code>. But who uses <code>std::valarray</code> anyway? it is a pretty abandoned corner of C++, I think)</p>\n<p>Finally, note for example that obviously <code>std::map</code> and less obviously <code>std::deque</code> don't have a <code>.data()</code> (or <code>std::data(...)</code>) function. <code>boost::multi_array&lt;..., N&gt;</code> has a <code>.data()</code> member and returns a pointer to the array element, it is not clear if this is contiguous sequence in the sense you want (because the order is not obvious) but in some sense it is also a contiguous allocation of memory.</p>\n<p><strong>EDIT:</strong>\nThere are two proposals currently addressing this issue (but at the level of the iterators) <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3884.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3884.pdf</a> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4284.html\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4284.html</a></p>\n", "LastEditorUserId": "225186", "LastActivityDate": "2016-09-09T18:05:42.613", "Score": "1", "CreationDate": "2016-07-16T06:18:59.573", "ParentId": "15188747", "CommentCount": "0", "OwnerUserId": "225186", "LastEditDate": "2016-09-09T18:05:42.613"}, "bq_ids": {"n4140": {"so_15188747_38409783_0": {"length": 9, "quality": 0.5625, "section_id": 763}, "so_15188747_15510314_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}}, "n3337": {"so_15188747_38409783_0": {"length": 9, "quality": 0.5625, "section_id": 750}, "so_15188747_15510314_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}}, "n4659": {"so_15188747_38409783_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7005}, "so_15188747_38409783_0": {"length": 13, "quality": 0.8125, "section_id": 743}}}, "15188747": {"ViewCount": "481", "Body": "<p>The C++ standard library provides a variety of \"Concepts\" which are used to specify an interface for container objects.  For example, <code>std::vector</code> implements the <code>Container</code>, <code>Sequence</code>, <code>RandomAccessContainer</code>, and <code>ReversibleContainer</code> concepts.  </p>\n<p>Is there a Concept, specified either in C++03 or C++11, that describes a <code>Sequence</code> which guarantees contiguous memory between elements, so that:</p>\n<p><code>static_cast&lt;void*&gt;(&amp;some_sequence[N]) == static_cast&lt;void*&gt;(&amp;some_sequence[0] + N)&gt;</code></p>\n<p>This would be a useful concept because it tells you whether you can use the Container with any function that expects a contiguous memory buffer, such as <code>std::istream::read</code>.</p>\n<p>I know that, in practice, only <code>std::vector</code> (and I think <code>std::string</code> in C++11 only) actually guarantee an underlying contiguous buffer - but is this guarantee unique to <code>std::vector</code> or is there a defined \"Concept\" that indicates a generic <code>Sequence</code> class that provides contiguous memory?</p>\n", "Title": "C++ Contiguous Sequence Concept", "CreationDate": "2013-03-03T17:53:21.380", "LastActivityDate": "2016-09-09T18:05:42.613", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-07-16T11:04:12.250", "LastEditorUserId": "3309790", "Id": "15188747", "Score": "7", "OwnerUserId": "469408", "Tags": "<c++><c++11><containers><std><language-lawyer>", "AnswerCount": "3"}, "15510314": {"Id": "15510314", "PostTypeId": "2", "Body": "<p>From the C++03, only <code>std::vector</code> guarantees that (23.2.4.1):</p>\n<blockquote>\n<p id=\"so_15188747_15510314_0\">The elements of a vector are stored\n  contiguously, meaning that if v is a\n  vector where T is some\n  type other than bool, then it obeys\n  the identity &amp;v[n] == &amp;v[0] + n for\n  all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>C++11 added std::array, which a wrapper around fixed-size arrays and would also have the same properties. I don't think there is a way to know if any container has such property.</p>\n", "LastActivityDate": "2013-03-19T20:59:15.603", "CommentCount": "0", "CreationDate": "2013-03-19T20:59:15.603", "ParentId": "15188747", "Score": "0", "OwnerUserId": "401200"}, "38409783": {"Id": "38409783", "PostTypeId": "2", "Body": "<p>\"Contiguous container\" is specifed in C++17. From <a href=\"http://eel.is/c++draft/containers#container.requirements.general-13\" rel=\"nofollow\">$23.2.1/13 General container requirements [container.requirements.general]</a>:</p>\n<blockquote>\n<p id=\"so_15188747_38409783_0\">A contiguous container is a container that supports random access iterators ([random.access.iterators]) and whose member types iterator and const_iterator are contiguous iterators ([iterator.requirements.general]).</p>\n</blockquote>\n<p>And about \"contiguous iterators\", <a href=\"http://eel.is/c++draft/iterator.requirements.general#5\" rel=\"nofollow\">$24.2.1/5 In general\n[iterator.requirements.general]</a>:</p>\n<blockquote>\n<p id=\"so_15188747_38409783_1\">Iterators that further satisfy the requirement that, for integral values n and dereferenceable iterator values a and (a + n), *(a + n) is equivalent to *(addressof(*a) + n), are called contiguous iterators.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/vector.overview#2\" rel=\"nofollow\">std::vector</a> (except for <code>std::vector&lt;bool&gt;</code>), <a href=\"http://eel.is/c++draft/array.overview#1\" rel=\"nofollow\">std::array</a> and <a href=\"http://eel.is/c++draft/basic.string#3\" rel=\"nofollow\">std::basic_string</a> are contiguous containers.</p>\n", "LastActivityDate": "2016-07-16T09:41:44.333", "CommentCount": "2", "CreationDate": "2016-07-16T09:41:44.333", "ParentId": "15188747", "Score": "3", "OwnerUserId": "3309790"}});