post_cb({"bq_ids": {"n4140": {"so_28058371_28058430_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 3299}, "so_28058371_28058430_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}, "so_28058371_28058430_3": {"length": 33, "quality": 0.9705882352941176, "section_id": 599}}, "n3337": {"so_28058371_28058430_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 3169}, "so_28058371_28058430_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}, "so_28058371_28058430_3": {"length": 33, "quality": 0.9705882352941176, "section_id": 589}}, "n4659": {"so_28058371_28058430_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 4065}, "so_28058371_28058430_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}, "so_28058371_28058430_3": {"length": 33, "quality": 0.9705882352941176, "section_id": 622}}}, "28058430": {"Id": "28058430", "PostTypeId": "2", "Body": "<p>The behavior makes sense. Scott Meyers has an example almost exactly like this in Effective Modern C++ (emphasis in original):</p>\n<blockquote>\n<p id=\"so_28058371_28058430_0\">If, however, one or more constructors declare a parameter of type <code>std::initializer_list</code>, calls using the braced initialization syntax strongly prefer the overloads taking <code>std;:initializer_list</code>s. <em>Strongly</em>. If there's <em>any way</em> for compilers to construe a call using a braced initializer to be a constructor taking a <code>std::initializer_list</code>, compilers will employ that interpretation.</p>\n</blockquote>\n<p>Example using this class:</p>\n<pre><code>class Widget {\npublic:\n    Widget(int, bool);\n    Widget(int, double);\n    Widget(std::initializer_list&lt;long double&gt;);\n};\n\nWidget w1(10, true); // calls first ctor\nWidget w2{10, true}; // calls std::initializer_list ctor\nWidget w3(10, 5.0); // calls second ctor\nWidget w4{10, 5.0}; // calls std::initializer_list ctor\n</code></pre>\n<p>Those two calls call the <code>initializer_list</code> ctor even though they involve converting BOTH arguments - and even though the other constructors are perfect matches. </p>\n<p>Furthermore:</p>\n<blockquote>\n<p id=\"so_28058371_28058430_1\">Compilers' determination to match braced initializers with constructors taking <code>std::initializer_list</code>s is so strong, it prevails even if the best-match <code>std::initializer_list</code> constructor can't be called. For example:</p>\n<pre><code>class Widget {\npublic:\n    Widget(int, bool); // as before\n    Widget(int, double); // as before\n    Widget(std::initializer_list&lt;bool&gt; ); // now bool\n};\n\nWidget w{10, 5.0}; // error! requires narrowing conversions\n</code></pre>\n</blockquote>\n<p>Both compilers pick the correct overload (the <code>initializer_list</code> one) - which we can see is required from the standard (\u00a713.3.1.7):</p>\n<blockquote>\n<p id=\"so_28058371_28058430_2\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor\n  in two phases:</p>\n<p id=\"so_28058371_28058430_3\">(1.1) \u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the\n  argument list consists of the initializer list as a single argument.<br>\n  (1.2) \u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the\n  candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements\n  of the initializer list.</br></p>\n</blockquote>\n<p>But calling that particular constructor involves a narrowing. In 8.5.1:</p>\n<blockquote>\n<p id=\"so_28058371_28058430_4\">If the <em>initializer-clause</em> is an expression\n  and a narrowing conversion (8.5.4) is required to convert the expression, the program is ill-formed.</p>\n</blockquote>\n<p>So the program is ill-formed. In this case, clang chooses to throw an error while gcc chooses to issue a warning. Both compilers are conforming. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-01-21T02:23:47.430", "Score": "11", "CreationDate": "2015-01-21T02:05:15.993", "ParentId": "28058371", "CommentCount": "9", "OwnerUserId": "2069064", "LastEditDate": "2015-01-21T02:23:47.430"}, "28058371": {"ViewCount": "780", "Body": "<p>The below fails to compile with <code>clang35 -std=c++11</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;initializer_list&gt;\n\nclass A\n{\n public:\n  A(int, bool) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n  A(int, double) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n  A(std::initializer_list&lt;int&gt;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; }\n};\n\nint main()\n{\n  A a1 = {1, 1.0};\n  return 0;\n}\n</code></pre>\n<p>with error</p>\n<pre><code>init.cpp:15:14: error: type 'double' cannot be narrowed to 'int' in initializer list [-Wc++11-narrowing]\n  A a1 = {1, 1.0};\n             ^~~\ninit.cpp:15:14: note: insert an explicit cast to silence this issue\n  A a1 = {1, 1.0};\n             ^~~\n             static_cast&lt;int&gt;( )\n</code></pre>\n<p>OTOH, it warns about the narrowing and compiles on <code>g++48 -std=c++11</code></p>\n<pre><code>init.cpp: In function \u2018int main()\u2019:\ninit.cpp:15:17: warning: narrowing conversion of \u20181.0e+0\u2019 from \u2018double\u2019 to \u2018int\u2019 inside { } [-Wnarrowing]\n   A a1 = {1, 1.0};\n                 ^\ninit.cpp:15:17: warning: narrowing conversion of \u20181.0e+0\u2019 from \u2018double\u2019 to \u2018int\u2019 inside { } [-Wnarrowing]\n</code></pre>\n<p>and produces the result</p>\n<pre><code>A::A(std::initializer_list&lt;int&gt;)\n</code></pre>\n<p>Does either behaviour make sense? Quoting from <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\">cppreference</a></p>\n<blockquote>\n<p id=\"so_28058371_28058371_0\">All constructors that take std::initializer_list as the only argument,\n  or as the first argument if the remaining arguments have default\n  values, are examined, and matched by overload resolution against a\n  single argument of type std::initializer_list </p>\n<p id=\"so_28058371_28058371_1\">If the previous stage does not produce a match, all constructors of T\n  participate in overload resolution against the set of arguments that\n  consists of the elements of the braced-init-list, with the restriction\n  that only non-narrowing conversions are allowed. If this stage\n  produces an explicit constructor as the best match for a\n  copy-list-initialization, compilation fails (note, in simple\n  copy-initialization, explicit constructors are not considered at all)</p>\n</blockquote>\n<p>Since narrowing conversions aren't allowed, I would expect the overload resolution step to not match the <code>A(std::initializer_list&lt;int&gt;)</code> constructor and instead match the <code>A(int, double)</code> one. For example, changing <code>A(std::initializer_list&lt;int&gt;)</code> to <code>A(std::initializer_list&lt;std::string&gt;)</code> compiles with both <code>clang35</code> and <code>g++48</code> and prints</p>\n<pre><code>A::A(int, double)\n</code></pre>\n<p>as expected.</p>\n", "AcceptedAnswerId": "28058430", "Title": "List-initialization and failed overload resolution of initializer_list constructor", "CreationDate": "2015-01-21T01:58:45.993", "Id": "28058371", "CommentCount": "2", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-02-07T04:24:19.683", "LastEditorUserId": "2069064", "LastActivityDate": "2015-02-07T04:24:19.683", "Score": "11", "OwnerUserId": "862351", "Tags": "<c++><c++11><overload-resolution><list-initialization>", "AnswerCount": "1"}});