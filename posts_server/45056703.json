post_cb({"45057356": {"ParentId": "45056703", "CommentCount": "9", "Body": "<p>From <a href=\"http://eel.is/c++draft/expr.prim.lambda#capture-10.sentence-2\" rel=\"noreferrer\">expr.prim.lambda.capture</a>:</p>\n<blockquote>\n<p id=\"so_45056703_45057356_0\">For each entity captured by copy, an unnamed non-static data member is declared in the closure type.</p>\n</blockquote>\n<p>While the lambdas here have no capture:</p>\n<pre><code>auto f = node{[]{ }}.then([]{ }).then([]{ });\n</code></pre>\n<p>and hence have no unnamed non-static data members, and hence are empty, that's not what <code>then()</code> actually uses. It uses this:</p>\n<pre><code>return ::node{[p = std::move(*this), t = std::move(f_then)](){}};\n</code></pre>\n<p><em>that</em> lambda captures <code>t</code> and <code>p</code> by copy, and hence has two unnamed non-static data members. Each <code>.then()</code> adds another member variable, even if each one is empty, hence the size of the node keeps going up. </p>\n<p>Or in other words, the empty base optimization only applies to bases, and capture for lambdas doesn't create bases, it creates non-static data members.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "45057356", "Score": "10", "CreationDate": "2017-07-12T12:10:35.133", "LastActivityDate": "2017-07-12T12:10:35.133"}, "45063504": {"ParentId": "45056703", "LastEditDate": "2017-07-12T18:05:11.947", "CommentCount": "3", "CreationDate": "2017-07-12T16:50:05.647", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "PostTypeId": "2", "Id": "45063504", "Score": "3", "Body": "<p>As others have noted, lambdas are specified to capture as member variables not as bases.  So you are out of luck.</p>\n<p>What you <em>could</em> do is take a page from bind.</p>\n<p>Suppose you have a tuple that <em>does</em> use empty base optimization.  Then we can write a helper:</p>\n<pre><code>template&lt;class Sig&gt;\nstruct lambda_ebo_t;\ntemplate&lt;class F, class...Args&gt;\nstruct lambda_ebo_t&lt;F(Args...)&gt;:\n  private std::tuple&lt;Args...&gt;,\n  private F\n{\n  decltype(auto) operator()(){\n    return std::apply( (F&amp;)*this, (std::tuple&lt;Args...&gt;&amp;)*this );\n  }\n  template&lt;class...Ts&gt;\n  lambda_ebo_t( F f, Ts&amp;&amp;...ts ):\n    std::tuple&lt;Args...&gt;( std::forward&lt;Ts&gt;(ts)... ),\n    F( std::move(f) )\n  {}\n};\n\ntemplate&lt;class F, class...Args&gt;\nlambda_ebo_t&lt;F, std::decay_t&lt;Args&gt;...&gt;\nlambda_ebo( F f, Args&amp;&amp;...args ) {\n  return {std::move(f), std::forward&lt;Args&gt;(args)...};\n}\n</code></pre>\n<p>That is a bunch of boilerplate, and incomplete (reference capture may not work right even if you use <code>std::ref</code>), but it gives us:</p>\n<pre><code>template &lt;typename FThen&gt;\nauto then(FThen&amp;&amp; f_then)\n{\n    return ::node{lambda_ebo([](auto&amp;&amp; p, auto&amp;&amp; t)\n    {   \n    }, std::move(*this), std::move(f_then))};\n}\n</code></pre>\n<p>where we store the data outside the lambda and pass it in as arguments to the lambda.  The storage uses EBO.</p>\n<p>No need to write a custom EBO class for each lambda, just a few hoops to jump through when you need a lambda with EBO enabled.</p>\n<p>This is one without using the tuple, but it doesn't support fundamantal types like <code>int</code> or other things you cannot derive from:</p>\n<pre><code>template&lt;class Sig&gt;\nstruct lambda_ebo_t;\ntemplate&lt;class F, class...Args&gt;\nstruct lambda_ebo_t&lt;F(Args...)&gt;:\n  private Args...,\n//  private std::tuple&lt;Args...&gt;,\n  private F\n{\n  decltype(auto) operator()(){\n    //return std::apply( (F&amp;)*this, (std::tuple&lt;Args...&gt;&amp;)*this );\n    return ((F&amp;)(*this))((Args&amp;)*this...);\n  }\n  template&lt;class...Ts&gt;\n  lambda_ebo_t( F f, Ts&amp;&amp;...ts ):\n    Args(std::forward&lt;Ts&gt;(ts))...,\n    F( std::move(f) )\n  {}\n};\n\ntemplate&lt;class F, class...Args&gt;\nlambda_ebo_t&lt;F(std::decay_t&lt;Args&gt;...)&gt;\nlambda_ebo( F f, Args&amp;&amp;...args ) {\n  return {std::move(f), std::forward&lt;Args&gt;(args)...};\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/00ee4b1a641ed7b5\" rel=\"nofollow noreferrer\">Live example</a>, with this test code:</p>\n<pre><code>auto test = lambda_ebo( [](auto&amp;&amp;...args){std::cout &lt;&lt; sizeof...(args) &lt;&lt; \"\\n\";}, []{} , []{}, []{}, []{}, []{}, []{}, []{}, []{}); //\nstd::cout &lt;&lt; \"bytes:\" &lt;&lt; sizeof(test) &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"args:\";\ntest();\n</code></pre>\n<p><code>sizeof(test)</code> is <code>1</code>, and it \"captures\" 8 arguments.</p>\n", "LastActivityDate": "2017-07-12T18:05:11.947"}, "45066215": {"ParentId": "45056703", "CommentCount": "2", "Body": "<p>Given the as-if rule and <a href=\"https://timsong-cpp.github.io/cppwp/expr.prim.lambda.closure#2\" rel=\"nofollow noreferrer\">[expr.prim.lambda.closure]/2</a>:</p>\n<blockquote>\n<p id=\"so_45056703_45066215_0\">An implementation may define the closure type differently from what is\n  described below provided this does not alter the observable behavior\n  of the program other than by changing:</p>\n<ul>\n<li>the size and/or alignment of the closure type,</li>\n<li>whether the closure type is trivially copyable (Clause [class]),</li>\n<li>whether the closure type is a standard-layout class (Clause [class]), or</li>\n<li>whether the closure type is a POD class (Clause [class]).</li>\n</ul>\n</blockquote>\n<p>I don't see anything preventing an implementation from using some kind of magic to optimize away the storage for the captured empty variable.</p>\n<p>That said, doing so would be an ABI break, so don't hold your breath.</p>\n<hr>\n<p>Allowing - or requiring - an implementation to make the type of a captured empty variable a <em>base</em> of the closure type, on the other hand, would be a horrendously bad idea. Consider:</p>\n<pre><code>struct X { };\nstruct Y { };\nvoid meow(X x);                     // #1\nvoid meow(Y y);                     // #2\nvoid meow(std::function&lt;void()&gt; f); // #3\n\ntemplate&lt;class T, class U&gt;\nvoid purr(T t, U u) {\n    meow([t = std::move(t), u = std::move(u)] { /* ... */ });\n}\n</code></pre>\n<p>It would be insane for <code>purr</code> to do anything other than call #3, yet if captures can become bases then it can call #1, or #2, or be ambiguous.</p>\n</hr>", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "45066215", "Score": "4", "CreationDate": "2017-07-12T19:39:03.363", "LastActivityDate": "2017-07-12T19:39:03.363"}, "45057568": {"ParentId": "45056703", "LastEditDate": "2017-07-12T12:26:55.627", "CommentCount": "0", "CreationDate": "2017-07-12T12:20:49.997", "OwnerUserId": "817643", "LastEditorUserId": "817643", "PostTypeId": "2", "Id": "45057568", "Score": "4", "Body": "<p>The other answers have the cause, so I will not re-iterate. I will just add that I was able to turn your example into an inheritance based one without too much boilerplate. Since you do public inheritance in the OP, I opted to remove the c'tor and go for aggregate initialization.</p>\n<p>It only required two deduction guides to make the code almost as pretty as your original scheme:</p>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/43489af3c28f9f20\" rel=\"nofollow noreferrer\">Live on Coliru</a></kbd></p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\nstruct empty {\n    void operator()() {}\n};\n\ntemplate &lt;typename P, typename T&gt;\nstruct node : P, T\n{\n    template &lt;typename FThen&gt;\n    auto then(FThen&amp;&amp; f_then)\n    {\n        return ::node{std::move(*this), std::forward&lt;FThen&gt;(f_then)};\n    }\n\n    void operator()() {\n        P::operator()();\n        T::operator()();\n    }\n};\n\ntemplate &lt;typename P&gt;             node(P)    -&gt; node&lt;P, ::empty&gt;;\ntemplate &lt;typename P, typename T&gt; node(P, T) -&gt; node&lt;P, T&gt;;\n\nint main()\n{\n    auto f = node{[]{ }}.then([]{ }).then([]{ });\n    std::cout &lt;&lt; sizeof(f);\n}   \n</code></pre>\n<p>The EBO was applied, as you can see by following the link.</p>\n<p>BTW, since we are are moving <code>*this</code>, it may be worth to r-value qualify <code>node::then</code>. Just to avoid any nastiness.</p>\n", "LastActivityDate": "2017-07-12T12:26:55.627"}, "45056927": {"ParentId": "45056703", "LastEditDate": "2017-07-12T12:05:40.000", "CommentCount": "4", "CreationDate": "2017-07-12T11:50:20.510", "OwnerUserId": "5501675", "LastEditorUserId": "5501675", "PostTypeId": "2", "Id": "45056927", "Score": "2", "Body": "<p>Empty base optimization works for me in the following case</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate &lt;typename F&gt;\nclass Something : public F {\npublic:\n    Something(F&amp;&amp; f_in) : F{std::move(f_in)} {}\n};\n\nint main() {\n    auto something = Something{[]{}};\n    static_assert(sizeof(decltype(something)) == 1);\n}\n</code></pre>\n<p>Live example here <a href=\"https://wandbox.org/permlink/J4m4epDUs19kp5CH\" rel=\"nofollow noreferrer\">https://wandbox.org/permlink/J4m4epDUs19kp5CH</a></p>\n<p>My guess is that the reason it's not working in your case is that the lambda you use in the <code>then()</code> method is not actually empty, it has member variables - the ones listed in your capture.  So there is no real empty base there.  </p>\n<p>If you change the last line of your code to just return <code>node{[]{}}</code> then it works.  The lambdas used by <code>.then()</code> do not materialize as \"empty\" classes. </p>\n<p>Whereas in the explicit struct case, it has no member variables per se, only classes it derives from, hence empty base optimization can work there. </p>\n", "LastActivityDate": "2017-07-12T12:05:40.000"}, "45056703": {"CommentCount": "1", "CreationDate": "2017-07-12T11:41:18.603", "PostTypeId": "1", "AcceptedAnswerId": "45057356", "LastEditorUserId": "734069", "LastActivityDate": "2017-09-06T17:50:55.197", "LastEditDate": "2017-09-06T17:50:55.197", "ViewCount": "279", "FavoriteCount": "5", "Title": "\"Empty base optimization\" for lambda captures - forbidden by the Standard? Why?", "Id": "45056703", "Score": "9", "Body": "<p>I recently came across a situation where I ended up with a large number of nested lambdas to <a href=\"https://vittorioromeo.info/index/blog/zeroalloc_continuations_p0.html\" rel=\"noreferrer\">build asynchronous computation chains</a>. </p>\n<pre><code>template &lt;typename F&gt;\nstruct node : F\n{\n    node(F&amp;&amp; f) : F{std::move(f)}\n    {\n    }\n\n    template &lt;typename FThen&gt;\n    auto then(FThen&amp;&amp; f_then)\n    {\n        return ::node{[p = std::move(*this), t = std::move(f_then)]()\n        {   \n        }};\n    }\n};\n\nint main()\n{\n    auto f = node{[]{ }}.then([]{ }).then([]{ });\n    return sizeof(f);\n}   \n</code></pre>\n<p>All the objects I capture in my the lambdas are <em>empty</em>, yet the size of the final object is greater than one: <a href=\"https://godbolt.org/g/2Y6pES\" rel=\"noreferrer\">example on <strong>gcc.godbolt.org</strong></a>.</p>\n<p>If I change the lambda inside <code>node&lt;/* ... */&gt;::then</code> to a function object with explicit EBO, the size of the final object becomes one.</p>\n<pre><code>template &lt;typename P, typename T&gt;\nstruct node_lambda : P, T\n{\n    node_lambda(P&amp;&amp; p, T&amp;&amp; t) : P{std::move(p)}, T{std::move(t)}\n    {\n    }\n\n    void operator()()\n    {\n    }\n};\n</code></pre>\n<p></p>\n<pre><code>template &lt;typename FThen&gt;\nauto node&lt;/* ... */&gt;::then(FThen&amp;&amp; f_then)\n{\n    return ::node{node_lambda{std::move(*this), std::move(f_then)}};\n}\n</code></pre>\n<p><a href=\"https://godbolt.org/g/BmyPMY\" rel=\"noreferrer\">Live example on <strong>gcc.godbolt.org</strong></a></p>\n<hr>\n<p>I find this really annoying because I'm forced to either:</p>\n<ul>\n<li><p>Write a lot of boilerplate code that is roughly equivalent to the lambda.</p></li>\n<li><p>Pay an additional memory cost due to the fact that something like EBO doesn't apply to lambda captures.</p></li>\n</ul>\n<p><strong>Is there anything in the Standard that explicitly forces empty lambda captures to take additional space?</strong> If so, why?</p>\n</hr>", "Tags": "<c++><lambda><c++1z>", "OwnerUserId": "598696", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_45056703_45057356_0": {"section_id": 5974, "quality": 0.9166666666666666, "length": 11}, "so_45056703_45066215_0": {"section_id": 5962, "quality": 1.0, "length": 17}}, "n3337": {"so_45056703_45057356_0": {"section_id": 5742, "quality": 0.9166666666666666, "length": 11}, "so_45056703_45066215_0": {"section_id": 5731, "quality": 1.0, "length": 17}}, "n4659": {"so_45056703_45057356_0": {"section_id": 7473, "quality": 0.9166666666666666, "length": 11}, "so_45056703_45066215_0": {"section_id": 7452, "quality": 1.0, "length": 17}}}});