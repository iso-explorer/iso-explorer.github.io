post_cb({"bq_ids": {"n4140": {"so_27317232_27317821_1": {"length": 15, "quality": 1.0, "section_id": 428}}, "n3337": {"so_27317232_27317821_1": {"length": 15, "quality": 1.0, "section_id": 420}}, "n4659": {"so_27317232_27317821_1": {"length": 15, "quality": 1.0, "section_id": 446}}}, "27317232": {"ViewCount": "127", "Body": "<p>Consider the following code:</p>\n<pre><code>class A {\n};\n\nclass B : public A {\n};\n\nclass C : public B{ \n    public:\n    C() : A() {}  // ERROR, A is not a direct base of B\n};\n</code></pre>\n<p>In this case GCC (4.8.1, C++99) gives me the correct error (I understand this behavior):</p>\n<p>prog.cpp:12:8: error: type \u2018a\u2019 is not a direct base of \u2018c\u2019</p>\n<p>However if the inheritance between b and a is virtual, this does not happen:</p>\n<pre><code>class A {\n};\n\nclass B : virtual public A {\n};\n\nclass C : public B{\n    public:\n    C() : A() {}  // OK with virtual inheritance\n};\n</code></pre>\n<p>Why does this work? \nIs A now considered a direct base to C by the compiler?</p>\n", "AcceptedAnswerId": "27317419", "Title": "virtual inheritance and base class of base class", "CreationDate": "2014-12-05T13:42:22.490", "Id": "27317232", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-12-05T15:40:20.973", "Score": "3", "OwnerUserId": "877473", "Tags": "<c++>", "AnswerCount": "3"}, "27317821": {"Id": "27317821", "PostTypeId": "2", "Body": "<p>From N3337, 12.6.2 </p>\n<blockquote>\n<p id=\"so_27317232_27317821_0\"><strong>Initializing bases and members</strong></p>\n<p id=\"so_27317232_27317821_1\">In the definition of a constructor for a class, initializers for <strong>direct and virtual base subobjects</strong> and non-static data members can be specified by a ctor-initializer, which has the form</p>\n</blockquote>\n<p>Perhaps someone who has better version of Standard can verify this.</p>\n", "LastActivityDate": "2014-12-05T14:14:57.930", "CommentCount": "0", "CreationDate": "2014-12-05T14:14:57.930", "ParentId": "27317232", "Score": "0", "OwnerUserId": "205955"}, "27317419": {"Id": "27317419", "PostTypeId": "2", "Body": "<p>Why does this work?</p>\n<p>According to the standard (10.1.4 in the FIDS), \"for each distinct baseclass that is specified virtual, the most derived object shall contain a single base class subobject of that type\".</p>\n<p>Virtual base is shared between all classes that derive from it for the instance of the object. Since a constructor may only be called once for a given instaniation of an object, you have to explicitly call the constructor in the most derived class because the compiler doesn't know how many classes share the virtual base. This is because the compiler will start from the most base class's constructor and work to the most derived class. Classes that inherit from a virtual base class directly, will not, by the standard, call their virtual base classes constructor, so it must be called explicitly.</p>\n", "LastActivityDate": "2014-12-05T13:53:20.470", "CommentCount": "3", "CreationDate": "2014-12-05T13:53:20.470", "ParentId": "27317232", "Score": "0", "OwnerUserId": "4047092"}, "27317656": {"Id": "27317656", "PostTypeId": "2", "Body": "<p>In general, because this is how C++ tries to resolve the diamond inheritance problem <a href=\"http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem</a> (whether or it is a good or bad solution is left as an exercise to the reader).</p>\n<p>All inheritance is a combination of an is-a and a has-a relationship...you must instantiate an instance of the parent. If you have the following classes:</p>\n<pre><code>class a;\nclass b : a;\nclass c : a;\nclass d : b,c;\n</code></pre>\n<p>Then you've instantiated an a for each b and c. d will not know which a to use.</p>\n<p>C++ solves this by allowing virtual inheritance, which is high-overhead inheritance that allows b and c to share the same a if inherited in d (it is much more complicated than that, but you can read  up on that on your own).</p>\n<p>The most derived type in the chain needs to be able to override the instantiation of the shared class to control disparities in the way that the shared class is inherited in the parent classes. Take the following example:</p>\n<pre><code>class a {int x; public: a(int xx) {x=xx;} int get_x() {return x;}};\nclass b : public virtual a { public: b(): a(10){}};\nclass c : public virtual a { public: c(): a(15){}};\nclass d : public virtual b, public virtual c {public: d() : a (20) {}};\nint main() {\n    d dd;\n    std::cout &lt;&lt; dd.get_x() &lt;&lt; std::endl;//20, d's constructor \"wins\"\n    return 0;\n}\n</code></pre>\n<p>If d did not define what <code>a</code> was instantiated as, it would have definitions for conflicting instantiations (from <code>b</code> and <code>c</code>). C++ handles this by forcing the most derived class in the inheritance chain to instantiate all parent classes (the above would barf if <code>d</code> did NOT explicitly instantiate <code>a</code>, though if <code>a</code> supplied a default constructor that could be implicitly used) and ignoring all parent instantiations.</p>\n", "LastEditorUserId": "1756405", "LastActivityDate": "2014-12-05T15:40:20.973", "Score": "2", "CreationDate": "2014-12-05T14:05:59.680", "ParentId": "27317232", "CommentCount": "2", "OwnerUserId": "1756405", "LastEditDate": "2014-12-05T15:40:20.973"}});