post_cb({"11004455": {"Id": "11004455", "PostTypeId": "2", "Body": "<p><a href=\"http://bartoszmilewski.com/2009/03/03/broken-promises-c0x-futures/\">Bartosz Milewski</a> provides a good writeup. </p>\n<blockquote>\n<p id=\"so_11004273_11004455_0\">C++ splits the implementation of futures into a set \n  of small blocks</p>\n</blockquote>\n<p>std::promise is one of these parts. </p>\n<blockquote>\n<p id=\"so_11004273_11004455_1\">A promise is a vehicle for passing the return value (or an \n  exception) from the thread executing a function to the thread \n  that cashes in on the function future. </p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_11004273_11004455_2\">A future is the synchronization object constructed around the \n  receiving end of the promise channel.</p>\n</blockquote>\n<p>So, if you want to use a future, you end up with a promise that you use to get the result of the asynchronous processing. </p>\n<p>An example from the page is:</p>\n<pre><code>promise&lt;int&gt; intPromise;\nfuture&lt;int&gt; intFuture = intPromise.get_future();\nstd::thread t(asyncFun, std::move(intPromise));\n// do some other stuff\nint result = intFuture.get(); // may throw MyException\n</code></pre>\n", "LastActivityDate": "2012-06-12T20:34:59.097", "Score": "29", "CreationDate": "2012-06-12T20:34:59.097", "ParentId": "11004273", "CommentCount": "1", "OwnerUserId": "351984"}, "11004561": {"Id": "11004561", "PostTypeId": "2", "Body": "<p><code>std::promise</code> is the channel or pathway for information to be returned from the async function. <code>std::future</code> is the synchronization mechanism thats makes the caller wait until the return value carried in the <code>std::promise</code> is ready(meaning its value is set inside the function).</p>\n", "LastActivityDate": "2012-06-12T20:42:10.683", "Score": "9", "CreationDate": "2012-06-12T20:42:10.683", "ParentId": "11004273", "CommentCount": "0", "OwnerUserId": "782997"}, "11004368": {"Id": "11004368", "PostTypeId": "2", "Body": "<p>In a rough approximation you can consider <code>std::promise</code> as the other end of a <code>std::future</code> (this is <strong>false</strong>, but for illustration you can think as if it was). The consumer end of the communication channel would use a <code>std::future</code> to consume the datum from the shared state, while the producer thread would use a <code>std::promise</code> to write to the shared state.</p>\n", "LastActivityDate": "2012-06-12T20:30:27.180", "Score": "24", "CreationDate": "2012-06-12T20:30:27.180", "ParentId": "11004273", "CommentCount": "10", "OwnerUserId": "36565"}, "12335206": {"Id": "12335206", "PostTypeId": "2", "Body": "<p>I understand the situation a bit better now (in no small amount due to the answers here!), so I thought I add a little write-up of my own.</p>\n<hr>\n<p>There are two distinct, though related, concepts in C++11: Asynchronous computation (a function that is called somewhere else), and concurrent execution (a <em>thread</em>, something that does work concurrently). The two are somewhat orthogonal concepts. Asynchronous computation is just a different flavour of func\u00adtion call, while a thread is an execution context. Threads are useful in their own right, but for the pur\u00adpose of this discussion, I will treat them as an implementation detail.</p>\n<p><br/></p>\n<p>There is a hierarchy of abstraction for asynchronous computation. For example's sake, suppose we have a function that takes some arguments:</p>\n<pre><code>int foo(double, char, bool);\n</code></pre>\n<p>First off, we have the template <a href=\"http://en.cppreference.com/w/cpp/thread/future\" rel=\"noreferrer\"><code>std::future&lt;T&gt;</code></a>, which represents a future value of type <code>T</code>. The val\u00adue can be retrieved via the member function <code>get()</code>, which effectively synchronizes the program by wait\u00ading for the result. Alternatively, a future supports <code>wait_for()</code>, which can be used to probe whether or not the result is already available. Futures should be thought of as the asynchronous drop-in re\u00adplace\u00adment for ordinary return types. For our example function, we expect a <code>std::future&lt;int&gt;</code>.</p>\n<p>Now, on to the hierarchy, from highest to lowest level:</p>\n<ol>\n<li><p><a href=\"http://en.cppreference.com/w/cpp/thread/async\" rel=\"noreferrer\"><code>std::async</code></a>: The most convenient and straight-forward way to perform an asynchronous com\u00adpu\u00adta\u00adtion is via the <code>async</code> function template, which returns the matching future immediately:</p>\n<pre><code>auto fut = std::async(foo, 1.5, 'x', false);  // is a std::future&lt;int&gt;\n</code></pre>\n<p>We have very little control over the details. In particular, we don't even know if the function is exe\u00adcu\u00adted concurrently, serially upon <code>get()</code>, or by some other black magic. However, the result is easily ob\u00adtained when needed:</p>\n<pre><code>auto res = fut.get();  // is an int\n</code></pre></li>\n<li><p>We can now consider how to <em>implement</em> something like <code>async</code>, but in a fashion that <em>we</em> control. For example, we may insist that the function be executed in a separate thread. We already know that we can provide a separate thread by means of the <a href=\"http://en.cppreference.com/w/cpp/thread/thread\" rel=\"noreferrer\"><code>std::thread</code></a> class.</p>\n<p>The next lower level of abstraction does exactly that: <a href=\"http://en.cppreference.com/w/cpp/thread/packaged_task\" rel=\"noreferrer\"><code>std::packaged_task</code></a>. This is a template that wraps a function and provides a future for the functions return value, but the object itself is call\u00adable, and calling it is at the user's discretion. We can set it up like this:</p>\n<pre><code>std::packaged_task&lt;int(double, char, bool)&gt; tsk(foo);\n\nauto fut = tsk.get_future();    // is a std::future&lt;int&gt;\n</code></pre>\n<p>The future becomes ready once we call the task and the call completes. This is the ideal job for a se\u00adpa\u00adrate thread. We just have to make sure to <em>move</em> the task into the thread:</p>\n<pre><code>std::thread thr(std::move(tsk), 1.5, 'x', false);\n</code></pre>\n<p>The thread starts running immediately. We can either <code>detach</code> it, or have <code>join</code> it at the end of the scope, or whenever (e.g. using Anthony Williams's <code>scoped_thread</code> wrapper, which really should be in the standard library). The details of using <code>std::thread</code> don't concern us here, though; just be sure to join or detach <code>thr</code> eventually. What matters is that whenever the function call finishes, our result is ready:</p>\n<pre><code>auto res = fut.get();  // as before\n</code></pre></li>\n<li><p>Now we're down to the lowest level: How would we <em>implement</em> the packaged task? This is where the <a href=\"http://en.cppreference.com/w/cpp/thread/promise\" rel=\"noreferrer\"><code>std::promise</code></a> comes in. The promise is the building block for communicating with a future. The principal steps are these:</p>\n<ul>\n<li><p>The calling thread makes a promise.</p></li>\n<li><p>The calling thread obtains a future from the promise.</p></li>\n<li><p>The promise, along with function arguments, are moved into a separate thread.</p></li>\n<li><p>The new thread executes the function and populates fulfills the promise.</p></li>\n<li><p>The original thread retrieves the result.</p></li>\n</ul>\n<p>As an example, here's our very own \"packaged task\":</p>\n<pre><code>template &lt;typename&gt; class my_task;\n\ntemplate &lt;typename R, typename ...Args&gt;\nclass my_task&lt;R(Args...)&gt;\n{\n    std::function&lt;R(Args...)&gt; fn;\n    std::promise&lt;R&gt; pr;             // the promise of the result\npublic:\n    template &lt;typename ...Ts&gt;\n    explicit my_task(Ts &amp;&amp;... ts) : fn(std::forward&lt;Ts&gt;(ts)...) { }\n\n    template &lt;typename ...Ts&gt;\n    void operator()(Ts &amp;&amp;... ts)\n    {\n        pr.set_value(fn(std::forward&lt;Ts&gt;(ts)...));  // fulfill the promise\n    }\n\n    std::future&lt;R&gt; get_future() { return pr.get_future(); }\n\n    // disable copy, default move\n};\n</code></pre>\n<p>Usage of this template is essentially the same as that of <code>std::packaged_task</code>. Note that moving the entire task subsumes moving the promise. In more ad-hoc situations, one could also move a promise object explicitly into the new thread and make it a function argument of the thread function, but a task wrapper like the one above seems like a more flexible and less intrusive solution.</p></li>\n</ol>\n<hr>\n<h2>Making exceptions</h2>\n<p>Promises are intimately related to exceptions. The interface of a promise alone is not enough to convey its state completely, so exceptions are thrown whenever an operation on a promise does not make sense. All exceptions are of type <code>std::future_error</code>, which derives from <code>std::logic_error</code>. First off, a description of some constraints:</p>\n<ul>\n<li><p>A default-constructed promise is inactive. Inactive promises can die without consequence.</p></li>\n<li><p>A promise becomes active when a future is obtained via <code>get_future()</code>. However, only <em>one</em> future may be obtained!</p></li>\n<li><p>A promise must either be satisfied via <code>set_value()</code> or have an exception set via <code>set_exception()</code> before its lifetime ends if its future is to be consumed. A satisfied promise can die without consequence, and <code>get()</code> becomes available on the future. A promise with an exception will raise the stored exception upon call of <code>get()</code> on the future. If the promise dies with neither value nor exception, calling <code>get()</code> on the future will raise a \"broken promise\" exception.</p></li>\n</ul>\n<p>Here is a little test series to demonstrate these various exceptional behaviours. First, the harness:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;future&gt;\n#include &lt;exception&gt;\n#include &lt;stdexcept&gt;\n\nint test();\n\nint main()\n{\n    try\n    {\n        return test();\n    }\n    catch (std::future_error const &amp; e)\n    {\n        std::cout &lt;&lt; \"Future error: \" &lt;&lt; e.what() &lt;&lt; \" / \" &lt;&lt; e.code() &lt;&lt; std::endl;\n    }\n    catch (std::exception const &amp; e)\n    {\n        std::cout &lt;&lt; \"Standard exception: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n    catch (...)\n    {\n        std::cout &lt;&lt; \"Unknown exception.\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>Now on to the tests.</p>\n<p><strong>Case 1: Inactive promise</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    return 0;\n}\n// fine, no problems\n</code></pre>\n<p><strong>Case 2: Active promise, unused</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    auto fut = pr.get_future();\n    return 0;\n}\n// fine, no problems; fut.get() would block indefinitely\n</code></pre>\n<p><strong>Case 3: Too many futures</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    auto fut1 = pr.get_future();\n    auto fut2 = pr.get_future();  //   Error: \"Future already retrieved\"\n    return 0;\n}\n</code></pre>\n<p><strong>Case 4: Satisfied promise</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    auto fut = pr.get_future();\n\n    {\n        std::promise&lt;int&gt; pr2(std::move(pr));\n        pr2.set_value(10);\n    }\n\n    return fut.get();\n}\n// Fine, returns \"10\".\n</code></pre>\n<p><strong>Case 5: Too much satisfaction</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    auto fut = pr.get_future();\n\n    {\n        std::promise&lt;int&gt; pr2(std::move(pr));\n        pr2.set_value(10);\n        pr2.set_value(10);  // Error: \"Promise already satisfied\"\n    }\n\n    return fut.get();\n}\n</code></pre>\n<p>The same exception is thrown if there is more than one of <em>either</em> of <code>set_value</code> or <code>set_exception</code>.</p>\n<p><strong>Case 6: Exception</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    auto fut = pr.get_future();\n\n    {\n        std::promise&lt;int&gt; pr2(std::move(pr));\n        pr2.set_exception(std::make_exception_ptr(std::runtime_error(\"Booboo\")));\n    }\n\n    return fut.get();\n}\n// throws the runtime_error exception\n</code></pre>\n<p><strong>Case 7: Broken promise</strong></p>\n<pre><code>int test()\n{\n    std::promise&lt;int&gt; pr;\n    auto fut = pr.get_future();\n\n    {\n        std::promise&lt;int&gt; pr2(std::move(pr));\n    }   // Error: \"broken promise\"\n\n    return fut.get();\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "596781", "LastActivityDate": "2016-08-21T10:06:08.763", "Score": "387", "CreationDate": "2012-09-08T23:10:05.543", "ParentId": "11004273", "CommentCount": "17", "LastEditDate": "2016-08-21T10:06:08.763", "OwnerUserId": "596781"}, "21321550": {"Id": "21321550", "PostTypeId": "2", "Body": "<p>There are really 3 core entities in asynchronous processing. C++11 currently focuses on 2 of them.<br/></p>\n<p>The core things you need to run some logic asynchronously are:<br/></p>\n<ol>\n<li>The <em>task</em> (logic packaged as some functor object) that will RUN 'somewhere'.<br/></li>\n<li>The <em>actual processing node</em> - a thread, a process, etc. that RUNS such functors when they are provided to it. Look at the \"Command\" design pattern for a good idea of how a basic worker thread pool does this.</li>\n<li>The <em>result handle</em>: Somebody needs that result, and needs an object that will GET it for them. For OOP and other reasons, any waiting or synchronization should be done in this handle's APIs.</li>\n</ol>\n<p>C++11 calls the things I speak of in (1) <code>std::promise</code>, and those in (3) <code>std::future</code>.\n<code>std::thread</code> is the only thing provided publicly for (2). This is unfortunate because real programs need to manage thread &amp; memory resources, and most will want tasks to run on thread pools instead of creating &amp; destroying a thread for every little task (which almost always causes unnecessary performance hits by itself and can easily create resource starvation that is even worse).<br/></p>\n<p>According to Herb Sutter and others in the C++11 brain trust, there are tentative plans to add a <code>std::executor</code> that- much like in Java- will be the basis for thread pools and logically similar setups for (2). Maybe we'll see it in C++2014, but my bet is more like C++17 (and God help us if they botch the standard for these). </p>\n", "LastEditorUserId": "832363", "LastActivityDate": "2014-04-28T08:10:42.357", "Score": "6", "CreationDate": "2014-01-23T23:33:14.913", "ParentId": "11004273", "CommentCount": "0", "LastEditDate": "2014-04-28T08:10:42.357", "OwnerUserId": "1937375"}, "bq_ids": {"n4140": {"so_11004273_11004455_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 3161}}, "n3337": {"so_11004273_11004455_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 3034}}, "n4659": {"so_11004273_11004455_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 3923}}}, "34914562": {"Id": "34914562", "PostTypeId": "2", "Body": "<p>A <code>std::promise</code> is created as an end point for a promise/future pair and the <code>std::future</code> (created from the std::promise using the <code>get_future()</code> method) is the other end point. This is a simple, one shot method of providing a way for two threads to synchronize as one thread provides data to another thread through a message.</p>\n<p>You can think of it as one thread creates a promise to provide data and the other thread collects the promise in the future. This mechanism can only be used once.</p>\n<p>The promise/future mechanism is only one direction, from the thread which uses the <code>set_value()</code> method of a <code>std::promise</code> to the thread which uses the <code>get()</code> of a <code>std::future</code> to receive the data. An exception is generated if the <code>get()</code> method of a future is called more than once.</p>\n<p>If the thread with the <code>std::promise</code> has not used <code>set_value()</code> to fulfill its promise then when the second thread calls <code>get()</code> of the <code>std::future</code> to collect the promise, the second thread will go into a wait state until the promise is fulfilled by the first thread with the <code>std::promise</code> when it uses the <code>set_value()</code> method to send the data.</p>\n<p>The following example code, a simple Visual Studio 2013 Windows console application, shows using a few of the C++11 concurrency classes/templates and other functionality. It illustrates a use for promise/future which works well, autonomous threads which will do some task and stop, and a use where more synchronous behavior is required and due to the need for multiple notifications the promise/future pair does not work.</p>\n<p>One note about this example is the delays added in various places. These delays were added only to make sure that the various messages printed to the console using <code>std::cout</code> would be clear and that text from the several threads would not be intermingled.</p>\n<p>The first part of the <code>main()</code> is creating three additional threads and using <code>std::promise</code> and <code>std::future</code> to send data between the threads. An interesting point is where the main thread starts up a thread, T2, which will wait for data from the main thread, do something, and then send data to the third thread, T3, which will then do something and send data back to the main thread.</p>\n<p>The second part of the <code>main()</code> creates two threads and a set of queues to allow multiple messages from the main thread to each of the two created threads. We can not use <code>std::promise</code> and <code>std::future</code> for this because the promise/future duo are one shot and can not be use repeatedly.</p>\n<p>The source for the class <code>Sync_queue</code> is from Stroustrup's The C++ Programming Language: 4th Edition.</p>\n<pre><code>// cpp_threads.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include &lt;iostream&gt;\n#include &lt;thread&gt;  // std::thread is defined here\n#include &lt;future&gt;  // std::future and std::promise defined here\n\n#include &lt;list&gt;    // std::list which we use to build a message queue on.\n\nstatic std::atomic&lt;int&gt; kount(1);       // this variable is used to provide an identifier for each thread started.\n\n//------------------------------------------------\n// create a simple queue to let us send notifications to some of our threads.\n// a future and promise are one shot type of notifications.\n// we use Sync_queue&lt;&gt; to have a queue between a producer thread and a consumer thread.\n// this code taken from chapter 42 section 42.3.4\n//   The C++ Programming Language, 4th Edition by Bjarne Stroustrup\n//   copyright 2014 by Pearson Education, Inc.\ntemplate&lt;typename Ttype&gt;\nclass Sync_queue {\npublic:\n    void  put(const Ttype &amp;val);\n    void  get(Ttype &amp;val);\n\nprivate:\n    std::mutex mtx;                   // mutex used to synchronize queue access\n    std::condition_variable cond;     // used for notifications when things are added to queue\n    std::list &lt;Ttype&gt; q;              // list that is used as a message queue\n};\n\ntemplate&lt;typename Ttype&gt;\nvoid Sync_queue&lt;Ttype&gt;::put(const Ttype &amp;val) {\n    std::lock_guard &lt;std::mutex&gt; lck(mtx);\n    q.push_back(val);\n    cond.notify_one();\n}\n\ntemplate&lt;typename Ttype&gt;\nvoid Sync_queue&lt;Ttype&gt;::get(Ttype &amp;val) {\n    std::unique_lock&lt;std::mutex&gt; lck(mtx);\n    cond.wait(lck, [this]{return  !q.empty(); });\n    val = q.front();\n    q.pop_front();\n}\n//------------------------------------------------\n\n\n// thread function that starts up and gets its identifier and then\n// waits for a promise to be filled by some other thread.\nvoid func(std::promise&lt;int&gt; &amp;jj) {\n    int myId = std::atomic_fetch_add(&amp;kount, 1);   // get my identifier\n    std::future&lt;int&gt; intFuture(jj.get_future());\n    auto ll = intFuture.get();   // wait for the promise attached to the future\n    std::cout &lt;&lt; \"  func \" &lt;&lt; myId &lt;&lt; \" future \" &lt;&lt; ll &lt;&lt; std::endl;\n}\n\n// function takes a promise from one thread and creates a value to provide as a promise to another thread.\nvoid func2(std::promise&lt;int&gt; &amp;jj, std::promise&lt;int&gt;&amp;pp) {\n    int myId = std::atomic_fetch_add(&amp;kount, 1);   // get my identifier\n    std::future&lt;int&gt; intFuture(jj.get_future());\n    auto ll = intFuture.get();     // wait for the promise attached to the future\n\n    auto promiseValue = ll * 100;   // create the value to provide as promised to the next thread in the chain\n    pp.set_value(promiseValue);\n    std::cout &lt;&lt; \"  func2 \" &lt;&lt; myId &lt;&lt; \" promised \" &lt;&lt; promiseValue &lt;&lt; \" ll was \" &lt;&lt; ll &lt;&lt; std::endl;\n}\n\n// thread function that starts up and waits for a series of notifications for work to do.\nvoid func3(Sync_queue&lt;int&gt; &amp;q, int iBegin, int iEnd, int *pInts) {\n    int myId = std::atomic_fetch_add(&amp;kount, 1);\n\n    int ll;\n    q.get(ll);    // wait on a notification and when we get it, processes it.\n    while (ll &gt; 0) {\n        std::cout &lt;&lt; \"  func3 \" &lt;&lt; myId &lt;&lt; \" start loop base \" &lt;&lt; ll &lt;&lt; \" \" &lt;&lt; iBegin &lt;&lt; \" to \" &lt;&lt; iEnd &lt;&lt; std::endl;\n        for (int i = iBegin; i &lt; iEnd; i++) {\n            pInts[i] = ll + i;\n        }\n        q.get(ll);  // we finished this job so now wait for the next one.\n    }\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    std::chrono::milliseconds myDur(1000);\n\n    // create our various promise and future objects which we are going to use to synchronise our threads\n    // create our three threads which are going to do some simple things.\n    std::cout &lt;&lt; \"MAIN #1 - create our threads.\" &lt;&lt; std::endl;\n\n    // thread T1 is going to wait on a promised int\n    std::promise&lt;int&gt; intPromiseT1;\n    std::thread t1(func, std::ref(intPromiseT1));\n\n    // thread T2 is going to wait on a promised int and then provide a promised int to thread T3\n    std::promise&lt;int&gt; intPromiseT2;\n    std::promise&lt;int&gt; intPromiseT3;\n\n    std::thread t2(func2, std::ref(intPromiseT2), std::ref(intPromiseT3));\n\n    // thread T3 is going to wait on a promised int and then provide a promised int to thread Main\n    std::promise&lt;int&gt; intPromiseMain;\n    std::thread t3(func2, std::ref(intPromiseT3), std::ref(intPromiseMain));\n\n    std::this_thread::sleep_for(myDur);\n    std::cout &lt;&lt; \"MAIN #2 - provide the value for promise #1\" &lt;&lt; std::endl;\n    intPromiseT1.set_value(22);\n\n    std::this_thread::sleep_for(myDur);\n    std::cout &lt;&lt; \"MAIN #2.2 - provide the value for promise #2\" &lt;&lt; std::endl;\n    std::this_thread::sleep_for(myDur);\n    intPromiseT2.set_value(1001);\n    std::this_thread::sleep_for(myDur);\n    std::cout &lt;&lt; \"MAIN #2.4 - set_value 1001 completed.\" &lt;&lt; std::endl;\n\n    std::future&lt;int&gt; intFutureMain(intPromiseMain.get_future());\n    auto t3Promised = intFutureMain.get();\n    std::cout &lt;&lt; \"MAIN #2.3 - intFutureMain.get() from T3. \" &lt;&lt; t3Promised &lt;&lt; std::endl;\n\n    t1.join();\n    t2.join();\n    t3.join();\n\n    int iArray[100];\n\n    Sync_queue&lt;int&gt; q1;    // notification queue for messages to thread t11\n    Sync_queue&lt;int&gt; q2;    // notification queue for messages to thread t12\n\n    std::thread t11(func3, std::ref(q1), 0, 5, iArray);     // start thread t11 with its queue and section of the array\n    std::this_thread::sleep_for(myDur);\n    std::thread t12(func3, std::ref(q2), 10, 15, iArray);   // start thread t12 with its queue and section of the array\n    std::this_thread::sleep_for(myDur);\n\n    // send a series of jobs to our threads by sending notification to each thread's queue.\n    for (int i = 0; i &lt; 5; i++) {\n        std::cout &lt;&lt; \"MAIN #11 Loop to do array \" &lt;&lt; i &lt;&lt; std::endl;\n        std::this_thread::sleep_for(myDur);  // sleep a moment for I/O to complete\n        q1.put(i + 100);\n        std::this_thread::sleep_for(myDur);  // sleep a moment for I/O to complete\n        q2.put(i + 1000);\n        std::this_thread::sleep_for(myDur);  // sleep a moment for I/O to complete\n    }\n\n    // close down the job threads so that we can quit.\n    q1.put(-1);    // indicate we are done with agreed upon out of range data value\n    q2.put(-1);    // indicate we are done with agreed upon out of range data value\n\n    t11.join();\n    t12.join();\n    return 0;\n}\n</code></pre>\n<p>This simple application creates the following output.</p>\n<pre><code>MAIN #1 - create our threads.\nMAIN #2 - provide the value for promise #1\n  func 1 future 22\nMAIN #2.2 - provide the value for promise #2\n  func2 2 promised 100100 ll was 1001\n  func2 3 promised 10010000 ll was 100100\nMAIN #2.4 - set_value 1001 completed.\nMAIN #2.3 - intFutureMain.get() from T3. 10010000\nMAIN #11 Loop to do array 0\n  func3 4 start loop base 100 0 to 5\n  func3 5 start loop base 1000 10 to 15\nMAIN #11 Loop to do array 1\n  func3 4 start loop base 101 0 to 5\n  func3 5 start loop base 1001 10 to 15\nMAIN #11 Loop to do array 2\n  func3 4 start loop base 102 0 to 5\n  func3 5 start loop base 1002 10 to 15\nMAIN #11 Loop to do array 3\n  func3 4 start loop base 103 0 to 5\n  func3 5 start loop base 1003 10 to 15\nMAIN #11 Loop to do array 4\n  func3 4 start loop base 104 0 to 5\n  func3 5 start loop base 1004 10 to 15\n</code></pre>\n", "LastEditorUserId": "1466970", "LastActivityDate": "2016-01-22T22:51:42.333", "Score": "5", "CreationDate": "2016-01-21T02:51:40.617", "ParentId": "11004273", "CommentCount": "0", "LastEditDate": "2016-01-22T22:51:42.333", "OwnerUserId": "1466970"}, "11020645": {"Id": "11020645", "PostTypeId": "2", "Body": "<p>In the words of [futures.state] a <code>std::future</code> is an <em>asynchronous return object</em> (\"an object that reads results from a shared state\") and a <code>std::promise</code> is an <em>asynchronous provider</em> (\"an object that provides a result to a shared state\") i.e. a promise is the thing that you <em>set</em> a result on, so that you can <em>get</em> it from the associated future.</p>\n<p>The asynchronous provider is what initially creates the shared state that a future refers to. <code>std::promise</code> is one type of asynchronous provider, <code>std::packaged_task</code> is another, and the internal detail of <code>std::async</code> is another.  Each of those can create a shared state and give you a <code>std::future</code> that shares that state, and can make the state ready.</p>\n<p><code>std::async</code> is a higher-level convenience utility that gives you an asynchronous result object and internally takes care of creating the asynchronous provider and making the shared state ready when the task completes. You could emulate it with a <code>std::packaged_task</code> (or <code>std::bind</code> and a <code>std::promise</code>) and a <code>std::thread</code> but it's safer and easier to use <code>std::async</code>.</p>\n<p><code>std::promise</code> is a bit lower-level, for when you want to pass an asynchronous result to the future, but the code that makes the result ready cannot be wrapped up in a single function suitable for passing to <code>std::async</code>.  For example, you might have an array of several <code>promise</code>s and associated <code>future</code>s and have a single thread which does several calculations and sets a result on each promise. <code>async</code> would only allow you to return a single result, to return several you would need to call <code>async</code> several times, which might waste resources.</p>\n", "LastEditorUserId": "257299", "LastActivityDate": "2016-10-03T10:19:45.387", "Score": "139", "CreationDate": "2012-06-13T17:59:00.707", "ParentId": "11004273", "CommentCount": "1", "LastEditDate": "2016-10-03T10:19:45.387", "OwnerUserId": "981959"}, "44835221": {"Id": "44835221", "PostTypeId": "2", "Body": "<p><strong>The promise is the other end of the wire.</strong></p>\n<p>Imagine you need to retrieve the value of a <code>future</code> being computed by an <code>async</code>. However, you don't want it to be computed in the same thread, and you don't even spawn a thread \"now\" - maybe your software was designed to pick a thread from a pool, so you don't know <em>who</em> will perform che computation in the end.</p>\n<p>Now, what do you pass to this (yet unknown) thread/class/entity? You don't pass the <code>future</code>, since this is the <em>result</em>. You want to pass something that is <em>connected</em> to the <code>future</code> and that represents <strong>the other end of the wire</strong>, so you will just query the <code>future</code> with no knowledge about who will actually compute/write something.</p>\n<p>This is the <code>promise</code>. It is a <em>handle</em> connected to your <code>future</code>. If the <code>future</code> is a <strong>speaker</strong>, and with <code>get()</code> you start listening until some sound comes out, the <code>promise</code> is a <strong>microphone</strong>; but not just any microphone, it is <em>the</em> microphone connected with a single wire to the speaker you hold. You might know who's at the other end but you don't need to know it - you just give it and wait until the other party says something.</p>\n", "LastActivityDate": "2017-06-29T21:24:24.627", "Score": "0", "CreationDate": "2017-06-29T21:24:24.627", "ParentId": "11004273", "CommentCount": "0", "OwnerUserId": "1394168"}, "11004273": {"ViewCount": "57463", "Body": "<p>I'm fairly familiar with the new standard library's <code>std::thread</code>, <code>std::async</code> and <code>std::future</code> components (e.g. see <a href=\"https://stackoverflow.com/a/10998831/596781\">this answer</a>), which are straight-forward.</p>\n<p>However, I cannot quite grasp what <code>std::promise</code> is, what it does and in which situations it is best used. The standard document itself doesn't contain a whole lot of information beyond its class synopsis, and neither does <a href=\"http://www.stdthread.co.uk/doc/headers/future/promise.html\" rel=\"noreferrer\">just::thread</a>.</p>\n<p>Could someone please give a brief, succinct example of a situation where an <code>std::promise</code> is needed and where it is the most idiomatic solution?</p>\n", "AcceptedAnswerId": "11020645", "Title": "What is std::promise?", "CreationDate": "2012-06-12T20:23:35.380", "Id": "11004273", "CommentCount": "10", "FavoriteCount": "238", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:47:26.613", "LastEditorUserId": "-1", "LastActivityDate": "2017-06-29T21:24:24.627", "Score": "294", "OwnerUserId": "596781", "Tags": "<c++><multithreading><c++11><promise><standard-library>", "AnswerCount": "8"}});