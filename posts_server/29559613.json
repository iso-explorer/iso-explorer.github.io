post_cb({"29559613": {"CommentCount": "5", "ViewCount": "129", "PostTypeId": "1", "LastEditorUserId": "4262344", "CreationDate": "2015-04-10T10:53:44.027", "LastActivityDate": "2015-04-12T20:53:24.567", "Title": "template non-type template parameter?", "LastEditDate": "2015-04-12T20:53:24.567", "Id": "29559613", "Score": "1", "Body": "<p>I'm trying to use a non-type template parameter which type is a template instance like this:</p>\n<pre><code>template&lt;size_t num&gt; class BitValue { ... };\nclass Foo {\n  // works\n  template&lt;template&lt;size_t&gt; class BitValue, size_t num&gt;\n  bool get(BitValue&lt;num&gt; &amp;&amp; t) { ... }\n\n  // fails\n  template&lt;typename T&gt; bool\n  template&lt;Bitvalue&lt;num&gt; bit&gt; bool get() { ... };\n  template&lt;template &lt;size_t&gt; Bitvalue bit&gt; bool get() { ... };\n  template&lt;template &lt;size_t&gt; class Bitvalue bit&gt; bool get() { ... };\n  template&lt;template &lt;size_t&gt; BitValue, size_t num, Bitvalue&lt;num&gt; bit&gt; bool get() { ... };\n};\n</code></pre>\n<p>You might say: Why not use the <code>foo.get(value)</code>? Foo represents a kind of bitfield that has multi-bit values and single-big values. I want foo.get&lt;...&gt;() for all members of the bitfield for consistency.</p>\n<p>Why not use `foo.get&lt;typeof(value)&gt;'?\nfoo.get&lt;MultiBitType&gt;() returns the value of the multi-bit field. foo.get&lt;SingleBitType&gt;() returns the raw value of the single-bit type. But unfortunately some of the bits are negated. So foo.get&lt;NegatedValue&gt;() should return !foo.get&lt;typeof(NegatedValue)&gt;().</p>\n<p>Any ideas if it is possible to have a template non-type template parameter at all? And if so how?</p>\n", "Tags": "<c++><templates><non-type>", "OwnerUserId": "4262344", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29559613_29560258_1": {"section_id": 57, "quality": 1.0, "length": 16}, "so_29559613_29560258_0": {"section_id": 57, "quality": 1.0, "length": 8}}, "n3337": {"so_29559613_29560258_1": {"section_id": 52, "quality": 1.0, "length": 16}, "so_29559613_29560258_0": {"section_id": 52, "quality": 1.0, "length": 8}}, "n4659": {"so_29559613_29560258_1": {"section_id": 59, "quality": 1.0, "length": 16}, "so_29559613_29560258_0": {"section_id": 59, "quality": 1.0, "length": 8}}}, "29560258": {"ParentId": "29559613", "CommentCount": "2", "Body": "<p>It is impossible to have a non-type template parameter of type <code>BitValue&lt;size_t&gt;</code> since the allowed types are [temp.param]:</p>\n<blockquote>\n<p id=\"so_29559613_29560258_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:  </p>\n<p id=\"so_29559613_29560258_1\">(4.1) \u2014 integral or enumeration type,<br>\n  (4.2) \u2014 pointer to object or pointer to function,<br>\n  (4.3) \u2014 lvalue reference to object or lvalue reference to function,<br>\n  (4.4) \u2014 pointer to member,<br>\n  (4.5) \u2014 <code>std::nullptr_t</code>.</br></br></br></br></p>\n</blockquote>\n<p>But you can just template on any type and delegate to a metafunction:</p>\n<pre><code>template &lt;typename T&gt;\nbool get() {\n    size_t bit = bit_number&lt;T&gt;::value;\n    ...\n}\n</code></pre>\n<p>where:</p>\n<pre><code>template &lt;typename T&gt; struct bit_number;\ntemplate &lt;size_t N&gt;\nstruct bit_number&lt;BitValue&lt;N&gt;&gt; : std::integral_constant&lt;size_t, N&gt; { };\n// other specializations\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "29560258", "Score": "2", "CreationDate": "2015-04-10T11:26:24.627", "LastActivityDate": "2015-04-10T11:26:24.627"}});