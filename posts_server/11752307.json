post_cb({"bq_ids": {"n4140": {"so_11752307_11752401_0": {"length": 5, "quality": 1.0, "section_id": 111}, "so_11752307_11752401_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 639}}, "n3337": {"so_11752307_11752401_0": {"length": 5, "quality": 1.0, "section_id": 106}, "so_11752307_11752401_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 629}}, "n4659": {"so_11752307_11752401_0": {"length": 5, "quality": 1.0, "section_id": 115}, "so_11752307_11752401_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 667}}}, "11752401": {"Id": "11752401", "PostTypeId": "2", "Body": "<p>It appears that VS2005 may be erroneously treating the <code>e</code> and <code>f</code> variables as <code>const char *</code> types.</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt; void compare (const T&amp;, const T&amp;) {\n    cout &lt;&lt; \"T:        \";\n};\n\ntemplate &lt;class U, class V&gt; void compare (U, U, V) {\n    cout &lt;&lt; \"UV:       \";\n};\n\nvoid compare (const char*, const char*) {\n    cout &lt;&lt; \"ordinary: \";\n};\n\nint main (void) {\n    char* c = \"a\";\n    char* d = \"b\";\n    compare (c,d);\n    cout &lt;&lt; \"&lt;- char *\\n\";\n\n    char e[] = \"a\";\n    char f[] = \"b\";\n    compare (e,f);\n    cout &lt;&lt; \"&lt;- char []\\n\";\n\n    const char g[] = \"a\";\n    const char h[] = \"b\";\n    compare (g,h);\n    cout &lt;&lt; \"&lt;- const char []\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>which outputs:</p>\n<pre><code>T:        &lt;- char *\nT:        &lt;- char []\nordinary: &lt;- const char []\n</code></pre>\n<hr>\n<p>Section <code>13.3 Overload resolution</code> of C++03 (section numbers appear to be unchanged in C++11 so the same comments apply there) specifies how to select which function is used and I'll try to explain it in (relatively) simple terms, given that the standard is rather a dry read.</p>\n<p>Basically, a list of <em>candidate</em> functions is built based on how the function is actually being called (as a member function of an class/object, regular (unadorned) function calls, calls via a pointer and so on).</p>\n<p>Then, out of those, a list of <em>viable</em> functions is extracted based on argument counts.</p>\n<p>Then, from the viable functions, the best fit function is selected based on the idea of a minimal implicit conversion sequence (see <code>13.3.3 Best viable function</code> of C++03).</p>\n<p>In essence, there is a \"cost\" for selecting a function from the viable list that is set based on the implicit conversions required for each argument. The cost of selecting the <em>function</em> is the sum of the costs for each individual <em>argument</em> to that function, and the compiler will chose the function with the minimal cost.</p>\n<p>If two functions are found with the same cost, the standard states the the compiler should treat it as an error.</p>\n<p>So, if you have a function where an implicit conversion happens to one argument, it will be preferred over one where two arguments have to be converted in that same way.</p>\n<p>The \"cost\" can be see in the table below in the Rank column. An exact match has less cost than promotion, which has less cost than conversion.</p>\n<pre><code>Rank                 Conversion\n----                 ----------\nExact match          No conversions required\n                     Lvalue-to-rvalue conversion\n                     Array-to-pointer conversion\n                     Function-to-pointer conversion\n                     Qualification conversion\nPromotion            Integral promotions\n                     Floating point promotions\nConversion           Integral conversion\n                     Floating point conversions\n                     Floating-integral conversions\n                     Pointer conversions\n                     Pointer-to-member conversions\n                     Boolean conversions\n</code></pre>\n<p>In places where the conversion cost is identical for functions <code>F1</code> and <code>F2</code> (such as in your case), <code>F1</code> is considered better if:</p>\n<blockquote>\n<p id=\"so_11752307_11752401_0\">F1 is a non-template function and F2 is a function template specialization.</p>\n</blockquote>\n<hr>\n<p>However, that's not the whole story since the template code and non-template code are all exact matches hence you would expect to see the non-template function called in all cases rather than just the third.</p>\n<p>That's covered further on in the standard: The answer lies in section <code>13.3.3.2 Ranking implicit conversion sequences</code>. That section states that an identical rank would result in ambiguity <em>except</em> under certain conditions, one of which is:</p>\n<blockquote>\n<p id=\"so_11752307_11752401_1\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if (1) S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is considered to be a subsequence of any non-identity conversion sequence) ...</p>\n</blockquote>\n<p>The conversions for the template version are actually a <em>proper subset</em> (qualification conversion) of the non-template version (qualification AND array-to-pointer conversions), and proper subsets are deemed to have a lower cost.</p>\n<p>Hence it prefers the template version in the first two cases. In the third case, the only conversions are array-to-pointer for the non-template version and qualification for the template version, hence there's no subset in either direction, and it prefers the non-template version based on the rule I mentioned above, under the ranking table).</p>\n</hr></hr>", "LastEditorUserId": "14860", "LastActivityDate": "2012-08-01T07:52:37.310", "Score": "4", "CreationDate": "2012-08-01T04:04:10.730", "ParentId": "11752307", "CommentCount": "9", "OwnerUserId": "14860", "LastEditDate": "2012-08-01T07:52:37.310"}, "11752307": {"ViewCount": "153", "Body": "<p>The code is:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// compares two objects\ntemplate &lt;typename T&gt; void compare(const T&amp;, const T&amp;){\n    cout&lt;&lt;\"T\"&lt;&lt;endl;\n};\n// compares elements in two sequences\ntemplate &lt;class U, class V&gt; void compare(U, U, V){\n    cout&lt;&lt;\"UV\"&lt;&lt;endl;\n};\n// plain functions to handle C-style character strings\nvoid compare(const char*, const char*){\n    cout&lt;&lt;\"ordinary\"&lt;&lt;endl;\n};\n\nint main() {\n\n    cout&lt;&lt;\"-------------------------char* --------------------------\"&lt;&lt; endl;\n\n    char* c=\"a\";\n    char* d=\"b\";\n    compare(c,d);\n\ncout&lt;&lt;\"------------------------- char [2]---------------------------\"&lt;&lt; endl;\n\n    char e[]= \"a\";\n    char f[]=\"b\";\n    compare(e,f);\n\n    system(\"pause\");\n}\n</code></pre>\n<p>The result is:</p>\n<blockquote>\n<p id=\"so_11752307_11752307_0\">-------------------------char* --------------------------</p>\n<p id=\"so_11752307_11752307_1\">T</p>\n<p id=\"so_11752307_11752307_2\">------------------------- char [2]-----------------------</p>\n<p id=\"so_11752307_11752307_3\">ordinary</p>\n</blockquote>\n<p>And my question is:\nWhy does compare(c,d) call compare(const T&amp;, const T&amp;) and compare(e,f) call the ordinary function even though the arguments of the two functions are char*s?</p>\n", "AcceptedAnswerId": "11752401", "Title": "Why does this code call different template function in vs2005?", "CreationDate": "2012-08-01T03:46:58.957", "Id": "11752307", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-08-01T04:14:35.857", "LastEditorUserId": "485971", "LastActivityDate": "2012-08-01T07:52:37.310", "Score": "5", "OwnerUserId": "1567318", "Tags": "<c++>", "AnswerCount": "1"}});