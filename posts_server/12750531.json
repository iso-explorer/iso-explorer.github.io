post_cb({"12750531": {"ViewCount": "900", "Body": "<p>It was said to me that the standard template library is differently implemented by every compiler, is this correct?</p>\n<p>How can computational complexity (both in time and space) be observed if (for instance) the set container is implemented with a linked list rather than a red-black tree?</p>\n<p>Did I miss something?</p>\n", "AcceptedAnswerId": "12750695", "Title": "STL - does every compiler implement it differently?", "CreationDate": "2012-10-05T16:40:48.980", "Id": "12750531", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-02-04T18:15:37.477", "Score": "2", "OwnerUserId": "1494037", "Tags": "<c++><stl>", "AnswerCount": "5"}, "12750695": {"Id": "12750695", "PostTypeId": "2", "Body": "<p>First things first, you probably mean the <em>C++ standard library</em>, not <a href=\"http://en.wikipedia.org/wiki/Standard_Template_Library\">STL</a>. The STL was a library written before C++ was standardised that heavily influenced the C++ standard library.</p>\n<p>Now, the C++ standard provides rules and definitions that an implementation should conform to. In particular, the standard library is described as various partial class definitions and function declarations and the properties that they should have. The implementation is free to implement the library in any way it chooses, as long as it meets exactly what the standard says. Here's what the standard says about a conforming implementation (\u00a71.4):</p>\n<blockquote>\n<p id=\"so_12750531_12750695_0\">For classes and class templates, the library Clauses specify partial definitions. Private members (Clause 11) are not specified, but each implementation shall supply them to complete the definitions according to the description in the library Clauses.</p>\n<p id=\"so_12750531_12750695_1\">For functions, function templates, objects, and values, the library Clauses specify declarations. Implementations shall supply definitions consistent with the descriptions in the library Clauses.</p>\n</blockquote>\n<p>For example, to ensure the complexity of a <code>std::list</code> implementation is equal to that of a double-linked list, its member functions are given complexity requirements. For example, the <code>std::list::insert</code> functions are given the following requirement (\u00a723.3.5.4, emphasis added):</p>\n<blockquote>\n<p id=\"so_12750531_12750695_2\">Insertion of a single element into a list takes <strong>constant time</strong> and exactly one call to a constructor of T.</p>\n</blockquote>\n<p>This doesn't necessarily mean that <code>std::list</code> <em>must</em> be implemented as a double-linked list. However, this is a common choice. An implementation must only act in such a way that the requirements are met (or that it <em>appears</em> that the requirements have been met; the <em>as-if rule</em>).</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2012-10-05T16:57:35.530", "Score": "8", "CreationDate": "2012-10-05T16:51:47.937", "ParentId": "12750531", "CommentCount": "0", "OwnerUserId": "150634", "LastEditDate": "2012-10-05T16:57:35.530"}, "12750580": {"Id": "12750580", "PostTypeId": "2", "Body": "<p>Every C++ compiler comes with an implementation of the C++ standard library. Some implementations are based on others while some are independent.</p>\n<p>However, they all <em>must</em> implement the standard. And the standard has certain complexity specifications that it requires from various functions. A <code>set</code> <em>cannot</em> be implemented purely as a linked-list and still meet those guarantees. Thus, if a C++ standard library implements <code>set</code> as a linked-list, then it is in <em>violation</em> of the standard. This is no different from a a C++ compiler implementing <code>if</code> wrong.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2012-10-05T17:26:03.513", "Score": "11", "CreationDate": "2012-10-05T16:44:00.973", "ParentId": "12750531", "CommentCount": "5", "OwnerUserId": "734069", "LastEditDate": "2012-10-05T17:26:03.513"}, "bq_ids": {"n4140": {"so_12750531_12750695_0": {"length": 21, "quality": 0.875, "section_id": 5771}, "so_12750531_12750740_0": {"length": 31, "quality": 0.5166666666666667, "section_id": 763}, "so_12750531_12750695_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 5772}, "so_12750531_12750695_2": {"length": 12, "quality": 1.0, "section_id": 919}}, "n3337": {"so_12750531_12750695_0": {"length": 21, "quality": 0.875, "section_id": 5544}, "so_12750531_12750740_0": {"length": 31, "quality": 0.5166666666666667, "section_id": 750}, "so_12750531_12750695_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 5545}, "so_12750531_12750695_2": {"length": 12, "quality": 1.0, "section_id": 907}}, "n4659": {"so_12750531_12750695_0": {"length": 21, "quality": 0.875, "section_id": 7228}, "so_12750531_12750740_0": {"length": 32, "quality": 0.5333333333333333, "section_id": 823}, "so_12750531_12750695_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 7229}, "so_12750531_12750695_2": {"length": 12, "quality": 1.0, "section_id": 980}}}, "12750740": {"Id": "12750740", "PostTypeId": "2", "Body": "<p>An example of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/\">the actual standard</a> may be helpful to clarify, and <code>unordered_*</code> is a good one I think, since it was added specifically to get a hash table into the standard. This quote is from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">a draft</a> but I expect the final version is substantially similar:</p>\n<blockquote id=\"so_12750531_12750740_0\">\n<h3>23.5.4.4 unordered_map modifiers</h3>\n<pre><code>template &lt;class P&gt;\npair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);\n</code></pre>\n<ol>\n<li>Requires: value_type is constructible from <code>std::forward&lt;P&gt;(obj)</code>.</li>\n<li>Effects: Inserts obj converted to value_type if and only if there is no element in the container with key equivalent to the key of <code>value_type(obj)</code>.</li>\n<li>Returns: The <code>bool</code> component of the returned pair object indicates whether the insertion took place and the iterator component points to the element with key equivalent to the key of <code>value_type(obj)</code>.</li>\n<li><strong>Complexity: Average case O(1), worst case O(size()).</strong></li>\n<li>Remarks: This signature shall not participate in overload resolution unless P is implicitly convertible to <code>value_type</code>.</li>\n</ol>\n</blockquote>\n<p>Other parts of the standard effectively require it be implemented as a hash table too, but I think the important part is that they make complexity requirements.</p>\n", "LastEditorUserId": "212555", "LastActivityDate": "2012-10-05T17:00:15.490", "Score": "5", "CreationDate": "2012-10-05T16:54:02.700", "ParentId": "12750531", "CommentCount": "0", "OwnerUserId": "212555", "LastEditDate": "2012-10-05T17:00:15.490"}, "12752263": {"Id": "12752263", "PostTypeId": "2", "Body": "<p><strong>Short answer</strong>: it cannot, the author probably misunderstood. A red-black tree is implemented as a node-based containers (ie, nodes linked to each others in some way), as is a linked-list, but the way the nodes are linked together are different because they have different complexity requirements on their various operations.</p>\n<hr>\n<p><strong>Long answer</strong>: actually, there is a misunderstanding.</p>\n<p>There are two (interleaved to a degree) components in the C++ Standard:</p>\n<ul>\n<li>the C++ language itself</li>\n<li>the C++ Standard Library</li>\n</ul>\n<p>A compiler is only required to implement the C++ language. And indeed there is not necessarily a one-to-one matching between a compiler and an implementation of the standard library.</p>\n<p>Examples:</p>\n<ul>\n<li>Dinkumware is a company providing its own implementation of the C++ Standard Library. It is sold to Microsoft which bundles it with its Visual Studio C++ compiler &amp; IDE.</li>\n<li>Clang is a C++ compiler which on most Linux distributions will use the libstdc++ implementation, which is usually bundled with the gcc compiler. The LLVM project (which hosts Clang) has its own implementation (the libc++ library), but it is not ported to many linux distributions yet.</li>\n</ul>\n<p>Any implementation of the Standard Library must meet a number of requirements, both in terms of interface (which classes/methods, which parameters, which types, ...) but also in terms of complexity. However the implementations do vary.</p>\n<p>Example: <code>std::string</code></p>\n<ul>\n<li>In libstdc++ (which comes with gcc), the <code>std::string</code> class only contains a single pointer to a shared class because it implements the Copy-On-Write idiom.</li>\n<li>In Dirkumware implementation, on the other hand, the <code>std::string</code> class is much fatter because it implements the Small-String-Optimization, which consists in storing small strings without dynamically allocating memory (via <code>new</code>) by reusing some space in the class.</li>\n</ul>\n<p>Both implement the same interface, but widely differently.</p>\n<p>Example: <code>std::sort</code></p>\n<p>The sort algorithm is only required to have a N*log(N) overall complexity, in average. However good implementations will implement either IntroSort algorithms or variations of TimSort, which have lower complexity in many common cases or less disastrous worst case complexity.</p>\n<p>It is my understanding that libc++'s implementation is currently the best out of the three libraries I cited, for example.</p>\n</hr>", "LastEditorUserId": "4525671", "LastActivityDate": "2015-02-04T18:15:37.477", "Score": "3", "CreationDate": "2012-10-05T18:46:32.017", "ParentId": "12750531", "CommentCount": "1", "OwnerUserId": "147192", "LastEditDate": "2015-02-04T18:15:37.477"}, "12751613": {"Id": "12751613", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12750531_12751613_0\">How can computational complexity (both in time and space) be observed if (for instance) the set container is implemented with a linked list rather than a red-black tree?</p>\n</blockquote>\n<p>SeaWorld San Antonio used to be owned by Anheuser-Busch. When Anheuser-Busch bought it, the weird liquor laws in Texas would have required Anheuser-Busch to sell only their competitors' beers at SeaWorld. It would have been illegal to sell Bud. Hence the Busch exception to those liquor laws. The Busch exception didn't name Anheuser-Busch or SeaWorld. That would have been a bit too blatant. But it nonetheless did allow SeaWorld to sell Bud, and it didn't apply anywhere else. Legislators are very adept at creating laws that target a very specific organization without naming that organization.</p>\n<p>The same applies to standards writers. The standard doesn't say red black trees anywhere, but the requirements are heavily rigged in favor of them. I doubt that even an AVL tree could meet those stringent insertion requirements. AVL trees give up some performance on insertion so as to make lookup as fast as possible. AVL trees are even faster than red-black trees with regard to search.</p>\n", "LastActivityDate": "2012-10-05T17:58:51.160", "CommentCount": "1", "CreationDate": "2012-10-05T17:58:51.160", "ParentId": "12750531", "Score": "1", "OwnerUserId": "774499"}});