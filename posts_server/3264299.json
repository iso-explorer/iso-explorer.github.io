post_cb({"26861151": {"ParentId": "3264299", "CommentCount": "0", "Body": "<p>Microsoft's standard library guy says the following (<a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-/C9-Lectures-Stephan-T-Lavavej-Standard-Template-Library-STL-6-of-n#c634231440240000000\">here</a>):</p>\n<blockquote>\n<ul>\n<li>Could you perhaps explain when to use 'get_temporary_buffer'</li>\n</ul>\n<p id=\"so_3264299_26861151_0\">It has a very specialized purpose. Note that it doesn't throw\n  exceptions, like new (nothrow), but it also doesn't construct objects,\n  unlike new (nothrow).</p>\n<p id=\"so_3264299_26861151_1\">It's used internally by the STL in algorithms like stable_partition().\n  This happens when there are magic words like N3126 25.3.13\n  [alg.partitions]/11: stable_partition() has complexity \"At most (last\n  - first) * log(last - first) swaps, but only linear number of swaps if there is enough extra memory.\" When the magic words \"if there is\n  enough extra memory\" appear, the STL uses get_temporary_buffer() to\n  attempt to acquire working space. If it can, then it can implement the\n  algorithm more efficiently. If it can't, because the system is running\n  dangerously close to out-of-memory (or the ranges involved are huge),\n  the algorithm can fall back to a slower technique.</p>\n<p id=\"so_3264299_26861151_2\">99.9% of STL users will never need to know about get_temporary_buffer().</p>\n</blockquote>\n", "OwnerUserId": "193887", "PostTypeId": "2", "Id": "26861151", "Score": "14", "CreationDate": "2014-11-11T09:07:37.490", "LastActivityDate": "2014-11-11T09:07:37.490"}, "3264443": {"ParentId": "3264299", "CommentCount": "0", "Body": "<pre><code>ptrdiff_t            request = 12\npair&lt;int*,ptrdiff_t&gt; p       = get_temporary_buffer&lt;int&gt;(request);\nint*                 base    = p.first;\nptrdiff_t            respond = p.sencond;\nassert( is_valid( base, base + respond ) );\n</code></pre>\n<p><em>respond</em> may be less than <em>request</em>.</p>\n<pre><code>size_t require = 12;\nint*   base    = static_cast&lt;int*&gt;( ::operator new( require*sizeof(int) ) );\nassert( is_valid( base, base + require ) );\n</code></pre>\n<p>the actual size of <em>base</em> must greater or equal to <em>require</em>.</p>\n", "OwnerUserId": "223181", "PostTypeId": "2", "Id": "3264443", "Score": "2", "CreationDate": "2010-07-16T11:41:08.063", "LastActivityDate": "2010-07-16T11:41:08.063"}, "bq_ids": {"n4140": {"so_3264299_3264299_0": {"section_id": 4257, "quality": 1.0, "length": 7}}, "n3337": {"so_3264299_3264299_0": {"section_id": 4098, "quality": 1.0, "length": 7}}, "n4659": {"so_3264299_3264299_0": {"section_id": 6418, "quality": 0.7142857142857143, "length": 5}}}, "3264409": {"ParentId": "3264299", "CommentCount": "0", "Body": "<p>The standard says it allocates storage for <strong>up to</strong> <code>n</code> elements.\nIn other words, your example might return a buffer big enough for 5 objects only.</p>\n<p>It does seem pretty difficult to imagine a good use case for this though. Perhaps if you're working on a very memory-constrained platform, it's a convenient way to get \"as much memory as possible\".</p>\n<p>But on such a constrained platform, I'd imagine you'd bypass the memory allocator as much as possible, and use a memory pool or something you have full control over.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "3264409", "Score": "9", "CreationDate": "2010-07-16T11:37:28.087", "LastActivityDate": "2010-07-16T11:37:28.087"}, "3264638": {"ParentId": "3264299", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Stroustrup says in <em>\"The C++ Programming Language\"</em> (<em>\u00a719.4.4</em>, SE):</p>\n<blockquote>\n<p id=\"so_3264299_3264638_0\">The idea is that a system may keep a number of fixed-sized buffers ready for fast allocation so that requesting space for <em>n</em> objects may yield space for more than <em>n</em>. It may also yield less, however, so one way of using <code>get_temporary_buffer()</code> is to optimistically ask for a lot and then use what happens to be available.<br>\n  [...] Because <code>get_temporary_buffer()</code> is low-level and likely to be optimized for managing temporary buffers, it should not be used as an alternative to <em>new</em> or <em>allocator::allocate()</em> for obtaining longer-term storage.</br></p>\n</blockquote>\n<p>He also starts the introduction to the two functions with:</p>\n<blockquote>\n<p id=\"so_3264299_3264638_1\">Algorithms often require temporary space to perform acceptably.</p>\n</blockquote>\n<p>... but doesn't seem to provide a definition of <em>temporary</em> or <em>longer-term</em> anywhere.</p>\n<p>An <a href=\"https://twitter.com/barrelshifter/status/659080214891204608\" rel=\"noreferrer\">anecdote</a> in <a href=\"http://rads.stackoverflow.com/amzn/click/0321942043\" rel=\"noreferrer\"><em>\"From Mathematics to Generic Programming\"</em></a> mentions that Stepanov provided a bogus placeholder implementation in the original STL design, however:</p>\n<blockquote>\n<p id=\"so_3264299_3264638_2\">To his surprise, he discovered years later that all the major vendors that provide STL implementations are still using this terrible implementation [...]</p>\n</blockquote>\n", "OwnerUserId": "168225", "LastEditorUserId": "168225", "LastEditDate": "2015-10-30T10:07:28.470", "Id": "3264638", "Score": "39", "CreationDate": "2010-07-16T12:06:16.963", "LastActivityDate": "2015-10-30T10:07:28.470"}, "8752881": {"ParentId": "3264299", "CommentCount": "2", "Body": "<p>Perhaps (just a guess) it has something to do with memory fragmentation. If you heavily keep allocating and deallocating temporal memory, but each time you do it you allocate some long-term intended memory after allocating the temp but before deallocating it, you may end up with a fragmented heap (I guess).</p>\n<p>So the get_temporary_buffer could be intended to be a bigger-than-you-would-need chunk of memory that is allocated once (perhaps there are many chunks ready for accepting multiple requests), and each time you need memory you just get one of the chunks. So the memory doesn't get fragmented.</p>\n", "OwnerUserId": "1133524", "PostTypeId": "2", "Id": "8752881", "Score": "2", "CreationDate": "2012-01-06T03:04:31.310", "LastActivityDate": "2012-01-06T03:04:31.310"}, "3264299": {"CommentCount": "1", "AcceptedAnswerId": "3264638", "PostTypeId": "1", "LastEditorDisplayName": "user283145", "CreationDate": "2010-07-16T11:25:38.520", "LastActivityDate": "2015-10-30T10:07:28.470", "LastEditDate": "2013-08-31T22:13:23.377", "ViewCount": "6829", "FavoriteCount": "16", "Title": "Why do I need std::get_temporary_buffer?", "Id": "3264299", "Score": "77", "Body": "<p>For what purpose I should use <a href=\"http://en.cppreference.com/w/cpp/memory/get_temporary_buffer\" rel=\"noreferrer\"><code>std::get_temporary_buffer</code></a>? Standard says the following:</p>\n<blockquote>\n<p id=\"so_3264299_3264299_0\">Obtains a pointer to storage sufficient to store up to n adjacent T objects.</p>\n</blockquote>\n<p>I thought that the buffer will be allocated on the stack, but that is not true. According to the C++ Standard this buffer is actually not temporary. What advantages does this function have over the global function <code>::operator new</code>, which doesn't construct the objects either. Am I right that the following statements are equivalent?</p>\n<pre><code>int* x;\nx = std::get_temporary_buffer&lt;int&gt;( 10 ).first;\nx = static_cast&lt;int*&gt;( ::operator new( 10*sizeof(int) ) );\n</code></pre>\n<p>Does this function only exist for syntax sugar? Why is there <code>temporary</code> in its name?</p>\n<hr>\n<p>One use case was suggested in the <a href=\"http://www.drdobbs.com/184403203;jsessionid=JDREHEWS1OHWRQE1GHOSKHWATMY32JVN?pgno=7\" rel=\"noreferrer\">Dr. Dobb's Journal, July 01, 1996</a> for implementing algorithms:</p>\n<blockquote>\n<p id=\"so_3264299_3264299_1\">If no buffer can be allocated, or if it is smaller than requested, the algorithm still works correctly, It merely slows down. </p>\n</blockquote>\n</hr>", "Tags": "<c++><memory-management><stl><buffer><temporary>", "OwnerUserId": "123111", "AnswerCount": "5"}});