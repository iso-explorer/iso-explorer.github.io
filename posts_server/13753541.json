post_cb({"13753702": {"ParentId": "13753541", "CommentCount": "10", "Body": "<p>The method taking two parameter packs is illegal according to 14.1 [temp.param] paragraph 11:</p>\n<blockquote>\n<p id=\"so_13753541_13753702_0\">... A template parameter pack of a function template shall not be followed by another template parameter unless that template parameter can be deduced from the parameter-type-list\n  of the function template or has a default argument (14.8.2). [ Example:</p>\n</blockquote>\n<pre><code>template&lt;class T1 = int, class T2&gt; class B; // error\n// U cannot be neither deduced from the parameter-type-list nor specified\ntemplate&lt;class... T, class... U&gt; void f() { } // error\ntemplate&lt;class... T, class U&gt; void g() { } // error\n</code></pre>\n<blockquote>\n<p id=\"so_13753541_13753702_1\">\u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13753702", "Score": "6", "CreationDate": "2012-12-06T22:24:07.130", "LastActivityDate": "2012-12-06T22:24:07.130"}, "bq_ids": {"n4140": {"so_13753541_13753702_0": {"section_id": 64, "quality": 0.9, "length": 18}}, "n3337": {"so_13753541_13753702_0": {"section_id": 59, "quality": 0.75, "length": 15}}, "n4659": {"so_13753541_13753702_0": {"section_id": 66, "quality": 0.9, "length": 18}}}, "13753541": {"CommentCount": "2", "ViewCount": "108", "CreationDate": "2012-12-06T22:10:42.990", "LastActivityDate": "2012-12-06T22:24:07.130", "Title": "Puzzling difference of variadic template method behavior for templated and non templated classes", "AcceptedAnswerId": "13753702", "PostTypeId": "1", "Id": "13753541", "Score": "9", "Body": "<p>I am scratching my head with a strange problem highlighted by the following minimal code:</p>\n<pre><code>struct A {\n    template &lt;typename ...X, typename ...Y&gt;\n    void f(X... a, Y...b) {\n    }\n\n    template &lt;typename ...X&gt;\n    void g(X...c) {\n       f&lt;X...&gt; (c...);\n    }\n};\n\ntemplate &lt;typename T&gt;\nstruct B {\n    template &lt;typename ...X, typename ...Y&gt;\n    void f(X... a, Y...b) {\n    }\n\n    template &lt;typename ...X&gt;\n    void g(X...c) {\n       f&lt;X...&gt; (c...);\n    }\n};\n\n\n\nint main() {\n    A a;\n    a.g(); // Compiles without problem\n\n    B&lt;int&gt; b;\n    b.g(); // Compiler complains saying g() calls f&lt;&gt;() with 0 arguments while 1 is expected\n}\n</code></pre>\n<p>Both g++ and clang++ give the same basic error messages for the second case. \nThey basically say that the call to f() within the templated class needs one argument.</p>\n<p>Is this a bug in both compilers, or am I missing something in the C++ standard?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1149566", "AnswerCount": "1"}});