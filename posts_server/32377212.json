post_cb({"bq_ids": {"n4140": {"so_32377212_32378723_1": {"length": 48, "quality": 0.9056603773584906, "section_id": 198}, "so_32377212_32378723_2": {"length": 40, "quality": 1.0, "section_id": 191}, "so_32377212_32378723_0": {"length": 21, "quality": 0.84, "section_id": 170}, "so_32377212_32378723_3": {"length": 22, "quality": 1.0, "section_id": 194}}, "n3337": {"so_32377212_32378723_1": {"length": 47, "quality": 0.8867924528301887, "section_id": 192}, "so_32377212_32378723_2": {"length": 40, "quality": 1.0, "section_id": 185}, "so_32377212_32378723_0": {"length": 21, "quality": 0.84, "section_id": 164}, "so_32377212_32378723_3": {"length": 22, "quality": 1.0, "section_id": 188}}, "n4659": {"so_32377212_32378723_1": {"length": 52, "quality": 0.9811320754716981, "section_id": 204}, "so_32377212_32378723_2": {"length": 39, "quality": 0.975, "section_id": 196}, "so_32377212_32378723_0": {"length": 24, "quality": 0.96, "section_id": 175}, "so_32377212_32378723_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 200}}}, "32377212": {"ViewCount": "186", "Body": "<p>I have carefully read many answers concerning this topic, but nevertheless I cannot figure out EXACTLY when these two keywords ARE or AREN'T needed in the scope of a non-template function which is member of a nested template class.</p>\n<p>My reference compilers are GNU g++ 4.9.2  and clang 3.5.0.</p>\n<p>They behave hardly different on the following code where I put embedded\ncomments trying to explain what happens.</p>\n<pre><code>#include &lt;iostream&gt;\n\n// a simple template class with a public member template struct\ntemplate &lt;class Z&gt;\nclass Pa\n{\n// anything\npublic:\n    template &lt;class U&gt;\n    struct Pe  // a nested template\n    {\n        // anything\n        void f(const char *); // a non-template member function\n    };\n\n    template &lt;class U&gt; friend struct Pe;\n};\n\n// definition of the function f\ntemplate &lt;class AAA&gt;\ntemplate &lt;class BBB&gt;\nvoid Pa&lt;AAA&gt; :: Pe&lt;BBB&gt; :: f(const char* c)\n{\n    Pa&lt;AAA&gt; p; // NO typename for both clang and GNU...\n\n    // the following line is ACCEPTED by both clang and GNU\n    // without both template and typename keywords\n    // However removing comments from typename only\n    // makes clang still accepting the code while GNU doesn't\n    // accept it anymore. The same happens if the comments   of template\n    // ONLY are removed.\n    //  \n    // Finally both compilers accept the line when both typename AND\n    // template are present...\n    /*typename*/ Pa&lt;AAA&gt;::/*template*/ Pe&lt;BBB&gt; q;\n\n    // in the following clang ACCEPTS typename, GNU doesn't:\n    /*typename*/ Pa&lt;AAA&gt;::Pe&lt;int&gt; qq;\n\n    // the following are accepted by both compilers\n    // no matter whether both typename AND template\n    // keywords are present OR commented out:\n    typename Pa&lt;int&gt;::template Pe&lt;double&gt; qqq;\n    typename Pa&lt;double&gt;::template Pe&lt;BBB&gt;  qqqq;\n    std::cout &lt;&lt; c &lt;&lt; std::endl; // just to do something...\n}\n\nint main()\n{\n    Pa&lt;char&gt;::Pe&lt;int&gt; pp;\n    pp.f(\"bye\");\n}\n</code></pre>\n<p>So, in the scope of <code>f</code> is <code>Pa&lt;double&gt;::Pe&lt;BBB&gt;</code> a dependent name or not? </p>\n<p>And what about <code>Pa&lt;AAA&gt;::Pe&lt;int&gt;</code> ?</p>\n<p>And, after all, why this different behaviour of the two quoted compilers?</p>\n<p>Can anyone clarify solving the puzzle?</p>\n", "Title": "Again on typename and template keywords", "CreationDate": "2015-09-03T13:36:38.480", "LastActivityDate": "2015-09-03T14:40:48.053", "CommentCount": "4", "LastEditDate": "2015-09-03T13:40:11.813", "PostTypeId": "1", "LastEditorUserId": "3953764", "Id": "32377212", "Score": "3", "OwnerUserId": "4278083", "Tags": "<c++><templates><typename><dependent-name>", "AnswerCount": "1"}, "32378723": {"Id": "32378723", "PostTypeId": "2", "Body": "<p>The important rule in [temp.res] is:</p>\n<blockquote>\n<p id=\"so_32377212_32378723_0\">When a <em>qualified-id</em> is intended to refer to a type that is not a member of the current instantiation (14.6.2.1)\n  and its <em>nested-name-specifier</em> refers to a dependent type, it shall be prefixed by the keyword <code>typename</code>, forming\n  a <em>typename-specifier</em>. If the <em>qualified-id</em> in a <em>typename-specifier</em> does not denote a type, the program is ill-formed.</p>\n</blockquote>\n<p>The question revoles around two <em>qualified-id</em>s:</p>\n<pre><code>Pa&lt;double&gt;::Pe&lt;BBB&gt;\nPa&lt;AAA&gt;::Pe&lt;int&gt;\n</code></pre>\n<p>First, what is a dependent type? According to [temp.dep.type]:</p>\n<blockquote>\n<p id=\"so_32377212_32378723_1\">A type is dependent if it is<br>\n  \u2014 a template parameter,<br>\n  \u2014 a member of an unknown specialization,<br>\n  \u2014 a nested class or enumeration that is a dependent member of the current instantiation,<br>\n  \u2014 a cv-qualified type where the cv-unqualified type is dependent,<br>\n  \u2014 a compound type constructed from any dependent type,<br>\n  \u2014 an array type whose element type is dependent or whose bound (if any) is value-dependent,<br>\n  \u2014 a <em>simple-template-id</em> in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent, or<br>\n  \u2014 denoted by <code>decltype</code>(<em>expression</em>), where <em>expression</em> is type-dependent (14.6.2.2).</br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p><code>Pa&lt;double&gt;</code> (the <em>nested-name-specifier</em> of the first example) is not a dependent type, as it fits none of the bullet points. Since we don't meet that criteria, we don't need to prefix the <code>typename</code> keyword. </p>\n<p><code>Pa&lt;AAA&gt;</code>, however, <em>is</em> a dependent type since it is a <em>simple-template-id</em> in which one of the template arguments is a dependent type (<code>AAA</code> is trivially a dependent type since it is a template parameter).</p>\n<p>What, then, is \"a member of the current instantiation\"? </p>\n<blockquote>\n<p id=\"so_32377212_32378723_2\">A name refers to the <em>current instantiation</em> if it is<br>\n  \u2014 [...]<br>\n  \u2014 in the definition of a primary class template or a member of a primary class template, the name of the class template followed by the template argument list of the primary template (as described below) enclosed in &lt;&gt; (or an equivalent template alias specialization)\"\n  \u2014 in the definition of a nested class of a class template, the name of the nested class referenced as a\n  member of the current instantiation, or</br></br></p>\n</blockquote>\n<p>The current instantiation, in this case, is <code>Pa&lt;AAA&gt;</code> (or, also, <code>Pa</code>). And:</p>\n<blockquote>\n<p id=\"so_32377212_32378723_3\">A name is a member of the current instantiation if it is [...] A <em>qualified-id</em> in which the <em>nested-name-specifier</em> refers to the current instantiation and that, when looked up, refers to at least one member of a class that is the current instantiation or a non-dependent base class thereof.</p>\n</blockquote>\n<p>So <code>Pe</code> is a member of the current instantiation. Thus, while the <em>nested-name-specifier</em> of <code>Pa&lt;AAA&gt;::Pe&lt;int&gt;</code> is a dependent type, it is a type that is a member of the current instantiation, so you do not need the keyword <code>typename</code>. Note that <code>Pa&lt;AAA&gt;::Pe&lt;int&gt;</code> <em>is</em> a dependent type itself (it's a nested class that is a dependent member of the current instantiation), but that in itself does mean that the <code>typename</code> keyword is required. </p>\n<p>The fact that gcc doesn't accept typename here:</p>\n<pre><code>/*typename*/ Pa&lt;AAA&gt;::Pe&lt;int&gt; qq;\n</code></pre>\n<p>because it wants</p>\n<pre><code>typename Pa&lt;AAA&gt;::template Pe&lt;int&gt; qq;\n</code></pre>\n<p>is a bug. </p>\n", "LastActivityDate": "2015-09-03T14:40:48.053", "CommentCount": "0", "CreationDate": "2015-09-03T14:40:48.053", "ParentId": "32377212", "Score": "3", "OwnerUserId": "2069064"}});