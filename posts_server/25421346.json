post_cb({"25478459": {"ParentId": "25421346", "LastEditDate": "2016-08-24T18:27:50.290", "CommentCount": "0", "CreationDate": "2014-08-25T03:00:12.343", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "PostTypeId": "2", "Id": "25478459", "Score": "13", "Body": "<p>As <code>std::function&lt;?&gt;</code> has to type-erase the copy constructor of the stored invocable object, you cannot construct it from a move-only type.  Your lambda, because it captures a move-only type by value, is a move-only type.  So... you cannot solve your problem.  <code>std::function</code> cannot store your lambda.</p>\n<p>At least not directly.</p>\n<p>This is C++, we simply route around the problem.</p>\n<pre><code>template&lt;class F&gt;\nstruct shared_function {\n  std::shared_ptr&lt;F&gt; f;\n  shared_function() = delete; // = default works, but I don't use it\n  shared_function(F&amp;&amp; f_):f(std::make_shared&lt;F&gt;(std::move(f_)){}\n  shared_function(shared_function const&amp;)=default;\n  shared_function(shared_function&amp;&amp;)=default;\n  shared_function&amp; operator=(shared_function const&amp;)=default;\n  shared_function&amp; operator=(shared_function&amp;&amp;)=default;\n  template&lt;class...As&gt;\n  auto operator()(As&amp;&amp;...as) const {\n    return (*f)(std::forward&lt;As&gt;(as)...);\n  }\n};\ntemplate&lt;class F&gt;\nshared_function&lt; std::decay_t&lt;F&gt; &gt; make_shared_function( F&amp;&amp; f ) {\n  return { std::forward&lt;F&gt;(f) };\n}\n</code></pre>\n<p>now that the above is done, we can solve your problem.</p>\n<pre><code>auto pi = std::make_unique&lt;int&gt;(0);\n\nauto foo = [q = std::move(pi)] {\n  *q = 5;\n  std::cout &lt;&lt; *q &lt;&lt; std::endl;\n};\n\nstd::function&lt; void() &gt; test = make_shared_function( std::move(foo) );\ntest(); // prints 5\n</code></pre>\n<p>The semantics of a <code>shared_function</code> is slightly different than other functions, as a copy of it shares the same state (including when turned into a <code>std::function</code>) as the original.</p>\n<p>We can also write a move-only fire-once function:</p>\n<pre><code>template&lt;class Sig&gt;\nstruct fire_once;\n\ntemplate&lt;class T&gt;\nstruct emplace_as {};\n\ntemplate&lt;class R, class...Args&gt;\nstruct fire_once&lt;R(Args...)&gt; {\n  // can be default ctored and moved:\n  fire_once() = default;\n  fire_once(fire_once&amp;&amp;)=default;\n  fire_once&amp; operator=(fire_once&amp;&amp;)=default;\n\n  // implicitly create from a type that can be compatibly invoked\n  // and isn't a fire_once itself\n  template&lt;class F,\n    std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;F&gt;, fire_once&gt;{}, int&gt; =0,\n    std::enable_if_t&lt;\n      std::is_convertible&lt;std::result_of_t&lt;std::decay_t&lt;F&gt;&amp;(Args...)&gt;, R&gt;{}\n      || std::is_same&lt;R, void&gt;{},\n      int\n    &gt; =0\n  &gt;\n  fire_once( F&amp;&amp; f ):\n    fire_once( emplace_as&lt;std::decay_t&lt;F&gt;&gt;{}, std::forward&lt;F&gt;(f) )\n  {}\n  // emplacement construct using the emplace_as tag type:\n  template&lt;class F, class...FArgs&gt;\n  fire_once( emplace_as&lt;F&gt;, FArgs&amp;&amp;...fargs ) {\n    rebind&lt;F&gt;(std::forward&lt;FArgs&gt;(fargs)...);\n  }\n  // invoke in the case where R is not void:\n  template&lt;class R2=R,\n    std::enable_if_t&lt;!std::is_same&lt;R2, void&gt;{}, int&gt; = 0\n  &gt;\n  R2 operator()(Args...args)&amp;&amp;{\n    try {\n      R2 ret = invoke( ptr.get(), std::forward&lt;Args&gt;(args)... );\n      clear();\n      return ret;\n    } catch(...) {\n      clear();\n      throw;\n    }\n  }\n  // invoke in the case where R is void:\n  template&lt;class R2=R,\n    std::enable_if_t&lt;std::is_same&lt;R2, void&gt;{}, int&gt; = 0\n  &gt;\n  R2 operator()(Args...args)&amp;&amp;{\n    try {\n      invoke( ptr.get(), std::forward&lt;Args&gt;(args)... );\n      clear();\n    } catch(...) {\n      clear();\n      throw;\n    }\n  }\n\n  // empty the fire_once:\n  void clear() {\n    invoke = nullptr;\n    ptr.reset();\n  }\n\n  // test if it is non-empty:\n  explicit operator bool()const{return (bool)ptr;}\n\n  // change what the fire_once contains:\n  template&lt;class F, class...FArgs&gt;\n  void rebind( FArgs&amp;&amp;... fargs ) {\n    clear();\n    auto pf = std::make_unique&lt;F&gt;(std::forward&lt;FArgs&gt;(fargs)...);\n    invoke = +[](void* pf, Args...args)-&gt;R {\n      return (*(F*)pf)(std::forward&lt;Args&gt;(args)...);\n    };\n    ptr = {\n      pf.release(),\n      [](void* pf){\n        delete (F*)(pf);\n      }\n    };\n  }\nprivate:\n  // storage.  A unique pointer with deleter\n  // and an invoker function pointer:\n  std::unique_ptr&lt;void, void(*)(void*)&gt; ptr{nullptr, +[](void*){}};\n  void(*invoke)(void*, Args...) = nullptr;\n};\n</code></pre>\n<p>which supports even non-movable types via the <code>emplace_as&lt;T&gt;</code> tag.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1cfdcd0491686fe1\" rel=\"noreferrer\">live example</a>.</p>\n<p>Note you have to evaluate <code>()</code> in an rvalue context (ie, after a <code>std::move</code>), as a silent destructive <code>()</code> seemed rude.</p>\n<p>This implementation does not use SBO, for if it did it would demand that the type stored be movable, and it would be more work (for me) to boot.</p>\n", "LastActivityDate": "2016-08-24T18:27:50.290"}, "25421346": {"CommentCount": "3", "AcceptedAnswerId": "25421519", "PostTypeId": "1", "LastEditorUserId": "1023390", "CreationDate": "2014-08-21T08:12:46.797", "LastActivityDate": "2017-05-25T21:48:11.430", "LastEditDate": "2017-05-25T21:48:11.430", "ViewCount": "3839", "FavoriteCount": "6", "Title": "How to create an std::function from a move-capturing lambda expression?", "Id": "25421346", "Score": "32", "Body": "<p>I'm trying to create an <code>std::function</code> from a move-capturing lambda expression. Note that I can create a move-capturing lambda expression without problems; it's only when I try to wrap it in an <code>std::function</code> that I get an error.</p>\n<p>For example:</p>\n<pre><code>auto pi = std::make_unique&lt;int&gt;(0);\n\n// no problems here!\nauto foo = [q = std::move(pi)] {\n    *q = 5;\n    std::cout &lt;&lt; *q &lt;&lt; std::endl;\n};\n\n// All of the attempts below yield:\n// \"Call to implicitly-deleted copy constructor of '&lt;lambda....\"\n\nstd::function&lt;void()&gt; bar = foo;\nstd::function&lt;void()&gt; bar{foo};\nstd::function&lt;void()&gt; bar{std::move(foo)};\nstd::function&lt;void()&gt; bar = std::move(foo);\nstd::function&lt;void()&gt; bar{std::forward&lt;std::function&lt;void()&gt;&gt;(foo)};\nstd::function&lt;void()&gt; bar = std::forward&lt;std::function&lt;void()&gt;&gt;(foo);\n</code></pre>\n<p>I'll explain why I want to write something like this. I've written a UI library which, similar to jQuery or JavaFX, allows the user to handle mouse/keyboard events by passing <code>std::function</code>s to methods with names like <code>on_mouse_down()</code>, <code>on_mouse_drag()</code>, <code>push_undo_action()</code>, etc. </p>\n<p>Obviously, the <code>std::function</code> I want to pass in should ideally use a move-capturing lambda expression, otherwise I need to resort to the ugly \"release/acquire-in-lambda\" idiom I was using when C++11 was the standard:</p>\n<pre><code>std::function&lt;void()&gt; baz = [q = pi.release()] {\n    std::unique_ptr&lt;int&gt; p{q};\n    *p = 5;\n    std::cout &lt;&lt; *q &lt;&lt; std::endl;\n};\n</code></pre>\n<p>Note that calling <code>baz</code> twice would be an error in the above code. However, in my code, this closure is guaranteed to be called exactly once.</p>\n<p>BTW, in my real code, I'm not passing an <code>std::unique_ptr&lt;int&gt;</code>, but something more interesting.</p>\n<p>Finally, I'm using Xcode6-Beta4 which uses the following version of clang:</p>\n<pre><code>Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)\nTarget: x86_64-apple-darwin13.3.0\nThread model: posix\n</code></pre>\n", "Tags": "<c++><lambda><std><c++14>", "OwnerUserId": "3665329", "AnswerCount": "2"}, "25421519": {"ParentId": "25421346", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_25421346_25421519_0\"><code>template&lt;class F&gt; function(F f);</code></p>\n<p id=\"so_25421346_25421519_1\"><code>template &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);</code></p>\n<p id=\"so_25421346_25421519_2\"><em>Requires:</em> <code>F</code> shall be <code>CopyConstructible</code>. <code>f</code> shall be <code>Callable</code> for argument types <code>ArgTypes</code> and return type <code>R</code>. The copy constructor and destructor of A shall not throw exceptions.</p>\n<p id=\"so_25421346_25421519_3\">\u00a720.9.11.2.1 [func.wrap.func.con]</p>\n</blockquote>\n<p>Note that <code>operator =</code> is defined in terms of this constructor and <code>swap</code>, so the same restrictions apply:</p>\n<blockquote>\n<p id=\"so_25421346_25421519_4\"><code>template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);</code></p>\n<p id=\"so_25421346_25421519_5\"><em>Effects:</em> <code>function(std::forward&lt;F&gt;(f)).swap(*this);</code></p>\n<p id=\"so_25421346_25421519_6\">\u00a720.9.11.2.1 [func.wrap.func.con]</p>\n</blockquote>\n<p>So to answer your question: Yes, it is possible to construct a <code>std::function</code> from a move-capturing lambda (since this only specifies how the lambda captures), but it is <strong>not</strong> possible to construct a <code>std::function</code> from a <strong>move-only type</strong> (e.g. a move-capturing lambda which move-captures something that is not copy constructible).</p>\n", "OwnerUserId": "1007504", "PostTypeId": "2", "Id": "25421519", "Score": "19", "CreationDate": "2014-08-21T08:22:12.730", "LastActivityDate": "2014-08-21T08:22:12.730"}, "bq_ids": {"n4140": {"so_25421346_25421519_1": {"section_id": 4658, "quality": 1.0, "length": 5}}, "n3337": {"so_25421346_25421519_2": {"section_id": 4470, "quality": 0.8571428571428571, "length": 12}, "so_25421346_25421519_1": {"section_id": 4469, "quality": 1.0, "length": 5}}, "n4659": {"so_25421346_25421519_1": {"section_id": 853, "quality": 0.8, "length": 4}}}});