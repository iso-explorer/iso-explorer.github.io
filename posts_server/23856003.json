post_cb({"bq_ids": {"n4140": {"so_23856003_23856057_0": {"length": 71, "quality": 0.9861111111111112, "section_id": 3919}}, "n3337": {"so_23856003_23856057_0": {"length": 71, "quality": 0.9861111111111112, "section_id": 3779}}, "n4659": {"so_23856003_23856057_0": {"length": 49, "quality": 0.6805555555555556, "section_id": 4805}}}, "23856057": {"Id": "23856057", "PostTypeId": "2", "Body": "<p>This section is outdated. The C++03 standard had no mention of threads, so when C++ implementations added them, they did whatever they wanted to with regards to the thread-safety of language constructs. A common choice was to not ensure thread-safe initialisation of static local variables.</p>\n<p>In C++11, local static variables are guaranteed to be initialised exactly once, the first time that the program's control flow passes through their declaration, even if this happens concurrently on multiple threads <code>6.7/4</code>:</p>\n<blockquote>\n<p id=\"so_23856003_23856057_0\">An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>Even so, this only ensures that initialisation is safe. If you plan to use the returned <code>FileSystem</code> from multiple threads simultaneously, <code>FileSystem</code> must itself provide threadsafe operations.</p>\n", "LastActivityDate": "2014-05-25T14:00:31.417", "CommentCount": "0", "CreationDate": "2014-05-25T14:00:31.417", "ParentId": "23856003", "Score": "8", "OwnerUserId": "485561"}, "23856003": {"ViewCount": "1286", "Body": "<p>I am currently reading Effective C++. There is a section about using static local variables and it says that if multiple threads access a static variable, there may be a race condition during initialization of that variable.</p>\n<p>At least that is my interpretation. Is this true? In C# for example, initialization of a class static variable will never have a race condition.</p>\n<p>For example, can this code have a race condition during the static variable initialization?</p>\n<pre><code>FileSystem&amp; tfs()\n{\n    static FileSystem fs;\n    return fs;\n}\n</code></pre>\n<p>Below is the except from the book.</p>\n<blockquote>\n<p id=\"so_23856003_23856003_0\">Here's the technique applied to both tfs and tempDir:</p>\n<pre><code>class FileSystem { ... }; // as before\n\nFileSystem&amp; tfs() // this replaces the tfs object; it could static in the FileSystem class\n{\n    static FileSystem fs; // define and initialize a local static object\n    return fs; // return a reference to it\n}\n</code></pre>\n<p id=\"so_23856003_23856003_1\">.</p>\n<pre><code>class Directory { ... }; // as before\n\nDirectory::Directory( params ) // as before, except references to tfs are now to tfs()\n{\n ...\n std::size_t disks = tfs().numDisks();\n ...\n}\n\nDirectory&amp; tempDir() // this replaces the tempDir object; it could be static in the Directory class\n{\n    static Directory td; // define/initialize local static object\n    return td; // return reference to it\n}\n</code></pre>\n<p id=\"so_23856003_23856003_2\">Clients of this modified system program exactly as they used to,\n  except they now refer to <code>tfs()</code> and <code>tempDir()</code> instead of <code>tfs</code> and\n  <code>tempDir</code>. That is, they use functions returning references to objects\n  instead of using the objects themselves.</p>\n<p id=\"so_23856003_23856003_3\">The reference-returning functions dictated by this scheme are always\n  simple: define and initialize a local static object on line 1, return\n  it on line 2. This simplicity makes them excellent candidates for\n  inlining, especially if they're called frequently (see Item 30). On\n  the other hand, the fact that these functions contain static objects\n  makes them problematic in multithreaded systems. <strong>Then again, any kind\n  of non-const static object \u2014 local or non-local \u2014 is trouble waiting\n  to happen in the presence of multiple threads. One way to deal with\n  such trouble is to manually invoke all the reference-returning\n  functions during the single-threaded startup portion of the program.\n  This eliminates initialization-related race conditions.</strong></p>\n</blockquote>\n", "AcceptedAnswerId": "23856057", "Title": "Race conditions in static local variables", "CreationDate": "2014-05-25T13:55:21.837", "Id": "23856003", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-05-25T13:59:09.897", "LastEditorUserId": "1973271", "LastActivityDate": "2014-05-25T14:00:31.417", "Score": "3", "OwnerUserId": "918683", "Tags": "<c++><multithreading><initialization><singleton><race-condition>", "AnswerCount": "1"}});