post_cb({"bq_ids": {"n4140": {"so_48453898_48454260_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 5991}, "so_48453898_48454417_3": {"length": 7, "quality": 0.875, "section_id": 7189}, "so_48453898_48454417_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_48453898_48454157_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5991}, "so_48453898_48454417_6": {"length": 7, "quality": 0.6363636363636364, "section_id": 7170}}, "n3337": {"so_48453898_48454260_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 5759}, "so_48453898_48454417_3": {"length": 7, "quality": 0.875, "section_id": 6933}, "so_48453898_48454417_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_48453898_48454157_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5759}, "so_48453898_48454417_6": {"length": 7, "quality": 0.6363636363636364, "section_id": 6914}}, "n4659": {"so_48453898_48454260_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 7491}, "so_48453898_48454417_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_48453898_48454157_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7491}, "so_48453898_48454417_4": {"length": 8, "quality": 0.8888888888888888, "section_id": 8697}, "so_48453898_48454417_3": {"length": 7, "quality": 0.875, "section_id": 8697}, "so_48453898_48454417_6": {"length": 7, "quality": 0.6363636363636364, "section_id": 8678}}}, "48454260": {"Id": "48454260", "PostTypeId": "2", "Body": "<p>Ok my bad from giving the below answer from former pre C++14 standard, reading the C++17, seems to me both GCC and Clang are correct:</p>\n<p>From: N4659 8.2.2/4 Function call [expr.call]</p>\n<blockquote>\n<p id=\"so_48453898_48454260_0\">It is implementation-defined whether the lifetime of a parameter ends\n  when the function in which it is defined returns or at the end of the\n  enclosing full-expression. The initialization and destruction of each\n  parameter occurs within the context of the calling function.</p>\n</blockquote>\n", "LastActivityDate": "2018-01-26T00:46:36.530", "Score": "-2", "CreationDate": "2018-01-26T00:46:36.530", "ParentId": "48453898", "CommentCount": "2", "OwnerUserId": "5352221"}, "48453898": {"ViewCount": "256", "Body": "<p>According to 5.2.2/4 \"Function call\" in n4640 (<a href=\"http://eel.is/c++draft/expr.call#4\" rel=\"nofollow noreferrer\">8.2.2/4</a> in n4659) function parameters are created and destroyed in the context of the caller. And implementations are allowed to delay the destruction of function parameters to the end of the enclosing full expression (as an implementation-defined feature). Note that the choice is not <em>unspecified</em>, but rather <em>implementation-defined</em>.</p>\n<p>(<strike>It is not entirely clear how this agrees with 3.3.3 \"Block scope\" (6.3.3 in n4659), which seems to imply that function parameters have block scope, and then 3.7.3 \"Automatic storage duration\" (6.7.3 in n4659), which says that the storage for block scope variables lasts until the block in which they are created exits. But let's assume that I'm missing/misunderstanding something in the wording.</strike> Apparently now function parameters will have <a href=\"http://eel.is/c++draft/basic.scope.param\" rel=\"nofollow noreferrer\">their own scope</a>)</p>\n<p>As far as I know, ABI requires GCC and Clang to delay the destruction of function parameters to the end of full expression, i.e. this is the implementation-defined behavior of these compilers. I would guess that in implementations like that it should be OK to return references/pointers to function parameters as long as these references/pointers are used within the calling expression only.</p>\n<p>However, the following example segfaults in GCC and works fine in Clang</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstd::string &amp;foo(std::string s)\n{\n  return s;\n}\n\nint main()\n{\n   std::cout &lt;&lt; foo(\"Hello World!\") &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Both compilers issue a warning about returning a reference to a local variable, which is perfectly appropriate here. A quick inspection of the generated code shows that both compilers do indeed delay the destruction of the parameter to the end of the expression. However, GCC still deliberately returns a \"null reference\" from <code>foo</code>, which causes the crash. Meanwhile, Clang behaves \"as expected\", returning a reference to its parameter <code>s</code>, which survives long enough to produce the expected output.</p>\n<p>(GCC is easy to fool in this case by simply doing</p>\n<pre><code>std::string &amp;foo(std::string s)\n{\n  std::string *p = &amp;s;\n  return *p;\n}\n</code></pre>\n<p>which fixes the segfault under GCC.)</p>\n<p>Is GCC's behavior justified in this case, under assumption that it guarantees \"late\" destruction of parameters? Am I missing some other passage in the standard that says that returning references to function parameters is always undefined, even if their lifetimes are extended by the implementation?</p>\n", "Title": "Late destruction of function parameters", "CreationDate": "2018-01-26T00:02:54.223", "LastActivityDate": "2018-01-26T10:48:40.593", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-01-26T01:40:25.370", "LastEditorUserId": "187690", "Id": "48453898", "Score": "13", "OwnerUserId": "187690", "Tags": "<c++><scope><lifetime><function-parameter><destruction>", "AnswerCount": "3"}, "48454157": {"Id": "48454157", "PostTypeId": "2", "Body": "<p>From 5.2.2/4 Function call [expr.call], seems to me GCC is correct:</p>\n<blockquote>\n<p id=\"so_48453898_48454157_0\">The lifetime of a parameter ends when the function in which it is\n  defined returns. The initialization and destruction of each parameter\n  occurs within the context of the calling function.</p>\n</blockquote>\n", "LastEditorUserId": "5352221", "LastActivityDate": "2018-01-26T00:39:48.467", "Score": "-2", "CreationDate": "2018-01-26T00:33:47.903", "ParentId": "48453898", "CommentCount": "7", "OwnerUserId": "5352221", "LastEditDate": "2018-01-26T00:39:48.467"}, "48454417": {"Id": "48454417", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48453898_48454417_0\">As far as I know, ABI requires GCC and Clang to delay the destruction of function parameters to the end of full expression</p>\n</blockquote>\n<p>The question relies heavily on this assumption. Let's see if it's correct. Itanium C++ ABI draft <a href=\"https://itanium-cxx-abi.github.io/cxx-abi/abi.html#value-parameter\" rel=\"nofollow noreferrer\">3.1.1 Value Parameters</a> says</p>\n<blockquote>\n<p id=\"so_48453898_48454417_1\">If the type has a non-trivial destructor, the caller calls that destructor after control returns to it (including when the caller throws an exception), at the end of enclosing full-expression.</p>\n</blockquote>\n<p>The ABI doesn't define <em>lifetime</em>, so let us check C++ standard draft N4659 <a href=\"http://eel.is/c++draft/basic.life#1\" rel=\"nofollow noreferrer\">[basic.life]</a></p>\n<blockquote>\n<p id=\"so_48453898_48454417_2\">1.2 ... The lifetime of an object o of type T ends when:</p>\n<p id=\"so_48453898_48454417_3\">1.3 if T is a class type with a non-trivial destructor (15.4), the destructor call starts, or ...</p>\n<p id=\"so_48453898_48454417_4\">1.4 the storage which the object occupies is released, or is reused by an object that is not nested within o ([intro.object]).</p>\n</blockquote>\n<p>The C++ standard says that lifetime ends in this case when the destructor is called. As such, the ABI does indeed require that the lifetime of a function parameter extends the full expression of the function call.</p>\n<p>Assuming that implementation defined requirement, I see no UB in the example program, so it should have expected behaviour on any implementation that guarantees to follow the Itanium C++ ABI. GCC appears to violate that.</p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html\" rel=\"nofollow noreferrer\">GCC docs</a> do state that</p>\n<blockquote>\n<p id=\"so_48453898_48454417_5\">From GCC version 3 onwards the GNU C++ compiler uses an industry-standard C++ ABI, the Itanium C++ ABI. </p>\n</blockquote>\n<p>As such, the demonstrated behaviour could be considered a bug.</p>\n<p>On the other hand, it is unclear whether this consequence of the changed wording of [expr.call] is intentional. The consequence might be considered to be a defect.</p>\n<hr>\n<blockquote>\n<p id=\"so_48453898_48454417_6\">... which says that the storage for block scope variables lasts until the block in which they are created exits.</p>\n</blockquote>\n<p>Indeed. But the <a href=\"http://eel.is/c++draft/expr.call\" rel=\"nofollow noreferrer\">[expr.call]</a>/4 that you quoted says <em>\"function parameters are <strong>created</strong> and destroyed in the <strong>context of the caller</strong>\"</em>. As such, the storage lasts until the end of the block of the function call. There appears to be no conflict with the storage duration.</p>\n<hr>\n<p>Note that the C++ standard links point to a site that is periodically generated from the <em>current</em> draft and therefore may differ from N4659 that I've quoted.</p>\n</hr></hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2018-01-26T10:48:40.593", "Score": "5", "CreationDate": "2018-01-26T01:05:30.263", "ParentId": "48453898", "CommentCount": "1", "OwnerUserId": "2079303", "LastEditDate": "2018-01-26T10:48:40.593"}});