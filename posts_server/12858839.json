post_cb({"30991097": {"Id": "30991097", "PostTypeId": "2", "Body": "<p>Since you said you were still waiting for a better answer, here's my take on it. It's not perfect, but I think it gets you as far as possible using SFINAE and partial specializations. (I guess Concepts will provide a complete and elegant solution, but we'll have to wait a bit longer for that.)</p>\n<p>The solution relies on a feature of alias templates that was specified only recently, in the standard working drafts after the final version of C++14, but has been supported by implementations for a while. The relevant wording in draft N4527 [14.5.7p3] is:</p>\n<blockquote>\n<p id=\"so_12858839_30991097_0\">However, if the template-id is dependent, subsequent template argument substitution still applies to the template-id. [ Example:</p>\n<pre><code>template&lt;typename...&gt; using void_t = void;\ntemplate&lt;typename T&gt; void_t&lt;typename T::foo&gt; f();\nf&lt;int&gt;(); // error, int does not have a nested type foo\n</code></pre>\n<p id=\"so_12858839_30991097_1\">\u2014end example ]</p>\n</blockquote>\n<p>Here's a complete example implementing this idea:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;typename&gt; struct User { static void f() { std::cout &lt;&lt; \"primary\\n\"; } };\n\ntemplate&lt;typename&gt; struct Data { };\ntemplate&lt;typename T, typename U&gt; struct Derived1 : Data&lt;T*&gt; { };\ntemplate&lt;typename&gt; struct Derived2 : Data&lt;double&gt; { };\nstruct DD : Data&lt;int&gt; { };\n\ntemplate&lt;typename T&gt; void take_data(Data&lt;T&gt;&amp;&amp;);\n\ntemplate&lt;typename T, typename = decltype(take_data(std::declval&lt;T&gt;()))&gt; \nusing enable_if_data = T;\n\ntemplate&lt;template&lt;typename...&gt; class TT, typename... Ts&gt; \nstruct User&lt;enable_if_data&lt;TT&lt;Ts...&gt;&gt;&gt; \n{ \n    static void f() { std::cout &lt;&lt; \"partial specialization for Data\\n\"; } \n};\n\ntemplate&lt;typename&gt; struct Other { };\ntemplate&lt;typename T&gt; struct User&lt;Other&lt;T&gt;&gt; \n{ \n    static void f() { std::cout &lt;&lt; \"partial specialization for Other\\n\"; } \n};\n\nint main()\n{\n    User&lt;int&gt;::f();\n    User&lt;Data&lt;int&gt;&gt;::f();\n    User&lt;Derived1&lt;int, long&gt;&gt;::f();\n    User&lt;Derived2&lt;char&gt;&gt;::f();\n    User&lt;DD&gt;::f();\n    User&lt;Other&lt;int&gt;&gt;::f();\n}\n</code></pre>\n<p>Running it prints:</p>\n<pre><code>primary\npartial specialization for Data\npartial specialization for Data\npartial specialization for Data\nprimary\npartial specialization for Other\n</code></pre>\n<p>As you can see, there's a wrinkle: the partial specialization isn't selected for <code>DD</code>, and it can't be, because of the way we declared it. So, why don't we just say</p>\n<pre><code>template&lt;typename T&gt; struct User&lt;enable_if_data&lt;T&gt;&gt; \n</code></pre>\n<p>and allow it to match <code>DD</code> as well? This actually works in GCC, but is correctly rejected by Clang and MSVC because of [14.5.5p8.3, 8.4] ([p8.3] may disappear in the future, as it's redundant - <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2033\" rel=\"noreferrer\">CWG 2033</a>):</p>\n<blockquote id=\"so_12858839_30991097_2\">\n<ul>\n<li>The argument list of the specialization shall not be identical to\n  the implicit argument list of the primary template.</li>\n<li>The specialization shall be more specialized than the primary template (14.5.5.2).</li>\n</ul>\n</blockquote>\n<p><code>User&lt;enable_if_data&lt;T&gt;&gt;</code> is equivalent to <code>User&lt;T&gt;</code> (modulo substitution into that default argument, which is handled separately, as explained by the first quote above), thus an invalid form of partial specialization. Unfortunately, matching things like <code>DD</code> would require, in general, a partial specialization argument of the form <code>T</code> - there's no other form it can have and still match every case. So, I'm afraid we can conclusively say that this part cannot be solved within the given constraints. (There's <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1980\" rel=\"noreferrer\">Core issue 1980</a>, which hints at some possible future rules regarding the use of template aliases, but I doubt they'll make our case valid.)</p>\n<p>As long as the classes derived from <code>Data&lt;T&gt;</code> are themselves template specializations, further constraining them using the technique above will work, so hopefully this will be of some use to you.</p>\n<hr>\n<p>Compiler support (this is what I tested, other versions may work as well):</p>\n<ul>\n<li>Clang 3.3 - 3.6.0, with <code>-Wall -Wextra -std=c++11 -pedantic</code> - works as described above.</li>\n<li>GCC 4.7.3 - 4.9.2, same options - same as above. Curiously, GCC 5.1.0 - 5.2.0 no longer selects the partial specialization using the correct version of the code. This looks like a regression. I don't have time to put together a proper bug report; feel free to do it if you want. The problem seems to be related to the use of parameter packs together with a template template parameter. Anyway, GCC accepts the incorrect version using <code>enable_if_data&lt;T&gt;</code>, so that can be a temporary solution.</li>\n<li>MSVC: Visual C++ 2015, with <code>/W4</code>, works as described above. Older versions don't like the <code>decltype</code> in the default argument, but the technique itself still works - replacing the default argument with another way of expressing the constraint makes it work on 2013 Update 4.</li>\n</ul>\n</hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2015-08-17T09:57:27.203", "Score": "6", "CreationDate": "2015-06-22T22:46:26.643", "ParentId": "12858839", "CommentCount": "0", "OwnerUserId": "4326278", "LastEditDate": "2015-08-17T09:57:27.203"}, "bq_ids": {"n4140": {"so_12858839_30991097_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 142}}, "n3337": {"so_12858839_30991097_2": {"length": 11, "quality": 0.6111111111111112, "section_id": 136}}, "n4659": {"so_12858839_30991097_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 171}, "so_12858839_30991097_2": {"length": 10, "quality": 0.5555555555555556, "section_id": 629}}}, "12858839": {"ViewCount": "7627", "Body": "<p>suppose I have these declarations</p>\n<pre><code>template&lt;typename T&gt; class User;\ntemplate&lt;typename T&gt; class Data;\n</code></pre>\n<p>and want to implement <code>User&lt;&gt;</code> for <code>T = Data&lt;some_type&gt;</code> <em>and any class derived from <code>Data&lt;some_type&gt;</code></em> but also allow for other specialisations defined elsewhere.</p>\n<p>If I didn't already have the declaration of the class template <code>User&lt;&gt;</code>, I could simply</p>\n<pre><code>template&lt;typename T,\n         typename A= typename std::enable_if&lt;is_Data&lt;T&gt;::value&gt;::type&gt;\nclass User { /*...*/ };\n</code></pre>\n<p>where</p>\n<pre><code>template&lt;template&lt;typename&gt; data&gt;&gt; struct is_Data\n{ static const bool value = /* some magic here (not the question) */; };\n</code></pre>\n<p>However, this has two template parameters and thus clashes with the previous declaration, where <code>User&lt;&gt;</code> is declared with only one template parameter. Is there anything else I can do?</p>\n<p>(Note</p>\n<pre><code>template&lt;typename T,\n         typename A= typename std::enable_if&lt;is_Data&lt;T&gt;::value&gt;::type&gt;\nclass User&lt;T&gt; { /*...*/ };\n</code></pre>\n<p>doesn't work (<em>default template arguments may not be used in partial specializations</em>),\nnor does</p>\n<pre><code>template&lt;typename T&gt; class User&lt;Data&lt;T&gt;&gt; { /*...*/ };\n</code></pre>\n<p>as it doesn't allow types derived from <code>Data&lt;&gt;</code>, neither does</p>\n<pre><code>template&lt;typename T&gt;\nclass User&lt;typename std::enable_if&lt;is_Data&lt;T&gt;::value,T&gt;::type&gt;\n{ /*...*/ };\n</code></pre>\n<p>since <em>template parameter <code>T</code> is not used in partial specialization</em>.)</p>\n", "AcceptedAnswerId": "30991097", "Title": "using SFINAE for template class specialisation", "CreationDate": "2012-10-12T12:14:16.303", "Id": "12858839", "CommentCount": "11", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2014-09-18T20:17:15.077", "LastEditorUserId": "1023390", "LastActivityDate": "2016-08-24T07:51:47.193", "Score": "26", "OwnerUserId": "1023390", "Tags": "<c++><templates><c++11><sfinae>", "AnswerCount": "3"}, "12859801": {"Id": "12859801", "PostTypeId": "2", "Body": "<p><strong>IF</strong> the original declaration of <code>User&lt;&gt;</code> can be adapted to</p>\n<pre><code>template&lt;typename, typename=std::true_type&gt; class User;\n</code></pre>\n<p>then we can find a solution (following Luc Danton's comment, instead of using <a href=\"http://en.cppreference.com/w/cpp/types/enable_if\" rel=\"nofollow\"><code>std::enable_if</code></a>)</p>\n<pre><code>template&lt;typename&gt;\nstruct is_Data : std::false_type {};\ntemplate&lt;typename T&gt;\nstruct is_Data&lt;Data&lt;T&gt;&gt; : std::true_type {};\n\ntemplate&lt;typename T&gt;\nclass User&lt;T, typename is_Data&lt;T&gt;::type &gt;\n{ /* ... */ };\n</code></pre>\n<p>However, this <em>doesn't answer the original question</em>, since it requires to change the original definition of <code>User</code>. I'm still <em>waiting for a better answer</em>. This could be one that conclusively <em>demonstrates that no other solution is possible</em>.</p>\n", "LastEditorUserId": "1023390", "LastActivityDate": "2016-08-24T07:51:47.193", "Score": "18", "CreationDate": "2012-10-12T13:09:09.543", "ParentId": "12858839", "CommentCount": "5", "OwnerUserId": "1023390", "LastEditDate": "2016-08-24T07:51:47.193"}, "21891407": {"Id": "21891407", "PostTypeId": "2", "Body": "<p>As you only want to implement it when a single condition is true, the easiest solution is to use a static assertion. It does not require SFINAE, gives a clear compile error if used incorrectly and the declaration of <code>User&lt;&gt;</code> does not need to be adapted: </p>\n<pre><code>template&lt;typename T&gt; class User {\n  static_assert(is_Data&lt;T&gt;::value, \"T is not (a subclass of) Data&lt;&gt;\");\n  /** Implementation. **/\n};\n</code></pre>\n<p>See also: <a href=\"https://stackoverflow.com/questions/11984768/when-to-use-static-assert-instead-of-sfinae\">When to use <code>static_assert</code> instead of SFINAE?</a>. The <code>static_assert</code> is a c++11 construct, however there are plenty workarounds available for pre-c++11 compilers, like:</p>\n<pre><code>#define STATIC_ASSERT(consdition,name) \\\n  typedef char[(condition)?1:-1] STATIC_ASSERT_ ## name\n</code></pre>\n<hr>\n<p>If the declaration of <code>user&lt;&gt;</code> can be changed and you want two implementations depending on the value of <code>is_Data</code>, then there is also a solution that does not use SFINAE:</p>\n<pre><code>template&lt;typename T, bool D=is_Data&lt;T&gt;::value&gt; class User;\n\ntemplate&lt;typename T&gt; class User&lt;T, true&gt; {\n  static_assert(is_Data&lt;T&gt;::value, \"T is not (a subclass of) Data&lt;&gt;\"); // Optional\n  /* Data implementation */\n};\n\ntemplate&lt;typename T&gt; class User&lt;T, false&gt; {\n  static_assert(!is_Data&lt;T&gt;::value, \"T is (a subclass of) Data&lt;&gt;\"); // Optional\n  /* Non-data implementation */\n};\n</code></pre>\n<p>The static assertions only checks whether the user did not accidentally specify the template argument <code>D</code> incorrectly. If <code>D</code> is not specified explicitly, then  the static assertions can be omitted.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-19T20:14:10.050", "Score": "5", "CreationDate": "2014-02-19T20:14:10.050", "ParentId": "12858839", "CommentCount": "1", "OwnerUserId": "558366", "LastEditDate": "2017-05-23T12:02:44.073"}});