post_cb({"31271975": {"ViewCount": "956", "Body": "<p>This works:</p>\n<pre><code>int arr[10] = {};\n</code></pre>\n<p>All elements of <code>arr</code> are value-initialized to zero.</p>\n<p>Why doesn't this work:</p>\n<pre><code>std::array&lt;int, 10&gt; arr({}); \n</code></pre>\n<p>I get the following warning from g++ (version 4.8.2):</p>\n<blockquote>\n<p id=\"so_31271975_31271975_0\">warning: missing initializer for member \u2018std::array&lt;int, 10ul&gt;::_M_elems\u2019</p>\n</blockquote>\n", "Title": "Why can I initialize a regular array from {}, but not a std::array", "CreationDate": "2015-07-07T14:48:09.783", "LastActivityDate": "2015-07-10T14:22:00.423", "CommentCount": "5", "LastEditDate": "2015-07-07T19:41:03.080", "PostTypeId": "1", "LastEditorUserId": "1708801", "Id": "31271975", "Score": "10", "OwnerUserId": "2725810", "Tags": "<c++><c++11><compiler-warnings><g++4.8><aggregate-initialization>", "AnswerCount": "3"}, "31272058": {"Id": "31272058", "PostTypeId": "2", "Body": "<p>There are two issues one which is a matter of style and the warning.</p>\n<p>Although it may not be obvious, aggregate initialization is happening on a temporary which is then being used as an argument to the copy constructor. The more idiomatic to do this initialization would be as follows:</p>\n<pre><code>std::array&lt;int, 10&gt; arr = {}; \n</code></pre>\n<p>Although this still leaves the warning.</p>\n<p>The warning is covered by <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36750\" rel=\"nofollow noreferrer\">gcc bug report:  - -Wmissing-field-initializers relaxation request </a> and one of the comments says:</p>\n<blockquote>\n<p id=\"so_31271975_31272058_0\">[...]Surely, the C++ syntax of saying MyType x = {}; should be supported,\n  as seen here:</p>\n<p id=\"so_31271975_31272058_1\"><a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/aggregate_initialization</a></p>\n<p id=\"so_31271975_31272058_2\">where for instance:</p>\n<pre><code>struct S {\n  int a;\n  float b;\n  std::string str;\n};\n\nS s = {}; // identical to S s = {0, 0.0, std::string};\n</code></pre>\n<p id=\"so_31271975_31272058_3\">That shouldn't warn for the reasons stated in earlier comments.</p>\n</blockquote>\n<p>and a follow-up comment says:</p>\n<blockquote>\n<p id=\"so_31271975_31272058_4\">My statement about zero-initialization was inaccurate (thanks), but\n  the general point still stands: in C you have to write ' = {0}' since\n  empty-braces initializer is not supported by the language (you get a\n  warning with -pedantic); in C++, you can write ' = {}' or 'T foo =\n  T();', but you don't need to write ' = {0}' specifically.</p>\n</blockquote>\n<p>The latest versions of gcc does not produce this warning for this case, <a href=\"http://melpon.org/wandbox/permlink/J98wUnm6uFXtPmx3\" rel=\"nofollow noreferrer\">see it live working with gcc 5.1</a>.</p>\n<p>We can see this topic also covered in the Clang Developers lists in the thead: <a href=\"http://clang-developers.42468.n3.nabble.com/Wmissing-field-initializers-td3761260.html\" rel=\"nofollow noreferrer\">-Wmissing-field-initializers</a>.</p>\n<p>For reference the draft C++11 standard section <code>8.5.1</code> <em>[dcl.init.aggr]</em> says:</p>\n<blockquote>\n<p id=\"so_31271975_31272058_5\">If there are fewer initializer-clauses in the list than there are\n  members in the aggregate, then each member not explicitly initialized\n  shall be initialized from an empty initializer list (8.5.4). [\n  Example:</p>\n<pre><code>struct S { int a; const char* b; int c; };\nS ss = { 1, \"asdf\" };\n</code></pre>\n<p id=\"so_31271975_31272058_6\">initializes ss.a with 1, ss.b with \"asdf\", and ss.c with the value of\n  an expression of the form int(), that is, 0. \u2014end example ]</p>\n</blockquote>\n<p>So as this is valid C++, although as noted using <code>{}</code> is not valid C99. One could argue that it is only a warning, but this seems like idiomatic C++ using <code>{}</code> for aggregate initialization and is problematic if we are using <code>-Werror</code> to turn warnings into errors.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-10T14:22:00.423", "Score": "12", "CreationDate": "2015-07-07T14:51:35.860", "ParentId": "31271975", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2015-07-10T14:22:00.423"}, "31307066": {"Id": "31307066", "PostTypeId": "2", "Body": "<p>Enough people have pointed this out as a \"problem\" when compiling with <code>-Werror</code> that I think it's worth mentioning that the problem goes away if you just double up:</p>\n<pre><code>std::array&lt;int, 10&gt; arr{{}};\n</code></pre>\n<p>Does not produce any warning for me on gcc 4.9.2.</p>\n<p>To add a bit as to why this solves it: my understanding was that std::array is actually a class with a C array as its only member. So double up on the braces makes sense: the outer braces indicate you are initializing the class, and then the inner braces default initialize the one and only member of the class.</p>\n<p>Since there is no possible ambiguity when there is only one variable in a class, just using one pair of {} should be reasonable, but gcc is overly pedantic here, and warns.</p>\n", "LastActivityDate": "2015-07-09T02:25:33.107", "CommentCount": "0", "CreationDate": "2015-07-09T02:25:33.107", "ParentId": "31271975", "Score": "2", "OwnerUserId": "1908347"}, "bq_ids": {"n4140": {"so_31271975_31272058_5": {"length": 17, "quality": 0.8947368421052632, "section_id": 3304}, "so_31271975_31272058_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 3304}}, "n3337": {"so_31271975_31272058_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 3174}, "so_31271975_31272058_5": {"length": 17, "quality": 0.8947368421052632, "section_id": 3174}}, "n4659": {"so_31271975_31272058_6": {"length": 9, "quality": 0.8181818181818182, "section_id": 4070}, "so_31271975_31272058_5": {"length": 15, "quality": 0.7894736842105263, "section_id": 4070}}}, "31277373": {"Id": "31277373", "PostTypeId": "2", "Body": "<p>Firstly, you <em>can</em> use the <code>({})</code> initializer with an <code>std::array</code> object, but semantically that stands for direct-initialization using copy-constructor from a temporary value-initialized <code>std::array</code> object, i.e. it is equivalent to</p>\n<pre><code>std::array&lt;int, 10&gt; arr(std::array&lt;int, 10&gt;{}); \n</code></pre>\n<p>And it is actually supposed to compile.</p>\n<p>Secondly, you don't really have to go the <code>({})</code> way when you can just do</p>\n<pre><code>std::array&lt;int, 10&gt; arr = {};\n</code></pre>\n<p>or </p>\n<pre><code>std::array&lt;int, 10&gt; arr{};\n</code></pre>\n<p>The first of the two is the most syntactically similar to your <code>int arr[10] = {};</code>, which makes me wonder why you didn't try it at first. Why did you decide to use <code>({})</code> instead of <code>= {}</code> when you built the <code>std::array</code> version of <code>= {}</code> syntax?</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2015-07-09T01:48:06.063", "Score": "5", "CreationDate": "2015-07-07T19:13:37.363", "ParentId": "31271975", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2015-07-09T01:48:06.063"}});