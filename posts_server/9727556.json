post_cb({"9727894": {"ParentId": "9727556", "CommentCount": "6", "Body": "<p>I'm not sure whether we could call it an \"oversight\", per se.</p>\n<p>No, you can't provide your own allocator to these specialised algorithms. But then there are other things that the standard doesn't contain, either.</p>\n<p>@MarkB identifies a very good reason that the standard <em>shouldn't</em> do this (that the range has no knowledge of the container's allocator). I'd go so far as to say it's just an inherent limitation.</p>\n<p>You can always re-invent <code>uninitialized_copy</code> for your needs, knowing what the allocator should be. It's just a two-line <code>for</code> loop.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "9727894", "Score": "2", "CreationDate": "2012-03-15T20:45:59.263", "LastActivityDate": "2012-03-15T20:45:59.263"}, "9727759": {"ParentId": "9727556", "CommentCount": "2", "Body": "<p>If these functions were free-functions, I can't see any way that the compiler could detect allocator mismatches since the allocator type isn't retained by the iterator. This in turn could result in a variety of hard-to-find problems.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "9727759", "Score": "1", "CreationDate": "2012-03-15T20:34:42.100", "LastActivityDate": "2012-03-15T20:34:42.100"}, "bq_ids": {"n4140": {"so_9727556_9727556_1": {"section_id": 805, "quality": 0.875, "length": 7}, "so_9727556_9727556_0": {"section_id": 709, "quality": 0.6206896551724138, "length": 36}}, "n3337": {"so_9727556_9727556_1": {"section_id": 794, "quality": 0.875, "length": 7}, "so_9727556_9727556_0": {"section_id": 698, "quality": 0.7931034482758621, "length": 46}}, "n4659": {"so_9727556_9727556_1": {"section_id": 863, "quality": 0.875, "length": 7}, "so_9727556_9727556_0": {"section_id": 738, "quality": 0.6206896551724138, "length": 36}}}, "9727556": {"CommentCount": "9", "ViewCount": "502", "PostTypeId": "1", "LastEditorUserId": "13430", "CreationDate": "2012-03-15T20:21:04.000", "LastActivityDate": "2012-08-15T14:05:23.000", "Title": "is uninitialized_copy/fill(In first, In last, For dest, A &a) an oversight in the c++ standard?", "AcceptedAnswerId": "9727894", "LastEditDate": "2012-08-15T14:05:23.000", "Id": "9727556", "Score": "3", "Body": "<p>I like to know how things work and as such have been delving deep into the c++ standard library. Something occurred to me the other day.</p>\n<p>It is required that containters (for example: <code>std::vector&lt;int, std::allocator&lt;int&gt; &gt;</code>) use the allocator specified for allocations. Specifically the standard says:</p>\n<p>23.1.8</p>\n<blockquote>\n<p id=\"so_9727556_9727556_0\">Copy constructors for all container types defined in this clause copy\n  an allocator argument from their respective first parameters. All\n  other constructors for these container types take an Allocator&amp;\n  argument (20.1.5), an allocator whose value type is the same as the\n  container\u2019s value type. A copy of this argument is used for any memory\n  allocation performed, by these constructors and by all member\n  functions, during the lifetime of each container object. In all\n  container types defined in this clause, the member get_allocator()\n  returns a copy of the Allocator object used to construct the\n  container.</p>\n</blockquote>\n<p>Also later in the standard it says (in a few different spots but i'll pick one) things like this:</p>\n<pre><code>explicit deque(size_type n, const T&amp; value = T(), const Allocator&amp; = Allocator());\n</code></pre>\n<blockquote>\n<p id=\"so_9727556_9727556_1\">Effects: Constructs a deque with n copies of value,\n  using the specified allocator.</p>\n</blockquote>\n<p><strong>OK, so on to my question.</strong></p>\n<p>Let's take <code>std::vector</code> as an example, the natural and efficient way to implement something like:</p>\n<pre><code>vector&lt;T, A&gt;::vector(const vector&amp; x)\n</code></pre>\n<p>might look something like this:</p>\n<pre><code>template &lt;class T, class A&gt;\nvector&lt;T, A&gt;::vector(const vector&amp; x)  {\n    pointer p = alloc_.allocate(x.size());\n    std::uninitialized_copy(x.begin(), x.end(), p);\n    first_ = p;\n    last_  = p + x.size();\n    end_   = p + x.size();\n}\n</code></pre>\n<p>specifically, we allocate some memory and then copy construct all the members in place. Not bothering to do something like <code>new value_type[x.size()]</code> because that would default construct the array only to overwrite it!.</p>\n<p><strong>but, this doesn't use the allocator to do the copy construction</strong>...</p>\n<p>I could manually write a loop which does something like this:</p>\n<pre><code>while(first != last) {\n    alloc_.construct(&amp;*dest++, *first++);\n}\n</code></pre>\n<p>but that's a waste, it's nearly identical to <code>std::uninitialized_copy</code>, the only difference is that is uses the allocator instead of placement new.</p>\n<p><strong>So, would you consider it an oversight that the standard doesn't have the (seemingly obvious to me) set of functions like these:</strong></p>\n<pre><code>template &lt;class In, class For, class A&gt;\nFor uninitialized_copy(In first, In last, For dest, A &amp;a);\n\ntemplate &lt;class In, class Size, class For, class A&gt;\nFor uninitialized_copy_n(In first, Size count, For dest, A &amp;a);\n\ntemplate &lt;class For, class T, class A&gt;\nvoid uninitialized_fill(For first, For last, const T&amp; x, A &amp;a);\n\ntemplate &lt;class For, class Size, class T, class A&gt;\nvoid uninitialized_fill_n(For first, Size count, const T&amp; x, A &amp;a);\n</code></pre>\n<p>I would imagine that these types of functions (even though they are trivial to implement manually... until you try to make them exception safe) would prove fairly useful if people want to implement there own containers and such and make efficient use of copy construction while using allocators.</p>\n<p>Thoughts?</p>\n", "Tags": "<c++><standards><allocator>", "OwnerUserId": "13430", "AnswerCount": "2"}});