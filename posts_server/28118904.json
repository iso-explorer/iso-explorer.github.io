post_cb({"bq_ids": {"n4140": {"so_28118904_28118904_1": {"length": 24, "quality": 0.96, "section_id": 4377}, "so_28118904_28119009_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 4435}}, "n3337": {"so_28118904_28118904_1": {"length": 24, "quality": 0.96, "section_id": 4214}, "so_28118904_28119009_1": {"length": 16, "quality": 0.6153846153846154, "section_id": 4272}}, "n4659": {"so_28118904_28118904_1": {"length": 24, "quality": 0.96, "section_id": 5640}}}, "28119009": {"Id": "28119009", "PostTypeId": "2", "Body": "<p>Absolutely. Even if it were specified that <code>use_count()</code> and <code>unique()</code> were both atomic, and it doesn't:</p>\n<blockquote>\n<p id=\"so_28118904_28119009_0\"><code>long use_count() const noexcept;</code><br>\n<em>Returns:</em> the number of <code>shared_ptr</code> objects, <code>*this</code> included, that share ownership with <code>*this</code>, or 0\n  when <code>*this</code> is empty.<br>\n<em>[ Note:</em> <code>use_count()</code> is not necessarily efficient.<em>\u2014end note ]</em> </br></br></p>\n<p id=\"so_28118904_28119009_1\"><code>bool unique() const noexcept;</code><br>\n<em>Returns:</em> <code>use_count() == 1</code>.<br>\n<em>[ Note:</em> <code>unique()</code> may be faster than <code>use_count()</code>. If you are using <code>unique()</code> to implement copy on\n  write, do not rely on a specific value when <code>get() == nullptr</code>. <em>\u2014end note ]</em></br></br></p>\n</blockquote>\n<p>There's nothing to stop something like this happening:</p>\n<pre><code>std::shared_ptr&lt;Foo&gt; sp;\n\n// thread 1                      // thread 2    \nbool uniq = sp.unique();    /**/\n                            /**/   std::shared_ptr&lt;Foo&gt; cpy = sp;\nif (uniq) {                 /**/\n   /* mine?? */             /**/   cpy-&gt;foo();\n   /* nope :-( */           /**/\n}                           /**/\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-01-23T21:34:13.983", "Score": "0", "CreationDate": "2015-01-23T21:28:57.367", "ParentId": "28118904", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-01-23T21:34:13.983"}, "28118904": {"ViewCount": "70", "Body": "<p>I have often had the desire to check to see if a <code>shared_ptr</code> was the only owner of a shared object.  It would be convenient for handing off behaviors before destroying the last shared_ptr, instead of having to do if after the destruction (my particular use case was dealing with preservation of weak pointers by rescuing them with another <code>shared_ptr</code> before destruction.  After destruction has started, it's too late to rescue them).</p>\n<blockquote>\n<p id=\"so_28118904_28118904_0\">C++11[draft] 20.7.2.1.4:</p>\n<p id=\"so_28118904_28118904_1\">For purposes of determining the presence of a data race, member\n  functions shall access and modify only the shared_ptr and weak_ptr\n  objects themselves and not objects they refer to. Changes in\n  use_count() do not reflect modifications that can introduce data\n  races.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/28113769/what-is-the-meaning-of-this-piece-of-standardese-about-shared-ptrs-use-count\">This question</a> clarified a concern I had had about <code>p.use_count() == 1</code> causing a data race.  However, I am still not convinced it is safe to use in the way I want to use it.</p>\n<p>In a single-threaded world, if <code>use_count()</code> returns 1, then you know you're the last owner of that object.  In a multithreading world where you've avoided data races, it seems reasonable that <code>use_count()</code> of 1 is sufficient to ensure you are the sole owner, but I'm having a frustrating time trying to get that from the spec-eese.  I can't tell if there's some loophole that would permit a use_count of 1 even though another shared_ptr exists on another thread.  On the other hand, it seems frustrating that the definition of <code>use_count</code> might turn to goo just beacuse I handed a shared_ptr to another thread.</p>\n<p>Can I ever get into a situation where <code>use_count()</code> is 1, but I am not the only owner, by the rules of the spec?  I recognize that, thanks to races, a <code>use_count</code> of 2 does not explicitly mean I am sharing (the other thread might release my object after my call to <code>use_count</code> on this thread), but I'm interested in the other direction, once I have seen <code>use_count</code> of 1.</p>\n<p>As a second related question: do the same rules apply for <code>unique</code>, which seems to be custom tailored to my desired implementation, but does not have any extra statements made regarding thread safety?</p>\n<hr>\n<p><strong>Edit:</strong> In response to answers I've gotten, the situation I am interested in has the <code>shared_ptr</code> we are calling <code>unique_count</code> on is only accessible by a single thread, so I do not have to worry about any other thread successfully copying it... they have to find their own <code>shared_ptr</code> to copy!</p>\n</hr>", "Title": "Checking for sole ownership of shared_ptr", "CreationDate": "2015-01-23T21:18:45.723", "LastActivityDate": "2015-01-24T01:19:31.310", "CommentCount": "1", "LastEditDate": "2017-05-23T11:50:58.750", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "28118904", "Score": "1", "OwnerUserId": "2728148", "Tags": "<c++11><thread-safety><smart-pointers><race-condition>", "AnswerCount": "2"}, "28119025": {"Id": "28119025", "PostTypeId": "2", "Body": "<p>If there is a possibility that a <code>weak_ptr</code> exists that points to the same control block as your single <code>shared_ptr</code>, and if another thread might convert that <code>weak_ptr</code> to a <code>shared_ptr</code>, then your thread could observe a <code>use_count() == 1</code>, but by the time it can do anything with that information, the other thread may construct a new <code>shared_ptr</code> from the <code>weak_ptr</code>, bumping the <code>use_count</code> up to 2.</p>\n<p>Even if there are no <code>weak_ptr</code>s, if more than one thread has read access to your <code>shared_ptr</code> (e.g. say its a global), then another thread might make a copy of it after you observe <code>use_count() == 1</code>.</p>\n<p>If your <code>shared_ptr</code> is not accessible to any other thread, and there is no possibility that another thread might convert a <code>weak_ptr</code> to a <code>shared_ptr</code>, then <code>use_count() == 1</code> is safe to depend on.</p>\n", "LastActivityDate": "2015-01-23T21:29:57.600", "CommentCount": "0", "CreationDate": "2015-01-23T21:29:57.600", "ParentId": "28118904", "Score": "3", "OwnerUserId": "576911"}});