post_cb({"11543625": {"CommentCount": "5", "CreationDate": "2012-07-18T14:25:53.957", "PostTypeId": "1", "AcceptedAnswerId": "11543811", "LastEditorUserId": "759866", "LastActivityDate": "2015-03-24T11:48:29.843", "LastEditDate": "2014-02-20T15:58:51.240", "ViewCount": "16422", "FavoriteCount": "1", "Title": "passing an array as a const argument of a method in C++", "Id": "11543625", "Score": "5", "Body": "<p>I would like to be able to pass a const array argument to a method in C++.</p>\n<p>I know that when you pass an array to method it is the same than passing a pointer to the first item of the array so an easy way is to use the pointer.</p>\n<pre><code>void myMethod(int * const inTab)\n</code></pre>\n<p>But having an array is sometimes better, you can write the size of the array for instance.</p>\n", "Tags": "<c++><arrays><methods><arguments><const>", "OwnerUserId": "1393890", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_11543625_11544332_2": {"section_id": 3241, "quality": 1.0, "length": 16}, "so_11543625_11544332_1": {"section_id": 3228, "quality": 0.75, "length": 9}, "so_11543625_11544332_0": {"section_id": 7226, "quality": 0.6666666666666666, "length": 8}, "so_11543625_11544332_3": {"section_id": 3241, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_11543625_11544332_2": {"section_id": 3114, "quality": 1.0, "length": 16}, "so_11543625_11544332_1": {"section_id": 3101, "quality": 0.75, "length": 9}, "so_11543625_11544332_0": {"section_id": 6970, "quality": 0.6666666666666666, "length": 8}, "so_11543625_11544332_3": {"section_id": 3114, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_11543625_11544332_3": {"section_id": 3997, "quality": 0.9333333333333333, "length": 14}, "so_11543625_11544332_1": {"section_id": 3985, "quality": 0.75, "length": 9}, "so_11543625_11544332_2": {"section_id": 3997, "quality": 0.75, "length": 12}, "so_11543625_11544332_0": {"section_id": 8740, "quality": 0.5833333333333334, "length": 7}}}, "11543811": {"ParentId": "11543625", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You can use a template taking the array size: <a href=\"http://ideone.com/0Qhra\" rel=\"noreferrer\">http://ideone.com/0Qhra</a></p>\n<pre><code>template &lt;size_t N&gt;\nvoid myMethod ( const int (&amp; intArray) [N] )\n{\n    std::cout &lt;&lt; \"Array of \" &lt;&lt; N &lt;&lt; \" ints\\n\";\n    return;\n}\n</code></pre>\n<p>EDIT:\nA possible way to avoid code bloat would be to have a function that takes a pointer and a size that does the actual work:</p>\n<pre><code>void myMethodImpl ( const int * intArray, size_t n );\n</code></pre>\n<p>and a trivial template that calls it, that will easily be inlined.</p>\n<pre><code>template &lt;size_t N&gt;\nvoid myMethod ( const int (&amp; intArray) [N] )\n    { myMethodImpl ( intArray, N ); }\n</code></pre>\n<p>Of course, you'ld have to find a way to test that this is always inlined away, but you do get the safety and ease of use. Even in the cases it is not, you get the benefits for relatively small cost.</p>\n", "OwnerUserId": "1171191", "LastEditorUserId": "1171191", "LastEditDate": "2012-07-24T11:25:59.783", "Id": "11543811", "Score": "14", "CreationDate": "2012-07-18T14:32:55.137", "LastActivityDate": "2012-07-24T11:25:59.783"}, "11543922": {"ParentId": "11543625", "CommentCount": "1", "Body": "<p>Not sure if it's what you asked about, but maybe it's what you were looking for</p>\n<pre><code>void func (const int array[10])\n{\n    //array[0] = 12345; // this wouldn't compile, so 'const' works\n}\n\nint main ()\n{\n    int array[10];\n    func(array);\n}\n</code></pre>\n", "OwnerUserId": "944687", "PostTypeId": "2", "Id": "11543922", "Score": "3", "CreationDate": "2012-07-18T14:38:04.107", "LastActivityDate": "2012-07-18T14:38:04.107"}, "11543726": {"ParentId": "11543625", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If you need the size of the array:</p>\n<pre><code>template &lt; std::size_t Size &gt;\nvoid myMethod( const int ( &amp;inTab )[ Size ] );\n</code></pre>\n", "OwnerUserId": "1346512", "LastEditorUserId": "142162", "LastEditDate": "2015-03-24T11:48:29.843", "Id": "11543726", "Score": "3", "CreationDate": "2012-07-18T14:29:38.667", "LastActivityDate": "2015-03-24T11:48:29.843"}, "11544332": {"ParentId": "11543625", "CommentCount": "0", "Body": "<p>Per 3.9.3:2</p>\n<blockquote>\n<p id=\"so_11543625_11544332_0\">Any cv-quali\ufb01ers applied to an array type a\ufb00ect the array element type, not the array type (8.3.4).</p>\n</blockquote>\n<p>and 8.3.4:1</p>\n<blockquote>\n<p id=\"so_11543625_11544332_1\">Any\n  type of the form \u201ccv-quali\ufb01er-seq array of N T\u201d is adjusted to \u201carray of N cv-quali\ufb01er-seq T\u201d, and similarly for\n  \u201carray of unknown bound of T\u201d.</p>\n</blockquote>\n<p>Also, per 8.3.5:5</p>\n<blockquote>\n<p id=\"so_11543625_11544332_2\">After\n  determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is\n  adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively.</p>\n</blockquote>\n<p>That means that within a function taking an array parameter, the parameter type is actually a pointer, and because of 3.9.3:2 the pointer is non-cv-qualified:</p>\n<pre><code>void foo(const int parameter[10]) {\n    parameter = nullptr;   // this compiles!\n}\n</code></pre>\n<p>This does not affect the type of the function itself, because of another clause in 8.3.5:5</p>\n<blockquote>\n<p id=\"so_11543625_11544332_3\">After producing the list\n  of parameter types, any top-level cv-quali\ufb01ers modifying a parameter type are deleted when forming the\n  function type.</p>\n</blockquote>\n<p>Thus if you want to be able to pass an array with cv qualifiers, it <em>must</em> be by reference:</p>\n<pre><code>void foo(const int (&amp;parameter)[10]);\n</code></pre>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "11544332", "Score": "3", "CreationDate": "2012-07-18T14:58:49.720", "LastActivityDate": "2012-07-18T14:58:49.720"}});