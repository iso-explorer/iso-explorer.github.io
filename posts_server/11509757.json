post_cb({"11530632": {"ParentId": "11509757", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-07-17T20:46:55.163", "Score": "1", "LastEditorUserId": "34509", "LastEditDate": "2012-07-17T20:53:08.497", "Id": "11530632", "OwnerUserId": "34509", "Body": "<p>Parenthesized expressions are equivalent to their unparenthesized expressions unless otherwise noted (as done in the ADL rules, for example, or by decltype for another example). It can sometimes be tricky when and when not something is equivalent in this manner (for example, the ADL rules don't explicitly mention \"unparenthesized\", but they use an explicit grammar non-terminal and examples that make it clear that parens are not taken as being equivalent). </p>\n<p>For the other questions: Yes, GCC does several optimizations on the AST directly that makes it accept various invalid programs, like the following</p>\n<pre><code>int a = 42;\nint *p = 0 * a;\n</code></pre>\n", "LastActivityDate": "2012-07-17T20:53:08.497"}, "11509757": {"CommentCount": "4", "AcceptedAnswerId": "11510186", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2012-07-16T17:50:45.143", "LastActivityDate": "2012-07-18T08:21:57.580", "LastEditDate": "2012-07-16T17:58:17.927", "ViewCount": "507", "FavoriteCount": "3", "Title": "Implicitly treating returned lvalue as rvalue", "Id": "11509757", "Score": "18", "Body": "<p>12.8 Copying and moving class objects [class.copy] \u00a731 and \u00a732 say:</p>\n<blockquote>\n<p id=\"so_11509757_11509757_0\">in a return statement in a function with a class return type, <strong>when the expression is the name</strong> of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</p>\n<p id=\"so_11509757_11509757_1\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n<p>Hence we can write:</p>\n<pre><code>unique_ptr&lt;int&gt; make_answer()\n{\n    unique_ptr&lt;int&gt; result(new int(42));\n    return result;   // lvalue is implicitly treated as rvalue\n}\n</code></pre>\n<p>However, I noticed that g++ 4.6.3 also accepts lvalues that are <strong>not names</strong>, for example:</p>\n<pre><code>    return (result);\n    return *&amp;result;\n    return true ? result : result;\n</code></pre>\n<p>By contrast, <code>return rand() ? result : result;</code> does not work. Is the compiler's optimizer interfering with the language semantics? As I interpret the standard, <code>return (result);</code> should not compile, because <code>(result)</code> is not a name, but a parenthesized expression. Am I right or wrong?</p>\n", "Tags": "<c++><c++11><return><move-semantics>", "OwnerUserId": "252000", "AnswerCount": "2"}, "11510186": {"ParentId": "11509757", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-07-16T18:20:28.340", "Score": "9", "LastEditorUserId": "1090079", "LastEditDate": "2012-07-18T08:21:57.580", "Id": "11510186", "OwnerUserId": "1090079", "Body": "<h2>Regarding <em>parenthesized expressions</em> [\u221a]</h2>\n<p>You are wrong when talking about parenthesized expressions and that it shouldn't be able to trigger a <em>move</em> when being <em>returned</em> and containing only the name of a <em>moveable</em> object.</p>\n<blockquote>\n<h3>5.1.1/1 \u00a0\u00a0\u00a0\u00a0 General \u00a0\u00a0\u00a0\u00a0 [expr.prim.general]</h3>\n<p id=\"so_11509757_11510186_0\">A parenthesized expression is a primary expression whose type and\n  value are identical to those of the enclosed expression. The\n  presence of parentheses does not affect whether the expression is an lvalue. <strong>The parenthesized expression can be used in exactly the same contexts as those where the enclosed expression can be used</strong>, and <strong>with the same meaning</strong>, except as otherwise indicated.</p>\n</blockquote>\n<hr>\n<h2>Regarding the constexpr <strong>conditional operator</strong> [\u2573]</h2>\n<p><strike><sup>The way I interpret the standard in regards to <em>constant-expressions</em> and he <em>coditional operator</em> is that the use of <code>return true ? result : result</code> is well-behaved since it is a constant expression and therefore equivalent to <em>return result;</em></sup></strike></p>\n<p>I have now gone through the standard more carefully  and nowhere does it say that a <em>constant conditional-expression</em> is the same as if only the <em>\"returned\"</em> expression would have been written.</p>\n<pre><code>true ? &lt;expr1&gt; : &lt;expr2&gt;; // this is not the same as just writing &lt;expr1&gt;;\n</code></pre>\n<hr>\n<h2>Regarding <em>return *&amp;result;</em> [\u2573]</h2>\n<p>In C99 it is explicitly stated that <code>*&amp;result</code> is the <strong>exact</strong> equivalent of having written <code>result</code> instead, this is not the case in the C++ specification.</p>\n<p>Though we can all agree on that using <code>*&amp;result</code> will indeed yield the same <em>lvalue</em> as <code>result</code>, but according to the standard <code>*&amp;result</code> (of course) isn't an expression where <em>\"the expression is the name of a non-volatile automatic object\"</em>.</p>\n<p>Sure, the <em>expression</em> contains an appropriate name, but it's not just only that.</p>\n<hr>\n<h3>To sum things up...</h3>\n<pre><code>return result; // #1, OK\n</code></pre>\n<p><sup></sup></p>\n<pre><code>return (result);                  // as described earlier, OK\nreturn true ? result : result;    // as described earlier, ill-formed\nreturn rand () ? result : result; // as described earlier, ill-formed\nreturn *&amp;result;                  // as described earlier, ill-formed\n</code></pre>\n</hr></hr></hr>", "LastActivityDate": "2012-07-18T08:21:57.580"}, "bq_ids": {"n4140": {"so_11509757_11510186_0": {"section_id": 5952, "quality": 0.9444444444444444, "length": 34}, "so_11509757_11509757_1": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}, "so_11509757_11509757_0": {"section_id": 480, "quality": 1.0, "length": 35}}, "n3337": {"so_11509757_11510186_0": {"section_id": 5722, "quality": 0.9444444444444444, "length": 34}, "so_11509757_11509757_1": {"section_id": 472, "quality": 1.0, "length": 29}, "so_11509757_11509757_0": {"section_id": 471, "quality": 1.0, "length": 35}}, "n4659": {"so_11509757_11510186_0": {"section_id": 7438, "quality": 0.6388888888888888, "length": 23}, "so_11509757_11509757_1": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_11509757_11509757_0": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}}}});