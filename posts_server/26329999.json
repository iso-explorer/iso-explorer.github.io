post_cb({"bq_ids": {"n4140": {"so_26329999_26330301_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6065}, "so_26329999_26330301_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 6066}, "so_26329999_26330301_0": {"length": 24, "quality": 0.96, "section_id": 6064}}, "n3337": {"so_26329999_26330301_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5833}, "so_26329999_26330301_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5834}, "so_26329999_26330301_0": {"length": 24, "quality": 0.96, "section_id": 5832}}, "n4659": {"so_26329999_26330301_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7561}, "so_26329999_26330301_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 7562}, "so_26329999_26330301_0": {"length": 23, "quality": 0.92, "section_id": 7560}}}, "26330301": {"Id": "26330301", "PostTypeId": "2", "Body": "<p>This is covered in \u00a7 5.3.1 [expr.unary.op]:</p>\n<blockquote>\n<p id=\"so_26329999_26330301_0\">1 The unary * operator performs <em>indirection</em>: the expression to which\n  it is applied shall be a pointer to an object type, or a pointer to a\n  function type and the result is an lvalue referring to the object or\n  function to which the expression points. If the type of the expression\n  is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_26329999_26330301_1\">2 The result of each of the following unary operators is a prvalue. </p>\n<p id=\"so_26329999_26330301_2\">3 The result of the unary &amp; operator is a pointer to its operand.</p>\n</blockquote>\n<p>Since <code>&amp;a</code> yields a <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow\"><code>prvalue</code></a>, <code>&amp;a = 5</code> is invalid, because <code>&amp;a</code> is not an lvalue. Only modifiable lvalues can appear on the left hand of the built-in assignment operator.</p>\n<p>On the other hand, <code>*(&amp;a)</code> yields an lvalue (making it assignable). </p>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-10-12T21:43:07.673", "Score": "0", "CreationDate": "2014-10-12T21:43:07.673", "ParentId": "26329999", "CommentCount": "0"}, "26329999": {"ViewCount": "149", "Body": "<p>I\u2019m studying about pointers. It\u2019s quite confusing\u2014maybe because I\u2019m new. I have a question that what <code>*(&amp;a)</code> indicates in the following short program.</p>\n<p>On line 7, I know <code>*(&amp;a)</code> means \u201cvalue at address of variable <code>a</code>,\u201d but on line 13, what does <code>*(&amp;a)=5</code> mean? When I assign <code>&amp;a=5</code>, the compiler gives an error along the lines of \u201clvalue required as left operand of assignment,\u201d but when I assign the value in <code>*(&amp;a)</code>, then it compiles with no error.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n  int *p, a = 2, b;\n\n  b = *(&amp;a);         // line 7\n  printf(\"%d\", b);\n\n  p = &amp;a;\n  printf(\"%d\", p);\n\n  *(&amp;a) = 5;         // line 13\n  printf(\"%d\", a);\n\n  return 0;\n}\n</code></pre>\n", "Title": "What does *(&a)=5 mean?", "CreationDate": "2014-10-12T21:08:55.380", "LastActivityDate": "2014-10-12T21:56:40.860", "CommentCount": "4", "LastEditDate": "2014-10-12T21:56:40.860", "PostTypeId": "1", "LastEditorUserId": "583570", "Id": "26329999", "Score": "0", "OwnerUserId": "3957069", "Tags": "<c++><c++11>", "AnswerCount": "3"}, "26330076": {"Id": "26330076", "PostTypeId": "2", "Body": "<p><code>&amp;a</code> will return a pointer to a, or the memory address where <code>a</code> is located.  The dereference operator <code>*</code> returns the value of the data pointed to by the address.  Consider the following code.</p>\n<pre><code>int foo = 3;\nint* bar = &amp;foo; /// bar points to foo.\nprintf( \"%d\\n\", *bar ); /// will print 3\nprintf( \"%d\\n\", *(&amp;foo) ); /// will also print 3\n</code></pre>\n<p>The variable <code>bar</code> points to the memory address where <code>foo</code> is located.  By using the dereference operator, you get the value stored in memory at the address contained in <code>bar</code>.  The last example combines the two, you get a pointer to <code>foo</code> and immediately dereference it, which returns the value stored in <code>foo</code></p>\n", "LastEditorUserId": "1730271", "LastActivityDate": "2014-10-12T21:49:54.210", "Score": "0", "CreationDate": "2014-10-12T21:17:52.283", "ParentId": "26329999", "CommentCount": "4", "LastEditDate": "2014-10-12T21:49:54.210", "OwnerUserId": "1730271"}, "26330079": {"Id": "26330079", "PostTypeId": "2", "Body": "<p>Given an <code>int a;</code> then <code>&amp;a</code> gives you the address of <code>a</code> which is an <code>int *</code>. Given an <code>int *p;</code> the expression <code>*p</code> gives you the <code>int</code> that <code>p</code> is pointing to. So <code>*(&amp;a)</code> is the value behind the address of <code>a</code> which is <code>a</code>. In other words <code>*(&amp;a)</code> does the same as just <code>a</code>. </p>\n<p>There are times when this is sort of useful. Given a <code>std::vector&lt;int&gt;::iterator it;</code> you can get a pointer to the <code>int</code> the iterator points to by dereferencing the iterator to get the <code>int</code> and then take the address, so you get <code>&amp;(*it)</code>.</p>\n", "LastActivityDate": "2014-10-12T21:18:23.150", "Score": "1", "CreationDate": "2014-10-12T21:18:23.150", "ParentId": "26329999", "CommentCount": "1", "OwnerUserId": "3484570"}});