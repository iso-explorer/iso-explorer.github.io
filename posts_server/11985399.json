post_cb({"11985463": {"CommentCount": "0", "Body": "<p>ptr stores the address of the starting byte of the integer object. Whether this is where the most or the least significant byte is stored depends on your platform. Some weird platforms even use mixed endianness in which case it'll be neither the MSB nor the LSB.</p>\n<p>There is no difference between C and C++ in that respect.</p>\n", "CreationDate": "2012-08-16T10:42:19.387", "ParentId": "11985399", "Id": "11985463", "LastActivityDate": "2012-08-16T10:42:19.387", "PostTypeId": "2", "Score": "5", "OwnerUserId": "172531"}, "11985451": {"LastActivityDate": "2012-08-16T12:17:06.980", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_11985399_11985451_0\">Will I get the LSB address of i, or the MSB? </p>\n</blockquote>\n<p>This is platform dependent: it will be <em>the lowest addressed byte</em>, which may be MSB or LSB depending on your platform's <em>endianness</em>.</p>\n<p>Although this is not written in the standard directly, this is what's implied by section 6.3.2.3.7:</p>\n<blockquote>\n<p id=\"so_11985399_11985451_1\">When a pointer to an object is converted to a pointer to a character type, the result points to the lowest addressed byte of the object.</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p id=\"so_11985399_11985451_2\">Will it act differently between platforms? </p>\n</blockquote>\n<p>Yes</p>\n<hr/>\n<blockquote>\n<p id=\"so_11985399_11985451_3\">Is there a difference here between c and c++?</p>\n</blockquote>\n<p>No: it is platform-dependent in both C and C++</p>\n", "CreationDate": "2012-08-16T10:41:48.627", "LastEditDate": "2012-08-16T12:17:06.980", "ParentId": "11985399", "Id": "11985451", "LastEditorUserId": "335858", "PostTypeId": "2", "Score": "8", "OwnerUserId": "335858"}, "11985471": {"LastActivityDate": "2012-08-16T10:42:37.750", "CommentCount": "0", "Body": "<p>What it points is MSB for my VC++ 2010 and Digital Mars. But it is related to endianness.</p>\n<p>This question's answers give some infor for you:\n<a href=\"https://stackoverflow.com/questions/1001307/detecting-endianness-programmatically-in-a-c-program\">Detecting endianness programmatically in a C++ program</a>.</p>\n<p>Here, user \"none\" says:</p>\n<pre><code>#define BIG_ENDIAN      0\n#define LITTLE_ENDIAN   1\n int TestByteOrder()\n{\n   short int word = 0x0001;\n   char *byte = (char *) &amp;word;\n   return(byte[0] ? LITTLE_ENDIAN : BIG_ENDIAN);\n}\n</code></pre>\n<p>This gives some endianness info</p>\n", "CreationDate": "2012-08-16T10:42:37.750", "LastEditDate": "2017-05-23T12:34:07.263", "ParentId": "11985399", "Id": "11985471", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "3", "OwnerUserId": "1470092"}, "11985699": {"CommentCount": "0", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_11985399_11985699_1\">well I get the LSB address of i, or the MSB? </p>\n</blockquote>\n</blockquote>\n<p>It depends on the machine and the OS.  On big endian machines and OS's you will get the MSB and on little endian machines and OS's you will get the LSB.</p>\n<p>Windows is always little endian.  All (most ?) flavors of Linux/Unix on x86 is little endian.  Linux/Unix on Motorola machines is big endian. Mac OS on x86 machines is little endian.  On PowerPC machines it's big endian.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_11985399_11985699_4\">well it act differently between platforms? \n    Yes it will.</p>\n<p id=\"so_11985399_11985699_5\">is there a difference here between c and c++?\n    Probably not.</p>\n</blockquote>\n</blockquote>\n", "CreationDate": "2012-08-16T10:58:43.647", "ParentId": "11985399", "Id": "11985699", "LastActivityDate": "2012-08-16T10:58:43.647", "PostTypeId": "2", "Score": "1", "OwnerUserId": "575170"}, "bq_ids": {"n4140": {"so_11985399_11985451_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 6143}}, "n3337": {"so_11985399_11985451_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 5907}}}, "11985399": {"FavoriteCount": "4", "ViewCount": "4634", "Id": "11985399", "AcceptedAnswerId": "12004532", "Score": "11", "Title": "Does a pointer point to the LSB or MSB?", "LastEditorUserId": "1561062", "CommentCount": "2", "Body": "<p>if I have the following code:</p>\n<pre><code>int i = 5;\nvoid * ptr = &amp;i;\nprintf(\"%p\", ptr);\n</code></pre>\n<p>Will I get the LSB address of i, or the MSB? <br/>\nWill it act differently between platforms? <br/>\nIs there a difference here between C and C++?</p>\n", "Tags": "<c++><c><pointers><void-pointers>", "CreationDate": "2012-08-16T10:38:07.093", "LastEditDate": "2012-08-16T10:55:14.150", "LastActivityDate": "2017-10-30T13:06:37.153", "PostTypeId": "1", "AnswerCount": "6", "OwnerUserId": "1561062"}, "12004532": {"LastActivityDate": "2017-10-30T13:06:37.153", "CommentCount": "0", "Body": "<p>Consider the size of <code>int</code> is 4 bytes. Always <code>&amp;i</code> will gives you the first address of those 4 bytes.</p>\n<p>If the architecture is little endian, then the lower address will have the LSB like below.</p>\n<pre>\n        +------+------+------+------+\nAddress | 1000 | 1001 | 1002 | 1003 |\n        +------+------+------+------+\nValue   |   5  |    0 |    0 |    0 |\n        +------+------+------+------+\n</pre>\n<p>If the architecture is big endian, then the lower address will have the MSB like below.</p>\n<pre>\n        +------+------+------+------+\nAddress | 1000 | 1001 | 1002 | 1003 |\n        +------+------+------+------+\nValue   |   0  |    0 |    0 |    5 |\n        +------+------+------+------+\n</pre>\n<p>So <code>&amp;i</code> will give LSB address of <code>i</code> if little endian or it will give MSB address of <code>i</code> if big endian</p>\n<p>In mixed endian mode also, either little or big endian will be chosen for each task dynamically. </p>\n<p>Below logic will tells you the endianess </p>\n<pre><code>int i = 5; \nvoid * ptr = &amp;i; \nchar * ch = (char *) ptr;\n\nprintf(\"%p\", ptr); \nif (5 == (*ch))\n    printf(\"\\nlittle endian\\n\");\nelse\n    printf(\"\\nbig endian\\n\");\n</code></pre>\n<p>This behaviour will be same for both <code>c</code> and <code>c++</code></p>\n", "CreationDate": "2012-08-17T11:01:28.970", "LastEditDate": "2017-10-30T13:06:37.153", "ParentId": "11985399", "Id": "12004532", "LastEditorUserId": "596370", "PostTypeId": "2", "Score": "15", "OwnerUserId": "596370"}, "11985466": {"LastActivityDate": "2012-08-16T10:52:04.733", "CommentCount": "2", "Body": "<p>It depends on the endianness of the platform; if it's a little-endian platform, you'll get a pointer to the LSB, if it's a big-endian platform it will point the MSB. There are even some mixed-endian plaforms, in that case <s>may God have mercy of your soul</s> check the specific documentation of your compiler/CPU.</p>\n<p>Still, you can perform a quick check at runtime:</p>\n<pre><code>uint32_t i=0x01020304;\nchar le[4]={4, 3, 2, 1};\nchar be[4]={1, 2, 3, 4};\nif(memcmp(&amp;i, le, 4)==0)\n    puts(\"Little endian\");\nelse if(memcmp(&amp;i, be, 4)==0)\n    puts(\"Big endian\");\nelse\n    puts(\"Mixed endian\");\n</code></pre>\n<p>By the way, to print pointers you must use the <code>%p</code> placeholder, not <code>%d</code>.</p>\n", "CreationDate": "2012-08-16T10:42:25.550", "LastEditDate": "2012-08-16T10:52:04.733", "ParentId": "11985399", "Id": "11985466", "LastEditorUserId": "214671", "PostTypeId": "2", "Score": "8", "OwnerUserId": "214671"}});