post_cb({"47824973": {"ViewCount": "110", "Body": "<p><strong>Edit</strong> This question has been heavily modified</p>\n<p>I am trying to export a template specialization from a dll that is defined in a cpp file (purely for the purpose of exporting the template).</p>\n<p>The first attempt (\"First Attempt\") at this based on using dllimport/export in the header turned out to work both in compilation and at runtime however it produced a C4661 warning (no suitable definition provided for explicit template instantiation request). This is what I first asked the question on. However @AnT answer showed my mistake and I attempted to correct this with the \"Second Attempt\" this however also results in a warning as well.</p>\n<p><strong>First Attempt</strong></p>\n<p>foo.h</p>\n<pre><code>#ifndef _foo_h_ //header guard\n#define _foo_h_\n\n#ifdef EXAMPLE_FOO_EXPORTS\n#define EXAMPLE_FOO_EXPORT __declspec(dllexport)\n#define EXAMPLE_FOO_EXTERN\n#else\n#define EXAMPLE_FOO_EXPORT __declspec(dllimport)\n#define EXAMPLE_FOO_EXTERN extern\n#endif\n\ntemplate&lt;typename _Type&gt;\nclass foo\n{\npublic:\n    _Type value();\n};\n\nEXAMPLE_FOO_EXTERN template class EXAMPLE_FOO_EXPORT foo&lt;int&gt;;\n\n#endif//_foo_h_\n</code></pre>\n<p>foo.cpp</p>\n<pre><code>#include \"foo.h\"\n\ntemplate&lt;typename _Type&gt; \n_Type foo&lt;_Type&gt;::value()\n{\n    return (_Type)1;\n}\n</code></pre>\n<p>I have a piece of test code in the dll to output a value.</p>\n<p>test.cpp</p>\n<pre><code>#include \"foo.h\"\n\nint readValue()\n{\n    foo&lt;int&gt; test;\n\n    return test.value();\n}\n</code></pre>\n<p><strong>Second Attempt</strong></p>\n<p>Going off of @AnT's note of the standard, instantiating in the cpp works but I am left with another issue (granted this is all VC-fu). Changing the code to below to make sure instantiation is done in the cpp (per standard and to get dll export working), I get a warning C4251: 'bar::value': class 'foo' needs to have dll-interface to be used by clients of struct 'bar'.</p>\n<p>foo.h</p>\n<pre><code>#ifndef _foo_h_ //header guard\n#define _foo_h_\n\n#ifdef EXAMPLE_FOO_EXPORTS\n#define EXAMPLE_FOO_EXPORT __declspec(dllexport)\n#define EXAMPLE_FOO_EXTERN\n#else\n#define EXAMPLE_FOO_EXPORT __declspec(dllimport)\n#define EXAMPLE_FOO_EXTERN extern\n#endif\n\ntemplate&lt;typename _Type&gt;\nclass foo\n{\npublic:\n    _Type value();\n};\n\ntypedef foo&lt;int&gt; fooInt;\n\n#ifndef EXAMPLE_FOO_EXPORTS\nextern template class __declspec(dllimport) foo&lt;int&gt;;\n#endif\n\nstruct EXAMPLE_FOO_EXPORT bar\n{\n    fooInt value;\n};\n#endif//_foo_h_\n</code></pre>\n<p>foo.cpp</p>\n<pre><code>#include \"foo.h\"\n\ntemplate&lt;typename _Type&gt; \n_Type foo&lt;_Type&gt;::value()\n{\n    return (_Type)1;\n}\n\n#ifdef EXAMPLE_FOO_EXPORTS\ntemplate class __declspec(dllexport) foo&lt;int&gt;;\n#endif\n</code></pre>\n<p>I believe the bar struct is instantiating the foo template before it is instantiated in the cpp with the __declspec(dllexport). Besides the fact that \"this is crazy, this is all wrong and why are you doing this\", is there a way around this or is this just a peculiarity of windows dll import/export and it is what it is?</p>\n", "Title": "(Edit) How to dll export a template specialization in Windows, with the source declared in a cpp file", "CreationDate": "2017-12-15T02:28:38.933", "LastActivityDate": "2017-12-15T23:22:23.643", "CommentCount": "5", "LastEditDate": "2017-12-15T23:22:23.643", "PostTypeId": "1", "LastEditorUserId": "1302439", "Id": "47824973", "Score": "-1", "OwnerUserId": "1302439", "Tags": "<c++><visual-c++><dll>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47824973_47825063_0": {"length": 22, "quality": 0.88, "section_id": 258}}, "n3337": {"so_47824973_47825063_0": {"length": 22, "quality": 0.88, "section_id": 249}}, "n4659": {"so_47824973_47825063_0": {"length": 22, "quality": 0.88, "section_id": 265}}}, "47825063": {"Id": "47825063", "PostTypeId": "2", "Body": "<p>The language specification says</p>\n<blockquote>\n<p id=\"so_47824973_47825063_0\"><strong>14.7.2 Explicit instantiation</strong><br>\n<strong>9</strong> An explicit instantiation definition that names a class template specialization explicitly instantiates the class template specialization and is an explicit instantiation definition of only those members that have been defined at the point of instantiation.</br></p>\n</blockquote>\n<p>In your case your explicit instantiation definition does <em>not</em> provide an explicit instantiation definition for <code>foo&lt;int&gt;::value()</code>, since at the point of explicit instantiation that member is not defined yet.</p>\n<p>The purpose of C4661 is to inform you about that issue. It is quite possible that a special treatment is applied by MSVC to <code>dllexport</code>-ed entities, which is what ultimately makes your code to link properly. But from the language point of view the issue is there.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2017-12-15T22:48:26.480", "Score": "1", "CreationDate": "2017-12-15T02:42:13.627", "ParentId": "47824973", "CommentCount": "1", "OwnerUserId": "187690", "LastEditDate": "2017-12-15T22:48:26.480"}});