post_cb({"24033088": {"ParentId": "24032322", "CommentCount": "0", "Body": "<blockquote>\n<pre><code>strcmp (buf1, reinterpret_cast&lt;char const *&gt; (buf2));\n</code></pre>\n<p id=\"so_24032322_24033088_0\">This looks fine,</p>\n</blockquote>\n<p>It is. <code>strcmp</code> takes <code>const char *</code> parameters, but internally converts them to <code>const unsigned char *</code> (if required), so that even if <code>char</code> is signed and two distinct bytes can compare equal when viewing them as <code>char</code>, they will still compare different when viewing them with <code>strcmp</code>.</p>\n<p>C99:</p>\n<blockquote>\n<p id=\"so_24032322_24033088_1\"><strong>7.21 String handling <code>&lt;string.h&gt;</code></strong></p>\n<p id=\"so_24032322_24033088_2\"><strong>7.21.1 String function conventions</strong></p>\n<p id=\"so_24032322_24033088_3\">3 For all functions in this subclause, each character shall be interpreted as if it had the type <code>unsigned char</code> (and therefore every possible object representation is valid and has a different value).</p>\n</blockquote>\n<p>That said,</p>\n<blockquote>\n<p id=\"so_24032322_24033088_4\">but does the Standard guarantee that the <em>(1)</em> will always yield <em>true</em>?</p>\n<pre><code>char unsigned * p1 = ...;\nchar          * p2 = reinterpret_cast&lt;char *&gt; (p1);\n\n*p1 == *p2; // (1)\n</code></pre>\n</blockquote>\n<p>What you wrote is not guaranteed.</p>\n<p>Take a common implementation, with signed <code>char</code>, 8-bit bytes using two's complement representation. If <code>*p1</code> is <code>UCHAR_MAX</code>, then <code>*p2 == -1</code>, and <code>*p1 == *p2</code> will be false because the promotion to <code>int</code> gives them different values.</p>\n<p>If you meant either <code>(char) *p1 == *p2</code>, or <code>*p1 == (unsigned char) *p2</code>, then those are still not guaranteed, so you do need to make sure that if you copy from an array of <code>char</code> to an array of <code>unsigned char</code>, you don't include such a conversion.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "24033088", "Score": "14", "CreationDate": "2014-06-04T08:59:12.687", "LastActivityDate": "2014-06-04T08:59:12.687"}, "24032323": {"ParentId": "24032322", "PostTypeId": "2", "CommentCount": "11", "Body": "<h3>THIS MIGHT SURPRISE YOU,</h3>\n<p>but there's no such guarantee in the <em>C++11</em> Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">N3337</a>), nor in the upcoming <em>C++14</em> (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\">N3797</a>).</p>\n<pre><code>char unsigned * p1 = ...;\nchar          * p2 = reinterpret_cast&lt;char *&gt; (p1);\n\n*p1 == *p2; // (1), not guaranteed to be true\n</code></pre>\n<p><sup><strong>Note</strong>: it is implementation specific whether <code>char</code> is <em>signed</em> or <em>unsigned</em>; <code>[basic.fundamental]p1</code>. </sup></p>\n<p><br/></p>\n<hr>\n<h3>DETAILS</h3>\n<p>The Standard guarantees that every character type shall;</p>\n<ul>\n<li>have the same <em>alignment requirement</em>;</li>\n<li>occupy the same amount of storage, and;</li>\n<li>that all bits of the storage occupied by a character type shall participate in the <em>value representation</em>, and;</li>\n<li>that the <em>value representation</em> is the same.</li>\n</ul>\n<p>Sharing the same amount of storage, <em>alignment requirement</em>, and the guarantee about bit participation, means that casting a lvalue referring to one type (<em>unsigned char</em>), to another (<em>char</em>), is safe.. as far as the actual cast is concerned.</p>\n<blockquote>\n<p id=\"so_24032322_24032323_0\"><code>3.9.1p1</code> <strong>Fundamental types</strong> <code>[basic.fundamental]</code></p>\n<blockquote>\n<p id=\"so_24032322_24032323_4\">It is implementation-defined whether a <code>char</code> can hold negative values. Characters can be explicitly declared <code>signed</code> or <code>unsigned</code>.</p>\n<p id=\"so_24032322_24032323_5\">A <code>char,</code> a <code>signed char,</code> and an <code>unsigned char</code> occupy the same amount of storage and have the same alignment requirements (3.11); that is, they have the same object representation. For character types, all bits of the object representation participate in the value representation.</p>\n<p id=\"so_24032322_24032323_6\">For unsigned character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types.</p>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_24032322_24032323_7\"><code>3.9p4</code> <strong>Types</strong> <code>[basic.types]</code></p>\n<blockquote>\n<p id=\"so_24032322_24032323_9\">The <em>object representation</em> of an object of type <code>T</code> is the sequence of <em>N</em> <code>unsigned char</code> objects taken up by the object of type <code>T,</code> where <code>N</code> equals <code>sizeof(T)</code>. The <em>value representation</em> of an object is the set of bits that hold the value of type <code>T</code>.</p>\n</blockquote>\n</blockquote>\n<p><br/></p>\n<hr>\n<h3>SO, WHAT ARE THE PROBLEM(s)?</h3>\n<p>If we assign the maximum value of an <em>unsigned char</em> (<a href=\"http://en.cppreference.com/w/c/types/limits\"><em>UCHAR_MAX</em></a>) to <code>*p1</code> and <code>*p2</code> is <em>signed</em>, <code>*p2</code> won't be able to represent this value. We will overflow <code>*p2</code> and it will, most likely, end up having the value of <code>-1</code>.</p>\n<p><sup> <strong>Note</strong>: <em>signed integer overflow</em> is actually <em>undefined behavior</em>. </sup></p>\n<hr>\n<pre><code>*p1 = UCHAR_MAX;\n\n*p1 == *p2; // (1)\n</code></pre>\n<hr>\n<p>Both sides of <code>operator==</code> must have the same type before we can compare them, and currently one side is <code>unsigned char</code> and the other <code>char</code>.</p>\n<p>The compiler will therefor resort to <em>integral promotion</em> to find a type that can represent all combined possible values of the two types; and in this case the resulting type will be <code>int</code>.</p>\n<p>After the integral promotion the statement is semantically equivalent to <code>int (UCHAR_MAX) == int(-1)</code>, which of course is false.</p>\n</hr></hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-04T16:12:51.597", "Id": "24032323", "Score": "17", "CreationDate": "2014-06-04T08:17:34.983", "LastActivityDate": "2014-06-04T16:12:51.597"}, "24032322": {"CommentCount": "5", "AcceptedAnswerId": "24032323", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-04T08:17:34.983", "LastActivityDate": "2014-06-04T16:12:51.597", "LastEditDate": "2017-05-23T11:46:37.420", "ViewCount": "4254", "FavoriteCount": "5", "Title": "Is it safe to cast an unsigned char* to char*, and treat the dereferenced pointer as if it really points to a char?", "Id": "24032322", "Score": "18", "Body": "<p>Following the question titled <a href=\"https://stackoverflow.com/q/24030116/1090079\"><strong>Warning generated due wrong strcmp parameter handling</strong></a>, there seems to be some questions regarding what the Standard actually guarantees regarding value representation of character types.</p>\n<hr>\n<h3>THE QUESTION</h3>\n<p>This looks fine, but does the Standard guarantee that the <em>(1)</em> will always yield <em>true</em>?</p>\n<pre><code>char unsigned * p1 = ...;\nchar          * p2 = reinterpret_cast&lt;char *&gt; (p1);\n\n*p1 == *p2; // (1)\n</code></pre>\n</hr>", "Tags": "<c++><c++11><language-lawyer><c++14>", "OwnerUserId": "1090079", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24032322_24032323_2": {"section_id": 7210, "quality": 0.9310344827586207, "length": 27}, "so_24032322_24032323_4": {"section_id": 7210, "quality": 0.9230769230769231, "length": 12}, "so_24032322_24032323_8": {"section_id": 7202, "quality": 0.8333333333333334, "length": 20}, "so_24032322_24032323_3": {"section_id": 7210, "quality": 0.8823529411764706, "length": 15}, "so_24032322_24032323_9": {"section_id": 7202, "quality": 0.8333333333333334, "length": 20}, "so_24032322_24032323_1": {"section_id": 7210, "quality": 0.9230769230769231, "length": 12}, "so_24032322_24032323_6": {"section_id": 7210, "quality": 0.8823529411764706, "length": 15}, "so_24032322_24032323_5": {"section_id": 7210, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_24032322_24032323_2": {"section_id": 6954, "quality": 0.9310344827586207, "length": 27}, "so_24032322_24032323_4": {"section_id": 6954, "quality": 0.9230769230769231, "length": 12}, "so_24032322_24032323_8": {"section_id": 6946, "quality": 0.8333333333333334, "length": 20}, "so_24032322_24032323_3": {"section_id": 6954, "quality": 0.8823529411764706, "length": 15}, "so_24032322_24032323_9": {"section_id": 6946, "quality": 0.8333333333333334, "length": 20}, "so_24032322_24032323_1": {"section_id": 6954, "quality": 0.9230769230769231, "length": 12}, "so_24032322_24032323_6": {"section_id": 6954, "quality": 0.8823529411764706, "length": 15}, "so_24032322_24032323_5": {"section_id": 6954, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_24032322_24032323_2": {"section_id": 8719, "quality": 0.9310344827586207, "length": 27}, "so_24032322_24032323_4": {"section_id": 8719, "quality": 0.9230769230769231, "length": 12}, "so_24032322_24032323_8": {"section_id": 8711, "quality": 0.8333333333333334, "length": 20}, "so_24032322_24032323_3": {"section_id": 8719, "quality": 0.7058823529411765, "length": 12}, "so_24032322_24032323_5": {"section_id": 8719, "quality": 0.9310344827586207, "length": 27}, "so_24032322_24032323_1": {"section_id": 8719, "quality": 0.9230769230769231, "length": 12}, "so_24032322_24032323_6": {"section_id": 8719, "quality": 0.7058823529411765, "length": 12}, "so_24032322_24032323_9": {"section_id": 8711, "quality": 0.8333333333333334, "length": 20}}}});