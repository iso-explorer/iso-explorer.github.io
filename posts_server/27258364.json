post_cb({"27258752": {"ParentId": "27258364", "CommentCount": "6", "CreationDate": "2014-12-02T20:54:04.740", "OwnerUserId": "2036161", "PostTypeId": "2", "Id": "27258752", "Score": "0", "Body": "<p>Since A already is a smart pointer to a class that wraps dynamically allocated memory, it's guaranteed that the memory will not be deallocated until all references are released. Thus you can use a simple array or vector and copy the smart pointers around, no need to dynamically allocate the array.</p>\n<p>For example:</p>\n<pre><code>typedef sdt::vector&lt;A&lt;SomeType&gt; &gt; AVector;\n\nAVector copy(AVector in)\n{\n   AVector copyArray = in;\n   return copyArray;\n}\n</code></pre>\n", "LastActivityDate": "2014-12-02T20:54:04.740"}, "27329244": {"ParentId": "27258364", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-12-06T07:05:03.940", "Score": "3", "LastEditorUserId": "2228299", "LastEditDate": "2014-12-06T20:11:52.623", "Id": "27329244", "OwnerUserId": "2228299", "Body": "<blockquote>\n<p id=\"so_27258364_27329244_0\">How do I create a dynamically allocated array of T, initialized with std::uninitialized_copy, so that it can be deleted with 'delete []' (i.e. treated as if it was allocated with a simple 'new T[N]')?</p>\n</blockquote>\n<p>So, given the relatively simple requirement that the memory be able to be deleted with <code>delete[]</code>, lets see what options we have.</p>\n<p><em>Note: All quotes from the standard are from the C++14 draft N3797 and I'm not the best at standard-interpreting so take this with a grain of salt.</em></p>\n<h2>Mixing <code>malloc()/free()</code> and <code>new[]/delete[]</code></h2>\n<p>Undefined, since new doesn't necessarily call malloc, see <strong>\u00a718.6.1/4</strong> (default behavior of <code>operator new</code>):</p>\n<blockquote>\n<p id=\"so_27258364_27329244_1\">Default behavior:</p>\n<ul>\n<li>Executes a loop: Within the loop, the function first attempts to allocate the requested storage. Whether the attempt involves a call to the Standard C library function malloc is unspecified.</li>\n</ul>\n</blockquote>\n<h2>Avoiding default-initialization</h2>\n<p>So, seeing that we're required to use <code>new[]</code> if we want to use <code>delete[]</code>,\nlooking at the standard for information about initialization in a <em>new-expression</em> <strong>\u00a75.3.4/17</strong>:</p>\n<blockquote>\n<p id=\"so_27258364_27329244_2\">A new-expression that creates an object of type T initializes that object as follows:</p>\n<ul>\n<li>If the new-initializer is omitted, the object is default-initialized (8.5); if no initialization is performed, the object has indeterminate value.</li>\n<li>Otherwise, the new-initializer is interpreted according to the initialization rules of 8.5 for direct-initialization.</li>\n</ul>\n</blockquote>\n<p>and going to <strong>\u00a78.5/7</strong>:</p>\n<blockquote>\n<p id=\"so_27258364_27329244_3\">To default-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9), the default constructor (12.1) for T is called (and the initialization is ill-formed if T has no default constructor or overload resolution (13.3) results in an ambiguity or in a function that is deleted or inaccessible from the context of the initialization);</li>\n<li>if T is an array type, each element is default-initialized;</li>\n</ul>\n</blockquote>\n<p>we see that if we omit a <em>new-initializer</em> in our <code>new[]</code>, all the elements of the array will be default initialized via their default constructors.</p>\n<p>So, what if we include a <em>new-initializer</em>, do we have any options? Going back to its definition in <strong>\u00a75.3.2/1</strong>:</p>\n<blockquote>\n<p id=\"so_27258364_27329244_4\">new-initializer:</p>\n<ul>\n<li>(expression-list opt)</li>\n<li>braced-init-list</li>\n</ul>\n</blockquote>\n<p>The only possibility we are left with is a <em>braced-init-list</em> (<em>expression-list</em> is for non-array <em>new-expressions</em>). I managed to get it working for objects with compile time size, but obviously that's not terribly helpful. For reference (portions of code adapted from <a href=\"http://en.cppreference.com/w/cpp/utility/integer_sequence\" rel=\"nofollow\">here</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct A\n{\n    int id;\n    A(int i) : id(i) {\n        std::cout &lt;&lt; \"c[\" &lt;&lt; id &lt;&lt; \"]\\t\";}\n    A() : A(0) {}\n\n    ~A() {std::cout &lt;&lt; \"d[\" &lt;&lt; id &lt;&lt; \"]\\t\";}\n};\n\ntemplate&lt;class T, std::size_t ...I&gt;\nT* template_copy_impl(T* a, std::index_sequence&lt;I...&gt;) {\n    return new T[sizeof...(I)]{std::move(a[I])...};\n}\n\ntemplate&lt;class T, std::size_t N,\n    typename Indices = std::make_index_sequence&lt;N&gt;&gt;\nT* template_copy(T* a) {\n    return template_copy_impl&lt;T&gt;(a, Indices());\n}\n\nint main()\n{\n    const std::size_t N = 3;\n\n    A* orig = new A[N];\n    std::cout &lt;&lt; std::endl;\n\n    // modify original so we can see whats going on\n    for (int i = 0; i &lt; N; ++i)\n        orig[i].id = 1 + i;\n\n    A* copy = template_copy&lt;A, N&gt;(orig);\n    for (int i = 0; i &lt; N; ++i)\n        copy[i].id *= 10;\n\n    delete[] orig;\n    std::cout &lt;&lt; std::endl;\n\n    delete[] copy;\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Which when compiled with <code>-std=c++1y</code> (or equivalent) should output something like:</p>\n<pre><code>c[0]    c[0]    c[0]\nd[3]    d[2]    d[1]\nd[30]   d[20]   d[10]\n</code></pre>\n<h2>Different types in <code>new[]</code> vs <code>delete[]</code></h2>\n<p>To summarize, not only are we required to use <code>new[]</code> if we want to use <code>delete[]</code> but when omitting a <em>new-initializer</em>, our objects are default-initialized. So, what if we allocate memory using a fundamental type (similar, in a way, to using placement new), it will leave the memory uninitialized, right? Yes, but its undefined to delete the memory with something like <code>T* ptr = /* whatever */; delete[] ptr</code> if it was allocated with a different type. See <strong>\u00a75.3.5/2</strong>:</p>\n<blockquote>\n<p id=\"so_27258364_27329244_5\">In the second alternative (delete array), the value of the operand of delete may be a null pointer value or a pointer value that resulted from a previous array new-expression. If not, the behavior is undefined. [ Note: this means that the syntax of the delete-expression must match the type of the object allocated by new, not the syntax of the new-expression. \u2014 end note ]</p>\n</blockquote>\n<p>and <strong>\u00a75.3.5/3</strong>, which hints at the same thing:</p>\n<blockquote>\n<p id=\"so_27258364_27329244_6\">In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<h2>Other options?</h2>\n<p>Well, you could still use <code>unique_ptr</code>s as others have suggested. Although given that you're stuck with a large code base it's probably not feasible. Again for reference, here's what my humble implementation might look like:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstruct A\n{\n    int id;\n    A(int i) : id(i) {\n        std::cout &lt;&lt; \"c[\" &lt;&lt; id &lt;&lt; \"]\\t\";}\n    A() : A(0) {}\n\n    ~A() {std::cout &lt;&lt; \"d[\" &lt;&lt; id &lt;&lt; \"]\\t\";}\n};\n\ntemplate&lt;class T&gt;\nstruct deleter\n{\n    const bool wrapped;\n    std::size_t size;\n\n    deleter() :\n        wrapped(true), size(0) {}\n    explicit deleter(std::size_t uninit_mem_size) :\n        wrapped(false), size(uninit_mem_size) {}\n\n    void operator()(T* ptr)\n    {\n        if (wrapped)\n            delete[] ptr;\n        else if (ptr)\n        {\n            // backwards to emulate destruction order in\n            // normally allocated arrays\n            for (std::size_t i = size; i &gt; 0; --i)\n                ptr[i - 1].~T();\n            std::return_temporary_buffer&lt;T&gt;(ptr);\n        }\n    }\n};\n\n// to make it easier on ourselves\ntemplate&lt;class T&gt;\nusing unique_wrap = std::unique_ptr&lt;T[], deleter&lt;T&gt;&gt;;\n\ntemplate&lt;class T&gt;\nunique_wrap&lt;T&gt; wrap_buffer(T* orig)\n{\n    return unique_wrap&lt;T&gt;(orig);\n}\n\ntemplate&lt;class T&gt;\nunique_wrap&lt;T&gt; copy_buffer(T* orig, std::size_t orig_size)\n{\n    // get uninitialized memory\n    auto mem_pair = std::get_temporary_buffer&lt;T&gt;(orig_size);\n\n    // get_temporary_buffer can return less than what we ask for\n    if (mem_pair.second &lt; orig_size)\n    {\n        std::return_temporary_buffer(mem_pair.first);\n        throw std::bad_alloc();\n    }\n\n    // create a unique ptr with ownership of our memory, making sure to pass\n    // the size of the uninitialized memory to the deleter\n    unique_wrap&lt;T&gt; a_copy(mem_pair.first, deleter&lt;T&gt;(orig_size));\n\n    // perform the actual copy and return the unique_ptr\n    std::uninitialized_copy_n(orig, orig_size, a_copy.get());\n    return a_copy;\n}\n\n\nint main()\n{\n    const std::size_t N = 3;\n\n    A* orig = new A[N];\n    std::cout &lt;&lt; std::endl;\n\n    // modify original so we can see whats going on\n    for (int i = 0; i &lt; N; ++i)\n        orig[i].id = 1 + i;\n\n    unique_wrap&lt;A&gt; orig_wrap = wrap_buffer(orig);\n\n    {\n        unique_wrap&lt;A&gt; copy = copy_buffer(orig, N);\n        for (int i = 0; i &lt; N; ++i)\n            copy[i].id *= 10;\n\n        // if we are passing the original back we can just release it\n        A* back_to_somewhere = orig_wrap.release();\n\n        delete[] back_to_somewhere;\n        std::cout &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Which should output:</p>\n<pre><code>c[0]    c[0]    c[0]\nd[3]    d[2]    d[1]\nd[30]   d[20]   d[10]\n</code></pre>\n<p>Lastly, you might be able to override the global or class <code>operator new/delete</code>, but I wouldn't suggest it.</p>\n", "LastActivityDate": "2014-12-06T20:11:52.623"}, "bq_ids": {"n4140": {"so_27258364_27329244_3": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_27258364_27329244_5": {"section_id": 6106, "quality": 0.8787878787878788, "length": 29}, "so_27258364_27329244_2": {"section_id": 6098, "quality": 1.0, "length": 7}, "so_27258364_27329244_6": {"section_id": 6107, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_27258364_27329244_3": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_27258364_27329244_5": {"section_id": 5872, "quality": 0.8787878787878788, "length": 29}, "so_27258364_27329244_2": {"section_id": 5864, "quality": 1.0, "length": 7}, "so_27258364_27329244_6": {"section_id": 5873, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_27258364_27329244_5": {"section_id": 7603, "quality": 0.8787878787878788, "length": 29}, "so_27258364_27329244_2": {"section_id": 7595, "quality": 1.0, "length": 7}, "so_27258364_27329244_6": {"section_id": 7604, "quality": 0.9285714285714286, "length": 13}}}, "27258364": {"CommentCount": "9", "ViewCount": "276", "PostTypeId": "1", "LastEditorUserId": "331059", "CreationDate": "2014-12-02T20:30:08.440", "LastActivityDate": "2014-12-06T20:11:52.623", "Title": "How can I efficiently clone a dynamically allocated array?", "AcceptedAnswerId": "27329244", "LastEditDate": "2014-12-03T21:00:14.843", "Id": "27258364", "Score": "-2", "Body": "<p>I have a class which is a templated smart pointer meant for wrapping dynamically allocated arrays. I know that there are classes in the STL that can be used for this, especially in C++11, but this is a widely-used internal class.</p>\n<p>I wish to write a Clone() method for it. My initial implementation used std::copy, but I realized I should be able to avoid the default construction when allocating the array.</p>\n<p><a href=\"http://codepad.org/qCl0EI3E\" rel=\"nofollow\">My attempt</a> at a PoC ends up with a segmentation fault:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nclass A\n{\npublic:\n    A(int j) : i(j) {}\n    ~A() {std::cout &lt;&lt; \"Destroying \" &lt;&lt; i &lt;&lt; std::endl;}\n\nprivate:\nint i;\n};\n\nint main()\n{\n    int a[] = {1, 2, 3};\n\n    A* arr = static_cast&lt;A*&gt;(::operator new[](sizeof(A) * 3));\n    std::uninitialized_copy(a, a + 3, arr);\n    delete [] arr;//::operator delete[](arr);\n}\n</code></pre>\n<p>How do I create a dynamically allocated array of T, initialized with std::uninitialized_copy, so that it can be deleted with 'delete []' (i.e. treated as if it was allocated with a simple 'new T[N]')?</p>\n<hr>\n<p>Since it seems people have had trouble understanding what I'm asking, here's the essence of my question:</p>\n<pre><code>#include &lt;algorithm&gt;\n\ntemplate &lt;typename T&gt;\nT* CloneArray(T* in_array, size_t in_count)\n{\n    if (!in_array)\n        return nullptr;\n\n    T* copy = new T[in_count];\n    try\n    {\n        std::copy(in_array, in_array + in_count, copy);\n    }\n    catch (...)\n    {\n        delete [] copy;\n\n        throw;\n    }\n\n    return copy;\n}\n</code></pre>\n<p>How would I rewrite this function in a way that prevents <code>T::T()</code> from being called (if it even exists!), while returning the exact same result (let's assume our types are well behaved in that <code>T t; t = other;</code> and <code>T t(other);</code> are equivalent), including the fact that the result of the function can be deleted using the standard <code>delete []</code> operator.</p>\n</hr>", "Tags": "<c++>", "OwnerUserId": "331059", "AnswerCount": "2"}});