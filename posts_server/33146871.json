post_cb({"33146871": {"CommentCount": "5", "AcceptedAnswerId": "33147835", "PostTypeId": "1", "LastEditorUserId": "4498329", "CreationDate": "2015-10-15T11:06:16.913", "LastActivityDate": "2015-10-15T11:52:11.647", "LastEditDate": "2015-10-15T11:13:47.800", "ViewCount": "414", "FavoriteCount": "4", "Title": "Is this valid C++ 11", "Id": "33146871", "Score": "24", "Body": "<p>I have the following code that compiles under g++, but not with clang.</p>\n<p>Clang will compile the code if changed in various minor ways, such as merging the 2 namespace declarations.</p>\n<pre><code>// The problem disappears without namespaces.\nnamespace Root {\n    // The problem disappears if 'g' is in the global namespace, and we change\n    // the friend declaration to '::g'\n\n    // The problem disappears if 'g' has void return type.\n\n    // The problem disappears if we get rid of the 'Value' template argument\n    // and the 'value' parameter.\n    template&lt;typename Value, typename Defaulted = void&gt;\n    bool g(Value value);\n\n    // The problem disappears if MyClass is not a template.\n    template&lt;typename ClassValue&gt;\n    class MyClass {\n    private:\n        template&lt;typename Value, typename Defaulted&gt;\n        friend bool g(Value value);\n    };\n}\n\n// The problem disappears if we declare the Root namespace in a single block\n// containing 'g', 'MyClass' and 'f'.\n\n// The problem remains if we declare f in the global namespace and reference\n// Root::g.\nnamespace Root {\n    void f() {\n        MyClass&lt;int&gt; value;\n\n        g(value);\n    }\n}\n</code></pre>\n<p>To compile with clang:</p>\n<pre><code>clang -fsyntax-only -std=c++11 testcase.cpp\n</code></pre>\n<p>To compile with g++:</p>\n<pre><code>g++ -fsyntax-only -std=c++11 testcase.cpp\n</code></pre>\n<p>Versions are g++ 4.9.2, clang 3.6.0, both on Ubuntu core 15.04.</p>\n<p>Clang gives the error message:</p>\n<pre><code>testcase.cpp:24:9: error: no matching function for call to 'g'\n        g(value);\n        ^\ntestcase.cpp:14:21: note: candidate template ignored: couldn't infer template argument 'Defaulted'\n        friend bool g(Value value);\n                ^\n1 error generated.\n</code></pre>\n", "Tags": "<c++><c++11><clang><language-lawyer>", "OwnerUserId": "2703165", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33146871_33147835_0": {"section_id": 62, "quality": 1.0, "length": 14}, "so_33146871_33147835_1": {"section_id": 63, "quality": 0.8, "length": 16}}, "n3337": {"so_33146871_33147835_0": {"section_id": 57, "quality": 1.0, "length": 14}, "so_33146871_33147835_1": {"section_id": 58, "quality": 0.8, "length": 16}}, "n4659": {"so_33146871_33147835_0": {"section_id": 64, "quality": 1.0, "length": 14}, "so_33146871_33147835_1": {"section_id": 65, "quality": 0.9, "length": 18}}}, "33147835": {"ParentId": "33146871", "CommentCount": "3", "Body": "<p>I believe this is a clang bug. From [temp.param], we have:</p>\n<blockquote>\n<p id=\"so_33146871_33147835_0\">If a friend function template declaration specifies\n  a default <em>template-argument</em>, that declaration shall be a definition and shall be the only declaration of the\n  function template in the translation unit.</p>\n<p id=\"so_33146871_33147835_1\">The set of default <em>template-arguments</em> available for use is obtained by merging the default arguments from\n  all prior declarations of the template in the same way default function arguments are (8.3.6).</p>\n</blockquote>\n<p>The latter point means that we can write:</p>\n<pre><code>template &lt;typename T, typename U=int&gt;\nvoid h();\n\ntemplate &lt;typename T, typename U&gt;\nvoid h() { }\n\nh&lt;int&gt;();\n</code></pre>\n<p>And this is perfectly well formed code that clang compiles. We <em>cannot</em> specify the default template-argument to <code>g</code> based on the rule quoted, as <code>g</code> is previously declared, but <em>not</em> specifying it should still keep <code>Defaulted</code> available for use as <code>void</code> via the merge step. If the default-argument is available, then lookup should be able to find the <code>g</code> we want. </p>\n<p>A workaround would be to simply friend the specialization we care about:</p>\n<pre><code>friend bool g&lt;&gt;(MyClass value);\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "33147835", "Score": "7", "CreationDate": "2015-10-15T11:52:11.647", "LastActivityDate": "2015-10-15T11:52:11.647"}});