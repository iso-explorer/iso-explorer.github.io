post_cb({"27042248": {"ParentId": "27042002", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Well, you could simply have <em>tried it</em>!</p>\n<pre><code>#include &lt;cassert&gt;\n\nstruct IBase1\n{\n    virtual void foo() = 0;\n    virtual ~IBase1() {}\n};\n\nstruct IBase2\n{\n    virtual void bar() = 0;\n    virtual ~IBase2() {}\n};\n\nstruct Derived : IBase1, IBase2\n{\n    void foo() {}\n    void bar() {}\n};\n\nint main()\n{\n    Derived d;\n\n    IBase1* ptr = &amp;d;\n    assert(dynamic_cast&lt;IBase2*&gt;(ptr));\n    assert(dynamic_cast&lt;Derived*&gt;(ptr));\n}\n\n// Compiles successfully\n</code></pre>\n<p>And here's the proof:</p>\n<blockquote>\n<p id=\"so_27042002_27042248_0\"><code>[C++11: 5.2.7/8]:</code> If <code>C</code> is the class type to which <code>T</code> points or refers, the run-time check logically executes as follows:</p>\n<ul>\n<li>If, in the most derived object pointed (referred) to by <code>v</code>, <code>v</code> points (refers) to a <code>public</code> base class subobject of a <code>C</code> object, and if only one object of type <code>C</code> is derived from the subobject pointed (referred) to by <code>v</code> the result points (refers) to that <code>C</code> object.</li>\n<li><p id=\"so_27042002_27042248_1\">Otherwise, <strong>if <code>v</code> points (refers) to a public base class subobject of the most derived object, and the type of the most derived object has a base class, of type <code>C</code>, that is unambiguous and <code>public</code>, the result points (refers) to the <code>C</code> subobject of the most derived object.</strong></p></li>\n<li><p id=\"so_27042002_27042248_2\">Otherwise, the run-time check <em>fails</em>.</p></li>\n</ul>\n</blockquote>\n<p>Colloquially, we call this <em>cross-casting</em>.</p>\n<p>There is no requirement stipulated by the language that the most derived object's type be known about in the \"current\" translation unit; it's up to the implementation to make that work and, in the common \"virtual tables\" model, indeed it does.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2014-11-20T14:46:13.237", "Id": "27042248", "Score": "1", "CreationDate": "2014-11-20T14:39:04.830", "LastActivityDate": "2014-11-20T14:46:13.237"}, "27042002": {"CommentCount": "4", "ViewCount": "555", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-11-20T14:27:38.277", "LastActivityDate": "2016-03-18T10:41:44.630", "Title": "Complex dynamic_cast in c++", "AcceptedAnswerId": "27042233", "LastEditDate": "2016-03-18T10:41:44.630", "Id": "27042002", "Score": "9", "Body": "<p>I have the following case in C++:</p>\n<ul>\n<li>Abstract base classes <code>Abstract1</code> and <code>Abstract2</code>. They are unrelated.</li>\n<li>A class <code>Foo</code> deriving from both <code>Abstract1</code> and <code>Abstract2</code></li>\n</ul>\n<p>I am in a compilation unit where I have no information about class <code>Foo</code> (no declaration, no definition). Only <code>Abstract1</code> and <code>Abstract2</code> are known.\n(Actually, Foo is even defined in a DLL)</p>\n<p>Will dynamic_cast allow casting from <code>Abstract1*</code> to <code>Abstract2*</code>? Is this a standard?</p>\n", "Tags": "<c++><polymorphism><language-lawyer><dynamic-cast><cross-cast>", "OwnerUserId": "2042388", "AnswerCount": "4"}, "27042181": {"ParentId": "27042002", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes it will work.</p>\n<p><code>dynamic_cast</code> is based on <a href=\"http://en.wikipedia.org/wiki/Run-time_type_information\" rel=\"nofollow\">RTTI</a>. The information provided by RTTI here is enough to determine the actual dynamic type of the pointed to object. By definition, RTTI is a run time notion, as is the dynamic type of the pointed to object (the fact that Foo's definition is not available in a compilation unit where said cast is written is a compile time notion, with no relevance here).</p>\n<ul>\n<li>If the pointed to object is actually a Foo, the dynamic_cast will succeed at <strong>run time</strong>.</li>\n<li>If it is not a pointer to an object deriving from Abstract2, it will fail (returning a null pointer).</li>\n</ul>\n<h1>details</h1>\n<p>A possible implementation of <code>dynamic_cast</code> is to look up a special member at the beginning of the object's memory layout (or it could be stored along the v-table). This structure could contain a value, which identifies the <strong>dynamic type</strong> of the object.\nSomewhere, the compiler would have generated a <em>static</em> table, replicating all the information about your program inheritance diagram.\nAt run time, the cast would extract the type identifier of your instance, and check it against the static table. If this identifier refers to a type deriving from Abstract2, the cast is meaningful (and the code can return a pointer correctly offset to the <code>Abstract2</code> interface of your object).</p>\n<p>Even this na\u00efve implementation never requires the knowledge of <code>Foo</code> in the compilation unit where the \ncast is written.</p>\n", "OwnerUserId": "1027706", "LastEditorUserId": "1027706", "LastEditDate": "2014-11-20T14:56:52.443", "Id": "27042181", "Score": "4", "CreationDate": "2014-11-20T14:36:09.000", "LastActivityDate": "2014-11-20T14:56:52.443"}, "27042329": {"ParentId": "27042002", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>For this code:</strong></p>\n<pre><code>void func(Abstract1* a1)\n{\n    Abstract2* a2 = dynamic_cast&lt;Abstract2*&gt;(a1);\n    ...\n}\n</code></pre>\n<p><strong>You're asking:</strong></p>\n<p>If <code>a1</code> is pointing to a <code>Foo</code> object, will the dynamic-cast return a valid object pointer?</p>\n<p><strong>The answer is yes:</strong></p>\n<ul>\n<li>During runtime, the dynamic-cast will identify the V-Table of <code>a1</code> as the V-Table of <code>class Foo</code>.</li>\n<li>Since <code>class Foo</code> inherits from <code>class Abstract2</code>, the dynamic-cast will return a valid pointer.</li>\n</ul>\n", "OwnerUserId": "1382251", "LastEditorUserId": "1382251", "LastEditDate": "2014-11-20T14:48:04.557", "Id": "27042329", "Score": "2", "CreationDate": "2014-11-20T14:42:25.397", "LastActivityDate": "2014-11-20T14:48:04.557"}, "27042233": {"ParentId": "27042002", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What you describe is a so-called <em>cross-cast</em>. For <code>dynamic_cast&lt;T&gt;(v)</code>, the standard specifies in [expr.dynamic.cast]/8</p>\n<blockquote>\n<p id=\"so_27042002_27042233_0\">If <code>C</code> is the class type to which <code>T</code> points or refers, the run-time\n  check logically executes as follows:</p>\n<ul>\n<li><p id=\"so_27042002_27042233_1\">If, in the most derived object pointed (referred) to by <code>v</code>, <code>v</code> points (refers) to a public base class subobject of a <code>C</code> object [..]</p></li>\n<li><p id=\"so_27042002_27042233_2\"><strong>Otherwise, if <code>v</code> points (refers) to a <code>public</code> base class subobject of the most derived object, and the type of the most derived object\n  has a base class, of type <code>C</code>, that is unambiguous and <code>public</code>, the\n  result points (refers) to the <code>C</code> subobject of the most derived\n  object.</strong></p></li>\n</ul>\n</blockquote>\n<p>That will work even with no information about <code>Foo</code>'s existence in the translation unit that contains the cast. <br/></p>\n<p>You should check out <a href=\"https://stackoverflow.com/a/5321710/3647361\">this question</a> too.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:45.630", "Id": "27042233", "Score": "6", "CreationDate": "2014-11-20T14:38:21.873", "LastActivityDate": "2014-11-21T07:51:55.487"}, "bq_ids": {"n4140": {"so_27042002_27042233_2": {"section_id": 6018, "quality": 1.0, "length": 26}, "so_27042002_27042248_0": {"section_id": 6018, "quality": 0.8181818181818182, "length": 9}, "so_27042002_27042233_0": {"section_id": 6018, "quality": 1.0, "length": 9}, "so_27042002_27042248_1": {"section_id": 6018, "quality": 1.0, "length": 26}, "so_27042002_27042233_1": {"section_id": 6018, "quality": 1.0, "length": 12}}, "n3337": {"so_27042002_27042248_0": {"section_id": 5786, "quality": 0.8181818181818182, "length": 9}, "so_27042002_27042233_2": {"section_id": 5786, "quality": 1.0, "length": 26}, "so_27042002_27042248_1": {"section_id": 5786, "quality": 1.0, "length": 26}, "so_27042002_27042233_0": {"section_id": 5786, "quality": 1.0, "length": 9}, "so_27042002_27042233_1": {"section_id": 5786, "quality": 1.0, "length": 12}}, "n4659": {"so_27042002_27042248_0": {"section_id": 7517, "quality": 0.8181818181818182, "length": 9}, "so_27042002_27042233_2": {"section_id": 7517, "quality": 1.0, "length": 26}, "so_27042002_27042248_1": {"section_id": 7517, "quality": 1.0, "length": 26}, "so_27042002_27042233_0": {"section_id": 7517, "quality": 1.0, "length": 9}, "so_27042002_27042233_1": {"section_id": 7517, "quality": 1.0, "length": 12}}}});