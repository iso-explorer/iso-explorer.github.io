post_cb({"1269141": {"Id": "1269141", "PostTypeId": "2", "Body": "<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf\" rel=\"nofollow noreferrer\">current C++ draft standard</a>, section 5.3.1 sentence 8:</p>\n<blockquote>\n<p id=\"so_1269019_1269141_0\">The operand of the unary <code>-</code> operator shall have arithmetic or enumeration type and the result is the negation of its operand. Integral promotion is performed on integral or enumeration operands. The negative of an unsigned quantity is computed by subtracting its value from 2<sup>n</sup>, where n is the number of bits in the promoted operand. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>So the resulting expression is still unsigned and calculated as described.</p>\n<p>User @outis mentioned this in a comment, but I'm going to put it in an answer since outis didn't. If outis comes back and answers, I'll accept that instead.</p>\n", "LastActivityDate": "2009-08-12T22:47:27.980", "Score": "1", "CreationDate": "2009-08-12T22:47:27.980", "ParentId": "1269019", "CommentCount": "1", "OwnerUserId": "90002"}, "1848053": {"Id": "1848053", "PostTypeId": "2", "Body": "<p>negating an unsigned number is useful for propagating the lsb across the word to form a mask for subsequent bitwise operations.</p>\n", "LastActivityDate": "2009-12-04T16:23:12.203", "Score": "2", "CreationDate": "2009-12-04T16:23:12.203", "ParentId": "1269019", "CommentCount": "0", "OwnerUserId": "224900"}, "1269081": {"Id": "1269081", "PostTypeId": "2", "Body": "<p>The only thing I can think of is so wrong it makes my head hurt...</p>\n<pre><code>size_t size_of_stuff = sizeof(stuff);\n\nif(I want to subtract the size)\n    size_of_stuff = -sizeof(stuff);\n\nsize_t total_size = size_of_stuff + other_sizes;\n</code></pre>\n<p>Overflow is a feature!</p>\n", "LastActivityDate": "2009-08-12T22:30:04.100", "Score": "1", "CreationDate": "2009-08-12T22:30:04.100", "ParentId": "1269019", "CommentCount": "1", "OwnerUserId": "129496"}, "1269035": {"Id": "1269035", "PostTypeId": "2", "Body": "<p><a href=\"http://msdn.microsoft.com/en-us/library/wxxx8d2t%28VS.80%29.aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/wxxx8d2t%28VS.80%29.aspx</a></p>\n<blockquote>\n<p id=\"so_1269019_1269035_0\">Unary negation of unsigned quantities\n  is performed by subtracting the value\n  of the operand from 2<sup>n</sup>, where n is the\n  number of bits in an object of the\n  given unsigned type. (Microsoft C++\n  runs on processors that utilize\n  two's-complement arithmetic. On other\n  processors, the algorithm for negation\n  can differ.)</p>\n</blockquote>\n<p>In other words, the exact behavior will be architecture-specific. If I were you, I would avoid using such a weird construct.</p>\n", "LastEditorUserId": "3560", "LastActivityDate": "2009-08-12T22:20:30.657", "Score": "2", "CreationDate": "2009-08-12T22:14:46.567", "ParentId": "1269019", "CommentCount": "10", "LastEditDate": "2009-08-12T22:20:30.657", "OwnerUserId": "3560"}, "1269019": {"ViewCount": "2187", "Body": "<p>I'm dealing with some code at work that includes an expression of the form </p>\n<pre><code>-(sizeof(struct foo))\n</code></pre>\n<p>i.e. the negation of a <code>size_t</code>, and I'm unclear on what the C and C++ standards require of compilers when they see this. Specifically, from looking around here and elsewhere, <code>sizeof</code> returns an unsigned integral value of type <code>size_t</code>. I can't find any clear reference for specified behavior when negating an unsigned integer. Is there any, and if so, what is it?</p>\n<p>Edit: Ok, so there are some good answers regarding arithmetic on unsigned types, but it's not clear that this is in fact such. When this negates, is it operating on an unsigned integer, or converting to a signed type and doing something with that? Is the behavior to expect from the standards \"imagine it's the negative number of similar magnitude and then apply the 'overflow' rules for unsigned values\"?</p>\n", "AcceptedAnswerId": "1269049", "Title": "What should happen to the negation of a size_t (i.e. `-sizeof(struct foo)`))?", "CreationDate": "2009-08-12T22:10:05.920", "Id": "1269019", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-08-12T22:31:48.653", "LastEditorUserId": "90002", "LastActivityDate": "2015-11-10T02:11:32.683", "Score": "12", "OwnerUserId": "90002", "Tags": "<c++><c><sizeof><unsigned><size-t>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_1269019_1269049_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 7213}, "so_1269019_1269049_0": {"length": 13, "quality": 0.8125, "section_id": 7213}, "so_1269019_1269141_0": {"length": 34, "quality": 0.918918918918919, "section_id": 6071}, "so_1269019_1269049_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 7213}, "so_1269019_1269049_4": {"length": 16, "quality": 0.8, "section_id": 6071}}, "n3337": {"so_1269019_1269049_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 6957}, "so_1269019_1269049_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 6957}, "so_1269019_1269049_4": {"length": 16, "quality": 0.8, "section_id": 5839}, "so_1269019_1269049_0": {"length": 15, "quality": 0.9375, "section_id": 6957}, "so_1269019_1269141_0": {"length": 34, "quality": 0.918918918918919, "section_id": 5839}}, "n4659": {"so_1269019_1269049_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 8722}, "so_1269019_1269049_3": {"length": 22, "quality": 0.8148148148148148, "section_id": 8722}, "so_1269019_1269049_4": {"length": 16, "quality": 0.8, "section_id": 7567}, "so_1269019_1269049_0": {"length": 13, "quality": 0.8125, "section_id": 8722}, "so_1269019_1269141_0": {"length": 34, "quality": 0.918918918918919, "section_id": 7567}}}, "33621222": {"Id": "33621222", "PostTypeId": "2", "Body": "<p><code>size_t</code> is an implementation-defined unsigned integer type.</p>\n<p>Negating a <code>size_t</code> value <em>probably</em> gives you a result of type <code>size_t</code> with the usual unsigned modulo behavior. For example, assuming that <code>size_t</code> is 32 bits and <code>sizeof(struct foo) == 4</code>, then <code>-sizeof(struct foo) == 4294967292</code>, or 2<sup>32</sup>-4.</p>\n<p>Except for one thing: The unary <code>-</code> operator applies the <em>integer promotions</em> (C) or <em>integral promotions</em> (C++) (they're essentially the same thing) to its operand. If <code>size_t</code> is at least as wide as <code>int</code>, then this promotion does nothing, and the result is of type <code>size_t</code>. But if <code>int</code> is wider than <code>size_t</code>, so that <code>INT_MAX &gt;= SIZE_MAX</code>, then the operand of <code>-</code> is \"promoted\" from <code>size_t</code> to <code>int</code>. In that unlikely case, <code>-sizeof(struct foo) == -4</code>.</p>\n<p>If you assign that value back to a <code>size_t</code> object, then it will be converted back to <code>size_t</code>, yielding the <code>SIZE_MAX-4</code> value that you'd expect. But without such a conversion, you can get some surprising results.</p>\n<p>Now I've never heard of an implementation where <code>size_t</code> is narrower than <code>int</code>, so you're not likely to run into this. But here's a test case, using <code>unsigned short</code> as a stand-in for the hypothetical narrow <code>size_t</code> type, that illustrates the potential problem:</p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n    typedef unsigned short tiny_size_t;\n    struct foo { char data[4]; };\n    tiny_size_t sizeof_foo = sizeof (foo);\n    std::cout &lt;&lt; \"sizeof (foo) = \" &lt;&lt; sizeof (foo) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"-sizeof (foo) = \" &lt;&lt; -sizeof (foo) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"sizeof_foo = \" &lt;&lt; sizeof_foo &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"-sizeof_foo = \" &lt;&lt; -sizeof_foo &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>The output on my system (which has 16-bit <code>short</code>, 32-bit <code>int</code>, and 64-bit <code>size_t</code>) is:</p>\n<pre><code>sizeof (foo) = 4\n-sizeof (foo) = 18446744073709551612\nsizeof_foo = 4\n-sizeof_foo = -4\n</code></pre>\n", "LastEditorUserId": "827263", "LastActivityDate": "2015-11-10T02:11:32.683", "Score": "1", "CreationDate": "2015-11-10T01:12:40.517", "ParentId": "1269019", "CommentCount": "4", "LastEditDate": "2015-11-10T02:11:32.683", "OwnerUserId": "827263"}, "1269049": {"Id": "1269049", "PostTypeId": "2", "Body": "<p>Both ISO C and ISO C++ standards guarantee that unsigned arithmetic is modulo 2<sup>n</sup> - i.e., for any overflow or underflow, it \"wraps around\". For ISO C++, this is 3.9.1[basic.fundamental]/4:</p>\n<blockquote>\n<p id=\"so_1269019_1269049_0\">Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo 2<sup>n</sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.<sup>41</sup></p>\n<p id=\"so_1269019_1269049_1\">...</p>\n<p id=\"so_1269019_1269049_2\">41) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer\n  type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer\n  type.</p>\n</blockquote>\n<p>For ISO C(99), it is 6.2.5/9:</p>\n<blockquote>\n<p id=\"so_1269019_1269049_3\">A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.</p>\n</blockquote>\n<p>Which means the result is guaranteed to be the same as <code>SIZE_MAX - (sizeof(struct foo)) + 1</code>.</p>\n<hr>\n<p>In ISO 14882:2003 5.3.1.7:</p>\n<blockquote>\n<p id=\"so_1269019_1269049_4\">[...] The negative of an unsigned\n  quantity is computed by subtracting\n  its value from 2<sup>n</sup>, where\n  <em>n</em> is the number of bits in\n  the pro- moted operand. The type of\n  the result is the type of the promoted\n  operand.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "3560", "LastActivityDate": "2009-08-12T22:41:04.890", "Score": "21", "CreationDate": "2009-08-12T22:19:19.240", "ParentId": "1269019", "CommentCount": "3", "LastEditDate": "2009-08-12T22:41:04.890", "OwnerUserId": "111335"}});