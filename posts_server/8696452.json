post_cb({"8696452": {"CommentCount": "0", "AcceptedAnswerId": "8696569", "PostTypeId": "1", "LastEditorUserId": "346804", "CreationDate": "2012-01-02T00:06:04.173", "LastActivityDate": "2012-01-02T06:46:24.830", "LastEditDate": "2012-01-02T06:46:24.830", "ViewCount": "2455", "FavoriteCount": "1", "Title": "get value_type of dereferencable types", "Id": "8696452", "Score": "3", "Body": "<p>I how would I achieve the following for any derefernable type?</p>\n<p>I find my current solution lacking since I need to do a class template specialization for every type I want it to work with:</p>\n<pre><code>template&lt;typename T&gt;\nstruct get_value_type\n{\n    typedef typename T::value_type value_type;\n};\n\ntemplate&lt;typename E&gt;\nstruct get_value_type&lt;std::unique_ptr&lt;E&gt;&gt;\n{\n    typedef typename E::value_type value_type;\n};  \n\ntemplate&lt;typename E&gt;\nstruct get_value_type&lt;std::shared_ptr&lt;E&gt;&gt;\n{\n    typedef typename E::value_type value_type;\n};  \n\ntemplate&lt;typename E&gt;\nstruct get_value_type&lt;boost::optional&lt;E&gt;&gt;\n{\n    typedef typename E::value_type value_type;\n};\n</code></pre>\n<p>I've tried the something along the ways of, which doesn't work.</p>\n<pre><code>template&lt;typename T, typename IsIndirect = false_type&gt;\nget_value_type\n{\n    typedef typename T::value_type value_type;     \n}\n\ntemplate&lt;typename T&gt;\nstruct get_value_type&lt;T, true_type&gt;\n{\n     typedef decltype(*boost::declval&lt;E&gt;())::value_type value_type; \n};\n\ntypedef get_value_type&lt;T, is_indirect&lt;T&gt;::type&gt; value_type;\n</code></pre>\n", "Tags": "<c++><visual-studio-2010><c++11><template-meta-programming><typetraits>", "OwnerUserId": "346804", "AnswerCount": "2"}, "8696569": {"ParentId": "8696452", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You're looking for <code>std::pointer_traits&lt;PointerType&gt;::element_type</code> which lives in <code>&lt;memory&gt;</code>.</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;boost/optional.hpp&gt;\n\ntemplate &lt;class Ptr&gt;\nstruct MyPointer\n{\n};\n\ntemplate &lt;class Ptr&gt;\nstruct YourPointer\n{\n    typedef signed char element_type;\n};\n\nint main()\n{\n    static_assert\n    (\n        std::is_same\n        &lt;\n            std::pointer_traits&lt;std::unique_ptr&lt;double&gt;&gt;::element_type,\n            double\n        &gt;::value,\n        \"\"\n    );\n    static_assert\n    (\n        std::is_same\n        &lt;\n            std::pointer_traits&lt;std::unique_ptr&lt;short[]&gt;&gt;::element_type,\n            short\n        &gt;::value,\n        \"\"\n    );\n    static_assert\n    (\n        std::is_same\n        &lt;\n            std::pointer_traits&lt;std::shared_ptr&lt;const char&gt;&gt;::element_type,\n            const char\n        &gt;::value,\n        \"\"\n    );\n    static_assert\n    (\n        std::is_same\n        &lt;\n            std::pointer_traits&lt;boost::optional&lt;int*&gt;&gt;::element_type,\n            int*\n        &gt;::value,\n        \"\"\n    );\n    static_assert\n    (\n        std::is_same\n        &lt;\n            std::pointer_traits&lt;MyPointer&lt;long long&gt;&gt;::element_type,\n            long long\n        &gt;::value,\n        \"\"\n    );\n    static_assert\n    (\n        std::is_same\n        &lt;\n            std::pointer_traits&lt;YourPointer&lt;long long&gt;&gt;::element_type,\n            signed char\n        &gt;::value,\n        \"\"\n    );\n}\n</code></pre>\n<p>20.6.3.1 Pointer traits member types [pointer.traits.types]</p>\n<blockquote>\n<p id=\"so_8696452_8696569_0\"><code>typedef</code> <em>see below</em> <code>element_type</code>;</p>\n<p id=\"so_8696452_8696569_1\"><em>Type:</em> <code>Ptr::element_type</code> if such a type exists; otherwise, <code>T</code> if <code>Ptr</code> is a class template instantiation of the form <code>SomePointer&lt;T,\n  Args&gt;</code>, where <code>Args</code> is zero or more type arguments; otherwise, the\n  specialization is ill-formed.</p>\n</blockquote>\n<p>Oh, and there's a specialization for pointer types as well:</p>\n<pre><code>template &lt;class T&gt;\nstruct pointer_traits&lt;T*&gt;\n{\n    typedef T*        pointer;\n    typedef T         element_type;\n    typedef ptrdiff_t difference_type;\n\n    template &lt;class U&gt; using rebind = U*;\n\n    static pointer pointer_to(see below r) noexcept;\n};\n</code></pre>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2012-01-02T01:08:39.493", "Id": "8696569", "Score": "7", "CreationDate": "2012-01-02T00:39:32.307", "LastActivityDate": "2012-01-02T01:08:39.493"}, "8696504": {"ParentId": "8696452", "CommentCount": "3", "Body": "<p>One solution which may be overly broad is to use a template template argument:</p>\n<pre><code>template &lt;template &lt;typename&gt; class C, typename T&gt;\nstruct get_value_type&lt;C&lt;T&gt;&gt;\n{\n    typedef T value_type;\n};\n</code></pre>\n<p>The more flexible solution would use variadics:</p>\n<pre><code>template &lt;typename&gt; struct get_first_param;\n\ntemplate &lt;template &lt;typename...&gt; class C, typename T, typename ...Args&gt;\nstruct get_first_param&lt;C&lt;T, Args...&gt;&gt;\n{\n    typedef T value_type;\n};\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "8696504", "Score": "2", "CreationDate": "2012-01-02T00:19:50.140", "LastActivityDate": "2012-01-02T00:19:50.140"}, "bq_ids": {"n4140": {"so_8696452_8696569_1": {"section_id": 4188, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_8696452_8696569_1": {"section_id": 4031, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_8696452_8696569_1": {"section_id": 5448, "quality": 0.8636363636363636, "length": 19}}}});