post_cb({"bq_ids": {"n4140": {"so_41528905_41528920_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 255}}, "n3337": {"so_41528905_41528920_1": {"length": 9, "quality": 0.6428571428571429, "section_id": 243}}, "n4659": {"so_41528905_41528920_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 262}}}, "41528905": {"ViewCount": "49", "Body": "<p>Today, someone presented me with code of the following form:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace example {\n    template &lt;typename T&gt;\n    T variable_template = T(42);\n}\n\nint main() {\n    example::variable_template&lt;int&gt; = 10;\n    std::cout &lt;&lt; example::variable_template&lt;int&gt; &lt;&lt; std::endl;\n}\n</code></pre>\n<p>You can see it running here: <a href=\"http://coliru.stacked-crooked.com/a/3a786c42b5204b0a\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/3a786c42b5204b0a</a></p>\n<p>I expected this code to print 42, since 10 appears to be assigned to a temporary. Inside the namespace, there template is only a declaration (not an instantation), so there's no data to mutate inside of the namespace. Dispite that, it surprised me and printed 10 instead.</p>\n<p>I would have also expected a warning on the assignment to a temporary, but that didn't happen either.</p>\n<p>Is this undefined behaviour, is my understanding of templates flawed, or is something else going on?</p>\n", "AcceptedAnswerId": "41528920", "Title": "Can a variable template be mutated?", "CreationDate": "2017-01-08T02:38:52.073", "Id": "41528905", "CommentCount": "1", "LastEditDate": "2017-01-08T13:04:55.947", "PostTypeId": "1", "LastEditorUserId": "1816262", "LastActivityDate": "2017-01-08T13:05:15.097", "Score": "0", "OwnerUserId": "1816262", "Tags": "<c++><templates><variable-templates>", "AnswerCount": "1"}, "41528920": {"Id": "41528920", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41528905_41528920_0\">Inside the namespace, there template is only a declaration (not an instantation), so there's no data to mutate inside of the namespace.</p>\n</blockquote>\n<p>Not so!</p>\n<blockquote>\n<p id=\"so_41528905_41528920_1\"><code>[C++14: 14.7.2/6]:</code> An explicit instantiation of a class, function template, or variable template specialization is placed in the namespace in which the template is defined. <em>[..]</em></p>\n</blockquote>\n<p>When you have a class template <code>Foo</code>, and refer to an instantiation (say, <code>Foo&lt;int&gt;</code>), that instantiation exists just like a normal class, with the same scope as the template had.</p>\n<p>There is nothing different with variable templates. When you refer to <code>example::variable_template&lt;int&gt;</code>, you \"add\" that variable to the scope containing the template.</p>\n<p><strong>Your namespace <code>example</code> then contains a variable called <code>variable_template&lt;int&gt;</code>.</strong></p>\n<hr>\n<blockquote>\n<p id=\"so_41528905_41528920_2\">I would have also expected a warning on the assignment to a temporary, but that didn't happen either.</p>\n</blockquote>\n<p>There are no temporaries here, aside from the <code>T(42)</code>.</p>\n</hr>", "LastEditorUserId": "1816262", "LastActivityDate": "2017-01-08T13:05:15.097", "Score": "4", "CreationDate": "2017-01-08T02:41:34.183", "ParentId": "41528905", "CommentCount": "3", "OwnerUserId": "560648", "LastEditDate": "2017-01-08T13:05:15.097"}});