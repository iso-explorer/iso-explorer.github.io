post_cb({"bq_ids": {"n4140": {"so_1243962_1244346_0": {"length": 15, "quality": 1.0, "section_id": 6030}, "so_1243962_1244346_1": {"length": 25, "quality": 1.0, "section_id": 593}}, "n3337": {"so_1243962_1244346_0": {"length": 15, "quality": 1.0, "section_id": 5798}, "so_1243962_1244346_1": {"length": 25, "quality": 1.0, "section_id": 583}}, "n4659": {"so_1243962_1244346_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 2}, "so_1243962_1244346_1": {"length": 25, "quality": 1.0, "section_id": 616}}}, "1244346": {"Id": "1244346", "PostTypeId": "2", "Body": "<p>I've simplified your example to the following:</p>\n<pre><code>typedef unsigned int size_t;\n\ntemplate &lt;typename T&gt;\nclass List\n{\npublic:\n  typedef size_t  size_type;\n  List (List const &amp;);\n  List (size_type i, T const &amp; = T());\n};\n\ntypedef List&lt;unsigned char&gt; UCList;\n\nclass MyClass\n{\npublic:\n  operator UCList const () const;\n  operator unsigned char () const;\n};\n\nvoid foo ()\n{\n  MyClass mc;\n  (UCList)mc;\n}\n</code></pre>\n<p>The first point, is that the standard defines that the C-style cast should use the more appropriate C++ style cast, and in this case that's <code>static_cast</code>.  So the above cast is equivalent to:</p>\n<pre><code>static_cast&lt;UCList&gt; (mc);\n</code></pre>\n<p>The definition of static_cast says:</p>\n<blockquote>\n<p id=\"so_1243962_1244346_0\">An expression e can be explicitly converted to a type T using a <code>static_cast</code> of the form\n  <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>\"T t(e);\"</code> is well-formed, for some invented temporary variable\n  t (8.5)</p>\n</blockquote>\n<p>So the semantics for the cast are the same as for:</p>\n<pre><code>UCList tmp (mc);\n</code></pre>\n<p>From 13.3.1.3 we get the set of candidate constructors that we can use in <code>UCList</code>:</p>\n<pre><code>UCList (UCList const &amp;)              #1\nUCList (size_type, T const &amp; = T()); #2\n</code></pre>\n<p>What happens next is two separate overload resolution steps, one for each conversion operator.</p>\n<p><strong>Converting to #1:</strong>  With a target type of <code>UCList const &amp;</code>, overload resolution selects between the following conversion operators.:  \"<code>operator UCList const ()</code>\" and \"<code>operator unsigned char ()</code>\".  Using <code>unsigned char</code> would require an additional user conversion and so is not a viable function for this overload step.  Therefore overload resolution succeeds and will use <code>operator UCList const ()</code>.</p>\n<p><strong>Converting to #2:</strong>  With a target type of <code>size_t</code>.  The default argument does not take part in overload resolution.  Overload resolution again selects between the conversion operators:  \"<code>operator UCList const ()</code>\" and \"<code>operator unsigned char ()</code>\".  This time there is no conversion from <code>UCList</code> to <code>unsigned int</code> and so that is not a viable function.  An <code>unsigned char</code> can be promoted to <code>size_t</code> and so this time overload resolution succeeds and will use \"<code>operator UCList const ()</code>\".</p>\n<p>But, now back at the top level there are two separate and independent overload resolution steps that have successfully converted from <code>mc</code> to <code>UCList</code>.  The result is therefore ambiguous.</p>\n<p>To explain that last point, this example is different to the normal overload resolution case.  Normally there is a 1:n relationship between argument and parameter types:</p>\n<pre><code>void foo (char);\nvoid foo (short);\nvoid foo (int);\n\nvoid bar() {\n  int i;\n  foo (i);\n}\n</code></pre>\n<p>Here there is <code>i=&gt;char</code>, <code>i=&gt;short</code> and <code>i=&gt;int</code>.  These are compared by overload resolution and the <code>int</code> overload would be selected.</p>\n<p>In the above case we have an m:n relationship.  The standard outlines the rules to select for each individual argument and all of the 'n' parameters, but that's where it ends, it does not specify how we should decide between using the different 'm' arguments.</p>\n<p>Hope this makes some sense!</p>\n<p><strong>UPDATE:</strong></p>\n<p>The two kinds of initialization syntax here are:</p>\n<pre><code>UCList t1 (mc);\nUCList t2 = mc;\n</code></pre>\n<p>'t1' is a  direct initialiation (13.3.1.3) and <em>all</em> constructors are included in the overload set.  This is almost like having more than one user defined conversion.  There are the set of constructors <em>and</em> the set of conversion operators.  (ie. m:n).</p>\n<p>In the case of 't2' the syntax uses copy-initialization (13.3.1.4) and the rules different:</p>\n<blockquote>\n<p id=\"so_1243962_1244346_1\">Under the conditions specified in 8.5, as part of a copy-initialization of an object of class type, a userdefined\n  conversion can be invoked to convert an initializer expression to the type of the object being initialized.\n  Overload resolution is used to select the user-defined conversion to be invoked</p>\n</blockquote>\n<p>In this case there is just one to type, <code>UCList</code>, and so there is only the set of conversion operator overloads to consider, ie. we do not consider the other constructors of UCList.</p>\n", "LastEditorUserId": "11698", "LastActivityDate": "2009-08-07T14:50:01.020", "Score": "2", "CreationDate": "2009-08-07T11:57:11.917", "ParentId": "1243962", "CommentCount": "4", "OwnerUserId": "11698", "LastEditDate": "2009-08-07T14:50:01.020"}, "1243962": {"ViewCount": "3766", "Body": "<p>While porting Windows code to Linux, I encountered the following error message with GCC 4.2.3. (Yes, I'm aware that it's a slight old version, but I can't easily upgrade.)</p>\n<pre><code>main.cpp:16: error: call of overloaded \u2018list(MyClass&amp;)\u2019 is ambiguous\n/usr/include/c++/4.2/bits/stl_list.h:495: note: candidates are: std::list&lt;_Tp, _Alloc&gt;::list(const std::list&lt;_Tp, _Alloc&gt;&amp;) [with _Tp = unsigned char, _Alloc = std::allocator&lt;unsigned char&gt;]\n/usr/include/c++/4.2/bits/stl_list.h:484: note:                 std::list&lt;_Tp, _Alloc&gt;::list(size_t, const _Tp&amp;, const _Alloc&amp;) [with _Tp = unsigned char, _Alloc = std::allocator&lt;unsigned char&gt;]\n</code></pre>\n<p>I'm using the following code to generate this error. </p>\n<pre><code>#include &lt;list&gt;\nclass MyClass\n    {\n    public:\n        MyClass(){}\n\n        operator std::list&lt;unsigned char&gt;() const { std::list&lt;unsigned char&gt; a; return a; }\n        operator unsigned char() const { unsigned char a; return a; }\n\n    };\n\n    int main()\n    {\n        MyClass a;\n        std::list&lt;unsigned char&gt; b = (std::list&lt;unsigned char&gt;)a;\n\n        return 0;\n    }\n</code></pre>\n<p>Has anyone experienced this error?  More importantly, how to get around it? (It's possible to completely avoid the overload, sure, by using functions such as <code>GetChar()</code>, <code>GetList()</code> etc, but I'd like to avoid that.)</p>\n<p>(By the way, removing \"<code>operator unsigned char()</code>\" removes the error.)</p>\n", "AcceptedAnswerId": "1243998", "Title": "C++ Operator overloading - casting from class", "CreationDate": "2009-08-07T10:04:59.537", "Id": "1243962", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-12-11T17:41:29.893", "LastEditorUserId": "963864", "LastActivityDate": "2011-12-11T17:41:29.893", "Score": "2", "OwnerUserId": "149813", "Tags": "<c++><gcc><operators><operator-overloading><operator-keyword>", "AnswerCount": "3"}, "1244136": {"Id": "1244136", "PostTypeId": "2", "Body": "<p>The ambiguity comes from the interpretation of the <em>cast-expression</em>.</p>\n<p>When choosing the conversion, the compiler first considers a <code>static_cast</code> style cast and considers how to resolve an initialization which looks like this:</p>\n<pre><code>std::list&lt;unsigned_char&gt; tmp( a );\n</code></pre>\n<p>This construction is ambiguous as <code>a</code> has a user-defined conversion to a <code>std::list&lt;unsigned char&gt;</code> and to an <code>unsigned char</code> and <code>std::list&lt;unsigned char&gt;</code> has both a constructor which takes a <code>const std::list&lt;unsigned char&gt;&amp;</code> and a constructor which takes  <code>size_t</code> (to which an <code>unsigned char</code> can be promoted).</p>\n<p>When casting to a <code>const std::list&lt;unsigned_char&gt;&amp;</code>, this initialization is considered:</p>\n<pre><code>const std::list&lt;unsigned_char&gt;&amp; tmp( a );\n</code></pre>\n<p>In this case, when the user-defined conversion to <code>std::list&lt;unsigned_char&gt;</code> is chosen, the new reference can bind directly to the result of the conversion. If the user-defined conversion to <code>unsigned char</code> where chosen a temporary object of type <code>std::list&lt;unsigned char&gt;</code> would have to be created and this makes this option a worse conversion sequence than the former option.</p>\n", "LastActivityDate": "2009-08-07T10:55:59.467", "CommentCount": "0", "CreationDate": "2009-08-07T10:55:59.467", "ParentId": "1243962", "Score": "6", "OwnerUserId": "19563"}, "1243998": {"Id": "1243998", "PostTypeId": "2", "Body": "<p>It compiles properly if you remove the cast, and I've checked that the operator std::list is being executed.</p>\n<pre><code>int main()\n{\n    MyClass a;\n    std::list&lt;unsigned char&gt; b = a;\n\n    return 0;\n}\n</code></pre>\n<p>Or if you cast it to a const reference.</p>\n<pre><code>    int main()\n    {\n        MyClass a;\n        std::list&lt;unsigned char&gt; b = (const std::list&lt;unsigned char&gt;&amp;)a;\n\n        return 0;\n     }\n</code></pre>\n", "LastEditorUserId": "78667", "LastActivityDate": "2009-08-07T10:21:20.470", "Score": "1", "CreationDate": "2009-08-07T10:15:49.280", "ParentId": "1243962", "CommentCount": "6", "OwnerUserId": "78667", "LastEditDate": "2009-08-07T10:21:20.470"}});