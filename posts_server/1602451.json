post_cb({"34602177": {"ParentId": "1602451", "CommentCount": "1", "Body": "<p>Since C++98, the C++ standard library provides class valarray&lt;&gt; for processing arrays of numeric\nvalues. A valarray is a representation of the mathematical concept of a linear sequence of values.\nIt has one dimension, but you can get the illusion of higher dimensionality by special techniques\nof computed indices and powerful subsetting capabilities. Therefore, a valarray can be used as a\nbase both for vector and matrix operations and for processing mathematical systems of polynomial\nequations with good performance.\nThe valarray classes enable some tricky optimizations to get good performance for the processing\nof value arrays. However, it is not clear how important this component of the C++ standard library\nwill be in the future, because other interesting developments perform even better. One of the most\ninteresting examples is the Blitz system. If you are interested in numeric processing, you should\nlook at it. \nThe valarray classes were not designed very well. In fact, nobody tried to determine whether the\nfinal specification worked. This happened because nobody felt \u201cresponsible\u201d for these classes. The\npeople who introduced valarrays to the C++ standard library left the committee long before the first\nC++ standard was finished. For example, to use valarrays, you often need some inconvenient and\ntime-consuming type conversions.</p>\n", "OwnerUserId": "1548486", "PostTypeId": "2", "Id": "34602177", "Score": "-3", "CreationDate": "2016-01-05T00:09:22.830", "LastActivityDate": "2016-01-05T00:09:22.830"}, "1602594": {"ParentId": "1602451", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Valarrays (value arrays) are intended to bring some of the speed of Fortran to C++. You wouldn't make a valarray of pointers so the compiler can make assumptions about the code and optimise it better. (The main reason that Fortran is so fast is that there is no pointer type so there can be no pointer aliasing.)</p>\n<p>Valarrays also have classes which allow you to slice them up in a reasonably easy way although that part of the standard could use a bit more work. Resizing them is destructive and they lack iterators.</p>\n<p>So, if it's numbers you are working with and convenience isn't all that important use valarrays. Otherwise, vectors are just a lot more convenient.</p>\n", "OwnerUserId": "177999", "LastEditorUserId": "415784", "LastEditDate": "2012-01-24T05:26:45.717", "Id": "1602594", "Score": "58", "CreationDate": "2009-10-21T18:14:13.367", "LastActivityDate": "2012-01-24T05:26:45.717"}, "1603055": {"ParentId": "1602451", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_1602451_1603055_0\">I know valarrays have some syntactic sugar</p>\n</blockquote>\n<p>I have to say that I don't think <code>std::valarrays</code> have much in way of syntactic sugar.  The syntax is different, but I wouldn't call the difference \"sugar.\"  The API is weird.  The section on <code>std::valarray</code>s in <em>The C++ Programming Language</em> mentions this unusual API and the fact that since <code>std::valarray</code>s are expected to be highly optimized, any error messages you get while using them will probably be non-intuitive.</p>\n<p>Out of curiosity, about a year ago I pitted <code>std::valarray</code> against <code>std::vector</code>.  I no longer have the code or the precise results (although it shouldn't be hard to write your own).  Using GCC I <em>did</em> get a little performance benefit when using <code>std::valarray</code> for simple math, but not for my implementations to calculate standard deviation (and, of course, standard deviation isn't that complex, as far as math goes).  <strike>I suspect that operations on each item in a large <code>std::vector</code> play better with caches than operations on <code>std::valarray</code>s.</strike> (<strong>NOTE</strong>, following advice from <a href=\"https://stackoverflow.com/users/424632/musiphil\">musiphil</a>, I've managed to get almost identical performance from <code>vector</code> and <code>valarray</code>).</p>\n<p>In the end, I decided to use <code>std::vector</code> while paying close attention to things like memory allocation and temporary object creation.</p>\n<hr>\n<p>Both <code>std::vector</code> and <code>std::valarray</code> store the data in a contiguous block.  However, they access that data using different patterns, and more importantly, the API for <code>std::valarray</code> encourages different access patterns than the API for <code>std::vector</code>.</p>\n<p>For the standard deviation example, at a particular step I needed to find the collection's mean and the difference between each element's value and the mean.</p>\n<p>For the <code>std::valarray</code>, I did something like:</p>\n<pre><code>std::valarray&lt;double&gt; original_values = ... // obviously I put something here\ndouble mean = original_values.sum() / original_values.size();\nstd::valarray&lt;double&gt; temp(mean, original_values.size());\nstd::valarray&lt;double&gt; differences_from_mean = original_values - temp;\n</code></pre>\n<p>I may have been more clever with <code>std::slice</code> or <code>std::gslice</code>.  It's been over five years now.</p>\n<p>For <code>std::vector</code>, I did something along the lines of:</p>\n<pre><code>std::vector&lt;double&gt; original_values = ... // obviously, I put something here\ndouble mean = std::accumulate(original_values.begin(), original_values.end(), 0.0) / original_values.size();\n\nstd::vector&lt;double&gt; differences_from_mean;\ndifferences_from_mean.reserve(original_values.size());\nstd::transform(original_values.begin(), original_values.end(), std::back_inserter(differences_from_mean), std::bind1st(std::minus&lt;double&gt;(), mean));\n</code></pre>\n<p>Today I would certainly write that differently.  If nothing else, I would take advantage of C++11 lambdas.</p>\n<p>It's obvious that these two snippets of code do different things.  For one, the <code>std::vector</code> example doesn't make an intermediate collection like the <code>std::valarray</code> example does.  However, I think it's fair to compare them because the differences are tied to the differences between <code>std::vector</code> and <code>std::valarray</code>.</p>\n<p>When I wrote this answer, I suspected that subtracting the value of elements from two <code>std::valarray</code>s (last line in the <code>std::valarray</code> example) would be less cache-friendly than the corresponding line in the <code>std::vector</code> example (which happens to also be the last line).</p>\n<p>It turns out, however, that</p>\n<pre><code>std::valarray&lt;double&gt; original_values = ... // obviously I put something here\ndouble mean = original_values.sum() / original_values.size();\nstd::valarray&lt;double&gt; differences_from_mean = original_values - mean;\n</code></pre>\n<p>Does the same thing as the <code>std::vector</code> example, and has almost identical performance.  In the end, the question is which API you prefer.</p>\n</hr>", "OwnerUserId": "10593", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:19.920", "Id": "1603055", "Score": "22", "CreationDate": "2009-10-21T19:27:59.550", "LastActivityDate": "2013-03-27T23:37:26.283"}, "1602691": {"ParentId": "1602451", "CommentCount": "3", "Body": "<p>During the standardization of C++98, valarray was designed to allow some sort of fast mathematical computations. However, around that time Todd Veldhuizen invented expression templates and created <a href=\"http://www.oonumerics.org/blitz/\" rel=\"noreferrer\">blitz++</a>, and similar template-meta techniques were invented, which made valarrays pretty much obsolete before the standard was even released. IIRC, the original proposer(s) of valarray abandoned it halfway into the standardization, which (if true) didn't help it either. </p>\n<p>ISTR that the main reason it wasn't removed from the standard is that nobody took the time to evaluate the issue thoroughly and write a proposal to remove it. </p>\n<p><em>Please keep in mind, however, that all this is vaguely remembered hearsay.</em> Take this with a grain of salt and hope someone corrects or confirms this. </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "1602691", "Score": "33", "CreationDate": "2009-10-21T18:29:23.397", "LastActivityDate": "2009-10-21T18:29:23.397"}, "1602451": {"CommentCount": "3", "AcceptedAnswerId": "1602594", "PostTypeId": "1", "LastEditorUserId": "2411320", "CreationDate": "2009-10-21T17:53:31.017", "LastActivityDate": "2017-11-08T02:08:57.093", "LastEditDate": "2016-07-22T19:21:39.550", "ViewCount": "36310", "FavoriteCount": "39", "Title": "C++ valarray vs. vector", "Id": "1602451", "Score": "126", "Body": "<p>I like vectors a lot. They're nifty and fast. But I know this thing called a valarray exists. Why would I use a valarray instead of a vector? I know valarrays have some syntactic sugar, but other than that, when are they useful?</p>\n", "Tags": "<c++><stl><stdvector><c++-standard-library><valarray>", "OwnerUserId": "72631", "AnswerCount": "8"}, "1602731": {"ParentId": "1602451", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>valarray was supposed to let some FORTRAN vector-processing goodness rub off on C++.  Somehow the necessary compiler support never really happened.</p>\n<p>The  Josuttis books contains some interesting (somewhat disparaging) commentary on valarray (<a href=\"http://books.google.co.uk/books?id=n9VEG2Gp5pkC&amp;lpg=PA547&amp;ots=Rdj8kmcaTT&amp;dq=Josuttis%20valarray&amp;pg=PA547#v=onepage&amp;q=&amp;f=false\" rel=\"noreferrer\">here</a> and <a href=\"http://books.google.co.uk/books?id=EotSAwuBkJoC&amp;lpg=PA342&amp;ots=iwL1E65kdd&amp;dq=Josuttis%20valarray&amp;pg=PA342#v=onepage&amp;q=&amp;f=false\" rel=\"noreferrer\">here</a>).</p>\n<p>However, Intel now seem to be revisiting valarray in their recent compiler releases (e.g see <a href=\"http://sc.tamu.edu/help/intel/tutorial/compiler_2.pdf\" rel=\"noreferrer\">slide 9</a>); this is an interesting development given that their 4-way SIMD SSE instruction set is about to be joined by 8-way AVX and 16-way Larrabee instructions and in the interests of portability it'll likely be much better to code with an abstraction like valarray than (say) intrinsics.</p>\n", "OwnerUserId": "24283", "LastEditorUserId": "24283", "LastEditDate": "2013-03-27T08:34:22.470", "Id": "1602731", "Score": "22", "CreationDate": "2009-10-21T18:35:27.827", "LastActivityDate": "2013-03-27T08:34:22.470"}, "1602787": {"ParentId": "1602451", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>valarray is kind of an orphan that was born in the wrong place at the wrong time. It's an attempt at optimization, fairly specifically for the machines that were used for heavy-duty math when it was written -- specifically, vector processors like the Crays.</p>\n<p>For a vector processor, what you generally wanted to do was apply a single operation to an entire array, then apply the next operation to the entire array, and so on until you'd done everything you needed to do. </p>\n<p>Unless you're dealing with fairly small arrays, however, that tends to work poorly with caching. On most modern machines, what you'd generally prefer (to the extent possible) would be to load part of the array, do all the operations on it you're going to, then move on to the next part of the array.</p>\n<p>valarray is also supposed to eliminate any possibility of aliasing, which (at least theoretically) lets the compiler improve speed because it's more free to store values in registers. In reality, however, I'm not at all sure that any real implementation takes advantage of this to any significant degree. I suspect it's rather a chicken-and-egg sort of problem -- without compiler support it didn't become popular, and as long as it's not popular, nobody's going to go to the trouble of working on their compiler to support it.</p>\n<p>There's also a bewildering (literally) array of ancillary classes to use with valarray. You get slice, slice_array, gslice and gslice_array to play with pieces of a valarray, and make it act like a multi-dimensional array. You also get mask_array to \"mask\" an operation (e.g. add items in x to y, but only at the positions where z is non-zero). To make more than trivial use of valarray, you have to learn a lot about these ancillary classes, some of which are pretty complex and none of which seems (at least to me) very well documented.</p>\n<p>Bottom line: while it has moments of brilliance, and can do some things pretty neatly, there are also some very good reasons that it is (and will almost certainly remain) obscure.</p>\n<p>Edit (eight years later, in 2017): Some of the preceding has become obsolete to at least some degree. For one example, Intel has implemented an optimized version of valarray for their compiler. It uses the Intel Integrated Performance Primitives (Intel IPP) to improve performance. Although the exact performance improvement undoubtedly varies, a quick test with simple code shows around a 2:1 improvement in speed, compared to identical code compiled with the \"standard\" implementation of <code>valarray</code>.</p>\n<p>So, while I'm not entirely convinced that C++ programmers will be starting to use <code>valarray</code> in huge numbers, there are least some circumstances in which it can provide a speed improvement.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2017-11-08T02:08:57.093", "Id": "1602787", "Score": "111", "CreationDate": "2009-10-21T18:44:31.947", "LastActivityDate": "2017-11-08T02:08:57.093"}, "10640258": {"ParentId": "1602451", "CommentCount": "1", "Body": "<p>The C++11 standard says:</p>\n<blockquote>\n<p id=\"so_1602451_10640258_0\">The valarray array classes are defined to be free of certain forms of\n  aliasing, thus allowing operations on these classes to be optimized.</p>\n</blockquote>\n<p>See C++11 26.6.1-2.</p>\n", "OwnerUserId": "1348273", "PostTypeId": "2", "Id": "10640258", "Score": "7", "CreationDate": "2012-05-17T17:10:02.473", "LastActivityDate": "2012-05-17T17:10:02.473"}, "44482550": {"ParentId": "1602451", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I found one good usage for valarray.\nIt's to use valarray just like numpy arrays.</p>\n<pre><code>auto x = linspace(0, 2 * 3.14, 100);\nplot(x, sin(x) + sin(3.f * x) / 3.f + sin(5.f * x) / 5.f);\n</code></pre>\n<p><a href=\"https://i.stack.imgur.com/Q799S.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/Q799S.png\"/></a></p>\n<p>We can implement above with valarray.</p>\n<pre><code>valarray&lt;float&gt; linspace(float start, float stop, int size)\n{\n    valarray&lt;float&gt; v(size);\n    for(int i=0; i&lt;size; i++) v[i] = start + i * (stop-start)/size;\n    return v;\n}\n\nstd::valarray&lt;float&gt; arange(float start, float step, float stop)\n{\n    int size = (stop - start) / step;\n    valarray&lt;float&gt; v(size);\n    for(int i=0; i&lt;size; i++) v[i] = start + step * i;\n    return v;\n}\n\nstring psstm(string command)\n{//return system call output as string\n    string s;\n    char tmp[1000];\n    FILE* f = popen(command.c_str(), \"r\");\n    while(fgets(tmp, sizeof(tmp), f)) s += tmp;\n    pclose(f);\n    return s;\n}\n\nstring plot(const valarray&lt;float&gt;&amp; x, const valarray&lt;float&gt;&amp; y)\n{\n    int sz = x.size();\n    assert(sz == y.size());\n    int bytes = sz * sizeof(float) * 2;\n    const char* name = \"plot1\";\n    int shm_fd = shm_open(name, O_CREAT | O_RDWR, 0666);\n    ftruncate(shm_fd, bytes);\n    float* ptr = (float*)mmap(0, bytes, PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    for(int i=0; i&lt;sz; i++) {\n        *ptr++ = x[i];\n        *ptr++ = y[i];\n    }\n\n    string command = \"python plot.py \";\n    string s = psstm(command + to_string(sz));\n    shm_unlink(name);\n    return s;\n}\n</code></pre>\n<p>Also, we need python script.</p>\n<pre><code>import sys, posix_ipc, os, struct\nimport matplotlib.pyplot as plt\n\nsz = int(sys.argv[1])\nf = posix_ipc.SharedMemory(\"plot1\")\nx = [0] * sz\ny = [0] * sz\nfor i in range(sz):\n    x[i], y[i] = struct.unpack('ff', os.read(f.fd, 8))\nos.close(f.fd)\nplt.plot(x, y)\nplt.show()\n</code></pre>\n", "OwnerUserId": "6626185", "LastEditorUserId": "6626185", "LastEditDate": "2017-06-11T10:13:16.097", "Id": "44482550", "Score": "4", "CreationDate": "2017-06-11T10:02:08.040", "LastActivityDate": "2017-06-11T10:13:16.097"}, "bq_ids": {"n4140": {"so_1602451_10640258_0": {"section_id": 3730, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_1602451_10640258_0": {"section_id": 3592, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_1602451_10640258_0": {"section_id": 4497, "quality": 0.9285714285714286, "length": 13}}}});