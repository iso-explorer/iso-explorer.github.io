post_cb({"31831724": {"CommentCount": "5", "Body": "<p>From [class.inhctor]:</p>\n<blockquote>\n<p id=\"so_31830780_31831724_0\">The\n  candidate set of inherited constructors from the class X named in the using-declaration consists of actual\n  constructors and notional constructors that result from the transformation of defaulted parameters and\n  ellipsis parameter specifications as follows:<br>\n  \u2014 [...]<br>\n  \u2014 for each non-template constructor of X that has at least one parameter with a default argument, the set\n  of constructors that results from omitting any ellipsis parameter specification and <strong>successively omitting\n  parameters with a default argument</strong> from the end of the parameter-type-list, and<br>\n  \u2014 [...]</br></br></br></p>\n</blockquote>\n<p>We have two non-template constructors of <code>Base</code>. The default constructor of <code>Base</code> introduces the candidate:</p>\n<pre><code>Derived() : Base() { }\n</code></pre>\n<p>And the other constructor of <code>Base</code> introduces one candidate for each successively omitted parameter. Namely:</p>\n<pre><code>Derived(int x, int y, int z) : Base(x, y, z) { }\nDerived(int x, int y)        : Base(x, y) { }\nDerived(int x)               : Base(x) { }\n</code></pre>\n<p>The default arguments are <strong>not</strong> inherited - we just get a different constructor for each number of arguments. So <code>Derived(5)</code> simply calls <code>Base(5)</code>, not <code>Base(5, 88, 99)</code>. </p>\n<p>The end result is the same - just how we get there is a bit different. </p>\n", "CreationDate": "2015-08-05T11:51:18.377", "ParentId": "31830780", "Id": "31831724", "LastActivityDate": "2015-08-05T11:51:18.377", "PostTypeId": "2", "Score": "6", "OwnerUserId": "2069064"}, "31831513": {"LastActivityDate": "2015-08-05T11:57:54.460", "CommentCount": "4", "Body": "<p>Your quote from the book is not full.</p>\n<blockquote>\n<p id=\"so_31830780_31831513_0\">If a base-class constructor has default arguments (\u00a76.5.1, p. 236), those arguments\n  are not inherited. Instead, the derived class gets multiple inherited constructors in\n  which each parameter with a default argument is successively omitted. For example, if\n  the base has a constructor with two parameters, the second of which has a default,\n  the derived class will obtain two constructors: one with both parameters (and no\n  default argument) and a second constructor with a single parameter corresponding to\n  the left-most, non-defaulted parameter in the base class</p>\n</blockquote>\n<p>So your Derived class will have 3 inherited constructors with signatures:</p>\n<pre><code>Derived (int x): Base{x} {}\nDerived (int x, int y): Base{x, y} {}\nDerived (int x, int y, int z): Base{x, y, z} {}\n</code></pre>\n<p>And so you are <strong>not</strong> inheriting any default arguments from base class.</p>\n<pre><code>Derived D(5);\n</code></pre>\n<p>calls the first of above three constructors and base constructor is called like</p>\n<pre><code>Base(5)\n</code></pre>\n<blockquote>\n<p id=\"so_31830780_31831513_1\">Also note that the default, copy, and move constructors are not\n  inherited. These constructors are synthesized using the normal rules. An inherited\n  constructor is not treated as a user-defined constructor. Therefore, a class that\n  contains only inherited constructors will have a synthesized default constructor.</p>\n</blockquote>\n", "CreationDate": "2015-08-05T11:41:19.403", "LastEditDate": "2015-08-05T11:57:54.460", "ParentId": "31830780", "Id": "31831513", "LastEditorUserId": "4712648", "PostTypeId": "2", "Score": "8", "OwnerUserId": "4712648"}, "31830780": {"CreationDate": "2015-08-05T11:07:44.717", "ViewCount": "354", "Id": "31830780", "AcceptedAnswerId": "31831724", "Score": "7", "Title": "Inheriting constructors w / wo their default arguments?", "LastEditorUserId": "2756719", "CommentCount": "0", "Body": "<p>C++ Primer (5th edition) on page 629 states:</p>\n<ul>\n<li>If a base class constructor has default arguments, those arguments are not inherited. </li>\n</ul>\n<p>I tried this for myself and to me it seems that the derived constructor generated by the compiler also has the same default arguments as the base constructor.\n<br><br>Here's a little test:</br></br></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base\n{\n    Base() = default;\n\n    Base(int x_, int y_ = 88, int z_ = 99)\n        : x(x_), y(y_), z(z_) {}\n\n    virtual void debug() const \n    { std::cout &lt;&lt; \"\\nx - \" &lt;&lt; x &lt;&lt; \", y - \" &lt;&lt; y &lt;&lt; \", z - \" &lt;&lt; z &lt;&lt; '\\n'; } \n\nprivate:\n    int x, y, z;\n};\n\nstruct Derived : Base\n{\n    using Base::Base;\n};\n\nint main() {\n    Base B(1);\n    B.debug();         // x - 1, y - 88, z - 99\n    Derived D(5);\n    D.debug();         // x - 5, y - 88, z - 99\n\n    return 0;\n}\n</code></pre>\n<p>( You can run this here - <a href=\"http://coliru.stacked-crooked.com/a/26cbb85757c1f021\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/26cbb85757c1f021</a> )</p>\n<p><br>So are we inheriting also the default arguments for a inherited constructor or not?\n<br>If not, how come I'm not getting junk for the last 2 members but the same exact values as the default argumuments for the constructor inherited from base?\n<br>\nAlso searched on the internet for a clear response about this but found none.</br></br></br></p>\n", "Tags": "<c++><c++11><inheritance><constructor><default-arguments>", "LastEditDate": "2015-08-05T22:54:17.897", "LastActivityDate": "2015-08-05T22:54:17.897", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "4249825"}, "bq_ids": {"n4140": {"so_31830780_31831724_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 482}}, "n3337": {"so_31830780_31831724_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 473}}}});