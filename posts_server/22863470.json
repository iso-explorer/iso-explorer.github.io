post_cb({"22864737": {"ParentId": "22863470", "CommentCount": "3", "CreationDate": "2014-04-04T13:50:44.900", "PostTypeId": "2", "Id": "22864737", "Score": "1", "Body": "<p>Looks like it up-casts the 16 bit integer to match the pointer size.\nRunning the following code outputs <code>\"upcast\"</code></p>\n<pre><code>uint16_t a = 1;\nvoid* b = (void*)0x10001;\n(b == a) ? printf(\"downcast\") : printf(\"upcast\");\n</code></pre>\n", "OwnerUserId": "2245909", "LastActivityDate": "2014-04-04T13:50:44.900"}, "22863470": {"CommentCount": "2", "AcceptedAnswerId": "22864737", "LastEditDate": "2014-04-04T13:44:58.720", "LastEditorUserId": "133374", "LastActivityDate": "2014-04-04T13:50:44.900", "Body": "<p>In some legacy code, which compiles fine on GCC 4.6 (with <code>-fpermissive</code>), I have this:</p>\n<pre><code>uint16_t a = 0;\nvoid* b = ...;\n\nif(b == a) // ...\n</code></pre>\n<p>Is this comparison well-defined on GCC 4.6? Does it downcast to 16 bits or upcast to 32/64 bits?</p>\n", "PostTypeId": "1", "ViewCount": "210", "Title": "compare void* with uint16_t", "Id": "22863470", "Score": "2", "CreationDate": "2014-04-04T12:55:22.510", "Tags": "<c++><gcc><gcc4.6>", "OwnerUserId": "133374", "AnswerCount": "3"}, "22864218": {"ParentId": "22863470", "CommentCount": "0", "CreationDate": "2014-04-04T13:29:10.627", "PostTypeId": "2", "Id": "22864218", "Score": "0", "Body": "<p>It may compile or may not (not sure, it depends on the compiler and compiler options)\nIn any case the cast will be performed like:</p>\n<pre><code>if( b == (void*)a )\n{\n}\n</code></pre>\n<p>Note that upcasting/downcasting is not the correct word to use because it is related to classes, in this case is just type conversions.</p>\n", "OwnerUserId": "3274630", "LastActivityDate": "2014-04-04T13:29:10.627"}, "22864029": {"ParentId": "22863470", "CommentCount": "3", "CreationDate": "2014-04-04T13:21:14.677", "PostTypeId": "2", "Id": "22864029", "Score": "1", "Body": "<p>Although this isn't explicitly written in the C++11 standard (N3337 draft), I was able to come up with this (emphasis mine).</p>\n<blockquote>\n<p id=\"so_22863470_22864029_0\"><strong>\u00a75.9 Relational operators</strong></p>\n<p id=\"so_22863470_22864029_1\">Pointers to objects or functions <em>of the same type</em> (after pointer conversions) can be compared, with a result defined as follows</p>\n<p id=\"so_22863470_22864029_2\">\u2014 If two pointers ...</p>\n<p id=\"so_22863470_22864029_3\">\u2014 If two pointers ...</p>\n<p id=\"so_22863470_22864029_4\">\u2014 If two pointers ...</p>\n<p id=\"so_22863470_22864029_5\">\u2014 If two pointers ...</p>\n<p id=\"so_22863470_22864029_6\">\u2014 If two pointers ...</p>\n<p id=\"so_22863470_22864029_7\">\u2014 <em>Other pointer comparisons are unspecified.</em></p>\n</blockquote>\n<p>Now for the equality part:</p>\n<blockquote>\n<p id=\"so_22863470_22864029_8\"><strong>\u00a75.10 Equality operators</strong></p>\n<p id=\"so_22863470_22864029_9\">The == (equal to) and the != (not equal to) operators <em>have the same semantic restrictions, conversions, and result type as the relational operators</em> except for their lower precedence and truth-value result.</p>\n</blockquote>\n<p>By this I believe that <em>such a comparison is unspecified</em>.</p>\n", "OwnerUserId": "183120", "LastActivityDate": "2014-04-04T13:21:14.677"}, "bq_ids": {"n3337": {"so_22863470_22864029_7": {"section_id": 5913, "quality": 1.0, "length": 4}, "so_22863470_22864029_1": {"section_id": 5913, "quality": 1.0, "length": 13}, "so_22863470_22864029_9": {"section_id": 5917, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_22863470_22864029_1": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}}}});