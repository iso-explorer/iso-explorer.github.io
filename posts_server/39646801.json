post_cb({"39648025": {"Id": "39648025", "PostTypeId": "2", "Body": "<p>Your question really has 2 parts:</p>\n<ol>\n<li>Should I use <code>static_cast</code> or <code>reinterpret_cast</code> to work with a pointer to the underlying bit pattern of an object without concern for the object type?</li>\n<li>If I should use <code>reinterpret_cast</code> is a <code>void*</code> or a <code>char*</code> preferable to address this underlying bit pattern?</li>\n</ol>\n<blockquote>\n<p id=\"so_39646801_39648025_0\"><a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow noreferrer\"><code>static_cast</code></a>: Converts between types using a combination of implicit and user-defined conversions</p>\n</blockquote>\n<p>In 5.2.9[expr.static.cast]13 the standard, in fact, gives the example:</p>\n<pre><code>T* p1 = new T;\nconst T* p2 = static_cast&lt;const T*&gt;(static_cast&lt;void*&gt;(p1));\n</code></pre>\n<p>It leverages the implicit cast:</p>\n<blockquote>\n<p id=\"so_39646801_39648025_1\">A prvalue pointer to any (optionally cv-qualified) object type <code>T</code> can be converted to a prvalue pointer to (identically cv-qualified) <code>void</code>. The resulting pointer represents the same location in memory as the original pointer value. If the original pointer is a null pointer value, the result is a null pointer value of the destination type.<sup><a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion#Pointer_conversions\" rel=\"nofollow noreferrer\">*</a></sup></p>\n</blockquote>\n<p>There is however no implicit cast from a pointer of type <code>T</code> to a <code>char*</code>. So the only way to accomplish that cast is with a <code>reinterpret_cast</code>.</p>\n<blockquote>\n<p id=\"so_39646801_39648025_2\"><a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\"><code>reinterpret_cast</code></a>: Converts between types by reinterpreting the underlying bit pattern</p>\n</blockquote>\n<p>So in answer to part <strong>1</strong> of your question when you cast to a <code>void*</code> or a <code>char*</code> you are looking to work with the underlying bit pattern, <strong><code>reinterpret_cast</code> should be used because it's use denotes to the reader a conversion to/from the underlying bit pattern.</strong></p>\n<p>Next let's compare <code>void*</code> to <code>char*</code>. The decision between these two may be a bit more application dependent. If you are going to use a standard library function with your underlying bit pattern just use the type that function accepts:</p>\n<ul>\n<li><code>void*</code> is used in the <code>mem</code> functions provided in the <code>cstring</code> library</li>\n<li><a href=\"http://en.cppreference.com/w/cpp/io/basic_istream/read\" rel=\"nofollow noreferrer\"><code>read</code></a> and <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/write\" rel=\"nofollow noreferrer\"><code>write</code></a> use <code>char*</code> as inputs</li>\n</ul>\n<p>It's notable that C++ specific libraries prefer <code>char*</code> for pointing to memory.\nHolding onto memory as a <code>void*</code> seems to have been preserved for compatibility reasons as pointer out <a href=\"https://stackoverflow.com/a/8530111/2642059\">here</a>. So if a <code>cstring</code> library function won't be used on your underlying bit patern, use the C++ specific libraries behavior to answer part <strong>2</strong> of your question: <strong>Prefer <code>char*</code> to <code>void*</code>.</strong></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-23T14:25:11.937", "Score": "0", "CreationDate": "2016-09-22T20:08:23.570", "ParentId": "39646801", "CommentCount": "0", "OwnerUserId": "2642059", "LastEditDate": "2017-05-23T11:48:33.470"}, "39647787": {"Id": "39647787", "PostTypeId": "2", "Body": "<p>Generally speaking, <code>static_cast</code> will do cast any two types if one of them can be cast to the other <em>implicitly</em>. That includes arithmetic casts, down-casts, up-casts and cast to and from <code>void*</code>.</p>\n<p>That is, if this cast is valid:</p>\n<pre><code>void foo(A a);\nB b;\nfoo(b);\n</code></pre>\n<p>Then the both <code>static_cast&lt;B&gt;(a)</code> and <code>static_cast&lt;A&gt;(b)</code> will also be valid.</p>\n<p>Since any pointer can be cast implicitly to <code>void*</code>, thus your peculiar behavior.</p>\n<p><code>reinterpret_cast</code> do cast by reinterpreting the bit-pattern of the values. That, as you said in the question, is usually done to convert between unrelated pointer types.</p>\n<p>Yes, you can convert between unrelated pointer types through <code>void*</code>, by using two <code>static_cast</code>:</p>\n<pre><code>B *b;\nA *a1 = static_cast&lt;A*&gt;(b); //compiler error\nA *a2 = static_cast&lt;A*&gt;(static_cast&lt;void*&gt;(b)); //it works (evil laugh)!\n</code></pre>\n<p>But that is bending the rules. Just use <code>reinterpret_cast</code> if you really need this.</p>\n", "LastActivityDate": "2016-09-22T19:52:47.733", "CommentCount": "0", "CreationDate": "2016-09-22T19:52:47.733", "ParentId": "39646801", "Score": "0", "OwnerUserId": "865874"}, "bq_ids": {"n4140": {"so_39646801_39648025_1": {"length": 24, "quality": 0.7058823529411765, "section_id": 40}}, "n3337": {"so_39646801_39648025_1": {"length": 19, "quality": 0.5588235294117647, "section_id": 37}}, "n4659": {"so_39646801_39648025_1": {"length": 18, "quality": 0.5294117647058824, "section_id": 43}}}, "39646801": {"ViewCount": "105", "Body": "<p>I know that <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\"><code>reinterpret_cast</code></a> is primarily used going to or from a <code>char*</code>.</p>\n<p>But I was surprised to find that <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow\"><code>static_cast</code></a> could do the same with a <code>void*</code>. For example:</p>\n<pre><code>auto foo \"hello world\"s;\nauto temp = static_cast&lt;void*&gt;(&amp;foo);\nauto bar = static_cast&lt;string*&gt;(temp);\n</code></pre>\n<p>What do we gain from using <code>reinterpret_cast</code> and <code>char*</code> over <code>static_cast</code> and <code>void*</code>? Is it something to do with the strict aliasing problem?</p>\n", "AcceptedAnswerId": "39648025", "Title": "Why can I use static_cast With void* but not With char*", "CreationDate": "2016-09-22T18:51:16.787", "Id": "39646801", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2016-09-23T14:25:11.937", "Score": "1", "OwnerUserId": "2642059", "Tags": "<c++><casting><reinterpret-cast><strict-aliasing><static-cast>", "AnswerCount": "2"}});