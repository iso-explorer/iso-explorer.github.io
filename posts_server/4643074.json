post_cb({"4643295": {"CommentCount": "13", "CreationDate": "2011-01-10T02:44:55.327", "CommunityOwnedDate": "2011-01-10T03:48:55.590", "LastEditorUserId": "13005", "LastActivityDate": "2011-01-10T11:59:56.233", "ParentId": "4643074", "PostTypeId": "2", "LastEditDate": "2011-01-10T11:59:56.233", "Id": "4643295", "Score": "166", "Body": "<p>Short answer: in order to make <code>x</code> a dependent name, so that lookup is deferred until the template parameter is known.</p>\n<p>Long answer: when a compiler sees a template, it is supposed to perform certain checks immediately, without seeing the template parameter. Others are deferred until the parameter is known. It's called two-phase compilation, and MSVC doesn't do it but it's required by the standard and implemented by the other major compilers. If you like, the compiler must compile the template as soon as it sees it (to some kind of internal parse tree representation), and defer compiling the instantiation until later.</p>\n<p>The checks that are performed on the template itself, rather than on particular instantiations of it, require that the compiler be able to resolve the grammar of the code in the template.</p>\n<p>In C++ (and C), in order to resolve the grammar of code, you sometimes need to know whether something is a type or not. For example:</p>\n<pre><code>#if WANT_POINTER\n    typedef int A;\n#else\n    int A;\n#endif\nstatic const int x = 2;\ntemplate &lt;typename T&gt; void foo() { A *x = 0; }\n</code></pre>\n<p>if A is a type, that declares a pointer (with no effect other than to shadow the global <code>x</code>). If A is an object, that's multiplication (and barring some operator overloading it's illegal, assigning to an rvalue). If it is wrong, this error must be diagnosed <em>in phase 1</em>, it's defined by the standard to be an error <em>in the template</em>, not in some particular instantiation of it. Even if the template is never instantiated, if A is an <code>int</code> then the above code is ill-formed and must be diagnosed, just as it would be if <code>foo</code> wasn't a template at all, but a plain function.</p>\n<p>Now, the standard says that names which <em>aren't</em> dependent on template parameters must be resolvable in phase 1. <code>A</code> here is not a dependent name, it refers to the same thing regardless of type <code>T</code>. So it needs to be defined before the template is defined in order to be found and checked in phase 1.</p>\n<p><code>T::A</code> would be a name that depends on T. We can't possibly know in phase 1 whether that's a type or not. The type which will eventually be used as <code>T</code> in an instantiation quite likely isn't even defined yet, and even if it was we don't know which type(s) will be used as our template parameter. But we have to resolve the grammar in order to do our precious phase 1 checks for ill-formed templates. So the standard has a rule for dependent names - the compiler must assume that they're non-types, unless qualified with <code>typename</code> to specify that they <em>are</em> types, or used in certain unambiguous contexts. For example in <code>template &lt;typename T&gt; struct Foo : T::A {};</code>, <code>T::A</code> is used as a base class and hence is unambiguously a type. If <code>Foo</code> is instantiated with some type that has a data member <code>A</code> instead of a nested type A, that's an error in the code doing the instantiation (phase 2), not an error in the template (phase 1).</p>\n<p>But what about a class template with a dependent base class?</p>\n<pre><code>template &lt;typename T&gt;\nstruct Foo : Bar&lt;T&gt; {\n    Foo() { A *x = 0; }\n};\n</code></pre>\n<p>Is A a dependent name or not? With base classes, <em>any</em> name could appear in the base class. So we could say that A is a dependent name, and treat it as a non-type. This would have the undesirable effect that <em>every name</em> in Foo is dependent, and hence <em>every type</em> used in Foo (except built-in types) has to be qualified. Inside of Foo, you'd have to write:</p>\n<pre><code>typename std::string s = \"hello, world\";\n</code></pre>\n<p>because <code>std::string</code> would be a dependent name, and hence assumed to be a non-type unless specified otherwise. Ouch!</p>\n<p>A second problem with allowing your preferred code (<code>return x;</code>) is that even if <code>Bar</code> is defined before <code>Foo</code>, and <code>x</code> isn't a member in that definition, someone could later define a specialization of <code>Bar</code> for some type <code>Baz</code>, such that <code>Bar&lt;Baz&gt;</code> does have a data member <code>x</code>, and then instantiate <code>Foo&lt;Baz&gt;</code>. So in that instantiation, your template would return the data member instead of returning the global <code>x</code>. Or conversely if the base template definition of <code>Bar</code> had <code>x</code>, they could define a specialization without it, and your template would look for a global <code>x</code> to return in <code>Foo&lt;Baz&gt;</code>. I think this was judged to be just as surprising and distressing as the problem you have, but it's <em>silently</em> surprising, as opposed to throwing a surprising error.</p>\n<p>To avoid these problems, the standard in effect says that dependent base classes of class templates just aren't searched for names unless the names are already dependent for some other reason. This stops everything from being dependent just because it could be found in a dependent base. It also has the undesirable effect that you're seeing - you have to qualify stuff from the base class or it's not found. There are three common ways to make <code>A</code> dependent:</p>\n<ul>\n<li><code>using Bar&lt;T&gt;::A;</code> in the class - <code>A</code> now refers to something in <code>Bar&lt;T&gt;</code>, hence dependent.</li>\n<li><code>Bar&lt;T&gt;::A *x = 0;</code> at point of use - Again, <code>A</code> is definitely in <code>Bar&lt;T&gt;</code>. This is multiplication since <code>typename</code> wasn't used, so possibly a bad example, but we'll have to wait until instantiation to find out whether <code>operator*(Bar&lt;T&gt;::A, x)</code> returns an rvalue. Who knows, maybe it does...</li>\n<li><code>this-&gt;A;</code> at point of use - <code>A</code> is a member, so if it's not in <code>Foo</code>, it must be in the base class, again the standard says this makes it dependent.</li>\n</ul>\n<p>Two-phase compilation is fiddly and difficult, and introduces some surprising requirements for extra verbiage in your code. But rather like democracy it's probably the worst possible way of doing things, apart from all the others.</p>\n<p>You could reasonably argue that in your example, <code>return x;</code> doesn't make sense if <code>x</code> is a nested type in the base class, so the language should (a) say that it's a dependent name and (2) treat it as a non-type, and your code would work without <code>this-&gt;</code>. To an extent you're the victim of collateral damage from the solution to a problem that doesn't apply in your case, but there's still the issue of your base class potentially introducing names under you that shadow globals, or not having names you thought they had, and a global being found instead.</p>\n<p>You could also possibly argue that the default should be the opposite for dependent names (assume type unless somehow specified to be an object), or that the default should be more context sensitive (in <code>std::string s = \"\";</code>, <code>std::string</code> could be read as a type since nothing else makes grammatical sense, even though <code>std::string *s = 0;</code> is ambiguous). Again, I don't know quite how the rules were agreed. My guess is that the number of pages of text that would be required, mitigated against creating a lot of specific rules for which contexts take a type and which a non-type.</p>\n", "OwnerUserId": "13005"}, "4643093": {"ParentId": "4643074", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><em><sup>(Original answer from Jan 10, 2011)</sup></em></p>\n<p>I think I have found the answer: <a href=\"https://stackoverflow.com/q/11405/341970\">GCC issue: using a member of a base class that depends on a template argument</a>.\nThe answer is not specific to gcc. </p>\n<hr>\n<p><strong>Update:</strong> In response to <a href=\"https://stackoverflow.com/questions/4643074/why-do-i-have-to-access-template-base-class-members-through-the-this-pointer/4643093?noredirect=1#comment41611012_4643093\">mmichael's comment</a>, from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft N3337</a> of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_4643074_4643093_0\"><strong>14.6.2 Dependent names [temp.dep]</strong><br>\n  [...]<br>\n  3  In the definition of a class or class template, if a base class depends on a \n  template-parameter, the base class scope is not examined during unqualified name \n  lookup either at the point of definition of the class template \n  or member or during an instantiation of the class template or member. </br></br></p>\n</blockquote>\n<p>Whether <em>\"because the standard says so\"</em> counts as an answer, I don't know. We can now ask why the standard mandates that but as <a href=\"https://stackoverflow.com/a/4643295/341970\">Steve Jessop's excellent answer</a> and others point out, the answer to this latter question is rather long and arguable. Unfortunately, when it comes to the C++ Standard, it is often nearly impossible to give a short and self-contained explanation as to why the standard mandates something; this applies to the latter question as well.</p>\n</hr>", "OwnerUserId": "341970", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:05.047", "Id": "4643093", "Score": "11", "CreationDate": "2011-01-10T01:48:04.480", "LastActivityDate": "2014-10-21T14:51:12.897"}, "4643091": {"ParentId": "4643074", "CommentCount": "1", "Body": "<p>The <code>x</code> is hidden during the inheritance. You can unhide via:</p>\n<pre><code>template &lt;typename T&gt;\nclass derived : public base&lt;T&gt; {\n\npublic:\n    using base&lt;T&gt;::x;             // added \"using\" statement\n    int f() { return x; }\n};\n</code></pre>\n", "OwnerUserId": "478288", "PostTypeId": "2", "Id": "4643091", "Score": "9", "CreationDate": "2011-01-10T01:47:52.123", "LastActivityDate": "2011-01-10T01:47:52.123"}, "bq_ids": {"n4140": {"so_4643074_4643093_0": {"section_id": 190, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_4643074_4643093_0": {"section_id": 184, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_4643074_4643093_0": {"section_id": 195, "quality": 0.7096774193548387, "length": 22}}}, "4643074": {"CommentCount": "2", "AcceptedAnswerId": "4643295", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2011-01-10T01:42:38.393", "LastActivityDate": "2016-06-15T14:13:30.663", "LastEditDate": "2016-06-15T14:13:30.663", "ViewCount": "15797", "FavoriteCount": "64", "Title": "Why do I have to access template base class members through the this pointer?", "Id": "4643074", "Score": "114", "Body": "<p>If the classes below were not templates I could simply have <code>x</code> in the <code>derived</code> class. However, with the code below, I <em>have to</em> use <code>this-&gt;x</code>. Why?</p>\n<pre><code>template &lt;typename T&gt;\nclass base {\n\nprotected:\n    int x;\n};\n\ntemplate &lt;typename T&gt;\nclass derived : public base&lt;T&gt; {\n\npublic:\n    int f() { return this-&gt;x; }\n};\n\nint main() {\n    derived&lt;int&gt; d;\n    d.f();\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><inheritance><c++-faq>", "OwnerUserId": "341970", "AnswerCount": "3"}});