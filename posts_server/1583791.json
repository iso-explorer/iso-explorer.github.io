post_cb({"1585974": {"ParentId": "1583791", "CommentCount": "7", "Body": "<p>That is a very interesting question.</p>\n<p>I am not Language Lawyer, but you might be able to replace the reinterpret_cast with a union.</p>\n<pre><code>const union {\n    int int_value;\n    char char_value[4];\n} Endian = { 0xAABBCCDD };\n\nconstexpr bool little_endian()\n{\n   return Endian[0] == 0xDD;\n}\n</code></pre>\n", "OwnerUserId": "85381", "PostTypeId": "2", "Id": "1585974", "Score": "4", "CreationDate": "2009-10-18T20:39:14.207", "LastActivityDate": "2009-10-18T20:39:14.207"}, "27088447": {"ParentId": "1583791", "CommentCount": "6", "Body": "<p>I was able to write this:</p>\n<pre><code>#include &lt;cstdint&gt;\n\nclass Endian\n{\nprivate:\n    static constexpr uint32_t uint32_ = 0x01020304;\n    static constexpr uint8_t magic_ = (const uint8_t&amp;)uint32_;\npublic:\n    static constexpr bool little = magic_ == 0x04;\n    static constexpr bool middle = magic_ == 0x02;\n    static constexpr bool big = magic_ == 0x01;\n    static_assert(little || middle || big, \"Cannot determine endianness!\");\nprivate:\n    Endian() = delete;\n};\n</code></pre>\n<p>g++ compiles it without error. It seems to work on my x64.\nCan anyone verify this code on any big-endian processor?</p>\n", "OwnerUserId": "3052438", "PostTypeId": "2", "Id": "27088447", "Score": "7", "CreationDate": "2014-11-23T11:29:40.550", "LastActivityDate": "2014-11-23T11:29:40.550"}, "23620241": {"ParentId": "1583791", "CommentCount": "0", "Body": "<p>This may seem like cheating, but you can always include endian.h... BYTE_ORDER == BIG_ENDIAN is a valid constexpr...</p>\n", "OwnerUserId": "60871", "PostTypeId": "2", "Id": "23620241", "Score": "0", "CreationDate": "2014-05-12T22:54:45.067", "LastActivityDate": "2014-05-12T22:54:45.067"}, "1583791": {"CommentCount": "0", "AcceptedAnswerId": "1584079", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2009-10-18T02:01:58.723", "LastActivityDate": "2014-11-23T11:29:40.550", "LastEditDate": "2011-12-18T22:32:48.163", "ViewCount": "3538", "FavoriteCount": "7", "Title": "constexpr and endianness", "Id": "1583791", "Score": "20", "Body": "<p>A common question that comes up from time to time in the world of C++ programming is compile-time determination of endianness.  Usually this is done with barely portable #ifdefs.  But does the C++11 <code>constexpr</code> keyword along with template specialization offer us a better solution to this?</p>\n<p>Would it be legal C++11 to do something like:</p>\n<pre><code>constexpr bool little_endian()\n{\n   const static unsigned num = 0xAABBCCDD;\n   return reinterpret_cast&lt;const unsigned char*&gt; (&amp;num)[0] == 0xDD;\n}\n</code></pre>\n<p>And then specialize a template for both endian types:</p>\n<pre><code>template &lt;bool LittleEndian&gt;\nstruct Foo \n{\n  // .... specialization for little endian\n};\n\ntemplate &lt;&gt;\nstruct Foo&lt;false&gt;\n{\n  // .... specialization for big endian\n};\n</code></pre>\n<p>And then do:</p>\n<pre><code>Foo&lt;little_endian()&gt;::do_something();\n</code></pre>\n", "Tags": "<c++><c++11><endianness>", "OwnerUserId": "168288", "AnswerCount": "6"}, "1586073": {"ParentId": "1583791", "CommentCount": "1", "Body": "<p>If your goal is to insure that the compiler optimizes <code>little_endian()</code> into a constant true or false at compile-time, without any of its contents winding up in the executable or being executed at runtime, and only generating code from the \"correct\" one of your two <code>Foo</code> templates, I fear you're in for a disappointment.</p>\n<p>I also am not a language lawyer, but it looks to me like <code>constexpr</code> is like <code>inline</code> or <code>register</code>: a keyword that alerts the compiler writer to the presence of a potential optimization. Then it's up to the compiler writer whether or not to take advantage of that. Language specs typically mandate behaviors, not optimizations.</p>\n<p>Also, have you actually tried this on a variety of C++0x complaint compilers to see what happens? I would guess most of them would choke on your dual templates, since they won't be able to figure out which one to use if invoked with <code>false</code>.</p>\n", "OwnerUserId": "174127", "PostTypeId": "2", "Id": "1586073", "Score": "-3", "CreationDate": "2009-10-18T21:26:20.020", "LastActivityDate": "2009-10-18T21:26:20.020"}, "1584079": {"ParentId": "1583791", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>Assuming <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2116.pdf\" rel=\"nofollow noreferrer\">N2116</a> is the wording that gets incorporated, then your example is ill-formed (notice that there is no concept of \"legal/illegal\" in C++). The proposed text for [decl.constexpr]/3 says</p>\n<blockquote id=\"so_1583791_1584079_0\">\n<ul>\n<li>its function-body shall be a compound-statement of the form\n           <code>{ return expression; }</code>\n  where expression is a potential constant expression (5.19); </li>\n</ul>\n</blockquote>\n<p>Your function violates the requirement in that it also declares a local variable.</p>\n<p><strong>Edit</strong>: This restriction could be overcome by moving num outside of the function. The function still wouldn't be well-formed, then, because expression needs to be a potential constant expression, which is defined as</p>\n<blockquote>\n<p id=\"so_1583791_1584079_1\">An expression is a potential constant expression if it is a constant\n  expression when all occurrences of function parameters are replaced\n  by arbitrary constant expressions of the appropriate type.</p>\n</blockquote>\n<p>IOW, <code>reinterpret_cast&lt;const unsigned char*&gt; (&amp;num)[0] == 0xDD</code>  would have to be a constant expression. However, it is not: <code>&amp;num</code> would be a address constant-expression (5.19/4). Accessing the value of such a pointer is, however, not allowed for a constant expression:</p>\n<blockquote>\n<p id=\"so_1583791_1584079_2\">The subscripting operator [] and the class member access . and \n  operators, the <code>&amp;</code> and <code>*</code> unary operators, and pointer casts (except dynamic_casts, 5.2.7) can be used in the creation of an\n  address constant expression, but the value of an object shall not be accessed by the use of these operators.</p>\n</blockquote>\n<p><strong>Edit</strong>: The above text is from C++98. Apparently, C++0x is more permissive what it allows for constant expressions. The expression involves an lvalue-to-rvalue conversion of the array reference, which is banned from constant expressions unless</p>\n<blockquote>\n<p id=\"so_1583791_1584079_3\">it is applied to an lvalue of effective integral type that refers \n  to a non-volatile const variable or static data member initialized \n  with constant expressions </p>\n</blockquote>\n<p>It's not clear to me whether <code>(&amp;num)[0]</code> \"refers to\" a const variable, or whether only a literal <code>num</code> \"refers to\" such a variable. If <code>(&amp;num)[0]</code> refers to that variable, it is then unclear whether <code>reinterpret_cast&lt;const unsigned char*&gt; (&amp;num)[0]</code> still \"refers to\" <code>num</code>.</p>\n", "OwnerUserId": "33006", "LastEditorUserId": "33006", "LastEditDate": "2009-10-18T19:55:59.457", "Id": "1584079", "Score": "12", "CreationDate": "2009-10-18T05:19:20.660", "LastActivityDate": "2009-10-18T19:55:59.457"}, "8197886": {"ParentId": "1583791", "CommentCount": "1", "Body": "<p>It is not possible to determine endianness at compile time using <code>constexpr</code>. <code>reinterpret_cast</code> is explicitly forbidden by [expr.const]p2, as is iain's suggestion of reading from a non-active member of a union.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "8197886", "Score": "6", "CreationDate": "2011-11-19T22:34:11.870", "LastActivityDate": "2011-11-19T22:34:11.870"}, "bq_ids": {"n4140": {"so_1583791_1584079_3": {"section_id": 6185, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_1583791_1584079_3": {"section_id": 5946, "quality": 0.7333333333333333, "length": 11}, "so_1583791_1584079_1": {"section_id": 5946, "quality": 0.5294117647058824, "length": 9}}, "n4659": {"so_1583791_1584079_3": {"section_id": 7687, "quality": 0.7333333333333333, "length": 11}}}});