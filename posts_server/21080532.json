post_cb({"bq_ids": {"n4140": {"so_21080532_21080853_2": {"length": 15, "quality": 1.0, "section_id": 7211}, "so_21080532_21080853_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 4701}, "so_21080532_21080853_3": {"length": 50, "quality": 0.9615384615384616, "section_id": 7212}}, "n3337": {"so_21080532_21080853_2": {"length": 15, "quality": 1.0, "section_id": 6955}, "so_21080532_21080853_3": {"length": 50, "quality": 0.9615384615384616, "section_id": 6956}, "so_21080532_21080853_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 4510}}, "n4659": {"so_21080532_21080853_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 8720}, "so_21080532_21080853_3": {"length": 50, "quality": 0.9615384615384616, "section_id": 8721}}}, "21082747": {"Id": "21082747", "PostTypeId": "2", "Body": "<p>MAYBE your test might be flawed? I'm not sure as you posted no code.. However, for such a test, DO NOT use the size to determine what type is being returned. Such a test is inaccurate when a long can be same size as int.</p>\n<p>For example:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nstd::make_signed&lt;unsigned long&gt;::type x;\n\nint main()\n{\n    std::cout&lt;&lt;(sizeof(x) == sizeof(int));\n}\n</code></pre>\n<p>is implementation defined and can return true if the long is the same size as the int. On most systems this will return true.</p>\n<p>Doing:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nstd::make_signed&lt;unsigned long&gt;::type x;\n\nint main()\n{\n    std::cout&lt;&lt;typeid(x).name();\n}\n</code></pre>\n<p>will print <code>L</code> if <code>x</code> is a <code>long</code> and it will print <code>I</code> if <code>x</code> is an <code>int</code>.</p>\n", "LastActivityDate": "2014-01-13T01:51:31.157", "CommentCount": "1", "CreationDate": "2014-01-13T01:51:31.157", "ParentId": "21080532", "Score": "0", "OwnerUserId": "1462718"}, "21080853": {"Id": "21080853", "PostTypeId": "2", "Body": "<p>C++11 20.9.7.3 [meta.trans.sign] describes <code>make_signed</code>:</p>\n<blockquote>\n<p id=\"so_21080532_21080853_0\">If <code>T</code> names a (possibly cv-qualified) signed integer type (3.9.1) then the\n  member typedef <code>type</code> shall name the type <code>T</code>; otherwise, <strong>if <code>T</code> names a\n  (possibly cv-qualified) unsigned integer type then <code>type</code> shall name the\n  corresponding signed integer type, with the same cv-qualifiers as <code>T</code></strong> [<em>emphasis added</em>];\n  otherwise, <code>type</code> shall name the signed integer type with smallest\n  rank (4.13) for which <code>sizeof(T) == sizeof(type)</code>, with the same\n  cv-qualifiers as <code>T</code>.</p>\n<p id=\"so_21080532_21080853_1\"><em>Requires:</em> <code>T</code> shall be a (possibly cv-qualified) integral type or enumeration but not a <code>bool</code> type.</p>\n</blockquote>\n<p>I would consider \"the corresponding signed integer type\" of <code>unsigned long</code> to be <code>long</code>. I don't think there's much room for interpretation.</p>\n<p>EDIT: There's <em>no</em> room for interpretation since the standard defines \"corresponding signed integer type\". 3.9.1/2 states:</p>\n<blockquote>\n<p id=\"so_21080532_21080853_2\">There are five <em>standard signed integer types</em>: \u201c<code>signed char</code>\u201d, \u201c<code>short int</code>\u201d, \u201c<code>int</code>\u201d, \u201c<code>long int</code>\u201d, and \u201c<code>long long int</code>\u201d. ...</p>\n</blockquote>\n<p>and 3.9.1/3:</p>\n<blockquote>\n<p id=\"so_21080532_21080853_3\">For each of the standard signed integer types, there exists a corresponding (but different) <em>standard unsigned integer type</em>: \u201c<code>unsigned char</code>\u201d, \u201c<code>unsigned short int</code>\u201d, \u201c<code>unsigned int</code>\u201d, \u201c<code>unsigned long int</code>\u201d, and \u201c<code>unsigned long long int</code>\u201d, each of which occupies the same amount of storage and has the same alignment requirements (3.11) as the corresponding signed integer type; that is, each signed integer type has the same object representation as its corresponding unsigned integer type. ...</p>\n</blockquote>\n<p>The corresponding signed integer type of <code>unsigned long int</code> is clearly <code>long int</code>.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-01-12T22:32:33.670", "Score": "7", "CreationDate": "2014-01-12T22:02:31.373", "ParentId": "21080532", "CommentCount": "2", "OwnerUserId": "923854", "LastEditDate": "2014-01-12T22:32:33.670"}, "21080532": {"ViewCount": "472", "Body": "<p>I'm using Visual Studio 2010 and the following code confused me a bit:</p>\n<pre><code>#include&lt;type_traits&gt;\nauto x = std::make_signed&lt;unsigned long&gt;::type();\n</code></pre>\n<p>x will be of type int, but I would have expected long. I know that int and long in VS10 are both 4-byte integers. But even if a signed long fits into an int, int for me is not the signed integer type corresponding to unsigned long. So my question: is this a bug/technical inaccuracy or do the specifications of the standard allow this result?</p>\n", "AcceptedAnswerId": "21080853", "Title": "make_signed<unsigned long>::type is int?", "CreationDate": "2014-01-12T21:30:06.513", "Id": "21080532", "CommentCount": "3", "LastEditDate": "2014-01-13T20:38:41.000", "PostTypeId": "1", "LastEditorUserId": "1624629", "LastActivityDate": "2014-01-13T20:38:41.000", "Score": "6", "OwnerUserId": "1624629", "Tags": "<c++><visual-studio-2010><c++11><types>", "AnswerCount": "2"}});