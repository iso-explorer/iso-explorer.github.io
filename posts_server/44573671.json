post_cb({"bq_ids": {"n4140": {"so_44573671_44573909_4": {"length": 4, "quality": 1.0, "section_id": 635}, "so_44573671_44573909_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 632}, "so_44573671_44573909_6": {"length": 8, "quality": 1.0, "section_id": 635}, "so_44573671_44573909_2": {"length": 12, "quality": 0.7058823529411765, "section_id": 634}}, "n3337": {"so_44573671_44573909_4": {"length": 4, "quality": 1.0, "section_id": 625}, "so_44573671_44573909_0": {"length": 27, "quality": 0.9, "section_id": 622}, "so_44573671_44573909_6": {"length": 8, "quality": 1.0, "section_id": 625}, "so_44573671_44573909_2": {"length": 12, "quality": 0.7058823529411765, "section_id": 624}}, "n4659": {"so_44573671_44573909_4": {"length": 4, "quality": 1.0, "section_id": 660}, "so_44573671_44573909_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 660}, "so_44573671_44573909_6": {"length": 8, "quality": 1.0, "section_id": 663}, "so_44573671_44573909_2": {"length": 12, "quality": 0.7058823529411765, "section_id": 662}}}, "44573909": {"Id": "44573909", "PostTypeId": "2", "Body": "<p>Oh, this is nasty.</p>\n<p>Per [over.ics.list]p4 and p7:</p>\n<blockquote>\n<p id=\"so_44573671_44573909_0\">4 Otherwise, if the parameter is a non-aggregate class <code>X</code> and overload resolution per 13.3.1.7 chooses a single best constructor of <code>X</code> to perform the initialization of an object of type <code>X</code> from the argument initializer list, the implicit conversion sequence is a user-defined conversion sequence with the second standard conversion sequence an identity conversion. [...]</p>\n<p id=\"so_44573671_44573909_1\">[...]</p>\n<p id=\"so_44573671_44573909_2\">6 Otherwise, if the parameter is a reference, see 13.3.3.1.4. [<em>Note: The rules in this section will apply for initializing the underlying temporary for the reference. -- end note</em>] [...]</p>\n<p id=\"so_44573671_44573909_3\">[...]</p>\n<p id=\"so_44573671_44573909_4\">7 Otherwise, if the parameter type is not a class:</p>\n<p id=\"so_44573671_44573909_5\">[...]</p>\n<p id=\"so_44573671_44573909_6\">(7.2) -- if the initializer list has no elements, the implicit conversion sequence is the identity conversion. [...]</p>\n</blockquote>\n<p>The construction of a <code>const std::pair&lt;int,int&gt;</code> temporary from <code>{}</code> is considered a user-defined conversion. The construction of a <code>const std::pair&lt;int,int&gt; *</code> prvalue, or a <code>const int *</code> prvalue, or a <code>const int</code> temporary object are all considered standard conversions.</p>\n<p>Standard conversions are preferred over user-defined conversions.</p>\n<p>Your own find of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1536\" rel=\"noreferrer\">CWG issue 1536</a> is relevant, but mostly for language lawyers. It's a gap in the wording, where the standard doesn't really say what happens for initialisation of a reference parameter from <code>{}</code>, since <code>{}</code> is not an expression. It's not what makes the one call ambiguous and the other not though, and implementations are managing to apply common sense here.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2017-06-15T18:31:59.333", "Score": "5", "CreationDate": "2017-06-15T17:52:10.747", "ParentId": "44573671", "CommentCount": "0", "OwnerUserId": "743382", "LastEditDate": "2017-06-15T18:31:59.333"}, "44573671": {"ViewCount": "251", "Body": "<p>I ran into a real-life WTF moment when I discovered that the code below outputs \"pointer\".</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;typename T&gt;\nstruct bla\n{\n    static void f(const T*) { std::cout &lt;&lt; \"pointer\\n\"; }\n    static void f(const T&amp;) { std::cout &lt;&lt; \"reference\\n\"; }\n};\n\nint main()\n{\n    bla&lt;std::pair&lt;int,int&gt;&gt;::f({});\n}\n</code></pre>\n<p>Changing the <code>std::pair&lt;int,int&gt;</code> template argument to an <code>int</code> or any other primitive type, gives the (for me at least) expected \"ambiguous overload\" error. It seems that builtin types are special here, because any user-defined type (aggregate, non-trivial, with defaulted constructor, etc...) all lead to the pointer overload being called. I believe the template is not necessary to reproduce it, it just makes it simple to try out different types.</p>\n<p>Personally, I don't think that is logical and I would expect the ambiguous overload error in all cases, regardless of the template argument. GCC and Clang (and I believe MSVC) all disagree with me, across C++11/14/1z. Note I am fully aware of the bad API these two overloads present, and I would never write <a href=\"https://github.com/qt/qtbase/blob/dev/src/corelib/thread/qfutureinterface.h#L179\" rel=\"noreferrer\">something like this, I promise</a>.</p>\n<p>So the question becomes: what is going on?</p>\n", "AcceptedAnswerId": "44573909", "Title": "Overload resolution with an empty brace initializer: pointer or reference?", "CreationDate": "2017-06-15T17:37:44.523", "Id": "44573671", "CommentCount": "2", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-06-15T17:50:18.590", "LastEditorUserId": "256138", "LastActivityDate": "2017-06-15T18:44:18.350", "ClosedDate": "2017-06-15T18:47:34.013", "Score": "18", "OwnerUserId": "256138", "Tags": "<c++><c++11><initializer-list><overload-resolution>", "AnswerCount": "1"}});