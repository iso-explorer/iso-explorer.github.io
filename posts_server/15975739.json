post_cb({"15975739": {"CommentCount": "9", "AcceptedAnswerId": "15976200", "PostTypeId": "1", "LastEditorUserId": "36565", "CreationDate": "2013-04-12T15:51:25.113", "LastActivityDate": "2013-04-12T16:31:34.567", "LastEditDate": "2013-04-12T16:31:34.567", "ViewCount": "336", "FavoriteCount": "1", "Title": "Operator overloading clang++ and g++ different output", "Id": "15975739", "Score": "9", "Body": "<p>With this sample program I observe a different behavior in g++ and clang</p>\n<p>Foo.h:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace Bar\n{\n\nclass Foo\n{\npublic:\n\n    Foo(int x) : _x(x)\n    {}\n\n    int x() const\n    {\n        return _x;\n    }\n\nprivate:\n\n    int _x;\n};\n\n}\n\nstd::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, const Bar::Foo* foo);\n</code></pre>\n<p>Foo.cpp</p>\n<pre><code>#include &lt;Foo.h&gt;\n\nusing namespace std;\n\nostream&amp; operator &lt;&lt;(ostream&amp; os, const Bar::Foo* foo)\n{\n    return os &lt;&lt; foo-&gt;x();\n}\n</code></pre>\n<p>main.cpp</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nvoid print(const T&amp; t)\n{\n    cout &lt;&lt; t &lt;&lt; endl;\n}\n\n#include &lt;Foo.h&gt;\n\nint main(int argc, char** argv)\n{\n    Bar::Foo* foo = new Bar::Foo(5);\n    print(foo);\n}\n</code></pre>\n<p>Compiling with clang++ and g++ produce different results:</p>\n<pre><code>air:~ jose$ clang++ Foo.cpp main.cpp -I.\nair:~ jose$ ./a.out\n0x7ff9e84000e0\nair:~ jose$ g++ Foo.cpp main.cpp -I.\nair:~ jose$ ./a.out\n5\n</code></pre>\n<p>Which one is correct and why?.</p>\n", "Tags": "<c++><name-lookup>", "OwnerUserId": "491807", "AnswerCount": "1"}, "15976200": {"ParentId": "15975739", "CommentCount": "4", "Body": "<p>In this particular case, clang++ is correct.</p>\n<p>The problem is how lookup is performed inside the template <code>print</code>. In the expression inside <code>print</code> the call to <code>operator&lt;&lt;</code> is <em>dependent</em>. Name resolution for <em>dependent names</em> is handled in 14.6.4:</p>\n<blockquote>\n<p id=\"so_15975739_15976200_0\">In resolving dependent names, names from the following sources are considered:</p>\n<p id=\"so_15975739_15976200_1\">\u2014 Declarations that are visible at the point of definition of the template.</p>\n<p id=\"so_15975739_15976200_2\">\u2014 Declarations from namespaces associated with the types of the function arguments both from the instantiation context (14.6.4.1) and from the definition context.</p>\n</blockquote>\n<p>In your case, the declaration of your operator is not visible at the point of definition of the template, since the header is included afterwards, and it does not live in any of the associated namespaces of the function arguments (namely <code>::std</code> for <code>::std::ostream</code> and <code>::Bar</code> for <code>::Bar::Foo*</code>), so it won't be found.</p>\n<p>Now, there is an overload in <code>::std</code> that takes a <code>void*</code>, and that will be found by Argument Dependent Lookup. The <code>::Bar::Foo*</code> will be converted to a <code>void*</code> and the address will be printed.</p>\n<p>That is, in a standard compliant compiler.</p>\n<p>I forgot to add this here, and left it only in the comment, but it is important enough:</p>\n<p><strong>Always</strong> define the operators that apply to your types in the same namespace that holds the types on which they apply. Let Argument Dependent Lookup do it's magic for you. It was specifically designed to serve this particular purpose, use it.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "15976200", "Score": "13", "CreationDate": "2013-04-12T16:14:31.330", "LastActivityDate": "2013-04-12T16:14:31.330"}, "bq_ids": {"n4140": {"so_15975739_15976200_2": {"section_id": 215, "quality": 0.9166666666666666, "length": 11}, "so_15975739_15976200_0": {"section_id": 215, "quality": 1.0, "length": 6}, "so_15975739_15976200_1": {"section_id": 215, "quality": 1.0, "length": 5}}, "n3337": {"so_15975739_15976200_2": {"section_id": 209, "quality": 0.9166666666666666, "length": 11}, "so_15975739_15976200_0": {"section_id": 209, "quality": 1.0, "length": 6}, "so_15975739_15976200_1": {"section_id": 209, "quality": 1.0, "length": 5}}, "n4659": {"so_15975739_15976200_2": {"section_id": 223, "quality": 0.9166666666666666, "length": 11}, "so_15975739_15976200_0": {"section_id": 223, "quality": 1.0, "length": 6}, "so_15975739_15976200_1": {"section_id": 223, "quality": 1.0, "length": 5}}}});