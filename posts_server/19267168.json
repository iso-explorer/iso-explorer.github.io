post_cb({"bq_ids": {"n4140": {"so_19267168_19267168_0": {"length": 14, "quality": 1.0, "section_id": 456}, "so_19267168_19267168_1": {"length": 15, "quality": 1.0, "section_id": 467}}, "n3337": {"so_19267168_19267168_0": {"length": 14, "quality": 1.0, "section_id": 447}, "so_19267168_19267168_1": {"length": 15, "quality": 1.0, "section_id": 458}}, "n4659": {"so_19267168_19267168_0": {"length": 14, "quality": 1.0, "section_id": 479}, "so_19267168_19267168_1": {"length": 15, "quality": 1.0, "section_id": 490}}}, "19267632": {"Id": "19267632", "PostTypeId": "2", "Body": "<p>This seems like a compiler bug indeed.</p>\n<p>Since you have defined a user-provided move assignment operator, the copy assignment operator should be implicitly defined as deleted (as specified in 12.8.18). This is the behaviour exhibited by other compilers (gcc, for example).</p>\n", "LastActivityDate": "2013-10-09T09:11:14.680", "Score": "2", "CreationDate": "2013-10-09T09:11:14.680", "ParentId": "19267168", "CommentCount": "0", "OwnerUserId": "980195"}, "19267168": {"ViewCount": "232", "Body": "<pre><code>struct A\n{\n    A(int x)\n        : n(x)\n    {}\n\n    A(A&amp;&amp;)\n    {}\n\n    A&amp; operator =(A&amp;&amp;)\n    {\n        return *this;\n    }\n\n    int n;\n};\n\nint main()\n{\n    A a(1), b(2);\n\n    a = b;\n\n    if (2 == a.n)\n    {\n        // It SHOULD go here!\n    }\n}\n</code></pre>\n<p>As per the C++ standard 12.8.7:</p>\n<blockquote>\n<p id=\"so_19267168_19267168_0\">If the class definition declares a move constructor or move assignment\n  operator, the implicitly declared copy constructor is defined as\n  deleted;</p>\n</blockquote>\n<p>and 12.8.18</p>\n<blockquote>\n<p id=\"so_19267168_19267168_1\">If the class definition declares a move constructor or move assignment\n  operator, the implicitly declared copy assignment operator is defined\n  as deleted;</p>\n</blockquote>\n<p>The statement <code>a = b;</code> should trigger a compiler error. However, my compiler (VC++ 2013 RC) accepts it and calls the implicitly-defined copy assignment instead.</p>\n<p>Is this a compiler's bug?</p>\n<p><strong>Update:</strong></p>\n<p>I have submitted this issue as a bug to <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/804896/the-copy-assignment-is-not-deleted-when-the-move-assignment-is-explicitly-declared#details\" rel=\"nofollow\">microsoft</a>.</p>\n", "Title": "Why is the copy assignment not deleted when the move assignment is declared?", "CreationDate": "2013-10-09T08:48:50.200", "LastActivityDate": "2013-10-09T09:14:11.423", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-10-09T09:14:11.423", "LastEditorUserId": "508343", "Id": "19267168", "Score": "7", "OwnerUserId": "508343", "Tags": "<c++><c++11><compiler-construction><copy-constructor><deleted-functions>", "AnswerCount": "1"}});