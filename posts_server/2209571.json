post_cb({"2209571": {"CommentCount": "1", "ViewCount": "158", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2010-02-05T18:54:34.390", "LastActivityDate": "2012-10-08T15:44:32.320", "Title": "Assignment to unions of members", "AcceptedAnswerId": "2209599", "LastEditDate": "2012-10-08T15:44:32.320", "Id": "2209571", "Score": "1", "Body": "<p>Let's say I have a class with union members in it:</p>\n<pre><code>class ClassX {\npublic:\n  union {\n    StructA * A;\n    StructB * B;\n    };\n  }\n</code></pre>\n<p>If I have pointers x1 and x2 to different ClassX objects, does this:</p>\n<pre><code>x1-&gt;A = x2-&gt;A;\n</code></pre>\n<p>Have the same effect as this:</p>\n<pre><code>x1-&gt;B = x2-&gt;B;\n</code></pre>\n<p>? Thanks.</p>\n", "Tags": "<c++><unions>", "OwnerUserId": "13500", "AnswerCount": "5"}, "2209594": {"ParentId": "2209571", "CommentCount": "2", "CreationDate": "2010-02-05T18:58:25.460", "OwnerUserId": "106769", "PostTypeId": "2", "Id": "2209594", "Score": "0", "Body": "<p>The operations should be identical.  But that might not be the case if you've overloaded the assignment operator for either of those two pointer types.</p>\n", "LastActivityDate": "2010-02-05T18:58:25.460"}, "2209599": {"ParentId": "2209571", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-02-05T18:58:44.657", "Score": "5", "LastEditorUserId": "19563", "LastEditDate": "2010-02-05T19:07:58.367", "Id": "2209599", "OwnerUserId": "19563", "Body": "<p>For most practical purposes, on most implementations, those two statements would have the same effect, however it's not guaranteed. If the member that you read from a union isn't the last member that was writted to the union the behaviour of the program is undefined.</p>\n<p>Because both members of the union are pointers to structs it is very likely that they occupy the same size and have analogous representations so assigning either union member is likely to correctly assign the other union member if that's what was actually stored in the source union.</p>\n", "LastActivityDate": "2010-02-05T19:07:58.367"}, "2209586": {"ParentId": "2209571", "CommentCount": "2", "CreationDate": "2010-02-05T18:57:38.230", "OwnerUserId": "8078", "PostTypeId": "2", "Id": "2209586", "Score": "0", "Body": "<p>These do not have the same effect unless StructA and StructB have the same size. The first line you posted copies all of the memory occupied by <code>x2-&gt;A</code> into <code>x1-&gt;A</code>, while the second does the same thing for <code>B</code>. <code>A</code> and <code>B</code> occupy an overlapping area of memory, but they may be different sizes, in which case the two statements are not equivalent.</p>\n", "LastActivityDate": "2010-02-05T18:57:38.230"}, "2209638": {"ParentId": "2209571", "CommentCount": "1", "CreationDate": "2010-02-05T19:05:44.887", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "2209638", "Score": "2", "Body": "<p>What kind of answer do you expect? </p>\n<p>A formal and pedantic one? If so, then there's simply no answer to that question. C++ language does give you any formal opportunity to compare the effects of these two assignments. If you assigned <code>ClassX::A</code>, you can only read <code>ClassX::A</code> and not <code>ClassX::B</code>. If you assigned <code>ClassX::B</code>, you can only read <code>ClassX::B</code> and not <code>ClassX::A</code>. In other words, there's no meaningful reason to even care whether the effects are the same or not. The language simply does not allow you to care about it. If your code somehow relies on it, then its behavior is undefined, as far as formal C++ is concerned.</p>\n<p>As for the real-life practical answer to that question... yes, the effects should be the same in any reasonable implementation of the language.</p>\n", "LastActivityDate": "2010-02-05T19:05:44.887"}, "2209697": {"ParentId": "2209571", "CommentCount": "2", "CreationDate": "2010-02-05T19:13:40.363", "OwnerUserId": "95135", "PostTypeId": "2", "Id": "2209697", "Score": "1", "Body": "<p><a href=\"http://www.kuzbass.ru:8086/docs/isocpp/class.html\" rel=\"nofollow noreferrer\">C++1x Standard Draft, Section 9.5.1</a></p>\n<blockquote>\n<p id=\"so_2209571_2209697_0\">In a union, at most one of the data\n  members can be active at any time,\n  that is, the value of at most one of\n  the data members can be stored in a\n  union at any time. [Note: one special\n  guarantee is made in order to simplify\n  the use of unions: If a POD-union\n  contains several POD-structs that\n  share a common initial sequence\n  (class.mem), and if an object of this\n  POD-union type contains one of the\n  POD-structs, it is permitted to\n  inspect the common initial sequence of\n  any of POD-struct members; see\n  class.mem. ] </p>\n</blockquote>\n<p>Do note the special guarantee.</p>\n", "LastActivityDate": "2010-02-05T19:13:40.363"}, "bq_ids": {"n4140": {"so_2209571_2209697_0": {"section_id": 5913, "quality": 0.82, "length": 41}}, "n3337": {"so_2209571_2209697_0": {"section_id": 5685, "quality": 0.82, "length": 41}}, "n4659": {"so_2209571_2209697_0": {"section_id": 7404, "quality": 0.8, "length": 40}}}});