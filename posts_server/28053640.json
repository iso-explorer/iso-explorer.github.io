post_cb({"28054077": {"ParentId": "28053640", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As far as I can tell <code>clang</code> is correct, using a non static member is only valid in an unevaluated context if it is a data member. So it looks like <code>gcc</code> is incorrect for the first two cases, but <code>gcc</code> works correctly in the case of <code>sizeof</code> and <code>decltype</code> which also have unevaluated operands.</p>\n<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>5.1.1</code> <em>[expr.prim.general]</em>:</p>\n<blockquote>\n<p id=\"so_28053640_28054077_0\">An id-expression that denotes a non-static data member or non-static\n  member function of a class can only be used:</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote>\n<p id=\"so_28053640_28054077_1\">if that id-expression denotes a non-static data member and it appears\n  in an unevaluated operand. <em>[ Example:</em></p>\n<pre><code>struct S {\n    int m;\n};\nint i = sizeof(S::m); // OK\nint j = sizeof(S::m + 42); // OK \n</code></pre>\n<p id=\"so_28053640_28054077_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>The rest of the bullets do not apply, they are as follows:</p>\n<blockquote id=\"so_28053640_28054077_3\">\n<ul>\n<li>as part of a class member access (5.2.5) in which the object expression refers to the member\u2019s class<sup>61</sup> or a class derived from that\n  class, or</li>\n<li>to form a pointer to member (5.3.1), or</li>\n<li>in a mem-initializer for a constructor for that class or for a class derived from that class (12.6.2), or</li>\n<li>in a brace-or-equal-initializer for a non-static data member of that class or of a class derived from that class (12.6.2), or</li>\n</ul>\n</blockquote>\n<p>We know that operand is unevaluated from section <code>5.2.8</code> which says:</p>\n<blockquote>\n<p id=\"so_28053640_28054077_4\">When typeid is applied to an expression other than a glvalue of a\n  polymorphic class type, [...] The expression is an unevaluated operand\n  (Clause 5).</p>\n</blockquote>\n<p>We can see from the grammar that an <em>id-expression</em> is either an <em>unqualified-id</em> or a <em>qualified-id</em>:</p>\n<pre><code>id-expression:\n    unqualified-id\n    qualified-id\n</code></pre>\n<p><b>Update</b></p>\n<p>Filed a gcc <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68604\" rel=\"nofollow\">bug report: typeid does not allow an id-expression that denotes a non-static data member</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-30T15:06:24.157", "Id": "28054077", "Score": "11", "CreationDate": "2015-01-20T19:56:40.917", "LastActivityDate": "2015-11-30T15:06:24.157"}, "28053640": {"CommentCount": "7", "ViewCount": "733", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-01-20T19:30:24.677", "LastActivityDate": "2015-11-30T15:06:24.157", "Title": "typeid doesn't work with non-static member function", "AcceptedAnswerId": "28054077", "LastEditDate": "2015-01-24T06:06:12.700", "Id": "28053640", "Score": "13", "Body": "<p><code>clang</code> doesn't compile the third call to <code>typeid</code> below (see <a href=\"http://coliru.stacked-crooked.com/a/e61efc069f27dc35\" rel=\"nofollow\">live example</a>). But I can't see anything in \u00a75.2.8 that disallows this, specially when we consider that the expression <code>B::f</code> is not a glvalue of polymorphic class type (see paragraph 3). Also, according to this paragraph the expression <code>B::f</code> is an unevaluated operand, and as such, the call <code>typeid(B::f)</code> should compile. Note that <code>GCC</code> doesn't compile any of the calls to <code>typeid</code> below:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nstruct A{ int i; };\nstruct B{ int i; void f(); };\n\nint main()\n{\n    std::cout &lt;&lt; typeid(A::i).name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; typeid(B::i).name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; typeid(B::f).name() &lt;&lt; '\\n';\n}\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer><typeid>", "OwnerUserId": "1042389", "AnswerCount": "2"}, "28054475": {"ParentId": "28053640", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>typeid(A::i).name()</code> doesn't quite do what I thought it would do. I expected it to be a pointer-to-member, but it's actually just an <code>int</code>.</p>\n<p>To see this, run this code:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A{ int i; };\nstruct B{ int i; void f(void); };\n\ntemplate&lt;typename T&gt;\nvoid what_is_my_type() {\n    std:: cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std:: endl;\n}\n\nint main()\n{\n    what_is_my_type&lt;decltype(&amp;A::i)&gt;(); // \"void what_is_my_type() [T = int A::*]\"\n    what_is_my_type&lt;decltype(&amp;B::i)&gt;(); // \"void what_is_my_type() [T = int B::*]\"\n    what_is_my_type&lt;decltype(&amp;B::f)&gt;(); // \"void what_is_my_type() [T = void (B::*)()]\"\n\n    what_is_my_type&lt;decltype(A::i)&gt;();  // \"void what_is_my_type() [T = int]\"\n    what_is_my_type&lt;decltype(B::i)&gt;();  // \"void what_is_my_type() [T = int]\"\n    // what_is_my_type&lt;decltype(B::f)&gt;();       //    doesn't compile\n\n}\n</code></pre>\n<p>I've put the output in a comment after each call.</p>\n<p>The first three calls work as expected - all three work and the type information includes the type of the struct (<code>A</code> or <code>B</code>) as well as the type of member.</p>\n<p>The last three are different though. The final one doesn't even compile, and the first two simply print <code>int</code>. I think this is a clue as to what is wrong. It is possible, given a particular <code>A</code> or <code>B</code>, to take the address of that particular member:</p>\n<pre><code>A a;\nint * x = &amp;(a.i);\n*x = 32;\n</code></pre>\n<p>but it is <em>not</em> possible (or even meaningful?) to do this:</p>\n<pre><code>B b;\n???   y = &amp;(a.f); // what does this even mean?\n</code></pre>\n<p>Finally, to emphasize that this is not about pointers, consider this:</p>\n<pre><code>A a;\nB b;\nint x = a.i;\nint y = b.i;\n??? z = b.f;  // what would this mean? What's its type?\n</code></pre>\n", "OwnerUserId": "146041", "LastEditorUserId": "146041", "LastEditDate": "2015-01-20T20:51:02.037", "Id": "28054475", "Score": "1", "CreationDate": "2015-01-20T20:23:16.240", "LastActivityDate": "2015-01-20T20:51:02.037"}, "bq_ids": {"n4140": {"so_28053640_28054077_0": {"section_id": 5959, "quality": 1.0, "length": 10}, "so_28053640_28054077_3": {"section_id": 5959, "quality": 0.5151515151515151, "length": 17}, "so_28053640_28054077_1": {"section_id": 5959, "quality": 0.8888888888888888, "length": 8}, "so_28053640_28054077_4": {"section_id": 6022, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_28053640_28054077_0": {"section_id": 5728, "quality": 1.0, "length": 10}, "so_28053640_28054077_3": {"section_id": 5728, "quality": 0.8484848484848485, "length": 28}, "so_28053640_28054077_1": {"section_id": 5728, "quality": 0.8888888888888888, "length": 8}, "so_28053640_28054077_4": {"section_id": 5790, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_28053640_28054077_3": {"section_id": 7440, "quality": 0.5151515151515151, "length": 17}, "so_28053640_28054077_0": {"section_id": 7440, "quality": 1.0, "length": 10}, "so_28053640_28054077_1": {"section_id": 7440, "quality": 0.8888888888888888, "length": 8}, "so_28053640_28054077_4": {"section_id": 7521, "quality": 0.9333333333333333, "length": 14}}}});