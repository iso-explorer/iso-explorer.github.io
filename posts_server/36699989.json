post_cb({"bq_ids": {"n4140": {"so_36699989_36700919_0": {"length": 36, "quality": 0.972972972972973, "section_id": 480}}, "n3337": {"so_36699989_36700919_0": {"length": 33, "quality": 0.8918918918918919, "section_id": 471}}, "n4659": {"so_36699989_36700919_0": {"length": 36, "quality": 0.972972972972973, "section_id": 502}}}, "36700919": {"Id": "36700919", "PostTypeId": "2", "Body": "<p>In <code>MyClass obj1(MyClass(5));</code> the compiler elides the temporary object <code>MyClass(5)</code> because it is allowed to.</p>\n<p>In particular, C++ standard 2014 \u00a712.8 para 31, defines cases when <em>copy elision</em> can be performed:</p>\n<blockquote>\n<p id=\"so_36699989_36700919_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects... This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which\n  may be combined to eliminate multiple copies):</p>\n<ul>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "412080", "LastActivityDate": "2016-04-18T17:53:42.273", "Score": "2", "CreationDate": "2016-04-18T17:48:22.183", "ParentId": "36699989", "CommentCount": "0", "OwnerUserId": "412080", "LastEditDate": "2016-04-18T17:53:42.273"}, "36699989": {"ViewCount": "78", "Body": "<pre><code>class MyClass\n{\n  public:    \n  int a;\n  MyClass(int r): a(r) {}\n\n  MyClass(const MyClass&amp; ref)\n  {\n      cout &lt;&lt; \"Copy Constructor\\n\";\n      a= ref.a;\n  }\n};\nint main()\n{\n    MyClass obj(5);\n    MyClass obj1(MyClass(5));  //Case 1\n    MyClass obj2(obj);        //Case 2\n    return 0;\n}\n</code></pre>\n<p>Why the copy constructor is invoked in Case 2, not in Case 1. \nIn case 1 a temporary object is passed as argument.</p>\n", "AcceptedAnswerId": "36700919", "Title": "Why copy constructor is not called when pass temporary object", "CreationDate": "2016-04-18T16:57:51.590", "Id": "36699989", "CommentCount": "3", "LastEditDate": "2016-04-18T17:13:58.683", "PostTypeId": "1", "LastEditorUserId": "6113534", "LastActivityDate": "2016-04-18T17:53:42.273", "Score": "0", "OwnerUserId": "6113534", "Tags": "<c++><c++11><copy-constructor>", "AnswerCount": "1"}});