post_cb({"10825009": {"ParentId": "10821756", "CommentCount": "0", "Body": "<p>It's possibly faster, in rare cases. Since you can't name the iterator, an optimizer can more easily prove that your loop cannot modify the iterator. This affects e.g. loop unrolling optimizations.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "10825009", "Score": "3", "CreationDate": "2012-05-30T22:13:34.870", "LastActivityDate": "2012-05-30T22:13:34.870"}, "10821839": {"ParentId": "10821756", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><em>Range-for</em> is as fast as possible since it caches the end iterator<sup>[<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html#the-range-based-for-statement\" rel=\"nofollow noreferrer\">citation provided</a>]</sup>, uses pre-increment and only dereferences the iterator once. </p>\n<p>so if you tend to write:</p>\n<pre><code>for(iterator i = cont.begin(); i != cont.end(); i++) { /**/ }\n</code></pre>\n<p>Then, yes, range-for may be <em>slightly</em> faster, since it's also easier to write there's no reason not to use it (when appropriate).</p>\n<p><strong>N.B.</strong> I said it's as fast as possible, it isn't however <em>faster than possible</em>. You can achieve the exact same performance if you write your manual loops carefully.</p>\n", "OwnerUserId": "3848", "LastEditorUserId": "3848", "LastEditDate": "2014-06-12T11:55:33.587", "Id": "10821839", "Score": "22", "CreationDate": "2012-05-30T18:08:14.510", "LastActivityDate": "2014-06-12T11:55:33.587"}, "10821756": {"CommentCount": "3", "AcceptedAnswerId": "10822280", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2012-05-30T18:02:20.543", "LastActivityDate": "2014-06-12T11:55:33.587", "LastEditDate": "2014-06-12T10:56:22.410", "ViewCount": "10498", "FavoriteCount": "7", "Title": "Is the ranged based for loop beneficial to performance?", "Id": "10821756", "Score": "26", "Body": "<p>Reading various questions here on Stack\u00a0Overflow about C++ iterators and performance**, I started wondering if <code>for(auto&amp; elem : container)</code> gets \"expanded\" by the compiler into the best possible version? (Kind of like <code>auto</code>, which the compiler infers into the right type right away and is therefore never slower and sometimes faster).</p>\n<p>** For example, does it matter if you write </p>\n<pre><code>for(iterator it = container.begin(), eit = container.end(); it != eit; ++it)\n</code></pre>\n<p>or</p>\n<pre><code>for(iterator it = container.begin(); it != container.end(); ++it)\n</code></pre>\n<p>for non-invalidating containers?</p>\n", "Tags": "<c++><performance><for-loop><foreach><c++11>", "OwnerUserId": "595189", "AnswerCount": "5"}, "10821789": {"ParentId": "10821756", "CommentCount": "1", "Body": "<p>No. It is same as the old <code>for</code> loop with iterators. After all, the range-based <code>for</code> works with iterators internally. The compiler just produces equivalent code for both.</p>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "10821789", "Score": "5", "CreationDate": "2012-05-30T18:05:06.143", "LastActivityDate": "2012-05-30T18:05:06.143"}, "10822280": {"ParentId": "10821756", "CommentCount": "4", "Body": "<p>The Standard is your friend, see <strong>[stmt.ranged]</strong>/1</p>\n<blockquote>\n<p id=\"so_10821756_10822280_0\">For a range-based for statement of the form</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n</code></pre>\n<p id=\"so_10821756_10822280_1\">let range-init be equivalent to the expression surrounded by parentheses</p>\n<pre><code>( expression )\n</code></pre>\n<p id=\"so_10821756_10822280_2\">and for a range-based for statement of the form</p>\n<pre><code>for ( for-range-declaration : braced-init-list ) statement\n</code></pre>\n<p id=\"so_10821756_10822280_3\">let range-init be equivalent to the braced-init-list. In each case, a range-based <code>for</code> statement is equivalent to</p>\n<pre><code>{\n  auto &amp;&amp; __range = range-init;\n  for ( auto __begin = begin-expr,\n             __end = end-expr;\n        __begin != __end;\n        ++__begin )\n  {\n    for-range-declaration = *__begin;\n    statement\n  }\n}\n</code></pre>\n</blockquote>\n<p>So yes, the Standard guarantees that the best possible form is achieved.</p>\n<p>And for a number of containers, such as <code>vector</code>, it is UB to modify (insert/erase) them during this iteration.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "10822280", "Score": "24", "CreationDate": "2012-05-30T18:40:14.930", "LastActivityDate": "2012-05-30T18:40:14.930"}, "bq_ids": {"n4140": {"so_10821756_10822280_1": {"section_id": 3906, "quality": 0.8333333333333334, "length": 5}, "so_10821756_10822280_3": {"section_id": 3906, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_10821756_10822280_1": {"section_id": 3766, "quality": 0.8333333333333334, "length": 5}, "so_10821756_10822280_3": {"section_id": 3766, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_10821756_10822280_1": {"section_id": 4792, "quality": 0.6666666666666666, "length": 4}}}, "10821946": {"ParentId": "10821756", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Out of curiosity I decided to look at the assembly code for both approaches:</p>\n<pre><code>int foo1(const std::vector&lt;int&gt;&amp; v) {\n    int res = 0;\n    for (auto x : v)\n        res += x;\n    return res;\n}\n\nint foo2(const std::vector&lt;int&gt;&amp; v) {\n    int res = 0;\n    for (std::vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); ++it)\n      res += *it;\n    return res;\n}\n</code></pre>\n<p>And the assembly code (with -O3 and gcc 4.6) is exactly the same for both approaches (code for <code>foo2</code> is omitted, since it is exactly the same):</p>\n<pre><code>080486d4 &lt;foo1(std::vector&lt;int, std::allocator&lt;int&gt; &gt; const&amp;)&gt;:\n80486d4:       8b 44 24 04             mov    0x4(%esp),%eax\n80486d8:       8b 10                   mov    (%eax),%edx\n80486da:       8b 48 04                mov    0x4(%eax),%ecx\n80486dd:       b8 00 00 00 00          mov    $0x0,%eax\n80486e2:       39 ca                   cmp    %ecx,%edx\n80486e4:       74 09                   je     80486ef &lt;foo1(std::vector&lt;int, std::allocator&lt;int&gt; &gt; const&amp;)+0x1b&gt;\n80486e6:       03 02                   add    (%edx),%eax\n80486e8:       83 c2 04                add    $0x4,%edx\n80486eb:       39 d1                   cmp    %edx,%ecx\n80486ed:       75 f7                   jne    80486e6 &lt;foo1(std::vector&lt;int, std::allocator&lt;int&gt; &gt; const&amp;)+0x12&gt;\n80486ef:       f3 c3                   repz ret \n</code></pre>\n<p>So, yes, both approaches are the same.</p>\n<p><strong>UPDATE</strong>: The same observation holds for other containers (or element types) such as <code>vector&lt;string&gt;</code> and <code>map&lt;string, string&gt;</code>. In those cases, it is especially important to use a reference in the ranged-based loop. Otherwise a temporary is created and lots of extra code appears (in the previous examples it was not needed since the <code>vector</code> contained just <code>int</code> values).</p>\n<p>For the case of <code>map&lt;string, string&gt;</code> the C++ code snippet used is:</p>\n<pre><code>int foo1(const std::map&lt;std::string, std::string&gt;&amp; v) {\n    int res = 0;\n    for (const auto&amp; x : v) {\n        res += (x.first.size() + x.second.size());\n    }\n    return res;\n}\n\nint foo2(const std::map&lt;std::string, std::string&gt;&amp; v) {\n    int res = 0;\n    for (auto it = v.begin(), end = v.end(); it != end; ++it) {\n        res += (it-&gt;first.size() + it-&gt;second.size());\n    }\n    return res;\n}\n</code></pre>\n<p>And the assembly code (for both cases) is:</p>\n<pre><code>8048d70:       56                      push   %esi\n8048d71:       53                      push   %ebx\n8048d72:       31 db                   xor    %ebx,%ebx\n8048d74:       83 ec 14                sub    $0x14,%esp\n8048d77:       8b 74 24 20             mov    0x20(%esp),%esi\n8048d7b:       8b 46 0c                mov    0xc(%esi),%eax\n8048d7e:       83 c6 04                add    $0x4,%esi\n8048d81:       39 f0                   cmp    %esi,%eax\n8048d83:       74 1b                   je     8048da0 \n8048d85:       8d 76 00                lea    0x0(%esi),%esi\n8048d88:       8b 50 10                mov    0x10(%eax),%edx\n8048d8b:       03 5a f4                add    -0xc(%edx),%ebx\n8048d8e:       8b 50 14                mov    0x14(%eax),%edx\n8048d91:       03 5a f4                add    -0xc(%edx),%ebx\n8048d94:       89 04 24                mov    %eax,(%esp)\n8048d97:       e8 f4 fb ff ff          call   8048990 &lt;std::_Rb_tree_increment(std::_Rb_tree_node_base const*)@plt&gt;\n8048d9c:       39 c6                   cmp    %eax,%esi\n8048d9e:       75 e8                   jne    8048d88 \n8048da0:       83 c4 14                add    $0x14,%esp\n8048da3:       89 d8                   mov    %ebx,%eax\n8048da5:       5b                      pop    %ebx\n8048da6:       5e                      pop    %esi\n8048da7:       c3                      ret    \n</code></pre>\n", "OwnerUserId": "1135819", "LastEditorUserId": "1135819", "LastEditDate": "2012-05-30T23:13:15.257", "Id": "10821946", "Score": "17", "CreationDate": "2012-05-30T18:14:58.910", "LastActivityDate": "2012-05-30T23:13:15.257"}});