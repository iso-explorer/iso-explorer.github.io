post_cb({"33146310": {"Id": "33146310", "PostTypeId": "2", "Body": "<p>One option would be to give the class a pure virtual function, and mark it final:</p>\n<pre><code>struct A final\n{\n  virtual void nonconstructible() = 0;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a7174b8b17fcfb88\">[Live example]</a></p>\n", "LastActivityDate": "2015-10-15T10:39:10.133", "CommentCount": "7", "CreationDate": "2015-10-15T10:39:10.133", "ParentId": "33146096", "Score": "14", "OwnerUserId": "1782465"}, "33146096": {"ViewCount": "313", "Body": "<p>How can I prohibit the construction of an object? I mark <code>= delete;</code> all relevant special functions as follows:</p>\n<pre><code>struct A\n{\n    A() = delete;\n    A(A const &amp;) = delete;\n    A(A &amp;&amp;) = delete;\n    void * operator new(std::size_t) = delete;\n    void operator delete(void *) = delete;\n};\nA x{};\nA y = {};\nA * z = ::new A{};\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/b43ee3e03590be79\" rel=\"noreferrer\">LIVE EXAMPLE</a></kbd></p>\n<p>But <code>x</code>, <code>y</code> and <code>*z</code> can still exist. What to do? I am interested in both cases; static/stack allocation and heap allocation.</p>\n", "AcceptedAnswerId": "33146310", "Title": "How to prohibit the construction of object?", "CreationDate": "2015-10-15T10:28:13.063", "Id": "33146096", "CommentCount": "21", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-10-15T13:12:00.917", "LastEditorUserId": "3747990", "LastActivityDate": "2015-10-15T13:21:32.163", "Score": "8", "OwnerUserId": "1430927", "Tags": "<c++><c++11><memory-management><c++14><memory-layout>", "AnswerCount": "5"}, "33148575": {"Id": "33148575", "PostTypeId": "2", "Body": "<p>Essentially this compiles and is allowed because the type <code>A</code> is an aggregate type and the aggregate initialisation doesn't use default constructors.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow\">What is an aggregate type?</a>;</p>\n<blockquote>\n<p id=\"so_33146096_33148575_0\">class type (typically, struct or union), that has</p>\n<ul>\n<li>no private or protected members</li>\n<li>no user-provided constructors (explicitly defaulted or deleted constructors are allowed) (since C++11)</li>\n<li>no base classes</li>\n<li>no virtual member functions</li>\n</ul>\n</blockquote>\n<p>Giving it any one of the above would make it non-aggregate and thus the aggregate initialisation would not apply. Giving it a private user defined (and unimplemented) constructor will do.</p>\n<pre><code>struct A\n{\n    A() = delete;\n    A(A const &amp;) = delete;\n    A(A &amp;&amp;) = delete;\n    void * operator new(std::size_t) = delete;\n    void operator delete(void *) = delete;\nprivate:\n    A(int);\n};\n</code></pre>\n<hr>\n<p>As a side note; I hope this is a defect in the language specifications. At first look I thought that this should not compile, yet it does. One of the motivations for the <code>=delete</code> was to avoid the C++03 \"trick\" of declaring the constructors private to \"hide\" them and thus be unusable. I would expect a <code>=delete</code> on the default constructor to effectively prohibit class creation (outside other user defined constructors).</p>\n<hr>\n<p>For easier reading and clearer intent, consider even an empty base class;</p>\n<pre><code>struct NonAggregate{};\nstruct A : private NonAggregate\n{\n    //...\n</code></pre>\n<p>Maybe the simplest yet is to return to the C++03 style here, make the default constructor private;</p>\n<pre><code>struct A\n{\nprivate:\n    A(); // note no =delete...\n};\n</code></pre>\n</hr></hr>", "LastEditorUserId": "3747990", "LastActivityDate": "2015-10-15T13:21:32.163", "Score": "1", "CreationDate": "2015-10-15T12:27:19.860", "ParentId": "33146096", "CommentCount": "8", "OwnerUserId": "3747990", "LastEditDate": "2015-10-15T13:21:32.163"}, "bq_ids": {"n4140": {"so_33146096_33148575_0": {"length": 4, "quality": 0.8, "section_id": 4701}, "so_33146096_33146987_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 3274}}, "n3337": {"so_33146096_33148575_0": {"length": 4, "quality": 0.8, "section_id": 4510}, "so_33146096_33146987_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 3145}}, "n4659": {"so_33146096_33148575_0": {"length": 4, "quality": 0.8, "section_id": 6097}, "so_33146096_33146987_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 4032}}}, "33146317": {"Id": "33146317", "PostTypeId": "2", "Body": "<p>If you want to make it impossible to instantiate the class you could just declare private constructors:</p>\n<pre><code>class NotInstantiable {\nprivate:\n    NotInstatiable();\n\npublic:\n};\n</code></pre>\n<p>And not defining <code>NotInstantiable</code> further. This can't now be instantiated since first the constructor is <code>private</code> but also that a definition for the constructor has not been provided.</p>\n<p>The second obstacle for instantiate the <code>NotInstantiable</code> would for example prohibit this possibility, which in fact otherwise is a well known pattern:</p>\n<pre><code>class NotInstantiable {\nprivate:\n    NotInstantiable();\n\npublic:\n    NotInstantiable* evil_method()\n    {\n        return new NotInstantiable(); // this will fail if there's no body of the constructor.\n    }\n};\n</code></pre>\n", "LastEditorUserId": "4498329", "LastActivityDate": "2015-10-15T11:54:36.027", "Score": "6", "CreationDate": "2015-10-15T10:39:27.357", "ParentId": "33146096", "CommentCount": "1", "OwnerUserId": "4498329", "LastEditDate": "2015-10-15T11:54:36.027"}, "33146987": {"Id": "33146987", "PostTypeId": "2", "Body": "<p>In general, to completely prevent client code instantiation of a class you can declare the class <code>final</code> and either</p>\n<ul>\n<li><p>make the constructors non-<code>public</code>, or</p></li>\n<li><p>delete the constructors and make sure that the class isn't an aggregate, or</p></li>\n<li><p>add a pure virtual member function (e.g. make the destructor pure virtual) to make the class abstract.</p></li>\n</ul>\n<p>Declaring the class <code>final</code> is necessary when the non-<code>public</code> is <code>protected</code>, and for the abstract class, in order to prevent instantiation of a base class sub-object of a derived class.</p>\n<hr>\n<p>To partially prohibit instantiation, you can</p>\n<ul>\n<li>make the destructor non-<code>public</code>.</li>\n</ul>\n<p>This prevents automatic and static variables, but it does not prevent dynamic allocation with <code>new</code>.</p>\n<ul>\n<li>make the class' allocation function (the <code>operator new</code>) non-<code>public</code>.</li>\n</ul>\n<p>This prevents dynamic allocation via an ordinary <code>new</code>-expression in client code, but it does not provide automatic and static variables, or sub-objects of other objects, and it does not prevent dynamic allocation via a <code>::new</code>-expression, which uses the global allocation function.</p>\n<p>There are also other relevant techniques, such as an allocation function with extra arguments that make <code>new</code>-expressions inordinately complicated and impractical. I used that once to force the use of a special macro to dynamically allocate objects, e.g. for a <a href=\"http://en.cppreference.com/w/cpp/memory/enable_shared_from_this\" rel=\"nofollow noreferrer\">shared-from-this class</a>. But that was in the time before C++11 support for forwarding of arguments; nowadays an ordinary function can do the job, and such a function can be made a <code>friend</code> of the class.</p>\n<hr>\n<p><del>The fact that the code <a href=\"http://coliru.stacked-crooked.com/a/b43ee3e03590be79\" rel=\"nofollow noreferrer\">compiles with at least one version of the clang compiler</a> with <code>-std=gnu++1z</code>, is due to a bug and/or language extension in that compiler.</del></p>\n<p><del>The code should not compile, since it invokes the default constructor that has been deleted. And it does not compile with e.g. MinGW g++ 5.1.0, even with <code>-std=gnu++1z</code>.</del></p>\n<p>The fact that the code <a href=\"http://coliru.stacked-crooked.com/a/b43ee3e03590be79\" rel=\"nofollow noreferrer\">compiles with at least one version of the clang compiler</a> with <code>-std=gnu++1z</code>, may be due to a bug and/or language extension in that compiler. What the correct behavior is, is unclear because</p>\n<ul>\n<li><p>Although the code compiles with clang and with Visual C++ 2015, it does not compile with e.g. MinGW g++ 5.1.0, even with <code>-std=gnu++1z</code>.</p></li>\n<li><p>Intuitively the <code>delete</code> would be meaningless if the code should compile, but many meaningless constructs are permitted in C++.</p></li>\n<li><p>At issue is whether the class is an <em>aggregate</em> (in which case the <code>new</code> expression performs aggregate initialization), which rests on whether the deleted default constructor can be regarded as <em>user-provided</em>. And as user <a href=\"https://stackoverflow.com/users/496161/tartanllama\">TartanLlama</a> explains in comments, the requirements for <em>user-provided</em> are</p></li>\n</ul>\n\nC++11 \u00a78.4.2/4\n\n<blockquote>\n<p id=\"so_33146096_33146987_0\"><strong>\u201d</strong> A special member function is <em>user-provided</em> if it is user-declared and not explicitly\n  defaulted or deleted on its first declaration.</p>\n</blockquote>\n<p>I.e. although the <code>delete</code> of the default constructor in this question's example declares that constructor, it's not user-provided (and ditto for the other members) and so the class is an aggregate.</p>\n<p>The only defect report I can find about this wording is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1355\" rel=\"nofollow noreferrer\">DR 1355</a>, which however just concerns an issue with the use of the words \u201cspecial member\u201d, and proposes to drop those words. But, considering both the effect demonstrated by this question, and considering that a function can only be deleted on its first declaration, the wording is strange.</p>\n<p>Summing up, formally, as of C++11 (I haven't checked C++14), the code should compile. But this may be a defect in the standard, with the wording not reflecting the intent. And since MinGW g++ 5.1.0 doesn't compile the code, as of October 2015 <strong>it's not a good idea to rely on the code compiling</strong>.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-15T12:57:10.107", "Score": "3", "CreationDate": "2015-10-15T11:11:58.080", "ParentId": "33146096", "CommentCount": "9", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T12:23:37.587"}, "33146292": {"Id": "33146292", "PostTypeId": "2", "Body": "<ol>\n<li><p>If you want to have just <code>static</code> members, then write <code>namespace A</code> rather than <code>struct A</code>. Ensuing code will be syntactically similar.</p></li>\n<li><p>To prevent creation of an instance of a class, make it abstract. (Include one pure virtual function). But doing this introduces a v-table into you class, which you might not want.</p></li>\n</ol>\n", "LastActivityDate": "2015-10-15T10:37:52.483", "CommentCount": "2", "CreationDate": "2015-10-15T10:37:52.483", "ParentId": "33146096", "Score": "5", "OwnerUserId": "2380830"}});