post_cb({"17560078": {"Id": "17560078", "PostTypeId": "2", "Body": "<p>First, let's take a look at the relevant standards. It's always possible that C and C++ have different meanings for this keyword.</p>\n<p><strong>C++ 2011 Section 7.1.1 Paragraphs 2 and 3:</strong></p>\n<blockquote>\n<p id=\"so_17559774_17560078_0\">The register specifier shall be applied only to names of variables declared in a block (6.3) or to function parameters (8.4). It specifies that the named variable has automatic storage duration (3.7.3). A variable declared without a storage-class-specifier at block scope or declared as a function parameter has automatic storage duration by default.</p>\n<p id=\"so_17559774_17560078_1\">A register specifier is a hint to the implementation that the variable so declared will be heavily used. [ Note: The hint can be ignored and in most implementations it will be ignored if the address of the variable is taken. This use is deprecated (see D.2). \u2014 end note ]</p>\n</blockquote>\n<p><strong>C 2011 Section 6.7.1 Paragraph 6 and Footnote 121:</strong></p>\n<blockquote>\n<p id=\"so_17559774_17560078_2\">A declaration of an identifier for an object with storage-class specifier register suggests that access to the object be as fast as possible. The extent to which such suggestions are effective is implementation-defined.)</p>\n<p id=\"so_17559774_17560078_3\">The implementation may treat any register declaration simply as an auto declaration. However, whether or not addressable storage is actually used, the address of any part of an object declared with storage-class specifier register cannot be computed, either explicitly (by use of the unary &amp; operator as discussed in 6.5.3.2) or implicitly (by converting an array name to a pointer as discussed in 6.3.2.1). Thus, the only operators that can be applied to an array declared with storage-class specifier register are sizeof and _Alignof.</p>\n</blockquote>\n<p>So, let's take away what we've learned here.</p>\n<ul>\n<li>In C++, the register keyword has no meaning. It does function as a compiler hint, but it's suggested that most compilers will ignore that hint anyways.</li>\n<li>In C, the register keyword <strong>retains</strong> a meaning. Here, we are not, for example, allowed to take the address of an object (see the quoted footnote). An implementation may ignore the register hint, and place the object in memory anyways, but the keyword does restrict what you can do with the object. These restrictions should enable a compiler to better optimize access to the object, but it's also possible (like it is suggested in the C++ case), that the compiler will be able to infer this anyways.</li>\n</ul>\n<p>As to what you're seeing in practice:</p>\n<ul>\n<li>We can see why you're getting the syntax error in C when you try to take the address of a <code>register int</code>, so let's move past that.</li>\n<li>You claim to be seeing a performance difference in C++ depending on whether or not you use <code>register</code>. In this case, it would be good to show your test, because there may be problems in the test itself. If the full test is fine, then it certainly is possible that your compiler is using the hint to produce better code.</li>\n<li>The code you've shown is certainly odd though. That's because a compiler under optimizations will likely just remove the entire for loop from the code. The for loop has no side-effects. It's likely (and preferred) that a compiler will return identical code (that is, no code) with <code>for (int i=0; i&lt;100; ++i){}</code> and <code>for (register int i=0; i&lt;100; ++i) {}</code>.</li>\n</ul>\n", "LastEditorUserId": "47453", "LastActivityDate": "2013-07-09T23:41:59.620", "CommentCount": "0", "CreationDate": "2013-07-09T23:36:11.953", "ParentId": "17559774", "Score": "7", "OwnerUserId": "47453", "LastEditDate": "2013-07-09T23:41:59.620"}, "17559774": {"ViewCount": "5744", "Body": "<p>I know the concept of register variable and it's use cases but there are few questions in my mind based on what I have tried. </p>\n<ol>\n<li><p>I cannot access the address of a register variable in C though I can do it C++! Why? Is there any issue in accessing the addressing of a register variable?</p></li>\n<li><p>Suppose if I declare a string variable in C++ as register, then where will that variable be stored? What is the point in declaring the storage class of non-numeric data types such as 'string' in C++ to be register??</p></li>\n</ol>\n<p><strong>UPDATE:</strong>\nI thought that C++ allows us to fetch the address of a register variable, as I was not getting any error in my program which is as follows:</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;time.h&gt;\n\nusing namespace std;\n\nclock_t beg, en;\n\nint main(){\n\n    int j, k=0;\n\n    beg=clock();\n    for(register int i=0;i&lt;10000000;i++){\n        /*if(k==0){\n            cout&lt;&lt;&amp;i&lt;&lt;endl;    // if this code is uncommented, then C++ rejects the recommendation to make 'i' as register\n            k++;\n        }*/\n    }\n    en=clock();\n\n    cout&lt;&lt;en-beg&lt;&lt;endl;\n\n    cout&lt;&lt;&amp;j&lt;&lt;endl&lt;&lt;&amp;k;\n\n    return 0;\n}\n</code></pre>\n<p>What I have observed is, if I make the variable 'i' as register and don't try to print the address using '&amp;i' then C++ accepts the recommendation and stores 'i' in register, this can be infered from running time of for loop which will always be around 4-12 ms if 'i' is in register. But if I try to print address of variable 'i' then though I don't get any error but C++ rejects the recommendation and this can be infered from the time of execution of loop which is always more than 25 if i is not register!!</p>\n<p>So, basically I cannot fetch address of a variable with storage class as register in both C as well as C++!! WHY?</p>\n", "AcceptedAnswerId": "17559955", "Title": "address of register variable in C and C++", "CreationDate": "2013-07-09T23:06:00.870", "Id": "17559774", "CommentCount": "23", "LastEditDate": "2017-01-25T22:02:41.100", "PostTypeId": "1", "LastEditorDisplayName": "user7359847", "LastActivityDate": "2017-01-25T22:02:41.100", "Score": "3", "OwnerUserId": "1460747", "Tags": "<c++><c><gcc><g++><cpu-registers>", "AnswerCount": "7"}, "17559809": {"PostTypeId": "2", "Body": "<p>The basic answer is that, on most architectures, general purpose registers do not have memory addresses. In general, a pointer is simply a (virtual) memory address of the memory location containing the object. This is done of efficiency.</p>\n<p>It would be possible to extend the concept of a pointer to point to memory or register. However, doing so would decrease program speed as the code to dereference a pointer would need to check what type of location is being pointer to.</p>\n", "LastActivityDate": "2013-07-09T23:10:34.650", "Id": "17559809", "CommentCount": "0", "CreationDate": "2013-07-09T23:10:34.650", "ParentId": "17559774", "Score": "1", "OwnerUserId": "2112731"}, "bq_ids": {"n4140": {"so_17559774_17559955_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5393}, "so_17559774_17560078_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5392}, "so_17559774_17559963_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5393}, "so_17559774_17560078_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 5393}}, "n3337": {"so_17559774_17559955_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5187}, "so_17559774_17560078_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5186}, "so_17559774_17559963_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5187}, "so_17559774_17560078_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 5187}}}, "41859148": {"Id": "41859148", "PostTypeId": "2", "Body": "<p>In C, we cannot take the address of a variable with register storage. we need to store with normal variables name. </p>\n", "LastEditorUserId": "668125", "LastActivityDate": "2017-01-25T21:26:00.270", "CommentCount": "0", "CreationDate": "2017-01-25T18:40:00.780", "ParentId": "17559774", "Score": "0", "OwnerUserId": "5649154", "LastEditDate": "2017-01-25T21:26:00.270"}, "41861682": {"PostTypeId": "2", "Body": "<p>Many aspects of C stem from a desire to allow single-pass compilation.  Many early compilers would read a little source code, generate some assembly or machine code, forget most of what they just read, read a little more code, generate some more assembly/machine code, etc.  If the compiler is generating machine code it may need to build up a list of back-patches for things like forward jumps, but a compiler could generate code for functions which were bigger than its available RAM.</p>\n<p>Many machines have a few registers that could be dedicated to storing values, but a compiler would not be able to know what variables could be most usefully kept in registers at any given point in the code unless it knows how variables are going to be used later in the code.  Given something like:</p>\n<pre><code> void test(void)\n {\n   int i,j,*p;\n   p=&amp;i;\n   i=j=0;\n   do\n   {\n     j++;\n     *p+=10;\n     j++;\n     ...\n</code></pre>\n<p>a single-pass compiler would have no way of knowing whether it could safely keep <code>j</code> in a register across the access to <code>*p</code>.  Flushing <code>j</code> to memory before the <code>*p+=10;</code> and reloading it after would negate most of the advantage of allocating a register to it, but a compiler skipped the flush and reload but the above code were followed by <code>p=&amp;j;</code> it would have a problem.  All loop passes after the first would need to keep <code>j</code> in memory while executing <code>*p+=10;</code>, but the compiler would have already forgotten the code that would be required for the second pass.</p>\n<p>This issue was resolved by specifying that if a compiler is declared <code>register</code>, a compiler may safely generate code which assumes that no pointer-based accesses will affect it.  The prohibition against taking the address was IMHO needlessly over-reaching (*) but it was simpler to describe than one which would allow the qualifier to be used in more circumstances.</p>\n<p>(*)The semantics would be useful, even today, if <code>register</code> promised that a compiler could safely keep a variable in a register if it flushed it to memory when its address was taken, and held off on reloading it until the next time code used the variable, branched backward [via looping construct or goto], or entered a loop where the variable was used].</p>\n", "LastActivityDate": "2017-01-25T21:08:27.007", "Id": "41861682", "CommentCount": "0", "CreationDate": "2017-01-25T21:08:27.007", "ParentId": "17559774", "Score": "1", "OwnerUserId": "363751"}, "17559955": {"Id": "17559955", "PostTypeId": "2", "Body": "<p>C and C++ are different languages.</p>\n<ul>\n<li><p>In C, you cannot take the address of a variable with <code>register</code> storage. Cf. C11 6.7.1/6:</p>\n<blockquote>\n<p id=\"so_17559774_17559955_0\">A declaration of an identifier for an object with storage-class specifier <code>register</code>\n  suggests that access to the object be as fast as possible. The extent to which such\n  suggestions are effective is implementation-defined.</p>\n<p id=\"so_17559774_17559955_1\">Footnote:  The implementation may treat any <code>register</code> declaration simply as an <code>auto</code> declaration. [...]</p>\n</blockquote></li>\n<li><p>In C++, <code>register</code> is a deprecated, meaningless keyword that has no effect (except perhaps serve as a compiler hint), and variables declared as <code>register</code> still just have automatic storage. In particular, C++ <em>doesn't have</em> a \"register\" storage class. (It just has the storage class <em>specifier</em>, inherited from C.) Cf. C++11, 7.1.1/3:</p>\n<blockquote>\n<p id=\"so_17559774_17559955_2\">A <code>register</code> specifier is a hint to the implementation that the variable so declared will be heavily used. [ Note: The hint can be ignored and in most implementations it will be ignored if the address of the variable is taken. This use is deprecated [...]</p>\n</blockquote></li>\n</ul>\n<p>Even in C nothing is actually guaranteed about how register storage is implemented (implementations are free to treat <code>register</code> as <code>auto</code>), but the language rules apply regardless.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-07-09T23:30:04.210", "CommentCount": "12", "CreationDate": "2013-07-09T23:23:16.187", "ParentId": "17559774", "Score": "15", "OwnerUserId": "596781", "LastEditDate": "2013-07-09T23:30:04.210"}, "17559963": {"Id": "17559963", "PostTypeId": "2", "Body": "<p>Taking the address of a variable will FORCE the compiler to store it in a memory (unless it's an architecure where registers has an address - I think the TI 9900 series processors were implemented this way, but it's a vague memory from ca 1984). If you have told the compiler to use a <code>register</code>, that makes it incompatible. Although the C++ standard seems to suggest that the compiler isn't obliged to tell you so, and can in fact ignore the <code>register</code> keyword. </p>\n<p>C++11 draft n3337, section 7.1.1, bullet 3</p>\n<blockquote>\n<p id=\"so_17559774_17559963_0\">A register specifier is a hint to the implementation that the variable so declared will be heavily used.\n  [ Note: The hint can be ignored and in most implementations it will be ignored if the address of the variable\n  is taken. This use is deprecated (see D.2). \u2014 end note ]</p>\n</blockquote>\n<p>(Edit: Yes, the TMS 9900 does indeed have \"registers in memory\", so theoretically, you can have the address of a register in that architecture - but the architecture is much more that \"registers live in memory (which has an address)\" than \"registers have addresses\"). </p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2013-07-09T23:36:39.773", "CommentCount": "1", "CreationDate": "2013-07-09T23:24:10.940", "ParentId": "17559774", "Score": "3", "OwnerUserId": "1919155", "LastEditDate": "2013-07-09T23:36:39.773"}, "17559794": {"PostTypeId": "2", "Body": "<p>Precisely because it's a register.  An address is an address <em>of a memory location</em>.  If something is resident in a register it is by definition <em>not in main memory</em>.</p>\n", "LastActivityDate": "2013-07-09T23:08:43.650", "Id": "17559794", "CommentCount": "3", "CreationDate": "2013-07-09T23:08:43.650", "ParentId": "17559774", "Score": "0", "OwnerUserId": "178382"}});