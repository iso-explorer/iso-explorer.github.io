post_cb({"bq_ids": {"n4140": {"so_11712343_11712518_0": {"length": 51, "quality": 0.9107142857142857, "section_id": 2237}}, "n3337": {"so_11712343_11712518_0": {"length": 51, "quality": 0.9107142857142857, "section_id": 2225}}, "n4659": {"so_11712343_11712518_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 2510}}}, "11713807": {"Id": "11713807", "PostTypeId": "2", "Body": "<p>While reading the string members (due_name,loan_name) of your class budget your code literally fills them byte by byte. While it makes sense for floats and ints it won't work for strings.</p>\n<p>Strings are designed to keep 'unlimited' amount of text, therefore their constructors, copy constructors, concatenations and so on must ensure to allocate the actual piece of memory to store the text and expand it if necessary (and delete upon destruction). Filling strings this way from disk will result in invalid pointers inside your string objects (not pointing to the actual memory which contains the text), actually no text will be actually read this way at all.</p>\n", "LastActivityDate": "2012-07-29T23:17:48.530", "CommentCount": "0", "CreationDate": "2012-07-29T23:17:48.530", "ParentId": "11712343", "Score": "0", "OwnerUserId": "1560058"}, "11714139": {"Id": "11714139", "PostTypeId": "2", "Body": "<p>The easiest way to solve this is to not use C++ strings in that class.  Work out the maximum length for each of the strings you will be storing, and make a char array that is one byte longer (to allow for the 0-terminator).  Now you can read and write that class as binary without worrying about serialization etc.</p>\n<p>If you don't want to do that, you cannot use iostream::read() on your class.  You will need member functions that read/write to a stream.  This is what serialization is about...  But you don't need the complexity of <strong>boost</strong>.  In basic terms, you'd do something like:</p>\n<pre><code>// Read with no error checking :-S\nistream&amp; budget::read( istream&amp; s )\n{\n    s.read( (char*)&amp;balance, sizeof(balance) );\n    s.read( (char*)&amp;year, sizeof(year) );\n    s.read( (char*)&amp;month, sizeof(month) );\n    s.read( (char*)&amp;due_pay, sizeof(due_pay) );\n    s.read( (char*)&amp;loan_given, sizeof(loan_given) );\n\n    size_t length;\n    char *tempstr;\n\n    // Read due_name\n    s.read( (char*)&amp;length, sizeof(length) );\n    tempstr = new char[length];\n    s.read( tempstr, length );\n    due_name.assign(tempstr, length);\n    delete [] tempstr;\n\n    // Read loan_name\n    s.read( (char*)&amp;length, sizeof(length) );\n    tempstr = new char[length];\n    s.read( tempstr, length );\n    loan_name.assign(tempstr, length);\n    delete [] tempstr;\n\n    return s;\n}\n\nostream&amp; budget::write( ostream&amp; s )\n{\n    // etc...\n}\n</code></pre>\n<p>Notice above that we've serialized the strings by writing a size value first, and then that many characters after.</p>\n", "LastActivityDate": "2012-07-30T00:25:02.620", "CommentCount": "0", "CreationDate": "2012-07-30T00:25:02.620", "ParentId": "11712343", "Score": "0", "OwnerUserId": "1553090"}, "11712343": {"ViewCount": "1066", "Body": "<p>How to use C++ strings in file handling? I created a class that had C++ string as one of its private data members but that gave an error while reading from the file even if I am not manipulating with it at the moment and was initialised with default value in constructor. There is no problem while writing to the file. It works fine if I use C string instead but I don't want to. Is there a way to solve this?</p>\n<pre><code>class budget \n{      \n     float balance;      \n     string due_name,loan_name;              //string objects\n     int  year,month;     \n     float due_pay,loan_given;    \n\n     public:                 \n     budget()     \n     {      \n          balance=0;\n          month=1;        \n          due_name=\"NO BODY\";              //default values\n          loan_name=\"SAFE\";   \n          year=0;             \n          balance = 0;      \n          due_pay=0;        \n          loan_given=0;      \n     }\n      .\n      .\n      .\n };\n\nvoid read_balance()                //PROBLEM AFTER ENTERING THIS FUNCTION      \n{          \n     system(\"cls\");        \n     budget b;     \n     ifstream f1;     \n     f1.open(\"balance.dat\",ios::in|ios::binary);     \n     while(f1.read((char*)&amp;b,sizeof(b)))     \n     { b.show_data();       \n     }     \n     system(\"cls\");        \n     cout&lt;&lt;\"No More Records To Display!!\";     \n     getch();     \n     f1.close();       \n} \n</code></pre>\n", "Title": "Use C++ strings in file handling", "CreationDate": "2012-07-29T19:39:16.830", "LastActivityDate": "2014-08-25T09:36:44.037", "CommentCount": "8", "LastEditDate": "2014-08-25T09:36:44.037", "PostTypeId": "1", "LastEditorUserId": "321731", "Id": "11712343", "Score": "0", "OwnerUserId": "1558478", "Tags": "<c++><string><file-io>", "AnswerCount": "3"}, "11712518": {"Id": "11712518", "PostTypeId": "2", "Body": "<p>String is <code>non-POD data-type</code>. You cannot read/write from/in string by read/write functions.</p>\n<pre><code>basic_istream&lt;charT,traits&gt;&amp; read(char_type* s, streamsize n);\n</code></pre>\n<blockquote>\n<p id=\"so_11712343_11712518_0\">30 Effects: Behaves as an unformatted input function (as described in\n  27.7.2.3, paragraph 1). After constructing a sentry object, if !good() calls setstate(failbit) which may throw an exception, and return.\n  <strong>Otherwise extracts characters and stores them into successive\n  locations of an array whose first element is designated by s.323\n  Characters are extracted and stored until either of the following\n  occurs: \u2014 n characters are stored;</strong> \u2014 end-of-file occurs on the input\n  sequence (in which case the function calls setstate(failbit | eofbit),\n  which may throw ios_base::failure (27.5.5.4)). 31 Returns: *this.</p>\n</blockquote>\n<p>There is nothing about, how members of <code>std::string</code> placed. Look at, or use <code>boost::serialiation</code>. <a href=\"http://www.boost.org/doc/libs/1_50_0/libs/serialization/doc/index.html\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_50_0/libs/serialization/doc/index.html</a> And of course you can write size of string and then write data and when read - read size, allocate array of this size, read data in this array and then create string. But use boost is better.</p>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2012-07-29T20:24:11.683", "Score": "1", "CreationDate": "2012-07-29T20:07:25.117", "ParentId": "11712343", "CommentCount": "0", "OwnerUserId": "1498580", "LastEditDate": "2012-07-29T20:24:11.683"}});