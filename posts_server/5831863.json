post_cb({"5831915": {"ParentId": "5831863", "CommentCount": "10", "Body": "<p>Because the type of a polymorphic object in C++ is, basically, determined from the pointer to its vtable, which is the table of virtual functions. The vtable is, however, only created if there's at least one virtual method. Why? Because in C++, you never get what you didn't explicitly ask for. They call it \"you don't have to pay for something you don't need\". Don't need polymorphism? You just saved a vtable.</p>\n", "OwnerUserId": "20363", "PostTypeId": "2", "Id": "5831915", "Score": "19", "CreationDate": "2011-04-29T12:18:07.967", "LastActivityDate": "2011-04-29T12:18:07.967"}, "bq_ids": {"n4140": {"so_5831863_5832682_0": {"section_id": 7002, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_5831863_5832682_0": {"section_id": 6748, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_5831863_5832682_0": {"section_id": 8499, "quality": 0.9333333333333333, "length": 14}}}, "5832682": {"ParentId": "5831863", "CommentCount": "1", "Body": "<p>Because it is defined as such in the standard.</p>\n<p>From 10.3/1 <strong>[class.virtual]</strong></p>\n<blockquote>\n<p id=\"so_5831863_5832682_0\">Virtual functions support dynamic binding and object-oriented programming. A class that declares or inherits a virtual function is called a <em>polymorphic</em> class.</p>\n</blockquote>\n<p>It makes sense that if you use inheritance, then you have at least one virtual method. If you don't have any virtual method, then you could use composition instead.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "5832682", "Score": "3", "CreationDate": "2011-04-29T13:28:46.817", "LastActivityDate": "2011-04-29T13:28:46.817"}, "5831863": {"CommentCount": "1", "AcceptedAnswerId": "5831915", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-29T12:13:51.267", "LastActivityDate": "2011-05-05T13:35:18.960", "LastEditDate": "2017-05-23T12:32:14.707", "ViewCount": "4900", "FavoriteCount": "1", "Title": "C++: Why does a struct\\class need a virtual method in order to be polymorphic?", "Id": "5831863", "Score": "12", "Body": "<p>Following <a href=\"https://stackoverflow.com/questions/5831765/c-is-not-a-polymorphic-type-while-using-boostdynamic-pointer-cast\">this question</a>, I'm wondering why a struct\\class in C++ has to have a virtual method in order to be polymorphic.</p>\n<p>Forcing a virtual destructor makes sense, but if there's no destructor at all, why is it mandatory to have a virtual method?</p>\n", "Tags": "<c++><polymorphism><virtual-method>", "OwnerUserId": "348545", "AnswerCount": "8"}, "5832238": {"ParentId": "5831863", "CommentCount": "0", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/C++#Philosophy\" rel=\"nofollow\">A C++ design philosophy</a> is that \"you don't pay for what you don't use\". You might already know that a <code>virtual</code> function incur some overhead as a class has to maintain a pointer to its implementation. In fact, an object contains a reference to a table of function pointers called the vtable. </p>\n<p>Consider the following example:</p>\n<pre><code>class Base\n{\npublic:\n    virtual f() { /* do something */ }\n}; \n\nclass Derived : public Base\n{\npublic:\n    virtual f() { /* do something */ }\n}; \n\nBase* a = new Derived;\na-&gt;f(); // calls Derived::f()\n</code></pre>\n<p>Note that the variable <code>a</code> points to a <code>Derived</code> object. As <code>f()</code> is declared <code>virtual</code> the vtable of <code>a</code> will contain a pointer to <code>Derived::f()</code> and that implementation is executed. If <code>f()</code> is not <code>virtual</code>, the vtable will be empty. So <code>Base::f()</code> is executed as the type of <code>a</code> is <code>Base</code>.</p>\n<p>A destructor behaves just like other member functions. If the destructor is not <code>virtual</code>, only the destructor in the <code>Base</code> class will be called. This might lead to memory/resource leaks if the <code>Derived</code> class implements <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII</a>. If a class is intended to be sub-classed, its destructor should be <code>virtual</code>.</p>\n<p>In some languages like Java all methods are virtual. So even objects that are not intended to be polymorphic will consume memory for maintaining the function pointers. In other words, you are forced to pay for what you don't use.</p>\n", "OwnerUserId": "133520", "PostTypeId": "2", "Id": "5832238", "Score": "1", "CreationDate": "2011-04-29T12:47:38.503", "LastActivityDate": "2011-04-29T12:47:38.503"}, "5831909": {"ParentId": "5831863", "CommentCount": "10", "Body": "<p>polymorphism is to allow your subclasses to override the default behaviour of base class functions, so unless you have virtual methods in your base class, you can't override methods in base.</p>\n", "OwnerUserId": "279982", "PostTypeId": "2", "Id": "5831909", "Score": "2", "CreationDate": "2011-04-29T12:17:40.643", "LastActivityDate": "2011-04-29T12:17:40.643"}, "5831957": {"ParentId": "5831863", "CommentCount": "0", "Body": "<p>Without any virtual method, there is no need to maintain a <em>virtual pointer</em> (abbreviated as vptr) for every object of the class. The virtual pointer is a mechanism for resolving virtual method calls at runtime; depending on the object's class, it might point to different <em>virtual method tables</em> (abbreviated as vtable) that contain the actual adresses of virtual methods.</p>\n<p>So by checking to what vtable does the vptr point to, compiler can determine object's class, for example in <code>dynamic_cast</code>. Object without the vptr cannot have its type determined this way and is not polymorphic.</p>\n", "OwnerUserId": "434799", "PostTypeId": "2", "Id": "5831957", "Score": "1", "CreationDate": "2011-04-29T12:21:51.973", "LastActivityDate": "2011-04-29T12:21:51.973"}, "5831914": {"ParentId": "5831863", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_5831863_5831914_0\">I'm wondering why does a struct\\class in C++ has to have a virtual method in order to be polymorphic?</p>\n</blockquote>\n<p>Because that is what polymorphic class means.</p>\n<p>In C++, runtime polymorphism is achieved through virtual functions. A base class declares some virtual functions which  the many derived classes implement, and the clients use pointers (or references) of static type of base class, and can make them point to objects of derived classes (often different derived classes), and then later on, call the implementation of derived classes through the base pointers. That is how runtime polymorphism is achieved. And since the central role is played by the functions being <code>virtual</code>, which enables runtime polymorphism, that is why classes having virtual functions is called polymorphic class.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-04-29T12:25:23.940", "Id": "5831914", "Score": "2", "CreationDate": "2011-04-29T12:18:06.213", "LastActivityDate": "2011-04-29T12:25:23.940"}, "5832190": {"ParentId": "5831863", "CommentCount": "0", "Body": "<p>Classes only need virtual methods in order to be <em>dynamically</em> polymorphic - for the reasons described by others. You can still have static polymorphism through templates, though.</p>\n", "OwnerUserId": "667821", "PostTypeId": "2", "Id": "5832190", "Score": "0", "CreationDate": "2011-04-29T12:44:37.190", "LastActivityDate": "2011-04-29T12:44:37.190"}, "5831907": {"ParentId": "5831863", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_5831863_5831907_0\">Forcing a virtual destructor makes sense</p>\n</blockquote>\n<p>Exactly. To destruct a virtual class manually (via <code>delete</code>) through its base class you <em>need</em> a virtual destructor. (Now, as I\u2019ve been reminded in the comments, this isn\u2019t usually needed: rather than use manual memory management, one would rely on modern smart pointers which also work correctly with non-virtual destructors.)</p>\n<p>So any class which acts as a polymorphic base class usually needs either a virtual destructor or virtual functions anyway.</p>\n<p>And since having runtime polymorphism <em>adds an overhead</em> (the class needs to store an additional pointer to its virtual method table), the default is not to add it, unless necessary anyway: C++\u2019 design philosophy is \u201cyou only pay for what you need\u201d. Making every class have a virtual method table would run afoul of this principle.</p>\n", "OwnerUserId": "1968", "LastEditorUserId": "1968", "LastEditDate": "2011-04-29T13:21:36.887", "Id": "5831907", "Score": "8", "CreationDate": "2011-04-29T12:17:23.163", "LastActivityDate": "2011-04-29T13:21:36.887"}});