post_cb({"bq_ids": {"n4140": {"so_47921786_47921786_0": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_47921786_47922718_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 7202}, "so_47921786_47922765_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 7200}, "so_47921786_47921786_2": {"length": 5, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_47921786_47921786_0": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_47921786_47921786_2": {"length": 5, "quality": 1.0, "section_id": 6983}, "so_47921786_47922765_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 6944}, "so_47921786_47922718_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6946}}, "n4659": {"so_47921786_47921786_0": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_47921786_47921786_2": {"length": 5, "quality": 1.0, "section_id": 8748}, "so_47921786_47922765_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 8709}, "so_47921786_47922718_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 8711}}}, "47922765": {"Id": "47922765", "PostTypeId": "2", "Body": "<p>The <code>char(&amp;)[N]</code> case and <code>std::array&lt;char, N&gt;</code> case both result in undefined behavior. The reason has already been block-quoted by you. Note neither <code>char(&amp;)[N]</code> nor <code>std::array&lt;char, N&gt;</code> is the same type as <code>char</code>.</p>\n<p>I am not sure of the <code>char</code> case, because the current standard does not explicitly say that an object can be viewed as an array of narrow characters (see <a href=\"https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/std-discussion/JNp8xsgRbW4\" rel=\"nofollow noreferrer\">here</a> for further discussion). </p>\n<p>Anyway, if you want to access the underlying bytes of an object, use <code>std::memcpy</code>, as the standards explicitly says in <a href=\"http://www.eel.is/c++draft/basic.types#2\" rel=\"nofollow noreferrer\">[basic.types]/2</a>:</p>\n<blockquote>\n<p id=\"so_47921786_47922765_0\">For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object holds a valid value of type T, the underlying bytes ([intro.memory]) making up the object can be copied into an array of char, unsigned char, or <code>std\u200b::\u200bbyte</code> ([cstddef.syn]). If the content of that array is copied back into the object, the object shall subsequently hold its original value. [\u2009Example:</p>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj;                          // obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N);      // between these two calls to std\u200b::\u200bmemcpy, obj might be modified\nstd::memcpy(&amp;obj, buf, N);      // at this point, each subobject of obj of scalar type holds its original value\n</code></pre>\n<p id=\"so_47921786_47922765_1\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-12-21T15:13:31.033", "Score": "3", "CreationDate": "2017-12-21T10:21:15.853", "ParentId": "47921786", "CommentCount": "6", "OwnerUserId": "5376789", "LastEditDate": "2017-12-21T15:13:31.033"}, "47922718": {"Id": "47922718", "PostTypeId": "2", "Body": "<p>The strict aliasing rule is in fact very simple: <em>Two objects with overlapping lifetime cannot have overlapping storage region if one is not a suboject of the other</em>.(*)</p>\n<p>Nevertheless, it is allowed to read the memory representation of an object. The memory representation of an object is <em>a sequence of <code>unsigned char</code></em> [basic.types]/4:</p>\n<blockquote>\n<p id=\"so_47921786_47922718_0\">The <em>object representation</em> of an object of type T is the sequence of N <code>unsigned char</code> objects taken up by the object of type T, where N equals <code>sizeof(T)</code>.\n  The value representation of an object is the set of bits that hold the value of type T.</p>\n</blockquote>\n<p>Accordingly in your example:</p>\n<ul>\n<li><code>lam(str1)</code> is UB (Undefined Behavior);</li>\n<li><code>lam(str2)</code> is UB (an array and its first element are not <a href=\"http://eel.is/c++draft/basic.compound#4\" rel=\"nofollow noreferrer\">pointer interconvertible</a>);</li>\n<li><code>lam(str3)</code> is not stated as UB in the standard, if you replace <code>char</code> by <code>unsigned char</code> one could argue that you are reading the <em>object representation</em>. (it is not defined either, but it should work on all compilers)</li>\n</ul>\n<p>So using the third case and changing the declaration of <code>p</code> to <code>const unsigned char*</code> should always produce the expected result. For the other 2 cases, it can work with this simple example, but may break if the code is more complicated or on newer compiler version.</p>\n<hr>\n<p>(*) There are two exception to this rule: one for unions' members with common initialization sequence; and one for array of <code>unsigned char</code> or <code>std::byte</code> that <em>provides storage</em> for an other object.</p>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2017-12-21T16:22:01.847", "Score": "2", "CreationDate": "2017-12-21T10:18:45.397", "ParentId": "47921786", "CommentCount": "32", "OwnerUserId": "5632316", "LastEditDate": "2017-12-21T16:22:01.847"}, "47921786": {"ViewCount": "195", "Body": "<p>According to <a href=\"https://stackoverflow.com/questions/98650/#7005988\">this</a> stackoverflow answer about <strong>C++11/14</strong> strict alias rules:</p>\n<blockquote>\n<p id=\"so_47921786_47921786_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the\n  behavior is undefined:</p>\n<ul>\n<li><p id=\"so_47921786_47921786_1\">the dynamic type of the object,</p></li>\n<li><p id=\"so_47921786_47921786_2\">a cv-qualified version of the dynamic type of the object,</p></li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members\n  (including, recursively, an element or non-static data member of a\n  subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a <strong><code>char</code></strong> or <strong><code>unsigned char</code></strong> type.</li>\n</ul>\n</blockquote>\n<p>can we access the storage of other type using </p>\n<p>(1) <code>char *</code></p>\n<p>(2) <code>char(&amp;)[N]</code> </p>\n<p>(3) <code>std::array&lt;char, N&gt; &amp;</code> </p>\n<p>without depending on <strong>undefined behavior</strong>?</p>\n<pre><code>constexpr uint64_t lil_endian = 0x65'6e'64'69'61'6e; \n    // a.k.a. Clockwise-Rotated Endian which allocates like\n    // char[8] = { n,a,i,d,n,e,\\0,\\0 }\n\nconst auto&amp; arr =   // std::array&lt;char,8&gt; &amp;\n    reinterpret_cast&lt;const std::array&lt;char,8&gt; &amp;&gt; (lil_endian);\n\nconst auto&amp; carr =  // char(&amp;)[8]&gt;\n    reinterpret_cast&lt;const char(&amp;)[8]&gt;           (lil_endian);\n\nconst auto* p =     // char *\n    reinterpret_cast&lt;const char *&gt;(std::addressof(lil_endian));\n\nint main()\n{\n    const auto str1  = std::string(arr.crbegin()+2, arr.crend() );\n\n    const auto str2  = std::string(std::crbegin(carr)+2, std::crend(carr) );\n\n    const auto sv3r  = std::string_view(p, 8);\n    const auto str3  = std::string(sv3r.crbegin()+2, sv3r.crend() );\n\n    auto lam = [](const auto&amp; str) {\n        std::cout &lt;&lt; str &lt;&lt; '\\n'\n                  &lt;&lt; str.size() &lt;&lt; '\\n' &lt;&lt; '\\n' &lt;&lt; std::hex;\n        for (const auto ch : str) {\n            std::cout &lt;&lt; ch &lt;&lt; \" : \" &lt;&lt; static_cast&lt;uint32_t&gt;(ch) &lt;&lt; '\\n';\n        }\n        std::cout &lt;&lt; '\\n' &lt;&lt; '\\n' &lt;&lt; std::dec;\n    };\n\n    lam(str1);\n    lam(str2);\n    lam(str3);\n}\n</code></pre>\n<p>all lambda invocations produce:</p>\n<pre><code>endian\n6\n\ne : 65\nn : 6e\nd : 64\ni : 69\na : 61\nn : 6e\n</code></pre>\n<p><a href=\"https://gcc.godbolt.org/g/cdDTAM\" rel=\"nofollow noreferrer\">godbolt.org/g/cdDTAM</a> (enable -fstrict-aliasing -Wstrict-aliasing=2 )</p>\n<p><a href=\"https://wandbox.org/permlink/pGvPCzNJURGfEki7\" rel=\"nofollow noreferrer\">wandbox.org/permlink/pGvPCzNJURGfEki7</a></p>\n", "Title": "Do the c++11 strict alias rules allow accessing uint64_t via char *, char(&)[N],even std::array<char, N>& with -fstrict-aliasing -Wstrict-aliasing=2?", "CreationDate": "2017-12-21T09:26:07.810", "LastActivityDate": "2017-12-21T16:22:01.847", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-21T11:11:55.413", "LastEditorUserId": "6370128", "Id": "47921786", "Score": "4", "OwnerUserId": "6370128", "Tags": "<c++><c++11><language-lawyer><strict-aliasing>", "AnswerCount": "2"}});