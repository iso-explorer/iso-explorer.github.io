post_cb({"bq_ids": {"n4140": {"so_14012309_14012334_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 480}, "so_14012309_14012334_2": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}, "so_14012309_14012334_0": {"length": 21, "quality": 1.0, "section_id": 5997}}, "n3337": {"so_14012309_14012334_0": {"length": 21, "quality": 1.0, "section_id": 5765}, "so_14012309_14012334_2": {"length": 29, "quality": 1.0, "section_id": 472}, "so_14012309_14012334_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 471}}, "n4659": {"so_14012309_14012334_0": {"length": 21, "quality": 1.0, "section_id": 7498}, "so_14012309_14012334_2": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}, "so_14012309_14012334_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 502}}}, "14012309": {"ViewCount": "386", "Body": "<blockquote>\n<p id=\"so_14012309_14012309_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/13857611/what-happens-if-i-return-literal-instead-of-declared-stdstring\">What happens if I return literal instead of declared std::string?</a> </br></p>\n</blockquote>\n<p>Consider the following code</p>\n<pre><code>1| string getName () {\n2|     return \"meme\";\n3| }\n4| \n5| string name = getName();\n</code></pre>\n<p>The function getName() returns a temporary object. In c++03, I understand the copy constructor of \"string\" gets called and the temporary object is destroyed. Actually it seems compiler (atleast in gcc 4.7) optimizes line 5 by not creating the object \"name\" but replacing it with the temporary object itself and not destroying the temporary object (I tried with a MyVector class; not std::string).</p>\n<p>As defined in C++11 standards,<br>\n 1. Is getName() returning an rvalue?<br>\n 2. In line 5 above, which constructor of string gets called (move or copy) ?  Should I necessarily call std::move() for the move constructor to get called?<br>\n 3. With move semantics, is it less efficient then the \"copy elision\" optimization provided by the compiler?</br></br></br></p>\n", "AcceptedAnswerId": "14012334", "Title": "understanding c++11 rvalues, move semantics and performance", "CreationDate": "2012-12-23T15:45:04.117", "Id": "14012309", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:27:40.637", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-26T16:51:05.203", "ClosedDate": "2012-12-25T23:58:49.333", "Score": "11", "OwnerUserId": "420996", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "14012334": {"Id": "14012334", "PostTypeId": "2", "Body": "<ol>\n<li><p>Functions don't <em>return</em> rvalues or lvalues. The value categories apply to expressions. So an expression that <em>calls</em> a function may be an rvalue or lvalue. In this case, the expression <code>getName()</code> is an rvalue expression because the function <code>getName</code> returns an object by value. This comes from \u00a75.2.2/10:</p>\n<blockquote>\n<p id=\"so_14012309_14012334_0\">A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function type, an xvalue if the result type is an rvalue reference to object type, and <strong>a prvalue otherwise</strong>.</p>\n</blockquote>\n<p>Your functions result type is not an lvalue or rvalue reference, so the function call is a prvalue. prvalue expressions are a subset of rvalue expressions.</p></li>\n<li><p>The move constructor will be used (unless it is elided, which it may be). That's because <code>getName()</code> is an rvalue, so the constructor of <code>std::string</code> that takes an rvalue reference will better match the argument. Note that even if the move construction is elided, the move constructor must still be accessible. That is, the code must be compilable even if it is not elided.</p></li>\n<li><p>In general, the optimization of copy or move elision will completely get rid of any copying or moving. So of course it's faster than actually doing a move. If a move is elided, literally nothing happens. There will be no code emitted for that move. The compiler achieves this by directly constructing the object in the location it would be copied or moved to.</p></li>\n</ol>\n<p>It's worth mentioning that this could also be equivalently optimized:</p>\n<pre><code>string getName () {\n  std::string str(\"meme\");\n  return str;\n}\n\nstring name = getName();\n</code></pre>\n<p>Here, two moves will be elided (involving what is commonly known as <a href=\"http://www.efnetcpp.org/wiki/Return_value_optimization\" rel=\"nofollow\">Named Return Value Optimization</a>). There are two points to consider here. First, <code>return str;</code> meets the criteria for copy/move elision (\u00a712.8/31):</p>\n<blockquote>\n<p id=\"so_14012309_14012334_1\">This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>Second is that, although <code>str</code> is an lvalue, it will still be moved from because it fits a special case given by the standard (\u00a712.8/32):</p>\n<blockquote>\n<p id=\"so_14012309_14012334_2\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n", "LastEditorUserId": "150634", "LastActivityDate": "2012-12-26T16:51:05.203", "Score": "18", "CreationDate": "2012-12-23T15:49:55.350", "ParentId": "14012309", "CommentCount": "0", "LastEditDate": "2012-12-26T16:51:05.203", "OwnerUserId": "150634"}});