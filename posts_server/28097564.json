post_cb({"28097739": {"Id": "28097739", "PostTypeId": "2", "Body": "<p>As for the <strong>why</strong> part of the question, it's simple: the C (and C++) standards consider <code>double</code> to be the \"default\" floating point type. Not <code>float</code> (which is what many of us programmers default to when using floating point numbers).</p>\n<p>This can be seen by observing:</p>\n<ol>\n<li><code>3.14</code> is a <code>double</code> (if you want a <code>float</code>, you've got to take an extra step and append an <code>f</code>)</li>\n<li>The standard math functions take a <code>double</code> by default (for example, <code>sin()</code> takes a <code>double</code>; if you want a <code>float</code> you've got to use <code>sinf()</code>)</li>\n</ol>\n<p>With this, it seems more \"natural\" that a <code>float</code> would be promoted to <code>double</code> in a variadic function call, given that <code>double</code> is the \"natural\" default in the language.</p>\n", "LastActivityDate": "2015-01-22T20:07:13.650", "CommentCount": "2", "CreationDate": "2015-01-22T20:07:13.650", "ParentId": "28097564", "Score": "14", "OwnerUserId": "1287251"}, "41283997": {"Id": "41283997", "PostTypeId": "2", "Body": "<p>Given a function prototype, type float is only automatically promoted<sup>1</sup> when used in trailing arguments. Function print uses those: </p>\n<pre><code>int printf(const char * restrict format, ...);\n</code></pre>\n<hr>\n<p><sup>1</sup> (Quoted from: ISO/IEC 9899:201x 6.5.2.2 Function calls)<br>\n6. the integer promotions are performed on each argument, and arguments that\nhave type float are promoted to double. These are called the default argument\npromotions.<br>\n7. The default argument\npromotions are performed on trailing arguments.</br></br></p>\n</hr>", "LastEditorUserId": "4082723", "LastActivityDate": "2016-12-22T15:30:26.840", "Score": "13", "CreationDate": "2016-12-22T13:11:25.787", "ParentId": "28097564", "CommentCount": "0", "OwnerUserId": "4082723", "LastEditDate": "2016-12-22T15:30:26.840"}, "28097654": {"Id": "28097654", "PostTypeId": "2", "Body": "<p>Yes, float arguments to variadic function are promoted to double.</p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"noreferrer\">draft C99 standard</a> section <code>6.5.2.2</code> Function calls says:</p>\n<blockquote>\n<p id=\"so_28097564_28097654_0\">[...]and arguments that\n  have type float are promoted to double. These are called the default argument\n  promotions.[...]</p>\n</blockquote>\n<p>from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft C++ standard</a> section <code>5.2.2</code> Function call:</p>\n<blockquote>\n<p id=\"so_28097564_28097654_1\">[...]a floating point type that is subject to the floating point\n  promotion (4.6), the value of the argument is converted to the\n  promoted type before the call. [...]</p>\n</blockquote>\n<p>and section <code>4.6</code>:</p>\n<blockquote>\n<p id=\"so_28097564_28097654_2\">A prvalue of type float can be converted to a prvalue of type double. The value is unchanged</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w\" rel=\"noreferrer\">cppreference</a> covers the <a href=\"http://en.cppreference.com/w/cpp/language/variadic_arguments\" rel=\"noreferrer\">default conversions</a> for variadic function in C++ well:</p>\n<blockquote id=\"so_28097564_28097654_3\">\n<ul>\n<li>std::nullptr_t is converted to void*</li>\n<li>float arguments are converted to double as in floating-point promotion</li>\n<li>bool, char, short, and unscoped enumerations are converted to int or wider integer types as in integer promotion</li>\n</ul>\n</blockquote>\n<p>We can see in C and presumably in C++ this conversion was kept around for compatibility with <em>K&amp;R C</em>, from <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"noreferrer\">Rationale for International Standard\u2014Programming Languages\u2014C</a> (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_28097564_28097654_4\">For compatibility with past practice, all argument promotions occur as\n  described in K&amp;R in the absence of a prototype declaration, <strong>including\n  the not always desirable promotion of float to double</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-01-24T06:04:57.710", "Score": "20", "CreationDate": "2015-01-22T20:02:46.110", "ParentId": "28097564", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2015-01-24T06:04:57.710"}, "bq_ids": {"n4140": {"so_28097564_28097654_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 5994}, "so_28097564_28097654_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 28}, "so_28097564_28097654_1": {"length": 14, "quality": 1.0, "section_id": 5994}}, "n3337": {"so_28097564_28097654_0": {"length": 6, "quality": 0.5454545454545454, "section_id": 5762}, "so_28097564_28097654_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 25}, "so_28097564_28097654_1": {"length": 14, "quality": 1.0, "section_id": 5762}}, "n4659": {"so_28097564_28097654_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 28}, "so_28097564_28097654_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 7496}}}, "28097564": {"ViewCount": "1577", "Body": "<p>From a previous <a href=\"https://stackoverflow.com/questions/4264127/correct-format-specifier-for-double-in-printf?rq=1\">question</a>:</p>\n<blockquote>\n<p id=\"so_28097564_28097564_0\">If you attempt to pass a <code>float</code> to <code>printf</code>, it'll be promoted to <code>double</code>\n  before <code>printf</code> receives it</p>\n</blockquote>\n<p><code>printf()</code> is a variadic function right? So does a variadic function promote a <code>float</code> argument to a <code>double</code> before passing it?</p>\n", "AcceptedAnswerId": "28097654", "Title": "Why does printf() promote a float to a double?", "CreationDate": "2015-01-22T19:57:48.170", "LastActivityDate": "2015-01-24T06:12:23.330", "CommentCount": "19", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:54:09.597", "OwnerDisplayName": "user4420637", "LastEditorUserId": "-1", "Id": "28097564", "Score": "19", "Tags": "<c++><c><printf><variadic-functions>", "AnswerCount": "4"}, "41283834": {"Id": "41283834", "PostTypeId": "2", "Body": "<p>Because the (C99 or <a href=\"https://en.wikipedia.org/wiki/C11_%28C_standard_revision%29\" rel=\"nofollow noreferrer\">C11</a>) standard says so. See <a href=\"https://stackoverflow.com/a/41283997/841108\">answer by 2501</a>.</p>\n<p>There are several pragmatical reasons for that: history (first implementations of C have been used for system programming, where floating point operations don't matter), and the fact that on current (tablet, desktop, server...) processors, arithmetic operations on <code>double</code> are about as efficient as <code>float</code> (but some cheap microcontrollers don't have any FPU, or can only add <code>float</code> by hardware, and require a library for every operation on <code>double</code>). At last, I guess that such a rule enables slightly simpler <a href=\"https://en.wikipedia.org/wiki/Calling_convention\" rel=\"nofollow noreferrer\">calling conventions</a> and <a href=\"https://en.wikipedia.org/wiki/Application_binary_interface\" rel=\"nofollow noreferrer\">ABI</a>s.</p>\n<p>Think of <code>float</code> as a sort-of <code>short double</code> (which of course is <em>illegal</em> in C). A <code>float</code> is useful mostly when you need to compact memory (and can afford the loss of precision). See also <a href=\"http://floating-point-gui.de/\" rel=\"nofollow noreferrer\">http://floating-point-gui.de/</a> for more.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-22T13:44:13.177", "Score": "11", "CreationDate": "2016-12-22T13:03:29.723", "ParentId": "28097564", "CommentCount": "7", "OwnerUserId": "841108", "LastEditDate": "2017-05-23T11:54:09.597"}});