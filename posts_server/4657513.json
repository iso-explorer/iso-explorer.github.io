post_cb({"4657755": {"ParentId": "4657513", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-01-11T12:46:39.940", "Score": "4", "LastEditorUserId": "491260", "LastEditDate": "2011-01-11T14:51:53.063", "Id": "4657755", "OwnerUserId": "491260", "Body": "<p>Undefined behavior as far as I know. In VS 2010 with </p>\n<pre><code>/*\n* to disable iterator checking that complains that the iterators are incompatible (come from * different containers :-)\n*/\n#define _HAS_ITERATOR_DEBUGGING 0 \n\nstd::vector&lt;int&gt; vec1, vec2;\n\nstd::vector&lt;int&gt;::iterator it1 = vec1.begin();\nstd::vector&lt;int&gt;::iterator it2 = vec2.begin();\n\nif (it1 == it2)\n{\nstd::cout &lt;&lt; \"they are equal!!!\"; \n}\n</code></pre>\n<p>The equality test returns in this case true :-), since the containers are empty and the _Ptr member of the iterators are both nullptr. </p>\n<p>Who knows maybe your implementation does things differently and the test would return false :-).</p>\n<p>EDIT:</p>\n<p>See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2948.html\" rel=\"nofollow\">C++ Standard library Active Issues list</a> \"446. Iterator equality between different containers\". Maybe someone can check the standard to see if the change was adopted?</p>\n<p>Probably not since it is on the active issues list so Charles Bailey who also answered this is right it's unspecified behavior. </p>\n<p>So I guess the behavior could differ (at least theoretically) between different implementations and this is only one problem. </p>\n<p>The fact that with iterator debugging enabled in the STL implementation that comes with VS checks are in place for this exact case (iterators coming from different containers) singnals at least to me once more that doing such comparisons should be avoided whenever possible.</p>\n", "LastActivityDate": "2011-01-11T14:51:53.063"}, "4657513": {"CommentCount": "1", "AcceptedAnswerId": "4664519", "CreationDate": "2011-01-11T12:18:02.010", "LastActivityDate": "2011-01-12T01:18:44.060", "PostTypeId": "1", "ViewCount": "5535", "FavoriteCount": "2", "Title": "comparing iterators from different containers", "Id": "4657513", "Score": "28", "Body": "<p>Is it legal to compare iterators from different containers?</p>\n<pre><code>std::vector&lt;int&gt; foo;\nstd::vector&lt;int&gt; bar;\n</code></pre>\n<p>Does the expression <code>foo.begin() == bar.begin()</code> yield false or undefined behavior?</p>\n<p>(I am writing a custom iterator and stumbled upon this question while implementing <code>operator==</code>.)</p>\n", "Tags": "<c++><stl><comparison><iterator>", "OwnerUserId": "252000", "AnswerCount": "7"}, "4657690": {"ParentId": "4657513", "CommentCount": "5", "Body": "<p>You cannot directly compare iterators from different containers. An iterator is an object that uses the <em>internal state</em> of a container to traverse it; comparing the internals of one container to another simply does not make sense.</p>\n<p>However, if the iterators resulting from <code>container.begin()</code> are available, it <em>may</em> make sense to compare iterators by the count of objects traversed from <code>begin()</code> to the current iterator value. This is done using <code>std::distance</code>:</p>\n<pre><code>int a = std::distance(containerA.begin(), iteratorA);\nint b = std::distance(containerB.begin(), iteratorB);\n\nif (a &lt;comparison&gt; b)\n{ /* ... */ }\n</code></pre>\n<p>Without more context, it's difficult to judge whether this would solve your problem or not. YMMV.</p>\n", "OwnerUserId": "230575", "PostTypeId": "2", "Id": "4657690", "Score": "3", "CreationDate": "2011-01-11T12:39:37.120", "LastActivityDate": "2011-01-11T12:39:37.120"}, "4657740": {"ParentId": "4657513", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-01-11T12:44:50.300", "Score": "0", "LastEditorUserId": "524436", "LastEditDate": "2011-01-11T13:03:39.480", "Id": "4657740", "OwnerUserId": "524436", "Body": "<p>I don't get the requirements on input iterators from the standard 100%, but from there on (forward/bidirectional/random access iterators) there are no requirements on the domain of ==, so it must <strike>return false</strike> <em>result in an equivalence relation</em>. You can't do &lt; or &gt; or subtraction on iterators from different containers though.</p>\n<p>Edit: It does not have to return false, it has to result in an equivalence relation, this allows <code>.begin()</code> of two empty containers to compare equal (as shown in another answer). If the iterators are dereferencable, <code>a == b =&gt; *a == *b</code> has to hold. It's still not undefined behaviour.</p>\n", "LastActivityDate": "2011-01-11T13:03:39.480"}, "4657700": {"ParentId": "4657513", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-01-11T12:40:23.480", "Score": "0", "LastEditorUserId": "528724", "LastEditDate": "2011-01-11T12:59:15.670", "Id": "4657700", "OwnerUserId": "528724", "Body": "<p>ISO/IEC 14882:2003(E) 5.10.1</p>\n<blockquote>\n<p id=\"so_4657513_4657700_0\">The == (equal to) and the != (not equal to) operators have the same semantic restrictions, conversions, and result type as the relational operators except for their lower precedence and truth-value result. [ .. ] Pointers to objects or functions of the same type (after pointer conversions) can be compared for equality. Two pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address (3.9.2).</p>\n</blockquote>\n<p>Simulation Results on XCode (3.2.3):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector &lt;int&gt; a,aa;\n    std::vector &lt;float&gt; b;\n\n    if( a.begin() == aa.begin() )\n        std::cout &lt;&lt; \"\\n a.begin() == aa.begin() \\n\" ;\n\n    a.push_back(10) ;\n\n    if( a.begin() != aa.begin() )\n        std::cout &lt;&lt; \"\\n After push back a.begin() != aa.begin() \\n\" ;\n\n    // Error if( a.begin() == b.begin() )   \n\n    return 0;\n}\n</code></pre>\n<p>Output :</p>\n<blockquote>\n<p id=\"so_4657513_4657700_1\">a.begin() == aa.begin()<br>\n  After push back a.begin() != aa.begin()</br></p>\n</blockquote>\n", "LastActivityDate": "2011-01-11T12:59:15.670"}, "4658175": {"ParentId": "4657513", "CommentCount": "2", "Body": "<p>I believe that it is unspecified behaviour (C++03). <code>std::vector</code> iterators are random access iterators and the behaviour of <code>==</code> is defined in the requirements for forward iterators.</p>\n<blockquote>\n<p id=\"so_4657513_4658175_0\">== is an equivalence relation</p>\n</blockquote>\n<p>Note that this is a requirement on a type, so must be applicable (in this case) to any pair of valid (dereferencable or otherwise) <code>std::vector::iterator</code>s. I believe that this means <code>==</code> must give you a <code>true</code>/<code>false</code> answer and can't cause UB.</p>\n<blockquote>\n<p id=\"so_4657513_4658175_1\">\u2014 If a and b are equal, then either a and b are both dereferenceable or else neither is dereferenceable.</p>\n</blockquote>\n<p>Conversely, a dereferenceable iterator cannot compare equal to an iterator that is not dereferenceable.</p>\n<blockquote>\n<p id=\"so_4657513_4658175_2\">\u2014 If a and b are both dereferenceable, then a == b if and only if *a and *b are the same object.</p>\n</blockquote>\n<p>Note the lack of requirement on whether <code>a == b</code> for two iterators that aren't dereferenceable. So long as <code>==</code> is transitive (if <code>a.end() == b.end()</code> and <code>b.end() == c.end()</code> then <code>a.end() == c.end()</code>), reflexive (<code>a.end() == a.end()</code>) and symmetric (if <code>a.end() == b.end()</code> then <code>b.end() == a.end()</code>) it doesn't matter if some, all or no <code>end()</code> iterators to different containers compare equal.</p>\n<p>Note, also, that this is in contrast to <code>&lt;</code>. <code>&lt;</code> is defined in terms of <code>b - a</code>, where <code>a</code> and <code>b</code> are both random access iterators. A pre-condition of performing <code>b - a</code> is that there must be a <code>Distance</code> value <code>n</code> such that <code>a + n == b</code> which requires <code>a</code> and <code>b</code> to be iterators into the same range.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "4658175", "Score": "2", "CreationDate": "2011-01-11T13:35:05.470", "LastActivityDate": "2011-01-11T13:35:05.470"}, "4657534": {"ParentId": "4657513", "CommentCount": "12", "Body": "<p>No. If it were legal, this would imply that pointers would not be iterators.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "4657534", "Score": "1", "CreationDate": "2011-01-11T12:19:52.990", "LastActivityDate": "2011-01-11T12:19:52.990"}, "bq_ids": {"n4140": {"so_4657513_4664519_0": {"section_id": 5560, "quality": 0.9375, "length": 15}, "so_4657513_4658175_1": {"section_id": 5577, "quality": 1.0, "length": 8}, "so_4657513_4664519_1": {"section_id": 5574, "quality": 0.8888888888888888, "length": 8}, "so_4657513_4658175_2": {"section_id": 5578, "quality": 1.0, "length": 5}}, "n3337": {"so_4657513_4664519_0": {"section_id": 5342, "quality": 0.9375, "length": 15}, "so_4657513_4658175_1": {"section_id": 5359, "quality": 1.0, "length": 8}, "so_4657513_4664519_1": {"section_id": 5356, "quality": 0.8888888888888888, "length": 8}, "so_4657513_4658175_2": {"section_id": 5360, "quality": 1.0, "length": 5}, "so_4657513_4657700_0": {"section_id": 5917, "quality": 0.9166666666666666, "length": 44}}, "n4659": {"so_4657513_4664519_0": {"section_id": 7007, "quality": 0.9375, "length": 15}, "so_4657513_4664519_1": {"section_id": 7021, "quality": 0.8888888888888888, "length": 8}, "so_4657513_4658175_2": {"section_id": 7025, "quality": 1.0, "length": 5}, "so_4657513_4658175_1": {"section_id": 7024, "quality": 1.0, "length": 8}}}, "4664519": {"ParentId": "4657513", "CommentCount": "1", "Body": "<p>If you consider the C++0x draft:</p>\n<p>\u00a7 24.2.1</p>\n<blockquote>\n<p id=\"so_4657513_4664519_0\">An iterator j is called reachable from an iterator i if and only if there is a finite sequence of applications of the expression ++i that makes i == j. If j is reachable from i, they refer to elements of the same sequence.</p>\n</blockquote>\n<p>\u00a7 24.2.5</p>\n<blockquote>\n<p id=\"so_4657513_4664519_1\">The domain of == for forward iterators is that of iterators over the same underlying sequence.</p>\n</blockquote>\n<p>Given that <code>RandomAccessIterator</code> must satisfy all requirements imposed by <code>ForwardIterator</code>, comparing iterators from different containers is undefined.</p>\n", "OwnerUserId": "298054", "PostTypeId": "2", "Id": "4664519", "Score": "27", "CreationDate": "2011-01-12T01:18:44.060", "LastActivityDate": "2011-01-12T01:18:44.060"}});