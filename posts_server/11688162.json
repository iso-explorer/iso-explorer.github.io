post_cb({"11688162": {"CommentCount": "6", "AcceptedAnswerId": "11689878", "PostTypeId": "1", "LastEditorUserId": "57428", "CreationDate": "2012-07-27T12:52:22.620", "LastActivityDate": "2012-08-01T09:28:42.233", "LastEditDate": "2012-07-27T14:10:40.947", "ViewCount": "747", "FavoriteCount": "3", "Title": "Is %p specifier only for valid pointers?", "Id": "11688162", "Score": "20", "Body": "<p>Suppose on my platform <code>sizeof(int)==sizeof(void*)</code> and I have this code:</p>\n<pre><code>printf( \"%p\", rand() );\n</code></pre>\n<p>Will this be undefined behavior because of passing a value that is not a valid pointer in place of <code>%p</code>?</p>\n", "Tags": "<c++><pointers><reinterpret-cast>", "OwnerUserId": "57428", "AnswerCount": "4"}, "11688435": {"ParentId": "11688162", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>C standard, 7.21.6.1, The <code>fprintf</code> function, states just</p>\n<blockquote>\n<p id=\"so_11688162_11688435_0\"><code>p</code>  The argument shall be a pointer to <code>void</code>.</p>\n</blockquote>\n<p>By Appendix J.2, this is a <em>constraint</em>, and violating a constraint causes UB.</p>\n<p>(Below is my previous reasoning why this should be UB, which was too complicated.)</p>\n<p><del>That paragraph does not describe how the <code>void*</code> is retrieved from the <code>...</code>, but the only way that the C standard itself offers for this purpose is 7.16.1.1, The <code>va_arg</code> macro, which warns us that</del></p>\n<blockquote>\n<p id=\"so_11688162_11688435_1\"><del>if <em>type</em> is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the behavior is undefined</del></p>\n</blockquote>\n<p>If you read 6.2.7, Compatible type and composite type, then there's no hint that <code>void*</code> and <code>int</code> should be compatible, regardless of their size. So, I'd say that since <code>va_arg</code> is the only way to implement <code>printf</code> <em>in standard C</em>, the behavior is undefined.</p>\n", "OwnerUserId": "166749", "LastEditorUserId": "166749", "LastEditDate": "2012-08-01T09:28:42.233", "Id": "11688435", "Score": "13", "CreationDate": "2012-07-27T13:11:08.340", "LastActivityDate": "2012-08-01T09:28:42.233"}, "11688363": {"ParentId": "11688162", "CommentCount": "1", "Body": "<p>%p is just a output format specification for printf. It doesn't need to dereference or validate the pointer in any way, although some compilers issue a warning if the type is not a pointer:</p>\n<pre><code>int main(void)\n{\n    int t = 5;\n    printf(\"%p\\n\", t);\n}\n</code></pre>\n<p>Compilation warning:</p>\n<pre><code>warning: format \u2018%p\u2019 expects argument of type \u2018void*\u2019, but argument 2 has type \u2018int\u2019 [-Wformat]\n</code></pre>\n<p>Outputs:</p>\n<pre><code>0x5\n</code></pre>\n", "OwnerUserId": "1554554", "PostTypeId": "2", "Id": "11688363", "Score": "-2", "CreationDate": "2012-07-27T13:06:22.800", "LastActivityDate": "2012-07-27T13:06:22.800"}, "11689878": {"ParentId": "11688162", "CommentCount": "0", "Body": "<p>To expand upon @larsman's answer (which says that since you violated a constraint, the behavior is undefined), here's an actual C implementation where <code>sizeof(int) == sizeof(void*)</code>, yet the code is not equivalent to <code>printf( \"%p\", (void*)rand() );</code></p>\n<p>The Motorola 68000 processor has 16 registers which are used for general computation, but they are not equivalent. Eight of them (named <code>a0</code> through <code>a7</code>) are used for accessing memory (address registers) and the other eight (<code>d0</code> through <code>d7</code>) are used for arithmetic (data registers). A valid calling convention for this architecture would be</p>\n<ol>\n<li>Pass the first two integer parameters in <code>d0</code> and <code>d1</code>; pass the rest on the stack.</li>\n<li>Pass the first two pointer parameters in <code>a0</code> and <code>a1</code>; pass the rest on the stack.</li>\n<li>Pass all other types on the stack, regardless of size.</li>\n<li>Parameters passed on the stack are pushed right-to-left regardless of type.</li>\n<li>Stack-based parameters are aligned on 4-byte boundaries.</li>\n</ol>\n<p>This is a perfectly legal calling convention, similar to calling conventions used by many modern processors.</p>\n<p>For example, to call the function <code>void foo(int i, void *p)</code>, you would pass <code>i</code> in <code>d0</code> and <code>p</code> in <code>a0</code>.</p>\n<p>Note that to call the function <code>void bar(void *p, int i)</code>, you would also pass <code>i</code> in <code>d0</code> and <code>p</code> in <code>a0</code>.</p>\n<p>Under these rules, <code>printf(\"%p\", rand())</code> would pass the format string in <code>a0</code> and the random number parameter in <code>d0</code>. On the other hand, <code>printf(\"%p\", (void*)rand())</code> would pass the format string in <code>a0</code> and the random pointer parameter in <code>a1</code>.</p>\n<p>The <code>va_list</code> structure would look like this:</p>\n<pre><code>struct va_list {\n    int d0;\n    int d1;\n    int a0;\n    int a1;\n    char *stackParameters;\n    int intsUsed;\n    int pointersUsed;\n};\n</code></pre>\n<p>The first four members are initialized with the corresponding entry values of the registers. The <code>stackParameters</code> points to the first stack-based parameters passed via the <code>...</code>, and the <code>intsUsed</code> and <code>pointersUsed</code> are initialized to the number of named parameters which are integers and pointers, respectively.</p>\n<p>The <code>va_arg</code> macro is a compiler intrinsic which generates different code based on the expected parameter type.</p>\n<ul>\n<li>If the parameter type is a pointer, then <code>va_arg(ap, T)</code> expands to <code>(T*)get_pointer_arg(&amp;ap)</code>.</li>\n<li>If the parameter type is an integer, then <code>va_arg(ap, T)</code> expands to <code>(T)get_integer_arg(&amp;ap)</code>.</li>\n<li>If the parameter type is something else, then <code>va_arg(ap, T)</code> expands to <code>*(T*)get_other_arg(&amp;ap, sizeof(T))</code>.</li>\n</ul>\n<p>The <code>get_pointer_arg</code> function goes like this:</p>\n<pre><code>void *get_pointer_arg(va_list *ap)\n{\n    void *p;\n    switch (ap-&gt;pointersUsed++) {\n    case 0: p = ap-&gt;a0; break;\n    case 1: p = ap-&gt;a1; break;\n    case 2: p = *(void**)get_other_arg(ap, sizeof(p)); break;\n    }\n    return p;\n}\n</code></pre>\n<p>The <code>get_integer_arg</code> function goes like this:</p>\n<pre><code>int get_integer_arg(va_list *ap)\n{\n    int i;\n    switch (ap-&gt;intsUsed++) {\n    case 0: i = ap-&gt;d0; break;\n    case 1: i = ap-&gt;d1; break;\n    case 2: i = *(int*)get_other_arg(ap, sizeof(i)); break;\n    }\n    return i;\n}\n</code></pre>\n<p>And the <code>get_other_arg</code> function goes like this:</p>\n<pre><code>void *get_other_arg(va_list *ap, size_t size)\n{\n    void *p = ap-&gt;stackParameters;\n    ap-&gt;stackParameters += ((size + 3) &amp; ~3);\n    return p;\n}\n</code></pre>\n<p>As noted earlier, calling <code>printf(\"%p\", rand())</code> would pass the format string in <code>a0</code> and the random integer in <code>d0</code>. But when the <code>printf</code> function executes, it will see the <code>%p</code> format and perform a <code>va_arg(ap, void*)</code>, which will use <code>get_pointer_arg</code> and read the parameter from <code>a1</code> instead of <code>d0</code>. Since <code>a1</code> was not initialized, it contains garbage. The random number you generated is ignored.</p>\n<p>Taking the example further, if you had <code>printf(\"%p %i %s\", rand(), 0, \"hello\");</code> this would be called as follows:</p>\n<ul>\n<li><code>a0</code> = address of format string (first pointer parameter)</li>\n<li><code>a1</code> = address of string <code>\"hello\"</code> (second pointer parameter)</li>\n<li><code>d0</code> = random number (first integer parameter)</li>\n<li><code>d1</code> = 0 (second integer parameter)</li>\n</ul>\n<p>When the <code>printf</code> function executes, it reads the format string from <code>a0</code> as expected. When it sees the <code>%p</code> it will retrieve the pointer from <code>a1</code> and print it, so you get the address of the string <code>\"hello\"</code>.  Then it will see the <code>%i</code> and retrieve the parameter from <code>d0</code>, so it prints a random number. Finally, it sees the <code>%s</code> and retrieves the parameter from the stack. But you didn't pass any parameters on the stack! This will read undefined stack garbage, which will most likely crash your program when it tries to print it as if it were a string pointer.</p>\n", "OwnerUserId": "902497", "PostTypeId": "2", "Id": "11689878", "Score": "20", "CreationDate": "2012-07-27T14:28:49.487", "LastActivityDate": "2012-07-27T14:28:49.487"}, "bq_ids": {"n4140": {"so_11688162_11688435_1": {"section_id": 7043, "quality": 0.5384615384615384, "length": 7}, "so_11688162_11688331_0": {"section_id": 7187, "quality": 0.9090909090909091, "length": 10}, "so_11688162_11688331_1": {"section_id": 7183, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_11688162_11688435_1": {"section_id": 6788, "quality": 0.5384615384615384, "length": 7}, "so_11688162_11688331_0": {"section_id": 6927, "quality": 0.9090909090909091, "length": 10}, "so_11688162_11688331_1": {"section_id": 6927, "quality": 1.0, "length": 6}}, "n4659": {"so_11688162_11688331_0": {"section_id": 8695, "quality": 0.9090909090909091, "length": 10}, "so_11688162_11688331_1": {"section_id": 8671, "quality": 0.8333333333333334, "length": 5}}}, "11688331": {"ParentId": "11688162", "CommentCount": "2", "Body": "<p>Yes, it's undefined. From C++11, 3.7.4.2/4:</p>\n<blockquote>\n<p id=\"so_11688162_11688331_0\">The effect of using an invalid pointer value (including passing it to a deallocation function) is undefined.</p>\n</blockquote>\n<p>with a footnote:</p>\n<blockquote>\n<p id=\"so_11688162_11688331_1\">On some implementations, it causes a system-generated runtime fault.</p>\n</blockquote>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "11688331", "Score": "5", "CreationDate": "2012-07-27T13:04:21.050", "LastActivityDate": "2012-07-27T13:04:21.050"}});