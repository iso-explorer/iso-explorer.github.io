post_cb({"28199177": {"CommentCount": "0", "AcceptedAnswerId": "28201770", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-28T17:59:40.347", "LastActivityDate": "2015-01-28T20:27:16.517", "LastEditDate": "2017-05-23T12:29:51.823", "ViewCount": "158", "FavoriteCount": "1", "Title": "Is returning uniform initialized reference valid?", "Id": "28199177", "Score": "7", "Body": "<p><strong>Is this code sample valid?</strong></p>\n<pre><code>using ref = char&amp;;\n\nref foo(ref x) {\n  return ref{x};\n}\n\nint main() {\n  char a;\n  foo(a);\n  return 0;\n}\n</code></pre>\n<p>seems that:</p>\n<ul>\n<li>clang 3.5 says YES</li>\n<li><p>gcc 4.9 says NO</p>\n<pre><code>main.cpp: In function 'char&amp; foo(ref)':\nmain.cpp:4:15: error: invalid cast of an rvalue expression of type 'char' to type 'ref {aka char&amp;}'\n   return ref{x};\n               ^\n</code></pre></li>\n</ul>\n<p><a href=\"http://coliru.stacked-crooked.com/a/cb6604b81083393f\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/cb6604b81083393f</a></p>\n<p><strong>So which compiler is right? or is it unspecified?</strong></p>\n<p>It very easy so overcome gcc build error by:</p>\n<ol>\n<li><p>using parenthesis instead of braces</p>\n<pre><code>ref foo(ref x) {\n  return ref(x);\n}\n</code></pre></li>\n<li><p>by naming returned value</p>\n<pre><code>ref foo(ref x) {\n  ref ret{x};\n  return ret;\n}\n</code></pre></li>\n</ol>\n<p>option 1. breaks uniform initialization, option 2. adds useless line of code.</p>\n<p>Similar question was already aked here:\n<a href=\"https://stackoverflow.com/questions/10509603/why-cant-i-initialize-a-reference-in-an-initializer-list-with-uniform-initializ\">Why can't I initialize a reference in an initializer list with uniform initialization?</a></p>\n<p>But mentioned pr50025 is fixed in gcc 4.9.</p>\n<p>I know that above code sample is pretty useless,\nbut I oversimplified it intentionally to point out the issue.\nIn real life code problem can be hidden in a generic function like:</p>\n<pre><code>#include &lt;utility&gt;\ntemplate &lt;typename Tp, typename... Us&gt;\nTp bar(Us&amp;&amp;... us) {\n  return Tp{std::forward&lt;Us&gt;(us)...};\n}\n</code></pre>\n", "Tags": "<c++11><gcc><reference><clang><uniform-initialization>", "OwnerUserId": "4503990", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28199177_28201770_0": {"section_id": 367, "quality": 0.5714285714285714, "length": 4}, "so_28199177_28201770_1": {"section_id": 5999, "quality": 0.9285714285714286, "length": 26}, "so_28199177_28201770_3": {"section_id": 6001, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_28199177_28201770_0": {"section_id": 356, "quality": 0.5714285714285714, "length": 4}, "so_28199177_28201770_1": {"section_id": 5767, "quality": 0.9285714285714286, "length": 26}, "so_28199177_28201770_3": {"section_id": 5769, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_28199177_28201770_0": {"section_id": 379, "quality": 0.5714285714285714, "length": 4}}}, "28201770": {"ParentId": "28199177", "CommentCount": "2", "Body": "<p>This seems like an omission in the standard, where GCC is implementing exactly what the standard requires, and clang is going for what's probably intended.</p>\n<p>From C++11 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_28199177_28201770_0\"><strong>5.2.3 Explicit type conversion (functional notation) [expr.type.conv]</strong></p>\n<p id=\"so_28199177_28201770_1\">1 A <em>simple-type-specifier</em> (7.1.6.2) or <em>typename-specifier</em> (14.6) followed by a parenthesized <em>expression-list</em> constructs a value of the specified type given the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4). [...]</p>\n<p id=\"so_28199177_28201770_2\">[...]</p>\n<p id=\"so_28199177_28201770_3\">3 Similarly, a <em>simple-type-specifier</em> or <em>typename-specifier</em> followed by a <em>braced-init-list</em> creates a temporary object of the specified type direct-list-initialized (8.5.4) with the specified <em>braced-init-list</em>, <strong>and its value is that temporary object as a prvalue</strong>.</p>\n</blockquote>\n<p>For the <em>braced-init-list</em> case, the standard doesn't specify that that this works just like a C-style cast. And it doesn't:</p>\n<pre><code>typedef char *cp;\nint main() {\n  int i;\n  (cp(&amp;i)); // okay: C-style casts can be used as reinterpret_cast\n  (cp{&amp;i}); // error: no implicit conversion from int * to char *\n}\n</code></pre>\n<p>Unfortunately, <code>T(expr)</code> being equivalent to <code>(T)expr</code> is also the one exception in which a functional cast <em>doesn't</em> necessarily produce a prvalue. The standard fails to specify a similar exception for a functional cast using a braced-init-list to a reference type. As a result, in your example, <code>ref{x}</code> constructs a temporary of type <code>ref</code>, direct-list-initialised from <code>{x}</code>. That temporary is then treated as a prvalue, because that's what the standard says the behaviour should be, and that prvalue cannot be used for binding to an lvalue reference.</p>\n<p>I strongly suspect that if this were brought up to the ISO C++ committee, the standard would be changed to require clang's behaviour, but based on the current wording of the standard, I think it's GCC that's correct, at least for your specific example.</p>\n<p>Instead of adding a variable, or switching to parentheses, you can omit <code>ref</code> (<code>Tp</code>) to avoid the problem:</p>\n<pre><code>template &lt;typename Tp, typename... Us&gt;\nTp bar(Us&amp;&amp;... us) {\n  return {std::forward&lt;Us&gt;(us)...};\n}\n</code></pre>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "28201770", "Score": "3", "CreationDate": "2015-01-28T20:27:16.517", "LastActivityDate": "2015-01-28T20:27:16.517"}});