post_cb({"7460268": {"ParentId": "7460242", "CommentCount": "1", "Body": "<p>Deleting a void pointer is dangerous. Compilers may warn or reject your code. The C++ standard says you shouldn't be doing so.</p>\n<p>In practice, if the compiler does accept your code, it only frees the memory without calling the destructor.</p>\n", "OwnerUserId": "498284", "PostTypeId": "2", "Id": "7460268", "Score": "0", "CreationDate": "2011-09-18T08:10:28.793", "LastActivityDate": "2011-09-18T08:10:28.793"}, "7460262": {"ParentId": "7460242", "CommentCount": "0", "Body": "<p>If you need this behavior, use a <a href=\"http://www.daniweb.com/software-development/cpp/code/216960\" rel=\"nofollow\">template</a>. You code, as written, has no way to know what destructor to call.</p>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "7460262", "Score": "3", "CreationDate": "2011-09-18T08:08:37.697", "LastActivityDate": "2011-09-18T08:08:37.697"}, "7460242": {"CommentCount": "3", "ViewCount": "176", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2011-09-18T08:04:46.653", "LastActivityDate": "2015-08-12T14:21:08.670", "Title": "Deleting objects in c++", "LastEditDate": "2015-08-12T14:21:08.670", "Id": "7460242", "Score": "0", "Body": "<p>I have a LinkedList with a Node that have a field:</p>\n<pre><code>void* _data;\n</code></pre>\n<p>Now, I want to delete this data, but i cant know if the data will be a primitive or an object that was dynamically allocated.</p>\n<p>so, if a write:</p>\n<pre><code>~Node() {\n  delete _node;\n}\n</code></pre>\n<p>and the data is an object that was dynamically allocated, will it call the destructor of the object or will i have a memory leak?</p>\n<p>So how can I make this work?</p>\n", "Tags": "<c++><destructor><delete-operator>", "OwnerUserId": "352660", "AnswerCount": "4"}, "7460258": {"ParentId": "7460242", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>Don't do that!</strong></p>\n<p>Calling <code>delete</code> on a <code>void pointer</code> is an <strong>Undefined Behavior</strong>.<sup>[Reference Below]</sup><br>\nUndefined Behavior means that anything can happen, the program might crash sometimes or might work sometimes but you cannot predict its behavior at all times, which is a very bad way of programing. </br></p>\n<p>As you rightly concluded with <code>void*</code> there is no way that the <code>delete</code> operator can figure out which class destructor it needs to call, Eventually, leading to a Undefined Behavior.</p>\n<p><strong>So how can i make this work?</strong><br>\nAs I see Your intention of having an <code>void*</code> pointer is for having a generic Link list implementation. C++ already provides a templated generic link list <strong><a href=\"http://www.cplusplus.com/reference/stl/list/\" rel=\"nofollow\">std::list</a></strong> for this purpose, You can use it as there is no point in re-inventing the wheel and it is most likely that the standard link list implementation will be better than any custom implemented version of a generic link list. </br></p>\n<p>If you would still want to have your own version of the link list. You should implement a generic template link list class just what <strong>std::list</strong> does.  </p>\n<p>Have a look at <strong><a href=\"http://en.wikipedia.org/wiki/Template_%28programming%29\" rel=\"nofollow\">Template Programming</a></strong>.</p>\n<hr>\n<p><strong>Reference:</strong><br>\nAs per <strong>C++03 Standard section 5.3.5/3:</strong> </br></p>\n<blockquote>\n<p id=\"so_7460242_7460258_0\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined(FootNote 73).</p>\n</blockquote>\n<p>Foot Note 73)</p>\n<blockquote>\n<p id=\"so_7460242_7460258_1\">This implies that an object cannot be deleted using a pointer of type void* because there are no objects of type void</p>\n</blockquote>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2011-09-18T09:03:18.783", "Id": "7460258", "Score": "7", "CreationDate": "2011-09-18T08:07:44.070", "LastActivityDate": "2011-09-18T09:03:18.783"}, "bq_ids": {"n4140": {"so_7460242_7460258_1": {"section_id": 6105, "quality": 0.7857142857142857, "length": 11}, "so_7460242_7460258_0": {"section_id": 6107, "quality": 0.8717948717948718, "length": 34}}, "n3337": {"so_7460242_7460258_1": {"section_id": 5871, "quality": 0.7142857142857143, "length": 10}, "so_7460242_7460258_0": {"section_id": 5873, "quality": 0.8717948717948718, "length": 34}}, "n4659": {"so_7460242_7460258_1": {"section_id": 7602, "quality": 0.7857142857142857, "length": 11}, "so_7460242_7460258_0": {"section_id": 7604, "quality": 0.8717948717948718, "length": 34}}}, "7460277": {"ParentId": "7460242", "CommentCount": "0", "Body": "<p>When <code>_node</code> has type <code>void*</code>, <code>delete _node</code> is always incorrect because the type of the operand used with <code>delete</code> must always be a pointer to the dynamic type of the object constructed, or to a type that is a base class of that type, providing that the base class type has a virtual destructor. Clearly, <code>void*</code> cannot fulfil either part of that requirement.</p>\n<p>If you are using a <code>void*</code> you need to find someway of casting back to the original type before calling <code>delete</code>. An altenrative approach would be to use something like a <code>std::shared_ptr&lt;void&gt;</code> which can be used in a way where an appropriate deleter is stored at construction (or reset) time and will automatically be called with the node is destroyed.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "7460277", "Score": "2", "CreationDate": "2011-09-18T08:13:33.357", "LastActivityDate": "2011-09-18T08:13:33.357"}});