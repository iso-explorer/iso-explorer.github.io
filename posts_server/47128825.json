post_cb({"47129827": {"ParentId": "47128825", "CommentCount": "0", "Body": "<p>Section <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.2.5\" rel=\"nofollow noreferrer\">\u00a76.2.5 <strong>Types</strong></a> of the <a href=\"http://port70.net/~nsz/c/c11/n1570.html\" rel=\"nofollow noreferrer\">C11 standard (ISO/IEC 9899:2011)</a> says, in part:</p>\n<blockquote>\n<p id=\"so_47128825_47129827_0\">\u00b610 There are three <em>real floating types</em>, designated as <code>float</code>, <code>double</code>, and <code>long double</code>.<sup>42)</sup> The set of values of the type <code>float</code> is a subset of the set of values of the\n  type <code>double</code>; the set of values of the type <code>double</code> is a subset of the set of values of the\n  type <code>long double</code>.</p>\n<p id=\"so_47128825_47129827_1\">\u00b611 There are three <em>complex types</em>, designated as <code>float _Complex</code>, <code>double _Complex</code>, and <code>long double _Complex</code>.<sup>43)</sup> (Complex types are a conditional\n  feature that implementations need not support; see 6.10.8.3.) The real floating and\n  complex types are collectively called the <em>floating types</em>.</p>\n<p id=\"so_47128825_47129827_2\">\u00b612 For each floating type there is a <em>corresponding real type</em>, which is always a real floating\n  type. For real floating types, it is the same type. For complex types, it is the type given\n  by deleting the keyword <code>_Complex</code> from the type name.</p>\n<p id=\"so_47128825_47129827_3\">\u00b613 Each complex type has the same representation and alignment requirements as an array\n  type containing exactly two elements of the corresponding real type; the first element is\n  equal to the real part, and the second element to the imaginary part, of the complex\n  number.</p>\n<p id=\"so_47128825_47129827_4\"><sup>42)</sup> See \u2018\u2018future language directions\u2019\u2019 (6.11.1).<br>\n<sup>43)</sup> A specification for imaginary types is in annex G.</br></p>\n<h3><a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.11.1\" rel=\"nofollow noreferrer\">6.11.1 Floating types</a></h3>\n<p id=\"so_47128825_47129827_5\">\u00b61 Future standardization may include additional floating-point types, including those with\n  greater range, precision, or both than <code>long double</code>.</p>\n</blockquote>\n<p>There's also the library specification <a href=\"http://port70.net/~nsz/c/c11/n1570.html#7.3\" rel=\"nofollow noreferrer\">\u00a77.3 Complex arithmetic <code>&lt;complex.h&gt;</code></a>:</p>\n<blockquote>\n<h3>7.3.1 Introduction</h3>\n<p id=\"so_47128825_47129827_6\">\u00b61 The header <code>&lt;complex.h&gt;</code> defines macros and declares functions that support complex\n  arithmetic.<sup>192)</sup></p>\n<p id=\"so_47128825_47129827_7\">\u00b62 Implementations that define the macro <code>__STDC_NO_COMPLEX__</code> need not provide\n  this header nor support any of its facilities.</p>\n<p id=\"so_47128825_47129827_8\">\u00b63 Each synopsis specifies a family of functions consisting of a principal function with one\n  or more <code>double complex</code> parameters and a <code>double complex</code> or <code>double</code> return\n  value; and other functions with the same name but with <code>f</code> and <code>l</code> suffixes which are\n  corresponding functions with <code>float</code> and <code>long double</code> parameters and return values.</p>\n<p id=\"so_47128825_47129827_9\">4 The macro</p>\n<pre><code>complex\n</code></pre>\n<p id=\"so_47128825_47129827_10\">expands to <code>_Complex</code>; the macro</p>\n<pre><code>_Complex_I\n</code></pre>\n<p id=\"so_47128825_47129827_11\">expands to a constant expression of type <code>const float _Complex</code>, with the value of\n  the imaginary unit.<sup>193)</sup></p>\n<p id=\"so_47128825_47129827_12\">\u00b65 The macros</p>\n<pre><code>imaginary\n</code></pre>\n<p id=\"so_47128825_47129827_13\">and</p>\n<pre><code>_Imaginary_I\n</code></pre>\n<p id=\"so_47128825_47129827_14\">are defined if and only if the implementation supports imaginary types;<sup>194)</sup> if defined,\n  they expand to <code>_Imaginary</code> and a constant expression of type <code>const float\n  _Imaginary</code> with the value of the imaginary unit.</p>\n<p id=\"so_47128825_47129827_15\">\u00b66 The macro</p>\n<pre><code>I\n</code></pre>\n<p id=\"so_47128825_47129827_16\">expands to either <code>_Imaginary_I</code> or <code>_Complex_I</code>. If <code>_Imaginary_I</code> is not defined, <code>I</code> shall expand to <code>_Complex_I</code>.</p>\n<p id=\"so_47128825_47129827_17\">\u00b67 Notwithstanding the provisions of 7.1.3, a program may undefine and perhaps then\n  redefine the macros <code>complex</code>, <code>imaginary</code>, and <code>I</code>.</p>\n<p id=\"so_47128825_47129827_18\"><sup>192)</sup> See \u2018\u2018future library directions\u2019\u2019 (7.31.1).<br>\n<sup>193)</sup> The imaginary unit is a number <em>i</em> such that <em>i<sup>2</sup> = \u22121</em>.<br>\n<sup>194)</sup> A specification for imaginary types is in informative annex G.</br></br></p>\n</blockquote>\n<p>And there's a 14-page <a href=\"http://port70.net/~nsz/c/c11/n1570.html#G\" rel=\"nofollow noreferrer\">Annex G</a>, which starts:</p>\n<blockquote>\n<h3>Annex G</h3>\n<p id=\"so_47128825_47129827_19\">(normative)</p>\n<h3>IEC 60559-compatible complex arithmetic</h3>\n<h3>G.1 Introduction</h3>\n<p id=\"so_47128825_47129827_20\">\u00b61 This annex supplements annex F to specify complex arithmetic for compatibility with\n  IEC 60559 real floating-point arithmetic. An implementation that defines\n  <code>__STDC_IEC_559_COMPLEX__</code> shall conform to the specifications in this annex.<sup>375)</sup></p>\n<p id=\"so_47128825_47129827_21\"><sup>375)</sup> Implementations that do not define <code>__STDC_IEC_559_COMPLEX__</code> are not required to conform to these specifications.</p>\n<h3>G.2 Types</h3>\n<p id=\"so_47128825_47129827_22\">\u00b61 There is a new keyword _Imaginary, which is used to specify imaginary types. It is\n  used as a type specifier within declaration specifiers in the same way as _Complex is\n  (thus, _Imaginary float is a valid type name).</p>\n<p id=\"so_47128825_47129827_23\">\u00b62 There are three imaginary types, designated as float _Imaginary, double\n  _Imaginary, and long double _Imaginary. The imaginary types (along with\n  the real floating and complex types) are floating types.</p>\n<p id=\"so_47128825_47129827_24\">\u00b63 For imaginary types, the corresponding real type is given by deleting the keyword\n  _Imaginary from the type name.</p>\n<p id=\"so_47128825_47129827_25\">\u00b64 Each imaginary type has the same representation and alignment requirements as the\n  corresponding real type. The value of an object of imaginary type is the value of the real\n  representation times the imaginary unit.</p>\n<p id=\"so_47128825_47129827_26\">\u00b65 The imaginary type domain comprises the imaginary types.</p>\n</blockquote>\n<hr>\n<p>It's curious that footnote 194 designates Annex G as 'informative' but the Annex identifies itself as 'normative'.  Footnote 43 does mention 'normative' or 'informative'.</p>\n<hr>\n<p>Section 6.2.5 \u00b613 of the C standard is quite clear about how a complex variable shall be represented.</p>\n</hr></hr>", "OwnerUserId": "15168", "PostTypeId": "2", "Id": "47129827", "Score": "2", "CreationDate": "2017-11-06T04:38:00.283", "LastActivityDate": "2017-11-06T04:38:00.283"}, "47128825": {"CommentCount": "9", "ViewCount": "92", "CreationDate": "2017-11-06T02:18:44.973", "LastActivityDate": "2017-11-06T04:38:00.283", "Title": "How are complex numbers(and the imaginary number i) represented in Native C as opposed to C++?", "PostTypeId": "1", "Id": "47128825", "Score": "1", "Body": "<p>In particular, the  class doesn't have much in the way of data structure definitions of complex numbers. You could represent it by:</p>\n<pre><code>struct complex{\n  double real;\n  double imaginary;\n\n};\n</code></pre>\n<p>But the imaginary number i = sqrt(-1) cannot be reduced to a primitive type since primitive numerical types are necessarily real numbers. So it would have to be defined implicitly by means of the complex product. This is very easy to do in an object oriented language that allows operator overloading but how is it done with a procedural language like C?</p>\n", "Tags": "<c++><c><complex-numbers><procedural-programming>", "OwnerUserId": "8524549", "AnswerCount": "2"}, "47129072": {"ParentId": "47128825", "CommentCount": "6", "Body": "<p>You can write:</p>\n<pre><code>_Complex double x = _Complex_I;\n</code></pre>\n<p>You can do the usual arithmetic operations on complex numbers. The header <code>#include &lt;complex.h&gt;</code> declares complex versions of the usual math functions (trig, roots etc.)</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "47129072", "Score": "2", "CreationDate": "2017-11-06T02:54:49.663", "LastActivityDate": "2017-11-06T02:54:49.663"}, "bq_ids": {"n4140": {"so_47128825_47129827_0": {"section_id": 7217, "quality": 0.8333333333333334, "length": 25}}, "n3337": {"so_47128825_47129827_0": {"section_id": 6961, "quality": 0.8333333333333334, "length": 25}}, "n4659": {"so_47128825_47129827_0": {"section_id": 8726, "quality": 0.8333333333333334, "length": 25}}}});