post_cb({"bq_ids": {"n4140": {"so_10965325_10965371_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 4723}, "so_10965325_10965371_4": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_10965325_10965371_6": {"length": 4, "quality": 1.0, "section_id": 45}}, "n3337": {"so_10965325_10965371_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 4530}, "so_10965325_10965371_4": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_10965325_10965371_6": {"length": 4, "quality": 1.0, "section_id": 42}}, "n4659": {"so_10965325_10965371_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6122}, "so_10965325_10965371_4": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_10965325_10965371_6": {"length": 4, "quality": 1.0, "section_id": 46}}}, "10965325": {"ViewCount": "622", "Body": "<p>Do the following class break the strict aliasing rule:</p>\n<pre><code>template&lt;typename T&gt;\nclass store {\n    char m_data[sizeof(T)];\n    bool m_init;\npublic:\n    store() : m_init(false) {}\n    store(const T &amp;t) : init(true) {\n        new(m_data) T(t);\n    }\n    ~store() {\n        if(m_init) {\n            get()-&gt;~T();\n        }\n    }\n    store &amp;operator=(const store &amp;s) {\n        if(m_init) {\n            get()-&gt;~T();\n        }\n        if(s.m_init) {\n            new(m_data) T(*s.get());\n        }\n        m_init = s.m_init;\n    }\n    T *get() {\n        if (m_init) {\n            return reinterpret_cast&lt;T *&gt;(m_data);\n        } else {\n            return NULL;\n        }\n    }\n}\n</code></pre>\n<p>My reading of a standard is that it is incorrect but I am not sure (my usage is to have an array of objects <code>T</code> + some metadata of those objects but to have control over the object construction/deconstruction without manually allocating memory) as the allocated objects are used as examples for placement <code>new</code> in standard.</p>\n", "AcceptedAnswerId": "10965371", "Title": "Does encapsulated char array used as object breaks strict aliasing rule", "CreationDate": "2012-06-09T23:29:07.580", "Id": "10965325", "CommentCount": "0", "LastEditDate": "2012-07-21T03:08:32.463", "PostTypeId": "1", "LastEditorUserId": "963864", "LastActivityDate": "2012-07-21T03:08:32.463", "Score": "3", "OwnerUserId": "49107", "Tags": "<c++><placement-new><reinterpret-cast><strict-aliasing><explicit-destructor-call>", "AnswerCount": "2"}, "10965371": {"Id": "10965371", "PostTypeId": "2", "Body": "<p>The standard contains this note:</p>\n<blockquote>\n<p id=\"so_10965325_10965371_0\">[ <em>Note:</em> A typical implementation would define aligned_storage as:</p>\n<pre><code>template &lt;std::size_t Len, std::size_t Alignment&gt;\nstruct aligned_storage {\n  typedef struct {\n    alignas(Alignment) unsigned char __data[Len];\n  } type;\n};\n</code></pre>\n<p id=\"so_10965325_10965371_1\">\u2014 <em>end note</em> ]</p>\n<p id=\"so_10965325_10965371_2\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 Pointer modifications [meta.trans.ptr] 20.9.7.5/1</em></p>\n</blockquote>\n<p>And aligned_storage is defined in part with:</p>\n<blockquote>\n<p id=\"so_10965325_10965371_3\">The member typedef <strong>type</strong> shall be a POD type suitable for use as uninitialized storage for any object whose size is at most <em>Len</em> and whose alignment is a divisor of <em>Align</em>.</p>\n</blockquote>\n<p>The only property covered by the standard that restricts the addresses at which an object can be constructed is alignment. An implementation might have some other restrictions, however I'm not familiar with any that do. So just ensure that having correct alignment is enough on your implementation and I think this should be okay. (and in pre-C++11 compilers you can use use compiler extensions for setting alignment such as <code>__attribute__((alignment(X)))</code> or <code>__declspec(align(X))</code>.</p>\n<p>I believe that as long as you don't access the underlying storage directly the aliasing rules don't even come into the picture, because the aliasing rules cover when it is okay to access the value of an object through an object of a different type. Constructing an object and accessing only that object doesn't involve accessing the object's value through an object of any other type.</p>\n<h3>Earlier answer</h3>\n<p>The aliasing rules specifically allow char arrays to alias other objects.</p>\n<blockquote>\n<p id=\"so_10965325_10965371_4\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<p id=\"so_10965325_10965371_5\">[...]</p>\n<p id=\"so_10965325_10965371_6\">\u2014 a char or unsigned char type.</p>\n<p id=\"so_10965325_10965371_7\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 Lvalues and rvalues [basic.lval] 3.10/10</em></p>\n</blockquote>\n<p>You do need to make sure that the array is properly aligned for type T though.</p>\n<pre><code>alignas(T) char m_data[sizeof(T)];\n</code></pre>\n<p>The above is C++11 syntax for setting alignment, but if you're on a C++03 compiler then you'll need a compiler specific attribute to do the same thing. GCC has <code>__attribute__((aligned(32)))</code> and MSVC has <code>__declspec(align(32))</code></p>\n<hr>\n<p>Kerrek SB brings up a good point that the aliasing rules state that it's okay to access the value of a T object via a char array, but that may not mean that accessing the value of a char array via a T object is okay. However, if the placement new expression is well defined then that creates a T object which I think it's okay to accesses as a T object by definition, and reading the original char array is accessing the value of the created T object, which is covered under the aliasing rules.</p>\n<p>I think that implies that you could store a T object in, for example, an int array, and as long as you don't access the value of that T object through the original int array then you're not hitting undefined behavior.</p>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2012-06-10T01:26:24.327", "Score": "3", "CreationDate": "2012-06-09T23:38:04.483", "ParentId": "10965325", "CommentCount": "0", "LastEditDate": "2012-06-10T01:26:24.327", "OwnerUserId": "365496"}, "10965384": {"Id": "10965384", "PostTypeId": "2", "Body": "<p>What is allowed is to take a <code>T</code> object and interpret it as an array of chars. However, it is in general <em>not</em> allowed to take an arbitrary array of chars and treat it as a <code>T</code>, or even as the pointer to an area of memory containing a <code>T</code>. At the very least, your char array would need to be properly aligned.</p>\n<p>One way around this might be to use a union:</p>\n<pre><code>union storage { char buf[sizeof(T)]; T dummy; };\n</code></pre>\n<p>Now you can construct a <code>T</code> inside <code>storage.buf</code>:</p>\n<pre><code>T * p = ::new (storage.buf) T();\n</code></pre>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-06-10T00:41:17.687", "Score": "0", "CreationDate": "2012-06-09T23:40:35.740", "ParentId": "10965325", "CommentCount": "11", "LastEditDate": "2012-06-10T00:41:17.687", "OwnerUserId": "596781"}});