post_cb({"7041294": {"ParentId": "7040076", "CommentCount": "14", "Body": "<p>Undefined behavior.</p>\n<p>3.3.7/1</p>\n<blockquote>\n<p id=\"so_7040076_7041294_0\">The following rules describe the scope of names declared in classes:</p>\n<p id=\"so_7040076_7041294_1\">2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in the completed scope of S. No diagnostic is required for a violation of this rule.</p>\n</blockquote>\n", "OwnerUserId": "136208", "PostTypeId": "2", "Id": "7041294", "Score": "8", "CreationDate": "2011-08-12T14:08:42.890", "LastActivityDate": "2011-08-12T14:08:42.890"}, "7041227": {"ParentId": "7040076", "CommentCount": "0", "Body": "<p>Since there's been no quote yet, I've been playing around with your example:</p>\n<p>Both gcc 4.5.1 and Clang 3.0 accept the code as can be seen below.</p>\n<p>Now, we just need someone to dig out an authoritative answer. With Clang, gcc and VC++ agreeing though (not <em>that</em> frequent), it seems intended.</p>\n<p>On <a href=\"http://ideone.com/VD6KM\" rel=\"nofollow\">ideone</a> (4.5.1):</p>\n<pre><code>#include &lt;utility&gt;\n\nstruct A\n{\n  struct Gold {};\n};\n\nstruct B : public A\n{\n  typedef Gold BaseGold;\n  struct Gold {};\n};\n\nstruct C : public B\n{\n  typedef Gold BaseGold;\n  struct Gold {};\n};\n\nstatic_assert(std::is_same&lt;B::BaseGold, A::Gold&gt;::value, \"Not the right treasure!\");\nstatic_assert(std::is_same&lt;C::BaseGold, B::Gold&gt;::value, \"Not the right treasure!\");\n</code></pre>\n<p>On <a href=\"http://llvm.org/demo/index.cgi\" rel=\"nofollow\">Clang</a>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntemplate &lt;typename T, typename U&gt;\nstruct is_same { enum { value = false }; };\n\ntemplate &lt;typename T&gt;\nstruct is_same&lt;T,T&gt; { enum { value = true }; };\n\nstruct A\n{\n  struct Gold {};\n};\n\nstruct B : public A\n{\n  typedef Gold BaseGold;\n  struct Gold {};\n};\n\nstruct C : public B\n{\n  typedef Gold BaseGold;\n  struct Gold {};\n};\n\nint main() {\n  if (!is_same&lt;B::BaseGold, A::Gold&gt;::value) {\n    printf(\"oups\");\n  }\n  if (!is_same&lt;C::BaseGold, B::Gold&gt;::value) {\n    printf(\"oups\");\n  }\n}\n</code></pre>\n<p>Clang output (as expected):</p>\n<pre><code>define i32 @main() nounwind readnone {\nentry:\n  ret i32 0\n}\n</code></pre>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "7041227", "Score": "1", "CreationDate": "2011-08-12T14:03:28.997", "LastActivityDate": "2011-08-12T14:03:28.997"}, "7040076": {"CommentCount": "6", "AcceptedAnswerId": "7041294", "CreationDate": "2011-08-12T12:30:08.580", "LastActivityDate": "2011-08-12T14:08:42.890", "PostTypeId": "1", "ViewCount": "247", "FavoriteCount": "1", "Title": "Name-lookup of nested classes with inheritance", "Id": "7040076", "Score": "9", "Body": "<p>Is this guaranteed to work:</p>\n<pre><code>struct A\n{\n  struct Gold {};\n};\n\nstruct B : public A\n{\n  typedef Gold BaseGold;\n  struct Gold {};\n};\n\nstruct C : public B\n{\n  typedef Gold BaseGold;\n  struct Gold {};\n};\n\nstatic_assert(is_same&lt;B::BaseGold, A::Gold&gt;::value, \"Not the right treasure!\");\nstatic_assert(is_same&lt;C::BaseGold, B::Gold&gt;::value, \"Not the right treasure!\");\n</code></pre>\n<p>It seems to work on VS2010. Obviously it relies on subtle declaration order/name lookup rules, so I was wondering what the standard says on the matter...</p>\n", "Tags": "<c++><inheritance><name-lookup>", "OwnerUserId": "518626", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7040076_7041294_1": {"section_id": 7070, "quality": 1.0, "length": 15}, "so_7040076_7041294_0": {"section_id": 7070, "quality": 0.875, "length": 7}}, "n3337": {"so_7040076_7041294_1": {"section_id": 6814, "quality": 1.0, "length": 15}, "so_7040076_7041294_0": {"section_id": 6814, "quality": 0.875, "length": 7}}, "n4659": {"so_7040076_7041294_1": {"section_id": 8568, "quality": 1.0, "length": 15}}}});