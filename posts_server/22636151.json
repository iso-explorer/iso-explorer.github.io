post_cb({"22886420": {"ParentId": "22636151", "CommentCount": "0", "Body": "<p>In the end I decided that I would use <code>std::tuple</code> as a parameter and hide the parameter expansion:</p>\n<h3>Usage is now:</h3>\n<pre><code>select.execute(\n    Bind(1462, 1477), \n    [](int ID, std::string const&amp; person, double item1, float item2){\n        std::cout &lt;&lt; \"Got Row:\" \n                  &lt;&lt; ID     &lt;&lt; \", \" \n                  &lt;&lt; person &lt;&lt; \", \" \n                  &lt;&lt; item1  &lt;&lt; \", \" \n                  &lt;&lt; item2  &lt;&lt; \"\\n\";\n});\n</code></pre>\n<p>Then I defined:</p>\n<pre><code>template&lt;typename ...Args&gt;\ninline std::tuple&lt;Args...&gt; Bind(Args... args) { return std::tuple&lt;Args...&gt;(args...);}\n</code></pre>\n<p>The class is redefined like this:</p>\n<pre><code>class Statement\n{\n    public:\n        Statement(std::string const&amp;);\n\n        template&lt;class Action, class ...Args&gt;\n        void execute(std::tuple&lt;Args...&gt; const&amp; param, Action action);\n};\n</code></pre>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "22886420", "Score": "0", "CreationDate": "2014-04-05T20:33:48.373", "LastActivityDate": "2014-04-05T20:33:48.373"}, "22636151": {"CommentCount": "2", "ViewCount": "455", "PostTypeId": "1", "LastEditorUserId": "14065", "CreationDate": "2014-03-25T13:30:56.303", "LastActivityDate": "2014-04-05T20:33:48.373", "Title": "C++11 variable argument alignment", "AcceptedAnswerId": "22886420", "LastEditDate": "2014-03-25T14:22:21.943", "Id": "22636151", "Score": "5", "Body": "<p>This is the interface I am trying to achieve:</p>\n<pre><code> Statement  select(\"SELECT * FROM People WHERE ID &gt; ? AND ID &lt; ?\");\n select.execute(1462, 1477, [](int ID, std::string const&amp; person, double item1, float item2){\n     std::cout &lt;&lt; \"Got Row:\" \n               &lt;&lt; ID     &lt;&lt; \", \" \n               &lt;&lt; person &lt;&lt; \", \" \n               &lt;&lt; item1  &lt;&lt; \", \" \n               &lt;&lt; item2  &lt;&lt; \"\\n\";\n });\n</code></pre>\n<p>Where the '?' in the select string are matched against the variable argument list <code>1462, 1477</code> at runtime.</p>\n<p>This is the class definition:</p>\n<pre><code>class Statement\n{\n    public:\n        Statement(std::string const&amp;);\n\n        template&lt;class Action, class ...Args&gt;\n        void execute(Args... param, Action action);\n};\n</code></pre>\n<p>Unfortunately this generates an error:</p>\n<blockquote>\n<p id=\"so_22636151_22636151_0\">test.cpp:133:12: error: no matching member function for call to 'execute'<br>\n  select.execute(1462, 1477, [](int ID, std::string const&amp; person, double item1, float item2){<br>\n  ~~~~~^~~~~~~  </br></br></p>\n<p id=\"so_22636151_22636151_1\">test.cpp:86:14: note: candidate template ignored: couldn't infer template argument 'Action'<br>\n  void execute(Args... param, Action action)<br>\n  ~~~^~~~~~~  </br></br></p>\n<p id=\"so_22636151_22636151_2\">1 error generated.</p>\n</blockquote>\n<p>But if I change the function definition slightly (below) it compiles fine.</p>\n<pre><code>class Statement\n{\n    public:\n        Statement(std::string const&amp;);\n\n        template&lt;class Action, class ...Args&gt;\n        void execute(Action action, Args... param);\n                  // ^^^^^^^ Move action to the front.\n};\n// Also changed the call by moving the lambda to the first argument.\n</code></pre>\n<p>I know its some syntactic sugar where the variable argument list goes, but I would like to put the variable argument list first. Are there any tricks I can use to help the compiler deduce the var arg list correctly?</p>\n", "Tags": "<c++><c++11><lambda><variadic-functions>", "OwnerUserId": "14065", "AnswerCount": "3"}, "22638424": {"ParentId": "22636151", "CommentCount": "2", "Body": "<p>Parameter pack cannot be deduced if they are not at the end of a function call.</p>\n<p>Quote from the standard, <code>14.8.2.1 Deducing template arguments from a function call</code></p>\n<p>Rules for the parameter pack at the end :</p>\n<blockquote>\n<p id=\"so_22636151_22638424_0\">For a function parameter pack that occurs at the end of the\n  parameter-declaration-list, the type A of each remaining argument of\n  the call is compared with the type P of the declarator-id of the\n  function parameter pack. Each comparison deduces template arguments\n  for subsequent positions in the template parameter packs expanded by\n  the function parameter pack.</p>\n</blockquote>\n<p>Other else :</p>\n<blockquote>\n<p id=\"so_22636151_22638424_1\">For a function parameter pack that does not occur at the end of the\n  parameter-declaration-list, the type of the parameter pack is a\n  non-deduced context.</p>\n</blockquote>\n", "OwnerUserId": "2694444", "PostTypeId": "2", "Id": "22638424", "Score": "1", "CreationDate": "2014-03-25T15:03:09.087", "LastActivityDate": "2014-03-25T15:03:09.087"}, "bq_ids": {"n4140": {"so_22636151_22638424_0": {"section_id": 302, "quality": 0.96875, "length": 31}, "so_22636151_22638424_1": {"section_id": 302, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_22636151_22638424_0": {"section_id": 293, "quality": 0.96875, "length": 31}, "so_22636151_22638424_1": {"section_id": 293, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_22636151_22638424_0": {"section_id": 309, "quality": 0.875, "length": 28}, "so_22636151_22638424_1": {"section_id": 309, "quality": 0.7692307692307693, "length": 10}}}, "22638348": {"ParentId": "22636151", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It's a bit ugly, but you could use tuples:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt;int... Is&gt;\nstruct integer_sequence {};\ntemplate&lt;int N, int... Is&gt;\nstruct make_integer_sequence : make_integer_sequence&lt;N-1, N-1, Is...&gt; {};\ntemplate&lt;int... Is&gt;\nstruct make_integer_sequence&lt;0, Is...&gt; : integer_sequence&lt;Is...&gt; {};\n\nclass Statement\n{\n    private:\n        std::string foo;\n\n    public:\n        Statement(std::string const&amp; p)\n            : foo(p)\n        {}\n\n        template&lt;class ...Args&gt;\n        void execute(Args... param)\n        {\n            execute_impl(make_integer_sequence&lt;sizeof...(Args)-1&gt;{}, param...);\n        }\n\n        template&lt;int... Is, class... Args&gt;\n        void execute_impl(integer_sequence&lt;Is...&gt;, Args... param)\n        {\n            std::get&lt;sizeof...(Args)-1&gt;(std::tie(param...))\n                (std::get&lt;Is&gt;(std::tie(param...))..., foo);\n        }\n};\n</code></pre>\n<p>Usage example:</p>\n<pre><code>int main()\n{\n    Statement s(\"world\");\n    s.execute(\"hello\", \", \",\n              [](std::string const&amp; p1, std::string const&amp; p2,\n                 std::string const&amp; p3)\n              { std::cout &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; p3; });\n    std::cout &lt;&lt; \"\\nEND\\n\";\n}\n</code></pre>\n<hr>\n<p>Here's an alternative solution, a bit less ugly but more verbose:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n\ntemplate&lt;class Tuple, class...&gt;\nstruct pop_back;\n\ntemplate&lt;class T, class... Ts, class... Us&gt;\nstruct pop_back&lt;std::tuple&lt;T, Ts...&gt;, Us...&gt;\n    : pop_back&lt;std::tuple&lt;Ts...&gt;, Us..., T&gt;\n{};\n\ntemplate&lt;class T, class... Us&gt;\nstruct pop_back&lt;std::tuple&lt;T&gt;, Us...&gt;\n{\n    using type = std::tuple&lt;Us...&gt;;\n};\n\nclass Statement\n{\n    private:\n        std::string foo;\n\n    public:\n        Statement(std::string const&amp; p)\n            : foo(p)\n        {}\n\n        template&lt;class ...Args&gt;\n        void execute(Args... param)\n        {\n            helper&lt;typename pop_back&lt;std::tuple&lt;Args...&gt;&gt;::type&gt;\n                ::execute(param..., foo);\n        }\n\n        template&lt;class T&gt;\n        struct helper;\n\n        template&lt;class... Args&gt;\n        struct helper&lt; std::tuple&lt;Args...&gt; &gt;\n        {\n            template&lt;class Action&gt;\n            static void execute(Args... param, Action action, std::string foo)\n            {\n                action(param..., foo);\n            }\n        };\n};\n</code></pre>\n<hr>\n<p>Here's a short <code>is_callable</code> trait that allows a <code>static_assert</code> for nicer error messages:</p>\n<pre><code>template&lt;class F, class... Args&gt;\nstruct is_callable\n{\n    template&lt;class F1&gt;\n    static auto test(int)\n        -&gt; decltype( std::declval&lt;F1&gt;() (std::declval&lt;Args&gt;()...),\n                     std::true_type{} );\n\n    template&lt;class F1&gt;\n    static std::false_type test(...);\n\n    constexpr static auto value = decltype(test&lt;F&gt;(0))::value;\n};\n</code></pre>\n<p>For example:</p>\n<pre><code>template&lt;int... Is, class... Args&gt;\nvoid execute_impl(integer_sequence&lt;Is...&gt;, Args... param)\n{\n    auto&amp; action = std::get&lt;sizeof...(Args)-1&gt;(std::tie(param...));\n    auto param_tuple = std::tie(param...);\n\n    static_assert(is_callable&lt;decltype(action),\n                              typename std::tuple_element&lt;Is,\n                                              decltype(param_tuple)&gt;::type...,\n                              decltype(foo)&gt;::value,\n                  \"The action is not callable with those argument types.\");\n\n    action(std::get&lt;Is&gt;(param_tuple)..., foo);\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-03-25T15:41:46.310", "Id": "22638348", "Score": "2", "CreationDate": "2014-03-25T14:59:57.963", "LastActivityDate": "2014-03-25T15:41:46.310"}});