post_cb({"bq_ids": {"n4140": {"so_35314297_35314557_2": {"length": 13, "quality": 1.0, "section_id": 438}, "so_35314297_35314557_0": {"length": 6, "quality": 1.0, "section_id": 438}, "so_35314297_35314557_1": {"length": 29, "quality": 1.0, "section_id": 438}}, "n3337": {"so_35314297_35314557_2": {"length": 13, "quality": 1.0, "section_id": 429}, "so_35314297_35314557_0": {"length": 6, "quality": 1.0, "section_id": 429}, "so_35314297_35314557_1": {"length": 29, "quality": 1.0, "section_id": 429}}, "n4659": {"so_35314297_35314557_2": {"length": 13, "quality": 1.0, "section_id": 458}, "so_35314297_35314557_0": {"length": 6, "quality": 1.0, "section_id": 458}, "so_35314297_35314557_1": {"length": 29, "quality": 1.0, "section_id": 458}}}, "35346192": {"Id": "35346192", "PostTypeId": "2", "Body": "<p>Non virtual inheritance is an exclusive relationship, like membership. A class can be the non-virtual base class of one other class in a given complete object.</p>\n<p>This implies that a class can override virtual functions of a non virtual base class without causing conflicts or issues.</p>\n<p>A constructor can also initialize non virtual bases reliably.</p>\n<p>Only virtual bases can be direct base classes of many indirect bases of a complete object. Because a virtual base class can be shared, overriders can conflict.</p>\n<p>A constructor can try to initialize a virtual base subobject in the ctor-init-list, but if the class is further derived, that part of the ctor-init-list will be ignored.</p>\n", "LastActivityDate": "2016-02-11T17:33:45.583", "CommentCount": "0", "CreationDate": "2016-02-11T17:33:45.583", "ParentId": "35314297", "Score": "2", "OwnerUserId": "963864"}, "42349433": {"Id": "42349433", "PostTypeId": "2", "Body": "<ol>\n<li>All the base classes that inherit virtually from <code>Biology</code> share one instance of <code>Biology</code> base between them.</li>\n<li>All the base classes that inherit non-virtually from <code>Biology</code> have one instance each of <code>Biology</code>.</li>\n</ol>\n<p>You have one base in each category, therefore you have one instance of <code>Biology</code> brought in by <code>Human</code> (and in principle shared with others) and one instance brought in by <code>Animal</code> (never shared with any other base class).</p>\n", "LastActivityDate": "2017-02-20T16:18:04.597", "CommentCount": "1", "CreationDate": "2017-02-20T16:18:04.597", "ParentId": "35314297", "Score": "1", "OwnerUserId": "4850040"}, "35314297": {"ViewCount": "1484", "Body": "<p>This is the code:</p>\n<pre><code>struct Biology\n{    \n    Biology() { cout &lt;&lt; \"Biology CTOR\" &lt;&lt; endl; }\n};\n\nstruct Human : Biology\n{    \n    Human() { cout &lt;&lt; \"Human CTOR\" &lt;&lt; endl; }\n};\n\nstruct Animal : virtual Biology\n{\n    Animal() { cout &lt;&lt; \"Animal CTOR\" &lt;&lt; endl; }\n};\n\nstruct Centaur : Human, Animal\n{\n    Centaur() { cout &lt;&lt; \"Centaur CTOR\" &lt;&lt; endl; }\n};\n\nint main()\n{   \n   Centaur c;\n\n   return 0;\n}\n</code></pre>\n<p>This code prints:</p>\n<pre><code>Biology CTOR\nBiology CTOR\nHuman CTOR\nAnimal CTOR\nCentaur CTOR\n</code></pre>\n<p>Why?</p>\n<p>Since we create a <code>Centaur</code> object, we start from building the <code>Centaur</code> by constructing <code>Human</code>, <code>Animal</code> and finally <code>Centaur</code> (we start from the less derived to the most derived).</p>\n<p>Let's start from <code>Human</code>:\n<code>Human</code> inherits from <code>Biology</code>, so we call <code>Biology</code>'s constructor first.\nNow that <code>Human</code>'s base class is constructed, we can finally construct the <code>Human</code> itself.\nBut instead, <strong><code>Biology</code> gets constructed again!</strong></p>\n<p>Why? What's happening behind the scenes?</p>\n<p>Please note that it was completely intentional leaving <code>Animal</code> inheriting virtually from <code>Biology</code> and, at the same time, it was also intentional leaving <code>Human</code> non-virtually inheriting from <code>Biology</code>.</p>\n<p>We are solving the <strong>Dreaded Diamond</strong> in an incorrect way: <em>both Human and Animal should virtually inherit Biology</em> to make this work.</p>\n<p>I'm just curious.</p>\n<p>Also, see this code:</p>\n<pre><code>struct Biology\n{    \n    Biology() { cout &lt;&lt; \"Biology CTOR\" &lt;&lt; endl; }\n};\n\nstruct Human : virtual Biology\n{\n    Human() { cout &lt;&lt; \"Human CTOR\" &lt;&lt; endl; }\n};\n\nstruct Animal : Biology\n{    \n    Animal() { cout &lt;&lt; \"Animal CTOR\" &lt;&lt; endl; }\n};\n\nstruct Centaur : Human, Animal\n{\n    Centaur() { cout &lt;&lt; \"Centaur CTOR\" &lt;&lt; endl; }\n};\n\nint main()\n{   \n   Centaur c;\n\n   return 0;\n}\n</code></pre>\n<p>Here we have <code>Human</code> inheriting virtually from <code>Biology</code>, while <code>Animal</code> is set to inherit in the \"classic way\".</p>\n<p>But this time, the output is different:</p>\n<pre><code>Biology CTOR\nHuman CTOR\nBiology CTOR\nAnimal CTOR\nCentaur CTOR\n</code></pre>\n<p>This because <code>Centaur</code> inherits <strong>at first</strong> from <code>Human</code> and <strong>then</strong> from <code>Animal</code>.</p>\n<p>Had the order been the inverse, we'd have achieved the same result as before, in the first example - two <code>Biology</code> instances being constructed in a row.</p>\n<p>What's the logic of this?</p>\n<p>Please try to explain your way, I've already checked tons of websites speaking about this. But none seems to satisfy my request.</p>\n", "AcceptedAnswerId": "35314557", "Title": "Mixing virtual and non-virtual inheritance of a base class", "CreationDate": "2016-02-10T11:44:35.060", "Id": "35314297", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-02-20T19:56:50.787", "LastEditorUserId": "963864", "LastActivityDate": "2017-02-20T19:56:50.787", "Score": "23", "OwnerUserId": "5406363", "Tags": "<c++><inheritance><constructor><multiple-inheritance><virtual-inheritance>", "AnswerCount": "3"}, "35314557": {"Id": "35314557", "PostTypeId": "2", "Body": "<p>It's clear from the output that <strong>two <code>Biology</code> objects are instantiated</strong>. That is because you've made <strong>only one</strong> inheritance <code>virtual</code>. Two base class instances is the cause of ambiguity in dreaded diamond problem and the solution is to make (as we know) <strong>both</strong> inheritances of <code>Biology</code> <code>virtual</code>.</p>\n<p>Recap of the hierarchy:</p>\n<pre><code>Biology  Biology\n   |       |     # one and only one inheritance virtual\nHuman     Animal\n    \\     /\n    Centaur\n</code></pre>\n<p>Ok, let's read the output again with these rules in mind:</p>\n<ul>\n<li>Base classes are constructed before derived classes.</li>\n<li>Base classes are constructed in order in which they appear in the <em>base-specifier-list</em>.</li>\n<li><strong>Virtual base classes are constructed before non-virtual ones by the most derived class</strong> - <a href=\"https://stackoverflow.com/questions/2126522/c-virtual-inheritance\">see this</a>.</li>\n</ul>\n<p>1st output - <code>Animal</code> <code>virtual</code>ly inherits from <code>Biology</code>:</p>\n<pre><code>Biology CTOR     # virtual base class inherited from Animal\nBiology CTOR     # non-virtual base class of Human\nHuman CTOR       # Human itself\nAnimal CTOR      # Animal's virtual base class already constructed\nCentaur CTOR\n</code></pre>\n<p>2nd output - <code>Human</code> <code>virtual</code>ly inherits from <code>Biology</code>:</p>\n<pre><code>Biology CTOR     # virtual base class inherited from Human\nHuman CTOR       # Human's virtual base class already constructed\nBiology CTOR     # non-virtual base class of Animal\nAnimal CTOR      # Animal itself\nCentaur CTOR\n</code></pre>\n<hr>\n<p><strong>More informative standard paragraph</strong> (<code>[class.base.init]/10</code>)<strong>:</strong></p>\n<blockquote>\n<p id=\"so_35314297_35314557_0\">In a non-delegating constructor, initialization proceeds in the\n  following order:</p>\n<p id=\"so_35314297_35314557_1\">\u2014 First, and only for the constructor of the most\n  derived class (1.8), virtual base classes are initialized in the order\n  they appear on a depth-first left-to-right traversal of the directed\n  acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of\n  appearance of the base classes in the derived class\n  <em>base-specifier-list</em>.</p>\n<p id=\"so_35314297_35314557_2\">\u2014 Then, direct base classes are initialized in\n  declaration order as they appear in the <em>base-specifier-list</em>\n  (regardless of the order of the <em>mem-initializers</em>).</p>\n<p id=\"so_35314297_35314557_3\">...</p>\n</blockquote>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-20T15:59:56.353", "Score": "36", "CreationDate": "2016-02-10T11:55:32.920", "ParentId": "35314297", "CommentCount": "1", "OwnerUserId": "3552770", "LastEditDate": "2017-05-23T11:53:20.327"}});