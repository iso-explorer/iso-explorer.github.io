post_cb({"bq_ids": {"n4140": {"so_13078893_13079051_0": {"length": 4, "quality": 1.0, "section_id": 5482}, "so_13078893_13079051_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5482}, "so_13078893_13079051_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 5512}, "so_13078893_13079051_3": {"length": 25, "quality": 0.7352941176470589, "section_id": 7117}}, "n3337": {"so_13078893_13079051_0": {"length": 4, "quality": 1.0, "section_id": 5268}, "so_13078893_13079051_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5268}, "so_13078893_13079051_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 5298}, "so_13078893_13079051_3": {"length": 25, "quality": 0.7352941176470589, "section_id": 6861}}, "n4659": {"so_13078893_13079051_0": {"length": 4, "quality": 1.0, "section_id": 6917}, "so_13078893_13079051_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 6917}, "so_13078893_13079051_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 6947}, "so_13078893_13079051_3": {"length": 25, "quality": 0.7352941176470589, "section_id": 8618}}}, "13079051": {"Id": "13079051", "PostTypeId": "2", "Body": "<p>The C++ standard states it pretty clearly in 7.3.1.1p1:</p>\n<blockquote>\n<p id=\"so_13078893_13079051_0\">An unnamed-namespace-definition behaves as if it were replaced by</p>\n</blockquote>\n<pre><code>inline(opt) namespace unique { /* empty body */ }\nusing namespace unique ;\nnamespace unique { namespace-body }\n</code></pre>\n<blockquote>\n<p id=\"so_13078893_13079051_1\">where inline appears if and only if it appears in the\n  unnamed-namespace-definition, all occurrences of unique in a\n  translation unit are replaced by the same identifier, and this\n  identifier differs from all other identifiers in the entire program.</p>\n</blockquote>\n<p>So from above, we know that your code actually translates to the following:</p>\n<pre><code>namespace unique1 {}\nusing namespace unique1;\nnamespace unique1 {\n    namespace unique2 {}\n    using namespace unique2;\n    namespace unique2 {\n\n        struct Foo\n        {\n        };\n\n    }\n}\n\nnamespace unique3 {}\nusing namespace unique3;\nnamespace unique3 {\n\n    struct Foo\n    {\n    };\n\n}\n</code></pre>\n<p><s>Therefore, your first <code>Foo</code> can <strong>only</strong> be accessed within <code>namespace unique1</code> and the second <code>Foo</code> can be accessed in the global namespace due to <code>using namespace unique3;</code>.</s> I was wrong. Corrected by comments below.</p>\n<p>Then from 7.3.4p4:</p>\n<blockquote>\n<p id=\"so_13078893_13079051_2\">For unqualified lookup (3.4.1), the using-directive is transitive: if\n  a scope contains a using-directive that nominates a second namespace\n  that itself contains using-directives, the effect is as if the\n  using-directives from the second namespace also appeared in the first.</p>\n</blockquote>\n<p>Therefore, when you refer to <code>Foo</code>, it can mean either <code>unique1::unique2::Foo</code> or <code>unique3::Foo</code>, which is an <strong>error</strong>. <strong>Note that</strong> the other answer says: <code>has hidden unique name that cannot be accessed</code>. This is <strong>incorrect</strong>, they can be accessed due to the using directives, it is just that both names are visible.</p>\n<p><strong>However</strong>, by prepending the scope resolution operator <code>::</code> to <code>Foo</code> you <strong>can</strong> access <code>unique3::Foo</code> because of the following:</p>\n<p>From 3.4.3.2p2:</p>\n<blockquote>\n<p id=\"so_13078893_13079051_3\">For a namespace X and name m, the namespace-qualified lookup set\n  S(X,m) is defined as follows: Let S0(X,m) be the set of all\n  declarations of m in X and the inline namespace set of X (7.3.1). If\n  S0(X,m) is not empty, S(X,m) is S0(X,m); <strong>otherwise, S(X,m) is the\n  union of S(Ni,m) for all namespaces Ni nominated by using-directives\n  in X and its inline namespace set</strong>.</p>\n</blockquote>\n<p>The emphasized part says <code>using-directives in X</code>, which in your case means <code>using namespace unique1;</code> and <code>using namespace unique3;</code>, so the namespace-qualified lookup set looks like this: <code>S(unique3::Foo)</code>, which means <code>unique1::unique2::Foo</code> <strong>is not</strong> included in the set and therefore is not an error.</p>\n", "LastEditorUserId": "906773", "LastActivityDate": "2012-10-26T01:35:13.743", "Score": "3", "CreationDate": "2012-10-25T23:59:23.660", "ParentId": "13078893", "CommentCount": "5", "OwnerUserId": "906773", "LastEditDate": "2012-10-26T01:35:13.743"}, "13078906": {"Id": "13078906", "PostTypeId": "2", "Body": "<p>Yes, this is fully legal, since it does not contradict to anything.</p>\n<p>Unnamed namespace is conceptually equivalent to:</p>\n<pre><code>namespace &lt;09FD8E6E-2DB6-4517-B62D-3B5A657DCC82&gt;\n{\n  // ....\n}\n</code></pre>\n<p>Meaning that each unnamed namespace has hidden unique name that cannot be accessed.</p>\n", "LastEditorUserId": "1459996", "LastActivityDate": "2012-10-26T01:04:32.950", "Score": "0", "CreationDate": "2012-10-25T23:40:06.517", "ParentId": "13078893", "CommentCount": "5", "OwnerUserId": "1459996", "LastEditDate": "2012-10-26T01:04:32.950"}, "13078893": {"ViewCount": "898", "Body": "<p>It is legal in C++ to declare nested anonymous namespaces in the following manner:</p>\n<pre><code>namespace {\n    namespace {\n        struct Foo\n        {\n        };\n    }\n}\n\nnamespace {    \n    struct Foo // SAME IDENTIFIER AS &lt;unnamed&gt;::&lt;unnamed&gt;::Foo!!!\n    {\n    };\n}\n</code></pre>\n<p>However, how would you declare an identifier using an explicitly typed Foo to avoid ambiguity?</p>\n<p>EDITED -- for all of you who do not read the question.</p>\n<p>p.s. I have no intentions to use this sort of constructs, but I need to understand whether it is possible to disambiguate Foo in case someone finds a legitimate use for it. My compiler extension needs to handle all cases.</p>\n", "AcceptedAnswerId": "13079051", "Title": "Nested anonymous namespaces", "CreationDate": "2012-10-25T23:38:38.987", "Id": "13078893", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-26T00:13:24.130", "LastEditorUserId": "383306", "LastActivityDate": "2012-10-26T01:35:13.743", "Score": "4", "OwnerUserId": "383306", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});