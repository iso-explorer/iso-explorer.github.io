post_cb({"bq_ids": {"n4140": {"so_12755837_12755902_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 902}}, "n3337": {"so_12755837_12755902_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 888}}, "n4659": {"so_12755837_12755902_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 962}}}, "12755884": {"Id": "12755884", "PostTypeId": "2", "Body": "<p>Since C++11 stl has a single linked list. Its use is similar to the ordinary double linked list.</p>\n<p>In particular:</p>\n<pre><code>std::forward_list&lt;node&gt; my_list;\n\nfor(auto iter = my_list.begin(); iter != my_list.end(); ++iter)\n{\n   node &amp;curr_node = *iter;\n   // Do something with curr_node.\n}\n</code></pre>\n", "LastEditorUserId": "1459996", "LastActivityDate": "2012-10-06T02:38:20.443", "Score": "4", "CreationDate": "2012-10-06T01:22:23.023", "ParentId": "12755837", "CommentCount": "0", "LastEditDate": "2012-10-06T02:38:20.443", "OwnerUserId": "1459996"}, "12755837": {"ViewCount": "144", "Body": "<p>I want something that provide:</p>\n<pre><code>std::list head;\nstd::list::node node;\nwhile (node = head-&gt;next) {\n    do something with this node\n};\n</code></pre>\n<p>It is rather weird to me that a list does not have a next pointer.</p>\n", "AcceptedAnswerId": "12755902", "Title": "Why stl does not provide c style list?", "CreationDate": "2012-10-06T01:08:14.840", "Id": "12755837", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-10-07T14:53:15.653", "Score": "1", "OwnerUserId": "193251", "Tags": "<c++><list>", "AnswerCount": "3"}, "12755902": {"Id": "12755902", "PostTypeId": "2", "Body": "<p>The actual implementation of the list is hidden. Since the standard dictates the the insertion and erasion of an element at a given position should be possible in constant time we can assume that something like a node is going to be used:</p>\n<blockquote>\n<h2>23.3.5 Class template list [list]</h2>\n<h3>23.3.5.1 Class template list overview [list.overview]</h3>\n<p id=\"so_12755837_12755902_0\">A <code>list</code> is a sequence container that supports bidirectional iterators and allows constant time insert and erase operations anywhere within the sequence, with storage management handled automatically. Unlike vectors (23.3.6) and deques (23.3.3), fast random access to list elements is not supported, but many algorithms only need sequential access anyway.</p>\n</blockquote>\n<p>However, the important thing about C++ container is that they all provide the same interface to actually traverse the content: <strong>iterators</strong>:</p>\n<pre><code>for(std::list&lt;double&gt;::iterator it = list.begin(); it != list.end(); ++it){\n   *it += 3.0; // add 3.0 to each element\n}\n</code></pre>\n<p>If you think about the list as a C-style object with</p>\n<pre><code>struct node{\n    struct node * next;\n    struct node * prev;\n    double value;\n};\n\nstruct list{\n    struct node * first;\n    struct node * last;\n}\n</code></pre>\n<p>the loop above is somewhat equivalent to </p>\n<pre><code>for(struct node * it = list.first; it != list.last + 1; it = it-&gt;next){\n   *it += 3.0; // add 3.0 to each element\n}\n</code></pre>\n<p>However, things like <code>it = it-&gt;next</code> are hidden in the actual implementation of the <code>std::list::iterator</code>. Since they provide an almost* unified interface for all classes you should learn to use them.</p>\n<p>* Some do actually provide a little bit more functionality than others, for example <code>RandomAccessIterators</code> vs. <code>BidirectionalIterators</code>, but this is something you will learn later.</p>\n", "LastActivityDate": "2012-10-06T01:27:39.327", "Score": "3", "CreationDate": "2012-10-06T01:27:39.327", "ParentId": "12755837", "CommentCount": "0", "OwnerUserId": "1139697"}, "12755889": {"Id": "12755889", "PostTypeId": "2", "Body": "<p><strong>It does</strong>. Only the interface changes.</p>\n<ol>\n<li><p><code>std::list</code> stores the item just like your linked-list. If you look up GCC\u00a04.6.1 standard library source code file <code>std_list.h</code> you will find:</p>\n<pre><code>struct _List_node_base\n{\n   _List_node_base* _M_next;\n   _List_node_base* _M_prev;\n   //...\n};\n</code></pre>\n<p>A double-linked list.</p></li>\n<li><p><code>std::list&lt;T&gt;::iterator</code> lets you go through all the elements the same way you\u2019d have used a \"next\" pointer. The same file, line 151, reads:</p>\n<pre><code>_Self&amp;\noperator++()\n{\n  _M_node = _M_node-&gt;_M_next;\n  return *this;\n}\n</code></pre></li>\n<li><p>One of the reason why all the implementation details are hidden from the programmer is that it lets you change container easily. If, for performance reason, you want to use another container or craft your own, you can just change the type.</p>\n<pre><code>typedef std::list&lt;MyItems&gt; itemContainer;\nfor (itemContainer::const_iterator it = allItems.begin(); it != allItems.end(); ++it) \n{\n     // do something\n}\n</code></pre></li>\n</ol>\n", "LastEditorUserId": "748175", "LastActivityDate": "2012-10-07T14:53:15.653", "Score": "4", "CreationDate": "2012-10-06T01:24:16.983", "ParentId": "12755837", "CommentCount": "0", "LastEditDate": "2012-10-07T14:53:15.653", "OwnerUserId": "748175"}});