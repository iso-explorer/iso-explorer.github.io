post_cb({"9622874": {"CommentCount": "1", "ViewCount": "2823", "CreationDate": "2012-03-08T18:31:35.377", "LastActivityDate": "2012-03-08T18:49:06.663", "Title": "Unnamed namespace access rules", "AcceptedAnswerId": "9622896", "PostTypeId": "1", "Id": "9622874", "Score": "4", "Body": "<p>I was looking over section <strong>7.3.1.1</strong> in the C++03 standard expecting to find some description of the access rules for items defined in an unnamed namespace.</p>\n<p>The rules seem to be a little different for unnamed namespaces, since you cannot fully qualify access to items in one. I know that at least within the same translation unit, one can access items in an unnamed namespace as if they were not in a namespace. For example:</p>\n<pre><code>namespace {\n  int foo;\n}\n\nvoid something()\n{\n  foo = 4;\n}\n</code></pre>\n<p>If the namespace had a name, you could not do this. So, where are the rules defined in the standard for these exceptional rules that apply to unnamed namespaces?</p>\n", "Tags": "<c++><namespaces>", "OwnerUserId": "157971", "AnswerCount": "2"}, "9622896": {"ParentId": "9622874", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>An anonymous namespace is basically treated as:</p>\n<pre><code>namespace unique_per_TU\n{\n    // Stuff\n}\nusing namespace unique_per_TU;\n</code></pre>\n<p>I'll try to find the reference here in a minute.</p>\n<p>EDIT:</p>\n<p>It appears you already found it in <code>7.3.1.1/1</code></p>\n<blockquote>\n<p id=\"so_9622874_9622896_0\">An unnamed namespace definition behaves as if it were replaced by</p>\n</blockquote>\n<pre><code>namespace unique { /* empty body */ }\nusing namespace unique;\nnamespace unique { namespacebody }\n</code></pre>\n<blockquote>\n<p id=\"so_9622874_9622896_1\">where all occurrences of unique in\n  a translation unit are replaced by the same identifier and this\n  identifier differs from all other identifiers in the entire program.</p>\n</blockquote>\n<p>The \"fake\" using already brings the namespace members into the global namespace as you discovered.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2012-03-08T18:49:06.663", "Id": "9622896", "Score": "5", "CreationDate": "2012-03-08T18:33:24.733", "LastActivityDate": "2012-03-08T18:49:06.663"}, "bq_ids": {"n4140": {"so_9622874_9623023_0": {"section_id": 7067, "quality": 0.9166666666666666, "length": 66}, "so_9622874_9622896_1": {"section_id": 5482, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_9622874_9623023_0": {"section_id": 6811, "quality": 0.9166666666666666, "length": 66}, "so_9622874_9622896_1": {"section_id": 5268, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_9622874_9623023_0": {"section_id": 8564, "quality": 0.7222222222222222, "length": 52}, "so_9622874_9622896_1": {"section_id": 6917, "quality": 0.8666666666666667, "length": 13}}}, "9623023": {"ParentId": "9622874", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Apart from the standard quote which defines Unnamed Namespaces in 7.3.1.1/1,<br>\nThis is explicitly stated in one of the examples in   </br></p>\n<p><strong>3.3.5/1 Namespace Scope:</strong> </p>\n<blockquote>\n<p id=\"so_9622874_9623023_0\">The declarative region of a <em>namespace-definition</em> is its <em>namespace-body</em>. The potential scope denoted by an <em>original-namespace-name</em> is the concatenation of the declarative regions established by each of the <em>namespace-definitions</em> in the same declarative region with that <em>original-namespace-name</em>. Entities declared in a <em>namespace-body</em> are said to be members of the namespace, and names introduced by these declarations into the declarative region of the namespace are said to be member names of the namespace. A namespace member name has namespace scope. Its potential scope includes its namespace from the name\u2019s point of declaration (3.3.1) onwards; and for each <em>using-directive</em> (7.3.4) that nominates the member\u2019s namespace,\n  the member\u2019s potential scope includes that portion of the potential scope of the <em>using-directive</em> that follows the member\u2019s point of declaration.</p>\n</blockquote>\n<pre><code>&gt;[Example:\nnamespace N {\n      int i;\n      int g(int a) { return a; }\n      int j();\n      void q();\n}\nnamespace { int l=1; }\n// the potential scope of l is from its point of declaration\n// to the end of the translation unit\n\nnamespace N {\n    int g(char a) // overloadsN::g(int)\n    {\n        return l+a; // l is from unnamed namespace\n    }\n    int i; // error: duplicate definition\n    int j(); // OK: duplicate function declaration\n    int j() // OK: definition ofN::j()\n    {\n       return g(i); // callsN::g(int)\n    }\n    int q(); // error: different return type\n}\n</code></pre>\n<blockquote>\n<p id=\"so_9622874_9623023_1\">\u2014end example]</p>\n</blockquote>\n<p>Note the wordings:<br>\n<strong>the potential scope of <code>l</code> is from its point of declaration to the end of the translation unit</strong></br></p>\n", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-03-08T18:48:40.390", "Id": "9623023", "Score": "2", "CreationDate": "2012-03-08T18:42:56.383", "LastActivityDate": "2012-03-08T18:48:40.390"}});