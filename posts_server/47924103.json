post_cb({"bq_ids": {"n4140": {"so_47924103_47924103_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 2578}}, "n3337": {"so_47924103_47924103_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 2543}}, "n4659": {"so_47924103_47924103_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 8733}, "so_47924103_47924103_1": {"length": 12, "quality": 1.0, "section_id": 8733}}}, "47927899": {"Id": "47927899", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47924103_47927899_0\">More generally, what is the rationale for distinguishing the notion of <em>pointer-interconvertibility</em> from the notion of having the same address?</p>\n</blockquote>\n<p>It is hard if not impossible to answer <em>why</em> certain decisions are made by the standard, but this is my take.</p>\n<p>Logically, pointers points to <em>objects</em>, not addresses. Addresses are the <em>value representations</em> of pointers. The distinction is particularly important when reusing the space of an object containing <code>const</code> members</p>\n<pre><code>struct S {\n    const int i;\n};\n\nS s = {42};\nauto ps = &amp;s;\nnew (ps) S{420};\nfoo(ps-&gt;i);  // UB, requires std::launder\n</code></pre>\n<p>That a pointer with the same <em>value representation</em> can be used as if it were the same pointer should be thought of as the special case instead of the other way round.</p>\n<p>Practically, the standard tries to place as little restriction as possible on implementations. <em>Pointer-interconvertibility</em> is the condition that pointers may be <code>reinterpret_cast</code> and yield the correct result. Seeing as how <code>reinterpret_cast</code> is meant to be compiled into nothing, it also means the pointers share the same <em>value representation</em>. Since that places more restrictions on implementations, the condition won't be given without compelling reasons.</p>\n", "LastActivityDate": "2017-12-21T15:18:53.300", "Score": "3", "CreationDate": "2017-12-21T15:18:53.300", "ParentId": "47924103", "CommentCount": "7", "OwnerUserId": "4832499"}, "47924103": {"ViewCount": "490", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"noreferrer\">working draft of the standard N4659</a> says:</p>\n<blockquote>\n<p id=\"so_47924103_47924103_0\">[basic.compound]<br>\n  If two objects are pointer-interconvertible, then they have the same address</br></p>\n</blockquote>\n<p>and then notes that</p>\n<blockquote>\n<p id=\"so_47924103_47924103_1\">An array object and its first element are not pointer-interconvertible, even though they have the same address</p>\n</blockquote>\n<p>What is the rationale for making an array object and its first element non-pointer-interconvertible? More generally, what is the rationale for distinguishing the notion of pointer-interconvertibility from the notion of having the same address? Isn't there a contradiction in there somewhere?</p>\n<p>It would appear that given this sequence of statements</p>\n<pre><code>int a[10];\n\nvoid* p1 = static_cast&lt;void*&gt;(&amp;a[0]);\nvoid* p2 = static_cast&lt;void*&gt;(&amp;a);\n\nint* i1 = static_cast&lt;int*&gt;(p1);\nint* i2 = static_cast&lt;int*&gt;(p2);\n</code></pre>\n<p>we have <code>p1 == p2</code>, however, <code>i1</code> is well defined and using <code>i2</code> would result in UB.</p>\n", "AcceptedAnswerId": "47934218", "Title": "Pointer interconvertibility vs having the same address", "CreationDate": "2017-12-21T11:35:14.633", "LastActivityDate": "2017-12-22T07:14:02.260", "CommentCount": "16", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-21T16:00:20.087", "LastEditorUserId": "3545273", "Id": "47924103", "Score": "18", "OwnerUserId": "775806", "Tags": "<c++><language-lawyer><c++17>", "AnswerCount": "3"}, "47929196": {"Id": "47929196", "PostTypeId": "2", "Body": "<p>Because the comittee wants to make clear that an array is a low level concept an not a first class object: you cannot return an array nor assign to it for example. Pointer-interconvertibility is meant to be a concept between objects of same <em>level</em>: only standard layout classes or unions.</p>\n<p>The concept is seldom used in the whole draft: in [expr.static.cast] where it appears as a special case, in [class.mem] where a note says that for standard layout classes, pointers an object and its first subobject are interconvertible, in [class.union] where pointers to the union and its non static data members are also declared interconvertible and in [ptr.launder].</p>\n<p>That last occurence separates 2 use cases: either pointers are interconvertible, or one element is an array. This is stated in a remark and not in a note like it is in [basic.compound], so it makes it more clear that <em>pointer-interconvertibility</em> willingly does not concern arrays.</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2017-12-22T07:14:02.260", "Score": "2", "CreationDate": "2017-12-21T16:38:14.870", "ParentId": "47924103", "CommentCount": "6", "OwnerUserId": "3545273", "LastEditDate": "2017-12-22T07:14:02.260"}, "47934218": {"Id": "47934218", "PostTypeId": "2", "Body": "<p>There are apparently existing implementations that optimize based on this. Consider:</p>\n<pre><code>struct A {\n    double x[4];\n    int n;\n};\n\nvoid g(double* p);\n\nint f() {\n    A a { {}, 42 };\n    g(&amp;a.x[1]);\n    return a.n; // optimized to return 42;\n                // valid only if you can't validly obtain &amp;a.n from &amp;a.x[1]\n}\n</code></pre>\n<p>Given <code>p = &amp;a.x[1];</code>, <code>g</code> might attempt to obtain access to <code>a.n</code> by <code>reinterpret_cast&lt;A*&gt;(reinterpret_cast&lt;double(*)[4]&gt;(p - 1))-&gt;n</code>. If the inner cast successfully yielded a pointer to <code>a.x</code>, then the outer cast will yield a pointer to <code>a</code>, giving the class member access defined behavior and thus outlawing the optimization.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2017-12-21T23:55:53.567", "Score": "10", "CreationDate": "2017-12-21T23:45:16.527", "ParentId": "47924103", "CommentCount": "14", "OwnerUserId": "2756719", "LastEditDate": "2017-12-21T23:55:53.567"}});