post_cb({"24678735": {"ViewCount": "700", "Body": "<p>My network code uses template specialization to serialize types that can not simply be copied. I defined a general template</p>\n<pre><code>template&lt;typename T&gt; struct TypeHandler\n</code></pre>\n<p>that handles all types that can be transported by a simple <code>memcpy</code> and then I define specializations for all other types. The problem now is that I have a file with multiple such specializations and if I compile the code with Visual Studio everything works fine. But with gcc all template specializations in that file get used with the exception of</p>\n<pre><code>template&lt;&gt; struct TypeHandler&lt;uint32_t&gt;\n</code></pre>\n<p>which variable length encodes the integer to save space.</p>\n<p>Namespaces are the same for all TypeHandler versions and they are even in the same file. But for some reason gcc decides to use the generalized version and I don't really know why.</p>\n<p>EDIT:</p>\n<p>It seems that gcc uses the instantiation of TypeHandler from an other project that this one links against but doesnt have a specialization for uint32_t even so it transmits uint32_t fields. GCC doesnt give me any error though. How can i tell gcc to use the specialization like Visual Studio does ?</p>\n<p>EDIT2:</p>\n<p>managed to generate an SSCCE <a href=\"http://netload.in/dateiz3R4eTVqi3/src.tar.gz.htm\" rel=\"nofollow\">http://netload.in/dateiz3R4eTVqi3/src.tar.gz.htm</a>\nthe bug here is the other way around but well.</p>\n<p>EDIT3:\nfixed filesize : <a href=\"http://netload.in/dateixP6iOvc6bD/src.zip.htm\" rel=\"nofollow\">http://netload.in/dateixP6iOvc6bD/src.zip.htm</a></p>\n", "Title": "gcc does not find template specialization", "CreationDate": "2014-07-10T14:07:32.540", "LastActivityDate": "2014-08-03T09:26:25.497", "CommentCount": "10", "LastEditDate": "2014-07-10T17:43:53.647", "PostTypeId": "1", "LastEditorUserId": "1366591", "Id": "24678735", "Score": "1", "OwnerUserId": "1366591", "Tags": "<c++><templates><gcc><template-specialization>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24678735_24683940_0": {"length": 59, "quality": 1.0, "section_id": 268}, "so_24678735_24683940_1": {"length": 105, "quality": 0.9905660377358491, "section_id": 269}}, "n3337": {"so_24678735_24683940_0": {"length": 59, "quality": 1.0, "section_id": 259}, "so_24678735_24683940_1": {"length": 105, "quality": 0.9905660377358491, "section_id": 260}}, "n4659": {"so_24678735_24683940_0": {"length": 59, "quality": 1.0, "section_id": 275}, "so_24678735_24683940_1": {"length": 105, "quality": 0.9905660377358491, "section_id": 276}}}, "24683940": {"Id": "24683940", "PostTypeId": "2", "Body": "<p>Minimized to:</p>\n<p><code>test1.cpp</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n\ntemplate&lt;typename T&gt;\nstruct TypeHandler\n{\n    void Print() { std::cout &lt;&lt; \"base\" &lt;&lt; std::endl; }\n};\n\n\nvoid test1()\n{\n    std::cout &lt;&lt; \"p1\" &lt;&lt; std::endl;\n    TypeHandler&lt;uint32_t&gt;().Print();\n}\n</code></pre>\n<p><code>test2.cpp</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdint.h&gt;\n\ntemplate&lt;typename T&gt;\nstruct TypeHandler\n{\n    void Print() { std::cout &lt;&lt; \"base\" &lt;&lt; std::endl; }\n};\n\ntemplate&lt;&gt;\nstruct TypeHandler&lt;uint32_t&gt;\n{\n    void Print() { std::cout &lt;&lt; \"int\" &lt;&lt; std::endl; }\n};\n\nvoid test2()\n{\n    std::cout &lt;&lt; \"p2\" &lt;&lt; std::endl;\n    TypeHandler&lt;uint32_t&gt;().Print();\n}\n</code></pre>\n<p><code>main.cpp</code>:</p>\n<pre><code>void test1();\nvoid test2();\nint main(){\n    test1();\n    test2();\n}\n</code></pre>\n<p>On Windows/MinGW 4.8.2, compiling with <code>g++ test1.cpp test2.cpp main.cpp -o test</code> and running produces</p>\n<pre><code>p1\nbase\np2\nbase\n</code></pre>\n<p>while using <code>g++ test2.cpp test1.cpp main.cpp -o test</code> produces</p>\n<pre><code>p1\nint\np2\nint\n</code></pre>\n<p>This is a straightforward standard violation causing undefined behavior. You can't explicitly specialize the same template in one translation unit but not the other. The explicit specialization is not visible in <code>test1.cpp</code>, causing the compiler to generate an implicit instantiation from the base template. So you get two <code>TypeHandler&lt;uint32_t&gt;</code> specializations, and in this instance it appears that the linker decided to pick the one from the first object file it saw. From \u00a714.7.3 [temp.expl.spec]/p6 of the standard  (emphasis mine):</p>\n<blockquote>\n<p id=\"so_24678735_24683940_0\">If a template, a member template or a member of a class template is\n  explicitly specialized then <strong>that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs</strong>; no diagnostic is required. If the program\n  does not provide a definition for an explicit specialization and\n  either the specialization is used in a way that would cause an\n  implicit instantiation to take place or the member is a virtual member\n  function, the program is ill-formed, no diagnostic required.  An\n  implicit instantiation is never generated for an explicit\n  specialization that is declared but not defined.</p>\n</blockquote>\n<p>Also, obligatory quote of the next paragraph (emphasis mine):</p>\n<blockquote>\n<p id=\"so_24678735_24683940_1\">The placement of explicit specialization declarations for function\n  templates, class templates, member functions of class templates,\n  static data members of class templates, member classes of class\n  templates, member  enumerations of class templates, member class\n  templates of class templates, member function templates of class\n  templates, member functions of member templates of class templates,\n  member functions of member templates of non-template classes, member\n  function templates of member classes of class templates, etc., and the\n  placement of partial specialization declarations of class templates,\n  member class templates of non-template classes, member class templates\n  of class templates, etc., can affect whether a program is well-formed\n  according to the relative positioning of the explicit specialization\n  declarations and their points of instantiation in the translation unit\n  as specified above and below. <strong>When writing a specialization, be\n  careful about its location; or to make it compile will be such a trial\n  as to kindle its self-immolation.</strong></p>\n</blockquote>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:26:25.497", "Score": "2", "CreationDate": "2014-07-10T18:38:23.997", "ParentId": "24678735", "CommentCount": "8", "OwnerUserId": "2756719", "LastEditDate": "2014-08-03T09:26:25.497"}});