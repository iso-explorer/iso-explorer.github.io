post_cb({"23660639": {"Id": "23660639", "PostTypeId": "2", "Body": "<p>Calling the destructor is delicate because it leaves an object in an undefined state. Any read from this object is undefined. In praticular, calling the destructor second time - which will always happen for local variables.</p>\n<p>I think in your case you mixed the operations on the list with those on the window.</p>\n<p>A constructor should only stabilize the invariant on the <em>current</em> object. Putting it inside a list should not be the responsibility of the constructor, in normal circumstances.</p>\n<p>Don't call the destructor on <code>CLOSE</code>. Deallocate the struct, and put <code>nullptr</code> in <code>_handler</code>. That's all.</p>\n", "LastActivityDate": "2014-05-14T16:51:43.820", "CommentCount": "0", "CreationDate": "2014-05-14T16:51:43.820", "ParentId": "23660498", "Score": "0", "OwnerUserId": "2289509"}, "23660498": {"ViewCount": "137", "Body": "<p>I got a <code>Window</code> class that is a wrapper to some C struct. <br/>\nThe class has a static <code>vector&lt;Window*&gt; windows_</code> that is a list containing created windows. <br/>\n<code>Window</code> constructor does two things:</p>\n<ul>\n<li><code>handle_ = SDL_CreateWindow( ... );</code> that basically allocates the C struct and store the pointer in a member variable <code>handle_</code>;</li>\n<li>pushes <code>this</code> in the list.</li>\n</ul>\n<p><code>Window</code> destructor does three things but only if <code>handle_</code> is not a <code>nullptr</code>:</p>\n<ul>\n<li><code>SDL_DestroyWindow()</code> deallocates the C struct;</li>\n<li>removes <code>this</code> from the list.</li>\n<li><code>handle_ = nullptr;</code></li>\n</ul>\n<p>Then, in my <code>main</code> I declare a <code>Window</code> as a local variable. <br/>\nWhen the window receives the <code>CLOSE</code> event, I call that window's destructor. <br/>\nThen, when the window goes out of scope, the window's destructor gets called again and I receive a segmentation error. <br/></p>\n<p>I know expicitly calling a destructor is delicate but I don't really know why. <br/>\nSo the question is twofold:</p>\n<p>Why is it crashing?</p>\n<p>What design can I use to avoid calling the destructor?</p>\n", "AcceptedAnswerId": "23660726", "Title": "Design: How to avoid calling destructor?", "CreationDate": "2014-05-14T16:43:06.217", "Id": "23660498", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2014-05-14T17:16:06.910", "Score": "0", "OwnerUserId": "3527769", "Tags": "<c++><design><destructor>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_23660498_23660634_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 411}}, "n3337": {"so_23660498_23660634_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 402}}, "n4659": {"so_23660498_23660634_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 429}}}, "23660634": {"Id": "23660634", "PostTypeId": "2", "Body": "<p>You really shouldn't be calling the destructor to variables with automatic storage explicitly, this is undefined behavior:</p>\n<p>Standard 12.4<code>[class.dtor]</code>/15</p>\n<blockquote>\n<p id=\"so_23660498_23660634_0\">Once a destructor is invoked for an object, the object no longer\n  exists; the behavior is undefined if the destructor is invoked for an\n  object whose lifetime has ended (3.8). [ <strong>Example: if the destructor\n  for an automatic object is explicitly invoked, and the block is\n  subsequently left in a manner that would ordinarily invoke implicit\n  destruction of the object, the behavior is undefined. \u2014end example</strong> ]</p>\n</blockquote>\n<p>instead of looking for a <strong>\"hacky\"</strong> way of disabling the automatic destructor call or something else you should probably look for a better design.</p>\n<p>Making a <code>DestroyWindow()</code> member function that takes care of the cleanup and sets a flag inside the class, but having the destructor check that flag and destroy the window (+ the other cleanup) if it wasn't done manually would already fix a lot.</p>\n<hr>\n<p>To make it clear you probably want it like the <code>fstream</code> and other streams in the standard library. You can explicitly call close on them, but if you don't do it it gets done in the destructor for you as to not leak resources. But note that this <strong>shouldn't be done through explicit destructor calls. (<code>fstream</code> for example got a <code>close</code> member function for explicitly closing it.)</strong></p>\n</hr>", "LastEditorUserId": "1942027", "LastActivityDate": "2014-05-14T17:16:06.910", "Score": "0", "CreationDate": "2014-05-14T16:51:31.180", "ParentId": "23660498", "CommentCount": "0", "OwnerUserId": "1942027", "LastEditDate": "2014-05-14T17:16:06.910"}, "23660890": {"Id": "23660890", "PostTypeId": "2", "Body": "<p>Your code needs to keep state as to whether your resource was cleaned up. Typically you set a handle to -1 or a pointer to nullptr:</p>\n<pre><code>class MyResourceContainer {\n    MyResourceContainer(int someParameter) {\n        open(someParameter);\n    }\n\n    ~MyResourceContainer() {\n        close();\n    }\n\n    void open(int someParameter) {\n        if(handle &gt; -1) {\n            // throw exception or close(), whatever you prefer\n        } \n\n        // allocate resource using specified parameter\n        handle = 42;\n    }\n\n    // can be called multiple times\n    void close() {\n        if(handle &gt; -1) {\n            // release resource\n            handle = -1;\n        }\n    }\n\nprivate:\n    int handle = -1;\n};\n</code></pre>\n", "LastActivityDate": "2014-05-14T17:04:27.557", "CommentCount": "0", "CreationDate": "2014-05-14T17:04:27.557", "ParentId": "23660498", "Score": "0", "OwnerUserId": "95976"}, "23660726": {"Id": "23660726", "PostTypeId": "2", "Body": "<p>You should post some code so we can see exactly what is happening, but you're right that you <strong>shouldn't manually call the destructor</strong> because that will cause undefined behavior (see Raphael Miedl's answer).  Instead, add a method to the class to close the window, and use the class to provide a safe interface to the SDL window functions.  Here is a sketch:</p>\n<pre><code>class Window {\nprivate:\n    SDL_Window *window_;\n\npublic:\n    Window() : window_(nullptr) { }\n    Window(const Window &amp;) = delete;\n    Window(Window &amp;&amp;w) : window_(w.window_) { w.window_ = nullptr; }\n    Window(const char* title, int x, int y, int w, int h, Uint32 flags)\n        : window(SDL_CreateWindow(title, x, y, w, h, flags))\n    { }\n\n    ~Window()\n    {\n        if (window_ != nullptr)\n            SDL_DestroyWindow(window_);\n    }\n\n    Window &amp;operator=(const Window &amp;) = delete;\n    Window &amp;operator=(Window &amp;&amp;w)\n    {\n        if (window_) { SDL_DestroyWindow(window_); window_ = nullptr; }\n        window_ = w.window_;\n        w.window_ = nullptr;\n    }\n\n    operator bool() const\n    {\n        return window_ != nullptr;\n    }\n\n    void close()\n    {\n        if (window_ != nullptr) {\n            SDL_DestroyWindow(window_);\n            window_ = nullptr;\n        }\n    }\n};\n</code></pre>\n", "LastActivityDate": "2014-05-14T16:55:36.427", "CommentCount": "3", "CreationDate": "2014-05-14T16:55:36.427", "ParentId": "23660498", "Score": "0", "OwnerUserId": "82294"}});