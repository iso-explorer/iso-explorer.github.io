post_cb({"12444503": {"CommentCount": "12", "ViewCount": "2136", "PostTypeId": "1", "LastEditorUserId": "430766", "CreationDate": "2012-09-16T04:57:09.683", "LastActivityDate": "2012-10-01T17:00:55.117", "Title": "What's wrong with copy-construction of a shared_ptr from an implicit cast?", "AcceptedAnswerId": "12630072", "LastEditDate": "2012-09-16T05:41:14.063", "Id": "12444503", "Score": "12", "Body": "<p>Consider this minimal example:</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct B {\n  typedef std::shared_ptr&lt;B&gt; Ptr;\n};\n\nstruct A {\n  operator B::Ptr() { // type conversion operator                  &lt;----+\n    return std::make_shared&lt;B&gt;();  //                                   |\n  }                                //                                   |\n};                                 //                                   |\n                                   //                                   |\nint main() {                       //                                   |\n  A* a = new A;                    //                                   |\n  B::Ptr{*a}; // copy construction from a's implicit cast to B::Ptr ----+ \n}\n</code></pre>\n<p>This innocent copy construction of a <code>shared_ptr&lt;B&gt;</code> <strong>fails horribly on g++ 4.6.3 x86_64-linux-gnu</strong> but appears to work for <a href=\"http://ideone.com/RKkgS\" rel=\"noreferrer\">g++ 4.5</a> (note that the newer version breaks, while the older works!). From what I can tell from the error (see below) g++ 4.6 seems to pass <code>A</code> by value, instead of by (r or l) reference.</p>\n<p>So, the question is, which is correct and which is broken? Is this behaviour supposed to fail? If so, why?<br>\nAs far as I understand conversion rules, the implicit cast to <code>B::Ptr</code> <em>should</em> be attempted at this point, right?</br></p>\n<hr>\n<p><sub>Note: I reduced this example to the bare technical problem, and this code doesn't make sense for any production-system as it stands.</sub></p>\n<p>Here is the precise error:</p>\n<pre><code>shp.cpp: In function \u2018int main()\u2019:\nshp.cpp:17:12: error: no matching function for call to \u2018std::shared_ptr&lt;B&gt;::shared_ptr(&lt;brace-enclosed initializer list&gt;)\u2019\nshp.cpp:17:12: note: candidates are:\n/usr/include/c++/4.6/bits/shared_ptr.h:315:2: note: template&lt;class _Alloc, class ... _Args&gt; std::shared_ptr::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&amp;, _Args&amp;&amp; ...)\n/usr/include/c++/4.6/bits/shared_ptr.h:266:17: note: constexpr std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::nullptr_t) [with _Tp = B, std::nullptr_t = std::nullptr_t]\n/usr/include/c++/4.6/bits/shared_ptr.h:266:17: note:   no known conversion for argument 1 from \u2018A\u2019 to \u2018std::nullptr_t\u2019\n/usr/include/c++/4.6/bits/shared_ptr.h:258:2: note: template&lt;class _Tp1, class _Del&gt; std::shared_ptr::shared_ptr(std::unique_ptr&lt;_Up, _Ep&gt;&amp;&amp;)\n/usr/include/c++/4.6/bits/shared_ptr.h:253:2: note: template&lt;class _Tp1&gt; std::shared_ptr::shared_ptr(std::auto_ptr&lt;_Tp1&gt;&amp;&amp;)\n/usr/include/c++/4.6/bits/shared_ptr.h:248:11: note: template&lt;class _Tp1&gt; std::shared_ptr::shared_ptr(const std::weak_ptr&lt;_Tp1&gt;&amp;)\n/usr/include/c++/4.6/bits/shared_ptr.h:236:2: note: template&lt;class _Tp1, class&gt; std::shared_ptr::shared_ptr(std::shared_ptr&lt;_Tp1&gt;&amp;&amp;)\n/usr/include/c++/4.6/bits/shared_ptr.h:226:7: note: std::shared_ptr&lt;_Tp&gt;::shared_ptr(std::shared_ptr&lt;_Tp&gt;&amp;&amp;) [with _Tp = B, std::shared_ptr&lt;_Tp&gt; = std::shared_ptr&lt;B&gt;]\n/usr/include/c++/4.6/bits/shared_ptr.h:226:7: note:   no known conversion for argument 1 from \u2018A\u2019 to \u2018std::shared_ptr&lt;B&gt;&amp;&amp;\u2019\n/usr/include/c++/4.6/bits/shared_ptr.h:218:2: note: template&lt;class _Tp1, class&gt; std::shared_ptr::shared_ptr(const std::shared_ptr&lt;_Tp1&gt;&amp;)\n/usr/include/c++/4.6/bits/shared_ptr.h:206:2: note: template&lt;class _Tp1&gt; std::shared_ptr::shared_ptr(const std::shared_ptr&lt;_Tp1&gt;&amp;, _Tp*)\n/usr/include/c++/4.6/bits/shared_ptr.h:184:2: note: template&lt;class _Deleter, class _Alloc&gt; std::shared_ptr::shared_ptr(std::nullptr_t, _Deleter, _Alloc)\n/usr/include/c++/4.6/bits/shared_ptr.h:165:2: note: template&lt;class _Tp1, class _Deleter, class _Alloc&gt; std::shared_ptr::shared_ptr(_Tp1*, _Deleter, _Alloc)\n/usr/include/c++/4.6/bits/shared_ptr.h:146:2: note: template&lt;class _Deleter&gt; std::shared_ptr::shared_ptr(std::nullptr_t, _Deleter)\n/usr/include/c++/4.6/bits/shared_ptr.h:129:2: note: template&lt;class _Tp1, class _Deleter&gt; std::shared_ptr::shared_ptr(_Tp1*, _Deleter)\n/usr/include/c++/4.6/bits/shared_ptr.h:112:11: note: template&lt;class _Tp1&gt; std::shared_ptr::shared_ptr(_Tp1*)\n/usr/include/c++/4.6/bits/shared_ptr.h:103:7: note: std::shared_ptr&lt;_Tp&gt;::shared_ptr(const std::shared_ptr&lt;_Tp&gt;&amp;) [with _Tp = B, std::shared_ptr&lt;_Tp&gt; = std::shared_ptr&lt;B&gt;]\n/usr/include/c++/4.6/bits/shared_ptr.h:103:7: note:   no known conversion for argument 1 from \u2018A\u2019 to \u2018const std::shared_ptr&lt;B&gt;&amp;\u2019\n/usr/include/c++/4.6/bits/shared_ptr.h:100:17: note: constexpr std::shared_ptr&lt;_Tp&gt;::shared_ptr() [with _Tp = B]\n/usr/include/c++/4.6/bits/shared_ptr.h:100:17: note:   candidate expects 0 arguments, 1 provided\n</code></pre>\n</hr>", "Tags": "<c++><c++11><compiler-errors><g++><type-conversion>", "OwnerUserId": "430766", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_12444503_12630072_0": {"section_id": 599, "quality": 1.0, "length": 6}, "so_12444503_12630072_1": {"section_id": 609, "quality": 0.5666666666666667, "length": 17}}, "n3337": {"so_12444503_12630072_0": {"section_id": 589, "quality": 1.0, "length": 6}, "so_12444503_12630072_1": {"section_id": 599, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_12444503_12630072_0": {"section_id": 622, "quality": 1.0, "length": 6}, "so_12444503_12630072_1": {"section_id": 635, "quality": 0.5666666666666667, "length": 17}}}, "12630072": {"ParentId": "12444503", "LastEditDate": "2017-05-23T11:53:23.413", "CommentCount": "3", "CreationDate": "2012-09-27T21:10:21.683", "OwnerUserId": "567292", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "12630072", "Score": "5", "Body": "<p>The code is incorrect under the current version of the standard (I'm looking at post-standard draft n3376).</p>\n<p>The rules for list-initialization specify:</p>\n<blockquote>\n<h3>13.3.1.7 Initialization by list-initialization [over.match.list]</h3>\n<p id=\"so_12444503_12630072_0\">1 - When objects of non-aggregate class type <code>T</code> are list-initialized [...]:</p>\n<ul>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements of the initializer list.</li>\n</ul>\n</blockquote>\n<p>However, when overload resolution is applied to the copy constructor of <code>B::Ptr</code> taking the single parameter <code>const std::shared_ptr&lt;B&gt; &amp;</code>, the argument list is <code>(*a)</code>, consisting of a single element of type <em>lvalue</em> <code>A</code>; overload resolution is not permitted to consider the conversion function <code>A::operator B::Ptr</code>:</p>\n<blockquote>\n<h3>13.3.3.1 Implicit conversion sequences [over.best.ics]</h3>\n<p id=\"so_12444503_12630072_1\">4 - However, when considering the argument of a constructor or user-defined conversion function that is a candidate [...] by 13.3.1.7 [...] when the initializer list has exactly one element and a conversion to some class X or reference to (possibly cv-quali\ufb01ed) X is considered for the first parameter of a constructor of X [...], only standard conversion sequences and ellipsis conversion sequences are considered.</p>\n</blockquote>\n<p>So g++-4.6 is correct to reject this code; g++-4.7.2 unfortunately accepts it, which is incorrect.</p>\n<p>The correct way to write this would be to use direct-initialization (<code>B::Ptr(*a)</code>) or a <code>static_cast&lt;B::Ptr&gt;</code>.</p>\n<p>The restriction on the allowable conversions can be traced to paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2672.htm\" rel=\"nofollow noreferrer\">n2672</a>, although in that paper the paragraph 13.3.3.1p4 only applies to <em>the argument of a user-defined conversion function</em>.  The additional restriction on constructors was added in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3006.html#978\" rel=\"nofollow noreferrer\">defect 978</a>:</p>\n<blockquote>\n<h3>978. Incorrect specification for copy initialization</h3>\n<p id=\"so_12444503_12630072_2\">13.3.3.1 [over.best.ics] paragraph 4 says,<br/>[...]<br/>\n  This is not quite right, as this applies to constructor arguments, not just arguments of user-defined conversion functions.</p>\n</blockquote>\n<p>The current wording of 13.3.3.1p4 can be traced to the seminal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#84\" rel=\"nofollow noreferrer\">defect 84</a>, which introduced the \"<em>common-law rule that only a single user-defined conversion will be called to do an implicit conversion</em>\".</p>\n<p>I'm a bit uneasy about this answer; I've asked <a href=\"https://stackoverflow.com/questions/12677711/is-it-possible-to-invoke-a-user-defined-conversion-function-via-list-initializat\">Is it possible to invoke a user-defined conversion function via list-initialization?</a> to see if anyone can clarify the intent of the standard here.</p>\n", "LastActivityDate": "2012-10-01T17:00:55.117"}});