post_cb({"4182013": {"ViewCount": "347", "Body": "<p>I have seen following style class definition several times. What exactly are the pros/cons of this style?</p>\n<pre><code>typedef class _MyClass\n{\npublic :\n  _MyClass();\n} MyClass;\n</code></pre>\n", "AcceptedAnswerId": "4182033", "Title": "What are the pros/cons of this class definition style?", "CreationDate": "2010-11-15T06:43:31.237", "Id": "4182013", "CommentCount": "3", "LastEditDate": "2012-10-10T16:54:31.997", "PostTypeId": "1", "LastEditorUserId": "20770", "LastActivityDate": "2012-10-10T16:54:31.997", "Score": "3", "OwnerUserId": "467947", "Tags": "<c++><typedef>", "AnswerCount": "3"}, "4182095": {"Id": "4182095", "PostTypeId": "2", "Body": "<p>One possible advantage is illustrated by a highly contrived example, but since the Standard speaks of it, it must be having an impliciation for sure.</p>\n<blockquote>\n<p id=\"so_4182013_4182095_0\">$7.1.3/6- \"Similarly, in a given\n  scope, a class or enumeration shall\n  not be declared with the same name as\n  a typedef-name that is declared in\n  that scope and refers to a type other\n  than the class or enumeration itself.\n  [</p>\n</blockquote>\n<pre><code>typedef struct S{} MYS;\n\nint MYS;                     // Error due to $7.1.3/6\n\nstruct A{};\n\nint A;                       // No error, subsequent use required fully elaborated name\n\nint main(){}\n</code></pre>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-11-15T07:12:34.337", "Score": "2", "CreationDate": "2010-11-15T06:59:24.693", "ParentId": "4182013", "CommentCount": "1", "OwnerUserId": "418110", "LastEditDate": "2010-11-15T07:12:34.337"}, "4182033": {"Id": "4182033", "PostTypeId": "2", "Body": "<p>It's pretty rare in C++, but common in C (where <code>struct Foo</code> does not automatically alias to just <code>Foo</code>.) You might see it in a library that has different classes for different platforms (e.g. a \"Canvas\" class, which is very implementation-specific.) The library would use the <code>typedef</code> to let its users simplify their code:</p>\n<pre><code>#if WINDOWS\n    typedef class WindowsCanvas {\n        private: HWND handle;\n    } Canvas;\n#elif MAC\n    typedef class MacCanvas {\n        private: CGContextRef context;\n    } Canvas;\n#endif\n</code></pre>\n<p>In such an example, one would only need to use the <code>Canvas</code> type, never the platform-specific types.</p>\n", "LastActivityDate": "2010-11-15T06:46:36.107", "CommentCount": "2", "CreationDate": "2010-11-15T06:46:36.107", "ParentId": "4182013", "Score": "3", "OwnerUserId": "265530"}, "4182031": {"Id": "4182031", "PostTypeId": "2", "Body": "<p>In C++ there are no pros. This style came from C where you couldn't just use the struct's name as a type. E.g.</p>\n<pre><code>struct X\n{\n   int x;\n};\n\nX a; //compiler error\nstruct X b; //OK\n</code></pre>\n<p>in order to avoid using the elaborated type specifier, like <code>struct X a</code>, or <code>enum E e;</code> etc. in C it is a common practice to typedef the name. \nE.G.</p>\n<pre><code>typedef struct X_ { ... } X;\n</code></pre>\n<p>Now <code>X a;</code> is OK too.</p>\n<p>Naturally in C++ there is no need to do this.</p>\n", "LastActivityDate": "2010-11-15T06:46:23.330", "CommentCount": "6", "CreationDate": "2010-11-15T06:46:23.330", "ParentId": "4182013", "Score": "2", "OwnerUserId": "469935"}, "bq_ids": {"n4140": {"so_4182013_4182095_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5413}}, "n3337": {"so_4182013_4182095_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5208}}, "n4659": {"so_4182013_4182095_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6835}}}});