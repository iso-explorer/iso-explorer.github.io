post_cb({"bq_ids": {"n4140": {"so_35575276_35575276_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 6718}, "so_35575276_35575276_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6716}, "so_35575276_35575276_2": {"length": 9, "quality": 0.9, "section_id": 6717}}, "n3337": {"so_35575276_35575276_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 6473}, "so_35575276_35575276_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6471}, "so_35575276_35575276_2": {"length": 9, "quality": 0.9, "section_id": 6472}}, "n4659": {"so_35575276_35575276_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 8210}, "so_35575276_35575276_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 8211}, "so_35575276_35575276_2": {"length": 9, "quality": 0.9, "section_id": 8208}}}, "35575596": {"Id": "35575596", "PostTypeId": "2", "Body": "<p><code>std::chrono::seconds</code> itself is not a standard arithmetic type, thus <code>std::numeric_limits</code> is not specialized for it. So you just see some rather useless defaults.</p>\n<p>To query the range of the underlying type used to count the ticks (which, under gcc, is the 64 bit <code>long int</code>), use</p>\n<pre><code>std::numeric_limits&lt;seconds::rep&gt;::max();\n</code></pre>\n<p>instead.</p>\n", "LastActivityDate": "2016-02-23T10:55:51.863", "CommentCount": "0", "CreationDate": "2016-02-23T10:55:51.863", "ParentId": "35575276", "Score": "7", "OwnerUserId": "3002139"}, "35575526": {"Id": "35575526", "PostTypeId": "2", "Body": "<p><code>std::numeric_limits</code> is not specialized for <code>std::chrono::seconds</code>. Default definitions are given for all data members and functions in <code>std::numeric_limits</code> to avoid compiler errors for unspecialized types. The default version of <code>numeric_limits&lt;T&gt;::max()</code> simply returns <code>T()</code>, which is <code>0</code> in this case.</p>\n<p>You can check if <code>std::numeric_limits</code> is specialized for a given <code>T</code> at compile time by checking <code>std::numeric_limits&lt;T&gt;::is_specialized</code>, which defaults to <code>false</code>.</p>\n", "LastActivityDate": "2016-02-23T10:53:27.050", "CommentCount": "5", "CreationDate": "2016-02-23T10:53:27.050", "ParentId": "35575276", "Score": "9", "OwnerUserId": "496161"}, "35575276": {"ViewCount": "452", "Body": "<p>I found an interesting gotcha with <code>std::numeric_limits&lt;seconds&gt;::max()</code> returning 0. The answer is to use <code>seconds::max()</code> or <code>std::numeric_limits&lt;seconds::rep&gt;::max()</code> instead, but I am interested to know why this happens. I would expect it to either fail at compile time or just work. The following code demonstrates the issue with gcc 4.9.3.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;chrono&gt; \n\nusing namespace std;\nusing namespace std::chrono;\n\nint main(int /*argc*/, const char* /*argv*/[])\n{\n    const auto maxSeconds = std::numeric_limits&lt;seconds&gt;::max();\n    std::cerr &lt;&lt; maxSeconds.count() &lt;&lt; \"\\n\";\n    const auto maxSeconds2 = seconds::max();\n    std::cerr &lt;&lt; maxSeconds2.count() &lt;&lt; \"\\n\";\n   return 0;\n}\n</code></pre>\n<p>I can't see any implicit conversions in the <em>chrono</em> header file. If a <code>duration</code> had implicitly cast to a numeric type and the sign was lost or a <code>bool</code> you could end up with a minimum of zero - but a maximum of zero doesn't make sense.</p>\n<hr>\n<p>As TartanLlama points out the default specialization uses the default constructor and therefore returns 0.</p>\n<p>Delving into an old copy of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\">standard</a> I see the following dictats:</p>\n<blockquote>\n<p id=\"so_35575276_35575276_0\">18.3.2.3 Class template <code>numeric_limits</code> [numeric.limits]</p>\n<p id=\"so_35575276_35575276_1\">Non-arithmetic standard types, such as <code>complex&lt;T&gt;</code> (26.4.2), shall not have specializations.</p>\n</blockquote>\n<p>and a little later:</p>\n<blockquote>\n<p id=\"so_35575276_35575276_2\">The default <code>numeric_limits&lt;T&gt;</code> template shall have all members, but with 0 or false values.</p>\n<p id=\"so_35575276_35575276_3\">The value of each member of a specialization of <code>numeric_limits</code> on a cv-qualified type <code>cv T</code> shall be equal to the value of the\n  corresponding member of the specialization on the unqualified type\n  <code>T</code>.</p>\n</blockquote>\n<p>What is missing is an explanation of why this was considered a better idea by the committee than a compilation failure. Is a library defect report warranted?</p>\n<hr>\n<p>Update: I have raised this as an issue with the ISO committee</p>\n<p><a href=\"https://issues.isocpp.org/show_bug.cgi?id=186\">https://issues.isocpp.org/show_bug.cgi?id=186</a></p>\n</hr></hr>", "Title": "Why does std::numeric_limits<seconds>::max() return 0?", "CreationDate": "2016-02-23T10:42:55.000", "LastActivityDate": "2016-03-15T16:02:19.857", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2016-03-15T16:02:19.857", "LastEditorUserId": "1569204", "Id": "35575276", "Score": "16", "OwnerUserId": "1569204", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});