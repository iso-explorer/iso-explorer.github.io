post_cb({"33597340": {"Id": "33597340", "PostTypeId": "2", "Body": "<p><code>static_cast&lt;&gt;</code> will generate a compiler error if you attempt to cast between incompatible types, but it makes no assurances at compile time or runtime that the cast is valid.</p>\n<p>Since TestDerived inherits from TestBase, it's a <em>legal</em> cast as permitted by the static_cast operator, but not all downcasts are necessarily a <em>safe</em> casts.</p>\n<p>In the above code, it <em>just happens</em> to work safely - most likely because TestMethod only accesses base class members, is single inheritance, no vtables, and not doing anything complex. As such, the compiler is <em>likely</em> treating the cast as a no-op simple example. Others will tell you \"this is undefined behavior\" - and not to assume anything about code written like this. (And they would be correct too.)</p>\n", "LastEditorUserId": "104458", "LastActivityDate": "2015-11-10T22:16:44.547", "Score": "-1", "CreationDate": "2015-11-08T18:17:27.780", "ParentId": "33597281", "CommentCount": "10", "OwnerUserId": "104458", "LastEditDate": "2015-11-10T22:16:44.547"}, "bq_ids": {"n4140": {"so_33597281_33598117_1": {"length": 67, "quality": 0.9710144927536232, "section_id": 6028}}, "n3337": {"so_33597281_33598117_1": {"length": 66, "quality": 0.9565217391304348, "section_id": 5796}}, "n4659": {"so_33597281_33598117_1": {"length": 57, "quality": 0.8260869565217391, "section_id": 7527}}}, "33598117": {"Id": "33598117", "PostTypeId": "2", "Body": "<p>From the standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33597281_33598117_0\">\u00a75.2.9 Static cast [expr.static.cast] ...</p>\n<p id=\"so_33597281_33598117_1\">(2) An lvalue of type \u201ccv1 B,\u201d where B is a class type,\n  <strong>can be cast to type \u201creference to cv2 D,\u201d</strong> where\n  <strong>D is a class derived from B</strong>, if a valid \n  standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists, cv2 is \n  the same cv-qualification as, or greater cv-qualification than, cv1, and B\n  is neither a virtual base class of D nor a base class of a virtual base\n  class of D. The result has type \u201ccv2 D.\u201d An xvalue of type \u201ccv1 B\u201dmay be\n  cast to type \u201crvalue reference to cv2 D\u201d with the same constraints as for \n  an lvalue of type \u201ccv1 B.\u201d\n  <strong>If the object of type \u201ccv1 B\u201d is actually a subobject of an object of \n  type D, the result refers to the enclosing object of type D.</strong>\n<strong><em>Otherwise, the behavior is undefined.</em></strong></p>\n</blockquote>\n<p>My first guess was that the cast should be valid in this case,\nbecause I got confused by the term <em>subobject</em>.</p>\n<p>Now (thanks to @T.C. and @M.M), it is obvious that the <em>behavior is undefined</em> in this case.</p>\n<p>The cast would be valid in the following example:</p>\n<pre><code>int main()\n{\n    TestDerived d;\n    TestBase &amp;br = d; // reference to a subobject of d\n    TestDerived &amp;dr = static_cast&lt;TestDerived&amp;&gt;(br);  // reference to the original d object\n    d.myMethod();\n}\n</code></pre>\n<p>Here, an object of class <code>TestDerived</code> (<code>d</code>) will have a subobject of class <code>TestBase</code> (<code>br</code> is a reference to this object).</p>\n", "LastEditorUserId": "2020827", "LastActivityDate": "2015-11-10T10:54:47.047", "Score": "8", "CreationDate": "2015-11-08T19:34:00.800", "ParentId": "33597281", "CommentCount": "2", "OwnerUserId": "2020827", "LastEditDate": "2015-11-10T10:54:47.047"}, "33597281": {"ViewCount": "256", "Body": "<p>Consider this example, where the base class has some data members, while derived one only provides an additional method:</p>\n<pre><code>struct TestBase\n{\n    int x;\n    TestBase() : x(5) {}\n};\n\nstruct TestDerived : public TestBase\n{\n    void myMethod()\n    {\n        x=8;\n    }\n};\n\nint main()\n{\n    TestBase b;\n    TestDerived&amp; d=static_cast&lt;TestDerived&amp;&gt;(b);\n    d.myMethod();\n}\n</code></pre>\n<p>This is downcasting to wrong type, so AFAIU it has undefined behavior. But are there maybe some exceptions to such cases as this, where the derived class' layout is identical to that of base class?</p>\n", "AcceptedAnswerId": "33598117", "Title": "Is this downcasting undefined?", "CreationDate": "2015-11-08T18:11:51.270", "Id": "33597281", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-11-10T22:16:44.547", "Score": "11", "OwnerUserId": "673852", "Tags": "<c++><undefined-behavior><downcasting>", "AnswerCount": "2"}});