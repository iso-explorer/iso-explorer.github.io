post_cb({"bq_ids": {"n4140": {"so_20275322_20275322_0": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_20275322_20275322_3": {"length": 22, "quality": 1.0, "section_id": 7239}, "so_20275322_20735355_1": {"length": 4, "quality": 0.8, "section_id": 6050}, "so_20275322_20735355_2": {"length": 38, "quality": 0.6551724137931034, "section_id": 6046}}, "n3337": {"so_20275322_20275322_0": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_20275322_20275322_3": {"length": 22, "quality": 1.0, "section_id": 6983}, "so_20275322_20735355_1": {"length": 4, "quality": 0.8, "section_id": 5818}, "so_20275322_20735355_2": {"length": 53, "quality": 0.9137931034482759, "section_id": 5814}, "so_20275322_20735355_0": {"length": 55, "quality": 0.859375, "section_id": 5818}}, "n4659": {"so_20275322_20275322_3": {"length": 22, "quality": 1.0, "section_id": 8748}, "so_20275322_20275322_0": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_20275322_20735355_2": {"length": 37, "quality": 0.6379310344827587, "section_id": 7545}}}, "20275465": {"Id": "20275465", "PostTypeId": "2", "Body": "<p>The item of the clause just refers to the normal access to members of any aggregate (<code>struct</code>, <code>class</code>, or array) or <code>union</code>: You need to be able to access the stored values of objects without causing undefined behavior. The clause only states necessary conditions: at least one of the items has to be true. It doesn't state sufficient conditions, i.e., in addition to these conditions other conditions may need to hold, too.</p>\n", "LastActivityDate": "2013-11-28T22:12:20.590", "CommentCount": "6", "CreationDate": "2013-11-28T22:12:20.590", "ParentId": "20275322", "Score": "2", "OwnerUserId": "1120273"}, "20735355": {"Id": "20735355", "PostTypeId": "2", "Body": "<p>The intent of that list is not to provide you alternate methods to access an object, but rather as the footnote to the list indicates, to list all the ways an object might be aliased.  Consider the following example:</p>\n<pre><code>struct foo\n{\n    char x; \n    float y; \n    int z; \n    bool w;\n};\n\nvoid func( foo &amp;F, int &amp;I, double &amp;D )\n{\n    //...\n}\n</code></pre>\n<p>What that list is saying is that accesses to <code>F</code> may also access the same underlying object as accesses to <code>I</code>.  This could happen if you passed a reference to <code>F.z</code> in for <code>I</code>, like this:</p>\n<pre><code>func(F, F.z, D); \n</code></pre>\n<p>On the other hand, you can safely assume no access to <code>F</code> accesses the same underlying object as <code>D</code>, because <code>struct foo</code> does not contain any members of type <code>double</code>.</p>\n<p>That's true even if some joker does this:</p>\n<pre><code>union onion\n{\n    struct foo F;\n    double D;\n};\n\nonion o; \nint i;\n\nfunc( o.F, i, o.D );  // [class.union] (9.5) wants a word with you.  UB.\n</code></pre>\n<p>I'm not sure that the <code>union</code> was central to your question.  But the part before the <code>union</code> example highlights why the aggregate rule exists.</p>\n<p>Now let's consider your example:  <code>reinterpret_cast&lt;Foo&amp;&gt;(a).y = 0;</code>  [expr.reinterpret.cast] (5.2.10), paragraph 11 has this to say:</p>\n<blockquote>\n<p id=\"so_20275322_20735355_0\">An lvalue expression of type <code>T1</code> can be cast to the type \u201creference to\n  <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly\n  converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. That\n  is, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as\n  the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code>\n  operators (and similarly for <code>reinterpret_cast&lt;T&amp;&amp;&gt;(x)</code>). The result\n  refers to the same object as the source lvalue, but with a different\n  type. The result is an lvalue for an lvalue reference type or an\n  rvalue reference to function type and an xvalue for an rvalue\n  reference to object type. No temporary is\n  created, no copy is made, and constructors \n  (12.1) or conversion functions (12.3) are not called.<sup>71</sup></p>\n<hr>\n<p id=\"so_20275322_20735355_1\"><sup><sup>71</sup> This is sometimes referred to as a <em>type pun.</em></sup></p>\n</hr></blockquote>\n<p>In the context of your example, it's saying that if it's legal to convert a pointer-to-<code>int</code> to a pointer-to-<code>Foo</code>, then your <code>reinterpret_cast&lt;Foo&amp;)(a)</code> is legal and produces an lvalue.  (Paragraph 1 tells us it will be an lvalue.)  And, as I read it, that pointer conversion is itself OK, according to paragraph 7:</p>\n<blockquote>\n<p id=\"so_20275322_20735355_2\">A pointer to an object can be explicitly converted to a pointer to a\n  different object type. When a  prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is\n  converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is <code>static_cast&lt;cv\n  T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment\n  requirements of <code>T2</code> are no stricter than those of <code>T1</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the\n  type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no\n  stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any\n  other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>You have standard-layout types with compatible alignment constraints.  So, what you have there is a type pun that yields an lvalue.  The rule you listed does not <em>on its own</em> make it undefined.</p>\n<p>So what might make it undefined?  Well, for one, [class.mem] (9.2) paragraph 21 reminds us that a pointer to a standard layout struct object points to its initial member, and vice versa.  And so, after your type pun, you're left with a reference to <code>Foo</code>, such that <code>Foo</code>'s <code>x</code> is at the same location as <code>a</code>. </p>\n<p>And... this is where my language lawyering peters out.  I know in my gut that accessing <code>Foo</code> through that franken-reference is at <em>best</em> implementation defined or unspecified.  I can't find where it's explicitly banished to the realm of <em>undefined</em> behavior.</p>\n<p>But, I think I answered your original question:  Why is the aggregate rule there?  It gives you a very basic way to rule on potential aliases without further pointer analysis.</p>\n", "LastActivityDate": "2013-12-22T23:51:17.257", "CommentCount": "11", "CreationDate": "2013-12-22T23:51:17.257", "ParentId": "20275322", "Score": "6", "OwnerUserId": "2354107"}, "20275322": {"ViewCount": "241", "Body": "<p>In \"Lvalues and rvalues\", [basic.lval] (3.10), the C++ standard contains a list of types such that it is valid to \"access the stored value of an object\" through a glvalue of such a type (paragraph 10). Specifically, it says:</p>\n<blockquote>\n<p id=\"so_20275322_20275322_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li><p id=\"so_20275322_20275322_1\">the dynamic type of the object,</p></li>\n<li><p id=\"so_20275322_20275322_2\">[some unimportant details about CV and signed/unsigned]</p></li>\n<li><p id=\"so_20275322_20275322_3\"><strong>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</strong></p></li>\n<li><p id=\"so_20275322_20275322_4\">[some more stuff]</p></li>\n</ul>\n</blockquote>\n<p>What exactly does the \"aggregate\" rule mean? How do I access an object's stored value through a glvalue of some general aggregate type?!</p>\n<p>I'm picturing something like this:</p>\n<pre><code>int a = 10;                                      // my \"stored value\"\n\nstruct Foo { char x; float y; int z; bool w; };  // an aggregate\n\nreinterpret_cast&lt;Foo&amp;&gt;(a).y = 0;                 // ???\n</code></pre>\n<p>Doesn't the final cast produce a glvalue of \"an aggregate type that includes the dynamic type of <code>a</code>\", and thus make this valid?</p>\n", "Title": "How to access an object's storage through an aggregate", "CreationDate": "2013-11-28T21:58:03.540", "LastActivityDate": "2013-12-22T23:51:17.257", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "Id": "20275322", "Score": "13", "OwnerUserId": "596781", "Tags": "<c++><language-lawyer><lvalue>", "AnswerCount": "2"}});