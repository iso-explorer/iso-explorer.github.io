post_cb({"21720579": {"CommentCount": "0", "AcceptedAnswerId": "21722226", "CreationDate": "2014-02-12T06:44:27.913", "LastActivityDate": "2014-02-12T13:51:09.780", "PostTypeId": "1", "ViewCount": "464", "FavoriteCount": "1", "Title": "Lifetime of data associated with std::current_exception", "Id": "21720579", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>std::exception_ptr eptr{ std::current_exception() };\nconst char* msg = 0;\ntry {\n    if (eptr != std::exception_ptr{}) {\n        std::rethrow_exception(eptr);\n    }\n} catch(const std::exception&amp; ex) {\n    msg = ex.what();\n}\n</code></pre>\n<p>Can I use <code>msg</code> outside of <code>catch</code>? In other words does <code>ex</code> references to the same exception instance as <code>eptr</code>? Thanks!</p>\n", "Tags": "<c++><exception><c++11>", "OwnerUserId": "834552", "AnswerCount": "2"}, "21720692": {"ParentId": "21720579", "CommentCount": "5", "CreationDate": "2014-02-12T06:50:57.937", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "21720692", "Score": "6", "Body": "<p>The description of <code>rethrow_exception</code> says:</p>\n<blockquote>\n<p id=\"so_21720579_21720692_0\"><em>Throws:</em> the exception object to which <code>p</code> refers.</p>\n</blockquote>\n<p>So the thrown object is the same one to which the pointer refers. The pointer may or may not refer to the original \"current exception\", because <code>current_exception</code> might make a copy of the exception object, but that's irrelevant to your question.</p>\n<p>So yes, the exception object that you rethrow is the same one that's owned by <code>eptr</code> and thus remains alive as long at least as long as that pointer owns it.</p>\n", "LastActivityDate": "2014-02-12T06:50:57.937"}, "21722226": {"ParentId": "21720579", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-02-12T08:17:27.800", "Score": "3", "LastEditorUserId": "147192", "LastEditDate": "2014-02-12T13:51:09.780", "Id": "21722226", "OwnerUserId": "147192", "Body": "<p><strong>TL;DR</strong>: I would not, because <code>ex</code> and <code>eptr</code> (might ?) reference different exceptions. (see edit: it might be guaranteed, but the standard is unclear enough that I would avoid relying on it)</p>\n<p>The lifetime of exceptions is ruled by <strong>\u00a715.1 [except.throw]</strong>, and specifically:</p>\n<blockquote>\n<p id=\"so_21720579_21722226_0\">4/ The memory for the exception object is allocated in an unspecified way, except as noted in \u00a73.7.4.1. If a handler exits by rethrowing, control is passed to another handler for the same exception. <strong>The exception object is destroyed after either the last remaining active handler for the exception exits by any means other than rethrowing, or the last object of type <code>std::exception_ptr</code> (\u00a718.8.5) that refers to the exception object is destroyed, whichever is later.</strong> In the former case, the destruction occurs when the handler exits, immediately after the destruction of the object declared in the <em>exception-declaration</em> in the handler, if any. In the latter case, the destruction occurs before the destructor of <code>std::exception_ptr</code> returns. The implementation may then deallocate the memory for the exception object; any such deallocation is done in an unspecified way. [ <em>Note:</em> a thrown exception does not propagate to other threads unless caught, stored, and rethrown using appropriate library functions; see \u00a718.8.5 and \u00a730.6. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>However, you also need to take into account the previous paragraph:</p>\n<blockquote>\n<p id=\"so_21720579_21722226_1\">3/ Throwing an exception copy-initializes (\u00a78.5, \u00a712.8) a temporary object, called the exception object. The temporary is an lvalue and is used to initialize the variable named in the matching handler (\u00a715.3). [...]</p>\n</blockquote>\n<p>Thus, what happens in your case:</p>\n<ul>\n<li><code>eptr</code> is initialized to point to the current exception in flight, guaranteeing this exception lives at least as long as it does</li>\n<li><code>ex</code> is initialized to reference <strong>a copy</strong> of the exception pointed to by <code>eptr</code></li>\n<li>when the catch clause ends, <strong>the copy</strong> dies</li>\n<li><code>msg</code> was pointing into the copy, and thus is left dangling... unless both copy and original shared the same message under the covers.</li>\n</ul>\n<p>The only way to guarantee that an exception lives long enough for your purpose is to create a <code>std::exception_ptr</code>, directly.</p>\n<p><strong>EDIT</strong> Ralph Tandetzky brough to my attention that <strong>\u00a718.8.5 [propagation]</strong> says:</p>\n<blockquote>\n<p id=\"so_21720579_21722226_2\">7/ [...] [ <em>Note:</em> if <code>rethrow_exception</code> rethrows the same exception object (rather than a copy), concurrent access to that rethrown exception object may introduce a data race. Changes in the number of <code>exception_ptr</code> objects that refer to a particular exception do not introduce a data\n  race. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Which suggests that in the following paragraph:</p>\n<blockquote>\n<pre><code>[[noreturn]] void rethrow_exception(exception_ptr p);\n</code></pre>\n<p id=\"so_21720579_21722226_3\">9/ <em>Requires:</em> <code>p</code> shall not be a null pointer.</p>\n<p id=\"so_21720579_21722226_4\">10/ <em>Throws:</em> the exception object to which <code>p</code> refers.</p>\n</blockquote>\n<p>the <em>Throws</em> clause should not be interpreted as some kind of <code>throw *p;</code>, but instead <em>could</em> have the same behavior as <code>throw;</code> (re-throwing the very same instance, not a copy). However, since there is a <em>if</em> in paragraph 7, it seems it might be a copy too...</p>\n<hr>\n<p>Note: interestingly experiments suggests that <a href=\"http://coliru.stacked-crooked.com/a/889051aace1885ff\" rel=\"nofollow\">the underlying object may be shared</a>... which contradicts my reading of the standard; I don't quite understand how <em>copy-initializes</em> could be interpreted differently though.</p>\n</hr>", "LastActivityDate": "2014-02-12T13:51:09.780"}, "bq_ids": {"n4140": {"so_21720579_21722226_1": {"section_id": 3336, "quality": 0.6666666666666666, "length": 12}, "so_21720579_21722226_2": {"section_id": 6939, "quality": 0.9, "length": 27}, "so_21720579_21722226_0": {"section_id": 3337, "quality": 0.9, "length": 90}}, "n3337": {"so_21720579_21722226_1": {"section_id": 3206, "quality": 0.5555555555555556, "length": 10}, "so_21720579_21722226_2": {"section_id": 6687, "quality": 0.9, "length": 27}, "so_21720579_21722226_0": {"section_id": 3207, "quality": 0.89, "length": 89}}, "n4659": {"so_21720579_21722226_1": {"section_id": 4103, "quality": 0.6666666666666666, "length": 12}, "so_21720579_21722226_2": {"section_id": 8436, "quality": 0.9, "length": 27}, "so_21720579_21722226_0": {"section_id": 4104, "quality": 0.64, "length": 64}}}});