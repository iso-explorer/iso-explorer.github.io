post_cb({"bq_ids": {"n4140": {"so_11645751_11645914_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 558}, "so_11645751_11645914_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 558}, "so_11645751_11645914_2": {"length": 37, "quality": 0.8604651162790697, "section_id": 558}}, "n3337": {"so_11645751_11645914_2": {"length": 37, "quality": 0.8604651162790697, "section_id": 549}, "so_11645751_11645914_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 549}, "so_11645751_11645914_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 549}}, "n4659": {"so_11645751_11645914_2": {"length": 37, "quality": 0.8604651162790697, "section_id": 581}, "so_11645751_11645914_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 581}, "so_11645751_11645914_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 581}}}, "11645751": {"ViewCount": "1728", "Body": "<blockquote>\n<p id=\"so_11645751_11645751_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/3682049/functions-with-const-arguments-and-overloading\">Functions with const arguments and Overloading</a> </br></p>\n</blockquote>\n<p>I am pretty confused by the overloading and const declaration rules.\nHere are two things that puzzle me maybe you can help me find the deeper misunderstanding in my head that result in them being puzzling to me. ;)</p>\n<p>First issue:</p>\n<p>My compiler allows this:</p>\n<pre><code>void f(int &amp; x) {\n  std::cout &lt;&lt; \"plain f\" &lt;&lt; std::endl;\n}\nvoid f(const int &amp; x) {\n  std::cout &lt;&lt; \"const f\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>But the following causes a compile error (function already has a body):</p>\n<pre><code>void f(int x) {\n  std::cout &lt;&lt; \"plain f\" &lt;&lt; std::endl;\n}\nvoid f(const int x) {\n  std::cout &lt;&lt; \"const f\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Which I suppose makes sense because I thought the const was only there to tell the compiler that the object being passed is not changed and in the second case it is copied anyway. But if that is correct then why can I overload functions using const?</p>\n<p>In other words, why if I use the compiling version and call the functions like this:</p>\n<pre><code>  int x1 = 5;\n  const int x2 = 5;\n  f(x1);\n  f(x2);\n</code></pre>\n<p>do I get \"plain f\" and \"const f\" instead of \"const f\" twice? Apparently now I am also using the const to tell the compiler which function to call not only that the reference doesn't change. This gets more confusing because if I remove the \"plain\" version it works just fine and calls the \"const\" version twice.</p>\n<p>Now what is my actual question? I would like to know what the ideas behind this behavior are because otherwise memorizing it is very hard.</p>\n", "AcceptedAnswerId": "11646899", "Title": "Why are const qualifiers in function arguments used for overloading resolution?", "CreationDate": "2012-07-25T08:36:30.877", "Id": "11645751", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:13:50.553", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-25T09:44:51.273", "ClosedDate": "2012-07-25T13:54:02.843", "Score": "10", "OwnerUserId": "1994377", "Tags": "<c++><overloading><function-overloading><overload-resolution>", "AnswerCount": "2"}, "11645914": {"Id": "11645914", "PostTypeId": "2", "Body": "<p>n3337 13.1</p>\n<blockquote>\n<p id=\"so_11645751_11645914_0\">[ Note: As specified in 8.3.5, function declarations that have\n  equivalent parameter declarations declare the same function and\n  therefore cannot be overloaded: ffer only in the presence or absence</p>\n<p id=\"so_11645751_11645914_1\">\u2014 Parameter declarations that di3\n  of const and/or volatile are equivalent. That is, the const and\n  volatile type-specifiers for each parameter type are ignored when\n  determining which function is being declared, defined, or called. [\n  Example: </p>\n<pre><code>typedef const int cInt;\nint f(int);\nint f(const int); // redeclaration of f(int)\nint f(int) { /* ... */ } // definition of f(int)\nint f(cInt) { /* ... */ } // error: redefinition of f(int)\n</code></pre>\n<p id=\"so_11645751_11645914_2\">\u2014 end\n  example ] Only the const and volatile type-specifiers at the outermost\n  level of the parameter type specifica- tion are ignored in this\n  fashion; const and volatile type-specifiers buried within a parameter\n  type specification are significant and can be used to distinguish\n  overloaded function declarations.124 In particular, for any type T,\n  \u201cpointer to T,\u201d \u201cpointer to const T,\u201d and \u201cpointer to volatile T\u201d are\n  considered distinct parameter types, as are \u201creference to T,\u201d\n  \u201creference to const T,\u201d and \u201creference to volatile T.\u201d</p>\n</blockquote>\n", "LastEditorUserId": "1968", "LastActivityDate": "2012-07-25T08:51:00.680", "Score": "4", "CreationDate": "2012-07-25T08:46:16.070", "ParentId": "11645751", "CommentCount": "2", "OwnerUserId": "1498580", "LastEditDate": "2012-07-25T08:51:00.680"}, "11646899": {"Id": "11646899", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11645751_11646899_0\">I thought the const was only there to tell the compiler that the object being\n  passed is not changed and in the second case it is copied anyway</p>\n</blockquote>\n<p>You are correct. Because in the second case it's copied anyway, and so the <code>const</code> makes no difference to the caller, the standard defines that <code>void f(const int x)</code> and <code>void f(int x)</code> have the same signature. Hence they collide, you're trying to define the same function twice.</p>\n<p>Because in the first case it <em>isn't</em> copied anyway, <code>void f(const int &amp;x)</code> and <code>void f(int &amp;x)</code> have <em>different</em> signatures. Hence they overload.</p>\n<p>In your first case, it's forbidden to call the <code>int&amp;</code> version of <code>f</code> with <code>x2</code> as argument, because that would create a non-const reference to a const object without any explicit cast in sight. Doing that defeats the purpose of the const system (which is that if you want to break const-safety, you have to do so explicitly with a cast). So it makes sense to have const- and non-const overloads of functions with reference parameters.</p>\n<p>In your second case, there's no relation between the const-ness of the source of a copy, and the const-ness of the destination. You can initialize a const variable from a non-const one, or a non-const one from a const one. This causes no problems and doesn't break const-safety. That's why the standard helpfully makes this clear by defining that your two \"different\" versions of <code>f</code> are actually the same function.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-07-25T09:44:51.273", "Score": "1", "CreationDate": "2012-07-25T09:39:29.793", "ParentId": "11645751", "CommentCount": "5", "OwnerUserId": "13005", "LastEditDate": "2012-07-25T09:44:51.273"}});