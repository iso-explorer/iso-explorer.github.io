post_cb({"21082847": {"ParentId": "21082581", "CommentCount": "2", "CreationDate": "2014-01-13T02:05:47.937", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "21082847", "Score": "1", "Body": "<p>Steve Jessop answered it, but for what it's worth, here is the quote from the Standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_21082581_21082847_0\">12.1/4 A constructor shall not be virtual (10.3) or static (9.4). A constructor can be invoked for a const, volatile or const volatile object. A constructor shall not be declared const, volatile, or const volatile (9.3.2). <strong>const and volatile semantics (7.1.6.1) are not applied on an object under construction. They come into effect when the constructor for the most derived object (1.8) ends.</strong> A constructor shall not be declared with a ref-qualifier.</p>\n</blockquote>\n<p>So <code>*this</code> is not a constant object from the point of view of the constructor, even when a constant object is created. This could have been designed differently, but then constructors of constant objects would be much less flexible than constructors of non-constant objects; for example, they would always have to initialize all members in the initializer list; they could not use loops etc. in the body of the constructor to set values for complex members.</p>\n", "LastActivityDate": "2014-01-13T02:05:47.937"}, "21082637": {"ParentId": "21082581", "CommentCount": "2", "CreationDate": "2014-01-13T01:35:20.530", "OwnerUserId": "388182", "PostTypeId": "2", "Id": "21082637", "Score": "4", "Body": "<p><code>const</code> is a language-level concept. That is, when you compile your code and execute it as machine code, all data is seen as data more or less. Note that I say \"more or less\" because we are ignoring the fact that, in theory, <code>const</code> data could be stored in read-only pages and trigger page faults when written to; but this is not common due to the granularity of page sizes. So what is happening is the following:</p>\n<p>Your constructor initializes that value of <code>ptr</code> to point to the address of <code>i</code>. Since your <code>obj</code> object is <code>const</code>, you could not directly modify the value of <code>i</code> and, further, you could not change where <code>ptr</code> points to. However, you can access and manipulate the memory that <code>ptr</code> points to (in this case, the value of <code>i</code>).</p>\n<p>Therefore, since the compiler doesn't check/know/care that <code>ptr</code> is pointing to <code>i</code>, it does not catch the violation of <code>const</code>. Instead, it just sees you modifying the data pointed to by <code>ptr</code>.</p>\n", "LastActivityDate": "2014-01-13T01:35:20.530"}, "21082803": {"ParentId": "21082581", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-01-13T01:59:37.263", "Score": "2", "LastEditorUserId": "13005", "LastEditDate": "2014-01-13T02:25:50.777", "Id": "21082803", "OwnerUserId": "13005", "Body": "<p>Clearly the constructor (or at least the initializer list if not the body of the ctor) needs to be able to write a value to <code>i</code>.</p>\n<p>As it happens, the way C++ achieves this is to make <code>this</code> a pointer-to-non-const in the constructor (and destructor). Basically, the <code>const</code>-ness of <code>obj</code> doesn't commence until the constructor has finished executing. That's why the vulnerability exists, because of a straightforward but imperfect solution to the technical problem of how to construct <code>const</code>-qualified objects.</p>\n<p>Perhaps it could in principle be done differently. I suppose you'd need a separate <code>const</code> version of the constructor in which the compiler applies different rules (just as normal member functions can be <code>const</code>), treating data members as <code>const</code> and therefore (1) allowing them to be initialized but not assigned, (2) forbidding the initialization of <code>ptr</code> from <code>&amp;i</code> since the latter would have type <code>int const*</code>. C++ doesn't do this, and as a result it has this loophole that you've driven through. If it did do it, people would have more difficulty writing constructors in certain cases, so it's a design trade-off.</p>\n<p>Be aware that similarly a <code>volatile</code>-qualified object is not <code>volatile</code> in its own constructor or destructor.</p>\n", "LastActivityDate": "2014-01-13T02:25:50.777"}, "bq_ids": {"n4140": {"so_21082581_21082847_0": {"section_id": 368, "quality": 0.6097560975609756, "length": 25}}, "n3337": {"so_21082581_21082847_0": {"section_id": 358, "quality": 0.9024390243902439, "length": 37}}, "n4659": {"so_21082581_21082847_0": {"section_id": 380, "quality": 0.6097560975609756, "length": 25}}}, "21082581": {"CommentCount": "1", "ViewCount": "115", "CreationDate": "2014-01-13T01:25:49.510", "LastActivityDate": "2014-01-13T02:25:50.777", "Title": "const correctness with const objects and member pointers, constructor vulnerability", "AcceptedAnswerId": "21082803", "PostTypeId": "1", "Id": "21082581", "Score": "1", "Body": "<pre><code>class Test\n{\npublic:\n    Test() : i(0), ptr(&amp;i) {}\n    int i;\n    int *ptr;\n    void change_const (int x) const { *ptr=x; }\n};\n\nint main()\n{\n    const Test obj;\n    obj.ptr = &amp;obj.i; // error\n    obj.change_const(99);\n    return 0;\n}\n</code></pre>\n<p>Although in <code>obj</code> <code>ptr</code> is of type <code>int *const</code>, the constructor can make him point to <code>i</code> of type <code>const int</code>. An explicit try to do this of course fails. Why does a constructor offer this vulnerability regarding const correctness? Other non directly obvious vulnerabilities like</p>\n<pre><code>int *ptr;\nconst int **c_ptr = &amp;ptr; // error\nconst int c = 10;\n*c_ptr = &amp;c;\n*ptr = 20; // because here change of c possible\n</code></pre>\n<p>are also well thought prevented.</p>\n", "Tags": "<c++><class><pointers><const-correctness>", "OwnerUserId": "2947694", "AnswerCount": "3"}});