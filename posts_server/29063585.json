post_cb({"bq_ids": {"n4140": {"so_29063585_29065296_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 2661}, "so_29063585_29065296_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 2661}}, "n3337": {"so_29063585_29065296_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 2625}, "so_29063585_29065296_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 2625}}, "n4659": {"so_29063585_29065296_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 3401}, "so_29063585_29065296_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3401}}}, "29065296": {"Id": "29065296", "PostTypeId": "2", "Body": "<h3>Introduction</h3>\n<p>There's nothing saying that a certain <em>MACRO</em>, or equivalent, will be available for the preprocessor (that would yield what thread-implementation a certain implementation is using). </p>\n<hr>\n<p>If we instead were to inspect the returned value (more specifically the returned type) of <a href=\"http://en.cppreference.com/w/cpp/thread/thread/native_handle\" rel=\"nofollow\"><code>std::thread::native_handler</code></a> (<code>std::thread::native_handle_type</code>) one might think that it would yield a better result.</p>\n<p>The problem, beyond the fact that it won't help us, is that the return-type of said function is <em>implementation-defined</em>; meaning that it could return anything, as long as that happens to be something that can be used as a handle for the underlying thread implementation.</p>\n<p>And even worse; the function might not be present at all, as described in <em>[thread.req.native]</em>:</p>\n<blockquote>\n<p id=\"so_29063585_29065296_0\"><em>30.2.3/1</em> <strong>Native handles</strong> <code>[thread.req.native]p1</code></p>\n<blockquote>\n<p id=\"so_29063585_29065296_2\">Several classes described in this Clause have members <code>native_handle_type</code> and <code>native_handle</code>. The presence of these members and their semantics is implementation-defined.</p>\n</blockquote>\n</blockquote>\n<hr>\n<hr>\n<h3>Elaboration</h3>\n<p>Looking at the handle associated with <em>pthreads</em>, we find that it is <code>pthread_t</code> - this <em>type-id</em> is most often a <em>typedef</em> for the intrinsic type <code>unsigned long int</code>.</p>\n<p>If we dive into the win32 threading library we see that the handle used is of type <code>HANDLE</code>, which (after some more digging) ends up being <code>void *</code>.</p>\n<hr>\n<p>Even if we could, realizably, assume that <em>pthread_t</em> <em>\"always\"</em> is an integral type, and that <code>HANDLE</code> <em>\"always\"</em> boils down to being a <em>pointer-to-void</em>; there's no such guarantee.</p>\n<p>What if another threading implementation also has <code>unsigned long</code> or <code>void*</code> as its thread handle; how would we distinguish that from the previous two?</p>\n<p>To sum it up; one should not rely on the returned type from <code>std::thread::native_handler</code> to query the underlying thread implementation simply because there's nothing saying that it will be a unique type (across different threading implementations).</p>\n<hr>\n<hr>\n<h3>Advice</h3>\n<p>Don't rely on the underlying thread implementation when writing your software, simply use <code>std::thread</code> and work through that.</p>\n<p>If there is some functionality that isn't present in <code>&lt;thread&gt;</code> that you \"must\" have, you will have to rely on some external magic (such as <em>autoconf</em>).</p>\n</hr></hr></hr></hr></hr></hr>", "LastActivityDate": "2015-03-15T19:38:45.117", "CommentCount": "1", "CreationDate": "2015-03-15T19:38:45.117", "ParentId": "29063585", "Score": "1", "OwnerUserId": "1090079"}, "29063585": {"ViewCount": "349", "Body": "<p>With <code>std::thread::native_handle()</code>, I can get the underlying pthreads handle in my implementation (mingw-w64 with pthreads)</p>\n<p>But is there a way to check during preprocessing if the implementation is actually using native pthreads or something else (win32 threads, etc...) ?\nI would like to make a code as portable as possible, which would use the native handle for setting the thread priority. This would be disabled at compile time if the implementation is not supported during compilation.</p>\n<p>But most importantly, I would like to prevent the following case during build configuration or compilation : pthreads is detected by autoconf, but the implementation does not use pthreads but something else, and I pass a wrong handle to pthreads.</p>\n", "AcceptedAnswerId": "29065296", "Title": "Test for std::thread native handle implementation", "CreationDate": "2015-03-15T17:07:38.673", "Id": "29063585", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-03-15T19:38:45.117", "Score": "0", "OwnerUserId": "2042388", "Tags": "<multithreading><c++11><pthreads><native><handle>", "AnswerCount": "1"}});