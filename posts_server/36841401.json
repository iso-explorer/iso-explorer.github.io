post_cb({"bq_ids": {"n4140": {"so_36841401_36841449_6": {"length": 41, "quality": 0.8541666666666666, "section_id": 5882}, "so_36841401_36841449_7": {"length": 19, "quality": 0.8636363636363636, "section_id": 51}, "so_36841401_36841449_2": {"length": 10, "quality": 1.0, "section_id": 7041}, "so_36841401_36841449_5": {"length": 38, "quality": 0.95, "section_id": 5881}, "so_36841401_36841449_3": {"length": 48, "quality": 0.8421052631578947, "section_id": 7043}, "so_36841401_36841449_4": {"length": 39, "quality": 0.9512195121951219, "section_id": 7043}, "so_36841401_36841449_1": {"length": 14, "quality": 1.0, "section_id": 7038}, "so_36841401_36841449_0": {"length": 19, "quality": 0.95, "section_id": 7135}}, "n3337": {"so_36841401_36841449_6": {"length": 41, "quality": 0.8541666666666666, "section_id": 5653}, "so_36841401_36841449_7": {"length": 19, "quality": 0.8636363636363636, "section_id": 46}, "so_36841401_36841449_2": {"length": 10, "quality": 1.0, "section_id": 6786}, "so_36841401_36841449_5": {"length": 38, "quality": 0.95, "section_id": 5652}, "so_36841401_36841449_0": {"length": 19, "quality": 0.95, "section_id": 6879}, "so_36841401_36841449_4": {"length": 38, "quality": 0.926829268292683, "section_id": 6788}, "so_36841401_36841449_1": {"length": 14, "quality": 1.0, "section_id": 6784}, "so_36841401_36841449_3": {"length": 48, "quality": 0.8421052631578947, "section_id": 6788}}, "n4659": {"so_36841401_36841449_6": {"length": 43, "quality": 0.8958333333333334, "section_id": 7365}, "so_36841401_36841449_7": {"length": 20, "quality": 0.9090909090909091, "section_id": 52}, "so_36841401_36841449_2": {"length": 10, "quality": 1.0, "section_id": 8538}, "so_36841401_36841449_5": {"length": 38, "quality": 0.95, "section_id": 7364}, "so_36841401_36841449_0": {"length": 19, "quality": 0.95, "section_id": 8636}, "so_36841401_36841449_4": {"length": 39, "quality": 0.9512195121951219, "section_id": 8540}, "so_36841401_36841449_1": {"length": 14, "quality": 1.0, "section_id": 8535}, "so_36841401_36841449_3": {"length": 48, "quality": 0.8421052631578947, "section_id": 8540}}}, "36841401": {"ViewCount": "173", "Body": "<p>If I will write something like this:</p>\n<pre><code>// A.h\n#ifndef A_h\n#define A_h\nclass A\n{\npublic:\n    void f();\n};\n\nvoid A::f()\n{\n}\n#endif //A_h\n\n\n// B.cpp\n#include \"A.h\"\n\nvoid foo()\n{\n    A a;\n    a.f();\n}\n\n\n// C.cpp\n#include \"A.h\"\n\nvoid bar()\n{\n    A b;\n    b.f();\n}\n\n// main.cpp\n#include \"B.cpp\"\n#include \"C.cpp\"\nusing namespace std;\n\nint main()\n{\n    foo();\n    bar();\n    return 0;\n}\n</code></pre>\n<p>I get a linker error as such:</p>\n<blockquote>\n<p id=\"so_36841401_36841401_0\">error LNK2005: \"public: void __thiscall A::f(void)\" (?f@A@@QAEXXZ)\n  already defined in B.obj</p>\n</blockquote>\n<p>Why does the same problem not happen when the <code>A</code> class is a class template? Eventually it becomes a plain class (a non-template one) during compilation, right? For this reason, I expect the same behavior as a non-template class, i.e. a linker error.</p>\n", "Title": "Why are templates not redefined, why is it all written in the header file?", "CreationDate": "2016-04-25T13:02:04.007", "LastActivityDate": "2016-04-27T17:48:44.497", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-04-26T07:25:28.857", "LastEditorUserId": "3747990", "Id": "36841401", "Score": "1", "OwnerUserId": "163394", "Tags": "<c++><templates><c++11><linker>", "AnswerCount": "3"}, "36841449": {"Id": "36841449", "PostTypeId": "2", "Body": "<p><em>Why is it that the non template functions are treated differently to templates when it comes to multiple definitions?</em></p>\n<p>There are historical and compatibility issues involved here. Some of the requirements come from C, that is the way it worked. There are also reasons related to what templates are, they are code generators; when required, the compiler needs to generate the code, consequently it needs to see the code when it generates it. This has a knock on effect that there will be multiple definitions, so rules are required to resolve those issues.</p>\n<p>Simply put; templates behave (w.r.t. linking) as if they had a single definition in the program, hence they do not behave the same during compilation and linking as non-templates (that are not declared with <code>inline</code>) - in particular w.r.t. functions. If the non-templates are declared <code>inline</code>, similar behaviour is seen.</p>\n<hr>\n<p>Standard references here include;</p>\n<p>Some background, most of the issues here relate to <em>linkage</em>, what is <em>linkage</em>? <a href=\"http://eel.is/c++draft/basic.link#2\" rel=\"nofollow\">\u00a73.5/2 [basic.link]</a></p>\n<blockquote>\n<p id=\"so_36841401_36841449_0\">A name is said to have <em>linkage</em> when it might denote the same object, reference, function, type, template, namespace or value as a name introduced by a declaration in another scope:</p>\n<ul>\n<li>When a name has <em>external linkage</em>, the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit.</li>\n<li>When a name has <em>internal linkage</em>, the entity it denotes can be referred to by names from other scopes in the same translation unit.</li>\n<li>When a name has <em>no linkage</em>, the entity it denotes cannot be referred to by names from other scopes.</li>\n</ul>\n</blockquote>\n<p>Some general rules relating to functions and variable, for the program as a whole and each of the translation units.</p>\n<p><a href=\"http://eel.is/c++draft/basic.def.odr#1\" rel=\"nofollow\">\u00a73.2/1 [basic.def.odr]</a></p>\n<blockquote>\n<p id=\"so_36841401_36841449_1\">No translation unit shall contain more than one definition of any \n  variable, function, class type, enumeration type, or template.</p>\n</blockquote>\n<p>And</p>\n<p><a href=\"http://eel.is/c++draft/basic.def.odr#4\" rel=\"nofollow\">\u00a73.2/4 [basic.def.odr]</a></p>\n<blockquote>\n<p id=\"so_36841401_36841449_2\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program...</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/basic.def.odr#6\" rel=\"nofollow\">\u00a73.2/6 [basic.def.odr]</a> </p>\n<blockquote>\n<p id=\"so_36841401_36841449_3\">There can be more than one definition of a class type (Clause [class]), enumeration type ([dcl.enum]), inline function with external linkage ([dcl.fct.spec]), class template (Clause [temp]), non-static function template ([temp.fct]), static data member of a class template ([temp.static]), member function of a class template ([temp.mem.func]), or template specialization for which some template parameters are not specified ([temp.spec], [temp.class.spec]) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements.... </p>\n<p id=\"so_36841401_36841449_4\">If <code>D</code> is a template and is defined in more than one translation unit, then the preceding requirements shall apply both to names from the template's enclosing scope used in the template definition ([temp.nondep]), and also to dependent names at the point of instantiation ([temp.dep]). If the definitions of <code>D</code> satisfy all these requirements, then the behavior is as if there were a single definition of <code>D</code>. If the definitions of <code>D</code> do not satisfy these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p><em>Some informal observations on the above list including the classes, templates etc. These are typical elements often found in header files (of course not exclusively or limited to headers). They are given these special rules to make everything work as expected.</em></p>\n<p>What about class member functions? <a href=\"http://eel.is/c++draft/class.mfct\" rel=\"nofollow\">\u00a79.3 [class.mfct]</a></p>\n<blockquote>\n<p id=\"so_36841401_36841449_5\">1/ A member function may be defined ([dcl.fct.def]) in its class definition, in which case it is an <em>inline</em> member function ([dcl.fct.spec]), or it may be defined outside of its class definition if it has already been declared but not defined in its class definition. A member function definition that appears outside of the class definition shall appear in a namespace scope enclosing the class definition...</p>\n<p id=\"so_36841401_36841449_6\">2/ An inline member function (whether static or non-static) may also be defined outside of its class definition provided either its declaration in the class definition or its definition outside of the class definition declares the function as <code>inline</code> or <code>constexpr</code>. [ <em>Note:</em> Member functions of a class in namespace scope have the linkage of that class. Member functions of a local class ([class.local]) have no linkage. See [basic.link].  \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>So basically, member functions not defined in the class definition and not implicitly <code>inline</code>, hence the \"normal\" rules apply and hence can only appear once in the program. </p>\n<p>And template, what does it say about <em>linkage</em> ? <a href=\"http://eel.is/c++draft/temp#4\" rel=\"nofollow\">\u00a714/4 [temp]</a></p>\n<blockquote>\n<p id=\"so_36841401_36841449_7\">A template name has linkage ([basic.link]). Specializations (explicit or implicit) of a template that has internal linkage are distinct from all specializations in other translation units... Template definitions shall obey the one-definition rule ([basic.def.odr]).</p>\n</blockquote>\n</hr>", "LastEditorUserId": "3747990", "LastActivityDate": "2016-04-27T17:44:40.073", "Score": "1", "CreationDate": "2016-04-25T13:04:06.843", "ParentId": "36841401", "CommentCount": "4", "OwnerUserId": "3747990", "LastEditDate": "2016-04-27T17:44:40.073"}, "36841645": {"Id": "36841645", "PostTypeId": "2", "Body": "<p>Templates are not code; they are patterns for creating code. They must be visible wherever they are used, so the compiler has to have special rules for using them. The key special rules here are that the compiler generates code wherever a template is used and that the linker ignores duplicates.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2016-04-26T11:42:25.840", "Score": "1", "CreationDate": "2016-04-25T13:13:36.413", "ParentId": "36841401", "CommentCount": "0", "OwnerUserId": "1593860", "LastEditDate": "2016-04-26T11:42:25.840"}, "36841663": {"Id": "36841663", "PostTypeId": "2", "Body": "<p>There are two separate effects at work here:</p>\n<ol>\n<li><p>A member function definition that's out of line is a normal function definition, and by one definition rule (ODR) it must occur precisely once in the link. A member function defined inline is implicitly <code>inline</code>, and the ODR allows inline function definitions to be repeated:</p>\n<p>That is, it's OK to put the following code in a header and include it repeatedly:</p>\n<p></p>\n<pre><code>struct Foo {\n   void bar() {}   // \"inline\" implied\n};\n</code></pre>\n<p>But if you have the definition out of line, it must be in a single translation unit.</p></li>\n<li><p>Function templates can be defined repeatedly, even when they are not inline. The templating mechanism in general already needs to deal with repeated instantiations of templates, and with their deduplication at link time.</p>\n<p>Member functions of class templates are themselves function templates, and therefore it doesn't matter whether you declare them <code>inline</code>.</p></li>\n</ol>\n", "LastActivityDate": "2016-04-25T13:14:14.777", "CommentCount": "4", "CreationDate": "2016-04-25T13:14:14.777", "ParentId": "36841401", "Score": "4", "OwnerUserId": "596781"}});