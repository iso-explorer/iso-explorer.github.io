post_cb({"bq_ids": {"n4140": {"so_39449946_39451728_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 382}}, "n3337": {"so_39449946_39451728_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 373}}, "n4659": {"so_39449946_39451912_0": {"length": 9, "quality": 0.9, "section_id": 456}}}, "39451728": {"Id": "39451728", "PostTypeId": "2", "Body": "<p>The reason for this warning is IMO this excerpt from standard (12.2.5):</p>\n<blockquote>\n<p id=\"so_39449946_39451728_0\">A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the\n  constructor exits.</p>\n</blockquote>\n<p>and since the <a href=\"http://en.cppreference.com/w/cpp/language/this\" rel=\"nofollow\">keyword this is a prvalue expression</a>, during <code>this_ref</code> initialization a temporary will be created and <code>this_ref</code> is bound to that temporary.</p>\n<p>But I have doubt whether your reference is actually initialized in <code>ctor-initializer</code>.</p>\n<p>If you write:</p>\n<pre><code>struct A {\nprivate:\n    const int&amp; rr = 1+1;\n};\n</code></pre>\n<p>then you will reproduce the exact same problem with gcc, removing private will also remove this warning.</p>\n<p>From what I know <code>this pointer</code> might be used in the body of the non-static member function, I have never read that it could be used as argument during default member initialization.</p>\n", "LastActivityDate": "2016-09-12T13:40:43.240", "CommentCount": "0", "CreationDate": "2016-09-12T13:40:43.240", "ParentId": "39449946", "Score": "1", "OwnerUserId": "471160"}, "39450037": {"Id": "39450037", "PostTypeId": "2", "Body": "<p>The member declaration</p>\n<pre><code>A* const&amp; this_ref{this};\n</code></pre>\n<p>binds a reference to a temporary that only exists during constructor execution (note: <code>this</code> is an rvalue expression).</p>\n<p>I'm not sure if <code>this</code> is formally available in that context, but if it is then with any use of that pointer you have serious case of UB.</p>\n<p>Re</p>\n<blockquote>\n<p id=\"so_39449946_39450037_0\"><strong>\u201d</strong> Which compiler is right?</p>\n</blockquote>\n<p>\u2026 a compiler can issue as many diagnostics as it wants. It's not wrong to issue a diagnostic. So per your description, that both accept the code, then either both compilers are right (which I think is most likely), or both are wrong.</p>\n", "LastActivityDate": "2016-09-12T12:11:45.053", "CommentCount": "1", "CreationDate": "2016-09-12T12:11:45.053", "ParentId": "39449946", "Score": "2", "OwnerUserId": "464581"}, "39451912": {"Id": "39451912", "PostTypeId": "2", "Body": "<p><code>this</code> is <a href=\"http://en.cppreference.com/w/cpp/language/value_category#prvalue\" rel=\"nofollow\">prvalue</a>, and <a href=\"http://en.cppreference.com/w/cpp/language/lifetime#Temporary_object_lifetime\" rel=\"nofollow\">temporary object</a> will be created when binding reference to a prvalue, so you're binding reference member to a temporary in <a href=\"http://en.cppreference.com/w/cpp/language/data_members#Member_initialization\" rel=\"nofollow\">default member initializer</a>.</p>\n<p>And binding reference member to temporary in default member initializer is ill-formed, which is stated by the standard explicitly.</p>\n<p><a href=\"http://eel.is/c++draft/class.base.init#11\" rel=\"nofollow\">$12.6.2/11 Initializing bases and members\n[class.base.init]</a>:</p>\n<blockquote>\n<p id=\"so_39449946_39451912_0\">A temporary expression bound to a reference member from a default\n  member initializer is ill-formed. [ Example:</p>\n<pre><code>struct A {\n  A() = default;          // OK\n  A(int v) : v(v) { }     // OK\n  const int&amp; v = 42;      // OK\n};\nA a1;                     // error: ill-formed binding of temporary to reference\nA a2(1);                  // OK, unfortunately\n</code></pre>\n<p id=\"so_39449946_39451912_1\">\u2014 end example ]</p>\n</blockquote>\n<p>And see <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1696\" rel=\"nofollow\">CWG 1696</a>, this is applied to C++14.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-09-12T13:59:12.307", "Score": "1", "CreationDate": "2016-09-12T13:50:31.690", "ParentId": "39449946", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2016-09-12T13:59:12.307"}, "39449946": {"ViewCount": "254", "Body": "<p>This is a follow-up of <a href=\"https://stackoverflow.com/questions/39446854/why-gcc-5-3-0-gives-warning-when-binding-reference-to-this-pointer#comment66215826_39446854\">these</a> <a href=\"https://stackoverflow.com/questions/39258248/is-it-possible-to-get-reference-to-this-pointer-in-class-body-without-using-th\">questions</a>.</p>\n<p>Consider the following code:</p>\n<pre><code>struct A {\nprivate:\n    A* const&amp; this_ref{this};\n};\n\nint main() {\n    A a{};\n    (void)a;\n}\n</code></pre>\n<p>If compiled with the <code>-Wextra</code>, both <a href=\"https://godbolt.org/g/TYQ75w\" rel=\"nofollow noreferrer\">GCC</a> v6.2 and <a href=\"https://godbolt.org/g/hB8d3p\" rel=\"nofollow noreferrer\">clang</a> v3.9 show a warning.</p>\n<p>Anyway, with the slightly modified version shown below they behave differently:</p>\n<pre><code>struct A {\n    A* const&amp; this_ref{this};\n};\n\nint main() {\n    A a{};\n    (void)a;\n}\n</code></pre>\n<p>In this case <a href=\"https://godbolt.org/g/eeXFrR\" rel=\"nofollow noreferrer\">GCC</a> doesn't give any warning, <a href=\"https://godbolt.org/g/wk9B0h\" rel=\"nofollow noreferrer\">clang</a> gives the same warning as returned in the previous example.</p>\n<p>The warnings are almost the identical.<br>\nIt follows the one from clang:</br></p>\n<blockquote>\n<p id=\"so_39449946_39449946_0\">3 : warning: binding reference member 'this_ref' to a temporary value [-Wdangling-field]</p>\n</blockquote>\n<p>Which compiler is right?</p>\n<p>I would say that GCC is wrong in this case and I were opening an issue, but maybe it's the opposite because of an arcane corner case of the language.</p>\n", "AcceptedAnswerId": "39451728", "Title": "Reference to the this pointer: GCC vs clang", "CreationDate": "2016-09-12T12:07:04.173", "Id": "39449946", "CommentCount": "7", "LastEditDate": "2017-05-23T12:15:03.633", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-12T13:59:12.307", "Score": "7", "OwnerUserId": "4987285", "Tags": "<c++><gcc><clang><language-lawyer><this-pointer>", "AnswerCount": "3"}});