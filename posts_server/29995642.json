post_cb({"29995642": {"ViewCount": "669", "Body": "<p>So, what I want is to create multidimensional vector of given type where the first dimension will have size of the first argument of a function call, etc, for example if I do</p>\n<pre><code>std::size_t n = 5;\nauto x = make_vector&lt;int&gt;(n + 1, n * 2, n * 3);\n</code></pre>\n<p><code>x</code> should be 6x10x15 3d array (consisting of zeroes, because I want to default construct right now)</p>\n<p>I have tried this:</p>\n<pre><code>template &lt;typename T&gt;\nstd::vector&lt;T&gt; make_vector(std::size_t size) {\n    return std::vector&lt;T&gt;(size);\n}\n\ntemplate &lt;typename T, typename... Args&gt;\nauto make_vector(std::size_t first, Args... sizes) -&gt; std::vector&lt;decltype(make_vector&lt;T&gt;(sizes...))&gt; {\n    auto inner = make_vector&lt;T&gt;(sizes...);\n    return std::vector&lt;decltype(inner)&gt;(first, inner);\n}\n</code></pre>\n<p>It seems to work for 1 or 2 arguments, but fails for 3 arguments with following error(clang++)</p>\n<pre><code>In file included from /Users/riad/ClionProjects/for-jhelper/output/run.cpp:1:\n/Users/riad/ClionProjects/for-jhelper/tasks/TaskC.cpp:12:12: error: no matching function for call to 'make_vector'\n                auto x = make_vector&lt;int&gt;(n + 1, n * 2, n * 3);\n                         ^~~~~~~~~~~~~~~~\n/Users/riad/ClionProjects/for-jhelper/tasks/../spcppl/make_vector.hpp:9:6: note: candidate template ignored: substitution failure [with T = int, Args = &lt;unsigned long, unsigned long&gt;]: call to function 'make_vector' that is neither visible in the template definition nor found by argument-dependent lookup\nauto make_vector(std::size_t first, Args... sizes) -&gt; std::vector&lt;decltype(make_vector&lt;T&gt;(sizes...))&gt; {\n     ^                                                                     ~~~~~~~~~~~\n/Users/riad/ClionProjects/for-jhelper/tasks/../spcppl/make_vector.hpp:4:16: note: candidate function template not viable: requires single argument 'size', but 3 arguments were provided\nstd::vector&lt;T&gt; make_vector(std::size_t size) {\n</code></pre>\n<p>If I understand correctly problem is that when compiler tries to calculate return value of make_vector it have to know the return value of vector with less number of arguments and fails to do so. How do I fix that? </p>\n", "AcceptedAnswerId": "29998034", "Title": "Create n-dimensional vector with given sizes", "CreationDate": "2015-05-01T21:47:37.300", "Id": "29995642", "CommentCount": "10", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-05-05T12:33:51.637", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-05T12:33:51.637", "Score": "8", "OwnerUserId": "768110", "Tags": "<c++><templates><c++11><variadic-templates><template-meta-programming>", "AnswerCount": "5"}, "29998034": {"Id": "29998034", "PostTypeId": "2", "Body": "<p>Create a namespace to put some helpers in it, called <code>details</code>.</p>\n<p>In <code>details</code> create a type <code>struct adl_helper{};</code></p>\n<p>Create an implementation of <code>make_vector</code>, except its first parameter is always a template parameter called <code>Adl</code>.  This template parameter is never named, and instances of it are passed to recursions.</p>\n<p>Implement <code>make_vector( blah )</code> by calling <code>details::make_vector&lt;T&gt;( details::adl_helper{}, blah )</code>.</p>\n<pre><code>namespace details {\n  struct adl_helper { };\n\n  template &lt;class T, class Adl&gt;\n  std::vector&lt;T&gt; make_vector(Adl, size_t size) {\n    return std::vector&lt;T&gt;(size);\n  }\n\n  template &lt;class T, class Adl, class... Args,\n    class R_T=decltype(\n      make_vector&lt;T&gt;(Adl{}, std::declval&lt;Args&gt;()...)\n    ),\n    class R=std::vector&lt;R_T&gt;\n  &gt;\n  R make_vector(Adl, size_t first, Args... sizes) \n  {\n    auto inner = make_vector&lt;T&gt;(Adl{}, std::forward&lt;Args&gt;(sizes)...);\n    return R(first, inner);\n  }\n}\n\n\ntemplate &lt;class T, class... Args,\n  class R=decltype(\n    details::make_vector&lt;T&gt;(details::adl_helper{}, std::declval&lt;Args&gt;()...)\n  )\n&gt;\nR make_vector(Args... args)\n{\n  return details::make_vector&lt;T&gt;(details::adl_helper{}, std::forward&lt;Args&gt;(args)...);\n}\n</code></pre>\n<p>What is going on here is that a seemingly recursive call in the signature of a template function is evaluated in two contexts.</p>\n<p>First, it is evaluated where it is declared.  In particular, it is evaluated <em>before itself has been defined</em>.  So it doesn't \"catch\" itself.</p>\n<p>Second, an ADL (argument dependent lookup) based pass is done at the point where it is instantiated based only off template types passed to the function.</p>\n<p>The <code>template&lt;class Adl&gt;</code> and <code>adl_helper</code> types means that this argument dependent lookup can see the <code>details::make_vector</code> function itself when it is instantiated.  And when it looks up the return type, it can <em>also</em> see <code>details::make_vector</code>.  Etc.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/43db48caa169907c\" rel=\"nofollow\">live example</a>.</p>\n<p>The use of <code>class R=</code> aliases and the like is just there to cleanup the code and reduce some needless duplication.</p>\n<p>In this particular case, the effort required to build the return type is easier than all this gymnastics.</p>\n<p>I think <a href=\"http://coliru.stacked-crooked.com/a/707f33a477098004\" rel=\"nofollow\">this solution is cleaner</a>:</p>\n<pre><code>template&lt;class T&gt;struct tag{using type=T;};\ntemplate&lt;class Tag&gt;using type=typename Tag::type;\n\ntemplate&lt;class T, size_t n&gt;\nstruct n_dim_vec:tag&lt; std::vector&lt; type&lt; n_dim_vec&lt;T, n-1&gt; &gt; &gt; &gt; {};\ntemplate&lt;class T&gt;\nstruct n_dim_vec&lt;T, 0&gt;:tag&lt;T&gt;{};\ntemplate&lt;class T, size_t n&gt;\nusing n_dim_vec_t = type&lt;n_dim_vec&lt;T,n&gt;&gt;;\n</code></pre>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-05-03T01:35:06.047", "Score": "4", "CreationDate": "2015-05-02T03:22:07.380", "ParentId": "29995642", "CommentCount": "10", "OwnerUserId": "1774667", "LastEditDate": "2015-05-03T01:35:06.047"}, "30022082": {"Id": "30022082", "PostTypeId": "2", "Body": "<p>I was unaware about the other answers when I posted this. Not deleting it in case it could be useful to someone. Ofcourse the solution is quite trivial with C++14 enabled.</p>\n<p>With [below code](<a href=\"http://ideone.com/p2XEM8\" rel=\"nofollow\">Demo@ideone</a> you can achieve:</p>\n<pre><code>  size_t n = 5;\n  auto x = make_vector&lt;int&gt;(n+1, n*2, n*3);\n</code></pre>\n<p>Here is the code with minimal comments:</p>\n<pre><code>// Creating a multidimensional container (e.g. `vector`, `map`)\ntemplate&lt;template&lt;typename...&gt; class Container,\n         typename T,  \n         size_t DIMENSION&gt;\nstruct MultiDimensional\n{\n  using internal = MultiDimensional&lt;Container, T, DIMENSION-1&gt;;\n  using type = Container&lt;typename internal::type&gt;;\n\n  template&lt;typename... Args&gt;\n  static\n  type Generate (const size_t size, Args... sizes)\n  {\n    return type(size, internal::Generate(sizes...));\n  }\n};\n\n// Last dimension overload\ntemplate&lt;template&lt;typename...&gt; class Container,\n         typename T&gt;\nstruct MultiDimensional&lt;Container, T, 1&gt;  \n{\n  using internal = T;\n  using type = Container&lt;T&gt;;\n\n  static\n  type Generate (const size_t size)\n  {\n    return type(size);\n  }\n};\n\n// Wrapper for the specific requirement of creating a multidimensional `std::vector`\ntemplate&lt;typename T,\n         typename... Args&gt;\nauto make_vector(Args... sizes)\n -&gt; typename MultiDimensional&lt;std::vector, T, sizeof...(sizes)&gt;::type\n{\n  return MultiDimensional&lt;std::vector, T, sizeof...(sizes)&gt;::Generate(sizes...);\n}\n</code></pre>\n", "LastEditorUserId": "514235", "LastActivityDate": "2015-05-05T09:35:14.333", "Score": "1", "CreationDate": "2015-05-04T03:17:32.070", "ParentId": "29995642", "CommentCount": "0", "OwnerUserId": "514235", "LastEditDate": "2015-05-05T09:35:14.333"}, "30002714": {"Id": "30002714", "PostTypeId": "2", "Body": "<p>Interesting question! The problem you're running into is that unqualified name lookup will look in the scopes of where it is used (in increasing order of generality). But, from [basic.scope.pdecl]:</p>\n<blockquote>\n<p id=\"so_29995642_30002714_0\">The <em>point of declaration</em> for a name is immediately after its complete declarator (Clause 8) and before its\n  <em>initializer</em> (if any)</p>\n</blockquote>\n<p>and in this function:</p>\n<pre><code>template &lt;typename T, typename... Args&gt;\nauto make_vector(std::size_t first, Args... sizes) \n-&gt; std::vector&lt;decltype(make_vector&lt;T&gt;(sizes...))&gt; {\n    ...\n}\n</code></pre>\n<p>The \"complete declarator\" includes the trailing-return-type. So the function template <code>make_vector&lt;T, Args...&gt;</code> will not be in scope yet until the <code>{</code>. That's why this won't compile for 3+ arguments.</p>\n<p>The <em>simplest</em> fix would be if you had access to C++14, you simply wouldn't need the trailing return type;</p>\n<pre><code>template &lt;typename T, typename... Args&gt;\nauto make_vector(std::size_t first, Args... sizes)\n{ /* exactly as before */ }\n</code></pre>\n<p>Within the body of the name function, you can make the recursive call with no issues. </p>\n<p>Without C++14, you could forward it to a class template whose name will be in the scope of all the recursive calls:</p>\n<pre><code>template &lt;typename T, size_t N&gt;\nstruct MakeVector\n{\n    template &lt;typename... Args&gt;\n    static auto make_vector(std::size_t first, Args... sizes)\n    -&gt; std::vector&lt;decltype(MakeVector&lt;T, N-1&gt;::make_vector(sizes...))&gt;\n    {\n        auto inner = MakeVector&lt;T, N-1&gt;::make_vector(sizes...);\n        return std::vector&lt;decltype(inner)&gt;(first, inner);        \n    }\n};\n\ntemplate &lt;typename T&gt;\nstruct MakeVector&lt;T, 1&gt;\n{\n    static std::vector&lt;T&gt; make_vector(std::size_t size) {\n        return std::vector&lt;T&gt;(size);\n    }\n};\n\ntemplate &lt;typename T, typename... Args&gt;\nauto make_vector(Args... args)\n-&gt; decltype(MakeVector&lt;T, sizeof...(Args)&gt;::make_vector(args...))\n{\n    return MakeVector&lt;T, sizeof...(Args)&gt;::make_vector(args...);\n}\n</code></pre>\n", "LastActivityDate": "2015-05-02T13:12:50.390", "CommentCount": "0", "CreationDate": "2015-05-02T13:12:50.390", "ParentId": "29995642", "Score": "7", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_29995642_30002714_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7049}}, "n3337": {"so_29995642_30002714_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6794}}, "n4659": {"so_29995642_30002714_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8546}}}, "30045588": {"Id": "30045588", "PostTypeId": "2", "Body": "<p>The easiest solution to this is to drop back to C:</p>\n<pre><code>void foo(size_t n) {\n    int (*threeDArray)[2*n][3*n] = malloc((n + 1)*sizeof(*threeDArray));\n\n    //Do with your array whatever you like.\n    //Here I just initialize it to zeros:\n    for(size_t i = 0; i &lt; n + 1; i++) {\n        for(size_t j = 0; j &lt; 2*n; j++) {\n            for(size_t k = 0; k &lt; 3*n; k++) {\n                threeDArray[i][j][k] = 0;\n            }\n        }\n    }\n\n    free(threeDArray);\n}\n</code></pre>\n<p>As I said, this is not possible in C++: the C++ standard requires all array sizes to be compile time constants. C is much more flexible in this regard, allowing run time array sizes everywhere since C99, even within <code>typedef</code>s.</p>\n<p>So, when I have some code that has to do serious work with multidimensional arrays, I seriously ask myself whether it is worth to move this code into a pure .c file and just link it together with the rest of my project.</p>\n", "LastActivityDate": "2015-05-05T06:21:01.883", "CommentCount": "1", "CreationDate": "2015-05-05T06:21:01.883", "ParentId": "29995642", "Score": "-2", "OwnerUserId": "2445184"}, "29995795": {"Id": "29995795", "PostTypeId": "2", "Body": "<p>I manage to do this by calculating the type separately but that seems unnecessary hard despite it's quite short.</p>\n<pre><code>template &lt;typename T, int n&gt;\nstruct NDVector {\n    typedef std::vector&lt;typename NDVector&lt;T, n - 1&gt;::type&gt; type;\n};\n\ntemplate &lt;typename T&gt;\nstruct NDVector&lt;T, 0&gt; {\n    typedef T type;\n};\n\ntemplate &lt;typename T&gt;\nstd::vector&lt;T&gt; make_vector(std::size_t size) {\n    return std::vector&lt;T&gt;(size);\n}\n\n\ntemplate &lt;typename T, typename... Args&gt;\ntypename NDVector&lt;T, sizeof...(Args) + 1&gt;::type make_vector(std::size_t first, Args... sizes) {\n    typedef typename NDVector&lt;T, sizeof...(Args) + 1&gt;::type Result;\n    return Result(first, make_vector&lt;T&gt;(sizes...));\n}\n</code></pre>\n<p>Will really appreciate more elegant solution</p>\n", "LastActivityDate": "2015-05-01T22:02:57.320", "CommentCount": "1", "CreationDate": "2015-05-01T22:02:57.320", "ParentId": "29995642", "Score": "4", "OwnerUserId": "768110"}});