post_cb({"32185160": {"CommentCount": "5", "AcceptedAnswerId": "32185258", "PostTypeId": "1", "LastEditorUserId": "163394", "CreationDate": "2015-08-24T14:43:59.090", "LastActivityDate": "2015-08-24T15:33:47.823", "LastEditDate": "2015-08-24T14:56:38.210", "ViewCount": "164", "FavoriteCount": "1", "Title": "Copy initialization is effective with move in C++11?", "Id": "32185160", "Score": "2", "Body": "<p>Copy initialization is when <code>Hello</code> is created in memory and then being used copy constructor to initialize <code>s</code>, right?</p>\n<pre><code>std::string s = std::string(\"Hello\")\n</code></pre>\n<p>After C++11 where move semantics is introduced can I say that the code above is as effective (eliminates copy) as in this case:</p>\n<pre><code>std::string s(\"Hello\");\n</code></pre>\n<p>EDIT: please don't answer for <code>string</code>. <code>string</code> was just and example of a class. SSO is not the case what I ask. I ask in general. </p>\n", "Tags": "<c++><c++11><copy-constructor><move-semantics>", "OwnerUserId": "163394", "AnswerCount": "3"}, "32185271": {"ParentId": "32185160", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Actually, this was the case before C++11 because of <a href=\"https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization\">copy elision</a>.</p>\n<p>Note that <code>std::string</code> is not necessarily cheap to move, as small strings may be held in the object itself rather than being dynamically allocated. This is known as <a href=\"https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring\">small string optimisation</a>.</p>\n", "OwnerUserId": "496161", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:11.833", "Id": "32185271", "Score": "0", "CreationDate": "2015-08-24T14:49:19.030", "LastActivityDate": "2015-08-24T14:49:19.030"}, "bq_ids": {"n4140": {"so_32185160_32185404_0": {"section_id": 480, "quality": 1.0, "length": 9}}, "n3337": {"so_32185160_32185404_0": {"section_id": 471, "quality": 1.0, "length": 9}}, "n4659": {"so_32185160_32185404_0": {"section_id": 502, "quality": 1.0, "length": 9}}}, "32185404": {"ParentId": "32185160", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Short answer: performances should be the same if copy elision is performed. Otherwise the latter should probably be faster.</p>\n<hr>\n<p>Long answer:</p>\n<p>This code</p>\n<pre><code>std::string s = std::string(\"Hello\")\n</code></pre>\n<p>should call a move constructor in C++11+ code (it requires an accessible one). Anyway <a href=\"https://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow noreferrer\">copy elision</a> is allowed in this case, although not mandated (cfr. <em>[class.copy]/p31</em>)</p>\n<blockquote>\n<p id=\"so_32185160_32185404_0\">When \n  certain criteria are met, an implementation is allowed to omit the \n  copy/move construction</p>\n</blockquote>\n<p>These are concepts that were already present in pre-C++11 though (they applied to copy constructors as well).</p>\n<p>As to the performances question: </p>\n<blockquote>\n<p id=\"so_32185160_32185404_1\">The standard also describes a few situations where copying can be eliminated even if this would alter the program's behavior, the most common being the return value optimization. Another widely implemented optimization, described in the C++ standard, is when a temporary object of class type is copied to an object of the same type.[1] As a result, copy-initialization is usually equivalent to direct-initialization in terms of performance, but not in semantics; copy-initialization still requires an accessible copy constructor.[2] </p>\n</blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow noreferrer\">Source - Copy elision</a></p>\n<p>If copy elision doesn't take place (e.g. it has been disabled in gcc via <code>-fno-elide-constructors</code> or for whatever reason the compiler won't perform it) then performances will probably <strong>not</strong> be the same and direct initialization should be faster (in this case for <code>std::string</code> <a href=\"https://stackoverflow.com/questions/10315041/meaning-of-acronym-sso-in-the-context-of-stdstring\">SSO</a> might also take a toll on the move)</p>\n</hr>", "OwnerUserId": "1938163", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:26:35.810", "Id": "32185404", "Score": "1", "CreationDate": "2015-08-24T14:56:01.740", "LastActivityDate": "2015-08-24T15:33:47.823"}, "32185258": {"ParentId": "32185160", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When you use strings smaller than 20 characters (depending on the implementation), short string optimization kicks in, and everything is copied anyway.</p>\n<p>But to answer your question, move semantics is not used in any of your examples anyway. In the first case even if both copy constructor and <code>string(const char*)</code> constructors must be available, copy elision will eliminate the copy.</p>\n<p>EDIT:</p>\n<p>To address your edit, if you have one initialization and one initialization + move constructor, the former will obviously always be faster. The reason I brought up SSO is because people assumes that move operations are always cheap (or even free), but not necessarily and sometimes they don't even happen at all.</p>\n", "OwnerUserId": "1707560", "LastEditorUserId": "1707560", "LastEditDate": "2015-08-24T15:13:45.663", "Id": "32185258", "Score": "1", "CreationDate": "2015-08-24T14:48:45.190", "LastActivityDate": "2015-08-24T15:13:45.663"}});