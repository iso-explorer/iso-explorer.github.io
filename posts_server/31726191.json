post_cb({"31728040": {"ParentId": "31726191", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It's simple to implement bit fields with known positions with C++:</p>\n<pre><code>template&lt;typename T, int POS, int SIZE&gt;\nstruct BitField {\n    T *data;\n\n    BitField(T *data) : data(data) {}\n\n    operator int() const {\n        return ((*data) &gt;&gt; POS) &amp; ((1ULL &lt;&lt; SIZE)-1);\n    }\n\n    BitField&amp; operator=(int x) {\n        T mask( ((1ULL &lt;&lt; SIZE)-1) &lt;&lt; POS );\n        *data = (*data &amp; ~mask) | ((x &lt;&lt; POS) &amp; mask);\n        return *this;\n    }\n};\n</code></pre>\n<p>The above toy implementation allows for example to define a 12-bit field in a <code>unsigned long long</code> variable with</p>\n<pre><code>unsigned long long var;\n\nBitField&lt;unsigned long long, 7, 12&gt; muxno(&amp;var);\n</code></pre>\n<p>and the generated code to access the field value is just</p>\n<pre class=\"lang-none prettyprint-override\"><code>0000000000000020 &lt;_Z6getMuxv&gt;:\n  20:   48 8b 05 00 00 00 00    mov    0x0(%rip),%rax  ; Get &amp;var\n  27:   48 8b 00                mov    (%rax),%rax     ; Get content\n  2a:   48 c1 e8 07             shr    $0x7,%rax       ; &gt;&gt; 7\n  2e:   25 ff 0f 00 00          and    $0xfff,%eax     ; keep 12 bits\n  33:   c3                      retq   \n</code></pre>\n<p>Basically what you'd have to write by hand</p>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2015-07-30T17:43:59.703", "Id": "31728040", "Score": "5", "CreationDate": "2015-07-30T15:31:09.953", "LastActivityDate": "2015-07-30T17:43:59.703"}, "31726191": {"CommentCount": "14", "AcceptedAnswerId": "45705017", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-07-30T14:14:42.893", "LastActivityDate": "2017-08-16T06:03:15.777", "LastEditDate": "2017-05-23T12:17:21.663", "ViewCount": "1429", "FavoriteCount": "5", "Title": "Is there a portable alternative to C++ bitfields", "Id": "31726191", "Score": "16", "Body": "<p>There are many situations (especially in low-level programming), where the binary layout of the data is important. For example: hardware/driver manipulation, network protocols, etc.</p>\n<p>In C++ I can read/write arbitrary binary structures using <code>char*</code> and bitwise operations (masks and shifts), but that's tedious and error-prone. Obviously, I try to limit the scope of these operations and encapsulate them in higher-level APIs, but it's still a pain.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/bit_field\" rel=\"nofollow noreferrer\">C++ bitfields</a> seem to offer a developer-friendly solution to this problem, but unfortunately their storage is <a href=\"https://stackoverflow.com/questions/17723604/bitfields-why-implementation-specific\">implementation specific</a>.</p>\n<p>NathanOliver mentionned <code>std::bitset</code> which basically allows you to access individual bits of an integer with a nice <code>operator[]</code> but lacks accessors for multi-bit fields.</p>\n<p>Using meta-programming and/or macros, it's possible to abstract the bitwise operations in a library. Since I don't want to reinvent the wheel, I'm looking for a (preferably STL or boost) library that does that.</p>\n<p><em>For the record, I'm looking into this for a <a href=\"https://technet.microsoft.com/en-us/library/Dd197470(v=WS.10).aspx\" rel=\"nofollow noreferrer\">DNS</a> resolver, but the problem and its solution should be generic.</em></p>\n<p>Edit: <strong>short answer</strong>: it turns out <em>bitfield's storage is reliable in practice</em> (even if it's not mandated by the standard) since system/network libraries use them and yeild well behaved programs when compiled with mainstream compilers.</p>\n", "Tags": "<c++><bit-fields>", "OwnerUserId": "762488", "AnswerCount": "5"}, "42738287": {"ParentId": "31726191", "CommentCount": "0", "Body": "<p>C is designed for low-level bit manipulation. It's easy enough to declare a buffer of unsigned chars, and set it to any bit pattern you want. Especially if your bit strings are very short so fit into one of the integral types.</p>\n<p>One potential problem is byte endiannness. C can't \"see\" this at all, but just as integers have an endianness, so too do bytes, when serialised. Another is the very small number of machines that don't use octets for bytes. C guarantees a byte shall be at least an octet, but 32 and 9 are real-world implementations. In those circumstances, you have to take a decision whether to simply ignore the uper bits (in which case naive code should work), or treat them as part of the bitstream (in which case you've got to be careful to fold CHAR_BIT into your calculations). It's also hard to test the code as you unlikely to find it easy to get your hands on a CHAR+BIT 32 machine.</p>\n", "OwnerUserId": "3310281", "PostTypeId": "2", "Id": "42738287", "Score": "0", "CreationDate": "2017-03-11T17:22:58.830", "LastActivityDate": "2017-03-11T17:22:58.830"}, "31727805": {"ParentId": "31726191", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>From the C++14 standard (N3797 draft), section 9.6 [class.bit], paragraph 1:</p>\n<blockquote>\n<p id=\"so_31726191_31727805_0\">Allocation of bit-fields within a class object is implementation-defined.\n  Alignment of bit-fields is implementation-defined. Bit-fields are packed into some addressable allocation unit.\n  [ Note: Bit-fields straddle allocation units on some machines and not on others. Bit-fields are assigned right-to-left on some machines, left-to-right on others. \u2014 end note ]</p>\n</blockquote>\n<p>Although notes are non-normative, every implementation I'm aware of uses one of two layouts: either big-endian or little endian bit order.</p>\n<p>Note that:</p>\n<ul>\n<li>You must specify padding manually. This implies that you must know the size of your types (e.g. by using <code>&lt;cstdint&gt;</code>).</li>\n<li>You must use unsigned types.</li>\n<li>The preprocessor macros for detecting the bit order are implementation-dependent.</li>\n<li>Usually the bit order endianness is the same as the byte order endianness. I believe there is a compiler flag to override it, though, but I can't find it.</li>\n</ul>\n<p>For examples, look in <code>netinet/tcp.h</code> and other nearby headers.</p>\n<p>Edit by OP: for example <code>tcp.h</code> defines</p>\n<pre><code>struct\n{\n    u_int16_t th_sport;     /* source port */\n    u_int16_t th_dport;     /* destination port */\n    tcp_seq th_seq;     /* sequence number */\n    tcp_seq th_ack;     /* acknowledgement number */\n# if __BYTE_ORDER == __LITTLE_ENDIAN\n    u_int8_t th_x2:4;       /* (unused) */\n    u_int8_t th_off:4;      /* data offset */\n# endif\n# if __BYTE_ORDER == __BIG_ENDIAN\n    u_int8_t th_off:4;      /* data offset */\n    u_int8_t th_x2:4;       /* (unused) */\n# endif\n    // ...\n}\n</code></pre>\n<p>And since it works with mainstream compilers, it means bitset's memory layout is reliable in practice.</p>\n<p>Edit:</p>\n<p>This is portable within one endianness:</p>\n<pre><code>struct Foo {\n    uint16_t x: 10;\n    uint16_t y: 6;\n};\n</code></pre>\n<p>But this may not be because it straddles a 16-bit unit:</p>\n<pre><code>struct Foo {\n    uint16_t x: 10;\n    uint16_t y: 12;\n    uint16_t z: 10;\n};\n</code></pre>\n<p>And this may not be because it has implicit padding:</p>\n<pre><code>struct Foo {\n    uint16_t x: 10;\n};\n</code></pre>\n", "OwnerUserId": "1405588", "LastEditorUserId": "35060", "LastEditDate": "2015-07-30T15:47:37.667", "Id": "31727805", "Score": "8", "CreationDate": "2015-07-30T15:21:27.430", "LastActivityDate": "2015-07-30T15:47:37.667"}, "45705017": {"ParentId": "31726191", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>We have this in production code where we had to port MIPS code to x86-64</p>\n<p><a href=\"https://codereview.stackexchange.com/questions/54342/template-for-endianness-free-code-data-always-packed-as-big-endian\">https://codereview.stackexchange.com/questions/54342/template-for-endianness-free-code-data-always-packed-as-big-endian</a></p>\n<p>Works well for us.</p>\n<p>It's basically a template without any storage, the template arguments specify the position of the relevant bits.</p>\n<p>If you need multiple fields, you put multiple specializations of the template together in a union, together with an array of bytes to provide storage.</p>\n<p>The template has overloads for assignment of value and a conversion operator to <code>unsigned</code> for reading the value.</p>\n<p>In addition, if the fields are larger than a byte, they are stored in big-endian byte order, which is sometimes useful when implementing cross-platform protocols.</p>\n<p>here's a usage example:</p>\n<pre><code>union header\n{\n    unsigned char arr[2];       // space allocation, 2 bytes (16 bits)\n\n    BitFieldMember&lt;0, 4&gt; m1;     // first 4 bits\n    BitFieldMember&lt;4, 5&gt; m2;     // The following 5 bits\n    BitFieldMember&lt;9, 6&gt; m3;     // The following 6 bits, total 16 bits\n};\n\nint main()\n{\n    header a;\n    memset(a.arr, 0, sizeof(a.arr));\n    a.m1 = rand();\n    a.m3 = a.m1;\n    a.m2 = ~a.m1;\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "3742955", "LastEditorUserId": "3742955", "LastEditDate": "2017-08-16T06:03:15.777", "Id": "45705017", "Score": "2", "CreationDate": "2017-08-16T04:13:30.643", "LastActivityDate": "2017-08-16T06:03:15.777"}, "42738153": {"ParentId": "31726191", "CommentCount": "0", "Body": "<p>I have written an implementation of bit fields in C++ as a library header file.  An example I give in the documentation is that, instead of writing this:</p>\n<pre><code>struct A\n  {\n    union\n      {\n        struct\n          {\n            unsigned x : 5;\n            unsigned a0 : 2;\n            unsigned a1 : 2;\n            unsigned a2 : 2;\n          }\n        u;\n        struct\n          {\n            unsigned x : 5;\n            unsigned all_a : 6;\n          }\n        v;\n      };\n  };\n\n// \u2026\n\nA x;\nx.v.all_a = 0x3f;\nx.u.a1 = 0;\n</code></pre>\n<p>you can write:</p>\n<pre><code>typedef Bitfield&lt;Bitfield_traits_default&lt;&gt; &gt; Bf;\n\nstruct A : private Bitfield_fmt\n  {\n    F&lt;5&gt; x;\n    F&lt;2&gt; a[3];\n  };\n\ntypedef Bitfield_w_fmt&lt;Bf, A&gt; Bwf;\n\n// \u2026\n\nBwf::Format::Define::T x;\nBITF(Bwf, x, a) = 0x3f;\nBITF(Bwf, x, a[1]) = 0;\n</code></pre>\n<p>There's an alternative interface, under which the last two lines of the above would change to:</p>\n<pre><code>#define BITF_U_X_BWF Bwf\n#define BITF_U_X_BASE x\nBITF(X, a) = 0x3f;\nBITF(X, a[1]) = 0;\n</code></pre>\n<p>Using this implementation of bit fields, the traits template parameter gives the programmer a lot of flexibility.  Memory is just processor memory by default, or it can be an abstraction, with the programmer providing functions to perform \"memory\" reads and writes.  The abstracted memory is a sequence of elements of any unsigned integral type (chosen by the programmer).  Fields can be laid out either from least-to-most or most-to-least significance.  The layout of fields in memory can be the reverse of what they are in the format structure.</p>\n<p>The implementation is located at:  <a href=\"https://github.com/wkaras/C-plus-plus-library-bit-fields\" rel=\"nofollow noreferrer\">https://github.com/wkaras/C-plus-plus-library-bit-fields</a></p>\n<p>(As you can see, I unfortunately was not able to fully avoid use of macros.)</p>\n", "OwnerUserId": "2793551", "PostTypeId": "2", "Id": "42738153", "Score": "1", "CreationDate": "2017-03-11T17:09:51.633", "LastActivityDate": "2017-03-11T17:09:51.633"}, "bq_ids": {"n4140": {"so_31726191_31727805_0": {"section_id": 5921, "quality": 0.8484848484848485, "length": 28}}, "n3337": {"so_31726191_31727805_0": {"section_id": 5693, "quality": 0.8484848484848485, "length": 28}}, "n4659": {"so_31726191_31727805_0": {"section_id": 7395, "quality": 0.8484848484848485, "length": 28}}}});