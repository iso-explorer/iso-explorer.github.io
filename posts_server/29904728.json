post_cb({"29904784": {"Id": "29904784", "PostTypeId": "2", "Body": "<p>Yes you are guaranteed to get there. Float imprecision occures after processing operations on concerned numbers. Constants are safe in your case.</p>\n<p>However, if you exceed floating-point number precision by providing too much decimals or you initialize the float with another data type, it might get interpreted differently. </p>\n<p>For instance, this might not make it:</p>\n<pre><code>float foo{2.1234321f};\nif (foo * 6.1234321f / 0.1234321f == 105.3428750f)\n{\n    // Am I always guaranteed to get here? Not at all.\n}\n</code></pre>\n<p>If you want to be safe when comparing floating-point numbers, you should \"approximate\" the result. See the code below.</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\nclass exact{};\nclass approx{};\n\ntemplate&lt;class&gt; struct tolerance;\n\ntemplate&lt;&gt;\nstruct tolerance&lt;float&gt;\n{\n    static constexpr float value() { return 0.00001; }\n}\n\ntemplate&lt;class T&gt;\nbool close_enough(T a, T b, exact)\n{\n    return a == b;\n}\n\ntemplate&lt;class T&gt;\nbool close_enough(T a, T b, approx)\n{\n    return abs(a - b) &lt;= tolerance&lt;T&gt;::value();\n}\n\ntemplate&lt;class T&gt;\nbool close_enough(T a, T b)\n{\n    return close_enough(a, b,\n        conditional&lt;numeric_limits&lt;T&gt;::is_exact, exact, approx&gt;::type{});\n}\n\nint main()\n{\n    float a = 2.1234321f, b = 105.3428750f;\n\n    if (close_enough(a * 6.1234321f / 0.1234321f, b))\n    {\n        // Am I always guaranteed to get here? Yes!\n    }\n    else\n    {\n        // ...\n    }\n}\n</code></pre>\n", "LastEditorUserId": "2950563", "LastActivityDate": "2015-04-28T20:21:24.017", "Score": "1", "CreationDate": "2015-04-27T19:55:56.190", "ParentId": "29904728", "CommentCount": "13", "OwnerUserId": "2950563", "LastEditDate": "2015-04-28T20:21:24.017"}, "29904819": {"Id": "29904819", "PostTypeId": "2", "Body": "<p>As far as I know yes it is guaranteed to go to that block. As <strong>0.0f</strong> is a float constant.</p>\n<pre><code>float f = 0.0; /* OK, throw away bits to convert 0.0 from double to float */\nassert ( f == 0.0 ); /* not OK, f is converted from float to double\n   and the value of 0.0 depends on how many bits you use to represent it. */\nassert ( f == 0.0f ); /* OK, comparing two floats, although == is finicky. */\n</code></pre>\n<p>Also note that in  <code>float x = 0</code> there is an implicit typecast from int to float.\nAnd in <code>float x = 0.0f</code> we dont have such a typecast. And in <code>float x = 0.0</code> we have  an implicit typecast from double to float. </p>\n<p>A good read: <a href=\"http://perso.ens-lyon.fr/jean-michel.muller/goldberg.pdf\" rel=\"nofollow\">what every computer scientist should know about floating-point arithmetic</a></p>\n", "LastEditorDisplayName": "user3846015", "OwnerDisplayName": "user3846015", "LastActivityDate": "2015-04-27T20:07:54.530", "Score": "0", "CreationDate": "2015-04-27T19:57:44.757", "ParentId": "29904728", "CommentCount": "2", "LastEditDate": "2015-04-27T20:07:54.530"}, "29905847": {"Id": "29905847", "PostTypeId": "2", "Body": "<p>While there is technically very little guarantee in the standard about floating point numbers, CPUs only use two different representations for them: binary coded decimal, and <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\" rel=\"nofollow\">IEEE 754</a>. Now the first one is rather esoteric, and never used by default because it provides less precision than the IEEE floats, so it is safe to assume that you have IEEE numbers whenever you have floating point.</p>\n<p>Why is that important? Simply because the IEEE format guarantees precision for quite a few values. Specifically, it defines what <code>+0.0</code> and <code>-0.0</code> is, and it follows from the format specification that a <code>float</code> can represent all integers within the range <code>-16777216</code> to <code>16777216</code> exactly. (Likewise, the <code>double</code> format allows for the range <code>-2^53</code> to <code>2^53</code>, which is quite comfortable.) From this, you can make deductions about how long your calculations stay exact and hence allow for equality comparison.</p>\n<p>However, whenever you use this information, you should also write a comment with your deductions, you can't assume that someone else will find them obvious...</p>\n", "LastActivityDate": "2015-04-27T21:00:26.127", "CommentCount": "0", "CreationDate": "2015-04-27T21:00:26.127", "ParentId": "29904728", "Score": "0", "OwnerUserId": "2445184"}, "bq_ids": {"n4140": {"so_29904728_29904728_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7217}}, "n3337": {"so_29904728_29904728_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6961}}, "n4659": {"so_29904728_29904728_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 8726}}}, "29904728": {"ViewCount": "237", "Body": "<p>From N3337 (C++11 draft) section 3.9.1.8:</p>\n<blockquote>\n<p id=\"so_29904728_29904728_0\">The value representation of floating-point types is implementation-defined.</p>\n</blockquote>\n<p>Does this apply to any and all usage of a float type, regardless of if it is a literal or not? Here is the example that is causing me some concern:</p>\n<pre><code>float foo{0.0f};\nif (foo == 0.0f)\n{\n    // Am I always guaranteed to get here?\n}\n</code></pre>\n<p>If we assume that <code>0.0f</code> is not really true 0 as far as the implementation is concerned, but some undefined number, would this comparison still technically be valid since both operands were obtained via constants and even though I may not know its true value, they will both still be the same?</p>\n<p>Equality comparisons with float literals like this always have a code smell and I just want to make sure there aren't certain use cases where this makes sense or is valid.</p>\n", "Title": "Is this comparison to floating point literal zero valid?", "CreationDate": "2015-04-27T19:52:29.460", "LastActivityDate": "2015-04-28T20:21:24.017", "CommentCount": "6", "PostTypeId": "1", "Id": "29904728", "Score": "1", "OwnerUserId": "157971", "Tags": "<c++><c++11><floating-point>", "AnswerCount": "4"}, "29905436": {"Id": "29905436", "PostTypeId": "2", "Body": "<p>In practice</p>\n<pre><code>float foo = 0.0 ;\nif (foo == 0.0)\n{\n}\n</code></pre>\n<p>tends to work. However, doing</p>\n<pre><code>float foot = SOMEARBITRARYCONSTANT ;\nif (foo == SOMEARBITRARYCONSTANT)\n{\n}\n</code></pre>\n<p>may not work.</p>\n<p>It tends to work when SOMEARBITRARYCONSTANT is a value that can be represented exactly and may fail otherwise.</p>\n<p>I have seen the equivalent of:</p>\n<pre><code>float foo = 0.1 ;\nif (foo == 0.1)\n{\n}\n</code></pre>\n<p>not work because the compiler rounded 0.1 differently.</p>\n<p>In general, floating point == is a bad idea.</p>\n", "LastActivityDate": "2015-04-27T20:34:33.857", "CommentCount": "1", "CreationDate": "2015-04-27T20:34:33.857", "ParentId": "29904728", "Score": "-1", "OwnerUserId": "3344003"}});