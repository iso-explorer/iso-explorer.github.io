post_cb({"37571889": {"Id": "37571889", "PostTypeId": "2", "Body": "<p>The specification is a bit indirect. <code>capacity</code> is specified as:</p>\n<blockquote>\n<pre><code>size_type capacity() const noexcept;\n</code></pre>\n<p id=\"so_37571737_37571889_0\"><em>Returns</em>: The total number of elements that the vector can hold without requiring reallocation.</p>\n</blockquote>\n<p>The second part comes from <code>reserve</code>:</p>\n<blockquote>\n<pre><code>reserve(size_type n);\n</code></pre>\n<p id=\"so_37571737_37571889_1\"><em>Remarks</em>: Reallocation invalidates all the references, pointers, and iterators referring to the elements in\n  the sequence. <strong>No reallocation shall take place during insertions that happen after a call to <code>reserve()</code>\n  until the time when an insertion would make the size of the vector greater than the value of <code>capacity()</code></strong>.</p>\n</blockquote>\n<p>From that you can conclude that if the size is less than the capacity, then insertion does not cause reallocation.</p>\n<p>There is no single, direct statement that the vector will not reallocate if there is spare capacity and you haven't explicitly called <code>reserve</code>. However, there is a general container requirement in [container.requirements.general]:</p>\n<blockquote>\n<p id=\"so_37571737_37571889_2\">Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container.</p>\n</blockquote>\n<p>Finally, we have description of the effects of insertion:</p>\n<blockquote>\n<pre><code>[insert/emplace_back/push_back:]\n</code></pre>\n<p id=\"so_37571737_37571889_3\"><em>Remarks</em>: Causes reallocation if the new size is greater than the old capacity.  If no reallocation happens, all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>Putting it all together: Unless otherwise specified, calling a member function does not invalidate iterators. Reallocation invalidates iterators (as described as part of <code>reserve</code> above), so unless otherwise specified, calling a member function, and in particular an insertion, does not reallocate, One such an overriding specification is given for the case where the new size exceeds the current capacity.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2016-06-01T17:34:47.473", "Score": "30", "CreationDate": "2016-06-01T14:42:36.290", "ParentId": "37571737", "CommentCount": "4", "OwnerUserId": "596781", "LastEditDate": "2016-06-01T17:34:47.473"}, "37571873": {"Id": "37571873", "PostTypeId": "2", "Body": "<p>The description of standard is not clear enough. </p>\n<p>$23.3.6.5 vector modifiers [vector.modifiers]:</p>\n<blockquote>\n<p id=\"so_37571737_37571873_0\">Remarks: Causes reallocation if the new size is greater than the old capacity. If no reallocation happens,\n  all the iterators and references before the insertion point remain valid.</p>\n</blockquote>\n<p>So when add elements to <code>std::vector</code> reallocation will certainly happen when the new size is greater than current capacity, but it doesn't says reallocation won't happen even if the new size is less than or equal to current capacity. Anyway if reallocation doesn't happen then all the iterators and references to the elements before the insertion point must remain valid, implies data won't be moved.</p>\n<p>It's the same for <code>insert()</code>, <code>emplace_back()</code>, <code>emplace()</code> and <code>push_back()</code>.</p>\n<p>Quote from <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow\">cppreference.com</a> just as reference:</p>\n<blockquote>\n<p id=\"so_37571737_37571873_1\">If the new <code>size()</code> is greater than <code>capacity()</code> then all iterators and\n  references (including the past-the-end iterator) are invalidated.\n  Otherwise only the past-the-end iterator is invalidated.</p>\n</blockquote>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2016-06-01T16:04:13.240", "Score": "8", "CreationDate": "2016-06-01T14:41:51.747", "ParentId": "37571737", "CommentCount": "3", "OwnerUserId": "3309790", "LastEditDate": "2016-06-01T16:04:13.240"}, "bq_ids": {"n4140": {"so_37571737_37571889_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 986}, "so_37571737_37571889_1": {"length": 30, "quality": 0.967741935483871, "section_id": 972}, "so_37571737_37571889_0": {"length": 8, "quality": 0.8, "section_id": 967}, "so_37571737_37571873_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 986}, "so_37571737_37571889_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 713}}, "n3337": {"so_37571737_37571889_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 971}, "so_37571737_37571873_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 971}, "so_37571737_37571889_0": {"length": 8, "quality": 0.8, "section_id": 957}, "so_37571737_37571889_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 961}, "so_37571737_37571889_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 702}}, "n4659": {"so_37571737_37571889_3": {"length": 18, "quality": 0.9473684210526315, "section_id": 1049}, "so_37571737_37571873_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 1049}, "so_37571737_37571889_0": {"length": 8, "quality": 0.8, "section_id": 1029}, "so_37571737_37571889_1": {"length": 30, "quality": 0.967741935483871, "section_id": 1034}, "so_37571737_37571889_2": {"length": 25, "quality": 0.9615384615384616, "section_id": 742}}}, "37571737": {"ViewCount": "779", "Body": "<p>Is it guaranteed that <code>std::vector</code> only moves its data when <code>size()==capacity()</code> and calling <code>push_back()</code> or <code>emplace_back()</code> or can it do it otherwise also?</p>\n", "Title": "Can std::vector move its data to another address at emplace_back() even though there is still unused space according to capacity()?", "CreationDate": "2016-06-01T14:36:16.303", "LastActivityDate": "2016-06-01T17:34:47.473", "CommentCount": "0", "LastEditDate": "2016-06-01T15:13:04.457", "PostTypeId": "1", "LastEditorUserId": "3309790", "Id": "37571737", "Score": "27", "OwnerUserId": "582235", "Tags": "<c++><c++11><vector><language-lawyer>", "AnswerCount": "2"}});