post_cb({"bq_ids": {"n4140": {"so_24420340_24420535_0": {"length": 46, "quality": 0.6216216216216216, "section_id": 233}}, "n3337": {"so_24420340_24420535_0": {"length": 46, "quality": 0.6216216216216216, "section_id": 226}}}, "24420340": {"ViewCount": "334", "Body": "<p>I have some types which have sub-types with the same name each:</p>\n<pre><code>struct TypeA {\n    typedef int subtype;\n};\nstruct TypeB {\n    typedef float subtype;\n};\n</code></pre>\n<p>and also types which don't have this sub-type but which are used in the same context:</p>\n<pre><code>struct TypeC {\n    // (no subtype defined)\n};\n</code></pre>\n<p>How can I add a dummy sub-type which gives a custom compile error message?</p>\n<p>My (so far unsuccessful) attempt is:</p>\n<pre><code>struct TypeC {\n    struct subtype {\n        static_assert(false, \"Attempt to access the non-existent subtype of TypeC.\");\n    };\n};\n</code></pre>\n<p>But <code>static_assert(false, ...)</code> can't work, as the compiler throws the error even if the type is never accessed.</p>\n<p><strong>How can I delay the evaluation of <code>static_assert</code> to the time when the type is being accessed?</strong></p>\n<p>A failed attempt is to introduce a dummy enum and construct an expression out of it:</p>\n<pre><code>enum { X };\nstatic_assert(X != X, \"...\");\n</code></pre>\n<hr>\n<p>Concrete use case: I have a class-template <code>List</code> which is defined with the sub-types <code>head</code> and <code>tail</code> if non-empty, and should give an error if these sub-types are used if it is empty:</p>\n<pre><code>template&lt;typename...&gt;\nstruct List;\n\n// empty list:\ntemplate&lt;&gt;\nstruct List&lt;&gt; {\n    struct head { static_assert(false, \"Attempt to access the head of an empty list.\"); };\n    struct tail { static_assert(false, \"Attempt to access the tail of an empty list.\"); };\n};\n\n// non-empty list:\ntemplate&lt;typename Head, typename ...Tail&gt;\nstruct List&lt;Head, Tail...&gt; {\n    typedef Head head;\n    typedef List&lt;Tail...&gt; tail;\n};\n</code></pre>\n<p>If I simply leave out the types <code>head</code> and <code>tail</code>, when accessing e.g. the 3rd element of a list which has size 2 with the code <code>List&lt;int,int&gt;::tail::tail::head</code> gives the not so nice message (g++ 4.7.2): <code>'head' is not a member of 'List&lt;int&gt;::tail {aka List&lt;&gt;}'</code></p>\n</hr>", "AcceptedAnswerId": "24420535", "Title": "Custom compile error message when undefined subtype is accessed", "CreationDate": "2014-06-25T23:42:23.270", "Id": "24420340", "CommentCount": "4", "LastEditDate": "2014-07-04T20:13:49.277", "PostTypeId": "1", "LastEditorUserId": "3043539", "LastActivityDate": "2014-07-25T01:39:06.130", "Score": "5", "OwnerUserId": "592323", "Tags": "<c++><templates><c++11><template-meta-programming><static-assert>", "AnswerCount": "2"}, "24420503": {"PostTypeId": "2", "Body": "<p>To delay the evaluation of <code>static_assert</code> to the point where your type is accessed, you have to make the expression <em>depend on a template parameter</em>.</p>\n<p>One possible solution is to add a helper class template just for printing the error message conditionally (depending on the value of the template parameter):</p>\n<pre><code>template&lt;bool X = false&gt;\nstruct SubTypeErrorMessage {\n    static_assert(X, \"Attempt to access the non-existent subtype of TypeC.\");\n};\n</code></pre>\n<p>Then, in the concrete type where you want to have a \"dummy sub-type\":</p>\n<pre><code>struct TypeC {\n    typedef SubTypeErrorMessage&lt;&gt; subtype;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/597e95808577108c\" rel=\"noreferrer\"><strong>Live Demo</strong></a></p>\n", "LastActivityDate": "2014-06-26T00:02:07.943", "Id": "24420503", "CommentCount": "0", "CreationDate": "2014-06-26T00:02:07.943", "ParentId": "24420340", "Score": "5", "OwnerUserId": "592323"}, "24420535": {"PostTypeId": "2", "Body": "<pre><code>// empty list:\ntemplate&lt;typename... Args&gt;\nstruct List {\n    struct head {static_assert(sizeof...(Args) != 0, \"Attempt to access the head of an empty list.\"); };\n    struct tail {static_assert(sizeof...(Args) != 0, \"Attempt to access the tail of an empty list.\"); };\n};\n\n// non-empty list:\ntemplate&lt;typename Head, typename ...Tail&gt;\nstruct List&lt;Head, Tail...&gt; {\n    typedef Head head;\n    typedef List&lt;Tail...&gt; tail;\n};\n</code></pre>\n<p>Edit: This problem actually touches on three aspects of how C++ templates work:</p>\n<blockquote id=\"so_24420340_24420535_0\">\n<ol>\n<li>(\u00a714.7.1 [temp.inst]/p1) Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3), the class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type or when the completeness of the class type affects the semantics of the program. The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions ... of the class member functions, member classes, [...]. </li>\n<li>(\u00a714.7.1 [temp.inst]/p11) An implementation shall not implicitly instantiate ... a member class...of a class template that does not require instantiation.</li>\n<li>(\u00a714.6 [temp.res]/p8) If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic required.</li>\n</ol>\n</blockquote>\n<p>3) means that the <code>static_assert</code> expression must depend on a template argument, as otherwise \"no valid specialization\" can be generated for the template and the program is ill-formed, and compilers are free to report an error (although they don't have to). In the above code, a valid specialization can be generated for the first template, but such a specialization is never used because of the partial specialization.</p>\n<p>The solution given above also relies on 1) and 2). 1) provides that implicitly instantiating a template specialization only instantiates the <em>declarations</em> (not <em>definitions</em>) of member classes, and 2) means that compilers are affirmatively prohibited from attempting to instantiate <code>head</code> or <code>tail</code> if one is merely using an implicitly instantiated <code>List&lt;&gt;</code>. Note that this rule does not apply if you explicitly instantiate <code>List&lt;&gt;</code> with <code>template struct List&lt;&gt;;</code>.</p>\n<p>The solution in leemes's answer works because <code>typedef</code>s do not require a complete type and so do not trigger implicit instantiation of <code>SubTypeErrorMessage&lt;&gt;</code> under 1), and the use of a template argument in the <code>static_assert</code> in <code>SubTypeErrorMessage</code> bypasses 3), as a valid specialization (i.e., <code>SubTypeErrorMessage&lt;true&gt;</code>) can be generated for that template.</p>\n<p>It's worth noting that in both cases the instantiation rules mean that it's still legal to use <code>List&lt;&gt;::head</code> or <code>TypeC::subtype</code> as long as you don't use them in a way that requires a complete type. Thus something like <code>int f(List&lt;&gt;::head &amp; ) { return 0; }</code> is valid, though entirely meaningless since there's no way you can actually call that function. If you don't define <code>List&lt;&gt;::head</code> at all, however, the compiler will report a (perhaps cryptic) error on this code. So that's the trade-off for prettier error messages :)</p>\n", "LastActivityDate": "2014-07-25T01:39:06.130", "LastEditorUserId": "2756719", "Id": "24420535", "CommentCount": "3", "CreationDate": "2014-06-26T00:06:05.450", "ParentId": "24420340", "Score": "5", "OwnerUserId": "2756719", "LastEditDate": "2014-07-25T01:39:06.130"}});