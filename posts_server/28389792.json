post_cb({"bq_ids": {"n4140": {"so_28389792_28390022_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 5455}, "so_28389792_28390022_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5963}}, "n4659": {"so_28389792_28390022_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 6881}, "so_28389792_28390022_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7450}}}, "28390146": {"Id": "28390146", "PostTypeId": "2", "LastEditDate": "2015-02-09T01:45:51.513", "CommentCount": "0", "LastEditorUserId": "1774667", "LastActivityDate": "2015-02-09T01:45:51.513", "CreationDate": "2015-02-08T03:06:55.850", "ParentId": "28389792", "Score": "3", "Body": "<p>First mistake: <code>std::function</code> is a type unrelated to any lambda.</p>\n<p>A lambda is an anonymous type with an <code>operator()</code> and a few other known properties.</p>\n<p><code>std::function&lt;R(Args...)&gt;</code> is a type erasure class for copy construct, destroy and invoke with <code>Args...</code> and return <code>R</code>.  It can be constructed from a lambda, but is not otherwise a related type.</p>\n<p>As you cannot name the type of a lambda, using a <code>std::function</code> to store it is common.  The lambda is not a <code>std::function</code> however.  <code>std::function</code>s have nearly unavoidable overhead from their type erasure and polymorphism: lambdas lack any polymorphism, which makes it really easy for the compiler to understand what <code>()</code> does at the point of invocation.</p>\n<p>In your case you have two lambdas.</p>\n<p>Your first lambda is:</p>\n<pre><code>[](auto&amp;&amp; f0,auto&amp;&amp; a0){return f0(f0,a0);}\n</code></pre>\n<p>This looks like a form of y-combinator, or a variant, used help with recursion.  The <code>operator()</code> in this case has signature:</p>\n<pre><code>template&lt;class F0, class A0&gt;\nauto operator()(F0&amp;&amp;,A0&amp;&amp;)const\n-&gt; std::result_of_t&lt;F0&amp;(F0&amp;,A0&amp;)&gt;\n</code></pre>\n<p>roughly.</p>\n<p>A more useful version (in my opinion) is:</p>\n<pre><code>[](auto&amp;&amp; f0){\n  return [f0=std::forward&lt;decltype(f0)&gt;(f0)]\n    (auto&amp;&amp;...args) {\n      return f0(f0, std::forward&lt;decltype(args)&gt;(args)...);\n    };\n}\n</code></pre>\n<p>which takes an <code>f0</code>, stores it, and invokes it with any arguments passing <code>f0</code> first.  This lets you bind the recursion 'out of sight'.  Making the inner lambda <code>mutable</code> is optional (depends if you want to invoke in a <code>const</code> context)</p>\n<p>Anyhow, the next lambda:</p>\n<pre><code>[](auto&amp; f,auto&amp;&amp; a)-&gt;int{ return (a&gt;1) ? f(f,a-1)*a : 1; }\n</code></pre>\n<p>has an <code>operator()</code> signature of:</p>\n<pre><code>template&lt;class F, class A&gt;\nauto operator()(F&amp;,A&amp;&amp;)const\n-&gt; int\n</code></pre>\n<p>You then pass an instance of the second lambda to the first, plus an argument, and it calculates <code>n!</code>.</p>\n<p>The types deduced by the <code>template</code> operator <code>()</code> do not depend on the types that the arguments themselves deduce, so there is no infinite type deduction problem.  The return type of the inner lambda is hard coded to <code>int</code>, so you don't have to deduce what <code>()</code> recursively returns to know it returns <code>int</code>.</p>\n<p>If you want to store the first lambda in a <code>std::function</code>, however, you are going to be disappointed.  <code>std::function</code> cannot erase a <code>template operator()</code>: it can only erase a fixed signature, and a <code>template</code> member is a factory of methods, not a method itself.</p>\n<p>However, remember my better version of y combination above?</p>\n<p>Call your first lambda <code>g</code>, your second <code>h</code> and my lambda <code>y</code> and the lambda my lambda returns <code>z</code>.</p>\n<p>Then <code>g(h,x)</code> = <code>y(h)(x)</code>  -- and <code>y(h)</code> can be stored in a <code>std::function&lt;int(int)&gt;</code> no problem.  We hide the part of the recursion that basically requires a recursive type signature, which <code>std::function</code> does not support<sup>1</sup>.  What is left, while it has a <code>template operator()</code>, can be bound to a simple signature.</p>\n<hr>\n<p><sup>1</sup> note that you could write <code>std::function</code> to support recursive signatures, like <code>std::function&lt; std::vector&lt;SELF_TYPE&gt;(int) &gt;</code>.  You can see how this might work with how <code>boost::variant</code> works with recursive variants.</p>\n</hr>", "OwnerUserId": "1774667"}, "28390022": {"Id": "28390022", "PostTypeId": "2", "LastEditDate": "2015-02-08T02:52:02.193", "CommentCount": "0", "LastEditorUserId": "2069064", "LastActivityDate": "2015-02-08T02:52:02.193", "CreationDate": "2015-02-08T02:45:03.863", "ParentId": "28389792", "Score": "1", "Body": "<p>From [expr.prim.lambda], emphasis mine:</p>\n<blockquote>\n<p id=\"so_28389792_28390022_0\">The\n  lambda return type is <code>auto</code>, <strong>which is replaced by the <em>trailing-return-type</em> if provided</strong> and/or deduced from\n  return statements as described in 7.1.6.4.</p>\n</blockquote>\n<p>You provide a <em>trailing-return-type</em>, that is the <code>-&gt;int</code> in your code, so no type deduction has to happen. The return type is just <code>int</code>.</p>\n<p>However, even without the <code>-&gt;int</code>, you can still get your function to compile if you just provided a <code>if</code> statement instead of using the conditional operator:</p>\n<pre><code>auto f = [](auto&amp; f0, auto&amp;&amp; a) {\n    if (a &lt;= 1) {\n        return 1; // this *must* be the first return case.\n    }\n    else {\n        return f0(f0, a-1) * a;\n    }\n};\n\nstd::cout &lt;&lt; f(f, 5) &lt;&lt; std::endl; // prints 120\n</code></pre>\n<p>This case, and only this case, fits one of the rules as above mentioned in \u00a77.1.6.4 [dcl.spec.auto]:</p>\n<blockquote>\n<p id=\"so_28389792_28390022_1\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression,\n  the program is ill-formed. Once a return statement has been seen in a function, however, the return type\n  deduced from that statement can be used in the rest of the function, including in other return statements.<br>\n<em>[Example:</em> </br></p>\n<pre><code> auto sum(int i) {\n     if (i == 1)\n         return i; // sum\u2019s return type is int\n     else\n         return sum(i-1)+i; // OK, sum\u2019s return type has been deduced\n }\n</code></pre>\n<p id=\"so_28389792_28390022_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n", "OwnerUserId": "2069064"}, "28389792": {"ViewCount": "341", "LastEditDate": "2015-02-08T02:36:24.000", "AcceptedAnswerId": "28390146", "Title": "Type of recursive calling generic lambda expression in C++14", "CreationDate": "2015-02-08T02:06:50.553", "LastActivityDate": "2015-02-09T01:45:51.513", "CommentCount": "1", "Body": "<p>What is the type of the lambda expression in (1) ?</p>\n<p>Why can this code compile?</p>\n<pre><code>#include&lt;functional&gt;\n#include&lt;iostream&gt;\n\n\nint main() {\n    std::cout &lt;&lt; \n        [](auto&amp;&amp; f0,auto&amp;&amp; a0){return f0(f0,a0);}\n        (\n            [](auto&amp; f,auto&amp;&amp; a)-&gt;int{ return (a&gt;1) ? f(f,a-1)*a : 1; }, // (1)\n            5\n         )\n         &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I think that infinite recursion is caused by type inference for lambda expression (1) in this code.\nI think that <code>auto&amp; f</code> is replaced to a type name such as <code>std::function&lt;int(std::function&lt;int(std::function&lt;int(......)&gt;)&gt;)&gt;</code>. </p>\n<p>Please point out my mistake.</p>\n", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "28389792", "AnswerCount": "2", "Score": "1", "OwnerUserId": "4541995", "Tags": "<c++><recursion><lambda><c++14>", "FavoriteCount": "1"}});