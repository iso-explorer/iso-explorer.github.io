post_cb({"bq_ids": {"n4140": {"so_31310175_33065133_0": {"length": 5, "quality": 1.0, "section_id": 3906}}, "n3337": {"so_31310175_33065133_0": {"length": 5, "quality": 1.0, "section_id": 3766}}}, "33065729": {"LastActivityDate": "2015-10-11T14:05:36.957", "CreationDate": "2015-10-11T13:48:41.750", "CommentCount": "0", "Body": "<p>In addition to the problem pointed out by songyuanyao's answer, the code you present is undefined behavior. First, it is possible that the vector needs to reallocate because of a <code>push_back</code>, and then all iterator are invalidated and thus incrementing the loop variable is undefined behavior.</p>\n<p>Looking at <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow\">the documentation for push_back</a>:</p>\n<blockquote>\n<p id=\"so_31310175_33065729_0\">If the new size() is greater than capacity() then all iterators and\n  references (including the past-the-end iterator) are invalidated.\n  Otherwise only the past-the-end iterator is invalidated.</p>\n</blockquote>\n<p>, I would say that appending to the vector in a range-based for statement is undefined behavior in any case, because the end iterator is always invalidated. The range-based for stores a copy of the initial <code>end()</code>-iterator, and this iterator is invalidated after the first <code>push_back</code>. This matches to your output, because it still points to the original end of the three-element vector. However, you should not rely on this behavior.</p>\n<p>Unfortuantely, I could not find a rigid definition of \"invalid iterator\" semantics in the standard. \u00a724.2.1.11 says that invalid iterators may be singular, but only states that dereferencing them may be undefined behavior. There is no semantics for comparing them, but given the fact that one implementation for vectors is to use the next memory address following the internal storage, and that address changes when the vector reallocates, I would say that the loop is undefined behavior.</p>\n", "Id": "33065729", "LastEditDate": "2015-10-11T14:05:36.957", "ParentId": "31310175", "OwnerUserId": "2169853", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "2169853"}, "33065133": {"LastActivityDate": "2015-10-11T16:15:54.743", "CreationDate": "2015-10-11T12:47:29.500", "CommentCount": "8", "Body": "<p>This is called <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"nofollow\">Range-based for loop</a>.</p>\n<p>6.5.4$1 The range-based for statement [stmt.ranged]:</p>\n<blockquote>\n<p id=\"so_31310175_33065133_0\">In each case, a range-based for statement is equivalent to</p>\n<pre><code>{\n  auto &amp;&amp; __range = range-init;\n  for ( auto __begin = begin-expr,\n             __end = end-expr;\n        __begin != __end;\n        ++__begin ) {\n    for-range-declaration = *__begin;\n    statement\n  }\n}\n</code></pre>\n</blockquote>\n<p>Note the equivalent pseudocode, <code>__end</code> (and <code>__begin</code>) will be set only once at the start of the loop. In your case, after the <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow\">push_back</a> at the last time of loop, the iterators might be invalid. If yes, the increment and comparsion on them will be implementation dependent. That means, as one of the possibilities, <code>__end</code> and <code>__begin</code> will remain the same, and loop count won't change.</p>\n", "Id": "33065133", "LastEditDate": "2015-10-11T16:15:54.743", "ParentId": "31310175", "OwnerUserId": "3309790", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "3309790"}, "31310175": {"FavoriteCount": "1", "ViewCount": "79", "Id": "31310175", "Score": "6", "Title": "Unusual behavior with auto while traversing a dynamic vector", "LastEditorUserId": "3777958", "CommentCount": "1", "Body": "<p>I am traversing a vector with auto ( code attached ). While traversing, I am also appending some elements at the back. I was not expecting the output that I got.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector &lt;int&gt; dynamic_vector;\n\nvoid access( )\n{\n    for ( auto i : dynamic_vector ) {\n        if ( i == 3 ) {\n            dynamic_vector.push_back( 4 );\n            dynamic_vector.push_back( 5 );\n        }\n        cout &lt;&lt; i &lt;&lt; endl;\n    }\n}\n\nint main() {\n    dynamic_vector.push_back( 1 );\n    dynamic_vector.push_back( 2 );\n    dynamic_vector.push_back( 3 );\n    access( );\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>1\n2\n3\n</code></pre>\n<p>I was expecting all numbers from 1 to 5 will get printed. I am not able to understand how traversing with auto works?</p>\n", "Tags": "<c++><c++11><vector><iterator><auto>", "CreationDate": "2015-07-09T06:55:14.097", "LastEditDate": "2015-10-11T14:08:44.867", "LastActivityDate": "2015-10-11T16:15:54.743", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "2440786"}});