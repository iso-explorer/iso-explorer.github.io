post_cb({"46505988": {"CommentCount": "0", "AcceptedAnswerId": "46506254", "CreationDate": "2017-09-30T18:49:04.483", "LastActivityDate": "2017-09-30T21:03:22.813", "PostTypeId": "1", "ViewCount": "150", "FavoriteCount": "1", "Title": "Static vs. Member Operator Overloads: std::operator<< and std::ostream::operator<<", "Id": "46505988", "Score": "7", "Body": "<p>The <code>ostream</code> class of C++ provides many default overloads for <code>operator&lt;&lt;</code>, however they are not all defined in the same way.</p>\n<p>The <a href=\"http://www.cplusplus.com/reference/ostream/ostream/operator-free/\" rel=\"noreferrer\">overloads</a> for <code>char</code> types, <code>string</code> types, and rvalue streams are defined as free <code>namespace</code>-scope functions such as:</p>\n<pre><code>namespace std {\nostream &amp;operator&lt;&lt;(ostream &amp;os, char c);\n}\n</code></pre>\n<p>While the <a href=\"http://www.cplusplus.com/reference/ostream/ostream/operator&lt;&lt;/\" rel=\"noreferrer\">overloads</a> for arithmetic types, <code>streambuf</code>, and stream manipulators are defined as member functions of <code>std::ostream</code> such as:</p>\n<pre><code>namespace std {\nostream &amp;ostream::operator&lt;&lt;(int val);\n}\n</code></pre>\n<h1>My Question</h1>\n<p>Is there an reason for this distinction? I understand that calls to these operator overloads operate slightly differently (i.e. ADL for the free <code>namespace</code>-scope definitions), and so I'd imagine there might be a preference to a particular type of operator overload for optimization purposes. But here <code>std::ostream</code> uses both types of definitions for different types. Are there any advantages to this semantically or implementation optimizations that this allows for?</p>\n", "Tags": "<c++><c++11><operator-overloading><iostream>", "OwnerUserId": "6452255", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46505988_46506254_2": {"section_id": 587, "quality": 0.8333333333333334, "length": 25}, "so_46505988_46506254_1": {"section_id": 583, "quality": 1.0, "length": 33}}, "n3337": {"so_46505988_46506254_2": {"section_id": 577, "quality": 0.8333333333333334, "length": 25}, "so_46505988_46506254_1": {"section_id": 573, "quality": 1.0, "length": 33}}, "n4659": {"so_46505988_46506254_2": {"section_id": 610, "quality": 0.8333333333333334, "length": 25}, "so_46505988_46506254_1": {"section_id": 606, "quality": 1.0, "length": 33}}}, "46506254": {"ParentId": "46505988", "PostTypeId": "2", "CommentCount": "14", "Body": "<blockquote>\n<p id=\"so_46505988_46506254_0\">I'd imagine there might be a preference to a particular type of operator overload for optimization purposes</p>\n</blockquote>\n<p>Well, no. At the end of the day both are preformed as function calls. There is not even an apparent implication to overload resolution itself. Since the standard dictates at [over.match], paragraphs <a href=\"http://eel.is/c++draft/over.match#oper-2\" rel=\"nofollow noreferrer\">2</a> and <a href=\"http://eel.is/c++draft/over.match#oper-6\" rel=\"nofollow noreferrer\">6</a>:</p>\n<blockquote>\n<p id=\"so_46505988_46506254_1\">If either operand has a type that is a class or an enumeration, a\n  user-defined operator function might be declared that implements this\n  operator or a user-defined conversion can be necessary to convert the\n  operand to a type that is appropriate for a built-in operator. In this\n  case, overload resolution is used to determine which operator function\n  or built-in operator is to be invoked to implement the operator.</p>\n<p id=\"so_46505988_46506254_2\">The set of candidate functions for overload resolution is the union of\n  the member candidates, the non-member candidates, and the built-in\n  candidates. The argument list contains all of the operands of the\n  operator. The best function from the set of candidate functions is\n  selected according to [over.match.viable] and [over.match.best].</p>\n</blockquote>\n<p>All of those operator overloads are resolved together. The only semantic difference is that a class deriving from <code>ostream</code> may choose to <strong>hide</strong> certain member overloads. This is done with accordance to how overloading works in a derived class. Only the overloads explicitly declared will be applicable. Unlike those members, the free function overloads will always participate in overload resolution, even for classes that derive from <code>ostream</code>.</p>\n<p>Since a derived class needs to be converted to an <code>ostream&amp;</code> in order for a free-function overload to be chosen, its own implicit conversion sequence needs to be ranked. And it may cause ambiguities if all the overloads are free functions. </p>\n<p>So the consideration may very well be to separate the types which may cause an ambiguity (pointers and arithmetic types) from the useful types which we may always want to have available (pointers to C-strings and individual characters). And allow hiding the \"less useful\" ones so as to avoid those ambiguities.</p>\n<hr>\n<p>As pointed out by W.F. <code>ostream</code> is in fact <code>basic_ostream&lt;char&gt;</code>. The free functions just so happen to be for data that requires streaming only. Characters or strings in the streams native \"alphabet\". So for <code>basic_ostream&lt;wchar_t&gt;</code> those free functions will accept <code>wchar_t</code> and <code>wchar_t*</code>. It's quite possible that simple streaming doesn't require any access to the streams private section.</p>\n<p>The other overloads are for data that requires serialization before streaming. Since said serialization is tightly coupled with the streams internal state, it makes far more sense to make those overloads be members.</p>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-09-30T21:03:22.813", "Id": "46506254", "Score": "5", "CreationDate": "2017-09-30T19:19:50.043", "LastActivityDate": "2017-09-30T21:03:22.813"}});