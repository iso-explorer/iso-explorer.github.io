post_cb({"28519731": {"ParentId": "28519704", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Partial specializations are automatically preferred over primary ones if they are matching. [temp.class.spec.match]/1:</p>\n<blockquote>\n<p id=\"so_28519704_28519731_0\">When a class template is used in a context that requires an\n  instantiation of the class, it is necessary to determine whether the\n  instantiation is to be generated using the primary template or one of\n  the partial specializations. This is done by matching the template\n  arguments of the class template specialization with the template\n  argument lists of the partial specializations.</p>\n<p id=\"so_28519704_28519731_1\">(1.1) \u2014 <strong>If exactly one matching specialization is found, the\n  instantiation is generated from that specialization.</strong></p>\n</blockquote>\n<p>For the function call, partial ordering kicks in though - and it ignores references for purposes of argument deduction, [temp.deduct.partial]/5:</p>\n<blockquote>\n<p id=\"so_28519704_28519731_2\">Before the partial ordering is done, certain transformations are\n  performed on the types used for partial ordering:</p>\n<p id=\"so_28519704_28519731_3\">(5.1) \u2014 If <code>P</code> is a reference type, <code>P</code> is replaced by the type\n  referred to.</p>\n</blockquote>\n<p>... which makes the function templates equivalent for partial ordering. Thus the call is ambiguous.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-02-14T20:09:34.323", "Id": "28519731", "Score": "3", "CreationDate": "2015-02-14T20:03:51.197", "LastActivityDate": "2015-02-14T20:09:34.323"}, "30252004": {"ParentId": "28519704", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28519704_30252004_0\">In the above example, the <code>is_rvalue_ref_func</code> overloads are obtained by\n  performing precisely this rewrite of the <code>is_rvalue_ref</code> primary\n  template and partial specialization.</p>\n</blockquote>\n<p>Hardly.</p>\n<blockquote>\n<p id=\"so_28519704_30252004_1\">the first function template has the same template parameters as the\n  first partial specialization and has a single function parameter whose\n  type is <strong>a class template specialization with the template arguments of\n  the first partial specialization</strong></p>\n</blockquote>\n<p>The correct rewrite, given a class template <code>template&lt;class&gt; class SomeTemplate;</code>, is</p>\n<pre><code>template&lt;class T&gt; void is_rvalue_ref_func(SomeTemplate&lt;T&gt;);\ntemplate&lt;class T&gt; void is_rvalue_ref_func(SomeTemplate&lt;T&amp;&amp;&gt;);\n</code></pre>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "30252004", "Score": "1", "CreationDate": "2015-05-15T05:20:38.210", "LastActivityDate": "2015-05-15T05:20:38.210"}, "28519796": {"ParentId": "28519704", "CommentCount": "0", "Body": "<p>The function templates are not partially specialized. Your quote only applies to partial class template specialization. It uses the rules for function overload resolution to define which specialization is more specialized.</p>\n<p>Instead, the function templaes are overloaded and there are two equally good overloads. Note, you can't partially specialize function template, you can only fully specialize them.</p>\n<p>If you want to use a function template to determine if something is an rvalue you could do something like this (I think; currently I can't easily test the code):</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr bool is_rvalue_func(T&amp;&amp;) {\n    return !std::is_reference&lt;T&gt;::value;\n}\n</code></pre>\n<p>I don't think you can distinguish between rvalues and rvalue references being passed to the function, though. That is, I think both of these will yield <code>true</code> although only the latter is actually an rvalue reference to an object:</p>\n<pre><code>is_rvalue_func(int());\nint i(17);\nis_rvalue_func(std:move(i));\n</code></pre>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "28519796", "Score": "0", "CreationDate": "2015-02-14T20:11:48.677", "LastActivityDate": "2015-02-14T20:11:48.677"}, "bq_ids": {"n4140": {"so_28519704_28519704_0": {"section_id": 147, "quality": 0.9285714285714286, "length": 26}, "so_28519704_28519731_1": {"section_id": 143, "quality": 1.0, "length": 8}, "so_28519704_28519704_2": {"section_id": 147, "quality": 1.0, "length": 22}, "so_28519704_28519704_1": {"section_id": 147, "quality": 1.0, "length": 22}, "so_28519704_28519731_0": {"section_id": 143, "quality": 0.967741935483871, "length": 30}, "so_28519704_28519731_3": {"section_id": 324, "quality": 1.0, "length": 5}, "so_28519704_28519731_2": {"section_id": 324, "quality": 1.0, "length": 10}, "so_28519704_30252004_1": {"section_id": 147, "quality": 1.0, "length": 22}}, "n3337": {"so_28519704_28519704_0": {"section_id": 141, "quality": 0.9285714285714286, "length": 26}, "so_28519704_28519731_1": {"section_id": 137, "quality": 1.0, "length": 8}, "so_28519704_28519704_1": {"section_id": 141, "quality": 1.0, "length": 22}, "so_28519704_28519704_2": {"section_id": 141, "quality": 1.0, "length": 22}, "so_28519704_28519731_0": {"section_id": 137, "quality": 0.967741935483871, "length": 30}, "so_28519704_28519731_3": {"section_id": 314, "quality": 1.0, "length": 5}, "so_28519704_28519731_2": {"section_id": 314, "quality": 1.0, "length": 10}, "so_28519704_30252004_1": {"section_id": 141, "quality": 1.0, "length": 22}}, "n4659": {"so_28519704_28519704_0": {"section_id": 151, "quality": 0.8571428571428571, "length": 24}, "so_28519704_28519731_1": {"section_id": 147, "quality": 1.0, "length": 8}, "so_28519704_28519704_1": {"section_id": 151, "quality": 0.9090909090909091, "length": 20}, "so_28519704_28519704_2": {"section_id": 151, "quality": 0.9090909090909091, "length": 20}, "so_28519704_28519731_0": {"section_id": 147, "quality": 0.967741935483871, "length": 30}, "so_28519704_28519731_3": {"section_id": 332, "quality": 1.0, "length": 5}, "so_28519704_28519731_2": {"section_id": 332, "quality": 1.0, "length": 10}, "so_28519704_30252004_1": {"section_id": 151, "quality": 0.9090909090909091, "length": 20}}}, "28519704": {"CommentCount": "3", "ViewCount": "81", "PostTypeId": "1", "LastEditorUserId": "862351", "CreationDate": "2015-02-14T19:59:59.760", "LastActivityDate": "2015-05-15T05:20:38.210", "Title": "Why is the following class template matching not ambiguous?", "AcceptedAnswerId": "30252004", "LastEditDate": "2015-02-14T20:26:43.827", "Id": "28519704", "Score": "0", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\ntemplate &lt;class T&gt; struct is_rvalue_ref      : std::false_type {};\ntemplate &lt;class T&gt; struct is_rvalue_ref&lt;T&amp;&amp;&gt; : std::true_type {};\n\ntemplate &lt;typename T&gt; bool is_rvalue_ref_func(T){return false;}\ntemplate &lt;typename T&gt; bool is_rvalue_ref_func(T&amp;&amp;){return true;}\n\nclass A {};\n\nint main() \n{\n  std::cout &lt;&lt; std::boolalpha;\n  std::cout &lt;&lt; is_rvalue_ref&lt;A&gt;::value &lt;&lt; '\\n';\n  std::cout &lt;&lt; is_rvalue_ref&lt;A&amp;&gt;::value &lt;&lt; '\\n';\n  std::cout &lt;&lt; is_rvalue_ref&lt;A&amp;&amp;&gt;::value &lt;&lt; '\\n';\n\n  /*****THIS FAILS TO COMPILE************\n  A a;\n  A&amp; alv = a;\n  A&amp;&amp; arv = std::move(a);\n  std::cout &lt;&lt; is_rvalue_ref_func(a) &lt;&lt; '\\n';\n  std::cout &lt;&lt; is_rvalue_ref_func(alv) &lt;&lt; '\\n';\n  std::cout &lt;&lt; is_rvalue_ref_func(arv) &lt;&lt; '\\n';\n  **************************************/   \n\n  return 0;\n}\n</code></pre>\n<p>The compiler(<code>clang 3.5 -std=c++11</code>) has no trouble disambiguating the calls to <code>is_rvalue_ref</code> while it balks on the <code>is_rvalue_ref_func</code> overloads with:</p>\n<pre><code>rv.cpp:31:16: error: call to 'is_rvalue_ref_func' is ambiguous\n  std::cout &lt;&lt; is_rvalue_ref_func(a) &lt;&lt; '\\n';\n               ^~~~~~~~~~~~~~~~~~\nrv.cpp:8:6: note: candidate function [with T = A]\nbool is_rvalue_ref_func(T)\n     ^\nrv.cpp:14:6: note: candidate function [with T = A &amp;]\nbool is_rvalue_ref_func(T&amp;&amp;)\n     ^\nrv.cpp:32:16: error: call to 'is_rvalue_ref_func' is ambiguous\n  std::cout &lt;&lt; is_rvalue_ref_func(alv) &lt;&lt; '\\n';\n               ^~~~~~~~~~~~~~~~~~\nrv.cpp:8:6: note: candidate function [with T = A]\nbool is_rvalue_ref_func(T)\n     ^\nrv.cpp:14:6: note: candidate function [with T = A &amp;]\nbool is_rvalue_ref_func(T&amp;&amp;)\n     ^\nrv.cpp:33:16: error: call to 'is_rvalue_ref_func' is ambiguous\n  std::cout &lt;&lt; is_rvalue_ref_func(arv) &lt;&lt; '\\n';\n               ^~~~~~~~~~~~~~~~~~\nrv.cpp:8:6: note: candidate function [with T = A]\nbool is_rvalue_ref_func(T)\n     ^\nrv.cpp:14:6: note: candidate function [with T = A &amp;]\nbool is_rvalue_ref_func(T&amp;&amp;)\n     ^\n3 errors generated.\n</code></pre>\n<p>However, according to <code>14.5.5.2 [temp.class.order]</code></p>\n<blockquote>\n<p id=\"so_28519704_28519704_0\">For two class template partial specializations, the first is at least\n  as specialized as the second if, given the following rewrite to two\n  function templates, the first function template is at least as\n  specialized as the second according to the ordering rules for function\n  templates (14.5.6.2):</p>\n<p id=\"so_28519704_28519704_1\">\u2014 the first function template has the same\n  template parameters as the first partial specialization and has a\n  single function parameter whose type is a class template\n  specialization with the template arguments of the first partial\n  specialization, and </p>\n<p id=\"so_28519704_28519704_2\">\u2014 the second function template has the same\n  template parameters as the second partial specialization and has a\n  single function parameter whose type is a class template\n  specialization with the template arguments of the second partial\n  specialization.</p>\n</blockquote>\n<p>In the above example, the <code>is_rvalue_ref_func</code> overloads are obtained by performing precisely this rewrite of the <code>is_rvalue_ref</code> primary template and partial specialization. Why is the function call ambiguous but the class template matching well-defined?</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "862351", "AnswerCount": "3"}});