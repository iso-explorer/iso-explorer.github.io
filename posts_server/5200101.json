post_cb({"5200101": {"AcceptedAnswerId": "5200285", "OwnerUserId": "141719", "LastActivityDate": "2011-03-05T15:08:17.210", "LastEditorUserId": "141719", "Score": "6", "LastEditDate": "2011-03-05T01:30:28.870", "CommentCount": "10", "Title": "Range-based for loops and ADL", "AnswerCount": "1", "PostTypeId": "1", "Tags": "<c++><foreach><c++11><argument-dependent-lookup>", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">C++0x standard working draft</a> states (section 6.5.4) the following about the begin() and end() calls that are implicit in a range-based for loop:</p>\n<blockquote>\n<p id=\"so_5200101_5200101_0\">'begin' and 'end' are looked up with\n  argument-dependent lookup (3.4.2). For\n  the purposes of this name lookup,\n  namespace std is an associated\n  namespace.</p>\n</blockquote>\n<p>The way I read this, this means that the overload resolution set for the calls to begin() and end() includes all of the following:</p>\n<ul>\n<li>all overloads of begin() and end() that are in scope at the location where the range-based for loop is used (in particular, all overloads in the global namespace will be in scope)</li>\n<li>all overloads of begin() and end() in namespace std</li>\n<li>all overloads of begin() and end() in other namespaces associated with their arguments</li>\n</ul>\n<p>Is that correct?</p>\n<p>g++ 4.6's behaviour does not seem to be consistent with this interpretation. For this code:</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate &lt;typename T, typename U&gt;\nT begin(const std::pair&lt;T, U&gt;&amp; p); \n\ntemplate &lt;typename T, typename U&gt;\nU end(const std::pair&lt;T, U&gt;&amp; p); \n\nint main()\n{\n    std::pair&lt;int*, int*&gt; p;\n    for (int x : p)\n        ;\n}\n</code></pre>\n<p>It gives the following errors:</p>\n<pre><code>adl1.cpp: In function 'int main()':\nadl1.cpp:12:18: error: No match for 'begin(pair&lt;int *, int *&gt; &amp;)'\nadl1.cpp:12:18: candidate is:\n/usr/local/lib/gcc/i686-pc-linux-\n    gnu/4.6.0/../../../../include/c++/4.6.0/initializer_list:86:38: template&lt;\n        class _Tp&gt; constexpr const _Tp * begin(initializer_list&lt;_Tp&gt;)\nadl1.cpp:12:18: error: No match for 'end(pair&lt;int *, int *&gt; &amp;)'\nadl1.cpp:12:18: candidate is:\n/usr/local/lib/gcc/i686-pc-linux-\n    gnu/4.6.0/../../../../include/c++/4.6.0/initializer_list:96:36: template&lt;\n        class _Tp&gt; constexpr const _Tp * end(initializer_list&lt;_Tp&gt;)\n</code></pre>\n<p>This suggests that it is considering <strong>only</strong> the overloads in namespace std, and not the overloads in the global namespace.</p>\n<p>If, however, I use my own pair class declared in the global namespace, it compiles fine:</p>\n<pre><code>template &lt;typename T, typename U&gt;\nstruct my_pair\n{\n    T first;\n    U second;\n};\n\ntemplate &lt;typename T, typename U&gt;\nT begin(const my_pair&lt;T, U&gt;&amp; p); \n\ntemplate &lt;typename T, typename U&gt;\nU end(const my_pair&lt;T, U&gt;&amp; p); \n\nint main()\n{\n    my_pair&lt;int*, int*&gt; p;\n    for (int x : p)\n        ;\n}\n</code></pre>\n<p>As a final test, I tried putting my_pair in a separate namespace:</p>\n<pre><code>namespace my\n{\n\ntemplate &lt;typename T, typename U&gt;\nstruct my_pair\n{\n    T first;\n    U second;\n};\n\n}\n\ntemplate &lt;typename T, typename U&gt;\nT begin(const my::my_pair&lt;T, U&gt;&amp; p); \n\ntemplate &lt;typename T, typename U&gt;\nU end(const my::my_pair&lt;T, U&gt;&amp; p); \n\nint main()\n{\n    my::my_pair&lt;int*, int*&gt; p;\n    for (int x : p)\n        ;\n}\n</code></pre>\n<p>And again I get the errors:</p>\n<pre><code>adl3.cpp: In function 'int main()':\nadl3.cpp:22:18: error: 'begin' was not declared in this scope\nadl3.cpp:22:18: suggested alternative:\nadl3.cpp:14:35:   'begin'\nadl3.cpp:22:18: error: 'end' was not declared in this scope\nadl3.cpp:22:18: suggested alternative:\nadl3.cpp:17:33:   'end'\n</code></pre>\n<p>So it seems it is considering <strong>only</strong> overloads in namespace std and other associated namespaces, and not overloads that are in scope at the call site (the first bullet point in my list above).</p>\n<p>Is this a gcc bug, or am I misinterpreting the standard?</p>\n<p>If the latter, does that mean it's impossible to treat an std::pair object as a range in a range-based for loop (without overloading std::begin() and std::end(), which if I'm not mistaken is not allowed)?</p>\n", "Id": "5200101", "ViewCount": "1567", "CreationDate": "2011-03-04T22:43:39.990"}, "5200285": {"PostTypeId": "2", "ParentId": "5200101", "Body": "<p>I first reported that this looked like a gcc bug to me.  It now appears that even this part of the for-loop specification is unclear, and an inquiry has been opened on the committee.</p>\n<p>It still looks like the range-based for-loop rules are going to change very shortly:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf</a></p>\n<p>And I'm not sure which option listed in N3257 will be chosen.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2011-03-05T15:08:17.210", "LastEditDate": "2011-03-05T15:08:17.210", "CommentCount": "3", "Id": "5200285", "OwnerUserId": "576911", "Score": "4", "CreationDate": "2011-03-04T23:09:46.063"}, "bq_ids": {"n3337": {"so_5200101_5200101_0": {"quality": 0.8571428571428571, "length": 12, "section_id": 3766}}}});