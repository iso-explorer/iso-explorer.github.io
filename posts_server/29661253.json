post_cb({"bq_ids": {"n4140": {"so_29661253_29661678_0": {"length": 29, "quality": 0.7631578947368421, "section_id": 6993}}, "n3337": {"so_29661253_29661678_0": {"length": 29, "quality": 0.7631578947368421, "section_id": 6739}}, "n4659": {"so_29661253_29661678_0": {"length": 29, "quality": 0.7631578947368421, "section_id": 8491}}}, "29661678": {"Id": "29661678", "PostTypeId": "2", "Body": "<p>The original code <strong>shouldn't</strong> compile, gcc is correct here. See [class.member.lookup]:</p>\n<blockquote>\n<p id=\"so_29661253_29661678_0\">Otherwise (i.e., C does not contain a declaration of f or the resulting declaration set is empty), S(f,C) is\n  initially empty. If C has base classes, calculate the lookup set for f in each direct base class subobject Bi,\n  and merge each such lookup set S(f,Bi) in turn into S(f,C).<br>\n  \u2014 [..]<br>\n  \u2014 Otherwise, if the declaration sets of S(f,Bi) and S(f,C) differ, the merge is ambiguous...</br></br></p>\n</blockquote>\n<p>The initial declaration set is empty (<code>overload</code> has no methods) - so merge all the bases, all of whom have differing sets. So the merge <strong>should</strong> fail. That rule only applies if the declaration set of <code>overload</code> is empty though, which is why the explicit adding of the <code>using F1::operator()</code> works. </p>\n", "LastActivityDate": "2015-04-15T21:59:51.407", "CommentCount": "0", "CreationDate": "2015-04-15T21:59:51.407", "ParentId": "29661253", "Score": "9", "OwnerUserId": "2069064"}, "29661253": {"ViewCount": "1386", "Body": "<p>I'm playing with a trick to overload lambdas in C++.  Specifically:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>// For std::function\n#include &lt;functional&gt;\n\n// For std::string\n#include &lt;string&gt;\n\n// For std::cout\n#include &lt;iostream&gt;\n\ntemplate &lt;class... F&gt;\nstruct overload : F... {\n    overload(F... f) : F(f)... {}\n};      \n\ntemplate &lt;class... F&gt;\nauto make_overload(F... f) {\n    return overload&lt;F...&gt;(f...);\n}\n\nint main() {\n\n    std::function &lt;int(int,int)&gt; f = [](int x,int y) {\n        return x+y;\n    };\n    std::function &lt;double(double,double)&gt; g = [](double x,double y) {\n        return x+y;\n    };\n    std::function &lt;std::string(std::string,std::string)&gt; h = [](std::string x,std::string y) {\n        return x+y;\n    };\n\n    auto fgh = make_overload(f,g,h);\n    std::cout &lt;&lt; fgh(1,2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fgh(1.5,2.5) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fgh(\"bob\",\"larry\") &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Now, the above program compiles and works fine in clang:</p>\n<pre><code>$ clang++ -g -std=c++14 test01.cpp -o test01\n$ ./test01\n3\n4\nboblarry\n</code></pre>\n<p>It does not compile in gcc:</p>\n<pre><code>$ g++ -g -std=c++14 test01.cpp -o test01\ntest01.cpp: In function 'int main()':\ntest01.cpp:36:25: error: request for member 'operator()' is ambiguous\n     std::cout &lt;&lt; fgh(1,2) &lt;&lt; std::endl;\n                         ^\nIn file included from test01.cpp:5:0:\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note: candidates are: _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = std::basic_string&lt;char&gt;; _ArgTypes = {std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;}]\n     function&lt;_Res(_ArgTypes...)&gt;::\n     ^\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note:                 _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = double; _ArgTypes = {double, double}]\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note:                 _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = int; _ArgTypes = {int, int}]\ntest01.cpp:37:29: error: request for member 'operator()' is ambiguous\n     std::cout &lt;&lt; fgh(1.5,2.5) &lt;&lt; std::endl;\n                             ^\nIn file included from test01.cpp:5:0:\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note: candidates are: _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = std::basic_string&lt;char&gt;; _ArgTypes = {std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;}]\n     function&lt;_Res(_ArgTypes...)&gt;::\n     ^\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note:                 _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = double; _ArgTypes = {double, double}]\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note:                 _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = int; _ArgTypes = {int, int}]\ntest01.cpp:38:35: error: request for member 'operator()' is ambiguous\n     std::cout &lt;&lt; fgh(\"bob\",\"larry\") &lt;&lt; std::endl;\n                                   ^\nIn file included from test01.cpp:5:0:\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note: candidates are: _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = std::basic_string&lt;char&gt;; _ArgTypes = {std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;}]\n     function&lt;_Res(_ArgTypes...)&gt;::\n     ^\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note:                 _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = double; _ArgTypes = {double, double}]\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.2/include/g++-v4/functional:2434:5: note:                 _Res std::function&lt;_Res(_ArgTypes ...)&gt;::operator()(_ArgTypes ...) const [with _Res = int; _ArgTypes = {int, int}]\nMakefile:2: recipe for target 'all' failed\nmake: *** [all] Error 1\n</code></pre>\n<p>Why is there a difference?  For the record, I'm using gcc 4.9.2 and clang 3.5.0.</p>\n<hr>\n<h1>Edit 1</h1>\n<p>Evidently, this snippet of code failed to compile on VC as well and had already been <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/990223/overloaded-lambda-pattern-fails-to-compile\">reported</a>.  That being said, Sean Middleditch  posted a working version of the overloaded code:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;class F1, class... Fs&gt;\nstruct overload : F1, overload&lt;Fs...&gt;\n{\n    using F1::operator();\n    using overload&lt;Fs...&gt;::operator();\n    overload(F1 f1, Fs... fs) : F1(f1), overload&lt;Fs...&gt;(fs...) {}\n};\n\ntemplate&lt;class F1&gt;\nstruct overload&lt;F1&gt; : F1\n{\n    using F1::operator();\n    overload(F1 f1) : F1(f1) {}\n};\n\n\ntemplate &lt;class... F&gt;\nauto make_overload(F... f) {\n    return overload&lt;F...&gt;(f...);\n}\n</code></pre>\n<p>I'm still interested in understanding why this version of the overloaded lambda code works, but the original one does not.</p>\n</hr>", "AcceptedAnswerId": "29661693", "Title": "Overloaded lambdas in C++ and differences between clang and gcc", "CreationDate": "2015-04-15T21:27:41.233", "Id": "29661253", "CommentCount": "8", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-04-15T22:16:40.920", "LastEditorUserId": "2069064", "LastActivityDate": "2015-04-15T22:16:40.920", "Score": "24", "OwnerUserId": "1932452", "Tags": "<c++><c++11><gcc><clang><overload-resolution>", "AnswerCount": "2"}, "29661693": {"Id": "29661693", "PostTypeId": "2", "Body": "<p>Looks like a Clang bug to me.</p>\n<p>The general rule is that member functions of the same name in different base classes do not overload. For example:</p>\n<pre><code>struct Foo { void bar(); };\nstruct Baz { void bar(int); };\nstruct Quux : Foo, Baz { };\n\nint main() { Quux().bar(); } // error on both GCC and Clang\n</code></pre>\n<p>For whatever reason, Clang fails to diagnose this ambiguity for <code>operator()</code>.</p>\n<p>A <code>using-declaration</code> lifts the named base class members to the derived class scope, allowing them to overload. Hence:</p>\n<pre><code>struct Quux_2 : Foo, Baz { using Foo::bar; using Baz::bar; };\nQuux_2().bar(); // OK.\n</code></pre>\n<p>In the working version of the code, the <code>using</code> declarations recursively bring every <code>operator()</code> declaration in the template arguments into the scope of the most derived class,  allowing them to overload.</p>\n", "LastActivityDate": "2015-04-15T22:00:44.970", "CommentCount": "1", "CreationDate": "2015-04-15T22:00:44.970", "ParentId": "29661253", "Score": "14", "OwnerUserId": "2756719"}});