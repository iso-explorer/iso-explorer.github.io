post_cb({"2643536": {"ParentId": "2643473", "CommentCount": "6", "Body": "<p>Taking into account that <code>a1</code> and <code>a2</code> would compare equal in your example, and what is actually stored in the <code>std::multiset</code> are copies of <code>a1</code> and <code>a2</code>, I don't really know how would you know which is which.</p>\n<p>If you can tell the difference, maybe <code>class A</code> was not well designed in the first place. So <code>std::multiset</code> does not guarantee such a thing.</p>\n", "OwnerUserId": "25824", "PostTypeId": "2", "Id": "2643536", "Score": "3", "CreationDate": "2010-04-15T07:51:50.543", "LastActivityDate": "2010-04-15T07:51:50.543"}, "2643599": {"ParentId": "2643473", "CommentCount": "4", "Body": "<p>In C++03 you are not guaranteed that <code>insert</code> and <code>erase</code> preserve <em>relative ordering</em>. However, this is changed in C++0x:</p>\n<blockquote>\n<p id=\"so_2643473_2643599_0\">n3092, \u00a723.2.4/4: An associative container supports unique keys if it may contain at most one element for each key. Otherwise, it supports equivalent keys. The set and map classes support unique keys; the multiset and multimap classes support equivalent keys. <strong>For multiset and multimap, insert and erase preserve the relative ordering of equivalent elements.</strong> <sub>Emphasis mine.</sub></p>\n</blockquote>\n<p>This is discussed in this <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#233\" rel=\"noreferrer\">defect report</a>. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1780.html\" rel=\"noreferrer\">This page</a> is the collection of comments on the issue, it's well-written and quite fleshed-out. (I very much recommend reading this one over the previous \"overview\" link.)</p>\n<p>From that comment page you'll find a comparison of current implementations, so you can check if the implementations you intend to use follow what you expect.</p>\n<p>I can't think of a way to force the ordering you want off the top of my head. :/</p>\n", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "2643599", "Score": "21", "CreationDate": "2010-04-15T08:01:26.410", "LastActivityDate": "2010-04-15T08:01:26.410"}, "2643473": {"CommentCount": "0", "AcceptedAnswerId": "2643599", "PostTypeId": "1", "LastEditorUserId": "87234", "CreationDate": "2010-04-15T07:40:52.713", "LastActivityDate": "2010-04-15T08:12:00.533", "LastEditDate": "2010-04-15T08:02:11.930", "ViewCount": "2753", "FavoriteCount": "3", "Title": "Does std::multiset guarantee insertion order?", "Id": "2643473", "Score": "11", "Body": "<p>I have a <code>std::multiset</code> which stores elements of <code>class A</code>. I have provided my own implementation of <code>operator&lt;</code> for this class. My question is if I insert two equivalent objects into this multiset is their order guaranteed? For example, first I insert a object <code>a1</code> into the set and then I insert an equivalent object <code>a2</code> into this set. Can I expect the <code>a1</code> to come before <code>a2</code> when I iterate through the set? If no, is there any way to achieve this using multiset?</p>\n", "Tags": "<c++><stl><data-structures><standard-library>", "OwnerUserId": "39742", "AnswerCount": "3"}, "2643660": {"ParentId": "2643473", "CommentCount": "0", "Body": "<p>std::multimap does not guarante this.\nIf you can express your <code>operator&lt;</code> using an integer via a function e.g. <code>int A::orderingInt()</code>, you could use a </p>\n<pre><code>std::multiset&lt;MyCustom&gt; myset;\n</code></pre>\n<p>with</p>\n<pre><code>class MyCustom : public std::vector&lt;A&gt; {}\n</code></pre>\n<p>with overloaded</p>\n<pre><code>bool operator&lt;(const MyCustom&amp; a, const MyCustom&amp; b) {\n   // theoretically empty MyCustom should not occure\n   return a[0].orderingInt() &lt; b[0].orderingInt();\n}\n</code></pre>\n<p>Of course adding and iteration would be different now:</p>\n<pre><code>A a;\nmyset[a.orderingInt()].push_back(a);\n\n// groups with \"small\" elements first\nfor(std::multiset&lt;MyCustom&gt;::iterator it=myset.begin(); it!=myset.end(); it++) {\n    // those elements are \"equal\"\n    for(std::vector&lt;A&gt;::iterator jt=it-&gt;begin(); jt-&gt;end(); jt++) { \n         // use A&amp; a = *jt;\n    }\n}\n</code></pre>\n", "OwnerUserId": "316448", "PostTypeId": "2", "Id": "2643660", "Score": "1", "CreationDate": "2010-04-15T08:12:00.533", "LastActivityDate": "2010-04-15T08:12:00.533"}, "bq_ids": {"n4140": {"so_2643473_2643599_0": {"section_id": 740, "quality": 0.813953488372093, "length": 35}}, "n3337": {"so_2643473_2643599_0": {"section_id": 729, "quality": 0.813953488372093, "length": 35}}, "n4659": {"so_2643473_2643599_0": {"section_id": 798, "quality": 0.813953488372093, "length": 35}}}});