post_cb({"3097889": {"ParentId": "3097806", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-06-22T23:27:57.797", "Score": "3", "LastEditorUserId": "252000", "LastEditDate": "2010-06-23T00:27:48.197", "Id": "3097889", "OwnerUserId": "252000", "Body": "<blockquote>\n<p id=\"so_3097806_3097889_0\">It prints 10 every time.</p>\n</blockquote>\n<p>Modify the main function a little and it won't print 10 anymore:</p>\n<pre><code>int main()\n{\n    B* p = f();\n    cout &lt;&lt; \"C++\\n\";   // prints C++\n    p-&gt;b();            // prints 4077568\n}\n</code></pre>\n<blockquote>\n<p id=\"so_3097806_3097889_1\">how does this link gets established at what level?</p>\n</blockquote>\n<p>See 12.2 [class.temporary] \u00a74 and \u00a75:</p>\n<blockquote>\n<p id=\"so_3097806_3097889_2\">Temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created.</p>\n<p id=\"so_3097806_3097889_3\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression.\n  The first context is [...]</p>\n<p id=\"so_3097806_3097889_4\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except: [...]</p>\n<p id=\"so_3097806_3097889_5\">A temporary bound to a reference parameter in a function call persists until the completion of the full-expression containing the call.</p>\n</blockquote>\n<p>So in your case, the temporary is destroyed after the evaluation of the full-expression <code>new B(A(10))</code>.</p>\n", "LastActivityDate": "2010-06-23T00:27:48.197"}, "3097877": {"ParentId": "3097806", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-06-22T23:26:18.370", "Score": "3", "LastEditorUserId": "252000", "LastEditDate": "2010-06-23T00:27:31.427", "Id": "3097877", "OwnerUserId": "1527", "Body": "<p>You just got lucky. Changing B::b to this:</p>\n<pre><code>void b() {\n    int i = rand();\n    int j = rand();\n    cout &lt;&lt; _a &lt;&lt; endl;\n}\n</code></pre>\n<p>prints out random numbers.</p>\n", "LastActivityDate": "2010-06-23T00:27:31.427"}, "3097806": {"CommentCount": "0", "AcceptedAnswerId": "3097861", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-06-22T23:11:14.813", "LastActivityDate": "2010-06-23T00:27:48.197", "LastEditDate": "2017-05-23T11:54:28.257", "ViewCount": "1543", "FavoriteCount": "3", "Title": "const reference to temporary oddity", "Id": "3097806", "Score": "7", "Body": "<p>We all know that things like this are valid in c++:</p>\n<pre><code>const T &amp;x = T();\n</code></pre>\n<p>while:</p>\n<pre><code>T &amp;x = T();\n</code></pre>\n<p>is not.</p>\n<p>In <a href=\"https://stackoverflow.com/questions/3097593/what-happens-when-c-reference-leaves-its-scope/\">a recent question</a> the conversation lead to this rule. The OP had posted some code which clearly evokes UB. But I would have expect a modified version of it to work (This is the modified version):</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    A(int k) { _k = k; };\n    int get() const { return _k; };\n    int _k;\n};\n\nclass B {\npublic:\n    B(const A&amp; a) : _a(a) {}\n    void b() { cout &lt;&lt; _a.get(); }\n    const A&amp; _a;\n};\n\nB* f() {\n    return new B(A(10));\n}\n\nint main() {\n    f()-&gt;b();\n}\n</code></pre>\n<p>This prints garbage on some machines, 10 on others... sounds like UB to me :-). But then I thought, well <code>A</code> is basically a glorified <code>int</code> all it does it initialize one and read it. Why not just call <code>A</code> an <code>int</code> and see what happens:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntypedef int A;\n\nclass B {\npublic:\n    B(const A&amp; a) : _a(a) {}\n    void b() { cout &lt;&lt; _a; }\n    const A&amp; _a;\n};\n\nB* f() {\n    return new B(A(10));\n}\n\nint main() {\n    f()-&gt;b();\n}\n</code></pre>\n<p>It prints <code>10</code> every time. It at least <strong>seems</strong> like the const reference rule is in effect for the <code>int</code> version, but not for the class version. Are they both simply UB due to the use of the heap? Am I just lucky with the <code>int</code> version because the compile saw through all <code>const</code>s and just directly printed out a <code>10</code>? Which aspect of the rule am I missing?</p>\n", "Tags": "<c++><reference><const><temporary>", "OwnerUserId": "13430", "AnswerCount": "3"}, "3097861": {"ParentId": "3097806", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2010-06-22T23:23:36.350", "Score": "15", "LastEditorUserId": "187690", "LastEditDate": "2010-06-22T23:37:19.547", "Id": "3097861", "OwnerUserId": "187690", "Body": "<p>It simply demonstrates that analyzing language behavior by \"trying it in the compiler\" doesn't normally produce any useful results. Both of your examples are invalid for the very same reason.</p>\n<p>The lifetime of the temporary is only extended when you use that temporary as the direct initializer for a const reference - only that will establish a \"lifetime\" link between the reference and the temporary.</p>\n<p>Trying to pass a temporary as a constructor's argument and attaching a const reference inside the constructor will not establish the aforementioned link and will not extend the lifetime of the temporary.</p>\n<p>Also, in accordance with C++ standard, if you do this</p>\n<pre><code>struct S {\n  const int &amp;r;\n\n  S() : r(5) {\n    cout &lt;&lt; r; // OK\n  }\n};\n</code></pre>\n<p>the lifetime of the temporary is only extended to the end of the constructor. Once the constructor is finished, the temporary dies, meaning that this</p>\n<pre><code>S s;\ncout &lt;&lt; s.r; // Invalid\n</code></pre>\n<p>is invalid.</p>\n<p>Your experiment with <code>int</code> simply \"appears to work\", purely by accident.</p>\n", "LastActivityDate": "2010-06-22T23:37:19.547"}, "bq_ids": {"n4140": {"so_3097806_3097889_2": {"section_id": 380, "quality": 1.0, "length": 14}, "so_3097806_3097889_4": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_3097806_3097889_3": {"section_id": 381, "quality": 0.9230769230769231, "length": 12}, "so_3097806_3097889_5": {"section_id": 382, "quality": 1.0, "length": 12}}, "n3337": {"so_3097806_3097889_2": {"section_id": 371, "quality": 1.0, "length": 14}, "so_3097806_3097889_4": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_3097806_3097889_3": {"section_id": 372, "quality": 0.9230769230769231, "length": 12}, "so_3097806_3097889_5": {"section_id": 373, "quality": 1.0, "length": 12}}, "n4659": {"so_3097806_3097889_2": {"section_id": 395, "quality": 1.0, "length": 14}, "so_3097806_3097889_4": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_3097806_3097889_3": {"section_id": 396, "quality": 0.8461538461538461, "length": 11}, "so_3097806_3097889_5": {"section_id": 397, "quality": 1.0, "length": 12}}}});