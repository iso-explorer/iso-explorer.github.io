post_cb({"bq_ids": {"n4140": {"so_41581225_41581251_0": {"length": 20, "quality": 1.0, "section_id": 7109}}, "n3337": {"so_41581225_41581251_0": {"length": 20, "quality": 1.0, "section_id": 6853}}, "n4659": {"so_41581225_41581251_0": {"length": 20, "quality": 1.0, "section_id": 8610}}}, "41581225": {"ViewCount": "144", "Body": "<p>In the following example:</p>\n<pre><code>class A\n{\npublic:\n    class B\n    {\n        ...\n    }\n    B Method(B argument);\n}\n\nA::B A::Method(B argument);\n</code></pre>\n<p>Why exactly is the scope required for return type, while not for argument type?</p>\n", "AcceptedAnswerId": "41581251", "Title": "Returning member class in C++", "CreationDate": "2017-01-11T01:15:46.993", "Id": "41581225", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-01-11T01:19:26.063", "Score": "7", "OwnerUserId": "7302586", "Tags": "<c++><types>", "AnswerCount": "1"}, "41581251": {"Id": "41581251", "PostTypeId": "2", "Body": "<p>According to [basic.lookup.qual]/3,</p>\n<blockquote>\n<p id=\"so_41581225_41581251_0\">In a declaration in which the <em>declarator-id</em> is a <em>qualified-id</em>, names used before the <em>qualified-id</em> being declared\n  are looked up in the defining namespace scope; names following the <em>qualified-id</em> are looked up in the scope\n  of the member\u2019s class or namespace.</p>\n</blockquote>\n<p>The return type comes before the <em>qualified-id</em> being declared (that is, <code>A::Method</code>) whereas the parameter type comes after it, so the parameter type's name is automatically looked up in the scope of <code>A</code>, while the return type's name is not. We can avoid the extra qualification using a trailing return type.</p>\n<pre><code>auto A::Method(B argument) -&gt; B;\n</code></pre>\n", "LastActivityDate": "2017-01-11T01:19:26.063", "CommentCount": "3", "CreationDate": "2017-01-11T01:19:26.063", "ParentId": "41581225", "Score": "8", "OwnerUserId": "481267"}});