post_cb({"44640873": {"Id": "44640873", "PostTypeId": "2", "Body": "<p>The requirement that there be exactly one sign bit means that it must be possible to identify a bit which is set for all negative numbers, and clear for all non-negative numbers.  An implementation may include within an \"int\" any number of padding bits, impose arbitrary restrictions on their values, and treat as trap representations any bit patterns that violate those requirements, provided that all calculations that yield defined integer values produce bit patterns that the implementation will accept.</p>\n<p>For example, an implementation could store \"int\" as two 16-bit words and specifies that the MSB of of the first word is the sign bit.  Such an implementation could write 0-14 of the first word match the sign bit and\ntrap when reading any value where they don't, or make those bits match bits\n1-15 of the second word (likewise trapping), or could write arbitrary values\nto those bits and ignore them when reading, or do just about anything else\nwith them.  If an implementation always wrote the top word as all ones or\nall zero, any bit could be designated the \"sign bit\" and it wouldn't matter;\nthe rest would all be \"padding bits\".</p>\n<p>The requirement that there be a single sign bit would mainly rule out\nimplementations where e.g. positive numbers may arbitrarily be represented\nas bit pattern 00 or 11, and negative numbers as 01 or 10.  On such an\nimplementation, it would be necessary to examine two bits rather than one\nto determine whether a number was negative or non-negative.</p>\n", "LastActivityDate": "2017-06-19T22:25:04.490", "CommentCount": "0", "CreationDate": "2017-06-19T22:25:04.490", "ParentId": "34862241", "Score": "0", "OwnerUserId": "363751"}, "34863695": {"Id": "34863695", "PostTypeId": "2", "Body": "<p>This is what C++11 says about representation of signed integer types:</p>\n<p>C++11 N3337 3.9.1 [basic.fundamental] P7:</p>\n<blockquote>\n<p id=\"so_34862241_34863695_0\">The representations of integral types\n  shall define values by use of a pure binary numeration system. 49 [ Example: this International Standard permits 2\u2019s complement, 1\u2019s complement and signed magnitude representations for integral types. \u2014 end\n  example ]</p>\n</blockquote>\n<p>where Footnote 49 reads:</p>\n<blockquote>\n<p id=\"so_34862241_34863695_1\">49) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest\n  position. (Adapted from the American National Dictionary for Information Processing Systems.)</p>\n</blockquote>\n<p>Thus C++ allows the same three options as C, as well as anything else satisfying Footnote 49. Which is a superset of what C allows. By Footnote 49, however, only the highest bit is allowed to have special meaning.</p>\n", "LastEditorUserId": "4451432", "LastActivityDate": "2016-01-19T08:56:16.237", "Score": "4", "CreationDate": "2016-01-18T20:41:02.597", "ParentId": "34862241", "CommentCount": "3", "OwnerUserId": "4451432", "LastEditDate": "2016-01-19T08:56:16.237"}, "34862827": {"Id": "34862827", "PostTypeId": "2", "Body": "<p>The C++ Standard is based in particularly on the C Standard where there is written (6.2.6.2 Integer types)</p>\n<blockquote>\n<p id=\"so_34862241_34862827_0\">2 For signed integer types, the bits of the object representation\n  shall be divided into three groups: value bits, padding bits, and the\n  sign bit. There need not be any padding bits; signed char shall not\n  have any padding bits. <strong>There shall be exactly one sign bit</strong>.....</p>\n</blockquote>\n", "LastActivityDate": "2016-01-18T19:45:03.637", "CommentCount": "2", "CreationDate": "2016-01-18T19:45:03.637", "ParentId": "34862241", "Score": "2", "OwnerUserId": "2877241"}, "bq_ids": {"n4140": {"so_34862241_34863695_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 7216}, "so_34862241_34863695_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 7216}}, "n3337": {"so_34862241_34863695_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 6960}, "so_34862241_34863695_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 6960}}, "n4659": {"so_34862241_34863695_0": {"length": 19, "quality": 0.7916666666666666, "section_id": 8725}, "so_34862241_34863695_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 8725}}}, "34862463": {"Id": "34862463", "PostTypeId": "2", "Body": "<p>I'm guessing the answer to the question you asked is no.</p>\n<p>I think the C++ Standard specifies the minimum size, and the <em>range of values</em> that each integer type must be able to represent. I don't believe the standard speaks specifically to any of the constraints you list.</p>\n<p>I think those are all implementation details.</p>\n<p>I think it would be odd to find a C++ implementation that used more than a single bit to hold the sign, and not use a 0 for positive and 1 for negative. But I don't think the C++ Standard specifically requires it.</p>\n", "LastActivityDate": "2016-01-18T19:23:41.277", "CommentCount": "2", "CreationDate": "2016-01-18T19:23:41.277", "ParentId": "34862241", "Score": "3", "OwnerUserId": "107744"}, "34862241": {"ViewCount": "473", "Body": "<p>Consider the fundamental signed integer types of C++, namely: <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code> and <code>long long int</code>, what does the current C++ standard require about their underlying bit representation?</p>\n<p>Does the constraints on their bit representation specify that they should include:</p>\n<ul>\n<li>optional padding bits</li>\n<li>mandatory value bits</li>\n<li>a mandatory sign bit that is <code>0</code> for positive values, and <code>1</code> for negative value</li>\n<li>if it exists, the sign bit should be the most significant bit </li>\n</ul>\n<p>Is this true? If not, then what are the constaints? I am searching for quotes from the standard that proves or disproves this.</p>\n<p><strong>EDIT:</strong> I am asking this question, because, in C, the standard says:</p>\n<blockquote>\n<p id=\"so_34862241_34862241_0\"><em>6.2.6.2.2:</em></p>\n<p id=\"so_34862241_34862241_1\">For signed integer types, the bits of the object representation shall\n  be divided into three groups: value bits, padding bits, and the sign\n  bit. There need not be any padding bits; signed char shall not have\n  any padding bits. There shall be exactly one sign bit. Each bit that\n  is a value bit shall have the same value as the same bit in the object\n  representation of the corresponding unsigned type (if there are M\n  value bits in the signed type and N in the unsigned type, then M \u2264 N\n  ). If the sign bit is zero, it shall not affect the resulting value.\n  If the sign bit is one, the value shall be modified in one of the\n  following ways: </p>\n<ul>\n<li>the corresponding value with sign bit 0 is negated (sign and magnitude); </li>\n<li>the sign bit has the value \u2212(2^M ) (two\u2019s complement); </li>\n<li>the sign bit has the value \u2212(2^M \u2212 1) (ones\u2019complement).</li>\n</ul>\n<p id=\"so_34862241_34862241_2\">Which of these applies is implementation-defined, as is\n  whether the value with sign bit 1 and all value bits zero (for the\n  first two), or with sign bit and all value bits 1 (for ones\u2019\n  complement), is a trap representation or a normal value. In the case\n  of sign and magnitude and ones\u2019 complement, if this representation is\n  a normal value it is called a negative zero.</p>\n</blockquote>\n<p>So I am wondering whether something comparable exists in C++</p>\n", "AcceptedAnswerId": "34863695", "Title": "Does the C++ standard requires signed integers to have exactly one sign bit?", "CreationDate": "2016-01-18T19:09:29.287", "Id": "34862241", "CommentCount": "5", "LastEditDate": "2016-01-18T19:59:25.160", "PostTypeId": "1", "LastEditorUserId": "882932", "LastActivityDate": "2017-06-19T22:25:04.490", "Score": "1", "OwnerUserId": "882932", "Tags": "<c++><c++11><integer><standards><language-lawyer>", "AnswerCount": "4"}});