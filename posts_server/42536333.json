post_cb({"42536333": {"CommentCount": "3", "ViewCount": "37", "CreationDate": "2017-03-01T15:56:53.850", "LastActivityDate": "2017-03-01T16:02:20.967", "Title": "Ambiguous/rvalue arguments cause compiler to choose incorrect overload", "AcceptedAnswerId": "42536449", "PostTypeId": "1", "Id": "42536333", "Score": "-4", "Body": "<p>I have a home grown template class called <code>Vec</code> which is a pale shadow of: <code>std::vector&lt;T&gt;</code> </p>\n<p>To avoid re-inventing the wheel the header overloads for <code>assign</code> are copied from: <code>std::vector::assign</code></p>\n<p><a href=\"https://i.stack.imgur.com/cpkLT.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/cpkLT.jpg\"/></a></p>\n<p>..so</p>\n<p><a href=\"https://i.stack.imgur.com/a5Gcp.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/a5Gcp.jpg\"/></a></p>\n<p>As part of testing <code>Str</code> class, ..test code is also run against <code>std::vector&lt;T&gt;</code> to ensure equivalent output... </p>\n<p>If <code>std::vector&lt;T&gt;</code> is used then compiler will choose the correct overload:</p>\n<p><a href=\"https://i.stack.imgur.com/JVUU6.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/JVUU6.jpg\"/></a></p>\n<p>However, when <code>Vec&lt;T&gt;</code> is used then compiler insists on choosing the incorrect overload:</p>\n<p><a href=\"https://i.stack.imgur.com/6OFwm.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/6OFwm.jpg\"/></a></p>\n<p>There is an obvious work around via casting the args to lvalues prior to use:</p>\n<p><a href=\"https://i.stack.imgur.com/qOgEg.jpg\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/qOgEg.jpg\"/></a></p>\n<p>Question:\nGiven that both <code>Vec&lt;T&gt;</code> and <code>std::vector&lt;T&gt;</code> use identical header overloads for their respective <code>assign</code> ...how is <code>std::vector&lt;T&gt;</code> able to implement rvalues arg without confusing the compiler?</p>\n", "Tags": "<c++><function-overloading><rvalue><ambiguous>", "OwnerUserId": "668180", "AnswerCount": "1"}, "42536449": {"ParentId": "42536333", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_42536333_42536449_0\"><strong>[sequence.reqmts]/14</strong> For every sequence container defined in this Clause and in Clause 21:</p>\n<p id=\"so_42536333_42536449_1\">(14.2) \u2014 If the member functions of the forms:</p>\n<pre><code>template &lt;class InputIterator&gt; // such as insert()\nrt fx1(const_iterator p, InputIterator first, InputIterator last);\ntemplate &lt;class InputIterator&gt; // such as append(), assign()\nrt fx2(InputIterator first, InputIterator last);\ntemplate &lt;class InputIterator&gt; // such as replace()\nrt fx3(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last);\n</code></pre>\n<p id=\"so_42536333_42536449_2\">are called with a type <code>InputIterator</code> that does not qualify as an input iterator, then these functions shall not participate in overload resolution.</p>\n</blockquote>\n<p>This is typically implemented with a touch of SFINAE. You can check the headers of your favorite standard library implementation for details.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "42536449", "Score": "3", "CreationDate": "2017-03-01T16:02:20.967", "LastActivityDate": "2017-03-01T16:02:20.967"}, "bq_ids": {"n4140": {"so_42536333_42536449_2": {"section_id": 733, "quality": 1.0, "length": 12}, "so_42536333_42536449_0": {"section_id": 733, "quality": 0.75, "length": 6}}, "n3337": {"so_42536333_42536449_2": {"section_id": 722, "quality": 1.0, "length": 12}, "so_42536333_42536449_0": {"section_id": 722, "quality": 0.75, "length": 6}}, "n4659": {"so_42536333_42536449_2": {"section_id": 763, "quality": 1.0, "length": 12}, "so_42536333_42536449_0": {"section_id": 763, "quality": 0.75, "length": 6}}}});