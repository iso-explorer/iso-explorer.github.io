post_cb({"179786": {"Id": "179786", "PostTypeId": "2", "Body": "<p>Re &lt;&gt; vs \"\".  At my shop, I'm very hands-off as far as matters of \"style\" are concerned.  One of the few areas where I have a requirement is with the use of angle brackets in #include statements -- the rule is this:  if you are #including an operating system or compiler file, you may use angle brackets if appropriate.  In all other cases, they are forbidden.  If you are #including a file written either by someone here or a 3rd party library, &lt;&gt; is forbidden.</p>\n<p>The reason is this:  #include \"x.h\" and #include  don't search the same paths.  #include  will only search the system path and whatever you have -i'ed in.  Importantly, it will not search the path where the file x.h is located, if that directory isn't included in the search path in some other way.</p>\n<p>For example, suppose you have the following files:</p>\n<p>c:\\dev\\angles\\main.cpp</p>\n<pre><code>#include \"c:\\utils\\mylib\\mylibrary.h\"\n\nint main()\n{\n    return 0;\n}\n</code></pre>\n<p>c:\\utils\\mylib\\mylibrary.h</p>\n<pre><code>#ifndef MYLIB_H\n#define MYLIB_H\n\n#include &lt;speech.h&gt;\n\nnamespace mylib\n{\n    void Speak(SpeechType speechType);  \n};\n\n#endif\n</code></pre>\n<p>c:\\utils\\mhlib\\speech.h</p>\n<pre><code>#ifndef SPEECH_H\n#define SPEECH_H\n\nnamespace mylib\n{\n    enum SpeechType {Bark, Growl};\n};\n\n#endif\n</code></pre>\n<p>This will not compile without changing the path either by setting the PATH environment variable or -i'ing in the c:\\utils\\mhlib\\ directory.  The compiler won't be able to resove <code>#include &lt;speech.h&gt;</code> even though that file is in the same directory as <code>mylibrary.h</code>!</p>\n<p>We make extensive use of relative and absolute pathnames in #include statements in our code, for two reasons.</p>\n<p>1) By keeping libraries and components off the main source tree (ie, putting utility libraries in a special directory), we don;t couple the lifecycle of the library to the lifecycle of the application.  This is particularly important when you have several distinct products that use common libraries.</p>\n<p>2) We use <a href=\"http://technet.microsoft.com/en-us/sysinternals/bb896768.aspx\" rel=\"nofollow noreferrer\">Junctions</a> to map a physical location on the hard drive to a directory on a logical drive, and then use a fully-qualified path on the logical drive in all #includes.  For example:</p>\n<p><code>#include \"x:\\utils\\mylib.h\"</code> -- good, x: is a subst'ed drive, and x:\\utils points to c:\\code\\utils_1.0 on the hard drive</p>\n<p><code>#include \"c:\\utils_1.0\\mylib.h\"</code> -- bad!  the application tha t#includes mylib.h is now coupled to a specific version of the MYLIB library, and all developers must have it on the same directory on thier hard drive, c:\\utils_1.0</p>\n<p>Finally, a broad but difficult to achieve goal of my team is to be able to support 1-click compiles.  This includes being able to compile the main source tree by doing nothing more than getting code from source control and then hitting 'compile'.  In particular, I abhor having to set paths &amp; machine-wide #include directories in order to be able to compile, because every little additional step you add to the set-up phase in buildign a development machine just makes it harder, easier to mess up, and it takes longer to get a new machine up to speed &amp; generating code.</p>\n", "LastActivityDate": "2008-10-07T18:38:08.163", "CommentCount": "0", "CreationDate": "2008-10-07T18:38:08.163", "ParentId": "179213", "Score": "1", "OwnerUserId": "241536"}, "179249": {"Id": "179249", "PostTypeId": "2", "Body": "<p>I use &lt;...&gt; from system header file (stdio, iostreams, string etc), and \"...\" for headers specific to that project.  </p>\n", "OwnerDisplayName": "James Curran", "LastActivityDate": "2008-10-07T16:15:29.993", "Score": "0", "CreationDate": "2008-10-07T16:15:29.993", "ParentId": "179213", "CommentCount": "1", "OwnerUserId": "12725"}, "179436": {"Id": "179436", "PostTypeId": "2", "Body": "<p>To quote from the C99 standard (at a glance the wording appears to be identical in the C90 standard, but I can't cut-n-paste from that):</p>\n<blockquote>\n<p id=\"so_179213_179436_0\">A preprocessing directive of the form</p>\n<p id=\"so_179213_179436_1\"><code># include \"q-char-sequence\" new-line</code></p>\n<p id=\"so_179213_179436_2\">causes the replacement of that\n  directive by the entire contents of\n  the source file identified by the\n  specified sequence between the \"\n  delimiters. The named source file is\n  searched for in an\n  implementation-defined manner. If this\n  search is not supported, or if the\n  search fails, the directive is\n  reprocessed as if it read</p>\n<p id=\"so_179213_179436_3\"><code># include &lt;h-char-sequence&gt; new-line</code></p>\n<p id=\"so_179213_179436_4\">with the identical contained sequence\n  (including &gt; characters, if any) from\n  the original directive.</p>\n</blockquote>\n<p>So the locations searched by <code>#include \"whatever\"</code> is a super-set of the locations searched by <code>#include &lt;whatever&gt;</code>.  The intent is that the first style would be used for headers that in general \"belong\" to you, and the second method would be used for headers that \"belong\" to the compiler/environment.  Of course, there are often some grey areas - which should you use for Boost headers, for example?  I'd use <code>#include &lt;&gt;</code>, but I wouldn't argue too much if someone else on my team wanted <code>#include \"\"</code>.  </p>\n<p>In practice, I don't think anyone pays much attention to which form is used as long as the build doesn't break.  I certainly don't recall it ever being mentioned in a code review (or otherwise, even).</p>\n", "OwnerDisplayName": "Mike B", "LastActivityDate": "2008-10-07T17:01:56.670", "Score": "4", "CreationDate": "2008-10-07T17:01:56.670", "ParentId": "179213", "CommentCount": "1", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_179213_179436_4": {"length": 7, "quality": 1.0, "section_id": 505}, "so_179213_1251308_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 504}, "so_179213_179436_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 505}, "so_179213_1251308_4": {"length": 7, "quality": 1.0, "section_id": 505}, "so_179213_1251308_3": {"length": 24, "quality": 0.9230769230769231, "section_id": 505}}, "n3337": {"so_179213_179436_4": {"length": 7, "quality": 1.0, "section_id": 496}, "so_179213_1251308_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 495}, "so_179213_179436_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 496}, "so_179213_1251308_4": {"length": 7, "quality": 1.0, "section_id": 496}, "so_179213_1251308_3": {"length": 24, "quality": 0.9230769230769231, "section_id": 496}}, "n4659": {"so_179213_179436_4": {"length": 7, "quality": 1.0, "section_id": 526}, "so_179213_1251308_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 525}, "so_179213_179436_2": {"length": 24, "quality": 0.9230769230769231, "section_id": 526}, "so_179213_1251308_4": {"length": 7, "quality": 1.0, "section_id": 526}, "so_179213_1251308_3": {"length": 24, "quality": 0.9230769230769231, "section_id": 526}}}, "179261": {"Body": "<p>There are two primary differences between <code>&lt;&gt;</code> and <code>\"\"</code>. The first is which character will end the name - there are no escape sequences in header names, and so you may be forced to do <code>#include &lt;bla\"file.cpp&gt;</code> or <code>\"bla&gt;file.cpp\"</code>. That probably won't come up often, though. The other difference is that system includes aren't supposed to occur on <code>\"\"</code>, just <code>&lt;&gt;</code>. So <code>#include \"iostream\"</code> is not guaranteed to work; <code>#include &lt;iostream&gt;</code> is. My personal preference is to use <code>\"\"</code> for files that are part of the project, and <code>&lt;&gt;</code> for files that aren't. Some people only use <code>&lt;&gt;</code> for standard library headers and <code>\"\"</code> for all else. Some people even use <code>&lt;&gt;</code> only for Boost and std; it depends on the project. Like all style aspects, the most important thing is to be consistent.</p>\n<p>As for the path, an external library will specify the convention for headers; e.g. <code>&lt;boost/preprocessor.hpp&gt;</code> <code>&lt;wx/window.h&gt;</code> <code>&lt;Magic++.h&gt;</code>. In a local project, I would write all paths relative to the top-level srcdir (or in a library project where they are different, the include directory).</p>\n<p>When writing a library, you may also find it helpful to use &lt;&gt; to differentiate between private and public headers, or to not <code>-I</code> the source directory, but the directory above, so you <code>#include \"public_header.hpp\"</code> and <code>\"src/private_header.hpp\"</code>. It's really up to you.</p>\n<p>EDIT: As for projects with directory structures, I would highly recommend them. Imagine if all of boost were in one directory (and no subnamespaces)! Directory structure is good because it lets you find files easier, and it allows you more flexibility in naming (<code>\"module\\_text\\_processor.hpp\"</code> as opposed to <code>\"module/text\\_processor.hpp\"</code>). The latter is more natural and easier to use.</p>\n", "CreationDate": "2008-10-07T16:17:14.360", "ParentId": "179213", "CommentCount": "0", "LastEditDate": "2016-03-27T18:42:51.720", "PostTypeId": "2", "OwnerDisplayName": "coppro", "LastEditorUserId": "96963", "LastActivityDate": "2016-03-27T18:42:51.720", "Id": "179261", "Score": "1", "OwnerUserId": "16855"}, "179554": {"Id": "179554", "PostTypeId": "2", "Body": "<p>We use #include \"header.h\" for headers local to the project and #include  for system includes, third party includes, and other projects in the solution. We use Visual Studio, and it's much easier to use the project directory in a header include, this way whenever we create a new project, we only have to specify the include path for the directory containing all the project directories, not a separate path for each project.</p>\n", "OwnerDisplayName": "Brian Stewart", "LastActivityDate": "2008-10-07T17:39:10.293", "Score": "0", "CreationDate": "2008-10-07T17:39:10.293", "ParentId": "179213", "CommentCount": "0", "OwnerUserId": "3114"}, "179248": {"Body": "<p>I typically use &lt;&gt; for system headers and \"\" for project headers. As for paths, that is only neccessary if the file you want is in a sub-directory of an include path.</p>\n<p>for example, if you need a file in /usr/include/SDL/, but only /usr/include/ is in your include path, then you could just use:</p>\n<pre><code>#include &lt;SDL/whatever.h&gt;\n</code></pre>\n<p>Also, keep in mind that unless the path you put starts with a /, it is relative to the current working directory.</p>\n<p>EDIT TO ANSWER COMMENT: It depends, if there is only a few includes for a library, I'd just include it's subdirectory in the include path, but if the library has many headers (like dozens) then I'd prefer to just have it in a subdir that I specify. A good example of this is Linux's system headers. You use them like:</p>\n<pre><code>#include &lt;sys/io.h&gt;\n#include &lt;linux/limits.h&gt;\n</code></pre>\n<p>etc.</p>\n<p>EDIT TO INCLUDE ANOTHER GOOD ANSWER: also, if it is conceivable that two or more libraries provide headers by the same name, then the sub-directory solution basically gives each header a namespace.</p>\n", "CreationDate": "2008-10-07T16:15:20.680", "ParentId": "179213", "CommentCount": "7", "LastEditDate": "2008-10-07T16:21:33.227", "PostTypeId": "2", "LastEditorDisplayName": "Evan Teran", "LastActivityDate": "2008-10-07T16:21:33.210", "LastEditorUserId": "13430", "Id": "179248", "OwnerDisplayName": "Evan Teran", "Score": "7", "OwnerUserId": "13430"}, "179631": {"Id": "179631", "PostTypeId": "2", "Body": "<p>1.a: What are the differences between the two notations?</p>\n<p>\"\" starts search in the directory where C/C++ file is located. &lt;&gt; starts search in -I directories and in default locations (such as /usr/include). Both of them ultimately search the same set of locations, only the order is different.</p>\n<p>1.b: Do all compilers implement them the same way?</p>\n<p>I hope so, but I am not sure.</p>\n<p>1.c: When would you use the &lt;&gt;, and when would you use the \"\" (i.e. what are the criteria you would use to use one or the other for a header include)?</p>\n<p>I use \"\" when the include file is supposed to be next to C file, &lt;&gt; in all other cases. IN particular, in our project all \"public\" include files are in project/include directory, so I use &lt;&gt; for them.</p>\n<p>2 - #include {TheProject/TheHeader.hpp} or {TheHeader.hpp} ?</p>\n<p>As already pointed out, xxx/filename.h allows you to do things like diskio/ErrorCodes.h and netio/ErrorCodes.h</p>\n<p>* private headers of your project?</p>\n<p>Private header of my subsystem in project. Use \"filename.h\"\nPublic header of my subsystem in project (not visible outside the project, but accessible to other subsystems). Use  or , depending on the convention adapted for the project. I'd rather use </p>\n<p>* headers of your project, but which are exporting symbols (and thus, \"public\")</p>\n<p>include exactly like the users of your library would include them. Probably </p>\n<p>* headers of another project your module links with</p>\n<p>Determined by the project, but certainly using &lt;&gt;\n* headers of a compiler or standard library\nDefinitely &lt;&gt;, according to standard.</p>\n<p>3.a: Do you work on project with sources and/or headers within a tree-like organisation (i.e., directories inside directories, as opposed to \"every file in one directory\") and what are the pros/cons?</p>\n<p>I do work on a structured project. As soon as you have more than a score of files, some division will become apparent. You should go the way the code is pulling you.</p>\n", "OwnerDisplayName": "Arkadiy", "LastActivityDate": "2008-10-07T17:55:20.510", "Score": "2", "CreationDate": "2008-10-07T17:55:20.510", "ParentId": "179213", "CommentCount": "1", "OwnerUserId": "3458"}, "179244": {"Id": "179244", "PostTypeId": "2", "Body": "<p>If I remember right.</p>\n<p>You use the diamond for all libraries that can be found in your \"path\". So any library that is in the STL, or ones that you have installed. In Linux your path is usually \"/usr/include\", in windows I am not sure, but I would guess it is under \"C:\\windows\".</p>\n<p>You use the \"\" then to specify everything else. \"my_bla.cpp\" with no starting directory information will resolve to the directory your code is residing/compiling in. or you can also specify the exact location of your include with it. Like this \"c:\\myproj\\some_code.cpp\"</p>\n<p>The type of header doesn't matter, just the location.</p>\n", "OwnerDisplayName": "J.J.", "LastActivityDate": "2008-10-07T16:14:06.753", "Score": "1", "CreationDate": "2008-10-07T16:14:06.753", "ParentId": "179213", "CommentCount": "1", "OwnerUserId": "21204"}, "179262": {"Id": "179262", "PostTypeId": "2", "Body": "<p>I'll tackle the second part of your question:</p>\n<p>I normally use <code>&lt;project/libHeader.h&gt;</code> when I am including headers from a 3rd party. And <code>\"myHeader.h\"</code> when including headers from within the project.</p>\n<p>The reason I use <code>&lt;project/libHeader.h&gt;</code> instead of <code>&lt;libHeader.h&gt;</code> is because it's possible that more than one library has a \"libHeader.h\" file.  In order to include them both you need the library name as part of the included filename.</p>\n", "OwnerDisplayName": "Trent", "LastActivityDate": "2008-10-07T16:17:33.687", "Score": "2", "CreationDate": "2008-10-07T16:17:33.687", "ParentId": "179213", "CommentCount": "1", "OwnerUserId": "9083"}, "179213": {"ViewCount": "20509", "Body": "<p>This is a multiple question for the same pre-processing instruction.</p>\n<h2>1 - &lt;&gt; or \"\" ?</h2>\n<p>Apart from the info found in the MSDN:</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/36k2cdd4(VS.80).aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/36k2cdd4(VS.80).aspx</a></p>\n<p>1.a: What are the differences between the two notations?<br>\n1.b: Do all compilers implement them the same way?<br>\n1.c: When would you use the &lt;&gt;, and when would you use the \"\" (i.e. what are the criteria you would use to use one or the other for a header include)?<br/></br></br></p>\n<h2>2 - #include {TheProject/TheHeader.hpp} or {TheHeader.hpp} ?</h2>\n<p>I've seen at least two ways of writing includes of one's project headers.\nConsidering that you have at least 4 types of headers, that is:</p>\n<ul>\n<li>private headers of your project?</li>\n<li>headers of your project, but which are exporting symbols (and thus, \"public\")</li>\n<li>headers of another project your module links with</li>\n<li>headers of a compiler or standard library</li>\n</ul>\n<p>For each kind of headers:</p>\n<p>2.a: Would you use &lt;&gt; or \"\" ?<br>\n2.b: Would you include with {TheProject/TheHeader.hpp}, or with {TheHeader.hpp} only?<br/></br></p>\n<h2>3 - Bonus</h2>\n<p>3.a: Do you work on project with sources and/or headers within a tree-like organisation (i.e., directories inside directories, as opposed to \"every file in one directory\") and what are the pros/cons?</p>\n", "Title": "C++ #include semantics", "CreationDate": "2008-10-07T16:07:32.523", "LastActivityDate": "2016-06-03T20:01:44.910", "CommentCount": "0", "FavoriteCount": "13", "PostTypeId": "1", "LastEditDate": "2016-06-03T20:01:44.910", "LastEditorDisplayName": "paercebal", "OwnerDisplayName": "paercebal", "LastEditorUserId": "4370109", "Id": "179213", "Score": "33", "OwnerUserId": "14089", "Tags": "<c++><c-preprocessor>", "AnswerCount": "10"}, "1251308": {"Id": "1251308", "PostTypeId": "2", "Body": "<p>After reading all answers, as well as compiler documentation, I decided I would follow the following standard.</p>\n<p>For all files, be them project headers or external headers, always use the pattern:</p>\n<pre><code>#include &lt;namespace/header.hpp&gt;\n</code></pre>\n<p>The namespace being at least one directory deep, to avoid collision.</p>\n<p>Of course, this means that the project directory where the project headers are should be added as \"default include header\" to the makefile, too.</p>\n<p>The reason for this choice is that I found the following information:</p>\n<h1>1. The include \"\" pattern is compiler-dependent</h1>\n<p>I'll give the answers below</p>\n<h2>1.a The Standard</h2>\n<p>Source:</p>\n<ul>\n<li>C++14 Working Draft n3797 : <a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"noreferrer\">https://isocpp.org/files/papers/N3797.pdf</a></li>\n<li>C++11, C++98, C99, C89 (the section quoted is unchanged in all those standards)</li>\n</ul>\n<p>In the section 16.2 Source file inclusion, we can read that:</p>\n<blockquote>\n<p id=\"so_179213_1251308_0\">A preprocessing directive of the form</p>\n<pre><code>  #include &lt;h-char-sequence&gt; new-line\n</code></pre>\n<p id=\"so_179213_1251308_1\">searches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the &lt; and &gt; delimiters, and causes the replacement of that directive by the entire contents of the header. How the places are specified or the header identified is implementation-defined.</p>\n</blockquote>\n<p>This means that #include &lt;...&gt; will search a file in an implementation defined manner.</p>\n<p>Then, the next paragraph:</p>\n<blockquote>\n<p id=\"so_179213_1251308_2\">A preprocessing directive of the form</p>\n<pre><code>  #include \"q-char-sequence\" new-line\n</code></pre>\n<p id=\"so_179213_1251308_3\">causes the replacement of that directive by the entire contents of the source file identified by the specified sequence between the \" delimiters. The named source file is searched for in an implementation-defined manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read</p>\n<pre><code>  #include &lt;h-char-sequence&gt; new-line\n</code></pre>\n<p id=\"so_179213_1251308_4\">with the identical contained sequence (including &gt; characters, if any) from the original directive.</p>\n</blockquote>\n<p>This means that #include \"...\" will search a file in an implementation defined manner and then, if the file is not found, will do another search as if it had been an #include &lt;...&gt;</p>\n<p>The conclusion is that we have to read the compilers documentation.</p>\n<p>Note that, for some reason, nowhere in the standards the difference is made between \"system\" or \"library\" headers or other headers. The only difference seem that #include &lt;...&gt; seems to target headers, while #include \"...\" seems to target source (at least, in the english wording).</p>\n<h2>1.b Visual C++:</h2>\n<p>Source:</p>\n<ul>\n<li><a href=\"http://msdn.microsoft.com/en-us/library/36k2cdd4.aspx\" rel=\"noreferrer\">http://msdn.microsoft.com/en-us/library/36k2cdd4.aspx</a></li>\n</ul>\n<h3>#include \"MyFile.hpp\"</h3>\n<p>The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>In the same directory as the file that contains the #include statement.</li>\n<li>In the directories of any previously opened include files in the reverse order in which they were opened. The search starts from the directory of the include file that was opened last and continues through the directory of the include file that was opened first.</li>\n<li>Along the path specified by each /I compiler option.</li>\n<li>(*) Along the paths specified by the INCLUDE environment variable or the development environment default includes.</li>\n</ol>\n<h3>#include &lt;MyFile.hpp&gt;</h3>\n<p>The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>Along the path specified by each /I compiler option.</li>\n<li>(*) Along the paths specified by the INCLUDE environment variable or the development environment default includes.</li>\n</ol>\n<h3>Note about the last step</h3>\n<p>The document is not clear about the \"Along the paths specified by the INCLUDE environment variable\" part for both <code>&lt;...&gt;</code>  and <code>\"...\"</code> includes. The following quote makes it stick with the standard:</p>\n<blockquote>\n<p id=\"so_179213_1251308_5\">For include files that are specified as #include \"path-spec\", directory searching begins with the directory of the parent file and then proceeds through the directories of any grandparent files. That is, searching begins relative to the directory that contains the source file that contains the #include directive that's being processed. If there is no grandparent file and the file has not been found, the search continues as if the file name were enclosed in angle brackets.</p>\n</blockquote>\n<p>The last step (marked by an asterisk) is thus an interpretation from reading the whole document.</p>\n<h2>1.c g++</h2>\n<p>Source:</p>\n<ul>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Header-Files.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Header-Files.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Include-Operation.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Include-Operation.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Invocation.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Invocation.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Once_002dOnly-Headers.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Once_002dOnly-Headers.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/Wrapper-Headers.html</a></li>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/cpp/System-Headers.html\" rel=\"noreferrer\">http://gcc.gnu.org/onlinedocs/cpp/System-Headers.html</a></li>\n</ul>\n<p>The following quote summarizes the process:</p>\n<blockquote>\n<p id=\"so_179213_1251308_6\">GCC [...] will look for headers requested with #include <code>&lt;file&gt;</code> in [system directories] [...] All the directories named by -I are searched, in left-to-right order, before the default directories</p>\n<p id=\"so_179213_1251308_7\">GCC looks for headers requested with #include \"file\" first in the directory containing the current file, then in the directories as specified by -iquote options, then in the same places it would have looked for a header requested with angle brackets.</p>\n</blockquote>\n<h3>#include \"MyFile.hpp\"</h3>\n<p>This variant is used for header files of your own program. The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>In the same directory as the file that contains the #include statement.</li>\n<li>Along the path specified by each -iquote compiler option.</li>\n<li>As for the #include <code>&lt;MyFile.hpp&gt;</code></li>\n</ol>\n<h3>#include &lt;MyFile.hpp&gt;</h3>\n<p>This variant is used for system header files. The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>Along the path specified by each -I compiler option.</li>\n<li>Inside the system directories.</li>\n</ol>\n<h2>1.d Oracle/Sun Studio CC</h2>\n<p>Source:</p>\n<ul>\n<li><a href=\"http://docs.oracle.com/cd/E19205-01/819-5265/bjadq/index.html\" rel=\"noreferrer\">http://docs.oracle.com/cd/E19205-01/819-5265/bjadq/index.html</a></li>\n</ul>\n<p>Note that the text contradict itself somewhat (see the example to understand). The key phrase is: \"<i>The difference is that the current directory is searched only for header files whose names you have enclosed in quotation marks.</i>\"</p>\n<h3>#include \"MyFile.hpp\"</h3>\n<p>This variant is used for header files of your own program. The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>The current directory (that is, the directory containing the \u201cincluding\u201d file)</li>\n<li>The directories named with -I options, if any</li>\n<li>The system directory (e.g. the /usr/include directory)</li>\n</ol>\n<h3>#include &lt;MyFile.hpp&gt;</h3>\n<p>This variant is used for system header files. The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>The directories named with -I options, if any</li>\n<li>The system directory (e.g. the /usr/include directory)</li>\n</ol>\n<h2>1.e XL C/C++ Compiler Reference - IBM/AIX</h2>\n<p>Source:</p>\n<ul>\n<li><a href=\"http://www.bluefern.canterbury.ac.nz/ucsc%20userdocs/forucscwebsite/c/aix/compiler.pdf\" rel=\"noreferrer\">http://www.bluefern.canterbury.ac.nz/ucsc%20userdocs/forucscwebsite/c/aix/compiler.pdf</a></li>\n<li><a href=\"http://www-01.ibm.com/support/docview.wss?uid=swg27024204&amp;aid=1\" rel=\"noreferrer\">http://www-01.ibm.com/support/docview.wss?uid=swg27024204&amp;aid=1</a></li>\n</ul>\n<p>Both documents are titled \"XL C/C++ Compiler Reference\" The first document is older (8.0), but is easier to understand. The second is newer (12.1), but is a bit more difficult to decrypt.</p>\n<h3>#include \"MyFile.hpp\"</h3>\n<p>This variant is used for header files of your own program. The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>The current directory (that is, the directory containing the \u201cincluding\u201d file)</li>\n<li>The directories named with -I options, if any</li>\n<li>The system directory (e.g. the /usr/vac[cpp]/include or /usr/include directories)</li>\n</ol>\n<h3>#include &lt;MyFile.hpp&gt;</h3>\n<p>This variant is used for system header files. The preprocessor searches for include files in the following order:</p>\n<ol>\n<li>The directories named with -I options, if any</li>\n<li>The system directory (e.g. the /usr/vac[cpp]/include or /usr/include directory)</li>\n</ol>\n<h2>1.e Conclusion</h2>\n<p>The pattern \"\" could lead to subtle compilation error across compilers, and as I currently work both on Windows Visual C++, Linux g++, Oracle/Solaris CC and AIX XL, this is not acceptable.</p>\n<p>Anyway, the advantage of \"\" described features are far from interesting anyway, so...</p>\n<h1>2. Use the {namespace}/header.hpp pattern</h1>\n<p>I saw at work (<i>i.e. this is not theory, this is real-life, painful professional experience</i>) two headers with the same name, one in the local project directory, and the other in the global include.</p>\n<p>As we were using the \"\" pattern, and that file was included both in local headers and global headers, there was no way to understand what was really going on, when strange errors appeared.</p>\n<p>Using the directory in the include would have saved us time because the user would have had to either write:</p>\n<pre><code>#include &lt;MyLocalProject/Header.hpp&gt;\n</code></pre>\n<p>or</p>\n<pre><code>#include &lt;GlobalInclude/Header.hpp&gt;\n</code></pre>\n<p>You'll note that while</p>\n<pre><code>#include \"Header.hpp\"\n</code></pre>\n<p>would have compiled successfully, thus, still hiding the problem, whereas</p>\n<pre><code>#include &lt;Header.hpp&gt;\n</code></pre>\n<p>would not have compiled in normal circonstances.</p>\n<p>Thus, sticking to the &lt;&gt; notation would have made mandatory for the developer the prefixing of the include with the right directory, another reason to prefer &lt;&gt; to \"\".</p>\n<h1>3. Conclusion</h1>\n<p>Using both the &lt;&gt; notation and namespaced notation together removes from the pre-compiler the possibility to guess for files, instead searching only the default include directories.</p>\n<p>Of course, the standard libraries are still included as usual, that is:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;vector&gt;\n</code></pre>\n", "LastEditorUserId": "14089", "LastActivityDate": "2014-06-04T17:15:07.783", "Score": "28", "CreationDate": "2009-08-09T12:37:50.090", "ParentId": "179213", "CommentCount": "0", "OwnerUserId": "14089", "LastEditDate": "2014-06-04T17:15:07.783"}});