post_cb({"5126219": {"CommentCount": "1", "AcceptedAnswerId": "5126331", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-02-26T09:55:23.043", "LastActivityDate": "2012-11-13T23:42:47.467", "LastEditDate": "2011-10-03T13:13:32.040", "ViewCount": "2281", "FavoriteCount": "4", "Title": "Is there a reference_wrapper<> for rvalue references?", "Id": "5126219", "Score": "12", "Body": "<p>I wonder how the following can be done</p>\n<pre><code>void f(string &amp;&amp;s) { \n  std::string i(move(s)); \n  /* other stuff */ \n} \n\nint main() { \n  std::string s; \n  bind(f, s)(); // Error.\n  bind(f, move(s))(); // Error.\n  bind(f, ref(s))(); // Error.\n}\n</code></pre>\n<p>How can I pass an rvalue reference and store it as an rvalue reference (possibly wrapped) in the call wrapper? I know I can manually write up a class like <code>std::reference_wrapper&lt;&gt;</code> that has a conversion function to <code>T&amp;&amp;</code>, but I would rather want to avoid that and use Standard technology. </p>\n<hr>\n<p>I implemented it like AProgrammer recommends:</p>\n<pre><code>template&lt;typename T&gt; struct adv { \n  T t; \n  explicit adv(T &amp;&amp;t):t(forward&lt;T&gt;(t)) {} \n  template&lt;typename ...U&gt; T &amp;&amp;operator()(U &amp;&amp;...) { \n    return forward&lt;T&gt;(t); \n  } \n}; \n\ntemplate&lt;typename T&gt; adv&lt;T&gt; make_adv(T &amp;&amp;t) { \n  return adv&lt;T&gt;{forward&lt;T&gt;(t)}; \n}\n\nnamespace std { \n  template&lt;typename T&gt; \n  struct is_bind_expression&lt; adv&lt;T&gt; &gt; : std::true_type {}; \n} \n</code></pre>\n<p>Now I can say</p>\n<pre><code>void f(string &amp;&amp;s) { \n  std::string i(move(s)); \n  /* other stuff */ \n} \n\nint main() { \n  std::string s; \n  bind(f, make_adv(move(s)))(); // Works!\n}\n</code></pre>\n<p>If we pass an lvalue to <code>make_adv</code>, it will forward it as an lvalue referring to the input argument, so it can be used as a replacement for <code>std::ref</code>, in this case. </p>\n</hr>", "Tags": "<c++><c++11><rvalue-reference><stdbind>", "OwnerUserId": "34509", "AnswerCount": "3"}, "5126466": {"ParentId": "5126219", "CommentCount": "1", "CreationDate": "2011-02-26T10:51:59.797", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "5126466", "Score": "0", "Body": "<p>You can use a mutable lambda object.</p>\n<pre><code>auto func = [=]() mutable {\n    f(std::move(s));\n};\n</code></pre>\n", "LastActivityDate": "2011-02-26T10:51:59.797"}, "5126331": {"ParentId": "5126219", "CommentCount": "2", "CreationDate": "2011-02-26T10:24:55.977", "OwnerUserId": "136208", "PostTypeId": "2", "Id": "5126331", "Score": "7", "Body": "<p>My take on this.</p>\n<p>20.8.10.1.2/10 in N3225</p>\n<blockquote>\n<p id=\"so_5126219_5126331_0\">The values of the bound arguments v1, v2, ..., vN and their corresponding types V1, V2, ..., VN\n  depend on the types TiD derived from the call to bind and the cv-qualifiers cv of the call wrapper g as\n  follows:</p>\n<ul>\n<li>if TiD is reference_wrapper, the argument is tid.get() and its type Vi is T&amp;;</li>\n<li>if the value of is_bind_expression::value is true, the argument is tid(std::forward(uj)...)\n  and its type Vi is result_of::type;</li>\n<li>if the value j of is_placeholder::value is not zero, the argument is std::forward(uj)\n  and its type Vi is Uj&amp;&amp;;</li>\n<li>otherwise, the value is tid and its type Vi is TiD cv &amp;.</li>\n</ul>\n</blockquote>\n<p>So the only possibility to have a rvalue reference is to have <code>is_bind_expression&lt;TiD&gt;::value</code> true or <code>is_placeholder&lt;TiD&gt;::value</code> not zero.  The second possibility has implications you don't want and achieving the wanted result with the first would imply that the problem we are trying to solve is solved if we restrict to the standard provided types.  So, the only possibility would be to provide your own wrapper and a specialisation for <code>is_bind_expression&lt;TiD&gt;</code> (that is allowed by 20.8.10.1.1/1) as I don't see one.</p>\n", "LastActivityDate": "2011-02-26T10:24:55.977"}, "bq_ids": {"n4140": {"so_5126219_5126331_0": {"section_id": 4641, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_5126219_5126331_0": {"section_id": 4452, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_5126219_5126331_0": {"section_id": 6011, "quality": 0.8235294117647058, "length": 14}}}, "5126440": {"ParentId": "5126219", "CommentCount": "2", "CreationDate": "2011-02-26T10:45:44.733", "OwnerUserId": "172531", "PostTypeId": "2", "Id": "5126440", "Score": "5", "Body": "<blockquote>\n<p id=\"so_5126219_5126440_0\">How can I pass an rvalue reference and store it as an rvalue reference in the call wrapper?</p>\n</blockquote>\n<p>The problem here is that such a bind function object can be invoked multiple times. If the function object forwarded a bound parameter as rvalue this would obviously only work once. So, this is a bit of a safety issue.</p>\n<p>But in some cases this kind of forwarding is exactly what you want. You could use a lambda as an intermediary:</p>\n<pre><code>bind([](string&amp; s){f(move(s));},move(s));\n</code></pre>\n<p>Basically, I came up with this bind+lambda combination as a workaround for a missing \"move-capture\".</p>\n", "LastActivityDate": "2011-02-26T10:45:44.733"}});