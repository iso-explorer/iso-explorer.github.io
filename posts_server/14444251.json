post_cb({"14444551": {"Id": "14444551", "PostTypeId": "2", "Body": "<p>Firstly, we see that an object of type <code>foo</code> has non-trivial initialization because its constructor is non-trivial (\u00a73.8/1):</p>\n<blockquote>\n<p id=\"so_14444251_14444551_0\">An object is said to have non-trivial initialization if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial default constructor.</p>\n</blockquote>\n<p>Now we see that an object of type <code>foo</code>'s lifetime begins after the constructor ends (\u00a73.8/1):</p>\n<blockquote>\n<p id=\"so_14444251_14444551_1\">The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>Now, it is undefined behaviour if you do <code>delete</code> on the object before the end of the constructor <em>if</em> the type <code>foo</code> has a non-trivial destructor (\u00a73.8/5):</p>\n<blockquote>\n<p id=\"so_14444251_14444551_2\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated [...] any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, [...]</p>\n</blockquote>\n<p>So since our object is under construction, we take a look at \u00a712.7:</p>\n<blockquote>\n<p id=\"so_14444251_14444551_3\">Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2).</p>\n</blockquote>\n<p>That means that it's fine for <code>self_destruct</code> to be called while the object is being constructed. However, this section says nothing specifically about destroying an object while it is being constructed. So I suggest we look at the operation of the <code>delete-expression</code>.</p>\n<p>First, it \"will invoke the destructor (if any) for the object [...] being deleted.\" The destructor is a special case of member function, so it is fine to call it. However, \u00a712.4 Destructors says nothing about whether it is <em>well-defined</em> when the destructor is called during construction. No luck here.</p>\n<p>Second, \"the <em>delete-expression</em> will call a <em>deallocation function</em>\" and \"the deallocation function shall deallocate the storage referenced by the pointer\". Once again, nothing is said about doing this to storage that is currently being used be an object under construction.</p>\n<p>So I argue that this is undefined behaviour by the fact that the standard hasn't defined it very precisely.</p>\n<p>Just to note: the lifetime of an object of type <code>foo</code> <em>ends</em> when the destructor call starts, because it has a non-trivial destructor. So if <code>delete this;</code> occurs before the end of the object's construction, <strong>its lifetime ends before it starts</strong>. This is playing with fire.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-01-21T19:53:02.833", "Score": "7", "CreationDate": "2013-01-21T17:58:41.137", "ParentId": "14444251", "CommentCount": "9", "OwnerUserId": "150634", "LastEditDate": "2013-01-21T19:53:02.833"}, "bq_ids": {"n4140": {"so_14444251_14444576_0": {"length": 45, "quality": 0.8490566037735849, "section_id": 7189}, "so_14444251_14444466_1": {"length": 46, "quality": 1.0, "section_id": 6106}, "so_14444251_14444551_0": {"length": 18, "quality": 1.0, "section_id": 7189}, "so_14444251_14444466_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 7194}, "so_14444251_14444551_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_14444251_14444551_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 447}, "so_14444251_14444551_2": {"length": 31, "quality": 0.9393939393939394, "section_id": 7193}}, "n3337": {"so_14444251_14444576_0": {"length": 45, "quality": 0.8490566037735849, "section_id": 6933}, "so_14444251_14444466_1": {"length": 46, "quality": 1.0, "section_id": 5872}, "so_14444251_14444551_0": {"length": 18, "quality": 1.0, "section_id": 6933}, "so_14444251_14444466_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 6938}, "so_14444251_14444551_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_14444251_14444551_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 438}, "so_14444251_14444551_2": {"length": 31, "quality": 0.9393939393939394, "section_id": 6937}}, "n4659": {"so_14444251_14444576_0": {"length": 40, "quality": 0.7547169811320755, "section_id": 8697}, "so_14444251_14444466_1": {"length": 46, "quality": 1.0, "section_id": 7603}, "so_14444251_14444551_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 8697}, "so_14444251_14444466_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 8703}, "so_14444251_14444551_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_14444251_14444551_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 469}, "so_14444251_14444551_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 8702}}}, "14444251": {"ViewCount": "610", "Body": "<p>Suppose I have a class whose constructor spawns a thread that deletes the object:</p>\n<pre><code>class foo {\npublic:\n    foo() \n    : // initialize other data-members\n    , t(std::bind(&amp;foo::self_destruct, this)) \n    {}\n\nprivate:\n    // other data-members\n    std::thread t;\n    // no more data-members declared after this\n\n    void self_destruct() { \n        // do some work, possibly involving other data-members\n        delete this; \n    }\n};\n</code></pre>\n<p>The problem here is that the destructor might get invoked before the constructor has finished. Is this legal in this case? Since <code>t</code> is declared (and thus initialized) last, and there is no code in the constructor body,  and I never intend to subclass this class, I assume that the object has been completely initialized when <code>self_destruct</code> is called. Is this assumption correct?</p>\n<p>I know that the statement <code>delete this;</code> is legal in member-functions if <code>this</code> is not used after that statement. But constructors are special in several ways, so I am not sure if this works.</p>\n<p>Also, if it is illegal, I am not sure how to work around it, other spawning the thread in a special initialization-function that must be called after construction of the object, which I really would like to avoid.</p>\n<p>P.S.: I am looking for an answer for C++03 (I am restricted to an older compiler for this project). The <code>std::thread</code> in the example is just for illustration-purposes.</p>\n", "AcceptedAnswerId": "14444551", "Title": "Is invoking the destructor before the constructor has finished legal?", "CreationDate": "2013-01-21T17:40:00.257", "Id": "14444251", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-01-21T17:50:30.157", "LastEditorUserId": "160206", "LastActivityDate": "2013-01-21T20:53:43.870", "Score": "6", "OwnerUserId": "160206", "Tags": "<c++><asynchronous><constructor><destructor>", "AnswerCount": "4"}, "14444576": {"Id": "14444576", "PostTypeId": "2", "Body": "<p>Formally the object doesn't exist until the constructor has finished successfully. Part of the reason is that the constructor might be called from a derived class' constructor. In that case you certainly don't want to destroy the constructed sub-object via an explicit destructor call, and even less invoke UB by calling <code>delete this</code> on a (part of a) not completely constructed object.</p>\n<hr>\n<p>Standardese about the object existence, emphasis added:</p>\n<blockquote>\n<p id=\"so_14444251_14444576_0\"><strong>C++11 \u00a73.8/1</strong>:<br>\n  The <em>lifetime</em> of an object is a runtime property of the object. An object is said to have non-trivial initialization\n  if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial\n  default constructor. [<em>Note:</em> initialization by a trivial copy/move constructor is non-trivial initialization. <em>\u2014end note</em> ] The lifetime of an object of type T begins when:<br>\n  \u2014 storage with the proper alignment and size for type T is obtained, and<br>\n  \u2014 if the object has non-trivial initialization, <strong><em>its initialization is complete</em></strong>.</br></br></br></p>\n</blockquote>\n<p>The constructor in this case is non-trivial just by being user-provided.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2013-01-21T19:22:39.207", "Score": "1", "CreationDate": "2013-01-21T18:00:17.753", "ParentId": "14444251", "CommentCount": "4", "OwnerUserId": "464581", "LastEditDate": "2013-01-21T19:22:39.207"}, "14444466": {"Id": "14444466", "PostTypeId": "2", "Body": "<p><code>delete this;</code> works correctly in practice on most platforms; some may even guarantee correct behavior as a platform-specific extension.  But IIRC it isn't well-defined according to the Standard.</p>\n<p>The behavior you're relying on is that it's often possible to call a non-virtual non-static member function on a dead object, as long as that member function doesn't actually access <code>this</code>.  But this behavior is not allowed by the Standard; it is at best non-portable.</p>\n<p>Section 3.8p6 of the Standard makes it undefined behavior if an object isn't live during a call to a non-static member function:</p>\n<blockquote>\n<p id=\"so_14444251_14444466_0\">Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a glvalue refers to allocated\n  storage, and using the properties of the glvalue that do not depend on its value is well-defined. The program has undefined behavior if:</p>\n<ul>\n<li>an lvalue-to-rvalue conversion is applied to such a glvalue,</li>\n<li><strong>the glvalue is used to access a non-static data member or call a non-static member function of the object, or</strong></li>\n<li>the glvalue is implicitly converted to a reference to a base class type, or</li>\n<li>the glvalue is used as the operand of a <code>static_cast</code> except when the conversion is ultimately\n  to <em><code>cv</code></em><code>char&amp;</code> or <em><code>cv</code></em><code>unsigned char&amp;</code>, or</li>\n<li>the glvalue is used as the operand of a <code>dynamic_cast</code> or as the operand of <code>typeid</code>.</li>\n</ul>\n</blockquote>\n<hr>\n<p>For this specific case (deleting an object under construction), we find in section 5.3.5p2:</p>\n<blockquote>\n<p id=\"so_14444251_14444466_1\">... In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer value, a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject representing a base class of such an object (Clause 10). If not, the behavior is undefined. In the second alternative (<em>delete array</em>), the value of the operand of <code>delete</code> may be a null pointer value or a pointer value that resulted from a previous array <em>new-expression</em>.  If not, the behavior is undefined.</p>\n</blockquote>\n<p>This requirement is not met.  <code>*this</code> is not an object <em>created</em>, past tense, by a <em>new-expression</em>.  It is an object <em>being created</em> (present progressive).  And this interpretation is supported by the array case, where the pointer must be the result of a previous <em>new-expression</em>... but the <em>new-expression</em> is not yet completely evaluated; it is not <em>previous</em> and it has no result yet.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2013-01-21T20:53:43.870", "Score": "1", "CreationDate": "2013-01-21T17:53:40.083", "ParentId": "14444251", "CommentCount": "9", "OwnerUserId": "103167", "LastEditDate": "2013-01-21T20:53:43.870"}, "14444696": {"Id": "14444696", "PostTypeId": "2", "Body": "<p>I daresay it is well-defined to be illegal (though it might obviously still work with some compilers).</p>\n<p>This is somewhat the same situation as \"destructor not called when exception is thrown from constructor\".</p>\n<p>A delete-expression, according to the standard, destroys <em>a most derived object (1.8) or array created by a new-expression</em> (5.3.2). Before the end of the constructor, an object <em>is not</em> a most derived object, but an object of its direct ancestor's type. </p>\n<p>Your class <code>foo</code> has no base class, so there is no ancestor, <code>this</code> therefore has no type and your object is not really an object at all at the time <code>delete</code> is called. But even if there was a base class, the object would be a not-most-derived object (still rendering it illegal), and the wrong constructor would be called.</p>\n", "LastActivityDate": "2013-01-21T18:09:44.997", "CommentCount": "0", "CreationDate": "2013-01-21T18:09:44.997", "ParentId": "14444251", "Score": "2", "OwnerUserId": "572743"}});