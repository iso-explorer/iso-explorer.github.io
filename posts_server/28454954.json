post_cb({"28454954": {"ViewCount": "417", "Body": "<p>How to create a static function whose variables need not to be created within it (for computational issues), taking into account that this function can be called by different threads?\nExample:</p>\n<pre><code>class calcul {\n    static double **v1, **v2, ...,**vn;\n\npublic:\n    calcul();\n    ~calcul();\n\n    static void matrix();\n}; \n</code></pre>\n<p>such that <code>matrix()</code> uses <code>v1</code>, ..., <code>vn</code>.</p>\n<p>The question is: when having multiple call for <code>calcul::matrix()</code> from different threads, would this create conflicts i.e. v1 related to thread A can be modified by thread B?</p>\n<p>My objective of using 'static' is ergonomic in the sense that I would not each time need creating a corresponding object. In fact Class 'clacul' would be part of a library that needs to be used for real-time applications. That means that calcul() could be called each milliseconds for instance.</p>\n", "AcceptedAnswerId": "28455132", "Title": "C++ static members in static functions and multithreading", "CreationDate": "2015-02-11T12:57:00.633", "Id": "28454954", "CommentCount": "5", "LastEditDate": "2015-02-12T09:05:30.880", "PostTypeId": "1", "LastEditorUserId": "1413253", "LastActivityDate": "2015-02-12T09:05:30.880", "Score": "-1", "OwnerUserId": "1413253", "Tags": "<c++><multithreading><static>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_28454954_28455153_1": {"length": 13, "quality": 1.0, "section_id": 7169}, "so_28454954_28455153_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 7168}}, "n3337": {"so_28454954_28455153_1": {"length": 13, "quality": 1.0, "section_id": 6913}, "so_28454954_28455153_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 6912}}, "n4659": {"so_28454954_28455153_1": {"length": 13, "quality": 1.0, "section_id": 8677}, "so_28454954_28455153_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 8676}}}, "28455132": {"Id": "28455132", "PostTypeId": "2", "Body": "<p>The way to create static variables is to declare them as you have, and then define them;</p>\n<pre><code>double calcul::v1, calcul::v2;   // same for other variables\n</code></pre>\n<p>This type of definition of the static variables has to occur in exactly ONE translation unit (aka source file which becomes an object) within your project.</p>\n<p>If you wish to call your <code>calcul::matrix()</code> from multiple threads, then each of those threads will need to synchronise access to the static variables (for example, using a mutex).    Otherwise you get problems such as race conditions, operations being preempted when partly completed, etc.   That can mean variables getting unexpected values.</p>\n", "LastActivityDate": "2015-02-11T13:05:22.027", "CommentCount": "3", "CreationDate": "2015-02-11T13:05:22.027", "ParentId": "28454954", "Score": "0", "OwnerUserId": "4491408"}, "28455170": {"Id": "28455170", "PostTypeId": "2", "Body": "<p>The static variables are from your class calcul namespace, and are allocated only once on memory, thus being the same for every object or thread you have.</p>\n<p>Whenever you are trying to access the same variables (same memory address) from different threads, you need to work with Mutex or Semaphores, in order to perform transactions/operations safely.</p>\n<p>Example:</p>\n<pre><code>#include &lt;mutex&gt;\n\nclass calcul{\n    std::mutex mtx;\n    ....\n}\n\nvoid matrix()\n{\n   //lock the resources below to the current thread only\n   mtx.lock();\n\n   //do stuff with the variables (common resource)\n\n   mtx.unlock(); //when the current thread is finished, unlock the resource.\n}\n</code></pre>\n", "LastActivityDate": "2015-02-11T13:07:28.837", "CommentCount": "0", "CreationDate": "2015-02-11T13:07:28.837", "ParentId": "28454954", "Score": "0", "OwnerUserId": "995959"}, "28455153": {"Id": "28455153", "PostTypeId": "2", "Body": "<p>You could make the values non-<code>static</code> since they are only used locally in the function:</p>\n<pre><code>void matrix() {\n    double v1, ..., vn;\n    // ..\n}\n</code></pre>\n<p>Or you could introduce some kind of synchronization primitive into matrix to prevent multiple threads from simultaneously accessing it:</p>\n<pre><code>class calcul {\n    std::mutex mtx;\n    static double v1, ..., vn;\n};\n\nvoid matrix() {\n    std::lock_guard&lt;std::mutex&gt; lk(mtx);\n    // ...\n};\n</code></pre>\n<p>Lastly if your compiler supports it, you could make the variables <code>static thread_local</code>:</p>\n<pre><code>class calcul {\n    static thread_local double v1, ..., vn;\n};\n</code></pre>\n<p>Which does, from [basic.stc.thread]:</p>\n<blockquote>\n<p id=\"so_28454954_28455153_0\">1 All variables declared with the <code>thread_local</code> keyword have <em>thread storage duration</em>. The storage for these\n  entities shall last for the duration of the thread in which they are created. There is a distinct object or\n  reference per thread, and use of the declared name refers to the entity associated with the current thread.  </p>\n<p id=\"so_28454954_28455153_1\">2 A variable with thread storage duration shall be initialized before its first odr-use (3.2) and, if constructed,\n  shall be destroyed on thread exit.</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-02-11T13:17:08.650", "Score": "1", "CreationDate": "2015-02-11T13:06:28.767", "ParentId": "28454954", "CommentCount": "13", "OwnerUserId": "2069064", "LastEditDate": "2015-02-11T13:17:08.650"}});