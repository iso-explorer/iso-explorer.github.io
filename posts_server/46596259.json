post_cb({"46596259": {"CommentCount": "2", "AcceptedAnswerId": "46596449", "CreationDate": "2017-10-05T23:36:49.597", "LastActivityDate": "2017-10-06T00:02:47.290", "PostTypeId": "1", "ViewCount": "56", "FavoriteCount": "1", "Title": "How to cast away constness on a function pointer?", "Id": "46596259", "Score": "3", "Body": "<p>The following code compiles clean on GCC but gets an error on Clang:</p>\n<pre><code>typedef void (MyFuncPtr)();\nvoid foo(const MyFuncPtr* ptr)\n{   \n    MyFuncPtr* myTestPtr = ptr;\n}\n</code></pre>\n<p>Clang error:</p>\n<pre><code>error: cannot initialize a variable of type 'MyFuncPtr *' (aka 'void (*)()') with an lvalue of type 'const MyFuncPtr *'\n  (aka 'void (const *)()')\n</code></pre>\n<p>I have tried the following solutions and they all get errors except for the C-style cast:</p>\n<p>const_cast:</p>\n<pre><code>MyFuncPtr* myTestPtr = const_cast&lt;MyFuncPtr*&gt;(ptr);\n</code></pre>\n<p>Error:</p>\n<pre><code>error: const_cast to 'MyFuncPtr *' (aka 'void (*)()'), which is not a reference, pointer-to-object, or pointer-to-data-member\n</code></pre>\n<p>reintepret_cast:</p>\n<pre><code>MyFuncPtr* myTestPtr = reinterpret_cast&lt;MyFuncPtr*&gt;(ptr);\n</code></pre>\n<p>Error:</p>\n<pre><code>error: reinterpret_cast from 'const MyFuncPtr *' (aka 'void (const *)()') to 'MyFuncPtr *' (aka 'void (*)()') casts away\n  qualifiers\n</code></pre>\n<p>C-style cast:</p>\n<pre><code>MyFuncPtr* myTestPtr = (MyFuncPtr*) ptr;\n</code></pre>\n<p>Success!</p>\n<p>Questions:<br>\nWhy doesn't const_cast work on function pointers?<br>\nIs using a C-style cast the only solution?<br>\nWhy does this work on GCC with no casting?</br></br></br></p>\n<p>Thanks in advance!</p>\n<p>COMPILER VERSIONS:<br>\n*G++ version 4.6.3<br>\n*clang version 3.5.0.210790</br></br></p>\n", "Tags": "<c++><casting><clang>", "OwnerUserId": "7999674", "AnswerCount": "1"}, "46596449": {"ParentId": "46596259", "CommentCount": "3", "Body": "<p>In your code, <code>MyFuncPtr</code> is a function type (not a function pointer type). Your code tries to use the type <code>const MyFuncPtr</code>, which is applying <code>const</code> to a function type.</p>\n<p>However, according to the note in C++14 [dcl.fct]/6, there is no such thing as a const-qualified function type:</p>\n<blockquote>\n<p id=\"so_46596259_46596449_0\">The effect of a <em>cv-qualifier-seq</em> in a function declarator is not the same as adding cv-qualification on top of the function type. In the latter case, the cv-qualifiers are ignored.  [Note: a function type that has a <em>cv-qualifier-seq</em> is not a cv-qualified type; there are no cv-qualified function types. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>This section is primarily talking about <em>cv-qualifier-seq</em>, which is the qualifiers that occur after a member function. However, in passing, it seems to specify that cv-qualifiers applied to a function type in general are ignored.</p>\n<p>So your code ought to be the same as:</p>\n<pre><code>typedef void (MyFuncPtr)();\nvoid foo(MyFuncPtr* ptr)\n{   \n    MyFuncPtr* myTestPtr = ptr;\n}\n</code></pre>\n<p>which would mean clang is bugged to report an error.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "46596449", "Score": "3", "CreationDate": "2017-10-06T00:02:47.290", "LastActivityDate": "2017-10-06T00:02:47.290"}, "bq_ids": {"n4140": {"so_46596259_46596449_0": {"section_id": 3242, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_46596259_46596449_0": {"section_id": 3115, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_46596259_46596449_0": {"section_id": 3999, "quality": 0.8518518518518519, "length": 23}}}});