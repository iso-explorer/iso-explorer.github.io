post_cb({"21961992": {"ParentId": "21956017", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>NO, there is no black-letter quote from the Standard that specifies this. The closest that one can get is point 7 of that same paragraph</p>\n<blockquote>\n<p id=\"so_21956017_21961992_0\">7 [...] the underlying type is an integral type that can represent all\n  the enumerator values de\ufb01ned in the enumeration. If no integral type\n  can represent all the enumerator values, the enumeration is\n  ill-formed. [...]</p>\n</blockquote>\n<p>Furthermore, 4.5 Integral promotions [conv.prom] says</p>\n<blockquote>\n<p id=\"so_21956017_21961992_1\">4 A prvalue of an unscoped enumeration type whose underlying type is\n  \ufb01xed (7.2) can be converted to a prvalue of its underlying type.</p>\n</blockquote>\n<p>As pointed out in the comments, there could be (devious IMO) implementations that have different endianess between an enum and its underlying type. That would be a Quality of Implementation issue. For all practical purposes, layout-compatibility should be expected.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2014-02-23T15:13:45.897", "Id": "21961992", "Score": "2", "CreationDate": "2014-02-22T23:21:37.450", "LastActivityDate": "2014-02-23T15:13:45.897"}, "21956017": {"CommentCount": "1", "CreationDate": "2014-02-22T15:02:42.177", "PostTypeId": "1", "AcceptedAnswerId": "21961992", "LastEditorUserId": "241631", "LastActivityDate": "2014-09-11T15:05:33.703", "LastEditDate": "2014-09-11T15:05:33.703", "ViewCount": "159", "FavoriteCount": "1", "Title": "Are enumeration types layout compatible with their underlying type?", "Id": "21956017", "Score": "3", "Body": "<p>I'm looking through <code>n3690</code>, a draft of the upcoming <code>C++14</code> standard, and I see in section <code>7.2</code> paragraph <code>9</code>:</p>\n<blockquote>\n<p id=\"so_21956017_21956017_0\">Two enumeration types are layout-compatible if they have the same underlying type.</p>\n</blockquote>\n<p>However, I can't find anything that says an enumeration type is layout-compatible with its underlying type. To me it seems obvious that this should follow given the reasonable semantics for what \"underlying type\" means, but is it actually guaranteed by the standard?</p>\n", "Tags": "<c++><enums><language-lawyer><c++14>", "OwnerUserId": "636917", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21956017_21961992_0": {"section_id": 5466, "quality": 0.95, "length": 19}, "so_21956017_21956017_0": {"section_id": 5468, "quality": 0.7777777777777778, "length": 7}, "so_21956017_21961992_1": {"section_id": 24, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_21956017_21961992_0": {"section_id": 5252, "quality": 0.95, "length": 19}, "so_21956017_21956017_0": {"section_id": 5254, "quality": 0.8888888888888888, "length": 8}, "so_21956017_21961992_1": {"section_id": 21, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_21956017_21961992_0": {"section_id": 6900, "quality": 0.95, "length": 19}, "so_21956017_21956017_0": {"section_id": 6902, "quality": 0.8888888888888888, "length": 8}, "so_21956017_21961992_1": {"section_id": 24, "quality": 0.9285714285714286, "length": 13}}}});