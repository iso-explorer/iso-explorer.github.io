post_cb({"22022826": {"CommentCount": "6", "AcceptedAnswerId": "22026484", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2014-02-25T18:21:50.297", "LastActivityDate": "2015-03-26T17:13:14.527", "LastEditDate": "2014-05-06T02:54:24.377", "ViewCount": "381", "FavoriteCount": "1", "Title": "Can you assign the value of one union member to another?", "Id": "22022826", "Score": "13", "Body": "<p>Consider the following code snippet:</p>\n<pre><code>union\n{\n   int a;\n   float b;\n};\n\na = /* ... */;\n\nb = a;               // is this UB?\nb = b + something;\n</code></pre>\n<p>Is the assignment of one union member to another valid?</p>\n", "Tags": "<c++><memory><language-lawyer><unions>", "OwnerUserId": "447979", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22022826_22026484_0": {"section_id": 5913, "quality": 1.0, "length": 9}, "so_22022826_22026484_2": {"section_id": 5916, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_22022826_22026484_0": {"section_id": 5685, "quality": 1.0, "length": 9}, "so_22022826_22026484_2": {"section_id": 5688, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_22022826_22026484_0": {"section_id": 7404, "quality": 1.0, "length": 9}, "so_22022826_22026484_2": {"section_id": 7409, "quality": 0.7058823529411765, "length": 12}}}, "29284781": {"ParentId": "22022826", "CommentCount": "0", "Body": "<p>I would expect that unless the source and destination variables are the same type, such a thing would be Undefined Behavior in C, and I see no reason to expect C++ to handle it any differently.  Given <code>long long *x,*y;</code>, some compilers might process a statement like <code>*x = *y &gt;&gt;8;</code> by generating code to read all of *y, compute the result, and store it to *x, but a compiler might perfectly legitimately write code that copied parts of *y to *x individually.  The standard makes clear that if *x and *y are pointers to the same object of the same type, the compiler must ensure that no part of the value gets overwritten <em>while that part is still needed in the computation</em>, but compilers are not required to deal with aliasing in other situations.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "29284781", "Score": "0", "CreationDate": "2015-03-26T17:13:14.527", "LastActivityDate": "2015-03-26T17:13:14.527"}, "22026484": {"ParentId": "22022826", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Unfortunately I believe the answer to this question is that this operation on unions is under specified in C++, although self assignment is perfectly ok.</p>\n<p>Self assignment is well defined behavior, if we look at the draft C++ standard section <code>1.9</code> <em>Program execution</em> paragraph <em>15</em> has the following examples:</p>\n<pre><code>void f(int, int);\nvoid g(int i, int* v) {\n    i = v[i++]; // the behavior is undefined\n    i = 7, i++, i++; // i becomes 9\n\n    i = i++ + 1; // the behavior is undefined\n    i = i + 1; // the value of i is incremented\n\n    f(i = -1, i = -1); // the behavior is undefined\n}\n</code></pre>\n<p>and self assignment is covered in the <code>i = i + 1</code> example.</p>\n<p>The problem here is that <a href=\"https://stackoverflow.com/questions/2310483/purpose-of-unions-in-c-and-c#comment26826326_2313676\">unlike C89 forward</a> which supports type-punning in <a href=\"https://stackoverflow.com/questions/2310483/purpose-of-unions-in-c-and-c\">C++ it is not clear</a>. We only know that:</p>\n<blockquote>\n<p id=\"so_22022826_22026484_0\">In a union, at most one of the non-static data members can be active at any time</p>\n</blockquote>\n<p>but as this discussion in the <a href=\"http://www.open-std.org/pipermail/ub/2013-July/000083.html\" rel=\"nofollow noreferrer\">WG21 UB study group mailing list</a> shows this concept is not well understood, we have the following comments:</p>\n<blockquote>\n<p id=\"so_22022826_22026484_1\">While the standard uses the term \"active field\", it does not define it</p>\n</blockquote>\n<p>and points out this non-normative note:</p>\n<blockquote>\n<p id=\"so_22022826_22026484_2\">Note: In general, one must use explicit destructor calls and placement new operators to change the active member of a union. \u2014 end note</p>\n</blockquote>\n<p>so we have to wonder whether:</p>\n<pre><code>b = a;\n</code></pre>\n<p>makes <code>b</code> the active member or not? I don't know and I don't see a way to prove it with the any of the current versions of the draft standard.</p>\n<p>Although in all practicality most modern compilers for example <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.1/gcc/Optimize-Options.html#index-fstrict_002daliasing-881\" rel=\"nofollow noreferrer\">gcc</a> supports type-punning in C++, which means that the whole concept of the active member is bypassed.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:26.250", "Id": "22026484", "Score": "3", "CreationDate": "2014-02-25T21:21:31.583", "LastActivityDate": "2014-02-25T21:21:31.583"}});