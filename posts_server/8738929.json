post_cb({"8739132": {"ParentId": "8738929", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Genuinely <code>const</code> objects may be treated by the compiler as legitimate constants. It can assume their values never change or even store them in <code>const</code> memory, e.g. ROM or Flash. So, you need to use the non-const access path provided by <code>this</code> as long as the object is, in fact, not constant. This condition only exists during object construction and destruction.</p>\n<p>Offhand, I think there does not need to be a corresponding requirement for destructors because the object lifetime has already ended and <code>cobj.c</code> is inaccessible as soon as the destructor for <code>cobj</code> begins.</p>\n<p>As Matthieu mentions, it is a strong \"code smell\" to be accessing an object besides through <code>this</code> during construction or destruction. Reviewing C++11 \u00a73.8 [basic.life] \u00b61 and 6, it would appear that <code>cobj.c</code> inside the constructor is UB for the same reason it is inside the destructor, regardless of the object being <code>const</code> or \u00a712.1/14, because its lifetime does not begin until initialization is complete (the constructor returns).</p>\n<p>It might be likely to work, but it will ring alarms for good C++ programmers, and by the book it is illegal.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2012-01-05T11:45:51.707", "Id": "8739132", "Score": "6", "CreationDate": "2012-01-05T07:40:32.497", "LastActivityDate": "2012-01-05T11:45:51.707"}, "8738929": {"CommentCount": "5", "ViewCount": "508", "PostTypeId": "1", "LastEditorUserId": "464581", "CreationDate": "2012-01-05T07:17:45.907", "LastActivityDate": "2012-01-05T11:45:51.707", "Title": "Construction of const object", "FavoriteCount": "3", "LastEditDate": "2012-01-05T07:30:59.423", "Id": "8738929", "Score": "13", "Body": "<p>C++11 \u00a712.1/14:</p>\n<blockquote>\n<p id=\"so_8738929_8738929_0\">During the construction of a const object, if the value of the object or any of its subobjects is accessed through an lvalue that is\n  not obtained, directly or indirectly, from the constructor\u2019s this\n  pointer, the value of the object or subobject thus obtained is\n  unspecified.  [Example:</p>\n</blockquote>\n<pre><code>struct C;\nvoid no_opt(C*);\n\nstruct C {\n    int c;\n    C() : c(0) { no_opt(this); }\n};\n\nconst C cobj;\n\nvoid no_opt(C* cptr) {\n    // value of cobj.c is unspecified\n    int i = cobj.c * 100;\n    cptr-&gt;c = 1;\n    // value of cobj.c is unspecified\n    cout &lt;&lt; cobj.c * 100 &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Compiling the above example outputs <code>100</code>. My question is why is the value of <code>cobj.c</code> should be unspecified when the initialization list sets it to <code>0</code> before entering constructor? How is this behavior different in case if a non-const object is used?</p>\n", "Tags": "<c++><constructor><const>", "OwnerUserId": "1086635", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_8738929_8738929_0": {"section_id": 377, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_8738929_8738929_0": {"section_id": 368, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_8738929_8738929_0": {"section_id": 391, "quality": 0.8695652173913043, "length": 20}}}, "8740165": {"ParentId": "8738929", "CommentCount": "0", "Body": "<p>The reason for the quoted rule is to allow the compiler to make\noptimizations based on the const-ness of the object.  For example,\ndepending on optimization, your compiler might replace the second\n<code>cobj.c * 100</code> in <code>no_opt</code> with <code>i</code>.  More likely, in this particular\ncase, the optimizer will suppress the <code>i</code> and its initialization\ncompletely, so the code will appear to work.  But this might not be the\ncase if you also output <code>i</code>, before changing <code>cptr-&gt;c</code>; it all depends\non how agressive the compiler optimizes.  But the compiler is allowed to\nassume that <code>*cptr</code> is not an alias for <code>cobj</code>, because <code>cobj</code> is a\nconst object, where as you modify through <code>*cptr</code>, so it cannot point to\na const object without undefined behavior.</p>\n<p>If the object isn't const, of course, the issue doesn't occur; the \ncompiler must always take into account a possible aliasing between\n<code>*cptr</code> and <code>cobj</code>.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "8740165", "Score": "3", "CreationDate": "2012-01-05T09:26:57.037", "LastActivityDate": "2012-01-05T09:26:57.037"}});