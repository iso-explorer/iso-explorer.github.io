post_cb({"bq_ids": {"n4140": {"so_48336643_48336643_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 102}}, "n3337": {"so_48336643_48336643_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 97}}, "n4659": {"so_48336643_48336643_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 106}}}, "48336643": {"ViewCount": "154", "Body": "<p>I have the following wrapper class:</p>\n<pre><code>template &lt;typename T&gt;\nclass Remap {\n  public:\n    Remap(T *data, int *remap) : data(data), remap(remap){};\n    T &amp;operator[](std::size_t idx) const { return data[remap[idx]]; }\n  private:\n    T *data;\n    int *remap;\n};    \n</code></pre>\n<p>It works perfectly fine if I call it like:</p>\n<pre><code>Remap&lt;double&gt; remap(data, remap);\n</code></pre>\n<p>where data is of the type <code>double *</code>. If I try to let the compiler (intel icc 15.0.3, with -std=c++11) deduce the template type:</p>\n<pre><code>Remap remap(data, remap);\n</code></pre>\n<p>It fails with the error message:</p>\n<blockquote>\n<p id=\"so_48336643_48336643_0\"><code>argument list for class template \"Remap\" is missing</code></p>\n</blockquote>\n<p>I try not to violate the <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" rel=\"nofollow noreferrer\">DRY</a> principle and thus like to fix this issue. </p>\n", "AcceptedAnswerId": "48336801", "Title": "Class template deduction for a pointer to a datatype", "CreationDate": "2018-01-19T08:10:16.617", "LastActivityDate": "2018-01-19T13:25:27.993", "CommentCount": "1", "LastEditDate": "2018-01-19T09:33:10.700", "PostTypeId": "1", "LastEditorUserId": "545127", "Id": "48336643", "Score": "7", "OwnerUserId": "2416647", "Tags": "<c++><c++11><templates><c++14><type-deduction>", "AnswerCount": "1"}, "48336801": {"Id": "48336801", "PostTypeId": "2", "Body": "<p>Before <em>C++17</em> there is no deduction for class template arguments.</p>\n<p>The workaround is to use some kind of <code>get_remap</code> template function which produces <code>Remap</code> objects:</p>\n<pre><code>template&lt;typename T&gt;\nRemap&lt;T&gt; get_remap(T* data, int* remap) {\n    return Remap&lt;T&gt;(data, remap);\n}\n</code></pre>\n<p>and then use it like:</p>\n<pre><code>double* data = nullptr;\nint* remap = nullptr;\n\nauto remap_obj = get_remap(data, remap);\n</code></pre>\n<p><a href=\"https://godbolt.org/g/mVmPeX\" rel=\"nofollow noreferrer\"><strong>Example</strong></a></p>\n<p>Moreover, with <em>C++14</em> support <code>get_remap</code> might be shortened to:</p>\n<pre><code>template&lt;typename T&gt;\nauto get_remap(T* data, int* remap) {\n    return Remap&lt;T&gt;(data, remap);\n}\n</code></pre>\n<p>by letting the compiler to deduce a return type.</p>\n<hr>\n<p>Since <em>C++17</em> you might make use of <a href=\"http://en.cppreference.com/w/cpp/language/class_template_argument_deduction\" rel=\"nofollow noreferrer\">class template argument deduction</a> and simply write:</p>\n<pre><code>double* data = nullptr;\nint* remap = nullptr;\n\nRemap remap_obj(data, remap);\n</code></pre>\n<p><a href=\"https://godbolt.org/g/1b3nmS\" rel=\"nofollow noreferrer\"><strong>Example</strong></a></p>\n</hr>", "LastEditorUserId": "5507349", "LastActivityDate": "2018-01-19T13:25:27.993", "Score": "10", "CreationDate": "2018-01-19T08:22:27.430", "ParentId": "48336643", "CommentCount": "4", "OwnerUserId": "5507349", "LastEditDate": "2018-01-19T13:25:27.993"}});