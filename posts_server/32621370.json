post_cb({"32621370": {"ViewCount": "64", "Body": "<p>This code does not compile:</p>\n<pre><code>template &lt;typename T&gt;\nstruct B {\n    typedef T type;\n};\n\nstruct D0 : public B&lt;int&gt; {\n    void h(type) { }\n};\n\ntemplate &lt;typename T&gt;\nstruct D : public B&lt;T&gt; {\n    void f(typename B&lt;T&gt;::type) { }\n    void g(type) { }\n};\n</code></pre>\n<ul>\n<li><a href=\"http://ideone.com/pVh94t\" rel=\"nofollow\">http://ideone.com/pVh94t</a></li>\n</ul>\n<p>Specifically, although <code>D0::h(type)</code> and <code>D::f(typename B&lt;T&gt;::type)</code> compile, <code>D::g(type)</code> does not.  Why is <code>type</code> not visible in <code>D</code>?</p>\n", "AcceptedAnswerId": "32621475", "Title": "C++: Scope of templated base class?", "CreationDate": "2015-09-17T01:45:58.473", "Id": "32621370", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-09-17T02:05:16.577", "Score": "1", "OwnerUserId": "1190965", "Tags": "<c++><templates><inheritance><scope>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32621370_32621475_0": {"length": 27, "quality": 0.84375, "section_id": 190}, "so_32621370_32621475_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 190}}, "n3337": {"so_32621370_32621475_0": {"length": 27, "quality": 0.84375, "section_id": 184}, "so_32621370_32621475_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 184}}, "n4659": {"so_32621370_32621475_0": {"length": 22, "quality": 0.6875, "section_id": 195}, "so_32621370_32621475_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 195}}}, "32621460": {"Id": "32621460", "PostTypeId": "2", "Body": "<p>Apparently, this is due to the compiler's order of semantic compilation phases. It happens that, to the compiler's view, the symbol <code>type</code> is not present in any scope, because it hasn't (yet) instantiated templates, and thus, it hasn't instantiated <code>D</code> itself.</p>\n<p>The only workaround is to force the compiler to resolve the symbol in a later phase of semantic compilation, such as with...</p>\n<pre><code>void f(typename B&lt;T&gt;::type) {}\n</code></pre>\n<p>Or, if the derived class is <em>not</em> a template, but the base class is, the compiler is <em>forced</em> to resolve/instantiate/whatever the base class first, thus avoiding any possible errors inside the derived class.</p>\n<p>But this is not the case if <em>both</em> base and derived are templates, because the compiler will look-up a symbol for the derived in all already instantiated scopes (such as the global scope) <strong>before</strong> instantiating the derived template class, and if it fails, well you already know what happens with <code>int main(){printf(\"%d\\n\", argc);}</code>, no?</p>\n", "LastEditorUserId": "5249858", "LastActivityDate": "2015-09-17T02:03:17.693", "Score": "1", "CreationDate": "2015-09-17T01:57:51.430", "ParentId": "32621370", "CommentCount": "0", "OwnerUserId": "5249858", "LastEditDate": "2015-09-17T02:03:17.693"}, "32621475": {"Id": "32621475", "PostTypeId": "2", "Body": "<p>Answer can be found in two places. First C++11 draft standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\"><code>N3337</code></a>:</p>\n<p>\u00a714.6.2/3</p>\n<blockquote>\n<p id=\"so_32621370_32621475_0\">In the definition of a class template or a member of a class template,\n  if a base class of the class template depends on a <em>template-parameter</em>,\n  the <strong>base class scope is not examined during unqualified name lookup</strong>\n  either at the point of definition of the class template or member or\n  during an instantiation of the class template or member. [ <em>Example:</em></p>\n<pre><code>typedef double A;\ntemplate&lt;class T&gt; class B {\n  typedef int A;\n};\ntemplate&lt;class T&gt; struct X : B&lt;T&gt; {\n  A a;              // a has type double\n};\n</code></pre>\n<p id=\"so_32621370_32621475_1\">The type name <code>A</code> in the definition of <code>X&lt;T&gt;</code> binds to the typedef\n  name defined in the global namespace scope, not to the typedef name\n  defined in the base class <code>B&lt;T&gt;</code>. \u2014 <em>end example</em> ]</p>\n</blockquote>\n<p><sup>(Bold emphasis mine)</sup></p>\n<p>Second, the parashift FAQ provides a human-readable explanation in <a href=\"https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-types\" rel=\"nofollow\">Why am I getting errors when my template-derived-class uses a nested type it inherits from its template-base-class?</a>:</p>\n<blockquote>\n<p id=\"so_32621370_32621475_2\">Perhaps surprisingly, the following code is not valid C++, even though\n  some compilers accept it:</p>\n<pre><code>template&lt;typename T&gt;\nclass B {\npublic:\n  class Xyz { /*...*/ };  // Type nested in class B&lt;T&gt;\n  typedef int Pqr;        // Type nested in class B&lt;T&gt;\n};\ntemplate&lt;typename T&gt;\nclass D : public B&lt;T&gt; {\npublic:\n  void g()\n  {\n    Xyz x;  // Bad (even though some compilers erroneously (temporarily?) accept it)\n    Pqr y;  // Bad (even though some compilers erroneously (temporarily?) accept it)\n  }\n};\n</code></pre>\n<p id=\"so_32621370_32621475_3\">This might hurt your head; better if you sit down.</p>\n<p id=\"so_32621370_32621475_4\">Within <code>D&lt;T&gt;::g()</code>, name <code>Xyz</code> and <code>Pqr</code> do not depend on template parameter\n  T, so they are known as a nondependent names. On the other hand, <code>B&lt;T&gt;</code>\n  is dependent on template parameter <code>T</code> so <code>B&lt;T&gt;</code> is called a dependent\n  name.</p>\n<p id=\"so_32621370_32621475_5\">Here\u2019s the rule: the compiler does not look in dependent base classes\n  (like <code>B&lt;T&gt;</code>) when looking up nondependent names (like <code>Xyz</code> or <code>Pqr</code>). As a\n  result, the compiler does not know they even exist let alone are\n  types.</p>\n<p id=\"so_32621370_32621475_6\">At this point, programmers sometimes prefix them with <code>B&lt;T&gt;::</code>, such as:</p>\n<pre><code>template&lt;typename T&gt;\nclass D : public B&lt;T&gt; {\npublic:\n  void g()\n  {\n    B&lt;T&gt;::Xyz x;  // Bad (even though some compilers erroneously (temporarily?) accept it)\n    B&lt;T&gt;::Pqr y;  // Bad (even though some compilers erroneously (temporarily?) accept it)\n  }\n};\n</code></pre>\n<p id=\"so_32621370_32621475_7\">Unfortunately this doesn\u2019t work either because those names (are you\n  ready? are you sitting down?) are not necessarily types. \u201cHuh?!?\u201d you\n  say. \u201cNot types?!?\u201d you exclaim. \u201cThat\u2019s crazy; any fool can SEE they\n  are types; just look!!!\u201d you protest. Sorry, the fact is that they\n  might not be types. The reason is that there can be a specialization\n  of <code>B&lt;T&gt;</code>, say <code>B&lt;Foo&gt;</code>, where <code>B&lt;Foo&gt;::Xyz</code> is a data member, for example.\n  Because of this potential specialization, the compiler cannot assume\n  that <code>B&lt;T&gt;::Xyz</code> is a type until it knows <code>T</code>. The solution is to give the\n  compiler a hint via the <code>typename</code> keyword:</p>\n<pre><code>template&lt;typename T&gt;\nclass D : public B&lt;T&gt; {\npublic:\n  void g()\n  {\n    typename B&lt;T&gt;::Xyz x;  // Good\n    typename B&lt;T&gt;::Pqr y;  // Good\n  }\n};\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "5344691", "LastActivityDate": "2015-09-17T02:05:16.577", "Score": "4", "CreationDate": "2015-09-17T01:59:59.863", "ParentId": "32621370", "CommentCount": "0", "OwnerUserId": "5344691", "LastEditDate": "2015-09-17T02:05:16.577"}});