post_cb({"13484670": {"ParentId": "13484308", "CommentCount": "0", "CreationDate": "2012-11-21T00:45:23.807", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13484670", "Score": "3", "Body": "<p>Here is what the standard says about this. First, in 8.3.6 [dcl.fct.default] paragraph 5:</p>\n<blockquote>\n<p id=\"so_13484308_13484670_0\">... The names in the default argument are bound, and the semantic constraints are checked, at the point where the default argument appears. Name lookup and checking of semantic constraints for default arguments in function templates and in member functions of class templates are performed as described in 14.7.1. ...</p>\n</blockquote>\n<p>Further in 14.7.1 [temp.inst] paragraph 12:</p>\n<blockquote>\n<p id=\"so_13484308_13484670_1\">If a function template f is called in a way that requires a default argument to be used, the dependent names are looked up, the semantics constraints are checked, and the instantiation of any template used in the default argument is done as if the default argument had been an initializer used in a function template specialization with the same scope, the same template parameters and the same access as that of the function template f\n  used at that point. This analysis is called default argument instantiation. The instantiated default argument is then used as the argument of f.</p>\n</blockquote>\n<p>I'm not quite sure what this exactly says. I can see both interpretations in this text. In case it matters, I think EDG agrees with gcc and clang.</p>\n", "LastActivityDate": "2012-11-21T00:45:23.807"}, "13484778": {"ParentId": "13484308", "CommentCount": "2", "CreationDate": "2012-11-21T00:57:05.097", "OwnerUserId": "722294", "PostTypeId": "2", "Id": "13484778", "Score": "6", "Body": "<p>This program suggests that the set of functions considered follows normal overload resolution rules:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct type1 {};\nstruct type2 {};\n\nint foo(type1 x)\n{\n  std::cout &lt;&lt; \"foo(type1)\" &lt;&lt; std::endl;\n  return 0;\n}\n\ntemplate&lt;typename T&gt;\nvoid bar(int x = foo(T())) {}\n\nint foo(type2 x)\n{\n  std::cout &lt;&lt; \"foo(type2)\" &lt;&lt; std::endl;\n  return 0;\n}\n\nint main()\n{\n  bar&lt;type1&gt;();\n  bar&lt;type2&gt;();\n  return 0;\n}\n</code></pre>\n<p>When compiled with <code>g++-4.6</code>, this program outputs:</p>\n<pre><code>$ g++ test_2.cpp ; ./a.out \nfoo(type1)\nfoo(type2)\n</code></pre>\n<p>In other words, <code>foo</code> is resolved via ADL when <code>bar</code> is instantiated.</p>\n<p>The behavior for the code from the OP seems to be that ADL does not apply to primitives such as <code>int</code> and <code>double</code>, so the only overloads considered are those declared before <code>foo</code>'s call. The odd MSVC behavior seems to be non-standard.</p>\n", "LastActivityDate": "2012-11-21T00:57:05.097"}, "13484698": {"ParentId": "13484308", "CommentCount": "1", "CreationDate": "2012-11-21T00:48:40.217", "OwnerUserId": "1835706", "PostTypeId": "2", "Id": "13484698", "Score": "1", "Body": "<p>Maybe it's because you declared&amp;defined the overloaded function \"foo(double)\" after the template, so it doesn't know anything about its existence . -&gt;structured programming.\nI'd suggest:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(int x)\n{\nstd::cout &lt;&lt; \"foo(int)\" &lt;&lt; std::endl;\n  return 0;\n}\n\ndouble foo(double x)\n{\nstd::cout &lt;&lt; \"foo(double)\" &lt;&lt; std::endl;\nreturn 0;\n}\n\ntemplate&lt;typename T&gt;\nvoid bar(T a, int x = foo(T(0))) {}\n\n\n\nint main()\n{\nbar&lt;int&gt;(1);\nbar&lt;double&gt;(1);\nreturn 0; \n}\n</code></pre>\n", "LastActivityDate": "2012-11-21T00:48:40.217"}, "bq_ids": {"n4140": {"so_13484308_13484670_0": {"section_id": 3256, "quality": 0.9310344827586207, "length": 27}, "so_13484308_13484670_1": {"section_id": 245, "quality": 0.9375, "length": 45}}, "n3337": {"so_13484308_13484670_0": {"section_id": 3128, "quality": 0.9310344827586207, "length": 27}, "so_13484308_13484670_1": {"section_id": 237, "quality": 0.9375, "length": 45}}, "n4659": {"so_13484308_13484670_0": {"section_id": 4014, "quality": 0.9310344827586207, "length": 27}, "so_13484308_13484670_1": {"section_id": 252, "quality": 0.9375, "length": 45}}}, "13484308": {"CommentCount": "5", "AcceptedAnswerId": "13484670", "PostTypeId": "1", "LastEditorUserId": "722294", "CreationDate": "2012-11-21T00:00:26.500", "LastActivityDate": "2012-11-21T00:57:05.097", "LastEditDate": "2012-11-21T00:09:16.217", "ViewCount": "235", "FavoriteCount": "1", "Title": "What set of functions is considered when resolving overloaded functions assigning to default parameter values?", "Id": "13484308", "Score": "13", "Body": "<p>Consider the function <code>bar</code> below, whose parameter has a default value initialized from an invocation of an overloaded <code>foo</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(int x)\n{\n  std::cout &lt;&lt; \"foo(int)\" &lt;&lt; std::endl;\n  return 0;\n}\n\ntemplate&lt;typename T&gt;\nvoid bar(T a, int x = foo(T(0))) {}\n\ndouble foo(double x)\n{\n  std::cout &lt;&lt; \"foo(double)\" &lt;&lt; std::endl;\n  return 0;\n}\n\nint main()\n{\n  bar&lt;int&gt;(1);\n  bar&lt;double&gt;(1);\n  return 0;\n}\n</code></pre>\n<p>I expect this program to output</p>\n<pre><code>foo(int)\nfoo(double)\n</code></pre>\n<p>corresponding to <code>foo</code>'s two overloads which are visible at <code>bar</code>'s instantiation.</p>\n<p>Instead, when compiled with <code>g++-4.6</code>, the output is</p>\n<pre><code>$ g++-4.6 -std=c++0x test.cpp; ./a.out \nfoo(int)\nfoo(int)\n</code></pre>\n<p>Is the set of overloads considered when implementing a default parameter value different from normal overload resolution? Is this case described in the ISO C++ standard?</p>\n", "Tags": "<c++><overloading>", "OwnerUserId": "722294", "AnswerCount": "3"}});