post_cb({"4171828": {"Id": "4171828", "PostTypeId": "2", "Body": "<p>You must seekp between changing from reads to writes (and vice versa, using seekg).  It appears your implementation allows you to avoid this some of the time.  (You're probably running into implicit flushes or other buffer manipulation which hide the problem sometimes.)</p>\n<h3>C++03, \u00a727.5.1p1, Stream buffer requirements</h3>\n<blockquote>\n<p id=\"so_4171652_4171828_0\">The controlled sequences can impose limitations on how the program can read characters from a\n  sequence, write characters to a sequence, put characters back into an input sequence, or alter the stream\n  position.</p>\n</blockquote>\n<p>This just generally states these aspects are controlled by the specific stream buffer.</p>\n<h3>C++03, \u00a727.8.1.1p2, Class template basic_filebuf</h3>\n<blockquote>\n<p id=\"so_4171652_4171828_1\">The restrictions on reading and writing a sequence controlled by an object of class\n  basic_filebuf&lt;charT,traits&gt; are the same as for reading and writing with the Standard C library\n  FILEs.</p>\n</blockquote>\n<p>fstream, ifstream, and ofstream use filebufs.</p>\n<h3>C99, \u00a77.19.5.3p6, The fopen function</h3>\n<blockquote>\n<p id=\"so_4171652_4171828_2\">When a file is opened with update mode ('+' as the second or third character in the above list of mode argument values), both input and output may be performed on the associated stream. However, output shall not be directly followed by input without an intervening call to the fflush function or to a file positioning function (fseek, fsetpos, or rewind), and input shall not be directly followed by output without an intervening call to a file positioning function, unless the input operation encounters end-of-file.</p>\n</blockquote>\n<p>You may need to look up these calls to translate to iostreams terminology, but it is fairly straight-forward.</p>\n<hr>\n<p>You sometimes free the result of EnDeCrypt and sometimes delete it (but with single-object delete and not the array form); this most likely doesn't contribute to the problem you see, but it's either an error on your part or, less likely, on the part of the designer of EnDeCrypt.</p>\n<hr>\n<p>You're using:</p>\n<pre><code>char* encryptionChunkBuffer = new char[2048]; //2KB chunk buffer\n//...\ngetStream().read(encryptionChunkBuffer,2048);\n//...\ndelete[] encryptionChunkBuffer;\n</code></pre>\n<p>But it would be better and easier to use:</p>\n<pre><code>vector&lt;char&gt; encryptionChunkBuffer (2048); //2KB chunk buffer\n//...\ngetStream().read(&amp;encryptionChunkBuffer[0], encryptionChunkBuffer.size());\n//...\n// no delete\n</code></pre>\n<p>If you don't want to type encryptionChunkBuffer.size() twice, then use a local constant for it.</p>\n</hr></hr>", "LastEditorDisplayName": "Roger Pate", "OwnerDisplayName": "Roger Pate", "LastActivityDate": "2010-11-13T10:36:52.233", "Score": "1", "CreationDate": "2010-11-13T09:23:54.743", "ParentId": "4171652", "CommentCount": "0", "LastEditDate": "2010-11-13T10:36:52.233"}, "bq_ids": {"n4140": {"so_4171652_4171828_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 2086}, "so_4171652_4171828_1": {"length": 12, "quality": 0.8, "section_id": 2412}}, "n3337": {"so_4171652_4171828_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 2074}, "so_4171652_4171828_1": {"length": 12, "quality": 0.8, "section_id": 2397}}, "n4659": {"so_4171652_4171828_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 2359}, "so_4171652_4171828_1": {"length": 12, "quality": 0.8, "section_id": 2687}}}, "4171652": {"ViewCount": "886", "Body": "<p>I've been trying to debug my code for the past few hours and I couldn't figure out the problem. I eventually set my filestream to throw exceptions on <code>failbit</code> and I found that my filestream was setting the failbit for some reason. I have absolutely no reason why the failbit is being set, because all I'm doing is writing 2048-byte chunks of data to the stream until suddenly it fails (at the same spot each time).</p>\n<p>I would like to show you my code to see if anyone can see a problem and possibly see what might cause a std::ios::failure to be thrown:</p>\n<pre><code>bool abstractBlock::encryptBlockRC4(char* key)\n{//Thic encryption method can be chunked :)\n getStream().seekg(0,std::ios::end);\n int sLen = int(getStream().tellg())-this-&gt;headerSize;\n seekg(0);//Seek to beginning of Data\n seekp(0);\n char* encryptionChunkBuffer = new char[2048]; //2KB chunk buffer\n for (int chunkIterator =0; chunkIterator&lt;sLen; chunkIterator+=2048)\n {\n  if (chunkIterator+2048&lt;=sLen)\n  {\n   getStream().read(encryptionChunkBuffer,2048);\n   char* encryptedData = EnDeCrypt(encryptionChunkBuffer,2048,key);\n   getStream().write(encryptedData,2048);\n   free(encryptedData);\n  }else{\n   int restLen = sLen-chunkIterator;\n   getStream().read(encryptionChunkBuffer,restLen);\n   char* encryptedData = EnDeCrypt(encryptionChunkBuffer,restLen,key);\n   getStream().write(encryptedData,restLen);\n   delete  encryptedData;\n  }\n }\n delete [] encryptionChunkBuffer;\n dataFlags |= DATA_ENCRYPTED_RC4; // Set the \"encryted (rc4)\" bit\n seekp(0); //Seek tp beginning of Data\n seekg(0); //Seek tp beginning of Data\n return true;\n}\n</code></pre>\n<p>The above code is essentially encrypting a file using 2048 chunks. It basically reads 2048 bytes, encrypts it and then writes it back to the stream (overwrites the \"unencrypted\" data that was previously there).\n<code>getStream()</code> is simply returning the fstream handle to the file thats being operated on.</p>\n<p>The error always occurs when chunkIterator==86116352 on the line <code>getStream().write(encryptedData,2048);</code></p>\n<p>I know my code may be hard to decode, but maybe you can tell me some possible things that might trigger a failbit? Currently, I think that the problem lies within the fact that I an reading/writing to a stream and it may be causing problems, but as I mentioned any ideas that can cause a failbit would maybe help me investigate the problem more.</p>\n", "AcceptedAnswerId": "4171828", "Title": "std::ios::failue (ios::badbit) problem with fstream.write()", "CreationDate": "2010-11-13T08:32:03.027", "Id": "4171652", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-11-13T10:36:52.233", "Score": "2", "OwnerUserId": "472966", "Tags": "<c++><exception><stl><file-io><stream>", "AnswerCount": "1"}});