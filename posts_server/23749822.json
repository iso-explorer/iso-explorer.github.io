post_cb({"23749822": {"CommentCount": "7", "AcceptedAnswerId": "23749908", "PostTypeId": "1", "LastEditorUserId": "2052436", "CreationDate": "2014-05-20T01:52:45.657", "LastActivityDate": "2014-05-20T04:00:55.420", "LastEditDate": "2014-05-20T02:00:35.577", "ViewCount": "451", "FavoriteCount": "1", "Title": "Is size_t guaranteed to be an alias type to one of integer types?", "Id": "23749822", "Score": "6", "Body": "<p>Or can it be a separate unsigned integer type?</p>\n<p>I have different specializations of a template function for different (unsigned) integer types. Do I need to provide a separate specialization for <code>size_t</code>?</p>\n", "Tags": "<c++><types><typedef>", "OwnerUserId": "2052436", "AnswerCount": "3"}, "23749989": {"ParentId": "23749822", "CommentCount": "0", "CreationDate": "2014-05-20T02:16:56.783", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "23749989", "Score": "1", "Body": "<p>Text from <code>[support.types]</code>:</p>\n<blockquote>\n<p id=\"so_23749822_23749989_0\">The contents are the same as the Standard C library header , with the following changes:</p>\n<p id=\"so_23749822_23749989_1\">The type size_t is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object.</p>\n</blockquote>\n<p>From the C99 specification of stddef.h there is also this footnote for clarification:</p>\n<blockquote>\n<p id=\"so_23749822_23749989_2\">224) Some of these types may denote implementation-defined extended integer types.</p>\n</blockquote>\n<p>Since the C++ standard text does not specifically say that <code>size_t</code> must be a typedef, and since it appears to be based on C99, it seems to me that we should conclude that it may be an implementation-defined extended integer type.</p>\n<p>Having said that, I don't know of any implementation for which it is not a typedef.</p>\n<p>I'm not sure what you should do about your overload problem, however note that it is not limited just to <code>size_t</code>; there is also <code>ptrdiff_t</code>, and all of the fixed-width integer types. The latter are specified as being <code>typedef</code>s, however they are allowed to be aliases for extended integer types. </p>\n", "LastActivityDate": "2014-05-20T02:16:56.783"}, "23749870": {"ParentId": "23749822", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-05-20T01:57:51.887", "Score": "0", "LastEditorUserId": "1390091", "LastEditDate": "2014-05-20T02:07:37.867", "Id": "23749870", "OwnerUserId": "1390091", "Body": "<p>From the standard (\u00a7 18.2) from <strong>N3797</strong> published on 13.10.2013:</p>\n<blockquote>\n<p id=\"so_23749822_23749870_0\">The type size_t is an implementation-defined unsigned integer type that is large enough to contain the \n      size in bytes of any object.</p>\n</blockquote>\n<p>So it must be an <em>unsigned</em> integral type, but the actual size is implementation defined.</p>\n", "LastActivityDate": "2014-05-20T02:07:37.867"}, "bq_ids": {"n4140": {"so_23749822_23749908_1": {"section_id": 6708, "quality": 0.7857142857142857, "length": 11}, "so_23749822_23749989_1": {"section_id": 6708, "quality": 0.8461538461538461, "length": 11}, "so_23749822_23749989_0": {"section_id": 4270, "quality": 0.75, "length": 6}, "so_23749822_23749908_2": {"section_id": 6709, "quality": 0.8148148148148148, "length": 22}, "so_23749822_23749908_0": {"section_id": 4270, "quality": 0.6666666666666666, "length": 6}, "so_23749822_23749989_2": {"section_id": 7211, "quality": 0.5555555555555556, "length": 5}, "so_23749822_23749870_0": {"section_id": 6708, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_23749822_23749908_1": {"section_id": 6463, "quality": 0.7857142857142857, "length": 11}, "so_23749822_23749989_1": {"section_id": 6463, "quality": 0.8461538461538461, "length": 11}, "so_23749822_23749989_0": {"section_id": 4111, "quality": 0.75, "length": 6}, "so_23749822_23749908_2": {"section_id": 6464, "quality": 0.8148148148148148, "length": 22}, "so_23749822_23749908_0": {"section_id": 4111, "quality": 0.6666666666666666, "length": 6}, "so_23749822_23749989_2": {"section_id": 6955, "quality": 0.5555555555555556, "length": 5}, "so_23749822_23749870_0": {"section_id": 6463, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_23749822_23749908_1": {"section_id": 8183, "quality": 0.7857142857142857, "length": 11}, "so_23749822_23749908_2": {"section_id": 8184, "quality": 0.8148148148148148, "length": 22}, "so_23749822_23749989_0": {"section_id": 3233, "quality": 0.75, "length": 6}, "so_23749822_23749989_1": {"section_id": 8183, "quality": 0.8461538461538461, "length": 11}, "so_23749822_23749908_0": {"section_id": 3233, "quality": 0.6666666666666666, "length": 6}, "so_23749822_23749870_0": {"section_id": 8183, "quality": 0.8461538461538461, "length": 11}}}, "23749908": {"ParentId": "23749822", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-05-20T02:05:29.577", "Score": "6", "LastEditorUserId": "410767", "LastEditDate": "2014-05-20T02:13:12.953", "Id": "23749908", "OwnerUserId": "410767", "Body": "<p>The C++ Standard says:</p>\n<blockquote>\n<p id=\"so_23749822_23749908_0\">18.2/2 The contents are the same as the Standard C library header , with the following changes:</p>\n<p id=\"so_23749822_23749908_1\">18.2/6 The type size_t is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object.</p>\n<p id=\"so_23749822_23749908_2\">18.2/7 [ Note: It is recommended that implementations choose types for ptrdiff_t and size_t whose integer\n  conversion ranks (4.13) are no greater than that of signed long int unless a larger size is necessary to\n  contain all the possible values. \u2014end note ]</p>\n</blockquote>\n<p>So, it <em>doesn't</em> say explicitly whether the implementation-defined unsigned integer type will be one of <code>unsigned short</code>, <code>int</code>, <code>long</code>, <code>long long</code>.  The fact that 18.2/6 exists and specifies an \"implementation-defined unsigned integer type\" may be seen to override 18.2/2's default of following C, so any answer for C can't be trusted for C++.</p>\n<p>The recommendation re conversion ranks implies the <code>size_t</code> will be expected to be one of the types mentioned in 4.13, where <code>size_t</code> isn't explicitly mentioned but the obvious candidates are, but that's no guarantee.</p>\n<blockquote>\n<p id=\"so_23749822_23749908_3\">Do I need to provide a separate specialization for size_t?</p>\n</blockquote>\n<p>You could use <code>std::is_same</code> and <code>std::enable_if</code> to do so when <code>size_t</code> is a distinct type....</p>\n", "LastActivityDate": "2014-05-20T02:13:12.953"}});