post_cb({"17299151": {"ParentId": "318064", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>In C++11 you can easily avoid inheritance altogether:</p>\n<pre><code>struct Interface {\n  explicit Interface(SomeType&amp; other)\n  : foo([=](){ return other.my_foo(); }), \n    bar([=](){ return other.my_bar(); }), /*...*/ {}\n  explicit Interface(SomeOtherType&amp; other)\n  : foo([=](){ return other.some_foo(); }), \n    bar([=](){ return other.some_bar(); }), /*...*/ {}\n  // you can add more types here...\n\n  // or use a generic constructor:\n  template&lt;class T&gt;\n  explicit Interface(T&amp; other)\n  : foo([=](){ return other.foo(); }), \n    bar([=](){ return other.bar(); }), /*...*/ {}\n\n  const std::function&lt;void(std::string)&gt; foo;\n  const std::function&lt;void(std::string)&gt; bar;\n  // ...\n};\n</code></pre>\n<p>In this case, an Interface has reference semantics, i.e. you have to make sure that the object outlives the interface (it is also possible to make interfaces with value semantics). </p>\n<p>These type of interfaces have their pros and cons: </p>\n<ul>\n<li>They <a href=\"http://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/\" rel=\"nofollow noreferrer\">require more memory</a> than inheritance based polymorphism. </li>\n<li>They <a href=\"http://probablydance.com/2013/01/13/a-faster-implementation-of-stdfunction/\" rel=\"nofollow noreferrer\">are in general faster</a> than inheritance based polymorphism.</li>\n<li>In those cases in which you know the final type, <a href=\"https://stackoverflow.com/questions/14922890/whats-the-cost-of-calling-a-virtual-function-in-a-non-polymorphic-way\">they are much faster!</a> (some compilers like gcc and clang perform more optimizations in types that do not have/inherit from types with virtual functions).</li>\n</ul>\n<p>Finally, inheritance is the root of all evil in complex software design. In <a href=\"http://www.youtube.com/watch?v=_BpMYeUFXv8\" rel=\"nofollow noreferrer\">Sean Parent's Value Semantics and Concepts-based Polymorphism</a> (highly recommended, better versions of this technique are explained there) the following case is studied:</p>\n<p>Say I have an application in which I deal with my shapes polymorphically using the <code>MyShape</code> interface:</p>\n<pre><code>struct MyShape { virtual void my_draw() = 0; };\nstruct Circle : MyShape { void my_draw() { /* ... */ } };\n// more shapes: e.g. triangle\n</code></pre>\n<p>In your application, you do the same with different shapes using the <code>YourShape</code> interface:</p>\n<pre><code>struct YourShape { virtual void your_draw() = 0; };\nstruct Square : YourShape { void your_draw() { /* ... */ } };\n/// some more shapes here...\n</code></pre>\n<p>Now say you want to use some of the shapes that I've developed in your application. Conceptually, our shapes have the same interface, but to make my shapes work in your application you would need to extend my shapes as follows:</p>\n<pre><code>struct Circle : MyShape, YourShape { \n  void my_draw() { /*stays the same*/ };\n  void your_draw() { my_draw(); }\n};\n</code></pre>\n<p>First, modifying my shapes might not be possible at all. Furthermore, multiple inheritance leads the road to spaghetti code (imagine a third project comes in that is using the <code>TheirShape</code> interface... what happens if they also call their draw function <code>my_draw</code> ?).</p>\n<p>Update: There are a couple of new references about non-inheritance based polymorphism:</p>\n<ul>\n<li>Sean Parent's <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil\" rel=\"nofollow noreferrer\">Inheritance is the base class of evil</a> talk.</li>\n<li>Sean Parent's <a href=\"https://www.youtube.com/watch?v=_BpMYeUFXv8\" rel=\"nofollow noreferrer\">Value-semantics and concept-based polymorphism</a> talk.</li>\n<li>Pyry Jahkola's <a href=\"https://www.youtube.com/watch?v=y54sKDKrDX8\" rel=\"nofollow noreferrer\">Inheritance free polymorphism</a> talk and the <a href=\"https://github.com/pyrtsa/poly\" rel=\"nofollow noreferrer\">poly library docs</a>.</li>\n<li>Zach Laine's <a href=\"https://www.youtube.com/watch?v=0I0FD3N5cgM\" rel=\"nofollow noreferrer\">Pragmatic Type Erasure: Solving OOP Problems with an Elegant Design Pattern</a> talk.</li>\n<li>Andrzej's C++ blog - Type Erasure parts <a href=\"http://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/\" rel=\"nofollow noreferrer\">i</a>, <a href=\"http://akrzemi1.wordpress.com/2013/12/06/type-erasure-part-ii/\" rel=\"nofollow noreferrer\">ii</a>, <a href=\"http://akrzemi1.wordpress.com/2013/12/11/type-erasure-part-iii/\" rel=\"nofollow noreferrer\">iii</a>, and <a href=\"http://akrzemi1.wordpress.com/2014/01/13/type-erasure-part-iv/\" rel=\"nofollow noreferrer\">iv</a>.</li>\n<li><a href=\"http://akrzemi1.files.wordpress.com/2013/10/mpool2007-marcus.pdf\" rel=\"nofollow noreferrer\">Runtime Polymorphic Generic Programming\u2014Mixing Objects and Concepts in ConceptC++</a></li>\n<li><a href=\"http://www.boost.org/doc/libs/1_56_0/doc/html/boost_typeerasure.html\" rel=\"nofollow noreferrer\">Boost.TypeErasure docs</a></li>\n<li><a href=\"http://stlab.adobe.com/group__poly__related.html\" rel=\"nofollow noreferrer\">Adobe Poly docs</a></li>\n<li><a href=\"http://www.boost.org/doc/libs/1_56_0/doc/html/any.html\" rel=\"nofollow noreferrer\">Boost.Any</a>, <a href=\"http://www.open-std.org/JTC1/sc22/WG21/docs/papers/2013/n3804.html\" rel=\"nofollow noreferrer\">std::any proposal (revision 3)</a>, <a href=\"http://www.boost.org/doc/libs/1_51_0/boost/spirit/home/support/detail/hold_any.hpp\" rel=\"nofollow noreferrer\">Boost.Spirit::hold_any</a>.</li>\n</ul>\n", "OwnerUserId": "1422197", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:31:37.937", "Id": "17299151", "Score": "7", "CreationDate": "2013-06-25T13:51:08.947", "LastActivityDate": "2014-10-16T09:08:02.407"}, "318105": {"CommentCount": "12", "CreationDate": "2008-11-25T17:01:06.327", "LastEditorUserId": "545127", "LastActivityDate": "2017-11-28T14:40:35.177", "ParentId": "318064", "PostTypeId": "2", "LastEditorDisplayName": "Joel Coehoorn", "LastEditDate": "2017-11-28T14:40:35.177", "Id": "318105", "Score": "117", "Body": "<p>The whole reason you have a special Interface type-category in addition to abstract base classes in C#/<a href=\"https://stackoverflow.com/questions/1321122/what-is-an-interface-in-java\">Java</a> is because C#/Java do not support multiple inheritance.  </p>\n<p>C++ supports multiple inheritance, and so a special type isn't needed.  An abstract base class with no non-abstract (pure virtual) methods is functionally equivalent to a C#/Java interface.</p>\n", "OwnerUserId": "3043", "OwnerDisplayName": "Joel Coehoorn"}, "318202": {"CommentCount": "7", "CreationDate": "2008-11-25T17:27:01.813", "LastEditorUserId": "1705337", "LastActivityDate": "2017-07-28T19:56:22.980", "ParentId": "318064", "PostTypeId": "2", "LastEditorDisplayName": "Dima", "LastEditDate": "2017-07-28T19:56:22.980", "Id": "318202", "Score": "38", "Body": "<p>There is no concept of \"interface\" per se in C++.  AFAIK, interfaces were first introduced in Java to work around the lack of multiple inheritance.  This concept has turned out to be quite useful, and the same effect can be achieved in C++ by using an abstract base class.</p>\n<p>An abstract base class is a class in which at least one member function (method in Java lingo) is a pure virtual function declared using the following syntax:</p>\n<pre><code>class A\n{\n  virtual void foo() = 0;\n};\n</code></pre>\n<p>An abstract base class cannot be instantiated, i. e. you cannot declare an object of class A. You can only derive classes from A, but any derived class that does not provide an implementation of <code>foo()</code> will also be abstract.  In order to stop being abstract, a derived class must provide implementations for all pure virtual functions it inherits.</p>\n<p>Note that an abstract base class can be more than an interface, because it can contain data members and member functions that are not pure virtual. An equivalent of an interface would be an abstract base class without any data with only pure virtual functions.</p>\n<p>And, as Mark Ransom pointed out, an abstract base class should provide a virtual destructor, just like any base class, for that matter.</p>\n", "OwnerUserId": "13313", "OwnerDisplayName": "Dima"}, "20685876": {"ParentId": "318064", "CommentCount": "1", "Body": "<pre><code>class Shape \n{\npublic:\n   // pure virtual function providing interface framework.\n   virtual int getArea() = 0;\n   void setWidth(int w)\n   {\n      width = w;\n   }\n   void setHeight(int h)\n   {\n      height = h;\n   }\nprotected:\n    int width;\n    int height;\n};\n\nclass Rectangle: public Shape\n{\npublic:\n    int getArea()\n    { \n        return (width * height); \n    }\n};\nclass Triangle: public Shape\n{\npublic:\n    int getArea()\n    { \n        return (width * height)/2; \n    }\n};\n\nint main(void)\n{\n     Rectangle Rect;\n     Triangle  Tri;\n\n     Rect.setWidth(5);\n     Rect.setHeight(7);\n\n     cout &lt;&lt; \"Rectangle area: \" &lt;&lt; Rect.getArea() &lt;&lt; endl;\n\n     Tri.setWidth(5);\n     Tri.setHeight(7);\n\n     cout &lt;&lt; \"Triangle area: \" &lt;&lt; Tri.getArea() &lt;&lt; endl; \n\n     return 0;\n}\n</code></pre>\n<p>Result:\nRectangle area: 35\nTriangle area: 17</p>\n<p>We have seen how an abstract class defined an interface in terms of getArea() and two other classes implemented same function but with different algorithm to calculate the area specific to the shape.</p>\n", "OwnerUserId": "1302665", "PostTypeId": "2", "Id": "20685876", "Score": "-1", "CreationDate": "2013-12-19T15:45:41.140", "LastActivityDate": "2013-12-19T15:45:41.140"}, "9571456": {"ParentId": "318064", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>As far I could test, it is very important to add the virtual destructor. I'm using objects created with <code>new</code> and destroyed with <code>delete</code>.</p>\n<p>If you do not add the virtual destructor in the interface, then the destructor of the inherited class is not called.</p>\n<pre><code>class IBase {\npublic:\n    virtual ~IBase() {}; // destructor, use it to call destructor of the inherit classes\n    virtual void Describe() = 0; // pure virtual method\n};\n\nclass Tester : public IBase {\npublic:\n    Tester(std::string name);\n    virtual ~Tester();\n    virtual void Describe();\nprivate:\n    std::string privatename;\n};\n\nTester::Tester(std::string name) {\n    std::cout &lt;&lt; \"Tester constructor\" &lt;&lt; std::endl;\n    this-&gt;privatename = name;\n}\n\nTester::~Tester() {\n    std::cout &lt;&lt; \"Tester destructor\" &lt;&lt; std::endl;\n}\n\nvoid Tester::Describe() {\n    std::cout &lt;&lt; \"I'm Tester [\" &lt;&lt; this-&gt;privatename &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n\n\nvoid descriptor(IBase * obj) {\n    obj-&gt;Describe();\n}\n\nint main(int argc, char** argv) {\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Tester Testing...\" &lt;&lt; std::endl;\n    Tester * obj1 = new Tester(\"Declared with Tester\");\n    descriptor(obj1);\n    delete obj1;\n\n    std::cout &lt;&lt; std::endl &lt;&lt; \"IBase Testing...\" &lt;&lt; std::endl;\n    IBase * obj2 = new Tester(\"Declared with IBase\");\n    descriptor(obj2);\n    delete obj2;\n\n    // this is a bad usage of the object since it is created with \"new\" but there are no \"delete\"\n    std::cout &lt;&lt; std::endl &lt;&lt; \"Tester not defined...\" &lt;&lt; std::endl;\n    descriptor(new Tester(\"Not defined\"));\n\n\n    return 0;\n}\n</code></pre>\n<p>If you run the previous code without <code>virtual ~IBase() {};</code>, you will see that the destructor <code>Tester::~Tester()</code> is never called.</p>\n", "OwnerUserId": "1229689", "LastEditorUserId": "1951907", "LastEditDate": "2013-07-06T08:20:40.220", "Id": "9571456", "Score": "36", "CreationDate": "2012-03-05T17:53:12.867", "LastActivityDate": "2013-07-06T08:20:40.220"}, "47148505": {"ParentId": "318064", "CommentCount": "0", "Body": "<p>Here is the definition of <code>abstract class</code> in c++ standard</p>\n<p>n4687</p>\n<p><strong>13.4.2</strong></p>\n<blockquote>\n<p id=\"so_318064_47148505_0\">An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract\n  class can be created except as subobjects of a class derived from it. A class is abstract if it has at least\n  one pure virtual function. </p>\n</blockquote>\n", "OwnerUserId": "6949852", "PostTypeId": "2", "Id": "47148505", "Score": "0", "CreationDate": "2017-11-07T01:22:20.887", "LastActivityDate": "2017-11-07T01:22:20.887"}, "318084": {"CommentCount": "7", "CreationDate": "2008-11-25T16:53:31.350", "LastEditorUserId": "273085", "LastActivityDate": "2016-08-24T16:58:38.730", "ParentId": "318064", "LastEditDate": "2016-08-24T16:58:38.730", "OwnerDisplayName": "bradtgmurray", "PostTypeId": "2", "Id": "318084", "Score": "216", "Body": "<p>Make a class with pure virtual methods. Use the interface by creating another class that overrides those virtual methods.</p>\n<p>A pure virtual method is a class method that is defined as virtual and assigned to 0.</p>\n<pre><code>class IDemo\n{\n    public:\n        virtual ~IDemo() {}\n        virtual void OverrideMe() = 0;\n};\n\nclass Child : public IDemo\n{\n    public:\n        virtual void OverrideMe()\n        {\n            //do stuff\n        }\n};\n</code></pre>\n", "OwnerUserId": "1546"}, "318137": {"CommentCount": "26", "CreationDate": "2008-11-25T17:11:33.763", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-05T13:47:00.177", "ParentId": "318064", "LastEditDate": "2017-05-23T12:10:45.110", "OwnerDisplayName": "Mark Ransom", "PostTypeId": "2", "Id": "318137", "Score": "594", "Body": "<p>To expand on the answer by <a href=\"https://stackoverflow.com/questions/318064/how-do-you-declare-an-interface-in-c#318084\">bradtgmurray</a>,  you may want to make one exception to the pure virtual method list of your interface by adding a virtual destructor. This allows you to pass pointer ownership to another party without exposing the concrete derived class. The destructor doesn't have to do anything, because the interface doesn't have any concrete members. It might seem contradictory to define a function as both virtual and inline, but trust me - it isn't.</p>\n<pre><code>class IDemo\n{\n    public:\n        virtual ~IDemo() {}\n        virtual void OverrideMe() = 0;\n};\n\nclass Parent\n{\n    public:\n        virtual ~Parent();\n};\n\nclass Child : public Parent, public IDemo\n{\n    public:\n        virtual void OverrideMe()\n        {\n            //do stuff\n        }\n};\n</code></pre>\n<p>You don't have to include a body for the virtual destructor - it turns out some compilers have trouble optimizing an empty destructor and you're better off using the default. </p>\n", "OwnerUserId": "5987"}, "318466": {"CommentCount": "6", "CreationDate": "2008-11-25T18:48:00.307", "LastEditorUserId": "496830", "LastActivityDate": "2011-11-01T18:03:27.513", "ParentId": "318064", "LastEditDate": "2011-11-01T18:03:27.513", "OwnerDisplayName": "Rexxar", "PostTypeId": "2", "Id": "318466", "Score": "31", "Body": "<p>My answer is basically the same as the others but I think there are two other important things to do:</p>\n<ol>\n<li><p>Declare a virtual destructor in your interface or make a protected non-virtual one to avoid undefined behaviours if someone tries to delete an object of type <code>IDemo</code>.</p></li>\n<li><p>Use virtual inheritance to avoid problems whith multiple inheritance. (There is more often multiple inheritance when we use interfaces.) </p></li>\n</ol>\n<p>And like other answers:</p>\n<ul>\n<li>Make a class with pure virtual methods.</li>\n<li><p>Use the interface by creating another class that overrides those virtual methods.</p>\n<pre><code>class IDemo\n{\n    public:\n        virtual void OverrideMe() = 0;\n        virtual ~IDemo() {}\n}\n</code></pre>\n<p>Or</p>\n<pre><code>class IDemo\n{\n    public:\n        virtual void OverrideMe() = 0;\n    protected:\n        ~IDemo() {}\n}\n</code></pre>\n<p>And   </p>\n<pre><code>class Child : virtual public IDemo\n{\n    public:\n        virtual void OverrideMe()\n        {\n            //do stuff\n        }\n}\n</code></pre></li>\n</ul>\n", "OwnerUserId": "10016"}, "318227": {"ParentId": "318064", "CommentCount": "7", "Body": "<p>A little addition to what's written up there:</p>\n<p>First, make sure your destructor is also pure virtual </p>\n<p>Second, you may want to inherit virtually (rather than normally) when you do implement, just for good measures. </p>\n", "OwnerUserId": "23072", "Id": "318227", "PostTypeId": "2", "OwnerDisplayName": "Uri", "Score": "4", "CreationDate": "2008-11-25T17:35:34.227", "LastActivityDate": "2008-11-25T17:35:34.227"}, "32811357": {"ParentId": "318064", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I'm still new in C++ development. I started with Visual Studio (VS). </p>\n<p>Yet, no one seems to mentioned the <code>__interface</code> in VS <strong>(.NET)</strong>. I am <strong>not</strong> very sure if this is a good way to declare an interface. But it seems to provide an <em>additional enforcement</em> (mentioned in <a href=\"https://msdn.microsoft.com/en-us/library/50h7kwtb.aspx\" rel=\"nofollow\">the documents</a>). Such that you don't have to explicitly specify the <code>virtual TYPE Method() = 0;</code>, since it will be automatically converted. </p>\n<pre><code>__interface IMyInterface {\n   HRESULT CommitX();\n   HRESULT get_X(BSTR* pbstrName);\n};\n</code></pre>\n<blockquote>\n<p id=\"so_318064_32811357_0\">However, I don't use it because I am concern about the cross platform compilation compatibility, since it only available under .NET.</p>\n</blockquote>\n<p>If anyone do have anything interesting about it, please share. :-)</p>\n<p>Thanks.</p>\n", "OwnerUserId": "764592", "LastEditorUserId": "764592", "LastEditDate": "2015-09-27T18:33:01.300", "Id": "32811357", "Score": "1", "CreationDate": "2015-09-27T18:27:29.060", "LastActivityDate": "2015-09-27T18:33:01.300"}, "bq_ids": {"n4140": {"so_318064_47148505_0": {"section_id": 7019, "quality": 0.96, "length": 24}}, "n3337": {"so_318064_47148505_0": {"section_id": 6765, "quality": 0.96, "length": 24}}, "n4659": {"so_318064_47148505_0": {"section_id": 8516, "quality": 0.96, "length": 24}}}, "38594093": {"ParentId": "318064", "CommentCount": "0", "Body": "<p>While it's true that <code>virtual</code> is the de-facto standard to define an interface, let's not forget about the classic C-like pattern, which comes with a constructor in C++:</p>\n<pre><code>struct IButton\n{\n    void (*click)(); // might be std::function(void()) if you prefer\n\n    IButton( void (*click_)() )\n    : click(click_)\n    {\n    }\n};\n\n// call as:\n// (button.*click)();\n</code></pre>\n<p>This has the advantage that you can re-bind events runtime without having to construct your class again (as C++ does not have a syntax for changing polymorphic types, this is a workaround for chameleon classes).</p>\n<p>Tips:</p>\n<ul>\n<li>You might inherit from this as a base class (both virtual and non-virtual are permitted) and fill <code>click</code> in your descendant's constructor.</li>\n<li>You might have the function pointer as a <code>protected</code> member and have a <code>public</code> reference and/or getter.</li>\n<li>As mentioned above, this allows you to switch the implementation in runtime. Thus it's a way to manage state as well. Depending on the number of <code>if</code>s vs. state changes in your code, this <em>might</em> be faster than <code>switch()</code>es or <code>if</code>s (turnaround is expected around 3-4 <code>if</code>s, but always measure first.</li>\n<li>If you choose <code>std::function&lt;&gt;</code> over function pointers, you <em>might</em> be able to manage all your object data within <code>IBase</code>. From this point, you can have value schematics for <code>IBase</code> (e.g., <code>std::vector&lt;IBase&gt;</code> will work). Note that this <em>might</em> be slower depending on your compiler and STL code; also that current implementations of <code>std::function&lt;&gt;</code> tend to have an overhead when compared to function pointers or even virtual functions (this might change in the future).</li>\n</ul>\n", "OwnerUserId": "6292621", "PostTypeId": "2", "Id": "38594093", "Score": "0", "CreationDate": "2016-07-26T15:29:25.433", "LastActivityDate": "2016-07-26T15:29:25.433"}, "1562554": {"ParentId": "318064", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>If you're using Microsoft's C++ compiler, then you could do the following:</p>\n<pre><code>struct __declspec(novtable) IFoo\n{\n    virtual void Bar() = 0;\n};\n\nclass Child : public IFoo\n{\npublic:\n    virtual void Bar() override { /* Do Something */ }\n}\n</code></pre>\n<p>I like this approach because it results in a lot smaller interface code and the generated code size can be significantly smaller. The use of novtable removes all reference to the vtable pointer in that class, so you can never instantiate it directly. See the documentation here - <a href=\"http://msdn.microsoft.com/en-us/library/k13k85ky.aspx\" rel=\"nofollow noreferrer\">novtable</a>.</p>\n", "OwnerUserId": "986", "LastEditorUserId": "366904", "LastEditDate": "2016-10-28T05:40:37.113", "Id": "1562554", "Score": "6", "CreationDate": "2009-10-13T19:53:38.793", "LastActivityDate": "2016-10-28T05:40:37.113"}, "318064": {"CommentCount": "0", "AcceptedAnswerId": "318137", "PostTypeId": "1", "LastEditorUserId": "63550", "LastEditorDisplayName": "Dima", "CreationDate": "2008-11-25T16:48:47.303", "LastActivityDate": "2017-11-28T14:40:35.177", "AnswerCount": "15", "LastEditDate": "2009-12-31T08:58:48.557", "ViewCount": "399039", "FavoriteCount": "275", "Title": "How do you declare an interface in C++?", "Id": "318064", "Score": "688", "Body": "<p>How do I setup a class that represents an interface?  Is this just an abstract base class?</p>\n", "Tags": "<c++><inheritance><interface><abstract-class><pure-virtual>", "OwnerUserId": "5618", "OwnerDisplayName": "Aaron Fischer"}, "318261": {"CommentCount": "2", "CreationDate": "2008-11-25T17:49:00.830", "LastEditorUserId": "15934", "LastActivityDate": "2011-11-01T14:12:26.957", "ParentId": "318064", "LastEditDate": "2011-11-01T14:12:26.957", "OwnerDisplayName": "Luc Hermitte", "PostTypeId": "2", "Id": "318261", "Score": "4", "Body": "<p>You can also consider contract classes implemented with the NVI (Non Virtual Interface Pattern). For instance:</p>\n<pre><code>struct Contract1 : boost::noncopyable\n{\n    virtual ~Contract1();\n    void f(Parameters p) {\n        assert(checkFPreconditions(p)&amp;&amp;\"Contract1::f, pre-condition failure\");\n        // + class invariants.\n        do_f(p);\n        // Check post-conditions + class invariants.\n    }\nprivate:\n    virtual void do_f(Parameters p) = 0;\n};\n...\nclass Concrete : public Contract1, public Contract2\n{\nprivate:\n    virtual void do_f(Parameters p); // From contract 1.\n    virtual void do_g(Parameters p); // From contract 2.\n};\n</code></pre>\n", "OwnerUserId": "15934"}, "319056": {"CommentCount": "2", "CreationDate": "2008-11-25T22:02:19.167", "LastEditorUserId": "10681", "LastActivityDate": "2008-12-02T20:26:36.443", "ParentId": "318064", "PostTypeId": "2", "LastEditorDisplayName": "Rodyland", "LastEditDate": "2008-12-02T20:26:36.443", "Id": "319056", "Score": "9", "Body": "<p>All good answers above.\nOne extra thing you should keep in mind - you can also have a pure virtual destructor.  The only difference is that you still need to implement it.  </p>\n<p>Confused?  </p>\n<pre><code>\n    --- header file ----\n    class foo {\n    public:\n      foo() {;}\n      virtual ~foo() = 0;\n\n      virtual bool overrideMe() {return false;}\n    };\n\n    ---- source ----\n    foo::~foo()\n    {\n    }\n\n</code></pre>\n<p>The main reason you'd want to do this is if you want to provide interface methods, as I have, but make overriding them optional.  </p>\n<p>To make the class an interface class requires a pure virtual method, but all of your virtual methods have default implementations, so the only method left to make pure virtual is the destructor.</p>\n<p>Reimplementing a destructor in the derived class is no big deal at all - I always reimplement a destructor, virtual or not, in my derived classes.</p>\n", "OwnerUserId": "10681", "OwnerDisplayName": "Rodyland"}});