post_cb({"8064616": {"CommentCount": "7", "AcceptedAnswerId": "8065951", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-11-09T11:54:00.500", "LastActivityDate": "2011-11-09T20:27:35.410", "LastEditDate": "2011-11-09T12:16:22.403", "ViewCount": "302", "FavoriteCount": "1", "Title": "Why is an initialiser containing a string literal valid to initialise a `char` array?", "Id": "8064616", "Score": "16", "Body": "<p>It turns out that <code>char c[] = {\"a\"};</code> is completely valid in both <a href=\"http://www.ideone.com/8PKkE\">C++03</a> and <a href=\"http://www.ideone.com/NBlQj\">C++11</a>.</p>\n<p>I would not expect it to be, because it is an array of <code>char</code> not of <code>char const*</code>, and I would expect a brace-initialiser to require a compatible type for each of its \"items\". It has one item, and that's a <code>char const*</code> not a <code>char</code>.</p>\n<p>So what makes this initialisation valid? And is there a rationale for it being so?</p>\n<hr>\n<p><sup>Similarly, <code>char c[] = {\"aa\"};</code> compiles, and printing <code>c</code> results in the output \"<code>aa</code>\".</sup></p>\n<p><sup>I <em>would</em> expect <code>char c[]{\"a\"}</code> to be valid in C++11, of course, but it's not the same! Similarly, <code>char c[] = {'a'}</code> is obvious in both, as is <code>char c[] = \"a\"</code>.</sup></p>\n</hr>", "Tags": "<c++>", "OwnerUserId": "560648", "AnswerCount": "3"}, "8064694": {"ParentId": "8064616", "CommentCount": "4", "Body": "<p>Although it may not necessarily be intuitive, it simply <em>is</em> allowed; there's a distinct rule for it in both standards:</p>\n<blockquote>\n<p id=\"so_8064616_8064694_0\"><code>[2003: 8.5.2/1]:</code> <strong>A <code>char</code> array</strong> (whether plain <code>char</code>, <code>signed char</code>, or\n  <code>unsigned char</code>) <strong>can be initialized by a <em>string-literal</em> (optionally\n  enclosed in braces);</strong> a <code>wchar_t</code> array can be initialized by a wide\n  <em>string-literal</em> (optionally enclosed in braces); successive characters\n  of the <em>string-literal</em> initialize the members of the array. [..]</p>\n<p id=\"so_8064616_8064694_1\"><code>[n3290: 8.5.2/1]:</code> <strong>A char array</strong> (whether <code>plain char</code>, <code>signed char</code>, or\n  <code>unsigned char</code>), <code>char16_t</code> array, <code>char32_t</code> array, or <code>wchar_t</code> array <strong>can\n  be initialized</strong> by a narrow character literal, <code>char16_t</code> string literal,\n  <code>char32_t</code> string literal, or wide string literal, respectively, or <strong>by\n  an appropriately-typed string literal enclosed in braces</strong>. Successive\n  characters of the value of the string literal initialize the elements\n  of the array.</p>\n</blockquote>\n<p>I can't explain why the committee made it this way, though.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "8064694", "Score": "5", "CreationDate": "2011-11-09T11:59:41.827", "LastActivityDate": "2011-11-09T11:59:41.827"}, "8065714": {"ParentId": "8064616", "CommentCount": "4", "Body": "<p>I guess it's for C compatibility? Actually, the <code>T x = { value of T };</code> applies to other types of T as well. In the C99 standard,</p>\n<blockquote>\n<p id=\"so_8064616_8065714_0\">6.7.8/11: The initializer for a scalar shall be a single expression, <strong>optionally enclosed in braces</strong>.</p>\n<p id=\"so_8064616_8065714_1\">6.7.8/14: An array of character type may be initialized by a character string literal, <strong>optionally enclosed in braces.</strong></p>\n<p id=\"so_8064616_8065714_2\">6.7.8/15: An array with element type compatible with <code>wchar_t</code> may be initialized by a wide string literal, <strong>optionally enclosed in braces</strong>. </p>\n</blockquote>\n<p>I don't know why C has this though.</p>\n", "OwnerUserId": "224671", "PostTypeId": "2", "Id": "8065714", "Score": "0", "CreationDate": "2011-11-09T13:29:29.850", "LastActivityDate": "2011-11-09T13:29:29.850"}, "bq_ids": {"n4140": {"so_8064616_8064694_1": {"section_id": 3314, "quality": 0.7555555555555555, "length": 34}, "so_8064616_8065714_2": {"section_id": 3314, "quality": 0.6428571428571429, "length": 9}, "so_8064616_8065714_1": {"section_id": 3314, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_8064616_8065714_2": {"section_id": 3184, "quality": 0.5714285714285714, "length": 8}, "so_8064616_8064694_0": {"section_id": 3184, "quality": 0.59375, "length": 19}, "so_8064616_8064694_1": {"section_id": 3184, "quality": 0.9555555555555556, "length": 43}, "so_8064616_8065714_1": {"section_id": 3184, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_8064616_8064694_1": {"section_id": 4080, "quality": 0.7555555555555555, "length": 34}, "so_8064616_8065714_2": {"section_id": 4080, "quality": 0.6428571428571429, "length": 9}, "so_8064616_8065714_1": {"section_id": 4080, "quality": 0.6666666666666666, "length": 8}}}, "8065951": {"ParentId": "8064616", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Scalar types can also be initialized using braces (just like structs and arrays).</p>\n<pre><code>struct S { int x, char c };\nS s = {5, 'a'};\n\nint arr[] = {5, 6, 7};\n\n/* (my guess) out of consistency */\nint z = { 4 };\n</code></pre>\n<p>And since string literals can be assigned to char array's and pointers</p>\n<pre><code>char arr[] = \"literal\";\nchar* ptr = \"another\";\n</code></pre>\n<p>It seems fitting to allow <code>char arr[] = { \"literal\" };</code> too. </p>\n", "OwnerUserId": "5822", "LastEditorUserId": "5822", "LastEditDate": "2011-11-09T20:27:35.410", "Id": "8065951", "Score": "3", "CreationDate": "2011-11-09T13:48:52.160", "LastActivityDate": "2011-11-09T20:27:35.410"}});