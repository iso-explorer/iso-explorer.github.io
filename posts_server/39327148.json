post_cb({"bq_ids": {"n4140": {"so_39327148_39327210_0": {"length": 42, "quality": 0.9545454545454546, "section_id": 5362}}, "n3337": {"so_39327148_39327210_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 5158}}, "n4659": {"so_39327148_39327210_0": {"length": 34, "quality": 0.7727272727272727, "section_id": 6786}}}, "39327148": {"ViewCount": "127", "Body": "<p>Why can two string literals separated by a space, tab or \"\\n\" be compiled without an error?</p>\n<pre><code>int main()\n{\n   char * a = \"aaaa\"  \"bbbb\";\n} \n</code></pre>\n<p>\"aaaa\" is a char*\n\"bbbb\" is a char*</p>\n<p>There is no specific concatenation rule to process two string literals. And obviously the following code gives an error during compilation:</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n   char * a = \"aaaa\";\n   char * b = \"bbbb\";\n   std::cout &lt;&lt; a b;\n}\n</code></pre>\n<p>Is this concatenation common to all compilers? Where is the null termination of \"aaaa\"? Is \"aaaabbbb\" a continuous block of RAM?</p>\n", "AcceptedAnswerId": "39327197", "Title": "Compilation of string literals", "CreationDate": "2016-09-05T09:04:23.580", "Id": "39327148", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-09-05T09:37:42.793", "LastEditorUserId": "4082723", "LastActivityDate": "2016-09-05T09:37:42.793", "Score": "3", "OwnerUserId": "4621872", "Tags": "<c++><compilation><string-concatenation><string-literals>", "AnswerCount": "5"}, "39327209": {"Id": "39327209", "PostTypeId": "2", "Body": "<p>In this statement</p>\n<pre><code>char * a = \"aaaa\"  \"bbbb\";\n</code></pre>\n<p>the compiler in some step of compilation before the syntax  analysis considers adjacent string literals as one literal.</p>\n<p>So for the compiler the above statement is equivalent to</p>\n<pre><code>char * a = \"aaaabbbb\";\n</code></pre>\n<p>that is the compiler stores only one string literal <code>\"aaaabbbb\"</code></p>\n", "LastActivityDate": "2016-09-05T09:07:33.360", "CommentCount": "0", "CreationDate": "2016-09-05T09:07:33.360", "ParentId": "39327148", "Score": "4", "OwnerUserId": "2877241"}, "39327204": {"Id": "39327204", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39327148_39327204_0\">String literals placed side-by-side are concatenated at translation phase 6 (after the preprocessor). That is, <code>\"Hello,\"  \" world!\"</code> yields the (single) string <code>\"Hello, world!\"</code>. If the two strings have the same encoding prefix (or neither has one), the resulting string will have the same encoding prefix (or no prefix).</p>\n</blockquote>\n<p>(<a href=\"http://en.cppreference.com/w/cpp/language/string_literal\" rel=\"nofollow\">source</a>)</p>\n", "LastActivityDate": "2016-09-05T09:07:16.047", "CommentCount": "0", "CreationDate": "2016-09-05T09:07:16.047", "ParentId": "39327148", "Score": "1", "OwnerUserId": "1524450"}, "39327197": {"Id": "39327197", "PostTypeId": "2", "Body": "<p>If you see e.g. <a href=\"http://en.cppreference.com/w/cpp/language/translation_phases\">this translation phase reference</a> in phase 6 it does:</p>\n<blockquote>\n<p id=\"so_39327148_39327197_0\">Adjacent string literals are concatenated. </p>\n</blockquote>\n<p>And that's exactly what happens here. You have two adjacent string literals, and they are concatenated into a single string literal.</p>\n<p>It is standard behavior.</p>\n<p>It only works for string literals, not two pointer variables, as you noticed.</p>\n", "LastActivityDate": "2016-09-05T09:07:07.373", "CommentCount": "0", "CreationDate": "2016-09-05T09:07:07.373", "ParentId": "39327148", "Score": "8", "OwnerUserId": "440558"}, "39327278": {"Id": "39327278", "PostTypeId": "2", "Body": "<p>In C and C++ compiles adjacent string literals as a single string literal. For example this:</p>\n<pre><code>\"Some text...\" \"and more text\"\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>\"Some text...and more text\"\n</code></pre>\n<p>That for historical reasons:</p>\n<blockquote>\n<p id=\"so_39327148_39327278_0\">The original C language was designed in 1969-1972 when computing was still dominated by the 80 column punched card. Its designers used 80 column devices such as the ASR-33 Teletype. These devices did not automatically wrap text, so there was a real incentive to keep source code within 80 columns. Fortran and Cobol had explicit continuation mechanisms to do so, before they finally moved to free format.</p>\n<p id=\"so_39327148_39327278_1\">It was a stroke of brilliance for Dennis Ritchie (I assume) to realise that there was no ambiguity in the grammar and that long ASCII strings could be made to fit into 80 columns by the simple expedient of getting the compiler to concatenate adjacent literal strings. Countless C programmers were grateful for that small feature.</p>\n<p id=\"so_39327148_39327278_2\">Once the feature is in, why would it ever be removed? It causes no grief and is frequently handy. I for one wish more languages had it. The modern trend is to have extended strings with triple quotes or other symbols, but the simplicity of this feature in C has never been outdone.</p>\n</blockquote>\n<p><a href=\"https://softwareengineering.stackexchange.com/questions/254984/on-concatenating-adjacent-string-literals\">Similar question here</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-05T09:15:02.727", "Score": "2", "CreationDate": "2016-09-05T09:11:38.173", "ParentId": "39327148", "CommentCount": "2", "OwnerUserId": "6040181", "LastEditDate": "2017-04-12T07:31:24.410"}, "39327210": {"Id": "39327210", "PostTypeId": "2", "Body": "<p>Adjacent string literals are concatenated as per the rules of C (and C++) standard. But no such rule exists for adjacent identifiers (i.e. variables <code>a</code> and <code>b</code>).</p>\n<p>To quote, C++14 (N3797 draft), \u00a7 2.14.5:</p>\n<blockquote>\n<p id=\"so_39327148_39327210_0\">In translation phase 6 (2.2), adjacent string literals are\n  concatenated. If both string literals have the same encoding-prefix,\n  the resulting concatenated string literal has that encoding-prefix. If\n  one string literal has no encoding-prefix, it is treated as a string\n  literal of the same encoding-prefix as the other operand. If a UTF-8\n  string literal token is adjacent to a wide string literal token, the\n  program is ill-formed. Any other concatenations are\n  conditionally-supported with implementation-defined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2016-09-05T09:07:34.963", "CommentCount": "0", "CreationDate": "2016-09-05T09:07:34.963", "ParentId": "39327148", "Score": "3", "OwnerUserId": "4389800"}});