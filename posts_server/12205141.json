post_cb({"12205401": {"ParentId": "12205141", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Like Mark said, the standard says that its a double unless its followed by an f.</p>\n<p>There are good reasons behind the standard and using compiler flags to get around it for convenience is bad practice. </p>\n<p>So, the correct approach would be:</p>\n<ol>\n<li>Remove the compiler flag</li>\n<li>Fix all the warnings about loss of precision when storing double values in floating point variables (add in all the f suffixes)</li>\n<li>When you need double, omit the f suffix. </li>\n</ol>\n<p>Its probably not the answer you were looking for, but it is the approach you should use if you care about the longevity of your code base.</p>\n", "OwnerUserId": "13760", "LastEditorUserId": "13760", "LastEditDate": "2012-08-31T00:12:43.473", "Id": "12205401", "Score": "19", "CreationDate": "2012-08-30T20:57:26.303", "LastActivityDate": "2012-08-31T00:12:43.473"}, "12205279": {"ParentId": "12205141", "CommentCount": "2", "Body": "<p>If you read 2.13.3/1 you'll see:</p>\n<blockquote>\n<p id=\"so_12205141_12205279_0\">The type of a floating literal is double unless explicitly specified\n  by a suffix. The suffixes f and F specify float, the suffixes l and L\n  specify long double.</p>\n</blockquote>\n<p>In other words there is no suffix to specify <code>double</code> for a literal floating point constant if you change the default to <code>float</code>. Unfortunately you can't have the best of both worlds in this case.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "12205279", "Score": "11", "CreationDate": "2012-08-30T20:49:40.163", "LastActivityDate": "2012-08-30T20:49:40.163"}, "12205543": {"ParentId": "12205141", "CommentCount": "0", "Body": "<p>If you can afford GCC 4.7 or Clang 3.1, use a user-defined literal:</p>\n<pre><code>double operator \"\" _d(long double v) { return v; }\n</code></pre>\n<p>Usage:</p>\n<pre><code>std::cout &lt;&lt; sizeof(1.0E200_d) &lt;&lt; std::endl;\nstd::cout &lt;&lt; 1.0E200_d &lt;&lt; std::endl;\n</code></pre>\n<p>Result:</p>\n<pre><code>8\n1e+200\n</code></pre>\n", "OwnerUserId": "1589919", "PostTypeId": "2", "Id": "12205543", "Score": "8", "CreationDate": "2012-08-30T21:07:16.093", "LastActivityDate": "2012-08-30T21:07:16.093"}, "12205141": {"CommentCount": "8", "AcceptedAnswerId": "12205401", "CreationDate": "2012-08-30T20:41:02.770", "LastActivityDate": "2012-08-31T00:12:43.473", "PostTypeId": "1", "ViewCount": "11539", "FavoriteCount": "2", "Title": "Is there a floating point literal suffix in C++ to make a number double precision?", "Id": "12205141", "Score": "17", "Body": "<p>I'm currently working on a C++ project which does numerical calculations. The vast, vast majority of the code uses single precision floating point values and works perfectly fine with that. Because of this I use compiler flags to make basic floating point literals single precision instead of the double precision, which is the default. I find that this makes expressions easier to read and I don't have to worry about forgetting a 'f' somewhere. However, every now and then I need the extra precision offered by double precision calculations and my question is how I can get a double precision literal into such an expression. Every way I've tried so far first store the value in a single precision variable and the converts the truncated value to a double precision value. Not what I want.</p>\n<p>Some ways I've tried so far is given below.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout &lt;&lt; sizeof(1.0E200) &lt;&lt; std::endl;\n  std::cout &lt;&lt; 1.0E200 &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; sizeof(1.0E200L) &lt;&lt; std::endl;\n  std::cout &lt;&lt; 1.0E200L &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; sizeof(double(1.0E200)) &lt;&lt; std::endl;\n  std::cout &lt;&lt; double(1.0E200) &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; sizeof(static_cast&lt;double&gt;(1.0E200)) &lt;&lt; std::endl;\n  std::cout &lt;&lt; static_cast&lt;double&gt;(1.0E200) &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>A run with single precision constants give the following results.</p>\n<pre><code>~/path$ g++ test.cpp -fsingle-precision-constant &amp;&amp; ./a.out\ntest.cpp:6:3: warning: floating constant exceeds range of \u2018float\u2019 [-Woverflow]\ntest.cpp:7:3: warning: floating constant exceeds range of \u2018float\u2019 [-Woverflow]\ntest.cpp:12:3: warning: floating constant exceeds range of \u2018float\u2019 [-Woverflow]\ntest.cpp:13:3: warning: floating constant exceeds range of \u2018float\u2019 [-Woverflow]\ntest.cpp:15:3: warning: floating constant exceeds range of \u2018float\u2019 [-Woverflow]\ntest.cpp:16:3: warning: floating constant exceeds range of \u2018float\u2019 [-Woverflow]\n4\ninf\n16\n1e+200\n8\ninf\n8\ninf\n</code></pre>\n<p>It is my understanding that the 8 bytes provided by the last two cases should be enough to hold 1.0E200, a theory supported by the following output, where the same program is compiled without -fsingle-precision-constant.</p>\n<pre><code>~/path$ g++ test.cpp  &amp;&amp; ./a.out\n8\n1e+200\n16\n1e+200\n8\n1e+200\n8\n1e+200\n</code></pre>\n<p>A possible workaround suggested by the above examples is to use quadruple precision floating point literals everywhere I originally intended to use double precision, and cast to double precision whenever required by libraries and such. However, this feels a bit wasteful.</p>\n<p>What else can I do?</p>\n", "Tags": "<c++><gcc><precision><literals>", "OwnerUserId": "1637052", "AnswerCount": "4"}, "12205538": {"ParentId": "12205141", "CommentCount": "1", "Body": "<p>You can't define your own suffix, but maybe a macro like</p>\n<pre><code>#define D(x) (double(x##L))\n</code></pre>\n<p>would work for you. The compiler ought to just emit a double constant, and appears to with <code>-O2</code> on my system.</p>\n", "OwnerUserId": "166955", "PostTypeId": "2", "Id": "12205538", "Score": "5", "CreationDate": "2012-08-30T21:06:51.817", "LastActivityDate": "2012-08-30T21:06:51.817"}, "bq_ids": {"n4140": {"so_12205141_12205279_0": {"section_id": 5348, "quality": 0.875, "length": 14}}, "n3337": {"so_12205141_12205279_0": {"section_id": 5145, "quality": 0.875, "length": 14}}, "n4659": {"so_12205141_12205279_0": {"section_id": 6773, "quality": 0.875, "length": 14}}}});