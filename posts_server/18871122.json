post_cb({"18871368": {"ParentId": "18871122", "CommentCount": "2", "Body": "<p>It looks like support has not been implemented in GCC. Vice versa, you cannot have a lambda inside a pack expansion (to produce one lambda per pack argument). It seems the two features don't play together at all.</p>\n<p>If you simply use <code>[&amp;]</code> instead, then there is a more helpful error message:</p>\n<blockquote>\n<p id=\"so_18871122_18871368_0\">sorry, unimplemented: use of \u2018type_pack_expansion\u2019 in template</p>\n</blockquote>\n<p>Disclaimer: My copy of GCC was built in late July; I'm probably due for an upgrade.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "18871368", "Score": "3", "CreationDate": "2013-09-18T11:45:28.097", "LastActivityDate": "2013-09-18T11:45:28.097"}, "18871122": {"CommentCount": "0", "ViewCount": "865", "PostTypeId": "1", "LastEditorUserId": "2073257", "CreationDate": "2013-09-18T11:33:17.377", "LastActivityDate": "2013-09-18T13:54:12.407", "Title": "Compiler bug, or non standard code? - Variadic template capture in lambda", "AcceptedAnswerId": "18871368", "LastEditDate": "2013-09-18T13:54:12.407", "Id": "18871122", "Score": "5", "Body": "<p>I have the following C++11 code;</p>\n<pre><code>template&lt;typename... T&gt;\nint g(T... t)\n{\n    return 0;\n}\n\ntemplate&lt;class... Args&gt;\nvoid f(Args... args)\n{\n    auto lm = [&amp;, args...] { return g(args...); };\n    lm();\n}\n\nint main()\n{\n    f(2, 5, 7);\n}\n</code></pre>\n<p>I do believe that it's valid C++11, according to; Section 5.1.2.23 of the standard;</p>\n<blockquote>\n<p id=\"so_18871122_18871122_0\">A capture followed by an ellipsis is a\n  pack expansion (14.5.3). [ Example:</p>\n<pre><code>template&lt;class... Args&gt; void f(Args... args) {\n    auto lm = [&amp;, args...] { return g(args...); }; lm();\n}\n</code></pre>\n<p id=\"so_18871122_18871122_1\">\u2014 end example ]</p>\n</blockquote>\n<p>However while Clang++ compiles fine, G++ provides this error;</p>\n<pre><code>main.cpp: In function 'void f(Args ...)':\nmain.cpp:10:23: error: expected ',' before '...' token\n     auto lm = [&amp;, args...] { return g(args...); };\n                   ^\nmain.cpp:10:23: error: expected identifier before '...' token\nmain.cpp:10:26: error: parameter packs not expanded with '...':\n     auto lm = [&amp;, args...] { return g(args...); };\n                      ^\nmain.cpp:10:26: note:         'args'\nmain.cpp: In lambda function:\nmain.cpp:10:43: error: expansion pattern 'args' contains no argument packs\n     auto lm = [&amp;, args...] { return g(args...); };\n                                       ^\nmain.cpp: In instantiation of 'struct f(Args ...) [with Args = {int, int, int}]::__lambda0':\nmain.cpp:10:49:   required from 'void f(Args ...) [with Args = {int, int, int}]'\nmain.cpp:16:14:   required from here\nmain.cpp:10:19: error: using invalid field 'f(Args ...)::__lambda0::__args'\n     auto lm = [&amp;, args...] { return g(args...); };\n                   ^\n</code></pre>\n<p>So my question is simply, is this a compiler bug in G++?</p>\n", "Tags": "<c++><c++11><lambda><variadic-templates><compiler-bug>", "OwnerUserId": "480212", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_18871122_18871122_0": {"section_id": 83, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_18871122_18871122_0": {"section_id": 5751, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_18871122_18871122_0": {"section_id": 86, "quality": 0.5714285714285714, "length": 4}}}});