post_cb({"17359114": {"ParentId": "17356719", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This non-restrictive definition allows for parallel computing. An implementation may choose to apply transform function using several threads. See also related question: <a href=\"https://stackoverflow.com/questions/2547531/stl-algorithms-and-concurrent-programming\">STL algorithms and concurrent programming</a></p>\n<p>Think of it as a semantic difference in algorithms (that is, that represents programmer's intent rather than being just another tool). With <code>for_each</code> you state that you need a sequential scan. With <code>transform</code> you state that you only need to aply a function to every item in the container, but you don't care how it will be done.</p>\n", "OwnerUserId": "949044", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:45.110", "Id": "17359114", "Score": "2", "CreationDate": "2013-06-28T07:06:11.187", "LastActivityDate": "2013-06-28T07:13:12.263"}, "33306492": {"ParentId": "17356719", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Quoting directly from the standard (copied at end):</p>\n<p>You will see from the template declaration of <code>std::transform&lt;&gt;</code> that the input iterator parameters must conform to the concept of an <code>InputIterator</code>. </p>\n<p>An <code>InputIterator</code> is one of the most restrictive iterator concepts in c++. It does not support any kind of random access. It is only able to advance.</p>\n<p>Therefore any implementation of std::transform that requires the iterator to do anything other than be dereferenced or advance is ill-formed. Remember that by specifying <code>InputIterator</code>, the standard is explicitly allowing the use of a <code>std::istream_iterator</code> (for example) and the implementation of <code>std::transform</code> is required to respect the restrictions therein. It must be written only in terms of the methods available on the <code>InputIterator</code> concept.</p>\n<p>Therefore, by implication, the implementation of this function <em>must</em> access elements sequentially (and therefore transform values sequentially) since <em>to not do so would break the contract implicit in the interface</em>.</p>\n<p>Therefore the standard <strong>does</strong> (implicitly and quietly) guarantee that <code>std::transform</code> initialise its elements sequentially. It would be impossible to write a well-formed implementation of <code>std::transform</code> that did not.</p>\n<blockquote>\n<p id=\"so_17356719_33306492_0\">25.3.4 Transform [alg.transform]</p>\n</blockquote>\n<pre><code>template&lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;\nOutputIterator\ntransform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate&lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation&gt;\nOutputIterator\ntransform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation binary_op);\n</code></pre>\n<blockquote>\n<p id=\"so_17356719_33306492_1\">1 Effects: Assigns through every iterator <code>i</code> in the range <code>[result,result + (last1 - first1))</code> a new corresponding value equal to <code>op(*(first1 + (i - result))</code> or <code>binary_op(*(first1 + (i - result)), *(first2 + (i - result)))</code>.</p>\n<p id=\"so_17356719_33306492_2\">2 Requires: op and binary_op shall not invalidate iterators or subranges, or modify elements in the ranges [first1,last1], [first2,first2 + (last1 - first1)], and [result,result + (last1 - first1)].</p>\n<p id=\"so_17356719_33306492_3\">3 Returns: result + (last1 - first1).</p>\n<p id=\"so_17356719_33306492_4\">4 Complexity: Exactly last1 - first1 applications of op or binary_op.</p>\n<p id=\"so_17356719_33306492_5\">5 Remarks: result may be equal to first in case of unary transform, or to first1 or first2 in case of binary transform.</p>\n</blockquote>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2756719", "LastEditDate": "2015-12-08T23:19:45.340", "Id": "33306492", "Score": "3", "CreationDate": "2015-10-23T15:44:53.163", "LastActivityDate": "2015-12-08T23:19:45.340"}, "39598430": {"ParentId": "17356719", "CommentCount": "0", "Body": "<p>Despite some earlier answers, I think it is possible to implement std::transform in a parallel way. For instance like this:</p>\n<p>1) Fetch all input sequentially.</p>\n<p>2) Iterate over OutputIterator, initialising dummy objects and keep a reference to each output.</p>\n<p>3) Distribute the input with the corresponding output iterator to different threads, each doing the transformation independently.</p>\n<p>Like this, the iterators are only incremented as allowed.</p>\n<p>As pointed out by clcto, another implementation could do step 1) first, then create a vector for all output elements, then compute all of these in parallel using the given function argument and then write them sequentially into the output.</p>\n", "OwnerUserId": "6854346", "PostTypeId": "2", "Id": "39598430", "Score": "2", "CreationDate": "2016-09-20T15:42:31.817", "LastActivityDate": "2016-09-20T15:42:31.817"}, "bq_ids": {"n4140": {"so_17356719_33306492_1": {"section_id": 1316, "quality": 0.8947368421052632, "length": 17}, "so_17356719_33306492_2": {"section_id": 1317, "quality": 0.7333333333333333, "length": 11}, "so_17356719_33306492_5": {"section_id": 1320, "quality": 0.9230769230769231, "length": 12}, "so_17356719_33306492_4": {"section_id": 1319, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_17356719_33306492_1": {"section_id": 1310, "quality": 0.8947368421052632, "length": 17}, "so_17356719_33306492_2": {"section_id": 1311, "quality": 0.7333333333333333, "length": 11}, "so_17356719_33306492_5": {"section_id": 1314, "quality": 0.9230769230769231, "length": 12}, "so_17356719_33306492_4": {"section_id": 1313, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_17356719_33306492_1": {"section_id": 1447, "quality": 0.8947368421052632, "length": 17}, "so_17356719_33306492_2": {"section_id": 1446, "quality": 0.7333333333333333, "length": 11}, "so_17356719_33306492_5": {"section_id": 1450, "quality": 0.9230769230769231, "length": 12}, "so_17356719_33306492_4": {"section_id": 1449, "quality": 0.8333333333333334, "length": 5}}}, "17356719": {"CommentCount": "2", "AcceptedAnswerId": "17359114", "PostTypeId": "1", "LastEditorUserId": "129570", "CreationDate": "2013-06-28T03:25:49.973", "LastActivityDate": "2016-09-20T15:42:31.817", "LastEditDate": "2013-06-28T03:32:18.287", "ViewCount": "738", "FavoriteCount": "0", "Title": "Why std::transform doesn't guarantee the order (but for_each guarantee the order)? Doesn't this allow trick implementation for performance?", "Id": "17356719", "Score": "2", "Body": "<p>I just realize the standard doesn't guarantee the order of applying function callback in <code>std::transform</code>. And it doesn't allow the callback function or functor have side effect. But at the same time <code>std::for_each</code> actually guarantee the order.</p>\n<p>One guess is the transform can using high performance algorithm which doesn't guarantee order, But O(N) is the best algorithm already.</p>\n<p>So why the standard doesn't make the <code>transform</code> have the behavior as <code>for_each</code> from the view of apply callback function order? The user will benefit form this guarantee.</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "2428052", "AnswerCount": "3"}});