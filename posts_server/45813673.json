post_cb({"bq_ids": {"n4140": {"so_45813673_45817771_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3299}}, "n3337": {"so_45813673_45817771_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3169}}, "n4659": {"so_45813673_45817771_0": {"length": 13, "quality": 1.0, "section_id": 4065}}}, "45817771": {"Id": "45817771", "PostTypeId": "2", "Body": "<p>In this case you can use simple pack expansion in the form of an array:</p>\n<pre><code>template&lt;typename... Ts&gt;\nvoid my_function(std::unordered_map&lt;std::string, memory_region&gt;&amp; my_map) {\n    using swallow = int[];\n    unsigned i = 0;\n    (void)swallow{0, (my_map.at(input_buffer_name(i++)).as_span&lt;Ts&gt;(), 0)...};\n}\n</code></pre>\n<h3><a href=\"https://wandbox.org/permlink/umx9DmdK46atiTKc\" rel=\"nofollow noreferrer\">Demo</a></h3>\n<p>The pack expansion will be expanded in order ([temp.variadic]), and also evaluated in order (left to right) because we're using a braced initializer list (an unused integer array): [dcl.init.aggr] </p>\n<blockquote>\n<p id=\"so_45813673_45817771_0\">When an aggregate is initialized by an initializer list [...] the elements of the initializer list are taken as initializers for the elements of the aggregate, in order.</p>\n</blockquote>\n<hr>\n<p>Re:</p>\n<blockquote>\n<p id=\"so_45813673_45817771_1\">But what if I need to use input_buffer_name(i) twice? e.g. if I need to use \n  <code>{ input_buffer_name(index), my_map.at(input_buffer_name(index).as_span&lt;Ts&gt;()) }</code></p>\n</blockquote>\n<p>I suppose we could take advantage of the fact that logical AND will sequence left to right ([expr.log.and]), and also a boolean can be promoted to <code>int</code>:</p>\n<pre><code>template&lt;typename... Ts&gt;\nvoid my_function_v2(std::unordered_map&lt;std::string, memory_region&gt;&amp; my_map) {\n    using swallow = int[];\n    unsigned i = 0;\n    (void)swallow{0, ((std::cout&lt;&lt; input_buffer_name(i) &lt;&lt; std::endl, true) &amp;&amp; (my_map.at(input_buffer_name(i++)).as_span&lt;Ts&gt;(), true))...};\n}\n</code></pre>\n<h3><a href=\"https://wandbox.org/permlink/g4P2HSofeFdoPWUC\" rel=\"nofollow noreferrer\">Demo 2</a></h3>\n</hr>", "LastEditorUserId": "27678", "LastActivityDate": "2017-08-22T13:18:34.060", "Score": "2", "CreationDate": "2017-08-22T12:32:45.093", "ParentId": "45813673", "CommentCount": "2", "OwnerUserId": "27678", "LastEditDate": "2017-08-22T13:18:34.060"}, "45813673": {"ViewCount": "244", "Body": "<p>I have a class named <code>memory_region</code>, which is sort of like an untyped <code>gsl::span</code> (i.e. it's essentially a <code>void*</code> and a <code>size_t</code>), which I also use for type erasure. It thus has an <code>as_span&lt;T&gt;()</code> method. </p>\n<p>With this class, I have a <code>std::unordered_map&lt;std::string, memory_region&gt; my_map</code> - which is used to pass type-erased spans between parts of my code which don't share headers, so they can't know about each others' types. The typical access to one of these looks like:</p>\n<pre><code>auto foo = my_map.at(\"foo\").as_span&lt;bar_t&gt;();\n</code></pre>\n<p>This works just fine with code that has a fixed set of buffers and types and names. But - things get tricky when my code's buffers depend on a template parameter pack. Now, I've implemented a</p>\n<pre><code>std::string input_buffer_name(unsigned input_buffer_index);\n</code></pre>\n<p>function, so if I have an index sequence and my parameter pack I can do, for example</p>\n<pre><code>template&lt;typename Ts..., std::size_t... Indices&gt;\nmy_function(std::unordered_map&lt;std::string, memory_region&gt;&amp; my map) {\n    compute_stuff_with_buffers(\n        my_map.at(input_buffer_name(Indices)).as_span&lt;Ts&gt;()...\n    );\n}\n</code></pre>\n<p>(this is a variation on the infamous <a href=\"https://stackoverflow.com/questions/31463388/can-someone-please-explain-the-indices-trick\">indices trick</a>; note that the same type may appear more than once in the pack, so I can't \"wrap the types in a tuple\" and acces it by type.)</p>\n<p>The thing is, though - my code doesn't have that index sequence in the template parameters; most of it is templated on just the parameter pack of types. So I find myself writing \"helper functions/methods\" all the time to be able to use that index sequence, e.g.:</p>\n<pre><code>template&lt;typename Ts..., std::size_t... Indices&gt;\nmy_function_helper(\n    std::unordered_map&lt;std::string, memory_region&gt;&amp; my map\n    std::index_sequence&lt;Indices...&gt;  /* unused */) \n{\n    compute_stuff_with_buffers(\n        my_map.at(input_buffer_name(Indices)).as_span&lt;Ts&gt;()...\n    );\n}\n\ntemplate&lt;typename Ts...&gt;\nmy_function(std::unordered_map&lt;std::string, memory_region&gt;&amp; my map) {\n    my_function_helper(\n        my_map, std::make_index_sequence&lt;sizeof...(Ts)&gt; {}\n    );\n}\n</code></pre>\n<p>What can I do instead, that will not involve so much code duplication?</p>\n", "Title": "How to avoid using the \"indices trick\" repeatedly?", "CreationDate": "2017-08-22T09:22:27.017", "LastActivityDate": "2017-08-22T15:41:26.867", "CommentCount": "4", "LastEditDate": "2017-08-22T15:41:26.867", "PostTypeId": "1", "LastEditorUserId": "1593077", "Id": "45813673", "Score": "4", "OwnerUserId": "1593077", "Tags": "<c++><c++14><variadic-templates><idiomatic><index-sequence>", "AnswerCount": "1"}});