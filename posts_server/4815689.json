post_cb({"bq_ids": {"n4140": {"so_4815689_4815754_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 7194}}, "n3337": {"so_4815689_4815754_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 6938}}, "n4659": {"so_4815689_4815754_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 8703}}}, "4815689": {"ViewCount": "253", "Body": "<p>Consider this code sample:</p>\n<pre><code>class Base {\npublic:\n    Base( string&amp; _object ) : object( _object ) {}\nprivate:\n    string&amp; object;\n};\n\nclass Derived: public Base {\npublic:\n    Derived() : Base( object ) {}\nprivate:\n   string object;\n};\n</code></pre>\n<p>Obviously first <code>Base</code> is constructed and it is passed a reference to a not yet constructed object.</p>\n<p>Memory is allocated for the whole <code>Derived</code> object, so <code>Derived::object</code> is in legally accessible memory, just its constructor has not run. <code>Base::Base()</code> doesn't call any methods of passed object, only stores the reference. It works in Visual C++ 9.</p>\n<p>Is it safe according to C++ Standard?</p>\n", "AcceptedAnswerId": "4815754", "Title": "Is it safe to bind a reference to a not yet constructed object in C++?", "CreationDate": "2011-01-27T11:23:39.487", "Id": "4815689", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-01-27T14:47:05.923", "Score": "20", "OwnerUserId": "57428", "Tags": "<c++><visual-c++><reference>", "AnswerCount": "1"}, "4815754": {"Id": "4815754", "PostTypeId": "2", "Body": "<p>It is safe, as long as you don't \"use\" the reference before object is constructed.  You can use the <a href=\"http://www.boost.org/doc/libs/1_45_0/libs/utility/base_from_member.html#rationale\">base-from-member idiom</a> to move object into a (private) base class which comes before Base, and thus be constructed before Base, if you need to change the construction order:</p>\n<pre><code>struct Base {\n  Base(string &amp;ref) {\n    cout &lt;&lt; \"imagine the ctor uses the ref: \" &lt;&lt; ref;\n  }\n};\n\nstruct DerivedDetail {\n  DerivedDetail(string const &amp;x) : object (x) {}\n  string object;\n};\n\nstruct Derived : private DerivedDetail, Base {\n  Derived() : DerivedDetail(\"foobar\"), Base(object) {}\n  // In particular, note you can still use this-&gt;object and just\n  // ignore that it is from a base, yet this-&gt;object is still private\n  // within Derived.\n};\n</code></pre>\n<hr>\n<p>C++03 \u00a73.8p6:</p>\n<blockquote>\n<p id=\"so_4815689_4815754_0\">\u2026before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any lvalue which refers to the original object may be used but only in limited ways. Such an lvalue refers to allocated storage (3.7.3.2), and using the properties of the lvalue which do not\n  depend on its value is well-defined. \u2026</p>\n</blockquote>\n<p>In a nutshell: don't access any members, methods, or pass it to anything that does.  You can take its address and bind references to it.</p>\n</hr>", "LastEditorUserId": "511601", "LastActivityDate": "2011-01-27T14:47:05.923", "Score": "19", "CreationDate": "2011-01-27T11:31:25.580", "ParentId": "4815689", "CommentCount": "1", "OwnerUserId": "511601", "LastEditDate": "2011-01-27T14:47:05.923"}});