post_cb({"22029869": {"Id": "22029869", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/22019445/2230\">BoBTFish's answer</a> sounds pretty convincing to me. Now, I don't have normative information on this subject myself, but I want to provide an alternative answer based on a bit of deduction:</p>\n<p>It is generally true that:</p>\n<ul>\n<li>Generally speaking, any expression involving a <code>NaN</code> must return <code>NaN</code>.</li>\n<li>An arithmetic expression might involve casting from/to <code>single</code> and <code>double</code>, maybe multiple times.</li>\n</ul>\n<p>I don't see how the compiler could could meet both requirements without preserving <code>NaN</code> during a <code>float</code>/<code>double</code> cast.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-26T01:29:16.000", "Score": "0", "CreationDate": "2014-02-26T01:29:16.000", "ParentId": "22019261", "CommentCount": "0", "OwnerUserId": "2230", "LastEditDate": "2017-05-23T11:57:48.047"}, "bq_ids": {"n4140": {"so_22019261_22019445_3": {"length": 38, "quality": 0.9743589743589743, "section_id": 35}, "so_22019261_22019445_5": {"length": 43, "quality": 0.9555555555555556, "section_id": 7217}, "so_22019261_22019445_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 28}}, "n3337": {"so_22019261_22019445_3": {"length": 38, "quality": 0.9743589743589743, "section_id": 32}, "so_22019261_22019445_5": {"length": 43, "quality": 0.9555555555555556, "section_id": 6961}, "so_22019261_22019445_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 25}}, "n4659": {"so_22019261_22019445_3": {"length": 34, "quality": 0.8717948717948718, "section_id": 35}, "so_22019261_22019445_5": {"length": 41, "quality": 0.9111111111111111, "section_id": 8726}, "so_22019261_22019445_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 28}}}, "22029667": {"Id": "22029667", "PostTypeId": "2", "Body": "<p>C++ doesn't require adherence to IEEE-754; however, for platforms that do follow the standard, clause 6.2 governs the behavior for quiet NaNs:</p>\n<blockquote>\n<p id=\"so_22019261_22029667_0\"><strong>For an operation with quiet NaN inputs</strong>, other than maximum and minimum operations, if a floating-point result is to be delivered <strong>the result shall be a quiet NaN</strong>  ...</p>\n</blockquote>\n<p>and signaling NaNs:</p>\n<blockquote>\n<p id=\"so_22019261_22029667_1\">Under default exception handling, any operation signaling an invalid operation exception and for which a floating-point result is to be delivered shall deliver a quiet NaN.</p>\n<p id=\"so_22019261_22029667_2\">Signaling NaNs shall be reserved operands that, under default exception handling, signal the invalid operation exception (see 7.2) for every general-computational and signaling-computational operation ...</p>\n</blockquote>\n", "LastActivityDate": "2014-02-26T01:10:29.367", "CommentCount": "0", "CreationDate": "2014-02-26T01:10:29.367", "ParentId": "22019261", "Score": "1", "OwnerUserId": "142434"}, "22019445": {"Id": "22019445", "PostTypeId": "2", "Body": "<p>From N3337:</p>\n<blockquote>\n<p id=\"so_22019261_22019445_0\">4.6 Floating point promotion [conv.fpprom]</p>\n<p id=\"so_22019261_22019445_1\">1 A prvalue of type <code>float</code> can be converted to a prvalue of type <code>double</code>. <strong>The value is unchanged.</strong></p>\n</blockquote>\n<p>,</p>\n<blockquote>\n<p id=\"so_22019261_22019445_2\">4.8 Floating point conversions [conv.double]</p>\n<p id=\"so_22019261_22019445_3\">1 A prvalue of floating point type can be converted to a prvalue of another floating point\n  type. <strong>If the source value can be exactly represented in the\n  destination type, the result of the conversion is that exact\n  representation.</strong> If the source value is between two adjacent\n  destination values, the result of the conversion is an\n  implementation-defined choice of either of those values. Otherwise,\n  the behavior is undefined.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_22019261_22019445_4\">3.9.1 Fundamental types [basic.fundamental]</p>\n<p id=\"so_22019261_22019445_5\">8 There are three floating point types: <code>float</code>, <code>double</code>, and <code>long double</code>. The type <code>double</code> provides\n  at least as much precision as <code>float</code>, and the type <code>long double</code> provides\n  at least as much precision as <code>double</code>. <strong>The set of values of the type\n  <code>float</code> is a subset of the set of values of the type <code>double</code></strong>; the set of\n  values of the type <code>double</code> is a subset of the set of values of the type\n  <code>long double</code>.</p>\n</blockquote>\n<p>Now we should confirm that <code>NaN</code> is in fact a valid <em>value</em> for a floating point type. The definition for <code>isnan</code> refers back to the <code>C</code> Standard. From N1570:</p>\n<blockquote>\n<p id=\"so_22019261_22019445_6\">7.12.3.4 The <code>isnan</code> macro</p>\n<p id=\"so_22019261_22019445_7\">2 The <code>isnan</code> macro determines whether its argument <strong>value</strong> is a NaN.</p>\n</blockquote>\n<p><strong>So to summarise:</strong> yes, going from <code>float</code> to <code>double</code> should preserve NaN-ness. Going from <code>double</code> to <code>float</code> is perhaps a little iffier, but as <code>double</code> supports NaN, we conclude that this conversion also must be preserved, by the \"subset of values\" wording.</p>\n<p>(<a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/Sg2IRvV9jFo\" rel=\"nofollow\">What the word \"value\" actually means seems to be somewhat ill-defined.</a>)</p>\n", "LastEditorUserId": "1171191", "LastActivityDate": "2014-02-25T16:06:12.600", "Score": "3", "CreationDate": "2014-02-25T15:54:32.560", "ParentId": "22019261", "CommentCount": "4", "OwnerUserId": "1171191", "LastEditDate": "2014-02-25T16:06:12.600"}, "22019261": {"ViewCount": "72", "Body": "<p>Basically:</p>\n<pre><code>float  nanf=std::numeric_limits::signaling_NaN&lt;decltype(g_nanf)&gt;();\ndouble nand = nanf;\nassert(std::isnan(nand));\n</code></pre>\n<p>can assert fire?\nalso what if I was assigning double nan to float</p>\n", "Title": "is isnan preserved when asigning to different size FP type.", "CreationDate": "2014-02-25T15:47:36.543", "LastActivityDate": "2014-02-26T01:29:16.000", "CommentCount": "1", "PostTypeId": "1", "Id": "22019261", "Score": "4", "OwnerUserId": "700825", "Tags": "<c++><nan><ieee-754>", "AnswerCount": "3"}});