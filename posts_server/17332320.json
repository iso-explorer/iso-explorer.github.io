post_cb({"17332320": {"CommentCount": "14", "ViewCount": "385", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2013-06-26T23:50:37.190", "LastActivityDate": "2013-06-29T23:27:09.657", "Title": "static_cast not working on precedence as expected", "FavoriteCount": "2", "LastEditDate": "2013-06-29T23:27:09.657", "Id": "17332320", "Score": "9", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\ntemplate&lt;int T&gt; void foo()\n{\n  std::cout &lt;&lt; \"a\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;uint8_t T&gt; void foo()\n{\n  std::cout &lt;&lt; \"b\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n  foo&lt;static_cast&lt;uint8_t&gt;(42)&gt; ();\n  foo&lt;static_cast&lt;int&gt;(42)&gt;();\n  return(0);\n}\n</code></pre>\n<p>any idea why this isn't working as expected ?</p>\n<p>My gcc 4.8.1 is complaining about an ambiguous call, but the static_cast isn't supposed to \"fix\" the precedence rule in cases like this one where you have 2 types with the same precedence ?</p>\n", "Tags": "<c++><templates><c++11><overloading><ambiguous-call>", "OwnerUserId": "2485710", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17332320_17333188_2": {"section_id": 161, "quality": 0.9767441860465116, "length": 42}, "so_17332320_17333188_1": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_17332320_17333188_0": {"section_id": 603, "quality": 0.8333333333333334, "length": 15}, "so_17332320_17333188_4": {"section_id": 163, "quality": 0.9285714285714286, "length": 13}, "so_17332320_17333188_3": {"section_id": 162, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_17332320_17333188_2": {"section_id": 155, "quality": 0.9767441860465116, "length": 42}, "so_17332320_17333188_1": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_17332320_17333188_0": {"section_id": 593, "quality": 0.8333333333333334, "length": 15}, "so_17332320_17333188_4": {"section_id": 157, "quality": 0.9285714285714286, "length": 13}, "so_17332320_17333188_3": {"section_id": 156, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_17332320_17333188_2": {"section_id": 165, "quality": 0.9767441860465116, "length": 42}, "so_17332320_17333188_3": {"section_id": 166, "quality": 0.9655172413793104, "length": 28}, "so_17332320_17333188_0": {"section_id": 629, "quality": 0.8333333333333334, "length": 15}, "so_17332320_17333188_4": {"section_id": 167, "quality": 0.9285714285714286, "length": 13}, "so_17332320_17333188_1": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}}}, "17333188": {"ParentId": "17332320", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You would think that the compiler, when resolving overloaded function templates, tries to figure out which of the templates matches the given arguments better. Based on that assumption, a template with a <code>uint8_t</code> should match a function call with a <code>uint8_t</code> argument better than a template for <code>int</code>.</p>\n<p>But that's not how template overload resolution works. Template overload resolution (\u00a714.5.6.2) is different from ordinary function overload resolution (\u00a713.3). It first establishes candidate templates and then, rather than trying to check how well each matches the given arguments, it simply establishes which of the two (or more) candidate templates is the most specialized.</p>\n<p>Note that this is a matter between the candidate templates only. It does not take into account the given arguments of the function call. (Those are taken into account for type deduction, which is only part of the procedure that establishes the candidate set of templates.)</p>\n<p>So it checks whether <code>uint8_t</code> is more specialized than <code>int</code> or vice versa (in general \u2013 not with respect to the given arguments of the function call at hand). It does this, basically, by checking whether any given <code>uint8_t</code> argument could (in theory) be used to fill an <code>int</code> parameter without non-standard conversions, and vice versa. This is the case (in both directions), so neither template is more specialized than the other. Hence the ambiguity cannot be resolved.</p>\n<hr>\n<p>The relevant sections of the Standard are as follows.</p>\n<p>First, \u00a713.3.3 establishes that when two functions templates (as opposed to two ordinary functions, or one function and one template) compete for a function call, the template overload mechanism is used to select the best:</p>\n<blockquote>\n<p id=\"so_17332320_17333188_0\">[...] a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_17332320_17333188_1\">[...]\n  \u2014 F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>Then, \u00a714.5.6.2 is very long, but the most relevant parts are:</p>\n<blockquote>\n<p id=\"so_17332320_17333188_2\">(2) Partial ordering selects which of two function templates is more specialized than the other by transforming each template in turn (see next paragraph) and performing template argument deduction using the function type. The deduction process determines whether one of the templates is more specialized than the other. If so, the more specialized template is the one chosen by the partial ordering process.</p>\n<p id=\"so_17332320_17333188_3\">(3) To produce the transformed template, for each type, non-type, or template template parameter (including template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively and substitute it for each occurrence of that parameter in the function type of the template. [...]</p>\n<p id=\"so_17332320_17333188_4\">(4) Using the transformed function template\u2019s function type, perform type deduction against the other template as described in 14.8.2.4.</p>\n</blockquote>\n<p>So the idea here is: Take the <code>uint8_t</code> template and <em>transform</em> it by replacing the <code>uint8_t</code> parameter with an actual, synthesized value (I guess that value could be taken from the actual function call, but the Standard doesn't say that). Then use the type deduction process to check if the transformed template, taken as a function call, would \"match\" the <em>other</em> template (i.e. the <code>int</code> template), i.e. if the <code>int</code> parameter of the other template could be deduced without non-standard conversions. The answer is yes, it could.</p>\n<p>Then go the other way, take the <code>int</code> template, synthesize a value and try if this \"matches\" the <code>uint8_t</code> template, i.e. if the <code>uint8_t</code> parameter could be deduced without non-standard conversions. The answer is yes again.</p>\n<p>If this works in only one direction, one of the two templates must be more specialized than the other and is chosen to resolve the ambiguity. If it works both ways (as in your case), the ambiguity cannot be resolved.</p>\n<p><em>Note.</em> The entire procedure is in fact more complicated, and its description in the Standard very long, mainly for the following reasons:</p>\n<ul>\n<li>The type deduction process itself is complicated. It does allow for certain implicit conversions (basically, standard-conversions including some related to cv-qualifiers);</li>\n<li>It has a number of special arbitration rules for the case when one candidate parameter is a const-reference and the other in a non-const reference, and some similar cases;</li>\n<li>Each candidate template may give rise to multiple transformed templates, especially when there is more than one template parameter to be deduced;</li>\n<li>The presence of default-arguments as well as template parameter packs complicates the situation further.</li>\n</ul>\n</hr>", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-06-27T02:01:21.990", "Id": "17333188", "Score": "5", "CreationDate": "2013-06-27T01:36:18.360", "LastActivityDate": "2013-06-27T02:01:21.990"}});