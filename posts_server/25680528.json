post_cb({"25682377": {"PostTypeId": "2", "Body": "<p>I think this may just be a bug in the mingw-w64 runtime or \"mingw-builds\"...</p>\n<p>It is possible that the runtime being used in the \"mingw-builds\" build has exported of the use of <code>std::string</code> with the default allocators from a pre-built dll (I have not been able to confirm this, it is possibly the mingw-w64 runtime itself), MSVC did something similar in the past (although I wouldn't know if this caused a similar error).</p>\n<p>Some combinations I've tried:</p>\n<ul>\n<li>The \"mingw-builds\" build using a <code>vector</code> and the overridden <code>operator new</code> is used as expected.</li>\n<li>Building the executable (mingw-builds) with a static binding (<code>--static</code>) to the runtime works as expected (for <code>string</code> and <code>vector</code>).</li>\n<li>The \"nuwen\" build and that works as expected for both <code>string</code> and <code>vector</code>.</li>\n<li>VS2013 also calls the overridden <code>operator new</code> was used with the <code>std::allocator</code> (with and without the <code>/MD</code> option).</li>\n<li>VS2008 (with <code>/MD</code>) produces the unexpected output (<code>std::string</code> is exported from the runtime dll, IIRC).</li>\n</ul>\n<p>From what I can make out the <code>std::string</code> is exported from \"libstdc++-6.dll\" and so the binding to <code>::operator new</code> etc. is probably already fixed (as you now know) in the binary for the <code>string</code> allocations.</p>\n<p>A simple change to the allocator;</p>\n<pre><code>template &lt;class C&gt;\nstruct myallocator : std::allocator&lt;C&gt; {\n};\n</code></pre>\n<p>Allows the overridden global <code>operator new</code> to work as expect with the \"mingw-builds\". You have already noted this with you full custom allocator, but the simple derivation here supports the notion that the \"default\" string class is possibly being sourced from a dll.</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n// replacement of a minimal set of functions:\nvoid* operator new(std::size_t sz) {\n    std::printf(\"global op new called, size = %d\\n\",sz);\n    return std::malloc(sz);\n}\nvoid operator delete(void* ptr) noexcept\n{\n    std::puts(\"global op delete called\");\n    std::free(ptr);\n}\ntemplate &lt;class C&gt;\nstruct myallocator : std::allocator&lt;C&gt; {\n};\nint main() {\n     using namespace std;\n\n     vector&lt;int&gt; def;\n     def.resize(100000);\n\n     basic_string&lt;char, char_traits&lt;char&gt;, myallocator&lt;char&gt;&gt; abc;\n     abc.resize(100000);\n}\n</code></pre>\n<p>Command lines</p>\n<pre class=\"lang-none prettyprint-override\"><code>cl /EHsc file.cpp\ncl /EHsc /MD file.cpp\ng++ --std=c++11 file.cpp\ng++ --static --std=c++11 file.cpp\n</code></pre>\n", "LastActivityDate": "2014-09-09T18:54:30.993", "LastEditorUserId": "3747990", "Id": "25682377", "CommentCount": "1", "CreationDate": "2014-09-05T09:11:38.177", "ParentId": "25680528", "Score": "3", "OwnerUserId": "3747990", "LastEditDate": "2014-09-09T18:54:30.993"}, "25680799": {"PostTypeId": "2", "Body": "<p>The gcc <code>basic_string</code> class does have a <code>allocator</code> argument for the template. This means that you could, with one small change (to the <code>stringfwd.h</code>), update <code>std::string</code> to use a different allocation method, including one that uses <code>new</code>. </p>\n<p>Where it says:</p>\n<pre><code>typedef basic_string&lt;char&gt;    string;   \n</code></pre>\n<p>change it to:</p>\n<pre><code>typedef basic_string&lt;char, char_traits&lt;char&gt;, my_allocator&gt;    string;   \n</code></pre>\n<p>Although I would expect that you may just see that the implementation is optimised and uses some internal storage for small strings - once you need a large enough string, it should use <code>new</code> for the allocation, I expect. </p>\n", "LastActivityDate": "2014-09-05T07:35:56.410", "Id": "25680799", "CommentCount": "3", "CreationDate": "2014-09-05T07:35:56.410", "ParentId": "25680528", "Score": "0", "OwnerUserId": "1919155"}, "25680660": {"PostTypeId": "2", "Body": "<p>n3376 20.6.9.2</p>\n<blockquote>\n<p id=\"so_25680528_25680660_0\"><code>pointer allocate(size_type n, allocator&lt;void&gt;::const_pointer hint = 0);</code></p>\n<p id=\"so_25680528_25680660_1\">Remark: <strong>the storage is obtained by calling ::operator new(std::size_t)</strong>\n  (18.6.1), but it is unspec- ified when or how often this function is\n  called. The use of hint is unspecified, but intended as an aid to\n  locality if an implementation so desires.</p>\n</blockquote>\n<p>Are you sure, that operator new is not called?</p>\n", "LastActivityDate": "2014-09-05T07:27:43.860", "Id": "25680660", "CommentCount": "0", "CreationDate": "2014-09-05T07:27:43.860", "ParentId": "25680528", "Score": "1", "OwnerUserId": "1498580"}, "bq_ids": {"n4140": {"so_25680528_25680660_1": {"length": 20, "quality": 0.8, "section_id": 4240}, "so_25680528_25680660_0": {"length": 4, "quality": 1.0, "section_id": 4237}}, "n3337": {"so_25680528_25680660_1": {"length": 20, "quality": 0.8, "section_id": 4081}, "so_25680528_25680660_0": {"length": 4, "quality": 1.0, "section_id": 4078}}}, "25680763": {"PostTypeId": "2", "Body": "<p>Maybe I can be wrong, but implementation of <code>operator new()</code> on Windows directly or indirectly calls <code>malloc()</code>, which calls functions such <code>VirtualAlloc</code> for real memory allocation by OS. There are no other ways for memory allocation and you may be calm about this.</p>\n", "LastActivityDate": "2014-09-05T07:34:02.827", "Id": "25680763", "CommentCount": "0", "CreationDate": "2014-09-05T07:34:02.827", "ParentId": "25680528", "Score": "-1", "OwnerUserId": "1047004"}, "25680528": {"ViewCount": "198", "Body": "<p>I just discovered that the default allocator for <code>basic_string&lt;char&gt;</code> from the STL in the implementation of <strong>GCC 4.9</strong> (using MinGW-w64) does not use the global <code>operator new()</code> but maybe directly <code>malloc</code>, but the implementation in <strong>MSVC 11</strong> (VS 2012) uses it.</p>\n<p>Also tried gcc 4.4.6 under CentOS and there the operator was called as expected.</p>\n<p>Why is there such a difference and isn't the MSVC approach the correct way? I would like to be able to track every allocation done by the STL by just providing my own <code>operator new()</code>.</p>\n<p>This is my test code:</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;cstdlib&gt;\n#include &lt;memory&gt;\n#include &lt;map&gt;\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nstruct MallocAllocator\n{\n    typedef std::size_t size_type;\n    typedef std::ptrdiff_t difference_type;\n    typedef T* pointer;\n    typedef const T* const_pointer;\n    typedef T&amp; reference;\n    typedef const T&amp; const_reference;\n    typedef T value_type;\n\n    pointer allocate(size_type n, const void* = 0) {\n        cout &lt;&lt; \"Custom: \" &lt;&lt; sizeof(value_type) * n &lt;&lt; endl;\n        return static_cast&lt;pointer&gt;(malloc(sizeof(value_type) * n));\n    }\n\n    void deallocate(pointer ptr, size_type) {\n        free(ptr);\n    }\n\n    // boilerplate follows\n    MallocAllocator() {}\n\n    MallocAllocator(const MallocAllocator&amp;) {}\n\n    size_type max_size () const throw() { return std::numeric_limits&lt;std::size_t&gt;::max() / sizeof(T); }\n\n    template &lt;typename Other&gt;\n    MallocAllocator(const MallocAllocator&lt;Other&gt;&amp;) {}\n\n    MallocAllocator&amp; operator=(const MallocAllocator&amp;) { return *this; }\n\n    template &lt;class Other&gt;\n    MallocAllocator&amp; operator=(const MallocAllocator&lt;Other&gt;&amp;) { return *this; }\n\n    template &lt;typename Other&gt;\n    struct rebind { typedef MallocAllocator&lt;Other&gt; other; };\n\n    pointer address(reference ref) const {\n        return &amp;ref;\n    }\n\n    const_pointer address(const_reference ref) const {\n        return &amp;ref;\n    }\n\n    void construct(pointer ptr, const value_type&amp; val) {\n        ::new(ptr) value_type(val);\n    }\n\n    void destroy(pointer ptr) {\n        ptr-&gt;~value_type();\n    }\n};\n\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const MallocAllocator&lt;T&gt;&amp;, const MallocAllocator&lt;U&gt;&amp;) {\n    return true;\n}\n\ntemplate &lt;typename T, typename U&gt;\ninline bool operator!=(const MallocAllocator&lt;T&gt;&amp; a, const MallocAllocator&lt;U&gt;&amp; b) {\n    return !(a == b);\n}\n\nvoid *operator new(size_t s) {\n    cout &lt;&lt; \"Global: \" &lt;&lt; s &lt;&lt; endl;\n    return (void*)malloc(s);\n}\n\nvoid *operator new[](size_t s) {\n    cout &lt;&lt; \"Global: \" &lt;&lt; s &lt;&lt; endl;\n    return (void*)malloc(s);\n}\n\nint main(int argc, char** argv) {\n    //basic_string&lt;char, char_traits&lt;char&gt;, MallocAllocator&lt;char&gt; &gt; s;\n    basic_string&lt;char&gt; s;\n    s = \"dfasdf\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \".\";\n    s += \"dfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfsdfasdfsdfasfs\";\n\n    cout &lt;&lt; s &lt;&lt; endl;\n\n#ifdef _MSC_VER\n    system(\"pause\");\n#endif\n\n    return 0;\n}\n</code></pre>\n<p>With GCC from MinGW-w64: When I use the custom allocator, I see the allocations. When I do not use it, I see nothing.</p>\n", "AcceptedAnswerId": "25682377", "Title": "Difference in allocation policy between implementations of STL?", "CreationDate": "2014-09-05T07:19:05.597", "Id": "25680528", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-09-15T11:23:48.597", "LastEditorUserId": "3747990", "LastActivityDate": "2014-09-15T11:23:48.597", "Score": "4", "OwnerUserId": "3162383", "Tags": "<c++><visual-c++><memory-management><stl><mingw-w64>", "AnswerCount": "4"}});