post_cb({"bq_ids": {"n4140": {"so_33115803_33116008_1": {"length": 9, "quality": 0.5625, "section_id": 433}, "so_33115803_33115832_0": {"length": 14, "quality": 1.0, "section_id": 3344}, "so_33115803_33161312_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 3344}}, "n3337": {"so_33115803_33115832_0": {"length": 14, "quality": 1.0, "section_id": 3214}, "so_33115803_33116008_1": {"length": 9, "quality": 0.5625, "section_id": 425}, "so_33115803_33161312_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 3214}}, "n4659": {"so_33115803_33115832_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 4111}, "so_33115803_33116008_1": {"length": 9, "quality": 0.5625, "section_id": 451}}}, "33116008": {"Id": "33116008", "PostTypeId": "2", "Body": "<p>Class constructors have two parts, a member initializer list and a function body. With constructor delegation, the initializer list and function body of the delegated (target) constructor is first executed. After that, the function body of the delegating constructor is executed. You may, in certain cases, consider an object to be fully constructed when both the initializer list and the function body of some constructor are executed.\nThat's why the wiki says <em>each delegating constructor will be executing on a fully constructed object of its own type</em>. In fact, the semantics can be more accurately described as:</p>\n<p>...<strong>the function body of</strong> each delegating constructor will be executing on a fully constructed object of its own type.</p>\n<p>However, the delegated constructor may only partially construct the object, and is designed to be invoked by other constructors only other than to be used alone. Such a constructor is usually declared private. So, it may not always be appropriate to consider the object to be fully constructed after the execution of the delegated constructor.</p>\n<p>Anyway, since only a single initializer list is performed, there is no such overhead as you have mentioned. Following are quoted from <a href=\"http://en.cppreference.com/w/cpp/language/initializer_list#Delegating_constructor\" rel=\"nofollow\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_33115803_33116008_0\">If the name of the class itself appears as class-or-identifier in the\n  member initializer list, then the list must consist of that one member\n  initializer only; such constructor is known as the delegating\n  constructor, and the constructor selected by the only member of the\n  initializer list is the target constructor</p>\n<p id=\"so_33115803_33116008_1\">In this case, the target constructor is selected by overload\n  resolution and executed first, then the control returns to the\n  delegating constructor and its body is executed.</p>\n<p id=\"so_33115803_33116008_2\">Delegating constructors cannot be recursive.</p>\n</blockquote>\n", "LastEditorUserId": "1348273", "LastActivityDate": "2015-10-14T03:35:07.883", "Score": "3", "CreationDate": "2015-10-14T03:14:27.887", "ParentId": "33115803", "CommentCount": "11", "OwnerUserId": "1348273", "LastEditDate": "2015-10-14T03:35:07.883"}, "33115803": {"ViewCount": "334", "Body": "<p>[this question has been highly edited; pardon that, I've moved the edits into an answer below]</p>\n<p>From <a href=\"https://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement\">Wikipedia (subarticle included)</a> on C++11:</p>\n<blockquote>\n<p id=\"so_33115803_33115803_0\">This [<em>new delegating constructors feature</em>] comes with a caveat: C++03 considers an object to be constructed when its constructor finishes executing, but <strong>C++11 considers an object constructed once any constructor finishes execution. Since multiple constructors will be allowed to execute, this will mean that each delegating constructor will be executing on a fully constructed object of its own type.</strong> Derived class constructors will execute after all delegation in their base classes is complete.\"</p>\n</blockquote>\n<p>Does this mean that delegation chains construct a unique temporary object for every link in a ctor delegation chain? That kind of overhead just to avoid a simple init function definition would not be worth the additional overhead.</p>\n<p><em>Disclaimer: I asked this question, because I'm a student, but the answers thus far have all been incorrect and demonstrate a lack of research and/or understanding of the research referenced. I've been somewhat frustrated by this, and as a result my edits and comments have been hastily and poorly composed, mostly over smart phone. Please excuse this; I hope I've minimized that in my answer below, and I have learned that I need to be careful, complete, and clear in my comments.</em></p>\n", "Title": "Do C++11 delegated ctors perform worse than C++03 ctors calling init functions?", "CreationDate": "2015-10-14T02:50:57.880", "LastActivityDate": "2015-10-16T17:53:55.167", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-10-16T00:48:11.163", "LastEditorUserId": "5122006", "Id": "33115803", "Score": "10", "OwnerUserId": "5122006", "Tags": "<c++><performance><c++11><constructor><delegating-constructor>", "AnswerCount": "3"}, "33115832": {"Id": "33115832", "PostTypeId": "2", "Body": "<p>No. They are equivalent. The delegating constructor behaves like an ordinary member function acting on the Object constructed by the previous constructor. </p>\n<p>I couldn't find any information explicitly supporting this in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986\" rel=\"noreferrer\">proposal for adding delegating constructors</a>, but creating copies is not possible in the general case. Some classes may not have copy constructors.</p>\n<p>In Section 4.3 - Changes to \u00a715, the proposed change to the standard states:</p>\n<blockquote>\n<p id=\"so_33115803_33115832_0\">if the non\u2010delegating constructor for an object has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s destructor will be invoked.</p>\n</blockquote>\n<p>This implies that the delegating constructor works on a completely constructed object (depending on how you define that) and allows the implementation to have delegating ctors work like member functions.</p>\n", "LastEditorUserId": "1278288", "LastActivityDate": "2015-10-14T05:40:36.387", "Score": "5", "CreationDate": "2015-10-14T02:54:34.097", "ParentId": "33115803", "CommentCount": "10", "OwnerUserId": "1278288", "LastEditDate": "2015-10-14T05:40:36.387"}, "33161312": {"Id": "33161312", "PostTypeId": "2", "Body": "<p><strong>Chained delegating constructors in C++11 do incur more overhead than the C++03 init function style!</strong></p>\n<p>See C++11 standard draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">N3242</a>, section 15.2. An exception may occur in the execution block of any link in the delegation chain, and C++11 extends existing exception handling behavior to account for that.</p>\n<p><em>[text] and <strong>emphasis</strong> mine.</em></p>\n<blockquote>\n<p id=\"so_33115803_33161312_0\">An object of any storage duration whose initialization or destruction is terminated by an exception will have destructors executed for all of its fully constructed subobjects ..., that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution. <strong>Similarly</strong>, if the non-delegating constructor for an object has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s [treated like a subobject as above] destructor will be invoked.</p>\n</blockquote>\n<p>This is describing delegating ctors' consistency with the C++ object stack model, which necessarily introduces overhead.</p>\n<p>I had to get familiar with things like how the stack works on a hardware level, what the stack pointer is, what automatic objects are, and what stack unwinding is, to really understand how this works. Technically these terms/concepts are implementation defined details, so N3242 does not define any of these terms; but it does use them.</p>\n<p>The gist of it: Objects declared on the stack are allocated onto memory, and the executable handles the addressing and cleanup for you. The implementation of the stack was simple in C, but in C++, we have exceptions, and they demand an extension of C's stack unwinding. Section 5 of <a href=\"http://www.stroustrup.com/except89.pdf\" rel=\"nofollow\">a paper by Stroustrup</a>* discusses the need for extended stack unwinding, and the necessary additional overhead introduced by such a feature:</p>\n<blockquote>\n<p id=\"so_33115803_33161312_1\">If a local object has a destructor, that destructor must be called as part of the stack unwinding. [A C++ extension of stack unwinding for automatic objects requires] ...an implementation technique that (in addition to the standard overhead of establishing a handler) involves only minimal overhead.</p>\n</blockquote>\n<p>It's this very implementation technique and overhead that you add into your code for <strong>every link in your delegation chain.</strong> Every scope has the potential for an exception, and every constructor has its own scope, so every constructor in the chain adds overhead (as compared to an init function that only introduces one additional scope).</p>\n<p>It's true that the overhead is minimal, and I'm sure that sane implementations optimize simple cases to remove that overhead. However, consider a case where you've got a 5 class inheritance chain. Let's say each of these classes has 5 constructors, and within each class, these constructors call each other in a chain to reduce redundant coding. If you instantiate an instance of the most derived class, you will incur the above described overhead up to <strong>25</strong> times, whereas the C++03 version would've incurred that overhead up to <strong>10</strong> times. If you make these classes virtual and multiply inheriting, this overhead will increase related to the accumulation of those features, as well as those features themselves introducing additional overhead. The moral here, is that as your code scales, you will feel the bite of this new feature.</p>\n<p>*<em>The Stroustrup reference was written a long time ago, to motivate discussion on C++ exception handling and defines potential (not necessarily) C++ language features. I chose this reference over some implementation specific reference because it is human readable, and 'portable.' My core use of this paper is section 5: specifically the discussion of the need for C++ stack unwinding, and the necessity of its overhead incurrence. These concepts are legitimized within the paper, and are valid today for C++11.</em></p>\n", "LastEditorUserId": "5122006", "LastActivityDate": "2015-10-16T17:53:55.167", "Score": "3", "CreationDate": "2015-10-16T01:52:15.200", "ParentId": "33115803", "CommentCount": "3", "OwnerUserId": "5122006", "LastEditDate": "2015-10-16T17:53:55.167"}});