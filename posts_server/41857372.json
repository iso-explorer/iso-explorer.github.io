post_cb({"41954927": {"ParentId": "41857372", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>To concatenate more than two strings, it's faster to reserve enough space for the new string before, and append to it the different strings (less copy constructors, operations, temporary variables...) than to use many times an operation on two strings (result, in concat example, is in parameter str) :</p>\n<pre><code>void concat (const std::list&lt;std::string&gt;&amp; ls, std::string&amp; str) {\n  size_t ns (0);\n  std::list&lt;std::string&gt;::const_iterator i (ls.begin());\n  for (; i != ls.end (); i++) ns += i-&gt;size ();\n  str.reserve (ns);\n  str.erase (str.begin (), str.end ());\n  for (i = ls.begin (); i != ls.end (); i++) str.append (*i);\n}\n</code></pre>\n", "OwnerUserId": "6514807", "LastEditorUserId": "6514807", "LastEditDate": "2017-04-12T14:39:14.907", "Id": "41954927", "Score": "-1", "CreationDate": "2017-01-31T10:17:13.977", "LastActivityDate": "2017-04-12T14:39:14.907"}, "41857372": {"CommentCount": "6", "ViewCount": "331", "PostTypeId": "1", "LastEditorUserId": "3991400", "CreationDate": "2017-01-25T17:01:50.550", "LastActivityDate": "2017-04-12T14:39:14.907", "Title": "C++ String Concatenation Optimizations", "LastEditDate": "2017-02-01T00:14:49.963", "Id": "41857372", "Score": "4", "Body": "<p>Looking at a piece of code like this (comments added):</p>\n<pre><code>std::string some_var;\nstd::string some_func(); // both are defined, but definition is irrelevant\n...\nreturn \"some text \" + some_var + \"c\" + some_func(); // intentionally \"c\" not 'c'\n</code></pre>\n<p>I was wondering, <strong>in which cases <code>operator +</code> of <code>std::string</code> has to make a copy (in the sense of using copy-construction/assignment, not the internal buffer being copied e.g. if SSO applies), and what actually gets copied</strong>. A quick look at <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%2B\" rel=\"nofollow noreferrer\">cppreference</a> was only partially helpful, as it lists 12(!) different cases. In part I am asking to confirm my understanding of the page:</p>\n<ul>\n<li>Case 1) makes a copy of lhs then copies rhs to end of this copy</li>\n<li>In C++98 Case 2) - 5) a temporary string is constructed from the <code>char/const char*</code> argument, which then results in case 1)</li>\n<li>In C++11 Case 2) - 5) a temporary string is constructed from the \n<code>char/const char*</code> argument, which then results in case 6) or 7)</li>\n<li>In C++11 Case 6) - 12) the r-value argument will be mutated with <code>insert/append</code> and, if a <code>char/const char*</code> argument was provided, no temporary is necessary due to the overloads on <code>insert/append</code>. In all cases an r-value is returned to facilitate further chaining. No copies are made (except the copy of the arguments to be appended/inserted at the insertion location). The contents of the string may need to be moved.</li>\n</ul>\n<p>A chain like the example above should thus result in: 2) -&gt; 6) -&gt; 11) -&gt; 8), with no copies of any lhs being made, but just modifications to the buffer of the r-value resulting from the first operation (creation of the temp-string). </p>\n<p>Therefore this seems to be as efficient as <code>operator +=</code>, once <code>operator +</code> uses at least on r-value argument. Is this correct, and <strong>is there any point in using <code>operator +=</code> over <code>operator +</code> in C++11 and after anymore, unless the both arguments are l-value strings?</strong></p>\n<p><strong>What optimizations can the compiler make in addition?</strong></p>\n<p>Edit: clarify intent of the question. Initial part is about the specifics of the language only (implementation non-withstanding); the last question is about additional optimizations.</p>\n", "Tags": "<c++><c++11><stl><language-lawyer><stdstring>", "OwnerUserId": "3991400", "AnswerCount": "2"}, "41957932": {"ParentId": "41857372", "CommentCount": "3", "Body": "<p>A string is a rather opaque object: it holds an internal char buffer and manages it the way it wants. Adding a single character to a string may end in allocation of a new buffer, copy of the initial part and copy of the added part. All depends whether the allocated buffer is large enough to accept to added part.</p>\n<p>The quotation says: </p>\n<blockquote>\n<p id=\"so_41857372_41957932_0\">... No copies are made (except the copy of the arguments to be appended/inserted at the insertion location). <strong>The contents of the string may need to be moved</strong>.</p>\n</blockquote>\n<p>Said differently a new allocation, a full copy and deallocation of the old buffer...</p>\n<p>And when you speak of efficiency and optimization, you must remember that the compiler has not to follow the way you have written the program. Because of the <em>as-if</em> rule, it can optimize the way it want, provided the observable behaviour is respected. C++ standard says:</p>\n<blockquote>\n<p id=\"so_41857372_41957932_1\">1.9 Program execution [intro.execution]<br/> ...<br/>\n  5 A conforming implementation executing a well-formed program shall produce the same observable behavior\n  as one of the possible executions of the corresponding instance of the abstract machine with the same program\n  and the same input.</p>\n</blockquote>\n<p>A note explains even that:</p>\n<blockquote>\n<p id=\"so_41857372_41957932_2\">an implementation is free to disregard any requirement of this\n  International Standard as long as the result is as if the requirement had been obeyed, as far as can be determined from the\n  observable behavior of the program.</p>\n</blockquote>\n<p>So it is likely that <code>a = a + b;</code> and <code>a += b;</code> are compiled in exactly the same code.</p>\n<p>You should never worry for low level optimizations when you write a C++ program: the compiler will care for it and it is commonly said that <em>compiler is smarter than you</em>. Only go that way when you have identified a real bottleneck, and be aware that low level optimization if only for one compiler on one architecture and one configuration.</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "41957932", "Score": "0", "CreationDate": "2017-01-31T12:43:11.593", "LastActivityDate": "2017-01-31T12:43:11.593"}, "bq_ids": {"n4140": {"so_41857372_41957932_1": {"section_id": 5801, "quality": 0.8571428571428571, "length": 18}, "so_41857372_41957932_2": {"section_id": 5797, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_41857372_41957932_1": {"section_id": 5574, "quality": 0.8571428571428571, "length": 18}, "so_41857372_41957932_2": {"section_id": 5570, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_41857372_41957932_2": {"section_id": 7256, "quality": 0.9411764705882353, "length": 16}, "so_41857372_41957932_1": {"section_id": 7260, "quality": 0.8571428571428571, "length": 18}}}});