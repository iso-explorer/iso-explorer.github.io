post_cb({"33704978": {"CommentCount": "9", "ViewCount": "1936", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2015-11-14T04:02:46.303", "LastActivityDate": "2015-11-14T06:53:31.540", "Title": "Why do I need to #include <typeinfo> when using the typeid operator?", "AcceptedAnswerId": "33705079", "LastEditDate": "2015-11-14T04:46:16.337", "Id": "33704978", "Score": "10", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/language/typeid\"><code>typeid</code></a> represents a C++ RTTI operator being also a C++ keyword. It returns a <a href=\"http://en.cppreference.com/w/cpp/types/type_info\"><code>std::type_info</code></a> object that holds (dynamic) type specific information.</p>\n<p>From what I understood from various sources, one MUST include <code>&lt;typeinfo&gt;</code> when using <code>typeid</code>, otherwise the program is ill-formed. In fact, my gcc5.2 compiler doesn't even compile the program if I don't include the before-mentioned header. I don't understand why is a header inclusion mandated for the usage of a C++ <em>keyword</em>. I understand mandating a header for whenever we use some object declared/defined in that header, but <code>typeid</code> is not of a class type. So what is the reason behind this enforcement of including the header <code>&lt;typeinfo&gt;</code>?</p>\n", "Tags": "<c++><rtti><typeid>", "OwnerUserId": "3093378", "AnswerCount": "2"}, "33705667": {"ParentId": "33704978", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><code>typeid</code> is not the only one that needs header</p>\n<p><code>new</code> also requires header <code>&lt;new&gt;</code> in some cases</p>\n<blockquote>\n<p id=\"so_33704978_33705667_0\">Note: the implicit declarations do not introduce the names std, std::bad_alloc, and std::size_t, or any other names that the library uses to declare these names. Thus, a new-expression, delete-expression or function call that refers to one of these functions without including the header is well-formed. However, referring to std, std::bad_alloc, and std::size_t is ill-formed unless the name has been declared by including the appropriate header. \u2014end note</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/a/2788548/5475140\">See abhay's answer on new keyword</a></p>\n<p>Another operator <code>sizeof</code> which returns std::size_t ( It does not actually need to include header, but my point here is that it uses an alias which is also defined in a header) </p>\n<p>C++ \u00a75.3.3</p>\n<blockquote>\n<p id=\"so_33704978_33705667_1\">The result of sizeof and sizeof... is a constant of type std::size_t. [Note: std::size_t is defined in the standard header <code>&lt;cstddef&gt;</code>(18.2).\u2014 end note]</p>\n</blockquote>\n<p><code>typeid</code> use classes which are declared in <code>&lt;typeinfo&gt;</code> header</p>\n<p>Header <code>&lt;typeinfo&gt;</code> synopsis</p>\n<pre><code>namespace std {\nclass type_info;\nclass bad_cast;\nclass bad_typeid;\n}\n</code></pre>\n<p><a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow noreferrer\">See section 18.7 on iso cpp paper</a></p>\n<p>IMO, Its C++ Standard Design Techniques, to keep the compiler neat, clean and lightweight</p>\n", "OwnerUserId": "5475140", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:48:18.050", "Id": "33705667", "Score": "3", "CreationDate": "2015-11-14T06:09:57.507", "LastActivityDate": "2015-11-14T06:53:31.540"}, "bq_ids": {"n4140": {"so_33704978_33705079_0": {"section_id": 6187, "quality": 0.5294117647058824, "length": 9}, "so_33704978_33705667_0": {"section_id": 7174, "quality": 0.8461538461538461, "length": 33}, "so_33704978_33705667_1": {"section_id": 6081, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_33704978_33705667_0": {"section_id": 6918, "quality": 0.8461538461538461, "length": 33}, "so_33704978_33705667_1": {"section_id": 5849, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_33704978_33705667_1": {"section_id": 7577, "quality": 0.6428571428571429, "length": 9}, "so_33704978_33705667_0": {"section_id": 8682, "quality": 0.8717948717948718, "length": 34}}}, "33705079": {"ParentId": "33704978", "CommentCount": "1", "Body": "<p>The next paragraph:</p>\n<blockquote>\n<p id=\"so_33704978_33705079_0\">The typeid expression is lvalue expression which refers to an object\n  with static storage duration, of the polymorphic type const\n  std::type_info or of some type derived from it.</p>\n</blockquote>\n<p>Because it is an lvalue expression, which uses <a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization\">reference initialization</a> to declare an initializer of <code>std::type_info</code>. <code>&lt;typeinfo&gt;</code> contains the definition for <a href=\"http://en.cppreference.com/w/cpp/types/type_info\">that object</a>.</p>\n", "OwnerUserId": "1575699", "PostTypeId": "2", "Id": "33705079", "Score": "6", "CreationDate": "2015-11-14T04:22:16.290", "LastActivityDate": "2015-11-14T04:22:16.290"}});