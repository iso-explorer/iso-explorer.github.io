post_cb({"4547902": {"Id": "4547902", "PostTypeId": "2", "Body": "<p>In C++ since the beginning of times the presence of an <em>initializer</em> was an exclusive attribute of object <em>definition</em>, i.e. a declaration with an initializer is always a <em>definition</em> (almost always). </p>\n<p>As you must know, each external object used in C++ program has to be defined once and only once in only one translation unit. Allowing in-class initializers for static objects would immediately go against this convention: the initializers would go into header files (where class definitions usually reside) and thus generate multiple definitions of the same static object (one for each translation unit that includes the header file). This is, of course, unacceptable. For this reason, the declaration approach for static class members is left perfectly \"traditional\": you only <em>declare</em> it in the header file (i.e. no initializer allowed), and then you <em>define</em> it in a translation unit of your choice (possibly with an initializer).</p>\n<p>One exception from this rule was made for const static class members of integral or enum types, because such entries can for Integral Constant Expressions (ICEs). The main idea of ICEs is that they are evaluated at compile time and thus do no depend on definitions of the objects involved. Which is why this exception was possible for integral or enum types. But for other types it would just contradict the basic declaration/definition principles of C++.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2012-08-09T18:54:04.263", "Score": "11", "CreationDate": "2010-12-28T17:22:58.623", "ParentId": "4547660", "CommentCount": "0", "LastEditDate": "2012-08-09T18:54:04.263", "OwnerUserId": "187690"}, "4547772": {"Id": "4547772", "PostTypeId": "2", "Body": "<p>Fundamentally this is because static members must be defined in exactly one translation unit, in order to not violate the <a href=\"https://stackoverflow.com/questions/4192170/what-exactly-is-one-definition-rule-in-c\">One-Definition Rule</a>.  If the language were to allow something like:</p>\n<pre><code>struct Gizmo\n{\n  static string name = \"Foo\";\n};\n</code></pre>\n<p>then <code>name</code> would be defined in each translation unit that <code>#include</code>s this header file.</p>\n<p>C++ does allow you to define <em>integral</em> static members within the declaration, but you still have to include a definition within a single translation unit, but this is just a shortcut, or syntactic sugar.  So, this is allowed:</p>\n<pre><code>struct Gizmo\n{\n  static const int count = 42;\n};\n</code></pre>\n<p>So long as a) the expression is <code>const</code> integral or enumeration type, b) the expression can be evaluated at compile-time, and c) there is still a definition somewhere that doesn't violate the one definition rule:</p>\n<p>file: gizmo.cpp</p>\n<pre><code>#include \"gizmo.h\"\n\nconst int Gizmo::count;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-12-28T17:15:13.300", "Score": "36", "CreationDate": "2010-12-28T17:02:35.500", "ParentId": "4547660", "CommentCount": "3", "LastEditDate": "2017-05-23T11:44:17.893", "OwnerUserId": "241536"}, "4547710": {"Id": "4547710", "PostTypeId": "2", "Body": "<p>It's because of the way the code is compiled. If you were to initialize it in the class, which often is in the header, every time the header is included you'd get an instance of the static variable. This is definitely not the intent. Having it initialized outside the class gives you the possibility to initialize it in the cpp file.</p>\n", "LastActivityDate": "2010-12-28T16:52:18.550", "Score": "2", "CreationDate": "2010-12-28T16:52:18.550", "ParentId": "4547660", "CommentCount": "7", "OwnerUserId": "551045"}, "bq_ids": {"n4140": {"so_4547660_4548031_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5908}}, "n3337": {"so_4547660_4548031_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5680}}, "n4659": {"so_4547660_4548031_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 7390}}}, "4548031": {"Id": "4548031", "PostTypeId": "2", "Body": "<p>Section 9.4.2, Static data members, of the C++ standard states:</p>\n<blockquote>\n<p id=\"so_4547660_4548031_0\">If a <code>static</code> data member is of <code>const</code> integral or <code>const</code> enumeration type, its declaration in the class definition can specify a <em>const-initializer</em> which shall be an integral constant expression.</p>\n</blockquote>\n<p>Therefore, it is possible for the value of a static data member to be included \"within the class\" (by which I presume that you mean within the declaration of the class). However, the type of the static data member must be a <code>const</code> integral or <code>const</code> enumeration type. The reason why the values of static data members of other types cannot be specified within the class declaration is that non-trivial initialization is likely required (that is, a constructor needs to run).</p>\n<p>Imagine if the following were legal:</p>\n<pre><code>// my_class.hpp\n#include &lt;string&gt;\n\nclass my_class\n{\npublic:\n  static std::string str = \"static std::string\";\n//...\n</code></pre>\n<p>Each object file corresponding to CPP files that include this header would not only have a copy of the storage space for <code>my_class::str</code> (consisting of <code>sizeof(std::string)</code> bytes), but also a \"ctor section\" that calls the <code>std::string</code> constructor taking a C-string. Each copy of the storage space for <code>my_class::str</code> would be identified by a common label, so a linker could theoretically merge all copies of the storage space into a single one. However, a linker would not be able to isolate all copies of the constructor code within the object files' ctor sections. It would be like asking the linker to remove all of the code to initialize <code>str</code> in the compilation of the following:</p>\n<pre><code>std::map&lt;std::string, std::string&gt; map;\nstd::vector&lt;int&gt; vec;\nstd::string str = \"test\";\nint c = 99;\nmy_class mc;\nstd::string str2 = \"test2\";\n</code></pre>\n<p><strong>EDIT</strong> It is instructive to look at the assembler output of g++ for the following code:</p>\n<pre><code>// SO4547660.cpp\n#include &lt;string&gt;\n\nclass my_class\n{\npublic:\n    static std::string str;\n};\n\nstd::string my_class::str = \"static std::string\";\n</code></pre>\n<p>The assembly code can be obtained by executing:</p>\n<pre><code>g++ -S SO4547660.cpp\n</code></pre>\n<p>Looking through the <code>SO4547660.s</code> file that g++ generates, you can see that there is a lot of code for such a small source file.</p>\n<p><code>__ZN8my_class3strE</code> is the label of the storage space for <code>my_class::str</code>. There is also the assembly source of a <code>__static_initialization_and_destruction_0(int, int)</code> function, which has the label <code>__Z41__static_initialization_and_destruction_0ii</code>. That function is special to g++ but just know that g++ will make sure that it gets called before any non-initializer code gets executed. Notice that the implementation of this function calls <code>__ZNSsC1EPKcRKSaIcE</code>. This is the mangled symbol for <code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(char const*, std::allocator&lt;char&gt; const&amp;)</code>.</p>\n<p>Going back to the hypothetical example above and using these details, each object file corresponding to a CPP file that includes <code>my_class.hpp</code> would have the label \n<code>__ZN8my_class3strE</code> for <code>sizeof(std::string)</code> bytes as well as assembly code to call <code>__ZNSsC1EPKcRKSaIcE</code> within its implementation of the <code>__static_initialization_and_destruction_0(int, int)</code> function. The linker can easily merge all occurrences of <code>__ZN8my_class3strE</code>, but it cannot possibly isolate the code that calls <code>__ZNSsC1EPKcRKSaIcE</code> within the object file's implementation of <code>__static_initialization_and_destruction_0(int, int)</code>.</p>\n", "LastEditorUserId": "196844", "LastActivityDate": "2010-12-28T22:18:13.787", "Score": "1", "CreationDate": "2010-12-28T17:40:58.667", "ParentId": "4547660", "CommentCount": "4", "LastEditDate": "2010-12-28T22:18:13.787", "OwnerUserId": "196844"}, "4547749": {"Id": "4547749", "PostTypeId": "2", "Body": "<p>I think the main reason to have initialization done outside the <code>class</code> block is to allow for initialization with return values of other class member functions. If you wanted to intialize <code>a::var</code> with <code>b::some_static_fn()</code> you'd need to make sure that every <code>.cpp</code> file that includes <code>a.h</code> includes <code>b.h</code> first. It'd be a mess, especially when (sooner or later) you run into a circular reference that you could only resolve with an otherwise unnecessary <code>interface</code>. The same issue is the main reason for having class member function implementations in a <code>.cpp</code> file instead of putting everything in your main class' <code>.h</code>.</p>\n<p>At least with member functions you do have the option to implement them in the header. With variables you must do the initialization in a .cpp file. I don't quite agree with the limitation, and I don't think there's a good reason for it either.</p>\n", "LastActivityDate": "2010-12-28T16:59:01.823", "Score": "0", "CreationDate": "2010-12-28T16:59:01.823", "ParentId": "4547660", "CommentCount": "0", "OwnerUserId": "213765"}, "4547660": {"ViewCount": "46881", "Body": "<p><br>\nFor static member variables in C++ class - the initialization is done outside the class. I wonder why? Any logical reasoning/constraint for this? Or is it purely legacy implementation - which the standard does not want to correct?  </br></p>\n<p>I think having initialization in the class is more \"intuitive\" and less confusing.It also gives the sense of both static and global-ness of the variable. For example if you see the static const member.</p>\n", "AcceptedAnswerId": "4547772", "Title": "C++ static member variable and its initialization", "CreationDate": "2010-12-28T16:46:32.010", "Id": "4547660", "CommentCount": "0", "FavoriteCount": "13", "PostTypeId": "1", "LastActivityDate": "2012-08-09T18:54:04.263", "Score": "41", "OwnerUserId": "327096", "Tags": "<c++><initialization><static-variables>", "AnswerCount": "5"}});