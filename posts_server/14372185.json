post_cb({"14392170": {"ParentId": "14372185", "CommentCount": "0", "CreationDate": "2013-01-18T04:01:45.033", "OwnerUserId": "1929432", "PostTypeId": "2", "Id": "14392170", "Score": "0", "Body": "<p>Using <code>static</code> with <code>inline</code> should fix 'multiple definitions' problem. Even for a compiler which can't decide on its own that it shouldn't generate symbols for 'inline'd functions.</p>\n", "LastActivityDate": "2013-01-18T04:01:45.033"}, "14372185": {"CommentCount": "8", "ViewCount": "1166", "PostTypeId": "1", "LastEditorUserId": "116621", "CreationDate": "2013-01-17T04:23:10.717", "LastActivityDate": "2013-01-24T14:46:43.593", "Title": "Compatible definitions of inline functions for C99 and C++", "AcceptedAnswerId": "14504020", "LastEditDate": "2013-01-18T03:23:46.717", "Id": "14372185", "Score": "3", "Body": "<p>I have a utility library of C99 code used by C++11 application code. A few inline functions are declared in the C99 style with code explicitly generated in the translation unit like:</p>\n<pre><code>// buffer.h\ninline bool has_remaining(void* obj) {\n...\n}\n\n// buffer.c\nextern inline bool has_remaining(void * obj);\n</code></pre>\n<p>However, when I try to use <code>has_remaining</code> in the C++ application, I get errors about multiple definitions at link time. It seems that g++ is instantiating the inline code that already exists in the library, despite the <code>extern \"C\"</code> <strike>header guards</strike> specifier.</p>\n<p>Is there a way to coerce g++ into working with this type of definition? </p>\n<p>It looks like if I <code>#ifdef __cplusplus</code> an extern definition with the <code>gnu_inline</code> attribute, the right thing will happen, but surely there is a more portable way to keep modern C headers compatible with modern C++?</p>\n<p><strong>-- Edit: Working Example --</strong></p>\n<p>buffer.h:</p>\n<pre><code>#ifndef BUFF_H\n#define BUFF_H\n\n#include &lt;stdbool.h&gt;\n#include &lt;stddef.h&gt;\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ninline bool has_remaining(void const* const obj) {\n    return (obj != NULL);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* BUFF_H */\n</code></pre>\n<p>buffer.c:</p>\n<pre><code>#include \"buffer.h\"\n\nextern inline bool has_remaining(void const* const obj);\n</code></pre>\n<p>app.cpp:</p>\n<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n#include \"buffer.h\"\n\nint main(int argc, char** argv) {\n  char const* str = \"okay\";\n  printf(str);\n\n  has_remaining(str);\n\n  return (0);\n}\n</code></pre>\n<p>compile:</p>\n<pre><code>$ gcc -std=gnu99 -o buffer.o -c buffer.c\n$ g++ -std=gnu++11 -o app.o -c app.cpp\n$ g++ -Wl,--subsystem,console -o app.exe app.o buffer.o\n\nbuffer.o:buffer.c:(.text+0x0): multiple definition of `has_remaining'\napp.o:app.cpp:(.text$has_remaining[_has_remaining]+0x0): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre>\n<p><strong>--Edit 2--</strong>\nThe <code>__gnu_inline__</code> attribute does indeed fix the problem of multiple definitions. I'd still like to see a (more) portable approach or some conclusive reasoning why one doesn't exist.</p>\n<pre><code>#if defined(__cplusplus) &amp;&amp; defined(NOTBROKEN)\n#define EXTERN_INLINE extern inline __attribute__((__gnu_inline__))\n#else\n#define EXTERN_INLINE inline\n#endif\n\nEXTERN_INLINE bool has_remaining(void const* const obj) {\n  return (obj != NULL);\n}\n</code></pre>\n", "Tags": "<c++><c><gcc><c++11><c99>", "OwnerUserId": "116621", "AnswerCount": "3"}, "14374396": {"ParentId": "14372185", "CommentCount": "2", "CreationDate": "2013-01-17T07:50:09.477", "OwnerUserId": "1595323", "PostTypeId": "2", "Id": "14374396", "Score": "0", "Body": "<p>C++11 standard states (3.2.3), that:</p>\n<blockquote>\n<p id=\"so_14372185_14374396_0\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). <strong>An inline function shall be defined in every translation unit in which it is odr-used.</strong></p>\n</blockquote>\n<p>C++ also knows about extern+inline, but understands it as \"An <strong>inline function with external linkage</strong> shall have the same address in all translation units\" (7.1.2)</p>\n<p>So extern+inline as you are using it is pure C99 feature, and there must be sufficient for you to make something like:</p>\n<pre><code>#ifdef __cplusplus\n#define C99_PROTOTYPE(x)\n#else\n#define C99_PROTOTYPE(x) x\n#endif\n</code></pre>\n<p>And refer in buffer.c:</p>\n<pre><code>// buffer.c\nC99_PROTOTYPE(extern inline bool has_remaining(void * obj);)\n</code></pre>\n<p>inline function in header for C++11 is ok and should work fine without C99-style prototypes.</p>\n", "LastActivityDate": "2013-01-17T07:50:09.477"}, "bq_ids": {"n4140": {"so_14372185_14374396_0": {"section_id": 7041, "quality": 0.8888888888888888, "length": 32}}, "n3337": {"so_14372185_14374396_0": {"section_id": 6786, "quality": 0.8888888888888888, "length": 32}}, "n4659": {"so_14372185_14374396_0": {"section_id": 8538, "quality": 0.8888888888888888, "length": 32}}}, "14504020": {"ParentId": "14372185", "CommentCount": "6", "CreationDate": "2013-01-24T14:46:43.593", "OwnerUserId": "1918193", "PostTypeId": "2", "Id": "14504020", "Score": "0", "Body": "<p>This was reported to gcc:\n<a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56066\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=56066</a>\nafter a discussion starting here:\n<a href=\"http://gcc.gnu.org/ml/gcc-help/2013-01/msg00152.html\" rel=\"nofollow\">http://gcc.gnu.org/ml/gcc-help/2013-01/msg00152.html</a></p>\n<p>On linux, gcc emits weak symbols for the inline functions, and a strong symbol for the extern inline one. At link time, the weak ones are discarded in favor of the strong one. Apparently, on windows, things are handled differently. I don't have any experience with windows, so I can't tell what happens there.</p>\n", "LastActivityDate": "2013-01-24T14:46:43.593"}});