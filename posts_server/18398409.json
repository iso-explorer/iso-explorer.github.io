post_cb({"18399065": {"Id": "18399065", "PostTypeId": "2", "Body": "<p>You've got just one virtual function <code>foo</code>:</p>\n<pre><code>class A {\n    virtual void foo() = 0;\n};\n\nclass B {\n    virtual void foo() = 0;\n};\n\nclass C : public A, public B {\n    virtual void foo();\n\n};\n\nvoid C::foo(){}\nvoid C::A::foo(){}\nvoid C::B::foo(){};\n\nint main() {\n    C c;\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "1312406", "LastActivityDate": "2013-08-23T10:16:45.700", "Score": "4", "CreationDate": "2013-08-23T09:12:10.990", "ParentId": "18398409", "CommentCount": "4", "OwnerUserId": "1312406", "LastEditDate": "2013-08-23T10:16:45.700"}, "bq_ids": {"n4140": {"so_18398409_18400950_0": {"length": 31, "quality": 1.0, "section_id": 7003}, "so_18398409_18400950_1": {"length": 12, "quality": 1.0, "section_id": 3208}}, "n3337": {"so_18398409_18400950_0": {"length": 31, "quality": 1.0, "section_id": 6749}, "so_18398409_18400950_1": {"length": 12, "quality": 1.0, "section_id": 3082}}, "n4659": {"so_18398409_18400950_0": {"length": 31, "quality": 1.0, "section_id": 8500}, "so_18398409_18400950_1": {"length": 12, "quality": 1.0, "section_id": 3965}}}, "18398409": {"ViewCount": "9407", "Body": "<p>I tried this code:</p>\n<pre><code>class A\n{\n    virtual void foo() = 0;\n};\n\nclass B\n{\n    virtual void foo() = 0;\n};\n\nclass C : public A, public B\n{\n    //virtual void A::foo(){}\n    //virtual void B::foo(){}\n\n    virtual void A::foo();\n    virtual void B::foo();\n};\n\nvoid C::A::foo(){}\nvoid C::B::foo(){}\n\nint main()\n{\n    C c;\n    return 0;\n}\n</code></pre>\n<p>It is OK when using the commented part, but when I try to write the definitions outside the class declaration, the compiler reports errors.\nI am using the MSVC11 compiler, does anyone know how to write this?\nI need to move the code into the cpp file.</p>\n<p>Thank you~~</p>\n", "Title": "C++ inherit from multiple base classes with the same virtual function name", "CreationDate": "2013-08-23T08:36:29.163", "LastActivityDate": "2016-11-14T10:57:03.563", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-08-23T09:49:47.550", "LastEditorUserId": "688659", "Id": "18398409", "Score": "7", "OwnerUserId": "2492786", "Tags": "<c++><function><class><virtual><multiple-inheritance>", "AnswerCount": "2"}, "18400950": {"Id": "18400950", "PostTypeId": "2", "Body": "<p>A function overrides a virtual function of a base class based on the name and parameter types (see below). Therefore, your class <code>C</code> has <em>two</em> virtual functions <code>foo</code>, one inherited from each <code>A</code> and <code>B</code>. But a function <code>void C::foo()</code> overrides <em>both</em>:</p>\n<p>[class.virtual]/2</p>\n<blockquote>\n<p id=\"so_18398409_18400950_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, <em>parameter-type-list</em>, cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it <em>overrides</em> <code>Base::vf</code>.</p>\n</blockquote>\n<p>As I already stated in the comments, [dcl.meaning]/1 forbids the use of a <em>qualified-id</em> in the declaration of a (member) function:</p>\n<blockquote>\n<p id=\"so_18398409_18400950_1\">When the <em>declarator-id</em> is qualified, the declaration shall refer to a previously declared member of the class or namespace to which the qualifier refers [...]\"</p>\n</blockquote>\n<p>Therefore any <code>virtual void X::foo();</code> is illegal as a declaration inside <code>C</code>.</p>\n<p>The code </p>\n<pre><code>class C : public A, public B\n{\n    virtual void foo();\n};\n</code></pre>\n<p>is the only way AFAIK to override <code>foo</code>, and it will override both <code>A::foo</code> and <code>B::foo</code>. There is no way to have two different overrides for <code>A::foo</code> and <code>B::foo</code> with different behaviour other than by introducing another layer of inheritance:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    virtual void foo() = 0;\n};\n\nstruct B\n{\n    virtual void foo() = 0;\n};\n\nstruct CA : A\n{\n    virtual void foo() { std::cout &lt;&lt; \"A\" &lt;&lt; std::endl; }\n};\n\nstruct CB : B\n{\n    virtual void foo() { std::cout &lt;&lt; \"B\" &lt;&lt; std::endl; }\n};\n\nstruct C : CA, CB {};\n\nint main() {\n    C c;\n    //c.foo();  // ambiguous\n\n    A&amp; a = c;\n    a.foo();\n\n    B&amp; b = c;\n    b.foo();\n}\n</code></pre>\n", "LastEditorUserId": "711006", "LastActivityDate": "2016-11-14T10:57:03.563", "Score": "13", "CreationDate": "2013-08-23T10:48:03.790", "ParentId": "18398409", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2016-11-14T10:57:03.563"}});