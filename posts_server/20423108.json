post_cb({"20423108": {"CommentCount": "6", "ViewCount": "191", "CreationDate": "2013-12-06T11:47:25.763", "LastActivityDate": "2013-12-10T10:24:49.070", "Title": "Clang Comparison Bug with negative values in strongly typed enum?", "PostTypeId": "1", "Id": "20423108", "Score": "2", "Body": "<p>I recently dealt with code using a strongly typed enum that contained negative values.\nWhen comparing the values of the enum, I got weird results when compiling the code with Clang (3.3) while Gcc works just fine.</p>\n<p>Here is a small example with an assert that fails.</p>\n<pre><code>enum class T: int { A = -1, B = 1 };\n\nint main() {\n    T a = T::A, b = T::B;\n    assert(a &lt; b);\n}\n</code></pre>\n<p>Is this an actual bug? Or does clang behave correctly and gcc just offers some kind of legacy support?</p>\n", "Tags": "<c++11><enums><clang>", "OwnerUserId": "2375725", "AnswerCount": "1"}, "20491870": {"ParentId": "20423108", "CommentCount": "0", "Body": "<p>It should be more intuitive that the following is <em>well-formed</em>:</p>\n<pre><code>T a = T::A;\nassert(a == T::A);\n</code></pre>\n<p>But the equality operators (<code>==</code>, <code>!=</code>) have the same restrictions as the relational operators (<code>&lt;</code>, <code>&lt;=</code>, ..) [expr.eq]/1:</p>\n<blockquote>\n<p id=\"so_20423108_20491870_0\">The <code>==</code> (equal to) and the <code>!=</code> (not equal to) operators have the same semantic restrictions, conversions, and result type as the relational operators except for their lower precedence and truth-value result.</p>\n</blockquote>\n<p>So if equality between values of a scoped enumeration type is well-defined, so should <code>&lt;</code> be.</p>\n<hr>\n<p>[expr.rel]/1</p>\n<blockquote>\n<p id=\"so_20423108_20491870_1\">The operands shall have arithmetic, enumeration, or pointer type, or type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>Of course, the usual arithmetic conversions are performed on operands of arithmetic or enumeration type [expr.rel]/2, where the conversion is the identity conversion for scoped enumerations (no integral promotion, see [expr]/10 first bullet). However, [expr.rel]/5 explicitly states:</p>\n<blockquote>\n<p id=\"so_20423108_20491870_2\">If both operands (<strong>after conversions</strong>) are of arithmetic or enumeration type, each of the operators shall yield\n  <code>true</code> if the specified relationship is true and <code>false</code> if it is false.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Therefore, <code>T::A &lt; T::B</code> should be well-formed <em>and</em> yield <code>true</code>.</p>\n<hr>\n<p>As I already wrote in a comment, the assertion doesn't fail on clang++3.4 trunk 193040. I therefore assume it's a bug that has been fixed, even though I couldn't find a corresponding bug report.</p>\n</hr></hr>", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "20491870", "Score": "0", "CreationDate": "2013-12-10T10:24:49.070", "LastActivityDate": "2013-12-10T10:24:49.070"}, "bq_ids": {"n4140": {"so_20423108_20491870_2": {"section_id": 6153, "quality": 1.0, "length": 16}, "so_20423108_20491870_1": {"section_id": 6154, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_20423108_20491870_2": {"section_id": 5916, "quality": 1.0, "length": 16}, "so_20423108_20491870_0": {"section_id": 5917, "quality": 0.9473684210526315, "length": 18}, "so_20423108_20491870_1": {"section_id": 5912, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_20423108_20491870_2": {"section_id": 7650, "quality": 1.0, "length": 16}, "so_20423108_20491870_1": {"section_id": 7651, "quality": 0.8888888888888888, "length": 8}}}});