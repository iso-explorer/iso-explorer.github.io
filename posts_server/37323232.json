post_cb({"37369101": {"ParentId": "37323232", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I agree with Nicol Bolas's answer that you <strong>can't</strong> access type through another type even if they are <em>layout-compatible</em>. I will just to add what <em>layout-compatible</em> means</p>\n<p>N3337 9.2/17</p>\n<blockquote>\n<p id=\"so_37323232_37369101_0\">Two standard-layout struct (Clause 9) types <strong>are layout-compatible</strong> if they have the <strong>same number of non-static\n  data members</strong> and corresponding <strong>non-static data members</strong> ( <strong>in declaration order</strong> ) <strong>have layout-compatible\n  types</strong> (3.9).</p>\n</blockquote>\n<hr>\n<p>Now to explain all terms here:</p>\n<p>(Note that <em>layout compatible <strong>types</strong></em></p></hr> and <em>layout-compatible <strong>standard-layout structs</strong></em> are 2 different things)\n<p><strong>1. Layout compatible type</strong></p>\n<p><em>layout-compatible type</em> means <em>same type</em>:</p>\n<p>N3337 3.9/11:</p>\n<blockquote>\n<p id=\"so_37323232_37369101_1\"><strong>If</strong> two types <strong>T1 and T2 are the same type</strong>, then <strong>T1 and T2 are <em>layout-compatible types</em></strong>.</p>\n</blockquote>\n<p><strong>2. Standard-Layout struct:</strong></p>\n<p>N3337 9/8</p>\n<blockquote>\n<p id=\"so_37323232_37369101_2\">A standard-layout struct is a <em>standard-layout class</em> defined with the <em>class-key</em> struct or the <em>class-key</em> class. </p>\n</blockquote>\n<p>(Or in other words (because C++ refers to structs,unions and classes as just <em>class</em>) it is <em>standard-layout class</em> that is not union)</p>\n<p><em>Standard-layout class</em> is:</p>\n<p>N3337 9/7</p>\n<blockquote>\n<p id=\"so_37323232_37369101_3\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with\n  non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.\n  108</li>\n</ul>\n<p id=\"so_37323232_37369101_4\">108) This ensures that two subobjects that have the same class type and that belong to the same most derived object are not\n  allocated at the same address (5.10)</p>\n</blockquote>\n", "OwnerUserId": "4932834", "LastEditorUserId": "4932834", "LastEditDate": "2016-05-22T14:47:36.220", "Id": "37369101", "Score": "0", "CreationDate": "2016-05-21T23:39:43.743", "LastActivityDate": "2016-05-22T14:47:36.220"}, "37368823": {"ParentId": "37323232", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Does [basic.lval] 10.6 allow aliasing between layout compatible types? No. The section in question states:</p>\n<blockquote>\n<p id=\"so_37323232_37368823_0\">an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union)</p>\n</blockquote>\n<p>Recall that \"the aforementioned types\" are the actual type <code>T</code>, the dynamic type of <code>T</code>, a type that is similar to the dynamic type, some const/volatile qualified version of the dynamic type, or a signed/unsigned version of the dynamic type.</p>\n<p>Now, consider this code:</p>\n<pre><code>struct T {int i;};\nstruct U {int i;};\n\nT t;\nU *pu = (U*)&amp;t;\npu-&gt;i = 5;\n</code></pre>\n<p>Now, let's look at 10.6 in that light. The question 10.6 asks is if the glvalue's type <code>U</code> contains a member that fits the qualifications of 10.1-10.5. Does it? Remember that the dynamic type of the object <code>t</code> is <code>T</code>.</p>\n<ul>\n<li>Does <code>U</code> contain a member of type <code>T</code>? No.</li>\n<li>Does <code>U</code> contain a member which is a const/volatile qualified version of <code>T</code>? No.</li>\n<li>Does <code>U</code> contain a member that is of a type which is similar to <code>T</code>? No.</li>\n<li>Does <code>U</code> contain a member that is a signed/unsigned version of <code>T</code>? No.</li>\n<li>Does <code>U</code>contain a member that is a const/volatile qualified version of a signed/unsigned version of <code>T</code>? No.</li>\n</ul>\n<p>Since all of those fail, the compiler is allowed to assume that modifying the object pointed to by <code>pu</code> will <em>not</em> modify the object <code>t</code>.</p>\n<hr>\n<p>FYI:</p>\n<blockquote>\n<p id=\"so_37323232_37368823_1\">Anyway, memcopy and pointer aliasing is exactly the same, except for global struct alignment.</p>\n</blockquote>\n<p>No, they aren't. The rules for trivial copy-ability and layout compatibility are not at all the same as the rules for aliasing.</p>\n<p>Trivial copyability is about the sanity of copying the value representation of an object and whether such a copy represents a legitimate object. The rules of layout compatibility are about whether the value representation of <code>A</code> is compatible with <code>B</code>, such that a value of <code>A</code> could be copied into an object of type <code>B</code>.</p>\n<p>Aliasing is about saying whether it is possible to access an object through a pointer/reference to <code>A</code> and a pointer/reference to <code>B</code> at the same time. The strict aliasing rule states that if the compiler sees a <code>A&amp; a</code> and a <code>B&amp; b</code>, the compiler is allowed to assume that modifications made through <code>a</code> <em>will not affect</em> the object referenced through <code>b</code>, and vice-versa. [basic.lval] 10 outlines the cases when the compiler is not allowed to assume this.</p>\n</hr>", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2016-05-22T00:21:00.723", "Id": "37368823", "Score": "5", "CreationDate": "2016-05-21T22:58:47.330", "LastActivityDate": "2016-05-22T00:21:00.723"}, "37408010": {"ParentId": "37323232", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is now clear (thanks to <a href=\"https://stackoverflow.com/a/37368823\">Nicol Bolas's answer</a>) that direct aliasing between two structs that are simply layout compatible would invoke UB because of the strict aliasing rule.</p>\n<p>Of course you can memcopy the content, but:</p>\n<ul>\n<li>it may be expensive depending of struct size</li>\n<li>you only get a copy (changes will not be reflected) unless you memcopy back when done</li>\n</ul>\n<p>But... you can create in C++ a struct of references that point to the original values. It will aliases directly members to their original type which is now perfectly defined by the standard.</p>\n<p>Code for foo could become:</p>\n<pre><code>void foo(void * arg)\n{\n    struct example // only used to declare the layout\n    {\n        int a;\n        const char * b;\n    };\n    struct r_example {\n    int &amp;a;\n    const char *&amp;b;\n    r_example(void *ext): a(*(static_cast&lt;int*&gt;(ext))),\n        b(*(reinterpret_cast&lt;const char **&gt;(\n            static_cast&lt;char*&gt;(ext) + offsetof(example, b)))) {}\n    };\n\n\n    r_example myarg(arg);\n    printf(\"in foo meaning of %s is %d\\n\",myarg.b,myarg.a);\n    myarg.a /= 2;\n}\n</code></pre>\n<p>And the change introduced in last line is visible without UB in caller:</p>\n<pre><code>void bar(void)\n{\n    struct example\n    {\n        int a;\n        const char * b;\n    };\n\n    example on_stack {42, \"life\"};\n    foo(&amp;on_stack);\n    printf(\"after foo meaning of %s is %d\\n\",on_stack.b,on_stack.a);\n}\n</code></pre>\n<p>Will display:</p>\n<pre><code>in foo meaning of life is 42\nafter foo meaning of life is 21\n</code></pre>\n<p>The C counterpart, will use pointers instead of refs:</p>\n<pre><code>    struct p_example {\n        int *a;\n        const char **b;\n    } my_arg;\n    my_arg.a = (int *) ext;\n    my_arg.b = (const char **)(((char*)ext) + offsetof(example, b));\n\n    printf(\"in foo meaning of %s is %d\\n\",*(myarg.b),*(myarg.a));\n    *(myarg.a) /= 2;\n</code></pre>\n", "OwnerUserId": "3545273", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:11.310", "Id": "37408010", "Score": "2", "CreationDate": "2016-05-24T08:19:56.710", "LastActivityDate": "2016-05-24T08:27:42.790"}, "bq_ids": {"n4140": {"so_37323232_37369101_0": {"section_id": 5876, "quality": 0.9545454545454546, "length": 21}, "so_37323232_37369101_4": {"section_id": 5851, "quality": 0.8333333333333334, "length": 15}, "so_37323232_37368823_0": {"section_id": 7239, "quality": 1.0, "length": 22}, "so_37323232_37369101_1": {"section_id": 7209, "quality": 0.8571428571428571, "length": 6}, "so_37323232_37369101_2": {"section_id": 5852, "quality": 1.0, "length": 9}}, "n3337": {"so_37323232_37369101_0": {"section_id": 5647, "quality": 1.0, "length": 22}, "so_37323232_37369101_4": {"section_id": 5621, "quality": 0.8333333333333334, "length": 15}, "so_37323232_37368823_0": {"section_id": 6983, "quality": 1.0, "length": 22}, "so_37323232_37369101_1": {"section_id": 6953, "quality": 1.0, "length": 7}, "so_37323232_37369101_2": {"section_id": 5622, "quality": 1.0, "length": 9}}, "n4659": {"so_37323232_37369101_4": {"section_id": 7330, "quality": 0.8333333333333334, "length": 15}, "so_37323232_37368823_0": {"section_id": 8748, "quality": 1.0, "length": 22}, "so_37323232_37369101_0": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}, "so_37323232_37369101_1": {"section_id": 6124, "quality": 0.7142857142857143, "length": 5}, "so_37323232_37369101_2": {"section_id": 7331, "quality": 0.8888888888888888, "length": 8}}}, "37323232": {"CommentCount": "19", "AcceptedAnswerId": "37408010", "PostTypeId": "1", "LastEditorUserId": "3726169", "CreationDate": "2016-05-19T12:27:55.157", "LastActivityDate": "2016-05-24T08:27:42.790", "LastEditDate": "2016-05-20T08:31:39.027", "ViewCount": "360", "FavoriteCount": "1", "Title": "Cast between structs from different scopes", "Id": "37323232", "Score": "12", "Body": "<p>I am interested in casting between pointers to structs that are potentially compatible. They'll use the same tag, the same members in the same order. Although the target codebase is compiled as either C or C++, for the sake of simplifying this question I would like to restrict this to C++ only.</p>\n<p>This is a situation where I am confident that the compiler will behave reasonably, but I cannot find supporting evidence that it is required to do so. </p>\n<p>The motivating code example is:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nvoid foo(void * arg)\n{\n    struct example\n    {\n        int a;\n        const char * b;\n    };\n\n    example * myarg = static_cast&lt;example *&gt;(arg);\n    printf(\"meaning of %s is %d\\n\",myarg-&gt;b,myarg-&gt;a);\n}\n\nvoid bar(void)\n{\n    struct example\n    {\n        int a;\n        const char * b;\n    };\n\n    example on_stack {42, \"life\"};\n    foo(&amp;on_stack);\n}\n\nint main(int,char**)\n{\n    bar();\n}\n</code></pre>\n<p>I have had less luck with the C++11 standard. Section 9 on classes suggests the examples will be \"layout-compatible\", which sounds encouraging, but I can't find a description of the consequences of structures being \"layout-compatible\". In particular, can I cast a pointer of one to a pointer of the other without consequences?</p>\n<p>A colleague believes \"layout-compatible\" means memcpy will work as expected. Given that the struct in question is also always trivially copyable, it is possible that the following nominally inefficient code would avoid UB:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\nvoid foo(void * arg)\n{\n    struct example\n    {\n        int a;\n        const char * b;\n    };\n\n    example local;\n    std::memcpy(&amp;local, arg, sizeof(example));\n    printf(\"meaning of %s is %d\\n\", local.b, local.a);\n}\n\n// bar and main as before\n</code></pre>\n<p>The actual motivation for this is to get the struct definition out of global scope when it's only used for communication between a small number of functions. I appreciate that it is debatable whether this is a good idea.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "3726169", "AnswerCount": "3"}});