post_cb({"506730": {"ParentId": "506518", "CommentCount": "3", "CreationDate": "2009-02-03T11:12:29.800", "OwnerUserId": "31762", "Id": "506730", "PostTypeId": "2", "OwnerDisplayName": "Lambert", "Score": "4", "Body": "<p><strong>I worked on a system where they used the alignment to free up the odd bit for there own use!</strong></p>\n<p>They used the odd bit to implement a virtual memory system.</p>\n<p>When a pointer had the odd bit set they used that to signify that it pointed (minus the odd \nbit) to the information to get the data from the database not the data itself.</p>\n<p>I thought this a particulary nasty bit of coding which was far to clever for its own good!!</p>\n<p>Tony</p>\n", "LastActivityDate": "2009-02-03T11:12:29.800"}, "506590": {"CommentCount": "8", "CreationDate": "2009-02-03T10:09:40.457", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-17T12:51:11.510", "ParentId": "506518", "PostTypeId": "2", "LastEditorDisplayName": "Richard Corden", "LastEditDate": "2017-05-23T11:54:29.097", "Id": "506590", "Score": "19", "Body": "<p>The alignment has the following guarantee from the standard (3.7.3.1/2):</p>\n<blockquote>\n<p id=\"so_506518_506590_0\">The pointer returned shall be suitably aligned so that it can be converted to a\n  pointer of any complete object type and then used to access the object or array in the \n  storage allocated (until\n  the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p><strong>EDIT</strong>:  Thanks to <a href=\"https://stackoverflow.com/users/24283/timday\">timday</a> for highlighting a <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=15795\" rel=\"nofollow noreferrer\">bug</a> in gcc/glibc where the guarantee does not hold.</p>\n<p><strong>EDIT 2</strong>:  Ben's comment highlights an intersting edge case.  The requirements on the allocation routines are for those provided by the standard only.  If the application has it's own version, then there's no such guarantee on the result.</p>\n", "OwnerUserId": "11698", "OwnerDisplayName": "Richard Corden"}, "506644": {"ParentId": "506518", "CommentCount": "0", "CreationDate": "2009-02-03T10:28:44.680", "OwnerUserId": "27048", "Id": "506644", "PostTypeId": "2", "OwnerDisplayName": "mfazekas", "Score": "4", "Body": "<p>The platform's new/new[] operator will return pointers with sufficient alignment so that it'll perform good with basic datatypes (double,float,etc.). At least any sensible C++ compiler+runtime should do that.</p>\n<p>If you have special alignment requirements like for SSE, then it's probably a good idea use special aligned_malloc functions, or roll your own.</p>\n", "LastActivityDate": "2009-02-03T10:28:44.680"}, "10627200": {"ParentId": "506518", "CommentCount": "0", "CreationDate": "2012-05-16T21:47:31.293", "OwnerUserId": "1059432", "PostTypeId": "2", "Id": "10627200", "Score": "9", "Body": "<p>This is a late answer but just to clarify the situation on Linux - on 64-bit systems\nmemory is always 16-byte aligned:</p>\n<p><a href=\"http://www.gnu.org/software/libc/manual/html_node/Aligned-Memory-Blocks.html\">http://www.gnu.org/software/libc/manual/html_node/Aligned-Memory-Blocks.html</a></p>\n<blockquote>\n<p id=\"so_506518_10627200_0\">The address of a block returned by malloc or realloc in the GNU system is always a \n   multiple of eight (or sixteen on 64-bit systems).</p>\n</blockquote>\n<p>The <code>new</code> operator calls <code>malloc</code> internally\n(see <code>./gcc/libstdc++-v3/libsupc++/new_op.cc</code>)\nso this applies to <code>new</code> as well.</p>\n<p>The implementation of <code>malloc</code> which is part of the <code>glibc</code> basically defines\n<code>MALLOC_ALIGNMENT</code> to be <code>2*sizeof(size_t)</code> and <code>size_t</code> is 32bit=4byte and 64bit=8byte\non a x86-32 and x86-64 system, respectively.</p>\n<pre><code>$ cat ./glibc-2.14/malloc/malloc.c:\n...\n#ifndef INTERNAL_SIZE_T\n#define INTERNAL_SIZE_T size_t\n#endif\n...\n#define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))\n...\n#ifndef MALLOC_ALIGNMENT\n#define MALLOC_ALIGNMENT       (2 * SIZE_SZ)\n#endif\n</code></pre>\n", "LastActivityDate": "2012-05-16T21:47:31.293"}, "506866": {"ParentId": "506518", "CommentCount": "1", "CreationDate": "2009-02-03T12:11:37.187", "OwnerUserId": "17604", "Id": "506866", "PostTypeId": "2", "OwnerDisplayName": "jheriko", "Score": "7", "Body": "<p>Incidentally the <a href=\"http://msdn.microsoft.com/en-us/library/ycsb6wwf.aspx\" rel=\"noreferrer\">MS documentation</a> mentions something about malloc/new returning addresses which are 16-byte aligned, but from experimentation this is not the case. I happened to need the 16-byte alignment for a project (to speed up memory copies with enhanced instruction set), in the end I resorted to writing my own allocator...</p>\n", "LastActivityDate": "2009-02-03T12:11:37.187"}, "bq_ids": {"n4140": {"so_506518_506590_0": {"section_id": 7177, "quality": 0.96, "length": 24}}, "n3337": {"so_506518_506590_0": {"section_id": 6921, "quality": 0.96, "length": 24}}, "n4659": {"so_506518_506590_0": {"section_id": 8685, "quality": 0.96, "length": 24}}}, "506518": {"CommentCount": "0", "CreationDate": "2009-02-03T09:44:04.287", "PostTypeId": "1", "AcceptedAnswerId": "506590", "LastEditorUserId": "4370109", "LastActivityDate": "2015-11-01T17:57:55.293", "AnswerCount": "5", "LastEditDate": "2015-11-01T17:57:55.293", "ViewCount": "11720", "FavoriteCount": "5", "Title": "Is there any guarantee of alignment of address return by C++'s new operation?", "Id": "506518", "Score": "21", "Body": "<p>Most of experienced programmer knows data alignment is important for program's performance. I have seen some programmer wrote program that allocate bigger size of buffer than they need, and use the aligned pointer as begin. I am wondering should I do that in my program, I have no idea is there any guarantee of alignment of address returned by C++'s new operation. So I wrote a little program to test</p>\n<pre><code>for(size_t i = 0; i &lt; 100; ++i) {\n    char *p = new char[123];\n    if(reinterpret_cast&lt;size_t&gt;(p) % 4) {\n        cout &lt;&lt; \"*\";\n        system(\"pause\");\n    }\n    cout &lt;&lt; reinterpret_cast&lt;void *&gt;(p) &lt;&lt; endl;\n}\nfor(size_t i = 0; i &lt; 100; ++i) {\n    short *p = new short[123];\n    if(reinterpret_cast&lt;size_t&gt;(p) % 4) {\n        cout &lt;&lt; \"*\";\n        system(\"pause\");\n    }\n    cout &lt;&lt; reinterpret_cast&lt;void *&gt;(p) &lt;&lt; endl;\n}\nfor(size_t i = 0; i &lt; 100; ++i) {\n    float *p = new float[123];\n    if(reinterpret_cast&lt;size_t&gt;(p) % 4) {\n        cout &lt;&lt; \"*\";\n        system(\"pause\");\n    }\n    cout &lt;&lt; reinterpret_cast&lt;void *&gt;(p) &lt;&lt; endl;\n}\nsystem(\"pause\");\n</code></pre>\n<p>The compiler I am using is Visual C++ Express 2008. It seems that all addresses the new operation returned are aligned. But I am not sure. So my question is: are there any guarantee? If they do have guarantee, I don't have to align myself, if not, I have to.</p>\n", "Tags": "<c++><performance><alignment><new-operator>", "OwnerUserId": "25077", "OwnerDisplayName": "Victor Lin"}});