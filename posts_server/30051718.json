post_cb({"30051718": {"CommentCount": "4", "AcceptedAnswerId": "30051793", "CreationDate": "2015-05-05T11:26:51.000", "LastActivityDate": "2015-05-05T12:01:01.433", "PostTypeId": "1", "ViewCount": "733", "FavoriteCount": "2", "Title": "C++14 warning: too many template headers for variable (should be 0)", "Id": "30051718", "Score": "18", "Body": "<p>While experimenting with the recent g++-5 compiler, I wrote below statement in a file:</p>\n<pre><code>template&lt;T&gt; T a;\ntemplate&lt;&gt; int a = 1;\n</code></pre>\n<p>Which results in:</p>\n<blockquote>\n<p id=\"so_30051718_30051718_0\">warning: too many template headers for <code>a</code> (should be 0)</p>\n</blockquote>\n<p>Also effectively, it doesn't really specialize <code>a&lt;int&gt;</code>. e.g.</p>\n<pre><code>template&lt;typename T&gt; T a;\ntemplate&lt;&gt; int a = 1;\n\nint main ()  {\n  std::cout &lt;&lt; a&lt;double&gt; &lt;&lt; \"\\n\";  // prints 0; OK\n  std::cout &lt;&lt; a&lt;int&gt; &lt;&lt; \"\\n\";  // prints 0! why not 1?\n}\n</code></pre>\n<p>What is the mystery about this syntax?</p>\n", "Tags": "<c++><language-lawyer><c++14><template-specialization><variable-templates>", "OwnerUserId": "514235", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30051718_30051793_0": {"section_id": 272, "quality": 1.0, "length": 17}}, "n3337": {"so_30051718_30051793_0": {"section_id": 263, "quality": 1.0, "length": 17}}, "n4659": {"so_30051718_30051793_0": {"section_id": 279, "quality": 1.0, "length": 17}}}, "30051793": {"ParentId": "30051718", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-05-05T11:30:35.437", "Score": "22", "LastEditorUserId": "1782465", "LastEditDate": "2015-05-05T12:01:01.433", "Id": "30051793", "OwnerUserId": "1782465", "Body": "<p>Template arguments can only be omitted in explicit specialisation of <em>function</em> templates. You have a variable template, so you have to include the <code>&lt;int&gt;</code>:</p>\n<pre><code>template&lt;&gt; int a&lt;int&gt; = 1;\n</code></pre>\n<p>Quoting C++14 (n4140), 14.7.3/10 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_30051718_30051793_0\">A trailing <em>template-argument</em> can be left unspecified in the <em>template-id</em> naming an explicit <strong>function template\n  specialization</strong> provided it can be deduced from the function argument type.</p>\n</blockquote>\n<p>If you do not want to repeat the type, you can use <code>auto</code>:</p>\n<pre><code>template&lt;&gt; auto a&lt;int&gt; = 1;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e35abf13b4a80ff7\">[Live example]</a> using Clang.</p>\n<p>There's one thing to bear in mind with this: when using <code>auto</code>, the type of the specialised variable will be deduced from the initialiser, not from the template argument. And since a specialisation can have a different type than the primary template, the compiler will happily accept it even if they differ.</p>\n", "LastActivityDate": "2015-05-05T12:01:01.433"}});