post_cb({"bq_ids": {"n4140": {"so_9546914_9547181_0": {"length": 14, "quality": 1.0, "section_id": 5916}}, "n3337": {"so_9546914_9547181_0": {"length": 14, "quality": 1.0, "section_id": 5688}}, "n4659": {"so_9546914_9547181_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7409}}}, "9547115": {"Id": "9547115", "PostTypeId": "2", "Body": "<pre><code>any.queen = Piece::Queen();\n</code></pre>\n<p>This does not mean what you think it does. This is equivalent to</p>\n<pre><code>any.queen.operator=(Piece::Queen());\n</code></pre>\n<p>which cannot reliably work if <code>any.queen</code> does not exist (because you haven't forced your <code>union</code> to contain an active member).</p>\n<p>You need to actually initialise the member you want to use, for example like this:</p>\n<pre><code>new (&amp;any.queen) Piece::Queen;\n</code></pre>\n", "LastActivityDate": "2012-03-03T15:05:14.007", "CommentCount": "0", "CreationDate": "2012-03-03T15:05:14.007", "ParentId": "9546914", "Score": "3", "OwnerUserId": "743382"}, "9546914": {"ViewCount": "380", "Body": "<p>I came across a strange phenomena upon running the following code:</p>\n<pre><code>#include &lt;iostream&gt;    \n\nclass Piece {\npublic:\n    class Queen;\n    class Knight;\n    union Any;\n    virtual const char* name() const = 0;\n};\n\nclass Piece::Queen : public Piece {\npublic:\n    virtual const char* name() const {\n        return \"Queen\";\n    }\n};\n\nclass Piece::Knight : public Piece {\npublic:\n    virtual const char* name() const {\n        return \"Knight\";\n    }\n};\n\nunion Piece::Any {\npublic:\n    Any() {}\n    Piece::Queen queen;\n    Piece::Knight knight;\n};\n\nusing namespace std;\nint main(int argc, const char* argv[]) {\n    Piece::Any any;\n    any.queen = Piece::Queen();\n    cout &lt;&lt; any.queen.name() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>The program compiled successfully on the Apple LLVM 3.0 compiler, but the output was \"Knight\".\nI was expecting for the output to be \"Queen\".\nFrom my testing I saw that when Piece::Any's default constructor runs, it calls both Piece::Queen and Piece::Knights' constructors, one after another. If I were to declare Piece::Any like this:</p>\n<pre><code>union Piece::Any {\npublic:\n    Any() {}\n    Piece::Knight knight;\n    Piece::Queen queen;\n};\n</code></pre>\n<p>(I basically swapped the order of knight and queen) then the output would be Queen.\nAny help would be appreciated.</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "9547181", "Title": "C++: Union containing class instances calls wrong virtual function", "CreationDate": "2012-03-03T14:35:14.050", "Id": "9546914", "CommentCount": "0", "LastEditDate": "2012-08-27T14:10:45.293", "PostTypeId": "1", "LastEditorUserId": "718379", "LastActivityDate": "2012-08-27T14:10:45.293", "Score": "4", "OwnerUserId": "1246924", "Tags": "<c++><class><virtual><call><unions>", "AnswerCount": "2"}, "9547181": {"Id": "9547181", "PostTypeId": "2", "Body": "<p>First of all - your constructor seems to initialize none of its members. You should choose one, for example</p>\n<pre><code>Piece::Any::Any(): knight() {}\n</code></pre>\n<p>Then according to 9.5.4 </p>\n<blockquote>\n<p id=\"so_9546914_9547181_0\">In general, one must use explicit destructor calls and placement new operators to change the active member of a union</p>\n</blockquote>\n<p>so correct switching from knight to queen is</p>\n<pre><code>any.knight.~Knight();\nnew(&amp;any.queen) Queen;\n</code></pre>\n<p>If it looks ugly to you (as it does to me), it is clear indication, that keeping objects with non-trivial constructors in union is not a good idea (how about boost::variant?).</p>\n", "LastEditorUserId": "113662", "LastActivityDate": "2012-03-03T15:24:39.147", "Score": "4", "CreationDate": "2012-03-03T15:14:09.407", "ParentId": "9546914", "CommentCount": "1", "OwnerUserId": "113662", "LastEditDate": "2012-03-03T15:24:39.147"}});