post_cb({"bq_ids": {"n4140": {"so_21499120_21509729_1": {"length": 14, "quality": 0.875, "section_id": 5879}, "so_21499120_21499120_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5876}}, "n3337": {"so_21499120_21509729_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5650}, "so_21499120_21509729_1": {"length": 14, "quality": 0.875, "section_id": 5650}, "so_21499120_21499120_0": {"length": 22, "quality": 1.0, "section_id": 5647}}, "n4659": {"so_21499120_21509729_1": {"length": 14, "quality": 0.875, "section_id": 7363}, "so_21499120_21499120_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 7361}}}, "21509451": {"Id": "21509451", "PostTypeId": "2", "Body": "<p>I am used to Borland environments and for them:</p>\n<p>T is a struct in your case so sizeof(T) is size of struct</p>\n<ul>\n<li>that depends on <strong>#pragma pack</strong> and <strong>align</strong> setting of your compiler</li>\n<li>so sometimes it can be greater than sizeof(unsigned) !!!</li>\n</ul>\n<p>for the same reason if you have 4Byte struct (uint32) and 16Byte allign</p>\n<ul>\n<li>struct T { uint32 u; };</li>\n<li>then T a[100] is not the same as uint32 a[100];</li>\n<li>because T is uint32 + 12 Byte empty space !!!</li>\n</ul>\n", "LastEditorUserId": "2521214", "LastActivityDate": "2014-02-02T10:30:22.343", "Score": "3", "CreationDate": "2014-02-02T10:25:11.367", "ParentId": "21499120", "CommentCount": "0", "OwnerUserId": "2521214", "LastEditDate": "2014-02-02T10:30:22.343"}, "21515546": {"Id": "21515546", "PostTypeId": "2", "Body": "<p>RETRACTION: The argument is erroneous. The proof of Lemma 2 relies on a hidden premise that the alignment of an aggregate type is determined strictly by the alignments of its member types. As <a href=\"https://stackoverflow.com/questions/21499120/is-sizeoft-sizeofint/21515546?noredirect=1#comment32484754_21515546\">Dyp points out in the commentary</a>, that premise is not supported by the standard. It is therefore admissible for <code>struct { Foo f }</code> to have a more strict alignment requirement that <code>Foo</code>.</p>\n<p><hr>\nI'll play devil's advocate here, since no one else seems to be willing. I will argue that standard C++ (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">I'll refer to N3797 herein</a>) guarantees that <code>sizeof(T) == sizeof(U)</code> when <code>T</code> is a standard layout class (9/7) with default alignment having a single default-aligned non-static data member <code>U</code>, e.g,</hr></p>\n<pre><code>struct T { // or class, or union\n  U u;\n};\n</code></pre>\n<p>It's well-established that:</p>\n<ul>\n<li><code>sizeof(T) &gt;= sizeof(U)</code></li>\n<li><code>offsetof(T, u) == 0</code> (9.2/19)</li>\n<li><code>U</code> must be a standard layout type for <code>T</code> to be a standard layout class</li>\n<li><code>u</code> has a representation consisting of exactly <code>sizeof(U)</code> contiguous bytes of memory (1.8/5)</li>\n</ul>\n<p>Together these facts imply that the first <code>sizeof(U)</code> bytes of the representation of <code>T</code> are occupied by the representation of <code>u</code>. If <code>sizeof(T) &gt; sizeof(U)</code>, the excess bytes must then be <em>tail padding</em>: unused padding bytes inserted after the representation of <code>u</code> in <code>T</code>.</p>\n<p>The argument is, in short:</p>\n<ul>\n<li>The standard details the circumstances in which an implementation may add padding to a standard-layout class,</li>\n<li>None of those cirumstances applies in this particular instance, and hence</li>\n<li>A conforming implementation may not add padding.</li>\n</ul>\n<hr>\n<h3>Potential Sources of Padding</h3>\n<p>Under what circumstances does the standard allow an implementation to add such padding to the representation of a standard layout class? When it's necessary for alignment: per 3.11/1, \"An <em>alignment</em> is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated.\" There are two mentions of adding padding, both for alignment reasons:</p>\n<ul>\n<li><p>5.3.3 Sizeof [expr.sizeof]/2 states \"When applied to a reference or a reference type, the result is the size of the referenced type. When applied\nto a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array. The size of a most derived class shall be greater than zero (1.8). The result of applying <code>sizeof</code> to a base class subobject is the size of the base class type.<sup>77</sup> When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of <em>n</em> elements is <em>n</em> times the size of an element.\"</p></li>\n<li><p>9.2 Class members [class.mem]/13 states \"Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).\"</p></li>\n<li><p>(Notably the C++ standard does <em>not</em> contain a blanket statement allowing implementations to insert padding in structures as in the C standards, e.g., N1570 (C11-ish) \u00a76.7.2.1/15 \"There may be unnamed padding within a structure object, but not at its beginning.\" and /17 \"There may be unnamed padding at the end of a structure or union.\")</p></li>\n</ul>\n<p>Clearly the text of 9.2 doesn't apply to our problem, since (a) <code>T</code> has only one member and thus no \"adjacent members\", and (b) <code>T</code> is standard layout and hence has no virtual functions or virtual base classes (per 9/7). Demonstrating that 5.3.3/2 doesn't allow padding in our problem is more challenging.</p>\n<hr>\n<h3>Some Prerequisites</h3>\n<p><em>Lemma 1:</em> <strong>For any type <code>W</code> with default alignment, <code>alignof(W)</code> divides <code>sizeof(W)</code>:</strong> By 5.3.3/2, the size of an array of <em>n</em> elements of type <code>W</code> is exactly <em>n</em> times <code>sizeof(W)</code> (i.e., there is no \"external\" padding between array elements). The addresses of consecutive array elements are then <code>sizeof(W)</code> bytes apart. By the definition of alignment, it must then be that <code>alignof(W)</code> divides <code>sizeof(W)</code>.</p>\n<p><em>Lemma 2:</em> <strong>The alignment <code>alignof(W)</code> of a default-aligned standard layout class <code>W</code> with only default-aligned data members is the least common multiple <code>LCM(W)</code> of the alignments of the data members (or 1 if there are none):</strong> Given an address at which an object of <code>W</code> can be allocated, the address <code>LCM(W)</code> bytes away must also be appropriately aligned: the difference between the addresses of member subobjects would also be <code>LCM(W)</code> bytes, and the alignment of each such member subobject divides <code>LCM(W)</code>. Per the definition of alignment in 3.11/1, we have that <code>alignof(W)</code> divides <code>LCM(W)</code>. Any whole number of bytes <code>n &lt; LCM(W)</code> must not be divisible by the alignment of some member <code>v</code> of <code>W</code>, so an address that is only <code>n</code> bytes away from an address at which an object of <code>W</code> can be allocated is consequently <em>not</em> appropriately aligned for an object of <code>W</code>, i.e., <code>alignof(W) &gt;= LCM(W)</code>. Given that <code>alignof(W)</code> divides <code>LCM(W)</code> and <code>alignof(W) &gt;= LCM(W)</code>, we have <code>alignof(W) == LCM(W)</code>.</p>\n<hr>\n<h3>Conclusion</h3>\n<p>Application of this lemma to the original problem has the immediate consequence that <code>alignof(T) == alignof(U)</code>. So how much padding might be \"required for placing objects of that type in an array\"? <em>None</em>. Since <code>alignof(T) == alignof(U)</code> by the second lemma, and <code>alignof(U)</code> divides <code>sizeof(U)</code> by the first, it must be that <code>alignof(T)</code> divides <code>sizeof(U)</code> so zero bytes of padding are required to place objects of type <code>T</code> in an array.</p>\n<p>Since all possible sources of padding bytes have been eliminated, an implementation may not add padding to <code>T</code> and we have <code>sizeof(T) == sizeof(U)</code> as required.</p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-02T21:22:21.647", "Score": "3", "CreationDate": "2014-02-02T20:05:19.073", "ParentId": "21499120", "CommentCount": "6", "OwnerUserId": "923854", "LastEditDate": "2017-05-23T12:21:01.307"}, "21499120": {"ViewCount": "486", "Body": "<p>I've been poring over the draft standard and can't seem to find what I'm looking for.</p>\n<p>If I have a standard-layout type</p>\n<pre><code>struct T {\n   unsigned handle;\n};\n</code></pre>\n<p>Then I know that <code>reinterpret_cast&lt;unsigned*&gt;(&amp;t) == &amp;t.handle</code> for some <code>T t;</code> </p>\n<p>The goal is to create some <code>vector&lt;T&gt; v</code> and pass <code>&amp;v[0]</code> to a C function that expects a pointer to an array of unsigned integers.</p>\n<p>So, does the standard define <code>sizeof(T) == sizeof(unsigned)</code> and does that imply that an array of <code>T</code> would have the same layout as an array of <code>unsigned</code>?</p>\n<p>While <a href=\"https://stackoverflow.com/questions/3585033/size-of-struct-with-a-single-element\">this question</a> addresses a very similar topic, I'm asking about the specific case where both the data member and the class are standard layout, and the data member is a fundamental type.</p>\n<p>I've read some paragraphs that seem to hint that <em>maybe</em> it might be true, but nothing that hits the nail on the head. For example:</p>\n<p>\u00a7 9.2.17</p>\n<blockquote>\n<p id=\"so_21499120_21499120_0\">Two standard-layout struct (Clause 9) types are layout-compatible if\n  they have the same number of non-static data members and corresponding\n  non-static data members (in declaration order) have layout-compatible\n  types</p>\n</blockquote>\n<p>This isn't quite what I'm looking for, I don't think.</p>\n", "AcceptedAnswerId": "21509729", "Title": "Is sizeof(T) == sizeof(int)?", "CreationDate": "2014-02-01T14:16:59.607", "Id": "21499120", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:28:38.103", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-02T21:22:21.647", "Score": "11", "OwnerUserId": "184741", "Tags": "<c++><arrays><sizeof>", "AnswerCount": "3"}, "21509729": {"Id": "21509729", "PostTypeId": "2", "Body": "<p>You essentially are asking, given:</p>\n<pre><code>struct T {\n    U handle;\n};\n</code></pre>\n<p>whether it's guaranteed that <code>sizeof(T) == sizeof(U)</code>.  No, it is not.</p>\n<p>Section 9.2/17 of the ISO C++03 standard says:</p>\n<blockquote>\n<p id=\"so_21499120_21509729_0\">A pointer to a POD-struct object, suitably converted using a\n  <code>reinterpret_cast</code>, points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>Suppose you have an array of <code>struct T</code>.  The vice versa part means that the address of any of the <code>T::handle</code> members must also be a valid address of a <code>struct T</code>.  Now, suppose that these members are of type <code>char</code> and that your claim is true.  This would mean that <code>struct T</code> would be allowed to have an unaligned address, which seems rather unlikely.  The standard usually tries to not tie the hands of implementations in such a way.  For your claim to be true, the standard would have to require that <code>struct T</code> be allowed to have unaligned addresses.  And it would have to be allowed for all structures, because <code>struct T</code> could be a forward-declared, opaque type.</p>\n<p>Furthermore, section 9.2/17 goes on to state:</p>\n<blockquote>\n<p id=\"so_21499120_21509729_1\">[Note: There might therefore be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment.]</p>\n</blockquote>\n<p>Which, taken a different way, means that there is no guarantee that there will never be padding.</p>\n", "LastEditorUserId": "179715", "LastActivityDate": "2014-02-02T11:34:05.600", "Score": "4", "CreationDate": "2014-02-02T10:57:27.653", "ParentId": "21499120", "CommentCount": "2", "OwnerUserId": "179715", "LastEditDate": "2014-02-02T11:34:05.600"}});