post_cb({"bq_ids": {"n4140": {"so_44759353_44760075_2": {"length": 7, "quality": 0.875, "section_id": 4321}, "so_44759353_44760075_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 1341}, "so_44759353_44760075_0": {"length": 23, "quality": 0.92, "section_id": 6365}}, "n3337": {"so_44759353_44760075_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 1335}, "so_44759353_44760075_2": {"length": 6, "quality": 0.75, "section_id": 4162}, "so_44759353_44760075_0": {"length": 23, "quality": 0.92, "section_id": 6122}}, "n4659": {"so_44759353_44760075_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 1471}, "so_44759353_44760075_2": {"length": 7, "quality": 0.875, "section_id": 5578}, "so_44759353_44760075_0": {"length": 23, "quality": 0.92, "section_id": 7876}}}, "44760075": {"Id": "44760075", "PostTypeId": "2", "Body": "<p>The actual wording in the Standard is found in section [lib.types.movedfrom]:</p>\n<blockquote>\n<p id=\"so_44759353_44760075_0\">Objects of types defined in the C++ standard library may be moved from ([class.copy]).  Move operations may be explicitly specified or implicitly generated.  Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>The description of <code>std::move</code> ([alg.move]) simply says that elements are moved and makes no comment about the moved-from objects. The description of <code>std::remove</code> ([alg.remove]) has a non-normative note:</p>\n<blockquote>\n<p id=\"so_44759353_44760075_1\"><em>Note:</em> each element in the range <code>[ret,last)</code>, where <code>ret</code> is the returned value, has a valid but unspecified state, because the algorithms can eliminate elements by moving from elements that were originally in that range.</p>\n</blockquote>\n<p>So cppreference happens to use different phrasing on those two pages, but they mean exactly the same thing.</p>\n<p>Now, given that <code>std::string s1</code> has been moved from, is it valid to do</p>\n<pre><code>std::cout &lt;&lt; s1;\n</code></pre>\n<p>Yes, it's allowed because <code>s1</code> is \"valid\", but it's not useful, since you have no guarantees on what will be output.  On the other hand,</p>\n<pre><code>s1 = \"cde\";\n</code></pre>\n<p>is both safe and useful, since any previous contents of <code>s1</code> are discarded.</p>\n<p>For an example of \"unless otherwise specified\", take a look at the move assignment operator of <code>std::unique_ptr&lt;T&gt;</code> ([unique.ptr.single.asgn]):</p>\n<pre><code>unique_ptr&amp; operator=(unique_ptr&amp;&amp; u) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_44759353_44760075_2\"><em>Effects:</em> Transfers ownership from <code>u</code> to <code>*this</code> as if by calling <code>reset(u.release())</code> followed by <code>get_deleter() = std::forward&lt;D&gt;(u.get_deleter())</code>.</p>\n</blockquote>\n<p>Since <code>u.release()</code> leaves <code>u</code> empty/null, we're actually guaranteed the moved-from object will be empty/null.  Similar guarantees are made for the move constructor and the templated constructor and assignment taking a <code>unique_ptr</code> with different template argument, so that a moved-from <code>unique_ptr</code> is always empty/null.</p>\n", "LastActivityDate": "2017-06-26T12:44:50.210", "Score": "1", "CreationDate": "2017-06-26T12:44:50.210", "ParentId": "44759353", "CommentCount": "0", "OwnerUserId": "459640"}, "44759353": {"ViewCount": "95", "Body": "<p>Looking at std::remove reference I see:</p>\n<pre><code>template&lt; class ForwardIt, class T &gt;\nForwardIt remove( ForwardIt first, ForwardIt last, const T&amp; value );\n</code></pre>\n<p>Removing is done by shifting (by means of move assignment) the elements in the range. Iterators pointing to an element between the new logical end and the physical end of the range are still dereferenceable, <strong>but the elements themselves have unspecified values</strong> (as per MoveAssignable post-condition).</p>\n<p>So, I see MoveAssignable conept:</p>\n<pre><code>t = rv   // Post-condition:The new value of rv is unspecified.\n</code></pre>\n<p>So far, it is OK. Question about MoveAssignable concept:</p>\n<pre><code>std::string s1 = \"abc\";\nstd::string s2;\ns2 = std::move(s1);\nstd::cout &lt;&lt; s1;    // is this code valid?\ns1 = \"cde\";         // is this code valid?\n</code></pre>\n<p>Can I reuse \"moved from\" variable by reading its value or by re-assigning its value?</p>\n<p>Now I am looking at std::move reference and it looks a bit surprising:</p>\n<pre><code>template&lt; class InputIt, class OutputIt &gt;\nOutputIt move( InputIt first, InputIt last, OutputIt d_first );\n</code></pre>\n<p>Moves the elements in the range [first, last), to another range beginning at d_first. <strong>After this operation the elements in the moved-from range will still contain valid values of the appropriate type</strong>, but not necessarily the same values as before the move.</p>\n<p>So, moved-from elements are defined by different way in std::remove and std::move, though they should be the same. Which one is correct? What are the rules of reusing (or not using) of moved-from elements?</p>\n", "AcceptedAnswerId": "44760075", "Title": "std::remove, std::move(range) and moved-from elements", "CreationDate": "2017-06-26T12:06:55.680", "Id": "44759353", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-06-26T12:44:50.210", "Score": "2", "OwnerUserId": "279313", "Tags": "<c++><c++11><move><stl-algorithm>", "AnswerCount": "1"}});