post_cb({"19590429": {"ParentId": "19590008", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, that type is still POD. The definition is given by C++11 9/10:</p>\n<blockquote>\n<p id=\"so_19590008_19590429_0\">A POD struct is a non-union class that is both a trivial class and a standard-layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types).</p>\n</blockquote>\n<p><em>Trivial</em> means that it doesn't do any funny business when creating, destroying or copying objects. <em>Standard-layout</em> means that it doesn't do any funny business with the layout of data members: no polymorphism, and restrictions on what you can do with access specifiers and inheritance. These terms are fully defined in C++11 9/6 and 9/7, if you want more detail.</p>\n<p>Nested types (such as your enumeration), static data members and non-virtual member functions (apart from constructors etc. which would make it non-trivial) will not effect any of those things, so it is still POD.</p>\n<p><strong>UPDATE:</strong> Since you say you're interested in historic definitions, C++03 defined:</p>\n<blockquote>\n<p id=\"so_19590008_19590429_1\">9/4 A POD-struct is an aggregate class that has no non-static members of type non-POD-struct, non-POD-union (or array of such types), and has no user-defined copy assignment operator and no user-defined destructor\"</p>\n<p id=\"so_19590008_19590429_2\">8.5.1/1 An aggregate is an array or class with no user-declared constructors, no private or protected non-static data members, no base classes and no virtual functions.</p>\n</blockquote>\n<p>So there were more restrictions; but nested types were still allowed. I don't have a copy of C++98, but I'm sure that would be identical to C++03.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-10-25T13:04:25.133", "Id": "19590429", "Score": "3", "CreationDate": "2013-10-25T12:52:11.240", "LastActivityDate": "2013-10-25T13:04:25.133"}, "19590008": {"CommentCount": "0", "ViewCount": "599", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-10-25T12:33:56.723", "LastActivityDate": "2015-06-07T01:27:28.080", "Title": "Does a nested enum inside POD class makes it not POD?", "AcceptedAnswerId": "19590429", "LastEditDate": "2017-05-23T12:14:28.500", "Id": "19590008", "Score": "2", "Body": "<p>By definition <a href=\"https://stackoverflow.com/questions/146452/what-are-pod-types-in-c\" title=\"here\">here</a>, <em>POD</em> is a simple class with no user-defined constructors, non static members, and containing simple data types only.</p>\n<p>The question is, will these 2 classes below be equivalent as <em>POD</em> types (in terms of memory footprint):</p>\n<pre><code>class pod\n{\npublic:\n   int x;\n   double y;\n};\n\nclass pod1\n{\npublic:\n   int x;\n   double y;\n\n   enum POD_TYPE\n   {\n      POD1 = 0,\n      POD = 1\n   };\n};\n</code></pre>\n<p>In other words does adding <em>enum</em> to the class only affects scope resolution of <em>enum</em> and does not affect properties of the class itself? By observation, it seems that class is still pod, but I would like to confirm based on the standard.</p>\n", "Tags": "<c++><enums><nested>", "OwnerUserId": "1935008", "AnswerCount": "3"}, "19590261": {"ParentId": "19590008", "CommentCount": "1", "Body": "<p>It doesn't make any difference regarding POD status because defining a nested <code>enum</code> does not add data members to the class. In fact, you could also define a nested class that is <em>not</em> POD inside <code>pod1</code> and it would still not make a difference regarding the PODness of <code>pod1</code>.</p>\n", "OwnerUserId": "50079", "PostTypeId": "2", "Id": "19590261", "Score": "2", "CreationDate": "2013-10-25T12:45:34.263", "LastActivityDate": "2013-10-25T12:45:34.263"}, "bq_ids": {"n4140": {"so_19590008_19591110_0": {"section_id": 5861, "quality": 1.0, "length": 20}, "so_19590008_19590429_1": {"section_id": 467, "quality": 0.5294117647058824, "length": 9}, "so_19590008_19591110_2": {"section_id": 5854, "quality": 0.9166666666666666, "length": 44}, "so_19590008_19590429_2": {"section_id": 3298, "quality": 0.8, "length": 12}, "so_19590008_19591110_1": {"section_id": 5876, "quality": 0.9545454545454546, "length": 21}, "so_19590008_19590429_0": {"section_id": 5854, "quality": 0.95, "length": 19}}, "n3337": {"so_19590008_19591110_0": {"section_id": 5631, "quality": 1.0, "length": 20}, "so_19590008_19590429_1": {"section_id": 458, "quality": 0.5294117647058824, "length": 9}, "so_19590008_19591110_2": {"section_id": 5624, "quality": 0.9375, "length": 45}, "so_19590008_19590429_2": {"section_id": 3168, "quality": 0.8, "length": 12}, "so_19590008_19591110_1": {"section_id": 5647, "quality": 1.0, "length": 22}, "so_19590008_19590429_0": {"section_id": 5624, "quality": 0.95, "length": 19}}, "n4659": {"so_19590008_19590429_1": {"section_id": 490, "quality": 0.5294117647058824, "length": 9}, "so_19590008_19591110_2": {"section_id": 7333, "quality": 0.9166666666666666, "length": 44}, "so_19590008_19590429_2": {"section_id": 4063, "quality": 0.6, "length": 9}, "so_19590008_19591110_1": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}, "so_19590008_19590429_0": {"section_id": 7333, "quality": 0.95, "length": 19}}}, "19591110": {"ParentId": "19590008", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <em>enum</em> <code>POD_TYPE</code> is a <em>type</em> and won't effect the <em>layout</em>, we can see this from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>9.2</code> <em>Class members</em> paragraph <em>1</em> which says:</p>\n<blockquote>\n<p id=\"so_19590008_19591110_0\">[...]Members of a class are data members, member functions (9.3), nested types, and\n  enumerators. Data members and member functions are static or non-static; see 9.4. <strong>Nested types are classes (9.1, 9.7) and enumerations (7.2)</strong> [...]</p>\n</blockquote>\n<p>as opposed to <em>data members</em> and we can further see that the definition of a  <em>standard layout class</em> depends only on data member from paragraph <em>16</em> which says:</p>\n<blockquote>\n<p id=\"so_19590008_19591110_1\">Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).</p>\n</blockquote>\n<p>and we further see going back to section <code>9</code> <em>Classes</em> paragraph <em>10</em> which says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19590008_19591110_2\">A POD struct<sup>108</sup> is a non-union class that is <strong>both a trivial class and a standard-layout class</strong>, and has <strong>no non-static data members</strong> of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union is a union that is both a trivial class and a standard layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD struct or a POD union.</p>\n</blockquote>\n<p>As far as I can tell the <em>pre C++11</em> standard does not diff much in the above items.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-10-26T01:04:59.813", "Id": "19591110", "Score": "1", "CreationDate": "2013-10-25T13:22:49.203", "LastActivityDate": "2013-10-26T01:04:59.813"}});