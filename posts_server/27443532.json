post_cb({"bq_ids": {"n4140": {"so_27443532_27443602_0": {"length": 59, "quality": 0.921875, "section_id": 5999}}, "n3337": {"so_27443532_27443602_0": {"length": 59, "quality": 0.921875, "section_id": 5767}}}, "27443532": {"ViewCount": "1761", "Body": "<p>It's been rehashed over and over that primitive types don't have constructors. For example this <code>_bar</code> is not initialized to 0 when I call <code>Foo()</code>:</p>\n<pre><code>class Foo{\n    int _bar;\n};\n</code></pre>\n<p><strong>So obviously <code>int()</code> is not a constructor. But what <em>is</em> it's name?</strong></p>\n<p>In this example I would say <code>i</code> is: (constructed? initialized? fooed?)</p>\n<pre><code>for(int i{}; i &lt; 13; ++i)\n</code></pre>\n<p><a href=\"https://stackoverflow.com/users/14065/loki-astari\">Loki Astari</a> mentions <a href=\"https://stackoverflow.com/questions/5113365/do-built-in-types-have-default-constructors/5113429?noredirect=1#comment43301621_5113429\">here</a> that the technique has some sort of name.</p>\n<p><strong>EDIT in response to <a href=\"https://stackoverflow.com/users/204847/mike-seymour\">Mike Seymour</a>:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Foo{\n    int _bar;\npublic:\n    void printBar(){ cout &lt;&lt; _bar &lt;&lt; endl; }\n};\n\nint main()\n{\n    Foo foo;\n\n    foo.printBar();\n\n    Foo().printBar();\n\n    return 0;\n}\n</code></pre>\n<p>Running this code on Visual Studio 2013 yields:</p>\n<blockquote>\n<p id=\"so_27443532_27443532_0\">3382592<br>\n  3382592</br></p>\n</blockquote>\n<p>Interestingly on gcc 4.8.1 yields:</p>\n<blockquote>\n<p id=\"so_27443532_27443532_1\">134514651<br>\n  0</br></p>\n</blockquote>\n", "AcceptedAnswerId": "27443703", "Title": "What is an int() Called?", "CreationDate": "2014-12-12T12:19:00.697", "Id": "27443532", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:59.987", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-10T10:59:57.230", "Score": "13", "OwnerUserId": "2642059", "Tags": "<c++><initialization><primitive><nomenclature><construction>", "AnswerCount": "3"}, "27444023": {"Id": "27444023", "PostTypeId": "2", "Body": "<p>You can call it a pseudo-constructor if you want, mirroring the terminology for destructor (<strong>pseudo-destructor calls</strong> are discussed in C++11 \u00a75.2.4). Anyway, <code>int()</code> is the default value of type <code>int</code>, i.e. 0.</p>\n<p>Re the assertion that \"primitive types don't have constructors\", that's a rather silly and impractical view. From a formal point of view primitive types don't have constructors, but those who cling to that assertion aren't that much into the formal, at all. Also, from a machine code point of view they don't, but again, to those who think that assertion is important, machine code is like magic. There is a difference, though, namely that from a machine code point of view also common non-primitive POD types can lack constructors (they do have constructors formally), and again I doubt that those who put that assertion forward are even aware of the issues, i.e. I don't think they're qualified to have an opinion. About the same kind of considerations go for any absolute terminological claim: you can be almost sure, when you hear such a claim, that those who make it have almost no idea about what's involved, and that the claim is just impractical &amp; silly.</p>\n<p>Instead, when you hear e.g. \"constructed\" or \"constructor call\" in the context of primitive types, think about what it <em>meaningfully</em> can mean. The formal is just a matter of definition. The important, except for language lawyer discussions where it anyway is a given, is to have a conceptual model that works.</p>\n<hr>\n<p>All the above said, the expression <code>T()</code> is not a \"constructor\" formally, it's not a constructor at the machine code level, and it's not a constructor conceptually, in any meaningful conceptual model.</p>\n<p>It <em>can</em> be a <strong>constructor <em>call</em></strong> (indeed the definition of a default constructor is that it can be called, at the source code level, with no arguments), but note that there's no grammar category for constructor calls.</p>\n<p>With all of the above in mind I would just call it a constructor call, and when there is a need to be more precise, for primitive type <code>T</code> I would call it a <strong>pseudo-constructor call</strong>.</p>\n<hr>\n<p>And if anyone criticized me for that, I'd just challenge them to a duel.</p>\n<hr>\n<p>Do note, regarding your statement that</p>\n<blockquote>\n<p id=\"so_27443532_27444023_0\"><strong>\u201d</strong> it's been rehashed over and over that primitive types don't have constructors. For example this bar is not initialized to 0 when I call <code>Foo()</code></p>\n</blockquote>\n<p>the expression <code>Foo()</code> performs value initialization, so that the instance (in this case) is zeroed.</p>\n<p>Regarding the general lack of initialization of local automatic variables of primitive types without initializers, you have the same situation with any type without a user defined constructor, and even when there is a used defined constructor if that constructor doesn't initialize things.</p>\n<p>This sometimes comes as a shock to C++ beginners.</p>\n</hr></hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-12-12T13:20:19.520", "CommentCount": "5", "CreationDate": "2014-12-12T12:48:40.133", "ParentId": "27443532", "Score": "-2", "OwnerUserId": "464581", "LastEditDate": "2014-12-12T13:20:19.520"}, "27443602": {"PostTypeId": "2", "Body": "<p>Here's what <code>int()</code> does (bearing in mind that, grammatically, <code>int</code> is a <em>simple-type-specifier</em>):</p>\n<blockquote>\n<p id=\"so_27443532_27443602_0\"><code>[C++11: 5.2.3/1]:</code> A <em>simple-type-specifier</em> (7.1.6.2) or <em>typename-specifier</em> (14.6) followed by a parenthesized <em>expression-list</em> constructs a value of the specified type given the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding cast expression (5.4). If the type specified is a class type, the class type shall be complete. If the expression list specifies more than a single value, the type shall be a class with a suitably declared constructor (8.5, 12.1), and the expression <code>T(x1, x2, ...)</code> is equivalent in effect to the declaration <code>T t(x1, x2, ...)</code>; for some invented temporary variable <code>t</code>, with the result being the value of <code>t</code> as a prvalue.</p>\n</blockquote>\n<p>Speaking colloquially, it represents the construction of a temporary <code>int</code> with an empty initialiser. I think you'd struggle to find a formal name for the entire construct, though.</p>\n<p>This is not the same as <code>int i{}</code>, which is a full-fledged <em>declaration</em> of a named object with an initialiser: your <code>i</code> has been declared, constructed and initialised.</p>\n<p>(I don't think that any of this is related to what Loki was saying in his comment on that linked answer.)</p>\n", "LastActivityDate": "2014-12-12T12:23:25.587", "Id": "27443602", "CommentCount": "1", "CreationDate": "2014-12-12T12:23:25.587", "ParentId": "27443532", "Score": "5", "OwnerUserId": "560648"}, "27443703": {"Id": "27443703", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27443532_27443703_0\">It's been rehashed over and over that primitive types don't have constructors. </p>\n</blockquote>\n<p>That's right.</p>\n<blockquote>\n<p id=\"so_27443532_27443703_1\">For example this bar is not initialized to 0 when I call <code>Foo()</code></p>\n</blockquote>\n<p>Yes it is. <code>Foo()</code> specifies value-initialisation which, for class like this with no user-provided constructor, means it's zero-initialised before initialising its members. So <code>_bar</code> ends up with the value zero. (Although, as noted in the comments, one popular compiler doesn't correctly value-initialise such classes.)</p>\n<p>It would not be initialised if you were to use default-initialisation instead. You can't do that with a temporary; but a declared variable <code>Foo f;</code> or an object by <code>new F</code> will be default-initialised. Default-initialisation of primitive types does nothing, leaving them with an indeterminate value.</p>\n<p>It would also not be initialised if the class had a user-provided default constructor, and that constructor didn't specifically initialise <code>_bar</code>. Again, it would be default-initialised, with no effect.</p>\n<blockquote>\n<p id=\"so_27443532_27443703_2\">So obviously int() is not a constructor. But what is it's name?</p>\n</blockquote>\n<p>As an expression, it's a value-initialised temporary of type <code>int</code>.</p>\n<p>Syntactically, it's a special case of an \"explicit type conversion (functional notation)\"; but it would be rather confusing to use that term for anything other than a type conversion.</p>\n<blockquote>\n<p id=\"so_27443532_27443703_3\">In this example I would say <code>i</code> is: (constructed? initialized? fooed?)</p>\n</blockquote>\n<p>Initialised. List-initialised (with an empty list), value-initialised, or zero-initialised, if you want to be more specific.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-12-12T13:12:55.113", "CommentCount": "19", "CreationDate": "2014-12-12T12:29:16.313", "ParentId": "27443532", "Score": "7", "OwnerUserId": "204847", "LastEditDate": "2014-12-12T13:12:55.113"}});