post_cb({"46019670": {"Id": "46019670", "PostTypeId": "2", "Body": "<p>There are some special rules in overload resolution for template functions, one of them is :</p>\n<blockquote>\n<p id=\"so_46019548_46019670_0\">F1 and F2 are function template specializations, and the function template for F1 is <strong>more specialized than</strong> the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>See <a href=\"https://stackoverflow.com/questions/17005985/whats-the-partial-ordering-procedure-in-template-deduction\">this question</a> about how to determine which function template is more specialized.</p>\n<p>Here, as the second template function is more specialized, there is no ambiguation.</p>\n<hr>\n<pre><code>#include &lt;iostream&gt;\nvoid func(int * const &amp;) {}\nvoid func(int *) {}\n\ntemplate &lt;typename T&gt; void tfunc(const T &amp;) {std::cout &lt;&lt; \"#1\\n\";}\ntemplate &lt;typename T&gt;void tfunc(T *) {std::cout &lt;&lt; \"#2\\n\";}\n\nint main()\n{\n  int a = 0;\n\n  //func(&amp;a);   // ambiguous\n  tfunc(&amp;a);  // unambiguous\n\n  return 0;\n}\n// output: #2\n</code></pre>\n<p>Edit: Though a test in <a href=\"https://ideone.com/C9rF8b\" rel=\"nofollow noreferrer\">https://ideone.com/C9rF8b</a> , we can see that the second template is chosen, not the first one as stated in the question.</p>\n</hr>", "LastEditorUserId": "1058916", "LastActivityDate": "2017-09-03T02:20:13.360", "Score": "2", "CreationDate": "2017-09-03T02:05:09.540", "ParentId": "46019548", "CommentCount": "0", "OwnerUserId": "1058916", "LastEditDate": "2017-09-03T02:20:13.360"}, "46019699": {"Id": "46019699", "PostTypeId": "2", "Body": "<p>Because a const pointer and a non-const pointer (i.e. <code>T * const</code> and <code>T *</code>) makes no difference if they appear in a function's parameters, and so does passing by value (by copy) and passing by const reference. That's the reason why <code>f(&amp;a)</code> is ambiguous.</p>\n<p>For the second one, since <code>&amp;a</code> is resolved to <code>int *</code>, the second template matches better because it's more specialized (it can't accept non-pointer arguments). The first template is more general so it's not used.</p>\n<p>If you change the first template function to this it will also be ambiguous:</p>\n<pre><code>template &lt;typename T&gt;\nvoid tfunc(T * const &amp;) {}\n</code></pre>\n", "LastActivityDate": "2017-09-03T02:11:20.333", "CommentCount": "0", "CreationDate": "2017-09-03T02:11:20.333", "ParentId": "46019548", "Score": "0", "OwnerUserId": "5958455"}, "46019548": {"ViewCount": "48", "Body": "<pre><code>// g++(5.4)\n\nvoid func(int * const &amp;) {}\nvoid func(int *) {}\n\ntemplate &lt;typename T&gt; void tfunc(const T &amp;) {}\ntemplate &lt;typename T&gt; void tfunc(T *) {}\n\nint main()\n{\n  int a = 0;\n\n  func(&amp;a);   // ambiguous\n  tfunc(&amp;a);  // unambiguous\n\n  return 0;\n}\n</code></pre>\n<p>According to my another test, <code>tfunc(&amp;a)</code> instantiates the first template to <code>void tfunc(int * const &amp;)</code> which has the same parameter type as the first nontemplate.</p>\n<p>So, why is the first call ambiguous but the second not?</p>\n", "AcceptedAnswerId": "46019698", "Title": "overloaded templates resolution", "CreationDate": "2017-09-03T01:35:24.603", "Id": "46019548", "CommentCount": "1", "LastEditDate": "2017-09-03T02:29:21.210", "PostTypeId": "1", "LastEditorUserId": "8314962", "LastActivityDate": "2017-09-03T02:29:21.210", "Score": "3", "OwnerUserId": "8314962", "Tags": "<c++><templates><overloading>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_46019548_46019670_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 603}}, "n3337": {"so_46019548_46019670_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 593}}, "n4659": {"so_46019548_46019670_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 629}}}, "46019698": {"Id": "46019698", "PostTypeId": "2", "Body": "<p>Given two function templates that are otherwise equally as good, overload resolution will select the <em>more specialized</em> function template, using a procedure commonly known as <em>partial ordering</em>. The exact rules are pretty complicated, but essentially it tries to determine if the set of arguments template A can be called with is a (proper) subset of the set of arguments template B can be called with. If so, then A is more specialized than B, and overload resolution will prefer A.</p>\n<p>Thus, in your case, <code>tfunc(const T&amp;)</code> can be called with ~everything; <code>tfunc(T*)</code> can only be called with pointers. The latter is more specialized, and is therefore selected.</p>\n<p>If you are interested in the standardese and detailed rules, see <a href=\"https://timsong-cpp.github.io/cppwp/temp.func.order\" rel=\"noreferrer\">[temp.func.order]</a> and <a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.partial\" rel=\"noreferrer\">[temp.deduct.partial]</a>.</p>\n", "LastActivityDate": "2017-09-03T02:11:19.040", "CommentCount": "3", "CreationDate": "2017-09-03T02:11:19.040", "ParentId": "46019548", "Score": "5", "OwnerUserId": "2756719"}});