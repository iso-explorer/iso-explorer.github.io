post_cb({"23870601": {"Id": "23870601", "PostTypeId": "2", "Body": "<p>Instead of sorting by the value of the pointers, you should probably pass a comparison object sorting by the pointed to values:</p>\n<pre><code>struct deref_compare {\n    template &lt;typename T&gt;\n    bool operator()(T const* o0, T const* o1) const {\n        return *o0 &lt; *o1;\n    }\n};\n\nstd::set&lt;int*, deref_compare&gt; s;\n// use s as before\n</code></pre>\n<p>If you can't change the declaration of the <code>std::set&lt;int*&gt;</code> you can <em>technically</em> specialize <code>std::less&lt;int*&gt;</code> to do something different but it isn't allowed unless you specialize involving user-defined types:</p>\n<pre><code>namespace std\n{\n    template &lt;&gt;\n    class less&lt;int*&gt; {\n    public:\n        bool operator()(int const* o0, int const* o1) const {\n            return *o0 &lt; *o1;\n        }\n    };\n}\n</code></pre>\n<p>Note that specializing any of the standard class templates without involving user-defined types results in undefined behavior: I'd recommend against specializing <code>std::less&lt;int*&gt;</code>. The problem is that it can affect other code, e.g., in the standard C++ library. The relevant section of the C++ standard is 17.6.4.2.1 [namespace.std] paragraph 1:</p>\n<blockquote>\n<p id=\"so_23870522_23870601_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified. A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2014-05-26T13:22:10.183", "Score": "3", "CreationDate": "2014-05-26T12:51:04.197", "ParentId": "23870522", "CommentCount": "5", "OwnerUserId": "1120273", "LastEditDate": "2014-05-26T13:22:10.183"}, "bq_ids": {"n4140": {"so_23870522_23870601_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}}, "n3337": {"so_23870522_23870601_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}}, "n4659": {"so_23870522_23870601_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}}}, "23870608": {"Id": "23870608", "PostTypeId": "2", "Body": "<p>Since the order imposed in a <code>std::set</code> is managed through a natural ordering of the elements, if you need a specific order, you need a specific criterion which doesn't change every specific run. This because the natural ordering on pointers involves just the value of the address itself.</p>\n<p>This means that you need to have a way to give a consistent order on them, through a specific comparison operator, eg:</p>\n<pre><code>struct my_order {\n    bool operator() (const Object* lhs, const Object* rhs) const {\n      // return consistent value for same pair of lhs and rhs\n    }\n\nset&lt;Object*, my_order&gt; mySet;\n</code></pre>\n", "LastActivityDate": "2014-05-26T12:51:22.747", "CommentCount": "2", "CreationDate": "2014-05-26T12:51:22.747", "ParentId": "23870522", "Score": "2", "OwnerUserId": "121747"}, "23870622": {"Id": "23870622", "PostTypeId": "2", "Body": "<p>You can specify a comparison function.</p>\n<p>As I'm writing this there is no code in the question, so no way to provide an example using your classes etc.</p>\n<p>Just check out the <a href=\"http://en.cppreference.com/w/cpp/container/set\" rel=\"nofollow\">documentation</a>.</p>\n", "LastActivityDate": "2014-05-26T12:51:55.147", "CommentCount": "0", "CreationDate": "2014-05-26T12:51:55.147", "ParentId": "23870522", "Score": "2", "OwnerUserId": "464581"}, "23870522": {"ViewCount": "66", "Body": "<p>Iam using stl <code>set</code> container class for storing pointers to objects. While reading from the stl sets, for different runs of the program, the order of objects are getting changed because of dynamic allocation of memory (address) to object.</p>\n<p>Lets say objects are A,B,C and their addresses in first run are 10,16,12. So when I insert these objects into <em>set</em> and retrieve them, I will get output as A C B (b'caz 10&lt;12&lt;16). Now if in the next run the addresses alloted are 14, 10, 8, I would get the output as C B A (8&lt;10&lt;14).</p>\n<p>Is there any way that I can get output in perticular order? </p>\n<p>Overloading comparator (custom comparator) can solve the problem, but in that case I have to pass it as a template parameter, which leads to modifying code at many places. Is there any way of avoiding modifying my code, still able to write custome comparator? </p>\n", "Title": "Order of items in STL SET differ for different runs of program", "CreationDate": "2014-05-26T12:46:34.500", "LastActivityDate": "2014-05-26T13:22:10.183", "CommentCount": "3", "PostTypeId": "1", "Id": "23870522", "Score": "0", "OwnerUserId": "1850417", "Tags": "<c++><stl><set><order>", "AnswerCount": "3"}});