post_cb({"bq_ids": {"n4140": {"so_42244250_42246348_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 7104}, "so_42244250_42246348_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 7104}, "so_42244250_42246348_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 336}, "so_42244250_42246348_4": {"length": 9, "quality": 0.6, "section_id": 147}, "so_42244250_42246348_1": {"length": 9, "quality": 0.6, "section_id": 147}, "so_42244250_42246348_6": {"length": 10, "quality": 0.625, "section_id": 7104}, "so_42244250_42246348_3": {"length": 10, "quality": 0.625, "section_id": 7104}, "so_42244250_42249785_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 603}}, "n3337": {"so_42244250_42246348_3": {"length": 10, "quality": 0.625, "section_id": 6848}, "so_42244250_42246348_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 6848}, "so_42244250_42246348_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 6848}, "so_42244250_42246348_4": {"length": 9, "quality": 0.6, "section_id": 141}, "so_42244250_42246348_1": {"length": 9, "quality": 0.6, "section_id": 141}, "so_42244250_42246348_6": {"length": 10, "quality": 0.625, "section_id": 6848}, "so_42244250_42249785_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 593}, "so_42244250_42246348_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 326}}, "n4659": {"so_42244250_42246348_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 623}, "so_42244250_42246348_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 623}, "so_42244250_42246348_0": {"length": 6, "quality": 1.0, "section_id": 623}, "so_42244250_42246348_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 623}, "so_42244250_42246348_6": {"length": 15, "quality": 0.9375, "section_id": 623}, "so_42244250_42246348_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 623}, "so_42244250_42246348_3": {"length": 15, "quality": 0.9375, "section_id": 623}, "so_42244250_42249785_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 629}}}, "42244250": {"ViewCount": "369", "Body": "<p>In <a href=\"https://stackoverflow.com/a/42221591/819272\"><strong>this Q&amp;A</strong></a> I wrote a little wrapper class that provides reverse iterator access to a range, relying on the c++1z language feature template argument deduction for class templates (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html\" rel=\"nofollow noreferrer\"><strong>p0091r3</strong></a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0512r0.pdf\" rel=\"nofollow noreferrer\"><strong>p0512r0</strong></a>)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;class Rng&gt;\nclass Reverse\n{\n    Rng const&amp; rng;    \npublic:    \n    Reverse(Rng const&amp; r) noexcept\n    : \n        rng(r)\n    {}\n\n    auto begin() const noexcept { using std::end; return std::make_reverse_iterator(end(rng)); }\n    auto end()   const noexcept { using std::begin; return std::make_reverse_iterator(begin(rng)); }\n};\n\nint main()\n{\n    std::vector&lt;int&gt; my_stack;\n    my_stack.push_back(1);\n    my_stack.push_back(2);\n    my_stack.puhs_back(3);\n\n    // prints 3,2,1\n    for (auto const&amp; elem : Reverse(my_stack)) {\n        std::cout &lt;&lt; elem &lt;&lt; ',';    \n    }\n}\n</code></pre>\n<p>However, doing a nested application of <code>Reverse</code> does not yield the original iteration order</p>\n<pre><code>// still prints 3,2,1 instead of 1,2,3\nfor (auto const&amp; elem : Reverse(Reverse(my_stack))) {\n    std::cout &lt;&lt; elem &lt;&lt; ',';    \n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/xk0yEumtsG1hp6VT\" rel=\"nofollow noreferrer\"><strong>Live Example</strong></a> (same output for g++ 7.0 SVN and clang 5.0 SVN)</p>\n<p>The culprit seems to be the template argument deduction for class templates because the usual wrapper function does allow for correct nesting</p>\n<pre><code>template&lt;class Rng&gt;\nauto MakeReverse(Rng const&amp; rng) { return Reverse&lt;Rng&gt;(rng); }\n\n// prints 1,2,3\nfor (auto const&amp; elem : MakeReverse(MakeReverse(my_stack))) {\n    std::cout &lt;&lt; elem &lt;&lt; ',';    \n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/uS9dUBYhWH9Ql4fK\" rel=\"nofollow noreferrer\"><strong>Live Example</strong></a> (same output for g++ and clang)</p>\n<p><strong>Question</strong>: is nested template argument deduction for class templates supposed to work only \"one level\" deep, or is this a bug in the current implementations of both g++ and clang?</p>\n", "AcceptedAnswerId": "42249785", "Title": "Nested template argument deduction for class templates not working", "CreationDate": "2017-02-15T08:33:58.240", "Id": "42244250", "CommentCount": "15", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:29.737", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-15T15:26:12.177", "Score": "12", "OwnerUserId": "819272", "Tags": "<c++><templates><c++1z><class-template><argument-deduction>", "AnswerCount": "2"}, "42249785": {"Id": "42249785", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/42246348/2069064\">Piotr's answer</a> correctly explains what is happening - the move constructor is a better match than your constructor template.</p>\n<p>But (h/t <a href=\"https://stackoverflow.com/questions/42244250/nested-template-argument-deduction-for-class-templates-not-working/42246348?noredirect=1#comment71661973_42246348\">T.C.</a> as usual) there's a better fix than just writing a factory anyway: you can add an explicit deduction guide for your constructor:</p>\n<pre><code>template &lt;class R&gt;\nReverse(R ) -&gt; Reverse&lt;R&gt;;\n</code></pre>\n<p>This seems redundant with your already existing constructor, since it defines exact same rule. But there is a newly added preference in [over.match.best] for this:</p>\n<blockquote>\n<p id=\"so_42244250_42249785_0\">Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function <code>F2</code> if [...] <code>F1</code> is generated from a deduction-guide (13.3.1.8) and <code>F2</code> is not.</p>\n</blockquote>\n<p>Hence, we'd have <em>four</em> generated functions, borrowing again from Piotr's naming:</p>\n<pre><code>template &lt;typename Rng&gt;\nReverse&lt;Rng&gt; foo(const Rng&amp; r);           // #1\n\ntemplate &lt;typename Rng&gt;\nReverse&lt;Rng&gt; foo(const Reverse&lt;Rng&gt;&amp; r);  // #2\n\ntemplate &lt;typename Rng&gt;\nReverse&lt;Rng&gt; foo(Reverse&lt;Rng&gt;&amp;&amp; r);       // #3\n\ntemplate &lt;typename Rng&gt;\nReverse&lt;Rng&gt; foo(Rng r);                  // #4 - same-ish as #1, but deduction guide\n</code></pre>\n<p>Before, <code>#3</code> was preferred as being more specialized. Now, <code>#4</code> is preferred as being a deduction guide. So, we can still write:</p>\n<pre><code>for (auto const&amp; elem : Reverse(Reverse(my_stack))) {\n    std::cout &lt;&lt; elem &lt;&lt; ',';    \n}\n</code></pre>\n<p>and that works. On clang, anyway. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-15T15:26:12.177", "Score": "4", "CreationDate": "2017-02-15T12:44:05.977", "ParentId": "42244250", "CommentCount": "5", "LastEditDate": "2017-05-23T11:53:49.533", "OwnerUserId": "2069064"}, "42246348": {"Id": "42246348", "PostTypeId": "2", "Body": "<p>This may be explained in <a href=\"http://eel.is/c++draft/over.match.class.deduct#1\">[over.match.class.deduct]/p1</a>:</p>\n<blockquote>\n<p id=\"so_42244250_42246348_0\">A set of functions and function templates is formed comprising:</p>\n<ul>\n<li>For each constructor of the class template designated by the\n  <em>template-name</em>, a function template with the following properties:</li>\n</ul>\n<blockquote>\n<ul>\n<li><p id=\"so_42244250_42246348_4\">The template parameters are the template parameters of the class template followed by the template parameters (including default\n    template arguments) of the constructor, if any.</p></li>\n<li><p id=\"so_42244250_42246348_5\">The types of the function parameters are those of the constructor.</p></li>\n<li><p id=\"so_42244250_42246348_6\">The return type is the class template specialization designated by the <em>template-name</em> and template arguments corresponding to the template\n    parameters obtained from the class template.</p></li>\n</ul>\n</blockquote>\n</blockquote>\n<p>My understanding is that the compiler invents the following two functions (two - including a copy constructor that is implicitly generated for this class):</p>\n<pre><code>template &lt;typename Rng&gt;\nReverse&lt;Rng&gt; foo(const Rng&amp; r);           // #1\n\ntemplate &lt;typename Rng&gt;\nReverse&lt;Rng&gt; foo(const Reverse&lt;Rng&gt;&amp; r);  // #2\n</code></pre>\n<p>and then tries to select the best overload based on the call:</p>\n<pre><code>foo(Reverse&lt;std::vector&lt;int&gt;&gt;(my_stack));\n</code></pre>\n<p>which resolves to #2 because this one is more specialized. The conclusion is that:</p>\n<pre><code>Reverse(Reverse(my_stack))\n</code></pre>\n<p>involves a copy constructor to construct the outer <code>Reverse</code> instance.</p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2017-02-15T10:46:39.433", "Score": "7", "CreationDate": "2017-02-15T10:12:17.237", "ParentId": "42244250", "CommentCount": "11", "LastEditDate": "2017-02-15T10:46:39.433", "OwnerUserId": "3953764"}});