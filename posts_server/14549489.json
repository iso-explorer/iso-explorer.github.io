post_cb({"14550864": {"ParentId": "14549489", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>As far as the C++ standard is concerned:</p>\n<ul>\n<li>if you call a virtual function in a constructor or destructor, then the function is \ndynamically dispatched as if its dynamic type were that of the current constructor/destructor being executed (\u00a712.7/4)</li>\n<li>if that function happened to a pure virtual, then this is <em>undefined behavior</em> (\u00a710.4/6); the <a href=\"http://www.swag.uwaterloo.ca/acd/docs/ItaniumC++ABI.htm#pure-virtual\" rel=\"noreferrer\">Itanium ABI</a> defines the behavior: <code>__cxa_pure_virtual</code> is called.</li>\n</ul>\n<p>So, you have a bit of a thorny issue...</p>\n<hr>\n<p>A possible solution to the problem would be to break it down in two parts, in order to break the destruction in two parts. This could be achieved with a <code>Strategy</code> pattern:</p>\n<ul>\n<li>provide a customizable <em>interface</em>, your strategy</li>\n<li>provide a manager class that encapsulate the functionality and defers to the strategy for the customizable parts</li>\n</ul>\n<p>Let's make it clearer:</p>\n<pre><code>class Interface {\npublic:\n    friend class Manager;\n\nprivate:\n    virtual void finalize() = 0;\n}; // class Interface\n\n\nclass Manager {\npublic:\n    explicit Manager(std::unique_ptr&lt;Interface&gt;&amp;&amp;);\n\n    ~Manager();\n\nprivate:\n    std::unique_ptr&lt;Interface&gt; _interface;\n}; // class Manager\n\nManager::~Manager() {\n    _interface-&gt;finalize();\n}\n</code></pre>\n<p>The trick ? At the point where <code>finalize()</code> is called the destruction of <code>_interface</code> has not begun yet! The call to the destructor will happen later; and thus you do not suffer from a half-dead object's fate.</p>\n<p>I'll end this answer by a warning about <code>join</code>-ing a thread in a destructor now. Beware that destructors are automatically called in case of <em>stack unwinding</em>, it might therefore be dangerous to wait indefinitely while <em>failing</em>; especially if the thread is waiting for data that should be provided by the currently <em>being unwound</em> one... a classic case of dead-lock.</p>\n<hr>\n<p><strong>References</strong> (n3337):</p>\n<blockquote>\n<p id=\"so_14549489_14550864_0\"><strong>\u00a712.7/4</strong> Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor or from a destructor, including during the construction or destruction of the class\u2019s non-static data members, and the object to which the call applies is the object (call it x) under construction or destruction, <em>the function called is the final overrider in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class</em>.</p>\n<p id=\"so_14549489_14550864_1\"><strong>\u00a710.4/6</strong> Member functions can be called from a constructor (or destructor) of an abstract class; <em>the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</em></p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2013-01-28T08:21:18.487", "Id": "14550864", "Score": "6", "CreationDate": "2013-01-27T18:47:38.907", "LastActivityDate": "2013-01-28T08:21:18.487"}, "14549489": {"CommentCount": "13", "AcceptedAnswerId": "14549689", "PostTypeId": "1", "LastEditorUserId": "3235496", "CreationDate": "2013-01-27T16:34:08.490", "LastActivityDate": "2015-07-23T15:41:04.550", "LastEditDate": "2015-03-07T10:30:27.043", "ViewCount": "24741", "FavoriteCount": "1", "Title": "How to fix pure virtual function called runtime error?", "Id": "14549489", "Score": "3", "Body": "<p>I understand why I am getting the error I am getting (pure virtual function called). I am trying to call pure virtual functions from within the destructor of my base class shown below. However, I do not know how to rework my code to prevent this from happening. Here are the base and derived classes (the relevant portions anyway):</p>\n<p>Base class:</p>\n<pre><code>TailFileManager::TailFileManager(const std::string &amp;filename, const int fileOpenPeriod_ms)\n: m_Stop(false)\n{\n    m_WorkerThread.reset(new boost::thread(boost::bind(&amp;TailFileManager::TailFile, this, filename, fileOpenPeriod_ms)));\n}\n\nTailFileManager::~TailFileManager()\n{\n    m_Stop = true;\n    m_WorkerThread-&gt;join();\n}\n\nvoid TailFileManager::TailFile(const std::string &amp;filename, const int fileOpenPeriod_ms)\n{\n    std::ifstream ifs(filename.c_str());\n\n    while (! ifs.is_open())\n    {\n        boost::this_thread::sleep(boost::posix_time::milliseconds(fileOpenPeriod_ms));\n    ifs.open(filename.c_str());\n    }\n\n    ifs.seekg(0, std::ios::end);\n\n    while (! m_Stop)\n    {\n        ifs.clear();\n\n        std::string line;\n\n        while (std::getline(ifs, line))\n        {\n            OnLineAdded(line);\n        }\n\n        OnEndOfFile();\n    }\n\n    ifs.close();\n}\n</code></pre>\n<p>Derived class:</p>\n<pre><code>ETSLogTailFileManager::ETSLogTailFileManager(const std::string &amp;filename, const int heartbeatPeriod_ms)\n: TailFileManager(filename, heartbeatPeriod_ms),\n  m_HeartbeatPeriod_ms(heartbeatPeriod_ms),\n  m_FoundInboundMessage(false),\n  m_TimeOfLastActivity(0)\n{\n}\n\nETSLogTailFileManager::~ETSLogTailFileManager()\n{\n}\n\nvoid ETSLogTailFileManager::OnLineAdded(const std::string &amp;line)\n{\n    // do stuff...\n}\n\nvoid ETSLogTailFileManager::OnEndOfFile()\n{\n    // do stuff...\n}\n</code></pre>\n", "Tags": "<c++><pure-virtual>", "OwnerUserId": "834594", "AnswerCount": "3"}, "14549689": {"ParentId": "14549489", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>You shouldn't call virtual functions during construction or destruction, because the calls won't do what you think, and if they did, you'd still be unhappy. If you're a recovering Java or C# programmer, pay close attention to this Item, because this is a place where those languages zig, while C++ zags.</p>\n<p>Re-work your design i.e you may call some cleanup function before object get destroyed, idea is just avoid virtual function during const/dest (if there are any!), if you are working with C++...</p>\n<p>The rules for virtual invocation are different. C++ 2003, section 12.7 \"Construction and Destruction\", says:</p>\n<p>Lets refresh some old memories ...</p>\n<p>Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor (including from the mem-initializer for a data member) or from a destructor, and the object to which the call applies is the object under construction or destruction, the function called is the one defined in the constructor or destructor\u00e2s own class or in one of its bases, but not a function overriding it in a class derived from the constructor or destructor\u00e2s class, or overriding it in one of the other base classes of the most derived object (1.8). If the virtual function call uses an explicit class member access (5.2.5) and the object-expression refers to the object under construction or destruction but its type is neither the constructor or destructor\u00e2s own class or one of its bases, the result of the call is undefined.</p>\n<p><strong>Because of this difference in behavior, it is recommended that you never invoke an object's virtual function while it is being constructed or destroyed.</strong></p>\n<p><strong>Never Call Virtual Functions during Construction or Destruction\nAn Excerpt from Effective C++, Third Edition\nby Scott Meyers</strong>\nJune 6, 2005</p>\n<p><a href=\"http://www.artima.com/cppsource/nevercall.html\" rel=\"noreferrer\">http://www.artima.com/cppsource/nevercall.html</a></p>\n", "OwnerUserId": "1012551", "LastEditorUserId": "1012551", "LastEditDate": "2013-12-05T07:25:35.687", "Id": "14549689", "Score": "10", "CreationDate": "2013-01-27T16:53:42.427", "LastActivityDate": "2013-12-05T07:25:35.687"}, "bq_ids": {"n4140": {"so_14549489_14550864_0": {"section_id": 447, "quality": 0.9375, "length": 45}, "so_14549489_14550864_1": {"section_id": 7023, "quality": 0.9259259259259259, "length": 25}, "so_14549489_14550027_0": {"section_id": 447, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_14549489_14550864_0": {"section_id": 438, "quality": 0.9375, "length": 45}, "so_14549489_14550864_1": {"section_id": 6769, "quality": 0.9259259259259259, "length": 25}, "so_14549489_14550027_0": {"section_id": 438, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_14549489_14550864_0": {"section_id": 469, "quality": 0.9375, "length": 45}, "so_14549489_14550864_1": {"section_id": 8520, "quality": 0.9259259259259259, "length": 25}, "so_14549489_14550027_0": {"section_id": 469, "quality": 0.5454545454545454, "length": 6}}}, "14550027": {"ParentId": "14549489", "CommentCount": "0", "Body": "<p>You write,</p>\n<blockquote>\n<p id=\"so_14549489_14550027_0\">\u201cI am trying to call pure virtual functions from within the destructor of my base class shown below.\u201d</p>\n</blockquote>\n<p>And the code in question is</p>\n<pre><code>TailFileManager::~TailFileManager()\n{\n    m_Stop = true;\n    m_WorkerThread-&gt;join();\n}\n</code></pre>\n<p>Happily in a single-threaded execution this couldn't possibly call a pure virtual function. But the thread that you're <code>join</code>ing might call a pure virtual function on this object, possibly via a non-virtual member function. If so, then the issue is with the threading, specifically the lifetime management of this object.</p>\n<p>Unfortunately you do not show the relevant code. Try to reduce things to a small, complete, working example. Where \"working\" in the sense that it reproduces the problem.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "14550027", "Score": "5", "CreationDate": "2013-01-27T17:26:40.213", "LastActivityDate": "2013-01-27T17:26:40.213"}});