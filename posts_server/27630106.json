post_cb({"27630415": {"ParentId": "27630106", "CommentCount": "0", "Body": "<p>You can provide a specialization of <code>std::numeric_limits</code> for your own type (\u00a7[namespace.std]/1):</p>\n<blockquote>\n<p id=\"so_27630106_27630415_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified. <strong>A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type</strong> and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>There doesn't seem to be any language to prohibit negative numbers for things like number of digits in \u00a7[limits.numeric], which is where you'd expect it if it existed. On the other hand, a negative number of digits doesn't make any sense either, and would pretty clearly run contrary to the description of the field, even though there's no <em>direct</em> prescription that the number be non-negative.</p>\n<p>It is entirely possible and reasonable for <code>std::numeric_limits&lt;T&gt;::digits</code> to produce the value 0 though. In fact, it's basically required to happen for most non-arithmetic types (\u00a7[numeric.limits]/1):</p>\n<pre><code>The default numeric_limits&lt;T&gt; template shall have all members, but with 0 or false \nvalues.\n</code></pre>\n<p>A few things that might initially <em>seem</em> like arithmetic types actually are <em>not</em>. For one obvious example, <code>std::complex&lt;T&gt;</code> is <em>not</em> an arithmetic type.</p>\n<p>Bottom line: I'd expect the number of digits to be strictly positive for all built-in types. Although there's nothing to <em>directly</em> prohibit a negative value for user-defined types, it seems like such a value would have to be an error--if the value is arithmetic, the number of digits should be strictly positive, and if it's not arithmetic, a specialization of <code>std::numeric_limits</code> should not be provided for that type (in which case the default with a value of 0 would be used).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "27630415", "Score": "0", "CreationDate": "2014-12-24T01:43:50.567", "LastActivityDate": "2014-12-24T01:43:50.567"}, "27630106": {"CommentCount": "0", "ViewCount": "76", "CreationDate": "2014-12-24T00:50:11.240", "LastActivityDate": "2014-12-24T01:43:50.567", "Title": "Can std::numeric_limits::digits be negative?", "PostTypeId": "1", "Id": "27630106", "Score": "0", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/digits\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/types/numeric_limits/digits</a></p>\n<p>Can the value ever be negative?</p>\n", "Tags": "<c++>", "OwnerUserId": "2068573", "AnswerCount": "2"}, "27630154": {"ParentId": "27630106", "CommentCount": "3", "Body": "<p>I suppose you could add your own specialisation for one of your own types and put in a negative <code>digits</code> member. For primitive types? No. The relevant place in the standard (as of 2011) is 18.3.2.4 (8-10):</p>\n<blockquote>\n<pre><code>static constexpr int digits;\n</code></pre>\n<p id=\"so_27630106_27630154_0\">8 Number of <code>radix</code> digits that can be represented without change.</p>\n<p id=\"so_27630106_27630154_1\">9 For integer types, the number of non-sign bits in the representation</p>\n<p id=\"so_27630106_27630154_2\">10 For floating point types, the number of <code>radix</code> digits in the mantissa.</p>\n</blockquote>\n<p>None of those can possibly be negative.</p>\n<p>If your actual question is: \"why, when <code>digits</code> cannot be negative, is it a signed <code>int</code>?\", then your guess is as good as mine. My guess is that it is because arithmetic with signed types is less surprising. For example, <code>std::numeric_limits&lt;int&gt;::digits - std::numeric_limits&lt;long&gt;::digits</code> is not larger than zero this way.</p>\n", "OwnerUserId": "4301306", "PostTypeId": "2", "Id": "27630154", "Score": "0", "CreationDate": "2014-12-24T00:59:48.023", "LastActivityDate": "2014-12-24T00:59:48.023"}, "bq_ids": {"n4140": {"so_27630106_27630154_2": {"section_id": 6728, "quality": 0.875, "length": 7}, "so_27630106_27630154_0": {"section_id": 6726, "quality": 1.0, "length": 6}, "so_27630106_27630415_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}, "so_27630106_27630154_1": {"section_id": 6727, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_27630106_27630154_2": {"section_id": 6483, "quality": 0.875, "length": 7}, "so_27630106_27630154_0": {"section_id": 6481, "quality": 1.0, "length": 6}, "so_27630106_27630415_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}, "so_27630106_27630154_1": {"section_id": 6482, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_27630106_27630154_2": {"section_id": 8222, "quality": 0.625, "length": 5}, "so_27630106_27630154_0": {"section_id": 8220, "quality": 1.0, "length": 6}, "so_27630106_27630415_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}, "so_27630106_27630154_1": {"section_id": 8221, "quality": 0.8571428571428571, "length": 6}}}});