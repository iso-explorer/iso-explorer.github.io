post_cb({"25655145": {"CommentCount": "8", "ViewCount": "261", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2014-09-03T23:28:34.920", "LastActivityDate": "2017-05-04T19:58:18.720", "Title": "How does a shared_ptr store deleter?", "LastEditDate": "2017-05-04T19:58:18.720", "Id": "25655145", "Score": "7", "Body": "<p>I can't understand how a <code>shared_ptr</code> can store the deleter that I gave to it.</p>\n<p>Initially, using a <code>shared_ptr&lt;int&gt;</code>, i thought it might use an <code>std::function&lt;void(int*)&gt;</code>, but i can give, as a deleter, any kind of function (or callable objects), as long as the first parameter is a <code>int*</code>.</p>\n<p>How can <code>shared_ptr</code> do this?</p>\n<p>I'm sorry if this is a silly question, I'm new to C++, forgive me!</p>\n<p>Edit:\nThe question is: how can I do something like that? What should I use? Any example? Or it is a very advanced topic?</p>\n", "Tags": "<c++><function><generics><shared-ptr>", "OwnerUserId": "3921616", "AnswerCount": "2"}, "25655168": {"ParentId": "25655145", "CommentCount": "0", "Body": "<p>The deleter, as well as the allocator, are type-erased. The shared pointer manages a dynamically allocated, private, templated control object, which is accessed through a polymorphic base and which stores all the type-specific state and functionality.</p>\n<p>The implementation of <code>std::function</code> uses similar ideas, since it is also a type-erasing dynamic manager class, but both are typically implemented entirely separately.</p>\n<p>The upshot is that both classes are comparatively \"expensive\" and should only be used when they are genuinely necessary. Otherwise, cheaper, non-polymorphic non-dynamic solutions are usually preferable.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "25655168", "Score": "7", "CreationDate": "2014-09-03T23:31:11.943", "LastActivityDate": "2014-09-03T23:31:11.943"}, "25655195": {"ParentId": "25655145", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_25655145_25655195_0\">I can give, as a deleter, any kind of function (or callable objects), as long as the first parameter is a <code>int*</code>.</p>\n</blockquote>\n<p>No, not really.  The <code>std::shared_ptr</code> constructor has the following contract, found in section 20.8.2.2.1 (<code>[util.smartptr.shared.const]</code>):</p>\n<blockquote>\n<pre><code>template&lt;class  Y,  class  D&gt;  shared_ptr(Y*  p,  D  d);\ntemplate&lt;class  Y,  class  D,  class  A&gt;  shared_ptr(Y*  p,  D  d,  A  a);\ntemplate  &lt;class  D&gt;  shared_ptr(nullptr_t  p,  D  d);\ntemplate  &lt;class  D,  class  A&gt;  shared_ptr(nullptr_t  p,  D  d,  A  a);\n</code></pre>\n<p id=\"so_25655145_25655195_1\">Requires:  <code>p</code>  shall  be  convertible  to  <code>T*</code>.   <code>D</code>  shall  be  CopyConstructible.   The  copy  constructor  and destructor  of    <code>D</code>  shall  not  throw  exceptions.   <strong>The  expression  <code>d(p)</code>  shall  be  well  formed</strong>,  shall  have well defined behavior,  and shall not throw exceptions.  A shall be an allocator (17.6.3.5).  The copy constructor and destructor of A shall not throw exceptions.</p>\n<p id=\"so_25655145_25655195_2\">Effects:  Constructs a <code>shared_ptr</code> object that owns  the object <code>p</code> and the deleter <code>d</code>.  The second and fourth constructors shall use a copy of <code>a</code> to allocate memory for internal use.</p>\n<p id=\"so_25655145_25655195_3\">Postconditions:  <code>use_count() == 1 &amp;&amp; get() == p</code>.</p>\n<p id=\"so_25655145_25655195_4\">Throws:   <code>bad_alloc</code>,  or  an  implementation-defined  exception  when  a  resource  other  than  memory could not be obtained.</p>\n<p id=\"so_25655145_25655195_5\">Exception safety:  If an exception is thrown, <code>d(p)</code> is called.</p>\n</blockquote>\n<p>This requirement is a lot stronger than that the first parameter of the deleter must be the right type.  It has to be the only parameter (without a default argument), such that <code>d(p)</code> is legal.  This is slightly more flexible than <code>std::function&lt;void (int*)&gt;</code>, because the return type can be anything, but it's also more constrained with respect to exception guarantees.</p>\n<p>If your compiler doesn't catch you when you provide a deleter with multiple required parameters, the standard library implementation is doing something rather wrong.</p>\n<p>As far as how to implement it, take advantage of the fact that it must be CopyConstructible.  For example, the following lambda should work pretty nicely, and be assignable to <code>std::function&lt;void(void)&gt;</code> (the CopyConstructible guarantee ensures that capture by value works):</p>\n<pre><code>[d, p] { d(p); }\n</code></pre>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2014-09-04T00:53:15.203", "Id": "25655195", "Score": "4", "CreationDate": "2014-09-03T23:35:22.617", "LastActivityDate": "2014-09-04T00:53:15.203"}, "bq_ids": {"n4140": {"so_25655145_25655195_4": {"section_id": 4383, "quality": 0.8181818181818182, "length": 9}, "so_25655145_25655195_1": {"section_id": 4385, "quality": 0.8148148148148148, "length": 22}, "so_25655145_25655195_2": {"section_id": 4386, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_25655145_25655195_4": {"section_id": 4220, "quality": 0.8181818181818182, "length": 9}, "so_25655145_25655195_1": {"section_id": 4222, "quality": 0.8148148148148148, "length": 22}, "so_25655145_25655195_2": {"section_id": 4223, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_25655145_25655195_4": {"section_id": 5648, "quality": 0.8181818181818182, "length": 9}, "so_25655145_25655195_2": {"section_id": 5651, "quality": 0.8823529411764706, "length": 15}}}});