post_cb({"bq_ids": {"n4140": {"so_10664699_10666695_0": {"length": 32, "quality": 1.0, "section_id": 1871}}, "n3337": {"so_10664699_10666695_0": {"length": 32, "quality": 1.0, "section_id": 1865}}, "n4659": {"so_10664699_10666695_0": {"length": 32, "quality": 1.0, "section_id": 2043}}}, "10666695": {"Id": "10666695", "PostTypeId": "2", "Body": "<p>In VC++ 2010 there are three overloads of <code>std::to_string</code> that take <code>long long</code>, <code>unsigned long long</code>, and <code>long double</code>, respectively \u2013 clearly <code>int</code> is none of these, and no one conversion is better than another (<a href=\"http://coliru.stacked-crooked.com/a/69cf73c6af5a7294\" rel=\"nofollow noreferrer\">demo</a>), so the conversion cannot be done implicitly/unambiguously.</p>\n<p>In terms of real C++11 support, this is a failing on the part of VC++ 2010's standard library implementation \u2013 the C++11 standard itself actually calls for <em>nine</em> overloads of <code>std::to_string</code> ([string.conversions]/7):</p>\n<blockquote id=\"so_10664699_10666695_0\">\n<pre><code>string to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n</code></pre>\n</blockquote>\n<p>Had all of these overloads been present, you obviously wouldn't have this problem; however, VC++ 2010 wasn't based on the actual C++11 standard (which did not yet exist at the time of its release), but rather on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf\" rel=\"nofollow noreferrer\">N3000</a> (from <em>2009</em>), which does <em>not</em> call for these additional overloads. Consequently, it's harsh to blame VC++ <em>too</em> much here...</p>\n<p>In any case, for only a handful of calls, there's nothing wrong with using a cast to resolve the ambiguity yourself:</p>\n<pre><code>void SentryManager::add(std::string&amp; name, std::shared_ptr&lt;Sentry&gt;) {\n    name += std::to_string(static_cast&lt;long long&gt;(counter));\n}\n</code></pre>\n<p>Or, if there's heavy usage of <code>std::to_string</code> in your codebase, write a few wrappers and use those instead \u2013 this way, no call-site casting is needed:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;string&gt;\n\ntemplate&lt;typename T&gt;\ninline typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value,\n                               std::string&gt;::type\nto_string(T const val) {\n    return std::to_string(static_cast&lt;long long&gt;(val));\n}\n\ntemplate&lt;typename T&gt;\ninline typename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value,\n                               std::string&gt;::type\nto_string(T const val) {\n    return std::to_string(static_cast&lt;unsigned long long&gt;(val));\n}\n\ntemplate&lt;typename T&gt;\ninline typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, std::string&gt;::type\nto_string(T const val) {\n    return std::to_string(static_cast&lt;long double&gt;(val));\n}\n\n// ...\n\nvoid SentryManager::add(std::string&amp; name, std::shared_ptr&lt;Sentry&gt;) {\n    name += to_string(counter);\n}\n</code></pre>\n<hr>\n<p>I can't check whether VC++ 2010 succeeds or fails with the above usage of SFINAE; if it fails, the following \u2014 using tag dispatch instead of SFINAE \u2014 should be compilable (if potentially less clear):</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;string&gt;\n\nnamespace detail {\n\ntemplate&lt;typename T&gt;\ninline std::string\nto_string(T const val, std::false_type /*is_float*/, std::false_type /*is_unsigned*/) {\n    return std::to_string(static_cast&lt;long long&gt;(val));\n}\n\ntemplate&lt;typename T&gt;\ninline std::string\nto_string(T const val, std::false_type /*is_float*/, std::true_type /*is_unsigned*/) {\n    return std::to_string(static_cast&lt;unsigned long long&gt;(val));\n}\n\ntemplate&lt;typename T, typename _&gt;\ninline std::string\nto_string(T const val, std::true_type /*is_float*/, _) {\n    return std::to_string(static_cast&lt;long double&gt;(val));\n}\n\n} // namespace detail\n\ntemplate&lt;typename T&gt;\ninline std::string to_string(T const val) {\n    return detail::to_string(val, std::is_floating_point&lt;T&gt;(), std::is_unsigned&lt;T&gt;());\n}\n</code></pre>\n</hr>", "LastEditorUserId": "636019", "LastActivityDate": "2017-06-21T14:29:15.047", "Score": "76", "CreationDate": "2012-05-19T15:51:53.617", "ParentId": "10664699", "CommentCount": "7", "OwnerUserId": "636019", "LastEditDate": "2017-06-21T14:29:15.047"}, "10666740": {"Id": "10666740", "PostTypeId": "2", "Body": "<p>You have tripped over <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1261\" rel=\"noreferrer\">C++ DR 1261</a>, which reads in part</p>\n<blockquote>\n<p id=\"so_10664699_10666740_0\">The code \"<code>int i; to_string(i);</code>\" fails to compile, as '<code>int</code>' is ambiguous between '<code>long long</code>' and '<code>long long unsigned</code>'. It seems unreasonable to expect users to cast numbers up to a larger type just to use <code>to_string</code>.</p>\n</blockquote>\n<p>The proposed resolution is to add more overloads.  <a href=\"http://gcc.gnu.org/ml/libstdc++/2009-11/msg00030.html\" rel=\"noreferrer\">GCC has implemented this already</a>; I guess MSVC hasn't.</p>\n", "LastActivityDate": "2012-05-19T15:57:18.680", "CommentCount": "1", "CreationDate": "2012-05-19T15:57:18.680", "ParentId": "10664699", "Score": "9", "OwnerUserId": "388520"}, "10664699": {"ViewCount": "40349", "Body": "<p><code>counter</code> is an <code>int</code></p>\n<pre><code>void SentryManager::add(std::string name,std::shared_ptr&lt;Sentry&gt;){\n    name = name + std::to_string(counter);\n}\n</code></pre>\n<p>What would be the best way to stop this error? When I was being lazy I just made the int <code>long long</code> (or something), but I'm sure there is a better way of solving this.</p>\n<p>Error message:</p>\n<pre><code>sentrymanager.cpp(8): error C2668: 'std::to_string' : ambiguous call to overloaded function\n</code></pre>\n<p>I am using Visual C++ 2010 Express.</p>\n", "AcceptedAnswerId": "10666695", "Title": "std::to_string - more than instance of overloaded function matches the argument list", "CreationDate": "2012-05-19T11:16:07.613", "Id": "10664699", "CommentCount": "2", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2012-05-19T15:50:16.533", "LastEditorUserId": "636019", "LastActivityDate": "2017-06-21T14:29:15.047", "Score": "46", "OwnerUserId": "1870451", "Tags": "<c++><visual-studio-2010><visual-c++><c++11>", "AnswerCount": "2"}});