post_cb({"4860178": {"PostTypeId": "2", "Body": "<p>It is entirely acceptable for <code>ptrdiff_t</code> to be the same size as pointer types, provided the overflow semantics are defined by the compiler so that any difference is still representable. There is no guarantee that a negative ptrdiff_t means that the second pointer lives at a lower address in memory than the first, or that ptrdiff_t is signed at all.</p>\n", "LastActivityDate": "2011-02-01T07:56:30.327", "Id": "4860178", "CommentCount": "12", "CreationDate": "2011-02-01T07:56:30.327", "ParentId": "4860086", "Score": "1", "OwnerUserId": "613064"}, "4860176": {"PostTypeId": "2", "Body": "<p>No, because there is no such thing as the difference between \"any two pointers\". You can only subtract pointers to elements of the same array (or the pointer to the location just past the end of an array).</p>\n", "LastActivityDate": "2011-02-01T07:56:27.137", "Id": "4860176", "CommentCount": "7", "CreationDate": "2011-02-01T07:56:27.137", "ParentId": "4860086", "Score": "8", "OwnerUserId": "379897"}, "4860086": {"ViewCount": "1617", "Body": "<p>I've always wondered: isn't <code>ptrdiff_t</code> supposed to be able to hold the difference of any two pointers <em>by definition</em>? How come it fails when the two pointers are too far? (I'm not pointing at any particular language... I'm referring to all languages which have this type.)</p>\n<p>(e.g. subtract the pointer with address <code>1</code> from the byte pointer with address <code>0xFFFFFFFF</code> when you have 32-bit pointers, and it overflows the sign bit...)</p>\n", "AcceptedAnswerId": "4860140", "Title": "ptrdiff_t too small?", "CreationDate": "2011-02-01T07:43:36.140", "Id": "4860086", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-05-17T14:18:51.630", "Score": "17", "OwnerUserId": "541686", "Tags": "<c++><c><d>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4860086_4860140_0": {"length": 113, "quality": 0.9338842975206612, "section_id": 6143}}, "n3337": {"so_4860086_4860140_0": {"length": 113, "quality": 0.9338842975206612, "section_id": 5907}}}, "7908524": {"PostTypeId": "2", "Body": "<p>To add a more explicit standard quote, <code>ISO 9899:1999 \u00a7J.2/1</code> states:</p>\n<blockquote>\n<p id=\"so_4860086_7908524_0\">The behavior is undefined in the following circumstances:</p>\n<p id=\"so_4860086_7908524_1\">[...]</p>\n<p id=\"so_4860086_7908524_2\">-- The result of subtracting two pointers is not representable in an object of type\n  ptrdiff_t (6.5.6).</p>\n</blockquote>\n", "LastActivityDate": "2011-10-26T20:29:48.610", "Id": "7908524", "CommentCount": "0", "CreationDate": "2011-10-26T20:29:48.610", "ParentId": "4860086", "Score": "2", "OwnerUserId": "273767"}, "4860140": {"Id": "4860140", "PostTypeId": "2", "Body": "<p>No, it is not.</p>\n<blockquote>\n<p id=\"so_4860086_4860140_0\"><strong>$5.7 [expr.add]</strong> (from n3225 - C++0x FCD)<br>\n  When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of the two array elements. The type of the result is an implementation-defined signed integral type; this type shall be the same type that is defined as <code>std::ptrdiff_t</code> in the <code>&lt;cstddef&gt;</code> header (18.2). As with any other arithmetic overflow, if the result does not fit in the space provided, the behavior is undefined.\n  In other words, if the expressions <code>P</code> and <code>Q</code> point to, respectively, the <code>i</code>-th and <code>j</code>-th elements of an array object, the expression <code>(P)-(Q)</code> has the value <code>i \u2212 j</code> provided the value fits in an object of type <code>std::ptrdiff_t</code>. Moreover, if the expression <code>P</code> points either to an element of an array object or one past the last element of an array object, and the expression <code>Q</code> points to the last element of the same array object, the expression <code>((Q)+1)-(P)</code> has the same value as <code>((Q)-(P))+1</code> and as <code>-((P)-((Q)+1))</code>, and has the value zero if the expression <code>P</code> points one past the last element of the array object, even though the expression <code>(Q)+1</code> does not point to an element of the array object. Unless both pointers point to elements of the same array object, or one past the last element of the array object, the behavior is undefined.</br></p>\n</blockquote>\n<p>Note the number of times <code>undefined</code> appears in the paragraph. Also note that you can only subtract pointers if they point within the same object.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2011-02-01T18:41:50.077", "CommentCount": "16", "CreationDate": "2011-02-01T07:51:23.240", "ParentId": "4860086", "Score": "28", "OwnerUserId": "147192", "LastEditDate": "2011-02-01T18:41:50.077"}, "16611346": {"PostTypeId": "2", "Body": "<p>Over/underflow is mathematically well-defined for fixed-size integer arithmetic:</p>\n<pre><code>(1 - 0xFFFFFFFF) % (1&lt;&lt;32) =\n(1 + -0xFFFFFFFF) % (1&lt;&lt;32) =\n1 + (-0xFFFFFFFF % (1&lt;&lt;32)) = 2\n</code></pre>\n<p>This <em>is</em> the correct result!</p>\n<p>Specifically, the result after over/underflow is an alias of the correct integer. In fact, every non-representable integer is aliased (undistinguishable) with one representable integer \u2014 count to infinity in fixed-size integers, and you will repeat yourself, round and round like a dial of an analog clock.</p>\n<p>An N-bit integer represents any real integer modulo 2^N. In C, modulo 2^N is written as %(1&lt;&lt;32).</p>\n<p>I believe C guarrantees mathematical correctness of over/underflow, but only for unsigned integers. Signed under/overflow is assumed to never happen (for the sake of optimization).</p>\n<p>In practice, signed integers are two's complement, which makes no difference in addition or subtraction, so correct under/overflow behavior is guarranteed for signed integers too (although not by C).</p>\n", "LastActivityDate": "2013-05-17T14:18:51.630", "Id": "16611346", "CommentCount": "2", "CreationDate": "2013-05-17T14:18:51.630", "ParentId": "4860086", "Score": "-1", "OwnerUserId": "2394284"}});