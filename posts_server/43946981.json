post_cb({"43950340": {"Id": "43950340", "PostTypeId": "2", "Body": "<p>Refering to \u00a71.8 of the c++ standard (N4618), an object:</p>\n<ol>\n<li><p>occupies a <strong>region of storage</strong> during its <em>period of construction</em>, through its <em>lifetime</em> and its <em>period of destruction</em>;</p></li>\n<li><p>has a <strong>lifetime</strong> (for non trivial objects it start when initialization is completed and stop when the destructor starts);</p></li>\n<li><p>has a <strong>storage duration</strong> (static, dynamic, thread or automatic)</p></li>\n<li><p>has a <strong>type</strong>: the <em>object type</em> which is unique (strict aliasing).</p></li>\n<li><p><em>may</em> have a <strong>name</strong></p></li>\n</ol>\n<hr>\n<h3>About object type</h3>\n<p>(Other answers already have detailed the meaning of storage duration.)</p>\n<p>The <em>object type</em> (or class) is a unique property of an object. The <em>object type</em> specifies the meaning of the region of storage occupied by the initialized object. So the meaning is unique, from a philosophical point of view, the <em>object type</em> is the species of the object, not its kind.</p>\n<p>For the <strong>compiler</strong>, it only constrains the ensemble of operation that can be applied to the region of storage: the methods associated to the object type (in which case the type is defined by <code>class</code> or <code>struct</code>), and all the functions taking the object as an argument (which are visible).</p>\n<p>For the <strong>programmer</strong>, the type also specifies what will be the consequences of the application of a sequence of operations to the object during its <em>lifetime</em>. The type contains much more information than the compiler actualy may be able to know. For exemple after having checked that the size of an object, <code>an_obj</code> of type <code>std::vector&lt;int&gt;</code> is <code>0</code>, the programmer knows that <code>an_obj.at(0)</code> will always throw, the compiler may not.</p>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2017-05-13T07:23:00.627", "Score": "4", "CreationDate": "2017-05-13T07:16:33.240", "ParentId": "43946981", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2017-05-13T07:23:00.627"}, "43947251": {"Id": "43947251", "PostTypeId": "2", "Body": "<p>Not to bash on the existing answers, but they're missing an element (that's arguably a standard defect).</p>\n<blockquote>\n<p id=\"so_43946981_43947251_0\">An <em>object</em> is a region of storage. [ <em>Note:</em> A function is not an object, regardless of whether or not it occupies storage in the way that objects do.  \u2014 <em>end note</em> ]</p>\n<p id=\"so_43946981_43947251_1\">An object is created by a <em>definition</em> ([basic.def]), by a <em>new-expression</em> ([expr.new]) or by the implementation ([class.temporary]) when needed.</p>\n<p id=\"so_43946981_43947251_2\">The properties of an object are determined when the object is created.</p>\n</blockquote>\n<p>An object is a region of storage <em>in which constuction has taken place</em>. In fact, most of the time \"object\" refers to that constructed entity, with its value and state, whereas \"storage\" just means the memory (or whatever) it is written on.</p>\n<p>The difference can be a simple detail:</p>\n<pre><code>// `s` names an object that has been constructed... somewhere.\n// That storage will live exactly as long as necessary to back `s`\n// as long as the object exists -- no need to worry about it.\nstd::string s = \"hello\";\n\n// Using the object\nstd::cout &lt;&lt; s &lt;&lt; '\\n';\n</code></pre>\n<p>But you can also (although it's very rarely useful) separate the object's lifetime from the lifetime of its storage:</p>\n<pre><code>// `storage` points at a chunk of... storage.\n// It hasn't been initialized, nor does it have a type.\nvoid *storage = malloc(sizeof(std::string));\n\n// Now we constructed an `std::string`:\n// we have an actual object inhabiting the storage!\nstd::string *s = new (storage) std::string(\"hello\");\n\n// Using the object, through the pointer we have\nstd::cout &lt;&lt; *s &lt;&lt; '\\n';    \n\n// Now we destruct the object: it exists no more.\ns-&gt;~basic_string();\n\n// Now we destroy the storage.\nfree(storage);\n</code></pre>\n<p>I must stress that this last example is for demonstration purposes only. It's a technique you probably won't encounter, and has been performed here with no error checking whatsoever. Don't try this at home :)</p>\n<p>Now, how does it relate to the OOP \"object\"? Well... not at all. \"Object\" is a <em>very</em> generic term, and OOP founders just chose to use it as well, independently.</p>\n", "LastEditorUserId": "3233393", "LastActivityDate": "2017-05-12T22:28:02.923", "Score": "6", "CreationDate": "2017-05-12T22:23:29.273", "ParentId": "43946981", "CommentCount": "8", "OwnerUserId": "3233393", "LastEditDate": "2017-05-12T22:28:02.923"}, "43947289": {"Id": "43947289", "PostTypeId": "2", "Body": "<p>In C++ world, an object is the instantiation of a class. It behaves (methods/functions) in certain ways and has attributes (data members) that depicts its state.</p>\n<p>An object has lifetime. It is created (through constructor), it lives, and it dies (through destructor).</p>\n<p>A class is like a blueprint, through which you define the behavior and attribute of an object.</p>\n", "LastActivityDate": "2017-05-12T22:26:38.063", "CommentCount": "1", "CreationDate": "2017-05-12T22:26:38.063", "ParentId": "43946981", "Score": "-3", "OwnerUserId": "5683933"}, "bq_ids": {"n4140": {"so_43946981_43947251_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5790}, "so_43946981_43947032_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5790}, "so_43946981_43947251_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5790}, "so_43946981_43947251_1": {"length": 7, "quality": 0.7, "section_id": 5790}}, "n3337": {"so_43946981_43947251_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5563}, "so_43946981_43947251_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5563}, "so_43946981_43947032_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5563}, "so_43946981_43947251_1": {"length": 7, "quality": 0.7, "section_id": 5563}}, "n4659": {"so_43946981_43947251_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7247}, "so_43946981_43947251_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 7247}, "so_43946981_43947032_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7247}}}, "43947032": {"Id": "43947032", "PostTypeId": "2", "Body": "<p>The <code>C++11</code> standard is pretty clear:</p>\n<blockquote>\n<p id=\"so_43946981_43947032_0\"><strong>1.8</strong> The C ++ object model <strong>[</strong> intro.object <strong>]</strong></p>\n<p id=\"so_43946981_43947032_1\">An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. \u2014 end note ]</p>\n</blockquote>\n<p>That's it. An object is a chunk of memory in which data can be stored.</p>\n<p>If you think about it <strong>OO</strong> or <strong>O</strong>bject <strong>O</strong>rientation makes more sense when you realize that in the old days the programs were organized around the functions which operated upon the objects (or data).</p>\n<p>The term \"object\" was around <em>long</em> before <em>object orientation</em>.</p>\n<p>What <em>object orientation</em> did was change the program organization from being organized around the functions to being organized around the data itself - the <em>objects</em>.</p>\n<p>Hence the term <strong>object orientated</strong>. </p>\n<p><strong>Change of paradigm</strong>.</p>\n<p>Here we see the paradigm shift from the old days:</p>\n<pre><code>struct my_object\n{\n    int i;\n    char s[20];\n};\n\nvoid function(my_object* o)\n{\n    // function operates on the object (procedural / procedure oriented)\n}\n</code></pre>\n<p>To what we have now:</p>\n<pre><code>struct my_object\n{\n    void function()\n    {\n        // object operates on itself (Object Oriented)\n    }\n\n    int i;\n    char s[20];\n};\n</code></pre>\n", "LastEditorUserId": "3807729", "LastActivityDate": "2017-05-12T22:18:56.250", "Score": "7", "CreationDate": "2017-05-12T21:59:58.527", "ParentId": "43946981", "CommentCount": "9", "OwnerUserId": "3807729", "LastEditDate": "2017-05-12T22:18:56.250"}, "43946981": {"ViewCount": "453", "Body": "<p>In the beginning of my journey learning C++, I thought an object is an OOP-only related term. However, the more I learn and the more I read, I can see that this not the case, and I can find that the term \"object\" has a more generalized meaning. I read a lot of materials on the net, but I could not yet find something clear/solid. May be I could not get to the correct place. I could get the standards and it has good paragraphs about this, but as you may know standard language is a bit difficult. and the information usually too scattered.</p>\n<p>My question: would you please show me in a simple English <strong>What is an object in C++ outside the OOP world?</strong> or at least point me where I can find something good, concrete and simple to read about this.  </p>\n<p><strong>AND Please if you downvote leave a comment. This is also a source to learn</strong> </p>\n", "AcceptedAnswerId": "43947032", "Title": "What is exactly an object in C++?", "CreationDate": "2017-05-12T21:54:23.560", "Id": "43946981", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-12T21:59:02.063", "LastEditorUserId": "7972961", "LastActivityDate": "2017-05-13T07:23:00.627", "Score": "10", "OwnerUserId": "7972961", "Tags": "<c++><object>", "AnswerCount": "5"}, "43947112": {"Id": "43947112", "PostTypeId": "2", "Body": "<h3>Short answer</h3>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/n3337/intro.object\" rel=\"noreferrer\">https://timsong-cpp.github.io/cppwp/n3337/intro.object</a></p>\n<blockquote>\n<p id=\"so_43946981_43947112_0\">An object is a region of storage.</p>\n</blockquote>\n<hr>\n<h3>A slightly longer answer</h3>\n<p>In traditional OOP and OOD, an Object is used to describe class of objects some times and to an instance of a class some times.</p>\n<p>In C++, <code>class</code> and <code>struct</code> represent classes.</p>\n<p>An object in C++ can be an instance of a <code>class</code> or a <code>struct</code> but it can also be an instance of a fundamental type.</p>\n<p><strong>A few simple examples:</strong></p>\n<pre><code>int i;\n</code></pre>\n<p><code>i</code> is an object. It is associated with a region of storage that can be used by the program.</p>\n<pre><code>struct foo { int a; int b;};\nfoo f;\n</code></pre>\n<p><code>f</code> is an also object. It is also associated with a region of storage that can be used by the program.</p>\n<pre><code>int* ptr = new int[200];\n</code></pre>\n<p><code>ptr</code> is a pointer that points to 200 objects of type <code>int</code>. Those objects are also associated with a region of storage that can be used by the program.</p>\n</hr>", "LastEditorUserId": "434551", "LastActivityDate": "2017-05-12T22:16:30.410", "Score": "6", "CreationDate": "2017-05-12T22:08:01.053", "ParentId": "43946981", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2017-05-12T22:16:30.410"}});