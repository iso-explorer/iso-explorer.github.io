post_cb({"25858423": {"ParentId": "25847349", "CommentCount": "0", "Body": "<p>My read is that this is required to work by the C++ standard; however if you're trying to use this for multithreading control, it doesn't work in that context because there is nothing here to guarantee the registers get written to memory in the right order.</p>\n<p>As your edit indicates, you are trying to use it exactly where it will not work.</p>\n", "OwnerUserId": "14768", "PostTypeId": "2", "Id": "25858423", "Score": "1", "CreationDate": "2014-09-15T23:26:19.270", "LastActivityDate": "2014-09-15T23:26:19.270"}, "25849109": {"ParentId": "25847349", "CommentCount": "0", "Body": "<p>Since A = a; and B = b; are independent in terms of data dependencies, this should not matter. If there was an output/outcome of previous instruction affecting the subsequent instruction's input, then ordering matters, otherwise not. this is strictly sequential execution normally.</p>\n", "OwnerUserId": "2032021", "PostTypeId": "2", "Id": "25849109", "Score": "1", "CreationDate": "2014-09-15T13:20:41.423", "LastActivityDate": "2014-09-15T13:20:41.423"}, "25873781": {"ParentId": "25847349", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It may be of interest that if you do this:</p>\n<pre><code>{ A=a, B=b; /*etc*/ }\n</code></pre>\n<p>Note the comma in place of the semi-colon.</p>\n<p>Then the C++ specification and any confirming compiler will have to guarantee the execution order because operands of the comma operator are always evaluated left to right.\nThis can indeed be used to prevent the optimizer from subverting your thread synchronization by reordering. The comma effectively becomes a barrier across which reordering is not allowed.</p>\n", "OwnerUserId": "4047190", "LastEditorUserId": "1708801", "LastEditDate": "2014-09-16T17:12:23.040", "Id": "25873781", "Score": "0", "CreationDate": "2014-09-16T16:18:48.483", "LastActivityDate": "2014-09-16T17:12:23.040"}, "25847349": {"CommentCount": "12", "AcceptedAnswerId": "25847384", "PostTypeId": "1", "LastEditorUserId": "3881143", "CreationDate": "2014-09-15T11:46:06.037", "LastActivityDate": "2014-12-02T14:32:50.567", "LastEditDate": "2014-09-15T13:05:00.380", "ViewCount": "3613", "FavoriteCount": "12", "Title": "For { A=a; B=b; }, will \"A=a\" be strictly executed before \"B=b\"?", "Id": "25847349", "Score": "48", "Body": "<p>Suppose <code>A</code>, <code>B</code>, <code>a</code>, and <code>b</code> are all variables, and the addresses of <code>A</code>, <code>B</code>, <code>a</code>, and <code>b</code> are all different. Then, for the following code:</p>\n<pre><code>A = a;\nB = b;\n</code></pre>\n<p>Do the C and C++ standard explicitly require <code>A=a</code> be strictly executed before <code>B=b</code>? Given that the addresses of <code>A</code>, <code>B</code>, <code>a</code>, and <code>b</code> are all different, are compilers allowed to swap the execution sequence of two statements for some purpose such as optimization?</p>\n<p>If the answer to my question is different in C and C++, I would like to know both.</p>\n<p>Edit: The background of the question is the following. In board game AI design, for optimization people use <a href=\"https://chessprogramming.wikispaces.com/Shared+Hash+Table\">lock-less shared-hash table</a>, whose correctness strongly depends on the execution order if we do not add <code>volatile</code> restriction.</p>\n", "Tags": "<c++><c><optimization><compiler-construction><standards>", "OwnerUserId": "3881143", "AnswerCount": "6"}, "25847445": {"ParentId": "25847349", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The compiler is only obligated to emulate the observable behavior of a program, so if a re-ordering would not violate that principle then it would be allowed. Assuming the behavior is well defined, if your program contains <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> such as a data race then the behavior of the program will be unpredictable and as commented would require use of some form of synchronization to protect the critical section. </p>\n<p><b>A Useful reference</b></p>\n<p>An interesting article that covers this is <a href=\"http://preshing.com/20120625/memory-ordering-at-compile-time/\" rel=\"nofollow\">Memory Ordering at Compile Time</a> and it says:</p>\n<blockquote>\n<p id=\"so_25847349_25847445_0\">The cardinal rule of memory reordering, which is universally followed\n  by compiler developers and CPU vendors, could be phrased as follows:</p>\n<blockquote>\n<p id=\"so_25847349_25847445_2\"><em>Thou shalt not modify the behavior of a single-threaded program.</em></p>\n</blockquote>\n</blockquote>\n<p><b>An Example</b></p>\n<p>The article provides a simple program where we can see this reordering:</p>\n<pre><code>int A, B;  // Note: static storage duration so initialized to zero\n\nvoid foo()\n{\n    A = B + 1;\n    B = 0;\n}\n</code></pre>\n<p>and shows at higher optimization levels <code>B = 0</code> is done before <code>A = B + 1</code>, and we can reproduce this result using <a href=\"http://gcc.godbolt.org/#\" rel=\"nofollow\">godbolt</a>, which while using <code>-O3</code> produces the following (<em><a href=\"http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%2C%22colouriseAsm%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22AQ4SwOwF2BBAaYAhA3AKDaYA3A9mAE2ADNdcAKASk1AG8asRZgBeZYAamAEZ1HQkrYAAY%2BoAL5AAAA%3D%3D%22%2C%22compiler%22%3A%22%2Fopt%2Fgcc-4.9.0%2Fbin%2Fg%2B%2B%22%2C%22options%22%3A%22-x%20c%20-std%3Dc99%20-O3%20-fverbose-asm%20-fno-inline-small-functions%22%7D%5D%7D\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>movl    $0, B(%rip) #, B\naddl    $1, %eax    #, D.1624\n</code></pre>\n<p><b>Why?</b></p>\n<p>Why does the compiler reorder? The article explains it is exactly the same reason the processor does so, because of complexity of the architecture:</p>\n<blockquote>\n<p id=\"so_25847349_25847445_3\">As I mentioned at the start, the compiler modifies the order of memory\n  interactions for the same reason that the processor does it \u2013\n  performance optimization. Such optimizations are a direct consequence\n  of modern CPU complexity.</p>\n</blockquote>\n<p><b>Standards</b></p>\n<p>In the draft C++ standard this is covered in section <code>1.9</code> <em>Program execution</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_25847349_25847445_4\">The semantic descriptions in this International Standard define a\n  parameterized nondeterministic abstract machine. This International\n  Standard places no requirement on the structure of conforming\n  implementations. In particular, they need not copy or emulate the\n  structure of the abstract machine. <strong>Rather, conforming implementations\n  are required to emulate (only) the observable behavior of the abstract\n  machine</strong> as explained below.<sup>5</sup></p>\n</blockquote>\n<p>footnote <code>5</code> tells us this is also known as the <em>as-if rule</em>:</p>\n<blockquote>\n<p id=\"so_25847349_25847445_5\">This provision is sometimes called the <strong>\u201cas-if\u201d rule</strong>, because an\n  implementation is <strong>free to disregard any requirement</strong> of this\n  International Standard <strong>as long as the result is as if the requirement\n  had been obeyed, as far as can be determined from the observable\n  behavior</strong> of the program. For instance, an actual implementation need\n  not evaluate part of an expression if it can deduce that its value is\n  not used and that no side effects affecting the observable behavior of\n  the program are produced.</p>\n</blockquote>\n<p>the draft C99 and draft C11 standard covers this in section <code>5.1.2.3</code> <em>Program execution</em> although we have to go to the index to see that it is called the <em>as-if rule</em> in the C standard as well:</p>\n<blockquote>\n<p id=\"so_25847349_25847445_6\">as\u2212if rule, 5.1.2.3</p>\n</blockquote>\n<p><b>Update on Lock-Free considerations</b></p>\n<p>The article <a href=\"http://preshing.com/20120612/an-introduction-to-lock-free-programming/\" rel=\"nofollow\">An Introduction to Lock-Free Programming</a> covers this topic well and for the OPs concerns on <em>lock-less shared-hash table</em> implementation this section is probably the most relevant:</p>\n<blockquote>\n<p id=\"so_25847349_25847445_7\"><strong>Memory Ordering</strong></p>\n<p id=\"so_25847349_25847445_8\">As the flowchart suggests, any time you do lock-free programming for\n  multicore (or any <a href=\"http://en.wikipedia.org/wiki/Symmetric_multiprocessing\" rel=\"nofollow\">symmetric multiprocessor</a>), and your environment does\n  not guarantee sequential consistency, you must consider how to prevent\n  <a href=\"http://preshing.com/20120515/memory-reordering-caught-in-the-act/\" rel=\"nofollow\">memory reordering</a>.</p>\n<p id=\"so_25847349_25847445_9\">On today\u2019s architectures, the tools to enforce correct memory ordering\n  generally fall into three categories, which prevent both <a href=\"http://preshing.com/20120625/memory-ordering-at-compile-time/\" rel=\"nofollow\">compiler\n  reordering</a> and <a href=\"http://preshing.com/20120710/memory-barriers-are-like-source-control-operations/\" rel=\"nofollow\">processor reordering</a>:</p>\n<ul>\n<li>A lightweight sync or fence instruction, which I\u2019ll talk about in <a href=\"http://preshing.com/20120913/acquire-and-release-semantics/\" rel=\"nofollow\">future posts</a>;</li>\n<li>A full memory fence instruction, which I\u2019ve <a href=\"http://preshing.com/20120522/lightweight-in-memory-logging/\" rel=\"nofollow\">demonstrated previously</a>;</li>\n<li>Memory operations which provide acquire or release semantics.</li>\n</ul>\n<p id=\"so_25847349_25847445_10\">Acquire semantics prevent memory reordering of operations which follow\n  it in program order, and release semantics prevent memory reordering\n  of operations preceding it. These semantics are particularly suitable\n  in cases when there\u2019s a producer/consumer relationship, where one\n  thread publishes some information and the other reads it. I\u2019ll also\n  talk about this more in a future post.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "5801", "LastEditDate": "2014-12-02T14:32:50.567", "Id": "25847445", "Score": "25", "CreationDate": "2014-09-15T11:51:42.537", "LastActivityDate": "2014-12-02T14:32:50.567"}, "25847433": {"ParentId": "25847349", "CommentCount": "0", "Body": "<p>If there is no dependency of instructions, these may be executed out of order also if final outcome is not affected. You can observe this while debugging a code compiled at higher optimization level.</p>\n", "OwnerUserId": "2659313", "PostTypeId": "2", "Id": "25847433", "Score": "3", "CreationDate": "2014-09-15T11:50:47.383", "LastActivityDate": "2014-09-15T11:50:47.383"}, "bq_ids": {"n4140": {"so_25847349_25847445_5": {"section_id": 5797, "quality": 0.9285714285714286, "length": 39}, "so_25847349_25847445_4": {"section_id": 5797, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_25847349_25847445_5": {"section_id": 5570, "quality": 0.9285714285714286, "length": 39}, "so_25847349_25847445_4": {"section_id": 5570, "quality": 0.8648648648648649, "length": 32}}, "n4659": {"so_25847349_25847445_5": {"section_id": 7256, "quality": 0.9285714285714286, "length": 39}, "so_25847349_25847445_4": {"section_id": 7256, "quality": 0.8648648648648649, "length": 32}}}, "25847384": {"ParentId": "25847349", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Both standards allow for these instructions to be performed out of order, so long as that does not change observable behaviour. This is known as the as-if rule:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule\">What exactly is the \"as-if\" rule?</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/as_if</a></li>\n</ul>\n<p>Note that as is pointed out in the comments, what is meant by \"observable behaviour\" is the observable behaviour of a program with defined behaviour. If your program has undefined behaviour, then the compiler is excused from reasoning about that.</p>\n", "OwnerUserId": "505088", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:06.330", "Id": "25847384", "Score": "54", "CreationDate": "2014-09-15T11:48:12.187", "LastActivityDate": "2014-09-15T21:25:26.840"}});