post_cb({"9467868": {"ViewCount": "785", "Body": "<p>I was wondering about an initialization of the following form:</p>\n<pre><code>int  array[] = {\nv - 1,\narray[0] + 1\n} ;\n</code></pre>\n<p>In the initialization of the second element, the value of the first is used, but the entire array is not yet initialized.  This happens to compile with g++, but I was unsure whether this is actually portable and a well defined construct?</p>\n", "AcceptedAnswerId": "9468380", "Title": "Can a (C/C++) array initialization reference itself?", "CreationDate": "2012-02-27T15:47:13.860", "Id": "9467868", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2012-02-27T16:02:12.930", "LastEditorUserId": "505088", "LastActivityDate": "2014-05-01T00:01:47.227", "Score": "30", "OwnerUserId": "189270", "Tags": "<c++>", "AnswerCount": "4"}, "9468380": {"Id": "9468380", "PostTypeId": "2", "Body": "<p>See 3.3.2 Point of declaration:</p>\n<blockquote>\n<p id=\"so_9467868_9468380_0\">The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its\n  initializer (if any), except as noted below. [ Example:</p>\n</blockquote>\n<pre><code>int x = 12;\n{ int x = x; }\n</code></pre>\n<blockquote>\n<p id=\"so_9467868_9468380_1\">Here the second x is initialized with its own (indeterminate) value. \u2014end example ]</p>\n</blockquote>\n<p>So you are referring to the array correctly, its name is known after the <code>=</code>.</p>\n<p>Then, 8.5.1 Aggregates:</p>\n<blockquote>\n<p id=\"so_9467868_9468380_2\">An aggregate is an array or a class [...]</p>\n<p id=\"so_9467868_9468380_3\">17: The full-expressions in an initializer-clause are evaluated in the order in which they appear.</p>\n</blockquote>\n<p>However, I see no reference to when the evaluated values are actually written into the array, so I wouldn't rely on this and would even go so far to declare your code as not well defined.</p>\n", "LastEditorUserId": "76722", "LastActivityDate": "2012-02-27T17:18:58.917", "Score": "16", "CreationDate": "2012-02-27T16:21:03.110", "ParentId": "9467868", "CommentCount": "0", "OwnerUserId": "76722", "LastEditDate": "2012-02-27T17:18:58.917"}, "9468915": {"Id": "9468915", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9467868_9468915_0\">Can a (C/C++) array initialization reference itself?</p>\n</blockquote>\n<p>This is also valid C code.</p>\n<p>C has some correspondent paragraph (emphasis mine). </p>\n<blockquote>\n<p id=\"so_9467868_9468915_1\">(C99, 6.2.1p7) \"Structure, union, and enumeration tags have scope that begins just after the appearance of the tag in a type specifier that declares the tag. Each enumeration constant has scope that begins just after the appearance of its defining enumerator in an enumerator list. <strong>Any other identifier has scope that begins just after the completion of its declarator.</strong>\"</p>\n</blockquote>\n", "LastActivityDate": "2012-02-27T16:56:46.417", "CommentCount": "0", "CreationDate": "2012-02-27T16:56:46.417", "ParentId": "9467868", "Score": "1", "OwnerUserId": "1119701"}, "bq_ids": {"n4140": {"so_9467868_9468380_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 3326}, "so_9467868_9468380_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7049}, "so_9467868_9468380_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7049}}, "n3337": {"so_9467868_9468380_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6794}, "so_9467868_9468380_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 3196}, "so_9467868_9468380_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6794}}, "n4659": {"so_9467868_9468380_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 8546}, "so_9467868_9468380_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 4092}, "so_9467868_9468380_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 8546}}}, "9468293": {"Id": "9468293", "PostTypeId": "2", "Body": "<p>As far as I can see, this is <em>not</em> well defined. The standard (C++11, 8.5.1/17) specifies that \"The <em>full-expressions</em> in an <em>initializer-clause</em> are evaluated in the order in which they appear\", but I can't see anything that requires each aggregate element to be initialised from the result of its <em>initializer-clause</em> before the next is evaluated.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2012-02-27T19:15:00.473", "Score": "13", "CreationDate": "2012-02-27T16:15:31.600", "ParentId": "9467868", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2012-02-27T19:15:00.473"}, "23400057": {"Id": "23400057", "PostTypeId": "2", "Body": "<p>I think this is handled by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1343\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1343</a> . Initially my report was only about non-class initializers for namespace scope objects (see <a href=\"https://stackoverflow.com/questions/5760866/when-exactly-is-an-initializer-temporary-destroyed\">When exactly is an initializer temporary destroyed?</a>), but the problem exists for aggregate elements just aswell if they are non-class. And as the additional recent note explains, even seems to exist for the entire aggregate initialization aswell, even if it is a class object, because then no constructor call happens that would enlargen the full-expression of the initializer. </p>\n<p>If instead of <code>int</code> you would have used a class, and the initialization would be a constructor call, then that constructor call would be part of the same full expression that encloses the aggregate-ininitializer element, so that here the order would be OK and your code would be well-defined.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2014-05-01T00:01:47.227", "Score": "0", "CreationDate": "2014-04-30T23:56:44.023", "ParentId": "9467868", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2014-05-01T00:01:47.227"}});