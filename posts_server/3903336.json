post_cb({"3903349": {"LastActivityDate": "2010-10-11T03:34:17.660", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_3903336_3903349_0\">The Standard talks about <code>-&gt;</code> and <code>.</code> but not about <code>::</code>.</p>\n</blockquote>\n<p>The scope resolution operator (<code>::</code>) is part of the <em>qualified-id</em> referred to by \"or after <em>nested-name-specifier</em> in a <em>qualified-id</em>.\"</p>\n<p>The additional verbiage in C++0x is part of the resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#224\" rel=\"noreferrer\">CWG defect 224</a>.  Effectively, the definition of dependent names has been changed:</p>\n<blockquote>\n<p id=\"so_3903336_3903349_1\">The decision on whether a name is dependent or non-dependent should be based on lookup, not on the form of the name: if the name can be looked up in the definition context and cannot be anything else as the result of specialization, the name should be non-dependent.</p>\n</blockquote>\n", "CreationDate": "2010-10-11T03:26:50.843", "LastEditDate": "2010-10-11T03:34:17.660", "ParentId": "3903336", "Id": "3903349", "LastEditorUserId": "151292", "PostTypeId": "2", "Score": "6", "OwnerUserId": "151292"}, "bq_ids": {"n4140": {"so_3903336_3903336_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}, "so_3903336_3903336_1": {"length": 25, "quality": 0.625, "section_id": 72}}, "n3337": {"so_3903336_3903336_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}, "so_3903336_3903336_1": {"length": 25, "quality": 0.625, "section_id": 67}}}, "3903437": {"LastActivityDate": "2010-10-11T04:15:24.710", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3903336_3903437_0\">Can someone give an example to illustrate what \"but does not refer to a member of the current instantiation\" means in context of C++0x?</p>\n</blockquote>\n<p>I don't know if this is something that in fact behaves differently between an implementation of C++03 and C++0x.</p>\n<pre><code>template&lt; typename Q &gt;\nstruct A {\n    template&lt; typename T &gt;\n    void f( T );\n\n    void g() {\n        this-&gt;f&lt; Q &gt;( 5 ); // member of current instantiation is not ambiguous\n\n        A&lt; identity&lt;Q&gt; &gt;().template f&lt; 5 &gt;(); // suppose A is partially \n// specialized on identity. Legal but confusing; need help from template keyword.\n    }\n};\n</code></pre>\n", "CreationDate": "2010-10-11T04:02:29.193", "LastEditDate": "2010-10-11T04:15:24.710", "ParentId": "3903336", "Id": "3903437", "LastEditorUserId": "153285", "PostTypeId": "2", "Score": "3", "OwnerUserId": "153285"}, "3903336": {"CreationDate": "2010-10-11T03:22:19.107", "ViewCount": "810", "Id": "3903336", "AcceptedAnswerId": "3903349", "Score": "4", "Title": "Scope resolution operator and dependent name", "CommentCount": "0", "Body": "<p>I have the following test code</p>\n<pre><code>#include &lt;iostream&gt;\ntemplate &lt;typename T&gt;\n\nstruct PS\n{\n   template &lt;typename U&gt;\n   static void foo()\n   {\n       std::cout&lt;&lt;\"Some test code\";\n   }\n};\n\ntemplate &lt;typename T&gt;\nvoid bar()\n{\n   PS&lt;T&gt;::template foo&lt;T&gt;(); //won't compile without `::template`\n}\n\nint main()\n{\n   bar&lt;int&gt;();\n}\n</code></pre>\n<p>ISO C++03 <code>14.2/4</code>: says</p>\n<blockquote>\n<p id=\"so_3903336_3903336_0\">When the name of a member template specialization appears <strong>after . or -&gt;</strong> in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), the member <strong>template name must be prefixed by the keyword template. Otherwise the name is assumed to name a non-template</strong>.</p>\n</blockquote>\n<p>The Standard talks about <code>-&gt;</code> and <code>.</code> but not about <code>::</code>. Is it a defect in the C++03 Standard or am I missing something? Someone please enlighten me. </p>\n<p>However the wording has been changed in <code>N3126</code></p>\n<blockquote>\n<p id=\"so_3903336_3903336_1\">When the name of a member template specialization appears after <strong>. or -&gt;</strong> in a post\ufb01x-expression or after a nested-name-speci\ufb01er in a quali\ufb01ed-id, and the object or pointer expression of the post\ufb01x-expression or the nested-name-speci\ufb01er in the quali\ufb01ed-id  depends on a template parameter (14.6.2) <strong>but does not refer to a member of the current instantiation</strong> (14.6.2.1), the member template name must be\n  pre\ufb01xed by the keyword template. Otherwise the name is assumed to name a non-template. </p>\n</blockquote>\n<p>Can someone give an example to illustrate what <code>but does not refer to a member of the current instantiation</code> means in context of C++0x?</p>\n<p>-PS</p>\n", "Tags": "<c++><templates>", "LastActivityDate": "2010-10-11T04:15:24.710", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "165520"}});