post_cb({"11813839": {"Id": "11813839", "PostTypeId": "2", "Body": "<pre><code>return n &lt;= 1 ? n : n + fun(n-1);\n</code></pre>\n", "LastActivityDate": "2012-08-05T03:54:45.063", "Score": "0", "CreationDate": "2012-08-05T03:54:45.063", "ParentId": "11813692", "CommentCount": "0", "OwnerUserId": "207421"}, "11813707": {"Id": "11813707", "PostTypeId": "2", "Body": "<p>The problem is this line:</p>\n<pre><code> sum += fun(n - 1);\n</code></pre>\n<p>which is updating the variable <code>sum</code>.</p>\n<p>Assuming that you are simply trying to sum the numbers from 1 to N, then it should be doing the calculation that calculates <code>f(N)</code> in terms of <code>f(N - 1)</code>.  That doesn't require you to refer to <code>sum</code> ... and certainly it doesn't require you to update it.</p>\n<p>(I'm being careful NOT to tell you what the answer is ... because it you will learn more if you figure it out yourself.)</p>\n<hr>\n<p>By the way, there is nothing Java specific about the flaw in your algorithm ...</p>\n<hr>\n<p>It is worth noting that the real issue is not to do with static versus instance variables.  The real issue is that a recursive function like this shouldn't be using <em>either</em> kind of variable.  Now in this example you can possibly get away with it, but if the recursion involves something like this: <code>f(N) = f(N-1) + f(N-2)</code> you are liable to find that the different call trees interfere with each other.</p>\n<p>A more correct solution in this case is to write the method as:</p>\n<pre><code>int fun(int n) {\n    if (n == 1)\n        return 1;\n    else\n        return n + f(n - 1);\n}\n</code></pre>\n<p>As I said, you don't need to refer to, or update the <code>sum</code> variable.</p>\n</hr></hr>", "LastEditorUserId": "139985", "LastActivityDate": "2012-08-05T04:28:36.527", "Score": "6", "CreationDate": "2012-08-05T03:26:14.287", "ParentId": "11813692", "CommentCount": "10", "LastEditDate": "2012-08-05T04:28:36.527", "OwnerUserId": "139985"}, "11813692": {"ViewCount": "825", "Body": "<p>The very simple Java code as follows has the weird output, but the same logic code in C and C++ has the right output. I try with the JDK 1.7 and JDK 1.3 (relative JRE), the weird output is always there.</p>\n<pre><code>public class Test {\n\n    public static int sum=0;\n\n    public static int fun(int n) {\n\n        if (n == 1)\n            return 1;\n        else\n            sum += fun(n - 1);  // this statement leads to weird output\n        // { // the following block has right output\n        //     int tmp = fun(n - 1);\n        //     sum += tmp;\n        // }\n\n        return sum;\n    }\n\n    public static void main(String[] arg) {\n        System.out.print(fun(5));\n    }\n}\n</code></pre>\n<p>The output is 1 which should be 8. Relative C/C++ code is as follows:</p>\n<pre><code>#include&lt;stdio.h&gt;\nint sum=0;\nint fun(int n) {\n\n        if (n == 1)\n            return 1;\n        else\n            sum += fun(n - 1);\n\n        return sum;\n    }\n\nint main()\n{\n    printf(\"%d\",fun(5));\n\n    return 0;\n}\n</code></pre>\n<p>Adding test java code:</p>\n<pre><code>class A {\n    public int sum = 0;\n\n    public int fun(int n) {\n        if(n == 1) {\n            return 1;\n        } else {\n            sum += fun(n - 1);\n            return sum;\n        }\n    }\n}\n\npublic class Test {\n    public static void main(String arg[]){\n        A a = new A();\n        System.out.print(a.fun(5));\n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "11813977", "Title": "Different results in Java and C++ using += in recursion", "CreationDate": "2012-08-05T03:18:57.900", "Id": "11813692", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-02-03T06:37:14.167", "LastEditorUserId": "880772", "LastActivityDate": "2017-02-03T06:37:14.167", "Score": "6", "OwnerUserId": "1576843", "Tags": "<java><c++><recursion><order-of-evaluation><console-output>", "AnswerCount": "8"}, "11813977": {"Id": "11813977", "PostTypeId": "2", "Body": "<p>I'm going to run through this for fun(3) for the sake of giving a complete answer. For those of you who are not interested why this works for C++ but not for Java, please ignore my answer.</p>\n<p><strong>Here is what Java is doing:</strong></p>\n<p>inside fun(3)</p>\n<pre><code>sum += sum + fn(n-1) // sum is 0\n</code></pre>\n<p>becomes </p>\n<pre><code>sum = 0 + fun(2) // sum is 0\n</code></pre>\n<p>Then inside fun(2)</p>\n<pre><code>sum = 0 + fun(1) // sum is 0\n</code></pre>\n<p>Then inside fun(1)</p>\n<pre><code>return 1 // sum is 0\n</code></pre>\n<p>Back inside fun(2)</p>\n<pre><code>sum = 0 + 1; // sum is 0\n</code></pre>\n<p>becomes</p>\n<pre><code>sum = 1; // sum will soon become 1\n</code></pre>\n<p>Back inside fun(3)</p>\n<pre><code>sum = 0 + 1; // sum is 1\n</code></pre>\n<p>becomes</p>\n<pre><code>sum = 1; // sum gets reset to 1\n</code></pre>\n<p><strong>Here is what C++ is doing:</strong></p>\n<p>inside fun(3)</p>\n<pre><code>sum += fn(n-1) // sum is 0\n</code></pre>\n<p>becomes</p>\n<pre><code>sum = sum + fn(2) // sum is 0\n</code></pre>\n<p>Then inside fun(2)</p>\n<pre><code>sum = sum + fn(1) // sum is 0\n</code></pre>\n<p>Then inside fun(1)</p>\n<pre><code>return 1 // sum is 0\n</code></pre>\n<p>Back inside fun(2)</p>\n<pre><code>sum = sum + 1 // sum is 0\n</code></pre>\n<p>Becomes</p>\n<pre><code>sum = 0 + 1 =&gt; sum = 1 // sum will soon become 1\n</code></pre>\n<p>Back inside fun(3)</p>\n<pre><code>sum = sum + 1 // sum is 1\n</code></pre>\n<p>Becomes</p>\n<pre><code>sum = 1 + 1 // sum will soon become 2\n</code></pre>\n<p><strong>What you should do:</strong>\nI do not know why C++ evaluates <code>sum</code> after making the function call rather than before. I do not know if this is in the specifications. But I do know that you should not be depending on this in <em>any</em> language. A correct solution would be:</p>\n<pre><code>int fun(int n) {\n    if (n == 1)\n        return 1;\n    else\n        return n + f(n - 1);\n}\n</code></pre>\n", "LastEditorUserId": "1448071", "LastActivityDate": "2012-08-05T04:35:19.367", "Score": "2", "CreationDate": "2012-08-05T04:29:59.213", "ParentId": "11813692", "CommentCount": "7", "LastEditDate": "2012-08-05T04:35:19.367", "OwnerUserId": "1448071"}, "11813761": {"Id": "11813761", "PostTypeId": "2", "Body": "<p>You really need to step through your logic there. It doesn't make any sense. Is the \"weird\" output that f(5) = 8? (you've actually accidentally written a function which computes 2^(n-2), but that seems beside the point)</p>\n<p>I can't explain to you where any syntax is wrong - its the algorithm itself. It just doesn't do what you intended it to do. A big red flag that should stand out to you: the variable n isn't even directly added to sum anywhere! When you call fun(5), that 5 isn't even used. It's just passed into f(4). </p>\n<p>It seems to me that your logic was this: recursively loop from n-&gt;1, and add that to sum. In which case, your function should have been:</p>\n<pre><code>void fun(int n){\n    if(n == 0)\n        return;\n    sum += n;\n    fun(n-1);\n}\n</code></pre>\n<p>or something like that. But that isn't a very...recursive-y way to do things. You'd be much better off with no variables at all. Non-base-case: return n+fun(n-1).</p>\n<p>Also in the future, when you say that some code has \"weird output\", you should probably provide both 1) the weird output and 2) what you expected the output to be. We're all just guessing at what you wanted to write. </p>\n", "LastEditorUserId": "544007", "LastActivityDate": "2012-08-05T20:58:42.273", "Score": "0", "CreationDate": "2012-08-05T03:37:55.960", "ParentId": "11813692", "CommentCount": "1", "LastEditDate": "2012-08-05T20:58:42.273", "OwnerUserId": "544007"}, "bq_ids": {"n4140": {"so_11813692_22003520_2": {"length": 9, "quality": 0.9, "section_id": 5811}, "so_11813692_22003520_1": {"length": 7, "quality": 0.875, "section_id": 6179}}, "n3337": {"so_11813692_22003520_2": {"length": 9, "quality": 0.9, "section_id": 5584}, "so_11813692_22003520_1": {"length": 7, "quality": 0.875, "section_id": 5940}}, "n4659": {"so_11813692_22003520_2": {"length": 9, "quality": 0.9, "section_id": 7272}, "so_11813692_22003520_1": {"length": 7, "quality": 0.875, "section_id": 7681}}}, "11813764": {"Id": "11813764", "PostTypeId": "2", "Body": "<p>Try this:</p>\n<pre><code>public class Test {\n\n   public static int fun(int n) {\n      System.out.println(\"processing n \" + n );\n\n      if (n == 1)\n        return 1;\n       else{\n           return n + fun(n - 1);\n      }\n   }\n\n   public static void main(String[] arg) {\n      System.out.print(fun(5));\n   }\n}\n</code></pre>\n", "LastActivityDate": "2012-08-05T03:38:30.333", "Score": "1", "CreationDate": "2012-08-05T03:38:30.333", "ParentId": "11813692", "CommentCount": "1", "OwnerUserId": "613247"}, "11813775": {"Id": "11813775", "PostTypeId": "2", "Body": "<pre><code>public static int fun(int n) {\n    if (n == 1)\n        return 1;\n    else\n        return n +  fun(n - 1);\n} \n</code></pre>\n<p>BTW  if you want to do it in the same way as in C code, just define sum as \"Integer\" instead of \"int\"</p>\n", "LastEditorUserId": "1540264", "LastActivityDate": "2012-08-05T03:59:25.283", "Score": "1", "CreationDate": "2012-08-05T03:41:31.300", "ParentId": "11813692", "CommentCount": "0", "LastEditDate": "2012-08-05T03:59:25.283", "OwnerUserId": "1540264"}, "11814027": {"Id": "11814027", "PostTypeId": "2", "Body": "<p><strong>Try this</strong></p>\n<pre><code>   static int getsum(int num){\n        int sum = 0;\n        if(num == 1){\n            return num;\n\n        }else{\n             sum  = num+getsum(num-1);  \n        }\n\n        return sum ;\n    }\n</code></pre>\n", "LastEditorUserId": "1509578", "LastActivityDate": "2012-08-05T04:48:47.850", "Score": "0", "CreationDate": "2012-08-05T04:42:44.563", "ParentId": "11813692", "CommentCount": "0", "LastEditDate": "2012-08-05T04:48:47.850", "OwnerUserId": "1509578"}, "22003520": {"Id": "22003520", "PostTypeId": "2", "Body": "<p>The current answers to this question do not get to the root of the issue. The behavior in Java is due to the fact that:</p>\n<pre><code>sum += fun(n - 1); \n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>sum = sum + fun(n - 1); \n</code></pre>\n<p>where <code>sum</code> is evaluated before <code>fun(n - 1)</code> and the value is stored. We can see this by going to the JLS section <a href=\"http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.26.2\" rel=\"nofollow\">15.26.2. Compound Assignment Operators </a> which says:</p>\n<blockquote>\n<p id=\"so_11813692_22003520_0\">A compound assignment expression of the form E1 op= E2 is equivalent to E1 = (T) ((E1) op (E2))</p>\n</blockquote>\n<p>and then the left hand operand is evaluated and then the right hand operand is evaluated and the operation is performed. So <code>sum</code> is evaluated before each iteration of the recursion and is <code>0</code> all the way back.</p>\n<p>It also means that if you switched the line to this:</p>\n<pre><code>sum = fun(n - 1) + sum ;\n</code></pre>\n<p>it would produce the effect you desire since <code>fun</code> would be evaluated first.</p>\n<p>In <em>C++</em>:</p>\n<pre><code>sum += fun(n - 1);\n</code></pre>\n<p>is also equivalent to:</p>\n<pre><code>sum = sum + fun(n - 1);  \n</code></pre>\n<p>this is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>5.17</code> <em>Assignment and compound assignment operators</em> which says:</p>\n<blockquote>\n<p id=\"so_11813692_22003520_1\">The behavior of an expression of the form E1 op = E2 is equivalent to E1 = E1 op E2 except that E1 is evaluated only once.[...]</p>\n</blockquote>\n<p>The major different is that the order of evaluation of the left and right hand side is unspecified which is covered in section <code>1.9</code> <em>Program execution</em> paragraph <em>15</em> which says:</p>\n<blockquote>\n<p id=\"so_11813692_22003520_2\">Except where noted, evaluations of operands of individual operators and of subexpressions of individualexpressions are unsequenced.[...]</p>\n</blockquote>\n<p>and so <code>1</code> and <code>8</code> would both be valid results in <em>C++</em>. We can see this live <a href=\"http://coliru.stacked-crooked.com/a/1ee03e5e546f2700\" rel=\"nofollow\">gcc gives us 8</a> and <a href=\"http://coliru.stacked-crooked.com/a/6dd311af640929e9\" rel=\"nofollow\">clang gives us 1</a>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-02-25T15:07:18.490", "Score": "3", "CreationDate": "2014-02-25T02:38:11.970", "ParentId": "11813692", "CommentCount": "1", "LastEditDate": "2014-02-25T15:07:18.490", "OwnerUserId": "1708801"}});