post_cb({"bq_ids": {"n4140": {"so_38173469_38230873_0": {"length": 85, "quality": 0.9444444444444444, "section_id": 87}}, "n3337": {"so_38173469_38230873_0": {"length": 75, "quality": 0.8333333333333334, "section_id": 82}}, "n4659": {"so_38173469_38230873_1": {"length": 31, "quality": 0.8157894736842105, "section_id": 90}}}, "38217946": {"Id": "38217946", "PostTypeId": "2", "Body": "<p>User defined conversions are not considered for template argument matching.</p>\n<p>However, instead of</p>\n<pre><code>print &lt;string &lt;'c', 'i', 'a', 'o', '\\0'&gt;{} &gt; ();\n</code></pre>\n<p>\u2026 you can just write</p>\n<pre><code>print &lt;string &lt;'c', 'i', 'a', 'o', '\\0'&gt;::value&gt; ();\n</code></pre>\n<p>Or you can define</p>\n<pre><code>template &lt;const char* str&gt;\nvoid print()\n{\n    std::cout &lt;&lt; str &lt;&lt; std::endl;\n}\n\ntemplate&lt; class Type &gt;\nvoid print()\n{\n    print&lt;Type::value&gt;();\n}\n</code></pre>\n<p>\u2026 and then write just</p>\n<pre><code>print &lt;x&gt; ();\nprint &lt;string &lt;'c', 'i', 'a', 'o', '\\0'&gt;&gt; ();\n</code></pre>\n<p>\u2026 where <code>x</code> is your namespace scope</p>\n<pre><code>static constexpr const char x[] = \"ciao\";\n</code></pre>\n<p><strong>Note</strong>: this code compiles with MinGW g++ 5.1.0 with <code>-std=c++14</code>, but not with Visual C++ 2015 update 2. Such differences are common for code that pushes the boundaries of the language. The standard is in flux, and the compilers are evolving to try to keep up with the standard, and so such code is in practice not very portable.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-07-06T07:04:13.227", "Score": "-1", "CreationDate": "2016-07-06T06:58:12.770", "ParentId": "38173469", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2016-07-06T07:04:13.227"}, "38230873": {"Id": "38230873", "PostTypeId": "2", "Body": "<p>In C++14, the restriction on template arguments to a template non-type parameter is:</p>\n<blockquote>\n<p id=\"so_38173469_38230873_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:<br>\n  * for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the <em>template-parameter</em>; or<br>\n  * the name of a non-type <em>template-parameter</em>; or<br>\n  * a constant expression (5.19) that designates the address of a complete object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp;</code> <em>id-expression</em>, where the <em>id-expression</em> is the name of an object or function, except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding <em>template-parameter</em> is a reference; or<br>\n  * a constant expression that evaluates to a null pointer value (4.10); or<br>\n  * a constant expression that evaluates to a null member pointer value (4.11); or<br>\n  * a pointer to member expressed as described in 5.3.1; or<br>\n  * a constant expression of type <code>std::nullptr_t</code>.</br></br></br></br></br></br></br></p>\n</blockquote>\n<p>In your example, <code>string&lt;'c', 'i', 'a', 'o', '\\0'&gt;{}</code> is none of those. Note that the first bullet is restricted to integral or enumeration type, and <code>const char*</code> is neither of those (the exception for integral types is what allows your \"Further experiments\" example to compile). None of the other bullets apply. So a conforming C++14 <em>should</em> reject your code.</p>\n<p>The workaround is to simply pass the underlying character array directly:</p>\n<pre><code>print&lt;string&lt;'c', 'i', 'a', 'o', '\\0'&gt;::value&gt;();\n</code></pre>\n<p>Or to take the type itself as the template <em>type</em> argument, and print <code>::value</code> within the function:</p>\n<pre><code>template &lt;class T&gt;\nvoid print() {\n    std::cout &lt;&lt; T::value &lt;&lt; std::endl;\n}\n\nprint&lt;string&lt;'c', 'i', 'a', 'o', '\\0'&gt;&gt;();\n</code></pre>\n<p><em>Or...</em></p>\n<hr/>\n<p>You'll be happy to know that in C++17, things get better. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html\" rel=\"nofollow\">N4198</a>, with the motivating example:</p>\n<pre><code>template&lt;int *p&gt; struct A {};\nint n;\nA&lt;&amp;n&gt; a; // ok\n\nconstexpr int *p() { return &amp;n; }\nA&lt;p()&gt; b; // error\n</code></pre>\n<p>The paper proposed fewer restrictions on template non-type arguments, which would make the above example well-formed. The new wording reads:</p>\n<blockquote>\n<p id=\"so_38173469_38230873_1\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a converted constant expression (5.20) of the type of the template-parameter. For a non-type <em>template-parameter</em> of reference type or pointer type, the value of the constant expression shall not refer to (or for a pointer type, shall not be the address of):<br>\n  * a subobject (1.8),<br>\n  * a temporary object (12.2),<br>\n  * a string literal (2.14.5),<br>\n  * the result of a <code>typeid</code> expression (5.2.8), or\n  * a predefined <code>__func__</code> variable (8.4.1).</br></br></br></br></p>\n</blockquote>\n<p>That's it. Everything else is allowed. </p>\n<p>Since <code>string&lt;'c', 'i', 'a', 'o', '\\0'&gt;{}</code> converts to a pointer that is none of those things, the example becomes well-formed. Clang 3.8 will compile your example in c++1z mode (correctly) but not in c++14 mode (correctly). GCC does not implement this yet. Just give them time. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-07-06T18:23:45.607", "Score": "4", "CreationDate": "2016-07-06T18:08:19.370", "ParentId": "38173469", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-07-06T18:23:45.607"}, "38173469": {"ViewCount": "412", "Body": "<p>It has happened to many people, and it happened to me. I got stuck playing with compile time strings in C++.</p>\n<p>I decided to take the apparently unusable approach: using <code>template &lt;char...&gt;</code> classes.</p>\n<p>This is what I came up with, it is very common, nothing special, and also it does not work. </p>\n<pre><code>template &lt;char... chars&gt; class string\n{\npublic:\n\n    static constexpr const char value[] = {chars...};\n\n    constexpr string()\n    {\n    }\n\n    constexpr operator decltype(value) &amp; () const\n    {\n        return value;\n    }\n};\n\ntemplate &lt;char... chars&gt; constexpr const char string &lt;chars...&gt; :: value[];\n</code></pre>\n<p>My idea was making a <code>string</code> instance <code>constexpr</code> constructible and exposing some kind of constexpr casting so that it would provide its content.</p>\n<p>Now, if I do</p>\n<pre><code>static constexpr const char x[] = \"ciao\";\n\ntemplate &lt;const char * str&gt; void print()\n{\n    std :: cout &lt;&lt; str &lt;&lt; std :: endl;\n}\n\nprint &lt;x&gt; ();\n</code></pre>\n<p>This works and says <code>ciao</code>. I get <code>ciao</code> also if I do</p>\n<pre><code>std :: cout &lt;&lt; string &lt;'c', 'i', 'a', 'o'&gt; {} &lt;&lt; std :: endl;\n</code></pre>\n<p>or</p>\n<pre><code>print &lt;string &lt;'c', 'i', 'a', 'o', '\\0'&gt; :: value&gt; ();\n</code></pre>\n<p>But when I do</p>\n<pre><code>print &lt;string &lt;'c', 'i', 'a', 'o', '\\0'&gt; {}&gt; ();\n</code></pre>\n<p>I get: <code>No matching function for call to print</code>.</p>\n<p>I am definitely missing something. Is it unfeasible to do what I am trying to do? Making an instance do a constexpr cast to somehow return <code>value</code>? If that worked, I would be able to easily make operators and string manipulation at compile time, the \"only\" downside being the ultra-boring <code>'i', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n'</code>.</p>\n<h2>Further experiments</h2>\n<p>I did another experiment that works perfectly.</p>\n<pre><code>template &lt;char... chars&gt; class string\n{\npublic:\n   constexpr string()\n   {\n   }\n\n   constexpr operator size_t () const\n   {\n      return sizeof...(chars);\n   }\n};\n\ntemplate &lt;size_t length&gt; void print()\n{\n   std :: cout &lt;&lt; length &lt;&lt; std :: endl;\n}\n\nprint &lt;string &lt;'c', 'i', 'a', 'o'&gt; {}&gt; ();\n</code></pre>\n<p>And it prints out a pretty <code>4</code>.</p>\n", "AcceptedAnswerId": "38230873", "Title": "Constexpr cast to const char[]", "CreationDate": "2016-07-03T19:11:44.383", "Id": "38173469", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-07-06T18:30:22.327", "LastEditorUserId": "2069064", "LastActivityDate": "2016-07-06T18:30:22.327", "Score": "7", "OwnerUserId": "774236", "Tags": "<c++><templates><char><constexpr>", "AnswerCount": "2"}});