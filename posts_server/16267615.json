post_cb({"16277275": {"Id": "16277275", "PostTypeId": "2", "Body": "<p>Even without checking the specs, you can easily see that dereferencing an iterator at <code>end</code> has to be invalid.</p>\n<p>A perfectly natural implementation (the <em>de-factor</em> standard implementation for <code>vector&lt;&gt;</code>) is for <code>end()</code> to be literally a memory pointer that has a value of <code>ptr_last_element + 1</code>, that is, the pointer value that would point to the next element - if there was a next element.</p>\n<p>You cannot possibly be allowed to dereference the <code>end</code> iterator because it could be a pointer that would end up pointing to either the next object in the heap, or perhaps an overflow guard area (so you would dereference random memory), or past the end of the heap, and possibly outside of the memory space of the process, in which case you might get an Access Violation exception when dereferencing).</p>\n", "LastActivityDate": "2013-04-29T11:16:57.647", "Score": "2", "CreationDate": "2013-04-29T11:16:57.647", "ParentId": "16267615", "CommentCount": "0", "OwnerUserId": "2230"}, "16267675": {"Id": "16267675", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16267615_16267675_0\">However, the operator *of the iterator is required to return a reference. Intuitively I'm assuming it to be valid and fully initialized?  </p>\n</blockquote>\n<p>Your assumption is wrong, dereferencing iterator that points outside of container will lead to UB.</p>\n<h1>24.2 Iterator requirements [iterator.requirements]</h1>\n<h2>24.2.1 In general [iterator.requirements.general]</h2>\n<blockquote>\n<p id=\"so_16267615_16267675_1\">7 Most of the library\u2019s algorithmic templates that operate on data structures have interfaces that use ranges.\n  A range is a pair of iterators that designate the beginning and end of the computation. A range [i,i) is an\n  empty range; in general, a range [i,j) refers to the elements in the data structure starting with the element\n  pointed to by i and up to but <strong>not including the element pointed to by j.</strong> Range [i,j) is valid if and only if\n  j is reachable from i. <strong>The result of the application of functions in the library to invalid ranges is undefined.</strong></p>\n</blockquote>\n", "LastActivityDate": "2013-04-28T20:46:58.780", "Score": "2", "CreationDate": "2013-04-28T20:46:58.780", "ParentId": "16267615", "CommentCount": "0", "OwnerUserId": "2254782"}, "16267615": {"ViewCount": "2100", "Body": "<p>I'm working with a <code>std::map&lt;std::string, MyClass* &gt;</code>.</p>\n<p>I want to test if <code>my_map.find(key)</code> returned a specific pointer.</p>\n<p>Right now I'm doing;</p>\n<pre><code>auto iter = my_map.find(key);\nif ((iter != my_map.end()) &amp;&amp; (iter-&gt;second == expected)) {\n    // Something wonderful has happened\n}\n</code></pre>\n<p>However, the <code>operator *</code> of the iterator is required to return a reference. Intuitively I'm assuming it to be valid and fully initialized? If so, <code>my_map.end()-&gt;second</code> would be <code>NULL</code>, and (since <code>NULL</code> is never expected), I could reduce my if statement to:</p>\n<pre><code>if (iter-&gt;second == expected)\n</code></pre>\n<p>Is this valid according to specification? Does anyone have practical experience with the implementations of this? IMHO, the code becomes clearer, and possibly a tiny performance improvement could be achieved.</p>\n", "AcceptedAnswerId": "16267741", "Title": "Is ->second defined for iterator my_map.end()?", "CreationDate": "2013-04-28T20:41:08.320", "Id": "16267615", "CommentCount": "0", "LastEditDate": "2013-04-29T11:19:07.990", "PostTypeId": "1", "LastEditorUserId": "193903", "LastActivityDate": "2013-04-29T11:19:07.990", "Score": "8", "OwnerUserId": "103192", "Tags": "<c++><stl><iterator>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_16267615_16267675_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 5561}, "so_16267615_16267741_1": {"length": 40, "quality": 0.9523809523809523, "section_id": 5559}}, "n3337": {"so_16267615_16267675_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 5343}, "so_16267615_16267741_1": {"length": 40, "quality": 0.9523809523809523, "section_id": 5341}}, "n4659": {"so_16267615_16267675_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 7008}, "so_16267615_16267741_1": {"length": 40, "quality": 0.9523809523809523, "section_id": 7006}}}, "16268223": {"Id": "16268223", "PostTypeId": "2", "Body": "<p>If <code>iter == my_map.end ()</code>, then dereferencing it is undefined behavior; but you're not doing that here.</p>\n<pre><code>auto iter = my_map.find(key);\nif ((iter != my_map.end()) &amp;&amp; (iter-&gt;second == expected)) {\n    // Something wonderful has happened\n}\n</code></pre>\n<p>If <code>iter != my_map.end()</code> is false, then the second half of the expression (<code>iter-&gt;second == expected</code>) will not be exectuted.</p>\n<p>Read up on \"short-circut evaluation\".\nAnalogous code for pointers:</p>\n<pre><code>if ( p != NULL &amp; *p == 4 ) {}\n</code></pre>\n", "LastActivityDate": "2013-04-28T21:40:17.510", "Score": "0", "CreationDate": "2013-04-28T21:40:17.510", "ParentId": "16267615", "CommentCount": "0", "OwnerUserId": "992490"}, "16267741": {"Id": "16267741", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_16267615_16267741_0\">Intuitively I'm assuming it to be valid and fully initialized?</p>\n</blockquote>\n<p>You cannot assume an iterator to an element past-the-end of a container to be dereferenceable. Per paragraph 24.2.1/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16267615_16267741_1\">Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element\n  of the array, so for any iterator type there is an iterator value that points past the last element of a\n  corresponding sequence. These values are called past-the-end values. Values of an iterator <code>i</code> for which the\n  expression <code>*i</code> is defined are called dereferenceable. <strong>The library never assumes that past-the-end values are\n  dereferenceable.</strong> [...]</p>\n</blockquote>\n", "LastActivityDate": "2013-04-28T20:52:53.643", "Score": "9", "CreationDate": "2013-04-28T20:52:53.643", "ParentId": "16267615", "CommentCount": "2", "OwnerUserId": "1932150"}});