post_cb({"44640490": {"LastActivityDate": "2017-06-20T07:25:00.333", "CommentCount": "0", "Body": "<p>I didn't have found anything that says the behavior you uncovered is OK, but I have found following, that might be asserting otherwise.</p>\n<blockquote>\n<p id=\"so_44367859_44640490_0\">When the name of a member template specialization appears after . or\n  -&gt; in a postfix-expression or after a nested-name-specifier in a qualified-id, and the object expression of the postfix-expression is\n  type-dependent or the nested-name-specifier in the qualified-id refers\n  to a dependent type, but the name is not a member of the current\n  instantiation (14.6.2.1), the member template name must be prefixed by\n  the keyword template. Otherwise the name is assumed to name a\n  non-template. </p>\n<pre><code>[ Example:\nstruct X {\ntemplate&lt;std::size_t&gt; X* alloc();\ntemplate&lt;std::size_t&gt; static X* adjust();\n};\ntemplate&lt;class T&gt; void f(T* p) {\nT* p1 = p-&gt;alloc&lt;200&gt;(); // ill-formed: &lt; means less than\nT* p2 = p-&gt;template alloc&lt;200&gt;(); // OK: &lt; starts template argument list\nT::adjust&lt;100&gt;(); // ill-formed: &lt; means less than\nT::template adjust&lt;100&gt;(); // OK: &lt; starts template argument list\n}\n\u2014 end example ]\n</code></pre>\n</blockquote>\n<p>You can work around id as already suggested by putting compared elements in parentheses. It will break name <code>array&lt;</code> </p>\n<pre><code>    return (lhs.val.array) &lt; (rhs.val.array);\n</code></pre>\n<p>Let's simplify you code a little bit more and remove all includes that might be obscuring what is going on. I will start with original code that still doesn't compile.</p>\n<pre><code>#include &lt;cstddef&gt; // needed for size_t\n//using std::array; brings following two lines into your code:\ntemplate&lt; class T, std::size_t N &gt;\nstruct array;\n\ntemplate &lt;typename X&gt;\nstruct A\n{\n    struct value_t { int array; };\n    value_t val = {};  \n    friend bool operator&lt;(const A&amp; lhs, const A&amp; rhs) {\n        return (lhs.val.array &lt; rhs.val.array);\n    }\n};\n</code></pre>\n<p>And now let's move <code>struct value_t { int array; };</code> outside of templated definition:</p>\n<pre><code>#include &lt;cstddef&gt; // needed for size_t\n//using std::array; brings following two lines into your code:\ntemplate&lt; class T, std::size_t N &gt;\nstruct array;\n\nstruct value_t { int array; };\n\ntemplate &lt;typename X&gt;\nstruct A\n{\n    value_t val = {};  \n    friend bool operator&lt;(const A&amp; lhs, const A&amp; rhs) {\n        return (lhs.val.array &lt; rhs.val.array);\n    }\n};\n</code></pre>\n<p>So by including <code>&lt;array&gt;</code> into your code, you brought template array into your code as shown here. In version with value_t outside of template there is <code>array&lt;T&gt;</code> and member <code>array</code>. These are different things and thus without any conflict.<br>\nWhen you put value_t inside template, the compiler starts its attempts to expand what comes from that template. It tries to do that with member array which should not happen as specified in the standard.</br></p>\n<p>Anyway, it looks like bug in GCC, because when it appears in expression <code>lhs.val.array</code> it should be treated as templated only when prefixed with keyword template <code>lhs.val.template array&lt;</code></p>\n<p>And yes using same name in different contexts is perfectly correct unless it is one of the reserved words, which array is not. But be careful with this use of names. I find it at least confusing to use name array for variable holding single integer. The name already suggests there will be more than one.</p>\n", "CreationDate": "2017-06-19T21:47:35.863", "LastEditDate": "2017-06-20T07:25:00.333", "ParentId": "44367859", "Id": "44640490", "LastEditorUserId": "8113019", "PostTypeId": "2", "Score": "1", "OwnerUserId": "8113019"}, "bq_ids": {"n4140": {"so_44367859_44640490_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 72}}, "n3337": {"so_44367859_44640490_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 67}}}, "44367859": {"CreationDate": "2017-06-05T11:23:58.590", "LastActivityDate": "2017-06-20T07:25:00.333", "Id": "44367859", "ViewCount": "619", "Score": "26", "Title": "Using std::array and using \"array\" as name", "CommentCount": "21", "Body": "<p>In my C++ JSON library, I recently had a <a href=\"https://github.com/nlohmann/json/issues/590\" rel=\"noreferrer\">regression with GCC7</a>. I stripped down the affected code and hope to understand the error.</p>\n<h1>The code</h1>\n<p>Consider this header <code>myclass.hpp</code>:</p>\n<pre><code>#pragma once\n\ntemplate &lt;typename X&gt;\nstruct A\n{\n    struct value_t\n    {\n        X array;\n    };\n\n    static A array()\n    {\n        return A();\n    }\n\n    friend bool operator&lt;(const A&amp; lhs, const A&amp; rhs) noexcept\n    {\n        return lhs.val.array &lt; rhs.val.array;\n    }\n\n    value_t val = {};  \n};\n</code></pre>\n<p>As you see, I used the name \"array\" as member variable name in struct <code>value_t</code>, as name of a static function. I then included the header in the following file:</p>\n<pre><code>#include &lt;array&gt;\nusing std::array; // note this!\n#include \"myclass.hpp\"\n\nint main()\n{}\n</code></pre>\n<h1>The problem</h1>\n<p>The code compiles with GCC6 and Clang5 (using <code>-std=c++11</code>), but GCC7 reports:</p>\n<pre><code>In file included from example.cpp:3:0:\nmyclass.hpp: In function 'bool operator&lt;(const A&lt;X&gt;&amp;, const A&lt;X&gt;&amp;)':\nmyclass.hpp:19:40: error: wrong number of template arguments (1, should be 2)\n         return lhs.val.array &lt; rhs.val.array;\n                                        ^~~~~\nIn file included from example.cpp:1:0:\n/usr/local/Cellar/gcc/7.1.0/include/c++/7.1.0/array:94:12: note: provided for 'template&lt;class _Tp, long unsigned int _Nm&gt; struct std::array'\n     struct array\n            ^~~~~\nmake: *** [all] Error 1\n</code></pre>\n<p>It seems as if the parser reads the \"array\" in <code>lhs.val.array</code> as <code>std::array</code> and treats the following <code>&lt;</code> as the start of a template list.</p>\n<p>The code can be compiled if I make any of the changes below:</p>\n<ul>\n<li>Remove the <code>using std::array;</code> or move it behind <code>#include \"myclass.hpp\"</code>.</li>\n<li>Change <code>return lhs.val.array &lt; rhs.val.array;</code> to <code>return (lhs.val.array) &lt; rhs.val.array;</code>.</li>\n</ul>\n<p>In addition, either compiler fails if I remove the <code>static A array()</code> function...</p>\n<h1>My questions</h1>\n<ul>\n<li>Is the code correct in the first place? Am I allowed to use \"array\" as a name even if I use <code>using std::array;</code>?</li>\n<li>If the code is correct, is this a bug in GCC7?</li>\n</ul>\n", "Tags": "<c++><c++11><using-directives><stdarray>", "FavoriteCount": "8", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "266378"}});