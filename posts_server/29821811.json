post_cb({"33446452": {"Id": "33446452", "PostTypeId": "2", "Body": "<p>The behavior of #2 is definitely well-defined. As mentioned by @dyp, the relevant paragraph is in [basic.life]: </p>\n<p><a href=\"https://i.stack.imgur.com/wbpgJ.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/wbpgJ.png\"/></a></p>\n<p>Binding the glvalue <code>yobj</code> to a reference is fine, since its storage lasts throughout the duration of the program ([basic.stc.static]/1) and the reference is bound to a valid object - aliveness aside - which meets the requirement in ([dcl.ref]/5). Similarly, for the second example you showed, as long as no operation is performed on members of the <code>A</code> subobject, the above paragraph applies as well since the constructor of <code>C</code> is called on the allocated storage <code>this</code> refers to.</p>\n", "LastActivityDate": "2015-10-30T23:48:21.063", "CommentCount": "0", "CreationDate": "2015-10-30T23:48:21.063", "ParentId": "29821811", "Score": "2", "OwnerUserId": "3647361"}, "bq_ids": {"n4140": {"so_29821811_29822863_2": {"length": 10, "quality": 1.0, "section_id": 444}, "so_29821811_29822863_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 5768}, "so_29821811_29821811_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 444}}, "n3337": {"so_29821811_29822863_2": {"length": 10, "quality": 1.0, "section_id": 435}, "so_29821811_29822863_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 5541}, "so_29821811_29821811_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 435}}, "n4659": {"so_29821811_29822863_2": {"length": 10, "quality": 1.0, "section_id": 467}, "so_29821811_29822863_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 7225}, "so_29821811_29821811_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 467}}}, "29822863": {"Id": "29822863", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29821811_29822863_0\">[...] there's no mention of references in the example [...]</p>\n</blockquote>\n<p>You mean, except for</p>\n<blockquote>\n<p id=\"so_29821811_29822863_1\">[...] <strong>referring</strong> to any non-static member [...]</p>\n</blockquote>\n<p>From the passage you quote, I would say this line causes undefined behaviour:</p>\n<pre><code>int&amp; r3 = yobj.i; // #3\n</code></pre>\n<p>because you are:</p>\n<blockquote>\n<p id=\"so_29821811_29822863_2\">[...] referring to any non-static member or base class of the object before the constructor begins execution[.]</p>\n</blockquote>\n<p>Also, for this:</p>\n<blockquote>\n<p id=\"so_29821811_29822863_3\">and the most important, the above paragraph doesn't imply that otherwise the behavior is well-defined.</p>\n</blockquote>\n<p>You're right, it doesn't:</p>\n<blockquote>\n<p id=\"so_29821811_29822863_4\">Undefined behavior may be expected when this International Standard <strong>omits any explicit definition of behavior</strong> or when a program uses an erroneous construct or erroneous data.</p>\n</blockquote>\n", "LastEditorUserId": "2302862", "LastActivityDate": "2015-04-23T12:36:55.253", "Score": "0", "CreationDate": "2015-04-23T12:01:29.627", "ParentId": "29821811", "CommentCount": "8", "OwnerUserId": "2302862", "LastEditDate": "2015-04-23T12:36:55.253"}, "29821811": {"ViewCount": "311", "Body": "<p>Is the behavior of the following code well-defined?</p>\n<pre><code>struct X { int i; }; // trivial\nstruct Y : X { Y(){} }; // non-trivial\n\nextern X xobj;\nint&amp; r1 = xobj.i; // #1\nX xobj;\n\nextern Y yobj;\nY&amp; r2 = yobj;     // #2\n// int&amp; r3 = yobj.i; // #3 - this is UB according to the standard\nY yobj;\n</code></pre>\n<p>This code is inspired by the example in the C++ standard, namely draft N4140 [class.cdtor]/1.</p>\n<p>That's what that paragraph reads:</p>\n<blockquote>\n<p id=\"so_29821811_29821811_0\">For an object with a non-trivial constructor, referring to any non-static member or base class of the object\n  before the constructor begins execution results in undefined behavior. For an object with a non-trivial\n  destructor, referring to any non-static member or base class of the object after the destructor finishes\n  execution results in undefined behavior.</p>\n</blockquote>\n<p>An example follows, which shows how <em>pointers</em> may and may not be bound to objects.</p>\n<p>So intuitively it seems that <code>#1</code> and <code>#2</code> are well-defined, while <code>#3</code> invokes UB if uncommented, but, first, examples are not normative, second, there's no mention of references in the example, and third and the most important, the above paragraph doesn't imply that otherwise the behavior is well-defined. Or does it? Or maybe there's another relevant quote in the standard that I missed?</p>\n<p><strong>Edit</strong>: The answer may (arguably) be yes if the objects have static storage duration, but they can be also local, e.g:</p>\n<pre><code>struct A { A(){} };\nstruct B { B(A&amp;){} };\n\nstruct C {\n    B b;\n    A a;\n    C() : b(a) {}\n};\n\nint main() {\n    C c;\n}\n</code></pre>\n<p>Actually this was the initial inspiration for this question, see <a href=\"https://stackoverflow.com/questions/29809241/circular-dependency-in-constructor-initialization-list\">Circular dependency in constructor initialization list</a></p>\n", "Title": "Binding reference to an object before construction", "CreationDate": "2015-04-23T11:16:14.047", "LastActivityDate": "2015-10-30T23:48:21.063", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:16:31.943", "LastEditorUserId": "-1", "Id": "29821811", "Score": "20", "OwnerUserId": "3959454", "Tags": "<c++><reference><language-lawyer><c++14>", "AnswerCount": "2"}});