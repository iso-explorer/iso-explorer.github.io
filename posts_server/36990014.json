post_cb({"bq_ids": {"n4140": {"so_36990014_36990071_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6184}}, "n3337": {"so_36990014_36990071_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5945}}, "n4659": {"so_36990014_36990071_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7686}}}, "36990071": {"Id": "36990071", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36990014_36990071_0\">Can I get this guarantee at all? Under some conditions? Assume, of\n  course, I'm not trying to use x's address or any such funny business.</p>\n</blockquote>\n<p>Yes, the compiler will <em>almost</em> always substitute <code>foo</code> for the number at compile time with no extra memory See <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\"><code>constexpr</code></a>.\nAlmost certainly, the compiler will <em>only</em> allocate memory to <code>foo</code> if you take it's address.</p>\n<p>And, from the link on <a href=\"http://eel.is/c++draft/expr.const#1\" rel=\"nofollow\"><strong>([expr.const])</strong></a>... we see a note:</p>\n<blockquote>\n<p id=\"so_36990014_36990071_1\">Note: Constant expressions can be evaluated during translation.</p>\n</blockquote>\n<p>And, and as far as most C++ compilers I know goes, they will evaluate and fold expressions where possible.</p>\n<hr>\n<p>Using <a href=\"http://gcc.godbolt.org\" rel=\"nofollow\">gcc.godbolt.org</a>, this code (without taking the address of <code>foo</code>)...</p>\n<pre><code>constexpr int foo = 123;\nint x(){\n    int b = 5 + foo;\n    return b;\n}\n</code></pre>\n<p>Without optimization flags, the Code generated was:</p>\n<pre><code>x():\n        movl    $128, %eax\n        ret\n</code></pre>\n<p>=======================================</p>\n<p>But this code... (taking the address of <code>foo</code>)</p>\n<pre><code>constexpr int foo = 123;\nint x(){\n    int b = 5 + reinterpret_cast&lt;long&gt;(&amp;foo);\n    return b;\n}\n</code></pre>\n<p>generated....</p>\n<pre><code>x():\n        movq    foo, -8(%rsp)\n        movl    foo, %eax\n        addl    $5, %eax\n        ret\nfoo:\n        .long   123\n</code></pre>\n<hr>\n<p>NB: Why I have used <em>may</em> instead if <em>will</em> is because the C++ standard doesn't force compilers to do so, (but they almost certainly do so, some are free not to do so for their specific constraints).</p>\n</hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2016-05-02T22:28:05.033", "Score": "3", "CreationDate": "2016-05-02T19:23:02.530", "ParentId": "36990014", "CommentCount": "11", "OwnerUserId": "1621391", "LastEditDate": "2016-05-02T22:28:05.033"}, "36991563": {"Id": "36991563", "PostTypeId": "2", "Body": "<p>The C++ standard does not make any guarantees about taking space in memory at runtime, or the contents of object files.</p>\n<p><code>constexpr int foo = 123;</code> at namespace scope means that <code>foo</code> has internal linkage, and in each translation unit that this line is visible, there is an object with static storage duration, of <code>sizeof(int)</code> bytes.</p>\n<p>The compiler is permitted, but not required, to optimize out this storage if the output of the program does not depend on whether the storage actually exists.  (This is called the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow\">as-if</a> rule).</p>\n<p>An example of where the storage probably would <strong>not</strong> be optimized out would be if you had a function:</p>\n<pre><code>int const *bar() { return &amp;foo; }\n</code></pre>\n<hr>\n<p>In practice:</p>\n<ul>\n<li>it is <em>very likely</em> that if <code>foo</code> is not <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow\">odr-used</a> then it will not occupy memory at runtime.  </li>\n<li>it is <em>very likely</em> that <code>foo</code>'s name will not appear in an object file, since it has internal linkage.</li>\n</ul>\n</hr>", "LastActivityDate": "2016-05-02T20:57:06.653", "CommentCount": "0", "CreationDate": "2016-05-02T20:57:06.653", "ParentId": "36990014", "Score": "4", "OwnerUserId": "1505939"}, "36990014": {"ViewCount": "621", "Body": "<p>I want to use a global <code>constexpr</code> variable:</p>\n<pre><code>constexpr int foo = 123;\n</code></pre>\n<p>instead of a C macro:</p>\n<pre><code>#define FOO (123)\n</code></pre>\n<p>in some code I'm writing. I would like to be guaranteed the same behavior, in the sense that this will not take up space in memory at runtime, nor will it be visible/exist in the compiled object code (that is, its value will be used as an immediate where relevant).</p>\n<p>Can I get this guarantee at all? Under some conditions? Assume, of course, I'm not trying to use x's address or any such funny business.</p>\n", "Title": "When can I be sure a constexpr global variable will be \"forgotten\", like a C macro?", "CreationDate": "2016-05-02T19:19:45.387", "LastActivityDate": "2016-05-02T22:28:05.033", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-02T20:47:05.490", "LastEditorUserId": "1505939", "Id": "36990014", "Score": "2", "OwnerUserId": "1593077", "Tags": "<c++><macros><constexpr>", "AnswerCount": "3"}, "36990076": {"Id": "36990076", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36990014_36990076_0\">I would like to be guaranteed the same behavior, in the sense that this will not take up space in memory at runtime, nor will it be visible/exist in the compiled object code (that is, its value will be used as an immediate where relevant).</p>\n</blockquote>\n<pre><code>constexpr int foo = 123;\n</code></pre>\n<p>will be equally seen as <code>123</code> whenever the compiler hits it. No extra memory, nothing fancy.</p>\n<p>So yes, it's completely equivalent with the preprocessors replacement for </p>\n<pre><code>#define FOO (123)\n</code></pre>\n", "LastEditorUserId": "1413395", "LastActivityDate": "2016-05-02T19:25:14.460", "Score": "1", "CreationDate": "2016-05-02T19:23:27.623", "ParentId": "36990014", "CommentCount": "3", "OwnerUserId": "1413395", "LastEditDate": "2016-05-02T19:25:14.460"}});