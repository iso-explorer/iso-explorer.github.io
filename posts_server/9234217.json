post_cb({"9234299": {"Id": "9234299", "PostTypeId": "2", "Body": "<p>What you're doing <em>may</em> be legal, but that depends on the real definition of <code>class T</code>, so we can't know for sure based on the code you've shown.</p>\n<p>Starting with C++11 \u00a73.9.2/3:</p>\n<blockquote>\n<p id=\"so_9234217_9234299_0\">Pointers to incomplete types are allowed although there are restrictions on what can be done with them.</p>\n</blockquote>\n<p>Those restrictions are listed in \u00a73.2/4:</p>\n<blockquote>\n<p id=\"so_9234217_9234299_1\">A class type <code>T</code> must be complete if:</p>\n<ul>\n<li>an object of type <code>T</code> is defined, or</li>\n<li>a non-static class data member of type <code>T</code> is declared, or</li>\n<li><code>T</code> is used as the object type or array element type in a <em>new-expression</em>, or</li>\n<li>an lvalue-to-rvalue conversion is applied to a glvalue referring to an object of type <code>T</code>, or</li>\n<li>an expression is converted (either implicitly or explicitly) to type <code>T</code>, or</li>\n<li>an expression that is not a null pointer constant, and has type other than <code>void*</code>, is converted to the type pointer to <code>T</code> or reference to <code>T</code> using an implicit conversion, a <code>dynamic_cast</code> or a <code>static_cast</code>, or</li>\n<li>a class member access operator is applied to an expression of type <code>T</code>, or</li>\n<li>the <code>typeid</code> operator or the <code>sizeof</code> operator is applied to an operand of type <code>T</code>, or</li>\n<li>a function with a return type or argument type of type <code>T</code> is defined or called, or</li>\n<li>a class with a base class of type <code>T</code> is defined, or</li>\n<li>an lvalue of type <code>T</code> is assigned to, or</li>\n<li>the type <code>T</code> is the subject of an <code>alignof</code> expression, or</li>\n<li>an <em>exception-declaration</em> has type <code>T</code>, reference to <code>T</code>, or pointer to <code>T</code>.</li>\n</ul>\n</blockquote>\n<p>The 6th bullet <em>appears</em> pertinent here, as we can see in \u00a75.2.10/7 that a <code>reinterpret_cast</code> between pointer types is defined in terms of <code>static_cast</code>:</p>\n<blockquote>\n<p id=\"so_9234217_9234299_2\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to cv <code>T2</code>\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>But because <code>reinterpret_cast</code> <code>static_cast</code>s to <code>void*</code> first, <em>then</em> to the real resulting pointer type, that 6th bullet doesn't apply.</p>\n<p>So, so far you're still in legal territory, despite <code>T</code> being an incomplete type. However, if it turns out that <code>T</code> is not a standard-layout type or has stricter alignment requirements than <code>int</code>, then the last sentence in \u00a75.2.10/7 holds true and you're invoking UB.</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2012-02-10T21:22:48.287", "Score": "4", "CreationDate": "2012-02-10T20:19:55.003", "ParentId": "9234217", "CommentCount": "0", "OwnerUserId": "636019", "LastEditDate": "2012-02-10T21:22:48.287"}, "9234343": {"Id": "9234343", "PostTypeId": "2", "Body": "<p>I'm not sure what you perceive as being allowed. There is a guarantee that you can <code>reinterpret_cast</code> from one pointer type to a sufficiently big other pointer type and back to the original type again and will be the original pointer. The specification for this is in 5.2.10 [expr.reinterpret.cast]. That is, the following is guaranteed to work:</p>\n<pre><code>T* ptr = ...;\nS* sptr = reinterpret_cast&lt;S*&gt;(ptr);\nT* tptr = reinterpret_cast&lt;T*&gt;(sptr);\nassert(ptr == tptr);\n</code></pre>\n<p>We had an out of session discussion earlier this week on this topic: if the Death Station 9000 implementation (which would be a conforming implementation of C++ but also tries to break user code wherever it is allowed to do so) XORs the bit pattern of the pointer with a bit pattern randomly chosen at the beginning of the program execution, would this be a permissible implementation if the types involved in the <code>reinterpret_cast&lt;T&gt;(x)</code> are not involving <code>char</code>. The consensus was that this would be OK.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-02-10T20:43:02.650", "Score": "0", "CreationDate": "2012-02-10T20:25:01.997", "ParentId": "9234217", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2012-02-10T20:43:02.650"}, "bq_ids": {"n4140": {"so_9234217_9234287_0": {"length": 40, "quality": 0.6557377049180327, "section_id": 6046}, "so_9234217_9234299_2": {"length": 40, "quality": 0.6557377049180327, "section_id": 6046}, "so_9234217_9234287_1": {"length": 44, "quality": 0.9565217391304348, "section_id": 6127}, "so_9234217_9234299_1": {"length": 4, "quality": 1.0, "section_id": 7042}, "so_9234217_9234299_0": {"length": 11, "quality": 1.0, "section_id": 7223}}, "n3337": {"so_9234217_9234287_0": {"length": 58, "quality": 0.9508196721311475, "section_id": 5814}, "so_9234217_9234299_2": {"length": 58, "quality": 0.9508196721311475, "section_id": 5814}, "so_9234217_9234287_1": {"length": 44, "quality": 0.9565217391304348, "section_id": 5891}, "so_9234217_9234299_1": {"length": 4, "quality": 1.0, "section_id": 6787}, "so_9234217_9234299_0": {"length": 11, "quality": 1.0, "section_id": 6967}}, "n4659": {"so_9234217_9234287_0": {"length": 39, "quality": 0.639344262295082, "section_id": 7545}, "so_9234217_9234299_2": {"length": 39, "quality": 0.639344262295082, "section_id": 7545}, "so_9234217_9234287_1": {"length": 44, "quality": 0.9565217391304348, "section_id": 7624}, "so_9234217_9234299_1": {"length": 4, "quality": 1.0, "section_id": 8539}, "so_9234217_9234299_0": {"length": 11, "quality": 1.0, "section_id": 8732}}}, "9234284": {"Id": "9234284", "PostTypeId": "2", "Body": "<p>Section 5.2.10 (7) for your case (as of ISO/IEC14882:1998(E), as well as in the 2011 FDIS).</p>\n", "LastActivityDate": "2012-02-10T20:18:35.220", "CommentCount": "0", "CreationDate": "2012-02-10T20:18:35.220", "ParentId": "9234217", "Score": "2", "OwnerUserId": "989510"}, "9234217": {"ViewCount": "846", "Body": "<p>Where in the C++ spec is this allowed?  It's cool.  I want to know how this is spec'd.  I didn't realize the spec allowed having a pointer to a undefined type.</p>\n<pre><code>class T;\n\nint main(int argc, char* argv[])\n{\n   int x;\n   T* p = reinterpret_cast&lt;T*&gt;(&amp;x);\n   return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "9234299", "Title": "Where does the C++ standard allow pointers to undefined types?", "CreationDate": "2012-02-10T20:12:25.307", "Id": "9234217", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-02-10T20:42:01.593", "LastEditorUserId": "33732", "LastActivityDate": "2012-02-10T21:22:48.287", "Score": "3", "OwnerUserId": "4778", "Tags": "<c++><forward-declaration><language-lawyer>", "AnswerCount": "4"}, "9234287": {"Id": "9234287", "PostTypeId": "2", "Body": "<p>The only thing you're allowed to do after casting a pointer to an unrelated type (other than <code>char*</code>), is cast back to the original pointer type.</p>\n<p>@cli_hlt beat me to providing the section.</p>\n<p>Here's the rule itself:</p>\n<blockquote>\n<p id=\"so_9234217_9234287_0\">An object pointer can be explicitly converted to an object pointer of a different type.\n  When a prvalue <code>v</code> of  type \"pointer to <code>T1</code>\"  is  converted  to  the  type  \"pointer  to  <em><code>cv</code></em> <code>T2</code>\",  the  result  is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv  void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>.  Converting a prvalue of type\n  \"pointer to <code>T1</code>\" to the type \"pointer to <code>T2</code>\" (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>The <em>strict aliasing rule</em> prohibits access to an object through an unrelated type.  See <a href=\"https://stackoverflow.com/a/7005988/103167\">https://stackoverflow.com/a/7005988/103167</a></p>\n<p>Another rule somewhat related to your question is found in section 5.4:</p>\n<blockquote>\n<p id=\"so_9234217_9234287_1\">The operand of a cast using the cast notation can be a prvalue of type \"pointer to incomplete class type\".  <strong>The destination type of a cast using the cast notation can be \"pointer to incomplete class type\"</strong>  If both the operand and destination types are class types and one or both are incomplete, it is unspecified whether the <code>static_cast</code> or the <code>reinterpret_cast</code> interpretation is used, even if there is an inheritance relationship\n  between the two classes. </p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-02-10T20:24:59.430", "Score": "4", "CreationDate": "2012-02-10T20:18:46.517", "ParentId": "9234217", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2017-05-23T10:30:20.080"}});