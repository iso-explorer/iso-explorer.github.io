post_cb({"17394128": {"ParentId": "17393842", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Workaround:</p>\n<pre><code> vector&lt;string&gt; args(argv, argv + argc);\n\n for (auto s: args) \n      cout &lt;&lt; s &lt;&lt; endl;\n</code></pre>\n<p><code>std::string</code> and <code>std::vector</code> are heavy weight objects.  Dynamic memory allocation is used during their construction. </p>\n<p>2nd way to do it is to use <a href=\"http://volnitsky.com/project/ro/\" rel=\"nofollow\">my RO library</a>.  Below code will create light weight <strong>iterator range</strong> object around <code>argv</code> array: </p>\n<pre><code> auto args = ro::range(argv,argv+argc);\n\n for (auto s: args) \n      cout &lt;&lt; s &lt;&lt; endl;\n</code></pre>\n", "OwnerUserId": "1173542", "LastEditorUserId": "1173542", "LastEditDate": "2013-08-01T09:37:58.393", "Id": "17394128", "Score": "8", "CreationDate": "2013-06-30T19:36:30.487", "LastActivityDate": "2013-08-01T09:37:58.393"}, "17393842": {"CommentCount": "9", "ViewCount": "814", "PostTypeId": "1", "LastEditorUserId": "2151629", "CreationDate": "2013-06-30T19:02:25.110", "LastActivityDate": "2013-08-01T09:37:58.393", "Title": "main () std::string instead of char** why the exclusion", "AcceptedAnswerId": "17393943", "LastEditDate": "2013-06-30T19:21:27.317", "Id": "17393842", "Score": "-2", "Body": "<p>The compiler gives the  warning\n<code>warning: second argument of \u2018int main(int, std::string*)\u2019 should be \u2018char **\u2019 [-Wmain]\n</code></p>\n<p>when I choose to put in </p>\n<p><code>int main(int argv, std::string a[])</code></p>\n<p>instead of </p>\n<p><code>int main(int argv, char * argc [])</code></p>\n<p>If you can come up with a reason ,also pray dotell what's wrong with the string approach.</p>\n<p>I mean with std::string being the posterchild of of character representation/string representation , for C++ , why bother with C styles?</p>\n<p><strong>ALSO</strong></p>\n<p>IS there really no hack around the standard implementation?</p>\n", "Tags": "<c++>", "OwnerUserId": "2151629", "AnswerCount": "3"}, "17394258": {"ParentId": "17393842", "CommentCount": "0", "Body": "<p>You've been given the reason why your implementation <em>need</em> not support it. However there's also a reason why your implementation would not <em>want</em> to support it:</p>\n<p>The (usually precompiled) code calling <code>main</code> passes an <code>int</code> and a <code>char**</code> (and in some implementations as extension a second <code>char**</code>; indeed, on many platforms it gets exactly that data already provided by the operating system and just passes it on). It is easy to support to ignore trailing arguments (usually they are pushed to the stack in reverse order, so ignoring the additional arguments just means not accessing them, no additional logic required). However, you cannot just read out a <code>char**</code> as <code>std::string*</code>, therefore the compiler would have to generate extra code to support this interface. Given that any source code using that interface would be non-portable anyway and few people would use it, and given that the original interface works just fine, it would just be a waste of resources to implement that alternative interface.</p>\n", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "17394258", "Score": "1", "CreationDate": "2013-06-30T19:50:44.543", "LastActivityDate": "2013-06-30T19:50:44.543"}, "bq_ids": {"n4140": {"so_17393842_17393943_2": {"section_id": 7146, "quality": 0.8695652173913043, "length": 40}, "so_17393842_17393943_0": {"section_id": 7146, "quality": 0.75, "length": 18}}, "n3337": {"so_17393842_17393943_2": {"section_id": 6890, "quality": 0.8695652173913043, "length": 40}, "so_17393842_17393943_0": {"section_id": 6890, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_17393842_17393943_2": {"section_id": 8647, "quality": 0.8695652173913043, "length": 40}, "so_17393842_17393943_0": {"section_id": 8647, "quality": 0.75, "length": 18}}}, "17393943": {"ParentId": "17393842", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>The reason is pretty simple: the language rules do not mandate your form and the implementation you use do not support it through its own choice.</p>\n<p>Quoting the standard  3.6.1p2</p>\n<blockquote>\n<p id=\"so_17393842_17393943_0\">An implementation shall not predefine the main function. This function shall not be overloaded. It shall have a return type of type int, but otherwise its type is implementation-defined. All implementations shall allow both of the following definitions of main:</p>\n</blockquote>\n<pre><code>int main() { /* ... */ }\n</code></pre>\n<blockquote>\n<p id=\"so_17393842_17393943_1\">and</p>\n</blockquote>\n<pre><code>int main(int argc, char* argv[]) { /* ... */ }\n</code></pre>\n<blockquote>\n<p id=\"so_17393842_17393943_2\">In the latter form argc shall be the number of arguments passed to the program from the environment in which the program is run. If argc is nonzero these arguments shall be supplied in argv[0] through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings (NTMBSs) (17.3.2.1.3.2) and argv[0] shall be the pointer to the initial character of a NTMBS that represents the name used to invoke the program or \"\". The value of argc shall be nonnegative. The value of argv[argc] shall be 0. [Note: it is recommended that any further (optional) parameters be added after argv. ]</p>\n</blockquote>\n<p>EDIT: to cover additional question:</p>\n<p>There is no need to \"hack\" anything, as nothing stops to use a function or a class that takes the original argc and argv and processes it to a vector literally, or better yet parse it and map processed data to internal variables.  We have a plenty of those floating around, and those who create more than a handful of main()-s per year probably already use one of those or their own. </p>\n", "OwnerUserId": "2422194", "LastEditorUserId": "2422194", "LastEditDate": "2013-06-30T19:30:50.437", "Id": "17393943", "Score": "10", "CreationDate": "2013-06-30T19:14:00.970", "LastActivityDate": "2013-06-30T19:30:50.437"}});