post_cb({"bq_ids": {"n4140": {"so_27603829_27603921_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 625}}, "n3337": {"so_27603829_27603921_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 615}}, "n4659": {"so_27603829_27603921_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 651}}}, "27603829": {"ViewCount": "90", "Body": "<p>I have a class hierarchy that can be written to an object using <code>operator&lt;&lt;</code>. The example looks as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base\n{\n};\n\nstruct Derived : public Base\n{\n};\n\nstruct Shift\n{\n    template&lt; typename U &gt;\n    Shift&amp; operator&lt;&lt;(const U&amp;)\n    {\n        std::cerr &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n        return *this;\n    }\n\n    Shift&amp; operator&lt;&lt;(const Base&amp;)\n    {\n        std::cerr &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n        return *this;\n    }\n\n#if 0\n    Shift&amp; operator&lt;&lt;(const Derived&amp;)\n    {\n        std::cerr &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n        return *this;\n    }\n#endif\n};\n\nint main()\n{\n    Shift sh;\n    Base bas;\n    Derived der;\n    int u32 = 0;\n\n    sh &lt;&lt; bas;\n    sh &lt;&lt; der;\n    sh &lt;&lt; u32;\n}\n</code></pre>\n<p>This produces the following output:</p>\n<pre><code>Shift&amp; Shift::operator&lt;&lt;(const Base&amp;)\nShift&amp; Shift::operator&lt;&lt;(const U&amp;) [with U = Derived]\nShift&amp; Shift::operator&lt;&lt;(const U&amp;) [with U = int]\n</code></pre>\n<p>If I uncomment the <code>#if 0</code> section it will change to the desired output:</p>\n<pre><code>Shift&amp; Shift::operator&lt;&lt;(const Base&amp;)\nShift&amp; Shift::operator&lt;&lt;(const Derived&amp;)\nShift&amp; Shift::operator&lt;&lt;(const U&amp;) [with U = int]\n</code></pre>\n<p>I have a lot of derived classes (actually a whole hierarchy) and until now I have to write a separate definition of <code>operator&lt;&lt;</code> for all those types. What I'd like is to have a solution where the operator for the base type is called for all types that are derived from <code>Base</code>. Is that possible?</p>\n<p>P.S.: I tried several solutions, for example writing a helper class:</p>\n<pre><code>struct Base\n{\n};\n\nstruct Derived : public Base\n{\n};\n\ntemplate&lt; typename T &gt;\nstruct Helper\n{\n    static void shift()\n    {\n        std::cerr &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    }\n};\n\ntemplate&lt; &gt;\nstruct Helper&lt; Base &gt;\n{\n    static void shift()\n    {\n        std::cerr &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    }\n};\n\nstruct Shift\n{\n    template&lt; typename U &gt;\n    Shift&amp; operator&lt;&lt;(const U&amp; value)\n    {\n        Helper&lt; U &gt;::shift();\n        return *this;\n    }\n};\n</code></pre>\n<p>Output:</p>\n<pre><code>static void Helper&lt;Base&gt;::shift()\nstatic void Helper&lt;T&gt;::shift() [with T = Derived]\nstatic void Helper&lt;T&gt;::shift() [with T = int]\n</code></pre>\n<p>But still the base template is called, instead of the <code>Base</code> specialization.</p>\n<p>P.P.S.: I'm currently limited to <code>C++03</code> without <code>Boost</code>, unfortunately.</p>\n", "AcceptedAnswerId": "27603921", "Title": "Template function gets called instead of function of base type", "CreationDate": "2014-12-22T13:38:36.513", "Id": "27603829", "CommentCount": "0", "LastEditDate": "2014-12-22T14:21:56.367", "PostTypeId": "1", "LastEditorUserId": "589206", "LastActivityDate": "2015-06-27T20:39:34.613", "Score": "1", "OwnerUserId": "589206", "Tags": "<c++><templates><overloading><template-specialization><c++03>", "AnswerCount": "1"}, "27603921": {"Id": "27603921", "PostTypeId": "2", "Body": "<p>In your current implementation the templated overload is preferred as per \u00a713.3.3.1.4 [over.ics.ref]/p1:</p>\n<blockquote>\n<p id=\"so_27603829_27603921_0\">When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion sequence is the identity conversion, unless the argument expression has a type that is a derived class of the parameter type, in which case the implicit conversion sequence is a <em>derived-to-base Conversion</em> (13.3.3.1).</p>\n</blockquote>\n<p>Since the <em>derived-to-base Conversion</em> is given a <em>Conversion</em> rank, to achieve the desired output the templated version with an <em>identity</em> conversion rank must be excluded from the set of viable functions during the overload resolution by using <code>enable_if</code> with a proper condition (SFINAE):</p>\n<pre><code>#include &lt;type_traits&gt;\n\n//...\ntemplate &lt;typename U&gt;\nauto operator&lt;&lt;(const U&amp;)\n    -&gt; typename std::enable_if&lt;!std::is_base_of&lt;Base, U&gt;{}, Shift&amp;&gt;::type\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    return *this;\n}\n\nShift&amp; operator&lt;&lt;(const Base&amp;)\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    return *this;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Shift&amp; Shift::operator&lt;&lt;(const Base&amp;)\nShift&amp; Shift::operator&lt;&lt;(const Base&amp;)\ntypename std::enable_if&lt;(! std::is_base_of&lt;Base, U&gt;{}), Shift&amp;&gt;::type Shift::operator&lt;&lt;(const U&amp;) [with U = int; typename std::enable_if&lt;(! std::is_base_of&lt;Base, U&gt;{}), Shift&amp;&gt;::type = Shift&amp;]\n</code></pre>\n<hr>\n<h3><em>C++03 zone</em>:</h3>\n<pre><code>template &lt;bool B, typename T = void&gt;\nstruct enable_if { typedef T type; };\ntemplate &lt;typename T&gt;\nstruct enable_if&lt;false, T&gt; {};\ntemplate &lt;typename Base, typename Derived&gt;\nstruct is_base_of\n{\n    typedef char (&amp;yes)[1];\n    typedef char (&amp;no)[2];\n    static yes test(Base*);\n    static no test(...);\n    static const bool value = sizeof(test((Derived*)0)) == sizeof(yes);\n};\ntemplate &lt;typename Base, typename Derived&gt;\nconst bool is_base_of&lt;Base, Derived&gt;::value;\n\n//...\ntemplate &lt;typename U&gt;\ntypename enable_if&lt;!is_base_of&lt;Base, U&gt;::value, Shift&amp;&gt;::type operator&lt;&lt;(const U&amp;)\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    return *this;\n}\n\nShift&amp; operator&lt;&lt;(const Base&amp;)\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n    return *this;\n}\n</code></pre>\n</hr>", "LastEditorUserId": "3953764", "LastActivityDate": "2015-06-27T20:39:34.613", "Score": "5", "CreationDate": "2014-12-22T13:44:30.670", "ParentId": "27603829", "CommentCount": "11", "OwnerUserId": "3953764", "LastEditDate": "2015-06-27T20:39:34.613"}});