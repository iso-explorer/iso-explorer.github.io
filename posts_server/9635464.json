post_cb({"9635597": {"ParentId": "9635464", "CommentCount": "6", "Body": "<p>Your program is ill-formed as per the C++ Standard and hence demonstrates a behavior which cannot be explained within the realms of the C++ standard.</p>\n<p>Reference:<br>\nC++03 Standard:   </br></p>\n<p><strong>15.4 Exception specifications   [except.spec]</strong> </p>\n<blockquote>\n<p id=\"so_9635464_9635597_0\"><strong>If a virtual function has an exception-specification, all declarations, including the definition, of any function that overrides that virtual function in any derived class shall only allow exceptions that are allowed by the exception-specificationof the base class virtual function.</strong> </p>\n<p id=\"so_9635464_9635597_1\">[Example:</p>\n</blockquote>\n<pre><code> struct B \n {\n    virtual void f() throw (int, double);\n    virtual void g();\n };\n struct D: B \n {\n    void f(); // ill-formed\n    void g() throw (int); // OK\n };\n</code></pre>\n<blockquote>\n<p id=\"so_9635464_9635597_2\">The declaration of <code>D::f</code>  is ill-formed because it allows all exceptions, whereas <code>B::f</code> allows only <code>int</code> and <code>double</code>. ]</p>\n</blockquote>\n", "OwnerUserId": "452307", "PostTypeId": "2", "Id": "9635597", "Score": "6", "CreationDate": "2012-03-09T14:23:49.187", "LastActivityDate": "2012-03-09T14:23:49.187"}, "9635739": {"ParentId": "9635464", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It evolved a bit in C++11 <strong>[except.spec]</strong>:</p>\n<blockquote>\n<p id=\"so_9635464_9635739_0\"><strong>5/</strong> If a virtual function has an exception-specification, all declarations, including the definition, of any function that overrides that virtual function in any derived class shall only allow exceptions that are allowed by the exception-specification of the base class virtual function.</p>\n</blockquote>\n<p>So you are never actually allowed to specify a <em>looser</em> exception specification.</p>\n<p>However this case is tricky because the destructor is actually synthetized by the compiler itself!</p>\n<p>In C++03, I think the Standard was not so careful about those, and you had to write them yourself, in C++11 however we get:</p>\n<blockquote>\n<p id=\"so_9635464_9635739_1\"><strong>14/</strong> An implicitly declared special member function (Clause 12) shall have an exception-specification. If <code>f</code> is an implicitly declared default constructor, copy constructor, move constructor, destructor, copy assignment operator, or move assignment operator, its implicit exception-specification specifies the type-id <code>T</code> if and only\n  if <code>T</code> is allowed by the exception-specification of a function directly invoked by <code>f</code>\u2019s implicit definition; <code>f</code> shall allow all exceptions if any function it directly invokes allows all exceptions, and <code>f</code> shall allow no exceptions if every function it directly invokes allows no exceptions.</p>\n</blockquote>\n<p>Where the compiler will generate the exception specification of the destructor so that it matches what can be thrown from the functions it calls (ie, the destructors of the attributes). If those destructors do not throw, then it will generate a <code>noexcept</code> destructor which will satisfy the base class constraint.</p>\n<p><em>Note: VS2005 is one of the least Standard compliant compiler you might find on Earth.</em></p>\n", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2012-03-09T14:50:40.760", "Id": "9635739", "Score": "5", "CreationDate": "2012-03-09T14:32:25.727", "LastActivityDate": "2012-03-09T14:50:40.760"}, "bq_ids": {"n4140": {"so_9635464_9635597_2": {"section_id": 3367, "quality": 0.9090909090909091, "length": 10}, "so_9635464_9635739_0": {"section_id": 3367, "quality": 1.0, "length": 21}, "so_9635464_9635739_1": {"section_id": 3376, "quality": 0.9423076923076923, "length": 49}, "so_9635464_9635597_0": {"section_id": 3367, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_9635464_9635597_2": {"section_id": 3237, "quality": 0.9090909090909091, "length": 10}, "so_9635464_9635739_0": {"section_id": 3237, "quality": 1.0, "length": 21}, "so_9635464_9635739_1": {"section_id": 3246, "quality": 1.0, "length": 52}, "so_9635464_9635597_0": {"section_id": 3237, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_9635464_9635739_0": {"section_id": 4132, "quality": 0.6190476190476191, "length": 13}, "so_9635464_9635597_0": {"section_id": 4132, "quality": 0.6190476190476191, "length": 13}}}, "9635464": {"CommentCount": "5", "AcceptedAnswerId": "9635597", "CreationDate": "2012-03-09T14:14:46.070", "LastActivityDate": "2012-03-09T14:50:40.760", "PostTypeId": "1", "ViewCount": "7344", "FavoriteCount": "3", "Title": "What the c++ standard says about loosing throw specifier in default destructor", "Id": "9635464", "Score": "19", "Body": "<p>Three different compilers show three different behaviours compiling this code:</p>\n<pre><code>class MyException : public std::exception\n{\n public:\n  MyException(std::string str) : m_str(str) {}\n  virtual const char * what() const throw () {return m_str.c_str(); }\n protected:\n  std::string m_str;\n};\n</code></pre>\n<p>Sun C++ 5.8 Patch 121017-22 2010/09/29: <strong>Warning</strong> Function MyException::~MyException() can throw only the exceptions thrown by the function std::exception::~exception() it overrides</p>\n<p>g++ 3.4.3: <strong>Error</strong>  looser throw specifier for `virtual MyException::~MyException()'</p>\n<p>Visual Studio 2005: <strong>It is very happy</strong> (neither error or warning)</p>\n<pre><code>class exception {\npublic:\n  exception () throw();\n  exception (const exception&amp;) throw();\n  exception&amp; operator= (const exception&amp;) throw();\n  virtual ~exception() throw();\n  virtual const char* what() const throw();\n}\n</code></pre>\n<p>I know what the problem is and how I can fix it:</p>\n<pre><code>class MyException : public std::exception\n{\n public:\n  MyException(std::string str) : m_str(str) {}\n  virtual const char * what() const throw () {return m_str.c_str(); }\n  ~MyException() throw() {}  &lt;------------ now it is fine!\n protected:\n  std::string m_str;\n};\n</code></pre>\n<p><strong>However I am wondering what the standard says in specific situation.</strong></p>\n<p>I ran another small test in Visual Studio 2005 and I have found something that really surprise me:</p>\n<pre><code>struct Base\n{\n    virtual int foo() const throw() { return 5; }\n};\n\nstruct Derived : public Base\n{\n    int foo() const { return 6; }\n};\n\nint main()\n{\n    Base* b = new Derived;\n    std::cout &lt;&lt; b-&gt;foo() &lt;&lt; std::endl; //&lt;-- this line print 6!!!\n    delete b;\n}\n</code></pre>\n<p>The signature of the two functions are different. How can this work? It seems that visual studio 2005 completely ignore the exception specification.</p>\n<pre><code>struct Base\n{\n    virtual int foo() const throw() { return 5; }\n};\n\nstruct Derived : public Base\n{\n    int foo() { return 6; } // I have removed the const keyword \n                            // and the signature has changed\n};\n\nint main()\n{\n    Base* b = new Derived;\n    std::cout &lt;&lt; b-&gt;foo() &lt;&lt; std::endl; // &lt;-- this line print 5\n    delete b;\n}\n</code></pre>\n<p><strong>Is this c++ standard? Is there any magic flag to set?</strong></p>\n<p><strong>What about VS2008 and VS2010?</strong></p>\n", "Tags": "<c++><visual-c++>", "OwnerUserId": "508175", "AnswerCount": "2"}});