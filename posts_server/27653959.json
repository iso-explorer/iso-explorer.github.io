post_cb({"27653999": {"ParentId": "27653959", "CommentCount": "0", "Body": "<p>It's a special rule in the standard.</p>\n<blockquote>\n<p id=\"so_27653959_27653999_0\">A name prefixed by a <em>nested-name-specifier</em> that nominates an enumeration type shall represent an enumerator of that enumeration.</p>\n</blockquote>\n<p>(C++11 [basic.lookup.qual]/5; same in N4296)</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "27653999", "Score": "2", "CreationDate": "2014-12-26T07:12:00.323", "LastActivityDate": "2014-12-26T07:12:00.323"}, "bq_ids": {"n4140": {"so_27653959_27653999_0": {"section_id": 7111, "quality": 1.0, "length": 9}, "so_27653959_27653959_0": {"section_id": 5470, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_27653959_27653999_0": {"section_id": 6855, "quality": 1.0, "length": 9}, "so_27653959_27653959_0": {"section_id": 5256, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_27653959_27653999_0": {"section_id": 8612, "quality": 1.0, "length": 9}, "so_27653959_27653959_0": {"section_id": 6904, "quality": 0.9583333333333334, "length": 23}}}, "27653959": {"CommentCount": "0", "ViewCount": "43", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "CreationDate": "2014-12-26T07:07:24.587", "LastActivityDate": "2014-12-27T02:46:24.747", "LastEditDate": "2014-12-27T02:46:24.747", "AcceptedAnswerId": "27653999", "LastEditorDisplayName": "user2953119", "Title": "Why does qualified name lookup find an unscoped enumerator?", "Id": "27653959", "Score": "0", "Body": "<p>Section, <code>N4296::7.2/11 [dcl.enum]</code>:</p>\n<blockquote>\n<p id=\"so_27653959_27653959_0\">Each enum-name and each unscoped enumerator is declared in the scope\n  that immediately contains the enum-specifier. Each scoped enumerator\n  is declared in the scope of the enumeration. These names obey the\n  scope rules defined for all names in (3.3) and (3.4).</p>\n</blockquote>\n<p>So it means, that unscoped enumerators aren't declared in the enumeration scope, but declared in the scope, immediately containing their. So, why does the qualified-name-lookup find such enumerators?</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum A{ x = -2, y = 2 };\n\nint a = x;\n\nint b = A::y; //OK, but it's not clear why?\n\nint main()\n{ \n    std::cout &lt;&lt; b &lt;&lt; std::endl; \n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/ab7ce1a70e273a8c\" rel=\"nofollow\">DEMO</a></strong></p>\n", "Tags": "<c++><enums>", "AnswerCount": "1"}});