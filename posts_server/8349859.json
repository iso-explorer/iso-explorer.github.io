post_cb({"8350189": {"ParentId": "8349859", "CommentCount": "2", "CreationDate": "2011-12-02T00:10:29.887", "OwnerUserId": "491591", "PostTypeId": "2", "Id": "8350189", "Score": "3", "Body": "<p>I don't have C++03 standard with me to check the wording there, so I will quote from FDIS n3290. I think the answer to this question is found in qualified name lookup rules in 3.4.3.2/2: </p>\n<blockquote>\n<p id=\"so_8349859_8350189_0\">For a namespace X and name m, the namespace-qualified lookup set S(X,m) is defined as follows: Let S0(X,m) be the set of all declarations of m in X and the inline namespace set of X (7.3.1). If S0(X,m) is not empty, S(X,m) is S0(X,m); otherwise, S(X,m) is the union of S(Ni,m) for all namespaces Ni nominated by using-directives in X and its inline namespace set.</p>\n</blockquote>\n<p>Now, remember that unnamed namespace is a uniquely named namespace with a using directive.</p>\n", "LastActivityDate": "2011-12-02T00:10:29.887"}, "8349859": {"CommentCount": "0", "AcceptedAnswerId": "8350189", "PostTypeId": "1", "LastEditorUserId": "229044", "CreationDate": "2011-12-01T23:28:44.143", "LastActivityDate": "2013-03-19T13:54:03.007", "LastEditDate": "2013-03-19T13:54:03.007", "ViewCount": "250", "FavoriteCount": "1", "Title": "namespaces having unnamed namespace with the same variable declared", "Id": "8349859", "Score": "7", "Body": "<p>I tried this dummy code below to test unnamed namespace.</p>\n<p>I have the following output</p>\n<pre><code> ctor 1\n ctor 0\n 3\n 5\n</code></pre>\n<p>I am a bit confused about this.</p>\n<ol>\n<li>I was expecting an error from the compiler saying that it cannot resolve\nan ambiguity regarding <code>a::m_a</code>. Instead it refers always to the\nless nested. Is it always the case? What rules C++ is following?</li>\n<li>It seems that the compiler creates variable CMyObj following the order\nwritten on the file. Is this always the case?</li>\n<li>is there any way to access the most nested <code>m_a</code> variable \nfrom <code>main()</code>?. </li>\n</ol>\n<pre><code>class CMyObj{     \n    public:\n    CMyObj(int a){std::cout  &lt;&lt; \"ctor \" &lt;&lt; a &lt;&lt; std::endl; }\n };\n namespace a{ \n      namespace{\n           int m_a=4;\n           int m_b=5;\n           CMyObj m_obj(1);\n      }  \n }\n namespace a{\n      int m_a=3;\n      CMyObj m_obj(0);\n }\n int main(){\n      std::cout &lt;&lt; a::m_a &lt;&lt; std::endl; // which one?\n      std::cout &lt;&lt; a::m_b &lt;&lt; std::endl; // how this is possible?\n      return 0;\n }\n</code></pre>\n", "Tags": "<c++><namespaces>", "OwnerUserId": "245416", "AnswerCount": "4"}, "8350226": {"ParentId": "8349859", "CommentCount": "0", "CreationDate": "2011-12-02T00:15:02.223", "OwnerUserId": "1013125", "PostTypeId": "2", "Id": "8350226", "Score": "0", "Body": "<p>There is no ambiguity because the scope of <code>namespace::&lt;unnamed&gt;::m_a</code> is the outer namespace (<code>namespace::a</code>). There is no way to access <code>namespace::&lt;unnamed&gt;::m_a</code> within the main function and that is why there is no ambiguity. Try the to compile the following code and you'll get the error:</p>\n<pre><code>namespace ns{\n  namespace {\n    int a = 2;\n  }\n  int a = 3;\n  int c = a;\n}\n</code></pre>\n<p>Global variables residing in the same translation unit will be initialized in the order they are declared. Initialization order of global variables declared in different translation units is undefined.</p>\n", "LastActivityDate": "2011-12-02T00:15:02.223"}, "8350162": {"ParentId": "8349859", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-12-02T00:08:09.710", "Score": "1", "LastEditorUserId": "21242", "LastEditDate": "2011-12-02T00:14:32.883", "Id": "8350162", "OwnerUserId": "21242", "Body": "<p>I should take time to find the exact definitions in the spec, but when you have an anonymous (unnamed) namespace, the compiler actually generates a mangled name. When you write </p>\n<pre><code>a::m_b \n</code></pre>\n<p>in the second <code>std::cout</code> statement, the compiler is automatically substituting the mangled name so you can access it. Incorporating from Gene Bushuyev's subsequent answer:</p>\n<blockquote>\n<p id=\"so_8349859_8350162_0\">Now, remember that unnamed namespace is a uniquely named namespace\n  with a using directive.</p>\n</blockquote>\n<p>In the case of the colliding names, the compiler knows what <code>a::m_a</code> means, so it uses that. It's the one at the top level of the namespace. I don't think there is any way to get to the unnamed namespace copy of m_a at this point.</p>\n<p>This page does a decent job of explaining namespaces. <a href=\"http://winterdom.com/dev/cpp/nspaces\" rel=\"nofollow\">Winterdom: On C++ Namespaces</a></p>\n", "LastActivityDate": "2011-12-02T00:14:32.883"}, "8350221": {"ParentId": "8349859", "CommentCount": "1", "CreationDate": "2011-12-02T00:14:06.657", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "8350221", "Score": "1", "Body": "<p>First look at this simplified code (and my simplified explanation, you can read \u00a73.4.3.2 for the details):</p>\n<pre><code>namespace a\n{\n    int x;\n}\n\nint main()\n{\n    int i = a::x;\n}\n</code></pre>\n<p>Consider what happens when we say <code>a::x</code>. First the compiler enumerates all the declarations of <code>x</code> in <code>a</code>. If it finds an unambiguous <code>x</code>, it finishes successfully. Otherwise it recursively searches the namespaces declared by a using-directive. If it never finds a result, the program is ill-formed.</p>\n<pre><code>namespace a\n{\n    int x;\n}\n\nnamespace b\n{\n    using namespace a;\n}\n\nint main()\n{\n    int i = b::x;\n}\n</code></pre>\n<p>Here, it doesn't find <code>x</code> in <code>b</code>, so it searches the namespace <code>a</code> (because of the using-directive) and finds it. It should now make sense why this isn't ambiguous:</p>\n<pre><code>namespace a\n{\n    int x;\n}\n\nnamespace b\n{\n    using namespace a;\n    int x;\n}\n\nint main()\n{\n    int i = b::x;\n}\n</code></pre>\n<p>Here it finds the <code>x</code> in <code>b</code> and never considers <code>a</code>. Now just consider that an unnamed namespace is actually just a namespace with a unique unknown name:</p>\n<pre><code>namespace b\n{\n    namespace\n    {\n        int x;\n    }\n\n    // this is what an unnamed namespace expands to (in exposition)\n    namespace __unique__ {}\n    using namespace __unique__;\n\n    namespace __unique__\n    {\n        int x;\n    }\n\n    int x;\n}\n\nint main()\n{\n    int i = b::x;\n}\n</code></pre>\n<p>Like before, the <code>x</code> in <code>b</code> is found without considering the unnamed namespace. Your code is similar.</p>\n", "LastActivityDate": "2011-12-02T00:14:06.657"}, "bq_ids": {"n4140": {"so_8349859_8350189_0": {"section_id": 7117, "quality": 0.7352941176470589, "length": 25}}, "n3337": {"so_8349859_8350189_0": {"section_id": 6861, "quality": 0.7352941176470589, "length": 25}}, "n4659": {"so_8349859_8350189_0": {"section_id": 8618, "quality": 0.7352941176470589, "length": 25}}}});