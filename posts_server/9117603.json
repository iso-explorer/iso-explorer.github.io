post_cb({"9117836": {"ParentId": "9117603", "CommentCount": "0", "Body": "<p><code>Base</code> can inherit <code>operator()</code> from <code>Type</code>, or from <code>BaseMixin</code> and if <code>Type</code> has <code>operator()</code> it hides <code>BaseMixin</code>'s operator.</p>\n<p>So, if <code>Type</code> has no <code>operator ()</code> defined, <code>Base</code>'s <code>operator()</code> can be casted implicitly to <code>BaseMixin</code>'s <code>operator()</code>. Then, <code>deduce(U*, Helper&lt;void (BaseMixin::*)(), &amp;U::operator()&gt;* = 0)</code> with <code>U==Base</code> will match. </p>\n<p>Oppositely, if <code>Type</code> has <code>operator()</code> defined, <code>Base</code>'s <code>operator()</code> cannot be casted to <code>BaseMixin</code>'s one, so <code>deduce(U*, Helper&lt;void (BaseMixin::*)(), &amp;U::operator()&gt;* = 0)</code> will not match.</p>\n", "OwnerUserId": "774651", "PostTypeId": "2", "Id": "9117836", "Score": "2", "CreationDate": "2012-02-02T18:28:08.907", "LastActivityDate": "2012-02-02T18:28:08.907"}, "9117603": {"CommentCount": "0", "AcceptedAnswerId": "9117779", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2012-02-02T18:12:01.890", "LastActivityDate": "2012-02-15T02:05:34.260", "LastEditDate": "2012-02-02T18:38:05.233", "ViewCount": "1445", "FavoriteCount": "4", "Title": "How does this has_member class template work?", "Id": "9117603", "Score": "4", "Body": "<p>I'm trying to understand how the following class template works (taken from <a href=\"http://groups.google.com/group/comp.lang.c++.moderated/msg/e5fbc9305539f699?pli=1\" rel=\"nofollow\">here</a>), but I couldn't understand it properly:</p>\n<pre><code>template &lt;typename Type&gt; \nclass has_member \n{ \n   class yes { char m;}; \n   class no { yes m[2];}; \n   struct BaseMixin \n   { \n     void operator()(){} \n   }; \n   struct Base : public Type, public BaseMixin {}; \n   template &lt;typename T, T t&gt;  class Helper{}; \n   template &lt;typename U&gt; \n   static no deduce(U*, Helper&lt;void (BaseMixin::*)(), &amp;U::operator()&gt;* = 0); \n   static yes deduce(...); \npublic: \n   static const bool result = sizeof(yes) == sizeof(deduce((Base*)(0))); \n};\n</code></pre>\n<p>More specifically, I don't understand the purpose of <code>BaseMixin</code> and the presence of <code>operator()</code> in it. Also, since <code>Base</code> is derived from it, I don't understand it as well. </p>\n<p>Even more specifically, when template parameter <code>Type</code> has defined <code>operator()</code>, why <em>only</em> then SFINAE is triggered, causing the first <code>deduce()</code> function to be ignored and the second one is chosen?</p>\n<hr>\n<p>Anyway, this is my test code:</p>\n<pre><code>struct A{};                             //SFINAE is triggered for A\nstruct B{ void operator()(){} };        //SFINAE is not triggered for B\nstruct C{ void operator()(int,int){} }; //SFINAE is not triggered for C\n\nint main() \n{       \n   std::cout &lt;&lt; std::boolalpha; //enable true/false instead of 1/0!\n   std::cout &lt;&lt; has_member&lt;A&gt;::result &lt;&lt; std::endl;\n   std::cout &lt;&lt; has_member&lt;B&gt;::result &lt;&lt; std::endl;\n   std::cout &lt;&lt; has_member&lt;C&gt;::result &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output(<a href=\"http://ideone.com/wWpaP\" rel=\"nofollow\">ideone</a>):</p>\n<pre><code>false\ntrue\ntrue\n</code></pre>\n</hr>", "Tags": "<c++><sfinae><template-meta-programming>", "OwnerUserId": "415784", "AnswerCount": "2"}, "9117779": {"ParentId": "9117603", "PostTypeId": "2", "CommentCount": "2", "Body": "<ul>\n<li><code>BaseMixin</code> has an <code>operator()</code> definition.</li>\n<li><code>Base</code> derives from both <code>Type</code> and <code>BaseMixin</code>, so if <code>Type</code> has an <code>operator()</code> then name lookup on <code>Base::operator()</code> will be ambiguous.</li>\n<li><code>deduce</code> is called for <code>Base*</code>, not <code>Type*</code>.</li>\n<li><code>Helper&lt;void (BaseMixin::*)(), &amp;U::operator()&gt;</code> will only instantiate if <code>&amp;U::operator()</code> unambiguously resolves to <code>BaseMixin::operator()</code>.</li>\n<li>Conversely, if <code>Helper&lt;void (BaseMixin::*)(), &amp;U::operator()&gt;</code> does <em>not</em> instantiate, it's because <code>Type</code> has its own <code>operator()</code> making name lookup on <code>&amp;U::operator()</code> ambiguous, and consequently the overload of <code>deduce</code> returning type <code>yes</code> is chosen.</li>\n</ul>\n<p>Standard citation regarding the second bullet \u2014 C++11 \u00a710.2/2-6:</p>\n<blockquote>\n<p id=\"so_9117603_9117779_0\">2 The following steps define the result of name lookup for a member name <code>f</code> in a class scope <code>C</code>.</p>\n<p id=\"so_9117603_9117779_1\">3 The <em>lookup set</em> for <code>f</code> in <code>C</code>, called <em>S(f,C)</em>, consists of two component sets: the <em>declaration set</em>, a set of members named <code>f</code>; and the <em>subobject set</em>, a set of subobjects where declarations of these members (possibly including <em>using-declaration</em>s) were found. In the declaration set, <em>using-declaration</em>s are replaced by the members they designate, and type declarations (including injected-class-names) are replaced by the types they designate. <em>S(f,C)</em> is calculated as follows:</p>\n<p id=\"so_9117603_9117779_2\">4 If <code>C</code> contains a declaration of the name <code>f</code>, the declaration set contains every declaration of <code>f</code> declared in <code>C</code> that satisfies the requirements of the language construct in which the lookup occurs. [ <em>Note:</em> Looking up a name in an <em>elaborated-type-specifier</em> or <em>base-specifier</em>, for instance, ignores all non-type declarations, while looking up a name in a <em>nested-name-specifier</em> ignores function, variable, and enumerator declarations. As another example, looking up a name in a <em>using-declaration</em> includes the declaration of a class or enumeration that would ordinarily be hidden by another declaration of that name in the same scope. \u2014<em>end note</em> ] If the resulting declaration set is not empty, the subobject set contains <code>C</code> itself, and calculation is complete.</p>\n<p id=\"so_9117603_9117779_3\">5 Otherwise (i.e., <code>C</code> does not contain a declaration of <code>f</code> or the resulting declaration set is empty), <em>S(f,C)</em> is initially empty. <strong>If <code>C</code> has base classes, calculate the lookup set for <code>f</code> in each direct base class subobject <em>B<sub>i</sub></em>, and merge each such lookup set <em>S(f,B<sub>i</sub>)</em> in turn into <em>S(f,C)</em>.</strong></p>\n<p id=\"so_9117603_9117779_4\">6 The following steps define the result of merging lookup set <em>S(f,B<sub>i</sub>)</em> into the intermediate <em>S(f,C)</em>:</p>\n<ul>\n<li>If each of the subobject members of <em>S(f,B<sub>i</sub>)</em> is a base class subobject of at least one of the subobject members of <em>S(f,C)</em>, or if <em>S(f,B<sub>i</sub>)</em> is empty, <em>S(f,C)</em> is unchanged and the merge is complete. Conversely, if each of the subobject members of <em>S(f,C)</em> is a base class subobject of at least one of the subobject members of <em>S(f,B<sub>i</sub>)</em>, or if <em>S(f,C)</em> is empty, the new <em>S(f,C)</em> is a copy of <em>S(f,B<sub>i</sub>)</em>.</li>\n<li><strong>Otherwise, if the declaration sets of <em>S(f,B<sub>i</sub>)</em> and <em>S(f,C)</em> differ, the merge is ambiguous: the new <em>S(f,C)</em> is a lookup set with an invalid declaration set and the union of the subobject sets.</strong> In subsequent merges, an invalid declaration set is considered different from any other.</li>\n<li>Otherwise, the new <em>S(f,C)</em> is a lookup set with the shared set of declarations and the union of the subobject sets.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2012-02-15T02:05:34.260", "Id": "9117779", "Score": "8", "CreationDate": "2012-02-02T18:23:42.537", "LastActivityDate": "2012-02-15T02:05:34.260"}, "bq_ids": {"n4140": {"so_9117603_9117779_3": {"section_id": 6993, "quality": 0.9666666666666667, "length": 29}, "so_9117603_9117779_4": {"section_id": 6994, "quality": 0.8333333333333334, "length": 10}, "so_9117603_9117779_1": {"section_id": 6991, "quality": 0.8636363636363636, "length": 38}, "so_9117603_9117779_0": {"section_id": 6990, "quality": 0.9090909090909091, "length": 10}, "so_9117603_9117779_2": {"section_id": 6992, "quality": 0.9523809523809523, "length": 60}}, "n3337": {"so_9117603_9117779_3": {"section_id": 6739, "quality": 0.9666666666666667, "length": 29}, "so_9117603_9117779_4": {"section_id": 6740, "quality": 0.8333333333333334, "length": 10}, "so_9117603_9117779_1": {"section_id": 6737, "quality": 0.9090909090909091, "length": 40}, "so_9117603_9117779_0": {"section_id": 6736, "quality": 0.9090909090909091, "length": 10}, "so_9117603_9117779_2": {"section_id": 6738, "quality": 0.9523809523809523, "length": 60}}, "n4659": {"so_9117603_9117779_3": {"section_id": 8491, "quality": 0.9666666666666667, "length": 29}, "so_9117603_9117779_0": {"section_id": 8488, "quality": 0.9090909090909091, "length": 10}, "so_9117603_9117779_1": {"section_id": 8489, "quality": 0.8636363636363636, "length": 38}, "so_9117603_9117779_4": {"section_id": 8492, "quality": 0.8333333333333334, "length": 10}, "so_9117603_9117779_2": {"section_id": 8490, "quality": 0.9523809523809523, "length": 60}}}});