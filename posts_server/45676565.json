post_cb({"45676565": {"CommentCount": "8", "AcceptedAnswerId": "45677030", "CreationDate": "2017-08-14T14:13:51.990", "LastActivityDate": "2017-08-14T14:44:56.117", "PostTypeId": "1", "ViewCount": "73", "FavoriteCount": "0", "Title": "Trouble with logic in very easy if-statement", "Id": "45676565", "Score": "-1", "Body": "<p>So I cant figure out the logic behind this very simple if-statement</p>\n<pre><code>int found = 0, value = 5;\nif (!found || \u2010\u2010value == 0)\ncout &lt;&lt; \"danger \";\ncout &lt;&lt; \"value = \" &lt;&lt; value &lt;&lt; endl;\n</code></pre>\n<p>Why does \"danger\" being written to the screen here? I thought since found = 0, !found is not euqual to zero. </p>\n", "Tags": "<c++><if-statement>", "OwnerUserId": "8338274", "AnswerCount": "3"}, "45677030": {"ParentId": "45676565", "CommentCount": "2", "Body": "<p>It seems that you are considering the condition in the if statement the following way</p>\n<pre><code>if ( ( !found == 0 ) || ( \u2010\u2010value == 0 ) )\n</code></pre>\n<p>However in C++ the condition in the if statement is equivalent to</p>\n<pre><code>if ( ( !found ) || ( \u2010\u2010value == 0 ) )\n</code></pre>\n<p>that in turn is equivalent to</p>\n<pre><code>if ( ( found == 0 ) || ( \u2010\u2010value == 0 ) )\n</code></pre>\n<p>So as the found is indeed equal to 0 then this subexpression <code>( found == 0 )</code> yields true and it is the result of the logical OR operator.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "45677030", "Score": "2", "CreationDate": "2017-08-14T14:38:00.987", "LastActivityDate": "2017-08-14T14:38:00.987"}, "45677161": {"ParentId": "45676565", "CommentCount": "1", "Body": "<p>You can decompose the test  statement into a logic that's closer to what the compiler does:</p>\n<pre><code>if (!found || --value == 0)\n{\n   cout &lt;&lt; \"danger\";\n} \n</code></pre>\n<p>Is understood logically by the compiler as something closer to this (expanded a bit for the example, since the assembly actually generated uses reverse logic...).</p>\n<pre><code>if (found == 0)   // !found\n{\n    cout &lt;&lt; \"danger\";    // if this is executed, the next test is not !\n}\nelse if (--value == 0)\n{\n    cout &lt;&lt; \"danger\";\n}\n</code></pre>\n<p>The compiler uses reverse logic, so it does not have to generate the <code>cout &lt;&lt; \"danger\"</code> statement twice.</p>\n<p>as in:</p>\n<pre><code>if (found == 0)\n{\n    goto print_danger;\n}\nelse \n{\n   -- value;        // this statement is never executed if (found == 0)\n   if (value != 0)\n   {\n      goto skip_print_danger;\n   }\n}\n\nprint_danger:\n  cout &lt;&lt; \"danger\";\n\nskip_print_danger:\n cout &lt;&lt; \"value = \" &lt;&lt; value;\n</code></pre>\n", "OwnerUserId": "2430669", "PostTypeId": "2", "Id": "45677161", "Score": "0", "CreationDate": "2017-08-14T14:44:56.117", "LastActivityDate": "2017-08-14T14:44:56.117"}, "bq_ids": {"n4140": {"so_45676565_45676607_2": {"section_id": 6072, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_45676565_45676607_2": {"section_id": 5840, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_45676565_45676607_2": {"section_id": 7568, "quality": 0.9047619047619048, "length": 19}}}, "45676607": {"ParentId": "45676565", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>When converting integers booleans, <code>0</code> is <code>false</code> and anything else is <code>true</code>:</p>\n<ol>\n<li><code>found == 0</code> - <code>found</code> is <code>0</code></li>\n<li><code>(bool)found == false</code> - <code>0</code> is interpreted as <code>false</code></li>\n<li><code>!found == true</code> - <code>not false</code> is <code>true</code></li>\n<li><code>(!found || anything else) == true</code> - if the first half of an <code>or</code> is <code>true</code>, the whole expression is <code>true</code>.</li>\n<li><code>if (!found || anything else) { // always hit! }</code></li>\n</ol>\n<p>Note that the boolean expressions <code>||</code> and <code>&amp;&amp;</code> have <em>short-circuiting</em>. So if the value of the entire expression is determined my the first sub-expression, the second sub-expression isn't even evaluation:</p>\n<ul>\n<li><code>true || who cares</code></li>\n<li><code>false &amp;&amp; who cares</code></li>\n</ul>\n<hr>\n<p>Language-lawyering:</p>\n<blockquote>\n<p id=\"so_45676565_45676607_0\">5.3.1 Unary operators [expr.unary.op]</p>\n<p id=\"so_45676565_45676607_1\">...</p>\n<p id=\"so_45676565_45676607_2\">9 The operand of the logical negation operator <code>!</code> is contextually converted to <code>bool</code> (Clause 4); its value is <code>true</code> if the converted operand is <code>false</code> and <code>false</code> otherwise. The type of the result is <code>bool</code>.</p>\n</blockquote>\n</hr>", "OwnerUserId": "1171191", "LastEditorUserId": "1171191", "LastEditDate": "2017-08-14T14:44:13.540", "Id": "45676607", "Score": "1", "CreationDate": "2017-08-14T14:16:21.413", "LastActivityDate": "2017-08-14T14:44:13.540"}});