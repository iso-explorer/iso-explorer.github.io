post_cb({"21518704": {"CommentCount": "11", "AcceptedAnswerId": "21519560", "CreationDate": "2014-02-03T02:01:16.973", "LastActivityDate": "2017-07-31T22:38:45.317", "PostTypeId": "1", "ViewCount": "14115", "FavoriteCount": "7", "Title": "How does C++ STL unordered_map resolve collisions?", "Id": "21518704", "Score": "31", "Body": "<p>How does C++ STL unordered_map resolve collisions?</p>\n<p>Looking at the <a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/\">http://www.cplusplus.com/reference/unordered_map/unordered_map/</a>, it says \"Unique keys\nNo two elements in the container can have equivalent keys.\"</p>\n<p>That should mean that the container is indeed resolving collisions. However, that page does not tell me how it is doing it. I know some ways to resolve collisions like using linked lists and/or probing. What I want to know is how the c++ STL unordered_map is resolving it.</p>\n", "Tags": "<c++><stl><unordered-map>", "OwnerUserId": "1575470", "AnswerCount": "2"}, "21519560": {"ParentId": "21518704", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The standard defines a little more about this than most people seem to realize.</p>\n<p>Specifically, the standard requires (\u00a723.2.5/9):</p>\n<blockquote>\n<p id=\"so_21518704_21519560_0\">The elements of an unordered associative container are organized into buckets. Keys with the same hash code appear in the same bucket.</p>\n</blockquote>\n<p>The interface includes a <code>bucket_count</code> that runs in constant time. (table 103). It also includes a <code>bucket_size</code> that has to run in time linear on the size of the bucket.</p>\n<p>That's basically describing an implementation that uses collision chaining. When you do use collision chaining, meeting all the requirements is somewhere between easy and trivial. <code>bucket_count()</code> is the number of elements in your array. <code>bucket_size()</code> is the number of elements in the collision chain. Getting them in constant and linear time respectively is simple and straightforward.</p>\n<p>By contrast, if you use something like linear probing or double hashing, those requirements become all but impossible to meet. Specifically, all the items that hashed to a specific value need to land in the same bucket, and you need to be able to count those buckets in constant time.</p>\n<p>But, if you use something like linear probing or double hashing, finding all the items that hashed to the same value means you need to hash the value, then walk through the \"chain\" of non-empty items in your table to find how many of those hashed to the same value. That's not linear on the number of items that hashed to the same value though--it's linear on the number of items that hashed to the same <em>or</em> a colliding value.</p>\n<p>With enough extra work and a fair amount of stretching the meaning of some of the requirements almost to the breaking point, it might be barely possible to create a hash table using something other than collision chaining, and still at least sort of meet the requirements--but I'm not really certain it's possible, and it would certain involve quite a lot of extra work.</p>\n<p>Summary: all practical implementations of <code>std::unordered_set</code> (or <code>unordered_map</code>) undoubtedly use collision chaining. While it might be (just barely) possible to meet the requirements using linear probing or double hashing, such an implementation seems to lose a great deal and gain nearly nothing in return.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2017-07-31T22:29:53.470", "Id": "21519560", "Score": "41", "CreationDate": "2014-02-03T04:15:51.600", "LastActivityDate": "2017-07-31T22:29:53.470"}, "bq_ids": {"n4140": {"so_21518704_21519560_0": {"section_id": 761, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_21518704_21519560_0": {"section_id": 748, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_21518704_21519560_0": {"section_id": 821, "quality": 0.8666666666666667, "length": 13}}}, "45426355": {"ParentId": "21518704", "CommentCount": "0", "Body": "<p>likely by chaining. One effective form of hashmap collision resolution is to implement it with a linked list. Thus if an entry ends up in collision with another hash, it'll simply append it to the collided entry's pointer node. I'll explain with code.</p>\n<pre><code>typedef struct mapnode {\n    const char *strKey;\n    void *pData;\n    struct mapnode *pNext;\n} mapnode_t;\n\ntypedef struct hashmap {\n    mapnode_t **ppTable;\n    unsigned uiLength; // how big is the table?\n    unsigned uiCount; // how many entries do we really have?\n} hashmap_t;\n\n// excerpt from hashmap_insert\nmapnode_t *node = malloc( sizeof(mapnode_t) );\nif( !node ) {\n    printf(\"**** Memory Allocation Error **** hashmap_insert::node is NULL\\n\");\n    return false;\n}\nnode-&gt;strKey = szKey;\nnode-&gt;pData = pData;\n\nunsigned hash = gethash(szKey) % d-&gt;uiLength;\nnode-&gt;pNext = d-&gt;ppTable[hash];\nd-&gt;ppTable[hash] = node;\n++d-&gt;uiCount;\n</code></pre>\n<p>As you can see from the last portion. When you get the hash value that your entry will be placed in, we first emplace the node's <code>pNext</code> pointer to point at whatever <code>ppTable[hash]</code> already has; if it's null, the pointer will be null either way. After setting the node's pointer, we set the node as the new hash index's value and increment <code>uiCount</code> as we successfully placed a new entry.</p>\n", "OwnerUserId": "5737217", "PostTypeId": "2", "Id": "45426355", "Score": "0", "CreationDate": "2017-07-31T22:38:45.317", "LastActivityDate": "2017-07-31T22:38:45.317"}});