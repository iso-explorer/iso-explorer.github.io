post_cb({"bq_ids": {"n4140": {"so_17683591_17683799_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 5964}, "so_17683591_17683799_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5964}}, "n3337": {"so_17683591_17683799_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 5733}, "so_17683591_17683799_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5733}}, "n4659": {"so_17683591_17683799_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 7453}, "so_17683591_17683799_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7453}}}, "17683799": {"Id": "17683799", "PostTypeId": "2", "Body": "<p>The closure type is the type created by a lambda expression. Its call operator (i.e., <code>operator ()</code>) is declared as <code>inline</code> as per 5.1.2/5 (emphasis is mine):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_17683591_17683799_1\">The closure type for a <em>lambda-expression</em> has a <strong>public <code>inline</code> function call operator</strong> (13.5.4) whose parameters and return type are described by the <em>lambda-expression</em>\u2019s <em>parameter-declaration-clause</em> and <em>trailing-return-type</em> respectively.</p>\n</blockquote>\n</blockquote>\n<p>In addition, the compiler can effectively see the definition of the call operator and, therefore, is able to inline the function call.</p>\n", "LastActivityDate": "2013-07-16T18:01:21.353", "CommentCount": "2", "CreationDate": "2013-07-16T18:01:21.353", "ParentId": "17683591", "Score": "2", "OwnerUserId": "1137388"}, "17683630": {"Id": "17683630", "PostTypeId": "2", "Body": "<p>As you say, calls through function pointers often can't be inlined since the target function may only be known at run time.</p>\n<p>A lambda can be inlined here. Its type (deduced as the template parameter <code>Fun</code>) is known at compile time; and therefore the function itself (<code>Fun::operator()</code>) is also known then.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-07-16T17:56:24.440", "Score": "4", "CreationDate": "2013-07-16T17:51:14.133", "ParentId": "17683591", "CommentCount": "1", "OwnerUserId": "204847", "LastEditDate": "2013-07-16T17:56:24.440"}, "17683591": {"ViewCount": "168", "Body": "<p>For example, I have a function template</p>\n<pre><code>template&lt;class Fun&gt;\nvoid Foo(Fun f)\n{\n   ...\n}\n</code></pre>\n<p>And the argument is a function object or a function pointer. If it is a normal function pointer, the performance is not good since the function cannot be inline. How about using a lambda function here? Thanks.</p>\n", "AcceptedAnswerId": "17683630", "Title": "Performance of using lambda function in template?", "CreationDate": "2013-07-16T17:48:32.943", "Id": "17683591", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-07-16T18:01:21.353", "Score": "1", "OwnerUserId": "1899020", "Tags": "<c++><templates><lambda>", "AnswerCount": "2"}});