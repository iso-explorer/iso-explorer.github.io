post_cb({"13674767": {"LastEditDate": "2012-12-02T23:55:30.563", "Body": "<p>Can one in C++11 somehow in <code>gcc</code> mark a function (not a class method) as <code>const</code> telling that it is <strong>pure</strong> and does not use the global memory but only its arguments?</p>\n<p>I've tried <code>gcc</code>'s <code>__attribute__((const))</code> and it is <strong>precisely</strong> what I want. But it does not produce any compile time error when the global memory is touched in the function.</p>\n<p><strong>Edit 1</strong></p>\n<p><strong>Please be careful</strong>. I mean pure functions. <strong>Not constant functions</strong>. GCC's attribute is a little bit confusing. Pure functions only use their arguments.</p>\n", "LastEditorUserId": "8368", "Score": "6", "AcceptedAnswerId": "13674901", "CommentCount": "7", "OwnerUserId": "684534", "Title": "Pure functions in C++11", "LastActivityDate": "2012-12-02T23:55:56.600", "PostTypeId": "1", "Tags": "<c++><gcc><c++11>", "AnswerCount": "2", "FavoriteCount": "1", "Id": "13674767", "ViewCount": "2858", "CreationDate": "2012-12-02T22:46:06.970"}, "13674901": {"PostTypeId": "2", "ParentId": "13674767", "Body": "<p>Are you looking for <code>constexpr</code>? This tells the compiler that the function may be evaluated at compile time. A <code>constexpr</code> function must have literal return and parameter types and the body can only contain static asserts, typedefs, using declarations and directives and one return statement. A <code>constexpr</code> function may be called in a constant expression.</p>\n<pre><code>constexpr int add(int a, int b) { return a + b; }\n\nint x[add(3, 6)];\n</code></pre>\n<hr>\n<p>Having looked at the meaning of <code>__atribute__((const))</code>, the answer is no, you cannot do this with standard C++. Using <code>constexpr</code> will achieve the same effect, but only on a much more limited set of functions. There is nothing stopping a compiler from making these optimizations on its own, however, as long as the compiled program behaves the same way (the as-if rule).</p>\n</hr>", "LastEditorUserId": "150634", "LastActivityDate": "2012-12-02T23:16:41.933", "LastEditDate": "2012-12-02T23:16:41.933", "CommentCount": "4", "Id": "13674901", "OwnerUserId": "150634", "Score": "4", "CreationDate": "2012-12-02T23:01:17.480"}, "13674891": {"PostTypeId": "2", "ParentId": "13674767", "Body": "<p>using just standard C++11:</p>\n<pre><code>namespace g{ int x; }\n\nconstexpr int foo()\n{\n    //return g::x = 42;  Nah, not constant\n    return 42;      // OK\n}\n\nint main()\n{}\n</code></pre>\n<hr>\n<p>here's another example:</p>\n<pre><code>constexpr int foo( int blah = 0 )\n{\n    return blah + 42;      // OK\n}\n\nint main( int argc, char** )\n{\n    int bah[foo(2)];            // Very constant.\n    int const troll = foo( argc );  // Very non-constant.\n}\n</code></pre>\n<hr>\n<p>The meaning of GCC's <code>__attribute__( const )</code> is documented in the <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html#index-g_t_0040code_007bconst_007d-function-attribute-2507\" rel=\"nofollow noreferrer\">GNU compiler docs</a> as \u2026</p>\n<blockquote>\n<p id=\"so_13674767_13674891_0\">Many functions do not examine any values except their arguments, and have no effects except the return value. Basically this is just slightly more strict class than the <code>pure</code> attribute below, since function is not allowed to read global memory.</p>\n</blockquote>\n<p>One may take that to mean that the function result should only depend on the arguments, and that the function should have no side effects.</p>\n<p>This allows a more general class of functions than C++11 <code>constexpr</code>, which makes the function <code>inline</code>, restricts arguments and function result to <em>literal types</em>, and restricts the \"active\" statements of the function body to a single <code>return</code> statement, where (C++11 \u00a77.1.5/3)</p>\n<blockquote>\n<p id=\"so_13674767_13674891_1\">\u2014 every constructor call and implicit conversion used in initializing the return value (6.6.3, 8.5) shall be one of those allowed in a constant expression (5.19)</p>\n</blockquote>\n<p>As an example, it is difficult (I would think not impossible, but difficult) to make a <code>constexpr</code> <code>sin</code> function.</p>\n<p>But the purity of the result matters only to two parties:</p>\n<ul>\n<li><p>When known to be pure, the compiler can elide calls with known results.<br>\nThis is mostly an optimization of macro-generated code. Replace macros with <code>inline</code> functions to avoid silly generation of identical sub-expressions.</br></p></li>\n<li><p>When known to be pure, a programmer can remove a call entirely.<br>\nThis is just a matter of proper <em>documentation</em>. :-)</br></p></li>\n</ul>\n<p>So instead of looking for a way to express the purity of e.g. <code>sin</code> in the language, I suggest just avoid code generation via macros, and document pure functions as such.</p>\n<p>And use <code>constexpr</code> for the functions where it's practically possible (unfortunately, as of Dec. 2012 the latest Visual C++ compiler doesn't yet support <code>constexpr</code>).</p>\n<hr>\n<p>There is a previous SO question about <a href=\"https://stackoverflow.com/questions/5462388/relation-betwean-constexpr-and-pure-functions\">the relationship between <em>pure</em> and <code>constexpr</code></a>. Mainly, every <code>constexpr</code> function is <em>pure</em>, but not vice versa.</p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-02T23:55:56.600", "LastEditDate": "2017-05-23T12:10:33.327", "CommentCount": "9", "Id": "13674891", "OwnerUserId": "464581", "Score": "0", "CreationDate": "2012-12-02T23:00:44.950"}, "bq_ids": {"n3337": {"so_13674767_13674891_1": {"quality": 0.8666666666666667, "length": 13, "section_id": 5214}}}});