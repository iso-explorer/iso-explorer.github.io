post_cb({"16913904": {"ParentId": "16913451", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-06-04T09:12:02.860", "Score": "2", "LastEditorUserId": "410767", "LastEditDate": "2013-06-04T09:18:38.767", "Id": "16913904", "OwnerUserId": "410767", "Body": "<p>You're right that the way protected only grants access to the embedded base object can be surprising... but there's a good reason for it.  Say you have a couple classes derived from <code>Base</code>, and a method in one of those classes wanted to do things to an arbitrary <code>Base</code> object via some reference or pointer... it might be that the <code>Base</code> it's fiddling with is part of the other derivation chain, which has other behavioural expectations of the <code>Base</code> object given the usage it makes of the protected member functions.  You're effectively removing the encapsulation that the other derived class intended, preventing it enforcing intended invariants, stepping outside the world of good OO behaviours....  Applying this insight to your specific scenario, the C++ rules are preventing you using that protected constructor to make a subobject that was expected to have invariants policed by some derived class, when there is actually no derived object into which that <code>Base</code> object will be embedded.</p>\n<p>Separately, the way <code>protected</code> works for constructors has clear utility - it prevents construction of the class (using that constructor) except as a subobject of the derived class, or from member functions of the base class (such as <code>makeA</code> in your example) - whether they're static or non-static member functions is irrelevant... all member functions always have full to the class.</p>\n<p>What would be the utility in ignoring the intuitive meanings of <code>private</code>/<code>protected</code>/<code>public</code> for static member functions?  You're saying you expect them to be effectively private, if that's behaviour you want then just make them private / if you need them accessible leave them protected.  Clearly the protected access is limited as per the justification in my first paragraph.</p>\n", "LastActivityDate": "2013-06-04T09:18:38.767"}, "16913683": {"ParentId": "16913451", "CommentCount": "2", "CreationDate": "2013-06-04T09:01:41.543", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16913683", "Score": "10", "Body": "<blockquote>\n<p id=\"so_16913451_16913683_0\">But then, why is it allowed (at least in GCC 4.6.3) to call static protected methods?</p>\n</blockquote>\n<p>Because that's what the Standard says. The constraints that apply to the accessibility of <code>protected</code> members (and that the answer you linked explains very well) are defined in paragraph  11.4/1 of the C++11 Standard, whose first sentence specifies:</p>\n<blockquote>\n<p id=\"so_16913451_16913683_1\">An additional access check beyond those described earlier in Clause 11 is applied when a <strong>non-static</strong> data\n  member or <strong>non-static member</strong> function is a protected member of its naming class (11.2). [...]</p>\n</blockquote>\n<p>The additional access check does not apply to static members or static member functions.</p>\n", "LastActivityDate": "2013-06-04T09:01:41.543"}, "16913451": {"CommentCount": "2", "AcceptedAnswerId": "16913683", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-06-04T08:49:13.660", "LastActivityDate": "2013-06-04T10:35:59.023", "LastEditDate": "2017-05-23T12:00:10.877", "ViewCount": "5480", "FavoriteCount": "1", "Title": "Why calling a protected static method in derived classes is allowed?", "Id": "16913451", "Score": "9", "Body": "<p>Invoking a protected constructor in a derived class is not allowed, as explained <a href=\"https://stackoverflow.com/questions/2393325/one-question-about-protected-constructor\">here</a>.</p>\n<p>The accepted answer explains that <code>protected</code> grants access to members of an object of base class <code>A</code> only when that object of class <code>A</code> is a subobject of class <code>B</code>. So far, so good.</p>\n<p>But then, why is it allowed (at least in GCC 4.6.3) to call static protected methods? Specifically, it doesn't make any sense to me that the following compiles, while the commented line does not:</p>\n<pre><code>class A \n{\nprotected:\n    A() {}\n    static A makeA() { return A(); }\n};\n\nclass B: public A\n{\npublic:\n    static A makeAFromB()\n    {\n        return makeA(); // compiles\n        // return A();  // does not compile\n    }\n};\n</code></pre>\n<p>Philosophically, a constructor is pretty much like a static method returning an object of class <code>A</code>, reason why I don't get the difference in behaviour here.</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "1951907", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16913451_16913683_1": {"section_id": 6695, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_16913451_16913683_1": {"section_id": 6450, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_16913451_16913683_1": {"section_id": 8170, "quality": 0.9545454545454546, "length": 21}}}, "16913913": {"ParentId": "16913451", "CommentCount": "0", "CreationDate": "2013-06-04T09:12:21.460", "OwnerUserId": "2447530", "PostTypeId": "2", "Id": "16913913", "Score": "0", "Body": "<p>Static methods are inherited in the sense that they're available amongst the child class's methods. We can call a static method using the child class's name, or using an instance of the child class, or without qualification in the body of a child class. </p>\n", "LastActivityDate": "2013-06-04T09:12:21.460"}});