post_cb({"18588096": {"ParentId": "18586189", "CommentCount": "1", "CreationDate": "2013-09-03T09:00:59.510", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "18588096", "Score": "4", "Body": "<p>To explain why the compiler has to do \"all or nothing\" when it comes to where to store the <code>struct</code>: In most processors, memory pages are 4KB (a few has 8KB pages). That is the granularity of \"read only\" vs \"read/write\" memory blocks. So you can't have one 4-byte integer in read-only memory, and then the next 4 byte integer in read-write memory (unless they are exactly straddling a 4KB memory boundary - but that would definitely make for quite wasteful use of memory if you have an array of 3000 of them, taking up 12MB). </p>\n<p>Note that this is not an \"optimisation\". Read-only memory is not faster than read-write memory. It's a protection against users being silly with <code>const</code> and writing to the data they shouldn't write to. </p>\n<p>Also if you add a constructor that \"does something\" to your <code>struct</code>, it will most likely store the struct in read-write memory, because it's quite tricky for the compiler to generate code to switch read-only on and off at runtime.</p>\n", "LastActivityDate": "2013-09-03T09:00:59.510"}, "18586375": {"ParentId": "18586189", "CommentCount": "3", "CreationDate": "2013-09-03T07:22:02.023", "OwnerUserId": "1922748", "PostTypeId": "2", "Id": "18586375", "Score": "1", "Body": "<p>The keyword \"const\" is more a label for the programmer team like \"private\" and \"public\" not a compiler directive or compiler hint. A compiler can use it for optimization but don't need to. The compiler have only to control the abuse and prevent it. So the behavior you see is totally ok. \nAnd no, it is impossible that parts of one struct instance or class instance exist in different memory areas (do not count mapping in). Because that decision would impact the use of the struct and has to be allowed by the programmer. </p>\n", "LastActivityDate": "2013-09-03T07:22:02.023"}, "18586189": {"CommentCount": "0", "AcceptedAnswerId": "18588096", "CreationDate": "2013-09-03T07:10:20.177", "LastActivityDate": "2013-09-03T09:00:59.510", "PostTypeId": "1", "ViewCount": "362", "FavoriteCount": "2", "Title": "Does mutable member disable const optimizations for non-mutable members?", "Id": "18586189", "Score": "5", "Body": "<p>As far as I know in C++ struct/class members with the same access control are stored in memory in declaration order. Is next example <code>m</code> and <code>c</code> should be stored one after the other:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nstruct X\n{\n    mutable int m;\n    int         c;\n};\n\nconst X cx = {0, 1};\n\nint main()\n{   \n    X&amp; x = const_cast&lt;X&amp;&gt;(cx);\n\n    x.m = rand();\n    x.c = rand();\n\n    std::cout&lt;&lt;x.m&lt;&lt;\" \"&lt;&lt;x.c;\n}\n</code></pre>\n<p>In this example the program runs and prints 2 random numbers. If I remove <code>mutable</code> it crashes because <code>cx</code> is stored in readonly protected memory. </p>\n<p>This made me wonder - does one <code>mutable</code> member disable <code>const</code> optimizations for the entire <code>struct</code>(somehow make all members <code>mutable</code>)? </p>\n<p>Is it possible to store parts of a <code>struct</code> in readonly memory and other parts on non-readonly memory and respect C++ standard memory layout?</p>\n<p>This was tested using Visual Studio 2010 on Windows 7 and GCC 4.7.2 on Ubuntu.</p>\n", "Tags": "<c++><const><mutable>", "OwnerUserId": "336578", "AnswerCount": "3"}, "18586708": {"ParentId": "18586189", "CommentCount": "2", "CreationDate": "2013-09-03T07:41:10.063", "OwnerUserId": "1394283", "PostTypeId": "2", "Id": "18586708", "Score": "5", "Body": "<p>The standard talks about <code>mutable</code> members in many places. I quote below three parts of the standard explaining that you can modify only the <code>mutable</code> members of a <code>const</code> object. Otherwise it is <em>Undefined Behaviour</em>.</p>\n<blockquote>\n<p id=\"so_18586189_18586708_0\"><strong>3.9.3 CV-qualifiers [basic.type.qualifier]</strong></p>\n<p id=\"so_18586189_18586708_1\">A <em>const object</em> is an object of type <code>const T</code> or a non-mutable subobject of such an object.</p>\n<p id=\"so_18586189_18586708_2\"><strong>[...]</strong></p>\n<p id=\"so_18586189_18586708_3\"><strong>7.1.1 Storage class specifiers [dcl.stc]</strong></p>\n<p id=\"so_18586189_18586708_4\">The <code>mutable</code> specifier on a class data member nullifies a const specifier applied to the containing class object and permits modification of the <code>mutable</code> class member even though the rest of the object is <code>const</code>.</p>\n<p id=\"so_18586189_18586708_5\"><strong>[...]</strong></p>\n<p id=\"so_18586189_18586708_6\"><strong>7.1.6.1 The cv-qualifiers [dcl.type.cv]</strong></p>\n<p id=\"so_18586189_18586708_7\">Except that any class member declared <code>mutable</code> (7.1.1) can be modified, any attempt to modify a <code>const</code> object during its lifetime (3.8) results in <strong>undefined behavior</strong>. </p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_18586189_18586708_8\">Is it possible to store parts of a <code>struct</code> in readonly memory and other parts on non-readonly memory and respect C++ standard memory layout?</p>\n</blockquote>\n<p>No, it is impossible to store a parts of a <code>struct</code> (or <code>class</code>) in a different memory area than the rest of the object.</p>\n</hr>", "LastActivityDate": "2013-09-03T07:41:10.063"}, "bq_ids": {"n4140": {"so_18586189_18586708_4": {"section_id": 5400, "quality": 0.9565217391304348, "length": 22}, "so_18586189_18586708_1": {"section_id": 7225, "quality": 0.8888888888888888, "length": 8}, "so_18586189_18586708_7": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_18586189_18586708_4": {"section_id": 5195, "quality": 0.9565217391304348, "length": 22}, "so_18586189_18586708_1": {"section_id": 750, "quality": 0.6666666666666666, "length": 6}, "so_18586189_18586708_7": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_18586189_18586708_4": {"section_id": 6825, "quality": 0.9565217391304348, "length": 22}, "so_18586189_18586708_1": {"section_id": 8735, "quality": 0.8888888888888888, "length": 8}, "so_18586189_18586708_7": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}});