post_cb({"7190915": {"ParentId": "7190424", "CommentCount": "1", "CreationDate": "2011-08-25T13:08:44.387", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "7190915", "Score": "14", "Body": "<p>You are actually violating a C++ rule here (emphasis mine):</p>\n<blockquote>\n<p id=\"so_7190424_7190915_0\"><strong>14.7.3 [temp.expl.spec]</strong>:</p>\n<p id=\"so_7190424_7190915_1\"><strong>6/</strong> If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; <strong>no diagnostic is required</strong>. If the program\n  does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, <strong>the program is ill-formed, no diagnostic required</strong>. An implicit instantiation is never generated for an explicit specialization that is declared but not defined. [ <em>Example</em>:</p>\n</blockquote>\n<pre><code>class String { };\n\ntemplate&lt;class T&gt; class Array { /* ... */ };\ntemplate&lt;class T&gt; void sort(Array&lt;T&gt;&amp; v) { /* ... */ }\n\nvoid f(Array&lt;String&gt;&amp; v) {\n  sort(v); // use primary template\n  // sort(Array&lt;T&gt;&amp;), T is String\n}\n\ntemplate&lt;&gt; void sort&lt;String&gt;(Array&lt;String&gt;&amp; v); // error: specialization\n                                                // after use of primary template\n\ntemplate&lt;&gt; void sort&lt;&gt;(Array&lt;char*&gt;&amp; v); // OK: sort&lt;char*&gt; not yet used\n\ntemplate&lt;class T&gt; struct A {\n  enum E : T;\n  enum class S : T;\n};\n\ntemplate&lt;&gt; enum A&lt;int&gt;::E : int { eint }; // OK\ntemplate&lt;&gt; enum class A&lt;int&gt;::S : int { sint }; // OK\ntemplate&lt;class T&gt; enum A&lt;T&gt;::E : T { eT };\ntemplate&lt;class T&gt; enum class A&lt;T&gt;::S : T { sT };\ntemplate&lt;&gt; enum A&lt;char&gt;::E : int { echar }; // ill-formed,\n                                            // A&lt;char&gt;::E was instantiated\n                                            // when A&lt;char&gt; was instantiated\ntemplate&lt;&gt; enum class A&lt;char&gt;::S : int { schar }; // OK\n</code></pre>\n<blockquote>\n<p id=\"so_7190424_7190915_2\">\u2014<em>end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2011-08-25T13:08:44.387"}, "bq_ids": {"n4140": {"so_7190424_7190915_1": {"section_id": 268, "quality": 0.9833333333333333, "length": 59}}, "n3337": {"so_7190424_7190915_1": {"section_id": 259, "quality": 0.9833333333333333, "length": 59}}, "n4659": {"so_7190424_7190915_1": {"section_id": 275, "quality": 0.9833333333333333, "length": 59}}}, "7190424": {"CommentCount": "10", "AcceptedAnswerId": "7190915", "PostTypeId": "1", "LastEditorUserId": "393756", "CreationDate": "2011-08-25T12:34:28.930", "LastActivityDate": "2011-08-25T15:00:06.203", "LastEditDate": "2011-08-25T15:00:06.203", "ViewCount": "3168", "FavoriteCount": "2", "Title": "C++ linking and template specializations", "Id": "7190424", "Score": "12", "Body": "<p>I'm studying the behavior of the C++ linker with respect to template specializations. I'm using Microsoft Visual C++ 2010 for these experiments. I don't know if the behavior is the same with other toolchains (e.g. gcc).</p>\n<p>Here's a first code snippet:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// bar.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\nint bar() { return foo&lt;double&gt;(); }\n\n// main.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\ntemplate &lt;&gt; int foo&lt;double&gt;() { return 2; }\n\nint bar();\n\nint main()\n{\n    const int x = bar();\n    const int y = foo&lt;double&gt;();  // doesn't link\n}\n</code></pre>\n<p>Expectedly, this code doesn't link because <code>foo&lt;double&gt;()</code> has multiple definitions as it gets instantiated once in <em>bar.cpp</em> and once in <em>main.cpp</em> (via specialization). We would then expect, <em>if this program would link</em>, that <code>bar()</code> and <code>main()</code> would use distinct instantiations of <code>foo()</code> such that at the end we would have x\u00a0==\u00a01 and y\u00a0==\u00a02.</p>\n<p>Let's fix the link error by declaring the specialization of <code>foo&lt;double&gt;()</code> as <code>static</code>:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// bar.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\nint bar() { return foo&lt;double&gt;(); }\n\n// main.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\ntemplate &lt;&gt; static int foo&lt;double&gt;() { return 2; }  // note: static\n\nint bar();\n\nint main()\n{\n    const int x = bar();          // x == 1\n    const int y = foo&lt;double&gt;();  // y == 2\n}\n</code></pre>\n<p>We now have x\u00a0==\u00a01 and y\u00a0==\u00a02, as we expected. (Note: we <em>must</em> use the <code>static</code> keyword here: an anonymous namespace won't do since we can't specialize a template function in a different namespace than its declaration.)</p>\n<p>Now, the use of the <code>static</code> keyword is rather unintuitive. Typically, the specialization  <code>foo&lt;double&gt;()</code> would reside somewhere in a header file, and thus would be marked as inline, like in the following snippet:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// bar.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\nint bar() { return foo&lt;double&gt;(); }\n\n// main.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\ntemplate &lt;&gt; inline int foo&lt;double&gt;() { return 2; }  // note: inline\n\nint bar();\n\nint main()\n{\n    const int x = bar();          // x == 2\n    const int y = foo&lt;double&gt;();  // y == 2\n}\n</code></pre>\n<p>This code now links properly and when we run it we get x\u00a0==\u00a02 and y\u00a0==\u00a02. <strong>This is the bit I find surprising: why is there a single definition of <code>foo&lt;double&gt;()</code>? What is the meaning of <code>inline</code> in this code?</strong></p>\n<p>A last snippet:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// bar.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\nint bar() { return foo&lt;double&gt;(); }\n\n// main.cpp\n\ntemplate &lt;typename T&gt; int foo() { return 1; }\ntemplate &lt;&gt; inline int foo&lt;double&gt;() { return 2; }  // note: inline\n\nint bar();\n\nint main()\n{\n    const int x = bar();             // x == 1\n    // const int y = foo&lt;double&gt;();  // note: commented out\n}\n</code></pre>\n<p>This case is actually not surprising: the  specialization of <code>foo&lt;double&gt;()</code> is no longer instantiated in <em>main.cpp</em> (although the declaration is still there), so the only instantiation remaining is the one in <em>bar.cpp</em>.</p>\n", "Tags": "<c++><templates><linker><inline><specialization>", "OwnerUserId": "393756", "AnswerCount": "1"}});