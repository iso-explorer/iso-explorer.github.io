post_cb({"21010730": {"ParentId": "21010685", "LastEditDate": "2014-01-09T02:52:37.010", "CommentCount": "2", "CreationDate": "2014-01-09T02:42:44.857", "OwnerUserId": "153891", "LastEditorUserId": "153891", "PostTypeId": "2", "Id": "21010730", "Score": "-1", "Body": "<p>Your two forms are the same, you're not really doing pointer arithmetic.</p>\n<p>The pointer form would be:</p>\n<pre><code>double * array= new double[10000000] ;\ndouble * dp= array ;\n\nfor ( int i= 0 ; ( i &lt; 10000000 ) ; i ++, dp ++ )\n{\n  * dp= 0 ;\n}\n</code></pre>\n<p>Hear, the address in <code>dp</code> is moved to the next one via an add.  In the other forms, the address is calculated each go through the loop by multiplying <code>i</code> time sizeof(double) and adding it to <code>array</code>.  Its the multiply that historically was slower than the add.</p>\n", "LastActivityDate": "2014-01-09T02:52:37.010"}, "21010685": {"CommentCount": "9", "ViewCount": "139", "PostTypeId": "1", "LastEditorUserId": "982049", "CreationDate": "2014-01-09T02:38:34.693", "LastActivityDate": "2014-01-09T04:26:34.727", "Title": "C++ pointer comparison with []operator for arrays?", "AcceptedAnswerId": "21010722", "LastEditDate": "2014-01-09T03:26:28.130", "Id": "21010685", "Score": "5", "Body": "<p>I have been reading a <a href=\"http://books.google.co.in/books/about/Programming_In_Ansi_C.html?id=3fZa9af1KtYC&amp;redir_esc=y\" rel=\"nofollow\">book</a> which says that accessing array elements by pointer arithmetic's is much faster than the [] operator. In short <a href=\"http://ideone.com/qrbFbJ\" rel=\"nofollow\">this</a> code is faster than <a href=\"http://ideone.com/OrbTZj\" rel=\"nofollow\">this</a> code.\nThe book does not say why. Is it advisible to use such pointer arithmetic's even if it provides significant improvement in speed?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // your code goes here\n    double *array = new double[1000000];\n    for(int i = 0; i &lt; 1000000; i++)\n    {\n        array[i] = 0;//slower?\n    }\n    delete[] array;\n    return 0;\n}\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // your code goes here\n    double *array = new double[1000000];\n    for(int i = 0; i &lt; 1000000; i++)\n    {\n        *(array + i) = 0;//faster?\n    }\n    delete[] array;\n    return 0;\n}\n</code></pre>\n<p><strong>EDIT:</strong></p>\n<p>Quote from book pg 369, 2nd last line</p>\n<blockquote>\n<p id=\"so_21010685_21010685_0\">The pointer accessing method is much faster than array indexing.</p>\n</blockquote>\n", "Tags": "<c++><arrays><pointers>", "OwnerUserId": "982049", "AnswerCount": "6"}, "21011586": {"ParentId": "21010685", "CommentCount": "0", "Body": "<p>There is no difference at all, if we go to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>5.2.1</code> <em>Subscripting</em> paragraph <em>1</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_21010685_21011586_0\">[...]<strong>The expression E1[E2] is identical (by definition) to *((E1)+(E2))</strong> [Note: see 5.3 and 5.7 for details of * and + and 8.3.4 for details of arrays. \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "PostTypeId": "2", "Id": "21011586", "Score": "2", "CreationDate": "2014-01-09T04:26:34.727", "LastActivityDate": "2014-01-09T04:26:34.727"}, "21010733": {"ParentId": "21010685", "CommentCount": "0", "Body": "<p>Utter rubbish. <code>a[x]</code> on a plain array decays into <code>*(a + x)</code>. There will literally be 0 performance difference.</p>\n", "OwnerUserId": "1085573", "PostTypeId": "2", "Id": "21010733", "Score": "1", "CreationDate": "2014-01-09T02:43:00.853", "LastActivityDate": "2014-01-09T02:43:00.853"}, "21010736": {"ParentId": "21010685", "LastEditDate": "2014-01-09T03:07:40.693", "CommentCount": "0", "CreationDate": "2014-01-09T02:43:35.763", "OwnerUserId": "149138", "LastEditorUserId": "149138", "PostTypeId": "2", "Id": "21010736", "Score": "1", "Body": "<p>The book is just plain wrong - especially if those are the actual examples they gave.  Decent compilers are likely to produce identical code for both methods, even without optimization and they will have identical performance.</p>\n<p>Without optimization, or with compilers from the 80s, you might get performance differences with some types of pointer arithmetic, but the examples don't even represent that case. The examples are basically just different syntax for the same thing.</p>\n<p>Here's an example that could plausibly have a performance difference (versus the array index case which is unchanged):</p>\n<pre><code>int main() {\n  // your code goes here\n  double *array = new double[1000000], *ptr = array;\n  for(; ptr &lt; array + 1000000; ptr++)\n  {\n    *ptr = 0;\n  }\n  return 0;\n}\n</code></pre>\n<p>Here, you aren't indexing against the base pointer each time through the loop, but are incrementing the pointer each time. In theory, you avoid the multiplication implicit in indexing, resulting in a faster loop. In practice, any decent compiler can reduce the indexed form to the additive form, and on modern hardware the multiplication by <code>sizeof(double)</code> implied by indexing is often free as part of an instruction like <code>lea</code> (load effective address), so even at the assembly level the indexed version may not be slower (and may in fact be faster since it avoids a loop-carried dependency and also lends itself better to aliasing analysis). </p>\n", "LastActivityDate": "2014-01-09T03:07:40.693"}, "21010818": {"ParentId": "21010685", "LastEditDate": "2017-05-23T12:21:27.580", "CommentCount": "0", "CreationDate": "2014-01-09T02:51:46.407", "OwnerUserId": "3171324", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "21010818", "Score": "2", "Body": "<p>Array indices are just syntactic sugar for pointer arithmetic. Your compiler will boil down <code>a[i]</code> into <code>*((a) + (i))</code>. Agreed, run away from that book!</p>\n<p>For more in-depth explanations, see</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/a/4608421/3171324\">SO Answer</a></li>\n<li><a href=\"http://eli.thegreenplace.net/2009/10/21/are-pointers-and-arrays-equivalent-in-c/\" rel=\"nofollow noreferrer\">Eli Bendersky's explanation</a></li>\n</ol>\n", "LastActivityDate": "2014-01-09T02:51:46.407"}, "21010722": {"ParentId": "21010685", "LastEditDate": "2017-05-23T12:03:47.687", "CommentCount": "0", "CreationDate": "2014-01-09T02:42:14.007", "OwnerUserId": "493122", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "21010722", "Score": "5", "Body": "<p>No, they are exactly the same thing. I definitely suggest you to drop that book and <a href=\"https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list?rq=1\">pick another one up</a> as soon as possible. </p>\n<p>And even if there was any performance difference, the clarity of <code>x[12]</code> over <code>*(x + 12)</code> is much more important.</p>\n", "LastActivityDate": "2014-01-09T02:42:14.007"}, "bq_ids": {"n4140": {"so_21010685_21011586_0": {"section_id": 5986, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_21010685_21011586_0": {"section_id": 5754, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_21010685_21011586_0": {"section_id": 7486, "quality": 0.6428571428571429, "length": 9}}}});