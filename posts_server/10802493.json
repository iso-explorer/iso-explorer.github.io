post_cb({"10803273": {"ParentId": "10802493", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>I came up with two HACK solutions, but they should work. The first doesn't use the scope resolution operator and is safer. The second uses a noop int variable to fake out the scoping.</p>\n<pre><code>#define logging_printStream(token) { std::stringstream o; o &lt;&lt; token; logging::print(o.str().c_str()); }\n\nnamespace logging { int noop; }\n#define printStream(token) noop = 0; { std::stringstream o; o &lt;&lt; token; logging::print(o.str().c_str()); }\n\nint main(int argc, const char** argv)\n{\n    int i = 1;\n\n    // MORE SAFE\n    logging_printStream(i)\n    logging_printStream(\"is this magic? \" &lt;&lt; (i ? \"yes\" : \"no\"))\n\n    // LESS SAFE\n    logging::printStream(i)\n    logging::printStream(\"is this magic? \" &lt;&lt; (i ? \"yes\" : \"no\"))\n}\n</code></pre>\n<hr>\n<p>I updated logging__printStream to logging_printStream because of 17.6.4.3.2</p>\n<blockquote>\n<p id=\"so_10802493_10803273_0\">17.6.4.3.2 Global names [global.names]</p>\n<p id=\"so_10802493_10803273_1\">Certain sets of names and function signatures are always reserved to the implementation:</p>\n<ul>\n<li><strong>Each name that contains a double underscore _ _</strong> or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use.</li>\n<li>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</li>\n</ul>\n</blockquote>\n<p>I left the declaration of main alone because of 3.6.1</p>\n<blockquote>\n<p id=\"so_10802493_10803273_2\">3.6.1 Main function [basic.start.main]</p>\n<p id=\"so_10802493_10803273_3\">A program shall contain a global function called main, which is the designated start of the program. It is implementation-defined whether a program in a freestanding environment is required to define a main function. An implementation shall not predefine the main function. This function shall not be overloaded. <strong>It shall have a return type of type int, but otherwise its type is implementation-defined.</strong></p>\n</blockquote>\n</hr>", "OwnerUserId": "1298400", "LastEditorUserId": "1298400", "LastEditDate": "2012-06-01T16:01:02.150", "Id": "10803273", "Score": "0", "CreationDate": "2012-05-29T16:39:44.907", "LastActivityDate": "2012-06-01T16:01:02.150"}, "10802591": {"ParentId": "10802493", "CommentCount": "4", "Body": "<p>You can write this:</p>\n<pre><code>print(static_cast&lt;std::ostringstream&amp;&gt;(std::ostringstream() &lt;&lt; \"The value of x is: \" &lt;&lt; x).str().c_str());\n</code></pre>\n<p>Maybe that's more to your liking?</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "10802591", "Score": "0", "CreationDate": "2012-05-29T15:54:48.563", "LastActivityDate": "2012-05-29T15:54:48.563"}, "10802851": {"ParentId": "10802493", "CommentCount": "3", "Body": "<p>As a starting point, you could ...</p>\n<pre><code>class Something {\npublic:\n    std::ostream&amp; error() const { ... code to return some std::ostream ... }\n};\n\n...\n\nint main () {\n    Something something;\n    something.error() &lt;&lt; \"Frobnicate\" &lt;&lt; 4;\n}\n</code></pre>\n<p>Later you could add your own proxy-object with overloaded stream operators (which I think is still easier than writing your own stream derived from <code>std::ostream</code>).</p>\n<p>Of course there's already tons of logging frameworks out there, look into them at first.</p>\n", "OwnerUserId": "76722", "PostTypeId": "2", "Id": "10802851", "Score": "0", "CreationDate": "2012-05-29T16:11:38.247", "LastActivityDate": "2012-05-29T16:11:38.247"}, "10802493": {"CommentCount": "6", "AcceptedAnswerId": "10803273", "CreationDate": "2012-05-29T15:48:42.670", "LastActivityDate": "2012-06-01T16:01:02.150", "PostTypeId": "1", "ViewCount": "2602", "FavoriteCount": "0", "Title": "Passing stringstream values through a function, C++", "Id": "10802493", "Score": "3", "Body": "<p>I currently have a logging system that takes a char* and var args and then uses them to do a printf. This works well with C-style strings, but I'd something that's a little cleaner. Currently if I use std::stringstream I must create the stringstream outside of the logging system, and then use the char* to the string given by the stringstream. It looks something like this:</p>\n<pre><code>std::stringstream strStream;\nstrStream &lt;&lt; \"The value of x is: \" &lt;&lt; x;\nlogging::print( strStream.str().c_str() );\n</code></pre>\n<p>What I would like is to pass the paramaters into the function as if I was using them directly with a stringstream. Which would look something like this from the user's point of view:</p>\n<pre><code>logging::printStream(\"The value of x is: \" &lt;&lt; x);\n</code></pre>\n<p>or possibly like this:</p>\n<pre><code>logging::printStream(\"The value of x is: \", x);\n</code></pre>\n<p>Is there any way to use logging in such a way that I can use a stringstream without having to create it outside of the logging system's functions?</p>\n<p>This is especially important because I intend to create a macro that prevents any of the function parameters from compiling in shipping builds. The macro will be useless if I have to create the stringstream outside of it and pass it in. Technically I could make a macro that does the stringstream stuff I'm talking about in this question, but that's pretty messy as I won't always be using stringstreams with this logging, so I would have a macro for the standard logging, and a different macro for using stringstreams that within it calls the macro for standard logging.</p>\n", "Tags": "<c++><function><stringstream>", "OwnerUserId": "967504", "AnswerCount": "5"}, "10806682": {"ParentId": "10802493", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The following works as intended (tested -- replace output to cerr with your logging::print):</p>\n<pre><code>#include&lt;sstream&gt;\n#include&lt;iostream&gt;\n\nclass StringstreamLogger {\nprivate:\n    std::stringstream s;\n\npublic:\n    StringstreamLogger () : s (std::ios_base::out) {\n    }\n\n    ~StringstreamLogger () {\n    std::cerr &lt;&lt; s.str () &lt;&lt; std::endl; // logging::print (s.str ().c_str ());\n    }\n\n    std::stringstream&amp; out () {\n    return s;\n    }\n};\n\nint main () {\n    StringstreamLogger ().out () &lt;&lt; \"My log message\";\n    std::cerr &lt;&lt; \"Some later output to test for prompt logging (to ensure that logging is not delayed until the end of a block)\" &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "1419315", "LastEditorUserId": "1419315", "LastEditDate": "2012-05-29T21:16:48.970", "Id": "10806682", "Score": "1", "CreationDate": "2012-05-29T21:03:43.847", "LastActivityDate": "2012-05-29T21:16:48.970"}, "bq_ids": {"n4140": {"so_10802493_10803273_1": {"section_id": 6307, "quality": 1.0, "length": 8}}, "n3337": {"so_10802493_10803273_1": {"section_id": 6064, "quality": 1.0, "length": 8}}, "n4659": {"so_10802493_10803273_1": {"section_id": 7844, "quality": 0.625, "length": 5}}}, "10809447": {"ParentId": "10802493", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>How about a custom type that overloads the output streaming operator?</p>\n<pre><code>struct logger\n{\n    std::stringstream ss_;\n\n    template &lt;typename T&gt;\n    friend logger&amp; operator &lt;&lt; (logger&amp; l, T const&amp; t) \n    {\n    #ifdef DEBUG_MODE\n        l.ss_ &lt;&lt; t;\n    #endif\n\n        return l;\n    }\n\n    ~logger()\n    {\n    #ifdef DEBUG_MODE\n        // output ss_.str().c_str() to your logger.\n    #endif\n    }\n};\n</code></pre>\n<p>And then whenever you need to log output just</p>\n<pre><code>logger log;\nlog &lt;&lt; \"Log this stuff: \" &lt;&lt; x &lt;&lt; '\\n';\n</code></pre>\n", "OwnerUserId": "154744", "LastEditorUserId": "154744", "LastEditDate": "2012-05-30T03:04:25.923", "Id": "10809447", "Score": "0", "CreationDate": "2012-05-30T02:59:14.707", "LastActivityDate": "2012-05-30T03:04:25.923"}});