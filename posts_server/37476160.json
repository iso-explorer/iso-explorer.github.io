post_cb({"37476206": {"ParentId": "37476160", "CommentCount": "0", "Body": "<p>q clearly doesn't support removing elements while iterating through them.</p>\n", "OwnerUserId": "5203926", "PostTypeId": "2", "Id": "37476206", "Score": "0", "CreationDate": "2016-05-27T06:22:38.477", "LastActivityDate": "2016-05-27T06:22:38.477"}, "37476263": {"ParentId": "37476160", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote id=\"so_37476160_37476263_0\">\n<ol>\n<li>Why does the following code crash ? How do I erase individual elements then ?</li>\n</ol>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/deque/erase\" rel=\"nofollow\"><code>std::deque::erase</code></a> invalidates iterators.</p>\n<blockquote>\n<p id=\"so_37476160_37476263_1\">All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated. </p>\n<p id=\"so_37476160_37476263_2\">The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased. </p>\n</blockquote>\n<p>In your code, the iterators to the element to be erased (i.e. <code>it</code> and <code>current</code>) will become invalid after <code>q.erase(current)</code>, then <code>it++</code> will lead to UB.</p>\n<p>You could make use of the return value of <code>std::deque::erase</code></p>\n<blockquote>\n<p id=\"so_37476160_37476263_3\">Iterator following the last removed element. If the iterator pos refers to the last element, the <code>end()</code> iterator is returned. </p>\n</blockquote>\n<pre><code>for (auto it = q.begin(); it!=q.end(); )\n{\n    it = q.erase(it);\n}\n</code></pre>\n<blockquote id=\"so_37476160_37476263_4\">\n<ol start=\"2\">\n<li>And what should I do if I am iterating via reverse iterator.</li>\n</ol>\n</blockquote>\n<p>Because <code>std::deque::erase</code> doesn't accept <code>reverse_iterator</code> as parameters, you need to use <a href=\"http://en.cppreference.com/w/cpp/iterator/reverse_iterator/base\" rel=\"nofollow\"><code>base()</code></a> to convert it to normal iterator (pay attention to the position conversion). Such as</p>\n<pre><code>for (auto it = q.rbegin(); it!=q.rend(); )\n{\n    it = std::make_reverse_iterator(q.erase((++it).base()));\n}\n</code></pre>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-05-27T06:58:04.403", "Id": "37476263", "Score": "3", "CreationDate": "2016-05-27T06:25:56.797", "LastActivityDate": "2016-05-27T06:58:04.403"}, "37476636": {"ParentId": "37476160", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As the other answerers have already pointed out, erasing elements from the queue will invalidate the iterators you are using to iterate its elements. Thus it fails.</p>\n<p>But I assume that you don't intend to erase all elements in the queue, in which case you probably would have rather used:</p>\n<pre><code>q.erase(q.begin(), q.end());\n</code></pre>\n<p>or</p>\n<pre><code>q.clear();\n</code></pre>\n<p>Therefore, I'd like to suggest using another technique, that can be used to delete items matching certain criteria from a queue: the <a href=\"https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom\" rel=\"nofollow\">erase-remove idiom</a>.</p>\n<p>Here, the functions <code>std::remove(...)</code> and <code>std::remove_if(...)</code> are used to move the items to be deleted (matching certain criteria) to the end of the container. The range-based version of <code>q.erase(...)</code> is then used to delete the items.</p>\n<p>Here's an example:</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\n// predicate function for removal of elements\nbool greater_three(int x) {\n    return x &gt; 3;\n}\n\nint main() {\n    std::deque&lt;int&gt; q = {1,2,3,4,5};\n    for (auto i : q) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\";\n    // delete all items with value 3\n    q.erase(std::remove(q.begin(), q.end(), 3), q.end()); \n    for (auto i : q) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\";\n    // delete all items with value &gt; 3\n    q.erase(std::remove_if(q.begin(), q.end(), greater_three), q.end()); \n    for (auto i : q) std::cout &lt;&lt; i &lt;&lt; \" \"; std::cout &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>$ g++ test.cc -std=c++11 &amp;&amp; ./a.out\n1 2 3 4 5 \n1 2 4 5 \n1 2 \n</code></pre>\n<p>For reference:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/container/deque/erase\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/deque/erase</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/container/deque/clear\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/deque/clear</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/algorithm/remove\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/algorithm/remove</a></li>\n</ul>\n", "OwnerUserId": "1025391", "LastEditorUserId": "1025391", "LastEditDate": "2016-05-27T06:54:43.893", "Id": "37476636", "Score": "1", "CreationDate": "2016-05-27T06:49:05.943", "LastActivityDate": "2016-05-27T06:54:43.893"}, "37476318": {"ParentId": "37476160", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As per <code>C++11 23.3.3.4 deque modifiers /4</code>, <code>deque</code> iterators become invalid if you delete certain elements.</p>\n<blockquote>\n<p id=\"so_37476160_37476318_0\">An erase operation that erases the last element of a deque invalidates only the past-the-end iterator and all iterators and references to the erased elements.</p>\n<p id=\"so_37476160_37476318_1\">An erase operation that erases the first element of a deque but not the last element invalidates only the erased elements.</p>\n<p id=\"so_37476160_37476318_2\">An erase operation that erases neither the first element nor the last element of a deque invalidates the past-the-end iterator and all iterators and references to all the elements of the deque.</p>\n</blockquote>\n<p>In your case, you're usually only ever erasing the first element so it will only invalidate that element. That means the <code>it++</code> is invalid and you should instead use something like:</p>\n<pre><code>it = q.erase(it);\n</code></pre>\n<p>inside the loop, since the <code>erase</code> call itself returns an \"adjusted\" iterator. This will also work when removing the last element.</p>\n<p>However, since your code is totally clearing the list (assuming it's not a cut down version of something which needs to process each element), you can ditch the loop altogether and just use:</p>\n<pre><code>q.clear();\n</code></pre>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2016-05-27T06:40:04.850", "Id": "37476318", "Score": "2", "CreationDate": "2016-05-27T06:29:11.823", "LastActivityDate": "2016-05-27T06:40:04.850"}, "37476160": {"CommentCount": "1", "CreationDate": "2016-05-27T06:20:11.670", "PostTypeId": "1", "AcceptedAnswerId": "37476263", "LastEditorUserId": "1025391", "LastActivityDate": "2016-05-27T07:03:32.580", "LastEditDate": "2016-05-27T07:03:32.580", "ViewCount": "334", "FavoriteCount": "1", "Title": "Segmentation fault when erasing elements while iterating std::deque", "Id": "37476160", "Score": "2", "Body": "<p>Why does the following code crash? And what should I do when I am iterating via reverse iterator. How do I erase individual elements then?</p>\n<pre><code>deque q;\nq.push_back(4);\nq.push_back(41);\nq.push_back(14);\n\nfor (auto it = q.begin(); it != q.end();) {\n    auto current = it;\n    q.erase(current);\n    it++; \n}\n</code></pre>\n", "Tags": "<c++><iterator><deque><erase>", "OwnerUserId": "1424746", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_37476160_37476318_1": {"section_id": 820, "quality": 1.0, "length": 12}, "so_37476160_37476263_2": {"section_id": 820, "quality": 0.5833333333333334, "length": 7}, "so_37476160_37476318_2": {"section_id": 820, "quality": 1.0, "length": 19}, "so_37476160_37476318_0": {"section_id": 820, "quality": 1.0, "length": 14}}, "n3337": {"so_37476160_37476318_1": {"section_id": 809, "quality": 1.0, "length": 12}, "so_37476160_37476263_2": {"section_id": 809, "quality": 0.5833333333333334, "length": 7}, "so_37476160_37476318_2": {"section_id": 809, "quality": 1.0, "length": 19}, "so_37476160_37476318_0": {"section_id": 809, "quality": 1.0, "length": 14}}, "n4659": {"so_37476160_37476318_1": {"section_id": 879, "quality": 1.0, "length": 12}, "so_37476160_37476318_0": {"section_id": 879, "quality": 1.0, "length": 14}, "so_37476160_37476318_2": {"section_id": 879, "quality": 1.0, "length": 19}, "so_37476160_37476263_1": {"section_id": 802, "quality": 0.5333333333333333, "length": 8}}}});