post_cb({"bq_ids": {"n4140": {"so_45611464_45613796_2": {"length": 4, "quality": 0.8, "section_id": 2552}, "so_45611464_45613796_5": {"length": 8, "quality": 1.0, "section_id": 7016}}, "n3337": {"so_45611464_45613796_2": {"length": 4, "quality": 0.8, "section_id": 2517}, "so_45611464_45613796_5": {"length": 8, "quality": 1.0, "section_id": 6762}}, "n4659": {"so_45611464_45613796_2": {"length": 4, "quality": 0.8, "section_id": 3288}, "so_45611464_45613796_5": {"length": 8, "quality": 1.0, "section_id": 8513}}}, "45611464": {"ViewCount": "134", "Body": "<p>Consider following code:</p>\n<pre><code>class user_error : public std::runtime_error\n{\npublic:\n    using std::exception::what;\n    explicit user_error(const std::string&amp; what_arg):std::runtime_error(what_arg){}\n};\n\n\nclass with_overriden_what : public user_error {\npublic:\n  with_overriden_what(const std::string&amp; val) : user_error(\"user_error\"), message(val) { }\n\n  std::string message;\n\n  virtual const char* what() const noexcept {\n    return message.c_str();\n  }\n};\n</code></pre>\n<p>with this calls:</p>\n<pre><code>with_overriden_what ex(\"thrown\");\nstd::cout &lt;&lt; \"1. direct result: \" &lt;&lt; ex.what() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"2. sliced result: \" &lt;&lt; static_cast&lt;user_error&gt;(ex).what() &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; \"3. ranged result: \" &lt;&lt; ex.user_error::what() &lt;&lt; \"\\n\";\n</code></pre>\n<p>It is surprise for me that result of 2 and 3 is different:</p>\n<pre><code>1. direct result: thrown\n2. sliced result: user_error\n3. ranged result: std::exception\n</code></pre>\n<p><strong>Q:</strong> Is there a paragraph in standard that address this behaviour?</p>\n", "Title": "using method from indirect parent", "CreationDate": "2017-08-10T10:41:53.267", "LastActivityDate": "2017-08-10T12:57:46.583", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-08-10T12:47:24.993", "LastEditorUserId": "2079303", "Id": "45611464", "Score": "6", "OwnerUserId": "8257709", "Tags": "<c++><language-lawyer><using-declaration>", "AnswerCount": "1"}, "45613796": {"Id": "45613796", "PostTypeId": "2", "Body": "<p>The difference between 2. and 3. is that 2. uses dynamic (== virtual) dispatch (== call). Dynamic dispatch is implicitly used, when a virtual function is called (see later paragraph for exception). Therefore 2. calls the most derived override, which is <code>std::runtime_error::what</code> which prints the message <code>\"user_error\"</code> that was given to the constructor, as required by the post condition of the constructor:</p>\n<blockquote>\n<p id=\"so_45611464_45613796_0\">[runtime.error]</p>\n<p id=\"so_45611464_45613796_1\"><code>runtime_error(const char* what_arg);</code></p>\n<p id=\"so_45611464_45613796_2\">4\n   Effects: Constructs an object of class runtime_error.</p>\n<p id=\"so_45611464_45613796_3\">5\n   <strong>Postcondition: <code>strcmp(what(), what_arg) == 0</code>.</strong></p>\n</blockquote>\n<hr>\n<p>Function call using a scope resolution operator does static dispatch even if the function is virtual.</p>\n<blockquote>\n<p id=\"so_45611464_45613796_4\">[class.virtual]</p>\n<p id=\"so_45611464_45613796_5\">15 Explicit qualification with the scope operator (5.1) suppresses the virtual call mechanism.</p>\n</blockquote>\n<p>Therefore overrides do not matter for 3. What matters is name resolution. The using declaration is like any other member declaration in that it <em>hides</em> the same name that would have otherwise been resolved from a parent.</p>\n<p>So, <code>user_error::what</code> hides <code>std::runtime_error::what</code>. And, <code>user_error::what</code> is defined by <code>std::exception::what</code>.</p>\n<hr>\n<p>Now, what should this non virtually called <code>std::exception::what</code> return according to the standard? <em>(annotated by me)</em>:</p>\n<blockquote>\n<p id=\"so_45611464_45613796_6\">[exception]</p>\n<p id=\"so_45611464_45613796_7\">7 Returns: An implementation-defined NTBS. <em>(null terminated string)</em></p>\n</blockquote>\n<p>Clearly, there is no requirement to print anything in particular, such as printing a string that was passed to a constructor of a derived class that contains this as sub object. Any string is standard compliant.</p>\n<hr>\n<p>A minimal example for the behaviour, that does not involve exceptions:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    virtual void x() {\n        std::cout &lt;&lt; \"A\\n\";\n    }\n};\n\nstruct B : A {\n    void x() {\n        std::cout &lt;&lt; \"B\\n\";\n    }\n};\n\nstruct C : B {\n    using A::x;\n};\n\nint main() {\n    C c;\n    c.x();\n    c.C::x();\n    return 0;\n}\n</code></pre>\n<p>The output of the two lines must be different.</p>\n</hr></hr></hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2017-08-10T12:57:46.583", "Score": "4", "CreationDate": "2017-08-10T12:29:57.080", "ParentId": "45611464", "CommentCount": "12", "OwnerUserId": "2079303", "LastEditDate": "2017-08-10T12:57:46.583"}});