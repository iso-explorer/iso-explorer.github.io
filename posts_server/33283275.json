post_cb({"bq_ids": {"n4140": {"so_33283275_33283491_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 1332}, "so_33283275_33305627_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 1333}, "so_33283275_33305627_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 1334}, "so_33283275_33305627_1": {"length": 32, "quality": 0.8648648648648649, "section_id": 1332}, "so_33283275_33305627_4": {"length": 7, "quality": 0.875, "section_id": 1335}}, "n3337": {"so_33283275_33283491_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 1326}, "so_33283275_33305627_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 1327}, "so_33283275_33305627_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 1328}, "so_33283275_33305627_1": {"length": 32, "quality": 0.8648648648648649, "section_id": 1326}, "so_33283275_33305627_4": {"length": 7, "quality": 0.875, "section_id": 1329}}, "n4659": {"so_33283275_33283491_0": {"length": 23, "quality": 0.6388888888888888, "section_id": 1463}, "so_33283275_33305627_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 1462}, "so_33283275_33305627_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 1464}, "so_33283275_33305627_1": {"length": 23, "quality": 0.6216216216216216, "section_id": 1463}, "so_33283275_33305627_4": {"length": 7, "quality": 0.875, "section_id": 1465}}}, "33305627": {"Id": "33305627", "PostTypeId": "2", "Body": "<p>I was intrigued by this so have done some research. </p>\n<p>At the bottom of this answer is a copy of the relevant section from the standard as of 2011.</p>\n<p>You will see from the template declaration of <code>std::generate&lt;&gt;</code> that the iterator parameters must conform to the concept of a <code>ForwardIterator</code> and <code>OutputIterator</code> respectively. </p>\n<p>A ForwardIterator <em>does not support random access</em>. it can only read or write sequentially. An <code>OutputIterator</code> is even more restrictive - its <code>operator*</code> implicitly includes the effect of an <code>operator++</code>. This is an explicit feature of the concept. </p>\n<p>Therefore, by implication, the implementation of this function <em>must</em> access elements sequentially (and therefore generate values sequentially) since <em>to not do so would break the contract implicit in the interface</em>.</p>\n<p>Therefore the standard <strong>does</strong> (implicitly and quietly) guarantee that <code>std::generate</code> initialise its elements sequentially. It would be impossible to write a well-formed implementation of <code>std::generate</code> that did not.</p>\n<p>QED</p>\n<blockquote>\n<p id=\"so_33283275_33305627_0\">25.3.7 Generate [alg.generate]</p>\n</blockquote>\n<pre><code>template&lt;class ForwardIterator, class Generator&gt;\nvoid generate(ForwardIterator first, ForwardIterator last,\nGenerator gen);\n\ntemplate&lt;class OutputIterator, class Size, class Generator&gt;\nOutputIterator generate_n(OutputIterator first, Size n, Generator gen);\n</code></pre>\n<blockquote>\n<p id=\"so_33283275_33305627_1\">1 Effects: The first algorithm invokes the function object gen and\n  assigns the return value of gen through all the iterators in the range\n  [first,last). The second algorithm invokes the function object gen and\n  assigns the return value of gen through all the iterators in the range\n  [first,first + n) if n is positive, otherwise it does nothing. </p>\n<p id=\"so_33283275_33305627_2\">2\n  Requires: gen takes no arguments, Size shall be convertible to an\n  integral type (4.7, 12.3). </p>\n<p id=\"so_33283275_33305627_3\">3 Returns: generate_n returns first + n for\n  non-negative values of n and first for negative values. </p>\n<p id=\"so_33283275_33305627_4\">4 Complexity:\n  Exactly last - first, n, or 0 invocations of gen and assignments,\n  respectively.</p>\n</blockquote>\n", "LastActivityDate": "2015-10-23T15:05:28.363", "CommentCount": "7", "CreationDate": "2015-10-23T15:05:28.363", "ParentId": "33283275", "Score": "3", "OwnerUserId": "2015579"}, "33283491": {"Id": "33283491", "PostTypeId": "2", "Body": "<p>Here is all the standard says about it (25.7.3/1):</p>\n<pre><code>template&lt;class ForwardIterator, class Generator&gt;\nvoid generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate&lt;class OutputIterator, class Size, class Generator&gt;\nOutputIterator generate_n(OutputIterator first, Size n, Generator gen);\n</code></pre>\n<blockquote>\n<p id=\"so_33283275_33283491_0\">The first algorithm invokes the function object\n  gen\n  and assigns the return value of\n  gen\n  through\n  all the iterators in the range\n  [first,last)\n  . The second algorithm invokes the function object\n  gen\n  and assigns the return value of\n  gen\n  through all the iterators in the range\n  [first,first + n)\n  if\n  n\n  is\n  positive, otherwise it does nothing.</p>\n</blockquote>\n<p>As you can see, it is not explicitly stated that the iterator assignments must be done sequentially.</p>\n", "LastActivityDate": "2015-10-22T14:27:47.120", "CommentCount": "1", "CreationDate": "2015-10-22T14:27:47.120", "ParentId": "33283275", "Score": "1", "OwnerUserId": "1490355"}, "33283275": {"ViewCount": "114", "Body": "<p>I was told <a href=\"https://stackoverflow.com/questions/33280217/how-to-use-algorithms-to-fill-vector-of-vectors/33282441?noredirect=1#comment54361802_33280760\">here</a> that:</p>\n<blockquote>\n<p id=\"so_33283275_33283275_0\">The order of generate is not guaranteed =&gt; depending on the implementation</p>\n</blockquote>\n<p>I have looked up <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.6.2/libstdc++/api/a01045_source.html#l05012\" rel=\"nofollow noreferrer\">gcc's implementation of <code>generate</code></a>:</p>\n<pre><code>  for (; __first != __last; ++__first)\n*__first = __gen();\n</code></pre>\n<p>And Visual Studio implements it identically to that. This is a relief to me as using a lambda in <code>generate</code> that reads and writes to a capture could have undeterministic results:</p>\n<pre><code>int foo[] = {1, 0, 13};\nvector&lt;int&gt; bar(3);\n\ngenerate(bar.begin(), bar.end(), [&amp;]() {\n    static auto i = 0;\n    static auto total = 0;\n\n    total += foo[i];\n    return foo[i] / total;\n});\n</code></pre>\n<p><a href=\"http://ideone.com/McpA4U\" rel=\"nofollow noreferrer\">I expect</a> <code>bar</code> to contain <code>{1, 0, 0}</code>.</p>\n<p>If I am allowed to execute out of order this could even cause a divide by 0 error.</p>\n<p>So I'd sleep easier if this question could be answered with proof that <code>generate</code> is required to execute sequentially.</p>\n<p>As a note here, I know that <a href=\"http://en.cppreference.com/w/cpp/experimental/parallelism/existing#generate\" rel=\"nofollow noreferrer\"><code>experimental::parallel::generate</code></a> will not be sequential. I'm just asking about <code>generate</code>.</p>\n", "AcceptedAnswerId": "33305627", "Title": "Is generate Guaranteed to be Executed Sequentially?", "CreationDate": "2015-10-22T14:17:54.947", "Id": "33283275", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:25:46.190", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-23T15:05:28.363", "Score": "3", "OwnerUserId": "2642059", "Tags": "<c++><algorithm><lambda><language-lawyer><sequential>", "AnswerCount": "2"}});