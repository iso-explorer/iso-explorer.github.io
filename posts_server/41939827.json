post_cb({"41941916": {"Id": "41941916", "PostTypeId": "2", "Body": "<p>This code runs afoul of [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_41939827_41941916_0\">The non-deduced contexts are: [...] A function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em>.</p>\n</blockquote>\n<p>as in:</p>\n<pre><code>template&lt;class D0, class... Ds, class... Is&gt;\nHOST_DEVICE void _apply(Typelist&lt;D0, Ds...&gt; , D0 d0, Ds... ds, Is... is) {\n//                                                   ~~~~~~~~\n</code></pre>\n<p>and [temp.arg.explicit]:</p>\n<blockquote>\n<p id=\"so_41939827_41941916_1\">A trailing template parameter pack (14.5.3) not otherwise deduced will be deduced to an empty sequence of template arguments.</p>\n</blockquote>\n<p>This deduce-nondeduced-packs-as-empty idea breaks your code on both gcc and clang in different ways. Consider the call <code>apply(1,2)</code>:</p>\n<ul>\n<li>every version of gcc I've tried considers the <code>Ds... ds</code> pack empty and deduces <code>Ds...</code> as <code>&lt;int&gt;</code> and <code>Is...</code> as <code>&lt;int, unsigned int&gt;</code>. So that overload is thrown out as it takes 5 arguments and we're only passing 4.</li>\n<li>every version of clang I've tried deduces the second <code>Ds...</code> as <code>&lt;int&gt;</code> from the first argument and <code>&lt;&gt;</code> from the pack and consider the deduction to be a failure due to the inconsistency.</li>\n</ul>\n<p>Either way, there's not really a path forward here. </p>\n<hr/>\n<p>What you can do instead is to flip the order and put all the <code>Is...</code> first. Since you know all the types, you can explicitly specify them, and let the <code>Ds...</code> be deduced. That is:</p>\n<pre><code>template&lt;class... Is&gt;\nHOST_DEVICE void _apply(Is..., Typelist&lt;&gt;)\n{\n    // ...\n}\n\ntemplate&lt;class... Is, class D0, class... Ds&gt;\nHOST_DEVICE void _apply(Is... is, Typelist&lt;D0, Ds...&gt; , D0 d0, Ds... ds) {\n    _apply&lt;Is..., decltype(std::declval&lt;Is&gt;()+std::declval&lt;D0&gt;())...&gt;(\n        is...,\n        (is+d0)...,\n        Typelist&lt;Ds...&gt;{},\n        ds...);\n}\n\ntemplate&lt;class... Ds&gt;\nHOST_DEVICE void apply(Ds... ds) {\n   _apply&lt;unsigned int&gt;(0u, Typelist&lt;Ds...&gt;{}, ds...);\n}\n</code></pre>\n<p>This works on every compiler.</p>\n", "LastActivityDate": "2017-01-30T17:30:41.753", "CommentCount": "0", "CreationDate": "2017-01-30T17:30:41.753", "ParentId": "41939827", "Score": "2", "OwnerUserId": "2069064"}, "41961545": {"Id": "41961545", "PostTypeId": "2", "Body": "<p>So I played with the code a bit and came up with 3 versions:</p>\n<p>Compiles in clang, fails with gcc:</p>\n<pre><code>template &lt;class..., class... Us&gt;\nvoid foo(Typelist&lt;&gt;, Typelist&lt;Us...&gt;, Us... us ){ /*do the stuff*/ }\n\ntemplate &lt;class T, class... Ts, class... Us&gt;\nvoid foo(Typelist&lt;T, Ts...&gt;, Typelist&lt;Us...&gt;, T t, Ts... ts, Us... us){\n    foo(Typelist&lt;Ts...&gt;{}, Typelist&lt;Us..., Us...&gt;{}, ts..., us..., (us+t)...);\n}\n\ntemplate &lt;class... Ts&gt;\nvoid bar(Ts... ts){\n    foo(Typelist&lt;Ts...&gt;{}, Typelist&lt;unsigned&gt;{}, ts..., 0u);\n}\n</code></pre>\n<p>Interesting, both typelist are required for this to work, although it seems that just one would be enough to resolve the ambiguity.</p>\n<p>Next one is from Barry's answer. It compiles with gcc, but fails with clang  for me:</p>\n<pre><code>template&lt;class... Is&gt;\nvoid foo(Is..., Typelist&lt;&gt;) { /*do the stuff*/ }\n\ntemplate&lt;class... Is, class D0, class... Ds&gt;\nvoid foo(Is... is, Typelist&lt;D0, Ds...&gt; , D0 d0, Ds... ds) {\n    foo&lt;Is..., decltype(std::declval&lt;Is&gt;()+std::declval&lt;D0&gt;())...&gt;(\n                is...,\n                (is+d0)...,\n                Typelist&lt;Ds...&gt;{},\n                ds...);\n}\n\ntemplate&lt;class... Ds&gt;\nvoid bar(Ds... ds) {\n    foo&lt;unsigned int&gt;(0u, Typelist&lt;Ds...&gt;{}, ds...);\n}\n</code></pre>\n<p>And finally the one working with both gcc(5.4, 6.3) and clang(3.9):</p>\n<pre><code>template&lt;class... Us&gt;\nstruct foo_impl&lt;Typelist&lt;&gt;, Typelist&lt;Us...&gt;&gt;{\n    auto operator()(Us... us)-&gt; void { /*do the stuff here*/ }\n};\n\ntemplate&lt;class T, class... Ts, class... Us&gt;\nstruct foo_impl&lt;Typelist&lt;T, Ts...&gt;, Typelist&lt;Us...&gt;&gt;{\n    auto operator()(T t, Ts... ts, Us... us)-&gt; void{\n        foo_impl&lt;Typelist&lt;Ts...&gt;, Typelist&lt;Us..., Us...&gt;&gt;{}(ts..., us..., (us+t)...);\n    }\n};\n\ntemplate &lt;class... Ts&gt;\nvoid bar(Ts... ts){\n    foo_impl&lt;Typelist&lt;Ts...&gt;, Typelist&lt;unsigned&gt;&gt;{}(ts..., 0u);\n}\n</code></pre>\n<p>Hope somebody finds this helpful.</p>\n", "LastActivityDate": "2017-01-31T15:41:33.807", "CommentCount": "0", "CreationDate": "2017-01-31T15:41:33.807", "ParentId": "41939827", "Score": "0", "OwnerUserId": "383522"}, "41939827": {"ViewCount": "83", "Body": "<p>I am trying to use variadics to convert <code>N</code> parameters function to <code>2^N</code> parameters function. The following snippet compiles happily by <code>clang 3.9</code>, while <code>nvcc 8.0</code> (effectively <code>gcc 5.4</code>) fails miserably with the error:</p>\n<pre><code>error: no instance of overloaded function \"foo\" matches the argument list\n</code></pre>\n<p>code:</p>\n<pre><code>template&lt;class... Ts&gt; struct Typelist{};\n\ntemplate &lt;class..., class... Us&gt;\nvoid foo(Typelist&lt;&gt;, Typelist&lt;Us...&gt;, Us... us ){\n//  do the actual work\n}\n\ntemplate &lt;class T, class... Ts, class... Us&gt;\nvoid foo(Typelist&lt;T, Ts...&gt;, Typelist&lt;Us...&gt;, T t, Ts... ts, Us... us){\n    foo(Typelist&lt;Ts...&gt;{}, Typelist&lt;Us..., Us...&gt;{}\n        , ts..., us..., (us+t)...);\n}\n\ntemplate &lt;class... Ts&gt;\nvoid bar(Ts... ts){\n    foo(Typelist&lt;Ts...&gt;{}, Typelist&lt;unsigned&gt;{}\n        , ts..., 0u);\n}\n</code></pre>\n<p>called like</p>\n<pre><code>int main(int /*argc*/, char */*argv*/[])\n{\n    bar(2u);\n    bar(2u, 3u, 4u);\n\n    return 0;\n}\n</code></pre>\n<p>Am I doing something wrong? How do I make it work with <code>gcc</code>?</p>\n", "AcceptedAnswerId": "41941916", "Title": "multiple parameter pack expansion by gcc and clang", "CreationDate": "2017-01-30T15:39:25.393", "Id": "41939827", "CommentCount": "8", "LastEditDate": "2017-01-31T15:25:37.117", "PostTypeId": "1", "LastEditorUserId": "383522", "LastActivityDate": "2017-01-31T15:41:33.807", "Score": "1", "OwnerUserId": "383522", "Tags": "<c++><gcc><clang><variadic-templates>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41939827_41941916_0": {"length": 9, "quality": 0.9, "section_id": 336}, "so_41939827_41941916_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 286}}, "n3337": {"so_41939827_41941916_0": {"length": 8, "quality": 0.8, "section_id": 293}, "so_41939827_41941916_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 277}}, "n4659": {"so_41939827_41941916_0": {"length": 9, "quality": 0.9, "section_id": 345}, "so_41939827_41941916_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 293}}}});