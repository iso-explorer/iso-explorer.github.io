post_cb({"17751031": {"CommentCount": "0", "ViewCount": "4494", "PostTypeId": "1", "LastEditorUserId": "763305", "CreationDate": "2013-07-19T16:26:16.543", "LastActivityDate": "2013-07-19T17:04:16.270", "Title": "Downcasting double to float: is overflow behaviour guaranteed?", "AcceptedAnswerId": "17751145", "LastEditDate": "2013-07-19T17:04:16.270", "Id": "17751031", "Score": "9", "Body": "<p>If I try this</p>\n<pre><code>float f = (float)numeric_limits&lt;double&gt;::infinity();\n</code></pre>\n<p>Or indeed, try to cast anything bigger than float max down to a float, am I guaranteed to end up with infinity?</p>\n<p>It works on GCC, but is it a standard though?</p>\n", "Tags": "<c++><casting><floating-point>", "OwnerUserId": "846550", "AnswerCount": "2"}, "17751118": {"ParentId": "17751031", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>From the C++11 standard, \u00a74.8.1:</p>\n<blockquote>\n<p id=\"so_17751031_17751118_0\">A prvalue of floating point type can be converted to a prvalue of\n  another floating point type. If the source value can be exactly\n  represented in the destination type, the result of the conversion is\n  that exact representation. If the source value is between two adjacent\n  destination values, the result of the conversion is an\n  implementation-defined choice of either of those values. Otherwise,\n  the behavior is undefined.</p>\n</blockquote>\n<p>This implies that</p>\n<ul>\n<li><p>If you cast double infinity to float, you get float infinity.</p></li>\n<li><p>If you cast a double value, that lies between float max and infinity, to float, then you get float max or float infinity.</p></li>\n</ul>\n", "OwnerUserId": "763305", "LastEditorUserId": "763305", "LastEditDate": "2013-07-19T16:51:01.710", "Id": "17751118", "Score": "6", "CreationDate": "2013-07-19T16:30:57.897", "LastActivityDate": "2013-07-19T16:51:01.710"}, "17751145": {"ParentId": "17751031", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_17751031_17751145_0\"><code>float f = (float)numeric_limits&lt;double&gt;::infinity();</code></p>\n</blockquote>\n<p>This is guaranteed to set <code>f</code> to infinity if your compilation platform offers IEEE 754 arithmetic for floating-point computations (it usually does).</p>\n<blockquote>\n<p id=\"so_17751031_17751145_1\">Or indeed, try to cast anything bigger than float max down to a float, am I guaranteed to end up with infinity?</p>\n</blockquote>\n<p>No. In the default IEEE 754 round-to-nearest mode, a few <code>double</code> values above the maximum finite <code>float</code> (that is, <code>FLT_MAX</code>) convert to <code>FLT_MAX</code>. The exact limit is the number midway between <code>FLT_MAX</code> (<code>0x1.fffffep127</code> in C99 hexadecimal representation) and the next <code>float</code> number that could be represented if the exponent in the single-precision format had a larger range, <code>0x2.0p128</code>. The limit is thus <code>0x1.ffffffp127</code> or approximately 3.4028235677973366e+38 in decimal.</p>\n", "OwnerUserId": "139746", "LastEditorUserId": "139746", "LastEditDate": "2013-07-19T16:45:28.153", "Id": "17751145", "Score": "7", "CreationDate": "2013-07-19T16:32:41.007", "LastActivityDate": "2013-07-19T16:45:28.153"}, "bq_ids": {"n4140": {"so_17751031_17751118_0": {"section_id": 35, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_17751031_17751118_0": {"section_id": 32, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_17751031_17751118_0": {"section_id": 35, "quality": 0.8717948717948718, "length": 34}}}});