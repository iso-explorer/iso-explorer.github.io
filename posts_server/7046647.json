post_cb({"7046771": {"ParentId": "7046647", "CommentCount": "14", "Body": "<p>Well, when you try to get <code>B&lt;A&gt;::C_type</code>, you have to instantiate <code>template &lt;typename&gt; B</code>, but you cannot instantiate the template on an incomplete type because it contains a member object <code>T my_t</code> which mustn't be incomplete -- the compiler doesn't know that you only want to get at the member typedef of <code>B&lt;A&gt;</code>.</p>\n<p>In <code>func2</code>, you only use <code>B&lt;A&gt;</code> as a return type, which is allowed to be incomplete -- we don't need to instantiate <code>B&lt;A&gt;</code> in order to allow it as a return type. But to access the member (typedef) we <em>do</em> need to instantiate <code>B&lt;A&gt;</code>. Furhtermore, <code>func4</code> is fine because <code>Other</code> is a complete type.</p>\n<p>The solution is simple, just resolve the typedef by hand and make the return type of <code>func3</code> into <code>C&lt;A&gt;</code>.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "7046771", "Score": "3", "CreationDate": "2011-08-12T21:57:42.200", "LastActivityDate": "2011-08-12T21:57:42.200"}, "7047597": {"ParentId": "7046647", "CommentCount": "0", "Body": "<p><strong>It is a circular reference:</strong></p>\n<p>In order for the compiler to understand what the structure <code>A</code> is, it must be able to understand what <code>B&lt;A&gt;::C_type</code> (since it contains a member that returns an object of this type). So, in order to understand what <code>B&lt;A&gt;::C_type</code> is, the compiler must understand what <code>B&lt;A&gt;</code> is. But in order to understand what <code>B&lt;A&gt;</code> is, the compiler needs to know what <code>A</code> is.</p>\n<p>Essentially, you've given the compiler a paradox: in order to understand what <code>A</code> is, you need to first know what <code>A</code> is.</p>\n", "OwnerUserId": "591057", "PostTypeId": "2", "Id": "7047597", "Score": "0", "CreationDate": "2011-08-13T00:10:14.077", "LastActivityDate": "2011-08-13T00:10:14.077"}, "7047049": {"ParentId": "7046647", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-08-12T22:35:29.593", "Score": "3", "LastEditorUserId": "560648", "LastEditDate": "2011-08-12T23:09:41.840", "Id": "7047049", "OwnerUserId": "560648", "Body": "<p>There are a few factors at play here.</p>\n<hr>\n<h2><code>A</code> is incomplete</h2>\n<p>First, in all the function declarations:</p>\n<pre><code>B&lt;A&gt;             func2();\nB&lt;A&gt;::C_type     func3();\nB&lt;Other&gt;::C_type func4();\n</code></pre>\n<p><code>A</code> is an incomplete type:</p>\n<blockquote>\n<p id=\"so_7046647_7047049_0\"><code>[2003: 9.2/2]:</code> A class is considered a completely-defined object type (3.9) (or\n  complete type) at the closing <code>}</code> of the <em>class-specifier</em>. Within the\n  class <em>member-specification</em>, the class is regarded as complete within\n  function bodies, default arguments, and constructor ctor-initializers (including such things in nested classes). <strong>Otherwise it is regarded as\n  incomplete within its own class <em>member-specification</em>.</strong></p>\n</blockquote>\n<hr>\n<h2><code>B&lt;A&gt;</code> needs to be instantiated</h2>\n<h3><code>func2</code> and <code>func4</code> are OK</h3>\n<p>Second, the function return type <em>may</em> be incomplete. That means that the return types of <code>func2</code> and <code>func4</code> are fine just the way they are.</p>\n<blockquote>\n<p id=\"so_7046647_7047049_1\"><code>[2003: 8.3.5/6]:</code> [..] The type of a parameter or the return type for\n  a function definition shall not be an incomplete class type (possibly\n  cv-qualified) unless the function definition is nested within the\n  <em>member-specification</em> for that class (including definitions in nested\n  classes defined within the class).</p>\n</blockquote>\n<h3><code>func3</code> is not OK</h3>\n<p>However, in the more complex example of <code>func3</code>, in order to use the type <code>B&lt;A&gt;::C_type</code>, <code>B&lt;A&gt;</code> must be complete.*</p>\n<p>And so it must also be <em>instantiated</em>:</p>\n<blockquote>\n<p id=\"so_7046647_7047049_2\"><code>[2003: 14.7.1/1]:</code> Unless a class template specialization has been\n  explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),\n  <strong>the class template specialization is implicitly instantiated when the\n  specialization is referenced in a context that requires a\n  completely-defined object type</strong> or when the completeness of the class\n  type affects the semantics of the program. [..]</p>\n</blockquote>\n<p>But, because <code>B&lt;A&gt;</code> contains a member of type <code>A</code>, and <code>A</code> is not a complete type, and <code>[8.3.5/6]</code> requires it to be, the instantiation is invalid, <code>B&lt;A&gt;</code> remains incomplete... and the program is ill-formed.</p>\n<hr>\n<p><sup>* I haven't yet found a citation to back this up, though it seems obvious.</sup></p>\n</hr></hr></hr>", "LastActivityDate": "2011-08-12T23:09:41.840"}, "7046873": {"ParentId": "7046647", "CommentCount": "5", "Body": "<p>I think the relevant paragraph comes from the classes chapter 2:</p>\n<blockquote>\n<p id=\"so_7046647_7046873_0\">A class is considered a completely-defined object type (3.9) (or\n  complete type) at the closing } of the class-specifier. Within the\n  class member-specification, the class is regarded as complete within\n  function bodies, default arguments, exception-specifications, and\n  brace-or-equal-initializers for non-static data members (including\n  such things in nested classes). Otherwise it is regarded as incomplete\n  within its own class member-specification.</p>\n</blockquote>\n<pre><code>B&lt;A&gt; func2()  //A is incomplete here, but B&lt;A&gt; isn't instantiated\n{\n    return B&lt;A&gt;();  //A is complete here\n}\n\nB&lt;A&gt;::C_type func3() //A is incomplete, B&lt;A&gt; needs to be instantiated for C_type\n{\n    return B&lt;A&gt;::C_type(); //OK, A is complete\n}\n</code></pre>\n", "OwnerUserId": "155693", "PostTypeId": "2", "Id": "7046873", "Score": "1", "CreationDate": "2011-08-12T22:11:49.317", "LastActivityDate": "2011-08-12T22:11:49.317"}, "7046747": {"ParentId": "7046647", "CommentCount": "1", "Body": "<p>You can store the member <code>my_t</code> in <code>template &lt;typename T&gt; struct B</code> as pointer and handle its construction, destruction and copying in <code>struct B</code>, like so:</p>\n<pre><code>template &lt;typename T&gt;\nstruct B\n{\n    typedef C&lt;T&gt; C_type;\n    T* my_t;\n};\n</code></pre>\n", "OwnerUserId": "308392", "PostTypeId": "2", "Id": "7046747", "Score": "-1", "CreationDate": "2011-08-12T21:55:12.370", "LastActivityDate": "2011-08-12T21:55:12.370"}, "bq_ids": {"n4140": {"so_7046647_7047049_1": {"section_id": 3245, "quality": 0.8888888888888888, "length": 24}, "so_7046647_7047049_0": {"section_id": 5862, "quality": 0.8888888888888888, "length": 32}, "so_7046647_7046873_0": {"section_id": 5862, "quality": 1.0, "length": 37}, "so_7046647_7047049_2": {"section_id": 233, "quality": 0.84375, "length": 27}}, "n3337": {"so_7046647_7047049_1": {"section_id": 3118, "quality": 0.8888888888888888, "length": 24}, "so_7046647_7047049_0": {"section_id": 5632, "quality": 0.8888888888888888, "length": 32}, "so_7046647_7046873_0": {"section_id": 5632, "quality": 1.0, "length": 37}, "so_7046647_7047049_2": {"section_id": 226, "quality": 0.84375, "length": 27}}, "n4659": {"so_7046647_7047049_2": {"section_id": 242, "quality": 0.84375, "length": 27}, "so_7046647_7046873_0": {"section_id": 7345, "quality": 0.8648648648648649, "length": 32}, "so_7046647_7047049_0": {"section_id": 7345, "quality": 0.8888888888888888, "length": 32}}}, "7046647": {"CommentCount": "5", "ViewCount": "143", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-08-12T21:44:33.077", "LastActivityDate": "2011-08-13T00:10:14.077", "Title": "Function returning T<A> doesn't compile in certain typedef situation", "LastEditDate": "2011-08-12T22:03:54.400", "Id": "7046647", "Score": "4", "Body": "<p>I don't understand why <code>func3()</code> can't compile, when <code>func2()</code> and <code>func4()</code> do.</p>\n<ul>\n<li><a href=\"http://codepad.org/about\" rel=\"nofollow\">g++ 4.1.2</a>: <code>error: 'B&lt;T&gt;::my_t' has incomplete type</code></li>\n<li>VS2008: <code>error C2079: 'B&lt;T&gt;::my_t' uses undefined class 'A'</code></li>\n</ul>\n<hr>\n<pre><code>template &lt;typename T&gt;\nstruct C {\n    T mt_t;\n};\n\ntemplate &lt;typename T&gt;\nstruct B {\n    typedef C&lt;T&gt; C_type;\n    T my_t;\n};\n\nstruct Other {};\n\nstruct A {\n    B&lt;A&gt;             func2();\n    B&lt;A&gt;::C_type     func3(); // error: 'B&lt;T&gt;::my_t' has incomplete type\n    B&lt;Other&gt;::C_type func4();\n};\n\nint main() {}\n</code></pre>\n</hr>", "Tags": "<c++><templates><typedef>", "OwnerUserId": "892515", "AnswerCount": "5"}});