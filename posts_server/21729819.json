post_cb({"bq_ids": {"n4140": {"so_21729819_21730048_0": {"section_id": 7107, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_21729819_21730048_0": {"section_id": 6851, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_21729819_21730048_0": {"section_id": 8608, "quality": 0.9629629629629629, "length": 26}}}, "21729819": {"CommentCount": "4", "AcceptedAnswerId": "21730048", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-02-12T13:49:57.610", "LastActivityDate": "2014-02-13T10:47:36.187", "LastEditDate": "2014-02-13T01:22:23.637", "ViewCount": "159", "FavoriteCount": "1", "Title": "Is it correct to have a variable with the same name as a namespace", "Id": "21729819", "Score": "4", "Body": "<p>Is it correct to do this? :</p>\n<pre><code>namespace name {\n    int name;\n}\n\nvoid proc(int name)\n{\n    name::name = name;\n}\n\nint main()\n{\n    int name = name::name;   \n    return 0;\n}\n</code></pre>\n<p>It works in GCC. But is this OK with standard and other compilers?</p>\n", "Tags": "<c++><namespaces><language-lawyer><identifier>", "OwnerUserId": "3123061", "AnswerCount": "2"}, "21730244": {"ParentId": "21729819", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, it is perfectly fine to do that.\nNamespaces are literally designed to resolve this kind of issue once the size of the code/project grows larger.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/namespace\" rel=\"nofollow\">Here</a> is a good place to check things out about C++.</p>\n", "OwnerUserId": "2827599", "LastEditorUserId": "2827599", "LastEditDate": "2014-02-12T14:14:53.450", "Id": "21730244", "Score": "1", "CreationDate": "2014-02-12T14:08:40.663", "LastActivityDate": "2014-02-12T14:14:53.450"}, "21730048": {"ParentId": "21729819", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes this is okay, we need to look at how the <em>scope resolution operator</em> works in this context. If we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>3.4.3</code> <em>Qualified name lookup</em> actually has a very similar example, it says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_21729819_21730048_0\">If a :: scope resolution operator in a nested-name-specifier is not preceded by a decltype-specifier, <strong>lookup of the name preceding that :: considers only namespaces, types, and templates whose specializations are types</strong>. If the name found does not designate a namespace or a class, enumeration, or dependent type, the program is ill-formed.[ Example:</p>\n</blockquote>\n<pre><code>class A {\npublic:\n    static int n;\n};\n\nint main() {\n    int A;\n    A::n = 42; // OK\n    A b; // ill-formed: A does not name a type\n}\n</code></pre>\n<blockquote>\n<p id=\"so_21729819_21730048_1\">\u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-02-13T10:47:36.187", "Id": "21730048", "Score": "4", "CreationDate": "2014-02-12T13:59:33.337", "LastActivityDate": "2014-02-13T10:47:36.187"}});