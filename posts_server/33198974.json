post_cb({"33201576": {"ParentId": "33198974", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The first copy is made by the <code>std::bind</code> itself:</p>\n<pre><code>std::bind(_cb, std::forward&lt;RfTs&gt;(args)...)\n</code></pre>\n<p>as it needs to store decayed-copies of its arguments.</p>\n<p>The other two copies are made by the assignment to <code>_cbWithArgs</code> which is of type <code>std::function</code> (\u00a7 20.8.11.2.1 [func.wrap.func.con]):</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);\n</code></pre>\n<p id=\"so_33198974_33201576_0\"><sup>18</sup> <em>Effects:</em> <code>function(std::forward&lt;F&gt;(f)).swap(*this);</code></p>\n</blockquote>\n<p>where:</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\n</code></pre>\n<p id=\"so_33198974_33201576_1\"><sup>9</sup> [...] <code>*this</code> targets a copy of <code>f</code> initialized with <code>std::move(f)</code>.</p>\n</blockquote>\n<p>That is, one copy for the parameter of a constructor, and another one to store  argument <code>f</code>.</p>\n<p>Since <code>Args</code> is a non-movable type, an attempt to <em>move from</em> a result of a call to <code>std::bind</code> falls back to a copy.</p>\n<p>It doesn't seem reasonable in your code to store the results of job execution in a <code>std::function</code>. Instead, you can store those values in a tuple:</p>\n<pre><code>template &lt;typename T, typename... Args&gt;\nclass Job\n{\npublic:\n    Job(std::weak_ptr&lt;T&gt; wp, std::function&lt;void(const Args&amp;...)&gt; &amp;&amp;cb)\n        : _cb(std::move(cb)), \n          _owner(wp) {}\n\npublic:\n    template&lt;typename... RfTs&gt;\n    void bind(RfTs&amp;&amp;... args)\n    {\n        _args = std::forward_as_tuple(std::forward&lt;RfTs&gt;(args)...);\n    }\n\n    void fire()\n    {\n        auto sp = _owner.lock();\n        if (sp)\n        {\n            apply(std::index_sequence_for&lt;Args...&gt;{});\n        }\n    }\n\nprivate:    \n    template &lt;std::size_t... Is&gt;\n    void apply(std::index_sequence&lt;Is...&gt;)\n    {\n        _cb(std::get&lt;Is&gt;(_args)...);\n    }\n\n    std::function&lt;void(const Args&amp;...)&gt; _cb;\n    std::weak_ptr&lt;T&gt; _owner;\n    std::tuple&lt;Args...&gt; _args;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/57b5d2b16570b050\" rel=\"nofollow\"><strong>DEMO</strong></a></p>\n", "OwnerUserId": "3953764", "LastEditorUserId": "5459549", "LastEditDate": "2015-10-20T09:14:57.440", "Id": "33201576", "Score": "5", "CreationDate": "2015-10-18T18:19:30.360", "LastActivityDate": "2015-10-20T09:14:57.440"}, "33198974": {"CommentCount": "0", "AcceptedAnswerId": "33201576", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-18T14:17:20.390", "LastActivityDate": "2015-10-20T10:26:45.767", "LastEditDate": "2017-05-23T11:44:46.990", "ViewCount": "246", "FavoriteCount": "1", "Title": "Too many copies when binding variadic template arguments", "Id": "33198974", "Score": "5", "Body": "<p>I'm creating a job queue. The job will be created in thread A, then the job will be sent to thread B and thread B will do the job. After the job has been done, the job will be sent back to thread A.</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T, typename... Args&gt;\nclass Job\n{\n    public:\n        Job(std::weak_ptr&lt;T&gt; &amp;&amp;wp, std::function&lt;void(const Args&amp;...)&gt; &amp;&amp;cb)\n            : _cb(std::move(cb)), \n              _cbWithArgs(), \n              _owner(std::move(wp)) {}\n\n    public:\n        template&lt;typename... RfTs&gt;\n        void bind(RfTs&amp;&amp;... args)\n        {\n            // bind will copy args for three times.\n            _cbWithArgs = std::bind(_cb, std::forward&lt;RfTs&gt;(args)...);\n        }\n\n        void fire()\n        {\n            auto sp = _owner.lock();\n            if (sp)\n            {\n                _cbWithArgs();\n            }\n        }\n\n    private:\n        std::function&lt;void(const Args&amp; ...)&gt; _cb;\n        std::function&lt;void()&gt; _cbWithArgs;\n        std::weak_ptr&lt;T&gt; _owner;\n};\n\nstruct Args\n{\n    Args() = default;\n    Args(const Args &amp;args)\n    {\n        cout &lt;&lt; \"Copied\" &lt;&lt; endl;\n    }\n};\n\nstruct Foo\n{\n    void show(const Args &amp;)\n    {\n        cout &lt;&lt; \"Foo\" &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    using namespace std::placeholders;\n\n    shared_ptr&lt;Foo&gt; sf (new Foo());\n    Args args;\n\n    // Let's say here thread A created the job.\n    Job&lt;Foo, Args&gt; job(sf, std::bind(&amp;Foo::show, sf.get(), _1));\n\n    // Here thread B has finished the job and bind the result to the\n    // job. \n    job.bind(args);\n\n    // Here, thread A will check the result.\n    job.fire();\n}\n</code></pre>\n<p>The above codes compiles and works. But it gives the following results (g++ 4.8.4 &amp; clang have the same results):</p>\n<pre><code>Copied\nCopied\nCopied\nFoo\n</code></pre>\n<p>There are three copies! Not acceptable, I don't know where I did wrong. Why three copies? I googled and find a method from here: <a href=\"https://stackoverflow.com/a/16868401\">https://stackoverflow.com/a/16868401</a>, it only copys params for one time. But it has to initialize the bind function in constructor.</p>\n<p>Thanks, Piotr Skotnicki. Unfortunately, I don't have a C++14 compiler. So, let's make the Args movable:</p>\n<pre><code>struct Args\n{\n    Args() = default;\n    Args(const Args &amp;args)\n    {\n        cout &lt;&lt; \"Copied\" &lt;&lt; endl;\n    }\n    Args(Args &amp;&amp;) = default;\n    Args&amp; operator=(Args &amp;&amp;) = default;\n};\n</code></pre>\n<p>Now, it copys just one time :)</p>\n<p>Finally, I adopted the codes from this thread <a href=\"https://stackoverflow.com/a/16868151/5459549\">https://stackoverflow.com/a/16868151/5459549</a>. The template gen_seq is true ART, I must say.</p>\n", "Tags": "<c++><templates><c++11><bind><variadic-templates>", "OwnerUserId": "5459549", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33198974_33201576_1": {"section_id": 4662, "quality": 1.0, "length": 4}}, "n3337": {"so_33198974_33201576_1": {"section_id": 4472, "quality": 1.0, "length": 4}}, "n4659": {"so_33198974_33201576_1": {"section_id": 6032, "quality": 1.0, "length": 4}}}});