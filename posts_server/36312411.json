post_cb({"36313320": {"ParentId": "36312411", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_36312411_36313320_0\">What is the difference between initializing with <code>=</code> and initializing with <code>{}</code>?</p>\n</blockquote>\n<p>In general, the difference is that the former is <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow\">copy initialization</a> and the latter is <a href=\"http://en.cppreference.com/w/cpp/language/direct_initialization\" rel=\"nofollow\">direct</a> - <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"nofollow\">list initialization</a>. The linked online reference describes all three forms of initialization in detail. In particular, there is the difference that you already quoted; List initialization may not be used with narrowing conversions.</p>\n<blockquote>\n<p id=\"so_36312411_36313320_1\">But the code on the right hand side loses some information even after using <code>{}</code></p>\n</blockquote>\n<p>The program on the right side is ill-formed.</p>\n<p>As mentioned, the standard does not allow narrowing <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">conversions</a> in the context of list initialization. <code>int</code> to <code>char</code> is a narrowing conversion.</p>\n<p>Because the program is ill-formed, the standard does not guarantee its behaviour except that a compiler is required to emit a diagnostic message. For example, g++-5.3.0 will say:</p>\n<pre><code>warning: narrowing conversion of 'x' from 'int' to 'char' inside { } [-Wnarrowing]\n</code></pre>\n<blockquote>\n<p id=\"so_36312411_36313320_2\">May you please elaborate on the \"ill-formed\" part?</p>\n</blockquote>\n<p>Standard says that the program shall not do X. Your program does X. Therefore it violates the standard which makes the program ill-formed. Here, X is:</p>\n<blockquote>\n<p id=\"so_36312411_36313320_3\">If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</p>\n</blockquote>\n<hr>\n<p>The program on the left is not ill-formed. However it, just like the program on the right side, does assign a value to <code>char y</code> that is not representable by the <code>char</code> type (it could be representable in some implementation where <code>char</code> is an unsigned type, but given the output, that appears not to be the case for your implementation). When an unrepresentable value is converted to a signed type, the resulting value is implementation defined.</p>\n</hr>", "OwnerUserId": "2079303", "LastEditorUserId": "4850040", "LastEditDate": "2016-03-30T16:35:11.290", "Id": "36313320", "Score": "7", "CreationDate": "2016-03-30T15:29:46.270", "LastActivityDate": "2016-03-30T16:35:11.290"}, "36312411": {"CommentCount": "7", "ViewCount": "217", "PostTypeId": "1", "LastEditorUserId": "4563555", "CreationDate": "2016-03-30T14:50:32.897", "LastActivityDate": "2016-03-30T16:35:11.290", "Title": "What is the difference between initializing with = and initializing with {}?", "AcceptedAnswerId": "36313320", "LastEditDate": "2016-03-30T15:29:06.760", "Id": "36312411", "Score": "5", "Body": "<p>You can initialize a variable using = . For example:</p>\n<pre><code>int a = 1000;\n</code></pre>\n<p>C++ 11 introduced an extra notation {} . For example:</p>\n<pre><code>int a {1000};\n</code></pre>\n<p>According to Programming: Principles and Practices by Bjarne Stroustrup: </p>\n<blockquote>\n<p id=\"so_36312411_36312411_0\">C++11 introduced an initialization notation that outlaws narrowing conversions.</p>\n</blockquote>\n<p>I wanted to check out this cool feature. And I typed a piece of code twice:</p>\n<pre><code>#include \"std_lib_facilities.h\"     |     #include \"std_lib_facilities.h\" \n                                    |\nint main()                          |     int main()\n                                    |\n{                                   |     {\n    int x = 254;                    |         int x {254};\n    char y = x;                     |         char y {x};\n    int z = y;                      |         int z {y};\n                                    |\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n'     |         cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n'\n         &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; '\\n'     |              &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; '\\n'\n         &lt;&lt; \"z = \" &lt;&lt; z &lt;&lt; '\\n';    |              &lt;&lt; \"z = \" &lt;&lt; z &lt;&lt; '\\n';\n                                    |\n}                                   |     }\n</code></pre>\n<p>The code on the left uses = whereas the code on the right uses {}</p>\n<p>But the code on the right hand side loses some information even after using {}. Thus the output is same in both pieces of code:</p>\n<blockquote>\n<p id=\"so_36312411_36312411_1\">x = 254</p>\n<p id=\"so_36312411_36312411_2\">y = \u25a0</p>\n<p id=\"so_36312411_36312411_3\">z = -2</p>\n</blockquote>\n<p>So, what's the difference between initializing with = and initializing with {} ?</p>\n<p>EDIT: My question may or may not be a duplicate. I'm just a beginner and I do not even understand the code of the possibly original question. I'm no judge. Even if it's a duplicate, I cannot understand any answers of that question. I feel that this question should be treated as an original one since I would understand simple language opposed to some high-level words of that question's answer. </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4563555", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36312411_36313320_3": {"section_id": 3325, "quality": 1.0, "length": 8}}, "n3337": {"so_36312411_36313320_3": {"section_id": 3195, "quality": 1.0, "length": 8}}, "n4659": {"so_36312411_36313320_3": {"section_id": 4091, "quality": 1.0, "length": 8}}}});