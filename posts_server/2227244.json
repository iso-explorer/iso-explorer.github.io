post_cb({"2227265": {"ParentId": "2227244", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is not really about some specific compiler deciding what's reasonable and what's not. The language specification explicitly says that in <code>inner(inner)</code> used in the constructors initializer list the first <code>inner</code> should be looked up in class scope (i.e. resolve to <code>COuter::inner</code>), while the second <code>inner</code>should  be looked up in the constructor scope (i.e. resolve to constructor parameter <code>inner</code>). </p>\n<p>This is what you described as VC++ behavior. However, I find it hard to believe that GCC would behave incorrectly in this case (unless you have some weird old version of GCC). Are you sure you haven't misinterpreted GCC's behavior somehow?</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2010-02-09T18:02:51.960", "Id": "2227265", "Score": "25", "CreationDate": "2010-02-09T06:41:05.550", "LastActivityDate": "2010-02-09T18:02:51.960"}, "2227244": {"CommentCount": "13", "ViewCount": "6642", "CreationDate": "2010-02-09T06:33:34.757", "LastActivityDate": "2010-02-09T18:02:51.960", "Title": "What if a constructor parameter has the same name as a member variable in C++?", "FavoriteCount": "3", "PostTypeId": "1", "Id": "2227244", "Score": "7", "Body": "<p>Some code first:</p>\n<pre><code>class CInner {\npublic:\n    CInner( const CInner&amp; another ) { //impl here }\nprivate:\n    // some member variables\n}\n\nclass COuter {\npublic:\n    COuter( const CInner&amp; inner ) : inner( inner ) {}\nprivate:\n    CInner inner;\n}\n</code></pre>\n<p>Yes, in <code>COuter::COuter( const CInner&amp; )</code> the parameter has the same name as the member variable.</p>\n<p>In VC++ that works - VC++ gets the idea that it is only reasonable to initialize the member variable with the parameter and that's what happens - <code>CInner::inner</code> gets initialized with the parameter. But when the same is compiled with GCC it is interpreted in another way: GCC initializes <code>CInner::inner</code> <em>with itself</em> and so it is left uninitialized.</p>\n<p>Which of the compilers is right?</p>\n", "Tags": "<c++><visual-c++><gcc><initialization>", "OwnerUserId": "57428", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2227244_2227278_0": {"section_id": 440, "quality": 1.0, "length": 10}}, "n3337": {"so_2227244_2227278_0": {"section_id": 431, "quality": 1.0, "length": 10}}, "n4659": {"so_2227244_2227278_0": {"section_id": 460, "quality": 1.0, "length": 10}}}, "2227278": {"ParentId": "2227244", "CommentCount": "3", "Body": "<p>Visual C++ is correct. I suspect you're using an older version of gcc for your test -- at least as I recall, recent ones do this correctly. This is covered in \u00a712.6.2/7 of the standard, which gives the following example:</p>\n<pre><code>class X {\n\n    int a;\n    int b;\n    int i;\n    int j;\n\npublic:\n    const int&amp; r;\n\n    X(int i): r(a), b(i), i(i), j(this-&gt;i) {}\n\n};\n</code></pre>\n<blockquote>\n<p id=\"so_2227244_2227278_0\">initializes X::r to refer to X::a, initializes X::b with the value of the constructor\n  parameter i, initializes X::i with the value of the constructor parameter i, [ ...]</p>\n</blockquote>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "2227278", "Score": "12", "CreationDate": "2010-02-09T06:44:26.810", "LastActivityDate": "2010-02-09T06:44:26.810"}});