post_cb({"bq_ids": {"n4140": {"so_21225086_21225154_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 434}, "so_21225086_21225154_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 435}}, "n3337": {"so_21225086_21225154_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 426}, "so_21225086_21225154_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 427}}, "n4659": {"so_21225086_21225154_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 452}, "so_21225086_21225154_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 454}}}, "21225086": {"ViewCount": "329", "Body": "<p>See the following code:</p>\n<pre><code>struct Object;\n\nstruct Component\n{\n    Component(Object* obj) { }\n};\n\nstruct Renderable : public virtual Component\n{\n    virtual void Render() = 0;\n};\n\nstruct AnimationRenderer : public Renderable\n{\n    AnimationRenderer(Object* obj) : Component(obj) { }\n    virtual void Render() { }\n};\n</code></pre>\n<p>This fails to compile, because there is no matching call to <code>Component::Component()</code> from <code>Renderable::Renderable()</code>.</p>\n<p>I can make this sample work by giving <code>Renderable</code> a constructor such as <code>Renderable() : Component(NULL) { }</code>, <strong>even though Renderable will never be able to initialize Component</strong>.</p>\n<p>Because <code>Renderable</code> is an abstract class, it can never be instantiated directly. Because it virtually inherits from <code>Component</code>, it will never be able to invoke initialization of <code>Component</code>.</p>\n<p>What is the reason for the language requiring code that will never/can never be invoked?</p>\n", "AcceptedAnswerId": "21225154", "Title": "Why do abstract derived classes need to initialize a virtual base class?", "CreationDate": "2014-01-20T01:53:56.863", "LastActivityDate": "2014-01-20T02:12:25.503", "CommentCount": "4", "LastEditDate": "2014-01-20T02:11:41.483", "PostTypeId": "1", "Tags": "<c++><inheritance><virtual-inheritance>", "Id": "21225086", "AnswerCount": "1", "Score": "3", "OwnerUserId": "214796", "ClosedDate": "2015-10-14T21:57:10.603", "LastEditorUserId": "103167"}, "21225154": {"Id": "21225154", "PostTypeId": "2", "Body": "<p>Actually, the language doesn't require that.  Your compiler is not using the current C++ rules.</p>\n<p>12.6.2p8 says (boldface mine for emphasis):</p>\n<blockquote>\n<p id=\"so_21225086_21225154_0\">[ Note: An abstract class is never a most derived class, thus its constructors never initialize virtual base classes, therefore <strong>the corresponding <em>mem-initializers</em> may be  omitted.</strong> \u2014 end  note ]</p>\n</blockquote>\n<p>I can't find that rule in C++03, so this is a recognized flaw in C++ that has since been fixed.  Look for a compiler update that supports C++11.</p>\n<p>The closest related rule in C++03 I can find was in section 12.6.2p6:</p>\n<blockquote>\n<p id=\"so_21225086_21225154_1\">A <em>mem-initializer</em> naming a virtual base class shall be ignored during execution of the constructor of any class that is not the most derived class.</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-01-20T02:12:25.503", "Score": "2", "CreationDate": "2014-01-20T02:05:30.830", "ParentId": "21225086", "CommentCount": "3", "LastEditDate": "2014-01-20T02:12:25.503", "OwnerUserId": "103167"}});