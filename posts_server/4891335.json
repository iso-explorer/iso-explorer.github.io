post_cb({"4891681": {"Id": "4891681", "PostTypeId": "2", "Body": "<p>7.1.5.3 p2 says:</p>\n<blockquote>\n<p id=\"so_4891335_4891681_0\">[Note: this implies that, within a\n  class template with  a template\n  type-parameter T, the declaration\n  friend class T; is  ill-formed.]</p>\n</blockquote>\n<p>As a result, any solution that allows you to it by any mean will be non standard conformant.</p>\n", "OwnerDisplayName": "user405725", "LastActivityDate": "2011-02-03T21:00:59.473", "Score": "1", "CreationDate": "2011-02-03T21:00:59.473", "ParentId": "4891335", "CommentCount": "2"}, "4891335": {"ViewCount": "896", "Body": "<p>It's impossible to friend a template parameter because the standard disallows it.  How might I get effectively the same thing then?</p>\n<p>What I want is basically a type that is unusable outside the object which owns it.  Why is rather beside the point but if you really must know, I'm trying to formulate a set of smart pointers that answer the problem of sharing an owned resource.  Thus what I'm looking to do is something like so, if it worked:</p>\n<pre><code>template &lt; typename T, typename Owner &gt;\nstruct accessible_member\n{\nprivate:\n  accessible_member() : val(T()) {}\n  accessible_member(T const&amp; t) : val(t) {}\n\n  operator T&amp; () { return val; }\n  operator T const&amp; () const { return val; }\n\n  member_ptr&lt;T&gt; operator &amp; () { return member_ptr&lt;T&gt;(val); }\n\n  friend class Owner;\n};\n</code></pre>\n<p>Thus a class can't hold this object as a member unless it declares itself the owner, and if it's silly enough to expose it as is, it will be impossible to use outside the class being so stupid.</p>\n", "AcceptedAnswerId": "4891661", "Title": "Friending a template parameter", "CreationDate": "2011-02-03T20:27:15.530", "Id": "4891335", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-12-25T01:38:10.477", "Score": "7", "OwnerUserId": "301883", "Tags": "<c++><templates><friend>", "AnswerCount": "6"}, "4891661": {"Id": "4891661", "PostTypeId": "2", "Body": "<p>You could use this, and then let all the owners inherit from <strong>Owner</strong>.</p>\n<p>You could then use <strong>Owner</strong> class to wrap privately the methods used in  <strong>accessible_member</strong>.<br>\n<strong>accessible_member</strong> is now accessible to <strong>Owner</strong>. Friend is not inherited, so you can supply (wrap) the necessary methods so all the classes that inherit Owner can use <strong>accessible_member</strong>.</br></p>\n<p>It's a 2 level solution but it keeps the level of encapsulation.</p>\n<pre><code>template &lt; typename U &gt;\nstruct Owner \n{\n   protected:\n   accessible_member&lt;U&gt; newAccessible_member() { return accessible_member&lt;U&gt;(); }\n   accessible_member&lt;U&gt; newAccessible_member(U const&amp; u) { return accessible_member&lt;U&gt;(u); }\n   .....\n\n};\n\ntemplate &lt; typename T &gt;\nstruct accessible_member\n{\nprivate:\n  accessible_member() : val(T()) {}\n  accessible_member(T const&amp; t) : val(t) {}\n\n  operator T&amp; () { return val; }\n  operator T const&amp; () const { return val; }\n\n  member_ptr&lt;T&gt; operator &amp; () { return member_ptr&lt;T&gt;(val); }\n\n\n  template &lt; typename U&gt; friend class Owner;\n};\n</code></pre>\n<p>Then you can use the accessible_member indirectly in structs that inherit from Owner using the protected methods:</p>\n<pre><code>struct Blah: Owner&lt;int&gt;\n{\n   void Dosomething() {\n       accessible_member&lt;int&gt; blah= newAccessible_member();\n   }\n};\n</code></pre>\n<p>Look at the last example at <a href=\"http://msdn.microsoft.com/en-us/library/f1b2td24.aspx\" rel=\"nofollow\">Template Friends</a>.</p>\n", "LastEditorUserId": "536086", "LastActivityDate": "2011-02-03T22:01:55.640", "Score": "3", "CreationDate": "2011-02-03T20:58:32.203", "ParentId": "4891335", "CommentCount": "12", "OwnerUserId": "536086", "LastEditDate": "2011-02-03T22:01:55.640"}, "4892379": {"Id": "4892379", "PostTypeId": "2", "Body": "<p>The only workaround I can see is rather ugly and uses the CRTP:</p>\n<pre><code>template &lt;typename T&gt;\nstruct CanUseAccessibleMember\n{\n    template &lt;typename T&gt;\n    static const T&amp; get(const accessible_member&lt;T&gt;&amp; m)\n    { return static_cast&lt;const T&amp;&gt;(m); }\n\n    // Etc. You can even specialize this class.\n};\n\nstruct ExampleOwner \n    : protected CanUseAccessibleMember&lt;ExampleOwner&gt;\n{\n    // Do whatever you want with accessible members here\n    // but you have to use the get syntax\n};\n\ntemplate &lt;typename T, typename Owner&gt;\nclass accessible_member\n{\n    // Implement members as you did\n\n    friend struct CanUseAccessibleMember&lt;Owner&gt;;\n};\n</code></pre>\n", "LastActivityDate": "2011-02-03T22:17:14.387", "CommentCount": "2", "CreationDate": "2011-02-03T22:17:14.387", "ParentId": "4891335", "Score": "0", "OwnerUserId": "373025"}, "bq_ids": {"n4140": {"so_4891335_4891681_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5443}}, "n3337": {"so_4891335_4891681_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5238}}, "n4659": {"so_4891335_4891681_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6870}}}, "8627815": {"Id": "8627815", "PostTypeId": "2", "Body": "<p>That will work, with a little change, under C++98 as far as I can see. It compiled without any warnings for me with <code>g++-4.1 -Wall -Wextra -pedantic -ansi -std=c++98</code></p>\n<p>Just change</p>\n<pre><code>friend Owner;\n</code></pre>\n<p>to</p>\n<pre><code>struct Wrapper { typedef Owner type; };\nfriend class Wrapper :: type;\n</code></pre>\n<p>(I got that answer on Stackoverflow, this question has come up a few times: <a href=\"https://stackoverflow.com/questions/6510041/template-parameter-as-a-friend\">Template parameter as a friend</a> )</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-12-25T01:38:10.477", "Score": "0", "CreationDate": "2011-12-25T01:38:10.477", "ParentId": "4891335", "CommentCount": "1", "OwnerUserId": "146041", "LastEditDate": "2017-05-23T11:48:06.637"}, "4891650": {"Id": "4891650", "PostTypeId": "2", "Body": "<p>You are correct about C++98/03.  However C++0x (n3225 11.4/3) allows you to do this with this syntax:</p>\n<pre><code>friend Owner;\n</code></pre>\n<p>See if your compiler will let you do that.  Try turning on C++0x support.  Otherwise the workarounds are uglier:</p>\n<pre><code>struct Owner\n{\n    typedef Owner self;\n};\n</code></pre>\n<p>...</p>\n<p>Then depending on your compiler one of:</p>\n<pre><code>friend typename Owner::self;\n</code></pre>\n<p>or:</p>\n<pre><code>friend class Owner::self;\n</code></pre>\n", "LastEditorUserId": "301883", "LastActivityDate": "2011-02-03T21:37:18.213", "Score": "5", "CreationDate": "2011-02-03T20:57:10.910", "ParentId": "4891335", "CommentCount": "9", "OwnerUserId": "576911", "LastEditDate": "2011-02-03T21:37:18.213"}, "4891544": {"Id": "4891544", "PostTypeId": "2", "Body": "<p>What about simply defining a private nested type that trivially inherits from accessible_member? Something like</p>\n<pre><code>class Owner\n{\n    template &lt; typename T &gt;\n    class accessible_member : public ::accessible_member&lt; T &gt; {};\n};\n</code></pre>\n<p>Of course that still means the original <code>accessible_member</code> type is available to anyone so it's maybe not of much use come to think of it.</p>\n", "LastActivityDate": "2011-02-03T20:47:10.520", "CommentCount": "1", "CreationDate": "2011-02-03T20:47:10.520", "ParentId": "4891335", "Score": "0", "OwnerUserId": "74465"}});