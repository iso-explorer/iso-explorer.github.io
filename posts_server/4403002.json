post_cb({"4403030": {"PostTypeId": "2", "Body": "<p>Write a class with a constructor (<code>initialization</code> code) and a destructor (<code>finalization</code> code). Declare a singleton instance of this class; the constructor will be called at startup, and the destructor before the program shuts down.</p>\n", "LastActivityDate": "2010-12-09T20:55:55.680", "Id": "4403030", "CommentCount": "2", "CreationDate": "2010-12-09T20:55:55.680", "ParentId": "4403002", "Score": "1", "OwnerUserId": "32133"}, "4403026": {"PostTypeId": "2", "Body": "<p>Class have constructors and destructors that you can use to intialize and clean up.</p>\n<p>I think the closest you get to \"code units\" in C++ is classes.</p>\n", "LastActivityDate": "2010-12-09T20:55:34.317", "Id": "4403026", "CommentCount": "0", "CreationDate": "2010-12-09T20:55:34.317", "ParentId": "4403002", "Score": "2", "OwnerUserId": "61974"}, "4403052": {"PostTypeId": "2", "Body": "<p>Typically, it's viewed as a code smell in C++ to have global state that needs construction or destruction, and even if you did have this, you would just declare a class that does this in it's constructor and define a file-global instance of it.</p>\n", "LastActivityDate": "2010-12-09T20:59:00.930", "Id": "4403052", "CommentCount": "7", "CreationDate": "2010-12-09T20:59:00.930", "ParentId": "4403002", "Score": "1", "OwnerUserId": "298661"}, "4403048": {"PostTypeId": "2", "Body": "<p>The equivalent C++ feature is constructors and destructors for file-scope/global objects.  For instance:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\n\nstruct X {\n   X() { cout &lt;&lt; \"X::X()\\n\"; }\n   ~X() { cout &lt;&lt; \"X::~X()\\n\"; }\n};\n\nstatic X x;\n\nint main() { cout &lt;&lt; \"main()\\n\"; return 0; }\n</code></pre>\n<p>will output</p>\n<pre><code>X::X()\nmain()\nX::~X()\n</code></pre>\n<p>when run.</p>\n<p>It is generally considered unwise to use this feature, because you have no control whatsoever over the order in which these constructors and destructors are executed, which means things may get initialized before their dependencies, producing hard-to-debug crashes.</p>\n", "LastActivityDate": "2010-12-09T20:58:24.270", "Id": "4403048", "CommentCount": "3", "CreationDate": "2010-12-09T20:58:24.270", "ParentId": "4403002", "Score": "7", "OwnerUserId": "388520"}, "4403081": {"PostTypeId": "2", "Body": "<p>In C++ constructor/destructor pairs are generally used for this sort of thing. Be careful when using static objects, however. Two things you should read if you want to do this:</p>\n<ol>\n<li><p><a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14\" rel=\"nofollow\">What's the \"static initialization order fiasco\"?</a></p></li>\n<li><p><a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.15\" rel=\"nofollow\">How do I prevent the \"static initialization order fiasco\"?</a></p></li>\n</ol>\n", "LastActivityDate": "2010-12-09T21:02:21.167", "Id": "4403081", "CommentCount": "9", "CreationDate": "2010-12-09T21:02:21.167", "ParentId": "4403002", "Score": "3", "OwnerUserId": "90848"}, "4403002": {"ViewCount": "1294", "Body": "<p>Before switching to C++, we found the <code>initialization</code> language element in Delphi extremely useful. It allowed you to have code in each unit which would be called when the program was started, so you could initialize various elements of that unit.</p>\n<p>This does in our opinion make things easier and helps to keep the code clean.</p>\n<ul>\n<li><p>So why is there no <code>initialization</code> and <code>finalization</code> in C++?</p></li>\n<li><p>What are our options for replacements of this language feature in C++?</p></li>\n</ul>\n", "Title": "Why is there no \"initialization\" keyword in C++, as there is in Delphi?", "CreationDate": "2010-12-09T20:53:47.913", "LastActivityDate": "2015-10-23T06:47:55.867", "CommentCount": "2", "LastEditDate": "2015-10-23T06:47:55.867", "PostTypeId": "1", "LastEditorUserId": "2660176", "Id": "4403002", "Score": "3", "OwnerUserId": "537048", "Tags": "<c++><delphi><initialization>", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_4403002_4404720_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 7153}}, "n3337": {"so_4403002_4404720_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 6897}}}, "4403049": {"PostTypeId": "2", "Body": "<p>In C++ you call the constructor (equivalent to your destructor) the same name of you class and the destructor the same name of you class, prefixed with tilde (~):</p>\n<pre><code>Class Point {\n    public:\n    Point() {  }\n    ~Point() { }\n}\n</code></pre>\n", "LastActivityDate": "2010-12-09T20:58:26.033", "Id": "4403049", "CommentCount": "0", "CreationDate": "2010-12-09T20:58:26.033", "ParentId": "4403002", "Score": "0", "OwnerUserId": "536284"}, "4403120": {"PostTypeId": "2", "Body": "<p>The closest feature C++ has to what you are use to is static variables (specifically, static member variables).</p>\n<pre><code>// A.h\nclass A\n{\npublic:\n\nprivate:\n    static int someValue;\n};\n\n// A.cpp\nint A::someValue = 2;\n</code></pre>\n<p>The static variable is initialized at program startup.  There is no automatic \"finalization\" procedure for static members (you would have to write your own cleanup function and call it).</p>\n", "LastActivityDate": "2010-12-09T21:06:36.767", "Id": "4403120", "CommentCount": "0", "CreationDate": "2010-12-09T21:06:36.767", "ParentId": "4403002", "Score": "0", "OwnerUserId": "529761"}, "4404720": {"PostTypeId": "2", "Body": "<h2>Question 1: why isn't there a keyword?</h2>\n<p>No-one apart from Stroustrup or the committee members can really answer why C++ is how it is, but we can speculate, probably that it wasn't considered important enough for a keyword.  The C++ standard does talk about order of initialization, such as for objects but the order is not strictly defined and left to the implementation.  Here's one quote (3.6.2/3):</p>\n<blockquote>\n<p id=\"so_4403002_4404720_0\">It is implementation-defined whether\n  or not the dynamic initialization\n  (8.5, 9.4, 12.1, 12.6.1) of an object\n  of namespace scope is done before the\n  first statement of main. If the\n  initialization is deferred to some\n  point in time after the first\n  statement of main, it shall occur\n  before the first use of any function\n  or object defined in the same\n  translation unit as the object to be\n  initialized</p>\n</blockquote>\n<h2>Question 2: how to achieve the equivalent of the Delphi <code>initialization</code> and <code>finalization</code> keywords?</h2>\n<p>There are two options.  The first has been mentioned by other posters and I don't want to copy their answers: declare an object in a certain scope (<a href=\"https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c\">translation unit</a> or namespace) and its constructor and destructor will be called 'sometime'; do work there.</p>\n<p>Note that the order of this is <strong>implementation-defined</strong>, so you're already in uncertain territory.</p>\n<p>The second option is also compiler dependent.  You're using Delphi, so am I right in thinking you're using C++ Builder to compile your C++ code?  If so, C++ Builder and some other compilers support the <a href=\"http://docs.embarcadero.com/products/rad_studio/delphiAndcpp2009/HelpUpdate2/EN/html/devwin32/pndsnpragmaexitandpndsnpragmastartup_xml.html\" rel=\"nofollow noreferrer\"><strong><code>#pragma startup</code> and <code>#pragma exit</code></strong> pragmas</a>.  These pragmas call a method at a certain time when your program is starting up or shutting down.</p>\n<p>Personally I find this a neater solution, for two reasons:</p>\n<ul>\n<li><p>It specifies exactly when something\nwill occur and I can see it written\ndown in code</p></li>\n<li><p>It allows you to call a\nfunction, instead of using a\nconstructor or destructor.  This is\naesthetically cleaner and lets you write, say,\n<code>initialization()</code> and <code>finalization()</code> methods which\nperform your work.  <strong>This probably gets you as close to the Delphi syntax as you can get.</strong></p></li>\n</ul>\n<p>You can use these pragmas to call a procedure (which takes no parameters and returns void) and also optionally specify when it should occur, using a number between 64 and 255.  You need to do this only if the order of initialization or finalization matters.  A higher number is called first and priorities of 0-63 are reserved.  For example:</p>\n<pre><code>void initialization(void) { foo = 3; bar = 5; /* Do useful work here */ }\n#pragma startup initialization 200\n\nvoid finalization(void) { foo = 0; bar = 0; /* Do useful work here */ }\n#pragma exit finalization 200\n</code></pre>\n<p>The call chain is managed by the linker and you can run into issues if you use more compiler-specific constructs, such as <a href=\"http://docwiki.embarcadero.com/RADStudio/en/E2221_$WEAKPACKAGEUNIT_%27%25s%27_cannot_have_initialization_or_finalization_code_%28Delphi%29\" rel=\"nofollow noreferrer\">weak packaging</a>, but in general this is the technique I would recommend.</p>\n", "LastActivityDate": "2010-12-10T01:02:12.047", "LastEditorUserId": "-1", "Id": "4404720", "CommentCount": "0", "CreationDate": "2010-12-10T01:02:12.047", "ParentId": "4403002", "Score": "3", "OwnerUserId": "121689", "LastEditDate": "2017-05-23T11:52:46.973"}});