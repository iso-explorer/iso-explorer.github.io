post_cb({"43264232": {"ParentId": "43263631", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-04-06T19:31:44.627", "Score": "18", "LastEditorUserId": "2877241", "LastEditDate": "2017-04-06T19:36:56.887", "Id": "43264232", "OwnerUserId": "2877241", "Body": "<p>The expression statement</p>\n<pre><code>--++a-- ++ +b--;  // the culprit\n</code></pre>\n<p>can be represented the following way</p>\n<p>at first like</p>\n<pre><code>( --++a-- ++ )  + ( b-- );\n</code></pre>\n<p>then like</p>\n<pre><code>( -- ( ++ ( ( a-- ) ++ ) ) )  + ( b-- );\n</code></pre>\n<p>and at last like</p>\n<pre><code>a.operator --( 0 ).operator ++( 0 ).operator ++().operator --().operator  + ( b.operator --( 0 ) );\n</code></pre>\n<p>Here is a demonstrative program.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    char c_;\npublic:\n    A(char c) : c_(c) {}\n    A&amp; operator++() {\n        cout &lt;&lt; c_ &lt;&lt; \"A \";\n        return *this;\n    }\n    A&amp; operator++(int) {\n        cout &lt;&lt; c_ &lt;&lt; \"B \";\n        return *this;\n    }\n    A&amp; operator--() {\n        cout &lt;&lt; c_ &lt;&lt; \"C \";\n        return *this;\n    }\n    A&amp; operator--(int) {\n        cout &lt;&lt; c_ &lt;&lt; \"D \";\n        return *this;\n    }\n    void operator+(A&amp; b) {\n        cout &lt;&lt; c_ &lt;&lt; \"U \";\n    }\n};\n\nint main()\n{\n    A a('a'), b('b');\n    --++a-- ++ +b--;  // the culprit\n\n    std::cout &lt;&lt; std::endl;\n\n    a.operator --( 0 ).operator ++( 0 ).operator ++().operator --().operator  + ( b.operator --( 0 ) );\n\n    return 0;\n}\n</code></pre>\n<p>Its output is</p>\n<pre><code>bD aD aB aA aC aU \nbD aD aB aA aC aU \n</code></pre>\n<p>You can imagine the last expression written in the functional form like a postfix expression of the form</p>\n<pre><code>post\ufb01x-expression ( expression-list ) \n</code></pre>\n<p>where the postfix expression is</p>\n<pre><code>a.operator --( 0 ).operator ++( 0 ).operator ++().operator --().operator  +\n</code></pre>\n<p>and the expression-list is</p>\n<pre><code>b.operator --( 0 )\n</code></pre>\n<p>In the C++ Standard (5.2.2 Function call) there is said  that</p>\n<blockquote>\n<p id=\"so_43263631_43264232_0\">8 [Note: The evaluations of the post\ufb01x expression and of the arguments\n  are all unsequenced relative to one another. All side e\ufb00ects of\n  argument evaluations are sequenced before the function is entered (see\n  1.9). \u2014end note]</p>\n</blockquote>\n<p>So it is implementation-defined whether at first the argument will be evaluated or the postfix expression. According to the showed output the compiler at first evaluates the argument and only then the postfix expression.</p>\n", "LastActivityDate": "2017-04-06T19:36:56.887"}, "43264234": {"ParentId": "43263631", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-04-06T19:32:02.470", "Score": "14", "LastEditorUserId": "179910", "LastEditDate": "2017-04-06T20:20:16.630", "Id": "43264234", "OwnerUserId": "179910", "Body": "<p>I would say they were wrong to include such a question.</p>\n<p>Except as noted, the following excerpts are all from \u00a7[intro.execution] of N4618 (and I don't think any of this stuff has changed in more recent drafts).</p>\n<p>Paragraph 16 has the basic definition of <code>sequenced before</code>, <code>indeterminately sequenced</code>, etc.</p>\n<p>Paragraph 18 says:</p>\n<blockquote>\n<p id=\"so_43263631_43264234_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>In this case, you're (indirectly) calling some functions. The rules there are fairly simple as well:</p>\n<blockquote>\n<p id=\"so_43263631_43264234_1\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function. For each function invocation F, for every evaluation A that occurs within F and every evaluation B that does not occur within F but is evaluated on the same thread and as part of the same signal handler (if any), either A is\n  sequenced before B or B is sequenced before A.</p>\n</blockquote>\n<p>Putting that into bullet points to more directly indicate order:</p>\n<ol>\n<li>first evaluate the function arguments, and whatever designates the function being called.</li>\n<li>Evaluate the body of the function itself.</li>\n<li>Evaluate another (sub-)expression.</li>\n</ol>\n<p>No interleaving is allowed unless something starts up a thread to allow something else to execute in parallel.</p>\n<p>So, does any of this change before we're invoking the functions via operator overloads rather than directly? Paragraph 19 says \"No\":</p>\n<blockquote>\n<p id=\"so_43263631_43264234_2\">The sequencing constraints on the execution of the called function (as described above) are features of the function calls as evaluated, whatever the syntax of the expression that calls the function might be.</p>\n</blockquote>\n<p>\u00a7[expr]/2 also says:</p>\n<blockquote>\n<p id=\"so_43263631_43264234_3\">Uses of overloaded operators are transformed into function calls as described\n  in 13.5. Overloaded operators obey the rules for syntax and evaluation order specified in Clause 5, but the requirements of operand type and value category are replaced by the rules for function call.</p>\n</blockquote>\n<h3>Individual operators</h3>\n<p>The only operator you've used that has somewhat unusual requirements with respect to sequencing are the post-increment and post-decrement. These say (\u00a7[expr.post.incr]/1:</p>\n<blockquote>\n<p id=\"so_43263631_43264234_4\">The value computation of the ++ expression is sequenced before the modification of the operand object. With respect to an indeterminately-sequenced function call, the operation of postfix ++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue conversion and the side effect associated with any single postfix ++ operator. \u2014end note ]</p>\n</blockquote>\n<p>In the end, however, this is pretty much just what you'd probably expect: if you pass <code>x++</code> as a parameter to a function, the function receives the previous value of <code>x</code>, but if  <code>x</code> is also in scope inside the function, <code>x</code> will have the incremented value by the time the body of the function starts to execute.</p>\n<p>The <code>+</code> operator, however, does not specify ordering of the evaluation of its operands.</p>\n<h3>Summary</h3>\n<p>Using overloaded operators does not enforce any sequencing on the evaluation of sub-expressions within an expression, beyond the fact that evaluating an individual operator is a function call, and has the ordering requirements of any other function call.</p>\n<p>More specifically, in this case, <code>b--</code> is the operand to a function call, and <code>--++a-- ++</code> is the expression that designates the function being called (or at least the object on which the function will be called--the <code>--</code> designates the function within that object). As noted, ordering between these two is not specified (nor does <code>operator +</code> specify an order of evaluating its left vs. right operand). </p>\n", "LastActivityDate": "2017-04-06T20:20:16.630"}, "43264155": {"ParentId": "43263631", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-04-06T19:27:42.420", "Score": "4", "LastEditorUserId": "187690", "LastEditDate": "2017-04-06T20:04:18.410", "Id": "43264155", "OwnerUserId": "187690", "Body": "<p>Operator precedence and associativity rules are only used to convert your expression from the original \"operators in expression\" notation to the equivalent \"function call\" format. After the conversion you end up with a bunch of nested function calls, which are processed in the usual way. In particular, order of parameter evaluation is unspecified, which means that there's no way to say which operand of the \"binary +\" call will get evaluated first. </p>\n<p>Also, note that in your case binary <code>+</code> is implemented as a member function, which creates certain superficial asymmetry between its arguments: one argument is \"regular\" argument, another is <code>this</code>. Maybe some compilers \"prefer\" to evaluate \"regular\" arguments first, which is what leads to <code>b--</code> being evaluated first in your tests (you might end up with different ordering from the same compiler if you implement your binary <code>+</code> as a freestanding function). Or maybe it doesn't matter at all.</p>\n<p>Clang, for example, begins with evaluating the first operand, leaving <code>b--</code> for later.</p>\n", "LastActivityDate": "2017-04-06T20:04:18.410"}, "43263848": {"ParentId": "43263631", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-04-06T19:10:41.147", "Score": "7", "LastEditorUserId": "27302", "LastEditDate": "2017-04-06T19:18:46.283", "Id": "43263848", "OwnerUserId": "27302", "Body": "<p>There is not something in the C++ standard which says things need to be evaluated in this way. C++ has the concept of <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\" rel=\"noreferrer\">sequenced-before</a>, where some operations are guaranteed to happen before other operations are. This is a partially-ordered set; that is, sosome operations are sequenced before others, two operations can\u2019t be sequenced before eath other, and if a is sequenced before b, and b is sequenced before c, then a is sequenced before c. However, there are many types of operation which have no sequenced-before guarantees. Before C++11, there was instead a concept of a sequence point, which isn\u2019t quite the same but similar.</p>\n<p>Very few operators (only <code>,</code>, <code>&amp;&amp;</code>, <code>?:</code>, and <code>||</code>, I believe) guarantee a sequence point between their arguments (and even then, until C++17, this guarantee doesn\u2019t exist when the operators are overloaded). In particular, the addition does not guarantee any such thing. The compiler is free to evaluate the left-hand side first, to evaluate the right-hand side first, or (I think) even to evaluate them simultaneously.</p>\n<p>Sometimes changing optimization options can change the results, or changing compilers. Apparently you aren\u2019t seeing that; there are no guarantees here.</p>\n", "LastActivityDate": "2017-04-06T19:18:46.283"}, "43263631": {"CommentCount": "17", "AcceptedAnswerId": "43264232", "PostTypeId": "1", "LastEditorUserId": "1523774", "CreationDate": "2017-04-06T18:56:42.337", "LastActivityDate": "2017-04-07T10:49:27.027", "LastEditDate": "2017-04-06T19:21:31.967", "ViewCount": "2580", "FavoriteCount": "2", "Title": "Why is '--++a-\u200b- ++ +b--' evaluated in this order?", "Id": "43263631", "Score": "17", "Body": "<p>Why does the following print <code>bD aD aB aA aC aU</code> instead of <code>aD aB aA aC bD aU</code>? In other words, why is <code>b--</code> evaluated before <code>--++a--++</code>?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    char c_;\npublic:\n    A(char c) : c_(c) {}\n    A&amp; operator++() {\n        cout &lt;&lt; c_ &lt;&lt; \"A \";\n        return *this;\n    }\n    A&amp; operator++(int) {\n        cout &lt;&lt; c_ &lt;&lt; \"B \";\n        return *this;\n    }\n    A&amp; operator--() {\n        cout &lt;&lt; c_ &lt;&lt; \"C \";\n        return *this;\n    }\n    A&amp; operator--(int) {\n        cout &lt;&lt; c_ &lt;&lt; \"D \";\n        return *this;\n    }\n    void operator+(A&amp; b) {\n        cout &lt;&lt; c_ &lt;&lt; \"U \";\n    }\n};\n\nint main()\n{\n    A a('a'), b('b');\n    --++a-- ++ +b--;  // the culprit\n}\n</code></pre>\n<p>From what I gather, here's how the expression is parsed by the compiler:</p>\n<ul>\n<li>Preprocessor tokenization: <code>--</code> <code>++</code> <code>a</code> <code>--</code> <code>++</code> <code>+</code> <code>b</code> <code>--</code>;</li>\n<li>Operator precedence<sup>1</sup>: <code>(--(++((a--)++))) + (b--)</code>;</li>\n<li><code>+</code> is left-to-right associative, but nonetheless the compiler may choose to evaluate the expression on the right (<code>b--</code>) first.</li>\n</ul>\n<p>I'm assuming the compiler chooses to do it this way because it leads to better optimized code (less instructions). However, it's worth noting that I get the same result when compiling with <code>/Od</code> (MSVC) and <code>-O0</code> (GCC). This brings me to my question:</p>\n<p>Since I was asked this on a test which should <em>in principle</em> be implementation/compiler-agnostic, <strong>is there something in the C++ standard that prescribes the above behavior, or is it truly unspecified?</strong> Can someone quote an excerpt from the standard which confirms either? Was it wrong to have such a question on the test?</p>\n<p><sub><sup>1</sup> <em>I realize the compiler doesn't really know about operator precedence or associativity, rather it cares only about the language grammar, but this should get the point across either way.</em></sub></p>\n", "Tags": "<c++><operator-overloading><compiler-optimization><evaluation><order-of-evaluation>", "OwnerUserId": "1523774", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_43263631_43264234_2": {"section_id": 5811, "quality": 0.9444444444444444, "length": 17}, "so_43263631_43264234_0": {"section_id": 5811, "quality": 1.0, "length": 11}, "so_43263631_43264234_4": {"section_id": 6009, "quality": 0.8529411764705882, "length": 29}, "so_43263631_43264234_3": {"section_id": 5935, "quality": 0.8928571428571429, "length": 25}, "so_43263631_43264232_0": {"section_id": 5995, "quality": 0.7391304347826086, "length": 17}, "so_43263631_43264234_1": {"section_id": 5811, "quality": 0.5555555555555556, "length": 30}}, "n3337": {"so_43263631_43264234_2": {"section_id": 5584, "quality": 0.9444444444444444, "length": 17}, "so_43263631_43264234_3": {"section_id": 5707, "quality": 0.8928571428571429, "length": 25}, "so_43263631_43264234_4": {"section_id": 5777, "quality": 0.8529411764705882, "length": 29}, "so_43263631_43264234_0": {"section_id": 5584, "quality": 1.0, "length": 11}, "so_43263631_43264232_0": {"section_id": 5763, "quality": 0.6956521739130435, "length": 16}, "so_43263631_43264234_1": {"section_id": 5584, "quality": 0.5555555555555556, "length": 30}}, "n4659": {"so_43263631_43264234_4": {"section_id": 7508, "quality": 0.8529411764705882, "length": 29}, "so_43263631_43264234_3": {"section_id": 7419, "quality": 0.9642857142857143, "length": 27}, "so_43263631_43264234_2": {"section_id": 7273, "quality": 0.9444444444444444, "length": 17}, "so_43263631_43264234_0": {"section_id": 7272, "quality": 1.0, "length": 11}, "so_43263631_43264234_1": {"section_id": 7273, "quality": 0.9814814814814815, "length": 53}}}, "43276238": {"ParentId": "43263631", "CommentCount": "1", "CreationDate": "2017-04-07T10:49:27.027", "OwnerUserId": "7214467", "PostTypeId": "2", "Id": "43276238", "Score": "-1", "Body": "<p>Take in account priority of operators in c++:</p>\n<ol>\n<li>a++   a--   Suffix/postfix increment and decrement. Left-to-right    </li>\n<li>++a   --a   Prefix increment and decrement. Right-to-left</li>\n<li>a+b   a-b   Addition and subtraction. Left-to-right</li>\n</ol>\n<p>Keeping the list in your mind you can easily read the expression even without parentheses:</p>\n<pre><code>--++a--+++b--;//will follow with\n--++a+++b--;//and so on\n--++a+b--;\n--++a+b;\n--a+b;\na+b;\n</code></pre>\n<p>And dont forget about essential difference prefix and postfix operators in terms of order evaluation of variable and expression )) </p>\n", "LastActivityDate": "2017-04-07T10:49:27.027"}});