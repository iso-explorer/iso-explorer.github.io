post_cb({"37725173": {"ParentId": "37724668", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It should be fine, but you are not allowed to use <code>y</code> inside of <code>X(Y&amp; y)</code> as it was not yet initialized.</p>\n<p>The relevant part that says it is not UB is:</p>\n<p>3.7.5/6 n4140 (emphasis is mine)</p>\n<blockquote>\n<p id=\"so_37724668_37725173_0\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, <strong><em>any glvalue that refers to the\n  original object may be used but only in limited ways</em></strong>.</p>\n</blockquote>\n<p><code>y</code> is lvalue (which is also a glvalue), so above is relevant here. Accessing variables using such reference is UB.</p>\n<p>Standard also says that reference to be valid it must (8.3.2/5):</p>\n<blockquote>\n<p id=\"so_37724668_37725173_1\">... A reference shall be initialized to refer to a valid object or function.</p>\n</blockquote>\n<p>But I have not found in standard what is <code>valid object</code>. Especially whether it means that its constructor has already been called. Using pointer instead of reference seems to not have this problem.</p>\n", "OwnerUserId": "471160", "LastEditorUserId": "471160", "LastEditDate": "2016-06-09T13:11:54.667", "Id": "37725173", "Score": "2", "CreationDate": "2016-06-09T11:50:11.860", "LastActivityDate": "2016-06-09T13:11:54.667"}, "37724668": {"CommentCount": "0", "AcceptedAnswerId": "37725173", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-06-09T11:26:58.430", "LastActivityDate": "2016-06-11T03:27:23.127", "LastEditDate": "2017-05-23T10:28:59.593", "ViewCount": "115", "FavoriteCount": "1", "Title": "Is taking uninitialized references of class members during construction legal?", "Id": "37724668", "Score": "4", "Body": "<p>\nComing from this <a href=\"https://stackoverflow.com/q/37644977/1312382\">question</a>, I am going a step further:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>C* c = static_cast&lt;C*&gt;(malloc(sizeof(C)));\n</code></pre>\n<p>As stated in the referenced question, accessing *c (its members) is undefined behaviour before a constructor is called. But, the pointer itself is valid, of course.</p>\n<p>Now within the constructor, the members are available already and I should be able to take the address off.</p>\n<p>Putting this together, I conclude that the following is legal:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Y;\nclass X\n{\n    Y&amp; y;\npublic:\n    X(Y&amp; y) : y(y) { } // non-trivial constructor!\n};\nclass Y\n{\n    X&amp; x;\npublic:\n    Y(X&amp; x) : x(x) { }\n};\nclass Z\n{\n    X x;\n    Y y;\npublic:\n    Z() : x(y), y(x) { } \n};\n</code></pre>\n<p>as long as the constructor of X does not use the uninitialized reference to Y other than storing it somewhere.</p>\n<p>Is this correct or have I overseen some important point (and thus producing UB again)? If I missed something, would it make a difference if I used pointers instead of references?</p>\n", "Tags": "<c++>", "OwnerUserId": "1312382", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37724668_37725173_1": {"section_id": 3222, "quality": 1.0, "length": 6}, "so_37724668_37725173_0": {"section_id": 7194, "quality": 1.0, "length": 31}}, "n3337": {"so_37724668_37725173_1": {"section_id": 3096, "quality": 1.0, "length": 6}, "so_37724668_37725173_0": {"section_id": 6938, "quality": 1.0, "length": 31}}, "n4659": {"so_37724668_37725173_1": {"section_id": 3979, "quality": 1.0, "length": 6}, "so_37724668_37725173_0": {"section_id": 8703, "quality": 1.0, "length": 31}}}, "37725397": {"ParentId": "37724668", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is legitimate. To justify this, see the following from the standard, [basic.life]:</p>\n<blockquote>\n<ol start=\"5\">\n<li>Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any pointer that refers to the\n  storage location where the object will be or was located may be used\n  but only in limited ways. For an object under construction or\n  destruction, see 12.7. Otherwise, such a pointer refers to allocated\n  storage (3.7.4.2), and using the pointer as if the pointer were of\n  type void*, is well-defined. ...</li>\n</ol>\n<p id=\"so_37724668_37725397_0\">...</p>\n<ol start=\"6\">\n<li>Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, <strong>any glvalue that refers to the\n  original object may be used but only in limited ways.</strong> For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined.</li>\n</ol>\n<p id=\"so_37724668_37725397_1\">...</p>\n</blockquote>\n<p>Merely taking a reference falls under the 'limited use' (for objects whose lifetime has not yet begun) criteria set out above.</p>\n", "OwnerUserId": "6255513", "LastEditorUserId": "6255513", "LastEditDate": "2016-06-09T12:21:16.050", "Id": "37725397", "Score": "2", "CreationDate": "2016-06-09T12:00:07.733", "LastActivityDate": "2016-06-09T12:21:16.050"}});