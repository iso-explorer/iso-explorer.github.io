post_cb({"15530585": {"ParentId": "15530321", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-03-20T17:26:51.943", "Score": "4", "LastEditorUserId": "367273", "LastEditDate": "2013-03-20T17:49:20.963", "Id": "15530585", "OwnerUserId": "367273", "Body": "<blockquote>\n<p id=\"so_15530321_15530585_0\">Is <code>std::vector(InputIterator first, InputIterator last)</code> linear time complexity?</p>\n</blockquote>\n<p><strong>In a nutshell, yes.</strong></p>\n<p>The standard guarantees the following for <code>vector(InputIterator, InputIterator)</code> in \u00a723.3.6.2:</p>\n<blockquote>\n<p id=\"so_15530321_15530585_1\">Complexity: Makes only N calls to the copy constructor of T (where N is the distance between first\n  and last) <strong>and no reallocations if iterators \ufb01rst and last are of forward, bidirectional, or random access\n  categories</strong>. It makes order N calls to the copy constructor of T and order log(N) reallocations if they\n  are just input iterators.</p>\n</blockquote>\n<p>Basically, for forward, bidirectional, or random access iterators you shouldn't be expecting to see any performance gain from using <code>reserve()</code> as in your second example; the constructor will automatically do this for you.</p>\n<p>For plain input iterators, <code>reserve()</code> would speed things up, but not more than by a constant factor. The <code>log(n)</code> reallocations would still be done in <code>O(n)</code> total time, so the total time of constructing the vector will also be <code>O(n)</code>.</p>\n", "LastActivityDate": "2013-03-20T17:49:20.963"}, "bq_ids": {"n4140": {"so_15530321_15530585_1": {"section_id": 966, "quality": 0.9032258064516129, "length": 28}}, "n3337": {"so_15530321_15530585_1": {"section_id": 954, "quality": 0.9032258064516129, "length": 28}}, "n4659": {"so_15530321_15530585_1": {"section_id": 1028, "quality": 0.9032258064516129, "length": 28}}}, "15530321": {"CommentCount": "0", "ViewCount": "430", "PostTypeId": "1", "LastEditorUserId": "115751", "CreationDate": "2013-03-20T17:14:45.067", "LastActivityDate": "2013-03-20T17:49:20.963", "Title": "Is std::vector(InputIterator first, InputIterator last) linear time complexity?", "AcceptedAnswerId": "15530585", "LastEditDate": "2013-03-20T17:24:49.747", "Id": "15530321", "Score": "3", "Body": "<p>I'd like to use the C++ <code>std::vector</code> input iterator constructor to build an array of consecutive integers like this:</p>\n<pre><code>std::vector&lt;unsigned&gt; indexes(boost::counting_iterator&lt;unsigned&gt;(0U),\n                              boost::counting_iterator&lt;unsigned&gt;(10000U));\n</code></pre>\n<p>However, I'm wondering if it will have time complexity proportional to the distance between the iterators or whether it could have an additional logarithmic component due to repeated resizing to grow the vector?  In other words, does the constructor look at the distance between the two iterators?  Since the constructor arguments are not random access iterators, I'm not sure the distance can be computed?</p>\n<p>If it would resize repeatedly, is there a better solution than this to avoid that:</p>\n<pre><code>std::vector&lt;unsigned&gt; indexes;\n\nindexes.reserve(10000U);\n\nfor (unsigned idx = 0; idx &lt; 10000U; ++idx) {\n  indexes.push_back(idx);\n}\n</code></pre>\n", "Tags": "<c++><boost><constructor><time-complexity><stdvector>", "OwnerUserId": "115751", "AnswerCount": "1"}});