post_cb({"5270552": {"Id": "5270552", "PostTypeId": "2", "Body": "<p>Yes.. It is defined in the standard.</p>\n<p>From standard docs <em>13.5.7 Increment and decrement</em>,</p>\n<blockquote>\n<p id=\"so_5270514_5270552_0\">The user-defined function called operator++ implements the prefix and postfix ++ operator. If this function is a member\n  function with no parameters, or a non-member function with one parameter of class or enumeration type, it defines the\n  prefix increment operator ++ for objects of that type. <strong>If the function is a member function with one parameter (which\n  shall be of type int) or a non-member function with two parameters (the second of which shall be of type int), it\n  defines the postfix increment operator ++ for objects of that type.</strong> When the postfix increment is called as a result of\n  using the ++ operator, the int argument will have value zero.</p>\n</blockquote>\n", "LastActivityDate": "2011-03-11T08:23:52.753", "CommentCount": "0", "CreationDate": "2011-03-11T08:23:52.753", "ParentId": "5270514", "Score": "3", "OwnerUserId": "249490"}, "5270514": {"ViewCount": "864", "Body": "<p>Is it some kind of enforced rule that the <code>overload ++</code> function must take an <code>int</code> as argument to distinguish itself from prefix operators? </p>\n<p>Also, In case of prefix <code>overload ++</code> function, how does the right hand operand is implicit argument?</p>\n<p>E.g <code>++ClassObj //ClassObj is rhs, but usualy lhs is made implicit</code></p>\n", "AcceptedAnswerId": "5270596", "Title": "Overloading postfix ++ operator", "CreationDate": "2011-03-11T08:18:57.167", "Id": "5270514", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-03-11T08:28:43.577", "Score": "3", "OwnerUserId": "655003", "Tags": "<c++><operator-overloading>", "AnswerCount": "3"}, "5270596": {"Id": "5270596", "PostTypeId": "2", "Body": "<p>On the second issue. Both prefix and postfix <code>++</code> are <em>unary</em> operators, they do not have a <em>left-hand-side</em> and <em>right-hand-side</em> operand, but a single operand on which they are applied. That is, in <code>x++</code> and <code>++x</code>, <code>x</code> is <em>the</em> operand, not the right hand/left hand, but <em>the</em> operand.</p>\n<p>Then on why the <code>int</code> that is required in the signature of the postfix version, it takes an <em>artificial</em> integer argument (which is not used) just to differentiate the signatures and allow the compiler to know that you are declaring/defining a <em>postfix</em> <code>++</code> and not the <em>prefix</em> version of it. Consider it as a tag, more than anything else, since the language requires different signatures.</p>\n", "LastActivityDate": "2011-03-11T08:28:43.577", "CommentCount": "0", "CreationDate": "2011-03-11T08:28:43.577", "ParentId": "5270514", "Score": "6", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_5270514_5270552_0": {"length": 55, "quality": 0.9322033898305084, "section_id": 665}}, "n3337": {"so_5270514_5270552_0": {"length": 58, "quality": 0.9830508474576272, "section_id": 655}}, "n4659": {"so_5270514_5270552_0": {"length": 55, "quality": 0.9322033898305084, "section_id": 693}}}, "5270579": {"Id": "5270579", "PostTypeId": "2", "Body": "<p>C++ needs to make a difference in the signature of the function. Unfortunately, both <code>x++</code> and <code>++x</code> have only one real argument, namely <code>x</code>. So the C++ designers chose a kind of <code>hack</code> in defining one to require a dummy unused int parameter. That results in different method signatures, and thus a way for the C++ compiler to distinguish the prefix from the postfix operator.</p>\n", "LastActivityDate": "2011-03-11T08:26:53.720", "CommentCount": "0", "CreationDate": "2011-03-11T08:26:53.720", "ParentId": "5270514", "Score": "3", "OwnerUserId": "182675"}});