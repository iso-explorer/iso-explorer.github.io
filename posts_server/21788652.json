post_cb({"21789691": {"ParentId": "21788652", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-02-14T21:18:49.133", "Score": "1", "LastEditorUserId": "1566221", "LastEditDate": "2014-02-14T22:02:26.690", "Id": "21789691", "OwnerUserId": "1566221", "Body": "<p>I know zip-all about VS C++, but you shouldn't actually need the <code>L</code> prefix for the concatenand of a wide string literal.</p>\n<pre><code> L\"%\" PRId32 \"\\n\"\n</code></pre>\n<p>should work (and it does with gcc).</p>\n<p>From the C11 draft, \u00a76.4.5/5: (as far as I can tell, this was roughly the same in C99, except that C99 didn't have utf-8 literals.)</p>\n<blockquote>\n<p id=\"so_21788652_21789691_0\">In translation phase 6, the multibyte character sequences specified by any sequence of\n  adjacent character and identically-prefixed string literal tokens are concatenated into a\n  single multibyte character sequence. If any of the tokens has an encoding prefix, the\n  resulting multibyte character sequence is treated as having the same prefix; otherwise, it\n  is treated as a character string literal. Whether differently-prefixed wide string literal\n  tokens can be concatenated and, if so, the treatment of the resulting multibyte character\n  sequence are implementation-defined.</p>\n</blockquote>\n<p>Also see \u00a77.8.1/7, which provides the example:</p>\n<pre><code>uintmax_t i = UINTMAX_MAX; // this type always exists\nwprintf(L\"The largest integer value is %020\"\n    PRIxMAX \"\\n\", i);\n</code></pre>\n<p>A similar clause appears in the C++11 standard, \u00a72.14.5/13. (However, in C++03, combining narrow and wide string literals was not allowed.)</p>\n<blockquote>\n<p id=\"so_21788652_21789691_1\">In translation phase 6, adjacent string literals are concatenated. If both string literals have the same encoding-prefix, the resulting concatenated string literal has that encoding-prefix. If one string literal has no encoding-prefix, it is treated as a string literal of the same encoding-prefix as the other operand\u2026</p>\n</blockquote>\n<p>Apparently, Visual Studio does not allow this form of literal concatenation.</p>\n", "LastActivityDate": "2014-02-14T22:02:26.690"}, "21789920": {"ParentId": "21788652", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-02-14T21:35:30.307", "Score": "5", "LastEditorUserId": "151292", "LastEditDate": "2014-02-17T17:30:23.603", "Id": "21789920", "OwnerUserId": "151292", "Body": "<p>The problem is twofold.  First, as noted in rici's answer, C99 and C++11 both added support for concatenating narrow string literals and wide string literals together, so you should not need to widen the narrow literal by prepending the L.  Visual C++ does not yet support this feature for either C or C++.</p>\n<p>Because the compiler does not yet support this feature, we should in the libraries make it possible for you to explicitly widen these string literals using a technique like the one in your answer.  Unfortunately, we've defined these macros in a way such that they may expand to multiple string literals.  E.g., <code>PRId32</code> expands to <code>\"l\" \"d\"</code>.</p>\n<p>This is valid, but it does prevent you from widening, because there is no way to prepend an <code>L</code> to the second string literal (to make <code>\"d\"</code> into <code>L\"d\"</code>).  I'm afraid I don't see a way to make this work without (re)defining the macros yourself.</p>\n<p>I've opened a bug internally so that if the compiler does not add support for concatenation of mixed-width literals during preprocessing in the next release, we can revisit these definitions to possibly make it possible to widen them explicitly.</p>\n", "LastActivityDate": "2014-02-17T17:30:23.603"}, "bq_ids": {"n4140": {"so_21788652_21789691_1": {"section_id": 5362, "quality": 1.0, "length": 28}}, "n3337": {"so_21788652_21789691_1": {"section_id": 5158, "quality": 1.0, "length": 28}}, "n4659": {"so_21788652_21789691_1": {"section_id": 6786, "quality": 0.7142857142857143, "length": 20}}}, "21788652": {"CommentCount": "1", "AcceptedAnswerId": "21789920", "CreationDate": "2014-02-14T20:09:13.557", "LastActivityDate": "2014-02-17T17:30:23.603", "PostTypeId": "1", "ViewCount": "1945", "FavoriteCount": "2", "Title": "How do I concatenate wide string literals with PRId32, PRIu64, etc.?", "Id": "21788652", "Score": "7", "Body": "<p>Suppose I need to print a formatted string with an <code>int32_t</code> using the printf format specifier from <code>&lt;inttypes.h&gt;</code>.</p>\n<pre><code>int32_t i = 0;\nprintf(\"%\" PRId32 \"\\n\", i);\n</code></pre>\n<p>If I try to do the same with wide characters in Visual C++ 2013, it fails:</p>\n<pre><code>#define W_(val) L ## val\n#define W(val) W_(val)\nwprintf(L\"%\" W(PRId32) L\"\\n\", i);\n</code></pre>\n<blockquote>\n<p id=\"so_21788652_21788652_0\">error C2308: concatenating mismatched strings</p>\n</blockquote>\n<p>How do I concatenate wide string literals with format conversion specifier macros?</p>\n", "Tags": "<c><string><visual-c++><unicode><macros>", "OwnerUserId": "501771", "AnswerCount": "2"}});