post_cb({"bq_ids": {"n4140": {"so_48009242_48009465_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 234}}, "n3337": {"so_48009242_48009465_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 227}}, "n4659": {"so_48009242_48009465_1": {"length": 21, "quality": 1.0, "section_id": 244}}}, "48009465": {"Id": "48009465", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48009242_48009465_0\">The surprise is that <code>FOO</code>'s template parameter <code>T</code> is not accessible. But even more surprising, it is perfectly possible to access <code>n</code>.</p>\n</blockquote>\n<p>I suppose that depends on your definition of perfect. It's not actually possible to access <code>n</code>, but the point at which you'd discover this is a little different. Indeed, if you tried to <em>use</em> <code>size</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T, int n&gt;\nstruct foo { };\n\ntemplate &lt;typename FOO&gt;\nstruct bar {\n    static constexpr int size = FOO::n;\n};\n\nint main() {\n    bar&lt;foo&lt;int, 3&gt;&gt; zoo;\n    std::cout &lt;&lt; zoo.size &lt;&lt; '\\n'; // error: n is not a member of foo&lt;int, 3&gt;\n}\n</code></pre>\n<p>This is because of <a href=\"http://eel.is/c++draft/temp.inst#3\" rel=\"noreferrer\">[temp.inst]/3</a>:</p>\n<blockquote>\n<p id=\"so_48009242_48009465_1\">[...] in particular, the initialization (and any associated side effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n<p>In your example, nothing required the static data member to exist, so its initialization didn't happen yet - and it's that initialization that would have been ill-formed. </p>\n<p>If you had directly tried to access the name \"n\", you'd see the same thing:</p>\n<pre><code>template &lt;typename T, int n&gt;\nstruct foo { };\n\ntemplate &lt;typename FOO&gt;\nstruct bar {\n    int array[FOO::n]; // error\n};\n\nint main() {\n    bar&lt;foo&lt;int, 3&gt;&gt; zoo;\n}\n</code></pre>\n", "LastActivityDate": "2017-12-28T14:42:56.633", "Score": "8", "CreationDate": "2017-12-28T14:42:56.633", "ParentId": "48009242", "CommentCount": "4", "OwnerUserId": "2069064"}, "48009242": {"ViewCount": "64", "Body": "<p>In a template class that contains another template class (for what it matters, an exchangeable storage representation of... whatever), I thought that instead of passing in serveral template parameters <strong>down</strong>, it would be more elegant to pass in one instantiation of the inner template and reach parameters <strong>up</strong> again instead.</p>\n<p>Why not! Sure this works, and it's way more elegant!</p>\n<p>Now, maybe the above is a bit hard to understand, so let's see some (almost compilable) code of what I've been trying to do:</p>\n<pre><code>template&lt;typename T, int n&gt; struct foo\n{\n    // using alias_of_T = T;\n};\n\ntemplate&lt;typename FOO&gt; struct bar\n{\n    FOO _foo;\n\n    // this works just fine!?\n    static constexpr int size = FOO::n;\n\n    // this indeed works, but... bleh\n    // using type_t = typename FOO::alias_of_T;\n\n    // this does not work?\n    using type_t = typename FOO::T;\n\n    type_t whatever() { return ...; }\n};\n\n//...\n\nint main()\n{\n    bar&lt;foo&lt;int, 3&gt;&gt; zoo;\n    ...\n</code></pre>\n<p>The surprise is that <code>FOO</code>'s template parameter <code>T</code> is not accessible. But even more surprising, it is perfectly possible to access <code>n</code>.</p>\n<p>What is the rationale behind that?</p>\n<p>Is there a more elegant way than using <code>FOO::alias_of_T</code>?</p>\n<h2>Re: Why does it work for the non-type parameter?</h2>\n<p>It turns out I'm too stupid to read my own code! There was (kudos to @Barry) indeed a \"different size\", i.e. a <code>constexpr size = n</code> alias in the original (not trimmed down, not-foo-bar) code, which I seem to have totally overlooked. That explains why it \"works fine\" for the non-type parameter, no surprise there. Well, that's embarrassing, you really gotta be able to read the code you typed yourself properly...</p>\n", "AcceptedAnswerId": "48009465", "Title": "Why are template type parameters not visible/existent as opposed to non-type parameters?", "CreationDate": "2017-12-28T14:26:35.500", "LastActivityDate": "2017-12-28T17:49:15.133", "CommentCount": "2", "LastEditDate": "2017-12-28T17:49:15.133", "PostTypeId": "1", "LastEditorUserId": "572743", "Id": "48009242", "Score": "2", "OwnerUserId": "572743", "Tags": "<c++><templates><c++17>", "AnswerCount": "1"}});