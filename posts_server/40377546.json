post_cb({"40377626": {"ParentId": "40377546", "PostTypeId": "2", "CommentCount": "19", "Body": "<blockquote>\n<p id=\"so_40377546_40377626_0\">N4140 \u00a7 3.6.2 [basic.start.init]/ 4</p>\n<p id=\"so_40377546_40377626_1\">It is implementation-defined whether the dynamic initialization of a\n  non-local variable with static storage duration is done before the\n  first statement of <code>main</code>.</p>\n</blockquote>\n<p>\u200b</p>\n<blockquote>\n<p id=\"so_40377546_40377626_2\">N4140 \u00a7 N4140 15.3 [except.handle]/ 13</p>\n<p id=\"so_40377546_40377626_3\">Exceptions thrown in destructors of objects with static storage\n  duration or in constructors of namespace-scope objects with static\n  storage duration are not caught by a <em>function-try-block</em> on <code>main()</code>.</p>\n</blockquote>\n<p>You simply cannot catch an exception generated by the string's constructor - say, <code>std::bad_alloc</code>.</p>\n<p>(opinion) That being said, for such small strings I find this kind of consideration to be paranoid.</p>\n", "OwnerUserId": "2456565", "LastEditorUserId": "2456565", "LastEditDate": "2016-11-02T17:52:41.757", "Id": "40377626", "Score": "31", "CreationDate": "2016-11-02T10:28:06.537", "LastActivityDate": "2016-11-02T17:52:41.757"}, "40381821": {"ParentId": "40377546", "CommentCount": "3", "Body": "<p>The only \"issue\" -- if you can call it that -- which I see with your code is that you are being wasteful by needlessly copying data that is already constant into a dynamically allocated buffer (which is <em>formally</em> constant, but not in reality). This uses twice as much physical memory as necessary and does a needless copy.</p>\n<p>Does it matter? Almost certainly, no. Even on a \"rather limited memory\" system, this will nowadays hardly be noticeable, neither from an execution time point of view, nor by its memory consumption.</p>\n<p>As for exceptions, it is of course <em>technically</em> true that the allocation that <code>std::string</code> has to make <em>could</em> fail, and therefore the constructor <em>could</em> throw, and you wouldn't be able to catch it. But please be realistic.<br>\nThis is almost guaranteed not to happen, but even if it does... if something as trivial as allocating memory for a couple of string fails while your program starts up, you have a really, really serious issue on a completely different scale!<br>\nBesides, as pointed out in a comment on another answer above: Assuming this does happen, what are you going to do about it? The program is utterly unable to run, so there's not much short of killing the program that you could conceivably do.</br></br></p>\n<p>Now, with C++17 not being far away and <code>string_view</code> already being available in <code>std::experimental</code> on several mainstream compilers, there's another thing you could try: <em>Use the correct thing</em>.</p>\n<p>A <code>string_view</code> will, contrary to a <code>string</code>, not allocate non-constant memory, copy constant data into that, and then <em>pretend</em> it's constant. Instead, it will manage a pointer directly to the constant data, and that's all.<br>\nThat way, your constants are truly (not just formally) constant, there are no allocations, no possibility of exceptions, and no double memory usage. And for the most part, it still looks and smells like a <code>string</code>. The only notable differences being that a <code>string_view</code> doesn't guarantee nul-termination (but the character constant it points to does, so this is irrelevant), and the fact that it's <em>really</em> constant, not modifiable... which is exactly what you want.</br></p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "40381821", "Score": "4", "CreationDate": "2016-11-02T13:59:41.033", "LastActivityDate": "2016-11-02T13:59:41.033"}, "40377546": {"CommentCount": "1", "AcceptedAnswerId": "40377626", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-11-02T10:24:17.140", "LastActivityDate": "2016-11-02T17:52:41.757", "LastEditDate": "2017-05-23T11:45:52.913", "ViewCount": "1698", "FavoriteCount": "2", "Title": "Why can creating a static const std::string cause an exception?", "Id": "40377546", "Score": "24", "Body": "<p>I have string constants, for strings that I use in multiple places in my app:</p>\n<pre><code>namespace Common{\n    static const std::string mystring = \"IamAwesum\";\n}\n</code></pre>\n<p>When posting a question about something else (<a href=\"https://stackoverflow.com/questions/40354900/what-happens-to-a-h-file-that-is-not-included-in-a-target-during-compilation?noredirect=1#comment67979223_40354900\">What happens to a .h file that is not included in a target during compilation?</a>), another user made the following comment :</p>\n<blockquote>\n<p id=\"so_40377546_40377546_0\">be aware that your static string are global in this case. So they are\n  could create an exception at anytime and can't be catch. I advise you\n  to use function who return a reference of your string. std::string\n  const &amp;mystring { static std::string const mystring = \"IamAwesum\";\n  return mystring} by this way your object is only construct when needed</p>\n</blockquote>\n<p>Can someone explain why using static const strings in the manner that I do so above, risks throwing exceptions ?</p>\n", "Tags": "<c++><static><constant-expression>", "OwnerUserId": "2990509", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_40377546_40377626_1": {"section_id": 7153, "quality": 0.9285714285714286, "length": 13}, "so_40377546_40377626_3": {"section_id": 3358, "quality": 1.0, "length": 16}}, "n3337": {"so_40377546_40377626_1": {"section_id": 6897, "quality": 0.9285714285714286, "length": 13}, "so_40377546_40377626_3": {"section_id": 3228, "quality": 1.0, "length": 16}}, "n4659": {"so_40377546_40377626_1": {"section_id": 8657, "quality": 0.8571428571428571, "length": 12}, "so_40377546_40377626_3": {"section_id": 4124, "quality": 1.0, "length": 16}}}, "40377830": {"ParentId": "40377546", "CommentCount": "0", "Body": "<p>The pdf document mostly refers to exceptions from the object ctor and initialization order fiasco with static or dynamically linked libraries.</p>\n<p>The only danger I see in your code for exceptions is if the ctor of std::string will throw when it is called.</p>\n<p>If you want to really be on the safe side you can use static const char* mystring instead which will not call to a C++ ctor.</p>\n<p>There is also the matter of the code being in a shared library which then needs to be placed in the address space of the process.\nI don't see that as a major problem if you don't use complicated ctors(ctors that can throw).</p>\n", "OwnerUserId": "682537", "PostTypeId": "2", "Id": "40377830", "Score": "4", "CreationDate": "2016-11-02T10:37:31.380", "LastActivityDate": "2016-11-02T10:37:31.380"}});