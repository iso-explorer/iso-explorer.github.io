post_cb({"7436808": {"ViewCount": "176", "Body": "<p>Suppose you have a static global variable in your header file, and you use this variable in your main.cpp.</p>\n<pre><code>// header.h\nstatic int variableOne = 100;\n\n//main.cpp\n   .\n   .\n   cout &lt;&lt; variableOne &lt;&lt; endl;\n</code></pre>\n<p>Will main.cpp get its own copy of <strong>variableOne</strong> (although the value is still 100...)? Or am I mixing this concept with extern (I know that extern tells the compiler that <strong>variableOne</strong> is defined elsewhere in the project...)</p>\n<p>Thank you.</p>\n", "AcceptedAnswerId": "7436960", "Title": "Does each file get its own copy of the static variable?", "CreationDate": "2011-09-15T20:02:50.287", "Id": "7436808", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-09-16T04:33:54.663", "Score": "2", "OwnerUserId": "230884", "Tags": "<c++>", "AnswerCount": "5"}, "7436832": {"PostTypeId": "2", "Body": "<p>In this case, each compilation module will get it's own copy of the variable.</p>\n<p>If you use <code>extern</code>, there will only be one copy. But you are only allowed to initialize it in one module.</p>\n<p>In other words, if you just replace <code>static</code> with <code>extern</code> in your example, it won't compile because it's being initialized in every module that includes that header.</p>\n", "LastActivityDate": "2011-09-15T20:05:02.657", "Id": "7436832", "CommentCount": "1", "CreationDate": "2011-09-15T20:05:02.657", "ParentId": "7436808", "Score": "5", "OwnerUserId": "922184"}, "7436960": {"PostTypeId": "2", "Body": "<h2>1. What does it mean #include</h2>\n<p>When you write <code>#include \"header.h\"</code> the compiler is basically just copying the whole content of the file instead of that line. In C++ an header file has no semantic meaning, it's just used for textual substitution.</p>\n<p>So if you have</p>\n<pre><code>---- header.h ----\nstatic int variableOne = 100;\n\n---- main.cpp ----\n#include \"header.h\"\n\n...\nstd::cout &lt;&lt; variableOne &lt;&lt; std::endl;\n</code></pre>\n<p>for the compiler is exactly the same as</p>\n<pre><code>---- main.cpp ----\nstatic int variableOne = 100;\n\n...\nstd::cout &lt;&lt; variableOne &lt;&lt; std::endl;\n</code></pre>\n<h2>2. What does it mean static in that context</h2>\n<p>A static variable is like a global for the lifetime (i.e. it's constructed before <code>main</code> starts and it's destroyed after <code>main</code> terminates) but is only visible inside the translation unit that defines it. So you can have the same static variable <strong>name</strong> used in different translation units and all those variables are distinct (each translation unit will see its own static variable).</p>\n<h2>3. What happens when you put a static variable declaration in an header?</h2>\n<p>The net result is that every translation unit that will include that header will get its own static variable with that name because it's exactly the same as if the translation unit defined a static variable in the <code>.cpp</code> and not in the header file.</p>\n<p>The name will be the same for all of them but they will be different variables. Of course if the header file declares and initializes the variable then the <strong>initial value</strong> will be the same, but all those variables will be distinct and if for example one translation unit changes that variable, the change will not be seen by other translation units.</p>\n", "LastActivityDate": "2011-09-15T20:39:34.420", "LastEditorUserId": "320726", "Id": "7436960", "CommentCount": "3", "CreationDate": "2011-09-15T20:16:43.697", "ParentId": "7436808", "Score": "4", "OwnerUserId": "320726", "LastEditDate": "2011-09-15T20:39:34.420"}, "7436854": {"PostTypeId": "2", "Body": "<p>Each source file would get their own independent copy of <code>variableOne</code>.</p>\n<blockquote>\n<p id=\"so_7436808_7436854_0\">The last use of static is as a global variable inside a file of code.\n  In this case, the use of static indicates that source code in other\n  files that are part of the project cannot access the variable. Only\n  code inside the single file can see the variable.</p>\n</blockquote>\n<p><strong><a href=\"http://www.cprogramming.com/tutorial/statickeyword.html\" rel=\"nofollow\">Source</a></strong></p>\n<p>If you use <code>extern</code> all your source files will reference the same variable, but you won't be able to initialize it in the header. You would have to add an initialization to one of the source files.</p>\n", "LastActivityDate": "2011-09-15T21:14:51.280", "LastEditorUserId": "674991", "Id": "7436854", "CommentCount": "1", "CreationDate": "2011-09-15T20:07:22.513", "ParentId": "7436808", "Score": "4", "OwnerUserId": "674991", "LastEditDate": "2011-09-15T21:14:51.280"}, "bq_ids": {"n4140": {"so_7436808_7436834_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5482}}, "n3337": {"so_7436808_7436834_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5268}}}, "7436836": {"PostTypeId": "2", "Body": "<p><code>static</code> variables in namespace scope are not external, and as such you would get a copy of the static variable for each 'translation unit' in the project. This technique has been obsoleted since C++03, and the recommended way to do it is now enclosing the variable within an unnamed namespace.</p>\n", "LastActivityDate": "2011-09-15T20:05:47.043", "Id": "7436836", "CommentCount": "1", "CreationDate": "2011-09-15T20:05:47.043", "ParentId": "7436808", "Score": "3", "OwnerUserId": "927034"}, "7436834": {"PostTypeId": "2", "Body": "<p>If you declare a <code>static</code> variable in an header file then a copy of that variable will be created in each <strong><a href=\"https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c\">translation unit</a></strong> where you include the header file.  </p>\n<p>So <strong>Never</strong> declare a static variable in Header File.  </p>\n<p>Also, <strong>C++03 standard: 7.3.1.1/2</strong> says:   </p>\n<blockquote>\n<p id=\"so_7436808_7436834_0\">The use of the <code>static</code> keyword is deprecated when declaring objects in a namespace scope, the \n  <strong><a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=/com.ibm.vacpp7a.doc/language/ref/clrc10unnamed_namespaces.htm\" rel=\"nofollow noreferrer\">unnamed-namespace</a></strong> provides a superior alternative.</p>\n</blockquote>\n<p><strong>C++03 standard: 7.3.1.1/1</strong> says: </p>\n<blockquote>\n<p id=\"so_7436808_7436834_1\">\"[a]lthough entities in an unnamed namespace might have external linkage, they are effectively qualified by a name unique to their translation unit and therefore can never be seen from any other translation unit.\" </p>\n</blockquote>\n<p>In simple words, an <code>unnamed namespace</code> restricts the visibility of its members to the scope of the translation unit by means of name mangling and avoids the problems faced as while using <code>static</code> keyword.</p>\n<p>Also, You cannot use keywords <code>static</code> and <code>extern</code> together on a variable because both aim to achieve mutually exclusive behaviors.</p>\n", "LastActivityDate": "2011-09-16T04:33:54.663", "LastEditorUserId": "-1", "Id": "7436834", "CommentCount": "1", "CreationDate": "2011-09-15T20:05:10.200", "ParentId": "7436808", "Score": "6", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T10:24:35.753"}});