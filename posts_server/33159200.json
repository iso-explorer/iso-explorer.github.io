post_cb({"bq_ids": {"n4140": {"so_33159200_33159350_2": {"length": 14, "quality": 1.0, "section_id": 6185}}, "n4659": {"so_33159200_33159350_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}}}, "33159367": {"Id": "33159367", "PostTypeId": "2", "Body": "<p>The code is indeed ill-formed as per [expr.const]/(2.6); lambdas aren't yet allowed in constant expressions, though a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4487.pdf\" rel=\"nofollow\">corresponding proposal</a> is in circulation. GCC is incorrect in accepting <code>lambda_plus</code>'s declaration.</p>\n", "Score": "3", "LastActivityDate": "2015-10-15T22:10:29.533", "CreationDate": "2015-10-15T22:10:29.533", "ParentId": "33159200", "CommentCount": "1", "OwnerUserId": "3647361"}, "33159200": {"ViewCount": "199", "LastEditDate": "2017-05-23T12:07:56.847", "AcceptedAnswerId": "33159367", "Title": "GCC constexpr lambas in constexpr functions and evaluation in compile time", "CreationDate": "2015-10-15T21:56:57.543", "LastActivityDate": "2016-05-26T19:20:03.130", "CommentCount": "5", "Body": "<p>Code first, we have the following piece of code that is used to accumulate a <code>constexpr std::array</code> in compile time:</p>\n<pre><code>template &lt;typename T, std::size_t N, typename O&gt;\nconstexpr T compile_time_accumulator(const std::array&lt;T, N&gt; const &amp;A, const std::size_t i, const O&amp; op, const T initialValue)\n{\n  return (i &lt; N)\n       ? op(A[i], compile_time_accumulator(A, i + 1, op, initialValue))\n       : initialValue;\n}\n</code></pre>\n<p>and the following code example to test/varify it (i.e., that it evaluates in compile time):</p>\n<pre><code>constexpr std::array&lt;int, 4&gt; v {{4, 5, 6, 7}};\nstd::cout &lt;&lt; std::integral_constant&lt;int, compile_time_accumulator(v, 42, std::plus&lt;int&gt;())&gt;::value \n          &lt;&lt; std::endl;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f21ef91109add133\" rel=\"nofollow noreferrer\"><strong>LIVE DEMO</strong></a></p>\n<p>Now if change the operator <code>std::plus&lt;int&gt;</code> with a <code>constexpr</code> lambda:</p>\n<pre><code>constexpr auto lambda_plus = [] (int x, int y) { return x + y; };\n</code></pre>\n<p>and call it like below:</p>\n<pre><code>constexpr std::array&lt;int, 4&gt; v {{4, 5, 6, 7}};\nstd::cout &lt;&lt; std::integral_constant&lt;int, compile_time_accumulator(v, 42, lambda_plus)&gt;::value &lt;&lt; std::endl;\n                                                                         ^^^^^^^^^^^ \n</code></pre>\n<p>I get an error, that lambda is not <code>constexpr</code> : </p>\n<blockquote>\n<p id=\"so_33159200_33159200_0\">call to non-constexpr function ''</p>\n</blockquote>\n<p>Now doing a litle <a href=\"https://stackoverflow.com/a/32697323/2352671\">research</a> I discovered that <code>constexpr</code> lambdas aren't support yet.</p>\n<h2>Q:</h2>\n<p>Why if <code>constexpr</code> lambdas aren't supported, we are allowed to define a <code>constexpr</code> lambda in the first place?</p>\n<p>Edit:</p>\n<p>It seems that clang doesn't accep the <a href=\"http://coliru.stacked-crooked.com/a/bccb610676dbb818\" rel=\"nofollow noreferrer\">code</a>. So which compiler is right?</p>\n", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "33159200", "AnswerCount": "2", "Score": "0", "OwnerUserId": "2352671", "Tags": "<c++><c++11><lambda><c++14><constexpr>", "FavoriteCount": "1"}, "33159350": {"Id": "33159350", "PostTypeId": "2", "LastEditDate": "2015-10-16T03:06:48.440", "CommentCount": "2", "LastEditorUserId": "3924882", "LastActivityDate": "2015-10-16T03:06:48.440", "CreationDate": "2015-10-15T22:09:22.037", "ParentId": "33159200", "Score": "3", "Body": "<p>C++11 allowed a very limited amount definition of a <code>constexpr</code> while C++14 has a long list of is not a <code>constexpr</code></p>\n<blockquote>\n<p id=\"so_33159200_33159350_0\">From n4296 (release candidate for C++14) 5.20.2.6</p>\n<p id=\"so_33159200_33159350_1\">5.20 Constant expressions [expr.const]</p>\n<p id=\"so_33159200_33159350_2\">2 A conditional-expression e is a core constant expression unless the\n  evaluation of e, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:</p>\n<p id=\"so_33159200_33159350_3\">2.6) \u2014 a lambda-expression (5.1.2);</p>\n</blockquote>\n<p>So the answer is that lambda's are not OK so the compiler must be wrong.</p>\n", "OwnerUserId": "4013258"}});