post_cb({"bq_ids": {"n4140": {"so_15795400_15800039_0": {"length": 23, "quality": 0.92, "section_id": 6041}}, "n3337": {"so_15795400_15800039_0": {"length": 23, "quality": 0.92, "section_id": 5809}}, "n4659": {"so_15795400_15800039_0": {"length": 23, "quality": 0.92, "section_id": 7540}}}, "15796158": {"Id": "15796158", "PostTypeId": "2", "Body": "<p>You would need to make your const version of iterator be constructible from a non-const node. Then I would rewrite the getters to be more STL compliant:</p>\n<pre><code>Iterator&lt;const T&gt; begin() const { return Iterator&lt;const T&gt;(front_); }\nIterator&lt;T&gt; begin() { return Iterator&lt;T&gt;(front_); }\n</code></pre>\n<p>All you need to do is make that first version compile. Casting won't work here since <code>Node&lt;T&gt;</code> isn't going to be related to <code>Node&lt;const T&gt;</code>. </p>\n", "LastActivityDate": "2013-04-03T19:22:13.417", "CommentCount": "3", "CreationDate": "2013-04-03T19:22:13.417", "ParentId": "15795400", "Score": "0", "OwnerUserId": "2069064"}, "15795400": {"ViewCount": "458", "Body": "<p>Would this be a correct use of reinterpret_cast or is there some better approach to solve the problem.</p>\n<pre><code>Node&lt;T&gt;* front_;\n\nIterator&lt;const T&gt; GetConstIterator() const {\n  return Iterator&lt;const T&gt;(reinterpret_cast&lt;Node&lt;const T&gt;*&gt;(front_));\n}\n\nIterator&lt;T&gt; GetIterator() {\n  return Iterator&lt;T&gt;(front_);\n}\n</code></pre>\n<p>The iterator's constructor is defined as this.</p>\n<pre><code>template&lt;class T&gt;\nclass Iterator {\n  explicit Iterator(Node&lt;T&gt;* const node) : node_(node) {}\n  ...\n}\n</code></pre>\n", "Title": "Using reinterpret_cast to add const to a template class", "CreationDate": "2013-04-03T18:42:10.387", "LastActivityDate": "2013-04-08T03:19:03.237", "CommentCount": "11", "LastEditDate": "2013-04-08T03:19:03.237", "PostTypeId": "1", "LastEditorUserId": "399663", "Id": "15795400", "Score": "0", "OwnerUserId": "399663", "Tags": "<c++><reinterpret-cast>", "AnswerCount": "2"}, "15800039": {"Id": "15800039", "PostTypeId": "2", "Body": "<p>It is illegal to use reinterpret_cast to cast away const-ness. You need to use const_cast for that. You <em>could</em> use <code>reinterpret_cast</code> to add const-ness, but a <code>const_cast</code> is more correct and more evident to future maintainers. </p>\n<p>From \u00a75.2.10 Reinterpret cast, p2:</p>\n<blockquote>\n<p id=\"so_15795400_15800039_0\">The reinterpret_cast operator shall not cast away constness (5.2.11).\n  An expression of integral, enumeration, pointer, or pointer-to-member\n  type can be explicitly converted to its own type; such a cast yields\n  the value of its operand.</p>\n</blockquote>\n<p>Really, the constructor of <code>Node&lt;const T&gt;</code> should be able to do this implicitly, and the cast shouldn't even be necessary.</p>\n<p>The ambiguity arises from your function:</p>\n<pre><code>Iterator&lt;T&gt; GetIterator() const {\n  return Iterator&lt;T&gt;(front_);\n}\n</code></pre>\n<p>You shouldn't be returning an iterator that can mutate the container as a const method. This method should not have the const-qualifier.</p>\n<p>You should just have:</p>\n<pre><code>Iterator&lt;const T&gt; GetIterator() const {\n  return Iterator&lt;const T&gt;(front_);\n}\n\nIterator&lt;T&gt; GetIterator() {\n  return Iterator&lt;T&gt;(front_);\n}\n</code></pre>\n", "LastEditorUserId": "311314", "LastActivityDate": "2013-04-04T00:24:53.597", "Score": "0", "CreationDate": "2013-04-03T23:29:13.983", "ParentId": "15795400", "CommentCount": "4", "OwnerUserId": "311314", "LastEditDate": "2013-04-04T00:24:53.597"}});