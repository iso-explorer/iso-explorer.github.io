post_cb({"3673857": {"Id": "3673857", "PostTypeId": "2", "Body": "<p>The class \"definition\" is actually only providing a \"declaration\" of <code>A::k</code>.  Yeah, I know it's confusing, but the idea is to allow the class definition to be in a <code>.h</code> (included from multiple <code>.cpp</code> sources) without creating ambiguities: one, and only one, of those <code>.cpp</code> sources, must provide the actual <em>definition</em> to match <code>A::k</code>'s <em>declaration</em> (the latter being part of class <code>A</code>'s <em>definition</em>).</p>\n", "LastActivityDate": "2010-09-09T04:51:06.590", "CommentCount": "5", "CreationDate": "2010-09-09T04:51:06.590", "ParentId": "3673831", "Score": "2", "OwnerUserId": "95810"}, "3674370": {"Id": "3674370", "PostTypeId": "2", "Body": "<p>Other answers have already given the how to fix it -- I'll go more into the why.</p>\n<p>When you do this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A { \n  public: \n  static const float k = 7.7;\n};\n\nint main()\n{\n  cout &lt;&lt; A::k;\n}\n</code></pre>\n<p>The compiler is probably in reality generating this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A { \n  public: \n  static const float k = 7.7;\n};\n\nint main()\n{\n  cout &lt;&lt; 7.7;\n}\n</code></pre>\n<p>which means there will be no link-time dependency between this translation unit and <code>A::f</code> -- the compiled code doesn't reference <code>A::f</code> at all!</p>\n<p>However, when you use <code>&amp;A::f</code>, you force the compiler to generate an address for <code>A::f</code>. Therefore that translation unit <em>does</em> have a dependence on <code>A::f</code>. Since you have not defined it, you get a linker error, because the linker cannot find an address for it. For the address to exist, <code>A::f</code> must be defined in one <strong>and only one</strong> translation unit. To choose the translation unit in which it should reside, you need to define it there.</p>\n<p>You also have an invalid code issue with your class above though -- only <strong>static const integral</strong> members may be initialized with the syntax you've used (putting k = 7.7 in the class body) -- <code>float</code> is not an integral type.</p>\n", "LastActivityDate": "2010-09-09T06:49:00.877", "CommentCount": "0", "CreationDate": "2010-09-09T06:49:00.877", "ParentId": "3673831", "Score": "1", "OwnerUserId": "82320"}, "3673831": {"ViewCount": "237", "Body": "<p>My question: What exactly is the out of class definition of k doing under the hood to make sure it's address is available? </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A { \n  public: \n  static const float k = 7.7;\n};\n\n//const float A::k; --&gt; without this line compiler error\n\nint main()\n{\n  cout &lt;&lt; &amp;A::k;\n}\n</code></pre>\n", "AcceptedAnswerId": "3674370", "Title": "Need for out of class definition of static variable?", "CreationDate": "2010-09-09T04:45:36.403", "Id": "3673831", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2010-09-09T07:15:14.317", "Score": "2", "OwnerUserId": "350810", "Tags": "<c++>", "AnswerCount": "6"}, "3674214": {"Id": "3674214", "PostTypeId": "2", "Body": "<p>If you could define like <code>static const float k = 7.7;</code> <em>as you wish</em>, you will end up in multiple definitions (<em>since static members will be defined only once</em>), wherever you are including it.</p>\n<p>To avoid that the definition is made reside separately in a <code>cpp</code> file.</p>\n<p>From C++ standard docs sec 9.4.1,</p>\n<blockquote>\n<p id=\"so_3673831_3674214_0\">A static data member is <strong>not part</strong> of the subobjects of a class. There is <strong>only one copy</strong> of a static data member <strong>shared\n  by all the objects</strong> of the class.</p>\n</blockquote>\n<p>Also 9.4.2 states that,</p>\n<blockquote>\n<p id=\"so_3673831_3674214_1\">The declaration of a static data member in its class definition <strong>is not a definition</strong> and may be of an incomplete type\n  other than cv-qualified void. The definition for a static data member <strong>shall appear</strong> in a <strong>namespace scope</strong> enclosing the\n  member\u2019s class definition.</p>\n</blockquote>\n<p>Hope it helps..</p>\n", "LastActivityDate": "2010-09-09T06:14:42.553", "CommentCount": "0", "CreationDate": "2010-09-09T06:14:42.553", "ParentId": "3673831", "Score": "1", "OwnerUserId": "249490"}, "bq_ids": {"n4140": {"so_3673831_3674214_0": {"length": 15, "quality": 0.9375, "section_id": 5906}, "so_3673831_3674214_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 5907}}, "n3337": {"so_3673831_3674214_0": {"length": 15, "quality": 0.9375, "section_id": 5678}, "so_3673831_3674214_1": {"length": 26, "quality": 0.9285714285714286, "section_id": 5679}}, "n4659": {"so_3673831_3674214_0": {"length": 15, "quality": 0.9375, "section_id": 7388}, "so_3673831_3674214_1": {"length": 24, "quality": 0.8571428571428571, "section_id": 7389}}}, "3673946": {"Id": "3673946", "PostTypeId": "2", "Body": "<p>A static variable can be deemed as data shared by all the objects of the class and hence only one copy of this variable should be created. With this said, with whom should lie the responsibility of allocationg memory for this member? Obviously it can't be object's responsibility as there could be multiple objects which would raise another challenge as to which object should allocate memory for this member.</p>\n<p>So typically compliler expects out of class, explicit definition of this member and hence the line:</p>\n<p><code>const float A::k;</code></p>\n<p>This ensures that the static member variable is accessible to all the objects of the class.  The memory for this variable is allocated on  globally accessible memory.</p>\n", "LastActivityDate": "2010-09-09T05:13:37.277", "CommentCount": "0", "CreationDate": "2010-09-09T05:13:37.277", "ParentId": "3673831", "Score": "0", "OwnerUserId": "240857"}, "3673853": {"Id": "3673853", "PostTypeId": "2", "Body": "<p>The one which is inside the class is the <em>declaration</em> of the variable <code>k</code>. You need to <em>define</em> it in exactly one translation unit in order to link your program correctly. Hence that statement is required.</p>\n", "LastEditorUserId": "39742", "LastActivityDate": "2010-09-09T07:15:14.317", "Score": "1", "CreationDate": "2010-09-09T04:49:56.763", "ParentId": "3673831", "CommentCount": "1", "OwnerUserId": "39742", "LastEditDate": "2010-09-09T07:15:14.317"}, "3673948": {"Id": "3673948", "PostTypeId": "2", "Body": "<p>It sounds like you're wondering why the variable needs to be defined even though you aren't accessing it.</p>\n<p>To print its address, it needs to have an address. To have an address, it must exist. To exist, it needs to have a definition and the linker needs to assign it a place in global variable space. So, there really isn't a middle ground.</p>\n<p>\"Under the hood,\" the definition tells the linker what the initializer for the global is. (In this case, the initializer is in the <code>class</code> block. But that's nonstandard. The official way is to write <code>const float A::k = 7.7;</code>) Without knowing that, it can't produce the executable file.</p>\n<p>Also, unless the compiler performs impossibly detailed analysis, it can't really tell that <code>operator &lt;&lt;</code> doesn't somehow pass that pointer to some other function or OS service that <em>will</em> access the value of <code>k</code>.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-09-09T05:18:53.957", "Score": "1", "CreationDate": "2010-09-09T05:13:52.420", "ParentId": "3673831", "CommentCount": "0", "OwnerUserId": "153285", "LastEditDate": "2010-09-09T05:18:53.957"}});