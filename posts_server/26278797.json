post_cb({"bq_ids": {"n4140": {"so_26278797_26279344_1": {"length": 21, "quality": 1.0, "section_id": 3163}, "so_26278797_26279344_0": {"length": 18, "quality": 1.0, "section_id": 3163}, "so_26278797_26278926_0": {"length": 20, "quality": 1.0, "section_id": 3071}}, "n3337": {"so_26278797_26279344_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 3036}, "so_26278797_26279344_0": {"length": 18, "quality": 1.0, "section_id": 3036}}, "n4659": {"so_26278797_26279344_1": {"length": 21, "quality": 1.0, "section_id": 3925}, "so_26278797_26279344_0": {"length": 18, "quality": 1.0, "section_id": 3925}, "so_26278797_26278926_0": {"length": 20, "quality": 1.0, "section_id": 3831}}}, "26278926": {"Id": "26278926", "PostTypeId": "2", "Body": "<p><code>std::async</code> returns a <a href=\"http://en.cppreference.com/w/cpp/thread/future\" rel=\"nofollow\">future</a>. Its <a href=\"http://en.cppreference.com/w/cpp/thread/future/~future\" rel=\"nofollow\">destructor</a> blocks if <code>get</code> or <code>wait</code> has not been called:</p>\n<blockquote>\n<p id=\"so_26278797_26278926_0\">it may block if all of the following are true: the shared state was created by a call to std::async, the shared state is not yet ready, and this was the last reference to the shared state.</p>\n</blockquote>\n<p>See <a href=\"http://scottmeyers.blogspot.co.uk/2013/03/stdfutures-from-stdasync-arent-special.html\" rel=\"nofollow\">std::futures from std::async aren't special!</a> for a detailed treatment of the subject.</p>\n", "LastActivityDate": "2014-10-09T12:52:27.990", "CommentCount": "2", "CreationDate": "2014-10-09T12:52:27.990", "ParentId": "26278797", "Score": "1", "OwnerUserId": "412080"}, "26278797": {"ViewCount": "467", "Body": "<p>I'm learning about mutexes in C++ and have a problem with the following code (taken from N. Josuttis' \"The C++ Standard Library\").</p>\n<p>I don't understand why it blocks / throws <em>unless I add</em> <code>this_thread::sleep_for</code> in the main thread (then it doesn't block and all three calls are carried out).</p>\n<p>The compiler is cl.exe used from the command line. </p>\n<pre><code>#include &lt;future&gt;\n#include &lt;mutex&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n\nstd::mutex printMutex;\n\nvoid print(const std::string&amp; s)\n{\n    std::lock_guard&lt;std::mutex&gt; lg(printMutex);\n\n    for (char c : s)\n    {\n        std::cout.put(c);\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nint main()\n{\n    auto f1 = std::async(std::launch::async, print, \"Hello from thread 1\");\n    auto f2 = std::async(std::launch::async, print, \"Hello from thread 2\");\n\n    // std::this_thread::sleep_for(std::chrono::seconds(1));\n\n    print(std::string(\"Hello from main\"));       \n}\n</code></pre>\n", "AcceptedAnswerId": "26279344", "Title": "C++ program unexpectedly blocks / throws", "CreationDate": "2014-10-09T12:46:06.977", "Id": "26278797", "CommentCount": "1", "LastEditDate": "2014-10-24T12:07:58.023", "PostTypeId": "1", "LastEditorUserId": "3747990", "LastActivityDate": "2014-10-24T12:07:58.023", "Score": "9", "OwnerUserId": "3907339", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "3"}, "26279051": {"Id": "26279051", "PostTypeId": "2", "Body": "<p>Add these 2 lines at the end of <code>main</code>:</p>\n<pre><code>f1.wait();\nf2.wait();\n</code></pre>\n<p>This will make sure the threads finish before <code>main</code> exists.</p>\n", "LastActivityDate": "2014-10-09T12:58:42.233", "CommentCount": "0", "CreationDate": "2014-10-09T12:58:42.233", "ParentId": "26278797", "Score": "1", "OwnerUserId": "3005057"}, "26279344": {"Id": "26279344", "PostTypeId": "2", "Body": "<p>I think what you are seeing is an issue with the conformance of the MSVC implementation of <code>async</code> (in combination with <code>future</code>). I believe it is <a href=\"https://stackoverflow.com/a/21023972/3747990\">not conformant</a>. I am able to reproduce it with VS2013, but unable to reproduce the issue with gcc.</p>\n<p>The crash is because the main thread exits (and starts to clean up) before the other two threads complete.</p>\n<p>Hence a simple delay (the <code>sleep_for</code>) or <code>.get()</code> or <code>.wait()</code> on the two futures should fix it for you. So the modified <code>main</code> could look like;</p>\n<pre><code>int main()\n{\n    auto f1 = std::async(std::launch::async, print, \"Hello from thread 1\");\n    auto f2 = std::async(std::launch::async, print, \"Hello from thread 2\");\n\n    print(std::string(\"Hello from main\"));       \n\n    f1.get();\n    f2.get();\n}\n</code></pre>\n<p>Favour the explicit wait or get over the timed \"sleep\".</p>\n<p><em>Notes on the conformance</em></p>\n<p>There was a proposal from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf\" rel=\"nofollow noreferrer\">Herb Sutter</a> to change the wait or block on the shared state of the <code>future</code> returned from <code>async</code>. This may be the reason for the behaviour in MSVC, it could be seen as having implemented the proposal. I'm not sure what the final result was of the proposal was or its integration (or part thereof) into C++14. At least w.r.t. the blocking of the <code>future</code> returned from <code>async</code> it looks like the MSVC behaviour did not make it into the specification.</p>\n<p>It is interesting to note that the wording in \u00a730.6.8/5 changed;</p>\n<p>From C++11</p>\n<blockquote>\n<p id=\"so_26278797_26279344_0\">a call to a waiting function on an asynchronous return object that shares the shared state created\n  by this <code>async</code> call shall block until the associated thread has completed, as if joined</p>\n</blockquote>\n<p>To C++14</p>\n<blockquote>\n<p id=\"so_26278797_26279344_1\">a call to a waiting function on an asynchronous return object that shares the shared state created\n  by this <code>async</code> call shall block until the associated thread has completed, as if joined, <strong>or else time\n  out</strong></p>\n</blockquote>\n<p>I'm not sure how the \"time out\" would be specified, I would imagine it is implementation defined.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-16T08:34:01.733", "Score": "11", "CreationDate": "2014-10-09T13:13:00.360", "ParentId": "26278797", "CommentCount": "2", "OwnerUserId": "3747990", "LastEditDate": "2017-05-23T11:49:37.063"}});