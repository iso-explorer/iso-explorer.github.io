post_cb({"42998461": {"ParentId": "42997644", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><strong>What happens in the expression <code>i = i++ + 1</code>? Is it well-defined, undefined, implementation defined or unspecified behaviour?</strong></p>\n<p>This exact example is given in the standard, how lucky are we?</p>\n<blockquote>\n<p id=\"so_42997644_42998461_0\"><strong>N4296 1.9.15 [intro.execution]</strong></p>\n<p id=\"so_42997644_42998461_1\"><code>i = i++ + 1; // the behavior is undefined</code></p>\n</blockquote>\n<p>Of course, we'd like to know <em>why</em> too. The following standard quote appears to be relevant here:</p>\n<blockquote>\n<p id=\"so_42997644_42998461_2\"><strong>N4296 1.9.15 [intro.execution]</strong></p>\n<p id=\"so_42997644_42998461_3\">[ ... ] The value computations of the operands of an operator are sequenced\n  before the value computation of the result of the operator. [ ... ]</p>\n</blockquote>\n<p>This tells us that the sum will occur before the assignment (duh, how else does it know what to assign!), but it doesn't guarantee that the increment will occur before or after the assignment, now we're in murky water...</p>\n<blockquote>\n<p id=\"so_42997644_42998461_4\"><strong>N4296 1.9.15 [intro.execution]</strong></p>\n<p id=\"so_42997644_42998461_5\">[ ... ] If a side effect on a scalar object is unsequenced relative to either\n  another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, and they are not\n  potentially concurrent (1.10), the behavior is undefined. [ ... ]</p>\n</blockquote>\n<p>The assignment operator has a side effect on the value of <code>i</code>, which means we have two side effects (the other is the assignment performed by <code>i++</code>) on the same scalar object, which are unsequenced, which is undefined.</p>\n<p><strong>Why does Visual Studio show the behavior which is different from written in standard?</strong></p>\n<p>It doesn't. The standard says it's undefined, which means it can do anything from what you wanted to something completely different, it just so happens that this is the behaviour that got spat out by the compiler!</p>\n", "OwnerUserId": "1816262", "LastEditorUserId": "1816262", "LastEditDate": "2017-03-24T11:38:18.867", "Id": "42998461", "Score": "1", "CreationDate": "2017-03-24T11:33:16.333", "LastActivityDate": "2017-03-24T11:38:18.867"}, "42997644": {"CommentCount": "14", "ViewCount": "116", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-03-24T10:54:21.803", "LastActivityDate": "2017-03-24T12:38:36.410", "Title": "Preincrement vs postincrement in terms of sequence points", "AcceptedAnswerId": "42998461", "LastEditDate": "2017-05-23T11:54:10.047", "Id": "42997644", "Score": "3", "Body": "<p>In <a href=\"https://stackoverflow.com/a/4183735/1989995\">this answer</a> there're some examples of well-defined and undefined expressions. I'm particularly interested in two of them:</p>\n<pre><code>(6) i = i++ + 1;    // Undefined Behaviour\n(7) i = ++i + 1;    // Well-defined Behaviour\n</code></pre>\n<p>This means that there's a difference between preincrement and postincrement in terms of sequence points and well defined / unspecified / undefined behavior, but I don't understand where this difference comes from.</p>\n<p>In standard draft (<strong>N4618</strong>) there's an example of code ([intro.execution], pt 18)</p>\n<blockquote>\n<p id=\"so_42997644_42997644_0\"><code>i = i++ + 1; // the value of i is incremented</code></p>\n<p id=\"so_42997644_42997644_1\"><code>i = i++ + i; // the behavior is undefined</code></p>\n</blockquote>\n<p>Which, as far as I understand, means that expression <code>i = i++ + 1</code> should be well-defined and the value of variable <code>i</code> should increase by <code>1</code> as the result of this expression. However, this code run in MSVS 2015 increases <code>i</code> by <code>2</code>.</p>\n<p>So, what happens in the expression <code>i = i++ + 1</code>? Is it well-defined, undefined, implementation defined or unspecified behavior? And is there any difference between preincrement and postincrement in this and similar expressions in terms of sequence points and UB, as stated in original answer? And why Visual Studio shows the behavior which is different from written in standard?</p>\n<p>Please also note that I'm primarily interested in modern c++ (14/17).</p>\n", "Tags": "<c++><c++14><language-lawyer><increment><undefined-behavior>", "OwnerUserId": "1989995", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_42997644_42999312_2": {"section_id": 5811, "quality": 0.9142857142857143, "length": 32}, "so_42997644_42999312_4": {"section_id": 6173, "quality": 0.8823529411764706, "length": 15}, "so_42997644_42998461_5": {"section_id": 5811, "quality": 0.9615384615384616, "length": 25}, "so_42997644_42999312_3": {"section_id": 6173, "quality": 0.8823529411764706, "length": 15}, "so_42997644_42998461_3": {"section_id": 5811, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_42997644_42999312_2": {"section_id": 5584, "quality": 0.9142857142857143, "length": 32}, "so_42997644_42999312_4": {"section_id": 5934, "quality": 0.8823529411764706, "length": 15}, "so_42997644_42998461_5": {"section_id": 5584, "quality": 0.7692307692307693, "length": 20}, "so_42997644_42999312_3": {"section_id": 5934, "quality": 0.8823529411764706, "length": 15}, "so_42997644_42998461_3": {"section_id": 5584, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_42997644_42999312_2": {"section_id": 7272, "quality": 0.7428571428571429, "length": 26}, "so_42997644_42998461_3": {"section_id": 7272, "quality": 0.9090909090909091, "length": 10}, "so_42997644_42998461_5": {"section_id": 7272, "quality": 0.7307692307692307, "length": 19}, "so_42997644_42999312_3": {"section_id": 7675, "quality": 0.8823529411764706, "length": 15}, "so_42997644_42999312_4": {"section_id": 7675, "quality": 0.8823529411764706, "length": 15}}}, "42999312": {"ParentId": "42997644", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_42997644_42999312_0\"><code>i = ++i + 1;    // Well-defined Behaviour</code></p>\n<p id=\"so_42997644_42999312_1\">This means that there's a difference between preincrement and postincrement in terms of sequence points and well defined / unspecified / undefined behavior, but I don't understand where this difference comes from.</p>\n</blockquote>\n<p>I believe that post is incorrect in several ways. Quoting the same section as they do, emphasis mine:</p>\n<blockquote>\n<p id=\"so_42997644_42999312_2\">C++11 1.9/15<br>\n  The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar\n  object is unsequenced relative to either another side effect on the same scalar object <strong>or a value computation\n  using the value of the same scalar object, the behavior is undefined</strong>.</br></p>\n</blockquote>\n<p>Then the assignment operator:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_42997644_42999312_4\">C++11 5.17<br>\n    In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</br></p>\n</blockquote>\n</blockquote>\n<p>Notable, the value computation or the right and left operands is not sequenced. (This has been explicitly spelled out in C11 <sup>1)</sup>, which otherwise has a completely identical text as C++11.)</p>\n<p>Meaning that in the expression <code>i = ++i + 1;</code> the side effect of <code>++i</code> is unsequenced in relation to the <em>value computation</em> of the left operand <code>i</code>. Thus it is undefined behavior as per 1.9/15. And the UB has nothing to do with the assignment side-effect at all.</p>\n<p>As for the expression <code>i = i++ + 1;</code>, the side-effect of assignment is, as per C++11, explicitly sequenced after the value computations, but before the value computation of the expression as whole. The value computation of <code>i++</code> is not an issue as per 5.2.6 \"The value computation of the ++ expression is sequenced before the modification of the operand object\". As per the nature of the postfix ++, the side effect of updating <code>i++</code> must be sequenced after the value computation of the whole expression. It is well-defined behavior, as far as I can tell.</p>\n<p>Correct text should therefore be</p>\n<pre><code>(6) i = i++ + 1;    // Well-defined Behaviour\n(7) i = ++i + 1;    // Undefined Behaviour\n</code></pre>\n<p>Apparently there was an incorrect example in C++11 1.9/15 <code>i = i++ + 1; // the behavior is undefined</code> which has been corrected in later versions of the standard. </p>\n<p>NOTE: None of this has the slightest to do with the change of wording about sequence points!</p>\n<hr>\n<p><sup>1)</sup> C11 6.5.16/3   </p>\n<blockquote>\n<p id=\"so_42997644_42999312_5\">The side effect of updating the stored value of the\n  left operand is sequenced after the value computations of the left and\n  right operands. <strong>The evaluations of the operands are unsequenced.</strong></p>\n</blockquote>\n</hr>", "OwnerUserId": "584518", "LastEditorUserId": "584518", "LastEditDate": "2017-03-24T12:38:36.410", "Id": "42999312", "Score": "0", "CreationDate": "2017-03-24T12:17:41.720", "LastActivityDate": "2017-03-24T12:38:36.410"}});