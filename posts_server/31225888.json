post_cb({"31225888": {"CommentCount": "11", "ViewCount": "518", "PostTypeId": "1", "LastEditorUserId": "5567387", "CreationDate": "2015-07-04T23:22:55.520", "LastActivityDate": "2016-02-23T07:26:16.743", "Title": "pre-typedef'ing a variadic-function-pointer argument", "AcceptedAnswerId": "35571258", "LastEditDate": "2016-02-07T19:57:26.673", "Id": "31225888", "Score": "15", "Body": "<p>I have a function <code>foo</code> that takes a variadic function pointer as its argument.</p>\n<p>I would like to use \"using\" to define the argument's type prior to the function declaration.</p>\n<pre><code>template &lt;typename ... vARGS&gt;\nusing TFuncType = void(*)(vARGS ... V_args);\n\ntemplate &lt;typename ... vARGS&gt;\nvoid foo(TFuncType&lt;vARGS ...&gt; funcptr) {}\n\nvoid bar(int i) {}\n\nint main() {\n  foo(&amp;bar); // This line fails to compile.\n}\n</code></pre>\n<p>This doesn't compile. The error (via clang using c++1z) is:</p>\n<pre><code>/make/proj/test/variadic-funcparam-deduce2.cpp:39:5: error: no matching function for call to 'foo'\nfoo(&amp;bar);\n^~~\n/make/proj/test/variadic-funcparam-deduce2.cpp:33:36: note: candidate template ignored: substitution failure [with vARGS = int]\ntemplate &lt;typename ... vARGS&gt; void foo(TFuncType&lt;vARGS ...&gt; funcptr) {}\n</code></pre>\n<p>Why is the \"int\" substitution failing?</p>\n<p>I can successfully compile if I explicitly write the type inside foo():</p>\n<pre><code>template &lt;typename ... vARGS&gt;\nvoid foo(void(*funcptr)(vARGS ... V_args)) {}\n</code></pre>\n<p>But I cannot get the initial (\"using\") version to work even when explicitly specifying the template parameters, and using a pre-casted <code>TFuncType&lt;int&gt;</code> for the argument, i.e.:</p>\n<pre><code>int main() {\n  TF_call&lt;int&gt; fptr = &amp;bar; // This line is OK.\n  foo&lt;int&gt;(fptr);\n}\n</code></pre>\n<p>Does anyone know what's up here?</p>\n<p>Is there something strange about using typedef'd (\"using\") variadics and/or function pointers that I'm missing?</p>\n", "Tags": "<c++><templates><c++11><function-pointers><variadic>", "OwnerUserId": "3969962", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31225888_35571258_0": {"section_id": 166, "quality": 0.88, "length": 22}}, "n3337": {"so_31225888_35571258_0": {"section_id": 160, "quality": 0.88, "length": 22}}, "n4659": {"so_31225888_35571258_0": {"section_id": 170, "quality": 0.88, "length": 22}}}, "35571258": {"ParentId": "31225888", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I believe this may be related to the following text which I copied from <a href=\"https://stackoverflow.com/a/8775296/459615\">this answer</a> that itself takes from the C++ standard in 14.5.7 [temp.alias] paragraph 2:</p>\n<blockquote>\n<p id=\"so_31225888_35571258_0\">When a template-id refers to the specialization of an alias template,\n  it is equivalent to the associated type obtained by substitution of\n  its template-arguments for the template-parameters in the type-id of\n  the alias template. <strong>[ Note: An alias template name is never deduced. \u2014\n  end note ]</strong></p>\n</blockquote>\n<p>If I'm interpreting that right, it means that GCC accepting the code is actually non-conforming.</p>\n", "OwnerUserId": "459615", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:33.607", "Id": "35571258", "Score": "1", "CreationDate": "2016-02-23T07:26:16.743", "LastActivityDate": "2016-02-23T07:26:16.743"}});