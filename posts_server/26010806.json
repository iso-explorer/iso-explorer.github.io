post_cb({"26011082": {"ParentId": "26010806", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It has little to do with rank of the type defined in 4.13. 4.13 defined internal rankings used to describe integral promotions and usual arithmetic conversions. They by itself do not directly affect overload resolution. Rankings relevant to overload resolution are defined in \"13.3.3.1.1 Standard conversion sequences\" and then used in \"13.3.3.2 Ranking implicit conversion sequences\".</p>\n<p>So, it is about rank of the conversion as defined under 13.3. <code>123456789</code> is an integer literal of type <code>int</code> on your platform. This means that calling both <code>char</code> and <code>unsigned long</code> versions of your function requires an implicit conversion from <code>int</code> to <code>char</code> or from <code>int</code> to <code>unsigned long</code>. In both cases we have conversions of \"integral conversion\" type. That means that both functions are equally \"bad\" in this case. Hence the ambiguity.</p>\n<p>If one of these functions required a mere integral <em>promotion</em> (as opposed to integral <em>conversion</em>), it would win the resolution and the call would be considered unambiguous. But alas both of your functions require integral <em>conversions</em>.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2014-09-25T14:27:49.767", "Id": "26011082", "Score": "51", "CreationDate": "2014-09-24T07:32:19.083", "LastActivityDate": "2014-09-25T14:27:49.767"}, "26010806": {"CommentCount": "6", "ViewCount": "1913", "PostTypeId": "1", "LastEditorUserId": "1593860", "CreationDate": "2014-09-24T07:16:41.080", "LastActivityDate": "2014-09-25T14:27:49.767", "Title": "Why is this function call ambiguous?", "FavoriteCount": "3", "LastEditDate": "2014-09-24T12:14:20.993", "Id": "26010806", "Score": "32", "Body": "<p>I'm reading the standard and trying to figure out why this code won't be resolved without a cast. </p>\n<pre><code>void foo(char c) { }\n\n// Way bigger than char\nvoid foo(unsigned long int) { }\n\nint main()\n{\n   foo(123456789); // ambiguous\n   foo((unsigned long int) 123456789); // works\n}\n</code></pre>\n<p>Here's what it says:</p>\n<blockquote>\n<p id=\"so_26010806_26010806_0\">4.13 Integer conversion rank [conv.rank]</p>\n<p id=\"so_26010806_26010806_1\">Every integer type has an integer conversion rank defined\n  as follows: </p>\n<p id=\"so_26010806_26010806_2\">\u2014 The rank of any unsigned integer type shall equal the rank of the\n  corresponding signed integer type. </p>\n<p id=\"so_26010806_26010806_3\">\u2014 The rank of char shall equal the rank of signed char and unsigned\n  char.</p>\n</blockquote>\n<p>In particular, what rustles my jimmies is that it doesn't say ANY unsigned integral type, just unsigned char. My guess is that char is being promoted to an unsigned type via conversion. Is this true?</p>\n", "Tags": "<c++><integer><implicit-conversion><unsigned-integer><integer-promotion>", "OwnerUserId": "4073503", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26010806_26010806_2": {"section_id": 45, "quality": 0.9090909090909091, "length": 10}, "so_26010806_26010806_3": {"section_id": 45, "quality": 0.8888888888888888, "length": 8}, "so_26010806_26010806_1": {"section_id": 45, "quality": 0.875, "length": 7}}, "n3337": {"so_26010806_26010806_2": {"section_id": 42, "quality": 0.9090909090909091, "length": 10}, "so_26010806_26010806_3": {"section_id": 42, "quality": 0.8888888888888888, "length": 8}, "so_26010806_26010806_1": {"section_id": 42, "quality": 0.875, "length": 7}}, "n4659": {"so_26010806_26010806_2": {"section_id": 46, "quality": 0.9090909090909091, "length": 10}, "so_26010806_26010806_3": {"section_id": 46, "quality": 0.8888888888888888, "length": 8}, "so_26010806_26010806_1": {"section_id": 46, "quality": 0.875, "length": 7}}}});