post_cb({"8720425": {"ViewCount": "4861", "Body": "<p>5.3.4 <code>[expr.new]</code> of the C++11 Feb draft gives the example: </p>\n<blockquote>\n<p id=\"so_8720425_8720425_0\"><code>new(2,f) T[5]</code> results in a call of <code>operator new[](sizeof(T)*5+y,2,f)</code>.</p>\n<p id=\"so_8720425_8720425_1\">Here, x and y are non-negative unspecified values representing array allocation overhead; the result of the <em>new-expression</em> will be offset by this amount from the value returned by <code>operator new[]</code>. This overhead may be applied in all array <em>new-expressions</em>, including those referencing the library function <code>operator new[](std::size_t, void*)</code> and other placement allocation functions. The amount of overhead may vary from one invocation of new to another. <em>\u2014end example</em> ]</p>\n</blockquote>\n<p>Now take the following example code:</p>\n<pre><code>void* buffer = malloc(sizeof(std::string) * 10);\nstd::string* p = ::new (buffer) std::string[10];\n</code></pre>\n<p>According to the above quote, the second line <code>new (buffer) std::string[10]</code> will internally call <code>operator new[](sizeof(std::string) * 10 + y, buffer)</code> (before constructing the individual <code>std::string</code> objects). The problem is that if <code>y &gt; 0</code>, the pre-allocated buffer will be too small!</p>\n<p>So how do I know how much memory to pre-allocate when using array placement-new?</p>\n<pre><code>void* buffer = malloc(sizeof(std::string) * 10 + how_much_additional_space);\nstd::string* p = ::new (buffer) std::string[10];\n</code></pre>\n<p>Or does the standard somewhere guarantee that <code>y == 0</code> in this case? Again, the quote says:</p>\n<blockquote>\n<p id=\"so_8720425_8720425_2\">This overhead may be applied in all array <em>new-expressions</em>, including those referencing the library function <code>operator new[](std::size_t, void*)</code> and other placement allocation functions. </p>\n</blockquote>\n", "AcceptedAnswerId": "8721932", "Title": "Array placement-new requires unspecified overhead in the buffer?", "CreationDate": "2012-01-04T00:03:39.807", "Id": "8720425", "CommentCount": "13", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2012-01-04T03:02:47.703", "LastEditorUserId": "46642", "LastActivityDate": "2016-04-26T03:51:51.500", "Score": "55", "OwnerUserId": "845092", "Tags": "<c++><memory-management><standards><placement-new>", "AnswerCount": "6"}, "8720442": {"Id": "8720442", "PostTypeId": "2", "Body": "<p><strong>Update:</strong> After some discussion, I understand that my answer no longer applies to the question. I'll leave it here, but a real answer is definitely still called for.</p>\n<p>I'll be happy to support this question with some bounty if a good answer isn't found soon.</p>\n<p>I'll restate the question here as far as I understand it, hoping that a shorter version might help others understand what's being asked. The question is:</p>\n<p>Is the following construction always correct? Is <code>arr == addr</code> at the end?</p>\n<pre><code>void * addr = std::malloc(N * sizeof(T));\nT * arr = ::new (addr) T[N];                // #1\n</code></pre>\n<p>We know from the standard that #1 causes the call <code>::operator new[](???, addr)</code>, where <code>???</code> is an unspecified number no smaller than <code>N * sizeof(T)</code>, and we also know that that call only returns <code>addr</code> and has no other effects. We also know that <code>arr</code> is offset from <code>addr</code> correspondingly. What we do <em>not</em> know is whether the memory pointed to by <code>addr</code> is sufficiently large, or how we would know how much memory to allocate.</p>\n<hr>\n<p>You seem to confuse a few things:</p>\n<ol>\n<li><p>Your example calls <code>operator new[]()</code>, not <s><code>operator new()</code></s>.</p></li>\n<li><p>The allocation functions <em>do not construct</em> anything. They <em>allocate</em>.</p></li>\n</ol>\n<p>What happens is that the <strong>expression</strong> <code>T * p = new T[10];</code> causes:</p>\n<ol>\n<li><p>a call to <code>operator new[]()</code> with size argument <code>10 * sizeof(T) + x</code>,</p></li>\n<li><p>ten calls to the default constructor of <code>T</code>, effectively <code>::new (p + i) T()</code>.</p></li>\n</ol>\n<p>The only peculiarity is that the array-new <em>expression</em> asks for more memory than what is used by the array data itself. You don't see any of this and cannot make use of this information in any way other than by silent acceptance.</p>\n<hr>\n<p>If you are curious how much memory was actually allocated, you can simply replace the array allocation functions <code>operator new[]</code> and <code>operator delete[]</code> and make it print out the actual size.</p>\n<hr>\n<p><em>Update:</em> As a random piece of information, you should note that the global placement-new <strong>functions</strong> are required to be no-ops. That is, when you construct an object or array in-place like so:</p>\n<pre><code>T * p = ::new (buf1) T;\nT * arr = ::new (buf10) T[10];\n</code></pre>\n<p>Then the corresponding calls to <code>::operator new(std::size_t, void*)</code> and <code>::operator new[](std::size_t, void*)</code> do nothing but return their second argument. However, you do not know what <code>buf10</code> is supposed to point to: It needs to point to <code>10 * sizeof(T) + y</code> bytes of memory, but you cannot know <code>y</code>.</p>\n</hr></hr></hr>", "LastEditorUserId": "596781", "LastActivityDate": "2013-06-02T13:08:52.897", "Score": "7", "CreationDate": "2012-01-04T00:05:11.347", "ParentId": "8720425", "CommentCount": "10", "OwnerUserId": "596781", "LastEditDate": "2013-06-02T13:08:52.897"}, "8722630": {"Id": "8722630", "PostTypeId": "2", "Body": "<p>Calling any version of <code>operator new[] ()</code> won't work too well with a fixed size memory area. Essentially, it is assumed that it delegates to some real memory allocation function rather than just returning a pointer to the allocated memory. If you already have a memory arena where you want to construct an array of objects, you want to use <code>std::uninitialized_fill()</code> or <code>std::uninitialized_copy()</code> to construct the objects (or some other form of individually constructing the objects).</p>\n<p>You might argue that this means that you have to destroy the objects in your memory arena manually as well. However, calling <code>delete[] array</code> on the pointer returned from the placement <code>new</code> won't work: it would use the non-placement version of <code>operator delete[] ()</code>! That is, when using placement <code>new</code> you need to manually destroy the object(s) and release the memory. </p>\n", "LastActivityDate": "2012-01-04T05:58:38.167", "CommentCount": "5", "CreationDate": "2012-01-04T05:58:38.167", "ParentId": "8720425", "Score": "6", "OwnerUserId": "1120273"}, "bq_ids": {"n4140": {"so_8720425_8720425_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6095}, "so_8720425_36854950_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6095}, "so_8720425_36854950_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6095}, "so_8720425_8720425_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 6095}, "so_8720425_8720425_0": {"length": 5, "quality": 1.0, "section_id": 6095}, "so_8720425_8735297_0": {"length": 37, "quality": 0.8222222222222222, "section_id": 6082}}, "n3337": {"so_8720425_8720425_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5861}, "so_8720425_36854950_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5861}, "so_8720425_36854950_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5861}, "so_8720425_8720425_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 5861}, "so_8720425_8720425_0": {"length": 5, "quality": 1.0, "section_id": 5861}, "so_8720425_8735297_0": {"length": 37, "quality": 0.8222222222222222, "section_id": 5850}}, "n4659": {"so_8720425_8720425_1": {"length": 42, "quality": 0.8936170212765957, "section_id": 7592}, "so_8720425_8720425_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 7592}, "so_8720425_36854950_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 7592}, "so_8720425_36854950_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7592}, "so_8720425_8735297_0": {"length": 34, "quality": 0.7555555555555555, "section_id": 7578}}}, "8735297": {"Id": "8735297", "PostTypeId": "2", "Body": "<p>After reading corresponding standard sections I am satarting to think that placement new for array types is simply useless idea, and the only reason for it being allowed by standard is generic way in which new-operator is described:</p>\n<blockquote>\n<p id=\"so_8720425_8735297_0\">The new expression attempts to create an object of the typeid (8.1) or\n  newtypeid to which it is applied. The type of that object is the\n  allocated type. This type shall be a complete object type, but not an\n  abstract class type or array thereof (1.8, 3.9, 10.4). [Note: because\n  references are not objects, references cannot be created by\n  newexpressions. ] [Note: the typeid may be a cvqualified type, in\n  which case the object created by the newexpression has a cvqualified\n  type. ]</p>\n</blockquote>\n<pre><code>new-expression: \n    ::(opt) new new-placement(opt) new-type-id new-initializer(opt)\n    ::(opt) new new-placement(opt) ( type-id ) new-initializer(opt)\n\nnew-placement: ( expression-list )\n\nnewtypeid:\n    type-specifier-seq new-declarator(opt)\n\nnew-declarator:\n    ptr-operator new-declarator(opt)\n    direct-new-declarator\n\ndirect-new-declarator:\n    [ expression ]\n    direct-new-declarator [ constant-expression ]\n\nnew-initializer: ( expression-list(opt) )\n</code></pre>\n<p>To me it seems that <code>array placement new</code> simply stems from compactness of the definition (all possible uses as one scheme), and it seems there is no good reason for it to be forbidden.</p>\n<p>This leaves us in a situation where we have useless operator, which needs memory allocated before it is known how much of it will be needed. The only solutions I see would be to either overallocate memory and hope that compiler will not want more than supplied, or re-allocate memory in overriden <code>array placement new</code> function/method (which rather defeats the purpose of using <code>array placement new</code> in the first place).</p>\n<hr>\n<p>To answer question pointed out by Kerrek SB:\nYour example:</p>\n<pre><code>void * addr = std::malloc(N * sizeof(T));\nT * arr = ::new (addr) T[N];                // #1\n</code></pre>\n<p>is not always correct. In most implementations <code>arr!=addr</code> (and there are good reasons for it) so your code is not valid, and your buffer will be overrun.</p>\n<p>About those \"good reasons\" - note that you are released by standard creators from some house-keeping when using <code>array new</code> operator, and <code>array placement new</code> is no different in this respect. Note that you do not need to inform <code>delete[]</code> about length of array, so this information must be kept in the array itself. Where? Exactly in this extra memory. Without it <code>delete[]</code>'ing would require keeping array length separate (as stl does using loops and non-placement <code>new</code>)</p>\n</hr>", "LastActivityDate": "2012-01-04T22:54:54.663", "CommentCount": "3", "CreationDate": "2012-01-04T22:54:54.663", "ParentId": "8720425", "Score": "1", "OwnerUserId": "455304"}, "8721932": {"Id": "8721932", "PostTypeId": "2", "Body": "<p>Don't use <code>operator new[](std::size_t, void* p)</code> unless you know a-priori the answer to this question.  The answer is an implementation detail and can change with compiler/platform.  Though it is typically stable for any given platform.  E.g. this is something specified by the <a href=\"http://sourcery.mentor.com/public/cxx-abi/\" rel=\"noreferrer\">Itanium ABI</a>.</p>\n<p>If you don't know the answer to this question, write your own placement array new that can check this at run time:</p>\n<pre><code>inline\nvoid*\noperator new[](std::size_t n, void* p, std::size_t limit)\n{\n    if (n &lt;= limit)\n        std::cout &lt;&lt; \"life is good\\n\";\n    else\n        throw std::bad_alloc();\n    return p;\n}\n\nint main()\n{\n    alignas(std::string) char buffer[100];\n    std::string* p = new(buffer, sizeof(buffer)) std::string[3];\n}\n</code></pre>\n<p>By varying the array size and inspecting <code>n</code> in the example above, you can infer <code>y</code> for your platform.  For <a href=\"http://sourcery.mentor.com/public/cxx-abi/\" rel=\"noreferrer\">my platform</a> <code>y</code> is 1 word.  The sizeof(word) varies depending on whether I'm compiling for a 32 bit or 64 bit architecture. </p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2012-01-05T02:07:07.717", "Score": "35", "CreationDate": "2012-01-04T04:13:38.313", "ParentId": "8720425", "CommentCount": "12", "OwnerUserId": "576911", "LastEditDate": "2012-01-05T02:07:07.717"}, "35926866": {"Id": "35926866", "PostTypeId": "2", "Body": "<p>As mentioned by Kerrek SB in comments, this defect was first reported <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#476\" rel=\"nofollow\">in 2004</a>, and it was resolved in 2012 as:</p>\n<blockquote>\n<p id=\"so_8720425_35926866_0\">The CWG agreed that EWG is the appropriate venue for dealing with this issue.</p>\n</blockquote>\n<p>Then the defect was <a href=\"https://cplusplus.github.io/EWG/ewg-closed.html#68\" rel=\"nofollow\">reported to EWG in 2013</a>, but closed as NAD  (presumably means \"Not A Defect\") with the comment:</p>\n<blockquote>\n<p id=\"so_8720425_35926866_1\">The problem is in trying to use array new to put an array into pre-existing storage. We don't need to use array new for that; just construct them.</p>\n</blockquote>\n<p>which presumably means that the suggested workaround is to use a loop with a call to non-array placement new once for each object being constructed.</p>\n<hr>\n<p>A corollary not mentioned elsewhere on the thread is that this code causes undefined behaviour for all <code>T</code>:</p>\n<pre><code>T *ptr = new T[N];\n::operator delete[](ptr);\n</code></pre>\n<p>Even if we comply with the lifetime rules (i.e. <code>T</code> either has trivial destruction, or the program does not depend on the destructor's side-effects), the problem is that <code>ptr</code> has been adjusted for this unspecified cookie, so it is the wrong value to pass to <code>operator delete[]</code>.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2016-04-14T22:39:42.257", "Score": "2", "CreationDate": "2016-03-10T20:42:35.983", "ParentId": "8720425", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2016-04-14T22:39:42.257"}, "36854950": {"Id": "36854950", "PostTypeId": "2", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_8720425_36854950_1\">This overhead may be applied in all array <em>new-expressions</em>, including those referencing the library function <code>operator new[](std::size_t, void*)</code> and other placement allocation functions. </p>\n</blockquote>\n</blockquote>\n<p>This is a defect in the standard. Rumor has it <a href=\"http://wg21.cmeerw.net/cwg/issue476\" rel=\"nofollow\">they couldn't find a volunteer to write an exception to it</a> (Message #1165).</p>\n<p>The <strong>non-replaceable array placement-new</strong> cannot be used with <code>delete[]</code> expressions, so you need to <strong>loop through the array and call each destructor</strong>.</p>\n<p>The overhead is targetted at the <strong>user-defined array placement-new</strong> functions, which allocate memory just like the regular <code>T* tp = new T[length]</code>. Those are compatible with <code>delete[]</code>, hence the overhead that carries the array length.</p>\n", "LastActivityDate": "2016-04-26T03:51:51.500", "CommentCount": "0", "CreationDate": "2016-04-26T03:51:51.500", "ParentId": "8720425", "Score": "0", "OwnerUserId": "2748628"}});