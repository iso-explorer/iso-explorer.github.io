post_cb({"18311885": {"Id": "18311885", "PostTypeId": "2", "Body": "<p>Seem templates in the inner namespace hide the names of the outer.</p>\n<pre><code>template&lt;int i&gt;\nstruct A\n{\n    static const int value = 0;\n};\n\nstruct B\n{\n    static const int value = 0;\n};\n\ntypedef A&lt;0&gt; C;\n\n\nnamespace N\n{\n    // The local function A is not declaced, yet, but the global A is:\n    int early_e = A&lt;3&gt;::value; // Ok: The A in the global namespace. [simple-template-id}\n\n    template&lt;int i&gt;\n    int A() { return 0; }\n    int B() { return 0; }\n    int C() { return 0; }\n\n    int a = A&lt;3&gt;();        // Ok: The A in the namespace. [simple-template-id}\n    int b = N::A&lt;3&gt;();     // Ok: The A in the namespace. [N::simple-template-id]\n    int c = ::N::A&lt;3&gt;();   // Ok: The A in the namespace. [::N::simple-template-id]\n    int d = ::A&lt;3&gt;::value; // Ok: The A in the global namespace. ::simple-template-id::identifier]\n    // The local function A is no type: \"templates whose specializations are types\"\n    int e = A&lt;3&gt;::value;   // Error: The namespace has the function name A,\n                           // which hides the global A. [simple-template-id::identifier]\n    // The local function B is no type, but the global B is a type:\n    int f = B::value;      // Ok: The B in the global namespace. [class-name::identifier]\n    // The local function C is no type, but the global typedef C is a type:\n    int g = C::value;      // Ok: The C in the global namespace. [typedef-name::identifier]\n}\n\nint main() {\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "2249683", "LastActivityDate": "2013-08-19T17:11:11.407", "Score": "3", "CreationDate": "2013-08-19T10:43:52.563", "ParentId": "18311496", "CommentCount": "3", "LastEditDate": "2013-08-19T17:11:11.407", "OwnerUserId": "2249683"}, "bq_ids": {"n4140": {"so_18311496_18311496_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 7107}, "so_18311496_18311496_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 70}, "so_18311496_18311496_4": {"length": 23, "quality": 1.0, "section_id": 71}}, "n3337": {"so_18311496_18311496_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 6851}, "so_18311496_18311496_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 65}, "so_18311496_18311496_4": {"length": 23, "quality": 1.0, "section_id": 66}}, "n4659": {"so_18311496_18311496_1": {"length": 44, "quality": 0.9777777777777777, "section_id": 8608}, "so_18311496_18311496_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 72}, "so_18311496_18311496_4": {"length": 23, "quality": 1.0, "section_id": 73}}}, "18311496": {"ViewCount": "602", "Body": "<p>Both clang and gcc reject this code:</p>\n<pre><code>template&lt;int i&gt;\nstruct ambiguous\n{\n    static const int value = i;\n};\n\nnamespace N\n{\n    template&lt;int i&gt;\n    void ambiguous();\n\n    int i = ambiguous&lt;3&gt;::value; // finds the function template name\n}\n</code></pre>\n<p>However, they both accept the following code:</p>\n<pre><code>struct ambiguous\n{\n    static const int value = 0;\n};\n\nnamespace N\n{\n    void ambiguous();\n\n    int i = ambiguous::value;\n}\n</code></pre>\n<p>The standard says that name lookup of a name preceding <code>::</code> \"considers only namespaces, types, and templates whose specializations are types\". Are clang and gcc correct in rejecting this code? If so, what am I missing?</p>\n<p>From C++ Working Draft Standard n3337</p>\n<blockquote>\n<p id=\"so_18311496_18311496_0\">3.4.3 Qualified name lookup [basic.lookup.qual]</p>\n<p id=\"so_18311496_18311496_1\">The name of a class or namespace member or enumerator can be referred to after the :: scope resolution\n  operator (5.1) applied to a nested-name-specifier that denotes its class, namespace, or enumeration. If a ::\n  scope resolution operator in a nested-name-specifier is not preceded by a decltype-specifier, <strong>lookup of the\n  name preceding that :: considers only namespaces, types, and templates whose specializations are types</strong>.\n  If the name found does not designate a namespace or a class, enumeration, or dependent type, the program\n  is ill-formed.</p>\n<p id=\"so_18311496_18311496_2\">14.2 Names of template specializations [temp.names]</p>\n<p id=\"so_18311496_18311496_3\">For a template-name to be explicitly qualified by the template arguments, <strong>the name must be known to refer\n  to a template</strong>.</p>\n<p id=\"so_18311496_18311496_4\"><strong>After name lookup (3.4) finds that a name is a template-name</strong> or that an operator-function-id or a literal-operator-id refers to a set of overloaded functions any member of which is a function template <strong>if this is\n  followed by a <code>&lt;</code>, the <code>&lt;</code> is always taken as the delimiter of a template-argument-list and never as the less-than\n  operator</strong>.</p>\n</blockquote>\n<h3>Edit</h3>\n<p>To avoid confusion of this issue with the ambiguity between an expression and a declaration, here is the original code with the templates using a type parameter instead of a non-type parameter. </p>\n<pre><code>template&lt;class&gt;\nstruct ambiguous\n{\n    static const int value = 0;\n};\n\nnamespace N\n{\n    template&lt;class&gt;\n    void ambiguous();\n\n    int i = ambiguous&lt;int&gt;::value; // finds the function template name\n}\n</code></pre>\n<p>This results in the same error in all cases. The <code>&lt;</code> cannot be interpreted as an operator. </p>\n<p><code>ambiguous</code> is unambiguously a template-name, but could either be a type or a function. It's possible to parse the entire template-id without knowing whether it names a function or a type, and resolve the ambiguity later on. Does the standard excuse the implementor from doing this?</p>\n", "Title": "Should the name of a function template be visible during lookup of a name preceding ::?", "CreationDate": "2013-08-19T10:24:54.713", "LastActivityDate": "2013-08-19T17:11:11.407", "CommentCount": "10", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-08-19T13:19:38.050", "LastEditorUserId": "1690864", "Id": "18311496", "Score": "8", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "2"}, "18311813": {"Id": "18311813", "PostTypeId": "2", "Body": "<p>The problem is that the paragraph you quote ends up being\napplied too late.  Before getting there, the compiler must\ndetermine that in <code>ambiguous&lt;3&gt;::value</code>, the <code>&lt;</code> and <code>&gt;</code> are\ntemplate argument delimiters, and not greater than and less\nthan.  (Consider:  </p>\n<pre><code>int ambiguous;\nint value:\n//  ...\nint i = ambiguous&lt;3&gt;::value;\n</code></pre>\n<p>, which parses as <code>(ambiguous &lt; 3) &gt; ::value</code>, where the <code>&lt;</code> and\n<code>&gt;</code> are less than and greater than, respectively.)  This\ninvolves a lookup of <code>ambiguous</code> as an unqualified name, and\nbinds the symbol to <code>N::ambiguous</code>.  Afterwards, you're stuck\nwith the instantiated template <code>N::ambiguous&lt;3&gt;</code> to the left of\n<code>::</code>, which isn't legal.</p>\n<h2>EDIT:</h2>\n<p>This issue isn't as clear as one might like: the standard only\nrefers to section 3.4 in section 14.2, where it discusses this,\nand section 3.4 discusses all of the possible rules of name\nlookup.  On the other hand, there is really only one way to\ninterpret it: the compiler <em>cannot</em> parse anything further until\nit knows whether <code>ambiguous</code> names a template or not, and can\ndecide whether the following <code>&lt;</code> is greater than, or opens\na template argument list.  And of course, it cannot \"rebind\" the\nargument later, once it has parsed the following tokens, since\nin the general case, rebinding could change the meaning of the\n<code>&lt;</code>, invalidating the parse.  In practice, although the standard\ndoesn't say so as clearly as it probably should, the name lookup\nin this case must be unqualified name lookup (or class member\naccess, if the name is preceded by a <code>.</code> or a <code>-&gt;</code> operator).</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2013-08-19T10:50:24.817", "Score": "8", "CreationDate": "2013-08-19T10:40:37.677", "ParentId": "18311496", "CommentCount": "12", "LastEditDate": "2013-08-19T10:50:24.817", "OwnerUserId": "649665"}});