post_cb({"bq_ids": {"n4140": {"so_26692637_26692775_6": {"length": 22, "quality": 1.0, "section_id": 5453}, "so_26692637_26692775_3": {"length": 6, "quality": 0.6, "section_id": 0}, "so_26692637_26692775_5": {"length": 12, "quality": 0.8571428571428571, "section_id": 5963}}, "n3337": {"so_26692637_26692775_0": {"length": 14, "quality": 1.0, "section_id": 5732}, "so_26692637_26692775_3": {"length": 10, "quality": 1.0, "section_id": 5732}}, "n4659": {"so_26692637_26692775_6": {"length": 22, "quality": 1.0, "section_id": 6879}, "so_26692637_26692775_3": {"length": 7, "quality": 0.7, "section_id": 7667}, "so_26692637_26692775_5": {"length": 12, "quality": 0.8571428571428571, "section_id": 7450}}}, "26692712": {"Id": "26692712", "PostTypeId": "2", "Body": "<p>It works with your example because all the <code>return</code> statements return values of the same type. But try changing the second <code>return</code> to a different type, for example:</p>\n<pre><code>auto f = [] (bool c1, bool c2) {\n    if (c1) return 1;\n    if (c2) return \"\";\n    else    return 3;\n};\n</code></pre>\n<p>Compiling this with clang++ yields the following error:</p>\n<pre><code>main.cpp:3:13: error: return type 'const char *' must match previous return type 'int' when lambda expression has unspecified explicit\n      return type\n    if (c2) return \"\";\n        ^\n1 error generated.\n</code></pre>\n", "LastActivityDate": "2014-11-01T20:07:47.433", "CommentCount": "3", "CreationDate": "2014-11-01T20:07:47.433", "ParentId": "26692637", "Score": "3", "OwnerUserId": "409228"}, "26692637": {"ViewCount": "665", "Body": "<p>I'm reading here on <a href=\"http://en.cppreference.com/w/cpp/language/lambda\">cppreference</a> about how a return type of a C++11 lambda is deduced:</p>\n<blockquote>\n<p id=\"so_26692637_26692637_0\">if the body consists of the single <code>return</code> statement, the return type is the type of the returned expression (after rvalue-to-lvalue, array-to-pointer, or function-to-pointer implicit conversion)</p>\n</blockquote>\n<p>So I think that means that a lambda can only have one return statement. But why does it work with multiple return statements still?</p>\n<p>This <a href=\"http://coliru.stacked-crooked.com/a/8276a87f293b96da\">compiles</a> on both compilers:</p>\n<pre><code>auto f = [] (bool c1, bool c2) {\n    if (c1) return 1;\n    if (c2) return 2;\n    else    return 3;\n};\n</code></pre>\n", "AcceptedAnswerId": "26692775", "Title": "C++11 restrictions on lambda return type", "CreationDate": "2014-11-01T20:00:52.123", "Id": "26692637", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-18T10:10:06.097", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T10:10:06.097", "Score": "10", "OwnerUserId": "1594090", "Tags": "<c++><c++11><lambda><return><language-lawyer>", "AnswerCount": "2"}, "26692775": {"Id": "26692775", "PostTypeId": "2", "Body": "<p>That is slightly imprecise. [expr.prim.lambda]/4:</p>\n<blockquote>\n<p id=\"so_26692637_26692775_0\">If a <em>lambda-expression</em> does not include a <em>lambda-declarator</em>, it is\n  as if the <em>lambda-declarator</em> were <code>()</code>. If a <em>lambda-expression</em> does\n  not include a <em>trailing-return-type</em>, it is as if the\n  trailing-return-type denotes the following type:</p>\n<ul>\n<li><p id=\"so_26692637_26692775_1\">if the compound-statement is of the form</p>\n<p id=\"so_26692637_26692775_2\"><code>{</code> <em>attribute-specifier-seq</em><sub><em>opt</em></sub><code>return</code> <em>expression</em> <code>; }</code></p>\n<p id=\"so_26692637_26692775_3\">the type of the returned expression after lvalue-to-rvalue\n  conversion (4.1), array-to-pointer conversion (4.2), and\n  function-to-pointer conversion (4.3);</p></li>\n<li><p id=\"so_26692637_26692775_4\">otherwise, <code>void</code>.</p></li>\n</ul>\n</blockquote>\n<p>So the return type is only deduced if the whole body of the lambda expression only consists of one sole <code>return</code> statement.<br><br> Both GCC and Clang are not standard conforming in this case as they issue an error message if and only if two <code>return</code> statements lead to inconsistent deductions. This is because they already implemented the C++14 standard which deducts the return type even with multiple <code>return</code> statements and/or multiple other statements present. [expr.prim.lambda]/4 specifies that</br></br></p>\n<blockquote>\n<p id=\"so_26692637_26692775_5\">The lambda return type is <code>auto</code>, which is replaced by the\n  <em>trailing-return-type</em> if provided <strong>and/or deduced from <code>return</code> statements as described in 7.1.6.4</strong>.</p>\n</blockquote>\n<p>\u00a77.1.6.4/9</p>\n<blockquote>\n<p id=\"so_26692637_26692775_6\">If a function with a declared return type that contains a placeholder\n  type has multiple <code>return</code> statements, the return type is deduced for\n  each <code>return</code> statement. If the type deduced is not the same in each\n  deduction, the program is ill-formed.</p>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-01T20:32:48.803", "Score": "13", "CreationDate": "2014-11-01T20:13:38.493", "ParentId": "26692637", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2014-11-01T20:32:48.803"}});