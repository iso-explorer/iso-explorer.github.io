post_cb({"8070291": {"Id": "8070291", "PostTypeId": "2", "Body": "<p>The <code>class Bar</code> construct is erroneous. Are you, by any chance, a C programmer who didn't use <code>typedef struct { /* members */ } Foo</code>?</p>\n<p>Anywho, you need to define both Bar and Baz inside test:</p>\n<pre><code>namespace Test {\n    class Bar;\n    class Baz;\n};\n</code></pre>\n<p>And remove <code>class</code>, <code>struct</code>, <code>union</code>, and <code>enum</code> keywords when declaring function parameters.</p>\n<p>With that modification, it compiles cleanly in g++4.6.</p>\n", "LastActivityDate": "2011-11-09T19:16:01.583", "CommentCount": "7", "CreationDate": "2011-11-09T19:16:01.583", "ParentId": "8070233", "Score": "-2", "OwnerUserId": "982617"}, "8070322": {"Id": "8070322", "PostTypeId": "2", "Body": "<p><strike>Well, I tried it in <a href=\"http://codepad.org/Ka2sUJkC\" rel=\"nofollow\">codepad.org</a> too and it compiles, but I'm not sure it should (not THAT proficient in C++ compiler functionality)! \n</strike></p>\n<p><strong>Workaround:</strong> forward declare <code>Bar</code> as well or you have to define <code>Bar</code> before you make <code>Foo</code>. In other words, this compiles in MSVC:</p>\n<pre><code>namespace Test \n{ \n    class Baz;\n    class Bar;// also forward-declare Bar\n    void Foo (Baz&amp; b, class Bar&amp; c);\n}\n\nnamespace Test \n{ \n    class Bar\n    {\n        template &lt;typename T&gt;\n        static void Foo ()\n        {\n        }\n    };\n}\n\nint main(void)\n{\n\n    return 0;\n}\n</code></pre>\n<p><strong>Update:</strong>\nI think that this might already be a bug reported to Microsoft... this looks pretty close: <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/99218/invalid-error-c2888-when-a-class-is-defined-after-it-is-declared\" rel=\"nofollow\">http://connect.microsoft.com/VisualStudio/feedback/details/99218/invalid-error-c2888-when-a-class-is-defined-after-it-is-declared</a></p>\n<p>The workaround cited by Microsoft:</p>\n<pre><code>A stand-alone forward declaration consists of an elaborated type specifier followed by a semicolon.\n\ninsert the declaration\n\nclass C2888;\n\nbefore the declaration of foo(C2888o, C2888). \n</code></pre>\n", "LastEditorUserId": "28760", "LastActivityDate": "2011-11-09T19:45:13.667", "Score": "2", "CreationDate": "2011-11-09T19:18:28.353", "ParentId": "8070233", "CommentCount": "3", "OwnerUserId": "28760", "LastEditDate": "2011-11-09T19:45:13.667"}, "8070789": {"Id": "8070789", "PostTypeId": "2", "Body": "<p>I think the code is well-formed.  But proving that for certain would require making sure there's nothing in the Standard that contradicts the usage.</p>\n<p>Some relevant quotes from the C++11 Standard:</p>\n<p>3.3.2 p6:</p>\n<blockquote>\n<p id=\"so_8070233_8070789_0\">The point of declaration of a class first declared in an <em>elaborated-type-specifier</em> is as follows:</p>\n</blockquote>\n<ul>\n<li>for an <em>elaborated-type-specifier</em> of the form <em>class-key identifier</em>\n<ul>\n<li>if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a\nfunction defined in namespace scope, the <em>identifier</em> is declared as a <em>class-name</em> in the namespace that\ncontains the declaration; otherwise, except as a friend declaration, the <em>identifier</em> is declared in the\nsmallest non-class, non-function-prototype scope that contains the declaration.</li>\n</ul></li>\n</ul>\n<p>3.4.4 p2:</p>\n<blockquote>\n<p id=\"so_8070233_8070789_1\">If the <em>elaborated-type-specifier</em> has no <em>nested-name-specifier</em>, and unless the elaborated-type-specifier appears in a declaration with the following form:\n  <em>class-key attribute-specifier-seq opt identifier</em> <code>;</code>\n  the <em>identifier</em> is looked up according to 3.4.1 but ignoring any non-type names that have been declared. ... If the <em>elaborated-type-specifier</em> is introduced by\n  the <em>class-key</em> and this lookup does not find a previously declared <em>type-name</em>, or if the <em>elaborated-type-specifier</em>\n  appears in a declaration with the form:\n  <em>class-key attribute-specifier-seq opt identifier</em> <code>;</code>\n  the <em>elaborated-type-specifier</em> is a <em>declaration</em> that introduces the <em>class-name</em> as described in 3.3.2.</p>\n</blockquote>\n<p>7.1.6 has some syntax definitions establishing that an <em>elaborated-type-specifier</em> can syntactically be a <em>type-specifier</em>.  7.1 establishes that a <em>type-specifier</em> can syntactically be a <em>decl-specifier</em>, which is the syntactical unit used as the type in a function <em>parameter-declaration</em> (8.3.5).</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2011-11-09T20:07:06.620", "Score": "1", "CreationDate": "2011-11-09T19:55:57.490", "ParentId": "8070233", "CommentCount": "0", "OwnerUserId": "459640", "LastEditDate": "2011-11-09T20:07:06.620"}, "8070541": {"Id": "8070541", "PostTypeId": "2", "Body": "<p>Probably it is a compiler bug.</p>\n<p>Changing the order of parameters will change the compilation result.</p>\n<pre><code>namespace Test { \nvoid Foo (class Bar&amp; b, class Baz&amp; c) - will compile.\n}\n</code></pre>\n", "LastActivityDate": "2011-11-09T19:34:34.547", "CommentCount": "0", "CreationDate": "2011-11-09T19:34:34.547", "ParentId": "8070233", "Score": "1", "OwnerUserId": "1037662"}, "bq_ids": {"n4140": {"so_8070233_8070789_0": {"length": 7, "quality": 0.875, "section_id": 7055}, "so_8070233_8070789_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 7124}}, "n3337": {"so_8070233_8070789_0": {"length": 7, "quality": 0.875, "section_id": 6799}, "so_8070233_8070789_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 6868}}, "n4659": {"so_8070233_8070789_0": {"length": 7, "quality": 0.875, "section_id": 8552}, "so_8070233_8070789_1": {"length": 41, "quality": 0.9111111111111111, "section_id": 8625}}}, "8070233": {"ViewCount": "1276", "Body": "<p>The following snippet fails to compile with Visual Studio 2010, but GCC likes it:</p>\n<pre><code>namespace Test { \n    class Baz;\n    // Adding class Bar; here and removing the class below makes it work\n    // with VC++, but it should work like this, shouldn't it?\n    void Foo (Baz&amp; b, class Bar&amp; c);\n}\n\nnamespace Test { \n    class Bar\n    {\n        // Making this method non-template works\n        template &lt;typename T&gt;\n        static void Lalala ()\n        {\n        }\n    };\n}\n\nint main ()\n{\n}\n</code></pre>\n<p>Am I doing something stupid here or is this a valid compiler bug? The error I get is:\n<code>error C2888: 'void Bar::Foo(void)' : symbol cannot be defined within namespace 'Test'</code></p>\n<p>It compiles with GCC 4.5.1: <a href=\"http://ideone.com/7sImY\" rel=\"nofollow\">http://ideone.com/7sImY</a></p>\n<p>[Edit] Just to be clear, I want to know if this is valid C++ or not (and if so, why not) -- workarounds to get it compiled are nice but not part of this question.</p>\n", "AcceptedAnswerId": "8070789", "Title": "Forward defining class in namespace?", "CreationDate": "2011-11-09T19:11:01.340", "Id": "8070233", "CommentCount": "0", "LastEditDate": "2011-11-09T19:25:32.667", "PostTypeId": "1", "LastEditorUserId": "39912", "LastActivityDate": "2011-11-09T20:07:06.620", "Score": "3", "OwnerUserId": "39912", "Tags": "<c++><visual-c++><compiler-errors><compiler-bug>", "AnswerCount": "4"}});