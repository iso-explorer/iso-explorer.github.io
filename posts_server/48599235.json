post_cb({"bq_ids": {"n4140": {"so_48599235_48599285_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_48599235_48599285_8": {"length": 10, "quality": 0.9090909090909091, "section_id": 45}, "so_48599235_48599285_7": {"length": 23, "quality": 0.9583333333333334, "section_id": 45}, "so_48599235_48599285_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 5943}, "so_48599235_48599285_5": {"length": 8, "quality": 1.0, "section_id": 45}}, "n3337": {"so_48599235_48599285_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_48599235_48599285_8": {"length": 10, "quality": 0.9090909090909091, "section_id": 42}, "so_48599235_48599285_7": {"length": 23, "quality": 0.9583333333333334, "section_id": 42}, "so_48599235_48599285_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 5714}, "so_48599235_48599285_5": {"length": 8, "quality": 1.0, "section_id": 42}}, "n4659": {"so_48599235_48599285_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_48599235_48599285_8": {"length": 10, "quality": 0.9090909090909091, "section_id": 46}, "so_48599235_48599285_7": {"length": 23, "quality": 0.9583333333333334, "section_id": 46}, "so_48599235_48599285_3": {"length": 23, "quality": 0.9583333333333334, "section_id": 7428}, "so_48599235_48599285_5": {"length": 8, "quality": 1.0, "section_id": 46}}}, "48599285": {"Id": "48599285", "PostTypeId": "2", "Body": "<pre><code>total_weight += static_cast&lt;uint64_t&gt;(W * H * D);\n</code></pre>\n<p>Here <code>W * H * D</code> is calculated as a multiplication of <code>unsigned int</code>s and then casted to <code>uint64_t</code> which does not save you from the potential overflow while <code>W * H * D</code> is calculated.</p>\n<pre><code>total_weight += static_cast&lt;uint64_t&gt;(W) * H * D;\n</code></pre>\n<p>Here <code>static_cast&lt;uint64_t&gt;(W) * H * D</code> is calculated as a multiplication of <code>uint64_t</code>s as <code>W</code> is casted to <code>uint64_t</code> and <code>H</code>, <code>D</code> promoted to <code>uint64_t</code> as well. So there are less chances to suffer from the overflow during multiplication in this case.</p>\n<hr>\n<p>Relevant conversion rules are described as follows:</p>\n<blockquote>\n<p id=\"so_48599235_48599285_0\">8 Expressions [expr]</p>\n<p id=\"so_48599235_48599285_1\">11 Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are defined as follows:</p>\n<p id=\"so_48599235_48599285_2\">...</p>\n<p id=\"so_48599235_48599285_3\">11.5.2 Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser\n  integer conversion rank shall be converted to the type of the operand\n  with greater rank.</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_48599235_48599285_4\">7.15 Integer conversion rank [conv.rank]</p>\n<p id=\"so_48599235_48599285_5\">1 Every integer type has an integer conversion rank defined as\n  follows:</p>\n<p id=\"so_48599235_48599285_6\">...</p>\n<p id=\"so_48599235_48599285_7\">1.3 The rank of long long int shall be greater than the rank of long int, which shall be greater than the rank of int, which shall be\n  greater than the rank of short int, which shall be greater than the\n  rank of signed char.</p>\n<p id=\"so_48599235_48599285_8\">1.4 The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "5507349", "LastActivityDate": "2018-02-03T16:16:02.577", "Score": "3", "CreationDate": "2018-02-03T16:04:18.670", "ParentId": "48599235", "CommentCount": "0", "OwnerUserId": "5507349", "LastEditDate": "2018-02-03T16:16:02.577"}, "48599235": {"ViewCount": "34", "Body": "<p>I'm doing a MOOC on Coursera and this code doesn't work:</p>\n<pre><code>unsigned int W, H, D;     \nuint64_t total_weight = 0;\nfor (unsigned int i = 0; i &lt; N; ++i) {\n    cin &gt;&gt; W &gt;&gt; H &gt;&gt; D;\n    total_weight += static_cast&lt;uint64_t&gt;(W * H * D);\n}\ntotal_weight *= R;\ncout &lt;&lt; total_weight;\n</code></pre>\n<p>However, this one does:</p>\n<pre><code>unsigned int W, H, D;     \nuint64_t total_weight = 0;\nfor (unsigned int i = 0; i &lt; N; ++i) {\n    cin &gt;&gt; W &gt;&gt; H &gt;&gt; D;\n    total_weight += static_cast&lt;uint64_t&gt;(W) * H * D;\n}\ntotal_weight *= R;\ncout &lt;&lt; total_weight;\n</code></pre>\n<p>As you can see, the difference is in this line:</p>\n<pre><code>total_weight += static_cast&lt;uint64_t&gt;(W) * H * D;\n</code></pre>\n<p>How is that cast different from </p>\n<pre><code>total_weight += static_cast&lt;uint64_t&gt;(W * H * D);\n</code></pre>\n<p>?</p>\n", "AcceptedAnswerId": "48599285", "Title": "How are the two typecasts different?", "CreationDate": "2018-02-03T15:59:21.270", "Id": "48599235", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2018-02-03T16:16:02.577", "Score": "1", "OwnerUserId": "5798365", "Tags": "<c++><casting>", "AnswerCount": "1"}});