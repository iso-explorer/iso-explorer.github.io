post_cb({"18079891": {"ParentId": "18079769", "CommentCount": "13", "Body": "<p>Default assign (and copy) behaviour does not memcpy the whole class, which would break things. Each member is copied using their copy constructor or assignment operator (depending on operation). This is applied recursively for members and their members. When a basic data type is reached, it simply performs a straight copy of data, similar to memcpy. So an array of basic data types may be copied similar to memcpy, but the whole class is not. If you add std::string to your class its = operator would be called, alongside copy of array. If you used array of std::string, each string in your array will have their operator called. They won't memcpy.</p>\n", "OwnerUserId": "2068573", "PostTypeId": "2", "Id": "18079891", "Score": "2", "CreationDate": "2013-08-06T12:14:45.737", "LastActivityDate": "2013-08-06T12:14:45.737"}, "18079769": {"CommentCount": "12", "ViewCount": "1750", "PostTypeId": "1", "LastEditorUserId": "20270", "CreationDate": "2013-08-06T12:09:02.180", "LastActivityDate": "2013-08-06T13:10:49.960", "Title": "What's the c++'s default assign operation behavior?", "AcceptedAnswerId": "18080046", "LastEditDate": "2013-08-06T12:13:33.877", "Id": "18079769", "Score": "7", "Body": "<p>eg, it puzzles me:</p>\n<pre><code>struct A {\n//  some fileds...\n    char buf[SIZE];\n};\n\nA a;\na = a;\n</code></pre>\n<p>Through A's field <code>buf</code>, it looks like probably that the default assign operation will call something like <code>memcpy</code> to assign an object X to Y, so what if assign an object to itself and there are no explicit assign operation defined, like <code>a = a;</code> above.</p>\n<p>memcpy manual page:</p>\n<pre><code>DESCRIPTION\n\nThe  memcpy() function copies n bytes from memory area src to memory area dest.  The memory areas must not overlap.  Use memmove(3) if the memory areas do overlap.\n</code></pre>\n<p>If use <code>memcpy</code>, there may some undefined behavior occur.</p>\n<p>So, what's the default assign operation behavior in C++ object?</p>\n", "Tags": "<c++><assignment-operator>", "OwnerUserId": "1105178", "AnswerCount": "4"}, "18080176": {"ParentId": "18079769", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_18079769_18080176_0\">If use memcpy, there may some undefined behavior occur.</p>\n</blockquote>\n<p>It's an implementation detail how the given class will be copied. Both memcpy() function and copy constructor will be converted into some machine code. However your objects in memory should not overlap because default assignment does not guarantee you'll have a proper result in case they overlap.</p>\n<blockquote>\n<p id=\"so_18079769_18080176_1\">So, what's the default assign operation behavior in C++ object?</p>\n</blockquote>\n<p>As in other responses, the <strong>behaviour</strong> is such that it will call assignments on all class/struct members recursively. However technically, as in your case, it may just copy whole block of memory, especially if your structure is POD (plain old data).</p>\n", "OwnerUserId": "2380660", "LastEditorUserId": "2380660", "LastEditDate": "2013-08-06T13:10:49.960", "Id": "18080176", "Score": "-1", "CreationDate": "2013-08-06T12:28:04.313", "LastActivityDate": "2013-08-06T13:10:49.960"}, "18080046": {"ParentId": "18079769", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The assignment operator is not defined in terms of <code>memcpy</code> (\u00a712.8/28).</p>\n<blockquote>\n<p id=\"so_18079769_18080046_0\">The implicitly-defined copy/move assignment operator for a non-union\n  class X performs memberwise copy/move assignment of its subobjects.\n  The direct base classes of X are assigned first, in the order of their\n  declaration in the base-specifier-list, and then the immediate\n  non-static data members of X are assigned, in the order in which they\n  were declared in the class definition. Let x be either the parameter\n  of the function or, for the move operator, an xvalue referring to the\n  parameter. Each subobject is assigned in the manner appropriate to its\n  type:</p>\n<p id=\"so_18079769_18080046_1\">[...]</p>\n<p id=\"so_18079769_18080046_2\">\u2014 if the subobject is an array, each element is assigned, in the\n  manner appropriate to the element type;</p>\n<p id=\"so_18079769_18080046_3\">[...]</p>\n</blockquote>\n<p>As you see, each <code>char</code> element will be assigned individually. That is always safe.</p>\n<p>However, under the as-if rule, a compiler may replace this with a <code>memmove</code> because it has identical behaviour for a <code>char</code> array. It could also replace it with a <code>memcpy</code> if it can guarantee that <code>memcpy</code> will result in this same behaviour, even if theoretically such a thing is undefined. Compilers can rely on theoretically undefined behaviour; one of the reasons undefined behaviour exists is so that compilers can define it to whatever is more appropriate for their operation.</p>\n<p>Actually, in this case a compiler could take the as-if rule even further and not do anything with the array at all, since that also results in the same behaviour.</p>\n", "OwnerUserId": "46642", "LastEditorUserId": "46642", "LastEditDate": "2013-08-06T12:30:30.287", "Id": "18080046", "Score": "11", "CreationDate": "2013-08-06T12:22:27.547", "LastActivityDate": "2013-08-06T12:30:30.287"}, "18080059": {"ParentId": "18079769", "CommentCount": "1", "Body": "<p>Some limited experimentation tells me that g++ completely removes any attempt to copy <code>a = a;</code> [assuming it is obvious - I'm sure with sufficient messing about with pointers, it will eventually be possible to copy the same object over itself, and get undefined behaviour]. </p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "18080059", "Score": "0", "CreationDate": "2013-08-06T12:22:58.050", "LastActivityDate": "2013-08-06T12:22:58.050"}, "bq_ids": {"n4140": {"so_18079769_18080046_2": {"section_id": 477, "quality": 1.0, "length": 9}, "so_18079769_18080046_0": {"section_id": 477, "quality": 0.9607843137254902, "length": 49}}, "n3337": {"so_18079769_18080046_2": {"section_id": 468, "quality": 1.0, "length": 9}, "so_18079769_18080046_0": {"section_id": 468, "quality": 0.9607843137254902, "length": 49}}, "n4659": {"so_18079769_18080046_2": {"section_id": 500, "quality": 1.0, "length": 9}, "so_18079769_18080046_0": {"section_id": 500, "quality": 0.9607843137254902, "length": 49}}}});