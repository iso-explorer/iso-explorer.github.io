post_cb({"bq_ids": {"n4140": {"so_25630662_25630837_0": {"length": 14, "quality": 1.0, "section_id": 5435}}, "n3337": {"so_25630662_25630837_0": {"length": 14, "quality": 1.0, "section_id": 5230}}, "n4659": {"so_25630662_25630837_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6862}}}, "25630837": {"Id": "25630837", "PostTypeId": "2", "Body": "<p>Your code that uses a cast has undefined behavior (\u00a77.1.6.1 [dcl.type.cv]/p6):</p>\n<blockquote>\n<p id=\"so_25630662_25630837_0\">If an attempt is made to refer to an object defined with a\n  volatile-qualified type through the use of a glvalue with a\n  non-volatile-qualified type, the program behavior is undefined.</p>\n</blockquote>\n<p><code>*(calibration_state_t *)&amp;calibration_state</code> is a glvalue of type <code>calibration_state_t</code>, a non-volatile-qualified type, and is being used to refer to <code>calibration_state</code>, an object defined with a volatile-qualified type. Undefined behavior results.</p>\n<p>Relying on undefined behavior to get the semantics you want is incredibly dangerous. While the compiler is unlikely to actually conjure nasal demons or blow your legs off (though it is allowed to), an optimizing compiler may legally assume from the undefined behavior that <code>get_calibration_state</code> will never be called, and that any code path containing it is unreachable, and generate code accordingly. This kind of optimizations depending on undefined behavior can and do happen.</p>\n<p>In reference binding, <code>volatile</code> is like <code>const</code> - you can't bind a <code>const</code> object to a non-<code>const</code> reference, and you can't bind a <code>volatile</code> object to a non-<code>volatile</code> reference. Give your class a copy constructor that takes a <code>const volatile &amp;</code>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-02T21:38:16.657", "Score": "3", "CreationDate": "2014-09-02T19:24:17.780", "ParentId": "25630662", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-09-02T21:38:16.657"}, "25630814": {"Id": "25630814", "PostTypeId": "2", "Body": "<p>For me it looks that:</p>\n<pre><code>return *(calibration_state_t *)&amp;calibration_state;\n</code></pre>\n<p>explicitly removes the <code>volatile</code> specifier, so the implicitly defined copy constructor:</p>\n<pre><code>calibration_state_t(const calibration_state_t&amp;)\n</code></pre>\n<p>is executed.</p>\n<p>When you don't cast the <code>calibration_state</code> instance first, then compiler can not call the copy constructor (<code>volatile</code> remains).</p>\n", "LastActivityDate": "2014-09-02T19:23:06.490", "CommentCount": "0", "CreationDate": "2014-09-02T19:23:06.490", "ParentId": "25630662", "Score": "1", "OwnerUserId": "3953764"}, "25630753": {"Id": "25630753", "PostTypeId": "2", "Body": "<p>What is the desired behavior exactly? Must ordering be preserved, for example? If something else sets <code>qualified</code> and then <code>running</code>, is it okay to get the old value of <code>qualified</code> but the new value of <code>running</code>?</p>\n<p>Because the structure is volatile, operations on it are part of the visible behavior of the program. That is, this:</p>\n<pre><code>calibration_state_t get_calibration_state()\n{\n    calibration_state_t ret;\n    ret.qualified = calibration_state.qualified;\n    ret.running = calibration_state.running;\n    return ret;\n}\n</code></pre>\n<p>Is not the same as:</p>\n<pre><code>calibration_state_t get_calibration_state()\n{\n    calibration_state_t ret;\n    ret.running = calibration_state.running;\n    ret.qualified = calibration_state.qualified;\n    return ret;\n}\n</code></pre>\n<p>So, you have to code what you want. How can the compiler know what behavior you want? You got <em>some</em> behavior by lying to the compiler, but I doubt it's the behavior you want.</p>\n", "LastActivityDate": "2014-09-02T19:20:15.200", "CommentCount": "3", "CreationDate": "2014-09-02T19:20:15.200", "ParentId": "25630662", "Score": "2", "OwnerUserId": "721269"}, "25630662": {"ViewCount": "152", "Body": "<p>I have the following declarations in my code:</p>\n<p>h file:</p>\n<pre><code>typedef struct {\n    bool qualified : 1;\n    bool running : 1;\n} calibration_state_t;\n\ncalibration_state_t get_calibration_state();\n</code></pre>\n<p>cpp file:</p>\n<pre><code>volatile calibration_state_t calibration_state = {false ,false};\n</code></pre>\n<p>The function</p>\n<pre><code>calibration_state_t get_calibration_state() {\n    return *(calibration_state_t *)&amp;calibration_state;\n}\n</code></pre>\n<p>compiles. However if I replace the return statement with</p>\n<pre><code>return (calibration_state_t)calibration_state;\n</code></pre>\n<p>It fails with</p>\n<pre><code>dcf77.cpp: In function \u2018DCF77_Frequency_Control::calibration_state_t DCF77_Frequency_Control::get_calibration_state()\u2019:\ndcf77.cpp:2923:37: error: no matching function for call to \u2018DCF77_Frequency_Control::calibration_state_t::calibration_state_t(volatile DCF77_Frequency_Control::calibration_state_t&amp;)\u2019\ndcf77.h:204:7: note: candidates are: DCF77_Frequency_Control::calibration_state_t::calibration_state_t()\ndcf77.h:204:7: note:                 DCF77_Frequency_Control::calibration_state_t::calibration_state_t(const DCF77_Frequency_Control::calibration_state_t&amp;)\n</code></pre>\n<p>The compiler is avr-gcc but I suspect this does not matter. Why does the compiler fail to compile the type cast? How would I get to the desired return value in a clean way?</p>\n", "AcceptedAnswerId": "25630753", "Title": "volatile struct vs. typecast", "CreationDate": "2014-09-02T19:14:00.307", "Id": "25630662", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-02T21:38:16.657", "Score": "0", "OwnerUserId": "2036917", "Tags": "<c++><gcc><struct><volatile>", "AnswerCount": "3"}});