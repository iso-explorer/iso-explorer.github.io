post_cb({"bq_ids": {"n4140": {"so_15077466_15077788_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 388}, "so_15077466_15077788_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 389}, "so_15077466_15077788_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 3913}, "so_15077466_15077788_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 3294}, "so_15077466_15077788_1": {"length": 17, "quality": 1.0, "section_id": 388}}, "n3337": {"so_15077466_15077788_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 379}, "so_15077466_15077788_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 380}, "so_15077466_15077788_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 3773}, "so_15077466_15077788_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 3164}, "so_15077466_15077788_1": {"length": 17, "quality": 1.0, "section_id": 379}}, "n4659": {"so_15077466_15077788_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 405}, "so_15077466_15077788_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 406}, "so_15077466_15077788_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 4056}, "so_15077466_15077788_1": {"length": 17, "quality": 1.0, "section_id": 405}}}, "15077788": {"Id": "15077788", "PostTypeId": "2", "Body": "<p>The definition for a <em>converting constructor</em> is different between C++03 and C++11. In both cases it must be a non-<code>explicit</code> constructor (otherwise it wouldn't be involved in implicit conversions), but for C++03 it must also be callable with a single argument. That is:</p>\n<pre><code>struct foo\n{\n  foo(int x);              // 1\n  foo(char* s, int x = 0); // 2\n  foo(float f, int x);     // 3\n  explicit foo(char x);    // 4\n};\n</code></pre>\n<p>Constructors 1 and 2 are both converting constructors in C++03 and C++11. Constructor 3, which must take two arguments, is only a converting constructor in C++11. The last, constructor 4, is not a converting constructor because it is <code>explicit</code>.</p>\n<ul>\n<li><p><strong>C++03</strong>: \u00a712.3.1</p>\n<blockquote>\n<p id=\"so_15077466_15077788_0\">A constructor declared without the <em>function-specifier</em> <code>explicit</code> that can be called with a single parameter specifies a conversion from the type of its first parameter to the type of its class. Such a constructor is called a converting constructor.</p>\n</blockquote></li>\n<li><p><strong>C++11</strong>: \u00a712.3.1</p>\n<blockquote>\n<p id=\"so_15077466_15077788_1\">A constructor declared without the <em>function-specifier</em> <code>explicit</code> specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</p>\n</blockquote></li>\n</ul>\n<p>Why are constructors with more than a single parameter considered to be converting constructors in C++11? That is because the new standard provides us with some handy syntax for passing arguments and returning values using <em>braced-init-lists</em>. Consider the following example:</p>\n<pre><code>foo bar(foo f)\n{\n  return {1.0f, 5};\n}\n</code></pre>\n<p>The ability to specify the return value as a <em>braced-init-list</em> is considered to be a conversion. This uses the converting constructor for <code>foo</code> that takes a <code>float</code> and an <code>int</code>. In addition, we can call this function by doing <code>bar({2.5f, 10})</code>. This is also a conversion. Since they are conversions, it makes sense for the constructors they use to be <em>converting constructors</em>.</p>\n<p>It is important to note, therefore, that making the constructor of <code>foo</code> which takes a <code>float</code> and an <code>int</code> have the <code>explicit</code> function specifier would stop the above code from compiling. The above new syntax can only be used if there is a converting constructor available to do the job.</p>\n<ul>\n<li><p><strong>C++11</strong>: \u00a76.6.3:</p>\n<blockquote>\n<p id=\"so_15077466_15077788_2\">A <code>return</code> statement with a <em>braced-init-list</em> initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n</blockquote>\n<p>\u00a78.5:</p>\n<blockquote>\n<p id=\"so_15077466_15077788_3\">The initialization that occurs [...] in argument passing [...] is called copy-initialization.</p>\n</blockquote>\n<p>\u00a712.3.1:</p>\n<blockquote>\n<p id=\"so_15077466_15077788_4\">An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.</p>\n</blockquote></li>\n</ul>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-02-25T22:52:43.730", "Score": "39", "CreationDate": "2013-02-25T22:31:43.570", "ParentId": "15077466", "CommentCount": "0", "OwnerUserId": "150634", "LastEditDate": "2013-02-25T22:52:43.730"}, "15077467": {"Id": "15077467", "PostTypeId": "2", "Body": "<p><strong>Converting implicitly with converting constructor</strong></p>\n<p>Let's make the example in the question more complex</p>\n<pre><code>class MyClass\n{\n  public:\n     int a, b;\n     MyClass( int i ) {}\n     MyClass( const char* n, int k = 0 ) {}\n     MyClass( MyClass&amp; obj ) {}\n}\n</code></pre>\n<p>First two constructors are converting constructors. The third one is a copy constructor, and as such it is another converting constructor.</p>\n<p>A converting constructor enables implicit conversion from argument type to the constructor type. Here, the first constructor enables conversion from an <code>int</code> to an object of class <code>MyClass</code>. Second constructor enables conversion from an string to an object of class <code>MyClass</code>. And third... from an object of class <code>MyClass</code> to an object of class <code>MyClass</code> !</p>\n<p>To be a converting constructor, constructor must have single argument (in the second one, second argument has one default value) and be declared without keyword <code>explicit</code>.</p>\n<p>Then, initialization in main can look like this:</p>\n<pre><code>int main()\n{\n    MyClass M = 1 ;\n    // which is an alternative to\n    MyClass M = MyClass(1) ;\n\n    MyClass M = \"super\" ;\n    // which is an alternative to\n    MyClass M = MyClass(\"super\", 0) ;\n    // or\n    MyClass M = MyClass(\"super\") ;\n}\n</code></pre>\n<p><strong>Explicit keyword and constructors</strong></p>\n<p>Now, what if we had used the <code>explicit</code> keyword ?</p>\n<pre><code>class MyClass\n{\n  public:\n     int a, b;\n     explicit MyClass( int i ) {}\n}\n</code></pre>\n<p>Then, compiler would not accept</p>\n<pre><code>   int main()\n    {\n        MyClass M = 1 ;\n    }\n</code></pre>\n<p>since this is implicit conversion. Instead, have to write</p>\n<pre><code>   int main()\n    {\n        MyClass M(1) ;\n        MyClass M = MyClass(1) ;\n        MyClass* M = new MyClass(1) ;\n        MyClass M = (MyClass)1;\n        MyClass M = static_cast&lt;MyClass&gt;(1);\n    }\n</code></pre>\n<p><code>explicit</code> keyword is always to be used to prevent implicit conversion for a constructor and it applies to constructor in a class declaration.</p>\n", "LastEditorUserId": "1141493", "LastActivityDate": "2013-02-25T22:16:55.930", "Score": "11", "CreationDate": "2013-02-25T22:09:36.250", "ParentId": "15077466", "CommentCount": "7", "OwnerUserId": "1141493", "LastEditDate": "2013-02-25T22:16:55.930"}, "15077466": {"ViewCount": "21986", "Body": "<p>I have heard that C++ has something called \"conversion constructors\" or \"converting constructors\".  What are these, and what are they for?  I saw it mentioned with regards to this code:</p>\n<pre><code>class MyClass\n{\n  public:\n     int a, b;\n     MyClass( int i ) {}\n}\n\n int main()\n{\n    MyClass M = 1 ;\n}\n</code></pre>\n", "AcceptedAnswerId": "15077788", "Title": "What is a converting constructor in C++ ? What is it for?", "CreationDate": "2013-02-25T22:09:36.250", "Id": "15077466", "CommentCount": "5", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2013-02-25T22:36:21.390", "LastEditorUserId": "845092", "LastActivityDate": "2015-03-15T20:33:34.087", "Score": "33", "OwnerUserId": "1141493", "Tags": "<c++><constructor><copy-constructor>", "AnswerCount": "2"}});