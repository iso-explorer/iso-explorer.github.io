post_cb({"38449561": {"Id": "38449561", "PostTypeId": "2", "Body": "<p>All of <code>~unique_ptr</code>, <code>unique_ptr::operator=</code> and <code>unique_ptr::reset</code> are <code>noexcept</code>. So, throwing exception from destructor of an object, owned by <code>unique_ptr</code>, will always result in <code>std::terminate</code>. Which makes memory leaks irrelevant in both cases.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow\">Here</a> it is explained why <code>make_shared</code>/<code>make_unique</code> are preferable to <code>unique_ptr(new ...)</code>/<code>shared_ptr(new ...)</code>. This is why we should prefer (2) to (1)</p>\n<p>Don't forget: you cannot specify custom deleters with <code>make_shared</code>/<code>make_unique</code>.</p>\n", "LastActivityDate": "2016-07-19T04:23:32.590", "CommentCount": "0", "CreationDate": "2016-07-19T04:23:32.590", "ParentId": "38447426", "Score": "3", "OwnerUserId": "2027606"}, "38447702": {"Id": "38447702", "PostTypeId": "2", "Body": "<pre><code>template&lt;typename T, typename... Args&gt;\nvoid reset(unique_ptr&lt;T&gt;&amp; p, Args&amp;&amp;... args)\n{\n  auto tmp = std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n  std::swap( tmp, p );\n}\n</code></pre>\n<p>As noted by the other answer, <code>reset</code> demands the destructor does not throw.</p>\n<p>The above, however, makes no such demands.  <code>swap</code> should never throw.  If the ctor in <code>make_unique</code> throws, obvious things happen.  The ctor of <code>tmp</code> does not throw.</p>\n<p>If the dtor of <code>tmp</code> throws, it already contains what <code>p</code> contained, and <code>p</code> already contains the new data.  So things are in a predictable state.</p>\n<p>This is not the strong exception guarantee, because if a throw occurs (during destruction of what was in <code>p</code>) things are not rolled back to the original state.  I can think of no logical way to provide that guarantee: maybe if <code>clone</code> of <code>T</code> is nothrow?  But even then if <code>p</code> throws, so would any temporary object, so things aren't really practical.</p>\n", "LastActivityDate": "2016-07-19T00:09:44.847", "CommentCount": "0", "CreationDate": "2016-07-19T00:09:44.847", "ParentId": "38447426", "Score": "3", "OwnerUserId": "1774667"}, "38447460": {"Id": "38447460", "PostTypeId": "2", "Body": "<p>As Jonathan Wakely <a href=\"https://stackoverflow.com/questions/38447426/strong-exception-guarantee-for-stdunique-ptrtreset/38447460#comment64300470_38447460\">points out</a>, the point is moot, because behaviour of <code>unique_ptr::reset</code> is undefined if the destructor throws anyway.</p>\n<p>Both versions have UB if the destructor throws, so this is not a reason to prefer one over the other.</p>\n<p><a href=\"http://eel.is/c++draft/unique.ptr#single.modifiers-4\" rel=\"nofollow noreferrer\">[unique.ptr.single.modifiers]</a> (standard draft)</p>\n<blockquote>\n<p id=\"so_38447426_38447460_0\">3 Requires: The expression <code>get_deleter()(get())</code> shall be well formed, shall have well-defined behavior, and <strong>shall not throw exceptions</strong>.</p>\n</blockquote>\n<hr>\n<p>Even if the behaviour was well defined...</p>\n<p>(1) Would not leak. <code>unique_ptr</code> takes ownership of the parameter before destructing the old one.</p>\n<blockquote>\n<p id=\"so_38447426_38447460_1\">4 Effects: Assigns <code>p</code> to the stored pointer, and then if the old value of the stored pointer, <code>old_p</code>, was not equal to <code>nullptr</code>, calls <code>get_deleter()(old_p)</code>. [ Note: The order of these operations is significant because the call to <code>get_deleter()</code> may destroy <code>*this</code>.  \u2014 end note ]</p>\n</blockquote>\n<hr>\n<p>Reasons to prefer one over the other</p>\n<ul>\n<li>(1) requires only C++11, (2) requires C++14 or your own boilerplate for <code>make_unique</code>.</li>\n<li>(2) doesn't have explicit call to <code>new</code>, so it is easier to reason about memory tidyness using the old rule of thumb: \"one delete for each new\".</li>\n</ul>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-18T23:52:19.040", "Score": "4", "CreationDate": "2016-07-18T23:36:35.120", "ParentId": "38447426", "CommentCount": "3", "OwnerUserId": "2079303", "LastEditDate": "2017-05-23T12:32:36.190"}, "bq_ids": {"n4140": {"so_38447426_38447460_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4318}, "so_38447426_38447460_1": {"length": 21, "quality": 0.7777777777777778, "section_id": 4341}}, "n3337": {"so_38447426_38447460_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4159}, "so_38447426_38447460_1": {"length": 21, "quality": 0.7777777777777778, "section_id": 4182}}, "n4659": {"so_38447426_38447460_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5575}, "so_38447426_38447460_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 5598}}}, "38447426": {"ViewCount": "174", "Body": "<p>Suppose I have a function <code>reset</code>:</p>\n<pre><code>template&lt;typename T, typename... Args&gt;\nvoid reset(unique_ptr&lt;T&gt;&amp; p, Args&amp;&amp;... args)\n{\n    // implementation (1)\n    p.reset(new T(forward&lt;Args&gt;(args)...));\n\n    // implementation (2)\n    p = make_unique&lt;T&gt;(forward&lt;Args&gt;(args)...);\n}\n</code></pre>\n<p>Am I correct that:</p>\n<ol>\n<li><p>For implementation (1), if an exception is thrown during the destruction of the original pointee of <code>p</code>, the <code>new</code>-ed memory will be leaked;</p></li>\n<li><p>For implementation (2), nothing can ever be leaked;</p></li>\n<li><p>And so we should prefer (2) to (1).</p></li>\n</ol>\n", "Title": "Strong exception guarantee for std::unique_ptr<T>::reset", "CreationDate": "2016-07-18T23:30:48.847", "LastActivityDate": "2016-07-19T04:23:32.590", "CommentCount": "2", "PostTypeId": "1", "Id": "38447426", "Score": "2", "OwnerUserId": "3234803", "Tags": "<c++><c++11>", "AnswerCount": "3"}});