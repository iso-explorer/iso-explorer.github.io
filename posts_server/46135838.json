post_cb({"46142707": {"ParentId": "46135838", "CommentCount": "1", "CreationDate": "2017-09-10T16:05:05.953", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "46142707", "Score": "3", "Body": "<p><code>ranges::view::partial_sum</code> by design mirrors the semantics of <code>std::partial_sum</code>. If you run:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nint main() \n{\n    std::vector&lt;int&gt; v { 6, 2, 3, 4, 5, 6 };\n    auto f = [](auto a, auto b) { return a*0.3 + b*0.7; };\n    std::vector&lt;double&gt; rng;\n    std::partial_sum(v.begin(), v.end(), std::back_inserter(rng), f);\n\n    for(auto i : rng)\n    {\n        std::cout&lt;&lt;i&lt;&lt;\" \";\n    }\n}\n</code></pre>\n<p>You should get <a href=\"https://wandbox.org/permlink/eEpz9706q4O7Woxy\" rel=\"nofollow noreferrer\">exactly the same output as from the program in the OP</a>. Like many range-v3 views, this view's job is to compute the same sequence of results as computed by a standard algorithm, but do so lazily.</p>\n<p><code>std::partial_sum</code> is specified to operate on an accumulator whose type is the same is the value type of the input range. <a href=\"http://eel.is/c++draft/partial.sum#2\" rel=\"nofollow noreferrer\">[partial.sum]/2</a> says:</p>\n<blockquote>\n<p id=\"so_46135838_46142707_0\">Effects: For a non-empty range, the function creates an accumulator <code>acc</code> whose type is <code>InputIterator</code>'s value type, initializes it with <code>*first</code>, and assigns the result to <code>*result</code>. For every iterator <code>i</code> in <code>[first + 1, last)</code> in order, <code>acc</code> is then modified by <code>acc = acc + *i</code> or <code>acc = binary_\u00adop(acc, *i)</code> and the result is assigned to <code>*(result + (i - first))</code>.</p>\n</blockquote>\n<p>To behave equivalently, <code>ranges::view::partial_sum</code> also uses an accumulator whose type is the value type of the input range.</p>\n<p>In the case of the OP, you can achieve the desired result by using <code>double</code> as the type of the input range. With range-v3 this is easy to do on-the-fly by composing with <code>ranges::view::transform(ranges::convert_to&lt;double&gt;{})</code>:</p>\n<pre><code>#include &lt;range/v3/all.hpp&gt;\n#include &lt;iostream&gt;\n\nnamespace rng = ranges::v3;\n\nint main() \n{\n    std::vector&lt;int&gt; v { 6, 2, 3, 4, 5, 6 };\n    auto f    = [](auto a, auto b) { return a*0.3 + b*0.7;};\n    auto rng  = v | rng::view::transform(rng::convert_to&lt;double&gt;{}) |\n        rng::view::partial_sum(f);\n\n    for(auto i : rng)\n    {\n        std::cout&lt;&lt;i&lt;&lt;\" \";\n    }\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/Wv57cRBs4Hfkdr3r\" rel=\"nofollow noreferrer\">which produces the desired output</a>:</p>\n<pre>\n6 3.2 3.06 3.718 4.6154 5.58462\n</pre>\n", "LastActivityDate": "2017-09-10T16:05:05.953"}, "bq_ids": {"n4140": {"so_46135838_46142707_0": {"section_id": 3853, "quality": 0.8571428571428571, "length": 30}}, "n3337": {"so_46135838_46142707_0": {"section_id": 3714, "quality": 0.8571428571428571, "length": 30}}, "n4659": {"so_46135838_46142707_0": {"section_id": 4640, "quality": 0.8571428571428571, "length": 30}}}, "46135838": {"CommentCount": "6", "ViewCount": "68", "PostTypeId": "1", "LastEditorUserId": "2412846", "CreationDate": "2017-09-09T22:58:40.997", "LastActivityDate": "2017-09-10T16:05:05.953", "Title": "C++ unexpected value type of range-v3 partial_sum view", "AcceptedAnswerId": "46142707", "LastEditDate": "2017-09-10T16:03:00.520", "Id": "46135838", "Score": "3", "Body": "<p>Consider the following minimal example:</p>\n<pre><code>#include &lt;range/v3/all.hpp&gt;\n#include &lt;iostream&gt;\n\nnamespace rng = ranges::v3;\n\nint main() \n{\n    std::vector&lt;int&gt; v { 6, 2, 3, 4, 5, 6 };\n    auto f    = [](auto a, auto b) { return a*0.3 + b*0.7;};\n    auto rng  = v | rng::view::partial_sum(f);\n\n    for(auto i : rng)\n    {\n        std::cout&lt;&lt;i&lt;&lt;\" \";\n    }\n}\n</code></pre>\n<p>This outputs</p>\n<pre><code>6 3 2 3 4 5 \n</code></pre>\n<p>I would have expected to see double numbers here, but the result are obvisouly integers. This is in contrast to the behavior of <code>view::transform</code>.</p>\n<p>The reason for this is because in the implementation, the running-sum value has a type that corresponds to the source range:</p>\n<pre><code>semiregular_t&lt;range_value_type_t&lt;Rng&gt;&gt; sum_;\n</code></pre>\n<p>Is this intended or a bug?</p>\n<hr>\n<p><strong>Discussion</strong>: I see the trouble one is running into when trying to get a valid return type, as as the transformation function is using both the source range and the result range as parameters and produces a return type. The next application uses the source-range-type and this return type to produce another (possibly different) return type, and so on.</p>\n<p>By this, in principle, one is repeatedly chaining the source-value-type with the result types of the transformation function. This repeated iteration yields something usable only if the result type \"converges\" to a specific type to which all other intermediate results can be converted to (in the example above, this type is <code>double</code>, which is obtained already after the first call of the transformation function).</p>\n<p>With this observation one could propose a workaround: apply the binary transformation function a given number of times and the use the <code>common_type</code> as value type of the resulting range (if one finds a convergence, prematurely stop). In the simplest case, the number of iterations is just one. If this iteration does not lead to something reasonable, one can still resort to the source-value-type (or a compiler error).</p>\n<p>To make it clear, here is the application for the example above:</p>\n<pre><code>First iteration : f(int,int)    -&gt; yields \"double\"\nSecond iteration: f(int,double) -&gt; yields \"double\"\nThird iteration : f(int,double) -&gt; yields \"double\"\n</code></pre>\n<p>After the third iteration the pattern converges, so stop and choose the common-type <code>double</code> as the value_type of the returned range.</p>\n<p>I'm not sure whether this approach is completely valid in all theoretical circumstances, but at least it gives a double in the first example -- which I guess is what everyone is strongly expecting.</p>\n</hr>", "Tags": "<c++><range-v3>", "OwnerUserId": "2412846", "AnswerCount": "1"}});