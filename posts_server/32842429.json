post_cb({"32843660": {"Id": "32843660", "PostTypeId": "2", "Body": "<p>(...there was a wrong answer...)</p>\n<p>It looks more strange in the following context:</p>\n<pre><code>class Foo {\npublic:\n    virtual void func(int param) { cout &lt;&lt; param &lt;&lt; endl; }\n    void call(int x) { Foo::func(x); }\n    void (Foo::*getPointer())(int) { return &amp;Foo::func; }\n};\n\nclass Bar : public Foo {\npublic:\n    void func(int param) override { cout &lt;&lt; \"Hello world!\" &lt;&lt; endl; }\n};\n\n\nint main() {\n\n    Foo *a = new Bar();\n    auto p = a-&gt;getPointer();\n    (a-&gt;*p)(4);\n    a-&gt;call(4);\n\n    return 0;\n}\n</code></pre>\n<p>The output is</p>\n<blockquote>\n<p id=\"so_32842429_32843660_0\">Hello world<br>\n  4</br></p>\n</blockquote>\n<p>Calling <code>Foo::func</code> is a call of <code>func</code> in <code>Foo</code> class while calling <code>&amp;Foo::func</code> is a virtual call.</p>\n", "LastEditorUserId": "2642059", "LastActivityDate": "2015-09-29T12:38:45.853", "Score": "3", "CreationDate": "2015-09-29T12:08:36.470", "ParentId": "32842429", "CommentCount": "4", "OwnerUserId": "5380314", "LastEditDate": "2015-09-29T12:38:45.853"}, "bq_ids": {"n4140": {"so_32842429_32845696_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7221}}, "n3337": {"so_32842429_32845696_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6965}}, "n4659": {"so_32842429_32845696_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 8730}}}, "32845696": {"Id": "32845696", "PostTypeId": "2", "Body": "<p>Pointers and pointer to members are distinct types, we can see that from section the draft C++ standard section <code>3.9.2</code> [basic.compound] which includes a compound type for pointer as well as <em>pointer to non-static class member</em> and notes:</p>\n<blockquote>\n<p id=\"so_32842429_32845696_0\">Static class members are objects or functions, and pointers to them\n  are ordinary pointers to objects or functions</p>\n</blockquote>\n<p>This issue with this is I think well described in <a href=\"https://stackoverflow.com/a/7138582/1708801\">this quote in an answer from Johannes</a> from the <a href=\"http://www.stroustrup.com/arm.html\" rel=\"nofollow noreferrer\">Annotated C++ Reference Manual(<em>ARM</em>)</a>:</p>\n<blockquote>\n<p id=\"so_32842429_32845696_1\">Note that the address-of operator must be explicitly used to get a\n  pointer to member; there is no implicit conversion ... Had there been,\n  we would have an ambiguity in the context of a member function ... For\n  example,</p>\n<pre><code>void B::f() {\n    int B::* p = &amp;B::i;   // ok\n    p = B::i;         // error: B::i is an int\n    p = &amp;i;           // error: '&amp;i'means '&amp;this-&gt;i'\n                      // which is an 'int*'\n\n    int *q = &amp;i;      // ok\n    q = B::i;         // error: 'B::i is an int\n    q = &amp;B::i;        // error: '&amp;B::i' is an 'int B::*'\n}\n</code></pre>\n</blockquote>\n<p>In particular these lines:</p>\n<pre><code>int B::* p = &amp;B::i; // OK\n</code></pre>\n<p>and:</p>\n<pre><code>p = &amp;i; // error: '&amp;i'means '&amp;this-&gt;i' which is an 'int*'\n</code></pre>\n<p>demonstrate the difference between the qualified and the unqualified name.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-14T02:57:27.803", "Score": "3", "CreationDate": "2015-09-29T13:48:10.683", "ParentId": "32842429", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T10:27:07.827"}, "32842429": {"ViewCount": "494", "Body": "<p>When returning a member function pointer to a class within one of that class's member functions I still have to specify the class. I cannot simply take the address. For example, <a href=\"http://ideone.com/auaGLm\">this code works fine</a>:</p>\n<pre><code>class Foo {\npublic:\n    void func(int param) { cout &lt;&lt; param &lt;&lt; endl; }\n    void (Foo::*getPointer())(int) { return &amp;Foo::func; }\n};\n</code></pre>\n<p>But if in <code>getPointer</code> I try to simply do: <code>return &amp;func</code> I get this error:</p>\n<blockquote>\n<p id=\"so_32842429_32842429_0\">prog.cpp: In member function '<code>void (Foo::* Foo::getPointer())(int)</code>':<br>\n  prog.cpp:8:43: error: ISO C++ forbids taking the address of an unqualified or parenthesized non-static member function to form a pointer to member function.  Say '<code>&amp;Foo::func</code>' [-fpermissive]<br>\n<code>void (Foo::*getPointer())(int) { return &amp;func; }</code></br></br></p>\n</blockquote>\n<p>Why must I specify the class when that's the context that I am within?</p>\n", "AcceptedAnswerId": "32845696", "Title": "Why does taking a member function pointer value requires class name qualification even from inside of the class?", "CreationDate": "2015-09-29T11:12:42.570", "Id": "32842429", "CommentCount": "22", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-09-29T11:17:15.297", "LastEditorUserId": "752976", "LastActivityDate": "2015-10-14T02:57:27.803", "Score": "11", "OwnerUserId": "2642059", "Tags": "<c++><methods><function-pointers><dereference><member-function-pointers>", "AnswerCount": "2"}});