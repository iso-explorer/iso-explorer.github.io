post_cb({"27217701": {"ParentId": "27217656", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>It's not quite clear how the alignment requirements transpose to storage allocated with <code>new</code>. The standard maintains in [expr.new] that</p>\n<blockquote>\n<p id=\"so_27217656_27217701_0\">It is implementation-defined whether over-aligned types are supported\n  (3.11).</p>\n</blockquote>\n<p>[basic.align]/3:</p>\n<blockquote>\n<p id=\"so_27217656_27217701_1\">An <em>extended alignment</em> is represented by an alignment greater than\n  <code>alignof(std::max_align_t)</code>. It is implementation-defined whether any\n  extended alignments are supported and the contexts in which they are\n  supported (7.6.2). <strong>A type having an extended alignment requirement\n  is an <em>over-aligned type</em></strong>.</p>\n</blockquote>\n<p>Over-aligned types might not be supported by GCC, and the \"non-support\" of this might (instead of a compiler error) lead to the allocation function only returning storage aligned with the <em>strictest fundamental alignment</em>: <code>sizeof(std::max_align_t)</code>. If the value of the latter is 16 on your machine, that would explain that the address is a multiple of 16.</p>\n<p>Also note that, despite the fact that runtime allocation functions will have maximum supported alignments, <code>operator new</code> can basically not take desired alignments into account as it has no parameter that could take the corresponding value and pass it on to the runtime environments allocation function. This problem is known and subject of an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3396.htm\" rel=\"nofollow\">EWG-issue</a>.</p>\n<hr>\n<p>Fun-fact: The above code is invoking UB. Consider the table in [meta.trans.ptr] that lists the requirements for <code>aligned_storage</code>s second template argument:</p>\n<blockquote>\n<p id=\"so_27217656_27217701_2\"><code>Align</code> shall be equal to <code>alignof(T)</code> for some type <code>T</code> or to\n  <em>default-alignment</em>.</p>\n</blockquote>\n<p>If no type <code>T</code> has an alignment of <code>4096</code> the requirement for the template argument is not fit. And what type would have an alignment of <em>2<sup>12</sup></em>?</p>\n<p>However, this is not important to the essence of the question. We can just use <code>new</code> with an own typedef.</p>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-30T21:30:29.580", "Id": "27217701", "Score": "9", "CreationDate": "2014-11-30T20:10:54.557", "LastActivityDate": "2014-11-30T21:30:29.580"}, "27217656": {"CommentCount": "9", "AcceptedAnswerId": "27217701", "PostTypeId": "1", "LastEditorUserId": "1171688", "CreationDate": "2014-11-30T20:06:52.020", "LastActivityDate": "2014-11-30T21:30:29.580", "LastEditDate": "2014-11-30T20:16:03.697", "ViewCount": "621", "FavoriteCount": "1", "Title": "Why does allocation of std::aligned_storage always have an offset?", "Id": "27217656", "Score": "7", "Body": "<p>When allocating an <code>std::aligned_storage&lt;2, 4096&gt;::type</code> on the heap I always get a pointer that is offset by 16 bytes (on x64; on x86 it is offset by 8 bytes). In other words, this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n\nint main() {\n    typedef std::aligned_storage&lt;2, 4096&gt;::type MemPage;\n\n    MemPage* p_mp = new MemPage;\n\n    std::cout &lt;&lt; (void*)p_mp &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>gives me (for example)</p>\n<pre><code>0x72f010\n</code></pre>\n<p>although I would expect all the last three digits to be zero. When allocating the <code>std::aligned_storage&lt;&gt;::type</code> on the stack everything works as expected.</p>\n<p>I use gcc-4.8.2 x86_64 on ubuntu 14.04.</p>\n", "Tags": "<c++><gcc><memory-alignment>", "OwnerUserId": "1171688", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27217656_27217701_0": {"section_id": 4239, "quality": 0.6666666666666666, "length": 4}, "so_27217656_27217701_1": {"section_id": 7242, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_27217656_27217701_0": {"section_id": 4080, "quality": 0.6666666666666666, "length": 4}, "so_27217656_27217701_1": {"section_id": 6986, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_27217656_27217701_0": {"section_id": 5177, "quality": 0.6666666666666666, "length": 4}, "so_27217656_27217701_1": {"section_id": 8751, "quality": 0.8695652173913043, "length": 20}}}});