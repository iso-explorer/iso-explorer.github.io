post_cb({"41878162": {"ParentId": "41878040", "Score": "11", "CreationDate": "2017-01-26T16:23:02.860", "Id": "41878162", "OwnerUserId": "4342498", "LastActivityDate": "2017-01-26T16:23:02.860", "Body": "<p>There is no guarantee but the C++17 draft states in <a href=\"http://eel.is/c++draft/any.class\">[any.class]</a> that</p>\n<blockquote>\n<p id=\"so_41878040_41878162_0\">Implementations should avoid the use of dynamically allocated memory for a small contained object. [\u2009Example: where the object constructed is holding only an int. \u2009\u2014\u2009end example\u2009] Such small-object optimization shall only be applied to types <code>T</code> for which <code>is_\u00adnothrow_\u00admove_\u00adconstructible_\u00adv&lt;T&gt;</code> is <code>true</code>.</p>\n</blockquote>\n<p>Unfortunately it does not give a recommendation for what should be considered <em>small</em> except to say a <code>int</code> should be able to be stored in place.</p>\n", "PostTypeId": "2", "CommentCount": "5"}, "41878040": {"Tags": "<c++><boost><c++1z>", "ViewCount": "890", "LastEditDate": "2017-01-27T13:36:38.657", "CreationDate": "2017-01-26T16:17:41.050", "LastEditorUserId": "1408611", "Title": "Does boost::any / std::any store small objects in-place?", "CommentCount": "4", "AcceptedAnswerId": "41878162", "Score": "12", "OwnerUserId": "1408611", "Id": "41878040", "LastActivityDate": "2017-01-27T13:36:38.657", "Body": "<p>To hold arbitrarily large objects, <code>boost::any</code> / <code>std::any</code> surely needs to allocate heap space for objects. However, for small types whose size is less or equal to a pointer (<code>int,char,bool,...</code>), <code>any</code> could instead store the value in-place in the pointer slot or in some other in-place memory and not allocate heap space. But does the implementation do this?</p>\n<p>I have a scenario where I often store small types in an <code>any</code> and only sometimes larger types like <code>string</code>s. The code is quite hot and therefore I am asking the question. If the optimization is not performed, I might be better off with an own implementation that stores small types in-place.</p>\n", "PostTypeId": "1", "FavoriteCount": "1", "AnswerCount": "3"}, "41878281": {"ParentId": "41878040", "Score": "5", "CreationDate": "2017-01-26T16:28:43.010", "Id": "41878281", "OwnerUserId": "25507", "LastActivityDate": "2017-01-26T16:28:43.010", "Body": "<p>If I understand the <a href=\"https://github.com/boostorg/any/blob/develop/include/boost/any.hpp\">Boost.Any</a> source code correctly, and from poking at it in a debugger, it does not apply a small object optimization. (Note the unconditional use of new.)</p>\n<pre><code>    template&lt;typename ValueType&gt;\n    any(const ValueType &amp; value)\n      : content(new holder&lt;\n            BOOST_DEDUCED_TYPENAME remove_cv&lt;BOOST_DEDUCED_TYPENAME decay&lt;const ValueType&gt;::type&gt;::type\n        &gt;(value))\n    {\n    }\n</code></pre>\n", "PostTypeId": "2", "CommentCount": "0"}, "41887519": {"ParentId": "41878040", "Score": "2", "CreationDate": "2017-01-27T05:33:48.447", "Id": "41887519", "OwnerUserId": "4988044", "LastActivityDate": "2017-01-27T05:33:48.447", "Body": "<p>Nathan Oliver's and Josh's Kelley's answers are correct:  There is no guarantee, boost does not use the small value optimization.</p>\n<p>In more practical cases,\n<a href=\"https://github.com/llvm-mirror/libcxx/blob/master/include/experimental/any#L129\" rel=\"nofollow noreferrer\">https://github.com/llvm-mirror/libcxx/blob/master/include/experimental/any#L129</a>\nShows you libc++ (clang's) gives you 3 void pointers worth of space, (24 bytes if they are 8 bytes wide)</p>\n<p>libstdc++ only one pointer:\n<a href=\"https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/include/experimental/any?view=markup#l106\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/include/experimental/any?view=markup#l106</a></p>\n<p>Changing <code>any</code> to make the size a template parameter is not difficult, just that you should also make sure there is convertibility between <code>any</code> of different sizes.</p>\n<p>IMO, the performance difference is so substantial between small size optimization and heap allocated, according to my benchmarks, and the implementation cost of making it a template so small it will become part of the standard</p>\n", "PostTypeId": "2", "CommentCount": "1"}, "bq_ids": {"n4659": {"so_41878040_41878162_0": {"length": 20, "section_id": 5308, "quality": 0.8333333333333334}}}});