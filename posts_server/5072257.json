post_cb({"bq_ids": {"n4140": {"so_5072257_5072289_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 1423}}, "n3337": {"so_5072257_5072289_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 1417}}, "n4659": {"so_5072257_5072289_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 1543}}}, "5072257": {"ViewCount": "4631", "Body": "<p>I have an array of structures, sorted on a member of a structure, something like:</p>\n<pre><code>struct foo\n{\n    int bar;\n    double baz;\n};\n\n// An array of foo, sorted on .bar\nfoo foos[] = { ........ };\n// foos[0] = {0, 0.245}\n// foos[1] = {1, -943.2}\n// foos[2] = {2, 304.222}\n// etc...\n</code></pre>\n<p>I want to find the element with a specific <code>.bar</code> value. It might or might not be in the array, and I'd like to do it in O(log(n)) time, since the array is sorted.</p>\n<p><code>std::lower_bound</code> is what I'd normally go for, but I need to specify a comparison function. However, the type of the members of the array (<code>struct foo</code>) and the searched value (<code>int</code>) are not the same, thus, my comparator is:</p>\n<pre><code>bool comp(foo a, int b)\n{\n    // ...\n}\n// --- or ---\nbool comp(int a, foo b)\n{\n    // ...\n}\n</code></pre>\n<p>It looks like the first will work with <code>gcc</code>, but I was wondering if the order of the arguments to the comparison function was specified by the standard, or if I'm relying on compiler behavior.</p>\n<p>I'd like to avoid constructing a <code>foo</code> to pass to <code>std::lower_bound</code> here, as a full <code>foo</code> isn't required, and could be costly. My other option would be to wrap the <code>foo *</code> in a custom iterator that only exposed the .bar member.</p>\n", "AcceptedAnswerId": "5072289", "Title": "std::lower_bound and comparator function with different types?", "CreationDate": "2011-02-21T22:59:28.493", "Id": "5072257", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2011-05-17T09:43:25.920", "Score": "13", "OwnerUserId": "101999", "Tags": "<c++><stl>", "AnswerCount": "2"}, "6029031": {"Id": "6029031", "PostTypeId": "2", "Body": "<p>This should really be a comment to wilhelmtell's post, but I don't have enough points to do that yet...</p>\n<p>I just wanted to point out that this also works for the MS compiler, but you'll need to define</p>\n<pre><code>comp(foo lhs, foo rhs)\n</code></pre>\n<p>otherwise your code won't compile in debug mode.</p>\n", "LastActivityDate": "2011-05-17T09:43:25.920", "CommentCount": "0", "CreationDate": "2011-05-17T09:43:25.920", "ParentId": "5072257", "Score": "3", "OwnerUserId": "456651"}, "5072289": {"Id": "5072289", "PostTypeId": "2", "Body": "<p>From the standard, 25.3.3.1/3, on <code>std::lower_bound()</code>:</p>\n<blockquote>\n<p id=\"so_5072257_5072289_0\"><strong>Returns</strong>: The furthermost iterator <code>i</code> in the range <code>[first, last]</code> such\n  that for any iterator <code>j</code> in the range\n  <code>[first, i)</code> the following\n  corresponding conditions hold: <code>*j &lt;\n  value</code> or <code>comp(*j, value) != false</code>.</p>\n</blockquote>\n<p>From that, you may use</p>\n<pre><code>bool comp(foo a, int b)\n</code></pre>\n<p>or you may compare two <code>foo</code> instances and then access <code>bar</code> in both of them.</p>\n", "LastEditorUserId": "456", "LastActivityDate": "2011-02-21T23:39:01.440", "Score": "13", "CreationDate": "2011-02-21T23:03:58.087", "ParentId": "5072257", "CommentCount": "2", "OwnerUserId": "456", "LastEditDate": "2011-02-21T23:39:01.440"}});