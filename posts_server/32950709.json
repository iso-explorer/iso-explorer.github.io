post_cb({"32950709": {"CommentCount": "30", "ViewCount": "804", "PostTypeId": "1", "LastEditorUserId": "1090079", "CreationDate": "2015-10-05T14:11:39.257", "LastActivityDate": "2015-10-05T15:46:01.683", "Title": "What would be the size of this enum, in bytes? C++", "AcceptedAnswerId": "32950795", "LastEditDate": "2015-10-05T14:13:34.000", "Id": "32950709", "Score": "-2", "Body": "<p>What would be the size of this enum, in bytes? C++</p>\n<pre><code>enum Cars { Toyota, Suzuki, Volkswa, Mitsubish, Alfarome, Holden, Bradleys };\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "5181883", "AnswerCount": "3"}, "32952583": {"ParentId": "32950709", "CommentCount": "0", "CreationDate": "2015-10-05T15:46:01.683", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "32952583", "Score": "1", "Body": "<p>Each enumeration is a separate entity.</p>\n<p>The compiler needs to allocate enough storage to hold the highest value of the enumeration.  </p>\n<p>In your case, there are 7 entities.  The compiler needs to allocate enough storage to hold the value 7.  </p>\n<p>The minimum size of an addressable data type is 1.  </p>\n<p>If you create a variable of the <code>enum</code> type, it must have a <strong>minimum</strong> size of 1.  However, the compiler can choose a size that is more optimal for the architecture (platform), such as 2 bytes (16-bit word), 4 bytes (32-bit word) or other.  </p>\n<p>If the enumeration items are used individually, like in an <code>if</code> statement, the compiler may not allocate any data storage and emit the values into an instruction in the executable.  </p>\n<p>So the answer to your question is:  the minimum space for a variable of the enum type is 1.  What your compiler uses is dependent on the compiler and the platform.  If the enumeration value is used in an expression, the compiler may choose to put the value in the instruction, so there will be zero data space allocated.  </p>\n", "LastActivityDate": "2015-10-05T15:46:01.683"}, "32950905": {"ParentId": "32950709", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-10-05T14:20:53.470", "Score": "4", "LastEditorUserId": "2020827", "LastEditDate": "2015-10-05T14:35:51.683", "Id": "32950905", "OwnerUserId": "2020827", "Body": "<p>The size depends on the platform/implementation.</p>\n<p>In C++11, you can specify the underlying type (and hence the size).\nIn the following example the size would be 1 byte:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nenum cars : std::uint8_t {\n    Toyota, Suzuki, Volkswa, Mitsubish, Alfarome, Holden, Bradleys\n};\n\nint main() {\n    cars my_car = cars::Toyota;\n    std::cout &lt;&lt; sizeof(my_car) &lt;&lt; std::endl;\n};\n</code></pre>\n<p>Returns:</p>\n<pre><code>1\n</code></pre>\n<p>While</p>\n<pre><code>enum cars : std::uint32_t { ...\n</code></pre>\n<p>Returns:</p>\n<pre><code>4\n</code></pre>\n", "LastActivityDate": "2015-10-05T14:35:51.683"}, "bq_ids": {"n4140": {"so_32950709_32950795_1": {"section_id": 5466, "quality": 0.9622641509433962, "length": 51}, "so_32950709_32950795_0": {"section_id": 5464, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_32950709_32950795_1": {"section_id": 5252, "quality": 0.9622641509433962, "length": 51}, "so_32950709_32950795_0": {"section_id": 5251, "quality": 0.6956521739130435, "length": 16}}, "n4659": {"so_32950709_32950795_1": {"section_id": 6900, "quality": 0.9622641509433962, "length": 51}, "so_32950709_32950795_0": {"section_id": 6898, "quality": 0.9130434782608695, "length": 21}}}, "32950795": {"ParentId": "32950709", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2015-10-05T14:15:14.917", "Score": "11", "LastEditorUserId": "464581", "LastEditDate": "2015-10-05T15:27:04.847", "Id": "32950795", "OwnerUserId": "493122", "Body": "<p>From \u00a77.2/5 of the C++ standard, you have that in your case the underlying type is not <em>fixed</em>:</p>\n<blockquote>\n<p id=\"so_32950709_32950795_0\">The underlying type can be explicitly specified using an enum-base. For a scoped enumeration type, the underlying type is int if it is not explicitly specified. In both of these cases, the underlying type is said to be fixed. [...]</p>\n</blockquote>\n<p>Which leads to \u00a77.2/7:</p>\n<blockquote>\n<p id=\"so_32950709_32950795_1\">For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can represent all the enumerator values defined in the enumeration. If no integral type can represent all the enumerator values, the enumeration is ill-formed. It is implementation-defined which integral type is used as the underlying type except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0.</p>\n</blockquote>\n<hr>\n<p>Summing up, for your enumeration the underlying type is at most an <code>int</code> or <code>unsigned int</code>. You can check the size via <code>sizeof</code>, and the type via <code>typeid</code>. Example checking code that prettifies the result with g++ (not necessary with Visual C++):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;     // std::type_info\n#include &lt;type_traits&gt;  // std::underlying_type\nusing namespace std;\n\nint const bits_per_byte = CHAR_BIT;\n\n#ifdef __GNUC__\n#   include &lt;cxxabi.h&gt;      // abi::*, free\n#   include &lt;string&gt;        // std::string\n\n    auto display_name( type_info const&amp; info )\n        -&gt; string\n    {\n        int   status;\n        char* demangled = abi::__cxa_demangle( info.name(), 0, 0, &amp;status );\n        string result = demangled;\n        free( demangled );\n        return result;\n    }\n#else\n    auto display_name( type_info const&amp; info )\n        -&gt; string\n    { return info.name(); }    \n#endif // __GNUC__\n\nenum Cars {\n    Toyota, Suzuki, Volkswa, Mitsubish, Alfarome, Holden, Bradleys\n    };\n\nauto main() -&gt; int\n{\n    using Cars_type = typename underlying_type&lt; Cars &gt;::type;\n    type_info const&amp; info = typeid( Cars_type );\n    cout &lt;&lt; \"This compiler is \" &lt;&lt; bits_per_byte*sizeof(void*) &lt;&lt; \"-bit.\\n\";\n    cout &lt;&lt; \"Underlying type is '\" &lt;&lt; display_name( info ) &lt;&lt; \"'.\\n\";\n    cout &lt;&lt; \"Size = \" &lt;&lt; sizeof( Cars ) &lt;&lt; \" bytes.\\n\";\n}\n</code></pre>\n<p>Output with MinGW g++ (tdm64-1) 5.1.0:</p>\n<pre>\nThis compiler is 64-bit.\nUnderlying type is 'unsigned int'.\nSize = 4 bytes.\n</pre>\n</hr>", "LastActivityDate": "2015-10-05T15:27:04.847"}});