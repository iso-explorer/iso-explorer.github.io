post_cb({"bq_ids": {"n4140": {"so_18818909_18818960_0": {"length": 68, "quality": 0.918918918918919, "section_id": 764}}, "n3337": {"so_18818909_18818960_0": {"length": 68, "quality": 0.918918918918919, "section_id": 751}}, "n4659": {"so_18818909_18818960_0": {"length": 66, "quality": 0.8918918918918919, "section_id": 824}}}, "18818909": {"ViewCount": "468", "Body": "<p>Given two large unordered_map, say map_a, map_b. How to effectively decide map_a has the same information as map_b?\nFor example, if map_a is <code>{'a':3, 'b':2}</code> and map_b is <code>{'a':3,'b':2}</code> then they are the same. That is, for each key k in map_a, map_a[k]=map_b[k].</p>\n<p>My question is how to decide this problem effectively. I know the worst time is <code>O( max{map_a.size(), map_b.size()} )</code>. But there are some observations which can quickly decide that map_a is not equivalent to map_b. For example, map_a.size()!=map_b.size().</p>\n<p>Are there any other observations? Can we use the bucket_count() and bucket_size()?</p>\n<p>W.l.o.g, let's suppose that map_a and map_b has the same hash function and (key,value) type.</p>\n", "AcceptedAnswerId": "18818960", "Title": "How to decide whether two LARGE unordered_map are equal?", "CreationDate": "2013-09-16T00:27:57.713", "Id": "18818909", "CommentCount": "0", "LastEditDate": "2013-09-16T10:09:04.180", "PostTypeId": "1", "LastEditorUserId": "1254356", "LastActivityDate": "2013-09-16T10:09:04.180", "Score": "5", "OwnerUserId": "1593180", "Tags": "<c++><stl>", "AnswerCount": "1"}, "18818960": {"Id": "18818960", "PostTypeId": "2", "Body": "<p>The problem is harder than it may seem, perhaps O( log( load_factor ) * size ), because the elements don't need to be in the same order in each map. (Hence <code>unordered_map</code>.) Each pair of corresponding buckets needs to be sorted (by hash value) before comparison.</p>\n<p>According to 23.2.5/12,</p>\n<blockquote>\n<p id=\"so_18818909_18818960_0\">For unordered_set and unordered_map, the complexity of operator== (i.e., the number of calls to the == operator of the value_type, to the predicate returned by key_equal(), and to the hasher returned by hash_function()) is proportional to N in the average case and to N2 in the worst case, where N is a.size(). For unordered_multiset and unordered_multimap, the complexity of operator== is proportional to \u2211Ei2 in the average case and to N2 in the worst case, where N is a.size(), and Ei is the size of the ith equivalent-key group in a. However, if the respective elements of each corresponding pair of equivalent-key groups Eai and Ebi are arranged in the same order (as is commonly the case, e.g., if a and b are unmodified copies of the same container), then the average-case complexity for unordered_multiset and unordered_multimap becomes proportional to N (but worst-case complexity remains O(N2), e.g., for a pathologically bad hash function).</p>\n</blockquote>\n<p>That's rather a lot to format properly for this site, but note that \"N2\" is supposed to be N<sup>2</sup>.</p>\n<p>My log(load_factor) analysis may have been an oversimplification: I think the algorithm is actually required not to allocate memory. My recommendation is not to try this at home. You should rely on your standard library's implementation of <code>operator ==</code>, because it can rely on internal invariants that may not be guaranteed by the standard.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2013-09-16T09:10:56.867", "Score": "4", "CreationDate": "2013-09-16T00:37:54.860", "ParentId": "18818909", "CommentCount": "0", "OwnerUserId": "153285", "LastEditDate": "2013-09-16T09:10:56.867"}});