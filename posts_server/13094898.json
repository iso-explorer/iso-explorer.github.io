post_cb({"13095136": {"Id": "13095136", "PostTypeId": "2", "Body": "<p>Good question; I've relied on that feature for years without thinking about it. I looked through several C++ books to find an answer, including Stroustrup's <em>The C++ Programming Language</em> and <em>The Annotated C++ Reference Manual</em>, but none acknowledge or explain the difference.  But, I think I can reason through it.</p>\n<p>The reason, I believe, that your example works is that the bodies of your <code>test</code> and <code>printout</code> aren't truly where they appear in your file.  The code</p>\n<pre><code>class MyClass {\n  void someFun() {\n    x = 5;\n  }\n  int x;\n};\n</code></pre>\n<p>...which appears to violate the rule of having to declare variables before you use them, is actually equivalent to:</p>\n<pre><code>class MyClass {\n  void someFun();\n  int x;\n};\n\nvoid MyClass::someFun() {\n  x = 5;\n}\n</code></pre>\n<p>Once we rewrite it like that, it becomes apparent that the stuff inside your <code>MyClass</code> definition is actually a list of <em>declarations</em>.  And those can be in any order.  You're not relying on <code>x</code> until after it's been declared.  I know this to be true because if you were to rewrite the example like so,</p>\n<pre><code>void MyClass::someFun() {\n  x = 5;\n}\n\nclass MyClass {\n  void someFun();\n  int x;\n};\n</code></pre>\n<p>...it would no longer compile!  So the class definition comes first (with its complete list of members), and then your methods can use any member without regard for the order in which they're declared in the class.</p>\n<p>The last piece of the puzzle is that C++ prohibits declaring any class member outside of the class definition, so once the compiler processes your class definition, it knows the full list of class members.  This is stated on p.170 of Stroustrup's <em>The Annotated C++ Reference Manual</em>: \"The <em>member list</em> defines the full set of members of the class. No member can be added elsewhere.\"</p>\n<p>Thanks for making me investigate this; I learned something new today. :)</p>\n", "LastActivityDate": "2012-10-26T22:11:56.530", "CommentCount": "6", "CreationDate": "2012-10-26T22:11:56.530", "ParentId": "13094898", "Score": "12", "OwnerUserId": "1214939"}, "13095751": {"Id": "13095751", "PostTypeId": "2", "Body": "<p>Besides Philip's good response, Stroustrup gives a nice explanation of <em>Name Lookup Rules</em> in <em>The Design and Evolution of C++</em>. This is described in \"6.3 Clarifications\". In 6.3.1.1, <em>\"The ARM Name Lookup Rules\"</em>, he mentions 2 rules defined in the <em>ARM</em>:</p>\n<p>[1]The type redefinition rule:A type name may not be redefined in a class after it has been used there.</p>\n<p>[2] The rewrite rule: Member functions defined inline are analyzed as if they were defined immediately after the end of their class declarations.</p>\n<p>So in your case it would apply the rewrite rule (as Philip deduced), that's why you can forward reference those class members.</p>\n<p>This book may be mainly of historical interest (it's written in '94), but I think those rules are applied the same way today.</p>\n", "LastEditorUserId": "398041", "LastActivityDate": "2012-10-27T20:41:40.653", "Score": "1", "CreationDate": "2012-10-26T23:35:29.580", "ParentId": "13094898", "CommentCount": "0", "OwnerUserId": "398041", "LastEditDate": "2012-10-27T20:41:40.653"}, "13095199": {"Id": "13095199", "PostTypeId": "2", "Body": "<p>Just to make it clear, this is required by the C++ Standard, not just the way several compilers handle class definitions.</p>\n<p>N3242 3.3.7:</p>\n<blockquote>\n<p id=\"so_13094898_13095199_0\">The potential scope of a name declared in a class consists not only of the declarative region following the name's point of declaration, but also of all function bodies, <em>brace-or-equal-initializers</em> of non-static data members, and default arguments in that class (including such things in nested classes).</p>\n</blockquote>\n", "LastActivityDate": "2012-10-26T22:19:08.007", "CommentCount": "0", "CreationDate": "2012-10-26T22:19:08.007", "ParentId": "13094898", "Score": "4", "OwnerUserId": "459640"}, "bq_ids": {"n4140": {"so_13094898_13095199_0": {"length": 27, "quality": 0.9, "section_id": 7070}}, "n3337": {"so_13094898_13095199_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 6814}}, "n4659": {"so_13094898_13095199_0": {"length": 27, "quality": 0.9, "section_id": 8567}}}, "13094898": {"ViewCount": "2097", "Body": "<p>So I was learning about classes and I stumbled upon something I found was quite awkward to me.</p>\n<pre><code>class Nebla \n{\n    public:\n        int test()\n        {\n            printout();\n            return x;\n        }\n\n        void printout()\n        {\n            printout2();\n        }\n\n    private:\n        int x,y;\n        void printout2()\n        {\n            cout&lt;&lt;\"Testing my class\";\n        }\n};\n</code></pre>\n<p>I found that in a class I can use functions before I declare them (prototype them)</p>\n<blockquote>\n<p id=\"so_13094898_13094898_0\">You can see I used <code>printout()</code> , <code>printout2()</code> before decleration.</p>\n</blockquote>\n<p>And I can use variables also before declaring them</p>\n<blockquote>\n<p id=\"so_13094898_13094898_1\">You can see I did <code>return x</code>; before declareing x.</p>\n</blockquote>\n<p>Why can I use functions and variables in classes before declaration but outside the class if I do that, I get an error?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "13095136", "Title": "Do class functions/variables have to be declared before being used?", "CreationDate": "2012-10-26T21:48:19.403", "Id": "13094898", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-10-26T22:24:39.663", "LastEditorUserId": "933198", "LastActivityDate": "2012-10-27T20:41:40.653", "Score": "8", "OwnerUserId": "1356331", "Tags": "<c++><class><function><variables><prototype>", "AnswerCount": "4"}, "13094921": {"Id": "13094921", "PostTypeId": "2", "Body": "<p>The reason you are able to do this is because by the time you call <code>test</code>, <code>printout</code> or <code>printout2</code>, they will have already been created. If you call the function <em>outside</em> the arbitrary function before it's implementation, then you'll get an error.</p>\n<p>Think of class member-functions as being asynchronous with the flow of evaluation of the rest of the class. This won't work with stand alone functions, but you can access data members that haven't been instantiated yet. I'm not completely sure why we are able to do this, but I think it has to do with instantitation of the class object.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2012-10-26T22:04:46.327", "Score": "0", "CreationDate": "2012-10-26T21:50:15.517", "ParentId": "13094898", "CommentCount": "2", "OwnerUserId": "701092", "LastEditDate": "2012-10-26T22:04:46.327"}});