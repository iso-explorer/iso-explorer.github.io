post_cb({"29638071": {"ParentId": "29637156", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Both your calls are of the same type. We can verify this with a simple program:</p>\n<pre><code>int main()\n{\n    static_assert(std::is_same&lt;\n        decltype(new int(3)),\n        decltype(new int[(3)])\n    &gt;{}, \"wat\");\n}\n</code></pre>\n<p>That is noted in the standard in [expr.new]:</p>\n<blockquote>\n<p id=\"so_29637156_29638071_0\">When the allocated object is an array (that is, the noptr-new-declarator syntax is used or the new-type-id or\n  type-id denotes an array type), the new-expression yields a pointer to the initial element (if any) of the array.\n  [ Note: both <code>new int</code> and <code>new int[10]</code> have type <code>int*</code> and the type of <code>new int[i][10]</code> is <code>int (*)[10]</code>\n  \u2014end note ] The attribute-specifier-seq in a noptr-new-declarator appertains to the associated array type.</p>\n</blockquote>\n<p>So there is no way to distinguish a pointer to a single element from a pointer to an array <em>by its type</em>. You could pass in some additional tag though, like:</p>\n<pre><code>struct array_tag { };\nstruct single_tag { };\n\nf1(new int(3), single_tag{});\nf1(new int[3], array_tag{});\n</code></pre>\n<p>Or just explicitly specify the types (this would require changing a couple other signatures - <code>f1</code> would have to take a <code>T</code>, not a <code>T*</code>, etc):</p>\n<pre><code>f1(new int(3));\nf1&lt;int*&gt;(new int(3));\n\nf1&lt;int[]&gt;(new int[3]);\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-14T23:30:50.347", "Id": "29638071", "Score": "3", "CreationDate": "2015-04-14T21:55:50.223", "LastActivityDate": "2015-04-14T23:30:50.347"}, "bq_ids": {"n4140": {"so_29637156_29638071_0": {"section_id": 6086, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_29637156_29638071_0": {"section_id": 5854, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_29637156_29638071_0": {"section_id": 7582, "quality": 0.8717948717948718, "length": 34}}}, "29637156": {"CommentCount": "7", "ViewCount": "80", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-04-14T20:50:20.937", "LastActivityDate": "2015-04-14T23:30:50.347", "Title": "Correctly forward to specializations for dynamically allocated arrays", "AcceptedAnswerId": "29638071", "LastEditDate": "2015-04-14T22:11:42.960", "Id": "29637156", "Score": "2", "Body": "<p>I learned that you can specialize for dynamically allocated arrays with <code>T[]</code> : </p>\n<pre><code>template&lt;typename T&gt;\nclass C {}; \n\ntemplate&lt;typename T&gt;\nclass C&lt;T[]&gt; {}; \n</code></pre>\n<p>Now while trying to use such machinery, I seem to have trouble composing this feature (using it in an inner layer, eg inside a function template) : </p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class _Ty&gt;\nstruct OP\n{   \n    void operator()(_Ty *_Ptr) const noexcept\n    {   \n        std::cout &lt;&lt; \"single pointer\\n\"; \n        delete _Ptr;\n    }\n};\n\ntemplate&lt;class _Ty&gt;\nstruct OP&lt;_Ty[]&gt;\n{\n    void operator()(_Ty *_Ptr) const noexcept\n    {\n        std::cout &lt;&lt; \"dynamically allocated array\\n\"; \n        delete[] _Ptr;\n    }\n};\n\ntemplate&lt;typename T&gt;\nvoid f1(T *arg)\n{\n   OP&lt;T&gt;()(arg); \n}\n\n\nint main()\n{\n     f1(new int(3));  \n     f1(new int[(3)]);  \n}\n</code></pre>\n<p>The <a href=\"http://coliru.stacked-crooked.com/a/96478cded770df45\" rel=\"nofollow\">above</a> prints </p>\n<blockquote>\n<p id=\"so_29637156_29637156_0\">single pointer</p>\n<p id=\"so_29637156_29637156_1\">single pointer</p>\n</blockquote>\n<p>when it's clear that the second call is done with an array. How can I fix this, what am I doing wrong ? </p>\n", "Tags": "<c++><arrays><templates><template-specialization>", "OwnerUserId": "4224575", "AnswerCount": "1"}});