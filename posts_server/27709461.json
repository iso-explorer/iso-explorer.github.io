post_cb({"39821266": {"ParentId": "27709461", "CommentCount": "0", "Body": "<p>The answer by Columbo answers the question, but I had problems adapting to to an input stream. My use case was that I wanted to call lexical_cast to convert from string to T. Boost offers has_right_shift and has_left_shift, which worked and should allow more flexibility for similar constructs.</p>\n<pre><code>template &lt;typename T, typename=void&gt;\nstruct IsLexCastable : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct IsLexCastable&lt;T,\n        typename std::enable_if&lt;boost::has_right_shift&lt;T&gt;::value&gt;::type&gt;\n  : std::true_type {};\n</code></pre>\n", "OwnerUserId": "2061551", "PostTypeId": "2", "Id": "39821266", "Score": "0", "CreationDate": "2016-10-02T20:17:48.510", "LastActivityDate": "2016-10-02T20:17:48.510"}, "27709701": {"ParentId": "27709461", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Your expression is not sufficient, as the <code>lexical_cast</code> function template takes everything and only reports errors via an internal <code>static_assert</code>. Instead test whether inserting the object into an <code>std::ostream</code> is valid:</p>\n<pre><code>template &lt;typename T, typename=void&gt;\nstruct IsLexCastable : std::false_type {};\n\n// Can be extended to consider std::wostream as well for completeness\ntemplate &lt;typename T&gt;\nstruct IsLexCastable&lt;T,\n            decltype(void(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;()))&gt;\n  : std::true_type {};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6e9f34665aacb9cb\" rel=\"nofollow\"><strong>Demo</strong></a>.<br>\nThat requirement is called <em>OutputStreamable</em> by <a href=\"http://www.boost.org/doc/libs/1_40_0/libs/conversion/lexical_cast.htm#lexical_cast\" rel=\"nofollow\"><strong>the documentation</strong></a>, and the direct one imposed onto the source type.</br></p>\n<p><hr/></p>\n<h3>Why did your implementation not work?</h3>\n<p><code>decltype</code> only causes the <strong>instantiation of the declaration</strong> of a function template. The internal static assertion is triggered inside the definition of <code>lexical_cast</code> though, hence it cannot be used in SFINAE.</p>\n<p>[temp.inst]/10:</p>\n<blockquote>\n<p id=\"so_27709461_27709701_0\">If a function template or a member function template specialization\n  <strong>is used in a way that involves overload resolution, a declaration of the specialization is implicitly instantiated (14.8.3).</strong></p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-12-30T17:55:56.820", "Id": "27709701", "Score": "4", "CreationDate": "2014-12-30T17:19:07.057", "LastActivityDate": "2014-12-30T17:55:56.820"}, "27709461": {"CommentCount": "0", "AcceptedAnswerId": "27709701", "CreationDate": "2014-12-30T17:00:36.667", "LastActivityDate": "2016-10-02T20:17:48.510", "PostTypeId": "1", "ViewCount": "380", "FavoriteCount": "1", "Title": "Check if type can be an argument to boost::lexical_cast<string>", "Id": "27709461", "Score": "4", "Body": "<p>I have the following traits class(<code>IsLexCastable</code>) to check if a type can be converted to a string by calling <code>boost::lexical_cast&lt;string&gt;</code>. It erroneously returns <code>true</code> for <code>vector&lt;int&gt;</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n#include &lt;boost/lexical_cast.hpp&gt;\n\nusing namespace std;\nusing namespace boost;\n\nnamespace std\n{\n/// Adding to std since these are going to be part of it in C++14.\ntemplate &lt;bool B, typename T = void&gt;\nusing enable_if_t = typename std::enable_if&lt;B, T&gt;::type;\n}\n\ntemplate &lt;typename T, typename = void&gt;\nstruct IsLexCastable : std::false_type\n{\n};\n\ntemplate &lt;typename T&gt;\nstruct IsLexCastable&lt;T, std::enable_if_t&lt;std::is_same&lt;std::string, decltype(boost::lexical_cast&lt;std::string&gt;(std::declval&lt;T&gt;()))&gt;::value&gt; &gt; : std::true_type\n{\n};\n\nint main()\n{\n  vector&lt;int&gt; a = {1, 2, 3};\n  //  cout &lt;&lt; lexical_cast&lt;string&gt;(a) &lt;&lt; endl;\n  cout &lt;&lt; IsLexCastable&lt;decltype(a)&gt;::value &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>This program prints <code>1</code>, but <code>lexical_cast&lt;string&gt;(a)</code> results in a compile error. What is the right way to implement <code>IsLexCastable</code>?</p>\n<p>(This was compiled with <code>g++48 -std=c++11</code>, and <code>boost 1.55.0</code>.)</p>\n", "Tags": "<c++><templates><c++11><boost><template-meta-programming>", "OwnerUserId": "862351", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27709461_27709701_0": {"section_id": 242, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_27709461_27709701_0": {"section_id": 234, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_27709461_27709701_0": {"section_id": 249, "quality": 0.9333333333333333, "length": 14}}}});