post_cb({"40203287": {"Id": "40203287", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38555749_40203287_0\"><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">14.5.7 Alias templates</a></p>\n<p id=\"so_38555749_40203287_1\">1 A template-declaration in which the declaration is an alias-declaration \n     (Clause 7) declares the identifier to be a alias template. An alias \n     template is a name for a family of types. The name of the alias \n     template is a template-name.</p>\n<p id=\"so_38555749_40203287_2\">2 When a template-id refers to the specialization of an alias \n     template, it is equivalent to the associated type obtained by \n     substitution of its template-arguments for the template-parameters \n     in the type-id of the alias template.</p>\n</blockquote>\n<p>In your example <code>Foo</code> and <code>Pack&lt;Foo&gt;::Container</code> (no parameter list) are template-names that don't represent a type but only a template. For example <code>Foo&lt;int&gt;</code> and <code>Pack&lt;Foo&gt;::Container&lt;int&gt;</code> would be template-ids and would thus be equivalent.</p>\n<p>To my knowledge the standard doesn't specify any equivalence relation between template-names, so MSVC and Clang are right to assume that only identical template-names are equivalent.</p>\n<p>But you could still specialize or overload based on the template-id if that is sufficient for your specific use case. e.g.:</p>\n<pre><code>template&lt; typename C &gt;\nstruct IsFoo : std::false_type\n{\n};\n\ntemplate&lt;class T&gt;\nstruct IsFoo&lt;Foo&lt;T&gt;&gt; : std::true_type\n{\n};\n\nstatic_assert( IsFoo&lt;Foo&lt;int&gt;&gt;::value,                             \"Only foos!\" );\nstatic_assert( IsFoo&lt; Pack&lt;Foo&gt;::Container&lt;int&gt; &gt;::value,          \"Only foos!\" );\nstatic_assert( IsFoo&lt; Pack&lt;Bar&gt;::Container&lt;int&gt; &gt;::value == false, \"Not a foo!\" );\n</code></pre>\n<p>or </p>\n<pre><code>template&lt;class T&gt;\nvoid do_stuff(const T&amp;) {}\n\ntemplate&lt;class T&gt;\nvoid do_stuff(const Foo&lt;T&gt;&amp;) {}\n</code></pre>\n", "LastActivityDate": "2016-10-23T13:08:15.557", "CommentCount": "0", "CreationDate": "2016-10-23T13:08:15.557", "ParentId": "38555749", "Score": "1", "OwnerUserId": "5622936"}, "bq_ids": {"n4140": {"so_38555749_40203287_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 165}, "so_38555749_40203287_2": {"length": 17, "quality": 1.0, "section_id": 166}}, "n3337": {"so_38555749_40203287_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 159}, "so_38555749_40203287_2": {"length": 17, "quality": 1.0, "section_id": 160}}, "n4659": {"so_38555749_40203287_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 169}, "so_38555749_40203287_2": {"length": 17, "quality": 1.0, "section_id": 170}}}, "38555749": {"ViewCount": "317", "Body": "<p>Assuming we have</p>\n<pre><code>template&lt;typename T&gt; \nstruct Foo\n{\n};\n\ntemplate&lt;typename T&gt; \nstruct Bar\n{\n};\n\ntemplate&lt; template&lt;typename T&gt; class C &gt;\nstruct Pack\n{\n    template&lt;typename T&gt;\n    using Container = C&lt;T&gt;;\n};\n</code></pre>\n<p>Are <code>Foo</code> and <code>Pack&lt;Foo&gt;::Container</code> supposed to be treated as the same thing if we have a specialization for <code>Foo</code>? That is:</p>\n<pre><code>template&lt; template&lt;typename T&gt; class C &gt;\nstruct IsFoo : std::false_type\n{\n};\n\ntemplate&lt;&gt;\nstruct IsFoo&lt;Foo&gt; : std::true_type\n{\n};\n\nstatic_assert( IsFoo&lt;Foo&gt;::value,                             \"Only foos!\" );\nstatic_assert( IsFoo&lt; Pack&lt;Foo&gt;::Container &gt;::value,          \"Only foos!\" ); // ???\nstatic_assert( IsFoo&lt; Pack&lt;Bar&gt;::Container &gt;::value == false, \"Not a foo!\" );\n</code></pre>\n<p>Is that second assertion correct? What is the expected behavior? Heck, is what I am trying to do even valid?</p>\n<p>I tested it on three compilers and I got different results. It seems that for\nMSVC and CLang, <code>Foo</code> and <code>Pack&lt;Foo&gt;::Container</code> are not the same thing, but <a href=\"http://coliru.stacked-crooked.com/a/622df10803be63cd\">GCC disagrees</a>, which is cool, because that is exactly what I wanted.</p>\n<p>So, who is right? </p>\n<p>PS: I am not sure if I am using the correct terminology on the title, nor inside the body of my question. Suggestions and corrections are more than welcome.</p>\n", "Title": "Template alias and specialization", "CreationDate": "2016-07-24T19:09:17.123", "LastActivityDate": "2016-10-23T13:08:15.557", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "Id": "38555749", "Score": "19", "OwnerUserId": "1593842", "Tags": "<c++>", "AnswerCount": "1"}});