post_cb({"bq_ids": {"n4140": {"so_45751978_45753280_0": {"length": 9, "quality": 1.0, "section_id": 305}}, "n3337": {"so_45751978_45753280_0": {"length": 9, "quality": 1.0, "section_id": 296}}, "n4659": {"so_45751978_45753280_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 2142}, "so_45751978_45753280_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 2142}, "so_45751978_45753280_0": {"length": 9, "quality": 1.0, "section_id": 312}}}, "45751978": {"ViewCount": "311", "Body": "<p><strong>TL;DR:</strong>\nCan I expect that the code below will compile on any c++17 conformant c++ toolchain (based on the current c++17 proposal) and the failure of MSVC to do so is a bug in their implementation?</p>\n<pre><code>#include &lt;string_view&gt;\n\nstruct Foo : std::string_view {};\n\nint main() {\n  Foo f1{};\n  Foo f2{};\n  return f1 == f2;\n}\n</code></pre>\n<p><strong>Explanation:</strong><br>\nI have a class that is derived from <code>std::string_view</code> and doesn't implement its own comparison operators, because the <code>std::string_view</code> semantics are exactly what I need and I also want it to be comparable to e.g. a <code>std::string</code>.   </br></p>\n<p>However, if I try to compare two instances of that class, MSVC 2017 complains about multiple overloads with similar conversions:</p>\n<pre><code>example.cpp\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xlocale(314): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc\n8 : &lt;source&gt;(8): error C2666: 'std::operator ==': 3 overloads have similar conversions\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(336): note: could be 'bool std::operator ==(const std::exception_ptr &amp;,const std::exception_ptr &amp;) throw()' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(341): note: or       'bool std::operator ==(std::nullptr_t,const std::exception_ptr &amp;) throw()' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/exception(346): note: or       'bool std::operator ==(const std::exception_ptr &amp;,std::nullptr_t) throw()' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(362): note: or       'bool std::operator ==(const std::error_code &amp;,const std::error_code &amp;) noexcept' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(370): note: or       'bool std::operator ==(const std::error_code &amp;,const std::error_condition &amp;) noexcept' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(378): note: or       'bool std::operator ==(const std::error_condition &amp;,const std::error_code &amp;) noexcept' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/system_error(386): note: or       'bool std::operator ==(const std::error_condition &amp;,const std::error_condition &amp;) noexcept' [found using argument-dependent lookup]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xstring(970): note: or       'bool std::operator ==&lt;char,std::char_traits&lt;char&gt;&gt;(const std::basic_string_view&lt;char,std::char_traits&lt;char&gt;&gt;,const std::basic_string_view&lt;char,std::char_traits&lt;char&gt;&gt;) noexcept'\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xstring(980): note: or       'bool std::operator ==&lt;char,std::char_traits&lt;char&gt;,Foo&amp;,void&gt;(_Conv,const std::basic_string_view&lt;char,std::char_traits&lt;char&gt;&gt;) noexcept(&lt;expr&gt;)'\n        with\n        [\n            _Conv=Foo &amp;\n        ]\n/opt/compiler-explorer/windows/19.10.25017/lib/native/include/xstring(990): note: or       'bool std::operator ==&lt;char,std::char_traits&lt;char&gt;,Foo&amp;,void&gt;(const std::basic_string_view&lt;char,std::char_traits&lt;char&gt;&gt;,_Conv) noexcept(&lt;expr&gt;)'\n        with\n        [\n            _Conv=Foo &amp;\n        ]\n8 : &lt;source&gt;(8): note: while trying to match the argument list '(Foo, Foo)'\nMicrosoft (R) C/C++ Optimizing Compiler Version 19.10.25017 for x64\nCopyright (C) Microsoft Corporation.  All rights reserved.\nCompiler exited with result code 2\n</code></pre>\n<p>I do not know, why the the first few overloads (e.g. with <code>std::error_code</code>) are listed at all. As the error message itself only talks about 3 overloads I guess they are only there for completeness, but are not part of the problem. </p>\n<p>What confuses me however are those two overloads:</p>\n<pre><code>bool std::operator ==&lt;char,std::char_traits&lt;char&gt;,Foo&amp;,void&gt;(_Conv,const std::basic_string_view&lt;char,std::char_traits&lt;char&gt;&gt;) noexcept(&lt;expr&gt;)\nbool std::operator ==&lt;char,std::char_traits&lt;char&gt;,Foo&amp;,void&gt;(const std::basic_string_view&lt;char,std::char_traits&lt;char&gt;&gt;,_Conv) noexcept(&lt;expr&gt;)\n</code></pre>\n<p>I could not find any mention of them on <code>cppreference.com</code> and the code compiles fine under clang and gcc: <a href=\"https://godbolt.org/g/4Lj5qv\" rel=\"nofollow noreferrer\">https://godbolt.org/g/4Lj5qv</a>, so they are probably not present in their implementation.</p>\n<p><strong>So my question is</strong> </p>\n<ul>\n<li>Is their existence actually allowed (or even mandated) by the expected c++17 standard or is that a bug in MSVC? </li>\n<li>If something like this is allowed in a standard conforming c++ standard library, is there a simple workaround that doesn't require me to implement all the comparators myself (I know, they are trivial to write, but it should imho not be necessary and I'd have to repeat the process for multiple types).</li>\n</ul>\n<p><strong>EDIT</strong>:<br>\nJust for reference, the actual <code>Foo</code> is an immutable string class very similar to this one: <a href=\"https://codereview.stackexchange.com/questions/116010/yet-another-immutable-string\">https://codereview.stackexchange.com/questions/116010/yet-another-immutable-string</a>, but in order to simplify the design I wanted to replace my hand-rolled <code>str_ref</code> with <code>std::string_view</code></br></p>\n", "AcceptedAnswerId": "45753280", "Title": "Comparison for objects derived from std::string_view is ambiguous in MSVC", "CreationDate": "2017-08-18T08:23:59.267", "Id": "45751978", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-08-22T15:58:00.657", "LastEditorUserId": "2881849", "LastActivityDate": "2017-08-22T15:58:00.657", "Score": "7", "OwnerUserId": "2881849", "Tags": "<c++><visual-c++><c++1z><c++-standard-library>", "AnswerCount": "1"}, "45753280": {"Id": "45753280", "PostTypeId": "2", "Body": "<p>Yes you should expect your code to work; template argument deduction can deduce the base class in function calls, see <a href=\"http://eel.is/c++draft/temp.deduct.call#4.3\" rel=\"nofollow noreferrer\">[temp.deduct.call]/4.3</a></p>\n<blockquote>\n<p id=\"so_45751978_45753280_0\">\u2014 If <code>P</code> is a class and <code>P</code> has the form <em>simple-template-id</em>, then the transformed <code>A</code> can be a derived class of the deduced <code>A</code>.</p>\n</blockquote>\n<p><strong>The issue with VS 2017 (15.3)</strong> is - the standard also has provisions for situations when one of the arguments is <em>implicitly-convertible</em> to <code>std::string_view</code>, see <a href=\"http://eel.is/c++draft/string.view#comparison\" rel=\"nofollow noreferrer\">[string.view.comparison]</a>:</p>\n<blockquote>\n<p id=\"so_45751978_45753280_1\">Let <code>S</code> be <code>basic_\u00adstring_\u00adview&lt;charT, traits&gt;</code>, and <code>sv</code> be an\n  instance of <code>S</code>. Implementations shall provide sufficient additional\n  overloads marked <code>constexpr</code> and <code>noexcept</code> so that an object <code>t</code> with\n  an implicit conversion to <code>S</code> can be compared according to Table 67.</p>\n<p id=\"so_45751978_45753280_2\">Table 67 \u2014 Additional <code>basic_\u00adstring_\u00adview</code> comparison overloads</p>\n<ul>\n<li>Expression <code>t == sv</code>  equivalent to: <code>S(t) == sv</code></li>\n<li>Expression <code>sv == t</code>  equivalent to: <code>sv == S(t)</code></li>\n<li>. . .</li>\n</ul>\n<p id=\"so_45751978_45753280_3\">[\u2009Example: A sample conforming implementation for <code>operator==</code> would be:</p>\n<pre><code>template&lt;class T&gt; using __identity = decay_t&lt;T&gt;;\ntemplate&lt;class charT, class traits&gt;\n  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,\n                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {\n    return lhs.compare(rhs) == 0;\n  }\ntemplate&lt;class charT, class traits&gt;\n  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; lhs,\n                            __identity&lt;basic_string_view&lt;charT, traits&gt;&gt; rhs) noexcept {\n    return lhs.compare(rhs) == 0;\n  }\ntemplate&lt;class charT, class traits&gt;\n  constexpr bool operator==(__identity&lt;basic_string_view&lt;charT, traits&gt;&gt; lhs,\n                            basic_string_view&lt;charT, traits&gt; rhs) noexcept {\n    return lhs.compare(rhs) == 0;\n  }\n</code></pre>\n<p id=\"so_45751978_45753280_4\">\u2014\u2009end example\u2009]</p>\n</blockquote>\n<p>This causes a problem in VS 2017 (15.3) because:</p>\n<ul>\n<li><p>The MSVC compiler can't handle <a href=\"https://stackoverflow.com/questions/45769950/partial-ordering-of-function-templates-and-non-deduced-context-not-working-in-ms\">partial ordering of function templates</a> w.r.t. non-deduced context (thanks @T.C.), so the implementation mentioned in the standard is <strong>not possible</strong></p></li>\n<li><p>Consequently, the MSVC standard library works around that with SFINAE for overloads #2 and #3, see <code>xstring</code>:</p></li>\n</ul>\n<blockquote id=\"so_45751978_45753280_5\">\n<pre><code>template&lt;class _Elem,\n  class _Traits,\n  class _Conv, // TRANSITION, VSO#265216\n  class = enable_if_t&lt;is_convertible&lt;_Conv, basic_string_view&lt;_Elem, _Traits&gt;&gt;::value&gt;&gt;\n  _CONSTEXPR14 bool operator==(_Conv&amp;&amp; _Lhs, const basic_string_view&lt;_Elem, _Traits&gt; _Rhs)\n      _NOEXCEPT_OP(_NOEXCEPT_OP((basic_string_view&lt;_Elem, _Traits&gt;(_STD forward&lt;_Conv&gt;(_Lhs)))))\n  {   // compare objects convertible to basic_string_view instances for equality\n  return (_Rhs._Equal(_STD forward&lt;_Conv&gt;(_Lhs)));\n  }\n\ntemplate&lt;class _Elem,\n  class _Traits,\n  class _Conv, // TRANSITION, VSO#265216\n  class = enable_if_t&lt;is_convertible&lt;_Conv, basic_string_view&lt;_Elem, _Traits&gt;&gt;::value&gt;&gt;\n  _CONSTEXPR14 bool operator==(const basic_string_view&lt;_Elem, _Traits&gt; _Lhs, _Conv&amp;&amp; _Rhs)\n      _NOEXCEPT_OP(_NOEXCEPT_OP((basic_string_view&lt;_Elem, _Traits&gt;(_STD forward&lt;_Conv&gt;(_Rhs)))))\n  {   // compare objects convertible to basic_string_view instances for equality\n  return (_Lhs._Equal(_STD forward&lt;_Conv&gt;(_Rhs)));\n  }\n</code></pre>\n</blockquote>\n<p>Unfortunately this is <em>not the same as what was meant in the standard</em> -  since the signature of these overloads differs from the original one, and <code>Foo&amp;&amp;</code> is a better match than <code>std::string_view</code> (again thanks @T.C.), no partial ordering between #1, #2 and #3 is performed - overload resolution selects #2 and #3 as better candidates. Now these two are truly ambiguous - both are viable yet neither is more specialized.</p>\n<p>As a workaround you can implement comparators for your types, or just a generic comparator for when both sides are convertible to <code>string_view</code>:</p>\n<pre><code>#include &lt;string_view&gt;\n\ntemplate&lt;class T, class T2,\n  class = std::enable_if_t&lt;std::is_convertible&lt;T, std::string_view&gt;::value&gt;,\n  class = std::enable_if_t&lt;std::is_convertible&lt;T2, std::string_view&gt;::value&gt;&gt;\nconstexpr bool operator==(T&amp;&amp; lhs, T2&amp;&amp; rhs) noexcept\n{\n  return lhs.compare(std::forward&lt;T2&gt;(rhs));\n}\n\nstruct Foo : std::string_view {};\n\nint main() {\n  Foo f1{};\n  Foo f2{};\n  return f1 == f2;\n}\n</code></pre>\n", "LastEditorUserId": "485343", "LastActivityDate": "2017-08-21T20:26:33.133", "Score": "6", "CreationDate": "2017-08-18T09:31:07.557", "ParentId": "45751978", "CommentCount": "4", "OwnerUserId": "485343", "LastEditDate": "2017-08-21T20:26:33.133"}});