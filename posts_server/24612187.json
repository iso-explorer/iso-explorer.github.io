post_cb({"24612793": {"ParentId": "24612187", "CommentCount": "0", "CreationDate": "2014-07-07T14:18:00.617", "OwnerUserId": "1221660", "PostTypeId": "2", "Id": "24612793", "Score": "0", "Body": "<pre><code>struct Counter {\n  int *ptr;\n  Counter() {ptr = new int; *ptr = 0;};\n  int next() {return (*ptr)++;}\n  ~Counter() {delete ptr;}\n};\n\nint function() {\n  static Counter c;\n  return c.next();\n}\n\nstruct Obj {\n  ~Obj() {cout&lt;&lt;function()&lt;&lt;endl;}  \n};\n\nObj obj;\n\nint main() {\n  cout&lt;&lt;function()&lt;&lt;endl;\n}\n</code></pre>\n<p>First, obj is being created. Then main calls function and Counter c is being created. When the program terminates it is possible that Counter c is destroyed before obj. When obj is destroyed the function should be executed but its static variable is gone... so undefined behavior.</p>\n", "LastActivityDate": "2014-07-07T14:18:00.617"}, "24612187": {"CommentCount": "4", "AcceptedAnswerId": "24612412", "OwnerDisplayName": "user2953119", "CreationDate": "2014-07-07T13:49:37.920", "LastActivityDate": "2014-07-07T14:18:00.617", "PostTypeId": "1", "ViewCount": "152", "FavoriteCount": "0", "Title": "Function, called during the object destruction", "Id": "24612187", "Score": "4", "Body": "<p>Could you provide code example reflecting the following rule:</p>\n<p>N3797 c++14, section 3.6.3/2:</p>\n<blockquote>\n<p id=\"so_24612187_24612187_0\">If a function contains a block-scope object of static or thread\n  storage duration that has been destroyed and the function is called\n  during the destruction of an object with static or thread storage\n  duration, the program has undefined behavior if the flow of control\n  passes through the definition of the previously destroyed block-scope\n  object.</p>\n</blockquote>\n", "Tags": "<c++><destructor>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24612187_24612187_0": {"section_id": 7157, "quality": 1.0, "length": 30}}, "n3337": {"so_24612187_24612187_0": {"section_id": 6901, "quality": 1.0, "length": 30}}, "n4659": {"so_24612187_24612187_0": {"section_id": 8664, "quality": 1.0, "length": 30}}}, "24612412": {"ParentId": "24612187", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2014-07-07T14:00:24.957", "Score": "10", "LastEditorUserId": "1782465", "LastEditDate": "2014-07-07T14:12:36.390", "Id": "24612412", "OwnerUserId": "1782465", "Body": "<p>Here you are:</p>\n<pre><code>void theFunction()\n{\n  static std::unique_ptr&lt;int&gt; foo { new int(42) };\n}\n\nstruct Creator\n{\n  Creator() { theFunction(); }\n};\n\n\nstruct Destroyer\n{\n  ~Destroyer() { theFunction(); }\n};\n\nDestroyer d;\nCreator c;\n\nint main()\n{}\n</code></pre>\n<p><code>d</code> is created first, but its constructor does nothing. Then, <code>c</code> is created, and as part of its initialisation, <code>theFunction()</code> is called, which causes the block-scope static-storage-duration variable <code>foo</code> to be initialised.</p>\n<p>Then, at program exit, static-storage objects are destroyed in reverse order of construction. So <code>foo</code> is destroyed, and then <code>c</code>. Finally, <code>d</code> is destroyed, but its destructor calls <code>theFunction()</code>, which causes control flow to reach the definition of <code>foo</code> again, after it's been destroyed already.</p>\n<p>The standard quote you've shown ascribes undefined behaviour to this.</p>\n", "LastActivityDate": "2014-07-07T14:12:36.390"}});