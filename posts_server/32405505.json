post_cb({"32405505": {"ViewCount": "88", "Body": "<p>While working on a simple project for reading structure datatypes from a binary file I came across a weird printf format type mishmash. Basically I use, most of the time the <code>%u</code> format to display unsigned integers, while in my struct is a member with the type <code>unsigned long long</code> displaying this data with the format character results in some weirdness and a few lost hours searching for a mistype. </p>\n<p>Here is an example:</p>\n<pre><code>struct bar {\n    unsigned long long ll;\n    unsigned int i1;\n    unsigned int i2;\n};\n\nint main(void)\n{\n    bar fubar;\n    fubar.ll = 1200;\n    fubar.i1 = 2500;\n    fubar.i2 = 450;\n\n    printf(\"Debt: %u Euro, Wallet: %u Euro, Outgoings: %u Euro.\\n\", fubar.ll, fubar.i1, fubar.i2);\n\n    return 0;\n}\n</code></pre>\n<p>Result:</p>\n<blockquote>\n<p id=\"so_32405505_32405505_0\">Debt: 1200 Euro, Wallet: 0 Euro, Outgoings: 2500 Euro.</p>\n<p id=\"so_32405505_32405505_1\">Compiled with Visual Studio 2013.</p>\n</blockquote>\n<p>Of course, when I use the <code>%llu</code> formating, everything works like expected. </p>\n<p>Is this caused, just because of the way <code>printf</code> works and is implemented?</p>\n", "AcceptedAnswerId": "32405765", "Title": "printf - Weird type mishmash result. Can someone explain this?", "CreationDate": "2015-09-04T19:46:20.570", "Id": "32405505", "CommentCount": "3", "LastEditDate": "2015-09-04T19:52:35.267", "PostTypeId": "1", "LastEditorUserId": "4555948", "LastActivityDate": "2015-09-04T20:21:14.530", "Score": "2", "OwnerUserId": "4555948", "Tags": "<c++><c><struct><printf>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32405505_32405618_2": {"length": 5, "quality": 0.625, "section_id": 7043}, "so_32405505_32405618_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 23}}, "n3337": {"so_32405505_32405618_2": {"length": 5, "quality": 0.625, "section_id": 6788}, "so_32405505_32405618_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 20}}, "n4659": {"so_32405505_32405618_2": {"length": 5, "quality": 0.625, "section_id": 7612}, "so_32405505_32405618_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 23}}}, "32405765": {"Id": "32405765", "PostTypeId": "2", "Body": "<p>I can't replicate this behavior on my computer with my compiler. However, the reported behavior is replicated at ideone : <a href=\"https://ideone.com/mCihqW\" rel=\"nofollow\">https://ideone.com/mCihqW</a> .</p>\n<p>The problem is that you are invoking undefined behavior. The second argument in the call to <code>printf</code> is an unsigned long long, but the first format directive is <code>%u</code>. That's a mismatch. You should have used <code>%llu</code> as the format directive. The format directives to <code>printf</code> must match the arguments. The function exhibits undefined behavior if they don't.</p>\n<p>There's no telling what the response to undefined behavior will be.</p>\n<p>I suspect that what's happening on your computer, with your compiler (and presumably at ideone.com as well) is that the call stack is populated with</p>\n<ul>\n<li>A pointer to the format directive (four or eight bytes),</li>\n<li>An unsigned long long with value 1200 (eight bytes),</li>\n<li>An unsigned int with value 2500 (four bytes), and</li>\n<li>An unsigned int with value 450 (another four bytes).</li>\n</ul>\n<p>On seeing the first <code>%u</code> in the format directive, <code>printf</code> examines the four bytes (not eight) after the format directive in the call stack. You presumably are running on a little endian computer. Those first four bytes interpreted as an unsigned int contain 1200, so that's what is printed.</p>\n<p>On seeing the next <code>%u</code>, <code>printf</code> examines the next four bytes in the call stack. These four bytes are the high order half of the unsigned long long your call pushed onto the call stack. Since 1200 is a lot smaller than 2<sup>32</sup>, the upper half of that unsigned long long is all bits zero. So <code>printf</code> prints 0 euros in your wallet.</p>\n<p>On seeing the last <code>%u</code>, <code>printf</code> once again examines the call stack, this time starting at eight bytes after the end of the format directive. The next four bytes, as an unsigned int, contain 2500. So that's what <code>printf</code> prints as outgoing.</p>\n<p>As mentioned above, I don't see this behavior on my computer. I see a different form of undefined behavior. Don't try to understand undefined behavior. Unless you truly know what you are doing and you are willing to live with the consequences (e.g., non-portability, nasal demons, hard drive erasure), don't invoke undefined behavior.</p>\n", "LastEditorUserId": "774499", "LastActivityDate": "2015-09-04T20:21:14.530", "Score": "2", "CreationDate": "2015-09-04T20:02:56.800", "ParentId": "32405505", "CommentCount": "0", "OwnerUserId": "774499", "LastEditDate": "2015-09-04T20:21:14.530"}, "32405618": {"Id": "32405618", "PostTypeId": "2", "Body": "<p><code>unsigned long long</code> is to be printed with <code>%llu</code>. Using mismatched type of variable invokes undefined behaviour.</p>\n<p>Quoting <code>C11</code>, chapter \u00a77.21.6.1</p>\n<blockquote>\n<p id=\"so_32405505_32405618_0\"><code>ll</code> (ell-ell) </p>\n<p id=\"so_32405505_32405618_1\">Specifies that a following d, i, o, u, x, or X conversion specifier applies to a\n  long long int or unsigned long long int argument;</p>\n</blockquote>\n<p>and regarding the UB,</p>\n<blockquote>\n<p id=\"so_32405505_32405618_2\">[..] If any argument is\n  not the correct type for the corresponding conversion specification, the behavior is\n  undefined.</p>\n</blockquote>\n", "LastActivityDate": "2015-09-04T19:53:12.493", "CommentCount": "0", "CreationDate": "2015-09-04T19:53:12.493", "ParentId": "32405505", "Score": "10", "OwnerUserId": "2173917"}});