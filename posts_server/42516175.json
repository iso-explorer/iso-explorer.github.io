post_cb({"42516175": {"CommentCount": "1", "ViewCount": "455", "CreationDate": "2017-02-28T18:27:14.367", "LastActivityDate": "2017-02-28T18:36:41.433", "Title": "I just can not understand DR 712", "AcceptedAnswerId": "42516291", "PostTypeId": "1", "Id": "42516175", "Score": "8", "Body": "<p><a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#712\" rel=\"noreferrer\">DR 712</a> was responsible for the change in the wording of [basic.def.odr]/2 in C++11 to the current wording today, in <a href=\"http://eel.is/c++draft/basic.def.odr#2\" rel=\"noreferrer\">[basic.def.odr]2 and 3</a>. But I'm still trying to understand the reason for the change, as stated in the DR, as follows:</p>\n<blockquote>\n<p id=\"so_42516175_42516175_0\"><strong>712. Are integer constant operands of a conditional-expression \u201cused?\u201d</strong></p>\n<p id=\"so_42516175_42516175_1\">In describing static data members initialized inside the class\n  definition, 9.2.3.2 [class.static.data] paragraph 3 says,</p>\n<p id=\"so_42516175_42516175_2\">The member shall still be defined in a namespace scope if it is used\n  in the program...  </p>\n<p id=\"so_42516175_42516175_3\">The definition of \u201cused\u201d is in 3.2 [basic.def.odr] paragraph 1:</p>\n<p id=\"so_42516175_42516175_4\">\u00a0\u00a0\u00a0\u00a0An object or non-overloaded function whose\n  name appears as a potentially-evaluated<br>\n  \u00a0\u00a0\u00a0\u00a0expression is used unless it is an object that satisfies the requirements for appearing in a \n  \u00a0\u00a0\u00a0\u00a0constant expression (5.20 [expr.const]) and the lvalue-to-rvalue conversion (4.1 [conv.lval])<br>\n  \u00a0\u00a0\u00a0\u00a0is immediately applied.  </br></br></p>\n<p id=\"so_42516175_42516175_5\">Now consider the following example:</p>\n<pre><code> struct S {\n      static const int a = 1;\n      static const int b = 2;\n };\n int f(bool x) {\n      return x ? S::a : S::b;\n }\n</code></pre>\n<p id=\"so_42516175_42516175_6\">According to the current wording of the Standard, this example\n  requires that <code>S::a</code> and <code>S::b</code> be defined in a namespace scope. The\n  reason for this is that, according to 5.16 [expr.cond] paragraph 4,\n  the result of this conditional-expression is an lvalue and the\n  lvalue-to-rvalue conversion is applied to that, not directly to the\n  object, <strong>so this fails the \u201cimmediately applied\u201d requirement</strong>. This is\n  surprising and unfortunate, since only the values and not the\n  addresses of the static data members are used. (This problem also\n  applies to the proposed resolution of issue 696.)</p>\n</blockquote>\n<p>Well, if the \"immediately applied requirement fails, then the expressions <code>S::a</code> and <code>S::b</code> in the conditional expression are <strong>not</strong> used (odr-used), and so, the respective static members of <code>struct S</code> will <strong>not</strong> need to be defined in namespace scope. But this is exactly the opposite of what the DR is saying. What am I missing??? </p>\n", "Tags": "<c++><c++11><language-lawyer><c++1z><one-definition-rule>", "OwnerUserId": "4463557", "AnswerCount": "2"}, "42516291": {"ParentId": "42516175", "CommentCount": "1", "CreationDate": "2017-02-28T18:34:24.647", "OwnerUserId": "4029014", "PostTypeId": "2", "Id": "42516291", "Score": "7", "Body": "<p>I think you're missing the point of the <code>used</code> definition: </p>\n<pre><code>it is used UNLESS ( (const) AND (immediately applied) )\n</code></pre>\n<p>So, if \"immediately applied\" is false, then the UNLESS is false, and thus it is used.</p>\n", "LastActivityDate": "2017-02-28T18:34:24.647"}, "42516332": {"ParentId": "42516175", "CommentCount": "0", "CreationDate": "2017-02-28T18:36:41.433", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "42516332", "Score": "2", "Body": "<blockquote>\n<p id=\"so_42516175_42516332_0\">An object or non-overloaded function whose name appears as a potentially-evaluated expression is used unless[...]</p>\n</blockquote>\n<p>Well, <code>S::a</code> and <code>S::b</code> appear in a potentially-evaluated expression within <code>f</code>.</p>\n<p>So they are used, unless either of the following exceptions apply.</p>\n<blockquote>\n<p id=\"so_42516175_42516332_1\">[...] it is an object that satisfies the requirements for appearing in a     constant expression (5.20 [expr.const]) and the lvalue-to-rvalue conversion (4.1 [conv.lval]) is immediately applied. </p>\n</blockquote>\n<p>Well, it is an object that satisfied the requirement for appearing in a constant expression.  So it passes that test.</p>\n<p>But the lvalue-to-rvalue conversion is not immediately applied.</p>\n<p>So it fails that test.</p>\n<p>As this entire section is under \"unless\", the failure means that the previous case applies; the object is considered \"used\".</p>\n", "LastActivityDate": "2017-02-28T18:36:41.433"}, "bq_ids": {"n4140": {"so_42516175_42516175_2": {"section_id": 5908, "quality": 0.8333333333333334, "length": 5}, "so_42516175_42516332_0": {"section_id": 7040, "quality": 0.875, "length": 7}}, "n3337": {"so_42516175_42516175_4": {"section_id": 6785, "quality": 0.7142857142857143, "length": 15}, "so_42516175_42516175_2": {"section_id": 5680, "quality": 0.8333333333333334, "length": 5}, "so_42516175_42516332_1": {"section_id": 6785, "quality": 0.7692307692307693, "length": 10}, "so_42516175_42516332_0": {"section_id": 6785, "quality": 0.875, "length": 7}}, "n4659": {"so_42516175_42516175_2": {"section_id": 7390, "quality": 0.8333333333333334, "length": 5}, "so_42516175_42516332_0": {"section_id": 8537, "quality": 0.875, "length": 7}}}});