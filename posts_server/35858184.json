post_cb({"bq_ids": {"n4140": {"so_35858184_35858302_1": {"length": 31, "quality": 0.96875, "section_id": 3344}}, "n3337": {"so_35858184_35858302_1": {"length": 31, "quality": 0.96875, "section_id": 3214}}}, "35858302": {"Id": "35858302", "PostTypeId": "2", "Body": "<p>In this case, your <code>Holder</code> object <code>h</code> is not fully constructued, that is that <code>h</code>'s constructor had not finished its construction before the stack unwinding process had begun.</p>\n<blockquote>\n<p id=\"so_35858184_35858302_0\">C++11 15.2 Constructors and destructors\n  (2)</p>\n<p id=\"so_35858184_35858302_1\">An object of any storage duration whose initialization or destruction\n  is terminated by an exception will have destructors executed for all\n  of its fully constructed subobjects (excluding the variant members of\n  a union-like class), that is, for subobjects for which the principal\n  constructor (12.6.2) has completed execution and the destructor has\n  not yet begun execution.</p>\n</blockquote>\n", "LastEditorUserId": "5699534", "LastActivityDate": "2016-03-08T03:53:24.153", "CommentCount": "2", "CreationDate": "2016-03-08T03:19:06.387", "ParentId": "35858184", "Score": "2", "OwnerUserId": "5699534", "LastEditDate": "2016-03-08T03:53:24.153"}, "35858184": {"ViewCount": "82", "Body": "<p>The output of the program below is:</p>\n<blockquote>\n<p id=\"so_35858184_35858184_0\">begin try<br>\n  Object() ctor<br>\n  begin catch<br/></br></br></p>\n</blockquote>\n<p>Why is the Holder class's destructor not called?  Is this a memory leak?  Is it possible to call the Holder class's destructor without rethrowing?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\n\n\nclass Object\n{\npublic:\n    Object() { std::cout &lt;&lt; \"Object() ctor\" &lt;&lt; std::endl; }\n    ~Object() { std::cout &lt;&lt; \"~Object() dtor\" &lt;&lt; std::endl; }\n};\n\nclass Holder\n{\n\npublic:\n    Holder() :myObjectP( new Object() )\n    {\n        throw std::exception();\n    }\n    ~Holder()\n    {\n        std::cout &lt;&lt; \"~Holder()\" &lt;&lt; std::endl;\n        delete myObjectP;\n    }\nprivate:\n    Object* myObjectP;\n\n};\n\nint main(int argc, char* argv[])\n{\n    try\n    {\n        std::cout &lt;&lt; \"begin try\" &lt;&lt; std::endl;\n        Holder h;\n    }\n    catch ( ... )\n    {\n        std::cout &lt;&lt; \"begin catch\" &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n", "Title": "RAII Failure - Why Does this C++ Code Leak? - throw in ctor in try block prevents dtor", "CreationDate": "2016-03-08T03:06:34.910", "LastActivityDate": "2016-03-08T03:53:24.153", "CommentCount": "2", "PostTypeId": "1", "Id": "35858184", "Score": "2", "OwnerUserId": "2779792", "Tags": "<c++><exception><memory-leaks><error-handling><exception-handling>", "AnswerCount": "1"}});