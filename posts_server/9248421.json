post_cb({"bq_ids": {"n4140": {"so_9248421_9248495_0": {"length": 28, "quality": 1.0, "section_id": 6246}}, "n3337": {"so_9248421_9248495_0": {"length": 28, "quality": 1.0, "section_id": 6006}}, "n4659": {"so_9248421_9248495_0": {"length": 28, "quality": 1.0, "section_id": 7750}}}, "9248495": {"Id": "9248495", "PostTypeId": "2", "Body": "<p>It looks like you are looking at the public interface of <code>typeinfo</code> from C++03. The standard doesn't restrict an implementation from adding members to a standard class (so long as there names come from those reserved to the implementation) to make things work.</p>\n<p>In the implementation that I am currently using <code>std::typeinfo</code> has a private member <code>const char* __name</code> which is used to implement the public member functions according to the requirements of the standard.</p>\n<p>ISO/IEC 14882:2011 17.5.2.3 Private members [objects.within.classes] / 1:</p>\n<blockquote>\n<p id=\"so_9248421_9248495_0\">Clauses 18 through 30 and Annex D do not specify the representation of classes, and intentionally omit specification of class members (9.2). An implementation may define static or non-static class members, or both, as needed to implement the semantics of the member functions specified in Clauses 18 through 30 and Annex D.</p>\n</blockquote>\n<p>Similar wording appears in C++03 17.3.2.3.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2012-02-12T11:52:50.360", "Score": "4", "CreationDate": "2012-02-12T11:43:07.720", "ParentId": "9248421", "CommentCount": "2", "OwnerUserId": "19563", "LastEditDate": "2012-02-12T11:52:50.360"}, "9248453": {"Id": "9248453", "PostTypeId": "2", "Body": "<p><code>typeid</code> is a keyword, not a function, so it need not and cannot be declared. It cannot be a function, since then the expression <code>typeid(T)</code> where <code>T</code> is a type would not be valid. It is implemented in the compiler, not in the library.</p>\n<p><code>typeinfo</code> doesn't need to have any data members; its <code>name</code> method is allowed to serve strings from what is effectively a <code>static</code> array of them. For example, consider this simple class that knows its own name:</p>\n<pre><code>// foo.h\nclass Foo {\n    // look ma, no data members!\n  public:\n    char const *name() const;\n};\n\n// foo.cpp\nchar const NAME[] = \"Foo\";\nchar const *Foo::name() const { return NAME; }\n</code></pre>\n<p>Apart from <code>name</code>, the main operation on <code>typeinfo</code> objects is <code>==</code>, which can be implemented by a simple pointer comparison between the objects; in that case, the compiler could construct a big <code>typeinfo []</code> array somewhere private and <code>typeid</code> would just index into that array to fetch the right <code>typeinfo</code> object. How it works, however, is implementation-dependent.</p>\n", "LastEditorUserId": "166749", "LastActivityDate": "2012-02-12T12:05:44.320", "Score": "4", "CreationDate": "2012-02-12T11:34:10.487", "ParentId": "9248421", "CommentCount": "7", "OwnerUserId": "166749", "LastEditDate": "2012-02-12T12:05:44.320"}, "9248421": {"ViewCount": "2024", "Body": "<pre><code>namespace std {\n class type_info\n {\n public:\n  virtual ~type_info(); //type_info can serve as a base class\n // enable comparison\n  bool operator==(const type_info&amp; rhs ) const;\n // return !( *this == rhs)\n  bool operator!=(const type_info&amp; rhs ) const;\n  bool before(const type_info&amp; rhs ) const; // ordering\n //return a C-string containing the type's name\n  const char* name() const;\n private:\n  //objects of this type cannot be copied\n     type_info(const type_info&amp; rhs );\n     type_info&amp; operator=(const type_info&amp; rhs);\n }; //type_info\n}  \n</code></pre>\n<p>In the declaration of type_info class ,I can't find any data member .So what is constructed or destructed ??  Also typeid isn't declared in it.So how type_info object is accessed by it?<br>\nIs above representation incomplete? <strong>Please tell about the type of data member in <code>type_info</code> class</strong> </br></p>\n", "AcceptedAnswerId": "9248495", "Title": "typeid and type_info class", "CreationDate": "2012-02-12T11:29:16.800", "Id": "9248421", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-02-12T12:05:44.320", "Score": "2", "OwnerUserId": "1152334", "Tags": "<c++><rtti><typeid>", "AnswerCount": "3"}, "9248461": {"Id": "9248461", "PostTypeId": "2", "Body": "<p>There are no data members you can access. <code>type_info</code> is implemented for you by the compiler; the details are not public. You obtain a <code>type_info</code> by using <code>typeid</code>. </p>\n<p>Don't worry, it's the compiler's job to make it all work.</p>\n", "LastActivityDate": "2012-02-12T11:37:29.027", "CommentCount": "0", "CreationDate": "2012-02-12T11:37:29.027", "ParentId": "9248421", "Score": "0", "OwnerUserId": "212870"}});