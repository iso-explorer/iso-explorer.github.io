post_cb({"8139264": {"ParentId": "8137917", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_8137917_8139264_0\">but this digresses from the text of the standard</p>\n</blockquote>\n<p>An implementation is allowed to add default arguments to any non-virtual library member function. This seems to permit precisely this kind of SFINAE tricks.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "8139264", "Score": "4", "CreationDate": "2011-11-15T16:00:34.463", "LastActivityDate": "2011-11-15T16:00:34.463"}, "8139273": {"ParentId": "8137917", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I was missing two pieces of information:</p>\n<ol>\n<li><p>gcc uses this:</p>\n<pre><code>template&lt;class _U1, class _U2, class = typename\n               std::enable_if&lt;std::is_convertible&lt;_U1, _T1&gt;::value\n                              &amp;&amp; std::is_convertible&lt;_U2, _T2&gt;::value&gt;::type&gt;\n        pair(_U1&amp;&amp; __x, _U2&amp;&amp; __y)\n        : first(std::forward&lt;_U1&gt;(__x)), second(std::forward&lt;_U2&gt;(__y)) { }\n</code></pre>\n<p>The trick seems to be in the default for the anonymous <code>class</code> template parameter. I'd not seen that before and <a href=\"http://definedbehavior.blogspot.com/2011/07/improving-conversions-of-stdpair-s.html\" rel=\"nofollow\">this implementation</a> didn't use that.</p></li>\n<li>I missed that gcc actually implemented this.</li>\n</ol>\n", "OwnerUserId": "168175", "LastEditorUserId": "168175", "LastEditDate": "2011-11-15T16:09:17.840", "Id": "8139273", "Score": "1", "CreationDate": "2011-11-15T16:00:57.827", "LastActivityDate": "2011-11-15T16:09:17.840"}, "bq_ids": {"n4140": {"so_8137917_8137917_0": {"section_id": 3967, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_8137917_8137917_0": {"section_id": 3824, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_8137917_8137917_0": {"section_id": 5572, "quality": 0.6666666666666666, "length": 8}}}, "8137917": {"CommentCount": "4", "CreationDate": "2011-11-15T14:31:02.067", "PostTypeId": "1", "AcceptedAnswerId": "8139264", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-15T16:09:17.840", "LastEditDate": "2017-05-23T10:34:58.877", "ViewCount": "294", "FavoriteCount": "1", "Title": "Excluding std::pair constructors that use explicit construction", "Id": "8137917", "Score": "11", "Body": "<p>Following on from <a href=\"https://stackoverflow.com/questions/8135555/how-to-avoid-implicit-calling-of-a-one-parameter-contructor-in-stdpair/8137176#8137176\">this answer</a>, it seems these constructors:</p>\n<pre><code>template&lt;class U, class V&gt; pair(pair&lt;U, V&gt;&amp;&amp; p); \ntemplate&lt;class U, class V&gt; pair(const pair&lt;U, V&gt;&amp; p);\n</code></pre>\n<p>are forbidden from participating in overload resolution when they would require an explicit conversion.</p>\n<p>From C++11 (\u00a720.3.2, n3290):</p>\n<blockquote>\n<p id=\"so_8137917_8137917_0\">Remark: This constructor shall not participate in overload resolution unless U is implicitly convertible to first_type and V is implicitly convertible to second_type. </p>\n</blockquote>\n<p>An interesting <a href=\"http://definedbehavior.blogspot.com/2011/07/improving-conversions-of-stdpair-s.html\" rel=\"nofollow noreferrer\">SFINAE workaround</a> has been suggested, but this digresses from the text of the standard.</p>\n<p>How can a conforming implementation possibly exclude this from overload resolution, short of some special internal compiler magic? I.e. can an implementation do this and can I duplicate it for my own type perhaps? There doesn't seem to be anyway of conforming with this! Is it a hangover from the removal of concepts from C++11?</p>\n<p>I did wonder about using a private constructor to do the SFINAE part and delegating from the public constructor, but it doesn't look like constructor delegation participates in SFINAE in such a way as to make that work.</p>\n", "Tags": "<c++><c++11><sfinae>", "OwnerUserId": "168175", "AnswerCount": "2"}});