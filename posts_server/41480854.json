post_cb({"bq_ids": {"n4140": {"so_41480854_41481150_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 7043}, "so_41480854_41481083_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 7043}, "so_41480854_41481150_3": {"length": 6, "quality": 0.5454545454545454, "section_id": 7043}, "so_41480854_41481083_0": {"length": 21, "quality": 1.0, "section_id": 7043}, "so_41480854_41481150_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 7043}}, "n3337": {"so_41480854_41481150_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 6788}, "so_41480854_41481083_1": {"length": 38, "quality": 0.926829268292683, "section_id": 6788}, "so_41480854_41481150_3": {"length": 6, "quality": 0.5454545454545454, "section_id": 6788}, "so_41480854_41481150_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 6788}, "so_41480854_41481083_0": {"length": 21, "quality": 1.0, "section_id": 6788}}, "n4659": {"so_41480854_41481150_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 8540}, "so_41480854_41481083_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 8540}, "so_41480854_41481150_3": {"length": 6, "quality": 0.5454545454545454, "section_id": 8540}, "so_41480854_41481083_0": {"length": 21, "quality": 1.0, "section_id": 8540}, "so_41480854_41481150_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 8540}}}, "41481150": {"Id": "41481150", "PostTypeId": "2", "Body": "<p>The answer you linked is for C language, and C is not C++. </p>\n<p>In C++ (quote from <a href=\"http://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\" rel=\"nofollow noreferrer\">en.cppreference</a>, see <a href=\"https://stackoverflow.com/a/41481083/2666289\">Danh's answer</a> for the standard), the rule is as follow:</p>\n<blockquote>\n<p id=\"so_41480854_41481150_0\">There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type [...], as long as all of the following is true: </p>\n<ul>\n<li><p id=\"so_41480854_41481150_1\">each definition consists of the same sequence of tokens (typically, appears in the same header file) </p></li>\n<li><p id=\"so_41480854_41481150_2\">[...]</p></li>\n</ul>\n<p id=\"so_41480854_41481150_3\">If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, <strong>the behavior is undefined</strong>. </p>\n</blockquote>\n<p>Your two definitions clearly violates the first condition, so the behavior is undefined.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-05T13:34:00.060", "Score": "7", "CreationDate": "2017-01-05T09:18:51.540", "ParentId": "41480854", "CommentCount": "7", "OwnerUserId": "2666289", "LastEditDate": "2017-05-23T12:01:49.547"}, "41480949": {"Id": "41480949", "PostTypeId": "2", "Body": "<p>Well, you're linking a C answer, but your question is about C++. Two languages, two standards, two answers. </p>\n<p>That said, I believe the C answer should <em>also</em> be that it's disallowed, per the One Definition Rule (which both languages have). Violating that is Undefined Behavior, which includes Segmentation Faults.</p>\n", "LastActivityDate": "2017-01-05T09:08:52.530", "CommentCount": "0", "CreationDate": "2017-01-05T09:08:52.530", "ParentId": "41480854", "Score": "0", "OwnerUserId": "15416"}, "41480854": {"ViewCount": "123", "Body": "<p>I've encountered a segmentation fault in a C++ program when two C++ files compiled together each include a different definition of a structure (with the same name).</p>\n<p>According to <a href=\"https://stackoverflow.com/questions/35034277/same-name-structure-with-different-definition-in-c\">this question</a>, I understand that structure definitions are restricted to the translation unit (the file and its inclusions). </p>\n<p>However, I get a crash when enabling -O1 or more at compile time.\nThe following minimal code reproduced the segfault. </p>\n<p>The code is in 3 short C++ files and 2 headers:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// td_collision1.cc\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include \"td1.h\"\n\nstruct Data\n{\n  long a;\n  double m1;\n  double m2;\n};\n\nvoid sz1(void) {\n    std::cout &lt;&lt; \"Size of in collision1: \" &lt;&lt; sizeof(struct Data) &lt;&lt; std::endl;\n}\n\nvoid collision1(void) {\n    struct Data tmp;\n    std::vector&lt;struct Data&gt; foo;\n    for (int i=0; i&lt;10; i++) {\n        tmp.a = 1;\n        tmp.m1 = 0;\n        tmp.m2 = 0;\n        foo.push_back(tmp);\n    }\n}\n// td1.h\n#include &lt;iostream&gt;\n\nvoid collision1(void);\nvoid sz1(void);\n\n// td_collision2.cc\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include \"td2.h\"\n\nstruct Data {\n  long a;\n  double m1; // note that there is one member less here\n};\n\nvoid sz2(void) {\n    std::cout &lt;&lt; \"Size of in collision2: \" &lt;&lt; sizeof(struct Data) &lt;&lt; std::endl;\n}\n\nvoid collision2(void) {\n    struct Data tmp2;\n    std::vector&lt;struct Data&gt; bar;\n    for (int i=0; i&lt;100; i++) {\n        tmp2.a = 1;\n        tmp2.m1 = 0;\n        bar.push_back(tmp2); // errors occur here\n    }\n}\n// td2.h\n#include &lt;iostream&gt;\n\nvoid collision2(void);\nvoid sz2(void);\n\n// td_main.cc\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include \"td1.h\"\n#include \"td2.h\"\n\nint main(void) {\n    sz1();\n    sz2();\n    collision2();\n}\n</code></pre>\n<p>This code compiled with GCC 6.3 with -O0 flag runs fine and without error under valgrind.\nHowever, running it with -O1 or O2 leads to the following output:</p>\n<pre><code>Size of in collision1: 24\nSize of in collision2: 16\n==326== Invalid write of size 8\n==326==    at 0x400F6C: construct&lt;Data, const Data&amp;&gt; (new_allocator.h:120)\n==326==    by 0x400F6C: construct&lt;Data, const Data&amp;&gt; (alloc_traits.h:455)\n==326==    by 0x400F6C: push_back (stl_vector.h:918)\n==326==    by 0x400F6C: collision2() (td_collision2.cc:22)\n==326==    by 0x400FE8: main (td_main.cc:10)\n==326==  Address 0x5aba1f0 is 0 bytes after a block of size 96 alloc'd\n==326==    at 0x4C2E1FC: operator new(unsigned long) (vg_replace_malloc.c:334)\n==326==    by 0x400DE9: allocate (new_allocator.h:104)\n==326==    by 0x400DE9: allocate (alloc_traits.h:416)\n==326==    by 0x400DE9: _M_allocate (stl_vector.h:170)\n==326==    by 0x400DE9: void std::vector&lt;Data, std::allocator&lt;Data&gt; &gt;::_M_emplace_back_aux&lt;Data const&amp;&gt;(Data const&amp;) (vector.tcc:412)\n==326==    by 0x400F7E: push_back (stl_vector.h:924)\n==326==    by 0x400F7E: collision2() (td_collision2.cc:22)\n==326==    by 0x400FE8: main (td_main.cc:10)\n==326== \n==326== Invalid write of size 8\n==326==    at 0x400F69: construct&lt;Data, const Data&amp;&gt; (new_allocator.h:120)\n==326==    by 0x400F69: construct&lt;Data, const Data&amp;&gt; (alloc_traits.h:455)\n==326==    by 0x400F69: push_back (stl_vector.h:918)\n==326==    by 0x400F69: collision2() (td_collision2.cc:22)\n==326==    by 0x400FE8: main (td_main.cc:10)\n==326==  Address 0x5aba1f8 is 8 bytes after a block of size 96 alloc'd\n==326==    at 0x4C2E1FC: operator new(unsigned long) (vg_replace_malloc.c:334)\n==326==    by 0x400DE9: allocate (new_allocator.h:104)\n==326==    by 0x400DE9: allocate (alloc_traits.h:416)\n==326==    by 0x400DE9: _M_allocate (stl_vector.h:170)\n==326==    by 0x400DE9: void std::vector&lt;Data, std::allocator&lt;Data&gt; &gt;::_M_emplace_back_aux&lt;Data const&amp;&gt;(Data const&amp;) (vector.tcc:412)\n==326==    by 0x400F7E: push_back (stl_vector.h:924)\n==326==    by 0x400F7E: collision2() (td_collision2.cc:22)\n==326==    by 0x400FE8: main (td_main.cc:10)\n==326== \n==326== \n==326== HEAP SUMMARY:\n==326==     in use at exit: 0 bytes in 0 blocks\n==326==   total heap usage: 5 allocs, 5 frees, 73,896 bytes allocated\n==326== \n==326== All heap blocks were freed -- no leaks are possible\n==326== \n==326== For counts of detected and suppressed errors, rerun with: -v\n==326== ERROR SUMMARY: 191 errors from 2 contexts (suppressed: 0 from 0)\n</code></pre>\n<p>the <code>push_back()</code> function fails when the libc reallocates <code>std::vector&lt;struct Data&gt; bar</code>. (in my case, its size is 4 items initially, and the vector is further resized afterwards when calling push_back() in the loop.)\nWhen <code>struct Data</code> in td_collision1.cc has the same size as in td_collision2.cc, the program doesn't crash. </p>\n<p>Therefore, there seem to be a collision between these two structure definitions. Indeed, if I rename one structure, the bug obviously vanishes.\nBut, as mentioned above, I thought that this could not happen. What did I misunderstood?\nAlso, if I get rid of function <code>collision1()</code>, the segfault vanishes (<code>struct Data</code> in collision1 is probably ditched by the compiler because unused)</p>\n<p>My understanding was that there exist a clear separation between these two CC files and no \"crosstalk\" should be possible if the structures are not present in the header.</p>\n<p>Edit: add missing td2.h</p>\n", "AcceptedAnswerId": "41481150", "Title": "Structure with same name, different definitions: segmentation fault with -O2", "CreationDate": "2017-01-05T09:03:16.523", "Id": "41480854", "CommentCount": "7", "LastEditDate": "2017-01-05T12:50:06.983", "PostTypeId": "1", "LastEditorUserId": "7378105", "LastActivityDate": "2017-01-05T13:34:00.060", "Score": "1", "OwnerUserId": "7378105", "Tags": "<c++><struct><segmentation-fault><translation-unit>", "AnswerCount": "3"}, "41481083": {"Id": "41481083", "PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/basic.def.odr#6\" rel=\"nofollow noreferrer\">basic.def.odr</a>, (... is omitted by me):</p>\n<blockquote>\n<p id=\"so_41480854_41481083_0\">There can be more than one definition of a class type (Clause [class]), ..... Given such an entity named D defined in more than one translation unit, then:</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n<li>...</li>\n</ul>\n<p id=\"so_41480854_41481083_1\">If D is a template and is defined in more than one translation unit, then the preceding requirements shall apply both to names from the template's enclosing scope used in the template definition ([temp.nondep]), and also to dependent names at the point of instantiation ([temp.dep]). If the definitions of D satisfy all these requirements, then the behavior is as if there were a single definition of D. <strong>If the definitions of D do not satisfy these requirements, then the behavior is undefined.</strong></p>\n</blockquote>\n<p>In your program, definition of <code>struct Data</code> in <code>td_collision1.cc</code> and in <code>td_collision2.cc</code> doesn't match with each other, hence, definitions of <code>struct Data</code> do not satisfy those requirements, then the behavior is undefined.</p>\n", "LastActivityDate": "2017-01-05T09:14:44.180", "CommentCount": "0", "CreationDate": "2017-01-05T09:14:44.180", "ParentId": "41480854", "Score": "1", "OwnerUserId": "4115625"}});