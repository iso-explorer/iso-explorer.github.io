post_cb({"bq_ids": {"n4140": {"so_4277477_4277523_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5846}}, "n3337": {"so_4277477_4277523_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 5616}}, "n4659": {"so_4277477_4277523_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 7325}}}, "4277477": {"ViewCount": "2075", "Body": "<p>I have code like this:</p>\n<pre><code>namespace N {\n   class B {\n     public:\n       virtual void doStuff(B *) = 0;\n    };\n }\n\n // not in a namespace\n class Derived : public N::B {\n   public:\n       void doStuff(B *); // Should this be N::B, or is B ok?\n };\n</code></pre>\n<p>Do I need the namespace qualifier where Derived refers to it's base class?  GCC and MSVC are happy with the code as written, but another compiler complains unless I put the namespace in.  What does the C++ standard say?</p>\n", "AcceptedAnswerId": "4277523", "Title": "Is a namespace required when referring to the base class", "CreationDate": "2010-11-25T13:20:02.877", "Id": "4277477", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-02-04T13:05:48.000", "LastEditorUserId": "560648", "LastActivityDate": "2016-05-02T05:56:00.497", "Score": "12", "OwnerUserId": "37386", "Tags": "<c++><namespaces><language-lawyer>", "AnswerCount": "1"}, "4277523": {"Id": "4277523", "PostTypeId": "2", "Body": "<p>Inside the class definition B is OK. That's the so-called <strong><em>injected class name</em></strong>.</p>\n<p>This also refers to templates (not counting dependent bases). E.g.</p>\n<pre><code>template &lt;class T&gt; class B{};\ntemplate &lt;class T&gt; class C: public B&lt;int&gt;\n{\n   void f(B* p) {} //same as B&lt;int&gt;* p\n   void f(C* p) {} //same as C&lt;T&gt;* p\n};\n</code></pre>\n<p>In general the base class (and the class itself) can be referred to inside the class definition without qualification or template arguments.</p>\n<p>Quotes from the standard:</p>\n<blockquote>\n<p id=\"so_4277477_4277523_0\">9.2 : A class-name is inserted into the scope in which it is declared immediately after the class-name is seen. The class-name is also\n  inserted into the scope of the class itself; this is known as the\n  injected-class-name. For purposes of access checking, the\n  injected-class-name is treated as if it were a public member name.</p>\n</blockquote>\n<p>From this definition it follows that the name of the class itself is publicly accessible from the class, and therefore is available in derived classes. Which proves my point about B being OK along with N::B because the name B is inherited</p>\n<p>Btw, this also explains why the following is invalid:</p>\n<pre><code>template &lt;class T&gt; class B{};\ntemplate &lt;class T&gt; class C: public B&lt;T&gt;\n{\n     voiid f(B* p){} //ERROR\n    // the above is invalid!! Base class is dependent therefore \n    //its scope is not considered during unqualified name lookup\n     void g(typename C::B* p){} //this is valid, same as B&lt;T&gt;* p  \n};\n</code></pre>\n<p>14.6.1 Speaks about injected class names in templates. It is far too long to paste here. \nHth</p>\n", "LastEditorUserId": "2372604", "LastActivityDate": "2016-05-02T05:56:00.497", "Score": "11", "CreationDate": "2010-11-25T13:24:33.477", "ParentId": "4277477", "CommentCount": "11", "OwnerUserId": "469935", "LastEditDate": "2016-05-02T05:56:00.497"}});