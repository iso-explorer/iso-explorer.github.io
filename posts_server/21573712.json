post_cb({"21574507": {"Id": "21574507", "PostTypeId": "2", "Body": "<p><code>asdf</code> explained it quite well, even if concisely in the linked post.</p>\n<blockquote>\n<p id=\"so_21573712_21574507_0\">because the compiler doesn't know CustomImage derives from Image at\n  this point in the program.</p>\n</blockquote>\n<p>Personally I can't be bothered to download rubbish from msdn just to dig in and answer the question. After all it is a coding challenge, you are supposed to figure it out.</p>\n<p>My rules for casting in C++ are:</p>\n<ol>\n<li>use C++ style casts <code>xx_cast&lt;T*&gt;</code> and not C-style <code>(T*)</code>, for <em>explicit is better than implicit.</em></li>\n<li>only use reinterpret cast when you really really mean it.</li>\n<li>if you do use <code>reinterpret_cast&lt;T*&gt;</code> make sure that cast/uncast are exact mirror, e.g.:</li>\n</ol>\n<p>.</p>\n<pre><code>T* obj = ...;\nvoid* tmp = reinterpret_cast&lt;void*&gt; obj;\nT* ref = reinterpret_cast&lt;T*&gt; tmp;  // T* obj --&gt; T* ref\n</code></pre>\n<p>Here, you must make sure that <code>obj</code> and <code>ref</code> are same exact type, including const qualifiers, class derivation, alignment, type of memory (embedded), absolutely anything you can think of.</p>\n", "LastEditorUserId": "705086", "LastActivityDate": "2014-02-05T11:56:35.170", "Score": "2", "CreationDate": "2014-02-05T10:23:32.730", "ParentId": "21573712", "CommentCount": "2", "OwnerUserId": "705086", "LastEditDate": "2014-02-05T11:56:35.170"}, "bq_ids": {"n4140": {"so_21573712_21574273_0": {"length": 21, "quality": 0.7, "section_id": 6046}}, "n3337": {"so_21573712_21574273_0": {"length": 24, "quality": 0.8, "section_id": 5814}}, "n4659": {"so_21573712_21574273_0": {"length": 20, "quality": 0.6666666666666666, "section_id": 7545}}}, "21573712": {"ViewCount": "292", "Body": "<p>I have seen people suggest using <code>static_cast&lt;SomeType*&gt;(static_cast&lt;void*&gt;(p))</code> rather than reinterpret casting.</p>\n<p>I don't understand why this is better, can someone explain?</p>\n<p>For the sake of argument here is an example scenario where reinterpret_cast is needed:</p>\n<pre><code>DWORD lpNumberOfBytes;\nULONG_PTR lpCompletionKey;\nLPOVERLAPPED lpOverlapped;\nGetQueuedCompletionStatus(myHandle, &amp;lpNumberOfBytes, &amp;lpCompletionKey, &amp;lpOverlapped, 0);\nif(lpCompletionKey == myCustomHandlerKey){\n    auto myObject = reinterpret_cast&lt;MyObject*&gt;(lpOverlapped);  //i know this is really a MyObject\n}\n</code></pre>\n<p>This is what I have heard suggested: </p>\n<pre><code>auto myObject = static_cast&lt;MyObject*&gt;(static_cast&lt;void*&gt;(lpOverlapped));\n</code></pre>\n<p><strong>Edit:</strong> I origionally started my question with <del>In the comments section \"asdf\" suggests using static_cast instead of reinterpret_cast here <a href=\"http://blogs.msdn.com/b/vcblog/archive/2014/02/04/challenge-vulnerable-code.aspx\" rel=\"nofollow noreferrer\">http://blogs.msdn.com/b/vcblog/archive/2014/02/04/challenge-vulnerable-code.aspx</a></del> but in retrospect the fact that my question came from there is irrelevant.</p>\n", "AcceptedAnswerId": "21574273", "Title": "should I use it or static_cast<void*> then static_cast<myType*> to avoid reinterpret_cast?", "CreationDate": "2014-02-05T09:49:05.230", "Id": "21573712", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-02-05T11:43:24.477", "LastEditorUserId": "893819", "LastActivityDate": "2014-02-05T11:56:35.170", "Score": "6", "OwnerUserId": "893819", "Tags": "<c++><casting><reinterpret-cast><static-cast>", "AnswerCount": "2"}, "21574273": {"Id": "21574273", "PostTypeId": "2", "Body": "<p>\u00a75.2.10 describes the legal mappings that <code>reinterpret_cast</code> can perform, and specifies that \u201cNo other conversion can be performed\u201d.</p>\n<p>The conversion relevant for your example is /7:</p>\n<blockquote>\n<p id=\"so_21573712_21574273_0\">A pointer to an object can be explicitly converted to a pointer to a different object type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is <code>static_cast&lt;<i>cv T2*&gt;(static_cast&lt;cv</i> void*&gt;(v))</code> <strong>if both <code>T1</code> and <code>T2</code> are standard-layout types \u2026 and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code></strong>. [emphasis mine]</p>\n</blockquote>\n<p>The result of the conversions of any <em>other</em> pointer to object types is \u201cunspecified\u201d.<sup>1</sup></p>\n<p>This is one of two reasons why <code>reinterpret_cast</code> is dangerous: its conversion is only well-defined for a subset of pointer to object types, and compilers usually offer <em>no</em> diagnostics about accidental misuse.</p>\n<p>The second reason is that the compiler doesn\u2019t even check whether the mapping you are trying to perform is legal in the first place, and which of the many (semantically completely different) mappings is going to be performed.</p>\n<p>Better to be explicit and tell the compiler (and the reader) <em>which</em> the intended conversion is that you want to perform. That said, asdf\u2019s comment isn\u2019t quite correct, because not <em>all</em> conversions that you might want to perform via <code>reinterpret_cast</code> are equivalent to using <code>static_cast&lt;void*&gt;</code> followed by a <code>static_cast</code> to the target type.</p>\n<hr>\n<p><sup>1</sup> Aside: In a nutshell (and slightly simplified), a <a href=\"http://en.cppreference.com/w/cpp/types/is_standard_layout\" rel=\"nofollow\">\u201cstandard layout type\u201d</a> is a type (or array of type) which doesn\u2019t have virtual functions or mixed member visibility, and all its members and bases are also standard layout. The <a href=\"http://en.cppreference.com/w/cpp/language/alignof\" rel=\"nofollow\">alignment</a> of a type is a restriction on the addresses in memory at which it may be located. For example, many machines require that <code>double</code>s are aligned at addresses divisible by 8.</p>\n</hr>", "LastEditorUserId": "1968", "LastActivityDate": "2014-02-05T11:08:02.123", "Score": "7", "CreationDate": "2014-02-05T10:14:01.893", "ParentId": "21573712", "CommentCount": "6", "OwnerUserId": "1968", "LastEditDate": "2014-02-05T11:08:02.123"}});