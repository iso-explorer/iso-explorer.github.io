post_cb({"12889237": {"CommentCount": "2", "ViewCount": "567", "PostTypeId": "1", "ClosedDate": "2012-10-15T08:15:03.620", "LastEditorUserId": "-1", "CreationDate": "2012-10-15T04:19:03.657", "LastActivityDate": "2012-10-15T05:28:25.390", "LastEditDate": "2017-05-23T12:12:26.130", "AcceptedAnswerId": "12889697", "OwnerDisplayName": "user1599559", "Title": "C++ Integer Overflow and Promotion", "Id": "12889237", "Score": "12", "Body": "<blockquote>\n<p id=\"so_12889237_12889237_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/6770258/how-do-promotion-rules-work-when-the-signedness-on-either-side-of-a-binary-opera\">How do promotion rules work when the signedness on either side of a binary operator differ?</a> </br></p>\n</blockquote>\n<p>I'm trying to wrap my head around integer promotion and overflow in C++. I'm a bit confused with several points:</p>\n<p><strong>a)</strong> If I have the following code segment:</p>\n<pre><code>int i = -15; \nunsigned j = 10; \nstd::cout &lt;&lt; i + j;\n</code></pre>\n<p>I get out <code>-5 % UINT_MAX</code>. Is this because the expression <code>i + j</code> is automatically promoted to an unsigned? I was trying to read the standard (4.13): </p>\n<p><code>\u2014 The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</code></p>\n<p>I'm not sure if I'm reading this incorrectly, but if that is true, why is <code>i + j</code> ending up as unsigned? </p>\n<p><strong>b)</strong> Adding onto the previous segment, I now have:</p>\n<pre><code>int k = j + i;\n</code></pre>\n<p>That is getting evaluated to <code>-5</code>. Shouldn't the expression <code>j + i</code> be evaluated first, giving <code>4294967291</code> on my system, and setting that equal to j? That should be out of bounds, so is this behavior undefined? I'm not sure why I get <code>-5</code>.</p>\n<p><strong>c)</strong> If I change the segment from <em>a)</em> slightly using <code>short</code>, I have:</p>\n<pre><code>short i = -15;\nunsigned short j = 10;\nstd::cout &lt;&lt; i + j;\n</code></pre>\n<p>I figured when I did this, I would get the same result as <em>a)</em>, just with <code>-5 % USHRT_MAX</code>. However, when I execute this, I get <code>-5</code>. Why does using <code>short</code> give a different value than <code>int</code>?</p>\n<p><strong>d)</strong> I have always learned that the overflow behavior of a signed integral is undefined. For example: <code>int r = ++INT_MAX</code> would be undefined.</p>\n<p>However, if there was an unsigned overflow, the quantity would be defined. For example: <code>unsigned a = ++UINT_MAX</code>, then a would be <code>0</code>. Is that correct?</p>\n<p>However, the standard didn't seem to say anything about it. Is that true? If so, why is that?</p>\n", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}, "12889697": {"ParentId": "12889237", "LastEditDate": "2012-10-15T05:28:25.390", "CommentCount": "1", "CreationDate": "2012-10-15T05:21:17.180", "OwnerUserId": "1204143", "LastEditorUserId": "1204143", "PostTypeId": "2", "Id": "12889697", "Score": "4", "Body": "<p>a) From \u00a75/9:</p>\n<blockquote>\n<p id=\"so_12889237_12889697_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:</p>\n<ul>\n<li>If either operand is of type <code>long double</code>, the other shall be\n  converted to <code>long double</code>.</li>\n<li>Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</li>\n<li>Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>. </li>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both operands.</li>\n<li>Then, if either operand is <code>unsigned long</code> the other shall be   converted to <code>unsigned long</code>. </li>\n<li>Otherwise, if one operand is a <code>long int</code> and the other <code>unsigned int</code>, then if a <code>long int</code> can represent all the values of an <code>unsigned int</code>, the <code>unsigned int</code> shall be converted to a <code>long int</code>; otherwise both operands shall be converted to <code>unsigned long int</code>.</li>\n<li>Otherwise, if either operand is <code>long</code>, the other shall be converted to <code>long</code>.</li>\n<li>Otherwise, if either operand is <code>unsigned</code>, the other shall be converted to <code>unsigned</code>.</li>\n</ul>\n<p id=\"so_12889237_12889697_1\">[<em>Note:</em> otherwise, the only remaining case is that both operands are <code>int</code>]</p>\n</blockquote>\n<p>Therefore, since <code>j</code> is <code>unsigned</code>, <code>i</code> is promoted to <code>unsigned</code> and the addition is performed using unsigned int arithmetic.</p>\n<p>b) This is UB. The result of the addition is <code>unsigned int</code> (as per (a)), and thus you overflow the <code>int</code> in the assignment.</p>\n<p>c) From \u00a74.5/1:</p>\n<blockquote>\n<p id=\"so_12889237_12889697_2\">An rvalue of type <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short int</code>, or <code>unsigned short int</code> can be converted to an rvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source rvalue can be converted to an rvalue of type <code>unsigned int</code>.</p>\n</blockquote>\n<p>Therefore, since a 4-byte <code>int</code> can represent any value in a 2-byte <code>short</code> or <code>unsigned short</code>, both are promoted to <code>int</code> (per \u00a75.9's integral promotions rule), and then added as <code>int</code>s.</p>\n<p>d) From \u00a73.9.1/4:</p>\n<blockquote>\n<p id=\"so_12889237_12889697_3\">Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>Therefore, <code>UINT_MAX+1</code> is legal (not UB) and equal to 0.</p>\n", "LastActivityDate": "2012-10-15T05:28:25.390"}, "bq_ids": {"n4140": {"so_12889237_12889697_0": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_12889237_12889697_3": {"section_id": 7213, "quality": 0.875, "length": 14}, "so_12889237_12889697_2": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}}, "n3337": {"so_12889237_12889697_0": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_12889237_12889697_3": {"section_id": 6957, "quality": 1.0, "length": 16}, "so_12889237_12889697_2": {"section_id": 18, "quality": 0.6060606060606061, "length": 20}}, "n4659": {"so_12889237_12889697_0": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_12889237_12889697_3": {"section_id": 8722, "quality": 0.875, "length": 14}, "so_12889237_12889697_2": {"section_id": 21, "quality": 0.6060606060606061, "length": 20}}}});