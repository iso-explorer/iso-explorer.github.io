post_cb({"31004483": {"CommentCount": "0", "ViewCount": "84", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-06-23T13:44:02.703", "LastActivityDate": "2015-06-23T14:18:03.850", "Title": "I don't understand how the template function gets to be a friend of the class A::X::Y in the example in [namespace.memdef]/3 in C++14", "AcceptedAnswerId": "31004839", "LastEditDate": "2015-06-23T14:18:03.850", "Id": "31004483", "Score": "2", "Body": "<p>Consider the following code from the example in [namespace.memdef]/3 in C++14:</p>\n<pre><code>// Assume f and g have not yet been declared.\nvoid h(int);\ntemplate &lt;class T&gt; void f2(T);\nnamespace A {\n    class X {\n        friend void f(X);           // A::f(X) is a friend\n        class Y {\n            friend void g();        // A::g is a friend\n            friend void h(int);     // A::h is a friend\n                                    // ::h not considered\n            friend void f2&lt;&gt;(int);  // ::f2&lt;&gt;(int) is a friend\n        };\n    };\n    // A::f, A::g and A::h are not visible here\n    X x;\n    void g() { f(x); }              // definition of A::g\n    void f(X) { /* ... */}          // definition of A::f\n    void h(int) { /* ... */ }       // definition of A::h\n    // A::f, A::g and A::h are visible here and known to be friends\n}\n\nusing A::x;\nvoid h() {\n    A::f(x);\n    //A::X::f(x);                  // error: f is not a member of A::X\n    //A::X::Y::g();                // error: g is not a member of A::X::Y\n}\n</code></pre>\n<p>I don't understand why <code>::f2&lt;&gt;(int)</code> is a friend of the class <code>A::X::Y</code>. Shouldn't the lookup of the name stop at <code>namespace A</code>? How is it allowed to find <code>::f2</code>? Why is there a difference in the treatment of <code>h</code> and <code>f2</code>?</p>\n", "Tags": "<c++><templates><language-lawyer><c++14><friend>", "OwnerUserId": "4470935", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31004483_31004839_1": {"section_id": 5485, "quality": 1.0, "length": 17}, "so_31004483_31004839_0": {"section_id": 5485, "quality": 1.0, "length": 22}}, "n3337": {"so_31004483_31004839_1": {"section_id": 5271, "quality": 0.8823529411764706, "length": 15}, "so_31004483_31004839_0": {"section_id": 5271, "quality": 1.0, "length": 22}}, "n4659": {"so_31004483_31004839_1": {"section_id": 6920, "quality": 1.0, "length": 17}, "so_31004483_31004839_0": {"section_id": 6920, "quality": 1.0, "length": 22}}}, "31004839": {"ParentId": "31004483", "CommentCount": "3", "Body": "<p>It doesn't have to be in namespace <code>A</code>. I think the confusion might come from this sentence from [namespace.memdef]/3:</p>\n<blockquote>\n<p id=\"so_31004483_31004839_0\">If the name in a <code>friend</code> declaration is neither\n  qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost\n  enclosing namespace.</p>\n</blockquote>\n<p>The name in the <code>friend</code> declaration in question is <code>f2&lt;&gt;</code>. That is not qualified, but it <em>is</em> a <em>template-id</em>. So the clause that would have restricted lookup to namespace <code>A</code> simply doesn't apply. We do the standard unqualified lookup on <code>f2</code> to find <code>::f2</code>. </p>\n<p>Consider the difference in the example you copied between <code>h</code> and <code>f2</code>:</p>\n<pre><code>friend void h(int);     // A::h is a friend\n                        // ::h not considered\nfriend void f2&lt;&gt;(int);  // ::f2&lt;&gt;(int) is a friend\n</code></pre>\n<p>There <code>h</code> is neither qualified nor a <em>template-id</em>, so we do not look outside of the innermost enclosing namespace. Since we don't find anything for <code>h</code> there, we apply the first sentence of [namespace.memdef]/3:</p>\n<blockquote>\n<p id=\"so_31004483_31004839_1\">If a friend declaration in a non-local class first declares a class, function, class template or function template\n  the friend is a member of the innermost enclosing namespace.</p>\n</blockquote>\n<p>So that particular line declares a <code>void A::h(int)</code>, which is a <code>friend</code> of <code>A::X::Y</code>.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31004839", "Score": "6", "CreationDate": "2015-06-23T13:58:02.690", "LastActivityDate": "2015-06-23T13:58:02.690"}});