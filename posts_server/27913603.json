post_cb({"27913893": {"ParentId": "27913603", "CommentCount": "0", "Body": "<p>For the <code>operator()</code> in <code>base</code> to do a valid <code>static_cast</code>, the most-derived object that <code>this</code> points to must be of type <code>Derived</code> (or a subclass thereof). However, the members of <code>e</code> are of type <code>base&lt;derived&gt;</code>, not <code>derived</code> itself. In the line</p>\n<pre><code>const noexcept { return m_a() + m_b(); }\n</code></pre>\n<p><code>m_a</code> is of type <code>base&lt;derived&gt;</code>, and <code>base&lt;derived&gt;::operator()</code> is called - <strong>with a most-derived object of type <code>base&lt;derived&gt;</code></strong>.<br>\nThus the cast tries to cast <code>*this</code> to a reference to object type that it doesn't actually refer to; That operation would have undefined behavior as [expr.static.cast]/2 describes:</br></p>\n<blockquote>\n<p id=\"so_27913603_27913893_0\">An lvalue of type \u201c<em>cv1</em> <code>B</code>,\u201d where B is a class type, can be cast to\n  type \u201creference to <em>cv2</em> <code>D</code>,\u201d where <code>D</code> is a class\n         derived (Clause 10) from <code>B</code> [..]. <strong>If the object of type \u201c<em>cv1</em> B\u201d is actually a subobject of an object of type <code>D</code>, the result refers\n  to the enclosing object of type <code>D</code></strong>. <strong>Otherwise, the behavior is\n  undefined.</strong></p>\n</blockquote>\n<p>And subsequently, [expr.const]/2 applies:</p>\n<blockquote>\n<p id=\"so_27913603_27913893_1\">A <em>conditional-expression</em> <code>e</code> is a core constant expression unless\n  the evaluation of <code>e</code>, following the rules of the abstract machine\n  (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_27913603_27913893_2\">(2.5) \u2014 an operation that would have undefined behavior</p>\n</blockquote>\n<p>Instead, rewrite <code>foo</code> as follows:</p>\n<pre><code>template &lt;class D1, class D2&gt;\nconstexpr auto foo(const D1&amp; d1, const D2&amp; d2)\nnoexcept { return expr&lt;D1, D2&gt;{d1, d2}; }\n</code></pre>\n<p>And the code <a href=\"http://coliru.stacked-crooked.com/a/55ffe9e53ef6743d\" rel=\"noreferrer\"><strong>works fine</strong></a>.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "27913893", "Score": "9", "CreationDate": "2015-01-13T02:04:56.740", "LastActivityDate": "2015-01-13T02:04:56.740"}, "27913603": {"CommentCount": "0", "CreationDate": "2015-01-13T01:23:36.153", "PostTypeId": "1", "AcceptedAnswerId": "27913893", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T11:26:13.860", "LastEditDate": "2016-03-18T11:26:13.860", "ViewCount": "367", "FavoriteCount": "3", "Title": "constexpr and CRTP: compiler disagreement", "Id": "27913603", "Score": "8", "Body": "<p>When expression templates are implemented using CRTP, the class at the top of the expression hierarchy uses base-to-derived downcasting in order to implement some of its operations. According to clang-3.5 (<code>-std=c++1y</code>), this downcast should be illegal in <code>constexpr</code> functions:</p>\n<pre><code>test.cpp:42:16: error: static_assert expression is not an integral constant expression\n        static_assert(e() == 0, \"\");\n                      ^~~~~~~~\ntest.cpp:11:26: note: cannot cast object of dynamic type 'const base&lt;derived&gt;' to type 'const derived'\n        const noexcept { return static_cast&lt;const Derived&amp;&gt;(*this)(); }\n</code></pre>\n<p>GCC happily <a href=\"http://ideone.com/VZQ8Mz\">compiles the code.</a> So who is right? If Clang is right, which C++14 restriction on <code>constexpr</code> functions makes this downcasting illegal?</p>\n<p>Here's the MWE:</p>\n<pre><code>template &lt;class Derived&gt;\nclass base\n{\npublic:\n    constexpr auto operator()()\n    const noexcept { return static_cast&lt;const Derived&amp;&gt;(*this)(); }\n};\n\nclass derived : public base&lt;derived&gt;\n{\npublic:\n    constexpr auto operator()()\n    const noexcept { return 0; }\n};\n\ntemplate &lt;class A, class B&gt;\nclass expr : public base&lt;expr&lt;A, B&gt;&gt;\n{\n    const A m_a;\n    const B m_b;\npublic:\n    constexpr explicit expr(const A a, const B b)\n    noexcept : m_a(a), m_b(b) {}\n\n    constexpr auto operator()()\n    const noexcept { return m_a() + m_b(); }\n};\n\ntemplate &lt;class D1, class D2&gt;\nconstexpr auto foo(const base&lt;D1&gt;&amp; d1, const base&lt;D2&gt;&amp; d2)\nnoexcept { return expr&lt;base&lt;D1&gt;, base&lt;D2&gt;&gt;{d1, d2}; }\n\nint main()\n{\n    constexpr auto d = derived{};\n    constexpr auto e = foo(d, d);\n    static_assert(e() == 0, \"\");\n}\n</code></pre>\n", "Tags": "<c++><templates><language-lawyer><c++14><constexpr>", "OwnerUserId": "414271", "AnswerCount": "3"}, "27913966": {"ParentId": "27913603", "LastEditDate": "2015-01-13T14:33:30.463", "CommentCount": "6", "CreationDate": "2015-01-13T02:15:55.637", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "PostTypeId": "2", "Id": "27913966", "Score": "2", "Body": "<p>Here is a decent rework of your original code.  UB is removed, and it extends nicely:</p>\n<pre><code>namespace library{\n  template &lt;class Derived&gt;\n  class base\n  {\n  public:\n    constexpr Derived const&amp; self() const noexcept { return static_cast&lt;const Derived&amp;&gt;(*this); }\n\n    constexpr auto operator()()\n    const noexcept { return self()(); }\n  };\n\n  template &lt;class A, class B&gt;\n  class expr : public base&lt;expr&lt;A, B&gt;&gt;\n  {\n    const A m_a;\n    const B m_b;\n  public:\n    constexpr explicit expr(const A a, const B b)\n    noexcept : m_a(a), m_b(b) {}\n\n    constexpr auto operator()()\n    const noexcept { return m_a() + m_b(); }\n  };\n\n  template &lt;class D1, class D2&gt;\n  constexpr auto foo(const base&lt;D1&gt;&amp; d1, const base&lt;D2&gt;&amp; d2)\n  noexcept { return expr&lt;D1, D2&gt;{d1.self(), d2.self()}; }\n}\n\nnamespace client {\n  class derived : public library::base&lt;derived&gt; {\n  public:\n    constexpr auto operator()()\n    const noexcept { return 0; }\n  };\n}\n\n\nint main()\n{\n  constexpr auto d = client::derived{};\n  constexpr auto e = foo(d, d);\n  static_assert(e() == 0, \"\");\n}\n</code></pre>\n<p>Basically every <code>base&lt;X&gt;</code> <strong>must</strong> be a <code>X</code>.  So when you store it, you store it as an <code>X</code>, not a <code>base&lt;X&gt;</code>.  We can access the <code>X</code> via <code>base&lt;X&gt;::self()</code> in a <code>constexpr</code> fashion.</p>\n<p>By doing it this way, we can put the machinery into <code>namespace library</code>.  <code>foo</code> can be found via ADL, and if you (for example) start adding operators to your expression-template like code, you won't have to manually import them for your <code>main</code> to work.</p>\n<p>Your <code>derived</code> is a class created by client code for your library, so goes in another namespace.  It overrides <code>()</code> as it pleases, and it \"just works\".</p>\n<p>A less contrived example would replace <code>foo</code> with <code>operator+</code>, and the advantages of this style become apparent.  <code>main</code> becomes <code>constexpr auto e = d+d;</code> without having to <code>using library::operator+</code>.</p>\n<p>The changes made are adding a <code>self()</code> method to <code>base</code> to access <code>Derived</code>, using it to remove a <code>static_cast</code>s in <code>()</code>, and having <code>foo</code> return an <code>expr&lt;D1, D2&gt;</code> instead of a <code>expr&lt;base&lt;D1&gt;, base&lt;D2&gt;&gt;</code>.</p>\n", "LastActivityDate": "2015-01-13T14:33:30.463"}, "bq_ids": {"n4140": {"so_27913603_27913893_1": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_27913603_27913893_0": {"section_id": 6028, "quality": 0.9, "length": 27}, "so_27913603_27913893_2": {"section_id": 6185, "quality": 1.0, "length": 5}}, "n3337": {"so_27913603_27913893_0": {"section_id": 5796, "quality": 0.8666666666666667, "length": 26}, "so_27913603_27913893_2": {"section_id": 1182, "quality": 0.8, "length": 4}}, "n4659": {"so_27913603_27913893_1": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_27913603_27913893_0": {"section_id": 7527, "quality": 0.9, "length": 27}, "so_27913603_27913893_2": {"section_id": 7687, "quality": 1.0, "length": 5}}}, "27913782": {"ParentId": "27913603", "LastEditDate": "2017-05-23T12:10:35.767", "CommentCount": "6", "CreationDate": "2015-01-13T01:48:34.043", "OwnerUserId": "502399", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27913782", "Score": "5", "Body": "<p>It seems to me that Clang is right in this case.  The type of <code>e</code> is <code>const expr&lt;base&lt;derived&gt;, base&lt;derived&gt;&gt;</code>, so <code>m_a</code> and <code>m_b</code> have type <code>base&lt;derived&gt;</code>, rather than <code>derived</code>.  In other words, you have <a href=\"https://stackoverflow.com/q/274626/502399\">sliced</a> <code>d</code> when copying it into <code>m_a</code> and <code>m_b</code>.</p>\n", "LastActivityDate": "2015-01-13T01:48:34.043"}});