post_cb({"24918426": {"CommentCount": "6", "ViewCount": "422", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-07-23T18:43:35.277", "LastActivityDate": "2014-07-23T19:38:07.887", "Title": "Initialize tuple of references with reference to tuple", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:31:49.123", "Id": "24918426", "Score": "3", "Body": "<p>If I have the code</p>\n<pre><code>#include &lt;tuple&gt;\n\nusing Vec3 = std::tuple&lt;float, float, float&gt;;\nusing Vec3Ref = std::tuple&lt;float&amp;, float&amp;, float&amp;&gt;;\n\nvoid stuff ()\n{\n  Vec3 foo (0,0,0);\n  Vec3Ref bar (foo);\n}\n</code></pre>\n<p>I get the error</p>\n<pre><code>/usr/include/c++/4.6/tuple:100:4: error: binding of reference to type 'float' to\na value of type 'const float' drops qualifiers\n\n: _M_head_impl(std::forward&lt;_UHead&gt;(__h)) { }\n\n^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n\n//snip...\n\n/usr/include/c++/4.6/tuple:257:11: note: in instantiation of function template\nspecialization 'std::_Tuple_impl&lt;0, float &amp;, float &amp;, float &amp;&gt;::_Tuple_impl\n&lt;float, float, float&gt;' requested here\n\n: _Inherited(static_cast&lt;const _Tuple_impl&lt;0, _UElements...&gt;&amp;&gt;(__in))\n\n^\n\n18 : note: in instantiation of function template specialization\n'std::tuple::tuple' requested here\n\nVec3Ref bar (foo);\n\n^\n</code></pre>\n<p>The closest thing I've found is <a href=\"https://stackoverflow.com/questions/19800303/what-is-the-difference-between-assigning-to-stdtie-and-tuple-of-references\">this question</a>, but the problem there seems to be about initializing with a tuple returned from <code>std::make_tuple</code>, which is an rvalue. <code>foo</code>, however, is very much an lvalue. Why does this not work? How is this different from using <code>std::tie</code>?</p>\n", "Tags": "<c++><reference><tuples>", "OwnerUserId": "603688", "AnswerCount": "1"}, "24919135": {"ParentId": "24918426", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Github draft from 2014-07-23, [tuple.cnstr]</p>\n<blockquote>\n<pre><code>template &lt;class... UType&gt; constexpr tuple(tuple&lt;UTypes...&gt;&amp;&amp; u);\n</code></pre>\n<p id=\"so_24918426_24919135_0\"><sup>18</sup> <em>Requires:</em> <code>sizeof...(Types) == sizeof...(UTypes)</code>.\n  <code>is_constructible&lt;Ti, Ui&amp;&amp;&gt;::value</code> is <code>true</code> for all <em>i</em>.</p>\n<p id=\"so_24918426_24919135_1\"><sup>20</sup> <em>Remark:</em> This constructor shall not participate in\n  overload resolution unless each type in <code>UTypes</code> is implicitly\n  convertible to its corresponding type in <code>Types</code>.</p>\n</blockquote>\n<p>The <em>Remarks:</em> section defines the SFINAE. Note how it's different from the <em>Requires:</em> section by requiring the use of <code>is_convertible</code> instead of <code>is_constructible</code>.</p>\n<p>In the OP's example, this leads to the check <code>is_convertible&lt;float, float&amp;&gt;</code>, which is false: a <code>float</code> xvalue cannot be bound to a <code>float</code> lvalue reference:</p>\n<p><code>is_convertible</code> [meta.rel]/4</p>\n<blockquote>\n<p id=\"so_24918426_24919135_2\">Given the following function prototype:</p>\n<pre><code>template &lt;class T&gt;\nadd_rvalue_reference_t&lt;T&gt;::type create() noexcept;\n</code></pre>\n<p id=\"so_24918426_24919135_3\">the predicate condition for a template specialization <code>is_convertible&lt;From, To&gt;</code> shall be satisfied if and only if the following vode would be well-formed, including any implicit conversions to the return type of the function:</p>\n<pre><code>To test() {\n    return create&lt;From&gt;();\n}\n</code></pre>\n</blockquote>\n<p>Here,</p>\n<pre><code>float&amp; test() {\n    return create&lt;float&gt;();\n}\n</code></pre>\n<p>is ill-formed, <code>create&lt;float&gt;()</code> returns a <code>float&amp;&amp;</code>, that is, an xvalue. The result cannot be bound to an lvalue-reference.</p>\n<hr>\n<p>It is well-known that the construction of <code>tuple</code> is not perfect; see for example <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3680.html\" rel=\"nofollow\">proposal N3680</a>, which also addresses <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2051\" rel=\"nofollow\">LWG defect 2051</a>.</p>\n<p>None of those seem to address the issue in the OP, however.</p>\n</hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2014-07-23T19:38:07.887", "Id": "24919135", "Score": "1", "CreationDate": "2014-07-23T19:21:42.953", "LastActivityDate": "2014-07-23T19:38:07.887"}, "bq_ids": {"n4140": {"so_24918426_24919135_3": {"section_id": 4718, "quality": 0.9375, "length": 15}, "so_24918426_24919135_2": {"section_id": 4710, "quality": 1.0, "length": 4}, "so_24918426_24919135_1": {"section_id": 4022, "quality": 0.8666666666666667, "length": 13}, "so_24918426_24919135_0": {"section_id": 4020, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_24918426_24919135_3": {"section_id": 4525, "quality": 0.9375, "length": 15}, "so_24918426_24919135_2": {"section_id": 4518, "quality": 1.0, "length": 4}, "so_24918426_24919135_1": {"section_id": 3872, "quality": 0.8666666666666667, "length": 13}, "so_24918426_24919135_0": {"section_id": 3870, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_24918426_24919135_3": {"section_id": 6117, "quality": 0.9375, "length": 15}, "so_24918426_24919135_0": {"section_id": 4928, "quality": 0.5714285714285714, "length": 4}}}});