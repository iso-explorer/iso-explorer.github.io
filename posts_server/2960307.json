post_cb({"2960432": {"Id": "2960432", "PostTypeId": "2", "Body": "<p><i>Are C++ compilers not supposed to initialize global PODs (including POD structures) at compilation time ?</i></p>\n<p>No.  How would they?  They are runtime constructs.  Even if the compiler built everything into the program's description (constant values on the stack) it still has to be initialized at runtime.</p>\n<p>IRC, within the same translation unit the initialization order of globals is guaranteed to be in order of declaration.  Consider where the placement of your some global object within the file.</p>\n<p>If I'm wrong about that then the order is undefined.  Furthermore, when we're talking about globals across translation units the order is undefined.  Of that I'm sure.</p>\n", "LastActivityDate": "2010-06-02T18:27:25.817", "CommentCount": "2", "CreationDate": "2010-06-02T18:27:25.817", "ParentId": "2960307", "Score": "0", "OwnerUserId": "301883"}, "2960663": {"Id": "2960663", "PostTypeId": "2", "Body": "<p>According to the C++ standard, 3.6.2.2: Initialization of non-local objects:</p>\n<blockquote>\n<p id=\"so_2960307_2960663_0\">Together, zero-initialization and\n  constant initialization are called\n  static initialization; all other\n  initialization is dynamic\n  initialization. Static initialization\n  shall be performed before any dynamic\n  initialization takes place.</p>\n</blockquote>\n<p>Since <code>myArrayOfPod</code> is at least at first glance initialized with a constant expression, it should be initialized before <code>oSomeGlobalObject</code>. The fact that it isn't in debug is probably a bug. You can submit a bug through <a href=\"http://connect.microsoft.com\" rel=\"nofollow noreferrer\">connect.microsoft.com</a>.</p>\n", "LastActivityDate": "2010-06-02T18:53:05.067", "CommentCount": "0", "CreationDate": "2010-06-02T18:53:05.067", "ParentId": "2960307", "Score": "3", "OwnerUserId": "6210"}, "2960307": {"ViewCount": "1735", "Body": "<p>I've got bitten today by a bug.</p>\n<h2>Question for the C++ lawyers</h2>\n<p>Let's consider the following source :</p>\n<pre><code>struct MyPod\n{\n   short              m_short ;\n   const char * const m_string ;\n} ;\n\nMyPod myArrayOfPod[] = { { 1, \"Hello\" } } ;\n\nint main(int argc, char * argv[])\n{\n   return 0 ;\n}\n</code></pre>\n<p>Note that all values are known at compile time, and that MyPod is a POD.</p>\n<p><b>So, should myArrayOfPod be initialized at compile time, or will some default constructor of MyPod be generated by the compiler ?</b></p>\n<h2>Details including a self-contained source</h2>\n<p>The following source which reproduces the error, can be copy/pasted into a main.cpp file:</p>\n<pre><code>#include &lt;iostream&gt;\n\n// The point of SomeGlobalObject is for its\n// constructor to be launched before the main\n// ...\nstruct SomeGlobalObject\n{\n   SomeGlobalObject() ;\n} ;\n\n// ...\n// Which explains the global object\nSomeGlobalObject oSomeGlobalObject ;\n\n// A POD... I was hoping it would be constructed at\n// compile time when using an argument list\nstruct MyPod\n{\n   short              m_short ;\n   const char * const m_string ;\n} ;\n\n// declaration/Initialization of a MyPod array\nMyPod myArrayOfPod[] = \n{ { 1, \"Hello\" }, { 2, \"World\" }, { 3, \" !\" } } ;\n\n// declaration/Initialization of an array of array of void *\nvoid * myArrayOfVoid[][2] = \n{ { (void *)1, \"Hello\" }, { (void *)2, \"World\" }, { (void *)3, \" !\" } } ;\n\n// constructor of the global object... Launched BEFORE main\nSomeGlobalObject::SomeGlobalObject()\n{\n   // The two values should be \"1\"\n   std::cout &lt;&lt; \"myArrayOfPod[0].m_short : \" &lt;&lt; myArrayOfPod[0].m_short &lt;&lt; std::endl ;\n   std::cout &lt;&lt; \"myArrayOfVoid[0][0] : \" &lt;&lt; myArrayOfVoid[0][0] &lt;&lt; std::endl ;\n}\n\n// main... What else ?\nint main(int argc, char* argv[])\n{\n   return 0 ;\n}\n</code></pre>\n<p>MyPod being a POD, I believed there would be no constructors. Only initialization at compile time.</p>\n<p>Thus, the global object <code>SomeGlobalObject</code> would have no problem to use the global array of PODs upon its construction.</p>\n<p>But, in Visual C++ 2008, on debug mode, upon execution <code>myArrayOfPod</code> is not properly initialized (all its values are zero-ed), even if <code>myArrayOfVoid</code> is correctly initialized.</p>\n<p>So my questions is: <i>Are C++ compilers not supposed to initialize global PODs (including POD structures) at compilation time ?</i></p>\n<h3>Displaimer</h3>\n<p>Note that I know global variable are evil, and I know that one can't be sure of the order of creation of global variables declared in different compilation units, but this is out-of-topic: The question is about global POD initialization.</p>\n<h2>Edit</h2>\n<p>I copy/pasted this code on my Ubuntu, and as far as g++ 4.4.3 is concerned, the two arrays are correctly initialized in both debug and release mode.</p>\n<p>The behaviour was reported to Microsoft, and awaiting confirmation:\n<a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/564844/pod-struct-global-object-initialization-uses-constructor\" rel=\"nofollow noreferrer\"><a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/564844/pod-struct-global-object-initialization-uses-constructor\" rel=\"nofollow noreferrer\">https://connect.microsoft.com/VisualStudio/feedback/details/564844/pod-struct-global-object-initialization-uses-constructor</a></a></p>\n<h2>Edit 2</h2>\n<p>Visual C++ QA answered the bug submission, quoting the standard (at least, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">n3092</a>). As far as they are concerned, the behaviour seen on Visual C++ does follow the standard.</p>\n<p>And despite my \"feeling\" this is still a bug, I must acknowledge the fact they know the standard infinitely more than I do (if only because I <i>use the language</i>, when they <i>write a compiler for the language</i>), and thus accept their answer.</p>\n<p>So, I'll do my homework, that is, I'll read <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">n3092</a> from start to end (A thousand pages of lawyer-like statements... This is my luck...): This document uses a lot of well-defined words, and if I don't know the exact meaning of each word, then there's no way I can quote some <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow noreferrer\">n3092</a> paragraph to support my viewpoint...</p>\n<p>Thanks to <a href=\"https://stackoverflow.com/users/6210/msn\">MSN</a> and <a href=\"https://stackoverflow.com/users/187690/andreyt\">AndreyT</a> for their answers.</p>\n", "Title": "POD global object initialization", "CreationDate": "2010-06-02T18:10:22.767", "LastActivityDate": "2010-06-19T22:51:11.260", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:30:21.980", "LastEditorUserId": "-1", "Id": "2960307", "Score": "3", "OwnerUserId": "14089", "Tags": "<c++><initialization><global-variables><pod>", "AnswerCount": "4"}, "2960395": {"Id": "2960395", "PostTypeId": "2", "Body": "<p>To me it seems like it is a point of which order the globals are initialized, not whether they are.  It must be the Debug mode calls the global initialization code in a different order than release mode.</p>\n<p>Globals referencing globals... can there be degrees of evil?  ;-)</p>\n<p>Edit:\nPresumably if you put the two cout's in main you'll see all the globals have been initialized by the time it gets there.</p>\n", "LastActivityDate": "2010-06-02T18:22:23.633", "CommentCount": "0", "CreationDate": "2010-06-02T18:22:23.633", "ParentId": "2960307", "Score": "0", "OwnerUserId": "350821"}, "bq_ids": {"n4140": {"so_2960307_2960663_0": {"length": 18, "quality": 0.9, "section_id": 7151}}, "n3337": {"so_2960307_2960663_0": {"length": 18, "quality": 0.9, "section_id": 6895}}, "n4659": {"so_2960307_2960663_0": {"length": 14, "quality": 0.7, "section_id": 8652}}}, "2960572": {"Id": "2960572", "PostTypeId": "2", "Body": "<p>C++ language guarantees that POD objects with static storage duration initialized with <em>constant expressions</em> are initialized <em>statically</em>, i.e. \"at compile time\". More pedantically, regardless of how static initialization is implemented (at compile time, at run time), it must take place <em>before</em> any dynamic initialization. A constructor call, for example, is dynamic initialization.</p>\n<p>In your case <code>myArrayOfPod</code> is a POD, integer literals are integer constant expressions, and string literals are address constant expressions. I'd say that your <code>myArrayOfPod</code> satisfies all requirements and therefore must be initialized statically. If you observe uninitialized <code>myArrayOfPod</code> from the constructor of <code>oSomeGlobalObject</code> in your experiment, it must be a bug in the compiler.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-06-02T18:51:56.193", "Score": "1", "CreationDate": "2010-06-02T18:43:43.733", "ParentId": "2960307", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2010-06-02T18:51:56.193"}});