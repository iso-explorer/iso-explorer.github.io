post_cb({"bq_ids": {"n4140": {"so_17736337_17807344_0": {"length": 44, "quality": 1.0, "section_id": 332}, "so_17736337_17807344_1": {"length": 15, "quality": 1.0, "section_id": 339}, "so_17736337_17807344_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 339}}, "n3337": {"so_17736337_17807344_0": {"length": 44, "quality": 1.0, "section_id": 322}, "so_17736337_17807344_1": {"length": 15, "quality": 1.0, "section_id": 329}, "so_17736337_17807344_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 329}}, "n4659": {"so_17736337_17807344_0": {"length": 44, "quality": 1.0, "section_id": 341}, "so_17736337_17807344_1": {"length": 15, "quality": 1.0, "section_id": 348}, "so_17736337_17807344_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 348}}}, "17807344": {"Id": "17807344", "PostTypeId": "2", "Body": "<p>Template arguments for a function are deduced from the types of the function's template parameters. Template arguments can only be deduced from a type when that type is one of the allowed forms. The allowed forms are specified in [temp.deduct.type]</p>\n<blockquote>\n<p id=\"so_17736337_17807344_0\">Template arguments can be deduced in several different contexts, but in each case a type that is specified in terms of template parameters (call it <code>P</code>) is compared with an actual type (call it <code>A</code>), and an attempt is made to find template argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) that will make <code>P</code>, after substitution of the deduced values (call it the deduced <code>A</code>), compatible with <code>A</code>.</p>\n<p id=\"so_17736337_17807344_1\">A template type argument <code>T</code>, a template template argument <code>TT</code> or a template non-type argument <code>i</code> can be deduced if <code>P</code> and <code>A</code> have one of the following forms:</p>\n</blockquote>\n<pre>T\ncv-list T\nT*\nT&amp;\nT[integer-constant]\ntemplate-name (where template-name refers to a class template)\ntype(*)(T)\nT(*)()\nT(*)(T)\nT type::*\ntype T::*\nT T::*\nT (type::*)()\ntype (T::*)()\ntype (type::*)(T)\ntype (T::*)(T)\nT (type::*)(T)\nT (T::*)()\nT (T::*)(T)\ntype[i]\ntemplate-name&amp;lti;&gt; (where template-name refers to a class template)\nTT&lt;T&gt;\nTT&lt;i&gt;\nTT&lt;&gt;</pre>\n<blockquote>\n<p id=\"so_17736337_17807344_2\">where <code>(T)</code> represents argument lists where at least one argument type contains a <code>T</code>, and <code>()</code> represents argument lists where no parameter contains a <code>T</code>. Similarly, <code>&lt;T&gt;</code> represents template argument lists where at least one argument contains a <code>T</code>, <code>&lt;i&gt;</code> represents template argument lists where at least one argument contains an <code>i</code> and <code>&lt;&gt;</code> represents template argument lists where no argument contains a <code>T</code> or an <code>i</code>.</p>\n</blockquote>\n<p>When considering only non-type template arguments, the relevant forms are those that contain <code>i</code>:</p>\n<pre>type[i]\ntemplate-name&amp;lti;&gt; (where template-name refers to a class template)\nTT&lt;i&gt;</pre>\n<p>Therefore it is not possible to deduce the value directly from the value of a function argument that is the function pointer. However it <strong>is</strong> possible to deduce the value of a non-type template argument if the function parameter has one of the specified forms. </p>\n<p>The following code ahieves this by wrapping the non-type template argument value in a class-template called <code>NonType</code>. The parameter of <code>f</code> is in the form <code>template-name&lt;i&gt;</code>, making it possible for the value of its non-type template argument to be deduced.</p>\n<pre><code>template&lt;typename T, T value&gt;\nstruct NonType {};\n\ntemplate&lt;typename T, T value&gt;\nvoid f(NonType&lt;T, value&gt;)\n{\n}\n\nvoid g();\n\nstruct A\n{\n    void f();\n    int m;\n};\n\nint i;\n\n#define MAKE_NONTYPE(value) NonType&lt;decltype(value), (value)&gt;()\n\nint main()\n{\n    f(MAKE_NONTYPE(0)); // NonType&lt;int, 0&gt;\n    f(MAKE_NONTYPE(&amp;g)); // NonType&lt;void(*)(), &amp;g&gt;\n    f(MAKE_NONTYPE(&amp;A::f)); // NonType&lt;void(A::*)(), &amp;A::f&gt;\n    f(MAKE_NONTYPE(&amp;A::m)); // NonType&lt;int A::*, &amp;A::m&gt;\n    f(MAKE_NONTYPE(&amp;i)); // NonType&lt;int*, &amp;i&gt;\n}\n</code></pre>\n<p>Note that <code>decltype</code> and the <code>MAKE_NON_TYPE</code> macro are used here only as a convenience, to avoid having to write out the full template argument list of <code>NonType</code></p>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2013-07-23T11:27:44.913", "Score": "2", "CreationDate": "2013-07-23T10:16:24.260", "ParentId": "17736337", "CommentCount": "0", "OwnerUserId": "1690864", "LastEditDate": "2013-07-23T11:27:44.913"}, "17736337": {"ViewCount": "643", "Body": "<p>C++ allows non-type template parameters to be of pointer, including function pointer, type. I recently asked a <a href=\"https://stackoverflow.com/questions/15191103/use-case-for-non-type-template-parameter-thats-not-of-integral-enumeration-type/17654008\">question</a> about what this is useful for, and this is a follow up to <a href=\"https://stackoverflow.com/a/17654008/141719\">one of the answers</a>.</p>\n<p>Is it posible to deduce the <strong>value</strong> of a function pointer template parameter, from a function argument that is the function pointer in question? For example:</p>\n<pre><code>using VoidFunction = void(*)();\n\ntemplate &lt;VoidFunction F&gt;\nvoid templ(VoidFunction);\n\n...\n\nvoid func();  // a VoidFunction\n\n...\n\ntempl&lt;func&gt;(func);  // works, but I have to specify the template parameter explicitly\ntempl(func);        //  &lt;-- I would like to be able to do this\n</code></pre>\n<p>Is there a way to get this deduction to happen? It seems technically possible from a compiler implementer's point of view, as long as the function argument can be resolved to a function in the code at compile time.</p>\n<p>If you're wondering about the motivation behind this, see the comments under <a href=\"https://stackoverflow.com/a/17654008/141719\">this answer</a>, particularly a possible optimization for the implementation of <code>std::bind()</code>.</p>\n<p><strong>EDIT</strong>: I realize that I could simply remove the function argument and use the template argument, as in <code>templ&lt;func&gt;()</code>. My only purpose of adding in the function argument was to try to avoid having to pass the template argument.</p>\n<p>I guess what I really want, is to also deduce the <strong>type</strong> of the function pointer, as in:</p>\n<pre><code>template &lt;typename Function, Function F&gt;\nvoid templ(/* something */);\n</code></pre>\n<p>and then be able to call</p>\n<pre><code>templ(func);\n</code></pre>\n<p>or</p>\n<pre><code>templ&lt;func&gt;();\n</code></pre>\n<p>and have both the type and value be deduced from a single mention of the function pointer.</p>\n<p>Hope that makes more sense now.</p>\n", "AcceptedAnswerId": "17807344", "Title": "Is there a way to deduce the value of a function pointer template parameter?", "CreationDate": "2013-07-19T00:41:19.927", "Id": "17736337", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:24:53.610", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-23T11:27:44.913", "Score": "6", "OwnerUserId": "141719", "Tags": "<c++><templates><non-type><template-deduction>", "AnswerCount": "1"}});