post_cb({"34488782": {"ParentId": "34488559", "PostTypeId": "2", "CommentCount": "17", "Body": "<p><a href=\"https://gcc.gnu.org/onlinedocs/gcc/Pointers-to-Arrays.html\" rel=\"nofollow\">GCC-gnu</a></p>\n<blockquote>\n<p id=\"so_34488559_34488782_0\">In GNU C, pointers to arrays with qualifiers work similar to pointers to other qualified types. For example, a value of type <code>int (*)[5]</code> can be used to initialize a variable of type <code>const int (*)[5]</code>. <strong>These types are incompatible in ISO C because the <code>const</code> qualifier is formally attached to the element type of the array and not the array itself</strong>. </p>\n</blockquote>\n<p>C standard says that (section: \u00a76.7.3/9):  </p>\n<blockquote>\n<p id=\"so_34488559_34488782_1\">If the specification of an array type includes any type qualifiers, the element type is so- qualified, <strong>not the array type</strong>.[...]   </p>\n</blockquote>\n<p>Now look at the C++ standard (section \u00a7 3.9.3/5):  </p>\n<blockquote>\n<p id=\"so_34488559_34488782_2\">[...] Cv-qualifiers applied to an array type attach to the underlying element type, so the notation \u201c<code>cv T</code>,\u201d where <code>T</code> is an array type, refers to an array whose elements are so-qualified. <strong>An array type whose elements are cv-qualified is also considered to have the same cv-qualifications as its elements</strong>. [ <em>Example</em>:  </p>\n<pre><code> typedef char CA[5];\n typedef const char CC;\n CC arr1[5] = { 0 };\n const CA arr2 = { 0 };\n</code></pre>\n<p id=\"so_34488559_34488782_3\">The type of both <code>arr1</code> and <code>arr2</code> is <em>\u201carray of 5 const char,\u201d</em> and <strong>the array type is considered to be const- qualified</strong>. \u2014endexample]  </p>\n</blockquote>\n<p>Therefore, the initialization  </p>\n<pre><code>const int (*p2)[9] = &amp;array;  \n</code></pre>\n<p>is assignment of type <em>pointer to array[9] of <code>int</code></em> to <em>pointer to array[9] of const <code>int</code></em>. This is not similar to assigning <code>int *</code> to a <code>const int *</code> where <code>const</code> is applied directly to the <strong>object type the pointer points to</strong>. This is not the case with <code>const int(*)[9]</code> where, in C, <code>const</code> is applied to the elements of the array object instead of the object the pointer points to. This makes the above initialization incompatible.  </p>\n<p>This rule is changed in C++. As <code>const</code> is applied to array object itself, the assignment is between same types <em>pointer to const array[9] of <code>int</code></em> instead of type <em>pointer to array[9] of <code>int</code></em> and <em>pointer to array[9] of const <code>int</code></em>.</p>\n", "OwnerUserId": "2455888", "LastEditorUserId": "2455888", "LastEditDate": "2015-12-29T13:43:29.073", "Id": "34488782", "Score": "20", "CreationDate": "2015-12-28T06:38:59.093", "LastActivityDate": "2015-12-29T13:43:29.073"}, "34488559": {"CommentCount": "1", "AcceptedAnswerId": "34488782", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2015-12-28T06:15:42.907", "LastActivityDate": "2015-12-29T13:43:29.073", "LastEditDate": "2015-12-28T06:27:36.697", "ViewCount": "1408", "FavoriteCount": "6", "Title": "Pointer to array with const qualifier in C & C++", "Id": "34488559", "Score": "16", "Body": "<p>Consider following program:</p>\n<pre><code>int main()\n{\n    int array[9];\n    const int (*p2)[9] = &amp;array;\n}\n</code></pre>\n<p>It compiles fine in C++ (See live demo <a href=\"http://melpon.org/wandbox/permlink/aB4aSHz3XpIArfCA\">here</a>) but fails in compilation in C. By default GCC gives following warnings. (See live demo <a href=\"http://melpon.org/wandbox/permlink/J8doYpCX4NNamH45\">here</a>).</p>\n<pre><code>prog.c: In function 'main':\nprog.c:4:26: warning: initialization from incompatible pointer type [enabled by default]\n     const int (*p2)[9] = &amp;array;\n</code></pre>\n<p>But If I use <code>-pedantic-errors</code> option:</p>\n<pre><code>gcc -Os -s -Wall -std=c11 -pedantic-errors -o constptr constptr.c\n</code></pre>\n<p>it gives me following compiler error</p>\n<pre><code>constptr.c:4:26: error: pointers to arrays with different qualifiers are incompatible in ISO C [-Wpedantic]\n</code></pre>\n<p>Why it fails in compilation in C but not in C++? What C &amp; C++ standard  says about this?</p>\n<p>If I  use <strong>const</strong> qualifier in array declaration statement it compiles fine in C also. So, what is happening here in above program? </p>\n", "Tags": "<c++><c><arrays><pointers><const>", "OwnerUserId": "3777958", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34488559_34488782_2": {"section_id": 7229, "quality": 0.9655172413793104, "length": 28}, "so_34488559_34488782_3": {"section_id": 7229, "quality": 0.6923076923076923, "length": 9}, "so_34488559_34488782_1": {"section_id": 300, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_34488559_34488782_2": {"section_id": 6973, "quality": 0.6206896551724138, "length": 18}, "so_34488559_34488782_1": {"section_id": 291, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_34488559_34488782_2": {"section_id": 8740, "quality": 0.9655172413793104, "length": 28}, "so_34488559_34488782_3": {"section_id": 8740, "quality": 0.6923076923076923, "length": 9}, "so_34488559_34488782_1": {"section_id": 307, "quality": 0.6363636363636364, "length": 7}}}});