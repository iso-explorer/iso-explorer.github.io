post_cb({"1421736": {"PostTypeId": "2", "Body": "<p>They're initialized before the program starts (i.e. before <code>main</code> is entered).</p>\n<p>When there are two or more definitions (of static data) in a single CPP file, then they're initialized in the sequence in which they're defined in the file (the one defined earlier/higher in the file is initialized before the next one is).</p>\n<p>When there are two or more definitions (of static data) in more than one CPP file, the sequence in which the CPP files are processed is undefined/implementation-specific. This is a problem if the constructor of a global variable (called before the program is started) references another global variable defined in a different CPP file, which might not have been constructed yet. However, item 47 of Meyers' <em>Effective C++</em> (which is titled <em>Ensure that global objects are initialized before they're used</em>) does describes a work-around ...</p>\n<ul>\n<li><p>Define a static variable in a header file (it's static so you can have multiple instances of it without the linker complaining)</p></li>\n<li><p>Have the constructor of that variable invoke whatever you need it to (in particular, construct the global singletons declared in the headers)</p></li>\n</ul>\n<p>... which it says is a technique which may be used in some system header files e.g. to ensure that the <code>cin</code> global variable is initialized before even your static variables' constructors use it.</p>\n", "LastActivityDate": "2009-09-14T14:21:35.613", "LastEditorUserId": "49942", "Id": "1421736", "CommentCount": "2", "CreationDate": "2009-09-14T14:01:05.203", "ParentId": "1421671", "Score": "16", "OwnerUserId": "49942", "LastEditDate": "2009-09-14T14:21:35.613"}, "1421715": {"PostTypeId": "2", "Body": "<p>They can be initialized in  an implementation file (.c/cpp/cc) files. Dont initialize them in .h as compiler will complain about multiple definitions. </p>\n<p>They are typically initialized  before main, however order is uknown, hence avoid dependencies. They can certainly be accessed within member function. Keep in mind, order of initialization is unknown for static members.  I would suggest to encapsulate a static member into the static function that will check if the member has been initialized. </p>\n", "LastActivityDate": "2009-09-14T13:58:17.967", "Id": "1421715", "CommentCount": "0", "CreationDate": "2009-09-14T13:58:17.967", "ParentId": "1421671", "Score": "1", "OwnerUserId": "149045"}, "1421706": {"PostTypeId": "2", "Body": "<p>I believe it can be accessed anytime during the execution. What remains undefined is the initialization order of the static variables.</p>\n", "LastActivityDate": "2009-09-14T13:57:29.653", "Id": "1421706", "CommentCount": "0", "CreationDate": "2009-09-14T13:57:29.653", "ParentId": "1421671", "Score": "0", "OwnerUserId": "137380"}, "1421780": {"PostTypeId": "2", "Body": "<p>The standard guarantees two things - that objects defined in the same translation unit (usually it means .cpp file) are initialized in order of their definitions (<strong>not declarations</strong>):</p>\n<p>3.6.2</p>\n<blockquote>\n<p id=\"so_1421671_1421780_0\">The storage for objects with static storage duration (basic.stc.static) shall be zero-initialized (dcl.init) before any other initialization takes place. Zero-initialization and initialization with a constant expression are collectively called static initialization; all other initialization is dynamic initialization. Objects of POD types (basic.types) with static storage duration initialized with constant expressions (expr.const) shall be initialized before any dynamic initialization takes place. Objects with static storage duration defined in namespace scope in the same translation unit and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit.</p>\n</blockquote>\n<p>The other guaranteed thing is that initialization of static objects from a translation unit will be done before use of any object or function from this translation unit:</p>\n<blockquote>\n<p id=\"so_1421671_1421780_1\">It is implementation-defined whether or not the dynamic initialization (dcl.init, class.static, class.ctor, class.expl.init) of an object of namespace scope is done before the first statement of main. If the initialization is deferred to some point in time after the first statement of main, it shall occur before the first use of any function or object defined in the same translation unit as the object to be initialized.</p>\n</blockquote>\n<p>Nothing else i guaranteed (especially order of initialization of objects defined in different translation units is implementation defined).</p>\n<p><s>EDIT\nAs pointed in Suma's comment, it is also guaranteed that they are initialized before <code>main</code> is entered.</s></p>\n", "LastActivityDate": "2015-05-07T09:17:28.673", "LastEditorUserId": "113662", "Id": "1421780", "CommentCount": "4", "CreationDate": "2009-09-14T14:07:27.243", "ParentId": "1421671", "Score": "45", "OwnerUserId": "113662", "LastEditDate": "2015-05-07T09:17:28.673"}, "1421671": {"ViewCount": "24105", "Body": "<p>There appears to be no easy answer to this, but are there any assumptions that can be safely made about when a static class field can be accessed?</p>\n<p>EDIT: The only safe assumption seems to be that all statics are initialized before the program commences (call to <code>main</code>).  So, as long as I don't reference statics from other static initialization code, I should have nothing to worry about? </p>\n", "AcceptedAnswerId": "1421780", "Title": "When are static C++ class members initialized?", "CreationDate": "2009-09-14T13:51:15.380", "Id": "1421671", "CommentCount": "5", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2009-09-14T14:02:00.600", "LastEditorUserId": "67063", "LastActivityDate": "2015-07-22T09:57:31.260", "Score": "51", "OwnerUserId": "67063", "Tags": "<c++><static><initialization>", "AnswerCount": "7"}, "1422095": {"PostTypeId": "2", "Body": "<p>i think the main thread of a proccess will execute the following five steps in order</p>\n<ol>\n<li><p>initialization of CRT library</p></li>\n<li><p>static initialization</p></li>\n<li><p>execution of main() function</p></li>\n<li><p>static unitialization</p></li>\n<li><p>unitialization of CRT library</p></li>\n</ol>\n<p>you want reference statics from other static initialization code?\nmaybe the following codes work:</p>\n<pre><code>class A;\nstatic auto_ptr&lt;A&gt; a(auto_ptr&lt;A&gt;(&amp;GetStaticA()));\nA &amp;GetStaticA(void)\n{\n    static A *a = NULL; //the static basic type variables initialized with constant experession will be initialized earlier than the other static ones\n    if (a == NULL)\n    {\n         a = new A();\n         return *a;\n    }\n}\n</code></pre>\n", "OwnerDisplayName": "Liulz", "LastActivityDate": "2009-09-14T14:57:41.197", "Id": "1422095", "CommentCount": "0", "CreationDate": "2009-09-14T14:57:41.197", "ParentId": "1421671", "Score": "-1"}, "bq_ids": {"n4140": {"so_1421671_1421780_0": {"length": 35, "quality": 0.5555555555555556, "section_id": 7151}, "so_1421671_1421780_1": {"length": 26, "quality": 0.7027027027027027, "section_id": 7153}}, "n3337": {"so_1421671_1421780_0": {"length": 35, "quality": 0.5555555555555556, "section_id": 6895}, "so_1421671_1421780_1": {"length": 26, "quality": 0.7027027027027027, "section_id": 6897}}}, "1421710": {"PostTypeId": "2", "Body": "<p>There isn't a totally trivial answer to this question, but basically they're initialized just before control is passed to the entry point (main) of your program. The order in which they are initialized is (to my knowledge) undefined and may be compiler specific.</p>\n<p>EDIT: To clarify, your added assumption is correct. As long as you're only accessing it post main-entry, you don't really have to worry about when/how it's initialized. It will be initialized by that time.</p>\n", "LastActivityDate": "2009-09-14T14:14:03.553", "LastEditorUserId": "170801", "Id": "1421710", "CommentCount": "0", "CreationDate": "2009-09-14T13:57:47.970", "ParentId": "1421671", "Score": "0", "OwnerUserId": "170801", "LastEditDate": "2009-09-14T14:14:03.553"}, "31559647": {"PostTypeId": "2", "Body": "<p>Your final conclusion in the Edit is correct. But the problem is the class static themselves. It's easier to say that my code will have class static members that don't refer to other global data/ class static members but once you take this route, things will go wrong soon. One approach that I have found useful in practice to not have class static data members but class static wrapper methods. These methods can then hold the static object within itself. For e.g.\n<code></code></p>\n<pre><code>TypeX* Class2::getClass1Instance()\n{\n    static TypeX obj1;\n    return &amp;obj1;\n}\n</code></pre>\n<p></p>\nNote: An earlier answer says:\n<blockquote>\n<p id=\"so_1421671_31559647_0\">The other guaranteed thing is that initialization of static objects\n  from a translation unit will be done before use of any object or\n  function from this translation unit</p>\n</blockquote>\n<p>This is not completely correct and the standard is incorrectly inferred here. This may not hold true if the function from a translation unit is called before main is entered.</p>\n", "LastActivityDate": "2015-07-22T09:57:31.260", "LastEditorUserId": "4734995", "Id": "31559647", "CommentCount": "0", "CreationDate": "2015-07-22T09:49:47.673", "ParentId": "1421671", "Score": "3", "OwnerUserId": "4734995", "LastEditDate": "2015-07-22T09:57:31.260"}});