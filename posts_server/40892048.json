post_cb({"bq_ids": {"n4140": {"so_40892048_40894796_0": {"length": 24, "quality": 0.8, "section_id": 147}, "so_40892048_40894796_2": {"length": 17, "quality": 0.6538461538461539, "section_id": 147}, "so_40892048_40894796_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 163}, "so_40892048_40892048_3": {"length": 22, "quality": 1.0, "section_id": 147}, "so_40892048_40894796_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 162}, "so_40892048_40892048_4": {"length": 22, "quality": 1.0, "section_id": 147}, "so_40892048_40894796_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 161}, "so_40892048_40892048_2": {"length": 24, "quality": 0.8, "section_id": 147}, "so_40892048_40894796_1": {"length": 8, "quality": 0.8, "section_id": 147}, "so_40892048_40892048_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 143}}, "n3337": {"so_40892048_40894796_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 156}, "so_40892048_40894796_2": {"length": 17, "quality": 0.6538461538461539, "section_id": 141}, "so_40892048_40894796_0": {"length": 24, "quality": 0.8, "section_id": 141}, "so_40892048_40894796_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 157}, "so_40892048_40892048_3": {"length": 22, "quality": 1.0, "section_id": 141}, "so_40892048_40892048_4": {"length": 22, "quality": 1.0, "section_id": 141}, "so_40892048_40894796_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 155}, "so_40892048_40892048_2": {"length": 24, "quality": 0.8, "section_id": 141}, "so_40892048_40894796_1": {"length": 8, "quality": 0.8, "section_id": 141}, "so_40892048_40892048_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 137}}, "n4659": {"so_40892048_40894796_0": {"length": 27, "quality": 0.9, "section_id": 151}, "so_40892048_40894796_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 166}, "so_40892048_40894796_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 167}, "so_40892048_40892048_3": {"length": 20, "quality": 0.9090909090909091, "section_id": 151}, "so_40892048_40894796_2": {"length": 26, "quality": 1.0, "section_id": 151}, "so_40892048_40892048_4": {"length": 20, "quality": 0.9090909090909091, "section_id": 151}, "so_40892048_40894796_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 165}, "so_40892048_40892048_2": {"length": 27, "quality": 0.9, "section_id": 151}, "so_40892048_40894796_1": {"length": 10, "quality": 1.0, "section_id": 151}, "so_40892048_40892048_1": {"length": 32, "quality": 0.9696969696969697, "section_id": 147}}}, "40892048": {"ViewCount": "460", "Body": "\n<p>While trying to implement a few things relying on variadic templates, I stumbled accross something I cannot explain. I boiled down the problem to the following code snippet:</p>\n<pre><code>template &lt;typename ... Args&gt;\nstruct A {};\n\ntemplate &lt;template &lt;typename...&gt; class Z, typename T&gt;\nstruct test;\n\ntemplate &lt;template &lt;typename...&gt; class Z, typename T&gt;\nstruct test&lt;Z, Z&lt;T&gt;&gt; {\n    static void foo() {\n        std::cout &lt;&lt; \"I'm more specialized than the variadic spec, hehe!\" &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;template &lt;typename...&gt; class Z, typename T, typename ... Args&gt;\nstruct test&lt;Z, Z&lt;T, Args...&gt;&gt; {\n    static void foo() {\n        std::cout &lt;&lt; \"I'm variadic!\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    test&lt;A, A&lt;int&gt;&gt;::foo();\n}\n</code></pre>\n<p>Under gcc, it produces an error because it considers both specializations to be equally specialized when trying to instantiate <code>test&lt;A, A&lt;int&gt;&gt;</code>:</p>\n<pre><code>main.cpp: In function 'int main()':\n\nmain.cpp:25:24: error: ambiguous template instantiation for 'struct test&lt;A, A&lt;int&gt; &gt;'\n\n         test&lt;A, A&lt;int&gt;&gt;::foo();\n\n                        ^~\n\nmain.cpp:11:12: note: candidates are: template&lt;template&lt;class ...&gt; class Z, class T&gt; struct test&lt;Z, Z&lt;T&gt; &gt; [with Z = A; T = int]\n\n     struct test&lt;Z, Z&lt;T&gt;&gt; {\n\n            ^~~~~~~~~~~~~\n\nmain.cpp:18:12: note:                 template&lt;template&lt;class ...&gt; class Z, class T, class ... Args&gt; struct test&lt;Z, Z&lt;T, Args ...&gt; &gt; [with Z = A; T = int; Args = {}]\n\n     struct test&lt;Z, Z&lt;T, Args...&gt;&gt; {\n</code></pre>\n<p>However, clang deems the first specialization \"more specialized\" (through partial ordering: see next section) as it compiles fine and prints:</p>\n<blockquote>\n<p id=\"so_40892048_40892048_0\">I'm more specialized than the variadic spec, hehe!</p>\n</blockquote>\n<p>A <kbd><a href=\"http://coliru.stacked-crooked.com/a/f0c1f71658fac3a3\" rel=\"nofollow noreferrer\">live demo</a></kbd> can be found on Coliru. I also tried using gcc's HEAD version and got the same errors.</p>\n<p>My question here is: since these two well-known compilers behave differently, which one is right and is this piece of code correct C++?</p>\n<hr>\n<h2>Standard interpretation (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++14 current draft</a>)</h2>\n<p>From the sections \u00a714.5.5.1 and $14.5.5.2 of the C++14 standard draft, partial ordering is triggered to determine which specialization should be chosen:</p>\n<blockquote>\n<p id=\"so_40892048_40892048_1\">(1.2) \u2014 If more than one matching specialization is found, the partial order rules (14.5.5.2) are used to determine\n  whether one of the specializations is more specialized than the others. If none of the specializations\n  is more specialized than all of the other matching specializations, then the use of the class template is\n  ambiguous and the program is ill-formed.</p>\n</blockquote>\n<p>Now according to \u00a714.5.5.2, the class template specializations are transformed into function templates through this procedure:</p>\n<blockquote>\n<p id=\"so_40892048_40892048_2\">For two class template partial specializations, the first is more specialized than the second if, given the\n  following rewrite to two function templates, the first function template is more specialized than the second\n  according to the ordering rules for function templates (14.5.6.2):</p>\n<p id=\"so_40892048_40892048_3\">(1.1) \u2014 the first function template has the same template parameters as the first partial specialization and has\n  a single function parameter whose type is a class template specialization with the template arguments\n  of the first partial specialization, and</p>\n<p id=\"so_40892048_40892048_4\">(1.2) \u2014 the second function template has the same template parameters as the second partial specialization\n  and has a single function parameter whose type is a class template specialization with the template\n  arguments of the second partial specialization.</p>\n</blockquote>\n<p>Therefore, I tried to reproduce the issue with the function template overloads that the transformation described above should generate:</p>\n<pre><code>template &lt;typename T&gt;\nvoid foo(T const&amp;) {\n    std::cout &lt;&lt; \"Generic template\\n\";\n}\n\ntemplate &lt;template &lt;typename ...&gt; class Z, typename T&gt;\nvoid foo(Z&lt;T&gt; const&amp;) {\n    std::cout &lt;&lt; \"Z&lt;T&gt;: most specialized overload for foo\\n\";\n}\n\ntemplate &lt;template &lt;typename ...&gt; class Z, typename T, typename ... Args&gt;\nvoid foo(Z&lt;T, Args...&gt; const&amp;) {\n    std::cout &lt;&lt; \"Z&lt;T, Args...&gt;: variadic overload\\n\";\n}\n</code></pre>\n<p>Now trying to use it like this:</p>\n<pre><code>template &lt;typename ... Args&gt;\nstruct A {};\n\nint main() {\n    A&lt;int&gt; a;\n    foo(a);\n}\n</code></pre>\n<p>yields a compilation error [ambiguous call] in both clang and gcc: <kbd><a href=\"http://coliru.stacked-crooked.com/a/8f4232a317c6f7be\" rel=\"nofollow noreferrer\">live demo</a></kbd>. I expected clang would at least have a behavior consistent with the class template case.</p>\n<p>Then, this is my interpretation of the standard (which I seem to share with @Danh), so at this point we need a <a class=\"post-tag\" href=\"/questions/tagged/language-lawyer\" rel=\"tag\" title=\"show questions tagged 'language-lawyer'\">language-lawyer</a> to confirm this.</p>\n<p><strong>Note:</strong> I browsed a bit LLVM's bug tracker and could not find a ticket for the behavior observed on function templates overloads in this question.</p>\n</hr>", "Title": "Class template specialization priority/ambiguity", "CreationDate": "2016-11-30T15:23:24.233", "LastActivityDate": "2016-12-01T09:17:27.080", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-12-01T09:17:27.080", "LastEditorUserId": "1794345", "Id": "40892048", "Score": "16", "OwnerUserId": "1794345", "Tags": "<c++><c++11><language-lawyer><variadic-templates><template-specialization>", "AnswerCount": "1"}, "40894796": {"Id": "40894796", "PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/temp.class.spec#temp.class.order-1\" rel=\"nofollow noreferrer\">temp.class.order</a>:</p>\n<blockquote>\n<p id=\"so_40892048_40894796_0\">For two class template partial specializations, the first is more specialized than the second if, given the following rewrite to two function templates, the first function template is more specialized than the second according to the ordering rules for function templates (<a href=\"http://eel.is/c++draft/temp.func.order\" rel=\"nofollow noreferrer\"><code>[temp.func.order]</code></a>):</p>\n<ul>\n<li><p id=\"so_40892048_40894796_1\">Each of the two function templates has the same template parameters as the corresponding partial specialization.</p></li>\n<li><p id=\"so_40892048_40894796_2\">Each function template has a single function parameter whose type is a class template specialization where the template arguments are the corresponding template parameters from the function template for each template argument in the template-argument-list of the simple-template-id of the partial specialization. </p></li>\n</ul>\n</blockquote>\n<p>The order of:</p>\n<pre><code>template &lt;template &lt;typename...&gt; class Z, typename T&gt;\nstruct test&lt;Z, Z&lt;T&gt;&gt; {\n    static void foo() {\n        std::cout &lt;&lt; \"I'm more specialized than the variadic spec, hehe!\" &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;template &lt;typename...&gt; class Z, typename T, typename ... Args&gt;\nstruct test&lt;Z, Z&lt;T, Args...&gt;&gt; {\n    static void foo() {\n        std::cout &lt;&lt; \"I'm variadic!\" &lt;&lt; std::endl;\n    }\n};\n</code></pre>\n<p>depends on the order of:</p>\n<pre><code>template &lt;template &lt;typename...&gt; class Z, typename T&gt;\nvoid bar(test&lt;Z, Z&lt;T&gt;&gt;); // #1\ntemplate &lt;template &lt;typename...&gt; class Z, typename T, typename ... Args&gt;\nvoid bar(test&lt;Z, Z&lt;T, Args...&gt;&gt;); // #2\n</code></pre>\n<p>From <a href=\"http://eel.is/c++draft/temp.func.order\" rel=\"nofollow noreferrer\"><code>[temp.func.order]</code></a>:</p>\n<blockquote>\n<p id=\"so_40892048_40894796_3\">Partial ordering selects which of two function templates is more specialized than the other by transforming each template in turn (see next paragraph) and performing template argument deduction using the function type. The deduction process determines whether one of the templates is more specialized than the other. If so, the more specialized template is the one chosen by the partial ordering process.</p>\n<p id=\"so_40892048_40894796_4\">To produce the transformed template, for each type, non-type, or template template parameter (including template parameter packs ([temp.variadic]) thereof) synthesize a unique type, value, or class template respectively and substitute it for each occurrence of that parameter in the function type of the template.</p>\n<p id=\"so_40892048_40894796_5\">Using the transformed function template's function type, perform type deduction against the other template as described in <a href=\"http://eel.is/c++draft/temp.deduct.partial\" rel=\"nofollow noreferrer\"><code>[temp.deduct.partial]</code></a>.</p>\n</blockquote>\n<p>By those paragraph, for any function transformed from any synthesized template <code>Z0</code> and type <code>T0</code>, which can form <code>#1</code>, we can do type deduction with <code>#2</code>. But functions transformed from <code>#2</code> with fictitious template <code>Z2</code> with any type <code>T2</code> and any non-empty set of <code>Args2</code> can't be deduced from <code>#1</code>. <code>#1</code> is obviously more specialized than <code>#2</code>.</p>\n<p>clang++ is right in this case.</p>\n<hr>\n<p>Actually, <a href=\"http://coliru.stacked-crooked.com/a/9d7a233c505962d7\" rel=\"nofollow noreferrer\">this one</a> and <a href=\"http://coliru.stacked-crooked.com/a/9dbc79376d54c103\" rel=\"nofollow noreferrer\">this one</a> are failed to compile (because of ambiguous) in both g++ and clang. It seems like both compilers have hard time with template template parameters. (The latter one is clearly ordered because its order is the same of no function call).</p>\n</hr>", "LastEditorUserId": "4115625", "LastActivityDate": "2016-12-01T01:06:29.293", "Score": "2", "CreationDate": "2016-11-30T17:39:02.217", "ParentId": "40892048", "CommentCount": "4", "OwnerUserId": "4115625", "LastEditDate": "2016-12-01T01:06:29.293"}});