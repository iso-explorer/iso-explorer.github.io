post_cb({"21818503": {"ParentId": "21809838", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote id=\"so_21809838_21818503_0\">\n<pre><code>std::istringstream(\"G B S\") &gt;&gt; std::noskipws &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\n</code></pre>\n</blockquote>\n<p>When an extraction is performed on strings, the string is first cleared and characters are inserted into its buffer.</p>\n<blockquote>\n<p id=\"so_21809838_21818503_1\"><strong>21.4.8.9 Inserters and extractors</strong></p>\n<pre><code> template&lt;class charT, class traits, class Allocator&gt;\n basic_istream&lt;charT, traits&gt;&amp;\n     operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; is,\n                basic_string&lt;charT, traits, Allocator&gt;&amp; str);\n</code></pre>\n<p id=\"so_21809838_21818503_2\">Effects: Behaves as a formatted input function (27.7.2.2.1). After constructing a sentry object, if the sentry converts to <code>true</code>, <strong>calls <code>str.erase()</code></strong> and then extracts characters from <code>is</code> and appends them to <code>str</code> as if by calling <code>str.append(1, c).</code> [...]</p>\n</blockquote>\n<p>The first read will extract the string <code>\"G\"</code> into <code>first</code>. For the second extraction, nothing will be extracted because the <code>std::noskipws</code> format flag is set, disabling the clearing of leading whitespace. Because of this, the string is cleared and then the extraction fails because no characters were put in. Here is the continuation of the above clause:</p>\n<blockquote>\n<p id=\"so_21809838_21818503_3\"><strong>21.4.8.9 Inserters and extractors (Cont.)</strong></p>\n<p id=\"so_21809838_21818503_4\">[...] Characters are extracted and appended until any of the following occurs:</p>\n<ul>\n<li><p id=\"so_21809838_21818503_5\"><code>n</code> characters are stored;</p></li>\n<li><p id=\"so_21809838_21818503_6\">end-of-file occurs on the input sequence;</p></li>\n<li><p id=\"so_21809838_21818503_7\"><strong><code>isspace(c, is.getloc())</code> is true for the next available input\n  character <code>c</code>.</strong></p></li>\n</ul>\n</blockquote>\n<p>When the stream determines a failed extraction the <code>std::ios_base::failbit</code> is set in the stream state indicating an error.</p>\n<p>From this point on any and all attempts at I/O will fail unless the stream state is cleared. The extractor becomes inoperable and it will not run given a stream state not cleared of all its errors. This means that the extraction into <code>last</code> doesn't do anything and it retains the value it had at the previous extraction (the one without <code>std::noskipws</code>) because the stream <strong>did not</strong> clear the string.</p>\n<hr>\n<p>As for the reason why using <code>char</code> works: Characters have no formatting requirements in C or C++. Any and all characters can be extracted into a object of type <code>char</code>, which is the reason why you're seeing the correct output despite <code>std::noskipws</code> being set:</p>\n<blockquote>\n<p id=\"so_21809838_21818503_8\"><strong>27.7.2.2.3/1 [istream::extractors]</strong></p>\n<pre><code>template&lt;class charT, class traits&gt;\nbasic_istream&lt;charT, traits&gt;&amp; operator&gt;&gt;(basic_istream&lt;charT, traits&gt;&amp; in,\n                                         charT&amp; c);\n</code></pre>\n<p id=\"so_21809838_21818503_9\">Effects: Behaves like a formatted input member (as described in 27.7.2.2.1) of in. After a sentry object is constructed a character is extracted from <code>in</code>, if one is available, and stored in <code>c</code>. Otherwise, the function calls <code>in.setstate(failbit)</code>.</p>\n</blockquote>\n<p>The semantics for the extractor will store a character into its operand <strong>if one is available</strong>. It doesn't delimit upon whitespace (or even the EOF character!). It will extract it just like a normal character.</p>\n</hr>", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2014-02-25T15:31:34.640", "Id": "21818503", "Score": "4", "CreationDate": "2014-02-16T23:54:49.280", "LastActivityDate": "2014-02-25T15:31:34.640"}, "21809916": {"ParentId": "21809838", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The basic algorithm for <code>&gt;&gt;</code> of a string is:</p>\n<blockquote>\n<p id=\"so_21809838_21809916_0\">1) skip whitespace<br>\n  2) read and extract until next whitespace  </br></p>\n</blockquote>\n<p>If you use <code>noskipws</code>, then the <code>first step is skipped</code>. </p>\n<p>After the first read, you are positionned on a whitespace, so the next (and all following) reads will stop immediatly, extracting nothing.<br>\nFor more information you can see <a href=\"https://stackoverflow.com/questions/7253864/skipws-flag-set-when-opening-an-input-file-stream-in-binary-mode\">this</a>.</br></p>\n<p>Form <a href=\"http://www.cplusplus.com/reference/iostream/manipulators/noskipws/\" rel=\"nofollow noreferrer\">cplusplus.com</a> ,  </p>\n<blockquote>\n<p id=\"so_21809838_21809916_1\">many extraction operations consider the whitespaces themselves as the terminating character, therfore, with the skipws flag disabled, some extraction operations may extract no characters at all from the stream.<br>\n  So , remove the noskipws , when using with strings .</br></p>\n</blockquote>\n", "OwnerUserId": "1731863", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:20.733", "Id": "21809916", "Score": "1", "CreationDate": "2014-02-16T10:23:34.490", "LastActivityDate": "2014-02-16T10:39:47.843"}, "21809838": {"CommentCount": "0", "ViewCount": "1948", "CreationDate": "2014-02-16T10:13:52.543", "LastActivityDate": "2014-02-25T15:31:34.640", "Title": "Demonstration of noskipws in C++", "FavoriteCount": "0", "PostTypeId": "1", "Id": "21809838", "Score": "0", "Body": "<p>I was trying out the noskipws manipulator in C++ and I wrote following code. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n{\n    string first, middle, last;\n\n    istringstream(\"G B Shaw\") &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\n    cout &lt;&lt; \"Default behavior: First Name = \" &lt;&lt; first &lt;&lt; \", Middle Name = \" &lt;&lt; middle &lt;&lt; \", Last Name = \" &lt;&lt; last &lt;&lt; '\\n';\n    istringstream(\"G B Shaw\") &gt;&gt; noskipws &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\n    cout &lt;&lt; \"noskipws behavior: First Name = \" &lt;&lt; first &lt;&lt; \", Middle Name = \" &lt;&lt; middle &lt;&lt; \", Last Name = \" &lt;&lt; last &lt;&lt; '\\n';\n}\n</code></pre>\n<p>I expect the following output:</p>\n<p><strong>Expected Output</strong></p>\n<pre><code>Default behavior: First Name = G, Middle Name = B, Last Name = Shaw\nnoskipws behavior: First Name = G, Middle Name = , Last Name = B\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>Default behavior: First Name = G, Middle Name = B, Last Name = Shaw\nnoskipws behavior: First Name = G, Middle Name = , Last Name = Shaw\n</code></pre>\n<p>I modified this code to make it work for chars like this and it works perfectly fine.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main()\n{\n    char first, middle, last;\n\n    istringstream(\"G B S\") &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\n    cout &lt;&lt; \"Default behavior: First Name = \" &lt;&lt; first &lt;&lt; \", Middle Name = \" &lt;&lt; middle &lt;&lt; \", Last Name = \" &lt;&lt; last &lt;&lt; '\\n';\n    istringstream(\"G B S\") &gt;&gt; noskipws &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\n    cout &lt;&lt; \"noskipws behavior: First Name = \" &lt;&lt; first &lt;&lt; \", Middle Name = \" &lt;&lt; middle &lt;&lt; \", Last Name = \" &lt;&lt; last &lt;&lt; '\\n';\n}\n</code></pre>\n<p>I know how cin works and I wasn't able to figure out why it works this way in case of <code>string</code>.</p>\n", "Tags": "<c++><manipulators>", "OwnerUserId": "1322382", "AnswerCount": "3"}, "21810094": {"ParentId": "21809838", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason is that in the second example you are not reading into last variable at all and instead you are printing old value of it.</p>\n<pre><code>std::string first, middle, last;\nstd::istringstream iss(\"G B S\");\n                           ^^^\niss &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\nstd::cout &lt;&lt; \"Default behavior: First Name = \" &lt;&lt; first \n            &lt;&lt; \", Middle Name = \" &lt;&lt; middle &lt;&lt; \", Last Name = \" &lt;&lt; last &lt;&lt; '\\n';\nstd::istringstream iss2(\"G B T\");\n                            ^^^\niss2 &gt;&gt; std::noskipws &gt;&gt; first &gt;&gt; middle &gt;&gt; last;\nstd::cout &lt;&lt; \"noskipws behavior: First Name = \" &lt;&lt; first \n            &lt;&lt; \", Middle Name = \" &lt;&lt; middle &lt;&lt; \", Last Name = \" &lt;&lt; last &lt;&lt; '\\n';\n</code></pre>\n<p>Default behavior: First Name = G, Middle Name = B, Last Name = S</p>\n<p>noskipws behavior: First Name = G, Middle Name = , Last Name = S</p>\n<p>This happen because after second read to variable last stream is positioned on whitespace.</p>\n", "OwnerUserId": "1141471", "LastEditorUserId": "1141471", "LastEditDate": "2014-02-16T10:59:48.260", "Id": "21810094", "Score": "0", "CreationDate": "2014-02-16T10:43:58.857", "LastActivityDate": "2014-02-16T10:59:48.260"}, "bq_ids": {"n4140": {"so_21809838_21818503_9": {"section_id": 2203, "quality": 0.8571428571428571, "length": 18}, "so_21809838_21818503_6": {"section_id": 1855, "quality": 1.0, "length": 4}, "so_21809838_21818503_4": {"section_id": 1855, "quality": 1.0, "length": 6}, "so_21809838_21818503_7": {"section_id": 1855, "quality": 0.7142857142857143, "length": 5}, "so_21809838_21818503_2": {"section_id": 1855, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_21809838_21818503_9": {"section_id": 2191, "quality": 0.8571428571428571, "length": 18}, "so_21809838_21818503_6": {"section_id": 1849, "quality": 1.0, "length": 4}, "so_21809838_21818503_4": {"section_id": 1849, "quality": 1.0, "length": 6}, "so_21809838_21818503_7": {"section_id": 1849, "quality": 0.7142857142857143, "length": 5}, "so_21809838_21818503_2": {"section_id": 1849, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_21809838_21818503_6": {"section_id": 2028, "quality": 1.0, "length": 4}, "so_21809838_21818503_4": {"section_id": 2028, "quality": 1.0, "length": 6}, "so_21809838_21818503_9": {"section_id": 2476, "quality": 0.8571428571428571, "length": 18}, "so_21809838_21818503_7": {"section_id": 2028, "quality": 1.0, "length": 7}, "so_21809838_21818503_2": {"section_id": 2028, "quality": 0.9130434782608695, "length": 21}}}});