post_cb({"44019436": {"Id": "44019436", "PostTypeId": "2", "Body": "<p><code>to_upper_iterator::pointer</code> should be a type that can point to the <code>value_type</code> and to mark that you can't modify the value you should make it const, i.e. <code>const CharT*</code></p>\n", "LastEditorUserId": "3668462", "LastActivityDate": "2017-05-17T09:23:22.870", "Score": "2", "CreationDate": "2017-05-17T08:27:05.163", "ParentId": "44019135", "CommentCount": "3", "OwnerUserId": "3668462", "LastEditDate": "2017-05-17T09:23:22.870"}, "44061435": {"Id": "44061435", "PostTypeId": "2", "Body": "<p>Adding my own answer, but assuming SO doesn't force me, won't mark it as the answer. It seems as though the relevant phrasing is in \u00a7 27.4.1</p>\n<blockquote>\n<p id=\"so_44019135_44061435_0\"><strong>27.4.1 Iterator traits [iterator.traits]</strong></p>\n<p id=\"so_44019135_44061435_1\">To implement algorithms only in terms of iterators, it is often necessary to determine the value and difference\n  types that correspond to a particular iterator type. Accordingly, it is required that if <code>Iterator</code> is the type of\n  an iterator, the types</p>\n<pre><code>iterator_traits&lt;Iterator&gt;::difference_type\niterator_traits&lt;Iterator&gt;::value_type\niterator_traits&lt;Iterator&gt;::iterator_category\n</code></pre>\n<p id=\"so_44019135_44061435_2\">be defined as the iterator\u2019s difference type, value type and iterator category, respectively. In addition, the\n  types</p>\n<pre><code>iterator_traits&lt;Iterator&gt;::reference\niterator_traits&lt;Iterator&gt;::pointer\n</code></pre>\n<p id=\"so_44019135_44061435_3\">shall be defined as the iterator\u2019s reference and pointer types, that is, for an iterator object <code>a</code>, the same type\n  as the type of <code>*a</code> and <code>a-&gt;</code>, respectively. In the case of an output iterator, the types</p>\n<pre><code>iterator_traits&lt;Iterator&gt;::difference_type\niterator_traits&lt;Iterator&gt;::value_type\niterator_traits&lt;Iterator&gt;::reference\niterator_traits&lt;Iterator&gt;::pointer\n</code></pre>\n<p id=\"so_44019135_44061435_4\">may be defined as <code>void</code>.</p>\n</blockquote>\n<p>In my case, <code>operator-&gt;</code> doesn't make sense since I'm just returning character types, so I can probably get away with <code>void</code> as @Richard Hodges suggested. I suppose the \"correct\" answer in the general case is to define some <code>pointer_proxy&lt;T&gt;</code> type (assuming such a thing doesn't already exist in the STL) that holds a <code>T</code> and defines an <code>operator-&gt;</code> that returns <code>T*</code> and use that for the iterator's <code>pointer</code> type</p>\n", "LastEditorUserId": "692061", "LastActivityDate": "2017-05-19T04:32:20.247", "Score": "0", "CreationDate": "2017-05-19T04:23:41.000", "ParentId": "44019135", "CommentCount": "0", "OwnerUserId": "692061", "LastEditDate": "2017-05-19T04:32:20.247"}, "44019135": {"ViewCount": "127", "Body": "<p>For example, consider some hypothetical <code>to_upper_iterator</code> that iterates over a range of characters, returning <code>std::toupper</code> for <code>operator*</code>. These iterator aliases make sense to me:</p>\n<pre><code>template &lt;typename CharT&gt;\nstruct to_upper_iterator\n{\n    using value_type = CharT;\n    using reference = CharT;\n    using difference_type = std::ptrdiff_t;\n    using iterator_category = std::random_access_iterator_tag;\n};\n</code></pre>\n<p>What <em>doesn't</em> make sense is what should/could be used for the <code>pointer</code> alias. I tried leaving it off, but sure enough I got compilation errors. It seems as though this is due to an addition in C++17. Summarized by <a href=\"http://en.cppreference.com/w/cpp/iterator/iterator_traits\" rel=\"nofollow noreferrer\">en.cppreference.com</a> for the <code>std::iterator_traits</code> type:</p>\n<blockquote>\n<p id=\"so_44019135_44019135_0\">If <code>Iterator</code> does not have the five member types <code>difference_type</code>, <code>value_type</code>, <code>pointer</code>, <code>reference</code>, and <code>iterator_category</code>, then this template has no members by any of those names (<code>std::iterator_traits</code> is SFINAE-friendly)</p>\n</blockquote>\n<p>So the question is: for types like this, should I just define <code>pointer</code> to <em>something</em> - my leading favorite being <code>void</code> or <code>void*</code> - or would it make more sense to do something like specialize <code>std::iterator_traits&lt;to_upper_iterator&gt;</code> so that it doesn't contain an alias for <code>pointer</code>.</p>\n", "AcceptedAnswerId": "44019327", "Title": "What to use for `Iterator::pointer` when nothing makes sense?", "CreationDate": "2017-05-17T08:13:08.733", "Id": "44019135", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-05-19T04:32:20.247", "Score": "4", "OwnerUserId": "692061", "Tags": "<c++>", "AnswerCount": "3"}, "44019327": {"Id": "44019327", "PostTypeId": "2", "Body": "<p>The standard c++ models of <code>OutputIterator</code> define all to be <code>void</code>.</p>\n<p>example: <a href=\"http://en.cppreference.com/w/cpp/iterator/back_insert_iterator\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/iterator/back_insert_iterator</a></p>\n<p>I would be inclined to do the same for those type that have no meaning in the context of your iterator type.</p>\n<p>This iterator of yours looks like it's modelling the concept of an adapter. In which case I might be inclined to start along these lines:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;string&gt;\n#include &lt;iterator&gt;\n#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename BaseIter&gt;\nstruct to_upper_iterator\n{\n    using value_type = typename std::iterator_traits&lt;BaseIter&gt;::value_type;\n    using reference = std::add_lvalue_reference_t&lt;std::add_const_t&lt;value_type&gt;&gt;;\n    using pointer = std::add_pointer_t&lt;std::add_const_t&lt;value_type&gt;&gt;;\n    using difference_type = typename std::iterator_traits&lt;BaseIter&gt;::difference_type;\n    using iterator_category = typename std::iterator_traits&lt;BaseIter&gt;::iterator_category;\n\n    to_upper_iterator(BaseIter iter = BaseIter()) : iter_(iter) {}\n\n    value_type operator*() const { return std::toupper(*underlying()); }\n    to_upper_iterator&amp; operator++()\n    {\n        iter_++;\n        return *this;\n    }\n\n    to_upper_iterator operator++(int)\n    {\n        auto copy = *this;\n        iter_++;\n        return copy;\n    }\n\n    bool operator!=(const to_upper_iterator&amp; other) const {\n        return iter_ != other.iter_;\n    }\n\n    // etc. use enable_if to enable functionality depending on iterator_category\n\nprivate:\n    BaseIter&amp; underlying() { return iter_; }\n    BaseIter const&amp; underlying() const { return iter_; }\n\n    BaseIter iter_;\n};\n\ntemplate&lt;class Iter&gt;\nauto make_upper_iterator(Iter iter)\n{\n    return to_upper_iterator&lt;Iter&gt;(iter);\n}\n\nint main()\n{\n    std::string a = \"abcdef\";\n\n    auto first = make_upper_iterator(a.begin());\n    auto last = make_upper_iterator(a.end());\n\n    std::copy(first, last, std::ostream_iterator&lt;char&gt;(std::cout));\n    std::cout &lt;&lt; std::endl;\n\n    const char b[] = \"abcdef\";\n    std::copy(make_upper_iterator(std::begin(b)),\n        make_upper_iterator(std::end(b) - 1),\n        std::ostream_iterator&lt;char&gt;(std::cout));\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2017-05-17T08:57:15.787", "Score": "4", "CreationDate": "2017-05-17T08:22:13.407", "ParentId": "44019135", "CommentCount": "2", "OwnerUserId": "2015579", "LastEditDate": "2017-05-17T08:57:15.787"}, "bq_ids": {"n4140": {"so_44019135_44061435_2": {"length": 11, "quality": 1.0, "section_id": 5583}, "so_44019135_44061435_1": {"length": 20, "quality": 1.0, "section_id": 5583}, "so_44019135_44061435_3": {"length": 15, "quality": 1.0, "section_id": 5583}}, "n3337": {"so_44019135_44061435_2": {"length": 11, "quality": 1.0, "section_id": 5365}, "so_44019135_44061435_3": {"length": 15, "quality": 1.0, "section_id": 5365}, "so_44019135_44061435_1": {"length": 20, "quality": 1.0, "section_id": 5365}}, "n4659": {"so_44019135_44061435_2": {"length": 11, "quality": 1.0, "section_id": 7030}, "so_44019135_44061435_3": {"length": 15, "quality": 1.0, "section_id": 7030}, "so_44019135_44061435_1": {"length": 20, "quality": 1.0, "section_id": 7030}, "so_44019135_44019135_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 7031}}}});