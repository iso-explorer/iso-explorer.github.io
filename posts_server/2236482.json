post_cb({"2239011": {"ParentId": "2236482", "CommentCount": "1", "Body": "<p>Is there a reason that you need <code>std::map</code> to not remove a <em>key, value</em> pair?</p>\n<p>This sounds like an attempt at premature optimization.</p>\n<p>A method is to replace the <em>value</em> part with a dummy or place holder value.  The problem in the long run is that the dummy value can be extracted from the <code>std::map</code> as long as the key exists.  You will need to add a check for dummy value every time the <code>std::map</code> is accessed.</p>\n<p>Because you want to maintain a key without a value, you most likely will have to write your own container.  You will especially have to design code to handle the case when the client accesses the key when it has no value.</p>\n<p>Looks like there is no performance gain for using standard containers and a key without value pair.  However, there <em>may</em> be a gain as far as memory is concerned.  Your issue would reduce fragmentation of dynamic memory; thus not having to re-allocate memory for the same key.  You'll have to decide the trade-off.</p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "2239011", "Score": "0", "CreationDate": "2010-02-10T17:36:20.553", "LastActivityDate": "2010-02-10T17:36:20.553"}, "2236560": {"ParentId": "2236482", "CommentCount": "1", "Body": "<p>I'm not certain what you exactly want from your ID. As it happens, each object already <em>has</em> a unique ID: its address! There are no two distinct objects with the same address, and the address of an object doesn't change over its lifetime.</p>\n<p><code>std::set&lt;T&gt;</code> typically stores its T values as members of larger nodes, not independent objects. Still, the T subobjects are never moved, and thus their addresses too are stable, unique identifiers.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "2236560", "Score": "1", "CreationDate": "2010-02-10T11:56:04.150", "LastActivityDate": "2010-02-10T11:56:04.150"}, "2236575": {"ParentId": "2236482", "CommentCount": "1", "Body": "<p>Create <code>std::set&lt;key_type&gt; removed_keys;</code> of the removed keys. If <code>removed_keys</code> is not empty then use key from <code>removed_keys</code> else create a new key.</p>\n", "OwnerUserId": "124161", "PostTypeId": "2", "Id": "2236575", "Score": "1", "CreationDate": "2010-02-10T11:57:56.770", "LastActivityDate": "2010-02-10T11:57:56.770"}, "2236482": {"CommentCount": "7", "ViewCount": "2420", "CreationDate": "2010-02-10T11:44:19.637", "LastActivityDate": "2010-02-10T17:36:20.553", "Title": "Data structure that maps unique id to an object", "PostTypeId": "1", "Id": "2236482", "Score": "2", "Body": "<p>I'm looking for a C++ data structure that will let me associate objects with a unique numeric value (a key), and that will re-use these keys after the corresponding object have been removed from the container. So it's basically somewhat of a hybrid map/queue structure. My current implementation is a</p>\n<pre><code>std::map&lt;size_t, TObject&gt;\n</code></pre>\n<p>and I insert objects like this:</p>\n<pre><code> size_t key = (m_Container.end()--)-&gt;first + 1;\n m_Container[key] = some_object;\n</code></pre>\n<p>which works fine for my purposes (I will never allocate more than size_t objects); yet still I keep wondering is there is a more specialized container available, preferably already in the stl or boost, or that there is a way to use another container to achieve this goal.</p>\n<p>(Of course I could, rather than taking the highest key in my map and adding one, every time go through the map and search for the first available key but that would reduce complexity from O(1) to O(n) Also it would be nice if the API was a simple</p>\n<pre><code>size_t new_key = m_Container.insert(object);\n</code></pre>\n<p>).</p>\n<p>Any ideas?</p>\n", "Tags": "<c++><data-structures><stl>", "OwnerUserId": "11449", "AnswerCount": "5"}, "2236557": {"ParentId": "2236482", "CommentCount": "5", "Body": "<p>If you're never going to allocate more than <code>size_t</code> keys then I recommend you simply use a static  counter:</p>\n<pre><code>size_t assign_id()\n{\n    static size_t next_id;\n    return next_id++;\n}\n</code></pre>\n<p>And if you want a nice API:</p>\n<pre><code>template&lt;class Container&gt;\nsize_t insert(Container &amp; container, TObject const &amp; obj)\n{\n     container.insert(obj);\n     return assign_id();\n}\n\nstd::set&lt;TObject&gt; m_Container;\nsize_t new_key = insert(m_Container, object);\n</code></pre>\n", "OwnerUserId": "244576", "PostTypeId": "2", "Id": "2236557", "Score": "1", "CreationDate": "2010-02-10T11:55:48.783", "LastActivityDate": "2010-02-10T11:55:48.783"}, "bq_ids": {"n4140": {"so_2236482_2237654_0": {"section_id": 6009, "quality": 0.6, "length": 6}}, "n3337": {"so_2236482_2237654_0": {"section_id": 5777, "quality": 0.6, "length": 6}}, "n4659": {"so_2236482_2237654_0": {"section_id": 7508, "quality": 0.6, "length": 6}}}, "2237654": {"ParentId": "2236482", "PostTypeId": "2", "CommentCount": "1", "Body": "<h3>Why not just use a vector?</h3>\n<pre><code>std::vector&lt;TObject&gt; m_Container;\n\nsize_t key = m_Container.size();\nm_Container.push_back(some_object);\n</code></pre>\n<p>Of course this could be completely useless if you have other usage characteristics. But since you only describe insert and the need for a key (so extracting) it is hard to give any other clear answer. But from these two requirements a std::vector&lt;&gt; should work just fine.</p>\n<p>If you have some other usage characteristics like: (Elements can be removed), (we insert elements in large blocks), (we insert elements infrequently) etc these would be interesting factoids that may change the recommendations people give.</p>\n<p>You mention that you want to search for un-used elements ID's. This suggests that you may be deleting elements but I don't see any explicit requirements or usage where elements are ebing deleted.</p>\n<h3>Looking at your code above:</h3>\n<pre><code>size_t key = (m_Container.end()--)-&gt;first + 1;\n</code></pre>\n<p>This is not doing what you think it is doing.<br>\nIt is equivalent too:</br></p>\n<pre><code>size_t key = m_Container.end()-&gt;first + 1;\nm_Container.end()--;\n</code></pre>\n<p>The <strong>post</strong> decrement operator modifies an lvalue. But the result of the expression is the original value. Thus you are applying the operator -&gt; to the value returned by end(). This is (probably) undefined behavior.</p>\n<p>See the standard:  </p>\n<blockquote>\n<p id=\"so_2236482_2237654_0\">Section:5.2.6 Increment and decrement<br>\n  The value of a postfix ++ expression is the value of its operand.</br></p>\n</blockquote>\n<pre><code>m_Container.end()--  // This sub-expresiion returns m_Container.end()\n</code></pre>\n<h3>Alternative:</h3>\n<pre><code>#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nclass X\n{\n    public:\n        T const&amp; operator[](std::size_t index) const    {return const_cast&lt;X&amp;&gt;(*this)[index];}\n        T&amp;       operator[](std::size_t index)          {return data[index];}\n        void        remove(std::size_t index)           {unused.push_back(index);}\n\n        std::size_t insert(T const&amp; value);\n    private:\n        std::vector&lt;T&gt;                  data;\n        std::vector&lt;std::size_t&gt;        unused;\n};\n\ntemplate&lt;typename T&gt;\nstd::size_t X&lt;T&gt;::insert(T const&amp; value)\n{\n    if (unused.empty())\n    {\n        data.push_back(value);\n        return data.size() - 1;\n    }\n    std::size_t result  = unused.back();\n    unused.pop_back();\n    data[result]    = value;\n    return result;\n}\n</code></pre>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2010-02-10T15:23:08.357", "Id": "2237654", "Score": "0", "CreationDate": "2010-02-10T14:55:49.833", "LastActivityDate": "2010-02-10T15:23:08.357"}});