post_cb({"3619022": {"Id": "3619022", "PostTypeId": "2", "Body": "<p>If you want a small memory foot print and want to store a number than signed and unsigned char are usefull.</p>\n<p>unsigned char is needed if you want to use a value between 128-255</p>\n<pre><code>unsigned char score = 232;\n</code></pre>\n<p>signed char is usfull if you want to store the difference between two characters.</p>\n<pre><code>signed char diff = 'D' - 'A';\n</code></pre>\n<p>char is distinct from the other two because you can not assume it is either.</p>\n", "LastActivityDate": "2010-09-01T14:18:25.437", "CommentCount": "0", "CreationDate": "2010-09-01T14:18:25.437", "ParentId": "3618419", "Score": "1", "OwnerUserId": "14065"}, "3618551": {"Id": "3618551", "PostTypeId": "2", "Body": "<p>Think of the ASCII character set.</p>\n<p>Historically, all characters used for text in computing were defined by the ASCII character set. Each character was represented by an 8 bit byte, which was unsigned, hence each character had a value in the range of 0 - 255.</p>\n<p>The word character was reduced to char for coding. </p>\n<p>An 8 bit char used the same memory as an 8 bit byte and as such they were interchangeable as far as a compiler was concerned.</p>\n<p>The compiler directive unsigned (all numbers were signed by default as twos compliment is used to represent negative numbers in binary) when applied to a byte or a char forced them to have a value in the range 0-255.</p>\n<p>If unsigned then then had a value of -128 - +127.</p>\n<p>Nowadays with the advent of UNICODE and multiple byte character sets this relationship between byte and char no longer exists.</p>\n", "LastActivityDate": "2010-09-01T13:29:33.200", "CommentCount": "2", "CreationDate": "2010-09-01T13:29:33.200", "ParentId": "3618419", "Score": "-1", "OwnerUserId": "102238"}, "3618419": {"ViewCount": "202", "Body": "<p>C++ Standard \u00a73.9.1 Fundamental types</p>\n<blockquote>\n<p id=\"so_3618419_3618419_0\">Objects declared as characters (char)\n  shall be large enough to store any\n  member of the implementation\u2019s basic\n  character set. If a character from\n  this set is stored in a character\n  object, the integral value of that\n  character object is equal to the value\n  of the single character literal form\n  of that character. It is\n  implementation-defined whether a char\n  object can hold negative values.\n  Characters can be explicitly declared\n  unsigned or signed. Plain char, signed\n  char, and unsigned char are three\n  distinct types.&lt;...&gt;</p>\n</blockquote>\n<p>I could not make sense of unsigned char.</p>\n<p><strong>A number may be +1 or -1.</strong></p>\n<p><strong>I can not think -A and +A in similar manner.</strong></p>\n<p><strong>What is the Historical reason of introducing unsigned char.</strong></p>\n", "Title": "3.9.1 Fundamental types", "CreationDate": "2010-09-01T13:17:10.907", "LastActivityDate": "2010-09-01T14:18:25.437", "CommentCount": "0", "LastEditDate": "2010-09-01T13:20:33.703", "PostTypeId": "1", "LastEditorUserId": "123111", "Id": "3618419", "Score": "0", "OwnerUserId": "434946", "Tags": "<c++>", "AnswerCount": "8"}, "3618497": {"Id": "3618497", "PostTypeId": "2", "Body": "<p>You can use the the overflow from 255 to 0? (I don't know. Just a guess)</p>\n<p>Maybe it is not only about characters but also about numbers between -128 and 127, and 0 to 255.</p>\n", "LastActivityDate": "2010-09-01T13:24:27.563", "CommentCount": "0", "CreationDate": "2010-09-01T13:24:27.563", "ParentId": "3618419", "Score": "0", "OwnerUserId": "14114"}, "3618552": {"Id": "3618552", "PostTypeId": "2", "Body": "<p>I am not sure, but my guess is that signed character was useful to distinguis between \"regular\" ASCII (which only takes 7 bits) and the \"other\" characters. if <code>(ch &gt; 0)</code> was true, you knew that you were dealing with one of the familiar characters, printed the same way on all terminals. When <code>(ch &lt; 0)</code>, it was an \"OEM code page\" or some such, which means that the actual character printed depended on the specific terminal's encoding. It could produce table-drawing lines, Cyrillic letters or Scandinavian accents.</p>\n", "LastActivityDate": "2010-09-01T13:29:53.507", "CommentCount": "2", "CreationDate": "2010-09-01T13:29:53.507", "ParentId": "3618419", "Score": "-1", "OwnerUserId": "3458"}, "3618505": {"Id": "3618505", "PostTypeId": "2", "Body": "<p>A <code>char</code> is actually an integral type. It is just that the type is also used to represent a character too. Since it is an integral type, it is valid to talk about signedness.</p>\n<p>(I don't know exactly about the historical reason. Probably to save a keyword for <code>byte</code> by conflating it with <code>char</code>.)</p>\n", "LastActivityDate": "2010-09-01T13:24:56.453", "CommentCount": "3", "CreationDate": "2010-09-01T13:24:56.453", "ParentId": "3618419", "Score": "2", "OwnerUserId": "224671"}, "bq_ids": {"n4140": {"so_3618419_3618419_0": {"length": 50, "quality": 0.9803921568627451, "section_id": 7210}}, "n3337": {"so_3618419_3618419_0": {"length": 50, "quality": 0.9803921568627451, "section_id": 6954}}, "n4659": {"so_3618419_3618419_0": {"length": 50, "quality": 0.9803921568627451, "section_id": 8719}}}, "3618601": {"Id": "3618601", "PostTypeId": "2", "Body": "<p>In C (and thus C++), <strong><code>char</code> does not mean character</strong>.  It means a byte (<code>int_least8_t</code>).  This is a historical legacy from the pre-Unicode days when a characters could actually fit in a <code>char</code>, but is now a flaw in the language.</p>\n<p>Since <code>char</code> is really a small integer, having <code>signed char</code> and <code>unsigned char</code> makes sense.  There are actually three distinct <code>char</code> types: <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>.  A common convention is that <code>unsigned char</code> represents bytes while plain <code>char</code> represents <s>characters</s> UTF-8 code units.</p>\n", "LastActivityDate": "2010-09-01T13:34:01.783", "CommentCount": "0", "CreationDate": "2010-09-01T13:34:01.783", "ParentId": "3618419", "Score": "2", "OwnerUserId": "287586"}, "3618609": {"Id": "3618609", "PostTypeId": "2", "Body": "<p>You're reading too much in to it. A character is a small integral type that can hold a character. End of story. Unsigned char was never introduced or intended, it's just how it is, because char is an integral type identical to int or long or short, it's just the size that's different. The fact is that there's little reason to use unsigned char, but people do if they want one-byte unsigned integral storage.</p>\n", "LastActivityDate": "2010-09-01T13:35:01.733", "CommentCount": "2", "CreationDate": "2010-09-01T13:35:01.733", "ParentId": "3618419", "Score": "1", "OwnerUserId": "298661"}, "3618490": {"Id": "3618490", "PostTypeId": "2", "Body": "<p>Computers do not \"understand\" the concept of alphabets or characters; they only work on numbers. So a bunch of people got together and agreed on what number maps to what letter. The most common one in use is ASCII (although the language does not guarantee that).</p>\n<p>In ASCII, the letter <strong>A</strong> has the code <strong>65</strong>. In environments using ASCII, the letter <strong>A</strong> would be represented by the number <strong>65</strong>.</p>\n<p>The <code>char</code> datatype also serves as an integral type - meaning that it can hold just numbers, so <code>unsigned</code> and <code>signed</code> was allowed. On most platforms I've seen, <code>char</code> is a single 8-bit byte.</p>\n", "LastActivityDate": "2010-09-01T13:24:02.107", "CommentCount": "2", "CreationDate": "2010-09-01T13:24:02.107", "ParentId": "3618419", "Score": "1", "OwnerUserId": "308661"}});