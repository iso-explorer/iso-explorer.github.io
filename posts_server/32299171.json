post_cb({"32299536": {"ParentId": "32299171", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>First of all inlining something ie requiring inline substitution of the function body at the point of call <strong>doesn't mean that the implementation is constrained to do so</strong> : </p>\n<blockquote>\n<p id=\"so_32299171_32299536_0\">7.1.2 Function specifiers</p>\n<p id=\"so_32299171_32299536_1\">2 A function declaration (8.3.5, 9.3, 11.3) with an inline specifier declares an inline function. The inline specifier indicates to the implementation that inline substitution of the function body at the point of call is to be preferred to the usual function call mechanism. <strong>An implementation is not required to perform this inline substitution at the point of call</strong>; however, even if this inline substitution is omitted, <strong>the other rules for inline functions defined by 7.1.2 shall still be respected.</strong></p>\n</blockquote>\n<p>This alone should give a taste that it's a fuzzy heuristic to rely on compiler optimizations (or that it matters doing so) regarding this topic. For example we know that the compiler has a hard time inlining function pointer calls but this is not of much importance. </p>\n<p>There are some examples of language constructs that the Standard mandates to be inlined and this not a matter of being a good compiler but a compliant one. </p>\n<h2>Function Call operators of closure types</h2>\n<blockquote>\n<p id=\"so_32299171_32299536_2\">5.1.2 </p>\n<p id=\"so_32299171_32299536_3\">5 The closure type for a non-generic lambda-expression has a public inline function call operator (...) For a generic lambda, the closure type has a public inline function call operator member template (...)</p>\n</blockquote>\n<h2>constexpr functions</h2>\n<blockquote>\n<p id=\"so_32299171_32299536_4\">7.1.5</p>\n<p id=\"so_32299171_32299536_5\">2 (...) constexpr functions and constexpr constructors are implicitly\n  inline (7.1.2).</p>\n</blockquote>\n<h2>Deleted functions</h2>\n<blockquote>\n<p id=\"so_32299171_32299536_6\">8.4.3 </p>\n<p id=\"so_32299171_32299536_7\">A deleted function is implicitly inline. [ Note: The one-definition rule (3.2) applies to deleted definitions.\n  \u2014 end note ] A deleted definition of a function shall be the first declaration of the function or, for an explicit\n  specialization of a function template, the first declaration of that specialization. </p>\n</blockquote>\n<p>Other examples are member functions defined inside the class definition and a function defined in a friend declaration of a class. Inlining is not the best choice in every case (can increase program size) so for performance critical section I'd suggest benchmarking and deciding yourself; after all <a href=\"https://isocpp.org/wiki/faq/inline-functions#inline-and-perf\" rel=\"nofollow\">Do inline functions improve performance?</a></p>\n", "OwnerUserId": "2567683", "LastEditorUserId": "2567683", "LastEditDate": "2015-08-30T18:03:16.760", "Id": "32299536", "Score": "3", "CreationDate": "2015-08-30T17:57:38.003", "LastActivityDate": "2015-08-30T18:03:16.760"}, "32299171": {"CommentCount": "8", "AcceptedAnswerId": "32299314", "PostTypeId": "1", "LastEditorUserId": "661519", "CreationDate": "2015-08-30T17:13:13.653", "LastActivityDate": "2015-08-30T18:03:16.760", "LastEditDate": "2015-08-30T17:18:30.867", "ViewCount": "516", "FavoriteCount": "2", "Title": "Is the GNU C++ compiler ((GCC) 5.2.0) good at \"inlining\" by itself?", "Id": "32299171", "Score": "2", "Body": "<p>I'm not asking why or when I should use <code>inline</code> in some code. </p>\n<p>I use <code>inline</code> where I think it's usual (like in get/set functions). I read on stack some unusual example where <code>inline</code> sounds necessary. I'm not sure that I'll recognize a such situation in my code... I mean, until I get an issue...</p>\n<p>So I wonder if for usual cases the compiler handles that as well as I do, maybe even better...</p>\n<p>The reason why I would like to avoid <code>inline</code>, is to avoid having to implement in the headers ... About that a question pop in my mind: </p>\n<p>is the compiler (I always consider the GCC compiler in my question) able to <code>inline</code> a function not implemented in the header ?</p>\n<p>n.b. : I don't know if there is some internal changes about <code>inline</code> in C++14.</p>\n", "Tags": "<c++><gcc><g++><c++14>", "OwnerUserId": "2430299", "AnswerCount": "3"}, "32299314": {"ParentId": "32299171", "CommentCount": "6", "Body": "<p>Without some kind of example code, it's VERY hard to say for sure what the compiler will do (even WITH code, it can be pretty darn difficult). </p>\n<p>Generally speaking, if the function is small, the compiler will inline functions that have their source code available during compilation (and others if you enable lto (link time optimisation). If you expect to be able to compile a function into an object file and get the function inlined, then you HAVE to use lto. </p>\n<p>A function that is large and static, called only once will also be inlined in most cases. </p>\n<p>The problem comes when you have several calls and the function is \"more than tiny in size\" - in other words more than 3-4 lines long. Then the compiler has to balance between inlining and bloating the code, and not inlining and the cost of calls. This is a very difficult balance to get right. Profile-driven optimisation can help a lot here, but in general, the compiler will MOSTLY get it right, but not at all guaranteed - if in doubt (and it's important), use a benchmark of your application, and measure whether it gets better with a force inline attribute.</p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "32299314", "Score": "1", "CreationDate": "2015-08-30T17:28:43.243", "LastActivityDate": "2015-08-30T17:28:43.243"}, "bq_ids": {"n4140": {"so_32299171_32299536_1": {"section_id": 5402, "quality": 0.8888888888888888, "length": 40}, "so_32299171_32299536_3": {"section_id": 5964, "quality": 0.9090909090909091, "length": 20}, "so_32299171_32299536_7": {"section_id": 3279, "quality": 0.8461538461538461, "length": 22}, "so_32299171_32299536_5": {"section_id": 5418, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_32299171_32299536_1": {"section_id": 5197, "quality": 0.8888888888888888, "length": 40}, "so_32299171_32299536_7": {"section_id": 3150, "quality": 0.8461538461538461, "length": 22}, "so_32299171_32299536_5": {"section_id": 5213, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_32299171_32299536_1": {"section_id": 6849, "quality": 0.8666666666666667, "length": 39}, "so_32299171_32299536_3": {"section_id": 7453, "quality": 0.9090909090909091, "length": 20}, "so_32299171_32299536_7": {"section_id": 4037, "quality": 0.8461538461538461, "length": 22}, "so_32299171_32299536_5": {"section_id": 6839, "quality": 0.5714285714285714, "length": 4}}}, "32299293": {"ParentId": "32299171", "CommentCount": "2", "Body": "<p>The compiler can inline a function used in the same file (technically, \"compilation unit\") but not when compiling different files, since it doesn't have the source.  That's why inline functions should be placed in the header file.</p>\n", "OwnerUserId": "1216776", "PostTypeId": "2", "Id": "32299293", "Score": "1", "CreationDate": "2015-08-30T17:26:39.943", "LastActivityDate": "2015-08-30T17:26:39.943"}});