post_cb({"26056589": {"Id": "26056589", "PostTypeId": "2", "Body": "<p>This is not an answer, but you might find it informative and fun.\nAdding 2 template functions to your class will effectively allow you to call any free function that takes an object of that class as the first parameter:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nstruct puppy {\n   puppy(std::string name)\n   : _name(std::move(name))\n   {}\n\n   const std::string&amp; name() const noexcept {\n      return _name;\n   }\n\n  void set_name(std::string name) {\n    _name = std::move(name);\n  }\n\n    template&lt;class F, class ...Args&gt;\n      auto perform(F&amp;&amp; f, Args&amp;&amp;...args) const \n      -&gt; decltype(f(*this, std::forward&lt;Args&gt;(args)...))\n    {\n      return f(*this, std::forward&lt;Args&gt;(args)...);\n    }\n\n    template&lt;class F, class ...Args&gt;\n      auto perform(F&amp;&amp; f, Args&amp;&amp;...args) \n      -&gt; decltype(f(*this, std::forward&lt;Args&gt;(args)...))\n    {\n      return f(*this, std::forward&lt;Args&gt;(args)...);\n    }\n\nprivate:\n   std::string _name;\n};\n\n\nvoid woof(const puppy&amp; p) {\n   std::cout &lt;&lt; \"puppy \" &lt;&lt; p.name() &lt;&lt; \" woofs!\" &lt;&lt; std::endl;   \n}\n\nvoid indented_woof(const puppy&amp;p, size_t indent) {\n    std::cout &lt;&lt; std::string(indent, ' ');\n    woof(p);\n}\n\nvoid complex_woof(const puppy&amp; p, int woofs)\n{\n    std::cout &lt;&lt; \"attention!\" &lt;&lt; std::endl;\n  for (int i = 0  ; i &lt; woofs ; ++i) {\n    p.perform(indented_woof, 4);\n  }\n}\n\nstd::string name_change(puppy&amp; p, std::string(new_name))\n{\n  auto old_name = p.name();\n  p.set_name(std::move(new_name));\n  return old_name;\n}\n\nint main()\n{\n  puppy fido { \"fido\" };\n\n  fido.perform(woof);\n  fido.perform(complex_woof, 10);\n  auto old_name = fido.perform(name_change, \"bonzo\");\n  fido.perform(woof);\n  std::cout &lt;&lt; \"changed name from \" &lt;&lt; old_name &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-09-26T09:43:39.440", "CommunityOwnedDate": "2014-09-26T09:43:39.440", "Score": "2", "CreationDate": "2014-09-26T09:43:39.440", "ParentId": "26055754", "CommentCount": "1", "OwnerUserId": "2015579"}, "26055852": {"Id": "26055852", "PostTypeId": "2", "Body": "<p><code>why should declare these? I know for common c method, there is no need to declare, instead of it just define it:</code></p>\n<p>There is no method in C, just attribute of an struct, wich can be function Pointeur, then associated to a function addresse.</p>\n<p>Furthermore you have to declare it in the class definition for the same reason you do it in C:</p>\n<p>The compilateur will transform this pre-declaration into a function pointeur then associate to the said methode int the construction of your object.</p>\n<p>If a definition of a C++ class should be transformed to a C struct the code would be like this:</p>\n<pre><code>struct Aclass {\n void (*Amethode))(int);\n}\nvoid Amethode(int) { return (0); }\nAclass primaryObject = {&amp;Amethode};\nAclass* AclassConstructor() {\n Aclass* object;\n object = malloc(sizeof(Aclass));\n memcpy(object, primaryObject, sizeof(Aclass));\n return (object);\n}\n</code></pre>\n", "LastEditorUserId": "3975382", "LastActivityDate": "2014-09-26T09:09:33.940", "Score": "1", "CreationDate": "2014-09-26T09:03:26.517", "ParentId": "26055754", "CommentCount": "7", "LastEditDate": "2014-09-26T09:09:33.940", "OwnerUserId": "3975382"}, "26055932": {"Id": "26055932", "PostTypeId": "2", "Body": "<p>You don't need to declare the method before you define it, but you need to declare class methods in the class. Else it wouldn't be a class method.</p>\n<p>That may seem like a contradiction, but a definition is also a declaration. So what this means is that the definition may appear in the class itself:</p>\n<pre><code>class A {\n  void testMethod() { /*...*/ } \n};\n</code></pre>\n<p>[edit]\nAlso, practically speaking, inside the class declaration there are <code>private</code>, <code>protected</code> and <code>public</code> parts. This is needed to for encapsulation. If you could declare methods outside the class, you would lose encapsulation. Anybody could access private members merely by defining extra getters and setters, even when those would not make sense. Class invariants would become meaningless.</p>\n", "LastEditorUserId": "15416", "LastActivityDate": "2014-09-26T10:34:19.620", "Score": "8", "CreationDate": "2014-09-26T09:08:13.090", "ParentId": "26055754", "CommentCount": "2", "LastEditDate": "2014-09-26T10:34:19.620", "OwnerUserId": "15416"}, "26056208": {"Id": "26056208", "PostTypeId": "2", "Body": "<p>Note the use of the qualifier <code>::</code>. It means</p>\n<ul>\n<li>on the left you have a namespace or class identifier</li>\n<li>on the right you have a namespace, class, or method / function identifier</li>\n</ul>\n<p>So writing <code>void A::testMethod()</code> assumes that there is a class or namespace <code>A</code> defined - this is how C++ is defined. And this applies to</p>\n<pre><code>void A::testMethod();\n</code></pre>\n<p>as well as to</p>\n<pre><code>void A::testMethod()\n{\n}\n</code></pre>\n<p>Also note the global namespace where you have indeed nothing at the left of <code>::</code> as in</p>\n<pre><code>void ::testMethod()\n{\n}\n</code></pre>\n<p>And by definition the global namespace is always defined so the above code defines a function similar to C-style without the qualifier.</p>\n", "LastActivityDate": "2014-09-26T09:23:26.887", "CommentCount": "0", "CreationDate": "2014-09-26T09:23:26.887", "ParentId": "26055754", "Score": "2", "OwnerUserId": "1916893"}, "bq_ids": {"n4140": {"so_26055754_26055790_0": {"length": 63, "quality": 0.9692307692307692, "section_id": 5881}}, "n3337": {"so_26055754_26055790_0": {"length": 63, "quality": 0.9692307692307692, "section_id": 5652}}, "n4659": {"so_26055754_26055790_0": {"length": 63, "quality": 0.9692307692307692, "section_id": 7364}}}, "26056725": {"Id": "26056725", "PostTypeId": "2", "Body": "<p>All of the previous answers are correct as far as they go, but\nthey fail to point out the reason behind the rule.  In C++,\na class definition is closed; you cannot add to it later.  This\nis necessary for non-static data members, since they determine\nthe size (and the implicitly generated special functions), but\nit is a basic principle in C++ for all class members: not just\ndata, but functions, types, etc.  It is considered essential for\ngood encapsulation.</p>\n<p>This is true for most (but not all) languages which support the\nconcept of class. </p>\n<p>This also explains why it the situation is different for\nnamespaces (which aren't closed).</p>\n", "LastActivityDate": "2014-09-26T09:50:24.647", "CommentCount": "1", "CreationDate": "2014-09-26T09:50:24.647", "ParentId": "26055754", "Score": "3", "OwnerUserId": "649665"}, "26055788": {"Id": "26055788", "PostTypeId": "2", "Body": "<p>It helps encapsulation. If you have a class A</p>\n<pre><code>class A {\npublic:\n  foo();\n  bar();\n}\n</code></pre>\n<p>You can be sure that only methods <code>foo</code> and <code>bar</code> mess with the private data members of the class. (Or pointer magic or undefined behavior of course)</p>\n", "LastActivityDate": "2014-09-26T09:00:02.973", "CommentCount": "8", "CreationDate": "2014-09-26T09:00:02.973", "ParentId": "26055754", "Score": "6", "OwnerUserId": "680982"}, "26056020": {"Id": "26056020", "PostTypeId": "2", "Body": "<p>\"Methods\" or \"member functions\" (as is the more common terminology in C++) are part of the class declaration. Since you must declare a C++ class in one single place, you must make sure that all \"member functions\" (or \"methods\") are already present in that declaration.</p>\n<blockquote>\n<p id=\"so_26055754_26056020_0\">I know for common C method methods it is not needed declare, but they\n  can just be defined</p>\n</blockquote>\n<p>When you refer a \"common C method\" in C++, you actually mean a \"common function\". Note that you can declare classes anywhere you can declare such functions.</p>\n<p>Also, note that you can declare a member function with a body. You do not have to separate declaration and definition. I.e. this is perfectly valid:</p>\n<pre><code>class A{\n   void privateMethod() {\n       // do something here...\n   }\npublic:\n   void publicMethod() {\n       // do something here...\n   }\n};\n</code></pre>\n", "LastEditorUserId": "2228771", "LastActivityDate": "2014-09-26T16:22:31.917", "Score": "2", "CreationDate": "2014-09-26T09:13:04.653", "ParentId": "26055754", "CommentCount": "0", "LastEditDate": "2014-09-26T16:22:31.917", "OwnerUserId": "2228771"}, "26055790": {"Id": "26055790", "PostTypeId": "2", "Body": "<p>There are several secondary reasons both objective and subjective (i.e. allows to specify visibility, serves as an interface for the class and probably several others related to compiling and linking phases and TU symbols visibility, not to mention a class is the basic encapsulation unit, with all that implies) but an unquestionable one is that <strong>the standard dictates it</strong>:</p>\n<p>N3797 - class.mfct/p2</p>\n<blockquote>\n<p id=\"so_26055754_26055790_0\"><strong>A member function may be defined (8.4) in its class definition, in\n  which case it is an inline member function (7.1.2), or it may be\n  defined outside of its class definition if it has already been\n  declared but not defined in its class definition.</strong> A member function\n  definition that appears outside of the class definition shall appear\n  in a namespace scope enclosing the class definition. Except for member\n  function definitions that appear outside of a class definition, and\n  except for explicit specializations of member functions of class\n  templates and member function templates (14.7) appearing outside of\n  the class definition, a member function shall not be redeclared.</p>\n</blockquote>\n<p>emphasis mine.</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2014-09-26T11:20:34.280", "Score": "7", "CreationDate": "2014-09-26T09:00:12.323", "ParentId": "26055754", "CommentCount": "1", "LastEditDate": "2014-09-26T11:20:34.280", "OwnerUserId": "1938163"}, "26056439": {"Id": "26056439", "PostTypeId": "2", "Body": "<p>Even if it were not mandated by the standard, there are the following two reasons why you need to declare all class methods in the class definition.</p>\n<ol>\n<li><p>You can only declare something as public, private or protected in the class declaration, you can't do so at the method definition in the .cpp file.  So what visibility would your free-standing class method have?</p></li>\n<li><p>If the standard decided to select one of the three as the default (C++ defaults to private), and place that visibility on your method, you now have a scoping problem.  Even the most restrictive visibility (private) means that you can use the method in any other member method, <em>including those defined before it in the source file</em>.  Without the declaration in the class definition, those earlier functions would not be aware of your free standing method, thus you violate the scoping rules.</p></li>\n</ol>\n<p>In your foo.h header:</p>\n<pre><code>class foo\n{\npublic:\n    foo() {}\n    virtual ~foo() {}\n\n    declaredMethod();\n};\n</code></pre>\n<p>In your foo.cpp</p>\n<pre><code>foo::declaredMethod()\n{\n    ...\n    freeStandingMethod();   // This should be legal, but it can't work since we\n                            //  haven't seen foo::freeStandingMethod() yet\n    ...\n}\n\nfoo::freeStandingMethod()\n{\n    ...\n}\n</code></pre>\n<p>Even if you could make this work in the same .cpp file, it's legal to place <code>foo::freeStandingMethod()</code> in a different .cpp file from <code>foo::declaredMethod()</code> at which point this becomes impossible.</p>\n", "LastActivityDate": "2014-09-26T09:35:38.713", "CommentCount": "0", "CreationDate": "2014-09-26T09:35:38.713", "ParentId": "26055754", "Score": "2", "OwnerUserId": "4022617"}, "26055754": {"ViewCount": "391", "Body": "<p>If only define this method it will have a compiler error.</p>\n<pre><code>void classA::testMethod() {    \n}\n</code></pre>\n<p>And so it must be declared first:</p>\n<pre><code>class classA {    \n   void testMethod();\n};\n</code></pre>\n<p>Why should these be declared?</p>\n<p>I know for common C method methods it is not needed declare, but they can just be defined:</p>\n<pre><code>void test() {\n}\n</code></pre>\n", "AcceptedAnswerId": "26055790", "Title": "Why must a method be declared in a C++ class definition?", "CreationDate": "2014-09-26T08:57:59.517", "Id": "26055754", "CommentCount": "9", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-09-26T09:15:14.050", "LastEditorUserId": "592323", "LastActivityDate": "2014-09-26T16:22:31.917", "Score": "6", "OwnerUserId": "1288446", "Tags": "<c++><declaration>", "AnswerCount": "9"}});