post_cb({"bq_ids": {"n4140": {"so_48103175_48103255_1": {"length": 45, "quality": 1.0, "section_id": 7104}}, "n3337": {"so_48103175_48103255_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 6848}}, "n4659": {"so_48103175_48103255_1": {"length": 45, "quality": 1.0, "section_id": 8605}}}, "48103175": {"ViewCount": "35", "Body": "<p>I have a couple of namespaces, each with a function template named <code>f</code>.</p>\n<pre><code>// f() and Widget\nnamespace A {\n  struct Widget { };\n\n  template &lt;typename T&gt;\n  void func(const T&amp;) { }\n}\n\n// f() and caller()\nnamespace B {\n  template &lt;typename T&gt;\n  void func(const T&amp;) { }\n\n  template &lt;typename T&gt;\n  void caller(const T&amp; t) {\n    func(t); // error occurs here\n  }\n}\n\ntemplate &lt;typename T&gt;\nclass Wrap { };\n\nint main() {\n  Wrap&lt;A::Widget&gt; w{};\n  B::caller(w); // triggers error\n}\n</code></pre>\n<p>The above produces the following error</p>\n<pre><code>error: call of overloaded \u2018func(const Wrap&lt;A::Widget&gt;&amp;)\u2019 is ambiguous\n     func(t);\n     ~~~~^~~\nnote: candidate: void B::func(const T&amp;) [with T = Wrap&lt;A::Widget&gt;]\n   void func(const T&amp;) { }\n        ^~~~\nnote: candidate: void A::func(const T&amp;) [with T = Wrap&lt;A::Widget&gt;]\n   void func(const T&amp;) { }\n        ^~~~\n</code></pre>\n<p>Why is <code>A::func</code> considered if <code>Wrap</code> is in the global namespace? Shouldn't <code>B::caller</code> call <code>B::func</code>?</p>\n", "Title": "Argument Dependent Look (ADL) considering template arguments?", "CreationDate": "2018-01-04T20:35:48.317", "LastActivityDate": "2018-01-05T19:59:16.697", "CommentCount": "0", "LastEditDate": "2018-01-05T18:10:00.757", "PostTypeId": "1", "LastEditorUserId": "1013719", "Id": "48103175", "Score": "1", "OwnerUserId": "1013719", "Tags": "<c++><templates><argument-dependent-lookup>", "AnswerCount": "1"}, "48103255": {"Id": "48103255", "PostTypeId": "2", "Body": "<p>ADL doesn't just considered the arguments to the function in the case of a template. Here you have <code>Wrap&lt;A::Widget&gt;</code> as the argument to <code>B::caller</code>. Because <code>caller</code> is in <code>namespace B</code>, <code>B::func</code> is obviously considered. The reason for <code>A::func</code> being considered comes from the below (emphasis added)</p>\n<blockquote>\n<p id=\"so_48103175_48103255_0\">N659 6.4.2/(2.2) [basic.lookup.argdep]</p>\n<p id=\"so_48103175_48103255_1\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is\n  a member, if any; and its direct and indirect base classes. Its associated namespaces are the innermost\n  enclosing namespaces of its associated classes. <strong>Furthermore, if T is a class template specialization,\n  its associated namespaces and classes also include: the namespaces and classes associated with the\n  types of the template arguments provided for template type parameters</strong> [...]</p>\n</blockquote>\n<p>Because <code>A::Widget</code> is a template argument to <code>Wrap</code>, <code>A</code> is also an associated namespace of <code>Wrap&lt;A::Widget&gt;</code></p>\n<p>This example can be made to compile as expected by preventing ADL by using the qualified name:</p>\n<pre><code>template &lt;typename T&gt;    \nvoid caller(const T&amp; t) {    \n  B::func(t);      \n}\n</code></pre>\n<p>or by enclosing the function name in paretheses</p>\n<pre><code>template &lt;typename T&gt;    \nvoid caller(const T&amp; t) {    \n  (func)(t);      \n}\n</code></pre>\n", "LastEditorUserId": "1013719", "LastActivityDate": "2018-01-05T19:59:16.697", "Score": "1", "CreationDate": "2018-01-04T20:42:18.340", "ParentId": "48103175", "CommentCount": "0", "OwnerUserId": "1013719", "LastEditDate": "2018-01-05T19:59:16.697"}});