post_cb({"6039817": {"CommentCount": "6", "CreationDate": "2011-05-18T04:17:43.053", "CommunityOwnedDate": "2011-05-18T06:10:46.300", "LastEditorUserId": "293791", "LastActivityDate": "2011-05-18T17:38:36.240", "ParentId": "6028427", "PostTypeId": "2", "LastEditDate": "2011-05-18T17:38:36.240", "Id": "6039817", "Score": "2", "Body": "<p>Had I paid more attention to the very next clause (5.2.8/3), I would have seen this</p>\n<blockquote>\n<p id=\"so_6028427_6039817_0\">When typeid is applied to an\n  expression other than an lvalue of a\n  polymorphic class type, . . . The expression is\n  not evaluated.</p>\n</blockquote>\n<p>In other words, as with <code>sizeof</code> (among others in C++11), the compiler is not meant to actually run the code you pass to <code>typeid</code>, it is just supposed to analyze it for behavior.  Unfortunately, unlike <code>sizeof</code>, the result sometimes depends on the runtime behavior of the expression due to polymorphic types.</p>\n<pre><code>Base* p1 = new Derived;\nBase* p2 = new Base;\ntypeid(*p1); //equivalent to typeid(Derived) [assuming Base is polymorphic]\ntypeid(*p2); //equivalent to typeid(Base)\n</code></pre>\n<p>If the expression were completely unevaluated, the compiler could not check the RTTI to see that <code>p1</code> is actually pointing to a <code>Derived</code> instead of a <code>Base</code>.  The standard writers decided to go one step further, however, and stated that if the expression is ultimately a dereference of a pointer type, the compiler should only partially evaluate it.   If the pointer is null, throw <code>std::bad_typeid</code> rather than perform the dereference and introduce undefined behavior.</p>\n<p>Contrast that with <code>dynamic_cast</code>.  The expression passed to <code>dynamic_cast</code> is always fully evaluated, the result would make no sense otherwise.  Since the compiler is required to fully evaluate the expression anyhow, it makes no sense to instruct it to stop early and throw an exception.</p>\n<p>In short, this is given special treatment in much the same way that <code>sizeof(*(int*)0)</code> is given special treatment.  <code>*(int*)0</code> isn't meant to be evaluated, so there is no reason to introduce undefined behavior in the first place, even though it looks bad.</p>\n", "OwnerUserId": "293791"}, "bq_ids": {"n4140": {"so_6028427_6028427_0": {"section_id": 6021, "quality": 0.8095238095238095, "length": 34}, "so_6028427_6039817_0": {"section_id": 6022, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_6028427_6028427_0": {"section_id": 5789, "quality": 0.8095238095238095, "length": 34}, "so_6028427_6039817_0": {"section_id": 5790, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_6028427_6028427_0": {"section_id": 7520, "quality": 0.8095238095238095, "length": 34}, "so_6028427_6039817_0": {"section_id": 7521, "quality": 0.7692307692307693, "length": 10}}}, "6028427": {"CommentCount": "8", "ViewCount": "1182", "PostTypeId": "1", "LastEditorUserId": "293791", "CreationDate": "2011-05-17T08:52:36.507", "LastActivityDate": "2011-05-18T17:38:36.240", "Title": "dereferencing a null pointer within typeid", "LastEditDate": "2011-05-17T09:14:56.100", "Id": "6028427", "Score": "15", "Body": "<p>While researching a recent question, I came upon the following clause in the '03 standard[1]:</p>\n<blockquote>\n<p id=\"so_6028427_6028427_0\">When typeid is applied to an lvalue\n  expression whose type is a polymorphic\n  class type (10.3), the result refers\n  to a type_info object representing the\n  type of the most derived object (1.8)\n  (that is, the dynamic type) to which\n  the lvalue refers. If the lvalue\n  expression is obtained by applying the\n  unary * operator to a pointer and\n  the pointer is a null pointer value\n  (4.10), the typeid expression throws\n  the bad_typeid exception (18.5.3).</p>\n</blockquote>\n<p>Specifically, I am wondering about the last bit, which provides well defined behavior for the result of dereferencing a null pointer.  As far as I can tell, this is the only time this is done[2].  Specifically, <code>dynamic_cast&lt;T&amp;&gt;</code> has no special treatment for this case, and that seems like a much more useful scenario.  Doubly so considering <code>dynamic_cast&lt;T&amp;&gt;</code> is already defined as throwing an exception under certain circumstances.</p>\n<p>Is there a specific reason that this particular expression was given special treatment?  It seems completely arbitrary, so I am guessing there is some specific use case they had in mind.</p>\n<hr>\n<p>[1] A similar clause exists in '11, but it refers to glvalue expressions, rather than lvalue expressions.</p>\n<p>[2] <code>delete 0;</code> and <code>dynamic_cast&lt;T*&gt;(0)</code> come close, but in both cases you are dealing with a pointer value, rather than an actual object.</p>\n</hr>", "Tags": "<c++><typeid>", "OwnerUserId": "293791", "AnswerCount": "1"}});