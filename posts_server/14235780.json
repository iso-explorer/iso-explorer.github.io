post_cb({"bq_ids": {"n4140": {"so_14235780_14236302_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 7117}}, "n3337": {"so_14235780_14236302_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 6861}}, "n4659": {"so_14235780_14236302_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 8618}}}, "14235780": {"ViewCount": "233", "Body": "<p>My original class structure was similar to:</p>\n<pre><code>//def.h\nnamespace A\n{\n   struct X {};\n}\n</code></pre>\n<p>and forward declarations where needed:</p>\n<pre><code>//file that needs forward declarations\nnamespace A { struct X; }\n</code></pre>\n<p>After some refactoring, <code>X</code> was moved to a different namespace, but to keep old code \"working\" <code>using</code> directives were used:</p>\n<pre><code>//def.h\nnamespace B\n{\n   struct X {};\n}\nnamespace A\n{\n   using ::B::X;\n}\n</code></pre>\n<p>Now we can access the same class keeping the old syntax <code>A::X</code>, but the forward declarations cause errors. The second problem is that the error message I'm getting doesn't point to where the forward declarations are, and finding/replacing the forward declarations is time-consuming.</p>\n<p>For now I fixed the problem (the hard way).</p>\n<p>What is the best approach to deal with this situation?</p>\n<p>IMO, the <code>using</code> shouldn't be there at all, and all code that uses <code>X</code> should be refactored to accomodate the new namespace (this is one solution), but unfortunately this isn't an option.</p>\n<p>The actual code is a lot more complicated, this is a simplified example.</p>\n", "Title": "Forward declarations cause errors after code refactor", "CreationDate": "2013-01-09T13:00:09.830", "LastActivityDate": "2013-01-09T20:26:09.313", "CommentCount": "9", "LastEditDate": "2013-01-09T13:37:43.423", "PostTypeId": "1", "LastEditorUserId": "819272", "Id": "14235780", "Score": "5", "OwnerUserId": "673730", "Tags": "<c++><namespaces><refactoring><forward-declaration><using-directives>", "AnswerCount": "2"}, "14236302": {"Id": "14236302", "PostTypeId": "2", "Body": "<p>I realize this is more about new code than about refactoring existing code, but I like using a special header called <code>X_fwd.hpp</code> for such cases. </p>\n<pre><code>// X_def.hpp\nnamespace B\n{\n   struct X {};\n}\nnamespace A\n{\n   // NOT: using namespace B; // does not participate in ADL!      \n   typedef ::B::X X;  // OR: using ::B::X;\n}\n\n// X_fwd.hpp\nnamespace A { struct X; }\n\n// some file needing declaration of X\n#include &lt;X_fwd.hpp&gt;\n</code></pre>\n<p>This makes it a lot easier to find forward declarations, and also to change them after the fact, because the change is isolated in one place only (DRY...).</p>\n<p><strong>NOTE1</strong>: AFAIK, there is no technical difference between using Peter Wood's answer of a <code>typedef</code> and your <code>using</code> declaration. Note that a <code>using</code> directive <code>using namespace B;</code> could cause trouble because these are ignored by <strong>Argument-Dependent-Lookup</strong>. Even worse, some of your code might then even <strong>silently call the wrong function overload</strong> because you are not pulling in the new namespace <code>B</code> anymore!</p>\n<p><strong>NOTE2</strong>: In the comments to the question, an <a href=\"http://ideone.com/CxhctQ\" rel=\"nofollow\">Ideone</a> example was given. This nicely illustrates a subtlety about name lookup inside namespaces: to quote from the draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">Standard</a>, section <strong>3.4.3.2 Namespace members [namespace.qual]</strong>, clause 2</p>\n<blockquote>\n<p id=\"so_14235780_14236302_0\">For a namespace X and name m, the namespace-quali\ufb01ed lookup set S(X,\n  m) is de\ufb01ned as follows: Let S'(X, m) be the set of all declarations\n  of m in X and the inline namespace set of X (7.3.1). If S'(X, m) is\n  not empty, S(X, m) is S'(X, m); otherwise, S(X, m) is the union of\n  S(Ni, m) for all namespaces Ni nominated by using-directives in X and\n  its inline namespace set.</p>\n</blockquote>\n<p>This explains the following tricky ambiguity</p>\n<pre><code>namespace A\n{\n    struct X1{};\n    struct X2{};\n}\n\nnamespace B\n{\n    using A::X1;    // OK: lookup-set is both namespace A and B, and a single unique name is found (at this point!)\n    struct X1;      // OK: lookup-set is namespace B, and a single unique name is found\n\n    struct X2;      // OK: lookup-set is namespace B, and a single unique name is found\n    using A::X2;    // error: lookup-set is both namespace A and B, and no unique name is found (at this point!)\n}\n</code></pre>\n<p>So the validity of having both a direct declaration and a using-declaration with the same name inside a namespace is order-dependent. Hence the convenience of a single declaration in a fwd header file.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2013-01-09T20:26:09.313", "Score": "4", "CreationDate": "2013-01-09T13:28:05.480", "ParentId": "14235780", "CommentCount": "4", "OwnerUserId": "819272", "LastEditDate": "2013-01-09T20:26:09.313"}, "14235880": {"Id": "14235880", "PostTypeId": "2", "Body": "<p>The best approach is to fix the code.</p>\n<p>You can do it in two steps :</p>\n<ol>\n<li>fix all forward declares</li>\n<li>remove <code>using ::B::X;</code></li>\n</ol>\n", "LastActivityDate": "2013-01-09T13:06:12.637", "CommentCount": "1", "CreationDate": "2013-01-09T13:06:12.637", "ParentId": "14235780", "Score": "1", "OwnerUserId": "476681"}});