post_cb({"bq_ids": {"n4140": {"so_14674289_14674289_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 704}, "so_14674289_14674289_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 709}}, "n3337": {"so_14674289_14674289_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 694}, "so_14674289_14674289_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 698}}, "n4659": {"so_14674289_14674289_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 733}, "so_14674289_14674289_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 738}}}, "14674289": {"ViewCount": "888", "Body": "<p>C++11 standard has following lines in General Container Requirements.</p>\n<p><em>(23.2.1 - 3)</em></p>\n<blockquote>\n<p id=\"so_14674289_14674289_0\">For the components affected by this subclause that declare an allocator_type, objects stored in these components shall be constructed using the allocator_traits::construct function and destroyed using the allocator_traits::destroy function (20.6.8.2). These functions are called only for the container\u2019s element type, <strong>not for internal types used by the container</strong></p>\n</blockquote>\n<p><em>(23.2.1 - 7)</em></p>\n<blockquote>\n<p id=\"so_14674289_14674289_1\">Unless otherwise specified, <strong>all containers defined in this clause obtain memory using an allocator</strong></p>\n</blockquote>\n<p>Is it true or not, that <em>all</em> memory used by container is allocated by specified allocator? Because standard says that internal types are constructed not with allocator_traits::construct, so there should be some kind of call to operator new. But standard also says that all containers defined in this clause obtain memory using an allocator, which in my opinion means that it can't be ordinary new operator, it has to be placement new operator. Am I correct?</p>\n<p>Let me show you example, why this is important.</p>\n<p>Let's say we have a class, which holds some allocated memory:</p>\n<pre><code>#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;new&gt;\n\nclass Arena\n{\npublic:\n        Arena(std::size_t size)\n        {\n                size_     = size;\n                location_ = 0;\n\n                data_ = nullptr;\n                if(size_ &gt; 0)\n                        data_ = new(std::nothrow) uint8_t[size_];\n        }\n        Arena(const Arena&amp; other) = delete;\n        ~Arena()\n        {\n                if(data_ != nullptr)\n                        delete[] data_;\n        }\n        Arena&amp; operator =(const Arena&amp; arena) = delete;\n\n        uint8_t* allocate(std::size_t size)\n        {\n                if(data_ == nullptr)\n                        throw std::bad_alloc();\n\n                if((location_ + size) &gt;= size_)\n                        throw std::bad_alloc();\n\n                uint8_t* result = &amp;data_[location_];\n                location_ += size;\n                return result;\n        }\n\n        void clear()\n        {\n                location_ = 0;\n        }\n\n        std::size_t getNumBytesUsed() const\n        {\n                return location_;\n        }\n\nprivate:\n        uint8_t* data_;\n        std::size_t location_, size_;\n\n};\n</code></pre>\n<p>we also have custom allocator:</p>\n<pre><code>template &lt;class T&gt; class FastAllocator\n{\npublic:\n        typedef T value_type;\n\n        typedef T*       pointer;\n        typedef const T* const_pointer;\n\n        typedef T&amp;       reference;\n        typedef const T&amp; const_reference;\n\n        typedef std::size_t    size_type;\n        typedef std::ptrdiff_t difference_type;\n\n        template &lt;class U&gt; class rebind\n        {\n        public:\n                typedef FastAllocator&lt;U&gt; other;\n\n        };\n\n        Arena* arena;\n\n        FastAllocator(Arena&amp; arena_): arena(&amp;arena_) {}\n        FastAllocator(const FastAllocator&amp; other): arena(other.arena) {}\n        template &lt;class U&gt; FastAllocator(const FastAllocator&lt;U&gt;&amp; other): arena(other.arena) {}\n\n        //------------------------------------------------------------------------------------\n        pointer allocate(size_type n, std::allocator&lt;void&gt;::const_pointer)\n        {\n                return allocate(n);\n        }\n        pointer allocate(size_type n)\n        {\n                return reinterpret_cast&lt;pointer&gt;(arena-&gt;allocate(n * sizeof(T)));\n        }\n\n        //------------------------------------------------------------------------------------\n        void deallocate(pointer, size_type) {}\n\n        //------------------------------------------------------------------------------------\n        size_type max_size() const\n        {\n                return std::numeric_limits&lt;size_type&gt;::max();\n        }\n\n        //------------------------------------------------------------------------------------\n        void construct(pointer p, const_reference val)\n        {\n                ::new(static_cast&lt;void*&gt;(p)) T(val);\n        }\n        template &lt;class U&gt; void destroy(U* p)\n        {\n                p-&gt;~U();\n        }\n\n};\n</code></pre>\n<p>This is how we use it:</p>\n<pre><code>typedef std::unordered_map&lt;uint32_t, uint32_t, std::hash&lt;uint32_t&gt;, std::equal_to&lt;uint32_t&gt;,\n                           FastAllocator&lt;std::pair&lt;uint32_t, uint32_t&gt;&gt;&gt; FastUnorderedMap;\n\nint main()\n{\n        // Allocate memory in arena\n        Arena arena(1024 * 1024 * 50);\n        FastAllocator&lt;uint32_t&gt; allocator(arena);\n        FastAllocator&lt;std::pair&lt;uint32_t, uint32_t&gt;&gt; pairAllocator(arena);\n        FastAllocator&lt;FastUnorderedMap&gt; unorderedMapAllocator(arena);\n\n        FastUnorderedMap* fastUnorderedMap = nullptr;\n\n        try\n        {\n                // allocate memory for unordered map\n                fastUnorderedMap = unorderedMapAllocator.allocate(1);\n\n                // construct unordered map\n                fastUnorderedMap =\n                        new(reinterpret_cast&lt;void*&gt;(fastUnorderedMap)) FastUnorderedMap\n                        (\n                                0,\n                                std::hash&lt;uint32_t&gt;(),\n                                std::equal_to&lt;uint32_t&gt;(),\n                                pairAllocator\n                        );\n\n                // insert something\n                for(uint32_t i = 0; i &lt; 1000000; ++i)\n                        fastUnorderedMap-&gt;insert(std::make_pair(i, i));\n        }\n        catch(std::bad_alloc badAlloc)\n        {\n                std::cout &lt;&lt; \"--- BAD ALLOC HAPPENED DURING FAST UNORDERED MAP INSERTION ---\" &lt;&lt; std::endl;\n        }\n\n        // no destructor of unordered map is called!!!!\n        return 0;\n}\n</code></pre>\n<p>As you can see, destructor of unordered_map is never called, but memory is freed during destruction of arena object. Will there be any memory leak and why?</p>\n<p>I would really appreciate any help on this topic.</p>\n", "AcceptedAnswerId": "14674382", "Title": "Memory allocation of internal types used by the containers", "CreationDate": "2013-02-03T15:53:25.110", "Id": "14674289", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-02-07T20:12:15.310", "LastEditorUserId": "636019", "LastActivityDate": "2013-02-07T20:12:15.310", "Score": "6", "OwnerUserId": "2037382", "Tags": "<c++><c++11><std><allocator>", "AnswerCount": "1"}, "14674382": {"Id": "14674382", "PostTypeId": "2", "Body": "<p>An allocator is supposed to provide 4 functions (of interest here):</p>\n<ul>\n<li>2 are used for memory management: <code>allocate</code>/<code>deallocate</code></li>\n<li>2 are used for objects lifetime management: <code>construct</code>/<code>destroy</code></li>\n</ul>\n<p>The <em>these functions</em> in your quote only apply to <code>construct</code> and <code>destroy</code> (which were mentioned in the previous sentence), and not to <code>allocate</code>/<code>deallocate</code>, thus there is no contradiction.</p>\n<p>Now, regarding memory leaks, for an arena allocator to work not only should the objects in the container be built using the arena allocator (which the container guarantees) but all the memory <em>those objects</em> allocate should also be obtained from this allocator; this can get slightly more complicated unfortunately.</p>\n", "LastActivityDate": "2013-02-03T16:03:56.993", "CommentCount": "3", "CreationDate": "2013-02-03T16:03:56.993", "ParentId": "14674289", "Score": "8", "OwnerUserId": "147192"}});