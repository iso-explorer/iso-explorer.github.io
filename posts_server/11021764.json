post_cb({"11022116": {"ParentId": "11021764", "CommentCount": "6", "CreationDate": "2012-06-13T19:36:50.427", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "11022116", "Score": "10", "Body": "<p>I think the edit that changed move construction to move assignment changes the answer. </p>\n<p>At least if I'm reading table 96 correctly, the complexity for move construction is given as \"note B\", which is constant complexity for anything except <code>std::array</code>. The complexity for move <em>assignment</em>, however, is given as linear.</p>\n<p>As such, the move construction has essentially no choice but to copy the pointer from the source, in which case it's hard to see how the iterators could become invalid.</p>\n<p>For move assignment, however, the linear complexity means it <em>could</em> choose to move individual elements from the source to the destination, in which case the iterators will almost certainly become invalid. </p>\n<p>The possibility of move assignment of elements is reinforced by the description: \"All existing elements of a are either move assigned to or destroyed\". The \"destroyed\" part would correspond to destroying the existing contents, and \"stealing\" the pointer from the source -- but the \"move assigned to\" would indicate moving individual elements from source to destination instead.</p>\n", "LastActivityDate": "2012-06-13T19:36:50.427"}, "11022447": {"ParentId": "11021764", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-06-13T20:00:37.920", "Score": "23", "LastEditorUserId": "279627", "LastEditDate": "2012-06-15T13:19:40.793", "Id": "11022447", "OwnerUserId": "241536", "Body": "<p>While it might be reasonable to assume that <code>iterator</code>s are still valid after a <code>move</code>, I don't think the Standard actually guarantees this.  Therefore, the iterators are in an undefined state after the <code>move</code>.</p>\n<hr>\n<p>There is no reference I can find in the Standard which <em>specifically states</em> that iterators that existed before a <code>move</code> are still valid <em>after</em> the <code>move</code>.</p>\n<p>On the surface, it would seem to be perfectly reasonable to assume that an <code>iterator</code> is <em>typically</em> implemented as pointers in to the controlled sequence.  If that's the case, then the iterators would still be valid after the <code>move</code>.</p>\n<p>But the implementation of an <code>iterator</code> is implementation-defined.  Meaning, so long as the <code>iterator</code> on a particular platform meets the requirements set forth by the Standard, it can be implemented in any way whatsoever.  It could, in theory, be implemented as a combination of a pointer back to the <code>vector</code> class along with an index.  If <em>that's</em> the case, then the iterators would become invalid after the <code>move</code>.</p>\n<p>Whether or not an <code>iterator</code> is actually implemented this way is irrelevant.  It could be implemented this way, so without a specific guarantee from the Standard that post-<code>move</code> iterators are still valid, you cannot assume that they are.  Bear in mind also that there <strong>is</strong> such a guarantee for iterators after a <code>swap</code>.  This was specifically clarified from the previous Standard.  Perhaps it was simply an oversight of the Std comittee to not make a similar clarification for iterators after a <code>move</code>, but in any case there is no such guarantee.</p>\n<p>Therefore, the long and the short of it is you can't assume your iterators are still good after a <code>move</code>.</p>\n<h2>EDIT:</h2>\n<p>23.2.1/11 in Draft n3242 states that:</p>\n<blockquote>\n<p id=\"so_11021764_11022447_0\">Unless otherwise specified (either explicitly or by defining a\n  function in terms of other functions), invoking a container member\n  function or passing a container as an argument to a library function\n  shall not invalidate iterators to, or change the values of, objects\n  within that container.</p>\n</blockquote>\n<p>This might lead one to conclude that the iterators are valid after a <code>move</code>, but I disagree.  In your example code, <code>a_iter</code> was an iterator in to the <code>vector</code> <code>a</code>.  After the <code>move</code>, that container, <code>a</code> has certainly been changed.  My conclusion is the above clause does not apply in this case.</p>\n</hr>", "LastActivityDate": "2012-06-15T13:19:40.793"}, "11022284": {"ParentId": "11021764", "CommentCount": "10", "CreationDate": "2012-06-13T19:49:45.157", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "11022284", "Score": "3", "Body": "<p>Since there's nothing to keep an iterator from keeping a reference or pointer to the original container, I'd say you can't rely on the iterators remaining valid unless you find an explicit guarantee in the standard.</p>\n", "LastActivityDate": "2012-06-13T19:49:45.157"}, "40445603": {"ParentId": "11021764", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-11-06T03:05:36.353", "Score": "1", "LastEditorUserId": "951423", "LastEditDate": "2016-11-06T15:22:15.960", "Id": "40445603", "OwnerUserId": "951423", "Body": "<p><strong>tl;dr : Yes, moving a <code>std::vector&lt;T, A&gt;</code> possibly invalidates the iterators</strong></p>\n<p><sub>The common case (with <code>std::allocator</code> in place) is that invalidation does not happen but there is no guarantee and switching compilers or even the next compiler update might make your code behave incorrect if you rely on the fact the your implementation currently does not invalidate the iterators.</sub></p>\n<hr>\n<p><em>On move assignment</em>:</p>\n<p>The question whether <code>std::vector</code> iterators can actually remain valid after move-assignment is connected with the allocator awareness of the vector template and depends on the allocator type (and possibly the respective instances thereof).</p>\n<p>In every implementation I have seen, move-assignment of a <code>std::vector&lt;T, std::allocator&lt;T&gt;&gt;</code><strong><sup>1</sup></strong> will not actually invalidate iterators or pointers. There is a problem however, when it comes down to making use of this, as <strong>the standard just cannot guarantee that iterators remain valid for any move-assignment of a <code>std::vector</code> instance in general, because the container is allocator aware.</strong></p>\n<p>Custom allocators may have state and if they do not propagate on move assignment and do not compare equal, the vector must allocate storage for the moved elements using its own allocator.</p>\n<p>Let:</p>\n<pre><code>std::vector&lt;T, A&gt; a{/*...*/};\nstd::vector&lt;T, A&gt; b;\nb = std::move(a);\n</code></pre>\n<p>Now if</p>\n<ol>\n<li><code>std::allocator_traits&lt;A&gt;::propagate_on_container_move_assignment::value == false &amp;&amp;</code></li>\n<li><code>std::allocator_traits&lt;A&gt;::is_always_equal::value == false &amp;&amp;</code> (<em>possibly as of c++17</em>)</li>\n<li><code>a.get_allocator() != b.get_allocator()</code></li>\n</ol>\n<p>then <code>b</code> will allocate new storage and move elements of <code>a</code> one by one into that storage, thus invalidating all iterators, pointers and references.</p>\n<p>The reason is that fulfillment of above condition <strong>1.</strong> forbidds move assignment of the allocator on container move. Therefore, we have to deal with two different instances of the allocator. If those two allocator objects now neither always compare equal (<strong>2.</strong>) nor actually compare equal, then both allocators have a different state. An allocator <code>x</code> may not be able to deallocate memory of another allocator <code>y</code> having a different state and therefore a container with allocator <code>x</code> cannot just steal memory from a container which allocated its memory via <code>y</code>.</p>\n<p>If the allocator propagates on move assignment or if both allocators compare equal, then an implementation will very likely choose to just make <code>b</code> own <code>a</code>s data because it can be sure to be able to deallocate the storage properly.</p>\n<p><strong><sup>1</sup></strong>: <code>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::propagate_on_container_move_assignment</code> and <code>std::allocator_traits&lt;std::allocator&lt;T&gt;&gt;::is_always_equal</code> both are typdefs for <code>std::true_type</code> (for any non-specialized <code>std::allocator</code>).</p>\n<hr>\n<p><em>On move construction</em>:</p>\n<pre><code>std::vector&lt;T, A&gt; a{/*...*/};\nstd::vector&lt;T, A&gt; b(std::move(a));\n</code></pre>\n<p>The move constructor of an allocator aware container will move-construct its allocator instance from the allocator instance of the container which the current expression is moving from. Thus, the proper deallocation capability is ensured and the memory can (and in fact will) be stolen because move construction is (except for <code>std::array</code>) bound to have constant complexity.</p>\n<p><em>Note: There is still no guarantee for iterators to remain valid even for move construction.</em></p>\n<hr>\n<p><em>On swap</em>:</p>\n<p>Demanding the iterators of two vectors to remain valid after a swap (now just pointing into the respective swapped container) is easy because swapping only has defined behaviour if </p>\n<ol>\n<li><code>std::allocator_traits&lt;A&gt;::propagate_on_container_swap::value == true ||</code></li>\n<li><code>a.get_allocator() == b.get_allocator()</code></li>\n</ol>\n<p>Thus, if the allocators do not propagate on swap and if they do not compare equal, swapping the containers is undefined behaviour in the first place.</p>\n</hr></hr></hr>", "LastActivityDate": "2016-11-06T15:22:15.960"}, "11021764": {"CommentCount": "11", "AcceptedAnswerId": "11022447", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-06-13T19:13:27.903", "LastActivityDate": "2016-11-06T15:22:15.960", "LastEditDate": "2017-05-23T12:17:33.783", "ViewCount": "2852", "FavoriteCount": "9", "Title": "Does moving a vector invalidate iterators?", "Id": "11021764", "Score": "59", "Body": "<p>If I have an iterator to a vector, then I move-construct or move-assign another vector from that vector, does that iterator still point to a valid element in the new vector? Here's a simple example: </p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[])\n{\n    std::vector&lt;int&gt;::iterator a_iter;\n    std::vector&lt;int&gt; b;\n    {\n        std::vector&lt;int&gt; a{1, 2, 3, 4, 5};\n        a_iter = a.begin() + 2;\n        b = std::move(a);\n    }\n    std::cout &lt;&lt; *a_iter &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Is <code>a_iter</code> still valid since <code>a</code> has been moved into <code>b</code>, or is the iterator invalidated by the move? For reference, <code>std::vector::swap</code> <a href=\"https://stackoverflow.com/a/4125186/185171\">does not invalidate iterators</a>.</p>\n", "Tags": "<c++><iterator><c++11>", "OwnerUserId": "185171", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_11021764_11022447_0": {"section_id": 713, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_11021764_11022447_0": {"section_id": 702, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_11021764_11022447_0": {"section_id": 742, "quality": 0.9615384615384616, "length": 25}}}});