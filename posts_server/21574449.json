post_cb({"21574751": {"ParentId": "21574449", "CommentCount": "0", "Body": "<p>This is a tough one to solve \"generically\", because the \"looses precision\" indicates that your pointers are larger than the type you are trying to store it in. Which may well be \"ok\" in your mind, but the compiler is concerned that you will be restoring the int value back into a pointer, which has now lost the upper 32 bits (assuming we're talking 32-bit int and 64-bit pointers - there are other possible combinations). </p>\n<p>There is <code>uintptr_t</code> that is size-compatible with whatever the pointer is on the systems, so typically, you can overcome the actual error by:</p>\n<pre><code>int x = static_cast&lt;int&gt;(reinterpret_cast&lt;uintptr_t&gt;(some_ptr));\n</code></pre>\n<p>This will first force a large integer from a pointer, and then cast the large integer to a smaller type. </p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "21574751", "Score": "4", "CreationDate": "2014-02-05T10:33:52.370", "LastActivityDate": "2014-02-05T10:33:52.370"}, "21575006": {"ParentId": "21574449", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Answer for C</p>\n<p>Converting pointers to integers is implementation defined. Your problem is that the code that you are talking about seems never have been correct. And probably only worked on ancient architectures where both <code>int</code> and pointers are 32 bit.</p>\n<p>The only types that are supposed to convert without loss are <code>[u]intptr_t</code>, if they exist on the platform (usually they do). Which part of such an <code>uintptr_t</code> is appropriate to use for your hash function is difficult to tell, you shouldn't make any assumptions on that. I would go for something like</p>\n<pre><code>uintptr_t n = (uintptr_t)x;\n</code></pre>\n<p>and then</p>\n<pre><code>((n &gt;&gt; 32) ^ n) &amp; UINT32_MAX\n</code></pre>\n<p>this can be optimized out on 32 bit archs, and would give you traces of all other bits on 64 bit archs.</p>\n<p>For C++ basically the same should apply, just the cast would be <code>reinterpret_cast&lt;std:uintptr_t&gt;(x)</code>.</p>\n", "OwnerUserId": "366377", "LastEditorUserId": "366377", "LastEditDate": "2014-02-05T10:51:27.630", "Id": "21575006", "Score": "3", "CreationDate": "2014-02-05T10:44:34.347", "LastActivityDate": "2014-02-05T10:51:27.630"}, "21574449": {"CommentCount": "20", "ViewCount": "4482", "PostTypeId": "1", "LastEditorUserId": "201725", "CreationDate": "2014-02-05T10:20:59.963", "LastActivityDate": "2014-02-05T10:51:27.630", "Title": "Why is \u201ccast from \u2018X*\u2019 to \u2018Y\u2019 loses precision\u201d a hard error and what is suitable fix for legacy code", "AcceptedAnswerId": "21574902", "LastEditDate": "2014-02-05T10:37:19.420", "Id": "21574449", "Score": "5", "Body": "<h1>1. Why?</h1>\n<p>Code like this used to work and it's kind of obvious what it is supposed to mean. Is the compiler even <em>allowed</em> (by the specification) to make it an error?</p>\n<p>I know that it's loosing precision and I would be happy with a warning. But it still has a well-defined semantics (at least for unsigned downsizing cast is defined) and the user just might want to do it.</p>\n<h1>2. Workaround</h1>\n<p>I have legacy code that I don't want to refactor too much because it's rather tricky and already debugged. It is doing two things:</p>\n<ol>\n<li><p>Sometimes stores integers in pointer variables. The code only casts the pointer to integer if it stored an integer in it before. Therefore while the cast is downsizing, the overflow never happens in reality. The code is tested and works.</p>\n<p>When integer is stored, it always fits in plain old unsigned, so changing the type is not considered a good idea and the pointer is passed around quite a bit, so changing it's type would be somewhat invasive.</p></li>\n<li><p>Uses the address as hash value. A rather common thing to do. The hash table is not that large to make any sense to extend the type.</p>\n<p>The code uses plain <code>unsigned</code> for hash value, but note that the more usual type of <code>size_t</code> <em>may still generate the error</em>, because there is no guarantee that <code>sizeof(size_t)</code> &gt;= <code>sizeof(void *)</code>. On platforms with segmented memory and far pointers, <code>size_t</code> only has to cover the offset part.</p></li>\n</ol>\n<p>So what are the least invasive suitable workarounds? The code is known to work when compiled with compiler that does not produce this error, so I really want to do the operation, not change it.</p>\n<hr>\n<h1>Notes:</h1>\n<pre><code>void *x;\nint y;\nunion U { void *p; int i; } u;\n</code></pre>\n<ol>\n<li><code>*(int*)&amp;x</code> and <code>u.p = x, u.i</code> are <em>not</em> equivalent to <code>(int)x</code> and are <em>not</em> the opposite of <code>(void *)y</code>. On big endian architectures, the first two will return the bytes on lower addresses while the later will work on low order bytes, which may reside on higher addresses.</li>\n<li><code>*(int*)&amp;x</code> and <code>u.p = x, u.i</code> are both strict aliasing violations, <code>(int)x</code> is <em>not</em>.</li>\n</ol>\n</hr>", "Tags": "<c++><c><language-lawyer>", "OwnerUserId": "201725", "AnswerCount": "3"}, "21574902": {"ParentId": "21574449", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>C++, 5.2.10:</p>\n<blockquote>\n<p id=\"so_21574449_21574902_0\">4 - A pointer can be explicitly converted to any integral type large enough to hold it. [...]</p>\n</blockquote>\n<p>C, 6.3.2.3:</p>\n<blockquote>\n<p id=\"so_21574449_21574902_1\">6 - Any pointer type may be converted to an integer type. [...] If the result cannot be represented in the integer type, the behavior is undefined. [...]</p>\n</blockquote>\n<p>So <code>(int) p</code> is illegal if <code>int</code> is 32-bit and <code>void *</code> is 64-bit; a C++ compiler is correct to give you an error, while a C compiler may either give an error on translation or emit a program with undefined behaviour.</p>\n<p>You should write, adding a single conversion:</p>\n<pre><code>(int) (intptr_t) p\n</code></pre>\n<p>or, using C++ syntax,</p>\n<pre><code>static_cast&lt;int&gt;(reinterpret_cast&lt;intptr_t&gt;(p))\n</code></pre>\n<p>If you're converting to an unsigned integer type, convert via <code>uintptr_t</code> instead of <code>intptr_t</code>.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-02-05T10:46:14.310", "Id": "21574902", "Score": "8", "CreationDate": "2014-02-05T10:40:27.690", "LastActivityDate": "2014-02-05T10:46:14.310"}, "bq_ids": {"n4140": {"so_21574449_21574902_1": {"section_id": 38, "quality": 0.6428571428571429, "length": 9}, "so_21574449_21574902_0": {"section_id": 6043, "quality": 1.0, "length": 9}}, "n3337": {"so_21574449_21574902_1": {"section_id": 35, "quality": 0.6428571428571429, "length": 9}, "so_21574449_21574902_0": {"section_id": 5811, "quality": 1.0, "length": 9}}, "n4659": {"so_21574449_21574902_1": {"section_id": 38, "quality": 0.6428571428571429, "length": 9}, "so_21574449_21574902_0": {"section_id": 7542, "quality": 1.0, "length": 9}}}});