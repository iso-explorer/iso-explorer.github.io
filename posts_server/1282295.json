post_cb({"19014644": {"ParentId": "1282295", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-09-25T20:31:24.023", "Score": "3", "LastEditorUserId": "1140976", "LastEditDate": "2014-10-30T15:30:30.047", "Id": "19014644", "OwnerUserId": "427532", "Body": "<blockquote>\n<p id=\"so_1282295_19014644_0\">Also, do you have another example (beside the Wikipedia one) where <code>nullptr</code> is superior to good old 0?</p>\n</blockquote>\n<p>Yes. It's also a (simplified) real-world example that occurred in our production code. It only stood out because gcc was able to issue a warning when crosscompiling to a platform with different register width (still not sure exactly why only when crosscompiling from x86_64 to x86, warns <code>warning: converting to non-pointer type 'int' from NULL</code>):</p>\n<p>Consider this code (C++03):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B {};\n\nstruct A\n{\n    operator B*() {return 0;}\n    operator bool() {return true;}\n};\n\nint main()\n{\n    A a;\n    B* pb = 0;\n    typedef void* null_ptr_t;\n    null_ptr_t null = 0;\n\n    std::cout &lt;&lt; \"(a == pb): \" &lt;&lt; (a == pb) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(a == 0): \" &lt;&lt; (a == 0) &lt;&lt; std::endl; // no warning\n    std::cout &lt;&lt; \"(a == NULL): \" &lt;&lt; (a == NULL) &lt;&lt; std::endl; // warns sometimes\n    std::cout &lt;&lt; \"(a == null): \" &lt;&lt; (a == null) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It yields this output:</p>\n<pre><code>(a == pb): 1\n(a == 0): 0\n(a == NULL): 0\n(a == null): 1\n</code></pre>\n", "LastActivityDate": "2014-10-30T15:30:30.047"}, "bq_ids": {"n4140": {"so_1282295_1282328_1": {"section_id": 5366, "quality": 0.75, "length": 6}}, "n3337": {"so_1282295_1282328_1": {"section_id": 5162, "quality": 0.75, "length": 6}}, "n4659": {"so_1282295_1282328_1": {"section_id": 6791, "quality": 0.75, "length": 6}}}, "31754707": {"ParentId": "1282295", "CommentCount": "0", "CreationDate": "2015-07-31T20:31:51.737", "OwnerUserId": "5179281", "PostTypeId": "2", "Id": "31754707", "Score": "-2", "Body": "<p>NULL need not to be 0. As long you use always NULL and never 0, NULL can be any value. Asuming you programme a von Neuman Microcontroller with flat memory, that has its interrupt vektors at 0. If NULL is 0 and something writes at a NULL Pointer the Microcontroller crashes. If NULL is lets say 1024 and at 1024 there is a reserved variable, the write won't crash it, and you can detect NULL Pointer assignments from inside the programme. This is Pointless on PCs, but for space probes, military or medical equipment it is important not to crash.</p>\n", "LastActivityDate": "2015-07-31T20:31:51.737"}, "1282345": {"ParentId": "1282295", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2009-08-15T17:06:52.770", "Score": "328", "LastEditorUserId": "485561", "LastEditDate": "2012-11-25T04:21:04.600", "Id": "1282345", "OwnerUserId": "34509", "Body": "<blockquote>\n<p id=\"so_1282295_1282345_0\">How is it a keyword and an instance of a type?</p>\n</blockquote>\n<p>This isn't surprising. Both <code>true</code> and <code>false</code> are keywords and as literals they have a type ( <code>bool</code> ). <code>nullptr</code> is a <em>pointer literal</em> of type <code>std::nullptr_t</code>, and it's a prvalue (you cannot take the address of it using <code>&amp;</code>). </p>\n<ul>\n<li><p><code>4.10</code> about pointer conversion says that a prvalue of type <code>std::nullptr_t</code> is a null pointer constant, and that an integral null pointer constant can be converted to <code>std::nullptr_t</code>. The opposite direction is not allowed. This allows overloading a function for both pointers and integers, and passing <code>nullptr</code> to select the pointer version. Passing <code>NULL</code> or <code>0</code> would confusingly select the <code>int</code> version. </p></li>\n<li><p>A cast of <code>nullptr_t</code> to an integral type needs a <code>reinterpret_cast</code>, and has the same semantics as a cast of <code>(void*)0</code> to an integral type (mapping implementation defined). A <code>reinterpret_cast</code> cannot convert <code>nullptr_t</code> to any pointer type. Rely on the implicit conversion if possible or use <code>static_cast</code>. </p></li>\n<li><p>The Standard requires that <code>sizeof(nullptr_t)</code> be <code>sizeof(void*)</code>. </p></li>\n</ul>\n", "LastActivityDate": "2012-11-25T04:21:04.600"}, "1282295": {"CommentCount": "5", "AcceptedAnswerId": "1282345", "PostTypeId": "1", "LastEditorUserId": "19750", "CreationDate": "2009-08-15T16:47:32.060", "LastActivityDate": "2017-10-20T21:32:39.053", "LastEditDate": "2013-10-09T12:36:57.707", "ViewCount": "251813", "FavoriteCount": "146", "Title": "What exactly is nullptr?", "Id": "1282295", "Score": "441", "Body": "<p>We now have C++11 with many new features. An interesting and confusing one (at least for me) is the new <code>nullptr</code>.</p>\n<p>Well, no need anymore for the nasty macro <code>NULL</code>.</p>\n<pre><code>int* x = nullptr;\nmyclass* obj = nullptr;\n</code></pre>\n<p>Still, I am not getting how <code>nullptr</code> works. For example, <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#Null_pointer_constant\" rel=\"noreferrer\">Wikipedia article</a> says:</p>\n<blockquote>\n<p id=\"so_1282295_1282295_0\">C++11 corrects this by introducing a new <strong>keyword</strong> to serve as a distinguished null pointer constant: nullptr. It is of <strong>type nullptr_t</strong>, which is implicitly convertible and comparable to any pointer type or pointer-to-member type. It is not implicitly convertible or comparable to integral types, except for bool.</p>\n</blockquote>\n<p>How is it a keyword and an instance of a type?</p>\n<p>Also, do you have another example (beside the Wikipedia one) where <code>nullptr</code> is superior to good old <code>0</code>?</p>\n", "Tags": "<c++><pointers><c++11><nullptr>", "OwnerUserId": "127893", "AnswerCount": "9"}, "46857442": {"ParentId": "1282295", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-10-20T21:14:58.270", "Score": "0", "LastEditorUserId": "706055", "LastEditDate": "2017-10-20T21:32:39.053", "Id": "46857442", "OwnerUserId": "706055", "Body": "<p>Let's say that you have a function (f) which was overloaded to take both int and char*. Before C++ 11, If you wanted to call it with a null pointer, and you used NULL (i.e. the value 0), then you would call the one overloaded for int:</p>\n<pre><code>void f(int);\nvoid f(char*);\n\nvoid g() \n{\n  f(0); //calls f(int)\n}\n</code></pre>\n<p>This is probably not what you wanted. C++11 solves this with nullptr; Now you can write the following:</p>\n<pre><code>void g()\n{\n  f(nullptr); //calls f(char*)\n}\n</code></pre>\n", "LastActivityDate": "2017-10-20T21:32:39.053"}, "1282331": {"ParentId": "1282295", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2009-08-15T17:02:18.363", "Score": "46", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:31.583", "Id": "1282331", "OwnerUserId": "70482", "Body": "<p>From <a href=\"http://www.devx.com/cplus/10MinuteSolution/35167/1954\" rel=\"nofollow noreferrer\"><strong>nullptr: A Type-safe and Clear-Cut Null Pointer</strong></a>:</p>\n<blockquote>\n<p id=\"so_1282295_1282331_0\">The new C++09 nullptr keyword designates an rvalue constant that serves as a universal null pointer literal, replacing the buggy and weakly-typed literal 0 and the infamous NULL macro. nullptr thus puts an end to more than 30 years of embarrassment, ambiguity, and bugs. The following sections present the nullptr facility and show how it can remedy the ailments of NULL and 0.</p>\n</blockquote>\n<p>Other references:</p>\n<ul>\n<li><a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/nullptr\" rel=\"nofollow noreferrer\">WikiBooks</a>, with sample code.</li>\n<li>Here at Stack Overflow: <a href=\"https://stackoverflow.com/questions/176989/do-you-use-null-or-0-zero-for-pointers-in-c\">Do you use NULL or 0 (zero) for pointers in C++?</a></li>\n<li><a href=\"http://bytes.com/topic/c/answers/844323-template-default-values-non-template-pointers-arguments#post3381427\" rel=\"nofollow noreferrer\"><strong><code>template</code></strong></a></li>\n<li>Google group: <a href=\"http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/fd1a9d9ae404ddd8\" rel=\"nofollow noreferrer\">comp.lang.c++.moderated - compiler discussion</a> </li>\n</ul>\n", "LastActivityDate": "2014-12-13T18:58:42.973"}, "1282310": {"ParentId": "1282295", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2009-08-15T16:52:28.400", "Score": "3", "LastEditorUserId": "126042", "LastEditDate": "2009-08-15T17:03:31.653", "Id": "1282310", "OwnerUserId": "126042", "Body": "<p>Well, other languages have reserved words that are instances of types.  Python, for instance:</p>\n<pre><code>&gt;&gt;&gt; None = 5\n  File \"&lt;stdin&gt;\", line 1\nSyntaxError: assignment to None\n&gt;&gt;&gt; type(None)\n&lt;type 'NoneType'&gt;\n</code></pre>\n<p>This is actually a fairly close comparison because <code>None</code> is typically used for something that hasn't been intialized, but at the same time comparisons such as <code>None == 0</code> are false.</p>\n<p>On the other hand, in plain C,  <code>NULL == 0</code> would return true IIRC because <code>NULL</code> is just a macro returning 0, which is always an invalid address (AFAIK).</p>\n", "LastActivityDate": "2009-08-15T17:03:31.653"}, "1282328": {"ParentId": "1282295", "CommentCount": "0", "CreationDate": "2009-08-15T17:00:47.243", "OwnerUserId": "12868", "PostTypeId": "2", "Id": "1282328", "Score": "3", "Body": "<p>It is a keyword because the standard will specify it as such. ;-) According to the latest public draft (n2914)</p>\n<blockquote>\n<p id=\"so_1282295_1282328_0\">2.14.7 Pointer literals [lex.nullptr]</p>\n<pre><code>pointer-literal:\nnullptr\n</code></pre>\n<p id=\"so_1282295_1282328_1\">The pointer literal is the keyword <code>nullptr</code>. It is an rvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>It's useful because it does not implicitly convert to an integral value. </p>\n", "LastActivityDate": "2009-08-15T17:00:47.243"}, "1283623": {"ParentId": "1282295", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2009-08-16T06:46:58.347", "Score": "27", "LastEditorUserId": "3677097", "LastEditDate": "2016-04-16T18:12:01.097", "Id": "1283623", "OwnerUserId": "3848", "Body": "<p>When you have a function that can receive pointers to more than one type then calling it with <code>NULL</code> is ambiguous, the way this is worked around now is very hacky by accepting an int and assuming it's <code>NULL</code>.</p>\n<pre><code>template &lt;class T&gt;\nclass ptr {\n    T* p_;\n    public:\n        ptr(T* p) : p_(p) {}\n\n        template &lt;class U&gt;\n        ptr(U* u) : p_(dynamic_cast&lt;T*&gt;(u)) { }\n\n        // Without this ptr&lt;T&gt; p(NULL) would be ambiguous\n        ptr(int null) : p_(NULL)  { assert(null == NULL); }\n};\n</code></pre>\n<p>In <code>C++11</code> you would be able to overload on <code>nullptr_t</code> so that <code>ptr&lt;T&gt; p(42);</code> would be a compile-time error rather than a run-time <code>assert</code>.</p>\n<pre><code>ptr(std::nullptr_t) : p_(nullptr)  {  }\n</code></pre>\n", "LastActivityDate": "2016-04-16T18:12:01.097"}, "14583764": {"ParentId": "1282295", "CommentCount": "0", "CreationDate": "2013-01-29T13:12:14.827", "OwnerUserId": "633658", "PostTypeId": "2", "Id": "14583764", "Score": "6", "Body": "<p><code>nullptr</code> can't be assigned to an <code>integral type</code> such as an int but only a type <code>pointer</code>; either a built-in pointer type such as <code>int *ptr</code> or a smart pointer such as <code>std::shared_ptr&lt;T&gt;</code></p>\n<p>I believe this is an important distinction because <code>NULL</code> can still be assigned to an <code>integral type</code> and a <code>pointer</code> as <code>NULL</code> is a macro expanded to <code>0</code> which can serve as both an initial value for an <code>int</code> as well as a <code>pointer</code>.</p>\n", "LastActivityDate": "2013-01-29T13:12:14.827"}});