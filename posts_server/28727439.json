post_cb({"28728070": {"Id": "28728070", "PostTypeId": "2", "Body": "<p>I'm not 100% sure because of the wording but it looks like this is covered by 3.8/6 (the reason I think this interpretation is correct is because of the non-normative example in 3.8/5, <code>// undefined behavior, lifetime of *pb has ended</code>):</p>\n<blockquote>\n<p id=\"so_28727439_28728070_0\">...after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways....The program has undefined behavior if:</p>\n</blockquote>\n<p>Then the first bullet is the culprit: <code>an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,</code>: This conversion has to happen either at the point of call to <code>operator&lt;&lt;</code> or finally at the point where the integral value is read for formatting within <code>ostream</code> code.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2016-05-23T03:08:49.103", "Score": "6", "CreationDate": "2015-02-25T19:38:15.057", "ParentId": "28727439", "CommentCount": "6", "OwnerUserId": "251738", "LastEditDate": "2016-05-23T03:08:49.103"}, "28727439": {"ViewCount": "639", "Body": "<p>I can't find where in the standard that it says this program is undefined:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    int *p;\n    {\n        int n = 45;\n        p = &amp;n;\n    }\n    std::cout &lt;&lt; *p;\n}\n</code></pre>\n<p>None of the cases in \u00a73.8 object lifetime seem to apply here. </p>\n", "Title": "Is it undefined behavior to dereference a dangling pointer?", "CreationDate": "2015-02-25T19:01:37.727", "Id": "28727439", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-05-23T02:45:24.923", "LastEditorDisplayName": "user3920237", "LastEditorUserId": "2069064", "LastActivityDate": "2016-05-23T03:16:44.190", "Score": "7", "OwnerUserId": "4607239", "Tags": "<c++><language-lawyer><undefined-behavior>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_28727439_28728510_1": {"length": 35, "quality": 1.0, "section_id": 7193}, "so_28727439_28728510_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 7170}, "so_28727439_28745226_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 7193}, "so_28727439_37382133_0": {"length": 8, "quality": 1.0, "section_id": 9}, "so_28727439_28728070_0": {"length": 19, "quality": 0.95, "section_id": 7194}}, "n3337": {"so_28727439_28728510_1": {"length": 35, "quality": 1.0, "section_id": 6937}, "so_28727439_28728510_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6914}, "so_28727439_28745226_0": {"length": 47, "quality": 0.8703703703703703, "section_id": 6937}, "so_28727439_28728070_0": {"length": 19, "quality": 0.95, "section_id": 6938}, "so_28727439_37382133_0": {"length": 8, "quality": 1.0, "section_id": 6}}, "n4659": {"so_28727439_28728510_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 8702}, "so_28727439_28728510_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 8678}, "so_28727439_28745226_0": {"length": 47, "quality": 0.8703703703703703, "section_id": 8702}, "so_28727439_28728070_0": {"length": 19, "quality": 0.95, "section_id": 8703}, "so_28727439_37382133_0": {"length": 8, "quality": 1.0, "section_id": 10}}}, "28728510": {"Id": "28728510", "PostTypeId": "2", "Body": "<p>So first of all according to <strong>3.7.3 Automatic storage duration</strong> storage of your object is released:</p>\n<blockquote>\n<p id=\"so_28727439_28728510_0\">Block-scope variables explicitly declared register or not explicitly\n  declared static or extern have automatic storage duration. The storage\n  for these entities lasts until the block in which they are created\n  exits.</p>\n</blockquote>\n<p>And from <strong>3.8 Object lifetime</strong></p>\n<blockquote>\n<p id=\"so_28727439_28728510_1\">Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any pointer that refers to the\n  storage location where the object will be or was located may be used\n  but only in limited ways</p>\n</blockquote>\n<p>so dereferencing pointer to variable which storage released leads to UB</p>\n", "LastActivityDate": "2015-02-25T20:01:51.757", "CommentCount": "0", "CreationDate": "2015-02-25T20:01:51.757", "ParentId": "28727439", "Score": "-1", "OwnerUserId": "432358"}, "37382133": {"Id": "37382133", "PostTypeId": "2", "Body": "<p><code>*p</code> is a glvalue.  The code <code>cout &lt;&lt; *p</code> necessitates an <em>lvalue-to-rvalue conversion</em>. This is defined by C++14 [conv.lval].</p>\n<p>Point 2 lists various cases and describes the behaviour in each case. None of those apply to <code>*p</code>. Particularly, the last point is:</p>\n<blockquote>\n<p id=\"so_28727439_37382133_0\">Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p>However, <code>*p</code> does not indicate an object.  </p>\n<p>In section [basic.life] are a few cases that define what lvalue-to-rvalue conversion does, beyond what is said in [conv.lval]. Those cases relate to when storage for an object has been obtained, but we are outside the object's lifetime.  However they do not apply to <code>*p</code> because storage is released when the previous block ends.</p>\n<p>So, the behaviour of this code is <em>undefined by omission</em>: nowhere in the Standard does it define what it means to perform rvalue conversion when the lvalue does not indicate an object and does not indicate valid storage for an object.</p>\n<hr>\n<p>It can feel unsatisfactory for something to be \"undefined by omission\", we always like to see a concrete statement \"this is undefined behaviour\" to be sure we haven't overlooked something.  But sometimes that is how it is.</p>\n</hr>", "LastActivityDate": "2016-05-23T03:16:44.190", "CommentCount": "0", "CreationDate": "2016-05-23T03:16:44.190", "ParentId": "28727439", "Score": "1", "OwnerUserId": "1505939"}, "28745226": {"Id": "28745226", "PostTypeId": "2", "Body": "<p>That's certainly undefined behavior (by common sense, and by the wording of the standard).</p>\n<p>As far as the standard goes, 3.8/5 is rather concrete about what is allowed and about what isn't:</p>\n<blockquote>\n<p id=\"so_28727439_28745226_0\">[...] after the lifetime of an object has ended and <strong>before</strong> the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways [...] <strong>and using the pointer as if the pointer were of type void*,\n  is well-defined</strong>.<br>\n  Indirection [...] is permitted [...] as described below. The program <strong>has undefined behavior if</strong>:<br>\n  - ...<br>\n  - [...] used as operand of <code>static_cast</code>, except when the conversion is to pointer to cv <code>void</code>, or to pointer to cv <code>void</code> and subsequently to pointer to either cv <code>char</code> or cv <code>unsigned char</code><br>\n  - [...] used as the operand of <code>dynamic_cast</code></br></br></br></br></p>\n</blockquote>\n<p>The object's storage ends at the end of the scope per 3.7.3/1 (in practice this is most likely not true, the stack frame will probably be reset at the end of the function, but <em>formally</em> that's what happens). Therefore, the dereference doesn't happen after the end of lifetime <strong>but before</strong> the release of the storage. It happens <strong>after</strong> release of the storage.<br>\nThe special conditions under which you may dereference the pointer anyway do therefore not apply (the same is true for any similar paragraphs with the same precondition such as 3.8/6).</br></p>\n<p>Further, assuming that the previous paragraph wasn't true, it is only allowable to dereference the pointer as cv <code>void*</code> or to cast it to cv <code>char</code> (signed or unsigned) prior to dereferencing. In other words, you are <strong>not</strong> allowed to look at the pointed-to <code>int</code> as if it were an <code>int</code>. As stated in 3.8/5, the <code>int*</code> is really only a mere <code>void*</code> after the lifetime of the object. Which means dereferencing it as <code>int*</code> is the equivalent of doing a cast (not explicitly, but still).</p>\n<p>One would really wish that this attempt produces an error, but I guess that's a really tough one for the compiler to detect. The pointer itself is well and alive, and it has been safely derived by taking a valid object's address, that's probably near impossible to diagnose.</p>\n", "LastActivityDate": "2015-02-26T14:38:51.213", "CommentCount": "0", "CreationDate": "2015-02-26T14:38:51.213", "ParentId": "28727439", "Score": "1", "OwnerUserId": "572743"}});