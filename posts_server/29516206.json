post_cb({"29517162": {"ParentId": "29516206", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Well, STL classes have not been designed to be inherited. The major issue with inheriting <code>std::string</code> and others is that they don't have a virtual destructor. That's a big no-no for a base class of public inheritance, as the warning makes clear. It's not nearly as dangerous for private inheritance, though.</p>\n<p>There's a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22395\" rel=\"nofollow\">bug report</a> for  not issuing an error in the case of privately inheriting a base class that has nonvirtual destructor. It hasn't been marked fixed, however my test shows that no warning is issued in <a href=\"http://coliru.stacked-crooked.com/a/70db9cd1248af08e\" rel=\"nofollow\">g++ 4.9.2</a> with private inheritance.</p>\n<p>Also, a comment in the bug shows how to shoot yourself the foot with (intentionally?) bad code:</p>\n<pre><code>class Foo {\npublic:\n    ~Foo() {}\n    virtual void f() { }\n};\n\nclass Bar : private Foo {\npublic:\n    Foo* get() { return this; }\n};\n\nint main()\n{\n    Bar* b = new Bar;\n    delete b-&gt;get();\n}\n</code></pre>\n<p>Privately inheriting a class with nonvirtual destructor is not bad as such if you avoid exposing the inheritance relationship outside the class like in the snippet above. Without going into detail of how you're going to use the inheritance, it's not possible to say if that's the best approach.</p>\n<blockquote>\n<p id=\"so_29516206_29517162_0\">Doesn't std::string derive from it?</p>\n</blockquote>\n<p>No, <code>std::string</code> is an alias of <code>std::basic_string&lt;char&gt;</code>.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2015-04-08T14:23:09.107", "Id": "29517162", "Score": "1", "CreationDate": "2015-04-08T14:12:37.337", "LastActivityDate": "2015-04-08T14:23:09.107"}, "29516206": {"CommentCount": "7", "AcceptedAnswerId": "29517162", "ClosedDate": "2015-04-09T01:10:41.273", "CreationDate": "2015-04-08T13:35:34.710", "LastActivityDate": "2015-04-08T14:23:09.107", "PostTypeId": "1", "ViewCount": "486", "Title": "Is inheriting from std::basic_string ok?", "Id": "29516206", "Score": "1", "Body": "<p>I've read a number of similar questions here but I'm still uncertain of the answer. I understand that deriving from STL classes is discouraged but std::basic_string seems like a good candidate.</p>\n<p>The problem I face is that g++ is throwing a fit because std::basic_string does not have a virtual destructor. Why isn't it virtual? Doesn't std::string derive from it?</p>\n<p>One attempt:</p>\n<pre><code>class string_t :\n  private std::basic_string&lt;char&gt;\n{\npublic:\n   string_t() :\n      basic_string&lt;value_type&gt;() {}\n\n   string_t(\n      const basic_string&lt;value_type&gt;&amp; s) :\n         basic_string&lt;value_type&gt;(s) {}\n\n   virtual ~string_t() {}\n};\n</code></pre>\n<p>Another attempt:</p>\n<pre><code>class string_t :\n   public std::basic_string&lt;char&gt;\n{\npublic:\n   virtual ~string_t();\n};\n</code></pre>\n<p>Both throw this warning when compiling with -Weffc++:</p>\n<blockquote>\n<p id=\"so_29516206_29516206_0\">warning: base class 'class std::basic_string' has a non-virtual\n  destructor</p>\n</blockquote>\n", "Tags": "<c++><inheritance><stl><g++>", "OwnerUserId": "1762276", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29516206_29516206_0": {"section_id": 238, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_29516206_29516206_0": {"section_id": 230, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_29516206_29516206_0": {"section_id": 242, "quality": 0.5714285714285714, "length": 4}}}});