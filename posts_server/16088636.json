post_cb({"16088636": {"CommentCount": "0", "AcceptedAnswerId": "16088781", "ClosedDate": "2013-04-19T13:13:00.570", "CreationDate": "2013-04-18T16:41:18.303", "LastActivityDate": "2013-04-18T16:56:59.040", "PostTypeId": "1", "ViewCount": "3844", "FavoriteCount": "0", "Title": "User-defined implicit conversion operator and overload resolution", "Id": "16088636", "Score": "2", "Body": "<p>Today I experienced an interesting behaviour with user-defined implicit conversion operators.</p>\n<p>Let's take this piece of code:</p>\n<pre><code>struct Widget {\n    Widget(uint64_t) {\n\n    }\n\n    Widget(const std::string &amp;) {\n\n    }\n\n    operator uint64_t() {\n        return static_cast&lt;uint64_t&gt;(123456789UL);\n    }\n\n    operator std::string() {\n        return std::string(\"Hello\");\n    }\n};\n</code></pre>\n<p>A basic struct which can implicitly be converted to either a uint64_t or a std::string. </p>\n<p>Now, try to print out a Widget instance through std::cout :</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    using std::cout;\n    Widget w(123456);\n\n    cout &lt;&lt; w;\n}\n</code></pre>\n<p>For whatever reason, the Widget will always be converted to a uint64_t. At first I would expect the call to be ambiguous, and be qualifed with a standard explicit conversion to compile :</p>\n<pre><code>int main() {\n    using std::cout;\n    Widget w(123456);\n\n    cout &lt;&lt; static_cast&lt;uint64_t&gt;(w);\n</code></pre>\n<p>}</p>\n<p>But for a reason I'm ignoring right now, operator uint64_t is selected. I tried to look at the C++ specification, but couldn't find anything useful to answer my question.</p>\n<p>Can anyone help me figuring out what is the compiler doing with overload resolution ?</p>\n", "Tags": "<c++>", "OwnerUserId": "1809650", "AnswerCount": "2"}, "16088846": {"ParentId": "16088636", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-04-18T16:51:31.500", "Score": "2", "LastEditorUserId": "952747", "LastEditDate": "2013-04-18T16:56:59.040", "Id": "16088846", "OwnerUserId": "952747", "Body": "<p>Of course you can find it in C++ specification.</p>\n<p>Read <em>Overload Resolution</em> in <code>\u00a713.3.1/2</code> and <code>\u00a713.3.1/3</code></p>\n<blockquote>\n<p id=\"so_16088636_16088846_0\">Overload resolution selects the function to call in seven distinct\n  contexts within the language...</p>\n</blockquote>\n<p>\u00a0</p>\n<blockquote id=\"so_16088636_16088846_1\">\n<ul>\n<li>First, a subset of the candidate functions (those that have the proper number of arguments and meet certain other conditions) is\n  selected to form a set of viable functions (13.3.2).</li>\n<li>Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed to match each argument to the\n  corresponding parameter of each viable function.</li>\n</ul>\n</blockquote>\n<p>\u00a0</p>\n<p>In brief, compiler first lists candidates to use, then tries to find best fit and more efficient overload. </p>\n", "LastActivityDate": "2013-04-18T16:56:59.040"}, "16088781": {"ParentId": "16088636", "CommentCount": "2", "CreationDate": "2013-04-18T16:48:46.417", "OwnerUserId": "6271971", "PostTypeId": "2", "Id": "16088781", "Score": "2", "Body": "<p><code>uint64_t</code> conversion is preferred. The reason is simply that <code>&lt;&lt;</code> is overloaded as template for <code>strings</code> (basic_strings). Compilers will always prefer exact match over templates on overload resolution.</p>\n", "LastActivityDate": "2013-04-18T16:48:46.417"}, "bq_ids": {"n4140": {"so_16088636_16088846_0": {"section_id": 563, "quality": 1.0, "length": 10}, "so_16088636_16088846_1": {"section_id": 563, "quality": 0.9473684210526315, "length": 36}}, "n3337": {"so_16088636_16088846_0": {"section_id": 554, "quality": 1.0, "length": 10}, "so_16088636_16088846_1": {"section_id": 554, "quality": 0.9473684210526315, "length": 36}}, "n4659": {"so_16088636_16088846_0": {"section_id": 586, "quality": 1.0, "length": 10}, "so_16088636_16088846_1": {"section_id": 586, "quality": 0.9473684210526315, "length": 36}}}});