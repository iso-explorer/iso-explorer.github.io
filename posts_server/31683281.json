post_cb({"31683410": {"ParentId": "31683281", "LastEditDate": "2015-07-28T17:44:53.900", "CommentCount": "0", "CreationDate": "2015-07-28T17:36:47.020", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "PostTypeId": "2", "Id": "31683410", "Score": "4", "Body": "<p>According to the C++ Standard (10.3 Virtual functions)</p>\n<blockquote>\n<p id=\"so_31683281_31683410_0\">1 Virtual functions support dynamic binding and object-oriented\n  programming. A class that <strong>declares or inherits a virtual function is\n  called a polymorphic class</strong>.</p>\n</blockquote>\n<p>In the quote you cited there is not required that the classes would be polymorphic that is that they had a virtual function. So including this word would not be correct.</p>\n<p>The quote gives a general definition of the dynamic type irrespective of whether the classes are polymorphic or are not..</p>\n", "LastActivityDate": "2015-07-28T17:44:53.900"}, "31683447": {"ParentId": "31683281", "CommentCount": "7", "Body": "<p>I don't think the definition of \"dynamic type\" needs that qualification. If you look through the rest of the standard, you'll see that when the static and dynamic types are different, that doesn't automatically imply that the expression behaves like the dynamic type. This is specified to <strong>only</strong> happen when the static type is polymorphic. For example, see [expr.typeid]/2-3:</p>\n<blockquote>\n<p id=\"so_31683281_31683447_0\">When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers\n  to a <code>std::type_info</code> object representing the type of the most derived object (1.8) (that is, the dynamic\n  type) to which the glvalue refers. If the glvalue expression is obtained by applying the unary <code>*</code> operator to\n  a pointer and the pointer is a null pointer value (4.10), the <code>typeid</code> expression throws an exception (15.1)\n  of a type that would match a handler of type <code>std::bad_typeid</code> exception (18.7.3).</p>\n<p id=\"so_31683281_31683447_1\">When <code>typeid</code> is applied to an expression other than a glvalue of a polymorphic class type, the result refers\n  to a <code>std::type_info</code> object representing the static type of the expression. Lvalue-to-rvalue (4.1), array-to-\n  pointer (4.2), and function-to-pointer (4.3) conversions are not applied to the expression. If the type of the\n  expression is a class type, the class shall be completely-defined. The expression is an unevaluated operand\n  (Clause 5).</p>\n</blockquote>\n<p>In paragraph 3 you can see that it specifically says \"static type\". That's because the static and dynamic types can still differ, but only the static type matters because it's not polymorphic.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "31683447", "Score": "4", "CreationDate": "2015-07-28T17:39:27.423", "LastActivityDate": "2015-07-28T17:39:27.423"}, "31683477": {"ParentId": "31683281", "CommentCount": "7", "Body": "<p>Firstly, even if we wanted to require polymorphism in this case, it would make more sense to impose that requirement on class <code>B</code>, not <code>D</code> (and as a consequence of that <code>D</code> would become polymophic as well).</p>\n<p>Secondly, the general concept of <em>dynamic type</em> does not in any way rely on polymoprphism.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "31683477", "Score": "4", "CreationDate": "2015-07-28T17:41:30.190", "LastActivityDate": "2015-07-28T17:41:30.190"}, "bq_ids": {"n4140": {"so_31683281_31683281_0": {"section_id": 5768, "quality": 0.7391304347826086, "length": 17}, "so_31683281_31683447_1": {"section_id": 6022, "quality": 0.9166666666666666, "length": 33}, "so_31683281_31683447_0": {"section_id": 6021, "quality": 0.9183673469387755, "length": 45}, "so_31683281_31683410_0": {"section_id": 7002, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_31683281_31683281_0": {"section_id": 5541, "quality": 0.7391304347826086, "length": 17}, "so_31683281_31683447_1": {"section_id": 5790, "quality": 0.9166666666666666, "length": 33}, "so_31683281_31683447_0": {"section_id": 5789, "quality": 0.7959183673469388, "length": 39}, "so_31683281_31683410_0": {"section_id": 6748, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_31683281_31683281_0": {"section_id": 7225, "quality": 0.7391304347826086, "length": 17}, "so_31683281_31683447_1": {"section_id": 7521, "quality": 0.7777777777777778, "length": 28}, "so_31683281_31683410_0": {"section_id": 8499, "quality": 0.9333333333333333, "length": 14}, "so_31683281_31683447_0": {"section_id": 7520, "quality": 0.9183673469387755, "length": 45}}}, "31683281": {"CommentCount": "3", "CreationDate": "2015-07-28T17:28:36.073", "PostTypeId": "1", "AcceptedAnswerId": "31683477", "LastEditorUserId": "1413395", "LastActivityDate": "2015-07-28T17:44:53.900", "LastEditDate": "2015-07-28T17:36:14.487", "ViewCount": "95", "FavoriteCount": "1", "Title": "Isn't the word `polymorphic` missing in \u00a71.3.7 (N4140)?", "Id": "31683281", "Score": "3", "Body": "<p>Isn't the word <code>polymorphic</code> (in parentheses) below, missing in <strong>\u00a71.3.7 dynamic type</strong>?</p>\n<blockquote>\n<p id=\"so_31683281_31683281_0\">[ Example: if a pointer (8.3.1) p whose static type is \u201cpointer to\n  class B\u201d is pointing to an object of a (<code>polymorphic</code>) class D,\n  derived from B (Clause 10), the dynamic type of the expression *p is\n  \u201cD.\u201d References (8.3.2) are treated similarly. \u2014end example ]</p>\n</blockquote>\n", "Tags": "<c++><polymorphism><language-lawyer>", "OwnerUserId": "4470210", "AnswerCount": "3"}});