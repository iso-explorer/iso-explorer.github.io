post_cb({"22808068": {"ParentId": "22808067", "PostTypeId": "2", "CommentCount": "22", "Body": "<p><strong>tl;dr: Yes, it's undefined behavior. No, the compiler doesn't diagnose it.</strong></p>\n<hr>\n<p>In general, the compiler won't (and sometimes can't) diagnose UB. More obvious examples of <code>const</code>-correctness violation are in fact <em>ill-formed</em> and <a href=\"http://coliru.stacked-crooked.com/a/7060bcd008058a72\" rel=\"nofollow\">can be diagnosed</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n   const int x = 0;\n   x = 1;\n   std::cout &lt;&lt; x;\n}\n\n// g++-4.8 -std=c++11 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n// main.cpp: In function 'int main()':\n// main.cpp:6:6: error: assignment of read-only variable 'x'\n//     x = 1;\n//       ^\n</code></pre>\n<p>But, other than that, it <a href=\"http://coliru.stacked-crooked.com/a/e0f69c2e6becee71\" rel=\"nofollow\">won't stop you from performing obvious violations of <code>const</code>-correctness</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    const int x = 0;\n    *const_cast&lt;int*&gt;(&amp;x) = 1;\n    std::cout &lt;&lt; x;\n}\n\n// Output: 1\n</code></pre>\n<p>So, going back to your code snippet, I wouldn't expect too much in the way of compiler diagnostics there.</p>\n<p>Still, your code <em>does</em> invoke undefined behaviour. Let's examine it:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n   int x = 0;\n   const int* px = new (&amp;x) const int(0);\n   x = 1;\n   std::cout &lt;&lt; *px;  // 1?\n}\n</code></pre>\n<p>Here's what happens:</p>\n<ol>\n<li>An <code>int</code> is created with automatic storage duration, initialised to <code>0</code>.</li>\n<li>The name <code>x</code> refers to this object.</li>\n<li>A <code>const int</code> is created with dynamic storage duration, re-using the <code>int</code>'s storage.</li>\n<li>The <code>int</code>'s lifetime ends<sup>1, 2</sup>.</li>\n<li><code>x</code> now refers to the <code>const int</code><sup>3</sup>.</li>\n<li>Although the name <code>x</code> has type <code>int</code>, it's now referring to a <code>const int</code>, so the assignment is undefined<sup>4</sup>.</li>\n</ol>\n<p>This is an interesting loophole you can use to \"get around\" <code>const</code>-correctness and, as long as the original <code>int</code> didn't live in read-only memory, it probably won't even result in a crash.</p>\n<p>However, it's still undefined and although I can't see what optimisations may be performed that could break the assignment and subsequent read, you're definitely open to all sorts of unexpected nastiness, such as spontaneous volcanoes in your back garden or all your hard-earned rep being transformed into Pounds Sterling and deposited in my bank account (thanks!).</p>\n<hr>\n<h3>Footnote 1</h3>\n<blockquote>\n<p id=\"so_22808067_22808068_0\"><code>[C++11: 3.8/1]:</code> <em>[..]</em> <strong>The lifetime of an object of type <code>T</code> ends when:</strong></p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li><strong>the storage which the object occupies is reused or released.</strong> </li>\n</ul>\n</blockquote>\n<h3>Footnote 2</h3>\n<p>Note that I did not have to explicitly call the \"destructor\" on the <code>int</code> object. This is mostly because such objects do not <em>have</em> a destructor, but even if I'd picked a simple class <code>T</code> rather than <code>int</code>, I may not have needed an explicit destructor call:</p>\n<blockquote>\n<p id=\"so_22808067_22808068_1\"><code>[C++11: 3.8/4]:</code> A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. <strong>For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused</strong> or released; <strong>however, if there is no explicit call to the destructor</strong> or if a delete-expression (5.3.5) is not used to release the storage, <strong>the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</strong></p>\n</blockquote>\n<h3>Footnote 3</h3>\n<blockquote>\n<p id=\"so_22808067_22808068_2\"><code>[C++11: 3.8/7]:</code> <strong>If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied,</strong> a pointer that pointed to the original object, a reference that referred to the original object, or <strong>the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if</strong>:</p>\n<ul>\n<li><strong>the storage for the new object exactly overlays the storage location which the original object occupied, and</strong></li>\n<li><strong>the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</strong></li>\n<li><strong>the type of the original object is not const-qualified</strong>, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and</li>\n<li>the original object was a most derived object (1.8) of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects). <em>[..]</em></li>\n</ul>\n</blockquote>\n<h3>Footnote 4</h3>\n<blockquote>\n<p id=\"so_22808067_22808068_3\"><code>[C++11: 7.1.6.1/4]:</code> Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a <code>const</code> object during its lifetime (3.8) results in undefined behavior. <em>[..]</em></p>\n</blockquote>\n<p><em>(Examples follow that are similar to, but not quite the same as, your code snippet.)</em></p>\n</hr></hr>", "OwnerUserId": "560648", "LastEditorUserId": "1370927", "LastEditDate": "2014-04-14T02:23:43.627", "Id": "22808068", "Score": "6", "CreationDate": "2014-04-02T10:08:11.853", "LastActivityDate": "2014-04-14T02:23:43.627"}, "bq_ids": {"n4140": {"so_22808067_22808068_0": {"section_id": 7189, "quality": 0.625, "length": 5}, "so_22808067_22808068_1": {"section_id": 7192, "quality": 0.9245283018867925, "length": 49}, "so_22808067_22808068_2": {"section_id": 7195, "quality": 0.9555555555555556, "length": 43}, "so_22808067_22808068_3": {"section_id": 5433, "quality": 0.85, "length": 17}}, "n3337": {"so_22808067_22808068_0": {"section_id": 6933, "quality": 0.625, "length": 5}, "so_22808067_22808068_1": {"section_id": 6936, "quality": 0.9245283018867925, "length": 49}, "so_22808067_22808068_2": {"section_id": 6939, "quality": 0.9555555555555556, "length": 43}, "so_22808067_22808068_3": {"section_id": 5228, "quality": 0.85, "length": 17}}, "n4659": {"so_22808067_22808068_0": {"section_id": 8697, "quality": 0.625, "length": 5}, "so_22808067_22808068_1": {"section_id": 8701, "quality": 0.9245283018867925, "length": 49}, "so_22808067_22808068_2": {"section_id": 8704, "quality": 0.9555555555555556, "length": 43}, "so_22808067_22808068_3": {"section_id": 6861, "quality": 0.85, "length": 17}}}, "22808067": {"CommentCount": "4", "AcceptedAnswerId": "22808068", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-04-02T10:08:11.853", "LastActivityDate": "2014-04-14T02:23:43.627", "LastEditDate": "2017-05-23T12:24:57.837", "ViewCount": "229", "FavoriteCount": "3", "Title": "Is it legal to modify a dynamically-allocated `const` object through a re-used non-`const` name?", "Id": "22808067", "Score": "7", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n   int x = 0;\n   const int* px = new (&amp;x) const int(0);\n   x = 1;\n   std::cout &lt;&lt; *px;  // 1?\n}\n</code></pre>\n<p>It <a href=\"http://coliru.stacked-crooked.com/a/d49f7eaf53e248ee\" rel=\"nofollow noreferrer\">compiles under GCC 4.8</a> (and produces the \"expected\" output), but I suspect it's entirely UB because the dynamic object has type <code>const int</code> (<a href=\"https://stackoverflow.com/q/22798558/560648\">which remains part of the type</a>). But, then, if so why isn't the compiler stopping me from violating <code>const</code>-correctness?</p>\n", "Tags": "<c++><c++11><const><language-lawyer><const-correctness>", "OwnerUserId": "560648", "AnswerCount": "1"}});