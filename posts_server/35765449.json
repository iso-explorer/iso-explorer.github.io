post_cb({"35765661": {"ParentId": "35765449", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_35765449_35765661_0\">Why does char* refer to strings?</p>\n</blockquote>\n<p>Well, it doesn't.  It is just a convention; in C it is idiomatic to consider a string (as in a piece of twine) of characters that ends with a NUL character (<code>'\\0'</code>) as a string.  You can have it point to a single character too.</p>\n<pre><code>char c = 'a';\nchar *p = &amp;c;\n</code></pre>\n<p>One of the constructors of <code>std::string</code> takes <code>char*</code> as an argument, hence the implicit conversion makes you think they are interchangeable, but they are not.</p>\n<blockquote>\n<p id=\"so_35765449_35765661_1\">why doesn't it come off as string* + string*?</p>\n</blockquote>\n<p>In the sub-expression <code>\"Testing\" + \" new\"</code>, it needs to implicitly convert both character arrays to <code>std::string</code> to perform what you want, while <code>\" new\" + func</code> works as you expect since one of them is already a <code>std::string</code> the other is converted, since <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%2B\" rel=\"nofollow noreferrer\">we have an <code>operator+</code> function</a> that takes a <code>char*</code> (to which the character <a href=\"https://stackoverflow.com/q/1461432/183120\">array decay</a>s into) and <code>std::string</code>. While there's no operator function or a rule in the language which talks about two <code>char</code> arrays.</p>\n<blockquote>\n<p id=\"so_35765449_35765661_2\">Why bother to concatenate the strings at all when you can just make a singular string?</p>\n</blockquote>\n<p>If the <code>error</code> function is just what you have shown it to be, then yes, having it take a single <code>std::string</code> makes more sense.</p>\n", "OwnerUserId": "183120", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:07:49.347", "Id": "35765661", "Score": "3", "CreationDate": "2016-03-03T07:23:29.280", "LastActivityDate": "2016-03-03T09:18:38.157"}, "35765449": {"CommentCount": "3", "ViewCount": "98", "CreationDate": "2016-03-03T07:12:52.537", "LastActivityDate": "2016-03-03T09:18:38.157", "Title": "Why does char* refer to strings?", "AcceptedAnswerId": "35765500", "PostTypeId": "1", "Id": "35765449", "Score": "-1", "Body": "<p>I was reading on errors, where it said that it's common to use concatenation of strings to describe a process, example: </p>\n<pre><code>void error(string s1, string s2)\n{\nthrow runtime_error(s1+s2);\n}\n</code></pre>\n<p>This led me to play around with just adding strings together, where I found an error in my code and discovered pointers: </p>\n<pre><code>int main()\n{\n    string func = \"function\";\n    string mesg = \"Testing\" + \" new\" + func;\n    cout &lt;&lt; mesg;\n}\n</code></pre>\n<p>I looked up the error and a few sources said that \"Testing\" + \" new\" was being seen as char* + char* which can't just be added together. My main question is, why doesn't it come off as string* + string*? A minor question I had also, is about the error() function. Why bother to concatenate the strings at all when you can just make a singular string? </p>\n", "Tags": "<c++><string>", "OwnerUserId": "5844452", "AnswerCount": "3"}, "35765570": {"ParentId": "35765449", "CommentCount": "1", "Body": "<p>The <code>char*</code> data type is a carry-over from plain C in which a \"string\" is conventionally expressed as a character array in which the end is the <code>nul</code> character (value zero in ASCII). </p>\n<p>What you have written is <em>not</em> additions of two <code>char*</code> variables but instead calling <code>operator+</code> to concatenate two instances of <code>string</code> objects.</p>\n<p>C++ has a way to re-define built-in operators to work with class instances. This is called <em>operator overloading</em>. One common use is for string classes (plural since there are a few known common implementations of <em>string</em> in C++) to define <code>operator+</code> to concatenate strings together.</p>\n", "OwnerUserId": "199360", "PostTypeId": "2", "Id": "35765570", "Score": "0", "CreationDate": "2016-03-03T07:18:41.573", "LastActivityDate": "2016-03-03T07:18:41.573"}, "bq_ids": {"n4140": {"so_35765449_35765500_0": {"section_id": 7229, "quality": 0.5555555555555556, "length": 5}, "so_35765449_35765500_1": {"section_id": 6106, "quality": 0.6666666666666666, "length": 4}, "so_35765449_35765500_2": {"section_id": 5356, "quality": 1.0, "length": 7}}, "n3337": {"so_35765449_35765500_1": {"section_id": 5872, "quality": 0.6666666666666666, "length": 4}, "so_35765449_35765500_2": {"section_id": 5153, "quality": 1.0, "length": 7}}, "n4659": {"so_35765449_35765500_0": {"section_id": 8740, "quality": 0.5555555555555556, "length": 5}, "so_35765449_35765500_1": {"section_id": 7603, "quality": 0.6666666666666666, "length": 4}, "so_35765449_35765500_2": {"section_id": 6781, "quality": 1.0, "length": 7}}}, "35765500": {"ParentId": "35765449", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The behavior in C++ is inherited from its C roots, and both in C and C++ a literal string is actually an <em>array</em> of <code>char</code>, and as all arrays it decays to a pointer to the first element, which in the case of an array of (read-only) characters will be <code>char const*</code>.</p>\n<hr>\n<p>The <code>const</code> part is important when dealing with string literals, as all string literals are read-only.</p>\n<p>If you define an explicit array, like</p>\n<pre><code>char my_string[] = \"foobar\";\n</code></pre>\n<p>then it's not read-only and so decays to a pointer to <code>char</code>, i.e. <code>char*</code>.</p>\n<hr>\n<p>As noted by DevSolar, in C string literals are actually plain arrays of <code>char</code> so they decay to <code>char*</code>. However, they are still <em>read-only</em> so using e.g. <code>const char *</code> is still a good idea when dealing with string literals.</p>\n<p>References for the C behavior: The C11 standard \u00a76.4.5/6 says</p>\n<blockquote>\n<p id=\"so_35765449_35765500_0\">For character string literals, the array elements have type <code>char</code></p>\n</blockquote>\n<p>and in /7 it says:</p>\n<blockquote>\n<p id=\"so_35765449_35765500_1\">If the program attempts to modify such an array, the behavior is undefined.</p>\n</blockquote>\n<p>For C++ (C++11 more specifically as that's the only one I have) the relevant part is \u00a72.14.5 [lex.string], where /8 says</p>\n<blockquote>\n<p id=\"so_35765449_35765500_2\">A narrow string literal has type \u201carray of <em>n</em> <code>const char</code>\u201d</p>\n</blockquote>\n</hr></hr>", "OwnerUserId": "440558", "LastEditorUserId": "440558", "LastEditDate": "2016-03-03T07:45:51.497", "Id": "35765500", "Score": "4", "CreationDate": "2016-03-03T07:15:34.453", "LastActivityDate": "2016-03-03T07:45:51.497"}});