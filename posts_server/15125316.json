post_cb({"bq_ids": {"n4140": {"so_15125316_15125401_2": {"section_id": 269, "quality": 0.9782608695652174, "length": 45}, "so_15125316_15125401_1": {"section_id": 268, "quality": 1.0, "length": 59}}, "n3337": {"so_15125316_15125401_2": {"section_id": 260, "quality": 0.9782608695652174, "length": 45}, "so_15125316_15125401_1": {"section_id": 259, "quality": 1.0, "length": 59}}, "n4659": {"so_15125316_15125401_2": {"section_id": 276, "quality": 0.9782608695652174, "length": 45}, "so_15125316_15125401_1": {"section_id": 275, "quality": 1.0, "length": 59}}}, "15125316": {"CommentCount": "2", "ViewCount": "178", "CreationDate": "2013-02-28T00:31:07.417", "LastActivityDate": "2013-02-28T00:47:41.437", "Title": "do all compilers ignore generated template code when explicit specializations are available to the linker?", "AcceptedAnswerId": "15125401", "PostTypeId": "1", "Id": "15125316", "Score": "6", "Body": "<p>I've recently run into a situation while specializing templates that has made me uneasy:</p>\n<p>foo.h:</p>\n<pre><code>template &lt;class T&gt;\nvoid foo() {\n  std::cout &lt;&lt; \"This is the generic foo\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>foo.cc:</p>\n<pre><code>#include \"foo.h\"\ntemplate &lt;&gt;\nvoid foo&lt;int&gt;() {\n  std::cout &lt;&lt; \"This is foo&lt;int&gt;\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>main.cc:</p>\n<pre><code>#include \"foo.h\"\n\nint main() {\n  foo&lt;int&gt;();\n}\n</code></pre>\n<p>So. I compile as follows:</p>\n<pre><code>g++ -c main.cc\ng++ -c foo.cc\ng++ -o main main.o foo.o\n</code></pre>\n<p>The output is <code>\"This is foo&lt;int&gt;\"</code>. I like this output. But I'm worried that what I'm observing might be unique to gcc (I don't have access to other compilers so I can't check).</p>\n<p>Here's what I think gcc is doing: When main.cc is compiled, I would expect it to emit the generic code for the foo call because it is not aware of the specialization in foo.cc. But by linking with foo.o, it uses the specialization instead because it has the same signature.</p>\n<p>But is this bad to count on? I'm worried that other compilers (or maybe even different versions of gcc?) might mangle their signatures when they emit template code, in a way that linking with foo.o will not replace the generic action like I want it to. Is this a valid worry? I've read a lot of things that make me feel uneasy, but nothing that makes me feel confident about what is happening in my current situation.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "2117521", "AnswerCount": "1"}, "15125401": {"ParentId": "15125316", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_15125316_15125401_0\">I'm worried that what I'm observing might be unique to gcc (I don't have access to other compilers so I can't check).</p>\n</blockquote>\n<p>You have good reasons to be worried: Your program is ill-formed, and the compiler is not even required to tell you! </p>\n<p>Paragraph 14.7.3/6 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_15125316_15125401_1\">If a template, a member template or a member of a class template is explicitly specialized then <strong>that specialization\n  shall be declared before the first use of that specialization that would cause an implicit instantiation\n  to take place, in every translation unit in which such a use occurs; no diagnostic is required.</strong> If the program\n  does not provide a definition for an explicit specialization and either the specialization is used in a way\n  that would cause an implicit instantiation to take place or the member is a virtual member function, <strong>the\n  program is ill-formed, no diagnostic required</strong>. An implicit instantiation is never generated for an explicit\n  specialization that is declared but not defined</p>\n</blockquote>\n<p>Your specialization must be visible from the point of instantiation in order for the program to have consistent behavior. In your case, it isn't: you are relegating it in a file which is not included by other translation units.</p>\n<p>Paragraph 14.7.3/7 Standard is quite explicit about what happens when you fail to do this:</p>\n<blockquote>\n<p id=\"so_15125316_15125401_2\"><strong>The placement of explicit specialization declarations for function templates</strong>, class templates, member functions\n  of class templates, [...], can affect whether a program is\n  well-formed according to the relative positioning of the explicit specialization declarations and their points of\n  instantiation in the translation unit as specified above and below. <strong>When writing a specialization, be careful\n  about its location; or to make it compile will be such a trial as to kindle its self-immolation.</strong></p>\n</blockquote>\n<p>I guess the last sentence makes it clear.</p>\n<p>Here, what you should do is to declare your intention to introduce an explicit specialization of your function template <em>before</em> any implicit instantiation of the primary template would occur. To do so, do the following:</p>\n<p><strong>foo.h</strong></p>\n<pre><code>template &lt;class T&gt;\nvoid foo() {\n   std::cout &lt;&lt; \"This is the generic foo\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;&gt; void foo&lt;int&gt;(); // Introduce a declaration of your\n                             // explicit specialization right\n                             // after you defined the primary\n                             // template!\n</code></pre>\n<p>By introducing a declaration right after the definition of the primary template, you make sure that wherever the primary template is visible, it will be known that a full specialization for it exists, saving you from self-immolation.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-02-28T00:47:41.437", "Id": "15125401", "Score": "8", "CreationDate": "2013-02-28T00:40:11.993", "LastActivityDate": "2013-02-28T00:47:41.437"}});