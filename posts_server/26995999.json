post_cb({"26995999": {"ViewCount": "100", "Body": "<p>I have Iterator template for class and class for use in the for statement.</p>\n<pre><code>template&lt;class T&gt;\nclass Itr2 {\npublic:\n     Itr2()  { }\n    ~Itr2()  { }\n\n    typedef typename Itr2 type;\n    typedef typename T&amp; reference;\n\n    virtual type&amp; operator++()                      { return *this; }\n    virtual T&amp;    operator*()                       { return ((reference)*((type*)this)); }\n    virtual bool  operator==(const type&amp; o) const { return true; }\n    virtual bool  operator!=(const type&amp; o) const { return false; }\n};\n\n\ntemplate&lt;class T&gt;\nclass I2\n{\npublic:\n    typedef I2&lt;T&gt; type;\n    typedef T     value;\n    typedef T&amp; reference;\n    typedef typename Itr2&lt;T&gt; iterator;\n\n    virtual iterator&amp; begin() { return *(new iterator()); }\n    virtual iterator&amp; end()   { return *(new iterator()); }\n};\n</code></pre>\n<p>Next, I created class for standard std::vector&lt;&gt;.</p>\n<pre><code>template&lt;class T&gt;\nclass ItrSTD : public Itr2&lt;T&gt; {\npublic:\n    typedef typename Itr2&lt;T&gt; base_type;\n    typedef typename ItrSTD&lt;T&gt; type;\n    typedef typename T&amp; reference;\n    typedef typename std::vector&lt;T&gt;::iterator std_itr;\nprotected:\n    std_itr itr_;\npublic:\n    ItrSTD(const type&amp; o)                               { itr_ = o.itr_; }\n    ItrSTD(const std_itr&amp; o)                            { itr_ = o; }\n\n    virtual base_type&amp;  operator++()                    { itr_++; return *this; }\n\n    virtual T&amp;          operator*()                     { return ((reference)(*this-&gt;itr_)); }\n    bool  operator==(const base_type&amp; o) const override { return (((const type&amp;)o).itr_ == this-&gt;itr_); }\n    bool  operator!=(const base_type&amp; o) const override { return (((const type&amp;)o).itr_ != this-&gt;itr_); }\n};\n\n\n\ntemplate&lt;class T&gt;\nclass VSTD : public I2&lt;T&gt; {\nprotected:\n    std::vector&lt;T&gt;  arr_;\npublic:\n    typedef typename ItrSTD&lt;T&gt;  iterator;\n\n    VSTD(const VSTD&amp; o)  { arr_ = o.arr_; }\n    template&lt;typename ...E&gt; VSTD(E&amp;&amp;...e) : arr_({ std::forward&lt;T&gt;(e)... }) {  }\n\n    iterator&amp; begin()  _NOEXCEPT  override{ return (*new iterator(arr_.begin())); }\n    iterator&amp; end()    _NOEXCEPT  override{ return (*new iterator(arr_.end())); }\n\n};\n</code></pre>\n<p>If i use direct statement for(int i:v). It is works fine, but when I try to do this from the pointer compiler use base class operator!= (not override operator!=) and code doesn't work :(.</p>\n<pre><code>int v_i = 0;\nVSTD&lt;int&gt; vstd_a = { 1, 2, 3 };\nI2&lt;int&gt; *i2 = &amp;vstd_a;\n\nfor (int j : *i2) //DOESN't work :( use operator!= from base class\n{\nv_i += j;\n}\nfor (int j : vstd_a) //work fine :)  use operator!= from VSTD.\n{\n v_i += j;\n}\n</code></pre>\n<p>If i simplify the code:</p>\n<pre><code>template&lt;typename T&gt;\nclass I3\n{\npublic:\n    T i;\n    virtual bool  operator==(const I3&amp; o) const { return false; }\n};\n\ntemplate&lt;typename T&gt;\nclass I3O : public I3&lt;T&gt;\n{\npublic:\n    virtual bool  operator==(const I3&amp; o) const override { return true; }\n};\n\nI3O&lt;int&gt; i3_a, i3_b; I3&lt;int&gt; *i3_ap, *i3_bp;\n\ni3_ap = &amp;i3_a; i3_bp = &amp;i3_b; bool i3_c;\n\ni3_c = (i3_a == i3_b);\ni3_c = ((*i3_ap) == (*i3_bp));\n</code></pre>\n<p>Both result are fine (return true) and compare from override class (only for( : ) work bad  :( :</p>\n<p>Why this happen. It is possible to use for statement for template pointer ?\nbegin(), end() functions works fine. Only operator work different. </p>\n<p>P.S. I use VS2013 compiler.</p>\n", "AcceptedAnswerId": "26998804", "Title": "Why pointer from override class use operator== and operator!= from base class", "CreationDate": "2014-11-18T13:51:47.183", "Id": "26995999", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-11-18T16:12:08.487", "Score": "0", "OwnerUserId": "4265816", "Tags": "<c++><pointers><c++11><visual-studio-2013><iterator>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26995999_26998804_6": {"length": 24, "quality": 0.9230769230769231, "section_id": 3906}, "so_26995999_26998804_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3906}, "so_26995999_26998804_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 3906}, "so_26995999_26998804_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 3906}}, "n3337": {"so_26995999_26998804_6": {"length": 24, "quality": 0.9230769230769231, "section_id": 3766}, "so_26995999_26998804_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 3766}, "so_26995999_26998804_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3766}, "so_26995999_26998804_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 3766}}, "n4659": {"so_26995999_26998804_6": {"length": 20, "quality": 0.7692307692307693, "section_id": 4792}, "so_26995999_26998804_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 4792}, "so_26995999_26998804_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4792}}}, "26996433": {"Id": "26996433", "PostTypeId": "2", "Body": "<p>I've not looked at the details in your code, but...  It looks like\nyou're trying to make the iterators polymorphic.  The standard\nconstantly passes them by value, however, and pass by value doesn't\nsupport polymorphism; it slices.  Thus (I assume), in:</p>\n<pre><code>for ( int j : *i2 )\n</code></pre>\n<p>the compiler creates local variables for the iterator, whose type is\ndetermined <em>statically</em>.  And although it calls the correct <code>begin()</code>,\nit assigns the results to this local variable, thus slicing it.</p>\n<p>If you need polymorphic iterators, you need to implement the\nletter/envelope idiom:</p>\n<pre><code>class Iterator\n{\n    Iterator* myImpl;\n\n    virtual Iterator* clone() const { abort(); }\n    virtual T&amp; current() const { abort(); }\n    virtual bool isEqual( Iterator const* other ) { abort(); }\n    virtual void next() { abort(); }\n\nprotected:\n    Iterator() : myImpl( nullptr ) {}\npublic:\n    Iterator( Iterator* impl ) : myImpl( impl ) {}\n    Iterator( Iterator const&amp; other ) : myImpl( other.clone() ) {}\n    virtual ~Iterator() { delete myImpl; }\n\n    T&amp; operator*() const\n    {\n        return myImpl-&gt;current();\n    }\n    bool operator==( Iterator const&amp; other ) const\n    {\n        return myImpl-&gt;isEqual( other.myImpl );\n    }\n    Iterator&amp; operator++()\n    {\n        myImpl-&gt;next();\n        return *this;\n    }\n    //  ...\n};\n\nclass DerivedIterator : public Iterator\n{\n    Iterator* clone() const override { return new DerivedIterator( *this );  }\n    T&amp; current() const override { ... }\n    bool isEqual( Iterator const* other ) override { ... }\n    virtual void next() { ... }\npublic:\n    DerivedIterator(...) ...\n};\n</code></pre>\n<p>Then, your derived <code>begin</code> and <code>end</code> return something like:</p>\n<pre><code>Iterator( new DerivedIterator(...) );\n</code></pre>\n<p>This is fairly expensive in run-time, but it's really the only way to\nprovide polymorphism and still have the value semantics required by\niterators.</p>\n", "LastActivityDate": "2014-11-18T14:15:13.540", "CommentCount": "0", "CreationDate": "2014-11-18T14:15:13.540", "ParentId": "26995999", "Score": "4", "OwnerUserId": "649665"}, "26998804": {"Id": "26998804", "PostTypeId": "2", "Body": "<p>The standard defines the semantics of the range-based for statement in [stmt.ranged]/1:</p>\n<blockquote>\n<p id=\"so_26995999_26998804_0\">For a range-based <code>for</code> statement of the form</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n</code></pre>\n<p id=\"so_26995999_26998804_1\">let <em>range-init</em> be equivalent to the <em>expression</em> surrounded by parentheses</p>\n<pre><code>( expression )\n</code></pre>\n<p id=\"so_26995999_26998804_2\">and for a range-based <code>for</code> statement of the form</p>\n<pre><code>for ( for-range-declaration : braced-init-list ) statement\n</code></pre>\n<p id=\"so_26995999_26998804_3\">let <em>range-init</em> be equivalent to the <em>braced-init-list</em>. In each case, a range-based <code>for</code> statement is equivalent to</p>\n<pre><code>{\n  auto &amp;&amp; __range = range-init;\n  for ( auto __begin = begin-expr,\n             __end = end-expr;\n        __begin != __end;\n        ++__begin ) {\n    for-range-declaration = *__begin;\n    statement\n  }\n}\n</code></pre>\n<p id=\"so_26995999_26998804_4\">where <code>__range</code>, <code>__begin</code>, and <code>__end</code> are variables defined for exposition only, and <code>_RangeT</code> is the type of the expression, and <em>begin-expr</em> and <em>end-expr</em> are determined as follows:</p>\n<p id=\"so_26995999_26998804_5\">(1.1) \u2014 if <code>_RangeT</code> is an array type, ...</p>\n<p id=\"so_26995999_26998804_6\">(1.2) \u2014 if <code>_RangeT</code> is a class type, the unqualified-ids <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, <em>begin-expr</em> and <em>end-expr</em> are <code>__range.begin()</code> and <code>__range.end()</code>, respectively;</p>\n<p id=\"so_26995999_26998804_7\">(1.3) \u2014 otherwise, ...</p>\n</blockquote>\n<p>The first loop in your program:</p>\n<pre><code>for (int j : *i2) //DOESN't work :( use operator!= from base class\n{\nv_i += j;\n}\n</code></pre>\n<p>is thus equivalent to:</p>\n<pre><code>{\n  auto &amp;&amp; __range = (*i2);\n  for ( auto __begin = __range.begin(),\n             __end = __range.end();\n        __begin != __end;\n        ++__begin ) {\n    int j = *__begin;\n    v_i += j;\n  }\n}\n</code></pre>\n<p>Since the return type of <code>I2&lt;int&gt;::begin</code> and <code>I2&lt;int&gt;::end</code> is <code>Itr2&lt;int&gt;&amp;</code>, <code>__begin</code> and <code>__end</code> will be deduced as type <code>Itr2&lt;int&gt;</code>, and copy constructed from the return values of <code>I2&lt;int&gt;::begin()</code> and <code>I2&lt;int&gt;::end()</code>. That copy construction of course slices the returned types, and you end up with instances of the base type.</p>\n", "LastActivityDate": "2014-11-18T16:12:08.487", "CommentCount": "1", "CreationDate": "2014-11-18T16:12:08.487", "ParentId": "26995999", "Score": "1", "OwnerUserId": "923854"}});