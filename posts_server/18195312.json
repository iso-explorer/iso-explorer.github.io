post_cb({"bq_ids": {"n4140": {"so_18195312_18195408_5": {"length": 37, "quality": 1.0, "section_id": 24}, "so_18195312_18195408_3": {"length": 13, "quality": 1.0, "section_id": 5937}, "so_18195312_18195408_9": {"length": 42, "quality": 0.7924528301886793, "section_id": 5467}, "so_18195312_18195408_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_18195312_18195408_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 6036}, "so_18195312_18195408_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5466}, "so_18195312_18195408_4": {"length": 8, "quality": 0.7272727272727273, "section_id": 3890}, "so_18195312_18195408_7": {"length": 37, "quality": 1.0, "section_id": 3893}}, "n3337": {"so_18195312_18195408_5": {"length": 37, "quality": 1.0, "section_id": 21}, "so_18195312_18195408_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 3750}, "so_18195312_18195408_9": {"length": 42, "quality": 0.7924528301886793, "section_id": 5253}, "so_18195312_18195408_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}, "so_18195312_18195408_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 5804}, "so_18195312_18195408_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 5252}, "so_18195312_18195408_3": {"length": 13, "quality": 1.0, "section_id": 5709}, "so_18195312_18195408_7": {"length": 37, "quality": 1.0, "section_id": 3753}}, "n4659": {"so_18195312_18195408_5": {"length": 37, "quality": 1.0, "section_id": 24}, "so_18195312_18195408_3": {"length": 13, "quality": 1.0, "section_id": 7421}, "so_18195312_18195408_9": {"length": 42, "quality": 0.7924528301886793, "section_id": 6901}, "so_18195312_18195408_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}, "so_18195312_18195408_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 7535}, "so_18195312_18195408_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6900}, "so_18195312_18195408_4": {"length": 8, "quality": 0.7272727272727273, "section_id": 4776}, "so_18195312_18195408_7": {"length": 37, "quality": 1.0, "section_id": 4779}}}, "18195408": {"Body": "<blockquote>\n<p id=\"so_18195312_18195408_0\">What is color set to according to the standard?</p>\n</blockquote>\n<p>Answering with a quote from the Standard:</p>\n<p>[expr.static.cast]/10</p>\n<blockquote>\n<p id=\"so_18195312_18195408_1\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting value is unspecified (and might not be in that range).</p>\n</blockquote>\n<p>Let's look up the <em>range of the enumeration values</em>: [dcl.enum]/7</p>\n<blockquote>\n<p id=\"so_18195312_18195408_2\">For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the underlying type.</p>\n</blockquote>\n<p><strong>Before CWG 1766</strong>\nTherefore, for <code>data[0] == 100</code>, the resulting value is specified(*), and no <a href=\"https://stackoverflow.com/q/2766731/420683\">Undefined Behaviour (UB)</a> is involved. More generally, as you cast from the underlying type to the enumeration type, no value in <code>data[0]</code> can lead to UB for the <code>static_cast</code>.</p>\n<p><strong>After CWG 1766</strong>\nSee <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1766\" rel=\"noreferrer\">CWG defect 1766</a>.\nThe [expr.static.cast]p10 paragraph has been strengthened, so you now <strong>do</strong> invoke UB if you cast a value that is outside the representable range of an enum to the enum type.</p>\n<p><sub>(*) <code>char</code> is required to be at least 8 bit wide, but isn't required to be <code>unsigned</code>. The maximum value storable is required to be at least <code>127</code> per Annex E of the C99 Standard.</sub></p>\n<hr>\n<p>Compare to [expr]/4</p>\n<blockquote>\n<p id=\"so_18195312_18195408_3\">If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p>\n</blockquote>\n<p>So this <em>could</em> easily lead to UB if the value was big enough, e.g. <code>static_cast&lt;Color&gt;(10000);</code>.</p>\n<hr>\n<p>Now, the <code>switch</code> statement:</p>\n<p>[stmt.switch]/2</p>\n<blockquote>\n<p id=\"so_18195312_18195408_4\">The condition shall be of integral type, enumeration type, or class type. [...] <strong>Integral promotions are performed.</strong></p>\n</blockquote>\n<p>[conv.prom]/4</p>\n<blockquote>\n<p id=\"so_18195312_18195408_5\">A prvalue of an <strong>unscoped</strong> enumeration type whose underlying type is fixed (7.2) can be converted to a prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue of the promoted underlying type.</p>\n</blockquote>\n<p><sub>Note: The underlying type of a scoped enum w/o <em>enum-base</em> is <code>int</code>. For unscoped enums the underlying type is implementation-defined, but shall not be larger than <code>int</code> if <code>int</code> can contain the values of all enumerators.</sub></p>\n<p>For an <strong>unscoped enumeration</strong>, this leads us to /1</p>\n<blockquote>\n<p id=\"so_18195312_18195408_6\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion rank (4.13) is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned int</code>.</p>\n</blockquote>\n<p>In the case of an <strong>unscoped</strong> enumeration, we would be dealing with <code>int</code>s here. For <strong>scoped</strong> enumerations (<code>enum class</code> and <code>enum struct</code>), no integral promotion applies. In any way, the integral promotion doesn't lead to UB either, as the stored value is in the range of the underlying type and in the range of <code>int</code>.</p>\n<p>[stmt.switch]/5</p>\n<blockquote>\n<p id=\"so_18195312_18195408_7\">When the <code>switch</code> statement is executed, its condition is evaluated and compared with each case constant. If one of the case constants is equal to the value of the condition, control is passed to the statement following the matched <code>case</code> label. If no <code>case</code> constant matches the condition, and if there is a <code>default</code> label, control passes to the statement labeled by the <code>default</code> label.</p>\n</blockquote>\n<p>The <code>default</code> label should be hit.</p>\n<p><sub>Note: One could take another look at the comparison operator, but it is not explicitly used in the referred \"comparison\". In fact, there's no hint it would introduce UB for scoped or unscoped enums in our case.</sub></p>\n<hr>\n<blockquote>\n<p id=\"so_18195312_18195408_8\">As a bonus, does the standard make any guarantees as about this but with plain enum?</p>\n</blockquote>\n<p>Whether or not the <code>enum</code> is scoped doesn't make any difference here. However, it does make a difference whether or not the underlying type is fixed. The complete [decl.enum]/7 is:</p>\n<blockquote>\n<p id=\"so_18195312_18195408_9\">For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the underlying type. Otherwise, for an enumeration where <em>e<sub>min</sub></em> is the smallest enumerator and <em>e<sub>max</sub></em> is the largest, the values of the enumeration are the values in the range <em>b<sub>min</sub></em> to <em>b<sub>max</sub></em>, defined as follows: Let <code>K</code> be <code>1</code> for a two's complement representation and <code>0</code> for a one's complement or sign-magnitude representation. <em>b<sub>max</sub></em> is the smallest value greater than or equal to <em>max(|e<sub>min</sub>| \u2212 <code>K</code>, |e<sub>max</sub>|)</em> and equal to <em>2<sup>M</sup> \u2212 1</em>, where <code>M</code> is a non-negative integer. <em>b<sub>min</sub></em> is zero if <em>e<sub>min</sub></em> is non-negative and <em>\u2212(b<sub>max</sub> + <code>K</code>)</em> otherwise.</p>\n</blockquote>\n<p>Fortunately, your enum's smallest enumerator is <code>red = 0x1</code>, so <em>max(|e<sub>min</sub>| \u2212 <code>K</code>, |e<sub>max</sub>|)</em> is equal to <em>|e<sub>max</sub>|</em> in any case, which is <code>yellow = 0x2</code>. The smallest value greater or equal to <code>2</code>, which is equal to <em>2<sup>M</sup> - 1</em> for a positive integer <code>M</code> is <code>3</code> (<em>2<sup>2</sup> - 1</em>). (I think the intent is to allow the range to extent in 1-bit-steps.) It follows that <em>b<sub>max</sub></em> is <code>3</code> and <em>bmin</em></p></hr></hr></hr> is <code>0</code>.\n<p>Therefore, <code>100</code> would be outside the range of the enum, and the <code>static_cast</code> would produce an unspecified value, which could lead to UB as per [expr]/4.</p>\n", "CreationDate": "2013-08-12T19:43:38.057", "ParentId": "18195312", "CommentCount": "18", "LastEditDate": "2017-05-23T11:47:05.747", "Id": "18195408", "PostTypeId": "2", "LastActivityDate": "2016-08-29T20:58:10.640", "LastEditorUserId": "-1", "CommunityOwnedDate": "2013-08-13T03:35:00.983", "Score": "93", "OwnerUserId": "420683"}, "18195312": {"ViewCount": "20556", "Body": "<p>Consider this C++11 code:</p>\n<pre><code>enum class Color : char { red = 0x1, yellow = 0x2 }\n// ...\nchar *data = ReadFile();\nColor color = static_cast&lt;Color&gt;(data[0]);\n</code></pre>\n<p>Suppose that data[0] is actually 100. What is color set to according to the standard?\nIn particular, if I later do</p>\n<pre><code>switch (color) {\n    // ... red and yellow cases omitted\n    default:\n        // handle error\n        break;\n}\n</code></pre>\n<p>does the standard guarantee that default will be hit? If not, what is the proper, most efficient, most elegant way to check for an error here?</p>\n<p>EDIT:</p>\n<p>As a bonus, does the standard make any guarantees as about this but with plain enum?</p>\n", "AcceptedAnswerId": "18195408", "Title": "What happens if you static_cast invalid value to enum class?", "CreationDate": "2013-08-12T19:38:16.543", "Id": "18195312", "CommentCount": "0", "FavoriteCount": "18", "PostTypeId": "1", "LastEditDate": "2013-08-12T19:43:38.800", "LastEditorUserId": "381512", "LastActivityDate": "2016-08-29T20:58:10.640", "Score": "93", "OwnerUserId": "381512", "Tags": "<c++><c++11>", "AnswerCount": "1"}});