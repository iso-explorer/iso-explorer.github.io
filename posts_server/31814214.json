post_cb({"31814278": {"ParentId": "31814214", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, of course. There's nothing implementation-defined about it.</p>\n<p>If there is a move constructor and it can be used, and it is a choice between a move constructor and a copy constructor, the move constructor will be invoked. That is a guarantee.</p>\n<blockquote>\n<p id=\"so_31814214_31814278_0\"><code>[C++11: 13.3.3.2/3]:</code> <em>[..]</em> Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if:</p>\n<p id=\"so_31814214_31814278_1\"><em>[..]</em></p>\n<ul>\n<li>S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.</li>\n</ul>\n<p id=\"so_31814214_31814278_2\"><em>[..]</em></p>\n</blockquote>\n<p>I think your confusion stems from misuse of the term \"elide\". The compiler may elide copies/moves and replace them with <em>nothingness</em> \u2014 with in-place construction that bypasses the invocation of a constructor altogether. Copy elision never results in a move, and move elision never results in a copy. Either the object \"transferral\" happens or it does not.</p>\n<p>You could sort of argue that your program has \"implementation-defined\" semantics in the sense that you don't know whether copies/moves <em>will</em> be elided until the program has been compiled, and because such elision is allowed to modify side-effects (such as console output). But we don't tend to think of it that way.</p>\n<p>Regardless, this does not affect which of the copy and move constructors will be invoked if either are to be.</p>\n<p>Your example is further flawed because only your move constructor <em>can</em> be invoked: your copy constructor takes a ref-to-non-<code>const</code> which can't be bound through an rvalue initialiser.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-08-04T16:18:26.123", "Id": "31814278", "Score": "1", "CreationDate": "2015-08-04T16:12:49.900", "LastActivityDate": "2015-08-04T16:18:26.123"}, "bq_ids": {"n4140": {"so_31814214_31814278_0": {"section_id": 603, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_31814214_31814278_0": {"section_id": 593, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_31814214_31814278_0": {"section_id": 629, "quality": 0.7272727272727273, "length": 8}}}, "31814214": {"CommentCount": "1", "ViewCount": "21", "CreationDate": "2015-08-04T16:09:38.043", "LastActivityDate": "2015-08-04T16:18:26.123", "Title": "Expected Moves vs Copies", "PostTypeId": "1", "Id": "31814214", "Score": "0", "Body": "<p>It is my understanding that move semantics can use move-constructors to elide what would otherwise be a copy.  For example, a function returning a (perhaps) large data structure can now return by value, and the move constructor will be used to avoid a copy.</p>\n<p>My question is this: is the compiler <em>required</em> to not copy when this is possible?  It doesn't seem to be the case.  In that case, wouldn't the following code have \"implementation-defined\" semantics?</p>\n<pre><code>static const int INVALID_HANDLE = 0xFFFFFFFF;\n\nclass HandleHolder {\n    int m_handle;\npublic:\n    explicit HandleHolder(int handle) : m_handle(handle) {}\n    HandleHolder(HandleHolder&amp; hh) {\n        m_handle = hh.m_handle;\n    }\n    HandleHolder(HandleHolder&amp;&amp; hh) : m_handle(INVALID_HANDLE) {\n        swap(m_handle, hh.m_handle);\n    }\n    ~HandleHolder() noexcept {\n        if (m_handle != INVALID_HANDLE) {\n            destroy_the_handle_object(m_handle);\n        }\n    }\n};\n</code></pre>\n<p>Say then we make a function:</p>\n<pre><code>HandleHolder make_hh(int handle) { return HandleHolder(handle); }\n</code></pre>\n<p>Which constructor is called?  I would expect the move constructor, but am I <em>guaranteed</em> the move constructor?</p>\n<p>I'm aware this is a silly example and that -- for example -- the copy constructor of this object should be deleted because there is no way to use it safely otherwise, but the semantics are simple enough that I wouldn't think something like this would be implementation-defined.</p>\n", "Tags": "<c++11><destructor><move><copy-constructor>", "OwnerUserId": "2443668", "AnswerCount": "1"}});