post_cb({"18290523": {"CommentCount": "2", "CreationDate": "2013-08-17T15:41:43.317", "PostTypeId": "1", "AcceptedAnswerId": "18290839", "LastEditorUserId": "1377706", "LastActivityDate": "2017-06-07T21:43:43.683", "LastEditDate": "2017-06-07T21:43:43.683", "ViewCount": "10261", "FavoriteCount": "9", "Title": "Is a `=default` move constructor equivalent to a member-wise move constructor?", "Id": "18290523", "Score": "49", "Body": "<p>Is this</p>\n<pre><code>struct Example { \n    int a, b; \n    Example(int mA, int mB) : a{mA}, b{mB}               { }\n    Example(const Example&amp; mE) : a{mE.a}, b{mE.b}        { }\n    Example(Example&amp;&amp; mE) : a{move(mE.a)}, b{move(mE.b)} { }\n    Example&amp; operator=(const Example&amp; mE) { a = mE.a; b = mE.b; return *this; } \n    Example&amp; operator=(Example&amp;&amp; mE)      { a = move(mE.a); b = move(mE.b); return *this; } \n}\n</code></pre>\n<p>equivalent to this</p>\n<pre><code>struct Example { \n    int a, b; \n    Example(int mA, int mB) : a{mA}, b{mB} { }\n    Example(const Example&amp; mE)            = default;\n    Example(Example&amp;&amp; mE)                 = default;\n    Example&amp; operator=(const Example&amp; mE) = default;\n    Example&amp; operator=(Example&amp;&amp; mE)      = default;\n}\n</code></pre>\n<p>?</p>\n", "Tags": "<c++><c++11><constructor><default><move-semantics>", "OwnerUserId": "598696", "AnswerCount": "3"}, "18290600": {"ParentId": "18290523", "CommentCount": "0", "Body": "<p>apart very pathological cases ... YES.</p>\n<p>To be more precise, you have also to considered eventual bases <code>Example</code> may have, with exact same rules. First the bases -in declaration order- then the members, always in declaration order.</p>\n", "OwnerUserId": "924727", "PostTypeId": "2", "Id": "18290600", "Score": "0", "CreationDate": "2013-08-17T15:49:58.287", "LastActivityDate": "2013-08-17T15:49:58.287"}, "bq_ids": {"n4140": {"so_18290523_18290839_2": {"section_id": 3270, "quality": 1.0, "length": 6}, "so_18290523_25123890_2": {"section_id": 464, "quality": 0.9090909090909091, "length": 10}, "so_18290523_25123890_0": {"section_id": 462, "quality": 0.7931034482758621, "length": 23}, "so_18290523_25123890_1": {"section_id": 464, "quality": 0.8727272727272727, "length": 48}, "so_18290523_18290839_4": {"section_id": 3270, "quality": 1.0, "length": 30}}, "n3337": {"so_18290523_18290839_2": {"section_id": 3142, "quality": 1.0, "length": 6}, "so_18290523_25123890_2": {"section_id": 455, "quality": 0.9090909090909091, "length": 10}, "so_18290523_18290839_4": {"section_id": 3142, "quality": 1.0, "length": 30}, "so_18290523_25123890_1": {"section_id": 455, "quality": 0.8727272727272727, "length": 48}, "so_18290523_25123890_0": {"section_id": 453, "quality": 0.7931034482758621, "length": 23}}, "n4659": {"so_18290523_18290839_2": {"section_id": 4028, "quality": 1.0, "length": 6}, "so_18290523_25123890_2": {"section_id": 487, "quality": 0.9090909090909091, "length": 10}, "so_18290523_25123890_0": {"section_id": 485, "quality": 0.7931034482758621, "length": 23}, "so_18290523_25123890_1": {"section_id": 487, "quality": 0.8545454545454545, "length": 47}, "so_18290523_18290839_4": {"section_id": 4028, "quality": 1.0, "length": 30}}}, "25123890": {"ParentId": "18290523", "LastEditDate": "2014-08-05T20:08:22.800", "CommentCount": "0", "CreationDate": "2014-08-04T17:03:13.083", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "25123890", "Score": "14", "Body": "<p>Yes, a defaulted move constructor will perform a member-wise move of its base and members, so:</p>\n<pre><code>Example(Example&amp;&amp; mE) : a{move(mE.a)}, b{move(mE.b)} { }\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>Example(Example&amp;&amp; mE)                 = default;\n</code></pre>\n<p>we can see this by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">draft C++11 standard</a> section <code>12.8</code> <em>Copying and moving class objects</em> paragraph <em>13</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_18290523_25123890_0\">A copy/move constructor that is defaulted and not defined as deleted\n  <strong>is implicitly defined</strong> if it is odrused (3.2) or when it is explicitly\n  defaulted after its first declaration. [ Note: The copy/move\n  constructor is implicitly defined even if the implementation elided\n  its odr-use (3.2, 12.2). \u2014end note ][...]</p>\n</blockquote>\n<p>and paragraph <em>15</em> which says:</p>\n<blockquote>\n<p id=\"so_18290523_25123890_1\">The <strong>implicitly-defined copy/move constructor</strong> for a non-union class X\n  <strong>performs a memberwise copy/move of its bases and members</strong>. [ Note:\n  brace-or-equal-initializers of non-static data members are ignored.\n  See also the example in 12.6.2. \u2014end note ] The order of\n  initialization is the same as the order of initialization of bases and\n  members in a user-defined constructor (see 12.6.2). Let x be either\n  the parameter of the constructor or, for the move constructor, an\n  xvalue referring to the parameter. Each base or non-static data member\n  is copied/moved in the manner appropriate to its type:</p>\n<ul>\n<li>if the member is an array, each element is direct-initialized with the corresponding subobject of x;</li>\n<li>if a member m has rvalue reference type T&amp;&amp;, it is direct-initialized with static_cast(x.m);</li>\n<li>otherwise, the base or member is direct-initialized with the corresponding base or member of x.</li>\n</ul>\n<p id=\"so_18290523_25123890_2\">Virtual base class subobjects shall be initialized only once by the\n  implicitly-defined copy/move constructor (see 12.6.2).</p>\n</blockquote>\n", "LastActivityDate": "2014-08-05T20:08:22.800"}, "18290839": {"ParentId": "18290523", "LastEditDate": "2013-08-17T22:54:11.303", "CommentCount": "3", "CreationDate": "2013-08-17T16:11:41.770", "OwnerUserId": "1394283", "LastEditorUserId": "1394283", "PostTypeId": "2", "Id": "18290839", "Score": "24", "Body": "<p><strong>Yes both are the same.</strong></p>\n<p>But</p>\n<pre><code>struct Example { \n    int a, b; \n    Example(int mA, int mB) : a{mA}, b{mB} { }\n    Example(const Example&amp; mE)            = default;\n    Example(Example&amp;&amp; mE)                 = default;\n    Example&amp; operator=(const Example&amp; mE) = default;\n    Example&amp; operator=(Example&amp;&amp; mE)      = default;\n}\n</code></pre>\n<p>This version will permits you to skip the body definition.</p>\n<p>However, you have to follow some rules when you declare <code>explicitly-defaulted-functions</code> :</p>\n<blockquote>\n<p id=\"so_18290523_18290839_0\"><strong>8.4.2 Explicitly-defaulted functions [dcl.fct.def.default]</strong></p>\n<p id=\"so_18290523_18290839_1\">A function definition of the form:</p>\n<pre><code>  attribute-speci\ufb01er-seqopt decl-speci\ufb01er-seqopt declarator virt-speci\ufb01er-seqopt = default ;\n</code></pre>\n<p id=\"so_18290523_18290839_2\">is called an <em>explicitly-defaulted</em> definition. A function that is explicitly defaulted shall</p>\n<ul>\n<li><p id=\"so_18290523_18290839_3\">be a special member function,</p></li>\n<li><p id=\"so_18290523_18290839_4\">have the same declared function type (except for possibly differing <em>ref-qualifiers</em> and except that in the case of a copy constructor or copy assignment operator, the parameter type may be \u201creference to non-const <code>T</code>\u201d, where <code>T</code> is the name of the member function\u2019s class) as if it had been implicitly declared,</p></li>\n<li><p id=\"so_18290523_18290839_5\">not have default arguments.</p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2013-08-17T22:54:11.303"}});