post_cb({"23202296": {"CommentCount": "7", "AcceptedAnswerId": "23202480", "CreationDate": "2014-04-21T17:21:47.363", "LastActivityDate": "2014-04-21T18:05:35.870", "PostTypeId": "1", "ViewCount": "2615", "FavoriteCount": "3", "Title": "Constructor-style casting in function call parameters", "Id": "23202296", "Score": "19", "Body": "<p>I don't understand why the following code fails to compile when using constructor-style casting:</p>\n<pre><code>template&lt;typename T&gt; void foo(const T&amp; t){}\n\nint main(){\n  foo(unsigned char(0));\n}\n</code></pre>\n<p>The errors are:</p>\n<ul>\n<li><code>error: expected primary-expression before \u2018unsigned\u2019</code> for gcc.</li>\n<li><code>error: expected '(' for function-style cast or type construction</code> for clang</li>\n</ul>\n<p>However these three syntaxes are correct:</p>\n<pre><code>template&lt;typename T&gt; void foo(const T&amp; t){}\n\nint main(){\n  // c-style cast\n  foo((unsigned char)0);\n\n  // without unsigned\n  foo(char(0));\n\n  // aliased unsigned char\n  typedef unsigned char uchar;\n  foo(uchar(0));\n}\n</code></pre>\n<p>So the space in the type is obviously to blame here.</p>\n<p>I thought it might be somehow related to our old friend <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\">the most vexing parse</a>, so I tried the <a href=\"http://stroustrup.com/C++11FAQ.html#uniform-init\">uniform initialization syntax</a>, which is supposed to get rid of this sort of ambiguities, but no luck:</p>\n<pre><code>template&lt;typename T&gt; void foo(const T&amp; t){}\n\nint main(){\n  foo(unsigned char{0});\n}\n</code></pre>\n<p>But still:</p>\n<ul>\n<li><code>error: expected primary-expression before \u2018unsigned\u2019</code> for gcc.</li>\n<li><code>error: expected '(' for function-style cast or type construction</code> for clang</li>\n</ul>\n<p>So my question is why is it not allowed to have a type containing a space in function-style casts? It doesn't look ambiguous to me.</p>\n<p><strong><em>note</em></strong>: I know I can write <code>foo&lt;unsigned char&gt;(0)</code>, but it doesn't answer the question ;)</p>\n", "Tags": "<c++><c++11><casting>", "OwnerUserId": "401200", "AnswerCount": "1"}, "23202480": {"ParentId": "23202296", "PostTypeId": "2", "CommentCount": "17", "Body": "<blockquote>\n<p id=\"so_23202296_23202480_0\"><code>[C++11: 5.2.3/1]:</code> A <em>simple-type-specifier</em> (7.1.6.2) or <em>typename-specifier</em> (14.6) followed by a parenthesized <em>expression-list</em> constructs a value of the specified type given the expression list. <em>[..]</em></p>\n</blockquote>\n<p>Examining the grammar, we see that the only way to get <code>unsigned char</code> from the <em>simple-type-specifier</em> production is by concatenating two of them.</p>\n<p>As evidence debunking the rumour that table 10 is stating the contrary, which I may myself  have started a short while ago (:P), the table heading says \"specifier(s)\" (note the optional plural), and refer to the below passage:</p>\n<blockquote>\n<p id=\"so_23202296_23202480_1\"><code>[C++11: 5.2.3/2]:</code> <em>[..]</em> Table 10 summarizes the valid <strong>combinations</strong> of <em>simple-type-specifiers</em> and the types they specify. <sup><em>(emphasis mine)</em></sup></p>\n</blockquote>\n<p>Now, combining <em>simple-type-specifiers</em> is allowed in some cases:</p>\n<blockquote>\n<p id=\"so_23202296_23202480_2\"><code>[C++11: 7.1.6.2/3]:</code> When multiple <em>simple-type-specifiers</em> are allowed, they can be freely intermixed with other <em>decl-specifiers</em> in any order. <em>[..]</em></p>\n</blockquote>\n<p>\u2026 but there's no indication that this is the case with functional notation, which clearly states \"<strong>a</strong> <em>simple-type-specifier</em>\" \u2014 singular.</p>\n<p><strong>Therefore GCC is correct, and Visual Studio is wrong.</strong></p>\n<p>As for <em>why</em> this is the case... well, I don't know. I suspect we could come up with some ambiguous edge case, but <a href=\"https://stackoverflow.com/users/923854/casey\">Casey</a> makes a good point in the comments below that allowing this would be inconsistent with function call syntax, since names of functions cannot have spaces in them.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:28.823", "Id": "23202480", "Score": "16", "CreationDate": "2014-04-21T17:32:43.970", "LastActivityDate": "2014-04-21T18:02:32.490"}, "bq_ids": {"n4140": {"so_23202296_23202480_2": {"section_id": 5439, "quality": 0.8461538461538461, "length": 11}, "so_23202296_23202480_0": {"section_id": 5999, "quality": 0.75, "length": 12}, "so_23202296_23202480_1": {"section_id": 5438, "quality": 0.5833333333333334, "length": 7}}, "n3337": {"so_23202296_23202480_2": {"section_id": 5234, "quality": 0.8461538461538461, "length": 11}, "so_23202296_23202480_0": {"section_id": 5767, "quality": 0.75, "length": 12}, "so_23202296_23202480_1": {"section_id": 5233, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_23202296_23202480_2": {"section_id": 6866, "quality": 0.8461538461538461, "length": 11}, "so_23202296_23202480_0": {"section_id": 7499, "quality": 0.625, "length": 10}, "so_23202296_23202480_1": {"section_id": 6865, "quality": 0.5833333333333334, "length": 7}}}});