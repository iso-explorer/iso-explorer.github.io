post_cb({"38870690": {"ParentId": "38870556", "Score": "4", "CreationDate": "2016-08-10T10:23:41.580", "Id": "38870690", "OwnerUserId": "6696291", "LastActivityDate": "2016-08-10T10:23:41.580", "Body": "<p>Without parenthesis, the operands on both sides of the <code>&lt;&lt;</code> determine the meaning: <code>int &lt;&lt; int == shift</code>, <code>stream &lt;&lt; any == insertion</code>.\nThis 'reuse' of the operator may be confusing, indead. But you can solve ambiguities by using parentheses: <code>stream &lt;&lt; (int &lt;&lt; int) == \"int\"</code></p>\n", "PostTypeId": "2", "CommentCount": "0"}, "38870556": {"Tags": "<c++><operator-overloading><associativity>", "ViewCount": "2425", "LastEditDate": "2016-08-10T18:29:03.453", "CreationDate": "2016-08-10T10:17:45.283", "LastEditorUserId": "744178", "Title": "When does operator<< refer to the insertion operator and when to the bitwise left shift?", "CommentCount": "14", "AcceptedAnswerId": "38871189", "Score": "23", "OwnerUserId": "5805009", "Id": "38870556", "LastActivityDate": "2016-08-11T07:47:51.207", "Body": "<p>When does <code>operator &lt;&lt;</code> refer to the insertion operator and when does it refer to the bitwise left shift?</p>\n<p>This will output <code>10</code>, and <code>operator &lt;&lt;</code> refers to the left shift. </p>\n<pre><code>cout &lt;&lt; a.b() &lt;&lt; a.a.b &lt;&lt; endl;  \n</code></pre>\n<p>And this will output <code>11</code>, <code>operator &lt;&lt;</code> refers to the insertion operator.</p>\n<pre><code>cout &lt;&lt; a.b();\ncout &lt;&lt; a.a.b ;\n</code></pre>\n<p>I am confused, when will <code>operator &lt;&lt;</code> (when use with <code>cout</code>)  refer to the left shift operator?</p>\n<pre><code>#include &lt;iostream&gt; \nusing namespace std; \n\nclass A { \npublic:\n    A() { a.a = a.b = 1; }\n\n    struct { int a, b; } a;\n\n    int b(); \n}; \n\nint A::b(){\n    int x=a.a;\n    a.a=a.b;\n    a.b=x; \n    return x;\n};\n\n int main(){\n    A a; \n    a.a.a = 0; \n    a.b(); \n\n    cout &lt;&lt; a.b() &lt;&lt; a.a.b &lt;&lt; endl;      // ?????\n    return 0;\n}\n</code></pre>\n", "PostTypeId": "1", "FavoriteCount": "2", "AnswerCount": "6"}, "38871054": {"ParentId": "38870556", "Score": "16", "CreationDate": "2016-08-10T10:37:46.087", "LastActivityDate": "2016-08-11T07:47:51.207", "LastEditDate": "2016-08-11T07:47:51.207", "OwnerUserId": "3959454", "LastEditorUserId": "3959454", "Body": "<p>In your case all <code>operator &lt;&lt;</code>s are output stream insertion operators because their left argument is of type <code>ostream&amp;</code>, and they group left to right.</p>\n<p>The difference in the output is caused by the order of evaluation of function arguments:</p>\n<pre><code>cout &lt;&lt; a.b() &lt;&lt; a.a.b\n</code></pre>\n<p>is</p>\n<pre><code>operator&lt;&lt;(operator&lt;&lt;(cout, a.b()), a.a.b)\n</code></pre>\n<p>so the output depends on which of <code>a.a.b</code> or <code>a.b()</code> is evaluated first. This actually unspecified by current standard (C++14) so you could get <code>11</code> as well. </p>\n<p>AFAIK in C++17 <code>11</code> will be the only valid output for both cases because it enforces left-to-right evaluation of function parameters.</p>\n<p><s>Update: this seems to be not true, as the committee decided (as of <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4606.pdf\" rel=\"nofollow\">N4606</a>) to go with indeterminately sequenced parameter evaluation mentioned at the bottom of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r2.pdf\" rel=\"nofollow\">P0145R2</a>. See [expr.call]/5.</s></p>\n<p>Update2: Since we are talking about overloaded operators here, [over.match.oper]/2 in N4606 applies, which says</p>\n<blockquote>\n<p id=\"so_38870556_38871054_0\">However, the operands are sequenced in the order prescribed for the built-in operator.</p>\n</blockquote>\n<p>So indeed, the order of evaluaion will be well-defined in C++17. This misunderstanding apparently has been predicted by the authors of P0145:</p>\n<blockquote>\n<p id=\"so_38870556_38871054_1\">We do not believe that such a nondeterminism brings any substantial added optimization benefit, but it does perpetuate the confusion and hazards around order of evaluations in function calls</p>\n</blockquote>\n", "Id": "38871054", "PostTypeId": "2", "CommentCount": "11"}, "38870700": {"ParentId": "38870556", "Score": "9", "CreationDate": "2016-08-10T10:24:12.520", "Id": "38870700", "OwnerUserId": "6612932", "LastActivityDate": "2016-08-10T10:24:12.520", "Body": "<p>This call:</p>\n<pre><code>cout &lt;&lt; a.b() &lt;&lt; a.a.b &lt;&lt; endl;\n</code></pre>\n<p>will first consider:</p>\n<pre><code>cout &lt;&lt; a.b()\n</code></pre>\n<p>which correspond to the insertion operator and returns a refence to cout. Thus, the instruction will become:</p>\n<pre><code>(returned reference to cout) &lt;&lt; a.a.b\n</code></pre>\n<p>which again will call the insertion operator and so on...</p>\n<p>If your instruction was:</p>\n<pre><code>cout &lt;&lt; (a.b() &lt;&lt; a.a.b) &lt;&lt; endl;\n</code></pre>\n<p>the part between parentheses would be considered first:</p>\n<pre><code>a.b() &lt;&lt; a.a.b\n</code></pre>\n<p>this time, you have an operator between 2 <code>int</code>: compiler can only resolve it as a call to bitwise operator.</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_38870556_38871054_0": {"length": 7, "section_id": 606, "quality": 1.0}}}, "38871010": {"ParentId": "38870556", "Score": "9", "CreationDate": "2016-08-10T10:35:55.780", "Id": "38871010", "OwnerUserId": "2718186", "LastActivityDate": "2016-08-10T10:35:55.780", "Body": "<p>Binary operators, such as <code>&lt;&lt;</code>, have two properties that define their usage: (operator) precedence and (left- or right-) associativity. In this case, associativity is the key, and, see e.g. <a href=\"http://en.cppreference.com/w/c/language/operator_precedence\">http://en.cppreference.com/w/c/language/operator_precedence</a>, the <code>&lt;&lt;</code> operator has left-to-right associativity, so they are sequenced (as if by brackets) from left to right:</p>\n<pre><code>((cout &lt;&lt; a.b()) &lt;&lt; a.a.b) &lt;&lt; endl;\n</code></pre>\n<p>or in words sequenced as <code>cout &lt;&lt; a.b()</code> then <code>&lt;&lt; a.a.b</code> and then <code>&lt;&lt; endl</code>.</p>\n<p>After this sequencing, operator overloading takes effect on each invocation of <code>&lt;&lt;</code> with the given types, which then determines which overload is called and thus if it's a <code>cout</code>-operation or a shift.</p>\n", "PostTypeId": "2", "CommentCount": "0"}, "38871031": {"ParentId": "38870556", "Score": "40", "CreationDate": "2016-08-10T10:36:49.770", "LastActivityDate": "2016-08-10T10:41:15.343", "LastEditDate": "2016-08-10T10:41:15.343", "OwnerUserId": "471160", "LastEditorUserId": "471160", "Body": "<blockquote>\n<p id=\"so_38870556_38871031_0\">This will output 10, and operator&lt;&lt; refer to left shift.</p>\n<p id=\"so_38870556_38871031_1\">cout &lt;&lt; a.b() &lt;&lt; a.a.b &lt;&lt; endl;  </p>\n</blockquote>\n<p>This is caused of the fact that order of evaluation of operands is unspecified. With clang it outputs 11 but with gcc it outputs 10.</p>\n<p>Your code:</p>\n<pre><code>cout &lt;&lt; a.b() &lt;&lt; a.a.b &lt;&lt; endl;\n</code></pre>\n<p>can be replaced with:</p>\n<pre><code>std::cout.operator&lt;&lt;(a.b()).operator&lt;&lt;(a.a.b);  \n</code></pre>\n<p>clang first evaluates <code>a.b()</code> then <code>a.a.b</code>, g++ does it the other way around. Since your <code>a.b()</code> modifies variables you get different results.</p>\n<p>When you rewrite your code as:</p>\n<pre><code>cout &lt;&lt; a.b();\ncout &lt;&lt; a.a.b ;\n</code></pre>\n<p>then you have two full expression statements, there is no unspecified behaviour here related to operand evaluation. So you get always the same result.</p>\n", "Id": "38871031", "PostTypeId": "2", "CommentCount": "1"}, "38871189": {"ParentId": "38870556", "Score": "14", "CreationDate": "2016-08-10T10:44:23.227", "Id": "38871189", "OwnerUserId": "6695750", "LastActivityDate": "2016-08-10T10:44:23.227", "Body": "<p>The problem you are confronted with is not concerning the &lt;&lt; operator. In each case, the insertion operator is called.</p>\n<p>However, you are faced with a problem concerning the <strong>order of evaluation</strong> in the command line </p>\n<pre><code>cout &lt;&lt; a.b() &lt;&lt; a.a.b &lt;&lt; endl;\n</code></pre>\n<p>The function <code>a.b()</code> has a side effect. It swaps the values a.a.a and a.a.b. Thus, it is evident, wether a.b() is called before or after evaluating the value ov <code>a.a.b</code>.</p>\n<p>In C++, the order of evaluation is unspecified, see <a href=\"http://en.cppreference.com/w/cpp/language/eval_order\">cppreference.com</a> for a more detailed discussion.</p>\n", "PostTypeId": "2", "CommentCount": "0"}});