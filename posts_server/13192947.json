post_cb({"13205188": {"Id": "13205188", "PostTypeId": "2", "Body": "<p>The other answers already provide the reason, if not the rationale:</p>\n<blockquote>\n<p id=\"so_13192947_13205188_0\">A <code>typedef</code> is an alias to a type, and it will be resolved by the compiler to the actual type. Argument dependent lookup is done based on the underlying type, not the typedef.</p>\n</blockquote>\n<p>The rationale for this design decision is actually the reason why ADL is in the language. ADL was added to the language to support operator overloading. In any other use case, the user <em>can</em> explicitly state the namespace of the functions, but in the case of operator overloading that would lead to convoluted code that is counter intuitive:</p>\n<pre><code>std::string s(\"Hi\");\nstd::cout.operator&lt;&lt;(s); // or is it std::operator&lt;&lt;(std::cout,s)??\n</code></pre>\n<p>So the language added rules for lookup to find operators (and functions) in different namespaces, and in particular in the namespace of the arguments to the function. In this case inside <code>std::</code> in case the <code>operator&lt;&lt;</code> that takes a <code>std::string</code> is not a member of <code>std::cout</code>. The same behavior is extended to all free functions in the same namespace (why not?) allowing the interface of a type to include not only member functions but also free functions in the same namespace.</p>\n<p>Now if you focus on this, the purpose is accessing functions that are part of the interface of the type, and those are defined <em>with</em> the type. When you add a typedef in a different namespace you are just creating a shorthand to refer to the original type. All of the functions that were provided with the type (for example <code>operator&lt;&lt;(std::ostream&amp;,MyType)</code>) are in the original namespace, no in the namespace of the <code>typedef</code>. You <em>want</em> ADL to look into the namespace where the real type was defined, not where the alias was created.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2012-11-05T15:14:07.087", "Score": "3", "CreationDate": "2012-11-03T01:44:11.523", "ParentId": "13192947", "CommentCount": "1", "OwnerUserId": "36565", "LastEditDate": "2012-11-05T15:14:07.087"}, "13193250": {"Id": "13193250", "PostTypeId": "2", "Body": "<p>The main point to note is that a <code>typedef</code> does not introduce a new type, but is a synonym for another type. So <code>d</code> has type <code>ns::data</code>.</p>\n<p>Now ADL applies and the function <code>func</code> will be found in the namespace <code>ns</code>.</p>\n<p>Addition: To prevent ADL you can write <code>(func)(d)</code>.</p>\n", "LastActivityDate": "2012-11-02T10:15:07.190", "CommentCount": "0", "CreationDate": "2012-11-02T10:15:07.190", "ParentId": "13192947", "Score": "3", "OwnerUserId": "1770418"}, "13193511": {"Id": "13193511", "PostTypeId": "2", "Body": "<p>This behaviour is specified by the standard (my emphasis):</p>\n<blockquote>\n<h3>3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</h3>\n<p id=\"so_13192947_13193511_0\">2 - For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument). <strong>Typedef names and <em>using-declarations</em> used to specify the types do not contribute to this set.</strong></p>\n</blockquote>\n<p>This is somewhat unfortunate; it means that e.g. the code (adapted from <a href=\"https://stackoverflow.com/questions/4155450/adl-with-typedefs-from-another-namespace\">ADL with typedefs from another namespace</a>):</p>\n<pre><code>std::vector&lt;int&gt; v;\ncount(v.begin(), v.end(), 0);\n</code></pre>\n<p>will depend for its validity and meaning on whether <code>std::vector&lt;T&gt;::iterator</code> is a typedef to <code>T *</code> or to some type in <code>namespace std</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-02T10:39:53.590", "Score": "4", "CreationDate": "2012-11-02T10:34:46.833", "ParentId": "13192947", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T12:02:48.590"}, "bq_ids": {"n4140": {"so_13192947_13193511_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 7104}}, "n3337": {"so_13192947_13193511_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 6848}}, "n4659": {"so_13192947_13193511_0": {"length": 31, "quality": 0.8378378378378378, "section_id": 8605}}}, "13193031": {"Id": "13193031", "PostTypeId": "2", "Body": "<p>The parameter <code>d</code> is local to <code>main</code>. <code>datatype</code> is just an alias for the type <code>ns::data</code> so <code>d</code> has type <code>ns::data</code>.</p>\n<p><code>ns::data</code> is a [direct] member of the <code>ns</code> namespace so this functions in the <code>ns</code> namespace will be considered for ADL.</p>\n", "LastActivityDate": "2012-11-02T10:01:46.127", "CommentCount": "0", "CreationDate": "2012-11-02T10:01:46.127", "ParentId": "13192947", "Score": "8", "OwnerUserId": "19563"}, "13192947": {"ViewCount": "604", "Body": "<p>I would not have expected this code to compile, but it does. My understanding is that <code>func(d)</code> it looks in the global namespace for a function called \"func\" but also in the namespace of any passed in parameters (Argument dependent lookup)</p>\n<p>But in this case the parameter is in the global namespace. So why does it find \"func\" in the ns namespace? Are there special rules saying that if the parameter type is a typedef then it uses the namespace of the underlying type rather than the namespace of the actual parameter?</p>\n<p>This appears to be true but I can't find anything supporting this... Is it the expected behavour?</p>\n<pre><code>namespace ns\n{\n    struct data {};\n    void func(ns::data item) {}\n};\n\n// Create an alias \"datatype\" in the global namespace for ns::data\ntypedef ns::data datatype;\n\n\nint main()\n{\n    datatype d;\n    func(d);\n}\n</code></pre>\n", "AcceptedAnswerId": "13205188", "Title": "Argument dependent name lookup and typedef", "CreationDate": "2012-11-02T09:56:36.067", "Id": "13192947", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-11-05T15:14:07.087", "Score": "8", "OwnerUserId": "417292", "Tags": "<c++>", "AnswerCount": "4"}});