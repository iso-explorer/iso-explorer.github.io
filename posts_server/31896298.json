post_cb({"bq_ids": {"n4140": {"so_31896298_31897188_6": {"length": 29, "quality": 0.9666666666666667, "section_id": 632}, "so_31896298_31897188_5": {"length": 8, "quality": 1.0, "section_id": 599}, "so_31896298_31897188_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}, "so_31896298_31897188_12": {"length": 18, "quality": 0.9, "section_id": 603}, "so_31896298_31897188_14": {"length": 8, "quality": 0.8888888888888888, "section_id": 638}, "so_31896298_31897188_15": {"length": 12, "quality": 0.9230769230769231, "section_id": 638}, "so_31896298_31897188_1": {"length": 27, "quality": 1.0, "section_id": 3323}, "so_31896298_31897188_8": {"length": 4, "quality": 1.0, "section_id": 635}, "so_31896298_31897188_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}, "so_31896298_31897188_9": {"length": 8, "quality": 1.0, "section_id": 635}, "so_31896298_31897188_4": {"length": 20, "quality": 1.0, "section_id": 599}, "so_31896298_31897188_13": {"length": 6, "quality": 0.75, "section_id": 603}, "so_31896298_31897188_7": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_31896298_31897188_0": {"length": 6, "quality": 0.75, "section_id": 3296}}, "n3337": {"so_31896298_31897188_6": {"length": 27, "quality": 0.9, "section_id": 622}, "so_31896298_31897188_5": {"length": 8, "quality": 1.0, "section_id": 589}, "so_31896298_31897188_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}, "so_31896298_31897188_12": {"length": 18, "quality": 0.9, "section_id": 593}, "so_31896298_31897188_14": {"length": 8, "quality": 0.8888888888888888, "section_id": 628}, "so_31896298_31897188_15": {"length": 12, "quality": 0.9230769230769231, "section_id": 628}, "so_31896298_31897188_1": {"length": 27, "quality": 1.0, "section_id": 3193}, "so_31896298_31897188_0": {"length": 6, "quality": 0.75, "section_id": 3166}, "so_31896298_31897188_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}, "so_31896298_31897188_9": {"length": 8, "quality": 1.0, "section_id": 625}, "so_31896298_31897188_4": {"length": 20, "quality": 1.0, "section_id": 589}, "so_31896298_31897188_13": {"length": 6, "quality": 0.75, "section_id": 593}, "so_31896298_31897188_7": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_31896298_31897188_8": {"length": 4, "quality": 1.0, "section_id": 625}}, "n4659": {"so_31896298_31897188_6": {"length": 29, "quality": 0.9666666666666667, "section_id": 660}, "so_31896298_31897188_5": {"length": 8, "quality": 1.0, "section_id": 622}, "so_31896298_31897188_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}, "so_31896298_31897188_12": {"length": 18, "quality": 0.9, "section_id": 629}, "so_31896298_31897188_14": {"length": 8, "quality": 0.8888888888888888, "section_id": 666}, "so_31896298_31897188_15": {"length": 12, "quality": 0.9230769230769231, "section_id": 666}, "so_31896298_31897188_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 4089}, "so_31896298_31897188_0": {"length": 6, "quality": 0.75, "section_id": 4058}, "so_31896298_31897188_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}, "so_31896298_31897188_9": {"length": 8, "quality": 1.0, "section_id": 663}, "so_31896298_31897188_4": {"length": 20, "quality": 1.0, "section_id": 622}, "so_31896298_31897188_13": {"length": 6, "quality": 0.75, "section_id": 629}, "so_31896298_31897188_7": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_31896298_31897188_8": {"length": 4, "quality": 1.0, "section_id": 660}}}, "31897188": {"Id": "31897188", "PostTypeId": "2", "Body": "<p>That <code>{}</code> syntax is a <em>braced-init-list</em>, and since it is used as an argument in a function call, it <em>copy-list-initializes</em> a corresponding parameter.</p>\n<p>\u00a7 8.5 [dcl.init]/p17:</p>\n<blockquote>\n<p id=\"so_31896298_31897188_0\"><sup>(17.1)</sup> \u2014 If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</p>\n</blockquote>\n<p>\u00a7 8.5.4 [dcl.init.list]/p1:</p>\n<blockquote>\n<p id=\"so_31896298_31897188_1\"><em>List-initialization</em> is initialization of an object or reference from a <em>braced-init-list</em>. Such an initializer is\n  called an <em>initializer list</em>, and the comma-separated initializer-clauses of the list are called the elements of the\n  initializer list. An initializer list may be empty. <em>List-initialization</em> can occur in <em>direct-initialization</em> or <em>copy-initialization</em> contexts; [...]</p>\n</blockquote>\n<p>For a class-type parameter, with list-initialization, overload resolution looks up for a viable constructor in two phases:</p>\n<p>\u00a7 13.3.1.7 [over.match.list]/p1:</p>\n<blockquote>\n<p id=\"so_31896298_31897188_2\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor\n  in two phases:</p>\n<p id=\"so_31896298_31897188_3\">\u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.</p>\n<p id=\"so_31896298_31897188_4\">\u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements of the initializer list.</p>\n</blockquote>\n<p>but:</p>\n<blockquote>\n<p id=\"so_31896298_31897188_5\">If the initializer list has no elements and <code>T</code> has a default constructor, the first phase is omitted.</p>\n</blockquote>\n<p>Since <code>std::deque&lt;T&gt;</code> defines a non-explicit default constructor, one is added to a set of viable functions for overload resolution. Initialization through a constructor is classified as a <strong>user-defined conversion</strong> (\u00a7 13.3.3.1.5 [over.ics.list]/p4):</p>\n<blockquote>\n<p id=\"so_31896298_31897188_6\">Otherwise, if the parameter is a non-aggregate class <code>X</code> and overload resolution per 13.3.1.7 chooses a single\n  best constructor of <code>X</code> to perform the initialization of an object of type <code>X</code> from the argument initializer list,\n  the implicit conversion sequence is a user-defined conversion sequence with the second standard conversion\n  sequence an identity conversion.</p>\n</blockquote>\n<p>Going further, an empty braced-init-list can value-initialize its corresponding parameter (\u00a7 8.5.4 [dcl.init.list]/p3), which for literal types stands for zero-initialization:</p>\n<blockquote>\n<p id=\"so_31896298_31897188_7\"><sup>(3.7)</sup> \u2014 Otherwise, if the initializer list has no elements, the object is value-initialized.</p>\n</blockquote>\n<p>This, for literal types like <code>bool</code>, doesn't require any conversion and is classified as a <strong>standard conversion</strong> (\u00a7 13.3.3.1.5 [over.ics.list]/p7):</p>\n<blockquote>\n<p id=\"so_31896298_31897188_8\">Otherwise, if the parameter type is not a class:</p>\n<p id=\"so_31896298_31897188_9\"><sup>(7.2)</sup> \u2014 if the initializer list has no elements, the implicit conversion sequence is the identity conversion.</p>\n<p id=\"so_31896298_31897188_10\">[ <em>Example</em>:</p>\n<pre><code>void f(int);\nf( { } );\n// OK: identity conversion\n</code></pre>\n<p id=\"so_31896298_31897188_11\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Overload resolution checks in first place if there exists an argument for which a conversion sequence to a corresponding parameter is better than in another overload (\u00a7 13.3.3 [over.match.best]/p1):</p>\n<blockquote>\n<p id=\"so_31896298_31897188_12\">[...] Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function\n  <code>F2</code> if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then:</p>\n<p id=\"so_31896298_31897188_13\"><sup>(1.3)</sup> \u2014 for some argument <code>j</code>, <code>ICSj(F1)</code> is a better conversion sequence than <code>ICSj(F2)</code>, or, if not that, [...]</p>\n</blockquote>\n<p>Conversion sequences are ranked as per \u00a7 13.3.3.2 [over.ics.rank]/p2:</p>\n<blockquote>\n<p id=\"so_31896298_31897188_14\">When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)</p>\n<p id=\"so_31896298_31897188_15\"><sup>(2.1)</sup> \u2014 a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and [...]</p>\n</blockquote>\n<p>As such, the first overload with <code>bool</code> initialized with <code>{}</code> is considered as a better match.</p>\n", "LastEditorUserId": "3953764", "LastActivityDate": "2015-08-09T10:57:51.373", "Score": "5", "CreationDate": "2015-08-08T18:28:48.327", "ParentId": "31896298", "CommentCount": "2", "OwnerUserId": "3953764", "LastEditDate": "2015-08-09T10:57:51.373"}, "31896298": {"ViewCount": "463", "Body": "<p>This question is regarding std::initializer_list, and why it is allowed to initialise primitive types. Consider the following two functions:</p>\n<pre><code>void foo(std::string arg1, bool arg2 = false);\nvoid foo(std::string arg1, std::deque&lt;std::string&gt; arg2, bool arg3 = false);\n</code></pre>\n<p>Why is it that, when calling foo like this:</p>\n<pre><code>foo(\"some string\", { });\n</code></pre>\n<p>The first overload is picked, instead of the second? Well, actually not <em>why</em> it's picked, it's because <code>{ }</code> can be used to initialise <em>anything</em>, including primitive types. My question is the reasoning behind this.</p>\n<p>std::initializer_list takes <code>{ args... }</code>, and as such cannot have indeterminate length at the time of compilation. Attempting to do something like <code>bool b = { true, true }</code> gives <code>error: scalar object 'b' requires one element in initialiser</code>.</p>\n<p>While it might have seemed like a good idea to allow uniform initialisation, the fact is that this is confusing and entirely unexpected behaviour. Indeed, how is the compiler able to do this, without some magic in the background doing std::initializer_list things?</p>\n<p>Unless <code>{ args... }</code> is a C++ lexical construct, in which case my point still stands: why is it allowed to be used in the initialisation of primitive types?</p>\n<p>Thanks. I had quite the bug-hunting session here, before realising that the wrong overload was being called. Spent 10 minutes figuring out why.</p>\n", "AcceptedAnswerId": "31897188", "Title": "Why does C++ allow std::initializer_list to be coerced to primitive types, and be used to initialise them?", "CreationDate": "2015-08-08T16:48:35.950", "Id": "31896298", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-09T07:38:50.643", "LastEditorUserId": "2756719", "LastActivityDate": "2015-08-09T10:57:51.373", "Score": "9", "OwnerUserId": "3120239", "Tags": "<c++><c++11><initializer-list>", "AnswerCount": "3"}, "31896363": {"Id": "31896363", "PostTypeId": "2", "Body": "<p>Unfortunately, <code>{}</code> does not actually indicate an <code>std::initializer_list</code>. It is also used for uniform initialization. Uniform initialization was intended to fix the problems of the piles of different ways C++ objects could be initialized but ended up just making things worse, and the syntactic conflict with <code>std::initializer_list</code> is fairly awful.</p>\n<p>Bottom line is that <code>{}</code> to denote an <code>std::initializer_list</code> and <code>{}</code> to denote uniform initialization are two different things, except when they're not.</p>\n<blockquote>\n<p id=\"so_31896298_31896363_0\">Indeed, how is the compiler able to do this, without some magic in the\n  background doing std::initialiser_list things?</p>\n</blockquote>\n<p>The aforementioned magic most assuredly exists. <code>{ args... }</code> is simply a lexical construct and the semantic interpretation depends on context- it is certainly not an <code>std::initializer_list</code>, unless the context says it is.</p>\n<blockquote>\n<p id=\"so_31896298_31896363_1\">why is it allowed to be used in the initialisation of primitive types?</p>\n</blockquote>\n<p>Because the Standards Committee did not properly consider how broken it was to use the same syntax for both features.</p>\n<p>Ultimately, uniform init is broken by design, and should realistically be banned.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2015-08-09T09:10:58.117", "Score": "3", "CreationDate": "2015-08-08T16:55:16.080", "ParentId": "31896298", "CommentCount": "3", "OwnerUserId": "298661", "LastEditDate": "2015-08-09T09:10:58.117"}, "31897231": {"Id": "31897231", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_31896298_31897231_0\">My question is the reasoning behind this.</p>\n</blockquote>\n<p>The reasoning behind it is simple (albeit flawed). List-initialization initializes everything.<br>\nIn particular, <code>{}</code> stands for \"default\" initializing the object it corresponds to; Whether this means that its <code>initializer_list</code>-constructor is called with an empty list, or that its default constructor is called, or that it is value-initialized, or that all of an aggregates subobjects are initialized with <code>{}</code>, etc. is irrelevant: It is supposed to act as a universal initializer for any object that the above can be applied to. </br></p>\n<p>If you wanted to call the second overload, you'd have to pass e.g. <code>std::deque&lt;std::string&gt;{}</code> (or pass three arguments in the first place). That is the current modus operandi.</p>\n<blockquote>\n<p id=\"so_31896298_31897231_1\">While it might have seemed like a good idea to allow uniform\n  initialisation, the fact is that this is confusing and entirely\n  unexpected behaviour.</p>\n</blockquote>\n<p>I wouldn't call it \"entirely unexpected\" by any means. What is confusing about list-initializing primitive types? It is absolutely vital for aggregates - but there's not that big of a step from aggregate types to arithmetic ones, as no <code>initializer_list</code> is involved in both cases. Don't forget that it can e.g. be useful to prevent narrowing as well.</p>\n<blockquote>\n<p id=\"so_31896298_31897231_2\"><code>std::initialiser_list</code> takes <code>{ args... }</code>, and as such cannot have\n  indeterminate length at the time of compilation.</p>\n</blockquote>\n<p>Well, technically speaking,</p>\n<pre><code>std::initializer_list&lt;int&gt; f(bool b) {\n    return b? std::initializer_list&lt;int&gt;{} : std::initializer_list&lt;int&gt;{1};\n}\n</code></pre>\n", "LastActivityDate": "2015-08-08T18:33:22.743", "CommentCount": "4", "CreationDate": "2015-08-08T18:33:22.743", "ParentId": "31896298", "Score": "0", "OwnerUserId": "3647361"}});