post_cb({"24714262": {"Id": "24714262", "PostTypeId": "2", "Body": "<p>Changing the active member of a union requires special care to object lifetime.  The C++ Standard says (9.5p4):</p>\n<blockquote>\n<p id=\"so_24713833_24714262_0\"><em>Note:</em> In general, one must use explicit destructor calls and placement new operators to change the active\n  member of a union.</p>\n</blockquote>\n<p>When the members are plain old data, it generally \"just works\", even though you aren't calling constructors (using placement <code>new</code>) and destructors.  That's because the lifetime for objects with trivial initialization begins \"when storage is obtained\" of sufficient size and correct alignment, and the union provides that.</p>\n<p>Now you've got members with non-trivial constructor and destructor.  Their lifetime doesn't begin when storage is obtained, you <em>also</em> have to cause initialization to finish.  And that means placement new.  Skipping destructor calls isn't safe either, you get undefined behavior if those destructors would have had side effects your program relies on (and a <code>unique_ptr</code> destructor has the side effect of deallocating its target).</p>\n<p>Thus you are calling a move-assignment operator on a member whose lifetime hasn't begun.  That is undefined behavior.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-07-12T15:19:48.197", "Score": "10", "CreationDate": "2014-07-12T15:10:38.163", "ParentId": "24713833", "CommentCount": "1", "OwnerUserId": "103167", "LastEditDate": "2014-07-12T15:19:48.197"}, "24714271": {"Id": "24714271", "PostTypeId": "2", "Body": "<p>For unrestricted union, you have to manage yourself some construct/destruction.</p>\n<p>Following may help:</p>\n<pre><code>union myUnion{\n    std::unique_ptr&lt;float&gt; upFloat;\n    std::unique_ptr&lt;int&gt; upInt;\n\n    myUnion(){ new (&amp;upFloat) std::unique_ptr&lt;float&gt;{};}\n    ~myUnion() {}\n};\n\nclass myStruct\n{\npublic:\n    ~myStruct()\n    {\n        destroy();\n    }\n\n    void destroy()\n    {\n        switch (type)\n        {\n            case unionType::f: num.upFloat.~unique_ptr&lt;float&gt;(); break;\n            case unionType::i: num.upInt.~unique_ptr&lt;int&gt;(); break;\n        }\n    }\n\n    void set(std::unique_ptr&lt;int&gt; p)\n    {\n        destroy();\n        new (&amp;num.upInt) std::unique_ptr&lt;int&gt;{std::move(p)};\n        type = unionType::i;\n    }\n    void set(std::unique_ptr&lt;float&gt; p)\n    {\n        destroy();\n        new (&amp;num.upFloat) std::unique_ptr&lt;float&gt;{std::move(p)};\n        type = unionType::f;\n    }\n\npublic:\n    enum class unionType {f, i} type = unionType::f; // match the default constructor of enum\n    myUnion num;\n};\n\nint main()\n{\n    myStruct aStruct, bStruct;\n\n    aStruct.set(std::make_unique&lt;float&gt;(3.14f));\n    bStruct.set(std::make_unique&lt;int&gt;(3));\n\n    std::cout &lt;&lt; \"aStruct float = \" &lt;&lt; *aStruct.num.upFloat &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"bStruct int = \" &lt;&lt; *bStruct.num.upInt &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>In C++17, you may use <code>std::variant</code> instead of your own struct</p>\n", "LastEditorUserId": "2684539", "LastActivityDate": "2017-11-17T14:15:34.687", "Score": "6", "CreationDate": "2014-07-12T15:11:36.517", "ParentId": "24713833", "CommentCount": "2", "OwnerUserId": "2684539", "LastEditDate": "2017-11-17T14:15:34.687"}, "24713833": {"ViewCount": "1529", "Body": "<p>Trying to use a unique_ptr inside a union gives me a segfault when I try to std::move or std::make_unique it.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nunion myUnion{\n    struct{std::unique_ptr&lt;float&gt; upFloat;}structUpFloat;\n    struct{std::unique_ptr&lt;int&gt; upInt;}structUpInt;\n    myUnion(){}\n    ~myUnion(){}\n};\nstruct myStruct{\n    int x;\n    myUnion num;\n\n};\nint main()\n{\n    myStruct aStruct, bStruct;\n    aStruct.x = 1;\n    bStruct.x = 2;\n\n    auto upF = std::make_unique&lt;float&gt;(3.14);\n    auto upI = std::make_unique&lt;int&gt;(3);\n\n    aStruct.num.structUpFloat.upFloat = std::move(upF);\n    bStruct.num.structUpInt.upInt = std::move(upI);\n\n    std::cout &lt;&lt; \"aStruct float = \" &lt;&lt; *aStruct.num.structUpFloat.upFloat &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"bStruct int = \" &lt;&lt; *bStruct.num.structUpInt.upInt &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>However, using a normal pointer works as expected:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nunion myUnion{\n    struct{float *pFloat;}structPFloat;\n    struct{int *pInt;}structPInt;\n    myUnion(){}\n    ~myUnion(){}\n};\nstruct myStruct{\n    int x;\n    myUnion num;\n\n};\nint main()\n{\n    myStruct aStruct, bStruct;\n    aStruct.x = 1;\n    bStruct.x = 2;\n\n    auto upF = std::make_unique&lt;float&gt;(3.14);\n    auto upI = std::make_unique&lt;int&gt;(3);\n\n    aStruct.num.structPFloat.pFloat = upF.get();\n    bStruct.num.structPInt.pInt = upI.get();\n\n    std::cout &lt;&lt; \"aStruct float = \" &lt;&lt; *aStruct.num.structPFloat.pFloat &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"bStruct int = \" &lt;&lt; *bStruct.num.structPInt.pInt &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>This is using clang.3.4.2 or gcc.4.9.0. So I'm assuming that I am doing something wrong here. Any help would be appreciated.</p>\n<p>EDIT:</p>\n<p>Ok, so it's probably a nice thing to do to share the code I settled on. Big thanks to everyone who pointed me to managing the lifetime of my pointers in variant members using placement new.</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nstruct myStruct\n{\npublic:\n    union\n    {\n        std::unique_ptr&lt;float&gt; upFloat;\n        std::unique_ptr&lt;int&gt; upInt;\n    };\n    enum class unionType {f, i,none} type = unionType::none; // Keep it sane\n    myStruct(){}\n    myStruct(std::unique_ptr&lt;float&gt; p)\n    {\n        new (&amp;upFloat) std::unique_ptr&lt;float&gt;{std::move(p)};\n        type = unionType::f;\n    }\n    myStruct(std::unique_ptr&lt;int&gt; p)\n    {\n        new (&amp;upInt) std::unique_ptr&lt;int&gt;{std::move(p)};\n        type = unionType::i;\n    }\n    ~myStruct()\n    {\n        switch (type)\n        {\n            case unionType::f: upFloat.~unique_ptr&lt;float&gt;(); break;\n            case unionType::i: upInt.~unique_ptr&lt;int&gt;(); break;\n        }\n    }\n};\n\nint main()\n{\n    std::vector&lt;std::unique_ptr&lt;myStruct&gt;&gt; structVec;\n    structVec.push_back(std::make_unique&lt;myStruct&gt;(std::make_unique&lt;float&gt;(3.14f)));\n    structVec.push_back(std::make_unique&lt;myStruct&gt;(std::make_unique&lt;int&gt;(739)));\n    structVec.push_back(std::make_unique&lt;myStruct&gt;());\n    structVec.push_back(std::make_unique&lt;myStruct&gt;(std::make_unique&lt;float&gt;(8.95f)));\n    structVec.push_back(std::make_unique&lt;myStruct&gt;(std::make_unique&lt;int&gt;(3)));\n    structVec.push_back(std::make_unique&lt;myStruct&gt;());\n\n    for(auto &amp;a: structVec)\n    {\n        if(a-&gt;type == myStruct::unionType::none)\n        {\n            std::cout &lt;&lt; \"Struct Has Unallocated Union\" &lt;&lt; std::endl;\n        }\n        else if(a-&gt;type == myStruct::unionType::f)\n        {\n            std::cout &lt;&lt; \"Struct float = \" &lt;&lt; *a-&gt;upFloat &lt;&lt; std::endl;\n        }\n        else\n        {\n            std::cout &lt;&lt; \"Struct int = \" &lt;&lt; *a-&gt;upInt &lt;&lt; std::endl;\n        }\n        std::cout &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Outputs:</p>\n<p>Struct float = 3.14</p>\n<p>Struct int = 739</p>\n<p>Struct Has Unallocated Union</p>\n<p>Struct float = 8.95</p>\n<p>Struct int = 3</p>\n<p>Struct Has Unallocated Union</p>\n", "AcceptedAnswerId": "24714271", "Title": "Using a union with unique_ptr", "CreationDate": "2014-07-12T14:21:26.970", "Id": "24713833", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-09-16T02:40:44.470", "LastEditorUserId": "718379", "LastActivityDate": "2017-11-17T14:15:34.687", "Score": "10", "OwnerUserId": "2822810", "Tags": "<c++><c++11><struct><unions><unique-ptr>", "AnswerCount": "4"}, "24714285": {"Id": "24714285", "PostTypeId": "2", "Body": "<p>From \u00a712.6.2[class.base.init]/p8 of the standard (emphasis added):</p>\n<blockquote>\n<p id=\"so_24713833_24714285_0\">In a non-delegating constructor, if a given non-static data member or\n  base class is not designated by a\n  <em>mem-initializer-id</em> (including the case where there is no <em>mem-initializer-list</em> because the constructor has no\n  <em>ctor-initializer</em>) and the entity is not a virtual base class of an abstract class (10.4), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a <em>brace-or-equal-initializer</em>, the entity is initialized as specified in 8.5;</li>\n<li><strong>otherwise, if the entity is a variant member (9.5), no initialization is performed</strong>;</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>Union members are variant members, which means that the <code>unique_ptr</code>s are left uninitialized. In particular, no constructor, not even the default one, is called. Technically, the lifetime of these <code>unique_ptr</code>s never even began.</p>\n<p>The <code>unique_ptr</code> move assignment operator must delete what the <code>unique_ptr</code> is currently holding, but you are move-assigning to an uninitialized \"<code>unique_ptr</code>\" containing garbage values. As a result, your move assignment likely caused an attempt to delete a garbage pointer, causing a segfault.</p>\n", "LastActivityDate": "2014-07-12T15:13:13.320", "CommentCount": "0", "CreationDate": "2014-07-12T15:13:13.320", "ParentId": "24713833", "Score": "2", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_24713833_24714262_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5916}, "so_24713833_24714285_0": {"length": 17, "quality": 0.6538461538461539, "section_id": 435}}, "n3337": {"so_24713833_24714262_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5688}, "so_24713833_24714285_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 427}}, "n4659": {"so_24713833_24714262_0": {"length": 12, "quality": 0.8, "section_id": 7409}, "so_24713833_24714285_0": {"length": 17, "quality": 0.6538461538461539, "section_id": 454}}}, "24713958": {"Id": "24713958", "PostTypeId": "2", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/union\" rel=\"nofollow\">this reference</a>:</p>\n<blockquote>\n<p id=\"so_24713833_24713958_0\">If a union contains a non-static data member with a non-trivial special member function (copy/move constructor, copy/move assignment, or destructor) that function is deleted by default in the union and needs to be defined explicitly by the programmer.</p>\n</blockquote>\n<p>I assume that the reason you wrapped the pointers in simple structures is because you could not build it otherwise, due to the restrictions imposed by the above paragraph.</p>\n<p>What you have done instead is bypassed the compilers safety-guards, and probably have <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\"><em>undefined behavior</em></a> in your code.</p>\n", "LastActivityDate": "2014-07-12T14:35:12.157", "CommentCount": "2", "CreationDate": "2014-07-12T14:35:12.157", "ParentId": "24713833", "Score": "4", "OwnerUserId": "440558"}});