post_cb({"19000992": {"CommentCount": "2", "ViewCount": "677", "CreationDate": "2013-09-25T09:22:09.777", "LastActivityDate": "2013-09-25T09:51:59.113", "Title": "Iterating through an STL map with an iterator by different threads", "PostTypeId": "1", "Id": "19000992", "Score": "3", "Body": "<p>I have an STL map that will be accessed by two threads.\nNeither of them inserts nor removes elements: they just read.</p>\n<p>If it were just a simple array, I am sure that this would never cause trouble.\nHowever, the STL map is a complicated data structure whose implementation is unknown to me.\nWill this cause a data race? </p>\n", "Tags": "<c++><multithreading><stl><synchronization>", "OwnerUserId": "651473", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19000992_19001141_4": {"section_id": 6349, "quality": 0.8461538461538461, "length": 22}, "so_19000992_19001141_6": {"section_id": 6351, "quality": 0.8928571428571429, "length": 25}, "so_19000992_19001141_9": {"section_id": 6354, "quality": 0.6666666666666666, "length": 8}, "so_19000992_19001141_2": {"section_id": 6347, "quality": 0.9523809523809523, "length": 20}, "so_19000992_19001141_8": {"section_id": 6353, "quality": 0.8947368421052632, "length": 17}, "so_19000992_19001141_1": {"section_id": 6346, "quality": 0.9310344827586207, "length": 27}, "so_19000992_19001141_5": {"section_id": 6350, "quality": 1.0, "length": 23}, "so_19000992_19001141_3": {"section_id": 6348, "quality": 0.9545454545454546, "length": 21}, "so_19000992_19001141_7": {"section_id": 6352, "quality": 1.0, "length": 16}}, "n3337": {"so_19000992_19001141_4": {"section_id": 6106, "quality": 0.8461538461538461, "length": 22}, "so_19000992_19001141_6": {"section_id": 6108, "quality": 0.8928571428571429, "length": 25}, "so_19000992_19001141_9": {"section_id": 6111, "quality": 0.6666666666666666, "length": 8}, "so_19000992_19001141_2": {"section_id": 6104, "quality": 0.9523809523809523, "length": 20}, "so_19000992_19001141_8": {"section_id": 6110, "quality": 0.8947368421052632, "length": 17}, "so_19000992_19001141_1": {"section_id": 6103, "quality": 0.9310344827586207, "length": 27}, "so_19000992_19001141_5": {"section_id": 6107, "quality": 1.0, "length": 23}, "so_19000992_19001141_3": {"section_id": 6105, "quality": 0.9545454545454546, "length": 21}, "so_19000992_19001141_7": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n4659": {"so_19000992_19001141_4": {"section_id": 7858, "quality": 0.8461538461538461, "length": 22}, "so_19000992_19001141_6": {"section_id": 7860, "quality": 0.8928571428571429, "length": 25}, "so_19000992_19001141_9": {"section_id": 7863, "quality": 0.6666666666666666, "length": 8}, "so_19000992_19001141_2": {"section_id": 7856, "quality": 0.9523809523809523, "length": 20}, "so_19000992_19001141_8": {"section_id": 7862, "quality": 0.8947368421052632, "length": 17}, "so_19000992_19001141_1": {"section_id": 7855, "quality": 0.9310344827586207, "length": 27}, "so_19000992_19001141_5": {"section_id": 7859, "quality": 1.0, "length": 23}, "so_19000992_19001141_3": {"section_id": 7857, "quality": 0.9545454545454546, "length": 21}, "so_19000992_19001141_7": {"section_id": 7861, "quality": 1.0, "length": 16}}}, "19001141": {"ParentId": "19000992", "LastEditDate": "2013-09-25T09:44:31.650", "CommentCount": "6", "CreationDate": "2013-09-25T09:28:33.593", "OwnerUserId": "1171191", "LastEditorUserId": "1171191", "PostTypeId": "2", "Id": "19001141", "Score": "2", "Body": "<p>Standard C++ containers (as of 2011) allow safe access by multiple concurrent readers (i.e. via <code>const</code> member functions).</p>\n<p>That is, you are ok (assuming the <code>const</code> member functions on the types you are using with the container follow the same rules: bitwise-<code>const</code> except on objects that are protected from access by other threads).</p>\n<p>If you are using an old implementation you may in theory have problems, but I doubt it.</p>\n<p>Here's an entire chunk of the Library introduction section of The Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\"><code>N3337</code></a>). I don't think any one of these paragraphs alone is enough to answer your question, so you get the whole lot!</p>\n<blockquote>\n<p id=\"so_19000992_19001141_0\">17.6.5.9 Data race avoidance <strong>[res.on.data.races]</strong></p>\n<p id=\"so_19000992_19001141_1\">1 This section specifies requirements that implementations shall meet to prevent data\n  races (1.10). Every standard library function shall meet each\n  requirement unless otherwise specified. Implementations may prevent\n  data races in cases other than those specified below.</p>\n<p id=\"so_19000992_19001141_2\">2 A C++ standard\n  library function shall not directly or indirectly access objects\n  (1.10) accessible by threads other than the current thread unless the\n  objects are accessed directly or indirectly via the function\u2019s\n  arguments, including this.</p>\n<p id=\"so_19000992_19001141_3\">3 A C++ standard library function shall not\n  directly or indirectly modify objects (1.10) accessible by threads\n  other than the current thread unless the objects are accessed directly\n  or indirectly via the function\u2019s non-const arguments, including this.</p>\n<p id=\"so_19000992_19001141_4\">4 [ Note: This means, for example, that implementations can\u2019t use a\n  static object for internal purposes without synchronization because it\n  could cause a data race even in programs that do not explicitly share\n  objects between threads. \u2014end note ]</p>\n<p id=\"so_19000992_19001141_5\">5 A C++ standard library function\n  shall not access objects indirectly accessible via its arguments or\n  via elements of its container arguments except by invoking functions\n  required by its specification on those container elements.</p>\n<p id=\"so_19000992_19001141_6\">6\n  Operations on iterators obtained by calling a standard library\n  container or string member function may access the underlying\n  container, but shall not modify it. [ Note: In particular, container\n  operations that invalidate iterators conflict with operations on\n  iterators associated with that container. \u2014end note ]</p>\n<p id=\"so_19000992_19001141_7\">7\n  Implementations may share their own internal objects between threads\n  if the objects are not visible to users and are protected against data\n  races.</p>\n<p id=\"so_19000992_19001141_8\">8 Unless otherwise specified, C++ standard library functions\n  shall perform all operations solely within the current thread if those\n  operations have effects that are visible (1.10) to users.</p>\n<p id=\"so_19000992_19001141_9\">9 [ Note: This allows implementations to parallelize operations if there are no visible side effects. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-09-25T09:44:31.650"}});