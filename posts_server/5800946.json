post_cb({"bq_ids": {"n4140": {"so_5800946_5801031_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_5800946_5800976_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_5800946_5800976_2": {"length": 7, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_5800946_5801031_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_5800946_5800976_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_5800946_5800976_2": {"length": 7, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_5800946_5801031_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_5800946_5800976_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_5800946_5800976_2": {"length": 7, "quality": 1.0, "section_id": 7428}}}, "5800946": {"ViewCount": "13469", "Body": "<p>Consider the following:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n\n    unsigned int x = 3;\n    unsigned int y = 5;\n\n    std::cout &lt;&lt; \"a: \" &lt;&lt; x - y        &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"b: \" &lt;&lt; ((int)x) - y &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"c: \" &lt;&lt; x - ((int)y) &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"d: \" &lt;&lt; ((int)x) - ((int)y) &lt;&lt; std::endl;\n\n}\n\n$ g++ -Wconversion -Wall uint_stackoverflow.cc -o uint_stackoverflow &amp;&amp; ./uint_stackoverflow\na: 4294967294\nb: 4294967294\nc: 4294967294\nd: -2\n</code></pre>\n<p>I understand why \"a\" doesn't give the expected result. But why \"b\" and \"c\" fail puzzles me. For \"b\" I thought after casting \"x\" to \"int\" the result will be \"int\" again.</p>\n<p>Could you please enlighten me?</p>\n<p>edit: Shouldn't the compiler warn? g++ (Ubuntu/Linaro 4.4.4-14ubuntu5) 4.4.5</p>\n<p>Thanks,</p>\n<p>Somebody</p>\n", "Title": "unsigned to signed conversion", "CreationDate": "2011-04-27T07:48:00.600", "LastActivityDate": "2016-04-06T11:43:33.103", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-04-27T07:56:23.493", "LastEditorUserId": "541705", "Id": "5800946", "Score": "11", "OwnerUserId": "541705", "Tags": "<c++>", "AnswerCount": "3"}, "5801031": {"Id": "5801031", "PostTypeId": "2", "Body": "<p>Quoting the standard as usual....</p>\n<p>For C++98, <strong>\u00a7[expr]/9:</strong></p>\n<blockquote>\n<p id=\"so_5800946_5801031_0\">Many binary operators that expect\n  operands of arithmetic or enumeration\n  type cause conversions and yield\n  result types in a similar way. The\n  purpose is to yield a common type,\n  which is also the type of the result.\n  This pattern is called the <em>usual\n  arithmetic conversions</em>, which are\n  defined as follows:</p>\n<ul>\n<li>If either operand is of type <code>long double</code>, the other shall be converted\n  to <code>long double</code>.</li>\n<li>Otherwise, if either operand is <code>double</code>, the other shall be converted\n  to <code>double</code>.</li>\n<li>Otherwise, if either operand is <code>float</code>, the other shall be converted\n  to <code>float</code>.</li>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both\n  operands.<sup>54)</sup></li>\n<li>Then, if either operand is <code>unsigned long</code> the other shall be converted to\n  <code>unsigned long</code>.</li>\n<li>Otherwise, if one operand is a <code>long int</code> and the other <code>unsigned int</code>,\n  then if a <code>long int</code> can represent all\n  the values of an <code>unsigned int</code>, the\n  <code>unsigned int</code> shall be converted to a\n  <code>long int</code>; otherwise both operands\n  shall be converted to <code>unsigned long\n  int</code>.</li>\n<li>Otherwise, if either operand is <code>long</code>, the other shall be converted\n  to <code>long</code>.</li>\n<li><strong>Otherwise, if either operand is <code>unsigned</code>, the other shall be\n  converted to <code>unsigned</code>.</strong></li>\n</ul>\n<p id=\"so_5800946_5801031_1\">[Note: otherwise, the only remaining\n  case is that both operands are <code>int</code> ]</p>\n</blockquote>\n<p>Basically, it can be summarized as</p>\n<ul>\n<li><code>long double</code> &gt; <code>double</code> &gt; <code>float</code> &gt; <code>unsigned long</code> &gt; <code>long</code> &gt; <code>unsigned</code> &gt; <code>int</code></li>\n<li>(Types smaller than <code>int</code> will be converted to <code>int</code>)</li>\n</ul>\n<p>The text is changed for C++0x (\u00a7[expr]/10) after the 5th item, but the effect on OP's code is the same: the <code>int</code> will be converted to an <code>unsigned</code>.</p>\n", "LastEditorUserId": "224671", "LastActivityDate": "2011-04-27T08:03:46.563", "Score": "10", "CreationDate": "2011-04-27T07:58:40.653", "ParentId": "5800946", "CommentCount": "0", "OwnerUserId": "224671", "LastEditDate": "2011-04-27T08:03:46.563"}, "5801021": {"Id": "5801021", "PostTypeId": "2", "Body": "<p>It's because there is a heirarchy of data types when performing implicit conversions, unsigned integers have a higher precedence than signed integers so b and c are being cast back to unsigned integers which is why you're seeing the results you are.</p>\n<p>If you are unsure of the types but know the type of the result you want then you should cast both x and y as you did in d.</p>\n<p>This has a really good explanation of type conversion:</p>\n<p><a href=\"http://www.learncpp.com/cpp-tutorial/44-type-conversion-and-casting/\" rel=\"nofollow\">http://www.learncpp.com/cpp-tutorial/44-type-conversion-and-casting/</a></p>\n", "LastActivityDate": "2011-04-27T07:56:32.467", "CommentCount": "0", "CreationDate": "2011-04-27T07:56:32.467", "ParentId": "5800946", "Score": "3", "OwnerUserId": "77120"}, "5800976": {"Id": "5800976", "PostTypeId": "2", "Body": "<p>In arithmetic operations, if any of the operand is <code>unsigned</code>, the <em>other</em> operand converts to <code>unsigned</code> (if its <code>signed</code>), and the result of the operations will be <code>unsigned</code> also.</p>\n<p>Also, casting <code>unsigned</code> to <code>signed</code> and then doing the operation doesn't change the bit representation of the operand. On a two's complement architecture (i.e <em>almost</em> every modern architecture), <code>(int)x</code> has same bit representation as <code>x</code> has, only their interpretation changes when calculating their <em>value</em> in decimal system. But the important point is that the arithmetic operation is performed on the bit representations (<strong>not</strong> on their <em>values</em> in decimal system). And since the casting doesn't change the bit representation, the bit representation of the result will also NOT change.</p>\n<p>C++03 Standard says in \u00a75/9:</p>\n<blockquote>\n<p id=\"so_5800946_5800976_0\">Many binary operators that expect\n  operands of arithmetic or enumeration\n  type cause conversions and yield\n  result types in a similar way. The\n  purpose is to yield a common type,\n  which is also the type of the result.\n  This pattern is called the usual\n  arithmetic conversions, which are\n  defined as follows:</p>\n<p id=\"so_5800946_5800976_1\">[...]   </p>\n<p id=\"so_5800946_5800976_2\">Otherwise, <strong>if either operand is\n  unsigned, the other shall be converted\n  to unsigned</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "415784", "LastActivityDate": "2016-04-06T11:43:33.103", "Score": "26", "CreationDate": "2011-04-27T07:51:47.247", "ParentId": "5800946", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2016-04-06T11:43:33.103"}});