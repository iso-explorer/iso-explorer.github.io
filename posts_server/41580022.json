post_cb({"bq_ids": {"n4140": {"so_41580022_41580022_0": {"length": 14, "quality": 1.0, "section_id": 6185}}, "n4659": {"so_41580022_41580022_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7687}}}, "41580022": {"ViewCount": "482", "FavoriteCount": "1", "Title": "Constexpr placement new?", "CreationDate": "2017-01-10T23:05:33.413", "LastActivityDate": "2017-06-08T07:58:09.033", "CommentCount": "3", "Body": "<p>The C++ standard specifically bans calling <code>new</code> in a constant expression (N4296 section 5.20 [expr.const]):</p>\n<blockquote>\n<p id=\"so_41580022_41580022_0\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_41580022_41580022_1\">...</p>\n<p id=\"so_41580022_41580022_2\">\u2014 a new-expression (5.3.4);</p>\n</blockquote>\n<p>This ban (as far as I can see) extends to <em>all</em> forms of <code>new</code>, including placement new. However, since placement new doesn't actually allocate any memory and merely runs constructors at the given location, and since it's legal to take the address of a variable in a <code>constexpr</code> context (indeed, <code>std::addressof</code> will be constexpr in C++17), it seems to me that this prohibition could (in principle at least) be eased to allow placement new in constexpr functions.</p>\n<p>So my question is, am I missing something? Is there a good reason why placement new is forbidden in <code>constexpr</code> functions?</p>\n<p>(For context: the current rules pretty much require that constexpr-enabled sum types like <code>std::variant</code> are implemented as a recursive union. It would be nicer to be able to use something like <code>std::aligned_storage</code> and placement new, but currently that's not possible.)</p>\n", "PostTypeId": "1", "Id": "41580022", "Score": "12", "OwnerUserId": "2797826", "Tags": "<c++><language-lawyer><constexpr><placement-new>", "AnswerCount": "1"}, "44429923": {"Id": "44429923", "PostTypeId": "2", "Body": "<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nclass A {\npublic:\n    constexpr A() = default;\n    int a = 5;\n};\n\nconstexpr int foo() {\n    uint8_t space[sizeof(A)];\n    new(space) A();\n    A&amp; a = *reinterpret_cast&lt;A*&gt;(space);\n    return a.a;\n}\n\nint main() {\n  std::cout &lt;&lt; foo() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It is certainly imaginable that a compiler may understand the above program. Generally I don't think it is feasible because of the complexity necessary to ensure that the placement parameter always points to local memory.</p>\n<p>I don't think that the concept of \"memory\" even applies to constexpr functions because they are usually evaluated at compile time.</p>\n", "Score": "0", "LastActivityDate": "2017-06-08T07:58:09.033", "CreationDate": "2017-06-08T07:58:09.033", "ParentId": "41580022", "CommentCount": "0", "OwnerUserId": "3526980"}});