post_cb({"46595858": {"ParentId": "46595133", "Score": "3", "CreationDate": "2017-10-05T22:43:46.753", "Id": "46595858", "OwnerUserId": "459640", "LastActivityDate": "2017-10-05T22:43:46.753", "Body": "<p>That sentence on cppreference.com comes from the wording added to C++17 about the new support for parallel algorithms.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/algorithms.parallel.exec#3\" rel=\"nofollow noreferrer\">[algorithms.parallel.exec]/3</a> says:</p>\n<blockquote>\n<p id=\"so_46595133_46595858_0\">Unless otherwise stated, implementations may make arbitrary copies of elements (with type <code>T</code>) from sequences where <code>is_trivially_copy_constructible_v&lt;T&gt;</code> and <code>is_\u00adtrivially_\u00addestructible_\u00adv&lt;T&gt;</code> are true.</p>\n</blockquote>\n<p>Note this is in a context discussing parallel algorithms, defined as standard library function templates which have a template parameter named <code>ExecutionPolicy</code>.</p>\n<p>But then <a href=\"https://timsong-cpp.github.io/cppwp/algorithms#alg.foreach-9\" rel=\"nofollow noreferrer\">[alg.foreach]/9</a> says of <code>for_each(ExecutionPolicy&amp;&amp;, ForwardIterator, ForwardIterator, Function)</code>:</p>\n<blockquote>\n<p id=\"so_46595133_46595858_1\">Implementations do not have the freedom granted under [algorithms.parallel.exec] to make arbitrary copies of elements from the input sequence.</p>\n</blockquote>\n<p>Presumably some parallelization techniques can be more efficient for trivial types by making copies of the elements.  (Maybe to make them contiguous in memory? I'm just guessing.) </p>\n<p>So none of this applies to the older non-parallel <code>for_each(InputIterator first, InputIterator last, Function f)</code>.  For that algorithm, it's simply the case that since the <a href=\"https://timsong-cpp.github.io/cppwp/algorithms#alg.foreach-2\" rel=\"nofollow noreferrer\">effects</a> are specified as \"Applies <code>f</code> to the result of dereferencing every iterator in the range <code>[first, last)</code>...\", the functor argument must be e.g. <code>*first</code> and not a copy of <code>*first</code>.</p>\n", "PostTypeId": "2", "CommentCount": "1"}, "46595133": {"Tags": "<c++><language-lawyer>", "ViewCount": "132", "AnswerCount": "2", "CreationDate": "2017-10-05T21:34:34.360", "Title": "Is function passed to std::for_each allowed to make copies of sequence elements?", "CommentCount": "7", "AcceptedAnswerId": "46595338", "Score": "6", "OwnerUserId": "7949231", "Id": "46595133", "LastActivityDate": "2017-10-05T22:43:46.753", "Body": "<p>I've recently stumbled upon this wording from <a href=\"http://en.cppreference.com/w/cpp/algorithm/for_each\" rel=\"noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_46595133_46595133_0\">Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.</p>\n</blockquote>\n<p>Is the statement correct? I haven't found any grounds in the standard. Do I understand well, that it would btw. imply the following example from the same page invalid?</p>\n<pre><code>struct Sum\n{\n    Sum(): sum{0} { }\n    void operator()(int n) { sum += n; }\n    int sum;\n};\n\nint main()\n{\n    std::vector&lt;int&gt; nums{3, 4, 2, 8, 15, 267};\n\u00a0\n    // ...\n\u00a0\n    // calls Sum::operator() for each number\n    Sum s = std::for_each(nums.begin(), nums.end(), Sum());\n\u00a0\n    // ...\n}\n</code></pre>\n", "PostTypeId": "1"}, "46595338": {"ParentId": "46595133", "Score": "0", "CreationDate": "2017-10-05T21:51:55.130", "LastActivityDate": "2017-10-05T22:15:02.303", "LastEditDate": "2017-10-05T22:15:02.303", "OwnerUserId": "1122645", "LastEditorUserId": "1122645", "Body": "<p>The wording is indeed confusing, as it is also mentionned that</p>\n<blockquote>\n<p id=\"so_46595133_46595338_0\">The signature of the function should be equivalent to the following:<br>\n  void fun(const Type &amp;a); <br>\n  The signature does not need to have const &amp;.</br></br></p>\n</blockquote>\n<p>I think you need to see the fact that <code>for_each</code> is not allowed to make copies of the elements as a guarantee given by the standard to the user rather than a limitation on the user predicate function applied to each element.. </p>\n", "Id": "46595338", "PostTypeId": "2", "CommentCount": "2"}, "bq_ids": {"n4659": {"so_46595133_46595858_0": {"length": 14, "section_id": 1339, "quality": 0.9333333333333333}, "so_46595133_46595858_1": {"length": 11, "section_id": 1365, "quality": 0.9166666666666666}}}});