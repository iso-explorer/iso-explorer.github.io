post_cb({"5565522": {"CommentCount": "2", "AcceptedAnswerId": "5565706", "PostTypeId": "1", "LastEditorUserId": "193852", "CreationDate": "2011-04-06T11:23:43.760", "LastActivityDate": "2011-04-06T12:20:28.797", "LastEditDate": "2011-04-06T11:44:36.823", "ViewCount": "1180", "FavoriteCount": "4", "Title": "Can anyone explain this paragraph of the current C++0x standard draft?", "Id": "5565522", "Score": "13", "Body": "<p>Can anyone explain this statement from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">ISO N3242</a> \u00a73.2, 2nd point      </p>\n<blockquote>\n<p id=\"so_5565522_5565522_0\">An expression is potentially evaluated unless it is an unevaluated operand\n        (Clause 5) or a subexpression thereof. A variable or non-overloaded\n  function whose name appears as a potentially-evaluated expression is\n  odr-used unless  it is an object that satisfies the requirements for appearing in a\n  constant\n        expression (5.19) and the lvalue-to-rvalue conversion (4.1) is\n  immediately \n        applied. this is odr-used if it appears as a potentiallyevaluated\n  expression\n        (including as the result of the implicit transformation in the body of\n  a\n        non-static member function (9.3.1)).</p>\n</blockquote>\n<p>ISO Standard 2003 : says </p>\n<blockquote>\n<p id=\"so_5565522_5565522_1\">An expression is potentially evaluated unless it appears where an\n  integral \n         constant expression is required (see 5.19), is the operand of the\n  sizeof \n         operator (5.3.3), or is the operand of the typeid operator and the\n  expression\n         does not designate an lvalue of polymorphic class type (5.2.8). An\n  object or \n         non-overloaded function is used if its name appears in a\n  potentially-evaluated\n         expression.</p>\n</blockquote>\n<p>What is the actual difference in these statements?</p>\n<p>Can any one explain this with the help of an example/program?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "526255", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_5565522_5565706_0": {"section_id": 7040, "quality": 0.55, "length": 11}, "so_5565522_5565522_0": {"section_id": 7040, "quality": 0.5609756097560976, "length": 23}, "so_5565522_5565706_1": {"section_id": 7040, "quality": 0.75, "length": 6}}, "n3337": {"so_5565522_5565706_0": {"section_id": 6785, "quality": 0.8, "length": 16}, "so_5565522_5565522_0": {"section_id": 6785, "quality": 0.8536585365853658, "length": 35}, "so_5565522_5565706_1": {"section_id": 6785, "quality": 0.625, "length": 5}}, "n4659": {"so_5565522_5565522_0": {"section_id": 8537, "quality": 0.5609756097560976, "length": 23}, "so_5565522_5565706_0": {"section_id": 8537, "quality": 0.55, "length": 11}, "so_5565522_5565706_1": {"section_id": 8537, "quality": 0.75, "length": 6}}}, "5565706": {"ParentId": "5565522", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>\"unevaluated operand\" replaces \"is the operand of the sizeof operator (5.3.3), or is the operand of the typeid operator and the expression does not designate an lvalue of polymorphic class type (5.2.8)\". It has the same basic purpose, but doesn't try to list all the cases in the C++0x standard of operators whose operands aren't evaluated. <code>decltype</code> is a new one, for example.</p>\n<p>\"odr-used\" replaces \"used\", I presume they figured that \"used\" alone might be ambiguous with other uses of the word \"use\" in the standard. In both cases, though, it's defining the sense of \"used\" which is relevant to the ODR.</p>\n<p>So those aren't really changes, just re-wordings updated for C++0x.</p>\n<p>This is a change:</p>\n<blockquote>\n<p id=\"so_5565522_5565706_0\">A variable or non-overloaded function \n  whose name appears as a\n  potentially-evaluated expression is\n  odr-used unless     it is an object\n  that satisfies the requirements for\n  appearing in a constant   expression\n  (5.19) and the lvalue-to-rvalue\n  conversion (4.1) is immediately<br>\n  applied.</br></p>\n</blockquote>\n<p>vs.</p>\n<blockquote>\n<p id=\"so_5565522_5565706_1\">An object or     non-overloaded\n  function is used if its name appears\n  in a potentially-evaluated<br>\n  expression.</br></p>\n</blockquote>\n<p>Suppose <code>a</code> is a <code>static const int</code> at global scope. Then in C++03 it is not used in the following statement:</p>\n<pre><code>char x[a];\n</code></pre>\n<p>because the context <em>requires</em> a constant expression. However, it is used in the following:</p>\n<pre><code>void foo(int); foo(a);\n</code></pre>\n<p>because the context doesn't require a constant expression.</p>\n<p>In C++0x, <code>a</code> is <em>not</em> odr-used in either case. It's allowed to be in a constant expression, and in the function call, lvalue-rvalue conversion is immediately applied (because <code>foo</code> takes its parameter by value, not reference). So it qualifies for the \"unless\" which wasn't present in C++03.</p>\n<p>There's also a difference in the definition of \"potentially evaluated\". In the first example, <code>char x[a]</code>, <code>a</code> is potentially evaluated in C++03 but not in C++0x. I haven't checked whether anything else in the standard uses \"potentially evaluated\", that might be affected by this change. If it's only mentioned here then that part of it isn't a change, it's just that the exception has been moved from \"potentially evaluated\" to \"used\".</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2011-04-06T12:20:28.797", "Id": "5565706", "Score": "12", "CreationDate": "2011-04-06T11:39:17.817", "LastActivityDate": "2011-04-06T12:20:28.797"}});