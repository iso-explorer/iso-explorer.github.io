post_cb({"46605439": {"ParentId": "46605184", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It would be UB to call:</p>\n<pre><code>Base* base = new Derived;\ndelete base; // UB here if ~Base is not virtual.\n</code></pre>\n<p>unless destructor of <code>Base</code> is <code>virtual</code>.</p>\n<blockquote>\n<p id=\"so_46605184_46605439_0\">5.3.5/3 Delete</p>\n<p id=\"so_46605184_46605439_1\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.73)</p>\n</blockquote>\n<p>In your case, \"static type of the operand\" is <code>ExtraData</code> and \"its dynamic type\" is either <code>BarData</code> or <code>BooData</code>. So they are different, and the static type <code>ExtraData</code> must have a virtual destructor.</p>\n", "OwnerUserId": "2684539", "LastEditorUserId": "15416", "LastEditDate": "2017-10-06T13:16:06.433", "Id": "46605439", "Score": "6", "CreationDate": "2017-10-06T12:10:43.840", "LastActivityDate": "2017-10-06T13:16:06.433"}, "bq_ids": {"n4140": {"so_46605184_46605439_1": {"section_id": 6107, "quality": 0.8717948717948718, "length": 34}}, "n3337": {"so_46605184_46605439_1": {"section_id": 5873, "quality": 0.8717948717948718, "length": 34}}, "n4659": {"so_46605184_46605439_1": {"section_id": 7604, "quality": 0.8717948717948718, "length": 34}}}, "46605373": {"ParentId": "46605184", "CommentCount": "1", "Body": "<p>When you do <code>delete myExtradata;</code> the delete will have to know how to call the correct destructor for the object that is deleted. For that to work polymorphically, <code>ExtraData</code> needs to have a virtual destructor.</p>\n<p>It's not only needed for pointers, but in this specific case I'm sure <code>std::string</code> in <code>BarData</code> has at least one pointer internally.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "46605373", "Score": "2", "CreationDate": "2017-10-06T12:07:15.967", "LastActivityDate": "2017-10-06T12:07:15.967"}, "46605184": {"CommentCount": "10", "ViewCount": "109", "CreationDate": "2017-10-06T11:57:33.500", "LastActivityDate": "2017-10-06T13:16:06.433", "Title": "Virtual destructor for non pointer member variables", "AcceptedAnswerId": "46605439", "PostTypeId": "1", "Id": "46605184", "Score": "1", "Body": "<p>I have a question regarding virtual destructors. I know that if a variable pointer is polymorphic it is neccesary to create a virtual destructor, but if I don't need to do any destruction specific code is it necessary?</p>\n<p>For example, the following code:</p>\n<pre><code>struct Foo\n{\n    struct ExtraData\n    {\n        int myType;\n    }\n    struct BarData : public ExtraData\n    {\n        std::string myName;\n        float myFoo;\n    }\n    struct BooData : public ExtraData\n    {\n        int myBoo;\n        double myTime;\n    }\n    Foo() {}\n    ~Foo() { delete myExtradata; }\n\n    int myA;\n    int myB;\n    ExtraData* myExtraData;\n};\n</code></pre>\n<p>myExtraData is created from outside the struct, it can be either via new BarData() or via new BooData(). Would BarData and BooData need a virtual destructor. Or since they don't have member pointer it's okay?</p>\n", "Tags": "<c++><c++11><pointers><destructor>", "OwnerUserId": "8732106", "AnswerCount": "2"}});