post_cb({"2535232": {"ParentId": "2535148", "LastEditDate": "2010-03-29T01:17:48.433", "CommentCount": "6", "CreationDate": "2010-03-29T00:44:09.030", "OwnerUserId": "12711", "LastEditorUserId": "12711", "PostTypeId": "2", "Id": "2535232", "Score": "4", "Body": "<p>For scenario 1, the compiler should not perform any of the reorderings you mention.  For scenario 2, the answer might depend on:</p>\n<ul>\n<li>and whether the <code>b</code> and <code>c</code> variables are visible outside the current function (either by being non-local or having had their address passed </li>\n<li>who you talk to (apparently there is some disagreement about how string <code>volatile</code> is in C/C++)</li>\n<li>your compiler implementation</li>\n</ul>\n<p>So (softening my first answer), I'd say that if you're depending on certain behavior in scenario 2, you'd have to treat it as non-portable code whose behavior on a particular platform would have be determined by whatever the implementation's documentation might indicate (and if the docs said nothing about it, then you're out of luck with a guaranteed behavior.</p>\n<p>from C99 5.1.2.3/2 \"Program execution\":</p>\n<blockquote>\n<p id=\"so_2535148_2535232_0\">Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects, which are changes in the state of the  execution  environment.  Evaluation  of  an  expression  may  produce  side  effects.  At certain specified points in the execution sequence called sequence points, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place. </p>\n<p id=\"so_2535148_2535232_1\">...</p>\n<p id=\"so_2535148_2535232_2\">(paragraph 5) The least requirements on a conforming implementation are:</p>\n<ul>\n<li>At sequence points, volatile objects are stable in the sense that previous accesses are complete and subsequent accesses have not yet occurred.</li>\n</ul>\n</blockquote>\n<p>Here's a little of what Herb Sutter has to say about the required behavior of <code>volatile</code> accesses in C/C++ (from \"<code>volatile</code> vs. <code>volatile</code>\" <a href=\"http://www.ddj.com/hpc-high-performance-computing/212701484\" rel=\"noreferrer\">http://www.ddj.com/hpc-high-performance-computing/212701484</a>) :</p>\n<blockquote>\n<p id=\"so_2535148_2535232_3\">what about nearby ordinary reads and writes -- can those still be reordered around unoptimizable reads and writes? Today, there is no practical portable answer because C/C++ compiler implementations vary widely and aren't likely to converge anytime soon. For example, one interpretation of the C++ Standard holds that ordinary reads can move freely in either direction across a C/C++ volatile read or write, but that an ordinary write cannot move at all across a C/C++ volatile read or write -- which would make C/C++ volatile both less restrictive and more restrictive, respectively, than an ordered atomic. Some compiler vendors support that interpretation; others don't optimize across volatile reads or writes at all; and still others have their own preferred semantics. </p>\n</blockquote>\n<p>And for what it's worth, Microsoft documents the following for the C/C++ <code>volatile</code> keyword (as Microsoft-sepcific):</p>\n<blockquote>\n<ul>\n<li><p id=\"so_2535148_2535232_4\">A write to a volatile object (volatile write) has Release semantics; a reference to a global or static object that occurs before a write to a volatile object in the instruction sequence will occur before that volatile write in the compiled binary.</p></li>\n<li><p id=\"so_2535148_2535232_5\">A read of a volatile object (volatile read) has Acquire semantics; a reference to a global or static object that occurs after a read of volatile memory in the instruction sequence will occur after that volatile read in the compiled binary.</p></li>\n</ul>\n<p id=\"so_2535148_2535232_6\">This allows volatile objects to be used for memory locks and releases in multithreaded applications.</p>\n</blockquote>\n", "LastActivityDate": "2010-03-29T01:17:48.433"}, "38257239": {"ParentId": "2535148", "LastEditDate": "2016-07-11T15:20:09.057", "CommentCount": "0", "CreationDate": "2016-07-08T00:22:19.443", "OwnerUserId": "363751", "LastEditorUserId": "363751", "PostTypeId": "2", "Id": "38257239", "Score": "0", "Body": "<p>Some compilers regard accesses to volatile-qualified objects as a memory fence.  Others do not.  Some programs are written to require that <code>volatile</code> works as a fence.  Others aren't.</p>\n<p>Code which is written to require fences, running on platforms that provide them, may run better than code which is written to not require fences, running on platforms that don't provide them, but code which requires fences will malfunction if they are not provided.  Code which doesn't require fences will often run slower on platforms that provide them than would code which does require the fences, and implementations which provide fences will run such code more slowly than those that don't.</p>\n<p>A good approach may be to define a macro <code>semi_volatile</code> as expanding to nothing on systems where <code>volatile</code> implies a memory fence, or to <code>volatile</code> on systems where it doesn't.  If variables that need to have accesses ordered with respect to other <code>volatile</code> variables but not to each other are qualified as <code>semi-volatile</code>, and that macro is defined correctly, reliable operation will be achieved on systems with or without memory fences, and the most efficient operation that can be achieved on systems with fences will be achieved.  If a compiler actually implements a qualifier that works as required, <code>semivolatile</code>, it could be defined as a macro that uses that qualifier and achieve even better code.</p>\n<p>IMHO, that's an area the Standard really should address, since the concepts involved are applicable on many platforms, and any platform where fences aren't meaningful can simply ignore them.</p>\n", "LastActivityDate": "2016-07-11T15:20:09.057"}, "2535235": {"ParentId": "2535148", "CommentCount": "5", "Body": "<p>Volatile is not a memory fence. Assignments to B and C in snippet #2 can be eliminated or performed whenever. Why would you want the declarations in #2 to cause the behavior of #1?</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "2535235", "Score": "2", "CreationDate": "2010-03-29T00:45:09.870", "LastActivityDate": "2010-03-29T00:45:09.870"}, "2535148": {"CommentCount": "0", "ViewCount": "3957", "LastActivityDate": "2016-07-11T15:20:09.057", "Body": "<p>A compiler cannot eliminate or reorder reads/writes to a <code>volatile</code>-qualified variables.</p>\n<p>But what about the cases where other variables are present, which may or may not be <code>volatile</code>-qualified?</p>\n<h2>Scenario 1</h2>\n<pre><code>volatile int a;\nvolatile int b;\n\na = 1;\nb = 2;\na = 3;\nb = 4;\n</code></pre>\n<p>Can the compiler reorder first and the second, or third and the fourth assignments?</p>\n<h2>Scenario 2</h2>\n<pre><code>volatile int a;\nint b, c;\n\nb = 1;\na = 1;\nc = b;\na = 3;\n</code></pre>\n<p>Same question, can the compiler reorder first and the second, or third and the fourth assignments?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "2535246", "FavoriteCount": "1", "Title": "\"volatile\" qualifier and compiler reorderings", "Id": "2535148", "Score": "9", "CreationDate": "2010-03-29T00:15:40.897", "Tags": "<c++><c><volatile><compiler-optimization>", "OwnerUserId": "23643", "AnswerCount": "4"}, "2535246": {"ParentId": "2535148", "LastEditDate": "2010-03-29T01:27:15.950", "CommentCount": "5", "CreationDate": "2010-03-29T00:51:14.160", "OwnerUserId": "13005", "LastEditorUserId": "13005", "PostTypeId": "2", "Id": "2535246", "Score": "8", "Body": "<p>The C++ standard says (1.9/6):</p>\n<blockquote>\n<p id=\"so_2535148_2535246_0\">The observable behavior of the\n  abstract machine is its sequence of\n  reads and writes to volatile data and\n  calls to library I/O functions.</p>\n</blockquote>\n<p>In scenario 1, either of the changes you propose changes the sequence of writes to volatile data.</p>\n<p>In scenario 2, neither change you propose changes the sequence. So they're allowed under the \"as-if\" rule (1.9/1):</p>\n<blockquote>\n<p id=\"so_2535148_2535246_1\">... conforming implementations are\n  required to emulate (only) the\n  observable behavior of the abstract\n  machine ...</p>\n</blockquote>\n<p>In order to tell that this has happened, you would need to examine the machine code, use a debugger, or provoke undefined or unspecified behavior whose result you happen to know on your implementation. For example, an implementation might make guarantees about the view that concurrently-executing threads have of the same memory, but that's outside the scope of the C++ standard. So while the standard might permit a particular code transformation, a particular implementation could rule it out, on grounds that it doesn't know whether or not your code is going to run in a multi-threaded program.</p>\n<p>If you were to use observable behavior to test whether the re-ordering has happened or not (for example, printing the values of variables in the above code), then of course it would not be allowed by the standard.</p>\n", "LastActivityDate": "2010-03-29T01:27:15.950"}, "bq_ids": {"n4140": {"so_2535148_2535232_2": {"section_id": 5804, "quality": 0.6666666666666666, "length": 4}, "so_2535148_2535246_1": {"section_id": 5797, "quality": 1.0, "length": 8}}, "n3337": {"so_2535148_2535232_2": {"section_id": 5577, "quality": 0.6666666666666666, "length": 4}, "so_2535148_2535246_1": {"section_id": 5570, "quality": 1.0, "length": 8}}, "n4659": {"so_2535148_2535232_2": {"section_id": 7262, "quality": 0.6666666666666666, "length": 4}, "so_2535148_2535246_1": {"section_id": 7256, "quality": 1.0, "length": 8}}}});