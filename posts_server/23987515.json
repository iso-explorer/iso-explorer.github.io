post_cb({"23987660": {"ParentId": "23987515", "CommentCount": "1", "Body": "<p>memset is the simplest solution.</p>\n<pre><code>Cache::Cache()  \n{\n  memset(byte, 0, sizeof(byte));\n}\n</code></pre>\n", "OwnerUserId": "972281", "PostTypeId": "2", "Id": "23987660", "Score": "2", "CreationDate": "2014-06-02T05:09:12.713", "LastActivityDate": "2014-06-02T05:09:12.713"}, "23987570": {"ParentId": "23987515", "CommentCount": "1", "Body": "<p>In <code>Cache</code> constructor, when you do :</p>\n<pre><code>byte[16]={0};\n</code></pre>\n<p>You are only setting the 16th byte of your array (which is out of bounds, so this operation has undefined behavior). Array objects are default-initialized in C++, because you store <code>int</code>, no initialization is performed.</p>\n<p>You can use <code>std::fill</code> to initialize it  :</p>\n<pre><code>Cache::Cache()  \n{\n  std::fill(byte, byte+16, 0);\n}\n</code></pre>\n<p>Or you can use a regular for-loop over your array.</p>\n", "OwnerUserId": "3510483", "PostTypeId": "2", "Id": "23987570", "Score": "5", "CreationDate": "2014-06-02T04:58:03.200", "LastActivityDate": "2014-06-02T04:58:03.200"}, "23987601": {"ParentId": "23987515", "CommentCount": "0", "Body": "<p>The initialization of an array with {0} works only upon declaration of the array.</p>\n<p>You need a for loop inside the constructor that sets the array elements to zero.</p>\n", "OwnerUserId": "1416206", "PostTypeId": "2", "Id": "23987601", "Score": "0", "CreationDate": "2014-06-02T05:02:09.753", "LastActivityDate": "2014-06-02T05:02:09.753"}, "23987515": {"CommentCount": "5", "AcceptedAnswerId": "23987926", "PostTypeId": "1", "LastEditorUserId": "661519", "CreationDate": "2014-06-02T04:49:36.790", "LastActivityDate": "2014-06-05T13:05:41.607", "LastEditDate": "2014-06-02T05:59:16.557", "ViewCount": "5102", "FavoriteCount": "1", "Title": "Zero-initializing an array data member in a constructor", "Id": "23987515", "Score": "4", "Body": "<p>I've got an array of class objects, and inside the class object I've got another array that I'd need to initialize to all zeros.  The code compiles and runs, but my output is showing C\nrather than 0.</p>\n<p>From the header file:</p>\n<pre><code>class Cache {\nprivate:\n    int byte[16];\npublic:\n    Cache();\n    int getBytes(int);\n    ~Cache();\n};\n</code></pre>\n<p>From the cpp file</p>\n<pre><code>Cache::Cache()  \n{\n    byte[16]={0};\n}\n\nint Cache::getBytes(int j){\n    return byte[j];\n}\n</code></pre>\n<p>from the other cpp file</p>\n<pre><code>for (int i = 0; i &lt; 16; i++) \n{\n    for (int j = 0; j &lt; 16; j++)  //visual check of initializes main memory\n    {\n        cout &lt;&lt; cache[i].getBytes(j) &lt;&lt; \" \";\n}\n}\n</code></pre>\n<p>Is this being set up correctly?  As I mentioned, getBytes is returning 'C's rather than '0's as expected.</p>\n", "Tags": "<c++><arrays><constructor>", "OwnerUserId": "3011392", "AnswerCount": "6"}, "23987926": {"ParentId": "23987515", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Just use <em>value initialization</em> in the constructor initialization list. That is the idiomatic way of doing this in C++.</p>\n<pre><code>Cache::Cache() : byte()\n{ \n}\n</code></pre>\n<p>Note that C++11 allows this syntax too:</p>\n<pre><code>Cache::Cache() : byte{}\n{ \n}\n</code></pre>\n<p>In case you're wondering <em>why</em> this works, from the C++ 11 standard (note this also applies to C++03):</p>\n<blockquote>\n<p id=\"so_23987515_23987926_0\"><strong>C++11 \u00a7 8.5,p10</strong></p>\n<p id=\"so_23987515_23987926_1\">An object whose initializer is an empty set of parentheses, i.e., <strong>()</strong>, shall be <strong>value-initialized</strong>.</p>\n</blockquote>\n<p>That term <em>value-initialized</em> takes us to:</p>\n<blockquote>\n<p id=\"so_23987515_23987926_2\"><strong>C++11 \u00a7 8.5,p7</strong></p>\n<p id=\"so_23987515_23987926_3\">To value-initialize an object of type T means:</p>\n<ul>\n<li><p id=\"so_23987515_23987926_4\">if T is a (possibly cv-qualified) class type<sub>9</sub> with a user-provided constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p></li>\n<li><p id=\"so_23987515_23987926_5\">if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</p></li>\n<li><p id=\"so_23987515_23987926_6\"><strong>if T is an array type, then each element is value-initialized;</strong></p></li>\n<li><p id=\"so_23987515_23987926_7\"><strong>otherwise, the object is zero-initialized.</strong></p></li>\n</ul>\n</blockquote>\n<p>The third option in this trips the value-initialization of each element; the fourth applies once we get to each of those elements because they're (a) no class types, so (1) and (2) are gone, and (b) not arrays, so (3) is gone. That leaves only the last one, and your elements are zero-initialized.</p>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2014-06-05T13:05:41.607", "Id": "23987926", "Score": "18", "CreationDate": "2014-06-02T05:38:05.823", "LastActivityDate": "2014-06-05T13:05:41.607"}, "23987572": {"ParentId": "23987515", "CommentCount": "0", "Body": "<p>There are two problems with your code:</p>\n<pre><code>byte[16]={0};\n</code></pre>\n<p>Array has <code>0</code> based index, so maximum index in this case can be <code>15</code>, not <code>16</code>. You are corrupting the memory.</p>\n<p>Second, you have to loop through all the elements and initialize them. The way you are initializing will be done for one element only.</p>\n<pre><code>Cache::Cache()  \n{\n  for(int i=0;i&lt;16;i++)\n   byte[i]=0;\n}\n</code></pre>\n", "OwnerUserId": "1390091", "PostTypeId": "2", "Id": "23987572", "Score": "1", "CreationDate": "2014-06-02T04:58:21.757", "LastActivityDate": "2014-06-02T04:58:21.757"}, "bq_ids": {"n4140": {"so_23987515_23987926_1": {"section_id": 3290, "quality": 1.0, "length": 7}, "so_23987515_23987926_5": {"section_id": 3287, "quality": 0.75, "length": 12}, "so_23987515_23987926_3": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_23987515_23987926_6": {"section_id": 3287, "quality": 1.0, "length": 6}, "so_23987515_23987926_4": {"section_id": 3286, "quality": 0.625, "length": 10}}, "n3337": {"so_23987515_23987926_1": {"section_id": 3160, "quality": 1.0, "length": 7}, "so_23987515_23987926_5": {"section_id": 3157, "quality": 1.0, "length": 16}, "so_23987515_23987926_3": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_23987515_23987926_6": {"section_id": 3157, "quality": 1.0, "length": 6}, "so_23987515_23987926_4": {"section_id": 3157, "quality": 0.875, "length": 14}}, "n4659": {"so_23987515_23987926_1": {"section_id": 4052, "quality": 1.0, "length": 7}, "so_23987515_23987926_5": {"section_id": 4049, "quality": 0.6875, "length": 11}, "so_23987515_23987926_6": {"section_id": 4049, "quality": 1.0, "length": 6}, "so_23987515_23987926_4": {"section_id": 4049, "quality": 0.5625, "length": 9}}}, "23987744": {"ParentId": "23987515", "CommentCount": "2", "Body": "<p>You are doing it wrong on many levels. The syntax you use does not do what you think it does. What you are doing now is essentially initializing 17th element of the table to 0.</p>\n<p>In your case <code>memset</code> is probably the fastest and simplest. However, it would not work for complex types, so I would consider writing a simple snippet for general case like:</p>\n<pre><code>template&lt;typename T&gt;\ninline void zero_init(T array[], size_t elements){\n if( std::is_pod&lt;T&gt;() ) memset(array, 0, sizeof(T)*elements);\n else std::fill(begin(array), begin(array)+elements, 0);\n}\n</code></pre>\n<p>This will check if the type is a POD-type, which in this context means it can be initialized via <code>memset</code> and will put <code>0</code> for the whole table. If the <code>T</code> does not support it, then for each element an equivalent of <code>element = 0</code> will be called. Also the check is possible to be evaluated at the compile time, so most probably the <code>if</code> will be compiled away and a simple \"one-liner\" version will be created for each type at the compilation time.</p>\n<p>You can call it via:</p>\n<pre><code>Cache::Cache()  \n{\n  zero_init(byte, 16);\n}\n</code></pre>\n", "OwnerUserId": "1133179", "PostTypeId": "2", "Id": "23987744", "Score": "1", "CreationDate": "2014-06-02T05:20:46.617", "LastActivityDate": "2014-06-02T05:20:46.617"}});