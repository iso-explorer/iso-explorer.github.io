post_cb({"2166318": {"Id": "2166318", "PostTypeId": "2", "Body": "<p><code>using namespace</code> is <a href=\"http://www.parashift.com/c++-faq-lite/big-picture.html#faq-6.15\" rel=\"noreferrer\">evil</a>! Namespaces were <strong>made</strong> to prevent such problems as you have! But that said, try:</p>\n<pre><code>using namespace FirstLib;\nusing namespace SecondLib;\nusing SecondLib::Foobar;\n</code></pre>\n<p>or even (for some compilers):</p>\n<pre><code>using namespace FirstLib;\nusing namespace SecondLib;\ntypedef SecondLib::Foobar Foobar;\n</code></pre>\n", "LastEditorUserId": "233522", "LastActivityDate": "2010-01-30T00:54:48.380", "Score": "6", "CreationDate": "2010-01-30T00:49:26.397", "ParentId": "2166271", "CommentCount": "9", "OwnerUserId": "233522", "LastEditDate": "2010-01-30T00:54:48.380"}, "2167476": {"Id": "2167476", "PostTypeId": "2", "Body": "<p>It's strange nobody suggested to replace the full namespace use by the <strong>list of used class names</strong>. This solution is even in the <a href=\"http://www.parashift.com/c++-faq-lite/coding-standards.html#faq-27.5\" rel=\"nofollow noreferrer\">C++faq</a> (where I should have thought to look first).</p>\n<p>If we cannot say</p>\n<blockquote>\n<p id=\"so_2166271_2167476_0\">include all <code>FirstLib</code>, but remove <code>SecondLib::Foobar</code></p>\n</blockquote>\n<p>We can use <a href=\"http://www.parashift.com/c++-faq-lite/coding-standards.html#faq-27.5\" rel=\"nofollow noreferrer\">using-declarations</a> of the exact elements we need:</p>\n<pre><code>using FirstLib::Boids;\nusing FirstLib::Life;\n// no using FirstLib::Foobar...\n</code></pre>\n", "LastEditorUserId": "252124", "LastActivityDate": "2010-01-30T10:10:40.273", "Score": "2", "CreationDate": "2010-01-30T09:57:08.650", "ParentId": "2166271", "CommentCount": "0", "OwnerUserId": "252124", "LastEditDate": "2010-01-30T10:10:40.273"}, "2166366": {"Id": "2166366", "PostTypeId": "2", "Body": "<p>If you load all elements from both namespace to current scope by use of <code>using namespace</code> directove:</p>\n<pre><code>using namespace FirstLib;\nusing namespace SecondLib;\n</code></pre>\n<p>and there is potential that some of the names in those namespace may clash, then you need to tell compiler explicitly which of the element you want to use, in current scope, by use of <code>using</code> declaration:</p>\n<pre><code>using SecondLib::Foobar;\n</code></pre>\n<p>As the C++ standard says:</p>\n<blockquote>\n<p id=\"so_2166271_2166366_0\">7.3.3 The using declaration</p>\n<p id=\"so_2166271_2166366_1\">1  A using-declaration introduces a\n  name into the declarative region in\n  which the using-declaration appears.\n  That name is a synonym for the name of\n  some entity declared elsewhere.</p>\n</blockquote>\n<p>This line requests compiler to think <code>SecondLib::Foobar</code> whenever it sees <code>Foobar</code> for the rest of current scope in which the using declaration was used.</p>\n<p>The <code>using</code> directive and declaration is very helpful, but they may cause problems as the one you're dealing with. So, it's a good idea to narrow use of any form of <code>using</code> to minimal scope possible. You can use the directive <code>using namespace</code> in scope of other namespace</p>\n<pre><code>namespace MyApp {\n   using namespace ::SecondLib;\n}\n</code></pre>\n<p>or even a function. The same applies to <code>using</code> declaration. So, it's a good idea to narrow the scope of use of any of them:</p>\n<pre><code>void foo()\n{\n   ::SecondLib::Foobar fb;\n}\n</code></pre>\n<p>It may seem tedious, but it is only when you type, though you most likely use intellisense-enabled editor, so cost is really small, but benefits are large - no confusions, readable code, no compilation issues.</p>\n<p>It's also a very good idea to NOT to use <code>using namespace</code> in header scope. See <a href=\"https://stackoverflow.com/questions/410516/header-files-usage-best-practices-c\">Header files usage - Best practices - C++</a></p>\n<p>My own tip: do use full qualification whenever you need to use any of these types</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-01-30T01:04:59.070", "Score": "0", "CreationDate": "2010-01-30T01:04:59.070", "ParentId": "2166271", "CommentCount": "0", "OwnerUserId": "151641", "LastEditDate": "2017-05-23T12:16:50.650"}, "2166284": {"Id": "2166284", "PostTypeId": "2", "Body": "<p>You've basically answered your own question. You must explicitly say which class you want to use, so you must do <code>SecondLib::Foobar</code> whenever you use that class.</p>\n", "LastActivityDate": "2010-01-30T00:39:19.173", "CommentCount": "0", "CreationDate": "2010-01-30T00:39:19.173", "ParentId": "2166271", "Score": "1", "OwnerUserId": "36384"}, "bq_ids": {"n4140": {"so_2166271_2166366_1": {"length": 10, "quality": 0.625, "section_id": 5490}}, "n3337": {"so_2166271_2166366_1": {"length": 15, "quality": 0.9375, "section_id": 5276}}, "n4659": {"so_2166271_2166366_1": {"length": 11, "quality": 0.6875, "section_id": 6924}}}, "2166271": {"ViewCount": "8934", "Body": "<p>I am using two large libraries (GUI &amp; network) and I can happily do</p>\n<pre><code>using namespace FirstLib;\nusing namespace SecondLib;\n</code></pre>\n<p>Except for 1 single class called <code>Foobar</code> where names clash.</p>\n<p>I my code, I do not use <code>FirstLib::Foobar</code>. Is there a way to say \"in my code, whenever you see <code>Foobar</code>, think <code>SecondLib::Foobar</code> ?</p>\n", "AcceptedAnswerId": "2167476", "Title": "How to resolve a naming conflict between two libraries in C++?", "CreationDate": "2010-01-30T00:36:30.617", "Id": "2166271", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-01-30T10:10:40.273", "Score": "2", "OwnerUserId": "252124", "Tags": "<c++><namespaces>", "AnswerCount": "7"}, "2166279": {"Id": "2166279", "PostTypeId": "2", "Body": "<p>You have to pick one of these namespaces and get rid of the 'using', and explicitly call out all the class names. C# has a way around this, but C++ does not afaik...</p>\n", "LastActivityDate": "2010-01-30T00:38:38.187", "CommentCount": "0", "CreationDate": "2010-01-30T00:38:38.187", "ParentId": "2166271", "Score": "1", "OwnerUserId": "5728"}, "2166343": {"Id": "2166343", "PostTypeId": "2", "Body": "<p>I don't think there's a way of excluding names. You either bring in the whole lot, or each one individually. Even when you bring in the whole lot, you can always disambiguate conflicting names by qualifying them fully.</p>\n<p>However, you could use typedef to rename the offending class:</p>\n<pre><code>typedef Lib2::FooBar FooBaz;\n</code></pre>\n<p>And I guess, with a conflicting function, you could use a function pointer to \"rename\" the conflicting one.</p>\n<hr>\n<p>I guess it's kind of a non-solution. I can understand the occasional motivation to use using declarations - sometimes there are indeed many different names that you'll use all over the place - but if just one is conflicting: be explicit. It would be confusing to anyone familiar with the libraries anyway, seeing that both namespaces are imported.</p>\n<p>Also, using declarations respect scope: you can make one namespace visible in one function, but not the other namespace - assuming you don't even use it in that function.</p>\n</hr>", "LastEditorUserId": "155693", "LastActivityDate": "2010-01-30T01:07:52.500", "Score": "1", "CreationDate": "2010-01-30T00:56:51.183", "ParentId": "2166271", "CommentCount": "3", "OwnerUserId": "155693", "LastEditDate": "2010-01-30T01:07:52.500"}, "2166285": {"Id": "2166285", "PostTypeId": "2", "Body": "<p>Have you tried:</p>\n<pre><code>using SecondLib::Foobar;\n</code></pre>\n<p>?</p>\n", "LastActivityDate": "2010-01-30T00:39:19.330", "CommentCount": "1", "CreationDate": "2010-01-30T00:39:19.330", "ParentId": "2166271", "Score": "0", "OwnerUserId": "153535"}});