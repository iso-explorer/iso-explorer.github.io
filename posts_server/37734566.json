post_cb({"37737194": {"ParentId": "37734566", "LastEditDate": "2016-06-10T01:56:20.480", "CommentCount": "0", "CreationDate": "2016-06-09T22:26:24.073", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "PostTypeId": "2", "Id": "37737194", "Score": "1", "Body": "<p>Sort of.</p>\n<p>What you do instead is create a structure containing aligned storage with a custom destroyer that cleans up the object and a bool saying if you should do so.</p>\n<p>Then placement new the aligned storage.</p>\n<p>Now use the aliasing shared ptr constructor to return a pointer to the aligned storage as a different type.</p>\n", "LastActivityDate": "2016-06-10T01:56:20.480"}, "37734928": {"ParentId": "37734566", "CommentCount": "0", "Body": "<p>No, this is not possible (with <code>make_shared</code>).</p>\n<p>Since a custom allocator for class <code>T</code> will typically be written and optimized (for example with a pool) to expect allocations of size <code>T</code>, and <code>make_shared</code> will be allocating <em>more</em> memory than that, I imagine it wasn't deemed an important feature to support.</p>\n<p>Further, the standard provides <code>allocate_shared</code> for the case where you wish to use a custom allocator.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "37734928", "Score": "12", "CreationDate": "2016-06-09T19:46:49.333", "LastActivityDate": "2016-06-09T19:46:49.333"}, "bq_ids": {"n4140": {"so_37734566_37734566_1": {"section_id": 4439, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_37734566_37734566_1": {"section_id": 4276, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_37734566_37734566_1": {"section_id": 5704, "quality": 0.7333333333333333, "length": 11}}}, "37734566": {"CommentCount": "3", "ViewCount": "541", "CreationDate": "2016-06-09T19:24:49.940", "LastActivityDate": "2016-06-10T01:56:20.480", "Title": "Is it possible to force `std::make_shared` to use a class's new operator?", "AcceptedAnswerId": "37734928", "PostTypeId": "1", "Id": "37734566", "Score": "6", "Body": "<p>Is it possible to force <code>std::make_shared</code> to use a class's new operator?  This relates to another <a href=\"https://stackoverflow.com/questions/14080408/does-stdmake-shared-use-custom-allocators\">SO question</a>.  According to that question, <code>std::make_shared</code> uses a custom allocator:</p>\n<blockquote>\n<p id=\"so_37734566_37734566_0\">From the standard (\u00a720.7.2.2.6 shared_ptr creation ):</p>\n<p id=\"so_37734566_37734566_1\">Effects: Allocates memory suitable for an object of type T and constructs an object in that memory via the placement new expression\n  ::new (pv) T(std::forward(args)...).</p>\n</blockquote>\n<p>As such, I thought that I could use a custom placement new operator, but that appears to be false</p>\n<pre><code>// std::cout\n#include &lt;iostream&gt;\n\n// std::make_shared\n#include &lt;memory&gt;\n\n// Track what we're making\nstruct Foo {\n    Foo() {\n        std::cout &lt;&lt; \"Foo constructor\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; foo) {\n        std::cout &lt;&lt; \"Foo copy constructor\" &lt;&lt; std::endl;\n    }\n    Foo(Foo &amp;&amp; foo) {\n        std::cout &lt;&lt; \"Foo move constructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo const &amp; foo) {\n        std::cout &lt;&lt; \"Foo copy assignment\" &lt;&lt; std::endl;\n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; foo) {\n        std::cout &lt;&lt; \"Foo move assignment\" &lt;&lt; std::endl;\n        return *this;\n    }\n    void * operator new(std::size_t size) throw(std::bad_alloc) {\n        std::cout &lt;&lt; \"Foo new\" &lt;&lt; std::endl;\n        return ::operator new(size);\n    }\n    void * operator new(std::size_t size, void * p) throw() {\n        std::cout &lt;&lt; \"Foo placement new\" &lt;&lt; std::endl;\n        return ::operator new(size,p);\n    }\n    void* operator new (std::size_t size, std::nothrow_t const &amp; nothrow_value) \n        throw()\n    {\n        std::cout &lt;&lt; \"Foo nonthrowing new\" &lt;&lt; std::endl;\n        return ::operator new(size,nothrow_value);\n\n    }\n    void operator delete(void * p, std::size_t size) {\n        std::cout &lt;&lt; \"Foo delete\" &lt;&lt; std::endl;\n        ::operator delete(p);\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"Foo destructor\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"---Creating foo\" &lt;&lt; std::endl;\n    auto foo = std::make_shared &lt;Foo&gt; ();\n    std::cout &lt;&lt; \"---Creating foo2\" &lt;&lt; std::endl;\n    auto foo2 = std::shared_ptr &lt;Foo&gt; (new Foo());\n    std::cout &lt;&lt; \"---Creating foo3\" &lt;&lt; std::endl;\n    auto foo3 = std::allocate_shared &lt;Foo&gt; (std::allocator &lt;Foo&gt;());\n    std::cout &lt;&lt; \"---fin\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>which gives</p>\n<pre><code>---Creating foo\nFoo constructor\n---Creating foo2\nFoo new\nFoo constructor\n---Creating foo3\nFoo constructor\n---fin\nFoo destructor\nFoo destructor\nFoo delete\nFoo destructor\n</code></pre>\n<p>Also tucked in there was an attempt to force an allocator that would call the custom new operator with the call to <code>std::allocate_shared</code>.  In any case, is there a way to make <code>std::make_shared</code> call the custom new operators without defining a whole new allocator?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "1932452", "AnswerCount": "2"}});