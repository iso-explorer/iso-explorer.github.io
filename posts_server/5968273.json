post_cb({"bq_ids": {"n4140": {"so_5968273_5968583_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5988}, "so_5968273_5968583_0": {"length": 5, "quality": 1.0, "section_id": 6693}}, "n3337": {"so_5968273_5968583_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5756}, "so_5968273_5968583_0": {"length": 5, "quality": 1.0, "section_id": 6448}}, "n4659": {"so_5968273_5968583_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7488}, "so_5968273_5968583_0": {"length": 5, "quality": 1.0, "section_id": 8168}}}, "5968583": {"Id": "5968583", "PostTypeId": "2", "Body": "<p>In your example, the type of the parameter <code>S</code> in <code>foo2</code> is <code>C1</code>.  The friend relationship exists between <code>T2&lt;S&gt;</code> and <code>T1&lt;S&gt;</code>.  Although <code>C1</code> derives from <code>T1&lt;C1&gt;</code> it does not become a friend of all the friends of <code>T1&lt;C1&gt;</code>.</p>\n<p>In the expression <code>pT1-&gt;bar</code>, <code>bar</code> is found in <code>C1</code> and, as the friendship is not passed down to the derived class, it is private.</p>\n<p>Your example is using virtual functions so this can be addressed by explicitly referring to the <code>bar</code> that <strong>is</strong> a friend of our class:</p>\n<pre><code>void foo2(S *pT1) { pT1-&gt;template T1&lt;S&gt;::bar(); }\n</code></pre>\n<p>The access check now succeeds.</p>\n<p>The reference for this in the '03 C++ standard is in 11.4/10, where it simply says:</p>\n<blockquote>\n<p id=\"so_5968273_5968583_0\">Friendship is neither inherited nor transitive. </p>\n</blockquote>\n<p>Thanks to Potatoswatter for his comment.  By using the <code>qualified-id</code> for the <code>id-expession</code>, we disable virtual dispatch (5.2.2/1):</p>\n<blockquote>\n<p id=\"so_5968273_5968583_1\">If the selected function is non-virtual, or if the id-expression in the class member access expression is a quali\ufb01ed-id, that function is called.</p>\n</blockquote>\n<p>We can add a non-virtual dispatcher, or we can first convert the parameter to the base type and then make the call:</p>\n<pre><code> void foo2(S *pT1) { static_cast&lt; T1&lt;S&gt;* &gt; (pT1)-&gt;bar(); }\n</code></pre>\n<p>Virtual dispatch now takes place as required.</p>\n", "LastEditorUserId": "11698", "LastActivityDate": "2011-05-11T18:42:05.487", "Score": "9", "CreationDate": "2011-05-11T18:03:41.917", "ParentId": "5968273", "CommentCount": "6", "OwnerUserId": "11698", "LastEditDate": "2011-05-11T18:42:05.487"}, "5968273": {"ViewCount": "202", "Body": "<p>I'm seeing something I can't explain in the following code.  Under VS6, VS9, and GCC T2::foo2() gives the error: 'bar' : cannot access protected member declared in class 'C1'.  But if you remove C1::bar(), it compiles and runs correctly, even though T2 is still accessing the protected C1B:bar(), which you would think would be the same problem.</p>\n<p>Note, that in T2::foo2() you could cast 'pT1' to be a 'T1*' and everything is fine, but that still does not explain why C1B::bar() is allowed, but C1::bar() is not.</p>\n<pre><code>template&lt;class S&gt; class T2;\n\ntemplate&lt;class T&gt; class T1\n{\n    //template&lt;class T&gt; friend class T2;  --&gt; this doesn't compile under VS6\n    friend class T2&lt;T&gt;;\n\n    protected:\n        virtual void bar() { printf(\"T1\\n\"); }\n};\n\ntemplate&lt;class S&gt; class T2\n{\n    public:\n        void foo1(T1&lt;S&gt; *pT1) { pT1-&gt;bar(); }  // --&gt; ok, makes sense, this works either way\n        void foo2(S *pT1) { pT1-&gt;bar(); }  // --&gt; this fails to compile if C1::bar() is defined, but works for C1B::foo() ???\n};\n\nclass C1 : public T1&lt;C1&gt;\n{\n    protected:\n        virtual void bar() { printf(\"C1\\n\"); }  // --&gt; comment this out and foo2 will compile\n};\n\nclass C1B : public  C1\n{\n    protected:\n        virtual void bar() { printf(\"C1B\\n\"); }\n};\n\nclass C2 : public  T2&lt;C1&gt;\n{\n};\n\nvoid test(void)\n{\n    C1B c1b;\n    C2 c2;\n    c2.foo1(&amp;c1b);\n    c2.foo2(&amp;c1b);  // --&gt; fails to compile if C1::bar() exists\n}\n</code></pre>\n", "AcceptedAnswerId": "5968583", "Title": "C++ Template friend odd behavior", "CreationDate": "2011-05-11T17:35:04.087", "Id": "5968273", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-05-11T18:42:05.487", "Score": "6", "OwnerUserId": "749186", "Tags": "<c++><templates><friend>", "AnswerCount": "1"}});