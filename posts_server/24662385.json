post_cb({"bq_ids": {"n4140": {"so_24662385_24662879_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}}, "n3337": {"so_24662385_24662879_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}}, "n4659": {"so_24662385_24662879_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}}}, "24662385": {"ViewCount": "261", "Body": "<p>From: <a href=\"https://stackoverflow.com/questions/24662227/is-it-safe-to-overload-char-and-stdstring\">Is it safe to overload char* and std::string?</a></p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\nvoid foo(std::string str) {\n  std::cout &lt;&lt; \"std::string\\n\";\n}\n\nvoid foo(char* str) {\n  std::cout &lt;&lt; \"char*\\n\";\n}\n\nint main(int argc, char *argv[]) {\n  foo(\"Hello\");\n}\n</code></pre>\n<p>The above code prints \"char*\" when compiled with <code>g++-4.9.0 -ansi -pedantic -std=c++11</code>.</p>\n<p>I feel that this is incorrect, because the type of a string literal is \"array of <em>n</em> <code>const char</code>\", and it shouldn't be possible to initialize a non-<code>const</code> <code>char*</code> with it, so the <code>std::string</code> overload should be selected instead. Is gcc violating the standard here?</p>\n", "AcceptedAnswerId": "24662879", "Title": "Is this overload resolution correct?", "CreationDate": "2014-07-09T19:37:54.163", "Id": "24662385", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:56.900", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-01T19:02:24.350", "Score": "11", "OwnerUserId": "481267", "Tags": "<c++><c++11><language-lawyer><overload-resolution>", "AnswerCount": "1"}, "24662879": {"Id": "24662879", "PostTypeId": "2", "Body": "<p>First, the type of string literals: They are all constant arrays of their character type.</p>\n<blockquote>\n<h2>2.14.5 String literals [lex.string]</h2>\n<p id=\"so_24662385_24662879_0\">7 A string literal that begins with u8, such as u8\"asdf\", is a UTF-8 string literal and is initialized with the given characters as encoded in UTF-8.<br>\n  8 Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has static storage duration (3.7).<br>\n  9 A string literal that begins with u, such as u\"asdf\", is a char16_t string literal. A char16_t string literal has type \u201carray of n const char16_t\u201d, where n is the size of the string as defined below; it has static storage duration and is initialized with the given characters. A single c-char may produce more than one char16_t character in the form of surrogate pairs.<br>\n  10 A string literal that begins with U, such as U\"asdf\", is a char32_t string literal. A char32_t string literal has type \u201carray of n const char32_t\u201d, where n is the size of the string as defined below; it has static storage duration and is initialized with the given characters.<br>\n  11 A string literal that begins with L, such as L\"asdf\", is a wide string literal. A wide string literal has type \u201carray of n const wchar_t\u201d, where n is the size of the string as defined below; it has static storage duration and is initialized with the given characters.</br></br></br></br></p>\n</blockquote>\n<p>Next, lets see that we only have standard array decay, so from <code>T[#]</code> to <code>T*</code>:</p>\n<blockquote>\n<h2>4.2 Array-to-pointer conversion [conv.array]</h2>\n<p id=\"so_24662385_24662879_1\">1 An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>And last, lets see that any conforming extension must not change the meaning of a correct program:</p>\n<blockquote>\n<h2>1.4 Implementation compliance [intro.compliance]</h2>\n<p id=\"so_24662385_24662879_2\">1 The set of diagnosable rules consists of all syntactic and semantic rules in this International Standard except for those rules containing an explicit notation that \u201cno diagnostic is required\u201d or which are described as resulting in \u201cundefined behavior.\u201d<br>\n  2 Although this International Standard states only requirements on C++ implementations, those requirements are often easier to understand if they are phrased as requirements on programs, parts of programs, or execution of programs. Such requirements have the following meaning:</br></p>\n<ul>\n<li>If a program contains no violations of the rules in this International Standard, a conforming implementation shall, within its resource limits, accept and correctly execute2 that program.</li>\n<li>If a program contains a violation of any diagnosable rule or an occurrence of a construct described in this Standard as \u201cconditionally-supported\u201d when the implementation does not support that construct, a conforming implementation shall issue at least one diagnostic message.</li>\n<li>If a program contains a violation of a rule for which no diagnostic is required, this International\n  Standard places no requirement on implementations with respect to that program.</li>\n</ul>\n</blockquote>\n<p>So, in summary, it's a compiler bug.</p>\n<p>(Before C++11 (C++03) the conversion was allowed but deprecated, so it would have been correct. A diagnostic in case it happened would not have been required but provided as a quality of implementation issue.)</p>\n<p>It's a GCC bug, and also a clang bug.<br>\nBug report for clang: <a href=\"http://llvm.org/bugs/show_bug.cgi?id=16314\" rel=\"nofollow noreferrer\">http://llvm.org/bugs/show_bug.cgi?id=16314</a> (<a href=\"https://stackoverflow.com/questions/24662385/is-this-overload-resolution-correct/24662879#comment38233744_24662385\">Thanks to T.C. for finding the bug report.</a>)</br></p>\n<p>The test-case from the clang bug-report, which is much shorter:</p>\n<pre><code>void f(char*);\nint &amp;f(...);\nint &amp;r = f(\"foo\");\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-01T19:02:24.350", "Score": "7", "CreationDate": "2014-07-09T20:05:39.133", "ParentId": "24662385", "CommentCount": "1", "OwnerUserId": "3204551", "LastEditDate": "2017-05-23T12:32:56.900"}});