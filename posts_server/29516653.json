post_cb({"29516807": {"ParentId": "29516653", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29516653_29516807_0\">13.3.2 Viable functions\n  A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding parameter is considered to \u201cmatch the ellipsis\u201d (13.3.3.1.3).</p>\n</blockquote>\n<p>And also</p>\n<blockquote>\n<p id=\"so_29516653_29516807_1\">Viable functions\n  Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of viable functions\n  To be included in the set of viable functions, the candidate function must satisfy the following:<br/>\n  1) If there are M arguments, the candidate function that has exactly M parameters is viable<br/>\n  2) If the candidate function has less than M parameters, but has an ellipsis parameter, it is viable.<br/>\n  [...]<br/>\n<a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">Overloading resolution</a></p>\n</blockquote>\n", "OwnerUserId": "2534793", "PostTypeId": "2", "Id": "29516807", "Score": "0", "CreationDate": "2015-04-08T13:58:20.717", "LastActivityDate": "2015-04-08T13:58:20.717"}, "29516897": {"ParentId": "29516653", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There's a ranking of implicit conversion sequences, as defined in [over.ics.rank], emphasis mine:</p>\n<blockquote>\n<p id=\"so_29516653_29516897_0\">When comparing the basic forms of implicit conversion sequences...<br>\n   - a standard conversion sequence (13.3.3.1.1) is <strong>a better conversion sequence than</strong> a user-defined conversion\n  sequence or <strong>an ellipsis conversion sequence</strong>, and<br>\n   - a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion\n  sequence (13.3.3.1.3).</br></br></p>\n</blockquote>\n<p>So we have two functions:</p>\n<pre><code>static char   testFun( int (C::*)() ) { return char(); }\nstatic double testFun( ... ) { return double(); }\n</code></pre>\n<p>Both functions are viable for <code>testFun(0)</code>. The first would involve a \"null member pointer conversion\" as per [conv.mem], and is a standard conversion sequence. The second would match the ellipsis and be an ellipsis conversion sequence. By [over.ics.rank], the former is preferred. There's no ambiguity, the one is strictly better than the other. </p>\n<p>An ambiguous overload would arise if we had two <em>equivalent</em> conversion sequences that the compiler could not decide between. Consider if we had something like:</p>\n<pre><code>static char testFun(int* ) { return 0; }\nstatic int testFun(char* ) { return 0; }\n\ntestFun(0);\n</code></pre>\n<p>Now both overloads would be equivalent as far as the conversion sequences go, so we'd have two viable candidates. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-04-08T14:13:29.653", "Id": "29516897", "Score": "4", "CreationDate": "2015-04-08T14:02:25.090", "LastActivityDate": "2015-04-08T14:13:29.653"}, "bq_ids": {"n4140": {"so_29516653_29516807_0": {"section_id": 601, "quality": 0.8076923076923077, "length": 21}, "so_29516653_29516941_0": {"section_id": 638, "quality": 0.9230769230769231, "length": 12}, "so_29516653_29516941_1": {"section_id": 42, "quality": 0.9310344827586207, "length": 27}, "so_29516653_29516897_0": {"section_id": 638, "quality": 0.90625, "length": 29}}, "n3337": {"so_29516653_29516941_1": {"section_id": 39, "quality": 0.9310344827586207, "length": 27}, "so_29516653_29516897_0": {"section_id": 628, "quality": 0.90625, "length": 29}, "so_29516653_29516807_0": {"section_id": 591, "quality": 0.8076923076923077, "length": 21}, "so_29516653_29516941_0": {"section_id": 628, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_29516653_29516807_0": {"section_id": 627, "quality": 0.8076923076923077, "length": 21}, "so_29516653_29516897_0": {"section_id": 666, "quality": 0.90625, "length": 29}, "so_29516653_29516941_1": {"section_id": 42, "quality": 0.9310344827586207, "length": 27}, "so_29516653_29516941_0": {"section_id": 666, "quality": 0.9230769230769231, "length": 12}}}, "29516903": {"ParentId": "29516653", "CommentCount": "0", "Body": "<p>A null pointer literal 0 should be an exact match to a function accepting a function pointer and treated as stronger than matching anything (<code>...</code>).</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "29516903", "Score": "0", "CreationDate": "2015-04-08T14:02:47.490", "LastActivityDate": "2015-04-08T14:02:47.490"}, "29516941": {"ParentId": "29516653", "CommentCount": "0", "Body": "<p>You have a standard conversion vs an ellipsis conversion. The standard says that a standard conversion is a better conversion sequence than the latter. [over.ics.rank]/p2:</p>\n<blockquote>\n<p id=\"so_29516653_29516941_0\">a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion\n  sequence or an ellipsis conversion sequence</p>\n</blockquote>\n<p>A pointer-to-member conversion is a standard conversion sequence. <code>0</code> is a null pointer constant and can be converted to a pointer-to-member. [conv.mem]/p1:</p>\n<blockquote>\n<p id=\"so_29516653_29516941_1\">A null pointer constant (4.10) can be converted to a pointer to member type; the result is the null member\n  pointer value of that type and is distinguishable from any pointer to member not created from a null pointer\n  constant. Such a conversion is called a null member pointer conversion.</p>\n</blockquote>\n<p>Therefore the first overload is preferred.</p>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "29516941", "Score": "3", "CreationDate": "2015-04-08T14:04:24.397", "LastActivityDate": "2015-04-08T14:04:24.397"}, "29516653": {"CommentCount": "1", "AcceptedAnswerId": "29516941", "CreationDate": "2015-04-08T13:52:19.650", "LastActivityDate": "2015-04-08T14:13:29.653", "PostTypeId": "1", "ViewCount": "126", "FavoriteCount": "1", "Title": "Why no ambiguity in this function call?", "Id": "29516653", "Score": "3", "Body": "<p>I'm wondering why there's no ambiguity in this function call:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;class T&gt;\nclass C\n{\npublic:\n    typedef char c;\n    typedef double d;\n\n    int fun() {}\n\n    static c testFun( decltype(&amp;C::fun) ) {return c();} \n    static d testFun(...) { return d(); }\n};\n\nint main() {\n    C&lt;int&gt;::testFun(0); // Why no ambiguity?\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/241ce5ab82b4a018\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/241ce5ab82b4a018</a></p>\n", "Tags": "<c++>", "OwnerUserId": "4715851", "AnswerCount": "4"}});