post_cb({"4888888": {"ParentId": "4885676", "CommentCount": "1", "CreationDate": "2011-02-03T16:40:25.643", "OwnerUserId": "445976", "PostTypeId": "2", "Id": "4888888", "Score": "8", "Body": "<p>Using the <code>list::remove_if</code> member function, a temporary hashed set, and lambda expression.</p>\n<pre><code>std::list&lt;int&gt; l;\nstd::unordered_set&lt;int&gt; s;\n\nl.remove_if([&amp;](int n) {\n    return (s.find(n) == s.end()) ? (s.insert(n), false) : true;\n});\n</code></pre>\n", "LastActivityDate": "2011-02-03T16:40:25.643"}, "4885676": {"CommentCount": "5", "AcceptedAnswerId": "4888888", "PostTypeId": "1", "LastEditorUserId": "382974", "CreationDate": "2011-02-03T11:42:25.087", "LastActivityDate": "2014-10-01T01:12:37.173", "LastEditDate": "2011-02-04T10:55:34.683", "ViewCount": "8759", "FavoriteCount": "1", "Title": "Remove duplicates from a list<int>", "Id": "4885676", "Score": "6", "Body": "<p>Using STL algorithms (as much as possible) such as <code>remove_if()</code> and <code>list::erase</code>, is there a nice way to remove duplicates from a list defined as following:</p>\n<p><code>list&lt;int&gt; l;</code></p>\n<p>Please note that <code>list::unique()</code> only works if duplication occurs in consecutive elements. In my case, all duplicates have to be eliminated regardless of their position in the list. Moreover, removing duplicates mean preserving only one copy of each element in the final result.</p>\n<p>EDIT: The option to <code>l.sort()</code> followed by <code>l.unique()</code> cannot be availed as that will destroy the order of the list.</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "382974", "AnswerCount": "3"}, "4885823": {"ParentId": "4885676", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2011-02-03T11:56:39.280", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:06.053", "Id": "4885823", "OwnerUserId": "276451", "Body": "<p>He said he wanted to use the erase-remove idiom, so here's a possible way, using a function object:</p>\n<pre><code>struct Unifier{\n    set&lt;int&gt; foundElements;\n\n    bool operator()(int &amp; a){\n        if(foundElements.find(a) != foundElements.end()){\n            return true;\n        }else{\n            foundElements.insert(a);\n            return false;\n        }\n    }\n};\n\n\nint main(){\n    list&lt;int&gt; v;\n\n    v.push_back(5);\n    v.push_back(4);\n    v.push_back(5);\n    v.push_back(3);\n    v.push_back(5);\n    v.push_back(3);\n\n    copy (v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout,\" \"));\n\n    Unifier u;\n    v.remove_if(u);\n\n    cout &lt;&lt; endl &lt;&lt; \"After:\" &lt;&lt; endl;\n    copy (v.begin(), v.end(), ostream_iterator&lt;int&gt;(cout,\" \"));\n\n}\n</code></pre>\n<hr>\n<p><strong>Update</strong>: The above code has a subtle bug. According to C++11 <code>[algorithms.general]/10</code>:</p>\n<blockquote>\n<p id=\"so_4885676_4885823_0\">[Note: Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function objects freely. Programmers for whom object identity is important should consider using a wrapper class that points to a noncopied implementation object such as <code>reference_wrapper&lt;T&gt;</code> (20.8.3), or some equivalent solution. \u2014end note ]</p>\n</blockquote>\n<p>There appears to be no \"otherwise specified\" for <code>std::list::remove_if</code>, so this code may fail to remove all duplicates because it may create copies of the predicate at the start, and then use different copies of the predicate for different parts of the list. <a href=\"http://coliru.stacked-crooked.com/a/7a3ca9a84465c908\" rel=\"nofollow noreferrer\">Example of this actually happening for std::remove_if</a>.</p>\n<p>A simple fix for C++11 is to replace <code>v.remove_if(u)</code> with:</p>\n<pre><code>v.remove_if( reference_wrapper&lt;decltype(u)&gt;(u) );\n</code></pre>\n<p>In C++03 I'm not sure if the above quote was present; but if it was then a fix would be to make <code>foundElements</code> be static, or to refactor <code>Unifier</code> so that all copies of it reference a single instance of <code>foundElements</code>.</p>\n<p><a href=\"https://stackoverflow.com/questions/5397616/what-is-wrong-with-stdset/\">Link to related question</a></p>\n</hr>", "LastActivityDate": "2014-10-01T01:12:37.173"}, "bq_ids": {"n4140": {"so_4885676_4885823_0": {"section_id": 1243, "quality": 0.8571428571428571, "length": 30}}, "n3337": {"so_4885676_4885823_0": {"section_id": 1241, "quality": 0.8571428571428571, "length": 30}}, "n4659": {"so_4885676_4885823_0": {"section_id": 1331, "quality": 0.8571428571428571, "length": 30}}}, "4885787": {"ParentId": "4885676", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2011-02-03T11:53:03.270", "Score": "8", "LastEditorUserId": "120471", "LastEditDate": "2011-02-03T12:29:56.903", "Id": "4885787", "OwnerUserId": "120471", "Body": "<p>If preserving the order of the list is not important, you can just do <code>list.sort(); list.unique();</code></p>\n<p>If the order is important, use Rup's suggestion:</p>\n<pre><code>list&lt;int&gt;::iterator iter = l.begin();\nset&lt;int&gt; elements;\nwhile (iter != l.end()) {\n  if (elements.find(*iter) != elements.end())\n    iter = l.erase(iter);\n  else {\n    elements.insert(*iter);\n    ++iter;\n  }\n}\n</code></pre>\n", "LastActivityDate": "2011-02-03T12:29:56.903"}});