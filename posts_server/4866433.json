post_cb({"bq_ids": {"n4140": {"so_4866433_4866508_0": {"length": 15, "quality": 0.9375, "section_id": 5520}}, "n3337": {"so_4866433_4866508_0": {"length": 15, "quality": 0.9375, "section_id": 5306}}, "n4659": {"so_4866433_4866508_0": {"length": 15, "quality": 0.9375, "section_id": 6955}}}, "4866627": {"Id": "4866627", "PostTypeId": "2", "Body": "<p>Everything seems to work fine for me if I just omit the <code>extern \"C\"</code> from your typedef.  That is, the following compiles, links, and runs without warnings, errors, or problems:</p>\n<p>foo.c:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint foo(int x) {\n    return printf(\"%x\\n\", x);\n}\n</code></pre>\n<p>test.cpp:</p>\n<pre><code>extern \"C\" int foo(int);\n\ntemplate &lt;typename return_t_, typename arg1_t_&gt;\nstruct test\n{\n    typedef return_t_ (*C_fun1_t)(arg1_t_);\n    C_fun1_t myFn;\n};\n\nint main() {\n    test&lt;int, int&gt; t;\n    t.myFn = foo;\n    return t.myFn(5);\n}\n</code></pre>\n<p>For the C++ gurus: I don't know the finer points of what distinguishes C linkage from C++.  Are there any hidden problems that wouldn't turn up in a simple example like this?</p>\n", "LastActivityDate": "2011-02-01T18:44:15.943", "Score": "0", "CreationDate": "2011-02-01T18:44:15.943", "ParentId": "4866433", "CommentCount": "2", "OwnerUserId": "306405"}, "4866569": {"Id": "4866569", "PostTypeId": "2", "Body": "<p>Consider <code>typedef</code> of a <code>boost::function</code> or the STL function objects ... also you can't define a template inside a extern \"C\" block for some quite obvious reasons if you think about it.</p>\n", "LastActivityDate": "2011-02-01T18:39:08.147", "Score": "1", "CreationDate": "2011-02-01T18:39:08.147", "ParentId": "4866433", "CommentCount": "5", "OwnerUserId": "516725"}, "4866508": {"Id": "4866508", "PostTypeId": "2", "Body": "<p>C++03, \u00a77.5p4:</p>\n<blockquote>\n<p id=\"so_4866433_4866508_0\">A linkage-specification shall occur only in namespace scope. \u2026 A C language linkage is ignored for the names of class members and the member function type of class member functions.</p>\n</blockquote>\n<p>Unfortunately, you simply can't do this in current C++.  This text is unchanged in the latest C++0x draft, but \"template typedefs\" may be able to accomplish it.</p>\n", "LastActivityDate": "2011-02-01T18:34:09.363", "Score": "9", "CreationDate": "2011-02-01T18:34:09.363", "ParentId": "4866433", "CommentCount": "3", "OwnerUserId": "511601"}, "4866433": {"ViewCount": "1990", "Body": "<p>I want to add a public <code>typedef</code> to a template for a pointer to a function-taking-one-argument that uses \"C\" language linkage.</p>\n<p>I tried:</p>\n<pre><code>extern \"C\" {\n    template &lt;typename return_t_, typename arg1_t_&gt;\n    struct test\n    {\n        typedef return_t_ (*C_fun1_t)(arg1_t_);\n    };\n}\n</code></pre>\n<p>And:</p>\n<pre><code>template &lt;typename return_t_, typename arg1_t_&gt;\nstruct test\n{\n    extern \"C\" {\n        typedef return_t_ (*C_fun1_t)(arg1_t_);\n    }\n};\n</code></pre>\n<p>And:</p>\n<pre><code>template &lt;typename return_t_, typename arg1_t_&gt;\nstruct test\n{\n    extern \"C\" typedef return_t_ (*C_fun1_t)(arg1_t_);\n};\n</code></pre>\n<p>without success.</p>\n<p>Is what I am trying to accomplish possible?</p>\n", "AcceptedAnswerId": "4866508", "Title": "Is it possible to typedef a pointer-to-extern-\"C\"-function type within a template?", "CreationDate": "2011-02-01T18:25:11.317", "Id": "4866433", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-02-01T18:44:15.943", "Score": "8", "OwnerUserId": "196844", "Tags": "<c++><templates><typedef><extern>", "AnswerCount": "3"}});