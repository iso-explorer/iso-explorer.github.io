post_cb({"bq_ids": {"n4140": {"so_19107851_19108471_0": {"length": 22, "quality": 0.7857142857142857, "section_id": 3223}}, "n3337": {"so_19107851_19108471_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 3097}}, "n4659": {"so_19107851_19108471_0": {"length": 22, "quality": 0.7857142857142857, "section_id": 3980}}}, "19107851": {"ViewCount": "118", "Body": "<p><strong>Code</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n#define PF         cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n\nclass berlp {\npublic:\n    berlp() { }\n    void p() { }\n};\n\ntemplate &lt;typename T&gt;\nclass derp {\npublic:\n    derp() = default;\n\n    derp(const T &amp; a) : mem(a) {\n        a.p();\n        mem.p();\n\n        PF\n    }\n\n    template &lt;typename U&gt;\n    derp(U &amp;&amp; a) : mem(std::forward&lt;U&gt;(a)) {\n        PF\n    }\n\n    T       mem;\n};\n\nint main(int argc, const char * argv[])\n{\n    berlp                   one;\n    derp&lt;berlp &amp;&gt;           f(one);     // problems with this list below\n    derp&lt;const berlp &amp;&gt;     h(one);     // problem with this follows\n\n    return 0;\n}\n</code></pre>\n<p><strong>Output Using XCode and CLang</strong>\nThis all compiles fine, and here is the output...</p>\n<pre><code>derp&lt;berlp &amp;&gt;::derp(const T &amp;) [T = berlp &amp;]\nderp&lt;const berlp &amp;&gt;::derp(U &amp;&amp;) [T = const berlp &amp;, U = berlp &amp;]\n</code></pre>\n<p><strong>Problems</strong> </p>\n<p><code>derp&lt;berlp &amp;&gt; f(one);</code> : a.p() in the derp constructor should fail since \"a\" is \"const berlp &amp;\" after reference collapsing, and p() is not const.  Secondly, initialization of \"mem\" (berlp &amp;) with \"a\" (const berlp &amp;) should not work.  It seems like the \"const\" in \"derp(const T &amp; a)\" is just not doing anything.  Finally, why does it even use the first constructor and not the templated one which seems like it would do all of this without breaking the const?</p>\n<p><code>derp&lt;const berlp &amp;&gt; h(one);</code> : why does this call use the templated constructor when the other seems to be exactly what we are after?  This isn't too terrible a problem, since it doesn't seem to break anything, but it does let you modify the passed berlp in the constructor, while the other constructor (supposedly) shouldn't.</p>\n<p>So, I'm either terribly confused, or something is up!  Please help!</p>\n", "AcceptedAnswerId": "19108471", "Title": "C++ Templated Rvalue Ctor vs Const Reference Ctor", "CreationDate": "2013-10-01T04:13:44.117", "Id": "19107851", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-10-01T04:19:29.403", "LastEditorUserId": "2172459", "LastActivityDate": "2013-10-01T05:14:42.153", "Score": "1", "OwnerUserId": "2172459", "Tags": "<c++><templates><c++11><constructor>", "AnswerCount": "1"}, "19108471": {"Id": "19108471", "PostTypeId": "2", "Body": "<p>There are really multiple questions here:</p>\n<ol>\n<li><p>Why does <code>derp&lt;berlp&amp;&gt;(one)</code> use the first constructor?</p>\n<p>The declaration of the constructor is <code>derp(T const&amp;)</code> which turns into <code>derp(berlp&amp; const&amp;)</code> and is collapsed into <code>derp(berlp&amp;)</code> as there is no such thing as a <code>const</code> reference or a reference reference. This stated in 8.3.2 [dcl.ref] paragraph 6:</p>\n<blockquote>\n<p id=\"so_19107851_19108471_0\">If a typedef (7.1.3), a type template-parameter (14.3.1), or a decltype-specifier (7.1.6.2) denotes a type TR that is a reference to a type T, an attempt to create the type \u201clvalue reference to cv TR\u201d creates the type \u201clvalue reference to T\u201d, while an attempt to create the type \u201crvalue reference to cv TR\u201d creates the type TR.</p>\n</blockquote>\n<p>Obviously, passing a <code>berlp&amp;</code> to a constructor taking a <code>berlp&amp;</code> is an exact match and the template constructor can't do any better. Thus, the non-template constructor is chosen.</p></li>\n<li><p>Why does calling <code>derp&lt;berlp&amp;&gt;(one)</code> with a <code>berlp</code> work?</p>\n<p>There is no real surprise here: <code>mem</code> is of type <code>berlp&amp;</code> and initialized with a <code>berlp&amp;</code> so the non-<code>const</code> members all work as expected.</p></li>\n<li><p>When using <code>derp&lt;berlp const&amp;&gt;</code> and passing a <code>berlp&amp;</code> the template constructor is a perfect match and is, obviously, chosen. The member variable of type <code>berlp const&amp;</code> is just initialized with a <code>berlp&amp;</code> which implicitly converts to a <code>berlp const&amp;</code>. No surprise here, either.</p></li>\n</ol>\n<p>I think you are just a bit confused about the reference collapsing rules. Placing the <code>const</code> into the wrong location also doesn't help: putting it to the right should actually clearly up most of the confusion and is part of <a href=\"http://kuhllib.com/2012/01/17/continental-const-placement/\" rel=\"nofollow\">my preference</a> to put the <code>const</code> to the right.</p>\n", "LastActivityDate": "2013-10-01T05:14:42.153", "CommentCount": "1", "CreationDate": "2013-10-01T05:14:42.153", "ParentId": "19107851", "Score": "1", "OwnerUserId": "1120273"}});