post_cb({"bq_ids": {"n4140": {"so_47854760_47855038_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 5862}}, "n3337": {"so_47854760_47855038_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 5632}}, "n4659": {"so_47854760_47855038_0": {"length": 36, "quality": 0.972972972972973, "section_id": 7345}}}, "47854760": {"ViewCount": "211", "Body": "<p>Minimal example I got is a bit complicated:</p>\n<pre><code>struct A { };\n\ntemplate &lt;int&gt;\nstruct Parent { };\n\ntemplate &lt;int N&gt;\nconstexpr int operator*(A, Parent&lt;N&gt;*) { return N; }\n\ntemplate &lt;class T&gt;\nusing ptr = T*;\n\ntemplate &lt;int&gt;\nstruct Other { };\n\ntemplate &lt;int N&gt;\nstruct Kid: Parent&lt;N&gt; { \n    static Other&lt;A{} * ptr&lt;Kid&gt;{}&gt; o;\n};\n\nint main() {\n    Kid&lt;2&gt;{};\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/NacHi0GrSGl8PyWu\" rel=\"noreferrer\">[gcc]</a> compiles the code without any problem, <a href=\"https://wandbox.org/permlink/WnxmxSxClJFjmP6L\" rel=\"noreferrer\">[clang]</a> complains about matching <code>Parent</code> against <code>Kid</code> problem:</p>\n<pre><code>prog.cc:7:15: note: candidate template ignored: could not match 'Parent' against 'Kid'\nconstexpr int operator*(A, Parent&lt;N&gt;*) { return N; }\n</code></pre>\n<p>To get more absurd when we change the code a bit:</p>\n<pre><code>struct A { };\n\ntemplate &lt;int&gt;\nstruct Parent { };\n\ntemplate &lt;int N&gt;\nconstexpr int operator*(A, Parent&lt;N&gt;*) { return N; }\n\ntemplate &lt;class T&gt;\nusing ptr = T*;\n\ntemplate &lt;int&gt;\nstruct Other { };\n\ntemplate &lt;int N&gt;\nstruct Kid: Parent&lt;N&gt; { \n    static constexpr int s = A{} * ptr&lt;Kid&gt;{};\n};\n\nint main() {\n    Other&lt;Kid&lt;2&gt;::s&gt;{};\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/eQsUMbksJEnAWxzP\" rel=\"noreferrer\">[clang]</a> also compiles the code. So... is it a bug or am I starting to go insane? </p>\n", "AcceptedAnswerId": "47855038", "Title": "Is it abuse to deduce parameters of parent template when passing pointer to constexpr function in the scope of a class", "CreationDate": "2017-12-17T11:45:24.600", "Id": "47854760", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-12-17T19:03:54.457", "Score": "8", "OwnerUserId": "4324224", "Tags": "<c++><language-lawyer><constexpr><incomplete-type><template-deduction>", "AnswerCount": "1"}, "47855038": {"Id": "47855038", "PostTypeId": "2", "Body": "<p>Clang is right to the letter of the law. Yes, <code>Kid</code> is derived from <code>Parent</code>. But that relationship can only be established once <code>Kid</code> is a completely defined type. And well, <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.mem#6\" rel=\"nofollow noreferrer\">[class.mem]/6</a>:</p>\n<blockquote>\n<p id=\"so_47854760_47855038_0\">A class is considered a completely-defined object type ([basic.types])\n  (or complete type) at the closing } of the class-specifier. Within the\n  class member-specification, the class is regarded as complete within\n  function bodies, default arguments, noexcept-specifiers, and default\n  member initializers (including such things in nested classes).\n  <strong>Otherwise it is regarded as incomplete within its own class\n  member-specification.</strong></p>\n</blockquote>\n<p>We are in the \"otherwise\" part I highlighted. Even though we are dealing with pointers, the class is not yet considered defined for the pointer conversion to be valid. GCC is overly permissive.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-17T19:03:54.457", "Score": "6", "CreationDate": "2017-12-17T12:18:07.993", "ParentId": "47854760", "CommentCount": "14", "OwnerUserId": "817643", "LastEditDate": "2017-12-17T19:03:54.457"}});