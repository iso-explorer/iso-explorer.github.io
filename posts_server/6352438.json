post_cb({"6352438": {"ViewCount": "375", "Body": "<p>I've noticed a slight discrepency in how MSVC and g++ handle creation of the temporary exception object when the thrown type is movable.  Hunting these down raised additional questions.  </p>\n<p>Before going any further, here is the core of my question: in the absense of copy/move elision, who well does the standard say how the temporary exception object should be created?  At the moment, the best I've been able to do is the following quote, from 15.1/3:</p>\n<blockquote>\n<p id=\"so_6352438_6352438_0\">A throw-expression initializes a temporary object, called the exception object, the type of which is determined by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d, respectively.</p>\n</blockquote>\n<p>I'm guessing the answer is buried somewhere in language elsewhere that defines the type of an expression and how objects are initialized, but I'm having no luck piecing it all together.  When an object is thrown, does the exception object get (a) copy constructed, (b) move constructed if appropriate, and copy constructed otherwise, or (c) initialized in an implementation defined manner?</p>\n<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\nstruct Blob {\n  Blob() { cout &lt;&lt; \"C\" &lt;&lt; endl; }\n  Blob(const Blob&amp;) { cout &lt;&lt; \"c\" &lt;&lt; endl; }\n  Blob(Blob&amp;&amp;) { cout &lt;&lt; \"m\" &lt;&lt; endl; }\n  Blob&amp; operator =(const Blob&amp;) { cout &lt;&lt; \"=\" &lt;&lt; endl; return *this; }\n  Blob&amp; operator =(Blob&amp;&amp;) { cout &lt;&lt; \"=m\" &lt;&lt; endl; return *this; }\n  ~Blob() { cout &lt;&lt; \"~\" &lt;&lt; endl; }\n\n  int i;\n};\n\nint main() {\n  try {\n     cout &lt;&lt; \"Throw directly: \" &lt;&lt; endl;\n     throw Blob();\n  } catch(const Blob&amp; e) { cout &lt;&lt; \"caught: \" &lt;&lt; &amp;e &lt;&lt; endl; }\n  try {\n     cout &lt;&lt; \"Throw with object about to die anyhow\" &lt;&lt; endl;\n     Blob b;\n     throw b;\n  } catch(const Blob&amp; e) { cout &lt;&lt; \"caught: \" &lt;&lt; &amp;e &lt;&lt; endl;  }\n  {\n    cout &lt;&lt; \"Throw with object not about to die anyhow (enter non-zero integer)\" &lt;&lt; endl;\n    Blob b;\n    int tmp;\n    cin &gt;&gt; tmp; //Just trying to keep optimizers from removing dead code\n    try {\n      if(tmp) throw b;\n      cout &lt;&lt; \"Test is worthless if you enter '0' silly\" &lt;&lt; endl;\n    } catch(const Blob&amp; e) { cout &lt;&lt; \"caught: \" &lt;&lt; &amp;e &lt;&lt; endl;  }\n    b.i = tmp;\n    cout &lt;&lt; b.i &lt;&lt; endl;\n  }\n}\n</code></pre>\n<p>This is all recreated on <a href=\"http://ideone.com/bA4iO\" rel=\"noreferrer\">ideone</a>.  As you can [hopefully] see, gcc via ideone creates the <code>Blob</code> object in place in the first case, and moves in the second two.  The results are summarized below, with the pointer values replaced with identifiers.  </p>\n<pre><code>Throw directly: \nC {A}\ncaught: {A}\n~ {A}\nThrow with object about to die anyhow\nC {A}\nm {B} &lt;- {A}\n~ {A}\ncaught: {B}\n~ {B}\nThrow with object not about to die anyhow (enter non-zero integer)\nC {A}\nm {B} &lt;- {A}\ncaught: {B}\n~ {B}\n2\n~ {A}\n</code></pre>\n<p>The same code in MSVC2010, regardless of optimization settings, the results are the same except the two moves are copies.  This is the difference that initially caught my eye.</p>\n<p>The first test I assume is fine; its classic copy elision.</p>\n<p>In the second test, gcc behaves the way I would have expected.  The temporary <code>Blob</code> is treated as an xvalue, and the exception object is move constructed from it.  But I'm not sure if the compiler is required to recognize that the original <code>Blob</code> is expiring; if it isn't it, then MSVC is acting correctly when it copies.  Thus my original question: does the standard mandate what happens here, or is it just part of the implementation defined behavior inherant to exception handling?  </p>\n<p>The third test is exactly the opposite: MSVC behaves the way my intuition demands.  gcc choses to move from <code>b</code>, but <code>b</code> is still live, as evidenced by the fact that I continue to work with it after handling the thrown exception.  Obviously, in this trivial example, moving or copying makes no difference to <code>b</code> itself, but surely the compiler isn't allowed to look at that when considering overload resolution.</p>\n<p>Obviously, the presence of copy/move elision makes this simple test hard to generalize from, but the bigger issue is that either compiler might not be complient just yet [particularly in gcc's case with the third test, and MSVC in general].  </p>\n<p>Note this is entirely for academic purposes; I almost never throw anything except a temporary, which both compilers construct in place anyhow, and I'm quite certain that behavior is allowed. </p>\n", "AcceptedAnswerId": "6359094", "Title": "Throwing movable objects", "CreationDate": "2011-06-15T02:40:17.750", "Id": "6352438", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-06-15T03:16:47.653", "LastEditorUserId": "293791", "LastActivityDate": "2011-06-15T14:13:27.760", "Score": "15", "OwnerUserId": "293791", "Tags": "<c++><exception><c++11>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_6352438_6359094_2": {"length": 11, "quality": 0.55, "section_id": 481}, "so_6352438_6352438_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 3336}, "so_6352438_6359094_0": {"length": 19, "quality": 0.95, "section_id": 480}}, "n3337": {"so_6352438_6359094_2": {"length": 20, "quality": 1.0, "section_id": 472}, "so_6352438_6352438_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 3206}, "so_6352438_6359094_0": {"length": 20, "quality": 1.0, "section_id": 471}}, "n4659": {"so_6352438_6352438_0": {"length": 14, "quality": 0.5384615384615384, "section_id": 7672}, "so_6352438_6359094_0": {"length": 19, "quality": 0.95, "section_id": 502}}}, "6352506": {"Id": "6352506", "PostTypeId": "2", "Body": "<p>Throwing is a very implementation-defined behaviour. In C++03 then the exception was copied an implementation-defined amount of times, placed in an implementation-dependent place, referred to during the catch block and then destructed. In C++0x I expect that an implementation will either have the right to both copy and move it as many times as it likes, or move it as many times as it likes (i.e., you can throw non-copyable classes).</p>\n<p>However, it's certainly not allowed that you could access an object that has been moved from during <code>catch</code>, as that would be Really Bad\u2122. If you have done so, then it is a compiler bug. You should print the address of the object to be certain.</p>\n<p>What you should also remember is that MSVC's implementation is to rules that existed many years ago, whereas GCC's rvalues implementation is much more recent. The rules may have changed since MSVC implemented theirs. However, the compiler <em>will</em> error on trying to throw a non-copyable class, suggesting to me that a compiler may both copy and move an exception object freely.</p>\n", "LastActivityDate": "2011-06-15T02:51:16.613", "CommentCount": "1", "CreationDate": "2011-06-15T02:51:16.613", "ParentId": "6352438", "Score": "3", "OwnerUserId": "298661"}, "6359094": {"Id": "6359094", "PostTypeId": "2", "Body": "<p>The move behavior is conforming for case 2, but not case 3.  See 12.8 [class.copy]/p31:</p>\n<blockquote>\n<p id=\"so_6352438_6359094_0\">When certain criteria are met, an\n  implementation is allowed to omit the\n  copy/move construction of a class\n  object, even if the copy/move\n  constructor and/or destructor for the\n  object have side effects. ...</p>\n<p id=\"so_6352438_6359094_1\">...</p>\n<ul>\n<li>in a throw-expression, when the operand is the name of a non-volatile\n  automatic object (other than a\n  function or catch-clause parameter)\n  whose scope does not extend beyond the\n  end of the innermost enclosing\n  try-block (if there is one), the\n  copy/move operation from the operand\n  to the exception object (15.1) can be\n  omitted by constructing the automatic\n  object directly into the exception\n  object</li>\n</ul>\n</blockquote>\n<p>The above doesn't define when an object can be implicitly moved.  But it <strong>does</strong> define when copy/move elision is legal.  To get when implicit move is legal you have to go down to paragraph 32 in the same section:</p>\n<blockquote>\n<p id=\"so_6352438_6359094_2\">32 When the criteria for elision of a\n  copy operation are met or would be met\n  save for the fact that the source\n  object is a function parameter, and\n  the object to be copied is designated\n  by an lvalue, overload resolution ...</p>\n</blockquote>\n<p>This paragraph explains that when copy/move elision is legal, then overload resolution happens with two passes:</p>\n<ol>\n<li><p>First pretend the lvalue is an rvalue in deciding what constructor is going to be called or elided.</p></li>\n<li><p>If 1) fails, then repeat overload resolution with the argument as an lvalue.</p></li>\n</ol>\n<p>This has the effect of producing a hierarchy of move semantics from best to worst:</p>\n<ol>\n<li>If you can elide construction, do so.</li>\n<li>Else if you can move the object out, do so.</li>\n<li>Else if you can copy the object out, do so.</li>\n<li>Else emit a diagnostic.</li>\n</ol>\n<p>Note that these are essentially the same rules for the ordinary return of local stack objects.</p>\n", "LastActivityDate": "2011-06-15T14:13:27.760", "CommentCount": "1", "CreationDate": "2011-06-15T14:13:27.760", "ParentId": "6352438", "Score": "8", "OwnerUserId": "576911"}});