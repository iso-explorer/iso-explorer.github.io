post_cb({"41085202": {"CommentCount": "4", "AcceptedAnswerId": "41086026", "PostTypeId": "1", "LastEditorUserId": "3087601", "CreationDate": "2016-12-11T10:29:56.217", "LastActivityDate": "2016-12-11T12:26:03.737", "LastEditDate": "2016-12-11T10:45:32.097", "ViewCount": "451", "FavoriteCount": "0", "Title": "Is address of global variable constexpr?", "Id": "41085202", "Score": "13", "Body": "<p>Consider following</p>\n<pre><code>struct dummy{};\n\ndummy d1;\ndummy d2;\n\ntemplate&lt;dummy* dum&gt;\nvoid foo()\n{\n    if (dum == &amp;d1)\n        ; // do something\n    else if (dum == &amp;d2)\n        ; // do something else\n}\n</code></pre>\n<p>Now, it is possible to call <code>foo</code> like this</p>\n<pre><code>foo&lt;&amp;d1&gt;();\nfoo&lt;&amp;d2&gt;();\n</code></pre>\n<p>and everything works as expected. But following does not</p>\n<pre><code>constexpr dummy* dum_ptr = &amp;d1;\nfoo&lt;dum_ptr&gt;();\n</code></pre>\n<p>With this error from Visual studio</p>\n<blockquote>\n<p id=\"so_41085202_41085202_0\">error C2975: <code>dum_ptr</code>: invalid template argument for <code>foo</code>, expected compile-time constant expression</p>\n</blockquote>\n<p>While this works </p>\n<pre><code>constexpr dummy&amp; dum_ref = d1;\nfoo&lt;&amp;dum_ptr&gt;();\n</code></pre>\n<p>In visual studio, but not in G++, because of</p>\n<blockquote>\n<p id=\"so_41085202_41085202_1\">note:   template argument deduction/substitution failed:<br>\n  error: <code>&amp; dum_ref</code> is not a valid template argument for <code>dummy*</code> because it is not the address of a variable</br></p>\n<pre><code>foo&lt;&amp;dum_ref&gt;();\n</code></pre>\n</blockquote>\n<p>EDIT:<br>\nSince C++17, <code>std::addressof</code> is being marked as constexpr, so I would guess it should work.</br></p>\n", "Tags": "<c++11><language-lawyer>", "OwnerUserId": "3087601", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41085202_41086026_0": {"section_id": 87, "quality": 1.0, "length": 5}, "so_41085202_41086026_1": {"section_id": 87, "quality": 0.5909090909090909, "length": 13}}, "n3337": {"so_41085202_41086026_0": {"section_id": 82, "quality": 1.0, "length": 5}, "so_41085202_41086026_1": {"section_id": 82, "quality": 0.7272727272727273, "length": 16}}, "n4659": {"so_41085202_41086026_1": {"section_id": 90, "quality": 0.9090909090909091, "length": 20}}}, "41086026": {"ParentId": "41085202", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-12-11T12:13:06.387", "Score": "4", "LastEditorUserId": "6838526", "LastEditDate": "2016-12-11T12:26:03.737", "Id": "41086026", "OwnerUserId": "6838526", "Body": "<p>GCC is right on this one.</p>\n<p>The expressions are definitely <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow noreferrer\"><code>constant-expression</code></a>s*, since they are assigned to a <code>constexpr</code> variable. However, until c++14, there are additional restrictions on what is allowed for a pointer template argument.</p>\n<blockquote>\n<h3>C++14 draft N4140 [temp.arg.nontype]</h3>\n<p id=\"so_41085202_41086026_0\">1 A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>for a non-type template-parameter of integral or enumeration type, a converted constant expression (5.19) of the type of the\n  template-parameter; or</li>\n<li>the name of a non-type template-parameter; or</li>\n<li>a constant expression (5.19) that designates the address of a complete object with static storage duration and external or internal\n  linkage or a function with external or internal linkage, including\n  function templates and function template-ids but excluding non-static\n  class members, <strong>expressed (ignoring parentheses) as \n  <code>&amp;id-expression</code>, where the id-expression is the name of an object</strong> or\n  function, except that the &amp; may be omitted if the name refers to a\n  function or array and shall be omitted if the corresponding\n  template-parameter is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or\n      a constant expression that evaluates to a null member pointer value (4.11); or\n      a pointer to member expressed as described in 5.3.1; or\n      a constant expression of type std::nullptr_t.</li>\n</ul>\n</blockquote>\n<p>For <code>foo&lt;dum_ptr&gt;()</code>, <code>dum_ptr</code> isn't expressed as <code>&amp;name</code>, and for <code>foo&lt;&amp;dum_ref&gt;()</code>, <code>dum_ref</code> isn't the name of the object, it's the name of a reference to the object, so both are disallowed as template arguments.</p>\n<p>These restrictions are lifted in c++17 to allow any constexpr, so thats why it works there:</p>\n<blockquote>\n<h3>C++17 draft N4606 - 14.3.2  Template non-type arguments [temp.arg.nontype]</h3>\n<p id=\"so_41085202_41086026_1\">1 A template-argument for a non-type template-parameter shall be a\n  converted constant expression (5.20) of the type of the\n  template-parameter.  For a non-type template-parameter of reference or\n  pointer type, the value of the constant expression shall not refer to\n  (or for a pointer type, shall not be the address of):</p>\n<ul>\n<li>(1.1) a subobject (1.8),</li>\n<li>(1.2) a temporary object (12.2),</li>\n<li>(1.3) a string literal (2.13.5),</li>\n<li>(1.4) the result of a typeid expression (5.2.8), or</li>\n<li>(1.5) a predefined __func__ variable (8.4.1).</li>\n</ul>\n</blockquote>\n<p>As usual, clang gives the best error messages:\n<a href=\"https://godbolt.org/g/j0Q2bV\" rel=\"nofollow noreferrer\">https://godbolt.org/g/j0Q2bV</a></p>\n<hr>\n<p>*(see <em>Address constant expression</em> and <em>Reference constant expression</em>)</p>\n</hr>", "LastActivityDate": "2016-12-11T12:26:03.737"}});