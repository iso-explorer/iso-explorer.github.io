post_cb({"bq_ids": {"n4140": {"so_47201359_47201660_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 6066}}, "n3337": {"so_47201359_47201660_0": {"length": 25, "quality": 0.8928571428571429, "section_id": 5834}}, "n4659": {"so_47201359_47201660_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 7562}}}, "47201359": {"ViewCount": "770", "Body": "<p>With g++ 5.4, this</p>\n<pre><code>struct B {\n    void f() {}\n}; \n\nstruct D : public B {\n    void g() {}\n};\n\ntemplate &lt;class T&gt;\nvoid foo(void (T::*)(), void (T::*)())\n{}\n\nint main()\n{\n    foo(&amp;D::f, &amp;D::g);\n}\n</code></pre>\n<p>fails due to \"deduced conflicting types for parameter \u2018T\u2019 (\u2018B\u2019 and \u2018D\u2019)\".  Why isn't T deduced as D, being an exact match?</p>\n", "AcceptedAnswerId": "47201660", "Title": "Why is template argument deduction failing for pointer-to-member-function?", "CreationDate": "2017-11-09T12:02:59.807", "Id": "47201359", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-11-09T18:13:02.080", "Score": "13", "OwnerUserId": "18167", "Tags": "<c++><templates><argument-deduction>", "AnswerCount": "2"}, "47201454": {"Id": "47201454", "PostTypeId": "2", "Body": "<p>The type of <code>&amp;D::f</code> would be <code>void ( B::* )(void)</code></p>\n<pre><code>static_assert(::std::is_same&lt;void ( B::* )(void), decltype(&amp;D::f)&gt;::value, \"\");\nstatic_assert(::std::is_same&lt;void ( D::* )(void), decltype(&amp;D::f)&gt;::value, \"\"); // error\nstatic_assert(::std::is_same&lt;void ( D::* )(void), decltype(&amp;D::g)&gt;::value, \"\");\n</code></pre>\n<p>The rationale behind this is that otherwise you won't be able to assign a value of <code>&amp;D::f</code> to a variable of <code>void ( B::* )(void)</code> type without a cast even though <code>f</code> is a member of <code>B</code> or compare <code>&amp;D::f == &amp;B::f</code>.</p>\n<p>As a workaround you can perform a static_cast:</p>\n<pre><code>foo(static_cast&lt;void (D::*)(void)&gt;(&amp;D::f), &amp;D::g);\n</code></pre>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2017-11-09T18:13:02.080", "Score": "13", "CreationDate": "2017-11-09T12:07:37.373", "ParentId": "47201359", "CommentCount": "3", "OwnerUserId": "7860670", "LastEditDate": "2017-11-09T18:13:02.080"}, "47201660": {"Id": "47201660", "PostTypeId": "2", "Body": "<p>In addition to <a href=\"https://stackoverflow.com/a/47201454/817643\"><strong>VTT</strong>'s excellent demonstration</a>. The standard text in question, I believe, is at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.unary.op#3\" rel=\"noreferrer\">[expr.unary.op]/3</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_47201359_47201660_0\">The result of the unary &amp; operator is a pointer to its operand. The\n  operand shall be an lvalue or a qualified-id. <strong>If the operand is a\n  qualified-id naming a non-static or variant member m of some class C\n  with type T, the result has type \u201cpointer to member of class C of type\n  T\u201d and is a prvalue designating C\u200b::\u200bm</strong>.</p>\n</blockquote>\n<p>The qualified id you used is <code>D::f</code>, but it names a member function of <code>B</code> (I can bring up the lookup rules if you want). So the class type <code>C</code> in the above paragraph, is <code>B</code>. The type therefore resolves to <code>void ( B::* )(void)</code>.</p>\n", "LastActivityDate": "2017-11-09T12:17:41.197", "CommentCount": "1", "CreationDate": "2017-11-09T12:17:41.197", "ParentId": "47201359", "Score": "12", "OwnerUserId": "817643"}});