post_cb({"40242505": {"ViewCount": "1150", "Body": "<p>As far as I understand - generic lambdas are transformed into objects of local scope structs with templated <code>operator()</code>. This makes generic lambda very powerful and easy to use tool. On the other hand one can create structs nested into the function, when however the struct has templated member e.g.:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    struct inner {\n    template &lt;class T&gt;\n       void operator()(T &amp;&amp;i) { }\n    };\n    return 0;\n}\n</code></pre>\n<p>or is templated by itself:</p>\n<pre><code>int main() {\n    template &lt;class T&gt;\n    struct inner {\n       void operator()(T &amp;&amp;i) { }\n    };\n    return 0;\n}\n</code></pre>\n<p>compiler seems to have a problem with compiling it:</p>\n<blockquote>\n<pre><code>error: invalid declaration of member template in local class\n</code></pre>\n<p id=\"so_40242505_40242505_0\">and</p>\n<pre><code>error: a template declaration cannot appear at block scope\n</code></pre>\n</blockquote>\n<p>I assume the problem lays more in c++ standard than in compiler bug. What are the reasons lambdas are allowed to have templated members and not the local structures?</p>\n<p>I found <a href=\"https://stackoverflow.com/questions/4299314/member-template-in-local-class\">this qustion</a>, but I think the answer is kind of outdated (I don't think it's true even for c++11).</p>\n", "AcceptedAnswerId": "40243927", "Title": "Why generic lambdas are allowed while nested structs with templated methods aren't?", "CreationDate": "2016-10-25T14:19:17.757", "Id": "40242505", "CommentCount": "15", "LastEditDate": "2017-05-23T11:59:58.607", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-11-13T14:17:12.370", "Score": "32", "OwnerUserId": "4324224", "Tags": "<c++><templates><c++14><local-class><generic-lambda>", "AnswerCount": "2"}, "40243839": {"Id": "40243839", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_40242505_40243839_0\">I assume the problem lays more in c++ standard </p>\n</blockquote>\n<p>Correct. This is stipulated in [temp] for class templates:</p>\n<blockquote>\n<p id=\"so_40242505_40243839_1\">A <em>template-declaration</em> can appear only as a namespace scope or class scope declaration.</p>\n</blockquote>\n<p>and [temp.mem] for member templates:</p>\n<blockquote>\n<p id=\"so_40242505_40243839_2\">A local class of non-closure type shall not have member templates.</p>\n</blockquote>\n<hr/>\n<blockquote>\n<p id=\"so_40242505_40243839_3\">What are the reasons lambdas are allowed to have templated members and not the local structures?</p>\n</blockquote>\n<p>Because once we had lambdas in C++11, it was deemed that it would be extremely useful to extend that concept to have generic lambdas. There was a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3418.pdf\" rel=\"nofollow\">proposal</a> for such a language extension, which was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3559.pdf\" rel=\"nofollow\">revised</a> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3649.html\" rel=\"nofollow\">and revised</a> and adopted. </p>\n<p>On the other hand, there has not yet been a proposal presented (as far as I'm aware from a brief search) that lays out the motivation for the need for member templates in local classes that isn't adequately solved by a generic lambda. </p>\n<p>If you feel that this is an important problem that needs to be solved, feel free to <a href=\"https://isocpp.org/std/submit-a-proposal\" rel=\"nofollow\">submit a proposal</a> after laying out a thoughtful motivation for why local member templates are important. </p>\n", "LastActivityDate": "2016-10-25T15:23:36.870", "CommentCount": "3", "CreationDate": "2016-10-25T15:23:36.870", "ParentId": "40242505", "Score": "3", "OwnerUserId": "2069064"}, "40243927": {"Id": "40243927", "PostTypeId": "2", "Body": "<p>This is <a href=\"http://wg21.link/cwg728\" rel=\"nofollow noreferrer\">core issue 728</a>, which was filed before generic lambdas were a thing.</p>\n<p>You mentioned generic lambdas and that they were identical to local classes with corresponding member <code>template operator()</code>. However, they actually aren't, and the differences are related to implementation characteristics. Consider</p>\n<pre><code>template &lt;typename T&gt;\nclass X {\n    template &lt;typename&gt;\n    void foo() {\n        T t;\n    }\n};\n</code></pre>\n<p>And</p>\n<pre><code>template &lt;typename T&gt;\nauto bar() {\n    return [] (auto) {T t;};\n};\n</code></pre>\n<p>Instantiating these templates with <code>&lt;void&gt;</code> will be fine in the first case, but ill-formed in the second. Why fine in the first case? <code>foo</code> need not be instantiatable for each particular <code>T</code>, but just one of them (this would be <a href=\"http://eel.is/c++draft/temp.res#8.1\" rel=\"nofollow noreferrer\">[temp.res]/(8.1)</a>).</p>\n<p>Why ill-formed in the second case? The generic lambda's body is instantiated - partially - using the provided template arguments. And the reason for this partial instantiation is the fact that\u2026 </p>\n<blockquote>\n<p id=\"so_40242505_40243927_0\">\u2026the lexical scopes used while processing a function definition are fundamentally transient, which means that delaying instantiation of some portion of a function template definition is hard to support.</p>\n</blockquote>\n<p>(<a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-proposals/qd3L1-bGg1A/IhkqByIbCgAJ\" rel=\"nofollow noreferrer\">Richard Smith</a>) We must instantiate enough of the local \"template\" to make it independent of the local context (which includes template parameters of the enclosing function template). </p>\n<p>This is also related to the rationale for \n<a href=\"http://eel.is/c++draft/expr.prim.lambda#13\" rel=\"nofollow noreferrer\">[expr.prim.lambda]/13</a>, which mandates that an entity is implicitly captured by a lambda if it\u2026</p>\n<blockquote>\n<p id=\"so_40242505_40243927_1\">names the entity in a potentially-evaluated expression ([basic.def.odr]) where the enclosing <em>full-expression</em> depends on a generic lambda parameter declared within the reaching scope of the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>That is, if I have a lambda like <code>[=] (auto x) {return (typename decltype(x)::type)a;}</code>, where <code>a</code> is some block-scope variable from an enclosing function, regardless of whether <code>x</code>'s member typedef is for <code>void</code> or not, the cast will cause a capture of <code>a</code>, because we must decide on this without waiting for an invocation of the lambda. For a discussion of this problem, see the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3559.pdf\" rel=\"nofollow noreferrer\">original proposal on generic lambdas</a>.</p>\n<p>The bottom line is that completely postponing instantiation of a member template is not compatible with the model used by (at least one) major implementation(s), and since those are the expected semantics, the feature was not introduced.</p>\n<hr>\n<p>Was that the original motivation for this constraint? It was introduced sometime between January and May 1994, with no paper covering it, so we can only get a rough idea of the prevailing notions from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1993/N0390.pdf\" rel=\"nofollow noreferrer\">this paper</a>'s justification of why local classes shall not be template arguments:</p>\n<blockquote>\n<p id=\"so_40242505_40243927_2\">Class templates and the classes generated from the template are global scope\n  entities and cannot refer to local scope entities.</p>\n</blockquote>\n<p>Perhaps back then, one wanted to KISS. </p>\n</hr>", "LastEditorUserId": "3670871", "LastActivityDate": "2017-11-13T14:17:12.370", "Score": "27", "CreationDate": "2016-10-25T15:28:08.977", "ParentId": "40242505", "CommentCount": "15", "OwnerUserId": "3647361", "LastEditDate": "2017-11-13T14:17:12.370"}, "bq_ids": {"n4140": {"so_40242505_40243839_2": {"length": 7, "quality": 1.0, "section_id": 111}, "so_40242505_40243839_1": {"length": 8, "quality": 1.0, "section_id": 49}, "so_40242505_40243927_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 5971}}, "n3337": {"so_40242505_40243839_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 106}, "so_40242505_40243839_1": {"length": 8, "quality": 1.0, "section_id": 44}}, "n4659": {"so_40242505_40243839_2": {"length": 7, "quality": 1.0, "section_id": 115}, "so_40242505_40243839_1": {"length": 8, "quality": 1.0, "section_id": 50}, "so_40242505_40243927_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 7470}}}});