post_cb({"46509077": {"CommentCount": "3", "ViewCount": "39", "CreationDate": "2017-10-01T04:01:46.960", "LastActivityDate": "2017-10-01T04:01:46.960", "Title": "Lvale-to-rvalue conversion of references", "PostTypeId": "1", "Id": "46509077", "Score": "0", "Body": "<p>Let's supposed I have an identifier <code>a</code> of type <code>A&amp;</code>, where <code>A</code> is a class type, and the expression <code>a</code> is in a context that must be converted to an rvalue. According to the standard (C++14):</p>\n<blockquote>\n<p id=\"so_46509077_46509077_0\">[conv.lval]/1 A glvalue (3.10) of a non-function, non-array type T can\n  be converted to a prvalue. If T is an incomplete type, a program that\n  necessitates this conversion is ill-formed. If T is a non-class type,\n  the type of the prvalue is the cv-unqualified version of T. Otherwise,\n  the type of the prvalue is T.</p>\n</blockquote>\n<p>The glvalue is <code>a</code>, and has type <code>A&amp;</code>. <code>A&amp;</code> is a non-class type, because its type is a reference to class type, so, its cv-unqualified version is <code>A&amp;</code>.</p>\n<p>If I'm wrong and <code>A&amp;</code> is considered a class-type too, despite it is a reference, its prvalue type will be <code>A&amp;</code> anyway.</p>\n<p>And then,</p>\n<blockquote>\n<p id=\"so_46509077_46509077_1\">[conv.lval]/2 [...] In all other cases, the result of the conversion is determined according to the following rules:</p>\n<p id=\"so_46509077_46509077_2\">\u2014 If T is (possibly cv-qualified) std::nullptr_t, the result is a null pointer constant (4.10).</p>\n<p id=\"so_46509077_46509077_3\">\u2014 Otherwise, if T has a class type, the conversion copy-initializes temporary of type T from the glvalue and the result of the conversion is a prvalue for the temporary.</p>\n<p id=\"so_46509077_46509077_4\">\u2014 Otherwise, if the object to which the glvalue refers contains an invalid pointer value (3.7.4.2, 3.7.4.3), the behavior is implementation-defined.</p>\n<p id=\"so_46509077_46509077_5\">\u2014 Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p>If we say <code>A&amp;</code> has class type instead of reference, the conversion should copy-initialize a temporary of type <code>A&amp;</code>. If it isn't, the value contained in the <code>A&amp;</code> object is the prvalue result, of type <code>A&amp;</code> due to the first paragraph.</p>\n<p>In any case, <code>T == A&amp;</code>. How can a reference be a prvalue? What is what I'm not understanding here?</p>\n", "Tags": "<c++><reference><c++14><lvalue>", "OwnerUserId": "1794803", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_46509077_46509077_4": {"section_id": 9, "quality": 0.8333333333333334, "length": 10}, "so_46509077_46509077_5": {"section_id": 9, "quality": 1.0, "length": 8}, "so_46509077_46509077_2": {"section_id": 9, "quality": 0.875, "length": 7}, "so_46509077_46509077_3": {"section_id": 9, "quality": 1.0, "length": 12}, "so_46509077_46509077_0": {"section_id": 8, "quality": 0.9130434782608695, "length": 21}, "so_46509077_46509077_1": {"section_id": 9, "quality": 0.9, "length": 9}}, "n3337": {"so_46509077_46509077_3": {"section_id": 6, "quality": 1.0, "length": 12}, "so_46509077_46509077_5": {"section_id": 6, "quality": 1.0, "length": 8}, "so_46509077_46509077_2": {"section_id": 6, "quality": 0.875, "length": 7}, "so_46509077_46509077_0": {"section_id": 5, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_46509077_46509077_4": {"section_id": 10, "quality": 0.75, "length": 9}, "so_46509077_46509077_5": {"section_id": 10, "quality": 1.0, "length": 8}, "so_46509077_46509077_2": {"section_id": 39, "quality": 0.625, "length": 5}, "so_46509077_46509077_3": {"section_id": 4087, "quality": 0.6666666666666666, "length": 8}, "so_46509077_46509077_0": {"section_id": 8, "quality": 0.9130434782608695, "length": 21}, "so_46509077_46509077_1": {"section_id": 10, "quality": 0.6, "length": 6}}}});