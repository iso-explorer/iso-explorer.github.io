post_cb({"bq_ids": {"n4140": {"so_43387247_43387721_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5593}, "so_43387247_43387721_0": {"length": 19, "quality": 1.0, "section_id": 5562}}, "n3337": {"so_43387247_43387721_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5376}, "so_43387247_43387721_0": {"length": 19, "quality": 1.0, "section_id": 5344}}, "n4659": {"so_43387247_43387721_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 7037}, "so_43387247_43387721_0": {"length": 19, "quality": 1.0, "section_id": 7009}}}, "43387721": {"Id": "43387721", "PostTypeId": "2", "Body": "<p>In short : yes, this is guaranteed by the standard.</p>\n<h2>Explanation</h2>\n<p>All iterators are required to have an <code>O(n)</code> traversal time complexity (where <code>n</code> is the amount of items traversed). This is because every single operation on an iterator has a constant time complexity (<code>O(1)</code>), including advancing the iterator one position.</p>\n<p>From the standard (section 24.2.1 \u00a78) :</p>\n<blockquote>\n<p id=\"so_43387247_43387721_0\">All the categories of iterators require only those functions that are realizable for a given category in constant time (amortized). Therefore, requirement tables for the iterators do not have a complexity column.</p>\n</blockquote>\n<p>So, when iterating over the items of a <code>std::unordered_set</code>, the time complexity is <code>O(n)</code> (with <code>n</code> the amount of items in the set).</p>\n<h2>Not convinced ?</h2>\n<p>A literal reading of the above quote only guarantees that constant time operations are <em>realizable</em>. This doesn't prevent a specific implementation from having worse time complexity than what's <em>realizable</em>. This is probably down to a bad choice of words, and hopefully no serious implementations actually do this.</p>\n<p>The only other place in the standard that can help resolve this ambiguity, is in section 24.4.4 \u00a71, where the standard has this to say about <a href=\"http://en.cppreference.com/w/cpp/iterator/advance\" rel=\"nofollow noreferrer\"><code>std::advance</code></a> and <a href=\"http://en.cppreference.com/w/cpp/iterator/distance\" rel=\"nofollow noreferrer\"><code>std::distance</code></a> :</p>\n<blockquote>\n<p id=\"so_43387247_43387721_1\">These function templates use <code>+</code> and <code>-</code> for random access iterators (and are, therefore, constant time for them); for input, forward and bidirectional iterators they use <code>++</code> to provide linear time\n  implementations.</p>\n</blockquote>\n<p>So, the <code>++</code> operation on a forward iterator (as used for <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set\" rel=\"nofollow noreferrer\"><code>std::unordered_set</code></a>) is implied to be a constant time operation.</p>\n<p>In summary, while the wording of the first quote is ambiguous, the second quote confirms the intent.</p>\n", "LastEditorUserId": "822669", "LastActivityDate": "2017-04-13T12:46:27.243", "Score": "2", "CreationDate": "2017-04-13T08:56:10.433", "ParentId": "43387247", "CommentCount": "4", "OwnerUserId": "822669", "LastEditDate": "2017-04-13T12:46:27.243"}, "43387247": {"ViewCount": "146", "Body": "<p>I recently played around with a <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set\" rel=\"nofollow noreferrer\"><code>std::unordered_set</code></a>. I'm suspecting my version of the STL keeps track of non-empty buckets in some FILO data-structure (looks like a list). I suppose this is done in order to provide <code>O(n)</code> time traversal of the complete <code>std::unordered_set</code> (where <code>n</code> denotes the number of elements in a <code>unordered_set</code> with <code>m</code> buckets and <code>m</code> much larger than <code>n</code>). This improves a naive traversal of all buckets in <code>O(m)</code> time.</p>\n<p>I've tested that indeed traversal of large and very sparse <code>unordered_set</code>s (with <code>begin</code> - <code>end</code>) is much faster than a naive traversal of all buckets.</p>\n<p><strong>Question</strong>: Is this traversal runtime guaranteed by the standard? Or is this just a feature of my particular standard library?</p>\n<hr>\n<p>Here is my test code to play around with:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\n\nvoid test(vector&lt;int&gt; data, int alloc_size) {\n   unordered_set&lt;int&gt; set(alloc_size);\n   for (auto i: data) {\n      set.insert(i);\n   }\n\n   for (size_t bidx = 0; bidx &lt; set.bucket_count(); ++bidx) {\n      cout &lt;&lt; \"[B\" &lt;&lt; bidx &lt;&lt; \":\";\n      for (auto bit = set.begin(bidx); bit != set.end(bidx); ++bit) {\n         cout &lt;&lt; \" \" &lt;&lt; *bit;\n      }\n      cout &lt;&lt; \"] \";\n   }\n\n   cout &lt;&lt; \"  {\";\n   for (auto const &amp; d: set) {\n      cout &lt;&lt; d &lt;&lt; \" \";\n   }\n   cout &lt;&lt; \"}\" &lt;&lt; endl;\n}\n\nint main() {\n   test({1, 2, 0}, 3);\n   test({1, 2, 0, 7}, 3);\n   test({18, 6, 11, 3, 13, 4}, 20);\n   test({18, 6, 11, 3, 13, 4, 34}, 20);\n}\n</code></pre>\n<p>Which prints:</p>\n<pre><code>[B0: 0] [B1: 1] [B2: 2] [B3:] [B4:]   {0 2 1 }\n[B0: 0] [B1: 1] [B2: 7 2] [B3:] [B4:]   {0 7 2 1 }\n[B0:] [B1:] [B2:] [B3: 3] [B4: 4] [B5:] [B6: 6] [B7:] [B8:] [B9:] [B10:] [B11: 11] [B12:] [B13: 13] [B14:] [B15:] [B16:] [B17:] [B18: 18] [B19:] [B20:] [B21:] [B22:]   {4 13 3 11 6 18 }\n[B0:] [B1:] [B2:] [B3: 3] [B4: 4] [B5:] [B6: 6] [B7:] [B8:] [B9:] [B10:] [B11: 34 11] [B12:] [B13: 13] [B14:] [B15:] [B16:] [B17:] [B18: 18] [B19:] [B20:] [B21:] [B22:]   {4 13 3 34 11 6 18 }\n</code></pre>\n<p>It appears the <code>begin</code> - <code>end</code> traversal reports buckets in the reverse order in which they became non-empty (cf. first and third line). Inserting into an already non-empty bucket does not change this ordering (cf. second and fourth line).</p>\n</hr>", "AcceptedAnswerId": "43387721", "Title": "Complexity of std::unordered_set iterator traversal", "CreationDate": "2017-04-13T08:31:59.140", "Id": "43387247", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-04-13T12:46:27.243", "Score": "0", "OwnerUserId": "2747160", "Tags": "<c++><c++11><stl><c++-standard-library>", "AnswerCount": "1"}});