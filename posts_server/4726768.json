post_cb({"8021893": {"ParentId": "4726768", "CommentCount": "2", "CreationDate": "2011-11-05T17:27:18.817", "OwnerUserId": "409863", "PostTypeId": "2", "Id": "8021893", "Score": "11", "Body": "<p>You can return lambda function from other lambda function, since you should not explicitly specify return type of lambda function. Just write something like that in global scope:</p>\n<pre><code> auto retFun = []() {\n     return [](int x) {return x;};\n };\n</code></pre>\n", "LastActivityDate": "2011-11-05T17:27:18.817"}, "4726768": {"CommentCount": "6", "AcceptedAnswerId": "4727021", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2011-01-18T17:01:00.303", "LastActivityDate": "2016-06-29T10:15:06.957", "LastEditDate": "2016-06-29T10:15:06.957", "ViewCount": "17066", "FavoriteCount": "18", "Title": "Function returning a lambda expression", "Id": "4726768", "Score": "57", "Body": "<p>I wonder if it's possible to write a function that returns a lambda function in C++11. Of course one problem is how to declare such function. Each lambda has a type, but that type is not expressible in C++. I don't think this would work:</p>\n<pre><code>auto retFun() -&gt; decltype ([](int x) -&gt; int)\n{\n    return [](int x) { return x; }\n}\n</code></pre>\n<p>Nor this:</p>\n<pre><code>int(int) retFun();\n</code></pre>\n<p>I'm not aware of any automatic conversions from lambdas to, say, pointers to functions, or some such. Is the only solution handcrafting a function object and returning it? </p>\n", "Tags": "<c++><function><c++11><lambda>", "OwnerUserId": "90088", "AnswerCount": "4"}, "37891825": {"ParentId": "4726768", "CommentCount": "1", "CreationDate": "2016-06-17T23:40:31.900", "OwnerUserId": "1286986", "PostTypeId": "2", "Id": "37891825", "Score": "7", "Body": "<p>Though the question specifically asks about C++11, for the sake of others who stumble upon this and have access to a C++14 compiler, C++14 now allows deduced return types for ordinary functions.  So the example in the question can be adjusted just to work as desired simply by dropping the <code>-&gt; decltype</code>... clause after the function parameter list:</p>\n<pre><code>auto retFun()\n{\n    return [](int x) { return x; }\n}\n</code></pre>\n<p>Note, however, that this will not work if more than one <code>return &lt;lambda&gt;;</code> appears in the function.  This is because a restriction on return type deduction is that all return statements must return expressions of the same type, but every lambda object is given its own unique type by the compiler, so the <code>return &lt;lambda&gt;;</code> expressions will each have a different type.</p>\n", "LastActivityDate": "2016-06-17T23:40:31.900"}, "4730655": {"ParentId": "4726768", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-01-19T00:44:37.217", "Score": "25", "LastEditorUserId": "3919155", "LastEditDate": "2016-06-29T10:12:56.100", "Id": "4730655", "OwnerUserId": "534498", "Body": "<p>For this simple example, you don't need <code>std::function</code>.</p>\n<p>From standard \u00a75.1.2/6:</p>\n<blockquote>\n<p id=\"so_4726768_4730655_0\">The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Because your function doesn't have a capture, it means that the lambda can be converted to a pointer to function of type <code>int (*)(int)</code>:</p>\n<pre><code>typedef int (*identity_t)(int); // works with gcc\nidentity_t retFun() { \n  return [](int x) { return x; };\n}\n</code></pre>\n<p>That's my understanding, correct me if I'm wrong.</p>\n", "LastActivityDate": "2016-06-29T10:12:56.100"}, "4727021": {"ParentId": "4726768", "CommentCount": "7", "CreationDate": "2011-01-18T17:22:49.283", "OwnerUserId": "182693", "PostTypeId": "2", "Id": "4727021", "Score": "65", "Body": "<p>You don't need a handcrafted function object, just use <code>std::function</code>, to which lambda functions are convertible:</p>\n<pre><code>std::function&lt;int (int)&gt; retFun() {\n    return [](int x) { return x; };\n}\n</code></pre>\n", "LastActivityDate": "2011-01-18T17:22:49.283"}, "bq_ids": {"n4140": {"so_4726768_4730655_0": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_4726768_4730655_0": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_4726768_4730655_0": {"section_id": 7456, "quality": 0.85, "length": 34}}}});