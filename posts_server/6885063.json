post_cb({"6885063": {"CommentCount": "1", "AcceptedAnswerId": "6885137", "CreationDate": "2011-07-30T18:14:28.820", "LastActivityDate": "2011-07-30T19:50:37.317", "PostTypeId": "1", "ViewCount": "388", "FavoriteCount": "3", "Title": "Where should I define operator >> for my specialization of std::pair?", "Id": "6885063", "Score": "15", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\nusing namespace std; //just for convenience, illustration only\n\ntypedef pair&lt;int, int&gt; point; //this is my specialization of pair. I call it point\n\nistream&amp; operator &gt;&gt; (istream &amp; in, point &amp; p)\n{\n    return in &gt;&gt; p.first &gt;&gt; p.second;\n}\n\nint main()\n{\n    vector&lt;point&gt; v((istream_iterator&lt;point&gt;(cin)), istream_iterator&lt;point&gt;()); \n    //             ^^^                         ^^^        \n    //extra parentheses lest this should be mistaken for a function declaration\n}\n</code></pre>\n<p>This fails to compile because as soon as ADL finds operator &gt;&gt; in namespace std it doesn't consider the global scope any more regardless of whether the operator found in std was a viable candidate or not. This is rather inconvenient. If I place the declaration of my operator &gt;&gt; into namespace std (which is technically illegal) the code compiles well as expected. Is there any way to resolve this issue other than make <code>point</code> my own class rather than typedefing it as a specialization of a template in std namespace?</p>\n<p>Thanks in advance</p>\n", "Tags": "<c++><stl><template-specialization><argument-dependent-lookup>", "OwnerUserId": "469935", "AnswerCount": "1"}, "6885137": {"ParentId": "6885063", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Adding an overload of <code>operator&gt;&gt;</code> in <code>namespace std</code> is forbidden, but adding a template specialization is sometimes allowed.</p>\n<p>However, there are no user-defined types here, and the operators on standard types are not yours to redefine.  Specializing <code>operator&gt;&gt;(istream&amp;, pair&lt;mytype, int&gt;)</code> would be reasonable.</p>\n<hr>\n<p>section <code>[namespace.std]</code> (section 17.6.4.2.1 of n3290) says</p>\n<blockquote>\n<p id=\"so_6885063_6885137_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified. <strong>A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type</strong> and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-07-30T19:50:37.317", "Id": "6885137", "Score": "11", "CreationDate": "2011-07-30T18:25:52.393", "LastActivityDate": "2011-07-30T19:50:37.317"}, "bq_ids": {"n4140": {"so_6885063_6885137_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_6885063_6885137_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_6885063_6885137_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}}}});