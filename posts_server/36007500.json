post_cb({"bq_ids": {"n4140": {"so_36007500_36007500_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 1394}}, "n3337": {"so_36007500_36007500_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 1388}}, "n4659": {"so_36007500_36007500_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 1512}}}, "36007500": {"ViewCount": "339", "Body": "<p>I have structs like this (types simplified to carry over the point), living in a <code>std::vector</code>:</p>\n<pre><code>struct Region {\n    int first;\n    int count;\n    struct Metadata region_metadata;\n};\n</code></pre>\n<p>In the vector, they are ordered by <code>first</code>. If you add <code>first</code> and <code>count</code>, you get the <code>first</code> of the next region; so basically this vector of structs describes metadata for contiguous ranges of numbers.</p>\n<p>Now given an integer, I want to look up the metadata. As the regions are sorted, I can use <code>std::upper_bound</code>. I implemented it this way:</p>\n<pre><code>struct Comp\n{\n    inline bool operator()(const Region &amp;region, int index) const\n    {\n        return region.first &lt; index;\n    }\n\n    inline bool operator()(int index, const Region &amp;region) const\n    {\n        return index &lt; region.first;\n    }\n};\n</code></pre>\n<p>This works, when calling <code>std::upper_bound</code> with:</p>\n<pre><code>auto iter = std::upper_bound(m_regions.begin(),\n                             m_regions.end(),\n                             index,\n                             Comp());\n</code></pre>\n<p>Now this happens to work, because <code>upper_bound</code> can internally pick the overload which matches its requirements, as it calls both <code>Comp()(Region, int)</code> and <code>Comp()(int, Region)</code> (which is the reason why a <code>[](const Region &amp;reg, int index){\u2026}</code> would not work). </p>\n<p>I actually came up with the solution by tracing down the error messages when using the lambda I mentioned before. The <a href=\"http://en.cppreference.com/w/cpp/algorithm/upper_bound\">docs for std::upper_bound at cppreference.com</a> write about the fourth argument:</p>\n<blockquote>\n<p id=\"so_36007500_36007500_0\">comparison function object (i.e. an object that satisfies the\n  requirements of Compare) which returns <em>\u200btrue</em> if the first argument is\n  less than the second.</p>\n<p id=\"so_36007500_36007500_1\">The signature of the comparison function should be equivalent to the\n  following:</p>\n<pre><code>bool cmp(const Type1 &amp;a, const Type2 &amp;b);\n</code></pre>\n<p id=\"so_36007500_36007500_2\"><s>The signature does not need to have <code>const &amp;</code>, but the function object\n  must not modify the objects passed to it. The types <code>Type1</code> and <code>Type2</code>\n  must be such that an object of type <code>T</code> can be implicitly converted to\n  both <code>Type1</code> and <code>Type2</code>, and an object of type <code>ForwardIt</code> can be\n  dereferenced and then implicitly converted to both <code>Type1</code> and <code>Type2</code>.</s></p>\n<p id=\"so_36007500_36007500_3\">The type <code>Type1</code> must be such that an object of type <code>T</code> can be \n  implicitly converted to <code>Type1</code>. The type <code>Type2</code> must be such that an \n  object of type <code>ForwardIt</code> can be dereferenced and then implicitly \n  converted to <code>Type2</code>. \u200b </p>\n</blockquote>\n<p>(cppreference <a href=\"http://en.cppreference.com/mwiki/index.php?title=cpp%2Falgorithm%2Fupper_bound&amp;action=historysubmit&amp;diff=84047&amp;oldid=77487\">has been fixed</a> since I posted this question, thanks @T.C.)</p>\n<p>Here, <code>T</code> is the third argument to <code>std::upper_bound</code> and <code>ForwardIt</code> is the type of the first two arguments. This quote does not talk about the function object actually being a struct which overloads its <code>operator()</code> to cover the \"forward\" and \"reverse\" situations.</p>\n<p>So in Rules-As-Written, is this legal, or is it an artifact of my specific compiler/standard library combination (g++ 5.3.1)?</p>\n<p>I am interested in answers specific to C++14 or C++17.</p>\n<p>Full example:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n\nstruct Region {\n    Region(int first, int count, int n):\n        first(first),\n        count(count),\n        n(n)\n    {\n\n    }\n\n    int first;\n    int count;\n    int n; // think struct Metadata\n};\n\n\nstruct Comp\n{\n    inline bool operator()(const Region &amp;region, int index) const\n    {\n        return region.first &lt; index;\n    }\n\n    inline bool operator()(int index, const Region &amp;region) const\n    {\n        return index &lt; region.first;\n    }\n};\n\n\nint main() {\n    std::vector&lt;Region&gt; regions;\n    regions.emplace_back(0, 10, 1);\n    regions.emplace_back(10, 10, 2);\n    regions.emplace_back(20, 10, 3);\n\n    const int lookup = 10;\n\n    auto iter = std::upper_bound(\n        regions.begin(),\n        regions.end(),\n        lookup,\n        Comp());\n\n    // yes, I omitted error checking here, with error being iter == regions.begin()\n    std::cout &lt;&lt; lookup &lt;&lt; \" is in region with n = \" &lt;&lt; (iter-1)-&gt;n &lt;&lt; std::endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "36007879", "Title": "Can I legally use a struct with overloaded operator() as Compare for std::upper_bound?", "CreationDate": "2016-03-15T09:39:43.500", "Id": "36007500", "CommentCount": "2", "LastEditDate": "2016-03-15T10:05:45.163", "PostTypeId": "1", "LastEditorUserId": "1248008", "LastActivityDate": "2016-03-15T10:29:44.467", "Score": "13", "OwnerUserId": "1248008", "Tags": "<c++><c++11><stl><language-lawyer>", "AnswerCount": "1"}, "36007879": {"Id": "36007879", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36007500_36007879_0\">Now this happens to work, because <code>upper_bound</code> can internally pick the\n  overload which matches its requirements, as it calls both\n  <code>Comp()(Region, int)</code> and <code>Comp()(int, Region)</code> (which is the reason why a <code>[](const Region &amp;reg, int index){\u2026}</code> would not work).</p>\n</blockquote>\n<p>No, <code>upper_bound</code> only calls <code>Comp</code>'s second overload. That's precisely what your (fixed - thanks @T.C.!) quote is about: The first argument to the comparator is always the  third argument to <code>upper_bound</code>. The lambda's parameters should be swapped.</p>\n<p>Overloading <code>operator()</code> inside a comparator for <code>upper_bound</code>/<code>lower_bound</code> is inherently meaningless, because only one overload will ever be picked by those algorithms.</p>\n<p><code>operator()</code> should be overloaded as you've shown when working with <code>equal_range</code>, and it is legal to do so since the internal details of a comparator (or any functor for that matter) are irrelevant to the library: You solely need to make sure that the ordering is strict (i.e. correct semantics) and the overloads unambiguous.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-15T10:29:44.467", "Score": "9", "CreationDate": "2016-03-15T09:55:24.723", "ParentId": "36007500", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2016-03-15T10:29:44.467"}});