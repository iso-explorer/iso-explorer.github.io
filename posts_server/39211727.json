post_cb({"39211727": {"CommentCount": "5", "AcceptedAnswerId": "39212207", "CreationDate": "2016-08-29T17:17:59.310", "LastActivityDate": "2016-08-29T20:04:56.910", "PostTypeId": "1", "ViewCount": "121", "FavoriteCount": "2", "Title": "Invalid use of incomplete type, reference vs pointer", "Id": "39211727", "Score": "5", "Body": "<p>Code below compiles and works both in Visual Studio and g++:</p>\n<pre><code>class A;\nA* getRef(void);\nchar (&amp;func(...))[2];\n\nint main() {\n    bool isDefault = sizeof(func(getRef()))==2;\n    std::cout &lt;&lt; isDefault &lt;&lt; std::endl; //prints 1\n    return 0;\n}\n</code></pre>\n<p>Next code still compiles (and works) in Studio, but g++ states this is <code>invalid use of incomplete type 'class A'</code>:</p>\n<pre><code>class A;\nA&amp; getRef(void); //the only change\nchar (&amp;func(...))[2];\n\nint main() {\n\n    bool isDefault = sizeof(func(getRef()))==2; //g++ error here\n    std::cout &lt;&lt; isDefault &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Is this a fundamentally wrong code which should be rejected by a compiler (and if so, why VS compiler doesn't produce any warnings)? Or is there actually some difference between pointers and references in this context that I'm not aware of?</p>\n", "Tags": "<c++><g++>", "OwnerUserId": "1835778", "AnswerCount": "2"}, "39211911": {"ParentId": "39211727", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>No matter what the arguments to <code>func</code> are <code>sizeof(func(getRef()))</code> is going to be equal to <code>2</code>. The arguments to <code>func</code> need not be evaluated to come up with that answer.</p>\n<p>From the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_39211727_39211911_0\"><strong>5.3.3 Sizeof</strong></p>\n<p id=\"so_39211727_39211911_1\">1 The <code>sizeof</code> operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is an unevaluated operand (Clause 5), or a parenthesized <em>type-id</em>.</p>\n</blockquote>\n<p>In your case, the operand is an expression, which is an unevaluated operand. The compiler need not evaluate <code>func(getRef())</code> to come up with the value of <code>sizeof(func(getRef()))</code>.</p>\n<p>Hence, I conclude that <code>g++</code> is overreaching in what it needs.</p>\n<hr>\n<p>It appears that g++'s handling of variable argument functions is the culprit. It works fine when <code>func</code> is modified to be</p>\n<pre><code>char (&amp;func(A&amp;))[2];\n</code></pre>\n<p>See it working at <a href=\"http://ideone.com/YQD9v0\" rel=\"nofollow\">http://ideone.com/YQD9v0</a>.</p>\n</hr>", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2016-08-29T20:04:56.910", "Id": "39211911", "Score": "2", "CreationDate": "2016-08-29T17:30:41.190", "LastActivityDate": "2016-08-29T20:04:56.910"}, "bq_ids": {"n4140": {"so_39211727_39211911_1": {"section_id": 6076, "quality": 0.8947368421052632, "length": 17}, "so_39211727_39212207_1": {"section_id": 8, "quality": 0.9230769230769231, "length": 12}, "so_39211727_39212207_0": {"section_id": 5994, "quality": 0.9333333333333333, "length": 28}}, "n3337": {"so_39211727_39211911_1": {"section_id": 5844, "quality": 0.8947368421052632, "length": 17}, "so_39211727_39212207_1": {"section_id": 5, "quality": 0.9230769230769231, "length": 12}, "so_39211727_39212207_0": {"section_id": 5762, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_39211727_39211911_1": {"section_id": 7572, "quality": 0.8947368421052632, "length": 17}, "so_39211727_39212207_1": {"section_id": 8, "quality": 0.9230769230769231, "length": 12}, "so_39211727_39212207_0": {"section_id": 7496, "quality": 0.8333333333333334, "length": 25}}}, "39212207": {"ParentId": "39211727", "CommentCount": "0", "Body": "<p>The crucial aspect of the modified code is that a reference to incomplete type is passed as actual argument to an ellipsis formal argument.</p>\n<i>C++11 \u00a75.2.2/7, about arguments to ellipsis:</i>\n<blockquote>\n<p id=\"so_39211727_39212207_0\"><strong>\u201d</strong> The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and\n  function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that has (possibly cv-qualified) type <code>std::nullptr_t</code> is converted to type <code>void*</code> (4.10). After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed.</p>\n</blockquote>\n<p>Then for the lvalue-to-rvalue conversion, we find</p>\n<i>C++11 \u00a74.1/1:</i>\n<blockquote>\n<p id=\"so_39211727_39212207_1\"><strong>\u201d</strong> A glvalue (3.10) of a non-function, non-array type <code>T</code> can be converted to a prvalue. If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed.</p>\n</blockquote>\n<p>As I read it, but this is just my gut-feeling interpretation, a reference to <code>T</code> is a glvalue of type <code>T</code>, which here is incomplete, yielding ill-formed code.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "39212207", "Score": "4", "CreationDate": "2016-08-29T17:49:57.933", "LastActivityDate": "2016-08-29T17:49:57.933"}});