post_cb({"31344054": {"ParentId": "31343134", "CommentCount": "3", "Body": "<p>I would say that your code</p>\n<pre><code>template&lt;&gt;\nint A&lt;1&gt;::foo() { return 1; } // specialization for N=1\n</code></pre>\n<p>it's an esplicit definition of the member function and as such cannot be done twice. So make sure is inside one translation unit only.</p>\n<blockquote>\n<p id=\"so_31343134_31344054_0\">14.7.3 Explicit specialization</p>\n<p id=\"so_31343134_31344054_1\">5 A member of an explicitly specialized class is not implicitly\n  instantiated from the member declaration of the class template;\n  instead, the member of the class template specialization shall itself\n  be explicitly defined if its definition is required.</p>\n</blockquote>\n", "OwnerUserId": "4877767", "PostTypeId": "2", "Id": "31344054", "Score": "1", "CreationDate": "2015-07-10T14:58:51.667", "LastActivityDate": "2015-07-10T14:58:51.667"}, "31343134": {"CommentCount": "0", "ViewCount": "561", "PostTypeId": "1", "LastEditorUserId": "4634174", "CreationDate": "2015-07-10T14:18:37.040", "LastActivityDate": "2015-07-10T16:10:05.090", "Title": "Multiple instantiation of specialized templates", "LastEditDate": "2015-07-10T16:10:05.090", "Id": "31343134", "Score": "2", "Body": "<p>I have an explicitly instantiated template class with specializations:</p>\n<pre><code>// a.hh\n#pragma once\n\ntemplate&lt;int N&gt;\nstruct A {\n  int foo();\n};\n\n// a.in\n#include \"a.hh\"\n\ntemplate&lt;&gt;\nint A&lt;1&gt;::foo() { return 1; } // specialization for N=1\n\ntemplate&lt;&gt;\nint A&lt;2&gt;::foo() { return 2; } // specialization for N=2\n\n// a1.cc\n#include \"a.in\"\n\ntemplate struct A&lt;1&gt;; // explicit instantiation for N=1\n\n// a2.cc\n#include \"a.in\"\n\ntemplate struct A&lt;2&gt;; // explicit instantiation for N=2\n</code></pre>\n<p>The above files are compiled into a static library with g++ 4.9.2:</p>\n<pre><code>g++ -Wall -c -o a1.o a1.cc\ng++ -Wall -c -o a2.o a2.cc\nar rcs libtest.a a1.o a2.o\n</code></pre>\n<p>I would expect that a1.o contains A&lt;1&gt;::foo(), and a2.o contains A&lt;2&gt;::foo(), but not the other way around, since there is only one instantiation in each of the .cc files.</p>\n<p>It turns out, however, that both object files contain both functions. VS2015RC also gives linker warnings:</p>\n<pre><code>a1.obj : warning LNK4006: \"public: int __thiscall A&lt;1&gt;::foo(void)\" already defined in a2.obj; second definition ignored\na1.obj : warning LNK4006: \"public: int __thiscall A&lt;2&gt;::foo(void)\" already defined in a2.obj; second definition ignored\n</code></pre>\n<p>Why?</p>\n<p>Also, if I comment out the specialization for N=2, with g++ it still compiles silently, even though the explicitly instantiated N=2 case has an unresolved function... (VS2015RC warns that \"no suitable definition provided for explicit template instantiation request\", as expected).</p>\n<hr>\n<p><strong>Clarification</strong> - according to the standard (14.7.3.6):</p>\n<blockquote>\n<p id=\"so_31343134_31343134_0\">If a [..] member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs[.]</p>\n</blockquote>\n<p>This passage (implicitly) states, that a use of the specialization is needed for it to be instantiated.</p>\n<p>My problem is that A&lt;2&gt;::foo() is implicitly instantiated in a1.o, even though there was no use of this specification in that translation unit.</p>\n</hr>", "Tags": "<c++><templates><template-specialization><specialization><explicit-instantiation>", "OwnerUserId": "4634174", "AnswerCount": "2"}, "31343853": {"ParentId": "31343134", "CommentCount": "2", "Body": "<p>Your specialization are not <code>inline</code>. so you have one definition by translation unit including <em>a.in</em>.</p>\n<p>Add <code>inline</code> keyword:</p>\n<pre><code>template&lt;&gt;\ninline int A&lt;1&gt;::foo() { return 1; } // specialization for N=1\n</code></pre>\n<p>or move definition in cpp file:</p>\n<pre><code>// a1.cc\n#include \"a.hh\"\n\ntemplate&lt;&gt;\nint A&lt;1&gt;::foo() { return 1; } // specialization for N=1\n\ntemplate struct A&lt;1&gt;; // explicit instantiation for N=1\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "31343853", "Score": "2", "CreationDate": "2015-07-10T14:50:54.590", "LastActivityDate": "2015-07-10T14:50:54.590"}, "bq_ids": {"n4140": {"so_31343134_31343134_0": {"section_id": 268, "quality": 1.0, "length": 24}, "so_31343134_31344054_1": {"section_id": 267, "quality": 1.0, "length": 21}}, "n3337": {"so_31343134_31343134_0": {"section_id": 259, "quality": 1.0, "length": 24}, "so_31343134_31344054_1": {"section_id": 258, "quality": 1.0, "length": 21}}, "n4659": {"so_31343134_31343134_0": {"section_id": 275, "quality": 1.0, "length": 24}, "so_31343134_31344054_1": {"section_id": 274, "quality": 1.0, "length": 21}}}});