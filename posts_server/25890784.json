post_cb({"25890784": {"ViewCount": "13761", "Body": "<p>I'm trying to compute the length of a string literal at compile time. To do so I'm using following code:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nint constexpr length(const char* str)\n{\n    return *str ? 1 + length(str + 1) : 0;\n}\n\nint main()\n{\n    printf(\"%d %d\", length(\"abcd\"), length(\"abcdefgh\"));\n}\n</code></pre>\n<p>Everything works as expected, the program prints 4 and 8. The assembly code generated by clang shows that the results are computed at compile time:</p>\n<pre><code>0x100000f5e:  leaq   0x35(%rip), %rdi          ; \"%d %d\"\n0x100000f65:  movl   $0x4, %esi\n0x100000f6a:  movl   $0x8, %edx\n0x100000f6f:  xorl   %eax, %eax\n0x100000f71:  callq  0x100000f7a               ; symbol stub for: printf\n</code></pre>\n<p><strong>My question: is it guaranteed by the standard that <code>length</code> function will be evaluated compile time?</strong> </p>\n<p>If this is true the door for compile time string literals computations just opened for me... for example I can compute hashes at compile time and many more... </p>\n", "AcceptedAnswerId": "25891133", "Title": "Computing length of a C string at compile time. Is this really a constexpr?", "CreationDate": "2014-09-17T12:38:30.837", "Id": "25890784", "CommentCount": "11", "FavoriteCount": "16", "PostTypeId": "1", "LastEditDate": "2014-09-20T17:52:28.360", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-28T06:56:06.847", "Score": "71", "OwnerUserId": "336578", "Tags": "<c++><c++11><standards><constexpr><string-literals>", "AnswerCount": "6"}, "26021702": {"Id": "26021702", "PostTypeId": "2", "Body": "<p>Just a note, that modern compilers (like gcc-4.x) do <code>strlen</code> for string literals at compile time because it is normally defined as an <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\">intrinsic function</a>. With no optimizations enabled. Although the result is not a compile time constant.</p>\n<p>E.g.:</p>\n<pre><code>printf(\"%zu\\n\", strlen(\"abc\"));\n</code></pre>\n<p>Results in:</p>\n<pre><code>movl    $3, %esi    # strlen(\"abc\")\nmovl    $.LC0, %edi # \"%zu\\n\"\nmovl    $0, %eax\ncall    printf\n</code></pre>\n", "LastEditorUserId": "412080", "LastActivityDate": "2014-09-25T14:12:55.320", "Score": "11", "CreationDate": "2014-09-24T16:11:52.530", "ParentId": "25890784", "CommentCount": "3", "OwnerUserId": "412080", "LastEditDate": "2014-09-25T14:12:55.320"}, "25891133": {"Id": "25891133", "PostTypeId": "2", "Body": "<p>Constant expressions are not guaranteed to be evaluated at compile time, we only have a non-normative quote from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">draft C++ standard</a> section <code>5.19</code> <em>Constant expressions</em> that says this though:</p>\n<blockquote>\n<p id=\"so_25890784_25891133_0\">[...]&gt;[ Note: Constant expressions can be evaluated during\n  translation.\u2014end note ]</p>\n</blockquote>\n<p>You can assign the result to <code>constexpr</code> variable to be sure it is evaluated at compile time, we can see this from <a href=\"http://www.stroustrup.com/C++11FAQ.html#constexpr\">Bjarne Stroustrup's C++11 reference</a> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_25890784_25891133_1\">In addition to be able to evaluate expressions at compile time, we\n  want to be able to <strong>require expressions to be evaluated at compile\n  time; constexpr in front of a variable definition does that</strong> (and\n  implies const):</p>\n</blockquote>\n<p>For example:</p>\n<pre><code>constexpr int len1 = length(\"abcd\") ;\n</code></pre>\n<p>Bjarne Stroustrup gives a summary of when we can assure compile time evaluation in this <a href=\"https://isocpp.org/blog/2013/01/when-does-a-constexpr-function-get-evaluated-at-compile-time-stackoverflow\">isocpp blog entry</a> and says:</p>\n<blockquote>\n<p id=\"so_25890784_25891133_2\">[...]The correct answer - as stated\n  by Herb - is that according to the standard a constexpr function may\n  be evaluated at compiler time or run time unless it is used as a\n  constant expression, in which case it must be evaluated at\n  compile-time. To guarantee compile-time evaluation, we must either use\n  it where a constant expression is required (e.g., as an array bound or\n  as a case label) or use it to initialize a constexpr. I would hope\n  that no self-respecting compiler would miss the optimization\n  opportunity to do what I originally said: \"A constexpr function is\n  evaluated at compile time if all its arguments are constant\n  expressions.\"</p>\n</blockquote>\n<p>So this outlines two cases where it should be evaluated at compile time:</p>\n<ol>\n<li>Use it where a constant expression is required, this would seem to be anywhere in the draft standard where the phrase <code>shall be ... converted constant expression</code> or <code>shall be ... constant expression</code> is used, such as an array bound.</li>\n<li>Use it to initialize a <code>constexpr</code> as I outline above.</li>\n</ol>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-18T04:18:06.120", "Score": "61", "CreationDate": "2014-09-17T12:53:18.873", "ParentId": "25890784", "CommentCount": "8", "OwnerUserId": "1708801", "LastEditDate": "2014-09-18T04:18:06.120"}, "26082447": {"Id": "26082447", "PostTypeId": "2", "Body": "<p>Let me propose another function that computes the length of a string at compile time without being recursive.</p>\n<pre><code>template&lt; size_t N &gt;\nconstexpr size_t length( char const (&amp;)[N] )\n{\n  return N-1;\n}\n</code></pre>\n<p>Have a look at this <a href=\"http://ideone.com/1qfeVu\">sample code at ideone</a>.</p>\n", "LastActivityDate": "2014-09-28T06:56:06.847", "CommentCount": "4", "CreationDate": "2014-09-28T06:56:06.847", "ParentId": "25890784", "Score": "9", "OwnerUserId": "2436830"}, "bq_ids": {"n4140": {"so_25890784_25891133_0": {"length": 5, "quality": 0.625, "section_id": 6184}}, "n3337": {"so_25890784_25891133_0": {"length": 5, "quality": 0.625, "section_id": 5945}}, "n4659": {"so_25890784_25891133_0": {"length": 5, "quality": 0.625, "section_id": 7686}}}, "25891045": {"Id": "25891045", "PostTypeId": "2", "Body": "<p>There is no guarantee that a <code>constexpr</code> function is evaluated at compile-time, though any reasonable compiler will do it at appropriate optimization levels enabled.  On the other hand, template parameters <em>must</em> be evaluated at compile-time.</p>\n<p>I used the following trick to force evaluation at compile time.  Unfortunately it only works with integral values (ie not with floating point values).</p>\n<pre><code>template&lt;typename T, T V&gt;\nstruct static_eval\n{\n  static constexpr T value = V;\n};\n</code></pre>\n<p>Now, if you write</p>\n<pre><code>if (static_eval&lt;int, length(\"hello, world\")&gt;::value &gt; 7) { ... }\n</code></pre>\n<p>you can be sure that the <code>if</code> statement is a compile-time constant with no run-time overhead.</p>\n", "LastEditorUserId": "1392132", "LastActivityDate": "2014-09-17T20:49:08.573", "Score": "6", "CreationDate": "2014-09-17T12:49:19.743", "ParentId": "25890784", "CommentCount": "4", "OwnerUserId": "1392132", "LastEditDate": "2014-09-17T20:49:08.573"}, "25891011": {"Id": "25891011", "PostTypeId": "2", "Body": "<p>A short explanation from Wikipedia's entry on <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#constexpr_.E2.80.93_Generalized_constant_expressions\" rel=\"nofollow\">Generalized constant expressions</a>:</p>\n<blockquote>\n<p id=\"so_25890784_25891011_0\">The use of constexpr on a function imposes some limitations on what that function can do. First, the function must have a non-void return type. Second, the function body cannot declare variables or define new types. Third, the body may contain only declarations, null statements and a single return statement. There must exist argument values such that, after argument substitution, the expression in the return statement produces a constant expression.</p>\n</blockquote>\n<p>Having the <code>constexpr</code> keyword before a function definition instructs the compiler to check if these limitations are met. If yes, and the function is called with a constant, the returned value is guaranteed to be constant and thus can be used anywhere a constant expression is required.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-19T00:43:46.847", "Score": "1", "CreationDate": "2014-09-17T12:47:52.543", "ParentId": "25890784", "CommentCount": "2", "OwnerUserId": "4046146", "LastEditDate": "2014-09-19T00:43:46.847"}, "25890860": {"Id": "25890860", "PostTypeId": "2", "Body": "<p>It's really easy to find out whether a call to a <code>constexpr</code> function results in a <em>core constant expression</em> or is merely being optimized:</p>\n<p>Use it in a context where a constant expression is required.</p>\n<pre><code>int main()\n{\n    constexpr int test_const = length(\"abcd\");\n    std::array&lt;char,length(\"abcdefgh\")&gt; test_const2;\n}\n</code></pre>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-17T12:49:56.933", "Score": "23", "CreationDate": "2014-09-17T12:41:44.950", "ParentId": "25890784", "CommentCount": "8", "OwnerUserId": "103167", "LastEditDate": "2014-09-17T12:49:56.933"}});