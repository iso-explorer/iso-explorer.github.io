post_cb({"9722954": {"Id": "9722954", "PostTypeId": "2", "Body": "<p>It's totally illegal, and always has been, but a lot of compilers\nneglect to signal the error.  I'm not sure why you want to do this.\nThe one use I know of is to trigger a compile time error from a boolean:</p>\n<pre><code>char someCondition[ condition ];\n</code></pre>\n<p>If <code>condition</code> is a false, then I get a compile time error.  Because\ncompilers do allow this, however, I've taken to using: </p>\n<pre><code>char someCondition[ 2 * condition - 1 ];\n</code></pre>\n<p>This gives a size of either 1 or -1, and I've never found a compiler\nwhich would accept a size of -1.</p>\n", "LastActivityDate": "2012-03-15T15:31:25.800", "CommentCount": "4", "CreationDate": "2012-03-15T15:31:25.800", "ParentId": "9722632", "Score": "22", "OwnerUserId": "649665"}, "9722632": {"ViewCount": "34598", "Body": "<p>Just curious, what actually happens if I define a zero-length array <code>int array[0];</code> in code? GCC doesn't complain at all.</p>\n<p><strong>Sample Program</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int arr[0];\n    return 0;\n}\n</code></pre>\n<p><strong>Clarification</strong></p>\n<p>I'm actually trying to figure out if zero-length arrays initialised this way, instead of being pointed at like the variable length in Darhazer's comments, are optimised out or not.</p>\n<p>This is because I have to release some code out into the wild, so I'm trying to figure out if I have to handle cases where the <code>SIZE</code> is defined as <code>0</code>, which happens in some code with a statically defined <code>int array[SIZE];</code></p>\n<p>I was actually surprised that GCC does not complain, which led to my question. From the answers I've received, I believe the lack of a warning is largely due to supporting old code which has not been updated with the new [] syntax.</p>\n<p>Because I was mainly wondering about the error, I am tagging Lundin's answer as correct (Nawaz's was first, but it wasn't as complete) -- the others were pointing out its actual use for tail-padded structures, while relevant, isn't exactly what I was looking for.</p>\n", "AcceptedAnswerId": "9723093", "Title": "What happens if I define a 0-size array in C/C++?", "CreationDate": "2012-03-15T15:12:42.580", "Id": "9722632", "CommentCount": "13", "FavoriteCount": "17", "PostTypeId": "1", "LastEditDate": "2012-03-15T15:47:46.430", "LastEditorUserId": "733762", "LastActivityDate": "2016-09-01T22:50:12.510", "Score": "93", "OwnerUserId": "733762", "Tags": "<c++><c><arrays>", "AnswerCount": "7"}, "29957036": {"Id": "29957036", "PostTypeId": "2", "Body": "<p>Another use of zero-length arrays is for making variable-length object (pre-C99). <strong>Zero-length arrays</strong> are <em>different</em> from <strong>flexible arrays</strong> which have [] without 0.</p>\n<p>Quoted from <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\" rel=\"noreferrer\">gcc doc</a>:</p>\n<blockquote>\n<p id=\"so_9722632_29957036_0\">Zero-length arrays are allowed in GNU C. They are very useful as the last element of a structure that is really a header for a variable-length object:</p>\n<pre><code> struct line {\n   int length;\n   char contents[0];\n };\n\n struct line *thisline = (struct line *)\n   malloc (sizeof (struct line) + this_length);\n thisline-&gt;length = this_length;\n</code></pre>\n<p id=\"so_9722632_29957036_1\">In ISO C99, you would use a flexible array member, which is slightly different in syntax and semantics:</p>\n<ul>\n<li>Flexible array members are written as contents[] without the 0.</li>\n<li>Flexible array members have incomplete type, and so the sizeof operator may not be applied.</li>\n</ul>\n</blockquote>\n<p>A real-world example is zero-length arrays of <code>struct kdbus_item</code> in <a href=\"https://github.com/gregkh/kdbus/blob/master/kdbus.h\" rel=\"noreferrer\">kdbus.h</a> (a Linux kernel module).</p>\n", "LastEditorUserId": "891046", "LastActivityDate": "2015-05-01T03:27:50.137", "Score": "6", "CreationDate": "2015-04-30T00:36:34.987", "ParentId": "9722632", "CommentCount": "5", "OwnerUserId": "891046", "LastEditDate": "2015-05-01T03:27:50.137"}, "9723093": {"Id": "9723093", "PostTypeId": "2", "Body": "<p>An array cannot have zero size.</p>\n<p>ISO 9899:2011 6.7.6.2:</p>\n<blockquote>\n<p id=\"so_9722632_9723093_0\">If the expression is a constant expression, it shall have a value greater than zero.</p>\n</blockquote>\n<p>The above text is true both for a plain array (paragraph 1). For a VLA (variable length array), the behavior is undefined if the expression's value is less than or equal to zero (paragraph 5). This is normative text in the C standard. A compiler is not allowed to implement it differently.</p>\n<p><code>gcc -std=c99 -pedantic</code> gives a warning for the non-VLA case.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2016-09-01T22:50:12.510", "Score": "67", "CreationDate": "2012-03-15T15:38:59.650", "ParentId": "9722632", "CommentCount": "21", "OwnerUserId": "584518", "LastEditDate": "2016-09-01T22:50:12.510"}, "9725504": {"Id": "9725504", "PostTypeId": "2", "Body": "<p>Zero-size array declarations within structs would be useful if they were allowed, and if the semantics were such that (1) they would force alignment but otherwise not allocate any space, and (2) indexing the array would be considered defined behavior in the case where the resulting pointer would be within the same block of memory as the struct.  Such behavior was never permitted by any C standard, but some older compilers allowed it before it became standard for compilers to allow incomplete array declarations with empty brackets.</p>\n<p>The struct hack, as commonly implemented using an array of size 1, is dodgy and I don't think there's any requirement that compilers refrain from breaking it.  For example, I would expect that if a compiler sees <code>int a[1]</code>, it would be within its rights to regard <code>a[i]</code> as <code>a[0]</code>.  If someone tries to work around the alignment issues of the struct hack via something like</p>\n<pre>\ntypedef struct {\n  uint32_t size;\n  uint8_t data[4];  // Use four, to avoid having padding throw off the size of the struct\n}\n</pre>\n<p>a compiler might get clever and assume the array size really is four:</p>\n<pre>\n; As written\n  foo = myStruct-&gt;data[i];\n; As interpreted (assuming little-endian hardware)\n  foo = ((*(uint32_t*)myStruct-&gt;data) &gt;&gt; (i &lt;&lt; 3)) &amp; 0xFF;\n</pre>\n<p>Such an optimization might be reasonable, especially if <code>myStruct-&gt;data</code> could be loaded into a register in the same operation as <code>myStruct-&gt;size</code>.  I know nothing in the standard that would forbid such optimization, though of course it would break any code which might expect to access stuff beyond the fourth element.</p>\n", "LastActivityDate": "2012-03-15T18:02:16.607", "CommentCount": "5", "CreationDate": "2012-03-15T18:02:16.607", "ParentId": "9722632", "Score": "5", "OwnerUserId": "363751"}, "bq_ids": {"n4140": {"so_9722632_9723093_0": {"length": 6, "quality": 0.75, "section_id": 500}}, "n3337": {"so_9722632_9723093_0": {"length": 6, "quality": 0.75, "section_id": 491}}, "n4659": {"so_9722632_9723093_0": {"length": 6, "quality": 0.75, "section_id": 7395}}}, "9722863": {"Id": "9722863", "PostTypeId": "2", "Body": "<p>Normally, it is not allowed.</p>\n<p>However it's been current practice in C to use <em>flexible arrays</em>.</p>\n<blockquote>\n<p id=\"so_9722632_9722863_0\"><strong>C99 6.7.2.1, \u00a716</strong>: As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member.</p>\n</blockquote>\n<p>Demonstration:</p>\n<pre><code>struct Array {\n  size_t size;\n  int content[];\n};\n</code></pre>\n<p>The idea is that you would then allocate it so:</p>\n<pre><code>void foo(size_t x) {\n  Array* array = malloc(sizeof(size_t) + x * sizeof(int));\n\n  array-&gt;size = x;\n  for (size_t i = 0; i != x; ++i) {\n    array-&gt;content[i] = 0;\n  }\n}\n</code></pre>\n<p>You might also use it statically (gcc extension):</p>\n<pre><code>Array a = { 3, { 1, 2, 3 } };\n</code></pre>\n<p>This is also known as <em>tail-padded structures</em> (this term predates the publication of the C99 Standard) or <em>struct hack</em> (thanks to Joe Wreschnig for pointing it out).</p>\n<p>However this syntax was standardized (and the effects guaranteed) only lately in C99. Before a constant size was necessary.</p>\n<ul>\n<li><code>1</code> was the portable way to go, though it was rather strange</li>\n<li><code>0</code> was better at indicating intent, but not legal as far as the Standard was concerned and supported as an extension by some compilers (including gcc)</li>\n</ul>\n<p>The tail padding practice, however, relies on the fact that storage is available (careful <code>malloc</code>) so is <strong>not suited</strong> to stack usage in general.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2015-02-04T19:01:34.247", "Score": "61", "CreationDate": "2012-03-15T15:26:01.197", "ParentId": "9722632", "CommentCount": "16", "OwnerUserId": "147192", "LastEditDate": "2015-02-04T19:01:34.247"}, "9722713": {"Id": "9722713", "PostTypeId": "2", "Body": "<p>I'll add that there is a <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Zero-Length.html\">whole page</a> of the online documentation of gcc on this argument. </p>\n<p>Some quotes:</p>\n<blockquote>\n<p id=\"so_9722632_9722713_0\">Zero-length arrays are allowed in GNU C. </p>\n</blockquote>\n<blockquote>\n<p id=\"so_9722632_9722713_1\">In ISO C90, you would have to give contents a length of 1</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_9722632_9722713_2\">GCC versions before 3.0 allowed zero-length arrays to be statically initialized, as if they were flexible arrays. In addition to those cases that were useful, it also allowed initializations in situations that would corrupt later data</p>\n</blockquote>\n<p>so you could</p>\n<pre><code>int arr[0] = { 1 };\n</code></pre>\n<p>and boom :-)</p>\n", "LastActivityDate": "2012-03-15T15:17:29.560", "CommentCount": "9", "CreationDate": "2012-03-15T15:17:29.560", "ParentId": "9722632", "Score": "8", "OwnerUserId": "613130"}, "9722672": {"Id": "9722672", "PostTypeId": "2", "Body": "<p>In Standard C and C++, zero-size array is <strong>not</strong> allowed..</p>\n<p>If you're using GCC, compile it with <code>-pedantic</code> option. It will give <strong>warning</strong>, saying:</p>\n<blockquote>\n<p id=\"so_9722632_9722672_0\"><code>zero.c:3:6: warning: ISO C forbids zero-size array 'a' [-pedantic]</code></p>\n</blockquote>\n<p>In case of C++, it gives similar warning.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2012-03-15T17:57:03.700", "Score": "56", "CreationDate": "2012-03-15T15:15:06.087", "ParentId": "9722632", "CommentCount": "8", "OwnerUserId": "415784", "LastEditDate": "2012-03-15T17:57:03.700"}});