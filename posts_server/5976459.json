post_cb({"5982904": {"Id": "5982904", "PostTypeId": "2", "Body": "<p>Since I haven't seen anyone else explicitly point this out...</p>\n<p>Your copy assignment operator taking its argument by value is an important optimization opportunity if (and <strong>only</strong> if) it's passed an rvalue, due to copy elision. But in a class with an assignment operator that explicitly <strong>only</strong> takes rvalues (i.e., one with a move assignment operator), this is a nonsensical scenario. So, modulo the memory leaks that have already been pointed out in other answers, I'd say your class is already ideal if you simply change the copy assignment operator to take its argument by const reference.</p>\n", "LastActivityDate": "2011-05-12T18:50:37.017", "CommentCount": "2", "CreationDate": "2011-05-12T18:50:37.017", "ParentId": "5976459", "Score": "1", "OwnerUserId": "636019"}, "5976459": {"ViewCount": "4553", "Body": "<p><strong>UPDATE</strong> at the bottom</p>\n<p><strong>q1:</strong> How would you implement the <a href=\"https://stackoverflow.com/questions/4782757/rule-of-three-becomes-rule-of-five-with-c0x\">rule of five</a> for a class that manages rather heavy resources,\nbut of which you want it to be passed around by value because that greatly simplifies and beautifies it's usage? Or are not all five items of the rule even needed?</p>\n<p>In practice, I'm starting something with 3D imaging where an image is usually 128*128*128 doubles.\nBeing able though to write things like this would make the math alot easier:</p>\n<pre><code>Data a = MakeData();\nData c = 5 * a + ( 1 + MakeMoreData() ) / 3;\n</code></pre>\n<p><strong>q2:</strong> Using a combination of copy elision / RVO / move semantics the compiler should be able to this this with a minimum of copying, no?</p>\n<p>I tried to figure out how to do this so I started with the basics; suppose an object implementing the traditional way of implementing copy and assignment:</p>\n<pre><code>class AnObject\n{\npublic:\n  AnObject( size_t n = 0 ) :\n    n( n ),\n    a( new int[ n ] )\n  {}\n  AnObject( const AnObject&amp; rh ) :\n    n( rh.n ),\n    a( new int[ rh.n ] )\n  {\n    std::copy( rh.a, rh.a + n, a );\n  }\n  AnObject&amp; operator = ( AnObject rh )\n  {\n    swap( *this, rh );\n    return *this;\n  }\n  friend void swap( AnObject&amp; first, AnObject&amp; second )\n  {\n    std::swap( first.n, second.n );\n    std::swap( first.a, second.a );\n  }\n  ~AnObject()\n  {\n    delete [] a;\n  }\nprivate:\n  size_t n;\n  int* a;\n};\n</code></pre>\n<p>Now enter rvalues and move semantics. As far as I can tell this would be a working implementation:</p>\n<pre><code>AnObject( AnObject&amp;&amp; rh ) :\n  n( rh.n ),\n  a( rh.a )\n{\n  rh.n = 0;\n  rh.a = nullptr;\n}\n\nAnObject&amp; operator = ( AnObject&amp;&amp; rh )\n{\n  n = rh.n;\n  a = rh.a;\n  rh.n = 0;\n  rh.a = nullptr;\n  return *this;\n}\n</code></pre>\n<p>However the compiler (VC++ 2010 SP1) is not too happy with this, and compilers are usually correct:</p>\n<pre><code>AnObject make()\n{\n  return AnObject();\n}\n\nint main()\n{\n  AnObject a;\n  a = make(); //error C2593: 'operator =' is ambiguous\n}\n</code></pre>\n<p><strong>q3:</strong> How to solve this? Going back to AnObject&amp; operator = ( const AnObject&amp; rh ) certainly fixes it but don't we lose a rather important optimization opportunity?</p>\n<p>Apart from that, it's clear that the code for the move constructor and assignment is full of duplication.\nSo for now we forget about the ambiguity and try to solve this using copy and swap but now for rvalues.\nAs explained <a href=\"https://stackoverflow.com/questions/2078515/why-arent-there-compiler-generated-swap-methods-in-c0x/2078987#2078987\">here</a> we wouldn't even need a custom swap but instead have std::swap do all the work, which sounds very promising.\nSo I wrote the following, hoping std::swap would copy construct a temporary using the move constructor, then swap it with *this:</p>\n<pre><code>AnObject&amp; operator = ( AnObject&amp;&amp; rh )\n{\n  std::swap( *this, rh );\n  return *this;\n}\n</code></pre>\n<p>But that doesn't work out and instead leads to a stack overflow due to infinite recursion since std::swap calls our operator = ( AnObject&amp;&amp; rh ) again. <strong>q4:</strong> Can someone provide an example of what is meant in the example then?</p>\n<p>We can solve this by providing a second swap function:</p>\n<pre><code>AnObject( AnObject&amp;&amp; rh )\n{\n  swap( *this, std::move( rh ) );\n}\n\nAnObject&amp; operator = ( AnObject&amp;&amp; rh )\n{\n  swap( *this, std::move( rh ) );\n  return *this;\n}\n\nfriend void swap( AnObject&amp; first, AnObject&amp;&amp; second )\n{\n  first.n = second.n;\n  first.a = second.a;\n  second.n = 0;\n  second.a = nullptr;\n}\n</code></pre>\n<p>Now there's almost twice the amount code, however the move part of it pays of by alowing pretty cheap moving; but on the other hand the normal assignment can't benefit from copy elision anymore. \nAt this point I'm really confused though, and not seeing anymore what's right and wrong, so I'm hoping to get some input here..</p>\n<p><strong>UPDATE</strong> So it seems there are two camps:</p>\n<ul>\n<li>one saying to skip the move assignment operator and continue doing what C++03 taught us, ie write a single assignment operator that passes the argument by value.</li>\n<li>the other one saying to implement the move assignment operator (after all, it's C++11 now) and have the copy assignment operator take its argument by reference.</li>\n</ul>\n<p>(ok and there's the 3rd camp telling me to use a vector, but that's sort of out of scope for this hypothetical class. Ok in real life I would use a vector, and there would be also other members, but since the move constructor/assignment are not automatically generated (yet?) the question would still hold)</p>\n<p>Unfortunately I cannot test both implementations in a real world scenario since this project has just started and the way the data will actually flow is not known yet. So I simply implemented both of them, added counters for allocation etc and ran a couple of iterations of approx. this code, where T is one of the implementations:</p>\n<pre><code>template&lt; class T &gt;\nT make() { return T( narraySize ); }\n\ntemplate&lt; class T &gt;\nvoid assign( T&amp; r ) { r = make&lt; T &gt;(); }\n\ntemplate&lt; class T &gt;\nvoid Test()\n{\n  T a;\n  T b;\n  for( size_t i = 0 ; i &lt; numIter ; ++i )\n  {\n    assign( a );\n    assign( b );\n    T d( a );\n    T e( b );\n    T f( make&lt; T &gt;() );\n    T g( make&lt; T &gt;() + make&lt; T &gt;() );\n  }\n}\n</code></pre>\n<p>Either this code is not good enough to test what I'm after, or the compiler is just too smart: doesn't matter what I use for arraySize and numIter, the results for both camps are pretty much identical: same number of allocations, very slight variations in timing but no reproducable significant difference.</p>\n<p>So unless someone can point to a better way to test this (given that the actual usage scnearios are not known yet), I'll have to conclude that it doesn't matter and hence is left to the taste of the developper. In which case I'd pick #2.</p>\n", "AcceptedAnswerId": "5977635", "Title": "How to actually implement the rule of five?", "CreationDate": "2011-05-12T10:11:19.343", "Id": "5976459", "CommentCount": "2", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:29.277", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-10T13:29:11.773", "Score": "41", "OwnerUserId": "128384", "Tags": "<c++><c++11><move-semantics><rvalue-reference>", "AnswerCount": "6"}, "5976829": {"Id": "5976829", "PostTypeId": "2", "Body": "<p>If your object is resource-heavy, you might want to avoid copying altogether, and just provide the move constructor and move assignment operator. However, if you really want copying too, it is easy to provide all of the operations.</p>\n<p>Your copy operations look sensible, but your move operations don't. Firstly, though an rvalue reference parameter will <strong>bind</strong> to an rvalue, within the function it is an <strong>lvalue</strong>, so your move constructor ought to be:</p>\n<pre><code>AnObject( AnObject&amp;&amp; rh ) :\n  n( std::move(rh.n) ),\n  a( std::move(rh.a) )\n{\n  rh.n = 0;\n  rh.a = nullptr;\n}\n</code></pre>\n<p>Of course, for fundamental types like you've got here it doesn't actually make a difference, but it's as well to get in the habit.</p>\n<p>If you provide a move-constructor, then you don't need a move-assignment operator when you define copy-assignment like you have --- because you accept the parameter by <strong>value</strong>, an rvalue will be moved into the parameter rather than copied.</p>\n<p>As you found, you can't use <code>std::swap()</code> on the whole object inside a move-assignment operator, since that will recurse back into the move-assignment operator. The point of the comment in the post you linked to is that you don't need to implement a custom <code>swap</code> if you provide move operations, as <code>std::swap</code> will use your move operations. Unfortunately, if you don't define a separate move assignment operator this doesn't work, and will still recurse. You can of course use <code>std::swap</code> to swap the members:</p>\n<pre><code>AnObject&amp; operator=(AnObject other)\n{\n    std::swap(n,other.n);\n    std::swap(a,other.a);\n    return *this;\n}\n</code></pre>\n<p>Your final class is thus:</p>\n<pre><code>class AnObject\n{\npublic:\n  AnObject( size_t n = 0 ) :\n    n( n ),\n    a( new int[ n ] )\n  {}\n  AnObject( const AnObject&amp; rh ) :\n    n( rh.n ),\n    a( new int[ rh.n ] )\n  {\n    std::copy( rh.a, rh.a + n, a );\n  }\n  AnObject( AnObject&amp;&amp; rh ) :\n    n( std::move(rh.n) ),\n    a( std::move(rh.a) )\n  {\n    rh.n = 0;\n    rh.a = nullptr;\n  }\n  AnObject&amp; operator = ( AnObject rh )\n  {\n    std::swap(n,rh.n);\n    std::swap(a,rh.a);\n    return *this;\n  }\n  ~AnObject()\n  {\n    delete [] a;\n  }\nprivate:\n  size_t n;\n  int* a;\n};\n</code></pre>\n", "LastEditorUserId": "5597", "LastActivityDate": "2011-05-12T12:28:04.400", "Score": "13", "CreationDate": "2011-05-12T10:46:12.433", "ParentId": "5976459", "CommentCount": "9", "OwnerUserId": "5597", "LastEditDate": "2011-05-12T12:28:04.400"}, "5977635": {"Id": "5977635", "PostTypeId": "2", "Body": "<p>You've missed a significant optimization in your copy assignment operator.  And subsequently the situation has gotten confused.</p>\n<pre><code>  AnObject&amp; operator = ( const AnObject&amp; rh )\n  {\n    if (this != &amp;rh)\n    {\n      if (n != rh.n)\n      {\n         delete [] a;\n         n = 0;\n         a = new int [ rh.n ];\n         n = rh.n;\n      }\n      std::copy(rh.a, rh.a+n, a);\n    }\n    return *this;\n  }\n</code></pre>\n<p>Unless you really <em>never</em> think you'll be assigning <code>AnObject</code>s of the same size, this is much better.  Never throw away resources if you can recycle them.</p>\n<p>Some might complain that the <code>AnObject</code>'s copy assignment operator now has only basic exception safety instead of strong exception safety.  However consider this:</p>\n<blockquote>\n<p id=\"so_5976459_5977635_0\">Your clients can always take a fast\n  assignment operator and give it strong\n  exception safety.  But they can't take\n  a slow assignment operator and make it\n  faster.</p>\n<pre><code>template &lt;class T&gt;\nT&amp;\nstrong_assign(T&amp; x, T y)\n{\n    swap(x, y);\n    return x;\n}\n</code></pre>\n</blockquote>\n<p>Your move constructor is fine, but your move assignment operator has a memory leak.  It should be:</p>\n<pre><code>  AnObject&amp; operator = ( AnObject&amp;&amp; rh )\n  {\n    delete [] a;\n    n = rh.n;\n    a = rh.a;\n    rh.n = 0;\n    rh.a = nullptr;\n    return *this;\n  }\n</code></pre>\n<p>...</p>\n<blockquote>\n<pre><code>Data a = MakeData();\nData c = 5 * a + ( 1 + MakeMoreData() ) / 3;\n</code></pre>\n<p id=\"so_5976459_5977635_1\"><strong>q2:</strong> Using a combination of copy elision / RVO / move semantics the\n  compiler should be able to this this\n  with a minimum of copying, no?</p>\n</blockquote>\n<p>You may need to overload your operators to take advantage of resources in rvalues:</p>\n<pre><code>Data operator+(Data&amp;&amp; x, const Data&amp; y)\n{\n   // recycle resources in x!\n   x += y;\n   return std::move(x);\n}\n</code></pre>\n<p>Ultimately resources ought to be created exactly once for each <code>Data</code> you care about.  There should be no needless <code>new/delete</code> just for the purpose of moving things around.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2011-05-12T12:12:56.157", "Score": "16", "CreationDate": "2011-05-12T12:00:38.337", "ParentId": "5976459", "CommentCount": "9", "OwnerUserId": "576911", "LastEditDate": "2011-05-12T12:12:56.157"}, "bq_ids": {"n4140": {"so_5976459_5977975_2": {"length": 6, "quality": 1.0, "section_id": 458}, "so_5976459_5977975_3": {"length": 6, "quality": 1.0, "section_id": 458}, "so_5976459_5977975_6": {"length": 19, "quality": 0.8636363636363636, "section_id": 458}, "so_5976459_5977975_0": {"length": 12, "quality": 1.0, "section_id": 458}, "so_5976459_5977975_1": {"length": 5, "quality": 1.0, "section_id": 458}, "so_5976459_5977975_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 456}}, "n3337": {"so_5976459_5977975_1": {"length": 5, "quality": 1.0, "section_id": 449}, "so_5976459_5977975_4": {"length": 4, "quality": 1.0, "section_id": 449}, "so_5976459_5977975_3": {"length": 6, "quality": 1.0, "section_id": 449}, "so_5976459_5977975_6": {"length": 19, "quality": 0.8636363636363636, "section_id": 449}, "so_5976459_5977975_0": {"length": 12, "quality": 1.0, "section_id": 449}, "so_5976459_5977975_2": {"length": 6, "quality": 1.0, "section_id": 449}, "so_5976459_5977975_5": {"length": 6, "quality": 1.0, "section_id": 449}}, "n4659": {"so_5976459_5977975_1": {"length": 5, "quality": 1.0, "section_id": 481}, "so_5976459_5977975_3": {"length": 6, "quality": 1.0, "section_id": 481}, "so_5976459_5977975_6": {"length": 19, "quality": 0.8636363636363636, "section_id": 481}, "so_5976459_5977975_0": {"length": 12, "quality": 1.0, "section_id": 481}, "so_5976459_5977975_2": {"length": 6, "quality": 1.0, "section_id": 481}, "so_5976459_5977975_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 479}}}, "7954173": {"Id": "7954173", "PostTypeId": "2", "Body": "<p><strong>q3 of the Original Poster</strong></p>\n<p>I think you (and some of the other responders) misunderstood what the compiler error meant, and came to the wrong conclusions because of it.  The compiler thinks that the (move) assignment call is ambiguous, and it's right!  You have multiple methods that are equally qualified.</p>\n<p>In your original version of the <code>AnObject</code> class, your copy constructor takes in the old object by <code>const</code> (lvalue) reference, while the assignment operator takes its argument by (unqualified) value.  The value argument is initialized by the appropriate transfer constructor from whatever was on the right-side of the operator.  Since you have only one transfer constructor, that copy constructor is always used, no matter if the original right-side expression was a lvalue or a rvalue.  This makes the assignment operator act as the copy-assignment special member function.</p>\n<p>The situation changes once a move constructor is added.  Whenever the assignment operator is called, there are two choices for the transfer constructor.  The copy constructor will still be used for lvalue expressions, but the move constructor will be used whenever a rvalue expression is given instead!  This makes the assignment operator <em>simultaneously</em> act as the move-assignment special member function.</p>\n<p>When you added a traditional move-assignment operator, you gave the class two versions of the same special member function, which is an error.  You already have what you wanted, so just get rid of the traditional move-assignment operator, and no other changes should be needed.</p>\n<p>In the two camps listed in your update, I guess I'm technically in the first camp, but for entirely different reasons.  (Don't skip the (traditional) move-assignment operator because it's \"broken\" for your class, but because it's superfluous.)</p>\n<p>BTW, I'm new to reading about C++11 and StackOverflow.  I came up with this answer from browsing another S.O. question before seeing this one.  (<strong>Update</strong>: Actually, I still had the <a href=\"https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me/3109981#3109981\">page</a> open.  The link goes to the specific response by <a href=\"https://stackoverflow.com/users/252000/fredoverflow\">FredOverflow</a> that shows the technique.)</p>\n<p><strong>About the 2011-May-12 Response by Howard Hinnant</strong></p>\n<p>(I'm too much of a newbie to directly comment on responses.)</p>\n<p>You don't need to explicitly check for self-assignment if a later test would already cull it.  In this case, <code>n != rh.n</code> would already take care of most of it.  However, the <code>std::copy</code> call is outside of that (currently) inner <code>if</code>, so we would get <code>n</code> component-level self-assignments.  It's up to you to decide if those assignments would be too anti-optimal even though self-assignment should be rare.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-10-31T20:55:46.803", "Score": "1", "CreationDate": "2011-10-31T13:09:04.323", "ParentId": "5976459", "CommentCount": "0", "OwnerUserId": "1010226", "LastEditDate": "2017-05-23T11:45:27.080"}, "5977975": {"Id": "5977975", "PostTypeId": "2", "Body": "<p>Let me help you:</p>\n<pre><code>#include &lt;vector&gt;\n\nclass AnObject\n{\npublic:\n  AnObject( size_t n = 0 ) : data(n) {}\n\nprivate:\n  std::vector&lt;int&gt; data;\n};\n</code></pre>\n<p>From the C++0x FDIS, <strong>[class.copy]</strong> note 9:</p>\n<blockquote>\n<p id=\"so_5976459_5977975_0\">If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</p>\n<ul>\n<li><p id=\"so_5976459_5977975_1\">X does not have a user-declared copy constructor,</p></li>\n<li><p id=\"so_5976459_5977975_2\">X does not have a user-declared copy assignment operator,</p></li>\n<li><p id=\"so_5976459_5977975_3\">X does not have a user-declared move assignment operator,</p></li>\n<li><p id=\"so_5976459_5977975_4\">X does not have a user-declared destructor, and</p></li>\n<li><p id=\"so_5976459_5977975_5\">the move constructor would not be implicitly defined as deleted.</p></li>\n</ul>\n<p id=\"so_5976459_5977975_6\"><em>[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise would have invoked the move constructor may instead invoke a copy constructor. \u2014end note ]</em></p>\n</blockquote>\n<p>Personally, I am much more confident in <code>std::vector</code> correctly managing its resources and optimizing the copies / moves that in any code I could write.</p>\n", "LastActivityDate": "2011-05-12T12:28:32.027", "CommentCount": "2", "CreationDate": "2011-05-12T12:28:32.027", "ParentId": "5976459", "Score": "4", "OwnerUserId": "147192"}, "42160564": {"Id": "42160564", "PostTypeId": "2", "Body": "<p>With help of delegating constructor, you only need to implement each concept once;</p>\n<ul>\n<li>default init</li>\n<li>resource delete</li>\n<li>swap</li>\n<li>copy</li>\n</ul>\n<p>the rest just uses those.</p>\n<p>Also don't forget to make move-assignment (and swap) <code>noexcept</code>,\nif helps performance a lot if you, for example, put your class\nin a <code>vector</code></p>\n<pre><code>#include &lt;utility&gt;\n\n// header\n\nclass T\n{\npublic:\n    T();\n    T(const T&amp;);\n    T(T&amp;&amp;);\n    T&amp; operator=(const T&amp;);\n    T&amp; operator=(T&amp;&amp;) noexcept;\n    ~T();\n\n    void swap(T&amp;) noexcept;\n\nprivate:\n    void copy_from(const T&amp;);\n};\n\n// implementation\n\nT::T()\n{\n    // here (and only here) you implement default init\n}\n\nT::~T()\n{\n    // here (and only here) you implement resource delete\n}\n\nvoid T::swap(T&amp;) noexcept\n{\n    using std::swap; // enable ADL\n    // here (and only here) you implement swap, typically memberwise swap\n}\n\nvoid T::copy_from(const T&amp; t)\n{\n    if( this == &amp;t ) return; // don't forget to protect against self assign\n    // here (and only here) you implement copy\n}\n\n// the rest is generic:\n\nT::T(const T&amp; t)\n    : T()\n{\n    copy_from(t);\n}\n\nT::T(T&amp;&amp; t)\n    : T()\n{\n    swap(t);\n}\n\nauto T::operator=(const T&amp; t) -&gt; T&amp;\n{\n    copy_from(t);\n    return *this;\n}\n\nauto T::operator=(T&amp;&amp; t) noexcept -&gt; T&amp;\n{\n    swap(t);\n    return *this;\n}\n</code></pre>\n", "LastActivityDate": "2017-02-10T13:29:11.773", "CommentCount": "0", "CreationDate": "2017-02-10T13:29:11.773", "ParentId": "5976459", "Score": "1", "OwnerUserId": "3202093"}});