post_cb({"24632964": {"ParentId": "24566576", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think the reason for first <code>static_cast</code> is being able to work with functions and libraries that expect old style <code>enum</code> or even used a bunch of defined values for enumerations and directly expect an integral type. But there is no other logical relation between type <code>enum</code> and an integral type, so you should use <code>reinterpret_cast</code> if you want that cast. but if you have problems with <code>reinterpret_cast</code> you can use your own helper:</p>\n<pre><code>template&lt; class EnumT &gt;\ntypename std::enable_if&lt;\n    std::is_enum&lt;EnumT&gt;::value,\n    typename std::underlying_type&lt;EnumT&gt;::type*\n&gt;::type enum_as_pointer(EnumT&amp; e)\n{\n    return reinterpret_cast&lt;typename std::underlying_type&lt;EnumT&gt;::type*&gt;(&amp;e);\n}\n</code></pre>\n<p>or</p>\n<pre><code>template&lt; class IntT, class EnumT &gt;\nIntT* static_enum_cast(EnumT* e, \n    typename std::enable_if&lt;\n        std::is_enum&lt;EnumT&gt;::value &amp;&amp;\n        std::is_convertible&lt;\n            typename std::underlying_type&lt;EnumT&gt;::type*,\n            IntT*\n        &gt;::value\n    &gt;::type** = nullptr)\n{\n    return reinterpret_cast&lt;typename std::underlying_type&lt;EnumT&gt;::type*&gt;(&amp;e);\n}\n</code></pre>\n<p>While this answer may not satisfy you about the <code>reason of prohibiting static_cast of enum pointers</code>, it give you a safe way to use <code>reinterpret_cast</code> with them.</p>\n", "OwnerUserId": "1425813", "LastEditorUserId": "1425813", "LastEditDate": "2014-07-12T19:50:15.860", "Id": "24632964", "Score": "1", "CreationDate": "2014-07-08T13:20:02.760", "LastActivityDate": "2014-07-12T19:50:15.860"}, "24639661": {"ParentId": "24566576", "CommentCount": "0", "Body": "<p>The answers to your questions can be found in the section <strong>5.2.9 Static cast</strong> in the draft standard.</p>\n<p>Support for allowing</p>\n<pre><code>int iv = static_cast&lt;int&gt;(me);\n</code></pre>\n<p>can be obtained from:</p>\n<blockquote>\n<p id=\"so_24566576_24639661_0\">5.2.9/9 A value of a scoped enumeration type (7.2) can be explicitly converted to an integral type. The value is unchanged if the original value can be represented by the specified type. Otherwise, the resulting value is unspecified.</p>\n</blockquote>\n<p>Support for allowing</p>\n<pre><code>me = static_cast&lt;MyEnum&gt;(100);\n</code></pre>\n<p>can be obtained from:</p>\n<blockquote>\n<p id=\"so_24566576_24639661_1\">5.2.9/10 A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting value is unspecified (and might not be in that range).</p>\n</blockquote>\n<p>Support for not allowing</p>\n<pre><code>int* ip = static_cast&lt;int*&gt;(&amp;me);\n</code></pre>\n<p>can be obtained from:</p>\n<blockquote>\n<p id=\"so_24566576_24639661_2\">5.2.9/11 A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be converted to a prvalue of type \u201cpointer to cv2 D,\u201d where D is a class derived (Clause 10) from B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and B is neither a virtual base class of D nor a base class of a virtual base class of D. The null pointer value (4.10)\n  is converted to the null pointer value of the destination type. If the prvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object of type D. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n<p><code>static_cast</code> cannot be used to cast <code>&amp;me</code> to an <code>int*</code> since <code>MyEnum</code> and <code>int</code> are not related by inheritance.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "24639661", "Score": "3", "CreationDate": "2014-07-08T18:57:07.273", "LastActivityDate": "2014-07-08T18:57:07.273"}, "24641541": {"ParentId": "24566576", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><strong>TL;DR:</strong> The designers of C++ don't like type punning.</p>\n<p>Others have pointed out why it's not allowed by the standard; I will try to address why the writers of the standard might have made it that way. According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf\" rel=\"nofollow\">this proposal</a>, the primary motivation for strongly-typed enums was type safety. Unfortunately, type safety means many things to many people. It's fair to assume consistency was another goal of the standards committee, so let's examine type safety in other relevant contexts of C++.</p>\n<h1>C++ type safety</h1>\n<p>In C++ in general, types are unrelated unless explicitly specified to be related (through inheritance). Consider this example:</p>\n<pre><code>class A\n{\n    double x;\n    int y;\n};\n\nclass B\n{\n    double x;\n    int y;\n};\n\nvoid foo(A* a)\n{\n    B* b = static_cast&lt;B*&gt;(a); //error\n}\n</code></pre>\n<p>Even though A and B have the exact same representation (the standard would even call them \"standard-layout types\"), you cannot convert between them without a <code>reinterpret_cast</code>. Similarly, this is also an error:</p>\n<pre><code>class C\n{\npublic:\n    int x;\n};\n\nvoid foo(C* c)\n{\n    int* intPtr = static_cast&lt;int*&gt;(c); //error\n}\n</code></pre>\n<p>Even though we know the only thing in C is an int and you can freely access it, the <code>static_cast</code> fails. Why? It's not explicitly specified that these types are related. C++ was designed to support object-oriented programming, which provides a distinction between composition and inheritance. You can convert between types related by inheritance, but not those related by composition.</p>\n<p>Based on the behavior you've seen, it's clear strongly-typed enums are related by composition to their underlying types. Why might this have been the model the standard committee chose?</p>\n<h1>Composition vs Inheritance</h1>\n<p>There are many articles on this issue better written than anything I could fit here, but I'll attempt to summarize. When to use composition vs. when to use inheritance is certainly a grey area, but there are many points in favor of composition in this case.</p>\n<ol>\n<li>Strongly-typed enums are not intended to be used as integral values. Thus the 'is-a' relationship indicated by inheritance does not fit.</li>\n<li>On the highest level, enums are meant to represent a set of discrete values. The fact that this is implemented through assigning an id number to each value is generally not important (unfortunately C exposes and thus enforces this relationship).</li>\n<li>Looking back at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf\" rel=\"nofollow\">the proposal</a>, the listed reason for allowing a specified underlying type is to specify the size and signedness of the enum.  This is much more of an implementation detail than an essential part of the enum, again favoring composition.</li>\n</ol>\n<p>You could argue for days about whether or not inheritance or composition is better in this case, but ultimately a decision had to be made and the behavior was modeled on composition.</p>\n", "OwnerUserId": "2263978", "LastEditorUserId": "1995714", "LastEditDate": "2015-12-02T23:24:23.223", "Id": "24641541", "Score": "10", "CreationDate": "2014-07-08T21:01:35.033", "LastActivityDate": "2015-12-02T23:24:23.223"}, "24566758": {"ParentId": "24566576", "CommentCount": "4", "Body": "<p>Instead, look at it in a slightly different way. You can't <code>static_cast</code> a <code>long*</code> to <code>int*</code> even if <code>int</code> and <code>long</code> have identical underlying representations. For same same reason an enum based on <code>int</code> is yet treated as a unique, unrelated type to <code>int</code> and as such requires the <code>reinterpret_cast</code>.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "24566758", "Score": "8", "CreationDate": "2014-07-04T04:33:03.593", "LastActivityDate": "2014-07-04T04:33:03.593"}, "24570962": {"ParentId": "24566576", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I think the error of thinking is that</p>\n<pre><code>enum class MyEnum : int {};\n</code></pre>\n<p>is not really inheritance. Of course you can say <code>MyEnum</code> <em>is an</em> <code>int</code>. However, it is different from classic inheritance, inasmuch as not all operations that are available on <code>int</code>s are available for <code>MyEnum</code> also. </p>\n<p>Let's compare this to the following: A circle is an ellipse. However, it would almost always be wrong to implement a <code>CirlceShape</code> as inheriting from <code>EllipseShape</code> since not all operations that are possible on ellipses are also possible for circle. A simple example would be scaling the shape in x direction. </p>\n<p>Hence, to think of enum classes as <em>inheriting</em> from an integer type leads to the confusion in your case. You cannot increment an instance of an enum class, but you can increment integers. Since it's not <em>really</em> inheritance, it makes sense to prohibit casting pointers to these types statically. The following line is not safe:</p>\n<pre><code>++*reinterpret_cast&lt;int*&gt;(&amp;me);\n</code></pre>\n<p>This might be the reason why the committee prohibited <code>static_cast</code> in this case. In general <code>reinterpret_cast</code> is considered to be evil while <code>static_cast</code> is considered to be ok. </p>\n", "OwnerUserId": "3804898", "LastEditorUserId": "3804898", "LastEditDate": "2014-07-04T10:45:31.477", "Id": "24570962", "Score": "6", "CreationDate": "2014-07-04T09:25:11.830", "LastActivityDate": "2014-07-04T10:45:31.477"}, "24566576": {"CommentCount": "9", "AcceptedAnswerId": "24641541", "CreationDate": "2014-07-04T04:08:48.837", "LastActivityDate": "2015-12-02T23:24:23.223", "PostTypeId": "1", "ViewCount": "6051", "FavoriteCount": "5", "Title": "Why can't C++11 strongly-typed enum be cast to underlying type via pointer?", "Id": "24566576", "Score": "21", "Body": "<p>In C++11 we can cast a strongly-typed enum (<code>enum class</code>) to its underlying type.  But it seems we cannot cast a pointer to the same:</p>\n<pre><code>enum class MyEnum : int {};\n\nint main()\n{\n  MyEnum me;\n\n  int iv = static_cast&lt;int&gt;(me); // works\n  int* ip = static_cast&lt;int*&gt;(&amp;me); // \"invalid static_cast\"\n}\n</code></pre>\n<p>I'm trying to understand why this should be: is there something about the enum mechanism that makes it hard or nonsensical to support this?  Is it a simple oversight in the standard?  Something else?</p>\n<p>It seems to me that if an enum type is truly built on top of an integral type as above, we should be able to cast not only the values but also the pointers.  We can still use <code>reinterpret_cast&lt;int*&gt;</code> or a C-style cast but that's a bigger hammer than I thought we'd need.</p>\n", "Tags": "<c++><c++11><enums><enum-class><strongly-typed-enum>", "OwnerUserId": "4323", "AnswerCount": "6"}, "24634262": {"ParentId": "24566576", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_24566576_24634262_0\">An enumeration is a distinct type (3.9.2) with named constants. [...] Each enumeration defines a type that is different from all other types. [...] Two enumeration types are layout-compatible if they have the same underlying type.</p>\n</blockquote>\n<p><strong>[dcl.enum]</strong> (\u00a77.2)</p>\n<p>The underlying type specifies the layout of the enum in memory, not its relation to other types in the type system (as the standard says, it's a <em>distinct type</em>, a type of its own). A pointer to an <code>enum : int {}</code> can never implicitly convert to an <code>int*</code>, the same way that a pointer to a <code>struct { int i; };</code> cannot, even though they all look the same in memory.</p>\n<p>So why does the implicit conversion to <code>int</code> work in the first place?</p>\n<blockquote>\n<p id=\"so_24566576_24634262_1\">For an enumeration whose underlying type is fixed, the values of the\n  enumeration are the values of the underlying type. [...] The value of\n  an enumerator or an object of an unscoped enumeration type is\n  converted to an integer by integral promotion (4.5).</p>\n</blockquote>\n<p><strong>[dcl.enum]</strong> (\u00a77.2)</p>\n<p>So we can assign values of an enum to an <code>int</code> because they are of type <code>int</code>. An object of enum type can be assigned to an <code>int</code> because of the rules of integer promotion. By the way, the standard here specifically points out that this is only true for C-style (unscoped) enums. This means that you still need the <code>static_cast&lt;int&gt;</code> in the first line of your example, but as soon as you turn the <code>enum class : int</code> into an <code>enum : int</code> it will work without the explicit cast. Still no luck with the pointer type though.</p>\n<p>Integral promotions are defined in the standard at <strong>[conv.prom]</strong> (\u00a74.5). I'll spare you the details of quoting the full section, but the important detail here is that all rules in there apply to <em>prvalues</em> of non-pointer types, so none of this applies to our little problem.</p>\n<p>The final piece of the puzzle can be found in <strong>[expr.static.cast]</strong> (\u00a75.2.9), which describes how <code>static_cast</code> works.</p>\n<blockquote>\n<p id=\"so_24566576_24634262_2\">A value of a scoped enumeration type (7.2) can be explicitly converted\n  to an integral type.</p>\n</blockquote>\n<p>That explains why your cast from <code>enum class</code> to <code>int</code> works.</p>\n<p>But note that all of the <code>static_cast</code>s allowed on pointer types (again, I won't quote the rather lengthy section) require some relationship between the types. If you remember the beginning of the answer, each enum is a distinct type, so there is no relationship to their underlying type or other enums of the same underlying type.</p>\n<p>This ties in with <a href=\"https://stackoverflow.com/a/24566758/577603\">@MarkB's answer</a>: Static-casting a pointer <code>enum</code> to a pointer to <code>int</code> is analogous to casting a pointer from one integral type to another - even if both have the same memory layout underneath and values of one will implicitly convert to the other by the rules integral promotions, they are still unrelated types, so <code>static_cast</code> will not work here.</p>\n", "OwnerUserId": "577603", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:23:04.317", "Id": "24634262", "Score": "7", "CreationDate": "2014-07-08T14:21:23.500", "LastActivityDate": "2014-07-08T14:21:23.500"}, "bq_ids": {"n4140": {"so_24566576_24634262_2": {"section_id": 6035, "quality": 1.0, "length": 9}, "so_24566576_24639661_1": {"section_id": 6036, "quality": 0.92, "length": 23}, "so_24566576_24634262_1": {"section_id": 5467, "quality": 0.6363636363636364, "length": 14}, "so_24566576_24639661_2": {"section_id": 6037, "quality": 0.8450704225352113, "length": 60}, "so_24566576_24639661_0": {"section_id": 6035, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_24566576_24634262_2": {"section_id": 5803, "quality": 1.0, "length": 9}, "so_24566576_24639661_0": {"section_id": 5803, "quality": 0.9130434782608695, "length": 21}, "so_24566576_24634262_1": {"section_id": 5253, "quality": 0.6363636363636364, "length": 14}, "so_24566576_24639661_2": {"section_id": 5805, "quality": 0.8732394366197183, "length": 62}, "so_24566576_24639661_1": {"section_id": 5804, "quality": 0.92, "length": 23}}, "n4659": {"so_24566576_24634262_2": {"section_id": 7534, "quality": 1.0, "length": 9}, "so_24566576_24639661_1": {"section_id": 7535, "quality": 0.8, "length": 20}, "so_24566576_24634262_1": {"section_id": 6901, "quality": 0.6363636363636364, "length": 14}, "so_24566576_24639661_2": {"section_id": 7536, "quality": 0.7464788732394366, "length": 53}, "so_24566576_24639661_0": {"section_id": 7534, "quality": 0.9130434782608695, "length": 21}}}});