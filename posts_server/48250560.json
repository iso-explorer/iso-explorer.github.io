post_cb({"bq_ids": {"n4140": {"so_48250560_48251573_3": {"length": 22, "quality": 0.9565217391304348, "section_id": 568}, "so_48250560_48251573_2": {"length": 7, "quality": 0.875, "section_id": 568}, "so_48250560_48251573_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 566}, "so_48250560_48251573_4": {"length": 29, "quality": 0.9666666666666667, "section_id": 639}, "so_48250560_48251573_0": {"length": 22, "quality": 1.0, "section_id": 583}}, "n3337": {"so_48250560_48251573_3": {"length": 22, "quality": 0.9565217391304348, "section_id": 559}, "so_48250560_48251573_2": {"length": 7, "quality": 0.875, "section_id": 559}, "so_48250560_48251573_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 557}, "so_48250560_48251573_4": {"length": 29, "quality": 0.9666666666666667, "section_id": 629}, "so_48250560_48251573_0": {"length": 22, "quality": 1.0, "section_id": 573}}, "n4659": {"so_48250560_48251573_3": {"length": 22, "quality": 0.9565217391304348, "section_id": 591}, "so_48250560_48251573_2": {"length": 7, "quality": 0.875, "section_id": 591}, "so_48250560_48251573_1": {"length": 35, "quality": 0.9459459459459459, "section_id": 589}, "so_48250560_48251573_4": {"length": 29, "quality": 0.9666666666666667, "section_id": 667}, "so_48250560_48251573_0": {"length": 22, "quality": 1.0, "section_id": 606}}}, "48251573": {"Id": "48251573", "PostTypeId": "2", "Body": "<p>This is an MSVC bug. The candidates aren't ambiguous. The work-around I guess would be to either provide a <em>named</em> conversion function to array, or just provide a user-defined <code>operator[]</code>. </p>\n<hr/>\n<p>When using operators, we have <a href=\"http://eel.is/c++draft/over.match.funcs#over.match.oper-2.sentence-1\" rel=\"nofollow noreferrer\">[over.match.oper]</a>:</p>\n<blockquote>\n<p id=\"so_48250560_48251573_0\">If either operand has a type that is a class or an enumeration, a user-defined operator function might be declared that implements this operator or a user-defined conversion can be necessary to convert the operand to a type that is appropriate for a built-in operator.</p>\n</blockquote>\n<p>In <code>f[0]</code>, <code>f</code> has class type, so we consider either the user-defined operator functions or user-defined conversions. There are none of the former, but two of the latter. Both are viable candidates:</p>\n<pre><code>f.operator type&amp;()[1];       // ok\nf.operator type const&amp;()[1]; // also ok\n</code></pre>\n<p>So we have to perform overload resolution to pick the best viable candidate. The different between the two is the implicit object parameter. As per <a href=\"http://eel.is/c++draft/over.match.funcs#2\" rel=\"nofollow noreferrer\">[over.match.funcs]</a>:</p>\n<blockquote>\n<p id=\"so_48250560_48251573_1\">So that argument and parameter lists are comparable within this heterogeneous set, a member function is considered to have an extra parameter, called the implicit object parameter, which represents the object for which the member function has been called. For the purposes of overload resolution, both static and non-static member functions have an implicit object parameter, but constructors do not. [ ... ]</p>\n<p id=\"so_48250560_48251573_2\">For non-static member functions, the type of the implicit object parameter is</p>\n<ul>\n<li>\u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</li>\n</ul>\n<p id=\"so_48250560_48251573_3\">[ ... ] where X is the class of which the function is a member and cv is the cv-qualification on the member function declaration. [ ... ] For conversion functions, the function is considered to be a member of the class of the implied object argument for the purpose of defining the type of the implicit object parameter.</p>\n</blockquote>\n<p>So overload resolution here behaves as if we had:</p>\n<pre><code>type&amp;       __op(foo&amp; );       // #1\ntype const&amp; __op(foo const&amp; ); // #2\n\n__op(f);\n</code></pre>\n<p>At which point, the <a href=\"http://eel.is/c++draft/over#ics.rank-3.2.6\" rel=\"nofollow noreferrer\">ICS ranking rules</a> tell us that:</p>\n<blockquote>\n<p id=\"so_48250560_48251573_4\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if [ ... ] S1 and S2 are reference bindings, and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers.</p>\n</blockquote>\n<p>The reference binding in <code>#1</code> is less cv-qualified than the reference binding in <code>#2</code>, so it's a better match. Since it's a better match, we do end up with a unique, best viable function, and the call is well-formed.</p>\n<hr/>\n<p>Moreover, having the conversion operators return pointers or references to arrays shouldn't matter here. The underlying rules are the same, but MSVC <a href=\"https://godbolt.org/g/vR7SjC\" rel=\"nofollow noreferrer\">allows the former</a>. And MSVC also allows this:</p>\n<pre><code>struct  foo\n{\n    using type = int[1];\n    operator type&amp;       ()       { return data; }\n    operator type const&amp; () const { return data; }\n    type data;\n};\n\nvoid call(int (&amp;)[1]); // #1\nvoid call(int const (&amp;)[1]); // #2\n\nint main()\n{\n    foo f;\n    call(f); // correctly calls #1\n}\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2018-01-14T16:36:54.903", "Score": "4", "CreationDate": "2018-01-14T16:17:05.117", "ParentId": "48250560", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2018-01-14T16:36:54.903"}, "48250560": {"ViewCount": "151", "Body": "<p>Recently, I tried using a conversion operator as an alternative to <code>operator []</code>.</p>\n<p>Like the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass foo\n{\npublic:\n    using type = int[1];\n\npublic:\n    operator type       &amp;()       { return data; }\n    operator type const &amp;() const { return data; }\n\nprivate:\n    type data;\n};\n\nint main()\n{\n    foo f;\n    f[0] = 1;                        // error happens here\n    std::cout &lt;&lt; f[0] &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>I found it <strong>works in G++</strong> but <strong>not in MSVC</strong>v141(2017).</p>\n<p>MSVC reports:</p>\n<pre><code>error C2593: 'operator [' is ambiguous\nnote: could be 'built-in C++ operator[(foo::type, int)'\nnote: or       'built-in C++ operator[(const foo::type, int)'\nnote: while trying to match the argument list '(foo, int)'\n</code></pre>\n<p>So is that a bug of MSVC or something else? And how to work around?</p>\n", "AcceptedAnswerId": "48251573", "Title": "MSVC error C2593 when overloading const and non-const conversion operator returning array type", "CreationDate": "2018-01-14T14:28:12.070", "LastActivityDate": "2018-01-14T16:36:54.903", "CommentCount": "4", "LastEditDate": "2018-01-14T16:30:12.233", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "48250560", "Score": "8", "OwnerUserId": "8051306", "Tags": "<c++><visual-c++><language-lawyer>", "AnswerCount": "1"}});