post_cb({"bq_ids": {"n4140": {"so_32920830_32920949_0": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_32920830_32920949_0": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_32920830_32920949_0": {"section_id": 3978, "quality": 1.0, "length": 5}}}, "32921082": {"ParentId": "32920830", "CommentCount": "0", "CreationDate": "2015-10-03T09:39:20.540", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "32921082", "Score": "2", "Body": "<p>Theoretically, if the world would only consist of simple programs, the compiler <em>could</em> optimize the sizeof of this struct to 1, because the sizeof of a struct is unspecified.</p>\n<p>But in our real world, we have separate compilation of shared libraries that the compiler when compiling your code has no clue about (for example you could <code>LoadLibrary</code> or <code>dlopen</code>) that also happen to define your <code>struct</code> and where the sizeof should better agree with that in your program.</p>\n<p>So actually a compiler better doesn't opimize the sizeof to 1 :)</p>\n", "LastActivityDate": "2015-10-03T09:39:20.540"}, "32920949": {"ParentId": "32920830", "CommentCount": "0", "CreationDate": "2015-10-03T09:23:31.760", "OwnerUserId": "2169853", "PostTypeId": "2", "Id": "32920949", "Score": "1", "Body": "<p>In 8.3.2.4, of the C++ standard, it is said</p>\n<blockquote>\n<p id=\"so_32920830_32920949_0\">It is unspecified whether or not a reference requires storage</p>\n</blockquote>\n<p>So, the standard leaves it open to the implementation how references should be implemented. This implies that the size of your struct can be non-zero.</p>\n<p>If the compiler would remove the references from the struct, you would not be able to link code compiled with different compiler settings. Imagine you compile one translation  unit with optimizations, the other one without and link them together and pass an object from one TU to the other. Which size should the code assume? A function in TU 1 allocates 12 bytes on the stack, while a function in TU 2 allocates some other space.</p>\n<p>The compiler can optimize your program and e.g. remove temporary objects, assignments etc. It may that you create an object of your struct somewhere in your source code and use it, but it will not be seen in the assembler code because it is not needed. What compilers also frequently do is remove indirections, e.g. by replacing references with direct access.</p>\n", "LastActivityDate": "2015-10-03T09:23:31.760"}, "32920830": {"CommentCount": "1", "ViewCount": "106", "CreationDate": "2015-10-03T09:10:02.230", "LastActivityDate": "2016-05-26T17:37:22.873", "Title": "Why C++ compiler isn't optimizing unused reference variables?", "AcceptedAnswerId": "32920908", "PostTypeId": "1", "Id": "32920830", "Score": "-2", "Body": "<p>Consider following program:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct Test\n{\n    int&amp; ref1;\n    int&amp; ref2;\n    int&amp; ref3;\n};\nint main()\n{\n    std::cout&lt;&lt;sizeof(Test)&lt;&lt;'\\n';\n}\n</code></pre>\n<p>I know that C++ compiler can optimize the reference variables entirely so that they won't take any space in memory at all. </p>\n<p>I tested a above demo program to see the output. \nBut when I compile &amp; run on g++ 4.8.1 it gives me output 12. \nIt looks like compiler isn't optimizing the reference variables. I was expecting size of the Test struct to be 1. \nI've also used <code>-Os</code> command line option but it still gives me output 12. I have also tried this program on MSVS 2010 \ncompiled with <code>/Ox</code> command line option but it looks like Microsoft compiler isn't performing any optimization at all.</p>\n<p>The three reference variables are unused &amp; they aren't associated with any other variable. Then why compilers aren't optimizing them?</p>\n", "Tags": "<c++><optimization><reference>", "OwnerUserId": "3777958", "AnswerCount": "3"}, "32920908": {"ParentId": "32920830", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-10-03T09:18:40.063", "Score": "2", "LastEditorUserId": "3777958", "LastEditDate": "2016-05-26T17:37:22.873", "Id": "32920908", "OwnerUserId": "2799037", "Body": "<p>The size of the struct stays the same, there is nothing to optimize. If you would like to create an array of <code>Test</code> it should allocate the right size for each <code>Test</code>. The compiler cannot know which will be used or not. That's why there is no such optimization.</p>\n<p>Unused variables would be for example a new <code>int&amp; int</code> inside your main function. If this is unused, the optimizer will optimize it away.</p>\n", "LastActivityDate": "2016-05-26T17:37:22.873"}});