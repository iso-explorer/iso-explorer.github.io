post_cb({"bq_ids": {"n4140": {"so_27206727_27207972_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}}, "n3337": {"so_27206727_27207972_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}}, "n4659": {"so_27206727_27207972_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}}}, "27206727": {"ViewCount": "338", "Body": "<p>Im new to C++ and I'm getting an error which I've never seen before.  I am attempting to search by a backtracking algorithm that uses a hash table (open hashing). </p>\n<p>Before I make a recursive call, I'm searching the hash table to see if the current position has been searched before (and has failed) and then inserting vector of ints \"B\" into the hash table when the recursive call returns false so that future search for the same position can be avoided.</p>\n<p>Heres my function in my program calling file to hash:</p>\n<pre><code>bool open_hash_solve (vector&lt;int&gt; B, vector&lt;Move&gt; &amp; MS, vector&lt;Move&gt; &amp; TMS, OpenHashTable&lt;vector&lt;int&gt;&gt; &amp; H) {\n\n  if (solved(B))\n    return true;\n\n  vector&lt;Move&gt; curr = currentMoves(B, TMS);\n\n  for (int m = 0; m &lt; curr.size(); m++) {\n\n    vector&lt;int&gt; moveMade = makeMove(B, curr[m]);\n\n    if (!H.contains(moveMade)){\n\n      if (open_hash_solve(moveMade, MS, TMS, H)){\n\n        MS.insert(MS.begin(), curr[m]);\n        return true;\n      }\n      else\n        H.insert(moveMade);\n    }\n  }\n  return false;\n}\n</code></pre>\n<p>Header file Separate Chaining from the textbook:</p>\n<pre><code>#ifndef SEPARATE_CHAINING_H\n#define SEPARATE_CHAINING_H\n\n#include &lt;vector&gt;\n#include &lt;list&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\nusing namespace std;\n\n\nint nextPrime( int n );\n\n// SeparateChaining Hash table class\n//\n// CONSTRUCTION: an approximate initial size or default of 101\n//\n// ******************PUBLIC OPERATIONS*********************\n// bool insert( x )       --&gt; Insert x\n// bool remove( x )       --&gt; Remove x\n// bool contains( x )     --&gt; Return true if x is present\n// void makeEmpty( )      --&gt; Remove all items\n\ntemplate &lt;typename HashedObj&gt;\nclass OpenHashTable\n{\n public:\n  explicit OpenHashTable( int size = 101 ) : currentSize{ 0 }\n  { theLists.resize( 101 ); }\n\n  bool contains( const HashedObj &amp; x ) const\n  {\n    auto &amp; whichList = theLists[ myhash( x ) ];\n    return find( begin( whichList ), end( whichList ), x ) != end( whichList );\n  }\n\n  void makeEmpty( )\n  {\n    for( auto &amp; thisList : theLists )\n      thisList.clear( );\n  }\n\n  bool insert( const HashedObj &amp; x )\n  {\n    auto &amp; whichList = theLists[ myhash( x ) ];\n    if( find( begin( whichList ), end( whichList ), x ) != end( whichList) )\n      return false;\n    whichList.push_back( x );\n\n    // Rehash; see Section 5.5\n    if( ++currentSize &gt; theLists.size( ) )\n      rehash( );\n\n    return true;\n  } \n\n  bool insert( HashedObj &amp;&amp; x )\n  {\n    auto &amp; whichList = theLists[ myhash( x ) ];\n    if( find( begin( whichList ), end( whichList ), x ) != end( whichList ) )\n      return false;\n    whichList.push_back( std::move( x ) );\n\n    // Rehash; see Section 5.5\n    if( ++currentSize &gt; theLists.size( ) )\n      rehash( );\n\n    return true;\n  }\n\n  bool remove( const HashedObj &amp; x )\n  {\n    auto &amp; whichList = theLists[ myhash( x ) ];\n    auto itr = find( begin( whichList ), end( whichList ), x );\n\n    if( itr == end( whichList ) )\n      return false;\n\n    whichList.erase( itr );\n    --currentSize;\n    return true;\n  }\n\n private:\n  vector&lt;list&lt;HashedObj&gt;&gt; theLists;   // The array of Lists\n  int  currentSize;\n\n  void rehash( )\n  {\n    vector&lt;list&lt;HashedObj&gt;&gt; oldLists = theLists;\n\n    // Create new double-sized, empty table\n    theLists.resize( nextPrime( 2 * theLists.size( ) ) );\n    for( auto &amp; thisList : theLists )\n      thisList.clear( );\n\n    theLists.resize( nextPrime( 2 * theLists.size( ) ) );\n    for( auto &amp; thisList : theLists )\n      thisList.clear( );\n\n    // Copy table over\n    currentSize = 0;\n    for( auto &amp; thisList : oldLists )\n      for( auto &amp; x : thisList )\n        insert( std::move( x ) );\n  }\n\n  size_t myhash( const HashedObj &amp; x ) const\n  {\n    static hash&lt;HashedObj&gt; hf;  ***** ERROR HERE *****\n    return hf( x ) % theLists.size( );\n  }\n};\n\n#endif\n</code></pre>\n<p>My Error:</p>\n<pre><code>SeparateChaining.h: In instantiation of \u2018size_t OpenHashTable&lt;HashedObj&gt;::myhash(const HashedObj&amp;) const [with HashedObj = std::vector&lt;int&gt;; size_t = long unsigned int]\u2019:\n\nSeparateChaining.h:33:44:   required from \u2018bool OpenHashTable&lt;HashedObj&gt;::contains(const HashedObj&amp;) const [with HashedObj = std::vector&lt;int&gt;]\u2019\n\nmovetest1.cpp:107:29:   required from here\n\nSeparateChaining.h:106:34: error: \u2018std::hash&lt;std::vector&lt;int&gt; &gt; hf\u2019 has incomplete type\n static hash&lt;HashedObj&gt; hf;\n                        ^\n</code></pre>\n<p>How do I fix this??\nLet me know if my description doesn't make sense or needs clarity. Thanks in advance! </p>\n", "Title": "\"Incomplete Type\" when open hashing c++", "CreationDate": "2014-11-29T20:25:10.280", "LastActivityDate": "2014-11-30T01:31:35.303", "CommentCount": "5", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-11-29T21:40:44.337", "LastEditorUserId": "4181864", "Id": "27206727", "Score": "0", "OwnerUserId": "4181864", "Tags": "<c++11><recursion><hash><hashtable><backtracking>", "AnswerCount": "1"}, "27207972": {"Id": "27207972", "PostTypeId": "2", "Body": "<p>The reason is that <code>std::hash</code> is not defined for <code>std::vector</code> except <code>std::vector&lt;bool&gt;</code>. It's defined only for <a href=\"http://en.cppreference.com/w/cpp/utility/hash\" rel=\"nofollow\">basic types and select library types</a>. You have to implement your own hashing algorithm.</p>\n<p>Regarding your last comment, <code>hash( x )</code> is invalid code since <code>std::hash</code> is a class template, not a function template.</p>\n<p>You also can't write your own specialization for <code>std::hash&lt;std::vector&lt;int&gt;&gt;</code> since <code>std::vector&lt;int&gt;</code> is not a user-defined type.</p>\n<p>Appropriate solution would be in the style of <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map\" rel=\"nofollow\">C++ standard library</a> - <code>OpenHashTable</code> should allow its user to specify hashing algorithm:</p>\n<pre><code>template&lt;typename HashedObj, typename Hash = std::hash&lt;HashedObj&gt;&gt;\nclass OpenHashTable {\n    // ...\n    size_t myhash(const HashedObj&amp; x) const {\n        static Hash hf;\n        return hf(x) % theLists.size();\n    }\n};\n</code></pre>\n<p>So you can use it as follows:</p>\n<pre><code>struct my_vector_int_hash {\n    size_t operator()(const std::vector&lt;int&gt;&amp; v) const {\n        // your code here\n    }\n};\n\nOpenHashTable&lt;std::vector&lt;int&gt;, my_vector_int_hash&gt; hashtable;\n</code></pre>\n<hr>\n<p>Update: as long as discussion arose about whether you can specialize <code>std::hash&lt;std::vector&lt;int&gt;&gt;</code>, here is why you are not allowed to do it.</p>\n<p><code>[namespace.std]/1</code> says:</p>\n<blockquote>\n<p id=\"so_27206727_27207972_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace std unless otherwise specified. A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p><code>std::vector&lt;int&gt;</code> is not a user-defined type, nor it depends on any user-defined type, so such specialization is illegal and leads to undefined behavior.</p>\n</hr>", "LastEditorUserId": "3959454", "LastActivityDate": "2014-11-30T01:31:35.303", "Score": "0", "CreationDate": "2014-11-29T22:45:23.867", "ParentId": "27206727", "CommentCount": "11", "OwnerUserId": "3959454", "LastEditDate": "2014-11-30T01:31:35.303"}});