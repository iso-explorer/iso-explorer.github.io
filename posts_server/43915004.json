post_cb({"43915004": {"ViewCount": "166", "Body": "<p>Dynamic analysis discovered curious memory leak in our code-base. The code in question looks like:</p>\n<pre><code>Something *p = new Something(getArgument());\n</code></pre>\n<p>where the function <code>getArgument()</code> sometimes throws. And when it throws, the freshly allocated object is leaked. This is compiled by Visual Studio 2015 (MSC++ 19.0).</p>\n<p>Now when I checked the specification (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"noreferrer\">C++14 final draft</a>), the \u00a75.3.4/8 curiously says:</p>\n<blockquote>\n<p id=\"so_43915004_43915004_0\">A <em>new-expression</em> <strong>may</strong> obtain storage for the object by calling an <em>allocation function</em> (3.7.4.1). If the\n  <em>new-expression</em> terminates by throwing an exception, it <strong>may</strong> release storage by calling a deallocation function\n  (3.7.4.2). If the allocated type is a non-array type, the allocation function\u2019s name is <code>operator new</code> and\n  the deallocation function\u2019s name is <code>operator delete</code>. If the allocated type is an array type, the allocation\n  function\u2019s name is <code>operator new[]</code> and the deallocation function\u2019s name is <code>operator delete[]</code>.</p>\n</blockquote>\n<p>The use of \u2018may\u2019 (highlighted above by me) here implies the compiler is free not to do it.</p>\n<p>So is this:</p>\n<ol>\n<li>stated as required somewhere else in the specification, making it a bug in Visual C++ compiler (that might occur only under some condition; didn't check how general it is),</li>\n<li>a bug in the specification, or</li>\n<li>written this way for some reason?</li>\n</ol>\n<p>Note: the code does correctly delete the object when the expression completes. There is no bug in that. The problem is strictly in what happens when the new-expression throws.</p>\n", "AcceptedAnswerId": "43915421", "Title": "Deallocation of memory when argument subexpression of new expression throws", "CreationDate": "2017-05-11T12:09:17.437", "Id": "43915004", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-05-11T13:12:31.000", "Score": "9", "OwnerUserId": "201725", "Tags": "<c++><visual-c++><memory-leaks><exception-handling><language-lawyer>", "AnswerCount": "2"}, "43915415": {"Id": "43915415", "PostTypeId": "2", "Body": "<p>Check further - specifically paragraph 20 :</p>\n<blockquote>\n<p id=\"so_43915004_43915415_0\">If any part of the object initialization described above terminates by throwing an exception and a suitable deallocation function can be found, the deallocation function is called to free the memory in which the object was being constructed, after which the exception continues to propagate in the context of the <em>new-expression</em>. If no unambiguous matching deallocation function can be found, propagating the exception does not cause the object\u2019s memory to be freed. <em>[ Note:</em> This is appropriate when the called allocation function does not allocate memory; otherwise, it is likely to result in a memory leak. <em>\u2014 end note ]</em></p>\n</blockquote>\n", "LastActivityDate": "2017-05-11T12:27:38.633", "CommentCount": "0", "CreationDate": "2017-05-11T12:27:38.633", "ParentId": "43915004", "Score": "3", "OwnerUserId": "822669"}, "bq_ids": {"n4140": {"so_43915004_43915415_0": {"length": 54, "quality": 0.9310344827586207, "section_id": 6101}, "so_43915004_43915421_1": {"length": 54, "quality": 0.9152542372881356, "section_id": 6101}, "so_43915004_43915421_0": {"length": 18, "quality": 0.9, "section_id": 6089}, "so_43915004_43915421_2": {"length": 30, "quality": 0.9375, "section_id": 6099}, "so_43915004_43915421_3": {"length": 15, "quality": 0.8333333333333334, "section_id": 6099}, "so_43915004_43915004_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 6089}}, "n3337": {"so_43915004_43915415_0": {"length": 54, "quality": 0.9310344827586207, "section_id": 5867}, "so_43915004_43915421_1": {"length": 54, "quality": 0.9152542372881356, "section_id": 5867}, "so_43915004_43915421_0": {"length": 16, "quality": 0.8, "section_id": 5857}, "so_43915004_43915421_2": {"length": 30, "quality": 0.9375, "section_id": 5865}, "so_43915004_43915421_3": {"length": 15, "quality": 0.8333333333333334, "section_id": 5865}, "so_43915004_43915004_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 5857}}, "n4659": {"so_43915004_43915421_0": {"length": 18, "quality": 0.9, "section_id": 7585}, "so_43915004_43915415_0": {"length": 54, "quality": 0.9310344827586207, "section_id": 7598}, "so_43915004_43915421_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 7596}, "so_43915004_43915421_1": {"length": 54, "quality": 0.9152542372881356, "section_id": 7598}, "so_43915004_43915004_0": {"length": 46, "quality": 0.9583333333333334, "section_id": 7585}}}, "43915421": {"Id": "43915421", "PostTypeId": "2", "Body": "<p>From the latest draft, the relevant quote is on:</p>\n<blockquote>\n<p id=\"so_43915004_43915421_0\"><a href=\"http://eel.is/c++draft/expr.new#8\" rel=\"nofollow noreferrer\">expr.new/8</a>: A <em>new-expression</em> <strong>may</strong>\n  obtain storage for the object by calling an allocation function\n  ([basic.stc.dynamic.allocation]). If the new-expression terminates by\n  throwing an exception, it may release storage by calling a\n  deallocation function. ....</p>\n</blockquote>\n<p>The use of \"may\" is in precedence of a proceeding section:</p>\n<blockquote>\n<p id=\"so_43915004_43915421_1\"><a href=\"http://eel.is/c++draft/expr.new#21\" rel=\"nofollow noreferrer\">expr.new/21</a> If any part of the\n  object initialization described above terminates by throwing an\n  exception and a suitable deallocation function can be found, the\n  deallocation function is called to free the memory in which the object\n  was being constructed, after which the exception continues to\n  propagate in the context of the new-expression. If no unambiguous\n  matching deallocation function can be found, propagating the exception\n  does not cause the object's memory to be freed. <em>[\u2009Note: This is\n  appropriate when the called allocation function does not allocate\n  memory; otherwise, it is likely to result in a memory leak. \u2014\u2009end note\n  \u2009]</em></p>\n</blockquote>\n<hr>\n<p>But you got hit by the indeterminate sequencing of the new expression in C++14 and older; Which says:</p>\n<blockquote>\n<p id=\"so_43915004_43915421_2\">$5.3.4/18 The invocation of the allocation function is indeterminately sequenced\n  with respect to the evaluations of expressions in the new-initializer.\n  Initialization of the allocated object is sequenced before the value\n  computation of the new-expression. It is unspecified whether\n  expressions in the new-initializer are evaluated if the allocation\n  function returns the null pointer or exits using an exception.</p>\n</blockquote>\n<p><sup>taken from C++14 draft</sup></p>\n<p>As per the adoption of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf\" rel=\"nofollow noreferrer\">this paper</a>. we now have a defined sequence in C++17:</p>\n<blockquote>\n<p id=\"so_43915004_43915421_3\"><a href=\"http://eel.is/c++draft/expr.new#19\" rel=\"nofollow noreferrer\">expr.new/19</a>\n  The invocation of the allocation function is sequenced before the\n  evaluations of expressions in the new-initializer. Initialization of\n  the allocated object is sequenced before the value computation of the\n  new-expression.</p>\n</blockquote>\n<hr>\n<hr>\n</hr></hr></hr>", "LastEditorUserId": "1621391", "LastActivityDate": "2017-05-11T13:12:31.000", "Score": "4", "CreationDate": "2017-05-11T12:27:55.593", "ParentId": "43915004", "CommentCount": "2", "OwnerUserId": "1621391", "LastEditDate": "2017-05-11T13:12:31.000"}});