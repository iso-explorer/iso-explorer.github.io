post_cb({"bq_ids": {"n4140": {"so_13493353_13493394_0": {"length": 13, "quality": 0.5416666666666666, "section_id": 6186}}, "n3337": {"so_13493353_13493394_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5947}, "so_13493353_13493353_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 36}}}, "13493394": {"LastActivityDate": "2012-11-21T12:59:11.653", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_13493353_13493394_0\"><code>[C++11: 5.19/3]:</code> A <em>literal constant expression</em> is a prvalue core constant expression of literal type, but not pointer type. An <em>integral constant expression</em> is a literal constant expression of integral or unscoped enumeration type. [..]</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_13493353_13493394_1\"><code>[C++11: 3.9/10]:</code> <strong>A type is a <em>literal type</em> if it is</strong>:</p>\n<ul>\n<li><strong>a scalar type</strong>; or</li>\n<li>a reference type; or</li>\n<li>a class type (Clause 9) that has all of the following properties: [..]</li>\n<li>an array of literal type.</li>\n</ul>\n</blockquote>\n<p>At this point, I can't find a reason for that code to be non-compliant, so I suspect a GCC bug.</p>\n<p>However it may be a deliberate bug given that the passage you quoted out of 4.10 is proposed to be changed (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\" rel=\"nofollow\">active issue #903</a>) so that this would in fact be non-compliant code.</p>\n<hr>\n<blockquote>\n<p id=\"so_13493353_13493394_2\">The compilation succeeds if I <code>s/constexpr/const/</code> and compile with <code>-ansi</code> rather than <code>-std=c++11</code>.</p>\n</blockquote>\n<p>The definition of <em>integral constant expression</em> explicitly allowed this case in C++03:</p>\n<blockquote>\n<p id=\"so_13493353_13493394_3\"><code>[C++03: 5.19/1]:</code> [..] An <em>integral constant-expression</em> can involve only literals (2.13), enumerators, <strong>const variables</strong> or static data members of integral or enumeration types initialized with constant expressions (8.5), non-type template parameters of integral or enumeration types, and <code>sizeof</code> expressions. [..]</p>\n</blockquote>\n</hr>", "CreationDate": "2012-11-21T12:33:57.737", "LastEditDate": "2012-11-21T12:59:11.653", "ParentId": "13493353", "Id": "13493394", "LastEditorUserId": "560648", "PostTypeId": "2", "Score": "8", "OwnerUserId": "560648"}, "13493353": {"CreationDate": "2012-11-21T12:31:32.687", "ViewCount": "451", "FavoriteCount": "1", "Id": "13493353", "AcceptedAnswerId": "13493394", "Score": "8", "Title": "Is this constexpr integer not a null pointer constant?", "CommentCount": "4", "Body": "<p>Consider the following C++11 program, and its result in GCC 4.7.2:</p>\n<pre><code>int main()\n{\n   constexpr int i = 0;\n   int* p = i;\n}\n\n// g++ -g -ggdb -Wall -Wextra -pedantic -std=c++11 t.cpp\n// t.cpp: In function 'int main()':\n// t.cpp:4:13: error: invalid conversion from 'int' to 'int*' [-fpermissive]\n// t.cpp:4:9: warning: unused variable 'p' [-Wunused-variable]\n</code></pre>\n<p>According to the standard:</p>\n<blockquote>\n<p id=\"so_13493353_13493353_0\"><code>[C++11: 4.10/1]:</code> A <em>null pointer constant</em> is an integral constant expression (5.19) prvalue of integer type that evaluates to zero [..]</p>\n</blockquote>\n<p>5.19 is a mess and I've failed to parse it fully, but wouldn't we expect <code>i</code> to satisfy this criterion and act as a <em>null pointer constant</em>, consequently requiring no explicit conversion to <code>int*</code> for the initialisation of <code>p</code>?</p>\n<p>The compilation succeeds if I <code>s/constexpr/const/</code> and compile with <code>-ansi</code> rather than <code>-std=c++11</code>.</p>\n", "Tags": "<c++><c++11><constexpr>", "LastActivityDate": "2012-11-21T12:59:11.653", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "560648"}});