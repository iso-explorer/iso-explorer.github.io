post_cb({"18858875": {"ParentId": "11488490", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Unlike suggested by the previous answer, gcc 4.7 was <em>wrong</em> to reject this code, a mistake which has been <a href=\"http://ideone.com/MVTJ0G\">corrected in gcc 4.8</a>.</p>\n<p>The full standard-conforming behavior for <code>vector&lt;T&gt;::push_back</code> is:</p>\n<ul>\n<li>If there is only a copy constructor and no move constructor, <code>push_back</code> will copy its argument and will give the strong exception safety guarantee. That is, if the push_back fails due to an exception triggered by reallocation of the vector storage, the original vector will remain unchanged and usable. This is the known behavior from C++98 and it is also the reason for the mess that follows.</li>\n<li>If there is a <code>noexcept</code> move constructor for <code>T</code>, <code>push_back</code> will <em>move</em> from its argument and will give the strong exception guarantee. No surprises here.</li>\n<li>If there is a move constructor that is <em>not</em> <code>noexcept</code> and there is also a copy constructor, <code>push_back</code> will <em>copy</em> the object and give the strong exception safety guarantee. This is unexpected at first glance. While <code>push_back</code> could move here, that would only be possible at the expense of sacrificing the strong exception guarantee. If you ported code from C++98 to C++11 and your type is movable, that would silently change the behavior of existing <code>push_back</code> calls. To avoid this pitfall and maintain compatibility with C++98 code, C++11 falls back to the slower copy. This is what the gcc 4.7 behavior is all about. But there is more...</li>\n<li>If there is a move constructor that is not <code>noexcept</code> but no copy constructor at all - that is, the element can only be moved and not copied - <code>push_back</code> will perform the move but will <em>not</em> give the strong exception safety guarantee. This is where gcc 4.7 went wrong. In C++98 there are no <code>push_back</code>s for types that are movable but not copyable. So sacrificing the strong exception safety here does not break existing code. This is why it is allowed and the original code is in fact legal C++11.</li>\n</ul>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\">cppreference.com</a> on <code>push_back</code>:</p>\n<blockquote>\n<p id=\"so_11488490_18858875_0\">If an exception is thrown, this function has no effect (strong\n  exception guarantee).</p>\n<p id=\"so_11488490_18858875_1\">If T's move constructor is not noexcept and the\n  copy constructor is not accessible, vector will use the throwing move\n  constructor. If it throws, the guarantee is waived and the effects are\n  unspecified.</p>\n</blockquote>\n<p>Or a little more convoluted \u00a723.3.6.5 from the C++11 Standard (emphasis added by me):</p>\n<blockquote>\n<p id=\"so_11488490_18858875_2\">Causes reallocation if the new size is greater than the old capacity.\n  If no reallocation happens, all the iterators and references before\n  the insertion point remain valid. If an exception is thrown other than\n  by the copy constructor, move constructor, assignment operator, or\n  move assignment operator of T or by any InputIterator operation there\n  are no effects. <strong>If an exception is thrown by the move constructor of a\n  non-CopyInsertable T, the effects are unspecified.</strong></p>\n</blockquote>\n<p>Or if you don't like reading, <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/An-Effective-Cpp11-14-Sampler\">Scott Meyer's Going Native 2013 talk</a> (starting at 0:30:20 with the interesting part at about 0:42:00).</p>\n", "OwnerUserId": "577603", "LastEditorUserId": "577603", "LastEditDate": "2013-09-17T20:26:28.270", "Id": "18858875", "Score": "8", "CreationDate": "2013-09-17T20:00:34.737", "LastActivityDate": "2013-09-17T20:26:28.270"}, "11488899": {"ParentId": "11488490", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Try adding \"noexcept\" to the declaration of the move constructor.</p>\n<p>I can't quote the standard, but recent versions of gcc appear to require either that the copy constructor be public or that the move constructor be declared \"noexcept\".  Regardless of the \"noexcept\" qualifier, if you make the copy constructor public, it will behave as you expect at run-time.</p>\n", "OwnerUserId": "1526166", "LastEditorUserId": "1526166", "LastEditDate": "2012-07-15T02:34:59.933", "Id": "11488899", "Score": "16", "CreationDate": "2012-07-15T02:25:08.833", "LastActivityDate": "2012-07-15T02:34:59.933"}, "bq_ids": {"n4140": {"so_11488490_18858875_2": {"section_id": 986, "quality": 1.0, "length": 42}, "so_11488490_18858875_0": {"section_id": 712, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_11488490_18858875_2": {"section_id": 971, "quality": 1.0, "length": 42}, "so_11488490_18858875_0": {"section_id": 701, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_11488490_18858875_2": {"section_id": 1049, "quality": 1.0, "length": 42}, "so_11488490_18858875_0": {"section_id": 5058, "quality": 0.7142857142857143, "length": 5}}}, "11488490": {"CommentCount": "5", "AcceptedAnswerId": "11488899", "PostTypeId": "1", "LastEditorUserId": "2556117", "CreationDate": "2012-07-15T00:36:01.980", "LastActivityDate": "2013-09-17T20:26:28.270", "LastEditDate": "2012-07-15T13:00:08.573", "ViewCount": "4457", "FavoriteCount": "4", "Title": "vector::push_back insists on using copy constructor though a move constructor is provided", "Id": "11488490", "Score": "12", "Body": "<p>I was receiving a strange error from gcc and cannot figure out why. I made the following example code to make the problem more clear. Basically, there is a class defined, for which I make its copy constructor and copy assignment operator private, to prevent calling them accidentally.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cstdio&gt;\nusing std::vector;\n\nclass branch \n{\npublic:\n  int th;\n\nprivate:\n  branch( const branch&amp; other );\n  const branch&amp; operator=( const branch&amp; other );\n\npublic:\n\n  branch() : th(0) {}\n\n  branch( branch&amp;&amp; other )\n  {\n    printf( \"called! other.th=%d\\n\", other.th );\n  }\n\n  const branch&amp; operator=( branch&amp;&amp; other )\n  {\n    printf( \"called! other.th=%d\\n\", other.th );\n    return (*this);\n  }\n\n};\n\n\n\nint main()\n{\n  vector&lt;branch&gt; v;\n  branch a;\n  v.push_back( std::move(a) );\n\n  return 0;\n}\n</code></pre>\n<p>I expect this code to compile, but it fails with gcc. Actually gcc complains that \n\"branch::branch(const branch&amp;) is private\", which as I understand shouldn't be called.</p>\n<p>The assignment operator works, since if I replace the body of main() with</p>\n<pre><code>branch a;\nbranch b;\nb = a;\n</code></pre>\n<p>It will compile and run as expected.</p>\n<p>Is this a correct behavior of gcc? If so, what's wrong with the above code?\nAny suggestion is helpful to me. Thank you!</p>\n", "Tags": "<c++><gcc><c++11><move-constructor>", "OwnerUserId": "414514", "AnswerCount": "2"}});