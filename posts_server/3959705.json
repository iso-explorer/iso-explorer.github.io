post_cb({"3959705": {"ViewCount": "7947", "Body": "<blockquote>\n<p id=\"so_3959705_3959705_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/1641957/is-array-name-a-pointer-in-c\">Is array name a pointer in C?</a> </br></p>\n</blockquote>\n<p>Are arrays and pointers implemented differently? I have come across this question because , in both the cases we access elements from the starting address of an element.So , there should be close relation between them . Please explain the exact relation between them . Thanks.</p>\n", "AcceptedAnswerId": "3960723", "Title": "Arrays are Pointers?", "CreationDate": "2010-10-18T13:36:54.267", "Id": "3959705", "CommentCount": "2", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:22.570", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-07T01:19:37.060", "ClosedDate": "2010-10-19T01:21:00.553", "Score": "13", "OwnerUserId": "476854", "Tags": "<c++><c><arrays><pointers>", "AnswerCount": "7"}, "3960723": {"Id": "3960723", "PostTypeId": "2", "Body": "<p>Let's get the important stuff out of the way first: <strong>arrays are not pointers</strong>.  Array types and pointer types are <em>completely different things</em> and are treated differently by the compiler.  </p>\n<p>Where the confusion arises is from how C treats array <em>expressions</em>. <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">N1570</a>:</p>\n<blockquote id=\"so_3959705_3960723_0\">\n<h3>6.3.2.1 Lvalues, arrays, and function designators</h3>\n...<br>\n3 Except when it is the operand of the <code>sizeof</code> operator, the <code>_Alignof</code> operator, or the\nunary <code>&amp;</code> operator, or is a string literal used to initialize an array, an expression that has\ntype \u2018\u2018array of <em>type</em>\u2019\u2019 is converted to an expression with type \u2018\u2018pointer to <em>type</em>\u2019\u2019 that points\nto the initial element of the array object and is not an lvalue. If the array object has\nregister storage class, the behavior is unde\ufb01ned.\n</br></blockquote>\n<p>Let's look at the following declarations:</p>\n<pre><code>int arr[10] = {0,1,2,3,4,5,6,7,8,9};\nint *parr = arr;\n</code></pre>\n<p><code>arr</code> is a 10-element array of <code>int</code>; it refers to a contiguous block of memory large enough to store 10 <code>int</code> values.  The <em>expression</em> <code>arr</code> in the second declaration is of array type, but since it is not the operand of <code>&amp;</code> or <code>sizeof</code> and it isn't a string literal, the type of the <em>expression</em> becomes \"pointer to <code>int</code>\", and the value is the address of the first element, or <code>&amp;arr[0]</code>.  </p>\n<p><code>parr</code> is a pointer to int; it refers to a block of memory large enough to hold the address of a single <code>int</code> object.  It is initialized to point to the first element in <code>arr</code> as explained above.  </p>\n<p>Here's a hypothetical memory map showing the relationship between the two (assuming 16-bit ints and 32-bit addresses):  </p>\n<pre>\nObject           Address         0x00  0x01  0x02  0x03\n------           -------         ----------------------\n   arr           0x10008000      0x00  0x00  0x00  0x01\n                 0x10008004      0x00  0x02  0x00  0x03\n                 0x10008008      0x00  0x04  0x00  0x05\n                 0x1000800c      0x00  0x06  0x00  0x07\n                 0x10008010      0x00  0x08  0x00  0x09\n  parr           0x10008014      0x10  0x00  0x80  0x00\n</pre>\n<p>The types matter for things like <code>sizeof</code> and <code>&amp;</code>; <code>sizeof arr == 10 * sizeof (int)</code>, which in this case is 20, whereas <code>sizeof parr == sizeof (int *)</code>, which in this case is 4.  Similarly, the type of the expression <code>&amp;arr</code> is <code>int (*)[10]</code>, or a pointer to a 10-element array of <code>int</code>, whereas the type of <code>&amp;parr</code> is <code>int **</code>, or pointer to pointer to <code>int</code>.  </p>\n<p>Note that the expressions <code>arr</code> and <code>&amp;arr</code> will yield the same <em>value</em> (the address of the first element in <code>arr</code>), but the types of the expressions are different (<code>int *</code> and <code>int (*)[10]</code>, respectively).  This makes a difference when using pointer arithmetic.  For example, given:</p>\n<pre><code>int arr[10] = {0,1,2,3,4,5,6,7,8,9};\nint *p = arr;\nint (*ap)[10] = &amp;arr;\n\nprintf(\"before: arr = %p, p = %p, ap = %p\\n\", (void *) arr, (void *) p, (void *) ap);\np++;\nap++;\nprintf(\"after: arr = %p, p = %p, ap = %p\\n\", (void *) arr, (void *) p, (void *) ap);\n</code></pre>\n<p>the \"before\" line should print the same values for all three expressions (in our hypothetical map, <code>0x10008000</code>).  The \"after\" line should show three different values: <code>0x10008000</code>,  <code>0x10008002</code> (base plus <code>sizeof (int)</code>), and <code>0x10008014</code> (base plus <code>sizeof (int [10])</code>).  </p>\n<p>Now let's go back to the second paragraph above: array <em>expressions</em> are converted to pointer types in most circumstances.  Let's look at the subscript expression <code>arr[i]</code>.  Since the expression <code>arr</code> is not appearing as an operand of either <code>sizeof</code> or <code>&amp;</code>, and since it is not a string literal being used to initialize another array, its type is converted from \"10-element array of <code>int</code>\" to \"pointer to <code>int</code>\", and the subscript operation is being applied to this <em>pointer</em> value.  Indeed, when you look at the C language definition, you see the following language:</p>\n<blockquote id=\"so_3959705_3960723_1\">\n<b>6.5.2.1 Array subscripting</b><br>\n...<br>\n2  A postfix expression followed by an expression in square brackets <b>[]</b> is a subscripted designation of an element of an array object. The definition of the subscript operator <b>[]</b> is that <b>E1[E2]</b> is identical to <b>(*((E1)+(E2)))</b>. Because of the conversion rules that apply to the binary + operator, if <b>E1</b> is an array object (equivalently, a pointer to the initial element of an array object) and <b>E2</b> is an integer, <b>E1[E2]</b> designates the <b>E2</b>-th element of <b>E1</b> (counting from zero).\n</br></br></blockquote>\n<p>In practical terms, this means you can apply the subscript operator to a pointer object <em>as though</em> it were an array.  This is why code like</p>\n<pre><code>int foo(int *p, size_t size)\n{\n  int sum = 0;\n  int i;\n  for (i = 0; i &lt; size; i++)\n  {\n    sum += p[i];\n  }\n  return sum;\n}\n\nint main(void)\n{\n  int arr[10] = {0,1,2,3,4,5,6,7,8,9};\n  int result = foo(arr, sizeof arr / sizeof arr[0]);\n  ...\n}\n</code></pre>\n<p>works the way it does.  <code>main</code> is dealing with an array of <code>int</code>, whereas <code>foo</code> is dealing with a pointer to <code>int</code>, yet both are able to use the subscript operator <em>as though</em> they were both dealing with an array type.  </p>\n<p>It also means array subscripting is <em>commutative</em>: assuming <code>a</code> is an array expression and <code>i</code> is an integer expression, <code>a[i]</code> and <code>i[a]</code> are both valid expressions, and both will yield the same value.  </p>\n", "LastEditorUserId": "134554", "LastActivityDate": "2013-02-22T22:28:09.237", "Score": "45", "CreationDate": "2010-10-18T15:34:41.250", "ParentId": "3959705", "CommentCount": "7", "OwnerUserId": "134554", "LastEditDate": "2013-02-22T22:28:09.237"}, "3961105": {"Id": "3961105", "PostTypeId": "2", "Body": "<p>In C++ array type has a \"size attribute\", so for</p>\n<pre><code>T a[10];\nT b[20];\n</code></pre>\n<p><em>a</em> and <em>b</em> has different types.</p>\n<p>This allows to use code like this</p>\n<pre><code>template&lt;typename T, size_t N&gt;\nvoid foo(T (&amp;a)[N])\n{\n   ...\n}\n</code></pre>\n", "LastActivityDate": "2010-10-18T16:18:45.563", "CommentCount": "0", "CreationDate": "2010-10-18T16:18:45.563", "ParentId": "3959705", "Score": "1", "OwnerUserId": "343443"}, "3960861": {"Id": "3960861", "PostTypeId": "2", "Body": "<p>The biggest point of confusion between arrays and pointers comes from K&amp;R's decision to make function parameters which are declared as being array type behave as though they were declared as pointers.  The declarations<pre>void foo(int a[]);</pre>and<pre>void foo(int *a);</pre>are equivalent, as is (so far as I can tell)<pre>void foo(int a[5]);</pre>though I'm not positive a compiler would be required to accept a reference to a[6] within the latter function.  In other contexts, an array declaration allocates space for the indicated number of elements.  Note that given:</p>\n<pre>\ntypedef int foo[1];\n</pre>\n<p>any declaration of a type foo will allocate space for one element, but any attempt to pass foo as a function parameter will instead pass the address.  Something of a useful trick I learned in studying a va_list implementation.</p>\n", "LastActivityDate": "2010-10-18T15:52:10.133", "CommentCount": "3", "CreationDate": "2010-10-18T15:52:10.133", "ParentId": "3959705", "Score": "0", "OwnerUserId": "363751"}, "bq_ids": {"n4140": {"so_3959705_3959761_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 11}}, "n3337": {"so_3959705_3959761_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 8}}, "n4659": {"so_3959705_3959761_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 12}}}, "3959723": {"Id": "3959723", "PostTypeId": "2", "Body": "<p>Don't know about C++. For C, the <a href=\"http://c-faq.com/aryptr/index.html\" rel=\"nofollow noreferrer\">c-faq</a> answers much better than I ever could.</p>\n<p>Small snippet from c-faq:</p>\n<blockquote>\n<p id=\"so_3959705_3959723_0\">6.3 So what is meant by the ``equivalence of pointers and arrays'' in C?</p>\n<p id=\"so_3959705_3959723_1\">[...]</p>\n<blockquote>\n<p id=\"so_3959705_3959723_5\">Specifically, the cornerstone of the equivalence is this key definition:</p>\n<blockquote>\n<p id=\"so_3959705_3959723_8\">A reference to an object of type array-of-T which appears in an\n      expression decays (with three exceptions) into a pointer to its\n      first element; the type of the resultant pointer is pointer-to-T.</p>\n</blockquote>\n<p id=\"so_3959705_3959723_7\">[...]</p>\n</blockquote>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-06-07T01:19:37.060", "Score": "19", "CreationDate": "2010-10-18T13:39:26.077", "ParentId": "3959705", "CommentCount": "7", "OwnerUserId": "25324", "LastEditDate": "2015-06-07T01:19:37.060"}, "3959761": {"Id": "3959761", "PostTypeId": "2", "Body": "<p>In C++ according to the C++ Standard 4.2:</p>\n<blockquote>\n<p id=\"so_3959705_3959761_0\">An lvalue or rvalue of type \u201carray of N\n  T\u201d or \u201carray of unknown bound of T\u201d\n  can be converted to an rvalue of type\n  \u201cpointer to T.\u201d The result is a\n  pointer to the first element of the\n  array.</p>\n</blockquote>\n", "LastActivityDate": "2010-10-18T13:42:10.953", "CommentCount": "9", "CreationDate": "2010-10-18T13:42:10.953", "ParentId": "3959705", "Score": "6", "OwnerUserId": "123111"}, "3960000": {"Id": "3960000", "PostTypeId": "2", "Body": "<p>In C++ (and in C too I think), an array is not a pointer and that can be proven in the following way.</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n   char arr[1000];\n   std::cout &lt;&lt; sizeof arr;\n}\n</code></pre>\n<p>if arr were a pointer this program would print sizeof (char*) which is typically 4. But it prints 1000.</p>\n<p>another proof:</p>\n<pre><code>template &lt;class T&gt;\nvoid f(T&amp; obj)\n{\n   T x = obj; //this will fail to compile if T is an array type\n}\n\nint main()\n{\n   int a[30] = {};\n   int* p = 0; \n   f(p); //OK\n   f(a); //results in compile error. Remember f takes by ref therefore needs lvalue and no conversion applies\n}\n</code></pre>\n<p>Formally, an array is converted to a pointer to its first element in lvalue-to-rvalue conversions, that is when an lvalue of array type is given in a context when an rvalue is expected, the array is converted to a pointer to its first element.</p>\n<p>Also, a function declared to take an array by value is equivant to function taking a pointer, that is</p>\n<pre><code>void f(int a[]);\nvoid f(int a[10]);\nvoid f(int* a);\n</code></pre>\n<p>are three equivalent declarations. HTH</p>\n", "LastEditorUserId": "469935", "LastActivityDate": "2010-10-18T19:26:39.477", "Score": "4", "CreationDate": "2010-10-18T14:06:54.333", "ParentId": "3959705", "CommentCount": "13", "OwnerUserId": "469935", "LastEditDate": "2010-10-18T19:26:39.477"}, "3960303": {"Id": "3960303", "PostTypeId": "2", "Body": "<p>No, they are not <strong>implemented</strong> differently.  Both find elements with the same calculation: <code>a[i]</code> is at address <code>a + i*sizeof(a[0])</code>, also <code>p[i]</code> is at address <code>p + i*sizeof(p[0])</code>.</p>\n<p>But, <strong>they are treated differently by the type system</strong>.  C++ has typing information on arrays which can be seen through the <code>sizeof operator</code> (like C), template inference, function overloading, RTTI, and so on.  Basically anywhere in the language that type information is used, it is possible for pointers and arrays to behave differently.</p>\n<p>There are many many examples in C++ where two different language concepts have the same implementation.  Just a few: arrays vs pointers, pointers vs references, virtual functions vs function pointers, iterators vs pointers, for loops vs while loops, exceptions vs longjmp</p>\n<p>In every case, there's a different syntax and a different way of thinking about the two concepts, but they result in the same machine code in the end.</p>\n", "LastActivityDate": "2010-10-18T14:45:45.630", "CommentCount": "0", "CreationDate": "2010-10-18T14:45:45.630", "ParentId": "3959705", "Score": "5", "OwnerUserId": "103167"}});