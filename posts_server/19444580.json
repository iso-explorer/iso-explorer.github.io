post_cb({"bq_ids": {"n4140": {"so_19444580_19444580_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 45}, "so_19444580_19446224_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 7210}}, "n3337": {"so_19444580_19444580_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 42}, "so_19444580_19446224_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 6954}}, "n4659": {"so_19444580_19444580_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 46}, "so_19444580_19446224_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 8719}}}, "19445770": {"Id": "19445770", "PostTypeId": "2", "Body": "<p>I will say what i know...</p>\n<p>For char type c++ has size '1' byte..</p>\n<p>if it is signed char then the range is from -128 to 127\nelse if it is unsigned char range is from 0 to 256</p>\n<p>we all know the 8 bits in a byte in case of signed char the MSB(ie , the left most bit) will be used for the sign the rest 7 bits for values making range 0-2^7(0-127) .negative sign(logical 1) and (logical 0) for positive sign on MSB. eg( 1 0000111=-7,0 0000111=+7)and 1 0000000-128. However if assign 129 for a signed char value it will be automatically changed to -127 (ie a value in range (-128,127).</p>\n<p>on the other case of unsigned char type all the 8 bits are used for values ie range is 0-2^8(0-255). here 0-127 is same as the signed char and the ones belongs to -128 to 0 can be found in range 128-255 in the unsigned char set.</p>\n<p>So we can say and spot the internal memory difference between the two types 'signed' and 'unsigned' which may be the problem.</p>\n", "LastActivityDate": "2013-10-18T09:09:57.733", "CommentCount": "6", "CreationDate": "2013-10-18T09:09:57.733", "ParentId": "19444580", "Score": "-1", "OwnerUserId": "2644803"}, "19446224": {"Id": "19446224", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19444580_19446224_0\">From what I learned, <code>char</code> and <code>signed char</code> are semantically identical, but are still &gt;considered as different by the compiler.</p>\n</blockquote>\n<p>NO. <code>char</code> is not semantically identical to <code>signed char</code>.</p>\n<p>In contrast to the other integral types (integer, long, short etc) there is no guarantee that char without a <code>signed</code> or <code>unsigned</code> will be <code>signed</code>. This is implementation defined. Some architectures define it as <code>signed</code>, others as <code>unsigned</code> <em>in the real world</em> </p>\n<p>So, with a <code>char</code>, if the signedness is important, you really do need to specify which you want. </p>\n<p>My recommendation would be if you are doing character manipulation etc, or using an api call that uses <code>char</code> or <code>char *</code>, use <code>char</code>. If you just want an 8-bit integer value, make sure you specify <code>signed char</code> or <code>unsigned char</code>, so that in a couple of years time when you port to a different architecture you don't get bitten in the bum.</p>\n<p>Or better yet, use <code>uint8_t</code> or <code>int8_t</code> for 8 bit integers.</p>\n<p>EDIT: From your own answer:</p>\n<blockquote>\n<p id=\"so_19444580_19446224_1\">These requirements do not hold for other types. In any particular implementation, a plain <strong>char object</strong> can take on either the same values as a signed char <strong>or</strong> an unsigned char; <strong>which one is implementation-defined.</strong></p>\n</blockquote>\n", "LastEditorUserId": "2139094", "LastActivityDate": "2013-10-18T09:38:03.520", "Score": "0", "CreationDate": "2013-10-18T09:32:05.567", "ParentId": "19444580", "CommentCount": "0", "OwnerUserId": "2139094", "LastEditDate": "2013-10-18T09:38:03.520"}, "19444580": {"ViewCount": "1176", "Body": "<p>I saw a piece of valid C code I tried to compile as C++ and I got an error I can't understand.</p>\n<pre><code>char* t;\nsigned char* v = t;\n</code></pre>\n<blockquote>\n<p id=\"so_19444580_19444580_0\">error: invalid conversion from <code>char*</code> to <code>signed char*</code></p>\n</blockquote>\n<p>From what I learned, <code>char</code> and <code>signed char</code> are semantically identical, but are still considered as different by the compiler.</p>\n<p>I know that the error is caused by the difference between these two type, my question is: <strong>Why does this difference exists ?</strong></p>\n<p>As far as I know <code>char</code> is implemented either as a <code>signed char</code> or as a <code>unsigned char</code> so it should be identical to either one or the other.</p>\n<hr>\n<p>I consulted <a href=\"https://stackoverflow.com/questions/15046162/invalid-conversion-from-unsigned-char-to-char\">this question</a> and it doesn't answer the point I want to know.</p>\n</hr>", "AcceptedAnswerId": "19444641", "Title": "Conversion from char* to signed char*", "CreationDate": "2013-10-18T08:04:52.490", "Id": "19444580", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:28:25.017", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-18T09:38:03.520", "Score": "9", "OwnerUserId": "610351", "Tags": "<c++><char><signed>", "AnswerCount": "3"}, "19444641": {"Id": "19444641", "PostTypeId": "2", "Body": "<p>Actually I finally found the spec part talking about this:</p>\n<blockquote>\n<p id=\"so_19444580_19444641_0\">3.9.1 Fundamental types</p>\n<ol>\n<li>Objects declared as characters (char) shall be large enough to store\n  any member of the implementation\u2019s basic character set. If a character\n  from this set is stored in a character object, the integral value of\n  that character object is equal to the value of the single character\n  literal form of that character. It is implementation-defined whether a\n  char object can hold negative values. Characters can be explicitly\n  declared unsigned or signed. <strong>Plain char, signed char, and unsigned\n  char are three distinct types.</strong> A char, a signed char, and an unsigned\n  char occupy the same amount of storage and have the same alignment\n  requirements (3.11); that is, they have the same object\n  representation. For character types, all bits of the object\n  representation participate in the value representation. For unsigned\n  character types, all possible bit patterns of the value representation\n  represent numbers. These requirements do not hold for other types. In\n  any particular implementation, a plain char object can take on either\n  the same values as a signed char or an unsigned char; which one is\n  implementation-defined.</li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2013-10-18T08:08:26.803", "CommentCount": "0", "CreationDate": "2013-10-18T08:08:26.803", "ParentId": "19444580", "Score": "9", "OwnerUserId": "610351"}});