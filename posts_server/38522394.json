post_cb({"38522440": {"ParentId": "38522394", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's specified in the standard, under Templates (14), Template instantiation and specialization (14.7), Implicit instantiation (14.7.1).</p>\n<blockquote>\n<p id=\"so_38522394_38522440_0\">3 Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_38522394_38522440_1\">11 An implementation shall not implicitly instantiate a function\n  template, a member template, a non-virtual member function, a member\n  class, or a static data member of a class template that does not\n  require instantiation.</p>\n</blockquote>\n", "OwnerUserId": "73657", "LastEditorUserId": "73657", "LastEditDate": "2016-07-22T09:10:20.907", "Id": "38522440", "Score": "4", "CreationDate": "2016-07-22T09:05:02.157", "LastActivityDate": "2016-07-22T09:10:20.907"}, "bq_ids": {"n4140": {"so_38522394_38522440_0": {"section_id": 235, "quality": 0.9545454545454546, "length": 21}, "so_38522394_38522440_1": {"section_id": 243, "quality": 1.0, "length": 20}}, "n3337": {"so_38522394_38522440_0": {"section_id": 228, "quality": 0.9545454545454546, "length": 21}, "so_38522394_38522440_1": {"section_id": 235, "quality": 1.0, "length": 20}}, "n4659": {"so_38522394_38522440_0": {"section_id": 245, "quality": 0.9545454545454546, "length": 21}, "so_38522394_38522440_1": {"section_id": 250, "quality": 0.9, "length": 18}}}, "38522394": {"CommentCount": "1", "ViewCount": "71", "PostTypeId": "1", "LastEditorUserId": "4326278", "CreationDate": "2016-07-22T09:02:47.300", "LastActivityDate": "2016-11-27T15:08:09.713", "Title": "Method in template class only for certain template parameters correct", "FavoriteCount": "1", "LastEditDate": "2016-11-27T15:08:09.713", "Id": "38522394", "Score": "2", "Body": "<p>Consider the following template class</p>\n<pre><code>template&lt;typename T&gt;\nstruct Caller {\n    void func(const T &amp;t) { t.func(); }\n    void gunc(const T &amp;t) { t.gunc(); }\n};\n</code></pre>\n<p>Now let some class <code>Target</code> only provide the member function <code>func()</code> but not <code>gunc()</code>, i.e.</p>\n<pre><code>struct Target {\n    void func() const { /* ... /* }\n};\n</code></pre>\n<p>is the template instantiation <code>Caller&lt;Target&gt;</code> valid?</p>\n<p>GCC, clang as well as VC++ accept such template instantiations. Of course, calling <code>Caller&lt;Target&gt;::gunc()</code> leads to an error but <code>Caller&lt;Target&gt;::func()</code> works just fine and as intended.</p>\n<p><strong>Now the question:</strong> What is the background for this permissive behavior and where are the relevant paragraphs in C++ standard.</p>\n", "Tags": "<c++><templates><template-instantiation>", "OwnerUserId": "71051", "AnswerCount": "1"}});