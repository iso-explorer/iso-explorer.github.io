post_cb({"14432644": {"ParentId": "14432539", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You can trigger the conversion operator with a cast:</p>\n<pre><code>printf(\"Test: %s, %s\\n\", static_cast&lt;const char*&gt;(str), \n       static_cast&lt;const char*&gt;(global_str));\n</code></pre>\n<p>However, I don't know if you will run into any problems with this, avoiding varargs in C++ code would probably be the best.</p>\n<p>How about using the <a href=\"http://en.wikipedia.org/wiki/Variadic_template\" rel=\"nofollow\">type-safe printf</a> instead (Credit: Wikipedia):</p>\n<pre><code>void printf(const char *s)\n{\n    while (*s) {\n        if (*s == '%') {\n            if (*(s + 1) == '%') {\n                ++s;\n            }\n            else {\n                throw std::runtime_error(\"invalid format string: missing arguments\");\n            }\n        }\n        std::cout &lt;&lt; *s++;\n    }\n}\n\ntemplate&lt;typename T, typename... Args&gt;\nvoid printf(const char *s, T value, Args... args)\n{\n    while (*s) {\n        if (*s == '%') {\n            if (*(s + 1) == '%') {\n                ++s;\n            }\n            else {\n                std::cout &lt;&lt; value;\n                printf(s + 1, args...); // call even when *s == 0 to detect extra arguments\n                return;\n            }\n        }\n        std::cout &lt;&lt; *s++;\n    }\n    throw std::logic_error(\"extra arguments provided to printf\");\n}\n</code></pre>\n<p>I don't think libstdc++ supports <code>std::runtime_error</code> and <code>std::logic_error</code> though.</p>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2013-01-21T06:31:32.453", "Id": "14432644", "Score": "1", "CreationDate": "2013-01-21T04:38:29.857", "LastActivityDate": "2013-01-21T06:31:32.453"}, "14432727": {"ParentId": "14432539", "CommentCount": "1", "Body": "<p>what are you trying to solve writing this (ugly, to be honest) string class??\nwhy not to use smth else? (like <code>std::string</code>) -- please think twice before starting to write your-own-super-optimized strings...</p>\n<p>about your question: you are <strong>really lucky</strong> with your sample code! have you any idea how ellipse works (in machine code) in C and <strong>why</strong> it is not allowed to pass non-trivial types via it? \nIn brief: <code>printf()</code> just looks into a format string and if it sees '%s' in it it assumes that next argument is a <code>char*</code> thats all! So if you pass anything else (like <code>char</code>, <code>short</code>, etc) instead -- it will be UB! (and in case of different <code>sizeof()</code> than expected it is high probability that you'll get a segmentation fault soon... It is why ellipses is a <strong>bad practice</strong> in C++! they are completely type-unsafe!</p>\n<p>If you are using C++, <strong>just do not use</strong> C API! There are plenty C++ libs designed for formatting output (like boost::format) and they are type-safe! C++11 open the door for printf-like function but with type safe guarantee! just read a \"classic\" example about variadic templates... and only after reading, try to implement your own strings :)</p>\n", "OwnerUserId": "1655064", "PostTypeId": "2", "Id": "14432727", "Score": "0", "CreationDate": "2013-01-21T04:48:13.190", "LastActivityDate": "2013-01-21T04:48:13.190"}, "14432539": {"CommentCount": "8", "ViewCount": "4582", "CreationDate": "2013-01-21T04:26:52.127", "LastActivityDate": "2016-02-12T15:14:47.917", "Title": "C++: Passing classes to vararg function", "AcceptedAnswerId": "14432644", "PostTypeId": "1", "Id": "14432539", "Score": "2", "Body": "<p>I'm trying to make a class that behaves like MS CString (that is, you pass it to printf and it acts just like a pointer to C string, without additional ugly black magic like \".c_str()\").</p>\n<p>This is very first implementation of this class, that just works and doesn't yet provide anything useful:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n\nclass CString\n{\nprotected:\n    struct CStringInfo\n    {\n        size_t Length;\n        size_t MaxLength;\n    };\n\npublic:\n    CString()\n    {\n        Buffer = NULL;\n\n        Assign(NULL);\n    }\n\n    CString(const char* chv)\n    {\n        Buffer = NULL;\n\n        Assign(chv, 0);\n    }\n\n    ~CString()\n    {\n        if(Buffer) delete[] Buffer;\n        Buffer = NULL;\n    }\n\n    size_t GetLength()\n    {\n        if(!Buffer) Alloc(1);\n        return GetInfo()-&gt;Length;\n    }\n\n    size_t Resize(size_t size)\n    {\n        Alloc(size + 1); // + 0x00\n        Buffer[size] = 0;\n        return size;\n    }\n\n    bool Assign(const char* value, size_t size = 0)\n    {\n        size_t strl = ((size) ? size : strlen(value));\n\n        if(!value || !(strl = strlen(value)))\n        {\n            if(!Buffer) Alloc(1);\n            return false;\n        }\n\n        Alloc(strl + 1);\n        memcpy(Buffer, value, strl);\n        Buffer[strl] = 0;\n        return true;\n    }\n\n    CString&amp; operator = (const char* what)\n    {\n        Assign(what);\n        return (*this);\n    }\n\n    CString&amp; operator = (CString&amp; string)\n    {\n        Assign(string.Buffer);\n        return (*this);\n    }\n\n    operator const char* ()\n    {\n        return Buffer;\n    }\n\nprotected:\n    char* Buffer;\n\n    void Alloc(size_t size)\n    {\n        if(!size) size = 1;\n        char* nb = new char[size + sizeof(CStringInfo)];\n        char* nbb = nb + sizeof(CStringInfo);\n        size_t cl = size - 1;\n        if(Buffer)\n        {\n            if(cl &gt; GetInfo()-&gt;Length) cl = GetInfo()-&gt;Length;\n            if(cl) memcpy(nbb, Buffer, cl - 1);\n            nbb[cl] = 0;\n            *(CStringInfo*)(nb) = *(CStringInfo*)(Buffer);\n            delete[] (Buffer - sizeof(CStringInfo));\n        }\n\n        Buffer = nb;\n        GetInfo()-&gt;MaxLength = size;\n        GetInfo()-&gt;Length = cl;\n    }\n\n    void Free()\n    {\n        if(Buffer)\n        {\n            delete[] (Buffer - sizeof(CStringInfo));\n        }\n    }\n\n    CStringInfo* GetInfo()\n    {\n        return (CStringInfo*)(this-&gt;Buffer - sizeof(CStringInfo));\n    }\n};\n</code></pre>\n<p>And code I test it on:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include \"CString.hpp\"\n\nCString global_str = \"global string!\";\n\nint main(int argc, char* argv[])\n{\n    CString str = \"string\";\n    printf(\"Test: %s, %s\\n\", str, global_str);\n    return 0;\n}\n</code></pre>\n<p>If I don't have a destructor in the class, then I can pass it to printf and it will work just like it should (as a C string). But when I add destructor, GCC produces following error:</p>\n<pre><code>error: cannot pass objects of non-trivially-copyable type 'class CString' through '...'\n</code></pre>\n<p>And in addition to that prior versions of GCC will give a warning + ud2 opcode.</p>\n<p>So... Question: can I actually make following construction work in GCC or is there any way, possibly not involving C varargs, to make something identical in use to above code?</p>\n", "Tags": "<c++><c><printf>", "OwnerUserId": "935559", "AnswerCount": "4"}, "35365992": {"ParentId": "14432539", "CommentCount": "0", "Body": "<p>You can't pass objects via varargs, only pointers to objects. However, you can use a (variadic) template-based implementation of <code>printf</code> such as the one provided by <a href=\"https://github.com/cppformat/cppformat\" rel=\"nofollow\">C++ Format</a>:</p>\n<pre><code>#include \"format.h\"\n#include \"CString.hpp\"\n\nCString global_str = \"global string!\";\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const CString &amp;s) {\n  return os &lt;&lt; static_cast&lt;const char*&gt;(s);\n}\n\nint main() {\n  CString str = \"string\";\n  fmt::printf(\"Test: %s, %s\\n\", str, global_str);\n}\n</code></pre>\n<p>This will print \"Test: string, global string!\" provided that <code>CString</code> is implemented correctly.</p>\n<p>Unlike Jesse Good's implementation, this supports standard <a href=\"http://en.cppreference.com/w/cpp/io/c/fprintf\" rel=\"nofollow\"><code>printf</code> format specifiers</a>.</p>\n<p><strong>Disclaimer</strong>: I'm the author of this library</p>\n", "OwnerUserId": "471164", "PostTypeId": "2", "Id": "35365992", "Score": "0", "CreationDate": "2016-02-12T15:14:47.917", "LastActivityDate": "2016-02-12T15:14:47.917"}, "14432703": {"ParentId": "14432539", "CommentCount": "0", "Body": "<p>You pretty much need to invoke a member function, either directly (<code>foo.c_str()</code>) or via something like a cast (<code>(char *)foo</code>).</p>\n<p>Otherwise, it depends on the compiler. In C++03, the behavior is undefined (\u00a75.2.2/7):</p>\n<blockquote>\n<p id=\"so_14432539_14432703_0\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving function can obtain the value of the argument by invoking va_arg (18.7). The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression. After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. If the argument has a non-POD class type (clause 9), the behavior is undefined.</p>\n</blockquote>\n<p>...but in (C++11, \u00a75.2.2/7), it's conditionally supported:</p>\n<blockquote>\n<p id=\"so_14432539_14432703_1\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that has (possibly cv-qualified) type std::nullptr_t is converted to type void* (4.10). After these conversions, if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the program is ill-formed. Passing a potentially-evaluated argument of class type (Clause 9) having a nontrivial copy constructor, a non-trivial move constructor, or a non-trivial destructor, with no corresponding parameter, is conditionally-supported with implementation-defined semantics.</p>\n</blockquote>\n<p>\"conditionally-supported with implementation-defined semantics\" leaves an opening for an implementation to support it with proper documentation, but it's still about as close to undefined behavior as you can get.</p>\n<p>If I were going to do this, I think I'd set up some sort of intermediary using a variadic template. With this, you'd supply an overload that (for example) automatically passed <code>foo.c_str()</code> to <code>printf</code> when you passed an argument of type <code>std::string</code>. It's (probably) more code, but at least it'll actually work. Personally, I'd avoid the whole thing as simply being more trouble than it's worth though.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "14432703", "Score": "2", "CreationDate": "2013-01-21T04:45:02.037", "LastActivityDate": "2013-01-21T04:45:02.037"}, "bq_ids": {"n4140": {"so_14432539_14432703_1": {"section_id": 5994, "quality": 0.95, "length": 57}, "so_14432539_14432703_0": {"section_id": 5994, "quality": 0.8478260869565217, "length": 39}}, "n3337": {"so_14432539_14432703_1": {"section_id": 5762, "quality": 0.95, "length": 57}, "so_14432539_14432703_0": {"section_id": 5762, "quality": 0.8478260869565217, "length": 39}}, "n4659": {"so_14432539_14432703_1": {"section_id": 7496, "quality": 0.9, "length": 54}, "so_14432539_14432703_0": {"section_id": 7496, "quality": 0.8478260869565217, "length": 39}}}});