post_cb({"3605731": {"CommentCount": "14", "ViewCount": "1327", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-08-31T02:55:20.330", "LastActivityDate": "2010-08-31T05:17:10.687", "Title": "Side effect / Volatile / Copy Constructor / Destructor", "LastEditDate": "2017-05-23T11:47:48.067", "Id": "3605731", "Score": "1", "Body": "<p>With reference to the discussion <a href=\"https://stackoverflow.com/questions/3604569/what-kinds-of-optimizations-does-volatile-prevent-in-c\">here</a></p>\n<p>$3.7.1/2 - \"If an object of static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy may be eliminated as specified in 12.8.\"</p>\n<p>$12.8/15- \"When certain criteria are met, an implementation is allowed to omit the copy construction of a class object, even if the copy constructor and/or destructor for the object have side effects.\"</p>\n<p>Is the above case, specific examples of a case, where even a volatile read/write may also be optimized away (e.g. if a copy constructor has a read/write to a volatile variable).</p>\n<p>So the question is \"can a copy constructor be elided even if the copy constructor has a read/write of a volatile variable?\"</p>\n", "Tags": "<c++><constructor><copy><destructor><volatile>", "OwnerUserId": "418110", "AnswerCount": "2"}, "3606185": {"ParentId": "3605731", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Sometimes. Funny you should ask, since something I mis-remembered about <code>volatile</code> (which Johannes called out) led me to look up exactly such trivia.</p>\n<p>\u00a712.8/15:</p>\n<blockquote>\n<p id=\"so_3605731_3606185_0\">in a return statement in a function\n  with a class return type, when the\n  expression is the name of a\n  non-volatile automatic object with the\n  same cv-unqualified type as the\n  function return type, the copy\n  operation can be omitted by\n  constructing the automatic object\n  directly into the function\u2019s return\n  value</p>\n</blockquote>\n<p>So, it's OK to eliminate a <code>volatile</code> access by eliding the constructor, but not if the <em>entire</em> object is volatile.</p>\n<p>Also, it <em>can</em> make a difference if a function returns <code>volatile foo</code> <em>by value</em> as opposed to plain <code>foo</code>, because construction of the volatile temporary cannot be elided!</p>\n<pre><code>foo factory_a(); // return class by value\nconst foo factory_b(); // also return by value: rather pointless\nvolatile foo factory_c(); // implies no elision\n</code></pre>\n<p>Note that the cv-qualification of the returned temporary also affects access semantics of the temporary, for example <code>factory_b().non_const_method()</code> is illegal. So this is all more arcane than boneheaded.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2010-08-31T05:17:10.687", "Id": "3606185", "Score": "0", "CreationDate": "2010-08-31T05:10:17.470", "LastActivityDate": "2010-08-31T05:17:10.687"}, "bq_ids": {"n4140": {"so_3605731_3606185_0": {"section_id": 480, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_3605731_3606185_0": {"section_id": 471, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_3605731_3606185_0": {"section_id": 502, "quality": 0.8666666666666667, "length": 26}}}, "3605852": {"ParentId": "3605731", "CommentCount": "2", "Body": "<p>NRVO is only allowed if the named object is non-volatile [its right in the same section you quoted, the first bullet], but otherwise I don't see why not.  After all, if the object you are creating is volatile, you are still writing to it, you just aren't doing so via the copy constructor.  And it doesn't qualify which side effects it is allowed to ignore, so clearly if the volatile read/write is within the copy constructor itself the compiler doesn't have to care.</p>\n", "OwnerUserId": "293791", "PostTypeId": "2", "Id": "3605852", "Score": "0", "CreationDate": "2010-08-31T03:39:50.850", "LastActivityDate": "2010-08-31T03:39:50.850"}});