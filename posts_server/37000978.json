post_cb({"37001054": {"ParentId": "37000978", "CommentCount": "1", "Body": "<p>Your code ends up storing a dangling reference (to an object that no longer exists) inside the function wrapper, and invoking the function results in undefined behaviour.</p>\n<p>If the original object doesn't live as long as the wrapper, you can always store a <em>copy</em> of the object in the wrapper:</p>\n<pre><code>f = std::bind(&amp;A::shout, a);\n//                      ^^^ copy\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "37001054", "Score": "5", "CreationDate": "2016-05-03T09:57:41.283", "LastActivityDate": "2016-05-03T09:57:41.283"}, "37001173": {"ParentId": "37000978", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>To show this is undefined, note that the address stored becomes an invalid pointer value - <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0137r0.html\" rel=\"nofollow\">[basic.stc]/3</a>:</p>\n<blockquote>\n<p id=\"so_37000978_37001173_0\">When the end of the duration of a region of storage is reached, the\n  values of all pointers representing the address of any part of the\n  deallocated storage become invalid pointer values ([basic.compound]).</p>\n</blockquote>\n<p>In the call to the bound functor, that pointer is dereferenced to perform the member function call, where <a href=\"http://eel.is/c++draft/basic.stc.dynamic.deallocation#4\" rel=\"nofollow\">[basic.stc.dynamic.deallocation]/4</a> applies:</p>\n<blockquote>\n<p id=\"so_37000978_37001173_1\">Indirection through an invalid pointer value and passing an invalid\n  pointer value to a deallocation function have undefined behavior.</p>\n</blockquote>\n<p>Instead, you could bind <code>a</code> per value (omit the ampersand).</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-05-03T10:08:55.573", "Id": "37001173", "Score": "2", "CreationDate": "2016-05-03T10:03:05.230", "LastActivityDate": "2016-05-03T10:08:55.573"}, "37000978": {"CommentCount": "0", "ViewCount": "44", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2016-05-03T09:53:25.897", "LastActivityDate": "2016-05-03T10:13:25.417", "Title": "Is the behavior of a functor created by std::bind well-defined when the bound object expires?", "AcceptedAnswerId": "37001054", "LastEditDate": "2016-05-03T10:13:25.417", "Id": "37000978", "Score": "0", "Body": "<p>Is the behavior of the following code well defined? How does the <code>f()</code> call behave?</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nstruct A\n{\n  void shout()\n  {\n      std::cout &lt;&lt;\"shout\";\n  }\n};\n\n\nint main()\n{\n    std::function&lt;void()&gt; f;\n    {\n        A a;\n        f = std::bind(&amp;A::shout, &amp;a);\n    }\n\n    f();  // what happens here?\n}\n</code></pre>\n", "Tags": "<c++><language-lawyer><stdbind>", "OwnerUserId": "1235183", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37000978_37001173_1": {"section_id": 7183, "quality": 1.0, "length": 14}}, "n3337": {"so_37000978_37001173_1": {"section_id": 6931, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_37000978_37001173_0": {"section_id": 8671, "quality": 0.8947368421052632, "length": 17}, "so_37000978_37001173_1": {"section_id": 8671, "quality": 1.0, "length": 14}}}});