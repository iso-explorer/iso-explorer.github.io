post_cb({"bq_ids": {"n4140": {"so_20860535_20860535_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 4718}, "so_20860535_20860535_1": {"length": 17, "quality": 0.85, "section_id": 4718}}, "n3337": {"so_20860535_20860535_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 4525}, "so_20860535_20860535_1": {"length": 17, "quality": 0.85, "section_id": 4525}}, "n4659": {"so_20860535_20860535_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6117}, "so_20860535_20860535_1": {"length": 17, "quality": 0.85, "section_id": 6117}}}, "21168610": {"Id": "21168610", "PostTypeId": "2", "Body": "<p>gcc was recently <a href=\"http://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=206302\" rel=\"nofollow\">patched</a> and version 4.9 will accept the code. clang accepts it as well, so the code is probably fine. That doesn't tell you how to work around the issue with older versions of gcc, sorry.</p>\n", "LastActivityDate": "2014-01-16T17:22:19.967", "CommentCount": "0", "CreationDate": "2014-01-16T17:22:19.967", "ParentId": "20860535", "Score": "4", "OwnerUserId": "1918193"}, "20860535": {"ViewCount": "483", "Body": "<p>Suppose I don't have <code>std::is_convertible</code> for whatever reason and want to implement it myself. The standard says something along these lines:</p>\n<blockquote>\n<p id=\"so_20860535_20860535_0\">The predicate condition for a template specialization <code>is_convertible&lt;From, To&gt;</code> shall be satisfied if and only if the return expression in the following code would be well-formed, including any implicit conversions to the return type of the function:</p>\n<pre><code>To f() {\n    return declval&lt;From&gt;();\n}\n</code></pre>\n</blockquote>\n<p>Okay, no big deal, I can do it like this (Note argument order opposite to the one in <code>std::is_convertible</code>, this is intentional and irrelevant to the issue):</p>\n<pre><code>template &lt;typename To_, typename From_&gt;\nclass my_is_convertible {\n    private:\n        template &lt;typename To&gt;\n        struct indirector {\n            indirector(To);\n        };\n\n        template &lt;typename To, typename From&gt;\n        struct tag {};\n\n        template &lt;typename To, typename From&gt;\n        static auto test(tag&lt;To, From&gt;)\n            -&gt; decltype(indirector&lt;To&gt;(std::declval&lt;From&gt;()), std::true_type());\n        static auto test(...)\n            -&gt; std::false_type;\n\n    public:\n        static constexpr bool value = decltype(test(tag&lt;To_, From_&gt;()))::value;\n};\n</code></pre>\n<p>This seems to work as intended, and as far as I can tell does the same thing.</p>\n<p>Now I can distinguish between implicit and explicit (or none at all) constructors:</p>\n<pre><code>struct A {};\nstruct B {};\n\nstruct Test {\n    Test(A);\n    explicit Test(B);\n}; \n\nint main() {   \n    std::cout &lt;&lt; my_is_convertible&lt;Test, A&gt;::value; // true \n    std::cout &lt;&lt; my_is_convertible&lt;Test, B&gt;::value; // false\n    return 0;\n}\n</code></pre>\n<p>So far, so good. Now, I want to do the same with multiple argument constructors. This didn't make sense prior to <code>c++11</code> as there was no way to call multiargument constructor implicitly. But now we have brace enclosed initializer list syntax, and <code>explicit</code> keyword on multiargument constructor makes a difference.</p>\n<p>Let us extend the definition:</p>\n<blockquote>\n<p id=\"so_20860535_20860535_1\">The predicate condition for a template specialization <code>my_is_convertible_many&lt;To, From...&gt;</code> shall be satisfied if and only if the return expression in the following code would be well-formed, including any implicit conversions to the return type of the function:</p>\n<pre><code>To f() {\n    return {declval&lt;From&gt;()...};\n}\n</code></pre>\n</blockquote>\n<p>To implement it I went the obvious way:</p>\n<pre><code>template &lt;typename To_, typename... From_&gt;\nclass my_is_convertible_many {\n    private:\n        template &lt;typename To&gt;\n        struct indirector {\n            indirector(To);\n        };\n\n        template &lt;typename To, typename... From&gt;\n        struct tag {};\n\n        template &lt;typename To, typename... From&gt;\n        static auto test(tag&lt;To, From...&gt;)\n            -&gt; decltype(indirector&lt;To&gt;({std::declval&lt;From&gt;()...}), std::true_type());\n        static auto test(...)\n            -&gt; std::false_type;\n\n    public:\n        static constexpr bool value = decltype(test(tag&lt;To_, From_...&gt;()))::value;\n};\n</code></pre>\n<p>This correctly reports <code>true</code> in the presence of matching implicit constructor and <code>false</code> if the is no matcing constructor. But it fails to compile if there is an explicit matching constructor (at least on gcc 4.8.1):</p>\n<pre><code>struct A {};\nstruct B {};\nstruct C {};\n\nstruct Test {\n    Test(A, A);\n    //Test(B, B);\n    explicit Test(C, C);\n}; \n\nint main() {    \n    std::cout &lt;&lt; my_is_convertible_many&lt;Test, A, A&gt;::value; // true, correct\n    std::cout &lt;&lt; my_is_convertible_many&lt;Test, B, B&gt;::value; // false, correct\n    std::cout &lt;&lt; my_is_convertible_many&lt;Test, C, C&gt;::value; // error\n    return 0;\n}\n</code></pre>\n<p>The error is about attempting to implicitly call explicit constructor, which on gcc sounds like this:</p>\n<pre><code>main.cpp: In substitution of 'template&lt;class To, class ... From&gt; static decltype (((my_is_convertible_many&lt;To_, From_&gt;::indirector&lt;To&gt;)({(declval&lt;From&gt;)()...}), std::true_type())) my_is_convertible_many&lt;To_, From_&gt;::test(my_is_convertible_many&lt;To_, From_&gt;::tag&lt;To, From ...&gt;) [with To = To; From = {From ...}; To_ = Test; From_ = {C, C}] [with To = Test; From = {C, C}]':\nmain.cpp:21:73:   required from 'constexpr const bool my_is_convertible_many&lt;Test, C, C&gt;::value'\nmain.cpp:37:54:   required from here\nmain.cpp:17:97: error: converting to 'Test' from initializer list would use explicit constructor 'Test::Test(C, C)'\n         static auto test(tag&lt;To, From...&gt;) -&gt; decltype(indirector&lt;To&gt;({std::declval&lt;From&gt;()...}), std::true_type());\n                                                                                                 ^\n</code></pre>\n<p>Which is sensible. I, however, expect this overload of <code>test</code> to sfinae out and the other one to be used instead, thus producing no error.</p>\n<p>So the question is: Why doesn't this happen, and what can I do about it?</p>\n", "AcceptedAnswerId": "21168610", "Title": "is_convertible for multiple arguments", "CreationDate": "2013-12-31T16:46:58.263", "Id": "20860535", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-02T08:52:28.690", "LastEditorUserId": "1554020", "LastActivityDate": "2014-01-16T17:22:19.967", "Score": "15", "OwnerUserId": "1554020", "Tags": "<c++><c++11><implicit-conversion><sfinae><typetraits>", "AnswerCount": "1"}});