post_cb({"2310504": {"CommentCount": "7", "Body": "<p>As you say, this is strictly undefined behaviour, though it will \"work\" on many platforms. The real reason for using unions is to create variant records.</p>\n<pre><code>union A {\n   int i;\n   double d;\n};\n\nA a[10];    // records in \"a\" can be either ints or doubles \na[0].i = 42;\na[1].d = 1.23;\n</code></pre>\n<p>Of course, you also need some sort of discriminator to say what the variant actually contains. And note that in C++ unions are not much use because they can only contain POD types - effectively those without constructors and destructors.</p>\n", "CreationDate": "2010-02-22T11:22:20.970", "OwnerDisplayName": "anon", "ParentId": "2310483", "Id": "2310504", "LastActivityDate": "2010-02-22T11:22:20.970", "PostTypeId": "2", "Score": "8"}, "2311425": {"LastActivityDate": "2012-05-11T11:30:50.430", "CommentCount": "3", "Body": "<p>Others have mentioned the architecture differences (little - big endian).</p>\n<p>I read the problem that since the memory for the variables is shared, then by writing to one, the others change and, depending on their type, the value could be meaningless.</p>\n<p>eg. \n    union{\n      float f;\n      int   i;\n    } x;</p>\n<p>Writing to x.i would be meaningless if you then read from x.f - unless that is what you intended in order to look at the sign, exponent or mantissa components of the float.</p>\n<p>I think there is also an issue of alignment: If some variables must be word aligned then you might not get the expected result.</p>\n<p>eg.\n    union{\n      char  c[4];\n      int   i;\n    } x;</p>\n<p>If, hypothetically, on some machine a char had to be word aligned then c[0] and c[1] would share storage with i but not c[2] and c[3].</p>\n", "CreationDate": "2010-02-22T14:25:14.327", "LastEditDate": "2012-05-11T11:30:50.430", "ParentId": "2310483", "Id": "2311425", "LastEditorUserId": "275052", "PostTypeId": "2", "Score": "3", "OwnerUserId": "275052"}, "2310508": {"CommentCount": "1", "Body": "<p>Although this is strictly undefined behaviour, in practice it will work with pretty much any compiler. It is such a widely used paradigm that any self-respecting compiler will need to do \"the right thing\" in cases such as this. It's certainly to be preferred over type-punning, which may well generate broken code with some compilers.</p>\n", "CreationDate": "2010-02-22T11:22:40.500", "ParentId": "2310483", "Id": "2310508", "LastActivityDate": "2010-02-22T11:22:40.500", "PostTypeId": "2", "Score": "4", "OwnerUserId": "253056"}, "2310621": {"CommentCount": "1", "Body": "<p>You can <em>use</em> a a union for two main reasons:</p>\n<ol>\n<li>A handy way to access the same data in different ways, like in your example</li>\n<li>A way to save space when there are different data members of which only one can ever be 'active'</li>\n</ol>\n<p>1 Is really more of a C-style hack to short-cut writing code on the basis you know how the target system's memory architecture works. As already said you can normally get away with it if you don't actually target lots of different platforms. I believe some compilers might let you use packing directives also (I know they do on structs)?</p>\n<p>A good example of 2. can be found in the <a href=\"http://msdn.microsoft.com/en-us/library/ms221627.aspx\" rel=\"nofollow noreferrer\">VARIANT</a> type used extensively in COM.</p>\n", "CreationDate": "2010-02-22T11:46:30.353", "ParentId": "2310483", "Id": "2310621", "LastActivityDate": "2010-02-22T11:46:30.353", "PostTypeId": "2", "Score": "2", "OwnerUserId": "197229"}, "18177444": {"CommentCount": "7", "Body": "<p>The most <em>common</em> use of <code>union</code> I regularly come across is <strong>aliasing</strong>.</p>\n<p>Consider the following:</p>\n<pre><code>union Vector3f\n{\n  struct{ float x,y,z ; } ;\n  float elts[3];\n}\n</code></pre>\n<p>What does this do?  It allows clean, neat access of a <code>Vector3f vec;</code>'s members by <em>either</em> name: </p>\n<pre><code>vec.x=vec.y=vec.z=1.f ;\n</code></pre>\n<p>or by integer access into the array</p>\n<pre><code>for( int i = 0 ; i &lt; 3 ; i++ )\n  vec.elts[i]=1.f;\n</code></pre>\n<p>In some cases, accessing by name is the clearest thing you can do.  In other cases, especially when the axis is chosen programmatically, the easier thing to do is to access the axis by numerical index - 0 for x, 1 for y, and 2 for z.</p>\n", "CreationDate": "2013-08-11T22:43:16.527", "ParentId": "2310483", "Id": "18177444", "LastActivityDate": "2013-08-11T22:43:16.527", "PostTypeId": "2", "Score": "12", "OwnerUserId": "111307"}, "8909213": {"LastActivityDate": "2012-01-18T11:28:43.283", "CommentCount": "0", "Body": "<p>The behaviour may be undefined, but that just means there isn't a \"standard\". All decent compilers offer <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.71%29.aspx\" rel=\"nofollow\">#pragmas</a> to control packing and alignment, but may have different defaults. The defaults will also change depending on the optimisation settings used.</p>\n<p>Also, unions are not <em>just</em> for saving space. They can help modern compilers with type punning. If you <code>reinterpret_cast&lt;&gt;</code> everything the compiler can't make assumptions about what you are doing. It may have to throw away what it knows about your type and start again (forcing a write back to memory, which is very inefficient these days compared to CPU clock speed).</p>\n", "CreationDate": "2012-01-18T11:21:31.557", "LastEditDate": "2012-01-18T11:28:43.283", "ParentId": "2310483", "Id": "8909213", "LastEditorUserId": "3233", "PostTypeId": "2", "Score": "3", "OwnerUserId": "3233"}, "2310483": {"CreationDate": "2010-02-22T11:17:19.760", "ViewCount": "64311", "FavoriteCount": "82", "Id": "2310483", "AcceptedAnswerId": "2313676", "Score": "176", "Title": "Purpose of Unions in C and C++", "LastEditorUserId": "-1", "CommentCount": "7", "Body": "<p>I have used unions earlier comfortably; today I was alarmed when I read <a href=\"https://stackoverflow.com/questions/1812348/a-question-about-union-in-c\">this post</a> and came to know that this code </p>\n<pre><code>union ARGB\n{\n    uint32_t colour;\n\n    struct componentsTag\n    {\n        uint8_t b;\n        uint8_t g;\n        uint8_t r;\n        uint8_t a;\n    } components;\n\n} pixel;\n\npixel.colour = 0xff040201;  // ARGB::colour is the active member from now on\n\n// somewhere down the line, without any edit to pixel\n\nif(pixel.components.a)      // accessing the non-active member ARGB::components\n</code></pre>\n<p>is actually undefined behaviour I.e. reading from a member of the union other than the one recently written to leads to undefined behaviour. If this isn't the intended usage of unions, what is? Can some one please explain it elaborately?</p>\n<p><strong>Update:</strong></p>\n<p>I wanted to clarify a few things in hindsight.</p>\n<ul>\n<li>The answer to the question isn't the same for C and C++; my ignorant younger self tagged it as both C and C++.</li>\n<li>After scouring through C++11's standard I couldn't conclusively say that it calls out accessing/inspecting a non-active union member is undefined/unspecified/implementation-defined. All I could find was \u00a79.5/1:\n\n<blockquote>\n<p id=\"so_2310483_2310483_0\">If a standard-layout union contains several standard-layout structs that share a common initial sequence, and if an object of this standard-layout union type contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of standard-layout struct members. \u00a79.2/19: Two standard-layout structs share a common initial sequence if corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.</p>\n</blockquote></li>\n<li>While in C, (<a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_283.htm\" rel=\"noreferrer\">C99 TC3 - DR 283</a> onwards) it's legal to do so (<a href=\"https://stackoverflow.com/questions/2310483/purpose-of-unions-in-c-and-c#comment26826326_2313676\">thanks to Pascal Cuoq</a> for bringing this up). However, attempting to do <em>it can still lead to undefined behavior</em>, if the value read happens to be invalid (so called \"trap representation\") for the type it is read through. Otherwise, the value read is implementation defined.</li>\n<li><p>C89/90 called this out under unspecified behavior (Annex J) and K&amp;R's book says it's implementation defined. Quote from K&amp;R:</p>\n<blockquote>\n<p id=\"so_2310483_2310483_1\">This is the purpose of a union - a single variable that can legitimately hold any of one of several types. [...] so long as the usage is consistent: the type retrieved must be the type most recently stored. It is the programmer's responsibility to keep track of which type is currently stored in a union; the results are implementation-dependent if something is stored as one type and extracted as another.</p>\n</blockquote></li>\n<li><p>Extract from Stroustrup's TC++PL (emphasis mine)</p>\n<blockquote>\n<p id=\"so_2310483_2310483_2\">Use of unions can be essential for compatness of data [...] <em>sometimes misused for \"type conversion</em>\".</p>\n</blockquote></li>\n</ul>\n<p><em>Above all, this question (whose title remains unchanged since my ask) was posed with an intention of understanding the purpose of unions AND not on what the standard allows</em> E.g. Using inheritance for code reuse is, of course, allowed by the C++ standard, but <a href=\"https://isocpp.org/wiki/faq/objective-c#objective-c-and-inherit\" rel=\"noreferrer\">it wasn't the purpose or the original intention of introducing inheritance as a C++ language feature</a>. This is the reason Andrey's answer continues to remain as the accepted one.</p>\n", "Tags": "<c++><c><unions><type-punning>", "LastEditDate": "2017-05-23T12:25:51.473", "LastActivityDate": "2017-11-10T12:45:54.497", "PostTypeId": "1", "AnswerCount": "14", "OwnerUserId": "183120"}, "2313601": {"LastActivityDate": "2010-02-22T19:48:37.277", "CommentCount": "0", "Body": "<p>For one more example of the actual use of unions, the CORBA framework serializes objects using the tagged union approach. All user-defined classes are members of one (huge) union, and an <a href=\"http://en.wikipedia.org/wiki/Discriminator\" rel=\"nofollow noreferrer\">integer identifier</a> tells the demarshaller how to interpret the union.</p>\n", "CreationDate": "2010-02-22T19:42:18.473", "LastEditDate": "2010-02-22T19:48:37.277", "ParentId": "2310483", "Id": "2313601", "LastEditorUserId": "273767", "PostTypeId": "2", "Score": "4", "OwnerUserId": "273767"}, "2310732": {"CommentCount": "3", "Body": "<p>In C it was a nice way to implement something like an variant.</p>\n<pre><code>enum possibleTypes{\n  eInt,\n  eDouble,\n  eChar\n}\n\n\nstruct Value{\n\n    union Value {\n      int iVal_;\n      double dval;\n      char cVal;\n    } value_;\n    possibleTypes discriminator_;\n} \n\nswitch(val.discriminator_)\n{\n  case eInt: val.value_.iVal_; break;\n</code></pre>\n<p>In times of litlle memory this structure is using less memory than a struct that has all the member.</p>\n<p>By the way C provides</p>\n<pre><code>    typedef struct {\n      unsigned int mantissa_low:32;      //mantissa\n      unsigned int mantissa_high:20;\n      unsigned int exponent:11;         //exponent\n      unsigned int sign:1;\n    } realVal;\n</code></pre>\n<p>to access bit values.</p>\n", "CreationDate": "2010-02-22T12:10:35.930", "ParentId": "2310483", "Id": "2310732", "LastActivityDate": "2010-02-22T12:10:35.930", "PostTypeId": "2", "Score": "6", "OwnerUserId": "101635"}, "2311008": {"CommentCount": "0", "Body": "<p>In C++, <a href=\"http://www.boost.org/doc/libs/1_42_0/doc/html/variant.html\" rel=\"nofollow noreferrer\">Boost Variant</a> implement a safe version of the union, designed to prevent undefined behavior as much as possible.</p>\n<p>Its performances are identical to the <code>enum + union</code> construct (stack allocated too etc) but it uses a template list of types instead of the <code>enum</code> :)</p>\n", "CreationDate": "2010-02-22T13:09:57.743", "ParentId": "2310483", "Id": "2311008", "LastActivityDate": "2010-02-22T13:09:57.743", "PostTypeId": "2", "Score": "4", "OwnerUserId": "147192"}, "39621823": {"CommentCount": "3", "Body": "<p>In the C language as it was documented in 1974, all structure members shared a common namespace, and the meaning of \"ptr-&gt;member\" was <em>defined</em> as adding the\nmember's displacement to \"ptr\" and accessing the resulting address using the\nmember's type.  This design made it possible to use the same ptr with member\nnames taken from different structure definitions but with the same offset;\nprogrammers used that ability for a variety of purposes.</p>\n<p>When structure members were assigned their own namespaces, it became impossible\nto declare two structure members with the same displacement.  Adding unions to\nthe language made it possible to achieve the same semantics that had been\navailable in earlier versions of the language (though the inability to have\nnames exported to an enclosing context may have still necessitated using a\nfind/replace to replace foo-&gt;member into foo-&gt;type1.member).  What was\nimportant was not so much that the people who added unions have any particular\ntarget usage in mind, but rather that they provide a means by which programmers\nwho had relied upon the earlier semantics, <em>for whatever purpose</em>, should still\nbe able to achieve the same semantics even if they had to use a different\nsyntax to do it.</p>\n", "CreationDate": "2016-09-21T16:24:32.927", "ParentId": "2310483", "Id": "39621823", "LastActivityDate": "2016-09-21T16:24:32.927", "PostTypeId": "2", "Score": "3", "OwnerUserId": "363751"}, "2310632": {"CommentCount": "1", "Body": "<p>Technically it's undefined, but in reality most (all?) compilers treat it exactly the same as using a <code>reinterpret_cast</code> from one type to the other, the result of which is implementation defined. I wouldn't lose sleep over your current code.</p>\n", "CreationDate": "2010-02-22T11:49:28.527", "ParentId": "2310483", "Id": "2310632", "LastActivityDate": "2010-02-22T11:49:28.527", "PostTypeId": "2", "Score": "4", "OwnerUserId": "59379"}, "2310515": {"CommentCount": "4", "Body": "<p>You could use unions to create structs like the following, which contains a field that tells us which component of the union is actually used:</p>\n<pre><code>struct VAROBJECT\n{\n    enum o_t { Int, Double, String } objectType;\n\n    union\n    {\n        int intValue;\n        double dblValue;\n        char *strValue;\n    } value;\n} object;\n</code></pre>\n", "CreationDate": "2010-02-22T11:24:30.153", "ParentId": "2310483", "Id": "2310515", "LastActivityDate": "2010-02-22T11:24:30.153", "PostTypeId": "2", "Score": "31", "OwnerUserId": "65464"}, "bq_ids": {"n4140": {"so_2310483_2310483_0": {"length": 44, "quality": 0.8461538461538461, "section_id": 5878}}, "n3337": {"so_2310483_2310483_0": {"length": 44, "quality": 0.8461538461538461, "section_id": 5649}}}, "2310534": {"LastActivityDate": "2010-02-22T22:46:21.010", "CommentCount": "12", "Body": "<p>The behavior is undefined from the language point of view. Consider that different platforms can have different constraints in memory alignment and endianness. The code in a big endian versus a little endian machine will update the values in the struct differently. Fixing the behavior in the language would require all implementations to use the same endianness (and memory alignment constraints...) limiting use.</p>\n<p>If you are using C++ (you are using two tags) and you really care about portability, then you can just use the struct and provide a setter that takes the <code>uint32_t</code> and sets the fields appropriately through bitmask operations. The same can be done in C with a function.</p>\n<p><strong>Edit</strong>: I was expecting AProgrammer to write down an answer to vote and close this one. As some comments have pointed out, endianness is dealt in other parts of the standard by letting each implementation decide what to do, and alignment and padding can also be handled differently. Now, the strict aliasing rules that AProgrammer implicitly refers to are a important point here. The compiler is allowed to make assumptions on the modification (or lack of modification) of variables. In the case of the union, the compiler could reorder instructions and move the read of each color component over the write to the colour variable.</p>\n", "CreationDate": "2010-02-22T11:28:27.810", "LastEditDate": "2010-02-22T22:46:21.010", "ParentId": "2310483", "Id": "2310534", "LastEditorUserId": "36565", "PostTypeId": "2", "Score": "33", "OwnerUserId": "36565"}, "2313676": {"LastActivityDate": "2017-03-22T01:31:30.247", "CommentCount": "27", "Body": "<p>The purpose of unions is rather obvious, but for some reason people miss it quite often.  </p>\n<p><strong>The purpose of union  is <em>to save memory</em> by using the same memory region for storing different objects at different times.</strong> That's it.</p>\n<p>It is like a room in a hotel. Different people live in it for non-overlapping periods of time. These people never meet, and generally don't know anything about each other. By properly managing the time-sharing of the rooms (i.e. by making sure different people don't get assigned to one room at the same time), a relatively small hotel can provide accomodations to a relatively large number of people, which is what hotels are for.</p>\n<p>That's exactly what union does. If you know that several objects in your program hold values with non-overlapping value-lifetimes, then you can \"merge\" these objects into a union and thus save memory. Just like a hotel room has at most one \"active\" tenant at each moment of time, a union has at most one \"active\" member at each moment of program time. Only the \"active\" member can be read. By writing into other member you switch the \"active\" status to that other member.</p>\n<p>For some reason, this original purpose of the union got \"overriden\" with something completely different: writing one member of a union and then inspecting it through another member. This kind of memory reinterpretation (aka \"type punning\") is <strike>not a valid use of unions. It generally leads to undefined behavior</strike> is decribed as producing implemenation-defined behavior in C89/90.</p>\n<p><strong>EDIT:</strong> Using unions for the purposes of type punning (i.e. writing one member and then reading another) was given a more detailed definition in one of the Technical Corrigendums to C99 standard (see <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_257.htm\" rel=\"noreferrer\">DR#257</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_283.htm\" rel=\"noreferrer\">DR#283</a>). However, keep in mind that formally this does not protect you from running into undefined behavior by attempting to read a trap representation.</p>\n", "CreationDate": "2010-02-22T19:52:02.693", "LastEditDate": "2017-03-22T01:31:30.247", "ParentId": "2310483", "Id": "2313676", "LastEditorUserId": "187690", "PostTypeId": "2", "Score": "269", "OwnerUserId": "187690"}});