post_cb({"33732772": {"Id": "33732772", "PostTypeId": "2", "Body": "C++11 \u00a73.9.1/4, full quote:\n\n<blockquote>\n<p id=\"so_33732489_33732772_0\"><strong>\u201d</strong> Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number\n  of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>Apart from the slightly misleading wording about \u201cdeclared <code>unsigned</code>\u201d this might seem to apply that every arithmetic expression that involve only argument of some given unsigned type, will yield a result modulo 2<sup><em>n</em></sup> for that type.</p>\n<p>However, there are no arithmetic expressions at all for unsigned types of lower conversion rank than <code>int</code>: all arguments in an apparent such expression are converted up to <sup>(1)</sup>at least <code>int</code>, or depending on the number ranges of the C++ implementation, up to <code>unsigned int</code>.</p>\n<p>As a result, <code>a*b</code> where <code>a</code> and <code>b</code> are <code>unsigned short</code> values, <sup>(2)</sup>can have formally Undefined Behavior. Because it's not an <code>unsigned short</code> expression. It's (in practice) an <code>int</code> expression.</p>\n<p>That said, with a reasonable compiler that doesn't introduce special casing where it notices formal UB, and with in-practice 8 bit bytes and <code>unsigned short</code> max value that is representable by <code>int</code>, and common two's complement signed integer representation, the result, when converted back down to <code>unsigned short</code>, will be <em>as if</em> it was modular arithmetic in the range of <code>unsigned short</code>. That's because two's complement, at the machine code level, is just modular arithmetic with a range centered on 0.</p>\n<hr>\n<p><sup>\n<sup>(1)</sup> In practice one will usually be using an 8 bits-per-byte implementation where the maximum value of <code>unsigned short</code> fits well within the <code>int</code> range, so in practice we're talking about a conversion up to <code>int</code>.<br>\n<sup>(2)</sup> E.g., for 16-bit <code>unsigned short</code> and 32-bit <code>int</code>, (2<sup>16</sup>\u22121)<sup>2</sup> = 2<sup>32</sup>\u22122\u00d72<sup>16</sup>+1 &gt; 2<sup>31</sup>\u22121, where the last value is the maximum positive <code>int</code> value.\n</br></sup></p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2015-11-16T10:22:44.030", "Score": "7", "CreationDate": "2015-11-16T10:09:03.647", "ParentId": "33732489", "CommentCount": "9", "OwnerUserId": "464581", "LastEditDate": "2015-11-16T10:22:44.030"}, "33732752": {"Id": "33732752", "PostTypeId": "2", "Body": "<p>When you multiply <code>unsigned short * unsigned short</code> then there is an <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">implicit conversion</a> and the value is casted to <code>int</code> in C++11. The <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast#Numeric_promotions\" rel=\"nofollow\">documentation</a> says:</p>\n<blockquote>\n<p id=\"so_33732489_33732752_0\">Prvalues of small integral types (such as char) may be converted to\n  prvalues of larger integral types (such as int). In particular,\n  arithmetic operators <strong>do not accept types smaller than int</strong> as arguments</p>\n</blockquote>\n<p>So it will result in an Undefined behavior.</p>\n", "LastActivityDate": "2015-11-16T10:08:10.393", "CommentCount": "0", "CreationDate": "2015-11-16T10:08:10.393", "ParentId": "33732489", "Score": "3", "OwnerUserId": "1501794"}, "bq_ids": {"n4140": {"so_33732489_33732772_0": {"length": 14, "quality": 0.875, "section_id": 7213}}, "n3337": {"so_33732489_33732772_0": {"length": 16, "quality": 1.0, "section_id": 6957}}, "n4659": {"so_33732489_33732772_0": {"length": 14, "quality": 0.875, "section_id": 8722}}}, "33732489": {"ViewCount": "545", "Body": "<p>As a follow-up to \"<a href=\"https://stackoverflow.com/questions/33732041/why-static-castunsigned-intushrt-maxushrt-max-yields-correct-value\">https://stackoverflow.com/questions/33732041/why-static-castunsigned-intushrt-maxushrt-max-yields-correct-value</a>\"</p>\n<p>I was asking myself if promoting all types (except some exceptions) with a lower rank than <code>int</code> to <code>int</code> to perform arithmetic operations might cause UB in some cases.</p>\n<p>e.g.:</p>\n<pre><code>unsigned short a = 0xFFFF;\nunsigned short b = a*a;\n</code></pre>\n<p>As unsigned short is promoted to <code>int</code> for arithmetic operations this would result in:</p>\n<pre><code>unsigned short a = 0xFFFF;\nunsigned short b = (int)a*(int)a;\n</code></pre>\n<p>As <code>(int)0xFFFF*(int)0xFFFF</code> causes an overflow, and overflow of signed types is UB: <strong>Can multiplying two unsigned shorts <code>x,y</code> cause undefined behaviour in the case that <code>x*y &gt; INT_MAX</code></strong></p>\n<hr>\n<p><strong>UPDATE</strong>: </p>\n<p>The question specifically aims at the case that <code>int</code> is 32-bit and <code>short</code> is 16-bit. </p>\n</hr>", "AcceptedAnswerId": "33732772", "Title": "Does multiplying unsigned short cause undefined behaviour?", "CreationDate": "2015-11-16T09:53:45.753", "Id": "33732489", "CommentCount": "4", "LastEditDate": "2017-05-23T12:08:56.267", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-16T14:00:01.523", "Score": "5", "OwnerUserId": "4181011", "Tags": "<c++><c++11><types><casting><integer-promotion>", "AnswerCount": "2"}});