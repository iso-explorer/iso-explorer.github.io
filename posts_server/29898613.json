post_cb({"29899468": {"Id": "29899468", "PostTypeId": "2", "Body": "\n<blockquote>\n<p id=\"so_29898613_29899468_0\">Is it right, that if <code>ClassA</code> has a constructor which has a parameter of type <code>ClassB</code>, it will be called in this case?</p>\n</blockquote>\n<p>Yes, constructors are considered for implicit type conversions:</p>\n<blockquote>\n<p id=\"so_29898613_29899468_1\"><strong>Type conversions of class objects can be specified by constructors</strong> and by conversion functions. These\n  conversions are called user-defined conversions and are used for implicit type conversions (Clause 4), for\n  initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n</blockquote>\n<p>A constructor with the signature <code>ClassA::ClassA(ClassB)</code> is called a <em>converting-constructor</em>. During a function call such as the assignment, constructors and user-defined conversion operators are compiled into an overload set and the best one is chosen for the conversion.</p>\n<p>If a constructor is chosen: If the source type is a by-value type, it creates a prvalue of the type of the source type (<code>ClassA</code>) initialized with the type of the destination type (<code>ClassB</code>), and that is used to initialize the parameter. If the source type is a reference, <a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization\" rel=\"nofollow\">reference-initialization rules</a> are used.</p>\n<hr>\n<p>The assignment operators are implicitly-generated in <code>ClassA</code> (assuming they haven't been overriden). They are:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>ClassA&amp; operator=(ClassA const&amp;);\nClassA&amp; operator=(ClassA      &amp;&amp;);\n</code></pre>\n<p>An implicit-conversion sequence can choose either a constructor or conversion function to convert from <code>ClassB -&gt; ClassA const&amp;</code> or <code>ClassB -&gt; ClassA&amp;&amp;</code>.</p>\n<p>However, in this case, going by your scenario, the conversion would not be able to succeed as it would be ambiguous. Consider:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>struct B { operator struct A(); };\n\nstruct A {\n    A() = default;\n    A(B) {}\n};\n\nB::operator A() { return A(); }\n\nint main() \n{\n    A a; B b;\n    a = b; // Error! Ambiguous conversion\n}\n</code></pre>\n<p>Both <code>A::A(B)</code> and <code>B::operator A()</code> are both viable conversion functions to use for the conversion. As such, the conversion is ambiguous and we are given a compile error.</p>\n<blockquote>\n<p id=\"so_29898613_29899468_2\">User-defined conversions are applied only where they are unambiguous (10.2, 12.3.2).</p>\n</blockquote>\n<p>If we change the signature of the converting-constructor in class <code>A</code> to <code>A::A(B const&amp;)</code>, then the conversion operator in <code>B</code> will be used because the <code>A</code>'s constructor requires a qualification-conversion (addition of <code>const</code>).</p>\n<p>There is a thread on <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator\" rel=\"nofollow\">cppreference</a> where you can learn more.</p>\n</hr>", "LastEditorUserId": "701092", "LastActivityDate": "2015-04-27T15:28:39.860", "Score": "3", "CreationDate": "2015-04-27T15:10:15.840", "ParentId": "29898613", "CommentCount": "0", "OwnerUserId": "701092", "LastEditDate": "2015-04-27T15:28:39.860"}, "bq_ids": {"n4140": {"so_29898613_29899468_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 383}, "so_29898613_29899468_2": {"length": 6, "quality": 0.75, "section_id": 384}}, "n3337": {"so_29898613_29899468_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 374}, "so_29898613_29899468_2": {"length": 6, "quality": 0.75, "section_id": 375}, "so_29898613_29899468_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 472}}, "n4659": {"so_29898613_29899468_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 400}, "so_29898613_29899468_2": {"length": 6, "quality": 0.75, "section_id": 401}}}, "29898613": {"ViewCount": "141", "Body": "<p>Consider this case:</p>\n<pre><code>ClassA obA;\nClassB obB;\n\nobA = obB;\n</code></pre>\n<p>Is it right, that if <code>ClassA</code> has a constructor which has a parameter of type <code>ClassB</code>, it will be called in this case?</p>\n<p>If there is an overloaded casting operator in <code>ClassB</code> - which converts <code>ClassB</code> object to <code>ClassA</code> object, the operator method will be called. If there is corresponding constructor and overloaded casting operator which one will be called? Where can I read about it?</p>\n", "AcceptedAnswerId": "29899468", "Title": "Implicit casting C++", "CreationDate": "2015-04-27T14:31:18.527", "Id": "29898613", "CommentCount": "3", "LastEditDate": "2015-04-27T14:41:34.487", "PostTypeId": "1", "LastEditorUserId": "3688510", "LastActivityDate": "2015-04-27T15:28:39.860", "Score": "3", "OwnerUserId": "3688510", "Tags": "<c++><implicit-cast>", "AnswerCount": "2"}, "29898766": {"Id": "29898766", "PostTypeId": "2", "Body": "<p>This code:</p>\n<pre><code>ClassA obA;\nClassB obB;\n\nobA = obB;\n</code></pre>\n<p>is not what you think it is <strong>(*)</strong>. This code:</p>\n<pre><code>ClassB obB;\nClassA  obA = obB;\n</code></pre>\n<p>will work (as provided) if:</p>\n<p><strong>1.</strong> <code>ClassA</code> has constructor, that accepts <code>ClassB</code> as parameter:</p>\n<pre><code>class ClassA\n{\npublic:\n    ClassA(const ClassB&amp; b)\n    {\n        //construct *this from b\n    }\n};\n</code></pre>\n<p><strong>2.</strong> <code>ClassB</code> has defined conversion-to-type operator:</p>\n<pre><code>class ClassB\n{\npublic:\n    operator ClassA() const\n    {\n        //construct ClassA from *this\n    }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_29898613_29898766_0\">If there is an overloaded casting operator in ClassA which has a parameter of type ClassB [...].</p>\n</blockquote>\n<p>You meant <strong>constructor</strong>, not <strong>casting operator</strong>, right? You try to convert <code>ClassA</code> to <code>ClassB</code>, so conversion operators from <code>ClassA</code> are irrelevant in this case.</p>\n<hr>\n<p><strong>(*)</strong> You assign <code>obB</code> to <code>obA</code> after <code>obA</code>'s construction, so in your case only second point is applicable. You can also make it work by adding assignment operator:</p>\n<p><strong>3.</strong></p>\n<pre><code>class ClassA\n{\npublic:\n    ClassA&amp; operator=(const ClassB&amp; b)\n    {\n        //assign b to *this\n    }\n};\n</code></pre>\n<p>which would be called in your case.</p>\n</hr>", "LastEditorUserId": "2812864", "LastActivityDate": "2015-04-27T14:42:49.107", "Score": "3", "CreationDate": "2015-04-27T14:37:36.340", "ParentId": "29898613", "CommentCount": "2", "OwnerUserId": "2812864", "LastEditDate": "2015-04-27T14:42:49.107"}});