post_cb({"9057613": {"CommentCount": "0", "AcceptedAnswerId": "9057653", "CreationDate": "2012-01-29T23:07:15.550", "LastActivityDate": "2012-01-30T01:09:09.940", "PostTypeId": "1", "ViewCount": "1047", "FavoriteCount": "1", "Title": "What happen when the constructor of a static variable in a function terminates unusually?", "Id": "9057613", "Score": "3", "Body": "<p>I have a function that can be reduced to this:</p>\n<pre><code>void f() {\n    static MyObject o(\"hello\");\n\n    DoSomethingWith(o);\n}\n</code></pre>\n<p>This function is called across a C API boundary, so like a good boy, I use <code>try</code> to catch any exceptions that are thrown before they cross the boundary and screw things up:</p>\n<pre><code>void f() {\n    try {\n        static MyObject o(\"hello\");\n\n        DoSomethingWith(o);\n    } catch (const MyObjectException&amp; e) {\n        Message(\"Constructor of o failed\");\n    }\n}\n</code></pre>\n<p>This function is called the first time and I get the message <code>\"Constructor of o failed\"</code>. However, later, the function is called again, and I get the message again. I get the message as many times as <code>f</code> is called. I am using Visual C++ so this tells me what MSVC++ does, but not what should be done.</p>\n<p>My question is, what should happen when the constructor of a <code>static</code> function variable terminates unusually (by <code>throw</code>ing, a <code>longjmp</code> out of the constructor, termination of the thread that it's in, etc)? Also what should happen with any other <code>static</code> variables declared before and after it? I would appreciate any relevant quotes from the standard as well.</p>\n", "Tags": "<c++><exception><static><initialization>", "OwnerUserId": "726361", "AnswerCount": "3"}, "9057644": {"ParentId": "9057613", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_9057613_9057644_0\">Q: what should happen when the constructor of a static function variable terminates unusually [...] ?</p>\n<p id=\"so_9057613_9057644_1\">A: <code>\u00a76.7 [stmt.dcl] p4</code><br>\n  [...] Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration.</br></p>\n</blockquote>\n<p>So the initialization of <code>o</code> will be tried again if it exits by throwing an exception. <strike>I think the same applies to any kind of abnormal exit from the initialization, though it's not explicitly stated. Brb, looking for more quotes.</strike></p>\n<p>Since I couldn't find <em>anything</em> related, I opened <a href=\"https://stackoverflow.com/q/9058206/500104\">a follow-up question</a>.</p>\n<blockquote>\n<p id=\"so_9057613_9057644_2\">Q: Also what should happen with any other static variables declared before and after it?</p>\n<p id=\"so_9057613_9057644_3\">A: Nothing, as long as neither the thread or the whole program terminate.</p>\n</blockquote>\n<p><code>\u00a73.6.3 [basic.start.term]</code></p>\n<blockquote>\n<p id=\"so_9057613_9057644_4\">Destructors (12.4) for initialized objects (that is, objects whose lifetime (3.8) has begun) with static storage duration are called as a result of returning from <code>main</code> and as a result of calling <code>std::exit</code> (18.5). Destructors for initialized objects with thread storage duration within a given thread are called as a result of returning from the initial function of that thread and as a result of that thread calling <code>std::exit</code>. The completions of the destructors for all initialized objects with thread storage duration within that thread are sequenced before the initiation of the destructors of any object with static storage duration.</p>\n</blockquote>\n<p><code>\u00a73.7.2 [basic.stc.thread]</code></p>\n<blockquote>\n<p id=\"so_9057613_9057644_5\">A variable with thread storage duration shall be initialized before its first odr-use (3.2) and, if constructed, shall be destroyed on thread exit.</p>\n</blockquote>\n", "OwnerUserId": "500104", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:28:30.040", "Id": "9057644", "Score": "1", "CreationDate": "2012-01-29T23:10:55.457", "LastActivityDate": "2012-01-30T01:09:09.940"}, "9057653": {"ParentId": "9057613", "CommentCount": "8", "Body": "<p>Section 6.7 (<code>[stmt.dcl]</code>) of the C++11 standard states that</p>\n<blockquote>\n<p id=\"so_9057613_9057653_0\">The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable, is performed before its block is first entered. An implementation is permitted to perform early initialization of other block-scope variables with static or\n  thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2).  Otherwise such a variable is initialized the first time control passes through its declaration; <strong>such a variable is considered initialized upon the completion of its initialization.  If the initialization exits by throwing an exception, the initialization\n  is not complete, so it will be tried again the next time control enters the declaration.</strong>   If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.\n  If control re-enters the declaration recursively while the variable is being\n  initialized, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "9057653", "Score": "5", "CreationDate": "2012-01-29T23:12:16.160", "LastActivityDate": "2012-01-29T23:12:16.160"}, "bq_ids": {"n4140": {"so_9057613_9057644_4": {"section_id": 7156, "quality": 0.9473684210526315, "length": 54}, "so_9057613_9057653_0": {"section_id": 3919, "quality": 0.9568965517241379, "length": 111}, "so_9057613_9057644_5": {"section_id": 7169, "quality": 1.0, "length": 13}, "so_9057613_9057644_1": {"section_id": 3919, "quality": 0.9696969696969697, "length": 32}}, "n3337": {"so_9057613_9057644_4": {"section_id": 6900, "quality": 0.9473684210526315, "length": 54}, "so_9057613_9057653_0": {"section_id": 3779, "quality": 0.9568965517241379, "length": 111}, "so_9057613_9057644_5": {"section_id": 6913, "quality": 1.0, "length": 13}, "so_9057613_9057644_1": {"section_id": 3779, "quality": 0.9696969696969697, "length": 32}}, "n4659": {"so_9057613_9057644_4": {"section_id": 8662, "quality": 0.631578947368421, "length": 36}, "so_9057613_9057653_0": {"section_id": 4805, "quality": 0.5258620689655172, "length": 61}, "so_9057613_9057644_5": {"section_id": 8677, "quality": 1.0, "length": 13}, "so_9057613_9057644_1": {"section_id": 4805, "quality": 0.8787878787878788, "length": 29}}}, "9057663": {"ParentId": "9057613", "CommentCount": "1", "Body": "<p>Redesign your program. Static variables will be attempted to be initialized until the initialization succeeds. If that pattern doesn't fit, you should find a better way to express your goal. Perhaps a static <code>unique_ptr</code> that you populate in a controlled environment? If you have a resource that you cannot reliably construct, you have to either relegate the construction into some other context where you can handle the error, or make your function depend only optionally on the resource (e.g. via a null pointer).</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "9057663", "Score": "-1", "CreationDate": "2012-01-29T23:13:21.457", "LastActivityDate": "2012-01-29T23:13:21.457"}});