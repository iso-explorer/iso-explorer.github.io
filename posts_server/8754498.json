post_cb({"8754525": {"Id": "8754525", "PostTypeId": "2", "Body": "<p>The free function is prefix as it lacks an int parameter.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Operators_in_C_and_C++\" rel=\"nofollow\">Helpful guide for operator signatures.</a></p>\n", "LastActivityDate": "2012-01-06T07:06:48.507", "CommentCount": "5", "CreationDate": "2012-01-06T07:06:48.507", "ParentId": "8754498", "Score": "0", "OwnerUserId": "964135"}, "8755054": {"Id": "8755054", "PostTypeId": "2", "Body": "<p>Global overloaded operator++ functions expect the explicit specification of all the arguments, so if the overloaded operator ++ is <strong>postfix</strong>, we are supposed to add one default int argument <em>(<a href=\"http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.4\" rel=\"nofollow\">to distinguish postfix version from prefix</a>)</em> in addition to the prerequisite one <em>(which determines the type on which the function needs to be applied)</em>.</p>\n<pre><code>unaryOperators operator++ (unaryOperators &amp;one, int dummy)\n{   \n    return one; \n}\n</code></pre>\n<p>In the case of <strong>prefix</strong> global overloaded operator++ functions, the only argument we need to specify is the prerequisite one <em>(which determines the type on which the function needs to be applied)</em>. </p>\n<pre><code>unaryOperators operator++ (unaryOperators &amp;one)\n{   \n    return one; \n}\n</code></pre>\n", "LastActivityDate": "2012-01-06T08:10:50.297", "CommentCount": "0", "CreationDate": "2012-01-06T08:10:50.297", "ParentId": "8754498", "Score": "1", "OwnerUserId": "462608"}, "8754529": {"Id": "8754529", "PostTypeId": "2", "Body": "<p>The canonical version of preincrement is:</p>\n<pre><code>T &amp;operator++(T &amp;)\n</code></pre>\n<p>That is, return the operand by reference. Postincrement takes an unused <code>int</code>, so the global <code>operator++</code> you defined is the preincrement operator.</p>\n", "LastActivityDate": "2012-01-06T07:07:04.413", "CommentCount": "2", "CreationDate": "2012-01-06T07:07:04.413", "ParentId": "8754498", "Score": "0", "OwnerUserId": "6210"}, "bq_ids": {"n4140": {"so_8754498_8754646_0": {"length": 54, "quality": 0.9152542372881356, "section_id": 665}}, "n3337": {"so_8754498_8754646_0": {"length": 57, "quality": 0.9661016949152542, "section_id": 655}}, "n4659": {"so_8754498_8754646_0": {"length": 54, "quality": 0.9152542372881356, "section_id": 693}}}, "8754530": {"Id": "8754530", "PostTypeId": "2", "Body": "<p>I think <a href=\"http://www.learncpp.com/cpp-tutorial/97-overloading-the-increment-and-decrement-operators/\" rel=\"nofollow\">this</a> will help you.</p>\n", "LastActivityDate": "2012-01-06T07:07:13.607", "CommentCount": "1", "CreationDate": "2012-01-06T07:07:13.607", "ParentId": "8754498", "Score": "2", "OwnerUserId": "987244"}, "8754830": {"Id": "8754830", "PostTypeId": "2", "Body": "<p>Every operator (that can be overloaded as a free function) takes one more argument when overloaded as a free function. The first argument corresponds to <code>*this</code> when overloaded as a member function.</p>\n<pre><code>bool AsMember::operator!() const;\nbool operator!(const AsFreeFunction&amp;);\n\nbool AsMember::operator==(const AsMember&amp; rhv) const;\nbool operator==(const AsFreeFunction&amp; lhv, const AsFreeFunction&amp; rhv);\n\netc.\n</code></pre>\n<p>Increment operator is no exception to this.</p>\n", "LastActivityDate": "2012-01-06T07:41:48.503", "CommentCount": "1", "CreationDate": "2012-01-06T07:41:48.503", "ParentId": "8754498", "Score": "2", "OwnerUserId": "155693"}, "8754498": {"ViewCount": "1007", "Body": "<p>Class declaration:</p>\n<pre><code>class unaryOperators \n{\n    public:\n        int i;\n\n        unaryOperators (int tempI = 0)\n        {\n            i = tempI;\n        }\n\n        unaryOperators operator++ (int);\n        unaryOperators operator++ ();\n};\n</code></pre>\n<p>Does this global definition correspond to postfix or prefix version of the overloaded operator++? Why?</p>\n<pre><code>unaryOperators operator++ (unaryOperators &amp;one)\n{   \n    return one; \n}\n</code></pre>\n", "AcceptedAnswerId": "8754646", "Title": "Overloading operator ++", "CreationDate": "2012-01-06T07:03:27.523", "Id": "8754498", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-01-06T09:01:10.863", "Score": "2", "OwnerUserId": "462608", "Tags": "<c++><operator-overloading>", "AnswerCount": "6"}, "8754646": {"Id": "8754646", "PostTypeId": "2", "Body": "<pre><code>unaryOperators&amp; operator++ (unaryOperators &amp;one)\n              ^^\n</code></pre>\n<p>is the non-member prefix unary increment operator.</p>\n<p>The non-member postfix unary increment operator takes an additional <code>int</code> as an policy enforcing parameter.</p>\n<pre><code>unaryOperators operator++ (unaryOperators &amp;one, int)\n</code></pre>\n<p><strong>Reference:</strong> </p>\n<p><strong>C++03 Standard 13.5.7 Increment and decrement [over.inc]</strong> </p>\n<blockquote>\n<p id=\"so_8754498_8754646_0\">The user-defined function called operator++ implements the prefix and postfix ++ operator. <strong>If this function is a member function with no parameters, or a non-member function with one parameter of class or enumeration type, it defines the prefix increment operator ++ for objects of that type. If the function is a member function with one parameter (<code>which shall be of type int</code>) or a non-member function with two parameters (<code>the second of which shall be of type int</code>), it defines the postfix increment operator ++ for objects of that type</strong>. When the postfix increment is called as a result of using the ++ operator, the int argument will have value zero.125)</p>\n</blockquote>\n<pre><code>[Example:\nclass X {\n   public:\n      X&amp; operator++(); // prefix ++a\n      X operator++(int); // postfix a++\n};\nclass Y { };\nY&amp; operator++(Y&amp;); // prefix ++b\nY operator++(Y&amp;, int); // postfix b++\n\nvoid f(X a, Y b) {\n++a; // a.operator++();\na++; // a.operator++(0);\n++b; // operator++(b);\nb++; // operator++(b, 0);\na.operator++(); // explicit call: like ++a;\na.operator++(0); // explicit call: like a++;\noperator++(b); //explicit call: like ++b;\noperator++(b, 0); // explicit call: like b++;\n}\n\u2014end example]\n</code></pre>\n", "LastEditorUserId": "452307", "LastActivityDate": "2012-01-06T09:01:10.863", "Score": "6", "CreationDate": "2012-01-06T07:19:40.857", "ParentId": "8754498", "CommentCount": "3", "OwnerUserId": "452307", "LastEditDate": "2012-01-06T09:01:10.863"}});