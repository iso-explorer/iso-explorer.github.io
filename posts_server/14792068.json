post_cb({"14792403": {"ParentId": "14792068", "CommentCount": "9", "Body": "<p>Although the definition does not directly state what type exactly <code>size_t</code> is, <strike>and does not even require a minimum size</strike>, it indirectly gives some good hints. A <code>size_t</code> must be able to contain the size in bytes of any object, in other words, it must be able to contain the size of the largest possible object.</p>\n<p>The largest possible object is an array (or structure) with a size equal to the entire available address space. It is not possible to reference a <em>larger</em> object in a meaningful manner, and apart from the availability of swap space there is no reason why it should need to be any <em>smaller</em>.</p>\n<p>Therefore, by the wording of the definition, <code>size_t</code> <strong>must</strong> be at least 32 bits on a 32 bit architecture, and at least 64 bits on a 64 bit system. It is of course possible for an implementation to choose a larger <code>size_t</code>, but this is not usually the case.</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "14792403", "Score": "0", "CreationDate": "2013-02-09T22:38:01.467", "LastActivityDate": "2013-02-09T22:38:01.467"}, "14792185": {"ParentId": "14792068", "CommentCount": "0", "Body": "<p>Such definitions are all implementation defined. I would use the sizeof(char *), or maybe sizeof(void *), if I needed a best guess size. The best this gives is the apparent word size software uses... what the hardware really has may be different (e.g., a 32-bit system may support 64-bit integers by software).</p>\n<p>Also if you are new to the C languages see stdint.h for all sorts of material on integer sizes.</p>\n", "OwnerUserId": "693294", "PostTypeId": "2", "Id": "14792185", "Score": "0", "CreationDate": "2013-02-09T22:12:53.363", "LastActivityDate": "2013-02-09T22:12:53.363"}, "14792087": {"ParentId": "14792068", "CommentCount": "20", "Body": "<p>In the C++ standard, [support.types] (18.2) /6: \"The type <code>size_t</code> is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object.\"</p>\n<p>This may or may not be the same as a \"word size\", whatever that means.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "14792087", "Score": "21", "CreationDate": "2013-02-09T22:01:48.663", "LastActivityDate": "2013-02-09T22:01:48.663"}, "14792097": {"ParentId": "14792068", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>No; <code>size_t</code> is not necessarily whatever you mean by 'the word size' of the machine that will run the code (in the case of cross-compilation) or that compiled the code (in the normal case where the code will run on the same type of machine that compiled the code).  It is an unsigned integer type big enough to hold the size (in bytes) of the largest object that the implementation can allocate.</p>\n<hr>\n<h2>Some history of <code>sizeof</code> and <code>size_t</code></h2>\n<p>I don't know when <code>size_t</code> was introduced exactly, but it was between 1979 and 1989.  The 1st Edition of K&amp;R The C Programming Language from 1978 has no mention of <code>size_t</code>. The 7th Edition Unix Programmer's Manual has no mention of <code>size_t</code> at all, and that dates from 1979. The book \"The UNIX Programming Environment\" by Kernighan and Pike from 1984 has no mention of <code>size_t</code> in the index (nor of <code>malloc()</code> or <code>free()</code>, somewhat to my surprise), but that is only indicative, not conclusive. The C89 standard certainly has <code>size_t</code>.</p>\n<p>The C99 Rationale documents some information about <code>sizeof()</code> and <code>size_t</code>:</p>\n<blockquote>\n<h3>6.5.3.4 The sizeof operator</h3>\n<p id=\"so_14792068_14792097_0\">It is fundamental to the correct usage of functions such as <code>malloc</code> and <code>fread</code> that\n  <code>sizeof(char)</code> be exactly one. In practice, this means that a byte in C terms is the smallest\n  unit of storage, even if this unit is 36 bits wide; and all objects are composed of an integer\n  number of these smallest units. Also applies if memory is bit addressable.\n  C89, like K&amp;R, defined the result of the <code>sizeof</code> operator to be a constant of an unsigned integer type. Common implementations, and common usage, have often assumed that the\n  resulting type is <code>int</code>. Old code that depends on this behavior has never been portable to\n  implementations that define the result to be a type other than <code>int</code>. The C89 Committee did not\n  feel it was proper to change the language to protect incorrect code.</p>\n<p id=\"so_14792068_14792097_1\">The type of <code>sizeof</code>, whatever it is, is published (in the library header <code>&lt;stddef.h&gt;</code>) as\n   <code>size_t</code>, since it is useful for the programmer to be able to refer to this type. This requirement\n  implicitly restricts <code>size_t</code> to be a synonym for an existing unsigned integer type. Note also\n  that, although <code>size_t</code> is an unsigned type, <code>sizeof</code> does not involve any arithmetic operations\n  or conversions that would result in modulus behavior if the size is too large to represent as a\n  <code>size_t</code>, thus quashing any notion that the largest declarable object might be too big to span even with an <code>unsigned long</code> in C89 or <code>uintmax_t</code> in C99. This also restricts the\n  maximum number of elements that may be declared in an array, since for any array <code>a</code> of <code>N</code>\n  elements,</p>\n<p id=\"so_14792068_14792097_2\"><code>N == sizeof(a)/sizeof(a[0])</code></p>\n<p id=\"so_14792068_14792097_3\">Thus <code>size_t</code> is also a convenient type for array sizes, and is so used in several library functions. [...]</p>\n<h3>7.17 Common definitions </h3>\n<p id=\"so_14792068_14792097_4\"><code>&lt;stddef.h&gt;</code> is a header invented to provide definitions of several types and macros used widely in conjunction with the library: <code>ptrdiff_t</code>, <code>size_t</code>, <code>wchar_t</code>, and <code>NULL</code>.\n  Including any header that references one of these macros will also define it, an exception to the\n  usual library rule that each macro or function belongs to exactly one header.</p>\n</blockquote>\n<p>Note that this specifically mentions that the <code>&lt;stddef.h&gt;</code> was invented by the C89 committee.  I've not found words that say that <code>size_t</code> was also invented by the C89 committee, but if it was not, it was a codification of a fairly recent development in C.</p>\n<hr>\n<p>In a comment to <a href=\"https://stackoverflow.com/users/131433/bmargulies\">bmargulies</a> <a href=\"https://stackoverflow.com/a/14792080/15168\">answer</a>, <a href=\"https://stackoverflow.com/users/1839777/vonbrand\">vonbrand</a> says that 'it [<code>size_t</code>] is certainly an ANSI-C-ism'.  I can very easily believe that it was an innovation with the original ANSI (ISO) C, though it is mildly odd that the rationale doesn't state that.</p>\n</hr></hr>", "OwnerUserId": "15168", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:06:49.553", "Id": "14792097", "Score": "12", "CreationDate": "2013-02-09T22:02:34.227", "LastActivityDate": "2013-02-12T00:08:34.373"}, "14792098": {"ParentId": "14792068", "CommentCount": "5", "Body": "<p>Not necessarily.  The C ISO spec (\u00a717.1/2) defines <code>size_t</code> as</p>\n<blockquote>\n<p id=\"so_14792068_14792098_0\">size_t, which is the unsigned integer type of the result of the <code>sizeof</code> operator</p>\n</blockquote>\n<p>In other words, <code>size_t</code> has to be large enough to hold the size of any expression that could be produced from <code>sizeof</code>.  This could be the machine word size, but it could be dramatically smaller (if, for example, the compiler limited the maximum size of arrays or objects) or dramatically larger (if the compiler were to let you create objects so huge that a single machine word could not store the size of that object).</p>\n<p>Hope this helps!</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "14792098", "Score": "3", "CreationDate": "2013-02-09T22:02:37.237", "LastActivityDate": "2013-02-09T22:02:37.237"}, "14792068": {"CommentCount": "7", "AcceptedAnswerId": "14792087", "PostTypeId": "1", "LastEditorUserId": "501557", "CreationDate": "2013-02-09T21:59:16.817", "LastActivityDate": "2013-02-12T00:08:34.373", "LastEditDate": "2013-02-09T22:03:22.540", "ViewCount": "2488", "FavoriteCount": "3", "Title": "Is size_t the word size?", "Id": "14792068", "Score": "29", "Body": "<p>Is <code>size_t</code> the word size of the machine that compiled the code? </p>\n<p>Parsing with g++, my compiler views <code>size_t</code> as an <code>long unsigned int</code>. Does the compiler internally choose the size of <code>size_t</code>, or is <code>size_t</code> actually typdefed inside some pre-processor macro in <code>stddef.h</code> to the word size before the compiler gets invoked? </p>\n<p>Or am I way off track?</p>\n", "Tags": "<c++><c><size-t>", "OwnerUserId": "1981808", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_14792068_14792098_0": {"section_id": 3291, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_14792068_14792098_0": {"section_id": 3358, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_14792068_14792098_0": {"section_id": 7797, "quality": 0.7142857142857143, "length": 5}}}, "14792080": {"ParentId": "14792068", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>size_t was, orignally, just a typedef in sys/types.h (traditionally on Unix/Linux). It was assumed to be 'big enough' for, say, the maximum size of a file, or the maximum allocation with malloc. However, over time, standard committees grabbed it, and so it wound up copied into many different header files, protected each time with its own #ifdef protection from multiple definition. On the other hand, the emergence of 64-bit systems with very big potential file sizes clouded its role. So it's a bit of a palimpset.</p>\n<p>Language standards now call it out as living in stddef.h. It has no necessary relationship to the hardware word size, and no compiler magic. See other answers with respect to what those standards say about how big it is.</p>\n", "OwnerUserId": "131433", "LastEditorUserId": "131433", "LastEditDate": "2013-02-09T22:16:21.030", "Id": "14792080", "Score": "2", "CreationDate": "2013-02-09T22:01:35.923", "LastActivityDate": "2013-02-09T22:16:21.030"}});