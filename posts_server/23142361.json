post_cb({"23142361": {"ViewCount": "163", "Body": "<p>While trying to formulate a C macro to ease the writing of non-const member functions calling const member functions with exact same logic (see Chapter 1, Item 3, \"Avoiding Duplication in const and Non-const Member Functions\" in <a href=\"http://rads.stackoverflow.com/amzn/click/0321334876\" rel=\"nofollow\" title=\"Effective C++\">Effective C++</a>), I believe I came across a <code>decltype()</code> bug in VS2013 Update 1.</p>\n<p>I wanted to use <code>decltype(*this)</code> to build a <code>static_cast&lt;decltype(*this) const&amp;&gt;(*this)</code> expression in the aforementioned macro to avoid having the macro call site pass any explicit type information. However, that latter expression doesn't appear to properly add const in some cases in VS2013.</p>\n<p>Here's a small block of code I was able to make repo the bug:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntemplate&lt;typename DatumT&gt;\nstruct DynamicArray\n{\n    DatumT* elements;\n    unsigned element_size;\n    int count;\n\n    inline const DatumT* operator [](int index) const\n    {\n        if (index &lt; 0 || index &gt;= count)\n            return nullptr;\n\n        return &amp;elements[index];\n    }\n\n    inline DatumT* operator [](int index)\n    {\n#if defined(MAKE_THIS_CODE_WORK)\n        DynamicArray const&amp; _this = static_cast&lt;decltype(*this) const&amp;&gt;(*this);\n        return const_cast&lt;DatumT*&gt;(_this[index]);\n#else\n        // warning C4717: 'DynamicArray&lt;int&gt;::operator[]' : recursive on all control paths, function will cause runtime stack overflow\n        return const_cast&lt;DatumT*&gt;(\n                static_cast&lt;decltype(*this) const&gt;(*this)\n                [index]\n            );\n#endif\n    }\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    DynamicArray&lt;int&gt; array = { new int[5], sizeof(int), 5 };\n    printf_s(\"%d\", *array[0]);\n    delete array.elements;\n\n    return 0;\n}\n</code></pre>\n<p>(may the first one to blab about not using std::vector be smitten)</p>\n<p>You can either compile the above code and see the warning yourself, or refer to my lone comment to see what VC++ would spew at you. You can then ! the <code>defined(MAKE_THIS_CODE_WORK)</code> expression to have VC++ compile the code as how I'm excepting the <code>#else</code> code to work.</p>\n<p>I don't have my trusty clang setup on this machine, but I was able to use GCC Explorer to see if clang complains (<a href=\"http://goo.gl/w997Hf\" rel=\"nofollow\">click to see/compile code</a>). Which it doesn't. However, g++ 4.8 will give you an <code>\u2018const\u2019 qualifiers cannot be applied to \u2018DynamicArray&amp;\u2019</code> error message using that same code. So perhaps g++ also has a bug?</p>\n<p>Referring to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf\" rel=\"nofollow\" title=\"decltype and auto\">decltype and auto</a> standards paper (albeit, it's almost 11 years old), the very bottom of page 6 says that <code>decltype(*this)</code> in a non-const member function should be <code>T&amp;</code>, so I'm pretty sure this should be legal...</p>\n<p>So am I wrong in trying to use decltype() on *this plus adding const to it? Or is this a bug in VS2013? And apparently g++ 4.8, but in a different manner.</p>\n<p><strong>edit</strong>: Thanks to Ben Voigt's response I was able to figure out how to craft a standalone C macro for what I'm desire to do.</p>\n<pre><code>// Cast [this] to a 'const this&amp;' so that a const member function can be invoked\n// [ret_type] is the return type of the member function. Usually there's a const return type, so we need to cast it to non-const too.\n// [...] the code that represents the member function (or operator) call\n#define CAST_THIS_NONCONST_MEMBER_FUNC(ret_type, ...)   \\\n    const_cast&lt;ret_type&gt;(                               \\\n        static_cast&lt;                                    \\\n            std::add_reference&lt;                         \\\n                std::add_const&lt;                         \\\n                    std::remove_reference&lt;              \\\n                        decltype(*this)                 \\\n                    &gt;::type                             \\\n                &gt;::type                                 \\\n            &gt;::type                                     \\\n        &gt;(*this)                                        \\\n        __VA_ARGS__                                     \\\n    )\n// We can now implement that operator[] like so:\nreturn CAST_THIS_NONCONST_MEMBER_FUNC(DatumT*, [index]);\n</code></pre>\n<p>The original desire was to hide this all in a macro, which is why I wasn't wanting to worry about creating typedefs or <code>this</code> aliases. It is still curious that clang in GCC Explorer didn't output a warning...though the output assembly does appear fishy.</p>\n", "AcceptedAnswerId": "23142429", "Title": "decltype(*this) bug in VS2013?", "CreationDate": "2014-04-17T19:58:58.367", "Id": "23142361", "CommentCount": "1", "LastEditDate": "2014-04-17T20:33:54.040", "PostTypeId": "1", "LastEditorUserId": "444977", "LastActivityDate": "2014-04-17T21:50:38.203", "Score": "0", "OwnerUserId": "444977", "Tags": "<gcc><c++11><visual-studio-2013><decltype>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23142361_23142429_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 3223}}, "n3337": {"so_23142361_23142429_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 3097}}, "n4659": {"so_23142361_23142429_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 3980}}}, "23142429": {"Id": "23142429", "PostTypeId": "2", "Body": "<p>You said yourself, <code>decltype (*this)</code> is <code>T&amp;</code>.  <code>decltype (*this) const &amp;</code> tries to form a reference to a reference (<code>T&amp; const &amp;</code>).  <code>decltype</code> triggers the reference collapsing rule 8.3.2p6.  But it doesn't collapse the way you'd like.</p>\n<p>You could say <code>decltype(this) const&amp;</code>, but that would be <code>T* const&amp;</code> -- a reference to a const pointer, not a pointer to a const object.  For the same reason, <code>decltype (*this) const</code> and <code>const decltype (*this)</code> don't form <code>const T&amp;</code>, but <code>(T&amp;) const</code>.  And top-level <code>const</code> on a reference is useless, since references already forbid rebinding.</p>\n<p>Perhaps you are looking for something more like</p>\n<pre><code>const typename remove_reference&lt;decltype(*this)&gt;::type &amp;\n</code></pre>\n<p>But note that you don't need the cast at all when adding <code>const</code>.  Instead of</p>\n<pre><code>DynamicArray const&amp; _this = static_cast&lt;decltype(*this) const&amp;&gt;(*this);\n</code></pre>\n<p>just say</p>\n<pre><code>DynamicArray const&amp; _this = *this;\n</code></pre>\n<p>These combine to</p>\n<pre><code>const typename std::remove_reference&lt;decltype(*this)&gt;::type &amp; this_ = *this;\n</code></pre>\n<p>Still, this is a stupid amount of code for a very simple and pervasive problem.  Just say:</p>\n<p><strong><code>const auto&amp; this_ = *this;</code></strong></p>\n<hr>\n<p>FYI here's the text of the reference collapsing rule:</p>\n<blockquote>\n<p id=\"so_23142361_23142429_0\">If a <em>typedef-name</em> (7.1.3, 14.1) or a <em>decltype-specifier</em> (7.1.6.2) denotes a type <code>TR</code> that is a reference to a type <code>T</code>, an attempt to create the type \"lvalue reference to <em>cv</em> <code>TR</code>\" creates the type \"lvalue reference to <code>T</code>\", while an attempt to create the type \"rvalue reference to <em>cv</em> <code>TR</code>\" creates the type <code>TR</code>.</p>\n</blockquote>\n<p><code>decltype(*this)</code> is our decltype-specifier which denotes <code>TR</code>, which is <code>DynamicArray&lt;DatumT&gt;&amp;</code>.  Here, <code>T</code> is <code>DynamicArray&lt;DatumT&gt;</code>.  The attempt <code>TR const&amp;</code> is the first case, attempt to create lvalue reference to (const) <code>TR</code>, and therefore the final result is <code>T&amp;</code>, not <code>const T&amp;</code>.  The cv-qualification is outside the innermost reference.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2014-04-17T20:21:52.870", "Score": "5", "CreationDate": "2014-04-17T20:03:07.250", "ParentId": "23142361", "CommentCount": "6", "OwnerUserId": "103167", "LastEditDate": "2014-04-17T20:21:52.870"}, "23143053": {"Id": "23143053", "PostTypeId": "2", "Body": "<p>With regard to your macro</p>\n<pre><code>// Cast [this] to a 'const this&amp;' so that a const member function can be invoked\n// [ret_type] is the return type of the member function. Usually there's a const return type, so we need to cast it to non-const too.\n// [...] the code that represents the member function (or operator) call\n#define CAST_THIS_NONCONST_MEMBER_FUNC(ret_type, ...)   \\\n    const_cast&lt;ret_type&gt;(                               \\\n        static_cast&lt;                                    \\\n            std::add_reference&lt;                         \\\n                std::add_const&lt;                         \\\n                    std::remove_reference&lt;              \\\n                        decltype(*this)                 \\\n                    &gt;::type                             \\\n                &gt;::type                                 \\\n            &gt;::type                                     \\\n        &gt;(*this)                                        \\\n        __VA_ARGS__                                     \\\n    )\n</code></pre>\n<p>It's much cleaner to do</p>\n<pre><code>// Cast [this] to a 'const this&amp;' so that a const member function can be invoked\ntemplate&lt;typename T&gt; const T&amp; deref_as_const(T* that) { return *that; }\n\n// [ret_type] is the return type of the member function. Usually there's a const return type, so we need to cast it to non-const too.\n// [...] the code that represents the member function (or operator) call\n#define CAST_THIS_NONCONST_MEMBER_FUNC(ret_type, ...)   \\\n    const_cast&lt;ret_type&gt;(deref_as_const(this)__VA_ARGS__)\n</code></pre>\n<p>It's shorter, self-contained, compatible with C++98 except for <code>__VA_ARGS__</code>, and avoids an unnecessary cast</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-04-17T21:50:38.203", "Score": "0", "CreationDate": "2014-04-17T20:41:38.950", "ParentId": "23142361", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2014-04-17T21:50:38.203"}});