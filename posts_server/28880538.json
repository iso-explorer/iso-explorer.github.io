post_cb({"bq_ids": {"n4140": {"so_28880538_28880915_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5423}}, "n3337": {"so_28880538_28880538_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 5214}, "so_28880538_28880915_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5218}}, "n4659": {"so_28880538_28880915_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6845}}}, "28880858": {"Id": "28880858", "PostTypeId": "2", "Body": "<p>constexpr does nothing but tells the compiler that the value is there in compile time, so you can use it as template argument (for example)</p>\n<pre><code>int a1 = 5;\nstd::array&lt;int, a1&gt; arr1; // error, a is variable\n\nconst int a2 = 5;\nstd::array&lt;int, a2&gt; arr2; // OK\n\nint f1() { return 3; }\nstd::array&lt;int, f1()&gt; arr3; // error, compiler doesn't know it is const 3\n\nconstexpr int f2() { return 3; }\nstd::array&lt;int, f2()&gt; arr4; // OK\n</code></pre>\n<p>Later you also can:</p>\n<pre><code>constexpr int f3() { return f1() + 1; } // error, f1 is not constexpr\n\nconstexpr int f4() { return f2() + 1; } // OK\nstd::array&lt;int, f4()&gt; arr5; // OK\n</code></pre>\n<p>Now about literal types limitation: the function arguments and result types should be literal types (<a href=\"https://stackoverflow.com/questions/18581443/need-clarification-on-definition-of-literal-type\">Need clarification on definition of literal type</a>), the very same limitation as template arguments apply (known in compile types).</p>\n<pre><code>constexpr std::string f5() { return \"hello\"; } // error, \n                   // std::string is not literal type\n\nconstexpr const std::string&amp; f6() { \n  static const std::string s = \"hello\";\n  return s;\n}\n\ntemplate&lt;const std::string&amp; s&gt; SomeClass { ... };\nSomeClass&lt;f6()&gt; someObject;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-05T19:27:28.513", "Score": "0", "CreationDate": "2015-03-05T14:56:46.500", "ParentId": "28880538", "CommentCount": "2", "OwnerUserId": "4634598", "LastEditDate": "2017-05-23T12:04:05.260"}, "28880915": {"Id": "28880915", "PostTypeId": "2", "Body": "<p>It's not contradictory. As well as mandating that the return type must be of \"literal type\", the draft standard states that a call to a <code>constexpr</code> function does not have to appear in a constant expression. From the C++11 draft standard:</p>\n<blockquote>\n<p id=\"so_28880538_28880915_0\">\u00a77.1.5/7 A call to a <code>constexpr</code> function produces the same result as\n  a call to a equivalent non-<code>constexpr</code>  function in all respects\n  except that a call to a <code>constexpr</code> function can appear in a constant\n  expression.</p>\n</blockquote>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2015-03-05T14:59:01.853", "Score": "6", "CreationDate": "2015-03-05T14:59:01.853", "ParentId": "28880538", "CommentCount": "0"}, "28880538": {"ViewCount": "1096", "Body": "<p>In C++ Primer, Fifth Edition, \u00a76.5.2:</p>\n<blockquote>\n<p id=\"so_28880538_28880538_0\">A <code>constexpr</code> function is defined like any other function but must meet certain restrictions: <strong>The return type and the type of each parameter in must be a literal type</strong> (\u00a72.4.4, p. 66), and the function body must contain exactly one return statement</p>\n</blockquote>\n<p>but another sentence in this chapter (page 239):</p>\n<blockquote>\n<p id=\"so_28880538_28880538_1\">A constexpr function is permitted to <strong>return a value that is not a constant</strong></p>\n<pre><code>// scale(arg) is a constant expression if arg is a constant expression\nconstexpr size_t scale(size_t cnt) { return new_sz() * cnt; }\n</code></pre>\n</blockquote>\n<p>Is it a contradictory summary? I am confused about it.<br>\nThe return type of <code>scale</code> is literal type?<br>\nupdate:\nwhat's the difference between literal type and constant ?</br></br></p>\n", "AcceptedAnswerId": "28880915", "Title": "I am confused about a constexpr function?", "CreationDate": "2015-03-05T14:42:59.383", "Id": "28880538", "CommentCount": "2", "LastEditDate": "2015-03-05T15:36:08.043", "PostTypeId": "1", "LastEditorUserId": "4358622", "LastActivityDate": "2015-03-06T19:38:36.003", "Score": "4", "OwnerUserId": "4358622", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "3"}, "28906349": {"Id": "28906349", "PostTypeId": "2", "Body": "<p>First of all what I believe the author meant was that a constexpr function does not have to result in a <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"noreferrer\">constant expression</a>, which is an expression that <em>can</em> be evaluated at compile time.</p>\n<p>A constexpr function will only yield a <em>constant expression</em> if the arguments to the function are also <em>constant expressions</em> and the comment right after says exactly that:</p>\n<pre><code>// scale(arg) is a constant expression if arg is a constant expression\n</code></pre>\n<p>and the examples that follow right after also demonstrate this behavior:</p>\n<pre><code>int arr[scale(2)]; // ok: scale(2) is a constant expression\nint i = 2; // i is not a constant expression\nint a2[scale(i)]; // error: scale(i) is not a constant expression\n</code></pre>\n<p>In C++(<em>as opposed to C99</em>) as array size must be a <em>constant expression</em> and so the last case is an error since the argument to <code>scale</code> is not a constant expression.</p>\n<p>This is different concept from the return type of the function, which must be a <a href=\"http://en.cppreference.com/w/cpp/concept/LiteralType\" rel=\"noreferrer\">literal type</a> which is any of the following:</p>\n<ul>\n<li>void(since c++14) (so that constexpr functions can return void)</li>\n<li>scalar type which includes Arithmetic types, enumeration types, pointer types, pointer to member types, std::nullptr_-\nt, and cv-qualified versions of these types)</li>\n<li>reference type</li>\n<li>an array of literal type</li>\n<li>class type that has all of the following properties: \n\n<ul>\n<li>has a trivial destructor,</li>\n<li>is either \n\n<ul>\n<li>an aggregate type</li>\n<li>a type with at least one constexpr (possibly template)    constructor that is not a copy or move constructor </li>\n</ul></li>\n<li>all non-static data members and base classes are of non-volatile literal types. </li>\n</ul></li>\n</ul>\n", "LastActivityDate": "2015-03-06T19:38:36.003", "CommentCount": "0", "CreationDate": "2015-03-06T19:38:36.003", "ParentId": "28880538", "Score": "8", "OwnerUserId": "1708801"}});