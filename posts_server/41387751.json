post_cb({"41387751": {"CommentCount": "3", "ViewCount": "217", "PostTypeId": "1", "LastEditorUserId": "4623526", "CreationDate": "2016-12-29T21:57:49.483", "LastActivityDate": "2016-12-29T22:35:09.057", "Title": "Is assignment to a std::vector element thread-safe?", "AcceptedAnswerId": "41387941", "LastEditDate": "2016-12-29T22:10:46.937", "Id": "41387751", "Score": "1", "Body": "<p>I have made a thread pool which writes to the same vector at the same time.  </p>\n<p>Is this implementation thread safe?</p>\n<p>If it is not, how should I fix it?</p>\n<pre><code>std::vector&lt;double&gt; global_var;\n\nvoid func1(int i)\n{\n    global_var[i]=some_computation(i /* only depends on i */);\n}\n\nvoid load_distribution()\n{\n    const int N_max=100;\n    global_var.assign(N_max,0.0);\n    std::vector&lt;std::thread&gt; th_pool;\n    for(long i=0;i&lt;N_max;i++)\n        th_pool.push_back(std::thread(func1,i));\n\n    for(std::thread&amp; tp : th_pool)\n        tp.join();\n}\n</code></pre>\n<hr>\n<p><strong>Update</strong></p>\n<p><code>global_var</code> will not be touched by any other part of the program before all threads terminated.</p>\n</hr>", "Tags": "<c++><multithreading><thread-safety><threadpool><stdvector>", "OwnerUserId": "4623526", "AnswerCount": "3"}, "41388133": {"ParentId": "41387751", "CommentCount": "0", "Body": "<p><a href=\"https://timsong-cpp.github.io/cppwp/container.requirements.dataraces\" rel=\"nofollow noreferrer\">[container.requirements.dataraces]/1-2</a>:</p>\n<blockquote>\n<p id=\"so_41387751_41388133_0\">1 For purposes of avoiding data races ([res.on.data.races]),\n  implementations shall consider the following functions to be <code>const</code>:\n  <code>begin</code>, <code>end</code>, <code>rbegin</code>, <code>rend</code>, <code>front</code>, <code>back</code>, <code>data</code>, [...], <code>at</code> and, except in associative or unordered\n  associative containers, <code>operator[]</code>.</p>\n<p id=\"so_41387751_41388133_1\">2 Notwithstanding ([res.on.data.races]), implementations are required\n  to avoid data races when the contents of the contained object in\n  different elements in the same container, excepting <code>vector&lt;bool&gt;</code>, are\n  modified concurrently.</p>\n</blockquote>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "41388133", "Score": "1", "CreationDate": "2016-12-29T22:35:09.057", "LastActivityDate": "2016-12-29T22:35:09.057"}, "41387941": {"ParentId": "41387751", "CommentCount": "7", "Body": "<p>Assuming your <em>global</em> vector is not modified by any other part of code, then your code is thread safe.</p>\n<p>Each thread is going to write (access) into a different cell of the vector, so there is no <em>\"dirty update\"</em> problem.</p>\n<p>Moreover the vector's type is a double, in a modern architecture is bigger than a WORD-size. So each array cell is not overlapped among others.</p>\n", "OwnerUserId": "6040181", "PostTypeId": "2", "Id": "41387941", "Score": "1", "CreationDate": "2016-12-29T22:15:54.440", "LastActivityDate": "2016-12-29T22:15:54.440"}, "bq_ids": {"n4140": {"so_41387751_41388133_1": {"section_id": 718, "quality": 0.9473684210526315, "length": 18}, "so_41387751_41388133_0": {"section_id": 717, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_41387751_41388133_1": {"section_id": 707, "quality": 0.8947368421052632, "length": 17}, "so_41387751_41388133_0": {"section_id": 706, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_41387751_41388133_1": {"section_id": 749, "quality": 0.9473684210526315, "length": 18}, "so_41387751_41388133_0": {"section_id": 748, "quality": 0.9130434782608695, "length": 21}}}, "41387823": {"ParentId": "41387751", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Generally, <code>std::vector</code> is not thread safe, but the above code will work because the backing array is preallocated with <code>assign()</code> method.</p>\n<p>As long as the writers don't cause reallocating the backing array, the code will work. The <code>assign()</code> method will preallocate enough space so it will not happen when the thread write to it.</p>\n", "OwnerUserId": "4787126", "LastEditorUserId": "4787126", "LastEditDate": "2016-12-29T22:07:25.370", "Id": "41387823", "Score": "-1", "CreationDate": "2016-12-29T22:04:35.353", "LastActivityDate": "2016-12-29T22:07:25.370"}});