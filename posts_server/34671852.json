post_cb({"bq_ids": {"n4140": {"so_34671852_34671852_5": {"length": 7, "quality": 1.0, "section_id": 7114}, "so_34671852_34671852_4": {"length": 12, "quality": 1.0, "section_id": 6991}, "so_34671852_34672033_1": {"length": 10, "quality": 1.0, "section_id": 367}, "so_34671852_34671852_7": {"length": 11, "quality": 1.0, "section_id": 7114}, "so_34671852_34671852_6": {"length": 7, "quality": 1.0, "section_id": 7114}, "so_34671852_34671852_3": {"length": 15, "quality": 1.0, "section_id": 6992}, "so_34671852_34671852_8": {"length": 5, "quality": 1.0, "section_id": 7114}, "so_34671852_34671852_1": {"length": 7, "quality": 0.7, "section_id": 6990}, "so_34671852_34671852_0": {"length": 15, "quality": 0.9375, "section_id": 6989}, "so_34671852_34671852_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 6991}, "so_34671852_34671852_9": {"length": 9, "quality": 0.9, "section_id": 7114}, "so_34671852_34671852_10": {"length": 10, "quality": 1.0, "section_id": 6992}}, "n3337": {"so_34671852_34671852_1": {"length": 7, "quality": 0.7, "section_id": 6736}, "so_34671852_34671852_5": {"length": 4, "quality": 0.5714285714285714, "section_id": 574}, "so_34671852_34672033_1": {"length": 10, "quality": 1.0, "section_id": 356}, "so_34671852_34671852_7": {"length": 11, "quality": 1.0, "section_id": 6858}, "so_34671852_34671852_0": {"length": 15, "quality": 0.9375, "section_id": 6735}, "so_34671852_34671852_6": {"length": 7, "quality": 1.0, "section_id": 6858}, "so_34671852_34671852_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 6737}, "so_34671852_34671852_3": {"length": 15, "quality": 1.0, "section_id": 6738}, "so_34671852_34671852_8": {"length": 5, "quality": 1.0, "section_id": 6858}, "so_34671852_34671852_10": {"length": 10, "quality": 1.0, "section_id": 6738}}, "n4659": {"so_34671852_34671852_5": {"length": 7, "quality": 1.0, "section_id": 8615}, "so_34671852_34671852_4": {"length": 12, "quality": 1.0, "section_id": 8489}, "so_34671852_34672033_1": {"length": 10, "quality": 1.0, "section_id": 379}, "so_34671852_34671852_7": {"length": 11, "quality": 1.0, "section_id": 8615}, "so_34671852_34671852_6": {"length": 7, "quality": 1.0, "section_id": 8615}, "so_34671852_34671852_3": {"length": 15, "quality": 1.0, "section_id": 8490}, "so_34671852_34671852_8": {"length": 5, "quality": 1.0, "section_id": 8615}, "so_34671852_34671852_1": {"length": 7, "quality": 0.7, "section_id": 8488}, "so_34671852_34671852_0": {"length": 15, "quality": 0.9375, "section_id": 8487}, "so_34671852_34671852_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 8489}, "so_34671852_34671852_9": {"length": 9, "quality": 0.9, "section_id": 8615}, "so_34671852_34671852_10": {"length": 10, "quality": 1.0, "section_id": 8490}}}, "34672033": {"Id": "34672033", "PostTypeId": "2", "Body": "<p>The standard goes to pains to point out that <em>a constructor doesn't have a name</em>. It can't be found by name lookup because it doesn't have a name.</p>\n\nC++11 \u00a712.1/1\n\n<blockquote>\n<p id=\"so_34671852_34672033_0\"><strong>\u201d</strong> Constructors do not have names.</p>\n</blockquote>\n\nC+11 \u00a712.1/2\n\n<blockquote>\n<p id=\"so_34671852_34672033_1\"><strong>\u201d</strong> Because constructors do not have names, they are\n  never found during name lookup.</p>\n</blockquote>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-01-08T07:58:50.650", "Score": "4", "CreationDate": "2016-01-08T07:54:46.400", "ParentId": "34671852", "CommentCount": "11", "OwnerUserId": "464581", "LastEditDate": "2016-01-08T07:58:50.650"}, "34671852": {"ViewCount": "87", "Body": "<p>Consider the following code:</p>\n<pre><code>struct base {};\n\nstruct derived : public base {\n    using base::base;\n    base foo() const;  // how does name lookup on 'base' here work?\n};\n</code></pre>\n<p>Intuitively, it's clear that this code is valid, and it does compile (tested with gcc and clang).</p>\n<p>However, I'd like to understand what in the standard makes it valid. Specifically, I'd like to understand how name lookup for <code>base</code> in <code>base foo()</code> finds the base class type rather than the inherited constructor.</p>\n<p>Here's my analysis of the standard wording, showing that it should resolve to the constructor. It's probably wrong, but I'd like to understand where I'm going wrong.</p>\n<p>I started with <code>[class.member.lookup] p1</code>:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_0\">Member name lookup determines the meaning of a name (<em>id-expression</em>) in a class scope. [...] For an <em>id-expression</em>, name lookup begins in the class scope of <code>this</code></p>\n</blockquote>\n<p><code>p7</code> tells us what the result of name lookup is:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_1\">The result of name lookup for [a member name] <code>f</code> in [a class scope] <code>C</code> is the declaration set of <em>S(f, C)</em></p>\n</blockquote>\n<p>I'm trying to follow this procedure with <code>C</code> being <code>derived</code>, and <code>f</code> being the use of <code>base</code> in <code>base foo()</code>.</p>\n<p>\"Declaration set\" is defined in <code>p3</code>:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_2\">The <em>lookup set</em> for <code>f</code> in <code>C</code>, called <em>S(f, C)</em>, consists of two component sets: the <em>declaration set</em>, a set of members named <code>f</code>; [...]</p>\n</blockquote>\n<p><code>p4</code> tells us what goes into the declaration set:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_3\">If <code>C</code> contains a declaration of the name <code>f</code>, the declaration set contains every declaration of <code>f</code> declared in <code>C</code> that satisfies the requirements of the language construct in which the lookup occurs.</p>\n</blockquote>\n<p><code>using base::base</code> is a declaration of the name <code>base</code> (<code>f</code>) in <code>derived</code> (<code>C</code>). The paragraph goes on to give examples of what it means for a declaration <strong>not</strong> to satisfy the requirements of the language construct in which the lookup occurs, but there's nothing there that would exclude <code>using base::base</code> from this lookup.</p>\n<p>Next, further down in <code>p3</code> we're told how <em>using-declarations</em> in the declaration set are handled:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_4\">In the declaration set, <em>using-declarations</em> are replaced by the set of designated members that are not hidden or overridden by members of the derived class</p>\n</blockquote>\n<p>So what members does <code>using base::base</code> designate? Seems to me like that's answered by <code>[class.qual] p2</code>:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_5\">In a lookup in which function names are not ignored and the\n  <em>nested-name-specifier</em> nominates a class <code>C</code>:</p>\n<ul>\n<li><p id=\"so_34671852_34671852_6\">if the name specified after the <em>nested-name-specifier</em>, when looked up in <code>C</code>, is the injected-class-name of <code>C</code>, or</p></li>\n<li><p id=\"so_34671852_34671852_7\">in a <em>using-declaration</em> that is a <em>member-declaration</em>, if the name specified after the <em>nested-name-specifier</em> is the same as\n  <em>identifier</em> [...] in the last component of the <em>nested-name-specifier</em></p></li>\n</ul>\n<p id=\"so_34671852_34671852_8\">the name is instead considered to name the constructor of class <code>C</code>.</p>\n</blockquote>\n<p>There is a footnote which clarifies what a \"lookup in which function names are not ignored\" means:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_9\">Lookups in which function names are ignored include names appearing in a <em>nested-name-specifier</em>, an <em>elaborated-type-specifier</em>, or a <em>base-specifier</em>.</p>\n</blockquote>\n<p>None of these is the case for the name lookup in question, so it seems to me that this paragraph applies, and says that <code>using base::base</code> designates the constructor (which is also what you'd expect intuitively, given that it's the inheriting constructor declaration).</p>\n<p>Having found a declaration (designating the base class constructor) in the derived class scope, we continue following <code>[class.member.lookup] p4</code>:</p>\n<blockquote>\n<p id=\"so_34671852_34671852_10\">If the resulting declaration set is not empty, the subobject set contains <code>C</code> itself, and calculation is complete.</p>\n</blockquote>\n<p>That is, since name lookup found a result in the derived class scope, it does not proceed to look in the base class scope (where it would find the <em>injected-class-name</em> <code>base</code>). [As an aside, even if name lookup continued into the base class scope, I don't see anything that would disambiguate between the constructor and the <em>injected-class-name</em>].</p>\n<p>Where is my reasoning going wrong?</p>\n", "AcceptedAnswerId": "34672033", "Title": "Lookup of base class name after inheriting constructor", "CreationDate": "2016-01-08T07:43:43.227", "Id": "34671852", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-01-08T07:58:50.650", "Score": "1", "OwnerUserId": "141719", "Tags": "<c++><c++11><name-lookup><inheriting-constructors><injected-class-name>", "AnswerCount": "1"}});