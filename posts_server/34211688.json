post_cb({"bq_ids": {"n4140": {"so_34211688_34214734_6": {"length": 7, "quality": 1.0, "section_id": 5419}, "so_34211688_34214734_12": {"length": 25, "quality": 0.9259259259259259, "section_id": 5421}, "so_34211688_34214734_5": {"length": 6, "quality": 1.0, "section_id": 5419}, "so_34211688_34214734_10": {"length": 10, "quality": 1.0, "section_id": 5419}, "so_34211688_34214734_4": {"length": 5, "quality": 1.0, "section_id": 5419}, "so_34211688_34214734_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5419}, "so_34211688_34214734_11": {"length": 15, "quality": 0.8333333333333334, "section_id": 6185}}, "n3337": {"so_34211688_34214734_6": {"length": 5, "quality": 0.7142857142857143, "section_id": 5214}, "so_34211688_34214734_12": {"length": 16, "quality": 0.5925925925925926, "section_id": 5216}, "so_34211688_34214734_5": {"length": 6, "quality": 1.0, "section_id": 5214}, "so_34211688_34214734_10": {"length": 6, "quality": 0.6, "section_id": 6895}, "so_34211688_34214734_4": {"length": 5, "quality": 1.0, "section_id": 5214}, "so_34211688_34214734_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5214}}, "n4659": {"so_34211688_34214734_6": {"length": 7, "quality": 1.0, "section_id": 6841}, "so_34211688_34214734_12": {"length": 20, "quality": 0.7407407407407407, "section_id": 6843}, "so_34211688_34214734_5": {"length": 6, "quality": 1.0, "section_id": 6841}, "so_34211688_34214734_10": {"length": 10, "quality": 1.0, "section_id": 6841}, "so_34211688_34214734_4": {"length": 5, "quality": 1.0, "section_id": 6841}, "so_34211688_34214734_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 6841}, "so_34211688_34214734_11": {"length": 15, "quality": 0.8333333333333334, "section_id": 7687}}}, "34214734": {"Id": "34214734", "PostTypeId": "2", "Body": "<p>In C++14 the rules for constexpr function were relaxed and the paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html\" rel=\"nofollow\">N3597: Relaxing constraints on constexpr functions</a>. The paper goes into the rationale and the effects and it includes the following (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_34211688_34214734_0\">As in C++11, the constexpr keyword is used to mark functions which the implementation is required to evaluate during translation, if they are used from a context where a constant expression is required. Any valid C++ code is permitted in constexpr functions, including the creation and modification of local variables, and almost all statements, <strong>with the restriction that it must be possible for a constexpr function to be used from within a constant expression. A constant expression may still have side-effects which are local to the evaluation and its result.</strong></p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_34211688_34214734_1\">A handful of syntactic restrictions on constexpr functions are\n  retained:</p>\n<ul>\n<li>asm-declarations are not permitted.</li>\n<li>try-blocks and function-try-blocks are not permitted.</li>\n<li>Declarations of variables with static and thread storage duration have some restrictions (see below).</li>\n</ul>\n</blockquote>\n<p>and we can find this covered in N4140 section <code>7.1.5</code> <em>[dcl.constexpr]</em> which says:</p>\n<blockquote>\n<p id=\"so_34211688_34214734_2\">The definition of a constexpr function shall satisfy the following constraints:</p>\n<ul>\n<li><p id=\"so_34211688_34214734_3\">it shall not be virtual (10.3);</p></li>\n<li><p id=\"so_34211688_34214734_4\">its return type shall be a literal type;</p></li>\n<li><p id=\"so_34211688_34214734_5\">each of its parameter types shall be a literal type;</p></li>\n<li><p id=\"so_34211688_34214734_6\">its function-body shall be = delete, = default, or a compound-statement that does not contain</p>\n<ul>\n<li><p id=\"so_34211688_34214734_7\">an asm-definition,</p></li>\n<li><p id=\"so_34211688_34214734_8\">a goto statement,</p></li>\n<li><p id=\"so_34211688_34214734_9\">a try-block, or</p></li>\n<li><p id=\"so_34211688_34214734_10\">a definition of a variable of non-literal type or of static or thread storage duration or for which\n  no initialization is performed.</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>The last example shows how <code>incr</code> can be used in a constexpr:</p>\n<pre><code>constexpr int h(int k) {\n  int x = incr(k); // OK: incr(k) is not required to be a core\n                   // constant expression\n  return x;\n}\n\nconstexpr int y = h(1); // OK: initializes y with the value 2\n                        // h(1) is a core constant expression because\n                        // the lifetime of k begins inside h(1)\n</code></pre>\n<p>and the rule that covers <code>the lifetime of k begins inside h(1)</code> is:</p>\n<blockquote id=\"so_34211688_34214734_11\">\n<ul>\n<li>modification of an object (5.17, 5.2.6, 5.3.2) unless it is applied to a non-volatile lvalue of literal type\n  that refers to a non-volatile object whose lifetime began within the evaluation of e;</li>\n</ul>\n</blockquote>\n<p>The wording in <code>7.1.5</code> <em>[dcl.constexpr]</em> shows us why <code>incr</code> is a valid constexpr:</p>\n<blockquote>\n<p id=\"so_34211688_34214734_12\">For a non-template, non-defaulted constexpr function or a non-template, non-defaulted, non-inheriting\n  constexpr constructor, if no argument values exist such that an invocation of the function or constructor\n  could be an evaluated subexpression of a core constant expression (5.19), the program is ill-formed; no\n  diagnostic required.</p>\n</blockquote>\n<p>As the modified example given by T.C.:</p>\n<pre><code>constexpr int&amp; as_lvalue(int&amp;&amp; i){ return i; }\n\nconstexpr int x = incr(as_lvalue(1)) ;\n</code></pre>\n<p>shows, we can indeed use <code>incr</code> as a subexpression of a core constant expression and therefore it is not ill-formed.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2016-01-13T21:33:20.903", "Score": "9", "CreationDate": "2015-12-11T01:24:11.033", "ParentId": "34211688", "CommentCount": "17", "OwnerUserId": "1708801", "LastEditDate": "2016-01-13T21:33:20.903"}, "34211688": {"ViewCount": "299", "Body": "<p>I got this example from \u00a75.19/2 in N4140:</p>\n<pre><code>constexpr int incr(int &amp;n) {\n    return ++n;\n}\n</code></pre>\n<p>As far as I can tell, this is not a <code>constexpr</code> function. But the snippet compiles in clang and g++. See <a href=\"http://coliru.stacked-crooked.com/a/c0d39eafd69d2d72\">live example</a>. What am I missing here?</p>\n", "AcceptedAnswerId": "34214734", "Title": "As far as I can tell the function below is not constexpr, but the code compiles in clang and g++. What am I missing?", "CreationDate": "2015-12-10T21:03:56.663", "Id": "34211688", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-12-11T07:10:30.970", "LastEditorUserId": "815724", "LastActivityDate": "2016-01-13T21:33:20.903", "Score": "10", "OwnerUserId": "411165", "Tags": "<c++><c++14><constexpr>", "AnswerCount": "2"}, "34212613": {"Id": "34212613", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34211688_34212613_0\">As far as I can tell, this is not a <code>constexpr</code> function.</p>\n</blockquote>\n<p>Why do you say that?\nThe example from \u00a75.19/2 reads: </p>\n<pre><code>constexpr int g(int k) {\n    constexpr int x = incr(k); // error: incr(k) is not a core constant\n                               // expression because lifetime of k\n                               // began outside the expression incr(k)\n    return x;\n}\n</code></pre>\n<p><code>incr(k)</code> not being a <em>core constant expression</em> does not mean <code>incr</code> cannot not be a constexpr function.</p>\n<p>Under C++14's constexpr rules, it is possible to use <code>incr</code> in a constexpr context, for example:</p>\n<pre><code>constexpr int incr(int&amp; n) {\n    return ++n;\n}\n\nconstexpr int foo() {\n    int n = 0;\n    incr(n);\n    return n;\n}\n</code></pre>\n<p>Unless it's downright impossible for the body of the function to be <code>constexpr</code> (for example, calling a non-constexpr function unconditionally), the compiler has no reason to produce an error at the point of definition.</p>\n<p>A constexpr function may even contain paths/branches in the body which would not be constexpr. As long as they are never taken <em>in a constexpr context</em>, you will not get an error.\nFor example:</p>\n<pre><code>constexpr int maybe_constexpr(bool choice, const int&amp; a, const int&amp; b) {\n    return choice ? a : b;\n}\n\nconstexpr int a = 0;\nint b = 1;\nstatic_assert(maybe_constexpr(true, a, b) == 0, \"!\");\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3d116012d9e101ec\">live example</a></p>\n", "LastEditorUserId": "996886", "LastActivityDate": "2015-12-10T22:17:04.887", "Score": "7", "CreationDate": "2015-12-10T22:05:49.843", "ParentId": "34211688", "CommentCount": "13", "OwnerUserId": "996886", "LastEditDate": "2015-12-10T22:17:04.887"}});