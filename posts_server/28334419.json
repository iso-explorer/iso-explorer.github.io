post_cb({"bq_ids": {"n4140": {"so_28334419_28336771_0": {"length": 5, "quality": 1.0, "section_id": 3245}}, "n3337": {"so_28334419_28336771_0": {"length": 5, "quality": 1.0, "section_id": 3118}}, "n4659": {"so_28334419_28336771_0": {"length": 5, "quality": 1.0, "section_id": 4003}}}, "28336771": {"Id": "28336771", "PostTypeId": "2", "Body": "<p>[dcl.fct]/p11:</p>\n<blockquote>\n<p id=\"so_28334419_28336771_0\">Types shall not be defined in return or parameter types.</p>\n</blockquote>\n<p>This is not new in C++11, as far as I know.</p>\n", "LastActivityDate": "2015-02-05T05:25:27.563", "Score": "4", "CreationDate": "2015-02-05T05:25:27.563", "ParentId": "28334419", "CommentCount": "0", "OwnerUserId": "2756719"}, "28334419": {"ViewCount": "224", "Body": "<p>What I am trying to achieve is mainly returning an unnamed struct from a function in C++11. In C++14, I can do this by defining the function inline and having <code>auto</code> as return type, like this:</p>\n<pre><code>auto func()\n{\n    struct\n    {\n        int member;\n    } ret;\n\n    // set ret.member\n\n    return ret;\n}\n</code></pre>\n<p>However, C++11 doesn't support deducing the return type of a normal (non-lambda) function, and this only works in C++14 when the definition is done inline.</p>\n<p>I tried the following two variations of declaring the struct in the function declaration:</p>\n<pre><code>auto func() -&gt; struct { int member; };\nstruct { int member; } func();\n</code></pre>\n<p>Is this simply impossible to do with C++11? If so, does someone know whether this was disallowed on purpose or just nobody thought of this new use of automatically deduced types (because this only works with the functions return value being assigned to an <code>auto</code> variable)?</p>\n<p>And finally, is there any other way to achieve something similar to this? I am aware of <code>std::tuple</code>, but I want to name the values; and in my use case the struct type is definitely only useful as return type of this one function, so why name it?</p>\n", "AcceptedAnswerId": "28336771", "Title": "Why can structs not be defined in a function declaration in C++11 or higher?", "CreationDate": "2015-02-05T00:55:26.297", "Id": "28334419", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-05T05:25:27.563", "Score": "7", "OwnerUserId": "1592377", "Tags": "<c++><c++11><c++14>", "AnswerCount": "2"}, "28335100": {"Id": "28335100", "PostTypeId": "2", "Body": "<p>A <em>class-specifier</em> consists of a <em>class-head-name</em> and <code>{ }</code>. Once the closing brace is encountered, the class is defined. If the <em>class-head-name</em> is omitted, the class is unnamed (\u00a79). A <em>type-specifier</em> can have a <em>class-specifier</em>, but <em>trailing-type-specifier</em> can't (only <em>simple-type-specifier</em>, <em>elaborated-type-specifier</em>, <em>typename-specifier</em> and <em>cv-qualifier</em> are allowed, \u00a77.1.6). For this reason, I believe that it's not possible to put the definition of a class in a <em>trailing-return-type</em>. </p>\n<p>Source: N4140</p>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2015-02-05T02:18:53.683", "Score": "2", "CreationDate": "2015-02-05T02:18:53.683", "ParentId": "28334419", "CommentCount": "3"}});