post_cb({"11236584": {"ParentId": "11235357", "CommentCount": "15", "CreationDate": "2012-06-28T00:30:33.510", "OwnerUserId": "1006264", "PostTypeId": "2", "Id": "11236584", "Score": "1", "Body": "<p>from n3290  [class.cdtor]</p>\n<p>12.7 Construction and destruction\n1 For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior. <strong>For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior.</strong></p>\n", "LastActivityDate": "2012-06-28T00:30:33.510"}, "11235479": {"ParentId": "11235357", "CommentCount": "6", "CreationDate": "2012-06-27T22:07:54.373", "OwnerUserId": "13767", "PostTypeId": "2", "Id": "11235479", "Score": "5", "Body": "<p>For me, from [12.4] it clearly stands, that it is not legal:</p>\n<blockquote>\n<p id=\"so_11235357_11235479_0\"><strong>Once a destructor is invoked for an object, the object no longer\n  exists;</strong> the behavior is unde\ufb01ned if the destructor is invoked for an\n  object whose lifetime has ended (3.8). [Example: ...]</p>\n</blockquote>\n<p>Despite the lack of definition for <em>no longer exists</em>, I think, I can say that referencing an object which <em>no longer exists</em> results in <strong>undefined behaviour</strong>.</p>\n", "LastActivityDate": "2012-06-27T22:07:54.373"}, "11235427": {"ParentId": "11235357", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2012-06-27T22:03:10.387", "Score": "1", "LastEditorUserId": "197788", "LastEditDate": "2012-06-27T22:28:48.247", "Id": "11235427", "OwnerUserId": "197788", "Body": "<p>At the moment in time that you're calling <code>b_-&gt;f()</code>, <code>Derived</code> is in the process of being destructed, but <code>Base</code> hasn't been destructed yet. You're still in limbo though, because it's <code>Derived::f()</code> that you're going to be calling.</p>\n<p>Edit:</p>\n<blockquote>\n<p id=\"so_11235357_11235427_0\">Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2). When a virtual function\n  is called directly or indirectly from a constructor (including from\n  the mem-initializer for a data member) or from a destructor, and the\n  object to which the call applies is the object under construction or\n  destruction, the function called is the one defined in the constructor\n  or destructor\u2019s own class or in one of its bases, but not a function\n  overriding it in a class derived from the constructor or destructor\u2019s\n  class, or overriding it in one of the other base classes of the most\n  derived object (1.8). If the virtual function call uses an explicit\n  class member access (5.2.5) and the object-expression refers to the\n  object under construction or destruction but its type is neither the\n  constructor or destructor\u2019s own class or one of its bases, the result\n  of the call is undefined.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow\">C++0x working draft Sec 12.7 par 4</a></p>\n", "LastActivityDate": "2012-06-27T22:28:48.247"}, "11235357": {"CommentCount": "3", "ViewCount": "392", "PostTypeId": "1", "LastEditorUserId": "98654", "CreationDate": "2012-06-27T21:56:44.603", "LastActivityDate": "2012-06-28T00:30:33.510", "Title": "The state of an object between a call to ~Derived() and ~Base()", "AcceptedAnswerId": "11236584", "LastEditDate": "2012-06-27T23:13:05.597", "Id": "11235357", "Score": "5", "Body": "<h2>Question</h2>\n<p>What does the C++ standard guarantee about the state of an object in the time \nafter a derived class's destructor executes, but before the base class's destructor executes ? (This is the time when the derived class's subobjects' destructors are being called.)</p>\n<h2>Example</h2>\n<pre><code>#include &lt;string&gt;\nstruct Base;\n\nstruct Member {\n  Member(Base *b);\n  ~Member();\n  Base *b_;\n};\n\nstruct Base {\n  virtual void f() {}\n  virtual ~Base() {}\n};\n\nstruct Derived : Base {\n  Derived() : m(this) {}\n  virtual ~Derived() {}  \n  virtual void f() {}\n  std::string s; \n  Member m;\n};\n\nMember::Member(Base *b) : b_(b) {}\nMember::~Member() {\n  // At this point, ~Derived has finished -- can we use b_ as a \n  // Derived* object (i.e. call Derived::f or access Derived::s)?\n  b_-&gt;f();\n}\n\nint main() {\n  Base *bd = new Derived;\n  delete bd;\n}\n</code></pre>\n<p>In this example, a <code>Member</code> object has a pointer to a <code>Derived</code> object that owns it, and it attempts to access that <code>Derived</code> object as it is destructed...even though the destructor for <code>Derived</code> has already finished.</p>\n<p>Which version of <code>*bd</code>'s virtual functions would be called if some subobject called a virtual function after <code>~Derived()</code> executes, but before <code>~Base()</code> executes?  Is it even legal to access <code>*bd</code> when it's in that state?</p>\n", "Tags": "<c++><destructor><object-lifetime>", "OwnerUserId": "98654", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_11235357_11235427_0": {"section_id": 447, "quality": 0.5172413793103449, "length": 45}, "so_11235357_11235479_0": {"section_id": 411, "quality": 0.875, "length": 14}}, "n3337": {"so_11235357_11235427_0": {"section_id": 438, "quality": 0.5172413793103449, "length": 45}, "so_11235357_11235479_0": {"section_id": 402, "quality": 0.875, "length": 14}}, "n4659": {"so_11235357_11235427_0": {"section_id": 469, "quality": 0.5172413793103449, "length": 45}, "so_11235357_11235479_0": {"section_id": 429, "quality": 0.875, "length": 14}}}});