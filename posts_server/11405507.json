post_cb({"11405507": {"CommentCount": "5", "ViewCount": "2809", "PostTypeId": "1", "LastEditorUserId": "1513437", "CreationDate": "2012-07-10T01:38:35.100", "LastActivityDate": "2017-04-07T10:01:42.703", "Title": "exit() function fails to exit process", "LastEditDate": "2012-07-10T03:07:24.323", "Id": "11405507", "Score": "2", "Body": "<p>I'm working on a multithreaded C++ application in Linux with FreeGLUT. Oddly enough, calling exit() in one of my threads results in an onexit() callback being called and completed, but fails to exit my program. Instead it hangs in a select() call in the GLUT library, according to GDB.</p>\n<p>I also have a keyboard callback that exits when I press 'q'. GLUT exits fine if I press 'q' while the program is hanging.</p>\n<p>No one seems to be having similar problems. Documentation says that exit() is supposed to close an entire process, and not just a thread, so it's not that. I'm stumped. Do you have any ideas?</p>\n<p>EDIT: I've found the problem. I was wrong that the exit handler had finished. A library function call was waiting on a mutex that was already locked at the time that exit() was called. GLUT just took advantage of the free time. Thank you all for your responses.</p>\n", "Tags": "<c++><linux><glut><exit><freeglut>", "OwnerUserId": "1513437", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11405507_11405948_3": {"section_id": 6805, "quality": 0.8076923076923077, "length": 21}, "so_11405507_11405948_1": {"section_id": 6805, "quality": 1.0, "length": 20}, "so_11405507_11405948_2": {"section_id": 6805, "quality": 1.0, "length": 22}, "so_11405507_11405948_0": {"section_id": 6805, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_11405507_11405948_3": {"section_id": 6560, "quality": 0.8076923076923077, "length": 21}, "so_11405507_11405948_1": {"section_id": 6560, "quality": 1.0, "length": 20}, "so_11405507_11405948_2": {"section_id": 6560, "quality": 1.0, "length": 22}, "so_11405507_11405948_0": {"section_id": 6560, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_11405507_11405948_3": {"section_id": 8296, "quality": 0.8076923076923077, "length": 21}, "so_11405507_11405948_1": {"section_id": 8296, "quality": 1.0, "length": 20}, "so_11405507_11405948_2": {"section_id": 8296, "quality": 1.0, "length": 22}}}, "11405948": {"ParentId": "11405507", "PostTypeId": "2", "CommentCount": "0", "Body": "<h3>In C++03</h3>\n<p>Note: exit() is a C function.</p>\n<p>C as a language does not have the concept of threads at the language level.<br>\nThreads are usually added to C via a library support. So you need to read the library documentation of the affects of calling exit() from a thread that is not the main thread.</br></p>\n<p>It is probably not portable across threading implementations.</p>\n<p>Your best bet is to only call exit() from the main thread.<br>\nIn a child thread you should probably just set some state that is viewed by the main thread. Let the main thread see this state and call exit manually. Note even calling exit on the man thread may hang some threading libraries if their are child threads still running. So best to get the main thread to wait for all children before exiting if you want your code to be portable.</br></p>\n<h3>In C++11</h3>\n<p>Now that C++11 has entered the since with explicit threading in the language there is more to it. <code>See n3376 Section 18.4.1 [cstdint.syn] Paragraph 8</code></p>\n<blockquote>\n<p id=\"so_11405507_11405948_0\">The function exit() has additional behavior in this International Standard:  </p>\n<p id=\"so_11405507_11405948_1\">\u2014 First, objects with thread storage duration and associated with the current thread are destroyed. Next, objects with static storage duration are destroyed and functions registered by calling atexit are called.</p>\n<pre><code>      See 3.6.3 for the order of destructions and calls. (Automatic objects are not destroyed as a result of calling exit().)\n\n      If control leaves a registered function called by exit because the function does not provide a handler for a thrown exception, std::terminate() shall be called (15.5.1).\n</code></pre>\n<p id=\"so_11405507_11405948_2\">\u2014 Next, all open C streams (as mediated by the function signatures declared in ) with unwritten buffered data are flushed, all open C streams are closed, and all files created by calling tmpfile() are removed.</p>\n<p id=\"so_11405507_11405948_3\">\u2014 Finally, control is returned to the host environment. If status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise the status returned is implementation-defined.</p>\n</blockquote>\n", "OwnerUserId": "14065", "LastEditorUserId": "872616", "LastEditDate": "2017-04-07T10:01:42.703", "Id": "11405948", "Score": "3", "CreationDate": "2012-07-10T02:48:59.930", "LastActivityDate": "2017-04-07T10:01:42.703"}});