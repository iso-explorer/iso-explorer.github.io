post_cb({"29752572": {"Id": "29752572", "PostTypeId": "2", "Body": "<p>On a 32 bit system, you might be able to allocate an array of more than 2 GB, and have two pointers to the start and end of the array that are more than 2 GB apart. </p>\n<p>In this case, (ptr1 &gt; ptr2) would yield a result of true, while (ptr1 - ptr2 &gt; 0) would be undefined behaviour if ptrdiff_t is a signed 32 bit integer. </p>\n<p>(Now since people rarely do this, there is a tiny chance that ptr1 &gt; ptr2 might give the wrong result because of a compiler bug. If you have two int* more than 2GB apart, ptr1 - ptr2 would be defined behaviour, because the correct result fits into a 32 bit signed number, but I wouldn't be surprised if a compiler got it wrong).</p>\n", "LastActivityDate": "2015-04-20T15:50:54.317", "CommentCount": "1", "CreationDate": "2015-04-20T15:50:54.317", "ParentId": "29746465", "Score": "0", "OwnerUserId": "3255455"}, "29746566": {"Id": "29746566", "PostTypeId": "2", "Body": "<p>Yes, there is such a case where the two will <strong>not</strong> behave the same.</p>\n<p>Pointer difference is <em>signed</em> [expr.add]:</p>\n<blockquote>\n<p id=\"so_29746465_29746566_0\">When two pointers to elements of the same array object are subtracted, the result is the difference of the\n  subscripts of the two array elements. The type of the result is an implementation-defined <strong>signed</strong> integral\n  type; this type shall be the same type that is defined as <a href=\"http://en.cppreference.com/w/cpp/types/ptrdiff_t\"><code>std::ptrdiff_t</code></a> in the <code>&lt;cstddef&gt;</code> header</p>\n</blockquote>\n<p>but with two caveats:</p>\n<blockquote>\n<p id=\"so_29746465_29746566_1\">As\n  with any other arithmetic overflow, if the result does not fit in the space provided, the behavior is undefined.</p>\n<p id=\"so_29746465_29746566_2\">Unless both pointers point to elements of the same array object, or\n  one past the last element of the array object, the behavior is undefined.</p>\n</blockquote>\n<p>On the comparison side, we have [expr.rel]:</p>\n<blockquote>\n<p id=\"so_29746465_29746566_3\">\u2014 If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to\n  the element with the higher subscript compares greater.<br>\n  \u2014 If one pointer points to an element of an array, or to a subobject thereof, and another pointer points\n  one past the last element of the array, the latter pointer compares greater.<br>\n  \u2014 If two pointers point to different non-static data members of the same object, or to subobjects of such\n  members, recursively, the pointer to the later declared member compares greater provided the two\n  members have the same access control (Clause 11) and provided their class is not a union.</br></br></p>\n</blockquote>\n<p>The last bullet point there gives us a difference. Consider:</p>\n<pre><code>struct A {\n    int x, y;\n}\n\nA a;\nint *px = &amp;a.x, *py = &amp;a.y\n</code></pre>\n<p><code>px &gt; py</code> is defined but <code>px - py &gt; 0</code> is <strong>undefined</strong>.</p>\n<p>There is also of course the integer overflow case, if you have an enormous array:</p>\n<pre><code>array[0] &gt; array[PTRDIFF_MAX + 10]         // defined\narray[0] - array[PTRDIFF_MAX + 10] &gt; 0     // undefined\n</code></pre>\n<p>Outside of those two cases, if the two pointers point to the same array (or one-past-the-end), the two expressions are equivalent. If the two pointers point to different arrays, then both are undefined. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-04-20T13:53:09.767", "Score": "29", "CreationDate": "2015-04-20T11:25:48.237", "ParentId": "29746465", "CommentCount": "7", "OwnerUserId": "2069064", "LastEditDate": "2015-04-20T13:53:09.767"}, "bq_ids": {"n4140": {"so_29746465_29746566_3": {"length": 65, "quality": 1.0, "section_id": 6151}, "so_29746465_29746566_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 6143}, "so_29746465_29746566_1": {"length": 10, "quality": 1.0, "section_id": 6143}, "so_29746465_29746566_2": {"length": 15, "quality": 0.9375, "section_id": 6143}}, "n3337": {"so_29746465_29746566_3": {"length": 38, "quality": 0.5846153846153846, "section_id": 5913}, "so_29746465_29746566_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5907}, "so_29746465_29746566_1": {"length": 10, "quality": 1.0, "section_id": 5907}, "so_29746465_29746566_2": {"length": 15, "quality": 0.9375, "section_id": 5907}}, "n4659": {"so_29746465_29746566_3": {"length": 46, "quality": 0.7076923076923077, "section_id": 7648}, "so_29746465_29746566_0": {"length": 20, "quality": 0.7142857142857143, "section_id": 7639}, "so_29746465_29746566_2": {"length": 9, "quality": 0.5625, "section_id": 7639}}}, "29746656": {"Id": "29746656", "PostTypeId": "2", "Body": "<p>It depends how you are doing the subtraction between ptr1 and ptr2. If it is signed then it should work fine otherwise if it is unsigned the result could be different. For example when:</p>\n<pre><code>if (ptr1 &gt; ptr2)\n</code></pre>\n<p>will fail and subtraction:</p>\n<pre><code>ptr1 - ptr2\n</code></pre>\n<p>is unsigned the result of subtraction will be positive, hence the:</p>\n<pre><code>if (ptr1 - ptr2 &gt; 0)\n</code></pre>\n<p>will be true.</p>\n<p>I would recommend using the ptr1 &gt; ptr2 because it is less prone to mistakes and pitfalls.</p>\n", "LastActivityDate": "2015-04-20T11:30:49.210", "CommentCount": "1", "CreationDate": "2015-04-20T11:30:49.210", "ParentId": "29746465", "Score": "-3", "OwnerUserId": "1386897"}, "29746687": {"Id": "29746687", "PostTypeId": "2", "Body": "<p>Constructs like <code>if(ptr1 - ptr2 &gt; 0)</code> can be dangerous.</p>\n<p>Recently, I ran into a problem, where I had two pointers to type <code>T</code>:</p>\n<pre><code>T* p1;\nT* p2;\n</code></pre>\n<p>and</p>\n<pre><code>sizeof(T) = 16\n</code></pre>\n<p>Now, there was a bug: difference between <code>p1</code> and <code>p2</code> was smaller than 16. So <code>p1 - p2</code> gave 0, which caused a lot of errors!</p>\n<p>Try <a href=\"https://ideone.com/ncQbh0\" rel=\"nofollow\">this sample</a>.</p>\n<p>The best solution is to use either:</p>\n<pre><code>if(ptr1 &gt; ptr2)\n</code></pre>\n<p>or:</p>\n<pre><code>ptrdiff_t diff = (ptrdiff_t)p2 - (ptrdiff_t)p1;\n\nif(diff &gt; 0)\n{\n}\n</code></pre>\n<p>So, basically, these two construct may or may not be equivalent (depending on sign of the difference), but sometimes they may not work in the same way. </p>\n<p>Pointers arithmetic can be very error-prone.</p>\n", "LastActivityDate": "2015-04-20T11:32:10.787", "CommentCount": "3", "CreationDate": "2015-04-20T11:32:10.787", "ParentId": "29746465", "Score": "3", "OwnerUserId": "2812864"}, "29746465": {"ViewCount": "1377", "Body": "<p>Assuming the two pointers of the same type point within the same array (or the same object) so that both subtraction of two pointers and comparison are valid... is there any case where</p>\n<pre><code>if(ptr1 - ptr2 &gt; 0)\n</code></pre>\n<p>would behave differently from</p>\n<pre><code>if(ptr1 &gt; ptr2)\n</code></pre>\n<p>or are they at all times equivalent?</p>\n", "AcceptedAnswerId": "29746566", "Title": "Is there any case when \"ptr1 - ptr2 > 0\" would differ from \"ptr1 > ptr2\"?", "CreationDate": "2015-04-20T11:21:18.613", "Id": "29746465", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-04-20T15:50:54.317", "Score": "21", "OwnerUserId": "57428", "Tags": "<c++><pointers>", "AnswerCount": "4"}});