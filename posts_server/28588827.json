post_cb({"28589107": {"ParentId": "28588827", "CommentCount": "0", "Body": "<p>Per [conv.ptr]/1 (quoting N4296 here):</p>\n<blockquote>\n<p id=\"so_28588827_28589107_0\">A <em>null pointer constant</em> is an integer literal (2.13.2) with value zero or a prvalue of type <code>std::nullptr_t</code>. ... A null pointer constant of integral type can be converted to a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p><code>shared_ptr</code> has a non-explicit constructor that accepts <code>std::nullptr_t</code> per [util.smartptr.shared.const]/1:</p>\n<pre><code>constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n</code></pre>\n<p>which constructs an empty, non-owning <code>shared_ptr</code>.</p>\n<p>When you call <code>f(0)</code> directly, <code>0</code> is a <em>null pointer constant</em> that is implicitly converted to <code>shared_ptr&lt;int&gt;</code> by the above constructor. When you instead call <code>call_f(f, 0)</code>, the type of the literal 0 is deduced to <code>int</code> and of course an <code>int</code> cannot be converted to a <code>shared_ptr&lt;int&gt;</code>.</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "28589107", "Score": "2", "CreationDate": "2015-02-18T16:49:43.327", "LastActivityDate": "2015-02-18T16:49:43.327"}, "28588827": {"CommentCount": "5", "CreationDate": "2015-02-18T16:37:42.117", "PostTypeId": "1", "AcceptedAnswerId": "28589112", "LastEditorUserId": "3093378", "LastActivityDate": "2017-01-07T02:56:18.827", "LastEditDate": "2017-01-07T02:56:18.827", "ViewCount": "889", "FavoriteCount": "1", "Title": "Implicit conversion from int to shared_ptr", "Id": "28588827", "Score": "6", "Body": "<p>Consider the code below:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nvoid f(std::shared_ptr&lt;int&gt; sp) {}\n\ntemplate &lt;typename FuncType, typename PtrType&gt;\nauto call_f(FuncType f, PtrType p) -&gt; decltype(f(p))\n{\n    return f(p);\n}\n\nint main()\n{\n    f(0); // doesn't work for any other int != 0, thanks @Rupesh\n    // call_f(f, 0); // error, cannot convert int to shared_ptr\n}\n</code></pre>\n<p>In the first line in <code>main()</code>, the integer <code>0</code> is converted to a <code>std::shared_ptr&lt;int&gt;</code> and the call <code>f(0)</code> succeeds without any problem. However, using a template to call the function make things different. Second line will not compile anymore, the error being </p>\n<pre><code>error: could not convert 'p' from 'int' to 'std::shared_ptr&lt;int&gt;'\n</code></pre>\n<p>My questions are:</p>\n<ol>\n<li>Why does the first call succeed and the second doesn't? Is there anything I'm missing here?</li>\n<li>I don't understand also how the conversion from <code>int</code> to <code>std::shared_ptr</code> is being performed in the call <code>f(0)</code>, as it looks like <code>std::shared_ptr</code> has only explicit constructors. </li>\n</ol>\n<p>PS: A variant of this example appears in Scott Meyers' <em>Effective Modern C++</em> Item 8, as a way of protecting such calls with <code>nullptr</code>.</p>\n", "Tags": "<c++><c++11><type-conversion><shared-ptr><implicit-conversion>", "OwnerUserId": "3093378", "AnswerCount": "3"}, "28589241": {"ParentId": "28588827", "CommentCount": "1", "Body": "<p>The firs call f(0) is compiled as f(nullptr), which is fine for the compiler (but it should not be in my opinion). The second call will create declaration for a function to work on any int, which is illegal. </p>\n<p>Funny thing is, that even this code works:</p>\n<pre><code>f(3-3);\nf(3*0); \n</code></pre>\n", "OwnerUserId": "3319335", "PostTypeId": "2", "Id": "28589241", "Score": "1", "CreationDate": "2015-02-18T16:55:25.610", "LastActivityDate": "2015-02-18T16:55:25.610"}, "bq_ids": {"n4140": {"so_28588827_28589112_0": {"section_id": 39, "quality": 0.8235294117647058, "length": 70}, "so_28588827_28589112_1": {"section_id": 39, "quality": 0.90625, "length": 29}, "so_28588827_28589107_0": {"section_id": 39, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_28588827_28589112_0": {"section_id": 36, "quality": 0.8941176470588236, "length": 76}, "so_28588827_28589112_1": {"section_id": 36, "quality": 0.84375, "length": 27}, "so_28588827_28589107_0": {"section_id": 36, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_28588827_28589112_0": {"section_id": 39, "quality": 0.8235294117647058, "length": 70}, "so_28588827_28589112_1": {"section_id": 39, "quality": 0.90625, "length": 29}, "so_28588827_28589107_0": {"section_id": 39, "quality": 0.9047619047619048, "length": 19}}}, "28589112": {"ParentId": "28588827", "LastEditDate": "2015-02-19T04:03:01.750", "CommentCount": "4", "CreationDate": "2015-02-18T16:49:53.777", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "28589112", "Score": "5", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr\" rel=\"nofollow\">std::shared_ptr</a> has a constructor that takes <em>std::nullptr_t</em>, literal <code>0</code> is a null pointer constant that is convertiable to <em>std::nullptr_t</em> from the draft C++ standard section <code>4.10</code> <em>[conv.ptr]</em> (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_28588827_28589112_0\"><strong>A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type\n  std::nullptr_t</strong>. A null pointer constant can be converted to a\n  pointer type; the result is the null pointer value of that type and is\n  distinguishable from every other value of object pointer or function\n  pointer type. Such a conversion is called a null pointer conversion.\n  Two null pointer values of the same type shall compare equal. The\n  conversion of a null pointer constant to a pointer to cv-qualified\n  type is a single conversion, and not the sequence of a pointer\n  conversion followed by a qualification conversion (4.4). <strong>A null\n  pointer constant of integral type can be converted to a prvalue of\n  type std::nullptr_t</strong>. [ Note: The resulting prvalue is not a null\n  pointer value. \u2014end note ]</p>\n</blockquote>\n<p>in your second case <code>p</code> is being deduced as type <em>int</em> which although has the value zero is no longer a null pointer constant and so does not fit the same case.</p>\n<p>As T.C. points out the wording was changed with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3714.html#903\" rel=\"nofollow\">DR 903</a> which requires an integer literal with value zero as opposed to an <em>integral constant expression</em> which evaluates to zero:</p>\n<blockquote>\n<p id=\"so_28588827_28589112_1\">A null pointer constant is an <strong>integer literal (2.14.2) with value\n  zero</strong> or a prvalue of type std::nullptr_t. A null pointer constant\n  can be converted to a pointer type; the result is the null pointer\n  value of that type and is distinguishable from every other value of\n  object pointer or function pointer type.</p>\n</blockquote>\n", "LastActivityDate": "2015-02-19T04:03:01.750"}});