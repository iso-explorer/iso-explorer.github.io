post_cb({"37541819": {"ParentId": "37541749", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_37541749_37541819_0\">Isn't it wrong C++?</p>\n</blockquote>\n<p>No. It's perfectly legal to redeclare an identifier, as long as it's in a different scope. In this case, the scope is the then-body of the if-statement.</p>\n<p>It isn't ambiguous. The nearest preceding declaration will be used.</p>\n", "OwnerUserId": "3425536", "LastEditorUserId": "3425536", "LastEditDate": "2016-05-31T09:28:32.580", "Id": "37541819", "Score": "1", "CreationDate": "2016-05-31T09:26:26.010", "LastActivityDate": "2016-05-31T09:28:32.580"}, "37541955": {"ParentId": "37541749", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, it is not wrong. It is a perfectly valid behavior according to the standard.</p>\n<pre><code>void function(int origin)\n{\n    if (origin &lt; 0) // scope of the first 'origin'\n    {\n        double origin = 0.3; // scope of the second 'origin' begins\n                             // scope of the first 'origin' is interrupted\n\n        std::cout &lt;&lt; origin &lt;&lt; std::endl;\n    } //block ends, scope of the second 'origin' ends\n      //scope of the first 'origin' resumes\n}\n</code></pre>\n<p>As tupe_cat said it is always valid to redeclare if their scopes vary. In such cases variable belonging to the inner scope will gain over the outer scope.</p>\n", "OwnerUserId": "5756174", "LastEditorUserId": "5756174", "LastEditDate": "2016-05-31T09:47:13.023", "Id": "37541955", "Score": "1", "CreationDate": "2016-05-31T09:32:11.037", "LastActivityDate": "2016-05-31T09:47:13.023"}, "37542104": {"ParentId": "37541749", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is legal according to C++ standard, section 3.3.3.1:</p>\n<blockquote>\n<p id=\"so_37541749_37542104_0\">A name declared in a block is local to that block; it has block scope. Its potential scope begins at its point of declaration and ends at the end of its block. A variable declared at block scope is a local variable.</p>\n</blockquote>\n<p>Such redeclaration hides the <code>origin</code> parameter.</p>\n<blockquote>\n<p id=\"so_37541749_37542104_1\">Cause doing the same but just in the beginning of function it gives a compile-time error.</p>\n</blockquote>\n<p>You get an error because C++ standard explicitly disallows such redeclaration in section 3.3.3.2:</p>\n<blockquote>\n<p id=\"so_37541749_37542104_2\">A parameter name shall not be redeclared in the outermost block of the function definition nor in the outermost block of any handler associated with a function-try-block.</p>\n</blockquote>\n<p>The reason for this exclusion is that function parameters are local to the outer scope of the function, so having a redeclaration without another layer of braces would introduce a duplicate identifier into the same scope.</p>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2016-05-31T09:43:30.383", "Id": "37542104", "Score": "2", "CreationDate": "2016-05-31T09:37:54.147", "LastActivityDate": "2016-05-31T09:43:30.383"}, "37542868": {"ParentId": "37541749", "CommentCount": "0", "Body": "<p>I don't mind this C++ behaviour. Sure, it can lead to bugs/oversights as you have demonstrated. But you can do this in C++</p>\n<pre><code>for (int i = 0; i &lt; 4; ++i) {\n    for (int i = 0; i &lt; 5; ++i) {\n        cout &lt;&lt; i;\n    }\n    cout &lt;&lt; i;\n}\ncout &lt;&lt; endl;\nfor (int i = 0; i &lt; 4; ++i) {\n    for (int j = 0; j &lt; 5; ++j) {\n        cout &lt;&lt; j;\n    }\n    cout &lt;&lt; i;\n}\n</code></pre>\n<p>and the results are identical because <code>i</code> is redefined in the scope of the inner <code>for</code> loop to be a different variable. </p>\n<p>In other languages like C# you can't do this. It will tell you have tried to redeclare a variable of the same name in an inner scope. </p>\n<p>I find this over-protective. When I'm cutting and pasting code with loops, it is irritating to have to redeclare <code>i</code>, which we all tend to use as the loop variable, to be <code>i1</code>, <code>i2</code> etc. I invariably miss one, with cut-and-paste code, so I'm using <code>arr[i]</code> in an <code>i3</code> loop, when I meant <code>arr[i3]</code> (whoops). </p>\n<p>In production code, I agree that defensive coding means you should use different names for loop variables in the same function. </p>\n<p>But it's nice to be able to reuse variable names in nested for loops when you're experimenting. C++ gives you that choice. </p>\n", "OwnerUserId": "6212666", "PostTypeId": "2", "Id": "37542868", "Score": "1", "CreationDate": "2016-05-31T10:13:45.730", "LastActivityDate": "2016-05-31T10:13:45.730"}, "37541749": {"CommentCount": "2", "ViewCount": "118", "CreationDate": "2016-05-31T09:23:20.493", "LastActivityDate": "2016-05-31T10:13:45.730", "Title": "Variables names ambiguity in C++", "AcceptedAnswerId": "37542868", "PostTypeId": "1", "Id": "37541749", "Score": "1", "Body": "<p>I'm a bit confused at this situation:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid function(int origin)\n{\n    if (origin &lt; 0)\n    {\n        double origin = 0.3;\n\n        std::cout &lt;&lt; origin &lt;&lt; std::endl;\n    }\n}\n\nint main()\n{\n    function(-4);\n}\n</code></pre>\n<p>where it gets compiled and run successfully using VS2013 under v120 ToolSet. Isn't it wrong C++? 'Cause doing the same but just in the beginning of function it gives a compile-time error. </p>\n", "Tags": "<c++><ambiguous>", "OwnerUserId": "3640988", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_37541749_37542104_2": {"section_id": 7062, "quality": 1.0, "length": 13}, "so_37541749_37542104_0": {"section_id": 7061, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_37541749_37542104_2": {"section_id": 6806, "quality": 1.0, "length": 13}, "so_37541749_37542104_0": {"section_id": 6805, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_37541749_37542104_2": {"section_id": 8559, "quality": 1.0, "length": 13}, "so_37541749_37542104_0": {"section_id": 8558, "quality": 0.9166666666666666, "length": 22}}}});