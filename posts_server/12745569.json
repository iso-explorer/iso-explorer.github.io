post_cb({"12745790": {"ParentId": "12745569", "CommentCount": "6", "Body": "<p>Template argument deduction comes <em>before</em> overload resolution. But template argument deduction does not consider implicit conversions, so your templated operator is never even considered.</p>\n<p>Implicit conversions are only applied <em>after</em> an overload has been chosen.</p>\n<p>You can say <code>A a3 = W(a1) + W(a2);</code>, though.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "12745790", "Score": "4", "CreationDate": "2012-10-05T11:58:20.210", "LastActivityDate": "2012-10-05T11:58:20.210"}, "12745920": {"ParentId": "12745569", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Your first example fails because the standard says it must fail with templates. There are potential problems with argument dependent name lookup, and templates exacerbate those problems. One way around this is to preclude templates from such lookup unless you are explicit about the use of templates. Here's the relevant text from the C++03 standard, paragraph 6 of section 14.8.1:</p>\n<blockquote>\n<p id=\"so_12745569_12745920_0\">For simple function names, argument dependent lookup (3.4.2) applies even when the function name is not visible within the scope of the call. This is because the call still has the syntactic form of a function call (3.4.1). But when a function template with explicit template arguments is used, the call does not have the correct syntactic form unless there is a function template with that name visible at the point of the call. If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not apply. If some such name is visible, argument dependent lookup applies and additional function templates may be found in other namespaces.</p>\n</blockquote>\n<p><strong>Update:</strong><br>\nThe question has been edited with additional information.</br></p>\n<blockquote>\n<p id=\"so_12745569_12745920_1\">I am trying to avoid this solution:<br>\n<code>A a3 = W(a1) + W(a2);</code></br></p>\n</blockquote>\n<p>Why, exactly, are you trying to avoid that situation? This code of yours violates two key rules of programming.</p>\n<ol>\n<li>Code as if the next guy to maintain your code is a homicidal maniac who knows where you live.</li>\n<li>Principle of least astonishment.</li>\n</ol>\n<p>Even your non-template version violates these rules. You compute <code>a1+a2</code> by a (hidden) conversion to an unrelated class <code>W</code>, the <code>operator+</code> of which returns an <code>A</code> rather than a <code>W</code>. This is not the principle of least astonishment. This is astonishing, to say the least. <em>Why don't you think making your conversions explicit is a better approach?</em></p>\n<p>Argument dependent lookup is a very powerful tool, but there are a lot of problems that are associated with this power. Couple ADL with automatic type conversions and the problems magnify. Couple it with automatic type conversions and templates and you have a mess. The standard committee decided enough was enough. You cannot do what you want to do unless you make the conversions explicit.</p>\n", "OwnerUserId": "774499", "LastEditorUserId": "774499", "LastEditDate": "2012-10-05T23:36:22.880", "Id": "12745920", "Score": "2", "CreationDate": "2012-10-05T12:05:18.410", "LastActivityDate": "2012-10-05T23:36:22.880"}, "bq_ids": {"n4140": {"so_12745569_12745920_0": {"section_id": 291, "quality": 0.9436619718309859, "length": 67}}, "n3337": {"so_12745569_12745920_0": {"section_id": 282, "quality": 0.9436619718309859, "length": 67}}, "n4659": {"so_12745569_12745920_0": {"section_id": 298, "quality": 0.9436619718309859, "length": 67}}}, "12745569": {"CommentCount": "0", "ViewCount": "145", "PostTypeId": "1", "LastEditorUserId": "1463922", "CreationDate": "2012-10-05T11:44:03.770", "LastActivityDate": "2012-10-05T23:36:22.880", "Title": "Why argument matching works for non template version, but does not work for template version?", "AcceptedAnswerId": "12745790", "LastEditDate": "2012-10-05T22:55:31.743", "Id": "12745569", "Score": "1", "Body": "<p>Consider this very simple example, where I have template wrapper class for which are defined operators:</p>\n<pre><code>template &lt;class T&gt;\nstruct W {\n   W(const T&amp;) {}\n};\ntemplate &lt;class T&gt; \nT operator + (const W&lt;T&gt;&amp; w1, const W&lt;T&gt;&amp; w2) { return T(); }\n</code></pre>\n<p>And this surprisingly cannot match for wrapped type, with simple error from gcc4.5.1 that cannot find <code>operator + (A,A)</code>:</p>\n<pre><code>struct A {};\nint main() {\n  A a1, a2;\n  A a3 = a1 + a2;\n}\n</code></pre>\n<p>I've tried to find the reason by testing non template wrapper, but this version works:</p>\n<pre><code>struct A {};\nstruct WA {\n   WA(const A&amp;) {}\n}; \nA operator + (const WA&amp; w1, const WA&amp; w2) { return A(); }\nint main() {\n  A a1, a2;\n  A a3 = a1 + a2;\n}\n</code></pre>\n<p>What is the reason of such difference of arguments matching, and what to do to make template version works?</p>\n<p><strong>[UPDATE]</strong></p>\n<p>I took your answers into consideration, and I've changed the example to be a little opposite way, still with the same results - template version is complaining for missing operator +, while non template works fine. Now I have explicit cast operator to explicit wrapper class:</p>\n<p><strong>template version</strong></p>\n<pre><code>template &lt;class T&gt;\nstruct W {\n};\ntemplate &lt;class T&gt; \nT operator + (const W&lt;T&gt;&amp; w1, const W&lt;T&gt;&amp; w2) { return T(); }\n\nstruct A {\n operator W&lt;A&gt;() const { return W&lt;A&gt;(); }\n};\n</code></pre>\n<p><strong>not template</strong></p>\n<pre><code>struct WA {\n}; \nstruct A {\n operator WA() const { return WA(); }\n};\n\nA operator + (const WA&amp; w1, const WA&amp; w2) { return A(); }\n</code></pre>\n<p>I am trying to avoid this solution:</p>\n<pre><code>A a3 = W(a1) + W(a2);\n</code></pre>\n<p>No hope for this to work?</p>\n<pre><code>A a3 = a1 + a2;\n</code></pre>\n", "Tags": "<c++><templates><operator-overloading>", "OwnerUserId": "1463922", "AnswerCount": "2"}});