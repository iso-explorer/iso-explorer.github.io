post_cb({"3109134": {"CommentCount": "4", "ViewCount": "87", "PostTypeId": "1", "LastEditorUserId": "163551", "CreationDate": "2010-06-24T10:35:14.653", "LastActivityDate": "2010-06-24T10:55:32.487", "Title": "What should the following code do and with explanations", "AcceptedAnswerId": "3109160", "LastEditDate": "2010-06-24T10:36:10.167", "Id": "3109134", "Score": "-1", "Body": "<pre><code>class A { \n public:\n  A() { } \n  ~A() { cout &lt;&lt; \"A Destructor \\n\" ; } \n};\n\nclass B :public A{ \n   public:\n   B() { } \n   virtual ~B() { cout &lt;&lt; \"B Destructor \\n\" ; } \n};\n\nclass C : public B {\n   public:\n   C() { }\n   ~C() { cout &lt;&lt; \"C Destructor \\n\"; }\n};\n\nint main()\n{\n\n   A *pointA = new A;\n   A *pointB = new B;\n   A *pointC = new C;\n\n   delete pointA;\n   delete pointB;\n   delete pointC;\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "373215", "AnswerCount": "2"}, "3109160": {"ParentId": "3109134", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It will invoke undefined behavior at the second (and third) delete, because A's destructor is not virtual. </p>\n<p>\u00a75.3.5/3:</p>\n<blockquote>\n<p id=\"so_3109134_3109160_0\">if the static type of the operand is different from its dynamic type, the\n  static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<hr>\n<p>If you make the destructor of A virtual, you get well-defined behavior, and the destructor of the dynamic type is called. (And each of those in turn calls the base destructor.) Your output would be:</p>\n<blockquote>\n<p id=\"so_3109134_3109160_1\">A destructor<br>\n  B destructor<br>\n  A destructor<br>\n  C destructor<br>\n  B destructor<br>\n  A destructor  </br></br></br></br></br></p>\n</blockquote>\n<hr>\n<p>For what it's worth, when you're that close to a compilable snippet, you should leave the includes. Also, just use <code>struct</code> instead of <code>class</code> to be concise about the <code>public</code> stuff, and leave out empty constructors.</p>\n</hr></hr>", "OwnerUserId": "87234", "LastEditorUserId": "87234", "LastEditDate": "2010-06-24T10:44:33.210", "Id": "3109160", "Score": "10", "CreationDate": "2010-06-24T10:38:13.553", "LastActivityDate": "2010-06-24T10:44:33.210"}, "3109290": {"ParentId": "3109134", "CommentCount": "0", "Body": "<p>As GMan pointed out, attempting to call the delete operator on a base pointer requires a virtual destructor for the compiler to be able to destroy subclass objects correctly. A lot of people oversimplify this to a rule like, \"If a class has virtual functions, it needs a virtual destructor.\" That is not necessarily the case; even a base class which has no virtual functions still needs a virtual destructor if you want to allow clients to delete the class through a base pointer. If you don't, the destructor should be protected and not public.</p>\n<p>There is an excellent book that describes this in detail and more called C++ Coding Standards by Herb Sutter. I recommend it as a starting point in your C++ adventures. :-)</p>\n", "OwnerUserId": "374980", "PostTypeId": "2", "Id": "3109290", "Score": "0", "CreationDate": "2010-06-24T10:55:32.487", "LastActivityDate": "2010-06-24T10:55:32.487"}, "bq_ids": {"n4140": {"so_3109134_3109160_0": {"section_id": 6107, "quality": 0.9047619047619048, "length": 19}, "so_3109134_3109160_1": {"section_id": 401, "quality": 1.0, "length": 6}}, "n3337": {"so_3109134_3109160_0": {"section_id": 5873, "quality": 0.9047619047619048, "length": 19}, "so_3109134_3109160_1": {"section_id": 389, "quality": 1.0, "length": 6}}, "n4659": {"so_3109134_3109160_0": {"section_id": 7604, "quality": 0.9047619047619048, "length": 19}, "so_3109134_3109160_1": {"section_id": 418, "quality": 1.0, "length": 6}}}});