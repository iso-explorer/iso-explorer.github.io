post_cb({"17341556": {"Id": "17341556", "PostTypeId": "2", "Body": "<p>You can use a converting constructor that is <a href=\"http://flamingdangerzone.com/cxx11/2012/06/01/almost-static-if.html\" rel=\"nofollow\">constrained</a> on conversions to <code>A</code>.</p>\n<pre><code>class B {\npublic:\n    // It doesn't hurt to keep that one\n    B(A a){};\n\n    template&lt;\n        typename T\n        , EnableIf&lt;std::is_convertible&lt;T, A&gt;&gt;...\n    &gt;\n    B(T&amp;&amp; value)\n    {\n        // How to use the value\n        A a = std::forward&lt;T&gt;(value);\n    }\n};\n\n// Now B b = foo; is valid iff A a = foo; is, except for a few exceptions\n</code></pre>\n<p>Make sure you understand the purpose of the <code>EnableIf</code> constraint. If you do not use it, you will face gnarly compilation errors, or worse: no errors at all. You should also carefully consider if making <code>B</code> convertible from potentially lots of types is at all worth it. Implicit conversions tend to make a program harder to understand, and that can quickly outweigh the apparent benefits they give.</p>\n", "LastActivityDate": "2013-06-27T11:09:55.477", "CommentCount": "0", "CreationDate": "2013-06-27T11:09:55.477", "ParentId": "17339895", "Score": "0", "OwnerUserId": "726300"}, "bq_ids": {"n4140": {"so_17339895_17348767_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 383}, "so_17339895_17348767_1": {"length": 11, "quality": 1.0, "section_id": 386}}, "n3337": {"so_17339895_17348767_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 374}, "so_17339895_17348767_1": {"length": 11, "quality": 1.0, "section_id": 377}}, "n4659": {"so_17339895_17348767_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 400}, "so_17339895_17348767_1": {"length": 11, "quality": 1.0, "section_id": 403}}}, "17339895": {"ViewCount": "289", "Body": "<p>Lets concider following code:</p>\n<pre><code>class A{\npublic:\n  A(int x){}\n};\n\nclass B{\npublic:\n  B(A a){};\n};\n\n\nint main() {\n  B b = 5;\n  return 0;\n}\n</code></pre>\n<p>And while compiling the compiler complains that:</p>\n<pre><code>/home/test/main.cpp:80: candidate constructor not viable: no known conversion from 'int' to 'A' for 1st argument\n</code></pre>\n<p>I don't want to create <code>B(int)</code> constructor - I would love the compiler to implicit convert this <code>int</code> to <code>A</code> object.</p>\n<p><strong>EDIT:</strong></p>\n<p>Direct initialisation works like this:</p>\n<pre><code>B b(5);\n</code></pre>\n<p>Is it possible to use the assigment operator instead?</p>\n", "AcceptedAnswerId": "17348767", "Title": "Implicit constructor argument conversion in C++11", "CreationDate": "2013-06-27T09:47:07.393", "Id": "17339895", "CommentCount": "4", "LastEditDate": "2013-06-27T09:53:34.827", "PostTypeId": "1", "LastEditorUserId": "889902", "LastActivityDate": "2013-06-27T16:43:50.937", "Score": "3", "OwnerUserId": "889902", "Tags": "<c++><c++11><types><compiler-construction><type-conversion>", "AnswerCount": "3"}, "17339987": {"Id": "17339987", "PostTypeId": "2", "Body": "<p>Use direct initialisation instead:</p>\n<pre><code>B b(5);\n</code></pre>\n", "LastActivityDate": "2013-06-27T09:50:22.860", "CommentCount": "6", "CreationDate": "2013-06-27T09:50:22.860", "ParentId": "17339895", "Score": "0", "OwnerUserId": "1782465"}, "17348767": {"Id": "17348767", "PostTypeId": "2", "Body": "<p>Just to be clear:</p>\n<pre><code>B b = 5;\n</code></pre>\n<p>is \"copy initialisation\" not assignment. (See <a href=\"http://www.gotw.ca/gotw/036.htm\" rel=\"nofollow\">http://www.gotw.ca/gotw/036.htm</a>). </p>\n<p>In this case, you are asking the compiler to perform two implicit user-defined conversions first, i.e. <code>int -&gt; A, A -&gt; B</code> before a temporary <code>B</code> object is passed to the copy constructor for <code>B b</code>. The compiler is allowed to elide the temporary object but semantically you are still asking the language to make two jumps across types.</p>\n<p>All implicit behaviour in programming languages is inherently scary. For the sake of a little syntactic sugar, we are asking c++ to \"do some magic to make it just work\". Unexpected type conversions can wreck havoc in large complex programmes. Otherwise, every time you wrote a new function or a new class, you would have to worry about all the other types and functions it could affect, with the side -effects rippling across your code.\nWould you really want implicit conversions from <code>int</code> -&gt; <code>apple</code> -&gt; <code>horse</code> -&gt; <code>horse_power</code> -&gt; <code>aeroplane</code>?</p>\n<p>For that reason, c++ only allows a single implicit user-defined conversion:</p>\n<p><strong>12.3 Conversions [class.conv]</strong></p>\n<blockquote>\n<p id=\"so_17339895_17348767_0\">1 Type conversions of class objects can be specified by constructors and by conversion functions. These conversions are called user-defined conversions and are used for implicit type conversions (clause 4), for initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n<p id=\"so_17339895_17348767_1\"><strong>4 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single value.</strong></p>\n</blockquote>\n<p>You are better off either with an explicit cast or \"direct initialisation\" both of which make it clear to the compiler and collaborators exactly what you are trying to do. Either the traditional or the new uniform initialisation syntax works:</p>\n<pre><code>B b(5);\nB b{5};\nB b = {5};\n</code></pre>\n", "LastActivityDate": "2013-06-27T16:43:50.937", "CommentCount": "0", "CreationDate": "2013-06-27T16:43:50.937", "ParentId": "17339895", "Score": "1", "OwnerUserId": "579584"}});