post_cb({"35389911": {"CommentCount": "8", "AcceptedAnswerId": "35390672", "PostTypeId": "1", "LastEditorUserId": "4973224", "CreationDate": "2016-02-14T08:43:40.853", "LastActivityDate": "2016-02-15T12:59:01.263", "LastEditDate": "2016-02-14T08:50:33.717", "ViewCount": "341", "FavoriteCount": "1", "Title": "Why is overloading on just one ref-qualifier not allowed?", "Id": "35389911", "Score": "12", "Body": "<p>Apparently, <strong>overloading on ref-qualifiers is not allowed</strong> \u2013 this code won't compile if you remove either <code>&amp;</code> or <code>&amp;&amp;</code> (just the tokens, not their functions):</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct S {\n    void f() &amp;  { std::cout &lt;&lt; \"Lvalue\" &lt;&lt; std::endl; }\n    void f() &amp;&amp; { std::cout &lt;&lt; \"Rvalue\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    S s;\n    s.f();   // prints \"Lvalue\"\n    S().f(); // prints \"Rvalue\"\n}\n</code></pre>\n<p>In other words, if you have two functions of the same name and type, you have to <strong>define both if you define either</strong>. I assume this is deliberate, but <strong>what's the reason</strong>? Why not allow, say, calling the <code>&amp;&amp;</code> version for rvalues if it's defined, and the \"primary\" <code>f()</code> on everything else in the following variation (and vice-versa \u2013 although that would be confusing):</p>\n<pre><code>struct S {\n    void f()    { std::cout &lt;&lt; \"Lvalue\" &lt;&lt; std::endl; }\n    void f() &amp;&amp; { std::cout &lt;&lt; \"Rvalue\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>In other words, let them act similar to template specializations with respect to the primary template.</p>\n", "Tags": "<c++><c++11><overloading><language-lawyer><rvalue>", "OwnerUserId": "4973224", "AnswerCount": "3"}, "35390672": {"ParentId": "35389911", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's not any different to the following situation:</p>\n<pre><code>struct S {};\n\nvoid g(S s);\nvoid g(S&amp; s);\n\nint main()\n{\n    S s;\n    g(s);     // ambiguous\n}\n</code></pre>\n<p>Overload resolution has always worked this way; passing by reference is not preferred to passing by value (or vice versa).   </p>\n<p>(Overload resolution for ref-qualified functions works as if it were a normal function with an implicit first parameter whose argument is <code>*this</code>; lvalue-ref qualified is like a first parameter <code>S &amp;</code>, <code>const &amp;</code> is like <code>S const &amp;</code> etc.)</p>\n<p>I guess you are saying that <code>g(s)</code> should call <code>g(S&amp;)</code> instead of being ambiguous.  </p>\n<p>I don't know the exact rationale, but overload resolution is complicated enough as it is without adding more special cases (especially ones that may silently compile to not what the coder intended).</p>\n<p>As you note in your question, the problem can be easily avoided by using the two versions <code>S &amp;</code> and <code>S &amp;&amp;</code>.</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2016-02-15T07:50:08.273", "Id": "35390672", "Score": "9", "CreationDate": "2016-02-14T10:20:33.903", "LastActivityDate": "2016-02-15T07:50:08.273"}, "35404544": {"ParentId": "35389911", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Let's start with what it means to define a basic non-static member function without any ref qualifiers.</p>\n<blockquote>\n<h3>\u00a713.3.1 [4]</h3>\n<p id=\"so_35389911_35404544_0\">For non-static member functions, the type of the implicit object parameter is</p>\n<p id=\"so_35389911_35404544_1\">\u2014 \"<strong>lvalue reference to cv X</strong>\u201d for functions declared <strong>without a ref-qualifier</strong> or with the &amp; ref-qualifier</p>\n<p id=\"so_35389911_35404544_2\">\u2014 \"rvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier</p>\n</blockquote>\n<p>But wait, there's more.</p>\n<blockquote>\n<p id=\"so_35389911_35404544_3\"><strong>[5]</strong> For non-static member functions declared without a ref-qualifier, <strong>an additional rule applies:</strong></p>\n<p id=\"so_35389911_35404544_4\">even if the implicit object parameter is not const-qualified, <strong>an rvalue can be bound to the parameter</strong> as\n  long as in all other respects the argument can be converted to the type of the implicit object parameter.</p>\n</blockquote>\n<p>Therefore</p>\n<ol>\n<li>You <em>can</em> overload for just one ref type: <a href=\"http://rextester.com/HTY55896\" rel=\"nofollow\">lvalue</a>, <a href=\"http://rextester.com/YXIIO49977\" rel=\"nofollow\">rvalue</a></li>\n<li>You <em>can't</em> overload one or the other and then also add in another that's not ref qualified, <em>because the one that's not ref qualified is defined to bind both types</em>, and hence the ambiguity.</li>\n</ol>\n", "OwnerUserId": "602372", "LastEditorUserId": "602372", "LastEditDate": "2016-02-15T10:27:32.327", "Id": "35404544", "Score": "1", "CreationDate": "2016-02-15T08:26:56.910", "LastActivityDate": "2016-02-15T10:27:32.327"}, "bq_ids": {"n4140": {"so_35389911_35403879_1": {"section_id": 568, "quality": 0.875, "length": 7}, "so_35389911_35404544_4": {"section_id": 569, "quality": 1.0, "length": 20}, "so_35389911_35404544_0": {"section_id": 568, "quality": 0.875, "length": 7}, "so_35389911_35404544_2": {"section_id": 568, "quality": 1.0, "length": 5}, "so_35389911_35403879_3": {"section_id": 568, "quality": 1.0, "length": 5}, "so_35389911_35403879_2": {"section_id": 568, "quality": 1.0, "length": 6}, "so_35389911_35404544_1": {"section_id": 568, "quality": 1.0, "length": 6}, "so_35389911_35404544_3": {"section_id": 569, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_35389911_35403879_1": {"section_id": 559, "quality": 0.875, "length": 7}, "so_35389911_35404544_4": {"section_id": 560, "quality": 1.0, "length": 20}, "so_35389911_35404544_0": {"section_id": 559, "quality": 0.875, "length": 7}, "so_35389911_35404544_2": {"section_id": 559, "quality": 1.0, "length": 5}, "so_35389911_35403879_3": {"section_id": 559, "quality": 1.0, "length": 5}, "so_35389911_35403879_2": {"section_id": 559, "quality": 1.0, "length": 6}, "so_35389911_35404544_1": {"section_id": 559, "quality": 1.0, "length": 6}, "so_35389911_35404544_3": {"section_id": 560, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_35389911_35403879_1": {"section_id": 591, "quality": 0.875, "length": 7}, "so_35389911_35404544_4": {"section_id": 592, "quality": 1.0, "length": 20}, "so_35389911_35404544_0": {"section_id": 591, "quality": 0.875, "length": 7}, "so_35389911_35404544_2": {"section_id": 591, "quality": 1.0, "length": 5}, "so_35389911_35403879_3": {"section_id": 591, "quality": 1.0, "length": 5}, "so_35389911_35403879_2": {"section_id": 591, "quality": 1.0, "length": 6}, "so_35389911_35404544_1": {"section_id": 591, "quality": 1.0, "length": 6}, "so_35389911_35404544_3": {"section_id": 592, "quality": 0.8888888888888888, "length": 8}}}, "35403879": {"ParentId": "35389911", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You can have both, or either. <a href=\"http://en.cppreference.com/w/cpp/language/member_functions\" rel=\"nofollow\">There is no specific requirement to include both if you implement the one</a>.</p>\n<p>The catch is that a member method (non-static member) that is not marked with a qualifier, is suitable for use with both lvalues and rvalues. <em>Once you overload a method with a ref-qualifier, unless you mark the others as well, you run into ambiguity issues</em>.</p>\n<blockquote>\n<p id=\"so_35389911_35403879_0\">During overload resolution, non-static cv-qualified member function of class <code>X</code> is treated as a function that takes an implicit parameter of type lvalue reference to cv-qualified <code>X</code> if it has no ref-qualifiers or if it has the lvalue ref-qualifier. Otherwise (if it has rvalue ref-qualifier), it is treated as a function taking an implicit parameter of type rvalue reference to cv-qualified <code>X</code>.</p>\n</blockquote>\n<p>So basically, if you have one method that is qualified (e.g. for an lvalue <code>&amp;</code>) and one that is not qualified, the rules are such that they are effectively both qualified and hence ambiguous.</p>\n<p>Similar rationale is applied to the <code>const</code> qualifier. You can implement a method and have one \"version\" for a <code>const</code> object, and one for a non-<code>const</code> object. The standard library containers are good examples of this, in particular the <code>begin()</code>, <code>end()</code> and other iterator related methods.</p>\n<p>One particular use case is when the logic applied to the method is different between when the object is a temporary (or expiring) object and when it is not. You may wish to optimise away certain calls and data processing internally if you know the lifetime is about to end.</p>\n<p>Another is to limit the use of a method to lvalues. A certain piece of application or object logic may not make sense or be useful if the entity is about to expire or is a temporary.</p>\n<hr>\n<p>The wording in the standard (taken from the draft N4567) from \u00a713.4.1/4 is:</p>\n<blockquote>\n<p id=\"so_35389911_35403879_1\">For non-static member functions, the type of the implicit object parameter is</p>\n<ul>\n<li><p id=\"so_35389911_35403879_2\">\u201clvalue reference to cv X\u201d for functions declared without a ref-qualifier or with the &amp; ref-qualifier</p></li>\n<li><p id=\"so_35389911_35403879_3\">\u201crvalue reference to cv X\u201d for functions declared with the &amp;&amp; ref-qualifier</p></li>\n</ul>\n</blockquote>\n</hr>", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-02-15T12:59:01.263", "Id": "35403879", "Score": "3", "CreationDate": "2016-02-15T07:40:49.427", "LastActivityDate": "2016-02-15T12:59:01.263"}});