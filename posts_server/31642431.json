post_cb({"31642806": {"ParentId": "31642431", "CommentCount": "0", "Body": "<p>You can't do this.  </p>\n<p>According to the standard (12.6.2/10) the order of initialisation is: </p>\n<blockquote>\n<p id=\"so_31642431_31642806_0\">\u2014 (...)</p>\n<p id=\"so_31642431_31642806_1\">\u2014 Then, direct base classes are initialized in declaration\n  order as they appear in the base-specifier-list (regardless of the\n  order of the mem-initializers).</p>\n<p id=\"so_31642431_31642806_2\">\u2014 Then, non-static data members are\n  initialized in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers). </p>\n<p id=\"so_31642431_31642806_3\">\u2014 Finally,\n  the compound-statement of the constructor body is executed.</p>\n</blockquote>\n<p>So in your <code>Child</code> constructor mem-initialization list, for the <code>Parent</code> initializer you <strong>can't use anything that relies on <code>Child</code> member variables</strong> because these are unitialized at that moment.  </p>\n<p>You could however use arguments of the Child constructor, for example:  </p>\n<pre><code>Child::Child(int c) : Parent(c.getImage()), childCamera(c) {}\n</code></pre>\n<p>provided of course that every copy of a Camera object would return the same image as the original object.  </p>\n<p>Another alternative could be to use multiple inheritance from an auxiliary class (to use the second dash of the standard quote above).  But this i smore tricky and anyway would also require copy of camera object.   </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "31642806", "Score": "0", "CreationDate": "2015-07-26T22:58:32.773", "LastActivityDate": "2015-07-26T22:58:32.773"}, "31642431": {"CommentCount": "3", "ViewCount": "172", "PostTypeId": "1", "LastEditorUserId": "595605", "CreationDate": "2015-07-26T22:08:13.093", "LastActivityDate": "2015-07-27T02:21:57.117", "Title": "How to initialize parent using member of child?", "FavoriteCount": "1", "LastEditDate": "2015-07-26T22:18:57.823", "Id": "31642431", "Score": "2", "Body": "<p>I have a class that I need to initialize: </p>\n<pre><code>//Parent.h\nclass Parent {\npublic:\n    Parent(Image image);\nprivate:\n    const Image parentImage;\n}\n\n//Parent.cpp\nParent::Parent(Image image) : parentImage(image) {}\n\n//Child.h\n\n#import \"Parent.h\"\n\nclass Child : public Parent {\npublic:\n    Child(int c);\nprivate:\n    Camera childCamera;\n}\n\n//Child.cpp\nChild::Child(int c) : Parent(this-&gt;childCamera.getImage()), childCamera(c) {}\n</code></pre>\n<p>The <code>Camera</code> needs to be initialized before images can be retrieved from it. The <code>Parent</code> stores an image from the camera, which is <code>const</code>, the child stores the <code>Camera</code>. How can I create a <code>Child</code>? I can't change <code>Parent</code>, as there are other subclasses that initialize <code>Parent</code> in other ways. I can change <code>Child</code>, but <code>Camera</code> can't be copied, and the <code>Child</code> does need to store the <code>Camera</code>.</p>\n<p>EDIT: I could add constructors to <code>Parent</code>, if that is the cleanest solution.</p>\n", "Tags": "<c++><inheritance><initialization>", "OwnerUserId": "595605", "AnswerCount": "3"}, "31644075": {"ParentId": "31642431", "CommentCount": "0", "Body": "<p>no you can't. you can't use anything that relies on Child for Parent.</p>\n", "OwnerUserId": "4976170", "PostTypeId": "2", "Id": "31644075", "Score": "0", "CreationDate": "2015-07-27T02:21:57.117", "LastActivityDate": "2015-07-27T02:21:57.117"}, "bq_ids": {"n4140": {"so_31642431_31642806_2": {"section_id": 438, "quality": 1.0, "length": 15}, "so_31642431_31642806_3": {"section_id": 438, "quality": 1.0, "length": 5}, "so_31642431_31642806_1": {"section_id": 438, "quality": 1.0, "length": 13}}, "n3337": {"so_31642431_31642806_2": {"section_id": 429, "quality": 1.0, "length": 15}, "so_31642431_31642806_3": {"section_id": 429, "quality": 1.0, "length": 5}, "so_31642431_31642806_1": {"section_id": 429, "quality": 1.0, "length": 13}}, "n4659": {"so_31642431_31642806_1": {"section_id": 458, "quality": 1.0, "length": 13}, "so_31642431_31642806_3": {"section_id": 458, "quality": 1.0, "length": 5}, "so_31642431_31642806_2": {"section_id": 458, "quality": 1.0, "length": 15}}}, "31643429": {"ParentId": "31642431", "CommentCount": "1", "Body": "<p>Given all the design constraints you've listed, one reasonable solution would be to construct a Camera externally to the Child and then pass it into the Child's constructor. The Child would then take ownership of it.</p>\n<p>So the class could be written like:</p>\n<pre><code>class Child : public Parent {\npublic:\n    Child(Camera* camera);\nprivate:\n    std::unique_ptr&lt;Camera&gt; childCamera;\n}\n\n//Child.cpp\nChild::Child(Camera* camera) \n    : Parent(camera-&gt;getImage()), childCamera(camera) \n{}\n</code></pre>\n<p>And then used as:</p>\n<pre><code>Camera* camera = new Camera;\nChild child(camera);\n</code></pre>\n", "OwnerUserId": "126027", "PostTypeId": "2", "Id": "31643429", "Score": "0", "CreationDate": "2015-07-27T00:32:48.517", "LastActivityDate": "2015-07-27T00:32:48.517"}});