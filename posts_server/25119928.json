post_cb({"25119928": {"CommentCount": "0", "AcceptedAnswerId": "25120059", "CreationDate": "2014-08-04T13:32:58.383", "LastActivityDate": "2014-08-04T13:52:15.883", "PostTypeId": "1", "ViewCount": "75", "FavoriteCount": "0", "Title": "Different Behaviour: Calling Function Directly vs. Through non-static member pointer", "Id": "25119928", "Score": "2", "Body": "<p><strong>Question:</strong></p>\n<p>Although I knew about function pointer, I can't understand that what makes these two function act differently in <code>Derived</code> class:</p>\n<p>I)  <code>StartPrintThroughFuncPtr()</code></p>\n<p>II) <code>StartPrint()</code></p>\n<p>Here is <strong>Full Code</strong>, plus <strong>Its output</strong> in comment:</p>\n<pre><code>#include \"iostream\"\n\nclass Base\n{\n    (void)(Base::*callee)(void);\n    virtual void Print(){std::cout&lt;&lt;\"Print: Base\"&lt;&lt;std::endl;}\n\npublic:\n    void StartPrintThroughFuncPtr(){\n        callee = &amp;Base::Print;\n        (this-&gt;*callee)();\n    }\n\n    void StartPrint(){\n        Base::Print();\n    }\n};\n\nclass Derived : public Base\n{\n    virtual void Print(){std::cout&lt;&lt;\"Print: Derived\"&lt;&lt;std::endl;}\n};\n\nvoid main()\n{\n    Base *basePtr = new Base;\n    basePtr-&gt;StartPrintThroughFuncPtr();    //  ==&gt; \"Print: Base\"\n    basePtr-&gt;StartPrint();                  //  ==&gt; \"Print: Base\"\n\n    Derived *derivedPtr = new Derived;\n    derivedPtr-&gt;StartPrintThroughFuncPtr(); //  ==&gt; \"Print: Derived\"\n    derivedPtr-&gt;StartPrint();               //  ==&gt; \"Print: Base\"\n}\n</code></pre>\n<p>Thanks =)</p>\n", "Tags": "<c++><function-pointers>", "OwnerUserId": "550478", "AnswerCount": "2"}, "25120076": {"ParentId": "25119928", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Pointers to member function support polymorphic behavior. When you create a pointer to a virtual function, the call is dispatched to the implementation that is based on the run-time type of the object through which the function is called (in your case, that's <code>basePtr</code> or <code>derivedPtr</code>). Scope resolution operator does not matter there, because the function pointer to a virtual function does not fully define a target.</p>\n<blockquote>\n<p id=\"so_25119928_25120076_0\">C++11 standard, section 4.11.2: A prvalue of type \u201cpointer to member of B of type cv T\u201d, where B is a class type, can be converted to a prvalue of type \u201cpointer to member of D of type cv T\u201d, where D is a derived class (Clause 10) of B. [...] <strong>The result of the conversion refers to the same member as the pointer to member before the conversion took place, but it refers to the base class member as if it were a member of the derived class.</strong> (emphasis added)</p>\n</blockquote>\n<p><code>StartPrint</code>, on the other hand, calls the implementation in the <code>Base</code> class directly, through its scope resolution operator.</p>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2014-08-04T13:52:15.883", "Id": "25120076", "Score": "2", "CreationDate": "2014-08-04T13:40:47.287", "LastActivityDate": "2014-08-04T13:52:15.883"}, "bq_ids": {"n4140": {"so_25119928_25120076_0": {"section_id": 43, "quality": 0.8666666666666667, "length": 39}}, "n3337": {"so_25119928_25120076_0": {"section_id": 40, "quality": 0.8666666666666667, "length": 39}}, "n4659": {"so_25119928_25120076_0": {"section_id": 43, "quality": 0.8666666666666667, "length": 39}}}, "25120059": {"ParentId": "25119928", "CommentCount": "2", "Body": "<p>A pointer to a virtual function actually stores an offset in virtual function table, not a direct pointer to a function. That's why an invokation through it is virtual.</p>\n", "OwnerUserId": "2040251", "PostTypeId": "2", "Id": "25120059", "Score": "3", "CreationDate": "2014-08-04T13:39:40.507", "LastActivityDate": "2014-08-04T13:39:40.507"}});