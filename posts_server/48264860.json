post_cb({"bq_ids": {"n4140": {"so_48264860_48264954_0": {"length": 12, "quality": 0.8, "section_id": 7041}}, "n3337": {"so_48264860_48264954_0": {"length": 12, "quality": 0.8, "section_id": 6786}}, "n4659": {"so_48264860_48264954_0": {"length": 15, "quality": 1.0, "section_id": 8538}}}, "48264954": {"Id": "48264954", "PostTypeId": "2", "Body": "<p>The compiler is not required to diagnose violations of the <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow noreferrer\">One Definition Rule</a>, so your program exhibits undefined behavior.</p>\n<p>From [basic.def.odr]</p>\n<blockquote>\n<p id=\"so_48264860_48264954_0\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in\n  that program outside of a discarded statement; <strong>no diagnostic required</strong>.</p>\n</blockquote>\n<p>IIRC some linkers can warn about these things, but again there's no requirement.</p>\n<p>Best to simply move one of those functions into a different namespace.</p>\n", "LastActivityDate": "2018-01-15T14:25:42.807", "Score": "3", "CreationDate": "2018-01-15T14:25:42.807", "ParentId": "48264860", "CommentCount": "0", "OwnerUserId": "27678"}, "48264860": {"ViewCount": "59", "Body": "<p>I've used <code>MATCHER_P</code> from gmock to create some matchers in different *.cpp test files. They happened to be defined in the same namespace and had the same name. When running the tests, I've got a segfault, because a test from <code>fooTest.cpp</code> used a matcher from <code>barTest.cpp</code>, even though a matcher with the same name was declared in <code>fooTest.cpp</code> and <code>barTest.cpp</code> was obvoiusly not included.</p>\n<p>What is going on here? Why does the test from <code>fooTest.cpp</code> even see the matcher declared in <code>barTest.cpp</code>? Shouldn't it be confined to the scope of the file that it's declared in? And if not why am I not getting a compilation error that says something about an \"ambiguous call?\"</p>\n", "AcceptedAnswerId": "48265422", "Title": "Two objects with the same name in the same namespace in different cpp files", "CreationDate": "2018-01-15T14:19:04.290", "LastActivityDate": "2018-01-15T14:55:22.633", "CommentCount": "1", "LastEditDate": "2018-01-15T14:28:39.393", "PostTypeId": "1", "LastEditorUserId": "27678", "Id": "48264860", "Score": "1", "OwnerUserId": "6646922", "Tags": "<c++><googletest><gmock>", "AnswerCount": "2"}, "48265422": {"Id": "48265422", "PostTypeId": "2", "Body": "<p>Using my crystal ball, your problem is that you have to identically named inline methods or functions.  Functions defined in the body of a class <em>are implicitly inline</em>.</p>\n<p>When you have two different inline functions with the same name, the linker silently discards all but one of them.  Such names include the names of the class they are part of.</p>\n<p>If the implementation of one or the other is different, this leads to problems.  One classic problem is inlined non-trivial zero argument constructors for objects of different size; one of them is discarded, and now you are clearing the wrong amount of memory for the wrong class.</p>\n<p>This could be laid at the feet of a one definition rule violation -- the very existence of your two classes is a ODR violation and makes your program ill formed, no diagnostic required.</p>\n<p>But knowing the step that actually caused your program to keel over is useful.</p>\n<p>The fix this this is to <em>always</em> define <em>everything</em> in a cpp file within an anonymous namespace.  Anything that defines a symbol in a header file should fully qualify it.  Now no definitions in one cpp file can collide with definitions in another accidentally.</p>\n", "LastActivityDate": "2018-01-15T14:55:22.633", "Score": "2", "CreationDate": "2018-01-15T14:55:22.633", "ParentId": "48264860", "CommentCount": "0", "OwnerUserId": "1774667"}});