post_cb({"bq_ids": {"n4140": {"so_41928634_41928634_2": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_41928634_41928634_5": {"section_id": 382, "quality": 0.8823529411764706, "length": 15}, "so_41928634_41928634_1": {"section_id": 381, "quality": 0.7857142857142857, "length": 11}, "so_41928634_41928634_3": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_41928634_41928634_6": {"section_id": 382, "quality": 0.5555555555555556, "length": 20}, "so_41928634_41928634_4": {"section_id": 382, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_41928634_41928634_2": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_41928634_41928634_5": {"section_id": 373, "quality": 0.8823529411764706, "length": 15}, "so_41928634_41928634_1": {"section_id": 372, "quality": 0.7857142857142857, "length": 11}, "so_41928634_41928634_3": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_41928634_41928634_6": {"section_id": 373, "quality": 0.5555555555555556, "length": 20}, "so_41928634_41928634_4": {"section_id": 373, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_41928634_41928634_1": {"section_id": 396, "quality": 0.7142857142857143, "length": 10}, "so_41928634_41928634_2": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_41928634_41928634_6": {"section_id": 397, "quality": 0.5277777777777778, "length": 19}, "so_41928634_41928634_4": {"section_id": 397, "quality": 0.7058823529411765, "length": 12}, "so_41928634_41928634_5": {"section_id": 397, "quality": 0.8823529411764706, "length": 15}}}, "41928634": {"CommentCount": "6", "ViewCount": "113", "PostTypeId": "1", "LastEditorUserId": "434551", "CreationDate": "2017-01-30T03:28:54.663", "LastActivityDate": "2017-05-26T19:13:27.320", "Title": "C++11 scoping and lifetime of temporary bound to a (const) reference (GCC)", "LastEditDate": "2017-05-26T19:13:27.320", "Id": "41928634", "Score": "1", "Body": "<p>I have the following questions related to the same situation (not in general):</p>\n<ul>\n<li>Why does the compiler not produce a warning when a temporary is bound\nto a reference?</li>\n<li>How does lifetime extension of a temporary work (when it is bound to\na reference)?</li>\n<li>How to interpret / understand the C++ standard (C++11)?</li>\n<li>Is this a bug (in the compiler)? Should it be?</li>\n</ul>\n<p>So this is what we are talking about:</p>\n<pre><code>struct TestRefInt {\n    TestRefInt(const int&amp; a) : a_(a) {};\n    void DoSomething() {    cout &lt;&lt; \"int:\" &lt;&lt; a_ &lt;&lt; endl;  }\nprotected:\n    const int&amp; a_;\n};\n</code></pre>\n<p>Should <code>TestRefInt tfi(55);</code> and <code>tfi.DoSomething();</code> work? How and where?\nSo here is a code</p>\n<pre><code>TestRefInt tfi(55);\n\nint main() {\n    TestRefInt ltfi(8);\n\n    tfi.DoSomething();\n    ltfi.DoSomething();\n    return 0;\n}\n</code></pre>\n<p>What should this do?</p>\n<p>Here I will elaborate some more.</p>\n<p>Consider this real world (simplified) example. How does it look like to a novice/beginner C++ programmer? Does this make sense?</p>\n<p>(you can skip the code the issue is the same as above) </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass TestPin //: private NonCopyable\n{\n    public:\n        constexpr TestPin(int pin) : pin_(pin) {}\n        inline void Flip()   const {\n            cout &lt;&lt; \" I'm flipping out man : \" &lt;&lt; pin_ &lt;&lt; endl;\n        }\n    protected:\n        const int pin_;\n};\n\nclass TestRef {\npublic:\n    TestRef(const TestPin&amp; a) : a_(a) {};\n    void DoSomething() {    a_.Flip();  }\nprotected:\n    const TestPin&amp; a_;\n};\n\nTestRef g_tf(1); \n\nint main() {\n    TestRef tf(2);\n\n    g_tf.DoSomething();\n    tf.DoSomething();\n\n    return 0;\n}\n</code></pre>\n<p>Command line:</p>\n<pre><code>/** Compile:\nInfo: Internal Builder is used for build\ng++ -std=c++11 -O0 -g3 -Wall -Wextra -Wconversion -c -fmessage-length=0 -o \"src\\\\Scoping.o\" \"..\\\\src\\\\Scoping.cpp\" \ng++ -o Scoping.exe \"src\\\\Scoping.o\" \n13:21:39 Build Finished (took 346ms)\n */\n</code></pre>\n<p>Output:</p>\n<pre><code>/** \n I'm flipping out man : 2293248\n I'm flipping out man : 2\n */\n</code></pre>\n<p>The issue:\n<code>TestRef g_tf(1); /// shouldn't the reference to temporary extend it's life in</code> global scope too?</p>\n<p>What does the standard says?</p>\n<p>From <a href=\"https://stackoverflow.com/questions/19864176/how-would-auto-extend-the-life-time-of-the-temporary-object\">How would auto&amp;&amp; extend the life-time of the temporary object?</a></p>\n<blockquote>\n<p id=\"so_41928634_41928634_0\">Normally, a temporary object lasts only until the end of the full\n  expression in which it appears.   However, C++ deliberately specifies\n  that binding a temporary object to a reference to const   on the stack\n  lengthens the lifetime of the temporary to the lifetime of the\n  reference itself</p>\n</blockquote>\n<pre><code>  ^^^^^\n</code></pre>\n<p>Globals are not allocated on stack, so lifetime is not extended.  However, the compiler does not produce any warning message whatsoever! Shouldn\u2019t it at least do that? </p>\n<p>But my main point is: from a usability standpoint (meaning as the user of C++, GCC as a programmer) it would be useful if the same principle would be extended to not just stack, but to global scope, extending the lifetime (making global temporaries \u201cpermanent\u201d).</p>\n<p>Sidenote:\nThe problem is further complicated by the fact that the <code>TestRef g_tf(1);</code> is really <code>TestRef g_tf{ TestPin{1} };</code> but the temporary object is not visible in the code, and without looking at the constructor declaration it looks like the constructor is called by an integer, and that rarely produces this kind of error. </p>\n<p>As far as I know the only way to fix the problem is to disallow temporaries in initialization by deleting <code>TestRefInt(const int&amp;&amp; a) =delete;</code> constructor. But this also disallows it on stack, where lifetime extension worked.</p>\n<p>But the previous quote is not exactly what the C++11 standard say. The relevant parts of the C++11 Standard are 12.2 p4 and p5:</p>\n<blockquote>\n<p id=\"so_41928634_41928634_1\">4 - There are two contexts in which temporaries are destroyed at a\n  different point than the end of the full expression. The first context\n  is [...] </p>\n<p id=\"so_41928634_41928634_2\">5 - The second context is when a reference is bound to a\n  temporary. The temporary to which the reference is bound or the\n  temporary that is the complete object of a subobject to which the\n  reference is bound persists for the lifetime of the reference except: </p>\n<p id=\"so_41928634_41928634_3\">\u2014 A temporary bound to a reference member in a constructor\u2019s\n  ctor-initializer (12.6.2) persists until the constructor exits. </p>\n<p id=\"so_41928634_41928634_4\">\u2014 A temporary bound to a reference parameter in a function call (5.2.2)\n  persists until the completion of the full-expression containing the\n  call. \u00a7 12.2 245 c ISO/IEC N3337 </p>\n<p id=\"so_41928634_41928634_5\">\u2014 The lifetime of a temporary bound\n  to the returned value in a function return statement (6.6.3) is not\n  extended; the temporary is destroyed at the end of the full-expression\n  in the return statement. </p>\n<p id=\"so_41928634_41928634_6\">\u2014 A temporary bound to a reference in a\n  new-initializer (5.3.4) persists until the completion of the\n  full-expression containing the new-initializer. [Example: struct S {\n  int mi; const std::pair&amp; mp; }; S a { 1, {2,3} }; S* p = new S{ 1,\n  {2,3} }; // Creates dangling reference \u2014 end example ] [ Note: This\n  may introduce a dangling reference, and implementations are encouraged\n  to issue a warning in such a case. \u2014 end note ]</p>\n</blockquote>\n<p>My English and understanding of the standard is not good enough, so what exception is this?\n The \u201c\u2014 A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits.\u201d or \u201creference parameter in a function call\u201d does not mention anything about allocation on stack or in global scope. The other exceptions do not seem to apply. Am I wrong?</p>\n<p>Which one is this, or none of them? </p>\n<p>We have a temporary in a function call (the constructor) and then a reference to \nthe temporary is bound to a member reference in the initializer. Is this undefined behavior? Or the exception still applies, and the temporary should be destroyed? (or both)</p>\n<p>What about this?</p>\n<pre><code>struct TestRefIntDirect {\n    TestRefIntDirect(int a) : a_(a) {};\n    void DoSomething() {    cout &lt;&lt; \"int:\" &lt;&lt; a_ &lt;&lt; endl;  }\nprotected:\n    const int&amp; a_;\n};\n</code></pre>\n<p>One less reference, same behavior.</p>\n<p>Why does it work in one case (instantiation inside a function) versus in other case (in global scope)?</p>\n<p>Does GCC not \u201cdestroy\u201d one of them by \u201caccident\u201d?</p>\n<p>My understanding is that none of them should work, the temporary should not persist as the standard says. It seems GCC just \"lets\" you access not persisting objects (sometimes). I guess that the standard does not specify what the compiler should warn about, but can we agree that it should? (in other cases it does warn about \u2018returning reference to temporary\u2019) I think it should here too.</p>\n<p>Is this a bug or maybe there should be a feature request somewhere? </p>\n<p>It seems to me like GCC says \u201cWell, you shouldn\u2019t touch this cookie, but I will leave it here for you and not warn anyone about it.\u201d ...which I don\u2019t like.</p>\n<p>This thing others reference about stack I did not find in the standard, where is it coming from? Is this misinformation about the standard? Or is this a consequence of something in the standard? (Or is this just implementation coincidence, that the temporary is not overwritten and can be referenced, because it happened to be on the stack? Or is this compiler defined behavior, extension?)</p>\n<p>The more I know C++ the more it seems that every day it is handing me a gun to shoot myself in the foot with it\u2026</p>\n<p>I would like to be warned by the compiler if I\u2019m doing something wrong, so I can fix it. Is that too much to ask?</p>\n<p>Other related posts:</p>\n<p><a href=\"https://stackoverflow.com/questions/17362673/temporary-lifetime-extension\">Temporary lifetime extension</a></p>\n<p><a href=\"https://stackoverflow.com/questions/4522900/c-constant-reference-to-temporary\">C++: constant reference to temporary</a></p>\n<p><a href=\"https://stackoverflow.com/questions/2784262/does-a-const-reference-prolong-the-life-of-a-temporary\">Does a const reference prolong the life of a temporary?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/11560339/returning-temporary-object-and-binding-to-const-reference\">Returning temporary object and binding to const reference</a></p>\n<p>I didn\u2019t want to write this much. If you read it all, thanks.</p>\n", "Tags": "<c++><c++11><gcc><reference><temporary-objects>", "OwnerUserId": "814749", "AnswerCount": "0"}});