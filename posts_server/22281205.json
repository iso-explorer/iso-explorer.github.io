post_cb({"22281800": {"ParentId": "22281205", "CommentCount": "0", "Body": "<p><code>A</code> is an alias template, and it essentially specializes to a typedef-name. <code>A&lt;int&gt;</code> is like a typedef for <code>int *</code>.</p>\n<p><code>C&lt;A, A&lt;int&gt;&gt;</code> is the same as <code>C&lt;A, int *&gt;</code>. The parameter <code>X</code> gets <code>A</code> and the parameter <code>Y</code> gets <code>int *</code>. To deduce that <code>Z</code> in the partial specialization should be <code>int</code>, the compiler would have to inspect inside the alias definition. That is not how aliases work. The definition is a non-deduced context, even if substituting the alias definition into its indirect use <code>X&lt;Z&gt;</code> in the partial specialization would produce a deduced context. Moreover, that deduction would need to be done speculatively to determine that <code>A</code> can even be <code>X</code> in the first place. Tackling this problem would be a huge burden of complexity.</p>\n<p>As you mentioned on the std-discussion list, \"An alias template name is never deduced.\"</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "22281800", "Score": "1", "CreationDate": "2014-03-09T11:48:29.400", "LastActivityDate": "2014-03-09T11:48:29.400"}, "22281205": {"CommentCount": "0", "AcceptedAnswerId": "22281608", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2014-03-09T10:43:04.863", "LastActivityDate": "2014-03-09T12:00:37.123", "LastEditDate": "2014-03-09T10:54:42.890", "ViewCount": "207", "FavoriteCount": "1", "Title": "C++11 alias template as template template argument in specialization?", "Id": "22281205", "Score": "2", "Body": "<p>Why doesn't the follow C++11 program compile?</p>\n<pre><code>template&lt;template&lt;typename&gt; class X, typename Y&gt; struct C;\ntemplate&lt;template&lt;typename&gt; class X, typename Z&gt; struct C&lt;X, X&lt;Z&gt;&gt; {};\n\ntemplate&lt;typename T&gt; using A = T*;\n\nint main()\n{\n    C&lt;A, A&lt;int&gt;&gt; c;\n}\n</code></pre>\n<p>The error is:</p>\n<pre><code>aggregate \u2018C&lt;A, int*&gt; c\u2019 has incomplete type and cannot be defined\n</code></pre>\n<p><strong>Why doesn't the partial specialization of <code>C</code> match <code>C&lt;A, A&lt;int&gt;&gt;</code>?</strong></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1131467", "AnswerCount": "3"}, "22281302": {"ParentId": "22281205", "CommentCount": "1", "Body": "<p><code>A&lt;int&gt;</code> <em>is</em> <code>int</code>, so <code>C&lt;A, A&lt;int&gt;&gt;</code> <em>is</em> <code>C&lt;A, int&gt;</code>. The specialization cannot match what you want because it cannot see <code>A&lt;int&gt;</code>.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "22281302", "Score": "1", "CreationDate": "2014-03-09T10:54:36.907", "LastActivityDate": "2014-03-09T10:54:36.907"}, "22281608": {"ParentId": "22281205", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>I <em>think</em> that 14.5.7 Alias templates:</p>\n<blockquote>\n<p id=\"so_22281205_22281608_0\">When a <em>template-id</em> refers to the specialization of an alias template, it is equivalent to the associated type obtained by substitution of its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of the alias template.</p>\n</blockquote>\n<p>would apply, so <code>X&lt;Z&gt;</code> would be interpreted as <code>Z*</code> as soon as <code>X</code> is known to be an alias template. The syntax for a partial specialisation does indeed use the <em>template-id</em> grammar rule. However, template argument substitution takes place as the last step in template argument deduction, only once all template arguments have been deduced.</p>\n<blockquote>\n<p id=\"so_22281205_22281608_1\"><strong>14.5.5.1 Matching of class template partial specializations [temp.class.spec.match]</strong></p>\n<p id=\"so_22281205_22281608_2\">2 A partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list (14.8.2).</p>\n<p id=\"so_22281205_22281608_3\"><strong>14.8.2 Template argument deduction [temp.deduct]</strong></p>\n<p id=\"so_22281205_22281608_4\">5 When all template arguments have been deduced or obtained from default template arguments, all uses of template parameters in the template parameter list of the template and the function type are replaced with the corresponding deduced or default argument values.</p>\n</blockquote>\n<p>Without template argument substitution of <code>X</code>, <code>Z</code> cannot be deduced. So, the specialisation does not match.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2014-03-09T12:00:37.123", "Id": "22281608", "Score": "4", "CreationDate": "2014-03-09T11:29:01.770", "LastActivityDate": "2014-03-09T12:00:37.123"}, "bq_ids": {"n4140": {"so_22281205_22281608_4": {"section_id": 297, "quality": 1.0, "length": 27}, "so_22281205_22281608_2": {"section_id": 144, "quality": 0.9473684210526315, "length": 18}, "so_22281205_22281608_0": {"section_id": 166, "quality": 1.0, "length": 17}, "so_22281205_22281608_1": {"section_id": 92, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_22281205_22281608_4": {"section_id": 288, "quality": 1.0, "length": 27}, "so_22281205_22281608_2": {"section_id": 138, "quality": 0.9473684210526315, "length": 18}, "so_22281205_22281608_0": {"section_id": 160, "quality": 1.0, "length": 17}, "so_22281205_22281608_1": {"section_id": 87, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_22281205_22281608_4": {"section_id": 304, "quality": 1.0, "length": 27}, "so_22281205_22281608_2": {"section_id": 148, "quality": 0.9473684210526315, "length": 18}, "so_22281205_22281608_1": {"section_id": 95, "quality": 0.5714285714285714, "length": 4}, "so_22281205_22281608_0": {"section_id": 170, "quality": 1.0, "length": 17}}}});