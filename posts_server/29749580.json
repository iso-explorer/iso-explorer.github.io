post_cb({"29749580": {"CommentCount": "6", "ViewCount": "86", "PostTypeId": "1", "LastEditorUserId": "3998522", "CreationDate": "2015-04-20T13:40:25.277", "LastActivityDate": "2015-04-20T14:07:08.943", "Title": "Is it not possible for an overloaded operator= returning void be a copy assignmnent operator?", "AcceptedAnswerId": "29750200", "LastEditDate": "2015-04-20T13:42:38.020", "Id": "29749580", "Score": "1", "Body": "<p>Referring to the page at <a href=\"http://en.cppreference.com/w/cpp/language/as_operator\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/as_operator</a>, copy assignment operators, as automatically generated when needed and possible by the compiler, returns an lvalue reference of the type of itself.</p>\n<p>So when I define an overloaded operator as below,</p>\n<pre><code>void operator=(T&amp; t)\n</code></pre>\n<p>Is there still a chance that the compiler will implicitly define a default copy assignment operator?</p>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "3998522", "AnswerCount": "2"}, "29750200": {"ParentId": "29749580", "CommentCount": "1", "Body": "<p>That's a copy-assignment operator, as specified by the language standard, in C++11 [class.copy]/17:</p>\n<blockquote>\n<p id=\"so_29749580_29750200_0\">A user-declared copy assignment operator <code>X::operator=</code> is a non-static non-template member function of class <code>X</code> with exactly one parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>.</p>\n</blockquote>\n<p>The return type doesn't affect whether it's considered to be a copy-assignment operator. It only affects what you can do with the result of an assignment expression.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "29750200", "Score": "2", "CreationDate": "2015-04-20T14:07:08.943", "LastActivityDate": "2015-04-20T14:07:08.943"}, "bq_ids": {"n4140": {"so_29749580_29749828_1": {"section_id": 466, "quality": 0.6842105263157895, "length": 13}, "so_29749580_29750200_0": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_29749580_29749828_1": {"section_id": 457, "quality": 0.6842105263157895, "length": 13}, "so_29749580_29750200_0": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_29749580_29749828_1": {"section_id": 489, "quality": 0.7368421052631579, "length": 14}, "so_29749580_29750200_0": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}}}, "29749828": {"ParentId": "29749580", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/as_operator\" rel=\"nofollow\">C++ Reference</a> (As you found out yourself) declares that:</p>\n<blockquote>\n<p id=\"so_29749580_29749828_0\">If no user-defined copy assignment operators are provided for a class type (struct, class, or union), the compiler will always declare one as an inline public member of the class.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_29749580_29749828_1\">A copy assignment operator of class T is a non-template non-static member function with the name operator= that takes exactly one parameter of type T, T&amp;, const T&amp;, volatile T&amp;, or const volatile T&amp;</p>\n</blockquote>\n<p>So in other words: as soon as you declare your own copy assignment operator (which takes a T&amp; parameter), the compiler won't add an implicit one.</p>\n<p>There's still the question why to return void however... (C++ coding guidelines propose to return a reference to self)</p>\n", "OwnerUserId": "3772383", "LastEditorUserId": "3772383", "LastEditDate": "2015-04-20T13:54:59.500", "Id": "29749828", "Score": "1", "CreationDate": "2015-04-20T13:51:09.797", "LastActivityDate": "2015-04-20T13:54:59.500"}});