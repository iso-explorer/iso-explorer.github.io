post_cb({"20478193": {"ViewCount": "944", "Body": "<p>I do not understand why this code compiles without error:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nstruct Test\n{\n    static constexpr T f() {return T();} \n};\n\nint main()\n{\n    Test&lt;void&gt; test;\n    test.f(); // Why not an error?\n    return 0;\n}\n</code></pre>\n<p>Is it ok according to the standard, or is it a compiler tolerance?</p>\n", "AcceptedAnswerId": "20478796", "Title": "Returning a void?", "CreationDate": "2013-12-09T18:45:20.893", "Id": "20478193", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-12-14T12:39:34.497", "Score": "23", "OwnerUserId": "882932", "Tags": "<c++><templates><c++11><return><void>", "AnswerCount": "3"}, "20478435": {"Id": "20478435", "PostTypeId": "2", "Body": "<p>See @Shafik Yaghmour's answer for the full info.</p>\n<p>The following paragraph forbids this for non-templates (7.1.5(3)):</p>\n<blockquote>\n<p id=\"so_20478193_20478435_0\">The definition of a <code>constexpr</code> function shall satisfy the following constraints:</p>\n<ul>\n<li><p id=\"so_20478193_20478435_1\">[...]</p></li>\n<li><p id=\"so_20478193_20478435_2\">its return type shall be a literal type or a reference to literal type</p></li>\n</ul>\n</blockquote>\n<p>To elaborate, a literal type is defined in 3.9(10) as a scalar type or a composition of literal type objects in an array or struct. <code>void</code> is not a scalar type by 3.9(9).</p>\n", "LastEditorUserId": "542190", "LastActivityDate": "2013-12-09T19:17:02.583", "Score": "6", "CreationDate": "2013-12-09T18:56:14.427", "ParentId": "20478193", "CommentCount": "5", "OwnerUserId": "542190", "LastEditDate": "2013-12-09T19:17:02.583"}, "20478496": {"Id": "20478496", "PostTypeId": "2", "Body": "<p>Your function returns the value of <code>void()</code>, you are not returning from a void function per se. You are returning a <code>NULL</code> value. What you are doing is equivalent to this:</p>\n<pre><code>void f() { return void(); }\n</code></pre>\n<p>This returns a void value, the only void value. you can't return anything else from a void function because it will be of a different type.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-12-10T00:30:47.637", "Score": "1", "CreationDate": "2013-12-09T18:58:55.647", "ParentId": "20478193", "CommentCount": "4", "OwnerUserId": "3084096", "LastEditDate": "2013-12-10T00:30:47.637"}, "bq_ids": {"n4140": {"so_20478193_20478435_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5419}, "so_20478193_20478796_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5419}, "so_20478193_20478796_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6000}, "so_20478193_20478796_3": {"length": 34, "quality": 0.7555555555555555, "section_id": 5422}, "so_20478193_20478796_2": {"length": 5, "quality": 1.0, "section_id": 5419}, "so_20478193_20478435_2": {"length": 7, "quality": 0.875, "section_id": 5419}}, "n3337": {"so_20478193_20478435_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5214}, "so_20478193_20478796_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5214}, "so_20478193_20478796_0": {"length": 19, "quality": 0.7037037037037037, "section_id": 5768}, "so_20478193_20478796_3": {"length": 42, "quality": 0.9333333333333333, "section_id": 5217}, "so_20478193_20478796_2": {"length": 5, "quality": 1.0, "section_id": 5214}, "so_20478193_20478435_2": {"length": 7, "quality": 0.875, "section_id": 5214}}, "n4659": {"so_20478193_20478796_3": {"length": 34, "quality": 0.7555555555555555, "section_id": 6844}, "so_20478193_20478435_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6841}, "so_20478193_20478796_2": {"length": 5, "quality": 1.0, "section_id": 6841}, "so_20478193_20478435_2": {"length": 7, "quality": 0.875, "section_id": 6841}, "so_20478193_20478796_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 6841}}}, "20478796": {"Id": "20478796", "PostTypeId": "2", "Body": "<p>This looks valid by the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a>, if we look at section <code>5.2.3</code> <em>Explicit type conversion (functional notation)</em> paragraph <em>2</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_20478193_20478796_0\">The <strong>expression T()</strong>, where T is a simple-type-specifier or\n  typename-specifier for a non-array complete object type <strong>or the\n  (possibly cv-qualified) void type</strong>, creates a prvalue of the\n  specified type, whose value is that produced by value-initializing\n  (8.5) an object of type T; no initialization is done for the void()\n  case.[...]</p>\n</blockquote>\n<p>the wording is pretty similar <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow noreferrer\">pre C++11</a> as well.</p>\n<p>This okay in a <em>constexpr</em> even though section <code>7.1.5</code> paragraph <code>3</code> says:</p>\n<blockquote>\n<p id=\"so_20478193_20478796_1\">The definition of a constexpr function shall satisfy the following\n  constraints:</p>\n</blockquote>\n<p>and includes this bullet:</p>\n<blockquote>\n<p id=\"so_20478193_20478796_2\">its return type shall be a literal type;</p>\n</blockquote>\n<p>and <em>void</em> is not a <em>literal</em> in <em>C++11</em> as per section <code>3.9</code> paragraph <em>10</em>, <em>but</em> if we then look at paragraph <em>6</em> it gives an exception that fits this case, it says:</p>\n<blockquote>\n<p id=\"so_20478193_20478796_3\">If the instantiated template specialization of a constexpr function\n  template or member function of a class template would fail to satisfy\n  the requirements for a constexpr function or constexpr constructor,\n  that specialization is not a constexpr function or constexpr\n  constructor. [ Note: If the function is a member function it will\n  still be const as described below. \u2014end note ] <strong>If no specialization of\n  the template would yield a constexpr function or constexpr\n  constructor, the program is ill-formed; no diagnostic required</strong>.</p>\n</blockquote>\n<p>As Casey <a href=\"https://stackoverflow.com/questions/20478193/returning-a-void#comment30604069_20478435\">noted</a> in the <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4140.pdf\" rel=\"nofollow noreferrer\">C++14 draft standard</a> <em>void</em> is a <em>literal</em>, this is section <code>3.9</code> <em>Types</em> paragraph <em>10</em> says:</p>\n<blockquote>\n<p id=\"so_20478193_20478796_4\">A type is a literal type if it is:</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_20478193_20478796_5\">\u2014 void; or</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-14T12:39:34.497", "Score": "23", "CreationDate": "2013-12-09T19:15:53.733", "ParentId": "20478193", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T10:27:21.027"}});