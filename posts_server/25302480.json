post_cb({"25303263": {"ParentId": "25302480", "CommentCount": "2", "Body": "<ol>\n<li>For floating point multiplication: FP multipliers use internally double the width of the operands to generate an intermediate result, which equals the real result within an infinite precision, and then round it to the target precision. Thus you should not worry about multiplication. The result is correctly rounded.</li>\n<li>For floating point addition, the result is also correctly rounded as standard FP adders use extra sufficient 3 guard bits to compute a correctly rounded result.</li>\n<li>For division, remainder and other complicated functions, like transcendentals such as sin, log, exp, etc... it depends mainly on the architecture and the used libraries. I recommend you to use the MPFR library if you seek correctly rounded results for division or any other complicated function.</li>\n</ol>\n", "OwnerUserId": "3697978", "PostTypeId": "2", "Id": "25303263", "Score": "1", "CreationDate": "2014-08-14T08:18:28.433", "LastActivityDate": "2014-08-14T08:18:28.433"}, "25303561": {"ParentId": "25302480", "PostTypeId": "2", "CommentCount": "20", "Body": "<h2>Precision of floating-point computations</h2>\n<p>C++11 <a href=\"http://www.cplusplus.com/reference/cfloat/\" rel=\"nofollow noreferrer\">incorporates</a> the definition of <code>FLT_EVAL_METHOD</code> from C99 in <code>cfloat</code>.</p>\n<pre>\nFLT_EVAL_METHOD     \n\nPossible values:\n-1 undetermined\n 0 evaluate just to the range and precision of the type\n 1 evaluate float and double as double, and long double as long double.\n 2 evaluate all as long double \n</pre>\n<p>If your compiler defines <code>FLT_EVAL_METHOD</code> as 2, then the computations of <code>r1</code> and <code>r2</code>, and of <code>s1</code> and <code>s2</code> below are respectively equivalent:</p>\n<pre><code>double var3 = \u2026;\ndouble var4 = \u2026;\n\ndouble r1 = var3 * var4;\ndouble r2 = (long double)var3 * (long double)var4;\n\nlong double s1 = var3 * var4;\nlong double s2 = (long double)var3 * (long double)var4;\n</code></pre>\n<p>If your compiler defines FLT_EVAL_METHOD as 2, then in all four computations above, the multiplication is done at the precision of the <code>long double</code> type.</p>\n<p>However, if the compiler defines <code>FLT_EVAL_METHOD</code> as 0 or 1, <code>r1</code> and <code>r2</code>, and respectively <code>s1</code> and <code>s2</code>, aren't always the same. The multiplications when computing <code>r1</code> and <code>s1</code> are done at the precision of <code>double</code>. The multiplications when computing <code>r2</code> and <code>s2</code> are done at the precision of <code>long double</code>.</p>\n<h2>Getting wide results from narrow arguments</h2>\n<p>If you are computing results that are destined to be stored in a wider result type than the type of the operands, as are <code>result1</code> and <code>result2</code> in your question, you should always convert the arguments to a type at least as wide as the target, as you do here:</p>\n<pre><code>result2=(long double)var3*(long double)var4;\n</code></pre>\n<p>Without this conversion (if you write <code>var3 * var4</code>), if the compiler's definition of <code>FLT_EVAL_METHOD</code> is 0 or 1, the product will be computed in the precision of <code>double</code>, which is a shame, since it is destined to be stored in a <code>long double</code>.</p>\n<p>If the compiler defines <code>FLT_EVAL_METHOD</code> as 2, then the conversions in <code>(long double)var3*(long double)var4</code> are not necessary, but they do not hurt either: the expression means exactly the same thing with and without them.</p>\n<h2>Digression: if the destination format is as narrow as the arguments, when is extended-precision for intermediate results better?</h2>\n<p>Paradoxically, for a single operation, rounding only once to the target precision is best. The only effect of computing a single multiplication in extended precision is that the result will be rounded to extended precision and then to <code>double</code> precision. This makes it <a href=\"http://en.wikipedia.org/wiki/Rounding#Double_rounding\" rel=\"nofollow noreferrer\">less accurate</a>. In other words, with <code>FLT_EVAL_METHOD</code> 0 or 1, the result <code>r2</code> above is sometimes less accurate than <code>r1</code> because of double-rounding, and if the compiler uses IEEE 754 floating-point, never better.</p>\n<p>The situation is different for larger expressions that contain several operations. For these, it is usually better to compute intermediate results in extended precision, either through explicit conversions or because the compiler uses <code>FLT_EVAL_METHOD == 2</code>. This <a href=\"https://stackoverflow.com/questions/13725802/properties-of-80-bit-extended-precision-computations-starting-from-double-precis\">question</a> and its accepted answer show that when computing with 80-bit extended precision intermediate computations for binary64 IEEE 754 arguments and results, the interpolation formula <code>u2 * (1.0 - u1) + u1 * u3</code> always yields a result between <code>u2</code> and <code>u3</code> for <code>u1</code> between 0 and 1. This property may not hold for binary64-precision intermediate computations because of the larger rounding errors then.</p>\n", "OwnerUserId": "139746", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:50.943", "Id": "25303561", "Score": "8", "CreationDate": "2014-08-14T08:33:20.923", "LastActivityDate": "2014-08-14T17:17:16.300"}, "25302649": {"ParentId": "25302480", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The <em>usual arthimetic conversions</em> for floating point types are applied before multiplication, division, and modulus:</p>\n<blockquote>\n<p id=\"so_25302480_25302649_0\">The usual arithmetic conversions are performed on the operands and determine the type of the result.</p>\n<p id=\"so_25302480_25302649_1\">\u00a75.6 [expr.mul]</p>\n</blockquote>\n<p>Similarly for addition and subtraction:</p>\n<blockquote>\n<p id=\"so_25302480_25302649_2\">The usual arithmetic conversions are performed for operands of arithmetic or enumeration type.</p>\n<p id=\"so_25302480_25302649_3\">\u00a75.7 [expr.add]</p>\n</blockquote>\n<p>The <em>usual arithmetic conversions</em> for floating point types are laid out in the standard as follows:</p>\n<blockquote>\n<p id=\"so_25302480_25302649_4\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the usual arithmetic conversions, which are defined as follows:</p>\n<p id=\"so_25302480_25302649_5\">[...]</p>\n<p id=\"so_25302480_25302649_6\">\u2014 If either operand is of type <code>long double</code>, the other shall be converted to <code>long double</code>.</p>\n<p id=\"so_25302480_25302649_7\">\u2014 Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</p>\n<p id=\"so_25302480_25302649_8\">\u2014 Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.</p>\n<p id=\"so_25302480_25302649_9\">\u00a75 [expr]</p>\n</blockquote>\n<p>The actual form/precision of these floating point types is implementation-defined:</p>\n<blockquote>\n<p id=\"so_25302480_25302649_10\">The type <code>double</code> provides at least as much precision as <code>float</code>, and the type <code>long double</code> provides at least as much precision as <code>double</code>.  The set of values of the type <code>float</code> is a subset of the set of values of the type <code>double</code>; the set of values of the type <code>double</code> is a subset of the set of values of the type <code>long double</code>. The value representation of floating-point types is implementation-defined.</p>\n<p id=\"so_25302480_25302649_11\">\u00a73.9.1 [basic.fundamental]</p>\n</blockquote>\n", "OwnerUserId": "1007504", "LastEditorUserId": "1007504", "LastEditDate": "2014-08-14T07:58:55.327", "Id": "25302649", "Score": "1", "CreationDate": "2014-08-14T07:46:49.593", "LastActivityDate": "2014-08-14T07:58:55.327"}, "25309357": {"ParentId": "25302480", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Not a direct answer to your question, but for constant floating-point values (such as the ones specified in your question), the method that yields the least amount of precision-loss would be using the rational representation of each value as an integer numerator divided by an integer denominator, and perform as many integer-multiplications as possible before the actual floating-point-division.</p>\n<p>For the floating-point values specified in your question:</p>\n<pre><code>int var1_num = 31;\nint var1_den = 10;\nint var2_num = 6789;\nint var2_den = 1000;\nint var3_num = 8745;\nint var3_den = 100;\nint var4_num = 234987;\nint var4_den = 1000;\ndouble result1 = (double)(var1_num*var2_num)/(var1_den*var2_den);\nlong double result2 = (long double)(var3_num*var4_num)/(var3_den*var4_den);\n</code></pre>\n<p>If any of the integer-products are too large to fit in an <code>int</code>, then you can use larger integer types:</p>\n<pre><code>unsigned int\nsigned   long\nunsigned long\nsigned   long long\nunsigned long long\n</code></pre>\n", "OwnerUserId": "1382251", "LastEditorUserId": "1382251", "LastEditDate": "2014-08-14T13:40:37.310", "Id": "25309357", "Score": "0", "CreationDate": "2014-08-14T13:34:00.760", "LastActivityDate": "2014-08-14T13:40:37.310"}, "25302480": {"CommentCount": "3", "ViewCount": "820", "PostTypeId": "1", "LastEditorUserId": "270986", "CreationDate": "2014-08-14T07:35:59.997", "LastActivityDate": "2014-08-14T17:17:16.300", "Title": "What precision are floating-point arithmetic operations done in?", "FavoriteCount": "1", "LastEditDate": "2014-08-14T08:22:56.193", "Id": "25302480", "Score": "6", "Body": "<p>Consider two very simple multiplications below:</p>\n<pre><code>double result1;\nlong double result2;\nfloat var1=3.1;\nfloat var2=6.789;\ndouble var3=87.45;\ndouble var4=234.987;\n\nresult1=var1*var2;\nresult2=var3*var4;\n</code></pre>\n<p>Are multiplications by default done in a higher precision than the operands? I mean in case of first multiplication is it done in double precision and in case of second one in x86 architecture is it done in 80-bit extended-precision or we should cast operands in expressions to the higher precision ourselves like below?</p>\n<pre><code>result1=(double)var1*(double)var2;\nresult2=(long double)var3*(long double)var4;\n</code></pre>\n<p>What about other operations(add, division and remainder)? For example when adding more than two positive single-precision values, using extra significant bits of double-precision can decrease round-off errors if used to hold intermediate results of expression.</p>\n", "Tags": "<c++><floating-point><rounding><floating-point-precision><arithmetic-expressions>", "OwnerUserId": "388056", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_25302480_25302649_10": {"section_id": 7217, "quality": 0.9047619047619048, "length": 38}, "so_25302480_25302649_6": {"section_id": 5943, "quality": 1.0, "length": 9}, "so_25302480_25302649_8": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_25302480_25302649_2": {"section_id": 6138, "quality": 0.8888888888888888, "length": 8}, "so_25302480_25302649_0": {"section_id": 6135, "quality": 0.8888888888888888, "length": 8}, "so_25302480_25302649_7": {"section_id": 5943, "quality": 1.0, "length": 7}, "so_25302480_25302649_4": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}}, "n3337": {"so_25302480_25302649_10": {"section_id": 6961, "quality": 0.9047619047619048, "length": 38}, "so_25302480_25302649_6": {"section_id": 5714, "quality": 1.0, "length": 9}, "so_25302480_25302649_8": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_25302480_25302649_2": {"section_id": 5902, "quality": 0.8888888888888888, "length": 8}, "so_25302480_25302649_0": {"section_id": 5899, "quality": 0.8888888888888888, "length": 8}, "so_25302480_25302649_7": {"section_id": 5714, "quality": 1.0, "length": 7}, "so_25302480_25302649_4": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}}, "n4659": {"so_25302480_25302649_10": {"section_id": 8726, "quality": 0.9047619047619048, "length": 38}, "so_25302480_25302649_6": {"section_id": 7428, "quality": 1.0, "length": 9}, "so_25302480_25302649_2": {"section_id": 7635, "quality": 0.8888888888888888, "length": 8}, "so_25302480_25302649_0": {"section_id": 7632, "quality": 0.8888888888888888, "length": 8}, "so_25302480_25302649_8": {"section_id": 7428, "quality": 1.0, "length": 7}, "so_25302480_25302649_4": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_25302480_25302649_7": {"section_id": 7428, "quality": 1.0, "length": 7}}}});