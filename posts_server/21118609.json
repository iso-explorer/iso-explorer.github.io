post_cb({"bq_ids": {"n4140": {"so_21118609_21118609_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5975}, "so_21118609_21118609_2": {"length": 12, "quality": 1.0, "section_id": 5977}, "so_21118609_21118609_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5974}}, "n3337": {"so_21118609_21118609_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5743}, "so_21118609_21118609_2": {"length": 12, "quality": 1.0, "section_id": 5745}, "so_21118609_21118609_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5742}}, "n4659": {"so_21118609_21118609_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 7475}, "so_21118609_21118609_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 7474}, "so_21118609_21118609_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 7473}}}, "21121004": {"Id": "21121004", "PostTypeId": "2", "Body": "<p>Of course such a data member exists in the closure type.  Capture by value and capture by reference both require a data member in the closure type.  The only question is its type:</p>\n<pre><code>T /* maybe const and/or volatile */ * captured_this;\n</code></pre>\n<p>vs</p>\n<pre><code>T /* maybe const and/or volatile */ * const &amp; captured_this;\n</code></pre>\n<p>Since <code>this</code> can't ever change, there is no observable difference between the two.</p>\n", "LastActivityDate": "2014-01-14T18:20:04.413", "CommentCount": "5", "CreationDate": "2014-01-14T18:20:04.413", "ParentId": "21118609", "Score": "0", "OwnerUserId": "103167"}, "21118993": {"Id": "21118993", "PostTypeId": "2", "Body": "<p>I think you've found a specification bug - you're correct in that <code>this</code> is being captured by reference, but the text you found in \u00a75.1.2/17 should only apply if <code>this</code> is captured by copy.  </p>\n<p>As Casey says though, it doesn't really make much sense to capture <code>this</code> by reference.</p>\n", "LastEditorUserId": "930949", "LastActivityDate": "2014-01-14T17:13:20.080", "Score": "0", "CreationDate": "2014-01-14T16:45:01.340", "ParentId": "21118609", "CommentCount": "0", "OwnerUserId": "930949", "LastEditDate": "2014-01-14T17:13:20.080"}, "21118609": {"ViewCount": "209", "Body": "<p>Consider the following code:</p>\n<pre><code>struct S\n{\n  int x;\n  void f()\n  {\n    auto l = [&amp;](){ x = 42; }; //this is implicitly captured here\n  }\n};\n</code></pre>\n<p>\u00a75.1.2/14 states:</p>\n<blockquote>\n<p id=\"so_21118609_21118609_0\">An entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly captured with a capture that does not include an &amp;.</p>\n</blockquote>\n<p>Hence I conclude, that <code>this</code> is not <em>captured by copy</em>. But then by \u00a75.1.2/15:</p>\n<blockquote>\n<p id=\"so_21118609_21118609_1\">An entity is captured by reference if it is implicitly or explicitly captured but not captured by copy. It is unspecified whether additional unnamed non-static data members are declared in the closure type for entities captured by reference.</p>\n</blockquote>\n<p><code>this</code> is <em>captured by reference</em>. But now \u00a75.1.2/17 states:</p>\n<blockquote>\n<p id=\"so_21118609_21118609_2\">[...] If <code>this</code> is captured, each odr-use of <code>this</code> is transformed into an access to the corresponding unnamed data member of the closure type, [...]</p>\n</blockquote>\n<p>As far as I understand, this implies that there must be an unnamed data member in the closure type corresponding to the <code>this</code> pointer. But since <code>this</code> is <em>captured by reference</em> the standard doesn't demand that such a member exists. What do I get wrong?</p>\n", "Title": "How is the this pointer captured?", "CreationDate": "2014-01-14T16:27:19.623", "LastActivityDate": "2014-01-14T21:07:44.667", "CommentCount": "0", "LastEditDate": "2014-01-14T21:07:44.667", "PostTypeId": "1", "LastEditorUserId": "103167", "Id": "21118609", "Score": "6", "OwnerUserId": "1770418", "Tags": "<c++><c++11><lambda><this>", "AnswerCount": "3"}, "21119160": {"Id": "21119160", "PostTypeId": "2", "Body": "<p>The standard does a poor job of making it clear, but <code>this</code> can only be captured by copy. It could not possibly be captured by lvalue-reference since <code>this</code> is an rvalue per C++11 \u00a79.3.2/1.</p>\n<p>Note that the standard forbids explicitly capturing <code>this</code> by reference since (a) the grammar does not allow <code>&amp;this</code> in a capture list since <code>this</code> is lexically a keyword and not an <em>identifier</em>, and (b) 5.1.2/8 forbids explicit capture of <code>this</code> when the capture-default is <code>=</code>.</p>\n<p>It would seem to be an error in the specification that <code>this</code> can be implicitly captured when the capture-default is <code>&amp;</code>, suggesting that it is captured by reference. </p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-01-14T17:40:38.670", "Score": "1", "CreationDate": "2014-01-14T16:52:15.113", "ParentId": "21118609", "CommentCount": "6", "OwnerUserId": "923854", "LastEditDate": "2014-01-14T17:40:38.670"}});