post_cb({"19636998": {"ParentId": "19300142", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the standard (\u00a7 5.2.10 <code>reinterpret_cast</code>, section 7):</p>\n<blockquote>\n<p id=\"so_19300142_19636998_0\">A pointer to an object can be explicitly converted to a pointer to a di\ufb00erent object type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to <code>cv T2</code>\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> <strong>if both <code>T1</code> and <code>T2</code> are standard-layout types and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>.</strong></p>\n<p id=\"so_19300142_19636998_1\">Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to T2\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. <strong>The result of any other such pointer conversion is unspeci\ufb01ed.</strong></p>\n</blockquote>\n<p>So, we could make the following conclusion:</p>\n<ol>\n<li><code>reinterpret_cast&lt;*T&gt;(ptr)</code> is eqiuvalent to <code>static_cast&lt;*T&gt;(static_cast&lt;void*&gt;(ptr))</code></li>\n<li><code>static_cast&lt;&gt;(ptr)</code> is not always equal to <code>ptr</code>, but <code>reinterpret_cast&lt;&gt;(ptr)</code> is always equal to <code>ptr</code></li>\n<li>if there is no alignment issues, we can use <code>reinterpret_cast</code> safely</li>\n</ol>\n", "OwnerUserId": "2900735", "LastEditorUserId": "2900735", "LastEditDate": "2013-10-28T14:25:43.260", "Id": "19636998", "Score": "4", "CreationDate": "2013-10-28T14:09:54.220", "LastActivityDate": "2013-10-28T14:25:43.260"}, "19300142": {"CommentCount": "5", "ViewCount": "657", "CreationDate": "2013-10-10T15:32:31.567", "LastActivityDate": "2013-10-28T14:25:43.260", "Title": "static_cast and reinterpret_cast for std::aligned_storage", "PostTypeId": "1", "Id": "19300142", "Score": "10", "Body": "<p>could someone please explain the bit of code about casting in <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/types/aligned_storage</a> please?</p>\n<p>can the following code</p>\n<pre><code>return *static_cast&lt;const T*&gt;(static_cast&lt;const void*&gt;(&amp;data[pos]));\n</code></pre>\n<p>be replaced with </p>\n<pre><code> return *reinterpret_cast&lt;const T*&gt;(&amp;data[pos]);\n</code></pre>\n<p>?</p>\n<p>Why here two casting are used?\nThanks a lot.</p>\n<p>Hong</p>\n", "Tags": "<c++><alignment><reinterpret-cast><static-cast>", "OwnerUserId": "1880729", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19300142_19636998_1": {"section_id": 6046, "quality": 0.7666666666666667, "length": 23}, "so_19300142_19636998_0": {"section_id": 6046, "quality": 0.7142857142857143, "length": 20}}, "n3337": {"so_19300142_19636998_1": {"section_id": 5814, "quality": 0.9333333333333333, "length": 28}, "so_19300142_19636998_0": {"section_id": 5814, "quality": 0.8214285714285714, "length": 23}}, "n4659": {"so_19300142_19636998_1": {"section_id": 7545, "quality": 0.7666666666666667, "length": 23}, "so_19300142_19636998_0": {"section_id": 7545, "quality": 0.6785714285714286, "length": 19}}}});