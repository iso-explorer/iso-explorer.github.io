post_cb({"4940550": {"ParentId": "4940419", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is not a bug in the implementation as others have suggested.</p>\n<p>Violating the requirements of a C++ Standard Library facility does not render your program ill-formed, it yields undefined behavior.  </p>\n<p>You have violated the requirement that the value type stored in a container must be copy constructible and assignable (<code>const</code> types are not assignable, obviously), so your program exhibits undefined behavior.</p>\n<p>The applicable language from the C++ Standard can be found in C++03 17.4.3.6 [lib.res.on.functions]:</p>\n<blockquote>\n<p id=\"so_4940419_4940550_0\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library  template  components),  the  C++  Standard  Library  depends  on  components  supplied  by  a  C++  program.  If  these  components  do  not  meet  their  requirements,  the  Standard  places  no  requirements  on  the implementation.</p>\n<p id=\"so_4940419_4940550_1\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_4940419_4940550_2\">...</p>\n<ul>\n<li>for types used as template arguments when instantiating a template component, if the operations on the type  do  not  implement  the  semantics  of  the  applicable Requirements subclause.</li>\n</ul>\n</blockquote>\n<p>The Visual C++ Standard Library implementation may do anything with this code, including silently removing or ignoring the const-qualification, and it is still standards-conforming.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2011-02-09T02:05:26.850", "Id": "4940550", "Score": "12", "CreationDate": "2011-02-09T01:45:52.400", "LastActivityDate": "2011-02-09T02:05:26.850"}, "4940450": {"ParentId": "4940419", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><s>\nThis simply shouldn't work. At \u00a723.1 \u00b6 3 it's specified, as you said, that objects stored in a container must be <code>CopyConstructible</code> (as specified at \u00a720.1.3) and <code>Assignable</code>.</s></p>\n<p>The <code>Assignable</code> requirements for a type <code>T</code> are that, being <code>t</code> and <code>u</code> of type <code>T</code>, you can do:</p>\n<pre><code>t = u\n</code></pre>\n<p>having a <code>T&amp;</code> as return value and <code>t</code> equivalent to <code>u</code> as postcondition. (\u00a723.1 \u00b64)</p>\n<p>Thus, <code>const</code> types are clearly not <code>Assignable</code>, since doing <code>t = u</code> would raise a compilation error (\u00a77.1.5.1 \u00b65).</p>\n<p>I suppose that this is a bug in Microsoft implementation. g++ on Linux emits the typical 25 kajillion-lines template error if you even try to instantiate a <code>vector&lt;const int&gt;</code> (tested both with and without the <code>-std=c++0x</code> flag, just in case).</p>\n<p>By the way, this is also explained in detail in this <a href=\"http://www-01.ibm.com/support/docview.wss?uid=swg21162689\" rel=\"nofollow\" title=\"Instantiating STL containers with const types\">IBM FAQ</a>.</p>\n<hr/>\n<p>In theory, as @James McNellis said, the compiler is not required to blow up on the vector instantiation (if it's undefined behavior anything can happen - including everything working fine); however, on the assignation statement there's a violation of the standard that should produce a compilation error.</p>\n<p>In facts, the <code>operator[]</code> member returns a <code>vector&lt;const int&gt;::reference</code>; that one is required to be an lvalue of <code>T</code> (\u00a723.1 \u00b65 table 66); since <code>T</code> is of a <code>const</code> type, it will be a <code>const</code> lvalue. So we fall down to (\u00a77.1.5.1 \u00b65), which defines code that tries to perform an assignment to a <code>const</code> element as \"ill-formed\", and this demands a compilation error or at least a warning, because assignment-to-<code>const</code> is a diagnosable rule (\u00a71.4 \u00b61-2) (no \"no diagnostic is required\" statement is specified).\n</p>\n<hr/>\n<p><em><strong>Final edit</strong></em></p>\n<p>Actually, @James McNellis is right; once you've invoked undefined behavior by instantiating <code>vector&lt;const int&gt;</code>, the usual rules stop having value, so the implementation is still standard-conforming whatever it does - including removing the <code>const</code> from the element type or generating the usual nasal demons.</p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2011-02-09T02:14:42.490", "Id": "4940450", "Score": "1", "CreationDate": "2011-02-09T01:21:52.247", "LastActivityDate": "2011-02-09T02:14:42.490"}, "4940419": {"CommentCount": "4", "ViewCount": "557", "PostTypeId": "1", "LastEditorUserId": "151292", "CreationDate": "2011-02-09T01:14:35.960", "LastActivityDate": "2011-02-09T02:19:49.277", "Title": "VC++ allows to use const types for STL containers. Why?", "FavoriteCount": "2", "LastEditDate": "2011-02-09T02:19:49.277", "Id": "4940419", "Score": "11", "Body": "<p>STL containers require the stored values to be copy constructible and assignable. const T is obviously not an assignable type for any T, but I tried to use it (just being curious) and found out that it compiles and, moreover, behaves as an assignable type.</p>\n<pre><code>vector&lt;const int&gt; v(1);\nv[0] = 17;\n</code></pre>\n<p>This successfully runs in Visual Studio 2008 and assigns v[0] to 17. </p>\n", "Tags": "<c++><visual-c++><stl><const><visual-c++-2008>", "OwnerUserId": "609063", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_4940419_4940550_1": {"section_id": 6324, "quality": 1.0, "length": 5}, "so_4940419_4940550_0": {"section_id": 6323, "quality": 0.88, "length": 22}}, "n3337": {"so_4940419_4940550_1": {"section_id": 6081, "quality": 1.0, "length": 5}, "so_4940419_4940550_0": {"section_id": 6080, "quality": 0.88, "length": 22}}, "n4659": {"so_4940419_4940550_1": {"section_id": 7834, "quality": 1.0, "length": 5}, "so_4940419_4940550_0": {"section_id": 7833, "quality": 0.88, "length": 22}}}});