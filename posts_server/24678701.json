post_cb({"24678701": {"CommentCount": "4", "ViewCount": "408", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-07-10T14:05:52.230", "LastActivityDate": "2014-07-25T01:40:04.593", "Title": "Move constructor is required even if it is not used. Why?", "AcceptedAnswerId": "24679050", "LastEditDate": "2017-05-23T10:26:15.100", "Id": "24678701", "Score": "3", "Body": "<p>Why?! Why C++ requires the class to be movable even if it's not used!\nFor example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A {\n    const int idx;\n    //   It could not be compileld if I comment out the next line and uncomment\n    // the line after the next but the moving constructor is NOT called anyway!\n    A(A&amp;&amp; a) : idx(a.idx) { cout&lt;&lt;\"Moving constructor with idx=\"&lt;&lt;idx&lt;&lt;endl; }\n   //  A(A&amp;&amp; a) = delete;\n    A(const int i) : idx(i) { cout&lt;&lt;\"Constructor with idx=\"&lt;&lt;i&lt;&lt;endl; }\n    ~A() { cout&lt;&lt;\"Destructor with idx=\"&lt;&lt;idx&lt;&lt;endl; }\n};\n\nint main()\n{\n    A a[2] = { 0, 1 };\n   return 0;\n}\n</code></pre>\n<p>The output is (the move constructor is not called!):</p>\n<blockquote>\n<p id=\"so_24678701_24678701_0\">Constructor with idx=0<br/>\n  Constructor with idx=1<br/>\n  Destructor with idx=1<br/>\n  Destructor with idx=0</p>\n</blockquote>\n<p>The code can not be compiled if moving constructor is deleted ('<em>use of deleted function \u2018A::A(A&amp;&amp;)\u2019</em>'. But if the constructor is not deleted it is not used!\nWhat a stupid restriction?\nNote:\nWhy do I need it for? The practical meaning appears when I am trying to initialize an array of objects contains unique_ptr field.\nFor example:</p>\n<pre><code>// The array of this class can not be initialized!\nclass B {\n    unique_ptr&lt;int&gt; ref;\npublic:\n    B(int* ptr) : ref(ptr)\n        {  }\n}\n// The next class can not be even compiled!\nclass C {\n    B arrayOfB[2] = { NULL, NULL };\n}\n</code></pre>\n<p>And it gets even worse if you are trying to use a vector of unique_ptr's.\n<p>\nOkay. Thanks a lot to everybody. There is big confusion with all those copying/moving constructors and array initialization. Actually the question was about the situation when the compiler requires a copying consrtuctor, may use a moving construcor and uses none of them.\nSo I'm going to create a new question a little bit later when I get a normal keyboard. I'll provide the link here.\n<p>\n<strong>P.S. I've created more specific and clear question - welcome to <a href=\"https://stackoverflow.com/questions/24691820/why-does-the-compiler-require-a-copying-constructor-need-and-have-moving-one-an\">discuss</a> it!</strong></p>\n</p></p>", "Tags": "<c++><c++11><std><c++14>", "OwnerUserId": "3544995", "AnswerCount": "2"}, "24678927": {"ParentId": "24678701", "CommentCount": "7", "Body": "<pre><code>A a[2] = { 0, 1 };\n</code></pre>\n<p>Conceptually, this creates two temporary <code>A</code> objects, <code>A(0)</code> and <code>A(1)</code>, and moves or copies them to initialise the array <code>a</code>; so a move or copy constructor is required.</p>\n<p>As an optimisation, the move or copy is allowed to be elided, which is why your program doesn't appear to use the move constructor. But there must still be a suitable constructor, even if its use is elided.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "24678927", "Score": "11", "CreationDate": "2014-07-10T14:15:34.787", "LastActivityDate": "2014-07-10T14:15:34.787"}, "bq_ids": {"n4140": {"so_24678701_24679050_0": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}, "so_24678701_24679050_1": {"section_id": 3296, "quality": 0.920863309352518, "length": 128}}, "n3337": {"so_24678701_24679050_0": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}, "so_24678701_24679050_1": {"section_id": 3166, "quality": 0.920863309352518, "length": 128}}, "n4659": {"so_24678701_24679050_0": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}, "so_24678701_24679050_1": {"section_id": 4058, "quality": 0.7697841726618705, "length": 107}}}, "24679050": {"ParentId": "24678701", "LastEditDate": "2014-07-25T01:40:04.593", "CommentCount": "7", "CreationDate": "2014-07-10T14:20:48.323", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "24679050", "Score": "5", "Body": "<pre><code>A a[2] = { 0, 1 };\n</code></pre>\n<p>This is <em>aggregate initialization</em>. \u00a78.5.1 [dcl.init.aggr]/p2 of the standard provides that</p>\n<blockquote>\n<p id=\"so_24678701_24679050_0\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each member is <strong>copy-initialized</strong> from the corresponding <em>initializer-clause</em>. </p>\n</blockquote>\n<p>\u00a78.5 [dcl.init]/p16, in turn, describes the semantics of copy initialization of class type objects:</p>\n<blockquote id=\"so_24678701_24679050_1\">\n<ul>\n<li>[...]</li>\n<li>If the destination type is a (possibly cv-qualified) class type:\n  <ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source\n  type is the same class as, or a derived class of, the class of the\n  destination, constructors are considered. The applicable constructors\n  are enumerated (13.3.1.3), and the best one is chosen through overload\n  resolution (13.3). The constructor so selected is called to initialize\n  the object, with the initializer expression or expression-list as its\n  argument(s). If no constructor applies, or the overload resolution is\n  ambiguous, the initialization is ill-formed.</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4,\n  and the best one is chosen through overload resolution (13.3). If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed. The function selected is called with the initializer\n  expression as its argument; if the function is a constructor, the call\n  initializes a temporary of the cv-unqualified version of the\n  destination type. The temporary is a prvalue. The result of the call\n  (which is the temporary for the constructor case) is then used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization. In certain cases, an\n  implementation is permitted to eliminate the copying inherent in this\n  direct-initialization by constructing the intermediate result directly\n  into the object being initialized; see 12.2, 12.8.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Since <code>0</code> and <code>1</code> are <code>int</code>s, not <code>A</code>s, the copy initialization here falls under the second clause. The compiler find a user-defined conversion from <code>int</code> to <code>A</code> in your <code>A::A(int)</code> constructor, calls it to construct a temporary of type <code>A</code>, then performs direct initialization using that temporary. This, in turn, means the compiler is required to perform overload resolution for a constructor taking a temporary of type <code>A</code>, which selects your deleted move constructor, which renders the program ill-formed.</p>\n", "LastActivityDate": "2014-07-25T01:40:04.593"}});