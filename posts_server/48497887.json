post_cb({"48497887": {"Tags": "<c++><constructor><initialization><language-lawyer>", "ViewCount": "59", "LastEditDate": "2018-01-29T09:49:42.097", "AnswerCount": "1", "LastEditorUserId": "5470596", "Title": "Comparison of member initialization by constructor vs. direct initialization", "CommentCount": "1", "AcceptedAnswerId": "48498122", "Score": "1", "CreationDate": "2018-01-29T09:20:21.380", "Id": "48497887", "LastActivityDate": "2018-01-29T09:49:42.097", "Body": "<p>I'm creating a class in which one member is a const pointer (immutable address) to another member of the struct.</p>\n<p>In the simplified version below, will both classes always behave the same value? Especially in the sense of whether the addresses stored in <code>ptr</code> are guaranteed to be properly initialized.</p>\n<pre><code>struct First\n{\n  int a;\n  int* const ptr = &amp;a;\n};\n\nstruct Second\n{\n  int a;\n  int* const ptr;\n\n  Second() : ptr(&amp;a) {}\n};\n</code></pre>\n<p>(In my actual application the member <code>a</code> is a class instance, and <code>ptr</code> is replaced by a map from some enums to pointers pointing to members of <code>a</code>.)</p>\n", "PostTypeId": "1", "OwnerUserId": "1987220"}, "48498122": {"ParentId": "48497887", "LastActivityDate": "2018-01-29T09:46:38.237", "OwnerUserId": "5470596", "Id": "48498122", "CreationDate": "2018-01-29T09:33:47.123", "LastEditorUserId": "5470596", "Body": "<blockquote>\n<p id=\"so_48497887_48498122_0\">In the simplified version below, will both structs always behave the same way?</p>\n</blockquote>\n<p>No they won't, but it may be ok for your case. Read on.</p>\n<p>Both <code>First::ptr</code> and <code>Second::ptr</code> will be initialized to the expected value being the address of <code>First::a</code> and respectively <code>Second::a</code>, but:</p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/class.mem#7.sentence-1\" rel=\"nofollow noreferrer\"><code>[class.mem]/7</code></a> &amp; <a href=\"http://eel.is/c++draft/class.mem#9.sentence-3\" rel=\"nofollow noreferrer\"><code>[class.mem]/9</code></a></h3>\n<p id=\"so_48497887_48498122_1\">7 <strong>In a <em>member-declarator</em>, an = immediately following the <em>declarator</em> is interpreted as</strong> introducing a <em>pure-specifier</em>\n  if the <em>declarator-id</em> has function type, otherwise it is interpreted as <strong>introducing a <em>brace-or-equal-initializer</em>.</strong></p>\n<p id=\"so_48497887_48498122_2\">9 A <em>brace-or-equal-initializer</em> shall appear only in the declaration of a data member. (For static data members,\n  see 12.2.3.2; for non-static data members, see 15.6.2 and 11.6.1). A <em>brace-or-equal-initializer</em> for a non-static\n  data member specifies a default member <em>initializer</em> for the member, <strong>and shall not directly or indirectly cause\n  the implicit definition of a defaulted default constructor</strong> for the enclosing class or the exception specification\n  of that constructor.</p>\n</blockquote>\n<p>This means, <code>First</code> has a defaulted default constructor where <code>Second</code> has a user-provided default constructor, which change some characteristic of those classes. I can for instance think of <a href=\"http://eel.is/c++draft/dcl.init.aggr\" rel=\"nofollow noreferrer\"><em>aggregates</em></a>, <a href=\"http://eel.is/c++draft/class.ctor#6\" rel=\"nofollow noreferrer\"><em>triviality</em></a> and maybe <em>standard layouts</em>.</p>\n", "LastEditDate": "2018-01-29T09:46:38.237", "PostTypeId": "2", "CommentCount": "2", "Score": "2"}, "bq_ids": {"n4659": {"so_48497887_48498122_2": {"length": 34, "section_id": 7347, "quality": 0.8717948717948718}, "so_48497887_48498122_1": {"length": 14, "section_id": 7346, "quality": 1.0}}}});