post_cb({"17890219": {"CommentCount": "2", "ViewCount": "1456", "CreationDate": "2013-07-26T20:12:24.577", "LastActivityDate": "2013-07-26T21:10:32.613", "Title": "C++ priority queue behaves wierdly when using reference for the head element", "PostTypeId": "1", "Id": "17890219", "Score": "0", "Body": "<p>I have below code trying to dump the values stored in a priority_queue in C++:</p>\n<pre><code>priority_queue&lt;Point, vector&lt;Point&gt;, myCmp&gt; pq;\nint i;\nfor (i = 0; i &lt; 10; i++) {\n    Point p(i,i);\n    pq.push(p);\n}\nconst Point&amp; p0 = pq.top();\nwhile(!pq.empty()) {\n    cout&lt;&lt;p0.x&lt;&lt;p0.y&lt;&lt;endl;\n    pq.pop();\n}//I'm getting output like \"00 11 22 33 ... 99\"\n</code></pre>\n<p>As the comment in the code said, my reference variable p0 is keep changing every time the queue pops a value. That does not make sense to me, because I think p0 should always be a reference to (0,0) object, i.e. the front of the queue at the beginning. I know I can use </p>\n<pre><code>Point p0 = pq.top()\n</code></pre>\n<p>to get a copy of the front element and avoid the issue. But still, can someone explain the problem of using references? </p>\n<p>P.S. I did the same for C++ queue and didn't observe this issue. </p>\n", "Tags": "<c++><stl><priority-queue>", "OwnerUserId": "1118401", "AnswerCount": "2"}, "17890475": {"ParentId": "17890219", "CommentCount": "0", "Body": "<p>Actually, I'm going to give a more in depth answer with my comment. </p>\n<p>So when you get a reference, you are actually just getting a pointer to the front element. The std::vector is the underlying container, so the code you have is (in functionality) more similar to this than what you have:</p>\n<pre><code>vector&lt;Point&gt; pq;\nint i;\nfor (i = 0; i &lt; 10; i++) {\n    Point p(i,i);\n    pq.push_back(p);\n}\nPoint* p = &amp;pq[0];\n\nwhile(!pq.empty()) \n{\n    cout&lt;&lt;p-&gt;x&lt;&lt;p-&gt;y&lt;&lt;endl;\n    pq.erase(pq.begin(),pq.begin()+1);\n}//I'm getting output like \"00 11 22 33 ... 99\"\n</code></pre>\n<p>Now there is NO guarentee that p* points to the first member of the vector after you start messing with the values. Indeed, if I add a pq.resize(100); after the p assignment, while pq[0] still equals (0,0), p points to outer random un-reserved memory (reading either outputs junk or you get a seg-fault). You are getting the right values out right now due to pure chance! That is why you always need to copy or move before the pop.</p>\n", "OwnerUserId": "1756405", "PostTypeId": "2", "Id": "17890475", "Score": "1", "CreationDate": "2013-07-26T20:27:14.947", "LastActivityDate": "2013-07-26T20:27:14.947"}, "17890265": {"ParentId": "17890219", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>After you change <code>priority_queue</code> (for example by popping) all references are invlidated. So it's <strong>undefined</strong>(?) behaviour</p>\n<h2>What happens:</h2>\n<p>You get reference to the top element. It's stored as first element of underlying <code>std::vector</code>, so you have just link to first element in the <code>vector</code>. When <code>popping</code> you rearrange <code>vector</code> to new state with deleted previous top element. New top element should be first in <code>vector</code>. So, if <code>vector</code> is in same place reference points to new top</p>\n<p><strong>Added:</strong></p>\n<p>Some references:</p>\n<p>make_pop:\n\u00a7 23.6.4.3/4</p>\n<blockquote>\n<p id=\"so_17890219_17890265_0\">void pop();<br>\n  4 E\ufb00ects:<br>\n  pop_heap(c.begin(), c.end(), comp);<br>\n  c.pop_back();</br></br></br></p>\n</blockquote>\n<p>\u00a7 25.4.6.2/2  </p>\n<blockquote>\n<p id=\"so_17890219_17890265_1\">E\ufb00ects: Swaps the value in the location first with the value in the location last - 1 and makes<br>\n  [first,last - 1) into a heap.</br></p>\n</blockquote>\n<p>I didn't find info that <code>pop_back</code> for <code>vector</code> is exactly the same as <code>erase(end() - 1)</code> (only for strings), but it's seems to be true.</p>\n<p>\u00a7 23.3.6.5/3</p>\n<blockquote>\n<p id=\"so_17890219_17890265_2\">iterator erase(const_iterator position);<br>\n  iterator erase(const_iterator first, const_iterator last);<br>\n  E\ufb00ects: Invalidates iterators and references <strong>at or after the point of the erase</strong></br></br></p>\n</blockquote>\n<p>So it's seems it's valid to rely that reference will point to new top after <code>pop</code> because even reallocation seems to be impossible. But it's not good idea to use it anyway.</p>\n<hr>\n<p>*All reference to N3242</p>\n</hr>", "OwnerUserId": "768110", "LastEditorUserId": "768110", "LastEditDate": "2013-07-26T21:10:32.613", "Id": "17890265", "Score": "1", "CreationDate": "2013-07-26T20:14:51.100", "LastActivityDate": "2013-07-26T21:10:32.613"}, "bq_ids": {"n4140": {"so_17890219_17890265_1": {"section_id": 1473, "quality": 0.8333333333333334, "length": 10}, "so_17890219_17890265_2": {"section_id": 819, "quality": 0.5333333333333333, "length": 8}}, "n3337": {"so_17890219_17890265_1": {"section_id": 1467, "quality": 0.8333333333333334, "length": 10}, "so_17890219_17890265_2": {"section_id": 808, "quality": 0.5333333333333333, "length": 8}}, "n4659": {"so_17890219_17890265_2": {"section_id": 878, "quality": 0.5333333333333333, "length": 8}, "so_17890219_17890265_1": {"section_id": 1611, "quality": 0.8333333333333334, "length": 10}}}});