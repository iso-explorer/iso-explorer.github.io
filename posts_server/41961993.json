post_cb({"41962076": {"ParentId": "41961993", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>First of all, copy constructors can certainly be a template, loosely speaking. Technically, a copy constructor is a constructor from another instance of the same class, but you can certainly define a constructor that takes a reference to another class as a parameter.</p>\n<p>However, the answer to your primary method is that \"Method2\" allows the smart pointer to be assigned from a smart pointer to a different class, as long as the implied type conversion is allowed:</p>\n<pre><code>class Base {};\n\nclass Derived : public Base {};\n\nCptr&lt;Derived&gt; d;\n\nCptr&lt;Base&gt; b=d; // \"Method2\" will be used here.\n</code></pre>\n<p>This smart pointer implementation allows a smart pointer to a derived class to be assigned to a smart pointer to the base class.</p>\n<p>Normally, <code>Cptr&lt;Base&gt;</code> and <code>Cptr&lt;Derived&gt;</code> are two completely unrelated classes. Each template instance is a separate class. And you can't normally assign an instance of one class to an instance of a completely unrelated class, unless an appropriate conversion is available.</p>\n<p>Just like you can assign an ordinary pointer to a derived class to a pointer to a base class, this smart pointer provides comparable functionality.</p>\n", "OwnerUserId": "3943312", "LastEditorUserId": "3943312", "LastEditDate": "2017-01-31T16:08:16.207", "Id": "41962076", "Score": "3", "CreationDate": "2017-01-31T16:04:56.197", "LastActivityDate": "2017-01-31T16:08:16.207"}, "41962227": {"ParentId": "41961993", "CommentCount": "0", "Body": "<p>First of all, you are right. Copy constructors cannot be templates. \u00a712.8/2 says (emphasis by myself):</p>\n<blockquote>\n<p id=\"so_41961993_41962227_0\">A <strong>non-template</strong> constructor for class <code>X</code> is a copy constructor if its\n  first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other\n  parameters have default arguments [...]</p>\n</blockquote>\n<p>But method 2 is not a copy constructor, because <strong><code>Cptr&lt;S&gt;</code> is a different class than <code>Cptr&lt;T&gt;</code></strong>. It is just a normal constructor, not really much different to, say, <code>Cptr(int i)</code> or <code>Cptr(std::string const&amp; s)</code>. And normal constructors can be templates.</p>\n<p>Of course, you can assume that <code>Cptr&lt;U&gt;</code> will have the same members as <code>Cptr&lt;T&gt;</code>. That's what the implementation of the constructor does. It would not work, for example, if <code>Cptr</code> was specialised for that <code>U</code> and those members did not exist.</p>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "41962227", "Score": "2", "CreationDate": "2017-01-31T16:13:02.950", "LastActivityDate": "2017-01-31T16:13:02.950"}, "41961993": {"CommentCount": "0", "ViewCount": "90", "PostTypeId": "1", "LastEditorUserId": "5128925", "CreationDate": "2017-01-31T16:01:41.550", "LastActivityDate": "2017-02-03T02:56:08.767", "Title": "Templated Class \"Copy Constructor\"", "AcceptedAnswerId": "41962076", "LastEditDate": "2017-02-03T02:56:08.767", "Id": "41961993", "Score": "0", "Body": "<p>I've come across this templated smart pointer class Cptr shown partially below, and I don't understand one of the method implementations and was hoping to get some input. My question is on 'Method 2', labeled below. Specifically, if Cptr is templated by T, what call syntax is available that allows 'Method 2' to be called, which appears, at least to me, to be a copy constructor, but I thought copy constructors are not templated. </p>\n<pre><code>template &lt;class T&gt; class Cptr\n{\n    public:\n\n        /* Constructors ... */\n\n        /* Getters ... */\n        T* ptr() const { return p_; }\n        long* cnt() const { return cnt_; }\n\n        /* Copy Constructors? */\n        //Method 1\n        Cptr&lt;T&gt;(const Cptr&lt;T&gt;&amp; i) \n            : ptr_(i.ptr()), cnt_(i.ptr())\n        {\n            std::cout &lt;&lt; \"M1\" &lt;&lt; std::endl;\n            ++(*cnt);\n        }\n\n        //Method 2\n        template &lt;class S&gt; Cptr(const Cptr&lt;S&gt;&amp; i) \n            : ptr_(i.get()), cnt_(i.cnt())\n        {\n            std::cout &lt;&lt; \"M2\" &lt;&lt; std::endl;\n            ++(*cnt_);\n        }\n\n    private:\n        T* p_;\n        int* cnt_;\n};\n\nint main(int argc, char* argv[])\n{\n\n    CPtr&lt;int&gt; A(new int(5));\n    CPtr&lt;int&gt; B(A);\n\n    std::cout &lt;&lt; *(B.get()) &lt;&lt; std::endl;\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>I envisioned a call to method 2 like so:</p>\n<pre><code>Cptr&lt;float&gt; B( new float(1.1) );\nCptr&lt;int&gt; A(B); //error for different types\n</code></pre>\n<p>But the assignment of pointers of different types does not make much sense to me. Has anyone come across a method definition like 'Method 2' and if so what are the uses? Thanks very much for your time.</p>\n", "Tags": "<c++>", "OwnerUserId": "5128925", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41961993_41962227_0": {"section_id": 451, "quality": 1.0, "length": 24}}, "n3337": {"so_41961993_41962227_0": {"section_id": 442, "quality": 1.0, "length": 24}}, "n4659": {"so_41961993_41962227_0": {"section_id": 474, "quality": 1.0, "length": 24}}}});