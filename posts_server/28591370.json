post_cb({"bq_ids": {"n4140": {"so_28591370_28591924_1": {"length": 4, "quality": 1.0, "section_id": 5834}, "so_28591370_28591924_0": {"length": 15, "quality": 0.9375, "section_id": 5817}, "so_28591370_28591924_2": {"length": 29, "quality": 0.90625, "section_id": 5834}}, "n3337": {"so_28591370_28591924_0": {"length": 15, "quality": 0.9375, "section_id": 5588}, "so_28591370_28591924_2": {"length": 20, "quality": 0.625, "section_id": 5605}}, "n4659": {"so_28591370_28591924_1": {"length": 4, "quality": 1.0, "section_id": 7296}, "so_28591370_28591924_0": {"length": 14, "quality": 0.875, "section_id": 7278}, "so_28591370_28591924_2": {"length": 29, "quality": 0.90625, "section_id": 7296}}}, "28591924": {"Id": "28591924", "PostTypeId": "2", "Body": "<p>\u00a71.10 [intro.multithread] (quoting N4140):</p>\n<blockquote>\n<p id=\"so_28591370_28591924_0\">6 Two expression evaluations <em>conflict</em> if one of them modifies a\n  memory location (1.7) and the other one accesses or modifies the same\n  memory location.</p>\n<p id=\"so_28591370_28591924_1\">23 Two actions are <em>potentially concurrent</em> if</p>\n<ul>\n<li>they are performed by different threads, or</li>\n<li>they are unsequenced, and at least one is performed by a signal handler.</li>\n</ul>\n<p id=\"so_28591370_28591924_2\">The execution of a program contains a <em>data race</em> if it contains two\n  potentially concurrent conflicting actions, at least one of which is\n  not atomic, and neither happens before the other, except for the\n  special case for signal handlers described below. Any such data race\n  results in undefined behavior.</p>\n</blockquote>\n<p><em>Purely</em> concurrent reads do not conflict, and so is safe.</p>\n<p>If at least one of the threads write to a memory location, and another reads from that location, then they conflict and are potentially concurrent. The result is a data race, and hence undefined behavior, unless appropriate synchronization is used, either by using atomic operations for all reads and writes, or by using synchronization primitives to establish a <em>happens before</em> relationship between the read and the write.</p>\n", "LastActivityDate": "2015-02-18T19:12:04.493", "CommentCount": "4", "CreationDate": "2015-02-18T19:12:04.493", "ParentId": "28591370", "Score": "7", "OwnerUserId": "2756719"}, "28592620": {"Id": "28592620", "PostTypeId": "2", "Body": "<p>This actually points to a race condition between writer thread and reader thread. The places where we access/write the global variable would be the critical sections of the code. Ideally we must synchronize between the read/write threads whenever we operate in the critical sections or else we may see unspecific behavior in the code.</p>\n<p>Your problem is similar to a reader-writer problem and we must synchronize using semaphores, mutex and other locking mechanisms to avoid the race condition. Assuming 1 writer and multiple reader we may use the following code to avoid undefined behavior:</p>\n<p><div class=\"snippet\" data-hide=\"false\" data-lang=\"js\">\n<div class=\"snippet-code\">\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>// Using read and write semaphores\r\nsemaphore rd, wrt; \r\nint readCount;\r\n\r\n// Writer Thread \r\n\r\ndo\r\n{\r\n...\r\n// Critical Section Starts  \r\n\r\nwait(wrt);\r\n    global variable = someValues;   // Write to the global Variable.\r\nsignal(wrt);\r\n\r\n// Critical Section Ends  \r\n...\r\n} while(1)\r\n\r\n\r\n// Reader thread \r\n\r\ndo\r\n{\r\n...\r\n// Critical Section 1 Starts  \r\n\r\nwait(rd)\r\nreadcount++;\r\n    if(readCount == 1) \r\n        wait(wrt);\r\nsignal(rd);\r\n\r\n// Critical Section 1 Ends\r\n\r\n// Do Reading \r\n\r\n// Critical Section 2 Starts\r\nwait(rd)  \r\n    readcount--;\r\n    if(readCount == 0)\r\n        signal(wrt);\r\nsignal(rd)\r\n// Critical Section 2 Ends\r\n...\r\n} while(1)</code></pre>\n</div>\n</div>\n</p>\n", "LastActivityDate": "2015-02-18T19:51:11.080", "CommentCount": "0", "CreationDate": "2015-02-18T19:51:11.080", "ParentId": "28591370", "Score": "0", "OwnerUserId": "4581012"}, "28592495": {"Id": "28592495", "PostTypeId": "2", "Body": "<h2>Yes. No. Maybe.</h2>\n<p>The formally correct answer is: <em>This is not safe</em>.</p>\n<p>The practical answer is not that easy. It's something like <em>\"This is safe, kind of, under some conditions\"</em>.</p>\n<p>Reads (any number of them) in absence of concurrent writes are <em>always</em> safe. Reads (even a single one) in presence of concurrent writes (even a single one) are <em>formally</em> never safe, but they are atomic on most processors in most situations, and this can be <em>just good enough</em>. Changing values (like incrementing a counter) is nearly always troublesome, even in practice, without explicitly using atomic operations.</p>\n<h2>Atomicity</h2>\n<p>The C++ standard mandates that you use <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow\"><code>std::atomic</code></a> or one of its specializations (or higher level synchronization primitives), or you are doomed. Demons will fly out of your nose (no, they won't... but as far as the standard goes, they might as well).</p>\n<p>All real, non-theoretical CPUs access memory exclusively via cache lines except in very special conditions which you must expclicitly provoke (such as using write-combining instructions). An entire cache line can be read or written to, atomically, at a time -- never anything different. Reading any memory location that is being written to might not give the value that you expect (if it has been updated in the mean time), but it will never return a \"garbage\" value.<br>\nNow of course a variable <em>might</em> cross a cacheline, in which case access isn't atomic, but unless you deliberately provoke it, this will not happen (since integral variables are power-of-two sized such as 2, or 4, or 8, and cache lines are also power-of-two sized and larger such as 64 or 128 -- if your variables are properly aligned to the former as by default, they are <em>automatically</em> also completely contained within the latter. Always.).</br></p>\n<h2>Ordering</h2>\n<p>Although your reads (and writes) may be atomic, and you might say that you only care whether some flag is zero or not so who cares even if a value is garbled, you don't have a guarantee that things happen in the order that you expect!<br>\nThe \"normal\" expectation that if you say that A happens before B, then A indeed happens before B and A <em>can be seen by someone else</em> before B is generally <strong>not true</strong>. In other words, it is perfectly possible that your worker thread prepares some data and then sets the <code>ready</code> flag. Your main thread sees that the <code>ready</code> flag is set, and begins reading some random garbage while the real data is still on its way somewhere in the cache hierarchy. Or maybe half of it is visible to the main thread already, but the other half isn't.</br></p>\n<p>For this, C++11 introduced the concept of <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\">memory order</a>. This means no more and no less than besides having the guarantee of atomicity, you <em>also</em> have a way of requesting a happens-before guarantee.<br>\nMost of the time, this only prevents the compiler from moving around loads and stores, but on some architectures, it may cause special instructions to be emitted (that's not your problem, though).</br></p>\n<h2>Read-Modify-Write</h2>\n<p>This is a particularly nefarious one. A simple thing like <code>++flag;</code> can be desastrous. This is <em>not at all the same</em> as <code>flag = 1;</code></p>\n<p>Without using proper atomic instructions, this is <strong>never</strong> safe, as it involves (atomically) reading, then modifying, and then (atomically) writing a cache line.<br>\nThe problem is, while reading and writing are both atomic, the whole thing isn't. Nor is there any guarantee about ordering.</br></p>\n<h2>Solution?</h2>\n<p>Either use <code>std::atomic</code> or block on a condition variable. The former will involve spinning, which may or may not be detrimental (depending on the frequency and latency requirements) while the latter will be CPU conservative.<br>\nYou could use a <code>mutex</code> to synchronize access to the global variable, too, but if you involve a heavyweight primitive, you might as well go for the condition variable instead of spinning (which will be the \"correct\" approach).</br></p>\n", "LastActivityDate": "2015-02-18T19:44:03.893", "CommentCount": "0", "CreationDate": "2015-02-18T19:44:03.893", "ParentId": "28591370", "Score": "1", "OwnerUserId": "572743"}, "28591420": {"Id": "28591420", "PostTypeId": "2", "Body": "<p>This really depends on a number of factors but is generally a bad idea and can lead to <a href=\"http://en.wikipedia.org/wiki/Race_condition\" rel=\"nofollow\">race conditions</a>. You can avoid this by locking the value so that reads and writes are all atomic and thus can't collide.</p>\n", "LastActivityDate": "2015-02-18T18:44:12.760", "CommentCount": "0", "CreationDate": "2015-02-18T18:44:12.760", "ParentId": "28591370", "Score": "1", "OwnerUserId": "335794"}, "28591446": {"Id": "28591446", "PostTypeId": "2", "Body": "<p>You must create a mutex (mutual exclusion object), only one thread at a time can own the mutex, and use it to control access to the variables. <a href=\"https://msdn.microsoft.com/en-us/library/z3x8b09y.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/z3x8b09y.aspx</a> </p>\n", "LastActivityDate": "2015-02-18T18:45:47.593", "CommentCount": "4", "CreationDate": "2015-02-18T18:45:47.593", "ParentId": "28591370", "Score": "0", "OwnerUserId": "3877712"}, "28591431": {"Id": "28591431", "PostTypeId": "2", "Body": "<p>Concurrent writes are not safe. Concurrent read and write are always safe (assuming atomic writes), but you never know whether you've read the value before or after write.</p>\n<p>Main thread behaves just the same as spawned threads, there's no difference at all.</p>\n<p>So, for concurrent write you'll need mutexes.</p>\n", "LastEditorUserId": "655027", "LastActivityDate": "2015-02-19T06:49:01.090", "Score": "-1", "CreationDate": "2015-02-18T18:44:55.717", "ParentId": "28591370", "CommentCount": "4", "OwnerUserId": "655027", "LastEditDate": "2015-02-19T06:49:01.090"}, "28591574": {"Id": "28591574", "PostTypeId": "2", "Body": "<p>If your different threads only read values of global variables, there will be no problem.</p>\n<p>If more than one thread tries to update same variable (example read, add 1 write), then you <strong>must</strong> use a synchronization system to ensure that the value cannot be modified between the read and the write.</p>\n<p>If only one thread writes while others read, it depends. If the different variables are unrelated, say number of apples and oranges in a basket, you do not need any synchronization, provided you accept not exactly accurate values. But if the values are related say amount of money on two bank accounts with a transfert between them, you need synchronization to ensure that what you read is coherent. It could be too old when you use it because it has already be updated but you have coherent values.</p>\n", "LastActivityDate": "2015-02-18T18:52:16.290", "CommentCount": "2", "CreationDate": "2015-02-18T18:52:16.290", "ParentId": "28591370", "Score": "4", "OwnerUserId": "3545273"}, "28591414": {"Id": "28591414", "PostTypeId": "2", "Body": "<p>The simple answer is yes. Once variables are starting to be shared amongs multiple threads for both reading and writing you will need some kind of protection.\nThere are different flavours to achieve this :\nSemaphores,\nlocks,\nmutex,\nevents,\ncritical section\nmessage queues.\nEspecially when your globals are references things can become ugly.\nSuppose you have global list of objects in a consumers / producers scenario with multiple consumers, the producer instantiates objects, the consumer takes them, does something with them and finally disposes them, without protection of some sort this leads to terrible problems.\nThere is a lot of specialised literature about this topic and there are dedicated college courses about this topic, and well known problems that are being given to students. For instance the dining philosefers problem, howto make a readerswritersemaphore without starvation, ... .\nInteresting book : the little book about semaphores.</p>\n", "LastEditorUserId": "2382728", "LastActivityDate": "2015-02-18T18:56:48.970", "Score": "2", "CreationDate": "2015-02-18T18:43:46.937", "ParentId": "28591370", "CommentCount": "4", "OwnerUserId": "2382728", "LastEditDate": "2015-02-18T18:56:48.970"}, "28591370": {"ViewCount": "2073", "Body": "<p>So I'm writing this neat little program to teach myself threading, I'm using boost::thread and C++ to do so.</p>\n<p>I need the main thread to communicate with the worker thread, and to do so I have been using global variables. It is working as expected, but I can't help but feel a bit uneasy.  </p>\n<p>What if the the worker thread tries write to a global variable at the same time as the main thread is reading the value. Is this bad, dangerous, or hopefully taken into account behind the scenes??</p>\n", "AcceptedAnswerId": "28591924", "Title": "Is it dangerous to read global variables from separate threads at potentially the same time?", "CreationDate": "2015-02-18T18:40:36.277", "Id": "28591370", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-02-19T06:49:01.090", "Score": "5", "OwnerUserId": "3359379", "Tags": "<c++><boost-thread>", "AnswerCount": "8"}});