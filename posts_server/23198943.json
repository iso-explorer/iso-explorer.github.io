post_cb({"bq_ids": {"n4140": {"so_23198943_23198943_0": {"length": 19, "quality": 1.0, "section_id": 3402}}, "n3337": {"so_23198943_23198943_0": {"length": 19, "quality": 1.0, "section_id": 3271}}, "n4659": {"so_23198943_23198943_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 4159}}}, "23200291": {"Id": "23200291", "PostTypeId": "2", "Body": "<p>It doesn't work the other way round. A <code>std::complex&lt;float&gt;</code> is two consecutive <code>float</code>'s in memory as proven by what the standard does allow you to do, but you have a pointer to a single float value and turn it into a pointer to a structure which should contain two floats. Even if you would have two floats, the standard doesn't guarantee it and it would therefore be illegal to <code>reinterpret_cast</code> to pointers in that direction.</p>\n", "LastActivityDate": "2014-04-21T15:22:31.487", "Score": "1", "CreationDate": "2014-04-21T15:22:31.487", "ParentId": "23198943", "CommentCount": "0", "OwnerUserId": "2073257"}, "23198943": {"ViewCount": "1226", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\"><strong>N3797</strong></a> <strong>26.4 [complex.numbers]</strong> says this about casting <code>std::complex&lt;T&gt;*</code> to <code>T*</code></p>\n<blockquote>\n<p id=\"so_23198943_23198943_0\">4 Moreover, if a is an expression of type <code>cv std::complex&lt;T&gt;*</code> and the expression <code>a[i]</code> is well-defined for an integer expression <code>i</code>, then:<br>\n   - <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> shall designate the real part of <code>a[i]</code>, and<br>\n   - <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</code> shall designate the imaginary part of <code>a[i]</code>.</br></br></p>\n</blockquote>\n<p>Does this (or some other wording of the standard) imply that I can <code>reinterpret_cast</code> the other way?  Can I do this:</p>\n<pre><code>    float * pf;\n    std::complex&lt;float&gt;* pc = reinterpret_cast&lt;std::complex&lt;float&gt;*&gt;(pf);\n    pc[i].real();\n</code></pre>\n<p>As n.m. pointed out below, I would have to make sure the alignment of <code>pf</code> is suitable for a <code>std::complex&lt;float&gt;</code>.  This can be assumed to be taken care of.</p>\n", "AcceptedAnswerId": "23200815", "Title": "Is it legal to cast float* to std::complex<float>*", "CreationDate": "2014-04-21T13:58:51.343", "Id": "23198943", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-25T20:01:07.360", "LastEditorUserId": "3204551", "LastActivityDate": "2015-07-25T20:01:07.360", "Score": "7", "OwnerUserId": "1277769", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}, "23200815": {"Id": "23200815", "PostTypeId": "2", "Body": "<p>No, that clause makes no such guarantee.</p>\n<p>Now, in practice, the most common issue would be alignment: but even that may be rare.</p>\n<p>The second problem would involve strict aliasing, where memory allocated as a <code>double</code> can be assumed by the compiler to not be modified by any operation involving pointers to other types (except <code>char</code>).  The above places a restricition going the other way (a <code>complex</code> allocated pointer may not assume thay <code>double*</code>s do not point to its data), but not in the direction you want.  Again this is relatively obscure, but a compiler could use this to reorder writes in your code.</p>\n<p>It will, however, usually work.  More often if you align it, and your compiler does not use strict aliasing assumptions: even then it is undefined behaviour by the standard, however.</p>\n", "LastActivityDate": "2014-04-21T15:52:54.203", "Score": "3", "CreationDate": "2014-04-21T15:52:54.203", "ParentId": "23198943", "CommentCount": "3", "OwnerUserId": "1774667"}});