post_cb({"41058221": {"CommentCount": "0", "ViewCount": "778", "CreationDate": "2016-12-09T10:26:46.577", "LastActivityDate": "2016-12-09T10:32:38.060", "Title": "Cast unsigned to signed and back", "AcceptedAnswerId": "41058349", "PostTypeId": "1", "Id": "41058221", "Score": "6", "Body": "<p>I have an unsigned value that needs to pass through a function as a signed value (it is not touched by the function). When it comes out I cast it back to unsigned. I know that the result of a cast to signed is implementation defined when overflowing, but can I at least guarantee that I end up with the same value when I cast it back (like with function pointers)?</p>\n<p>Example:</p>\n<pre><code>int32_t function_with_default(int32_t a_Default)\n{\n    // Try some stuff\n    // ...\n\n    // Fall back to default\n    return a_Default;\n}\n\nvoid main()\n{\n    uint32_t input = UINT32_MAX;\n    uint32_t output = static_cast&lt;uint32_t&gt;(function_with_default(static_cast&lt;int32_t&gt;(input));\n\n    // Is is guarenteed to be true?\n    input == output;\n}\n</code></pre>\n<p>I do have the guarentee that the signed integer is always bigger or equal than the unsigned integer in bytes, so no data should be lost due to lack of space.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "2534689", "AnswerCount": "2"}, "41058349": {"ParentId": "41058221", "CommentCount": "1", "Body": "<p>No, you don't have such guarantee: [conv.integral]</p>\n<blockquote>\n<p id=\"so_41058221_41058349_0\">2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2^n where n is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s\n  complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is\n  no truncation). \u2014end note ]</p>\n<p id=\"so_41058221_41058349_1\">3 If the destination type is signed, the value is unchanged if it can be represented in the destination type;\n  otherwise, the value is <strong>implementation-defined</strong>.</p>\n</blockquote>\n", "OwnerUserId": "1989995", "PostTypeId": "2", "Id": "41058349", "Score": "6", "CreationDate": "2016-12-09T10:32:38.060", "LastActivityDate": "2016-12-09T10:32:38.060"}, "41058304": {"ParentId": "41058221", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, you can't, because the result of a cast to signed is implementation defined when overflowing.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/14664896/560648\">does in c++ the conversion from unsigned int to int always preserve the bit pattern?</a></li>\n</ul>\n", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:44.480", "Id": "41058304", "Score": "0", "CreationDate": "2016-12-09T10:31:09.103", "LastActivityDate": "2016-12-09T10:31:09.103"}, "bq_ids": {"n4140": {"so_41058221_41058349_0": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_41058221_41058349_1": {"section_id": 32, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_41058221_41058349_0": {"section_id": 28, "quality": 0.90625, "length": 29}, "so_41058221_41058349_1": {"section_id": 29, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_41058221_41058349_1": {"section_id": 32, "quality": 0.9166666666666666, "length": 11}, "so_41058221_41058349_0": {"section_id": 31, "quality": 0.90625, "length": 29}}}});