post_cb({"bq_ids": {"n4140": {"so_38862435_38862457_0": {"length": 40, "quality": 0.975609756097561, "section_id": 7200}}, "n3337": {"so_38862435_38862457_0": {"length": 40, "quality": 0.975609756097561, "section_id": 6944}}, "n4659": {"so_38862435_38862457_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 8709}}}, "38862435": {"ViewCount": "32", "Body": "<p>Suppose I have a have a class <code>T</code> and an array:</p>\n<pre><code>uint8_t array[sizeof(T)];\n</code></pre>\n<p>One thing to note is that <code>array</code> might have an alignment which might not be compatible with <code>T</code>.</p>\n<p>Now the question is: Is there any way to store a <code>T</code> in array (despite the alignment issues), provided that we do not try to do any thing with the <code>T</code>, until we copy it from the array into a properly aligned storage space?</p>\n<p>In other words <code>array</code> is just going to be a storage location, until we need to access <code>T</code>, at which case we copy it to proper alignment, and use the value, and copy it back into storage.</p>\n<p>Note:</p>\n<p><code>T</code> may be trivially copyable but it is not guaranteed that <code>T</code> is going to be trivially copyable......it could be any class you could think of </p>\n<p>So.....is this in any way possible (hopefully standard conforming?)</p>\n", "Title": "Store aligned data non aligned", "CreationDate": "2016-08-10T00:27:31.857", "LastActivityDate": "2016-08-10T00:36:55.130", "CommentCount": "2", "LastEditDate": "2016-08-10T00:35:02.650", "PostTypeId": "1", "LastEditorUserId": "6149078", "Id": "38862435", "Score": "0", "OwnerUserId": "6149078", "Tags": "<c++><alignment>", "AnswerCount": "1"}, "38862457": {"Id": "38862457", "PostTypeId": "2", "Body": "<p><sup><em>The question is evolving and I'm not going to track it by revising this answer correspondingly.</em></sup></p>\n<p>Yes,  for a <em>trivially copyable</em> object you can use <code>memcpy</code>, and that's used in a (non-normative) example in the standard.</p>\n<i>C++11 \u00a73.9/2:</i>\n<blockquote>\n<p id=\"so_38862435_38862457_0\"><strong>\u201d</strong> For any object (other than a base-class subobject) of trivially copyable type <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes (1.7) making up the object can be copied into an array of <code>char</code> or <code>unsigned char</code>. If the content of the array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall subsequently hold its original value.</p>\n</blockquote>\n<p>For template code you can check whether a type is trivially copyable via <a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\" rel=\"nofollow\"><code>std::is_trivially_copyable</code></a>.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-08-10T00:36:55.130", "Score": "1", "CreationDate": "2016-08-10T00:29:51.233", "ParentId": "38862435", "CommentCount": "5", "OwnerUserId": "464581", "LastEditDate": "2016-08-10T00:36:55.130"}});