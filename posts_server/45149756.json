post_cb({"45150017": {"ParentId": "45149756", "CommentCount": "6", "Body": "<p><code>delete</code> is defined in [expr.delete] to invoke a deallocation function, and deallocation functions are defined in [basic.stc.dynamic.deallocation] as:</p>\n<blockquote>\n<p id=\"so_45149756_45150017_0\">Each deallocation function shall return <code>void</code> and its first parameter shall be <code>void*</code>.</p>\n</blockquote>\n<p>Since all deallocation functions get <code>void*</code>, not a <code>void*&amp;</code>, there's no mechanism for them to be able to modify their parameters. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "45150017", "Score": "2", "CreationDate": "2017-07-17T17:12:29.037", "LastActivityDate": "2017-07-17T17:12:29.037"}, "45815061": {"ParentId": "45149756", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The context in which you found the statement from Stroustrup, is available under <a href=\"http://www.stroustrup.com/bs_faq2.html#delete-zero\" rel=\"nofollow noreferrer\">Stroustrup, delete zero</a></p>\n<p>Stroustrup let you consider</p>\n<pre><code>delete p;\n// ...\ndelete p;\n</code></pre>\n<p>After the first delete, pointer p was invalid. The second delete is wrong, but it would have no effect if p was set to 0 after the first delete.</p>\n<p>Stroustrups idea was to compile it as something like </p>\n<pre><code>delete p; p = 0;\n// ...\ndelete p;\n</code></pre>\n<p>delete itself is not able to zero out the pointer since it passed <code>void *</code> but not <code>void *&amp;</code></p>\n<p>However, I find zero out p doesn't help very much as they may exist other copies of that pointer which may accidently deleted, too.\nA better way is to use the different type of smartpointers.</p>\n<h3>Spec 6.7</h3>\n<p>Says that any pointer with the address of pointer p will be invalid (in an implementation defined way) after a delete p. It says nothing about changing the pointer address, neither it is allowed nor it is forbidden.</p>\n<h3>Spec 6.9</h3>\n<p>The prerequisit of 6.9 is a object (valid or not). This spec does not apply here since p (the address) is no more valid after delete and thatfore does NOT point to an object. So there is no contradiction, and any discussion whether 6.7 or 6.9 is stronger is invalid.</p>\n<p>The spec requires also to copy the bytes back to the original object location, which your code does not, and would not be able too, because the original object has been deleted.</p>\n<hr>\n<p>However, I see no reason to pack a pointer address into a char array and pass it. And pointers have always the same size in an certain implementation. Your code is just a cumbersome version of:</p>\n<pre><code>SomeObject *o = ...;\n\nvoid *orgO = o;\ndelete o;\n\nsomeHashtable.remove(orgO);\n// someHashtable.remove(o); o might be set to 0\n</code></pre>\n<p>However, this code still looks strange. To get an object from the hash table you need the pointer to that object. Why not directly use the pointer directly??</p>\n<p>A hash table should help to find objects by some invariant values of the objects. That is not your application of hash table</p>\n<p>Did you intented to have a list of all valid instances of <code>SomeObject</code>?</p>\n<p><strong>Your code is invalid cause</strong>, according to Stroustrup, the compiler is allowed to set p to zero. If this happened your code will crash </p>\n</hr>", "OwnerUserId": "732454", "LastEditorUserId": "732454", "LastEditDate": "2017-08-22T11:00:09.187", "Id": "45815061", "Score": "2", "CreationDate": "2017-08-22T10:22:55.317", "LastActivityDate": "2017-08-22T11:00:09.187"}, "45787047": {"ParentId": "45149756", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>Before the deletion, <code>ptr</code>'s value was valid. After the deletion, the value was invalid. Therefore the value changed.  Valid values and invalid values are mutually exclusive -- a value cannot be simultaneously valid and invalid.</p>\n<p>Your question has a basic misconception; you're conflating these two different concepts:</p>\n<ul>\n<li>The value of a variable</li>\n<li>The representation of a variable in memory.</li>\n</ul>\n<p>There isn't a one-to-one correspondence between these two things. The same value may have multiple representations, and the same representation may correspond to different values. </p>\n<hr>\n<p>I think the gist of your question is: <em>can <code>delete ptr;</code> change the representation of <code>ptr</code>?</em>.  To which the answer is \"Yes\". You could memcpy the deleted pointer into a char array, inspect the bytes, and find them all to be zero-valued bytes (or anything else). This is covered in the standard by C++14 [basic.stc.dynamic.deallocation]/4:</p>\n<blockquote>\n<p id=\"so_45149756_45787047_0\">Any other use of an invalid pointer value has implementation-defined behavior. </p>\n</blockquote>\n<p>It's implementation-defined and the implementation could define that inspecting the bytes gives bytes with value zero.</p>\n<hr>\n<p>Your code snippet relies on implementation-defined behaviour. \"Valid code\" isn't terminology used by the Standard, but the code might not remove the intended item from the hash table.</p>\n<p>As alluded to by Stroustrup, this is an intentional design decision.  An example usage would be a compiler in debug mode setting deleted pointers to a particular representation, so that it can raise a runtime error if a deleted pointer is subsequently used. <a href=\"https://stackoverflow.com/questions/30579430/access-violation-writing-location-0xcdcdcdcd\">Here's an example</a> of that principle in action for uninitialized pointers.</p>\n<p>Historical note: In C++11 this case was <em>undefined</em>, rather than implementation-defined. So the behaviour of using a deleted pointer was identical to the behaviour of using an uninitialized pointer.  In the C language, freeing memory is defined as putting all pointers to that memory into the same state as an uninitialized pointer has.</p>\n</hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2017-08-20T22:01:36.773", "Id": "45787047", "Score": "10", "CreationDate": "2017-08-20T21:42:37.827", "LastActivityDate": "2017-08-20T22:01:36.773"}, "45807513": {"ParentId": "45149756", "CommentCount": "4", "Body": "<p>In order for a delete function to update the pointer, it needs to know the address of this pointer and also do the update. This would require extra memory, few extra operations and a compiler support. Looks more or less trivial in your example. </p>\n<p>Now imagine a chain of functions which pass the pointer to each other in arguments and only the last one will really delete. Which pointers to update in such a case? The last one? All? For the latter one would need to create a dynamic lists of pointers:</p>\n<pre><code>Objec *o = ...\nhandle(o);\nvoid handle(Object *o){\n   if (deleteIt) doDelete(0);\n   else doSomethingElseAndThenPossiblyDeleteIt(o);\n}\nvoid doDelete(Object *o) {\n    delete o;\n}\n</code></pre>\n<p>So, philosophically if the delete would be allowed to modify its parameter, it would open a can of warms reducing program efficiency. So, it is not allowed and i hope that it will never be. The undefined behavior is probably the most natural thing in those cases. </p>\n<p>As for the memory contents, unfortunately i saw too many errors where a deleted memory gets overwritten after the pointer was deleted. And... it works ok till a moment comes. Since the memory is marked as free it get reused by other objects eventually with very uninteresting consequences and a lot of debugging. So, philosophically again, c++ is not an easy language to program with. There are other tools which could catch those issues, without any language support.  </p>\n", "OwnerUserId": "1143850", "PostTypeId": "2", "Id": "45807513", "Score": "1", "CreationDate": "2017-08-22T01:07:08.097", "LastActivityDate": "2017-08-22T01:07:08.097"}, "45149756": {"CommentCount": "33", "AcceptedAnswerId": "45787047", "PostTypeId": "1", "LastEditorUserId": "8157187", "CreationDate": "2017-07-17T16:57:04.650", "LastActivityDate": "2017-08-25T09:28:08.993", "LastEditDate": "2017-08-22T08:29:28.127", "ViewCount": "805", "FavoriteCount": "1", "Title": "Is delete allowed to modify its parameter?", "Id": "45149756", "Score": "32", "Body": "<p>In an answer, <a href=\"https://stackoverflow.com/a/704568/8157187\">https://stackoverflow.com/a/704568/8157187</a>, there is a quote from Stroustrup:</p>\n<blockquote>\n<p id=\"so_45149756_45149756_0\">C++ explicitly allows an implementation of delete to zero out an\n  lvalue operand, and I had hoped that implementations would do that,\n  but that idea doesn't seem to have become popular with implementers.</p>\n</blockquote>\n<p>However, I failed to find this explicit statement in the standard. There is a part of the current draft standard (N4659), that one may interpret this way:</p>\n<p>6.7:</p>\n<blockquote>\n<p id=\"so_45149756_45149756_1\">When the end of the duration of a region of storage is reached, the\n  values of all pointers representing the address of any part of that\n  region of storage become invalid pointer values (6.9.2). Indirection\n  through an invalid pointer value and passing an invalid pointer value\n  to a deallocation function have unde\ufb01ned behavior. Any other use of an\n  invalid pointer value has implementation-de\ufb01ned behavior.</p>\n<p id=\"so_45149756_45149756_2\">Footnote: Some implementations might de\ufb01ne that copying an invalid pointer value causes a system-generated runtime fault</p>\n</blockquote>\n<p>So, after a <code>delete ptr;</code>, <code>ptr</code>'s value becomes a invalid pointer value, and using this value has implementation-defined behavior. However, it doesn't say that <code>ptr</code>'s value is allowed to change.</p>\n<p>It might be a philosophical question, how can one decide that a value has changed, if one cannot use its value?</p>\n<p>6.9:</p>\n<blockquote>\n<p id=\"so_45149756_45149756_3\">For any object (other than a base-class subobject) of trivially\n  copyable type T, whether or not the object holds a valid value of type\n  T, the underlying bytes (4.4) making up the object can be copied into\n  an array of char, unsigned char, or std::byte (21.2.1).43 If the\n  content of that array is copied back into the object, the object shall\n  subsequently hold its original value.</p>\n</blockquote>\n<p>So, it seems, that it is valid to <code>memcpy</code> an invalid pointer value into a char array (depending on which statement is \"stronger\", 6.7 or 6.9. To me, 6.9 seems stronger).</p>\n<p>This way, I can detect, that the pointer value has been changed by <code>delete</code>: <code>memcpy</code> the pointer's value before and after the <code>delete</code> to char array, then compare them.</p>\n<p>So, as I understand, 6.7 doesn't grant that <code>delete</code> is allowed to modify its parameter.</p>\n<p>Is delete allowed to modify its parameter?</p>\n<p>Check out the comments here:\n<a href=\"https://stackoverflow.com/a/45142972/8157187\">https://stackoverflow.com/a/45142972/8157187</a></p>\n<hr>\n<p>Here's an unlikely, but still possible real-world code, where this matters:</p>\n<pre><code>SomeObject *o = ...; // We have a SomeObject\n// This SomeObject is registered into someHashtable, with its memory address\n// The hashtable interface is C-like, it handles opaque keys (variable length unsigned char arrays)\n\ndelete o;\n\nunsigned char key[sizeof(o)];\nmemcpy(key, &amp;o, sizeof(o)); // Is this line OK? Is its behavior implementation defined?\nsomeHashtable.remove(key, sizeof(key)); // Remove o from the hashtable\n</code></pre>\n<p>Of course, this snippet can be reordered, so it becomes a surely valid code. But the question is: is this a valid code?</p>\n<hr>\n<p>Here's a related train of thought: suppose, that an implementation does define what footnote describes:</p>\n<blockquote>\n<p id=\"so_45149756_45149756_4\">copying an invalid pointer value causes a system-generated runtime fault</p>\n</blockquote>\n<p>6.9 guarantees that I can <code>memcpy()</code> any value. Even an invalid one. So in this theoretical implementation, when I <code>memcpy()</code> the invalid pointer value (which should succeed, 6.9 guarantees that), in a sense, I don't use the invalid pointer value, but only its underlying bytes (because it would generate a runtime fault, and 6.9 doesn't allow it), <strong>so 6.7 doesn't apply</strong>.</p>\n</hr></hr>", "Tags": "<c++><language-lawyer><c++1z>", "OwnerUserId": "8157187", "AnswerCount": "5"}, "45876962": {"ParentId": "45149756", "PostTypeId": "2", "CommentCount": "15", "Body": "<blockquote>\n<blockquote>\n<p id=\"so_45149756_45876962_1\">Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</p>\n</blockquote>\n</blockquote>\n<p></p>\n<blockquote>\n<p id=\"so_45149756_45876962_2\">So, after a <code>delete ptr;</code>, <code>ptr</code>'s value becomes a invalid pointer value, and using this value has implementation-defined behavior.</p>\n</blockquote>\n<p>The standard is saying that the pointer value passed \"becomes invalid\", ie its status has changed so that certain calls become undefined and the implementation can treat it differently.</p>\n<p>The language is not very clear, but here is the context:</p>\n<blockquote>\n<p id=\"so_45149756_45876962_3\">6.7 Storage duration<br>\n  4 When the end of the duration of a region of storage is reached, the values of all pointers representing the address of any part of that region of storage become invalid pointer values (6.9.2). Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</br></p>\n</blockquote>\n<p></p>\n<blockquote>\n<p id=\"so_45149756_45876962_4\">6.9.2 Compound types<br>\n  Every value of pointer type is one of the following:<br>\n  (3.1) \u2014 a pointer to an object or function (the pointer is said to point to the object or function), or<br>\n  (3.2) \u2014 a pointer past the end of an object (8.7), or<br>\n  (3.3) \u2014 the null pointer value (7.11) for that type, or<br>\n  (3.4) \u2014 an invalid pointer value.  </br></br></br></br></br></p>\n</blockquote>\n<p>It is <em>values of type pointer</em> that are or are not invalid, and they \"become\" so according to the progress of excution of a program on the C++ abstract machine.</p>\n<p>The standard is not talking about changes to what value is held by the variable/object addressed by an lvalue or changes to the association of a symbol with a value.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_45149756_45876962_6\">C++ explicitly allows an implementation of delete to zero out an\n    lvalue operand, and I had hoped that implementations would do that,\n    but that idea doesn't seem to have become popular with implementers.</p>\n</blockquote>\n</blockquote>\n<p><em>Separately</em> from this, Stroustrup is saying that if an operand expression was a modifiable lvalue, ie an operand expression was the address of a variable/object holding a pointer value that gets passed, after which the status of that value is \"invalid\", then the implementation can set the value held by that variable/object to zero.</p>\n<blockquote>\n<p id=\"so_45149756_45876962_7\">However, it doesn't say that <code>ptr</code>'s value is allowed to change.</p>\n</blockquote>\n<p>Stroustrup is being informal by talking about what an implementation can do. The standard defines how an abstract C++ machine can/cannot/may behave. Here Stroustrup is talking about a hypothetical implementation that looks like that machine. A \"<code>ptr</code>'s value\" is \"allowed to change\" because the defined and undefined behaviour doesn't let you find out what that value is as of deallocation, and the implementation-defined behaviour can be anything, so it can be that the variable/object holds a different value.</p>\n<p>It does not make sense to talk about a value changing. You can't \"zero out\" a value; you can zero out a variable/object, and that's what we mean when we say \"zero out\" an lvalue--zero out the variable/object it references/identifies. Even if you stretch \"zero out\" to include associating a new value with a name or literal, the implementation can do this, because you cannot \"use\" the value at runtime via the name or literal to find out whether it is still associated with the same value.</p>\n<p>(However, since all one can do with a value is \"use\" it in a program by passing an lvalue identifying a variable/object holding it to an operator or by passing a reference or constant denoting it to an operator, and an operator can act as if a <em>different</em> value was passed, I guess you could reasonably informally sloppily capture that as \"values changing value\" in the implementation.)</p>\n<blockquote>\n<blockquote>\n<p id=\"so_45149756_45876962_9\">If the content of that array is copied back into the object, the object shall subsequently hold its original value.</p>\n</blockquote>\n</blockquote>\n<p>But copying it is using it so copying it is implementation-defined once it is \"invalid\". So calling a program that would normally copy it is implementation-defined. This is made clear by the footnote that gives the example that </p>\n<blockquote>\n<blockquote>\n<p id=\"so_45149756_45876962_11\">Some implementations might de\ufb01ne that copying an invalid pointer value causes a system-generated runtime fault</p>\n</blockquote>\n</blockquote>\n<p>Nothing does what it normally does as of undefined/implemenation-defined behaviour. We use the normal behaviour to determine a sequence of changes to an abstract machine, and if an implementation-defined state change arises then things act like the implementation defines them to act, not the way they normally do. Sadly the meaning of \"use of\" a value is not made clear. I don't know why you think 6.9 \"guarantees\" anything more or less re memcpy than anywhere re anything, which after an undefined/implementation-defined state is nothing.</p>\n", "OwnerUserId": "3404097", "LastEditorUserId": "3404097", "LastEditDate": "2017-08-25T09:28:08.993", "Id": "45876962", "Score": "1", "CreationDate": "2017-08-25T08:05:12.237", "LastActivityDate": "2017-08-25T09:28:08.993"}, "bq_ids": {"n4140": {"so_45149756_45876962_8": {"section_id": 7200, "quality": 1.0, "length": 12}, "so_45149756_45876962_0": {"section_id": 7183, "quality": 0.9545454545454546, "length": 21}, "so_45149756_45149756_4": {"section_id": 7183, "quality": 1.0, "length": 8}, "so_45149756_45876962_9": {"section_id": 7200, "quality": 1.0, "length": 12}, "so_45149756_45876962_3": {"section_id": 7183, "quality": 0.5813953488372093, "length": 25}, "so_45149756_45787047_0": {"section_id": 7183, "quality": 0.875, "length": 7}, "so_45149756_45876962_1": {"section_id": 7183, "quality": 0.9545454545454546, "length": 21}, "so_45149756_45876962_10": {"section_id": 7183, "quality": 0.8333333333333334, "length": 10}, "so_45149756_45149756_3": {"section_id": 7200, "quality": 0.925, "length": 37}, "so_45149756_45150017_0": {"section_id": 7181, "quality": 1.0, "length": 9}, "so_45149756_45149756_2": {"section_id": 7183, "quality": 0.7692307692307693, "length": 10}, "so_45149756_45149756_1": {"section_id": 7183, "quality": 0.5609756097560976, "length": 23}, "so_45149756_45876962_11": {"section_id": 7183, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_45149756_45876962_8": {"section_id": 6944, "quality": 1.0, "length": 12}, "so_45149756_45149756_3": {"section_id": 6944, "quality": 0.925, "length": 37}, "so_45149756_45876962_10": {"section_id": 6927, "quality": 0.5833333333333334, "length": 7}, "so_45149756_45149756_4": {"section_id": 6927, "quality": 0.875, "length": 7}, "so_45149756_45150017_0": {"section_id": 6925, "quality": 1.0, "length": 9}, "so_45149756_45149756_2": {"section_id": 6927, "quality": 0.5384615384615384, "length": 7}, "so_45149756_45876962_9": {"section_id": 6944, "quality": 1.0, "length": 12}, "so_45149756_45876962_4": {"section_id": 5913, "quality": 0.5517241379310345, "length": 16}, "so_45149756_45876962_11": {"section_id": 6927, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_45149756_45876962_8": {"section_id": 8709, "quality": 1.0, "length": 12}, "so_45149756_45876962_0": {"section_id": 8671, "quality": 0.9090909090909091, "length": 20}, "so_45149756_45149756_4": {"section_id": 8671, "quality": 1.0, "length": 8}, "so_45149756_45876962_9": {"section_id": 8709, "quality": 1.0, "length": 12}, "so_45149756_45876962_4": {"section_id": 8732, "quality": 0.7586206896551724, "length": 22}, "so_45149756_45149756_1": {"section_id": 8671, "quality": 0.9024390243902439, "length": 37}, "so_45149756_45787047_0": {"section_id": 8671, "quality": 0.75, "length": 6}, "so_45149756_45876962_3": {"section_id": 8671, "quality": 0.8837209302325582, "length": 38}, "so_45149756_45876962_1": {"section_id": 8671, "quality": 0.9090909090909091, "length": 20}, "so_45149756_45876962_10": {"section_id": 8671, "quality": 0.8333333333333334, "length": 10}, "so_45149756_45149756_3": {"section_id": 8709, "quality": 0.95, "length": 38}, "so_45149756_45150017_0": {"section_id": 8689, "quality": 1.0, "length": 9}, "so_45149756_45149756_2": {"section_id": 8671, "quality": 0.7692307692307693, "length": 10}, "so_45149756_45876962_11": {"section_id": 8671, "quality": 0.8333333333333334, "length": 10}}}});