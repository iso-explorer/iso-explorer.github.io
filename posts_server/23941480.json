post_cb({"23941748": {"ParentId": "23941480", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Your question:</p>\n<blockquote>\n<p id=\"so_23941480_23941748_0\"><code>int N::j=i</code> actual appears into the namespace scope. Hence the declaration <code>int i=2</code> is not visible for unqualified name lookup. Why does this declaration found?</p>\n</blockquote>\n<p>Answer:</p>\n<blockquote>\n<p id=\"so_23941480_23941748_1\">Since <code>i</code> is not found in the <code>N</code> namespace, it is looked up in the global namespace. Had an <code>i</code> been there in the <code>N</code> namespace, that would have been used to initialize <code>N::j</code>.</p>\n</blockquote>\n<p>Hope the following program clarifies your doubt.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace N \n{\n   extern int j;\n   extern int k;\n\n   int x = 3;\n}\n\nint x = 2;\nint y = 10;\n\nint N::j = x; // N::x is used to initialize N::j\nint N::k = y; // ::y is used to initialize N::k\n\nint main()\n{\n   std::cout &lt;&lt; N::j &lt;&lt; std::endl;\n   std::cout &lt;&lt; N::k &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output:</p>\n<pre>\n3\n10\n</pre>\n<p><strong>Update, in response to comment by OP</strong></p>\n<p>What the standard is saying is that:</p>\n<pre><code>namespace N \n{\n   extern int j;\n}\n\nint x = 2;\n\nint N::j = x;\n</code></pre>\n<p>is equivalent to:</p>\n<pre><code>namespace N \n{\n   extern int j;\n}\n\nint x = 2;\n\nnamespace N \n{\n   int j = x;\n}\n</code></pre>\n<p>The logic for lookup of<code>x</code> is same. If it is found within the same namespace <code>N</code>, it is used.  If <code>x</code> is not found in namespace <code>N</code>, it is searched for outward in the enclosing namespaces.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2014-05-29T20:18:02.913", "Id": "23941748", "Score": "3", "CreationDate": "2014-05-29T19:49:00.883", "LastActivityDate": "2014-05-29T20:18:02.913"}, "23941480": {"CommentCount": "8", "ViewCount": "50", "OwnerDisplayName": "user3636875", "CreationDate": "2014-05-29T19:31:50.977", "LastActivityDate": "2014-05-29T20:18:02.913", "PostTypeId": "1", "AcceptedAnswerId": "23941748", "Title": "User-declared namespace member", "Id": "23941480", "Score": "2", "Body": "<p>There is from 3.4.1/14:</p>\n<blockquote>\n<p id=\"so_23941480_23941480_0\">If a variable member of a namespace is defined outside of the scope of\n  its namespace then any name that appears in the definition of the\n  member (after the declarator-id) is looked up as if the definition of\n  the member occurred in its namespace.</p>\n</blockquote>\n<p><strong>If that name treated as the definition of the member name then what is it point of declaration?</strong></p>\n<p>And why the following example will works:</p>\n<pre><code>namespace N \n{\n    extern int j;\n}\nint i = 2;\nint N::j = i; //N::j=2\n</code></pre>\n<p><code>int N::j=i</code> actual appears into the namespace scope. Hence the declaration<code>int i=2</code> is not visible for unqualified name lookup. <strong>Why does this declaration found?</strong></p>\n", "Tags": "<c++><namespaces>", "AnswerCount": "2"}, "23942110": {"ParentId": "23941480", "CommentCount": "1", "Body": "<p>You seem to be confused about how name lookup works on a basic level. Maybe a simple example helps:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid print(std::string const &amp; s) { std::cout &lt;&lt; \"Boo: \" &lt;&lt; s &lt;&lt; \"\\n\"; }\n\nnamespace Foo\n{\n    std::string message = \"Foo\";\n\n    void action() { print(message); }\n}\n\nint main() { Foo::action(); }\n</code></pre>\n<p>Clearly the name <code>print</code> is visible in the definition of <code>Foo::action</code>. Names from containing namespaces are visible in contained namespaces. There's nothing unusual about that.</p>\n<p>The point of the rule you are quoting, and which R Sahu already demonstrated nicely, is that you can put the definition of a variable elsewhere from its declaration, and in that case any name appearing in the initializer is looked up in the namespace in which the variable is declared. Here's another example:</p>\n<pre><code>namespace Foo\n{\n    namespace Bar { int a = 10; }\n    int b = 20;\n\n    extern int c;\n}\n\nnamespace Bar { int a = -20; }\nint b = 5;\n\nint Foo::c = Bar::a + b;  // uses Foo::Bar::a and Foo::b, NOT ::Bar::a or ::b\n\nint main() { return Foo::c; }  // returns 30\n</code></pre>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "23942110", "Score": "1", "CreationDate": "2014-05-29T20:12:50.960", "LastActivityDate": "2014-05-29T20:12:50.960"}, "bq_ids": {"n4140": {"so_23941480_23941480_0": {"section_id": 7100, "quality": 1.0, "length": 21}}, "n3337": {"so_23941480_23941480_0": {"section_id": 6844, "quality": 1.0, "length": 21}}, "n4659": {"so_23941480_23941480_0": {"section_id": 8601, "quality": 1.0, "length": 21}}}});