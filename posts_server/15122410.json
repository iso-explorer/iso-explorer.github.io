post_cb({"15122464": {"ParentId": "15122410", "CommentCount": "0", "Body": "<p><code>std::equal_to</code> is defined as:</p>\n<pre><code>template &lt;class T&gt; struct equal_to {\n  bool operator()(const T&amp; x, const T&amp; y) const;\n  typedef T first_argument_type;\n  typedef T second_argument_type;\n  typedef bool result_type;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_15122410_15122464_0\"><code>operator()</code> returns <code>x == y</code>.</p>\n</blockquote>\n<p>So yes, if <code>T</code> is a class type with an <code>operator==</code> overload defined for it as the left operand, it will be used.</p>\n", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "15122464", "Score": "2", "CreationDate": "2013-02-27T21:09:02.500", "LastActivityDate": "2013-02-27T21:09:02.500"}, "15122462": {"ParentId": "15122410", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_15122410_15122462_0\">Is std::equal_to guaranteed to call <code>operator ==</code> by default?</p>\n</blockquote>\n<p><strong>Yes</strong>. </p>\n<p>If not specialized, <code>equal_to</code>'s call operator will invoke <code>operator ==</code>. From Paragraph 20.8.5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15122410_15122462_1\">1 The library provides basic function object classes for all of the comparison operators in the language (5.9, 5.10).</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; struct equal_to \n{\n    bool operator()(const T&amp; x, const T&amp; y) const;\n    typedef T first_argument_type;\n    typedef T second_argument_type;\n    typedef bool result_type;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_15122410_15122462_2\">2 <strong><code>operator()</code> returns <code>x == y</code></strong>.</p>\n</blockquote>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "15122462", "Score": "7", "CreationDate": "2013-02-27T21:08:53.567", "LastActivityDate": "2013-02-27T21:08:53.567"}, "bq_ids": {"n4140": {"so_15122410_15122462_1": {"section_id": 4592, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_15122410_15122462_1": {"section_id": 4416, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_15122410_15122462_1": {"section_id": 5961, "quality": 0.8333333333333334, "length": 10}}}, "15122410": {"CommentCount": "8", "AcceptedAnswerId": "15122462", "CreationDate": "2013-02-27T21:06:14.397", "LastActivityDate": "2013-02-27T21:09:02.500", "PostTypeId": "1", "ViewCount": "1099", "FavoriteCount": "1", "Title": "Is std::equal_to guaranteed to call operator== by default?", "Id": "15122410", "Score": "2", "Body": "<p>I had always thought that the standard required the non-specialized template for <code>std::equal_to&lt;T&gt;</code> to call <code>T::operator==</code>, but I noticed the <a href=\"http://en.cppreference.com/w/cpp/utility/functional/equal_to\" rel=\"nofollow\">description at cppreference.com</a> almost implies it's the other way around; certainly it doesn't mention it as a requirement. I also checked the C++11 draft standard N3337 and couldn't find any guarantees there either.</p>\n<p>If you create a class with an <code>operator==</code> you'd hope it would get used in all circumstances.</p>\n<p>I can't honestly think of a way to implement <code>std::equal_to</code> that wouldn't work this way, but am I missing something?</p>\n", "Tags": "<c++><std><comparison-operators>", "OwnerUserId": "5987", "AnswerCount": "2"}});