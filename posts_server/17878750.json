post_cb({"17878802": {"ParentId": "17878750", "CommentCount": "0", "Body": "<p>While you can declare them, if you call one with fn(10,15), you're likely to get an error stating that it's an ambiguous call as the compiler doesn't know which you want to use. Though this may dependent on the compiler you're using.</p>\n", "OwnerUserId": "2068642", "PostTypeId": "2", "Id": "17878802", "Score": "1", "CreationDate": "2013-07-26T10:19:02.133", "LastActivityDate": "2013-07-26T10:19:02.133"}, "17878840": {"ParentId": "17878750", "CommentCount": "0", "Body": "<p>This is not a valid C++ code, the call is ambiguous.\nHere is diagnostics from GCC:</p>\n<pre><code>In function \u2018int main()\u2019:\nerror: call of overloaded \u2018fn(int, int)\u2019 is ambiguous\nnote: candidates are: void fn(int, int)\nnote:                 void fn(int, int, int)\n</code></pre>\n<p>Although <em>some</em> compilers can treat the situation in some way (e.g. always use the second definition in case of ambiguity instead of aborting).</p>\n", "OwnerUserId": "1062250", "PostTypeId": "2", "Id": "17878840", "Score": "1", "CreationDate": "2013-07-26T10:20:30.090", "LastActivityDate": "2013-07-26T10:20:30.090"}, "17878817": {"ParentId": "17878750", "CommentCount": "4", "Body": "<p>The compiler can't know, and thus throws an error:</p>\n<pre><code>prog.cpp: In function \u2018int main()\u2019: prog.cpp:15:12: error: call of\n  overloaded \u2018fn(int, int)\u2019 is ambiguous prog.cpp:15:12: note:\n  candidates are: prog.cpp:1:6: note: void fn(int, int) prog.cpp:7:6:\n  note: void fn(int, int, int)\n</code></pre>\n<p>The error doesn't happen on declaration, but on call, when it's actually resolved.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "17878817", "Score": "8", "CreationDate": "2013-07-26T10:19:45.310", "LastActivityDate": "2013-07-26T10:19:45.310"}, "17879145": {"ParentId": "17878750", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In addition to other answers, I guess, that the following rules from C++ standard applies:</p>\n<h3>13.3 Overload resolution</h3>\n<blockquote id=\"so_17878750_17879145_0\">Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way. But, once the candidate functions and argument lists have been identified, the selection of the best function is the same in all cases:\n<ul>\n<li> First, a subset of the candidate functions (those that have the proper number of arguments and meet certain other conditions) is selected to form a set of viable functions (13.3.2).</li>\n<li> Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed to match each argument to the corresponding parameter of each viable function.</li>\n</ul>\n\n3. <b><i>If a best viable function exists and is unique</i>, overload resolution succeeds and produces it as the result. Otherwise overload resolution fails and the invocation is ill-formed.</b> When overload resolution succeeds, and the best viable function is not accessible (Clause 11) in the context in which it is used, the program is ill-formed.</blockquote>\n<p>By the way, there actually <em>is</em> a way to call <em>specific</em> overload:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint f(int a, int b)\n{\n    printf(\"f - version 1\\n\");\n    return 0;\n}\n\nint f(int a, int b, int c = 10)\n{\n    printf(\"f - version 2\\n\");\n    return 0;\n}\n\nint main(int argc, char * argv[])\n{\n    int (* fn1)(int, int);\n    fn1 = f;\n\n    fn1(5, 10);\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "453803", "LastEditorUserId": "453803", "LastEditDate": "2013-07-26T10:40:52.190", "Id": "17879145", "Score": "1", "CreationDate": "2013-07-26T10:34:24.197", "LastActivityDate": "2013-07-26T10:40:52.190"}, "bq_ids": {"n4140": {"so_17878750_17879145_0": {"section_id": 563, "quality": 0.6847826086956522, "length": 63}}, "n3337": {"so_17878750_17879145_0": {"section_id": 554, "quality": 0.6847826086956522, "length": 63}}, "n4659": {"so_17878750_17879145_0": {"section_id": 586, "quality": 0.6847826086956522, "length": 63}}}, "17878750": {"CommentCount": "5", "ViewCount": "294", "PostTypeId": "1", "LastEditorUserId": "2588499", "CreationDate": "2013-07-26T10:15:51.430", "LastActivityDate": "2013-07-26T10:50:44.537", "Title": "How Function Overloading is working with default parameter", "FavoriteCount": "1", "LastEditDate": "2013-07-26T10:50:44.537", "Id": "17878750", "Score": "5", "Body": "<p>Consider the following functions definition</p>\n<pre><code>void fn(int a, int b)\n{\n  //...\n  //...\n}\n\nvoid fn(int a, int b, int c = 0)\n{\n  //...\n  //...\n}\n</code></pre>\n<p>In the main function I am calling a fn with 2 arguments:</p>\n<pre><code>int main()\n{\n  fn(10, 15);\n  return 0;\n}\n</code></pre>\n<p>So would like to know how compiler handles this situation.</p>\n", "Tags": "<c++><oop><overloading>", "OwnerUserId": "2588499", "AnswerCount": "4"}});