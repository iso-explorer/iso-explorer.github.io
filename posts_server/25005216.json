post_cb({"bq_ids": {"n4140": {"so_25005216_25028515_0": {"length": 21, "quality": 0.84, "section_id": 37}}, "n3337": {"so_25005216_25028515_0": {"length": 21, "quality": 0.84, "section_id": 34}}, "n4659": {"so_25005216_25028515_0": {"length": 19, "quality": 0.76, "section_id": 37}}}, "25028515": {"Id": "25028515", "PostTypeId": "2", "Body": "<p>So <code>std::tgamma(x)</code> computes the gamma function of x.  This function goes to infinity quite rapidly:</p>\n<p><a href=\"http://www.wolframalpha.com/share/clip?f=d41d8cd98f00b204e9800998ecf8427et5pmak8jtn\" rel=\"nofollow noreferrer\">http://www.wolframalpha.com/share/clip?f=d41d8cd98f00b204e9800998ecf8427et5pmak8jtn</a></p>\n<p>Already at x == 31, you have a very large number.</p>\n<p>When converting this very large double back to int, the results are undefined behavior (4.9 Floating-integral conversions [conv.fpint]):</p>\n<blockquote>\n<p id=\"so_25005216_25028515_0\">A prvalue of a floating point type can be converted to a prvalue of an\n  integer type. The conversion trun- cates; that is, the fractional part\n  is discarded. The behavior is undefined if the truncated value cannot\n  be represented in the destination type.</p>\n</blockquote>\n<p>On my system this conversion (with an input of {30, 2}) results in an int with the value -2147483648.  This is easily observed by inserting some print statements:</p>\n<pre><code>int\nchooseC(int n, int k)\n{\n    if (k &gt; n)\n    {                                                                                                                                      \n        std::cout &lt;&lt; \"Error. k cannot be greater than n.\\n\";\n        return 0;                                                                                                                                       \n    }                                                                                                                                                 \n    int factN = std::tgamma(n + 1);\n    std::cout &lt;&lt; \"factN = \" &lt;&lt; factN &lt;&lt; '\\n';\n    int factK = std::tgamma(k + 1);\n    std::cout &lt;&lt; \"factK = \" &lt;&lt; factK &lt;&lt; '\\n';\n    int factDiff = std::tgamma(n - k + 1);\n    std::cout &lt;&lt; \"factDiff = \" &lt;&lt; factDiff &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"factK*factDiff = \" &lt;&lt; factK*factDiff &lt;&lt; '\\n';\n    return factN/(factK*factDiff); \n}\n</code></pre>\n<p>which for me outputs:</p>\n<pre><code>factN = -2147483648\nfactK = 2\nfactDiff = -2147483648\nfactK*factDiff = 0\n</code></pre>\n<p>As can be seen, the UB ultimately results in a divide by zero, which is also UB.  And sounds very similar to the behavior you are seeing.</p>\n<p>The solution to this problem is to compute things using only integral arithmetic, and in such a way that the intermediate computations do not overflow if the final result is representable in the integral type.  This entails the use of a Greatest Common Divisor function.</p>\n<p>Open source code which does this is available here:</p>\n<p><a href=\"http://howardhinnant.github.io/combinations.html\" rel=\"nofollow noreferrer\">http://howardhinnant.github.io/combinations.html</a></p>\n<p>Search for \"count_each_combination\".  Your <code>chooseC</code> can be coded in terms of <code>count_each_combination</code> like so:</p>\n<pre><code>int\nchooseC(int n, int k)\n{\n    if (k &gt; n)\n    {                                                                                                                                      \n        std::cout &lt;&lt; \"Error. k cannot be greater than n.\\n\";\n        return 0;                                                                                                                                       \n    }                                                                                                                                                 \n    return count_each_combination(n-k, k);\n}\n</code></pre>\n<p>Now <code>chooseC(30, 2)</code> will return 435.  If <code>count_each_combination</code> is unable to store the result in an <code>int</code>, a <code>std::overflow_error</code> will be thrown.</p>\n<p>If you would like to constrain your <code>chooseC</code> to <code>k == 2</code>, or perhaps do so just temporarily just to better understand the algorithm, note that the formula for counting combinations is:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/rMRjs.png\"/></p>\n<p>When <code>k == 2</code>, this simplifies to:</p>\n<pre><code>n*(n-1)/2\n</code></pre>\n<p>Now either <code>n</code> is even, or <code>n-1</code> is even.  You can discover which, and then divide that number by 2, with no truncation error, and then multiply the result by the number which wasn't divided by 2.  Thus you get the exact result with no possibility of truncation error, nor intermediate overflow, using only integral arithmetic.  This is the technique which <code>count_each_combination</code> uses, but generalized to any divisor, to deliver a result that is always exact if it can fit into the supplied integral type.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2014-09-21T20:12:12.610", "Score": "3", "CreationDate": "2014-07-30T03:56:17.843", "ParentId": "25005216", "CommentCount": "1", "OwnerUserId": "576911", "LastEditDate": "2014-09-21T20:12:12.610"}, "25005216": {"ViewCount": "382", "Body": "<p>I've written an 'n choose k' function in C++, which is interfacing with R via Rcpp.  For some reason I am getting a 'divide by zero' runtime error.  It happens when I try to evaluate 30 choose 2. </p>\n<p>I've tried evaluating each line manually (with evalCpp), and I am still puzzled about where the divide by zero is happening. Maybe somebody could point this out to me or suggest a better way of writing n choose K? </p>\n<p>Here is the code: </p>\n<pre><code>// [[Rcpp::export]]                                                                                                                                  \nint chooseC(int n, int k) {                                                                                                                         \n  if (k &gt; n) {                                                                                                                                      \n    std::cout &lt;&lt; \"Error. k cannot be greater than n.\" &lt;&lt; std::endl;                                                                                 \n    return 0;                                                                                                                                       \n  }                                                                                                                                                 \n  int factN = std::tgamma(n + 1);                                                                                                                   \n  int factK = std::tgamma(k + 1);                                                                                                                   \n  int factDiff = std::tgamma(n - k + 1);                                                                                                            \n  return factN/(factK*factDiff);                                                                                                                    \n} \n</code></pre>\n", "AcceptedAnswerId": "25005407", "Title": "N Choose K Function Crashes Rcpp", "CreationDate": "2014-07-28T22:13:50.483", "Id": "25005216", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-09-21T20:12:12.610", "Score": "0", "OwnerUserId": "3053861", "Tags": "<c++><r><statistics><combinations><rcpp>", "AnswerCount": "2"}, "25005407": {"Id": "25005407", "PostTypeId": "2", "Body": "<p>Briefly:</p>\n<ul>\n<li><p>There is no tgamma in std as far as I can see</p></li>\n<li><p>R itself as a <code>choose</code> function so I would just do what is below</p></li>\n<li><p>R also has the gamma distribution etc so you can do this by hand as well</p></li>\n<li><p>Why didn't you just print the values <code>factN</code>, <code>factK</code>, <code>factDiff</code> ? </p></li>\n</ul>\n<p>Simple Rcpp solution:</p>\n<pre><code>#include &lt;Rcpp.h&gt;\n\n// [[Rcpp::export]]  \ndouble chooseC(double n, double k) {\n  return Rf_choose(n, k);\n}\n</code></pre>\n<p>Example:</p>\n<pre><code>R&gt; chooseC(5,2)     \n[1] 10\nR&gt; \n</code></pre>\n<p><em>Edit:</em> Following the comment by @Blastfurnace about <code>tgamma()</code> in the C++11 <code>cmath</code> header, here is a repaired version which works fine for me:</p>\n<pre><code>#include &lt;Rcpp.h&gt;\n#include &lt;cmath&gt;\n\n// [[Rcpp::plugins(cpp11)]]\n\n// [[Rcpp::export]] \nint chooseCtake2(int n, int k) {\n  if (k &gt; n) {\n    Rcpp::stop(\"Error. k cannot be greater than n.\");\n  }\n  int factN = std::tgamma(n + 1);\n  int factK = std::tgamma(k + 1);\n  int factDiff = std::tgamma(n - k + 1);\n  return factN/(factK*factDiff); \n}\n</code></pre>\n<p>Example use:</p>\n<pre><code>R&gt; sourceCpp(\"/tmp/chooseC.cpp\")\nR&gt; chooseCtake2(2,3)\nError: Error. k cannot be greater than n.\nR&gt; chooseCtake2(5,2)\n[1] 10\nR&gt; \n</code></pre>\n", "LastEditorUserId": "143305", "LastActivityDate": "2014-07-29T01:11:07.473", "Score": "3", "CreationDate": "2014-07-28T22:32:29.920", "ParentId": "25005216", "CommentCount": "3", "OwnerUserId": "143305", "LastEditDate": "2014-07-29T01:11:07.473"}});