post_cb({"3521914": {"ViewCount": "13971", "Body": "<p>i want to use string inside Union.\nif i write as below  </p>\n<pre><code>union U\n{\n   int i;\n   float f;\n   string s;\n};\n</code></pre>\n<p>Compiler gives error saying U::S has copy constructor.</p>\n<p>I read some other post for alternate ways for solving this issue.\nBut i want to know why compiler doesn't allow this in the first place?</p>\n<p>EDIT:  @KennyTM: In any union, if member is initialized others will have garbage values, if none is initialized all will have garbage values. I think, tagged union just provides some comfort to access valid values from Union. \nYour question: how do you or the compiler write a copy constructor for the union above without extra information?\n     sizeof(string) gives 4 bytes. Based on this, compiler can compare other members sizes and allocate largest allocation(4bytes in our example). Internal string length doesn't matter because it will be stored in a seperate location. Let the string be of any length. All that Union has to know is invoking string class copy constructor with string parameter. In whichever way compiler finds that copy constructor has to be invoked in normal case, similar method as to be followed even when string is inside Union. So i am thinking compiler could do like, allocate 4 bytes. Then if any string is assigned to s, then string class will take care of allocation and copying of that string using its own allocator. So there is no chance of memory corruption as well.</p>\n<p>Is string not existed at the time of Union developement in compiler ?\nSo the answer is not clear to me still.\nAm a new joinee in this site, if anything wrong, pls excuse me.</p>\n", "AcceptedAnswerId": "3521972", "Title": "Why compiler doesn't allow std::string inside union?", "CreationDate": "2010-08-19T12:50:36.917", "Id": "3521914", "CommentCount": "2", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2010-08-20T07:33:51.010", "LastEditorUserId": "426051", "LastActivityDate": "2016-02-04T14:06:21.683", "Score": "36", "OwnerUserId": "426051", "Tags": "<c++>", "AnswerCount": "5"}, "3521962": {"Id": "3521962", "PostTypeId": "2", "Body": "<p>In C++98/03, members of a union can't have constructors, destructors, virtual member functions, or base classes.</p>\n<p>So basically, you can only use built-in data types, or <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"noreferrer\">PODs</a></p>\n<p>Note that it is changing in C++0x: <a href=\"http://en.wikipedia.org/wiki/C%2B%2B0x#Unrestricted_unions\" rel=\"noreferrer\">Unrestricted unions</a></p>\n<pre><code>union {\n    int z;\n    double w;\n    string s;  // Illegal in C++98, legal in C++0x.\n};\n</code></pre>\n", "LastEditorUserId": "191367", "LastActivityDate": "2010-08-20T08:04:00.757", "Score": "12", "CreationDate": "2010-08-19T12:55:55.250", "ParentId": "3521914", "CommentCount": "1", "OwnerUserId": "191367", "LastEditDate": "2010-08-20T08:04:00.757"}, "35203160": {"Id": "35203160", "PostTypeId": "2", "Body": "<p>The garbage is introduced if you </p>\n<ol>\n<li>assign a string</li>\n<li>then assign an int or float</li>\n<li>then a string again</li>\n</ol>\n<p>string manages memory somewhere else. This information is most likely some pointer. This pointer is garbaged when assigning the int. Assigning a new string should destroy the old string, which is not possible.</p>\n<p>The second step should destroy the string, but does not know, if there has been a string.</p>\n<p>They obviously have found a solution for this problem in the meantime. </p>\n", "LastActivityDate": "2016-02-04T14:06:21.683", "CommentCount": "2", "CreationDate": "2016-02-04T14:06:21.683", "ParentId": "3521914", "Score": "0", "OwnerUserId": "5883504"}, "3521998": {"Id": "3521998", "PostTypeId": "2", "Body": "<p>Because having a class with a non-trivial (copy/)constructor in a union doesn't make sense. Suppose we have</p>\n<pre><code>union U {\n  string x;\n  vector&lt;int&gt; y;\n};\n\nU u;  // &lt;--\n</code></pre>\n<p>If U was a struct, <code>u.x</code> and <code>u.y</code> would be initialized to an empty string and empty vector respectively. But members of a union share the same address. So, if <code>u.x</code> is initialized, <code>u.y</code> will contain invalid data, and so is the reverse. If both of them are not initialized then they cannot be used. In any case, having these data in a union cannot be handled easily, so C++98 chooses to deny this: (\u00a79.5/1):</p>\n<blockquote>\n<p id=\"so_3521914_3521998_0\">An object of a class with a non-trivial constructor (12.1), a non-trivial copy constructor (12.8), a non-trivial destructor (12.4), or a non-trivial copy assignment operator (13.5.3, 12.8) cannot be a member of a union, nor can an array of such objects.</p>\n</blockquote>\n<p>In C++0x this rule has been relaxed (\u00a79.5/2):</p>\n<blockquote>\n<p id=\"so_3521914_3521998_1\">At most one non-static data member of a union may have a <em>brace-or-equal-initializer</em>. [<em>Note:</em> if any non-static data member of a union has a non-trivial default constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move\n  assignment operator (12.8), or destructor (12.4), the corresponding member function of the union must be user-provided or it will be implicitly deleted (8.4.3) for the union. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>but it is still a not possible to create (correct) con/destructors for the union, e.g. how do you or the compiler write a copy constructor for the union above without extra information? To ensure which member of the union is active, you need a <a href=\"http://en.wikipedia.org/wiki/Tagged_union\" rel=\"nofollow noreferrer\">tagged union</a>, and you need to handle the construction and destruction manually e.g.</p>\n<pre><code>struct TU {\n   int type;\n   union {\n     int i;\n     float f;\n     std::string s;\n   } u;\n\n   TU(const TU&amp; tu) : type(tu.type) {\n     switch (tu.type) {\n       case TU_STRING: new(&amp;u.s)(tu.u.s); break;\n       case TU_INT:    u.i = tu.u.i;      break;\n       case TU_FLOAT:  u.f = tu.u.f;      break;\n     }\n   }\n   ~TU() {\n     if (tu.type == TU_STRING)\n       u.s.~string();\n   }\n   ...\n};\n</code></pre>\n<p>But, as <a href=\"https://stackoverflow.com/questions/3521914/why-compiler-doesnt-allow-stdstring-inside-union/3521972#3521972\">@DeadMG</a> has mentioned, this is already implemented as <a href=\"http://boost.org/doc/libs/1_43_0/doc/html/variant.html\" rel=\"nofollow noreferrer\"><code>boost::variant</code></a> <a href=\"http://www.boost.org/doc/libs/1_43_0/doc/html/variant/misc.html#variant.versus-any\" rel=\"nofollow noreferrer\">or</a> <a href=\"http://www.boost.org/doc/libs/1_43_0/doc/html/any.html\" rel=\"nofollow noreferrer\"><code>boost::any</code></a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-26T08:26:54.277", "Score": "44", "CreationDate": "2010-08-19T13:00:18.467", "ParentId": "3521914", "CommentCount": "6", "OwnerUserId": "224671", "LastEditDate": "2017-05-23T12:25:47.360"}, "bq_ids": {"n4140": {"so_3521914_3521998_1": {"length": 31, "quality": 0.6595744680851063, "section_id": 5914}}, "n3337": {"so_3521914_3521998_1": {"length": 37, "quality": 0.7872340425531915, "section_id": 5686}}, "n4659": {"so_3521914_3521998_1": {"length": 31, "quality": 0.6595744680851063, "section_id": 7406}}}, "3521972": {"Id": "3521972", "PostTypeId": "2", "Body": "<p>Think about it. How does the compiler know what type is in the union?</p>\n<p>It doesn't. The fundamental operation of a union is essentially a bitwise cast. Operations on values contained within unions are only safe when each type can essentially be filled with garbage. <code>std::string</code> can't, because that would result in memory corruption. Use <code>boost::variant</code> or <code>boost::any</code>.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2010-08-19T15:05:22.177", "Score": "21", "CreationDate": "2010-08-19T12:57:01.520", "ParentId": "3521914", "CommentCount": "2", "OwnerUserId": "298661", "LastEditDate": "2010-08-19T15:05:22.177"}, "3522009": {"Id": "3522009", "PostTypeId": "2", "Body": "<p>From the C++ spec \u00a79.5.1: </p>\n<blockquote>\n<p id=\"so_3521914_3522009_0\"><em>An object of a class with a non-trivial constructor, a non-trivial copy constructor, a non-trivial destructor, or a non-trivial copy assignment operator cannot be a member of a union.</em></p>\n</blockquote>\n<p>The reason for this rule is that the compiler will never know which of the destructors/constructors call, since it never really knows which of the possible objects is inside the union.</p>\n", "LastActivityDate": "2010-08-19T13:01:36.187", "CommentCount": "0", "CreationDate": "2010-08-19T13:01:36.187", "ParentId": "3521914", "Score": "7", "OwnerUserId": "102834"}});