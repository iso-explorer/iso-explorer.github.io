post_cb({"bq_ids": {"n4140": {"so_37767893_37768220_0": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_37767893_37768220_0": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_37767893_37768220_0": {"section_id": 7834, "quality": 1.0, "length": 5}}}, "37767893": {"CommentCount": "14", "ViewCount": "146", "PostTypeId": "1", "LastEditorUserId": "362589", "CreationDate": "2016-06-11T19:44:26.197", "LastActivityDate": "2016-06-11T20:27:04.280", "Title": "Is iterator to a container with incomplete data type legal?", "AcceptedAnswerId": "37768220", "LastEditDate": "2016-06-11T20:26:19.120", "Id": "37767893", "Score": "6", "Body": "<p>Is the following code legal?</p>\n<pre><code>class A\n{\n    std::map&lt;int, A&gt;::iterator x;\n};\n</code></pre>\n<p>Visual Studio 2015 accepts it, but clang says</p>\n<pre><code>.../ndk/sources/cxx-stl/llvm-libc++/libcxx/include/utility:254:9:  \nerror: field has incomplete type 'A'\n    _T2 second;\n    ^\n....\na.cpp:52:21:\nnote: definition of 'A' is not complete until the closing '}'\n    struct A\n           ^\n</code></pre>\n<p>Edit:<br>\nThe problem seems to be with the standard library, <a href=\"http://rextester.com/QNNEG57036\" rel=\"nofollow\">http://rextester.com/QNNEG57036</a> fails on it</br></p>\n<p>My question is whether the code is legal or not, not how to fix it (ex. by changing compiler flags).</p>\n", "Tags": "<c++><iterator><incomplete-type>", "OwnerUserId": "362589", "AnswerCount": "1"}, "37768220": {"ParentId": "37767893", "CommentCount": "12", "Body": "<p>Unless explicitly stated in the standard that incomplete types are legal, they are not legal. The specific section is 17.6.4.8 [res.on.functions] paragraph 2:</p>\n<blockquote>\n<p id=\"so_37767893_37768220_0\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_37767893_37768220_1\">[...]</p>\n<ul>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n<p>I don't think any of containers is required to support incomplete types. Some of the smart pointers do allow incomplete types. Off-hand I can't think of anything else which would allow incomplete types. A quick search for \"incomplete\" yields the following components allowing incomplete types as template arguments:</p>\n<ul>\n<li><code>std::declval&lt;T&gt;()</code></li>\n<li><code>std::unique_ptr&lt;T&gt;</code></li>\n<li><code>std::default_delete&lt;T&gt;</code></li>\n<li><code>std::shared_ptr&lt;T&gt;</code></li>\n<li><code>std::weak_ptr&lt;T&gt;</code></li>\n<li><code>std::enable_shared_from_this&lt;T&gt;</code></li>\n</ul>\n<p>In the code example, <code>std::map&lt;int, A&gt;::iterator</code> instantiates a template with an incomplete type. As a result the code results in undefined behavior.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "37768220", "Score": "4", "CreationDate": "2016-06-11T20:27:04.280", "LastActivityDate": "2016-06-11T20:27:04.280"}});