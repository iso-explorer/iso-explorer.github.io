post_cb({"3633187": {"ParentId": "3632761", "CommentCount": "0", "Body": "<p>Here is my interpreation of one part of my query which is</p>\n<blockquote>\n<p id=\"so_3632761_3633187_0\">\"Why MYINT\" can be referred to as\n  \"MYINT\" instead of \"A::MYINT\"?</p>\n<p id=\"so_3632761_3633187_1\">$3.4.1/9 states - \"Name lookup for a\n  name used in the definition of a\n  friend function (11.4) defined inline\n  in the class granting friendship shall\n  proceed as described for lookup in\n  member function definitions. If the\n  friend function is not defined in the\n  class granting friendship, name lookup\n  in the friend function definition\n  shall proceed as described for lookup\n  in namespace member function\n  definitions.\"</p>\n</blockquote>\n<p>In our case, the name to be looked up is 'MYINT' which is a unqualified name. The lookup for this name inside the definition of the friend 'f' which is defined inline in the class would would be done in the same was as it would be for member functions of 'A'.</p>\n<blockquote>\n<p id=\"so_3632761_3633187_2\">Is my understanding correct?</p>\n</blockquote>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3633187", "Score": "0", "CreationDate": "2010-09-03T05:07:00.730", "LastActivityDate": "2010-09-03T05:07:00.730"}, "3633087": {"ParentId": "3632761", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have quoted only part of \u00a711.4/5. According to it <code>f()</code> should be declared out of class first (function should have namespace scope). Try this:</p>\n<pre><code>void f(); // declare it first\nstruct A{\n   typedef int MYINT;\n   void f2(){f();}                    \n   friend void f(){MYINT mi = 0;}     // definition of global f, a friend of A\n   void f1(){f();}                    \n};\n</code></pre>\n<p>As for second question, it is ok because of quoted by you part of \u00a711.4/5. <code>f()</code> obeys the same rules for name binding as a static member function of that class and has no special access rights to members of an enclosing class.</p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2010-09-03T04:49:44.270", "Id": "3633087", "Score": "1", "CreationDate": "2010-09-03T04:44:05.470", "LastActivityDate": "2010-09-03T04:49:44.270"}, "bq_ids": {"n4140": {"so_3632761_3633187_1": {"section_id": 7095, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_3632761_3633187_1": {"section_id": 6839, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_3632761_3633187_1": {"section_id": 8596, "quality": 0.9210526315789473, "length": 35}}}, "3632761": {"CommentCount": "1", "ViewCount": "178", "PostTypeId": "1", "LastEditorUserId": "418110", "CreationDate": "2010-09-03T02:49:16.040", "LastActivityDate": "2010-09-03T05:07:00.730", "Title": "Friends confusion", "FavoriteCount": "1", "LastEditDate": "2010-09-03T02:56:28.957", "Id": "3632761", "Score": "6", "Body": "<p>$11.4/5 - \"[...]A friend function defined in a class is in the (lexical) scope of the class in which it is defined[...]\"</p>\n<p>What does this statement mean?</p>\n<pre><code>struct A{\n   typedef int MYINT;\n   void f2(){f();}                    // Error, 'f' is undefined\n   friend void f(){MYINT mi = 0;}     // Why does this work, shouldn' it be A::MYINT?\n   void f1(){f();}                    // Error, 'f' is undefined\n};\n\nint main(){}\n</code></pre>\n<ol>\n<li><p>What is confusing here is that the call to 'f' from 'A::f1' is quiet understandable. However why is call to 'f' from 'A::f2' ill-formed, when a friend is in 'lexical' scope of the befriending class? What does 'lexical' scope mean?</p></li>\n<li><p>At the same type why is the usage of 'MYINT' in 'f' OK? Shouldn't it be 'A::MYINT'?</p></li>\n</ol>\n<p>If I add a parameter of type 'A *' to 'f', then both 'f1' and 'f2' are able to find 'f' because of ADL. This is understandable.</p>\n", "Tags": "<c++><friend>", "OwnerUserId": "418110", "AnswerCount": "2"}});