post_cb({"17446559": {"ParentId": "17446220", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Here's the relevant paragraph from the Standard. It pretty much speaks for itself.</p>\n<blockquote>\n<p id=\"so_17446220_17446559_0\">8.3.5/10</p>\n<p id=\"so_17446220_17446559_1\">A typedef of function type may be used to declare a function but shall not be used to define a function (8.4).</p>\n<p id=\"so_17446220_17446559_2\"><em>Example:</em></p>\n<pre><code>typedef void F();\nF  fv;         // OK: equivalent to void fv();\nF  fv { }      // ill-formed\nvoid fv() { }  // OK: definition of fv\n</code></pre>\n<p id=\"so_17446220_17446559_3\">A typedef of a function type whose declarator includes a <em>cv-qualifier-seq</em> shall be used only to declare the function type for a non-static member function, to declare the function type to which a pointer to member refers, or to declare the top-level function type of another function typedef declaration.</p>\n<p id=\"so_17446220_17446559_4\"><em>Example:</em></p>\n<pre><code>typedef int FIC(int) const;\nFIC f;               // ill-formed: does not declare a member function\nstruct S {\n  FIC f;             // OK\n};\nFIC S::*pm = &amp;S::f;  // OK\n</code></pre>\n</blockquote>\n", "OwnerUserId": "459640", "LastEditorUserId": "728847", "LastEditDate": "2013-07-03T11:32:05.603", "Id": "17446559", "Score": "14", "CreationDate": "2013-07-03T11:18:47.087", "LastActivityDate": "2013-07-03T11:32:05.603"}, "17446220": {"CommentCount": "1", "AcceptedAnswerId": "17446559", "PostTypeId": "1", "LastEditorUserId": "123632", "CreationDate": "2013-07-03T11:00:02.307", "LastActivityDate": "2013-07-03T15:24:19.063", "LastEditDate": "2013-07-03T15:24:19.063", "ViewCount": "9382", "FavoriteCount": "1", "Title": "C++ function types", "Id": "17446220", "Score": "11", "Body": "<p>I have a problem understanding function types (they appear e.g. as the <code>Signature</code> template parameter of a <code>std::function</code>):</p>\n<pre><code>typedef int Signature(int); // the signature in question\n\ntypedef std::function&lt;int(int)&gt;  std_fun_1;\ntypedef std::function&lt;Signature&gt; std_fun_2;\n\nstatic_assert(std::is_same&lt;std_fun_1, std_fun_2&gt;::value,\n              \"They are the same, cool.\");\n\nint square(int x) { return x*x; }\n\nSignature* pf = square;   // pf is a function pointer, easy\nSignature f;              // but what the hell is this?\nf(42);                    // this compiles but doesn't link\n</code></pre>\n<p>The variable <code>f</code> can not be assigned, but can be called. Weird. What is it good for, then?</p>\n<p>Now if I const-qualify the typedef, I can still use it to build further types but apparently for nothing else:</p>\n<pre><code>typedef int ConstSig(int) const;\n\ntypedef std::function&lt;int(int) const&gt;  std_fun_3;\ntypedef std::function&lt;ConstSig&gt;        std_fun_4;\n\nstatic_assert(std::is_same&lt;std_fun_3, std_fun_4&gt;::value,\n              \"Also the same, ok.\");\n\nConstSig* pfc = square; // \"Pointer to function type cannot have const qualifier\"\nConstSig fc;            // \"Non-member function cannot have const qualifier\"\n</code></pre>\n<p>What remote corner of the language have I hit here? How is this strange type called and what can I use it for outside of template parameters?</p>\n", "Tags": "<c++><c++11><function-pointers><std-function>", "OwnerUserId": "728847", "AnswerCount": "2"}, "17446530": {"ParentId": "17446220", "CommentCount": "0", "Body": "<p>In your case, <code>std_fun_1</code> and <code>std_fun_2</code> are identical objects with identical type signatures. They are both <code>std::function&lt;int(int)&gt;</code>, and can both hold function pointers or callable objects of type <code>int(int)</code>.</p>\n<p><code>pf</code> is a pointer to <code>int(int)</code>. That is, it serves the same basic purpose as <code>std::function</code>, but without the machinery of that class or support for instances of callable objects.</p>\n<p>Similarly, <code>std_fun_3</code> and <code>std_fun_4</code> are identical objects with identical type signatures, and can both hold function pointers or callable objects of type <code>int(int) const</code>.</p>\n<p>Also similarly, <code>pfc</code> is a function pointer of type <code>int(int) const</code>, and can hold pointers to functions of that type, but not instances of callable objects.</p>\n<p>But <code>f</code> and <code>fc</code> are <strong>function declarations.</strong></p>\n<p>The line:</p>\n<pre><code>Signature fc;\n</code></pre>\n<p>Is identically equivalent to:</p>\n<pre><code>int fc(int) const;\n</code></pre>\n<p>Which is a declaration for a function named <code>fc</code> of type <code>int(int) const</code>.</p>\n<p>There's nothing strange going on here. You've simply happened upon syntax you probably already understand, from a perspective you're not accustomed to.</p>\n", "OwnerUserId": "33345", "PostTypeId": "2", "Id": "17446530", "Score": "0", "CreationDate": "2013-07-03T11:16:54.007", "LastActivityDate": "2013-07-03T11:16:54.007"}, "bq_ids": {"n4140": {"so_17446220_17446559_3": {"section_id": 3242, "quality": 0.7037037037037037, "length": 19}, "so_17446220_17446559_1": {"section_id": 3246, "quality": 1.0, "length": 9}}, "n3337": {"so_17446220_17446559_3": {"section_id": 3119, "quality": 1.0, "length": 27}, "so_17446220_17446559_1": {"section_id": 3119, "quality": 1.0, "length": 9}}, "n4659": {"so_17446220_17446559_1": {"section_id": 4004, "quality": 1.0, "length": 9}, "so_17446220_17446559_3": {"section_id": 3998, "quality": 0.7037037037037037, "length": 19}}}});