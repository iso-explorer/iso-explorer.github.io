post_cb({"13097268": {"CommentCount": "3", "ViewCount": "605", "PostTypeId": "1", "LastEditorUserId": "82320", "CreationDate": "2012-10-27T04:33:17.430", "LastActivityDate": "2012-10-29T12:30:28.370", "Title": "What are the alignment limitations of the standard global default operator new?", "AcceptedAnswerId": "13100870", "LastEditDate": "2012-10-27T06:03:25.410", "Id": "13097268", "Score": "6", "Body": "<p>I'm working on some older code that uses ATL's <code>CComBSTR</code> type. I'm changing it so that it will compile using Visual C++ Express Edition, which does not come with ATL. I used only a very small subset of <code>CComBSTR</code>, so doing this is fairly simple.</p>\n<p>However, when allocating the <code>BSTR</code> memory block, I need to fill the first four bytes with a 4 byte length prefix. I'm concerned that if I use a <code>new char[size]</code> expression to allocate the memory for the string, that I will cause alignment faults due to the allocated <code>char</code> array not having the correct alignment for the four byte prefix.</p>\n<p>Is there anything in the standard that states what alignment requirements the returned values of <code>new</code> have? All I see in C++11 are:</p>\n<blockquote>\n<p id=\"so_13097268_13097268_0\">5.3.4/1 [expr.new]<br>\n  It is implementation-defined whether over-aligned types are supported (3.11).</br></p>\n<p id=\"so_13097268_13097268_1\">3.11/6 [basic.align]<br>\n  The alignment requirement of a complete type can be queried using an alignof expression (5.3.6). Furthermore, the types char, signed char, and unsigned char shall have the weakest alignment requirement. [ Note: This enables the character types to be used as the underlying type for an aligned memory area (7.6.2).\u2014end note ]</br></p>\n</blockquote>\n<p>I find this slightly confusing -- \"weakest alignment requirement\" says to me \"least strict constraint on alignment\", but the note under this seems to indicate the standard means the opposite.</p>\n<p>Am I safe using a <code>new char[sizeof(uint32_t) + 2*(length + 1)]</code> buffer as a <code>BSTR</code> like this?</p>\n<p><strong>EDIT</strong>: I just realized that in this specific case of <code>BSTR</code>, one needs to use SysAllocString in order to allocate the string anyway; but I'm still interested in whether or not it is okay to use <code>new</code> in this way.</p>\n", "Tags": "<c++><visual-c++><com><memory-alignment>", "OwnerUserId": "82320", "AnswerCount": "3"}, "13121674": {"ParentId": "13097268", "CommentCount": "5", "CreationDate": "2012-10-29T12:30:28.370", "OwnerUserId": "57428", "PostTypeId": "2", "Id": "13121674", "Score": "0", "Body": "<p>You should never try to use C++ memory management functions for BSTRs - they should only be allocated using <code>SysAllocString()</code> family functions. This ensures that whoever obtains a <code>BSTR</code> can use <code>SysFreeString()</code> and other functions of the family on the obtained <code>BSTR</code>. If you violate this requirement your program will run into undefined behavior.</p>\n", "LastActivityDate": "2012-10-29T12:30:28.370"}, "13101921": {"ParentId": "13097268", "CommentCount": "1", "CreationDate": "2012-10-27T16:21:35.077", "OwnerUserId": "17034", "PostTypeId": "2", "Id": "13101921", "Score": "5", "Body": "<p>It is an implementation detail, but MSVC uses the operating system allocators.  HeapAlloc() for CRT allocations, CoTaskMemAlloc() for COM type wrappers like _bstr_t.  They both align by 8, both in 32-bit and 64-bit code.</p>\n<p>You should never allocate memory for BSTRs with the <em>new</em> operator, the COM allocator must be used to ensure that they get deallocated using the proper heap.  Important in any interop scenario, which is where BSTR is used, it is a standard Automation type.  CoTaskMemAlloc/Free() is required but always use the BSTR helper functions to ensure they get properly initialized.  SysAllocString() and SysFreeString().  Use SysAllocStringLen() to deal with strings containing embedded zeros.  </p>\n", "LastActivityDate": "2012-10-27T16:21:35.077"}, "bq_ids": {"n4140": {"so_13097268_13100870_3": {"section_id": 7242, "quality": 0.9130434782608695, "length": 21}, "so_13097268_13100870_1": {"section_id": 4239, "quality": 0.6666666666666666, "length": 4}, "so_13097268_13097268_1": {"section_id": 7245, "quality": 0.6388888888888888, "length": 23}, "so_13097268_13100870_4": {"section_id": 7248, "quality": 1.0, "length": 22}}, "n3337": {"so_13097268_13100870_3": {"section_id": 6986, "quality": 0.9130434782608695, "length": 21}, "so_13097268_13100870_1": {"section_id": 4080, "quality": 0.6666666666666666, "length": 4}, "so_13097268_13097268_1": {"section_id": 6989, "quality": 0.7777777777777778, "length": 28}, "so_13097268_13100870_4": {"section_id": 6992, "quality": 1.0, "length": 22}}, "n4659": {"so_13097268_13100870_3": {"section_id": 8751, "quality": 0.8695652173913043, "length": 20}, "so_13097268_13100870_1": {"section_id": 5177, "quality": 0.6666666666666666, "length": 4}, "so_13097268_13097268_1": {"section_id": 8754, "quality": 0.6388888888888888, "length": 23}}}, "13100870": {"ParentId": "13097268", "CommentCount": "3", "CreationDate": "2012-10-27T14:05:24.003", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "13100870", "Score": "4", "Body": "<blockquote>\n<p id=\"so_13097268_13100870_0\">5.3.4/1 [expr.new]</p>\n<p id=\"so_13097268_13100870_1\">It is implementation-defined whether over-aligned types are supported (3.11).</p>\n</blockquote>\n<p>One important thing here: <code>over-aligned</code> means more aligned than any built-in type. For example, on 64 bits machine, pointers are generally 8 bytes aligned and thus on those machines over-aligned means having an alignment strictly greater than 8.</p>\n<p>Therefore, <code>over-aligned</code> is only of concern when using vector types, such as those required for SSE or AVX instructions or some variants of C/C++ (like Open CL). In day to day programming, the types you craft from the built-in types are never over-aligned.</p>\n<blockquote>\n<p id=\"so_13097268_13100870_2\"><strong>\u00a73.11 Alignment [basic.align]</strong></p>\n<p id=\"so_13097268_13100870_3\"><strong>3/</strong> An <em>extended alignment</em> is represented by an alignment greater than <code>alignof(std::max_align_t)</code>. It is implementation-defined whether any extended alignments are supported and the contexts in which they are supported (7.6.2). A type having an extended alignment requirement is an <em>over-aligned</em> type.</p>\n<p id=\"so_13097268_13100870_4\"><strong>9/</strong> If a request for a specific extended alignment in a specific context is not supported by an implementation, the program is ill-formed. <strong>Additionally, a request for runtime allocation of dynamic storage for which the requested alignment cannot be honored shall be treated as an allocation failure.</strong></p>\n</blockquote>\n<p>Furthermore, it is customary for <code>new</code> to return memory aligned to <code>alignof(std::max_align_t)</code>. This is because the regular <code>::operator new</code> is only aware of the size of the object to allocate for, not of its alignment, and therefore need satisfy the strongest alignment requirements possible in the program.</p>\n<p>On the other hand, beware of a <code>char</code> array allocated on the stack, there is no guarantee what its alignment would end up being.</p>\n", "LastActivityDate": "2012-10-27T14:05:24.003"}});