post_cb({"23757167": {"Id": "23757167", "PostTypeId": "2", "Body": "<p>Let's start of by digging into the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\">N3797</a>):</p>\n<blockquote>\n<p id=\"so_23757166_23757167_0\"><code>23.2.1p9</code> <strong>General Container Requirements</strong> <code>[container.requirements.general]</code></p>\n<blockquote>\n<p id=\"so_23757166_23757167_2\">If\n    <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code>\n    is <code>true</code>, then the allocators of <code>a</code> and <code>b</code> shall also be exchanged\n    using an unqalified call to non-member <code>swap</code>. <strong>Otherwise, they shall\n    not be swapped, and the behavior is undefined unless <code>a.get_allocator() == b.get_allocator()</code></strong>.</p>\n</blockquote>\n</blockquote>\n<hr>\n<p><strong>What is the purpose of <code>propagate_on_container_swap</code>?</strong></p>\n<p>If an Allocator has a <em>typedef</em> named <code>propagate_on_container_swap</code> that refers to <code>std::true_type</code> the underlying Allocators of two containers being swapped, will also swap.<sup>[1]</sup></p>\n<p>If <code>propagate_on_container_swap</code> is <code>std::false_type</code> only the data of the two containers will swap, but the allocators will remain in their place.</p>\n<p><sup><sup>[1]</sup> This means that after <code>a.swap(b)</code>, <code>a.get_allocator()</code> will be that which was previously <code>b.get_allocator()</code>; the allocators has <em>swapped</em>.</sup></p>\n<hr>\n<p><strong>What are the implications of stateful Allocators?</strong></p>\n<p>The Allocator is not only responsible for allocating memory for the elements within a Standard container, they are also responsible for the deallocation of said elements.</p>\n<p>C++03 didn't allow <em>stateful allocators</em> within standard containers, but C++11 mandates that support for such must be present. This means that we could define an allocator that, depending on how it's constructed, acts in a certain way.</p>\n<p>If the allocator has <code>propagate_on_container_swap::value</code> equal to <code>false</code> the difference in state between the two allocators involved might lead to <em>undefined behavior</em>, since one instance of the Allocator might not be compatible with the data handled by the other.</p>\n<hr>\n<p><strong>What might be the problem with stateful allocators if they are not swapped properly?</strong></p>\n<p>Let's say we have a <code>MagicAllocator</code> which either uses <code>malloc</code> or <code>operator new</code> to allocate memory, depending on how it's constructed.</p>\n<p>If it uses <code>malloc</code> to allocate memory it must use <code>free</code> to deallocate it, and in case of <code>operator new</code>, <code>delete</code> is required; because of this it must maintain some information saying which of the two it should use.</p>\n<p>If we have two <code>std::vector</code> which both uses <code>MagicAllocator</code> but with different states (meaning that one uses <code>malloc</code> and the other <code>operator new</code>), and we don't swap the allocators upon <code>a.swap(b)</code> the allocator won't match the memory allocated for the elements in the two vectors after the swap - which in terms means that the wrong <code>free</code>/<code>delete</code> might be called upon deallocation.</p>\n</hr></hr></hr>", "LastActivityDate": "2014-05-20T10:23:13.750", "CommentCount": "4", "CreationDate": "2014-05-20T10:23:13.750", "ParentId": "23757166", "Score": "13", "OwnerUserId": "1090079"}, "23757166": {"ViewCount": "338", "Body": "<p><sup><strong>Note:</strong> Originially asked by <a href=\"https://stackoverflow.com/users/966376/greenscape\">GreenScape</a> as <a href=\"https://stackoverflow.com/questions/23754223/why-are-the-swap-member-functions-in-stl-containers-not-declared-noexcept/23755126?noredirect=1#comment36524813_23755126\">comment</a>.</sup></p>\n<hr>\n<p>After reading <a href=\"https://stackoverflow.com/q/23754223/1090079\">Why are the swap member functions in STL containers not declared noexcept?</a> it seems that the reason for potential <em>undefined behavior</em> when doing <code>a.swap(b)</code> for standard containers boils down to also swapping, or not swapping, the underlying allocators.</p>\n<ul>\n<li>Why is swapping allocators along with data problematic?</li>\n</ul>\n</hr>", "AcceptedAnswerId": "23757167", "Title": "Why can swapping standard library containers be problematic in C++11 (involving allocators)?", "CreationDate": "2014-05-20T10:23:13.750", "Id": "23757166", "CommentCount": "0", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:50:23.690", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-20T11:36:43.013", "Score": "13", "OwnerUserId": "1090079", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23757166_23757167_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 710}, "so_23757166_23757167_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 710}}, "n3337": {"so_23757166_23757167_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 699}, "so_23757166_23757167_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 699}}, "n4659": {"so_23757166_23757167_2": {"length": 13, "quality": 0.7222222222222222, "section_id": 739}, "so_23757166_23757167_1": {"length": 13, "quality": 0.7222222222222222, "section_id": 739}}}});