post_cb({"bq_ids": {"n4140": {"so_48889931_48889931_0": {"length": 33, "quality": 0.6111111111111112, "section_id": 233}}, "n3337": {"so_48889931_48889931_0": {"length": 33, "quality": 0.6111111111111112, "section_id": 226}}, "n4659": {"so_48889931_48889931_0": {"length": 31, "quality": 0.5740740740740741, "section_id": 243}}}, "48889931": {"ViewCount": "54", "Body": "<p>This question covers <strong>C++03</strong>, and how to omit a conversion operator from a class template, say <code>template&lt;typename T&gt; struct Foo { ... };</code>, given traits on <code>T</code>.</p>\n<hr>\n<p><em>(Questions at the bottom)</em></p>\n<p><strong>Background</strong></p>\n<p>Ideally, I'd would like to make use of an <code>enable_if</code> construct and SFINAE to exclude a conversion operator based on traits of <code>T</code> of class template (see <code>Foo</code> above), but default template arguments may not be used in function templates in C++03, which (afaik) excludes that approach; as previously covered in the following thread:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/3076206/enable-if-and-conversion-operator\">enable_if and conversion operator?</a></li>\n</ul>\n<p>Instead, I'm using an approach where the type of the return value of the conversion operator is conditional on traits on <code>T</code>, particularly being a dummy (<code>void</code> or some private externally inaccessible type) for certain types of <code>T</code>. This approach seems to work fine, but I'm uncertain what possible pitfalls I might be digging for myself; specifically what is guaranteed by the (C++03) Standard in this context.</p>\n<p>Consider the following example (which I've tried to keep as minimal as possible), using the approach described in the previous paragraph:</p>\n<p><strong><code>include/util.h</code></strong>:</p>\n<pre><code>namespace util {\n\n// dummy predicate: is T int?\ntemplate &lt;typename T&gt; struct is_int { static const bool value = false; };\ntemplate &lt;&gt; struct is_int&lt;int&gt; { static const bool value = true; };\ntemplate &lt;typename T&gt; const bool is_int&lt;T&gt;::value;\n\n// [meta.trans.other]/conditional\ntemplate &lt;bool B, class T, class F&gt; struct conditional { typedef T type; };\ntemplate &lt;class T, class F&gt; struct conditional&lt;false, T, F&gt; { typedef F type; };\n\n// class template with non-template operator() member\ntemplate &lt;typename T&gt; struct Foo {\n    explicit Foo(const T &amp;value) : value_(value) {}\n\n    // [Question regarding this conversion operator here]\n    operator typename conditional&lt;is_int&lt;T&gt;::value, int, void&gt;::type() const {\n        return value_;\n  }\n\nprivate:\n  T value_;\n};\n\n/* Alternatively */\ntemplate &lt;typename T&gt; class Bar {\n    struct Dummy {};\n    T value_;\npublic:\n    explicit Bar(const T &amp;value) : value_(value) {}\n    operator typename conditional&lt;is_int&lt;T&gt;::value, int, Dummy&gt;::type() const {\n        return value_;\n  }\n};\n\n}  // namespace util\n</code></pre>\n<p><strong><code>main.cc</code></strong>:</p>\n<pre><code>#include \"include/util.h\"\n\nvoid baz(int) {}\n\nint main()\n{\n    const util::Foo&lt;int&gt; foo_int(42);\n    baz(foo_int); // OK\n    const util::Foo&lt;char&gt; foo_char('a');\n\n    const util::Bar&lt;int&gt; bar_int(42);\n    baz(bar_int); // OK\n    const util::Bar&lt;char&gt; bar_char('a');\n\n    /* OK, expected:\n       Error: cannot convert \u2018const util::Foo&lt;char&gt;\u2019/\u2018const util::Bar&lt;char&gt;\u2019\n         to \u2018int\u2019 for argument \u20181\u2019 to \u2018void baz(int)\n    baz(foo_char);\n    baz(bar_char); */\n\n    return 0;\n}\n</code></pre>\n<p>This compiles fine using <code>gcc</code> and <code>clang</code> (<code>-std=c++03</code>), but I'm wondering if it's really OK to conditionally have an invalid body(/return) for the conversion operator, as is the case e.g. for a full instantiation of <code>Foo&lt;char&gt;</code>. I'm assuming it's fine due to partial implicit instantiation; [temp.inst]/1 (14.7.1 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">in the C++03 standard draft</a>) describes [<strong>emphasis</strong> mine]:</p>\n<blockquote>\n<p id=\"so_48889931_48889931_0\">The implicit instantiation of a class template specialization causes\n  the implicit instantiation of the declarations, <strong>but not of the\n  definitions</strong> or default arguments, <strong>of the class member functions</strong>,\n  member classes, static data members and member templates; and it\n  causes the implicit instantiation of the definitions of member\n  anonymous unions. Unless a <strong>member of a class template</strong> or a member\n  template has been explicitly instantiated or explicitly specialized,\n  the specialization of the member is implicitly instantiated <strong>when the\n  specialization is referenced in a context that requires the member\n  definition to exist</strong>;</p>\n</blockquote>\n<p><strong>Question</strong></p>\n<ul>\n<li>Does the C++03 Standard guarantee that a conditionally (trait on <code>T</code>) invalid non-template member function body of a class template is not an error in case it is not referenced from instantiations of the class where it is/would be invalid?</li>\n</ul>\n</hr>", "Title": "Excluding conversion operator from class template ...<typename T> based on traits on T", "CreationDate": "2018-02-20T16:32:48.953", "LastActivityDate": "2018-02-20T17:11:33.797", "CommentCount": "9", "LastEditDate": "2018-02-20T17:11:33.797", "PostTypeId": "1", "LastEditorUserId": "4573247", "Id": "48889931", "Score": "0", "OwnerUserId": "4573247", "Tags": "<c++><templates><language-lawyer><c++03>", "AnswerCount": "0"}});