post_cb({"bq_ids": {"n4140": {"so_14607506_14607736_0": {"length": 13, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_14607506_14607736_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_14607506_14607736_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "14608534": {"Id": "14608534", "PostTypeId": "2", "Body": "<p>A singleton instance is a global. Globals can be shared across DLL/Shared object boundaries, if that is really what you are asking.</p>\n<p>You also need to understand the <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow\">One Definition Rule</a>, which guarantees that indeed there is only one definition of this class, and therefore any static members within the class have just one instance.</p>\n", "LastActivityDate": "2013-01-30T16:11:43.053", "CommentCount": "0", "CreationDate": "2013-01-30T16:11:43.053", "ParentId": "14607506", "Score": "1", "OwnerUserId": "442284"}, "14607506": {"ViewCount": "3529", "Body": "<p>Let's imagine that I have following architecture:</p>\n<ul>\n<li><code>Dodo</code> singleton class in <code>libdodo</code></li>\n<li>Main program has linked <code>libdodo</code> and <code>libponny</code>; Main Program called <code>Dodo::instance()</code></li>\n<li><code>Ponny</code> class from <code>libponny</code> created. It has headers for <code>Dodo</code> singleton</li>\n</ul>\n<p>mainwindow.cpp</p>\n<pre><code>    #include \"shared/dodo/dodo.h\"\n    // ...\n    Dodo::instance()-&gt;setNumber(91);\n</code></pre>\n<p>And then, after this call, <code>Ponny</code> class (ponny.cpp) is created</p>\n<p><strong>ponny.cpp</strong></p>\n<pre><code>    #include \"shared/dodo/dodo.h\"\n    // ...\n    bool is = (Dodo::instance()-&gt;number() == 91);\n    // Will `is` be true?\n</code></pre>\n<p>So, can I do it in this way?</p>\n", "AcceptedAnswerId": "14607736", "Title": "Accessing singleton defined in shared library", "CreationDate": "2013-01-30T15:26:01.323", "Id": "14607506", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-01-30T23:58:34.817", "LastEditorUserId": "1168156", "LastActivityDate": "2013-01-30T23:58:34.817", "Score": "5", "OwnerUserId": "1894236", "Tags": "<c++><singleton><shared-libraries>", "AnswerCount": "2"}, "14607736": {"Id": "14607736", "PostTypeId": "2", "Body": "<p>Since definitions of behaviour of your singleton are located within its library, it means that singleton instance will be unique and it will exist within the compilation unit where it was created.</p>\n<p>Let's say that in <code>libdodo</code> there is <code>Dodo.cpp</code>, where you have:</p>\n<pre><code>static Dodo&amp; Dodo::instance()\n{\n    static Dodo dodo;\n    return dodo;\n}\n</code></pre>\n<p>Note that <strong>local</strong> static variables are initialized the first time execution reaches their declaration, so in this case when <code>Dodo::instance</code> is called first time, so most likely you won't have any problems with lazy initialization of singleton like this.</p>\n<p>The only fact that plays role here is thread safety, since there is a possible race condition when more threads call <code>Dodo::instance()</code> for the first time. For more information I recommend you to read:<br>\nthis question: <a href=\"https://stackoverflow.com/questions/3069255/singleton-multi-threading\">Singleton &amp; Multi-threading</a><br>\nthis article: <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2004/03/08/85901.aspx\" rel=\"nofollow noreferrer\">C++ scoped static initialization is not thread-safe, on purpose!</a><br>\nand this question could help you as well:   <a href=\"https://stackoverflow.com/questions/6915/thread-safe-lazy-construction-of-a-singleton-in-c\">Thread safe lazy construction of a singleton in C++</a></br></br></br></p>\n<hr>\n<p>Also note that in C++11 (\u00a76.7.4), initialization of static variables is guaranteed to be threadsafe:</p>\n<blockquote>\n<p id=\"so_14607506_14607736_0\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>which means that lazy initialization like this becomes kinda bulletproof ;)</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-30T16:52:52.940", "Score": "3", "CreationDate": "2013-01-30T15:35:35.847", "ParentId": "14607506", "CommentCount": "2", "LastEditDate": "2017-05-23T11:47:25.103", "OwnerUserId": "1168156"}});