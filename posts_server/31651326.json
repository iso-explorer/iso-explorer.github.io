post_cb({"bq_ids": {"n4140": {"so_31651326_31662268_6": {"length": 42, "quality": 0.8076923076923077, "section_id": 52}}, "n3337": {"so_31651326_31662268_6": {"length": 42, "quality": 0.8076923076923077, "section_id": 47}}, "n4659": {"so_31651326_31662268_6": {"length": 42, "quality": 0.8076923076923077, "section_id": 53}}}, "31662268": {"Id": "31662268", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_31651326_31662268_0\"><strong>1) What was the reasoning to allow that name sharing?</strong></p>\n</blockquote>\n<p>According to <a href=\"http://stroustrup.com/dne.html\" rel=\"nofollow\">\"The Design and Evolution of C++\", by Bjarne Stroustrup</a>, section 2.8.2 \"Structure Tags vs. Type Names\", this feature was introduced to maintain compatibility with C. The C language requires the use of the <code>struct</code> keyword to name a structure (no keyword is required to name a typedef). You can then use the same identifier to declare a structure and either a function or a variable:</p>\n<pre><code>struct X { int m; };\nvoid X(void);\n\nX(); // call X\nstruct X x; // create a new object of type X\n</code></pre>\n<blockquote>\n<p id=\"so_31651326_31662268_1\">A significant syntactic simplification for the benefit of users was\n  introduced into C++ at the cost of some extra work to implementers and\n  some C compatibility problems. [...] In the context of C with Classes\n  [dyp: the predecessor of C++], this had annoyed me for some time\n  because it made user-defined types second-class citizens\n  syntactically.</p>\n<p id=\"so_31651326_31662268_2\">[...]</p>\n<p id=\"so_31651326_31662268_3\">The real need to address this particular issue came from the fact that some standard UNIX header files, notably, <code>stat.h</code>, rely on a <code>struct</code> and a variable or function having the same name.</p>\n<p id=\"so_31651326_31662268_4\">-- <em>D&amp;E 2.8.2</em></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_31651326_31662268_5\"><strong>2) Why the reasoning that allowed code 2 was not good enough to allow code 4?</strong></p>\n</blockquote>\n<p>I'll first quote the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_31651326_31662268_6\">A class template shall not have the same name as any other template,\n  class, function, variable, enumeration, enumerator, namespace, or type\n  in the same scope (3.3), except as specified in (14.5.5 <em>[dyp: class template partial specialization]</em>). Except that\n  a function template can be overloaded either by (non-template)\n  functions with the same name or by other function templates with the\n  same name (14.8.3 <em>[dyp: this refers to overloading]</em>), a template name declared in namespace scope or in\n  class scope shall be unique in that scope.</p>\n<p id=\"so_31651326_31662268_7\">-- <em>C++11 International Standard [temp]p5</em></p>\n</blockquote>\n<p>According to my interpretation of this passage, codes 3 and 4 are both illegal. clang++ rejects them, but accepts the first part of code 3:</p>\n<pre><code>template&lt; class H &gt; void h(){}\nstruct h{};\n</code></pre>\n<p>Which, according to [temp]p5, should be illegal as well.</p>\n<p>Considering all these examples (3, 4, and the beginning of 3) as illegal, I think the <em>rationale</em> is that you don't need the compatibility exception in those cases: C has no templates.</p>\n</hr>", "LastActivityDate": "2015-07-27T20:07:02.703", "CommentCount": "0", "CreationDate": "2015-07-27T20:07:02.703", "ParentId": "31651326", "Score": "3", "OwnerUserId": "420683"}, "31651326": {"ViewCount": "121", "Body": "<p>While the name of a structure must be unique in the set of structures within a namespace, such a name can be \"shared\" with variables and functions. For example, the following code compiles just fine:</p>\n<pre><code>// Code 1\nstruct h{};\nint h{ 8 };\n</code></pre>\n<p>Similarly, there is no collision in:</p>\n<pre><code>// Code 2\nstruct h{};\nvoid h(){}\n</code></pre>\n<p><strong>1) What was the reasoning to allow that name sharing?</strong></p>\n<p>Moreover, if we throw templates into the mix, we have some strange situations. The code </p>\n<pre><code>// Code 3\ntemplate&lt; class H &gt; void h(){}\nstruct h{};\ntemplate&lt; class H &gt; struct j{};\nvoid j(){}\n</code></pre>\n<p>does compile; but the following code fails:</p>\n<pre><code>// Code 4\nstruct h{};\ntemplate&lt; class H &gt; void h(){}\nvoid j(){}\ntemplate&lt; class H &gt; struct j{};\n</code></pre>\n<p><strong>2) Why the reasoning that allowed code 2 was not good enough to allow code 4?</strong> I am not asking about the rules in the standard. I am asking about the reason behind those rules.</p>\n", "AcceptedAnswerId": "31662268", "Title": "uniqueness of struct names", "CreationDate": "2015-07-27T10:58:57.740", "Id": "31651326", "CommentCount": "9", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-07-27T20:07:02.703", "Score": "6", "OwnerUserId": "2549876", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}});