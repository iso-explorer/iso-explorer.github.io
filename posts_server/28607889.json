post_cb({"28607889": {"CommentCount": "7", "AcceptedAnswerId": "28608670", "PostTypeId": "1", "LastEditorUserId": "149392", "CreationDate": "2015-02-19T13:40:07.917", "LastActivityDate": "2015-02-19T16:03:05.390", "LastEditDate": "2015-02-19T15:20:17.163", "ViewCount": "1296", "FavoriteCount": "2", "Title": "How to generate the same random number sequence over multiple types of compilers and kernels with <random>?", "Id": "28607889", "Score": "18", "Body": "<h2>The problem</h2>\n<p>I need to produce the same (pseudo) random number sequence on different machines and compilers. If I use the same kernel, it seems that the implementetion of mersenne twister (MT) in g++ works well: regardless if I compile my program on a newer machine, with g++ 4.9 or 4.7, I get the same random numbers. But I get different ones if I use older kernel or if I change to Visual Studio's compiler. That's ok, because there's no gurantee that <code>mersenne_twister_engine::seed</code> sets the internal state to the same over different compilers.</p>\n<h3>What I've already tried</h3>\n<p>I tought that applying <code>operator&lt;&lt;</code> on the generator produces a unique result that can be used to set the generators on other machines with the <code>operator&gt;&gt;</code>, but in case of <code>mt19937</code>, it seems it is not working. To make it clear, on a computer A I had the code </p>\n<pre><code>mt19937 generator1A;\nuniform_int_distribution&lt;int&gt; distribution(0, 1000);\n\ncout &lt;&lt; \"Generating random numbers with seed 1000\" &lt;&lt; endl;\n\ngenerator1A.seed(1000);\ngenerator1A(); //to advance the state by one so operator&gt;&gt; will give a longer output; this is not necessary indeed\nofstream test(\"testseed1000.txt\");\ntest &lt;&lt; generator1A &lt;&lt; endl;\n\nfor (int i = 0; i &lt; 10; ++i)\n    cout &lt;&lt; distribution(generator1A) &lt;&lt; endl;\n</code></pre>\n<p>And it produces 252, 590, 893, ..., and a long file. I transfer the file to the other machine B, and run the following code:</p>\n<pre><code>mt19937 generator1B, generator2B;\nuniform_int_distribution&lt;int&gt; distribution(0, 1000);\n\ncout &lt;&lt; \"Generating random numbers with seed 1000, and with operator&gt;&gt;\" &lt;&lt; endl;\ngenerator2B.seed(1000);\ngenerator2B(); // to advance the state by one here as well\n\nifstream test(\"testseed1000.txt\");\n\ntest &gt;&gt; generator1B;\ncout &lt;&lt; \"************************\" &lt;&lt; endl;\ncout &lt;&lt; generator1B &lt;&lt; endl;\ncout &lt;&lt; \"************************\" &lt;&lt; endl;\ncout &lt;&lt; \"With seed\\twith operator&gt;&gt;\" &lt;&lt; endl;\n\nfor (int i = 0; i &lt; 10; ++i)\n    cout &lt;&lt; distribution(generator2B) &lt;&lt; \"\\t\" &lt;&lt; distribution(generator1B) &lt;&lt; endl;\n</code></pre>\n<p>And it produces</p>\n<pre><code>654     205\n205     115\n115     610\n</code></pre>\n<h2>The question</h2>\n<p>Can you give advices how to generate the same (pseudo) random numbers with at least VC++ on Windows and g++ on Debian and Ubuntu? I'd like to use std if it is possible and I wouldn't like to implement my own MT engine.</p>\n<h3>Notes:</h3>\n<ul>\n<li>creating millions of random numbers and then reading in is not a solution</li>\n<li>I have to use MSVS for code developing and unix servers for simulation</li>\n<li>other than MT engines are also welcomed but I prefer MT</li>\n</ul>\n", "Tags": "<c++><c++11><random>", "OwnerUserId": "1837006", "AnswerCount": "2"}, "28608670": {"ParentId": "28607889", "CommentCount": "1", "CreationDate": "2015-02-19T14:17:39.167", "OwnerUserId": "1084944", "PostTypeId": "2", "Id": "28608670", "Score": "12", "Body": "<p>To remove a variable from the problem, try looking at the outputs from your random number engine, rather than feeding it into a distribution.</p>\n<p>I just looked at a few documentation pages for <code>uniform_int_distribution</code>, and it does not give any statement about how the outputs from the uniform random number generator are used. I'm not sure what the standard says.</p>\n<p>I predict that you <em>are</em> getting the same outputs from your mersenne twister, but you're feeding those outputs into two inequivalent implementations of <code>uniform_int_distribution</code>.</p>\n<p>If this is true, then to get the same random number sequence, you're going to have to use an external implementation of the distribution functions to ensure that you get the same results on all systems.</p>\n", "LastActivityDate": "2015-02-19T14:17:39.167"}, "bq_ids": {"n4140": {"so_28607889_28610763_1": {"section_id": 3612, "quality": 0.8571428571428571, "length": 6}, "so_28607889_28610763_0": {"section_id": 3574, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_28607889_28610763_1": {"section_id": 3474, "quality": 0.8571428571428571, "length": 6}, "so_28607889_28610763_0": {"section_id": 3439, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_28607889_28610763_1": {"section_id": 4376, "quality": 0.7142857142857143, "length": 5}, "so_28607889_28610763_0": {"section_id": 4339, "quality": 0.6923076923076923, "length": 9}}}, "28610763": {"ParentId": "28607889", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-02-19T15:52:03.720", "Score": "8", "LastEditorUserId": "2756719", "LastEditDate": "2015-02-19T16:03:05.390", "Id": "28610763", "OwnerUserId": "2756719", "Body": "<p>The standard requires the engines to produce reproducible numbers across implementations, by specifying the value a default-constructed engine must produce on the 10000th invocation (it also specifies the actual transition and generation algorithms for the engines). For instance, for <code>mt19937</code> the standard specifies that ([rand.predef]/p3):</p>\n<blockquote>\n<pre><code>typedef mersenne_twister_engine&lt;uint_fast32_t,\n       32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253&gt;\n       mt19937;\n</code></pre>\n<p id=\"so_28607889_28610763_0\"><em>Required behavior</em>: The 10000<sup>th</sup> consecutive invocation of a default-constructed object of type <code>mt19937</code> shall produce the value\n  4123659995.</p>\n</blockquote>\n<p>For distributions, there's no such requirement; instead the standard says that ([rand.dist.general]/p3):</p>\n<blockquote>\n<p id=\"so_28607889_28610763_1\">The algorithms for producing each of the specified distributions are\n  implementation-defined.</p>\n</blockquote>\n<p>In other words, implementations may use different algorithms for the distributions, but must document the algorithms they use. MSVC and libstdc++ presumably use different algorithms.</p>\n<p>You might consider using an external implementation, such as Boost.Random's distribution classes, if you want full portability.</p>\n", "LastActivityDate": "2015-02-19T16:03:05.390"}});