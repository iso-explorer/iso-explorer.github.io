post_cb({"26641063": {"ParentId": "26640866", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong>Short answer:</strong> This was a bug in the Standard which is fixed in C++14, and g++ 4.9 has the fix (retroactively applied to C++11 mode too). <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1288\">Defect Report 1288</a></p>\n<hr>\n<p>Here's a simpler example:</p>\n<pre><code>struct S\n{\n    int x;\n    S() { }     // this causes S to not be an aggregate (otherwise aggregate \n                // initialization is used instead of list initialization)\n};\n\nS x = 5;\nS const &amp;y { x } ;    \n\nx = 6;\nstd::cout &lt;&lt; y &lt;&lt; std::endl;     // output : 5\n</code></pre>\n<p>In the text of C++11, the meaning of <code>S const &amp;y {x};</code> is not to bind <code>y</code> to <code>x</code>; in fact the meaning is to create a temporary and bind a reference to that. From C++11 [dcl.init.ref]/3:  </p>\n<blockquote>\n<p id=\"so_26640866_26641063_0\">Otherwise, if T is a reference type, <strong>a prvalue temporary</strong> of the type referenced by T is list-initialized, and the reference is bound to that temporary. [Note: As usual, the binding will fail and the program is ill-formed if the reference type is an lvalue reference to a non-const type. \u2014end note ]</p>\n</blockquote>\n<p>This is pretty silly , clearly the intent of this code is to bind <code>y</code> directly to <code>x</code>. In C++14 the text was changed:</p>\n<blockquote>\n<p id=\"so_26640866_26641063_1\">Otherwise, if the initializer list has a single element of type E and either T is not a reference type or its referenced type is reference-related to E, the object or reference is initialized from that element;</p>\n</blockquote>\n<p>Since a type is reference-related to itself (or one of its base classes), in my sample here and in your actual code, it should actually bind correctly.</p>\n<hr>\n<p>Your error message comes from the compiler following the C++11 wording and attempting to create a temporary from <code>base</code> to bind the reference to; and this fails because <code>base</code> is of an abstract type.</p>\n</hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2014-10-29T23:10:38.710", "Id": "26641063", "Score": "12", "CreationDate": "2014-10-29T21:34:03.810", "LastActivityDate": "2014-10-29T23:10:38.710"}, "bq_ids": {"n4140": {"so_26640866_26641063_1": {"section_id": 3325, "quality": 1.0, "length": 17}, "so_26640866_26641063_0": {"section_id": 3325, "quality": 0.84, "length": 21}}, "n3337": {"so_26640866_26641063_1": {"section_id": 3195, "quality": 0.6470588235294118, "length": 11}, "so_26640866_26641063_0": {"section_id": 3195, "quality": 0.88, "length": 22}}, "n4659": {"so_26640866_26641063_1": {"section_id": 4091, "quality": 1.0, "length": 17}, "so_26640866_26641063_0": {"section_id": 4091, "quality": 0.72, "length": 18}}}, "26640866": {"CommentCount": "6", "AcceptedAnswerId": "26641063", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2014-10-29T21:18:48.380", "LastActivityDate": "2016-09-08T03:46:44.960", "LastEditDate": "2016-09-08T03:46:44.960", "ViewCount": "981", "FavoriteCount": "3", "Title": "Why doesn't C++11 curly brace initialzation in constructor initialization list work when parens initializaton does?", "Id": "26640866", "Score": "11", "Body": "<p>How is {} initialization in a constructor initialization list different from () initialization when initializing reference to abstract types?  Take class Bar below:</p>\n<pre><code>class AbstractBase\n{\npublic:\n    AbstractBase() {}\n    virtual ~AbstractBase() = default;\n\n    virtual void ab() = 0;\n};\n\nclass Foo : public AbstractBase\n{\npublic:\n    Foo() {}\n\n    void ab() {}\n};\n\nclass Bar\n{\npublic:\n    Bar(const AbstractBase&amp; base) : myBase{base} {}\n\nprivate:\n    const AbstractBase&amp; myBase;\n};\n\n\nint main()\n{\n    Foo f{};\n    Bar b{f};\n\n}\n</code></pre>\n<p>When compiling, I get the error</p>\n<pre><code>test5.cpp: In constructor \u2018Bar::Bar(const AbstractBase&amp;)\u2019:\ntest5.cpp:22:48: error: cannot allocate an object of abstract type \u2018AbstractBase\u2019\n     Bar(const AbstractBase&amp; base) : myBase{base}\n                                                ^\ntest5.cpp:2:7: note:   because the following virtual functions are pure within \u2018AbstractBase\u2019:\n class AbstractBase\n       ^\ntest5.cpp:8:18: note:   virtual void AbstractBase::ab()\n     virtual void ab() = 0;\n</code></pre>\n<p>Changing the line</p>\n<pre><code>Bar(const AbstractBase&amp; base) : myBase(base) {}\n</code></pre>\n<p>it compiles and runs fine.</p>\n<p>Reading through Stroustrup's C++11 book, I was under the impression that {} was the same as () in most all cases, except where there was an ambiguity between constructors that take std::initializer_list&lt;&gt; and other constructors, and cases where using auto as the type, neither of which I'm doing here.</p>\n", "Tags": "<c++><c++11><reference><initialization><list-initialization>", "OwnerUserId": "3362479", "AnswerCount": "1"}});