post_cb({"5013938": {"ParentId": "5013829", "CommentCount": "0", "Body": "<p>Is this essentially equivalent to:</p>\n<pre><code>test((A*)&amp;B);\n</code></pre>\n<p>Almost ;-P</p>\n<pre><code>test(*(A*)&amp;B);\n</code></pre>\n<p>(Nasty stuff!)</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "5013938", "Score": "0", "CreationDate": "2011-02-16T08:06:12.327", "LastActivityDate": "2011-02-16T08:06:12.327"}, "5013829": {"CommentCount": "1", "ViewCount": "209", "PostTypeId": "1", "LastEditorUserId": "619230", "CreationDate": "2011-02-16T07:52:00.300", "LastActivityDate": "2011-02-16T09:08:22.713", "Title": "Structure typecast", "LastEditDate": "2011-02-16T08:35:56.923", "Id": "5013829", "Score": "1", "Body": "<p>Given the following code:</p>\n<pre><code>struct A_struct\n{\n  int x;\n};\n\nstruct B_struct\n{\n  int y;\n};\n\nint test(A_struct some_struct)\n{\n  return some_struct.x;\n}\n\nB_struct B;\n</code></pre>\n<p>Can someone explain what kind of typecasting this is?</p>\n<pre><code>test((A_struct&amp;)B);\n</code></pre>\n<p>Is this essentially equivalent to:</p>\n<pre><code>test(*(A_struct*)&amp;B);\n</code></pre>\n<p>I'm mainly curious in how they are equivalent, since I'm having trouble finding any text that bridges the gap.</p>\n", "Tags": "<c++>", "OwnerUserId": "619230", "AnswerCount": "4"}, "5013856": {"ParentId": "5013829", "CommentCount": "0", "Body": "<p>It's a C-style cast permitting you to do some very bad things, which happens to work in this sample case since the layout in memory of the two completely unrelated structs happen to match.</p>\n<p>Don't do this, unless you know exactly what you want and that this is how to achieve it on every platform you use.</p>\n", "OwnerUserId": "616700", "PostTypeId": "2", "Id": "5013856", "Score": "4", "CreationDate": "2011-02-16T07:56:05.517", "LastActivityDate": "2011-02-16T07:56:05.517"}, "5013914": {"ParentId": "5013829", "CommentCount": "1", "Body": "<pre><code>test((A&amp;)B);\n</code></pre>\n<p>is not a valid statement.</p>\n<p>Though assuming 'B' is an instance of the struct B, the statement will blindly typecast the object B into a reference to an 'A' type of object. </p>\n", "OwnerUserId": "415007", "PostTypeId": "2", "Id": "5013914", "Score": "0", "CreationDate": "2011-02-16T08:03:04.287", "LastActivityDate": "2011-02-16T08:03:04.287"}, "bq_ids": {"n4140": {"so_5013829_5014483_0": {"section_id": 6050, "quality": 0.6739130434782609, "length": 31}}, "n3337": {"so_5013829_5014483_0": {"section_id": 5818, "quality": 0.8913043478260869, "length": 41}}, "n4659": {"so_5013829_5014483_0": {"section_id": 7549, "quality": 0.6739130434782609, "length": 31}}}, "5014483": {"ParentId": "5013829", "CommentCount": "0", "Body": "<p>In this case, this should be the equivalent of C++ <code>reinterpret_cast</code>:</p>\n<p><strong>5.2.10. <code>reinterpret_cast</code>:</strong></p>\n<blockquote>\n<p id=\"so_5013829_5014483_0\">An lvalue expression of type T1 can be\n  cast to the type \"reference  to   T2\" \n  if  an  expression of type \"pointer to\n  T1\" can be explicitly converted to\n  the type \"pointer to T2\" using a\n  reinterpret_cast.  That is,   a \n  reference  cast \n  <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same\n  effect as the   conversion\n  <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in &amp; and *  operators.   The\n  result is an lvalue that refers to the\n  same object as the   source lvalue,\n  but with a different type.  No\n  temporary is created, no   copy  is\n  made, and constructors\n  or conversion functions are not called.</p>\n</blockquote>\n", "OwnerUserId": "219972", "PostTypeId": "2", "Id": "5014483", "Score": "1", "CreationDate": "2011-02-16T09:08:22.713", "LastActivityDate": "2011-02-16T09:08:22.713"}});