post_cb({"bq_ids": {"n4140": {"so_47310700_47310910_1": {"length": 19, "quality": 0.7916666666666666, "section_id": 6028}, "so_47310700_47310910_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 6019}}, "n3337": {"so_47310700_47310910_1": {"length": 18, "quality": 0.75, "section_id": 5796}, "so_47310700_47310910_2": {"length": 16, "quality": 0.6666666666666666, "section_id": 5787}}, "n4659": {"so_47310700_47310910_1": {"length": 21, "quality": 0.875, "section_id": 7527}, "so_47310700_47310910_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 7518}}}, "47310990": {"Id": "47310990", "PostTypeId": "2", "Body": "<p>Not at all.</p>\n<p>Let's say Base is represented in memory by this block [--] and A is [--+], here you can see that A contains a part Base (with the little '-').</p>\n<p>When you are creating a Base you have your [--] and then you are casting it to A which means that you are saying it's in fact [--+] BUT the memory after [--] does not correspond to [--+]</p>\n<p>As you may understand with this example, you can cast A to Base because [--+] contains [--] </p>\n", "LastActivityDate": "2017-11-15T15:16:26.687", "CommentCount": "0", "CreationDate": "2017-11-15T15:16:26.687", "ParentId": "47310700", "Score": "0", "OwnerUserId": "8945252"}, "47310910": {"Id": "47310910", "PostTypeId": "2", "Body": "<p><code>static_cast</code> for performing downcast does not perform any safety checks. Since it's possible for a <code>Base&amp;</code> to be referencing an instance of <code>A</code>, the cast proceeds and since it's <em>NOT</em> actually referencing an <code>A</code>, we enter undefined behavior territory<sup>*</sup>.</p>\n<p>A <code>dynamic_cast</code> on the other hand is safer. It will perform a check and throw an exception in the case of reference casting, or return <code>nullptr</code> in the case of pointer casting<sup>\u2020</sup>.</p>\n<p>However, since your base class lacks any virtual functions, <code>dynamic_cast</code> is impossible, so you'd need to modify it with at least a virtual destructor:</p>\n<pre><code>class Base{\npublic:\n    int m_object;\n    virtual ~Base()=default;\n};\n</code></pre>\n<p>Now if we tried to cast:</p>\n<pre><code>A* a = dynamic_cast&lt;A*&gt;(&amp;base);\nif (a)\n    a-&gt;arggh();\nelse\n    std::cout &lt;&lt; \"null\\n\";\n</code></pre>\n<p>Our output would be</p>\n<blockquote>\n<p id=\"so_47310700_47310910_0\">null</p>\n</blockquote>\n<hr>\n<p><sup>*</sup>Relevant standardese can be found in [expr.static.cast]:</p>\n<blockquote>\n<p id=\"so_47310700_47310910_1\">[for a cast like <code>static_cast&lt;D&amp;&gt;(b)</code> where <code>b</code> is an instance of a base class for <code>D</code>], If the object of type \u201c<em>cv1</em> <code>B</code>\u201d is actually a base class subobject of an object of type <code>D</code>, the result refers to the enclosing object of type <code>D</code>. Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p><sup>\u2020</sup>Relevant standardese at [expr.dynamic.cast]</p>\n<blockquote>\n<p id=\"so_47310700_47310910_2\">The value of a failed cast to pointer type is the null pointer value of the required result type. A failed cast to reference type throws an exception of a type that would match a handler of type\n  <code>std::bad_cast</code></p>\n</blockquote>\n</hr>", "LastEditorUserId": "63550", "LastActivityDate": "2017-11-23T12:36:30.627", "Score": "5", "CreationDate": "2017-11-15T15:12:49.223", "ParentId": "47310700", "CommentCount": "1", "LastEditDate": "2017-11-23T12:36:30.627", "OwnerUserId": "27678"}, "47310772": {"Id": "47310772", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>Not all <code>Base</code> objects are of type <code>A</code><sup>1</sup>, although the converse is true, and a <code>static_cast</code> would work in <em>that</em> direction.</p>\n<hr>\n<p><sup>1</sup>Another translation unit might have a class that inherits from <code>Base</code>.</p>\n</hr>", "LastActivityDate": "2017-11-15T15:06:03.630", "CommentCount": "4", "CreationDate": "2017-11-15T15:06:03.630", "ParentId": "47310700", "Score": "1", "OwnerUserId": "2380830"}, "47310700": {"ViewCount": "71", "Body": "<p>Is this <code>static_cast</code> downcast valid?</p>\n<pre><code>// non-virtual, may be non-trivially copyable\nstruct Base{\n    int m_object;\n};\n\n// Derived class have only non-virtual functions\nstruct A : Base{\n    void arggh(){\n        std::cout &lt;&lt; \"Arrghh \" &lt;&lt; m_object;\n    }\n};\n\nint main() {\n    Base base{190};\n    A&amp; a = static_cast&lt;A&amp;&gt;(base);\n    a.arggh();\n    return 0;\n}\n</code></pre>\n<p>I mean, CREATE base class, and then cast to derived.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b41fa256a292b145\" rel=\"nofollow noreferrer\">Live</a></p>\n", "AcceptedAnswerId": "47310910", "Title": "C++ static_cast downcast validity", "CreationDate": "2017-11-15T15:02:53.253", "Id": "47310700", "CommentCount": "5", "PostTypeId": "1", "ClosedDate": "2017-11-15T18:54:17.347", "LastActivityDate": "2017-11-23T12:36:30.627", "Score": "1", "OwnerUserId": "1559666", "Tags": "<c++>", "AnswerCount": "3"}});