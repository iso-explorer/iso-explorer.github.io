post_cb({"19251227": {"ParentId": "19249975", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_19249975_19251227_0\">why <code>a == b</code>? I know that <code>c == d</code> because of the precision of double.</p>\n</blockquote>\n<p>For exactly the same reason. There are no overloads of <code>pow</code> for integer types, so the arithmetic is done using <code>double</code>. Since <code>double</code> typically has 52 bits of significance, adding or subtracting 1 to a value as large as 2<sup>63</sup> will have no effect.</p>\n<blockquote>\n<p id=\"so_19249975_19251227_1\">why <code>(long long)c</code> and <code>(long long)d</code> is not <code>9223372036854775800</code>?</p>\n</blockquote>\n<p>Because <code>long long</code> is a 64-bit <strong>signed</strong> type, and the maximum representable value is 2<sup>63</sup>-1. <code>c</code> and <code>d</code> might both have the value 2<sup>63</sup> (or even a slightly larger value), which is out of range. On a typical 2s-complement platform, this is likely to overflow to give a value around -2<sup>63</sup>, as you observe. But note that this is undefined behaviour; you cannot rely on anything if a floating point conversion overflows.</p>\n<blockquote>\n<p id=\"so_19249975_19251227_2\">why <code>(long long)c != a</code> and <code>(long long)d != b</code>?</p>\n</blockquote>\n<p>I don't know; for me, <code>a</code> and <code>b</code> have the same large negative values. It looks like some quirk of your implementation caused <code>a</code> and <code>b</code> to end up with the value 2<sup>63</sup>-1 rather than the expected 2<sup>63</sup>. As always when dealing with floating-point numbers, you should expect small rounding errors like that.</p>\n<p>You could get the exact result by using integer arithmetic:</p>\n<pre><code>long long a = (1ULL &lt;&lt; 63) - 1;\nunsigned long long b = 1ULL &lt;&lt; 63;\n</code></pre>\n<p>Note the use of unsigned arithmetic since, as mentioned above, the signed <code>(1LL &lt;&lt; 63)</code> would overflow.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-10-09T15:26:47.607", "Id": "19251227", "Score": "2", "CreationDate": "2013-10-08T14:57:08.760", "LastActivityDate": "2013-10-09T15:26:47.607"}, "19250143": {"ParentId": "19249975", "CommentCount": "2", "Body": "<p><code>pow(2,63) - 1</code> is all done in double-precision floating point arithmetic. In particular, the <code>-1</code> is converted into <code>-1.0</code> and that is too small to matter</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "19250143", "Score": "4", "CreationDate": "2013-10-08T14:13:29.477", "LastActivityDate": "2013-10-08T14:13:29.477"}, "19268886": {"ParentId": "19249975", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>long long -&gt; %lld</p>\n<p>long double -&gt;%Lf</p>\n<p>double    -&gt; %f</p>\n<p>float     -&gt; %f</p>\n<p>int       -&gt; %d</p>\n<p>Read Chapter 15 in &lt;&lt; POINTERS on C &gt;&gt; for more details.</p>\n", "OwnerUserId": "2349273", "LastEditorUserId": "2349273", "LastEditDate": "2013-10-09T13:12:50.070", "Id": "19268886", "Score": "0", "CreationDate": "2013-10-09T10:02:26.343", "LastActivityDate": "2013-10-09T13:12:50.070"}, "19251473": {"ParentId": "19249975", "PostTypeId": "2", "CommentCount": "11", "Body": "<blockquote>\n<p id=\"so_19249975_19251473_0\">why a == b</p>\n</blockquote>\n<p>Because your compiler (gcc) calculated the values to initialize <code>a</code> and <code>b</code> with, and found (proved ?) both were matching or exceeding the maximum possible value for a <code>long long</code>, so it initialized both with that maximum value <code>LLONG_MAX</code> (or <code>0x7FFFFFFFFFFFFFFF</code>, or <code>9223372036854775807</code> on your platform).</p>\n<p>Note that (as pointed out by Pascal Cuoq) this is undefined behaviour, caused by an overflow while converting a <code>double</code> to a <code>long long</code> when initializing <code>a</code> and <code>b</code>. While gcc deals with this as described above, other compilers can deal with this differently</p>\n<blockquote>\n<p id=\"so_19249975_19251473_1\">I know that c ==d because of the precision of double</p>\n</blockquote>\n<p>The reason <code>c</code> and <code>d</code> hold the same value is indeed because of the precision of a <code>double</code> :</p>\n<ul>\n<li><code>pow(2, 63)</code> can be accurately represented with fraction <code>1</code> and exponent <code>63</code></li>\n<li><code>pow(2, 63) - 1</code> cannot be accurately represented</li>\n</ul>\n<p>The reason it's not showing <code>9223372036854775808</code> (the precise value stored in <code>c</code> and <code>d</code>), is because of the <code>printf</code> precision, which on your platform apparently only shows 17 digits. You might be able to force it to show more using eg. <code>%20.0f</code>, but on Windows that will likely not make a difference due to <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/329278/printf-sprintf-do-not-print-enough-significant-digits-for-exact-binary-fractions\" rel=\"nofollow\">this bug</a>.</p>\n<blockquote>\n<p id=\"so_19249975_19251473_2\">why (long long)c and (long long)d is not 9223372036854775800 ?</p>\n</blockquote>\n<p>Because <code>c</code> and <code>d</code> hold the value <code>9223372036854775808</code>, or <code>0x8000000000000000</code>, which when printed as a signed value becomes <code>-9223372036854775808</code>.</p>\n<p>Note that this is again undefined behaviour (due to signed overflow).</p>\n<blockquote>\n<p id=\"so_19249975_19251473_3\">why (long long)c != a and (long long)d != b?</p>\n</blockquote>\n<p>Because they were calculated in different ways. <code>a</code> and <code>b</code> were calculated by the compiler, while <code>(long long) c</code> and <code>(long long) d</code> were calculated at runtime.</p>\n<p>While normally, these different ways of calculating should yield the same results, we're dealing with undefined behaviour here (as explained earlier), so anything goes. And in your case, the compiler's results are different from the runtime results.</p>\n", "OwnerUserId": "822669", "LastEditorUserId": "822669", "LastEditDate": "2013-10-09T10:12:44.027", "Id": "19251473", "Score": "2", "CreationDate": "2013-10-08T15:07:55.473", "LastActivityDate": "2013-10-09T10:12:44.027"}, "19250134": {"ParentId": "19249975", "CommentCount": "2", "Body": "<p>Because <code>pow</code> returns a double and double lost precisions. That's why <code>a==b</code>.</p>\n", "OwnerUserId": "1153165", "PostTypeId": "2", "Id": "19250134", "Score": "1", "CreationDate": "2013-10-08T14:13:01.760", "LastActivityDate": "2013-10-08T14:13:01.760"}, "19249975": {"CommentCount": "5", "AcceptedAnswerId": "19251227", "PostTypeId": "1", "LastEditorUserId": "1439688", "CreationDate": "2013-10-08T14:07:26.233", "LastActivityDate": "2013-10-09T15:26:47.607", "LastEditDate": "2013-10-08T15:00:54.783", "ViewCount": "4542", "FavoriteCount": "1", "Title": "confuse in \"double to long long\" in c++", "Id": "19249975", "Score": "3", "Body": "<p>my code:</p>\n<pre><code>int main()\n{\nlong long a = pow(2,63) - 1;\nlong long b = pow(2,63);\ndouble c  = pow(2,63) - 1;\ndouble d = pow(2,63);\nprintf(\"%lld %lld \\n%f %f \\n%lld %lld\\n\", a, b, c, d, (long long)c, (long long)d);\n\nreturn 0;\n}\n</code></pre>\n<p>and the excute result is (codeblock with gcc in win7 x64):</p>\n<pre><code>9223372036854775807 9223372036854775807\n9223372036854775800.000000 9223372036854775800.000000\n-9223372036854775808 -9223372036854775808\n</code></pre>\n<p><strong>Question:</strong></p>\n<p>Why <code>a == b</code> ?</p>\n<p>I know that <code>c == d</code> because of the precision of <code>double</code>.</p>\n<p>But why <code>(long long)c</code> and <code>(long long)d</code> is not <code>9223372036854775800</code> ?</p>\n<p>And why <code>(long long)c != a</code>  and <code>(long long)d != b</code>?</p>\n", "Tags": "<c++><double><long-long>", "OwnerUserId": "2234300", "AnswerCount": "6"}, "19250182": {"ParentId": "19249975", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>pow(2, 63)</code> is equivalent to <code>pow((double) 2, (double) 63)</code>.</p>\n<p>Indeed, C++11 26.8 [c.math] paragraph 3 says that <code>&lt;cmath&gt;</code> provides the declaration of <code>double pow(double, double)</code> and paragraph 11 says that (emphasis mine)</p>\n<blockquote id=\"so_19249975_19250182_0\">\n<blockquote id=\"so_19249975_19250182_1\">\n<ol>\n<li>If any argument corresponding to a double parameter has type long double, then all arguments corresponding to double parameters are effectively cast to long double.</li>\n<li>Otherwise, <strong>if any argument corresponding to a <code>double</code> parameter has type <code>double</code> or an integer type, then all arguments corresponding to <code>double</code> parameters are effectively cast to <code>double</code></strong>.</li>\n<li>Otherwise, all arguments corresponding to double parameters are effectively cast to float.</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>Now, the literals <code>2</code> and <code>63</code> are <code>int</code>s, therefore, <code>pow(2, 63)</code> is equivalent to <code>pow((double) 2, (double) 63)</code>. The returning type is then <code>double</code> which doesn't have 63 bits of precision required to \"see\" the difference between <code>2^63</code> and <code>2^63 - 1</code>.</p>\n<p>I recommend the reading of <a href=\"https://stackoverflow.com/questions/5627030/why-was-stdpowdouble-int-removed-from-c11\">this post</a> and the excelent answer by Howard Hinnant.</p>\n", "OwnerUserId": "1137388", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:22.797", "Id": "19250182", "Score": "0", "CreationDate": "2013-10-08T14:14:52.790", "LastActivityDate": "2013-10-08T14:56:06.287"}, "bq_ids": {"n4140": {"so_19249975_19250182_0": {"section_id": 3876, "quality": 0.9545454545454546, "length": 42}, "so_19249975_19250182_1": {"section_id": 3876, "quality": 0.9545454545454546, "length": 42}}, "n3337": {"so_19249975_19250182_0": {"section_id": 3736, "quality": 1.0, "length": 44}, "so_19249975_19250182_1": {"section_id": 3736, "quality": 1.0, "length": 44}}, "n4659": {"so_19249975_19250182_0": {"section_id": 4690, "quality": 0.9545454545454546, "length": 42}, "so_19249975_19250182_1": {"section_id": 4690, "quality": 0.9545454545454546, "length": 42}}}});