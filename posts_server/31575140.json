post_cb({"31575140": {"CommentCount": "9", "AcceptedAnswerId": "31575766", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-07-22T22:27:58.693", "LastActivityDate": "2015-07-26T22:20:45.187", "LastEditDate": "2017-05-23T11:44:01.370", "ViewCount": "234", "FavoriteCount": "1", "Title": "Do any implementations of operator new return a pointer to a guard page for zero-size arrays?", "Id": "31575140", "Score": "8", "Body": "<p>Related to: <a href=\"https://stackoverflow.com/a/1087066/625687\">C++ new int[0] -- will it allocate memory?</a></p>\n<p>The standard says, in 5.3.4/7:</p>\n<blockquote>\n<p id=\"so_31575140_31575140_0\">When the value of the expression in a direct-new-declarator is zero, the allocation function is called to allocate an array with no elements.</p>\n</blockquote>\n<p>...and, in 3.7.3.1/2:</p>\n<blockquote>\n<p id=\"so_31575140_31575140_1\">The effect of dereferencing a pointer returned as a request for zero size is undefined.</p>\n</blockquote>\n<p>...yet, the pointer can't be a null pointer.</p>\n<p>Since actually dereferencing the pointer is undefined behavior, does any implementation return a pointer to a guard page? I imagine that it'd be easy, and help detect bugs/improve security.</p>\n", "Tags": "<c++><new-operator>", "OwnerUserId": "625687", "AnswerCount": "2"}, "31576143": {"ParentId": "31575140", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-07-23T00:19:08.200", "Score": "2", "LastEditorUserId": "693294", "LastEditDate": "2015-07-26T22:20:45.187", "Id": "31576143", "OwnerUserId": "693294", "Body": "<p>To track how much memory needs to be released most allocators I've looked within or wrote look something like:</p>\n<pre> void *malloc_example( size_t bytes ) {\n     size_t *ret = get_memory(bytes + sizeof size_t);   /* find free memory */\n     *ret = bytes;                /* remember size of allocated area */\n     return (void *)( ret + 1 );\n }</pre>\n<p>So when you allocate zero-length blocks you actually get a sneaky word ahead of the address returned to you. This also assures each allocation is assigned a unique address. This is important and pointing to dedicated guard memory for zero-length blocks is more of a waste as each free must test for what my experience says is a rare condition.</p>\n<p>Some debugging allocators include additional overhead to catch double-frees, memory leaks, guard words to catch overflow of previous buffers, etc. Also, pointing to some magic memory can make such debugging more difficult to do.</p>\n", "LastActivityDate": "2015-07-26T22:20:45.187"}, "31575766": {"ParentId": "31575140", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-07-22T23:32:20.453", "Score": "4", "LastEditorUserId": "5145654", "LastEditDate": "2015-07-23T00:21:57.817", "Id": "31575766", "OwnerUserId": "5145654", "Body": "<p>I looked at the (draft) standard and I couldn't find anything that explicitly prohibits this. I would guess that the answer is \"no\", though. This is why:</p>\n<ul>\n<li>As you say, new is required to return a non-null pointer.</li>\n<li>Further, whatever it returns must be safe to pass to delete.</li>\n<li>So a \"random value\" won't work because it will break delete.</li>\n<li>It's also required to return different values for each call (at least until they are deleted) - see the C++ standard section basic.stc.dynamic.allocation.</li>\n<li>At this point only one option remains: return \"fake  pointers\" which are somehow recognizable by delete as \"fake pointers\".</li>\n</ul>\n<p>One possible implementation could be done by reserving a range of unpaged memory, and every time someone calls new int[0] it could return a different address in that range (easy to do if the allocator keeps a global counter or something like that).</p>\n<p>On the plus side, you will gain the ability to immediately detect dereferences on this type of pointer. On the other hand, you will lose the ability to detect double-frees because delete on your pointer effectively becomes a no op, and you will make new and delete more complex and slower for all the normal cases.</p>\n<p>So because it's tricky to do, and the cons outweigh the pros, I'm pretty confident that nobody does that.</p>\n<p>gcc on linux just allocates a small amount of memory and returns that. I believe that this is pretty much a standard way to do this.</p>\n", "LastActivityDate": "2015-07-23T00:21:57.817"}, "bq_ids": {"n4140": {"so_31575140_31575140_1": {"section_id": 7177, "quality": 0.7777777777777778, "length": 7}, "so_31575140_31575140_0": {"section_id": 6088, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_31575140_31575140_1": {"section_id": 6921, "quality": 0.8888888888888888, "length": 8}, "so_31575140_31575140_0": {"section_id": 5856, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_31575140_31575140_1": {"section_id": 8685, "quality": 0.7777777777777778, "length": 7}, "so_31575140_31575140_0": {"section_id": 7584, "quality": 0.7272727272727273, "length": 8}}}});