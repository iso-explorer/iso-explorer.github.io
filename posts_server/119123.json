post_cb({"119132": {"ParentId": "119123", "CommentCount": "0", "CreationDate": "2008-09-23T04:27:07.347", "OwnerUserId": "7756", "Id": "119132", "PostTypeId": "2", "OwnerDisplayName": "Orion Adrian", "Score": "5", "Body": "<p>It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that's not a multiple of 4 bytes.</p>\n<p>Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.</p>\n", "LastActivityDate": "2008-09-23T04:27:07.347"}, "119123": {"CommentCount": "4", "AcceptedAnswerId": "119128", "PostTypeId": "1", "LastEditorUserId": "5306861", "CreationDate": "2008-09-23T04:24:47.820", "LastActivityDate": "2017-07-05T20:25:02.153", "AnswerCount": "11", "LastEditDate": "2016-05-16T17:37:03.013", "ViewCount": "126173", "FavoriteCount": "223", "Title": "Why isn't sizeof for a struct equal to the sum of sizeof of each member?", "Id": "119123", "Score": "490", "Body": "<p>Why does the 'sizeof' operator return a size larger for a structure than the total sizes of the structure's members?</p>\n", "Tags": "<c++><c><struct><sizeof><c++-faq>", "OwnerUserId": "6386", "OwnerDisplayName": "Kevin"}, "37032302": {"ParentId": "119123", "LastEditDate": "2017-04-11T06:30:22.160", "CommentCount": "0", "CreationDate": "2016-05-04T15:38:27.733", "OwnerUserId": "895245", "LastEditorUserId": "895245", "PostTypeId": "2", "Id": "37032302", "Score": "5", "Body": "<p><strong>C99 N1256 standard draft</strong></p>\n<p><a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf</a></p>\n<p><em>6.5.3.4 The sizeof operator</em>:</p>\n<blockquote>\n<p id=\"so_119123_37032302_0\">3 When applied to an operand that has structure or union type,\n  the result is the total number of bytes in such an object,\n  including internal and trailing padding.</p>\n</blockquote>\n<p><em>6.7.2.1 Structure and union specifiers</em>:</p>\n<blockquote>\n<p id=\"so_119123_37032302_1\">13 ... There may be unnamed\n  padding within a structure object, but not at its beginning.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_119123_37032302_2\">15 There may be unnamed padding at the end of a structure or union.</p>\n</blockquote>\n<p>The new C99 <a href=\"https://en.wikipedia.org/wiki/Flexible_array_member\" rel=\"nofollow noreferrer\">flexible array member feature</a> (<code>struct S {int is[];};</code>) may also affect padding:</p>\n<blockquote>\n<p id=\"so_119123_37032302_3\">16 As a special case, the last element of a structure with more than one named member may\n  have an incomplete array type; this is called a flexible array member. In most situations,\n  the flexible array member is ignored. In particular, the size of the structure is as if the\n  flexible array member were omitted except that it may have more trailing padding than\n  the omission would imply.</p>\n</blockquote>\n<p><em>Annex J Portability Issues</em> reiterates:</p>\n<blockquote>\n<p id=\"so_119123_37032302_4\">The following are unspecified: ...</p>\n<ul>\n<li>The value of padding bytes when storing values in structures or unions (6.2.6.1)</li>\n</ul>\n</blockquote>\n<p><strong>C++11 N3337 standard draft</strong></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></p>\n<p><em>5.3.3 Sizeof</em>:</p>\n<blockquote>\n<p id=\"so_119123_37032302_5\">2 When applied\n  to a class, the result is the number of bytes in an object of that class including any padding required for\n  placing objects of that type in an array.</p>\n</blockquote>\n<p><em>9.2 Class members</em>:</p>\n<blockquote>\n<p id=\"so_119123_37032302_6\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:\n  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,\n  as necessary to achieve appropriate alignment. \u2014 end note ]</p>\n</blockquote>\n<p>I only know enough C++ to understand the note :-)</p>\n", "LastActivityDate": "2017-04-11T06:30:22.160"}, "bq_ids": {"n4140": {"so_119123_37032302_5": {"section_id": 6077, "quality": 1.0, "length": 15}, "so_119123_37032302_1": {"section_id": 5879, "quality": 0.8, "length": 8}, "so_119123_37032302_0": {"section_id": 6077, "quality": 0.5625, "length": 9}, "so_119123_37032302_6": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}}, "n3337": {"so_119123_37032302_5": {"section_id": 5845, "quality": 1.0, "length": 15}, "so_119123_37032302_1": {"section_id": 5650, "quality": 0.8, "length": 8}, "so_119123_37032302_0": {"section_id": 5845, "quality": 0.5625, "length": 9}, "so_119123_37032302_6": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_119123_37032302_5": {"section_id": 7573, "quality": 1.0, "length": 15}, "so_119123_37032302_1": {"section_id": 7363, "quality": 0.8, "length": 8}, "so_119123_37032302_0": {"section_id": 7573, "quality": 0.5625, "length": 9}, "so_119123_37032302_6": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}}}, "119144": {"CommentCount": "2", "CreationDate": "2008-09-23T04:31:41.610", "LastEditorUserId": "19784", "LastActivityDate": "2014-01-09T12:53:22.087", "ParentId": "119123", "LastEditDate": "2014-01-09T12:53:22.087", "OwnerDisplayName": "Kyle Burton", "PostTypeId": "2", "Id": "119144", "Score": "11", "Body": "<p>This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:</p>\n<pre><code>#include \"stdio.h\"\n\n\nstruct oneInt {\n  int x;\n};\n\nstruct twoInts {\n  int x;\n  int y;\n};\n\nstruct someBits {\n  int x:2;\n  int y:6;\n};\n\n\nint main (int argc, char** argv) {\n  printf(\"oneInt=%zu\\n\",sizeof(struct oneInt));\n  printf(\"twoInts=%zu\\n\",sizeof(struct twoInts));\n  printf(\"someBits=%zu\\n\",sizeof(struct someBits));\n  return 0;\n}\n</code></pre>\n<p>Have members who's sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).</p>\n<pre><code>oneInt=4\ntwoInts=8\nsomeBits=4\n</code></pre>\n", "OwnerUserId": "19784"}, "30760303": {"ParentId": "119123", "LastEditDate": "2015-06-12T06:50:22.897", "CommentCount": "6", "CreationDate": "2015-06-10T15:07:08.930", "OwnerUserId": "4995406", "LastEditorUserId": "4995406", "PostTypeId": "2", "Id": "30760303", "Score": "4", "Body": "<p>The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.</p>\n<p>For example.  Consider the simple structure:</p>\n<pre><code>struct myStruct\n{\n   int a;\n   char b;\n   int c;\n} data;\n</code></pre>\n<p>If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,</p>\n<p>Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.</p>\n<p>Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper \"packing\".</p>\n<p>On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.</p>\n<p>For example:</p>\n<pre><code>#pragma pack 1\nstruct MyStruct\n{\n    int a;\n    char b;\n    int c;\n    short d;\n} myData;\n\nI = sizeof(myData);\n</code></pre>\n<p>I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.</p>\n", "LastActivityDate": "2015-06-12T06:50:22.897"}, "119134": {"CommentCount": "4", "CreationDate": "2008-09-23T04:27:32.383", "LastEditorUserId": "1950231", "LastActivityDate": "2015-11-30T23:33:40.563", "ParentId": "119123", "LastEditDate": "2015-11-30T23:33:40.563", "OwnerDisplayName": "EmmEff", "PostTypeId": "2", "Id": "119134", "Score": "131", "Body": "<p>Packing and byte alignment, as described in the C FAQ <a href=\"http://www.c-faq.com/struct/align.html\" rel=\"noreferrer\">here</a>:</p>\n<blockquote>\n<p id=\"so_119123_119134_0\">It's for alignment. Many processors can't access 2- and 4-byte\n  quantities (e.g. ints and long ints) if they're crammed in\n  every-which-way.</p>\n<p id=\"so_119123_119134_1\">Suppose you have this structure:</p>\n<pre><code>struct {\n    char a[3];\n    short int b;\n    long int c;\n    char d[3];\n};\n</code></pre>\n<p id=\"so_119123_119134_2\">Now, you might think that it ought to be possible to pack this\n  structure into memory like this:</p>\n<pre><code>+-------+-------+-------+-------+\n|           a           |   b   |\n+-------+-------+-------+-------+\n|   b   |           c           |\n+-------+-------+-------+-------+\n|   c   |           d           |\n+-------+-------+-------+-------+\n</code></pre>\n<p id=\"so_119123_119134_3\">But it's much, much easier on the processor if the compiler arranges\n  it like this:</p>\n<pre><code>+-------+-------+-------+\n|           a           |\n+-------+-------+-------+\n|       b       |\n+-------+-------+-------+-------+\n|               c               |\n+-------+-------+-------+-------+\n|           d           |\n+-------+-------+-------+\n</code></pre>\n<p id=\"so_119123_119134_4\">In the packed version, notice how it's at least a little bit hard for\n  you and me to see how the b and c fields wrap around? In a nutshell,\n  it's hard for the processor, too. Therefore, most compilers will pad\n  the structure (as if with extra, invisible fields) like this:</p>\n<pre><code>+-------+-------+-------+-------+\n|           a           | pad1  |\n+-------+-------+-------+-------+\n|       b       |     pad2      |\n+-------+-------+-------+-------+\n|               c               |\n+-------+-------+-------+-------+\n|           d           | pad3  |\n+-------+-------+-------+-------+\n</code></pre>\n</blockquote>\n", "OwnerUserId": "9188"}, "121049": {"ParentId": "119123", "CommentCount": "1", "CreationDate": "2008-09-23T13:38:11.797", "OwnerUserId": "1674", "Id": "121049", "PostTypeId": "2", "OwnerDisplayName": "JohnMcG", "Score": "4", "Body": "<p>In addition to the other answers, a struct can (but usually doesn't) have virtual functions, in which case the size of the struct will also include the space for the vtbl.</p>\n", "LastActivityDate": "2008-09-23T13:38:11.797"}, "119128": {"CommentCount": "12", "CreationDate": "2008-09-23T04:25:34.527", "CommunityOwnedDate": "2008-09-23T04:25:34.527", "LastEditorUserId": "5402401", "LastActivityDate": "2017-07-05T20:25:02.153", "ParentId": "119123", "PostTypeId": "2", "LastEditorDisplayName": "Chris Jester-Young", "LastEditDate": "2017-07-05T20:25:02.153", "Id": "119128", "Score": "486", "Body": "<p>This is because of padding added to satisfy alignment constraints. <a href=\"http://en.wikipedia.org/wiki/Data_structure_alignment\" rel=\"noreferrer\">Data structure alignment</a> impacts both performance and correctness of programs:</p>\n<ul>\n<li>Mis-aligned access might be a hard error (often <code>SIGBUS</code>).</li>\n<li>Mis-aligned access might be a soft error.\n\n<ul>\n<li>Either corrected in hardware, for a modest performance-degradation.</li>\n<li>Or corrected by emulation in software, for a severe performance-degradation.</li>\n<li>In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.</li>\n</ul></li>\n</ul>\n<p>Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):</p>\n<pre><code>struct X\n{\n    short s; /* 2 bytes */\n             /* 2 padding bytes */\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 3 padding bytes */\n};\n\nstruct Y\n{\n    int   i; /* 4 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n    short s; /* 2 bytes */\n};\n\nstruct Z\n{\n    int   i; /* 4 bytes */\n    short s; /* 2 bytes */\n    char  c; /* 1 byte */\n             /* 1 padding byte */\n};\n\nconst int sizeX = sizeof(struct X); /* = 12 */\nconst int sizeY = sizeof(struct Y); /* = 8 */\nconst int sizeZ = sizeof(struct Z); /* = 8 */\n</code></pre>\n<p>One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure <code>Z</code> in the example above).</p>\n<p>IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special <code>#pragma</code> statements to change the structure alignment settings.</p>\n", "OwnerUserId": "6386", "OwnerDisplayName": "Kevin"}, "35595109": {"ParentId": "119123", "CommentCount": "0", "Body": "<p>The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.</p>\n<pre><code>struct pixel {\n    unsigned char red;   // 0\n    unsigned char green; // 1\n    unsigned int alpha;  // 4 (gotta skip to an aligned offset)\n    unsigned char blue;  // 8 (then skip 9 10 11)\n};\n\n// next offset: 12\n</code></pre>\n<p>The x86 architecture has always been able to fetch misaligned addresses. However, it's slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.</p>\n<p>Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today's mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)</p>\n<p>Finally, note that cache lines can be arbitrarily large, and the compiler doesn't attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line. </p>\n<p><em>TL;DR:</em> alignment is important.</p>\n", "OwnerUserId": "140740", "PostTypeId": "2", "Id": "35595109", "Score": "2", "CreationDate": "2016-02-24T06:46:13.627", "LastActivityDate": "2016-02-24T06:46:13.627"}, "31687400": {"ParentId": "119123", "LastEditDate": "2015-07-29T06:38:59.103", "CommentCount": "0", "CreationDate": "2015-07-28T21:25:42.483", "OwnerUserId": "1154447", "LastEditorUserId": "1154447", "PostTypeId": "2", "Id": "31687400", "Score": "3", "Body": "<p><strong>C language leaves compiler some freedom about the location of the structural elements in the memory:</strong></p>\n<ul>\n<li>memory holes may appear between any two components, and after the last component. It was due to the fact that certain types of objects on the target computer may be limited by the boundaries of addressing</li>\n<li>\"memory holes\" size included in the result of sizeof operator. The sizeof only doesn't include size of the flexible array, which is available in C/C++</li>\n<li>Some implementations of the language allow you to control the memory layout of structures through the pragma and compiler options</li>\n</ul>\n<p><strong>The C language provides some assurance to the programmer of the elements layout in the structure:</strong></p>\n<ul>\n<li>compilers required to assign a sequence of components increasing memory addresses</li>\n<li>Address of the first component coincides with the start address of the structure</li>\n<li>unnamed bit fields may be included in the structure to the required address alignments of adjacent elements</li>\n</ul>\n<p><strong>Problems related to the elements alignment:</strong></p>\n<ul>\n<li>Different computers line the edges of objects in different ways</li>\n<li>Different restrictions on the width of the bit field</li>\n<li>Computers differ on how to store the bytes in a word (Intel 80x86 and Motorola 68000)</li>\n</ul>\n<p><strong>How alignment works:</strong></p>\n<ul>\n<li>The volume occupied by the structure is calculated as the size of the aligned single element of an array of such structures. The structure should\nend so that the first element of the next following structure does not  the violate requirements of alignment</li>\n</ul>\n<p>p.s More detailed info are available here: \"Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)\"</p>\n", "LastActivityDate": "2015-07-29T06:38:59.103"}, "119491": {"CommentCount": "7", "CreationDate": "2008-09-23T07:06:14.547", "CommunityOwnedDate": "2013-08-25T13:16:43.090", "LastEditorUserId": "13136", "LastActivityDate": "2013-08-29T15:26:46.857", "ParentId": "119123", "PostTypeId": "2", "OwnerDisplayName": "Iulian \u0218erb\u0103noiu", "LastEditDate": "2013-08-29T15:26:46.857", "Id": "119491", "Score": "22", "Body": "<p>If you want the structure to have a certain size with GCC for example use <a href=\"http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/\" rel=\"noreferrer\"><code>__attribute__((packed))</code></a>.</p>\n<p>On Windows you can set the alignment to one byte when using the cl.exe compier with the <a href=\"http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx\" rel=\"noreferrer\">/Zp option</a>.</p>\n<p>Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.</p>\n<p>So it is a matter of alignment basically.</p>\n<p><strong>You need to have good reasons to change it.</strong></p>\n", "OwnerUserId": "13136"}, "6185547": {"ParentId": "119123", "LastEditDate": "2017-04-24T21:45:36.043", "CommentCount": "2", "CreationDate": "2011-05-31T09:27:12.250", "OwnerUserId": "724291", "LastEditorUserId": "724291", "PostTypeId": "2", "Id": "6185547", "Score": "8", "Body": "<p>See also:</p>\n<p>for Microsoft Visual C:</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/2e70t5y1%28v=vs.80%29.aspx</a></p>\n<p>and GCC claim compatibility with Microsoft's compiler.:</p>\n<p><a href=\"http://gcc.gnu.org/onlinedocs/gcc/Structure_002dPacking-Pragmas.html\" rel=\"nofollow noreferrer\">http://gcc.gnu.org/onlinedocs/gcc/Structure_002dPacking-Pragmas.html</a></p>\n<p>In addition to the previous answers, please note that regardless the packaging, <strong>there is no members-order-guarantee in C++</strong>. Compilers may (and certainly do) add virtual table pointer and base structures' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.</p>\n<p>I'm quite sure <strong>member-order <em>is</em> guaranteed in C</strong>, but I wouldn't count on it, when writing a cross-platform or cross-compiler program.</p>\n", "LastActivityDate": "2017-04-24T21:45:36.043"}});