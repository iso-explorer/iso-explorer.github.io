post_cb({"24232937": {"CommentCount": "16", "AcceptedAnswerId": "24233450", "PostTypeId": "1", "LastEditorUserId": "368896", "CreationDate": "2014-06-15T18:47:01.913", "LastActivityDate": "2014-06-17T14:47:30.887", "LastEditDate": "2014-06-17T14:47:30.887", "ViewCount": "1059", "FavoriteCount": "1", "Title": "Should the memory vulnerability of the line of code \"printf(\"%s\", argv[1]);\" be described as a stack overflow?", "Id": "24232937", "Score": "16", "Body": "<p>Today, I took a short \"C++ skills test\" from Elance.com.  One question was the following:</p>\n<blockquote>\n<p id=\"so_24232937_24232937_0\">What is the security vulnerability of the following line of code:</p>\n<p id=\"so_24232937_24232937_1\"><code>printf(\"%s\", argv[1]);</code></p>\n<p id=\"so_24232937_24232937_2\"><strong>Option 1: Format String</strong></p>\n<p id=\"so_24232937_24232937_3\"><strong>Option 2: Stack Overflow</strong> &lt;-- This was marked by Elance as the correct answer</p>\n</blockquote>\n<p>The user was provided 10 seconds to answer this question after an initial few seconds of seeing the question (or automatically fail the question).  (There were also two other clearly irrelevant answers that were not marked as the correct answer by Elance.)</p>\n<p>I was looking for <strong>buffer overrun</strong> or <strong>buffer overflow</strong> as an option.</p>\n<p>I instinctively did not like the answer <em>stack overflow</em>, because in my 10 seconds I mentally used what I believe is the <a href=\"https://en.wikipedia.org/wiki/Stack_overflow\" rel=\"nofollow\">standard definition of \"Stack Overflow\"</a>:</p>\n<blockquote>\n<p id=\"so_24232937_24232937_4\">In software, a stack overflow occurs when the stack pointer exceeds\n  the stack bound. The call stack may consist of a limited amount of\n  address space, often determined at the start of the program ...</p>\n</blockquote>\n<p>According to this definition of \"Stack Overflow\", <strong>a buffer overrun is entirely possible without a stack overflow</strong>; it is a stack overflow only if the program attempts to <strong>write outside the calling program's total <em>stack allocation</em></strong> (whether due to a buffer overrun, or whether it would otherwise be a legitimate write, such as allocating memory for stack-based variables an excessive number of times).</p>\n<p>My 10-second instinct told me that \"buffer overrun\" is a more accurate description of the problematic line of code, above - because often (in my experience) there are sufficient null characters (<code>'\\0'</code>) peppered through garbage data in RAM to often avoid an actual stack overflow in cases like this, but a buffer overrun in the implementation seems reasonably possible or even likely.  (But the possibility that <code>printf</code> reads garbage here <em>might</em> assume that <code>argc == 1</code>, such that there <em>was</em> no user-provided <code>argv[1]</code>; if <code>argv[1]</code> is present, perhaps one can assume it's likely that the calling function has not inserted <code>NULL</code>'s.  It was not stated in the problem whether <code>argv[1]</code> was present.)</p>\n<p>Because I imagined that there could be a buffer overrun problem here, even without a stack overflow, I answered <strong><em>Format String</em></strong>, because simply by passing a different format string such as <code>\"%.8s\"</code>, the problem can be mostly avoided, so it seemed like an overall more generic, and therefore better, answer.</p>\n<p>My answer was marked as wrong.  The correct answer was marked as \"Stack Overflow\".</p>\n<p>It now occurs to me that perhaps if one assumes that <code>argv[1]</code> is present, that the <strong>only</strong> possible buffer overrun is a stack overflow, in which case, <em>stack overflow</em> might in fact be the correct answer.  However, even in this case, would it not be considered odd to call this a <em>stack overflow</em>?  Isn't <em>buffer overflow</em> a better way to describe this problem, even assuming <code>argv[1]</code> is present?  And, if <code>argv[1]</code> is <strong>not</strong> present, isn't it pretty much incorrect to state that the problem is <em>stack overflow</em>, rather than the more accurate <em>buffer overrun</em>?</p>\n<p>I would like the opinion of professionals on this site: Is \"stack overflow\" the proper way to define the memory safety problem with the above line of code?  Or, rather, is \"buffer overflow\" or \"buffer overrun\" clearly a <em>better</em> way to describe the problem?  Finally, given the two options provided for the question's answer (above), is the answer ambiguous, or is \"stack overflow\" (or \"format string\") clearly the better answer?</p>\n<hr>\n<p><strong>Tangential Comments regarding the Elance test</strong>  (Not related to the question in this posting)</p>\n<p>None of the Elance \"<strong>C++</strong> skills test\" questions pertained to <strong>any</strong> C++-specific features such as classes, templates, anything in the STL, or any aspect of polymorphism.  Every question was a down-and-out, straight-from-C question.</p>\n<p>Because there were many (at least 3) other questions in Elance's so-called \"C++ skills test\" that were unarguably wrong (such as this question: given <code>sizeof(int) == sizeof(int*)</code> and <code>sizeof(int) == 4</code>, then in the code <code>int *a, *b; a=b; b++; b-a;</code>, what is <code>b-a</code>, with the correct answer listed as <code>4</code>, rather than the actual correct answer of <code>1</code>), and given the fact that there were no C++-specific questions on the test, I have contacted Elance and plan to seriously pursue their problematic test with the organization.  However, for the question discussed in this posting, I am uncertain whether the question/answers are problematic.</p>\n</hr>", "Tags": "<c++><printf><stack-overflow><language-lawyer><buffer-overflow>", "OwnerUserId": "368896", "AnswerCount": "3"}, "24233435": {"ParentId": "24232937", "PostTypeId": "2", "CommentCount": "4", "Body": "<h2>C++ standard response</h2>\n<p>As far as the language is concerned there can be the following cases:</p>\n<ol>\n<li><code>argc &lt; 2</code></li>\n<li><code>argc &gt;= 2</code></li>\n</ol>\n<p>In the first case, <code>printf(\"%s\", argv[1])</code> is simply <em>undefined behavior</em>. </p>\n<p>In the second case, the program is well-formed (as from <code>argv[0]</code> to <code>argv[argc-1]</code> are guaranteed to be valid null terminated strings:</p>\n<blockquote>\n<p id=\"so_24232937_24233435_0\"><strong>\u00a73.6.1/2</strong> [basic.start.main]</p>\n<p id=\"so_24232937_24233435_1\">In the latter form, for purposes of exposition, the first function parameter is called argc and the second function parameter is called argv, where argc shall be the number of arguments passed to the program from the environment in which the program is run. <strong>If argc is nonzero these arguments shall be supplied in argv[0] through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings</strong> (ntmbs s) (17.5.2.1.4.2) and argv[0] shall be the pointer to the initial character of a ntmbs that represents the name used to invoke the program or \"\". The value of argc shall be non-negative. The value of argv[argc] shall be 0. [ Note: It is recommended that any further (optional) parameters be addedafterargv. \u2014endnote]</p>\n</blockquote>\n<p>(emphasis mine).</p>\n<h2>Why <em>stack overflow</em> is awfully imprecise</h2>\n<p>Given that no other informations were given (as compiler or architecture), the answer \"Stack Overflow\" is simply imprecise. The C++ standard does not try to defined what a \"stack\" is, and therefore \"stack overflow\" means almost nothing to the C++ standard.</p>\n<p>The standard reasons in terms of an <em>abstract machine</em> with a guaranteed memory model.</p>\n<h2>What really happens</h2>\n<p>In the case in which <code>argc &lt; 2</code>, nobody knows what happens. The standard does not guaranteed nor specify anything. In the case in which <code>argc &gt;= 2</code> the program is well-defined.</p>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-06-15T19:49:08.507", "Id": "24233435", "Score": "3", "CreationDate": "2014-06-15T19:42:22.943", "LastActivityDate": "2014-06-15T19:49:08.507"}, "24233450": {"ParentId": "24232937", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>There is no potential stack overflow here.</p>\n<p>The standard guarantees that <code>argc</code> is non-negative, which means it can be <code>0</code>. If <code>argc</code> is positive, <code>argv[0]</code> through <code>argv[argc-1]</code> are pointers to strings.</p>\n<p>If <code>argc == 0</code>, then <code>argv[1]</code> is not merely a null pointer -- it doesn't exist at all. In that case, <code>argv[1]</code> attempts to access a nonexistent array element.  (<code>argv[1]</code> is equivalent to <code>*(argv+1)</code>; the pointer addition is permitted, but the dereference has undefined behavior.) Note that in this case the program name, which would otherwise be accessible via <code>argv[0]</code> is unavailable.</p>\n<p>If <code>argc==1</code>, then <code>argv[1] == NULL</code>. Evaluating <code>argv[1]</code> is perfectly valid, but it yields a null pointer. Passing a null pointer to <code>printf</code> with a <code>\"%s\"</code> option has undefined behavior. I suppose you could call this a format string problem, but the real problem is using a null pointer when a non-null pointer to a string is required.</p>\n<p>If <code>argc &gt;= 2</code>, then <code>argv[1]</code> is guaranteed to point to a string, <code>printf(\"%s\", argv[1])</code> will simply print the characters of that string, up to but not including the terminating <code>'\\0'</code> (which is guaranteed to be exist).</p>\n<p>There is still a potential vulnerability in that case. Quoting <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">N1570</a> 7.21.6.1 paragraph 15:</p>\n<blockquote>\n<p id=\"so_24232937_24233450_0\">The number of characters that can be produced by any single conversion shall be at least\n  4095.</p>\n</blockquote>\n<p>(N1570 is a draft of the C standard; C++ refers to the C standard for portions of its standard library.)</p>\n<p>Which means that an implementation may limit the number of characters produced by the <code>printf</code> call. In practice, there's probably no reason to impose a fixed limit; <code>printf</code> can simply print characters, one at a time, until it reaches the end of the string. But in principle, if <code>strlen(argv[1]) &gt; 4095</code>, and if the current implementation imposes such a limit, then the behavior could be undefined.</p>\n<p>Still, this isn't what I'd call a \"stack overflow\" -- particularly since the C++ standard does not use the word \"stack\" (except for a couple of brief references to \"stack unwinding\").</p>\n<p>Most of these problems can be avoided by checking first:</p>\n<pre><code>if (argc &gt;= 2) {\n    printf(\"%s\", argv[1]);\n}\n</code></pre>\n<p>or, if you're feeling paranoid:</p>\n<pre><code>if (argc &gt;= 2 &amp;&amp; argv[1] != NULL) {\n    printf(\"%s\", argv[1]);\n}\n</code></pre>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2014-06-15T21:09:07.637", "Id": "24233450", "Score": "6", "CreationDate": "2014-06-15T19:44:11.677", "LastActivityDate": "2014-06-15T21:09:07.637"}, "24233349": {"ParentId": "24232937", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>On a Unix system <code>argv[1]</code> <a href=\"http://trust-in-soft.com/finding-vulnerabilities-in-small-challenge-like-c-programs/\" rel=\"nofollow\">can be</a> an invalid memory access in and of itself (case <code>argc==0</code>), a pointer to a well-formed string (<code>argc &gt;= 2</code>), or NULL (<code>argc == 1</code>).</p>\n<p>The problem with <code>printf(\"%s\", argv[1]);</code> is using a pointer (<code>argv[1]</code>) without having checked that it was valid. Anything that happens later is only a secondary consequence. The problem is the failure to validate that <code>argv[1]</code> is what is intended before using it. It might fall under the very general <a href=\"http://cwe.mitre.org/data/definitions/20.html\" rel=\"nofollow\">CWE20: Improper Input Validation</a>. It is misleading to call it a buffer overflow or a stack overflow.</p>\n", "OwnerUserId": "139746", "LastEditorUserId": "139746", "LastEditDate": "2014-06-15T19:39:42.743", "Id": "24233349", "Score": "4", "CreationDate": "2014-06-15T19:33:56.080", "LastActivityDate": "2014-06-15T19:39:42.743"}, "bq_ids": {"n4140": {"so_24232937_24233435_1": {"section_id": 7146, "quality": 0.8620689655172413, "length": 50}}, "n3337": {"so_24232937_24233435_1": {"section_id": 6890, "quality": 0.6206896551724138, "length": 36}}, "n4659": {"so_24232937_24233435_1": {"section_id": 8647, "quality": 0.8620689655172413, "length": 50}}}});