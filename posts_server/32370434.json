post_cb({"32370797": {"ParentId": "32370434", "CommentCount": "5", "Body": "<p>If you want to forbid construction/assignation from const temporary, you may mark as deleted these methods:</p>\n<pre><code>A(const A &amp;&amp;) = delete;\nA&amp; operator = (const A &amp;&amp;) = delete;\n</code></pre>\n<p><a href=\"https://ideone.com/jxUgWr\" rel=\"nofollow\">Live Demo</a></p>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "32370797", "Score": "1", "CreationDate": "2015-09-03T08:36:38.963", "LastActivityDate": "2015-09-03T08:36:38.963"}, "32370434": {"CommentCount": "6", "ViewCount": "271", "PostTypeId": "1", "LastEditorUserId": "2784509", "CreationDate": "2015-09-03T08:18:07.603", "LastActivityDate": "2015-09-03T08:39:25.963", "Title": "returning constant object and assigning it to non-constant object", "AcceptedAnswerId": "32370752", "LastEditDate": "2015-09-03T08:39:25.963", "Id": "32370434", "Score": "7", "Body": "<p>I've found strange behavior of a code which is apparently ignoring const-ness:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cerr;\n\nclass A\n{\npublic:\n    A() { cerr &lt;&lt; \"A::A()\\n\"; }\n    A(const A &amp;a) { cerr &lt;&lt; \"A::A(const A&amp;)\\n\"; }\n    A(A &amp;&amp;) { cerr &lt;&lt; \"A::A(A&amp;&amp;)\\n\"; }\n    A &amp; operator = (const A &amp;a) { cerr &lt;&lt; \"A::operator=(const A&amp;)\\n\"; return *this; }\n    A &amp; operator = (A &amp;&amp;a) { cerr &lt;&lt; \"A::operator(A&amp;&amp;)\\n\"; return *this; }\n    ~A() { cerr &lt;&lt; \"A::~A()\\n\"; }\n\n    const A get() const { cerr &lt;&lt; \"const A A::get() const\\n\"; return A(); }\n    A get() { cerr &lt;&lt; \"A A::get()\\n\"; return A(); }\n};\n\nint main()\n{\n    const A a;\n    A b = a.get();\n}\n</code></pre>\n<p>Firstly, what I did expect here: <code>a</code> is a constant, so the constant-version of get() is invoked. Next, constant object is being returned, but on the left side is non-constant object <code>b</code>, so the copy-constructor is ought to be called. Which is not:</p>\n<pre><code>A::A()\nconst A A::get() const\nA::A()\nA::~A()\nA::~A()\n</code></pre>\n<p>Is this behavior expected by c++ standard? <strong>So, is it okay that constness of a temporary object is simply ignored by RVO? And how copying could be enforced here?</strong></p>\n<p>Output with copy-elision disabled (<code>-fno-elide-constructors</code>) makes an additional move and the expected copy-constructor call:</p>\n<pre><code>A::A()\nconst A A::light_copy() const\nA::A()\nA::A(A&amp;&amp;)\nA::~A()\nA::A(const A&amp;)\nA::~A()\nA::~A()\nA::~A()\n</code></pre>\n<p>If <code>a</code> object is not constant, then it will be two moves without copying, which is expected too.</p>\n<p>PS. The behavior matters for me because the one I see is breaking shallow-copying const-strictness: for const-version of <code>get()</code> (which is <code>shallow_copy()</code> actually) I need to be sure that no modification of the returned object will be made, because the returned object is a shallow copy and a modification on the shallow copy will affect the \"parent\" object (which might be a constant).</p>\n", "Tags": "<c++><c++11><const><copy-constructor>", "OwnerUserId": "2784509", "AnswerCount": "2"}, "32370752": {"ParentId": "32370434", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_32370434_32370752_0\">So, is it okay that constness of a temporary object is simply ignored by RVO?</p>\n</blockquote>\n<p>Yes. [class.copy]/p31 (quoting N4527, which incorporates some DRs that clarifies the intent; emphasis mine):</p>\n<blockquote>\n<p id=\"so_32370434_32370752_1\">This elision of copy/move operations, called copy elision, is\n  permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, when the <em>expression</em> is the name of a nonvolatile automatic object (other\n  than a function parameter or a variable introduced by the\n  <em>exception-declaration</em> of a <em>handler</em> (15.3)) with the same type <strong>(ignoring cv-qualification)</strong> as the function return type, the copy/move\n  operation can be omitted by constructing the automatic object directly\n  into the function\u2019s return value</li>\n<li>[...]</li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same type\n  <strong>(ignoring cv-qualification)</strong>, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>The third bullet is the one applicable here; note that a similar rule applies to NRVO (first bullet) as well.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "32370752", "Score": "7", "CreationDate": "2015-09-03T08:34:26.460", "LastActivityDate": "2015-09-03T08:34:26.460"}, "bq_ids": {"n4140": {"so_32370434_32370752_1": {"section_id": 480, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_32370434_32370752_1": {"section_id": 471, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_32370434_32370752_1": {"section_id": 502, "quality": 0.9333333333333333, "length": 14}}}});