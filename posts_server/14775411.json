post_cb({"14775565": {"Id": "14775565", "PostTypeId": "2", "Body": "<p>When you say <code>throw x;</code>, then the exception object has the same type as <code>x</code> but is a copy.</p>\n<p>When you say <code>std::rethrow_exception(p);</code>, the exception object is the actual object which is referred to by the pointer, and no further copies get made.</p>\n<p>Thus is several threads concurrently rethrow the <em>same</em> exception pointer (which you are allowed to copy!), then they all have a reference to the <em>same</em> object.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-02-08T15:49:19.027", "Score": "3", "CreationDate": "2013-02-08T15:12:12.663", "ParentId": "14775411", "CommentCount": "2", "OwnerUserId": "596781", "LastEditDate": "2013-02-08T15:49:19.027"}, "14775558": {"Id": "14775558", "PostTypeId": "2", "Body": "<p>Yes, it's possible. The exception-handling mechanism already has a copy of the object that was originally thrown, squirreled away in a private memory stash. Typically, <code>exception_ptr</code> is implemented as a smart pointer that manages a reference count for that copy.</p>\n<p>As to the <strong>general</strong> requirements, if a specific requirement conflicts with a general requirement, the specific requirement wins.</p>\n", "LastActivityDate": "2013-02-08T15:11:39.147", "CommentCount": "2", "CreationDate": "2013-02-08T15:11:39.147", "ParentId": "14775411", "Score": "2", "OwnerUserId": "1593860"}, "14776362": {"Id": "14776362", "PostTypeId": "2", "Body": "<p>Yes, it looks like a deficiency in the standard.  For a rethrowing throw-expression i.e. <code>throw;</code> without an operand, 15.1p8 says:</p>\n<blockquote>\n<p id=\"so_14775411_14776362_0\">A <em>throw-expression</em> with no operand rethrows the currently handled exception. The exception is reactivated with the existing exception object; no new exception object is created. [...]</p>\n</blockquote>\n<p>That is:</p>\n<pre><code>#include &lt;exception&gt;\n#include &lt;cassert&gt;\nint main() {\n   std::exception *p = nullptr;\n   try {\n      try {\n         throw std::exception();\n      } catch(std::exception &amp;ex) {\n         p = &amp;ex;\n         throw;\n      }\n   } catch(std::exception &amp;ex) {\n      assert(p == &amp;ex);\n   }\n}\n</code></pre>\n<p>If the implementation of <code>current_exception</code> copies the currently handled exception object, there's no way to tell whether <code>rethrow_exception</code> copies or not, but if it refers to the exception object then we can check:</p>\n<pre><code>#include &lt;exception&gt;\n#include &lt;iostream&gt;\nint main() {\n   std::exception_ptr p;\n   try {\n      try {\n         throw std::exception();\n      } catch(...) {\n         p = std::current_exception();\n         std::cout &lt;&lt; (p == std::current_exception()) &lt;&lt; ' ';\n         std::rethrow_exception(p);\n      }\n   } catch(...) {\n      std::cout &lt;&lt; (p == std::current_exception()) &lt;&lt; '\\n';\n   }\n}\n</code></pre>\n<p>Every implementation I've tried it on prints <code>1 1</code>; <code>0 0</code> is allowed if <code>current_exception</code> copies; <code>0 1</code> is obviously impossible, while the standard in its current state appears to require <code>1 0</code>.  The fix would be for 18.8.5p10 to be clarified with language similar to 15.1p8, either allowing or mandating <code>rethrow_exception</code> to not copy the exception object pointed to by the <code>exception_ptr</code>.</p>\n<p>Most <strong>Throws:</strong> specifications in the standard just name a type (<em>Throws: <code>bad_alloc</code></em>) or use the indefinite article (<em>Throws: an exception of type ...</em>); the only other exception specifications to use the definite article are those of <code>future::get</code> and <code>shared_future::get</code>, so any resolution should probably address those as well.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2013-02-08T16:00:09.487", "Score": "3", "CreationDate": "2013-02-08T15:52:16.377", "ParentId": "14775411", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2013-02-08T16:00:09.487"}, "bq_ids": {"n4140": {"so_14775411_14775411_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6939}, "so_14775411_14776362_0": {"length": 15, "quality": 0.9375, "section_id": 3341}}, "n3337": {"so_14775411_14775411_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6687}, "so_14775411_14776362_0": {"length": 13, "quality": 0.8125, "section_id": 3211}}, "n4659": {"so_14775411_14775411_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 8436}, "so_14775411_14776362_0": {"length": 15, "quality": 0.9375, "section_id": 7673}}}, "14775411": {"ViewCount": "1116", "Body": "<p>While examining what <code>exception_ptr</code> does, the C++11 standard says (18.8.5/7) that:</p>\n<blockquote>\n<p id=\"so_14775411_14775411_0\">Use of rethrow_exception on exception_ptr objects that refer to the same exception object shall not introduce a data race. [ Note: if rethrow_exception rethrows the same exception object (rather than a copy), concurrent access to that rethrown exception object may introduce a data race...</p>\n</blockquote>\n<p>I don't find the case where this weird \"Note\" applies, since the described effect of <code>rethrow_exception</code> is \"Throws: the exception object to which p refers\" but 15.1/3, describing the general exception throwing process mandates that \"throwing an exception copy-initializes a temporary object, called the exception object.\"</p>\n<p>The weird note would imply that rethrow_exception skips this copy-initialization. But is this really possible?</p>\n", "AcceptedAnswerId": "14776362", "Title": "can rethrow_exception really throw the same exception object, rather than a copy?", "CreationDate": "2013-02-08T15:03:42.357", "Id": "14775411", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-02-09T12:34:16.203", "LastEditorUserId": "399317", "LastActivityDate": "2013-02-09T12:34:16.203", "Score": "7", "OwnerUserId": "1453330", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "3"}});