post_cb({"42132196": {"Id": "42132196", "PostTypeId": "2", "Body": "<p>It would have been okay if you allocated memory to variable x using \"new\" and directed a pointer towards it . Because when the scope of variable x ends (as outside if) , the VALUE of x will still remain on heap (dynamic memory allocated to your program) and your pointer will still be pointing to some valid value . but in your case, since the memory allocated to variable x wasn't allocated dynamically, so once the scope of x ends outside its if's block, VALUE of x also wipes out and so in this case the pointer is now NOT pointing to variable's value, rather it is now pointing to some garbage value</p>\n", "LastActivityDate": "2017-02-09T09:01:37.030", "CommentCount": "0", "CreationDate": "2017-02-09T09:01:37.030", "ParentId": "42128911", "Score": "0", "OwnerUserId": "5401992"}, "42128996": {"Id": "42128996", "PostTypeId": "2", "Body": "<p>The problem is the life span of the pointer is greater than that of the object pointed to. This smells bad and you should rethink what you're trying to do.</p>\n", "LastActivityDate": "2017-02-09T05:34:38.257", "CommentCount": "4", "CreationDate": "2017-02-09T05:34:38.257", "ParentId": "42128911", "Score": "6", "OwnerUserId": "1312406"}, "bq_ids": {"n4140": {"so_42128911_42129251_2": {"length": 8, "quality": 1.0, "section_id": 9}, "so_42128911_42129251_5": {"length": 10, "quality": 0.8333333333333334, "section_id": 9}, "so_42128911_42129251_4": {"length": 42, "quality": 0.9333333333333333, "section_id": 7187}, "so_42128911_42129251_7": {"length": 42, "quality": 0.9333333333333333, "section_id": 7187}, "so_42128911_42129251_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 9}, "so_42128911_42129251_6": {"length": 8, "quality": 1.0, "section_id": 9}}, "n3337": {"so_42128911_42129251_2": {"length": 8, "quality": 1.0, "section_id": 6}, "so_42128911_42129251_7": {"length": 37, "quality": 0.8222222222222222, "section_id": 6931}, "so_42128911_42129251_4": {"length": 37, "quality": 0.8222222222222222, "section_id": 6931}, "so_42128911_42129251_6": {"length": 8, "quality": 1.0, "section_id": 6}}, "n4659": {"so_42128911_42129251_2": {"length": 8, "quality": 1.0, "section_id": 10}, "so_42128911_42129251_5": {"length": 9, "quality": 0.75, "section_id": 10}, "so_42128911_42129251_4": {"length": 42, "quality": 0.9333333333333333, "section_id": 8695}, "so_42128911_42129251_7": {"length": 42, "quality": 0.9333333333333333, "section_id": 8695}, "so_42128911_42129251_1": {"length": 9, "quality": 0.75, "section_id": 10}, "so_42128911_42129251_6": {"length": 8, "quality": 1.0, "section_id": 10}}}, "42129222": {"Id": "42129222", "PostTypeId": "2", "Body": "<p>The short answer is that it is not safe to use that pointer. The long answer is more complicated. You <em>can</em> do it if you do this in a very specific way, that honestly, I don't think you ever should. The pointer pTest will in all likeliness point to a position relative to the stack pointer. As long as nothing else clobbers that location, you are safe to use it. This is why it might \"work\" in certain situations. That said, here are some of the things that could cause that to fail:</p>\n<ol>\n<li>Another variable might occupy the same space because once that variable is out of scope, another variable might take up the same space. This is similar to using memory that you have freed.</li>\n<li><p>The compiler may do a transformation on your code making the assumption that it is not relying on undefined behavior (which this is). This could, for example, manifest that the compiler simply optimizes out this line:</p>\n<p><code>pTest = &amp;x;</code></p></li>\n</ol>\n<p>The reason that the compiler may optimize out that particular line is that it concludes that any code that relies on reading that pointer from there on is relying on undefined behavior and so (ideally) the programmer knows this and wouldn't write code that depends on undefined behavior. The optimizer will then conclude that the most efficient solution is to nothing. That won't break any code that is not relying on undefined behavior.</p>\n", "LastActivityDate": "2017-02-09T05:53:00.760", "CommentCount": "0", "CreationDate": "2017-02-09T05:53:00.760", "ParentId": "42128911", "Score": "2", "OwnerUserId": "7520014"}, "42129251": {"Id": "42129251", "PostTypeId": "2", "Body": "<p>UPDATE: I found <a href=\"https://stackoverflow.com/questions/30694069/is-it-legal-to-compare-dangling-pointers\">this relevant question</a>. Thanks to the standard citations in there, I can say that there is indeed a paragraph causing the pointer value to become invalid when the object's lifetime ends. In addition, performing an lvalue-to-rvalue conversion on a pointer with an invalid value is implementation-defined behaviour.</p>\n<p>Thus, my below answer should ultimately be changed to implementation-defined. This means that your implementation is required to document what it will do when performing this lvalue-to-rvalue conversion, if that matters to you.</p>\n<hr>\n<h2>Old Answer</h2>\n<p>I believe this is okay by the standard if your definition of use means lvalue-to-rvalue conversion (e.g., printing the value, copying the value into another pointer, not dereferencing it\u00b9).</p>\n<blockquote>\n<p id=\"so_42128911_42129251_0\"><a href=\"http://eel.is/c++draft/conv.lval\" rel=\"nofollow noreferrer\">[cov.lval]</a>/3.3-3.4:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_42128911_42129251_5\">Otherwise, if the object to which the glvalue refers contains an invalid pointer value ([basic.stc.dynamic.deallocation],\n    [basic.stc.dynamic.safety]), the behavior is implementation-defined.</p></li>\n<li><p id=\"so_42128911_42129251_6\">Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p></li>\n</ul>\n</blockquote>\n<p id=\"so_42128911_42129251_3\"><a href=\"http://eel.is/c++draft/basic.stc.dynamic.safety\" rel=\"nofollow noreferrer\">[basic.stc.dynamic.safety]</a>/4:</p>\n<blockquote>\n<p id=\"so_42128911_42129251_7\">An implementation may have relaxed pointer safety, in which case the validity of a pointer value does not depend on whether it is a\n    safely-derived pointer value. Alternatively, an implementation may\n    have strict pointer safety, in which case a pointer value referring to\n    an object with dynamic storage duration that is not a safely-derived\n    pointer value is an invalid pointer value unless the referenced\n    complete object has previously been declared reachable\n    ([util.dynamic.safety]).</p>\n</blockquote>\n</blockquote>\n<p>So if we have strict pointer safety, it's still valid - this piece doesn't make it invalid because it doesn't refer to an object with dynamic storage duration.</p>\n<p>In short, I claim it's safe to use in the context of lvalue-to-rvalue conversions. If there is another paragraph in the standard making its value invalid because the referred-to object no longer exists, or some obscure trouble with \"the value contained in the object indicated by the glvalue\", I would love to see it.</p>\n<hr>\n<p>\u00b9: There's some great discussion in this general area <a href=\"https://stackoverflow.com/questions/7346634/dereferencing-an-invalid-pointer-then-taking-the-address-of-the-result\">here</a>. I simplified this part since most uses of <code>*p</code> would be undefined behaviour.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-09T06:35:39.400", "Score": "2", "CreationDate": "2017-02-09T05:56:15.447", "ParentId": "42128911", "CommentCount": "0", "OwnerUserId": "962089", "LastEditDate": "2017-05-23T11:45:23.923"}, "42128911": {"ViewCount": "82", "Body": "<p>Is it ok to use a pointer which point to the address of a variable declared inside \"if\" statement ?\nExample as below:</p>\n<pre><code>...\nint *pTest = 0;\nif (...)\n{\n  int x = 10;\n  pTest = &amp;x;\n}\nelse\n{\n  int x = 100;\n  pTest = &amp;x;\n}\n...\n// use pTest \n</code></pre>\n", "AcceptedAnswerId": "42128996", "Title": "Is it ok to use a pointer which point to the address of a variable declared inside \"if\" statement", "CreationDate": "2017-02-09T05:27:53.360", "Id": "42128911", "CommentCount": "10", "PostTypeId": "1", "LastActivityDate": "2017-02-09T09:01:37.030", "Score": "2", "OwnerUserId": "2719531", "Tags": "<c++><pointers><variables><if-statement><memory-address>", "AnswerCount": "4"}});