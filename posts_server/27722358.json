post_cb({"bq_ids": {"n4140": {"so_27722358_27732038_8": {"length": 7, "quality": 1.0, "section_id": 201}, "so_27722358_27722358_11": {"length": 4, "quality": 1.0, "section_id": 194}, "so_27722358_27732038_10": {"length": 7, "quality": 1.0, "section_id": 200}, "so_27722358_27722358_18": {"length": 22, "quality": 0.9565217391304348, "section_id": 204}, "so_27722358_27722358_13": {"length": 24, "quality": 1.0, "section_id": 195}, "so_27722358_27722358_5": {"length": 9, "quality": 1.0, "section_id": 206}, "so_27722358_27732038_1": {"length": 39, "quality": 0.9069767441860465, "section_id": 5891}, "so_27722358_27732455_1": {"length": 4, "quality": 1.0, "section_id": 194}, "so_27722358_27732038_3": {"length": 44, "quality": 0.9777777777777777, "section_id": 5949}, "so_27722358_27732455_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 209}, "so_27722358_27732455_4": {"length": 17, "quality": 1.0, "section_id": 194}, "so_27722358_27732455_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 204}, "so_27722358_27722358_7": {"length": 14, "quality": 1.0, "section_id": 5954}, "so_27722358_27722358_9": {"length": 4, "quality": 1.0, "section_id": 72}, "so_27722358_27722358_3": {"length": 10, "quality": 1.0, "section_id": 203}, "so_27722358_27722358_12": {"length": 8, "quality": 0.8888888888888888, "section_id": 195}, "so_27722358_27732455_2": {"length": 4, "quality": 1.0, "section_id": 194}, "so_27722358_27732038_12": {"length": 36, "quality": 0.9230769230769231, "section_id": 179}, "so_27722358_27732038_16": {"length": 13, "quality": 1.0, "section_id": 198}, "so_27722358_27722358_14": {"length": 6, "quality": 1.0, "section_id": 195}, "so_27722358_27732038_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 5951}}, "n3337": {"so_27722358_27732038_8": {"length": 7, "quality": 1.0, "section_id": 195}, "so_27722358_27722358_11": {"length": 4, "quality": 1.0, "section_id": 188}, "so_27722358_27722358_7": {"length": 14, "quality": 1.0, "section_id": 5724}, "so_27722358_27732455_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 198}, "so_27722358_27722358_18": {"length": 22, "quality": 0.9565217391304348, "section_id": 198}, "so_27722358_27722358_13": {"length": 24, "quality": 1.0, "section_id": 189}, "so_27722358_27722358_5": {"length": 9, "quality": 1.0, "section_id": 200}, "so_27722358_27732038_1": {"length": 39, "quality": 0.9069767441860465, "section_id": 5662}, "so_27722358_27732455_1": {"length": 4, "quality": 1.0, "section_id": 188}, "so_27722358_27732455_3": {"length": 6, "quality": 0.5454545454545454, "section_id": 67}, "so_27722358_27732455_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 188}, "so_27722358_27722358_12": {"length": 8, "quality": 0.8888888888888888, "section_id": 189}, "so_27722358_27722358_9": {"length": 4, "quality": 1.0, "section_id": 67}, "so_27722358_27722358_3": {"length": 10, "quality": 1.0, "section_id": 197}, "so_27722358_27732038_3": {"length": 44, "quality": 0.9777777777777777, "section_id": 5719}, "so_27722358_27732455_2": {"length": 4, "quality": 1.0, "section_id": 188}, "so_27722358_27732038_12": {"length": 36, "quality": 0.9230769230769231, "section_id": 173}, "so_27722358_27732038_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 5721}, "so_27722358_27732038_16": {"length": 13, "quality": 1.0, "section_id": 192}, "so_27722358_27722358_14": {"length": 6, "quality": 1.0, "section_id": 189}, "so_27722358_27732038_10": {"length": 7, "quality": 1.0, "section_id": 194}}, "n4659": {"so_27722358_27732038_8": {"length": 7, "quality": 1.0, "section_id": 207}, "so_27722358_27722358_11": {"length": 4, "quality": 1.0, "section_id": 74}, "so_27722358_27722358_7": {"length": 14, "quality": 1.0, "section_id": 7441}, "so_27722358_27732455_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 210}, "so_27722358_27722358_18": {"length": 22, "quality": 0.9565217391304348, "section_id": 210}, "so_27722358_27722358_13": {"length": 24, "quality": 1.0, "section_id": 201}, "so_27722358_27722358_5": {"length": 9, "quality": 1.0, "section_id": 214}, "so_27722358_27732038_1": {"length": 39, "quality": 0.9069767441860465, "section_id": 7374}, "so_27722358_27732455_1": {"length": 4, "quality": 1.0, "section_id": 74}, "so_27722358_27732455_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 217}, "so_27722358_27732455_4": {"length": 17, "quality": 1.0, "section_id": 200}, "so_27722358_27722358_12": {"length": 8, "quality": 0.8888888888888888, "section_id": 201}, "so_27722358_27722358_9": {"length": 4, "quality": 1.0, "section_id": 196}, "so_27722358_27722358_3": {"length": 10, "quality": 1.0, "section_id": 209}, "so_27722358_27732038_3": {"length": 43, "quality": 0.9555555555555556, "section_id": 7435}, "so_27722358_27732455_2": {"length": 4, "quality": 1.0, "section_id": 74}, "so_27722358_27732038_12": {"length": 36, "quality": 0.9230769230769231, "section_id": 184}, "so_27722358_27732038_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 7437}, "so_27722358_27732038_16": {"length": 13, "quality": 1.0, "section_id": 204}, "so_27722358_27722358_14": {"length": 6, "quality": 1.0, "section_id": 201}, "so_27722358_27732038_10": {"length": 7, "quality": 1.0, "section_id": 206}}}, "27722358": {"ViewCount": "416", "Body": "<p>Both gcc 5.0 and clang 3.6 require the <code>typename</code> keyword in the following example:</p>\n<pre><code>template&lt;int n&gt;\nstruct I\n{\n    typedef int Type;\n};\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    int m;\n\n    void f()\n    {\n        typedef typename I&lt;sizeof m&gt;::Type Type; // typename required\n    }\n};\n</code></pre>\n<p>This is covered by the following wording in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_27722358_27722358_0\">[temp.dep.type]/8</p>\n<p id=\"so_27722358_27722358_1\">A type is dependent if it is</p>\n<ul>\n<li>a simple-template-id in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent</li>\n</ul>\n</blockquote>\n<p>So <code>I&lt;sizeof m&gt;</code> is dependent if <code>sizeof m</code> is value-dependent.</p>\n<blockquote>\n<p id=\"so_27722358_27722358_2\">[temp.dep.expr]/4</p>\n<p id=\"so_27722358_27722358_3\">Expressions of the following forms are never type-dependent (because the type of the expression cannot be\n  dependent):</p>\n<pre><code>sizeof unary-expression\n</code></pre>\n<p id=\"so_27722358_27722358_4\">[temp.dep.constexpr]/2</p>\n<p id=\"so_27722358_27722358_5\">Expressions of the following form are value-dependent if the unary-expression or expression is typedependent\n  or the type-id is dependent:</p>\n<pre><code>sizeof unary-expression\n</code></pre>\n</blockquote>\n<p>So <code>sizeof m</code> is only dependent if <code>m</code> is dependent.</p>\n<blockquote>\n<p id=\"so_27722358_27722358_6\">[expr.prim.general]/8</p>\n<p id=\"so_27722358_27722358_7\">Within the\n  definition of a non-static member function, an identifier that names a non-static member is transformed to a\n  class member access expression</p>\n</blockquote>\n<p>So <code>m</code> is the member in a class member access expression.</p>\n<blockquote>\n<p id=\"so_27722358_27722358_8\">[temp.dep.type]/4</p>\n<p id=\"so_27722358_27722358_9\">A name is a <em>member of the current instantiation</em> if it is</p>\n<ul>\n<li>An id-expression denoting the member in a class member access expression (5.2.5) for which the type\n  of the object expression is the current instantiation, and the id-expression, when looked up (3.4.5),\n  refers to at least one member of the current instantiation or a non-dependent base class thereof.</li>\n</ul>\n</blockquote>\n<p>So it seems that <code>m</code> is a member of the current instantiation.</p>\n<blockquote>\n<p id=\"so_27722358_27722358_10\">[temp.dep.type]/5</p>\n<p id=\"so_27722358_27722358_11\">A name is a member of an unknown specialization if it is</p>\n<ul>\n<li><p id=\"so_27722358_27722358_12\">An id-expression denoting the member in a class member access expression (5.2.5) in which either</p>\n<ul>\n<li><p id=\"so_27722358_27722358_13\">the type of the object expression is the current instantiation, the current instantiation has at least\n  one dependent base class, and name lookup of the id-expression does not find a member of the\n  current instantiation or a non-dependent base class thereof; or</p></li>\n<li><p id=\"so_27722358_27722358_14\">the type of the object expression is dependent and is not the current instantiation.</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So <code>m</code> is NOT a member of an unknown specialization - it would be found by name lookup to be a member of the current instantiation.</p>\n<blockquote>\n<p id=\"so_27722358_27722358_15\">[temp.dep.expr]/3</p>\n<p id=\"so_27722358_27722358_16\">An id-expression is type-dependent if it contains</p>\n<ul>\n<li>an identifier associated by name lookup with one or more declarations declared with a dependent type,</li>\n<li>a nested-name-specifier or a qualified-id that names a member of an unknown specialization</li>\n</ul>\n</blockquote>\n<p>Since <code>m</code> is of type <code>int</code> and is not a member of an unknown specialization, neither of these bullets would make the id-expression <code>m</code> dependent.</p>\n<blockquote>\n<p id=\"so_27722358_27722358_17\">[temp.dep.expr]/5</p>\n<p id=\"so_27722358_27722358_18\">A class member access expression (5.2.5) is type-dependent if the expression refers to a member of the current\n  instantiation and the type of the referenced member is dependent, or the class member access expression\n  refers to a member of an unknown specialization.</p>\n</blockquote>\n<p>When <code>m</code> is transformed to a class member access expression, it is still not dependent because it does not refer to a member of an unknown specialization.</p>\n<p>Should <code>m</code> be treated as dependent? On a related note, should <code>this-&gt;m</code> be treated as dependent? What about <code>std::declval&lt;A&gt;().m</code> ?</p>\n<p><strong>EDIT</strong></p>\n<p>And finally, should <code>&amp;A::m</code> be dependent?</p>\n", "Title": "Is the name of a non-static-member dependent when used within a non-static member function?", "CreationDate": "2014-12-31T14:18:32.983", "LastActivityDate": "2015-02-21T14:42:27.133", "CommentCount": "17", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-01-01T19:06:14.607", "LastEditorUserId": "1690864", "Id": "27722358", "Score": "15", "OwnerUserId": "1690864", "Tags": "<c++><templates><c++11><language-lawyer><dependent-type>", "AnswerCount": "2"}, "27732038": {"Id": "27732038", "PostTypeId": "2", "Body": "<p>The answer hinges on whether <code>m</code> can be looked up to determine that it is a member of the current instantiation. The id-expression <code>m</code> is transformed to a class member access <code>(*this).m</code>, meaning that the rules for qualified name lookup within a class member access are applicable.</p>\n<p>In general, the type of a type-dependent expression cannot be determined. It's not completely clear whether an exception should be made for <code>(*this).</code> and <code>this-&gt;</code>. An expression containing <code>this</code> is type-dependent, but both <code>(*this).</code> and <code>this-&gt;</code> unambiguously name the current instantiation.</p>\n<h2><code>m</code></h2>\n<p>The expression <code>m</code> is indeed not type-dependent, because it refers to a member of the current instantiation.</p>\n<p>In the context of a non-static member, <code>m</code> is transformed into the class member access expression <code>(*this).m</code>.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_0\">[class.mfct.non-static]/3</p>\n<p id=\"so_27722358_27732038_1\">When an id-expression (5.1) that is not part of a class member access syntax (5.2.5) and not used to form a pointer to member (5.3.1) is used in a member of class <code>X</code> in a context where this can be used (5.1.1), if name lookup (3.4) resolves the name in the id-expression to a non-static non-type member of some class <code>C</code>, and if either the id-expression is potentially evaluated or <code>C</code> is <code>X</code> or a base class of <code>X</code>, the id-expression is transformed into a class member access expression (5.2.5) using <code>(*this)</code></p>\n</blockquote>\n<p>The transformation occurs because <code>m</code> is a member of class <code>A</code> used within a non-static-member of class <code>A</code>.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_2\">[expr.prim.general]/3</p>\n<p id=\"so_27722358_27732038_3\">If a declaration declares a member function or member function template of a class <code>X, the expression</code>this`\n  is a prvalue of type \u201cpointer to cv-qualifier-seq X\u201d between the optional cv-qualifer-seq and the end of the\n  function-definition, member-declarator, or declarator. It shall not appear before the optional cv-qualifier-seq\n  and it shall not appear within the declaration of a static member function (although its type and value\n  category are defined within a static member function as they are within a non-static member function).</p>\n<p id=\"so_27722358_27732038_4\">[expr.prim.general]/5</p>\n<p id=\"so_27722358_27732038_5\">The expression <code>this</code> shall not appear in any other context. [ Example:</p>\n</blockquote>\n<pre><code>class Outer {\n    int a[sizeof(*this)]; // error: not inside a member function\n    unsigned int sz = sizeof(*this); // OK: in brace-or-equal-initializer\n\n    void f() {\n        int b[sizeof(*this)]; // OK\n\n        struct Inner {\n            int c[sizeof(*this)]; // error: not inside a member function of Inner\n        };\n    }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_27722358_27732038_6\">\u2014end example ]</p>\n</blockquote>\n<p>The above example explicitly permits use of <code>this</code> within a <code>sizeof</code> expression within a non-static member.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_7\">[temp.dep.expr]/2</p>\n<p id=\"so_27722358_27732038_8\"><code>this</code> is type-dependent if the class type of the enclosing member function is dependent</p>\n</blockquote>\n<p>Therefore <code>this</code> is type-dependent within the definition of a member function of a class template.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_9\">[temp.dep.expr]/1</p>\n<p id=\"so_27722358_27732038_10\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n</blockquote>\n<p>However, the above is overruled by the exception in [temp.dep.expr]/5 quoted in the question.</p>\n<h2><code>this-&gt;m</code></h2>\n<p>The expression <code>this-&gt;m</code> is also not type-dependent, because it is also a class member access expression which refers to a member of the current instantiation.</p>\n<h2><code>std::declval&lt;A&gt;().m</code></h2>\n<p>The expression <code>std::declval&lt;A&gt;().m</code> has to be type-dependent, as the return type of <code>std::declval&lt;A&gt;()</code> could depend on the type of <code>A</code>.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_11\">[temp.local]/1</p>\n<p id=\"so_27722358_27732038_12\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injectedclass-\n  name can be used as a template-name or a type-name. When it is used with a template-argument-list,\n  as a template-argument for a template template-parameter, or as the final identifier in the elaborated-typespecifier\n  of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent\n  to the template-name followed by the template-parameters of the class template enclosed in <code>&lt;&gt;</code></p>\n</blockquote>\n<p>Therefore <code>A</code> is transformed to <code>A&lt;T&gt;</code>.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_13\">[temp.dep.type]/8</p>\n<p id=\"so_27722358_27732038_14\">A type is dependent if it is</p>\n<ul>\n<li><p id=\"so_27722358_27732038_15\">a template parameter,</p></li>\n<li><p id=\"so_27722358_27732038_16\">a simple-template-id in which either the template name is a template parameter or any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent</p></li>\n</ul>\n</blockquote>\n<p>This confirms that <code>A&lt;T&gt;</code> is a dependent type, meaning that <code>A</code> is also dependent.</p>\n<blockquote>\n<p id=\"so_27722358_27732038_17\">[temp.dep.expr]/3</p>\n<p id=\"so_27722358_27732038_18\">An id-expression is type-dependent if it contains</p>\n<ul>\n<li>a template-id that is dependent,</li>\n</ul>\n</blockquote>\n<p>So <code>std::declval&lt;A&gt;</code> is a type-dependent expression. It follows that <code>std::declval&lt;A&gt;().m</code> is type-dependent because it contains the type-dependent subexpression <code>std::declval&lt;A&gt;</code>.</p>\n<h2><code>&amp;A::m</code></h2>\n<p>The expression <code>&amp;A::m</code> logically has to be type-dependent because it has the type <code>int A&lt;T&gt;::*</code> which is a dependent type.</p>\n<p>The expression <code>&amp;A::m</code> is transformed to <code>&amp;A&lt;T&gt;::m</code> because <code>A</code> is the injected class name - as shown above.</p>\n<p>The id-expression <code>A&lt;T&gt;::m</code> is type-dependent according to [temp.dep.expr]/3 because it contains a template-id <code>A&lt;T&gt;</code> that is dependent. Therefore the expression <code>&amp;A&lt;T&gt;::m</code> is type-dependent according to [temp.dep.expr]/1.</p>\n<h2><code>A::m</code></h2>\n<p>The expression <code>A::m</code> is transformed to <code>A&lt;T&gt;::m</code> because <code>A</code> is the injected class name - as shown above. The expression <code>A&lt;T&gt;::m</code> is further transformed to <code>(*this).A&lt;T&gt;::m</code> because <code>A&lt;T&gt;::m</code> names a non-static member of <code>A</code>.</p>\n<p>The id-expression <code>A&lt;T&gt;::m</code> is type-dependent according to [temp.dep.expr]/3 because it contains a template-id <code>A&lt;T&gt;</code> that is dependent. The class member access expression <code>(*this).A&lt;T&gt;::m</code> refers to a member of the current instantiation, so [temp.dep.expr]/5 applies but does not make the expression type-dependent - nor does it contradict [temp.dep.expr]/3.</p>\n<h2>Defect?</h2>\n<p>Given the interpretation above, an id-expression naming a member of <code>A</code> qualified with <code>A</code> or <code>A&lt;T&gt;</code> would become type-dependent, which seems unnecessary and inconsistent. Consider that a type-name qualified with <code>A</code> or <code>A&lt;T&gt;</code> would not be dependent in the same context.</p>\n<p>If the intention of [temp.dep.expr]/5 is that <code>(*this).m</code> is not type-dependent, then it follows that <code>(*this).A&lt;T&gt;::m</code> should also not be type-dependent. On the other hand, the intention could be that the name of a non-static member is always dependent. I've posted a question to std-discussion to clarify this point: <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/gEvZ7mmXEC8\" rel=\"nofollow\">https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/gEvZ7mmXEC8</a></p>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2015-01-02T12:30:32.807", "Score": "1", "CreationDate": "2015-01-01T15:26:16.310", "ParentId": "27722358", "CommentCount": "4", "OwnerUserId": "1690864", "LastEditDate": "2015-01-02T12:30:32.807"}, "27732455": {"Id": "27732455", "PostTypeId": "2", "Body": "<p>As correctly stated by you, <code>sizeof m</code> is transformed into <code>sizeof (*this).m</code>.<br>\n<code>sizeof</code> is dependent only if the argument expression is type-dependent, which it isn't, according to [temp.dep.expr]/5:</br></p>\n<blockquote>\n<p id=\"so_27722358_27732455_0\">A class member access expression (5.2.5) is type-dependent if the\n  expression refers to a member of the current instantiation and the\n  type of the referenced member is dependent, or the class member access\n  expression refers to a member of an unknown specialization.</p>\n</blockquote>\n<p>The type of <code>m</code> is not dependent, and the expression does not refer to a member of an unknown specialization either - [temp.dep.type]/6:</p>\n<blockquote>\n<p id=\"so_27722358_27732455_1\">A name is a member of an unknown specialization if it is</p>\n<ul>\n<li>An <em>id-expression</em> denoting the member in a class member access expression (5.2.5) in which either\n  <ul>\n<li>the type of the object expression is the current instantiation, the current instantiation has at least one dependent base class, and\n  name lookup of the <em>id-expression</em> does not find a member of a class\n  that is the current instantiation or a non-dependent base class\n  thereof; or</li>\n<li>the type of the object expression is dependent and is not the current instantiation.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Even though the type of <code>(*this)</code> is dependent, it is the current instantiation. And name lookup should find <code>m</code> to be a member of the current instantiation.  </p>\n<p>So <code>*this</code> isn't type-dependent and thus <code>sizeof (*this).m</code> isn't dependent. (<code>sizeof m</code> is also not dependent outside any non-static data member initializer of function definition, which I accidentally covered in my second, deleted answer).</p>\n<hr>\n<p>For <code>sizeof std::declval&lt;A&gt;().m</code> to be dependent, <code>std::declval&lt;A&gt;().m</code> must be type-dependent.<br>\n<code>std::declval&lt;A&gt;().m</code> <em>seems</em> to be type-dependent, but I'm not certain. As specified in [temp.dep.expr]/5 which I quoted above, the only possibility is that <code>m</code> in the expression is a member of an unknown specialization, which we have to show it is.</br></p>\n<blockquote>\n<p id=\"so_27722358_27732455_2\">A name is a member of an unknown specialization if it is</p>\n<ul>\n<li>An <em>id-expression</em> denoting the member in a class member access expression (5.2.5) in which either\n  <ul>\n<li>the type of the object expression is the current instantiation, the current instantiation has at least one dependent base class, and\n  name lookup of the id-expression does not find a member of a class\n  that is the current instantiation or a non-dependent base class\n  thereof; or</li>\n<li><strong>the type of the object expression is dependent and is not the current instantiation.</strong></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Here are the facts:</p>\n<ul>\n<li><p>The object expression <code>std::declval&lt;A&gt;()</code> is type-dependent.</p></li>\n<li><p>The lookup of <code>std::declval&lt;A&gt;</code> is only done in the definition context since it is a <em>qualified-id</em>, which are never <em>dependent names</em> ([temp.dep]/1).</p></li>\n</ul>\n<p>There is exactly one <code>declval</code> function template found by qualified name lookup, but we cannot know if the return type of that candidate is the current instantiation at  definition time. Here in particular, <code>add_rvalue_reference</code> might have specializations not known at definition time (A scenario similar to <a href=\"http://coliru.stacked-crooked.com/a/6e935cca8c4417ef/\" rel=\"nofollow\"><strong>this one</strong></a>). So because we do not know whether <code>std::declval&lt;A&gt;()</code> is the current instantiation, (we assume) it isn't, which makes the whole expression type-dependent.</p>\n<hr>\n<p><code>&amp;A::m</code> is of the form <code>&amp;</code><em>qualified-id</em>, which is covered by [temp.dep.constexpr]/5:</p>\n<blockquote>\n<p id=\"so_27722358_27732455_3\">An expression of the form <code>&amp;</code><em>qualified-id</em> where the <em>qualified-id</em>\n  names a dependent member of the current instantiation is\n  value-dependent.</p>\n</blockquote>\n<p>[temp.dep.type]/5:</p>\n<blockquote>\n<p id=\"so_27722358_27732455_4\">A name is a <em>dependent member of the current instantiation</em> if it is a\n  member of the current instantiation that, when looked up, refers to at\n  least one member of a class that is the current instantiation.</p>\n</blockquote>\n<p>Clearly <code>A::m</code> is a member of the current instantiation, thus <code>&amp;A::m</code> is value-dependent.<br>\nAlso <code>&amp;A::m</code> is type-dependent: The subexpression <code>A</code> is equivalent to <code>A&lt;T&gt;</code> according to [temp.local], which is a <em>simple-template-id</em> with dependent template arguments.</br></p>\n</hr></hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-01T19:26:55.890", "Score": "2", "CreationDate": "2015-01-01T16:20:18.277", "ParentId": "27722358", "CommentCount": "10", "OwnerUserId": "3647361", "LastEditDate": "2015-01-01T19:26:55.890"}});