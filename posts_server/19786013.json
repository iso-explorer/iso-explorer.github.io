post_cb({"19786109": {"ParentId": "19786013", "CommentCount": "0", "Body": "<p>The compiler is free to add padding and reorganize the struct how it sees fit. Especially in C++ you can add (virtual) functions and then chances are that the virtual table is hidden before that. But of course that are implementation details.\nFor C this assumption is valid.</p>\n", "OwnerUserId": "2282011", "PostTypeId": "2", "Id": "19786109", "Score": "0", "CreationDate": "2013-11-05T09:56:13.450", "LastActivityDate": "2013-11-05T09:56:13.450"}, "19786013": {"CommentCount": "14", "ViewCount": "597", "PostTypeId": "1", "LastEditorUserId": "1790722", "CreationDate": "2013-11-05T09:51:04.537", "LastActivityDate": "2013-11-05T11:11:06.077", "Title": "C/C++ Pointer to a POD struct also points to the 1st struct member", "AcceptedAnswerId": "19786321", "LastEditDate": "2013-11-05T11:11:06.077", "Id": "19786013", "Score": "1", "Body": "<p>Can I assume that a C/C++ struct pointer will always point to the first member?\n<br>\nExample 1:</br></p>\n<pre><code>typedef struct {\n unsigned char  array_a[2];\n unsigned char  array_b[5];\n}test;\n//..\ntest var;\n//..\n</code></pre>\n<p>In the above example will &amp;var always point to array_a?\nAlso in the above example is it possible to cast the pointer\nto an unsigned char pointer and access each byte separately?\n<br>\nExample 2:</br></p>\n<pre><code>function((unsigned char *)&amp;var,sizeof(test));\n//...\n//...\nvoid function(unsigned char *array, int len){\n int i;\n for( i=0; i&lt;len; i++){\n    array[i]++;\n }\n}\n</code></pre>\n<p>Will that work correctly?</p>\n<p>Note: I know that chars are byte aligned in a struct therefore I assume the size of the above struct is 7 bytes.</p>\n", "Tags": "<c++><c><pointers><struct>", "OwnerUserId": "1790722", "AnswerCount": "4"}, "19786321": {"ParentId": "19786013", "LastEditDate": "2013-11-05T10:15:43.840", "CommentCount": "2", "CreationDate": "2013-11-05T10:06:24.923", "OwnerUserId": "2797826", "LastEditorUserId": "2797826", "PostTypeId": "2", "Id": "19786321", "Score": "6", "Body": "<p>For C structs, yes, you can rely on it. This is how almost all \"object orientated\"-style APIs work in C (such as GObject and GTK).</p>\n<p>For C++, you can rely on it only for \"plain old data\" (POD) types, which are guaranteed to be laid out in memory the same way as C structs. Exactly what constitutes a POD type is a little complicated and has changed between C++03 and C++11, but the crux of it is that if your type has any virtual functions then it's not a POD.</p>\n<p>(In C++11 you can use <code>std::is_pod</code> to test at compile-time whether a struct is a POD type.)</p>\n<p>EDIT: This tells you what constitutes a POD type in C++: <a href=\"http://en.cppreference.com/w/cpp/concept/PODType\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/concept/PODType</a></p>\n<p>EDIT2: Actually, in C++11, it doesn't need to be a POD, just \"standard layout\", which is a lightly weaker condition. Quoth section 9.2 [class.mem] paragraph 20 of the standard:</p>\n<blockquote>\n<p id=\"so_19786013_19786321_0\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its\n  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:\n  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,\n  as necessary to achieve appropriate alignment. \u2014 end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-11-05T10:15:43.840"}, "19786207": {"ParentId": "19786013", "CommentCount": "0", "Body": "<p>For C, it's largely implementation-specific, but in practice the rule (in the absence of #pragma pack or something likewise) is:</p>\n<ul>\n<li>Struct members are stored in the order they are declared. (This is required by the C99 standard, as mentioned here earlier.)</li>\n<li>If necessary, padding is added before each struct member, to ensure correct alignment.</li>\n</ul>\n<p>So given a struct like</p>\n<pre><code>struct test{\nchar ch;\nint i;\n}\n</code></pre>\n<p>will have ch at offset 0, then a padding byte to align, i at offset 2 and then at the end, padding bytes are added to make the struct size a multiple of 8 bytes.(on a 64-bit machine,  4 byte alignment may be permitted in 32 bit machines)</p>\n<p>So at least in this case, for C, I think you can assume that the struct pointer will point to the first array.</p>\n", "OwnerUserId": "2653187", "PostTypeId": "2", "Id": "19786207", "Score": "0", "CreationDate": "2013-11-05T09:59:58.887", "LastActivityDate": "2013-11-05T09:59:58.887"}, "19786085": {"ParentId": "19786013", "LastEditDate": "2013-11-05T10:01:23.997", "CommentCount": "1", "CreationDate": "2013-11-05T09:55:02.657", "OwnerUserId": "1189215", "LastEditorUserId": "1956352", "PostTypeId": "2", "Id": "19786085", "Score": "6", "Body": "<p>From the C99 standard section 6.7.2.1 bullet point 13:</p>\n<blockquote>\n<p id=\"so_19786013_19786085_0\">Within a structure object, the non-bit-field members and the units in\n  which bit-fields reside have addresses that increase in the order in\n  which they are declared. A pointer to a structure object, suitably\n  converted, points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides), and vice versa.\n  There may be unnamed padding within a structure object, but not at its\n  beginning.</p>\n</blockquote>\n<p>The answer to your question is therefore yes.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\" rel=\"nofollow\">Reference</a> (see page 103)</p>\n", "LastActivityDate": "2013-11-05T10:01:23.997"}, "bq_ids": {"n4140": {"so_19786013_19786321_0": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}}, "n3337": {"so_19786013_19786085_0": {"section_id": 5650, "quality": 0.575, "length": 23}, "so_19786013_19786321_0": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_19786013_19786321_0": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}}}});