post_cb({"bq_ids": {"n4140": {"so_29468724_29470096_0": {"length": 11, "quality": 1.0, "section_id": 175}}, "n3337": {"so_29468724_29470096_0": {"length": 11, "quality": 1.0, "section_id": 169}}, "n4659": {"so_29468724_29470096_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 180}}}, "29468724": {"ViewCount": "394", "Body": "<p>I am trying to get static_assert to help me avoid null pointers in C++11.</p>\n<p>The problem seems to be that C++11 require the compiler to compile templates even if they are not instantiated.</p>\n<p>I have the following code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T, typename... Us&gt;\nstd::enable_if_t&lt; std::is_constructible&lt;T, Us...&gt;::value == true, T * &gt;\ncreate_if_constructible(Us... args) { return new T(args...); }\n\ntemplate&lt;typename T, typename... Us&gt;\nstd::enable_if_t&lt; std::is_constructible&lt;T, Us...&gt;::value == false, T * &gt;\ncreate_if_constructible(Us... args) { \n   static_assert( false, \"Class T constructor does not match argument list.\");\n   return nullptr; \n}\n\nstruct ClassA {\n   ClassA(int a, string b) {}\n};\n\nvoid foo() {\n   ClassA *a = create_if_constructible&lt;ClassA&gt;(1, \"Hello\");\n   // ClassA *b = create_if_constructible&lt;ClassA&gt;(1, \"Hello\", \"world\"); // I want compile time error here.\n}\n</code></pre>\n<p>I would like this to compile without error. But the static_assert is compiled and gives me a compile time error.</p>\n<p>Only if the the second instantiation of the ClassA is in the code should it give me a compile time error. </p>\n", "AcceptedAnswerId": "29470096", "Title": "Conditional compilation of templates", "CreationDate": "2015-04-06T09:40:30.347", "Id": "29468724", "CommentCount": "12", "PostTypeId": "1", "LastActivityDate": "2015-04-06T19:34:01.453", "Score": "0", "OwnerUserId": "2099460", "Tags": "<c++><c++11><static-assert>", "AnswerCount": "2"}, "29469892": {"Id": "29469892", "PostTypeId": "2", "Body": "<p>In all C++ standards ever, templates are compiled in two phases. The second phase is instantiation, but compilation can also fail in phase 1. In particular, syntax errors are detected in phase 1.</p>\n<p>In your case, the simpler solution is to leave out the body of the second instantiation.</p>\n<p>Another solution is to use <code>T</code> in the <code>static_assert</code>, so the compiler must delay evaluation to phase 2. Trivially: <code>static_assert(sizeof(T)==0,</code></p>\n", "LastActivityDate": "2015-04-06T10:57:13.627", "Score": "0", "CreationDate": "2015-04-06T10:57:13.627", "ParentId": "29468724", "CommentCount": "9", "OwnerUserId": "15416"}, "29470096": {"Id": "29470096", "PostTypeId": "2", "Body": "<p>The standard permits, but does not require, compilers to diagnose templates for which no valid instantiation can be generated. This can range from simple syntax errors to your example of a constant <code>false</code> expression in a <code>static_assert</code>. \u00a714.6 [temp.res]/p8:</p>\n<blockquote>\n<p id=\"so_29468724_29470096_0\">If no valid specialization can be generated for a template, and that\n  template is not instantiated, the template is ill-formed, no\n  diagnostic required.</p>\n</blockquote>\n<p>I'm rather baffled by all this SFINAE machinery, though. A simple</p>\n<pre><code>template&lt;typename T, typename... Us&gt;\nT* create_if_constructible(Us... args) { return new T(args...); }\n</code></pre>\n<p>already refuses to compile if <code>T</code> is not constructible from the parameter given, so I'm not sure how this complex circumlocution will help you \"avoid null pointers\".</p>\n<p>Regardless, a simple way to make choosing the second function template a compile-time error is to explicitly delete it.</p>\n<pre><code>template&lt;typename T, typename... Us&gt;\nstd::enable_if_t&lt; std::is_constructible&lt;T, Us...&gt;::value == false, T * &gt;\ncreate_if_constructible(Us... args) = delete;\n</code></pre>\n<p>Alternatively, if you are partial to <code>static_assert</code>s, perhaps because of the custom error message, you must ensure that there is theoretically a way to generate a valid instantiation of your template. That means that 1) what you are <code>static_assert</code>ing on must depend on a template argument, and 2) there must be theoretically a way for the condition to be <code>true</code>. A simple way is to use an auxiliary template:</p>\n<pre><code>template&lt;class&gt; class always_false : std::false_type {};\n\ntemplate&lt;typename T, typename... Us&gt;\nstd::enable_if_t&lt; std::is_constructible&lt;T, Us...&gt;::value == false, T * &gt;\ncreate_if_constructible(Us... args) { \n   static_assert( always_false&lt;T&gt;::value, \"Class T constructor does not match argument list.\");\n   return nullptr; \n}\n</code></pre>\n<p>The key point here is that the compiler cannot assume that <code>always_false&lt;T&gt;::value</code> is always <code>false</code> because it is always possible that there's a specialization later that sets it to <code>true</code>, and so it is not allowed to reject this at template definition time.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-04-06T19:34:01.453", "Score": "3", "CreationDate": "2015-04-06T11:09:56.817", "ParentId": "29468724", "CommentCount": "2", "LastEditDate": "2015-04-06T19:34:01.453", "OwnerUserId": "2756719"}});