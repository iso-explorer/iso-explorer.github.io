post_cb({"bq_ids": {"n4140": {"so_28717682_28718438_4": {"length": 4, "quality": 0.5714285714285714, "section_id": 91}, "so_28717682_28718438_2": {"length": 27, "quality": 0.9, "section_id": 3325}, "so_28717682_28718438_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 382}, "so_28717682_28718438_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_28717682_28718438_3": {"length": 7, "quality": 1.0, "section_id": 3288}}, "n3337": {"so_28717682_28718438_4": {"length": 4, "quality": 0.5714285714285714, "section_id": 86}, "so_28717682_28718438_3": {"length": 7, "quality": 1.0, "section_id": 3158}, "so_28717682_28718438_2": {"length": 21, "quality": 0.7, "section_id": 3195}, "so_28717682_28718438_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_28717682_28718438_5": {"length": 10, "quality": 0.9090909090909091, "section_id": 373}}, "n4659": {"so_28717682_28718438_4": {"length": 7, "quality": 1.0, "section_id": 453}, "so_28717682_28718438_3": {"length": 7, "quality": 1.0, "section_id": 4050}, "so_28717682_28718438_2": {"length": 21, "quality": 0.7, "section_id": 4091}, "so_28717682_28718438_0": {"length": 6, "quality": 1.0, "section_id": 4091}}}, "28718438": {"Id": "28718438", "PostTypeId": "2", "Body": "<p>GCC is correct in its interpretation of <code>{}</code>. [dcl.init.list]/p3.8-9 (quoting N4296; earlier drafts has the same relative ordering of these two bullets):</p>\n<blockquote>\n<p id=\"so_28717682_28718438_0\">List-initialization of an object or reference of type <code>T</code> is defined as\n  follows:</p>\n<ul>\n<li><p id=\"so_28717682_28718438_1\">[7 inapplicable bullets omitted]</p></li>\n<li><p id=\"so_28717682_28718438_2\">Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code> is copy-list-initialized or\n  direct-list-initialized, depending on the kind of initialization for\n  the reference, and the reference is bound to that temporary. [ <em>Note</em>:\n  As usual, the binding will fail and the program is ill-formed if the\n  reference type is an lvalue reference to a non-const type. \u2014<em>end note</em>\n  ]</p></li>\n<li>Otherwise, if the initializer list has no elements, the object is value-initialized.</li>\n</ul>\n</blockquote>\n<p>List-initializing the reference hits bullet 3.8, causing the construction of a temporary. The value-initialization case, in 3.9, doesn't apply.</p>\n<p>Value-initialization of a reference is ill-formed ([dcl.init]/p9):</p>\n<blockquote>\n<p id=\"so_28717682_28718438_3\">A program that calls for default-initialization or\n  value-initialization of an entity of reference type is ill-formed.</p>\n</blockquote>\n<hr>\n<p>However, as of N4296, per [class.base.init]/p8:</p>\n<blockquote>\n<p id=\"so_28717682_28718438_4\">A temporary expression bound to a reference member in a\n  <em>mem-initializer</em> is ill-formed.</p>\n</blockquote>\n<p>This was added as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4305.html#1696\" rel=\"nofollow\">CWG issue 1696</a>, which is a DR (defect report) against C++14.</p>\n<p>Pre-CWG1696, the standard provided that (N4140 [class.temporary]/p5.1):</p>\n<blockquote>\n<p id=\"so_28717682_28718438_5\">A temporary bound to a reference member in a constructor\u2019s\n  <em>ctor-initializer</em> (12.6.2) persists until the constructor exits.</p>\n</blockquote>\n<p>which means that the reference will become dangling immediately after construction. This presumably motivated CWG1696's decision to disallow such bindings altogether.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2015-02-25T12:30:12.000", "Score": "6", "CreationDate": "2015-02-25T11:57:35.377", "ParentId": "28717682", "CommentCount": "6", "OwnerUserId": "2756719", "LastEditDate": "2015-02-25T12:30:12.000"}, "28717682": {"ViewCount": "710", "Body": "<p>I was playing with some useless code to understand initialization of member references, and bumped into this:</p>\n<pre><code>struct A {};\n\nstruct B\n{\n    B() : a()\n    {\n    }\n\n    const A&amp; a;\n};\n</code></pre>\n<p>The code above gives the following error when compiled with gcc 4.9.2:</p>\n<pre><code>In constructor 'B::B()':\nerror: value-initialization of reference type 'const A&amp;'\n  B() : a()\n</code></pre>\n<p>Which I understand.</p>\n<p>But if I use uniform initialization in B's constructor's initializer list, like so:</p>\n<pre><code>struct A {};\n\nstruct B\n{\n    B() : a{}\n    {\n    }\n\n    const A&amp; a;\n};\n</code></pre>\n<p>It compiles fine.</p>\n<p>So the question is, why does the use of uniform initialization here change the compilation result?</p>\n<p>I also tried this with Microsoft Visual C++ 2013.\nIt does not compile either version of the code, with the same error message:</p>\n<pre><code>Error 3 error C2440: 'initializing' : cannot convert from 'int' to 'const A &amp; \n</code></pre>\n<p>You can have a quick play with it here:</p>\n<p><a href=\"http://ideone.com/7f2t8I\" rel=\"noreferrer\">http://ideone.com/7f2t8I</a></p>\n", "AcceptedAnswerId": "28718438", "Title": "Initialization of const reference member in initializer list", "CreationDate": "2015-02-25T11:20:03.717", "Id": "28717682", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-02-25T11:43:48.427", "LastEditorUserId": "592323", "LastActivityDate": "2015-02-25T12:30:12.000", "Score": "9", "OwnerUserId": "4605289", "Tags": "<c++><gcc><reference><initialization><initializer-list>", "AnswerCount": "1"}});