post_cb({"31700442": {"Id": "31700442", "PostTypeId": "2", "Body": "<p>No, it not allowed by the standard. From [temp.param]:</p>\n<blockquote>\n<p id=\"so_31697055_31700442_0\">A template parameter pack of a function template shall not be followed\n  by another template parameter unless that template parameter can be deduced from the <em>parameter-type-list</em>\n  of the function template or has a default argument (14.8.2). <em>[Example:</em></p>\n<pre><code>template&lt;class T1 = int, class T2&gt; class B;    // error\n\n// U can be neither deduced from the parameter-type-list nor specified\ntemplate&lt;class... T, class... U&gt; void f() { }  // error\ntemplate&lt;class... T, class U&gt; void g() { }     // error\n</code></pre>\n<p id=\"so_31697055_31700442_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>In your case, <code>...B</code> cannot be deduced (as there's nothing to deduce it from) and it has no default argument. </p>\n<blockquote>\n<p id=\"so_31697055_31700442_2\">so what exactly needs to be deduced for the packs (just the type, or the values, too)?</p>\n</blockquote>\n<p>For example, if your <code>foo</code> was:</p>\n<pre><code>template &lt;size_t... A, size_t... B&gt;\nvoid foo(std::index_sequence&lt;B...&gt; );\n</code></pre>\n<p><code>...A</code> is followed by <code>...B</code>, but <code>...B</code> can be deduced, so that's allowed. Similarly:</p>\n<pre><code>template &lt;typename T, T... A, T B = 0&gt;\nvoid foo();\n</code></pre>\n<p>is fine, as <code>B</code> has a default argument. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-29T12:46:14.757", "Score": "2", "CreationDate": "2015-07-29T12:30:13.640", "ParentId": "31697055", "CommentCount": "0", "LastEditDate": "2015-07-29T12:46:14.757", "OwnerUserId": "2069064"}, "31697055": {"ViewCount": "384", "Body": "<p>[temp.param] p11 says (in N4527):</p>\n<blockquote>\n<p id=\"so_31697055_31697055_0\">(...) A template parameter pack of a function template shall not be followed by another template parameter unless that template parameter can be deduced from the parameter-type-list of the function template or has a default argument</p>\n</blockquote>\n<p>In the context of <em>non-type</em> template parameter packs, there can't be default arguments,<br>\nso what exactly needs to be deduced for the packs (just the type, or the values, too)? </br></p>\n<p>i.e. I'm wondering if this is allowed by the standard (C++11, 14 or 1z):</p>\n<pre><code>template&lt;typename T, T... A, T... B&gt;\nvoid foo(T) {}\n</code></pre>\n<p>The first pack's values could be explicitly specified, but the second pack is \"unreachable\" and would always be empty if I'm not mistaken.</p>\n<p>clang++-3.6 and g++-5.2 seem to accept these empty unreachable packs (even non non-type packs), but VC++ 14.0 refuses them with the error:</p>\n<blockquote>\n<p id=\"so_31697055_31697055_1\">error C3547: template parameter 'B' cannot be used because it follows a template parameter pack and cannot be deduced from the function parameters of 'foo'</p>\n</blockquote>\n", "AcceptedAnswerId": "31700442", "Title": "Are multiple non-type template parameter packs allowed?", "CreationDate": "2015-07-29T09:54:41.303", "Id": "31697055", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2015-07-29T12:46:14.757", "Score": "2", "OwnerUserId": "996886", "Tags": "<c++><templates><c++11><language-lawyer>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31697055_31697055_0": {"length": 18, "quality": 1.0, "section_id": 64}, "so_31697055_31700442_0": {"length": 18, "quality": 0.9, "section_id": 64}}, "n3337": {"so_31697055_31697055_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 59}, "so_31697055_31700442_0": {"length": 15, "quality": 0.75, "section_id": 59}}, "n4659": {"so_31697055_31697055_0": {"length": 18, "quality": 1.0, "section_id": 66}, "so_31697055_31700442_0": {"length": 18, "quality": 0.9, "section_id": 66}}}});