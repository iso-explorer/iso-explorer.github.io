post_cb({"3263919": {"ParentId": "3263873", "CommentCount": "0", "Body": "<p>Volatile forces the variable to be read from memory each time instead of caching it.</p>\n", "OwnerUserId": "134098", "PostTypeId": "2", "Id": "3263919", "Score": "1", "CreationDate": "2010-07-16T10:31:54.207", "LastActivityDate": "2010-07-16T10:31:54.207"}, "19675409": {"ParentId": "3263873", "LastEditDate": "2013-10-30T10:19:38.600", "CommentCount": "0", "CreationDate": "2013-10-30T06:35:39.693", "OwnerUserId": "476681", "LastEditorUserId": "476681", "PostTypeId": "2", "Id": "19675409", "Score": "0", "Body": "<blockquote>\n<p id=\"so_3263873_19675409_0\">Can we change it at any time because it is not constant?</p>\n</blockquote>\n<p>Yes, you can change it, but C++ doesn't tell what should happen bellow. That depends on the abstract machine (i.e. the platform you are working on).</p>\n<p>If the volatile variable doesn't map to a register of a HW device, then your volatile variable will behave almost like a normal variable. I said almost, because you will not be able to pass it to methods and functions expecting non-volatile int, like this one :</p>\n<pre><code>void foo( int &amp; p );\n</code></pre>\n<p>If the variable maps to a register of a HW device, then trying to write to a read-only registers depends on the device. It may simply ignore writes, but it can also somehow indicate an error - c++ doesn't tell anything.</p>\n<hr>\n<p><code>volatile</code> is a cv-qualifier, used to access hardware registers, or part of memory which can be modified externally (for example, by a controller).</p>\n<p>The c++ standard in [dcl.type.cv]/7 tells :</p>\n<blockquote>\n<p id=\"so_3263873_19675409_1\">[ Note: volatile is a hint to the implementation to avoid aggressive\n  optimization involving the object because the value of the object\n  might be changed by means undetectable by an implementation. See 1.9\n  for detailed semantics. In general, the semantics of volatile are\n  intended to be the same in C ++ as they are in C. \u2014 end note ]</p>\n</blockquote>\n<p>The <a href=\"https://sites.google.com/site/kjellhedstrom2/stay-away-from-volatile-in-threaded-code\" rel=\"nofollow\">Stay away from Volatile in threaded code?</a> article tells what the volatile is good for :</p>\n<blockquote>\n<p id=\"so_3263873_19675409_2\">The volatile keyword is not a threading or synchronization primitive\n  in portable C or C++. It was mainly intended to  </p>\n<p id=\"so_3263873_19675409_3\">1) Allow access to memory mapped devices (I.e. pointers to data structure in coherent memory that can be modified by I/O devices.)<br>\n  2) Variables in signal handlers and between setjmp and longjmp (ref: Volatile at  Wikipedia)</br></p>\n</blockquote>\n<p>Another article <a href=\"http://software.intel.com/en-us/blogs/2007/11/30/volatile-almost-useless-for-multi-threaded-programming/\" rel=\"nofollow\">Volatile: Almost Useless for Multi-Threaded Programming</a> tells :</p>\n<blockquote>\n<p id=\"so_3263873_19675409_4\">Hans Boehm points out that there are only three portable uses for volatile. I'll summarize them here:<br>\n       *  marking a local variable in the scope of a setjmp so that the variable does not rollback after a longjmp.<br>\n       *  memory that is modified by an external agent or appears to be because of a screwy memory mapping<br>\n       *  signal handler mischief</br></br></br></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_3263873_19675409_5\">If you are multi-threading for the sake of speed, slowing down code is definitely not what you want. For multi-threaded programming, there two key issues that volatile is often mistakenly thought to address:<br>\n  * atomicity<br>\n  * memory consistency, i.e. the order of a thread's operations as seen by another thread.</br></br></p>\n</blockquote>\n<p>What is important is that volatile <strong>should not be used</strong> in multi-threaded environment as synchronization mechanism, or as to provide atomic access, since it may work on some compilers, and not on other. For that there are other tools for synchronization (for example semaphores, or mutex with conditional variable) and atomic access (<a href=\"http://en.cppreference.com/w/cpp/atomic\" rel=\"nofollow\">atomic library</a>.</p>\n</hr>", "LastActivityDate": "2013-10-30T10:19:38.600"}, "29443285": {"ParentId": "3263873", "CommentCount": "0", "Body": "<p>Volatile keyword is used to inform the compiler not to predict/assume/believe/presume the value of the particular variable which has been declared as volatile. </p>\n<p>This variable can change by internal and external sources, so you can definitely change it.</p>\n<p>const volatile int k=5; &lt;==== This could not be change by your program but can change by external sources, const makes its read only, only for compiler or programmer</p>\n<p>Source : - <a href=\"http://www.firmcodes.com/volatile-keyword-in-c-and-embedded-system/\" rel=\"nofollow\">Volatile variable in C</a></p>\n", "OwnerUserId": "4748504", "PostTypeId": "2", "Id": "29443285", "Score": "0", "CreationDate": "2015-04-04T05:57:52.910", "LastActivityDate": "2015-04-04T05:57:52.910"}, "3263873": {"CommentCount": "0", "CreationDate": "2010-07-16T10:24:07.873", "PostTypeId": "1", "AcceptedAnswerId": "3263943", "LastEditorUserId": "63550", "LastActivityDate": "2015-04-04T05:57:52.910", "LastEditDate": "2010-09-01T15:04:11.627", "ViewCount": "739", "FavoriteCount": "1", "Title": "Question about the volatile keyword", "Id": "3263873", "Score": "5", "Body": "<p>I know that by the <code>volatile</code> keyword,</p>\n<pre><code>volatile int k=7; \n</code></pre>\n<p>we hint the compiler that the variable can be changed at any time but what about a simple\n<code>int k=7</code>? Can we change it at any time because it is not constant? What is different?</p>\n", "Tags": "<c++>", "OwnerUserId": "466534", "AnswerCount": "6"}, "3263902": {"ParentId": "3263873", "CommentCount": "0", "Body": "<p>Each time the compiler comes across an access to <code>k</code>, it will refetch it from memory instead of optimizing the code to collapse multiple uses of it.</p>\n<pre><code>int k = 7;\nint i = k;\nint j = k;\n</code></pre>\n<p>becomes equivalent to:</p>\n<pre><code>int k = 7;\nint i;\nint j;\ni = j = k;\n</code></pre>\n<p>but</p>\n<pre><code>volatile int k = 7;\nint i = k;\nint j = k;\n</code></pre>\n<p>does not.</p>\n", "OwnerUserId": "20862", "PostTypeId": "2", "Id": "3263902", "Score": "3", "CreationDate": "2010-07-16T10:28:27.147", "LastActivityDate": "2010-07-16T10:28:27.147"}, "3263888": {"ParentId": "3263873", "LastEditDate": "2010-07-16T10:32:22.423", "CommentCount": "3", "CreationDate": "2010-07-16T10:26:40.097", "OwnerUserId": "234053", "LastEditorUserId": "234053", "PostTypeId": "2", "Id": "3263888", "Score": "18", "Body": "<p><code>volatile</code> prevents compiler optimizations and tells the compiler that the contents of the variable declared volatile can change at any time (i.e. a hardware device, interrupt, or another thread kicks in and writes into the variable's memory location). This means, caching values in CPU registers is not possible.</p>\n<pre><code>volatile int a = foo();\nd=a+4;\ne=a+4;\nf=a+4;\n</code></pre>\n<p>Here, the compiler is forced to read <code>a</code> from memory every time it is used. If there was no <code>volatile</code>, precomputing <code>a+4</code> would be a valid (and effective) optimization. </p>\n<pre><code>volatile int a = 4;\nreturn a+5;\n</code></pre>\n<p>Here, the compiler is not allowed to optimize this to a simple <code>return 9;</code> because the contents of <code>a</code> might change between initialization (line 1) and first use (line 2);</p>\n", "LastActivityDate": "2010-07-16T10:32:22.423"}, "bq_ids": {"n4140": {"so_3263873_19675409_1": {"section_id": 5436, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_3263873_19675409_1": {"section_id": 5231, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_3263873_19675409_1": {"section_id": 6863, "quality": 0.8928571428571429, "length": 25}}}, "3263943": {"ParentId": "3263873", "LastEditDate": "2013-10-30T10:58:10.990", "CommentCount": "5", "CreationDate": "2010-07-16T10:34:44.013", "OwnerUserId": "417292", "LastEditorUserId": "417292", "PostTypeId": "2", "Id": "3263943", "Score": "4", "Body": "<p>It's used in low level programming with interrupts and so on mostly</p>\n<pre><code>volatile int count;\n\nvoid test()\n{\n   while(count&lt; 100) \n   {\n        // do nothing\n   }\n}\n\n//\n// Interrupt function called by the hardware automatically at intervals\n//\nvoid interrupt()\n{\n    count = count + 1;\n}\n</code></pre>\n<p>if you don't declare the variable as volatile the compiler will probably notice that count can't change in the while loop and so won't bother to actually read the value every time from memory so it will never exit the loop.</p>\n<p>If you declare it volatile then the compiler will read the value from memory every time as you've told it that the value might change without notice...</p>\n<p>Another use is to map hardware ports.</p>\n<p>On a microcontroller you might have some digital inputs which \"appear\" at a certain memory address. You can read them as if they were a variable but of course the value will potentially change all the time depending on the input signals. Declaring the value as volatile will indicate to the compiler that yes you actually do need to read this memory location every single time because it might have changed, and no you can't assume that it won't change unless you change it.</p>\n<p>Unless you are using low level interrupts or some uses of threading then you don't need to use it.</p>\n<p>EDIT: To be clear, volatile is NOT for synchronization between theads in standard c++, it only does a part of what is necessary. The last sentence in my original post could be misleading. The examples and stuff about hardware interrupts etc in my post are what volatile is for, it absolutely ISN'T for threading and don't even try to use it for that.</p>\n<p><em>I originally wrote \"some uses of threading\" because on some platforms it might be sufficient to use volatile. This is BAD ADVICE in general but if you have a single core and all writes are visible to all \"threads\" then it might work for you. For example on a microcontroller with a simple interrupt based thread switching system it would likely \"work\" even though not guarenteed by the standard. But don't do it. In general it's just wrong, and c++11 has ways that actually work (remember this answer was written pre c++11)</em></p>\n", "LastActivityDate": "2013-10-30T10:58:10.990"}});