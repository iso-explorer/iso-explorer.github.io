post_cb({"bq_ids": {"n4140": {"so_30636541_30637053_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 662}}, "n3337": {"so_30636541_30637053_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 652}}, "n4659": {"so_30636541_30637053_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 690}}}, "30637053": {"Id": "30637053", "PostTypeId": "2", "Body": "<p>The \"implicit\" invocation is also ill-formed. In fact, <a href=\"http://coliru.stacked-crooked.com/a/ebbeea93da231435\">GCC rejects it</a>, so it seems like a bug in Clang.</p>\n<p>The standard (N4140, [over.call]/1) clearly says that</p>\n<blockquote>\n<p id=\"so_30636541_30637053_0\">a call <code>x(arg1,...)</code> is interpreted as <code>x.operator()(arg1, ...)</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator()(T1, T2, T3)</code> exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3.3).</p>\n</blockquote>\n<p>So the two invocations must behave identically.</p>\n<p><strong>Update</strong>: this is a <a href=\"https://llvm.org/bugs/show_bug.cgi?id=22039\">known issue</a> in Clang.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2015-06-04T07:20:47.903", "Score": "7", "CreationDate": "2015-06-04T06:59:16.410", "ParentId": "30636541", "CommentCount": "0", "OwnerUserId": "3959454", "LastEditDate": "2015-06-04T07:20:47.903"}, "30636541": {"ViewCount": "423", "Body": "<p>Is there a clause in standard describing the following difference between a ways to call <code>operator ()</code> from base classes?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n\ntemplate&lt; typename visitor, typename ...visitors &gt;\nstruct composite_visitor\n    : std::decay_t&lt; visitor &gt;\n    , composite_visitor&lt; visitors... &gt;\n{\n\n    //using std::decay_t&lt; visitor &gt;::operator ();\n    //using composite_visitor&lt; visitors... &gt;::operator ();\n\n    composite_visitor(visitor &amp;&amp; _visitor, visitors &amp;&amp;... _visitors)\n        : std::decay_t&lt; visitor &gt;(std::forward&lt; visitor &gt;(_visitor))\n        , composite_visitor&lt; visitors... &gt;{std::forward&lt; visitors &gt;(_visitors)...}\n    { ; }\n\n};\n\ntemplate&lt; typename visitor &gt;\nstruct composite_visitor&lt; visitor &gt;\n    : std::decay_t&lt; visitor &gt;\n{\n\n    //using std::decay_t&lt; visitor &gt;::operator ();\n\n    composite_visitor(visitor &amp;&amp; _visitor)\n        : std::decay_t&lt; visitor &gt;(std::forward&lt; visitor &gt;(_visitor))\n    { ; }\n\n};\n\ntemplate&lt; typename visitor, typename ...visitors &gt;\ncomposite_visitor&lt; visitor, visitors... &gt;\ncompose_visitors(visitor &amp;&amp; _visitor, visitors &amp;&amp;... _visitors)\n{\n    return {std::forward&lt; visitor &gt;(_visitor), std::forward&lt; visitors &gt;(_visitors)...};\n}\n\nint\nmain()\n{\n    struct A {};\n    struct B {};\n#if 1\n    struct { int operator () (A) { return 1; } } x;\n    struct { int operator () (B) { return 2; } } y;\n    auto xy = compose_visitors(x, y);\n#else\n    auto xy = compose_visitors([] (A) { return 1; }, [] (B) { return 2; });\n#endif\n    // \"implicit\":\n    assert(xy(A{}) == 1);\n    assert(xy(B{}) == 2);\n    // \"explicit\":\n    assert(xy.operator () (A{}) == 1); // error: member 'operator()' found in multiple base classes of different types\n    assert(xy.operator () (B{}) == 2);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>\"Implicit\" invocation compiles fine, but not the \"explicit\". Why is it so?</p>\n<p><code>compose_visitors</code> combine the arguments into single class by means of construction of a class derived from all of them.</p>\n<p>Uncommenting the <code>using</code> derectives removes the hard error. It is clear.</p>\n<p>The behaviour is identical for lambda functions and for functors.</p>\n<p>Compiler is <em>clang 3.6</em>.</p>\n", "AcceptedAnswerId": "30637053", "Title": "Difference between \"explicit\" and \"implicit\" invocation of operator ()", "CreationDate": "2015-06-04T06:31:19.393", "Id": "30636541", "CommentCount": "1", "LastEditDate": "2015-06-04T07:08:36.617", "PostTypeId": "1", "LastEditorUserId": "1430927", "LastActivityDate": "2015-06-04T07:20:47.903", "Score": "1", "OwnerUserId": "1430927", "Tags": "<c++><c++11><inheritance><c++14>", "AnswerCount": "1"}});