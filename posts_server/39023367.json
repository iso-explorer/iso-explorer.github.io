post_cb({"bq_ids": {"n4140": {"so_39023367_39031767_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 1567}, "so_39023367_39031767_3": {"length": 10, "quality": 1.0, "section_id": 1567}}, "n3337": {"so_39023367_39031767_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 1562}, "so_39023367_39031767_3": {"length": 10, "quality": 1.0, "section_id": 1562}}, "n4659": {"so_39023367_39031767_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 1716}, "so_39023367_39031767_3": {"length": 10, "quality": 1.0, "section_id": 1716}}}, "39023367": {"ViewCount": "130", "Body": "<p>I know that C++11 has made quite a few changes to the <code>string</code>. Not the least of which is requiring it to be laid out linearly in memory.</p>\n<p>Prior to C++11 a call to <code>string::c_str</code> would return a <code>const char*</code> but is it guaranteed to be the same one. For example, given <code>string foo</code>, is this guaranteed to be true, or might they return different addresses?</p>\n<pre><code>foo.c_str() == foo.c_str()\n</code></pre>\n<p><strong>EDIT:</strong> I should have appended that I'm asking if the return of <code>string::c_str</code> will always be consistent as long as no method is called  on <code>foo</code> which would have invalidated its iterators.</p>\n", "AcceptedAnswerId": "39031767", "Title": "Does c_str Always Return the Same Address?", "CreationDate": "2016-08-18T16:35:34.227", "Id": "39023367", "CommentCount": "6", "LastEditDate": "2016-08-19T05:55:17.937", "PostTypeId": "1", "LastEditorUserId": "1009479", "LastActivityDate": "2016-08-19T06:12:16.380", "Score": "1", "OwnerUserId": "2642059", "Tags": "<c++><string><c-strings><c++03>", "AnswerCount": "1"}, "39031767": {"Id": "39031767", "PostTypeId": "2", "Body": "<p><strong>Edit</strong>: Reading the same paragraph from the standard, I now conclude that subsequent calls to methods data()/c_str() are allowed to invalidate the previously returned pointer (even if you haven't done anything else), so the answer to your question would be <strong>No</strong>, how ironic.</p>\n<p>Original answer:</p>\n<p>Yes, as long as the only non-const operations you perform on the object are <strong>operator[]</strong>, <strong>at</strong>, <strong>begin</strong>, <strong>rbegin</strong>, <strong>end</strong>, and <strong>rend</strong>. </p>\n<p>data()/c_str() returns a pointer to the first element of the string. See the standard (N1905), p. 21.3 [Class template basic_string]:</p>\n<blockquote>\n<ol start=\"6\">\n<li>References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the\n  following uses of that basic_string object:</li>\n</ol>\n<p id=\"so_39023367_39031767_0\">\u2014 As an argument to non-member functions swap() (21.3.7.8), operator&gt;&gt;() (21.3.7.9), and getline() (21.3.7.9).</p>\n<p id=\"so_39023367_39031767_1\">\u2014 As an argument to basic_string::swap().</p>\n<p id=\"so_39023367_39031767_2\">\u2014 Calling data() and c_str() member functions.</p>\n<p id=\"so_39023367_39031767_3\">\u2014 Calling non-const member functions, except <strong>operator[], at, begin, rbegin, end, and rend</strong>.</p>\n<p id=\"so_39023367_39031767_4\">\u2014 Following construction or any of the above uses, except the forms of insert and erase that return iterators, the first call to non-const member functions operator[], at, begin, rbegin, end, or rend.</p>\n</blockquote>\n", "LastEditorUserId": "419450", "LastActivityDate": "2016-08-19T06:12:16.380", "Score": "2", "CreationDate": "2016-08-19T05:35:56.650", "ParentId": "39023367", "CommentCount": "2", "LastEditDate": "2016-08-19T06:12:16.380", "OwnerUserId": "419450"}});