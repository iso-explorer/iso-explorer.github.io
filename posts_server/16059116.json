post_cb({"16059116": {"CommentCount": "2", "CreationDate": "2013-04-17T11:45:04.113", "PostTypeId": "1", "AcceptedAnswerId": "16067411", "LastEditorUserId": "905908", "LastActivityDate": "2013-04-18T09:03:30.563", "LastEditDate": "2013-04-18T09:03:30.563", "ViewCount": "809", "FavoriteCount": "1", "Title": "C++: call (derived's) member function on base pointer of a different derived class's object", "Id": "16059116", "Score": "0", "Body": "<p>Is it \"safe\" (and/or portable) to call a member function (pointer) on the pointer of a base class, but the object pointed to is an instance different derived class. The member function does not access any member variables or functions of the derived class.</p>\n<pre><code>/* Shortened example of what happens in the client code and library */\nclass Base { /* ... */ }\nclass DerivedA : public Base {\n    /* ... */ \n    public: void doSomethingA(float dt);\n}\nvoid DerivedA::doSomethingA(float dt) {\n    /* Does not access members. Conventionally calls/accesses statics */\n    cout &lt;&lt; \"dt(\" &lt;&lt; dt &lt;&lt; \")\";\n}\n\nclass DerivedB : public Base { /* ... */ }\n\ntypedef void (Base::*SEL_SCHEDULE)(float);\nSEL_SCHEDULE pCallback = (SEL_SCHEDULE)(&amp;DerivedA::doSomethingA);\n\nDerivedB db = new DerivedB();\nBase *b = &amp;db;\n/* pCallback and b are saved in a list elsewhere (a scheduler) which calls */\n(b-&gt;*pCallback)(0.f);\n</code></pre>\n<p>This <em>seems to work</em> (in MSVC/Debug mode) okay at runtime, but I'm wondering whether this is Bad (TM) - and why? (I'm yet to test this code with the compilers for Android and iOS).</p>\n<p>Some more specifics if required: I'm building a <a href=\"https://github.com/cocos2d/cocos2d-x/\" rel=\"nofollow\">cocos2d-x</a> based project. <code>Base</code> is <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/cocoa/CCObject.h\" rel=\"nofollow\"><code>CCObject</code></a>, <code>DerivedA</code> and <code>DerivedB</code> are subclasses of <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h\" rel=\"nofollow\"><code>CCLayer</code></a>.</p>\n<p>The hierarchy is <code>DerivedA</code> and <code>DerivedB</code> &lt; <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/layers_scenes_transitions_nodes/CCLayer.h\" rel=\"nofollow\"><code>CCLayer</code></a> &lt; <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/base_nodes/CCNode.h\" rel=\"nofollow\"><code>CCNode</code></a> &lt; <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/cocoa/CCObject.h\" rel=\"nofollow\"><code>CCObject</code></a>. They're <em>game scenes</em> which are visible/alive at mutually exclusive times.</p>\n<p><code>DerivedA</code> has a different <em>static function to set up playback of music</em> which receives a <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/base_nodes/CCNode.h\" rel=\"nofollow\"><code>CCNode</code></a> caller object as a parameter and <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/base_nodes/CCNode.cpp#L1059\" rel=\"nofollow\">schedules</a> another <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/cocoa/CCObject.h#L78\" rel=\"nofollow\">selector</a> (<code>doSomethingA</code>) to <em>begin playback and slowly fade it in</em> using something like:</p>\n<pre><code>callerNode-&gt;schedule(schedule_selector(DerivedA::doSomethingA), 0.05f);\n</code></pre>\n<p><a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/cocoa/CCObject.h#L87\" rel=\"nofollow\"><code>schedule_selector</code></a> is what does the C-style cast. <code>doSomethingA</code> does not access any of its member variables or call member functions. It accesses static members and calls other static functions such as <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/CocosDenshion/include/SimpleAudioEngine.h#L141\" rel=\"nofollow\">such as</a></p>\n<pre><code>CocosDenshion::SimpleAudioEngine::sharedEngine()-&gt;setBackgroundMusicVolume(sFadeMusicVolume);\n</code></pre>\n<p>The call to <code>doSomethingA</code> at runtime happens in <a href=\"https://github.com/cocos2d/cocos2d-x/blob/master/cocos2dx/CCScheduler.cpp#L160\" rel=\"nofollow\">CCTimer::update</a>.</p>\n<p>The <em>hack</em> is primarily to avoid duplicating code and conform to the library's callback signature (timer/scheduler system).</p>\n", "Tags": "<c++><cocos2d-x>", "OwnerUserId": "905908", "AnswerCount": "3"}, "16067411": {"ParentId": "16059116", "CommentCount": "2", "Body": "<p>It's UB.</p>\n<p>You can even use static_cast instead of the odious C-style cast, and the cast itself is quite legal. But </p>\n<blockquote>\n<p id=\"so_16059116_16067411_0\">[Note: although class B need not contain the original member, the\n  dynamic type of the object on which the pointer to member is\n  dereferenced must contain the original member; see 5.5. \u2014end note ] (5.2.9 12)</p>\n<p id=\"so_16059116_16067411_1\">\"The first operand is called the object expression. If the dynamic\n  type of the object expression does not contain the member to which the\n  pointer refers, the behavior is undefined\" (5.5 4)</p>\n</blockquote>\n<p>I.e., you go undefined when you call it from an object of dynamic type DerivedB.</p>\n<p>Now, as a dirty hacks goes, it's probably not the worst (better than the manual traversing of vtables), but is it really needed? If you don't need any dynamic data, why call it on DerivedB? Base is in the library, you cannot redefine it. Callback is librarian, too, so you have to have this <code>typedef void (Base::*SEL_SCHEDULE)(float);</code>, OK. But why can't you define <code>doSomething</code> for B and make pointer to it to couple with an instance of DerivedB? You say </p>\n<blockquote>\n<p id=\"so_16059116_16067411_2\">doSomethingA does not access any of its member variables or call\n  member functions. It accesses static members and calls other static\n  functions</p>\n</blockquote>\n<p>But you can do it in <code>doSomethingB</code> as well. Or, if your callbacks are completely uncoupled from object types, and the only reason you need a member function pointer is the conformance to the library callback signature, you can make your actual callbacks non-member plain old functions, and call them from one-line members-callback conformers like <code>DoSomething(float dt) {ReallyDoSomething(dt);}</code>.</p>\n", "OwnerUserId": "2231575", "PostTypeId": "2", "Id": "16067411", "Score": "1", "CreationDate": "2013-04-17T18:26:51.417", "LastActivityDate": "2013-04-17T18:26:51.417"}, "16059379": {"ParentId": "16059116", "LastEditDate": "2013-04-17T12:29:13.630", "CommentCount": "0", "CreationDate": "2013-04-17T11:57:42.087", "OwnerUserId": "442284", "LastEditorUserId": "442284", "PostTypeId": "2", "Id": "16059379", "Score": "1", "Body": "<p>It is not safe in general.</p>\n<p>You have broken the type-safety system with a C-style cast of your callback in this line:</p>\n<pre><code>SEL_SCHEDULE pCallback = (SEL_SCHEDULE)(&amp;DerivedA::doSomethingA);\n</code></pre>\n<p>A member function of DerivedA should operate on an instance of a DerivedA only (or something that further derives from it). You don't have one, you have a DerivedB, but because of your C-cast, your code compiled.</p>\n<p>If your callback function had actually tried to access a member of a DerivedA you would potentially have had serious issues (undefined behaviour).</p>\n<p>As it is the function only prints so in this case is probably not undefined, but that doesn't mean you should do it.</p>\n<p>One typesafe way is to use a callback that takes a Base (reference) and a float and use <code>boost::bind</code> or <code>std::bind</code> to create it.</p>\n<p>The other simple way which will probably be your answer most of the time is to just call a virtual method of Base that takes a float.</p>\n", "LastActivityDate": "2013-04-17T12:29:13.630"}, "bq_ids": {"n4140": {"so_16059116_16067411_1": {"section_id": 6131, "quality": 0.5882352941176471, "length": 10}, "so_16059116_16067411_0": {"section_id": 6038, "quality": 0.7619047619047619, "length": 16}}, "n3337": {"so_16059116_16067411_1": {"section_id": 5895, "quality": 0.5882352941176471, "length": 10}, "so_16059116_16067411_0": {"section_id": 5806, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_16059116_16067411_1": {"section_id": 7628, "quality": 0.5882352941176471, "length": 10}, "so_16059116_16067411_0": {"section_id": 7537, "quality": 0.7142857142857143, "length": 15}}}, "16059304": {"ParentId": "16059116", "LastEditDate": "2013-04-17T12:26:39.180", "CommentCount": "0", "CreationDate": "2013-04-17T11:54:35.823", "OwnerUserId": "204847", "LastEditorUserId": "204847", "PostTypeId": "2", "Id": "16059304", "Score": "1", "Body": "<blockquote>\n<p id=\"so_16059116_16059304_0\">I'm wondering whether this is Bad (TM)</p>\n</blockquote>\n<p>It certainly is, unless it's an override of a virtual function declared in a common base class. </p>\n<p>If it is, then you don't need the dodgy cast; just initialise directly from <code>&amp;Base::DoSomethingA</code>.</p>\n<p>If it isn't, then the evil C cast (which here is a <code>reinterpret_cast</code> in disguise) allows you to apply the pointer to a type that doesn't have that member function; calling that Frankensteinian abomination could do absolutely anything. If the function doesn't actually touch the object, then there's a good chance that you won't see any ill effects; but you're still firmly in undefined behaviour.</p>\n", "LastActivityDate": "2013-04-17T12:26:39.180"}});