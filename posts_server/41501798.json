post_cb({"41502592": {"ParentId": "41501798", "CommentCount": "3", "Body": "<p><code>std::vector</code> guarantees that pointers are valid iterators for its entire sequence, because <code>vector::data</code> returns \"A pointer such that <code>[data(), data() + size())</code> is a valid range.\" That's pointer addition, which is defined over <code>std::ptrdiff_t</code>, which is the signed version of <code>std::size_t</code>.</p>\n<p>Also, [iterator.requirements.general]/6 applies:</p>\n<blockquote>\n<p id=\"so_41501798_41502592_0\">\u2026 for integral values <code>n</code> and dereferenceable iterator values <code>a</code> and <code>(a + n)</code>, <code>*(a + n)</code> is equivalent to <code>*(addressof(*a) + n)</code>\u2026</p>\n</blockquote>\n<p>It's possible for <code>vector::size_type</code> to be <em>narrower</em> than <code>std::size_t</code>, for example 32 bits on a 64-bit system. But it's not something I'd worry about.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "41502592", "Score": "4", "CreationDate": "2017-01-06T09:27:06.963", "LastActivityDate": "2017-01-06T09:27:06.963"}, "41501798": {"CommentCount": "6", "AcceptedAnswerId": "41502592", "CreationDate": "2017-01-06T08:32:25.510", "LastActivityDate": "2017-01-06T09:27:06.963", "Title": "Is `size_t` always an alias for `vector<int>::size_type` or any other container type?", "ViewCount": "185", "PostTypeId": "1", "Id": "41501798", "Score": "4", "Body": "<p>Let's make the simplest example possible:</p>\n<p><strong>Formulation 1:</strong></p>\n<pre><code>std::vector&lt;int&gt; vec;\n// add 10E11 elements\nfor(std::size_t n = 0; n &lt; vec.size(); ++n)\n    // ...\n</code></pre>\n<p><strong>Formulation 2:</strong></p>\n<pre><code>std::vector&lt;int&gt; vec;\n// add 10E11 elements\nfor(std::vector&lt;int&gt;::size_type n = 0; n &lt; vec.size(); ++n)\n    // ...\n</code></pre>\n<p>Naturally, <code>unsigned int</code> or any inappropriate data types do not work here and we have to compile x64. My question is: Is there any case in which the first formulation can lead to issues or can we <em>safely</em> always write it in this much shorter notation? I would also be interesting in similar settings if they are trivial to cover (x86, any other container, other applications of <code>size_type</code>).</p>\n", "Tags": "<c++><size-type>", "OwnerUserId": "2573127", "AnswerCount": "3"}, "41501955": {"ParentId": "41501798", "CommentCount": "0", "Body": "<p>Although it is the case in all common implementation, the standard makes no guarantee on this. What is guaranteed is that <code>std::vector&lt;T&gt;::size_type</code> is an implementation defined unsigned integer type.</p>\n<p>References:</p>\n<p>23.2.1 General container requirements [container.requirements.general] </p>\n<blockquote>\n<p id=\"so_41501798_41501955_0\">X::size_type [is a] unsigned\n  integer type</p>\n</blockquote>\n<p>and 23.3.6.1 Class template vector overview [vector.overview] \u00a72</p>\n<blockquote id=\"so_41501798_41501955_1\">\n<pre><code>typedef implementation-defined size_type; // see 23.2\n</code></pre>\n</blockquote>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "41501955", "Score": "3", "CreationDate": "2017-01-06T08:46:26.163", "LastActivityDate": "2017-01-06T08:46:26.163"}, "41501952": {"ParentId": "41501798", "CommentCount": "0", "Body": "<p>While <code>std::vector::size_type</code> is usually <code>std::size_t</code>, there is no guarantee that it must. It's safer to use </p>\n<pre><code>for(std::vector&lt;int&gt;::size_type n = 0; n &lt; vec.size(); ++n)\n</code></pre>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "41501952", "Score": "0", "CreationDate": "2017-01-06T08:46:05.297", "LastActivityDate": "2017-01-06T08:46:05.297"}, "bq_ids": {"n4659": {"so_41501798_41502592_0": {"section_id": 7005, "quality": 1.0, "length": 7}}}});