post_cb({"bq_ids": {"n4140": {"so_25638770_25639844_1": {"length": 21, "quality": 0.875, "section_id": 6046}}, "n3337": {"so_25638770_25639844_1": {"length": 18, "quality": 0.75, "section_id": 5814}}, "n4659": {"so_25638770_25639844_1": {"length": 21, "quality": 0.875, "section_id": 7545}}}, "25638770": {"ViewCount": "1701", "Body": "<p>Is there any difference between the following three casts for extracting raw byte pointers for use in pointer arithmetic? (assume a platform where char is 1 byte.)</p>\n<ol>\n<li><code>static_cast&lt;char*&gt;((void*)ptr))</code></li>\n<li><code>reinterpret_cast&lt;char*&gt;(ptr)</code></li>\n<li>(updated) or: <code>static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(ptr))</code></li>\n</ol>\n<p>Which should I prefer?</p>\n<p><strong>In more detail...</strong></p>\n<p>Given pointers to two member objects in a class, I would like to compute an offset from one to the other, so that I can reconstruct the address of one member given an offset and the address of the other member.</p>\n<pre><code>// assumed data layout:\nstruct C {\n  // ...\n  A a;\n  // ...\n  B b;\n}\n</code></pre>\n<p>The code that I use at the moment is along the lines of:</p>\n<pre><code>void approach1( A *pa, B *pb )\n{\n  // compute offset:\n  std::ptrdiff_t offset = static_cast&lt;char*&gt;((void*)pa) - static_cast&lt;char*&gt;((void*)pb);\n  // then in some other function...\n  // given offset and ptr to b, compute ptr to a:\n  A *a = static_cast&lt;A*&gt;( (void*)(static_cast&lt;char*&gt;((void*)pb) + offset) );\n}\n\nmain()\n{\n  C c;\n  approach1(&amp;c.a, &amp;c.b);\n}\n</code></pre>\n<p>I would like to know whether the following is better (or worse):</p>\n<pre><code>void approach2( A *pa, B *pb )\n{\n  std::ptrdiff_t offset = reinterpret_cast&lt;char*&gt;(pa) - reinterpret_cast&lt;char*&gt;(pb);\n  // ...\n  A *a = reinterpret_cast&lt;A*&gt;( reinterpret_cast&lt;char*&gt;(pb) + offset );\n}\n</code></pre>\n<p>Are the two methods entirely equivalent? Are they equally portable?</p>\n<p>My impression is that <code>approach1()</code> is more portable, because \"<a href=\"https://stackoverflow.com/questions/573294/when-to-use-reinterpret-cast\"><code>static_cast</code>ing a pointer to and from <code>void*</code> preserves the address</a>,\" whereas <code>reinterpret_cast&lt;&gt;</code> guarantees less (see accepted answer at link).</p>\n<p>I would like to know what the cleanest way to do this is.</p>\n<p><strong>Update: Explanation of Purpose</strong></p>\n<p>A number of people have asked what is the purpose of computing these offsets. The purpose is to construct a meta-class table of instance offsets. This is used by a runtime reflection mechanism for automatic GUI building and persistance (the offsets are not serialized, just used to traverse the structure). The code has been in production for over 15 years. For the purposes of this question I just want to know the most portable way of computing the pointer offsets. I have no intention of making large changes to the way the metaclass system works. In addition, I'm also generally interested in the best way to do this, as I have other uses in mind (e.g. difference pointers for shared memory code).</p>\n<p><strong>NOTE:</strong> I can not use <code>offsetof()</code> because in my actual code I only have the pointers to instances <code>a</code> and <code>b</code>, I don't necessarily have the type of the containing object <code>c</code> or other static info to use <code>offsetof()</code>. All I can assume is that <code>a</code> and <code>b</code> are members of the same object.</p>\n", "Title": "reinterpret_cast<char*>(p) or static_cast<char*>((void*)p)) for bytewise pointer difference, which is better?", "CreationDate": "2014-09-03T07:36:52.370", "LastActivityDate": "2017-10-06T08:45:26.083", "CommentCount": "10", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:59:06.237", "LastEditorUserId": "-1", "Id": "25638770", "Score": "6", "OwnerUserId": "2013747", "Tags": "<c++><pointers><casting>", "AnswerCount": "2"}, "25639844": {"Id": "25639844", "PostTypeId": "2", "Body": "<p>These two will lead to the same result so the difference is mostly semantical, and <code>reinterpret_cast</code> has exactly the meaning of the operation you want, plus the fact that only one cast is required instead of two (and the less cast you have in your code the better).</p>\n<blockquote>\n<p id=\"so_25638770_25639844_0\"><strong>reinterpret_cast</strong> </p>\n<p id=\"so_25638770_25639844_1\"><strong>5.2.10/7</strong>: An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of\n  object pointer type is converted to the object pointer type \u201cpointer to cv T\u201d, the result is static_cast&lt; cv T* &gt;(static_cast&lt; cv void* &gt;(v)).</p>\n</blockquote>\n<p>So except if an exotique random low level different behaviour appears on a middle-age platform, you should definitely go with:</p>\n<pre><code>reinterpret_cast&lt;char*&gt;(ptr);\n</code></pre>\n<p>In general.</p>\n<p>That said, why don't you use <a href=\"http://en.cppreference.com/w/cpp/types/integer\" rel=\"nofollow noreferrer\">uintptr_t</a> in your case ? it's even more apropriate, you need no pointer:</p>\n<pre><code>void approach3( A *pa, B *pb )\n{\n  std::ptrdiff_t offset = reinterpret_cast&lt;std::uintptr_t&gt;(pa) - reinterpret_cast&lt;std::uintptr_t&gt;(pb);\n  // ...\n  A *a = reinterpret_cast&lt;A*&gt;( reinterpret_cast&lt;std::uintptr_t&gt;(pb) + offset );\n}\n</code></pre>\n<p>For additional information see:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/reinterpret_cast</a></p>\n", "LastEditorUserId": "1147772", "LastActivityDate": "2017-10-06T08:45:26.083", "Score": "6", "CreationDate": "2014-09-03T08:38:35.090", "ParentId": "25638770", "CommentCount": "7", "OwnerUserId": "1147772", "LastEditDate": "2017-10-06T08:45:26.083"}, "25638895": {"Id": "25638895", "PostTypeId": "2", "Body": "<p>I do not recommend calculating offset distances between class members' addresses. Either the compiler might inject padding data, or even if it is working it will work the same way only for that specific compiler running on that specific host. There are a multitude sources of error when applying this practice. For example what if you have to deal with the famous <a href=\"https://stackoverflow.com/questions/11603198/virtual-tables-and-memory-layout-in-multiple-virtual-inheritance\">Virtual tables and memory layout in multiple virtual inheritance</a> ? This will totally render your solution unusable.</p>\n<p>So back to the roots: Why are you trying to do this? Maybe there is a better solution.</p>\n<p><strong>EDIT/Update</strong></p>\n<p>Thanks for explaining us the reason. It is a very interesting approach I did not see till now. I have learned something today.</p>\n<p>However, I still stick to my point that there should be a much more easier way of handling this. And just as a concept of proof, I wrote a small application just to see which of your methods is working. For me neither of them work. </p>\n<p>The application is a slightly expanded one of your methods, here it is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\nstruct A\n{\n    A(const std::string&amp; pa) : a(pa) {printf(\"CTR: A address: %p\\n\", this) ;}\n    std::string a;\n};\n\nstruct B\n{\n    B(const std::string&amp; pb) : b(pb) {printf(\"CTR: B address: %p\\n\", this) ;}\n    std::string b;\n};\n\n// assumed data layout:\nstruct C {\n\n    C() : a(\"astring\"), b(\"bstring\") {}\n  // ...\n  A a;\n  // ...\n  B b;\n};\n\nvoid approach1( A *pa, B *pb )\n{\n\n    printf(\"approach1: A address: %p B address: %p\\n\", pa, pb); \n    // compute offset:\n    std::ptrdiff_t offset = static_cast&lt;char*&gt;((void*)pb) - static_cast&lt;char*&gt;((void*)pa);\n    // then in some other function...\n    // given offset and ptr to b, compute ptr to a:\n    A *a = static_cast&lt;A*&gt;( (void*)(static_cast&lt;char*&gt;((void*)pb) + offset) );\n    printf(\"approach1: a address: %p \\n\", a); \n\n    std::cout &lt;&lt; \"approach1: A-&gt;a=\" &lt;&lt; a-&gt;a &lt;&lt; std::endl;\n}\n\n\nvoid approach2( A *pa, B *pb )\n{\n    printf(\"approach2: A address: %p B address: %p\\n\", pa, pb); \n\n    std::ptrdiff_t offset = reinterpret_cast&lt;char*&gt;(pb) - reinterpret_cast&lt;char*&gt;(pa);\n\n    A *a = reinterpret_cast&lt;A*&gt;( reinterpret_cast&lt;char*&gt;(pb) + offset );\n    printf(\"approach2: a address: %p \\n\", a); \n    std::cout &lt;&lt; \"approach2: A-&gt;a=\" &lt;&lt; a-&gt;a &lt;&lt; std::endl;\n}\n\nmain()\n{\n  C c;\n  std::cout &lt;&lt; c.a.a &lt;&lt; std::endl;\n\n  approach1(&amp;c.a, &amp;c.b);\n  approach2(&amp;c.a, &amp;c.b);\n}\n</code></pre>\n<p>The output of it on my computer (<code>uname -a\nLinux flood 3.13.0-33-generic #58-Ubuntu SMP Tue Jul 29 16:45:05 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</code>) with my compiler (<code>g++ (Ubuntu 4.8.2-19ubuntu1) 4.8.2</code>) is:</p>\n<pre><code>CTR: A address: 0x7fff249f0900\nCTR: B address: 0x7fff249f0908\nastring\napproach1: A address: 0x7fff249f0900 B address: 0x7fff249f0908\napproach1: a address: 0x7fff249f0910 \napproach1: A-&gt;a=&lt;GARBAGE&gt;\napproach2: a address: 0x7fff249f0910 \n</code></pre>\n<p>where <code>&lt;GARBAGE&gt;</code> as expected contains ... garbage.</p>\n<p>Please see at: <a href=\"http://ideone.com/U8ahAL\" rel=\"nofollow noreferrer\">http://ideone.com/U8ahAL</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-03T08:17:47.153", "Score": "0", "CreationDate": "2014-09-03T07:43:28.610", "ParentId": "25638770", "CommentCount": "5", "OwnerUserId": "186193", "LastEditDate": "2017-05-23T11:59:06.237"}});