post_cb({"bq_ids": {"n4140": {"so_6389521_6389769_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 955}}, "n3337": {"so_6389521_6389769_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 943}}}, "6389595": {"CommentCount": "0", "Body": "<p>A <code>vector</code> is just a wrapper around a contiguous block of dynamically allocated memory, in other words, an array. So, if this program would work with an array allocated with <code>malloc</code> or <code>new</code>, it should continue to work with a <code>vector</code>.</p>\n<p>(Unless it only worked \"accidentally\" with an array, of course, but the <code>vector</code> is unlikely to introduce extra problems.)</p>\n", "CreationDate": "2011-06-17T17:40:08.173", "ParentId": "6389521", "Id": "6389595", "LastActivityDate": "2011-06-17T17:40:08.173", "PostTypeId": "2", "Score": "1", "OwnerUserId": "166749"}, "6389769": {"CommentCount": "0", "Body": "<p>The C++ standard in <strong>23.2.4</strong> guarantees that each element of a vector&lt;&gt; is stored contiguously:</p>\n<blockquote>\n<p id=\"so_6389521_6389769_0\">The elements of a\n  vector are stored contiguously, meaning that if v is a vector where T is some type\n  other than bool, then it obeys the identity <strong>&amp;v[n] == &amp;v[0] + n</strong> for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n<p>It's important to notice what it says about vector &lt; bool &gt; , vector &lt; bool &gt; is a specialized vector&lt;&gt; that happens to try to \"optimize space allocation\", in some implementations it does so by storing each boolean value in a bit which pretty much renders pointer arithmetic useless.</p>\n", "CreationDate": "2011-06-17T17:54:35.063", "ParentId": "6389521", "Id": "6389769", "LastActivityDate": "2011-06-17T17:54:35.063", "PostTypeId": "2", "Score": "0", "OwnerUserId": "722973"}, "6389521": {"CreationDate": "2011-06-17T17:32:29.493", "ViewCount": "173", "Id": "6389521", "AcceptedAnswerId": "6389628", "Score": "1", "Title": "using a char array to hold an array of arbitrarily sized objects, alignment issues?", "LastEditorUserId": "331059", "CommentCount": "3", "Body": "<p>I want to pass in an array of parameters to SQLBindParameters, and have this array held in a char array(since I don't know the type beforehand) (I want all the elements in the 'array' to be the same).</p>\n<p>I'll have a pointer to a sample parameter type, and the size of the parameter.</p>\n<pre><code>void *buffer = getBuffer();\nint bufferLength = getBufferLength();\nconst int numElements = 200; //for example\n\nchar *array = new char[bufferLength * numElements];\n\nfor(int i=0; i &lt; numElements; ++i)\n{\n    memcpy(array + (i * bufferLength), buffer, bufferLength)\n}\n\n// now use array in SQLBindParameter call    \n</code></pre>\n<p>will this work as expected, without any alignment issues? (i.e., the same as if I had just declared an array of the right type to start with)</p>\n", "Tags": "<c++><odbc>", "LastEditDate": "2011-06-17T18:03:12.200", "LastActivityDate": "2011-06-17T18:03:12.200", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "331059"}, "6389628": {"CreationDate": "2011-06-17T17:42:49.427", "CommentCount": "2", "Body": "<p>Assuming that you're using <code>vector</code> with an allocator that uses <code>operator new</code> under the hood, then the C++ standard guarantees that an array of <code>char</code> allocated with <code>new</code> will be aligned suitably for use with any data type.</p>\n<p>EDIT: Yes, <code>new char[]</code> is guaranteed to be aligned for use with any type.</p>\n<p>EDIT2: Do note that a local (stack) array <code>char foo[]</code> has no such alignment guarantees.</p>\n", "Id": "6389628", "OwnerUserId": "251738", "LastEditDate": "2011-06-17T17:51:46.400", "ParentId": "6389521", "LastActivityDate": "2011-06-17T17:51:46.400", "PostTypeId": "2", "Score": "1", "LastEditorUserId": "251738"}});