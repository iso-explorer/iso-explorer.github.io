post_cb({"1239932": {"ParentId": "1239908", "CommentCount": "3", "Body": "<p>Seems to compile ok in vs 2008.  Have you tried:</p>\n<pre><code>public:\n    Derived( bool initZero = Base&lt;T&gt;::NO_ZEROFILL );\n</code></pre>\n", "OwnerUserId": "2958", "PostTypeId": "2", "Id": "1239932", "Score": "1", "CreationDate": "2009-08-06T16:11:03.950", "LastActivityDate": "2009-08-06T16:11:03.950"}, "29618861": {"ParentId": "1239908", "LastEditDate": "2015-04-14T07:24:02.347", "CommentCount": "1", "CreationDate": "2015-04-14T03:50:16.810", "OwnerUserId": "4785548", "LastEditorUserId": "4785548", "PostTypeId": "2", "Id": "29618861", "Score": "0", "Body": "<p>Try this program</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\ntemplate &lt;class T&gt; class base{\npublic:\nT x;\nbase(T a){x=a;}\nvirtual T get(void){return x;}\n};\ntemplate &lt;class T&gt;\nclass derived:public base&lt;T&gt;{\npublic:\nderived(T a):base&lt;T&gt;(a){}\nT get(void){return this-&gt;x+2;}\n};\nint main(void){\nbase&lt;int&gt; ob1(10);\ncout&lt;&lt;ob1.get()&lt;&lt;endl;\nderived&lt;float&gt; ob(10);\ncout&lt;&lt;ob.get();\nreturn 0;\n}\n</code></pre>\n<p>in the <code>T get(void){return this-&gt;x+2;}</code> line u can also use the scope resolution (::) operator. for example, try replace the line with</p>\n<pre><code>T get(void){return base&lt;T&gt;::x+2;}\n</code></pre>\n", "LastActivityDate": "2015-04-14T07:24:02.347"}, "1239908": {"CommentCount": "0", "CreationDate": "2009-08-06T16:06:07.270", "PostTypeId": "1", "AcceptedAnswerId": "1239940", "LastEditorUserId": "6637668", "LastActivityDate": "2016-08-29T10:29:55.227", "LastEditDate": "2016-08-29T10:29:55.227", "ViewCount": "15136", "FavoriteCount": "25", "Title": "Why doesn't a derived template class have access to a base template class' identifiers?", "Id": "1239908", "Score": "39", "Body": "<p>Consider:</p>\n<pre><code>template &lt;typename T&gt;\nclass Base\n{\n    public:\n        static const bool ZEROFILL = true;\n        static const bool NO_ZEROFILL = false;\n}\n\ntemplate &lt;typename T&gt;\nclass Derived : public Base&lt;T&gt;\n{\n    public: \n        Derived( bool initZero = NO_ZEROFILL );    // NO_ZEROFILL is not visible\n        ~Derived();\n}\n</code></pre>\n<p>I am not able compile this with GCC g++ 3.4.4 (cygwin).</p>\n<p>Prior to converting these to class templates, they were non-generic and the derived class was able to see the base class's static members. Is this loss of visibility in a requirement of the C++ spec or is there a syntax change that I need to employ? </p>\n<p>I understand that each instantiation of <code>Base&lt;T&gt;</code> will have it's own static member \"<code>ZEROFILL</code>\" and \"<code>NO_ZEROFILL</code>\", that <code>Base&lt;float&gt;::ZEROFILL</code> and <code>Base&lt;double&gt;::ZEROFILL</code> are different variables, but i don't really care; the constant is there for readability of the code. I wanted to use a static constant because that is more safe in terms of name conflicts rather than a macro or global.</p>\n", "Tags": "<c++><templates><derived-class><c++-faq>", "OwnerUserId": "141023", "AnswerCount": "4"}, "1239940": {"ParentId": "1239908", "LastEditDate": "2016-07-06T06:31:00.973", "CommentCount": "12", "CreationDate": "2009-08-06T16:12:16.243", "OwnerUserId": "140719", "LastEditorUserId": "140719", "PostTypeId": "2", "Id": "1239940", "Score": "43", "Body": "<p>That's two-phase lookup for you. </p>\n<p><code>Base&lt;T&gt;::NO_ZEROFILL</code> (all caps identifiers are boo, except for macros, BTW) is an identifier that depends on <code>T</code>.<br>\nSince, when the compiler first parses the template, there's no actual type substituted for <code>T</code> yet, the compiler doesn't \"know\" what <code>Base&lt;T&gt;</code> is. So it cannot know any identifiers you assume to be defined in it (there might be a specialization for some <code>T</code>s that the compiler only sees later) and you cannot omit the base class qualification from identifiers defined in the base class. </br></p>\n<p>That's why you have to write <code>Base&lt;T&gt;::NO_ZEROFILL</code> (or <code>this-&gt;NO_ZEROFILL</code>). That tells the compiler that <code>NO_ZEROFILL</code> is something in the base class, which depends on <code>T</code>, and that it can only verify it later, when the template is instantiated. It will therefore accept it without trying to verify the code.<br>\nThat code can only be verified later, when the template is instantiated by supplying an actual parameter for <code>T</code>. </br></p>\n", "LastActivityDate": "2016-07-06T06:31:00.973"}, "1254095": {"ParentId": "1239908", "CommentCount": "5", "Body": "<p>The problem you have encountered is due to name lookup rules for dependent base classes.  14.6/8 has:</p>\n<blockquote>\n<p id=\"so_1239908_1254095_0\">When looking for the declaration of a name used in a template definition, the usual lookup rules (3.4.1,\n  3.4.2) are used for nondependent names. The lookup of names dependent on the template parameters is\n  postponed until the actual template argument is known (14.6.2).</p>\n</blockquote>\n<p>(This is not really \"2-phase lookup\" - see below for an explanation of that.)</p>\n<p>The point about 14.6/8 is that as far as the compiler is concerned <code>NO_ZEROFILL</code> in your example is an identifier and is not dependent on the template parameter.  It is therefore looked up as per the normal rules in 3.4.1 and 3.4.2.</p>\n<p>This normal lookup doesn't search inside <code>Base&lt;T&gt;</code> and so NO_ZEROFILL is simply an undeclared identifier.  14.6.2/3 has:</p>\n<blockquote>\n<p id=\"so_1239908_1254095_1\">In the definition of a class template or a member of a class template, if a base class of the class template\n  depends on a template-parameter, the base class scope is not examined during unqualified name lookup\n  either at the point of definition of the class template or member or during an instantiation of the class template\n  or member.</p>\n</blockquote>\n<p>When you qualify <code>NO_ZEROFILL</code> with <code>Base&lt;T&gt;::</code> in essence you are changing it from being a non dependent name to a dependent one and when you do that you delay its lookup until the template is instantiated.</p>\n<p><strong>Side note: What is 2-phase lookup:</strong></p>\n<pre><code>void bar (int);\n\ntemplate &lt;typename T&gt;\nvoid foo (T const &amp; t) {\n  bar (t);\n}\n\n\nnamespace NS\n{\n  struct A {};\n  void bar (A const &amp;);\n}\n\n\nint main ()\n{\n  NS::A a;\n  foo (a);\n}\n</code></pre>\n<p>The above example is compiled as follows.  The compiler parses the function body of <code>foo</code> and see that there is a call to <code>bar</code> which has a dependent argument (ie. one that is dependent on the template parameter).  At this point the compiler looks up bar as per 3.4.1 and this is the \"phase 1 lookup\".  The lookup will find the function <code>void bar (int)</code> and that is stored with the dependent call until later.</p>\n<p>When the template is then instantiated (as a result of the call from <code>main</code>), the compiler then performs an additional lookup in the scope of the argument, this is the \"phase 2 lookup\". This case that results in finding <code>void NS::bar(A const &amp;)</code>.</p>\n<p>The compiler has two overloads for <code>bar</code> and it selects between them, in the above case calling <code>void NS::bar(A const &amp;)</code>.</p>\n", "OwnerUserId": "11698", "PostTypeId": "2", "Id": "1254095", "Score": "28", "CreationDate": "2009-08-10T10:16:23.870", "LastActivityDate": "2009-08-10T10:16:23.870"}, "bq_ids": {"n4140": {"so_1239908_1254095_1": {"section_id": 190, "quality": 0.8709677419354839, "length": 27}, "so_1239908_1254095_0": {"section_id": 176, "quality": 0.8461538461538461, "length": 22}}, "n3337": {"so_1239908_1254095_1": {"section_id": 184, "quality": 0.8709677419354839, "length": 27}, "so_1239908_1254095_0": {"section_id": 170, "quality": 0.8461538461538461, "length": 22}}, "n4659": {"so_1239908_1254095_1": {"section_id": 195, "quality": 0.7096774193548387, "length": 22}, "so_1239908_1254095_0": {"section_id": 181, "quality": 0.8461538461538461, "length": 22}}}});