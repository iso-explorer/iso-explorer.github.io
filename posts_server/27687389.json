post_cb({"bq_ids": {"n4140": {"so_27687389_27688405_0": {"length": 18, "quality": 1.0, "section_id": 144}}, "n3337": {"so_27687389_27688405_0": {"length": 18, "quality": 1.0, "section_id": 138}}, "n4659": {"so_27687389_27688405_0": {"length": 18, "quality": 1.0, "section_id": 148}}}, "27687803": {"Id": "27687803", "PostTypeId": "2", "Body": "<pre><code>// specialized as has_member&lt; T , void &gt; or discarded (sfinae)\ntemplate&lt;class T&gt;\nstruct has_member&lt;T , void_t&lt;decltype(T::member)&gt;&gt; : true_type\n{ };\n</code></pre>\n<p>That above specialization exists only when it is well formed, so when <code>decltype( T::member )</code> is valid and not ambiguous.\nthe specialization is so for <code>has_member&lt;T , void&gt;</code> as state in the comment.</p>\n<p>When you write <code>has_member&lt;A&gt;</code>, it is <code>has_member&lt;A, void&gt;</code> because of default template argument.</p>\n<p>And we have specialization for <code>has_member&lt;A, void&gt;</code> (so inherit from <code>true_type</code>) but we don't have specialization for <code>has_member&lt;B, void&gt;</code> (so we use the default definition : inherit from <code>false_type</code>)</p>\n", "LastActivityDate": "2014-12-29T11:16:13.167", "CommentCount": "0", "CreationDate": "2014-12-29T11:16:13.167", "ParentId": "27687389", "Score": "14", "OwnerUserId": "2684539"}, "27688405": {"Id": "27688405", "PostTypeId": "2", "Body": "<p>When you write <code>has_member&lt;A&gt;::value</code>, the compiler looks up the name <code>has_member</code> and finds the <em>primary</em> class template, that is, this declaration:</p>\n<pre><code>template&lt; class , class = void &gt;\nstruct has_member;\n</code></pre>\n<p>(In the OP, that's written as a definition.)</p>\n<p>The template argument list <code>&lt;A&gt;</code> is compared to the template parameter list of this primary template. Since the primary template has two parameters, but you only supplied one, the remaining parameter is defaulted to the default template argument: <code>void</code>. It's as if you had written <code>has_member&lt;A, void&gt;::value</code>.</p>\n<p>Now, the template parameter list is compared against any specializations of the template <code>has_member</code>. Only if no specialization matches, the definition of the primary template is used as a fall-back. So the partial specialization is taken into account:</p>\n<pre><code>template&lt; class T &gt;\nstruct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : true_type\n{ };\n</code></pre>\n<p>The compiler tries to match the template arguments <code>A, void</code> with the patterns defined in the partial specialization: <code>T</code> and <code>void_t&lt;..&gt;</code> one by one. First, template argument deduction is performed. The partial specialization above is still a template with template-parameters that need to be \"filled\" by arguments.</p>\n<p>The first pattern, <code>T</code>, allows the compiler to deduce the template-parameter <code>T</code>. This is a trivial deduction, but consider a pattern like <code>T const&amp;</code>, where we could still deduce <code>T</code>. For the pattern <code>T</code> and the template argument <code>A</code>, we deduce <code>T</code> to be <code>A</code>.</p>\n<p>In the second pattern <code>void_t&lt; decltype( T::member ) &gt;</code>, the template-parameter <code>T</code> appears in a context where it cannot be deduced from any template argument. There are two reasons for this:</p>\n<ul>\n<li><p>The expression inside <code>decltype</code> is explicitly excluded from template argument deduction. I guess this is because it can be arbitrarily complex.</p></li>\n<li><p>Even if we used a pattern without <code>decltype</code> like <code>void_t&lt; T &gt;</code>, then the deduction of <code>T</code> happens on the resolved alias template. That is, we resolve the alias template and then try to deduce the type <code>T</code> from the resulting pattern. The resulting pattern however is <code>void</code>, which is not dependent on <code>T</code> and therefore does not allow us to find a specific type for <code>T</code>. This is similar to the mathematical problem of trying to invert a constant function (in the mathematical sense of those terms).</p></li>\n</ul>\n<p>Template argument deduction is finished<sup>(*)</sup>, now the <em>deduced</em> template arguments are substituted. This creates a specialization that looks like this:</p>\n<pre><code>template&lt;&gt;\nstruct has_member&lt; A, void_t&lt; decltype( A::member ) &gt; &gt; : true_type\n{ };\n</code></pre>\n<p>The type <code>void_t&lt; decltype( A::member ) &gt; &gt;</code> can now be evaluated. It is well-formed after substitution, hence, no <em>Substitution Failure</em> occurs. We get:</p>\n<pre><code>template&lt;&gt;\nstruct has_member&lt;A, void&gt; : true_type\n{ };\n</code></pre>\n<p>Now, we can compare the template parameter list of this specialization with the template arguments supplied to the original <code>has_member&lt;A&gt;::value</code>. Both types match exactly, so this partial specialization is chosen.</p>\n<p>On the other hand, when we define the template as:</p>\n<pre><code>template&lt; class , class = int &gt; // &lt;-- int here instead of void\nstruct has_member : false_type\n{ };\n\ntemplate&lt; class T &gt;\nstruct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : true_type\n{ };\n</code></pre>\n<p>We end up with the same specialization:</p>\n<pre><code>template&lt;&gt;\nstruct has_member&lt;A, void&gt; : true_type\n{ };\n</code></pre>\n<p>but our template argument list for <code>has_member&lt;A&gt;::value</code> now is <code>&lt;A, int&gt;</code>. The arguments do not match the parameters of the specialization, and the primary template is chosen as a fall-back.</p>\n<hr>\n<p><sup>(*)</sup> The Standard, IMHO confusingly, includes the substitution process and the matching of explicitly specified template arguments in the <em>template argument deduction</em> process. For example (post-N4296) [temp.class.spec.match]/2:</p>\n<blockquote>\n<p id=\"so_27687389_27688405_0\">A partial specialization matches a given actual template argument list\n  if the template arguments of the partial specialization can be deduced\n  from the actual template argument list.</p>\n</blockquote>\n<p>But this does not <em>just</em> mean that all template-parameters of the partial specialization have to be deduced; it also means that substitution must succeed and (as it seems?) the template arguments have to match the (substituted) template parameters of the partial specialization. Note that I'm not completely aware of <em>where</em> the Standard specifies the comparison between the substituted argument list and the supplied argument list.</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2017-11-21T11:54:07.987", "Score": "91", "CreationDate": "2014-12-29T11:56:55.730", "ParentId": "27687389", "CommentCount": "14", "OwnerUserId": "420683", "LastEditDate": "2017-11-21T11:54:07.987"}, "27687389": {"ViewCount": "8249", "Body": "<p>I watched Walter Brown's talk at Cppcon14 about modern template programming (<a href=\"http://youtu.be/Am2is2QCvxY\" rel=\"noreferrer\">Part I</a>, <a href=\"http://youtu.be/a0FliKwcwXE\" rel=\"noreferrer\">Part II</a>) where he presented his <code>void_t</code> SFINAE technique.</p>\n<p>Example:<br>\nGiven a simple variable template that evaluates to <code>void</code> if all template arguments are well formed:</br></p>\n<pre><code>template&lt; class ... &gt; using void_t = void;\n</code></pre>\n<p>and the following trait that checks for the existence of a member variable called <em>member</em>:</p>\n<pre><code>template&lt; class , class = void &gt;\nstruct has_member : std::false_type\n{ };\n\n// specialized as has_member&lt; T , void &gt; or discarded (sfinae)\ntemplate&lt; class T &gt;\nstruct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : std::true_type\n{ };\n</code></pre>\n<p>I tried to understand why and how this works. Therefore a tiny example:</p>\n<pre><code>class A {\npublic:\n    int member;\n};\n\nclass B {\n};\n\nstatic_assert( has_member&lt; A &gt;::value , \"A\" );\nstatic_assert( has_member&lt; B &gt;::value , \"B\" );\n</code></pre>\n<p><strong>1.</strong> <code>has_member&lt; A &gt;</code></p>\n<ul>\n<li><code>has_member&lt; A , void_t&lt; decltype( A::member ) &gt; &gt;</code>\n<ul>\n<li><code>A::member</code> exists</li>\n<li><code>decltype( A::member )</code> is well-formed</li>\n<li><code>void_t&lt;&gt;</code> is valid and evaluates to <code>void</code></li>\n</ul></li>\n<li><code>has_member&lt; A , void &gt;</code> and therefore it chooses the specialized template</li>\n<li><code>has_member&lt; T , void &gt;</code> and evaluates to <code>true_type</code></li>\n</ul>\n<p><strong>2.</strong> <code>has_member&lt; B &gt;</code></p>\n<ul>\n<li><code>has_member&lt; B , void_t&lt; decltype( B::member ) &gt; &gt;</code>\n<ul>\n<li><code>B::member</code> does not exist</li>\n<li><code>decltype( B::member )</code> is ill-formed and fails silently (sfinae)</li>\n<li><code>has_member&lt; B , expression-sfinae &gt;</code> so this template is discarded</li>\n</ul></li>\n<li>compiler finds <code>has_member&lt; B , class = void &gt;</code> with void as default argument</li>\n<li><code>has_member&lt; B &gt;</code> evaluates to <code>false_type</code></li>\n</ul>\n<p><a href=\"http://ideone.com/HCTlBb\" rel=\"noreferrer\">http://ideone.com/HCTlBb</a></p>\n<p>Questions:<br>\n1. Is my understanding of this correct?<br>\n2. Walter Brown states that the default argument has to be the exact same type as the one used in <code>void_t</code> for it to work. Why is that? (I don't see why this types need to match, doesn't just any default type does the job?)  </br></br></p>\n", "AcceptedAnswerId": "27688405", "Title": "How does `void_t` work", "CreationDate": "2014-12-29T10:47:15.347", "Id": "27687389", "CommentCount": "3", "FavoriteCount": "55", "PostTypeId": "1", "LastEditDate": "2016-04-08T22:19:04.187", "LastEditorUserId": "220481", "LastActivityDate": "2017-11-21T11:54:07.987", "Score": "100", "OwnerUserId": "3087952", "Tags": "<c++><templates><c++14><sfinae>", "AnswerCount": "2"}});