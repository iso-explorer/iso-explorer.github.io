post_cb({"bq_ids": {"n4140": {"so_26040452_26040651_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 7040}, "so_26040452_26040651_3": {"length": 18, "quality": 0.6428571428571429, "section_id": 5971}, "so_26040452_26040720_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 7040}}, "n3337": {"so_26040452_26040651_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 6785}, "so_26040452_26040651_3": {"length": 27, "quality": 0.9642857142857143, "section_id": 5739}, "so_26040452_26040720_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6785}}, "n4659": {"so_26040452_26040651_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 8537}, "so_26040452_26040651_3": {"length": 18, "quality": 0.6428571428571429, "section_id": 7470}, "so_26040452_26040720_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 8537}}}, "26040651": {"Id": "26040651", "PostTypeId": "2", "Body": "<p>If we go to cppreference page on <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">lambda function</a> they have the following explanation:</p>\n<blockquote>\n<p id=\"so_26040452_26040651_0\">[=] captures all automatic variables mentioned in the body of the lambda by value </p>\n</blockquote>\n<p>and further says:</p>\n<blockquote>\n<p id=\"so_26040452_26040651_1\">The capture-list is a comma-separated list of zero or more captures, optionally beginning with the capture-default. The only capture defaults are &amp; (implicitly catch the odr-used automatic variables and this by reference) <strong>and = (implicitly catch the odr-used automatic variables and this by value).</strong></p>\n</blockquote>\n<p>The reference section for <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow\">odr-used</a> says:</p>\n<blockquote>\n<p id=\"so_26040452_26040651_2\">a variable is odr-used if its name appears as a potentially-evaluated expression, except if all of the following is\n  true:</p>\n<ul>\n<li>applying lvalue-to-rvalue conversion to the exression yields a constant expression that doesn't invoke non-trivial functions</li>\n<li>the expression is either discarded-value expression or an lvalue-to-rvalue conversion </li>\n</ul>\n</blockquote>\n<p>The exceptions do not apply to <code>i</code> so <code>i</code> will be captured.</p>\n<p>Which agrees with the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>5.1.2</code> <em>Lambda expressions</em> paragraph <em>11</em> which says:</p>\n<blockquote>\n<p id=\"so_26040452_26040651_3\">If a lambda-expression has an associated capture-default and its\n  compound-statement odr-uses (3.2) this or a variable with automatic\n  storage duration and the odr-used entity is not explicitly captured,\n  then the odr-used entity is said to be implicitly captured; such\n  entities shall be declared within the reaching scope of the lambda\n  expression.</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-27T17:28:11.580", "Score": "2", "CreationDate": "2014-09-25T14:04:24.740", "ParentId": "26040452", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-09-27T17:28:11.580"}, "26040452": {"ViewCount": "313", "Body": "<p>Given the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nusing namespace std;\nint main() {\n    std::shared_ptr&lt;int&gt; i(new int(42));\n    cout &lt;&lt; i.use_count() &lt;&lt; endl;\n    auto fn = [=](){i; cout &lt;&lt; 42 &lt;&lt; endl;};\n    cout &lt;&lt; i.use_count() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>When does the compiler decide which objects it will capture?<br>\nThe shared_ptr <code>i</code> is never used in the lambda expression. So in a normal function I would assume that the optimizer will remove this nop statement.<br>\nBut if it is removed the compiler could think that <code>i</code> needs not to be captured.</br></br></p>\n<p>So with gcc this program will always produce 1,2 as an output.<br>\nBut is this guaranteed by the standard?</br></p>\n", "AcceptedAnswerId": "26040651", "Title": "Lifetime of lambda captures", "CreationDate": "2014-09-25T13:55:26.347", "Id": "26040452", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-09-26T02:26:40.383", "LastEditorUserId": "1708801", "LastActivityDate": "2014-09-27T17:28:11.580", "Score": "4", "OwnerUserId": "264338", "Tags": "<c++><lambda>", "AnswerCount": "2"}, "26040720": {"Id": "26040720", "PostTypeId": "2", "Body": "<p>With a default-capture of <code>[=]</code>, any local variable is captured if it's <em>odr-used</em> within the lambda. The definition of <em>odr-used</em> is:</p>\n<blockquote>\n<p id=\"so_26040452_26040720_0\">A variable whose name appears as a potentially-evaluated expression is <em>odr-used</em> unless it is an object that satisfies the requirements for appearing in a constant expression and the lvalue-to-rvalue conversion is immediately applied.</p>\n</blockquote>\n<p>Here, <code>i</code> is an evaluated expression, and isn't a constant; so it is <code>odr-used</code> and therefore is captured; whether or not evaluating the expression has any effect.</p>\n<blockquote>\n<p id=\"so_26040452_26040720_1\">But is this guaranteed by the standard?</p>\n</blockquote>\n<p>tl;dr yes.</p>\n", "LastActivityDate": "2014-09-25T14:07:50.830", "CommentCount": "0", "CreationDate": "2014-09-25T14:07:50.830", "ParentId": "26040452", "Score": "2", "OwnerUserId": "204847"}});