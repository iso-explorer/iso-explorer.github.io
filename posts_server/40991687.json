post_cb({"40991805": {"ParentId": "40991687", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Are you catching the exception? When catching the exception, valgrind <em>(compiling with <strong>g++ 6.2</strong> <code>-g</code>)</em> detects no leaks both with <code>make_unique</code> and <code>reset</code>.</p>\n<pre><code>int main() try\n{\n#if TEST_MAKE_UNIQUE\n    std::unique_ptr&lt;Foo&gt; l_ptr = std::make_unique&lt;Foo&gt;();   \n#else\n    std::unique_ptr&lt;Foo&gt; l_ptr;\n    l_ptr.reset(new Foo());\n#endif\n}\ncatch(...)\n{\n\n}\n</code></pre>\n<p><em>AddressSanitizer</em> does not report any issue as well.</p>\n<p><em>(P.S. this was a nice opportunity to show off the less known <a href=\"http://en.cppreference.com/w/cpp/language/function-try-block\" rel=\"nofollow noreferrer\">function-try-block</a> language feature.)</em></p>\n<hr>\n<blockquote>\n<p id=\"so_40991687_40991805_0\"><em>\"Why doesn't the memory get leaked?\"</em></p>\n</blockquote>\n<p>The standard guarantees that the memory allocated with a <em>\"<code>new</code> expression\"</em> will be automatically freed if an exception is thrown during construction.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/except.ctor#exception_handling,constructors_and_destructors\" rel=\"nofollow noreferrer\">From <strong>$15.2.5</strong>:</a></p>\n<blockquote>\n<p id=\"so_40991687_40991805_1\">If the object was allocated by a new-expression ([expr.new]), the matching deallocation function ([basic.stc.dynamic.deallocation]), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n<hr>\n<p>Related questions:</p>\n<ul>\n<li><p><a href=\"https://stackoverflow.com/questions/4094996/what-happens-to-the-memory-allocated-by-new-if-the-constructor-throws\">\"What happens to the memory allocated by <code>new</code> if the constructor throws?\"</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/14269219/stdunique-ptrreset-and-constructor-exceptions\">\"std::unique_ptr::reset and constructor exceptions\"</a></p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/1197566/is-it-ever-not-safe-to-throw-an-exception-in-a-constructor\">\"Is it ever not safe to throw an exception in a constructor?\"</a></p></li>\n</ul>\n</hr></hr>", "OwnerUserId": "598696", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:58.417", "Id": "40991805", "Score": "9", "CreationDate": "2016-12-06T09:24:14.703", "LastActivityDate": "2016-12-06T09:38:31.297"}, "41001856": {"ParentId": "40991687", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>make_unique</code> can be used to avoid a memory leak in certain circumstances, e.g.:</p>\n<pre><code>int foo();\nvoid bar(unique_ptr&lt;int&gt; a, int b);\n\nint main()\n{\n    try\n    {\n         bar(unique_ptr&lt;int&gt;(new int(5)), foo());\n    }\n    catch (...) {/*TODO*/}\n}\n</code></pre>\n<p>It is possible here for the call to <code>new</code> to happen first, and the call to <code>foo()</code> then may happen before the <code>unique_ptr&lt;int&gt;</code> construction. If <code>foo()</code> throws, then the <code>int</code> will be leaked. This is not possible if <code>make_unique</code> is used instead:</p>\n<pre><code>int foo();\nvoid bar(unique_ptr&lt;int&gt; a, int b);\n\nint main()\n{\n    try\n    {\n        bar(make_unique&lt;int&gt;(5), foo());\n    }\n    catch (...) {/*TODO*/}\n}\n</code></pre>\n<p>In this case, either <code>foo()</code> is called first, and no <code>int</code> is created if it throws, or <code>make_unique&lt;int&gt;(5)</code> is called first, and allowed to finish. If <code>foo()</code> then throws, the <code>int</code> will be deleted during stack unwinding via the destructor of the temporary <code>unique_ptr&lt;int&gt;</code>.</p>\n<p>If you don't put anything else that can throw inside the same statement, as with the call to <code>l_ptr.reset(new Foo());</code>, then <code>make_unique</code> does not improve safety. It may still be more convenient, though.</p>\n<p>If you don't catch a thrown exception, the stack may or may not be unwound. In a multi-threaded program, you can even trigger undefined behavior by letting exceptions \"escape\" from a thread. In short, don't do that.</p>\n<p><strong>UPDATE</strong> In C++17, the above <code>bar(unique_ptr&lt;int&gt;(new int(5)), foo());</code> is also exception safe, because the evaluation of function arguments is no longer <em>unsequenced</em> but now <em>indeterminately sequenced</em>. This means the compiler has to guarantee that there is an order, it just doesn't have to tell you <em>which</em> order. See Barry's response to <a href=\"https://stackoverflow.com/questions/38501587/what-are-the-evaluation-order-guarantees-introduced-by-c17\">this question</a>.</p>\n", "OwnerUserId": "4083309", "LastEditorUserId": "4083309", "LastEditDate": "2017-11-20T11:52:25.710", "Id": "41001856", "Score": "2", "CreationDate": "2016-12-06T17:58:21.323", "LastActivityDate": "2017-11-20T11:52:25.710"}, "41007104": {"ParentId": "40991687", "CommentCount": "0", "Body": "<p>As mentioned in other responses, valgrind is complaining that you're leaking memory as the result of having an uncaught exception, which in turn calls <code>std::terminate</code>, which in turn leaves everything as it is.  If the executable does not terminate (e.g., you catch the exception somewhere), the memory will be freed automatically by the language's definition of how <code>new</code> behaves.</p>\n<p>It seems like you're asking a deeper question about why <code>std::make_unique</code> exists.  This exists for a situation like:</p>\n<pre><code>some_func(new Foo, new Foo);\n</code></pre>\n<p>In just such a case, the language makes no guarantees about when <code>new</code> gets called vs. when <code>Foo::Foo()</code> gets called.  You may have the compiler organize things a bit such that <code>new</code> gets called twice, once to allocate space for the first parameter, and once to allocate space for the second parameter.  Then <code>Foo()</code> gets constructed, throws an exception.  The first allocation gets cleared up, but the second one will have leaked because there was no construction (or exception there)!  Queue <code>make_unique</code>:</p>\n<pre><code>some_func(std::make_unique&lt;Foo&gt;(), std::make_unique&lt;Foo&gt;());\n</code></pre>\n<p>Now that we are calling a function, the <code>new</code> will be called before the constructor for each parameter <em>in that order.</em>  If the first parameter throws an exception, the second allocation won't even have happened.</p>\n<p>Vs. <code>unique_ptr::reset</code> we just have convenience.  You should not see any issues with memory leaks because of the defined <code>new</code> behavior with throwing exceptions.</p>\n", "OwnerUserId": "7257958", "PostTypeId": "2", "Id": "41007104", "Score": "0", "CreationDate": "2016-12-06T23:56:53.870", "LastActivityDate": "2016-12-06T23:56:53.870"}, "bq_ids": {"n4140": {"so_40991687_40991805_1": {"section_id": 3344, "quality": 0.8571428571428571, "length": 12}, "so_40991687_40991687_0": {"section_id": 6101, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_40991687_40991805_1": {"section_id": 3214, "quality": 0.8571428571428571, "length": 12}, "so_40991687_40991687_0": {"section_id": 5867, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_40991687_40991805_1": {"section_id": 4112, "quality": 0.8571428571428571, "length": 12}, "so_40991687_40991687_0": {"section_id": 7598, "quality": 0.5384615384615384, "length": 7}}}, "40991687": {"CommentCount": "1", "ViewCount": "897", "CreationDate": "2016-12-06T09:16:46.643", "LastActivityDate": "2017-11-20T11:52:25.710", "Title": "std::make_unique<T> vs reset(new T)", "FavoriteCount": "1", "PostTypeId": "1", "Id": "40991687", "Score": "4", "Body": "<p>I want to ask a question about memory leaks in constructor. Let's consider a class:</p>\n<pre><code> class Foo\n {\n   public:\n      Foo(){ throw 500;} \n };\n</code></pre>\n<p>What is the difference between </p>\n<pre><code>std::unique_ptr&lt;Foo&gt; l_ptr = std::make_unique&lt;Foo&gt;();\n</code></pre>\n<p>and </p>\n<pre><code>std::unique_ptr&lt;Foo&gt; l_ptr;\nl_ptr.reset(new Foo());\n</code></pre>\n<p>In my opinion a solution with make_unique should protect me from memory leak but in both situations I got the same valgrind result:</p>\n<pre><code>$ valgrind --leak-check=full ./a.out\n==17611== Memcheck, a memory error detector\n==17611== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.\n==17611== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info\n==17611== Command: ./a.out\n==17611== \nterminate called after throwing an instance of 'int'\n==17611== \n==17611== Process terminating with default action of signal 6 (SIGABRT)\n==17611==    at 0x5407418: raise (raise.c:54)\n==17611==    by 0x5409019: abort (abort.c:89)\n==17611==    by 0x4EC984C: __gnu_cxx::__verbose_terminate_handler() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==17611==    by 0x4EC76B5: ??? (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==17611==    by 0x4EC7700: std::terminate() (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==17611==    by 0x4EC7918: __cxa_throw (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==17611==    by 0x40097B: Foo::Foo() (in /home/rungo/Repositories/test/a.out)\n==17611==    by 0x4008DC: main (in /home/rungo/Repositories/test/a.out)\n==17611== \n==17611== HEAP SUMMARY:\n==17611==     in use at exit: 72,837 bytes in 3 blocks\n==17611==   total heap usage: 4 allocs, 1 frees, 72,841 bytes allocated\n==17611== \n==17611== 132 bytes in 1 blocks are possibly lost in loss record 2 of 3\n==17611==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==17611==    by 0x4EC641F: __cxa_allocate_exception (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21)\n==17611==    by 0x400963: Foo::Foo() (in /home/rungo/Repositories/test/a.out)\n==17611==    by 0x4008DC: main (in /home/rungo/Repositories/test/a.out)\n==17611== \n==17611== LEAK SUMMARY:\n==17611==    definitely lost: 0 bytes in 0 blocks\n==17611==    indirectly lost: 0 bytes in 0 blocks\n==17611==      possibly lost: 132 bytes in 1 blocks\n==17611==    still reachable: 72,705 bytes in 2 blocks\n==17611==         suppressed: 0 bytes in 0 blocks\n==17611== Reachable blocks (those to which a pointer was found) are not shown.\n==17611== To see them, rerun with: --leak-check=full --show-leak-kinds=all\n==17611== \n==17611== For counts of detected and suppressed errors, rerun with: -v\n==17611== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n[1]    17611 abort (core dumped)  valgrind --leak-check=full ./a.out\n</code></pre>\n<p>It is the same when I use clang++ and g++.\nI found here: <a href=\"https://isocpp.org/wiki/faq/exceptions#ctors-can-throw\" rel=\"nofollow noreferrer\">https://isocpp.org/wiki/faq/exceptions#ctors-can-throw</a> the sentence: </p>\n<blockquote>\n<p id=\"so_40991687_40991687_0\">Note: if a constructor finishes by throwing an exception, the memory associated with the object itself is cleaned up \u2014 there is no memory leak.</p>\n</blockquote>\n<p>My question is why we have a leak in this situation and why make_unique is not preventing a leak (doeas it means that there is no dofference between make_unique and reset(new ...)?</p>\n", "Tags": "<c++><c++11><memory-leaks><smart-pointers><unique-ptr>", "OwnerUserId": "3989196", "AnswerCount": "3"}});