post_cb({"bq_ids": {"n4140": {"so_26754107_26754423_3": {"length": 4, "quality": 0.8, "section_id": 611}, "so_26754107_26754423_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 625}, "so_26754107_26754423_1": {"length": 30, "quality": 0.967741935483871, "section_id": 623}, "so_26754107_26754423_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 625}}, "n3337": {"so_26754107_26754423_1": {"length": 31, "quality": 1.0, "section_id": 613}, "so_26754107_26754423_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 615}, "so_26754107_26754423_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 615}, "so_26754107_26754423_3": {"length": 4, "quality": 0.8, "section_id": 601}}, "n4659": {"so_26754107_26754423_3": {"length": 4, "quality": 0.8, "section_id": 637}, "so_26754107_26754423_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 651}, "so_26754107_26754423_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 651}, "so_26754107_26754423_1": {"length": 30, "quality": 0.967741935483871, "section_id": 649}}}, "26754107": {"ViewCount": "76", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt; struct CSizex {\n};\n\nstruct CSize : public CSizex&lt;int&gt; \n{\n};\n\nstruct Logger\n{\n    template &lt;typename T&gt; \n    Logger&amp; operator&lt;&lt; (T&amp; value)\n    {\n        return *this &lt;&lt; const_cast&lt;const T &amp; &gt;(value);\n    }\n\n    template &lt;typename T&gt; Logger&amp; operator&lt;&lt;(const CSizex&lt;T&gt;&amp; size)\n    {\n        std::cout &lt;&lt; __FUNCSIG__;\n        return *this;\n    }\n\n    template &lt;typename T&gt; \n    Logger&amp; operator&lt;&lt; (const T&amp; value)\n    {\n        static_assert(std::is_arithmetic&lt;T&gt;::value || std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value, \"This method is only meant for arithmetic types\");\n        std::cout &lt;&lt; __FUNCSIG__;\n        return *this;\n    }\n};\n\nint main()\n{\n    CSize size;\n    Logger() &lt;&lt; CSize();\n    return 0;\n}\n</code></pre>\n<p>When I do this:</p>\n<pre><code>Logger() &lt;&lt; CSize();\n</code></pre>\n<p>the compiler is trying to instantiate <code>Logger&amp; operator&lt;&lt;(const T&amp; value)</code> overload, which, of course, fails with <code>static_assert</code>. Why isn't <code>Logger&amp; operator&lt;&lt;(const CSizex&lt;T&gt;&amp; size)</code>  considered a better match? How can I implement what I want?</p>\n", "AcceptedAnswerId": "26754423", "Title": "Overloaded template method not resolved as expected", "CreationDate": "2014-11-05T09:55:41.990", "Id": "26754107", "CommentCount": "12", "LastEditDate": "2014-11-05T14:03:04.563", "PostTypeId": "1", "LastEditorUserId": "634821", "LastActivityDate": "2014-11-05T14:53:13.553", "Score": "3", "OwnerUserId": "634821", "Tags": "<c++><templates>", "AnswerCount": "1"}, "26754423": {"Id": "26754423", "PostTypeId": "2", "Body": "<p>In a fact, <code>const CSizex&lt;T&gt;&amp;</code> is an <em>exact</em> match as it is an identity conversion; [over.ics.ref]/1:</p>\n<blockquote>\n<p id=\"so_26754107_26754423_0\">When a parameter of reference type binds directly to an argument\n  expression, the implicit conversion sequence is the identity\n  conversion, unless the argument expression has a type that is a\n  derived class of the parameter type, in which case the implicit\n  conversion sequence is a derived-to-base Conversion (13.3.3.1).</p>\n</blockquote>\n<p>The specialization instantiated from the template that causes the error is also an exact match:\n[over.ics.user]/4:</p>\n<blockquote>\n<p id=\"so_26754107_26754423_1\">A conversion of an expression of class type to the same class type is\n  given Exact Match rank, and a conversion of an expression of class\n  type to a base class of that type is given Conversion rank, in spite\n  of the fact that a copy/move constructor (i.e., a user-defined\n  conversion function) is called for those cases.</p>\n</blockquote>\n<p>However, the first template is more specialized than the second. After removing references and cv-qualifiers from the parameters and argument types of both the original and the transformed templates we then, for a unique type <code>Unique</code>, deduce the argument of the transformed template against the parameter of the original template of the other template: <code>Unique</code> is deduced against <code>CSizex&lt;T&gt;</code>, which yields a deduction failure (since <code>Unique</code> is no specialization of <code>CSizex</code>), while <code>CSizex&lt;Unique&gt;</code> deduced against <code>T</code> would be successful (with <code>T</code> being <code>CSizex&lt;Unique&gt;</code> itself). So the first template is more specialized and should thus be selected by partial ordering.<br>\n<a href=\"http://coliru.stacked-crooked.com/a/6be39f4fa68f360f\" rel=\"nofollow\">Clang compiles this correctly.</a> So does <a href=\"http://coliru.stacked-crooked.com/a/bf8aea8247cb9a98\" rel=\"nofollow\">GCC 4.9.0</a>. Perhaps you reduced your problem to a code that does not reflect the mistake anymore.</br></p>\n<p><hr/></p>\n<h3>Updated:</h3>\n<p>Now, we consider</p>\n<pre><code>template &lt;typename T&gt;\nLogger&amp; operator&lt;&lt;(const CSizex&lt;T&gt;&amp; size); // #1\n\ntemplate &lt;typename T&gt; \nLogger&amp; operator&lt;&lt; (const T&amp; value);       // #2\n</code></pre>\n<p>For #2, the argument is deduced as <code>CSize</code> so the parameter is <code>CSize const&amp;</code>, while for #1 the parameter of the specialization is <code>CSize&lt;int&gt; const&amp;</code>.\nOverload resolution clearly states in the above quote:</p>\n<blockquote>\n<p id=\"so_26754107_26754423_2\">When a parameter of reference type binds directly to an argument\n  expression, the implicit conversion sequence is the identity\n  conversion, unless the argument expression has a type that is a\n  derived class of the parameter type, in which case the implicit\n  conversion sequence is a derived-to-base Conversion (13.3.3.1).</p>\n</blockquote>\n<p>... that the conversion is an identity conversion for #2 but a derived-to-base conversion for #1. It is not hard to see that #2 is selected due to the better rank, [over.best.ics]/6:</p>\n<blockquote>\n<p id=\"so_26754107_26754423_3\">A derived-to-base Conversion has Conversion rank (13.3.3.1.1).</p>\n</blockquote>\n<p>... and identity conversions have Exact Match rank.<br><br>\nBasically it should suffice to move the condition of the static assertion into <code>enable_if</code>:</br></br></p>\n<pre><code>struct Logger\n{\n    template &lt;typename T&gt;\n    Logger&amp; operator&lt;&lt;(const CSizex&lt;T&gt;&amp; size)\n    {\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n';\n        return *this;\n    }\n\n    template &lt;typename T&gt;\n    typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value\n                         || std::is_integral&lt;T&gt;::value \n                         || std::is_enum&lt;T&gt;::value, Logger&amp;&gt;::type\n    operator&lt;&lt;(const T&amp; value)\n    {\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n';\n        return *this;\n    }\n};\n</code></pre>\n<p><a href=\"http://ideone.com/Ur4zVu\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-05T14:53:13.553", "Score": "2", "CreationDate": "2014-11-05T10:09:29.597", "ParentId": "26754107", "CommentCount": "11", "LastEditDate": "2014-11-05T14:53:13.553", "OwnerUserId": "3647361"}});