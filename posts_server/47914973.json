post_cb({"bq_ids": {"n4140": {"so_47914973_47915181_0": {"length": 18, "quality": 1.0, "section_id": 3327}, "so_47914973_47915039_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6955}}, "n3337": {"so_47914973_47915181_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 3197}, "so_47914973_47915039_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 6702}}, "n4659": {"so_47914973_47915181_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 4093}, "so_47914973_47915039_0": {"length": 8, "quality": 0.6666666666666666, "section_id": 8452}}}, "47914973": {"ViewCount": "208", "Body": "<p>When using an initializer list such as this:</p>\n<pre><code>for (int i : {3, 1, 6, 4})\n{\n    std::cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The ouput is in the same order, 3, 1, 6, and finally 4.  So I know the compiler must be using something similar to <code>std::vector&lt;int&gt;</code> and not <code>std::set&lt;int&gt;</code>.</p>\n<p>Is this guaranteed?  Where can I find the docs that explain how the compiler must interpret <code>{3, 1, 6, 4}</code>.</p>\n", "AcceptedAnswerId": "47915181", "Title": "What does a C++ compiler do with this initializer list?", "CreationDate": "2017-12-20T22:01:25.333", "Id": "47914973", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-12-20T22:42:27.397", "Score": "4", "OwnerUserId": "13022", "Tags": "<c++><c++11><initializer-list>", "AnswerCount": "2"}, "47915039": {"Id": "47915039", "PostTypeId": "2", "Body": "<p>You are creating an instance of <code>std::initializer_list&lt;int&gt;</code>. See <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/initializer_list</a> for details.</p>\n<p>From that page:</p>\n<blockquote>\n<p id=\"so_47914973_47915039_0\">An object of type <code>std::initializer_list&lt;T&gt;</code> is a lightweight proxy object that provides access to an array of objects of type <code>const T</code>.</p>\n</blockquote>\n<p>The output order is guaranteed. However, that's not because the compiler creates a <code>std::vector&lt;int&gt;</code>. It is guaranteed because there is an array of <code>int</code>s underneath the <code>initializer_list</code>.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2017-12-20T22:42:27.397", "Score": "9", "CreationDate": "2017-12-20T22:07:14.947", "ParentId": "47914973", "CommentCount": "4", "OwnerUserId": "434551", "LastEditDate": "2017-12-20T22:42:27.397"}, "47915181": {"Id": "47915181", "PostTypeId": "2", "Body": "<p>Your <a href=\"http://en.cppreference.com/w/cpp/language/range-for\" rel=\"noreferrer\">range based loop</a> is using the <a href=\"http://en.cppreference.com/w/cpp/language/list_initialization\" rel=\"noreferrer\">braced-init-list</a> as a range expression which constructs a temporary object of type <a href=\"https://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"noreferrer\">std::initializer_list&lt;int&gt;</a>. The order is guaranteed because the 8.5.4.5. paragraph of the <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4140.pdf?raw=true\" rel=\"noreferrer\">n4140 draft / standard</a> states (emphasis mine):</p>\n<blockquote>\n<p id=\"so_47914973_47915181_0\">An object of type std::initializer_list&lt;E&gt; is constructed from an\n  initializer list <strong>as if</strong> the implementation allocated a temporary\n  <strong>array of N elements</strong> of type const E, where N is the number of\n  elements in the initializer list.</p>\n</blockquote>\n", "LastEditorUserId": "8751754", "LastActivityDate": "2017-12-20T22:40:48.217", "Score": "6", "CreationDate": "2017-12-20T22:18:58.787", "ParentId": "47914973", "CommentCount": "0", "OwnerUserId": "8751754", "LastEditDate": "2017-12-20T22:40:48.217"}});