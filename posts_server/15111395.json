post_cb({"15111422": {"ParentId": "15111395", "CommentCount": "1", "CreationDate": "2013-02-27T11:51:47.593", "OwnerUserId": "1904007", "PostTypeId": "2", "Id": "15111422", "Score": "2", "Body": "<p>Because strings a NULL-treminated. You have extra character at string literal '\\0'</p>\n", "LastActivityDate": "2013-02-27T11:51:47.593"}, "15111395": {"CommentCount": "4", "AcceptedAnswerId": "15111434", "ClosedDate": "2013-02-27T20:42:28.033", "CreationDate": "2013-02-27T11:50:17.523", "LastActivityDate": "2013-02-27T11:57:28.240", "PostTypeId": "1", "ViewCount": "87", "FavoriteCount": "3", "Title": "C++ Comparing the length of two similar arrays", "Id": "15111395", "Score": "1", "Body": "<p>I believe Array1 and Array2 are declared differently but they both do have the same type - char. Both Array1 and Array2 seem to contain the same exact values and the same amount of values. I don't understand why their length are different from each other. Can someone please explain why?</p>\n<pre><code>char Array1[ ] = { 1, 2, 3, 4, 5 };\nchar Array2[ ] = \"\\x01\\x02\\x03\\x04\\x05\";\n\nstd::cout &lt;&lt; \"Length of Array1 = \" &lt;&lt; sizeof( Array1 )/sizeof( *Array1 )\n          &lt;&lt; std::endl\n          &lt;&lt; \"Length of Array2 = \" &lt;&lt; sizeof( Array2 )/sizeof( *Array2 );\n</code></pre>\n<p>Output:</p>\n<pre><code>Length of Array1 = 5\nLength of Array2 = 6\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "2014656", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15111395_15111434_0": {"section_id": 5363, "quality": 1.0, "length": 16}}, "n3337": {"so_15111395_15111434_0": {"section_id": 5159, "quality": 1.0, "length": 16}}, "n4659": {"so_15111395_15111434_0": {"section_id": 6787, "quality": 1.0, "length": 16}}}, "15111434": {"ParentId": "15111395", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-02-27T11:52:20.427", "Score": "5", "LastEditorUserId": "1033896", "LastEditDate": "2013-02-27T11:57:28.240", "Id": "15111434", "OwnerUserId": "1033896", "Body": "<p>The second array has an extra character due to the implicit null terminating character present in the string literal.</p>\n<p>From section <em>2.14.5 String literals</em> of the C++11 standard (draft n3337) point 14 states:</p>\n<blockquote>\n<p id=\"so_15111395_15111434_0\">After any necessary concatenation, in translation phase 7 (2.2), <strong>\u2019\\0\u2019 is appended to every string literal</strong> so\n  that programs that scan a string can find its end.</p>\n</blockquote>\n", "LastActivityDate": "2013-02-27T11:57:28.240"}});