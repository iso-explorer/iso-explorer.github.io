post_cb({"1875377": {"Id": "1875377", "PostTypeId": "2", "Body": "<p>MSVC allows explicit specialization at class scope whereas the standard does not.</p>\n<p>From what I can see, the code you're giving comes from a class definition. Specialize outside the scope of the class.</p>\n<pre><code>template&lt;&gt; inline std::string Foo::getValue&lt;std::string&gt;(const_iterator key)const {\n    return key-&gt;second;\n}\n\ntemplate&lt;&gt; inline std::string Foo::getValue&lt;std::string&gt;(const std::string &amp;key)const {\n    const_iterator i = find(key);\n    if(i == end())throw KeyNotFound(name,key);\n    else return i-&gt;second;\n}\n</code></pre>\n<p>See:</p>\n<blockquote>\n<p id=\"so_1875296_1875377_0\">14.7.3.2:</p>\n<p id=\"so_1875296_1875377_1\">An explicit specialization shall be declared in the namespace of \n  which the template is a member, or, for member templates, in the \n  namespace of which the enclosing class or enclosing class template is \n  a member. An explicit specialization of a member function, member \n  class or static data member of a class template shall be declared in \n  the namespace of which the class template is a member.</p>\n</blockquote>\n", "LastEditorUserId": "216063", "LastActivityDate": "2009-12-09T17:28:01.603", "Score": "3", "CreationDate": "2009-12-09T17:11:25.797", "ParentId": "1875296", "CommentCount": "0", "OwnerUserId": "216063", "LastEditDate": "2009-12-09T17:28:01.603"}, "bq_ids": {"n4140": {"so_1875296_1875377_1": {"length": 18, "quality": 0.5806451612903226, "section_id": 150}}, "n3337": {"so_1875296_1875377_1": {"length": 18, "quality": 0.5806451612903226, "section_id": 144}}, "n4659": {"so_1875296_1875377_1": {"length": 18, "quality": 0.5806451612903226, "section_id": 154}}}, "1875369": {"Id": "1875369", "PostTypeId": "2", "Body": "<p>You haven't shown the class definition enclosing these function-declarations. But i assume it's some class where these templates are declared in. You have to define the specializations outside:</p>\n<pre><code>struct SomeClass {\n   template&lt;typename T&gt; T getValue(const_iterator key)const\n    {\n        try{return boost::lexical_cast&lt;T&gt;(key-&gt;second);}\n        catch(boost::bad_lexical_cast &amp;e)\n        {\n            throw TypeParseError&lt;T&gt;(name, key-&gt;first, e.what());\n        }\n    }\n    template&lt;typename T&gt; T getValue(const std::string &amp;key)const\n    {\n        iterator i = find(key);\n        if(i == end())throw KeyNotFound(name,key);\n        else return getValue(i);\n    }\n};\n\ntemplate&lt;&gt; inline std::string SomeClass::getValue&lt;std::string&gt;(const_iterator key)const {\n    return key-&gt;second;\n}\n\ntemplate&lt;&gt; inline std::string SomeClass::getValue&lt;std::string&gt;(const std::string &amp;key)const {\n    const_iterator i = find(key);\n    if(i == end())throw KeyNotFound(name,key);\n    else return i-&gt;second;\n}\n</code></pre>\n<p>Remember that since you have defined them outside, they are not inline implicitly, so you either have to make them inline explicitly, or move them into a <code>cpp</code> file (not a header), and forward-declare the specializations in the header like this:</p>\n<pre><code>template&lt;&gt; inline std::string SomeClass::getValue&lt;std::string&gt;(const_iterator key)const;\ntemplate&lt;&gt; inline std::string SomeClass::getValue&lt;std::string&gt;(const std::string &amp;key)const;\n</code></pre>\n<p>If you omit the forward-declaration, the compiler has no way to know whether to instantiate the functions or to use the explicit specializations. The forward declaration tells it. </p>\n", "LastActivityDate": "2009-12-09T17:09:39.600", "CommentCount": "1", "CreationDate": "2009-12-09T17:09:39.600", "ParentId": "1875296", "Score": "7", "OwnerUserId": "34509"}, "1875296": {"ViewCount": "228", "Body": "<p>I'm trying to port some code from VC9 to G++, however Ive run into a problem with template specialisations apparently not being allowed for class members.</p>\n<p>The following code is an example of these errors for the getValue specialisations of the class methods. In all cases the error is \"error: explicit specialization in non-namespace scope <code>class ...</code>\"</p>\n<pre><code>template&lt;typename T&gt; T getValue(const_iterator key)const\n{\n    try{return boost::lexical_cast&lt;T&gt;(key-&gt;second);}\n    catch(boost::bad_lexical_cast &amp;e)\n    {\n        throw TypeParseError&lt;T&gt;(name, key-&gt;first, e.what());\n    }\n}\ntemplate&lt;typename T&gt; T getValue(const std::string &amp;key)const\n{\n    iterator i = find(key);\n    if(i == end())throw KeyNotFound(name,key);\n    else return getValue(i);\n}\ntemplate&lt;&gt; std::string getValue&lt;std::string&gt;(const_iterator key)const\n{\n    return key-&gt;second;\n}\ntemplate&lt;&gt; std::string getValue&lt;std::string&gt;(const std::string &amp;key)const\n{\n    const_iterator i = find(key);\n    if(i == end())throw KeyNotFound(name,key);\n    else return i-&gt;second;\n}\n</code></pre>\n<p>Is it just the exact syntax is not supported, and that a minor change will make it work, or will I need to change the code to avoid specialisations like this? If the latter which is the best way to do so in general?</p>\n", "AcceptedAnswerId": "1875369", "Title": "Problem with class template specialisations", "CreationDate": "2009-12-09T17:00:13.443", "Id": "1875296", "CommentCount": "0", "LastEditDate": "2009-12-09T17:29:50.540", "PostTypeId": "1", "LastEditorUserId": "216063", "LastActivityDate": "2009-12-09T17:29:50.540", "Score": "0", "OwnerUserId": "6266", "Tags": "<c++><visual-c++><scope><g++><specialization>", "AnswerCount": "2"}});