post_cb({"9582687": {"ParentId": "9582034", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>In <em>14.5.5.1 Matching of class template partial specializations</em>, there is</p>\n<blockquote>\n<p id=\"so_9582034_9582687_0\">If more than one matching specialization is found, the partial order rules (14.5.5.2) are used to determine\n          whether one of the specializations is more specialized than the others. If none of the specializations\n          is more specialized than all of the other matching specializations, then the use of the class template is\n          ambiguous and the program is ill-formed.</p>\n</blockquote>\n<p>However, this would only apply to your first case where there are two specializations visible, and I am not sure yet if those two specializations are valid in themselves.</p>\n<p>In your second case, however, before the second specialization is reached, the <em>template-id</em> <code>Unique&lt;3&gt;</code> already exists, for which (thanks n.m., Matthieu M., James Kanze) the first specialization is already instantiated:</p>\n<p><em>14.5.5 Class template partial specializations</em></p>\n<blockquote>\n<p id=\"so_9582034_9582687_1\">A partial specialization shall be declared before the first use of a class template specialization that would make use of the partial specialization as the result of an implicit or\n  explicit instantiation in every translation unit in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<p>And in <em>14.5.5, Item 8</em></p>\n<blockquote>\n<p id=\"so_9582034_9582687_2\">Within the argument list of a class template partial specialization, the following restrictions apply:</p>\n<p id=\"so_9582034_9582687_3\">\u2014 A partially specialized non-type argument expression shall not involve a template parameter of the\n   partial specialization except when the argument expression is a simple identifier. [ &gt;Example:</p>\n<p id=\"so_9582034_9582687_4\"><code>template &lt;int I, int J&gt; struct A {};</code></p>\n<p id=\"so_9582034_9582687_5\"><code>template &lt;int I&gt; struct A&lt;I+5, I*2&gt; {}; // error</code></p>\n<p id=\"so_9582034_9582687_6\"><code>template &lt;int I, int J&gt; struct B {};</code></p>\n<p id=\"so_9582034_9582687_7\"><code>template &lt;int I&gt; struct B&lt;I, I&gt; {}; // OK</code></p>\n<p id=\"so_9582034_9582687_8\">\u2014end example ]</p>\n</blockquote>\n<p>So it seems that non-type arguments do not participate in specialization creation, if not used as a simple identifier (thus <code>Range&lt;(value &gt; 2)&gt;</code> would be wrong).</p>\n<p>So it seems your code is not well-formed.</p>\n<hr>\n<p>Not directly related but still interesting in this regard:</p>\n<p><em>14.7.3 Explicit specialization</em></p>\n<blockquote>\n<p id=\"so_9582034_9582687_9\"><strong>The placement of</strong> explicit specialization declarations for function templates, class templates, member functions\n  of class templates, static data members of class templates, member classes of class templates, member\n  class templates of class templates, member function templates of class templates, member functions of member\n  templates of class templates, member functions of member templates of non-template classes, member\n  function templates of member classes of class templates, etc., and the placement of partial specialization\n  declarations of class templates, member class templates of non-template classes, member class templates of\n  class templates, etc., <strong>can affect whether a program is well-formed according to the relative positioning</strong> of\n  the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below. <strong>When writing a specialization, be careful about its location; or to make it compile will be\n  such a trial as to kindle its self-immolation.</strong></p>\n</blockquote>\n</hr>", "OwnerUserId": "76722", "LastEditorUserId": "76722", "LastEditDate": "2012-03-06T16:05:22.477", "Id": "9582687", "Score": "2", "CreationDate": "2012-03-06T11:23:16.047", "LastActivityDate": "2012-03-06T16:05:22.477"}, "9585856": {"ParentId": "9582034", "CommentCount": "1", "Body": "<p><code>o1</code> doesn't see the second specialization because of this:</p>\n<blockquote>\n<p id=\"so_9582034_9585856_0\"><strong>14.5.5/1</strong> A partial specialization shall be declared before the \ufb01rst use of a\n  class template specialization that would make use of the partial\n  specialization as the result of an implicit or explicit instantiation\n  in every translation unit in which such a use occurs; <em>no diagnostic is required</em>.</p>\n</blockquote>\n<p>In the second example, the second specialization would be used in the instantiation of <code>Unique&lt;3&gt;</code> if it were seen before the declaration of <code>o1</code>. Since this rule is violated, the program is broken, and the compiler is allowed to be silent about it.</p>\n<p><code>o2</code> doesn't see the second specialization because it doesn't see any specialization at all. Its class is instantiated once, at the point of <code>o1</code> declaration.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "9585856", "Score": "2", "CreationDate": "2012-03-06T14:43:35.780", "LastActivityDate": "2012-03-06T14:43:35.780"}, "9582034": {"CommentCount": "5", "AcceptedAnswerId": "9582687", "CreationDate": "2012-03-06T10:42:24.983", "LastActivityDate": "2012-03-06T16:05:22.477", "PostTypeId": "1", "ViewCount": "175", "FavoriteCount": "1", "Title": "Why SFINAE gets messed up when changing the place of the class template specialization? Is this a C++ bug?", "Id": "9582034", "Score": "6", "Body": "<p>Following code gives compiler error which is expected (<a href=\"http://ideone.com/YQko1\">Demo</a>):</p>\n<pre><code>  1 template&lt;bool&gt; struct Range;\n  2 \n  3 template&lt;int value, typename = Range&lt;true&gt; &gt; struct Unique;\n  4 template&lt;int value&gt; struct Unique&lt;value, Range&lt;(value &gt; 1)&gt; &gt; { typedef char type[1]; };\n  5 template&lt;int value&gt; struct Unique&lt;value, Range&lt;(value &gt; 2)&gt; &gt; { typedef char type[2]; };\n  6 \n  7 Unique&lt;3&gt;::type o1;\n  8 Unique&lt;3&gt;::type o2;\n</code></pre>\n<p>Now, if I swap line-5 and line-7. Then there is <strong>NO compiler error</strong> !! <a href=\"http://ideone.com/99bcS\">Demo</a>.</p>\n<pre><code>  5 Unique&lt;3&gt;::type o1;\n\n  7 template&lt;int value&gt; struct Unique&lt;value, Range&lt;(value &gt; 2)&gt; &gt; { typedef char type[2]; };\n</code></pre>\n<p>For <code>o1</code>, it's understandable to have no error, because specialization for <code>(value &gt; 2)</code> is not yet visible. But why there no error for <code>o2</code> also, which sees 2 matching specializations !?<br>\nMy guess is that, compiler should be choosing the <code>Unique&lt;3&gt;::type</code> with some arbitrary name when it encounters for the 1st time and then replacing <code>Unique&lt;3&gt;::type</code> everywhere with that name.</br></p>\n<p>Is this a compilation bug or C++ bug or C++ \"<em>feature</em>\" ?</p>\n", "Tags": "<c++><template-specialization><language-lawyer><sfinae><compiler-bug>", "OwnerUserId": "514235", "AnswerCount": "3"}, "9582554": {"ParentId": "9582034", "CommentCount": "11", "Body": "<p>A template is instantiated the first time it is needed (in the\ntranslation unit), not each time.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "9582554", "Score": "3", "CreationDate": "2012-03-06T11:16:24.177", "LastActivityDate": "2012-03-06T11:16:24.177"}, "bq_ids": {"n4140": {"so_9582034_9582687_3": {"section_id": 142, "quality": 0.9411764705882353, "length": 16}, "so_9582034_9582687_2": {"section_id": 142, "quality": 1.0, "length": 10}, "so_9582034_9582687_0": {"section_id": 143, "quality": 0.9696969696969697, "length": 32}, "so_9582034_9582687_9": {"section_id": 269, "quality": 0.9901960784313726, "length": 101}, "so_9582034_9582687_1": {"section_id": 135, "quality": 1.0, "length": 26}, "so_9582034_9585856_0": {"section_id": 135, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_9582034_9582687_3": {"section_id": 136, "quality": 0.9411764705882353, "length": 16}, "so_9582034_9582687_2": {"section_id": 136, "quality": 1.0, "length": 10}, "so_9582034_9582687_0": {"section_id": 137, "quality": 0.9696969696969697, "length": 32}, "so_9582034_9582687_9": {"section_id": 260, "quality": 0.9901960784313726, "length": 101}, "so_9582034_9582687_1": {"section_id": 129, "quality": 1.0, "length": 26}, "so_9582034_9585856_0": {"section_id": 129, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_9582034_9582687_9": {"section_id": 276, "quality": 0.9901960784313726, "length": 101}, "so_9582034_9582687_2": {"section_id": 146, "quality": 1.0, "length": 10}, "so_9582034_9585856_0": {"section_id": 139, "quality": 0.9259259259259259, "length": 25}, "so_9582034_9582687_1": {"section_id": 139, "quality": 1.0, "length": 26}, "so_9582034_9582687_0": {"section_id": 147, "quality": 0.9696969696969697, "length": 32}}}});