post_cb({"7034414": {"ParentId": "7034297", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>During overload resolution, overloads requiring no conversions beat overloads requiring some conversions, even if those conversions are trivial. Quoting the C++03 standard, [over.match.best] (\u00a713.3.3/1):</p>\n<blockquote>\n<p id=\"so_7034297_7034414_0\">Define ICS<i>i</i>(<code>F</code>) as follows:</p>\n<ul>\n<li>if <code>F</code> is a static member function, ICS<i>1</i>(<code>F</code>) is defined such that ICS<i>1</i>(<code>F</code>) is neither better nor worse than ICS<i>1</i>(<code>G</code>) for any function <code>G</code>, and, symmetrically, ICS<i>1</i>(<code>G</code>) is neither better nor worse than ICS<i>1</i>(<code>F</code>); otherwise,</li>\n<li>let ICS<i>i</i>(<code>F</code>) denote the implicit conversion sequence that converts the <em>i</em>-th argument in the list to the type of the <em>i</em>-th parameter of viable function <code>F</code>. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</li>\n</ul>\n<p id=\"so_7034297_7034414_1\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if for all arguments <em>i</em>, ICS<i>i</i>(<code>F1</code>) is not a worse conversion sequence than ICS<i>i</i>(<code>F2</code>), and then</p>\n<ul>\n<li>for some argument <em>j</em>, ICS<i>j</i>(<code>F1</code>) is a better conversion sequence than ICS<i>j</i>(<code>F2</code>), or, if not that,</li>\n<li><code>F1</code> is a non-template function and <code>F2</code> is a function template specialization, or, if not that,</li>\n<li><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized than the template for <code>F2</code> according to the partial ordering rules described in 14.5.5.2, or, if not that,</li>\n<li>the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of <code>F2</code> to the destination type.</li>\n</ul>\n</blockquote>\n<p>When <code>const</code> is present, in order to call the overload taking a reference, no conversion is necessary -- <code>T</code> is deduced to be <code>float*</code> and the argument is <code>float* const&amp;</code>. However, in order to call the overload taking a pointer, <code>float</code> would need to be converted to <code>float const</code> for said overload to be viable. Consequently, the overload taking a reference wins.</p>\n<p>Note, of course, that if <code>pf</code> were changed to be a <code>float const*</code>, the behavior would go back to the way you expected because the overload taking a pointer would no longer require a conversion.</p>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2011-08-12T00:48:21.423", "Id": "7034414", "Score": "3", "CreationDate": "2011-08-12T00:18:46.423", "LastActivityDate": "2011-08-12T00:48:21.423"}, "7034297": {"CommentCount": "0", "AcceptedAnswerId": "7034414", "CreationDate": "2011-08-11T23:59:34.113", "LastActivityDate": "2011-08-12T00:48:21.423", "PostTypeId": "1", "ViewCount": "206", "FavoriteCount": "1", "Title": "Global function template overloading and const parameters", "Id": "7034297", "Score": "1", "Body": "<p>If I compile (gcc 4.6.0) and run this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; void F(/* const */ T&amp; value) {\n    std::cout &lt;&lt; \"T &amp; \" &lt;&lt; value &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename T&gt; void F(/* const */ T* value) {\n    std::cout &lt;&lt; \"T * \" &lt;&lt; value &lt;&lt; std::endl;\n    F(*value);\n}\n\nint main(int argc, char* argv[]) {\n    float f = 123.456;   \n    float* pf = &amp;f;\n\n    F(pf);\n\n    return 0;\n}\n</code></pre>\n<p>I get the following output:</p>\n<pre><code>T * 0x7fff7b2652c4\nT &amp; 123.456\n</code></pre>\n<p>If I uncomment the const keywords I get the following output:</p>\n<pre><code>T &amp; 0x7fff3162c68c\n</code></pre>\n<p>I can change <code>float* pf = &amp;f;</code> to <code>const float* pf = &amp;f;</code> to get the original output again, that's not the issue.</p>\n<p>What I'd like to understand is why, when compiling with the const modifiers, overload resolution considers <code>const T&amp; value</code> a better match than  <code>const T* value</code>for a non-const <code>float*</code>?</p>\n", "Tags": "<c++><templates><overloading>", "OwnerUserId": "57465", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7034297_7034414_1": {"section_id": 603, "quality": 0.85, "length": 17}}, "n3337": {"so_7034297_7034414_1": {"section_id": 593, "quality": 0.85, "length": 17}}, "n4659": {"so_7034297_7034414_1": {"section_id": 629, "quality": 0.85, "length": 17}}}});