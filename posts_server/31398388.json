post_cb({"31398388": {"CommentCount": "0", "AcceptedAnswerId": "31398544", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-07-14T05:35:14.150", "LastActivityDate": "2015-07-14T06:03:51.743", "LastEditDate": "2015-07-14T05:43:18.943", "ViewCount": "230", "FavoriteCount": "1", "Title": "Can I apply the final keyword to a POD (standard-layout) struct in C++11 ? Should I?", "Id": "31398388", "Score": "6", "Body": "<p>In a C++ project that is full of objects (with proper behaviors) and relatively few of non-object-oriented structs (consisting of only data fields and no methods), I would like to prevent the accidental misuse of these structs, in which one might try to create a class inheriting from it.</p>\n<p>According to my understanding, because these \"POD\" (plain old data) structs do not have a virtual destructor, it is not possible to properly delete a derived class object (if one is allowed to create it) via a pointer of the POD type.</p>\n<p>This seems to make a good use case for the C++11 \"final\" keyword, which marks a class or struct as non-inheritable.</p>\n<p>However, I wonder if the \"final\" keyword causes the struct to become non-POD?</p>\n<p>I suspect that the standards documentation may have addressed this issue, but I am not intelligent enough to sift through the very long documentations to find out. Any useful pointers would be welcome.</p>\n<p>Note: I am not interested in merely knowing that it passes the compilation of some compiler vendors. Passing compilation do not guarantee:</p>\n<ul>\n<li>Whether the compiled code will execute correctly in all situations (especially when the technique is applied in a larger, more complex project),</li>\n<li>Whether the C++ standards body intends this to be used in this way.</li>\n</ul>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Pod final\n{\n    int a;\n    int b;\n    int c;\n};\n\n#if 0\nclass FailsBecauseCannotDeriveFromFinalAnything : public Pod\n{\n};\n#endif\n\nclass ContainsSomethingFinalAsMember\n{\npublic:\n    ContainsSomethingFinalAsMember() : pod() {}\nprivate:\n    Pod pod;\n};\n\nint main() \n{\n    std::cout &lt;&lt; std::is_pod &lt; Pod &gt; :: value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><inheritance><struct><final>", "OwnerUserId": "377657", "AnswerCount": "2"}, "31398544": {"ParentId": "31398388", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_31398388_31398544_0\">According to my understanding, because these \"POD\" (plain old data) structs do not have a virtual destructor, it is not possible to properly delete a derived class object (if one is allowed to create it) via a pointer of the POD type.</p>\n</blockquote>\n<p>It's not possible given a raw pointer, but it is possible given a smart pointer object, such as <code>std::shared_ptr</code> or a <code>std::unique_ptr</code> with an appropriate deleter.</p>\n<p>Since smart pointers were standardized, there are few excuses to continue following the poor practice of using the <code>delete</code> operator manually. Certainly, classes shouldn't be designed around compatibility with the <code>delete</code> operator. Each class interface should be designed with its particular uses in mind.</p>\n<p>No, it's not a good practice to make every class either <code>final</code> or polymorphic.</p>\n<blockquote>\n<p id=\"so_31398388_31398544_1\">However, I wonder if the \"final\" keyword causes the struct to become non-POD?</p>\n</blockquote>\n<p>No, it's still POD. The requirements for POD are standard layout (in turn requiring no base class, no access specifiers between members, no virtual anything) and trivial special member functions (copy/move constructor, assignment operator, destructor).</p>\n<p>However, the purpose of POD-ness is to allow you to use <code>memcpy</code> instead of properly constructing objects, which good C++ code would avoid doing.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "31398544", "Score": "4", "CreationDate": "2015-07-14T05:47:28.860", "LastActivityDate": "2015-07-14T05:47:28.860"}, "bq_ids": {"n4140": {"so_31398388_31398779_12": {"section_id": 474, "quality": 1.0, "length": 5}, "so_31398388_31398779_5": {"section_id": 369, "quality": 1.0, "length": 4}, "so_31398388_31398779_10": {"section_id": 461, "quality": 1.0, "length": 4}, "so_31398388_31398779_0": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_31398388_31398779_1": {"section_id": 5850, "quality": 0.782608695652174, "length": 18}, "so_31398388_31398779_9": {"section_id": 461, "quality": 0.9428571428571428, "length": 33}, "so_31398388_31398779_6": {"section_id": 369, "quality": 1.0, "length": 4}, "so_31398388_31398779_11": {"section_id": 474, "quality": 1.0, "length": 6}, "so_31398388_31398779_4": {"section_id": 5854, "quality": 0.95, "length": 19}, "so_31398388_31398779_3": {"section_id": 5852, "quality": 1.0, "length": 9}}, "n3337": {"so_31398388_31398779_12": {"section_id": 465, "quality": 1.0, "length": 5}, "so_31398388_31398779_5": {"section_id": 359, "quality": 1.0, "length": 4}, "so_31398388_31398779_3": {"section_id": 5622, "quality": 1.0, "length": 9}, "so_31398388_31398779_0": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_31398388_31398779_1": {"section_id": 5620, "quality": 0.8260869565217391, "length": 19}, "so_31398388_31398779_9": {"section_id": 452, "quality": 0.9428571428571428, "length": 33}, "so_31398388_31398779_6": {"section_id": 359, "quality": 1.0, "length": 4}, "so_31398388_31398779_10": {"section_id": 452, "quality": 1.0, "length": 4}, "so_31398388_31398779_11": {"section_id": 465, "quality": 1.0, "length": 6}, "so_31398388_31398779_4": {"section_id": 5624, "quality": 0.95, "length": 19}}, "n4659": {"so_31398388_31398779_12": {"section_id": 495, "quality": 0.8, "length": 4}, "so_31398388_31398779_3": {"section_id": 7331, "quality": 0.8888888888888888, "length": 8}, "so_31398388_31398779_0": {"section_id": 6103, "quality": 1.0, "length": 4}, "so_31398388_31398779_1": {"section_id": 7329, "quality": 0.6956521739130435, "length": 16}, "so_31398388_31398779_9": {"section_id": 484, "quality": 0.9428571428571428, "length": 33}, "so_31398388_31398779_11": {"section_id": 497, "quality": 1.0, "length": 6}, "so_31398388_31398779_4": {"section_id": 7333, "quality": 0.95, "length": 19}}}, "31398779": {"ParentId": "31398388", "CommentCount": "0", "Body": "<p>Marking a class <code>final</code> does not change its POD status. Quoting C++11:</p>\n<p>9 [class]:</p>\n<blockquote>\n<p id=\"so_31398388_31398779_0\">6 A <em>trivially copyable class</em> is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors (12.8),</li>\n<li>has no non-trivial move constructors (12.8),</li>\n<li>has no non-trivial copy assignment operators (13.5.3, 12.8),</li>\n<li>has no non-trivial move assignment operators (13.5.3, 12.8), and</li>\n<li>has a trivial destructor (12.4).</li>\n</ul>\n<p id=\"so_31398388_31398779_1\">A <em>trivial class</em> is a class that has a trivial default constructor (12.1) and is trivially copyable.\n  [ <em>Note:</em> In particular, a trivially copyable or trivial class does not have virtual functions or virtual base\n  classes.<em>\u2014end note</em> ]</p>\n<p id=\"so_31398388_31398779_2\">7 A <em>standard-layout class</em> is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with\n  non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n<p id=\"so_31398388_31398779_3\">8 A <em>standard-layout struct</em> is a standard-layout class defined with the <em>class-key</em> <code>struct</code> or the <em>class-key</em> <code>class</code>. ...</p>\n<p id=\"so_31398388_31398779_4\">10 A <em>POD struct</em> is a non-union class that is both a trivial class and a standard-layout class, and has no\n  non-static data members of type non-POD struct, non-POD union (or array of such types). ...</p>\n</blockquote>\n<p>12.1 [class.ctor]</p>\n<blockquote>\n<p id=\"so_31398388_31398779_5\">5 ... A default constructor is trivial if it is not user-provided and if:</p>\n<ul>\n<li>its class has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>no non-static data member of its class has a brace-or-equal-initializer, and</li>\n<li>all the direct base classes of its class have trivial default constructors, and</li>\n<li>for all the non-static data members of its class that are of class type (or array thereof), each such class\n  has a trivial default constructor.</li>\n</ul>\n<p id=\"so_31398388_31398779_6\">Otherwise, the default constructor is <em>non-trivial.</em></p>\n</blockquote>\n<p>12.4 [class.dtor]</p>\n<blockquote>\n<p id=\"so_31398388_31398779_7\">5 ... A destructor is trivial if it is not user-provided and if:</p>\n<ul>\n<li>the destructor is not virtual,</li>\n<li>all of the direct base classes of its class have trivial destructors, and</li>\n<li>for all of the non-static data members of its class that are of class type (or array thereof), each such\n  class has a trivial destructor.</li>\n</ul>\n<p id=\"so_31398388_31398779_8\">Otherwise, the destructor is <em>non-trivial.</em></p>\n</blockquote>\n<p>12.8 [class.copy]</p>\n<blockquote>\n<p id=\"so_31398388_31398779_9\">12 A copy/move constructor for class <code>X</code> is trivial if it is not user-provided and if\n  \u2014 class <code>X</code> has no virtual functions (10.3) and no virtual base classes (10.1), and\n  \u2014 the constructor selected to copy/move each direct base class subobject is trivial, and\n  \u2014 for each non-static data member of <code>X</code> that is of class type (or array thereof), the constructor selected\n  to copy/move that member is trivial;</p>\n<p id=\"so_31398388_31398779_10\">otherwise the copy/move constructor is <em>non-trivial.</em></p>\n<p id=\"so_31398388_31398779_11\">25 A copy/move assignment operator for class <code>X</code> is trivial if it is not user-provided and if</p>\n<ul>\n<li>class <code>X</code> has no virtual functions (10.3) and no virtual base classes (10.1), and</li>\n<li>the assignment operator selected to copy/move each direct base class subobject is trivial, and</li>\n<li>for each non-static data member of <code>X</code> that is of class type (or array thereof), the assignment operator\n  selected to copy/move that member is trivial;</li>\n</ul>\n<p id=\"so_31398388_31398779_12\">otherwise the copy/move assignment operator is <em>non-trivial.</em></p>\n</blockquote>\n<p>As you see, the definition of a POD struct does not take into account whether the class has the <em>class-virt-specifier</em> <code>final</code>.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "31398779", "Score": "1", "CreationDate": "2015-07-14T06:03:51.743", "LastActivityDate": "2015-07-14T06:03:51.743"}});