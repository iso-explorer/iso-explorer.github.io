post_cb({"17055440": {"ParentId": "17054367", "CommentCount": "1", "Body": "<p>You, and the people here giving advice about small functions, are looking at <code>inline</code> the old-fashioned way.</p>\n<p><code>inline</code> used to mean \"I want this code to run quickly, so whenever I call this function, I want you to expand it in-place to avoid the overhead of a function call.\"</p>\n<p>That's a really good optimization. It's so good, in fact, that the compiler will eagerly do it even if you <em>don't</em> specify <code>inline</code>.</p>\n<p>The compiler is also free to <em>not</em> expand your <code>inline</code> functions. So you really don't have to worry about how it will affect performance, because the compiler can and will ignore <code>inline</code> if you use it in a stupid way.</p>\n<p>In fact, compilers today almost <em>always</em> ignore your use of <code>inline</code>, and just do whatever they think is best.</p>\n<p>So, knowing that, why do people still use <code>inline</code>?</p>\n<p>There's only one reason to use <code>inline</code> nowadays, and that's to work around the One Definition Rule (ODR).</p>\n<p>In C/C++, you're only allowed to define a function once. If you do this:</p>\n<pre><code>int foo() { /* do something */ }\nint foo() { /* do something else */ }\n</code></pre>\n<p>the compiler will complain that you've defined the same function twice.</p>\n<p>That looks like a silly example, but it's particularly easy to do something like that when you're using <code>#include</code> - if you defined your function in a header, and you <code>#include</code> the same header twice, this is exactly what you're doing.</p>\n<p>Thankfully, <code>inline</code> has another use which is still valid today: if you mark a function as <code>inline</code>, it forces the compiler to silence ODR issues, making it possible to define your function in a header.</p>\n<p>In other words, <code>inline</code> now means \"I want to define this function in a header.\"</p>\n<p>When you look at it that way, it should be clear that you should remove the <code>inline</code> when moving the function into a cpp file.</p>\n<hr>\n<p>For interest sake, there's a couple places where functions are implicitly made inline. One of them is in class member functions:</p>\n<pre><code>struct Foo {\n    void bar() { /* do something */ }\n};\n</code></pre>\n<p>I've seen people mark functions like this <code>inline</code>, but that's completely redundant. The compiler does it anyway; there's no need to worry about ODR, and there's no performance to be gained.</p>\n<p>The other place is in templates. Since templates <em>have</em> to be defined in headers, they're exempt from the ODR, and <code>inline</code>ing them is redundant.</p>\n</hr>", "OwnerUserId": "754093", "PostTypeId": "2", "Id": "17055440", "Score": "3", "CreationDate": "2013-06-11T23:22:33.083", "LastActivityDate": "2013-06-11T23:22:33.083"}, "17054518": {"ParentId": "17054367", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>If you moved the function definition from a header to a cpp file, you MUST remove the <code>inline</code> keyword all <em>all</em> locations for that function.  With older linkers it might make things slightly slower, but with modern linkers you <em>should</em> notice no real difference in performance.<sup>*</sup></p>\n<p>There are certain cases where a public member function can be <code>inline</code>, but that's just a bad idea.  Don't do it.  Arguments can be made for marking certain private member functions as <code>inline</code>, but in reality what you really want in those to be <code>__attribute__((always_inline))</code> or <code>__forceinline</code></p>\n<p><sup>*In extremely rare cases it will make a difference, but 99% of the time it won't, and 99.9% of what's left you don't care.  If measurements show you hit that one-in-ten-thousand, you can use the aformentioned <code>__forceinline</code>.</sup></p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2013-06-11T22:47:16.173", "Id": "17054518", "Score": "12", "CreationDate": "2013-06-11T21:55:33.217", "LastActivityDate": "2013-06-11T22:47:16.173"}, "17054680": {"ParentId": "17054367", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>If the function isn't TINY (or takes several arguments, but doesn't do much, such as a constructor or similar, that takes a bunch of things, and just copies it to somewhere inside the class), inlining it will have little impact on performance in the first place. Setters and getters are usually good candidates to inline, since they (typically) just copy data from one place to another, and can easily be done where the call takes place. </p>\n<p>As others have said, it's a \"please compiler, if I may ask you kindly, consider inlining this function\" - it's not a \"make this function inline\". The compiler, on the other hand, will often inline functions REGARDLESS of whether there is an <code>inline</code> keyword. It looks at the size of the function, the number of calls and how much larger the code gets from inlining. </p>\n<p>If you move the function to \"foo.cpp\", it will ONLY get inline inside the \"foo.cpp\" compile unit (typically, compile unit = source file). </p>\n<p>That is unless you have a compiler capable of \"whole program optimization\" or similar tricks, and enable that feature - this basically means that instead of producing a ready to link object file with machine code, the compiler produces a \"parsed, but not completely translated to machine instructions\" object file. Then, when it comes to finally putting the executable (or shared library) toegether, the compiler/linker will produce one large lump of machine code from the \"halfway\" code. Both MS and GCC do support this, but I don't know how well it works for large projects.</p>\n<p>Edit: </p>\n<p>As per Mooing Duck's comment: An <code>inline</code> function doesn't make a real function name in the object file, so the linker may also give errors for <code>unresolved symbol int Foo::Method()</code> [or some wording to that extent]. </p>\n<p>End edit.</p>\n<p>If performance is critical, you should measure the current code's performance, then make your changes, and measure it again. If it's significantly different, you'll have your answer. If it's faster (because of less inlining leading to more cache-hit rate for other bits of code, for example), then that's good. If it's slower, you'll have to put back (some of) the functions into the header file. Or live with it being slower... Or find some other way of making it faster again... The choices are yours (and, if you work in a group, some other people may have a say in the final decision, of course). It's almost impossible for anyone to say for SURE which way it will go without at the very least understanding the whole programs architecture and what goes on in the class - which, given the name \"foo.cpp\" in the post is probably not the REAL code... </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2013-06-11T22:15:19.433", "Id": "17054680", "Score": "4", "CreationDate": "2013-06-11T22:07:47.120", "LastActivityDate": "2013-06-11T22:15:19.433"}, "17054440": {"ParentId": "17054367", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Keyword <code>inline</code> is redundant in the class. It is implied if you have a function body.</p>\n<p>In the implementation file it is also fairly redundant. </p>\n<p>The only use of it is if you define a free function in a header (or a member function outside the class, but in the header) to avoid multiple bodies. </p>\n<p>Optimization-wise on mist modern compilers it's even more redundant, they inline anything in sight without question anyway, or ignore your keyword at will.</p>\n<p>The inline usage must be consistent!  From 7.1.2p4:</p>\n<blockquote>\n<p id=\"so_17054367_17054440_0\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case (3.2). [ Note: A call to the inline function may be encountered before its definition appears in the translation unit. \u2014end note ] If the definition of a function appears in a translation unit before its first declaration as inline, the program is ill-formed. If a function with external linkage is\n  declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required.  ...</p>\n</blockquote>\n", "OwnerUserId": "2422194", "LastEditorUserId": "2422194", "LastEditDate": "2013-06-11T22:34:35.393", "Id": "17054440", "Score": "5", "CreationDate": "2013-06-11T21:49:25.280", "LastActivityDate": "2013-06-11T22:34:35.393"}, "17054506": {"ParentId": "17054367", "CommentCount": "1", "Body": "<p>It may be confusing, but you should not think of the purpose of <code>inline</code> to make the compiler inline a function. (Modern compilers are way smarter than you in regards to when a function should be inlined or not anyway).</p>\n<p>No, the real purpose of <code>inline</code> is to tell the linker to not worry about multiple definitions of the function. If you put the definition of a (non-member) function in a header, you should mark it <code>inline</code> to avoid linker errors.</p>\n", "OwnerUserId": "2460285", "PostTypeId": "2", "Id": "17054506", "Score": "1", "CreationDate": "2013-06-11T21:54:43.963", "LastActivityDate": "2013-06-11T21:54:43.963"}, "17054527": {"ParentId": "17054367", "CommentCount": "4", "Body": "<p><code>2. How typically the removal of the inline keyword affect the performance (practically all my methods are inlined)?</code></p>\n<p>The <code>inline</code> keyword tells the compiler to take the implementation code of that function and put it in place of the function call. This reduces the number of function calls on the stack and if used correctly, can improve the performance of your program.</p>\n<p>The <code>inline</code> keyword should only be used with small functions. Get and Set functions are good examples. They set the value of one variable or return the value of one variable. </p>\n<p>If you make a function with a lot of code <code>inline</code>, it can increase the size of your code by a lot (depending on the size of the function code and how many times that function is used) and actually DECREASE the performance of your program. </p>\n", "OwnerUserId": "2457551", "PostTypeId": "2", "Id": "17054527", "Score": "0", "CreationDate": "2013-06-11T21:56:04.803", "LastActivityDate": "2013-06-11T21:56:04.803"}, "bq_ids": {"n4140": {"so_17054367_17054440_0": {"section_id": 5404, "quality": 0.9444444444444444, "length": 51}}, "n3337": {"so_17054367_17054440_0": {"section_id": 5199, "quality": 0.9444444444444444, "length": 51}}, "n4659": {"so_17054367_17054440_0": {"section_id": 6853, "quality": 0.9444444444444444, "length": 51}}}, "17054367": {"CommentCount": "2", "CreationDate": "2013-06-11T21:44:11.553", "PostTypeId": "1", "AcceptedAnswerId": "17054518", "LastEditorUserId": "1760345", "LastActivityDate": "2013-06-11T23:22:33.083", "LastEditDate": "2013-06-11T21:51:30.350", "ViewCount": "4866", "FavoriteCount": "0", "Title": "Moving inline methods from a header file to a .cpp files", "Id": "17054367", "Score": "3", "Body": "<p>I have the following class defined in a <code>foo.h</code> header file</p>\n<pre><code>class Foo {\n\npublic:\n    inline int Method();\n\n};\n\ninline int Foo::Method() { // Implementation }\n</code></pre>\n<p>I would like now to move the implementation to a <code>foo.cpp</code> file. To this end, I have to remove the <code>inline</code> keyword and move the implementation of the method to a <code>foo.cpp</code> file like this</p>\n<pre><code>#include `foo.h`\n\ninline int Foo::Method() { // Implementation }\n</code></pre>\n<p>I have two questions:</p>\n<ol>\n<li>Is my statement about the removal of the <code>inline</code> keyword correct? Should it be necessarily removed?</li>\n<li>How typically the removal of the <code>inline</code> keyword affect the performance (practically all my methods are inlined)?</li>\n</ol>\n<p>Thank you very much in advance.</p>\n", "Tags": "<c++><class><methods>", "OwnerUserId": "1886641", "AnswerCount": "6"}});