post_cb({"2065497": {"ParentId": "2065228", "LastEditDate": "2017-05-23T11:48:36.173", "CommentCount": "3", "CreationDate": "2010-01-14T16:03:46.550", "OwnerUserId": "33732", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "2065497", "Score": "2", "Body": "<p>What you're asking is similar to an earlier question, and the answer I gave there is relevant here as well.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/1424261/conditional-operator-cant-resolve-overloaded-member-function-pointers\">Conditional operator can\u2019t resolve overloaded member function pointers</a></li>\n</ul>\n<p>From section 13.4/1 (\"Address of overloaded function,\" [over.over]):</p>\n<blockquote>\n<p id=\"so_2065228_2065497_0\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a pointer to function or pointer to member function for a specific function from the overload set. A function template name is considered to name a set of overloaded functions in such contexts. The function selected is the one whose type matches the target type required in the context. The target can be</p>\n<ul>\n<li>an object or reference being initialized (8.5, 8.5.3),</li>\n<li>the left side of an assignment (5.17),</li>\n<li>a parameter of a function (5.2.2),</li>\n<li>a parameter of a user-defined operator (13.5),</li>\n<li>the return value of a function, operator function, or conversion (6.6.3), or</li>\n<li>an explicit type conversion (5.2.3, 5.2.9, 5.4).</li>\n</ul>\n<p id=\"so_2065228_2065497_1\">The overload function name can be preceded by the <code>&amp;</code> operator. An overloaded function name shall not be used without arguments in contexts other than those listed. [<em>Note:</em> any redundant set of parentheses surrounding the overloaded function name is ignored (5.1). ]</p>\n</blockquote>\n<p>In your case, the <em>target</em> from the above list is the third one, a parameter of your <code>MakeObjGuard</code> function. However, I suspect that's a function template, and one of the type parameters for the template is the type of the function pointer. The compiler has a Catch-22. It can't deduce the template parameter type without knowing which overload is selected, and it can't automatically select which overload you mean without knowing the parameter type.</p>\n<p>Therefore, you need to help it out. You can either type-cast the method pointer, as you're doing now, or you can specify the template argument type explicitly when you call the function: <code>MakeObjGuard&lt;SelectObjectBitmap&gt;(...)</code>. Either way, you need to know the type. You don't strictly need to have a typedef name for the function type, but it sure helps readability.</p>\n", "LastActivityDate": "2010-01-14T16:03:46.550"}, "2065562": {"ParentId": "2065228", "CommentCount": "0", "Body": "<p>You can avoid using the typedef, but it really isn't pretty:</p>\n<pre><code>void foo(int){\n    std::cout &lt;&lt; \"int\" &lt;&lt; std::endl;\n}\n\nvoid foo(float){\n    std::cout &lt;&lt; \"float\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    typedef void (*ffp)(float);\n\n    ffp fp = (void (*)(float)) foo; // cast to a function pointer without a typedef\n\n    ((ffp)fp)(0);\n}\n</code></pre>\n<p>Better to stick to the typedef.</p>\n", "OwnerUserId": "233201", "PostTypeId": "2", "Id": "2065562", "Score": "1", "CreationDate": "2010-01-14T16:13:55.550", "LastActivityDate": "2010-01-14T16:13:55.550"}, "2066148": {"ParentId": "2065228", "LastEditDate": "2010-01-14T17:38:12.040", "CommentCount": "0", "CreationDate": "2010-01-14T17:32:02.270", "OwnerUserId": "187690", "LastEditorUserId": "187690", "PostTypeId": "2", "Id": "2066148", "Score": "0", "Body": "<p>You seem to be misunderstanding the root of the issue. As long as the concrete type on the receiving side of the assignment/initialization is known to the compiler, you are not supposed to make any effort to \"select\" it at all, If your typedef is defined as</p>\n<pre><code>typedef CBitmap * (CDC::* SelectObjectBitmap)(CBitmap*); \n</code></pre>\n<p>then the initialization </p>\n<pre><code>SelectObjectBitmap pmf = &amp;CDC::SelectObject; \n</code></pre>\n<p>is required to invoke overload resolution and select the proper overloaded version of the function without the need for an explicit cast. This is actually only one place in C++ when overload resolution in the right-hand side of the expression/initialization depends on the left-hand side.</p>\n<p>Of course, the same should work without a typedef.</p>\n<hr>\n<p>OK, seeing that what you are actually doing is passing the address of the method to a template function as a dependent argument type: of course, in this case you have to either 1) select the proper overload by using a cast, or 2) fix the function parameter type by explicitly specifying the template argument.</p>\n<p>Of course, you can just pre-select the proper overload by doing</p>\n<pre><code>SelectObjectBitmap pmf = &amp;CDC::SelectObject; \n</code></pre>\n<p>and then pass <code>pmf</code> to your template function.</p>\n</hr>", "LastActivityDate": "2010-01-14T17:38:12.040"}, "2065228": {"CommentCount": "2", "ViewCount": "1154", "PostTypeId": "1", "LastEditorUserId": "112755", "CreationDate": "2010-01-14T15:33:45.350", "LastActivityDate": "2010-01-14T17:38:12.040", "Title": "is there a better way to select correct method overload?", "AcceptedAnswerId": "2065497", "LastEditDate": "2010-01-14T17:22:29.803", "Id": "2065228", "Score": "5", "Body": "<p>Is this really the only way to get the correct address for an instance function:</p>\n<pre><code>typedef CBitmap * (CDC::* SelectObjectBitmap)(CBitmap*);\nSelectObjectBitmap pmf = (SelectObjectBitmap)&amp;CDC::SelectObject;\n</code></pre>\n<p>First, one has to create a typedef, and then one has to use that to force the compiler to select the correct overloaded method when taking its address?</p>\n<p>Is there no syntax that is more natural, and self-contained, such as:</p>\n<pre><code>SelecdtObjectBitmap pmf = &amp;CDC::SelectObject(CBitmap*);\n</code></pre>\n<p>I use <a href=\"http://www.ddj.com/cpp/184403758\" rel=\"nofollow noreferrer\">ScopeGuard</a> often in my code.  And one obvious use is to ensure that any temporary CDC objects are first selected into a given DC, then removed at scope exit, making my code leak free even under exceptional circumstances - and simultaneously cleaning up the code written (stupid multiple exit paths and try/catch and so on to try to handle removing any selected objects from a given CDC).</p>\n<p>So a more complete example of what I currently am forced to do looks like:</p>\n<pre><code>// get our client rect\nCRect rcClient;\nGetClientRect(rcClient);\n\n// get the real DC we're drawing on\nPAINTSTRUCT ps;\nCDC * pDrawContext = BeginPaint(&amp;ps);\n\n// create a drawing buffer\nCBitmap canvas;\ncanvas.CreateCompatibleBitmap(pDrawContext, rcClient.Width(), rcClient.Height());\n\nCDC memdc;\nmemdc.CreateCompatibleDC(pDrawContext);\n\n//*** HERE'S THE LINE THAT REALLY USES THE TYPEDEF WHICH i WISH TO ELIMINATE ***//\nScopeGuard guard_canvas = MakeObjGuard(memdc, (SelectObjectBitmap)&amp;CDC::SelectObject, memdc.SelectObject(&amp;canvas));\n\n// copy the image to screen\npDrawContext-&gt;BitBlt(rcClient.left, rcClient.top, rcClient.Width(), rcClient.Height(), &amp;memdc, rcClient.left, rcClient.top, SRCCOPY);\n\n// display updated\nEndPaint(&amp;ps);\n</code></pre>\n<p>It has always struck me as goofy as hell that I need to typedef every overloaded function which I wish to take the address of.</p>\n<p>So... is there a better way?!</p>\n<p><strong>EDIT: Based on the answers folks have supplied, I believe I have a solution to my underlying need: i.e. to have a more natural syntax for MakeGuard which deduces the correct SelectObject override for me:</strong></p>\n<pre><code>template &lt;class GDIObj&gt;\nObjScopeGuardImpl1&lt;CDC, GDIObj*(CDC::*)(GDIObj*), GDIObj*&gt; MakeSelectObjectGuard(CDC &amp; dc, GDIObj * pGDIObj)\n{\n    return ObjScopeGuardImpl1&lt;CDC, GDIObj*(CDC::*)(GDIObj*), GDIObj*&gt;::MakeObjGuard(dc, (GDIObj*(CDC::*)(GDIObj*))&amp;CDC::SelectObject, dc.SelectObject(pGDIObj));\n}\n</code></pre>\n<p>Which makes my above code change to:</p>\n<pre><code>ScopeGuard guard_canvas = MakeSelectObjectGuard(memdc, &amp;canvas);\n</code></pre>\n<p>//////////////////////////////////////////////////////////</p>\n<p>For those who might look here for a non-MFC version of the same thing:</p>\n<pre><code>//////////////////////////////////////////////////////////////////////////\n//\n// AutoSelectGDIObject\n//  selects a given HGDIOBJ into a given HDC,\n//  and automatically reverses the operation at scope exit\n//\n// AKA:\n//  \"Tired of tripping over the same stupid code year after year\"\n//\n// Example 1:\n//  CFont f;\n//  f.CreateIndirect(&amp;lf);\n//  AutoSelectGDIObject select_font(*pDC, f);\n//\n// Example 2:\n//  HFONT hf = ::CreateFontIndirect(&amp;lf);\n//  AutoSelectGDIObject select_font(hdc, hf);\n//\n// NOTE:\n//  Do NOT use this with an HREGION.  Those don't need to be swapped with what's in the DC.\n//////////////////////////////////////////////////////////////////////////\n\nclass AutoSelectGDIObject\n{\npublic:\n    AutoSelectGDIObject(HDC hdc, HGDIOBJ gdiobj) \n        : m_hdc(hdc)\n        , m_gdiobj(gdiobj)\n        , m_oldobj(::SelectObject(m_hdc, gdiobj))\n    {\n        ASSERT(m_oldobj != m_gdiobj);\n    }\n\n    ~AutoSelectGDIObject()\n    {\n        VERIFY(m_gdiobj == ::SelectObject(m_hdc, m_oldobj));\n    }\n\nprivate:\n    const HDC       m_hdc;\n    const HGDIOBJ   m_gdiobj;\n    const HGDIOBJ   m_oldobj;\n};\n</code></pre>\n<p>//////////////////////////////////////////////////////////</p>\n<p><strong><em>Thanks Everyone who replied &amp; commented! :D</em></strong></p>\n", "Tags": "<c++><visual-studio-2008><templates><mfc><winapi>", "OwnerUserId": "112755", "AnswerCount": "4"}, "2065492": {"ParentId": "2065228", "CommentCount": "1", "Body": "<p>You don't really need to use the typedef. You're just using the typedef to create a name for a type, then using that type to define your pointer, and in a typecast to initialize the pointer. If you really want to, you can use the type directly for both of those, but you end up repeating the same (often lengthy) type for both the definition and the typecast. For a somewhat simplified, standalone example:</p>\n<pre><code>struct XXX {\n    int member() { return 0; }\n    int member(int) { return 1; }\n};\n\nint main() {     \n    int (XXX::*pmfv)(void) = (int (XXX::*)())&amp;XXX::member;\n    int (XXX::*pmfi)(int) = (int (XXX::*)(int))&amp;XXX::member;\n    return 0;\n}\n</code></pre>\n<p>While this is possible, and should be accepted by any properly functioning compiler, I can't say I'd really advise it -- while it creates and initializes the pointer in a single statement, if the type involved has a long name, it's probably going to end up as a couple of lines of code anyway, just due to the length.</p>\n<p>I believe C++ 0x's, <code>auto</code> should allow the first example above to be shortened to something like this:</p>\n<pre><code>auto pmf = (int (XXX::*)())&amp;XXX::member;\n</code></pre>\n<p>This should make it much easier to avoid the typedef (and depending on the compiler you're using, you may already have this available).</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "2065492", "Score": "2", "CreationDate": "2010-01-14T16:02:58.237", "LastActivityDate": "2010-01-14T16:02:58.237"}, "bq_ids": {"n4140": {"so_2065228_2065497_1": {"section_id": 641, "quality": 0.92, "length": 23}, "so_2065228_2065497_0": {"section_id": 641, "quality": 0.926829268292683, "length": 38}}, "n3337": {"so_2065228_2065497_1": {"section_id": 631, "quality": 0.92, "length": 23}, "so_2065228_2065497_0": {"section_id": 631, "quality": 0.926829268292683, "length": 38}}, "n4659": {"so_2065228_2065497_1": {"section_id": 669, "quality": 0.92, "length": 23}, "so_2065228_2065497_0": {"section_id": 669, "quality": 0.8536585365853658, "length": 35}}}});