post_cb({"bq_ids": {"n4140": {"so_16794332_16794471_0": {"section_id": 4394, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_16794332_16794471_0": {"section_id": 4231, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_16794332_16794471_0": {"section_id": 4289, "quality": 0.6666666666666666, "length": 6}}}, "16794332": {"CommentCount": "0", "ViewCount": "77", "PostTypeId": "1", "OwnerDisplayName": "user494461", "CreationDate": "2013-05-28T14:13:10.563", "LastActivityDate": "2013-05-28T14:20:07.497", "LastEditDate": "2013-05-28T14:19:36.017", "AcceptedAnswerId": "16794471", "LastEditorDisplayName": "user494461", "Title": "how does passing shared pointer by value and accepting as base class argument work?", "Id": "16794332", "Score": "1", "Body": "<p>in this program :<a href=\"http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/example/chat/chat_server.cpp\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_53_0/doc/html/boost_asio/example/chat/chat_server.cpp</a></p>\n<pre><code>class chat_session\n  : public chat_participant,\n</code></pre>\n<p>chat_session inherits chat_participant</p>\n<p>in one of the calls a <code>shared_ptr</code> to <code>chat_session</code> is sent to the <code>join</code> method<br>\n<code>room_.join(shared_from_this());</code> </br></p>\n<p>which is defined as</p>\n<pre><code>  void join(chat_participant_ptr participant)\n</code></pre>\n<p>so how does the example above translate to <code>particpant</code> being a base class pointer to the inherited class instance?</p>\n<p>My understnading of base class pointer to inherited class instance is the from the <strong>Virtual members</strong>\nexample here </p>\n<p><a href=\"http://www.cplusplus.com/doc/tutorial/polymorphism/\" rel=\"nofollow\">http://www.cplusplus.com/doc/tutorial/polymorphism/</a></p>\n<p>---edit---</p>\n<p>An example would be great if somebody could explain how a pointer to base class can be defined in the function arguments even if we are not using shared_ptrs</p>\n", "Tags": "<c++><inheritance><boost><polymorphism><shared-ptr>", "AnswerCount": "2"}, "16794471": {"ParentId": "16794332", "CommentCount": "0", "CreationDate": "2013-05-28T14:20:07.497", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16794471", "Score": "2", "Body": "<p>Smart pointers are supposed to behave like regular raw pointers <em>in this respect</em>. With raw pointers, you can have a function <code>foo()</code> like the one below:</p>\n<pre><code>void foo(B* pBase);\n</code></pre>\n<p>And - given a class <code>D</code> that derives from <code>B</code> - pass to it a pointer of type <code>D*</code>:</p>\n<pre><code>class D : public B { ... };\n// ...\nD obj;\nfoo(&amp;obj); // OK!\n</code></pre>\n<p>This is simply how derived-to-base conversion works, and its fundamental for polymorphism. Now smart pointers are meant to emulate this mechanism, so that given:</p>\n<pre><code>void foo(shared_ptr&lt;B&gt; pBase);\n</code></pre>\n<p>You could do:</p>\n<pre><code>shared_ptr&lt;D&gt; pObj = make_shared&lt;D&gt;();\nfoo(pObj); // OK!\n</code></pre>\n<p>Technically, the way this behavior is achieved for the <code>shared_ptr</code> class template is to have a user-defined constructor template that carries out the implicit conversion:</p>\n<pre><code>template&lt;class T&gt; class shared_ptr {\npublic:\n    // ...\n    template&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;\n    // ...\n};\n</code></pre>\n<p>This converting constructor will actually participate to overload resolution only if <code>Y</code> is convertible to <code>T</code>. \u00a7 20.7.2.2.1/17 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_16794332_16794471_0\"><em>Requires</em>: The second constructor shall not participate in the overload resolution unless <code>Y*</code> is implicitly\n  convertible to <code>T*</code>.</p>\n</blockquote>\n<p>This is typically achieved by using SFINAE constraints on the function template.</p>\n", "LastActivityDate": "2013-05-28T14:20:07.497"}, "16794449": {"ParentId": "16794332", "CommentCount": "0", "CreationDate": "2013-05-28T14:19:07.070", "OwnerUserId": "469935", "PostTypeId": "2", "Id": "16794449", "Score": "1", "Body": "<p>There is an implicit conversion (by means of a non-explicit constructor) from <code>shared_ptr&lt;T&gt;</code> to <code>shared_ptr&lt;U&gt;</code> if and only if </p>\n<ul>\n<li><code>U</code> is <code>void</code> or</li>\n<li><code>U</code> is an accessible base class of <code>T</code></li>\n</ul>\n", "LastActivityDate": "2013-05-28T14:19:07.070"}});