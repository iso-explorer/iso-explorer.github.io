post_cb({"23831292": {"ParentId": "23829696", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes it is by omission in <code>[conv.ptr]</code> and the applicable paragraph is in <code>[expr.reinterpret.cast]</code>,</p>\n<blockquote>\n<p id=\"so_23829696_23831292_0\"><code>7</code> An object pointer can be explicitly converted to an object pointer of\n  a different type. When a prvalue v  of  type  \"pointer  to  T1\"  is \n  converted  to  the  type  \"pointer  to  cv  T2\",  the  result  is \n  <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv  void*&gt;(v))</code> if both T1 and T2 are\n  standard-layout types (3.9) and the alignment requirements of T2 are\n  no stricter than those of T1, or if either type is void.  Converting a\n  prvalue of type \"pointer to T1\" to the type \"pointer to T2\" (where T1\n  and T2 are object types and where the alignment requirements of T2 are\n  no stricter than those of T1) and back to its original type yields the\n  original pointer value. The result of any other such pointer\n  conversion is unspeci\ufb01ed.</p>\n</blockquote>\n<p>You have to use <code>reinterpret_cast&lt;int*&gt;(...)</code>.</p>\n<hr>\n<p><strong>EDIT.</strong> There is a concern in the comments that I am making more visible in this edit, that this is not a language-lawyer question but that the intention is to use the pointer. I am not sure how the concern came about, as it is rather obvious that one can simply C-cast without asking, but if there is doubt - the pointer cast to <code>int*</code> violates <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">strict aliasing</a> rules. </p>\n<p>That is, an undefined behaviour may arise from the fact that you break the compiler's assumption that pointers of different types could never point to the same memory location. </p>\n</hr>", "OwnerUserId": "3099074", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:13.830", "Id": "23831292", "Score": "0", "CreationDate": "2014-05-23T14:01:56.030", "LastActivityDate": "2014-05-24T06:19:34.887"}, "23831795": {"ParentId": "23829696", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>long</code> and <code>int</code> are two distinct types, even if they are the same size, so I think the invalid conversion is due to [<em>basic.lval.10</em>]</p>\n<blockquote>\n<p id=\"so_23829696_23831795_0\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the\n  object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types\n  among its elements or non-static data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<hr>\n<p>As a side note, if [<em>basic.lval</em>] did not exist, there would be other issues: same size doesn't mean same representation / range.</p>\n<p>There's no guarantee that the value bits in <code>int</code> correspond precisely to the value bits in a <code>long</code>.</p>\n</hr>", "OwnerUserId": "3235496", "LastEditorUserId": "3235496", "LastEditDate": "2014-05-23T15:27:23.810", "Id": "23831795", "Score": "0", "CreationDate": "2014-05-23T14:26:20.023", "LastActivityDate": "2014-05-23T15:27:23.810"}, "bq_ids": {"n4140": {"so_23829696_23831795_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_23829696_23831292_0": {"section_id": 6046, "quality": 0.6557377049180327, "length": 40}}, "n3337": {"so_23829696_23831795_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_23829696_23831292_0": {"section_id": 5814, "quality": 0.9344262295081968, "length": 57}}, "n4659": {"so_23829696_23831795_0": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_23829696_23831292_0": {"section_id": 7545, "quality": 0.639344262295082, "length": 39}}}, "23829696": {"CommentCount": "0", "ViewCount": "149", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2014-05-23T12:47:54.523", "LastActivityDate": "2015-07-25T20:01:44.470", "Title": "Conversion between long* and int* when sizeof(long) == sizeof(int)", "AcceptedAnswerId": "23831292", "LastEditDate": "2015-07-25T20:01:44.470", "Id": "23829696", "Score": "2", "Body": "<p>We know in general <code>sizeof(long) != sizeof(int)</code>. But which parts of the (C++11) standard disallow aliasing <code>long*</code> through <code>int*</code>? Is it just by omission in [conv.ptr], the aliasing rules in [basic.lval], or something else?</p>\n<pre><code>void f()\n{\n    static_assert(sizeof(int) == sizeof(long), \"\");\n    long x[] = {1, 2};\n    int* y = x; // error: invalid conversion from \u2018long int*\u2019 to \u2018int*\u2019 [-fpermissive]\n}\n</code></pre>\n", "Tags": "<c++><c++11><type-conversion><language-lawyer><type-punning>", "OwnerUserId": "634175", "AnswerCount": "2"}});