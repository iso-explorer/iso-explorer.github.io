post_cb({"45478126": {"ParentId": "45478054", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>It's explicitly allowed in the typedef case, and disallowed in the declaration itself:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.type#1\" rel=\"nofollow noreferrer\">[dcl.type/1]</a></p>\n<blockquote>\n<p id=\"so_45478054_45478126_0\">The type-specifiers are:  </p>\n<p id=\"so_45478054_45478126_1\"><em>type-specifier</em> : ... <em>cv-qualifier</em><br>\n<strong><em>defining-type-specifier</em></strong> : <em>type-specifier</em></br></p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.spec#2\" rel=\"nofollow noreferrer\">[dcl.spec/1 and 2]</a></p>\n<blockquote>\n<p id=\"so_45478054_45478126_2\">The specifiers that can be used in a declaration are:  </p>\n<p id=\"so_45478054_45478126_3\"><em>decl-specifier</em> : ... <strong><em>defining-type-specifier</em></strong> ...</p>\n<p id=\"so_45478054_45478126_4\"><strong>Each decl-specifier shall appear at most once in a complete\n  decl-specifier-seq, except that long may appear twice.</strong></p>\n</blockquote>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.type.cv#1\" rel=\"nofollow noreferrer\">[dcl.type.cv/1]</a></p>\n<blockquote>\n<p id=\"so_45478054_45478126_5\">There are two cv-qualifiers, const and volatile. <strong>Each cv-qualifier\n  shall appear at most once in a cv-qualifier-seq</strong>. If a cv-qualifier\n  appears in a decl-specifier-seq, the init-declarator-list or\n  member-declarator-list of the declaration shall not be empty. [\u2009Note:\n  [basic.type.qualifier] and [dcl.fct] describe how cv-qualifiers affect\n  object and function types. \u2009\u2014\u2009end note\u2009] <strong>Redundant cv-qualifications\n  are ignored. [\u2009Note: For example, these could be introduced by\n  typedefs.\u2009\u2014\u2009end note\u2009]</strong></p>\n</blockquote>\n<p>Besides type aliases, a template parameter is another case where the qualifier could be redundant. The rationale for allowing this, is to not break otherwise correct declarations just because a cv-qualifier snuck in the back door.</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-08-04T06:26:25.640", "Id": "45478126", "Score": "30", "CreationDate": "2017-08-03T07:54:46.613", "LastActivityDate": "2017-08-04T06:26:25.640"}, "45478054": {"CommentCount": "1", "AcceptedAnswerId": "45478126", "PostTypeId": "1", "LastEditorUserId": "3982001", "CreationDate": "2017-08-03T07:51:04.297", "LastActivityDate": "2017-08-04T06:26:25.640", "LastEditDate": "2017-08-03T09:49:26.923", "ViewCount": "773", "FavoriteCount": "1", "Title": "Same const type qualifier", "Id": "45478054", "Score": "24", "Body": "<p>Having two <code>const</code>'s for a type issues a warning / error. However if the type has been defined with <code>typedef</code>, the compiler accepts it (both Visual Studio 2013 and the online compiler C++ shell).</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef const int value_type;\n\nint main()\n{\n    const value_type  n = 0;   //ok \n    const const int   n2 = 0;  //error C4114\n\n    return 0;\n}\n</code></pre>\n<p>Does anyone have an idea as to why? Is it that one is <code>const (const int)</code>, which is different from <code>const const int</code>?</p>\n", "Tags": "<c++><const><typedef>", "OwnerUserId": "1079347", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45478054_45478126_5": {"section_id": 5430, "quality": 0.7560975609756098, "length": 31}}, "n3337": {"so_45478054_45478126_5": {"section_id": 5225, "quality": 0.6097560975609756, "length": 25}}, "n4659": {"so_45478054_45478126_4": {"section_id": 6814, "quality": 1.0, "length": 12}, "so_45478054_45478126_5": {"section_id": 6858, "quality": 0.7804878048780488, "length": 32}}}});