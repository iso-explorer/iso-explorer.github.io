post_cb({"26473160": {"ParentId": "26472434", "CommentCount": "1", "Body": "<p>Answer for C++11:\n VS is right, because according to <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/lwg-defects.html#2103\" rel=\"nofollow\">this</a> defect report, the specification of <code>std::allocator</code></p>\n<blockquote>\n<p id=\"so_26472434_26473160_0\">leads to the unneeded requirements (<code>MoveInsertable</code> and <code>MoveAssignable</code> of the value type) on the move assignment operator of containers with the default allocator.</p>\n</blockquote>\n<p>This was however fixed in C++14. So now <code>std::allocator</code> does not make this code illegal anymore and according to Table 96 in N3797, ([20.2.1,container.requirements.general]), the requirement for the template argument <code>T</code> of <code>std::vector&lt;T&gt; =: X</code> is</p>\n<blockquote>\n<p id=\"so_26472434_26473160_1\">Requires: T is Erasable from X</p>\n</blockquote>\n<p>which is true and <code>a = rv</code> for a value <code>a</code> of type <code>X</code> and an non-cpnst r-value <code>rv</code> of type <code>X</code> has the requirement </p>\n<blockquote>\n<p id=\"so_26472434_26473160_2\">a shall be equal to\n  the value that rv\n  had before this\n  assignment,</p>\n</blockquote>\n<p>so no further requirement to <code>T</code>. I did not find any additional requirements to <code>T</code> in [23.3.6,vector], so this should be legal code in C++14 (like the defect report suggests).</p>\n", "OwnerUserId": "3002139", "PostTypeId": "2", "Id": "26473160", "Score": "3", "CreationDate": "2014-10-20T19:10:08.723", "LastActivityDate": "2014-10-20T19:10:08.723"}, "bq_ids": {"n4140": {"so_26472434_26473160_2": {"section_id": 705, "quality": 1.0, "length": 5}, "so_26472434_26473169_2": {"section_id": 4224, "quality": 0.8571428571428571, "length": 6}, "so_26472434_26473169_0": {"section_id": 716, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_26472434_26473160_2": {"section_id": 695, "quality": 1.0, "length": 5}, "so_26472434_26473169_2": {"section_id": 4065, "quality": 0.8571428571428571, "length": 6}, "so_26472434_26473169_0": {"section_id": 705, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_26472434_26473160_2": {"section_id": 734, "quality": 1.0, "length": 5}, "so_26472434_26473169_2": {"section_id": 802, "quality": 0.5714285714285714, "length": 4}, "so_26472434_26473169_0": {"section_id": 746, "quality": 0.9230769230769231, "length": 12}}}, "26472434": {"CommentCount": "8", "AcceptedAnswerId": "26473169", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-10-20T18:27:11.393", "LastActivityDate": "2016-03-18T01:00:44.930", "LastEditDate": "2016-03-18T01:00:44.930", "ViewCount": "555", "FavoriteCount": "2", "Title": "Move assignment of vector of non-movable-non-copyable objects does not compile", "Id": "26472434", "Score": "13", "Body": "<p>The following code does not compile with Visual Studio 2013:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct X {\n    X() = default;\n    X(const X&amp;) = delete;\n    X&amp; operator=(const X&amp;) = delete;\n    X(X&amp;&amp;) = delete;\n    X&amp; operator=(X&amp;&amp;) = delete;\n    ~X() = default;\n};\n\nvoid foo()\n{\n    std::vector&lt;X&gt; v;\n    std::vector&lt;X&gt; w;\n    w = std::move(v);\n}\n</code></pre>\n<p>The error message says</p>\n<pre><code>error C2280: 'X::X(X &amp;&amp;)' : attempting to reference a deleted function\n</code></pre>\n<p>That makes no sense to me. You should not need the move constructor for <code>X</code> in order to move a <code>vector&lt;X&gt;</code>. Is this a compiler bug, or am I missing something?</p>\n<p>Here is the complete error message:</p>\n<pre><code>C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory0(600): error C2280: 'X::X(X &amp;&amp;)' : attempting to reference a deleted function\n    Test.cpp(9) : see declaration of 'X::X'\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory0(723) : see reference to function template instantiation 'void std::allocator&lt;_Ty&gt;::construct&lt;_Objty,_Ty&gt;(_Objty *,_Ty &amp;&amp;)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Objty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory0(723) : see reference to function template instantiation 'void std::allocator&lt;_Ty&gt;::construct&lt;_Objty,_Ty&gt;(_Objty *,_Ty &amp;&amp;)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Objty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory0(872) : see reference to function template instantiation 'void std::allocator_traits&lt;_Alloc&gt;::construct&lt;_Ty,_Ty&gt;(std::allocator&lt;_Ty&gt; &amp;,_Objty *,_Ty &amp;&amp;)' being compiled\n    with\n    [\n        _Alloc=std::allocator&lt;X&gt;\n    ,   _Ty=X\n    ,   _Objty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory0(872) : see reference to function template instantiation 'void std::allocator_traits&lt;_Alloc&gt;::construct&lt;_Ty,_Ty&gt;(std::allocator&lt;_Ty&gt; &amp;,_Objty *,_Ty &amp;&amp;)' being compiled\n    with\n    [\n        _Alloc=std::allocator&lt;X&gt;\n    ,   _Ty=X\n    ,   _Objty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory(378) : see reference to function template instantiation 'void std::_Wrap_alloc&lt;std::allocator&lt;_Ty&gt;&gt;::construct&lt;X,X&gt;(_Ty *,X &amp;&amp;)' being compiled\n    with\n    [\n        _Ty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory(378) : see reference to function template instantiation 'void std::_Wrap_alloc&lt;std::allocator&lt;_Ty&gt;&gt;::construct&lt;X,X&gt;(_Ty *,X &amp;&amp;)' being compiled\n    with\n    [\n        _Ty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory(416) : see reference to function template instantiation '_FwdIt std::_Uninit_copy&lt;_InIt,_FwdIt,std::allocator&lt;_Ty&gt;&gt;(_InIt,_InIt,_FwdIt,std::_Wrap_alloc&lt;std::allocator&lt;_Ty&gt;&gt; &amp;,std::_Nonscalar_ptr_iterator_tag)' being compiled\n    with\n    [\n        _FwdIt=X *\n    ,   _InIt=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ,   _Ty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\xmemory(427) : see reference to function template instantiation '_FwdIt std::_Uninit_copy&lt;_Iter,X,_Alloc&gt;(_InIt,_InIt,_FwdIt,_Alloc &amp;)' being compiled\n    with\n    [\n        _FwdIt=X *\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ,   _Alloc=std::_Wrap_alloc&lt;std::allocator&lt;X&gt;&gt;\n    ,   _InIt=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(1640) : see reference to function template instantiation '_FwdIt std::_Uninitialized_copy&lt;_Iter,X*,std::_Wrap_alloc&lt;std::allocator&lt;_Ty&gt;&gt;&gt;(_InIt,_InIt,_FwdIt,_Alloc &amp;)' being compiled\n    with\n    [\n        _FwdIt=X *\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ,   _Ty=X\n    ,   _InIt=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ,   _Alloc=std::_Wrap_alloc&lt;std::allocator&lt;X&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(789) : see reference to function template instantiation 'X *std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Ucopy&lt;_Iter&gt;(_Iter,_Iter,X *)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(789) : see reference to function template instantiation 'X *std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Ucopy&lt;_Iter&gt;(_Iter,_Iter,X *)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(766) : see reference to function template instantiation 'void std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Construct&lt;_Iter&gt;(_Iter,_Iter,std::forward_iterator_tag)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(766) : see reference to function template instantiation 'void std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Construct&lt;_Iter&gt;(_Iter,_Iter,std::forward_iterator_tag)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(854) : see reference to function template instantiation 'void std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Construct&lt;std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;&gt;(_Iter,_Iter)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(854) : see reference to function template instantiation 'void std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Construct&lt;std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;&gt;(_Iter,_Iter)' being compiled\n    with\n    [\n        _Ty=X\n    ,   _Iter=std::move_iterator&lt;std::_Vector_iterator&lt;std::_Vector_val&lt;std::_Simple_types&lt;X&gt;&gt;&gt;&gt;\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(849) : while compiling class template member function 'void std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Assign_rv(std::vector&lt;_Ty,std::allocator&lt;_Ty&gt;&gt; &amp;&amp;,std::false_type)'\n    with\n    [\n        _Ty=X\n    ]\n    C:\\Program Files (x86)\\Microsoft Visual Studio 12.0\\VC\\include\\vector(860) : see reference to function template instantiation 'void std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;::_Assign_rv(std::vector&lt;_Ty,std::allocator&lt;_Ty&gt;&gt; &amp;&amp;,std::false_type)' being compiled\n    with\n    [\n        _Ty=X\n    ]\n    Test.cpp(16) : see reference to class template instantiation 'std::vector&lt;X,std::allocator&lt;_Ty&gt;&gt;' being compiled\n    with\n    [\n        _Ty=X\n    ]\n</code></pre>\n", "Tags": "<c++><c++11><visual-studio-2013><language-lawyer><move-semantics>", "OwnerUserId": "763305", "AnswerCount": "2"}, "26473169": {"ParentId": "26472434", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As mentioned by dyp in the comments, this is a <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/lwg-defects.html#2103\">reported bug in C++11</a>*. The expression</p>\n<pre><code>a = rv\n</code></pre>\n<p><sub>(where <code>a</code> is a Container of type <code>X</code> with element type <code>T</code> and <code>rv</code> is a non-const rvalue of type <code>X</code>)</sub>\n<br>had the following requirement in Table 99, \"Allocator-aware container requirements\":</br></p>\n<blockquote>\n<p id=\"so_26472434_26473169_0\">If <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment\n  ::value</code>\n  is <code>false</code>, <code>T</code> is <em>MoveInsertable</em> into <code>X</code> and <em>MoveAssignable</em>. All\n  existing elements of <code>a</code> are either move assigned to or destroyed.</p>\n</blockquote>\n<p><code>allocator_traits</code> had the following definition of <code>propagate_on_container_move_assignment</code>:</p>\n<blockquote>\n<p id=\"so_26472434_26473169_1\"><code>typedef</code> <em>see below</em> <code>propagate_on_container_move_assignment;</code></p>\n<p id=\"so_26472434_26473169_2\"><em>Type:</em> <code>Alloc::propagate_on_container_move_assignment</code> if such a type exists, <br> otherwise <code>false_type</code>.</br></p>\n</blockquote>\n<p>The problem was that one forgot to put the corresponding typedef into <code>std::allocator</code>, so <code>propagate_on_container_move_assignment</code> was always <code>false</code>. This was resolved for C++14 by simply adding the typedef.</p>\n<p>* <sub>Note that [default.allocator] and [allocator.traits.types] are actually in \u00a720.6 in N3337, not \u00a720.7.</sub></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-10-20T19:17:09.623", "Id": "26473169", "Score": "11", "CreationDate": "2014-10-20T19:11:04.217", "LastActivityDate": "2014-10-20T19:17:09.623"}});