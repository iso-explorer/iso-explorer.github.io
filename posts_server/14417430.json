post_cb({"14417456": {"PostTypeId": "2", "Body": "<p>Sorry, this is not possible. The template argument must be a constant expression known at compile time.</p>\n", "LastActivityDate": "2013-01-19T18:34:04.173", "Id": "14417456", "CommentCount": "0", "CreationDate": "2013-01-19T18:34:04.173", "ParentId": "14417430", "Score": "2", "OwnerUserId": "49793"}, "14417442": {"Id": "14417442", "PostTypeId": "2", "Body": "<p>Template arguments must be compile-time constants aka \"constant expressions\" or <code>constexpr</code>s for short. So there is no way to do is using templates.</p>\n<p>You could use a dynamic-sized array and store its size in an <code>int</code>.</p>\n<p>Or simply use a <code>vector</code>. Be sure to initialize its size in the constructor by passing the desired size to the vector's constructor!</p>\n", "LastEditorUserId": "680982", "LastActivityDate": "2013-01-19T18:38:31.830", "CommentCount": "0", "CreationDate": "2013-01-19T18:32:33.427", "ParentId": "14417430", "Score": "3", "OwnerUserId": "680982", "LastEditDate": "2013-01-19T18:38:31.830"}, "14417430": {"ViewCount": "6342", "Body": "<p>I am trying to use an integer as a template parameter for a class. Here is a sample of the code:</p>\n<pre><code>template&lt; int array_qty &gt; \nclass sample_class {\n\n    public:\n        std::array&lt; std::string, array_qty &gt; sample_array;\n\n}\n</code></pre>\n<p>If I do so something like this, it works:</p>\n<pre><code>sample_class&lt; 10 &gt; sample_class_instance;\n</code></pre>\n<p>However, let's say that I do not know the value of array_qty (the template parameter) when compiling, and will only know it during run-time. In this case, I would essentially be passing an int variable as the template argument. For the sake of demonstration, the following code does not work:</p>\n<pre><code>int test_var = 2;\nint another_test_var = 5;\nint test_array_qty = test_var * another_test_var;\n\nsample_class&lt; test_array_qty &gt; sample_class_instance;\n</code></pre>\n<p>I get the following error during compile time when trying the above:</p>\n<pre><code>the value of \u2018test_array_qty\u2019 is not usable in a constant expression\n</code></pre>\n<p>I've tried converting test_array_qty to a const while passing it as the template parameter, but that doesn't seem to do the trick either. Is there any way to do this, or am I misusing template parameters? Perhaps they need to be known at compile time?</p>\n<p>The goal is NOT to solve this specific approach, but rather to find a way to set the length of the array to an int variable that can be stated when instantiating the class. If there is a way to do this via a template parameter, that would be ideal.</p>\n<p>Please note that I have to use an array for this, and NOT a vector which I may end up as a suggestion. Additionally, array_qty will always be a value between 0 and 50 - in case that makes a difference.</p>\n<hr>\n<p>Edit:</p>\n<p>I stated that I cannot use a vector for this because I CANNOT USE A VECTOR FOR THIS. Yes, I have benchmarked it. Either way, this question is not an exploration of \"arrays vs vectors\". I want to avoid this question having many comments and answers telling me to \"just use a vector\". That's kind of like going up to Edison and saying \"just use a candle\". Good programming is an exploration of what's possible, not just a statement of what's known. If we cannot figure this out due to sheer impossibility, that is one thing. Not exploring the possibility of a solution to this because \"a vector would be easier\" is not.</p>\n<p>Also, I do not understand why there is a downvote on this. This is a perfectly valid question asked in a coherent manner.</p>\n</hr>", "AcceptedAnswerId": "14417730", "Title": "Using an int as a template parameter that is not known until run-time", "CreationDate": "2013-01-19T18:30:59.640", "Id": "14417430", "CommentCount": "10", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-01-19T18:41:24.160", "LastEditorUserId": "396404", "LastActivityDate": "2015-10-27T01:20:10.430", "Score": "7", "OwnerUserId": "396404", "Tags": "<c++><templates><constexpr>", "AnswerCount": "4"}, "14417552": {"PostTypeId": "2", "Body": "<p>For C++ 11, non-type template arguments are restricted to the following (\u00a714.3.2/1):</p>\n<blockquote>\n<p id=\"so_14417430_14417552_0\">A template-argument for a non-type, non-template template-parameter shall be one of:<br/></p>\n<ul>\n<li>for a non-type template-parameter of integral or enumeration type, a converted constant expression (5.19) of the type of the template-parameter; or<br/></li>\n<li>the name of a non-type template-parameter; or<br/></li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates and function template-ids but excluding non-static class members, expressed (ignoring parentheses) as &amp; id-expression, except that the &amp; may be omitted if the name refers to a function or array and shall be omitted if the corresponding template-parameter is a reference; or<br/></li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or<br/></li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or<br/></li>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n</ul>\n</blockquote>\n<p>In C++ 98 and 03, the list is even more restricted. Bottom line: what you're trying to do simply isn't allowed.</p>\n", "LastActivityDate": "2013-01-19T18:43:18.633", "Id": "14417552", "CommentCount": "0", "CreationDate": "2013-01-19T18:43:18.633", "ParentId": "14417430", "Score": "5", "OwnerUserId": "179910"}, "bq_ids": {"n4140": {"so_14417430_14417552_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_14417430_14417552_0": {"length": 5, "quality": 1.0, "section_id": 82}}}, "14417730": {"Id": "14417730", "PostTypeId": "2", "Body": "<p>This can be done in effect.  But trust me when I say you are asking the wrong question.  So what follows answers your question, even thought doing it is a bad idea almost always.</p>\n<p>What you in effect can do is create 50 different programs, one for each of the 50 possible sizes, and then conditionally jump to the one you want.</p>\n<pre><code>template&lt;int n&gt;\nstruct prog {\n  void run() {\n    // ...\n  }\n};\n\n\ntemplate&lt;int n&gt;\nstruct switcher {\n  void run(int v) {\n    if(v==n)\n      prog&lt;n&gt;::run();\n    else\n      switcher&lt;n-1&gt;::run(v);\n  }\n};\n\ntemplate&lt;&gt;\nstruct switcher&lt;-1&gt; {\n  void run(int v){\n  }\n};\n</code></pre>\n<p>Call <code>switcher&lt;50&gt;::run( value );</code> and if value is 0 to 50, <code>prog&lt;value&gt;::run()</code> is invoked.  Within <code>prog::run</code> the template parameter is a compile time value.</p>\n<p>Horrid hack, and odds are you would be better off using another solution, but it is what you asked for.</p>\n<p>Here is a C++14 table-based version:</p>\n<pre><code>template&lt;size_t N&gt;\nusing index_t = std::integral_constant&lt;size_t, N&gt;; // C++14\n\ntemplate&lt;size_t M&gt;\nstruct magic_switch_t {\n  template&lt;class...Args&gt;\n  using R=std::result_of_t&lt;F(index_t&lt;0&gt;, Args...)&gt;;\n  template&lt;class F, class...Args&gt;\n  R&lt;Args...&gt; operator()(F&amp;&amp; f, size_t i, Args&amp;&amp;...args)const{\n    if (i &gt;= M)\n      throw i; // make a better way to return an error\n    return invoke(std::make_index_sequence&lt;M&gt;{}, std::forward&lt;F&gt;(f), i, std::forward&lt;Args&gt;(args)...);\n  }\nprivate:\n  template&lt;size_t...Is, class F, class...Args&gt;\n  R&lt;Args...&gt; invoke(std::index_sequence&lt;Is...&gt;, F&amp;&amp;f, size_t i, Args&amp;&amp;...args)const {\n    using pF=decltype(std::addressof(f));\n    using call_func = R&lt;Args...&gt;(*)(pF pf, Args&amp;&amp;...args);\n    static const call_func table[M]={\n      [](pF pf, Args&amp;&amp;...args)-&gt;R&lt;Args...&gt;{\n        return std::forward&lt;F&gt;(*pf)(index_t&lt;Is&gt;{}, std::forward&lt;Args&gt;(args)...);\n      }...\n    };\n    return table[i](std::addressof(f), std::forward&lt;Args&gt;(args)...);\n  }\n};\n</code></pre>\n<p><code>magic_switch_t&lt;N&gt;{}( f, 3, blah1, blah2, etc )</code> will invoke <code>f(index_t&lt;3&gt;{}, blah1, blah2, etc)</code>.</p>\n<p>Some C++14 compilers will choke on the variardic pack expansion containing a lambda.  It isn't essential, you can do a workaround, but the workaround is ugly.</p>\n<p>The C++14 features are all optional: you can implement it all in C++11, but again, ugly.</p>\n<p>The <code>f</code> passed basically should be a function object (either a lambda taking <code>auto</code> as the first argument, or a manual one).  Passing a function name directly won't work well, because the above best works when the first argument becomes a compile-time value.</p>\n<p>You can wrap a function template with a lambda or a function object to help.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-10-27T01:20:10.430", "CommentCount": "2", "CreationDate": "2013-01-19T18:58:32.723", "ParentId": "14417430", "Score": "8", "OwnerUserId": "1774667", "LastEditDate": "2015-10-27T01:20:10.430"}});