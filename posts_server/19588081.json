post_cb({"bq_ids": {"n4140": {"so_19588081_19588547_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6254}}, "n3337": {"so_19588081_19588547_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6014}}, "n4659": {"so_19588081_19588547_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7758}}}, "19588547": {"Id": "19588547", "PostTypeId": "2", "Body": "<p>Probably because the standard says so, 17.6.1.1/2:</p>\n<blockquote>\n<p id=\"so_19588081_19588547_0\">All library entities except macros, operator new and operator delete are de\ufb01ned within the namespace std or namespaces nested within namespace std.</p>\n</blockquote>\n<p>And you would still need to put <code>using ::swap</code> sometimes, so it would introduce even more special cases. Here I use <code>func</code> instead of <code>swap</code> - <a href=\"http://ideone.com/WAWBfZ\" rel=\"nofollow\">http://ideone.com/WAWBfZ</a> :</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nauto func(T) -&gt; void\n{\ncout &lt;&lt; \"::f\" &lt;&lt; endl;\n}\n\nnamespace my_ns {\nstruct my_struct {};\n\nauto func(my_struct) -&gt; void\n{\ncout &lt;&lt; \"my_ns::func\" &lt;&lt; endl;\n}\n\nauto another_func() -&gt; void\n{\n// won't compile without `using ::func;`\nfunc(123);\n}\n}\n\nauto main() -&gt; int {}\n</code></pre>\n<p>fails with</p>\n<pre><code>prog.cpp: In function \u2018void my_ns::another_func()\u2019:\nprog.cpp:21:17: error: could not convert \u2018123\u2019 from \u2018int\u2019 to \u2018my_ns::my_struct\u2019\n         func(123);\n</code></pre>\n", "LastEditorUserId": "476681", "LastActivityDate": "2013-10-25T12:04:49.380", "Score": "4", "CreationDate": "2013-10-25T11:26:15.420", "ParentId": "19588081", "CommentCount": "7", "OwnerUserId": "1641779", "LastEditDate": "2013-10-25T12:04:49.380"}, "19588081": {"ViewCount": "171", "Body": "<p>Item 25 in <a href=\"http://rads.stackoverflow.com/amzn/click/0321334876\" rel=\"nofollow\">Effective c++ third edition</a>, Scott Meyers suggests to implement swap in the same namespace as the class, and then when swapping to employ the using std::swap, and there the author says :</p>\n<blockquote>\n<p id=\"so_19588081_19588081_0\">For example, if you were to write the call to swap this way:</p>\n<pre><code>std::swap(obj1,obj2);  // the wrong way to call swap\n</code></pre>\n<p id=\"so_19588081_19588081_1\">you'd force the compiler to consider only the swap in std, thus\n  eliminating the possibility of getting a more appropriate T-specific\n  version defined elsewhere. Alas, some misguided programmers do qualify\n  calls to swap in this way, and that is why it's important to totally\n  specialize std::swap for your classes.</p>\n</blockquote>\n<p>The author recommends to always swap objects this way :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n#define CUSTOM_SWAP\n\nnamespace aaa{\n\nstruct A\n{\n};\n#ifdef CUSTOM_SWAP\nvoid swap( A&amp;, A&amp; )\n{\n    std::cout&lt;&lt;\"not std::swap\"&lt;&lt;std::endl;\n}\n#endif\n\n}\n\nint main() \n{\n    using std::swap;   // add std::swap to a list of possible resolutions\n\n    aaa::A a1;\n    aaa::A a2;\n\n    swap(a1,a2);\n}\n</code></pre>\n<p>Why isn't <code>std::swap</code> in global namespace? That way, it would be simpler to add custom swap functions.</p>\n", "AcceptedAnswerId": "19588547", "Title": "Why is not std::swap in global namespace?", "CreationDate": "2013-10-25T11:04:16.510", "Id": "19588081", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2013-10-25T12:04:49.380", "Score": "1", "OwnerUserId": "476681", "Tags": "<c++><swap>", "AnswerCount": "1"}});