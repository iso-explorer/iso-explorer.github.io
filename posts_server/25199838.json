post_cb({"25200031": {"Id": "25200031", "PostTypeId": "2", "Body": "<h2>Why doing exchange in a loop?</h2>\n<p>Usually, you want your work to be done before you move on, thus, you put <code>compare_exchange_weak</code> into a loop so that it tries to exchange until it succeeds (i.e., returns <code>true</code>).</p>\n<p>Note that also <code>compare_exchange_strong</code> is often used in a loop. It does not fail due to spurious failure, but it does fail due to concurrent writes.</p>\n<h2>Why to use <code>weak</code> instead of <code>strong</code>?</h2>\n<p>Quite easy: Spurious failure does not happen often, so it is no big performance hit. In constrast, tolerating such a failure allows for a much more efficient implementation of the <code>weak</code> version (in comparison to <code>strong</code>) on some platforms: <code>strong</code> must always check for spurious failure  and mask it. This is expensive.</p>\n<p>Thus, <code>weak</code> is used because it is a lot faster than <code>strong</code> on some platforms</p>\n<h2>When should you use <code>weak</code> and when <code>strong</code>?</h2>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange\">reference</a> states hints when to use <code>weak</code> and when to use <code>strong</code>:</p>\n<blockquote>\n<p id=\"so_25199838_25200031_0\">When a compare-and-exchange is in a loop, the weak version will yield\n  better performance on some platforms. When a weak compare-and-exchange\n  would require a loop and a strong one would not, the strong one is\n  preferable.</p>\n</blockquote>\n<p>So the answer seems to be quite simple to remember: If you would have to introduce a loop only because of spurious failure, don't do it; use <code>strong</code>. If you have a loop anyway, then use <code>weak</code>.</p>\n<h2>Why is <code>!expected</code> in the example</h2>\n<p>It depends on the situation and its desired semantics, but usually it is not needed for correctness. Omitting it would yield a very similar semantics. Only in a case where another thread might reset the value to <code>false</code>, the semantics could become slightly different (yet I  cannot find a meaningful example where you would want that). See Tony D.'s comment for a detailed explanation.</p>\n<p>It is simply a fast track when <em>another</em> thread writes <code>true</code>: Then the we abort instead of trying to write <code>true</code> again.</p>\n<h2>About your last question</h2>\n<blockquote>\n<p id=\"so_25199838_25200031_1\">But as analyzed above, two versions in a loop should give the same/similar performance.\n  What's the thing I miss?</p>\n</blockquote>\n<p>From <a href=\"http://en.wikipedia.org/wiki/Load-link/store-conditional\">Wikipedia</a>:</p>\n<blockquote>\n<p id=\"so_25199838_25200031_2\">Real implementations of LL/SC do not always succeed if there are no\n  concurrent updates to the memory location in question. Any exceptional\n  events between the two operations, such as a context switch, another\n  load-link, or even (on many platforms) another load or store\n  operation, will cause the store-conditional to spuriously fail. Older\n  implementations will fail if there are any updates broadcast over the\n  memory bus.</p>\n</blockquote>\n<p>So, LL/SC will fail spuriously on context switch, for example. Now, the strong version would bring its \"own small loop\" to detect that spurious failure and mask it by trying again. Note that this own loop is also more complicated than a usual CAS loop, since it must distinguish between spurious failure (and mask it) and failure due to concurrent access (which results in a return with value <code>false</code>). The weak version does not have such own loop.</p>\n<p>Since you provide an explicit loop in both examples, it is simply not necessary to have the small loop for the strong version. Consequently, in the example with the <code>strong</code> version, the check for failure is done twice; once by <code>compare_exchange_strong</code> (which is more complicated since it must distinguish spurious failure and concurrent acces) and once by your loop. This expensive check is unnecessary and the reason why <code>weak</code> will be faster here.</p>\n<p>Also note that your argument (LL/SC) is just <strong>one</strong> possibility to implement this. There are more platforms that have even different instruction sets. In addition (and more importantly), note that <code>std::atomic</code> must support all operations for <em>all possible data types</em>, so even if you declare a ten million byte struct, you can use <code>compare_exchange</code> on this. Even when on a CPU that does have CAS, you cannot CAS ten million bytes, so the compiler will generate other instructions (probably lock acquire, followed by a non-atomic compare and swap, followed by a lock release). Now, think of how many things can happen while swapping ten million bytes. So while a spurious error may be very rare for 8 byte exchanges, it might be more common in this case.</p>\n<p>So in a nutshell, C++ gives you two semantics, a \"best effort\" one (<code>weak</code>) and a \"I will do it for sure, no matter how many bad things might happen inbetween\" one (<code>strong</code>). How these are implemented on various data types and platforms is a totally different topic.  Don't tie your mental model to the implementation on your specific platform; the standard library is designed to work with more architectures than you might be aware of. The only general conclusion we can draw is that guaranteeing success is usually more difficult (and thus may require additional work) than just trying and leaving room for possible failure.</p>\n", "LastEditorUserId": "1408611", "LastActivityDate": "2014-08-11T08:30:25.247", "Score": "49", "CreationDate": "2014-08-08T09:21:23.507", "ParentId": "25199838", "CommentCount": "7", "LastEditDate": "2014-08-11T08:30:25.247", "OwnerUserId": "1408611"}, "25199838": {"ViewCount": "13046", "Body": "<pre><code>bool compare_exchange_weak (T&amp; expected, T val, ..);\n</code></pre>\n<p><code>compare_exchange_weak()</code> is one of compare-exchange primitives provided in C++11. It's <strong><em>weak</em></strong> in the sense that it returns false even if the value of the object is equal to <code>expected</code>. This is due to <strong><em>spurious failure</em></strong> on some platforms where a sequence of instructions (instead of one as on x86) are used to implement it. On such platforms, context switch, reloading of the same address (or cache line) by another thread, etc can fail the primitive. It's <code>spurious</code> as it's not the value of the object (not equal to <code>expected</code>) that fails the operation. Instead, it's kind of timing issues.</p>\n<p>But what puzzles me is what's said in C++11 Standard (ISO/IEC 14882),</p>\n<blockquote>\n<p id=\"so_25199838_25199838_0\">29.6.5\n  ..\n  A consequence of spurious failure is that nearly all uses of weak\n  compare-and-exchange will be in a loop.</p>\n</blockquote>\n<p>Why does it have to be in a loop in <strong><em>nearly all uses</em></strong> ? Does that mean we shall loop when it fails because of spurious failures? If that's the case, why do we bother use <code>compare_exchange_weak()</code> and write the loop ourselves? We can just use <code>compare_exchange_strong()</code> which I think should get rid of spurious failures for us. What are the common use cases of <code>compare_exchange_weak()</code>?</p>\n<p>Another question related. In his book \"C++ Concurrency In Action\" Anthony says,</p>\n<pre><code>//Because compare_exchange_weak() can fail spuriously, it must typically\n//be used in a loop:\n\nbool expected=false;\nextern atomic&lt;bool&gt; b; // set somewhere else\nwhile(!b.compare_exchange_weak(expected,true) &amp;&amp; !expected);\n\n//In this case, you keep looping as long as expected is still false,\n//indicating that the compare_exchange_weak() call failed spuriously.\n</code></pre>\n<p>Why is <code>!expected</code> there in the loop condition? Does it there to prevent that all threads may starve and make no progress for some time?</p>\n<p><strong>Edit: (one last question)</strong></p>\n<p>On platforms that no single hardware CAS instruction exist, both the weak and strong version are implemented using LL/SC (like ARM, PowerPC, etc). So is there any difference between the following two loops? Why, if any? (To me, they should have similar performance.)</p>\n<pre><code>// use LL/SC (or CAS on x86) and ignore/loop on spurious failures\nwhile (!compare_exchange_weak(..))\n{ .. }\n\n// use LL/SC (or CAS on x86) and ignore/loop on spurious failures\nwhile (!compare_exchange_strong(..)) \n{ .. }\n</code></pre>\n<p>I come up w/ this last question you guys all mention that there maybe a performance difference inside a loop. It's also mentioned by the C++11 Standard (ISO/IEC 14882):</p>\n<blockquote>\n<p id=\"so_25199838_25199838_1\">When a compare-and-exchange is in a loop, the weak version will yield\n  better performance on some platforms.</p>\n</blockquote>\n<p>But as analyzed above, two versions in a loop should give the same/similar performance. What's the thing I miss?</p>\n", "AcceptedAnswerId": "25217283", "Title": "Understanding std::atomic::compare_exchange_weak() in C++11", "CreationDate": "2014-08-08T09:11:32.460", "Id": "25199838", "CommentCount": "5", "FavoriteCount": "26", "PostTypeId": "1", "LastEditDate": "2014-08-09T09:59:14.663", "LastEditorUserId": "419391", "LastActivityDate": "2014-08-11T08:30:25.247", "Score": "59", "OwnerUserId": "419391", "Tags": "<c++><multithreading><c++11><atomic>", "AnswerCount": "4"}, "25200054": {"Id": "25200054", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25199838_25200054_0\">Why does it have to be in a loop in <strong>nearly all uses</strong> ?</p>\n</blockquote>\n<p>Because if you don't loop and it fails spuriously your program hasn't done anything useful - you didn't update the atomic object and you don't know what its current value is (Correction: see comment below from Cameron). If the call doesn't do anything useful what's the point of doing it?</p>\n<blockquote>\n<p id=\"so_25199838_25200054_1\">Does that mean we shall loop when it fails because of spurious failures?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_25199838_25200054_2\">If that's the case, why do we bother use <code>compare_exchange_weak()</code> and write the loop ourselves? We can just use compare_exchange_strong() which I think should get rid of spurious failures for us. What are the common use cases of compare_exchange_weak()?</p>\n</blockquote>\n<p>On some architectures <code>compare_exchange_weak</code> is more efficient, and spurious failures should be fairly uncommon, so it might be possible to write more efficient algorithms using the weak form and a loop.</p>\n<p>In general it is probably better to use the strong version instead if your algorithm doesn't need to loop, as you don't need to worry about spurious failures. If it needs to loop anyway even for the strong version (and many algorithms do need to loop anyway), then using the weak form might be more efficient on some platforms.</p>\n<blockquote>\n<p id=\"so_25199838_25200054_3\">Why is <code>!expected</code> there in the loop condition?</p>\n</blockquote>\n<p>The value could have got set to <code>true</code> by another thread, so you don't want to keep looping trying to set it.</p>\n<p><strong>Edit:</strong></p>\n<blockquote>\n<p id=\"so_25199838_25200054_4\">But as analyzed above, two versions in a loop should give the same/similar performance. What's the thing I miss?</p>\n</blockquote>\n<p>Surely it's obvious that on platforms where spurious failure is possible the implementation of <code>compare_exchange_strong</code> has to be more complicated, to check for spurious failure and retry.</p>\n<p>The weak form just returns on spurious failure, it doesn't retry.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2014-08-08T17:33:31.253", "Score": "15", "CreationDate": "2014-08-08T09:22:42.020", "ParentId": "25199838", "CommentCount": "7", "LastEditDate": "2014-08-08T17:33:31.253", "OwnerUserId": "981959"}, "25207431": {"Id": "25207431", "PostTypeId": "2", "Body": "<p>Alright, so I need a function which performs atomic left-shifting. My processor doesn't have a native operation for this, and the standard library doesn't have a function for it, so it looks like I'm writing my own. Here goes:</p>\n<pre><code>void atomicLeftShift(std::atomic&lt;int&gt;* var, int shiftBy)\n{\n    do {\n        int oldVal = std::atomic_load(var);\n        int newVal = oldVal &lt;&lt; shiftBy;\n    } while(!std::compare_exchange_weak(oldVal, newVal));\n}\n</code></pre>\n<p>Now, there's two reasons that loop might be executed more than once.</p>\n<ol>\n<li>Someone else changed the variable while I was doing my left shift. The results of my computation should not be applied to the atomic variable, because it would effectively erase that someone else's write.</li>\n<li>My CPU burped and the weak CAS spuriously failed.</li>\n</ol>\n<p>I honestly don't care which one. Left shifting is fast enough that I may as well just do it again, even if the failure was spurious.</p>\n<p>What's <em>less</em> fast, though, is the extra code that strong CAS needs to wrap around weak CAS in order to be strong. That code doesn't do much when the weak CAS succeeds... but when it fails, strong CAS needs to do some detective work to determine whether it was Case 1 or Case 2. That detective work takes the form of a second loop, effectively inside my own loop. Two nested loops. Imagine your algorithms teacher glaring at you right now.</p>\n<p>And as I previously mentioned, I don't care about the result of that detective work! Either way I'm going to be redoing the CAS. So using strong CAS gains me precisely nothing, and loses me a small but measurable amount of efficiency.</p>\n<p>In other words, weak CAS is used to implement atomic update operations. Strong CAS is used when you care about the result of CAS.</p>\n", "LastActivityDate": "2014-08-08T15:53:29.600", "Score": "9", "CreationDate": "2014-08-08T15:53:29.600", "ParentId": "25199838", "CommentCount": "0", "OwnerUserId": "787480"}, "25217283": {"Id": "25217283", "PostTypeId": "2", "Body": "<p>I'm trying to answer this myself, after going through various online resources (e.g., <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html\" rel=\"noreferrer\">this one</a> and <a href=\"http://cbloomrants.blogspot.be/2011/07/07-14-11-compareexchangestrong-vs.html\" rel=\"noreferrer\">this one</a>), the C++11 Standard, as well as the answers given here.</p>\n<p>The related questions are merged (e.g., \"<strong><em>why !expected ?</em></strong>\" is merged with <strong><em>\"why put compare_exchange_weak() in a loop ?</em></strong>\") and answers are given accordingly.</p>\n<hr>\n<h2>Why does compare_exchange_weak() have to be in a loop in nearly all uses?</h2>\n<p><strong>Typical Pattern A</strong></p>\n<p>You need achieve an atomic update based on the value in the atomic variable. A failure indicates that the variable is not updated with our desired value and we want to retry it. Note that <em>we don't really care about whether it fails due to concurrent write or spurious failure. But we do care that</em> <strong><em>it is us</em></strong> <em>that make this change.</em></p>\n<pre><code>expected = current.load();\ndo desired = function(expected);\nwhile (!current.compare_exchange_weak(expected, desired));\n</code></pre>\n<p>A real-world example is for several threads to add an element to a singly linked list concurrently. Each thread first loads the head pointer, allocates a new node and appends the head to this new node. Finally, it tries to swap the new node with the head.</p>\n<p>Another example is to implement mutex using <code>std::atomic&lt;bool&gt;</code>. At most one thread can enter the critical section at a time, depending on which thread first set <code>current</code> to <code>true</code> and exit the loop.</p>\n<p><strong>Typical Pattern B</strong></p>\n<p>This is actually the pattern mentioned in Anthony's book. In contrary to pattern A, <em>you want the atomic variable to be updated once, but you don't care who does it.</em> As long as it's not updated, you try it again. This is typically used with boolean variables. E.g., you need implement a trigger for a state machine to move on. Which thread pulls the trigger is regardless.</p>\n<pre><code>expected = false;\n// !expected: if expected is set to true by another thread, it's done!\n// Otherwise, it fails spuriously and we should try again.\nwhile (!current.compare_exchange_weak(expected, true) &amp;&amp; !expected);\n</code></pre>\n<p>Note that we generally cannot use this pattern to implement a mutex. Otherwise, multiple threads may be inside the critical section at the same time.</p>\n<p>That said, it should be rare to use <code>compare_exchange_weak()</code> outside a loop. On the contrary, there are cases that the strong version is in use. E.g.,</p>\n<pre><code>bool criticalSection_tryEnter(lock)\n{\n  bool flag = false;\n  return lock.compare_exchange_strong(flag, true);\n}\n</code></pre>\n<p><code>compare_exchange_weak</code> is not proper here because when it returns due to spurious failure, it's likely that no one occupies the critical section yet.</p>\n<h2>Starving Thread?</h2>\n<p>One point worth mentioning is that what happens if spurious failures continue to happen thus starving the thread? Theoretically it could happen on platforms when <code>compare_exchange_XXX()</code> is implement as a sequence of instructions (e.g., LL/SC). Frequent access of the same cache line between LL and SC will produce continuous spurious failures. A more realistic example is due to a dumb scheduling where all concurrent threads are interleaved in the following way.</p>\n<pre><code>Time\n |  thread 1 (LL)\n |  thread 2 (LL)\n |  thread 1 (compare, SC), fails spuriously due to thread 2's LL\n |  thread 1 (LL)\n |  thread 2 (compare, SC), fails spuriously due to thread 1's LL\n |  thread 2 (LL)\n v  ..\n</code></pre>\n<p><em>Can it happen?</em></p>\n<p>It won't happen forever, fortunately, thanks to what C++11 requires:</p>\n<blockquote>\n<p id=\"so_25199838_25217283_0\">Implementations should ensure that weak compare-and-exchange\n  operations do not consistently return false unless either the atomic\n  object has value different from expected or there are concurrent\n  modifications to the atomic object.</p>\n</blockquote>\n<h2>Why do we bother use compare_exchange_weak() and write the loop ourselves? We can just use compare_exchange_strong().</h2>\n<p>It depends.</p>\n<p><strong>Case 1: When both need to be used inside a loop.</strong> C++11 says:</p>\n<blockquote>\n<p id=\"so_25199838_25217283_1\">When a compare-and-exchange is in a loop, the weak version will yield\n  better performance on some platforms.</p>\n</blockquote>\n<p>On x86 (at least currently. Maybe it'll resort to a similiar scheme as LL/SC one day for performance when more cores are introduced), the weak and strong version are essentially the same because they both boil down to the single instruction <code>cmpxchg</code>. On some other platforms where <code>compare_exchange_XXX()</code> isn't implemented <em>atomically</em> (here meaning no single hardware primitive exists), the weak version inside the loop may win the battle because the strong one will have to handle the spurious failures and retry accordingly.</p>\n<p><strong><em>But,</em></strong></p>\n<p>rarely, we may prefer <code>compare_exchange_strong()</code> over <code>compare_exchange_weak()</code> even in a loop. E.g., when there is a lot of things to do between atomic variable is loaded and a calculated new value is exchanged out (see <code>function()</code> above). If the atomic variable itself doesn't change frequently, we don't need repeat the costly calculation for every spurious failure. Instead, we may hope that <code>compare_exchange_strong()</code> \"absorb\" such failures and we only repeat calculation when it fails due to a real value change.</p>\n<p><strong>Case 2: When only</strong> <code>compare_exchange_weak()</code> <strong>need to be used inside a loop.</strong> C++11 also says:</p>\n<blockquote>\n<p id=\"so_25199838_25217283_2\">When a weak compare-and-exchange would require a loop and a strong one\n  would not, the strong one is preferable.</p>\n</blockquote>\n<p>This is typically the case when you loop just to eliminate spurious failures from the weak version. You retry until exchange is either successful or failed because of concurrent write.</p>\n<pre><code>expected = false;\n// !expected: if it fails spuriously, we should try again.\nwhile (!current.compare_exchange_weak(expected, true) &amp;&amp; !expected);\n</code></pre>\n<p>At best, it's reinventing the wheels and perform the same as <code>compare_exchange_strong()</code>. Worse? <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2748.html\" rel=\"noreferrer\">This approach fails to take full advantage of machines that provide non-spurious compare-and-exchange in hardware</a>. </p>\n<p>Last, if you loop for other things (e.g., see \"Typical Pattern A\" above), then there is a good chance that <code>compare_exchange_strong()</code> shall also be put in a loop, which brings us back to the previous case.</p>\n</hr>", "LastEditorUserId": "419391", "LastActivityDate": "2014-08-10T13:35:48.950", "Score": "9", "CreationDate": "2014-08-09T09:51:32.643", "ParentId": "25199838", "CommentCount": "0", "LastEditDate": "2014-08-10T13:35:48.950", "OwnerUserId": "419391"}, "bq_ids": {"n4140": {"so_25199838_25217283_1": {"length": 11, "quality": 1.0, "section_id": 1204}, "so_25199838_25217283_2": {"length": 12, "quality": 1.0, "section_id": 1204}, "so_25199838_25199838_1": {"length": 11, "quality": 1.0, "section_id": 1204}, "so_25199838_25217283_0": {"length": 19, "quality": 1.0, "section_id": 1203}, "so_25199838_25200031_0": {"length": 23, "quality": 1.0, "section_id": 1204}, "so_25199838_25199838_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 1204}}, "n3337": {"so_25199838_25217283_1": {"length": 11, "quality": 1.0, "section_id": 1202}, "so_25199838_25217283_2": {"length": 12, "quality": 1.0, "section_id": 1202}, "so_25199838_25199838_1": {"length": 11, "quality": 1.0, "section_id": 1202}, "so_25199838_25217283_0": {"length": 19, "quality": 1.0, "section_id": 1201}, "so_25199838_25200031_0": {"length": 23, "quality": 1.0, "section_id": 1202}, "so_25199838_25199838_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 1202}}, "n4659": {"so_25199838_25217283_1": {"length": 11, "quality": 1.0, "section_id": 1284}, "so_25199838_25217283_2": {"length": 12, "quality": 1.0, "section_id": 1284}, "so_25199838_25199838_1": {"length": 11, "quality": 1.0, "section_id": 1284}, "so_25199838_25217283_0": {"length": 19, "quality": 1.0, "section_id": 1283}, "so_25199838_25200031_0": {"length": 23, "quality": 1.0, "section_id": 1284}, "so_25199838_25199838_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 1284}}}});