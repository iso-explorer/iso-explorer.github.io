post_cb({"17386761": {"ParentId": "17386722", "CommentCount": "8", "Body": "<p>Operator overloading in C++ adds all sorts of nasty complexities. (It lets you do awesome stuff too\u2014but sometimes it's just a headache.)</p>\n<p>As explained in the other answers, C++ is doing some automatic type coercion on your function pointers. If you just use the good ol' C-style <code>printf</code> you should get the results you're expecting:</p>\n<pre><code>#include &lt;cstdio&gt;\n\n// ...\n\nprintf(\"func1: %p\\nfunc2: %p\\n\", funcOne, funcTwo);\n</code></pre>\n", "OwnerUserId": "1427124", "PostTypeId": "2", "Id": "17386761", "Score": "1", "CreationDate": "2013-06-30T03:09:12.660", "LastActivityDate": "2013-06-30T03:09:12.660"}, "bq_ids": {"n4140": {"so_17386722_17386795_0": {"section_id": 40, "quality": 0.5909090909090909, "length": 26}}, "n3337": {"so_17386722_17386795_0": {"section_id": 37, "quality": 0.9545454545454546, "length": 42}}, "n4659": {"so_17386722_17386795_0": {"section_id": 41, "quality": 0.5227272727272727, "length": 23}}}, "17386722": {"CommentCount": "7", "ViewCount": "147", "CreationDate": "2013-06-30T03:00:20.433", "LastActivityDate": "2013-06-30T03:17:14.163", "Title": "Why do function pointers all have the same value?", "AcceptedAnswerId": "17386795", "PostTypeId": "1", "Id": "17386722", "Score": "2", "Body": "<p>For example:</p>\n<pre><code>using namespace std;\n#include &lt;iostream&gt;\n\nvoid funcOne() {\n}\n\nvoid funcTwo( int x ) {\n}\n\nint main() {\n\n  void (*ptrOne)() = funcOne;\n  cout &lt;&lt; ptrOne &lt;&lt; endl;      //prints 1\n\n  void (*ptrTwo)( int x ) = funcTwo;\n  cout &lt;&lt; ptrTwo &lt;&lt; endl;      //prints 1\n\n  int (*ptrMain)() = main;\n  cout &lt;&lt; ptrMain &lt;&lt; endl;     //prints 1\n\n}\n</code></pre>\n<p>Does anyone know the reasoning behind this? At first I thought it was because the functions don't exist in memory since I never call on them, and thus they never get added to the stack.  But even the value of a pointer to the main function prints out 1.</p>\n", "Tags": "<c++><function-pointers>", "OwnerUserId": "1953105", "AnswerCount": "4"}, "17386795": {"ParentId": "17386722", "CommentCount": "2", "Body": "<p>Function pointers do not implicitly convert to <code>void *</code>, which is what <code>operator &lt;&lt;</code> overloads on.</p>\n<p>This is specified by omission in C++11 \u00a74.10/2:</p>\n<blockquote>\n<p id=\"so_17386722_17386795_0\">A prvalue of type \u201cpointer to cv T,\u201d <strong>where T is an object type,</strong> can be converted to a prvalue of type \u201cpointer to cv void\u201d. The result of converting a \u201cpointer to cv T\u201d to a \u201cpointer to cv void\u201d points to the start of the storage location where the object of type T resides, as if the object is a most derived object (1.8) of type T (that is, not a base class subobject). The null pointer value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>Function types are not object types.</p>\n<p>Moreover, you can't even do it using <code>static_cast</code>. Functions and objects may live in completely different address spaces (this is called Harvard architecture), with differently-sized pointers. Converting a function pointer to <code>void *</code> can <em>maybe</em> be done with <code>reinterpret_cast</code>: it's \"conditionally-supported\" (C++11 \u00a75.2.10/8). Such a <code>void *</code> should only be used for printing or conversion back to the original function pointer type.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "17386795", "Score": "7", "CreationDate": "2013-06-30T03:17:14.163", "LastActivityDate": "2013-06-30T03:17:14.163"}, "17386750": {"ParentId": "17386722", "CommentCount": "4", "Body": "<p>Try this instead:</p>\n<pre><code>void (*ptrOne)() = funcOne;\ncout &lt;&lt; reinterpret_cast&lt;void*&gt;(ptrOne) &lt;&lt; endl;\n\nvoid (*ptrTwo)( int x ) = funcTwo;\ncout &lt;&lt; reinterpret_cast&lt;void*&gt;(ptrTwo) &lt;&lt; endl;\n\nint (*ptrMain)() = main;\ncout &lt;&lt; reinterpret_cast&lt;void*&gt;(ptrMain) &lt;&lt; endl;\n</code></pre>\n<p>I think normally, function overloading rules mean that the version of <code>&lt;&lt;</code> being called is <code>operator&lt;&lt;(bool)</code>, which means:</p>\n<pre><code>cout &lt;&lt; ptrOne &lt;&lt; endl;\n</code></pre>\n<p>Gets transformed into:</p>\n<pre><code>cout &lt;&lt; (ptrOne != NULL) &lt;&lt; endl;\n</code></pre>\n<p>Which is the same as:</p>\n<pre><code>cout &lt;&lt; true &lt;&lt; endl;\n</code></pre>\n", "OwnerUserId": "82294", "PostTypeId": "2", "Id": "17386750", "Score": "0", "CreationDate": "2013-06-30T03:06:22.233", "LastActivityDate": "2013-06-30T03:06:22.233"}, "17386746": {"ParentId": "17386722", "CommentCount": "3", "Body": "<p>Use it like this, or it will be converted to a <code>bool</code> type.</p>\n<pre><code>cout &lt;&lt; reinterpret_cast&lt;void*&gt;(ptrOne) &lt;&lt; endl;\n</code></pre>\n", "OwnerUserId": "1009479", "PostTypeId": "2", "Id": "17386746", "Score": "2", "CreationDate": "2013-06-30T03:06:08.837", "LastActivityDate": "2013-06-30T03:06:08.837"}});