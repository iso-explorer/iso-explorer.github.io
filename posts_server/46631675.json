post_cb({"46631675": {"ViewCount": "71", "Body": "<p>In his book \"Programming, Principles and practices using C++\" Bjarne Stroustrup introduces the concept of <strong>member initializer list</strong> on pages 314-316 (\u00a7 9.4.4). He uses the following example:</p>\n<pre><code>// Simple Date (year, month, day)\n\nclass Date\n{\npublic:\n    Date(int yy, int mm, int dd): y{yy}, m{mm}, d{dd}\n    {\n        //...\n    }\n\nprivate:\n    int y, m, d;\n};\n</code></pre>\n<p>On page 315 he says:</p>\n<blockquote>\n<p id=\"so_46631675_46631675_0\">We could have written:</p>\n<pre><code>Date::Date(int yy, int mm, int dd)  // constructor\n{\n    y = yy;\n    m = mm;\n    d = dd;\n}\n</code></pre>\n<p id=\"so_46631675_46631675_1\">but then we would in principle first have default initialized the members and then assigned values to them.</p>\n</blockquote>\n<p>Therefore, can I conclude that using <strong>member initializer lists</strong> makes the code slightly faster? Of course, no one would notice on a modern PC. But I'm planning to use C++ for embedded development.</p>\n<p>EDIT:<br>\nI'll further specify my question. By \"slightly faster\" I actually mean \"less CPU cycles involved\".<br>\nI also agree that the potential efficiency increase for this particular example will be near to nothing. But for much larger classes and structs, it might become noticable on a microcontroller.</br></br></p>\n", "AcceptedAnswerId": "46631778", "Title": "Will using a member initializer list make the initialization slightly faster?", "CreationDate": "2017-10-08T13:35:39.353", "Id": "46631675", "CommentCount": "5", "LastEditDate": "2017-10-08T13:45:03.727", "PostTypeId": "1", "LastEditorUserId": "6178507", "LastActivityDate": "2017-10-08T13:46:28.180", "Score": "2", "OwnerUserId": "6178507", "Tags": "<c++><c++11><initializer-list>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_46631675_46631769_1": {"length": 4, "quality": 1.0, "section_id": 3286}, "so_46631675_46631769_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 3286}, "so_46631675_46631769_3": {"length": 5, "quality": 1.0, "section_id": 3286}}, "n3337": {"so_46631675_46631769_1": {"length": 4, "quality": 1.0, "section_id": 3156}, "so_46631675_46631769_2": {"length": 13, "quality": 0.5652173913043478, "section_id": 359}, "so_46631675_46631769_3": {"length": 5, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_46631675_46631769_2": {"length": 12, "quality": 0.5217391304347826, "section_id": 382}, "so_46631675_46631769_3": {"length": 5, "quality": 1.0, "section_id": 4048}}}, "46631769": {"Id": "46631769", "PostTypeId": "2", "Body": "<p>The C++ standard specifies \"default initialization\" as follows:</p>\n<blockquote>\n<p id=\"so_46631675_46631769_0\">[dcl.init]</p>\n<p id=\"so_46631675_46631769_1\">To default-initialize an object of type T means:</p>\n<p id=\"so_46631675_46631769_2\">\u2014 if T is\n  a (possibly cv-qualified) class type (Clause 9), the default\n  constructor (12.1) for T is called (and the initialization is\n  ill-formed if T has no default constructor or overload resolution\n  (13.3) results in an ambiguity or in a function that is deleted or\n  inaccessible from the context of the initialization);</p>\n<p id=\"so_46631675_46631769_3\">\u2014 if T is an\n  array type, each element is default-initialized;</p>\n<p id=\"so_46631675_46631769_4\">\u2014 otherwise, no initialization is performed.</p>\n</blockquote>\n<p>Your class members are plain, garden-variety, <code>int</code>s. They are not classes. They are not arrays. Therefore default-initialization, in the case of <code>int</code>s, does nothing.</p>\n<p>I will expect most compilers to generate identical code, in both of your examples. It makes no difference, whatsoever.</p>\n", "LastActivityDate": "2017-10-08T13:45:08.740", "CommentCount": "4", "CreationDate": "2017-10-08T13:45:08.740", "ParentId": "46631675", "Score": "1", "OwnerUserId": "3943312"}, "46631778": {"Id": "46631778", "PostTypeId": "2", "Body": "<p>In the second example you are not initializing, you are assigning to variables which have been already initialized. The variables are initialized (default constructed) before entering the constructor, so you are actually setting them twice.</p>\n<p>An <code>int</code> doesn't have any specific default initializer so you don't notice but try with different code <a href=\"https://ideone.com/u9GHv6\" rel=\"noreferrer\">as in</a></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Foo\n{\n  int x;\n\npublic:\n  Foo() : x(0) { cout &lt;&lt; \"Foo()\" &lt;&lt; endl; }\n  Foo(int x) : x(x) { cout &lt;&lt; \"Foo(int)\" &lt;&lt; endl; }\n  Foo&amp; operator=(const Foo&amp; o) { \n    cout &lt;&lt; \"Foo::operator=(const Foo&amp;)\" &lt;&lt; endl; \n    this-&gt;x = o.x; return *this;\n  }\n};\n\nclass Bar\n{\n   Foo foo;\npublic:  \n   Bar(const Foo&amp; foo) { this-&gt;foo = foo; }\n   Bar(bool, const Foo&amp; foo) : foo(foo) { }\n};\n\nint main() {\n  cout &lt;&lt; \"Assigned in constructor\" &lt;&lt; endl;\n  Bar bar = Bar(Foo(5));\n  cout &lt;&lt; \"Assigned in initializer list\" &lt;&lt; endl;\n  Bar bar2 = Bar(false, Foo(5));\n}\n</code></pre>\n<p>This prints </p>\n<pre><code>Assigned in constructor\nFoo(int)\nFoo()\nFoo::operator=(const Foo&amp;)\nAssigned in initializer list\nFoo(int)\n</code></pre>\n<p>so you see they're definitely not equivalent. Indeed, for example, you are not able to assign a <code>const</code> field in a constructor</p>\n", "LastActivityDate": "2017-10-08T13:46:28.180", "CommentCount": "7", "CreationDate": "2017-10-08T13:46:28.180", "ParentId": "46631675", "Score": "5", "OwnerUserId": "121747"}});