post_cb({"32141599": {"ParentId": "32132574", "CommentCount": "23", "Body": "<p>Undefined behavior is simply the result of a situation coming up that the writers of the specification did not foresee. </p>\n<p>Take the idea of a traffic light. Red means stop, yellow means prepare for red, and green means go. In this example people driving cars are the implementation of the spec. </p>\n<p>What happens if both green and red are on? Do you stop, then go? Do you wait until red turns off and it's just green? This is a case that the spec did not describe, and as a result, anything the drivers do is undefined behavior. Some people will do one thing, some another. Since there is no guarantee about what will happen you want to avoid this situation. The same applies to code. </p>\n", "OwnerUserId": "2574189", "PostTypeId": "2", "Id": "32141599", "Score": "2", "CreationDate": "2015-08-21T13:30:30.357", "LastActivityDate": "2015-08-21T13:30:30.357"}, "32148352": {"ParentId": "32132574", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>Undefined behaviors allow compilers to generate faster code in some cases. Consider two different processor architectures that ADD differently:\nProcessor A inherently discards the carry bit upon overflow, while processor B generates an error. (Of course, Processor C inherently generates Nasal Demons - its just the easiest way to discharge that extra bit of energy in a snot-powered nanobot...)</p>\n<p>If the standard required that an error be generated, then all code compiled for processor A would basically be forced to include additional instructions, to perform some sort of check for overflow, and if so, generate an error. This would result in slower code, even if the developer know that they were only going to end up adding small numbers.</p>\n<p>Undefined behavior sacrifices portability for speed. By allowing 'anything' to happen, the compiler can avoid writing safety-checks for situations that will never occur. (Or, you know... they might.)</p>\n<p>Additionally, when a programmer knows exactly what an undefined behavior will actually cause in their given environment, they are free to exploit that knowledge to gain additional performance.</p>\n<p>If you want to ensure that your code behaves exactly the same on all platforms, you need to ensure that no 'undefined behavior' ever occurs - however, this may not be your goal.</p>\n<p><strong>Edit:</strong> (In respons to OPs edit)\nImplementation Defined behavior would require the consistent generation of nasal demons. Undefined behavior allows the sporadic generation of nasal demons.</p>\n<p>That's where the advantage that undefined behavior has over implementation specific behavior appears. Consider that extra code may be needed to avoid inconsistent behavior on a particular system. In these cases, undefined behavior allows greater speed.</p>\n", "OwnerUserId": "1015072", "LastEditorUserId": "1015072", "LastEditDate": "2015-08-21T21:01:39.187", "Id": "32148352", "Score": "1", "CreationDate": "2015-08-21T19:56:21.070", "LastActivityDate": "2015-08-21T21:01:39.187"}, "32133512": {"ParentId": "32132574", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>One of the historical purposes of Undefined Behavior was to allow for the possibility that certain actions may have different <em>potentially-useful</em> effects on different platforms.  For example, in the early days of C, given</p>\n<pre><code>int i=INT_MAX;\ni++;\nprintf(\"%d\",i);\n</code></pre>\n<p>some compilers could guarantee that the code would print some particular value (for a two's-complement machine it would typically be INT_MIN), while others would guarantee that the program would terminate without reaching the printf.  Depending upon the application requirements, either behavior could be useful.  Leaving the behavior undefined meant that an application where abnormal program termination was an acceptable consequence of overflow but producing seemingly-valid-but-wrong output would not be, could forgo overflow checking if run on a platform which would reliably trap it, and an application where abnormal termination in case of overflow would not be acceptable, but producing arithmetically-incorrect output would be, could forgo overflow checking if run on a platform where overflows weren't trapped.</p>\n<p>Recently, however, some compiler authors seem to have gotten into a contest to see who can most efficiently eliminate any code whose existence would not be mandated by the standard.  Given, for example...</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n  int ch = getchar();\n  if (ch &lt; 74)\n    printf(\"Hey there!\");\n  else\n    printf(\"%d\",ch*ch*ch*ch*ch);\n}\n</code></pre>\n<p>a hyper-modern compiler may conclude that if <code>ch</code> is 74 or greater, the computation of <code>ch*ch*ch*ch*ch</code> would yield Undefined Behavior, and as a\nconsequence the program should print \"Hey there!\" unconditionally regardless\nof what character was typed.</p>\n", "OwnerUserId": "363751", "LastEditorUserId": "15168", "LastEditDate": "2015-08-21T12:00:51.480", "Id": "32133512", "Score": "21", "CreationDate": "2015-08-21T06:13:09.270", "LastActivityDate": "2015-08-21T12:00:51.480"}, "32132747": {"ParentId": "32132574", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>Nitpicking</strong>: You have not quoted a standard.</p>\n<blockquote>\n<p id=\"so_32132574_32132747_0\">These are the sources used to generate drafts of the C++ standard. These sources should not be considered an ISO publication, nor should documents generated from them unless officially adopted by the C++ working group (ISO/IEC JTC1/SC22/WG21).</p>\n</blockquote>\n<p><strong>Interpretation</strong>: Notes are not <a href=\"https://stackoverflow.com/questions/21364398/are-notes-and-examples-in-the-core-language-specification-of-the-c-standard-no\">normative</a> according to the ISO/IEC Directives Part 2. </p>\n<blockquote>\n<p id=\"so_32132574_32132747_1\">Notes and examples integrated in the text of a document shall only be used for giving additional information intended to assist the understanding or use of the document. <strong>They shall not contain requirements (\"shall\"; see 3.3.1 and Table H.1) or any information considered indispensable for the use of the document</strong> e.g. instructions (imperative; see Table H.1), recommendations (\"should\"; see 3.3.2 and Table H.2) or permission (\"may\"; see Table H.3). Notes may be written as a statement of fact. </p>\n</blockquote>\n<p>Emphasis mine. This alone rules out \"comprehensive list of options\". Giving examples however does count as \"additional information intended to assist the understanding .. of the document\". </p>\n<p>Do keep in mind that the \"nasal demon\" meme is not meant to be taken literally, just as using a balloon to explain how universe expansion works holds no truth in physical reality. It's to illustrate that it's foolhardy to discuss what \"undefined behavior\" <strong>should</strong> do when it's permissible to do anything. Yes, this means that there isn't an actual rubber band in outer space.</p>\n", "OwnerUserId": "5250294", "LastEditorUserId": "15168", "LastEditDate": "2015-08-21T11:58:14.690", "Id": "32132747", "Score": "14", "CreationDate": "2015-08-21T05:11:58.613", "LastActivityDate": "2015-08-21T11:58:14.690"}, "bq_ids": {"n4140": {"so_32132574_32132574_0": {"section_id": 5768, "quality": 0.9285714285714286, "length": 26}, "so_32132574_32132609_0": {"section_id": 5768, "quality": 0.7142857142857143, "length": 5}, "so_32132574_32141702_0": {"section_id": 5798, "quality": 0.9459459459459459, "length": 35}}, "n3337": {"so_32132574_32132574_0": {"section_id": 5541, "quality": 0.9285714285714286, "length": 26}, "so_32132574_32132609_0": {"section_id": 5541, "quality": 0.7142857142857143, "length": 5}, "so_32132574_32141702_0": {"section_id": 5571, "quality": 0.9459459459459459, "length": 35}}, "n4659": {"so_32132574_32132574_0": {"section_id": 7225, "quality": 0.9285714285714286, "length": 26}, "so_32132574_32132609_0": {"section_id": 7225, "quality": 0.7142857142857143, "length": 5}, "so_32132574_32141702_0": {"section_id": 7257, "quality": 0.9459459459459459, "length": 35}}}, "32132609": {"ParentId": "32132574", "CommentCount": "28", "Body": "<p>Yes, it permits anything to happen. The note is just giving examples. The definition is pretty clear:</p>\n<blockquote>\n<p id=\"so_32132574_32132609_0\">Undefined behavior: behavior for which this International Standard imposes no requirements.</p>\n</blockquote>\n", "OwnerUserId": "541686", "PostTypeId": "2", "Id": "32132609", "Score": "72", "CreationDate": "2015-08-21T04:56:57.650", "LastActivityDate": "2015-08-21T04:56:57.650"}, "32132690": {"ParentId": "32132574", "CommentCount": "9", "Body": "<p>The definition of undefined behaviour, in every C and C++ standard, is essentially that the standard imposes no requirements on what happens.</p>\n<p>Yes, that means any outcome is permitted.   But there are no particular outcomes that are <em>required</em> to happen, nor any outcomes that are <em>required</em> to NOT happen.    It does not matter if you have a compiler and library that consistently yields a particular behaviour in response to a particular instance of undefined behaviour - such a behaviour is not required, and may change even in a future bugfix release of your compiler - and the compiler will still be perfectly correct according to each version of the C and C++ standards.</p>\n<p>If your host system has hardware support in the form of connection to probes that are inserted in your nostrils, it is within the realms of possibility that an occurrence of undefined behaviour will cause undesired nasal effects.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "32132690", "Score": "9", "CreationDate": "2015-08-21T05:06:01.887", "LastActivityDate": "2015-08-21T05:06:01.887"}, "32132574": {"CommentCount": "40", "AcceptedAnswerId": "32132609", "PostTypeId": "1", "ClosedDate": "2015-08-22T14:37:34.353", "LastEditorUserId": "1858225", "CreationDate": "2015-08-21T04:53:14.900", "LastActivityDate": "2015-12-22T20:02:27.747", "LastEditDate": "2015-12-22T20:02:27.747", "ViewCount": "5322", "FavoriteCount": "9", "Title": "Does \"Undefined Behavior\" really permit *anything* to happen?", "Id": "32132574", "Score": "85", "Body": "<p>EDIT: This question was not intended as a forum for discussion about the (de)merits of undefined behavior, but that's sort of what it became. In any case, <a href=\"https://groups.google.com/forum/m/#!msg/boring-crypto/48qa1kWignU/o8GGp2K1DAAJ\" rel=\"noreferrer\">this thread about a hypothetical C-compiler with no undefined behavior</a> may be of additional interest to those who think this is an important topic.</p>\n<hr>\n<p>The classic apocryphal example of \"undefined behavior\" is, of course, \"nasal demons\" \u2014 a physical impossibility, regardless of what the C and C++ standards permit.</p>\n<p>Because the C and C++ communities tend to put such an emphasis on the unpredictability of undefined behavior and the idea that the compiler is allowed to cause the program to do literally <em>anything</em> when undefined behavior is encountered, I had assumed that the standard puts no restrictions whatsoever on the behavior of, well, undefined behavior.</p>\n<p>But the <a href=\"https://github.com/cplusplus/draft/blob/dd95ad99c2d548f40ddabdb47a59c0c77056c072/source/intro.tex\" rel=\"noreferrer\">relevant quote in the C++ standard seems to be</a>:</p>\n<blockquote>\n<p id=\"so_32132574_32132574_0\"><code>[C++14: defns.undefined]:</code> <em>[..]</em> Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). <em>[..]</em></p>\n</blockquote>\n<p>This actually specifies a small set of possible options:</p>\n<ul>\n<li><strong>Ignoring the situation</strong> -- Yes, the standard goes on to say that this will have \"unpredictable results\", but that's not the same as the compiler <em>inserting</em> code (which I assume would be a prerequisite for, you know, nasal demons).</li>\n<li><strong>Behaving in a documented manner characteristic of the environment</strong> -- this actually sounds relatively benign. (I certainly haven't heard of any documented cases of nasal demons.)</li>\n<li><strong>Terminating translation or execution</strong> -- with a diagnostic, no less. Would that all UB would behave so nicely.</li>\n</ul>\n<p>I assume that in most cases, compilers choose to ignore the undefined behavior; for example, when reading uninitialized memory, it would presumably be an anti-optimization to insert any code to ensure consistent behavior. I suppose that the stranger types of undefined behavior (such as \"<a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2014/06/27/10537746.aspx\" rel=\"noreferrer\">time travel</a>\") would fall under the second category--but this requires that such behaviors be documented and \"characteristic of the environment\" (so I guess nasal demons are only produced by infernal computers?).</p>\n<p>Am I misunderstanding the definition? Are these intended as mere <em>examples</em> of what could constitute undefined behavior, rather than a comprehensive list of options? Is the claim that \"anything can happen\" meant merely as an unexpected side-effect of ignoring the situation?</p>\n<p><strong>EDIT:</strong> Two minor points of clarification:</p>\n<ul>\n<li>I thought it was clear from the original question, and I think to most people it was, but I'll spell it out anyway: I do realize that \"nasal demons\" is tongue-in-cheek.</li>\n<li>Please do not write an(other) answer explaining that UB allows for platform-specific compiler optimizations, unless you <em>also</em> explain how it allows for optimizations that <em>implementation-defined</em> behavior <em>wouldn't</em> allow.</li>\n</ul>\n</hr>", "Tags": "<c++><c><language-lawyer><undefined-behavior>", "OwnerUserId": "1858225", "AnswerCount": "9"}, "32148933": {"ParentId": "32132574", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>One of the reasons for leaving behavior undefined is to allow the compiler to make whatever assumptions it wants when optimizing.</p>\n<p>If there exists some condition that must hold if an optimization is to be applied, and that condition is dependent on undefined behavior in the code, then the compiler may assume that it's met, since a conforming program can't depend on undefined behavior in any way.  Importantly, the compiler does not need to be consistent in these assumptions.  (which is <em>not</em> the case for implementation-defined behavior)</p>\n<p>So suppose your code contains an admittedly contrived example like the one below:</p>\n<pre><code>int bar = 0;\nint foo = (undefined behavior of some kind);\nif (foo) {\n   f();\n   bar = 1;\n}\nif (!foo) {\n   g();\n   bar = 1;\n}\nassert(1 == bar);\n</code></pre>\n<p>The compiler is free to assume that !foo is true in the first block and foo is true in the second, and thus optimize the entire chunk of code away.  Now, logically either foo or !foo must be true, and so looking at the code, you would reasonably be able to assume that bar must equal 1 once you've run the code.  But because the compiler optimized in that manner, bar never gets set to 1.  And now that assertion becomes false and the program terminates, which is behavior that would not have happened if foo hadn't relied on undefined behavior.</p>\n<p>Now, is it possible for the compiler to actually insert completely new code if it sees undefined behavior?  If doing so will allow it to optimize more, absolutely.  Is it likely to happen often?  Probably not, but you can never guarantee it, so operating on the assumption that nasal demons are possible is the only safe approach.</p>\n", "OwnerUserId": "5196093", "LastEditorUserId": "5196093", "LastEditDate": "2015-08-21T21:11:33.710", "Id": "32148933", "Score": "3", "CreationDate": "2015-08-21T20:40:19.863", "LastActivityDate": "2015-08-21T21:11:33.710"}, "32141702": {"ParentId": "32132574", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>First, it is important to note that it is not only the behaviour of the user program that is undefined, it is <strong>the behaviour of the compiler</strong> that <strong>is undefined</strong>. Similarly, UB is not encountered at runtime, it is a property of the source code.</p>\n<p>To a compiler writer, \"the behaviour is undefined\" means, \"you do not have to take this situation into account\", or even \"you can assume no source code will ever produce this situation\".\nA compiler can do anything, intentionally or unintentionally, when presented with UB, and still be standard compliant, so yes, if you granted access to your nose...</p>\n<p>Then, it is not always possible to know if a program has UB or not.\nExample:</p>\n<pre><code>int * ptr = calculateAddress();\nint i = *ptr;\n</code></pre>\n<p>Knowing if this can ever be UB or not would require knowing all possible values returned by <code>calculateAddress()</code>, which is impossible in the general case (See \"<a href=\"https://en.wikipedia.org/wiki/Halting_problem\" rel=\"nofollow\">Halting Problem</a>\"). A compiler has two choices:</p>\n<ul>\n<li>assume <code>ptr</code> will always have a valid address</li>\n<li>insert runtime checks to guarantee a certain behaviour</li>\n</ul>\n<p>The first option produces fast programs, and puts the burden of avoiding undesired effects on the programmer, while the second option produces safer but slower code.</p>\n<p>The C and C++ standards leave this choice open, and most compilers choose the first, while Java for example mandates the second.</p>\n<hr>\n<p><strong><em>Why is the behaviour not implementation-defined, but undefined?</em></strong> </p>\n<p><strong>Implementation-defined</strong> means (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">N4296</a>, 1.9\u00a72):</p>\n<blockquote>\n<p id=\"so_32132574_32141702_0\">Certain aspects and operations of the abstract machine are described in this International Standard as\n  implementation-defined (for example,\n  sizeof(int)\n  ). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these\n  respects.\n  Such <strong>documentation shall define the instance of the abstract machine that corresponds to that\n  implementation</strong> (referred to as the \u201ccorresponding instance\u201d below).</p>\n</blockquote>\n<p>Emphasis mine. In other words: A compiler-writer has to document <em>exactly</em> how the machine-code behaves, when the source code uses implementation-defined features.</p>\n<p>Writing to a random non-null invalid pointer is one of the most unpredictable things you can do in a program, so this would require performance-reducing runtime-checks too.<br>\nBefore we had MMUs, you could <a href=\"https://en.wikipedia.org/wiki/Killer_poke\" rel=\"nofollow\"><strong>destroy hardware</strong></a> by writing to the wrong address, which comes <em>very</em> close to nasal demons ;-)</br></p>\n</hr>", "OwnerUserId": "3435400", "LastEditorUserId": "3435400", "LastEditDate": "2015-08-22T15:54:30.707", "Id": "32141702", "Score": "5", "CreationDate": "2015-08-21T13:34:58.397", "LastActivityDate": "2015-08-22T15:54:30.707"}, "32137520": {"ParentId": "32132574", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>I thought I'd answer just one of your points, since the other answers answer the general question quite well, but have left this unaddressed.</p>\n<p>\"Ignoring the situation -- Yes, the standard goes on to say that this will have \"unpredictable results\", but that's not the same as the compiler inserting code (which I assume would be a prerequisite for, you know, nasal demons).\"</p>\n<p>A situation in which nasal demons could very reasonably be expected to occur with a sensible compiler, without the compiler inserting ANY code, would be the following:</p>\n<pre><code>if(!spawn_of_satan)\n    printf(\"Random debug value: %i\\n\", *x); // oops, null pointer deference\n    nasal_angels();\nelse\n    nasal_demons();\n</code></pre>\n<p>A compiler, if it can prove that that *x is a null pointer dereference, is perfectly entitled, as part of some optimisation, to say \"OK, so I see that they've dereferenced a null pointer in this branch of the if. Therefore, as part of that branch I'm allowed to do anything. So I can therefore optimise to this:\"</p>\n<pre><code>if(!spawn_of_satan)\n    nasal_demons();\nelse\n    nasal_demons();\n</code></pre>\n<p>\"And from there, I can optimise to this:\"</p>\n<pre><code>nasal_demons();\n</code></pre>\n<p>You can see how this sort of thing can in the right circumstances prove very useful for an optimising compiler, and yet cause disaster. I did see some examples a while back of cases where actually it IS important for optimisation to be able to optimise this sort of case. I might try to dig them out later when I have more time.</p>\n<p>EDIT: One example that just came from the depths of my memory of such a case where it's useful for optimisation is where you very frequently check a pointer for being NULL (perhaps in inlined helper functions), even after having already dereferenced it and without having changed it. The optimising compiler can see that you've dereferenced it and so optimise out all the \"is NULL\" checks, since if you've dereferenced it and it IS null, anything is allowed to happen, including just not running the \"is NULL\" checks. I believe that similar arguments apply to other undefined behaviour.</p>\n", "OwnerUserId": "1953158", "LastEditorUserId": "1953158", "LastEditDate": "2015-08-21T11:34:37.673", "Id": "32137520", "Score": "6", "CreationDate": "2015-08-21T09:56:38.507", "LastActivityDate": "2015-08-21T11:34:37.673"}});