post_cb({"9975672": {"CommentCount": "0", "AcceptedAnswerId": "9976054", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-04-02T11:35:23.453", "LastActivityDate": "2012-04-04T13:21:49.277", "LastEditDate": "2017-05-23T12:25:33.503", "ViewCount": "12614", "FavoriteCount": "8", "Title": "c++ automatic factory registration of derived types", "Id": "9975672", "Score": "13", "Body": "<p>Like many before me, I'm trying so get my derived types to automatically register with my factory. I read through many question and tried to focus on what I didn't find there.</p>\n<p>I've got everything running nicely except the automatic registration.</p>\n<p><strong>My Goals:</strong></p>\n<ol>\n<li>automatically register any derived class of my base class <strong>Base</strong>\n<ol>\n<li>only classes I mark as <em>registrable</em></li>\n<li>not only direct sub-classes of <strong>Base</strong>\n<ul>\n<li><strong>ex:</strong> Base -&gt; Device -&gt; Camera -&gt; <strong>Webcam</strong></li>\n<li>this would make using the <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow noreferrer\">CRTP</a> like described in <a href=\"https://stackoverflow.com/questions/6399804/automatic-static-invocation-of-derived-types\">this question</a> dificult</li>\n</ul></li>\n</ol></li>\n<li>minimal changes to the classes I want registered - <em>dummies proof</em></li>\n<li>would prefer using a <strong>registrator class</strong> than macros\n\n<ul>\n<li>like in <a href=\"https://stackoverflow.com/questions/6399804/automatic-static-invocation-of-derived-types\">this question</a>, but I'm not sure if this is dependent on <a href=\"http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow noreferrer\">CRTP</a></li>\n</ul></li>\n</ol>\n<p><strong>What I have:</strong></p>\n<pre><code>template &lt;class T&gt;\nclass abstract_factory\n{\n    public:\n        template &lt; typename Tsub &gt; static void register_class();\n        static T* create( const std::string&amp; name );\n    private:\n        // allocator&lt;T&gt; is a helper class to create a pointer of correct type\n        static std::map&lt;std::string, boost::shared_ptr&lt;allocator&lt;T&gt; &gt; &gt; s_map;\n};\n</code></pre>\n<ul>\n<li>templated abstract factory, with <strong>std::string</strong> as <em>key type</em></li>\n<li>abstract factory has all members and methods <strong>static</strong></li>\n<li>class name is recovered automatically with <strong>typeid</strong> (no need for text name when registering)</li>\n<li>registration by calling: <code>abstract_factory&lt;Base&gt;::register_class&lt;MyDerived&gt;();</code></li>\n</ul>\n<p><strong>What I tried (or would like to but don't know how to properly):</strong></p>\n<ul>\n<li><code>registrator&lt;Derived&gt; class</code>: templateded class that is instantiated statically in <code>Derived.cpp</code> and should call <code>abstract_factory::register_class&lt;Derived&gt;()</code> in it's constructor\n\n<ul>\n<li>never gets called or instantiated</li>\n<li>if I make an instance of <code>Derived</code> in <code>main()</code> this works -&gt; kinda defeats the purpose though </li>\n</ul></li>\n<li>declare a simple static variable in each <code>Derived.hpp</code> and set it with the static registration method in <code>Derived.cpp</code> -&gt; again, never gets called.</li>\n<li>make <code>abstract_factory</code> a true singleton instead of having everything static?</li>\n</ul>\n<p>Could use any advice, large or small, thanx.</p>\n", "Tags": "<c++><templates><static-methods><factory-pattern>", "OwnerUserId": "613391", "AnswerCount": "2"}, "9976188": {"ParentId": "9975672", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>--- registration.h ---</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct registrar {\n        struct proxy { inline proxy();};\n        static proxy p;\n};\n\ntemplate&lt;class T&gt; typename registrar&lt;T&gt;::proxy registrar&lt;T&gt;::p;\n\n\n\nstruct factory {\n        template &lt;typename T&gt; static T* create() {\n               registrar&lt;T&gt;::p;\n               return new T();\n        }\n};\n\nset&lt;string&gt; &amp; types();\n\ntemplate&lt;typename T&gt;\nregistrar&lt;T&gt;::proxy::proxy() { types().insert(typeid(T).name());}\n</code></pre>\n<p>--- registration.cpp ---</p>\n<pre><code>#include \"registration.h\"\n#include &lt;boost/foreach.hpp&gt;\n\nset&lt;string&gt; &amp; types() {static set&lt;string&gt; types; return types;} \n\nint main() {\n    BOOST_FOREACH(const string &amp; s, types()) { cout&lt;&lt;s&lt;&lt;\"\\n\";}\n        factory::create&lt;int&gt;();\n    factory::create&lt;double&gt;();\n    factory::create&lt;bool&gt;();\n        return 0;\n}\n</code></pre>\n<p>--- registration_ext.cpp ---</p>\n<pre><code>#include \"registration.h\"\n\nclass myclass {};\n\nvoid phony() {\n    factory::create&lt;double&gt;();\n    factory::create&lt;myclass&gt;();\n}\n</code></pre>\n<p>Then compiled with:</p>\n<pre><code>$ g++ registration.cpp registration_ext.cpp -o registration\n</code></pre>\n<p>When run:</p>\n<pre><code>$ ./registration \n7myclass\nb\nd\ni\n</code></pre>\n<p>So, it seems to have registered the classes before main is called.</p>\n<p>Edit:\nI've noticed that this solution is implementation dependent. Under 3.6.2 the C++ standard says:</p>\n<blockquote>\n<p id=\"so_9975672_9976188_0\">It is implementation-defined whether the dynamic initialization of a\n  non-local variable with static storage duration is done before the\n  first statement of main. If the initialization is deferred to some\n  point in time after the first statement of main, it shall occur before\n  the first odr-use (3.2) of any function or variable defined in the\n  same translation unit as the variable to be initialized.</p>\n</blockquote>\n", "OwnerUserId": "1103705", "LastEditorUserId": "1103705", "LastEditDate": "2012-04-04T13:21:49.277", "Id": "9976188", "Score": "4", "CreationDate": "2012-04-02T12:12:17.177", "LastActivityDate": "2012-04-04T13:21:49.277"}, "9976054": {"ParentId": "9975672", "CommentCount": "4", "Body": "<p>I use a singleton with a member for registration, basically:</p>\n<pre><code>template&lt; typename KeyType, typename ProductCreatorType &gt;\nclass Factory\n{\n    typedef boost::unordered_map&lt; KeyType, ProductCreatorType &gt; CreatorMap;\n    ...\n};\n</code></pre>\n<p>Using Loki I then have something along these lines:</p>\n<pre><code> typedef Loki::SingletonHolder&lt; Factory&lt; StringHash, boost::function&lt; boost::shared_ptr&lt; SomeBase &gt;( const SomeSource&amp; ) &gt; &gt;, Loki::CreateStatic &gt; SomeFactory;\n</code></pre>\n<p>Registration is usually done using a macro such as: </p>\n<pre><code>#define REGISTER_SOME_FACTORY( type ) static bool BOOST_PP_CAT( type, __regged ) = SomeFactory::Instance().RegisterCreator( BOOST_PP_STRINGIZE( type ), boost::bind( &amp;boost::make_shared&lt; type &gt;, _1 ) );\n</code></pre>\n<p>This setup has a number of advantages:</p>\n<ul>\n<li>Works with for example boost::shared_ptr&lt;&gt;.</li>\n<li>Does not require maintaining a huge file for all the registration needs.</li>\n<li>Is very flexible with the creator, anything goes pretty much.</li>\n<li>The macro covers the most common use case, while leaving the door open for alternatives.</li>\n</ul>\n<p>Invoking the macro in the .cpp file is then enough to get the type registered at start up during static initialization. This works dandy save for when the type registration is a part of a static library, in which case it won't be included in your binary. The only solutions which compiles the registration as a part of the library which I've seen work is to have one huge file that does the registration explicitly as a part of some sort of initialization routine. Instead what I do nowadays is to have a client folder with my lib which the user includes as a part of the binary build.</p>\n<p>From your list of requirements I believe this satisfies everything save for using a registrator class.</p>\n", "OwnerUserId": "135326", "PostTypeId": "2", "Id": "9976054", "Score": "9", "CreationDate": "2012-04-02T12:03:28.710", "LastActivityDate": "2012-04-02T12:03:28.710"}, "bq_ids": {"n4140": {"so_9975672_9976188_0": {"section_id": 7153, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_9975672_9976188_0": {"section_id": 6897, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_9975672_9976188_0": {"section_id": 8657, "quality": 0.6571428571428571, "length": 23}}}});