post_cb({"bq_ids": {"n4140": {"so_26805502_26805636_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5808}, "so_26805502_26805636_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 3850}}, "n3337": {"so_26805502_26805636_1": {"length": 20, "quality": 0.8695652173913043, "section_id": 5581}, "so_26805502_26805636_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 3711}}, "n4659": {"so_26805502_26805636_1": {"length": 19, "quality": 0.8260869565217391, "section_id": 7269}, "so_26805502_26805636_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 4619}}}, "26805636": {"Id": "26805636", "PostTypeId": "2", "Body": "<p>As far as your guarantees go..</p>\n<p>C++03 [lib.accumulate]:</p>\n<blockquote>\n<p id=\"so_26805502_26805636_0\">Requires: T must meet the requirements of CopyConstructible (20.1.3) and Assignable (23.1) types. <code>binary_op</code> shall not cause side effects.</p>\n</blockquote>\n<p>So the function must not have any 'side effects'. Which is defined as follows:</p>\n<p>C++03 [intro.execution]:</p>\n<blockquote>\n<p id=\"so_26805502_26805636_1\">Accessing an object designated by a volatile lvalue (3.10), <strong>modifying an object</strong>, calling a library I/O function, or calling a function that does any of those operations are all side effects, which are changes in the state of the execution environment.</p>\n</blockquote>\n<p>emphasis mine.</p>\n<p>Note that in C++11 the wording changes slightly (\u00a7 26.7.2):</p>\n<blockquote>\n<p id=\"so_26805502_26805636_2\">Requires: T shall meet the requirements of CopyConstructible (Table 21) and CopyAssignable (Table 23) types. In the range [first,last], <code>binary_op</code> shall neither modify elements nor invalidate iterators or subranges.</p>\n</blockquote>\n<p>However, you could make a tag type that kind of works with whatever you throw at it and is a null operation..</p>\n<pre><code>struct tag {\n    template&lt;typename T&gt;\n    tag&amp; operator=(const T&amp;) { return *this; } // not explicitly necessary\n};\n</code></pre>\n<p>Then you make a functor that accepts that tag type on its left hand side and a closure to maintain the result.</p>\n<pre><code>struct accumulator {\n    int&amp; x;\n    accumulator(int&amp; x): x(x) {}\n    tag operator()(tag t, int y) {\n        x += y;\n        return t;\n    }\n};\n</code></pre>\n<p>then use it as normal..</p>\n<pre><code>std::accumulate(v.begin(), v.end(), tag(), accumulator(x));\n</code></pre>\n<p>and it should work. Though I think at this point <code>std::for_each</code> is a better alternative or maybe the <code>BOOST_FOREACH</code> macro.</p>\n<p>You could also write your own algorithm which would be less boilerplate-y:</p>\n<pre><code>template&lt;typename It, typename T, typename Op&gt;\nT inplace_accumulate(It begin, It end, T init, Op op) {\n    for(; begin != end; ++begin) {\n        op(init, *begin);\n    }\n    return init;\n}\n</code></pre>\n<p>Then you just feed it the regular accumulator with this signature:</p>\n<pre><code>struct accumulator {\n    template&lt;typename T&gt;\n    void operator()(T&amp; x, const T&amp; y) const {\n        x += y;\n    }\n};\n\n// somewhere else\nint x = inplace_accumulate(v.begin(), v.end(), 10, accumulator());\n</code></pre>\n", "LastEditorUserId": "1381108", "LastActivityDate": "2014-11-07T16:51:58.810", "Score": "1", "CreationDate": "2014-11-07T16:24:03.203", "ParentId": "26805502", "CommentCount": "2", "OwnerUserId": "1381108", "LastEditDate": "2014-11-07T16:51:58.810"}, "26805502": {"ViewCount": "180", "Body": "<p>There are cases where</p>\n<pre><code>x += y;\n</code></pre>\n<p>is a lot more efficient than</p>\n<pre><code>x = x + y;\n</code></pre>\n<p>(assuming <code>x</code> and <code>y</code> are of some class type with complex overloaded operators). Now of course I could do a fold with</p>\n<pre><code>X x;\nBOOST_FOREACH(Y const &amp;y, collection)\n    x += y;\n</code></pre>\n<p>(I am stuck on platform with old compiler) but I somehow prefer <code>std::accumulate</code>. Is it possible to make it (or other algorithm, but not for_each) to use <code>+=</code> instead?</p>\n<p>The <code>std::accumulate</code> is supposed to call the operator like</p>\n<pre><code>sum = op(sum, *iter);\n</code></pre>\n<p>but can one rely on it, that is, will</p>\n<pre><code>X x(std::accumulate(collection.begin(),\n                    collection.end(),\n                    X(),\n                    std::mem_fun_ref(&amp;X::operator+=)));\n</code></pre>\n<p>work?</p>\n", "AcceptedAnswerId": "26805636", "Title": "Using mutating function in std::accumulate", "CreationDate": "2014-11-07T16:16:32.037", "Id": "26805502", "CommentCount": "5", "LastEditDate": "2014-11-07T16:47:50.217", "PostTypeId": "1", "LastEditorUserId": "201725", "LastActivityDate": "2014-11-07T16:51:58.810", "Score": "-1", "OwnerUserId": "201725", "Tags": "<c++><language-lawyer><c++03><c++-standard-library>", "AnswerCount": "2"}, "26805694": {"Id": "26805694", "PostTypeId": "2", "Body": "<p>Yes you can rely on it.</p>\n<p>You could write your own really <em>ugly</em> operator, ignore the sum, and hope that the compiler will optimize the junk you've created.</p>\n<p>Please don't. I doubt anybody would like to read that code.</p>\n<p>Why don't you roll your own algorithm?</p>\n<pre><code>template&lt;class InputIt, class T&gt;\nT accumulate_fast(InputIt first, InputIt last, T init)\n{\n    for (; first != last; ++first) {\n        init += *first;\n    }\n    return init;\n}\n</code></pre>\n<p>This is generic and doesn't need a separate custom binary operator for each type.</p>\n", "LastActivityDate": "2014-11-07T16:27:37.737", "CommentCount": "6", "CreationDate": "2014-11-07T16:27:37.737", "ParentId": "26805502", "Score": "1", "OwnerUserId": "650405"}});