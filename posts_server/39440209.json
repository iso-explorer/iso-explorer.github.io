post_cb({"39441589": {"ParentId": "39440209", "CommentCount": "0", "Body": "<p>The first snippet is correct in C++17, but not in C++14 and 11. </p>\n<p>For C++14, [temp.arg.nontype]/1 says:</p>\n<blockquote>\n<p id=\"so_39440209_39441589_0\">A <em>template-argument</em> for a non-type, non-template\n  <em>template-parameter</em> shall be one of: </p>\n<p id=\"so_39440209_39441589_1\">[...]</p>\n<ul>\n<li>a constant expression (5.19) that designates the address of a complete object with static storage duration and external or internal\n  linkage or a function with external or internal linkage, including\n  function templates and function <em>template-ids</em> but excluding\n  non-static class members, expressed (ignoring parentheses) as <code>&amp;</code>\n<em>id-expression</em>, where the <em>id-expression</em> is the name of an object or function, except that the <code>&amp;</code> may be omitted if the name refers to a\n  function or array and shall be omitted if the corresponding\n  <em>template-parameter</em> is a reference; or </li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or </li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or </li>\n<li>a pointer to member expressed as described in 5.3.1; or </li>\n<li>a constant expression of type <code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n<p>(I've included only the bullets that are directly relevant to pointers and pointers to members.)</p>\n<p>Basically, the address of the function in your sample has to be expressed strictly as <code>&amp;fn</code> or <code>fn</code>.</p>\n<p>C++11 contains essentially the same wording minus a couple of clarifications introduced by defect reports between 11 and 14:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1570\" rel=\"noreferrer\">DR1570</a> clarified the bit about complete objects;</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1398\" rel=\"noreferrer\">DR1398</a> amended by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1666\" rel=\"noreferrer\">DR1666</a> added the last bullet.</li>\n</ul>\n<p>For C++17, the restrictions have been relaxed as a result of the adoption of paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html\" rel=\"noreferrer\">N4268</a> (rationale in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html\" rel=\"noreferrer\">N4198</a>). The corresponding paragraph (2) now says:</p>\n<blockquote>\n<p id=\"so_39440209_39441589_2\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a\n  converted constant expression (5.20) of the type of the\n  <em>template-parameter</em>. For a non-type <em>template-parameter</em> of reference or\n  pointer type, the value of the constant expression shall not refer to\n  (or for a pointer type, shall not be the address of):</p>\n<ul>\n<li>a subobject (1.8),</li>\n<li>a temporary object (12.2),</li>\n<li>a string literal (2.13.5),</li>\n<li>the result of a <code>typeid</code> expression (5.2.8), or</li>\n<li>a predefined <code>__func__</code> variable (8.4.1).</li>\n</ul>\n<p id=\"so_39440209_39441589_3\">[ <em>Note:</em> If the <em>template-argument</em> represents a set of overloaded\n  functions (or a pointer or member pointer to such), the matching\n  function is selected from the set (13.4). <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4198.html\" rel=\"noreferrer\">N4198</a> contains good explanations for each of those bullets.</p>\n", "OwnerUserId": "4326278", "PostTypeId": "2", "Id": "39441589", "Score": "6", "CreationDate": "2016-09-11T23:22:51.130", "LastActivityDate": "2016-09-11T23:22:51.130"}, "39440209": {"CommentCount": "7", "ViewCount": "636", "CreationDate": "2016-09-11T20:12:45.480", "LastActivityDate": "2016-09-11T23:22:51.130", "Title": "can a static constexpr variable be used as a template argument", "AcceptedAnswerId": "39441589", "PostTypeId": "1", "Id": "39440209", "Score": "12", "Body": "<p>I have the following piece of code which compiles on older gcc, but not on version 6 (works with -std=c++1z). Clang rejects it too, saying the object val doesn't have the right kind of linkage. I don't understand the difference. Isn't a constexpr variable of a pointer type supposed to work more or less transparently? Is there something I'm missing in the syntax that would allow this to work? Or is this violating some portion of the standard?</p>\n<pre><code>typedef void(*t_voidfn)();\ntemplate &lt;t_voidfn&gt; struct s {};\nvoid fn() {\n  static constexpr t_voidfn val = &amp;fn;\n  s&lt;val&gt; x;\n}\n</code></pre>\n<p>On the other hand this one works.</p>\n<pre><code>typedef void(*t_voidfn)();\ntemplate &lt;t_voidfn&gt; struct s {};\nvoid fn() {\n  s&lt;&amp;fn&gt; x;\n}\n</code></pre>\n", "Tags": "<c++><templates><constexpr>", "OwnerUserId": "2306145", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39440209_39441589_2": {"section_id": 87, "quality": 0.5909090909090909, "length": 13}, "so_39440209_39441589_3": {"section_id": 91, "quality": 0.6470588235294118, "length": 11}, "so_39440209_39441589_0": {"section_id": 87, "quality": 1.0, "length": 5}}, "n3337": {"so_39440209_39441589_2": {"section_id": 82, "quality": 0.7272727272727273, "length": 16}, "so_39440209_39441589_3": {"section_id": 86, "quality": 0.6470588235294118, "length": 11}, "so_39440209_39441589_0": {"section_id": 82, "quality": 1.0, "length": 5}}, "n4659": {"so_39440209_39441589_2": {"section_id": 90, "quality": 0.9090909090909091, "length": 20}, "so_39440209_39441589_3": {"section_id": 90, "quality": 0.7647058823529411, "length": 13}}}});