post_cb({"27953906": {"ParentId": "27953336", "CommentCount": "0", "Body": "<p>The way that <code>function</code> is constructed from any functor <code>F f</code> is stipulated by the standard in \u00a720.9.11.2.1 as (assuming <code>f</code> is a non-null, emphasis mine):</p>\n<blockquote>\n<p id=\"so_27953336_27953906_0\"><code>*this</code> targets a <strong>copy</strong> of <code>f</code> initialized with <strong><code>std::move(f)</code></strong></p>\n</blockquote>\n<p>So there is no way to in-place construct a <code>function</code>. That leaves you with a choice between incurring that move:</p>\n<pre><code>function&lt;void()&gt; f1 = C{};\n</code></pre>\n<p>Or passing in some wrapper around <code>C</code> that is cheaper to move/copy, either one in which you manage externally:</p>\n<pre><code>C manage_me;\nfunction&lt;void()&gt; f2 = std::ref(manage_me);\n</code></pre>\n<p>... or an allocated one bound to <code>operator()</code>:</p>\n<pre><code>function&lt;void()&gt; f3 = std::bind(&amp;C::operator(), std::make_shared&lt;C&gt;());\n</code></pre>\n<p>That last one could cause some headaches if <code>operator()</code> happens to be overloaded, as you'd have to cast it to the right type, which is an issue that none of the previous versions have to deal with.</p>\n<pre><code>function&lt;void()&gt; f4 = std::bind(\n                          static_cast&lt;void(C::*)()&gt;(&amp;C::operator()),\n                          std::make_shared&lt;C&gt;()\n                          );\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "27953906", "Score": "5", "CreationDate": "2015-01-14T22:49:36.103", "LastActivityDate": "2015-01-14T22:49:36.103"}, "27953503": {"ParentId": "27953336", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You can use <code>std::bind</code> but you do not really need to implement <code>operator()</code> for that:</p>\n<pre><code>int main(int argc, char *argv[]) {\n    C c;\n    function&lt;void()&gt; f = std::bind( &amp;C::operator(), &amp;c );\n    f();\n    return 0;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>CREATING\nCALLING\nDELETING\n</code></pre>\n<p>of course you need to properly maintain lifetime of object c in this case.\nTo make <code>std::function</code> to own <code>C</code> instance and make it more in-place construction <code>std::shared_ptr</code> can be used:</p>\n<pre><code>int main(int argc, char *argv[]) {\n    function&lt;void()&gt; f = std::bind( &amp;C::operator(), std::make_shared&lt;C&gt;() );\n    f();\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "432358", "LastEditorUserId": "432358", "LastEditDate": "2015-01-14T22:25:49.210", "Id": "27953503", "Score": "4", "CreationDate": "2015-01-14T22:18:42.227", "LastActivityDate": "2015-01-14T22:25:49.210"}, "27953336": {"CommentCount": "0", "ViewCount": "322", "PostTypeId": "1", "LastEditorUserId": "2642204", "CreationDate": "2015-01-14T22:06:29.943", "LastActivityDate": "2015-01-14T22:49:36.103", "Title": "Constructing std::function target in-place", "AcceptedAnswerId": "27953906", "LastEditDate": "2015-01-14T22:13:00.797", "Id": "27953336", "Score": "5", "Body": "<p>What I understand as a typical use of <code>std::function</code></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n\nusing namespace std;\n\nclass C {\npublic: \n    C() { cout &lt;&lt; \"CREATING\" &lt;&lt; endl; }\n    C(const C&amp;) { cout &lt;&lt; \"COPY C \"&lt;&lt; endl; };\n    C(C&amp;&amp;) { cout &lt;&lt; \"MOVE C \" &lt;&lt; endl; };\n    ~C() { cout &lt;&lt; \"DELETING\"&lt;&lt; endl; }\n    C&amp; operator =(const C&amp;) {\n        cout &lt;&lt; \"COPY A \" &lt;&lt; endl; return *this;\n    };\n    C&amp; operator =(C&amp;&amp;) {\n        cout &lt;&lt; \"MOVE A\" &lt;&lt; endl; return *this;\n    };\n    void operator ()() const { cout &lt;&lt; \"CALLING\" &lt;&lt; endl; }\n};\n\nint main(int argc, char *argv[]) {\n    function&lt;void()&gt; f = C();\n    f();\n    return 0;\n}\n</code></pre>\n<p>yields following output</p>\n<pre><code>CREATING\nMOVE C\nDELETING\nCALLING\nDELETING\n</code></pre>\n<p>Apparently, temporary object is created on stack and then moved into function object. If move constructor is not provided, it is copied instead.<br>\nIs there a standard way of setting the target without need for a temporary object?</br></p>\n", "Tags": "<c++><c++11><std-function>", "OwnerUserId": "2551720", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27953336_27953906_0": {"section_id": 4662, "quality": 1.0, "length": 4}}, "n3337": {"so_27953336_27953906_0": {"section_id": 4472, "quality": 1.0, "length": 4}}, "n4659": {"so_27953336_27953906_0": {"section_id": 6032, "quality": 1.0, "length": 4}}}});