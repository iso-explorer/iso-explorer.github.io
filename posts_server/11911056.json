post_cb({"11911056": {"CommentCount": "11", "AcceptedAnswerId": "11911111", "PostTypeId": "1", "LastEditorUserId": "19404", "CreationDate": "2012-08-11T01:12:36.367", "LastActivityDate": "2012-08-11T03:50:07.897", "LastEditDate": "2012-08-11T03:50:07.897", "ViewCount": "266", "FavoriteCount": "1", "Title": "What should happen when the return value from a C++ function that returns a reference of an undefined object type is not assigned?", "Id": "11911056", "Score": "5", "Body": "<p>Consider the following code:</p>\n<pre><code>class Foo;\n\nFoo&amp; CreateFoo();\n\n\nvoid Bar()\n{\n   CreateFoo();\n}\n</code></pre>\n<p>In Visual Studio this will result in an error C2027 that Foo is an undefined type. In most other compilers it compiles fine. It is only an issue if the return value of CreateFoo is not assigned. If I change the line to:</p>\n<pre><code>Foo&amp; foo = CreateFoo();\n</code></pre>\n<p>it compiles fine in Visual Studio. Also if Foo is defined rather than just forward-declared, then it will compile fine with no assignment.</p>\n<p>Which should be the correct behavior? Is there anything in the C++ standard that addresses this, or is this something that is left to the implementation? I looked and didn't see anything that talks about this.</p>\n<p>Update:\n<a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/757831/\" rel=\"nofollow\">A bug report has been filed.</a></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "19404", "AnswerCount": "2"}, "11911111": {"ParentId": "11911056", "CommentCount": "1", "CreationDate": "2012-08-11T01:23:46.667", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "11911111", "Score": "6", "Body": "<p>This looks like the relevant part of the Standard (section 5.2.2):</p>\n<blockquote>\n<p id=\"so_11911056_11911111_0\">A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function\n  type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n<p id=\"so_11911056_11911111_1\">If a function call is a prvalue of object type:</p>\n<ul>\n<li><p id=\"so_11911056_11911111_2\">if the function call is either</p>\n<ul>\n<li><p id=\"so_11911056_11911111_3\">the operand of a <em>decltype-specifier</em> or</p></li>\n<li><p id=\"so_11911056_11911111_4\">the right operand of a comma operator that is the operand of a <em>decltype-specifier</em>,</p></li>\n</ul>\n<p id=\"so_11911056_11911111_5\">a temporary object is not introduced for the prvalue.  The type of the prvalue may be incomplete.\n  [ Note: as a result, storage is not allocated for the prvalue and it is not destroyed; thus, a class type is\n  not instantiated as a result of being the type of a function call in this context. This is true regardless of\n  whether the expression uses function call notation or operator notation (13.3.1.2).  \u2014 end note ] [ Note:\n  unlike the rule for a decltype-specifier that considers whether an id-expression is parenthesized (7.1.6.2),\n  parentheses have no special meaning in this context.  \u2014 end note ]</p></li>\n<li>otherwise, the type of the prvalue shall be complete.</li>\n</ul>\n</blockquote>\n<p>Since this function result type is an lvalue reference type, the function call evaluates to an lvalue, and the completeness requirement does not apply.</p>\n<p>The code is legal, at least in C++11, which no released version of Visual C++ implements fully.</p>\n", "LastActivityDate": "2012-08-11T01:23:46.667"}, "bq_ids": {"n4140": {"so_11911056_11911111_1": {"section_id": 3296, "quality": 1.0, "length": 5}, "so_11911056_11911111_0": {"section_id": 5997, "quality": 1.0, "length": 21}, "so_11911056_11911111_5": {"section_id": 5998, "quality": 0.8181818181818182, "length": 45}, "so_11911056_11911111_4": {"section_id": 5998, "quality": 1.0, "length": 6}}, "n3337": {"so_11911056_11911111_1": {"section_id": 3166, "quality": 1.0, "length": 5}, "so_11911056_11911111_0": {"section_id": 5765, "quality": 1.0, "length": 21}, "so_11911056_11911111_5": {"section_id": 5766, "quality": 0.8181818181818182, "length": 45}, "so_11911056_11911111_4": {"section_id": 5766, "quality": 1.0, "length": 6}}, "n4659": {"so_11911056_11911111_1": {"section_id": 4058, "quality": 1.0, "length": 5}, "so_11911056_11911111_0": {"section_id": 7498, "quality": 1.0, "length": 21}, "so_11911056_11911111_4": {"section_id": 607, "quality": 0.6666666666666666, "length": 4}}}, "11911203": {"ParentId": "11911056", "CommentCount": "1", "CreationDate": "2012-08-11T01:44:50.337", "OwnerUserId": "485289", "PostTypeId": "2", "Id": "11911203", "Score": "1", "Body": "<p>You can always use incomplete types in function declarations (since that only declares a signature of the function, not any real code), but not when you use it.</p>\n<p>Calling <code>CreateFoo();</code> is equals to <code>(void) CreateFoo();</code>, and my guess is that Visual Studio needs to inspect the code of Foo to do ANY conversion (I'm not sure if you can actually write a void conversion), because, for conversions you need a complete type.</p>\n<p>As for <code>Foo &amp; foo = CreateFoo();</code>, this does not do any conversions, so you can get away with having an incomplete type.</p>\n", "LastActivityDate": "2012-08-11T01:44:50.337"}});