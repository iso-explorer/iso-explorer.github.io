post_cb({"bq_ids": {"n4140": {"so_43769773_43771344_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 1548}, "so_43769773_43771344_1": {"length": 6, "quality": 1.0, "section_id": 1532}}, "n3337": {"so_43769773_43771344_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 1542}, "so_43769773_43771344_1": {"length": 6, "quality": 1.0, "section_id": 1526}}, "n4659": {"so_43769773_43771344_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 1698}, "so_43769773_43771344_1": {"length": 6, "quality": 1.0, "section_id": 1682}}}, "43769773": {"ViewCount": "174", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nint main(int, char **) {\n  std::basic_stringstream&lt;char16_t&gt; stream;\n\n  stream.put(u'\\u0100');\n  std::cout &lt;&lt; \" Bad: \" &lt;&lt; stream.bad() &lt;&lt; std::endl;\n\n  stream.put(u'\\uFFFE');\n  std::cout &lt;&lt; \" Bad: \" &lt;&lt; stream.bad() &lt;&lt; std::endl;\n\n  stream.put(u'\\uFFFF');\n  std::cout &lt;&lt; \" Bad: \" &lt;&lt; stream.bad() &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code> Bad: 0                                                                                                                                                                                \n Bad: 0                                                                                                                                                                                \n Bad: 1  \n</code></pre>\n<p>It seems the reason the badbit gets set is because 'put' sets the badbit if the character equals std::char_traits::eof(). I can now no longer put to the stream.</p>\n<p>At <a href=\"http://en.cppreference.com/w/cpp/string/char_traits\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/string/char_traits</a> it states:</p>\n<blockquote>\n<p id=\"so_43769773_43769773_0\">int_type: an integer type that can hold all values of char_type plus\n  EOF</p>\n</blockquote>\n<p>But if char_type is the same as int_type (uint_least16_t) then how can this be true?</p>\n", "AcceptedAnswerId": "43771344", "Title": "Is size of char_traits<char16_t>::int_type not large enough?", "CreationDate": "2017-05-03T20:50:08.630", "Id": "43769773", "CommentCount": "4", "LastEditDate": "2017-05-03T21:12:10.253", "PostTypeId": "1", "LastEditorUserId": "596781", "LastActivityDate": "2017-05-09T09:26:24.437", "Score": "4", "OwnerUserId": "676575", "Tags": "<c++>", "AnswerCount": "3"}, "43770842": {"Id": "43770842", "PostTypeId": "2", "Body": "<p>That really depends on what you mean by \"large enough\". <code>char16_t</code> is not \"a type large enough to hold any Unicode character including those which I'm not allowed to use\". <em>You</em> chose to try to cram <a href=\"http://www.unicode.org/versions/corrigendum9.html\" rel=\"nofollow noreferrer\"><code>\\uFFFF</code>, which is \"reserved for internal use\"</a>, into a <code>char16_t</code>, and thus you are the one at fault. The program is simply doing as you instructed.</p>\n", "LastActivityDate": "2017-05-03T22:12:00.937", "CommentCount": "11", "CreationDate": "2017-05-03T22:12:00.937", "ParentId": "43769773", "Score": "1", "OwnerUserId": "560648"}, "43771344": {"Id": "43771344", "PostTypeId": "2", "Body": "<p>The standard is quite explicit, <code>std::char_traits&lt;char16_t&gt;::int_type</code> is a typedef for <code>std::uint_least16_t</code>, see  [char.traits.specializations.char16_t], which also says:</p>\n<blockquote>\n<p id=\"so_43769773_43771344_0\">The member <code>eof()</code> shall return an implementation-defined constant that cannot appear as a valid UTF-16 code unit.</p>\n</blockquote>\n<p>I'm not sure precisely how that interacts with <a href=\"http://www.unicode.org/versions/corrigendum9.html\" rel=\"nofollow noreferrer\">http://www.unicode.org/versions/corrigendum9.html</a> but existing practice in the major C++ implementations is to use the all-ones bit pattern for <code>char_traits&lt;char16_t&gt;::eof()</code>, even when <code>uint_least16_t</code> has exactly 16 bits.</p>\n<p>After a bit more thought, I think it's possible for implementations to meet the Character traits requirements by making <code>std::char_traits&lt;char16_t&gt;::to_int_type(char_type)</code> return U+FFFD when given U+FFFF. This satisfies the requirement for <code>eof()</code> to return:</p>\n<blockquote>\n<p id=\"so_43769773_43771344_1\">a value <code>e</code> such that <code>X::eq_int_type(e,X::to_int_type(c))</code> is <code>false</code> for all values <code>c</code>.</p>\n</blockquote>\n<p>This would also ensure that it's possible to distinguish success and failure when checking the result of <code>basic_streambuf&lt;char16_t&gt;::sputc(u'\\uFFFF')</code>, so that it only returns <code>eof()</code> on failure, and returns <code>u'\\ufffd'</code> otherwise.</p>\n<p>I'll try that. I've created <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80624\" rel=\"nofollow noreferrer\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80624</a> to track this in GCC.</p>\n<p>I've also reported an <a href=\"http://wg21.link/lwg2959\" rel=\"nofollow noreferrer\">issue</a> against the standard, so we can fix the \"cannot appear as a valid UTF-16 code unit\" wording, and maybe fix it some other way too.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2017-05-09T09:26:24.437", "Score": "5", "CreationDate": "2017-05-03T23:02:50.147", "ParentId": "43769773", "CommentCount": "10", "OwnerUserId": "981959", "LastEditDate": "2017-05-09T09:26:24.437"}, "43775555": {"Id": "43775555", "PostTypeId": "2", "Body": "<p>The behavior is interesting, that:</p>\n<pre><code>stream.put(u'\\uFFFF');\n</code></pre>\n<p>sets the <code>badbit</code>, while:</p>\n<pre><code>stream &lt;&lt; u'\\uFFFF';\nchar16_t c = u'\\uFFFF'; stream.write( &amp;c, 1 );\n</code></pre>\n<p>does not set <code>badbit</code>.</p>\n<p>This answer only focus on the differences.</p>\n<p>So let's check gcc's source code in <a href=\"https://gcc.gnu.org/git/?p=gcc.git;a=blob;f=libstdc%2B%2B-v3/include/bits/ostream.tcc;h=e96bad8121000470fd6dcfc77c946d1d1ec08bd5;hb=HEAD#l149\" rel=\"nofollow noreferrer\">bits/ostream.tcc</a>, line 164~165, we can see that <code>put()</code> checks if the value equals to <code>eof()</code>, and set the <code>badbit</code>.</p>\n<pre><code>if (traits_type::eq_int_type(__put, traits_type::eof()))  // &lt;== It checks the value!\n    __err |= ios_base::badbit;\n</code></pre>\n<p>From line 196, we can see <code>write()</code> does not have this logic, it only checks if all the chars are written to the buffer.</p>\n<p>This explains the behavior.</p>\n<p>From <code>std::basic_ostream::put</code>'s <a href=\"http://www.cplusplus.com/reference/ostream/basic_ostream/put/\" rel=\"nofollow noreferrer\">description</a>:</p>\n<blockquote>\n<p id=\"so_43769773_43775555_0\">Internally, the function accesses the output sequence by first\n  constructing a sentry object. Then (if good), it inserts c into its\n  associated stream buffer object as if calling its member function\n  sputc, and finally destroys the sentry object before returning.</p>\n</blockquote>\n<p>It does not tell anything about the check of <code>eof()</code>.</p>\n<p>So I would think this is either a bug in document or a bug in implementation.</p>\n", "LastEditorUserId": "1030870", "LastActivityDate": "2017-05-05T15:23:51.783", "Score": "1", "CreationDate": "2017-05-04T06:37:35.300", "ParentId": "43769773", "CommentCount": "7", "OwnerUserId": "1030870", "LastEditDate": "2017-05-05T15:23:51.783"}});