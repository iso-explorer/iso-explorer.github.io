post_cb({"bq_ids": {"n4140": {"so_13038985_13039987_0": {"length": 12, "quality": 0.631578947368421, "section_id": 5421}, "so_13038985_13039987_1": {"length": 20, "quality": 1.0, "section_id": 5423}}, "n3337": {"so_13038985_13039987_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5216}, "so_13038985_13039987_1": {"length": 20, "quality": 1.0, "section_id": 5218}, "so_13038985_13039987_2": {"length": 17, "quality": 0.8095238095238095, "section_id": 5946}}, "n4659": {"so_13038985_13039987_0": {"length": 12, "quality": 0.631578947368421, "section_id": 6843}, "so_13038985_13039987_1": {"length": 20, "quality": 1.0, "section_id": 6845}}}, "13038985": {"ViewCount": "576", "Body": "<p>Normally, constexpr must be free of side-effects. However, I just discovered that it is possible to use side-effects in the constructors of thrown exceptions. That technique can be used to emulate assert() for constexpr functions, as it is demonstrated in the following program.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;stdexcept&gt;\n\nstruct constexpr_precond_violated : std::logic_error\n{\n  constexpr_precond_violated(const char* msg) :\n    std::logic_error(msg)\n  {\n    std::cerr &lt;&lt; msg &lt;&lt; '\\n';\n    abort(); // to get a core dump\n  }\n};\n\n#define TO_STRING_IMPL(x) #x\n#define TO_STRING(x) TO_STRING_IMPL(x)\n\n#define CONSTEXPR_PRECOND(cond, value) \\\n  ((!(cond)) ? throw constexpr_precond_violated( \\\n    \"assertion: &lt;\" #cond \"&gt; failed (file: \" \\\n    __FILE__ \", line: \" TO_STRING(__LINE__) \")\")    \\\n   : (value))\n\nconstexpr int divide(int x, int y)\n{\n  return CONSTEXPR_PRECOND(y != 0, x / y);\n}\n\nint main(int argc, char** argv)\n{\n  // The compiler cannot know argc, so it must be evaluated at runtime.\n  // If argc is 2, the precondition is violated.\n  return divide(100, argc - 2);\n}\n</code></pre>\n<p>I tested it with g++ 4.7.2 and clang++ 3.1. When the preconditions fails, you get the error location and a core dump.</p>\n<pre><code>./constexpr_assert some_arg\nassertion: &lt;y != 0&gt; failed (file: constexpr_assert.cpp, line: 26)\nAborted (core dumped)\n</code></pre>\n<p>So it works with the current compilers, but is it legal C++11?</p>\n", "AcceptedAnswerId": "13039987", "Title": "Is it legal to use side-effects in exceptions thrown by constexpr?", "CreationDate": "2012-10-23T20:48:15.223", "Id": "13038985", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-10-23T21:08:37.120", "LastEditorUserId": "636019", "LastActivityDate": "2012-10-23T22:27:35.667", "Score": "15", "OwnerUserId": "783510", "Tags": "<c++><c++11><assert><language-lawyer><constexpr>", "AnswerCount": "1"}, "13039987": {"Id": "13039987", "PostTypeId": "2", "Body": "<p>It is legal.</p>\n<p>For each <code>constexpr</code> function there must be some argument values that result in a constant expression (\u00a77.1.5/5):</p>\n<blockquote>\n<p id=\"so_13038985_13039987_0\">For a <code>constexpr</code> function, if no function argument values exist such\n  that the function invocation substitution would produce a constant\n  expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>Note that this does not mean that <em>every</em> possible argument value must result in a constant expression. <code>divide</code> clearly has some argument values that result in a constant expression: <code>divide(1, 1)</code> is a simple example. So, the definition is clearly valid.</p>\n<p>But can <code>divide(1, 0)</code> be called? Yes, it can. There's almost no difference between invoking a <code>constexpr</code> function or a \"normal\" function (\u00a77.1.5/7):</p>\n<blockquote>\n<p id=\"so_13038985_13039987_1\">A call to a <code>constexpr</code> function produces the same result as a call to\n  an equivalent non-<code>constexpr</code> function in all respects except that a\n  call to a <code>constexpr</code> function can appear in a constant expression.</p>\n</blockquote>\n<p>Note that calls to <code>constexpr</code> functions <em>can</em> appear in constant expressions, but nothing forbids them from not resulting in constant expressions. This is intended so one can call <code>constexpr</code> functions with both compile-time and runtime arguments (otherwise usefulness of <code>constexpr</code> would be severaly limited).</p>\n<p>For completeness, let's see what makes a constant expression (\u00a75.19/2):</p>\n<blockquote>\n<p id=\"so_13038985_13039987_2\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it\n  involves one of the following as a potentially evaluated subexpression\n  (\u00a73.2), but subexpressions of logical AND (\u00a75.14), logical OR (\u00a75.15),\n  and conditional (\u00a75.16) operations that are not evaluated are not\n  considered [...].</p>\n</blockquote>\n<p>So, <code>divide(1, 1)</code> is a constant expression, but <code>divide(1, 0)</code> is not. If you used <code>divide(1, 0)</code> in a template parameter, the program would be ill-formed. But otherwise it's fine.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-10-23T22:14:33.280", "Score": "14", "CreationDate": "2012-10-23T21:58:17.330", "ParentId": "13038985", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2012-10-23T22:14:33.280"}});