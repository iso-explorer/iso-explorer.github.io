post_cb({"21828507": {"ParentId": "21826187", "CommentCount": "0", "Body": "<p>In contrast to the first three types <code>iterator_category</code>, <code>value_type</code> and <code>difference_type</code>  (which are heavily used by the standard algorithms for tag dispatching to efficient versions depending on the iterator capabilities) the last two types <code>pointer</code> and <code>reference</code> inside <code>iterator_traits</code> appear not to be used by any algorithms but are used to define compliance with the iterator requirements.</p>\n<p><strong>24.2.1 In general [iterator.requirements.general]</strong></p>\n<blockquote>\n<p id=\"so_21826187_21828507_0\">1 [..] All iterators <code>i</code> for which the expression <code>(*i).m</code> is\n  well-de\ufb01ned, support the expression <code>i-&gt;m</code> with the same semantics as\n  <code>(*i).m</code>. [...]</p>\n</blockquote>\n<p><strong>24.4.1 Iterator traits [iterator.traits]</strong></p>\n<blockquote>\n<p id=\"so_21826187_21828507_1\">[...]\n  In addition, the types</p>\n<pre><code> iterator_traits&lt;Iterator&gt;::reference\n iterator_traits&lt;Iterator&gt;::pointer \n</code></pre>\n<p id=\"so_21826187_21828507_2\">shall be de\ufb01ned as the iterator\u2019s\n  reference and pointer types, that is, for an iterator object <code>a</code>, the\n  same type as the type of <code>*a</code> and <code>a-&gt;</code>, respectively. [...]</p>\n</blockquote>\n<p>The default values <code>T*</code> and <code>T&amp;</code> for <code>pointer</code> and <code>reference</code> of course satisfy the iterator requirements. Regarding proxy references, the <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/iterator/doc/iterator_facade.html#id2\" rel=\"nofollow\">Boost.Iterator documentation</a> specifies</p>\n<blockquote>\n<p id=\"so_21826187_21828507_3\">The <code>reference</code> type of a readable iterator (and today's input iterator)\n  need not in fact be a reference, so long as it is convertible to the\n  iterator's <code>value_type</code>. When the <code>value_type</code> is a class, however, it\n  must still be possible to access members through <code>operator-&gt;</code>.\n  Therefore, an iterator whose <code>reference</code> type is not in fact a reference\n  must return a proxy containing a copy of the referenced value from its\n  <code>operator-&gt;</code>.</p>\n<p id=\"so_21826187_21828507_4\">The return types for <code>iterator_facade</code>'s <code>operator-&gt;</code> and <code>operator[]</code> are\n  not explicitly specified. Instead, those types are described in terms\n  of a set of requirements, which must be satisfied by the\n  <code>iterator_facade</code> implementation.</p>\n</blockquote>\n<p><strong>Conclusion</strong>: as long as a proxy iterator does not require accessing members of its underlying <code>value_type</code> through <code>.m</code> or <code>-&gt;m</code>, one does not need to worry about the <code>pointer</code> type inside <code>iterator_traits</code>, and even if one does use proxy iterators, <code>boost::iterator_facade</code> will do the right thing.</p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "21828507", "Score": "1", "CreationDate": "2014-02-17T11:59:15.697", "LastActivityDate": "2014-02-17T11:59:15.697"}, "21826187": {"CommentCount": "7", "ViewCount": "255", "CreationDate": "2014-02-17T10:13:46.143", "LastActivityDate": "2014-02-17T11:59:15.697", "Title": "What is the use of the nested pointer type in iterator_traits?", "AcceptedAnswerId": "21828507", "PostTypeId": "1", "Id": "21826187", "Score": "3", "Body": "<p>The <code>std::iterator_traits</code> class template defines 5 nested types: <code>iterator_category</code>, <code>value_type</code>, <code>difference_type</code>, <code>pointer</code> and <code>reference</code>. Browsing the sources of the <code>&lt;algorithm&gt;</code> header of both libc++ and libstdc++, one can see many uses of <code>value_type</code>, <code>difference_type</code> and <code>iterator_category</code>, but only one for <code>reference</code> (inside <code>std::iter_swap</code>) and none for <code>pointer</code>. </p>\n<p>My application uses a hand-built proxy iterator / proxy reference pair. I want to transition to using the Boost <code>iterator_facade</code> which lets me configure the reference type from the default <code>T&amp;</code> to an arbitrary type, but not so for the pointer type which is <code>T*</code> by default. I want to avoid being bitten by some deeply hidden use of the nested <code>pointer</code> type.</p>\n<p><strong>Note</strong>: the iterator is a proxy for a builtin type without nested members, so I do not need compatibility with <code>operator-&gt;</code> (for which the return type would be <code>pointer</code>).</p>\n<p><strong>Question</strong>: what use cases are there in the Standard Library for the nested type <code>pointer</code> inside <code>iterator_traits</code>?</p>\n", "Tags": "<c++><iterator><traits><proxy-classes><boost-iterators>", "OwnerUserId": "819272", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21826187_21828507_2": {"section_id": 5583, "quality": 0.9090909090909091, "length": 10}, "so_21826187_21828507_0": {"section_id": 5555, "quality": 0.875, "length": 7}}, "n3337": {"so_21826187_21828507_2": {"section_id": 5365, "quality": 0.9090909090909091, "length": 10}, "so_21826187_21828507_0": {"section_id": 5337, "quality": 0.875, "length": 7}}, "n4659": {"so_21826187_21828507_2": {"section_id": 7030, "quality": 0.9090909090909091, "length": 10}, "so_21826187_21828507_0": {"section_id": 7000, "quality": 0.625, "length": 5}}}});