post_cb({"36549760": {"Id": "36549760", "PostTypeId": "2", "Body": "<p>It is possible to do this using macros:</p>\n<pre><code>#define delete _delete\n\nenum class EServerAction\n{\n    create,\n    read,\n    update,\n    delete\n};\n</code></pre>\n<p>This practice is usually discouraged because now you cannot use <code>delete</code> in other parts of the file. But it is useful in some situations like when compiling a C program that has identifiers named as C++ keywords (like <code>delete</code>) using a C++ compiler.</p>\n<p>This will also cause confusion in the debugger because the identifiers for the symbols are not the same identifiers that are in the source code.</p>\n", "LastEditorUserId": "3787875", "LastActivityDate": "2016-04-11T13:21:15.837", "Score": "0", "CreationDate": "2016-04-11T13:13:04.847", "ParentId": "36547516", "CommentCount": "3", "OwnerUserId": "3787875", "LastEditDate": "2016-04-11T13:21:15.837"}, "36547516": {"ViewCount": "1195", "Body": "<p>I have been unable to find if there is a way to use a keyword in a enum definition, like:</p>\n<pre><code>enum class EServerAction\n{\n    create,\n    read,\n    update,\n    delete\n};\n</code></pre>\n<p>In C# I can use the @ char to make the compiler look at it as an identifier. Is there a way to do this in C++ (Visual Studio 2015)?</p>\n", "AcceptedAnswerId": "36547634", "Title": "Is there a way to use a keyword as identifier in an enum?", "CreationDate": "2016-04-11T11:32:03.370", "Id": "36547516", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2016-04-11T15:14:38.667", "Score": "17", "OwnerUserId": "4278283", "Tags": "<c++><enums><keyword>", "AnswerCount": "4"}, "36547798": {"Id": "36547798", "PostTypeId": "2", "Body": "<p>In C++ keywords cannot be used as identifiers as they can in C#.</p>\n", "LastEditorUserId": "1879699", "LastActivityDate": "2016-04-11T12:11:31.643", "Score": "2", "CreationDate": "2016-04-11T11:45:39.400", "ParentId": "36547516", "CommentCount": "2", "OwnerUserId": "3767202", "LastEditDate": "2016-04-11T12:11:31.643"}, "bq_ids": {"n4140": {"so_36547516_36552661_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 6307}, "so_36547516_36552661_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 5336}, "so_36547516_36552661_4": {"length": 9, "quality": 0.9, "section_id": 5335}, "so_36547516_36552661_6": {"length": 10, "quality": 1.0, "section_id": 6307}, "so_36547516_36552661_2": {"length": 9, "quality": 0.9, "section_id": 5337}}, "n3337": {"so_36547516_36552661_5": {"length": 13, "quality": 0.9285714285714286, "section_id": 6064}, "so_36547516_36552661_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 5133}, "so_36547516_36552661_4": {"length": 9, "quality": 0.9, "section_id": 5132}, "so_36547516_36552661_6": {"length": 10, "quality": 1.0, "section_id": 6064}, "so_36547516_36552661_2": {"length": 9, "quality": 0.9, "section_id": 5134}}, "n4659": {"so_36547516_36552661_5": {"length": 12, "quality": 0.8571428571428571, "section_id": 6756}, "so_36547516_36552661_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 6757}, "so_36547516_36552661_4": {"length": 8, "quality": 0.8, "section_id": 6756}, "so_36547516_36552661_6": {"length": 9, "quality": 0.9, "section_id": 6756}, "so_36547516_36552661_2": {"length": 9, "quality": 0.9, "section_id": 6758}}}, "36547634": {"Id": "36547634", "PostTypeId": "2", "Body": "<p>No they cant be used.</p>\n<p>From <a href=\"https://msdn.microsoft.com/en-us/library/2e6a4at9(v=vs.110).aspx\">MSDN</a></p>\n<blockquote>\n<p id=\"so_36547516_36547634_0\">Keywords are predefined reserved identifiers that have special\n  meanings. <strong>They cannot be used</strong> as identifiers in your program.</p>\n</blockquote>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/language/identifiers\">rule</a> for identifier says:</p>\n<blockquote>\n<p id=\"so_36547516_36547634_1\">An identifier can be used to name objects, references, functions,\n  enumerators, types, class members, namespaces, templates, template\n  specializations, parameter packs, goto labels, and other entities,\n  with the following exceptions:</p>\n<ul>\n<li><strong>the identifiers that are keywords cannot be used for other purposes;</strong></li>\n<li>the identifiers with a double underscore anywhere are reserved;</li>\n<li>the identifiers that begin with an underscore followed by an    uppercase letter are reserved;</li>\n<li>the identifiers that begin with an underscore are reserved in the    global namespace.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "1501794", "LastActivityDate": "2016-04-11T12:05:10.587", "Score": "14", "CreationDate": "2016-04-11T11:37:29.040", "ParentId": "36547516", "CommentCount": "5", "OwnerUserId": "1501794", "LastEditDate": "2016-04-11T12:05:10.587"}, "36552661": {"Id": "36552661", "PostTypeId": "2", "Body": "<p>As per 2.12 [lex.key] in the C++14 standard, certain identifiers <strong>must never</strong> be used as identifiers:</p>\n<blockquote>\n<p id=\"so_36547516_36552661_0\">The identifiers shown in Table 4 are reserved for use as keywords (that is, they are unconditionally treated as keywords in phase 7) except in an attribute token (7.6.1) [ Note: The export keyword is unused but is reserved for future use. \u2014 end note ]:</p>\n<p id=\"so_36547516_36552661_1\"><strong><em>Table 4 \u2014 Keywords</em></strong></p>\n<pre><code>   alignas continue friend register true\n   alignof decltype goto reinterpret_cast try\n   asm default if return typedef\n   auto delete inline short typeid\n   bool do int signed typename\n   break double long sizeof union\n   case dynamic_cast mutable static unsigned\n   catch else namespace static_assert using\n   char enum new static_cast virtual\n   char16_t explicit noexcept struct void\n   char32_t export nullptr switch volatile\n   class extern operator template wchar_t\n   const false private this while\n   constexpr float protected thread_local\n   const_cast for public throw\n</code></pre>\n</blockquote>\n<p>Furthermore, some identifiers <strong>shall not</strong> be used:</p>\n<blockquote>\n<p id=\"so_36547516_36552661_2\">Furthermore, the alternative representations shown in Table 5 for certain operators and punctuators (2.6) are reserved and shall not be used otherwise:</p>\n<p id=\"so_36547516_36552661_3\"><strong><em>Table 5 \u2014 Alternative representations</em></strong></p>\n<pre><code>and and_eq bitand bitor compl not\nnot_eq or or_eq xor xor_eq\n</code></pre>\n</blockquote>\n<p>Even furthermore, as per 2.11 Identifier [lex.name], some are <strong>illegal to use</strong>, but the compiler is not required to tell you:</p>\n<blockquote>\n<p id=\"so_36547516_36552661_4\">some identifiers are reserved for use by C++ implementations and standard libraries (17.6.4.3.2) and shall not be used otherwise; no diagnostic is required</p>\n<p id=\"so_36547516_36552661_5\">\u2014 Each name that contains a double underscore _ _ or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use.</p>\n<p id=\"so_36547516_36552661_6\">\u2014 Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</p>\n</blockquote>\n", "LastActivityDate": "2016-04-11T15:14:38.667", "CommentCount": "0", "CreationDate": "2016-04-11T15:14:38.667", "ParentId": "36547516", "Score": "2", "OwnerUserId": "76722"}});