post_cb({"24555402": {"Id": "24555402", "PostTypeId": "2", "Body": "<p>The only suitable overload of <code>operator&lt;&lt;</code> is that for <code>bool</code>, so the array is converted (via a pointer) to <code>bool</code>, giving <code>true</code> since its address is non-null. This outputs as <code>1</code> unless you use the <code>std::boolalpha</code> manipulator.</p>\n<p>It can't use the overload for <code>const char *</code> which would output the string, or that for <code>const void *</code> which would output the pointer value, since those conversions would require removing the <code>volatile</code> qualifier. Implicit pointer conversions can add qualifiers, but can't remove them.</p>\n<p>To output the string, you'd have to cast away the qualifier:</p>\n<pre><code>std::cout &lt;&lt; const_cast&lt;const char*&gt;(test) &lt;&lt; \"\\n\";\n</code></pre>\n<p>but beware that this gives undefined behaviour since the array will be accessed as if it were not volatile.</p>\n<p><code>printf</code> is an old-school variadic function, giving no type safety. The <code>%s</code> specifier makes it interpret the argument as <code>const char *</code>, whatever it actually is.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-07-04T06:10:53.323", "Score": "14", "CreationDate": "2014-07-03T13:44:47.457", "ParentId": "24555288", "CommentCount": "7", "OwnerUserId": "204847", "LastEditDate": "2014-07-04T06:10:53.323"}, "bq_ids": {"n4140": {"so_24555288_24555400_1": {"length": 14, "quality": 1.0, "section_id": 5435}, "so_24555288_24555400_0": {"length": 15, "quality": 1.0, "section_id": 14}}, "n3337": {"so_24555288_24555400_1": {"length": 14, "quality": 1.0, "section_id": 5230}, "so_24555288_24555400_0": {"length": 15, "quality": 1.0, "section_id": 11}}, "n4659": {"so_24555288_24555400_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 6862}, "so_24555288_24555400_0": {"length": 15, "quality": 1.0, "section_id": 19}}}, "24555400": {"Id": "24555400", "PostTypeId": "2", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt\" rel=\"nofollow\">std::basic_ostream::operator&lt;&lt;</a> only has an overload for <code>const char*</code> or <code>const void*</code> which does not match in this case since you can not discard the <em>volatile</em> qualifier without a cast, this is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>4.4</code> <em>Qualification conversions</em> which says:</p>\n<blockquote>\n<p id=\"so_24555288_24555400_0\">A prvalue of type \u201cpointer to cv1 T\u201d can be converted to a prvalue of\n  type \u201cpointer to cv2 T\u201d if \u201ccv2 T\u201d is more cv-qualified than \u201ccv1 T\u201d.</p>\n</blockquote>\n<p>so it is using the <code>bool</code> version and since it is not a <code>nullptr</code> the result is <code>true</code>.</p>\n<p>If you remove the <em>volatile</em> qualifier from <code>test</code> this will provide the result you expect. Several answers suggest using a <code>const_cast</code> to remove the volatile qualifiers but this is undefined behavior. We can see by going to section <code>7.1.6.1</code> <em>The cv-qualifiers</em> paragraph <em>6</em> which says:</p>\n<blockquote>\n<p id=\"so_24555288_24555400_1\">If an attempt is made to refer to an object defined with a\n  volatile-qualified type through the use of a glvalue with a\n  non-volatile-qualified type, the program behavior is undefined.</p>\n</blockquote>\n<p><code>const_cast</code> in this case yields a <em>prvalue</em> but dereferencing that pointer yields an <em>lvalue</em> which will invoke undefined behavior.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-04T10:46:36.217", "Score": "5", "CreationDate": "2014-07-03T13:44:44.227", "ParentId": "24555288", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-07-04T10:46:36.217"}, "24555405": {"Id": "24555405", "PostTypeId": "2", "Body": "<p>Answer found <a href=\"http://www.daniweb.com/software-development/cpp/threads/329452/volatile-string-why-has-1-output\" rel=\"nofollow\">here</a> by a minimal amount of web searching:</p>\n<blockquote>\n<p id=\"so_24555288_24555405_0\">Short answer: <code>cout</code> is interpreting the object as a <code>bool</code> due to the <code>volatile</code> qualifier. It's a quirk of overloading for the <code>&lt;&lt;</code> operator.</p>\n<p id=\"so_24555288_24555405_1\">Long answer: A volatile pointer can't be converted to a non-volatile pointer without an explicit cast, so neither the <code>char*</code> nor the <code>void*</code> overload can be used when the <code>&lt;&lt;</code> operator is called. There's no volatile qualified overload, and the closest match is the <code>bool</code> overload, thus your array is interpreted as a boolean value rather than an address or a string.</p>\n<p id=\"so_24555288_24555405_2\">You can fix it a number of ways, but an explicit cast is probably what you wanted:</p>\n</blockquote>\n<pre><code>std::cout&lt;&lt; (char*)test &lt;&lt;std::endl;\n</code></pre>\n<p>(Personally I would cast to <code>const char*</code>.)</p>\n", "LastActivityDate": "2014-07-03T13:44:52.470", "CommentCount": "0", "CreationDate": "2014-07-03T13:44:52.470", "ParentId": "24555288", "Score": "2", "OwnerUserId": "166749"}, "24555288": {"ViewCount": "514", "Body": "<p>Consider this (artificial) example:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  volatile char test[] = \"abc\";\n  std::printf(\"%s\\n\", test);\n  std::cout &lt;&lt; test &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Compiling it with GCC and running gives the following output:</p>\n<pre><code>$ g++ test.cc \n$ ./a.out \nabc\n1\n</code></pre>\n<p>As you can see <code>printf</code> prints the string correctly while <code>cout</code> prints <code>1</code>. Why does writing to <code>cout</code> produces <code>1</code> in this case?</p>\n", "AcceptedAnswerId": "24555402", "Title": "Why does ostream prints `1` for a string defined as `volatile char[]`?", "CreationDate": "2014-07-03T13:39:56.140", "LastActivityDate": "2014-07-04T10:46:36.217", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "Tags": "<c++><string><printf><iostream><volatile>", "Id": "24555288", "Score": "16", "OwnerUserId": "471164", "ClosedDate": "2014-07-03T17:11:00.200", "AnswerCount": "4"}, "24555539": {"Id": "24555539", "PostTypeId": "2", "Body": "<p>It's the <code>volatile</code> qualifier that casts it to a <code>bool</code>, try instead:</p>\n<pre><code>std::cout &lt;&lt; const_cast&lt;char*&gt;(test) &lt;&lt; \"\\n\";\n</code></pre>\n", "LastActivityDate": "2014-07-03T13:50:16.740", "CommentCount": "2", "CreationDate": "2014-07-03T13:50:16.740", "ParentId": "24555288", "Score": "0", "OwnerUserId": "1312406"}});