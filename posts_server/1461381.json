post_cb({"1461475": {"ParentId": "1461381", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I can see two distinct questions here.</p>\n<p>First, on modern architectures it's pretty safe to assume that pointers are the same size (that is, there are no near/far pointers; but pointers to member functions aren't regular pointers and may be a different size); and on a 32 bit system that size is generally 32 bits.  C even goes so far as to automatically cast <code>void*</code> to anything else because, after all, a pointer is really just a memory address.  However the language definitions distinguish various pointers as different types.  I believe the reason for this is that different types can have different alignment (the <code>void*</code> rule is that nothing can really be of type <code>void</code>, so if you have a pointer to <code>void</code> you likely know the correct type and, implicitly, the correct alignment(<em>see note</em>))</p>\n<p>Second, as others have pointed out, <code>long</code>s and <code>ints</code> are fundamentally different types with default conversions built in.  The standards require <code>long</code>s to be at least as large as <code>int</code>s, but possibly larger.  On your architecture, the alignment is probably the same but on other architectures that could be different as well.</p>\n<p>It is possible to fudge in your case, but it's not portable.  If you do not <code>#include</code> the correct function declarations, and instead simply forward declare them yourself things should magically work because in your case <code>long</code>s and <code>int</code>s are compatible (assuming no signedness issues; also in C++ you'll need to <code>extern \"C\"</code> both your declarations and the actual function implementations so that you don't get link errors).  Until you switch to a different compiler, or different operating system, or different architecture, etc.</p>\n<p>For instance, in C++ you could do this:</p>\n<pre><code>// in file lib.cc\n#include &lt;iostream&gt;\n\nextern \"C\" void foo_int(int* a)\n{\n    std::cout &lt;&lt; \"foo_int \" &lt;&lt; *a &lt;&lt; \" at address \" &lt;&lt; a &lt;&lt;'\\n';\n}\n\nextern \"C\" void foo_long(long* a)\n{\n    std::cout &lt;&lt; \"foo_long \" &lt;&lt; *a &lt;&lt; \" at address \" &lt;&lt; a &lt;&lt;'\\n';\n}\n</code></pre>\n<hr>\n<pre><code>// In file main.cc\nextern \"C\" void foo_int(long* a);\nextern \"C\" void foo_long(int* a);\n\nint main()\n{\n    int i = 5;\n    long l = 10;\n\n    foo_long(&amp;i);\n    foo_int(&amp;l);\n}\n</code></pre>\n<p>(In C, you would get rid of the <code>extern \"C\"</code> and use <code>printf</code> instead of <code>cout</code>).</p>\n<p>Using GCC you would compile like so:</p>\n<pre><code>$ g++ -c lib.cc -o lib.o\n$ g++ main.cc lib.o\n$ ./a.out\nfoo_long 5 at address 0x22cce4\nfoo_int 10 at address 0x22cce0\n</code></pre>\n<hr>\n<p><strong>NOTE</strong>  Since there are no objects of type <code>void</code>, a <code>void*</code> can only point to objects of some other type.  And the compiler knew that real type when it put the object there.  And the compiler knew the alignment for that type when it allocated the object.  You may not really know the alignment, but the cast is only guaranteed to work if it's back to the original type, in which case the alignment and size will be the same.</p>\n<p>But there are wrinkles.  For one, the object's packing must be the same in both places (not an issue with primitive types).  For another, it <em>is</em> possible to point at arbitrary memory with <code>void*</code>s, but programmers who do that presumably realize what they're doing.</p>\n</hr></hr>", "OwnerUserId": "10593", "LastEditorUserId": "10593", "LastEditDate": "2009-09-23T05:54:24.220", "Id": "1461475", "Score": "18", "CreationDate": "2009-09-22T17:33:07.773", "LastActivityDate": "2009-09-23T05:54:24.220"}, "1461390": {"ParentId": "1461381", "CommentCount": "0", "Body": "<p>...because the C++ standard defines int and long to be two distinct types regardless of their value range, representation, etc. If by \"basically compatible\" you mean convertible to each other, then yes.</p>\n", "OwnerUserId": "172531", "PostTypeId": "2", "Id": "1461390", "Score": "25", "CreationDate": "2009-09-22T17:16:35.197", "LastActivityDate": "2009-09-22T17:16:35.197"}, "1461518": {"ParentId": "1461381", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is because on some platforms long and int are of different size. </p>\n<pre>\n16 bit:\nlong=32bits\nint=16bits\n\n32bit:\nlong=32bits\nint=32bits\n\n64bit(ILP64):\nlong=64bits\nint=64bits\n\n64bit(LP64):\nlong=64bits\nint=32bits\n\n64bit(LLP64): (what windows uses for whatever reason)\nlong long=64bits\nlong=32bits\nint=32bits\n</pre>\n<p>Also, the more confusing thing is that though you must cast to interact between the two types, but you can not do function overloading like this as if they truly were two separate types</p>\n<pre><code>long foo(int bar);\nint foo(int bar);\n</code></pre>\n", "OwnerUserId": "69742", "LastEditorUserId": "69742", "LastEditDate": "2009-09-22T17:50:50.063", "Id": "1461518", "Score": "2", "CreationDate": "2009-09-22T17:41:44.013", "LastActivityDate": "2009-09-22T17:50:50.063"}, "1462060": {"ParentId": "1461381", "CommentCount": "0", "Body": "<p>Since I don't particularly like any of the answers given so far, I went to the C++ standard:</p>\n<blockquote>\n<p id=\"so_1461381_1462060_0\">4.7  Integral conversions                              [conv.integral]</p>\n<p id=\"so_1461381_1462060_1\">1 An rvalue of an integer type can be\n  converted to an rvalue of another\n  integer type. An rvalue of an\n  enumeration type can be converted to\n  an rvalue of an integer type.</p>\n</blockquote>\n<p>This says it is allowed to implicitly convert one integer to another, so the two types (as they are the same size), are interchangeable as rvalues.</p>\n<blockquote>\n<p id=\"so_1461381_1462060_2\">4.10  Pointer conversions                                   [conv.ptr]</p>\n<p id=\"so_1461381_1462060_3\">1 An  integral constant expression\n  (<em>expr.const</em>) rvalue of integer type\n  that evaluates to zero (called a null\n  pointer constant)  can  be  converted  to  a  pointer  type.   The\n  result is a value (called the null\n  pointer value of that type)\n  distinguishable from every pointer to\n  an object or function. Two null\n  pointer values of the same type shall\n  compare equal.  The conversion of a\n  null pointer constant to a pointer\n  to cv-qualified type is a single\n  conversion, and not the sequence of a\n  pointer conversion followed   by\n  a qualification conversion\n  (<em>conv.qual</em>).</p>\n<p id=\"so_1461381_1462060_4\">2 An rvalue of type \"pointer to cv T,\"\n  where T is an object type, can be\n  converted to an rvalue of type\n  \"pointer to cv void.\" The  result\n  of converting a \"pointer to cv T\" to\n  a \"pointer to cv void\" points to the\n  start of the storage location where\n  the object of type T resides, as\n  if the object is a most derived\n  object (<em>intro.object</em>) of type T\n  (that is, not a base class subobject).</p>\n<p id=\"so_1461381_1462060_5\">3 An rvalue of type \"pointer to cv D,\"\n  where D is a class type,  can  be\n  converted  to  an  rvalue of type\n  \"pointer to cv B,\" where B is a base\n  class (<em>class.derived</em>) of D.\n  If B is an inaccessible\n  (<em>class.access</em>) or ambiguous\n  (<em>class.member.lookup</em>) base class of\n  D, a program that necessitates this\n  conversion is ill-formed. The result\n  of the conversion is a pointer to\n  the base class sub-object of the\n  derived class object. The null\n  pointer value is converted to the null\n  pointer value of the destination type.</p>\n</blockquote>\n<p>It is only allowed to implicitly convert:</p>\n<ul>\n<li>0 to any pointer type (making it a null pointer)</li>\n<li>any pointer type to void* (properly cv-qualified)</li>\n<li>derived pointer to a base pointer (properly cv-qualified)</li>\n</ul>\n<p>So even though the underlying machine type is the same, it is not allowed to implicitly convert between the two types.</p>\n", "OwnerUserId": "5963", "PostTypeId": "2", "Id": "1462060", "Score": "4", "CreationDate": "2009-09-22T19:18:25.917", "LastActivityDate": "2009-09-22T19:18:25.917"}, "1461394": {"ParentId": "1461381", "CommentCount": "0", "Body": "<p><code>long</code> and <code>int</code> are two distinct types, even if they are the same size. There would be huge consequences in the c++ template world if they were treated the same by some compilers.</p>\n", "OwnerUserId": "72631", "PostTypeId": "2", "Id": "1461394", "Score": "7", "CreationDate": "2009-09-22T17:17:31.747", "LastActivityDate": "2009-09-22T17:17:31.747"}, "1463286": {"ParentId": "1461381", "CommentCount": "1", "Body": "<p>int and long are defined to be distinct types so you can program portable.</p>\n", "OwnerUserId": "44952", "PostTypeId": "2", "Id": "1463286", "Score": "1", "CreationDate": "2009-09-23T00:12:52.177", "LastActivityDate": "2009-09-23T00:12:52.177"}, "bq_ids": {"n4140": {"so_1461381_1462060_1": {"section_id": 30, "quality": 0.7647058823529411, "length": 13}, "so_1461381_1462060_5": {"section_id": 41, "quality": 0.8409090909090909, "length": 37}, "so_1461381_1462060_3": {"section_id": 39, "quality": 0.7454545454545455, "length": 41}}, "n3337": {"so_1461381_1462060_1": {"section_id": 27, "quality": 0.7647058823529411, "length": 13}, "so_1461381_1462060_5": {"section_id": 38, "quality": 0.8409090909090909, "length": 37}, "so_1461381_1462060_3": {"section_id": 36, "quality": 0.8181818181818182, "length": 45}, "so_1461381_1462060_4": {"section_id": 37, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_1461381_1462060_1": {"section_id": 30, "quality": 0.7647058823529411, "length": 13}, "so_1461381_1462060_3": {"section_id": 39, "quality": 0.7454545454545455, "length": 41}, "so_1461381_1462060_5": {"section_id": 41, "quality": 0.8409090909090909, "length": 37}}}, "1461429": {"ParentId": "1461381", "CommentCount": "0", "Body": "<p>Just because <code>long</code> and <code>int</code> both happen to be 32-bit on your particular compiler and hardware, does not mean that they will always both be 32-bit on every kind of hardware and every compiler.</p>\n<p>C (and C++) were designed to be source-portable between different compilers and different hardware.</p>\n", "OwnerUserId": "52963", "PostTypeId": "2", "Id": "1461429", "Score": "26", "CreationDate": "2009-09-22T17:24:32.980", "LastActivityDate": "2009-09-22T17:24:32.980"}, "15246330": {"ParentId": "1461381", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I don't think any of these answers cut to the chase.</p>\n<p>The answer is this: valid conversion between types doesn't imply valid conversion between pointers. This makes sense, right? You want the following code to compile</p>\n<pre><code>char a = 12;\nint b = a;\n</code></pre>\n<p>But letting this code compile would be a recipe for disaster:</p>\n<pre><code>void foo(int* x) { x = 0x7f8f9faf; }\n\n// ...\n\nchar a = 12;\nfoo(&amp;a);\n</code></pre>\n<p>So just because there exists a conversion between <code>long</code> and <code>int</code> doesn't mean that there should be a pointer conversion. But, you may protest, <code>long</code> and <code>int</code> have exactly the same representation on your compiler! And you'd be right but that doesn't change the fact that as far as the standard and compiler are concerned they are different types. And you can't implicitly convert between pointers to types unless there is an inheritance relationship.</p>\n<p>Also, more generally, whilst C++ may change in whether it is valid on not based on the local definitions of how big <code>int</code>, etc. are, it does not change whether it is syntactically correct. Completely collapsing the distinction between <code>long</code> and <code>int</code> will do this.</p>\n", "OwnerUserId": "1502345", "LastEditorUserId": "1502345", "LastEditDate": "2013-03-06T11:45:02.003", "Id": "15246330", "Score": "1", "CreationDate": "2013-03-06T11:36:47.223", "LastActivityDate": "2013-03-06T11:45:02.003"}, "1463385": {"ParentId": "1461381", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You don't need to write the explicit cast by hand on every call. A simple macro can do it:</p>\n<pre><code>#include &lt;stdio.h&gt; \n\nvoid foo_int( int *a ){ printf(\"a: %i\\n\", *a ); }\n\n#define foo_int(a)  foo_int( (int*)a ) \n\nint main(){\n  long l = 12;\n  foo_int( &amp;l; ); // no warning, runs as expected\n  foo_int(  l ); // no warning, segmentation fault\n}\n</code></pre>\n", "OwnerUserId": "172856", "LastEditorUserId": "172856", "LastEditDate": "2009-09-23T00:57:23.313", "Id": "1463385", "Score": "0", "CreationDate": "2009-09-23T00:43:57.877", "LastActivityDate": "2009-09-23T00:57:23.313"}, "1461381": {"CommentCount": "1", "ViewCount": "1814", "PostTypeId": "1", "LastEditorUserId": "5963", "CreationDate": "2009-09-22T17:14:50.347", "LastActivityDate": "2013-03-06T11:45:02.003", "Title": "Why are \"long *\" and \"int *\" not compatible in 32-bit code?", "FavoriteCount": "1", "LastEditDate": "2009-09-22T18:58:16.613", "Id": "1461381", "Score": "7", "Body": "<p>I was wondering why the following code doesn't compile:</p>\n<pre><code>void foo_int(int *a) { }\nvoid foo_long(long *a) { }\n\nint main()\n{\n    int i;\n    long l;\n\n    foo_long(&amp;i);\n    foo_int(&amp;l);\n}\n</code></pre>\n<p>I am using GCC, and neither calls work either in C or C++. Since it is a 32-bit system, both <strong>int</strong> and <strong>long</strong> are signed 32-bit integers (which can be verified with sizeof at compile time).</p>\n<p>The reason I am asking is that I have two separate header files, neither are under my control, and one does something like: <code>typedef unsigned long u32;</code> and the other: <code>typedef unsigned int uint32_t;</code>. The declarations are basically compatible, except when I use them as pointers as in the above code snippet, I have to explicitly cast.</p>\n<p>Any idea why this is?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "5963", "AnswerCount": "10"}, "1461675": {"ParentId": "1461381", "CommentCount": "2", "Body": "<p>int* and long* are distinct types, which are not necessarily the same. In every real implementation I think they are, but that's neither here nor there for a standards-conformant compiler.</p>\n<p>I believe it was one of the early PDP machines in which a char* was larger than an int*. The reason for this was the odd size of ints on that architecture (36bits). So the system would pack multiple 9bit chars into a single int, so a char* contained the address in the format of (int*,offset inside the int). **</p>\n<p>The standard specifies that all pointers are representable as a void*, and insinuates that char* must be the same as void*, but there is no particular requirement for the other pointer types to be convertible.</p>\n<p>** I'm unable to find references to this, so the source of this might have been a theoretical (but still valid) example rather than an actual implementation.<a href=\"http://www.parashift.com/c++-faq-lite/intrinsic-types.html#faq-26.6\" rel=\"nofollow noreferrer\">C++ FAQ Lite</a></p>\n", "OwnerUserId": "118150", "PostTypeId": "2", "Id": "1461675", "Score": "2", "CreationDate": "2009-09-22T18:08:47.087", "LastActivityDate": "2009-09-22T18:08:47.087"}});