post_cb({"46038799": {"ParentId": "46038378", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A conforming implementation of std::optional <em>must</em> respect the alignment requirements of its <code>value_type</code> according to the C++17 standard draft:</p>\n<blockquote>\n<p id=\"so_46038378_46038799_0\">23.6.3 Class template optional</p>\n<p id=\"so_46038378_46038799_1\">(...)\n  The contained value shall be allocated in a region of the optional storage suitably aligned for the type T.</p>\n</blockquote>\n<p>An implementor could use a union potentially containing the value as member, ensuring proper alignment.</p>\n<p>As Thomas already mentioned while I was looking it up, boost::optional does ensure proper alignment by use of <code>aligned_storage&lt;T&gt;</code></p>\n", "OwnerUserId": "6608866", "LastEditorUserId": "6608866", "LastEditDate": "2017-09-04T14:27:01.917", "Id": "46038799", "Score": "5", "CreationDate": "2017-09-04T14:06:28.777", "LastActivityDate": "2017-09-04T14:27:01.917"}, "46038714": {"ParentId": "46038378", "CommentCount": "1", "Body": "<p>In the GNU C++ implementation, <code>std::optional</code> derives from <code>_Optional_Base&lt;_Tp&gt;</code>, which in turn contains an <code>_Optional_payload&lt;_Tp&gt;</code>. This is a template with several specializations, all of which contains the following members:</p>\n<pre><code>  using _Stored_type = remove_const_t&lt;_Tp&gt;;\n  struct _Empty_byte { };\n  union {\n      _Empty_byte _M_empty;\n      _Stored_type _M_payload;\n  };\n  bool _M_engaged = false;\n</code></pre>\n<p>As you can see, the <code>_M_payload</code> is actually strongly typed, so any alignment attributes should carry over properly in this implementation.</p>\n<hr>\n<p>The Boost implementation does not use a union. Instead, <code>boost::optional&lt;T&gt;</code> derives from <code>optional_base&lt;T&gt;</code>, which simply contains:</p>\n<pre><code> typedef aligned_storage&lt;T&gt; storage_type ;\n bool m_initialized ;\n storage_type m_storage ;\n</code></pre>\n<p>The name of <code>aligned_storage</code> is a clue; the <a href=\"http://www.boost.org/doc/libs/1_65_0/libs/type_traits/doc/html/boost_typetraits/reference/aligned_storage.html\" rel=\"nofollow noreferrer\">docs</a> don't mention that the second template argument is optional and defaults to -1, which means <code>boost::detail::max_align</code>, which means to use the alignment a union type containing a bunch of primitive types up to 128 bits in length. So (from a cursory reading) Boost seems to be a bit more pessimistic than GNU, but will also get your alignment right.</p>\n</hr>", "OwnerUserId": "14637", "PostTypeId": "2", "Id": "46038714", "Score": "2", "CreationDate": "2017-09-04T14:01:57.770", "LastActivityDate": "2017-09-04T14:01:57.770"}, "bq_ids": {"n4659": {"so_46038378_46038799_1": {"section_id": 5016, "quality": 0.8, "length": 8}}}, "46038378": {"CommentCount": "4", "ViewCount": "83", "CreationDate": "2017-09-04T13:42:24.060", "LastActivityDate": "2017-09-04T14:27:01.917", "Title": "Do std::optional and boost::optional respect alignment restrictions of the managed object?", "PostTypeId": "1", "Id": "46038378", "OwnerUserId": "4341534", "Body": "<p>If a class <code>T</code> has an alignment requirement, such as one specified by the <code>alignas</code> keyword, are <code>std::optional&lt;T&gt;</code> and <code>boost::optional&lt;T&gt;</code> guaranteed to respect said alignment?</p>\n<p>If they were simply wrapper classes for a <code>T</code> object and a <code>bool initialized</code>, then they would automatically align their <code>T</code> member as required, but the standard and boost documentation state that they can hold no object and deal well with expensive to construct objects. From this I understand that they don't simply contain a <code>T</code>. Rather, they seem to allocate a buffer upon which the <code>T</code> is constructed or destroyed manually. Therefore, the C++ language will not automatically align the buffer because it is not of type <code>T</code>.</p>\n<p>So, do <code>std::optional&lt;T&gt;</code> and <code>boost::optional&lt;T&gt;</code> properly align their managed <code>T</code> object? Do they also provide <code>optional&lt;T&gt;::operator new</code> and <code>optional&lt;T&gt;::operator new[]</code> that respect the alignment requirement?</p>\n", "Tags": "<c++><boost><c++1z><boost-optional><stdoptional>", "Score": "1", "AnswerCount": "2"}});