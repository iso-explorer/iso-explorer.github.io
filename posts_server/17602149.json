post_cb({"bq_ids": {"n4140": {"so_17602149_17602451_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5504}}, "n3337": {"so_17602149_17602451_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5290}}, "n4659": {"so_17602149_17602451_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 6938}}}, "17602451": {"Id": "17602451", "PostTypeId": "2", "Body": "<p>As others have written, there is no ambiguity because <code>Derived::f(int)</code> hides <code>Base::f(int)</code>. You were probably expecting this to be the case only in the absence of the <code>using</code> declaration:</p>\n<pre><code>using Base::f;\n</code></pre>\n<p>But hiding still applies. Paragraph 7.3.3/15 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_17602149_17602451_0\">When a <em>using-declaration</em> brings names from a base class into a derived class scope, <strong>member functions</strong> and\n  member function templates <strong>in the derived class override and/or hide member functions</strong> and member function\n  templates with the same name, <em>parameter-type-list</em> (8.3.5), <em>cv-qualification</em>, and <em>ref-qualifier</em> (if any) in a\n  base class <strong>(rather than conflicting)</strong>.</p>\n</blockquote>\n<p>It also provides an example quite similar to yours (see how the expression <code>p-&gt;f(1)</code> does not result in ambiguity, and <code>D::f</code> is picked instead):</p>\n<pre><code>struct B {\n    virtual void f(int);\n    virtual void f(char);\n    void g(int);\n    void h(int);\n};\n\nstruct D : B {\n    using B::f;\n    void f(int); // OK: D::f(int) overrides B::f(int);\n    using B::g;\n    void g(char); // OK\n    using B::h;\n    void h(int); // OK: D::h(int) hides B::h(int)\n};\n\nvoid k(D* p)\n{\n    p-&gt;f(1); // calls D::f(int)\n    p-&gt;f(\u2019a\u2019); // calls B::f(char)\n    p-&gt;g(1); // calls B::g(int)\n    p-&gt;g(\u2019a\u2019); // calls D::g(char)\n}\n</code></pre>\n", "LastActivityDate": "2013-07-11T20:04:32.857", "CommentCount": "2", "CreationDate": "2013-07-11T20:04:32.857", "ParentId": "17602149", "Score": "3", "OwnerUserId": "1932150"}, "17602236": {"Id": "17602236", "PostTypeId": "2", "Body": "<p>Because the static type of <code>d</code> is <code>Derived</code>, and <code>Derived::f(int)</code> <em>hides</em> <code>Base::f(int)</code>.</p>\n", "LastActivityDate": "2013-07-11T19:53:47.800", "CommentCount": "0", "CreationDate": "2013-07-11T19:53:47.800", "ParentId": "17602149", "Score": "1", "OwnerUserId": "241536"}, "17602149": {"ViewCount": "84", "Body": "<p>Why there's no ambiguity in the expression <code>d.f(1);</code> below in <code>main()</code> between <code>Base::f(int)</code> and <code>Derived::f(int)</code> ?</p>\n<pre><code>class Base\n{\n    public:\n    void f(int i) {}\n    void f(int i, int j) {}\n};\n\nclass Derived : public Base\n{\n    public:\n    using Base::f;\n    void f(int i) {}\n};\n\nint main()\n{\n    Derived d;\n    d.f(1);\n}\n</code></pre>\n", "AcceptedAnswerId": "17602451", "Title": "Why there's no ambiguity in the expression `d.f(1);` below in main()?", "CreationDate": "2013-07-11T19:48:41.513", "Id": "17602149", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-07-11T20:04:32.857", "Score": "2", "OwnerUserId": "1042389", "Tags": "<c++><ambiguous-call><using-declaration>", "AnswerCount": "3"}, "17602225": {"Id": "17602225", "PostTypeId": "2", "Body": "<p>The function in the derived class hides the function in the base class.<br>\nThis is called shadowing.</br></p>\n", "LastActivityDate": "2013-07-11T19:52:47.117", "CommentCount": "0", "CreationDate": "2013-07-11T19:52:47.117", "ParentId": "17602149", "Score": "2", "OwnerUserId": "34397"}});