post_cb({"14738430": {"LastActivityDate": "2013-02-06T20:44:58.217", "ParentId": "14738335", "OwnerDisplayName": "user2033018", "CommentCount": "5", "Score": "0", "Body": "<p>Draft n3485 indicates that if the compiler can unambiguously determine the return type it will allow for the lambda to not specify it.</p>\n", "Id": "14738430", "CreationDate": "2013-02-06T20:44:58.217", "PostTypeId": "2"}, "14738411": {"LastActivityDate": "2013-02-07T03:28:11.437", "LastEditorUserId": "103167", "ParentId": "14738335", "CommentCount": "2", "PostTypeId": "2", "Score": "6", "Body": "<p>The book accurately reflects the rules in draft n3290 of the Standard.  Perhaps your compiler implemented a different draft.</p>\n<p>In section 5.1.2p4, the draft reads</p>\n<blockquote>\n<p id=\"so_14738335_14738411_0\">If a <em>lambda-expression</em> does not include a <em>trailing-return-type</em>, it is\n  as if the <em>trailing-return-type</em> denotes the following type:</p>\n<ul>\n<li>if the <em>compound-statement</em> is of the form\n    <code>{</code> <em>attribute-specifier-seq</em><sub><em>opt</em></sub> <code>return</code> <em>expression</em> <code>;</code> <code>}</code>\n  the type of the returned expression after lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion;</li>\n<li>otherwise, void.</li>\n</ul>\n</blockquote>\n<p>The syntactic construct <em>attribute-specifier-seq</em> may be <code>alignas</code> or the double-bracketed attributes.  Not variable declarations.</p>\n<p>Draft n3485, which followed publication of C++11 (i.e. it is work in progress toward C++1y), contains the same wording.  I don't know if there was a different rule in some draft earlier than n3290.</p>\n", "Id": "14738411", "LastEditDate": "2013-02-07T03:28:11.437", "OwnerUserId": "103167", "CreationDate": "2013-02-06T20:43:41.023"}, "14738335": {"AcceptedAnswerId": "14738411", "Tags": "<c++><c++11><lambda><llvm><clang>", "CommentCount": "9", "OwnerUserId": "2015453", "Body": "<p>My book says this:</p>\n<blockquote>\n<p id=\"so_14738335_14738335_0\">Lambdas with function bodies that contain anything other than a single return statement that do not specify a return type return void.</p>\n</blockquote>\n<p>but this:</p>\n<pre><code>auto f = []{\n  int i=0; i++;\n  return std::string(\"foo\");\n};\nstd::cout &lt;&lt; f() &lt;&lt; std::endl;\n</code></pre>\n<p>actually compiles and prints out \"foo\", but that lambda expr has more than just a single return statement so it should return void, because it does not manually specify \"-&gt; std::string\" as a return type.</p>\n<p>What's going on here?</p>\n<p>I'm using Apple's compiler in the latest Xcode 4.6, based on Clang 3.2 it seems:</p>\n<p>clang --version</p>\n<p>Apple LLVM version 4.2 (clang-425.0.24) (based on LLVM 3.2svn)\nTarget: x86_64-apple-darwin12.2.0\nThread model: posix</p>\n", "Id": "14738335", "CreationDate": "2013-02-06T20:38:32.530", "ViewCount": "498", "LastActivityDate": "2017-09-30T13:52:17.750", "LastEditorUserId": "1033581", "PostTypeId": "1", "Title": "Is my book's discussion of lambda return types wrong?", "AnswerCount": "5", "Score": "13", "LastEditDate": "2017-09-30T13:52:17.750"}, "bq_ids": {"n4659": {"so_14738335_14738447_1": {"section_id": 7667, "quality": 0.6, "length": 9}}, "n3337": {"so_14738335_14738447_1": {"section_id": 5732, "quality": 0.8666666666666667, "length": 13}, "so_14738335_14738411_0": {"section_id": 5732, "quality": 1.0, "length": 8}, "so_14738335_14738447_0": {"section_id": 5732, "quality": 0.9333333333333333, "length": 14}}}, "16393291": {"LastActivityDate": "2013-05-06T06:39:17.317", "ParentId": "14738335", "Score": "1", "CommentCount": "0", "OwnerUserId": "1041090", "Body": "<p>Clang implements the proposed resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#975\" rel=\"nofollow\">C++ core issue 975</a>. That allows an arbitrary body for a lambda, with any number of return statements, and deduces the return value from the returned expression under the proviso that they must all produce the same type.</p>\n<p>In C++14, this support is generalized further by <a href=\"http://isocpp.org/files/papers/N3638.html\" rel=\"nofollow\">N3638</a>, which was voted into the working draft for the standard at the Bristol meeting of WG21.</p>\n", "Id": "16393291", "CreationDate": "2013-05-06T06:39:17.317", "PostTypeId": "2"}, "14738447": {"LastActivityDate": "2013-02-06T20:46:01.307", "ParentId": "14738335", "Score": "1", "CommentCount": "13", "OwnerUserId": "36565", "Body": "<p>I am not sure of what to make from the quote in the question, but here is what the C++11 standard says about lambdas without declarator or return type:</p>\n<blockquote>\n<p id=\"so_14738335_14738447_0\">If a lambda-expression does not include a lambda-declarator, it is as\n  if the lambda-declarator were (). If a lambda-expression does not\n  include a trailing-return-type, it is as if the trailing-return-type\n  denotes the following type (5.1.2p4):</p>\n<p id=\"so_14738335_14738447_1\">\u2014 if the compound-statement is of the form\n  { attribute-specifier-seqopt return expression ; } the type of the\n  returned expression after lvalue-to-rvalue conversion (4.1),\n  array-to-pointer conversion (4.2), and function-to-pointer conversion\n  (4.3); </p>\n<p id=\"so_14738335_14738447_2\">\u2014 otherwise, void.</p>\n</blockquote>\n", "Id": "14738447", "CreationDate": "2013-02-06T20:46:01.307", "PostTypeId": "2"}, "14738379": {"LastActivityDate": "2013-02-07T07:58:08.317", "LastEditorUserId": "453803", "ParentId": "14738335", "CommentCount": "5", "PostTypeId": "2", "Score": "3", "Body": "<p>If you use popular compilers (gcc, Visual Studio), you usually don't need to specify return type as long as the compiler is able to determine it unambiguously - like in your example.</p>\n<p>The following example shows a lambda, which requires explicit return type information:</p>\n<pre><code>auto lambda = [](bool b) -&gt; float\n    { \n        if (b) \n            return 5.0f; \n        else \n            return 6.0; \n    };\n</code></pre>\n<p>I asked Bjarne Stroustrup regarding this matter, his comment:</p>\n<p><code>I do not know if C++11 allows the deduction of the return type is there\u00a0are several return statements with identical return type. If not, that's\u00a0planned for C++14.</code></p>\n", "Id": "14738379", "LastEditDate": "2013-02-07T07:58:08.317", "OwnerUserId": "453803", "CreationDate": "2013-02-06T20:41:14.193"}});