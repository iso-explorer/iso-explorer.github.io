post_cb({"43363620": {"CreationDate": "2017-04-12T07:58:39.107", "ViewCount": "156", "Id": "43363620", "AcceptedAnswerId": "43364934", "Score": "2", "Title": "Should throw() function always unwind stack on exception and allow exception to be catched or std::terminate must be called?", "LastEditorUserId": "6483824", "CommentCount": "2", "Body": "<p>I am interested whether this is forced by standard and whether it is violated by some compiler. My observation is that:</p>\n<ul>\n<li>Visual Studio 2015/2017 (with /EHsc): stack in the throw() function is not unwound (d-tors are not called), but exception exits function and is being caught by try/catch. No std::terminate is called.</li>\n<li><p>gcc (6.3.0), stack in throw() function is unwound but then std::terminate is called (exception cannot be cought by try/catch). But with 7.0 (current HEAD), no stack is being unwound, std::termiante is called immediately.\nActually gcc 7.0 even warns of this : <code>warning: throw will always call terminate() [-Wterminate]</code> for <code>NoExceptFunctionWithObj2()</code>. It makes throw() behave as noexcept(true).</p></li>\n<li><p>clang, in all versions I have checked unwinds function stack (objects d-tors are called), and then std::terminate is called.</p></li>\n</ul>\n<p><a href=\"https://wandbox.org/permlink/MO3j3hGvTGnfyVws\" rel=\"nofollow noreferrer\">Test code:</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstruct TestDataWithoutNoexcept {\n  TestDataWithoutNoexcept() {\n    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \"\\n\";\n  }\n  ~TestDataWithoutNoexcept() {\n    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \"\\n\";\n  }\n  TestDataWithoutNoexcept(TestDataWithoutNoexcept const &amp; rhs) {\n    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \"\\n\";\n  }\n  TestDataWithoutNoexcept(TestDataWithoutNoexcept &amp;&amp; rhs) {\n    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \"\\n\";\n  }\n  TestDataWithoutNoexcept&amp; operator=(TestDataWithoutNoexcept const&amp; rhs) {\n    std::cout &lt;&lt; __FUNCTION__ &lt;&lt; \"\\n\";\n  }\n};\n\nvoid NoExceptFunctionWithObj1() noexcept {\n  TestDataWithoutNoexcept test;\n  throw std::runtime_error(\"NoExceptFunctionWithObj1 ex.\");\n}\n\nvoid NoExceptFunctionWithObj2() throw() {\n  TestDataWithoutNoexcept test;\n  throw std::runtime_error(\"NoExceptFunctionWithObj2 ex.\");\n}\n\nint main()\n{\n  // Now lets see whether stack is being unwound when exception is thrown in noexcept versus throw() function.\n  std::cout &lt;&lt; \"\\n See how dtors are called in noexcept or throw() functions\\n\";\n  try {\n    //NoExceptFunctionWithObj1();\n  }\n  catch (std::runtime_error&amp; ex) {\n    std::cout &lt;&lt; ex.what();\n  }\n\n  try {\n    NoExceptFunctionWithObj2();\n  }\n  catch (std::runtime_error&amp; ex) {\n    std::cout &lt;&lt; \"\\nShouldn't this be shown? : \" &lt;&lt; ex.what();\n  }\n}\n</code></pre>\n", "Tags": "<c++><c++11><c++14><c++1z>", "LastEditDate": "2017-04-12T08:12:29.800", "LastActivityDate": "2017-08-18T12:23:21.150", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "6483824"}, "43364934": {"LastActivityDate": "2017-08-18T12:23:21.150", "CommentCount": "4", "Body": "<p>Yes, <code>std::terminate</code> should be called. The <a href=\"http://eel.is/c++draft/\" rel=\"nofollow noreferrer\">latest published draft</a> of the standard says :</p>\n<p><strong>15.4 [except.spec], paragraph 12</strong></p>\n<blockquote>\n<p id=\"so_43363620_43364934_0\">An\n  exception-specification\n  is\n  non-throwing\n  if it is of the form\n  throw()\n  ,\n  noexcept\n  , or\n  noexcept(\n  constant-expression\n  )\n  where the\n  constant-\n  expression\n  yields\n  true\n  .</p>\n</blockquote>\n<p>Which means that <code>throw()</code> is strictly equivalent to <code>noexcept(true)</code>. <code>throw()</code> is deprecated in <code>C++17</code>.</p>\n<p><strong>15.5.1 [except.terminate]</strong></p>\n<blockquote>\n<p id=\"so_43363620_43364934_1\">when the search for a handler (15.3) encounters the outermost block of a function with a\n  noexcept-\n  specification\n  that does not allow the exception (15.4) [...] std::terminate()\n  is called (18.8.3). In the situation where no matching handler is found,\n  it is implementation-defined whether or not the stack is unwound before\n  std::terminate()\n  is called</p>\n</blockquote>\n<p>Not calling <code>std::terminate</code>means MSVC is not compliant.</p>\n<p>Regarding the handling of the stack, the compiler does what it wants about unwinding it or not in your example \u2014 this is specified to be <em>implementation-defined</em>.</p>\n<p>Historically (before C++11) stack unwinding in this situation was mandatory. However it turned out that the runtime cost of this enforced behaviour was too high and it was inhibiting the compiler to do some optimizations (even in the non-exception case). As a result, the compiler is now free to leave this out.</p>\n<p><strong>Edited after clarifications from @mike.</strong></p>\n", "CreationDate": "2017-04-12T09:00:24.760", "LastEditDate": "2017-08-18T12:23:21.150", "ParentId": "43363620", "Id": "43364934", "LastEditorUserId": "1885002", "PostTypeId": "2", "Score": "3", "OwnerUserId": "1714762"}, "bq_ids": {"n4140": {"so_43363620_43364934_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 3374}, "so_43363620_43364934_1": {"length": 15, "quality": 0.5172413793103449, "section_id": 3383}}, "n3337": {"so_43363620_43364934_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 3244}, "so_43363620_43364934_1": {"length": 15, "quality": 0.5172413793103449, "section_id": 3252}}}});