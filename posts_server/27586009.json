post_cb({"27586250": {"ParentId": "27586009", "CommentCount": "1", "Body": "<p>Where did you get that strange idea that <code>N</code> is \"absolutely NOT a compile-time constant\", as you state in the code comments?</p>\n<p>Since the beginning of times, a <code>const</code> integral object declared with an <em>integral constant expression</em> initializer by itself forms an <em>integral constant expression</em>. I.e. is a <em>compile-time constant</em> in C++.</p>\n<p>This applies equally to namespace declarations, local declarations and static class member declarations.</p>\n<p>(It would not be a compile-time constant in C. But it has always been a compile-time constant in C++.)</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "27586250", "Score": "6", "CreationDate": "2014-12-21T02:39:04.937", "LastActivityDate": "2014-12-21T02:39:04.937"}, "27586105": {"ParentId": "27586009", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>N4140 \u00a75.19 [expr.const]/p2, bullet 2.7.1, and p3:</p>\n<blockquote>\n<p id=\"so_27586009_27586105_0\">2 A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the\n  evaluation of <code>e</code>, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions:</p>\n<ul>\n<li>[...]</li>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to\n  <ul>\n<li>a non-volatile glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization,\n  initialized with a constant expression [ <em>Note</em>: a string literal\n  (2.14.5) corresponds to an array of such objects. \u2014<em>end note</em> ]</li>\n<li>a non-volatile glvalue that refers to a non-volatile object defined with <code>constexpr</code>, or that refers to a non-mutable sub-object of such an object, or</li>\n<li>a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began\n  within the evaluation of <code>e</code>;</li>\n</ul></li>\n<li>[...]</li>\n</ul>\n<p id=\"so_27586009_27586105_1\">3 An <em>integral constant expression</em> is an expression of integral or unscoped enumeration type, implicitly converted to a prvalue, where the converted expression is a core constant expression. [ <em>Note</em>: Such expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field lengths (9.6), as enumerator initializers if the underlying type is not fixed (7.2), and as alignments (7.6.2). \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>In your code, <code>N</code> is a \"non-volatile glvalue of integral or enumeration type\", it refers to a \"non-volatile const object with a preceding initialization\", so applying the lvalue-to-rvalue conversion to it does not prevent the expression from being a core constant expression despite the absence of <code>constexpr</code>.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-12-21T02:24:45.753", "Id": "27586105", "Score": "7", "CreationDate": "2014-12-21T02:02:09.977", "LastActivityDate": "2014-12-21T02:24:45.753"}, "27586106": {"ParentId": "27586009", "CommentCount": "6", "Body": "<p>A const int initialized with a literal is considered a constant expression</p>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">N1905 5.19</a></p>\n<blockquote>\n<p id=\"so_27586009_27586106_0\">An integral constant-expression can involve only literals of arithmetic types  enumerators, non-volatile <strong>const</strong> variables or static data members of integral or enumeration types <strong>initialized with constant expressions</strong></p>\n</blockquote>\n<p>Note the \"non-volatile,\" indicating your original code should have been rejected by g++.</p>\n", "OwnerUserId": "1013719", "PostTypeId": "2", "Id": "27586106", "Score": "1", "CreationDate": "2014-12-21T02:02:16.107", "LastActivityDate": "2014-12-21T02:02:16.107"}, "27586066": {"ParentId": "27586009", "CommentCount": "3", "Body": "<p>Well - N is constant during compilation so it is equivalent to</p>\n<p>int a[10]{};</p>\n", "OwnerUserId": "4381807", "PostTypeId": "2", "Id": "27586066", "Score": "1", "CreationDate": "2014-12-21T01:54:09.653", "LastActivityDate": "2014-12-21T01:54:09.653"}, "27586009": {"CommentCount": "8", "AcceptedAnswerId": "27586105", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2014-12-21T01:41:27.513", "LastActivityDate": "2014-12-21T02:59:59.753", "LastEditDate": "2014-12-21T02:59:59.753", "ViewCount": "221", "FavoriteCount": "2", "Title": "g++ compiles array with size given at runtime by const value (not constexpr)", "Id": "27586009", "Score": "3", "Body": "<p>Can someone clarify why is this legal C++ code? (Yes, I'm asking why my code works ;) )</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    const std::size_t N = 10; \n\n    int a[N]{}; // value-initialize it to get rid of annoying un-initialized warnings in the following line\n    std::cout &lt;&lt; a[5] &lt;&lt; std::endl; // got a zero \n}\n</code></pre>\n<p>The size of the array is declared as <code>const</code> (NOT <code>constexpr</code>), still the program compiles with no warnings (<code>-Wall</code>, <code>-Wextra</code>, <code>-Wpedantic</code>) in both g++ and clang++. I thought that the C++ standard explicitly specified that the size of the array should be a compile-time constant. It is absolutely not the case here. </p>\n", "Tags": "<c++><arrays><c++11>", "OwnerUserId": "3093378", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_27586009_27586105_1": {"section_id": 6186, "quality": 0.8055555555555556, "length": 29}, "so_27586009_27586105_0": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_27586009_27586105_1": {"section_id": 5947, "quality": 0.5277777777777778, "length": 19}}, "n4659": {"so_27586009_27586105_1": {"section_id": 7688, "quality": 0.7222222222222222, "length": 26}, "so_27586009_27586105_0": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}}}});