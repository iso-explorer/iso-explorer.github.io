post_cb({"37418655": {"ParentId": "37418412", "CommentCount": "2", "Body": "<p>From [basic.lval]:</p>\n<blockquote>\n<p id=\"so_37418412_37418655_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined:<br>\n  (10.1) \u2014 the dynamic type of the object,<br>\n  (10.2) \u2014 a cv-qualified version of the dynamic type of the object,<br>\n  (10.3) \u2014 a type similar (as defined in 4.4) to the dynamic type of the object,<br>\n  (10.4) \u2014 a type that is the signed or unsigned type corresponding to the dynamic type of the object,<br>\n  (10.5) \u2014 a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type\n  of the object,<br>\n  (10.6) \u2014 an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic\n  data members (including, recursively, an element or non-static data member of a subaggregate or\n  contained union),<br>\n  (10.7) \u2014 a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,<br>\n  (10.8) \u2014 a <code>char</code> or <code>unsigned char</code> type.</br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>You're attempting to access the stored value of a <code>uint8_t</code> through a glvalue of type <code>bool</code>. That fits none of those 8 categories, hence the behavior is undefined. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "37418655", "Score": "6", "CreationDate": "2016-05-24T16:04:59.797", "LastActivityDate": "2016-05-24T16:04:59.797"}, "bq_ids": {"n4140": {"so_37418412_37418655_0": {"section_id": 7239, "quality": 0.9101123595505618, "length": 81}}, "n3337": {"so_37418412_37418655_0": {"section_id": 6983, "quality": 0.9101123595505618, "length": 81}}, "n4659": {"so_37418412_37418655_0": {"section_id": 8748, "quality": 0.9101123595505618, "length": 81}}}, "37418412": {"CommentCount": "8", "ViewCount": "195", "PostTypeId": "1", "LastEditorUserId": "4108376", "CreationDate": "2016-05-24T15:52:26.907", "LastActivityDate": "2016-05-24T16:11:43.313", "Title": "Using reinterpret_cast with bool", "AcceptedAnswerId": "37418655", "LastEditDate": "2016-05-24T15:57:32.437", "Id": "37418412", "Score": "1", "Body": "<p>C++ automatically sets <code>bool</code> values to either <code>true</code> or <code>false</code>, even if the type actually holds a 1 byte value.</p>\n<p>So <code>bool(123) == true</code> is true, with</p>\n<pre><code>int i = 123;\nbool b = i;\nint j = b;\n</code></pre>\n<p><code>j</code> takes the value <code>1</code>.</p>\n<hr>\n<p>But does this remain the case when <code>reinterpret_cast</code> is used with <code>bool*</code> pointers? E.g.</p>\n<pre><code>static_assert(sizeof(bool) == 1, \"assuming sizeof(bool) is one in this example...\");\nstd::uint8_t i = 123;\nbool* b = reinterpret_cast&lt;bool*&gt;(&amp;i);\n\nint j = *b; // j becomes 1\nif(*b == true) ... // condition is true\n</code></pre>\n<p>Are these results guaranteed to be true, or is it undefined behavior. (i.e. can be compiled rely on the assumption that <code>bool</code> objects are already internally represented as <code>1</code> and <code>0</code>).</p>\n</hr>", "Tags": "<c++><boolean>", "OwnerUserId": "4108376", "AnswerCount": "1"}});