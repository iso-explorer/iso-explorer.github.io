post_cb({"bq_ids": {"n4140": {"so_44346513_44346749_0": {"length": 21, "quality": 1.0, "section_id": 328}}, "n3337": {"so_44346513_44346749_0": {"length": 21, "quality": 1.0, "section_id": 318}}, "n4659": {"so_44346513_44346749_0": {"length": 21, "quality": 1.0, "section_id": 336}}}, "44346749": {"Id": "44346749", "PostTypeId": "2", "Body": "<p>We are in partial-ordering land again. The type of the synthesized function template parameters are</p>\n<pre><code>T&amp;&amp;      // #1: not a forwarding reference\nconst T&amp; // #2\nU&amp;&amp;      // #3: a forwarding reference\n</code></pre>\n<p>The pre-partial ordering transformation <a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.partial#5\" rel=\"nofollow noreferrer\">strips away referenceness</a> and after that the <a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.partial#7\" rel=\"nofollow noreferrer\">top-level cv-qualification</a>, leaving us with a bare type in all three cases. It follows that in all three cases deduction succeeds in both directions. We are now left with <a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.partial#9\" rel=\"nofollow noreferrer\">[temp.deduct.partial]/9</a>'s tiebreaker:</p>\n<blockquote>\n<p id=\"so_44346513_44346749_0\">If, for a given type, deduction succeeds in both directions (i.e., the\n  types are identical after the transformations above) and both P and A\n  were reference types (before being replaced with the type referred to\n  above): </p>\n<ul>\n<li>if the type from the argument template was an lvalue\n  reference and the type from the parameter template was not, the\n  parameter type is not considered to be at least as specialized as the\n  argument type; otherwise,</li>\n<li>if the type from the argument template\n  is more cv-qualified than the type from the parameter template (as\n  described above), the parameter type is not considered to be at least\n  as specialized as the argument type.</li>\n</ul>\n</blockquote>\n<p>For <code>U&amp;&amp;</code> vs <code>T&amp;&amp;</code>, neither rule applies and there's no ordering. For <code>U&amp;&amp;</code> vs <code>const T&amp;</code>, however, the parameter type <code>U&amp;&amp;</code> is not considered to be at least as specialized as the argument type <code>const T&amp;</code>, per the first bullet.</p>\n<p>Partial ordering therefore finds #2 to be more specialized than #3, but finds #1 and #3 to be indistinguishable. GCC is correct.</p>\n<p>That said, this may well be an oversight in the partial ordering rules. Class template deduction is the first time we have a \"rvalue reference to cv-unqualified template parameter that isn't a forwarding reference\" thing. Previously, in double-reference cases, forwarding references will always lose to non-forwarding rvalue references at the second bullet (because the only way you get non-forwarding rvalue references is if you have <code>cv T&amp;&amp;</code> for some non-empty <code>cv</code>).</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2017-06-03T19:42:24.377", "Score": "7", "CreationDate": "2017-06-03T17:29:14.370", "ParentId": "44346513", "CommentCount": "5", "OwnerUserId": "2756719", "LastEditDate": "2017-06-03T19:42:24.377"}, "44346513": {"ViewCount": "154", "Body": "<p><a href=\"https://wandbox.org/permlink/JmuyUxQCy7MvoNO7\" rel=\"noreferrer\">gcc 8.0.0</a> and <a href=\"https://wandbox.org/permlink/ZzSYuRgTDpErfGK7\" rel=\"noreferrer\">clang 5.0.0</a> disagree on the behavior of this program:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct A {\n    A(const T&amp;) { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n    A(T&amp;&amp;)      { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n};\n\ntemplate &lt;typename U&gt; A(U&amp;&amp;) -&gt; A&lt;double&gt;;\n\nint main() {\n    int i = 0;\n    const int ci = 0;\n\n    A a1(0);  // both say A&lt;double&gt;\n    A a2(i);  // both say A&lt;double&gt;\n    A a3(ci); // gcc says A&lt;int&gt;, clang says A&lt;double&gt;\n}\n</code></pre>\n<p>gcc's behavior doesn't make sense to me - if the <code>const T&amp;</code> overload is preferred to the <code>U&amp;&amp;</code> overload for lvalue <code>const int</code>, why isn't the <code>T&amp;&amp;</code> overload preferred to the <code>U&amp;&amp;</code> overload for rvalue <code>int</code>? clang's makes more sense to me (none of the functions is more specialized than the other, so deduction guide wins). </p>\n<p>Who's right? </p>\n", "AcceptedAnswerId": "44346749", "Title": "Partial ordering of forwarding reference and normal reference with deduction guides", "CreationDate": "2017-06-03T17:05:45.830", "Id": "44346513", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-06-04T03:33:55.967", "LastEditorUserId": "2756719", "LastActivityDate": "2017-06-04T03:33:55.967", "Score": "8", "OwnerUserId": "2069064", "Tags": "<c++><templates><language-lawyer><c++1z><deduction-guide>", "AnswerCount": "1"}});