post_cb({"bq_ids": {"n4140": {"so_7694201_7716499_1": {"length": 50, "quality": 0.9615384615384616, "section_id": 123}}, "n3337": {"so_7694201_7716499_1": {"length": 50, "quality": 0.9615384615384616, "section_id": 117}}, "n4659": {"so_7694201_7716499_1": {"length": 50, "quality": 0.9615384615384616, "section_id": 127}}}, "7714597": {"Id": "7714597", "PostTypeId": "2", "Body": "<p>As mentioned above in a  comment, gcc is pretty weak on variadic template support to day. Especially when it comes to parameter pack expansions. Gcc 4.6 can not even expand packs into fixed length lists.</p>\n<p>The following code is a possible workaround that is based on a far more complex way of working around those limitations that I usually use. It will only compile on a very recent gcc from svn:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct derive : T\n{\n    template&lt;class... A&gt;\n    derive( A... a ) :\n        T(a...)\n    {\n    }\n};\n\ntemplate&lt;class X, class... T&gt;\nstruct deriver;\n\ntemplate&lt;class X&gt;\nstruct deriver&lt;X&gt; :\n    derive&lt;X&gt;\n{\n    template&lt;class... A&gt;\n    deriver( A... a ) :\n        derive&lt;X&gt;(a...)\n    {\n    }\n};\n\ntemplate&lt;class X, class... T&gt;\nstruct deriver : \n    derive&lt;X&gt;, deriver&lt;T...&gt;\n{\n    template&lt;class... A&gt;\n    deriver( A... a ) :\n        derive&lt;X&gt;(a...), deriver&lt;T...&gt;(a...)\n    {\n    }\n};\n\ntemplate&lt;class... __Policies&gt;\nclass GenericPolicyAdapter\n    : public deriver&lt;__Policies...&gt;\n{\npublic:\n    template&lt;class... __Args&gt;\n        GenericPolicyAdapter( __Args... args )\n            : deriver&lt;__Policies...&gt;( args...)\n        {}\n};\n\n#define BARK std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \"\\n\"\nstruct T1\n{\n    T1(int, int, int) {BARK;}\n};\n\nstruct T2\n{\n    T2(int, int, int) {BARK;}\n};\n\nint main()\n{\n    GenericPolicyAdapter&lt;T1,T2&gt; generic_policy_adapter( 1, 2, 3 );\n}\n</code></pre>\n<p>All released gccs will choke on this with: </p>\n<pre><code>sorry, unimplemented: cannot expand 'T ...' into a fixed-length argument list\n</code></pre>\n<p>which can possibly also worked around by even more indirection, but this should be a good starting point (depending on how much portability you want).</p>\n", "LastActivityDate": "2011-10-10T14:51:44.927", "CommentCount": "0", "CreationDate": "2011-10-10T14:51:44.927", "ParentId": "7694201", "Score": "0", "OwnerUserId": "833362"}, "7694201": {"ViewCount": "7142", "Body": "<p>I'm trying to create a class that inherits from multiple classes (as defined by a variadic template) and, for each class, passes the same parameter pack of args to the constructor of each class. However, it seems as though I'm not able to unpack both the variadic template of classes and the parameter pack of args.</p>\n<p>I have a class:</p>\n<pre><code>template&lt;class... __Policies&gt;\nclass GenericPolicyAdapter : public __Policies...{\n</code></pre>\n<p>With constructor:</p>\n<pre><code>template&lt;class... __Args&gt;\nGenericPolicyAdapter( __Args... args ) : __Policies( args... ){\n</code></pre>\n<p>and test:</p>\n<pre><code>GenericPolicyAdapter&lt;T1,T2&gt; generic_policy_adapter( arg1, arg2, arg3 );\n</code></pre>\n<p>gcc fails with:</p>\n<pre><code>error: type \u2018__Policies\u2019 is not a direct base of \u2018GenericPolicyAdapter&lt;T1,T2&gt;\u2019\n</code></pre>\n<p>where <code>__Policies = T1, T2</code></p>\n<p>To clarify, I'm essentially trying to do:</p>\n<pre><code>GenericPolicyAdapter : public T1, public T2\n{\n  public:\n    template&lt;class... __Args&gt;\n    GenericPolicyAdapter( __Args... args ) : T1( args... ), T2( args... ){}\n};\n</code></pre>\n<p>but with <code>T1</code> and <code>T2</code> deduced from <code>__Policies</code></p>\n<p>Any ideas? It seems like gcc is treating <code>__Policies</code> as a single type rather than a list of types. Thanks in advance!</p>\n<hr>\n<p>Edit:</p>\n<p>I should clarify that I'm using gcc/g++ 4.4.5.</p>\n<p>The suggestion by Howard Hinnant was to do:</p>\n<pre><code>template&lt;class... __Args&gt;\n    GenericPolicyAdapter( __Args... args )\n        : __Policies( args...)...\n    {}\n</code></pre>\n<p>However, with gcc/g++ 4.4.5, this gives <code>invalid use of pack expansion expression</code>. It's great that this works in OSX/clang but is there a way to do this in gcc/g++?</p>\n</hr>", "Title": "Unpacking parameter pack of args into the constructor of each class defined in a variadic template", "CreationDate": "2011-10-08T01:25:23.370", "LastActivityDate": "2011-11-30T18:35:16.913", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-10-09T20:18:16.957", "LastEditorUserId": "984862", "Id": "7694201", "Score": "4", "OwnerUserId": "984862", "Tags": "<c++><c++11><variadic-templates>", "AnswerCount": "3"}, "7716499": {"Id": "7716499", "PostTypeId": "2", "Body": "<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p>\n<blockquote>\n<p id=\"so_7694201_7716499_0\">14.5.3 Variadic templates \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 [temp.variadic]</p>\n<p id=\"so_7694201_7716499_1\">5  \u00a0  \u00a0 A parameter pack whose name appears within the pattern of a pack expansion is expanded by that pack expansion. <strong>An appearance of the name of a parameter pack is only expanded by the innermost enclosing pack expansion. The pattern of a pack expansion shall name one or more parameter packs that are not expanded by a nested pack expansion.</strong> All of the parameter packs expanded by a pack expansion shall have the same number of arguments specified. An appearance of a name of a parameter pack that is not expanded is ill-formed. [ Example:</p>\n<pre><code>template&lt;typename...&gt; struct Tuple {};\ntemplate&lt;typename T1, typename T2&gt; struct Pair {};\n\ntemplate&lt;class ... Args1&gt; struct zip {\n  template&lt;class ... Args2&gt; struct with {\n    typedef Tuple&lt;Pair&lt;Args1, Args2&gt; ... &gt; type;\n  };\n};\n\ntypedef zip&lt;short, int&gt;::with&lt;unsigned short, unsigned&gt;::type T1;\n    // T1 is Tuple&lt;Pair&lt;short, unsigned short&gt;, Pair&lt;int, unsigned&gt;&gt;\ntypedef zip&lt;short&gt;::with&lt;unsigned short, unsigned&gt;::type T2;\n    // error: different number of arguments specified for Args1 and Args2\n\ntemplate&lt;class ... Args&gt; void g(Args ... args) {\n  f(const_cast&lt;const Args*&gt;(&amp;args)...); // OK: \u201cArgs\u201d and \u201cargs\u201d are expanded\n  f(5 ...); // error: pattern does not contain any parameter packs\n  f(args); // error: parameter pack \u201cargs\u201d is not expanded\n  f(h(args ...) + args ...); // OK: first \u201cargs\u201d expanded within h, second\n  // \u201cargs\u201d expanded within f\n}\n</code></pre>\n<p id=\"so_7694201_7716499_2\">\u2014end example ]</p>\n</blockquote>\n<p>I think that <code>f(h(args ...) + args ...);</code> might be the closest standardese example you will get.</p>\n<p>Note that if you had done:</p>\n<pre><code>template&lt;class... __Policies&gt;\nclass GenericPolicyAdapter\n    : public __Policies...\n{\npublic:\n    template&lt;class... __Args&gt;\n        GenericPolicyAdapter( __Args... args )\n            : __Policies(args)... // See the missing '...' ?\n        {}\n};\n</code></pre>\n<p>You would have pulled a single arg of the constructor parameter list, and applied them in order to the base constructors.  The key is to expand <code>__Policies</code> after you expand <code>args</code>.</p>\n", "LastActivityDate": "2011-10-10T17:34:44.273", "CommentCount": "2", "CreationDate": "2011-10-10T17:34:44.273", "ParentId": "7694201", "Score": "6", "OwnerUserId": "985032"}, "7694253": {"Id": "7694253", "PostTypeId": "2", "Body": "<p>\"<code>...</code>\" is a lot like \"<code>typename</code>\".  You just have to keep aggressively sprinkling it around until things compile. :-)</p>\n<pre><code>template&lt;class... __Policies&gt;\nclass GenericPolicyAdapter\n    : public __Policies...\n{\npublic:\n    template&lt;class... __Args&gt;\n        GenericPolicyAdapter( __Args... args )\n            : __Policies( args...)...\n        {}\n};\n\nstruct T1\n{\n    T1(int, int, int) {}\n};\n\nstruct T2\n{\n    T2(int, int, int) {}\n};\n\nint main()\n{\n    GenericPolicyAdapter&lt;T1,T2&gt; generic_policy_adapter( 1, 2, 3 );\n}\n</code></pre>\n", "LastEditorUserId": "500104", "LastActivityDate": "2011-11-30T18:35:16.913", "Score": "16", "CreationDate": "2011-10-08T01:37:36.777", "ParentId": "7694201", "CommentCount": "10", "OwnerUserId": "576911", "LastEditDate": "2011-11-30T18:35:16.913"}});