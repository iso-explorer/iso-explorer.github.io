post_cb({"36533642": {"ParentId": "36533199", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Better way would be to create your own function that make use of <code>std::to_string</code> if it's possible as well as the <code>.toString()</code> method whenever it's available for passed argument:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstruct MyClass {\n   std::string toString() const { return \"MyClass\"; }\n};\n\ntemplate&lt;class T&gt;\ntypename std::enable_if&lt;std::is_same&lt;decltype(std::declval&lt;const T&amp;&gt;().toString()), std::string&gt;::value, std::string&gt;::type my_to_string(const T &amp;t) {\n    return t.toString();\n}\n\ntemplate&lt;class T&gt;\ntypename std::enable_if&lt;std::is_same&lt;decltype(std::to_string(std::declval&lt;T&amp;&gt;())), std::string&gt;::value, std::string&gt;::type my_to_string(const T &amp;t) {\n    return std::to_string(t);\n}\n\nint main() {\n   std::cout &lt;&lt; my_to_string(MyClass()) &lt;&lt; std::endl; // will invoke .toString\n   std::cout &lt;&lt; my_to_string(1) &lt;&lt; std::endl; //will invoke std::to_string\n}\n</code></pre>\n", "OwnerUserId": "4324224", "LastEditorUserId": "4324224", "LastEditDate": "2016-04-10T18:30:01.440", "Id": "36533642", "Score": "7", "CreationDate": "2016-04-10T18:17:21.827", "LastActivityDate": "2016-04-10T18:30:01.440"}, "36533238": {"ParentId": "36533199", "CommentCount": "7", "Body": "<p>If I'm not mistaken you can simply overload <code>to_string</code> for a generic type:</p>\n<pre><code>template&lt;typename T&gt; to_string(const T&amp; _x) {\n    return _x.toString();\n}\n</code></pre>\n<p>and this allows use of ADL (argument dependent lookup) by your program to correctly choose the relevant <code>to_string</code> method based upon the type passed.</p>\n", "OwnerUserId": "5508296", "PostTypeId": "2", "Id": "36533238", "Score": "9", "CreationDate": "2016-04-10T17:42:32.673", "LastActivityDate": "2016-04-10T17:42:32.673"}, "36533199": {"CommentCount": "0", "AcceptedAnswerId": "36533280", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2016-04-10T17:38:54.960", "LastActivityDate": "2017-01-23T08:09:37.413", "LastEditDate": "2017-01-23T08:09:37.413", "ViewCount": "2038", "FavoriteCount": "1", "Title": "Is specialization of std::to_string for custom types allowed by the C++ standard?", "Id": "36533199", "Score": "29", "Body": "<p>In C++11 and later, is it allowed to specialize <code>std::to_string</code> in the <code>std</code> namespace for custom types?</p>\n<pre><code>namespace std {\nstring to_string(::MyClass const &amp; c) { return c.toString(); }\n}\n</code></pre>\n<p>Sample use-case:</p>\n<pre><code>int main() {\n    MyClass c;\n    std::cout &lt;&lt; std::to_string(c) &lt;&lt; std::endl;\n}\n</code></pre>\n", "Tags": "<c++><c++11><std><tostring><specialization>", "OwnerUserId": "3919155", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36533199_36533280_2": {"section_id": 6299, "quality": 0.6521739130434783, "length": 15}, "so_36533199_36533280_6": {"section_id": 6300, "quality": 1.0, "length": 7}, "so_36533199_36533280_7": {"section_id": 6300, "quality": 1.0, "length": 9}, "so_36533199_36533280_8": {"section_id": 6300, "quality": 1.0, "length": 10}, "so_36533199_36533280_1": {"section_id": 6299, "quality": 0.5333333333333333, "length": 8}, "so_36533199_36533280_9": {"section_id": 6300, "quality": 1.0, "length": 17}}, "n3337": {"so_36533199_36533280_2": {"section_id": 6056, "quality": 0.6521739130434783, "length": 15}, "so_36533199_36533280_6": {"section_id": 6057, "quality": 1.0, "length": 7}, "so_36533199_36533280_7": {"section_id": 6057, "quality": 1.0, "length": 9}, "so_36533199_36533280_8": {"section_id": 6057, "quality": 1.0, "length": 10}, "so_36533199_36533280_1": {"section_id": 6056, "quality": 0.5333333333333333, "length": 8}, "so_36533199_36533280_9": {"section_id": 6057, "quality": 1.0, "length": 17}}, "n4659": {"so_36533199_36533280_2": {"section_id": 7808, "quality": 0.6521739130434783, "length": 15}, "so_36533199_36533280_6": {"section_id": 7809, "quality": 1.0, "length": 7}, "so_36533199_36533280_7": {"section_id": 7809, "quality": 1.0, "length": 9}, "so_36533199_36533280_8": {"section_id": 7809, "quality": 1.0, "length": 10}, "so_36533199_36533280_1": {"section_id": 7808, "quality": 0.5333333333333333, "length": 8}, "so_36533199_36533280_9": {"section_id": 7809, "quality": 1.0, "length": 17}}}, "36533280": {"ParentId": "36533199", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_36533199_36533280_0\">In C++11 and later, is it allowed to specialize std::to_string in the std namespace for custom types?</p>\n</blockquote>\n<p>No. First of all, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/to_string\" rel=\"noreferrer\">it is not a template function</a> so you can't specialize it at all.</p>\n<p>If you're asking about adding your own overload functions the answer still remains the same.</p>\n<p>Documentation snippet from <a href=\"http://en.cppreference.com/w/cpp/language/extending_std\" rel=\"noreferrer\">Extending the namespace std</a>:</p>\n<blockquote>\n<p id=\"so_36533199_36533280_1\">It is undefined behavior to add declarations or definitions to namespace std or to any namespace nested within std, with a few exceptions noted below</p>\n<p id=\"so_36533199_36533280_2\">It is allowed to add template specializations for any standard library template to the namespace std only if the declaration depends on a user-defined type and the specialization satisfies all requirements for the original template, except where such specializations are prohibited.</p>\n</blockquote>\n<hr>\n<p>In practice everything will probably work just fine but strictly speaking the standard says there is no guarantee of what will happen.</p>\n<hr>\n<p>Edit: I don't have access to the official standard so the following is from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"noreferrer\">free working draft (N4296)</a>:</p>\n<blockquote>\n<p id=\"so_36533199_36533280_3\"><strong>17.6.4.2</strong> Namespace use</p>\n<p id=\"so_36533199_36533280_4\"><strong>17.6.4.2.1</strong> Namespace std</p>\n<ol>\n<li>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a\n  namespace within namespace std unless otherwise specified. A program may add a template specialization\n  for any standard library template to namespace std only if the declaration depends on a user-defined type\n  and the specialization meets the standard library requirements for the original template and is not explicitly\n  prohibited.<sup>181</sup></li>\n<li><p id=\"so_36533199_36533280_5\">The behavior of a C++ program is undefined if it declares</p>\n<p id=\"so_36533199_36533280_6\">2.1 \u2014 an explicit specialization of any member function of a standard library class template, or</p>\n<p id=\"so_36533199_36533280_7\">2.2 \u2014 an explicit specialization of any member function template of a standard library class or class template,\n  or</p>\n<p id=\"so_36533199_36533280_8\">2.3 \u2014 an explicit or partial specialization of any member class template of a standard library class or class\n  template.</p>\n<p id=\"so_36533199_36533280_9\">A program may explicitly instantiate a template defined in the standard library only if the declaration\n  depends on the name of a user-defined type and the instantiation meets the standard library requirements\n  for the original template.</p></li>\n<li>A translation unit shall not declare namespace std to be an inline namespace (7.3.1).</li>\n</ol>\n</blockquote>\n</hr></hr>", "OwnerUserId": "4505712", "LastEditorUserId": "4505712", "LastEditDate": "2016-04-10T18:46:31.620", "Id": "36533280", "Score": "28", "CreationDate": "2016-04-10T17:46:05.653", "LastActivityDate": "2016-04-10T18:46:31.620"}});