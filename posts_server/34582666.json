post_cb({"34582686": {"ParentId": "34582666", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Almost.</p>\n<blockquote>\n<p id=\"so_34582666_34582686_0\"><code>[C++14: 24.2.5/6]:</code> <em>[..]</em> In containers that support equivalent keys, elements with equivalent keys are adjacent to each other in the iteration order of the container. Thus, although <strong>the absolute order of elements in an unordered container is not specified</strong>, its elements are grouped into equivalent-key groups such that all elements of each group have equivalent keys. <strong>Mutating operations on unordered containers shall preserve the relative order of elements within each equivalent-key group unless otherwise specified.</strong></p>\n<p id=\"so_34582666_34582686_1\"><code>[C++14: 24.2.5/9]:</code> <em>[..]</em> <strong>For unordered_multiset and unordered_multimap, rehashing preserves the relative ordering of equivalent elements.</strong></p>\n</blockquote>\n<p>It's pretty awkward wording but, from what I can tell, the general notion is that the order of elements underneath equivalent keys is unspecified, though it at least pretty much stays the same afterwards.</p>\n<p>So:</p>\n<p><strong>You can't rely on insertion order, but you can probably rely on a stable order if you're careful.</strong></p>\n<p>This is in contrast with the ordered associative containers:</p>\n<blockquote>\n<p id=\"so_34582666_34582686_2\"><code>[C++14: 23.2.4/4]:</code> <strong>For multiset and multimap, insert, emplace, and erase preserve the relative ordering of equivalent elements.</strong></p>\n</blockquote>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2016-01-03T23:12:23.000", "Id": "34582686", "Score": "8", "CreationDate": "2016-01-03T23:08:38.577", "LastActivityDate": "2016-01-03T23:12:23.000"}, "34582708": {"ParentId": "34582666", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>std::unordered_multimap</code> is neither ordered (obviously) nor <em>stable</em>.  So the order you put equivalent elements into the <code>std::unordered_multimap</code> are in no way guaranteed to be consistent by the standard.</p>\n", "OwnerUserId": "1312406", "LastEditorUserId": "1312406", "LastEditDate": "2016-01-03T23:13:17.337", "Id": "34582708", "Score": "1", "CreationDate": "2016-01-03T23:11:10.817", "LastActivityDate": "2016-01-03T23:13:17.337"}, "34582666": {"CommentCount": "1", "ViewCount": "281", "CreationDate": "2016-01-03T23:05:52.883", "LastActivityDate": "2016-01-03T23:13:17.337", "Title": "Can I rely on the order of an unordered map?", "AcceptedAnswerId": "34582686", "PostTypeId": "1", "Id": "34582666", "Score": "9", "Body": "<p>I have an <code>std::unordered_multimap</code> and I want to get the last inserted element of a specific key. I observed this behaviour:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nint main() {\n    unordered_multimap&lt;string, string&gt; mmap;\n\n    mmap.emplace(\"a\", \"first\");\n    mmap.emplace(\"a\", \"second\");\n    mmap.emplace(\"a\", \"last\");\n    mmap.emplace(\"b\", \"1\");\n    mmap.emplace(\"b\", \"2\");\n    mmap.emplace(\"b\", \"3\");\n\n    auto last_a = mmap.equal_range(\"a\").first;\n    auto last_b = mmap.equal_range(\"b\").first;\n\n    cout &lt;&lt; last_a-&gt;second &lt;&lt; endl;\n    cout &lt;&lt; last_b-&gt;second &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>This code outputs:</p>\n<pre><code>last\n3\n</code></pre>\n<p>This is, at least, on GCC, the behaviour I want. Can I rely on this? Does the standard say simething about the order the <code>std::unordered_multimap</code> store things? If not, what would be the best alternative?</p>\n", "Tags": "<c++><c++11><gcc><language-lawyer><multimap>", "OwnerUserId": "2104697", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34582666_34582686_1": {"section_id": 761, "quality": 0.7272727272727273, "length": 8}, "so_34582666_34582686_0": {"section_id": 758, "quality": 0.9411764705882353, "length": 48}, "so_34582666_34582686_2": {"section_id": 740, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_34582666_34582686_1": {"section_id": 748, "quality": 0.7272727272727273, "length": 8}, "so_34582666_34582686_0": {"section_id": 746, "quality": 0.9411764705882353, "length": 48}, "so_34582666_34582686_2": {"section_id": 729, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_34582666_34582686_1": {"section_id": 821, "quality": 0.7272727272727273, "length": 8}, "so_34582666_34582686_0": {"section_id": 818, "quality": 0.9215686274509803, "length": 47}, "so_34582666_34582686_2": {"section_id": 798, "quality": 0.7692307692307693, "length": 10}}}});