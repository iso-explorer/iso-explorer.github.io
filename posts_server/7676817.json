post_cb({"7676866": {"ParentId": "7676817", "CommentCount": "3", "Body": "<p>C++ enums are not type-safe. You can, as you say, ram any value down an enums throat. This feature is not implementation dependent, it is enshrined in the standard.</p>\n<p>C++11 introduces <a href=\"http://en.wikipedia.org/wiki/C++0x#Strongly_typed_enumerations\" rel=\"noreferrer\">strongly-typed enumerations</a> which are declared with a different syntax so as not to break your old code with type unsafe enumerations.</p>\n", "OwnerUserId": "505088", "PostTypeId": "2", "Id": "7676866", "Score": "8", "CreationDate": "2011-10-06T15:42:58.447", "LastActivityDate": "2011-10-06T15:42:58.447"}, "7676940": {"ParentId": "7676817", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>An enum is <em>guaranteed</em> to hold any value in the range between its smallest defined value and its largest, and is unspecified on how it handles numbers outside the range.</p>\n<blockquote>\n<p id=\"so_7676817_7676940_0\">\u00a77.2/3<br>\n  ...if not explicitly specified, the underlying type of a\n  scoped enumeration type is int.\"    </br></p>\n<p id=\"so_7676817_7676940_1\">\u00a7 7.2/7<br>\n  ...for an enumeration where emin is the smallest enumerator and emax\n  is the largest, the values of the enumeration are the values in the\n  range bmin to bmax, defined as follows: Let K be 1 for a two\u2019s\n  complement representation and 0 for a one\u2019s complement or\n  sign-magnitude representation. bmax is the smallest value greater than\n  or equal to max(|emin| \u2212 K, |emax|) and equal to 2M \u2212 1, where M is a\n  non-negative integer. bmin is zero if emin is non-negative and \u2212(bmax\n  + K) otherwise. The size of the smallest bit-field large enough to\n  hold all the values of the enumeration type is max(M, 1) if bmin is\n  zero and M + 1 otherwise.</br></p>\n<p id=\"so_7676817_7676940_2\">\u00a7 7.2/10<br>\n  An expression of arithmetic or enumeration type can be converted to an\n  enumeration type explicitly. The value is unchanged if it is in the\n  range of enumeration values of the enumeration type; otherwise the\n  resulting enumeration value is unspecified.</br></p>\n</blockquote>\n<p>Also note that <code>testEnum e();</code> declares a function that returns a <code>testEnum</code>  This is caused by the <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"nofollow noreferrer\">Most Vexing Parse</a>.  Not sure why GCC decided that equaled one (maybe it got coerced into a pointer-&gt;bool somehow?)  <code>testEnum e = testEnum();</code> is a valid statement which default-initializes an <code>testEnum</code>, which for primitives (and apparently <code>enums</code>) means setting them to zero.</p>\n<p>Note that this does not mean that enumerations may not take values outside of their defined range; as noted in footnote 96 of N4296:</p>\n<blockquote>\n<p id=\"so_7676817_7676940_3\">This set of values is used to define promotion and conversion semantics for the enumeration type. It does not preclude an\n  expression of enumeration type from having a value that falls outside this range.</p>\n</blockquote>\n<p>I should also mention that it isn't particularly complicated to make a typesafe enum in C++03, there's just a few wierd tricks to it.  <a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Safe_Enum\" rel=\"nofollow noreferrer\">http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Safe_Enum</a> shows one way.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "4850040", "LastEditDate": "2016-01-28T16:24:40.360", "Id": "7676940", "Score": "8", "CreationDate": "2011-10-06T15:48:04.947", "LastActivityDate": "2016-01-28T16:24:40.360"}, "7676817": {"CommentCount": "1", "AcceptedAnswerId": "7676940", "CreationDate": "2011-10-06T15:40:30.180", "LastActivityDate": "2016-01-28T16:24:40.360", "PostTypeId": "1", "ViewCount": "7914", "FavoriteCount": "3", "Title": "Forcing improper enum values?", "Id": "7676817", "Score": "6", "Body": "<p>I came across some unusual (to me at least...) behavior with C++'s enums.  I've tried the following in Visual Studio 2008 and g++ version 4.4.3</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nenum testEnum\n{\n    // no zero enum\n    one = 1,\n    two = 2,\n    three = 3\n};\n\nint main(int argc, char *argv[])\n{\n    testEnum e;  // undefined value (may be zero, but thats just luck)\n    cout &lt;&lt; \"Uninitialized enum e = \" &lt;&lt; e &lt;&lt; endl;\n\n    /*\n        testEnum e2(0);  // error converting from int to enum\n    */\n\n    testEnum e3(testEnum(0)); // forces zero !?!!?!?\n    cout &lt;&lt; \"zero enum e3 = \" &lt;&lt; e3 &lt;&lt; endl;  // prints '0'\n\n    testEnum e4(testEnum(9999)); // forces 9999 ?!?!?!?!\n    cout &lt;&lt; \"9999 enum e4 = \" &lt;&lt; e4 &lt;&lt; endl; // prints '9999'\n\n    return 0;\n}\n</code></pre>\n<p>The undefined value for e is as I expected, and I understand why you can't convert from an int to an enum (but you can go the other way).</p>\n<p>I'm curious as to how the last two enums (e3 and e4) are allowed to compile and attain any value you want to  give them.</p>\n<p>Also, I found that this:</p>\n<pre><code>testEnum e();\n</code></pre>\n<p>Compiled in both studio and linux, and cout-ing in linux yielded '1' but in studio I got a linker error:</p>\n<pre><code>main.obj : error LNK2001: unresolved external symbol \"enum testEnum __cdecl e2(void)\"\n</code></pre>\n<p>In studio, I could do:</p>\n<pre><code>testEnum e = testEnum();\n</code></pre>\n<p>But cout-ing it yielded '0' not '1'</p>\n<p>So my main question is how you can ram any value down an enum's throat like e3 and e4 in the above example.  And if this is implementation dependent or not.</p>\n", "Tags": "<c++><enums>", "OwnerUserId": "121546", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_7676817_7676940_2": {"section_id": 6036, "quality": 0.6521739130434783, "length": 15}, "so_7676817_7676940_1": {"section_id": 5467, "quality": 0.7543859649122807, "length": 43}, "so_7676817_7676940_3": {"section_id": 5467, "quality": 0.9473684210526315, "length": 18}, "so_7676817_7676940_0": {"section_id": 5464, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_7676817_7676940_2": {"section_id": 5804, "quality": 0.6521739130434783, "length": 15}, "so_7676817_7676940_0": {"section_id": 5251, "quality": 0.8888888888888888, "length": 8}, "so_7676817_7676940_3": {"section_id": 5253, "quality": 0.9473684210526315, "length": 18}, "so_7676817_7676940_1": {"section_id": 5253, "quality": 0.7543859649122807, "length": 43}}, "n4659": {"so_7676817_7676940_2": {"section_id": 7535, "quality": 0.6521739130434783, "length": 15}, "so_7676817_7676940_0": {"section_id": 6898, "quality": 0.6666666666666666, "length": 6}, "so_7676817_7676940_3": {"section_id": 6901, "quality": 0.9473684210526315, "length": 18}, "so_7676817_7676940_1": {"section_id": 6901, "quality": 0.7543859649122807, "length": 43}}}, "7676928": {"ParentId": "7676817", "CommentCount": "0", "Body": "<p>Enum it's just a memory, usually it's implemented as int while the compiler should force you to only assign them the correct values. But no compiler is perfect.. Those cases you presented should not be valid (undef).</p>\n", "OwnerUserId": "672689", "PostTypeId": "2", "Id": "7676928", "Score": "0", "CreationDate": "2011-10-06T15:47:21.947", "LastActivityDate": "2011-10-06T15:47:21.947"}});