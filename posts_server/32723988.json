post_cb({"32723988": {"CommentCount": "3", "AcceptedAnswerId": "32724096", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-09-22T18:13:04.750", "LastActivityDate": "2015-09-22T18:33:23.200", "LastEditDate": "2015-09-22T18:21:10.233", "ViewCount": "130", "FavoriteCount": "0", "Title": "alias of class template", "Id": "32723988", "Score": "3", "Body": "<p>Consider an alias template like the <code>A</code> in the code below. Now let <code>B</code> be an alias template of <code>A</code>.</p>\n<p>In the code below these class templates are used as template arguments for a struct <code>C</code> which is only specialized for one typename (<code>A</code>). <code>clang -std=c++11</code> exists with <code>error: implicit instantiation of undefined template 'C&lt;B&gt;'</code> indicating that another specialization for <code>B</code> is needed.</p>\n<pre><code>template&lt;int N&gt;\nusing A = int;\n\ntemplate&lt;int N&gt;\nusing B = A&lt;N&gt;;\n\ntemplate&lt;template&lt;int&gt; class I&gt;\nstruct C;\n\ntemplate&lt;&gt;\nstruct C&lt;A&gt; {};\n\nint main() {\n  C&lt;A&gt; c;\n  C&lt;B&gt; d; // clang error: implicit instantiation\n}\n</code></pre>\n<p>Why (if even) is it that - despite not allowing specializations of aliases - <code>A</code> and <code>B</code> are treated as different class templates? Is there a workaround allowing me to rename a lengthy template without incurring this problem?</p>\n", "Tags": "<c++><templates><c++11><typedef>", "OwnerUserId": "3139931", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32723988_32724096_1": {"section_id": 166, "quality": 1.0, "length": 17}}, "n3337": {"so_32723988_32724096_1": {"section_id": 160, "quality": 1.0, "length": 17}}, "n4659": {"so_32723988_32724096_1": {"section_id": 170, "quality": 1.0, "length": 17}}}, "32724096": {"ParentId": "32723988", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1286\" rel=\"nofollow\">CWG issue #1286</a>, which deals with this example:</p>\n<blockquote id=\"so_32723988_32724096_0\">\n<pre><code>template&lt;template&lt;class&gt; class TT&gt; struct X { };\ntemplate&lt;class&gt; struct Y { };\ntemplate&lt;class T&gt; using Z = Y&lt;T&gt;;\nX&lt;Y&gt; y;\nX&lt;Z&gt; z;\n</code></pre>\n</blockquote>\n<p>questioning whether or not <code>y</code> and <code>z</code> have the same type.</p>\n<p>Basically, according to the Standard, clang is correct in rejecting the code. All [temp.alias] tells us is:</p>\n<blockquote>\n<p id=\"so_32723988_32724096_1\">When a <em>template-id</em> refers to the <strong>specialization of an alias template</strong>, it is equivalent to the associated type\n  obtained by substitution of its <em>template-argument</em>s for the <em>template-parameter</em>s in the <em>type-id</em> of the alias\n  template.</p>\n</blockquote>\n<p>So while <code>A&lt;X&gt;</code> is equivalent to <code>B&lt;X&gt;</code> (for all <code>X</code>!), there is no wording that <code>A</code> is equivalent to <code>B</code>. But on some level that doesn't really make any sense since <code>B</code> and <code>A</code> <em>should be</em> equivalent. There is a proposed resolution that would make them so, but it has not yet been approved. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-09-22T18:33:23.200", "Id": "32724096", "Score": "3", "CreationDate": "2015-09-22T18:19:45.457", "LastActivityDate": "2015-09-22T18:33:23.200"}});