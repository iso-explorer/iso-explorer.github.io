post_cb({"3267636": {"ParentId": "3142630", "CommentCount": "0", "Body": "<p>There are tricky rules for how string literal concatenation interacts with escape sequences.\nSuppose you have</p>\n<pre><code>const char x1[] = \"a\\15\" \"4\";\nconst char y1[] = \"a\\154\";\nconst char x2[] = \"a\\r4\";\nconst char y2[] = \"al\";\n</code></pre>\n<p>then <code>x1</code> and <code>x2</code> must wind up equal according to <code>strcmp</code>, and the same for <code>y1</code> and <code>y2</code>.  (This is what Heath is getting at in quoting the translation steps - escape conversion happens <em>before</em> string constant concatenation.)  There's also a requirement that if <em>any</em> of the string constants in a concatenation group has an <code>L</code> or <code>U</code> prefix, you get a wide or Unicode string.  Put it all together and it winds up being significantly more convenient to do this work as part of the \"compiler\" rather than the \"preprocessor.\"  </p>\n", "OwnerUserId": "388520", "PostTypeId": "2", "Id": "3267636", "Score": "1", "CreationDate": "2010-07-16T18:00:00.373", "LastActivityDate": "2010-07-16T18:00:00.373"}, "3142630": {"CommentCount": "3", "ViewCount": "2321", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2010-06-29T16:18:22.837", "LastActivityDate": "2016-02-25T22:52:59.720", "Title": "Implementation of string literal concatenation in C and C++", "AcceptedAnswerId": "3142693", "LastEditDate": "2016-02-25T22:52:59.720", "Id": "3142630", "Score": "6", "Body": "<p><em>AFAIK, this question applies equally to <strong>C</strong> and C++</em></p>\n<p>Step 6 of the \"translation phases\" specified in the <strong>C</strong> standard (5.1.1.2 in the draft C99 standard) states that adjacent string literals have to be concatenated into a single literal. <a href=\"http://en.wikipedia.org/wiki/C_syntax#String_literal_concatenation\" rel=\"nofollow noreferrer\">I.e.</a> </p>\n<pre><code>printf(\"helloworld.c\" \": %d: Hello \"\n       \"world\\n\", 10);\n</code></pre>\n<p>Is equivalent (syntactically) to: </p>\n<pre><code>printf(\"helloworld.c: %d: Hello world\\n\", 10);\n</code></pre>\n<p>However, the standard doesn't seem to specify which part of the compiler has to handle this - should it be the preprocessor (<code>cpp</code>) or the compiler itself. Some online research tells me that this function is generally expected to be performed by the preprocessor (<a href=\"http://www.mers.byu.edu/docs/standardC/preproc.html\" rel=\"nofollow noreferrer\">source #1</a>, <a href=\"http://msdn.microsoft.com/en-us/library/69ze775t%28VS.80%29.aspx\" rel=\"nofollow noreferrer\">source #2</a>, and there are more), which makes sense.</p>\n<p>However, running <code>cpp</code> in Linux shows that <code>cpp</code> doesn't do it:</p>\n<pre><code>eliben@eliben-desktop:~/test$ cat cpptest.c \nint a = 5;\n\n\"string 1\" \"string 2\"\n\"string 3\"\n\neliben@eliben-desktop:~/test$ cpp cpptest.c \n# 1 \"cpptest.c\"\n# 1 \"&lt;built-in&gt;\"\n# 1 \"&lt;command-line&gt;\"\n# 1 \"cpptest.c\"\nint a = 5;\n\n\"string 1\" \"string 2\"\n\"string 3\"\n</code></pre>\n<p>So, my question is: where should this feature of the language be handled, in the preprocessor or the compiler itself?</p>\n<p>Perhaps there's no single good answer. Heuristic answers based on experience, known compilers, and general good engineering practice will be appreciated.</p>\n<hr>\n<p>P.S. If you're wondering why I care about this... I'm trying to figure out whether my <a href=\"http://code.google.com/p/pycparser/\" rel=\"nofollow noreferrer\">Python based C parser</a> should handle string literal concatenation (which it doesn't do, at the moment), or leave it to <code>cpp</code> which it assumes runs before it.</p>\n</hr>", "Tags": "<c++><c><c-preprocessor><string-literals>", "OwnerUserId": "8206", "AnswerCount": "5"}, "3142693": {"ParentId": "3142630", "CommentCount": "2", "Body": "<p>The standard doesn't specify a preprocessor vs. a compiler, it just specifies the phases of translation you already noted. Traditionally, phases 1 through 4 were in the preprocessor, Phases 5 though 7 in the compiler, and phase 8 the linker -- but none of that is required by the standard.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "3142693", "Score": "8", "CreationDate": "2010-06-29T16:27:07.557", "LastActivityDate": "2010-06-29T16:27:07.557"}, "3182020": {"ParentId": "3142630", "CommentCount": "1", "Body": "<p>I would handle it in the scanning token part of the parser, so in the compiler. It seems more logical. The preprocessor has not to know the \"structure\" of the language, and in fact it ignores it usually so that macros can generate uncompilable code. It handles nothing more than what it is entitled to handle by directives that are specifically addressed to it (<code># ...</code>), and the \"consequences\" of them (like those of a <code>#define x h</code>, which would make the preprocessor change a lot of x into h)</p>\n", "OwnerUserId": "354803", "PostTypeId": "2", "Id": "3182020", "Score": "0", "CreationDate": "2010-07-05T20:37:15.147", "LastActivityDate": "2010-07-05T20:37:15.147"}, "3142664": {"ParentId": "3142630", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Unless the preprocessor is specified to handle this, it's safe to assume it's the compiler's job.</p>\n<p>Edit:</p>\n<p>Your \"<a href=\"http://en.wikipedia.org/wiki/C_syntax#String_literal_concatenation\" rel=\"nofollow noreferrer\">I.e.</a>\" link at the beginning of the post answers the question:</p>\n<blockquote>\n<p id=\"so_3142630_3142664_0\">Adjacent string literals are concatenated at compile time; this allows long strings to be split over multiple lines, and also allows string literals <em>resulting from C preprocessor defines and macros</em> to be appended to strings <em>at compile time</em>...</p>\n</blockquote>\n", "OwnerUserId": "161424", "LastEditorUserId": "161424", "LastEditDate": "2010-06-29T16:28:58.177", "Id": "3142664", "Score": "3", "CreationDate": "2010-06-29T16:22:43.620", "LastActivityDate": "2010-06-29T16:28:58.177"}, "3142716": {"ParentId": "3142630", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In the ANSI C standard, this detail is covered in section 5.1.1.2, item (6):</p>\n<blockquote>\n<p id=\"so_3142630_3142716_0\">5.1.1.2 Translation phases<br>\n  ...<br>\n<br>\n  4. Preprocessing directives are executed and macro invocations are expanded. ...<br>\n<br>\n  5. Each source character set member and escape sequence in character constants and string literals is converted to a member of the execution character set.<br>\n<br>\n  6. Adjacent character string literal tokens are concatenated and adjacent wide string literal tokens are concatenated.</br></br></br></br></br></br></br></p>\n</blockquote>\n<p>The standard does not define that the implementation must use a pre-processor and compiler, per se.  </p>\n<p>Step 4 is clearly a preprocessor responsibility.</p>\n<p>Step 5 requires that the \"execution character set\" be known.  This information is also required by the compiler.  It is easier to port the compiler to a new platform if the preprocessor does not contain platform dependendencies, so the tendency is to implement step 5, and thus step 6, in the compiler.</p>\n", "OwnerUserId": "188704", "LastEditorUserId": "188704", "LastEditDate": "2010-06-29T16:58:02.753", "Id": "3142716", "Score": "2", "CreationDate": "2010-06-29T16:29:57.983", "LastActivityDate": "2010-06-29T16:58:02.753"}, "bq_ids": {"n4140": {"so_3142630_3142716_0": {"section_id": 5313, "quality": 0.7297297297297297, "length": 27}}, "n3337": {"so_3142630_3142716_0": {"section_id": 5110, "quality": 0.7297297297297297, "length": 27}}, "n4659": {"so_3142630_3142716_0": {"section_id": 6737, "quality": 0.7297297297297297, "length": 27}}}});