post_cb({"bq_ids": {"n4140": {"so_21101774_21147176_6": {"length": 7, "quality": 1.0, "section_id": 7189}, "so_21101774_21147176_2": {"length": 9, "quality": 1.0, "section_id": 7195}, "so_21101774_21147176_4": {"length": 17, "quality": 1.0, "section_id": 7195}, "so_21101774_21147176_3": {"length": 16, "quality": 1.0, "section_id": 7195}, "so_21101774_21147176_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_21101774_21147176_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_21101774_21147176_1": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_21101774_21147176_7": {"length": 5, "quality": 1.0, "section_id": 7189}}, "n3337": {"so_21101774_21147176_6": {"length": 7, "quality": 1.0, "section_id": 6933}, "so_21101774_21147176_3": {"length": 16, "quality": 1.0, "section_id": 6939}, "so_21101774_21147176_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_21101774_21147176_2": {"length": 9, "quality": 1.0, "section_id": 6939}, "so_21101774_21147176_4": {"length": 17, "quality": 1.0, "section_id": 6939}, "so_21101774_21147176_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_21101774_21147176_1": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_21101774_21147176_7": {"length": 5, "quality": 1.0, "section_id": 6933}}, "n4659": {"so_21101774_21147176_6": {"length": 7, "quality": 1.0, "section_id": 8697}, "so_21101774_21147176_3": {"length": 16, "quality": 1.0, "section_id": 8704}, "so_21101774_21147176_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_21101774_21147176_2": {"length": 9, "quality": 1.0, "section_id": 8704}, "so_21101774_21147176_4": {"length": 17, "quality": 1.0, "section_id": 8704}, "so_21101774_21147176_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_21101774_21147176_1": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_21101774_21147176_7": {"length": 5, "quality": 1.0, "section_id": 8701}}}, "21101774": {"ViewCount": "1483", "Body": "<p>Is the following legal in C++?</p>\n<p>As far as I can tell, <code>Reference</code> has a trivial destructor, so it should be legal.<br>\nBut I thought references can't be rebound legally... can they?</br></p>\n<pre><code>template&lt;class T&gt;\nstruct Reference\n{\n    T &amp;r;\n    Reference(T &amp;r) : r(r) { }\n};\n\nint main()\n{\n    int x = 5, y = 6;\n    Reference&lt;int&gt; r(x);\n    new (&amp;r) Reference&lt;int&gt;(y);\n}\n</code></pre>\n", "AcceptedAnswerId": "21147176", "Title": "Is \"rebinding\" references in C++ like this legal?", "CreationDate": "2014-01-13T21:31:07.663", "Id": "21101774", "CommentCount": "5", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2014-01-13T21:40:58.343", "LastEditorUserId": "501557", "LastActivityDate": "2014-01-15T20:08:36.883", "Score": "35", "OwnerUserId": "541686", "Tags": "<c++><reference><language-lawyer><placement-new>", "AnswerCount": "3"}, "21102111": {"Id": "21102111", "PostTypeId": "2", "Body": "<p>There is no reference being rebound in your example. The first reference (constructed on line two with the name <code>r.r</code>) is bound to the <code>int</code> denoted by <code>x</code> for the entire of its lifetime. This reference's lifetime is ended when the storage for its containing object is re-used by the placement new expression on line three. The replacement object contains a reference which is bound <code>y</code> for its entire lifetime which lasts until the end of its scope - the end of <code>main</code>.</p>\n", "LastActivityDate": "2014-01-13T21:52:43.360", "Score": "11", "CreationDate": "2014-01-13T21:52:43.360", "ParentId": "21101774", "CommentCount": "13", "OwnerUserId": "19563"}, "21101928": {"Id": "21101928", "PostTypeId": "2", "Body": "<p>You aren't rebinding a reference, you're creating a new object in the memory of another one with a placement new. Since the destructor of the old object was never run I think this would be undefined behavior.</p>\n", "LastActivityDate": "2014-01-13T21:40:59.973", "Score": "18", "CreationDate": "2014-01-13T21:40:59.973", "ParentId": "21101774", "CommentCount": "11", "OwnerUserId": "5987"}, "21147176": {"Id": "21147176", "PostTypeId": "2", "Body": "<p>I think I found the answer in a passage <em>below</em> the \"quoted\" one that talks about trivial dtor / dtor side effects, namely [basic.life]/7:</p>\n<blockquote>\n<p id=\"so_21101774_21147176_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can\n  be used to manipulate the new object, if:</p>\n<ul>\n<li><p id=\"so_21101774_21147176_1\">the storage for the new object exactly overlays the storage location which the original object occupied, and</p></li>\n<li><p id=\"so_21101774_21147176_2\">the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p></li>\n<li><p id=\"so_21101774_21147176_3\">the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and</p></li>\n<li><p id=\"so_21101774_21147176_4\">the original object was a most derived object of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</p></li>\n</ul>\n</blockquote>\n<p>By reusing the storage, we end the lifetime of original object [basic.life]/1</p>\n<blockquote>\n<p id=\"so_21101774_21147176_5\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li><p id=\"so_21101774_21147176_6\">if <code>T</code> is a class type with a non-trivial destructor, the destructor call starts, or</p></li>\n<li><p id=\"so_21101774_21147176_7\">the storage which the object occupies is reused or released.</p></li>\n</ul>\n</blockquote>\n<p>So I think [basic.life]/7 covers the situation</p>\n<pre><code>Reference&lt;int&gt; r(x);\nnew (&amp;r) Reference&lt;int&gt;(y);\n</code></pre>\n<p>where we end the lifetime of the object denoted by <code>r</code>, and create a new object at the same location.</p>\n<p>As <code>Reference&lt;int&gt;</code> is a class type with a reference data member, the requirements of [basic.life]/7 are <strong>not</strong> fulfilled. That is, <code>r</code> might not even refer to the new object, and we may not use it to \"manipulate\" this newly created object (I interpret this \"manipulate\" also as read-only accesses).</p>\n", "LastActivityDate": "2014-01-15T20:08:36.883", "Score": "4", "CreationDate": "2014-01-15T20:08:36.883", "ParentId": "21101774", "CommentCount": "2", "OwnerUserId": "420683"}});