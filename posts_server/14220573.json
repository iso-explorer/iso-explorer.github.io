post_cb({"14220573": {"ViewCount": "575", "Body": "<p>I have a question regarding the new/delete operator compared to alloc/free.</p>\n<p>When dynamicly allocating memory for a char*, I normaly use calloc so all reserved bits are set to zero, so I don't have to bother with nulltermination.</p>\n<p>Does char *string = new char[20] only reserve 20 items with the size of a char or does it also sets all bits in that memoryarea to zero?</p>\n<p>If not can memset be used on this memory to accomplish that?\nAnd if memset or any other method of zeroing out the allocated memory is possibly, can the new operator be overloaded for the native char type to do this work on its own?</p>\n", "AcceptedAnswerId": "14220679", "Title": "A quick on new/delete and alloc/free", "CreationDate": "2013-01-08T17:20:56.703", "Id": "14220573", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-01-08T17:41:02.753", "Score": "3", "OwnerUserId": "1516883", "Tags": "<c++>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_14220573_14220679_0": {"length": 7, "quality": 1.0, "section_id": 6098}}, "n3337": {"so_14220573_14220679_0": {"length": 7, "quality": 1.0, "section_id": 5864}}, "n4659": {"so_14220573_14220679_0": {"length": 7, "quality": 1.0, "section_id": 7595}}}, "14220626": {"Id": "14220626", "PostTypeId": "2", "Body": "<p><code>char * string = new char[20]</code> is going to be filled with whatever is in the allocated memory before it was allocated.</p>\n<p>You can memset the array to 0 to achieve what you want.</p>\n<pre><code>char * string = new char[20];\nmemset(string, 0x00, sizeof(char) * 20);\n</code></pre>\n<p>Overwriting new could do this as well.</p>\n<pre><code>void* operator new(size_t n){\n   void * mem = malloc(n);\n   memset(mem, 0x00, n);\n   return mem;\n}\n</code></pre>\n", "LastActivityDate": "2013-01-08T17:23:40.527", "Score": "1", "CreationDate": "2013-01-08T17:23:40.527", "ParentId": "14220573", "CommentCount": "1", "OwnerUserId": "1020484"}, "14220632": {"Id": "14220632", "PostTypeId": "2", "Body": "<p><code>new</code> does not zero-initialize primtive types (like <code>char</code>).  Using <code>memset</code> is fine, but the idiomatic C++ way would be to use <code>std::fill</code>:</p>\n<pre><code>std::fill(string, string+length, 0);\n</code></pre>\n<p>Of course, if you want a string, then you should just use a <code>std::string</code> in C++.</p>\n", "LastActivityDate": "2013-01-08T17:23:57.027", "Score": "1", "CreationDate": "2013-01-08T17:23:57.027", "ParentId": "14220573", "CommentCount": "0", "OwnerUserId": "129570"}, "14220679": {"Id": "14220679", "PostTypeId": "2", "Body": "<p>When you use:</p>\n<pre><code>string = new char[20];\n</code></pre>\n<p>the allocated array is not initialized. In order to default-initialize it, you have to use:</p>\n<pre><code>string = new char[20]();  // Allocates and initializes all members to 0\n</code></pre>\n<p>This is stated in C++03 \u00a75.3.4/15:</p>\n<blockquote>\n<p id=\"so_14220573_14220679_0\">A new-expression that creates an object of type T initializes that object as follows:\n  ...</p>\n<p id=\"so_14220573_14220679_1\">If the new-initializer is of the form (), the item is\n    value-initialized (8.5);</p>\n</blockquote>\n<p>As for your second question \u2014 yes, you can use <code>memset</code> to fill the memory with any values you want.</p>\n", "OwnerDisplayName": "user405725", "LastEditorUserId": "14065", "LastActivityDate": "2013-01-08T17:41:02.753", "Score": "5", "CreationDate": "2013-01-08T17:26:52.867", "ParentId": "14220573", "CommentCount": "1", "LastEditDate": "2013-01-08T17:41:02.753"}});