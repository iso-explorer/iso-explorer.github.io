post_cb({"bq_ids": {"n4140": {"so_6152956_6153010_2": {"length": 15, "quality": 1.0, "section_id": 2110}, "so_6152956_6153010_1": {"length": 31, "quality": 0.9393939393939394, "section_id": 2243}}, "n3337": {"so_6152956_6153010_2": {"length": 15, "quality": 1.0, "section_id": 2098}, "so_6152956_6153010_1": {"length": 31, "quality": 0.9393939393939394, "section_id": 2231}}, "n4659": {"so_6152956_6153010_2": {"length": 15, "quality": 1.0, "section_id": 2383}, "so_6152956_6153010_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 2516}}}, "6155810": {"Id": "6155810", "PostTypeId": "2", "Body": "<p>You should consider using <a href=\"http://www.cplusplus.com/reference/iostream/istream/peek/\" rel=\"nofollow\"><code>std::istream::peek</code></a> instead.</p>\n<p>It allows you to check the next available character without actually getting it out of the stream. This way you won't have to put it back :)</p>\n", "LastActivityDate": "2011-05-27T17:37:39.543", "CommentCount": "0", "CreationDate": "2011-05-27T17:37:39.543", "ParentId": "6152956", "Score": "0", "OwnerUserId": "147192"}, "6152956": {"ViewCount": "548", "Body": "<p>Considering the following:</p>\n<pre><code>char c;\ncin &gt;&gt; c;\ncin.unget();\n</code></pre>\n<p>Assuming the char input was successful, is unget guaranteed to be able to back up at least that one character?  If I ask for, and successfully get a string, can I be guaranteed to be allowed to call unget all the way to the beginning of that string?</p>\n", "AcceptedAnswerId": "6153010", "Title": "Are there any guarantees with unget?", "CreationDate": "2011-05-27T13:31:53.510", "Id": "6152956", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-05-27T17:37:39.543", "Score": "4", "OwnerUserId": "440119", "Tags": "<c++>", "AnswerCount": "2"}, "6153010": {"Id": "6153010", "PostTypeId": "2", "Body": "<p>You are guaranteed to be able to <code>unget</code> at least 1 character. Any more than one is up to the implementation and circumstances, so you shouldn't assume that you can <code>unget</code> more than one.</p>\n<p><strong>EDIT:</strong> Sorry I was thinking of libc's <code>int unget(int ch, FILE *stream)</code>. Which the standard says:</p>\n<blockquote>\n<p id=\"so_6152956_6153010_0\">One character of pushback is\n  guaranteed. If the ungetc function is\n  called too many times on the same\n  stream without an intervening read or\n  file positioning operation on that\n  stream, the operation may fail.</p>\n</blockquote>\n<p>I will see if I can find exactly what is said about <code>basic_istream&lt;&gt;&amp; unget()</code></p>\n<p><strong>EDIT:</strong> OK, so here's what the c++ standard says about <code>basic_istream&lt;&gt;&amp; unget()</code> (bolding added by me):</p>\n<blockquote>\n<p id=\"so_6152956_6153010_1\">Behaves as an unformatted input\n  function (as described in 27.6.1.3,\n  paragraph 1). After constructing a\n  <code>sentry</code> object, if <code>!good()</code> calls\n  <code>setstate(failbit)</code> which may throw an\n  exception, and return. If <code>rdbuf()</code> is\n  not null, <strong>calls <code>rdbuf()-&gt;sungetc()</code></strong>. If\n  <code>rdbuf()</code> is null, or if <code>sungetc()</code>\n  returns <code>traits::eof()</code>, calls\n  <code>setstate(badbit)</code> (which may throw\n  <code>ios_base::failure</code> (27.4.4.3)).</p>\n</blockquote>\n<p>So the important bit is that it calls <code>sungetc()</code>, so let's see what the standard says about that:</p>\n<blockquote>\n<p id=\"so_6152956_6153010_2\">If the input sequence putback position\n  is not available, returns <code>pbackfail()</code>.\n  Otherwise, decrements the next pointer\n  for the input sequence and returns\n  <code>traits::to_int_type(*gptr())</code>.</p>\n</blockquote>\n<p>I see nothing that explicitly states a limitation, so it's worth a try. If I understand this correctly, it will adjust pointers in the backing stream buffer. So as long as there is enough \"history\" in the buffer, it should continue to succeed.</p>\n<p>Unlike C, however, it seems that you are never guaranteed that it will work, but you will likely be able to putback more than one character.</p>\n<p>So my advice is to not depend on putting back more than one character, and always check for failure.</p>\n", "LastEditorUserId": "13430", "LastActivityDate": "2011-05-27T14:45:17.237", "Score": "7", "CreationDate": "2011-05-27T13:37:17.207", "ParentId": "6152956", "CommentCount": "1", "OwnerUserId": "13430", "LastEditDate": "2011-05-27T14:45:17.237"}});