post_cb({"26123293": {"ParentId": "26123254", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2014-09-30T14:26:53.603", "Score": "11", "LastEditorUserId": "3953764", "LastEditDate": "2015-06-27T20:06:27.063", "Id": "26123293", "OwnerUserId": "3953764", "Body": "<p>The member functions of a class template are instantiated only when required by a context, which means you will not see any error until you try to use <code>new_t()</code>. The related section from the C++ standard is:</p>\n<blockquote>\n<h3>\u00a7 14.7.1 Implicit instantiation <code>[temp.inst]</code></h3>\n<ol start=\"3\">\n<li><p id=\"so_26123254_26123293_0\">Unless a function template specialization has been explicitly instantiated or explicitly specialized, the <strong>function template specialization is implicitly instantiated when the specialization is referenced in a context that requires a function definition to exist</strong>. Unless a call is to a function template explicit specialization or to a member function of an explicitly specialized class template, a default argument for a function template or a member function of a class template is implicitly instantiated when the function is called in a context that requires the value of the default argument.</p></li>\n<li><p id=\"so_26123254_26123293_1\">[ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; struct Z {\n  void f();\n  void g();\n};\n\nvoid h() {\n  Z&lt;int&gt; a;     // instantiation of class Z&lt;int&gt; required\n  Z&lt;char&gt;* p;   // instantiation of class Z&lt;char&gt; not required\n  Z&lt;double&gt;* q; // instantiation of class Z&lt;double&gt; not required\n  a.f();        // instantiation of Z&lt;int&gt;::f() required\n  p-&gt;g();       // instantiation of class Z&lt;char&gt; required, and\n                // instantiation of Z&lt;char&gt;::g() required\n}\n</code></pre>\n<p id=\"so_26123254_26123293_2\">Nothing in this example requires <code>class Z&lt;double&gt;</code>, <code>Z&lt;int&gt;::g()</code>, or <code>Z&lt;char&gt;::f()</code> to be implicitly\n  instantiated. \u2014 <em>end example</em> ]</p></li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2015-06-27T20:06:27.063"}, "bq_ids": {"n4140": {"so_26123254_26123293_2": {"section_id": 236, "quality": 0.8181818181818182, "length": 9}, "so_26123254_26123293_0": {"section_id": 235, "quality": 0.9615384615384616, "length": 50}}, "n3337": {"so_26123254_26123293_2": {"section_id": 229, "quality": 0.8181818181818182, "length": 9}, "so_26123254_26123293_0": {"section_id": 228, "quality": 0.9615384615384616, "length": 50}}, "n4659": {"so_26123254_26123293_2": {"section_id": 246, "quality": 0.8181818181818182, "length": 9}, "so_26123254_26123293_0": {"section_id": 245, "quality": 0.9615384615384616, "length": 50}}}, "26123254": {"CommentCount": "1", "AcceptedAnswerId": "26123293", "CreationDate": "2014-09-30T14:25:03.403", "LastActivityDate": "2015-06-27T20:06:27.063", "PostTypeId": "1", "ViewCount": "1220", "FavoriteCount": "1", "Title": "Member function instantiation", "Id": "26123254", "Score": "10", "Body": "<p>The following compiles on GCC 4.8.1 (with <code>--std=c++11</code>):</p>\n<pre><code>struct non_default_constructible { non_default_constructible() = delete; };\n\ntemplate&lt;class T&gt;\nstruct dummy {\n    T new_t() { return T(); }\n};\n\nint main(int argc, char** argv) {\n    dummy&lt;non_default_constructible&gt; d;\n    return 0;\n}\n</code></pre>\n<p>The tricky part is that <code>dummy&lt;non_default_constructible&gt;::new_t()</code> is obviously ill-formed, but that does not prevent the compiler from instantiating <code>dummy&lt;non_default_constructible&gt;</code>. </p>\n<p>Is this the behaviour specified by the standard? And what would be the relevant sections/keywords?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "1734710", "AnswerCount": "1"}});