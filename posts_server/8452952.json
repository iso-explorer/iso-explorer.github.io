post_cb({"8452952": {"ViewCount": "11048", "Body": "<p>I am compiling the following simple program with <code>g++-4.6.1 --std=c++0x</code>:</p>\n<pre><code>#include &lt;algorithm&gt;\n\nstruct S\n{\n    static constexpr int X = 10;\n};\n\nint main()\n{\n    return std::min(S::X, 0);\n};\n</code></pre>\n<p>I get the following linker error:</p>\n<pre><code>/tmp/ccBj7UBt.o: In function `main':\nscratch.cpp:(.text+0x17): undefined reference to `S::X'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>I realize that inline-defined static members do not have symbols defined, but I was under the (probably flawed) impression that using <code>constexpr</code> told the compiler to always treat the symbol as an expression; so, the compiler would know that it is not legal to pass a reference to the symbol <code>S::X</code> (for the same reason you can't take a reference to the literal <code>10</code>).</p>\n<p>However if S is declared as namespace, i.e. \"namespace S\" instead of \"struct S\", everything links fine.</p>\n<p>Is this a <code>g++</code> bug or do I still have to use a trick to workaround this annoyance?</p>\n", "AcceptedAnswerId": "8452990", "Title": "C++ Linker Error With Class static constexpr", "CreationDate": "2011-12-09T23:22:34.020", "Id": "8452952", "CommentCount": "0", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2012-07-19T22:28:39.683", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-16T22:14:33.080", "Score": "30", "OwnerUserId": "254306", "Tags": "<c++><linker><c++11><constexpr>", "AnswerCount": "4"}, "36670394": {"Id": "36670394", "PostTypeId": "2", "Body": "<p>The reason for the error has been already explained, so I'd just add a workaround.</p>\n<pre><code>return std::min(int(S::X), 0);\n</code></pre>\n<p>This creates a temporary, so <code>std::min</code> could take a reference to it.</p>\n", "LastActivityDate": "2016-04-16T22:14:33.080", "CommentCount": "0", "CreationDate": "2016-04-16T22:14:33.080", "ParentId": "8452952", "Score": "6", "OwnerUserId": "23714"}, "bq_ids": {"n4140": {"so_8452952_24383995_4": {"length": 10, "quality": 1.0, "section_id": 7135}, "so_8452952_24383995_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 7135}, "so_8452952_24383995_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7136}, "so_8452952_24383995_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 7135}, "so_8452952_24383995_1": {"length": 19, "quality": 0.95, "section_id": 7135}}, "n3337": {"so_8452952_24383995_4": {"length": 10, "quality": 1.0, "section_id": 6879}, "so_8452952_24383995_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 6879}, "so_8452952_24383995_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 6880}, "so_8452952_24383995_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 6879}, "so_8452952_24383995_1": {"length": 19, "quality": 0.95, "section_id": 6879}}, "n4659": {"so_8452952_24383995_4": {"length": 10, "quality": 1.0, "section_id": 8636}, "so_8452952_24383995_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 8636}, "so_8452952_24383995_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 8637}, "so_8452952_24383995_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 8636}, "so_8452952_24383995_1": {"length": 19, "quality": 0.95, "section_id": 8636}}}, "8452990": {"Id": "8452990", "PostTypeId": "2", "Body": "<p>I don't think this is a bug. If you change the <code>constexpr</code> to <code>const</code>, it still fails, with the exact same error.</p>\n<p>You've declared <code>S::X</code>, but not defined it anywhere, so there's no storage for it. If you do anything with it that needs to know the address of it then you'll need to define it somewhere also.</p>\n<p>Examples:</p>\n<pre><code>int main() {\n      int i = S::X; // fine\n      foo&lt;S::X&gt;(); // fine\n      const int *p = &amp;S::X; // needs definition\n      return std::min(S::X, 0); // needs it also\n}\n</code></pre>\n<p>The reason for this is that <code>constexpr</code> <em>can</em> be evaluated at compile time, but it's not <em>required</em> to be evaluated as such, and can equally happen at runtime. It doesn't instruct <em>\"the compiler to always treat the symbol as an expression\"</em>, it hints that it would be sensible and permissible to do so if the compiler felt like it.</p>\n", "LastEditorUserId": "168175", "LastActivityDate": "2011-12-09T23:33:34.140", "Score": "21", "CreationDate": "2011-12-09T23:28:32.727", "ParentId": "8452952", "CommentCount": "5", "OwnerUserId": "168175", "LastEditDate": "2011-12-09T23:33:34.140"}, "24383995": {"Id": "24383995", "PostTypeId": "2", "Body": "<p>In the C++ standard (<a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">latest working draft</a>), it says:</p>\n<blockquote>\n<p id=\"so_8452952_24383995_0\">A name having namespace scope (3.3.6) has internal linkage if it is the name of [...] a variable that is explicitly declared <code>const</code> or <code>constexpr</code> and neither explicitly declared <code>extern</code> nor previously declared to have external linkage [...].</p>\n</blockquote>\n<p>\"Linkage\" is defined like this:</p>\n<blockquote>\n<p id=\"so_8452952_24383995_1\">A name is said to have linkage when it might denote the same object, reference, function, type, template,\n  namespace or value as a name introduced by a declaration in another scope:</p>\n<p id=\"so_8452952_24383995_2\">\u2014 When a name has <em>external linkage</em>, the entity it denotes can be referred to by names from scopes of\n  other translation units or from other scopes of the same translation unit.</p>\n<p id=\"so_8452952_24383995_3\">\u2014 When a name has <em>internal linkage</em>, the entity it denotes can be referred to by names from other scopes\n  in the same translation unit.</p>\n<p id=\"so_8452952_24383995_4\">\u2014 When a name has <em>no linkage</em>, the entity it denotes cannot be referred to by names from other scopes.</p>\n</blockquote>\n<p>Thus, in case of <code>namespace S</code>, it will have <em>external linkage</em>, in case of <code>struct S</code>, it will have <em>internal linkage</em>.</p>\n<p>Symbols with external linkage need to have the symbol defined explicitly in some translation unit.</p>\n", "LastActivityDate": "2014-06-24T10:14:27.907", "CommentCount": "1", "CreationDate": "2014-06-24T10:14:27.907", "ParentId": "8452952", "Score": "3", "OwnerUserId": "133374"}, "24327635": {"Id": "24327635", "PostTypeId": "2", "Body": "<p>Your understanding of <code>constexpr</code> is wrong.  An lvalue declared\n<code>constexpr</code> is still an lvalue, and a function declared\n<code>constexpr</code> is still a function.  And when a function has\na reference parameter, and it is passed an lvalue, the language\nrequires that the reference refer to that lvalue, and nothing\nelse.  (When applied to a variable of type <code>int</code>, there is\nreally very little difference between <code>constexpr</code> and plain\n<code>const</code>.) </p>\n", "LastActivityDate": "2014-06-20T12:46:39.850", "CommentCount": "0", "CreationDate": "2014-06-20T12:46:39.850", "ParentId": "8452952", "Score": "1", "OwnerUserId": "649665"}});