post_cb({"27399232": {"ParentId": "27397701", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1232\" rel=\"nofollow\">DR 1232</a> changed C++11 to allow calling functions with reference-to-array parameters from an initializer list. (The changes to the working paper are shown in <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1232\" rel=\"nofollow\">N3262</a>.) All the compilers tested implement that rule.</p>\n<p><a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1307\" rel=\"nofollow\">DR1307</a> then changed the same wording again to resolve the ambiguity you've discovered. Your code is accepted by GCC and EDG compilers, so I assume Clang does not implement that DR yet.</p>\n<p>It's interesting to note that even after that DR was resolved, <code>foo({1, 2})</code> is still ambiguous, and rejected by all compilers. The reason is that <code>{1, 2}</code> can bind to the <code>const int(&amp;)[2]</code> parameter (obviously) but it can also bind to the <code>const int(&amp;)[3]</code> parameter because <code>int</code> is default-constructible, so it means the same as <code>{1, 2, int()}</code> i.e. <code>{1, 2, 0}</code></p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2014-12-10T12:00:09.077", "Id": "27399232", "Score": "4", "CreationDate": "2014-12-10T10:56:32.823", "LastActivityDate": "2014-12-10T12:00:09.077"}, "27399225": {"ParentId": "27397701", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think that although GCC's behaviour is more useful, it's clang's behaviour that is correct for C++11:</p>\n<blockquote>\n<p id=\"so_27397701_27399225_0\"><strong>13.3.3.1.5 List-initialization sequence [over.ics.list]</strong></p>\n<p id=\"so_27397701_27399225_1\">2 If the parameter type is <code>std::initializer_list&lt;X&gt;</code> or \"array of <code>X</code>\" and all the elements of the initializer list can be implicitly converted to <code>X</code>, the implicit conversion sequence is the worst conversion necessary to convert an element of the list to <code>X</code>.</p>\n</blockquote>\n<p>This conversion sequence pays no attention to the array length. Both function overloads give an implicit conversion sequence that is an identity conversion: both take a reference to an array of <code>int</code>, and each element in the function argument is an <code>int</code>.</p>\n<p>Overload resolution then sees two identity conversions, and although the standard does have a few exceptions for resolving conflicts on conversions of equal rank, there is none that pays attention to the array's length:</p>\n<blockquote>\n<p id=\"so_27397701_27399225_2\"><strong>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</strong></p>\n<p id=\"so_27397701_27399225_3\">3 Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of the following rules applies:</p>\n</blockquote>\n<p>followed by a list that does not mention arrays at all.</p>\n<p>Jonathan Wakely points out that this has since changed. Your question is exactly what prompted that change, and the corresponding DR is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1307\" rel=\"nofollow\">#1307</a>. In C++14, your code is valid, but not in C++11.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2014-12-10T11:19:42.913", "Id": "27399225", "Score": "5", "CreationDate": "2014-12-10T10:56:01.653", "LastActivityDate": "2014-12-10T11:19:42.913"}, "bq_ids": {"n4140": {"so_27397701_27399225_3": {"section_id": 639, "quality": 1.0, "length": 13}, "so_27397701_27399225_1": {"section_id": 630, "quality": 0.95, "length": 19}}, "n3337": {"so_27397701_27399225_3": {"section_id": 629, "quality": 1.0, "length": 13}, "so_27397701_27399225_1": {"section_id": 621, "quality": 1.0, "length": 20}}, "n4659": {"so_27397701_27399225_3": {"section_id": 667, "quality": 1.0, "length": 13}, "so_27397701_27399225_1": {"section_id": 658, "quality": 0.95, "length": 19}}}, "27397701": {"CommentCount": "3", "ViewCount": "283", "PostTypeId": "1", "LastEditorUserId": "4278083", "CreationDate": "2014-12-10T09:43:35.757", "LastActivityDate": "2014-12-10T12:00:09.077", "Title": "Initializer_list as argument to an array reference parameter in a not-template context", "FavoriteCount": "2", "LastEditDate": "2014-12-10T10:26:27.880", "Id": "27397701", "Score": "12", "Body": "<p>My question concerns this very simple and short code where an overload resolution is attempted between two non-template functions accepting an array reference parameter. The question has been posted elsewhere, but in a template deduction context. Here's the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo ( const int (&amp;x) [3] ) { std::cout &lt;&lt; \"3\\n\"; }\nvoid foo ( const int (&amp;x) [2] ) { std::cout &lt;&lt; \"2\\n\"; }\n\nint main()\n{\n    foo({1,2,3});\n}\n</code></pre>\n<p>g++ 4.8.3 compiles this code selecting the first function as (I suppose) the ONLY viable,\nwhile clang 3.4 doesn't compile it, saying that the call to foo  is  ambiguous (why?).</p>\n<p>Which compiler does the right thing?</p>\n<p>clang doesn't compile the code even removing the second overload: it seems that an initializer_list is simply not accepted to initialize an array reference.</p>\n<p>Is this buggy?</p>\n", "Tags": "<c++><c++11><initializer-list><overload-resolution>", "OwnerUserId": "4278083", "AnswerCount": "2"}});