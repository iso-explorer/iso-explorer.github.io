post_cb({"bq_ids": {"n4140": {"so_7054176_7054354_4": {"section_id": 6092, "quality": 0.9230769230769231, "length": 84}, "so_7054176_7054354_3": {"section_id": 7244, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_7054176_7054354_4": {"section_id": 5859, "quality": 0.9230769230769231, "length": 84}, "so_7054176_7054354_3": {"section_id": 6988, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_7054176_7054354_3": {"section_id": 8753, "quality": 0.8695652173913043, "length": 20}, "so_7054176_7054354_4": {"section_id": 7588, "quality": 0.9340659340659341, "length": 85}}}, "7054289": {"ParentId": "7054176", "CommentCount": "5", "Body": "<p>You can influence the alignment in memory with the pragma pack declarations, just Google for it.</p>\n", "OwnerUserId": "803931", "PostTypeId": "2", "Id": "7054289", "Score": "0", "CreationDate": "2011-08-14T00:58:28.887", "LastActivityDate": "2011-08-14T00:58:28.887"}, "7054176": {"CommentCount": "1", "ViewCount": "1085", "PostTypeId": "1", "LastEditorUserId": "1228", "CreationDate": "2011-08-14T00:27:09.920", "LastActivityDate": "2013-06-26T20:17:12.197", "Title": "Data alignment in C++, standard and portability", "LastEditDate": "2013-06-26T20:17:12.197", "Id": "7054176", "Score": "5", "Body": "<p>I want to construct an object of class <code>T</code> by using <code>::operator new(size_t)</code> and placement <code>new</code>.</p>\n<p>To \"extend\" the size of <code>char v[1]</code>, which is the last declared data member in <code>T</code>, I allocate <code>sizeof(T) + n - 1</code> bytes with <code>operator new()</code>, where <code>n</code> is the wanted size in bytes. This trick allows me to access <code>v[i]</code> for any <code>i</code> in <code>[0, n -1]</code>.</p>\n<p>My questions are about the C++ standard:</p>\n<ol>\n<li><p>Does the order of declaration of data members in <code>T</code> reflect the order in which data is represented in memory?</p></li>\n<li><p>If the order is preserved, are data member alignments also preserved no matter how bigger is the size of the allocated memory?</p></li>\n</ol>\n", "Tags": "<c++>", "OwnerUserId": "893504", "AnswerCount": "4"}, "7054193": {"ParentId": "7054176", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>1) Yes.  From the section on pointer comparisons, the standard states that pointers to later members must compare as greater than pointers to earlier members.  <strong>Edit:</strong>  As pointed out by Martin, the standard only mandates this for POD structs. </p>\n<p>2) Yes.  Data alignment is not affected by the size of the allocation.</p>\n<p>The thing is, nothing in the standard actually guarantees that the trick of using arrays this way works (IIRC).</p>\n<pre><code>struct something {\n    ...\n    char buf[1];\n};\n</code></pre>\n<p>However, this is done <em>so commonly</em> that it is a de-facto standard.  The standards folks, last time I checked, were working on a way that they could codify these existing practices (It's already made its way into the C standard and it's only a matter of time before it's standardized in C++).</p>\n", "OwnerUserId": "82294", "LastEditorUserId": "82294", "LastEditDate": "2011-08-14T01:56:34.467", "Id": "7054193", "Score": "3", "CreationDate": "2011-08-14T00:31:50.500", "LastActivityDate": "2011-08-14T01:56:34.467"}, "7054191": {"ParentId": "7054176", "CommentCount": "2", "Body": "<p>1a: Yes, just like C, the order of data members define the order in memory.</p>\n<p>1b: Not unless the class is a POD (plain-old-data) class. To get that, it must not have constructors or virtual functions. The C++ standard has a list of rules that define what qualifies as POD.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7054191", "Score": "0", "CreationDate": "2011-08-14T00:31:31.950", "LastActivityDate": "2011-08-14T00:31:31.950"}, "7054354": {"ParentId": "7054176", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_7054176_7054354_0\">Does the order of declaration of data members in T reflect the order in which data is represented in memory?</p>\n</blockquote>\n<p>In limited situations yes.<br>\nSee Section 9 Classes [class] paragraph 7 (Look for details about A standard-layout class)  </br></p>\n<p>But in general no. There are no guarantees about the order of members in different protected/private/public regions.</p>\n<blockquote>\n<p id=\"so_7054176_7054354_1\">If the order is preserved, are data member alignments also preserved no matter how bigger is the size of the allocated memory?</p>\n</blockquote>\n<p>What do you mean preserved. The compiler decides for you. Once they are defined for a class they are constant through the code.</p>\n<blockquote>\n<p id=\"so_7054176_7054354_2\">I want to construct an object of class T by using ::operator new(size_t) and placement new.</p>\n</blockquote>\n<p>This is guaranteed. As long as you use new to allocate a block of memory at lease the same size as T then it is guaranteed to be aligned correctly for objects of type T.</p>\n<h3>3.1.1 Alignment [basic.align]</h3>\n<p>Paragraph 5:</p>\n<blockquote>\n<p id=\"so_7054176_7054354_3\">Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.</p>\n</blockquote>\n<p>Thus if you have an object that is aligned to stricter requirement it is guaranteed to be aligned for weaker alignments. Thus space aligned for something that that is larger than T is also aligned for objects of size T.</p>\n<h3>5.3.4 New    [expr.new]</h3>\n<p>Paragraph 10</p>\n<blockquote>\n<p id=\"so_7054176_7054354_4\">A new-expression passes the amount of space requested to the allocation function as the first argument of type std::size_t. That argument shall be no less than the size of the object being created; it may be greater than the size of the object being created only if the object is an array. <strong>For arrays of char and unsigned char, the difference between the result of the new-expression and the address returned by the allocation function shall be an integral multiple of the strictest fundamental alignment requirement (3.11)</strong> of any object type whose size is no greater than the size of the array being created. [ <strong>Note: Because allocation functions are assumed to return pointers to storage that is appropriately aligned for objects of any type with fundamental alignment, this constraint on array allocation overhead permits the common idiom of allocating character arrays into which objects of other types will later be placed. \u2014 end note</strong> ]</p>\n</blockquote>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2011-08-14T16:18:56.817", "Id": "7054354", "Score": "0", "CreationDate": "2011-08-14T01:16:44.800", "LastActivityDate": "2011-08-14T16:18:56.817"}});