post_cb({"23660294": {"ParentId": "23659222", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_23659222_23660294_0\">As users do not define <code>std::vector&lt;int&gt;</code>, and <code>std::vector&lt;int&gt;</code> is not dependent on any type a user defines, <code>std::vector&lt;int&gt;</code> is not a user-defined type.</p>\n</blockquote>\n<p>The logical counter argument is that users <strong>do</strong> define <code>std::vector&lt;int&gt;</code>. You see <code>std::vector</code> is a <strong>class template</strong> and as such has no direct representation in binary code. </p>\n<p>In a sense it gets it binary representation through the instantiation of a type, so the very action of declaring a <code>std::vector&lt;int&gt;</code> object is what gives \"soul\" to the template (pardon the phrasing). In a program where noone uses a <strong><code>std::vector&lt;int&gt;</code></strong> this data type does not exist. </p>\n<p>On the other hand, following the same argument, <code>std::vector&lt;T&gt;</code> is <strong>not</strong> a user defined type, it is not even a type, it does not exist; only if we want to (instantiate a type), <strong>it will mandate</strong> how a structure will be layed out but until then we can only argue about it in terms of <strong>structure</strong>, <strong>design</strong>, <strong>properties</strong> and so on.</p>\n<h2>Note</h2>\n<p>The above argument (about templates being not code but ... well templates for code) may seem a bit superficial but draws it's logic, from Mayer's introduction in A. Alexandrescu's book <strong>Modern C++ Design</strong>. The relative quote there, goes like this :</p>\n<blockquote>\n<p id=\"so_23659222_23660294_1\">Eventually, Andrei turned his attention to the development of template-based implementations of popular language idioms and design patterns, especially the GoF[*] patterns. This led to a brief skirmish with the Patterns community, <strong>because one of their fundamental tenets is that patterns cannot be represented in code. Once it became clear that Andrei was automating the generation of pattern implementations rather than trying to encode patterns themselves</strong>, that objection was removed, and I was pleased to see Andrei and one of the GoF (John Vlissides) collaborate on two columns in the C++ Report focusing on Andrei's work.</p>\n</blockquote>\n", "OwnerUserId": "2567683", "LastEditorUserId": "2567683", "LastEditDate": "2014-05-14T16:42:14.383", "Id": "23660294", "Score": "7", "CreationDate": "2014-05-14T16:31:07.283", "LastActivityDate": "2014-05-14T16:42:14.383"}, "23661911": {"ParentId": "23659222", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The draft standard contrasts fundamental types with user-defined types in a couple of (non-normative) places.</p>\n<p>The draft standard also uses the term \"user-defined\" in other contexts, referring to entities created by the programmer <em>or</em> defined in the standard library. Examples include user-defined constructor, user-defined operator and user-defined conversion.</p>\n<p>These facts allow us, absent other evidence, to tentatively assume that the intent of the standard is that user-defined type should mean compound type, according to historical usage. Only an explicit clarification in a future standard document can definitely resolve the issue.</p>\n<p>Note that the historical usage is not clear on types like <code>int*</code> or <code>struct foo*</code> or <code>void(*)(struct foo****)</code>. They are compound, but should they (or some of them) be considered user-defined? </p>\n", "OwnerUserId": "775806", "LastEditorUserId": "775806", "LastEditDate": "2014-05-14T18:13:36.417", "Id": "23661911", "Score": "2", "CreationDate": "2014-05-14T18:04:15.473", "LastActivityDate": "2014-05-14T18:13:36.417"}, "27790521": {"ParentId": "23659222", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When Clause 17 says \"user-defined\" it means \"a type not defined in the standard\" so <code>std::vector&lt;int&gt;</code> is <strong>not</strong> user-defined, neither is <code>std::string</code>, so you cannot specialize <code>std::vector&lt;int&gt;</code> or <code>std::vector&lt;std::string&gt;</code>. On the other hand, <code>struct MyClass</code> is user-defined, because it's not a type defined in the standard, so you can specialize <code>std::vector&lt;MyClass&gt;</code>.</p>\n<p>This is not the same meaning of \"user-defined\" used in clauses 1-16, and that difference is confusing and silly. There is a <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2139\" rel=\"noreferrer\">defect report</a> for this, with some discussion recorded that basically says \"yes, the library uses the wrong term, but we don't have a better one\".</p>\n<p>So the answer to your question is \"it depends\". If you're talking to a C++ compiler implementor or a core language expert, <code>std::vector&lt;int&gt;</code> is definitely a user-defined type, but if you're talking to a standard library implementor, it is not. More precisely, it's not user-defined <em>for the purposes of 17,6.4.2.1</em>.</p>\n<p>One way to look at it is that the standard library is \"user code\" as far as the core language is concerned. But the standard library has a different idea of \"users\" and considers itself to be part of the implementation, and only things that aren't part of the library are \"user-defined\".</p>\n<p><strong>Edit:</strong> I have proposed changing the library Clauses to use a new term, \"program-defined\", which means something defined in your program (as opposed to UDTs defined in the standard, such as <code>std::string</code>).</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-06-30T15:46:56.970", "Id": "27790521", "Score": "14", "CreationDate": "2015-01-06T01:00:46.087", "LastActivityDate": "2015-06-30T15:46:56.970"}, "23659817": {"ParentId": "23659222", "CommentCount": "7", "Body": "<p>Prof. Stroustrup is very clear that any type that is not built-in is <em>user-defined</em>. See the second paragraph of section 9.1 in Programming Principles and Practice Using C++.</p>\n<p>He even specifically calls out \u201cstandard library types\u201d as an example of user-defined types. In other words, a user-defined type is any compound type.</p>\n<p><a href=\"http://www.slashslash.info/tag/udts/\">Source</a></p>\n<p>The article explicitly mentions that not everyone seems to agree, but this is IMHO mostly wishful thinking and not what the standard (and Prof. Stroustrup) are actually saying, only what some people want to read into it.</p>\n", "OwnerUserId": "2073257", "PostTypeId": "2", "Id": "23659817", "Score": "32", "CreationDate": "2014-05-14T16:06:46.293", "LastActivityDate": "2014-05-14T16:06:46.293"}, "bq_ids": {"n4140": {"so_23659222_23659222_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_23659222_23659222_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_23659222_23659222_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}}}, "23659222": {"CommentCount": "10", "ViewCount": "2204", "PostTypeId": "1", "LastEditorUserId": "1774667", "CreationDate": "2014-05-14T15:39:00.953", "LastActivityDate": "2016-03-29T20:37:15.890", "Title": "Is std::vector<T> a `user-defined type`?", "FavoriteCount": "10", "LastEditDate": "2016-03-29T20:37:15.890", "Id": "23659222", "Score": "41", "Body": "<p>In 17.6.4.2.1/1 and 17.6.4.2.1/2 of the <a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"noreferrer\">current draft standard</a> restrictions are placed on specializations injected by users into <code>namespace std</code>.</p>\n<blockquote>\n<p id=\"so_23659222_23659222_0\">The behavior of a C\n  ++\n  program is undefined if it adds declarations or definitions to namespace\n  std\n  or to a\n  namespace within namespace\n  std\n  unless otherwise specified. A program may add a template specialization\n  for any standard library template to namespace\n  std\n  only if the declaration depends on a <strong>user-defined type</strong>\n  and the specialization meets the standard library requirements for the original template and is not explicitly\n  prohibited.</p>\n</blockquote>\n<p>I cannot find where in the standard the phrase <strong>user-defined type</strong> is defined.</p>\n<p>One option I have heard claimed is that a type that is not <code>std::is_fundamental</code> is a <strong>user-defined type</strong>, in which case <code>std::vector&lt;int&gt;</code> would be a <strong>user-defined type</strong>.</p>\n<p>An alternative answer would be that a <strong>user-defined type</strong> is a type that a user defines.  As users do not define <code>std::vector&lt;int&gt;</code>, and <code>std::vector&lt;int&gt;</code> is not dependent on any type a user defines, <code>std::vector&lt;int&gt;</code> is not a <strong>user-defined type</strong>.</p>\n<p>A practical problem this impacts is \"can you inject a specialization for <code>std::hash</code> for <code>std::tuple&lt;Ts...&gt;</code> into <code>namespace std</code>?  Being able to do so is somewhat convenient -- the alternative is to create another namespace where we recursively build our hash for <code>std::tuple</code> (and possibly other types in <code>std</code> that do not have <code>hash</code> support), and if and only if we fail to find a hash in that namespace do we fall back on <code>std</code>.</p>\n<p>However, if this is legal, then if and when the standard adds a <code>hash</code> specialization for <code>std::tuple</code> to <code>namespace std</code>, code that specialized it already would be broken, creating a reason not to add such specializations in the future.</p>\n<p>While I am talking about <code>std::vector&lt;int&gt;</code> as a concrete example, I am trying to ask if types defined in <code>std</code> are ever <strong>user-defined type</strong> s.  A secondary question is, even if not, maybe <code>std::tuple&lt;int&gt;</code> becomes a <strong>user-defined type</strong> when used by a user (this gets slippery: what then happens if something inside <code>std</code> defines <code>std::tuple&lt;int&gt;</code>, and you partial-specialize <code>hash</code> for <code>std::tuple&lt;Ts...&gt;</code>).</p>\n<hr>\n<p>There is currently an <a href=\"https://cplusplus.github.io/LWG/lwg-active.html#2139\" rel=\"noreferrer\">open defect</a> on this problem.</p>\n</hr>", "Tags": "<c++><c++11><language-lawyer><template-specialization><c++14>", "OwnerUserId": "1774667", "AnswerCount": "4"}});