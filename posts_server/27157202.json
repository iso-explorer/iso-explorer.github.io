post_cb({"27157202": {"CommentCount": "2", "ViewCount": "296", "PostTypeId": "1", "FavoriteCount": "0", "CreationDate": "2014-11-26T19:18:44.827", "LastActivityDate": "2014-11-26T22:33:30.923", "LastEditDate": "2014-11-26T19:31:18.440", "LastEditorDisplayName": "user3920237", "Title": "Can it be safe to keep a copy of an std::initializer_list? What is the rationale?", "Id": "27157202", "Score": "5", "Body": "<p>In my environment, the <code>std::initializer_list</code> is implemented as a pointer to the first element, and a size. Still in my specific setup, I was able to observe that:</p>\n<ul>\n<li>the underlying data is allocated in the current function frame (because the pointer to the first element says so)</li>\n<li>returning an <code>initializer_list</code> by value from a function does not change the value of the pointer (leading to the conclusion that the data is not copied alongside the initializer_list).</li>\n</ul>\n<p>This is making it unsafe to copy an <code>initializer_list</code>, <strong>if the copy can outlive the original object</strong>.</p>\n<ul>\n<li>Will this behavior be maintained by further releases of the C++ standard ?</li>\n<li>And equally important, what would be the rationale behind this behaviour ? (it bit me really hard today, so I would na\u00efvely say it goes against the beloved principle of \"least astonishment\")</li>\n</ul>\n", "Tags": "<c++><c++11><c++14><initializer-list>", "OwnerUserId": "1027706", "AnswerCount": "1"}, "27157506": {"ParentId": "27157202", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2014-11-26T19:36:15.717", "Score": "6", "LastEditorUserId": "1484212", "LastEditDate": "2014-11-26T22:33:30.923", "Id": "27157506", "OwnerUserId": "1484212", "Body": "<p>From the C++11 standard, 18.9 [support.initlist]:</p>\n<blockquote>\n<p id=\"so_27157202_27157506_0\"><sup>2</sup> An object of type initializer_list provides access to an array of objects of type const E. [ Note: A pair of pointers or a pointer plus a length would be obvious representations for initializer_list. initializer_list is used to implement initializer lists as specified in 8.5.4. <strong>Copying an initializer list does not copy the underlying elements.</strong> \u2014 end note ]</p>\n</blockquote>\n<p>It's like taking pointers to objects. You can also make the pointer outlive the object. If you want to do it \"safely\", take/store a vector of elements instead.</p>\n<p>Copying the elements would make it expensive, and thus nobody would use it. The <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow\">documentation available</a> makes it very clear about what it does.</p>\n<p><strong>EDIT:</strong></p>\n<p>This is Stroustrup's proposal for <code>initializer_list</code>: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf\" rel=\"nofollow\">N2100</a>. Reading it might enlighten on its design decisions.</p>\n", "LastActivityDate": "2014-11-26T22:33:30.923"}, "bq_ids": {"n4140": {"so_27157202_27157506_0": {"section_id": 6955, "quality": 0.8529411764705882, "length": 29}}, "n3337": {"so_27157202_27157506_0": {"section_id": 6702, "quality": 0.8529411764705882, "length": 29}}, "n4659": {"so_27157202_27157506_0": {"section_id": 8452, "quality": 0.8529411764705882, "length": 29}}}});