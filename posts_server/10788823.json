post_cb({"10789707": {"ParentId": "10788823", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes, you're correct, that was pointed out in the \"PODs revisited\" proposals: <a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2007/n2342.htm#ABI\">http://www.open-std.org/jtc1/sc22/WG21/docs/papers/2007/n2342.htm#ABI</a></p>\n<p>The Embarcadero compiler docs also state it: <a href=\"http://docwiki.embarcadero.com/RADStudio/en/Is_standard_layout\">http://docwiki.embarcadero.com/RADStudio/en/Is_standard_layout</a></p>\n<p>Another key point is [class.mem]/16</p>\n<blockquote>\n<p id=\"so_10788823_10789707_0\">Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).</p>\n</blockquote>\n<p>Note that only data members affect layout compatibility, not base classes, so these two standard layout classes are layout-compatible:</p>\n<pre><code>struct empty { };\nstruct stdlayout1 : empty { int i; };\n\nstruct stdlayout2 { int j; };\n</code></pre>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2012-05-28T19:49:14.797", "Id": "10789707", "Score": "21", "CreationDate": "2012-05-28T19:42:57.883", "LastActivityDate": "2012-05-28T19:49:14.797"}, "bq_ids": {"n4140": {"so_10788823_10788823_0": {"section_id": 5851, "quality": 1.0, "length": 10}, "so_10788823_10789707_0": {"section_id": 5876, "quality": 0.9545454545454546, "length": 21}, "so_10788823_10788823_2": {"section_id": 5851, "quality": 0.875, "length": 7}, "so_10788823_10788823_1": {"section_id": 369, "quality": 0.7142857142857143, "length": 5}, "so_10788823_10788823_4": {"section_id": 5851, "quality": 1.0, "length": 19}, "so_10788823_10788823_6": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}, "so_10788823_10788823_5": {"section_id": 5851, "quality": 1.0, "length": 8}}, "n3337": {"so_10788823_10788823_0": {"section_id": 5621, "quality": 1.0, "length": 10}, "so_10788823_10789707_0": {"section_id": 5647, "quality": 1.0, "length": 22}, "so_10788823_10788823_2": {"section_id": 5621, "quality": 0.875, "length": 7}, "so_10788823_10788823_1": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_10788823_10788823_4": {"section_id": 5621, "quality": 1.0, "length": 19}, "so_10788823_10788823_6": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}, "so_10788823_10788823_5": {"section_id": 5621, "quality": 1.0, "length": 8}}, "n4659": {"so_10788823_10788823_5": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_10788823_10788823_0": {"section_id": 7330, "quality": 1.0, "length": 10}, "so_10788823_10788823_2": {"section_id": 7330, "quality": 0.875, "length": 7}, "so_10788823_10788823_1": {"section_id": 383, "quality": 0.7142857142857143, "length": 5}, "so_10788823_10789707_0": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}, "so_10788823_10788823_6": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}, "so_10788823_10788823_4": {"section_id": 7330, "quality": 0.7894736842105263, "length": 15}}}, "10788823": {"CommentCount": "12", "AcceptedAnswerId": "10789707", "PostTypeId": "1", "LastEditorUserId": "927034", "CreationDate": "2012-05-28T18:11:47.357", "LastActivityDate": "2012-05-28T19:49:14.797", "LastEditDate": "2012-05-28T18:38:55.597", "ViewCount": "1276", "FavoriteCount": "2", "Title": "Is the Empty Base Class Optimization now a mandatory optimization (at least for standard-layout classes)?", "Id": "10788823", "Score": "26", "Body": "<p>According to <strong>C++11</strong> <em>9.1/7 (draft n3376)</em>, a <em>standard-layout</em> class is a class that:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_10788823_10788823_0\">has no non-static data members of type non-standard-layout class (or array of such types) or reference,</p></li>\n<li><p id=\"so_10788823_10788823_1\">has no virtual functions (10.3) and no virtual base classes (10.1),</p></li>\n<li><p id=\"so_10788823_10788823_2\">has the same access control (Clause11) for all non-static data members,</p></li>\n<li><p id=\"so_10788823_10788823_3\">has no non-standard-layout base classes,</p></li>\n<li><p id=\"so_10788823_10788823_4\">either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</p></li>\n<li><p id=\"so_10788823_10788823_5\">has no base classes of the same type as the first non-static data member.</p></li>\n</ul>\n</blockquote>\n<p>it follows that an empty class is a <em>standard-layout</em> class; and that another class with an empty class as a base is also a <em>standard-layout</em> class provided the first non-static data member of such class is not of the same type as the base.</p>\n<p>Furthermore, <em>9.2/19</em> states that:</p>\n<blockquote>\n<p id=\"so_10788823_10788823_6\">A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note]</p>\n</blockquote>\n<p>This seems to imply that the <em>Empty Base Class Optimization</em> is now a mandatory optimization, at least for <em>standard-layout</em> classes. My point is that if the empty base optimization isn't mandated, then the layout of a <em>standard-layout</em> class would not be standard but rather depend on whether the implementation implements or not said optimization. Is my reasoning correct, or am I missing something?</p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "927034", "AnswerCount": "1"}});