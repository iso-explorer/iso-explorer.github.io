post_cb({"29023601": {"ViewCount": "2361", "Body": "<p>Assume:</p>\n<pre><code>switch ( test ) {\n\n  // Set some variables, call some functions ?\n  int x = 1 ;\n  int y = function(x) ;\n  //\n\n  case 1 : \n    // Process for test = 1\n    ...\n    break;\n\n  case 5 : \n    // Process for test = 5\n    ...\n    break;\n\n  default : \n    // Process for all other cases.\n    ...\n\n}\n</code></pre>\n<p>Is it 'legal' to execute that extra bit of code I added before the first <code>case</code>?  I've never seen this in examples.</p>\n", "AcceptedAnswerId": "29023816", "Title": "Can I put code outside of cases in a switch?", "CreationDate": "2015-03-13T01:54:43.673", "Id": "29023601", "CommentCount": "8", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-03-13T06:19:00.700", "LastEditorUserId": "4577158", "LastActivityDate": "2015-05-22T06:32:56.860", "Score": "7", "OwnerUserId": "2650419", "Tags": "<c++><c>", "AnswerCount": "5"}, "29902726": {"Id": "29902726", "PostTypeId": "2", "Body": "<p>Control <em>can</em> reach statements in between the <code>switch</code> head and the first <code>case</code> expression -- but <em>some other</em> control structure has to send it there.  For instance, there is nothing stopping you from <a href=\"http://www.catb.org/jargon/html/D/Duffs-device.html\" rel=\"nofollow\">interlacing a switch and a loop</a>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int x = 1;\n    switch (x) {\n        do {\n            printf(\"got here with x=%d\\n\", x);\n    case 2:\n            puts(\"case two or loop\");\n    case 1:\n            puts(\"case one or loop\");\n        } while (++x &lt; 3);\n    }\n    return 0;\n}\n</code></pre>\n<p>compiles without any complaints from either gcc 4.9 or clang 3.5 in <code>-std=c11</code> mode with the warnings cranked up as high as they will go, and when run, prints:</p>\n<pre><code>case one or loop\ngot here with x=2\ncase two or loop\ncase one or loop\n</code></pre>\n<p>Fun fact: with optimization enabled, both compilers will actually generate 100% straight-line code:</p>\n<pre><code>main:\n    subq    $8, %rsp\n    movl    $.LC0, %edi\n    call    puts\n    movl    $2, %esi\n    movl    $.LC1, %edi\n    xorl    %eax, %eax\n    call    printf\n    movl    $.LC2, %edi\n    call    puts\n    movl    $.LC0, %edi\n    call    puts\n    xorl    %eax, %eax\n    addq    $8, %rsp\n    ret\n</code></pre>\n", "LastActivityDate": "2015-04-27T17:54:32.847", "Score": "2", "CreationDate": "2015-04-27T17:54:32.847", "ParentId": "29023601", "CommentCount": "0", "OwnerUserId": "388520"}, "bq_ids": {"n4140": {"so_29023601_29023816_2": {"length": 5, "quality": 0.625, "section_id": 3878}}, "n3337": {"so_29023601_29023816_2": {"length": 5, "quality": 0.625, "section_id": 3738}}, "n4659": {"so_29023601_29023816_2": {"length": 5, "quality": 0.625, "section_id": 4767}}}, "29023816": {"Id": "29023816", "PostTypeId": "2", "Body": "<p>First some background on how <code>switch</code> (really) works:</p>\n<p>A <code>switch</code> is usually thought of as a construct that selects a piece of code to execute depending on the value of some expression, as in</p>\n<pre><code>switch (x) {\ncase 1:\n    foo();\n    break;\n\ncase 2:\n    bar();\n    break;\n}\n</code></pre>\n<p>However, it's more accurate to think of a <code>switch</code> as a form of computed <code>goto</code> statement. For example, the following is perfectly legal:</p>\n<pre><code>switch (x) {\n    puts(\"I can't be reached\");\ncase 1:\n    if (cond) {\ncase 2:\n        puts(\"Either x == 1 &amp;&amp; cond, or x == 2\");\n    }\n}\n</code></pre>\n<p>Depending on the value of <code>x</code>, the program will jump to either <code>case 1</code> or <code>case 2</code> (or past the <code>switch</code> if <code>x</code> is neither 1 nor 2).</p>\n<hr>\n<p>Your program will compile as C (with junk values for <code>x</code> and <code>y</code> inside the <code>switch</code>, since the initializations are skipped), but not as C++. The reason is that C++ does not allow a jump to a <code>case</code> label to cross the initialization of a variable. For simple types like <code>int</code>, skipping over <code>int x;</code> is allowed (since no initialization is involved), but not skipping over <code>int x = 1;</code>.</p>\n<p>The main motivation for this difference is probably that letting a jump to a <code>case</code> label cross an initialization in C++ would be unsafe when constructors are involved. For example, if C++ allowed a <code>case</code> label to occur after a definition <code>My_class my_object</code> within some scope, then jumping to that <code>case</code> label would skip <code>my_object</code>'s constructor but still run its destructor when exiting the scope.</p>\n<p>The same restrictions apply to <code>goto</code> in C++. You can't use it to jump into a block and past a variable initialization.</p>\n<hr>\n<p>As a side note, <code>switch</code> follows the same general syntax as <code>if</code> and <code>while</code>. The syntax of <code>if</code> as given in the C11 standard (ISO/IEC 9899:2011, section 6.8.4) is</p>\n<blockquote>\n<p id=\"so_29023601_29023816_0\"><strong>if</strong> ( expression ) statement</p>\n</blockquote>\n<p>, while the syntax of <code>switch</code> is</p>\n<blockquote>\n<p id=\"so_29023601_29023816_1\"><strong>switch</strong> ( expression ) statement</p>\n</blockquote>\n<p>The only difference as far as <em>statement</em> is concerned (in C -- C++ adds some more limitations as mentioned above) is that it is allowed to contain <code>case</code> labels (and <code>break</code>) for a <code>switch</code> but not for an <code>if</code> (unless the <code>if</code> occurs within a <code>switch</code>).</p>\n<p>Just as with an <code>if</code>, you can even leave off the braces and write code like the following. (Whether this is unnecessarily confusing is another discussion.)</p>\n<pre><code>switch (x) case 1: case 2: puts(\"x is 1 or 2\");\n</code></pre>\n<p>Syntactically, <code>case</code> and <code>default</code> labels belong in the same category as <code>goto</code> labels. Section 6.8.1 of the C11 standard has the following definition:</p>\n<blockquote>\n<p id=\"so_29023601_29023816_2\"><em>labeled-statement:</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>identifier</em> <strong>:</strong> <em>statement</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<strong>case</strong> <em>constant-expression</em> <strong>:</strong> <em>statement</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<strong>default</strong> <strong>:</strong> <em>statement</em> </br></br></br></p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "4577158", "LastActivityDate": "2015-05-22T06:32:56.860", "Score": "11", "CreationDate": "2015-03-13T02:17:54.360", "ParentId": "29023601", "CommentCount": "3", "LastEditDate": "2015-05-22T06:32:56.860", "OwnerUserId": "4577158"}, "29023747": {"Id": "29023747", "PostTypeId": "2", "Body": "<p>I tried to compile a code similar to what you ask, it comes out at least one error:</p>\n<blockquote>\n<p id=\"so_29023601_29023747_0\">error C2360: initialization of 'x' is skipped by 'case' label</p>\n</blockquote>\n<p>Your extra bit of code has never been executed because after switch check the statement 'test', then it will go to corresponding label, your extra bit of code is not under any label, therefore it is forever been skipped.</p>\n<p>Why you can't put your extra bit of code before the switch statement? any reason?</p>\n", "LastActivityDate": "2015-03-13T02:09:38.483", "Score": "0", "CreationDate": "2015-03-13T02:09:38.483", "ParentId": "29023601", "CommentCount": "0", "OwnerUserId": "3230406"}, "29023773": {"Id": "29023773", "PostTypeId": "2", "Body": "<p>It is not legal, and when you compile you will get a bunch of \"crosses initialization of ...\" errors.  There's a really good explanation of what's going on here:\n<a href=\"https://stackoverflow.com/questions/11578936/getting-a-bunch-of-crosses-initialization-error\">Getting a bunch of crosses initialization error</a></p>\n<p>Essentially, a switch case works by jumping over any code in between the case statements, and it's illegal to jump past the initialization of a variable.  It will technically be legal, and will compile, if you just put a function call in between the two, although the function will never actually be called.</p>\n<pre><code>int test = 1;\nint x = 1 ; \nswitch ( test ) { \n\n    //Technically legal, although will never be called.\n    std::cout&lt;&lt;somefunc(x)&lt;&lt;std::endl;;  \n\n    //jumps straight here, over any code above it\n    case 1 : \n        std::cout&lt;&lt;\"1\"&lt;&lt;std::endl;\n        break;\n\n    case 5 : \n        std::cout&lt;&lt;\"5\"&lt;&lt;std::endl;\n        break;\n\n    default : \n        std::cout&lt;&lt;\"Default.\"&lt;&lt;std::endl;\n}  \n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-13T02:17:33.620", "Score": "1", "CreationDate": "2015-03-13T02:12:24.413", "ParentId": "29023601", "CommentCount": "2", "LastEditDate": "2017-05-23T12:21:51.003", "OwnerUserId": "2581698"}, "29023758": {"Id": "29023758", "PostTypeId": "2", "Body": "<p>You can find out what happens with a simple test:</p>\n<pre><code>int w = 1;\n\nswitch (w)\n{\n    int i = 3;\n    int y = foo(i);\n\ncase 1:\n    printf(\"here %d\\n\", y);\n    printf(\"here %d\\n\", i);\n    break;\n\ncase 2:\n    printf(\"not here\\n\");\n    break;\n}\n</code></pre>\n<p>This code will compile inside of a function using <code>gcc</code>. The C compiler sees <code>i</code> and <code>y</code> declared inside of a block delimited by the braces, so will accept it. However, the <code>printf</code> statements will print junk for <code>i</code> and <code>y</code>, because the assignments are never executed. This is because a <code>switch</code> statement forms a jump to the <code>case</code> which corresponds to the expression at the head of the <code>switch</code>. So the executable code between the opening brace and the first <code>case</code> cannot be reached. See <a href=\"https://stackoverflow.com/questions/92396/why-cant-variables-be-declared-in-a-switch-statement\">Why can't variables be declared in a switch statement?</a>, which doesn't explain exactly the same scenario, but does have some related discussion about the <code>switch</code> statement.</p>\n<p>If you compile this with warnings turned on (<code>gcc -Wall</code>), you get:</p>\n<pre><code>foo.c: In function \u2018main\u2019:\nfoo.c:19:15: warning: \u2018y\u2019 may be used uninitialized in this function [-Wuninitialized]\nfoo.c:20:15: warning: \u2018i\u2019 may be used uninitialized in this function [-Wuninitialized]\n</code></pre>\n<p>Interestingly, the following code will compile without warnings and work:</p>\n<pre><code>int w = 1;\n\nswitch (w)\n{\n    int i;\n    int y;\n\ncase 1:\n    i = 2; y = 3 * i;\n    printf(\"here %d\\n\", y);\n    printf(\"here %d\\n\", i);\n    break;\n\ncase 2:\n    i = 1; y = 2;\n    printf(\"here %d\\n\", y);\n    printf(\"here %d\\n\", i);\n    break;\n}\n</code></pre>\n<p>The variables print as you would expect them to as they're declared within the scope of the <code>switch</code> block, and values set within the <code>case</code> sections where execution occurs. The fact that it works in this case is not to say that it is recommended practice. :)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-13T10:12:32.907", "Score": "7", "CreationDate": "2015-03-13T02:10:38.677", "ParentId": "29023601", "CommentCount": "0", "LastEditDate": "2017-05-23T11:43:43.177", "OwnerUserId": "980550"}});