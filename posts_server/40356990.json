post_cb({"bq_ids": {"n4140": {"so_40356990_40357386_0": {"length": 9, "quality": 0.9, "section_id": 307}, "so_40356990_40357386_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 335}, "so_40356990_40357386_1": {"length": 12, "quality": 1.0, "section_id": 307}}, "n3337": {"so_40356990_40357386_0": {"length": 9, "quality": 0.9, "section_id": 298}, "so_40356990_40357386_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 325}, "so_40356990_40357386_1": {"length": 12, "quality": 1.0, "section_id": 298}}, "n4659": {"so_40356990_40357386_0": {"length": 9, "quality": 0.9, "section_id": 325}, "so_40356990_40357386_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 344}, "so_40356990_40357386_1": {"length": 12, "quality": 1.0, "section_id": 314}}}, "40357386": {"Id": "40357386", "PostTypeId": "2", "Body": "<p>As noted in the answer to your linked question:</p>\n<blockquote>\n<p id=\"so_40356990_40357386_0\"><code>[temp.deduct.call]/6:</code>When <code>P</code> is a function type, pointer to function type, or pointer to member function type:</p>\n<p id=\"so_40356990_40357386_1\">\u2014 If the argument is an overload set containing one or more function templates, the parameter is treated\n  as a non-deduced context.</p>\n</blockquote>\n<p>Since the overload set contains a function template, the parameter is treated as a non-deduced context. This causes template argument deduction to fail:</p>\n<blockquote>\n<p id=\"so_40356990_40357386_2\"><code>[temp.deduct.type]/4:</code> [...]If a template parameter is used only in non-deduced\n  contexts and is not explicitly specified, template argument deduction fails.</p>\n</blockquote>\n<p>And this failed deduction gives you your error. Note that if you explicitly specify the arguments, the code compiles successfully:</p>\n<pre><code>bar&lt;int,double&gt;(foo);\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7d361ed80478a293\" rel=\"nofollow noreferrer\">Live demo</a></p>\n", "LastEditorUserId": "496161", "LastActivityDate": "2016-11-01T10:18:08.367", "Score": "19", "CreationDate": "2016-11-01T09:36:47.617", "ParentId": "40356990", "CommentCount": "0", "OwnerUserId": "496161", "LastEditDate": "2016-11-01T10:18:08.367"}, "40356990": {"ViewCount": "548", "Body": "<p>This is the <em>more sophisticated question</em> mentioned in <a href=\"https://stackoverflow.com/questions/40343663/how-does-overload-resolution-work-when-an-argument-is-an-overloaded-function\">How does overload resolution work when an argument is an overloaded function?</a></p>\n<p>Below code <a href=\"https://godbolt.org/g/3wWmJK\" rel=\"nofollow noreferrer\">compiles without any problem</a>:</p>\n<pre><code>void foo() {}\nvoid foo(int) {}\nvoid foo(double) {}\nvoid foo(int, double) {}\n\n// Uncommenting below line break compilation\n//template&lt;class T&gt; void foo(T) {}\n\ntemplate&lt;class X, class Y&gt; void bar(void (*f)(X, Y))\n{\n    f(X(), Y());\n}\n\nint main()\n{\n    bar(foo);\n}\n</code></pre>\n<p>It doesn't appear a challenging task for template argument deduction - there is only one function <code>foo()</code> that accepts two arguments. However, uncommenting the template overload of <code>foo()</code> (which still has just a single parameter) breaks compilation for no obvious reason. Compilation fails both with gcc 5.x/6.x and clang 3.9.</p>\n<p>Can it be explained by the rules of overload resolution/template argument deduction or it should be qualified as a defect in those compilers?</p>\n", "AcceptedAnswerId": "40357386", "Title": "How does template argument deduction work when an overloaded function is involved as an argument?", "CreationDate": "2016-11-01T09:10:23.997", "Id": "40356990", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:33:01.713", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-01T10:18:08.367", "Score": "20", "OwnerUserId": "6394138", "Tags": "<c++><language-lawyer><overload-resolution><argument-deduction>", "AnswerCount": "1"}});