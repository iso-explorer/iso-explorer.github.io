post_cb({"25332548": {"ParentId": "25332245", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-08-15T19:01:20.760", "Score": "4", "LastEditorUserId": "2527797", "LastEditDate": "2014-08-15T19:06:25.340", "Id": "25332548", "OwnerUserId": "2527797", "Body": "<p>The difference is definitely not about the safety = atomicity which is guaranteed for both methods.</p>\n<p>The most important difference I think is that <code>fetch_add()</code> can take a different memory order argument while for increment operator it is always <code>memory_order_seq_cst</code>.</p>\n<p>Another obvious difference is that <code>fetch_add()</code> can take not only <code>1</code> as argument while on the other hand, <code>operator++</code> is more likely to be implemented using <code>lock inc</code> instruction (though, theoretically nothing prevents a compiler from such an optimization for <code>fetch_add(1)</code> as well)</p>\n<p>So answering your exact question, there is no any semantically important difference between <code>x++</code> and <code>x.fetch_add(1)</code>. The <a href=\"http://www.cplusplus.com/reference/atomic/atomic/operatorplusplus/\" rel=\"nofollow\">doc says</a>:</p>\n<blockquote>\n<p id=\"so_25332245_25332548_0\">This function behaves as if atomic::fetch_add was called with 1 and memory_order_seq_cst as arguments.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-15T19:06:25.340"}, "25332245": {"CommentCount": "1", "ViewCount": "1547", "PostTypeId": "1", "LastEditorUserId": "922184", "CreationDate": "2014-08-15T18:41:42.460", "LastActivityDate": "2015-06-17T12:10:42.350", "Title": "std::atomic<int>: Difference between x.fetch_add(1) and x++;", "AcceptedAnswerId": "25332548", "LastEditDate": "2014-08-15T18:58:21.720", "Id": "25332245", "Score": "6", "Body": "<p>What is the difference between</p>\n<pre><code>extern std::atomic&lt;int&gt; x;\nint i = x++;\n</code></pre>\n<p>and</p>\n<pre><code>extern std::atomic&lt;int&gt; x;\nint i = x.fetch_add(1);\n</code></pre>\n<p>I feel like the second version is safer, but I couldn't see any differences in testing between these two versions.</p>\n", "Tags": "<c++><multithreading><c++11><parallel-processing><atomic>", "OwnerUserId": "904050", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25332245_30877160_1": {"section_id": 1181, "quality": 1.0, "length": 9}}, "n3337": {"so_25332245_30877160_1": {"section_id": 1179, "quality": 1.0, "length": 9}}, "n4659": {"so_25332245_30877160_1": {"section_id": 7687, "quality": 0.5555555555555556, "length": 5}}}, "30877160": {"ParentId": "25332245", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-06-16T20:05:52.447", "Score": "2", "LastEditorUserId": "895245", "LastEditDate": "2015-06-17T12:10:42.350", "Id": "30877160", "OwnerUserId": "895245", "Body": "<p><strong>C++11</strong></p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">C++11 N3337 draft</a> 29.6.5/33 \"Requirements for operations on atomic types\":</p>\n<pre><code>C A ::operator++(int) volatile noexcept;\nC A ::operator++(int) noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_25332245_30877160_0\">Returns: fetch_add(1)</p>\n</blockquote>\n<p>29.6.5/2 clarifies <code>C</code> and <code>A</code>:</p>\n<blockquote id=\"so_25332245_30877160_1\">\n<ul>\n<li>an A refers to one of the atomic types.</li>\n<li>a C refers to its corresponding non-atomic type</li>\n</ul>\n</blockquote>\n<p>I wasn't able to find it explained clearly but I suppose <code>Returns: fetch_add(1)</code> implies that <code>fetch_add(1)</code> is called for its side effect of course.</p>\n<p>It is also worth looking at the prefix version a bit further:</p>\n<pre><code>C A ::operator++() volatile noexcept;\nC A ::operator++() noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_25332245_30877160_2\">Effects: fetch_add(1)</p>\n<p id=\"so_25332245_30877160_3\">Returns: fetch_add(1) + 1</p>\n</blockquote>\n<p>which indicates that this one returns the value + 1 like the regular prefix increment for integers.</p>\n<p><strong>GCC 4.8</strong></p>\n<p><a href=\"https://github.com/gcc-mirror/gcc/blob/gcc-4_8_2-release/libstdc%2B%2B-v3/include/std/atomic#L594\" rel=\"nofollow\">libstdc++-v3/include/std/atomic</a> says <code>atomic&lt;int&gt;</code> inherits <code>__atomic_base&lt;int&gt;</code>:</p>\n<pre><code>struct atomic&lt;int&gt; : __atomic_base&lt;int&gt;\n</code></pre>\n<p><a href=\"https://github.com/gcc-mirror/gcc/blob/gcc-4_8_2-release/libstdc%2B%2B-v3/include/bits/atomic_base.h#L387\" rel=\"nofollow\">libstdc++-v3/include/bits/atomic_base.h</a> implements it like:</p>\n<pre><code>__int_type\noperator++(int) noexcept\n{ return fetch_add(1); }\n\n__int_type\noperator++(int) volatile noexcept\n{ return fetch_add(1); }\n\n__int_type\noperator++() noexcept\n{ return __atomic_add_fetch(&amp;_M_i, 1, memory_order_seq_cst); }\n\n__int_type\noperator++() volatile noexcept\n{ return __atomic_add_fetch(&amp;_M_i, 1, memory_order_seq_cst); }\n\n_GLIBCXX_ALWAYS_INLINE __int_type\nfetch_add(__int_type __i,\nmemory_order __m = memory_order_seq_cst) noexcept\n{ return __atomic_fetch_add(&amp;_M_i, __i, __m); }\n\n_GLIBCXX_ALWAYS_INLINE __int_type\nfetch_add(__int_type __i,\nmemory_order __m = memory_order_seq_cst) volatile noexcept\n{ return __atomic_fetch_add(&amp;_M_i, __i, __m); }\n</code></pre>\n<p>I do not understand why the postfix calls the <code>fetch_add</code> helper and the prefix uses the built-in directly, but in the end they all come down to the GCC intrinsics <code>__atomic_fetch_add</code> and <code>__atomic_add_fetch</code> which do the real work.</p>\n", "LastActivityDate": "2015-06-17T12:10:42.350"}});