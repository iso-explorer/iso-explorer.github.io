post_cb({"bq_ids": {"n4140": {"so_28766075_28766204_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 7136}, "so_28766075_28766204_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 7043}}, "n3337": {"so_28766075_28766204_1": {"length": 22, "quality": 0.9166666666666666, "section_id": 6880}, "so_28766075_28766204_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 6788}}, "n4659": {"so_28766075_28766204_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 8637}, "so_28766075_28766204_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 8540}}}, "28766075": {"ViewCount": "168", "Body": "<p>Consider the following code:</p>\n<pre><code>const int a = 0;\nconst std::string b = \"hi\";\n\ninline void f_a1()\n{\n    std::cout &lt;&lt; a;\n}\n\ninline void f_b1()\n{\n    std::cout &lt;&lt; b;\n}\n\ninline void f_a2()\n{\n    std::cout &lt;&lt; &amp;a;\n}\n\ninline void f_b2()\n{\n    std::cout &lt;&lt; &amp;b;\n}\n</code></pre>\n<p>Assume this code exists in a header file that will be included in multiple translation units.</p>\n<p>My understanding of inline functions is that they must be exactly the same in every translation unit.</p>\n<p>My understanding of constants as used above, is that they are implictly <code>static</code> ie internal linkage. These means each translation unit gets its own copy.</p>\n<p>As the inline functions above rely on these constants, which of these functions, if any, are correct?</p>\n", "AcceptedAnswerId": "28766204", "Title": "Can an inline function in a header file use a constant which has internal linkage?", "CreationDate": "2015-02-27T13:17:30.393", "Id": "28766075", "CommentCount": "6", "LastEditDate": "2015-10-28T22:37:12.677", "PostTypeId": "1", "LastEditorUserId": "1505939", "LastActivityDate": "2015-10-28T22:37:12.677", "Score": "6", "OwnerUserId": "2068573", "Tags": "<c++><const><inline><linkage><one-definition-rule>", "AnswerCount": "1"}, "28766204": {"Id": "28766204", "PostTypeId": "2", "Body": "<p>If included into multiple translation units, the only function that is valid is <code>f_a1</code>.</p>\n<p>The relevant clause is <strong>[basic.def.odr]</strong>/6, which states that an <code>inline</code> function can appear in multiple translation units, but only given that:</p>\n<blockquote>\n<p id=\"so_28766075_28766204_0\">[...] a name can refer to a non-volatile\n  <code>const</code> object with internal or no linkage if the object has the same literal type in all de\ufb01nitions of D,\n  and the object is initialized with a constant expression (5.19), and the object is not odr-used, and the\n  object has the same value in all definitions of D;</p>\n</blockquote>\n<p>As the objects are <code>const</code>, they have internal linkage per <strong>[basic.link]</strong>/3:</p>\n<blockquote>\n<p id=\"so_28766075_28766204_1\">A name having namespace scope (3.3.6) has internal linkage if it is the name of [...]<br/>\n  \u2014 a non-volatile variable that is explicitly declared const or constexpr and neither explicitly declared\n  extern nor previously declared to have external linkage [...]</p>\n</blockquote>\n<p>However, taking the address of or forming a reference to a variable (e.g. for argument passing) is <em>odr-use</em>, so <code>f_a2</code> and <code>f_b2</code> are invalid.  <code>f_b1</code> is also invalid, as the <code>ostream</code> output operator for <code>std::string</code> takes its argument by reference; and even if it took its argument by value the implicitly called copy constructor would take <em>its</em> argument by reference.  <code>f_a1</code> is OK because the <code>int</code> stream-out operator takes its argument by value, and copying the value of an <code>int const</code> is not odr-use.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2015-02-27T13:51:58.940", "Score": "6", "CreationDate": "2015-02-27T13:25:30.767", "ParentId": "28766075", "CommentCount": "6", "OwnerUserId": "567292", "LastEditDate": "2015-02-27T13:51:58.940"}});