post_cb({"16823949": {"ParentId": "16823501", "CommentCount": "1", "Body": "<p>Not an answer, but some details (gcc) too large for a comment:</p>\n<p>Function is checked for validity with </p>\n<pre><code>template&lt;typename _Signature&gt;\n  static bool\n  _M_not_empty_function(const function&lt;_Signature&gt;&amp; __f)\n  { return static_cast&lt;bool&gt;(__f); }\n\ntemplate&lt;typename _Tp&gt;\n  static bool\n  _M_not_empty_function(const _Tp*&amp; __fp)\n  { return __fp; }\n\ntemplate&lt;typename _Class, typename _Tp&gt;\n  static bool\n  _M_not_empty_function(_Tp _Class::* const&amp; __mp)\n  { return __mp; }\n\ntemplate&lt;typename _Tp&gt;\n  static bool\n  _M_not_empty_function(const _Tp&amp;)\n  { return true; }\n</code></pre>\n<p>Probably </p>\n<pre><code>template&lt;typename _Tp&gt;\n  static bool\n  _M_not_empty_function(const _Tp*&amp; __fp)\n  { return __fp; }\n</code></pre>\n<p>is intended to work with functional pointers, buit it doesn't. Instead general case is used that is probably intended  for functional objects only.</p>\n<pre><code>template&lt;typename _Tp&gt;\n    static bool\n    M_not_empty_function(const _Tp*&amp; __fp)\n    { return __fp; }\n\nint main()\n{\n    typedef void (*fp_t)();\n    fp_t fp = nullptr;\n    return  M_not_empty_function(fp);\n}\n</code></pre>\n<p>generates </p>\n<pre><code>error: no matching function for call to 'M_not_empty_function(void (*&amp;)())'\nnote: candidate is:\nnote: template&lt;class _Tp&gt; bool M_not_empty_function(const _Tp*&amp;)\nnote:   template argument deduction/substitution failed:\nnote:   types 'const _Tp' and 'void()' have incompatible cv-qualifiers\n</code></pre>\n", "OwnerUserId": "774651", "PostTypeId": "2", "Id": "16823949", "Score": "4", "CreationDate": "2013-05-29T21:16:34.277", "LastActivityDate": "2013-05-29T21:16:34.277"}, "bq_ids": {"n4140": {"so_16823501_16823501_2": {"section_id": 4661, "quality": 0.6923076923076923, "length": 9}, "so_16823501_16823501_0": {"section_id": 4658, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_16823501_16823501_2": {"section_id": 4471, "quality": 0.9230769230769231, "length": 12}, "so_16823501_16823501_0": {"section_id": 4469, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_16823501_16823501_2": {"section_id": 6031, "quality": 0.6923076923076923, "length": 9}, "so_16823501_16823501_0": {"section_id": 1401, "quality": 0.6666666666666666, "length": 4}}}, "16823501": {"CommentCount": "8", "AcceptedAnswerId": "16823704", "PostTypeId": "1", "LastEditorUserId": "981959", "CreationDate": "2013-05-29T20:46:44.973", "LastActivityDate": "2013-05-30T09:10:02.890", "LastEditDate": "2013-05-30T09:10:02.890", "ViewCount": "6058", "FavoriteCount": "2", "Title": "std::function constructor and nullptr", "Id": "16823501", "Score": "18", "Body": "<p>Why does the following code prints \"0\" as the output?</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    typedef void (*fp_t)();\n\n    fp_t fp = nullptr;\n\n    std::function&lt;void()&gt; f = fp;\n    std::cout &lt;&lt; (f == nullptr) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>I've tested it both with gcc 4.7.2 and MSVC-11.0.</p>\n<p>I think that it's should print \"1\" because of the following quote from the standard:</p>\n<p><strong>ISO/IEC 14882:2011</strong></p>\n<p>20.8.11.2.1 function construct/copy/destroy [func.wrap.func.con]</p>\n<blockquote>\n<p id=\"so_16823501_16823501_0\"><code>template&lt;class F&gt; function(F f);</code><br>\n<code>template&lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);</code> </br></p>\n<p id=\"so_16823501_16823501_1\">...  </p>\n<p id=\"so_16823501_16823501_2\">8 <em>Postconditions:</em> <code>!*this</code> if any of the following hold: \u2014 <code>f</code> is a <code>NULL</code>\n  function pointer. \u2014 <code>f</code> is a <code>NULL</code> pointer to member. \u2014 <code>F</code> is an instance\n  of the function class template, and <code>!f</code></p>\n</blockquote>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1608835", "AnswerCount": "2"}, "16823704": {"ParentId": "16823501", "LastEditDate": "2013-05-29T21:05:41.897", "CommentCount": "13", "CreationDate": "2013-05-29T21:00:09.247", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "PostTypeId": "2", "Id": "16823704", "Score": "15", "Body": "<p>I think this is a bug. Per paragraph 20.8.11.2.6/1 of the C++11 Standard:</p>\n<blockquote>\n<pre><code>template &lt;class R, class... ArgTypes&gt;\nbool operator==(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;\n\ntemplate &lt;class R, class... ArgTypes&gt;\nbool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;\n</code></pre>\n<p id=\"so_16823501_16823704_0\">1 <strong><em>Returns</em>: <code>!f</code></strong>.</p>\n</blockquote>\n<p>Therefore, <code>(f == nullptr)</code> should evaluate to <code>true</code> if and only if <code>!f</code> evaluates to <code>true</code>. Then, paragraph 20.8.11.2.1/8 specifies:</p>\n<blockquote>\n<pre><code>template&lt;class F&gt; function(F f);\ntemplate &lt;class F, class A&gt; function(allocator_arg_t, const A&amp; a, F f);\n</code></pre>\n<p id=\"so_16823501_16823704_1\">[...]</p>\n<p id=\"so_16823501_16823704_2\">8 <strong>Postconditions: <code>!*this</code> if any of the following hold</strong>:</p>\n<blockquote>\n<p id=\"so_16823501_16823704_5\">\u2014 <strong><code>f</code> is a NULL function pointer.</strong></p>\n<p id=\"so_16823501_16823704_6\">[...]</p>\n</blockquote>\n</blockquote>\n<p>Since <code>fp</code> is a null function pointer, the above paragraph should guarantee that after initialization of <code>f</code> from <code>fp</code>, the expression <code>!f</code> evaluates to <code>true</code>. Which in turn means, that the comparison with <code>nullptr</code> should return <code>true</code> (by \u00a7 20.8.11.2.6/1).</p>\n<p>Which in turns means, that this is a bug.</p>\n", "LastActivityDate": "2013-05-29T21:05:41.897"}});