post_cb({"bq_ids": {"n4140": {"so_42754244_42754244_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 3161}, "so_42754244_42754244_1": {"length": 29, "quality": 0.8787878787878788, "section_id": 5814}}, "n3337": {"so_42754244_42754244_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 3034}, "so_42754244_42754244_1": {"length": 29, "quality": 0.8787878787878788, "section_id": 5586}}, "n4659": {"so_42754244_42754244_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 3923}}}, "42754244": {"ViewCount": "798", "Body": "<p>Visual C++ uses the Windows thread pool (Vista's <code>CreateThreadpoolWork</code> if available and <code>QueueUserWorkItem</code> if not) when calling <code>std::async</code> with <code>std::launch::async</code>.</p>\n<p>The number of threads in the pool is limited. If create several tasks that run for a long time without sleeping (including doing I/O), the upcoming tasks in the queue won't get a chance to work.</p>\n<p>The standard (I'm using N4140) says that using <code>std::async</code> with <code>std::launch::async</code></p>\n<blockquote>\n<p id=\"so_42754244_42754244_0\">... calls <code>INVOKE(DECAY_COPY(std::forward&lt;F&gt;(f)), DECAY_COPY(std::forward&lt;Args&gt;(args))...)</code> (20.9.2, 30.3.1.2) <strong>as if in a new thread of execution represented by a thread object</strong> with the calls to <code>DECAY_COPY()</code> being evaluated in the thread that called <code>async</code>.</p>\n</blockquote>\n<p>(\u00a730.6.8p3, Emphasis mine.)</p>\n<p><code>std::thread</code>'s constructor creates a new thread etc.</p>\n<p>About threads in general it says (\u00a71.10p3):</p>\n<blockquote>\n<p id=\"so_42754244_42754244_1\">Implementations should ensure that all unblocked threads eventually make progress. [<em>Note:</em> Standard library functions may silently block on I/O or locks. Factors in the execution environment, including externally-imposed thread priorities, may prevent an implementation from making certain guarantees of forward progress. \u2014<em>end note</em>]</p>\n</blockquote>\n<p>If I create a bunch of OS threads or <code>std::thread</code>s, all performing some very long (perhaps infinite) tasks, they'll all be scheduled (at least on Windows; without messing with priorities, affinities, etc.). If we schedule the same tasks to the Windows thread pool (or use <code>std::async(std::launch::async, ...)</code> which does that), the later scheduled tasks won't run until the earlier tasks will finish.</p>\n<p>Is this legal, strictly speaking? And what does \"eventually\" mean?</p>\n<hr>\n<p>The problem is that if the tasks scheduled first are <em>de-facto</em> infinite, the rest of the tasks won't run. So the other threads (not OS threads, but \"C++-threads\" according to the as-if rule) won't make progress.</p>\n<p>One may argue that if the code has infinite loops the behavior is undefined, and thus it's legal.</p>\n<p>But I argue that we don't need an infinite loop of the problematic kind the standard says causes UB to make that happen. Accessing volatile objects, performing atomic operation and synchronization operations are all side effects that \"disable\" the assumption about loops terminating.</p>\n<p>(I have a bunch of async calls executing the following lambda</p>\n<pre><code>auto lambda = [&amp;] {\n    while (m.try_lock() == false) {\n        for (size_t i = 0; i &lt; (2 &lt;&lt; 24); i++) {\n            vi++;\n        }\n        vi = 0;\n    }\n};\n</code></pre>\n<p>and the lock is released only upon user input. But there are other valid kinds of legitimate infinite loops.)</p>\n<p>If I schedule a couple of such tasks, tasks I schedule after them don't get to run.</p>\n<p>A really wicked example would be launching too many tasks that run until a lock is release/a flag is raised and then schedule using `std::async(std::launch::async, ...) a task that raises the flag. Unless the word \"eventually\" means something very surprising, this program has to terminate. But under the VC++ implementation it won't!</p>\n<p>To me it seems like a violation of the standard. What makes me wonder is the second sentence in the note. Factors may prevent implementations from making certain guarantees of forward progress. So how are these implementation conforming?</p>\n<p>It's like saying there may be factors preventing implementations from providing certain aspect of memory ordering, atomicity, or even the existence of multiple threads of execution. Great, but conforming hosted implementations must support multiple threads. Too bad for them and their factors. If they can't provide them that's not C++.</p>\n<p>Is this a relaxation of the requirement? If interpreting so, it's a complete withdrawal of the requirement, since it doesn't specify what are the factors and, more importantly, which guarantees may be not supplied by the implementations.</p>\n<p>If not - what does that note even mean?</p>\n<p>I recall footnotes being non-normative according to the ISO/IEC Directives, but I'm not sure about notes. I did find in the ISO/IEC directives the following:</p>\n<blockquote>\n<p id=\"so_42754244_42754244_2\"><strong>24 Notes</strong></p>\n<p id=\"so_42754244_42754244_3\"><strong>24.1 Purpose or rationale</strong></p>\n<p id=\"so_42754244_42754244_4\">Notes are used for giving additional information intended to assist the understanding or use of the text of the document. <em>The document shall be usable without the notes.</em></p>\n</blockquote>\n<p>Emphasis mine. If I consider the document without that unclear note, seems to me like threads must make progress, <code>std::async(std::launch::async, ...)</code> has the effect <strong>as-if</strong> the functor is execute on a new thread, as-if it was being created using <code>std::thread</code>, and thus a functors dispatched using <code>std::async(std::launch::async, ...)</code> must make progress. And in the VC++ implementation with the threadpool they don't. So VC++ is in violation of the standard in this respect.</p>\n<hr>\n<p>Full example, tested using VS 2015U3 on Windows 10 Enterprise 1607 on i5-6440HQ:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;future&gt;\n#include &lt;atomic&gt;\n\nint main() {\n    volatile int vi{};\n    std::mutex m{};\n    m.lock();\n\n    auto lambda = [&amp;] {\n        while (m.try_lock() == false) {\n            for (size_t i = 0; i &lt; (2 &lt;&lt; 10); i++) {\n                vi++;\n            }\n            vi = 0;\n        }\n        m.unlock();\n    };\n\n    std::vector&lt;decltype(std::async(std::launch::async, lambda))&gt; v;\n\n    int threadCount{};\n    std::cin &gt;&gt; threadCount;\n    for (int i = 0; i &lt; threadCount; i++) {\n        v.emplace_back(std::move(std::async(std::launch::async, lambda)));\n    }\n\n    auto release = std::async(std::launch::async, [&amp;] {\n        __asm int 3;\n        std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl;\n        vi = 123;\n        m.unlock();\n    });\n\n    return 0;\n}\n</code></pre>\n<p>With 4 or less it terminates. With more than 4 it doesn't.</p>\n<hr>\n<p>Similar questions:</p>\n<ul>\n<li><p><a href=\"https://stackoverflow.com/questions/40806894/is-there-an-implementation-of-stdasync-which-uses-thread-pool\">Is there an implementation of std::async which uses thread pool?</a> - But it doesn't question about legality, and doesn't have an answer anyway.</p></li>\n<li><p><a href=\"https://stackoverflow.com/questions/9363377/stdasync-implementation-dependent-usage\">std::async - Implementation dependent usage?</a> - Mentions that \"thread pools are not really supported\" but focuses on <code>thread_local</code> variables (which is solvable even if \"not straightforward\" or non-trivial as the answer and comment say) and doesn't address the note near the requirement of making progress.</p></li>\n</ul>\n</hr></hr></hr>", "Title": "Is the Visual C++ implementation of std::async using a thread pool legal", "CreationDate": "2017-03-12T23:01:31.507", "LastActivityDate": "2017-03-12T23:01:31.507", "CommentCount": "14", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:21.910", "LastEditorUserId": "-1", "Id": "42754244", "Score": "20", "OwnerUserId": "306930", "Tags": "<c++><c++11><visual-c++><language-lawyer><stdasync>", "AnswerCount": "0"}});