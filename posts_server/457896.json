post_cb({"766706": {"Id": "766706", "PostTypeId": "2", "Body": "<p>The following is <em>not</em> a defense of the notion of void references. I offer it as an anecdote from the wild. Ask yourself if it doesn't smell funny.</p>\n<p>My company was one of the first using C++ commercially, and initially compiled using <a href=\"http://en.wikipedia.org/wiki/Cfront\" rel=\"nofollow noreferrer\">Cfront</a>. Early developers were still learning the language, and generally using every trick in the book (operators everywhere!). Here is a trick they thought was cool:</p>\n<pre><code>void Foo::something(int action, ostream &amp;os = *(ostream *)0)\n{\n   ostream *os_p = &amp;os;\n   if (&amp;os == (ostream *)0) {\n      os_p = &amp;cerr;\n   }\n   // continue with method\n}\n</code></pre>\n<p>So here you have, not a void reference, but rather a typed reference with a potentially <em>void</em> binding! A moment's thought should probably suggest better alternatives to this particular idiom...</p>\n", "LastActivityDate": "2009-04-20T02:51:37.277", "CommentCount": "0", "CreationDate": "2009-04-20T02:51:37.277", "ParentId": "457896", "Score": "0", "OwnerUserId": "3778"}, "458347": {"Id": "458347", "PostTypeId": "2", "Body": "<p>You can think of a reference as a de-referenced pointer.  Syntactically you treat a reference as though it is not a pointer: you do not need the * operator to dereference it, and you can use . rather than -&gt; to access its members.</p>\n<p>However, you cannot dereference a <code>void</code> pointer.  As pointed out by Binary Worrier trying to do that will give you a compiler error.  And if you cannot have a dereferenced void pointer, that means you cannot have a void reference.</p>\n", "OwnerDisplayName": "Dima", "LastActivityDate": "2009-01-19T17:06:42.697", "Score": "0", "CreationDate": "2009-01-19T17:06:42.697", "ParentId": "457896", "CommentCount": "1", "OwnerUserId": "13313"}, "457963": {"Id": "457963", "PostTypeId": "2", "Body": "<p>If you did have a reference to void, what would you do with it?  It wouldn't be a number, or a character, or a pointer, or anything like that.  Your hypothetical generic function couldn't perform any operation on it, except taking its address (and not its size).</p>\n<p>\"void\" has two uses:  to disclaim any knowledge of type (as in void *), and to specify nothing as opposed to something (void function return).  In neither case is it possible to say anything about a void something except that it may have an address.</p>\n<p>If you can't think of a way something can be useful, and I can't, that is at least evidence that something is useless, and that may well be at least part of the rationale here.</p>\n", "OwnerDisplayName": "David Thornley", "LastActivityDate": "2009-01-19T15:26:16.957", "Score": "33", "CreationDate": "2009-01-19T15:26:16.957", "ParentId": "457896", "CommentCount": "8", "OwnerUserId": "14148"}, "bq_ids": {"n4140": {"so_457896_457896_0": {"length": 6, "quality": 1.0, "section_id": 3218}}, "n3337": {"so_457896_457896_0": {"length": 6, "quality": 1.0, "section_id": 3092}}, "n4659": {"so_457896_457896_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 3975}}}, "766579": {"Id": "766579", "PostTypeId": "2", "Body": "<p>OK, one thing is bugging me about this. The idea of a <code>void*</code>, as mentioned above, is that you still have a valid variable containing an address, but the type is being ignored. This seems allowable since we can still work with the address data - the type is somewhat superfluous (or less important)  in this context. Dereferencing it is bad, because to try and <em>access a member</em> doesn't make sense e.g. <code>p.mem</code>. We don't know what class to refer to, and thus the memory to jump to, the vtable pointers to follow.</p>\n<p>However, it'd then seem to make sense that <code>p</code> on its own would be OK since it'd only refer to the object, but none of its data. No class information is needed to do so, just the address. I understand there's absolutely no use for this, but it's important in defining when things break down. Allowing this notion, a C++ reference (constantly dereferenced but not accessing anything) e.g. <code>void&amp; ref = static_cast&lt; &amp;void &gt;(obj)</code> also makes sense, and thus would allow void references. I'm not saying anyone should take it up with those in charge, but from a \"making sense\" point of view, it'd seem correct, no?</p>\n<p>As Luc Touraille pointed out above (at least, this is my interpretation), it could be implemented,  but the issue is a semantic one. The reasonable explanation I could come to was that since an object variable is a \"tag\" for a sequence of memory, the type is of important semantic value. Thus, the pointer, being thought of as a variable with an address value, treats the type as somewhat superfluous - not key to defining it.</p>\n<p>Would anyone agree with that?</p>\n", "OwnerDisplayName": "Andy", "LastEditorUserId": "20984", "LastActivityDate": "2011-11-22T08:13:11.087", "Score": "1", "CreationDate": "2009-04-20T01:08:59.583", "ParentId": "457896", "CommentCount": "0", "LastEditDate": "2011-11-22T08:13:11.087"}, "458161": {"Id": "458161", "PostTypeId": "2", "Body": "<p>Technically speaking, all that is guaranteed is that a reference to an object is an alias for it. That under the hood reference argument passing is done with pointers is an implementation detail. This can be confusing because of references reusing the &amp; operator which is also address-of, but keep in mind that the operator actually has different meanings in different contexts (in a variable or parameter declaration it denotes a reference type, otherwise it's address-of, except when it's bitwise-and). Because it's technically just an alias for an object, a reference is 'always dereferenced' as Worrier explained.</p>\n", "OwnerDisplayName": "Joseph Garvin", "LastActivityDate": "2009-01-19T16:16:41.800", "Score": "1", "CreationDate": "2009-01-19T16:16:41.800", "ParentId": "457896", "CommentCount": "0", "OwnerUserId": "50385"}, "457925": {"Id": "457925", "PostTypeId": "2", "Body": "<p><strong>void</strong> is something that, by definition, doesn't exist, so it is not logical to have it's adress. </p>\n", "OwnerDisplayName": "dmajkic", "LastActivityDate": "2009-01-19T15:16:39.050", "Score": "-2", "CreationDate": "2009-01-19T15:16:39.050", "ParentId": "457896", "CommentCount": "2", "OwnerUserId": "39233"}, "457896": {"ViewCount": "12271", "Body": "<p>Why is it impossible to have a reference to void? The only thing I found in the C++ Standard is this line, at <strong>8.3.2.1</strong></p>\n<blockquote>\n<p id=\"so_457896_457896_0\">A declarator that specifies the type \"reference to <em>cv</em> void\" is ill-formed.</p>\n</blockquote>\n<p>Why is it that way? Why can't I write a \"generic\" function that accept a <code>void&amp;</code>? </p>\n<p>Just to be clear, I have no useful application in mind where using a reference-to-void could be better than using templates, but I'm just curious about the rationale for forbidding this construct.</p>\n<hr>\n<p>To clarify a little, I understand that using a reference-to-void \"as is\" would be as meaningless as dereferencing a pointer-to-void. However, I could cast it to a reference-to-<em>sometype</em> in order to use it, couldn't I? In fact, I don't see why the following snippet can work...</p>\n<pre><code>void foo(void *data)\n{\n    int *i = reinterpret_cast&lt;int*&gt;(data);\n    // do something with i\n}\n</code></pre>\n<p>...while this one cannot:</p>\n<pre><code>void foo(void &amp;data)\n{\n    int &amp;i = reinterpret_cast&lt;int&amp;&gt;(data);\n    // do something with i\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "457963", "Title": "Why is it impossible to have a reference-to-void?", "CreationDate": "2009-01-19T15:09:15.913", "Id": "457896", "CommentCount": "0", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2009-01-19T15:54:14.763", "LastEditorDisplayName": "Luc Touraille", "OwnerDisplayName": "Luc Touraille", "LastEditorUserId": "20984", "LastActivityDate": "2011-11-22T08:13:11.087", "Score": "26", "OwnerUserId": "20984", "Tags": "<c++><reference><void-pointers>", "AnswerCount": "10"}, "458651": {"Id": "458651", "PostTypeId": "2", "Body": "<p>If they were, they would be semantically non-differentiated from pointers, and would amount to syntactic sugar.  A reference says, \"I refer to something that is of this type.\"  Allowing void or null reference would weaken that difference from pointers. </p>\n<p>Granted, it's still possible for a reference to refer to an object that doesn't exist anymore, but that is an exception.</p>\n", "OwnerDisplayName": "JohnMcG", "LastActivityDate": "2009-01-19T18:39:07.380", "Score": "0", "CreationDate": "2009-01-19T18:39:07.380", "ParentId": "457896", "CommentCount": "0", "OwnerUserId": "1674"}, "458451": {"Id": "458451", "PostTypeId": "2", "Body": "<p>Here's a summary of the different things that have been said, and that I've thought of.</p>\n<h2>Two main reasons why reference-to-void are disallowed</h2>\n<hr>\n<p>1 <strong>They would have been totally useless.</strong></p>\n<p>Indeed, if we look back at the times of C, void pointers had two purposes:</p>\n<ul>\n<li>Memory management (e.g. malloc)</li>\n<li>Genericity (writing functions that can accept any type of arguments)</li>\n</ul>\n<p>When C++ came out, templates became the best solution to implement genericity. However, custom memory management still had to be possible, and inter-operability between C++ and C was a major concern, so void* was keeped. An hypothetical void reference would be of no help with memory management, and genericity is already covered, so basically it would have almost no use (except for the guarantee of non-nullness described below).</p>\n<p>2 <strong>You wouldn't be able to do anything with it</strong></p>\n<p>When using a void pointer, you're not allowed to dereference it; transposed to the case of references, that means you can't use the (always hypothetical) void reference. So</p>\n<pre><code>void *data = // something\n// using *data and data-&gt; is forbidden\n\nvoid &amp;data = // something\n// using data is forbidden\n</code></pre>\n<p>However, we could think of a use case where the reference wouldn't have to be \"dereferenced\" (this phrase is awfully incorrect, but you get my point), but where we would only take its address . Let's assume I have the following function:</p>\n<pre><code>void foo(void *dataptr)\n{\n    assert(dataptr != NULL); // or != 0\n    // do something with dataptr\n}\n</code></pre>\n<p>To avoid this annoying assert, I could write the function this way:</p>\n<pre><code>void foo(void &amp;dataref)\n{\n    void *data = &amp;dataref;\n    // do something with data\n}\n</code></pre>\n<p>However, for this to work, <code>&amp;dataref</code> needs to be equivalent to <code>dataptr</code>, <strong>which is not the case</strong>: <code>&amp;dataref</code> is equivalent to <code>&amp;*dataptr</code>! </p>\n<p>Therefore, even taking the address implies a dereferencing, at least conceptually (behind the scenes, the first equivalence is probably true, but at the semantic level it is not). Consequently, there is absolutely no usage we can make of data, so void references are an aberration.</p>\n</hr>", "OwnerDisplayName": "Luc Touraille", "LastActivityDate": "2009-01-19T17:38:05.553", "Score": "3", "CreationDate": "2009-01-19T17:38:05.553", "ParentId": "457896", "CommentCount": "2", "OwnerUserId": "20984"}, "457921": {"Id": "457921", "PostTypeId": "2", "Body": "<p>A reference is a reference to an instance of something.\nAn instance of something can't be of type <code>void</code>.\nAny instance of something must have a specific type (and possibly base types).</p>\n", "OwnerDisplayName": "ChrisW", "LastActivityDate": "2009-01-19T15:15:31.440", "Score": "6", "CreationDate": "2009-01-19T15:15:31.440", "ParentId": "457896", "CommentCount": "0", "OwnerUserId": "49942"}, "457930": {"Body": "<p>Ask your self first, how you would de-reference a void pointer? </p>\n<pre><code>void *p = /*something*/ ;\ncout &lt;&lt; *p &lt;&lt; endl;\n</code></pre>\n<p>The above code is meaningless, one of the reasons we have void is so we can say \"I need to do some generic pointer work here, and I neither know nor care what I'm pointing to\".\nBy definition, the compiler doesn't know what a void * points to, therefore it can't dereference it. You can - by casting - but the compiler can't.</p>\n<p>A reference to a void sufferes from the same problem, by definition the data pointed to doesn't have a type, therefore it can't be referenced in any meaningful way.</p>\n<p>To reference it you - the programmer - need to cast it to another type, then you can have a typed reference to it.</p>\n<p>Not sure if I explained this as well as I wanted to.</p>\n<p>Ruben, any thoughts?</p>\n<p><strong>EDIT:</strong> To answer your edit.</p>\n<p>Take the first function, where you pass void* data.\ndata is a perfectly valid item, you can compute with it, or if you've some logging implemented, you can log it.</p>\n<pre><code>logger &lt;&lt; data;\n</code></pre>\n<p>and you'll get the address data points to. If you try to dereference data, the compiler will give you an error (don't have C++ compiler handy at moment, so not sure of the actual error).\ne.g. </p>\n<pre><code>void* data = /* some assignment */;\nlogger &lt;&lt; *data; // compiler error.\n</code></pre>\n<p>Now, the compiler won't let you dereference a void* for any reason (it doesn't make sense), the same stands for a reference to void &amp;data, except that because it's a reference <em>it's implicitly dereferenced all the time</em>. The compiler won't let you dereference a void* on one operation, it's not going to let you dereference it constantly.</p>\n<pre><code>void&amp; data = /* some assignment *.;\nlogger &lt;&lt; data; // means same as logger &lt;&lt; *data above\n</code></pre>\n<p>You can't do <strong>ANYTHING</strong> to data <strong>EXCEPT</strong> take it's address, and there's a perfectly good - and safe - method built into the languge to do that, i.e.</p>\n<pre><code>void* data;\n</code></pre>\n<p>Is this making any more sense?</p>\n", "CreationDate": "2009-01-19T15:18:09.937", "ParentId": "457896", "CommentCount": "2", "LastEditDate": "2009-01-19T16:08:42.910", "PostTypeId": "2", "LastEditorDisplayName": "Binary Worrier", "LastActivityDate": "2009-01-19T16:08:42.893", "LastEditorUserId": "18797", "Id": "457930", "OwnerDisplayName": "Binary Worrier", "Score": "13", "OwnerUserId": "18797"}});