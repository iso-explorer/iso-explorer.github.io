post_cb({"33740643": {"ParentId": "33731158", "CommentCount": "9", "Body": "<p>It seems that nobody has answered this part of the question yet:</p>\n<blockquote>\n<p id=\"so_33731158_33740643_0\">Should I expect any problems with this solution? </p>\n</blockquote>\n<pre><code>u = static_cast&lt;unsigned&gt;(t*t);\n</code></pre>\n<p>Yes, there is a problem here: it first computes <code>t*t</code> and allows it to overflow, then it converts the result to <code>unsigned</code>. Integer overflow causes undefined behavior according to the C++ standard (even though it may always work fine in practice). The correct solution is:</p>\n<pre><code>u = static_cast&lt;unsigned&gt;(t)*t;\n</code></pre>\n<p>Note that the second <code>t</code> is promoted to <code>unsigned</code> before the multiplication because the first operand is <code>unsigned</code>.</p>\n", "OwnerUserId": "459565", "PostTypeId": "2", "Id": "33740643", "Score": "4", "CreationDate": "2015-11-16T16:58:19.517", "LastActivityDate": "2015-11-16T16:58:19.517"}, "33731158": {"CommentCount": "8", "AcceptedAnswerId": "33731370", "PostTypeId": "1", "ClosedDate": "2015-11-16T21:51:14.547", "LastEditorUserId": "-1", "CreationDate": "2015-11-16T08:35:59.073", "LastActivityDate": "2015-11-26T15:18:45.750", "LastEditDate": "2017-05-23T12:07:34.770", "ViewCount": "2634", "FavoriteCount": "1", "Title": "Why is unsigned short (multiply) unsigned short converted to signed int?", "Id": "33731158", "Score": "18", "Body": "<p>Why is <code>unsigned short * unsigned short</code> converted to <code>int</code> in C++11?</p>\n<p>The <code>int</code> is too small to handle max values as demonstrated by this line of code.</p>\n<pre><code>cout &lt;&lt; USHRT_MAX * USHRT_MAX &lt;&lt; endl;\n</code></pre>\n<p>overflows on MinGW 4.9.2</p>\n<pre><code>-131071\n</code></pre>\n<p>because (<a href=\"http://www.cplusplus.com/reference/climits/\" rel=\"nofollow noreferrer\">source</a>)</p>\n<blockquote>\n<p id=\"so_33731158_33731158_0\">USHRT_MAX = 65535 (2^16-1) or greater*</p>\n<p id=\"so_33731158_33731158_1\">INT_MAX = 32767 (2^15-1) or greater*</p>\n</blockquote>\n<p>and <code>(2^16-1)*(2^16-1) = ~2^32</code>.</p>\n<hr>\n<p>Should I expect any problems with this <strong>solution</strong>? </p>\n<pre><code>unsigned u = static_cast&lt;unsigned&gt;(t*t);\n</code></pre>\n<hr>\n<p>This program</p>\n<pre><code>unsigned short t;\ncout&lt;&lt;typeid(t).name()&lt;&lt;endl;\ncout&lt;&lt;typeid(t*t).name()&lt;&lt;endl;\n</code></pre>\n<p>gives output</p>\n<pre><code>t\ni\n</code></pre>\n<p>on</p>\n<pre><code>gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC)\ngcc version 4.8.2 (GCC)\nMinGW 4.9.2\n</code></pre>\n<p>with both</p>\n<pre><code>g++ p.cpp\ng++ -std=c++11 p.cpp\n</code></pre>\n<p>which proves that <code>t*t</code> is converted to <code>int</code> on these compilers. </p>\n<hr>\n<h2>Usefull resources:</h2>\n<p><a href=\"https://stackoverflow.com/questions/50605/signed-to-unsigned-conversion-in-c-is-it-always-safe\">Signed to unsigned conversion in C - is it always safe?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/16966636/signed-unsigned-integer-multiplication\">Signed &amp; unsigned integer multiplication</a></p>\n<p><a href=\"https://bytes.com/topic/c-sharp/answers/223883-multiplication-types-smaller-than-int-yields-int\" rel=\"nofollow noreferrer\">https://bytes.com/topic/c-sharp/answers/223883-multiplication-types-smaller-than-int-yields-int</a></p>\n<p><a href=\"http://www.cplusplus.com/reference/climits\" rel=\"nofollow noreferrer\">http://www.cplusplus.com/reference/climits</a></p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/types</a></p>\n<hr>\n<p><strong>Edit:</strong> I have demonstrated the problem on the following image.</p>\n<p><a href=\"https://i.stack.imgur.com/zoKr4.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/zoKr4.png\"/></a></p>\n</hr></hr></hr></hr>", "Tags": "<c++><c++11><types><type-conversion><integer-promotion>", "OwnerUserId": "1459339", "AnswerCount": "6"}, "33731370": {"ParentId": "33731158", "CommentCount": "3", "Body": "<p>You may want to read about <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\">implicit conversions</a>, especially the section about <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast#Numeric_promotions\">numeric promotions</a> where it says</p>\n<blockquote>\n<p id=\"so_33731158_33731370_0\">Prvalues of small integral types (such as <code>char)</code> may be converted to prvalues of larger integral types (such as <code>int</code>). In particular, <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic\">arithmetic operators</a> do not accept types smaller than <code>int</code> as arguments</p>\n</blockquote>\n<p>What the above says is that if you use something smaller than <code>int</code> (like <code>unsigned short</code>) in an expression that involves <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic\">arithmetic operators</a> (which of course includes multiplication) then the values will be promoted to <code>int</code>.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "33731370", "Score": "11", "CreationDate": "2015-11-16T08:50:48.023", "LastActivityDate": "2015-11-16T08:50:48.023"}, "33732601": {"ParentId": "33731158", "CommentCount": "2", "Body": "<p>As pointed out by Paolo M in comments, <code>USHRT_MAX</code> has type <code>int</code> (this is specified by 5.2.4.2.1/1: all such macros have a type at least as big as <code>int</code>).</p>\n<p>So <code>USHRT_MAX * USHRT_MAX</code> is already an <code>int</code> x <code>int</code>, no promotions occur.  </p>\n<p>This invokes signed integer overflow on your system, causing undefined behaviour.</p>\n<hr>\n<p>Regarding the proposed solution:</p>\n<pre><code>unsigned u = static_cast&lt;unsigned&gt;(t*t);\n</code></pre>\n<p>This does not help because <code>t*t</code> itself causes undefined behaviour due to signed integer overflow. As explained by the other answers, <code>t</code> is promoted to <code>int</code> before the multiplication occurs, for historical reasons.</p>\n<p>Instead you could use:</p>\n<pre><code>auto u = static_cast&lt;unsigned int&gt;(t) * t;\n</code></pre>\n<p>which, after <em>integer promotion</em>, is an <code>unsigned int</code> multiplied by an <code>int</code>; and then according to the rest of the <em>usual arithmetic conversions</em>, the <code>int</code> is promoted to <code>unsigned int</code>, and a well-defined modular multiplication occurs.</p>\n</hr>", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "33732601", "Score": "6", "CreationDate": "2015-11-16T10:00:14.563", "LastActivityDate": "2015-11-16T10:00:14.563"}, "33739185": {"ParentId": "33731158", "CommentCount": "0", "Body": "<p>As it has been pointed out by other answers, this happens due to integer promotion rules.</p>\n<p>The simplest way to avoid the conversion from an unsigned type with a smaller rank than a signed type with a larger rank, is to make sure the conversion is done into an <code>unsigned int</code> and not <code>int</code>.</p>\n<p>This is done by multiplying by the value 1 that is of type unsigned int. Due to 1 being a multiplicative identity, the result will remain unchanged:</p>\n<pre><code>unsigned short c = t * 1U * t;\n</code></pre>\n<p>First the operands t and 1U are evaluated. Left operand is signed and has a smaller rank than the unsigned right operand, so it gets converted to the type of the right operand. Then the operands are multiplied and the same happens with the result and the remaining right operand. The last paragraph in the Standard cited below is used for this promotion.</p>\n<blockquote>\n<p id=\"so_33731158_33739185_0\">Otherwise, the integer promotions are performed on both operands. Then the\n  following rules are applied to the promoted operands:</p>\n<p id=\"so_33731158_33739185_1\">-If both operands have the same type, then no further conversion is needed.</p>\n<p id=\"so_33731158_33739185_2\">-Otherwise, if both operands have signed integer types or both have unsigned\n  integer types, the operand with the type of lesser integer conversion rank is\n  converted to the type of the operand with greater rank.</p>\n<p id=\"so_33731158_33739185_3\">-Otherwise, if the operand that has unsigned integer type has rank greater or\n  equal to the rank of the type of the other operand, then the operand with\n  signed integer type is converted to the type of the operand with unsigned\n  integer type.</p>\n</blockquote>\n", "OwnerUserId": "2327831", "PostTypeId": "2", "Id": "33739185", "Score": "3", "CreationDate": "2015-11-16T15:42:07.377", "LastActivityDate": "2015-11-16T15:42:07.377"}, "33731380": {"ParentId": "33731158", "CommentCount": "0", "Body": "<p>With integer promotion rules</p>\n<p><code>USHRT_MAX</code> value is promoted to <code>int</code>.\nthen we do the multiplication of 2 int (with possible overflow).</p>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "33731380", "Score": "5", "CreationDate": "2015-11-16T08:51:05.930", "LastActivityDate": "2015-11-16T08:51:05.930"}, "bq_ids": {"n4140": {"so_33731158_33739185_1": {"section_id": 5943, "quality": 0.8888888888888888, "length": 8}, "so_33731158_33731465_0": {"section_id": 5943, "quality": 0.896551724137931, "length": 26}, "so_33731158_33739185_0": {"section_id": 5943, "quality": 0.9166666666666666, "length": 11}, "so_33731158_33739185_3": {"section_id": 5943, "quality": 0.9565217391304348, "length": 22}, "so_33731158_33739185_2": {"section_id": 5943, "quality": 1.0, "length": 23}, "so_33731158_33731465_1": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_33731158_33739185_1": {"section_id": 5714, "quality": 0.8888888888888888, "length": 8}, "so_33731158_33731465_0": {"section_id": 5714, "quality": 0.896551724137931, "length": 26}, "so_33731158_33739185_0": {"section_id": 5714, "quality": 0.9166666666666666, "length": 11}, "so_33731158_33739185_3": {"section_id": 5714, "quality": 0.9565217391304348, "length": 22}, "so_33731158_33739185_2": {"section_id": 5714, "quality": 1.0, "length": 23}, "so_33731158_33731465_1": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_33731158_33739185_1": {"section_id": 7428, "quality": 0.8888888888888888, "length": 8}, "so_33731158_33739185_3": {"section_id": 7428, "quality": 0.9565217391304348, "length": 22}, "so_33731158_33739185_0": {"section_id": 7428, "quality": 0.9166666666666666, "length": 11}, "so_33731158_33731465_0": {"section_id": 7428, "quality": 0.896551724137931, "length": 26}, "so_33731158_33739185_2": {"section_id": 7428, "quality": 1.0, "length": 23}, "so_33731158_33731465_1": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}}}, "33731465": {"ParentId": "33731158", "CommentCount": "2", "Body": "<p>It's the <em>usual arithmetic conversions</em> in action.</p>\n<p>Commonly called argument <em>promotion</em>, although the standard uses that term in a more restricted way (the eternal conflict between reasonable descriptive terms and standardese).</p>\n\nC++11 \u00a75/9:\n\n<blockquote>\n<p id=\"so_33731158_33731465_0\"><strong>\u201d</strong> Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the usual <em>arithmetic conversions</em> [\u2026]</p>\n</blockquote>\n<p>The paragraph goes on to describe the details, which amount to conversions up a ladder of more general types, until all arguments can be represented. The lowest rung on this ladder is <strong>integral promotion</strong> of both operands of a binary operation, so at least that is performed (but the conversion can start at a higher rung). And integral promotion starts with this:</p>\n\nC++11 \u00a74.5/1:\n\n<blockquote>\n<p id=\"so_33731158_33731465_1\"><strong>\u201d</strong> A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or <code>wchar_t</code> whose integer conversion\n  rank (4.13) is less than the rank of <code>int</code> can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type <code>unsigned int</code></p>\n</blockquote>\n<p>Crucially, this is about types, not arithmetic expressions. In your case the arguments of the multiplication operator <code>*</code> are converted to <code>int</code>. Then the multiplication is performed as an <code>int</code> multiplication, yielding an <code>int</code> result.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "33731465", "Score": "10", "CreationDate": "2015-11-16T08:55:49.980", "LastActivityDate": "2015-11-16T08:55:49.980"}});