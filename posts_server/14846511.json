post_cb({"14849163": {"ParentId": "14846511", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_14846511_14849163_0\">is there any way I can get around this?</p>\n</blockquote>\n<p>You can use <code>boost::has_pre_increment</code> and SFINAE :</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;boost/type_traits.hpp&gt;\n\n\ntemplate&lt;typename R,bool hasOp = boost::has_pre_increment&lt;R&gt;::value &gt; struct OpRet\n{\n  typedef R Ret;\n};\ntemplate&lt;typename R&gt; struct OpRet&lt;R,false&gt;\n{\n  typedef void Ret;\n};\n\n\ntemplate&lt;typename T&gt;\nclass Wrapper\n{\nprivate:\n    T val;\npublic:\n    Wrapper(T value) : val(value) {}\n    auto operator++() -&gt; typename OpRet&lt;T&gt;::Ret\n    {\n        return ++val;\n    }\n};\n\nint main()\n{\n  Wrapper&lt;std::string&gt; a(\"abc\");\n  Wrapper&lt;int&gt; b(2);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_14846511_14849163_1\">is it possible this is improper behavior for the compiler in the first place, since the function isn't generating code?</p>\n</blockquote>\n<p>No. The compiler issues proper diagnostic. The <code>std::string</code> really has no prefix increment operator. [temp.deduct] 7 and 8 are clear about this :</p>\n<p>7: </p>\n<blockquote>\n<p id=\"so_14846511_14849163_2\">The substitution occurs in all types and expressions that are used in the function type and in template parameter declarations. The expressions include not only constant expressions such as those that appear in array bounds or as nontype template arguments but also general expressions (i.e., non-constant expressions) inside sizeof, decltype, and other contexts that allow non-constant expressions. [ Note: The equivalent substitution in exception specifications is done only when the function is instantiated, at which point a program is ill-formed if the substitution results in an invalid type or expression. \u2014 end note ]</p>\n</blockquote>\n<p>8:</p>\n<blockquote>\n<p id=\"so_14846511_14849163_3\">If a substitution results in an invalid type or expression, type deduction fails. ...</p>\n</blockquote>\n", "OwnerUserId": "476681", "LastEditorUserId": "476681", "LastEditDate": "2013-02-13T08:29:59.017", "Id": "14849163", "Score": "2", "CreationDate": "2013-02-13T08:18:19.023", "LastActivityDate": "2013-02-13T08:29:59.017"}, "14849716": {"ParentId": "14846511", "CommentCount": "2", "Body": "<p>You indeed want SFINAE. <code>operator++</code> needs to be made a function template for that, and a good trick is to use a default argument for the template parameter to turn <code>T</code> into a dependent type (this is necessary for SFINAE to apply).</p>\n<pre><code>template&lt;typename U = T&gt;\nauto operator++() -&gt; decltype(++std::declval&lt;U&amp;&gt;())\n{\n    return ++this-&gt;val;\n}\n</code></pre>\n<p>As you may notice however, we lose the convenience of using the member directly, and we need a bit of thinking to figure out what exactly we should feed to <code>std::declval</code> to get the value category and cv-qualifiers right.</p>\n", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "14849716", "Score": "1", "CreationDate": "2013-02-13T08:55:43.317", "LastActivityDate": "2013-02-13T08:55:43.317"}, "14846511": {"CommentCount": "9", "CreationDate": "2013-02-13T04:43:04.157", "PostTypeId": "1", "AcceptedAnswerId": "14849163", "LastEditorUserId": "1880530", "LastActivityDate": "2013-02-13T16:20:07.310", "LastEditDate": "2013-02-13T16:20:07.310", "ViewCount": "248", "FavoriteCount": "1", "Title": "decltype throwing errors on template methods that aren't generating code", "Id": "14846511", "Score": "2", "Body": "<p>I'm trying to create a sort of wrapper class that forwards all operators to its contained object, to try and make it able to \"pretend\" to be the contained object. The code I'd <em>like</em> to write looks something like this (simplified):</p>\n<pre><code>template&lt;typename T&gt;\nclass Wrapper\n{\nprivate:\n    T val;\npublic:\n    Wrapper(T value) : val(value) {}\n    auto operator++() -&gt; decltype(++this-&gt;val)\n    {\n        return ++this-&gt;val;\n    }\n};\n</code></pre>\n<p>This works fine with an <code>int</code>, but if I try to pass a <code>std::string</code> into it, I get the error <code>cannot increment value of type 'std::basic_string&lt;char&gt;'</code>.</p>\n<p>I also tried using declval here, but that only made things worse, as not only did it still throw errors on <code>std::string</code>, it also threw them on <code>int</code> in that case due to <code>int</code> not being a class.</p>\n<p>Now, in normal situations, this function wouldn't be generated at all because I'm not calling it. But, for whatever reason, the decltype is still being processed on this function even though it isn't being generated at all. (If I remove the decltype and change the return type to void, I can compile with <code>std::string</code> with no problem.)</p>\n<p>So my question is: is there any way I can get around this? Maybe some crazy trick using SFINAE? Or, is it possible this is improper behavior for the compiler in the first place, since the function isn't generating code?</p>\n<p>EDIT: Solution, modified somewhat from the solution suggested by B\u0408\u043e\u0432\u0438\u045b:</p>\n<pre><code>//Class, supports operator++, get its declared return type\ntemplate&lt;typename R, bool IsObj = boost::is_class&lt;R&gt;::value, bool hasOp = boost::has_pre_increment&lt;R&gt;::value&gt; struct OpRet\n{\n    typedef decltype(++std::declval&lt;R&gt;()) Ret;\n};\n//Not a class, but supports operator++, return type is R (i.e., ++int returns int)\ntemplate&lt;typename R&gt; struct OpRet&lt;R, false, true&gt;\n{\n    typedef R Ret;\n};\n//Doesn't support operator++, return type is void\ntemplate&lt;typename R&gt; struct OpRet&lt;R, true, false&gt;\n{\n    typedef void Ret;\n};\ntemplate&lt;typename R&gt; struct OpRet&lt;R, false, false&gt;\n{\n    typedef void Ret;\n};\n\ntemplate&lt;typename T&gt;\nclass Wrapper\n{\nprivate:\n    T val;\npublic:\n    Wrapper(T value) : val(value) {}\n    auto operator++() -&gt; typename OpRet&lt;T&gt;::Ret\n    {\n        return ++val;\n    }\n};\n</code></pre>\n<p>This will work with both simple and class types, and for class types, will also work in situations where the return type of operator++ is not R (which is probably very rare for operator++, but worth taking into account for the sake of maximum compatibility.)</p>\n", "Tags": "<c++><templates><c++11><sfinae><decltype>", "OwnerUserId": "1880530", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14846511_14849163_3": {"section_id": 300, "quality": 1.0, "length": 8}, "so_14846511_14849163_2": {"section_id": 299, "quality": 0.8771929824561403, "length": 50}}, "n3337": {"so_14846511_14849163_3": {"section_id": 291, "quality": 1.0, "length": 8}, "so_14846511_14849163_2": {"section_id": 290, "quality": 0.8947368421052632, "length": 51}}, "n4659": {"so_14846511_14849163_3": {"section_id": 307, "quality": 1.0, "length": 8}, "so_14846511_14849163_2": {"section_id": 306, "quality": 0.8771929824561403, "length": 50}}}});