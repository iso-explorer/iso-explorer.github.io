post_cb({"32850659": {"ParentId": "32850179", "LastEditDate": "2017-05-23T11:59:28.850", "CommentCount": "0", "CreationDate": "2015-09-29T17:53:05.117", "OwnerUserId": "4342498", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "32850659", "Score": "1", "Body": "<blockquote>\n<p id=\"so_32850179_32850659_0\">Rather than initialize with a size of 10, this initializes with a size of 1 with one element <code>10</code></p>\n</blockquote>\n<p>First initializer-list  are gready:</p>\n<p>\u00a713.3.1.7 [over.match.list]/p1:</p>\n<blockquote>\n<p id=\"so_32850179_32850659_1\">When objects of non-aggregate class type <code>T</code> are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases:</p>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of\n  the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all\n  the constructors of the class <code>T</code> and the argument list consists of\n  the elements of the initializer list.</li>\n</ul>\n<p id=\"so_32850179_32850659_2\">If the initializer list has no elements and <code>T</code> has a default\n  constructor, the first phase is omitted. In copy-list-initialization,\n  if an <code>explicit</code> constructor is chosen, the initialization is\n  ill-formed.</p>\n</blockquote>\n<p>So the compiler will first try to create the vector using </p>\n<pre><code>vector( std::initializer_list&lt;T&gt; init, const Allocator&amp; alloc = Allocator() );\n</code></pre>\n<p>As <a href=\"https://stackoverflow.com/a/32850363/4342498\">pointed out</a> by <a href=\"https://stackoverflow.com/users/5389903/user5389903\">user5389903</a> since you have a <code>const std::size_t s</code> and its value is within the range of an <code>int</code> it can convert <code>{s}</code> into a <code>std::initializer_list&lt;int&gt;</code>.  now since we have a valid <code>std::initializer_list</code> the <code>std::initializer_list</code> constructor will be called.</p>\n", "LastActivityDate": "2015-09-29T17:53:05.117"}, "32850363": {"ParentId": "32850179", "CommentCount": "0", "Body": "<p>No it is not a bug. See [dcl.init.list]/7 of N3337:</p>\n<blockquote>\n<p id=\"so_32850179_32850363_0\">A narrowing conversion is an implicit conversion</p>\n<p id=\"so_32850179_32850363_1\">...</p>\n<ul>\n<li>from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except\n  where the source is a constant expression and the actual value after\n  conversion will fit into the target type and will produce the original\n  value when converted back to the original type.</li>\n</ul>\n</blockquote>\n<p>Therefore the code is valid so long as <code>s</code> is <code>const</code>.</p>\n", "OwnerUserId": "5389903", "PostTypeId": "2", "Id": "32850363", "Score": "2", "CreationDate": "2015-09-29T17:35:55.860", "LastActivityDate": "2015-09-29T17:35:55.860"}, "bq_ids": {"n4140": {"so_32850179_32850659_2": {"section_id": 599, "quality": 1.0, "length": 14}, "so_32850179_32850659_1": {"section_id": 599, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_32850179_32850659_2": {"section_id": 589, "quality": 1.0, "length": 14}, "so_32850179_32850659_1": {"section_id": 589, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_32850179_32850659_2": {"section_id": 622, "quality": 1.0, "length": 14}, "so_32850179_32850659_1": {"section_id": 622, "quality": 0.9230769230769231, "length": 12}}}, "32850179": {"CommentCount": "6", "ViewCount": "123", "PostTypeId": "1", "LastEditorUserId": "2849346", "CreationDate": "2015-09-29T17:26:29.007", "LastActivityDate": "2015-09-29T18:13:20.807", "Title": "Why doesn't the compiler warn about unsigned to signed conversion?", "LastEditDate": "2015-09-29T18:13:20.807", "Id": "32850179", "Score": "1", "Body": "<p>I recently got bit in the butt with this code:</p>\n<pre><code>std::size_t s = 10;\nstd::vector&lt;int&gt; v{s};\n</code></pre>\n<p>Rather than initialize with a size of 10, this initializes with a size of 1 with one element <code>10</code>. However, the vector has an explicit constructor that takes a <code>std::size_t</code>. With all the hype about \"use braces everywhere\", I would expect many people have fallen into this trap. This could be avoided if the compiler simply warned that we were trying to turn a <code>size_t</code> into an <code>int</code>.</p>\n<p>Why isn't the compiler required to do this?</p>\n<p><strong>EDIT</strong>: My original code had <code>const std::size_t s</code>. Apparently none of the compilers I use warn unless I remove the const. Is this a bug?</p>\n", "Tags": "<c++><c++11><const><compiler-warnings>", "OwnerUserId": "5389903", "AnswerCount": "2"}});