post_cb({"25838258": {"CommentCount": "5", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "434551", "CreationDate": "2014-09-14T21:36:25.763", "LastActivityDate": "2015-08-30T12:37:04.517", "Title": "Is polymorphic class required for dynamic_cast?", "LastEditDate": "2014-09-14T23:36:56.147", "Id": "25838258", "Score": "0", "Body": "<p>I've done some searching for this, but just to make sure:</p>\n<p>Using <code>dynamic_cast</code> to cast a base-class pointer to a derived-class pointer requires the base class to be polymorphic? Otherwise we won't even be able to compile?</p>\n<p>Thanks.</p>\n", "Tags": "<c++>", "OwnerUserId": "3367091", "AnswerCount": "2"}, "25838501": {"ParentId": "25838258", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-14T22:09:57.653", "Score": "1", "LastEditorUserId": "787480", "LastEditDate": "2014-09-14T23:00:44.610", "Id": "25838501", "OwnerUserId": "3723423", "Body": "<p>You could use dynamic_cast to cast a derived class to a non polymorphic base class.  But you cannot dynamic_cast a non polymorphic base to a derived class.    </p>\n<p>The standard explains (\u00a75.2.7):  </p>\n<blockquote>\n<p id=\"so_25838258_25838501_0\">(1) The result of the expression dynamic_cast(v) (...)    </p>\n<p id=\"so_25838258_25838501_1\">(5) If T is \u201cpointer to cv1 B\u201d and v has type \u201cpointer to cv2 D\u201d such that B is a base class of D, the result is a pointer to the unique B subobject of the D object pointed to by v.</p>\n<p id=\"so_25838258_25838501_2\">(6) Otherwise, v shall be a pointer to or a glvalue of a polymorphic type </p>\n</blockquote>\n<p>The polymorphic is meant here in a very humble sense:  \"<em>A class that declares or\ninherits a virtual function is called a polymorphic class.</em>\" (\u00a710.3/1). </p>\n", "LastActivityDate": "2014-09-14T23:00:44.610"}, "bq_ids": {"n4140": {"so_25838258_25838501_1": {"section_id": 6015, "quality": 0.8571428571428571, "length": 12}, "so_25838258_25838501_2": {"section_id": 6016, "quality": 1.0, "length": 5}}, "n3337": {"so_25838258_25838501_1": {"section_id": 5783, "quality": 0.8571428571428571, "length": 12}, "so_25838258_25838501_2": {"section_id": 5784, "quality": 0.8, "length": 4}}, "n4659": {"so_25838258_25838501_1": {"section_id": 7514, "quality": 0.8571428571428571, "length": 12}, "so_25838258_25838501_2": {"section_id": 7515, "quality": 1.0, "length": 5}}}, "25838571": {"ParentId": "25838258", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-09-14T22:20:31.397", "Score": "0", "LastEditorUserId": "3647361", "LastEditDate": "2015-08-30T12:37:04.517", "Id": "25838571", "OwnerUserId": "3647361", "Body": "<p>For Upcasts, the base class type - which is the type of the casted expression - has to be polymorphic, <a href=\"http://coliru.stacked-crooked.com/a/6d66e18798a8c165\" rel=\"nofollow\">otherwise you get a compiler error</a>.\nThat is because <code>dynamic_cast</code> uses RTTI to perform the cast and check whether it is successful or not - and RTTI is only generated for polymorphic types.</p>\n<p><code>static_cast</code> on the other hand doesn't check whether the cast is valid; if it isn't, the cast invokes undefined behavior. <code>static_cast</code> just adds or subtracts an offset from the pointer (or internal pointer of the reference). <code>dynamic_cast</code> does a runtime type check.</p>\n", "LastActivityDate": "2015-08-30T12:37:04.517"}});