post_cb({"bq_ids": {"n4140": {"so_48146177_48146177_0": {"length": 29, "quality": 0.90625, "section_id": 268}}, "n3337": {"so_48146177_48146177_0": {"length": 29, "quality": 0.90625, "section_id": 259}}, "n4659": {"so_48146177_48146177_0": {"length": 29, "quality": 0.90625, "section_id": 275}}}, "48146177": {"ViewCount": "50", "Body": "<p>I want to enable user to control \"internal type\" of base class.  This code works fine.</p>\n<p><strong>Version 1</strong> (<a href=\"http://coliru.stacked-crooked.com/a/7a6940073f816550\" rel=\"nofollow noreferrer\">demo</a>)</p>\n<pre><code>//library layer\ntemplate&lt;class Derived&gt; class BT_trait{\n    public: using type=int;  \n};\ntemplate&lt;class Derived&gt; class BT{\n    public: using typee=typename BT_trait&lt;Derived&gt;::type;\n    public: typee f(){ return 1;}\n};\n//user code below\nclass C;\ntemplate&lt;&gt; class BT_trait&lt;C&gt;{\n    public: using type=std::string;  //&lt;-- user want to set \"internal type\"\n};\nclass C : public BT&lt;C&gt; {\n    public: typee f(){ return \"OK\";}\n};\nint main(){\n    C bt;\n    std::cout&lt;&lt; bt.f();\n}\n</code></pre>\n<p>If I make it a little more complex by adding a template parameter, it will not  compilable anymore.<br>\n (show below)</br></p>\n<p><strong>Version 2</strong> (<a href=\"http://coliru.stacked-crooked.com/a/cbe4cda7bb593c55\" rel=\"nofollow noreferrer\">demo</a>)</p>\n<pre><code>template&lt;class Derived&gt; class BT_trait{\n    public: using type=int;  \n};\ntemplate&lt;class Derived,class Dummy&gt; class BT{\n    public: using typee=typename BT_trait&lt;Derived&gt;::type;\n    public: typee f(){ return 1;}\n};\n//user code below\ntemplate&lt;class T&gt; class C;\ntemplate&lt;class T&gt; class BT_trait&lt;C&lt;T&gt;&gt;{\n    public: using type=std::string;  \n};\ntemplate&lt;class T&gt; class C : public BT&lt;C&lt;T&gt;,T&gt; {\n    // public: typename BT&lt;C&lt;T&gt;, T&gt;::typee f(){ return \"OK\";} //Version #2b \n    public: typee f(){ return \"OK\";}  //Version #2a\n    //^ error: 'typee' does not name a type; did you mean 'wctype'?\n};\nint main(){\n    C&lt;int&gt; bt;\n    std::cout&lt;&lt; bt.f();\n}\n</code></pre>\n<p>But if I use <code>#2b</code> (dirty) instead of <code>#2a</code> (concise), the above code will work fine.<br>\nWhy?  Is it possible to make <code>#2a</code> work?</br></p>\n<p>According to a quote from <a href=\"https://stackoverflow.com/questions/5912689/specialization-of-template-function-after-point-of-use-will-break-the-compilatio\">Specialization of template function after point of use will break the compilation</a> :-</p>\n<blockquote>\n<p id=\"so_48146177_48146177_0\">Section [temp.expl.spec] 14.7.3p6 : If a template, a member\n  template or a member of a class template is explicitly specialized\n  then that specialization shall be declared before the first use of\n  that specialization that would cause an implicit instantiation to take\n  place, in every translation unit in which such a use occurs; no\n  diagnostic is required.</p>\n</blockquote>\n<p>I doubt that my code is undefined behavior.  Correct?<br>\nI am very new to template specialization.</br></p>\n", "AcceptedAnswerId": "48146343", "Title": "specialize type_trait after base class = undefine behavior?", "CreationDate": "2018-01-08T07:50:56.260", "Id": "48146177", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2018-01-08T08:06:51.943", "Score": "1", "OwnerUserId": "8112491", "Tags": "<c++><c++14><language-lawyer><template-specialization><typetraits>", "AnswerCount": "2"}, "48146301": {"Id": "48146301", "PostTypeId": "2", "Body": "<p>Note that <code>typee</code> type depends on template parameters. As an option you can make <code>typee</code> recognizable as is by adding using directive:</p>\n<pre><code>using typename BT&lt;C&lt;T&gt;, T&gt;::typee;\npublic: typee f(){ return \"OK\";}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/1dpEOMiIpLN4VKax\" rel=\"nofollow noreferrer\">online compiler</a></p>\n", "LastActivityDate": "2018-01-08T08:02:43.127", "CommentCount": "2", "CreationDate": "2018-01-08T08:02:43.127", "ParentId": "48146177", "Score": "2", "OwnerUserId": "7860670"}, "48146343": {"Id": "48146343", "PostTypeId": "2", "Body": "<p>No, your code does not exhibit UB, and will not even when made to compile.</p>\n<p>The problem is that once <code>C</code> becomes a template, the two-phase lookup rule starts to apply inside it. Basically, names which do not depend on template parameters are looked up when the template is parsed, at which point in time the argument for <code>T</code> is of course unknown and the compiler thus cannot look into <code>BT&lt;C&lt;T&gt;, T&gt;</code> and find <code>typee</code> defined there. So it fails.</p>\n<p>You have to mark <code>typee</code> as a dependent name (because it <em>does</em> depend on <code>T</code>). You have several ways:</p>\n<ul>\n<li><p>Qualify it when referring to it:</p>\n<pre><code>public: typename C::typee f(){ return \"OK\";}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/9707095077131d83\" rel=\"nofollow noreferrer\">[Live example]</a></p></li>\n<li><p>Bring it into your class' scope (as also suggested by <a href=\"https://stackoverflow.com/a/48146301/1782465\">VTT's answer</a>):</p>\n<pre><code>using typename BT&lt;C&lt;T&gt;, T&gt;::typee;\npublic: typee f(){ return \"OK\";}\n</code></pre></li>\n</ul>\n", "LastActivityDate": "2018-01-08T08:06:51.943", "CommentCount": "0", "CreationDate": "2018-01-08T08:06:51.943", "ParentId": "48146177", "Score": "2", "OwnerUserId": "1782465"}});