post_cb({"bq_ids": {"n4140": {"so_44015848_44016076_1": {"length": 42, "quality": 0.9333333333333333, "section_id": 3296}, "so_44015848_44016076_0": {"length": 6, "quality": 1.0, "section_id": 3296}}, "n3337": {"so_44015848_44016076_1": {"length": 42, "quality": 0.9333333333333333, "section_id": 3166}, "so_44015848_44016076_0": {"length": 6, "quality": 1.0, "section_id": 3166}}, "n4659": {"so_44015848_44016076_1": {"length": 42, "quality": 0.9333333333333333, "section_id": 4058}, "so_44015848_44016076_0": {"length": 6, "quality": 1.0, "section_id": 4058}}}, "44015848": {"ViewCount": "684", "Body": "<p>In the following snippet, GCC 7 with C++1z mode invokes the default constructor, but GCC/C++14 and Clang/C++14,C++1z invoke the initializer-list constructor.</p>\n<p>Is this behavior affected by any C++1z Specifiation change (possibly <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html\" rel=\"noreferrer\">Guaranteed copy elision</a>?), or GCC bug?</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;initializer_list&gt;\n\nstruct S {\n  S() { std::printf(\"DEF \"); }      // (1)\n  S(std::initializer_list&lt;int&gt; il)  // (2)\n    { std::printf(\"L=%zu \", il.size()); }\n};\n\nint main() {\n  S x({});\n}\n</code></pre>\n<p>Output:</p>\n<ul>\n<li><a href=\"https://wandbox.org/permlink/iACdbGKRhtYLgvD8\" rel=\"noreferrer\">gcc 7.1.0/-std=c++14</a>: <code>L=0</code></li>\n<li><a href=\"https://wandbox.org/permlink/Ajf8qDTPiw9XisVb\" rel=\"noreferrer\">gcc 7.1.0/-std=c++1z</a>: <code>DEF</code></li>\n<li><a href=\"https://wandbox.org/permlink/Dvk8z2ZAhzfzKeQU\" rel=\"noreferrer\">Clang HEAD 5.0.0/-std=c++14 and c++1z</a>: <code>L=0</code></li>\n</ul>\n", "AcceptedAnswerId": "44016076", "Title": "why `S x({})` invoke default constructor in GCC 7/C++1z mode only?", "CreationDate": "2017-05-17T04:49:42.923", "Id": "44015848", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-17T17:34:59.857", "LastEditorUserId": "3980929", "LastActivityDate": "2017-05-17T17:34:59.857", "Score": "16", "OwnerUserId": "684921", "Tags": "<c++><gcc><language-lawyer><c++1z>", "AnswerCount": "1"}, "44016076": {"Id": "44016076", "PostTypeId": "2", "Body": "<p>I think this is a gcc bug (submitted as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80804\" rel=\"noreferrer\">80804</a>). The order of rules for [dcl.init] in C++17 is:</p>\n<blockquote>\n<p id=\"so_44015848_44016076_0\">If the destination type is a (possibly cv-qualified) class type:  </p>\n<ul>\n<li>If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same class as the class of the destination, the initializer expression is used to initialize the destination object.</li>\n</ul>\n</blockquote>\n<p>That first bullet does not apply. The initializer expression here is <code>{}</code>, which isn't even an expression so it doesn't even have a cv-unqualified type to compare against <code>S</code>. This bullet <em>would</em> apply if we had written <code>S x(S{})</code> instead.</p>\n<blockquote id=\"so_44015848_44016076_1\">\n<ul>\n<li>Otherwise, if the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated ([over.match.ctor]), and the best one is chosen through overload resolution. The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n</ul>\n</blockquote>\n<p>This is direct-initialization, so constructors are considered as per [over.match.ctor], which just tells is to overload on the constructors. Since there is a <code>std::initializer_list</code> constructor, that one gets priority per [over.ics.rank], so that one is selected.</p>\n<hr/>\n<p>The only difference between C++14 and C++17 here is the introduction of that first bullet - which doesn't apply anyway, so the behavior should be the same.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-05-17T13:53:26.393", "Score": "17", "CreationDate": "2017-05-17T05:10:24.147", "ParentId": "44015848", "CommentCount": "3", "OwnerUserId": "2069064", "LastEditDate": "2017-05-17T13:53:26.393"}});