post_cb({"bq_ids": {"n4140": {"so_45902829_45905157_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 7194}, "so_45902829_45905157_2": {"length": 13, "quality": 1.0, "section_id": 444}}, "n3337": {"so_45902829_45905157_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 6938}, "so_45902829_45905157_2": {"length": 13, "quality": 1.0, "section_id": 435}}, "n4659": {"so_45902829_45905157_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 8703}, "so_45902829_45905157_2": {"length": 13, "quality": 1.0, "section_id": 467}}}, "45905157": {"Id": "45905157", "PostTypeId": "2", "Body": "<p>Firstly, let me clarify one thing.\nI am not sure if it is even possible to literally <em>copy a reference</em>.</p>\n<pre><code>int i = 10;\nint&amp; ref = i;       // since this moment ref becomes \"untouchable\"\nint&amp; alt_ref = ref; // actually, means int&amp; alt_ref = i;\n</code></pre>\n<p>I think the same happens if <code>ref</code> is a member of some class and you copy an instance of this class.\nBesides, if you look closer on your code, you don't even \"copy a reference\", but rather initialize a reference with uninitialized (yet) object.</p>\n<pre><code>struct Parent \n{\n  Object&amp; ref;\n  Parent(Object&amp; i): ref(i) { }\n};\n\nstruct Child : Parent\n{\n  Object obj;\n  Child(int i): Parent(obj), obj(i) { }\n};\n</code></pre>\n<p>physically is equivalent to:</p>\n<pre><code>struct Child\n{\n  Object&amp; ref;\n  Object obj;\n  Child(int i): ref(obj), obj(i) { }\n};\n</code></pre>\n<p>With that being said, your question actually means:</p>\n<blockquote>\n<p id=\"so_45902829_45905157_0\">Is it undefined behavior to <em>initialize</em> a reference before\n  initializing the object it <em>is about to</em> refer?</p>\n</blockquote>\n<p>Here is a quote from C++ Standard (\u00a73.8.6 [basic.life/6]) which possibly gives the answer:</p>\n<blockquote>\n<p id=\"so_45902829_45905157_1\">Similarly, before the lifetime of an object has started but after the\n  storage which the object will occupy has been allocated or, after the\n  lifetime of an object has ended and before the storage which the\n  object occupied is reused or released, any glvalue that refers to the\n  original object may be used but only in limited ways. For an object\n  under construction or destruction, see 12.7. Otherwise, such a glvalue\n  refers to allocated storage (3.7.4.2), and using the properties of the\n  glvalue that do not depend on its value is well-defined.</p>\n</blockquote>\n<p>And \u00a712.7.1 [class.cdtor/1] just says:</p>\n<blockquote>\n<p id=\"so_45902829_45905157_2\">...referring to any non-static member or base class of the object\n  before the constructor begins execution results in undefined behavior.</p>\n</blockquote>\n<p>\u00a712.7.1 mentions only \"referring to objects members\", hence \"referring to the object <strong>itself</strong>\" falls under \u00a73.8.6.\nThis way, I make a conclusion that referring to uninitialized (but already allocated) object is well-defined. </p>\n<p>If you see any mistakes, please let me know in the comments. Also feel free to edit this answer.</p>\n<p><strong>Edit:</strong>\nI just want to say, that such conclusion seems reasonable. Initialization of an object cannot change its location in memory. What is bad in storing the reference to already allocated memory even before it is initialized?</p>\n", "LastEditorUserId": "6639082", "LastActivityDate": "2017-08-27T13:12:43.103", "Score": "2", "CreationDate": "2017-08-27T12:53:51.430", "ParentId": "45902829", "CommentCount": "2", "OwnerUserId": "6639082", "LastEditDate": "2017-08-27T13:12:43.103"}, "45902829": {"ViewCount": "50", "Body": "<p>According to the c++ standard, is it undefined behavior to copy a reference before initializing the object it refers to? This happens in the following example, where I pass a reference to a parent class and I initialize the value of the object only after because the call to the parent constructor has to be first in the initializer list. </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Object\n{\n  int val;\n  Object(int i): val(i) {}\n};\n\nstruct Parent \n{\n  Object&amp; ref;\n  Parent(Object&amp; i): ref(i){}\n};\n\nstruct Child : Parent\n{\n  Object obj;\n  Child(int i): Parent(obj), obj(i) {}\n};\n\nint main()\n{\n  std::cout &lt;&lt; Child(3).ref.val;\n}\n</code></pre>\n<p>Here when <strong>Parent</strong> is initialized with Parent(obj), the value of <strong>obj</strong> has not been initialized yet. </p>\n<p>This compiles fine under gcc, and I do get a correct output, but I'm not sure whether the standard or good coding practice advise against it. Is it an undefined behavior ? And if not, is it a bad practice that I should avoid?</p>\n", "AcceptedAnswerId": "45905157", "Title": "Copying a reference to an uninitialized object in c++", "CreationDate": "2017-08-27T07:54:49.630", "Id": "45902829", "CommentCount": "7", "LastEditDate": "2017-08-27T08:16:42.227", "PostTypeId": "1", "LastEditorUserId": "7205445", "LastActivityDate": "2017-08-27T13:12:43.103", "Score": "0", "OwnerUserId": "7205445", "Tags": "<c++><reference><initializer-list>", "AnswerCount": "1"}});