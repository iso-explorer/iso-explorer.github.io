post_cb({"9980476": {"ParentId": "9974596", "CommentCount": "1", "Body": "<p>It would seem to me the least smelly way to deal with this is to introduce a base class for A &amp; B:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base\n{\n    virtual ~Base() {};\n};\n\nstruct A : public virtual Base\n{\n    int a;\n    virtual ~A() {};\n    virtual void afunc() {};\n};\n\n\n\nstruct B : public virtual Base\n{\n    int b;\n    virtual ~B() {};\n    virtual void bfunc() {};\n};\n\nstruct C: A, B\n{};\n\nint main()\n{\n    C c;\n    A *a = &amp;c;\n    B *b = &amp;c;\n\n    std::cout &lt;&lt; \"a* == \" &lt;&lt; &amp;(*a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b* == \" &lt;&lt; &amp;(*b) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"a == b == \" &lt;&lt; ((void*)a == (void*)b) &lt;&lt; std::endl;\n\n    Base* ba = a;\n    Base* bb = b;\n\n    std::cout &lt;&lt; \"ba* == \" &lt;&lt; &amp;(*ba) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"bb* == \" &lt;&lt; &amp;(*bb) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"ba == bb == \" &lt;&lt; (ba == bb) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "3978", "PostTypeId": "2", "Id": "9980476", "Score": "1", "CreationDate": "2012-04-02T16:52:54.357", "LastActivityDate": "2012-04-02T16:52:54.357"}, "9980684": {"ParentId": "9974596", "CommentCount": "0", "Body": "<p>Since with <code>dynamic_cast</code> you also can cast \"sideways\" in the type hierarchy, I would suggest:</p>\n<pre><code>(b != nullptr? dynamic_cast&lt;B*&gt;(a) == b : a == nullptr)\n</code></pre>\n<p>If <code>a</code> points to some subobject at the beginning of <code>*b</code>, then <code>dynamic_cast&lt;B*&gt;(a)</code> will necessarily return a null pointer (because there's no way a <code>B</code> contains itself). Therefore if b is not a null pointer, <code>dynamic_cast&lt;B*&gt;(a) == b</code> will succeed only if both share the same most derived class. The case that b is a null pointer has to be treated specifically because if <code>a</code> is not null, but does not point to a class derived from <code>B</code>, the <code>dynamic_cast</code> test will fail.</p>\n<p>However there are some situations involving multiple inheritance where this solution will give a false negative (unlike your solution which never gives false negatives, but can give false positives). However the class hierarchies where this might happen are hierarchies which I'd say you shouldn't create anyway (namely the same derived class containing multiple indirect bases of type B). You can reduce the number of false negatives by testing again through exchanging the role of <code>a</code> and <code>b</code> (then only if <em>both</em> <code>A</code> and <code>B</code> are ambiguous in the most derived class, the test will fail).</p>\n<p>You could also combine your and my test to give three results:</p>\n<ul>\n<li>Both tests succeed: The pointers definitely are to the same object (or noth null).</li>\n<li>Both tests fail: The pointers definitely are not to the same object.</li>\n<li>Only my test fails: <em>Either</em> your test has given a false positive, <em>or</em> my test has given a false negative. You can't tell for sure whether both are the same object, but at least you can tell that you can't tell.</li>\n</ul>\n", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "9980684", "Score": "0", "CreationDate": "2012-04-02T17:08:25.937", "LastActivityDate": "2012-04-02T17:08:25.937"}, "9974596": {"CommentCount": "16", "ViewCount": "6939", "LastEditDate": "2017-11-13T20:58:03.700", "LastEditorUserId": "7232508", "CreationDate": "2012-04-02T10:17:54.503", "LastActivityDate": "2017-11-13T20:58:03.700", "PostTypeId": "1", "FavoriteCount": "3", "Title": "how to check whether two pointers point to the same object or not?", "Id": "9974596", "OwnerUserId": "396672", "Body": "<p>Consider two pointers</p>\n<pre><code>A* a; \nB* b;\n</code></pre>\n<p>Both A and B are polymorphic classes.\nHow to check whether a and b point to the same object or not?</p>\n<p>More precisely, let's specify a and b point to the same object if there exists some object d of type D such that both *a and *b are somewhere in the class hierarchy of d.</p>\n<p>I would propose the following solution:</p>\n<pre><code>dynamic_cast&lt;void*&gt;(a) == dynamic_cast&lt;void*&gt;(b)\n</code></pre>\n<p>Indeed, according to the standard, </p>\n<pre><code>dynamic_cast&lt;void*&gt;(v) \n</code></pre>\n<p>yields \u201da pointer to the most derived object pointed to by v. (n3242.pdf: \u00a7 5.2.7 - 7).\nIf the most derived for both is the same object, then the pointers point to the same object.</p>\n<p>I'm pretty sure that it should always work correctly from the practical viewpoint. But theoretically, at first glance the proposed equality seems to produce false positive, for example, in case if b points to the first member of A (not to A's ancestor). Although it's practically impossible to get equal addresses for A and its member since  A's virtual table pointer should be located before this member, the standard doesn't mandate virtual tables and says nothing about the class layout. </p>\n<p>So, my questions are:</p>\n<ol>\n<li><p>Is the proposed solution correct from the standard viewpoint?</p></li>\n<li><p>Are there any caveats about private (protected) inheritance or cv-qualification ?</p></li>\n<li><p>Are there better solutions?</p></li>\n</ol>\n<p><b>[EDIT] </b></p>\n<p>I tried to present some example that illustrates a relatively complex scenario. In this case dynamic crosscasting and static casting are ambiguous.</p>\n<pre><code> // proposed impplementation:\ntemplate&lt;typename P, typename Q&gt; \nbool test_ptrs(const P* p, const Q* q)\n{\n  return (dynamic_cast&lt;const void*&gt;(p) ==  dynamic_cast&lt;const void*&gt;(q));\n}\n\n\nstruct Root\n{\n  virtual ~Root(){};\n};\n\nstruct A: public Root // nonvirtually\n{\n};\n\nstruct B: public Root // nonvirtually\n{\n};\n\nstruct C: public A, B  // nonvirtual diamond started with Root\n{\n  Root another_root_instance;\n};\n\nint main()\n{\n  C c;\n\n  A* pa= &amp;c;\n  B* pb= &amp;c;\n\n  bool b = (dynamic_cast&lt;void*&gt;(pa) ==  dynamic_cast&lt;void*&gt;(pb));\n\n  Root* pra= dynamic_cast&lt;Root*&gt; (pa); \n  Root* prb= dynamic_cast&lt;Root*&gt; (pb);\n\n  //Root* prc= dynamic_cast&lt;Root*&gt; (&amp;c); // runtime error, ambiguous cast\n  Root* prr= dynamic_cast&lt;Root*&gt;(pra);\n\n  Root* pcar= dynamic_cast&lt;Root*&gt;(pra);\n  Root* pcbr= dynamic_cast&lt;Root*&gt;(prb);\n\n  if(\n      test_ptrs(pa, pb) \n      &amp;&amp; test_ptrs(pra, prb)\n      &amp;&amp; !test_ptrs(pa,&amp;c.another_root_instance)\n    )\n  {\n    printf(\"\\n test passed \\n\");\n  }\n}\n</code></pre>\n", "Tags": "<c++><dynamic-cast>", "Score": "13", "AnswerCount": "3"}, "9978209": {"ParentId": "9974596", "CommentCount": "0", "Body": "<p>I was trying to resolve this by comparing the address these pointers pointing to.</p>\n<ul>\n<li>Address it is pointing to changes based on the type of pointer.</li>\n</ul>\n<p>Hence theoretically we can say like </p>\n<blockquote>\n<p id=\"so_9974596_9978209_0\">a* and b* points to the same object if there exists some object c of type C such that both *a and *b are somewhere in the class hierarchy of C.\"</p>\n</blockquote>\n<p>Logically </p>\n<blockquote>\n<p id=\"so_9974596_9978209_1\">we have to revisit the above statement like \n  \"a* and b* points to the same object <strong>but has it own zone of access in the memory of obj c</strong> of type C such that both *a and *b are somewhere in the class hierarchy of C.\"\"</p>\n</blockquote>\n<p><code>struct Aa \n{   int a;\nAa() {a= 0;}\n    };</code> </p>\n<pre><code>struct Bb \n{   int b;\n    Bb() { b= 0;}\n}; \nstruct C: Aa, Bb {      \n}; \n\nC c; \nAa *a1 = &amp;c; \nAa *a2 = &amp;c; \nBb *b1 = &amp;c; \nBb *b2 = &amp;c; \n\ncout  &lt;&lt; &amp;c &lt;&lt; \"\\t\"&lt;&lt; &amp;(*a1)&lt;&lt;\"\\t\"&lt;&lt; &amp;(*a2)&lt;&lt;endl;\ncout  &lt;&lt; &amp;c &lt;&lt; \"\\t\"&lt;&lt; &amp;(*b1)&lt;&lt;\"\\t\"&lt;&lt; &amp;(*b2)&lt;&lt;endl;\n</code></pre>\n<p>Output:</p>\n<ul>\n<li>&amp;c  0x0012fd04</li>\n<li>&amp;(*a1)  0x0012fd04</li>\n<li>&amp;(*a2)  0x0012fd04</li>\n<li>&amp;(*b1)  0x0012fd08</li>\n<li>&amp;(*b2)  0x0012fd08</li>\n</ul>\n<p>Though this will not solve your problem, we have a point to infer here. </p>\n", "OwnerUserId": "193670", "PostTypeId": "2", "Id": "9978209", "Score": "1", "CreationDate": "2012-04-02T14:25:16.803", "LastActivityDate": "2012-04-02T14:25:16.803"}, "bq_ids": {"n4659": {"so_9974596_9978209_0": {"section_id": 7709, "quality": 0.6153846153846154, "length": 8}}}});