post_cb({"8108658": {"Id": "8108658", "PostTypeId": "2", "Body": "<p>As far as C++ is concerned:</p>\n<p>C++11, [lex.icon] \u00b62</p>\n<blockquote>\n<p id=\"so_8108642_8108658_0\">The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be represented.</p>\n</blockquote>\n<p>And Table 6, for literals without suffixes and decimal constants, gives:</p>\n<pre><code>int\nlong int\nlong long int\n</code></pre>\n<p>(interestingly, for hexadecimal or octal constants also <code>unsigned</code> types are allowed - but each one come <em>after</em> the corresponding signed one in the list)</p>\n<p>So, it's clear that in that case the constant has been interpreted as a <code>long int</code> (or <code>long long int</code> if <code>long int</code> was too 32 bit).</p>\n<p>Notice that \"too big literals\" should result in a compilation error:</p>\n<blockquote>\n<p id=\"so_8108642_8108658_1\">A program is ill-formed if one of its translation units contains an integer literal that cannot be represented by any of the allowed types.</p>\n</blockquote>\n<p>(ibidem, \u00b63)</p>\n<p>which is promptly seen <a href=\"http://ideone.com/9hujM\">in this sample</a>, that reminds us that ideone.com uses 32 bit compilers.</p>\n<hr/>\n<p>I saw now that the question was about C... well, it's more or less the same:</p>\n<p>C99, \u00a76.4.4.1</p>\n<blockquote>\n<p id=\"so_8108642_8108658_2\">The type of an integer constant is the first of the corresponding list in which its value can be represented.</p>\n</blockquote>\n<p>list that is the same as in the C++ standard.</p>\n<hr/>\n<p>Addendum: both C99 and C++11 allow also the literals to be of \"extended integer types\" (i.e. other implementation-specific integer types) if everything else fails. (C++11, [lex.icon] \u00b63; C99, \u00a76.4.4.1 \u00b65 after the table)</p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2011-11-13T01:04:57.873", "Score": "30", "CreationDate": "2011-11-13T00:30:44.763", "ParentId": "8108642", "CommentCount": "7", "OwnerUserId": "214671", "LastEditDate": "2011-11-13T01:04:57.873"}, "8108715": {"Id": "8108715", "PostTypeId": "2", "Body": "<p>From my draft of the C standard labeled <em>ISO/IEC 9899:TC2 Committee Draft \u2014 May 6, 2005</em>, the rules are remarkably similar to the C++ rules Matteo found:</p>\n<blockquote>\n<p id=\"so_8108642_8108715_0\">5  The type of an integer constant is the first of the corresponding list in which its value can be represented.</p>\n</blockquote>\n<pre><code>Suffix      Decimal Constant          Octal or Hexadecimal Constant\n-------------------------------------------------------------------\nnone        int                       int\n            long int                  unsigned int\n            long long int             long int\n                                      unsigned long int\n                                      long long int\n                                      unsigned long long int\n\nu or U      unsigned int              unsigned int\n            unsigned long int         unsigned long int\n            unsigned long long int    unsigned long long int\n\nl or L      long int                  long int\n            long long int             unsigned long int\n                                      long long int\n                                      unsigned long long int\nBoth u or U unsigned long int         unsigned long int\nand l or L  unsigned long long int    unsigned long long int\n\nll or LL    long long int             long long int\n                                      unsigned long long int\n\nBoth u or U unsigned long long int    unsigned long long int\nand ll or LL \n</code></pre>\n", "LastActivityDate": "2011-11-13T00:45:08.143", "CommentCount": "1", "CreationDate": "2011-11-13T00:45:08.143", "ParentId": "8108642", "Score": "8", "OwnerUserId": "377270"}, "bq_ids": {"n4140": {"so_8108642_8108658_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5341}, "so_8108642_8108658_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 5341}, "so_8108642_8108658_1": {"length": 12, "quality": 1.0, "section_id": 5342}, "so_8108642_8108715_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5341}}, "n3337": {"so_8108642_8108658_1": {"length": 12, "quality": 1.0, "section_id": 5139}, "so_8108642_8108658_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 5138}, "so_8108642_8108715_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5138}, "so_8108642_8108658_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5138}}, "n4659": {"so_8108642_8108658_1": {"length": 12, "quality": 1.0, "section_id": 6763}, "so_8108642_8108658_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 6762}, "so_8108642_8108715_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6762}, "so_8108642_8108658_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6762}}}, "8108726": {"Id": "8108726", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8108642_8108726_0\">I still wonder what was really going on inside the compiler</p>\n</blockquote>\n<p>You can look at assembler, if you are interested in how the compiler interprets code.</p>\n<p>10000000000:</p>\n<pre><code>400054f:\nmov    -0x4(%rbp),%eax\nmov    %eax,-0x8(%rbp)\naddl   $0x1,-0x4(%rbp)\njmp    40054f &lt;main+0xb&gt;\n</code></pre>\n<p>so it just compiled it into infinite loop,\nif replace  10000000000 with 10000:</p>\n<pre><code>....\ntest   %al,%al\njne    400551\n</code></pre>\n", "LastEditorUserId": "597607", "LastActivityDate": "2011-11-13T10:13:44.283", "Score": "1", "CreationDate": "2011-11-13T00:48:26.320", "ParentId": "8108642", "CommentCount": "3", "OwnerUserId": "1034749", "LastEditDate": "2011-11-13T10:13:44.283"}, "8108642": {"ViewCount": "8529", "Body": "<p>I just answered <a href=\"https://stackoverflow.com/q/8108171/743214\">this question</a>, which asked why iterating until 10 billion in a for loop takes so much longer (the OP actually aborted it after 10 mins) than iterating until 1 billion:</p>\n<pre><code>for (i = 0; i &lt; 10000000000; i++)\n</code></pre>\n<p>Now my and many others' obvious answer was that it was due to the iteration variable being 32-bit (which never reaches 10 billion) and the loop getting an infinite loop.</p>\n<p>But though I realized this problem, I still wonder what was really going on inside the compiler?</p>\n<p>Since the literal was not appended with an <code>L</code>, it should IMHO be of type <code>int</code>, too, and therefore 32-bit. So due to overflow it should be a normal <code>int</code> inside the range to be reachable. To actually recognize that it cannot be reached from <code>int</code>, the compiler needs to know that it is 10 billion and therefore see it as a more-than-32-bit constant.</p>\n<p>Does such a literal get promoted to a fitting (or at least implementation-defined) range (at least 64-bit, in this case) automatically, even if not appended an <code>L</code> and is this standard behaviour? Or is something different going on behind the scenes, like UB due to overflow (is integer overflow actually UB)? Some quotes from the Standard may be nice, if any.</p>\n<p>Although the original question was C, I also appreciate C++ answers, if any different.</p>\n", "AcceptedAnswerId": "8108658", "Title": "Type of integer literals not int by default?", "CreationDate": "2011-11-13T00:24:41.413", "Id": "8108642", "CommentCount": "7", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:53.593", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-15T02:45:56.513", "Score": "29", "OwnerUserId": "743214", "Tags": "<c++><c><overflow><literals>", "AnswerCount": "3"}});