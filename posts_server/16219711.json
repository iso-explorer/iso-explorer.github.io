post_cb({"16219711": {"CommentCount": "1", "ViewCount": "934", "CreationDate": "2013-04-25T16:09:14.490", "LastActivityDate": "2013-04-25T16:26:22.713", "Title": "Undefined symbols for constexpr function", "AcceptedAnswerId": "16219760", "PostTypeId": "1", "Id": "16219711", "Score": "8", "Body": "<p>When I attempt compiling the following code I get a linker error: <code>Undefined symbols for architecture x86_64: \"Foo()\", referenced from: _main in main.o</code> using LLVM 4.2.</p>\n<p>This behavior only occurs when the function is marked <code>constexpr</code>. The program compiles and links correctly when the function is marked <code>const</code>. Why does declaring the function <code>constexpr</code> cause a linker error?</p>\n<p>(I realize that writing the function this way doesn't give the benefit of compile-time computation; at this point I am curious why the function fails to link.)</p>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include \"test.hpp\"\n\nint main()\n{\n    int bar = Foo();\n    std::cout &lt;&lt; bar &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p><strong>test.hpp</strong></p>\n<pre><code>constexpr int Foo();\n</code></pre>\n<p><strong>test.cpp</strong></p>\n<pre><code>#include \"test.hpp\"\n\nconstexpr int Foo()\n{\n    return 42;\n}\n</code></pre>\n", "Tags": "<c++><c++11><linker-errors><constexpr>", "OwnerUserId": "1601291", "AnswerCount": "3"}, "16219987": {"ParentId": "16219711", "CommentCount": "0", "Body": "<p>It's an interesting question.  As Andy Prowl, <code>constexpr</code> makes\nthe function <code>inline</code>, which means that there must be\na definition of it in every translation unit which uses it;\nI would have expected an error from the compiler.  (Actually, if\nI read \u00a73.2/5 correctly, a diagnostic is required if you use the\nfunction and there is no definition.)</p>\n<p>As to why <code>const</code> has different behavior: you can't mark\na non-menber function <code>const</code>.  If you write <code>const int Foo();</code>,\nit is not the function which is <code>const</code>, but the type it returns\n(except that if the return type is not a class type,\ncv-qualifiers are ignored, so this is really the same as <code>int\nFoo();</code>). </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "16219987", "Score": "1", "CreationDate": "2013-04-25T16:24:14.337", "LastActivityDate": "2013-04-25T16:24:14.337"}, "16219760": {"ParentId": "16219711", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_16219711_16219760_0\">Why does declaring the function <code>constexpr</code> cause a linker error?</p>\n</blockquote>\n<p>That is because <code>constexpr</code> functions are implicitly <code>inline</code>. Per Paragraph 7.1.5/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16219711_16219760_1\">A <code>constexpr</code> specifier used in the declaration of a function that is not a constructor declares that function\n  to be a <code>constexpr</code> function. Similarly, a <code>constexpr</code> specifier used in a constructor declaration declares that\n  constructor to be a <code>constexpr</code> constructor. <strong><code>constexpr</code> functions and <code>constexpr</code> constructors are implicitly\n  <code>inline</code> (7.1.2).</strong></p>\n</blockquote>\n<p>Per Paragraph 7.1.2/4, then:</p>\n<blockquote>\n<p id=\"so_16219711_16219760_2\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly\n  the same definition in every case (3.2). [...]</p>\n</blockquote>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-25T16:18:41.220", "Id": "16219760", "Score": "8", "CreationDate": "2013-04-25T16:12:21.663", "LastActivityDate": "2013-04-25T16:18:41.220"}, "16220024": {"ParentId": "16219711", "CommentCount": "1", "Body": "<p>The body of a <code>constexpr</code> function must be visible at every point where it's used. In your case you have to <code>move Foo()</code>'s code to <code>test.hpp</code>.</p>\n<p>For instance, consider this code in <code>main.cpp</code>:</p>\n<pre><code>constexpr int Foo(); \n\nint main() {\n  static_assert(Foo() == 42, \"Ops\");\n}\n</code></pre>\n<p>where <code>Foo()</code> is defined in <code>test.cpp</code>. How the compiler is supposed to check the <code>static_assert</code> condition while processing <code>main.cpp</code> if it cannot see that <code>Foo()</code> does return <code>42</code>. That's impossible. The whole point of <code>constexpr</code> functions is that the compiler can \"call\" them at compile time and for this to happen it must see the code.</p>\n<p>Therefore, this compiles fine:</p>\n<pre><code>constexpr int Foo() { return 42; }\n\nint main() {\n  static_assert(Foo() == 42, \"Ops\");\n}\n</code></pre>\n", "OwnerUserId": "1137388", "PostTypeId": "2", "Id": "16220024", "Score": "4", "CreationDate": "2013-04-25T16:26:22.713", "LastActivityDate": "2013-04-25T16:26:22.713"}, "bq_ids": {"n4140": {"so_16219711_16219760_2": {"section_id": 5404, "quality": 1.0, "length": 13}, "so_16219711_16219760_1": {"section_id": 5418, "quality": 0.8, "length": 20}}, "n3337": {"so_16219711_16219760_2": {"section_id": 5199, "quality": 1.0, "length": 13}, "so_16219711_16219760_1": {"section_id": 5213, "quality": 0.8, "length": 20}}, "n4659": {"so_16219711_16219760_2": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_16219711_16219760_1": {"section_id": 6840, "quality": 0.56, "length": 14}}}});