post_cb({"20848261": {"ParentId": "20848132", "CommentCount": "0", "Body": "<p>The wording in the standard is around 5.16/2:</p>\n<blockquote>\n<p id=\"so_20848132_20848261_0\">If either the second or the third operand has type void, then the lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the second and third operands, and one of the following shall hold:</p>\n<p id=\"so_20848132_20848261_1\">\u2014 The second or the third operand (but not both) is a throw-expression (15.1); the result is of the type of the other and is a prvalue.</p>\n</blockquote>\n<p>Which explains the behavior you are getting. It is legal to throw, but the type of the expression is a <em>pure-rvalue</em> (even if the expression is an <em>lvalue</em>) and you cannot thus bind a non-const <em>lvalue-reference</em></p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "20848261", "Score": "13", "CreationDate": "2013-12-30T21:58:59.057", "LastActivityDate": "2013-12-30T21:58:59.057"}, "20848282": {"ParentId": "20848132", "CommentCount": "1", "Body": "<p>The conditional operator is described in 5.16 [expr.cond]. Its paragraph 2 includes the following text:</p>\n<blockquote>\n<p id=\"so_20848132_20848282_0\">The second or the third operand (but not both) is a <em>throw-expression</em> (15.1); the result is of the type of the other and is a prvalue.</p>\n</blockquote>\n<p>That says that it is allowed to throw an exception from the conditional operator. However, even if the other branch is an lvalue, it is turned into an rvalue! Thus, it isn't possible to bind an lvalue to the result of a conditional expression. Aside from rewriting the condition using the comma operator, the code could be rewritten to only obtain the lvalue from the result of the conditional operator:</p>\n<pre><code>template &lt;typename It&gt;\ntypename std::iterator_traits&lt;It&gt;::reference\naccess(It it, It end) {\n    return *(it == end? throw std::runtime_error(\"no element\"): it);\n}\n</code></pre>\n<p>The somewhat tricky business is that returning a <code>const</code> reference from the function would compile but actually return a reference to a temporary!</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "20848282", "Score": "15", "CreationDate": "2013-12-30T22:00:38.697", "LastActivityDate": "2013-12-30T22:00:38.697"}, "20848217": {"ParentId": "20848132", "CommentCount": "5", "Body": "<p>It can be done like this:</p>\n<pre><code>return it == end? (throw std::runtime_error(\"no element\"),*it): *it;\n</code></pre>\n", "OwnerUserId": "2073257", "PostTypeId": "2", "Id": "20848217", "Score": "12", "CreationDate": "2013-12-30T21:55:42.187", "LastActivityDate": "2013-12-30T21:55:42.187"}, "bq_ids": {"n4140": {"so_20848132_20848261_1": {"section_id": 6168, "quality": 0.8333333333333334, "length": 10}, "so_20848132_20848282_0": {"section_id": 6168, "quality": 0.8333333333333334, "length": 10}, "so_20848132_20848261_0": {"section_id": 6172, "quality": 0.5555555555555556, "length": 10}}, "n3337": {"so_20848132_20848261_1": {"section_id": 5929, "quality": 0.8333333333333334, "length": 10}, "so_20848132_20848282_0": {"section_id": 5929, "quality": 0.8333333333333334, "length": 10}, "so_20848132_20848261_0": {"section_id": 5929, "quality": 1.0, "length": 18}}, "n4659": {"so_20848132_20848261_1": {"section_id": 7665, "quality": 0.8333333333333334, "length": 10}, "so_20848132_20848282_0": {"section_id": 7665, "quality": 0.8333333333333334, "length": 10}, "so_20848132_20848261_0": {"section_id": 7667, "quality": 0.6111111111111112, "length": 11}}}, "20848132": {"CommentCount": "5", "AcceptedAnswerId": "20848282", "CreationDate": "2013-12-30T21:49:37.267", "LastActivityDate": "2013-12-30T22:00:38.697", "PostTypeId": "1", "ViewCount": "1096", "FavoriteCount": "3", "Title": "Can an exception be thrown from the ternary operator?", "Id": "20848132", "Score": "22", "Body": "<p>Sometimes it is convenient or even necessary to have a function which just one statement (it is necessary when returning a <code>constexpr</code>). If a condition needs to be checked and only one statement is allowed, the conditional operator is the only option. In case of an error it would be nice to throw an exception from the conditional operator, e.g.:</p>\n<pre><code>template &lt;typename It&gt;\ntypename std::iterator_traits&lt;It&gt;::reference\naccess(It it, It end) {\n    return it == end? throw std::runtime_error(\"no element\"): *it;\n}\n</code></pre>\n<p>The above function doesn't compile, however, when used for example as (<a href=\"http://ideone.com/pXAWrx\">live example</a>):</p>\n<pre><code>std::vector&lt;int&gt; v;\naccess(v.begin(), v.end());\n</code></pre>\n<p>The compiler complains about trying to bind a non-<code>const</code> reference to a temporary. The compiler doesn't complain about the <code>throw</code>-expression per se, though. So the question: Can exceptions be thrown from the conditional operator and, if so, what's going wrong with the above code?</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "1120273", "AnswerCount": "3"}});