post_cb({"5173494": {"CommentCount": "13", "ViewCount": "4500", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-03-02T21:07:49.973", "LastActivityDate": "2013-08-11T22:15:15.990", "Title": "pass reference to array in C++", "FavoriteCount": "10", "LastEditDate": "2011-11-04T01:31:20.360", "Id": "5173494", "Score": "34", "Body": "<p>Can any one help me understand the following code</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(const char * c)\n{\n   std::cout &lt;&lt; \"const char *\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;size_t N&gt;\nvoid foo(const char (&amp;t) [N])\n{\n   std::cout &lt;&lt; \"array ref\" &lt;&lt; std::endl;\n   std::cout &lt;&lt; sizeof(t) &lt;&lt; std::endl;\n}\n\nint main()\n{\n    const char t[34] = {'1'};\n    foo(t);\n\n    char d[34] = {'1'};\n    foo(d);\n}\n</code></pre>\n<p>The output is </p>\n<pre><code>const char *\narray ref\n34\n</code></pre>\n<p>Why does the first foo calls the <code>const char *</code> version ? How can I make it call the reference version ?</p>\n", "Tags": "<c++>", "OwnerUserId": "511274", "AnswerCount": "3"}, "5173876": {"ParentId": "5173494", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This appears to be different for various compilers.</p>\n<p>Mircosoft and Borland both use the const char* version, while GNU is giving the output you described.</p>\n<p>Here is a snippet from the C++ standard:</p>\n<blockquote>\n<p id=\"so_5173494_5173876_0\">14.8.2.1 Deducing template arguments from a function call\n  [temp.deduct.call]</p>\n<p id=\"so_5173494_5173876_1\">Template argument deduction is done by\n  comparing each function template\n  parameter type (call it P) with the\n  type of the corresponding argument of\n  the call (call it A) as described\n  below.</p>\n<p id=\"so_5173494_5173876_2\">If P is not a reference type:</p>\n<p id=\"so_5173494_5173876_3\">-- If A is an array type, the pointer type produced by the array-to-pointer \n  standard conversion (4.2) is used in\n  place of A for type deduction;\n  otherwise,</p>\n<p id=\"so_5173494_5173876_4\">-- If A is a function type, the pointer type produced by the\n  function-to-pointer     standard\n  conversion (4.3) is used in place of A\n  for type deduction; otherwise,</p>\n<p id=\"so_5173494_5173876_5\">-- If A is a cv-qualified type, the top level cv-qualifiers of A's type\n  are     ignored for type deduction.</p>\n<p id=\"so_5173494_5173876_6\">If P is a cv-qualified type, the top\n  level cv-qualifiers of P's type are\n  ignored for type deduction. If P is a\n  reference type, the type referred to\n  by P is used for type deduction</p>\n</blockquote>\n<p>The compiler will build an <code>A</code> list as follows:</p>\n<pre><code>Argument:        t                 d\nA:          char const[34]      char[34]\n</code></pre>\n<p>And parameter list <code>P</code>:</p>\n<pre><code>Parameter:       c                 t\nP:            char const*       char const&amp; t[N]\n</code></pre>\n<p>By default the compiler should choose non-referenced parameters. GNU is dong it wrong the second time for some reason.</p>\n", "OwnerUserId": "640831", "LastEditorUserId": "560648", "LastEditDate": "2013-08-11T22:15:15.990", "Id": "5173876", "Score": "1", "CreationDate": "2011-03-02T21:42:59.887", "LastActivityDate": "2013-08-11T22:15:15.990"}, "5173628": {"ParentId": "5173494", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Conversion of <code>const char[N]</code> to <code>const char*</code> is considered an \"exact match\" (to make literals easier, mainly), and between two exact matches a non-template function takes precedence.</p>\n<p>You can use <code>enable_if</code> and <code>is_array</code> to force it to do what you want.</p>\n<hr>\n<p>A messy way to force it might be:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid foo(const T* c)\n{\n   std::cout &lt;&lt; \"const T*\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename T, size_t N&gt;\nvoid foo(const T (&amp;t) [N])\n{\n   std::cout &lt;&lt; \"array ref\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    const char t[34] = {'1'};\n    foo(t);\n\n    char d[34] = {'1'};\n    foo(d);\n}\n\n/*\narray ref\narray ref\n*/\n</code></pre>\n<p>I realise that the OP had <code>char</code> not some generic <code>T</code>, but nonetheless this demonstrates that the problem lay in one overload being a template and not the other.</p>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-03-02T21:44:43.417", "Id": "5173628", "Score": "15", "CreationDate": "2011-03-02T21:20:47.897", "LastActivityDate": "2011-03-02T21:44:43.417"}, "bq_ids": {"n4140": {"so_5173494_5173876_3": {"section_id": 303, "quality": 1.0, "length": 11}, "so_5173494_5173876_0": {"section_id": 282, "quality": 0.5714285714285714, "length": 4}, "so_5173494_5173876_5": {"section_id": 303, "quality": 1.0, "length": 9}, "so_5173494_5173876_4": {"section_id": 303, "quality": 1.0, "length": 11}, "so_5173494_5173876_1": {"section_id": 302, "quality": 1.0, "length": 18}, "so_5173494_5173876_6": {"section_id": 304, "quality": 1.0, "length": 15}}, "n3337": {"so_5173494_5173876_0": {"section_id": 273, "quality": 0.5714285714285714, "length": 4}, "so_5173494_5173876_3": {"section_id": 294, "quality": 1.0, "length": 11}, "so_5173494_5173876_5": {"section_id": 294, "quality": 1.0, "length": 9}, "so_5173494_5173876_4": {"section_id": 294, "quality": 1.0, "length": 11}, "so_5173494_5173876_1": {"section_id": 293, "quality": 1.0, "length": 18}, "so_5173494_5173876_6": {"section_id": 295, "quality": 1.0, "length": 15}}, "n4659": {"so_5173494_5173876_3": {"section_id": 310, "quality": 1.0, "length": 11}, "so_5173494_5173876_0": {"section_id": 289, "quality": 0.5714285714285714, "length": 4}, "so_5173494_5173876_5": {"section_id": 310, "quality": 0.7777777777777778, "length": 7}, "so_5173494_5173876_4": {"section_id": 310, "quality": 1.0, "length": 11}, "so_5173494_5173876_1": {"section_id": 309, "quality": 1.0, "length": 18}, "so_5173494_5173876_6": {"section_id": 311, "quality": 0.8666666666666667, "length": 13}}}, "5173780": {"ParentId": "5173494", "CommentCount": "6", "Body": "<p>Let's look at this modified example with no template.</p>\n<pre><code>void foo(const char * c)\n{\n    std::cout &lt;&lt; \"const char *\" &lt;&lt; std::endl;\n}\n\nvoid foo(const char (&amp;t) [34])\n{\n    std::cout &lt;&lt; \"const char (&amp;) [34]\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    const char t[34] = {'1'};\n    foo(t);\n}\n</code></pre>\n<p>My compiler says call of overloaded <code>foo</code> is ambiguous.  This is because conversions from array to pointer are considered an \"Exact\" conversion sequence and are not better than the null conversion sequence for overload resolution (Standard section 13.3.3.1.1.)</p>\n<p>In the original code, the template parameter <code>N</code> can be deduced as 34, but then both non-template <code>foo(const char*)</code> and <code>foo&lt;34&gt;(const char (&amp;)[34])</code> are considered in overload resolution.  Since neither is better than the other by conversion rules, the non-template function beats the template function.</p>\n<p>Fixing things seems tricky.  It seems like the <code>is_array</code> template from header <code>&lt;type_traits&gt;</code> (from C++0x if possible or Boost if not) might help.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "5173780", "Score": "5", "CreationDate": "2011-03-02T21:33:29.207", "LastActivityDate": "2011-03-02T21:33:29.207"}});