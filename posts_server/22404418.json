post_cb({"22404984": {"ParentId": "22404418", "CommentCount": "0", "Body": "<p>In C++, the method call will not check for the object creation. For example, consider the following class</p>\n<pre><code>Class Test\n{\n  public:\n    int x;\n    void play(int y) \n    { \n      cout&lt;&lt;\"X Value: \"&lt;&lt;x&lt;&lt;endl; \n      cout&lt;&lt;\"Y Value: \"&lt;&lt;y&lt;&lt;endl;\n    }\n}\n\nint main ()\n{\n   Test t = new Test();\n   t-&gt;x = 5;\n   t-&gt;play();\n   return 0;\n}\n</code></pre>\n<p>In the above code, when I called the play method, internally the method is executed by sending the class instance as a method parameter like below.</p>\n<pre><code>void play(Test obj, int y)\n</code></pre>\n<p>If we call the play method without creating an object, it won't fail in the calling line. The c++ call the play method with null parameter (void play(null, 5)). So, the program throws an exception when the method is trying to use the class object to access its member(int x). (Note: If we didn't use any class members in the method, then the method is successfully executed even without creating the object for class).</p>\n<p>Consider the below code:</p>\n<pre><code>Class Test\n{\n  public:\n    void play(int y) { cout&lt;&lt;\"Y Value: \"&lt;&lt;y&lt;&lt;endl; }\n}\n\nint main ()\n{\n   Test t;\n   t-&gt;play(5);\n   return 0;\n}\n</code></pre>\n<p>In the above example, I called the Play method of Test class without creating the object for the class. Internally play method is called by using null parameter(void play(null, 5)). But, inside the class we didn't used the class object. So, it won't throw any exception and happily printed \"Y Value: 5\" string and the program will successfully got executed.</p>\n<p>Like this, in your code, when you tried to call the play method it will call the method with null parameter. Since, your method is not used any class members your method will got executed successfully. The static_cast&lt;&gt; is not doing any magic here. static_cast&lt;&gt; is used only for the following purposes</p>\n<ul>\n<li>Converting a pointer of a base class to a pointer of a derived class</li>\n<li>Convert numeric data types such as enums to ints or ints to floats</li>\n</ul>\n<p>In your code, static_cast will not convert the Base class to Test class. It just returned some junk pointer. If you used any class members in the play method definitely the call will get failed in the line where you tried to used the class object.</p>\n", "OwnerUserId": "2244486", "PostTypeId": "2", "Id": "22404984", "Score": "0", "CreationDate": "2014-03-14T12:28:06.427", "LastActivityDate": "2014-03-14T12:28:06.427"}, "22404651": {"ParentId": "22404418", "CommentCount": "0", "Body": "<p>This is highly dangerous behaviour. You take a pointer (<code>void*</code>) and make it to point to the address of an already constructed object. This is ok. However, you use the pointer to make it a new kind of object ... This is not ok. The memory layout of class Base and Test are the same, but consider the following changes:</p>\n<pre><code>  #include &lt;iostream&gt;\n\n  using namespace std;\n  class Test\n  {\n    public:\n          Test() : c(1) {}                            // &lt;-- Change here\n          void play(){cout&lt;&lt;\"Test::play\"&lt;&lt; c &lt;&lt;endl;} // &lt;-- Change here\n         int c;                                       // &lt;-- here \n  };\n  class Base\n  {\n    public:\n       Base() : b(2) {}                          // &lt;- here\n    int b;                                  // &lt;- here\n };\n\n int main ()\n {\n    Base b;\n    void* vobj = &amp;b;\n    Test *t = static_cast&lt;Test*&gt;(vobj);\n    t-&gt;play();\n    return 0;\n }\n</code></pre>\n<p>Do you expecet that it will print 1? No. It will print 2 since it is acting as a <code>Test</code> on the memory of a <code>Base</code> obejct :)</p>\n<p>Static cast is not safe and can be misused in situations like this, since no run time check is done whether you are allowed to cast or not :(</p>\n", "OwnerUserId": "186193", "PostTypeId": "2", "Id": "22404651", "Score": "3", "CreationDate": "2014-03-14T12:11:08.200", "LastActivityDate": "2014-03-14T12:11:08.200"}, "22404418": {"CommentCount": "0", "ViewCount": "77", "CreationDate": "2014-03-14T12:00:54.757", "LastActivityDate": "2014-03-14T12:28:06.427", "Title": "Understanding static cast", "AcceptedAnswerId": "22404651", "PostTypeId": "1", "Id": "22404418", "Score": "0", "Body": "<p>I am trying to understand static_cast. I have simple code in which I have two classes.\nI am assigning one class object to another class object via void pointer.</p>\n<p>As per my understanding program should not work</p>\n<pre><code>  #include &lt;iostream&gt;\n\n  using namespace std;\n  class Test\n  {\n    public:\n          void play(){cout&lt;&lt;\"Test::play\"&lt;&lt;endl;}\n  };\n  class Base\n  {\n    public:\n\n  };\n\n  int main ()\n  {\n     Base b;\n     void* vobj = &amp;b;\n     Test *t = static_cast&lt;Test*&gt;(vobj);\n     t-&gt;play();\n     return 0;\n  }\n</code></pre>\n<p>After running this program I got output as </p>\n<pre><code>  Test::play\n</code></pre>\n<p>Please help me to understand this behavior.</p>\n", "Tags": "<c++>", "OwnerUserId": "3013022", "AnswerCount": "4"}, "22404653": {"ParentId": "22404418", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It works because:</p>\n<ol>\n<li><p>The type of variable <code>vobj</code> is <code>void*</code>, and a static cast from <code>void*</code> to <code>Test*</code> is acceptable. Therefore, the compiler does not generate a compilation error for <code>static_cast&lt;Test*&gt;(vobj)</code>.</p></li>\n<li><p>Function <code>play</code> is not virtual in the hierarchy of its class, so the compiler can replace the call to this function with a direct jump to its address without reading it from the V-Table of the calling object first.</p></li>\n<li><p>Function <code>play</code> does not make use of any member fields of the calling object (<code>this</code>) , so the type of the calling object makes no difference (and in essence, it is exactly like calling a global function).</p></li>\n</ol>\n", "OwnerUserId": "1382251", "LastEditorUserId": "1382251", "LastEditDate": "2014-03-14T12:19:04.373", "Id": "22404653", "Score": "2", "CreationDate": "2014-03-14T12:11:12.520", "LastActivityDate": "2014-03-14T12:19:04.373"}, "bq_ids": {"n4140": {"so_22404418_22404604_0": {"section_id": 6039, "quality": 0.8913043478260869, "length": 41}}, "n3337": {"so_22404418_22404604_0": {"section_id": 5807, "quality": 0.8913043478260869, "length": 41}}, "n4659": {"so_22404418_22404604_0": {"section_id": 7536, "quality": 0.5652173913043478, "length": 26}}}, "22404604": {"ParentId": "22404418", "CommentCount": "0", "Body": "<p>Your program is <strong>technically</strong> well-formed, although it isn't in practice, of course.</p>\n<p>5.2.9/13 states:</p>\n<blockquote>\n<p id=\"so_22404418_22404604_0\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue of type \u201cpointer to cv2 T,\u201d where\n  T is an object type and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. The null\n  pointer value is converted to the null pointer value of the destination type. A value of type pointer to object\n  converted to \u201cpointer to cv void\u201d and back, possibly with different cv-qualification, shall have its original\n  value.</p>\n</blockquote>\n<p>That is what you are doing. You are tricking the compiler (around two corners) into doing an illegal conversion. The intent of allowing those conversions from <code>void*</code> to another type is of course <strong>not</strong> to allow you to do any cast (whether it's legal or not), but rather to allow some cases where you legitimately cast a <code>void*</code> to a class <em>knowing that it's correct</em>.</p>\n<p>It still \"works\", or so it seems, but that is just luck (or rather, bad luck... would be better if it crashed).</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "22404604", "Score": "1", "CreationDate": "2014-03-14T12:09:17.567", "LastActivityDate": "2014-03-14T12:09:17.567"}});