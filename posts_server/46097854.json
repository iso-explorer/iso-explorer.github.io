post_cb({"bq_ids": {"n4140": {"so_46097854_46099015_2": {"length": 35, "quality": 1.0, "section_id": 481}}, "n3337": {"so_46097854_46099015_2": {"length": 32, "quality": 0.9142857142857143, "section_id": 472}}, "n4659": {"so_46097854_46099015_1": {"length": 9, "quality": 1.0, "section_id": 504}, "so_46097854_46099015_2": {"length": 35, "quality": 1.0, "section_id": 504}}}, "46097854": {"ViewCount": "135", "Body": "<p>The following code returns a move-only type that should then be converted to another type by a converting constructor.</p>\n<pre><code>#include &lt;utility&gt;\n\nclass Foo\n{\npublic:\n  Foo() {}\n  Foo(const Foo&amp;) = delete;\n  Foo(Foo&amp;&amp;) = default;\n};\n\nclass Other\n{\npublic:\n  Other(Foo foo) {}\n};\n\n\nOther moo()\n{\n  Foo foo;\n  return foo;\n}\n\nint main()\n{\n  moo();\n}\n</code></pre>\n<p>This threw me an error with my compiler and could only be fixed by adding <code>std::move</code> to the return statement which is considered bad practice, because in general it prevents return value optimization. Shouldn't the identifier of a return statement be treated as rvalue first to satisfy conversions?</p>\n<p>Is this code valid and which compiler is right here?</p>\n<ul>\n<li>g++, c++14: compiles: <a href=\"http://coliru.stacked-crooked.com/a/f25ae94e8ca9c5c8\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/f25ae94e8ca9c5c8</a></li>\n<li>g++-4.8, c++11: does not compile: <a href=\"http://coliru.stacked-crooked.com/a/0402e3ebf97fd0e7\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/0402e3ebf97fd0e7</a></li>\n<li>clang++, c++14: does not compile: <a href=\"http://coliru.stacked-crooked.com/a/682d8ca93d3e2f6a\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/682d8ca93d3e2f6a</a></li>\n</ul>\n", "AcceptedAnswerId": "46099015", "Title": "Move-only type returned into converting constructor", "CreationDate": "2017-09-07T13:37:40.573", "Id": "46097854", "CommentCount": "17", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-09-07T14:24:17.587", "LastEditorUserId": "2684539", "LastActivityDate": "2017-09-07T15:17:00.157", "Score": "4", "OwnerUserId": "2040925", "Tags": "<c++><language-lawyer><move-semantics><rvalue>", "AnswerCount": "2"}, "46099745": {"Id": "46099745", "PostTypeId": "2", "Body": "<p>Barry's fine answer covers the standard rules, but I have a practical suggestion:</p>\n<blockquote>\n<p id=\"so_46097854_46099745_0\">and could only be fixed by adding <code>std::move</code> to the return statement which is considered bad practice, because in general it prevents return value optimization. </p>\n</blockquote>\n<p>Your worry is unjustified. NRVO does not apply to conversions anyway, and RVO on the result of the move is allowed. The explicit move is fine.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2017-09-07T15:17:00.157", "Score": "2", "CreationDate": "2017-09-07T15:06:58.270", "ParentId": "46097854", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2017-09-07T15:17:00.157"}, "46099015": {"Id": "46099015", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46097854_46099015_0\">Shouldn't the identifier of a return statement be treated as rvalue first to satisfy conversions?</p>\n</blockquote>\n<p>Yes and no. From <a href=\"http://eel.is/c++draft/class.copy#elision-3\" rel=\"nofollow noreferrer\">[class.copy]</a>, as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"nofollow noreferrer\">CWG 1579</a> (the wording here is copied from C++17, although it's the same in <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.copy#32\" rel=\"nofollow noreferrer\">C++14</a>. I find the bullets easier to read than the earlier grammar choice that would make James Joyce blush... ):</p>\n<blockquote>\n<p id=\"so_46097854_46099015_1\">In the following copy-initialization contexts, a move operation might be used instead of a copy operation:  </p>\n<ul>\n<li>If the expression in a <code>return</code> statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, or</li>\n<li>[...]  </li>\n</ul>\n<p id=\"so_46097854_46099015_2\">overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If the first overload resolution fails or was not performed, or <strong>if the type of the first parameter of the selected constructor is not an rvalue reference to the object's type</strong> (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue.</p>\n</blockquote>\n<p>The first bullet applies here, so we first do overload resolution as if <code>foo</code> was an rvalue. This gets is to the <code>Other(Foo )</code> constructor by way of <code>Foo(Foo&amp;&amp; )</code>. </p>\n<p>The first parameter of <code>Other(Foo )</code> is not an rvalue reference, so we should do overload resolution again considering the <code>foo</code> as an lvalue, which fails. This seems like an unnecessary restriction, but I'd call clang correct here. If you change the constructor to <code>Other(Foo&amp;&amp; )</code>, clang accepts it. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-09-07T14:47:45.983", "Score": "4", "CreationDate": "2017-09-07T14:32:18.517", "ParentId": "46097854", "CommentCount": "7", "OwnerUserId": "2069064", "LastEditDate": "2017-09-07T14:47:45.983"}});