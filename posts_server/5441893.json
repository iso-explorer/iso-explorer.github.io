post_cb({"5441944": {"ParentId": "5441893", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_5441893_5441944_0\">Iterators can also have singular values <strong>that are not associated with any container</strong>.</p>\n</blockquote>\n<p>I suppose that's its definition.</p>\n<blockquote>\n<p id=\"so_5441893_5441944_1\">How and why dereferenceable values are always nonsingular?</p>\n</blockquote>\n<p>Because if they wouldn't, dereferencing them would be undefined behavior.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5441944", "Score": "8", "CreationDate": "2011-03-26T11:17:09.200", "LastActivityDate": "2011-03-26T11:17:09.200"}, "bq_ids": {"n4140": {"so_5441893_5441893_0": {"section_id": 5559, "quality": 0.898876404494382, "length": 80}, "so_5441893_5441944_1": {"section_id": 5559, "quality": 0.6666666666666666, "length": 4}, "so_5441893_5441944_0": {"section_id": 5559, "quality": 0.875, "length": 7}, "so_5441893_5442120_2": {"section_id": 5559, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_5441893_5441893_0": {"section_id": 5341, "quality": 0.898876404494382, "length": 80}, "so_5441893_5441944_1": {"section_id": 5341, "quality": 0.6666666666666666, "length": 4}, "so_5441893_5441944_0": {"section_id": 5341, "quality": 0.875, "length": 7}, "so_5441893_5442120_2": {"section_id": 5341, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_5441893_5441944_1": {"section_id": 7006, "quality": 0.6666666666666666, "length": 4}, "so_5441893_5442120_2": {"section_id": 7006, "quality": 0.6666666666666666, "length": 4}, "so_5441893_5441944_0": {"section_id": 7006, "quality": 0.875, "length": 7}, "so_5441893_5441893_0": {"section_id": 7006, "quality": 0.898876404494382, "length": 80}}}, "5442120": {"ParentId": "5441893", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_5441893_5442120_0\">What is singular value and nonsingular value? How are they defined? And where?</p>\n</blockquote>\n<p>Let us use the simplest incarnation of an <code>Iterator</code>: the pointer.</p>\n<p>For a pointer:</p>\n<ul>\n<li>the singular value alluded to is <strike>the NULL value</strike> an uninitialized value.</li>\n<li>a non-singular value is an explicitly initialized value, it may not be dereferencable still (the past-the-end pointer shall not be dereferenced)</li>\n</ul>\n<p>I would say that the <code>NULL</code> pointer is a singular value, though not the only one, since it represents the absence of value.</p>\n<blockquote>\n<p id=\"so_5441893_5442120_1\">What is the equivalence for regular iterators ?</p>\n</blockquote>\n<p><code>std::vector&lt;int&gt;::iterator it;</code>, the default constructor of most iterators (those linked to a container) create a singular value. Since it's not tied to a container, any form of navigation (increment, decrement, ...) is meaningless.</p>\n<blockquote>\n<p id=\"so_5441893_5442120_2\">How and why dereferenceable values are always nonsingular ?</p>\n</blockquote>\n<p>Singular values, by definition, represent the absence of a real value. They appear in many languages: Python's <code>None</code>, C#'s <code>null</code>, C's <code>NULL</code>, C++'s <code>std::nullptr</code>. The catch is that in C or C++, they may also be simple garbage... (whatever was there in memory before)</p>\n<blockquote>\n<p id=\"so_5441893_5442120_3\">Is a default constructed iterator a singular value ?</p>\n</blockquote>\n<p>Not necessarily, I guess. It is not required by the standard, and one could imagine the use of a sentinel object.</p>\n", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2011-03-28T13:15:31.130", "Id": "5442120", "Score": "2", "CreationDate": "2011-03-26T11:53:29.990", "LastActivityDate": "2011-03-28T13:15:31.130"}, "5441934": {"ParentId": "5441893", "CommentCount": "2", "Body": "<p>If I understand this correctly, a singular value for an iterator is essentially the equivalent of an unassigned pointer.  It's an iterator that hasn't been initialized to point anywhere and thus has no well-defined element it's iterating over.  Declaring a new iterator that isn't set up to point to an element of a range, for example, creates that iterator as a singular iterator.</p>\n<p>As the portion of the spec alludes to, singular iterators are unsafe and none of the standard iterator operations, such as increment, assignment, etc. can be used on them.  All you can do is assign them a new value, hopefully pointing them at valid data.</p>\n<p>I think the reason for having this definition is so that statements like</p>\n<pre><code>set&lt;int&gt;::iterator itr;\n</code></pre>\n<p>Can be permitted by the spec while having standardized meaning.  The term \"singular\" here probably refers to the mathematical definition of a singularity, which is also called a \"discontinuity\" in less formal settings.</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "5441934", "Score": "8", "CreationDate": "2011-03-26T11:15:42.613", "LastActivityDate": "2011-03-26T11:15:42.613"}, "5441893": {"CommentCount": "0", "AcceptedAnswerId": "5441944", "CreationDate": "2011-03-26T11:07:04.690", "LastActivityDate": "2011-03-28T13:15:31.130", "PostTypeId": "1", "ViewCount": "3127", "FavoriteCount": "3", "Title": "What is singular and non-singular values in the context of STL iterators?", "Id": "5441893", "Score": "9", "Body": "<p>The section \u00a724.1/5 from the C++ Standard (2003) reads,</p>\n<blockquote>\n<p id=\"so_5441893_5441893_0\">Just as a regular pointer to an array\n  guarantees that there is a pointer\n  value pointing past the last element\n  of the array, so for any iterator type\n  there is an iterator value that points\n  past the last element of a\n  corresponding container. These values\n  are called past-the-end values. Values\n  of an iterator i for which the\n  expression *i is defined are called\n  dereferenceable. The library never\n  assumes that past-the-end values are\n  dereferenceable. <strong>Iterators can also\n  have singular values that are not\n  associated with any container.</strong>\n  [Example: After the declaration of an\n  uninitialized pointer x (as with int*\n  x;), x must always be assumed to have\n  a singular value of a pointer.]\n  <strong>Results of most expressions are\n  undefined for singular values; the\n  only exception is an assignment of a\n  non-singular value to an iterator that\n  holds a singular value. In this case\n  the singular value is overwritten the\n  same way as any other value.\n  Dereferenceable values are always\n  nonsingular.</strong></p>\n</blockquote>\n<p>I couldn't really understand the text shown in <strong>bold</strong>? </p>\n<ul>\n<li>What is singular value and nonsingular value? How are they defined? And where?</li>\n<li>How and <em>why</em> dereferenceable values are <em>always</em> nonsingular?</li>\n</ul>\n", "Tags": "<c++><pointers><stl><iterator><standards>", "OwnerUserId": "415784", "AnswerCount": "4"}, "5442000": {"ParentId": "5441893", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Have a look at <a href=\"https://stackoverflow.com/questions/3395180/what-is-an-iterators-default-value\">What is an iterator's default value?</a>.</p>\n<p>As the quote indicates, singular values are iterator values that are not associated with any container. A singular value is almost useless: you can't advance it, dereference it, etc. One way (the only way?) of getting a singular iterator is by not initializing it, as shown in templatetypedef's answer.</p>\n<p>One of the useful things you <em>can</em> do with a singular iterator, is <em>assign</em> it a non-singular value. When you do that you can do whatever else you want with it.</p>\n<p>The non-singular values are, almost by definition, iterator values that <em>are</em> associated with a container. This answers why dereferenceable values are always non-singular: iterators that do not point to any container cannot be dereferenced (what element would this return?).</p>\n<p>As Matthieu M. correctly noted, non-singular values may still be non-dereferenceable. An example is the past-the-end iterator (obtainable by calling container.end()): it is associated with a container, but still cannot be referenced.</p>\n<p>I can't say where these terms are defined. However, Google has this to say about \"define: singular\" (among other definitions):</p>\n<pre><code>remarkable: unusual or striking\n</code></pre>\n<p>I suppose this can explain the terminology.</p>\n", "OwnerUserId": "447202", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:03:59.873", "Id": "5442000", "Score": "2", "CreationDate": "2011-03-26T11:27:35.363", "LastActivityDate": "2011-03-26T12:17:32.503"}});