post_cb({"908830": {"ViewCount": "2294", "Body": "<p>I have a class that had an inline member, but I later decided that I wanted to remove the implementation from the headers so I moved the members body of the functions out to a cpp file. At first I just left the inlined signature in the header file (sloppy me) and the program failed to link correctly. Then I fixed my header and it all works fine, of course.</p>\n<p><em>But wasn't inline totally optional?</em></p>\n<p>In code:</p>\n<p>First:</p>\n<pre><code>//Class.h\nclass MyClass\n{\n   void inline foo()\n   {}\n};\n</code></pre>\n<p>Next changed to (won't link):</p>\n<pre><code>//Class.h\nclass MyClass\n{\n   void inline foo();\n};\n\n//Class.cpp\nvoid MyClass::foo()\n{}\n</code></pre>\n<p>And then to (will work fine):</p>\n<pre><code>//Class.h\nclass MyClass\n{\n   void foo();\n};\n\n//Class.cpp\nvoid MyClass::foo()\n{}\n</code></pre>\n<p>I thought inline was optional, and imagined I might get by with a warning for my sloppiness, but didn't expect a linking error. What's the correct/standard thing a compiler should do in this case, did I deserve my error according to the standard?</p>\n", "AcceptedAnswerId": "910686", "Title": "Isn't C++'s inline totally optional?", "CreationDate": "2009-05-26T03:37:35.830", "Id": "908830", "CommentCount": "0", "FavoriteCount": "11", "PostTypeId": "1", "LastActivityDate": "2009-07-05T18:51:41.810", "Score": "18", "OwnerUserId": "15124", "Tags": "<c++><inline>", "AnswerCount": "4"}, "912575": {"Id": "912575", "PostTypeId": "2", "Body": "<p>Regarding harshath.jr's answer, a method need not be declared inline if its definition has the \"inline\" keyword, and that definition is available in the same header, <em>i.e.</em>:</p>\n<pre><code>class foo\n{\n  void bar();\n};\n\ninline void foo::bar()\n{\n  ...\n}\n</code></pre>\n<p>This is useful for conditionally inlining a method depending on whether or not the build is \"<em>debug</em>\" or \"<em>release</em>\" like so:</p>\n<pre><code>// Header - foo.h\n\nclass foo\n{\n  void bar();  // Conditionally inlined.\n};\n\n#ifndef FOO_DEBUG\n# include \"foo.inl\"\n#endif\n</code></pre>\n<p>The \"inline\" file could look like:</p>\n<pre><code>// Inline Functions/Methods - foo.inl\n#ifndef FOO_DEBUG\n# define FOO_INLINE inline\n#else\n# define FOO_INLINE\n#endif\n\nFOO_INLINE void foo::bar()\n{\n  ...\n}\n</code></pre>\n<p>and the implementation could like the following:</p>\n<pre><code>// Implementation file - foo.cpp\n#ifdef FOO_DEBUG\n# include \"foo.inl\"\n#endif\n\n...\n</code></pre>\n<p>It's not exactly pretty but it has it's uses when aggressive inline becomes a debugging headache.</p>\n", "LastActivityDate": "2009-05-26T20:28:33.783", "CommentCount": "0", "CreationDate": "2009-05-26T20:28:33.783", "ParentId": "908830", "Score": "2", "OwnerUserId": "69998"}, "bq_ids": {"n4140": {"so_908830_910686_2": {"length": 16, "quality": 1.0, "section_id": 7138}, "so_908830_910686_3": {"length": 18, "quality": 0.9, "section_id": 7137}, "so_908830_910686_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 7041}, "so_908830_910686_4": {"length": 37, "quality": 0.9487179487179487, "section_id": 7043}, "so_908830_910686_1": {"length": 69, "quality": 0.9857142857142858, "section_id": 5404}}, "n3337": {"so_908830_910686_2": {"length": 16, "quality": 1.0, "section_id": 6882}, "so_908830_910686_3": {"length": 18, "quality": 0.9, "section_id": 6881}, "so_908830_910686_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 6786}, "so_908830_910686_4": {"length": 37, "quality": 0.9487179487179487, "section_id": 6788}, "so_908830_910686_1": {"length": 69, "quality": 0.9857142857142858, "section_id": 5199}}, "n4659": {"so_908830_910686_2": {"length": 13, "quality": 0.8125, "section_id": 8639}, "so_908830_910686_3": {"length": 18, "quality": 0.9, "section_id": 8638}, "so_908830_910686_0": {"length": 29, "quality": 0.8529411764705882, "section_id": 8538}, "so_908830_910686_4": {"length": 37, "quality": 0.9487179487179487, "section_id": 8540}, "so_908830_910686_1": {"length": 62, "quality": 0.8857142857142857, "section_id": 6853}}}, "908928": {"Id": "908928", "PostTypeId": "2", "Body": "<p>Point to note: when method is declared inline, its definition MUST be together with its declaration.</p>\n", "LastActivityDate": "2009-05-26T04:24:08.903", "CommentCount": "2", "CreationDate": "2009-05-26T04:24:08.903", "ParentId": "908830", "Score": "6", "OwnerUserId": "2119053"}, "910686": {"Id": "910686", "PostTypeId": "2", "Body": "<p>Indeed, there is this one definition rule saying that an inline function <em>must</em> be defined in every translation unit it is used. Gory details follow. First <code>3.2/3</code>:</p>\n<blockquote>\n<p id=\"so_908830_910686_0\">Every program shall contain exactly one definition of every non-inline function or object that is used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8).\n  An inline function shall be defined in every translation unit in which it is used.</p>\n</blockquote>\n<p>And of course <code>7.1.2/4</code>:</p>\n<blockquote>\n<p id=\"so_908830_910686_1\">An inline function shall be defined in every translation unit in which it is used and shall have exactly the same definition in every case (3.2). [Note: a call to the inline function may be encountered before its definition appears in the translation unit. ] If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required. An inline function with external linkage shall have the same address in all translation units. A static local variable in an extern inline function always refers to the same object. A string literal in an extern inline function is the same object in different translation units.</p>\n</blockquote>\n<p>However, if you define your function within the class definition, it is implicitly declared as <code>inline</code> function. That will allow you to include the class definition containing that inline function body multiple times in your program. Since the function has <code>external</code> linkage, any definition of it will refer to the <em>same</em> function (or more gory - to the same <code>entity</code>). </p>\n<p>Gory details about my claim. First <code>3.5/5</code>:</p>\n<blockquote>\n<p id=\"so_908830_910686_2\">In addition, a member function, static data member, class or enumeration of class scope has external linkage if the name of the class has external linkage.</p>\n</blockquote>\n<p>Then <code>3.5/4</code>:</p>\n<blockquote>\n<p id=\"so_908830_910686_3\">A name having namespace scope has external linkage if it is the name of [...] a named class (clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes.</p>\n</blockquote>\n<p>This \"name for linkage purposes\" is this fun thing:</p>\n<pre><code>typedef struct { [...] } the_name;\n</code></pre>\n<p>Since now you have multiple definitions of the <em>same entity</em> in your programs, another thing of the ODR happens to restrict you. <code>3.2/5</code> follows with boring stuff.</p>\n<blockquote>\n<p id=\"so_908830_910686_4\">There can be more than one definition of a class type (clause 9), enumeration type (7.2), inline function with external linkage (7.1.2) [...] in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n<li>in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined within the definition of D, or shall refer to the same entity, after overload resolution (13.3) and after matching of partial template specialization (14.8.3) [...]</li>\n</ul>\n</blockquote>\n<p>I cut off some unimportant stuff now. The above are the two important one to remember about inline functions. If you define an extern inline function multiple times, but do define it differently, or if you define it and names used within it resolve to different entities, then you are doing undefined behavior. </p>\n<p>The rule that the function has to be defined in every TU in which it is used is easy to remember. And that it is the same is also easy to remember. But what about that name resolution thingy? Here some example. Consider a static function <code>assert_it</code>:</p>\n<pre><code>static void assert_it() { [...] }\n</code></pre>\n<p>Now, since <code>static</code> will give it internal linkage, when you include it into multiple translation units, then each definition will define a <em>different entity</em>. This means that you are <em>not</em> allowed to use <code>assert_it</code> from an extern inline function that's going to be defined multiple times in the program: Because what happens is that the inline function will refer to one entity called <code>assert_it</code> in one TU, but to another entity of the same name in another TU. You will find that this all is boring theory and compilers won't probably complain, but i found this example in particular shows the relation between the ODR and entities. </p>\n<hr>\n<p>What follows is getting back to your particular problem again. </p>\n<p>Following are the same things:</p>\n<pre><code>struct A { void f() { } };\nstruct A { inline void f(); }; void A::f() { } // same TU!\n</code></pre>\n<p>But this one is different, since the function is non-inline. You will violate the ODR, since you have more than one definition of <code>f</code> if you include the header more than once</p>\n<pre><code>struct A { void f(); }; void A::f() { } // evil!\n</code></pre>\n<p>Now if you put <code>inline</code> on the declaration of <code>f</code> inside the class, but then omit defining it in the header, then you violate <code>3.2/3</code> (and <code>7.1.2/4</code> which says the same thing, just more elaborating), since the function isn't defined in that translation unit! </p>\n<p>Note that in C (C99), inline has different semantics than in C++. If you create an extern inline function, you should first read some good paper (preferably the Standard), since those are really tricky in C (basically, any used inline-definition of a function will need another, non-inline function definition in another TU. static inline functions in C are easy to handle. They behave like any other function, apart of having the usual \"inline substitution\" hint. static <code>inline</code> in both C and C++ serve only as a inline-substitution hint. Since static will already create a different entity any time it's used (because of internal linkage), <code>inline</code> will just add the inline-substitution hint - not more. </p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2009-07-05T18:51:41.810", "Score": "34", "CreationDate": "2009-05-26T13:29:20.590", "ParentId": "908830", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2009-07-05T18:51:41.810"}, "908834": {"Id": "908834", "PostTypeId": "2", "Body": "<p>Whether or not the method is actually inlined is at the sole discretion of the compiler.  However the presence of the inline keyword will also affect the linkage of the method.</p>\n<p>C++ linkage is not my specialty so I'll defer to the links for a better explanation.  </p>\n<ul>\n<li><a href=\"http://publib.boulder.ibm.com/infocenter/zos/v1r9/index.jsp?topic=/com.ibm.zos.r9.cbclx01/inline_linkage.htm\" rel=\"nofollow noreferrer\">http://publib.boulder.ibm.com/infocenter/zos/v1r9/index.jsp?topic=/com.ibm.zos.r9.cbclx01/inline_linkage.htm</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Inline_function\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Inline_function</a></li>\n</ul>\n<p>Alternately you can just wait for <a href=\"https://stackoverflow.com/users/34509/litb\">litb</a> to provide the gory details in an hour or so ;)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-05-26T04:18:06.000", "Score": "10", "CreationDate": "2009-05-26T03:39:23.850", "ParentId": "908830", "CommentCount": "4", "OwnerUserId": "23283", "LastEditDate": "2017-05-23T12:00:28.850"}});