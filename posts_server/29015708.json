post_cb({"29015969": {"ParentId": "29015708", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is going to be 'opinion based' and as such is not strictly on-tpoic for SO.</p>\n<p>However I don't see the point in using iterators in this case as the <code>read()</code> function is more succinct.</p>\n<p>However, more importantly, the way you are doing this breaks strict aliasing rules because the alignment in memory of your <code>struct</code> is not guaranteed to be in line with a <code>char</code> array.</p>\n<p>It is always best to cast the address of the <code>struct</code> to a <code>char*</code> not the other way round:</p>\n<pre><code>HeaderType header;\n\nFile.read(reinterpret_cast&lt;char*&gt;(&amp;header), sizeof(header));\nFile.close();\n</code></pre>\n<p>Reading data in binary like this is not portable and won't work for complex user-defined types (like <code>std::string</code>) so it is preferred to serialize all the data members as a formatted string.</p>\n<p><strong>NOTE:</strong> See docs for <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\">reinterpret_cast</a> for information on type aliasing.</p>\n", "OwnerUserId": "3807729", "LastEditorUserId": "3807729", "LastEditDate": "2015-03-12T17:19:09.940", "Id": "29015969", "Score": "1", "CreationDate": "2015-03-12T17:04:00.897", "LastActivityDate": "2015-03-12T17:19:09.940"}, "29015708": {"CommentCount": "1", "ViewCount": "302", "PostTypeId": "1", "LastEditorUserId": "4184203", "CreationDate": "2015-03-12T16:52:08.297", "LastActivityDate": "2015-03-12T18:50:36.987", "Title": "What's the difference between ifstream with or without istreambuf_iterator?", "LastEditDate": "2015-03-12T17:16:58.837", "Id": "29015708", "Score": "1", "Body": "<p>I need to read a binary file (in one go) which contains a header and data. There are different ways to read a file in C++ and I would like to know which one is the fastest and more reliable. I also don't know if <code>reintrerpret_cast</code> is the best way to turn raw data into a structure.  </p>\n<p>EDIT: The header structure doesn't have any functions, only data.</p>\n<pre><code>ifstream File(Filename, ios::binary);    // Opens file\n\nif (!File)    // Stops if an error occured\n{\n    /* ... */\n}\n\nFile.seekg(0, ios::end);\nsize_t Size = File.tellg();    // Get size\nFile.seekg(0, ios::beg);\n</code></pre>\n<p>This is ifstream WITHOUT istreambuf_iterator</p>\n<pre><code>char* Data = new char[Size];\n\nFile.read(Data, Size);\nFile.close();\n\nHeaderType *header = reinterpret_cast&lt;HeaderType*&gt;(Data);\n\n/* ... */\n\ndelete[] Data;\n</code></pre>\n<p>This is ifstream WITH istreambuf_iterator</p>\n<pre><code>std::string Data;    // Is it better to use another container type?\n\nData.reserve(Size);\nstd::copy((std::istreambuf_iterator&lt;char&gt;(File)), std::istreambuf_iterator&lt;char&gt;(),\n          std::back_inserter(Data));\n\nFile.close();\n\nconst HeaderType *header = reinterpret_cast&lt;HeaderType*&gt;(Data.data());\n</code></pre>\n<p>Also found this in the Internet</p>\n<pre><code>std::ostringstream Data;\nData &lt;&lt; File.rdbuf();\nFile.close();\nstd::string String = Data.str();\n\nconst HeaderType *header = reinterpret_cast&lt;HeaderType*&gt;(String.data());\n</code></pre>\n", "Tags": "<c++><ifstream><istream-iterator>", "OwnerUserId": "4184203", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29015708_29016046_2": {"section_id": 6046, "quality": 0.639344262295082, "length": 39}}, "n3337": {"so_29015708_29016046_2": {"section_id": 5814, "quality": 0.9344262295081968, "length": 57}}, "n4659": {"so_29015708_29016046_2": {"section_id": 7545, "quality": 0.6229508196721312, "length": 38}}}, "29016046": {"ParentId": "29015708", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Reading the contents of the file into a <code>char*</code> and then performing <code>reinterpret_cast</code> to <code>HeaderType*</code> is not a good idea. </p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_29015708_29016046_0\"><strong>5.2.10 Reinterpret cast</strong></p>\n<p id=\"so_29015708_29016046_1\">...</p>\n<p id=\"so_29015708_29016046_2\">7 An object pointer can be explicitly converted to an object pointer of a different type<sup>70</sup>. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. The result of any other such pointer conversion is unspecified.</p>\n</blockquote>\n<p>In your case, if alignment requirements of <code>HeaderType</code> are stricter than <code>char</code>, you will run into undefined behavior.</p>\n<p>If you have the choice, I would suggest.</p>\n<ol>\n<li><p>Read the header first.</p>\n<pre><code>HeaderType header;\nFile.read(reinterpret_cast&lt;char*&gt;(&amp;header), sizeof(HeaderType));\n</code></pre></li>\n<li><p>Read the rest of the data based on the value of <code>header</code>.</p></li>\n</ol>\n", "OwnerUserId": "434551", "LastEditorUserId": "701092", "LastEditDate": "2015-03-12T18:05:44.227", "Id": "29016046", "Score": "3", "CreationDate": "2015-03-12T17:08:31.180", "LastActivityDate": "2015-03-12T18:05:44.227"}, "29017937": {"ParentId": "29015708", "CommentCount": "2", "Body": "<p>First, none of the solutions you describe will actually work; the\n<code>reinterpret_cast</code> should tell you that.  At some point, you'll have to\nparse the bytes in the buffer, and insert the extracted data field by\nfield into your internal data structures.</p>\n<p>As for getting the bytes into the buffer as quickly as possible, the\nless extra work you do, the better.  The fastest way would be to either\nuse low level IO (<code>open</code> and then <code>read</code> under Unix), or even map the\nfile into memory (<code>mmap</code> under Unix).  Of course, this is system\ndependent; if you want to use <code>ifstream</code> in order to achieve system\nindependence, then using <code>istream::read</code> is certainly the fastest (and\nthe most logical, all things considered).  Just be sure that the stream\nis imbued with the <code>\"C\"</code> locale, as well as being opened in binary mode.</p>\n<p>For the record: using the system level functions will transfer the data\ndirectly from the OS into your buffer.  <code>istream::read</code> will copy from\nan interal buffer in the <code>filebuf</code> into your buffer (and use the system\nlevel functions to get the data into your buffer).  The other two will\nbuild an <code>std::string</code> object, byte by byte, allocating memory as\nneeded, since the final length won't be known.</p>\n<p>And finally, rather than <code>new char[size]</code>, use an <code>std::vector&lt;char&gt;</code>.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "29017937", "Score": "0", "CreationDate": "2015-03-12T18:50:36.987", "LastActivityDate": "2015-03-12T18:50:36.987"}});