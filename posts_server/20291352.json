post_cb({"22374366": {"ParentId": "20291352", "CommentCount": "0", "Body": "<p>This does not answer the question whether the code above is valid, but is a quite pretty workaround that I have found by experimenting shortly after asking the question, and I think is useful to share.</p>\n<p>All that is needed are the following definitions:</p>\n<pre><code>template &lt;template &lt;typename...&gt; class F&gt;\nstruct temp { };\n\ntemplate &lt;typename... A, template &lt;typename...&gt; class F&gt;\nF &lt;A...&gt; subs_fun(temp &lt;F&gt;);\n\ntemplate &lt;template &lt;typename...&gt; class F, typename... A&gt;\nusing subs = decltype(subs_fun &lt;A...&gt;(temp &lt;F&gt;()));\n</code></pre>\n<p>then, wherever <code>F &lt;A...&gt;</code> would be problematic, replace it with <code>subs &lt;F, A...&gt;</code>. That's it. I cannot explain why, but it has worked in all cases so far.</p>\n<p>For instance, in the SFINAE example of the question, just replace line</p>\n<pre><code>template &lt;typename... A&gt; static pass &lt;F &lt;A...&gt; &gt; _(int);\n</code></pre>\n<p>by</p>\n<pre><code>template &lt;typename... A&gt; static pass &lt;subs &lt;F, A...&gt; &gt; _(int);\n</code></pre>\n<p>This is a change at one point only, all remaining code stays the same. You don't need to redefine or wrap every template metafunction that with be used as <code>F</code>. Here's a <a href=\"http://coliru.stacked-crooked.com/a/4642824fef85911c\" rel=\"nofollow\">live example</a>.</p>\n<p>If <code>F &lt;A...&gt;</code> is indeed valid and compilers support it eventually, it is again easy to switch back because changes are minimal.</p>\n<p>I find this important because it allows specifying a SFINAE test in just two lines</p>\n<pre><code>template &lt;typename T&gt; using type_of  = typename T::type;\ntemplate &lt;typename T&gt; using has_type = sfinae &lt;type_of, T&gt;;\n</code></pre>\n<p>and is completely generic. Typically, each such test needs at least 10 lines of code and implementations of <code>&lt;type_traits&gt;</code> are full of such code. In some cases such code blocks are defined as macros. With this solution, templates can do the job and macros are not needed.</p>\n", "OwnerUserId": "2644390", "PostTypeId": "2", "Id": "22374366", "Score": "2", "CreationDate": "2014-03-13T09:35:55.260", "LastActivityDate": "2014-03-13T09:35:55.260"}, "20291352": {"CommentCount": "3", "ViewCount": "724", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-13T09:35:55.260", "Body": "<p>This is a follow-up of <a href=\"https://stackoverflow.com/questions/20253473/variadic-template-aliases-as-template-arguments\">another question</a>. It refers to the same problem (I hope) but uses an entirely different example to illustrate it. The reason is that in the previous example only experimental GCC 4.9 failed with a compiler error. In this example, also Clang and GCC 4.8.1 fail in different ways: Clang produces an unexpected result and GCC 4.8.1 reports a different error message.</p>\n<p>Answers to the previous question say more or less that the code is valid and the problem lies with the experimental version of GCC. But this result makes me a bit more sceptical. I have been troubled for months with problems that I suspect are related (or the same), and this is the first time I have a small concrete example to illustrate.</p>\n<p>So, here is some code. First, some generic code that applies SFINAE to an arbitrary test as specified by a variadic template alias metafunction <code>F</code>:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nusing _true  = integral_constant &lt;bool, true&gt;;\nusing _false = integral_constant &lt;bool, false&gt;;\n\ntemplate &lt;typename T&gt; using pass = _true;\n\ntemplate &lt;template &lt;typename...&gt; class F&gt;\nstruct test\n{\n    template &lt;typename... A&gt; static _false           _(...);\n    template &lt;typename... A&gt; static pass &lt;F &lt;A...&gt; &gt; _(int);\n};\n\ntemplate &lt;template &lt;typename...&gt; class F, typename... A&gt;\nusing sfinae = decltype(test &lt;F&gt;::template _&lt;A...&gt;(0));\n</code></pre>\n<p>Second, a specific test, checking if a given class has defined a type named <code>type</code>:</p>\n<pre><code>template &lt;typename T&gt; using type_of  = typename T::type;\ntemplate &lt;typename T&gt; using has_type = sfinae &lt;type_of, T&gt;;\n</code></pre>\n<p>Finally, an example:</p>\n<pre><code>struct A { using type = double; };\n\nint main()\n{\n    cout &lt;&lt; has_type &lt;int&gt;() &lt;&lt; \", \";\n    cout &lt;&lt; has_type &lt;A&gt;()   &lt;&lt; endl;\n}\n</code></pre>\n<p>The expected result would be <code>0, 1</code>. Clang says <code>0, 0</code>. GCC 4.8.1 says</p>\n<pre><code>tst.cpp: In substitution of \u2018template&lt;class T&gt; using type_of = typename T::type [with T = A ...]\u2019:\ntst.cpp:15:51: required from \u2018struct test&lt;type_of&gt;\u2019\ntst.cpp:19:67: required by substitution of \u2018template&lt;template&lt;class ...&gt; class F, class ... A&gt; using sfinae = decltype (test:: _&lt;A ...&gt;(0)) [with F = type_of; A = {T}]\u2019\ntst.cpp:24:58: required from here\ntst.cpp:23:56: error: \u2018A ...\u2019 is not a class, struct, or union type\n  template &lt;typename T&gt; using type_of = typename T::type; \n                                                        ^\n</code></pre>\n<p>and GCC 4.9 says</p>\n<pre><code>tst.cpp:19:67:   required by substitution of \u2018template&lt;template&lt;class ...&gt; class F, class ... A&gt; using sfinae = decltype (test:: _&lt;A ...&gt;(0)) [with F = type_of; A = {T}]\u2019\ntst.cpp:24:58:   required from here\ntst.cpp:15:51: error: pack expansion argument for non-pack parameter \u2018T\u2019 of alias template \u2018template&lt;class T&gt; using type_of = typename T::type\u2019\n  template &lt;typename... A&gt; static pass &lt;F &lt;A...&gt; &gt; _(int);\n                                                   ^\n</code></pre>\n<p>(line numbers may vary). So, everything fails, in different ways.</p>\n<p>Now, here is a workaround. Metafunction <code>car</code> picks the first type fom a given pack, and then the test is redefined as <code>type_of2</code>, now being variadic:</p>\n<pre><code>template &lt;typename... T&gt; struct car_t;\ntemplate &lt;typename... T&gt; using  car = type_of &lt;car_t &lt;T...&gt; &gt;;\n\ntemplate &lt;typename T, typename... Tn&gt;\nstruct car_t &lt;T, Tn...&gt; { using type = T; };\n\ntemplate &lt;typename... T&gt; using type_of2  = typename car &lt;T...&gt;::type;\ntemplate &lt;typename T&gt;    using has_type2 = sfinae &lt;type_of2, T&gt;;\n\nint main()\n{\n    cout &lt;&lt; has_type2 &lt;int&gt;() &lt;&lt; \", \";\n    cout &lt;&lt; has_type2 &lt;A&gt;()   &lt;&lt; endl;\n}\n</code></pre>\n<p>Now all three compilers say <code>0, 1</code> as expected. It is interesting that for any version of GCC we have to remove <code>has_type</code> (even if we don't use it) and leave only <code>has_type2</code>; otherwise we have similar error.</p>\n<p><strong>To wrap up</strong>: I see the problem with one template expecting a variadic template-parameter of the form</p>\n<pre><code>template &lt;typename...&gt; class F\n</code></pre>\n<p>where we actually give as input a non-variadic template alias of the form</p>\n<pre><code>template &lt;typename T&gt; using alias = // ... anything including T or not\n</code></pre>\n<p>and finally invoke <code>F</code> as if it was variadic:</p>\n<pre><code>F &lt;A...&gt;\n</code></pre>\n<p>Opinions so far say this is valid, but now it seems three compilers disagree. So the question is again: <strong>is it valid</strong>?</p>\n<p>To me it matters because I have dozens of files of existing code based on the assumption that this is valid, and now I need a redesign anyway (since there are practical problems with these compilers) but the exact redesign will depend on the answer. </p>\n", "Title": "Variadic template aliases as template arguments (part 2)", "FavoriteCount": "5", "LastEditDate": "2017-05-23T12:00:52.550", "Id": "20291352", "Score": "13", "CreationDate": "2013-11-29T18:08:19.670", "Tags": "<c++><templates><variadic-templates><template-meta-programming><template-aliases>", "OwnerUserId": "2644390", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20291352_20291484_0": {"section_id": 92, "quality": 1.0, "length": 10}}, "n3337": {"so_20291352_20291484_0": {"section_id": 87, "quality": 1.0, "length": 10}}, "n4659": {"so_20291352_20291484_0": {"section_id": 95, "quality": 1.0, "length": 10}}}, "20291484": {"ParentId": "20291352", "CommentCount": "1", "Body": "<p>I think the situation is pretty well standardized; C++11 14.3.3/1 says:</p>\n<blockquote>\n<p id=\"so_20291352_20291484_0\">A <em>template-argument</em> for a template <em>template-parameter</em> shall be the name of a class template or an alias template, expressed as <em>id-expression</em>.</p>\n</blockquote>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "20291484", "Score": "0", "CreationDate": "2013-11-29T18:19:21.437", "LastActivityDate": "2013-11-29T18:19:21.437"}});