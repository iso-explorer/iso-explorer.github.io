post_cb({"4295128": {"Id": "4295128", "PostTypeId": "2", "Body": "<p>There is a good chance the memory will be correctly freed. Just because the Standard doesn't assure this doesn't mean it won't work. It's hard to see how it could fail.</p>\n", "LastActivityDate": "2010-11-28T03:11:00.707", "CommentCount": "1", "CreationDate": "2010-11-28T03:11:00.707", "ParentId": "4294066", "Score": "0", "OwnerUserId": "518287"}, "4294083": {"Id": "4294083", "PostTypeId": "2", "Body": "<p>Formally speaking, this is undefined behaviour, so you have no guarantees that the memory is freed, or indeed that your program does anything in particular. It may format your hard disk. It may not. In practice, the memory might well be freed in this case -- but you're daft if you rely on it, and you shouldn't do it. It's as simple as that.</p>\n", "LastEditorUserId": "499449", "LastActivityDate": "2010-11-27T22:01:51.070", "Score": "3", "CreationDate": "2010-11-27T21:46:03.187", "ParentId": "4294066", "CommentCount": "5", "OwnerUserId": "499449", "LastEditDate": "2010-11-27T22:01:51.070"}, "4294087": {"Id": "4294087", "PostTypeId": "2", "Body": "<p>Technically, the answer is 'unknown'.  Deleting a pointer to derived from a pointer to base that has no virtual destructor is undefined behavior.</p>\n<p>Practically speaking though, most implementations just fail to properly delete the stuff in the derived object.</p>\n", "LastActivityDate": "2010-11-27T21:46:37.183", "CommentCount": "3", "CreationDate": "2010-11-27T21:46:37.183", "ParentId": "4294066", "Score": "3", "OwnerUserId": "301883"}, "bq_ids": {"n4140": {"so_4294066_4294108_0": {"length": 27, "quality": 1.0, "section_id": 6107}, "so_4294066_4294076_0": {"length": 41, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_4294066_4294108_0": {"length": 27, "quality": 1.0, "section_id": 5873}, "so_4294066_4294076_0": {"length": 41, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_4294066_4294108_0": {"length": 27, "quality": 1.0, "section_id": 7604}, "so_4294066_4294076_0": {"length": 41, "quality": 1.0, "section_id": 7604}}}, "4294093": {"Id": "4294093", "PostTypeId": "2", "Body": "<p>In the very particular case that you describe, all of the memory used by the derived class object will be freed when you don't have a virtual destructor. (If using non-virtual destructors <em>always</em> caused derived classes to leak memory, I don't think the language would allow inheriting from classes that used them!)</p>\n<p>Remember, the DESTRUCTOR is not what frees the memory; \"delete\" frees the memory. The destructor is just a function that gets CALLED by delete.</p>\n<p>Blah blah blah extensibility blah blah cause yourself trouble in the future blah blah careful with that etc. etc. etc. You know what I mean, obviously.</p>\n", "LastActivityDate": "2010-11-27T21:47:22.563", "CommentCount": "5", "CreationDate": "2010-11-27T21:47:22.563", "ParentId": "4294066", "Score": "-4", "OwnerUserId": "21434"}, "4294076": {"Id": "4294076", "PostTypeId": "2", "Body": "<p>Edit: I Was mistaken:  Key prose from draft standard, emphasis mine: Section 5.3.5</p>\n<blockquote>\n<p id=\"so_4294066_4294076_0\">3 In the first alternative (delete\n  object), if the static type of the\n  object to be deleted is different from\n  its dynamic type, the static type\n  shall be a base class of the dynamic\n  type of the object to be deleted and\n  the static type <strong><em>shall have a virtual\n  destructor or the behavior is\n  undefined.</em></strong> In the second alternative\n  (delete array) if the dynamic type of\n  the object to be deleted differs from\n  its static type, the behavior is\n  undefined.</p>\n</blockquote>\n", "LastEditorUserId": "65696", "LastActivityDate": "2010-11-27T21:58:10.633", "Score": "0", "CreationDate": "2010-11-27T21:44:47.663", "ParentId": "4294066", "CommentCount": "4", "OwnerUserId": "65696", "LastEditDate": "2010-11-27T21:58:10.633"}, "4294108": {"Id": "4294108", "PostTypeId": "2", "Body": "<p>It's undefined behavior, so anything can happen. Quote from the standard [expr.delete]:</p>\n<blockquote>\n<p id=\"so_4294066_4294108_0\">In the first alternative (delete object), if the static type of the object\n  to be deleted is different from its\n  dynamic type, the static type shall be\n  a base class of the dynamic type of\n  the object to be deleted and the\n  static type shall have a virtual\n  destructor or the behavior is\n  undefined.</p>\n</blockquote>\n<p>Although how it works is the detail of implementation, the typical implementation may override automatically the destructor in the derived classes and implement the release of the memory there. Note that you must define the virtual destructor in the base class so the implementation can reserve an entry in the virtual table.</p>\n", "LastEditorUserId": "277176", "LastActivityDate": "2010-11-27T22:02:21.100", "Score": "4", "CreationDate": "2010-11-27T21:48:55.903", "ParentId": "4294066", "CommentCount": "0", "OwnerUserId": "277176", "LastEditDate": "2010-11-27T22:02:21.100"}, "4294066": {"ViewCount": "284", "Body": "<p>If a Base class does not have a virtual destructor (in order to avoid the vtable entry for instance) and the Derived class has only basic attributes, does it free all the memory allocated by new, when the pointer of the Base class is deleted? I know the destructor of the Derived class will not be called but I am wondering if the memory allocated by the whole object will be freed?\nI assume also that calling delete on a Derived pointer will free the whole memory space.</p>\n<p>Also, if it does not free the Derived class part of the memory, how does it work in the same case but with of a virtual destructor in the Base class, <strong>to know how much memory to free</strong>?</p>\n<p>Exemple:</p>\n<pre><code>class Base {\n  public:\n    int a;\n    int b;\n   Base() {}\n  ~Base() {}\n};\n\nclass Derived : public Base {\n  public:\n    int c;\n    int d;\n    Derived() {}\n    ~Derived() {}\n};\n\nint main() {\n  Base *p = new Derived();\n  delete p; // is memory allocated for Derived freed?\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "4294108", "Title": "Is the whole object freed with a non-virtual destructor and a Base class pointer?", "CreationDate": "2010-11-27T21:42:40.787", "Id": "4294066", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-11-28T03:11:00.707", "Score": "4", "OwnerUserId": "339986", "Tags": "<c++><destructor>", "AnswerCount": "6"}});