post_cb({"20652162": {"Id": "20652162", "PostTypeId": "2", "Body": "<p>Yes, it is specified in the C++ Standard (paragraph #1 section 5.7 Additive operators) that that </p>\n<blockquote>\n<p id=\"so_20649734_20652162_0\">the usual arithmetic conversions are performed for operands of\n  arithmetic or enumeration type.</p>\n</blockquote>\n<p>For types (for example char or unsigned char) that have rank less than int the integral promotion will be performed. For size_t (size_t has a rank that is not less than the rank of int or unsigned int) nothing will be done because there is no a second operand of arithmetic type.</p>\n", "LastActivityDate": "2013-12-18T07:36:20.567", "CommentCount": "0", "CreationDate": "2013-12-18T07:36:20.567", "ParentId": "20649734", "Score": "0", "OwnerUserId": "2877241"}, "20650459": {"Id": "20650459", "PostTypeId": "2", "Body": "<p>It does not seem required by the standard for any promotion to occur since <code>char</code> is an integral type:</p>\n<p><strong>For addition, either both operands shall have arithmetic or unscoped enumeration type,\nor one operand shall be a pointer to a completely-defined object type and the other shall have integral or unscoped enumeration type</strong></p>\n<p>It seems implementations may depend on the type of pointer additions allowed by the underlying architecture - so if the archtecture supports <code>address+BYTE</code> - all is good with <code>char</code> - if not it will likely promote to the smallest address offset size supported.</p>\n<p>The result of subtraction of pointers is defined to be of type `std::ptrdiff_t'</p>\n<p><strong>When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of the two array elements. The type of the result is an implementation-defined signed integral type; this type shall be the same type that is defined as std::ptrdiff_t in the  header</strong></p>\n", "LastEditorUserId": "2963099", "LastActivityDate": "2013-12-18T05:58:29.807", "Score": "1", "CreationDate": "2013-12-18T05:40:46.880", "ParentId": "20649734", "CommentCount": "0", "OwnerUserId": "2963099", "LastEditDate": "2013-12-18T05:58:29.807"}, "20729634": {"Id": "20729634", "PostTypeId": "2", "Body": "<p>C++11 \u00a75.7/1:  </p>\n<blockquote>\n<p id=\"so_20649734_20729634_0\">\u201cThe additive operators <code>+</code> and <code>-</code> group left-to-right. The usual arithmetic conversions are performed for operands of arithmetic or enumeration type.\u201d</p>\n</blockquote>\n<p>This apparently reduces the problem to considering the <strong>usual arithmetic conversions</strong>, defined by \u2026</p>\n<p>C++11 \u00a75/9:  </p>\n<blockquote>\n<p id=\"so_20649734_20729634_1\">\u201cMany binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result This pattern is called the <em>usual arithmetic conversions</em>,\n  which are defined as follows:</p>\n<ul>\n<li><p id=\"so_20649734_20729634_2\">If either operand is of scoped enumeration type (7.2), no conversions are performed; if the otheroperand does not have the same type, the expression is ill-formed.</p></li>\n<li><p id=\"so_20649734_20729634_3\">If either operand is of type <code>long double</code>, the other shall be converted to <code>long double</code>.</p></li>\n<li><p id=\"so_20649734_20729634_4\">Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</p></li>\n<li><p id=\"so_20649734_20729634_5\">Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.</p></li>\n<li><p id=\"so_20649734_20729634_6\">Otherwise, the integral promotions (4.5) shall be performed on both operands. Then the following rules shall be applied to the promoted operands:</p>\n<ul>\n<li><p id=\"so_20649734_20729634_7\">If both operands have the same type, no further conversion is needed.</p></li>\n<li><p id=\"so_20649734_20729634_8\">Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank shall be converted to the type of the operand with greater rank.</p></li>\n<li><p id=\"so_20649734_20729634_9\">Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type shall be converted to the type of the operand with unsigned integer type.</p></li>\n<li><p id=\"so_20649734_20729634_10\">Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall be converted to the type of the operand with signed integer type.</p></li>\n<li><p id=\"so_20649734_20729634_11\">Otherwise, both operands shall be converted to the unsigned integer type corresponding to the type of the operand with signed integer type.\u201d</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Followed mechanically, this set of rules would end up in the last bullet point (dash in the standard) and convert a pointer operand to the unsigned integer-type corresponding to something non-existing. Which is just wrong. So the wording \u201cThe usual arithmetic conversions are performed for operands of arithmetic or enumeration type\u201d can not be interpreted literally  \u2013  it's IMHO defective \u2013 but must be interpreted like \u201cThe usual arithmetic conversions are performed for invocations where both operands are of arithmetic or enumeration type\u201c</p>\n<p>So, <em>promotions</em> as such, which are invoked via the usual arithmetic conversions, don't come into play when one operand is a pointer.</p>\n<p>But a bit further down in \u00a75.7 one finds \u2026</p>\n<p>C++11 \u00a75.7/5:  </p>\n<blockquote>\n<p id=\"so_20649734_20729634_12\">\u201cWhen an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression.\u201d</p>\n</blockquote>\n<p>This defines the result entirely in terms of array indexing. For a <code>char</code> array the difference of subscripts can exceed the range of <code>ptrdiff_t</code>. A reasonable way for an implementation to arrange this, is to convert the non-pointer argument to the unsigned integral type <code>size_t</code> (effectively sign extension at the bit level), and use that value with modular arithmetic to compute the resulting pointer value.</p>\n", "LastActivityDate": "2013-12-22T12:54:50.943", "CommentCount": "0", "CreationDate": "2013-12-22T12:54:50.943", "ParentId": "20649734", "Score": "1", "OwnerUserId": "464581"}, "20651807": {"Id": "20651807", "PostTypeId": "2", "Body": "<p>I'd say normal integer promotion is applied to <code>a</code>. The C-Standard does not provide any specific rules for the conversion of the integer part of an arithmetic operation on a pointer.</p>\n<p>That is, as <code>a</code> is declared <code>char</code>, it is converted to an <code>int</code> prior to being passed to the <code>+</code> operator.</p>\n<p>If one adds a <code>size_t</code> it either stays what <code>size_t</code> is defined to be or if (for whatever reasons) it has a smaller rank then <code>int</code> it is promoted to an <code>int</code>.</p>\n", "LastEditorUserId": "694576", "LastActivityDate": "2013-12-18T07:20:40.810", "Score": "0", "CreationDate": "2013-12-18T07:14:11.780", "ParentId": "20649734", "CommentCount": "0", "OwnerUserId": "694576", "LastEditDate": "2013-12-18T07:20:40.810"}, "bq_ids": {"n4140": {"so_20649734_20729634_9": {"length": 23, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_8": {"length": 23, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5943}, "so_20649734_20729634_3": {"length": 9, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_10": {"length": 25, "quality": 1.0, "section_id": 5943}, "so_20649734_20652162_0": {"length": 8, "quality": 1.0, "section_id": 6138}, "so_20649734_20729634_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 6138}, "so_20649734_20729634_7": {"length": 8, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_5": {"length": 7, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 5943}, "so_20649734_20729634_6": {"length": 12, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_4": {"length": 7, "quality": 1.0, "section_id": 5943}, "so_20649734_20729634_12": {"length": 36, "quality": 1.0, "section_id": 6142}, "so_20649734_20729634_11": {"length": 13, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_20649734_20729634_9": {"length": 23, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_8": {"length": 23, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5714}, "so_20649734_20729634_3": {"length": 9, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_10": {"length": 25, "quality": 1.0, "section_id": 5714}, "so_20649734_20652162_0": {"length": 8, "quality": 1.0, "section_id": 5902}, "so_20649734_20729634_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5902}, "so_20649734_20729634_7": {"length": 8, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_5": {"length": 7, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 5714}, "so_20649734_20729634_6": {"length": 12, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_4": {"length": 7, "quality": 1.0, "section_id": 5714}, "so_20649734_20729634_12": {"length": 36, "quality": 1.0, "section_id": 5906}, "so_20649734_20729634_11": {"length": 13, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_20649734_20729634_4": {"length": 7, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_8": {"length": 23, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 7428}, "so_20649734_20729634_3": {"length": 9, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_10": {"length": 25, "quality": 1.0, "section_id": 7428}, "so_20649734_20652162_0": {"length": 8, "quality": 1.0, "section_id": 7635}, "so_20649734_20729634_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7635}, "so_20649734_20729634_7": {"length": 8, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_5": {"length": 7, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7428}, "so_20649734_20729634_6": {"length": 12, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_9": {"length": 23, "quality": 1.0, "section_id": 7428}, "so_20649734_20729634_11": {"length": 13, "quality": 1.0, "section_id": 7428}}}, "20649734": {"ViewCount": "708", "Body": "<p>In the expression <code>p + a</code> where <code>p</code> is a pointer type and <code>a</code> is an integer, will integer promotion rules apply? For example, if <code>a</code> is a <code>char</code>, on a 64-bit machine it will surely be extended to 64 bit before being added to the pointer value (in the compiled assembly), but is it specified by the standards? What will it be promoted to? <code>int</code>, <code>intptr_t</code> or <code>ptrdiff_t</code>? What will <code>unsigned char</code> or <code>size_t</code> be converted to?</p>\n", "Title": "Pointer arithmetic and integral promotion", "CreationDate": "2013-12-18T04:38:47.590", "LastActivityDate": "2013-12-22T12:54:50.943", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "Id": "20649734", "Score": "5", "OwnerUserId": "832878", "Tags": "<c++><c><pointers><standards>", "AnswerCount": "4"}});