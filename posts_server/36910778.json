post_cb({"36910778": {"CommentCount": "5", "ViewCount": "119", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2016-04-28T09:38:11.197", "LastActivityDate": "2016-04-28T10:12:11.270", "Title": "When are user-defined conversion sequences not considered for selecting viable constructors in C++?", "AcceptedAnswerId": "36911331", "LastEditDate": "2016-04-28T09:51:01.303", "Id": "36910778", "Score": "2", "Body": "<p>I saw the following words in the C++ standard draft N4582:</p>\n<blockquote>\n<p id=\"so_36910778_36910778_0\">[over.best.ics/4] However, if the target is</p>\n<p id=\"so_36910778_36910778_1\">(4.1) the first parameter of a constructor or</p>\n<p id=\"so_36910778_36910778_2\">(4.2) the implicit object parameter of a user-defined conversion function  </p>\n<p id=\"so_36910778_36910778_3\">and the constructor or user-defined conversion function is a candidate by</p>\n<p id=\"so_36910778_36910778_4\">(4.3) 13.3.1.3, <strong>when the argument is the temporary in the second step of a class copy-initialization</strong>, or</p>\n<p id=\"so_36910778_36910778_5\">(4.4) 13.3.1.4, 13.3.1.5, or 13.3.1.6 (in all cases),</p>\n<p id=\"so_36910778_36910778_6\">user-defined conversion sequences are not considered.</p>\n</blockquote>\n<p>I am confused about the bold part, and don't know how to understand it. I write the following program:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;    \nstruct A {\n    A(int) {}\n    operator int() {cout &lt;&lt; \"user-defined conversion\" &lt;&lt; endl; return 0;}\n    A(A&amp;) {} //prevent default copy\n};\nint main()\n{\n    A a = A(0);\n}\n</code></pre>\n<p>It works well in g++ 5.3.0, and output \"user-defined conversion\", which means a user-defined conversion occurs. Certainly, it can be interpreted as that the temporary A(0) is not a consequence of <strong>copy-initialization</strong>. Next I change the program to:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;    \nstruct A {\n    A(int) {}\n    operator int() {cout &lt;&lt; \"user-defined conversion\" &lt;&lt; endl; return 0;}\n    A(A&amp;) {} //prevent default copy\n};\nA foo() {return A(0);}\nint main()\n{\n    A a = foo();\n}\n</code></pre>\n<p>Now the value of foo() is a temporary copy-initialized from A(0), but the program still works. Why would this happen? </p>\n", "Tags": "<c++><standards><implicit-conversion>", "OwnerUserId": "5376789", "AnswerCount": "2"}, "36911331": {"ParentId": "36910778", "CommentCount": "3", "Body": "<p>You can go read <a href=\"http://eel.is/c++draft/dcl.init#17\" rel=\"nofollow\">[dcl.init]/17</a> for the actual standardese. The \"second step\" here is referring to copy-initializing a variable of class type <code>A</code> from something <code>b</code> of an unrelated type. In such a case, copy-initialization happens in two steps:</p>\n<ul>\n<li>Step 1: you implicitly convert <code>b</code> to <code>A</code>. If you call a converting constructor for this, it creates a temporary <code>A</code>.</li>\n<li>Step 2: you then initialize the <code>A</code> variable from the result of the conversion. (In sane classes, this is typically elided.)</li>\n</ul>\n<p>What that quote is saying is that you don't do user-defined conversions in this second step.</p>\n<p>For example, with your <code>A</code>,  <code>A a = 0;</code>. In the first step, you make an <code>A</code> temporary from <code>0</code>. In the second step, you try to initialize <code>a</code> with that temporary - without using user-defined conversions. That fails, because neither <code>A</code> constructor is viable.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "36911331", "Score": "4", "CreationDate": "2016-04-28T10:02:57.357", "LastActivityDate": "2016-04-28T10:02:57.357"}, "36911538": {"ParentId": "36910778", "CommentCount": "0", "Body": "<p>There is only 2 ctors, one that take a reference to an existing object (no temporary) and one that takes an int.</p>\n<p>Your code produces (with additional messages):</p>\n<pre><code>int ctor\nuser-defined conversion\nint ctor\nuser-defined conversion\nint ctor\n</code></pre>\n<p>The first is the construction inside <code>foo</code>.</p>\n<p>The second is due to the fact that the returned value can't be constructed by copy as you prevented it, so the compiler convert the value constructed to an <code>int</code>.</p>\n<p>The third is because it uses the ctor that takes an <code>int</code> to build the returned value.</p>\n<p>The fourth is (as the second) due to the fact that the returned value can't be used to construct <code>a</code>, so it convert it to an <code>int</code>.</p>\n<p>The fifth is because it then uses the ctor that takes an <code>int</code>to build <code>a</code>.</p>\n", "OwnerUserId": "719263", "PostTypeId": "2", "Id": "36911538", "Score": "0", "CreationDate": "2016-04-28T10:12:11.270", "LastActivityDate": "2016-04-28T10:12:11.270"}, "bq_ids": {"n4140": {"so_36910778_36910778_2": {"section_id": 609, "quality": 1.0, "length": 6}, "so_36910778_36910778_4": {"section_id": 609, "quality": 0.875, "length": 7}, "so_36910778_36910778_3": {"section_id": 609, "quality": 1.0, "length": 5}}, "n3337": {"so_36910778_36910778_2": {"section_id": 629, "quality": 1.0, "length": 6}, "so_36910778_36910778_4": {"section_id": 599, "quality": 0.875, "length": 7}, "so_36910778_36910778_3": {"section_id": 599, "quality": 1.0, "length": 5}}, "n4659": {"so_36910778_36910778_2": {"section_id": 635, "quality": 1.0, "length": 6}, "so_36910778_36910778_4": {"section_id": 635, "quality": 0.875, "length": 7}, "so_36910778_36910778_3": {"section_id": 586, "quality": 1.0, "length": 5}}}});