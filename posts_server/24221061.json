post_cb({"24221355": {"ParentId": "24221061", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_24221061_24221355_0\"><sup><strong>Note</strong>: All standard references in this post are taken from the C++ Standard Draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">n3337</a>.</sup></p>\n</blockquote>\n<hr>\n<h3>Introduction</h3>\n<p>The standard states that a <em>capture</em> must be <code>&amp;</code>, <code>=</code>, <code>this</code>, an <em>identifier</em>, or an <em>identifier</em> preceeded by <code>&amp;</code>.</p>\n<blockquote>\n<p id=\"so_24221061_24221355_1\"><code>5.1.2</code> <strong>Lambda expressions</strong> <code>[expr.prim.lambda]</code>\n</p>\n<blockquote id=\"so_24221061_24221355_2\">\n<pre><code>capture-list:\n  capture ..._opt\n  capture-list , capture ..._opt\n\ncapture:\n  identifier\n  &amp; identifier\n  this\n</code></pre>\n</blockquote>\n</blockquote>\n<p>Since <code>parentItem.displayName</code> is not an identifier, but a <em>\"class member access expression\"</em>. the compiler is correct when rejecting your snippet.</p>\n<blockquote>\n<p id=\"so_24221061_24221355_3\"><code>5.2.5p1</code> <strong>Class member access</strong> <code>[expr.ref]</code></p>\n<blockquote>\n<p id=\"so_24221061_24221355_5\">A postfix expression followed by a dot <code>.</code> or an arrow <code>-&gt;</code>, optionally follow by the keyword <code>template</code> (14.2), and then followed by an id-expression, is a postfix expression. The postfix expression before the dot or arrow is evaluated;<sup>66</sup> the result of that evaluation, together with the id-expression, determines the result of the entire postfix expression.</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3>If only there was a way to initialize captures with <em>expressions</em>...</h3>\n<p>In <em>C++14</em> you <strong>will</strong> be able to use an <em>init-capture</em> to circumvent the issue at hand, looking as the snippet below. It will create a capture with the name <em>display_name</em>, initialized with the value of <em>parentItem.displayName</em>. </p>\n<pre><code>[display_name = parentItem.displayName](){ ... };\n</code></pre>\n<hr>\n<h3>What about <em>C++11</em>?</h3>\n<p>Sadly such a feature is not available in <em>C++11</em>. The solution to the problem is therefore to make a local reference to the the data-member, and then capture that reference when creating the lambda.</p>\n<pre><code>auto&amp; lmb_display_name = parentItem.displayName;\n\n[lmb_display_name](){ ... }; // the lambda will have a copy of `parentItem.displayName`\n</code></pre>\n<p><br/>\n<sup><strong>Note</strong>: Your original post seems to imply that the name of a <em>reference</em> <em>R</em> in a lambda's capture-list would make the lambda contain a reference to that which <em>R</em> refers to, something which isn't true, as can be seen by <a href=\"http://coliru.stacked-crooked.com/a/4e2c3304c1f923e3\">this snippet</a>.</sup></p>\n</hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-14T15:34:39.300", "Id": "24221355", "Score": "9", "CreationDate": "2014-06-14T15:17:19.850", "LastActivityDate": "2014-06-14T15:34:39.300"}, "24221061": {"CommentCount": "1", "CreationDate": "2014-06-14T14:45:31.890", "PostTypeId": "1", "AcceptedAnswerId": "24221355", "LastEditorUserId": "634821", "LastActivityDate": "2014-06-14T15:50:53.490", "LastEditDate": "2014-06-14T15:50:53.490", "ViewCount": "739", "FavoriteCount": "1", "Title": "Lambda capture list: capturing object's member field by value not possible without capturing the whole object?", "Id": "24221061", "Score": "5", "Body": "<p>The following code</p>\n<pre><code>void CMainWindow::someMethod(const CLocationsCollection&amp; parentItem)\n{\n    auto f = [this, parentItem.displayName](){};\n}\n</code></pre>\n<p>gives me an error:</p>\n<blockquote>\n<p id=\"so_24221061_24221061_0\">error C2143: syntax error : missing ']' before '.'</p>\n</blockquote>\n<p>If I wanted to catch <code>parentItem.displayName</code> by ref, I'd make a non-dependent alias identifier for it:</p>\n<pre><code>const QString&amp; name = parentItem.displayName;\nauto f = [this, &amp;name](){}; // Or should it be [this, name] ?\n</code></pre>\n<p>But I need to capture it by value, and I don't want to capture the whole <code>parentItem</code> because it's heavy. Any solution?</p>\n<p>P. S. Names in the capture list must be identifiers. Isn't <code>parentItem.displayName</code> (as a whole) an identifier? Why can't it be parsed properly by the compiler?</p>\n", "Tags": "<c++><c++11><lambda><language-lawyer>", "OwnerUserId": "634821", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24221061_24221355_4": {"section_id": 6004, "quality": 0.8709677419354839, "length": 27}, "so_24221061_24221355_2": {"section_id": 5960, "quality": 0.6666666666666666, "length": 6}, "so_24221061_24221355_5": {"section_id": 6004, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_24221061_24221355_4": {"section_id": 5772, "quality": 0.8709677419354839, "length": 27}, "so_24221061_24221355_2": {"section_id": 5729, "quality": 0.6666666666666666, "length": 6}, "so_24221061_24221355_5": {"section_id": 5772, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_24221061_24221355_4": {"section_id": 7503, "quality": 0.8709677419354839, "length": 27}, "so_24221061_24221355_5": {"section_id": 7503, "quality": 0.8709677419354839, "length": 27}}}});