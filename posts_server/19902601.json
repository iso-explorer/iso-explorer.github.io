post_cb({"bq_ids": {"n4140": {"so_19902601_19906025_0": {"length": 16, "quality": 1.0, "section_id": 142}}, "n3337": {"so_19902601_19906025_0": {"length": 16, "quality": 1.0, "section_id": 136}}}, "19902601": {"ViewCount": "387", "Body": "<p>I have problem with implementing recursive template (function in template struct), which will be terminated by std::tuple_size.</p>\n<p>Here is fragment of code (I simplified code, to emphasize problem):</p>\n<pre><code>template&lt;int index, typename ...T_arguments&gt;\n    struct Helper\n    {\n        static void func (size_t&amp;                           return_size,\n                          const std::tuple&lt;T_arguments...&gt;&amp; arguments)\n        {\n            const auto&amp; argument (std::get&lt;index&gt; (arguments));\n\n            return_size += ::value_size (argument);\n\n            ::Helper&lt;index + 1, T_arguments...&gt;::func (return_size, arguments);\n        }\n\n// ...\n\ntemplate&lt;typename... T_arguments&gt;\n    struct Helper&lt;std::tuple_size&lt;T_arguments...&gt;::value, T_arguments...&gt;\n    {\n        static void func (size_t&amp;                           return_size,\n                          const std::tuple&lt;T_arguments...&gt;&amp; arguments)\n        {\n            const auto&amp; argument (std::get&lt;std::tuple_size&lt;T_arguments...&gt;::value&gt; (arguments));\n\n            return_size += ::value_size (argument);\n        }\n</code></pre>\n<p>Initial template call looks like this:</p>\n<pre><code>Helper&lt;0, T_arguments...&gt;::func (return_size, arguments);\n</code></pre>\n<p>GCC fails with error:</p>\n<blockquote>\n<p id=\"so_19902601_19902601_0\">error: template argument \u2018std::tuple_size::value\u2019\n  involves template parameter(s)\n               struct Helper::value, T_arguments...&gt;</p>\n</blockquote>\n<p><code>std::tuple_size</code> is claimed to be known at compile time, so why I cannot use it template specialization?</p>\n", "Title": "Recursive variadic template terminated by std::tuple_size in C++11", "CreationDate": "2013-11-11T09:12:20.693", "LastActivityDate": "2013-11-12T10:37:30.727", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-11-12T10:37:30.727", "LastEditorUserId": "46642", "Id": "19902601", "Score": "2", "OwnerUserId": "325519", "Tags": "<c++><templates><c++11><recursion>", "AnswerCount": "2"}, "19906931": {"PostTypeId": "2", "Body": "<p>Use index_sequence and range-based-for.</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstddef&gt;\n\n#include &lt;tuple&gt;\n\nnamespace mpl\n{\n    template&lt; std::size_t ... I&gt;\n    struct index_sequence\n    {\n    };\n\n    template&lt; std::size_t s, typename I1, typename I2&gt;\n    struct concate;\n\n    template&lt; std::size_t s, std::size_t ...I, std::size_t ...J&gt;\n    struct concate&lt;s, index_sequence&lt;I...&gt;, index_sequence&lt;J...&gt; &gt;\n    {\n        typedef index_sequence&lt;I... ,( J + s)... &gt; type;\n    };\n\n\n    template&lt; std::size_t N&gt;\n    struct make_index_sequence\n    {\n        typedef typename concate&lt; N/2,\n           typename make_index_sequence&lt; N/2&gt;::type,\n           typename make_index_sequence&lt; N - N/2&gt;::type\n        &gt;::type type;\n    };\n\n    template&lt;&gt;struct make_index_sequence&lt;0&gt;\n    {\n        typedef index_sequence&lt;&gt; type;\n    };\n\n    template&lt;&gt; struct make_index_sequence&lt;1&gt;\n    {\n        typedef index_sequence&lt;0&gt; type;\n    };\n\n    template&lt; typename ...T&gt;\n    struct index_sequence_for\n    {\n        typedef typename make_index_sequence&lt; sizeof...(T) &gt; ::type type;\n    };\n} // mpl\n\n\ntemplate&lt; typename T &gt;\nstd::size_t value_size( T ){ return sizeof(T); }// only for illustration\n\ntemplate&lt; typename ...Tp, std::size_t ...i&gt;\nstd::size_t total_value_size_impl( const std::tuple&lt;Tp...&gt; &amp; t, mpl::index_sequence&lt;i...&gt; )\n{\n    std::size_t result=0;\n\n    for(auto x: { value_size( std::get&lt;i&gt;(t) ) ... } )\n    {\n          result += x;\n    }\n\n    return result;\n\n}\n\ntemplate&lt; typename ...Tp&gt;\nstd::size_t total_value_size( const std::tuple&lt;Tp...&gt; &amp; t)\n{\n    typedef typename mpl::index_sequence_for&lt;Tp...&gt; :: type indexes;\n\n    return total_value_size_impl( t, indexes{} );\n}\n\n#include &lt;cstdio&gt;\n\nint main()\n{\n    typedef std::tuple&lt;int, char, double&gt; types;\n\n    std::size_t result = total_value_size(types{});\n\n    printf(\"%d\\n\", result);\n}\n</code></pre>\n", "LastActivityDate": "2013-11-11T12:55:43.020", "Id": "19906931", "CommentCount": "0", "CreationDate": "2013-11-11T12:55:43.020", "ParentId": "19902601", "Score": "0", "OwnerUserId": "2614655"}, "19906025": {"PostTypeId": "2", "Body": "<p>Actually what you're doing is forbidden by section \u00a714.5.4/9 which says,</p>\n<blockquote>\n<p id=\"so_19902601_19906025_0\">A partially specialized <strong>non-type argument expression shall not involve a template parameter of the partial specialization</strong> except when the argument expression is a simple identifier.</p>\n</blockquote>\n<p>Following may help:</p>\n<pre><code>template&lt;std::size_t I = 0, typename... Tp&gt;\ninline typename std::enable_if&lt;I == sizeof...(Tp), void&gt;::type\n  total_value_size(size_t&amp; return_size, const std::tuple&lt;Tp...&gt;&amp; t)\n  { }\n\ntemplate&lt;std::size_t I = 0, typename... Tp&gt;\ninline typename std::enable_if&lt;I &lt; sizeof...(Tp), void&gt;::type\n  total_value_size(size_t&amp; return_size, const std::tuple&lt;Tp...&gt;&amp; t)\n  {\n        const auto&amp; argument (std::get&lt;I&gt; (t));\n\n        return_size += ::value_size(argument);\n        total_value_size&lt;I + 1, Tp...&gt;(return_size, t);\n  }\n</code></pre>\n", "LastActivityDate": "2013-11-11T12:09:10.100", "Id": "19906025", "CommentCount": "0", "CreationDate": "2013-11-11T12:09:10.100", "ParentId": "19902601", "Score": "1", "OwnerUserId": "2684539"}});