post_cb({"42055583": {"CommentCount": "0", "ViewCount": "281", "PostTypeId": "1", "LastEditorUserId": "3024983", "CreationDate": "2017-02-05T18:21:05.463", "LastActivityDate": "2017-02-07T18:34:25.517", "Title": "Member rvalue references and object lifetime", "AcceptedAnswerId": "42097383", "LastEditDate": "2017-02-05T18:26:54.667", "Id": "42055583", "Score": "2", "Body": "<p>It's been a while since I last looked at temporary lifetime rules and I don't remember how member rvalue references affect\nlifetime.</p>\n<p>For example take the two following pieces of code:</p>\n<pre><code>int main() \n{\n    std::get&lt;0&gt;(std::forward_as_tuple(\n        [](int v){ std::cout &lt;&lt; v &lt;&lt; std::endl; }\n    ))(6);\n    return 0;\n}\n</code></pre>\n<p>,</p>\n<pre><code>int main() \n{\n    auto t = std::forward_as_tuple(\n        [](int v){ std::cout &lt;&lt; v &lt;&lt; std::endl; }\n    );\n    std::get&lt;0&gt;(t)(6);\n    return 0;\n}\n</code></pre>\n<p>If member rvalue references don't affect lifetime rules, I would expect the first example to be well-behaved while the second example\nto be undefined (since the full-expression containing the lambda object\nends at the first semicolon).</p>\n<p>How do C++11, C++14 and C++17 treat the given examples? Are there differences between the three?</p>\n", "Tags": "<c++><c++11><c++14><language-lawyer><c++1z>", "OwnerUserId": "3024983", "AnswerCount": "3"}, "42055827": {"ParentId": "42055583", "CommentCount": "3", "CreationDate": "2017-02-05T18:45:07.907", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "42055827", "Score": "4", "Body": "<p>The rules of temporary lifetime extension haven't changed in any version of C++ since 98. We may have new ways to manifest temporaries, but once they exist, their lifetimes are well understood.</p>\n<p>It should be noted that your example doesn't really apply to member references of any kind. You're calling a function with a temporary, and the parameter is a forwarding reference. The temporary in question is therefore bound to the <em>function parameter</em> reference, not to a member reference. The lifetime of that temporary will end after the expression that invoked that function, as it would with any temporary passed to a reference parameter.</p>\n<p>The fact that this function (<code>forward_as_tuple</code>) will eventually store that reference in a <code>tuple</code> is irrelevant. What you do with a reference cannot alter its lifetime.</p>\n<p>Again, that's C++98, and none of the later versions changed that.</p>\n", "LastActivityDate": "2017-02-05T18:45:07.907"}, "bq_ids": {"n4140": {"so_42055583_42097383_1": {"section_id": 382, "quality": 0.8571428571428571, "length": 30}, "so_42055583_42097383_0": {"section_id": 381, "quality": 0.9, "length": 18}, "so_42055583_42097383_2": {"section_id": 378, "quality": 1.0, "length": 9}}, "n3337": {"so_42055583_42097383_1": {"section_id": 373, "quality": 0.8571428571428571, "length": 30}, "so_42055583_42097383_0": {"section_id": 372, "quality": 0.9, "length": 18}, "so_42055583_42097383_2": {"section_id": 369, "quality": 1.0, "length": 9}}, "n4659": {"so_42055583_42097383_3": {"section_id": 392, "quality": 1.0, "length": 8}, "so_42055583_42097383_1": {"section_id": 397, "quality": 0.8857142857142857, "length": 31}, "so_42055583_42097383_0": {"section_id": 396, "quality": 0.9, "length": 18}}}, "42097383": {"ParentId": "42055583", "CommentCount": "1", "CreationDate": "2017-02-07T18:34:25.517", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42097383", "Score": "3", "Body": "<p>Because this is a <a class=\"post-tag\" href=\"/questions/tagged/language-lawyer\" rel=\"tag\" title=\"show questions tagged 'language-lawyer'\">language-lawyer</a> question. The rules for lifetime extension are in [class.temporary]. The wording from C++11 to C++14 to C++17 didn't change in a way that is relevant to this particular question. The rule is:</p>\n<blockquote>\n<p id=\"so_42055583_42097383_0\">There are [two/three<sup>\u2020</sup>] contexts in which temporaries are destroyed at a different point than the end of the full-expression. The first context is when a default constructor is called to initialize an element of an array [...]<sup>\u2020</sup></p>\n<p id=\"so_42055583_42097383_1\">The [second/third<sup>\u2020</sup>] context is when a reference is bound to a temporary. The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference except:<br>\n  \u2014 A temporary object bound to a reference parameter in a function call (5.2.2) persists until the completion\n  of the full-expression containing the call.</br></p>\n</blockquote>\n<p>This expression:</p>\n<pre><code>std::forward_as_tuple([](int v){ std::cout &lt;&lt; v &lt;&lt; std::endl; })\n</code></pre>\n<p>involves binding a reference (the parameter in <a href=\"http://en.cppreference.com/w/cpp/utility/tuple/forward_as_tuple\" rel=\"nofollow noreferrer\"><code>forward_as_tuple</code></a>) to a prvalue (the lambda-expression), which is explicitly mentioned in C++11/14 as a context which creates a temporary:</p>\n<blockquote>\n<p id=\"so_42055583_42097383_2\">Temporaries of class type are created in various contexts: binding a reference to a prvalue, [...]</p>\n</blockquote>\n<p>which in C++17 is worded as:</p>\n<blockquote>\n<p id=\"so_42055583_42097383_3\">Temporary objects are created<br>\n  (1.1) \u2014 when a prvalue is materialized so that it can be used as a glvalue (4.4),</br></p>\n</blockquote>\n<p>Either way, we have a temporary, it's bound to a reference in a function call, so the temporary object persists until the completion of the full-epxression containing the call. </p>\n<p>So this is okay:</p>\n<pre><code>std::get&lt;0&gt;(std::forward_as_tuple(\n    [](int v){ std::cout &lt;&lt; v &lt;&lt; std::endl; }\n))(6);\n</code></pre>\n<p>But this calls through a dangling reference:</p>\n<pre><code>auto t = std::forward_as_tuple(\n    [](int v){ std::cout &lt;&lt; v &lt;&lt; std::endl; }\n);\nstd::get&lt;0&gt;(t)(6);\n</code></pre>\n<p>because the lifetime of the temporary function object ended at the end of the statement initializing <code>t</code>. </p>\n<p>Note that this has nothing to do with member rvalue references. If we had something like:</p>\n<pre><code>struct Wrapper {\n    X&amp;&amp; x;\n};\n\nWrapper w{X()};\n</code></pre>\n<p>then the lifetime of the temporary <code>X</code> persists through the lifetime of <code>w</code>, and <code>w.x</code> isn't a dangling reference. But that's because there's no function call. </p>\n<hr/>\n<p><sup>\u2020</sup>C++17 introduced a 3rd context which involves copying an array, which is unrelated here.</p>\n", "LastActivityDate": "2017-02-07T18:34:25.517"}, "42068714": {"ParentId": "42055583", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-02-06T13:14:48.603", "Score": "4", "LastEditorUserId": "1774667", "LastEditDate": "2017-02-06T19:47:03.457", "Id": "42068714", "OwnerUserId": "1774667", "Body": "<p>Lifetime extension applies when you directly bind a temporary to a reference anywhere but within a constructor initializer list.  (Note: aggregate initialization isn't a constructor)</p>\n<p><code>std::forward_as_tuple</code> is a function.  Any temporary passed to it cannot be lifetime extended beyond the current line.</p>\n<p>Temporaries by default last until the end of the current line, basically.  (What exactly that spot is isn't actually the end of the current line).  In your two cases, it is the end of the current line (the <code>;</code>) where the temporary ends its lifetime.  This is long enough for the first case; in the second case, the temporary is dead and your code exhibits undefined behavior.</p>\n<p>At the same time:</p>\n<pre><code>struct foo {\n  int&amp;&amp; x;\n};\n\nint main() {\n  foo f{3};\n  std::cout &lt;&lt; f.x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>is perfectly well defined.  No constructor, we bound a temporary to an (rvalue) reference, thus lifetime is extended.</p>\n<p>Add this:</p>\n<pre><code>struct foo {\n  int&amp;&amp; x;\n  foo(int&amp;&amp; y):x(y) {}\n};\n</code></pre>\n<p>or</p>\n<pre><code>struct foo {\n  int&amp;&amp; x;\n  foo(int y):x((int)y) {}\n};\n</code></pre>\n<p>and it is now UB.</p>\n<p>The first one because we bound the temporary to an rvalue reference when invoking the ctor.  The inside of the constructor is irrelevant, as there is no temporary being bound directly there.  Then the argument to the function and the temporary both go out of scope in <code>main</code>.</p>\n<p>The second because the rule that binding the temporary <code>(int)y</code>0 to <code>int&amp;&amp;x</code> in a constructor initializer list does not extend lifetime the same way as it does elsewhere.</p>\n", "LastActivityDate": "2017-02-06T19:47:03.457"}});