post_cb({"26726920": {"CommentCount": "5", "ViewCount": "157", "CreationDate": "2014-11-04T02:46:29.217", "LastActivityDate": "2014-11-04T03:26:52.790", "Title": "how can static variables be directly used in lambda's body even the invoking beyond the scope of the static variables", "PostTypeId": "1", "Id": "26726920", "Score": "0", "Body": "<p>i'm getting confused when reading the capture rule of local static variables for lambda, see below codes:</p>\n<pre><code>std::function&lt;bool(int)&gt; returnLambda()\n{\n    static int s_b = 1;\n\n    return [](int a){return a+s_b ;} ;\n}\n\nint main()\n{\n    int i;\n\n    i = returnLambda()(2);\n\n    return i;\n}\n</code></pre>\n<p>in the returnLambda function, when lambda expression is envaluated, one function object is constructed and returned.Then there is one copy at the invoking place, and operator() is invoked at the invoking place, so does the local static variable. here the question is, why the local static variable inside the returnLambda function can still alive even outside the returnLambda function?\ngenerally you can not refer to one local static variables outsie it's sope.</p>\n", "Tags": "<c++><lambda>", "OwnerUserId": "2745000", "AnswerCount": "2"}, "26727129": {"ParentId": "26726920", "CommentCount": "4", "CreationDate": "2014-11-04T03:11:31.583", "OwnerUserId": "2023844", "PostTypeId": "2", "Id": "26727129", "Score": "0", "Body": "<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/mkwJB.png\"/></p>\n<p>lambda lives inside returnLambda, is this what you're asking? &gt;&lt;</p>\n", "LastActivityDate": "2014-11-04T03:11:31.583"}, "26727161": {"ParentId": "26726920", "LastEditDate": "2014-11-04T03:26:52.790", "CommentCount": "5", "CreationDate": "2014-11-04T03:14:44.740", "Score": "3", "LastEditorUserId": "103167", "PostTypeId": "2", "Id": "26727161", "OwnerUserId": "103167", "Body": "<p>The rules for lambdas state that you can't use any captured entity beyond the lifetime of said entity.</p>\n<p>The lifetime of an object with static lifetime is until the end of <code>main()</code> (or call to <code>exit()</code>).  So there's no problem using it after returning the lambda.  Only usage in the destructors of other objects with static lifetime (e.g. globals) could be a problem.</p>\n<p>In fact, this variable isn't even captured by the lambda.  No need, just like there would be no need to capture a global variable.  It works because identifier lookup within the lambda finds an object with static lifetime in an enclosing scope, so it gets used.  Because the variable does not have automatic storage duration, the rule for implicit capture isn't triggered.</p>\n<p>This is the rule, from 5.1.2:</p>\n<blockquote>\n<p id=\"so_26726920_26727161_0\">A lambda-expression with an associated <em>capture-default</em> that does not explicitly capture <code>this</code> or a variable with automatic storage duration (this excludes any <em>id-expression</em> that has been found to refer to an <em>init-capture</em>'s associated non-static data member), is said to <em>implicitly capture</em> the entity (i.e., <code>this</code> or a variable) if the <em>compound-statement</em>:</p>\n<ul>\n<li>odr-uses (3.2) the entity, or</li>\n<li>names the entity in a potentially-evaluated expression (3.2) where the enclosing full-expression depends\n  on a generic lambda parameter declared within the reaching scope of the <em>lambda-expression</em>.</li>\n</ul>\n</blockquote>\n<p>The whole reason for the capture machinery is so that the lambda can locate variables it uses, if those variables have a time-varying location.  Static variables (and globals, and static class members, and functions, and whatever else isn't an automatic local variable or a non-static data member of <code>this</code>) don't move around, so sticking their location in the lambda object isn't necessary.</p>\n<p>In short: You absolutely can continue using static locals outside their scope.  Many standard library functions work this way, for example <code>asctime</code>.  Scope determines whether the name is recognized; for objects with static or dynamic lifetime, scope has no effect on lifetime.</p>\n", "LastActivityDate": "2014-11-04T03:26:52.790"}, "bq_ids": {"n4140": {"so_26726920_26727161_0": {"section_id": 5971, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_26726920_26727161_0": {"section_id": 7470, "quality": 0.9230769230769231, "length": 24}}}});