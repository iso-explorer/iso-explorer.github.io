post_cb({"22273064": {"ParentId": "22272920", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-03-08T18:08:23.937", "Score": "2", "LastEditorUserId": "1181561", "LastEditDate": "2014-09-19T14:00:13.543", "Id": "22273064", "OwnerUserId": "1181561", "Body": "<p>Pointer arithmetic allows you to write code that processes an array. Consider summing an array of ints:</p>\n<pre><code>int values[] = { 0, 1, 2, 3};\nint* current = values;\nint* end = values + 4;\nint sum = 0;\nwhile (current != end)\n{\n    sum += *current;\n    ++current;\n}\n</code></pre>\n<p>Of course, there are easier ways to accomplish this than using raw pointers, so don't ever write code as complicated as this to do something that is simpler to do another way. As other answers have pointed out, array indexing is translated into pointer arithmetic by the compiler: <code>values[2]</code> is equivalent to saying <code>*(values + 2)</code> so in this case looping over the array with the much simpler code is what you should do.</p>\n<pre><code>for (int i = 0; i &lt; 4; ++i)\n{\n    sum += values[i];\n}\n</code></pre>\n<p>There are more advanced reasons to use pointer arithmetic because it can actually help to simplify implementation; for example I've used it before in an assignment along with reinterpret_cast to create a free list memory allocator.</p>\n", "LastActivityDate": "2014-09-19T14:00:13.543"}, "22273025": {"ParentId": "22272920", "CommentCount": "1", "CreationDate": "2014-03-08T18:04:05.433", "OwnerUserId": "149392", "PostTypeId": "2", "Id": "22273025", "Score": "1", "Body": "<p>Let's say you have an array of integers and that on your platform an integer consists of 4 bytes. An int pointer can now legally point to the first, fifth, ninth etc. byte of that array, but it may not legally point to say the second or third byte of the array (because that wouldn't be the start of an int object).</p>\n<p>So since pointer arithmetic uses the size of the given type, you can only get legal pointer by performing pointer arithmetic on the array (except if your index is out of bounds) without casting to a different pointer type. Otherwise it would be much easier to accidentally create illegal pointers through arithmetic.</p>\n<p>It's also more convenient since, if C didn't automatically do this, the programmer would have to manually multiply by the type's size anyway in 99% of the use cases.</p>\n", "LastActivityDate": "2014-03-08T18:04:05.433"}, "22273031": {"ParentId": "22272920", "CommentCount": "0", "CreationDate": "2014-03-08T18:05:02.373", "OwnerUserId": "3177124", "PostTypeId": "2", "Id": "22273031", "Score": "2", "Body": "<p>You have some problems in your understanding here which show up in the comments</p>\n<pre><code>int main() {\n\n    // This one is fine\n    long long * x = new long long [10]; // array of long long\n\n    // This does not do what you think it does. It casts a pointer to a\n    // long then assigns it to a. x is the address of the first element,\n    // but you are putting it into a long. Did you mean:\n    //     long * a = x;\n    long a = (long) x;  // address of first element\n\n    // Same mistake as above, save that b is now the address of the\n    // second element, cast to a long\n    long b = (long) (x+1); //address of second element\n\n    // Now, 'c' will be the difference between the two pointers. As under\n    // pointer arithmetic, x+1 will move on by one long, the pointer has\n    // moved on by sizeof(long) bytes, i.e. either 4 or 8 depending on\n    // your platform\n    long c = b - a ;  // first difference\n\n    // this is doing long d = long (1)\n    long d = (long) ((x+1) - x);  // second difference\n\n    std::cout &lt;&lt; c &lt;&lt; std::endl ;\n\n    std::cout &lt;&lt; d &lt;&lt; std::endl ;\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-03-08T18:05:02.373"}, "22273038": {"ParentId": "22272920", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-03-08T18:05:47.870", "Score": "2", "LastEditorUserId": "2037422", "LastEditDate": "2014-03-08T18:13:29.023", "Id": "22273038", "OwnerUserId": "2037422", "Body": "<p>You can use it like this:</p>\n<pre><code>struct Some {\n  /* some fields */\n};\n\nSome* vals = Some[100];\nfor (Some* ptr = vals; ptr != vals + 100; ++ptr) {\n  cout &lt;&lt; *ptr &lt;&lt; endl;\n}\n/* or */\nfor_each(vals, vals + 100, [](const Some&amp; arg) { cout &lt;&lt; *ptr &lt;&lt; endl; });\n</code></pre>\n<p>You don't have to worry about the size of Some structure.</p>\n", "LastActivityDate": "2014-03-08T18:13:29.023"}, "22272920": {"CommentCount": "5", "AcceptedAnswerId": "22273064", "PostTypeId": "1", "LastEditorUserId": "1968", "CreationDate": "2014-03-08T17:55:49.973", "LastActivityDate": "2014-09-19T14:00:13.543", "LastEditDate": "2014-03-08T18:03:26.150", "ViewCount": "196", "FavoriteCount": "0", "Title": "Address arithmetic", "Id": "22272920", "Score": "3", "Body": "<p>Consider the following piece of code : </p>\n<pre><code>int main() {    \n    long long * x = new long long [10]; // array of long long\n    long a = (long) x;  // address of first element\n    long b = (long) (x+1); //address of second element\n    long c = b - a ;  // first difference\n    long d = (long) ((x+1) - x);  // second difference\n    std::cout &lt;&lt; c &lt;&lt; std::endl ;\n    std::cout &lt;&lt; d &lt;&lt; std::endl ;\n    return 0;\n}\n</code></pre>\n<p>The program out puts first 8, then 1 . \nI have got some understanding of pointers, and how to use them.\nI have come to the conclusion that adding +1 to a raw pointer value will increment it by the size of the thing it is pointing. This feature is unfamiliar to me. </p>\n<p>So my question is why do pointer types behave like this? \nWhat would be the use of such behaviour ? </p>\n", "Tags": "<c++><c><memory-address>", "OwnerUserId": "2868955", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_22272920_22272974_0": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_22272920_22272974_0": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_22272920_22272974_0": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}}}, "22272974": {"ParentId": "22272920", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-03-08T18:00:31.707", "Score": "2", "LastEditorUserId": "1708801", "LastEditDate": "2014-03-09T01:50:15.443", "Id": "22272974", "OwnerUserId": "1708801", "Body": "<p>Yes, pointer math works based on the size of the type it points to. The most basic example of why is array indexing let's says <code>E1[E2]</code> which is just syntactic sugar for <code>*((E1)+(E2))</code>. If it did not work this way then array indexing would not work properly.</p>\n<p>For reference array subscripting is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>5.2.1</code> <em>Subscripting</em> which says:</p>\n<blockquote>\n<p id=\"so_22272920_22272974_0\">[...]The expression E1[E2] is identical (by definition) to *((E1)+(E2))[...]</p>\n</blockquote>\n<p>the draft C99 standard says the same thing in section <code>6.5.2.1</code> <em>Array subscripting</em>.</p>\n<p><a href=\"http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/BitOp/pointer.html\" rel=\"nofollow\">Here</a> is a reference that goes into all the details of pointer arithmetic.</p>\n", "LastActivityDate": "2014-03-09T01:50:15.443"}});