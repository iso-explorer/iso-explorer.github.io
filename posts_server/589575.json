post_cb({"589690": {"Id": "589690", "PostTypeId": "2", "Body": "<p>For floating point numbers <a href=\"http://en.wikipedia.org/wiki/IEEE_754\" rel=\"noreferrer\">there is a standard (IEEE754)</a>: floats are 32 bit and doubles are 64. This is a hardware standard, not a C++ standard, so compilers could theoretically define float and double to some other size, but in practice I've never seen an architecture that used anything different.</p>\n", "OwnerDisplayName": "Crashworks", "LastActivityDate": "2009-02-26T08:49:36.147", "Score": "7", "CreationDate": "2009-02-26T08:49:36.147", "ParentId": "589575", "CommentCount": "2", "OwnerUserId": "53543"}, "625697": {"Body": "<p>You can use variables provided by libraries such as <a href=\"http://en.wikipedia.org/wiki/OpenGL\" rel=\"nofollow noreferrer\">OpenGL</a>, <a href=\"https://en.wikipedia.org/wiki/Qt_%28software%29\" rel=\"nofollow noreferrer\">Qt</a>, etc.</p>\n<p>For example, Qt <a href=\"http://doc.trolltech.com/4.5/qtglobal.html\" rel=\"nofollow noreferrer\">provides</a> qint8 (guaranteed to be 8-bit on all platforms supported by Qt), qint16, qint32, qint64, quint8, quint16, quint32, quint64, etc.</p>\n", "CreationDate": "2009-03-09T10:22:30.310", "ParentId": "589575", "CommentCount": "1", "LastEditDate": "2016-05-06T17:16:43.680", "PostTypeId": "2", "OwnerDisplayName": "Lawand", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:16:43.680", "Id": "625697", "Score": "-1", "OwnerUserId": "49217"}, "589685": {"Body": "<p>For 32-bit systems, the 'de facto' standard is ILP32 \u2014 that is, <code>int</code>, <code>long</code> and pointer are all 32-bit quantities.</p>\n<p>For 64-bit systems, the primary Unix 'de facto' standard is LP64 \u2014 <code>long</code> and pointer are 64-bit (but <code>int</code> is 32-bit).  The Windows 64-bit standard is LLP64 \u2014 <code>long long</code> and pointer are 64-bit (but <code>long</code> and <code>int</code> are both 32-bit).</p>\n<p>At one time, some Unix systems used an ILP64 organization.</p>\n<p>None of these de facto standards is legislated by the C standard (ISO/IEC 9899:1999), but all are permitted by it.</p>\n<p>And, by definition, <code>sizeof(char)</code> is <code>1</code>, notwithstanding the test in the Perl configure script.</p>\n<p>Note that there were machines (Crays) where <code>CHAR_BIT</code> was much larger than 8.  That meant, IIRC, that <code>sizeof(int)</code> was also 1, because both <code>char</code> and <code>int</code> were 32-bit.</p>\n", "CreationDate": "2009-02-26T08:47:59.490", "ParentId": "589575", "CommentCount": "12", "LastEditDate": "2014-10-03T08:17:37.117", "PostTypeId": "2", "LastEditorDisplayName": "Jonathan Leffler", "LastActivityDate": "2014-10-03T08:17:37.117", "LastEditorUserId": "15168", "Id": "589685", "OwnerDisplayName": "Jonathan Leffler", "Score": "202", "OwnerUserId": "15168"}, "28388728": {"Id": "28388728", "PostTypeId": "2", "Body": "<p>On a 64-bit machine: </p>\n<pre><code>int: 4\nlong: 8\nlong long: 8\nvoid*: 8\nsize_t: 8\n</code></pre>\n", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:25:00.330", "Score": "-7", "CreationDate": "2015-02-07T23:27:31.683", "ParentId": "589575", "CommentCount": "1", "OwnerUserId": "2826084", "LastEditDate": "2016-05-06T17:25:00.330"}, "16767955": {"Id": "16767955", "PostTypeId": "2", "Body": "<p>As others have answered, the \"standards\" all leave most of the details as \"implementation defined\" and only state that type \"char\" is at leat \"char_bis\" wide, and that \"char &lt;= short &lt;= int &lt;= long &lt;= long long\" (float and double are pretty much consistent with the IEEE floating point standards, and long double is typically same as double--but may be larger on more current implementations).</p>\n<p>Part of the reasons for not having very specific and exact values is because languages like C/C++ were designed to be portable to a large number of hardware platforms--Including computer systems in which the \"char\" word-size may be 4-bits or 7-bits, or even some value other than the \"8-/16-/32-/64-bit\" computers the average home computer user is exposed to. (Word-size here meaning how many bits wide the system normally operates on--Again, it's not always 8-bits as home computer users may expect.)</p>\n<p>If you really need a object (in the sense of a series of bits representing an integral value) of a specific number of bits, most compilers have some method of specifying that; But it's generally not portable, even between compilers made by the ame company but for different platforms. Some standards and practices (especially limits.h and the like) are common enough that most compilers will have support for determining at the best-fit type for a specific range of values, but not the number of bits used. (That is, if you know you need to hold values between 0 and 127, you can determine that your compiler supports an \"int8\" type of 8-bits which will be large enought to hold the full range desired, but not something like an \"int7\" type which would be an exact match for 7-bits.)</p>\n<p>Note: Many Un*x source packages used \"./configure\" script which will probe the compiler/system's capabilities and output a suitable Makefile and config.h. You might examine some of these scripts to see how they work and how they probe the comiler/system capabilities, and follow their lead.</p>\n", "LastActivityDate": "2013-05-27T07:04:36.367", "CommentCount": "0", "CreationDate": "2013-05-27T07:04:36.367", "ParentId": "589575", "Score": "1", "OwnerUserId": "2424022"}, "bq_ids": {"n4140": {"so_589575_589586_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 7212}, "so_589575_589586_0": {"length": 25, "quality": 1.0, "section_id": 7211}, "so_589575_3618674_1": {"length": 10, "quality": 1.0, "section_id": 7211}, "so_589575_3618674_0": {"length": 42, "quality": 1.0, "section_id": 7211}}, "n3337": {"so_589575_589586_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 6956}, "so_589575_589586_0": {"length": 25, "quality": 1.0, "section_id": 6955}, "so_589575_3618674_1": {"length": 10, "quality": 1.0, "section_id": 6955}, "so_589575_3618674_0": {"length": 42, "quality": 1.0, "section_id": 6955}}, "n4659": {"so_589575_589586_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 8721}, "so_589575_589586_0": {"length": 24, "quality": 0.96, "section_id": 8720}, "so_589575_3618674_1": {"length": 8, "quality": 0.8, "section_id": 8720}, "so_589575_3618674_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 8720}}}, "6339780": {"Id": "6339780", "PostTypeId": "2", "Body": "<p>You can use:</p>\n<pre><code>cout &lt;&lt; \"size of datatype = \" &lt;&lt; sizeof(datatype) &lt;&lt; endl;\n</code></pre>\n<p><code>datatype = int</code>, <code>long int</code> etc.\nYou will be able to see the size for whichever datatype you type.</p>\n", "LastEditorUserId": "1570534", "LastActivityDate": "2014-05-16T05:45:41.333", "Score": "6", "CreationDate": "2011-06-14T06:19:18.543", "ParentId": "589575", "CommentCount": "0", "OwnerUserId": "616233", "LastEditDate": "2014-05-16T05:45:41.333"}, "697531": {"Body": "<p>There is standard. </p>\n<p>C90 standard requires that</p>\n<pre><code>sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)\n</code></pre>\n<p>C99 standard requires that</p>\n<pre><code>sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt; sizeof(long long)\n</code></pre>\n<p><a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"noreferrer\">Here is the C99 specifications</a>. Page 22 details sizes of different integral types. </p>\n<p>Here is the int type sizes (bits) for Windows platforms:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Type           C99 Minimum     Windows 32bit\nchar           8               8\nshort          16              16\nint            16              32\nlong           32              32\nlong long      64              64\n</code></pre>\n<p>If you are concerned with portability, or you want the name of the type reflects the size, you can look at the header <code>&lt;inttypes.h&gt;</code>, where the following macros are available:</p>\n<pre><code>int8_t\nint16_t\nint32_t\nint64_t\n</code></pre>\n<p><code>int8_t</code> is guaranteed to be 8 bits, and <code>int16_t</code> is guaranteed to be 16 bits, etc.</p>\n", "CreationDate": "2009-03-30T14:49:54.030", "ParentId": "589575", "CommentCount": "3", "LastEditDate": "2012-04-02T10:48:12.627", "PostTypeId": "2", "OwnerDisplayName": "Ryan Shaw", "LastEditorUserId": "111575", "LastActivityDate": "2012-04-02T10:48:12.627", "Id": "697531", "Score": "72", "OwnerUserId": "80347"}, "18138095": {"Id": "18138095", "PostTypeId": "2", "Body": "<p>When it comes to built in types for different architectures and different compilers just run the following code on your architecture with your compiler to see what it outputs. Below shows my <a href=\"http://en.wikipedia.org/wiki/List_of_Ubuntu_releases#Ubuntu_13.04_.28Raring_Ringtail.29\" rel=\"nofollow\">Ubuntu\u00a013.04</a> (Raring Ringtail) 64 bit g++4.7.3 output. Also please note what was answered below which is why the output is ordered as such:</p>\n<p>\"There are five standard signed integer types: signed char, short int, int, long int, and long long int. In this list, each type provides at least as much storage as those preceding it in the list.\"</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main ( int argc, char * argv[] )\n{\n  std::cout&lt;&lt; \"size of char: \" &lt;&lt; sizeof (char) &lt;&lt; std::endl;\n  std::cout&lt;&lt; \"size of short: \" &lt;&lt; sizeof (short) &lt;&lt; std::endl;\n  std::cout&lt;&lt; \"size of int: \" &lt;&lt; sizeof (int) &lt;&lt; std::endl;\n  std::cout&lt;&lt; \"size of long: \" &lt;&lt; sizeof (long) &lt;&lt; std::endl;\n  std::cout&lt;&lt; \"size of long long: \" &lt;&lt; sizeof (long long) &lt;&lt; std::endl;\n\n  std::cout&lt;&lt; \"size of float: \" &lt;&lt; sizeof (float) &lt;&lt; std::endl;\n  std::cout&lt;&lt; \"size of double: \" &lt;&lt; sizeof (double) &lt;&lt; std::endl;\n\n  std::cout&lt;&lt; \"size of pointer: \" &lt;&lt; sizeof (int *) &lt;&lt; std::endl;\n}\n\n\nsize of char: 1\nsize of short: 2\nsize of int: 4\nsize of long: 8\nsize of long long: 8\nsize of float: 4\nsize of double: 8\nsize of pointer: 8\n</code></pre>\n", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:24:41.890", "Score": "5", "CreationDate": "2013-08-08T23:47:45.473", "ParentId": "589575", "CommentCount": "1", "OwnerUserId": "708803", "LastEditDate": "2016-05-06T17:24:41.890"}, "589597": {"Body": "<p>There is a standard and it is specified in the various standards documents (ISO, ANSI and whatnot).</p>\n<p>Wikipedia has a great page explaining the various types and the max they may store:\n<a href=\"http://en.wikipedia.org/wiki/Integer_(computer_science)\" rel=\"noreferrer\">Integer in Computer Science.</a></p>\n<p>However even with a standard C++ compiler you can find out relatively easily using the following code snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\n\nint main() {\n    // Change the template parameter to the various different types.\n    std::cout &lt;&lt; std::numeric_limits&lt;int&gt;::max() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Documentation for <a href=\"http://www2.roguewave.com/support/docs/sourcepro/edition9/html/stdlibref/numeric-limits.html\" rel=\"noreferrer\">std::numeric_limits</a> can be found at <a href=\"http://www2.roguewave.com/support/docs/sourcepro/edition9/html/stdlibref/numeric-limits.html\" rel=\"noreferrer\">Roguewave</a>. It includes a plethora of other commands you can call to find out the various limits. This can be used with any arbitrary type that conveys size, for example std::streamsize.</p>\n<p>John's answer contains the best description, as those are guaranteed to hold. No matter what platform you are on, there is another good page that goes into more detail as to how many bits each type MUST contain: <a href=\"http://home.att.net/~jackklein/c/inttypes.html\" rel=\"noreferrer\">int types</a>, which are defined in the standard.</p>\n<p>I hope this helps!</p>\n", "CreationDate": "2009-02-26T08:06:35.843", "ParentId": "589575", "CommentCount": "0", "LastEditDate": "2009-02-26T08:13:26.437", "PostTypeId": "2", "LastEditorDisplayName": "X-Istence", "LastActivityDate": "2009-02-26T08:13:26.437", "LastEditorUserId": "13986", "Id": "589597", "OwnerDisplayName": "X-Istence", "Score": "6", "OwnerUserId": "13986"}, "589586": {"Body": "<p>In practice there's no such thing. You can expect <code>std::size_t</code> to always represent the unsigned native integer size on current architecture. i.e. 16-bit, 32-bit or 64-bit.</p>\n<p>But as far as all the other built-in types go, it really depends on the compiler. Here's two excerpts taken from the current working draft of the latest C++ standard:</p>\n<blockquote>\n<p id=\"so_589575_589586_0\">There are five standard signed integer types : signed char, short int, int, long int, and long long int. In this list, each type provides at least as much storage as those preceding it in the list.</p>\n<p id=\"so_589575_589586_1\">For each of the standard signed integer types, there exists a corresponding (but different) standard unsigned integer type: unsigned char, unsigned short int, unsigned int, unsigned long int, and unsigned long long int, each of which occupies the same amount of storage and has the same alignment requirements.</p>\n</blockquote>\n<p>If you want to you can statically (compile-time) assert the sizeof these fundamental types. It will alert people to think about porting your code if the sizeof assumptions change. </p>\n", "CreationDate": "2009-02-26T08:02:56.633", "ParentId": "589575", "CommentCount": "2", "LastEditDate": "2013-07-24T10:19:22.450", "PostTypeId": "2", "LastEditorDisplayName": "Hosam Aly", "LastActivityDate": "2013-07-24T10:19:22.450", "LastEditorUserId": "1155650", "Id": "589586", "OwnerDisplayName": "John", "Score": "77", "OwnerUserId": "58961"}, "28681429": {"Id": "28681429", "PostTypeId": "2", "Body": "<p>From Alex B The C++ standard does not specify the size of integral types in bytes, but it specifies minimum ranges they must be able to hold. You can infer minimum size in bits from the required range. You can infer minimum size in bytes from that and the value of the CHAR_BIT macro that defines the number of bits in a byte (in all but the most obscure platforms it's 8, and it can't be less than 8).</p>\n<p>One additional constraint for char is that its size is always 1 byte, or CHAR_BIT bits (hence the name).</p>\n<p>Minimum ranges required by the standard (page 22) are:</p>\n<p>and Data Type Ranges on MSDN:</p>\n<p>signed char: -127 to 127 (note, not -128 to 127; this accommodates 1's-complement platforms)\nunsigned char: 0 to 255\n\"plain\" char: -127 to 127 or 0 to 255 (depends on default char signedness)\nsigned short: -32767 to 32767\nunsigned short: 0 to 65535\nsigned int: -32767 to 32767\nunsigned int: 0 to 65535\nsigned long: -2147483647 to 2147483647\nunsigned long: 0 to 4294967295\nsigned long long: -9223372036854775807 to 9223372036854775807\nunsigned long long: 0 to 18446744073709551615\nA C++ (or C) implementation can define the size of a type in bytes sizeof(type) to any value, as long as</p>\n<p>the expression sizeof(type) * CHAR_BIT evaluates to the number of bits enough to contain required ranges, and\nthe ordering of type is still valid (e.g. sizeof(int) &lt;= sizeof(long)).\nThe actual implementation-specific ranges can be found in  header in C, or  in C++ (or even better, templated std::numeric_limits in  header).</p>\n<p>For example, this is how you will find maximum range for int:</p>\n<p>C:</p>\n<pre><code>#include &lt;limits.h&gt;\nconst int min_int = INT_MIN;\nconst int max_int = INT_MAX;\n</code></pre>\n<p>C++:</p>\n<pre><code>#include &lt;limits&gt;\nconst int min_int = std::numeric_limits&lt;int&gt;::min();\nconst int max_int = std::numeric_limits&lt;int&gt;::max();\n</code></pre>\n<p>This is correct, however, you were also right in saying that:\nchar   : 1 byte\nshort  : 2 bytes\nint    : 4 bytes\nlong   : 4 bytes\nfloat  : 4 bytes\ndouble : 8 bytes</p>\n<p>Because 32 bit architectures are still the default and most used, and they have kept these standard sizes since the pre-32 bit days when memory was less available, and for backwards compatibility and standardization it remained the same. Even 64 bit systems tend to use these and have extentions/modifications.\nPlease reference this for more information:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/types</a></p>\n", "LastActivityDate": "2015-02-23T19:05:49.933", "CommentCount": "0", "CreationDate": "2015-02-23T19:05:49.933", "ParentId": "589575", "Score": "0", "OwnerUserId": "4233869"}, "589684": {"Body": "<p>The C++ standard does not specify the size of integral types in bytes, but it specifies minimum ranges they must be able to hold. You can infer minimum size in bits from the required range. You can infer minimum size in bytes from that and the value of the <code>CHAR_BIT</code> macro that <a href=\"https://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c/437640#437640\">defines the number of bits in a byte</a> (in all but the most obscure platforms it's 8, and it can't be less than 8).</p>\n<p>One additional constraint for <code>char</code> is that its size is always 1 byte, or <code>CHAR_BIT</code> bits (hence the name).</p>\n<p>Minimum ranges <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"noreferrer\">required by the standard</a> (page 22) are:</p>\n<p>and Data Type Ranges on <a href=\"http://msdn.microsoft.com/en-us/library/s3f49ktz.aspx\" rel=\"noreferrer\">MSDN</a>:</p>\n<ol>\n<li><code>signed char</code>: -127 to 127 (note, not -128 to 127; this accommodates 1's-complement and sign-and-magnitude platforms)</li>\n<li><code>unsigned char</code>: 0 to 255</li>\n<li>\"plain\" <code>char</code>: same range as <code>signed char</code> or <code>unsigned char</code>, <a href=\"https://stackoverflow.com/q/2397984\">implementation-defined</a></li>\n<li><code>signed short</code>: -32767 to 32767</li>\n<li><code>unsigned short</code>: 0 to 65535</li>\n<li><code>signed int</code>: -32767 to 32767</li>\n<li><code>unsigned int</code>: 0 to 65535</li>\n<li><code>signed long</code>: -2147483647 to 2147483647</li>\n<li><code>unsigned long</code>: 0 to 4294967295</li>\n<li><code>signed long long</code>: -9223372036854775807 to 9223372036854775807</li>\n<li><code>unsigned long long</code>: 0 to 18446744073709551615</li>\n</ol>\n<p>A C++ (or C) implementation can define the size of a type in bytes <code>sizeof(type)</code> to any value, as long as</p>\n<ol>\n<li>the expression <code>sizeof(type) * CHAR_BIT</code> evaluates to a number of bits high enough to contain required ranges, and</li>\n<li>the ordering of type is still valid (e.g. <code>sizeof(int) &lt;= sizeof(long)</code>).</li>\n</ol>\n<p>The actual implementation-specific ranges can be found in <code>&lt;limits.h&gt;</code> header in C, or <code>&lt;climits&gt;</code> in C++ (or even better, templated <code>std::numeric_limits</code> in <code>&lt;limits&gt;</code> header).</p>\n<p>For example, this is how you will find maximum range for <code>int</code>:</p>\n<p><strong>C:</strong></p>\n<pre><code>#include &lt;limits.h&gt;\nconst int min_int = INT_MIN;\nconst int max_int = INT_MAX;\n</code></pre>\n<p><strong>C++</strong>:</p>\n<pre><code>#include &lt;limits&gt;\nconst int min_int = std::numeric_limits&lt;int&gt;::min();\nconst int max_int = std::numeric_limits&lt;int&gt;::max();\n</code></pre>\n", "CreationDate": "2009-02-26T08:47:43.623", "ParentId": "589575", "CommentCount": "15", "LastEditDate": "2017-05-23T12:02:43.670", "PostTypeId": "2", "LastEditorDisplayName": "Checkers", "LastActivityDate": "2015-07-14T03:09:03.537", "LastEditorUserId": "-1", "Id": "589684", "OwnerDisplayName": "Checkers", "Score": "607", "OwnerUserId": "23643"}, "20889319": {"Id": "20889319", "PostTypeId": "2", "Body": "<pre><code>unsigned char bits = sizeof(X) &lt;&lt; 3;\n</code></pre>\n<p>where <code>X</code> is a <code>char</code>,<code>int</code>,<code>long</code> etc.. will give you size of <code>X</code> in bits.</p>\n", "LastEditorUserId": "1169798", "LastActivityDate": "2014-01-02T18:41:56.110", "Score": "0", "CreationDate": "2014-01-02T18:25:25.897", "ParentId": "589575", "CommentCount": "2", "OwnerUserId": "3154672", "LastEditDate": "2014-01-02T18:41:56.110"}, "3618674": {"Id": "3618674", "PostTypeId": "2", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"noreferrer\">C++ Standard</a> says it like this:</p>\n<p>3.9.1, \u00a72:</p>\n<blockquote>\n<p id=\"so_589575_3618674_0\">There are five signed integer types :\n  \"signed char\", \"short int\", \"int\",\n  \"long int\", and \"long long int\". In\n  this list, each type provides at least\n  as much storage as those preceding it\n  in the list. Plain ints have the\n  natural size suggested by the\n  architecture of the execution\n  environment (44); the other signed\n  integer types are provided to meet\n  special needs.</p>\n<p id=\"so_589575_3618674_1\">(44) that is, <b>large enough to contain\n  any value in the range of INT_MIN and\n  INT_MAX, as defined in the header\n  <code>&lt;climits&gt;</code></b>.</p>\n</blockquote>\n<p>The conclusion: It depends on which architecture you're working on. Any other assumption is false.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:17:25.370", "Score": "16", "CreationDate": "2010-09-01T13:41:13.873", "ParentId": "589575", "CommentCount": "0", "OwnerUserId": "3673", "LastEditDate": "2016-05-06T17:17:25.370"}, "31163442": {"Id": "31163442", "PostTypeId": "2", "Body": "<p>I notice that all the other answers here have focused almost exclusively on integral types, while the questioner also asked about floating-points.</p>\n<p>I don't think the C++ standard requires it, but compilers for the most common platforms these days generally follow the IEEE754 standard for their floating-point numbers. This standard specifies four types of binary floating-point (as well as some BCD formats, which I've never seen support for in C++ compilers):</p>\n<ul>\n<li>Half precision (binary16) - 11-bit significand, exponent range -14 to 15</li>\n<li>Single precision (binary32) - 24-bit significand, exponent range -126 to 127</li>\n<li>Double precision (binary64) - 53-bit significand, exponent range -1022 to 1023</li>\n<li>Quadruple precision (binary128) - 113-bit significand, exponent range -16382 to 16383</li>\n</ul>\n<p>How does this map onto C++ types, then? Generally the <code>float</code> uses single precision; thus, <code>sizeof(float) = 4</code>. Then <code>double</code> uses double precision (I believe that's the source of the name <code>double</code>), and <code>long double</code> may be either double or quadruple precision (it's quadruple on my system, but on 32-bit systems it may be double). I don't know of any compilers that offer half precision floating-points.</p>\n<p>In summary, this is the usual:</p>\n<ul>\n<li><code>sizeof(float)</code> = 4</li>\n<li><code>sizeof(double)</code> = 8</li>\n<li><code>sizeof(long double)</code> = 8 or 16</li>\n</ul>\n", "LastActivityDate": "2015-07-01T13:56:32.647", "CommentCount": "1", "CreationDate": "2015-07-01T13:56:32.647", "ParentId": "589575", "Score": "0", "OwnerUserId": "1502810"}, "592062": {"Body": "<p>Updated: C++11 brought the types from TR1 officially into the standard:</p>\n<ul>\n<li>long long int</li>\n<li>unsigned long long int</li>\n</ul>\n<p>And the \"sized\" types from <code>&lt;cstdint&gt;</code></p>\n<ul>\n<li>int8_t</li>\n<li>int16_t</li>\n<li>int32_t</li>\n<li>int64_t</li>\n<li>(and the unsigned counterparts).</li>\n</ul>\n<p>Plus you get:</p>\n<ul>\n<li>int_least8_t</li>\n<li>int_least16_t</li>\n<li>int_least32_t</li>\n<li>int_least64_t</li>\n<li>Plus the unsigned counterparts. </li>\n</ul>\n<p>These types represent the smallest integer types with at least the specified number of bits. Likewise there are the \"fastest\" integer types with at least the specified number of bits:</p>\n<ul>\n<li>int_fast8_t</li>\n<li>int_fast16_t</li>\n<li>int_fast32_t</li>\n<li>int_fast64_t</li>\n<li>Plus the unsigned versions. </li>\n</ul>\n<p>What \"fast\" means, if anything, is up to the implementation. It need not be the fastest for all purposes either.</p>\n", "CreationDate": "2009-02-26T19:32:40.530", "ParentId": "589575", "CommentCount": "6", "LastEditDate": "2014-09-18T03:04:41.917", "PostTypeId": "2", "OwnerDisplayName": "Brian Neal", "LastEditorUserId": "63485", "LastActivityDate": "2014-09-18T03:04:41.917", "Id": "592062", "Score": "31", "OwnerUserId": "63485"}, "592308": {"Id": "592308", "PostTypeId": "2", "Body": "<p>1) Table N1 in article \"<a href=\"http://www.viva64.com/art-1-2-16511733.html\" rel=\"noreferrer\">The forgotten problems of 64-bit programs development</a>\"</p>\n<p>2) \"<a href=\"http://www.viva64.com/terminology/Data_model.html\" rel=\"noreferrer\">Data model</a>\"</p>\n", "OwnerDisplayName": "Andrew", "LastActivityDate": "2009-02-26T20:31:18.487", "Score": "6", "CreationDate": "2009-02-26T20:31:18.487", "ParentId": "589575", "CommentCount": "0"}, "589625": {"Body": "<p>If you need fixed size types, use types like uint32_t (unsigned integer 32 bits) defined in <a href=\"http://en.wikipedia.org/wiki/Stdint.h\" rel=\"noreferrer\">stdint.h</a>. They are specified in <a href=\"https://en.wikipedia.org/wiki/C99\" rel=\"noreferrer\">C99</a>.</p>\n", "CreationDate": "2009-02-26T08:18:12.260", "ParentId": "589575", "CommentCount": "2", "LastEditDate": "2016-05-06T17:14:55.703", "PostTypeId": "2", "OwnerDisplayName": "Ben", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:14:55.703", "Id": "589625", "Score": "37", "OwnerUserId": "38924"}, "11485218": {"Id": "11485218", "PostTypeId": "2", "Body": "<p>We are allowed to define a synonym for the type so we can create our own \"standard\". </p>\n<p>On a machine in which sizeof(int) == 4, we can define:</p>\n<pre><code>typedef int int32;\n\nint32 i;\nint32 j;\n...\n</code></pre>\n<p>So when we transfer the code to a different machine where actually the size of long int is 4, we can just redefine the single occurrence of int.</p>\n<pre><code>typedef long int int32;\n\nint32 i;\nint32 j;\n...\n</code></pre>\n", "LastEditorUserId": "1477024", "LastActivityDate": "2015-07-14T07:06:13.077", "Score": "8", "CreationDate": "2012-07-14T16:01:46.560", "ParentId": "589575", "CommentCount": "1", "OwnerUserId": "1477024", "LastEditDate": "2015-07-14T07:06:13.077"}, "589599": {"Id": "589599", "PostTypeId": "2", "Body": "<p>Nope, there is no standard for type sizes. Standard only requires that:</p>\n<pre><code>sizeof(short int) &lt;= sizeof(int) &lt;= sizeof(long int)\n</code></pre>\n<p>The best thing you can do if you want variables of a fixed sizes is to use macros like this:</p>\n<pre><code>#ifdef SYSTEM_X\n  #define WORD int\n#else\n  #define WORD long int\n#endif\n</code></pre>\n<p>Then you can use WORD to define your variables. It's not that I like this but it's the <strong>most portable</strong> way.</p>\n", "OwnerDisplayName": "happy_emi", "LastActivityDate": "2009-02-26T08:07:09.040", "Score": "11", "CreationDate": "2009-02-26T08:07:09.040", "ParentId": "589575", "CommentCount": "4", "OwnerUserId": "62811"}, "7438551": {"Id": "7438551", "PostTypeId": "2", "Body": "<p>There are four types of integers based on size:</p>\n<ul>\n<li>short integer: 2 byte</li>\n<li>long integer: 4 byte</li>\n<li>long long integer: 8 byte</li>\n<li>integer: depends upon the compiler (16 bit, 32 bit, or 64 bit)</li>\n</ul>\n", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:20:35.620", "Score": "-8", "CreationDate": "2011-09-15T23:18:37.010", "ParentId": "589575", "CommentCount": "2", "OwnerUserId": "947876", "LastEditDate": "2016-05-06T17:20:35.620"}, "589575": {"ViewCount": "1107963", "Body": "<p>I'm looking for detailed information regarding the size of basic C++ types.\nI know that it depends on the architecture (16 bits, 32 bits, 64 bits) and the compiler.</p>\n<p>But are there any standards for C++?</p>\n<p>I'm using Visual Studio 2008 on a 32-bit architecture. Here is what I get:</p>\n<pre><code>char  : 1 byte\nshort : 2 bytes\nint   : 4 bytes\nlong  : 4 bytes\nfloat : 4 bytes\ndouble: 8 bytes\n</code></pre>\n<p>I tried to find, without much success, reliable information stating the sizes of <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>double</code>, <code>float</code> (and other types I didn't think of) under different architectures and compilers.</p>\n", "Title": "What does the C++ standard state the size of int, long type to be?", "CreationDate": "2009-02-26T07:59:23.367", "LastActivityDate": "2016-05-06T18:09:06.887", "CommentCount": "10", "FavoriteCount": "304", "PostTypeId": "1", "LastEditDate": "2016-05-06T18:09:06.887", "LastEditorDisplayName": "Jonathan Leffler", "OwnerDisplayName": "J&#233;r&#244;me", "LastEditorUserId": "15168", "Id": "589575", "Score": "602", "OwnerUserId": "2796", "Tags": "<c++><c++-faq>", "AnswerCount": "24"}, "13091807": {"CommunityOwnedDate": "2012-10-26T17:43:10.087", "PostTypeId": "2", "Body": "<p>If you are interested in a pure C++ solution, I made use of templates and only C++ standard code to define types at compile time based on their bit size. \nThis make the solution portable across compilers.</p>\n<p>The idea behind is very simple: Create a list containing types char, int, short, long, long long (signed and unsigned versions) and the scan the list and by the use of numeric_limits template select the type with given size.</p>\n<p>Including this header you got 8 type stdtype::int8, stdtype::int16, stdtype::int32, stdtype::int64, stdtype::uint8, stdtype::uint16, stdtype::uint32, stdtype::uint64.</p>\n<p>If some type cannot be represented it will be evaluated to stdtype::null_type also declared in that header.</p>\n<p>THE CODE BELOW IS GIVEN WITHOUT WARRANTY, PLEASE DOUBLE CHECK IT.<br>\nI'M NEW AT METAPROGRAMMING TOO, FEEL FREE TO EDIT AND CORRECT THIS CODE.<br>\nTested with DevC++ (so a gcc version around 3.5)</br></br></p>\n<pre><code>#include &lt;limits&gt;\n\nnamespace stdtype\n{\n    using namespace std;\n\n\n    /*\n     * THIS IS THE CLASS USED TO SEMANTICALLY SPECIFY A NULL TYPE.\n     * YOU CAN USE WHATEVER YOU WANT AND EVEN DRIVE A COMPILE ERROR IF IT IS \n     * DECLARED/USED.\n     *\n     * PLEASE NOTE that C++ std define sizeof of an empty class to be 1.\n     */\n    class null_type{};\n\n    /*\n     *  Template for creating lists of types\n     *\n     *  T is type to hold\n     *  S is the next type_list&lt;T,S&gt; type\n     *\n     *  Example:\n     *   Creating a list with type int and char: \n     *      typedef type_list&lt;int, type_list&lt;char&gt; &gt; test;\n     *      test::value         //int\n     *      test::next::value   //char\n     */\n    template &lt;typename T, typename S&gt; struct type_list\n    {\n        typedef T value;\n        typedef S next;         \n\n    };\n\n\n\n\n    /*\n     * Declaration of template struct for selecting a type from the list\n     */\n    template &lt;typename list, int b, int ctl&gt; struct select_type;\n\n\n    /*\n     * Find a type with specified \"b\" bit in list \"list\"\n     *\n     * \n     */\n    template &lt;typename list, int b&gt; struct find_type\n    {   \n        private:\n            //Handy name for the type at the head of the list\n            typedef typename list::value cur_type;\n\n            //Number of bits of the type at the head\n            //CHANGE THIS (compile time) exp TO USE ANOTHER TYPE LEN COMPUTING\n            enum {cur_type_bits = numeric_limits&lt;cur_type&gt;::digits};\n\n        public:\n            //Select the type at the head if b == cur_type_bits else\n            //select_type call find_type with list::next\n            typedef  typename select_type&lt;list, b, cur_type_bits&gt;::type type;\n    };\n\n    /*\n     * This is the specialization for empty list, return the null_type\n     * OVVERRIDE this struct to ADD CUSTOM BEHAVIOR for the TYPE NOT FOUND case\n     * (ie search for type with 17 bits on common archs)\n     */\n    template &lt;int b&gt; struct find_type&lt;null_type, b&gt;\n    {   \n        typedef null_type type;\n\n    };\n\n\n    /*\n     * Primary template for selecting the type at the head of the list if\n     * it matches the requested bits (b == ctl)\n     *\n     * If b == ctl the partial specified templated is evaluated so here we have\n     * b != ctl. We call find_type on the next element of the list\n     */\n    template &lt;typename list, int b, int ctl&gt; struct select_type\n    {   \n            typedef  typename find_type&lt;typename list::next, b&gt;::type type; \n    };\n\n    /*\n     * This partial specified templated is used to select top type of a list\n     * it is called by find_type with the list of value (consumed at each call)\n     * the bits requested (b) and the current type (top type) length in bits\n     *\n     * We specialice the b == ctl case\n     */\n    template &lt;typename list, int b&gt; struct select_type&lt;list, b, b&gt;\n    {\n            typedef typename list::value type;\n    };\n\n\n    /*\n     * These are the types list, to avoid possible ambiguity (some weird archs)\n     * we kept signed and unsigned separated\n     */\n\n    #define UNSIGNED_TYPES type_list&lt;unsigned char,         \\\n        type_list&lt;unsigned short,                           \\\n        type_list&lt;unsigned int,                             \\\n        type_list&lt;unsigned long,                            \\\n        type_list&lt;unsigned long long, null_type&gt; &gt; &gt; &gt; &gt;\n\n    #define SIGNED_TYPES type_list&lt;signed char,         \\\n        type_list&lt;signed short,                         \\\n        type_list&lt;signed int,                           \\\n        type_list&lt;signed long,                          \\\n        type_list&lt;signed long long, null_type&gt; &gt; &gt; &gt; &gt;\n\n\n\n    /*\n     * These are acutally typedef used in programs.\n     * \n     * Nomenclature is [u]intN where u if present means unsigned, N is the \n     * number of bits in the integer\n     *\n     * find_type is used simply by giving first a type_list then the number of \n     * bits to search for.\n     *\n     * NB. Each type in the type list must had specified the template \n     * numeric_limits as it is used to compute the type len in (binary) digit.\n     */\n    typedef find_type&lt;UNSIGNED_TYPES, 8&gt;::type  uint8;\n    typedef find_type&lt;UNSIGNED_TYPES, 16&gt;::type uint16;\n    typedef find_type&lt;UNSIGNED_TYPES, 32&gt;::type uint32;\n    typedef find_type&lt;UNSIGNED_TYPES, 64&gt;::type uint64;\n\n    typedef find_type&lt;SIGNED_TYPES, 7&gt;::type    int8;\n    typedef find_type&lt;SIGNED_TYPES, 15&gt;::type   int16;\n    typedef find_type&lt;SIGNED_TYPES, 31&gt;::type   int32;\n    typedef find_type&lt;SIGNED_TYPES, 63&gt;::type   int64;\n\n}\n</code></pre>\n", "OwnerDisplayName": "user781847", "LastActivityDate": "2012-10-26T17:43:10.087", "Score": "1", "CreationDate": "2012-10-26T17:43:10.087", "ParentId": "589575", "CommentCount": "0", "Id": "13091807"}, "589596": {"Id": "589596", "PostTypeId": "2", "Body": "<p>As you mentioned - it largely depends upon the compiler and the platform. For this, check the ANSI standard, <a href=\"http://home.att.net/~jackklein/c/inttypes.html\" rel=\"nofollow noreferrer\">http://home.att.net/~jackklein/c/inttypes.html</a></p>\n<p>Here is the one for the Microsoft compiler: <em><a href=\"http://msdn.microsoft.com/en-us/library/s3f49ktz(vs.71).aspx\" rel=\"nofollow noreferrer\">Data Type Ranges</a></em>.</p>\n", "LastEditorUserId": "63550", "LastActivityDate": "2016-05-06T17:13:43.493", "Score": "0", "CreationDate": "2009-02-26T08:06:08.467", "ParentId": "589575", "CommentCount": "0", "OwnerUserId": "36130", "LastEditDate": "2016-05-06T17:13:43.493"}, "589581": {"Body": "<p>As mentioned the size should reflect the current architecture. You could take a peak around in <code>limits.h</code> if you want to see how your current compiler is handling things.</p>\n", "CreationDate": "2009-02-26T08:01:31.893", "ParentId": "589575", "CommentCount": "1", "LastEditDate": "2013-07-24T10:18:46.917", "PostTypeId": "2", "LastEditorDisplayName": "John T", "LastActivityDate": "2013-07-24T10:18:46.917", "LastEditorUserId": "1155650", "Id": "589581", "OwnerDisplayName": "John T", "Score": "3", "OwnerUserId": "36457"}});