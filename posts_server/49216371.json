post_cb({"bq_ids": {"n4140": {"so_49216371_49216508_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 235}, "so_49216371_49216464_1": {"length": 19, "quality": 0.7307692307692307, "section_id": 243}}, "n3337": {"so_49216371_49216508_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 228}, "so_49216371_49216464_1": {"length": 17, "quality": 0.6538461538461539, "section_id": 235}}, "n4659": {"so_49216371_49216508_1": {"length": 9, "quality": 0.5294117647058824, "section_id": 245}, "so_49216371_49216464_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 250}}}, "49216508": {"Id": "49216508", "PostTypeId": "2", "Body": "<p>It is not a bug in GCC. You do not call your function template, therefore the function is not instantiated, and it does not try to access the private member of the nested class. Try to call your function somewhere in a real function (not template) or try to refer it (implicit instantiation).</p>\n<blockquote>\n<p id=\"so_49216371_49216508_0\">A function template by itself is not a type, or a function, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be determined so that the compiler can generate an actual function (or class, from a class template).</p>\n<p id=\"so_49216371_49216508_1\">When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs.</p>\n</blockquote>\n<pre><code>template void Enclosing::EnclosingFun(Enclosing::Nested *n, int t); // instantiates the function for the second int parameter\n</code></pre>\n", "LastEditorUserId": "6752050", "LastActivityDate": "2018-03-11T04:05:36.110", "Score": "2", "CreationDate": "2018-03-11T03:59:39.613", "ParentId": "49216371", "CommentCount": "0", "OwnerUserId": "6752050", "LastEditDate": "2018-03-11T04:05:36.110"}, "49216371": {"ViewCount": "32", "Body": "<p>The following code fails to compile as expected:</p>\n<pre><code>#include&lt;iostream&gt;\nclass Enclosing {\n    int x;\n    class Nested { int y; };\n\n    void EnclosingFun(Nested *n) {\n        std::cout &lt;&lt; n-&gt;y;  // Compiler Error: y is private in Nested\n    }\n};\n</code></pre>\n<p>However, if I change EnclosingFun into a template member function, the compiler (gcc-7) doesn't complain about accessing y:</p>\n<pre><code>#include&lt;iostream&gt;\nclass Enclosing {      \n    int x;\n    class Nested { int y; };\n\n    template &lt;typename T&gt;\n    void EnclosingFun(Nested *n, T t) {\n        std::cout &lt;&lt; t &lt;&lt; n-&gt;y;  // OK? Why?\n    }      \n};\n</code></pre>\n<p>Is this a bug in gcc? Or does c++ have different access rules for template member function to access nested classes?</p>\n", "Title": "C++ class template function can access nested class private member", "CreationDate": "2018-03-11T03:32:51.307", "LastActivityDate": "2018-03-11T04:05:36.110", "CommentCount": "3", "LastEditDate": "2018-03-11T03:56:42.990", "PostTypeId": "1", "LastEditorUserId": "3309790", "Id": "49216371", "Score": "3", "OwnerUserId": "5944048", "Tags": "<c++><templates><private><instantiation>", "AnswerCount": "2"}, "49216464": {"Id": "49216464", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_49216371_49216464_0\">Is this a bug in gcc? Or does c++ have different access rules for template member function to access nested classes?</p>\n</blockquote>\n<p>No either.</p>\n<p>According to the standard, <a href=\"http://eel.is/c++draft/temp.inst#10\" rel=\"nofollow noreferrer\">\u00a717.8.1 Implicit instantiation [temp.inst]</a>,</p>\n<blockquote>\n<p id=\"so_49216371_49216464_1\">An implementation shall not implicitly instantiate a function template, a variable template, a member template, a non-virtual member function, a member class, a static data member of a class template, or a substatement of a constexpr if statement ([stmt.if]), unless such instantiation is required.</p>\n</blockquote>\n<p>That means, <code>Enclosing::EnclosingFun()</code> is not instantiated here. Adding the invocation to it would cause it to be instantiated, then you'll get the error, e.g.</p>\n<pre><code>prog.cc:8:30: error: 'int Enclosing::Nested::y' is private within this context\n         std::cout &lt;&lt; t &lt;&lt; n-&gt;y;  // OK? Why?\n                           ~~~^\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/XvYc1CcTlCFJt6Sv\" rel=\"nofollow noreferrer\">LIVE</a></p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2018-03-11T03:56:48.020", "Score": "4", "CreationDate": "2018-03-11T03:50:09.207", "ParentId": "49216371", "CommentCount": "1", "OwnerUserId": "3309790", "LastEditDate": "2018-03-11T03:56:48.020"}});