post_cb({"bq_ids": {"n4140": {"so_15222638_15222768_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 64}}, "n3337": {"so_15222638_15222768_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 59}}, "n4659": {"so_15222638_15222768_0": {"length": 44, "quality": 0.9565217391304348, "section_id": 66}}}, "15222833": {"Id": "15222833", "PostTypeId": "2", "Body": "<p>No, you cannot use such code. You can use following for example</p>\n<pre><code>template&lt;typename... Params&gt;\nclass FunctionDelegate;\n</code></pre>\n<p>or</p>\n<pre><code>template&lt;typename Arguments, typename Params&gt;\nclass FunctionDelegate;\n</code></pre>\n<p>as Xeo suggests.</p>\n<pre><code>template&lt;typename... Arguments, typename... Params&gt;\nclass FunctionDelegate&lt;tuple&lt;Arguments...&gt;, tuple&lt;Params...&gt;&gt; : \npublic Runnable&lt;Params...&gt; { // };\n</code></pre>\n", "LastActivityDate": "2013-03-05T11:38:21.843", "CommentCount": "2", "CreationDate": "2013-03-05T11:38:21.843", "ParentId": "15222638", "Score": "5", "OwnerUserId": "1498580"}, "15222768": {"Id": "15222768", "PostTypeId": "2", "Body": "<p>Concerning your first two questions (the answers are \"<strong>No</strong>\" and \"<strong>No</strong>\"), paragraph 14.1/11 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_15222638_15222768_0\">If a template-parameter of a class template or alias template has a default template-argument, each subsequent\n  template-parameter shall either have a default template-argument supplied or be a template parameter\n  pack. <strong>If a template-parameter of a primary class template or alias template is a template parameter pack,\n  it shall be the last template-parameter</strong>. A template parameter pack of a function template shall not be\n  followed by another template parameter unless that template parameter can be deduced or has a default\n  argument (14.8.2). [ Example:</p>\n</blockquote>\n<pre><code>template&lt;class T1 = int, class T2&gt; class B; // error\n// U cannot be deduced or specified\ntemplate&lt;class... T, class... U&gt; void f() { }\ntemplate&lt;class... T, class U&gt; void g() { }\n</code></pre>\n<blockquote>\n<p id=\"so_15222638_15222768_1\">\u2014end example ]</p>\n</blockquote>\n<p>Your example clearly violates the sentence in bold, which prohibits having more than one template argument pack on a (primary) class template.</p>\n", "LastActivityDate": "2013-03-05T11:35:02.030", "CommentCount": "4", "CreationDate": "2013-03-05T11:35:02.030", "ParentId": "15222638", "Score": "4", "OwnerUserId": "1932150"}, "15222638": {"ViewCount": "956", "Body": "<p>So, I've recently build a delegate system using c++11's variadic templates, and it works just as a charm.</p>\n<p>However in the system I've built arguments to functions are given at creation-time (as I'd like), but now I'd also like to be able to pass some (variable) number of arguments at call-time. In order to achieve this, I went and redid my code, however is where I'm getting the issues;</p>\n<pre><code>error: parameter packs must be at the end of the parameter list\nsorry, unimplemented: cannot expand \u2018Arguments ...\u2019 into a fixed-length argument list\nerror: type/value mismatch at argument 1 in template parameter list for \u2018template&lt;&lt;declaration error&gt;, class ... Params&gt; class FunctionDelegate\u2019\n</code></pre>\n<p>... and a lot more to come, so here's a snippet that spawned the issue;</p>\n<pre><code>template&lt;typename... Params&gt; \nclass Runnable\n{\n    public:\n        virtual void invoke(tuple&lt;Params...&gt; params) = 0;\n        virtual ~Runnable() \n        {\n        }\n};\n</code></pre>\n<p>This is the parent class for my two delegates (FunctionDelegate and ObjectDelegate). This used to be an untemplated class (as invoke didn't take any arguments), however as I've a variadic template list to it, I had to modify my subclasses as well (obviously), and I've just added another variadic template to them;</p>\n<pre><code>template&lt;typename... Arguments, typename... Params&gt;\nclass FunctionDelegate : public Runnable&lt;Params...&gt;\n{\n    public:\n        typedef void (*FunctionType)(Arguments..., Params...);\n\n        FunctionDelegate(FunctionType function, tuple&lt;Arguments...&gt; args)\n            : function(function), args(args)\n        {\n        }\n\n        void invoke(tuple&lt;Params...&gt; params) \n        {\n            callFunction(typename gens&lt;sizeof...(Arguments)&gt;::type(), params, typename gens&lt;sizeof...(Params)&gt;::type());\n        }\n    private:\n        template&lt;int... S, int... R&gt;\n        void callFunction(seq&lt;S...&gt;, tuple&lt;Params...&gt; params, seq&lt;R...&gt;)\n        {\n            function(get&lt;S&gt;(args)..., get&lt;R&gt;(params)...);\n        }\n    private:\n        FunctionType function;\n        tuple&lt;Arguments...&gt; args;\n};\n</code></pre>\n<p>This however, does not seem to be allowed, atleast that's what I suspect, so;</p>\n<ol>\n<li>Is it allowed to have two variadic template lists?</li>\n<li>Is there some way, that I can hint the compiler, about which goes to which list? (namely the ones used in the constructor goes to Arguments, and the rest to Params).</li>\n<li>If there's simply no way to do this (using two variadic template lists), isn't it possible using one, Arguments and Parameters in the same variadic list, and then simply splitting that using the arguments to the constructor?</li>\n<li>Is there any other way to achieve what I'm trying? (except from using the plain old, non type-checked variadic parameter passing). </li>\n</ol>\n<p>Any help or insight is welcome. </p>\n", "AcceptedAnswerId": "15222768", "Title": "Multiple variadic templated delegate system", "CreationDate": "2013-03-05T11:28:44.987", "Id": "15222638", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-03-05T11:38:21.843", "Score": "2", "OwnerUserId": "480212", "Tags": "<c++><templates><c++11><delegates><metaprogramming>", "AnswerCount": "2"}});