post_cb({"11703553": {"CommentCount": "18", "ViewCount": "707", "PostTypeId": "1", "LastEditorUserId": "597607", "CreationDate": "2012-07-28T18:20:24.827", "LastActivityDate": "2012-07-29T11:59:27.550", "Title": "Template specialization not used", "AcceptedAnswerId": "11703570", "LastEditDate": "2012-07-29T11:59:27.550", "Id": "11703553", "Score": "1", "Body": "<p>I have the following functions defined:</p>\n<pre><code>template &lt;typename T&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, T data);\ntemplate &lt;&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, const char *data);\ntemplate &lt;&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, const Glib::ustring &amp;data);\n</code></pre>\n<p>When I call:</p>\n<pre><code>buffer &lt;&lt; Glib::ustring(\"hello\");\n</code></pre>\n<p>The compiler uses the general template definition instead of the specialization with Glib::ustring.</p>\n<p>What am I doing wrong here?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "526974", "AnswerCount": "2"}, "11703890": {"ParentId": "11703553", "CommentCount": "0", "Body": "<pre><code>template &lt;typename T&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, T data);\n</code></pre>\n<p>is primary template. Specializations are not primary templates. Compiler finds only primary templates when match functions and then, if chosen template function has specialisations looks at these, if compiler find specialization, that exactly match parameters - uses it, else uses primary template.</p>\n<pre><code>template &lt;&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, const Glib::ustring &amp;data)\n</code></pre>\n<p>this specialization not exactly matches operation <code>buffer_t &lt;&lt; Glib::ustring(\"s\")</code>, but this matches exactly</p>\n<pre><code>template &lt;&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, Glib::ustring data)\n</code></pre>\n<p>I suggest you to not use function-template specialization, use overload.</p>\n<pre><code>template &lt;typename T&gt; buffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, T data);\nbuffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, const char *data);\nbuffer_t &amp;operator&lt;&lt;(buffer_t &amp;buffer, const Glib::ustring &amp;data);\n</code></pre>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "11703890", "Score": "4", "CreationDate": "2012-07-28T19:13:46.287", "LastActivityDate": "2012-07-28T19:13:46.287"}, "11703570": {"ParentId": "11703553", "LastEditDate": "2012-07-28T19:26:42.437", "CommentCount": "6", "CreationDate": "2012-07-28T18:22:41.997", "OwnerUserId": "596781", "LastEditorUserId": "596781", "PostTypeId": "2", "Id": "11703570", "Score": "4", "Body": "<p>You have a <em>function</em> template, and you want to perform <em>template argument deduction</em>. For this purpose, your function call is matched against the templated function argument <code>T data</code>. I believe that 14.8.2.4 applies to the partial ordering for your specialization where <code>P</code> is the template argument and <code>A</code> is the type of the actual argument; emphasis is mine):</p>\n<blockquote>\n<p id=\"so_11703553_11703570_0\">Before the partial ordering is done, certain transformations are performed on the types used for partial\n  ordering:</p>\n<p id=\"so_11703553_11703570_1\">\u2014 If <code>P</code> is a reference type, <code>P</code> is replaced by the type referred to.</p>\n<p id=\"so_11703553_11703570_2\">\u2014 <strong>If <code>A</code> is a reference type, <code>A</code> is replaced by the type referred to.</strong></p>\n</blockquote>\n<p>Thus, since the type of your argument is <code>A = Glib::ustring</code>, then this is not as good a match for the specialization <code>const Glib::ustring &amp;</code> as the primary template is, and even if you have an actual const-reference, the reference is stripped off during the partial ordering, and you again end up with a worse match.</p>\n<p>The usual way to fix this is to make your primary template a const-reference; this can also bind to temporary objects and should thus be \"as good as\" a value argument:</p>\n<pre><code>template &lt;typename T&gt; buffer_t &amp; operator&lt;&lt;(buffer_t &amp; buffer, T const &amp; data);\n//                                                             ^^^^^^^^^\n</code></pre>\n", "LastActivityDate": "2012-07-28T19:26:42.437"}, "bq_ids": {"n4140": {"so_11703553_11703570_2": {"section_id": 324, "quality": 1.0, "length": 5}, "so_11703553_11703570_0": {"section_id": 324, "quality": 1.0, "length": 10}, "so_11703553_11703570_1": {"section_id": 324, "quality": 1.0, "length": 5}}, "n3337": {"so_11703553_11703570_2": {"section_id": 314, "quality": 1.0, "length": 5}, "so_11703553_11703570_0": {"section_id": 314, "quality": 1.0, "length": 10}, "so_11703553_11703570_1": {"section_id": 314, "quality": 1.0, "length": 5}}, "n4659": {"so_11703553_11703570_2": {"section_id": 332, "quality": 1.0, "length": 5}, "so_11703553_11703570_0": {"section_id": 332, "quality": 1.0, "length": 10}, "so_11703553_11703570_1": {"section_id": 332, "quality": 1.0, "length": 5}}}});