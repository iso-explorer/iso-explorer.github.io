post_cb({"11703840": {"ParentId": "11703643", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>In C++11 section 17.6.3.5 Allocator requirements [allocator.requirements] specifies the requirements for conforming allocators.  Among the requirements are:</p>\n<pre><code>X                    an Allocator class for type T\n...\na, a1, a2            values of type X&amp;\n...\na1 == a2             bool          returns true only if storage\n                                   allocated from each can be\n                                   deallocated via the other.\n                                   operator== shall be reflexive,\n                                   symmetric, and transitive, and\n                                   shall not exit via an exception.\n...\nX a1(a);                           Shall not exit via an exception.\n                                   post: a1 == a\n</code></pre>\n<p>I.e. when you copy an allocator, the two copies are required to be able to delete each other's pointers.</p>\n<p>Conceivably one could put internal buffers into allocators, but copies would have to keep a list of other's buffers.  Or perhaps an allocator could have an invariant that deallocation is always a no-op because the pointer always comes from an internal buffer (either from your own, or from some other copy).</p>\n<p>But whatever the scheme, copies must be \"cross-compatible\".</p>\n<p><strong>Update</strong></p>\n<p>Here is a C++11 conforming allocator that does the \"short string optimization\".  To make it C++11 conforming, I had to put the \"internal\" buffer external to the allocator so that copies are equal:</p>\n<pre><code>#include &lt;cstddef&gt;\n\ntemplate &lt;std::size_t N&gt;\nclass arena\n{\n    static const std::size_t alignment = 16;\n    alignas(alignment) char buf_[N];\n    char* ptr_;\n\n    std::size_t \n    align_up(std::size_t n) {return n + (alignment-1) &amp; ~(alignment-1);}\n\npublic:\n    arena() : ptr_(buf_) {}\n    arena(const arena&amp;) = delete;\n    arena&amp; operator=(const arena&amp;) = delete;\n\n    char* allocate(std::size_t n)\n    {\n        n = align_up(n);\n        if (buf_ + N - ptr_ &gt;= n)\n        {\n            char* r = ptr_;\n            ptr_ += n;\n            return r;\n        }\n        return static_cast&lt;char*&gt;(::operator new(n));\n    }\n    void deallocate(char* p, std::size_t n)\n    {\n        n = align_up(n);\n        if (buf_ &lt;= p &amp;&amp; p &lt; buf_ + N)\n        {\n            if (p + n == ptr_)\n                ptr_ = p;\n        }\n        else\n            ::operator delete(p);\n    }\n};\n\ntemplate &lt;class T, std::size_t N&gt;\nclass stack_allocator\n{\n    arena&lt;N&gt;&amp; a_;\npublic:\n    typedef T value_type;\n\npublic:\n    template &lt;class U&gt; struct rebind {typedef stack_allocator&lt;U, N&gt; other;};\n\n    explicit stack_allocator(arena&lt;N&gt;&amp; a) : a_(a) {}\n    template &lt;class U&gt;\n        stack_allocator(const stack_allocator&lt;U, N&gt;&amp; a)\n            : a_(a.a_) {}\n    stack_allocator(const stack_allocator&amp;) = default;\n    stack_allocator&amp; operator=(const stack_allocator&amp;) = delete;\n\n    T* allocate(std::size_t n)\n    {\n        return reinterpret_cast&lt;T*&gt;(a_.allocate(n*sizeof(T)));\n    }\n    void deallocate(T* p, std::size_t n)\n    {\n        a_.deallocate(reinterpret_cast&lt;char*&gt;(p), n*sizeof(T));\n    }\n\n    template &lt;class T1, std::size_t N1, class U, std::size_t M&gt;\n    friend\n    bool\n    operator==(const stack_allocator&lt;T1, N1&gt;&amp; x, const stack_allocator&lt;U, M&gt;&amp; y);\n\n    template &lt;class U, std::size_t M&gt; friend class stack_allocator;\n};\n\ntemplate &lt;class T, std::size_t N, class U, std::size_t M&gt;\nbool\noperator==(const stack_allocator&lt;T, N&gt;&amp; x, const stack_allocator&lt;U, M&gt;&amp; y)\n{\n    return N == M &amp;&amp; &amp;x.a_ == &amp;y.a_;\n}\n\ntemplate &lt;class T, std::size_t N, class U, std::size_t M&gt;\nbool\noperator!=(const stack_allocator&lt;T, N&gt;&amp; x, const stack_allocator&lt;U, M&gt;&amp; y)\n{\n    return !(x == y);\n}\n</code></pre>\n<p>It could be used like this:</p>\n<pre><code>#include &lt;vector&gt;\n\ntemplate &lt;class T, std::size_t N&gt; using A = stack_allocator&lt;T, N&gt;;\ntemplate &lt;class T, std::size_t N&gt; using Vector = std::vector&lt;T, stack_allocator&lt;T, N&gt;&gt;;\n\nint main()\n{\n    const std::size_t N = 1024;\n    arena&lt;N&gt; a;\n    Vector&lt;int, N&gt; v{A&lt;int, N&gt;(a)};\n    v.reserve(100);\n    for (int i = 0; i &lt; 100; ++i)\n        v.push_back(i);\n    Vector&lt;int, N&gt; v2 = std::move(v);\n    v = v2;\n}\n</code></pre>\n<p>All allocations for the above problem are drawn from the local <code>arena</code> which is 1 Kb in size.  You should be able to pass this allocator around by value or by reference.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2012-07-29T00:47:24.150", "Id": "11703840", "Score": "9", "CreationDate": "2012-07-28T19:06:11.193", "LastActivityDate": "2012-07-29T00:47:24.150"}, "11703643": {"CommentCount": "2", "AcceptedAnswerId": "11703840", "CreationDate": "2012-07-28T18:34:02.847", "LastActivityDate": "2012-07-29T00:47:24.150", "PostTypeId": "1", "ViewCount": "1849", "FavoriteCount": "3", "Title": "Can I assume allocators don't hold their memory pool directly (and can therefore be copied)?", "Id": "11703643", "Score": "5", "Body": "<p>I'm writing a container and would like to permit the user to use custom allocators, but I can't tell if I should pass allocators around by reference or by value.</p>\n<p>Is it guaranteed (or at least, a reasonable assumption to make) that an allocator object will <em>not</em> contain its memory pool directly, and hence it would be OK to copy an allocator and expect the memory pools of the allocators to be cross-compatible? Or do I always need to pass allocators by reference?  </p>\n<p>(I have found that passing by reference harms performance by a factor of &gt; 2 because the compiler starts worrying about aliasing, so it makes a whether or not I can rely on this assumption.)</p>\n", "Tags": "<c++><c++11><allocator><stateful>", "OwnerUserId": "541686", "AnswerCount": "2"}, "11703670": {"ParentId": "11703643", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The old C++ standard makes requirements for a standard-compliant allocator: These requirements include that if you have <code>Alloc&lt;T&gt; a, b</code>, then <code>a == b</code>, and you can use <code>b</code> to deallocate things that were allocated with <code>a</code>. Allocators are fundamentally <em>stateless</em>.</p>\n<hr>\n<p>In C++11, the situation got a lot more involved, as there is now support for <em>stateful</em> allocators. As you copy and move objects around, there are specific rules whether one container can be copied or moved from another container if the allocators differ, and how the allocators get copied or moved.</p>\n<p>Just to answer your question first: No, you can definitely <em>not</em> assume that it makes sense to copy your allocator around, and your allocator may not even be copyable.</p>\n<p>Here is 23.2.1/7 on this subject:</p>\n<blockquote>\n<p id=\"so_11703643_11703670_0\">Unless otherwise specified, all containers defined in this clause obtain memory using an allocator (see 17.6.3.5). Copy constructors for these container types obtain an allocator by calling <code>allocator_traits&lt;allocator_-type&gt;::select_on_container_copy_construction</code> on their first parameters. Move constructors obtain an allocator by move construction from the allocator belonging to the container being moved. Such move construction of the allocator shall not exit via an exception. All other constructors for these container types take an <code>Allocator&amp;</code> argument (17.6.3.5), an allocator whose value type is the same as the container\u2019s value type. [Note: If an invocation of a constructor uses the default value of an optional allocator argument, then the Allocator type must support value initialization. \u2014end note] A copy of this allocator is used for any memory allocation performed, by these constructors and by all member functions, during the lifetime of each container object or until the allocator is replaced. The allocator may be replaced only via assignment or\n  swap(). Allocator replacement is performed by copy assignment, move assignment, or swapping of the allocator only if  <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</code>,\n  <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</code>, or <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> is true within the implementation of the corresponding container operation. The behavior of a call to a container\u2019s swap function is undefined unless the objects being swapped have allocators that compare equal or <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code> is true. In all container types defined in this Clause, the member <code>get_allocator()</code> returns a copy of the allocator used to construct the container or, if that allocator has been replaced, a copy of the most recent replacement.</p>\n</blockquote>\n<p>See also the documentation of <a href=\"http://en.cppreference.com/w/cpp/memory/allocator_traits\" rel=\"noreferrer\"><code>std::allocator_traits</code></a> for a synopsis.</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-07-28T18:45:18.397", "Id": "11703670", "Score": "11", "CreationDate": "2012-07-28T18:38:31.060", "LastActivityDate": "2012-07-28T18:45:18.397"}, "bq_ids": {"n4140": {"so_11703643_11703670_0": {"section_id": 709, "quality": 0.8636363636363636, "length": 133}}, "n3337": {"so_11703643_11703670_0": {"section_id": 698, "quality": 0.9415584415584416, "length": 145}}, "n4659": {"so_11703643_11703670_0": {"section_id": 738, "quality": 0.7532467532467533, "length": 116}}}});