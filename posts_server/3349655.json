post_cb({"3349655": {"ViewCount": "800", "Body": "<p>Is this just an implementation side effect (red-black tree) or the order is guaranteed by the c++ standard?</p>\n", "AcceptedAnswerId": "3349714", "Title": "Are the elements in a std::map guaranteed to be ordered?", "CreationDate": "2010-07-28T03:18:02.060", "Id": "3349655", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-07-28T03:29:25.340", "LastEditorUserId": "151292", "LastActivityDate": "2010-07-28T03:45:21.053", "Score": "5", "OwnerUserId": "396383", "Tags": "<c++><stl>", "AnswerCount": "4"}, "3349661": {"Id": "3349661", "PostTypeId": "2", "Body": "<p>Guaranteed. If you want something that's not constrained by this try boost::unordered_map&lt;&gt;</p>\n", "LastActivityDate": "2010-07-28T03:19:53.183", "Score": "0", "CreationDate": "2010-07-28T03:19:53.183", "ParentId": "3349655", "CommentCount": "1", "OwnerUserId": "315016"}, "bq_ids": {"n4140": {"so_3349655_3349773_0": {"length": 21, "quality": 0.6, "section_id": 738}, "so_3349655_3349714_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 746}}, "n3337": {"so_3349655_3349773_0": {"length": 21, "quality": 0.6, "section_id": 727}, "so_3349655_3349714_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 735}}, "n4659": {"so_3349655_3349773_0": {"length": 21, "quality": 0.6, "section_id": 796}, "so_3349655_3349714_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 805}}}, "3349773": {"Id": "3349773", "PostTypeId": "2", "Body": "<p>\u00a723.1.2/2:</p>\n<blockquote>\n<p id=\"so_3349655_3349773_0\">Each associative container is\n  parameterized on <code>Key</code> and an ordering\n  relation <code>Compare</code> that induces a strict\n  weak ordering (25.3) on elements of\n  <code>Key</code>. \u2026 The object of type <code>Compare</code> is\n  called the comparison object of a\n  container. This comparison object\n  may be a pointer to function or an\n  object of a type with an appropriate\n  function call operator.</p>\n</blockquote>\n<p>The default <code>Compare</code> object is the less-than function <code>std::less&lt;Key&gt;</code>.</p>\n<p>The ordering is a property of the function. It's a requirement, not a side effect.</p>\n<p><em>Sorting</em> the objects is a side effect. 23.1.2/10 and 23.1.2/9 (quoted by James) guarantee that map/set and multimap/multiset have increasing/non-decreasing keys, respectively, over the sequence from <code>begin</code> to <code>end</code>.</p>\n", "LastActivityDate": "2010-07-28T03:45:21.053", "Score": "4", "CreationDate": "2010-07-28T03:45:21.053", "ParentId": "3349655", "CommentCount": "0", "OwnerUserId": "153285"}, "3349714": {"Id": "3349714", "PostTypeId": "2", "Body": "<p>Ordered iteration is not an implementation detail; it is guaranteed by the C++ standard.  It is a fundamental property of all associative containers (C++03 \u00a723.1.2/9):</p>\n<blockquote>\n<p id=\"so_3349655_3349714_0\">The fundamental property of iterators of associative containers is that they iterate through the containers in the non-descending order of keys where non-descending is defined by the comparison that was used to construct them.  For any two dereferenceable iterators <code>i</code> and <code>j</code> such that distance from <code>i</code> to <code>j</code> is positive,</p>\n<pre><code>    value_comp(*j, *i) == false\n</code></pre>\n</blockquote>\n<p><code>value_comp</code> is the comparator with which the map was constructed (by default, it is <code>std::less&lt;T&gt;</code>).</p>\n", "LastActivityDate": "2010-07-28T03:28:58.570", "Score": "11", "CreationDate": "2010-07-28T03:28:58.570", "ParentId": "3349655", "CommentCount": "2", "OwnerUserId": "151292"}, "3349659": {"Id": "3349659", "PostTypeId": "2", "Body": "<p>It's guaranteed by the c++ standard.</p>\n", "LastActivityDate": "2010-07-28T03:18:55.743", "Score": "2", "CreationDate": "2010-07-28T03:18:55.743", "ParentId": "3349655", "CommentCount": "1", "OwnerUserId": "13029"}});