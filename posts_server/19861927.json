post_cb({"19861927": {"CommentCount": "5", "ViewCount": "2044", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2013-11-08T14:52:47.797", "LastActivityDate": "2013-11-15T18:26:38.120", "Title": "Why is this undefined behaviour?", "AcceptedAnswerId": "19862240", "LastEditDate": "2013-11-15T18:26:38.120", "Id": "19861927", "Score": "2", "Body": "<p>Here's the sample code:</p>\n<pre><code>X * makeX(int index) { return new X(index); }\nstruct Tmp {\n    mutable int count;\n    Tmp() : count(0) {}\n    const X ** getX() const { \n        static const X* x[] = { makeX(count++), makeX(count++) };\n        return x; \n    }\n};\n</code></pre>\n<p>This reports Undefined Behavior on CLang build 500 in the static array construction.\nFor sake of simplification for this post, the count is not static, but it does not change anything. The error I am receiving is as follows:</p>\n<blockquote>\n<p id=\"so_19861927_19861927_0\">test.cpp:8:44: warning: multiple unsequenced modifications to 'count' [-Wunsequenced]</p>\n</blockquote>\n", "Tags": "<c++><clang><undefined-behavior>", "OwnerUserId": "1469714", "AnswerCount": "3"}, "19862240": {"ParentId": "19861927", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><b>Update 2</b></p>\n<p>So after some research I realized this was actually <em>well defined</em> although the evaluation order is <em>unspecified</em>. It was a pretty interesting putting the pieces together and although there is a more general question covering this for <a href=\"https://stackoverflow.com/questions/14442894/are-multiple-mutations-within-initializer-lists-undefined-behavior?lq=1\">the C++11 case</a> there was not a general question covering the pre <em>C++11</em> case so I ended up creating a self answer question, <a href=\"https://stackoverflow.com/questions/19881803/are-multiple-mutations-of-the-same-variable-within-initializer-lists-undefined-b\">Are multiple mutations of the same variable within initializer lists undefined behavior pre C++11</a> that covers all the details.</p>\n<p>Basically, the instinct when seeing <code>makeX(count++), makeX(count++)</code> is to see the whole thing as a full-expression but it is not and therefore each intializer has a <em>sequence point</em>.</p>\n<p><b>Update</b></p>\n<p>As James points out it may not be <em>undefined</em> pre-<em>C++11</em>, which would seem to rely on interpreting the initialization of each element as a <em>full expression</em> but it is not clear you can definitely make that claim.</p>\n<p><b>Original</b></p>\n<p>Pre-<em>C++11</em> it is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a> to modify a variable more than once within a sequence point, we can see that by looking at the relevant section in an <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow noreferrer\">older draft standard</a> would be section <code>5</code> <em>Expressions</em> paragraph <em>4</em> which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19861927_19862240_0\">[...]<strong>Between the previous and next sequence point a scalar object shall have its stored value modified at most once</strong> by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full expression; <strong>otherwise the behavior is undefined.</strong></p>\n</blockquote>\n<p>In the <em>C++11</em> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft standard</a> this changes and to the following wording from section <code>1.9</code> <em>Program execution</em> paragraph <em>15</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_19861927_19862240_1\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...] <strong>If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</strong></p>\n</blockquote>\n<p>and we can see that for initializer lists from section <code>8.5.4</code> <em>List-initialization</em> paragraph <em>4</em> says:</p>\n<blockquote>\n<p id=\"so_19861927_19862240_2\">Within the initializer-list of a braced-init-list, the initializer-clauses, including any that result from pack expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and side effect associated with a given initializer-clause is sequenced before every value computation and side effect associated with any initializer-clause that follows it in the comma-separated list of the initializer-list.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:48.963", "Id": "19862240", "Score": "2", "CreationDate": "2013-11-08T15:08:56.480", "LastActivityDate": "2013-11-15T04:12:43.043"}, "19862058": {"ParentId": "19861927", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In C++11, this is fine; each clause of an initialiser list is sequenced before the next one, so the evaluation is well-defined.</p>\n<p>Historically, the clauses might have been unsequenced, so the two unsequenced modifications of <code>count</code> would give undefined behaviour. </p>\n<p><sub>(Although, as noted in the comments, it might have been well-defined even then - you can probably interpret the standard as implying that each clause is a <em>full-expression</em>, and there's a seqeuence point at the end of each full-expression. I'll leave it to historians to debate the finer points of obsolete languages.)</sub></p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-11-08T16:35:52.997", "Id": "19862058", "Score": "10", "CreationDate": "2013-11-08T14:59:13.097", "LastActivityDate": "2013-11-08T16:35:52.997"}, "19861991": {"ParentId": "19861927", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Because it this case, the <code>,</code> is NOT a sequence point, but acts more like a delimiter in the initialization of the elements of the array.</p>\n<p>In other words, you're modifying the same variable twice in a statement without sequence points (between the modifications).</p>\n<hr>\n<p>EDIT: thanks to @MikeSeymour: this is an issue in <code>C++03</code> an before. It seems like in <code>C++11</code>, the order of evaluation <em>is defined</em> for this case.</p>\n</hr>", "OwnerUserId": "435800", "LastEditorUserId": "435800", "LastEditDate": "2013-11-08T15:02:16.900", "Id": "19861991", "Score": "2", "CreationDate": "2013-11-08T14:56:13.220", "LastActivityDate": "2013-11-08T15:02:16.900"}, "bq_ids": {"n4140": {"so_19861927_19862240_1": {"section_id": 5811, "quality": 1.0, "length": 33}, "so_19861927_19862240_2": {"section_id": 3326, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_19861927_19862240_1": {"section_id": 5584, "quality": 1.0, "length": 33}, "so_19861927_19862240_2": {"section_id": 3196, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_19861927_19862240_1": {"section_id": 7272, "quality": 0.8181818181818182, "length": 27}, "so_19861927_19862240_2": {"section_id": 4092, "quality": 0.9428571428571428, "length": 33}}}});