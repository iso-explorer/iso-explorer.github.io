post_cb({"45091979": {"ParentId": "45069219", "CommentCount": "3", "Body": "<p>There's nothing wrong with seeding by using time, assuming you don't need it to be secure (and you didn't say this was necessary).  The insight is that you can use hashing to fix the non-randomness.  I've found this works adequately in all cases, including and in-particular for heavy Monte Carlo simulations.</p>\n<p>One nice feature of this approach is that it generalizes to initialization from other not-really-random sets of seeds.  For example, if you want each thread to have its own RNG (for threadsafety), you can just initialize based on hashed thread ID.</p>\n<p>The following is a <a href=\"http://sscce.org/\" rel=\"nofollow noreferrer\">SSCCE</a>, distilled from <a href=\"https://geometrian.com/programming/projects/index.php?project=libash\" rel=\"nofollow noreferrer\">my codebase</a> (for simplicity; some OO support structures elided):</p>\n<pre><code>#include &lt;cstdint&gt; //`uint32_t`\n#include &lt;functional&gt; //`std::hash`\n#include &lt;random&gt; //`std::mt19937`\n#include &lt;iostream&gt; //`std::cout`\n\nstatic std::mt19937 rng;\n\nstatic void seed(uint32_t seed) {\n    rng.seed(static_cast&lt;std::mt19937::result_type&gt;(seed));\n}\nstatic void seed() {\n    uint32_t t = static_cast&lt;uint32_t&gt;( time(nullptr) );\n    std::hash&lt;uint32_t&gt; hasher; size_t hashed=hasher(t);\n    seed( static_cast&lt;uint32_t&gt;(hashed) );\n}\n\nint main(int /*argc*/, char* /*argv*/[]) {\n    seed();\n    std::uniform_int_distribution&lt;&gt; dis(0, 5);\n    std::cout &lt;&lt; dis(rng);\n}\n</code></pre>\n", "OwnerUserId": "688624", "PostTypeId": "2", "Id": "45091979", "Score": "2", "CreationDate": "2017-07-13T22:40:03.113", "LastActivityDate": "2017-07-13T22:40:03.113"}, "45069584": {"ParentId": "45069219", "CommentCount": "4", "Body": "<p>A given platform might have a source of entropy, such as <code>/dev/random</code>.  Nanoseconds since the Epoch with <code>std::chrono::high_resolution_clock::now()</code> is probably the best seed in the Standard Library.</p>\n<p>I previously have used something like <code>(uint64_t)( time(NULL)*CLOCKS_PER_SEC + clock() )</code> to get more bits of entropy for applications that aren\u2019t security-critical.</p>\n", "OwnerUserId": "4474419", "PostTypeId": "2", "Id": "45069584", "Score": "-2", "CreationDate": "2017-07-13T00:26:28.823", "LastActivityDate": "2017-07-13T00:26:28.823"}, "45069347": {"ParentId": "45069219", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>The implementation I am working on takes advantage of the <code>state_size</code> property of the <code>mt19937</code> PRNG to decide how many seeds to provide on initialization:</p>\n<pre><code>using Generator = std::mt19937;\n\ninline\nauto const&amp; random_data()\n{\n    thread_local static std::array&lt;typename Generator::result_type, Generator::state_size&gt; data;\n    thread_local static std::random_device rd;\n\n    std::generate(std::begin(data), std::end(data), std::ref(rd));\n\n    return data;\n}\n\ninline\nGenerator&amp; random_generator()\n{\n    auto const&amp; data = random_data();\n\n    thread_local static std::seed_seq seeds(std::begin(data), std::end(data));\n    thread_local static Generator gen{seeds};\n\n    return gen;\n}\n\ntemplate&lt;typename Number&gt;\nNumber random_number(Number from, Number to)\n{\n    using Distribution = typename std::conditional\n    &lt;\n        std::is_integral&lt;Number&gt;::value,\n        std::uniform_int_distribution&lt;Number&gt;,\n        std::uniform_real_distribution&lt;Number&gt;\n    &gt;::type;\n\n    thread_local static Distribution dist;\n\n    return dist(random_generator(), typename Distribution::param_type{from, to});\n}\n</code></pre>\n<p>I think there is room for improvement because <code>std::random_device::result_type</code> could differ from <code>std::mt19937::result_type</code> in size and range so that should really be taken into account.</p>\n<p><strong>A note about <a href=\"http://en.cppreference.com/w/cpp/numeric/random/random_device\" rel=\"nofollow noreferrer\">std::random_device</a>.</strong></p>\n<p>According to the <code>C++11(/14/17)</code> standard(s):</p>\n<blockquote>\n<p id=\"so_45069219_45069347_0\"><strong>26.5.6</strong> Class random_device <strong>[</strong> rand.device <strong>]</strong></p>\n<p id=\"so_45069219_45069347_1\"><strong>2</strong> If implementation limitations prevent generating non-deterministic random numbers, the implementation may employ a random number engine.</p>\n</blockquote>\n<p>This means the implementation may only generate <em>deterministic</em> values if it is prevented from generating <em>non-deterministic</em> ones by some limitation.</p>\n<p>The <code>MinGW</code> compiler on <code>Windows</code> famously does not provide <em>non-deterministic</em> values from its <code>std::random_device</code>, despite them being easily available from the Operating System. So I consider this a bug and not likely a common occurrence across implementations and platforms. </p>\n", "OwnerUserId": "3807729", "LastEditorUserId": "5879503", "LastEditDate": "2017-07-13T19:31:48.573", "Id": "45069347", "Score": "5", "CreationDate": "2017-07-12T23:58:42.480", "LastActivityDate": "2017-07-13T19:31:48.573"}, "45069285": {"ParentId": "45069219", "CommentCount": "13", "Body": "<p>In a sense, this can't be done portably. That is, one can conceive a valid fully-deterministic platform running C++ (say, a simulator which steps the machine clock deterministically, and with \"determinized\" I/O) in which there is no source of randomness to seed a PRNG.</p>\n", "OwnerUserId": "1593077", "PostTypeId": "2", "Id": "45069285", "Score": "22", "CreationDate": "2017-07-12T23:51:56.520", "LastActivityDate": "2017-07-12T23:51:56.520"}, "45078542": {"ParentId": "45069219", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You can use a <code>std::seed_seq</code> and fill it to at least the requires state size for the generator using Alexander Huszagh's method of getting the entropy:</p>\n<pre><code>size_t sysrandom(void* dst, size_t dstlen); //from Alexander Huszagh answer above\n\nvoid foo(){\n\n    std::uint_fast32_t[std::mt19937::state_size] state;\n    sysrandom(state, sizeof(state));\n    std::seed_seq s(std::begin(state), std::end(state));\n\n    std::mt19937 g;\n    g.seed(s);\n}\n</code></pre>\n<p>If there was a proper way to fill or create a <a href=\"http://en.cppreference.com/w/cpp/concept/SeedSequence\" rel=\"noreferrer\">SeedSequence</a> from a <a href=\"http://en.cppreference.com/w/cpp/concept/UniformRandomBitGenerator\" rel=\"noreferrer\">UniformRandomBitGenerator</a> in the standard library using <code>std::random_device</code> for seeding properly would be much simpler.</p>\n", "OwnerUserId": "731620", "LastEditorUserId": "731620", "LastEditDate": "2017-07-13T11:02:09.157", "Id": "45078542", "Score": "10", "CreationDate": "2017-07-13T10:52:51.713", "LastActivityDate": "2017-07-13T11:02:09.157"}, "45070076": {"ParentId": "45069219", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Here's my own stab at the question:</p>\n<pre><code>#include &lt;random&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nuint32_t LilEntropy(){\n  //Gather many potential forms of entropy and XOR them\n  const  uint32_t my_seed = 1273498732; //Change during distribution\n  static uint32_t i = 0;        \n  static std::random_device rd; \n  const auto hrclock = std::chrono::high_resolution_clock::now().time_since_epoch().count();\n  const auto sclock  = std::chrono::system_clock::now().time_since_epoch().count();\n  auto *heap         = malloc(1);\n  const auto mash = my_seed + rd() + hrclock + sclock + (i++) +\n    reinterpret_cast&lt;intptr_t&gt;(heap)    + reinterpret_cast&lt;intptr_t&gt;(&amp;hrclock) +\n    reinterpret_cast&lt;intptr_t&gt;(&amp;i)      + reinterpret_cast&lt;intptr_t&gt;(&amp;malloc)  +\n    reinterpret_cast&lt;intptr_t&gt;(&amp;LilEntropy);\n  free(heap);\n  return mash;\n}\n\n//Fully seed the mt19937 engine using as much entropy as we can get our\n//hands on\nvoid SeedGenerator(std::mt19937 &amp;mt){\n  std::uint_least32_t seed_data[std::mt19937::state_size];\n  std::generate_n(seed_data, std::mt19937::state_size, std::ref(LilEntropy));\n  std::seed_seq q(std::begin(seed_data), std::end(seed_data));\n  mt.seed(q);\n}\n\nint main(){\n  std::mt19937 mt;\n  SeedGenerator(mt);\n\n  for(int i=0;i&lt;100;i++)\n    std::cout&lt;&lt;mt()&lt;&lt;std::endl;\n}\n</code></pre>\n<p>The idea here is to use XOR to combine many potential sources of entropy (fast time, slow time, <code>std::random-device</code>, static variable locations, heap locations, function locations, library locations, program-specific values) to make a best-effort attempt at initializing the mt19937. As long as at least once source is \"good\", the result will be at least that \"good\".</p>\n<p>This answer is not as short as would be preferable and may contain one or more mistakes of logic. So I'm considering it a work in progress. Please comment if you have feedback.</p>\n", "OwnerUserId": "752843", "LastEditorUserId": "752843", "LastEditDate": "2017-07-13T20:00:07.617", "Id": "45070076", "Score": "0", "CreationDate": "2017-07-13T01:36:41.153", "LastActivityDate": "2017-07-13T20:00:07.617"}, "45069219": {"CommentCount": "21", "ViewCount": "4129", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-07-12T23:44:18.577", "LastActivityDate": "2017-07-14T19:07:11.660", "Title": "How to succinctly, portably, and thoroughly seed the mt19937 PRNG?", "FavoriteCount": "27", "LastEditDate": "2017-07-13T15:19:35.287", "Id": "45069219", "Score": "92", "Body": "<p>I seem to see many answers in which someone suggests using <code>&lt;random&gt;</code> to generate random numbers, usually along with code like this:</p>\n<pre><code>std::random_device rd;  \nstd::mt19937 gen(rd());\nstd::uniform_int_distribution&lt;&gt; dis(0, 5);\ndis(gen);\n</code></pre>\n<p>Usually this replaces some kind of \"unholy abomination\" such as:</p>\n<pre><code>srand(time(NULL));\nrand()%6;\n</code></pre>\n<p>We might <a href=\"https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful\" rel=\"noreferrer\">criticize</a> the old way by arguing that <code>time(NULL)</code> provides low entropy, <code>time(NULL)</code> is predictable, and the end result is non-uniform.</p>\n<p>But all of that is true of the new way: it just has a shinier veneer. </p>\n<ul>\n<li><p><code>rd()</code> returns a single <code>unsigned int</code>. This has at least 16 bits and probably 32. That's not enough to seed MT's 19937 bits of state.</p></li>\n<li><p>Using <code>std::mt19937 gen(rd());gen()</code> (seeding with 32 bits and looking at the first output) doesn't give a good output distribution. 7 and 13 can never be the first output. Two seeds produce 0. Twelve seeds produce 1226181350. (<a href=\"http://www.pcg-random.org/posts/cpp-seeding-surprises.html\" rel=\"noreferrer\">Link</a>)</p></li>\n<li><p><code>std::random_device</code> can be, and sometimes is, implemented as a simple PRNG with a fixed seed. It might therefore produce the same sequence on every run. (<a href=\"https://stackoverflow.com/questions/18880654/why-do-i-get-the-same-sequence-for-every-run-with-stdrandom-device-with-mingw\">Link</a>) This is even worse than <code>time(NULL)</code>.</p></li>\n</ul>\n<p>Worse yet, it is very easy to copy and paste the foregoing code snippets, despite the problems they contain. Some solutions to the this require acquiring <a href=\"http://www.pcg-random.org/\" rel=\"noreferrer\">largish</a> <a href=\"http://www.boost.org/doc/libs/1_64_0/doc/html/boost_random.html\" rel=\"noreferrer\">libraries</a> which may not be suitable to everyone.</p>\n<p>In light of this, my question is <strong>How can one succinctly, portably, and thoroughly seed the mt19937 PRNG in C++?</strong></p>\n<p>Given the issues above, a good answer:</p>\n<ul>\n<li>Must fully seed the mt19937/mt19937_64.</li>\n<li>Cannot rely solely on <code>std::random_device</code> or <code>time(NULL)</code> as a source of entropy.</li>\n<li>Should not rely on Boost or other libaries.</li>\n<li>Should fit in a small number of lines such that it would look nice copy-pasted into an answer.</li>\n</ul>\n<p><strong>Thoughts</strong></p>\n<ul>\n<li><p>My current thought is that outputs from <code>std::random_device</code> can be mashed up (perhaps via XOR) with <code>time(NULL)</code>, values derived from <a href=\"https://en.wikipedia.org/wiki/Address_space_layout_randomization\" rel=\"noreferrer\">address space randomization</a>, and a hard-coded constant (which could be set during distribution) to get a best-effort shot at entropy.</p></li>\n<li><p><code>std::random_device::entropy()</code> <a href=\"https://stackoverflow.com/questions/28390843/how-to-find-the-true-entropy-of-stdrandom-device\">does not</a> give a good indication of what <code>std::random_device</code> might or might not do.</p></li>\n</ul>\n", "Tags": "<c++><c++11><random>", "OwnerUserId": "752843", "AnswerCount": "7"}, "45069417": {"ParentId": "45069219", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>I would argue the greatest flaw with <code>std::random_device</code> is the that it is allowed a deterministic fallback if no CSPRNG is available. This alone is a good reason not to seed a PRNG using <code>std::random_device</code>, since the bytes produced may be deterministic.  It unfortunately doesn't provide an API to find out when this happens, or to request failure instead of low-quality random numbers.</p>\n<p>That is, there is no completely <strong>portable</strong> solution: however, there is a decent, minimal approach. You can use a minimal wrapper around a CSPRNG (defined as <code>sysrandom</code> below) to seed the PRNG.</p>\n<h2>Windows</h2>\n<hr>\n<p>You can rely on <code>CryptGenRandom</code>, a CSPRNG. For example, you may use the following code:</p>\n<pre><code>bool acquire_context(HCRYPTPROV *ctx)\n{\n    if (!CryptAcquireContext(ctx, nullptr, nullptr, PROV_RSA_FULL, 0)) {\n        return CryptAcquireContext(ctx, nullptr, nullptr, PROV_RSA_FULL, CRYPT_NEWKEYSET);\n    }\n    return true;\n}\n\n\nsize_t sysrandom(void* dst, size_t dstlen)\n{\n    HCRYPTPROV ctx;\n    if (!acquire_context(&amp;ctx)) {\n        throw std::runtime_error(\"Unable to initialize Win32 crypt library.\");\n    }\n\n    BYTE* buffer = reinterpret_cast&lt;BYTE*&gt;(dst);\n    if(!CryptGenRandom(ctx, dstlen, buffer)) {\n        throw std::runtime_error(\"Unable to generate random bytes.\");\n    }\n\n    if (!CryptReleaseContext(ctx, 0)) {\n        throw std::runtime_error(\"Unable to release Win32 crypt library.\");\n    }\n\n    return dstlen;\n}\n</code></pre>\n<h2>Unix-Like</h2>\n<hr>\n<p>On many Unix-like systems, you should use <a href=\"http://www.2uo.de/myths-about-urandom/\" rel=\"noreferrer\">/dev/urandom</a> when possible (although this is not guaranteed to exist on POSIX-compliant systems).</p>\n<pre><code>size_t sysrandom(void* dst, size_t dstlen)\n{\n    char* buffer = reinterpret_cast&lt;char*&gt;(dst);\n    std::ifstream stream(\"/dev/urandom\", std::ios_base::binary | std::ios_base::in);\n    stream.read(buffer, dstlen);\n\n    return dstlen;\n}\n</code></pre>\n<h2>Other</h2>\n<hr>\n<p>If no CSPRNG is available, you might choose to rely on <code>std::random_device</code>. However, I would avoid this if possible, since various compilers (most notably, MinGW) implement it with as a <a href=\"https://stackoverflow.com/questions/18880654/why-do-i-get-the-same-sequence-for-every-run-with-stdrandom-device-with-mingw\">PRNG</a> (in fact, producing the same sequence every time to alert humans that it's not properly random).</p>\n<h2>Seeding</h2>\n<hr>\n<p>Now that we have our pieces with minimal overhead, we can generate the desired bits of random entropy to seed our PRNG. The example uses (an obviously insufficient) 32-bits to seed the PRNG, and you should increase this value (which is dependent on your CSPRNG).</p>\n<pre><code>std::uint_least32_t seed;    \nsysrandom(&amp;seed, sizeof(seed));\nstd::mt19937 gen(seed);\n</code></pre>\n<h2>Comparison To Boost</h2>\n<hr>\n<p>We can see parallels to boost::random_device (a true CSPRNG) after a quick look at the <a href=\"https://github.com/boostorg/random/blob/develop/src/random_device.cpp\" rel=\"noreferrer\">source code</a>. Boost uses <code>MS_DEF_PROV</code> on Windows, which is the provider type for <code>PROV_RSA_FULL</code>. The only thing missing would be verifying the cryptographic context, which can be done with <code>CRYPT_VERIFYCONTEXT</code>. On *Nix, Boost uses <code>/dev/urandom</code>. IE, this solution is portable, well-tested, and easy-to-use.</p>\n<h2>Linux Specialization</h2>\n<hr>\n<p>If you're willing to sacrifice succinctness for security, <a href=\"http://man7.org/linux/man-pages/man2/getrandom.2.html\" rel=\"noreferrer\"><code>getrandom</code></a> is an excellent choice on Linux 3.17 and above, and on recent Solaris. <code>getrandom</code> behaves identically to <code>/dev/urandom</code>, except it blocks if the kernel hasn't initialized its CSPRNG yet after booting.  The following snippet detects if Linux <code>getrandom</code> is available, and if not falls back to <code>/dev/urandom</code>.</p>\n<pre><code>#if defined(__linux__) || defined(linux) || defined(__linux)\n#   // Check the kernel version. `getrandom` is only Linux 3.17 and above.\n#   include &lt;linux/version.h&gt;\n#   if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3,17,0)\n#       define HAVE_GETRANDOM\n#   endif\n#endif\n\n// also requires glibc 2.25 for the libc wrapper\n#if defined(HAVE_GETRANDOM)\n#   include &lt;sys/syscall.h&gt;\n#   include &lt;linux/random.h&gt;\n\nsize_t sysrandom(void* dst, size_t dstlen)\n{\n    int bytes = syscall(SYS_getrandom, dst, dstlen, 0);\n    if (bytes != dstlen) {\n        throw std::runtime_error(\"Unable to read N bytes from CSPRNG.\");\n    }\n\n    return dstlen;\n}\n\n#elif defined(_WIN32)\n\n// Windows sysrandom here.\n\n#else\n\n// POSIX sysrandom here.\n\n#endif\n</code></pre>\n<h2>OpenBSD</h2>\n<hr>\n<p>There is one final caveat: modern OpenBSD does not have <code>/dev/urandom</code>. You should use <a href=\"https://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/getentropy.2\" rel=\"noreferrer\">getentropy</a> instead.</p>\n<pre><code>#if defined(__OpenBSD__)\n#   define HAVE_GETENTROPY\n#endif\n\n#if defined(HAVE_GETENTROPY)\n#   include &lt;unistd.h&gt;\n\nsize_t sysrandom(void* dst, size_t dstlen)\n{\n    int bytes = getentropy(dst, dstlen);\n    if (bytes != dstlen) {\n        throw std::runtime_error(\"Unable to read N bytes from CSPRNG.\");\n    }\n\n    return dstlen;\n}\n\n#endif\n</code></pre>\n<h2>Other Thoughts</h2>\n<hr>\n<p>If you need cryptographically secure random bytes, you should probably replace the fstream with POSIX's unbuffered open/read/close. This is because both <code>basic_filebuf</code> and <code>FILE</code> contain an internal buffer, which will be allocated via a standard allocator (and therefore not wiped from memory).</p>\n<p>This could easily be done by changing <code>sysrandom</code> to:</p>\n<pre><code>size_t sysrandom(void* dst, size_t dstlen)\n{\n    int fd = open(\"/dev/urandom\", O_RDONLY);\n    if (fd == -1) {\n        throw std::runtime_error(\"Unable to open /dev/urandom.\");\n    }\n    if (read(fd, dst, dstlen) != dstlen) {\n        close(fd);\n        throw std::runtime_error(\"Unable to read N bytes from CSPRNG.\");\n    }\n\n    close(fd);\n    return dstlen;\n}\n</code></pre>\n<h2>Thanks</h2>\n<hr>\n<p>Special thanks to Ben Voigt for pointing out <code>FILE</code> uses buffered reads, and therefore should not be used.</p>\n<p>I would also like to thank Peter Cordes for mentioning <code>getrandom</code>, and OpenBSD's lack of <code>/dev/urandom</code>.</p>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr>", "OwnerUserId": "4131059", "LastEditorUserId": "4131059", "LastEditDate": "2017-07-14T19:07:11.660", "Id": "45069417", "Score": "48", "CreationDate": "2017-07-13T00:05:31.320", "LastActivityDate": "2017-07-14T19:07:11.660"}, "bq_ids": {"n4140": {"so_45069219_45069347_1": {"section_id": 3583, "quality": 1.0, "length": 13}}, "n3337": {"so_45069219_45069347_1": {"section_id": 3448, "quality": 1.0, "length": 13}}, "n4659": {"so_45069219_45069347_1": {"section_id": 4348, "quality": 1.0, "length": 13}}}});