post_cb({"bq_ids": {"n4140": {"so_9168823_9168823_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6365}}, "n3337": {"so_9168823_9168823_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6122}}, "n4659": {"so_9168823_9168917_0": {"length": 30, "quality": 0.9090909090909091, "section_id": 7709}, "so_9168823_9168823_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 7876}}}, "9168892": {"Id": "9168892", "PostTypeId": "2", "Body": "<p>I don't think you can do ANYTHING with a moved-from object (except destroy it).</p>\n<p>Can't you use <code>swap</code> instead, to get all the advantages of moving but leave the container in a known state?</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-02-06T23:37:55.760", "Score": "-3", "CreationDate": "2012-02-06T23:26:40.207", "ParentId": "9168823", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2012-02-06T23:37:55.760"}, "9168823": {"ViewCount": "4160", "Body": "<p>What is the correct way to reuse a moved container?</p>\n<pre><code>std::vector&lt;int&gt; container;\ncontainer.push_back(1);\nauto container2 = std::move(container);\n\n// ver1: Do nothing\n//container2.clear(); // ver2: \"Reset\"\ncontainer = std::vector&lt;int&gt;() // ver3: Reinitialize\n\ncontainer.push_back(2);\nassert(container.size() == 1 &amp;&amp; container.front() == 2);\n</code></pre>\n<p>From what I've read in the C++0x standard draft; ver3 seems to be the correct way, since an object after move is in a </p>\n<blockquote>\n<p id=\"so_9168823_9168823_0\">\"Unless otherwise specified, such moved-from objects shall be placed\n  in a valid but unspecified state.\"</p>\n</blockquote>\n<p>I have never found any instance where it is \"otherwise specified\".</p>\n<p>Although I find ver3 a bit roundabout and would have much preferred ver1, though vec3 can allow some additional optimization, but on the other hand can easily lead to mistakes.</p>\n<p>Is my assumption correct?</p>\n", "AcceptedAnswerId": "9168917", "Title": "Reusing a moved container?", "CreationDate": "2012-02-06T23:18:53.807", "Id": "9168823", "CommentCount": "9", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2013-03-15T13:24:19.860", "LastEditorUserId": "313113", "LastActivityDate": "2013-03-15T13:24:19.860", "Score": "49", "OwnerUserId": "346804", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "3"}, "9168917": {"Id": "9168917", "PostTypeId": "2", "Body": "<p>From section 17.3.26 of the spec \"valid but unspecified state\":</p>\n<blockquote>\n<p id=\"so_9168823_9168917_0\">an object state that is not specified except that the object\u2019s invariants are met and operations on the object behave as specified for its type [ Example: If an object <code>x</code> of type <code>std::vector&lt;int&gt;</code> is in a valid but unspecified state, <code>x.empty()</code> can be\n  called unconditionally, and <code>x.front()</code> can be called only if <code>x.empty()</code> returns false. \u2014end example ]</p>\n</blockquote>\n<p>Therefore, the object is live. You can perform any operation that does not require a precondition (unless you verify the precondition first).</p>\n<p><code>clear</code>, for example, has no preconditions. And it will return the object to a known state. So just clear it and use it as normal.</p>\n", "LastActivityDate": "2012-02-06T23:29:48.267", "CommentCount": "9", "CreationDate": "2012-02-06T23:29:48.267", "ParentId": "9168823", "Score": "65", "OwnerUserId": "734069"}, "9168922": {"Id": "9168922", "PostTypeId": "2", "Body": "<p>The object beeing in a <strong>valid, but undefined state</strong> basically means that while the exact state of the object is not guaranteed, it is valid and as such memberfunctions (or non memberfunctions) are guaranteed to work as long as they don't rely on the object having a certain  state. </p>\n<p>The <code>clear()</code> memberfunction has no preconditions on the state of the object (other then it is valid of course) and can therefore be called on moved from objects. On the other hand for example <code>front()</code> depends on the container being not empty, and can therefore not be called, since it is not guaranteed to be non empty.</p>\n<p>Therefore both ver2 and ver3 should both be fine. </p>\n", "LastEditorUserId": "442284", "LastActivityDate": "2012-02-07T13:28:16.557", "Score": "5", "CreationDate": "2012-02-06T23:30:44.953", "ParentId": "9168823", "CommentCount": "6", "OwnerUserId": "201270", "LastEditDate": "2012-02-07T13:28:16.557"}});