post_cb({"7297081": {"ParentId": "7297024", "CommentCount": "1", "Body": "<p>It would be easier to write a variation on <code>shared_ptr</code> that has deep copying built into it. That way, you <em>don't</em> have to write a copy constructor for your main class; just for this special <code>deep_copy_shared_ptr</code> type. Your <code>deep_copy_shared_ptr</code> would have a copy constructor, and it would store a <code>shared_ptr</code> itself. It could even have an implicit conversion to <code>shared_ptr</code>, to make it a bit easier to use.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7297081", "Score": "4", "CreationDate": "2011-09-04T02:33:53.520", "LastActivityDate": "2011-09-04T02:33:53.520"}, "7297784": {"ParentId": "7297024", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Here\u2019s the question code as I\u2019m writing this:</p>\n<pre><code>class Foo {\npublic:\n     Foo() {}\n     Foo(Foo const &amp; other);\n     ...\nprivate:\n     int a, b, c, d, e;\n     std::shared_ptr&lt;Bla&gt; p;\n};\n\nFoo::Foo(Foo const &amp; other) {\n    p.reset(new Bla(other.p));\n\n    // Can I avoid having to write the default copy constructor code below\n    a = other.a;\n    b = other.b;\n    c = other.c;\n    d = other.d;\n    e = other.e;\n}\n</code></pre>\n<p>The above code is most likely <strong>wrong</strong>, because</p>\n<ol>\n<li><p>the default constructor leaves <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> and <code>e</code> uninitialized, and</p></li>\n<li><p>the code does not take charge of assignment copying, and</p></li>\n<li><p>the expression <code>new Bla(other.p)</code> requires that <code>Bla</code> has a constructor taking a <code>std::shared_ptr&lt;Bla&gt;</code>, which is extremely unlikely.</p></li>\n</ol>\n<p>With <code>std::shared_ptr</code> this would have to be C++11 code in order to be formally correct language-wise. However, I believe that it\u2019s just code that uses what\u2019s available with your compiler. And so I believe that the relevant C++ standard is C++98, with the technical corrections of the C++03 amendment.</p>\n<p>You can easily leverage the built-in (generated) copy initialization, even in C++98, e.g.</p>\n<pre><code>namespace detail {\n    struct AutoClonedBla {\n        std::shared_ptr&lt;Bla&gt; p;\n\n        AutoClonedBla( Bla* pNew ): p( pNew ) {}\n\n        AutoClonedBla( AutoClonedBla const&amp; other )\n            : p( new Bla( *other.p ) )\n        {}\n\n        void swap( AutoClonedBla&amp; other )\n        {\n            using std::swap;\n            swap( p, other.p );\n        }\n\n        AutoClonedBla&amp; operator=( AutoClonedBla other )\n        {\n            other.swap( *this );\n            return *this;\n        }\n    };\n}\n\nclass Foo {\npublic:\n     Foo(): a(), b(), c(), d(), e(), autoP( new Bla ) {}\n     // Copy constructor generated by compiler, OK.\n\nprivate:\n     int                      a, b, c, d, e;\n     detail::AutoClonedBla    autoP;\n};\n</code></pre>\n<p>Note that this code does initialize correctly in the default constructor, does take charge of copy assignment (employing the <a href=\"https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom\">swap idiom</a> for that), and does not require a special smart-pointer-aware <code>Bla</code> constructor, but instead just uses the ordinary <code>Bla</code> copy constructor to copy.</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:16.903", "Id": "7297784", "Score": "5", "CreationDate": "2011-09-04T06:43:42.487", "LastActivityDate": "2015-10-22T12:35:31.760"}, "7297038": {"ParentId": "7297024", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Not to my knowledge, but what you can (and should) do is use an initializer list, anyway:</p>\n<pre><code>Foo::Foo(Foo const &amp; other)\n    : a(other.a), b(other.b), c(other.c), \n      d(other.d), e(other.e), p(new Bla(other.p))\n{}\n</code></pre>\n<p>This won't save you from the writing, but it will save you from the possible performance penalty of assigning (unneccessarily) default-constructed members (although in this case it might be fine) and the many other pitfalls this could bring. Always use initializer lists in constructors, if possible.</p>\n<p>And by the way, Kerrek's comment is right. Why do you need a <code>shared_ptr</code>, if you make a deep copy anyway. In this case a <code>unique_ptr</code> might be more appropriate. Besides it's benefits <code>shared_ptr</code> is not a general no-more-to-think-about-deallocation solution and you should always think if you need a smart pointer and what type of smart pointer is most appropriate.</p>\n", "OwnerUserId": "743214", "LastEditorUserId": "743214", "LastEditDate": "2011-09-04T02:33:48.847", "Id": "7297038", "Score": "1", "CreationDate": "2011-09-04T02:21:54.310", "LastActivityDate": "2011-09-04T02:33:48.847"}, "7297024": {"CommentCount": "3", "AcceptedAnswerId": "7297784", "PostTypeId": "1", "LastEditorUserId": "627517", "CreationDate": "2011-09-04T02:17:57.663", "LastActivityDate": "2016-01-26T09:44:47.400", "LastEditDate": "2011-09-04T15:26:11.623", "ViewCount": "5528", "FavoriteCount": "1", "Title": "Call default copy constructor from within overloaded copy constructor", "Id": "7297024", "Score": "10", "Body": "<p>I need to write a copy constructor that deep copies the contents of a <code>std::shared_ptr</code>. However, there are a bunch of variable <code>int a, b, c, d, e;</code> also defined in the class. Is there a way to generate the default copy constructor code (or call the default copy constructor) inside my new overloaded one.</p>\n<p>Here is a code snippet with a comment that hopefully clarifies the issue.</p>\n<pre><code>class Foo {\npublic:\n     Foo() {}\n     Foo(Foo const &amp; other);\n     ...\nprivate:\n     int a, b, c, d, e;\n     std::shared_ptr&lt;Bla&gt; p;\n};\n\nFoo::Foo(Foo const &amp; other) {\n    p.reset(new Bla(*other.p));\n\n    // Can I avoid having to write the default copy constructor code below\n    a = other.a;\n    b = other.b;\n    c = other.c;\n    d = other.d;\n    e = other.e;\n}\n</code></pre>\n", "Tags": "<c++><constructor><shared-ptr><copy-constructor><deep-copy>", "OwnerUserId": "627517", "AnswerCount": "5"}, "7297049": {"ParentId": "7297024", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>That's not possible. It's either you write a custom copy constructor (entirely on your own) or the compiler writes it for you.</p>\n<p>Note that if you write a copy constructor then you probably need a copy assignment and a destructor as well, because writing any of these three resource-management functions implies you're managing a resource. With the copy-and-swap idiom, however, you only need to write the copy logic once, in the copy constructor, and you then define the assignment operator in terms of the copy constructor.</p>\n<p>Aside from that, I'm not entirely sure why you're using a <code>shared_ptr&lt;&gt;</code>. The point of a <code>shared_ptr&lt;&gt;</code> is to allow multiple pointers to safely point at the same object. But you're not sharing the pointee, you deep-copy it. Maybe you should use a raw pointer instead, and free it in the destructor. Or, better yet, replace the <code>shared_ptr&lt;&gt;</code> with a <code>clone_ptr</code>, and then eliminate the copy constructor, copy assignment and destructor altogether.</p>\n", "OwnerUserId": "456", "LastEditorUserId": "456", "LastEditDate": "2011-09-04T04:40:14.287", "Id": "7297049", "Score": "1", "CreationDate": "2011-09-04T02:25:03.533", "LastActivityDate": "2011-09-04T04:40:14.287"}, "7297110": {"ParentId": "7297024", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I always think that questions like this should have at least one answer quote from the standard for future readers, so here it is.</p>\n<p>\u00a712.8.4 of the standard states that:</p>\n<blockquote>\n<p id=\"so_7297024_7297110_0\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly.</p>\n</blockquote>\n<p>This implies that when a class definition <em>does</em> explicitly declare a copy constructor, one is <em>not</em> declared implicitly. So if you declare one explicitly, the implicit one does not exist, so you can't call it.</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2011-09-04T02:48:24.490", "Id": "7297110", "Score": "6", "CreationDate": "2011-09-04T02:40:18.240", "LastActivityDate": "2011-09-04T02:48:24.490"}, "bq_ids": {"n4140": {"so_7297024_7297110_0": {"section_id": 456, "quality": 1.0, "length": 10}}, "n3337": {"so_7297024_7297110_0": {"section_id": 447, "quality": 1.0, "length": 10}}, "n4659": {"so_7297024_7297110_0": {"section_id": 479, "quality": 1.0, "length": 10}}}});