post_cb({"39417395": {"CommentCount": "1", "AcceptedAnswerId": "39417433", "ClosedDate": "2016-09-09T23:09:21.660", "CreationDate": "2016-09-09T18:07:31.027", "LastActivityDate": "2016-09-09T18:25:13.373", "PostTypeId": "1", "ViewCount": "127", "Title": "Does forbidding copy operations automatically forbid move operations?", "Id": "39417395", "Score": "3", "Body": "<p>I want to write a C++ class without any copy and move semantics: I'm just interested in its constructor and destructor.</p>\n<p>I disabled copy operations (i.e. copy constructor and copy assignment operator) <em>explicitly</em> using C++11's <code>=delete</code> syntax, e.g.:</p>\n<pre><code>class MyClass \n{\n  public:    \n    MyClass()  { /* Init something */    }\n    ~MyClass() { /* Cleanup something */ }\n\n    // Disable copy\n    MyClass(const MyClass&amp;) = delete;\n    MyClass&amp; operator=(const MyClass&amp;) = delete;\n};\n</code></pre>\n<p>As a test, I tried calling <code>std::move()</code> on class instances, and it seems that there are no move operations automatically generated, as the Visual Studio 2015 C++ compiler emits error messages.</p>\n<p>Is this a behavior specific to MSVC 2015, or is it dictated by the C++ standard that disabling via <code>=delete</code> copy operations <em>automatically</em> disables move constructor and move assignment?</p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "1629821", "AnswerCount": "2"}, "39417433": {"ParentId": "39417395", "CommentCount": "2", "Body": "<p>MSVC conforms to the standard in this case. [class.copy]/9 in C++14 reads:</p>\n<blockquote>\n<p id=\"so_39417395_39417433_0\">If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared\n  as defaulted if and only if</p>\n<ul>\n<li><code>X</code> does not have a user-declared copy constructor,</li>\n<li><code>X</code> does not have a user-declared copy assignment operator,</li>\n<li><code>X</code> does not have a user-declared move assignment operator, and</li>\n<li><code>X</code> does not have a user-declared destructor.</li>\n</ul>\n</blockquote>\n<p>So your class has <em>no</em> move constructor and any attempt to move it will fall back to the deleted copy constructor.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "39417433", "Score": "4", "CreationDate": "2016-09-09T18:10:04.427", "LastActivityDate": "2016-09-09T18:10:04.427"}, "39417658": {"ParentId": "39417395", "CommentCount": "0", "Body": "<p>Although Brian has <em>probably</em> given you the information you care about, let me try to add just a little bit more (or maybe just get pedantic about wording in a way nobody cares about).</p>\n<p>Deleting the copy constructor or copy assignment operator prevents the compiler from implicitly synthesizing a move constructor/move assignment operator.</p>\n<p>You can still explicitly define a move constructor and/or move assignment yourself though. So, preventing copies does not actually prevent move construction and move assignment--it just prevents the compiler from implementing them implicitly.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "39417658", "Score": "2", "CreationDate": "2016-09-09T18:25:13.373", "LastActivityDate": "2016-09-09T18:25:13.373"}, "bq_ids": {"n4140": {"so_39417395_39417433_0": {"section_id": 458, "quality": 1.0, "length": 12}}, "n3337": {"so_39417395_39417433_0": {"section_id": 449, "quality": 1.0, "length": 12}}, "n4659": {"so_39417395_39417433_0": {"section_id": 481, "quality": 1.0, "length": 12}}}});