post_cb({"bq_ids": {"n4140": {"so_425457_425615_0": {"length": 30, "quality": 0.9375, "section_id": 114}}, "n3337": {"so_425457_425615_0": {"length": 30, "quality": 0.9375, "section_id": 109}}, "n4659": {"so_425457_425615_0": {"length": 30, "quality": 0.9375, "section_id": 118}}}, "425627": {"Id": "425627", "PostTypeId": "2", "Body": "<p>Note that your question is not particular to inheritance. Given your code example, you cannot instantiate <code>MyParent</code> at all, either because it doesn't accept a template argument list or because it has no default constructor.</p>\n<p>In order to instantiate <code>MyParent</code> with a constructor template, you need to provide some way for the compiler to know the template argument, and you can't do that with a no-argument constructor. You need to give <code>MyParent</code>'s constructor a parameter. Here's an example based on <a href=\"http://www.velocityreviews.com/forums/t545918-template-default-constructor-possible.html\" rel=\"nofollow noreferrer\">code from Alf P. Steinbach</a>:</p>\n<pre><code>template &lt;typename T&gt;\nstruct UseMethodsOf {};\n\nclass MyParent\n{\npublic:\n  template &lt;typename T&gt;\n  MyParent(UseMethodsOf&lt;T&gt;)\n  {\n    T* Something;\n  }\n};\n\nclass MyDerived: public MyParent\n{\npublic:\n  MyDerived()\n  : MyParent(UseMethodsOf&lt;int&gt;())\n  {\n  }\n};\n</code></pre>\n", "OwnerDisplayName": "Rob Kennedy", "LastActivityDate": "2009-01-08T19:53:04.867", "Score": "4", "CreationDate": "2009-01-08T19:53:04.867", "ParentId": "425457", "CommentCount": "1", "OwnerUserId": "33732"}, "425615": {"Body": "<p>It is not possible. From the standard section 14.8.1  Explicit template argument, it notes:</p>\n<blockquote>\n<p id=\"so_425457_425615_0\">[Note: because  the explicit template argument list follows the function template name, and because conversion member  function  templates and  constructor  member function templates are called without using a\n    function name, there is no way to provide an explicit  template  argument list for these function templates.  ]</p>\n</blockquote>\n<p>As noted in the comments, you would need to have the constructor take a parameter of type <code>T</code> (or <code>const T &amp;</code>), and then have <code>MyDerived</code> call <code>MyParent::MyParent</code> with a paremeter of type <code>int</code>.</p>\n", "CreationDate": "2009-01-08T19:49:58.023", "ParentId": "425457", "CommentCount": "0", "LastEditDate": "2013-11-23T11:47:19.890", "PostTypeId": "2", "OwnerDisplayName": "Greg Rogers", "LastEditorUserId": "1322972", "LastActivityDate": "2013-11-23T11:47:19.890", "Id": "425615", "Score": "4", "OwnerUserId": "5963"}, "425457": {"ViewCount": "332", "Body": "<p>Let's say we have a class, MyParent:</p>\n<pre><code>class MyParent\n{\npublic:\n  template&lt;namespace T&gt;\n  MyParent()\n  {\n    T* Something;\n  }\n};\n</code></pre>\n<p>And a derived class, which uses this constructor:</p>\n<pre><code>class MyDerived : public MyParent\n{\npublic:\n  MyDerived()\n  : MyParent&lt;int&gt;()\n  {\n  }\n};\n</code></pre>\n<p>Then I get a compiling error, because there's ambiguity. The compiler thinks that the <strong><em>int</em></strong> is a template argument to the class, not the constructor.</p>\n<p>How do I specify that I want the <strong><em>int</em></strong> to be an argument to the constructor?</p>\n", "AcceptedAnswerId": "425615", "Title": "Inheriting from a non-templated class that has a templated constructor - how to resolve ambiguity?", "CreationDate": "2009-01-08T19:07:47.673", "Id": "425457", "CommentCount": "3", "PostTypeId": "1", "OwnerDisplayName": "Geeho", "LastActivityDate": "2013-11-23T11:47:19.890", "Score": "2", "OwnerUserId": "51747", "Tags": "<c++><templates><constructor>", "AnswerCount": "2"}});