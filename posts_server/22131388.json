post_cb({"22131388": {"CommentCount": "3", "AcceptedAnswerId": "22131521", "CreationDate": "2014-03-02T18:16:36.367", "LastActivityDate": "2014-03-02T19:46:02.897", "PostTypeId": "1", "ViewCount": "226", "FavoriteCount": "1", "Title": "Is conversion int -> unsigned long long defined by the standard", "Id": "22131388", "Score": "4", "Body": "<p>I can't find the exact specification of how <code>int</code> value is converted to <code>unsigned long long</code> in the standard. Various similar conversions, such as int -&gt; unsigned, unsigned -&gt; int (UB if negative), unsigned long long -&gt; int, etc. are specified</p>\n<p>For example GCC, <code>-1</code> is converted to <code>0xffffffffffffffff</code>, not to <code>0x00000000ffffffff</code>. Can I rely on this behavior?</p>\n", "Tags": "<c++><type-conversion><standards>", "OwnerUserId": "2371640", "AnswerCount": "3"}, "22131473": {"ParentId": "22131388", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, it's defined:</p>\n<p>C++11 \u00a7 4.7 [conv.integral]/2 says this:</p>\n<blockquote>\n<p id=\"so_22131388_22131473_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>The least unsigned integer congruent to -1 (modulo 2<sup><code>sizeof(unsigned long long)</code></sup>) is the largest value of <code>unsigned long long</code> possible.</p>\n", "OwnerUserId": "962089", "LastEditorUserId": "962089", "LastEditDate": "2014-03-02T18:28:22.370", "Id": "22131473", "Score": "1", "CreationDate": "2014-03-02T18:22:02.307", "LastActivityDate": "2014-03-02T18:28:22.370"}, "22131521": {"ParentId": "22131388", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, this is well defined, it is basically adding <code>max unsigned long long + 1</code> to <code>-1</code> which will always be <code>max unsigned long long</code>. This is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>4.7</code> <em>Integral conversions</em> which says:</p>\n<blockquote>\n<p id=\"so_22131388_22131521_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014end note ]</p>\n</blockquote>\n<p>it does the same thing as C99 but the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">draft C99 standard</a> is easier to understand, from section <code>6.3.1.3</code> <em>Signed and unsigned integers</em>:</p>\n<blockquote>\n<p id=\"so_22131388_22131521_1\">Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or\n  subtracting one more than the maximum value that can be represented in the new type\n  until the value is in the range of the new type.<sup>49)</sup></p>\n</blockquote>\n<p>where footnote <code>49</code> says:</p>\n<blockquote>\n<p id=\"so_22131388_22131521_2\">The rules describe arithmetic on the mathematical value, not the value of a given type of expression.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-03-02T19:46:02.897", "Id": "22131521", "Score": "2", "CreationDate": "2014-03-02T18:24:31.140", "LastActivityDate": "2014-03-02T19:46:02.897"}, "bq_ids": {"n4140": {"so_22131388_22131521_0": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_22131388_22131473_0": {"section_id": 31, "quality": 1.0, "length": 18}}, "n3337": {"so_22131388_22131521_0": {"section_id": 28, "quality": 0.90625, "length": 29}, "so_22131388_22131473_0": {"section_id": 28, "quality": 1.0, "length": 18}}, "n4659": {"so_22131388_22131473_0": {"section_id": 31, "quality": 1.0, "length": 18}, "so_22131388_22131521_0": {"section_id": 31, "quality": 0.90625, "length": 29}}}, "22131536": {"ParentId": "22131388", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Unsigned integers have guaranteed modulo arithmetic. Thus any <code>int</code> value <em>v</em> is converted to the <code>unsigned long</code> value <em>u</em> such that <i>u</i> = K*2<sup><i>n</i></sup>+<i>v</i>, where K is either 0 or 1, and  where <em>n</em> is the number of value representation bits for <code>unsigned long</code>. In other words, if <em>v</em> is negative, just add 2<sup><i>n</i></sup>.</p>\n<hr>\n<p>The power of 2 follows from the C++ standard's requirement that integers be represented with a pure binary system. With <em>n</em> value representation bits the number of possible values is 2<sup><i>n</i></sup>. There is not such a requirement for floating point types (you can use <code>std::numeric_limits</code> to check the radix of the representation of floating point values).</p>\n<hr>\n<p>Also note that in order to cater to some now archaic platforms, as well as one popular compiler that does things its own way, the standard leaves the opposite conversion as undefined behavior when the unsigned value is not directly representable as a signed value. In practice, on modern systems all compilers can be told to make that reverse conversion the exact opposite of the conversion to unsigned type, and e.g. Visual C++ does that by default. However, it's worth keeping in mind that there's no formal support, so that portable code incurs a slight (now with modern computers needless) inefficiency.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-03-02T18:37:15.150", "Id": "22131536", "Score": "1", "CreationDate": "2014-03-02T18:25:38.773", "LastActivityDate": "2014-03-02T18:37:15.150"}});