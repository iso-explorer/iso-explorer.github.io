post_cb({"30803399": {"CommentCount": "3", "AcceptedAnswerId": "30803988", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2015-06-12T12:43:03.190", "LastActivityDate": "2017-04-15T18:23:05.257", "LastEditDate": "2017-04-15T18:23:05.257", "ViewCount": "217", "FavoriteCount": "1", "Title": "twisted logic: a global variable in one file refers to an extern variable but is also referred by that extern variable", "Id": "30803399", "Score": "6", "Body": "<p>fileA.cpp\uff1a</p>\n<pre><code>#include &lt;iostream&gt;\nextern int iA;\nextern int iB= iA;\nint main()\n{\nstd::cout&lt;&lt;iA&lt;&lt;','&lt;&lt;iB;\n}\n</code></pre>\n<p>fileB.cpp</p>\n<pre><code>extern int iB;\nextern int iA = 2*iB;\n</code></pre>\n<p>Compiled and linked and ran, out come in the debug and release mode is <code>0,0</code>\nMy question is how it works, why there is no issue in linking stage?\nI'm using VC++2003.</p>\n", "Tags": "<c++><compilation><linker><external>", "OwnerUserId": "1814794", "AnswerCount": "1"}, "30803988": {"ParentId": "30803399", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The initialiser overrides the <code>extern</code> keyword, so there's nothing \"magical\" about this: you're just declaring and defining two completely unrelated variables in different functions.</p>\n<blockquote>\n<p id=\"so_30803399_30803988_0\"><code>[C++14: 3.1/2]:</code> <strong>A declaration is a <em>definition</em> unless</strong> it declares a function without specifying the function\u2019s body (8.4), <strong>it contains the <code>extern</code> specifier</strong> (7.1.1) or a <em>linkage-specification</em><sup>25</sup> (7.5) <strong>and neither an initializer</strong> nor a <em>function-body</em>, it declares a static data member in a class definition (9.2, 9.4), it is a class name declaration (9.1), it is an <em>opaque-enum-declaration</em> (7.2), it is a <em>template-parameter</em> (14.1), it is a <em>parameter-declaration</em> (8.3.5) in a function declarator that is not the declarator of a <em>function-definition</em>, or it is a <code>typedef</code> declaration (7.1.3),\n  an <em>alias-declaration</em> (7.1.3), a <em>using-declaration</em> (7.3.3), a <em>static_assert-declaration</em> (Clause 7), an <em>attribute-declaration</em> (Clause 7), an <em>empty-declaration</em> (Clause 7), or a <em>using-directive</em> (7.3.4).</p>\n</blockquote>\n<p>Your program is thus equivalent to the following:</p>\n<p><em>fileA.cpp</em></p>\n<pre><code>#include &lt;iostream&gt;\nextern int iA;\nint iB= iA;\nint main()\n{\nstd::cout&lt;&lt;iA&lt;&lt;','&lt;&lt;iB;\n}\n</code></pre>\n<p><em>fileB.cpp</em></p>\n<pre><code>extern int iB;\nint iA = 2*iB;\n</code></pre>\n<p>Now, both objects necessarily undergo static initialization (to bitwise all-zeroes) before anything else happens. When dynamic-initialization later takes place, depending on whether the static-storage-duration objects in fileA.cpp or fileB.cpp get initialised first (and you <em>can't know</em> what order that'll be) either <code>iB</code> is initialized to a zero <code>iA</code> (then <code>iA</code> is initialized to <code>2*iB</code> as expected), or <code>iA</code> is initialised to a zero <code>iB</code> multiplied by two, which is still two (then <code>iB</code> is initialized to a zero <code>iA</code>).</p>\n<p>Either way, both objects are going to end up, via well-defined semantics, having a value of zero.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-06-12T13:24:33.263", "Id": "30803988", "Score": "3", "CreationDate": "2015-06-12T13:12:05.600", "LastActivityDate": "2015-06-12T13:24:33.263"}, "bq_ids": {"n4140": {"so_30803399_30803988_0": {"section_id": 7034, "quality": 0.7843137254901961, "length": 40}}, "n3337": {"so_30803399_30803988_0": {"section_id": 6780, "quality": 0.7843137254901961, "length": 40}}, "n4659": {"so_30803399_30803988_0": {"section_id": 8531, "quality": 0.7843137254901961, "length": 40}}}});