post_cb({"bq_ids": {"n4140": {"so_31882729_31882963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5525}, "so_31882729_31882963_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5525}}, "n3337": {"so_31882729_31882963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5311}, "so_31882729_31882963_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5311}}, "n4659": {"so_31882729_31882963_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6960}, "so_31882729_31882963_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6960}}}, "31882963": {"Id": "31882963", "PostTypeId": "2", "Body": "<p>The behavior is implementation-defined.</p>\n<blockquote>\n<p id=\"so_31882729_31882963_0\"><strong>[dcl.link]</strong> Linkage from C++ to objects defined in other languages and to objects defined in C++ from other languages is implementation-defined and language-dependent.</p>\n</blockquote>\n<p>It continues:</p>\n<blockquote>\n<p id=\"so_31882729_31882963_1\">Only where the object layout strategies of two language implementations are similar enough can such linkage be achieved.</p>\n</blockquote>\n<p>That sentence in the standard really should be an annotation, since it doesn't specify what counts as \"similar enough\".</p>\n", "LastActivityDate": "2015-08-07T16:54:37.857", "CommentCount": "5", "CreationDate": "2015-08-07T16:54:37.857", "ParentId": "31882729", "Score": "18", "OwnerUserId": "902497"}, "31883143": {"Id": "31883143", "PostTypeId": "2", "Body": "<p>As Raymond has already said, this is implementation-defined at the formal, language level.</p>\n<p>But it's important to remember what your compiled code <em>is</em>. It's not C++ code any more, nor is it C code. The rules about the behaviour of code in those languages apply to code written in those languages. They are taken into consideration during the parsing and translation process. But, once your code has been translated into assembly, or machine code, or whatever else you translated it to, <em>those rules no longer apply</em>.</p>\n<p>So it's effectively meaningless to ask whether compiled C code has UB. If you had a well-defined C program, and compiled it, <em>that's that</em>. You're out of the realm of being able to discuss whether the compiled program is well-defined or not. It's a meaningless distinction, unless you have somehow managed to generate a program that is dictated to have UB by the specification for your assembly or machine language dialect.</p>\n<p>The upshot of all this is that the premise of your question is unsound. You can't \"avoid undefined behaviour\" when linking to the compiled result of a C program, because the very notion of \"undefined behaviour\" does not exist there. But, <strong>as long as the original source code was well-defined when you translated it, you will be fine</strong>.</p>\n", "LastActivityDate": "2015-08-07T17:07:57.530", "CommentCount": "5", "CreationDate": "2015-08-07T17:07:57.530", "ParentId": "31882729", "Score": "11", "OwnerUserId": "560648"}, "31882729": {"ViewCount": "853", "Body": "<p>If you have a C file, compiled with a C compiler and have defined behavior for C but not C++, can you link it with a C++ file and not have undefined behavior?</p>\n<p>in blah.c (the file compiled as C)</p>\n<pre><code>struct x {\n    int blah;\n    char buf[];\n};\n\nextern char * get_buf(struct x * base);\nextern struct x * make_struct(int blah, int size);\n</code></pre>\n<p>blah_if.h</p>\n<pre><code>extern \"C\"\n{\n    struct x;\n\n    char * get_buf(struct x * base);\n    struct x * make_struct(int blah, int size);\n}\n</code></pre>\n<p>some_random.cpp (Compiled with a C++ compiler)</p>\n<pre><code>#include \"blah_if.h\"\n\n...\n\nx * data=make_struct(7, 12);\nstd::strcpy(get_buf(data), \"hello\");\n</code></pre>\n<p>Is using the defined behavior in C's flexible array member in a file compiled with a C compiler, defined behavior when used by a file compiled as C++ and linked with the object from the C compiler?</p>\n<p><em>Note that because a C compiler is used and <code>struct x</code> is opaque, this is different than:</em></p>\n<p><a href=\"https://stackoverflow.com/questions/31881811/does-extern-c-with-c-avoid-undefined-behavior-that-is-legal-in-c-but-not-c\">Does extern C with C++ avoid undefined behavior that is legal in C but not C++?</a></p>\n", "AcceptedAnswerId": "31883143", "Title": "Does linking C with C++ avoid undefined behavior that is legal in C but not C++?", "CreationDate": "2015-08-07T16:39:45.953", "Id": "31882729", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:01:09.563", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-01T21:08:40.713", "Score": "18", "OwnerUserId": "2963099", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "2"}});