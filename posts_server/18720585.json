post_cb({"bq_ids": {"n4140": {"so_18720585_18720678_0": {"section_id": 6071, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_18720585_18720678_0": {"section_id": 5839, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_18720585_18720678_0": {"section_id": 7567, "quality": 0.9230769230769231, "length": 12}}}, "18720678": {"ParentId": "18720585", "CommentCount": "8", "Body": "<p>Bear this in mind:</p>\n<p>The 2003 Standard C++ 5.3.1c7: </p>\n<blockquote>\n<p id=\"so_18720585_18720678_0\">The negative of an unsigned quantity is computed by subtracting its\n  value from 2^n, where n is the number of bits in the promoted operand.</p>\n</blockquote>\n<p><code>a+b = a - (-b)</code> will work in a C++ compiler conforming to 2003 standard (and C++11 by the way).</p>\n<p>Of course, I'll upvote an answer that's conformant with earlier standards (C++99 for example where <code>-unsigned</code> is undefined).</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "18720678", "Score": "3", "CreationDate": "2013-09-10T13:45:11.223", "LastActivityDate": "2013-09-10T13:45:11.223"}, "18720706": {"ParentId": "18720585", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>The logic</strong>: The code implements a series of <a href=\"http://en.wikipedia.org/wiki/Adder_(electronics)#Half_adder\" rel=\"noreferrer\">half-adders</a> and propagates the carry from one of them to the next one via recursion. See the dry-run for an example on how this works.</p>\n<p>Consider these two values <code>a=0011</code> and <code>b=0101</code>. In base 10 they are <code>a=3</code> and <code>b=5</code> respectively.</p>\n<p>Now, <code>a^b=0110</code> (<code>1</code> only when a single bit is <code>1</code>) while <code>a&amp;b=0001</code> (<code>1</code> only when both bits is one, the single case where you can have a carry).</p>\n<p>Then, you need to move the carry to the next bit, that's why you have the <code>&lt;&lt;1</code> operation, making <code>carry=0010</code>.</p>\n<p>Now you need to add <code>0110</code> and <code>0010</code> using the above algorithm. This will turn into adding <code>0100</code> and <code>0100</code>. Which will result in adding <code>0000</code> with <code>1000</code> which will result in adding <code>1000</code> with <code>0000</code> which will end via the base case (<code>b == 0</code>).</p>\n<p>In tabular form:</p>\n<pre><code>|   a  |   b  | a^b  |  a&amp;b | carry|\n------------------------------------\n| 0011 | 0101 | 0110 | 0001 | 0010 |\n| 0110 | 0010 | 0100 | 0010 | 0100 |\n| 0100 | 0100 | 0000 | 0100 | 1000 |\n| 0000 | 1000 | 1000 | 0000 | 0000 |\n| 1000 | 0000 | ---- | ---- | ---- |\n</code></pre>\n<p>Last row is base case.</p>\n", "OwnerUserId": "371834", "LastEditorUserId": "371834", "LastEditDate": "2013-09-10T13:53:21.080", "Id": "18720706", "Score": "6", "CreationDate": "2013-09-10T13:46:35.727", "LastActivityDate": "2013-09-10T13:53:21.080"}, "18721011": {"ParentId": "18720585", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The bit manipulation code in the question uses two basic principles: <a href=\"https://en.wikipedia.org/wiki/Adder_%28electronics%29#Half_adder\" rel=\"nofollow\">half adder</a> and the fact that addition is commutative.</p>\n<p>A single half adder adds two bits, with no carry-in. The single bit add result is one if exactly one of the inputs is one, zero if the inputs are equal. That is represented by the bitwise <code>xor</code> in the code.</p>\n<p>Even after doing that, you need to deal with the carries. The carry out from a bit position is one if both bits are one, zero otherwise. That is represented by the combination of a bitwise <code>and</code>, with a following <code>shift</code> to move the carry to the bit position where it needs to be added.</p>\n<p>The recursive call to add applies the carries, using the fact that addition is commutative. It does not matter whether the carries are added bit-by-bit along with the initial addition, or in bulk in a later step.</p>\n<p>Adding in a carry may cause a new carry-out. That is handled by continuing the recursive calls until an add has no carries.</p>\n<p>The recursion base case, zero carry, must be reached because adding zero, with zero carry-in, cannot result in a carry. If the least significant <code>k</code> bits of the carry are all zero on one carry addition, at least <code>k+1</code> least significant bits of the next carry must be zero.</p>\n", "OwnerUserId": "1798593", "LastEditorUserId": "1798593", "LastEditDate": "2013-09-10T14:21:23.993", "Id": "18721011", "Score": "3", "CreationDate": "2013-09-10T14:01:56.833", "LastActivityDate": "2013-09-10T14:21:23.993"}, "18721536": {"ParentId": "18720585", "CommentCount": "0", "Body": "<p>This is the way the hardware implements addition.  The results\nof an addition on a bit are the exclusive or (the <code>^</code> operator\nin C++) of the bits; this is what you get with <code>sum</code>.  But this\ndoesn't take into consideration any carry from the lower bit.\nThe carry out is the and of the bits (the <code>&amp;</code> operator), which\ngives you the initial value of <code>carry</code>.  But the carry out of\nbit n is the carry in of bit n + 1, so we shift left, moving bit\nn into bit n + 1, and add it in. </p>\n<p>We use recursion to add it in, because if the results (at the\nbit level) before adding carry in are 1, and carry in is 1,\nthere will also be a carry out.</p>\n<p>It's a bit more subtle why the recursion ends (and of course,\nthe hardware version doesn't recurse, but rather adds additional\nlogic).  This is most easily evaluated by considering the\noriginal values:</p>\n<pre><code>a   b   carry_in  sum carry_out\n\n0   0       0      0      0\n1   0       0      1      0\n0   1       0      1      0\n1   1       0      0      1\n0   0       1      0      0\n1   0       1      1      1\n0   1       1      1      1\n1   1       1      0      1\n</code></pre>\n<p>(The \"sum\" column is the result of <code>a ^ b</code>, without the carry.)</p>\n<p>On the first recursive call, bit 0 of b will be 0 (because it\nrepresents the carry_in of the lower order bit, and there isn't\none\u2014or because of the <code>&lt;&lt;</code>, which moves the carry_out of\nbit n to carry_in of bit n + 1).  And of course, the carry_in of\nbit 0 will be 0.  So for bit 0 in the first recursive call, only\nthe first two lines can occur.  Which means that there will be\nno carry_out, and for the next recursion, only the first two\nlines are relevant for bits 0 and 1.  In other words, each\nrecursion effectively eliminates one set bit from the propagated\ncarry, with the result that the propagated carry must eventually\nbecome 0.  And since it is propagated as parameter b, parameter\nb must eventually become 0.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "18721536", "Score": "0", "CreationDate": "2013-09-10T14:23:57.830", "LastActivityDate": "2013-09-10T14:23:57.830"}, "18720977": {"ParentId": "18720585", "CommentCount": "1", "Body": "<p>To understand why the function does in fact add two numbers it is helpful to look at the truth table for addition of two bits:</p>\n<p>a = 0, b = 0 -&gt; a + b = 00<br>\na = 0, b = 1 -&gt; a + b = 01<br>\na = 1, b = 0 -&gt; a + b = 01<br>\na = 1, b = 1 -&gt; a + b = 10<br/></br></br></br></p>\n<p>You see that the lower bit is the XOR of both input bits and the higher bit is the AND of the two input bits, so the final result is represented by (a XOR b) OR ((a AND B) &lt;&lt; 1). As this function adds 32-bit numbers you cannot simply OR the results anymore because some additional carry bits can appear in the higher digits when combining the results of the XOR and the AND operations, and that's why you have to apply the function recursively.</p>\n<p>Btw, that is pretty much the way addition of numbers is done in hardware.</p>\n", "OwnerUserId": "1900164", "PostTypeId": "2", "Id": "18720977", "Score": "1", "CreationDate": "2013-09-10T13:59:47.337", "LastActivityDate": "2013-09-10T13:59:47.337"}, "18720585": {"CommentCount": "8", "AcceptedAnswerId": "18720706", "CreationDate": "2013-09-10T13:41:26.793", "LastActivityDate": "2013-09-10T14:23:57.830", "PostTypeId": "1", "ViewCount": "288", "FavoriteCount": "1", "Title": "Add unsigned numbers without using '+' or '++'", "Id": "18720585", "Score": "4", "Body": "<p>I need to add 2 unsigned numbers 'a' and 'b' .</p>\n<p>I found the following Code , using bit operations</p>\n<pre><code>unsigned int add (unsigned int a,unsigned int b)\n{\n    unsigned int carry, sum;\n    if (b == 0)\n    {\n        return a;\n    }\n\n    sum = a ^ b; // xor takes sum\n    carry = a &amp; b; // collect carry;\n    carry = carry &lt;&lt; 1;\n    return ( add (sum, carry) );\n}\n</code></pre>\n<p>I cant figure out how is this code adding two numbers .</p>\n<p>Any help/direction people .</p>\n", "Tags": "<c++><algorithm><bit-manipulation>", "OwnerUserId": "2426101", "AnswerCount": "5"}});