post_cb({"5011415": {"ParentId": "5009737", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>To give an example why this is definetly undefined behaviour; change the following in your code:</p>\n<pre><code>#include &lt;iostream&gt;\n// ...\nint main() {\n    A&amp; v = func();\n    v.v=9;\n\n    int over[9000] = {1};\n    std::cout &lt;&lt; v.v;\n\n    return 0;\n}\n</code></pre>\n<p>At least for me (and consistently), that overwrote the memory stored in v.v. But it may not be consistent for others, because how memory is handled is probably implementation Dependant. It should give you an idea however.</p>\n", "OwnerUserId": "431528", "LastEditorDisplayName": "user34537", "LastEditDate": "2011-02-16T03:13:32.123", "Id": "5011415", "Score": "1", "CreationDate": "2011-02-16T01:01:51.357", "LastActivityDate": "2011-02-16T03:13:32.123"}, "5009886": {"ParentId": "5009737", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I think you're making a big logical mistake. Undefined Behavior doesn't mean that a program will crash... it means that anything could happen.</p>\n<p>If you're lucky (very very lucky) then you get a crash. What normally happens instead is that if you do anything that implies undefined behavior simply the program keeps running as if nothing happened, until one million executed instructions later where a perfectly legal piece of code does something very crazy. Normal reactions from programmers is then to blame the compiler, the OS version, the defective RAM and voodoo dolls hidden by hostile colleagues in the drawer.</p>\n<p>If you are just a little unlucky instead the program will just behave exactly as you would expect, including providing the result you expect from it and closing fine without any problems at all. All this until you get to the big demo day, when instead it will crash badly in front of the audience just after you say \"And now let's save our work...\".</p>\n<p>But why isn't undefined behavior checked in C++?</p>\n<p>One of the main philosophical foundation of C++ is simply that programmers make no error. This means that when a programmer does indeed make an error there is no \"runtime error angel\" that will come to help, just \"undefined behavior daemons\" that instead will try to bite.</p>\n<p>This has been done to avoid leaving enough space for another language between C++ and assembler, so it must be possible to write efficient code, and runtime error angels are too heavy to carry around. While for sure it's easy to write bloated and slow code in C++ it's also possible to write efficient code if you have a good grasp of how the language works and by keeping a constant focus to performance in mind.</p>\n<p>When you see \"this is undefined behavior\" simply the meaning is that the compiler writers are free to ignore whatever is going to happen. Checking that those rules are not violated is a burden on the programmers that are using C++, not on the C++ compiler.</p>\n<p>In my opinion the very fact that \"undefined behavior\" means that's unpredictable what happens and the fact that's very very easy to get undefined behavior by mistake means that C++ is a terrible language to learn by experimentation, because when you make a mistake the system won't tell you clearly so. It's also in my opinion a terrible language for a beginner (because it's natural for beginners to do more mistakes).</p>\n<p>The only reasonable path to C++ is:</p>\n<ol>\n<li><p>Learning it by studying and not by experimenting</p>\n<p>C++ is a complex language with a long evolution history. In some parts it's illogical because of historical accidents. Even if you're smart you will never be able to guess the historical reasons for an apparently illogical choice. History must be studied.</p></li>\n<li><p>You must think very carefully at every single statement you write</p>\n<p>Like I said before you can't expect C++ to detect all your mistakes. Anything can happen when you make a mistake (including nothing!) and this means that debugging can be very very hard. The only viable option is to try to not introduce bugs. Writing code without serious thinking and hoping that tests and debug will find them is IMO bad for any language, but a true suicidal approach to C++.</p></li>\n</ol>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2011-02-15T22:27:52.717", "Id": "5009886", "Score": "2", "CreationDate": "2011-02-15T21:42:35.767", "LastActivityDate": "2011-02-15T22:27:52.717"}, "5009814": {"ParentId": "5009737", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Using a reference to a local object after it has gone out of scope is undefined behavior, and as such it does not require any diagnostic from the compiler.</p>\n<blockquote>\n<p id=\"so_5009737_5009814_0\"><strong>1.3.12 undefined behavior</strong></p>\n<p id=\"so_5009737_5009814_1\">behavior, such as might arise upon use of an erroneous program construct or erroneous data, for which this International Standard imposes no requirements. Undefined behavior may also be expected when this International Standard omits the description of any explicit definition of behavior. [Note: <strong><em>permissible undefined behavior ranges from ignoring the situation completely with unpredictable results</em></strong>, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a\n  diagnostic message).</p>\n</blockquote>\n<hr/>\n<p>You ask why can't it be detected at runtime; how can that be? The only way would be to check, at every memory access done via a pointer/reference whose value is in the range currently used for the stack, that such address is below the current stack pointer.</p>\n<p>This would be a hugely costly operation (in terms both of time spent and executable size increase) since it would have to be done for <em>every</em> memory access, so it's not done.</p>\n<p>On the other hand, the checks for the arrays you described work (AFAIK) by checking if a flag value put between stack frames has been overwritten, and such check is performed only when the function returns (by the way, such checks in VC++ can be enabled only in unoptimized builds).</p>\n<p>Another kind of check that the compiler can do is by static analysis of the code; this is not perfect, but often works fine, and warns you if you do something nonsensical as directly returning a reference/pointer to a local variable; in this case it didn't warn you because your example is quite convoluted, and the static analysis didn't manage to catch it.</p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2011-02-15T22:10:47.663", "Id": "5009814", "Score": "3", "CreationDate": "2011-02-15T21:36:16.297", "LastActivityDate": "2011-02-15T22:10:47.663"}, "5009824": {"ParentId": "5009737", "CommentCount": "0", "Body": "<p>The compiler can't tell that it's invalid code. Returning <code>*this</code> as a reference would be OK if the reference lifetime was shorter than the lifetime of the object being returned. Determining which has the longer lifetime at runtime is beyond the capabilities of the compiler at compile-time, since the lifetime can in general depend on what happens at run-time.</p>\n<p>I suppose a sufficiently clever compiler (or more likely, lint tool) could put in checks for certain special cases, possibly including the case you give here. The question is whether it's worth implementing such a check when it will only catch obvious cases anyway.</p>\n", "OwnerUserId": "174963", "PostTypeId": "2", "Id": "5009824", "Score": "0", "CreationDate": "2011-02-15T21:37:02.637", "LastActivityDate": "2011-02-15T21:37:02.637"}, "5009737": {"CommentCount": "2", "ViewCount": "211", "PostTypeId": "1", "LastEditorUserId": "214671", "CreationDate": "2011-02-15T21:29:36.633", "LastActivityDate": "2011-02-16T03:13:32.123", "LastEditDate": "2011-02-15T21:32:58.340", "AcceptedAnswerId": "5009821", "OwnerDisplayName": "user34537", "Title": "This code is undefined, why is it running? How do i crash it?", "Id": "5009737", "Score": "0", "Body": "<p>I ran the code below in visual studios and expected to get a runtime or some kind of error. I got nothing, absolutely nothing. I got the output code 9, comment that line out and got 3. I ran it on codepad and it gave me no errors as well.</p>\n<p>Is there a compiler that will tell me this code is incorrect? If it is correct why is it? I know const A&amp; <a href=\"http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"nofollow\">is legal</a> but AFAIK the below isnt.</p>\n<pre><code>class A\n{\npublic:\n    int v;\n    A&amp; get()\n    {\n        return *this;\n    }\n};\n\nA&amp; func()\n{\n    A a;\n    a.v=3;\n    return a.get();\n}\n\nint main()\n{\n    A&amp; v = func();\n    v.v=9;\n    return v.v;\n}\n</code></pre>\n", "Tags": "<c++>", "AnswerCount": "7"}, "5009760": {"ParentId": "5009737", "CommentCount": "4", "Body": "<p>It's working because the memory the instance was being stored in hadn't been overwritten yet. This obviously wouldn't fly in a real project.</p>\n", "OwnerUserId": "610744", "PostTypeId": "2", "Id": "5009760", "Score": "5", "CreationDate": "2011-02-15T21:31:21.660", "LastActivityDate": "2011-02-15T21:31:21.660"}, "5009821": {"ParentId": "5009737", "CommentCount": "6", "Body": "<p>Undefined behavior is undefined behavior.  You can't expect it to do anything in particular, including crash.</p>\n<p>There is no compiler I know of that will catch all types of UB and I don't think it's possible.  You could crank up the warning level of your compiler but I don't think it would even warn you then.  Your use of get() as the way of capturing a reference to a local variable will, I believe, effectively hide the fact that this is what you're doing from most, if not all compilers.  The amount of effort that would be required to catch such instances of suicide don't seem to me to be worth it.</p>\n<p>That's just part of the life of a C++ developer.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "5009821", "Score": "6", "CreationDate": "2011-02-15T21:36:48.897", "LastActivityDate": "2011-02-15T21:36:48.897"}, "bq_ids": {"n4140": {"so_5009737_5009814_1": {"section_id": 5768, "quality": 0.7407407407407407, "length": 40}}, "n3337": {"so_5009737_5009814_1": {"section_id": 5541, "quality": 0.7407407407407407, "length": 40}}, "n4659": {"so_5009737_5009814_1": {"section_id": 7225, "quality": 0.7407407407407407, "length": 40}}}, "5009825": {"ParentId": "5009737", "CommentCount": "0", "Body": "<p>In addition to what everyone said, the typical stack implementation on a modern OS allocates stack in 4-8KB increments (pages). Stack usage at program startup is typically small, the object data exists several bytes past the top of stack. Even if only one stack page is allocated, there's a decent chunk of prefectly read-writeable space past the stack top. So reading from that memory does not cause a runtime error.</p>\n<p>But yes, it's an undefined behavior.</p>\n", "OwnerUserId": "219159", "PostTypeId": "2", "Id": "5009825", "Score": "0", "CreationDate": "2011-02-15T21:37:04.980", "LastActivityDate": "2011-02-15T21:37:04.980"}});