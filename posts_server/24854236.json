post_cb({"24855566": {"ParentId": "24854236", "CommentCount": "4", "Body": "<p>For me this case looks legit and there is no undefined behaviour.</p>\n<p><ol>\n<li>He is using type-punning and it is legit because it B* b and C* c in union members  is a pointers and could be converted to char array.</li>\n<li>Both B and C have virtual destructor because of base class (not because base is a same! but because base have virtual destructor).</li></ol></p>\n<blockquote>\n<p id=\"so_24854236_24855566_0\">12.4.9 If a class has a base class with a virtual destructor, its destructor (whether user- or implicitly-declared) is virtual.</p></blockquote>\n<li>While destructor call, (because it is virtual) exact function address will be picked up from choice variable and proper destructor sequence will be called. So there is no ANY undefined behaviour at all.</li>\n", "OwnerUserId": "3853514", "PostTypeId": "2", "Id": "24855566", "Score": "-1", "CreationDate": "2014-07-20T22:37:20.817", "LastActivityDate": "2014-07-20T22:37:20.817"}, "24854236": {"CommentCount": "9", "ViewCount": "142", "CreationDate": "2014-07-20T19:43:58.167", "LastActivityDate": "2014-07-20T22:37:20.817", "Title": "Can I delete a union component without checking whether it stores that object?", "AcceptedAnswerId": "24854287", "PostTypeId": "1", "Id": "24854236", "Score": "0", "Body": "<p>I mean the following. I have a few classes which inherit the same base class. Union consists of pointers of these classes:</p>\n<pre><code>#include \"stdio.h\"\n\nclass A {\npublic:\n    A() { printf(\"A\\n\"); }\n    virtual ~A() { printf(\"~A\\n\"); }\n};\n\nclass B  : public A {\npublic:\n    B() { printf(\"B\\n\"); }\n    virtual ~B() { printf(\"~B\\n\"); }\n};\n\nclass C : public A {\npublic:\n    C() { printf(\"C\\n\"); }\n    virtual ~C() { printf(\"~C\\n\"); }\n};\n\nint main() {\n    union {\n        B* b;\n        C* c;\n    } choice;\n    choice.b = new B();\n    delete choice.c;    //We have B object, but deleting C\n    return 0;\n}\n</code></pre>\n<p>It seems to work, but I'm not sure if it isn't implementation-specific behaviour. Can I use such weird deleting method or should I remember a type of stored object and delete it respectively?</p>\n<p>P.S. I use C++11 and want it works on both GCC and Visual C++ (2012 and higher). In a real project I have more complex class hierarchy but all of them are successors (directly or indirectly) of the same abstract base class</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2717575", "AnswerCount": "4"}, "24854287": {"ParentId": "24854236", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is a double dose of undefined behavior. First, you can't <code>delete</code> a <code>B</code> through a pointer to <code>C</code>. \u00a75.3.5 [expr.delete]/p3:</p>\n<blockquote>\n<p id=\"so_24854236_24854287_0\">In the first alternative (delete object), if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and the static type shall have a virtual destructor or the\n  behavior is undefined. In the second alternative (delete array) if the\n  dynamic type of the object to be deleted differs from its static type,\n  the behavior is undefined.</p>\n</blockquote>\n<p>Second, <a href=\"https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-undefined\">accessing the inactive member of a union</a> is also undefined behavior in C++. </p>\n<p>There's no need to use an union here anyway. <code>B</code> and <code>C</code> share the same base class, so you can just store the pointer in an <code>A *</code>.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:57:44.487", "Id": "24854287", "Score": "5", "CreationDate": "2014-07-20T19:51:51.400", "LastActivityDate": "2014-07-20T19:59:01.600"}, "24854437": {"ParentId": "24854236", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As it has been said in other answer, this is not proper C++.</p>\n<p>My impression is that you want to keep an union of pointers because in certain circumstances you need an instance of a (sub)class of <code>B</code>, and in another an instance of <code>C</code>, with the issue of <code>B</code> and <code>C</code> having not quite the same interface. Perhaps you store several of these in a container, or simply you don't know until runtime which instance will be used. </p>\n<p>So you may keep your code as it was, with perhaps a type tag somewhere indicating which instance has been created, and then use a <code>switch</code> each time you need to determine the correct code to run, or you could leverage your classes to actually invoke the proper function at run time, by including in the common base class of <code>B</code> and <code>C</code><sup>(1)</sup> a virtual method, and overload this method in <code>B</code> and <code>C</code> with the proper branch of the <code>switch</code>, then replace the union with a simple pointer to the base class.</p>\n<hr>\n<p><sub>(1) that base class doesn't have to be <code>A</code>: if you don't want to clutter your class tree, just make a different class having the minimal interface needed there, and thanks to C++ <em>multiple inheritance</em>, have <code>B</code> and <code>C</code> inherit from it as well. Don't forget the virtual destructor!</sub></p>\n</hr>", "OwnerUserId": "1769720", "LastEditorUserId": "1769720", "LastEditDate": "2014-07-20T20:15:30.637", "Id": "24854437", "Score": "1", "CreationDate": "2014-07-20T20:07:35.140", "LastActivityDate": "2014-07-20T20:15:30.637"}, "24854284": {"ParentId": "24854236", "CommentCount": "4", "Body": "<p>You shouldn't. You are only allowed to read from the union member you last wrote into and you're only allowed to delete an object through a pointer to a base class (if it has a virtual destructor). It may seem to work now, but you may find it to break randomly in the future, usually due to an aggressive optimizer.</p>\n<p>Why don't you store a pointer to <code>A</code> instead of the union?</p>\n", "OwnerUserId": "89847", "PostTypeId": "2", "Id": "24854284", "Score": "2", "CreationDate": "2014-07-20T19:51:35.387", "LastActivityDate": "2014-07-20T19:51:35.387"}, "bq_ids": {"n4140": {"so_24854236_24855566_0": {"section_id": 405, "quality": 0.9166666666666666, "length": 11}, "so_24854236_24854287_0": {"section_id": 6107, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_24854236_24855566_0": {"section_id": 396, "quality": 0.9166666666666666, "length": 11}, "so_24854236_24854287_0": {"section_id": 5873, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_24854236_24855566_0": {"section_id": 423, "quality": 0.9166666666666666, "length": 11}, "so_24854236_24854287_0": {"section_id": 7604, "quality": 0.9512195121951219, "length": 39}}}});