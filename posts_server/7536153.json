post_cb({"7536230": {"Id": "7536230", "PostTypeId": "2", "Body": "<p>Yes, it is guaranteed to copy properly.</p>\n<p>Quoting the FDIS, \u00a73.9/2:</p>\n<blockquote>\n<p id=\"so_7536153_7536230_0\">For any object (other than a base-class subobject) of <strong>trivially copyable type</strong> <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes making up the object can be copied into an array of <code>char</code> or <code>unsigned char</code>. If the content of the array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall subsequently hold its original value.</p>\n</blockquote>\n<p>And \u00a73.9/3:</p>\n<blockquote>\n<p id=\"so_7536153_7536230_1\">For any <strong>trivially copyable type</strong> <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes making up <code>obj1</code> are copied into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>.</p>\n</blockquote>\n<p>So the requirements you're asking about are, \u00a73.9/9:</p>\n<blockquote>\n<p id=\"so_7536153_7536230_2\">Arithmetic types, enumeration types, pointer types, pointer to member types, <code>std::nullptr_t</code>, and cv-qualified versions of these types are collectively called <em>scalar types</em>. Scalar types, POD classes, arrays of such types and <em>cv-qualified</em> versions of these types are collectively called <em>POD types</em>. <strong>Scalar types, trivially copyable class types, arrays of such types, and cv-qualified versions of these types are collectively called <em>trivially copyable types</em></strong>.</p>\n</blockquote>\n<p>And \u00a79/6:</p>\n<blockquote>\n<p id=\"so_7536153_7536230_3\">A <em>trivially copyable class</em> is a class that:</p>\n<ul>\n<li>has no non-trivial copy constructors,</li>\n<li>has no non-trivial move constructors,</li>\n<li>has no non-trivial copy assignment operators,</li>\n<li>has no non-trivial move assignment operators, and</li>\n<li>has a trivial destructor.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "636019", "LastActivityDate": "2011-09-24T01:23:51.337", "Score": "9", "CreationDate": "2011-09-24T00:48:00.563", "ParentId": "7536153", "CommentCount": "2", "LastEditDate": "2011-09-24T01:23:51.337", "OwnerUserId": "636019"}, "bq_ids": {"n4140": {"so_7536153_7536230_3": {"length": 4, "quality": 1.0, "section_id": 4706}, "so_7536153_7536245_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 7200}, "so_7536153_7536230_1": {"length": 30, "quality": 0.967741935483871, "section_id": 7201}, "so_7536153_7536185_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 5850}, "so_7536153_7536230_0": {"length": 40, "quality": 0.975609756097561, "section_id": 7200}, "so_7536153_7536185_0": {"length": 30, "quality": 0.967741935483871, "section_id": 7201}, "so_7536153_7536230_2": {"length": 45, "quality": 0.9375, "section_id": 7207}}, "n3337": {"so_7536153_7536230_3": {"length": 4, "quality": 1.0, "section_id": 4515}, "so_7536153_7536185_0": {"length": 30, "quality": 0.967741935483871, "section_id": 6945}, "so_7536153_7536185_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 5620}, "so_7536153_7536230_1": {"length": 30, "quality": 0.967741935483871, "section_id": 6945}, "so_7536153_7536230_2": {"length": 47, "quality": 0.9791666666666666, "section_id": 6951}, "so_7536153_7536230_0": {"length": 40, "quality": 0.975609756097561, "section_id": 6944}, "so_7536153_7536245_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 6944}}, "n4659": {"so_7536153_7536230_3": {"length": 4, "quality": 1.0, "section_id": 6103}, "so_7536153_7536245_0": {"length": 36, "quality": 0.8780487804878049, "section_id": 8709}, "so_7536153_7536230_2": {"length": 42, "quality": 0.875, "section_id": 8716}, "so_7536153_7536230_1": {"length": 30, "quality": 0.967741935483871, "section_id": 8710}, "so_7536153_7536230_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 8709}, "so_7536153_7536185_0": {"length": 30, "quality": 0.967741935483871, "section_id": 8710}}}, "7536153": {"ViewCount": "682", "Body": "<p>The C++11 standard guarantees that byte-for-byte copies are always valid for POD types.  But what about certain trivial types?</p>\n<p>Here's an example:</p>\n<pre><code>struct trivial\n{\n  int x;\n  int y;\n  trivial(int i) : x(2 * i) { std::cout &lt;&lt; \"Constructed.\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>If I were to copy this struct, byte-for-byte, is it guaranteed to copy properly, even though it isn't technically a POD?  When is the line drawn as to when it's <em>not</em> okay to byte-copy an object?</p>\n", "AcceptedAnswerId": "7536230", "Title": "Byte-for-byte copies of types in C++11?", "CreationDate": "2011-09-24T00:32:47.740", "Id": "7536153", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-09-24T00:34:30.717", "LastEditorUserId": "36723", "LastActivityDate": "2011-09-24T01:23:51.337", "Score": "4", "OwnerUserId": "646385", "Tags": "<c++><c++11><language-lawyer><trivial><standard-layout>", "AnswerCount": "3"}, "7536185": {"Id": "7536185", "PostTypeId": "2", "Body": "<p>If the standard states it's only defined for POD types (I haven't examined the C++11 standard in detail yet so I don't know if your contention is correct or not <sup>(a)</sup>) and you do it for a non-POD type, it's not defined behaviour. Period.</p>\n<p>It may work, on some implementations, in some environments at certain times of the day, when the planets are aligned. It may work the vast majority of times. That still doesn't make it a good idea if you value portability.</p>\n<hr>\n<p><sup>(a)</sup> After more investigation, it appears your particular case is okay. Section 3.9/3 of the standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">n3242 draft</a>, but I'd be surprised if it had changed much from this late draft) states:</p>\n<blockquote>\n<p id=\"so_7536153_7536185_0\">For any trivially copyable type T, if two pointers to T point to distinct T objects obj1 and obj2 where neither obj1 nor obj2 is a base-class subobject, if the underlying bytes making up obj1 are copied into obj2, obj2 shall subsequently hold the same value as obj1.</p>\n</blockquote>\n<p>Section 9 defines (at a high level) what \"trivially copyable\" means:</p>\n<blockquote>\n<p id=\"so_7536153_7536185_1\">A trivially copyable class is a class that:<br>\n   - has no non-trivial copy constructors (12.8),<br>\n   - has no non-trivial move constructors (12.8),<br>\n   - has no non-trivial copy assignment operators (13.5.3, 12.8),<br>\n   - has no non-trivial move assignment operators (13.5.3, 12.8), and<br>\n   - has a trivial destructor (12.4).<br/></br></br></br></br></br></p>\n</blockquote>\n<p>with the referenced sections going into more detail on each area, <code>12.8</code> for copying and moving class objects and <code>13.5.3</code> for assignments.</p>\n</hr>", "LastEditorUserId": "14860", "LastActivityDate": "2011-09-24T01:19:30.920", "Score": "3", "CreationDate": "2011-09-24T00:39:03.047", "ParentId": "7536153", "CommentCount": "11", "LastEditDate": "2011-09-24T01:19:30.920", "OwnerUserId": "14860"}, "7536245": {"Id": "7536245", "PostTypeId": "2", "Body": "<p>C++11 broke the definition of POD types into more useful categories, specifically 'trivial' and 'standard layout'.  Your example is standard layout, and trivally copyable, although the constructor prevents it from being fully trivial.  Trivially copyable types are guaranteed to be safely byte-wise copied:</p>\n<blockquote>\n<p id=\"so_7536153_7536245_0\">For any object (other than a base-class subobject) of trivially\n  copyable type T, whether or not the object holds a valid value of type\n  T, the underlying bytes (1.7) making up the object can be copied into\n  an array of char or unsigned char.40 If the content of the array of\n  char or unsigned char is copied back into the object, the object shall\n  subsequently hold its original value.</p>\n</blockquote>\n<p>So no, POD status is not required to be safely copied that way, but it is possible to identify the subset of non-POD types that can be.</p>\n", "LastActivityDate": "2011-09-24T00:53:38.763", "Score": "4", "CreationDate": "2011-09-24T00:53:38.763", "ParentId": "7536153", "CommentCount": "0", "OwnerUserId": "293791"}});