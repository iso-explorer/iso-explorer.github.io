post_cb({"bq_ids": {"n4140": {"so_39719557_39720975_2": {"length": 17, "quality": 1.0, "section_id": 7152}, "so_39719557_39720975_1": {"length": 14, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_39719557_39720975_2": {"length": 17, "quality": 1.0, "section_id": 6896}, "so_39719557_39720975_1": {"length": 14, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_39719557_39720975_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 8653}, "so_39719557_39720975_1": {"length": 8, "quality": 0.5714285714285714, "section_id": 8655}}}, "39720975": {"Id": "39720975", "PostTypeId": "2", "Body": "<p>Let's start with C. Asking this for C is like asking: If a tree falls in a forest and no one is around to hear it, does it make a sound? It doesn't matter because there is no way to write a valid C program that can tell the difference. This means that it would be pointless for the standard to define this. All we need to know is that by the time any code runs variables with static storage duration have been initialized. The <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">C11 standard draft</a> spells it out in section 5.1.2:</p>\n<blockquote>\n<p id=\"so_39719557_39720975_0\">All objects with static storage duration shall be initialized (set to their initial values) before program startup. The manner and timing of such initialization are otherwise unspecified.</p>\n</blockquote>\n<p>In C++ on the other hand, things aren't that easy. It is possible to observe the order of initialization during dynamic initialization. In the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">standard draft</a> we find section 3.6.2. It quickly gets complicated. It defines the order as: first we do static initialization (this is equivalent to the only thing C can do) and after that dynamic initialization is done. So far so good. We get to this part:</p>\n<blockquote>\n<p id=\"so_39719557_39720975_1\">Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit.</p>\n</blockquote>\n<p>and everything is still ok in the world. But then things quickly fall apart:</p>\n<blockquote>\n<p id=\"so_39719557_39720975_2\">An implementation is permitted to perform the initialization of a non-local variable with static storage duration as a static initialization even if such initialization is not required to be done statically</p>\n</blockquote>\n<p>This sentence moves us from a predictable world to \"it's complicated\". The code example in that section of the standard explains this perfectly:</p>\n<pre><code>inline double fd() { return 1.0; }\nextern double d1;\ndouble d2 = d1;   // unspecified:\n                  // may be statically initialized to 0.0 or\n                  // dynamically initialized to 0.0 if d1 is\n                  // dynamically initialized, or 1.0 otherwise\ndouble d1 = fd(); // may be initialized statically or dynamically to 1.0\n</code></pre>\n<p>In short, in C it doesn't matter, in C++ if you write code that depends on this you'll quite likely to run into trouble when you change compilers.</p>\n<p>So your quote is doubly incorrect. Not only isn't initialization done in order of declaration (it's static first, then dynamic), it's also quite fuzzy what is actually static and what is dynamic.</p>\n", "LastActivityDate": "2016-09-27T09:26:30.903", "CommentCount": "0", "CreationDate": "2016-09-27T09:26:30.903", "ParentId": "39719557", "Score": "7", "OwnerUserId": "939410"}, "39719557": {"ViewCount": "129", "Body": "<p><a href=\"https://stackoverflow.com/questions/211237/static-variables-initialisation-orderhttp://\">Here</a> it is states that </p>\n<blockquote>\n<p id=\"so_39719557_39719557_0\">C++ guarantees that variables in a compilation unit (.cpp file) are\n  initialized in order of declaration</p>\n</blockquote>\n<p>Is this the same for C? </p>\n<p>Can you quote the relevant standard passages for both C and C++?</p>\n", "Title": "Where does the C++ standard say, and does C say the same: variables in a compilation unit (.cpp file) are initialised in order of declaration", "CreationDate": "2016-09-27T08:16:59.280", "LastActivityDate": "2016-09-27T09:38:28.053", "CommentCount": "11", "LastEditDate": "2017-05-23T12:00:50.697", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "39719557", "Score": "1", "OwnerUserId": "4675668", "Tags": "<c++><c>", "AnswerCount": "3"}, "39719811": {"Id": "39719811", "PostTypeId": "2", "Body": "<p>In C++ the order of initialisation has to be defined, since there may be constructors which are called in the initialisation of a variable. Thus C++ defines in which order this code is executed. In plain C there are no constructors. There is no way to tell in which order the variables are initialised, as long as each variable gets initialised before any code that can access the variable is executed.</p>\n", "LastActivityDate": "2016-09-27T08:31:02.673", "CommentCount": "7", "CreationDate": "2016-09-27T08:31:02.673", "ParentId": "39719557", "Score": "2", "OwnerUserId": "5998125"}, "39721069": {"Id": "39721069", "PostTypeId": "2", "Body": "<p>The C standard (C11) 6.7.6 says</p>\n<blockquote>\n<p id=\"so_39719557_39721069_0\">A full declarator is a declarator that is not part of another\n  declarator. The end of a full declarator is a sequence point.</p>\n</blockquote>\n<p>Meaning that at the end of each declaration, the initialization must be done and all sub-expressions must have been evaluated for side effects. </p>\n<p>When the actual code is executed isn't specified. Meaning it could be done long before the line where the initialization takes place, but not after that line.</p>\n<p>Variables with static storage duration is a special case, since they are guaranteed to be initialized before program startup. Their order of execution wouldn't matter in C, since they can't depend on each other (must be initialized to constant expressions). </p>\n<p>In C++, class objects with static storage duration are initialized in an unspecified order and therefore they shouldn't be written so that they rely on each other to be initialized in a certain order.</p>\n<p>Also please note 6.7.9/23:</p>\n<blockquote>\n<p id=\"so_39719557_39721069_1\">The evaluations of the initialization list expressions are\n  indeterminately sequenced with respect to one another and thus the\n  order in which any side effects occur is unspecified.</p>\n</blockquote>\n<p>Meaning that we can't know the order in which all initializers part of the same declaration are executed. </p>\n<p>I believe C and C++ are identical in all of the above, though C++ will also execute constructors as part of the initialization.</p>\n", "LastEditorUserId": "584518", "LastActivityDate": "2016-09-27T09:38:28.053", "Score": "0", "CreationDate": "2016-09-27T09:31:21.153", "ParentId": "39719557", "CommentCount": "0", "OwnerUserId": "584518", "LastEditDate": "2016-09-27T09:38:28.053"}});