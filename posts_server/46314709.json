post_cb({"bq_ids": {"n4140": {"so_46314709_46314790_0": {"length": 30, "quality": 0.6976744186046512, "section_id": 3277}}, "n3337": {"so_46314709_46314790_0": {"length": 30, "quality": 0.6976744186046512, "section_id": 3148}}, "n4659": {"so_46314709_46314790_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 4035}}}, "46314709": {"ViewCount": "46", "Body": "<p>I came across the following confusing example involving ADL and deleted functions:</p>\n<p>First Example:</p>\n<pre><code>namespace A\n{\n    struct S{};\n\n    void f(S){cout &lt;&lt; \"adl\" &lt;&lt; endl;}\n}\n\nnamespace C\n{\n    //void f() = delete;\n\n    //void f (double);\n\n    void test()\n    {\n        A::S arg;\n        f(arg);\n    }\n}\n\n\nint main()\n{\n    C::test();\n\n    return 0;\n}\n</code></pre>\n<p>As expected, <code>A::f</code> is called through ADL. In the next example, there is a deleted function with the same name in <code>C</code>:</p>\n<pre><code>namespace A\n{\n    struct S{};\n\n    void f(S){cout &lt;&lt; \"adl\" &lt;&lt; endl;}\n}\n\nnamespace C\n{\n    void f() = delete;\n\n    //void f (double);\n\n    void testi()\n    {\n        A::S arg;\n        f(arg);\n    }\n}\n\n\nint main()\n{\n    C::testi();\n\n    return 0;\n}\n</code></pre>\n<p>Compiling fails with the error message <code>error: use of deleted function 'void C::f()'</code>. Apparently, the deleted functions stops the ADL version from getting into the overloading table. Now for the last example: In addition to the deleted function there is now another, not-deleted, function with the same name:</p>\n<pre><code>namespace A\n{\n    struct S{};\n\n    void f(S){cout &lt;&lt; \"adl\" &lt;&lt; endl;}\n}\n\nnamespace C\n{\n    void f() = delete;\n\n    void f (double);\n\n    void testi()\n    {\n        A::S arg;\n        f(arg);\n    }\n}\n\n\nint main()\n{\n    C::testi();\n\n    return 0;\n}\n</code></pre>\n<p>Running this executes the ADL version of <code>f</code>. So in conclusion:</p>\n<ul>\n<li>Having no matching function the current namespace results in the ADL version being called</li>\n<li>Having just the deleted function in the current namespace results in an error, probably because the ADL version is not discovered at all</li>\n<li>Having another, non-deleted, function in the current namespace results in the ADL version being called.</li>\n</ul>\n<p>My questions: Is this behaviour intentional? If so, which part of the standard specifies this?</p>\n<p>Edit: I forgot to mention that I used onlinegdb for compilation, so gcc/g++ was used.</p>\n", "AcceptedAnswerId": "46314790", "Title": "Deleted function and ADL", "CreationDate": "2017-09-20T06:26:05.017", "Id": "46314709", "CommentCount": "0", "LastEditDate": "2017-09-20T06:32:14.603", "PostTypeId": "1", "LastEditorUserId": "4747021", "LastActivityDate": "2017-09-20T06:36:56.663", "Score": "1", "OwnerUserId": "4747021", "Tags": "<c++><function-overloading><argument-dependent-lookup>", "AnswerCount": "1"}, "46314790": {"Id": "46314790", "PostTypeId": "2", "Body": "<p>Definite compiler bug. To quote the C++ standard draft (n4659) <a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.fct.def.delete#2\" rel=\"nofollow noreferrer\">[dcl.fct.def.delete]/2</a>:</p>\n<blockquote>\n<p id=\"so_46314709_46314790_0\">A program that refers to a deleted function implicitly or explicitly,\n  other than to declare it, is ill-formed. [\u2009Note: This includes calling\n  the function implicitly or explicitly and forming a pointer or\n  pointer-to-member to the function. It applies even for references in\n  expressions that are not potentially-evaluated. <strong>If a function is\n  overloaded, it is referenced only if the function is selected by\n  overload resolution</strong>. The implicit odr-use of a virtual function does\n  not, by itself, constitute a reference. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Overload resolution cannot select that overload by ADL. So this function shouldn't be referenced. The second code sample is a well-formed C++ program (if the missing include directives are put back in).</p>\n<hr>\n<p>You mentioned using g++ to compile, note that this issue is <a href=\"http://coliru.stacked-crooked.com/a/ac2337642802bd2f\" rel=\"nofollow noreferrer\">fixed in GCC 7.2.0</a></p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2017-09-20T06:36:56.663", "Score": "1", "CreationDate": "2017-09-20T06:31:26.023", "ParentId": "46314709", "CommentCount": "3", "LastEditDate": "2017-09-20T06:36:56.663", "OwnerUserId": "817643"}});