post_cb({"12834281": {"CommentCount": "0", "AcceptedAnswerId": "12834899", "CreationDate": "2012-10-11T07:24:34.877", "LastActivityDate": "2012-10-11T09:05:59.630", "PostTypeId": "1", "ViewCount": "931", "FavoriteCount": "0", "Title": "How is the storage associated with std::future allocated?", "Id": "12834281", "Score": "11", "Body": "<p>One way to get a <code>std::future</code> is through <code>std::async</code>:</p>\n<pre><code>int foo()\n{\n  return 42;\n}\n\n...\n\nstd::future&lt;int&gt; x = std::async(foo);\n</code></pre>\n<p>In this example, how is the storage for <code>x</code>'s asynchronous state allocated, and which thread (if more than one thread is involved) is responsible for performing the allocation? Moreover, does a client of <code>std::async</code> have any control over the allocation?</p>\n<p>For context, I see that <a href=\"http://en.cppreference.com/w/cpp/thread/promise/promise\" rel=\"noreferrer\">one of the constructors</a> of <code>std::promise</code> may receive an allocator, but it's not clear to me if it is possible to customize the allocation of the <code>std::future</code> at the level of <code>std::async</code>.</p>\n", "Tags": "<c++><asynchronous><c++11><future><c++-standard-library>", "OwnerUserId": "722294", "AnswerCount": "2"}, "12834899": {"ParentId": "12834281", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Just judging from the mere arguments of <a href=\"http://en.cppreference.com/w/cpp/thread/async\" rel=\"nofollow\"><code>std::async</code></a> there seems to be no way to control the allocation of the internal <code>std::promise</code> and it can therefore just use anything, though likely the <code>std::allocator</code>. Though I guess in theory it is unspecified, it is likely the shared state is allocated inside the calling thread. I haven't found any explicit information in the standard about this matter. In the end <code>std::async</code> is a very specialized facility for easy asynchronous invocation, so you don't have to think if there actually <strong>is</strong> a <code>std::promise</code> anywhere.</p>\n<p>For more direct control about the behaviour of an asynchronous call there is also <a href=\"http://en.cppreference.com/w/cpp/thread/packaged_task\" rel=\"nofollow\"><code>std::packaged_task</code></a>, which indeed has an allocator argument. But from the mere standard quote it is not perfectly clear if this allocator is just used to allocate storage for the function (since <code>std::packaged_task</code> is kind of a special <code>std::function</code>) or if it is also used to allocate the shared state of the internal <code>std::promise</code>, though it seems likely:</p>\n<p>30.6.9.1 [futures.task.members]:</p>\n<blockquote>\n<p id=\"so_12834281_12834899_0\"><em>Effects:</em> constructs a new <code>packaged_task</code> object with a shared state and\n  initializes the object\u2019s stored task with <code>std::forward&lt;F&gt;(f)</code>. The\n  constructors that take an <code>Allocator</code> argument use it to allocate memory\n  needed to store the internal data structures.</p>\n</blockquote>\n<p>Well, it doesn't even say there <strong>is</strong> a <code>std::promise</code> underneath (likewise for <code>std::async</code>), it could just be an undefined type connectable to a <code>std::future</code>.</p>\n<p>So if it is indeed not specified how <code>std::packaged_task</code> allocates its internal shared state, your best bet might be to implement your own facilities for asynchronous function invocation. Considering that, simply spoken, a <code>std::packaged_task</code> is just a <code>std::function</code> bundled with a <code>std::promise</code> and <code>std::async</code> just starts a <code>std::packaged_task</code> in a new thread (well, except when it doesn't), this shouldn't be too much of a problem.</p>\n<p>But indeed this might be an oversight in the specification. Whereas allocation control doesn't really fit to <code>std::async</code>, the explanation of <code>std::packaged_task</code> and its use of allocators might be a bit clearer. But this may also be intentional, so the <code>std::packaged_task</code> is free to use whatever it wants and doesn't even need a <code>std::promise</code> internally.</p>\n<p><strong>EDIT:</strong> Reading it again, I think the above standard quote indeed says, that the <code>std::packaged_task</code>'s shared state <strong>is</strong> allocated using the provided allocator, since it is part of the <em>\"internal data structures\"</em>, whatever those are (there doesn't need to be an actual <code>std::promise</code>, though). So I think <code>std::packaged_task</code> should be enough for having explicit control of the shared state of an asynchronous task's <code>std::future</code>.</p>\n", "OwnerUserId": "743214", "LastEditorUserId": "743214", "LastEditDate": "2012-10-11T08:17:48.977", "Id": "12834899", "Score": "5", "CreationDate": "2012-10-11T08:04:06.753", "LastActivityDate": "2012-10-11T08:17:48.977"}, "12834871": {"ParentId": "12834281", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The memory is allocated by the thread that calls <code>std::async</code>, and you have no control over how it is done. Typically it will be done by some variant of <code>new __internal_state_type</code>, but there is no guarantee; it may use <code>malloc</code>, or an allocator specifically chosen for the purpose.</p>\n<p>From 30.6.8p3 [futures.async]:</p>\n<blockquote>\n<p id=\"so_12834281_12834871_0\">\"Effects: The first function behaves the same as a call to the second function with a policy argument of <code>launch::async | launch::deferred</code> and the same arguments for <code>F</code> and <code>Args</code>. The second function creates a shared state that is associated with the returned future object. ...\"</p>\n</blockquote>\n<p>The \"first function\" is the overload without a launch policy, whilst the second is the overload with a launch policy.</p>\n<p>In the case of <code>std::launch::deferred</code>, there is no other thread, so everything must happen on the calling thread. In the case of <code>std::launch::async</code>, 30.6.8p3 goes on to say:</p>\n<blockquote>\n<p id=\"so_12834281_12834871_1\">\u2014 if <code>policy &amp; launch::async</code> is non-zero \u2014 calls <code>INVOKE (DECAY_COPY (std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code> (20.8.2, 30.3.1.2) as if in a new thread of execution represented by a thread object <strong>with the calls to <code>DECAY_COPY ()</code> being evaluated in the thread that called <code>async</code>.</strong> ...</p>\n</blockquote>\n<p>I've added the emphasis. Since the copy of the function and arguments has to happen in the calling thread, this essentially requires that the shared state is allocated by the calling thread.</p>\n<p>Of course, you could write an implementation that started the new thread, waited for it to allocate the state, and then returned a <code>future</code> that referenced that, but why would you?</p>\n", "OwnerUserId": "5597", "LastEditorUserId": "5597", "LastEditDate": "2012-10-11T09:05:59.630", "Id": "12834871", "Score": "5", "CreationDate": "2012-10-11T08:01:53.343", "LastActivityDate": "2012-10-11T09:05:59.630"}, "bq_ids": {"n4140": {"so_12834281_12834871_1": {"section_id": 3161, "quality": 0.6666666666666666, "length": 16}, "so_12834281_12834899_0": {"section_id": 3172, "quality": 0.92, "length": 23}, "so_12834281_12834871_0": {"section_id": 3161, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_12834281_12834871_1": {"section_id": 3034, "quality": 0.6666666666666666, "length": 16}, "so_12834281_12834899_0": {"section_id": 3045, "quality": 0.92, "length": 23}, "so_12834281_12834871_0": {"section_id": 3034, "quality": 0.8846153846153846, "length": 23}}, "n4659": {"so_12834281_12834871_1": {"section_id": 3923, "quality": 0.625, "length": 15}, "so_12834281_12834871_0": {"section_id": 3923, "quality": 0.8846153846153846, "length": 23}}}});