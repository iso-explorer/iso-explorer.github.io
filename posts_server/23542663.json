post_cb({"bq_ids": {"n4140": {"so_23542663_23543096_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 5768}}, "n3337": {"so_23542663_23543096_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 5541}}, "n4659": {"so_23542663_23543096_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 7225}}}, "23542663": {"ViewCount": "145", "Body": "<p>Is the following a case of static, or dynamic binding? Since I can know, what is the class of object my pointer is pointing to at compile time, my guess is that it is static...</p>\n<pre><code>class Base \n{\nvoid print() const;\n};\n\nclass Derived : public Base \n{\nvoid print() const;\n};\n\nint main()\n{\nBase base;\nBase *basePtr = &amp;base;\nbasePtr-&gt;print();\n}\n</code></pre>\n<p>And why we should use dynamic binding over static? I don't understand why we should use virtual functions instead of simply call a function in this way <code>base.print()</code> (for the example above). This method already \"understand\" which <code>print()</code> function call for the right class of the object, without using polymorphism and virtual functions.</p>\n<hr>\n<h2>Update</h2>\n<pre><code>  // Point class definition represents an x-y coordinate pair.\n  #ifndef POINT_H\n  #define POINT_H\n\n  class Point {\n\n  public:\n     Point( int = 0, int = 0 ); // default constructor\n\n   void setX( int );  // set x in coordinate pair\n   int getX() const;  // return x from coordinate pair\n\n   void setY( int );  // set y in coordinate pair\n   int getY() const;  // return y from coordinate pair\n\n   virtual void print() const;  // output Point object\n\nprivate: \n   int x;  // x part of coordinate pair\n   int y;  // y part of coordinate pair\n\n}; // end class Point\n\n#endif\n</code></pre>\n<hr>\n<pre><code>  // Circle class contains x-y coordinate pair and radius.\n  #ifndef CIRCLE_H\n  #define CIRCLE_H\n\n  #include \"point.h\"  // Point class definition\n\n  class Circle : public Point {\n\npublic:\n\n   // default constructor\n   Circle( int = 0, int = 0, double = 0.0 );  \n\n   void setRadius( double );   // set radius\n   double getRadius() const;   // return radius\n\n   double getDiameter() const;       // return diameter\n   double getCircumference() const;  // return circumference\n   double getArea() const;           // return area\n\n   virtual void print() const;       // output Circle object\n\nprivate: \n   double radius;  // Circle's radius\n\n}; // end class Circle\n\n#endif \n</code></pre>\n<hr>\n<pre><code>  // Introducing polymorphism, virtual functions and dynamic\n  // binding.\n  #include &lt;iostream&gt;\n\n  using std::cout;\n  using std::endl;\n  using std::fixed;\n\n#include &lt;iomanip&gt;\n\nusing std::setprecision;\n\n#include \"point.h\"   // Point class definition\n#include \"circle.h\"  // Circle class definition\n\nint main()\n{\n   Point point( 30, 50 );\n   Point *pointPtr = 0;\n\n   Circle circle( 120, 89, 2.7 );\n   Circle *circlePtr = 0; \n  // set floating-point numeric formatting\n   cout &lt;&lt; fixed &lt;&lt; setprecision( 2 );\n\n   // output objects point and circle using static binding\n   cout &lt;&lt; \"Invoking print function on point and circle \"\n        &lt;&lt; \"\\nobjects with static binding \"\n        &lt;&lt; \"\\n\\nPoint: \";\n   point.print();         // static binding\n   cout &lt;&lt; \"\\nCircle: \";\n   circle.print();        // static binding\n\n   // output objects point and circle using dynamic binding\n   cout &lt;&lt; \"\\n\\nInvoking print function on point and circle \"\n        &lt;&lt; \"\\nobjects with dynamic binding\";\n\n   // aim base-class pointer at base-class object and print\n   pointPtr = &amp;point;                                      \n   cout &lt;&lt; \"\\n\\nCalling virtual function print with base-class\"\n        &lt;&lt; \"\\npointer to base-class object\"\n        &lt;&lt; \"\\ninvokes base-class print function:\\n\";\n   pointPtr-&gt;print();\n   // aim derived-class pointer at derived-class\n   // object and print                          \n   circlePtr = &amp;circle;                         \n   cout &lt;&lt; \"\\n\\nCalling virtual function print with \"\n        &lt;&lt; \"\\nderived-class pointer to derived-class object \"\n        &lt;&lt; \"\\ninvokes derived-class print function:\\n\";\n   circlePtr-&gt;print();\n\n   // aim base-class pointer at derived-class object and print\n   pointPtr = &amp;circle;                                        \n   cout &lt;&lt; \"\\n\\nCalling virtual function print with base-class\"\n        &lt;&lt; \"\\npointer to derived-class object \"\n        &lt;&lt; \"\\ninvokes derived-class print function:\\n\";\n   pointPtr-&gt;print();  // polymorphism: invokes circle's print\n   cout &lt;&lt; endl;\n\n   return 0;\n\n} // end main\n</code></pre>\n</hr></hr></hr>", "AcceptedAnswerId": "23543155", "Title": "Is this dynamic or static binding?", "CreationDate": "2014-05-08T13:07:23.067", "Id": "23542663", "CommentCount": "5", "LastEditDate": "2014-05-08T14:48:12.197", "PostTypeId": "1", "LastEditorUserId": "3379939", "LastActivityDate": "2014-05-08T14:48:12.197", "Score": "2", "OwnerUserId": "3379939", "Tags": "<c++><binding><polymorphism>", "AnswerCount": "3"}, "23543096": {"Id": "23543096", "PostTypeId": "2", "Body": "<p>There is no any dynamic binding in your example. You simply defined a pointer of the type of the base class and assigned it an address of an object of the (same) base class. So it is not clear why you are speaking about dynamic binding.</p>\n<p>Also the definition of the derived class is used nowehere.</p>\n<p>Dynamic binding is used when the static type of a pointer or a reference does not coinside with its dynamic type and when there is used a virtual function.\nIn your example there is no the first requirement nor the second.</p>\n<p>Here is an example of dynamic binding</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base \n{\n   virtual void print() const { std::cout &lt;&lt; \"Base\" &lt;&lt; std::endl; }\n   virtual ~Base() = default;\n   // or virtual ~Baae() {}\n};\n\nclass Derived : public Base \n{\n   void print() const { std::cout &lt;&lt; \"Derived\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n   Derived d;\n   Base *basePtr = &amp;d;\n   basePtr-&gt;print();\n}\n</code></pre>\n<p>Though static type of pointer basePtr is <code>Base *</code> its dynamic type is <code>Derived *</code> because it was assigned by the address of an object of the derived class.</p>\n<p>It will be useful to cite a note from the C++ Standard that it would be more clear</p>\n<blockquote>\n<p id=\"so_23542663_23543096_0\">[ Example: if a pointer (8.3.1) p whose static type is \u201cpointer to\n  class B\u201d is pointing to an object of class D, derived from B (Clause\n  10), the dynamic type of the expression *p is \u201cD.\u201d References (8.3.2)\n  are treated similarly. \u2014end example ]</p>\n</blockquote>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-05-08T13:36:48.073", "Score": "1", "CreationDate": "2014-05-08T13:25:31.393", "ParentId": "23542663", "CommentCount": "0", "OwnerUserId": "2877241", "LastEditDate": "2014-05-08T13:36:48.073"}, "23543107": {"Id": "23543107", "PostTypeId": "2", "Body": "<p>Dynamic binding occurs when using <code>virtual</code> methods. <code>Base::print</code> is not <code>virtual</code>. The idea of dynamic binding is the actual method that will be called is <em>bound</em> at run time, and this occurs when a <code>derived</code> class overrides a <code>virtual</code> method in base class, then depending on the <strong>actual object class</strong> (base/derived), the method gets bound.  In fact defining method in derived class with same name as base class hides the base class method, and this is a bad practice.</p>\n", "LastActivityDate": "2014-05-08T13:25:47.387", "CommentCount": "0", "CreationDate": "2014-05-08T13:25:47.387", "ParentId": "23542663", "Score": "0", "OwnerUserId": "1390091"}, "23543155": {"Id": "23543155", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23542663_23543155_0\">Is the following a case of static, or dynamic binding?</p>\n</blockquote>\n<p>Static, since the function isn't virtual.</p>\n<p>If it were virtual, then the function would be dispatched according to the dynamic type of the object.</p>\n<blockquote>\n<p id=\"so_23542663_23543155_1\">And why we should use dynamic binding over static?</p>\n</blockquote>\n<p>When we want to interact with objects of different types via a common base class, without knowing what the actual (dynamic) type is. For example,</p>\n<pre><code>class Base \n{\n    virtual void print() const;  // add \"virtual\" to enable dynamic dispatch\n};\n\n// This function doesn't know the real (dynamic) type of the object,\n// but still calls the correct version of \"print\".\nvoid print(Base const &amp; base) {\n    // If \"print\" is virtual, then this calls the override for the dynamic type.\n    // Otherwise, this calls Base::print.\n    base.print();\n}\n\nint main() {\n    Base base;\n    Derived derived;\n\n    print(base);     // calls Base::print\n    print(derived);  // calls Derived::print\n}\n</code></pre>\n<blockquote>\n<p id=\"so_23542663_23543155_2\">This method already \"understand\" which print() function call for the right class of the object, without using polymorphism and virtual functions.</p>\n</blockquote>\n<p>Indeed, polymorphism isn't useful if, as in your example, you know the dynamic type already. It's for when you don't know the dynamic type, as in my example.</p>\n", "LastActivityDate": "2014-05-08T13:27:39.233", "CommentCount": "2", "CreationDate": "2014-05-08T13:27:39.233", "ParentId": "23542663", "Score": "2", "OwnerUserId": "204847"}});