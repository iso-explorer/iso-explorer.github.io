post_cb({"3574187": {"ParentId": "3574059", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++ tries to prevent accidental errors, but it doesn't go out of its way to fight a programmer who's determined to have things their own way.  If you use cast operators you're telling it \"trust me, I know what's there\", demanding it ignore it's own knowledge of the program.  It's precisely because the C-style casting operator you've used is dangerous and can be easily misused that C++ introduces static_cast, const_cast and reinterpret_cast, which communicate the programmer's intent in such a way that the compiler can still say \"hey, hold on there, that'd require more than just the type of leniency you're asking for\".  reinterpret_cast is the big daddy though... no arguing with that... just as brutal as the C-cast and rarely needed in a high-level application.  Precisely because it's rarely needed, verbose and easily seen, it draws scrutiny.  Code littered with C-style casts can easily hide bugs.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2010-08-26T10:43:39.770", "Id": "3574187", "Score": "3", "CreationDate": "2010-08-26T10:24:38.243", "LastActivityDate": "2010-08-26T10:43:39.770"}, "3574209": {"ParentId": "3574059", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>$5.4/5 is about <code>explicit type conversion</code> (which is what is being used here)</p>\n<blockquote>\n<p id=\"so_3574059_3574209_0\">The conversions performed by</p>\n<p id=\"so_3574059_3574209_1\">\u2014 a const_cast (5.2.11), </p>\n<p id=\"so_3574059_3574209_2\">\u2014 a static_cast (5.2.9),</p>\n<p id=\"so_3574059_3574209_3\">\u2014 a static_cast followed by a const_cast, </p>\n<p id=\"so_3574059_3574209_4\">\u2014 a reinterpret_cast (5.2.10), or </p>\n<p id=\"so_3574059_3574209_5\">\u2014 a reinterpret_cast followed by a const_cast, </p>\n<p id=\"so_3574059_3574209_6\">can be performed using the cast notation of\n  explicit type conversion. The same\n  semantic restrictions and behaviors\n  apply. <strong>If a conversion can be\n  interpreted in more than one of the\n  ways listed above, the interpretation\n  that appears first in the list is\n  used, even if a cast resulting from\n  that interpretation is ill-formed.</strong>\n  If a conversion can be interpreted in\n  more than one way as a static_cast\n  followed by a const_cast, the\n  conversion is ill-formed.</p>\n</blockquote>\n<p>In this case, <code>((temp*)this)</code> got treated as <code>(const_cast&lt;temp *&gt;(this))</code> and was well-formed. This removed away the constness, thereby allowing to change the class member value.</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2010-08-26T10:36:17.037", "Id": "3574209", "Score": "5", "CreationDate": "2010-08-26T10:28:26.933", "LastActivityDate": "2010-08-26T10:36:17.037"}, "3574059": {"CommentCount": "6", "ViewCount": "180", "PostTypeId": "1", "LastEditorUserId": "87234", "CreationDate": "2010-08-26T10:08:47.637", "LastActivityDate": "2010-08-26T10:43:39.770", "Title": "why is the value being changed even in a const function?", "LastEditDate": "2010-08-26T10:10:06.977", "Id": "3574059", "Score": "5", "Body": "<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass temp\n    {\n      int value1; \n      public :\n        void fun() const\n        {\n        ((temp*)this)-&gt;value1 = 10;\n        }\n        void print()\n        {\n            cout&lt;&lt;value1&lt;&lt;endl;\n        }\n     };\nint main()\n{\n  temp t;\n  t.fun();\n  t.print();\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "430537", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_3574059_3574209_6": {"section_id": 6126, "quality": 0.9772727272727273, "length": 43}}, "n3337": {"so_3574059_3574209_6": {"section_id": 5890, "quality": 0.9772727272727273, "length": 43}}, "n4659": {"so_3574059_3574209_6": {"section_id": 7623, "quality": 0.9772727272727273, "length": 43}}}, "3574071": {"ParentId": "3574059", "CommentCount": "2", "Body": "<p>Because you're casting away <code>const</code>...</p>\n<p>When you cast something, the responsibility is yours for making sure that it doesn't do something dumb.</p>\n<hr>\n<p>Note that if <code>temp t;</code> is changed to <code>const temp t;</code>, you get undefined behavior, for modifying a <code>const</code> value.</p>\n<p>Coincidentally I literally just touched on this in <a href=\"http://blackninjagames.com/?p=91\" rel=\"nofollow noreferrer\">my blog</a>. (Almost the same function, too.)</p>\n</hr>", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "3574071", "Score": "14", "CreationDate": "2010-08-26T10:09:57.927", "LastActivityDate": "2010-08-26T10:09:57.927"}});