post_cb({"bq_ids": {"n4140": {"so_32173757_32173795_3": {"length": 6, "quality": 1.0, "section_id": 57}, "so_32173757_32173795_6": {"length": 19, "quality": 0.7916666666666666, "section_id": 58}, "so_32173757_32173795_2": {"length": 4, "quality": 1.0, "section_id": 57}, "so_32173757_32173795_0": {"length": 8, "quality": 1.0, "section_id": 57}}, "n3337": {"so_32173757_32173795_3": {"length": 6, "quality": 1.0, "section_id": 52}, "so_32173757_32173795_6": {"length": 19, "quality": 0.7916666666666666, "section_id": 53}, "so_32173757_32173795_2": {"length": 4, "quality": 1.0, "section_id": 52}, "so_32173757_32173795_0": {"length": 8, "quality": 1.0, "section_id": 52}}, "n4659": {"so_32173757_32173795_3": {"length": 6, "quality": 1.0, "section_id": 59}, "so_32173757_32173795_6": {"length": 19, "quality": 0.7916666666666666, "section_id": 60}, "so_32173757_32173795_2": {"length": 4, "quality": 1.0, "section_id": 59}, "so_32173757_32173795_0": {"length": 8, "quality": 1.0, "section_id": 59}}}, "32173757": {"ViewCount": "81", "Body": "<p>I noticed something interesting when templates are used (and I'm still learning c++, so hopefully I haven't botched this sample code):</p>\n<pre><code>template &lt;class T&gt;\nT Pyramid&lt;T&gt;::getValue(int row, int col) {\n    return data[triangleNum[row] + col];\n}\n</code></pre>\n<p>Why do we manually specify the <code>T</code> argument (as it is named in this function) as a <code>class</code>? Isn't it obvious <code>T</code> is going to be a class, or does this mean we can allow other data types to be used in the template?</p>\n<p>So, if we were to re-create the array from scratch, could we do something like this, and if so, what data types are allowed, and what are the restrictions for this?</p>\n<pre><code># template &lt;class T, int length&gt;\nCustomArray&lt;float, 365&gt; dailyIncome;\n</code></pre>\n", "Title": "What data types can you use with a template?", "CreationDate": "2015-08-24T02:37:44.330", "LastActivityDate": "2015-08-24T03:08:17.543", "CommentCount": "3", "PostTypeId": "1", "ClosedDate": "2015-08-24T08:43:10.117", "Id": "32173757", "Score": "0", "OwnerUserId": "617937", "Tags": "<c++><templates>", "AnswerCount": "1"}, "32173795": {"Id": "32173795", "PostTypeId": "2", "Body": "<p>There are, broadly, two categories of template parameters.</p>\n<ol>\n<li><p><code>template&lt;typename T&gt;</code> (This is more general than marking parameter <code>T</code> as a <code>class</code> or <code>struct</code> or <code>union</code>, as it can also include primitive types like <code>int</code>, <code>bool</code>, etc.)</p></li>\n<li><p>Integral constants, i.e. <code>template&lt;int i&gt;</code>. For instance the following construction is useful in some TMP techniques.</p></li>\n</ol>\n<p>:</p>\n<pre><code>template&lt;int k&gt; struct Rank : Rank&lt;k-1&gt; {};\ntemplate&lt;&gt; struct Rank&lt;0&gt; {};\n</code></pre>\n<p>This template generates a hierarchy of <code>Rank</code> types which each inherit from one another, i.e. <code>Rank&lt;0&gt;</code> is a superclass of <code>Rank&lt;1&gt;</code> is a superclass of <code>Rank&lt;2&gt;</code> ...</p>\n<p>Integral constants can be broadly construed to include <code>char</code>, and also pointers like <code>int *</code> or even a pointer to some struct. You can for instance template a class against a pointer to some fixed (static storage duration) instance of a struct of some type in memory somewhere, this can be useful.</p>\n<p>You cannot template against anything with a ctor or dtor (when would they run?). You cannot template against a <code>const char *</code> string literal -- if you attempted to instantiate a type <code>my_type&lt;\"foo\"&gt;</code> you would never be able to refer to that type again, because when you typed <code>my_type&lt;\"foo\"&gt;</code> later you would get a different string literal <code>\"foo\"</code> and therefore a different pointer and a different type. (You can however template against a particular string <em>with static storage duration</em>.) You also cannot template against float either, because you might expect things like <code>my_type&lt;2.0/3&gt;</code> and <code>my_type&lt;6.0/9&gt;</code> to always give you the same type, and then get a rude surprise caused by floating point rounding.</p>\n<p>You can also template against function pointers, that's sometimes really useful also.</p>\n<p>Pointer-to-member-function templating is also possible, I've used that in the past when making some code that binds C++ classes to lua.</p>\n<p>Here's the actual text of C++11 standard (14.1.4)</p>\n<blockquote>\n<p id=\"so_32173757_32173795_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>\n<p id=\"so_32173757_32173795_1\">(4.1) \u2014 integral or enumeration type,</p>\n<p id=\"so_32173757_32173795_2\">(4.2) \u2014 pointer to object or pointer to function,</p>\n<p id=\"so_32173757_32173795_3\">(4.3) \u2014 lvalue reference to object or lvalue reference to function,</p>\n<p id=\"so_32173757_32173795_4\">(4.4) \u2014 pointer to member,</p>\n<p id=\"so_32173757_32173795_5\">(4.5) \u2014 std::nullptr_t.</p>\n<p id=\"so_32173757_32173795_6\">[ Note: Other types are disallowed either explicitly below or implicitly by the rules governing the form of\n  template-arguments (14.3). \u2014 end note ] The top-level cv-qualifiers on the template-parameter are ignored\n  when determining its type.</p>\n</blockquote>\n<p>Actually I didn't know about lvalue reference, I've never actually used that, nor have I used pointer to member besides pointer to member function. I have templated against <code>nullptr</code>, that is also useful at times.</p>\n", "LastEditorUserId": "3598119", "LastActivityDate": "2015-08-24T03:08:17.543", "Score": "0", "CreationDate": "2015-08-24T02:45:06.057", "ParentId": "32173757", "CommentCount": "4", "OwnerUserId": "3598119", "LastEditDate": "2015-08-24T03:08:17.543"}});