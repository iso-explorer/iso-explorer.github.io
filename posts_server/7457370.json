post_cb({"bq_ids": {"n4140": {"so_7457370_7457436_2": {"length": 17, "quality": 0.68, "section_id": 3294}, "so_7457370_7457436_3": {"length": 42, "quality": 0.8936170212765957, "section_id": 3296}, "so_7457370_7457436_4": {"length": 33, "quality": 0.8918918918918919, "section_id": 480}, "so_7457370_7457436_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3293}}, "n3337": {"so_7457370_7457436_2": {"length": 17, "quality": 0.68, "section_id": 3164}, "so_7457370_7457436_4": {"length": 34, "quality": 0.918918918918919, "section_id": 471}, "so_7457370_7457436_3": {"length": 42, "quality": 0.8936170212765957, "section_id": 3166}, "so_7457370_7457436_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3163}}, "n4659": {"so_7457370_7457436_2": {"length": 17, "quality": 0.68, "section_id": 4056}, "so_7457370_7457436_4": {"length": 33, "quality": 0.8918918918918919, "section_id": 502}, "so_7457370_7457436_3": {"length": 42, "quality": 0.8936170212765957, "section_id": 4058}}}, "7457436": {"Id": "7457436", "PostTypeId": "2", "Body": "<p><em>(Less verbose testcase <a href=\"http://codepad.org/PiqcL0cI\" rel=\"nofollow\">here</a>.)</em></p>\n<p>The two forms of initialisation are actually not completely equivalent at all.</p>\n<p>The former is your bog-standard construction:</p>\n<pre><code>T o(10);\n</code></pre>\n<p>The latter, however, is more complicated.</p>\n<pre><code>T o = 10;\n</code></pre>\n<p>Here, the expression on the RHS (<code>10</code>) is converted to type <code>T</code>, then the object <code>o</code> is copy-constructed from that converted expression. The copy construction is not possible here because your <code>T(T&amp;)</code> prohibits the synthesis of an implicit <code>T(T const&amp;)</code>, and the temporary object on the RHS cannot be bound to a ref-to-non-<code>const</code>.</p>\n<p>Now, the compiler is allowed to elide that copy-construction and this usually occurs, but the conversion must still be valid or the program is ill-formed.</p>\n<hr>\n<blockquote>\n<p id=\"so_7457370_7457436_0\"><code>[n3290: 8.5/13]:</code> The form of initialization (using parentheses or =)\n  is generally insignificant, but does matter when the initializer or\n  the entity being initialized has a class type; see below. [..]</p>\n<p id=\"so_7457370_7457436_1\"><code>[n3290: 8.5/14]:</code> The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_7457370_7457436_2\">as well as in argument passing, function return, throwing an exception\n  (15.1), handling an exception (15.3), and aggregate member\n  initialization (8.5.1) is called <em>copy-initialization</em>. [ <em>Note:</em>\n  Copy-initialization may invoke a move (12.8). <em>\u2014end note</em> ]</p>\n<p id=\"so_7457370_7457436_3\"><code>[n3290: 8.5/16]:</code> The semantics of initializers are as follows. [..]\n  If the destination type is a (possibly cv-qualified) class type: [..]\n  Otherwise (i.e., <strong>for the remaining copy-initialization cases</strong>),\n  <strong>user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4</strong>,\n  and the best one is chosen through overload resolution (13.3). <strong>If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed.</strong> [..]</p>\n<p id=\"so_7457370_7457436_4\"><code>[n3290: 12.8/31]:</code> When certain criteria are met, an implementation\n  is allowed to omit the copy/move construction of a class object, even\n  if the copy/move constructor and/or destructor for the object have\n  side effects. [..] This elision of copy/move operations, called copy\n  elision, is permitted in the following circumstances (which may be\n  combined to eliminate multiple copies): [..]</p>\n<ul>\n<li>when a temporary class object that has not been bound to a reference\n  (12.2) would be copied/moved to a class object with the same\n  cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move. [..]</li>\n</ul>\n</blockquote>\n<p>(I can't actually find a citation stating explicitly that the copy constructor must still be accessible even when the copy is elided, but this is the case.)</p>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-09-17T20:19:54.847", "Score": "2", "CreationDate": "2011-09-17T20:05:19.333", "ParentId": "7457370", "CommentCount": "8", "OwnerUserId": "560648", "LastEditDate": "2011-09-17T20:19:54.847"}, "7457813": {"Id": "7457813", "PostTypeId": "2", "Body": "<p>I don't agree with K-ballo. When you define a c'tor with single argument, it can be [mis]used by compiler for implicit conversion. Which is what happens in this case.</p>\n<p>So when you run the program it calls \"c'tor with single arg\" for construction of a AWA aa.</p>\n<blockquote>\n<blockquote>\n<p id=\"so_7457370_7457813_1\">Test aa = 10;</p>\n</blockquote>\n</blockquote>\n<p>There is no \"copying\" or \"assignment\" involved in this statement.\nGiven that you've provided the compiler with a single arg c'tor, it'd [mis]use it in this case. </p>\n<pre><code>// So basically compiler converts this:\nTest aa = 10;\n// to\nTest aa(10);\n</code></pre>\n<p>You can stop misuse by marking that c'tor as explicit. Just change <code>Test( int x )</code> to <code>explicit Test( int x )</code>\nSee some explanation of explicit keyword here: <a href=\"https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-in-c-mean\">What does the explicit keyword mean in C++?</a></p>\n<blockquote>\n<blockquote>\n<p id=\"so_7457370_7457813_3\">if I modify Test(Test&amp; xx) to Test(const Test&amp; xx) it is working. But why is the compiler checking for copy constructor signature when we are trying to call constructor with integer argument.</p>\n</blockquote>\n</blockquote>\n<p>I also didn't understand this and would like to know. :)</p>\n<p>I observed that copy c'tor simply is never called.</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass Test\n{\npublic :\n    int x;\n    Test() { x=0; cout &lt;&lt; \"    Test() - \" &lt;&lt; x &lt;&lt; endl;}\n    Test(int xx) { x=xx; cout &lt;&lt; \"    Test(int xx) - \" &lt;&lt; x &lt;&lt; endl;}\n    Test(Test&amp; xx){ x=xx.x; cout &lt;&lt; \"    Test(Test&amp; xx) - \" &lt;&lt; x &lt;&lt; endl;}\n    Test(const Test&amp; xx){ x=xx.x; cout &lt;&lt; \"    Test(const Test&amp; xx) - \" &lt;&lt; x &lt;&lt; endl;}\n    Test&amp; operator= (const Test&amp; xx) { x=xx.x; cout &lt;&lt; \"    Test&amp; operator= (const Test&amp; xx) - \" &lt;&lt; x &lt;&lt; endl; return *this;}\n};\n\n\nint main()\n{\n    cout &lt;&lt; \"--Test a(10);--\" &lt;&lt; endl;\n    Test a(10);\n    cout &lt;&lt; \"--Test aa = 20;--\" &lt;&lt; endl;\n    Test aa = 20;\n    cout &lt;&lt; \"--Test aaa = aa;--\" &lt;&lt; endl;\n    Test aaa = aa;\n    cout &lt;&lt; \"--aaa = aa;--\" &lt;&lt; endl;\n    aaa = aa;\n    cout &lt;&lt; \"--aaa = 30;--\" &lt;&lt; endl;\n    aaa = 30;\n}\n/*\nOUTPUT:\n    --Test a(10);--\n        Test(int xx) - 10\n    --Test aa = 20;--\n        Test(int xx) - 20\n    --Test aaa = aa;--\n        Test(Test&amp; xx) - 20\n    --aaa = aa;--\n        Test&amp; operator= (const Test&amp; xx) - 20\n    --aaa = 30;--\n        Test(int xx) - 30\n        Test&amp; operator= (const Test&amp; xx) - 30\n*/\n</code></pre>\n<p>and when copy c'tor with const arg <code>Test(const Test&amp; xx)</code> is commented out:</p>\n<p>We get compilation errors.</p>\n<pre><code>D:\\Workspaces\\CodeBlocks\\Test\\main.cpp: In function 'int main()':\nD:\\Workspaces\\CodeBlocks\\Test\\main.cpp:21:19: error: no matching function for call to 'Test::Test(Test)'\nD:\\Workspaces\\CodeBlocks\\Test\\main.cpp:10:9: note: candidates are: Test::Test(Test&amp;)\nD:\\Workspaces\\CodeBlocks\\Test\\main.cpp:9:9: note:                 Test::Test(int)\nD:\\Workspaces\\CodeBlocks\\Test\\main.cpp:8:9: note:                 Test::Test()\nProcess terminated with status 1 (0 minutes, 0 seconds)\n4 errors, 0 warnings\n</code></pre>\n<p>Line 21 is <code>Test aa = 20;</code></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-17T21:09:34.283", "Score": "-1", "CreationDate": "2011-09-17T21:09:34.283", "ParentId": "7457370", "CommentCount": "0", "OwnerUserId": "496289", "LastEditDate": "2017-05-23T10:27:07.303"}, "7457885": {"Id": "7457885", "PostTypeId": "2", "Body": "<p>All of the answers you've gotten so far are overly complicated and/or slightly misleading.</p>\n<p>In the first construction/initialization:</p>\n<pre><code>T a(10);\n</code></pre>\n<p>The very obvious thing happens. The second construction/initialization is more interesting:</p>\n<pre><code>T aa = 10;\n</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>T aa(T(10));\n</code></pre>\n<p>Meaning that you create a temporary object of type T, and then construct <code>aa</code> as a copy of this temporary. This means that the copy constructor is called.</p>\n<p>C++ has a default copy constructor that it creates for a class when you have none explicitly declared. So even though the first version of <code>class T</code> has no copy constructor declared, there still is one. The one the compiler declares has this signature <code>T(const T &amp;)</code>.</p>\n<p>Now in your second case where you declare something that looks like a copy constructor, you make the argument a <code>T &amp;</code>, not a <code>const T &amp;</code>. This means that the compiler, when trying to compile the second expression, tries to use your copy constructor, and it can't. It's complaining that the copy constructor you declared requires a non-const argument, and the argument it's being given is const. So it fails.</p>\n<p>The other rule is that after the compiler has converted your initialization to <code>T aa(T(10));</code> it is then allowed to transform it to <code>T aa(10);</code>. This is called 'copy elision'. The compiler is allowed, in certain circumstances, to skip calls to the copy constructor. But it may only do this after it verifies that the expression is correctly formed and doesn't generate any compiler errors when the copy constructor call is still there. So this is an optimization step that may affect exactly which parts of a program run, but cannot affect which programs are valid and which ones are in error (at least from the standpoint of whether or not they compile).</p>\n", "LastEditorUserId": "167958", "LastActivityDate": "2011-09-17T21:45:07.697", "Score": "6", "CreationDate": "2011-09-17T21:22:50.243", "ParentId": "7457370", "CommentCount": "2", "OwnerUserId": "167958", "LastEditDate": "2011-09-17T21:45:07.697"}, "7457370": {"ViewCount": "7272", "Body": "<pre><code>class Test{\n    public :\n        int x;  \n        Test()\n        {\n            x = 0;\n            cout&lt;&lt;\"constructor with no arguments called\"&lt;&lt;endl;\n        }\n        Test(int xx)\n        {\n            x = xx;\n            cout&lt;&lt;\"constructor with single int argument called\"&lt;&lt;endl;\n        }\n\n};\n\n\nint main()\n{\n    Test a(10);\n    Test aa = 10;\n}\n</code></pre>\n<p>output:\nProgram compiles and outputs</p>\n<blockquote>\n<p id=\"so_7457370_7457370_0\">constructor with single int argument called </p>\n<p id=\"so_7457370_7457370_1\">constructor with single int argument called</p>\n</blockquote>\n<p>But now </p>\n<pre><code>class Test{\n    public :\n        int x;  \n        Test()\n        {\n            x = 0;\n            cout&lt;&lt;\"constructor with no arguments called\"&lt;&lt;endl;\n        }\n        Test(int xx)\n        {\n            x = xx;\n            cout&lt;&lt;\"constructor with single int argument called\"&lt;&lt;endl;\n        }\n\n        Test( Test&amp; xx)\n        {\n            x = xx.x;\n            cout&lt;&lt;\"copy constructor called\"&lt;&lt;endl;\n        }\n\n\n};\n\n\nint main()\n{\n    Test a(10);\n    Test aa = 10;\n}\n</code></pre>\n<p>compilation fails.</p>\n<pre><code>constructorinvokings.cc:36:7: error: no viable constructor copying variable of type 'Test'\n        Test aa = 10;\n             ^    ~~\nconstructorinvokings.cc:23:3: note: candidate constructor not viable: no known conversion from 'Test' to 'Test &amp;' for 1st\n      argument\n                Test( Test&amp; xx)\n                ^\n1 error generated.\n</code></pre>\n<p>I am new to C++. </p>\n<p>Aren't Test a(10) and Test aa = 10; identical ?</p>\n<p>why is the addition of copy constructor conflicting with Test aa=10?</p>\n<p>if I modify Test(Test&amp; xx) to Test(const Test&amp; xx) it is working. But why is the compiler checking for copy constructor signature when we are trying to call constructor with integer argument.</p>\n<p>Please clarify</p>\n<p>Thanks in advance.</p>\n", "AcceptedAnswerId": "7457885", "Title": "C++ constructor calling and object creation", "CreationDate": "2011-09-17T19:51:36.550", "Id": "7457370", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2011-09-17T21:44:34.577", "LastEditorUserId": "167958", "LastActivityDate": "2011-09-17T21:45:07.697", "Score": "4", "OwnerUserId": "320105", "Tags": "<c++><initialization><copy-constructor>", "AnswerCount": "4"}, "7457395": {"Id": "7457395", "PostTypeId": "2", "Body": "<p>Test a(10) and Test aa = 10; are not identical. The first one constructs a Test out of 10, while the second one constructs a Test out of 10 <strong>and</strong> then copy-constructs aa out of it. The addition of the copy constructor conflicts because it states that making a copy-construction is a mutable operation for both two operands. There are cases where copy-constructors take the source as a non const reference, but are somewhat complicated cases and is not your case here.</p>\n<p><strong>Edit:</strong> Note that in the second case the compiler is allowed to elide that copy-construction, and usually does.</p>\n", "LastEditorUserId": "927034", "LastActivityDate": "2011-09-17T20:37:02.283", "Score": "4", "CreationDate": "2011-09-17T19:56:34.567", "ParentId": "7457370", "CommentCount": "9", "OwnerUserId": "927034", "LastEditDate": "2011-09-17T20:37:02.283"}});