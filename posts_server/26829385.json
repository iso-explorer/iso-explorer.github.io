post_cb({"26829385": {"CommentCount": "0", "AcceptedAnswerId": "26829520", "PostTypeId": "1", "LastEditorUserId": "3429860", "CreationDate": "2014-11-09T14:44:40.193", "LastActivityDate": "2014-11-09T15:28:06.760", "LastEditDate": "2014-11-09T14:50:21.060", "ViewCount": "123", "FavoriteCount": "1", "Title": "lambdas and equality/inequality operator", "Id": "26829385", "Score": "3", "Body": "<p>I have a question about equality comparison of lambdas.\nI've tried to read some references but I've found nothing about this.</p>\n<pre><code>[] (Args ...args) -&gt; ReturnType { ... };\n</code></pre>\n<p>For this type of lambdas, which are not closures actually because they have empty capture list, operators <code>==</code> and <code>!=</code> works in the same way as for static functions (well, it seems, compiler generates them as static functions as well). But for closures any attempt to compare in the same way causes compilation error.</p>\n<p>Here is simple programm for example:</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;iostream&gt;\n\nstruct WrapperBase {\n    virtual ~WrapperBase() = default;\n\n    virtual bool operator==(WrapperBase&amp; v) = 0;\n    virtual bool operator!=(WrapperBase&amp; v) = 0;\n};\n\ntemplate&lt;typename _Tp&gt;\nstruct Wrapper : WrapperBase {\n    Wrapper(const _Tp&amp; v) : value(v) { }\n\n    bool operator==(WrapperBase&amp; v) override {\n        try {\n            Wrapper&lt;_Tp&gt;&amp; vv = dynamic_cast&lt;Wrapper&lt;_Tp&gt;&amp;&gt;(v);\n            return value == vv.value;\n        }\n        catch(std::bad_cast&amp; err) { }\n\n        return false;\n    }\n    bool operator!=(WrapperBase&amp; v) override {\n        try {\n            Wrapper&lt;_Tp&gt;&amp; vv = dynamic_cast&lt;Wrapper&lt;_Tp&gt;&amp;&gt;(v);\n            return value != vv.value;\n        }\n        catch(std::bad_cast&amp; err) { }\n\n        return true;\n    }\n\n    //\n\n    _Tp value;\n};\n\ntemplate&lt;typename _Tp&gt;\nWrapperBase* create_wrapper(const _Tp&amp; v) {\n    return new Wrapper&lt;_Tp&gt;(v);\n}\n\nstruct Base {\n    Base(int a, int b) : wrapper(nullptr), a(a), b(b) { }\n    virtual ~Base() { delete wrapper; }\n\n    virtual WrapperBase* create_wrapper() = 0;\n\n    WrapperBase* wrapper;\n    int a;\n    int b;\n};\nstruct ClassA : Base {\n    ClassA(int a, int b) : Base(a, b) {\n        wrapper = create_wrapper();\n    }\n\n    WrapperBase* create_wrapper() override {\n        auto lambda = [] (int v1, int v2) { return v1 + v2; };\n        return ::create_wrapper(lambda);\n    }\n};\n\nstruct ClassB : Base {\n    ClassB(int a, int b) : Base(a, b) {\n        wrapper = create_wrapper();\n    }\n\n    WrapperBase* create_wrapper() override {\n        auto lambda = [=] (int v1, int v2) { return a + b + v1 + v2; };\n        return ::create_wrapper(lambda);\n    }\n};\n\nint main(int argc, char** argv) {\n    std::cout &lt;&lt; std::boolalpha;\n\n    // all works fine:\n    ClassA a1(1, 2);\n    ClassA a2(3, 4);\n\n    std::cout &lt;&lt; (*a1.wrapper == *a1.wrapper) &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; (*a2.wrapper == *a2.wrapper) &lt;&lt; std::endl; // true\n    std::cout &lt;&lt; (*a1.wrapper == *a2.wrapper) &lt;&lt; std::endl; // true\n\n    // cause compilation error:\n    ClassB b1(1, 2);\n    ClassB b2(3, 4);\n\n    std::cout &lt;&lt; (*b1.wrapper == *b1.wrapper) &lt;&lt; std::endl;\n    std::cout &lt;&lt; (*b2.wrapper == *b2.wrapper) &lt;&lt; std::endl;\n    std::cout &lt;&lt; (*b1.wrapper == *b2.wrapper) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Comparing lambdas created in instances of ClassA always return <code>true</code> even if they are created in different context (just as I said). On the other hand, ClassB do not even compile because operator <code>==</code> and <code>!=</code> for its lambda is not found.</p>\n<p>It seems, this programm is not well-formed, and comparing of lambdas in the way I've tried causes undefined behavior of the programm. But if it's really undefined behavior, how can they be compared? (I guess, nohow)</p>\n", "Tags": "<c++><c++11><lambda><closures>", "OwnerUserId": "3429860", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_26829385_26829520_1": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_26829385_26829520_1": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_26829385_26829520_1": {"section_id": 7456, "quality": 0.85, "length": 34}}}, "26829520": {"ParentId": "26829385", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_26829385_26829520_0\">For this type of lambdas, which are not closures actually because they\n  have empty capture list, operators == and != works in the same way as\n  for static functions (well, it seems, compiler generates them as\n  static functions as well).</p>\n</blockquote>\n<p>It works because the closure type of a lambda without captures provides a conversion operator that returns a function pointer. Those are comparable. [expr.prim.lambda]/6 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26829385_26829520_1\">The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em>\n  has a public non-virtual <strong>non-explicit</strong> const conversion function to\n  pointer to function having the same parameter and return types as the\n  closure type\u2019s function call operator. The value returned by this\n  conversion function shall be the address of a function that, when\n  invoked, has the same effect as invoking the closure type\u2019s function\n  call operator.</p>\n</blockquote>\n<p>(If the conversion operator was explicit the comparison would not work)<br>\nRoughly, a lambda of the form <code>[] {}</code> translates to</br></p>\n<pre><code>struct closure_type\n{\nprivate:\n    static void call() {}\n\npublic:\n\n    // closure_type() = delete; // Commented for the sake of the demo\n    closure_type&amp; operator=(closure_type const&amp;) = delete;\n\n    void operator()() const { /*return call();*/ }\n\n    operator decltype(&amp;call)() const\n    {\n        return &amp;call;\n    }\n};\n</code></pre>\n<p>As you may have noted, the conversion operator returns the same function pointer each time. Though it would be utterly surprising if anything the like happened, the standard does allow different function pointers to be returned for a call to the conversion operator for the same closure object; A comparison of two closure objects has therefore an implementation-defined value. (It should, though, on all implementations be <code>true</code> for two closure objects of the same type.)</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-09T15:28:06.760", "Id": "26829520", "Score": "4", "CreationDate": "2014-11-09T14:58:39.523", "LastActivityDate": "2014-11-09T15:28:06.760"}});