post_cb({"bq_ids": {"n4140": {"so_27878843_27883301_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 5768}, "so_27878843_27883301_0": {"length": 17, "quality": 0.85, "section_id": 6290}}, "n3337": {"so_27878843_27883301_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 5541}, "so_27878843_27883301_0": {"length": 17, "quality": 0.85, "section_id": 6050}}, "n4659": {"so_27878843_27883301_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 7225}}}, "27883301": {"Id": "27883301", "PostTypeId": "2", "Body": "<p>Table 28 in <strong>17.6.3.5</strong> defines <code>deallocate</code> this way:</p>\n<blockquote>\n<p id=\"so_27878843_27883301_0\"><code>a.deallocate(p,n)</code>: All <code>n</code> <code>T</code> objects in the area pointed to by <code>p</code> shall be destroyed prior to this call. <code>n</code> shall match the value passed to <code>allocate</code> to obtain this memory. Does not throw exceptions. [ Note:<code>p</code> shall not be singular.\u2014end note ]</p>\n</blockquote>\n<p>Per Table 27 right above, <code>p</code> is \"a value of type <code>XX::pointer</code>, obtained by calling <code>a1.allocate</code>, where <code>a1 == a</code>\" (where <code>XX</code> is \"the type <code>allocator_traits&lt;X&gt;</code>\", and <code>X</code> is \"an Allocator class for type <code>T</code>\"). Further, <code>a</code> and <code>a1</code> are \"values of type <code>X&amp;</code>\".</p>\n<p>In other words, the standard does not envision passing to <code>deallocate</code> a pointer allocated by an allocator of a different type. It only specifies what happens when <code>deallocate</code> is given a pointer allocated by the same allocator object, or another allocator of the same type that compares equal to this allocator.</p>\n<p>At which point, we have</p>\n<blockquote>\n<p id=\"so_27878843_27883301_1\"><strong>1.3.24</strong> undefined behavior</p>\n<p id=\"so_27878843_27883301_2\">behavior for which this International Standard imposes no requirements\n  [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of behavior...]</p>\n</blockquote>\n", "LastActivityDate": "2015-01-11T02:11:37.703", "CommentCount": "0", "CreationDate": "2015-01-11T02:11:37.703", "ParentId": "27878843", "Score": "2", "OwnerUserId": "1670129"}, "27878843": {"ViewCount": "143", "Body": "<p>Are memory allocators supposed to be used with polymorphic types?\nFor example, is the code below correct?</p>\n<pre><code>class A { ... };\nclass B { ... };\nclass C : public A, public B { ... };\n\nstd::allocator&lt;C&gt; alloc_c;\nauto p_c = alloc_c.allocate(1);\n\n// CASE A: pointer to A and to C point to the same memory address\nstd::allocator&lt;A&gt; alloc_a(alloc_c);\nalloc_a.deallocate((A*)p_c, 1);\n\n// CASE B: pointer to B and to C point to the different memory addresses\nstd::allocator&lt;B&gt; alloc_b(alloc_c);\nalloc_b.deallocate((B*)p_c, 1);\n</code></pre>\n<p>Of course, it's either case A or case B, not both.</p>\n", "AcceptedAnswerId": "27883301", "Title": "C++ memory allocators and polymorphic types", "CreationDate": "2015-01-10T17:09:13.253", "Id": "27878843", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-01-11T02:11:37.703", "Score": "2", "OwnerUserId": "627327", "Tags": "<c++><stl><standards><allocator>", "AnswerCount": "1"}});