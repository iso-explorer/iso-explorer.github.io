post_cb({"47312173": {"ParentId": "47311823", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From the C++ 2017 Standard (12.2.3.2 Static data members)</p>\n<blockquote>\n<p id=\"so_47311823_47312173_0\">2 The declaration of a non-inline static data member in its class\n  definition is not a definition and may be of an incomplete type other\n  than cv void. The definition for a static data member that is not\n  defined inline in the class definition shall appear in a namespace\n  scope enclosing the member\u2019s class definition. In the definition at\n  namespace scope, the name of the static data member shall be qualified\n  by its class name using the :: operator. <strong>The initializer expression\n  in the definition of a static data member is in the scope of its\n  class</strong> (6.3.7).</p>\n</blockquote>\n<p>So in this definition of the static data member</p>\n<pre><code>const A* B::a_obj = new(arr) A;\n</code></pre>\n<p>the unqualified name <code>arr</code> is at first searched in the scope of the class <code>B</code>. And the class B indeed declares such a name</p>\n<pre><code>static char arr[sizeof(A)];\n</code></pre>\n<p>If you want to use the name from the global namespace then use the qualified name</p>\n<pre><code>const A* B::a_obj = new(::arr) A;\n</code></pre>\n<p>Here is a demonstrative program</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    const static int N = 10;\n    static int n1;\n    static int n2;\n};\n\nconst int N = 20;\n\nint A::n1 = N;\nint A::n2 = ::N;\n\n\nint main() \n{\n    std::cout &lt;&lt; \"A::n1 = \" &lt;&lt; A::n1 &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"A::n2 = \" &lt;&lt; A::n2 &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Its output is</p>\n<pre><code>A::n1 = 10\nA::n2 = 20\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2017-11-15T16:15:11.877", "Id": "47312173", "Score": "1", "CreationDate": "2017-11-15T16:09:22.687", "LastActivityDate": "2017-11-15T16:15:11.877"}, "47312408": {"ParentId": "47311823", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The reason arr is attribute to the class B and not the global scope is due to unqualified name lookup rules.</p>\n<p>Specifically: </p>\n<blockquote>\n<p id=\"so_47311823_47312408_0\">Static data member definition For a name used in the definition of a\n  static data member, lookup proceeds the same way as for a name used in\n  the definition of a member function. </p>\n</blockquote>\n<p>Meaning:</p>\n<pre><code>struct X {\n    static int x;\n    static const int n = 1; // found 1st\n};\nint n = 2; // found 2nd.\nint X::x = n; // finds X::n, sets X::x to 1, not 2\n</code></pre>\n<p>If you are intrested you can see more information here:\n<a href=\"http://en.cppreference.com/w/cpp/language/unqualified_lookup\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/unqualified_lookup</a></p>\n<p>As people suggested to get what you want just use:</p>\n<pre><code>const A* B::a_obj = new(::arr) A;\n</code></pre>\n", "OwnerUserId": "8908931", "LastEditorUserId": "8908931", "LastEditDate": "2017-11-15T16:26:30.123", "Id": "47312408", "Score": "1", "CreationDate": "2017-11-15T16:20:51.827", "LastActivityDate": "2017-11-15T16:26:30.123"}, "47311823": {"CommentCount": "3", "ViewCount": "45", "PostTypeId": "1", "LastEditorUserId": "2877241", "CreationDate": "2017-11-15T15:53:33.870", "LastActivityDate": "2017-11-15T16:26:30.123", "Title": "Static variable shadowing global", "AcceptedAnswerId": "47312173", "LastEditDate": "2017-11-15T16:19:17.900", "Id": "47311823", "Score": "3", "Body": "<p>I am trying to create an object using <code>placement new</code> (I know to use smart pointers, this is just to learn). My code is as follows:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\n\nusing namespace std; // please excuse this\n\n// if you change like 19 to arr1 (or any other var name) instead of arr and line 40 to arr1 then it works\n\nstruct A\n{\n    int in = 999;\n    A()\n    {cout &lt;&lt; \"A ctor\\n\";}\n    ~A()\n    {cout &lt;&lt; \"A dtor\\n\";}\n};\n\nchar arr[sizeof(A)];\n\nclass B\n{\n    public:\n    static char arr[sizeof(A)];\n\n    const static A* a_obj;\n\n    B()\n    {\n        cout &lt;&lt; \"B ctor\\n\";\n        //cout &lt;&lt; (a_obj-&gt;in) &lt;&lt; endl;\n    }\n    ~B()\n    {\n        cout &lt;&lt; \"B dtor\\n\";\n    }\n};\n\n\n\nconst A* B::a_obj = new(arr) A;\n\n\nint main()\n{\n    B g;\n}\n</code></pre>\n<p>I have created a <code>global array</code> named arr and another <code>array</code> named <code>arr</code>in <code>B</code>. It seems like when I do my <code>placement new</code> the <code>arr</code> being used is from the class as I get what I think are linker errors.</p>\n<p>Why is this happening? why isn't the <code>global arr</code> being used? If i change the <code>placement new</code> to use my renamed <code>global array</code> it works. I think it has to do something with <code>lookups</code> but I don't have a concrete answer.</p>\n", "Tags": "<c++><c++11><scope><static><initialization>", "OwnerUserId": "4992422", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47311823_47312408_0": {"section_id": 5907, "quality": 0.5555555555555556, "length": 10}, "so_47311823_47312173_0": {"section_id": 5907, "quality": 0.8392857142857143, "length": 47}}, "n3337": {"so_47311823_47312408_0": {"section_id": 5679, "quality": 0.5555555555555556, "length": 10}, "so_47311823_47312173_0": {"section_id": 5679, "quality": 0.8392857142857143, "length": 47}}, "n4659": {"so_47311823_47312408_0": {"section_id": 7389, "quality": 0.5555555555555556, "length": 10}, "so_47311823_47312173_0": {"section_id": 7389, "quality": 0.9107142857142857, "length": 51}}}});