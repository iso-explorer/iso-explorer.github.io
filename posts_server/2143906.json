post_cb({"2143906": {"CommentCount": "8", "AcceptedAnswerId": "2143953", "PostTypeId": "1", "LastEditorUserId": "3964927", "CreationDate": "2010-01-27T01:11:07.370", "LastActivityDate": "2015-07-06T16:34:13.900", "LastEditDate": "2015-07-06T16:34:13.900", "ViewCount": "5955", "FavoriteCount": "2", "Title": "C/C++: Calling function with no arguments with function which returns nothing", "Id": "2143906", "Score": "14", "Body": "<p>Why isn't it possible to call a function which takes no arguments with a function call as argument which does not return any value (which IMHO is equivalent to calling a function which takes no arguments with no arguments).</p>\n<p>For example:</p>\n<pre><code>void foo(void) {...}\nvoid bar(void) {...}\n\nfoo(bar())\n</code></pre>\n<p>Don't get me wrong, I know <code>void</code> is not a value and that it cannot be treated like one.</p>\n<p>With my logic it would make sense and it should be possible to do that.\nI mean, why not? Any argument why that should not be possible?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "257636", "AnswerCount": "9"}, "2143937": {"ParentId": "2143906", "CommentCount": "0", "CreationDate": "2010-01-27T01:18:58.623", "OwnerUserId": "209605", "PostTypeId": "2", "Id": "2143937", "Score": "1", "Body": "<p>it does make kind of sense (<code>bar</code> produces nothing, <code>foo</code> consumes nothing, therefore <code>foo(bar())</code> should be allowed).  OTOH, it would only be good to confuse the reader.  if you want to be l33t, there's always <code>,</code>, <code>&amp;&amp;</code> and <code>||</code> operators to emulate semicolons.</p>\n", "LastActivityDate": "2010-01-27T01:18:58.623"}, "2146490": {"ParentId": "2143906", "CommentCount": "1", "CreationDate": "2010-01-27T11:38:14.967", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "2146490", "Score": "0", "Body": "<p>I'll add one extra declaration: <code>void baz(int);</code></p>\n<p>Now obviously if an argument with type <code>void</code> is equal to no arguments, then two arguments, one of which has type void would be equal to one argument (as 0 = 1*x &lt;=&gt; 1 = 1+1*x)</p>\n<p>So, obviously this is legal: <code>baz(1, bar());</code>. But also (since void is \"nothing\") <code>baz(bar(),1);</code>.</p>\n<p>And we can continue in this sense: <code>baz(bar(), 1, bar());</code>. After all, \"void is nothing\". </p>\n<p>Either you ban it outright, put in arbitrary restrictions, or you end up allowing ridiculous constructs. I agree with the choice for the first resolution</p>\n", "LastActivityDate": "2010-01-27T11:38:14.967"}, "2143923": {"ParentId": "2143906", "CommentCount": "1", "CreationDate": "2010-01-27T01:14:42.080", "OwnerUserId": "20862", "PostTypeId": "2", "Id": "2143923", "Score": "0", "Body": "<p>Because <code>void</code> doesn't allow you to specify an argument name, which would be required in order to capture the return value of the first function, regardless of what it actually returned.</p>\n", "LastActivityDate": "2010-01-27T01:14:42.080"}, "2143953": {"ParentId": "2143906", "CommentCount": "7", "CreationDate": "2010-01-27T01:23:40.870", "OwnerUserId": "13", "PostTypeId": "2", "Id": "2143953", "Score": "8", "Body": "<p>I'm not convinced that any of the reasons I've heard are good ones.</p>\n<p>See, in C++, you can return a <code>void</code> function's result:</p>\n<pre><code>void foo() {\n    // ...\n}\n\nvoid bar() {\n    // ...\n    return foo();\n}\n</code></pre>\n<p>Yes, it's exactly the same as:</p>\n<pre><code>foo();\nreturn;\n</code></pre>\n<p>but is much more consistent with generic programming, so that you can make a forwarding function work without having to worry about whether the function being forwarded has <code>void</code> return.</p>\n<p>So, if a similar system applied so that a <code>void</code> return constituted a nullary call in a function composition scenario, that could make function composition more generic too.</p>\n", "LastActivityDate": "2010-01-27T01:23:40.870"}, "2143995": {"ParentId": "2143906", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-01-27T01:36:51.687", "Score": "3", "LastEditorUserId": "153285", "LastEditDate": "2010-01-27T01:44:46.910", "Id": "2143995", "OwnerUserId": "153285", "Body": "<p>Because, according to paragraph 3.9.1/9 of the standard,</p>\n<blockquote>\n<p id=\"so_2143906_2143995_0\">An\n  expression of type void shall be used\n  only as an expression statement (6.2),\n  as an operand of a comma expression\n  (5.18), as a second or third operand\n  of ?: (5.16), as the operand of\n  typeid, or as the expression in a\n  return statement (6.6.3) for a\n  function with the return type void.</p>\n</blockquote>\n<p>C/C++ just isn't designed to be that generic. You <em>do</em> get <code>return returns_void();</code> for tail-call optimization, that's functional-ish, right? :vP</p>\n<p><strong>Edit:</strong> The above rule would still allow you to call <code>takes_void(3)</code> with <code>3</code> converted to <code>void</code>. This is forbidden by 8.3.5/2:</p>\n<blockquote>\n<p id=\"so_2143906_2143995_1\">If the parameter-declaration-clause is\n  empty, the function takes no\n  arguments. The parameter list (void)\n  is equivalent to the empty parameter\n  list. Except for this spe- cial case,\n  void shall not be a parameter type\n  (though types derived from void, such\n  as void*, can).</p>\n</blockquote>\n", "LastActivityDate": "2010-01-27T01:44:46.910"}, "2144029": {"ParentId": "2143906", "CommentCount": "0", "CreationDate": "2010-01-27T01:46:10.053", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "2144029", "Score": "2", "Body": "<p>If the <code>(void)</code> parameter list was treated uniformly with all other parameter lists in C/C++, the semantic meaning if such parameter declaration would be \"a single parameter of type <code>void</code>\". If that was the case, it is quite possible that for the purposes of uniformity the language would allow to \"chain\" the calls to such functions as shown in your example. (At least C++ probably would, since it allows this kind of uniformity in <code>return</code> statements).</p>\n<p>However, in C++ language as well as in C, parameter list that has the form <code>(void)</code> is not treated uniformly with other forms of parameter lists. Instead, it has a special meaning. It means that the function has <em>no parameters at all</em>. (Equivalent to empty <code>()</code> in C++).</p>\n<p>In other words, the function declared with <code>(void)</code> parameter list takes <em>zero</em> parameters. You are supplying <em>one</em>. This is what makes it illegal. Considering the special meaning of <code>(void)</code> parameter list in C/C++, allowing </p>\n<pre><code>foo(bar());\n</code></pre>\n<p>would not be much different from allowing </p>\n<pre><code>foo(bar(), bar());\nfoo(bar(), bar(), bar());\n</code></pre>\n<p>as well. Qualitatively, 2 and 3 are as much different from 0, as 1 is.</p>\n", "LastActivityDate": "2010-01-27T01:46:10.053"}, "2144269": {"ParentId": "2143906", "CommentCount": "0", "CreationDate": "2010-01-27T02:50:29.140", "OwnerUserId": "41661", "PostTypeId": "2", "Id": "2144269", "Score": "2", "Body": "<p>Don't be misled by the notation. Rather annoyingly, C uses the <code>f(void)</code> prototype to mean \"<code>f</code> expects no parameters\" rather than \"<code>f</code> expects a single parameter of type <code>void</code>\".  The notation <code>f()</code> was kept to mean \"the number of parameters that <code>f</code> expects is not known, so you can call it with any number of parameters you like, and good luck to you\".  Before ANSI Standard C (aka C89), there was no such thing as a function prototype, and you needed a tool like <code>lint</code> to protect you against even the most mundane sorts of errors with parameters, such as passing the wrong number of parameters or passing a parameter with a wildly incompatible type.</p>\n<p>As to why you can't use the value of a function return <code>void</code> as a value, or why you can't pass a parameter to a function that expects no parameters, those restrictions are in place to protect you from making the most mundane sorts of errors with parameters.</p>\n", "LastActivityDate": "2010-01-27T02:50:29.140"}, "2143968": {"ParentId": "2143906", "CommentCount": "4", "CreationDate": "2010-01-27T01:27:43.563", "OwnerUserId": "29809", "PostTypeId": "2", "Id": "2143968", "Score": "0", "Body": "<blockquote>\n<p id=\"so_2143906_2143968_0\">At the moment i have something like this in my code: #define EVAL(f) f(++evalcounter) Dont ask me why i use it, i just have to. Normally f does not take any values. I just added this (global) integer just to count something. Wouldnt it be much better if i had something like #define EVAL(f) f( dummy(++evalcounter) ) ? </p>\n</blockquote>\n<p>Have you tried the comma operator:</p>\n<pre><code>#define EVAL(f)   (++evalcounter, f())\n</code></pre>\n", "LastActivityDate": "2010-01-27T01:27:43.563"}, "bq_ids": {"n4140": {"so_2143906_2143995_1": {"section_id": 3240, "quality": 0.6296296296296297, "length": 17}, "so_2143906_2143995_0": {"section_id": 7218, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_2143906_2143995_1": {"section_id": 3113, "quality": 0.8888888888888888, "length": 24}, "so_2143906_2143995_0": {"section_id": 6962, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_2143906_2143995_1": {"section_id": 3996, "quality": 0.6296296296296297, "length": 17}, "so_2143906_2143995_0": {"section_id": 8727, "quality": 0.782608695652174, "length": 18}}}, "2143938": {"ParentId": "2143906", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2010-01-27T01:19:03.640", "Score": "0", "LastEditorUserId": "249810", "LastEditDate": "2010-01-27T02:08:19.003", "Id": "2143938", "OwnerUserId": "249810", "Body": "<p>Let's pretend it works. Can you think of a single hypothetical case where</p>\n<pre><code>bar();\nfoo();\n</code></pre>\n<p>which does precisely the same thing isn't vastly more readable and sensible?</p>\n<p>Edited. Yes, yes. :)</p>\n", "LastActivityDate": "2010-01-27T02:08:19.003"}});