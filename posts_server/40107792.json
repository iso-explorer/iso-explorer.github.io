post_cb({"bq_ids": {"n4140": {"so_40107792_40108049_2": {"length": 34, "quality": 0.6938775510204082, "section_id": 7151}}, "n3337": {"so_40107792_40108049_2": {"length": 33, "quality": 0.673469387755102, "section_id": 6895}}, "n4659": {"so_40107792_40108049_2": {"length": 34, "quality": 0.6938775510204082, "section_id": 8652}}}, "40107792": {"ViewCount": "180", "Body": "<p>Given a static member variable which is initialized from a static member variable of <em>another class</em>, the non-literal <code>struct ii</code> is sometimes default initialized to <code>0</code> <strong>or</strong> to <code>333</code>. This depends on the compilation or linking order. <strong>Pseudocode</strong> to demonstrate:</p>\n<pre><code>class StaticClass: // file 'ONE.cpp/.hpp'\n    static int i = 2\n    static struct ii { int a = 333 }\n\nclass ABC: // file 'abc.cpp'\n    static int abc_i = StaticClass::i   // always 2\n    static struct abc_ii = StaticClass::ii // sometimes 0, sometimes 333\n</code></pre>\n<p>Calling <code>g++ -std=c++11 abc.cpp ONE.cpp &amp;&amp; ./a.out</code> results in <code>i = 2 / ii = 0</code> (gcc 4.8.1, same with clang++ 3.7; <code>-Wall -Wextra</code> never complain).</p>\n<p>But calling <code>g++ -std=c++11 ONE.cpp abc.cpp &amp;&amp; ./a.out</code> results in <code>i = 2 / ii = 333</code> <strong>!</strong></p>\n<p>The same happens with <code>ONE.o abc.o</code> vs <code>abc.o ONE.o</code> and also when concatenating the files one way or another:</p>\n<p><code>cat ONE.cpp abc.cpp &gt; X.cpp &amp;&amp; g++ X.cpp &amp;&amp; ./a.out</code> vs\n<code>cat abc.cpp ONE.cpp &gt; Y.cpp &amp;&amp; g++ Y.cpp &amp;&amp; ./a.out</code></p>\n<p>Removing includes and moving code around in the single file, the default initialization to 0 happens when this order is present:</p>\n<p><code>const OneI ABC::def_ii = StaticClass::ii; const OneI StaticClass::ii = OneI{333};</code></p>\n<p>and the one to 333 with this ordering:</p>\n<p><code>const OneI StaticClass::ii = OneI{333}; const OneI ABC::def_ii = StaticClass::ii;</code></p>\n<p>Why does this even happen with two separate compilation units? Can this be avoided somehow by enforcing the latter ordering all the time? Is using a static pointer in <code>ABC</code> to <code>StaticClass::ii</code> safe (I'd prefer not to, though)?</p>\n<p>Full C++ code:</p>\n<hr>\n<pre><code>/* File: abc.cpp */\n\n#include &lt;iostream&gt;\n#include \"ONE.hpp\"\n\nstruct ABC {\n  ABC();\n\n  static const int def_i;\n  static const OneI def_ii;\n  void arg_i(const int &amp;x) { std::cout &lt;&lt; \"i = \" &lt;&lt; x &lt;&lt; \" \";};\n  void arg_ii(const OneI &amp;x) { std::cout &lt;&lt; \"/ ii = \" &lt;&lt; x.a &lt;&lt; \" \";};\n\n};\n\nABC::ABC() {\n  arg_i(def_i);\n  arg_ii(def_ii);\n}\n\nconst int ABC::def_i = StaticClass::i;\nconst OneI ABC::def_ii = StaticClass::ii;\n\nint main() {\n  ABC a;\n  std::cout &lt;&lt; '\\n';\n}\n/* End: abc.cpp */\n</code></pre>\n<hr>\n<pre><code>/* File: ONE.cpp */\n\n#include &lt;iostream&gt;\n\n#include \"ONE.hpp\"\n\nconst int StaticClass::i = 2;\nconst OneI StaticClass::ii = OneI{333};\n\n/* End: ONE.cpp */\n</code></pre>\n<hr>\n<pre><code>/* File: ONE.hpp */\n\n#include &lt;iostream&gt;\n\n#ifndef One\n#define One\n\nstruct OneI {\n  OneI(int a_) : a(a_) { }\n  int a;\n};\n\nstruct StaticClass {\n  const static int i;\n  const static OneI ii;\n};\n\n#endif // One header guard\n\n/* End: ONE.hpp */\n</code></pre>\n</hr></hr></hr>", "AcceptedAnswerId": "40108049", "Title": "C++: static on static member variable dependent initialization with int vs struct", "CreationDate": "2016-10-18T12:04:35.697", "Id": "40107792", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-10-18T13:08:12.490", "Score": "7", "OwnerUserId": "2791512", "Tags": "<c++><c++11><static>", "AnswerCount": "1"}, "40108049": {"Id": "40108049", "PostTypeId": "2", "Body": "<p>Congratulations! You've encountered the <a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order\" rel=\"nofollow\">static initialization order fiasco</a>.</p>\n<p>The initialization order of static objects is not defined across multiple translation units.</p>\n<p><code>StaticClass::ii</code> is defined in <code>ONE.cpp</code> and <code>ABC::def_ii</code> is defined in <code>abc.cpp</code>. Therefore <code>StaticClass::ii</code> may or may not be initialized before <code>ABC::def_ii</code>. Since the initialization of <code>ABC::def_ii</code> uses the value of <code>StaticClass::ii</code> the value will depend on whether <code>StaticClass::ii</code> was initialized yet<sup>\u2020</sup>.</p>\n<p>The initialization order of static objects <em>within</em> a translation unit is defined. Objects are initialized in the order in which they are defined.  Therefore when you concatenate the source files, the order of initialization is defined. However, when you concatenate the files in the wrong order, the defined initialization order is wrong:</p>\n<pre><code>const OneI ABC::def_ii = StaticClass::ii; // StaticClass::ii wasn't initialized yet\nconst OneI StaticClass::ii = OneI{333};\n</code></pre>\n<blockquote>\n<p id=\"so_40107792_40108049_0\">Can this be avoided somehow by enforcing the latter ordering all the time?</p>\n</blockquote>\n<p>Most trivial solution is to define both objects in the same translation unit, in the correct order. A more general solution is to initialize your static objects using <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Construct_On_First_Use\" rel=\"nofollow\">Construct On First Use Idiom</a>.</p>\n<blockquote>\n<p id=\"so_40107792_40108049_1\">Is using a static pointer in <code>ABC</code> to <code>StaticClass::ii</code> safe (I'd prefer not to, though)?</p>\n</blockquote>\n<p>As long as the dereferenced value of the pointer isn't used during the initialization of a static object in another translation unit that where the pointed object is defined, yes, replacing <code>ABC::def_ii</code> with a pointer would be safe.</p>\n<hr>\n<p><sup>\u2020</sup> <code>StaticClass::ii</code> will have been zero-initialized during the static initialization phase<sup>\u2020\u2020</sup>. The Static initialization order fiasco concerns the dynamic initialization phase<sup>\u2020\u2020</sup>.</p>\n<p><sup>\u2020\u2020</sup> C++ standard draft <a href=\"http://eel.is/c++draft/basic.start.static\" rel=\"nofollow\">[basic.start.static]</a></p>\n<blockquote>\n<p id=\"so_40107792_40108049_2\">If constant initialization is not performed, a variable with static storage duration ([basic.stc.static]) or thread storage duration ([basic.stc.thread]) is zero-initialized ([dcl.init]). Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place. [ Note: The dynamic initialization of non-local variables is described in [basic.start.dynamic]; that of local static variables is described in [stmt.dcl].  \u2014 end note ]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2016-10-18T13:08:12.490", "Score": "4", "CreationDate": "2016-10-18T12:17:32.720", "ParentId": "40107792", "CommentCount": "6", "LastEditDate": "2016-10-18T13:08:12.490", "OwnerUserId": "2079303"}});