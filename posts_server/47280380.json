post_cb({"47280516": {"ParentId": "47280380", "CommentCount": "1", "Body": "<p>Another thread may erase the element, or destroy the map, which would of course also invalidate the element. </p>\n<p>Erasing an element only invalidates iterators and refewrences to this element. Insertion does not invalidate iterators or references into the map. </p>\n<p>(that's what the <a href=\"http://en.cppreference.com/w/cpp/container/map/erase\" rel=\"nofollow noreferrer\">second-hand documentation says</a>, at least - and it's an assumption I hold that never was invalidated, if anecdotal evidence counts.)</p>\n<p>Another problem remains: Manipulation of the element through the returned reference is not thread safe. You need to sync e.g. per element - and make sure you don't violate lock hierarchy. </p>\n", "OwnerUserId": "31317", "PostTypeId": "2", "Id": "47280516", "Score": "3", "CreationDate": "2017-11-14T08:04:23.880", "LastActivityDate": "2017-11-14T08:04:23.880"}, "47280517": {"ParentId": "47280380", "CommentCount": "2", "Body": "<p>The iterator invalidation rule for associative containers (which <code>std::map</code> is) says at <a href=\"https://timsong-cpp.github.io/cppwp/n3337/associative.reqmts#9\" rel=\"noreferrer\">[associative.reqmts]/9</a>:</p>\n<blockquote>\n<p id=\"so_47280380_47280517_0\">The insert and emplace members shall not affect the validity of\n  iterators and references to the container, and the erase members shall\n  invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>So if one thread inserts an element, it won't affect any references to existing elements. But if it removes something, other threads may be borked. Some form of element-wise locking is in order, I'd say.</p>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "47280517", "Score": "7", "CreationDate": "2017-11-14T08:04:31.450", "LastActivityDate": "2017-11-14T08:04:31.450"}, "bq_ids": {"n4140": {"so_47280380_47280517_0": {"section_id": 745, "quality": 0.9375, "length": 15}}, "n3337": {"so_47280380_47280517_0": {"section_id": 734, "quality": 0.9375, "length": 15}}, "n4659": {"so_47280380_47280517_0": {"section_id": 803, "quality": 0.9375, "length": 15}}}, "47280380": {"CommentCount": "4", "ViewCount": "457", "CreationDate": "2017-11-14T07:55:22.827", "LastActivityDate": "2017-11-14T08:06:04.503", "Title": "Can a reference to an element inside an std::map be invalidated?", "AcceptedAnswerId": "47280517", "PostTypeId": "1", "Id": "47280380", "Score": "8", "Body": "<p>I have a multi-threaded application and a shared resource <code>std::map&lt;KeyType, ElementType&gt;</code>. I use a mutex to protect inserts, gets and removes.</p>\n<p>My get method returns a reference to the stored element (unlocks on return), and then I do some work with that element.</p>\n<p><strong>Question:</strong> Is it possible that while working with the stored element reference, another thread may change the <code>std::map</code> so the element will be moved to a different address and the reference will no longer be valid? (I know there are certain ADT implementations which do rearrangement of the ADT on resize).</p>\n", "Tags": "<c++><multithreading><c++11><std>", "OwnerUserId": "5470144", "AnswerCount": "2"}});