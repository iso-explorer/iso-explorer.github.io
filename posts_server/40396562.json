post_cb({"bq_ids": {"n4140": {"so_40396562_40396752_1": {"length": 18, "quality": 1.0, "section_id": 31}, "so_40396562_40396752_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}, "n3337": {"so_40396562_40396752_1": {"length": 18, "quality": 1.0, "section_id": 28}, "so_40396562_40396752_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 29}}, "n4659": {"so_40396562_40396752_1": {"length": 18, "quality": 1.0, "section_id": 31}, "so_40396562_40396752_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "40396562": {"ViewCount": "106", "Body": "<p>The following code has been compiled on 3 different compilers and 3 different processors and gave 2 different results:</p>\n<pre><code>typedef unsigned long int u32;\ntypedef signed long long s64;\nint main ()\n{ u32 Operand1,Operand2;\n  s64 Result;\n  Operand1=95;\n  Operand2=100;\n  Result= (s64)(Operand1-Operand2);}\n</code></pre>\n<p>Result produces 2 results:\neither \n<code>-5</code>  or <code>4294967291</code></p>\n<p>I do understand that the operation of <code>(Operand1-Operand2)</code> is done in as 32-bit unsigned calculation, then when casted to <code>s64</code> sign extension was done correctly in the first case but not done correctly for the 2nd case.</p>\n<p>My question is whether the sign extension is possible to be controlled via compiler options, or it is compiler-dependent or maybe it is target-dependent.</p>\n", "Title": "Is Sign Extension in C++ a compiler option, or compiler dependent or target dependent?", "CreationDate": "2016-11-03T08:10:09.373", "LastActivityDate": "2016-11-03T08:49:53.220", "CommentCount": "12", "LastEditDate": "2016-11-03T08:29:31.427", "PostTypeId": "1", "LastEditorUserId": "4850040", "Id": "40396562", "Score": "-3", "OwnerUserId": "5600228", "Tags": "<c++><compiler-options>", "AnswerCount": "3"}, "40396922": {"Id": "40396922", "PostTypeId": "2", "Body": "<p>Type promotions, and the corresponding sign-extensions are specified by the C++ language.</p>\n<p>What's not specified, but is platform-dependent, is the range of integer types provided.  It's even Standard-compliant for <code>char</code>, <code>short int</code>, <code>int</code>, <code>long int</code> and <code>long long int</code> all to have the same range, provided that range satisfies the C++ Standard requirements for <code>long long int</code>.  On such a platform, no widening or narrowing would ever happen, but signed&lt;-&gt;unsigned conversion could still alter values.</p>\n", "LastActivityDate": "2016-11-03T08:35:42.200", "CommentCount": "0", "CreationDate": "2016-11-03T08:35:42.200", "ParentId": "40396562", "Score": "1", "OwnerUserId": "4850040"}, "40396673": {"Id": "40396673", "PostTypeId": "2", "Body": "<p>Sign extension is platform dependent, where platform is a combination of a compiler, target hardware architecture and operating system.</p>\n<p>Moreover, as Paul R mentioned, width of built-in types (like <code>unsigned long</code>) is platform-dependent too. Use types from <code>&lt;cstdint&gt;</code> to get fixed-width types. Nevertheless, they are just platform-dependent definitions, so their sign extension behavior still depends on the platform.</p>\n<p><a href=\"https://stackoverflow.com/questions/2331751/does-the-size-of-an-int-depend-on-the-compiler-and-or-processor\">Here</a> is a good almost-duplicate question about type sizes. And <a href=\"https://stackoverflow.com/a/13398763/1690777\">here</a> is a good table about type size relations.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-03T08:26:39.153", "Score": "2", "CreationDate": "2016-11-03T08:18:38.490", "ParentId": "40396562", "CommentCount": "0", "OwnerUserId": "1690777", "LastEditDate": "2017-05-23T12:01:26.917"}, "40396752": {"Id": "40396752", "PostTypeId": "2", "Body": "<p>Your issue is that you assume <code>unsigned long int</code> to be 32 bit wide and <code>signed long long</code> to be 64 bit wide. <strong>This assumption is wrong</strong>.</p>\n<p><a href=\"http://ideone.com/6ctjZj\" rel=\"nofollow noreferrer\">We can visualize what's going on</a> by using <a href=\"http://en.cppreference.com/w/cpp/types/integer\" rel=\"nofollow noreferrer\">types that have a guaranteed (by the standard) bit width</a>:</p>\n<pre><code>int main() {\n    {\n        uint32_t large = 100, small = 95;\n        int64_t result = (small - large);\n        std::cout &lt;&lt; \"32 and 64 bits: \" &lt;&lt; result &lt;&lt; std::endl;\n    }  // 4294967291\n    {\n        uint32_t large = 100, small = 95;\n        int32_t result = (small - large);\n        std::cout &lt;&lt; \"32 and 32 bits: \" &lt;&lt; result &lt;&lt; std::endl;\n    }  // -5\n    {\n        uint64_t large = 100, small = 95;\n        int64_t result = (small - large);\n        std::cout &lt;&lt; \"64 and 64 bits: \" &lt;&lt; result &lt;&lt; std::endl;\n    }  // -5\n    return 0;\n}\n</code></pre>\n<p>In every of these three cases, the expression <code>small - large</code> results in a  result of <strong>unsigned</strong> integer type (of according width). This result is calculated using modular arithmetic.</p>\n<p>In the first case, because that unsigned result can be stored in the wider signed integer, no conversion of the value is performed.</p>\n<p>In the other cases the result <strong>cannot</strong> be stored in the signed integer. Thus an implementation defined conversion is performed, which usually means interpreting the bit pattern of the unsigned value as signed value. Because the result is \"large\", the highest bits will be set, which when treated as signed value (under two's complement) is equivalent to a \"small\" negative value.</p>\n<hr>\n<p>To highlight the comment from L\u01b0u V\u0129nh Ph\u00fac:</p>\n<blockquote>\n<p id=\"so_40396562_40396752_0\"><code>Operand1-Operand2</code> is unsigned therefore when casting to s64 it's always zero extension. [..]</p>\n</blockquote>\n<p>The sign extension is only done in the first case as only then there is a widening conversion, and it is indeed always zero extension.</p>\n<hr>\n<p>Quotes from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">the standard</a>, emphasis mine. Regarding <code>small - large</code>:</p>\n<blockquote>\n<p id=\"so_40396562_40396752_1\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo <code>2^n$</code> where n is the number of bits used to represent the unsigned type). [..]</p>\n<p id=\"so_40396562_40396752_2\">\u00a7 4.7/2</p>\n</blockquote>\n<p>Regarding the conversion from unsigned to signed:</p>\n<blockquote>\n<p id=\"so_40396562_40396752_3\">If the destination type [of the integral conversion] is signed, the value is unchanged if it can be represented in the destination type; otherwise, the value is <strong>implementation-defined</strong>.</p>\n<p id=\"so_40396562_40396752_4\">\u00a7 4.7/3</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "1116364", "LastActivityDate": "2016-11-03T08:49:53.220", "Score": "5", "CreationDate": "2016-11-03T08:24:40.743", "ParentId": "40396562", "CommentCount": "4", "OwnerUserId": "1116364", "LastEditDate": "2016-11-03T08:49:53.220"}});