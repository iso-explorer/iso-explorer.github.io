post_cb({"bq_ids": {"n4140": {"so_17655880_17655982_0": {"section_id": 2710, "quality": 0.7083333333333334, "length": 17}}, "n3337": {"so_17655880_17655982_0": {"section_id": 2671, "quality": 0.7083333333333334, "length": 17}}, "n4659": {"so_17655880_17655982_0": {"section_id": 3450, "quality": 0.7083333333333334, "length": 17}}}, "17655982": {"ParentId": "17655880", "CommentCount": "0", "Body": "<p>From C++11, 30.3.1.2/4, about the <code>thread</code> constructor you mention:</p>\n<blockquote>\n<pre><code>template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);\n</code></pre>\n<p id=\"so_17655880_17655982_0\"><em>Effects:</em> Constructs an object of type <code>thread</code>. The new thread of execution executes <code>INVOKE (DECAY_COPY(std::forward&lt;F&gt;(f)), DECAY_COPY(std::forward&lt;Args&gt;(args))...)</code> with the calls to <code>DECAY_COPY</code> being evaluated in the constructing thread. Any return value from this invocation is ignored.</p>\n</blockquote>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "17655982", "Score": "2", "CreationDate": "2013-07-15T13:54:59.223", "LastActivityDate": "2013-07-15T13:54:59.223"}, "17655990": {"ParentId": "17655880", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, there is no guarantee that the thread has started execution when the <code>std::thread</code> constructor has finished. All that is guaranteed is that it is scheduled for execution, so at some point after the constructor is called the thread will run, and that it will be completed before the call to <code>join()</code> on the relevant <code>std::thread</code> object returns.</p>\n", "OwnerUserId": "5597", "LastEditorUserId": "1090079", "LastEditDate": "2013-07-15T14:30:02.290", "Id": "17655990", "Score": "9", "CreationDate": "2013-07-15T13:55:08.273", "LastActivityDate": "2013-07-15T14:30:02.290"}, "17656153": {"ParentId": "17655880", "CommentCount": "0", "Body": "<p>There can't be such a gurantee in the C++ standard, as the thread created will be put to the run queue of the scheduler and eventually being executed (depending on the priority and the way the OS is handling such things). </p>\n<p>In fact neither chap. 20 nor chap. 30 of the C++ standard give such a guarantee.</p>\n", "OwnerUserId": "2216000", "PostTypeId": "2", "Id": "17656153", "Score": "1", "CreationDate": "2013-07-15T14:03:00.283", "LastActivityDate": "2013-07-15T14:03:00.283"}, "17655880": {"CommentCount": "0", "ViewCount": "294", "PostTypeId": "1", "LastEditorUserId": "1574294", "CreationDate": "2013-07-15T13:50:09.377", "LastActivityDate": "2013-07-15T14:30:02.290", "Title": "std::thread construction and execution", "AcceptedAnswerId": "17655990", "LastEditDate": "2013-07-15T13:52:49.670", "Id": "17655880", "Score": "1", "Body": "<p>I could not find any information in the <a href=\"http://en.cppreference.com/w/cpp/thread/thread/thread\" rel=\"nofollow\">documentation</a> if there is a guarantee that the thread is actually running after the thread object construction was finished or not. In other words is there a guarantee that the thread function is already being executed after the thread constructor is complete? Some references would be greatly appreciated.</p>\n", "Tags": "<c++><multithreading><c++11><constructor>", "OwnerUserId": "1574294", "AnswerCount": "5"}, "17656084": {"ParentId": "17655880", "CommentCount": "0", "Body": "<p>What does it mean by \"running\"?  There is a guarantee that the\narguments will have been copied, and, at least on most systems,\nthe copy must take place in the newly created thread.  But that\ndoesn't mean much.  For that matter, what would be significant?\nThat the newly created thread execute a single machine\ninstruction before you return from the constructor?  That it\nhave executed a complete C++ statement?  Or what? </p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "17656084", "Score": "1", "CreationDate": "2013-07-15T14:00:23.900", "LastActivityDate": "2013-07-15T14:00:23.900"}, "17655985": {"ParentId": "17655880", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_17655880_17655985_0\">is there a guarantee that the thread function is already being executed after the thread constructor is complete</p>\n</blockquote>\n<p>C++ standard can not require this.</p>\n<p>It depends on the operating system, its process scheduler and the current system load. Sometimes the thread has started executing when <code>thread</code> constructor returns, sometimes it has not.</p>\n<p>It it possible though for the new thread to let your parent thread know whether it has started executing yet using IPC, such as, signals, pipe or a mutex and a condition variable.</p>\n", "OwnerUserId": "412080", "LastEditorUserId": "412080", "LastEditDate": "2013-07-15T14:03:25.880", "Id": "17655985", "Score": "4", "CreationDate": "2013-07-15T13:55:02.910", "LastActivityDate": "2013-07-15T14:03:25.880"}});