post_cb({"26036863": {"ParentId": "25987790", "CommentCount": "1", "Body": "<pre><code>f[\"hello\"]; \n</code></pre>\n<p>translates to f.operator [] (index), where index is the value of the pointer pointing to \"hello\". In your case, it calls operator [](size_t i). Thus, is absolutely ok that compiler does not complain. In fact the index value would be a l;arge value (value of a pointer), so better be careful while overloading [] and check for upper boundary there\nIn fact, if you have:</p>\n<pre><code>char *c = \"hello\"; // c is a pointer\nf[c]; // ok\n</code></pre>\n", "OwnerUserId": "2032021", "PostTypeId": "2", "Id": "26036863", "Score": "0", "CreationDate": "2014-09-25T10:57:48.660", "LastActivityDate": "2014-09-25T10:57:48.660"}, "25987942": {"ParentId": "25987790", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The reason that line compiles is that, with the implicit conversion, it can be reinterpreted as <code>'a'[\"hello\"];</code>, which in turn is the same as writing <code>*(('a')+(\"hello\"));</code> which also compiles.</p>\n<p>Excerpt for the Standard:</p>\n<blockquote>\n<p id=\"so_25987790_25987942_0\">5.2.1 Subscripting:</p>\n<p id=\"so_25987790_25987942_1\">... The\n  expression E1[E2] is identical (by definition) to *((E1)+(E2)) ...</p>\n</blockquote>\n<p>The easiest workaround without making the conversion operator explicit is to declare the offending subscript operator as deleted:</p>\n<pre><code>struct foo\n{\n  operator char() const { return 'a'; }\n  int operator[](size_t i) const { return 1; }\n\n  // prevent accidental use of foo[\"hello\"]\n  int operator[](char const*) const = delete;\n};\n</code></pre>\n", "OwnerUserId": "1707560", "LastEditorUserId": "1651000", "LastEditDate": "2014-09-23T22:53:53.367", "Id": "25987942", "Score": "34", "CreationDate": "2014-09-23T06:04:47.480", "LastActivityDate": "2014-09-23T22:53:53.367"}, "25987790": {"CommentCount": "1", "AcceptedAnswerId": "25987942", "PostTypeId": "1", "LastEditorUserId": "75525", "CreationDate": "2014-09-23T05:53:38.313", "LastActivityDate": "2014-09-25T10:57:48.660", "LastEditDate": "2014-09-24T08:09:41.280", "ViewCount": "932", "FavoriteCount": "6", "Title": "C++ unexpected implict conversion", "Id": "25987790", "Score": "30", "Body": "<p>The following code compiles due to the implicit conversion for <code>char</code>.  I'm not sure why since the only implicit conversion I would expect (and expect to fail) is from <code>char const*</code> to <code>size_t</code>.</p>\n<pre><code>#include &lt;cstddef&gt;\n\nstruct foo\n{\n    int operator[](size_t i) const { return 1; }\n    operator char() const { return 'a'; }\n};\n\nint main()\n{\n    foo f;\n    f[\"hello\"]; // compilation error desired here\n}\n</code></pre>\n<p>What is the implicit conversion here that allows this to compile?  If I remove <code>operator char</code> or make it <code>explicit</code> then the compile fails at the desired location.</p>\n<p>The class that this code is extracted from really does need both the implicit conversion and the <code>operator[]</code>.  So is there a way I can prevent the behaviour without making the conversion explicit?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "1651000", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25987790_25987942_1": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_25987790_25987942_1": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_25987790_25987942_1": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}}}});