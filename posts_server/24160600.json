post_cb({"bq_ids": {"n4140": {"so_24160600_24160661_0": {"length": 27, "quality": 0.9, "section_id": 7080}}, "n3337": {"so_24160600_24160661_0": {"length": 27, "quality": 0.9, "section_id": 6824}}, "n4659": {"so_24160600_24160661_0": {"length": 27, "quality": 0.9, "section_id": 8581}}}, "24160661": {"Id": "24160661", "PostTypeId": "2", "Body": "<p>From <em>N3797</em></p>\n<p><strong>3.3.10/3 Name hiding</strong></p>\n<blockquote>\n<p id=\"so_24160600_24160661_0\">In a member function definition, the declaration of a name at block scope hides the declaration of a member of the class with the same name; see 3.3.7. <strong>The declaration of a member in a derived class (Clause 10) hides the declaration of a member of a base class of the same name</strong>. see 10.2.</p>\n</blockquote>\n<p>So <code>Foo2::foo()</code> hides <code>Foo1::foo()</code>.</p>\n", "LastEditorUserId": "1390091", "LastActivityDate": "2014-06-11T10:42:20.280", "Score": "4", "CreationDate": "2014-06-11T10:31:23.457", "ParentId": "24160600", "CommentCount": "1", "OwnerUserId": "1390091", "LastEditDate": "2014-06-11T10:42:20.280"}, "24160704": {"Id": "24160704", "PostTypeId": "2", "Body": "<p>The <code>foo</code> in the derived class hides the <code>foo</code> with different signature of the base class.</p>\n<p>To say that you want the overloads of the base included you need to add a <code>using</code> declaration to <code>Foo2</code>:</p>\n<pre><code>struct Foo2 : Foo1\n{\n    using Foo1::foo;\n    virtual int foo(int i) = 0;\n};\n</code></pre>\n", "LastActivityDate": "2014-06-11T10:33:28.973", "CommentCount": "2", "CreationDate": "2014-06-11T10:33:28.973", "ParentId": "24160600", "Score": "3", "OwnerUserId": "56338"}, "24160600": {"ViewCount": "57", "Body": "<p>I just stumbled across an compile error and I am wondering why this occurs.<br>\nThe code:</br></p>\n<pre><code>struct Foo1\n{\n    virtual int foo() = 0;\n};\nstruct Foo2 : Foo1\n{\n    virtual int foo(int i) = 0;\n};\nstruct Bar : public Foo2\n{\n    virtual int foo() { return 0; }\n    virtual int foo(int i) { return i; }\n};\nint main() {\n    Bar b;\n    Foo2* f2 = &amp;b;\n    b.foo();\n    //f2-&gt;foo(); // this gives an error\n    return 0;\n}\n</code></pre>\n<p>The error on a gcc 4.8.1 is</p>\n<blockquote>\n<p id=\"so_24160600_24160600_0\">error: no matching function for call to \u2018Foo2::foo()\u2019</p>\n</blockquote>\n<p>I am wondering why the compiler cannot see the <code>Foo1::foo</code> function?\nI know that I can fix this by adding <code>using Foo1::foo</code> to the <code>Foo2</code> class, but can anyone give me a reference to the standard why the compiler is not able to find the function by itself?</p>\n", "AcceptedAnswerId": "24160661", "Title": "Virtual Function access through multiple interfaces", "CreationDate": "2014-06-11T10:28:29.693", "Id": "24160600", "CommentCount": "0", "PostTypeId": "1", "ClosedDate": "2014-06-11T10:38:15.937", "LastActivityDate": "2014-06-11T10:42:20.280", "Score": "1", "OwnerUserId": "264338", "Tags": "<c++>", "AnswerCount": "2"}});