post_cb({"2438386": {"Id": "2438386", "PostTypeId": "2", "Body": "<p>Here's what happens in g++:</p>\n<pre><code>#include &lt;stdio.h&gt;\nclass A {\npublic:\n    ~A()\n    {\n        fprintf(stderr, \"in ~A\\n\");\n        throw \"error\";\n    }\n};\n\nvoid foo()\n{\n    A a;\n    fprintf(stderr, \"in foo\\n\");\n    throw \"error\";\n}\n\nint main()\n{\n    try {\n        foo();\n    }\n    catch (const char*) {\n        return 1;\n    }\n    return 0;\n}\n\n\n[~/ecc/ellcc/ecc] main% ./a.out\nin foo\nin ~A\nterminate called after throwing an instance of 'char const*'\nAbort\n[~/ecc/ellcc/ecc] main% \n</code></pre>\n<p>As you can see, the throw in foo happens first, then the throw in ~A causes the error.</p>\n", "LastActivityDate": "2010-03-13T12:55:32.533", "CommentCount": "1", "CreationDate": "2010-03-13T12:55:32.533", "ParentId": "2438334", "Score": "2", "OwnerUserId": "204046"}, "2438355": {"Id": "2438355", "PostTypeId": "2", "Body": "<p>To illustrate, here's what happens in Microsoft C++:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\npublic:\n    ~A() {\n        std::cout &lt;&lt; \"in ~A\" &lt;&lt; std::endl;\n        throw \"error\";\n    }\n};\n\nvoid foo() {\n    A a;\n    std::cout &lt;&lt; \"in foo\" &lt;&lt; std::endl;\n    throw \"error\";\n}\n\nint main() {\n\n    try {\n        foo();\n    }\n    catch (void *) {\n        std::cout &lt;&lt; \"exit: 1\" &lt;&lt; std::endl;\n        return 1;\n    }\n    std::cout &lt;&lt; \"exit: 0\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>And the result:</p>\n<pre><code>&gt;cpptest1.exe\nin foo\nin ~A\n\nThis application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information.\n\n&gt;\n</code></pre>\n", "LastEditorUserId": "47775", "LastActivityDate": "2010-03-13T14:52:07.757", "Score": "0", "CreationDate": "2010-03-13T12:46:01.890", "ParentId": "2438334", "CommentCount": "2", "OwnerUserId": "47775", "LastEditDate": "2010-03-13T14:52:07.757"}, "2438484": {"Id": "2438484", "PostTypeId": "2", "Body": "<p>You got is slightly wrong and that's why you don't understand it. You see, throw in destructor is not causing <code>teriminate()</code> function to be called, it is a bad practice, but it is not fatal for program execution. What is fatal is that some code throws while there's still active exception. C++ can't decide what exception to propagate further, new one or old one and it can't propagate them both. It is considered fatal for program execution and that's why terminate is called.</p>\n<p>So, you see, without throw in <code>foo</code>, terminate wouldn't be called but there will be an exception thrown from <code>~A</code>. So, naturally, throw in foo has to be called first and then during the second throw everything breaks.</p>\n", "LastActivityDate": "2010-03-13T13:22:57.927", "CommentCount": "1", "CreationDate": "2010-03-13T13:22:57.927", "ParentId": "2438334", "Score": "1", "OwnerUserId": "6258"}, "2438334": {"ViewCount": "2091", "Body": "<p>I'm pondering a question on Brainbench. I actually realised that I could answer my question easily by compiling the code, but it's an interesting question nonetheless, so I'll ask the question anyway and answer it myself shortly.</p>\n<p>Take a look at this snippet:</p>\n<p><a href=\"http://img714.imageshack.us/img714/2791/i546s.gif\" rel=\"nofollow noreferrer\">Snippet from Brainbench http://img714.imageshack.us/img714/2791/i546s.gif</a></p>\n<p>The question considers what happens when we <code>throw</code> from a destructor (which causes <code>terminate()</code> to be called). It's become clear to me by asking the question that the memory is indeed freed and the destructor is called, but, is this <em>before or after</em> <code>throw</code> is called from <code>foo</code>? Perhaps the issue here is that <code>throw</code> is used while the stack is unwinding that is the problem... Actually this is slightly confusing.</p>\n", "AcceptedAnswerId": "2438384", "Title": "Are destructors of automatic objects invoked when terminate is called?", "CreationDate": "2010-03-13T12:38:52.263", "LastActivityDate": "2010-03-13T15:38:43.653", "CommentCount": "9", "LastEditDate": "2010-03-13T15:38:43.653", "PostTypeId": "1", "Tags": "<c++><stack><throw><brainbench>", "Id": "2438334", "AnswerCount": "6", "Score": "2", "OwnerUserId": "47775", "ClosedDate": "2015-06-23T01:13:28.340", "LastEditorUserId": "47775"}, "bq_ids": {"n4140": {"so_2438334_2438384_3": {"length": 8, "quality": 0.8, "section_id": 3382}, "so_2438334_2438384_4": {"length": 38, "quality": 0.95, "section_id": 3383}, "so_2438334_2438384_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 3382}}, "n3337": {"so_2438334_2438384_3": {"length": 8, "quality": 0.8, "section_id": 3251}, "so_2438334_2438384_4": {"length": 38, "quality": 0.95, "section_id": 3252}, "so_2438334_2438384_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 3251}}, "n4659": {"so_2438334_2438384_3": {"length": 8, "quality": 0.8, "section_id": 4142}, "so_2438334_2438384_4": {"length": 38, "quality": 0.95, "section_id": 4143}, "so_2438334_2438384_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 4142}}}, "2438384": {"Id": "2438384", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2438334_2438384_0\">It's become clear to me by asking the\n  question that the memory is indeed\n  freed and the destructor is called,\n  but, is this before or after throw is\n  called from foo?</p>\n</blockquote>\n<p>This is what is happening:</p>\n<ul>\n<li><code>foo()</code> is called</li>\n<li>An object <code>a</code> of type <code>A</code> is created on the stack</li>\n<li>The next statement throws</li>\n<li>Now, the dtor for <code>a</code> is called, which throws another exception</li>\n<li><code>std::terminate</code> is called -- which is nothing but abandoning the exception handling mechanism:</li>\n</ul>\n<p>From C++0x draft:</p>\n<blockquote>\n<p id=\"so_2438334_2438384_1\"><strong>15.5.1 The std::terminate() function</strong></p>\n<p id=\"so_2438334_2438384_2\"><strong>1</strong> In the following situations exception\n  handling must be abandoned for less\n  subtle error handling techniques:</p>\n<p id=\"so_2438334_2438384_3\">[...]\n  \u2014 when the destruction of\n  an object during stack unwinding\n  (15.2) exits using an exception, or</p>\n<p id=\"so_2438334_2438384_4\"><strong>2</strong> In such cases, std::terminate() is\n  called (18.7.3). In the situation\n  where no matching handler is found, it\n  is implementation-defined whether or\n  not the stack is unwound before\n  std::terminate() is called. <em>In all\n  other situations, the stack shall not\n  be unwound before std::terminate() is\n  called. An implementation is not\n  permitted to finish stack unwinding\n  prematurely based on a determination\n  that the unwind process will\n  eventually cause a call to\n  std::terminate().</em></p>\n<p id=\"so_2438334_2438384_5\"><em>Note: Emphasis mine</em></p>\n</blockquote>\n", "LastActivityDate": "2010-03-13T12:55:25.203", "CommentCount": "0", "CreationDate": "2010-03-13T12:55:25.203", "ParentId": "2438334", "Score": "13", "OwnerUserId": "66692"}, "2438378": {"Id": "2438378", "PostTypeId": "2", "Body": "<p>If I'm not mistaken, once <code>terminate</code> is called, no (further) stack unwinding would occur.</p>\n<p><code>terminate</code> calls a handler function (which you can set with <code>set_terminate</code>):</p>\n<blockquote>\n<p id=\"so_2438334_2438378_0\">The type of a handler function to be\n  called by terminate() when terminating\n  exception processing.<br>\n<strong>Required\n  behavior</strong>:\n      A terminate_handler shall terminate execution of the program\n  without returning to the caller.<br>\n<strong>Default behavior:</strong>\n      The implementation's default terminate_handler calls abort().</br></br></p>\n</blockquote>\n<p>At least I don't know of a way to \"terminate execution without returning to the caller\" that would allow you to unwind the stack. </p>\n<p>You can modify the example to see what you can expect:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nclass A\n{\n    public:\n        ~A() {\n            puts(\"Entered A destructor\");\n            throw \"error\";\n        }\n};\n\nvoid foo()\n{\n    A a, b;\n    throw \"error\";\n}\n\nint main()\n{\n    try {\n        foo();\n    } catch (const char*) {\n        return 1;\n    }\n}\n</code></pre>\n<p>Now there are two A instances, and the destructor of the second one is never called, because the execution was terminated as soon as the destructor of the first A finished and let another exception escape.</p>\n", "LastEditorUserId": "155693", "LastActivityDate": "2010-03-13T13:30:04.087", "Score": "1", "CreationDate": "2010-03-13T12:52:35.677", "ParentId": "2438334", "CommentCount": "0", "OwnerUserId": "155693", "LastEditDate": "2010-03-13T13:30:04.087"}, "2438345": {"Id": "2438345", "PostTypeId": "2", "Body": "<p>Object <code>a</code> is a stack object, so there is no dynamic memory to be freed. Once control goes out of the scope of <code>foo()</code>, the stack frame, and therefore the object, no longer exists.</p>\n", "LastActivityDate": "2010-03-13T12:43:55.530", "CommentCount": "1", "CreationDate": "2010-03-13T12:43:55.530", "ParentId": "2438334", "Score": "0", "OwnerUserId": "174963"}});