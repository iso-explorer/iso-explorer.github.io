post_cb({"16192961": {"Id": "16192961", "PostTypeId": "2", "Body": "<p>There are three general cases to consider when deducing template parameters like this.</p>\n<ol>\n<li><p><code>void foo(T x)</code>: this means \"pass-by-value\". It always deduces a type as appropriate to pass by value.</p></li>\n<li><p><code>void foo(T&amp; x)</code>: this means \"pass-by-lvalue-reference\". It always deduces a type as appropriate to pass by lvalue reference.</p></li>\n<li><p><code>void foo(T&amp;&amp; x)</code>: this means \"pass-by-reference\". It always deduces a type as appropriate to pass by reference, which may be an lvalue reference or an rvalue reference.</p></li>\n</ol>\n", "LastActivityDate": "2013-04-24T13:12:35.730", "CommentCount": "0", "CreationDate": "2013-04-24T13:12:35.730", "ParentId": "16192796", "Score": "6", "OwnerUserId": "46642"}, "bq_ids": {"n4140": {"so_16192796_16192955_0": {"length": 19, "quality": 0.95, "section_id": 304}}, "n3337": {"so_16192796_16192955_0": {"length": 19, "quality": 0.95, "section_id": 295}}, "n4659": {"so_16192796_16192955_0": {"length": 19, "quality": 0.95, "section_id": 311}}}, "16192955": {"Id": "16192955", "PostTypeId": "2", "Body": "<p>This is because of the way <em>type deduction</em> is defined, and it is only related to perfect forwarding in the sense that the result of <code>std::forward&lt;&gt;()</code> is an rvalue if an rvalue reference is passed, and an lvalue if an lvalue reference is passed. </p>\n<p>But in general, <strong>when you do not have a reference to begin with, your <code>T</code> is not going to be deduced as a reference type</strong> (i.e. as <code>A&amp;</code>, whatever <code>A</code> could be). If that was the case, as <a href=\"https://stackoverflow.com/questions/16192796/when-you-perfect-forward-typename-t-becomes-a-t-or-t-but-when-you-dont-t/16192955#comment23151213_16192955\">Yakk</a> correctly points out in the comments, it would be impossible to write a function template that takes its arguments by value.</p>\n<p>In particular, the reference collapsing rule you are referring to is defined in Paragraph 14.8.2.1/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16192796_16192955_0\">If P is a\n  reference type, the type referred to by P is used for type deduction. <strong>If P is an rvalue reference to a cv-unqualified\n  template parameter and the argument is an lvalue, the type \u201clvalue reference to A\u201d is used in\n  place of A for type deduction</strong>. [ <em>Example</em>:</p>\n<pre><code>template &lt;class T&gt; int f(T&amp;&amp;);\ntemplate &lt;class T&gt; int g(const T&amp;&amp;);\nint i;\nint n1 = f(i); // calls f&lt;int&amp;&gt;(int&amp;)\nint n2 = f(0); // calls f&lt;int&gt;(int&amp;&amp;)\nint n3 = g(i); // error: would call g&lt;int&gt;(const int&amp;&amp;), which\n// would bind an rvalue reference to an lvalue\n</code></pre>\n<p id=\"so_16192796_16192955_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-24T13:33:49.950", "Score": "7", "CreationDate": "2013-04-24T13:12:15.170", "ParentId": "16192796", "CommentCount": "3", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T11:57:18.633"}, "16192949": {"Id": "16192949", "PostTypeId": "2", "Body": "<p>A template parameter <code>T</code> can be deduced as a reference type <strong>only</strong> if it appears in a function parameter of the form <code>T&amp;&amp;</code></p>\n<p>A function template of the form:</p>\n<ul>\n<li><p><dt><code>template&lt;class T&gt; void f(T x)</code></dt> <dd> will deduce <code>T</code> as an object type (and <code>x</code> is an object type so is passed by value)</dd></p></li>\n<li><p><dt><code>template&lt;class T&gt; void f(T&amp; x)</code></dt> <dd> will deduce <code>T</code> as an object type (and then <code>x</code> has lvalue reference type)</dd></p></li>\n<li><p><dt><code>template&lt;class T&gt; void f(T&amp;&amp; x)</code></dt> <dd> will deduce <code>T</code> as</dd></p>\n<ul>\n<li><em>either</em> an lvalue reference (so <code>x</code> has lvalue reference type due to reference collapsing rules)</li>\n<li><em>or</em> as an object type (so <code>x</code> has rvalue reference type)<br>\n</br></li></ul></li></ul>\n<blockquote>\n<p id=\"so_16192796_16192949_0\"><strong>How come in the perfect forwarding function, T turns into a T&amp; or T&amp;&amp;, <em>[...]</em></strong></p>\n</blockquote>\n<p>This is wrong.  <code>T</code> becomes a <strong>reference type <code>L&amp;</code></strong> or <strong>an object type <code>R</code></strong>, <em>not</em> a reference <code>R&amp;&amp;</code>.<br>\nThe function parameter of the form <code>T&amp;&amp;</code> thus becomes </br></p>\n<ul>\n<li>either <code>L&amp;</code> (because adding an rvalue reference to an lvalue reference is still an lvalue reference, just like <code>add_rvalue_reference&lt;L&amp;&gt;::type</code> is still <code>L&amp;</code>)</li>\n<li>or it becomes <code>R&amp;&amp;</code> (because <code>add_rvalue_reference&lt;R&gt;::type</code> is <code>R&amp;&amp;</code>)</li>\n</ul>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-04-24T13:22:59.820", "Score": "9", "CreationDate": "2013-04-24T13:11:51.623", "ParentId": "16192796", "CommentCount": "1", "OwnerUserId": "981959", "LastEditDate": "2013-04-24T13:22:59.820"}, "16192796": {"ViewCount": "409", "Body": "<p>I'm reading about perfect forwarding, and this is something I've learnt that has confused me: <br>When you're trying to achieve perfect forwarding, you'll do something like this:</br></p>\n<pre><code>template&lt;class T&gt; // If I were to call foo with an l-value int, foo would look\nvoid foo(T &amp;&amp;x);  // like this: void foo(int&amp; &amp;&amp;x)\n</code></pre>\n<p>So then I thought, wait, does that mean that if I did this:</p>\n<pre><code>template&lt;class T&gt; // If I were to call foo with an l-value int, foo would look\nvoid foo(T x);    // like this: void foo(int&amp; x);\n</code></pre>\n<p>But that's not what happens. <em>foo</em> instead looks like this: <code>void foo(int x);</code> </p>\n<p><strong>My question: How come in the perfect forwarding function, T turns into a T&amp; or T&amp;&amp;, but in the other one, T isn't a reference? Can somebody tell me the exact rules for this? I need some clarification!</strong></p>\n", "AcceptedAnswerId": "16192949", "Title": "When you perfect-forward, typename T becomes a T& or T&&, but when you don't, T isn't a reference at all. How?", "CreationDate": "2013-04-24T13:05:06.110", "Id": "16192796", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-24T13:33:49.950", "Score": "5", "OwnerUserId": "1149522", "Tags": "<c++><templates><c++11>", "AnswerCount": "4"}, "16192996": {"Id": "16192996", "PostTypeId": "2", "Body": "<p>Relax, slow down, and breathe.</p>\n<p><em>Template argument deduction</em> is the central mechanism that you need to understand, and it's not totally trivial. When you say <code>template &lt;typename T&gt; void foo(T)</code>, then <code>T</code> is <em>always</em> deduced as a non-reference type.</p>\n<p>If you want a reference, you have to put a <code>&amp;</code> on it: <code>template &lt;typename T&gt; void foo(T&amp;)</code> will also deduce <code>T</code> as a non-reference-type, but <code>foo</code> now always expects an lvalue reference.</p>\n<p>The final piece of magic comes from the new reference collapsing rules. When you say <code>template &lt;typename T&gt; void foo(T&amp;&amp;)</code>, then two things can happen:</p>\n<ul>\n<li><p>You call <code>foo</code> with an rvalue, e.g. <code>foo(Bar())</code>. Then <code>T</code> is deduced as <code>Bar</code>, and <code>foo</code> takes an rvalue reference to <code>Bar</code>, i.e. a <code>Bar&amp;&amp;</code>.</p></li>\n<li><p>You call <code>foo</code> with an lvalue, e.g. <code>Bar x; foo(x);</code>. Now the only thing <code>foo</code> can take is an lvalue reference. This requires <code>T</code> to be deduced as <code>Bar&amp;</code>, since <code>T&amp;&amp; == Bar&amp; &amp;&amp; == Bar&amp;</code>, due to the collapsing rules.</p></li>\n</ul>\n<p>Only this final template is able to accept both lvalues and rvalues. This is why it is sometimes called \"universal reference\"; but remember that it's not the reference that matters, but the template argument deduction. Using <code>std::forward&lt;T&gt;</code> allows you to pass on the argument with the same value category that you received.</p>\n", "LastActivityDate": "2013-04-24T13:14:06.163", "CommentCount": "0", "CreationDate": "2013-04-24T13:14:06.163", "ParentId": "16192796", "Score": "6", "OwnerUserId": "596781"}});