post_cb({"15273964": {"CommentCount": "10", "ViewCount": "589", "PostTypeId": "1", "LastEditorUserId": "2068573", "CreationDate": "2013-03-07T14:38:05.957", "LastActivityDate": "2015-01-08T15:48:43.460", "Title": "Work around for vector<bool>, use basic_string<bool>?", "FavoriteCount": "0", "LastEditDate": "2015-01-08T15:48:43.460", "Id": "15273964", "Score": "6", "Body": "<p>Is this a safe workaround? I want to use <em>vector bool</em> but need to pass a pointer to old code expecting C-style array.</p>\n<pre><code>typedef std::basic_string&lt;bool&gt; vector_bool;\n\nint main()\n{\n    vector_bool ab;\n    ab.push_back(true);\n    ab.push_back(true);\n    ab.push_back(true);\n    ab.push_back(false);\n    bool *b = &amp;ab[0];\n    b[1] = false;\n}\n</code></pre>\n<p>Edit:\nThanks for suggestions of other solutions, but I would really like a definite answer on my above solution. Thanks.</p>\n", "Tags": "<c++>", "OwnerUserId": "2068573", "AnswerCount": "3"}, "15274156": {"ParentId": "15273964", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-03-07T14:46:09.753", "Score": "14", "LastEditorUserId": "981959", "LastEditDate": "2013-03-07T16:02:32.267", "Id": "15274156", "OwnerUserId": "981959", "Body": "<p>I'm not sure about <code>std::basic_string&lt;bool&gt;</code> because that will instantiate <code>std::char_traits&lt;bool&gt;</code> and I'm not sure if the standard requires that to be defined, or if the <code>char_traits</code> primary template can be left undefined, with only explicit specializations such as <code>char_traits&lt;char&gt;</code> being defined.  You're not allowed to provide your own specialization of <code>char_traits&lt;bool&gt;</code> because you can only specialize standard templates if the specialization depends on a user-defined type, which <code>bool</code> obviously isn't.  That said, it might work if your stdlib does have a default <code>char_traits</code> definition, and you don't try to use an string operations that require members of <code>char_traits</code> to do anything useful.</p>\n<p>Alternatively, this is hacky but might work:</p>\n<pre><code>struct boolish { bool value; };\ninline boolish make_boolish(bool b) { boolish bish = { b }; return bish; }\n\nstd::vector&lt;boolish&gt; b;\nb.push_back( make_boolish(true) );\nbool* ptr = &amp;b.front().value;\n</code></pre>\n<p><code>boolish</code> is a trivial type, so as long as an array of <code>boolish</code> has the same representation as an array of <code>bool</code> (which you'd need to check for your compiler, I used a <code>static_assert</code> to check there is no padding) then you might get away with it, although it probably violates the aliasing rules because <code>*ptr</code> and <code>*++ptr</code> are not part of the same array, so incrementing the pointer doesn't point to the next <code>boolish::value</code> it points \"past the end\" of the previous one (even if those two locations actually have the same address, although [basic.compound]/3 does seem to say that <code>++ptr</code> does \"point to\" the next <code>bool</code>).</p>\n<p>The syntax gets a bit easier with C++11, you don't need <code>make_boolish</code> ...</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;assert.h&gt;\n\nstruct boolish { bool value; };\n\nint main()\n{\n  std::vector&lt;boolish&gt; vec(10);\n  vec.push_back( boolish{true} );\n  bool* ptr = &amp;vec.front().value;\n  assert( ptr[10] == true );\n  ptr[3] = true;\n  assert( vec[3].value == true );\n\n  static_assert( sizeof(boolish) == sizeof(bool), \"\" );\n  boolish test[10];\n  static_assert( sizeof(test) == (sizeof(bool)*10), \"\" );\n}\n</code></pre>\n", "LastActivityDate": "2013-03-07T16:02:32.267"}, "15274831": {"ParentId": "15273964", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-03-07T15:18:48.287", "Score": "2", "LastEditorUserId": "14065", "LastEditDate": "2013-03-07T15:35:01.943", "Id": "15274831", "OwnerUserId": "14065", "Body": "<p>Everything Jonathan Weekly said.</p>\n<p>But I would go simpler:<br>\nI would use:</br></p>\n<pre><code>assert(sizeof(bool) == sizeof(char));\ntypedef std::vecor&lt;char&gt; vector_bool;  // Now all the rest of your code works as expected\n                                       // without the need for a maker function.\n</code></pre>\n", "LastActivityDate": "2013-03-07T15:35:01.943"}, "bq_ids": {"n4140": {"so_15273964_15276769_1": {"section_id": 1566, "quality": 0.6086956521739131, "length": 14}, "so_15273964_15276769_2": {"section_id": 1567, "quality": 0.9696969696969697, "length": 32}, "so_15273964_15276769_0": {"section_id": 1526, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_15273964_15276769_1": {"section_id": 1561, "quality": 0.6086956521739131, "length": 14}, "so_15273964_15276769_2": {"section_id": 1562, "quality": 0.9696969696969697, "length": 32}, "so_15273964_15276769_0": {"section_id": 1520, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_15273964_15276769_2": {"section_id": 1716, "quality": 0.9696969696969697, "length": 32}, "so_15273964_15276769_0": {"section_id": 1676, "quality": 0.6666666666666666, "length": 8}}}, "15276769": {"ParentId": "15273964", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-03-07T16:41:19.183", "Score": "1", "LastEditorUserId": "1741542", "LastEditDate": "2013-03-08T12:16:55.427", "Id": "15276769", "OwnerUserId": "1741542", "Body": "<p>From \"Working Draft C++, 2012-11-02\" </p>\n<blockquote>\n<p id=\"so_15273964_15276769_0\"><strong>21.1 General [strings.general]</strong><br>\n  1 This Clause describes components for manipulating sequences of any non-array POD (3.9) type.</br></p>\n<p id=\"so_15273964_15276769_1\"><strong>21.4.1 basic_string general requirements [string.require]</strong><br>\n  5 The char-like objects in a basic_string object shall be stored contiguously. That is, for any basic_string\n  object s, the identity &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n such that 0\n  &lt;= n &lt; s.size().</br></p>\n</blockquote>\n<p>but </p>\n<blockquote>\n<p id=\"so_15273964_15276769_2\">6 References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:<br>\n  \u2014 as an argument to any standard library function taking a reference to non-const basic_string as an argument.233<br>\n  \u2014 Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and rend.</br></br></p>\n</blockquote>\n<p>So, you should be safe as long as you pay attention, not to call these functions, while you use the raw array somewhere else.</p>\n<p><strong>Update</strong>:</p>\n<p>Character traits and requirements are described in <strong>21.2 Character traits [char.traits]</strong> and <strong>21.2.1 Character traits requirements [char.traits.require]</strong>. Additionally, typedefs and specializations are described in <strong>21.2.2 traits typedefs [char.traits.typedefs]</strong> and <strong>21.2.3 char_traits specializations [char.traits.specializations]</strong> respectively.</p>\n<p>These traits are used in the Input/output library as well. So there are requirements, like <code>eof()</code> or <code>pos_type</code> and <code>off_type</code>, which don't make sense in the context of <code>basic_string</code>.</p>\n<p>I don't see any requirement for these traits to be actually defined by an implementatin, besides the four specializations for <code>char</code>, <code>char16_t</code>, <code>char32_t</code> and <code>wchar_t</code>.</p>\n<p>Although, it worked out of the box with gcc 4.7 with your example, I defined a minimal <code>bool_traits</code> with just </p>\n<pre><code>struct bool_traits {\n    typedef bool char_type;\n    static void assign(char_type &amp;r, char_type d);\n    static char_type *copy(char_type *s, const char_type *p, std::size_t n);\n    static char_type *move(char_type *s, const char_type *p, std::size_t n);\n};\n</code></pre>\n<p>took the default implementation provided (gcc 4.7), and used that like </p>\n<pre><code>std::basic_string&lt;bool, bool_traits&gt; ab;\n</code></pre>\n<p>Your environment might already provide a working implementation. If not, you can implement a simple <code>bool_traits</code> or a template specialization <code>std::char_traits&lt;bool&gt;</code> yourself.</p>\n<p>You can see the complete interface for character traits in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/\" rel=\"nofollow\">Working Draft, PDF</a> or at <a href=\"http://en.cppreference.com/w/cpp/string/char_traits\" rel=\"nofollow\">cppreference.com - std::char_traits</a>.</p>\n", "LastActivityDate": "2013-03-08T12:16:55.427"}});