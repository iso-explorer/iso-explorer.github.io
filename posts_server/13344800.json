post_cb({"13345578": {"Id": "13345578", "PostTypeId": "2", "Body": "<p>Yes, from the C++11 draft, 12.8:</p>\n<blockquote>\n<p id=\"so_13344800_13345578_0\">If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared\n  as defaulted if and only if</p>\n<ul>\n<li>X does not have a user-declared copy constructor,</li>\n<li>X does not have a user-declared copy assignment operator,</li>\n<li>X does not have a user-declared move assignment operator,</li>\n<li>X does not have a user-declared destructor, and</li>\n<li>the move constructor would not be implicitly defined as deleted.</li>\n</ul>\n</blockquote>\n<p>The latter condition is specified with more detail later:</p>\n<blockquote>\n<p id=\"so_13344800_13345578_1\">An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy/move constructor for a class X is defined as deleted (8.4.3) if X has:</p>\n<ul>\n<li>a variant member with a non-trivial corresponding constructor and X is a union-like class,</li>\n<li>a non-static data member of class type M (or array thereof) that cannot be copied/moved because\n  overload resolution (13.3), as applied to M\u2019s corresponding constructor, results in an ambiguity or a\n  function that is deleted or inaccessible from the defaulted constructor,</li>\n<li>a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as\n  applied to B\u2019s corresponding constructor, results in an ambiguity or a function that is deleted or\n  inaccessible from the defaulted constructor,</li>\n<li>any direct or virtual base class or non-static data member of a type with a destructor that is deleted\n  or inaccessible from the defaulted constructor,</li>\n<li>for the copy constructor, a non-static data member of rvalue reference type, or</li>\n<li>for the move constructor, a non-static data member or direct or virtual base class with a type that does not have a move constructor and is not trivially copyable.</li>\n</ul>\n</blockquote>\n<p>Plainly speaking, the move constructor will be implicitly declared if:</p>\n<ol>\n<li>The class does not have user-declared any of the other special member functions.</li>\n<li>The move constructor can be sensibly implemented by moving all its members and bases.</li>\n</ol>\n<p>Your class obviously complies with these conditions.</p>\n", "LastEditorUserId": "865874", "LastActivityDate": "2012-11-12T14:44:40.497", "Score": "7", "CreationDate": "2012-11-12T14:34:15.733", "ParentId": "13344800", "CommentCount": "9", "OwnerUserId": "865874", "LastEditDate": "2012-11-12T14:44:40.497"}, "bq_ids": {"n4140": {"so_13344800_13345578_0": {"length": 12, "quality": 1.0, "section_id": 458}, "so_13344800_13345578_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 460}}, "n3337": {"so_13344800_13345578_0": {"length": 12, "quality": 1.0, "section_id": 449}, "so_13344800_13345578_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 451}}, "n4659": {"so_13344800_13345578_0": {"length": 12, "quality": 1.0, "section_id": 481}, "so_13344800_13345578_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 483}}}, "13345073": {"Id": "13345073", "PostTypeId": "2", "Body": "<p>The compiler synthesizes a move constructor if it can and if there is no user-defined copy constructor. The restriction that no move constructor is synthesized if there is copy constructor is intended to avoid breaking existing code. Of course, all members need to be movable. The exact rules are a bit more involved.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-11-12T14:27:30.053", "Score": "5", "CreationDate": "2012-11-12T14:01:20.103", "ParentId": "13344800", "CommentCount": "7", "OwnerUserId": "1120273", "LastEditDate": "2012-11-12T14:27:30.053"}, "13344800": {"ViewCount": "1032", "Body": "<p>Consider the following class:</p>\n<pre><code>class A\n{\npublic:\n   std::string field_a;\n   std::string field_b;\n}\n</code></pre>\n<p>Now consider the following copy construction:</p>\n<pre><code>A a1(a2);\n</code></pre>\n<p>The copy construction will adequately copy <code>A</code> despite the lack of of an explicit copy constructor because the copy constructors for <code>std::string</code> will be called by the compiler generated implicit copy constructor.</p>\n<p>What I wish to know is, is the same true for move construction?</p>\n<p><strong>EDIT</strong>: Testing <a href=\"http://ideone.com/1tBOpe\" rel=\"noreferrer\">here</a> shows that:</p>\n<pre><code>A a2(std::move(a1));\n</code></pre>\n<p>Will actually result in a copy construction, unless the specific move constructor:</p>\n<pre><code>A( A &amp;&amp; other ) : a(std::move(other.a)) {}\n</code></pre>\n<p>Is defined.</p>\n<p><strong>EDIT EDIT</strong>\nI pinged Stephan T Lavavej and asked him why VC 2012 doesn't seem to follow what draft 12.8 states regarding implicit move constructor generation.  He was kind enough to explain:</p>\n<blockquote>\n<p id=\"so_13344800_13344800_0\">It's more of a \"feature not yet implemented\" than a bug.  VC currently\n  implements what I refer to as rvalue references v2.0, where move\n  ctors/assigns are never implicitly generated and never affect the\n  implicit generation of copy ctors/assigns.  C++11 specifies rvalue\n  references v3.0, which are the rules you're looking at.</p>\n</blockquote>\n", "AcceptedAnswerId": "13345578", "Title": "Can a move constructor be implicit?", "CreationDate": "2012-11-12T13:42:42.423", "Id": "13344800", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-11-21T20:29:27.317", "LastEditorUserId": "636019", "LastActivityDate": "2012-11-21T20:29:27.317", "Score": "11", "OwnerUserId": "193128", "Tags": "<c++><visual-c++><c++11><visual-studio-2012><move-semantics>", "AnswerCount": "2"}});