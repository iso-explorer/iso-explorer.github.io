post_cb({"47314293": {"ParentId": "47312983", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Your example code is ill-formed, because of ISO section 17.7.3 (<a href=\"http://eel.is/c++draft/temp.res#3\" rel=\"nofollow noreferrer\">http://eel.is/c++draft/temp.res#3</a>): <code>T</code> is not a <code>nested name-specifier</code>.</p>\n<p>Hence, there's no way <code>T</code> can be anything else but the <code>typename T</code> used as the template parameter. I.e. the compiler can't be mistaken, so you don't need to qualify it with the <code>typename-specifier</code>.</p>\n<p>An example of a dependent type where the <code>typename-specifier</code> is required would be <code>T::value_type</code>, because the actual type/value of <code>value_type</code> <em>depends</em> on what <code>T</code> is. In that case you have to help the compiler out:</p>\n<pre><code>template &lt;typename T&gt; class U {\n  using t = T;                      // OK\n  using u = T::value_type;          // ill-formed: needs typename-specifier\n  using v = typename t::value_type; // OK: qualified with typename keyword\n};\n</code></pre>\n<p>Let's say you have the following:</p>\n<pre><code>class foo {\n  constexpr static int value_type = 7;\n}\n\nclass bar {\n  using value_type = int;\n}\n</code></pre>\n<p>This is the reason the 2nd typedef line above is ill-formed: if <code>T</code> is <code>foo</code> then <code>value_type</code> is not actually a type, but a constant with a very confusing name. If <code>T</code> is <code>bar</code> then all is well. But the compiler can't know this, so you have to help him out and assure him <code>value_type</code> is in fact a type. That also means you will be greeted with a compile error if you ever try to compile <code>U&lt;foo&gt;</code>.</p>\n<p>Note: I used C++11 syntax for the typedefs, because I find it much more readable. The explanation above still holds if you use <code>typedef</code> instead of <code>using</code>.</p>\n", "OwnerUserId": "255803", "LastEditorUserId": "255803", "LastEditDate": "2017-11-17T17:39:43.663", "Id": "47314293", "Score": "1", "CreationDate": "2017-11-15T17:58:38.930", "LastActivityDate": "2017-11-17T17:39:43.663"}, "47312983": {"CommentCount": "5", "ViewCount": "56", "PostTypeId": "1", "LastEditorUserId": "8212126", "CreationDate": "2017-11-15T16:48:48.227", "LastActivityDate": "2017-11-17T17:39:43.663", "Title": "Simple type specifier is template parameter", "LastEditDate": "2017-11-17T16:53:24.547", "Id": "47312983", "Score": "1", "Body": "<p>According to ISO 14882:2011 \u00a7 14.6.2.1:</p>\n<blockquote>\n<p id=\"so_47312983_47312983_0\">A type is dependent if it is \u2014 a template parameter,</p>\n</blockquote>\n<p>And according to \u00a7 ISO 14882:2011 14.6:</p>\n<blockquote>\n<p id=\"so_47312983_47312983_1\">A name used in a template declaration or definition and that is\n  dependent on a template-parameter is assumed not to name a type unless\n  the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename.</p>\n</blockquote>\n<p>But </p>\n<pre><code>template &lt;typename T&gt; class U\n{\n    typename T t; // ill-formed, i have an compilier error\n};\n</code></pre>\n<p>Are \"dependent name\" and \"name used in a template declaration or definition and that is dependent on a template-parameter\" the same concept?\nI try to resolve my missunderstanding, since it looks as collision between  assertions in standard(ISO 14882:2011 \u00a7 14.6.2.1) and example from standard T t;.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "8212126", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47312983_47312983_0": {"section_id": 198, "quality": 1.0, "length": 4}, "so_47312983_47312983_1": {"section_id": 169, "quality": 1.0, "length": 19}}, "n3337": {"so_47312983_47312983_0": {"section_id": 192, "quality": 1.0, "length": 4}, "so_47312983_47312983_1": {"section_id": 163, "quality": 1.0, "length": 19}}, "n4659": {"so_47312983_47312983_0": {"section_id": 146, "quality": 1.0, "length": 4}, "so_47312983_47312983_1": {"section_id": 174, "quality": 1.0, "length": 19}}}});