post_cb({"27162225": {"CommentCount": "1", "ViewCount": "72", "ClosedDate": "2014-11-27T03:06:54.983", "CreationDate": "2014-11-27T02:40:02.163", "LastActivityDate": "2014-11-27T03:10:11.153", "Title": "What does a reference-to-reference mean in C++? (Not an rvalue reference)", "PostTypeId": "1", "Id": "27162225", "Score": "2", "Body": "<p>suppose I have</p>\n<pre><code>typedef int&amp; intr;\ntypedef intr&amp; intrr;\n</code></pre>\n<p>I am allowed to declare</p>\n<pre><code>int x = 7;\nintrr y = x;\n</code></pre>\n<p>But what <em>is</em> a reference-to-reference? Is an intrr any different semantically than just an intr?</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "948176", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27162225_27162410_1": {"section_id": 3223, "quality": 0.7857142857142857, "length": 22}}, "n3337": {"so_27162225_27162410_1": {"section_id": 3097, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_27162225_27162410_1": {"section_id": 3980, "quality": 0.7857142857142857, "length": 22}}}, "27162410": {"ParentId": "27162225", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There's no such thing as a reference to reference. The C++ standard explicitly says so:</p>\n<p>\u00a78.3.3/5 </p>\n<blockquote>\n<p id=\"so_27162225_27162410_0\">There shall be no references to references, ...</p>\n</blockquote>\n<p>In typedefs and templates, there is a rule commonly referred to as \"reference collapsing\". It's described in paragraph 6 of the same section:</p>\n<blockquote>\n<p id=\"so_27162225_27162410_1\">If a typedef (7.1.3), a type <em>template-parameter</em> (14.3.1), or a\n  <em>decltype-specifier</em> (7.1.6.2) denotes a type <code>TR</code> that is a reference to a type <code>T</code>, an attempt to create the type \u201clvalue reference to <em>cv</em>\n<code>TR</code>\u201d creates the type \u201clvalue reference to <code>T</code>\u201d, while an attempt to\n  create the type \u201crvalue reference to <em>cv</em> <code>TR</code>\u201d creates the type <code>TR</code>.</p>\n<p id=\"so_27162225_27162410_2\">[ <em>Example:</em></p>\n<pre><code>int i;\ntypedef int&amp; LRI;\ntypedef int&amp;&amp; RRI;\n\nLRI&amp; r1 = i;           // r1 has the type int&amp;\nconst LRI&amp; r2 = i;     // r2 has the type int&amp;\nconst LRI&amp;&amp; r3 = i;    // r3 has the type int&amp;\n\nRRI&amp; r4 = i;           // r4 has the type int&amp;\nRRI&amp;&amp; r5 = 5;          // r5 has the type int&amp;&amp;\n\ndecltype(r2)&amp; r6 = i;  // r6 has the type int&amp;\ndecltype(r2)&amp;&amp; r7 = i; // r7 has the type int&amp;\n</code></pre>\n<p id=\"so_27162225_27162410_3\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p><code>intr</code> and <code>intrr</code> in your sample are exactly the same type, which is <code>int&amp;</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nint main()\n{\n    typedef int&amp; intr;\n    typedef intr&amp; intrr;\n    int x = 7;\n    intrr y = x;\n    std::cout &lt;&lt; std::is_same&lt;intr, intrr&gt;::value;\n    std::cout &lt;&lt; std::is_same&lt;int&amp;, intrr&gt;::value;\n    std::cout &lt;&lt; std::is_same&lt;int&amp;, intr&gt;::value;\n}\n</code></pre>\n<p>Output: <code>111</code></p>\n<p>Thomas Becker's article on <a href=\"http://thbecker.net/articles/rvalue_references/section_08.html\" rel=\"nofollow\"><em>Rvalue References explained</em></a> provides a nice table:</p>\n<blockquote id=\"so_27162225_27162410_4\">\n<ol>\n<li>A&amp; &amp; becomes A&amp;</li>\n<li>A&amp; &amp;&amp; becomes A&amp;</li>\n<li>A&amp;&amp; &amp; becomes A&amp;</li>\n<li>A&amp;&amp; &amp;&amp; becomes A&amp;&amp;</li>\n</ol>\n</blockquote>\n", "Id": "27162410", "LastEditDate": "2014-11-27T03:10:11.153", "OwnerDisplayName": "user3920237", "Score": "1", "CreationDate": "2014-11-27T03:04:37.863", "LastActivityDate": "2014-11-27T03:10:11.153", "LastEditorDisplayName": "user3920237"}});