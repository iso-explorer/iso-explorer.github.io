post_cb({"24913605": {"ParentId": "24913269", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-07-23T14:43:59.257", "Score": "0", "LastEditorUserId": "2756719", "LastEditDate": "2014-07-23T15:00:44.590", "Id": "24913605", "OwnerUserId": "2756719", "Body": "<p>This is specified in an interesting way, and it looks like MSVC implemented the standard to the letter here. The assignment itself is specified in \u00a720.8.2.2.3 [util.smartptr.shared.assign]/p1-3:</p>\n<blockquote>\n<pre><code>shared_ptr&amp; operator=(const shared_ptr&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr&amp; operator=(const shared_ptr&lt;Y&gt;&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr&amp; operator=(auto_ptr&lt;Y&gt;&amp;&amp; r);\n</code></pre>\n<p id=\"so_24913269_24913605_0\"><em>Effects</em>: Equivalent to <code>shared_ptr(r).swap(*this)</code>.</p>\n<p id=\"so_24913269_24913605_1\"><em>Returns</em>: <code>*this</code>.</p>\n<p id=\"so_24913269_24913605_2\">[ <em>Note</em>: The use count updates caused by the temporary object construction and destruction are not\n  observable side effects, so the implementation may meet the effects (and the implied guarantees) via\n  different means, without creating a temporary. <code>&lt;example omitted&gt;</code>]</p>\n</blockquote>\n<p>The relevant constructor is specified in \u00a720.8.2.2.1 [util.smartptr.shared.const]/p17-19:</p>\n<blockquote>\n<pre><code>shared_ptr(const shared_ptr&amp; r) noexcept;\ntemplate&lt;class Y&gt; shared_ptr(const shared_ptr&lt;Y&gt;&amp; r) noexcept;\n</code></pre>\n<p id=\"so_24913269_24913605_3\"><em>Requires</em>: The second constructor shall not participate in the overload resolution unless <code>Y*</code> is implicitly convertible to <code>T*</code>.</p>\n<p id=\"so_24913269_24913605_4\"><em>Effects</em>: If <code>r</code> is empty, constructs an empty <code>shared_ptr</code> object; otherwise, constructs a <code>shared_ptr</code> object that shares ownership with\n  <code>r</code>.</p>\n<p id=\"so_24913269_24913605_5\"><em>Postconditions</em>: <code>get() == r.get() &amp;&amp; use_count() == r.use_count()</code>.</p>\n</blockquote>\n<p>Since <code>const TestClass *</code> is not implicitly convertible to <code>TestClass *</code>, the templated constructor does not participate in overload resolution, rendering <code>shared_ptr(r)</code> ill-formed as there is no matching constructor.</p>\n<hr>\n<p><strong>Edit</strong>: I see the confusion. VS2012 is rather poorly designed in reporting compiler error messages. The full error message emitted by the compiler is:</p>\n<pre><code>error C2440: '&lt;function-style-cast&gt;' : cannot convert from 'const std::shared_ptr&lt;_Ty&gt;' to 'std::shared_ptr&lt;_Ty&gt;'\n      with\n      [\n          _Ty=const TestClass\n      ]\n      and\n      [\n          _Ty=TestClass\n      ]\n</code></pre>\n<p>Importantly, the two <code>_Ty</code>s in the error output are referring to <em>different</em> types. The Error List window in VS2012, however, truncates this to the first line only, and loses that essential information. You should look at the build output for the full error message.</p>\n</hr>", "LastActivityDate": "2014-07-23T15:00:44.590"}, "24913269": {"CommentCount": "1", "ViewCount": "351", "CreationDate": "2014-07-23T14:29:35.410", "LastActivityDate": "2014-07-23T15:00:44.590", "Title": "why cast a smart pointer of const type to smart pointer of type works", "PostTypeId": "1", "Id": "24913269", "Score": "0", "Body": "<p>Any idea why a1 =a2 does not work but a2=a1 works. There must be a function in the smart pointer template that does the conversion? which one is it?</p>\n<pre><code>#include \"stdafx.h\"\n#include&lt;memory&gt;\nclass TestClass\n{\npublic:\n    int a ; \n\n};\ntypedef std::shared_ptr&lt;TestClass&gt; TestSP;\ntypedef std::shared_ptr&lt;const TestClass&gt; TestConstSP;\nint _tmain(int argc, _TCHAR* argv[])\n{\n    TestSP a1 = TestSP();\n    TestConstSP a2 = TestConstSP();\n    //a1 =a2; //error C2440: '&lt;function-style-cast&gt;' : cannot convert from 'const std::shared_ptr&lt;_Ty&gt;' to 'std::shared_ptr&lt;_Ty&gt;'       \n    a2=a1;\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><type-conversion><smart-pointers>", "OwnerUserId": "1394786", "AnswerCount": "2"}, "24913470": {"ParentId": "24913269", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-07-23T14:37:16.613", "Score": "0", "LastEditorUserId": "840960", "LastEditDate": "2014-07-23T14:43:26.143", "Id": "24913470", "OwnerUserId": "840960", "Body": "<p>This is due to the usage of <code>const</code>. Should you have a <code>const</code> pointer '<code>const_ptr</code>' and a non <code>const</code> pointer '<code>non_const_ptr</code>', it is OK to do:</p>\n<pre><code>const_ptr = non_const_ptr; // const_ptr doesn't allow modifying the pointed value, while non_const_ptr does.\n</code></pre>\n<p>But it is forbidden to do:</p>\n<pre><code>non_const_ptr = const_ptr; // const_ptr is `const`. Allowing non_const_ptr to modify the pointed value would'n respect the `const` contract.\n</code></pre>\n<p>And the following would work:</p>\n<pre><code>non_const_ptr = (type *) const_ptr; // You have the right to do that as you explicitely break the contract. \n                                    // The programmer is the boss. This is a bit ugly though.\n</code></pre>\n<p>The exact same logic applies to your example.</p>\n", "LastActivityDate": "2014-07-23T14:43:26.143"}, "bq_ids": {"n4140": {"so_24913269_24913605_2": {"section_id": 4416, "quality": 0.8846153846153846, "length": 23}, "so_24913269_24913605_3": {"section_id": 4394, "quality": 0.7777777777777778, "length": 7}, "so_24913269_24913605_5": {"section_id": 4396, "quality": 0.8, "length": 4}, "so_24913269_24913605_4": {"section_id": 4395, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_24913269_24913605_2": {"section_id": 4253, "quality": 0.8846153846153846, "length": 23}, "so_24913269_24913605_3": {"section_id": 4231, "quality": 0.7777777777777778, "length": 7}, "so_24913269_24913605_5": {"section_id": 4233, "quality": 0.8, "length": 4}, "so_24913269_24913605_4": {"section_id": 4232, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_24913269_24913605_3": {"section_id": 4289, "quality": 0.6666666666666666, "length": 6}, "so_24913269_24913605_2": {"section_id": 5675, "quality": 0.8846153846153846, "length": 23}, "so_24913269_24913605_5": {"section_id": 5661, "quality": 0.8, "length": 4}, "so_24913269_24913605_4": {"section_id": 5660, "quality": 0.9166666666666666, "length": 11}}}});