post_cb({"44652353": {"CommentCount": "1", "ViewCount": "108", "PostTypeId": "1", "LastEditorUserId": "4342498", "CreationDate": "2017-06-20T11:54:30.297", "LastActivityDate": "2017-06-20T12:14:00.000", "Title": "Call unlock on std::shared_mutex that is locked in shared mode", "AcceptedAnswerId": "44652576", "LastEditDate": "2017-06-20T12:14:00.000", "Id": "44652353", "Score": "3", "Body": "<p>C++17 introduces the <a href=\"http://en.cppreference.com/w/cpp/thread/shared_mutex\" rel=\"nofollow noreferrer\"><code>std::shared_mutex</code></a> type. I have been looking at the documentation over on <a href=\"http://en.cppreference.com/w/\" rel=\"nofollow noreferrer\">CppReference</a> with a particular interest for cases that produce undefined behavior.</p>\n<p>While reading through both unlock methods (one for releasing exclusive ownership, one for releasing shared ownership), I've noticed the documentation is a little vague on one occasion.</p>\n<p>For <a href=\"http://en.cppreference.com/w/cpp/thread/shared_mutex/unlock_shared\" rel=\"nofollow noreferrer\"><code>std::shared_mutex::unlock_shared</code></a>, the documentation states (emphasis mine):</p>\n<blockquote>\n<p id=\"so_44652353_44652353_0\">The mutex must be locked by the current thread of execution in <strong>shared mode</strong>, otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>It is clearly indicated that a call to <code>unlock_shared</code> must be preceded by a call to <code>lock_shared</code> as that is the only way to lock the mutex in shared mode.</p>\n<p>For <a href=\"http://en.cppreference.com/w/cpp/thread/shared_mutex/unlock\" rel=\"nofollow noreferrer\"><code>std::shared_mutex::unlock</code></a>, the documentation states:</p>\n<blockquote>\n<p id=\"so_44652353_44652353_1\">The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>There is no mention of the level of access the current thread of execution must hold before calling <code>unlock</code>. This made me wonder if it is also capable of releasing shared ownership as well as exclusive ownership. </p>\n<p><strong>My question:</strong> is it undefined behavior to release shared ownership of a <code>std::shared_mutex</code> with a call to <code>unlock</code> instead of <code>unlock_shared</code>?</p>\n<p>If possible, I'd like a quote from the C++ standard that explicitly confirms or denies undefined behavior in the aforementioned scenario.</p>\n", "Tags": "<c++><multithreading><language-lawyer><mutex>", "OwnerUserId": "4841248", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44652353_44652576_2": {"section_id": 2770, "quality": 0.8333333333333334, "length": 5}, "so_44652353_44652576_0": {"section_id": 2768, "quality": 0.8571428571428571, "length": 6}, "so_44652353_44652576_4": {"section_id": 2772, "quality": 0.8181818181818182, "length": 9}, "so_44652353_44652576_1": {"section_id": 2754, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_44652353_44652576_2": {"section_id": 2731, "quality": 0.8333333333333334, "length": 5}, "so_44652353_44652576_0": {"section_id": 2729, "quality": 0.8571428571428571, "length": 6}, "so_44652353_44652576_4": {"section_id": 2733, "quality": 0.7272727272727273, "length": 8}, "so_44652353_44652576_1": {"section_id": 2715, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_44652353_44652576_2": {"section_id": 3508, "quality": 0.8333333333333334, "length": 5}, "so_44652353_44652576_0": {"section_id": 3506, "quality": 0.8571428571428571, "length": 6}, "so_44652353_44652576_4": {"section_id": 3510, "quality": 0.8181818181818182, "length": 9}, "so_44652353_44652576_1": {"section_id": 3492, "quality": 0.6666666666666666, "length": 4}}}, "44652576": {"ParentId": "44652353", "CommentCount": "7", "Body": "<p>Per <a href=\"http://eel.is/c++draft/thread.mutex.requirements.mutex\" rel=\"nofollow noreferrer\">[thread.mutex.requirements.mutex]</a> we have</p>\n<blockquote>\n<p id=\"so_44652353_44652576_0\">The expression <code>m.unlock()</code> shall be well-formed and have the following semantics:</p>\n<p id=\"so_44652353_44652576_1\"><em>Requires</em>: The calling thread shall own the mutex.</p>\n<p id=\"so_44652353_44652576_2\"><em>Effects</em>: Releases the calling thread's ownership of the mutex.</p>\n<p id=\"so_44652353_44652576_3\"><em>Return</em> type: void.</p>\n<p id=\"so_44652353_44652576_4\"><em>Synchronization</em>: This operation synchronizes with subsequent lock operations that obtain ownership on the same object.</p>\n<p id=\"so_44652353_44652576_5\"><em>Throws</em>: Nothing.</p>\n</blockquote>\n<p>So, as long as the thread owns the mutex ,whether it is in shared mode or not, <code>unlock</code> will release the threads ownership of the mutex.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "44652576", "Score": "2", "CreationDate": "2017-06-20T12:05:20.653", "LastActivityDate": "2017-06-20T12:05:20.653"}});