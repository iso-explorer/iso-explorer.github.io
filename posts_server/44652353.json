post_cb({"bq_ids": {"n4140": {"so_44652353_44652576_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2770}, "so_44652353_44652576_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 2772}, "so_44652353_44652576_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 2754}, "so_44652353_44652576_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2768}}, "n3337": {"so_44652353_44652576_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 2731}, "so_44652353_44652576_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 2733}, "so_44652353_44652576_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 2715}, "so_44652353_44652576_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2729}}, "n4659": {"so_44652353_44652576_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 3508}, "so_44652353_44652576_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 3510}, "so_44652353_44652576_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3492}, "so_44652353_44652576_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3506}}}, "44652353": {"ViewCount": "108", "Body": "<p>C++17 introduces the <a href=\"http://en.cppreference.com/w/cpp/thread/shared_mutex\" rel=\"nofollow noreferrer\"><code>std::shared_mutex</code></a> type. I have been looking at the documentation over on <a href=\"http://en.cppreference.com/w/\" rel=\"nofollow noreferrer\">CppReference</a> with a particular interest for cases that produce undefined behavior.</p>\n<p>While reading through both unlock methods (one for releasing exclusive ownership, one for releasing shared ownership), I've noticed the documentation is a little vague on one occasion.</p>\n<p>For <a href=\"http://en.cppreference.com/w/cpp/thread/shared_mutex/unlock_shared\" rel=\"nofollow noreferrer\"><code>std::shared_mutex::unlock_shared</code></a>, the documentation states (emphasis mine):</p>\n<blockquote>\n<p id=\"so_44652353_44652353_0\">The mutex must be locked by the current thread of execution in <strong>shared mode</strong>, otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>It is clearly indicated that a call to <code>unlock_shared</code> must be preceded by a call to <code>lock_shared</code> as that is the only way to lock the mutex in shared mode.</p>\n<p>For <a href=\"http://en.cppreference.com/w/cpp/thread/shared_mutex/unlock\" rel=\"nofollow noreferrer\"><code>std::shared_mutex::unlock</code></a>, the documentation states:</p>\n<blockquote>\n<p id=\"so_44652353_44652353_1\">The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>There is no mention of the level of access the current thread of execution must hold before calling <code>unlock</code>. This made me wonder if it is also capable of releasing shared ownership as well as exclusive ownership. </p>\n<p><strong>My question:</strong> is it undefined behavior to release shared ownership of a <code>std::shared_mutex</code> with a call to <code>unlock</code> instead of <code>unlock_shared</code>?</p>\n<p>If possible, I'd like a quote from the C++ standard that explicitly confirms or denies undefined behavior in the aforementioned scenario.</p>\n", "AcceptedAnswerId": "44652576", "Title": "Call unlock on std::shared_mutex that is locked in shared mode", "CreationDate": "2017-06-20T11:54:30.297", "Id": "44652353", "CommentCount": "1", "LastEditDate": "2017-06-20T12:14:00.000", "PostTypeId": "1", "LastEditorUserId": "4342498", "LastActivityDate": "2017-06-20T12:14:00.000", "Score": "3", "OwnerUserId": "4841248", "Tags": "<c++><multithreading><language-lawyer><mutex>", "AnswerCount": "1"}, "44652576": {"Id": "44652576", "PostTypeId": "2", "Body": "<p>Per <a href=\"http://eel.is/c++draft/thread.mutex.requirements.mutex\" rel=\"nofollow noreferrer\">[thread.mutex.requirements.mutex]</a> we have</p>\n<blockquote>\n<p id=\"so_44652353_44652576_0\">The expression <code>m.unlock()</code> shall be well-formed and have the following semantics:</p>\n<p id=\"so_44652353_44652576_1\"><em>Requires</em>: The calling thread shall own the mutex.</p>\n<p id=\"so_44652353_44652576_2\"><em>Effects</em>: Releases the calling thread's ownership of the mutex.</p>\n<p id=\"so_44652353_44652576_3\"><em>Return</em> type: void.</p>\n<p id=\"so_44652353_44652576_4\"><em>Synchronization</em>: This operation synchronizes with subsequent lock operations that obtain ownership on the same object.</p>\n<p id=\"so_44652353_44652576_5\"><em>Throws</em>: Nothing.</p>\n</blockquote>\n<p>So, as long as the thread owns the mutex ,whether it is in shared mode or not, <code>unlock</code> will release the threads ownership of the mutex.</p>\n", "LastActivityDate": "2017-06-20T12:05:20.653", "CommentCount": "7", "CreationDate": "2017-06-20T12:05:20.653", "ParentId": "44652353", "Score": "2", "OwnerUserId": "4342498"}});