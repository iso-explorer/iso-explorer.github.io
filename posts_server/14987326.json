post_cb({"14987706": {"ParentId": "14987326", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2013-02-20T18:52:09.120", "Score": "5", "LastEditorUserId": "1076143", "LastEditDate": "2013-02-20T19:23:48.217", "Id": "14987706", "OwnerUserId": "1076143", "Body": "<p>Let's break this down into two different problems:</p>\n<p><strong>1. Why does this generate a compiler error?</strong> </p>\n<pre><code>struct C\n{\n    operator bool () {return false;}\n    operator int () {return 1;}\n};\n</code></pre>\n<p>As both <code>int</code> and <code>bool</code> can be implicitly converted to <code>double</code>, the compiler can not know which function it should use. There are two functions which it could use and neither one takes precedence over the other one.</p>\n<p><strong>2. Why isn't the templated version a perfect match?</strong> </p>\n<pre><code>struct C\n{\n    template &lt;typename T&gt; operator T () {return 0.5;}\n    operator int () {return 1;}\n};\n</code></pre>\n<p>Why is <code>operator int()</code> called when requesting a double? </p>\n<blockquote>\n<p id=\"so_14987326_14987706_0\">The non-template function is called because a non-template function takes precedence in overload resolution. (<a href=\"http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=/com.ibm.xlcpp8l.doc/language/ref/overloading_function_templates.htm\" rel=\"nofollow\">Overloading function templates</a>)</p>\n</blockquote>\n<p><strong>EDIT:</strong>\nI was wrong! As Yan Zhou mentioned in his comment, and as it is stated in the link I provided, a perfect match in the templated function takes precedence over the non-templated function. </p>\n<p>I tested your code (compiled with g++ 4.7.2), and it worked as expected: it returned <code>0.5</code>, in other words, the templated function was used!</p>\n<p><strong>EDIT2:</strong>\nI now tried with clang and I can reproduce the behaviour you described. As it works correctly in gcc, this seems to be a bug in clang.</p>\n", "LastActivityDate": "2013-02-20T19:23:48.217"}, "14987326": {"CommentCount": "0", "AcceptedAnswerId": "14990231", "PostTypeId": "1", "LastEditorUserId": "794424", "CreationDate": "2013-02-20T18:30:51.197", "LastActivityDate": "2013-02-20T21:26:11.230", "LastEditDate": "2013-02-20T18:38:47.633", "ViewCount": "6350", "FavoriteCount": "2", "Title": "Overloading conversion operator template", "Id": "14987326", "Score": "12", "Body": "<p>Consider the following simple example</p>\n<pre><code>struct C\n{\n    template &lt;typename T&gt; operator T () {return 0.5;}\n    operator int () {return 1;}\n    operator bool () {return false;}\n};\n\nint main ()\n{\n    C c;\n    double x = c;\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n</code></pre>\n<p>When compiled with Clang, it gives the following error</p>\n<pre><code>test.cpp:11:12: error: conversion from 'C' to 'double' is ambiguous\n    double x = c;\n           ^   ~\ntest.cpp:4:5: note: candidate function\n    operator int () {return 1;}\n    ^\ntest.cpp:5:5: note: candidate function\n    operator bool () {return false;}\n    ^\ntest.cpp:3:27: note: candidate function [with T = double]\n    template &lt;typename T&gt; operator T () {return 0.5;}\n                          ^\n1 error generated.\n</code></pre>\n<p>Other compilers generate similar errors, e.g., GCC and Intel iclc</p>\n<p>If I remove <code>operator int</code> and <code>operator bool</code>. It compiles fine and work as expected. If only remove one of them, that is keep the template operator and say <code>operator int</code>, then the non-template version is always chosen.</p>\n<p>My understanding is that only when the template and non-template overloaded functions are equal in the sense that they are both perfect match or both require the same conversion sequence, the non-template version will be preferred. However in this case, it appears that the compiler does not see the operator template as a perfect match. And when both the <code>bool</code> and <code>int</code> overloading are present, then naturally it considers they are ambiguous.</p>\n<p>In summary, my question is that why the operator template is not considered a perfect match in this case?</p>\n", "Tags": "<c++>", "OwnerUserId": "794424", "AnswerCount": "2"}, "14990231": {"ParentId": "14987326", "CommentCount": "1", "CreationDate": "2013-02-20T21:26:11.230", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "14990231", "Score": "4", "Body": "<p>This is interesting.  There are two ways to read a critical part of section 13.3.3.  The original example should definitely call the function template, but the version where one of the non-templates is removed might be argued to be ambiguous.</p>\n<p>13.3.3:</p>\n<blockquote>\n<p id=\"so_14987326_14990231_0\">A viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if for all arguments <em>i</em>, ICS_i(<code>F1</code>) is not a worse conversion sequence than ICS_i(<code>F2</code>), and then</p>\n<ul>\n<li><p id=\"so_14987326_14990231_1\">for some argument <em>j</em>, ICS_j(<code>F1</code>) is a better conversion sequence than ICS_j(<code>F2</code>), or, if not that,</p></li>\n<li><p id=\"so_14987326_14990231_2\">the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of <code>F2</code> to the destination type, or, if not that,</p></li>\n<li><p id=\"so_14987326_14990231_3\"><code>F1</code> is a non-template function and <code>F2</code> is a function template specialization, or, if not that,</p></li>\n<li><p id=\"so_14987326_14990231_4\"><code>F1</code> and <code>F2</code> are function template specializations, and the function template for <code>F1</code> is more specialized than the template for <code>F2</code> according to the partial ordering rules described in 14.5.6.2.</p></li>\n</ul>\n<p id=\"so_14987326_14990231_5\">If there is exactly one viable function that is a better function than all other viable functions, then it is the one selected by overload resolution; otherwise the call is ill-formed.</p>\n</blockquote>\n<p>In the example, clang correctly identifies the set of three viable candidate functions:</p>\n<pre><code>C::operator int()\nC::operator bool()\nC::operator double&lt;double&gt;()\n</code></pre>\n<p>The third is a function template specialization.  (I don't think the syntax above is legal, but you get the idea: at this point of overload resolution it's not treated as a template, but as a specialization with a definite function type.)</p>\n<p>The only Implicit Conversion Sequence on arguments here (ICS1) is the exact match \"lvalue <code>C</code>\" to \"<code>C&amp;</code>\" on the implicit parameter, so that won't make a difference.</p>\n<p>This example is exactly the situation described in the second bullet, so the function returning <code>double</code> is clearly better than the other two.</p>\n<p>Here's where it gets weird: By a very literal reading, <code>operator int</code> is also better than the template specialization, because of the third bullet.  \"Wait a minute, shouldn't 'better than' be antisymmetric? How can you say <code>F1</code> is better than <code>F2</code> AND <code>F2</code> is better than <code>F1</code>?\"  Unfortunately, the Standard doesn't explicitly say anything of the sort.  \"Doesn't the second bullet take priority over the third bullet because of the 'if not that' phrase?\"  Yes, for constant <code>F1</code> and <code>F2</code>.  But the Standard doesn't say that satisfying the second bullet for <code>(F1,F2)</code> makes the third bullet for <code>(F2,F1)</code> not applicable.</p>\n<p>Of course, since <code>operator int</code> is not better than <code>operator bool</code> and vice versa, there is still \"exactly one viable function that is a better function than all other viable functions\".</p>\n<p>I'm not exactly endorsing this weird reading, except maybe to report it as a Standard defect.  Going with that would have bizarre consequences (like <em>removing</em> an overload which was <em>not</em> the best from this example changes a program from well-formed to ambiguous!).  I think the intent is for the second bullet to be considered both ways before the third bullet is considered at all.</p>\n<p>Which would mean the function template should be selected by overload resolution, and this is a clang bug.</p>\n", "LastActivityDate": "2013-02-20T21:26:11.230"}, "bq_ids": {"n4140": {"so_14987326_14990231_0": {"section_id": 603, "quality": 0.8333333333333334, "length": 15}, "so_14987326_14990231_5": {"section_id": 604, "quality": 1.0, "length": 20}, "so_14987326_14990231_2": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_14987326_14990231_1": {"section_id": 603, "quality": 0.75, "length": 6}, "so_14987326_14990231_4": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_14987326_14990231_3": {"section_id": 111, "quality": 1.0, "length": 5}}, "n3337": {"so_14987326_14990231_0": {"section_id": 593, "quality": 0.8333333333333334, "length": 15}, "so_14987326_14990231_5": {"section_id": 594, "quality": 1.0, "length": 20}, "so_14987326_14990231_2": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_14987326_14990231_1": {"section_id": 593, "quality": 0.75, "length": 6}, "so_14987326_14990231_4": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_14987326_14990231_3": {"section_id": 106, "quality": 1.0, "length": 5}}, "n4659": {"so_14987326_14990231_0": {"section_id": 629, "quality": 0.8333333333333334, "length": 15}, "so_14987326_14990231_5": {"section_id": 630, "quality": 1.0, "length": 20}, "so_14987326_14990231_2": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_14987326_14990231_1": {"section_id": 629, "quality": 0.75, "length": 6}, "so_14987326_14990231_4": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_14987326_14990231_3": {"section_id": 115, "quality": 1.0, "length": 5}}}});