post_cb({"39540469": {"ParentId": "39539577", "CommentCount": "0", "CreationDate": "2016-09-16T21:41:48.163", "OwnerUserId": "1794803", "PostTypeId": "2", "Id": "39540469", "Score": "0", "Body": "<p>To complete the @Niall's answer, although the order of initialization is undefined, the order of destruction will be the inverse of the initialization order.</p>\n<p>The only way to be sure about anything, will be through the creation of a global function with your object as a static local variable (as shown in other answers).</p>\n<p>In that case, you will know for sure that the <code>static</code> object will be deleted \"before\" the static class member, because it was created \"after\" (the first time you call the global function):</p>\n<pre><code>class Object {\n    static std::vector&lt; Object * &gt; all_objects;\n\npublic\n    Object() {\n        all_objects.push_back( this );\n    }\n\n    ~Object() {\n        all_objects.erase(\n          std::remove(all_objects.begin(), all_objects.end(), this), \n          all_objects.end());\n    }\n};\n\nObject&amp; static_obj()\n{\n     static Object obj;\n     return obj;\n}\n\nstd::vector&lt; Object * &gt; Object::all_objects; // It is created first (before main)\n\nint main()\n{\n    Object&amp; o = static_obj(); // `obj` is initialized here.\n} // At the end of the program, `obj` will be destroid first.\n</code></pre>\n", "LastActivityDate": "2016-09-16T21:41:48.163"}, "39540275": {"ParentId": "39539577", "CommentCount": "0", "CreationDate": "2016-09-16T21:23:34.880", "OwnerUserId": "6827629", "PostTypeId": "2", "Id": "39540275", "Score": "1", "Body": "<p>Static variables really have global scope in that they are not on the stack for a function or method.  So the destructors are called at the last possible time.</p>\n<p>So in a single thread environment I can't see any problem with it. Here is a silly example but it does run.  After the return statement the destructor for the two statics is called.</p>\n<pre><code>ob.h\nclass ob\n{\n  static int a;\n  static int b;\npublic:\n  ob()\n  {\n    a++;\n  }\n  ~ob()\n  {\n    b--;\n  }\n};\n</code></pre>\n<p>main.cpp\n    #include ob.h;</p>\n<pre><code>int ob::a = 0;\nint ob::b = 0;\n\nvoid tt()\n{\n  static ob zz;\n}\n\nint main() \n{\n  static ob yy;\n  tt();\n\n  {\n    ob b;\n  }\n  ob a;\n\n  return 1;\n}\n</code></pre>\n<p>Regarding the static vars in another compilation unit, would depend on how you used it.  For example if everything is inlined and the header is used in A.dll and B.dll, there would be no reference between them and you would have to initialize the static in each unit giving them a unique address.  But if it was in a lib or dll where it was exported you would be using the same memory address. \nI've seen a problem with this before where we had two versions of the same class.  Object A was 1.0 and object B was 1.2.  They were not exported directly but were used in functions that were exported.  The wrong destructor was called for the objects.  That was a really poor coding choice and was changed.\nIn a multi-threaded build it could be very bad depending on how you are using the objects.  You can't know the order of destruction and you could try to access something after it was destroyed.</p>\n<p>Overall I would say not a good practice.  It will work but in a more complex situation, future changes could break things fast.</p>\n", "LastActivityDate": "2016-09-16T21:23:34.880"}, "39539577": {"CommentCount": "0", "AcceptedAnswerId": "39539765", "CreationDate": "2016-09-16T20:23:13.067", "LastActivityDate": "2016-09-17T17:13:09.010", "PostTypeId": "1", "ViewCount": "201", "FavoriteCount": "0", "Title": "In C++, can a static object outlive its static member variable?", "Id": "39539577", "Score": "4", "Body": "<p>Regarding the order of destruction of static variables in C++, are there any guarantees about the lifetime of static objects with respect to their static member variables?</p>\n<p>For example, if I had something like this (insanely simplified example for demonstration purposes only):</p>\n<pre><code>class Object {\n    static std::vector&lt; Object * &gt; all_objects;\n\npublic\n    Object() {\n        all_objects.push_back( this );\n    }\n\n    ~Object() {\n        all_objects.erase(\n          std::remove(all_objects.begin(), all_objects.end(), this), \n          all_objects.end());\n    }\n};\n</code></pre>\n<p>Would this be \"safe\" with respect to static Objects in different compilation units? That is, is there any guarantee that the <code>all_objects</code> member variable will stick around at least as long as any valid Object, or could there be an issue where <code>all_objects</code> is destroyed prior to the last Object instance?</p>\n<p>And does the answer change if the code is being used as a library (say within Python) rather than as a standalone program with its own main()?</p>\n", "Tags": "<c++><language-lawyer><destructor>", "OwnerUserId": "3022952", "AnswerCount": "4"}, "39539765": {"ParentId": "39539577", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-09-16T20:39:38.103", "Score": "1", "LastEditorUserId": "434551", "LastEditDate": "2016-09-17T17:13:09.010", "Id": "39539765", "OwnerUserId": "434551", "Body": "<blockquote>\n<p id=\"so_39539577_39539765_0\">Would this be \"safe\" with respect to static Objects in different compilation units?</p>\n</blockquote>\n<p>It is not safe at initialization time. There is no guarantee that <code>all_objects</code> will be initialized at the time a <code>static</code> object in a compilation unit is constructed.</p>\n<p>I am not clear on the order of termination. My guess is that destruction happens in the reverse order of construction. If construction/initialization is not safe, destruction is likely to be unsafe too.</p>\n<p>One way to make it safe at initialization time is wrap <code>all_objects</code> in a function.</p>\n<pre><code>class Object {\n    static std::vector&lt;Object *&gt;&amp; get_all_objects();\n\npublic\n    Object() {\n        get_all_objects().push_back( this );\n    }\n\n    ~Object() {\n       std::vector&lt;Object *&gt;&amp; all_objects = get_all_objects();\n       all_objects.erase(\n          std::remove(all_objects.begin(), all_objects.end(), this), \n          all_objects.end());\n    }\n};\n\nstd::vector&lt;Object *&gt;&amp; Object::get_all_objects()\n{\n    static std::vector&lt;Object *&gt; all_objects;\n    return all_objects;\n}\n</code></pre>\n<p>This is what the C++11 Standard (3.6.3/1) has to say about destruction of objects with static storage duration.</p>\n<blockquote>\n<p id=\"so_39539577_39539765_1\">If the completion of the constructor or dynamic initialization of an object with static storage duration is sequenced before that of another, the completion of the destructor of the second is sequenced before the initiation of the destructor of the first.</p>\n</blockquote>\n<p>Given that, the above approach <strong>is safe</strong> for destruction. <code>all_objects</code> will be destructed only after the last <code>Object</code> will be destructed.</p>\n", "LastActivityDate": "2016-09-17T17:13:09.010"}, "bq_ids": {"n4140": {"so_39539577_39539765_1": {"section_id": 7156, "quality": 1.0, "length": 19}}, "n3337": {"so_39539577_39539765_1": {"section_id": 6900, "quality": 1.0, "length": 19}}, "n4659": {"so_39539577_39539765_1": {"section_id": 8663, "quality": 1.0, "length": 19}}}, "39539743": {"ParentId": "39539577", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-09-16T20:37:43.080", "Score": "1", "LastEditorUserId": "3747990", "LastEditDate": "2016-09-17T07:00:38.067", "Id": "39539743", "OwnerUserId": "3747990", "Body": "<blockquote>\n<p id=\"so_39539577_39539743_0\">Would this be \"safe\" with respect to static <code>Objects</code> in different compilation units?</p>\n</blockquote>\n<p>No, it is not safe.</p>\n<p>This is an example of when it would not be safe since <em>the relative order of static data initialization is not guaranteed</em>. There are some platform specific ways to achieve this though. </p>\n<p><a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use\" rel=\"nofollow\">See the FAQ for techniques to work around this <em>static initialisation fiasco</em></a>. The technique basically hides the static member in a function and it is then initialised on first use. </p>\n<p>It could be made to be safe so long as the objects added to the static member are managed appropriately, i.e. not static and they are not left dangling somewhere or in some undefined state and suffer no other undefined behaviour.</p>\n<blockquote>\n<p id=\"so_39539577_39539743_1\">And does the answer change if the code is being used as a library (say within Python) rather than as a standalone program with its own main()?</p>\n</blockquote>\n<p>I don't believe this would be defined by the standard other than it being implementation defined. As far as I know, no, given the popular implementations, the platforms and their ABI etc. the answer would not change. </p>\n", "LastActivityDate": "2016-09-17T07:00:38.067"}});