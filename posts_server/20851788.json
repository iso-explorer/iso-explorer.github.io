post_cb({"bq_ids": {"n4140": {"so_20851788_20851978_0": {"length": 17, "quality": 1.0, "section_id": 166}}, "n3337": {"so_20851788_20851978_0": {"length": 17, "quality": 1.0, "section_id": 160}}, "n4659": {"so_20851788_20851978_0": {"length": 17, "quality": 1.0, "section_id": 170}}}, "20851788": {"ViewCount": "663", "Body": "<p>I read \"The C++ Programming language 4th edition, 1st printing, by Bjarne Stroustrup\" book (from Amazon.com).\nPage 785.\nStroustrup is explaining how he can eliminate explicit writing of \"<strong>::type</strong>\", when using \"<strong>std::conditional</strong> + <strong>std::make_unsigned</strong>\", using \"<strong>type aliases</strong>\" (keyword \"using\"). But that using \"type aliases\" on \"<strong>std::conditional</strong> + <strong>std::make_unsigned</strong>\" is causing compile errors. \nBy now everything is as it should be. And he goes on to show how to elimintate these compile errors using \"delayed evaluation of template type function\".</p>\n<p>The question is on the line <code>Atype&lt;make_unsigned&lt;string&gt;</code> and <code>myType2&lt;string&gt; ...</code>.</p>\n<p>I used g++ 4.8.2.</p>\n<h2>Compile:</h2>\n<h2>g++ -std=c++1y test45.cpp -o a</h2>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;  // for typeid(...)\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct ErrIndicator {\n   typedef ErrIndicator&lt;T&gt; type;\n};\n\ntemplate&lt;bool C, class T, class F&gt;\nusing Conditional = typename conditional&lt;C,T,F&gt;::type;\n\ntemplate&lt;typename T&gt;\nusing Make_unsigned = typename make_unsigned&lt;T&gt;::type;\n\ntemplate&lt;template&lt;typename ...&gt; class F, typename... Args&gt;\nusing Delay = F&lt;Args ...&gt;;\n\ntemplate&lt;class T&gt;\nusing myType1 = Conditional&lt;is_integral&lt;T&gt;::value,\n    Make_unsigned&lt;T&gt;,\n    ErrIndicator&lt;T&gt;\n    &gt;;\n\ntemplate&lt;class T&gt; \n    using myType2 = Conditional&lt;is_integral&lt;T&gt;::value,\n    Delay&lt;Make_unsigned, T&gt;,   // delayed evaluation\n    ErrIndicator&lt;T&gt;\n    &gt;;\n\ntemplate&lt;class T&gt;\n    using myType4 = Conditional&lt;is_integral&lt;T&gt;::value,\n    make_unsigned&lt;T&gt;,\n    ErrIndicator&lt;T&gt;\n    &gt;;\n\ntemplate&lt;typename T&gt;\nclass Atype {}; \n\ntemplate&lt;typename T&gt;\nvoid func1(T &amp;ia /* output param */) {\n  cout &lt;&lt; \"unsigned integral type\" &lt;&lt; endl;\n  ia = 4;  // \"unsigned integral type\" computation\n}\n\ntemplate&lt;typename T&gt;\nvoid func1(ErrIndicator&lt;T&gt; &amp;) {\n  cout &lt;&lt; \"non integral type: \" &lt;&lt; typeid(T).name() &lt;&lt; endl;\n}\n\nint main() {\n  myType1&lt;int&gt; var1a; // OK\n  // myType1&lt;string&gt; var1b; // Error; The book says error\n  //                    // should occur here. Here I understand.\n  myType2&lt;int&gt; var2a; // OK\n  // myType2&lt;string&gt; var2b; // Error - why?. Maybe I didn't get it,\n  //                      // but I understand the book as no\n  //                      // error should occur here.\n  //                      // @DyP answered it.\n  Atype&lt;make_unsigned&lt;string&gt; &gt; var3;  // OK here, look below at @DyP\n  //                             // for \"foo, bar, X\" why\n  //                        // make_unsigned&lt;string&gt; is not an error here.\n  // make_unsigned&lt;string&gt; var6; // Error\n  // Atype&lt;make_unsigned&lt;string&gt;::type &gt; var4;  // Error\n  Atype&lt;make_unsigned&lt;int&gt;::type &gt; var5;  // OK\n  //-------------\n  myType4&lt;string&gt;::type var7;    // Look below for \"myType3\", where @Yakk\n  //                          // obviates the necessity to write \"::type\".\n  // rsl7 = 1:\n  cout &lt;&lt; \"rsl7 = \" &lt;&lt; is_same&lt;decltype(var7), ErrIndicator&lt;string&gt; &gt;::value &lt;&lt; endl; \n  func1(var7);  // \"non integral type\" overload of func1()\n  //---------\n  myType4&lt;int&gt;::type var8;\n  // rsl8 = 1:\n  cout &lt;&lt; \"rsl8 = \" &lt;&lt; is_same&lt;decltype(var8), unsigned int&gt;::value &lt;&lt; endl; \n  func1(var8);  // \"unsigned integral type\" overload of func1()\n}\n</code></pre>\n", "AcceptedAnswerId": "20851978", "Title": "Delayed evaluation of template type function", "CreationDate": "2013-12-31T04:39:12.190", "Id": "20851788", "CommentCount": "8", "LastEditDate": "2014-01-07T09:46:49.577", "PostTypeId": "1", "LastEditorUserId": "1578604", "LastActivityDate": "2014-01-07T09:46:49.577", "Score": "6", "OwnerUserId": "2697065", "Tags": "<c++><templates><c++11>", "AnswerCount": "2"}, "20852289": {"Id": "20852289", "PostTypeId": "2", "Body": "<pre><code>template&lt;bool, template&lt;typename...&gt;class Lhs, template&lt;typename...&gt;class Rhs, typename... Ts&gt;\nstruct conditional_apply {\n  typedef Lhs&lt;Ts...&gt; type;\n};\ntemplate&lt;template&lt;typename...&gt;class Lhs, template&lt;typename...&gt;class Rhs, typename...Ts&gt;\nstruct conditional_apply&lt;false, Lhs, Rhs, Ts...&gt; {\n  typedef Rhs&lt;Ts...&gt; type;\n};\ntemplate&lt;bool b, template&lt;typename...&gt;class Lhs, template&lt;typename...&gt;class Rhs, typename... Ts&gt;\nusing Conditional_apply=typename conditional_apply&lt;b, Lhs, Rhs, Ts...&gt;::type;\n\ntemplate&lt;class T&gt; using myType3 = Conditional_apply&lt;is_integral&lt;T&gt;::value, Make_unsigned, ErrIndicator, T &gt;;\n</code></pre>\n<p>should do actual delayed application of <code>template</code>s on <code>T</code>, barring typos (on phone).</p>\n", "LastActivityDate": "2013-12-31T05:32:38.023", "CommentCount": "0", "CreationDate": "2013-12-31T05:32:38.023", "ParentId": "20851788", "Score": "2", "OwnerUserId": "1774667"}, "20851978": {"Id": "20851978", "PostTypeId": "2", "Body": "<p>I think Stroustrup intents to delay the access to <code>make_unsigned&lt;T&gt;::type</code>, because this nested type isn't defined for non-integral types. However, using an alias template seems not to be enough for clang++ and g++: They resolve <code>Delay&lt;Make_unsigned,T&gt;</code> directly to <code>Make_unsigned&lt;T&gt;</code>, and this to <code>make_unsigned&lt;T&gt;::type</code>.</p>\n<p>The whole example is:</p>\n<pre><code>template&lt;typename C, typename T, typename F&gt;\nusing Conditional = typename std::conditional&lt;C,T,F&gt;::type;\n\ntemplate&lt;typename T&gt;\nusing Make_unsigned = typename std::make_unsigned&lt;T&gt;::type;\n\n// the example\nConditional&lt;\n  is_integral&lt;T&gt;::value,\n  Delay&lt;Make_unsigned,T&gt;,\n  Error&lt;T&gt;\n&gt;\n\n// \"The implementation of a perfect `Delay` function is nontrivial,\n//  but for many uses this will do:\"\ntemplate&lt;template&lt;typename...&gt; class F, typename... Args&gt;\nusing Delay = F&lt;Args...&gt;;\n</code></pre>\n<hr>\n<p>The question is of course, when is <code>Delay&lt;Make_Unsigned,T&gt;</code> resolved? For class templates (not alias templates), they're only instantiated implicitly when a complete object type is required or the semantics of the program are affected. Consider:</p>\n<pre><code>#include &lt;type_traits&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct foo\n{\n    static_assert(is_same&lt;T, void&gt;{}, \"!\");\n};\n\ntemplate&lt;class X&gt;\nstruct bar\n{\n    // without the line below, no error!\n    //X x;\n};\n\nint main()\n{\n    bar&lt;foo&lt;int&gt;&gt; b;\n}\n</code></pre>\n<p>This however is not the case for alias templates. They're substituted [temp.alias]/2</p>\n<blockquote>\n<p id=\"so_20851788_20851978_0\">When a <em>template-id</em> refers to the specialization of an alias template, it is equivalent to the associated type\n  obtained by substitution of its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of the alias\n  template.</p>\n</blockquote>\n<p>IMHO, this suggests that in the example above, <code>Delay&lt;Make_unsigned,T&gt;</code> is equivalent to <code>make_unsigned&lt;T&gt;::type</code>, which <em>will</em> instantiate <code>make_unsigned&lt;string&gt;::type</code> and cause a compile-time error.</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-12-31T05:41:24.840", "Score": "3", "CreationDate": "2013-12-31T05:02:27.553", "ParentId": "20851788", "CommentCount": "8", "OwnerUserId": "420683", "LastEditDate": "2013-12-31T05:41:24.840"}});