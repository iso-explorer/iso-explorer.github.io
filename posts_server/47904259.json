post_cb({"bq_ids": {"n4140": {"so_47904259_47904371_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5313}}, "n3337": {"so_47904259_47904371_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5110}}, "n4659": {"so_47904259_47904371_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6737}}}, "47904836": {"Id": "47904836", "PostTypeId": "2", "Body": "<p>This behavious is inherited from C compilers and the old time when we used serial terminals where only 7 bits were used (the 8th being a parity bit). To allow non English languages with special characters (for example the accented \u00e0\u00e9\u00e8\u00ea\u00ee\u00ef\u00f4\u00f9 in French or \u00f1 in Spanish) the <a href=\"https://en.wikipedia.org/wiki/ISO/IEC_646\" rel=\"nofollow noreferrer\">ISO/IEC 646</a> code pages used some ASCII (7bits) code to represent them. In particular, the codes 0x23, 0x24 (<code>#$</code> in ASCII) 0x40 (<code>@</code>), 0x5B to 0x5E(<code>[\\]^</code>), 0x60 (`) and 0x7B to 0x7E (<code>{|}~</code>) could be replaced by national variants<sup>1</sup>.</p>\n<p>As they have special meaning in C, they could be replaced in source code with trigraphs using only the invariant part of the ISO 646.</p>\n<p>For compatibility reasons, this has been kept up to the C++14, when only dinosaurs still remember of the (not so good) days of ISO646 and 7 bits only code pages.</p>\n<hr>\n<p><sup>1</sup> For example, the French variant used: 0x23 <code>\u00a3</code>, 0x40 <code>\u00e0</code> 0x5B-0x5D <code>\u00b0\u00e7\u00a7</code>, 0x60 <code>\u00b5</code>, 0x7B-0x7E <code>\u00e9\u00f9\u00e8\u00a8</code></p>\n</hr>", "LastActivityDate": "2017-12-20T11:20:08.370", "Score": "1", "CreationDate": "2017-12-20T11:20:08.370", "ParentId": "47904259", "CommentCount": "2", "OwnerUserId": "3545273"}, "47904259": {"ViewCount": "53", "Body": "<p>Consider this innocuous C++ program:</p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n  std::cout &lt;&lt; \"(Is this a trigraph??)\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>When I compile it using g++ version 5.4.0, I get the following diagnostic:</p>\n<pre><code>me@my-laptop:~/code/C++$ g++ -c test_trigraph.cpp\ntest_trigraph.cpp:4:36: warning: trigraph ??) ignored, use -trigraphs to enable [-Wtrigraphs]\n   std::cout &lt;&lt; \"(Is this a trigraph??)\" &lt;&lt; std::endl;\n                                     ^\n</code></pre>\n<p>The program runs, and its output is as expected:</p>\n<pre><code>(Is this a trigraph??)\n</code></pre>\n<p>Why are string literals parsed for trigraphs at all?</p>\n<p>Do other compilers do this, too?</p>\n", "AcceptedAnswerId": "47904371", "Title": "Why are string literals parsed for trigraph sequences in Gnu gcc/g++?", "CreationDate": "2017-12-20T10:46:40.260", "Id": "47904259", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-12-20T11:27:09.850", "Score": "0", "OwnerUserId": "4487214", "Tags": "<c++><gcc><trigraphs>", "AnswerCount": "2"}, "47904371": {"Id": "47904371", "PostTypeId": "2", "Body": "<p>Trigraphs were handled in translation phase 1 (they are removed in C++17, however). String literal related processing happens in subsequent phases. As the C++14 standard specifies (n4140) <a href=\"https://timsong-cpp.github.io/cppwp/n4140/lex.phases#1.1\" rel=\"nofollow noreferrer\">[lex.phases]/1.1</a>:</p>\n<blockquote>\n<p id=\"so_47904259_47904371_0\">The precedence among the syntax rules of translation is specified by\n  the following phases.</p>\n<ol>\n<li>Physical source file characters are mapped, in an implementation-defined manner, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary. The set of physical source file characters accepted is\n  implementation-defined. <strong>Trigraph sequences ([lex.trigraph]) are\n  replaced by corresponding single-character internal representations.</strong>\n  Any source file character not in the basic source character set\n  ([lex.charset]) is replaced by the universal-character-name that\n  designates that character. (An implementation may use any internal\n  encoding, so long as an actual extended character encountered in the\n  source file, and the same extended character expressed in the source\n  file as a universal-character-name (i.e., using the \\uXXXX notation),\n  are handled equivalently except where this replacement is reverted in\n  a raw string literal.)</li>\n</ol>\n</blockquote>\n<p>This happened first, because as you were told in comments, the characters that trigraphs stood for needed to be printable as well.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-12-20T11:27:09.850", "Score": "4", "CreationDate": "2017-12-20T10:52:34.170", "ParentId": "47904259", "CommentCount": "1", "OwnerUserId": "817643", "LastEditDate": "2017-12-20T11:27:09.850"}});