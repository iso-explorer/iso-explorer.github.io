post_cb({"bq_ids": {"n4140": {"so_46457386_46457745_0": {"length": 4, "quality": 0.8, "section_id": 4724}}, "n3337": {"so_46457386_46457745_0": {"length": 4, "quality": 0.8, "section_id": 4531}}, "n4659": {"so_46457386_46457745_0": {"length": 4, "quality": 0.8, "section_id": 6123}}}, "46457386": {"ViewCount": "43", "Body": "<p>The <code>std::aligned_storage</code> structure provides a <code>type</code> typedef that at least according to <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow noreferrer\">cppreference</a>: </p>\n<blockquote>\n<p id=\"so_46457386_46457386_0\">Provides the member typedef type, which is a PODType suitable for use\n  as uninitialized storage for any object whose size is at most Len and\n  whose alignment requirement is a divisor of Align.</p>\n<p id=\"so_46457386_46457386_1\">The default value of Align is the most stringent (the largest)\n  alignment requirement for any object whose size is at most Len.</p>\n</blockquote>\n<p>In particular, with the default value of <code>Align</code>, the suitably aligned for <em>any object</em> whose size is at most Len.</p>\n<p>Note that there are no caveats or exceptions for over-aligned types (and in any case the platform I'm using, gcc, supports at least some over-aligned types).</p>\n<p>How can such an implementation actually work? To satisfy the requirement of \"any object\" it would seem that it would either:</p>\n<ol>\n<li>On a platform where <code>alignof(T) &lt;= sizeof(T)</code> for types <code>T</code>, need to always align to roughly <code>Len</code> bytes, since an object of size <code>Len</code> could have an alignment of up to <code>Len</code>. Of course, this would waste a lot of memory for large <code>Len</code>!</li>\n<li>On a platform where <code>alignof(T)</code> may be larger than than <code>sizeof(T)</code>, I don't see how it could be implemented at all. However, it isn't <a href=\"https://stackoverflow.com/questions/46457449/is-it-always-the-case-that-sizeoft-alignoft-for-all-types-t\">clear to me</a> that such a type can even exist.</li>\n</ol>\n<p>Based on <a href=\"http://coliru.stacked-crooked.com/a/d27a419d81c12f2d\" rel=\"nofollow noreferrer\">my testing</a>, for default <code>Align</code> values, <code>gcc</code> simply always aligns to 16, regardless of len. This means the storage is <em>not</em> suitable for <em>any</em> object, but only objects of fundamental alignment (<code>alignof(max_align_t) == 16</code> on this platform).</p>\n", "AcceptedAnswerId": "46457745", "Title": "How can std::aligned_storage expose correctly aligned storage for any object?", "CreationDate": "2017-09-27T21:19:18.567", "Id": "46457386", "CommentCount": "0", "LastEditDate": "2017-09-27T21:25:38.477", "PostTypeId": "1", "LastEditorUserId": "149138", "LastActivityDate": "2017-09-27T21:48:29.657", "Score": "2", "OwnerUserId": "149138", "Tags": "<c++><c++11><memory-management><alignment>", "AnswerCount": "1"}, "46457745": {"Id": "46457745", "PostTypeId": "2", "Body": "<p>Per <a href=\"https://timsong-cpp.github.io/cppwp/meta.trans.other#2\" rel=\"nofollow noreferrer\">[meta.trans.other]/2</a>,</p>\n<blockquote>\n<p id=\"so_46457386_46457745_0\">It is implementation-defined whether any extended alignment is supported.</p>\n</blockquote>\n<p>It's pretty annoying when they specify stuff like this after the big table without a pointer. I've just added the sentence to cppreference.</p>\n", "LastActivityDate": "2017-09-27T21:48:29.657", "CommentCount": "1", "CreationDate": "2017-09-27T21:48:29.657", "ParentId": "46457386", "Score": "2", "OwnerUserId": "2756719"}});