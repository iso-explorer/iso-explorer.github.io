post_cb({"bq_ids": {"n4140": {"so_30466949_30468523_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_30466949_30468523_1": {"length": 8, "quality": 1.0, "section_id": 411}}, "n3337": {"so_30466949_30468523_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_30466949_30468523_1": {"length": 8, "quality": 1.0, "section_id": 402}}, "n4659": {"so_30466949_30468523_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_30466949_30468523_1": {"length": 8, "quality": 1.0, "section_id": 429}}}, "30467640": {"Id": "30467640", "PostTypeId": "2", "Body": "<p>If you call destructor explicitely, it will be called second time implicitely when <code>f3</code> goes out of scope. This creates UB and that is why your class crashes.</p>\n<p>You can work-around the crash in <code>delete</code> by resetting <code>s</code> to <code>nullptr</code> in the destructor (so that second time it is <code>nullptr</code>) but the UB in calling destructor twice will be still there.</p>\n", "LastActivityDate": "2015-05-26T19:50:50.013", "CommentCount": "0", "CreationDate": "2015-05-26T19:50:50.013", "ParentId": "30466949", "Score": "3", "OwnerUserId": "4538344"}, "30468523": {"Id": "30468523", "PostTypeId": "2", "Body": "<p>For any class with a non-trivial destructor, destroying it twice is undefined behavior by core language rule:</p>\n<p>[basic.life]/p1:</p>\n<blockquote>\n<p id=\"so_30466949_30468523_0\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>[class.dtor]/p15:</p>\n<blockquote>\n<p id=\"so_30466949_30468523_1\">the behavior is undefined if the destructor is invoked for an object\n  whose lifetime has ended (3.8)</p>\n</blockquote>\n<p>Your code destroys <code>f3</code> twice, once by explicit destructor call and once by leaving the scope, so it has undefined behavior.</p>\n<p>It happens that both libstdc++ and libc++'s <code>unique_ptr</code> destructor will assign a null pointer to the stored pointer (libc++ calls <code>reset()</code>; libstdc++ does it manually). This is not required by the standard, and is arguably a performance bug in something that's meant to be an zero-overhead wrapper over raw pointers. As a result, your code \"works\" in <code>-O0</code>. </p>\n<p>g++ at <code>-O2</code>, however, is able to see that the assignment in the destructor cannot possibly be observed by a well-defined program, so it optimizes away the assignment, causing a double delete.</p>\n", "LastActivityDate": "2015-05-26T20:43:32.083", "CommentCount": "0", "CreationDate": "2015-05-26T20:43:32.083", "ParentId": "30466949", "Score": "4", "OwnerUserId": "2756719"}, "30466949": {"ViewCount": "157", "Body": "<p>I took the code from <a href=\"https://stackoverflow.com/q/4082065/1858225\">this question</a> and edited it to produce a segfault by explicitly calling the destructor of one of the move-constructed objects:</p>\n<pre><code>using namespace std;\n\nstruct Foo\n{\n    Foo()  \n    {\n        s = new char[100]; \n        cout &lt;&lt; \"Constructor called!\" &lt;&lt; endl;  \n    }\n\n    Foo(const Foo&amp; f) = delete;\n\n    Foo(Foo&amp;&amp; f) :\n      s{f.s}\n    {\n        cout &lt;&lt; \"Move ctor called!\" &lt;&lt; endl;   \n        f.s = nullptr;\n    }\n\n    ~Foo() \n    { \n        cout &lt;&lt; \"Destructor called!\" &lt;&lt; endl;   \n        cout &lt;&lt; \"s null? \" &lt;&lt; (s == nullptr) &lt;&lt; endl;\n        delete[] s; // okay if s is NULL\n    }\n\n    char* s;\n};\n\nvoid work(Foo&amp;&amp; f2)\n{\n    cout &lt;&lt; \"About to create f3...\" &lt;&lt; endl;\n    Foo f3(move(f2));\n    // f3.~Foo();\n}\n\nint main()\n{\n    Foo f1;\n    work(move(f1));\n}\n</code></pre>\n<p>Compiling and running this code (with G++ 4.9) produces the following output:</p>\n<pre><code>Constructor called!\nAbout to create f3...\nMove ctor called!\nDestructor called!\ns null? 0\nDestructor called!\ns null? 0\n*** glibc detected *** ./a.out: double free or corruption (!prev): 0x0916a060 ***\n</code></pre>\n<p>Note that when the destructor is not explicitly called, no double-free error occurs.</p>\n<p>Now, when I change the type of <code>s</code> to <code>unique_ptr&lt;char[]&gt;</code> and remove the <code>delete[] s</code> in <code>~Foo()</code> and <code>f.s = nullptr</code> in <code>Foo(Foo&amp;&amp;)</code> (see full code below), I do <em>not</em> get a double-free error:</p>\n<pre><code>Constructor called!\nAbout to create f3...\nMove ctor called!\nDestructor called!\ns null? 0\nDestructor called!\ns null? 1\nDestructor called!\ns null? 1\n</code></pre>\n<p>What is going on here? Why can the moved-to object be explicitly deleted when its data member is a <code>unique_ptr</code>, but not when the invalidation of the moved-from object is handled manually in <code>Foo(Foo&amp;&amp;)</code>? Since the move-constructor <em>is</em> called when <code>f3</code> is created (as shown by the \"Move ctor called!\" line), why does the first destructor call (presumably for <code>f3</code>) state that <code>s</code> is <em>not</em> null? If the answer is simply that <code>f3</code> and <code>f2</code> are somehow actually the same object due to an optimization, what is <code>unique_ptr</code> doing that's preventing the same problem from happening with that implementation?</p>\n<hr>\n<p><strong>EDIT:</strong> As requested, the full code using <code>unique_ptr</code>:</p>\n<pre><code>using namespace std;\n\n struct Foo\n{\n    Foo() :\n      s{new char[100]}\n    {\n        cout &lt;&lt; \"Constructor called!\" &lt;&lt; endl;  \n    }\n\n    Foo(const Foo&amp; f) = delete;\n\n    Foo(Foo&amp;&amp; f) :\n      s{move(f.s)}\n    {\n        cout &lt;&lt; \"Move ctor called!\" &lt;&lt; endl;   \n    }\n\n    ~Foo() \n    { \n        cout &lt;&lt; \"Destructor called!\" &lt;&lt; endl;   \n        cout &lt;&lt; \"s null? \" &lt;&lt; (s == nullptr) &lt;&lt; endl;\n    }\n\n    unique_ptr&lt;char[]&gt; s;\n};\n\nvoid work(Foo&amp;&amp; f2)\n{\n    cout &lt;&lt; \"About to create f3...\" &lt;&lt; endl;\n    Foo f3(move(f2));\n    f3.~Foo();\n}\n\nint main()\n{\n    Foo f1;\n    work(move(f1));\n}\n</code></pre>\n<p>I have double-checked that this produces the output copied above.</p>\n<p><strong>EDIT2:</strong> Actually, using Coliru (see T.C.'s link below), this exact code <em>does</em> produce a double-deletion error.</p>\n</hr>", "AcceptedAnswerId": "30468523", "Title": "Why doesn't this RAII move-only type properly emulate `std::unique_ptr`?", "CreationDate": "2015-05-26T19:11:54.880", "Id": "30466949", "CommentCount": "22", "LastEditDate": "2017-05-23T12:21:51.273", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-26T20:43:32.083", "Score": "0", "OwnerUserId": "1858225", "Tags": "<c++><c++11><move-semantics><unique-ptr>", "AnswerCount": "2"}});