post_cb({"bq_ids": {"n4140": {"so_48209179_48209179_0": {"length": 34, "quality": 0.8095238095238095, "section_id": 5913}}, "n3337": {"so_48209179_48209179_0": {"length": 34, "quality": 0.8095238095238095, "section_id": 5685}}, "n4659": {"so_48209179_48209179_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 7404}}}, "48209179": {"ViewCount": "76", "Body": "<p>In the <code>union U</code> below, if <code>a</code> or <code>b</code> is the active member, is it defined behavior to access <code>c</code>?</p>\n<pre><code>struct A{\n    int a;\n};\nstruct B{\n    int a;\n    double b;\n};\nunion U{\n    A a;\n    B b;\n    int c;\n};\n</code></pre>\n<hr>\n<p>In <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.union#1\" rel=\"nofollow noreferrer\">[class.union]</a>, the standard defines some rules to make using a <code>union</code> easier (<strong>emphasis</strong> mine):</p>\n<blockquote>\n<p id=\"so_48209179_48209179_0\">[\u2009Note: One special guarantee is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout <strong>structs</strong> that share a common initial sequence, and if a non-static data member of an object of this standard-layout union type is active and is one of the standard-layout <strong>structs</strong>, it is permitted to inspect the common initial sequence of any of the standard-layout <strong>struct</strong> members; see [class.mem]. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>I'm hung up on the word <strong>struct</strong> here. Does a standard layout scalar like <code>int</code> count even though it's not a struct?</p>\n<ul>\n<li><p>My <code>union U</code> above is indeed a \"standard-layout\" union following <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class\" rel=\"nofollow noreferrer\">[class]</a> that basically says it needs to be a standard layout class that uses the <code>union</code> keyword instead, and since we only use scalars (standard layout types), it passes.</p></li>\n<li><p>The structs obviously share a <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.mem#def:common_initial_sequence\" rel=\"nofollow noreferrer\">common initial sequence</a> that consists of the first <code>int</code> member, but it's unclear if fundamental types can be considered for common initial sequences.</p>\n<ul>\n<li><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.union#2\" rel=\"nofollow noreferrer\">[class.union]</a> also says that \"Each non-static data member is allocated as if it were the sole member of a struct.\" which I think gives evidence that it is defined.</li>\n</ul></li>\n<li>Finally, standard layout structs are not allowed to have padding at the beginning (<a href=\"https://timsong-cpp.github.io/cppwp/n4659/class#mem-24\" rel=\"nofollow noreferrer\">[class.mem]</a>), and the members of a union are <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.compound#4\" rel=\"nofollow noreferrer\">pointer interconvertible</a> so the standard is telling us that the <code>int</code> elements in the standard layout structs, and the non-static <code>int c</code> in the union are guaranteed to align.</li>\n</ul>\n</hr>", "AcceptedAnswerId": "48209398", "Title": "Do scalar members in a union count towards the common initial sequence?", "CreationDate": "2018-01-11T14:18:19.670", "LastActivityDate": "2018-01-12T14:09:18.070", "CommentCount": "11", "LastEditDate": "2018-01-11T15:13:19.410", "PostTypeId": "1", "LastEditorUserId": "27678", "Id": "48209179", "Score": "2", "OwnerUserId": "27678", "Tags": "<c++><language-lawyer><c++17><unions>", "AnswerCount": "1"}, "48209398": {"Id": "48209398", "PostTypeId": "2", "Body": "<p><code>struct A</code> and <code>struct B</code> are:</p>\n<ul>\n<li>contained in the standard-layout <code>union U</code>,</li>\n<li>standard-layout structs, and</li>\n<li>share a common initial sequence.</li>\n</ul>\n<p>So, they satisfy the description in the sentence \u201cIf a standard-layout union contains several standard-layout structs that share a common initial sequence\u2026\u201d.</p>\n<p>The <code>int c</code> that is also in the union is not such a struct nor is it in such a struct. So this sentence is not telling you that you can write to <code>c</code> and inspect <code>a.a</code> or <code>b.a</code>, nor that you can write to <code>a.a</code> or <code>b.a</code> and inspect <code>c</code>.</p>\n<p>This means that <code>c</code> is not part of the common initial sequence you can inspect. But neither does it spoil the common initial sequence of <code>struct A</code> and <code>struct B</code>.</p>\n<p>Regarding the text \u201cEach non-static data member is allocated as if it were the sole member of a struct,\" the standard is being a bit sloppy with language here. Allocation usually refers to acquiring or reserving storage, but this use seems to refer to laying out the bytes of an object within given storage. I do not see a formal definition in the C++ standard (but I did not look too hard), but I did find a similar use. So I take it to mean that each non-static data member is laid out as if it were the sole member.</p>\n<p>What this says is that a pointer to any one of these union members points to the same place as a pointer to any of the other union members. This may imply that pointers to one can be converted to pointers to the other. However, it does not give you license to violate the strict-aliasing rules. Even if <code>x</code> is a pointer to <code>c</code> and <code>y</code> is a pointer to <code>a</code> or <code>a.a</code>, you cannot use <code>*x</code> to access <code>c</code> while <code>a</code> is the last-written member or use <code>*y</code> while <code>c</code> is the last-written member.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2018-01-12T14:09:18.070", "Score": "6", "CreationDate": "2018-01-11T14:28:56.777", "ParentId": "48209179", "CommentCount": "1", "OwnerUserId": "298225", "LastEditDate": "2018-01-12T14:09:18.070"}});