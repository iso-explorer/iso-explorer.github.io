post_cb({"29954631": {"Id": "29954631", "PostTypeId": "2", "Body": "<p>Just as with functions, variables can have 'purely declarative' declarations, and actual definitions. You're confused because you probably didn't encounter many pure variable declarations before.</p>\n<pre><code>int i; // Definition\nextern int i, j; // (Re)declares i, and declares j\nextern int j = 0; // Defines j (confusing, eh?)\n</code></pre>\n<p>As you're used to with functions, definitions are declarations, but not all declarations are definitions. \u00a73.1/2 reads</p>\n<blockquote>\n<p id=\"so_29954191_29954631_0\">A declaration is a <em>definition</em> unless [\u2026] it declares a static data\n  member in a class definition (9.2, 9.4),</p>\n</blockquote>\n<p>Thus in-class static data member declarations are never defining the variables they declare. However, sometimes, a variables definition doesn't have to be present. That is the case <strong>when you can use its value directly without necessitating the variables run-time existence.</strong></p>\n<p>In technical terms, as long as a static data member (or any entity, for that matter) is not 'odr-used', it doesn't have to be defined. <em>Odr-use</em> for all entities is defined in \u00a73.2/3:</p>\n<blockquote>\n<p id=\"so_29954191_29954631_1\">A variable <code>x</code> whose name appears as a <em>potentially-evaluated</em> expression\n  <code>ex</code> is <em>odr-used</em> by <code>ex</code> unless applying the lvalue-to-rvalue conversion\n  (4.1) to <code>x</code> yields a constant expression (5.20) that does not invoke\n  any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of\n  the set of potential results of an expression <code>e</code>, where either the\n  lvalue-to-rvalue conversion (4.1) is applied to <code>e</code>, or <code>e</code> is a\n  discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>This looks complicated, and it was simpler in earlier versions of the standard. However, it roughly says that the variable is not odr-used by some expression when that expression \"immediately\" accesses the variables value, and this access yields a constant expression. Meyers example of \"taking its address\" is only one of many for odr-use.</p>\n<p>For some class <code>A</code> and its static data member <code>i</code>,</p>\n<pre><code>class A {\n    static const int i = 57; // Declaration, not definition\n};\n\nconst int A::i; // Definition in namespace scope. Not required per se.\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-04-29T22:02:20.910", "Score": "8", "CreationDate": "2015-04-29T21:10:24.130", "ParentId": "29954191", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-04-29T22:02:20.910"}, "29954619": {"Id": "29954619", "PostTypeId": "2", "Body": "<p>It is stated <a href=\"http://www.oopweb.com/CPP/Documents/CPPAnnotations/Volume/cplusplus10.html\" rel=\"nofollow\">here</a> that:  </p>\n<blockquote>\n<p id=\"so_29954191_29954619_0\">Static <code>const</code> integral data members initialized in the class interface are not addressable variables. They are mere symbolic names for their associated values. Since they are not variables, it is not possible to determine their addresses. Note that this is not a compilation problem, but a linking problem. The static <code>const</code> variable that is initialized in the class interface does not exist as an addressable entity.   </p>\n</blockquote>\n<p>What \"addressable entity\" refers here is \"instance\" of static <code>const</code> data type. No instance, no address, i.e its only a declaration.<br>\nNote that static variables that are explicitly defined in a source file can be linked correctly, though.   </br></p>\n<pre><code>class X\n{\n    public:\n        static int const s_x = 34;\n        static int const s_y;\n};\n\nint const X::s_y = 12;\n\nint main()\n{\n    int const *ip = &amp;X::s_x;    // compiles, but fails to link\n    ip = &amp;X::s_y;               // compiles and links correctly\n} \n</code></pre>\n<blockquote>\n<p id=\"so_29954191_29954619_1\">... if you do take the address of a class constant, or if your .. part of the above quoted paragraph ?  </p>\n</blockquote>\n<p>It <a href=\"http://en.cppreference.com/w/cpp/language/static\" rel=\"nofollow\">means</a> if such a member is odr-used, a definition at namespace scope is still required, but it should not have an initializer.</p>\n<pre><code>struct X {\n    const static int n = 1;\n};\nconst int* p = &amp;X::n; // X::n is odr-used\nconst int X::n;       // ... so a definition is necessary\n</code></pre>\n", "LastEditorUserId": "2455888", "LastActivityDate": "2015-04-30T05:57:37.893", "Score": "2", "CreationDate": "2015-04-29T21:09:33.557", "ParentId": "29954191", "CommentCount": "6", "OwnerUserId": "2455888", "LastEditDate": "2015-04-30T05:57:37.893"}, "29954191": {"ViewCount": "1090", "Body": "<p>My question stems from studying <a href=\"http://www.amazon.in/Effective-Specific-Addison-Wesley-Professional-Computing/dp/0321334876\">Effective C++</a> by Scott Meyers. \nIn Item II of that book, following is written :</p>\n<blockquote>\n<p id=\"so_29954191_29954191_0\">To limit the scope of a constant to a class, you must make it a member and, to ensure there's at most one copy of the constant, you must make it a static member. </p>\n</blockquote>\n<p>That is correctly written. Then immediately the following example is given : </p>\n<pre><code>class GamePlayer {\nprivate:\n    static const int NumTurns = 5;\n    int scores[NumTurns];\n    ....\n  };\n</code></pre>\n<p>Then the following is written pertaining to the above example : </p>\n<blockquote>\n<p id=\"so_29954191_29954191_1\">What you see above is a <em>declaration</em> and not a definition of NumTurns.</p>\n</blockquote>\n<p><strong>My First question is : What is the meaning of this statement ?</strong></p>\n<p>Immediately after that the following is mentioned : </p>\n<blockquote>\n<p id=\"so_29954191_29954191_2\">Usually C++ requires that you provide a definition for anything you use, but class specific constants that are static and of integral type (e.g - integers, chars, bools) are an exception. As long as you don't take their address, you can declare them and use them without providing a definition. If you do take the address of a class constant, or if your compiler incorrectly insists on a definition even if you don't take the address, you provide a separate definition like this : \n  <code>const int GamePlayer::Numturns; //definition of NumTurns</code></p>\n</blockquote>\n<p><strong>Why now it is a definition and not a declaration ?</strong></p>\n<p>I understand the difference in the context of a function but do not understand it in the context of a regular variable. Also, can someone expand on what the author means by </p>\n<blockquote>\n<p id=\"so_29954191_29954191_3\">... if you do take the address of a class constant, or if your .. \n  part of the above quoted paragraph ?</p>\n</blockquote>\n<p>P.S : I am a relatively newbie in C++.</p>\n", "Title": "What is the difference between declaration and definition of a variable in C++?", "CreationDate": "2015-04-29T20:46:21.127", "LastActivityDate": "2015-04-30T05:57:37.893", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-04-29T21:04:33.233", "Tags": "<c++>", "Id": "29954191", "LastEditorUserId": "701092", "Score": "18", "OwnerUserId": "2711403", "ClosedDate": "2015-04-30T00:40:41.843", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_29954191_29954631_0": {"length": 7, "quality": 0.875, "section_id": 5907}, "so_29954191_29954631_1": {"length": 30, "quality": 0.9375, "section_id": 7040}}, "n3337": {"so_29954191_29954631_0": {"length": 7, "quality": 0.875, "section_id": 5679}}, "n4659": {"so_29954191_29954631_0": {"length": 7, "quality": 0.875, "section_id": 7389}, "so_29954191_29954631_1": {"length": 30, "quality": 0.9375, "section_id": 8537}}}, "29955881": {"Id": "29955881", "PostTypeId": "2", "Body": "<p>A short answer is: a declaration says \"this thing exists somewhere\", and a definition causes the space to be allocated.  In your case, you've declared it to be static and const.  The compiler may be smart enough to notice that if you only ever use it as a value, it can simply replace that usage with the literal 5.  It doesn't need to actually make space for a variable somewhere and fill it with the 5, it can use the 5 directly at compile-time.   However, if you take the address of it, the compiler can no longer make that assumption and now needs to put that 5 into somewhere addressable.  The compiler needs it to exist in one translation unit (roughly: one cpp file.  See also the One Definition Rule.), so now you have to explicitly declare it somewhere.</p>\n", "LastActivityDate": "2015-04-29T22:43:07.597", "CommentCount": "0", "CreationDate": "2015-04-29T22:43:07.597", "ParentId": "29954191", "Score": "0", "OwnerUserId": "1987633"}, "29954696": {"Id": "29954696", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29954191_29954696_0\"><strong>Why now it is a definition and not a declaration ?</strong></p>\n</blockquote>\n<p>Because this statement causes the compiler to generate an address for the static variable. </p>\n<blockquote>\n<p id=\"so_29954191_29954696_1\">Also, can someone expand on what the author means by \"if you do take\n  the address of a class constant\":</p>\n</blockquote>\n<p>When you make a pointer point to a variable you take its address.</p>\n", "LastActivityDate": "2015-04-29T21:14:00.197", "CommentCount": "0", "CreationDate": "2015-04-29T21:14:00.197", "ParentId": "29954191", "Score": "0", "OwnerUserId": "350737"}});