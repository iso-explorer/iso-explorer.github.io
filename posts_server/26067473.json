post_cb({"bq_ids": {"n4140": {"so_26067473_26069040_1": {"length": 27, "quality": 1.0, "section_id": 7140}, "so_26067473_26069198_1": {"length": 15, "quality": 1.0, "section_id": 7142}, "so_26067473_26069040_0": {"length": 20, "quality": 1.0, "section_id": 7047}}, "n3337": {"so_26067473_26069040_1": {"length": 27, "quality": 1.0, "section_id": 6884}, "so_26067473_26069198_1": {"length": 15, "quality": 1.0, "section_id": 6886}, "so_26067473_26069040_0": {"length": 20, "quality": 1.0, "section_id": 6792}}, "n4659": {"so_26067473_26069040_1": {"length": 27, "quality": 1.0, "section_id": 8641}, "so_26067473_26069198_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 8643}, "so_26067473_26069040_0": {"length": 20, "quality": 1.0, "section_id": 8544}}}, "26069198": {"Id": "26069198", "PostTypeId": "2", "Body": "<p>The standard clearly and unambiguously clarifies that the two declarations of <code>upper_bound</code> refer to the same object.</p>\n<blockquote>\n<p id=\"so_26067473_26069198_0\"><strong>3.5 Program and linkage [basic.link]</strong></p>\n<p id=\"so_26067473_26069198_1\">9 Two names that are the same (Clause 3) and that are declared in different scopes shall denote the same variable, function, type, enumerator, template or namespace if</p>\n<ul>\n<li>both names have external linkage or else both names have internal linkage and are declared in the same translation unit; and</li>\n<li>both names refer to members of the same namespace or to members, not by inheritance, of the same class; and</li>\n<li>when both names denote functions, the parameter-type-lists of the functions (8.3.5) are identical; and</li>\n<li>when both names denote function templates, the signatures (14.5.6.1) are the same.</li>\n</ul>\n</blockquote>\n<p>Both names have external linkage. Both names refer to a member in the global namespace. Neither name denotes a function or a function template. Therefore, both names refer to the same object. Suggesting that the fact that you've got separate declarations invalidates such basic facts is like saying that <code>int i = 0; int &amp;j = i; j = 1; return i;</code> might return zero, because the compiler might have forgotten what <code>j</code> refers to. Of course that must return 1. This has to work, plain and simple. If it doesn't, you've found a compiler bug.</p>\n", "LastActivityDate": "2014-09-26T22:29:26.710", "CommentCount": "2", "CreationDate": "2014-09-26T22:29:26.710", "ParentId": "26067473", "Score": "11", "OwnerUserId": "743382"}, "26069040": {"Id": "26069040", "PostTypeId": "2", "Body": "<p>This behavior seems to be correct if you dig a bit into the standard.</p>\n<p>First hint is in the note on at section 3.3.1/4, which says:</p>\n<blockquote>\n<p id=\"so_26067473_26069040_0\">Local extern declarations (3.5) may introduce a name into the declarative region where the declaration appears and also introduce a (possibly not visible) name into an enclosing namespace;</p>\n</blockquote>\n<p>Which is a little bit vague and seems to imply that compiler is not required to introduce the name <code>upper_bound</code> in the global context when passing through the <code>bar()</code> function, and therefore, when <code>upper_bound</code> appears in the <code>foo()</code> function, there is no connection made between those two extern variables, and therefore, <code>bar()</code> has no side-effect as far as the compiler knows, and thus, the optimization turns into an infinite loop (unless upper_bound is zero to begin with).</p>\n<p>But this vague language is not enough, and it is only a cautionary note, not a formal requirement.</p>\n<p>Fortunately, there is a precision later on, at section 3.5/7, which goes as follows:</p>\n<blockquote>\n<p id=\"so_26067473_26069040_1\">When a block scope declaration of an entity with linkage is not found to refer to some other declaration, then that entity is a member of the innermost enclosing namespace. However such a declaration does not introduce the member name in its namespace scope.</p>\n</blockquote>\n<p>And they even provide an example:</p>\n<pre><code>namespace X {\n  void p() {\n    q();              // error: q not yet declared\n    extern void q();  // q is a member of namespace X\n  }\n\n  void middle() {\n    q();              // error: q not yet declared\n  }\n}\n</code></pre>\n<p>which is directly applicable to the example you gave.</p>\n<p>So, the core of the issue is that the compiler is required <strong>not</strong> to make the association between the first <code>upper_bound</code> declaration (in bar) and the second one (in foo).</p>\n<p>So, let's examine the implication for optimization of the two <code>upper_bound</code> declarations are assumed to be un-connected. The compiler understands the code like this:</p>\n<pre><code>void bar() \n{\n   extern int upper_bound_1;\n   upper_bound_1--;\n}\n\nvoid foo()\n{\n   extern int upper_bound_2;\n   for (int i = 0; i &lt; upper_bound_2; ) {\n      bar();\n   }\n}\n</code></pre>\n<p>Which becomes as follows, due to function inlining of bar:</p>\n<pre><code>void foo()\n{\n   extern int upper_bound_1;\n   extern int upper_bound_2;\n   while( 0 &lt; upper_bound_2 ) {\n      upper_bound_1--;\n   }\n}\n</code></pre>\n<p>Which is clearly an infinite loop (as far the compiler knows), and even if <code>upper_bound</code> was declared <code>volatile</code>, it would just have an undefined termination point (whenever <code>upper_bound</code> happens to externally be set to 0 or less). And decrementing a variable (<code>upper_bound_1</code>) an infinite (or indefinite) amount of times has undefined behavior, because of overflow. Therefore, the compiler can choose to do nothing, which is an allowed behavior when it's undefined behavior, obviously. And so, the code becomes:</p>\n<pre><code>void foo()\n{\n   extern int upper_bound_2;\n   while( 0 &lt; upper_bound_2 ) { };\n}\n</code></pre>\n<p>Which is exactly what you see in the assembly listing for the function that GCC 4.8.2 produces (with <code>-O3</code>):</p>\n<pre><code>    .globl  _Z3foov\n    .type   _Z3foov, @function\n_Z3foov:\n.LFB1:\n   .cfi_startproc\n    movl    upper_bound(%rip), %eax\n    testl   %eax, %eax\n    jle .L6\n.L5:\n    jmp .L5\n    .p2align 4,,10\n    .p2align 3\n.L6:\n    rep ret\n    .cfi_endproc\n.LFE1:\n    .size   _Z3foov, .-_Z3foov\n</code></pre>\n<p>Which can be fixed by adding a global-scope declaration of the extern variable, as such:</p>\n<pre><code>extern int upper_bound;\n\nvoid bar() \n{\n   extern int upper_bound;\n   upper_bound--;\n}\n\nvoid foo()\n{\n   extern int upper_bound;\n   for (int i = 0; i &lt; upper_bound; ) {\n      bar();\n   }\n}\n</code></pre>\n<p>Which produces this assembly:</p>\n<pre><code>_Z3foov:\n.LFB1:\n    .cfi_startproc\n    movl    upper_bound(%rip), %eax\n    testl   %eax, %eax\n    jle .L2\n    movl    $0, upper_bound(%rip)\n.L2:\n    rep ret\n    .cfi_endproc\n.LFE1:\n    .size   _Z3foov, .-_Z3foov\n</code></pre>\n<p>Which is the intended behavior, i.e., the observable behavior of <code>foo()</code> is equivalent to:</p>\n<pre><code>void foo()\n{\n   extern int upper_bound;\n   upper_bound = 0;\n}\n</code></pre>\n", "LastActivityDate": "2014-09-26T22:12:59.257", "CommentCount": "31", "CreationDate": "2014-09-26T22:12:59.257", "ParentId": "26067473", "Score": "-2", "OwnerUserId": "491645"}, "26067473": {"ViewCount": "693", "Body": "<p>While debugging some legacy code I stumbled upon surprising (for me) compiler behavior. Now I'd like to know whether any clause in the C++ spec allows the following optimization, where side effects from a function call on the for-condition are ignored: </p>\n<pre><code>void bar() \n{\n   extern int upper_bound;\n   upper_bound--;\n}\n\nvoid foo()\n{\n   extern int upper_bound; // from some other translation unit, initially ~ 10\n   for (int i = 0; i &lt; upper_bound; ) {\n      bar();\n   }\n}\n</code></pre>\n<p>In the resulting dissambly there is a control path in which <code>upper_bound</code> is preserved in a register and the decrement of <code>upper_bound</code> in <code>bar()</code> never takes effect.</p>\n<p>My compiler is Microsoft Visual C++ 11.00.60610.1.</p>\n<p>Honestly I don't see much wiggle room in 6.5.3 and 6.5.1 of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\">N3242</a> but I want to be sure that I'm not missing something obvious. </p>\n", "Title": "Does C++ allow an optimizing compiler to ignore side effects on the for-condition?", "CreationDate": "2014-09-26T20:03:43.193", "LastActivityDate": "2014-09-26T23:33:37.203", "CommentCount": "30", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2014-09-26T23:33:37.203", "LastEditorUserId": "2756719", "Id": "26067473", "Score": "22", "OwnerUserId": "1490959", "Tags": "<c++><for-loop><language-lawyer><extern><specifications>", "AnswerCount": "2"}});