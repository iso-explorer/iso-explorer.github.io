post_cb({"7252828": {"ParentId": "5056973", "CommentCount": "3", "Body": "<p><code>std::list</code> is my preferred almost exclusively for but one property that <code>vector</code> does not share, and that's knowing my pointers into a <code>list</code> will always be valid.  Because of this, I can use this to contain all the instances of whatever asset I need in a single area, while also loaning out references to other objects to use.  Best example I could think of would be an image loader that only keeps one copy of pixels in memory, while loaning out pointers to multiple entities so they can all draw from it.</p>\n<p>All <code>vector</code> has going for it is O(1) access time.  While that sounds like a huge asset, in practice I have very rarely ever needed to access items in a data structure outside stepping from 'first' to 'last'</p>\n", "OwnerUserId": "620863", "PostTypeId": "2", "Id": "7252828", "Score": "1", "CreationDate": "2011-08-31T05:18:59.367", "LastActivityDate": "2011-08-31T05:18:59.367"}, "5056994": {"ParentId": "5056973", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Lists are better for inserting or deleting anywhere in the middle, vectors are better for inserting at the end.</p>\n<p>Vectors are also better for accessing elements.</p>\n<p>This is an artefact of the way they're implemented.</p>\n<p>So, if a collection changes very little (compared to accesses) or the changes are concentrated at the end, I'd use a vector.</p>\n<p>If the number of changes is substantial (compared to accesses) and they're not at the ends, I'd use a list.</p>\n<p>By way of example, reading in a collection at program startup and hardly ever changing it (or if the changes are onlt adding to the end), this would be a good candidate for a vector.</p>\n<p>On the other hand, a phone book application for a particularly popular and fickle rock star, I'd be looking towards a list. Actually I'd be looking toward a database connection but that was the best example I could come up with at short notice :-)</p>\n<p>As to references, the latest C++0x draft states in part (23.3.4, lists):</p>\n<blockquote>\n<p id=\"so_5056973_5056994_0\">A list is a sequence container that supports bidirectional iterators and allows constant time insert and erase operations anywhere within the sequence, with storage management handled automatically. Unlike vectors and deques, fast random access to list elements is not supported.</p>\n</blockquote>\n<p>Section 23.3.5 (on vectors):</p>\n<blockquote>\n<p id=\"so_5056973_5056994_1\">A vector is a sequence container that supports random access iterators. In addition, it supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time.</p>\n</blockquote>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2011-02-20T12:53:15.283", "Id": "5056994", "Score": "15", "CreationDate": "2011-02-20T12:21:34.777", "LastActivityDate": "2011-02-20T12:53:15.283"}, "5057001": {"ParentId": "5056973", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_5056973_5057001_0\">So my question is: when exactly do you <em>prefer</em> <code>std::list</code> over <code>std::vector</code>?</p>\n</blockquote>\n<p>When I need a sequential container in a performance-sensitive area and <strong><em>profiling</em></strong> shows <code>std::list</code> is faster. </p>\n<p>So far, this has never happened to me. </p>\n<p>(I might be tempted to try <code>std::list</code> first when I would have to store very big objects with lots of insertion/removal in the middle. However, in practice, I've never come across such a use-case.) </p>\n", "OwnerUserId": "140719", "LastEditorUserId": "140719", "LastEditDate": "2014-08-21T11:46:35.400", "Id": "5057001", "Score": "29", "CreationDate": "2011-02-20T12:23:33.727", "LastActivityDate": "2014-08-21T11:46:35.400"}, "bq_ids": {"n4140": {"so_5056973_5056994_1": {"section_id": 955, "quality": 1.0, "length": 22}, "so_5056973_5056994_0": {"section_id": 902, "quality": 1.0, "length": 28}}, "n3337": {"so_5056973_5056994_1": {"section_id": 943, "quality": 1.0, "length": 22}, "so_5056973_5056994_0": {"section_id": 888, "quality": 1.0, "length": 28}}, "n4659": {"so_5056973_5056994_1": {"section_id": 856, "quality": 0.9090909090909091, "length": 20}, "so_5056973_5056994_0": {"section_id": 962, "quality": 1.0, "length": 28}}}, "5058736": {"ParentId": "5056973", "CommentCount": "0", "Body": "<p>In addition to other answers,\nnode-base containers(<code>list</code>/associative containers) can provide strong\nexception guarantee.<br>\nEven if a container-mutating operation(for example insertion) throws an\nexception, all the pointers/references/iterators to the elements remain\nvalid.<br>\nHowever, linear-memory(piecewise contiguous memory cell) containers can\nprovide only basic guarantee.\nWhen an insertion throws, even if the insertion isn't actually executed,\npointers/references/iterators may be invalidated\n(though the container itself can be destructed safely).</br></br></p>\n", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "5058736", "Score": "2", "CreationDate": "2011-02-20T17:37:03.877", "LastActivityDate": "2011-02-20T17:37:03.877"}, "22975070": {"ParentId": "5056973", "CommentCount": "0", "Body": "<p>I don't need to repeat the basics, but what I learned the hard way is that if insertion performance is relevant and you have \"large\" objects, then you should <em>really</em> consider a std::list, <em>even</em> if you're only inserting at the end. (Well, a list or possibly a vector of smart pointer / ptr_vector.)</p>\n<p>We had some use cases where we had to build up collections of a priori unknown size of structs of multiple small std::string and using a std::vector totally killed insertion performance <em>and</em> added a non-neglible memory overhead.</p>\n<p>The <strong>problem with std::vector in the unknown count insert</strong> scenario is:</p>\n<ul>\n<li>Since the vector will always over allocate, you pay 50% space overhead worst case for typical implementations (A single vector of string, where an object has, e.g. 24 bytes (MSVC), given meagre 100,000 elements, could have a space overhead of 2MB. And it will multiply for larger objects with more string or other biggish members.)</li>\n<li>Every time the vector has to reallocate, it has to copy all the objects around, and that ain't cheap if you have anything slighly complex. Obviously, move-semantics will help, but if the objects themselves are large, the repeated copy may still be relevant. It doesn't matter if the average amortized insertion time (at the end) is theoretically constant, if you copy all your objects muliple times during building up of the vector. You may notice this peformance hit.</li>\n<li>Objects get large really quick: A struct of only two empty std::string already has <em>non-moveable</em> 48 bytes on MSVC.</li>\n</ul>\n<p>This is not to bash std::vector, I still use it by default -- but know what to expect of your datastructures!</p>\n", "OwnerUserId": "321013", "PostTypeId": "2", "Id": "22975070", "Score": "4", "CreationDate": "2014-04-09T22:20:52.257", "LastActivityDate": "2014-04-09T22:20:52.257"}, "5056973": {"CommentCount": "2", "AcceptedAnswerId": "5056994", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2011-02-20T12:18:20.490", "LastActivityDate": "2015-03-02T10:24:38.480", "LastEditDate": "2011-03-11T10:23:47.190", "ViewCount": "5349", "FavoriteCount": "5", "Title": "When do you prefer using std::list<T> instead of std::vector<T>?", "Id": "5056973", "Score": "26", "Body": "<p>I've never used <code>std::list&lt;T&gt;</code> myself. I was wondering when people use it when we already have <code>std::vector&lt;T&gt;</code> which is just like arrays with contiguous memory. <code>std::vector</code> seems like a perfect choice when we need sequential container!</p>\n<p>So my question is</p>\n<ul>\n<li>When exactly do you <em>prefer</em> <code>std::list</code> over <code>std::vector</code>? and why exactly? </li>\n<li>When do you <em>prefer</em> <code>std::vector</code> over <code>std::list</code>? and why?</li>\n</ul>\n<p>If there is performance consideration, then please list them too with detail explanation/information. </p>\n<p><strong>If possible, quote some references also, to support your answer.</strong></p>\n", "Tags": "<c++><stl><containers>", "OwnerUserId": "415784", "AnswerCount": "11"}, "5056990": {"ParentId": "5056973", "CommentCount": "4", "Body": "<p>You use std::list when you need to frequently modify the sequence in other places than the front or back. The overhead of such operations is large in std::vector in comparision std::list.</p>\n", "OwnerUserId": "346804", "PostTypeId": "2", "Id": "5056990", "Score": "1", "CreationDate": "2011-02-20T12:20:36.540", "LastActivityDate": "2011-02-20T12:20:36.540"}, "5058269": {"ParentId": "5056973", "CommentCount": "0", "Body": "<p>The only (few) times I preferred <code>std::list</code> is due to the <code>list::splice</code> member function. If you are shuffling around subranges within a list or between lists this operation can be significantly faster than using <code>std::vector</code>.</p>\n", "OwnerUserId": "445976", "PostTypeId": "2", "Id": "5058269", "Score": "6", "CreationDate": "2011-02-20T16:19:45.017", "LastActivityDate": "2011-02-20T16:19:45.017"}, "5057005": {"ParentId": "5056973", "CommentCount": "1", "Body": "<p>There are a few trade-offs to be considered when choosing between std::list and std::vector. Also std::list is not about contiguous memory, it can be quite useful if you can't afford iterator invalidation or if you need amortized constant time insertion in the begin/middle/end.</p>\n", "OwnerUserId": "155191", "PostTypeId": "2", "Id": "5057005", "Score": "11", "CreationDate": "2011-02-20T12:23:52.217", "LastActivityDate": "2011-02-20T12:23:52.217"}, "28807431": {"ParentId": "5056973", "CommentCount": "0", "Body": "<p>Some would say that you should, arguably, <a href=\"https://kjellkod.wordpress.com/2012/02/25/why-you-should-never-ever-ever-use-linked-list-in-your-code-again/\" rel=\"nofollow\">never ever ever use linked list in your code again</a>. ;)</p>\n<p>One issue is that vectors have much better <em>locality of reference</em>, and the big performance gains resulting from this will then, in many cases, outweigh the advantages of more (algorithmically) efficient operations for things like delete and insert in a linked list.</p>\n<p>(See the blog post lined above for more discussion of this specific issue, with benchmarks and so on.)</p>\n<p>So, often a std::vector will outperform std::list, even if you are doing a certain number of operations for which a list would be more natural (e.g. arbitrary element deletion, insert at arbitrary position, or splice).</p>\n<p>But note that, even when you <em>do</em> do lots of these kinds of operations, you may be better off 'hosting' your list within the contiguous buffer of a std::vector.</p>\n<p>I discuss this in more detail in this blog post, with some diagrams and code examples: <a href=\"http://upcoder.com/12/vector-hosted-lists/\" rel=\"nofollow\">http://upcoder.com/12/vector-hosted-lists/</a></p>\n<p>In the specific case when you need to delete arbitrary elements, but don't need to insert at arbitrary positions or splice, a good alternative to a full blown linked list can be to just mark entries as 'dead' and skip over these dead entries during iteration. </p>\n", "OwnerUserId": "3036581", "PostTypeId": "2", "Id": "28807431", "Score": "1", "CreationDate": "2015-03-02T10:24:38.480", "LastActivityDate": "2015-03-02T10:24:38.480"}, "5057053": {"ParentId": "5056973", "CommentCount": "0", "Body": "<p>Use a list when its invalidation semantics and performance characteristics match your requirements.</p>\n<p>List can insert/erase/splice anywhere in O(1), and this doesn't invalidate any iterators.  Vector is O(n) for insert/erase except at the end, and even then only for insert if size &lt; capacity; vector can't splice.  Performance is even more subtle than this, with the caching locality mentioned in another answer, for example.</p>\n", "OwnerUserId": "624206", "PostTypeId": "2", "Id": "5057053", "Score": "1", "CreationDate": "2011-02-20T12:33:18.930", "LastActivityDate": "2011-02-20T12:33:18.930"}, "5057010": {"ParentId": "5056973", "CommentCount": "1", "Body": "<p>You should use a list when you're doing a lot of deletions / insertions.</p>\n<p>Vector can be used if the total size of elements does not change a lot, and if you do some swapping.</p>\n", "OwnerUserId": "624551", "PostTypeId": "2", "Id": "5057010", "Score": "0", "CreationDate": "2011-02-20T12:24:42.167", "LastActivityDate": "2011-02-20T12:24:42.167"}});