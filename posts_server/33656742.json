post_cb({"33656742": {"CommentCount": "1", "ViewCount": "203", "CreationDate": "2015-11-11T17:53:06.977", "LastActivityDate": "2015-11-11T18:07:21.900", "Title": "C++11 backwards compatibility (conversion of null integer constant to pointer)", "AcceptedAnswerId": "33656869", "PostTypeId": "1", "Id": "33656742", "Score": "10", "Body": "<p>The C++ standard allows the implicit conversion of <strong>zero integer constant</strong> to pointer of any type.</p>\n<p>The following code is invalid, because the value <code>v</code> is not constant here:</p>\n<pre><code>float* foo()\n{\n    int v = 0;\n    return v;    // Error\n}\n</code></pre>\n<p>But the following code is correct:</p>\n<pre><code>float* foo()\n{\n    const int v = 0;\n    return v;    // Ok in C++98 mode, error in C++11 mode\n}\n</code></pre>\n<p><strong>The question is</strong>: why <code>gcc</code> and <code>clang</code> (tried different versions) compile the code correctly in c++98/03 mode but return warning/error when compiled in c++11/14 mode (<code>-std=c++11</code>)? I tried to find the changes in C++11 working draft PDF, but got no success.</p>\n<p>Intel compiler 16.0 and VS2015 compilers show no errors and warnings in both cases.</p>\n", "Tags": "<c++><c++11><g++><language-lawyer>", "OwnerUserId": "5380314", "AnswerCount": "1"}, "33656869": {"ParentId": "33656742", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>GCC and Clang behave differently with <code>-std=c++11</code> because C++11 changed the definition of a null pointer constant, and then C++14 changed it again, see Core <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#903\" rel=\"noreferrer\">DR 903</a> which changed the rules in C++14 so that only literals are null pointer constants.</p>\n<p>In C++03 4.10 [conv.ptr] said:</p>\n<blockquote>\n<p id=\"so_33656742_33656869_0\">A null pointer constant is an integral constant expression (5.19) rvalue of integer type that evaluates to zero.</p>\n</blockquote>\n<p>That allows all sorts of of expressions, as long as they are constant and evaluate to zero. Enumerations, <code>false</code>, <code>(5 - 5)</code> etc. etc. ... this used to cause lots of problems in C++03 code.</p>\n<p>In C++11 it says:</p>\n<blockquote>\n<p id=\"so_33656742_33656869_1\">A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>And in C++14 it says:</p>\n<blockquote>\n<p id=\"so_33656742_33656869_2\">A null pointer constant is an integer literal (2.14.2) with value zero or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>This is a much more restrictive rule, and makes far more sense.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-11-11T18:07:21.900", "Id": "33656869", "Score": "11", "CreationDate": "2015-11-11T18:00:28.783", "LastActivityDate": "2015-11-11T18:07:21.900"}, "bq_ids": {"n4140": {"so_33656742_33656869_2": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_33656742_33656869_2": {"section_id": 5947, "quality": 0.7272727272727273, "length": 8}, "so_33656742_33656869_1": {"section_id": 36, "quality": 0.8666666666666667, "length": 13}, "so_33656742_33656869_0": {"section_id": 36, "quality": 0.75, "length": 9}}, "n4659": {"so_33656742_33656869_2": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}}});