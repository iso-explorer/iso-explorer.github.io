post_cb({"bq_ids": {"n4140": {"so_48626987_48627208_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5962}, "so_48626987_48627208_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 5965}, "so_48626987_48627208_1": {"length": 22, "quality": 1.0, "section_id": 6665}}, "n3337": {"so_48626987_48627208_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5731}, "so_48626987_48627208_2": {"length": 34, "quality": 0.8095238095238095, "section_id": 5734}, "so_48626987_48627208_1": {"length": 22, "quality": 1.0, "section_id": 6420}}, "n4659": {"so_48626987_48627208_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7452}, "so_48626987_48627208_2": {"length": 37, "quality": 0.8809523809523809, "section_id": 7456}, "so_48626987_48627208_1": {"length": 22, "quality": 1.0, "section_id": 8140}}}, "48627168": {"Id": "48627168", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48626987_48627168_0\">However, the lambda has no capture list and it cannot have it because of the <code>+</code> that forces the conversion to a function pointer.</p>\n</blockquote>\n<p><code>+</code> does not <em>force</em> a conversion to a function pointer, but adds a conversion operator to pointer to function for you to use as an <em>option</em>. Lambda remains a lambda, with all the access privileges granted to it, i.e. it may access the same names that the member function itself may access.</p>\n", "LastActivityDate": "2018-02-05T16:33:33.447", "CommentCount": "3", "CreationDate": "2018-02-05T16:33:33.447", "ParentId": "48626987", "Score": "6", "OwnerUserId": "335858"}, "48627208": {"Id": "48627208", "PostTypeId": "2", "Body": "<p>For lambda expressions inside the member function, according to <a href=\"http://eel.is/c++draft/expr.prim.lambda.closure#2\" rel=\"nofollow noreferrer\">\u00a78.4.5.1/2 Closure types [expr.prim.lambda.closure]</a>:</p>\n<blockquote>\n<p id=\"so_48626987_48627208_0\">The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding lambda-expression.</p>\n</blockquote>\n<p>That means the lambda closure type will be declared inside the member function, i.e. a local class. And according to <a href=\"http://eel.is/c++draft/class.access#2\" rel=\"nofollow noreferrer\">\u00a714/2 Member access control [class.access]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_48626987_48627208_1\">A member of a class can also access all the names to which the class has access. <strong>A local class of a member\n  function may access the same names that the member function itself may access</strong>.</p>\n</blockquote>\n<p>That means for the lambda expression itself, it could access the <code>private</code> members of <code>S</code>, same as the member function <code>func</code>.</p>\n<p>And <a href=\"http://eel.is/c++draft/expr.prim.lambda.closure#7\" rel=\"nofollow noreferrer\">\u00a78.4.5.1/7 Closure types [expr.prim.lambda.closure]</a>:</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_48626987_48627208_2\">The closure type for a non-generic lambda-expression with no lambda-capture whose constraints (if any) are satisfied has a conversion function to pointer to function with C++ language linkage having the same parameter and return types as the closure type's function call operator. ... <strong>The value returned by this conversion function is the address of a function F that, when invoked, has the same effect as invoking the closure type's function call operator.</strong></p>\n</blockquote>\n<p>That means when the converted function pointer gets invoked the same rule applies.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2018-02-05T23:25:47.050", "Score": "15", "CreationDate": "2018-02-05T16:35:26.173", "ParentId": "48626987", "CommentCount": "3", "OwnerUserId": "3309790", "LastEditDate": "2018-02-05T23:25:47.050"}, "48626987": {"ViewCount": "787", "Body": "<p>Consider the following example:</p>\n<pre><code>#include &lt;cassert&gt;\n\nstruct S {\n    auto func() { return +[](S &amp;s) { s.x++; }; }\n    int get() { return x; }\n\nprivate:\n    int x{0};\n};\n\nint main() {\n    S s;\n    s.func()(s);\n    assert(s.get() == 1);\n}\n</code></pre>\n<p>It compiles both with G++ and clang, so I'm tempted to expect that is allowed by the standard.\nHowever, the lambda has no capture list and it cannot have it because of the <code>+</code> that forces the conversion to a function pointer. Therefore, I expected it was not allowed to access private data members of <code>S</code>.<br>\nInstead, it behaves more or less how if it was defined as a static member function.</br></p>\n<p>So far, so good. If I knew it before, I would have used this trick often to avoid writing redundant code.</p>\n<p>What I'd like to know now is where in the standard (the working draft is fine) this is defined, for I've not been able to find the section, the bullet or whatever that rules about it.<br>\nIs there any limitation for the lambda or it works <em>exactly</em> as if it was defined as a static member function?</br></p>\n", "AcceptedAnswerId": "48627208", "Title": "About lambdas, conversions to function pointers and visibility of private data members", "CreationDate": "2018-02-05T16:24:20.907", "Id": "48626987", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2018-02-05T23:25:47.050", "Score": "15", "OwnerUserId": "4987285", "Tags": "<c++><lambda><c++14><language-lawyer>", "AnswerCount": "2"}});