post_cb({"bq_ids": {"n4140": {"so_2413097_2420230_3": {"length": 10, "quality": 0.625, "section_id": 3241}}, "n3337": {"so_2413097_2420230_3": {"length": 10, "quality": 0.625, "section_id": 3114}}, "n4659": {"so_2413097_2420230_3": {"length": 9, "quality": 0.5625, "section_id": 3997}}}, "2413376": {"Id": "2413376", "PostTypeId": "2", "Body": "<p>Well, it's a bug.  The const modifiers is emitted into the metadata with the modopt custom modifier.  Unfortunately, the C++/CLI language rules do not match the CLI rules.  Chapter 7.1.1 of the CLI spec says:</p>\n<blockquote>\n<p id=\"so_2413097_2413376_0\">Custom modifiers, defined using modreq\n  (\u201crequired modifier\u201d) and modopt\n  (\u201coptional modifier\u201d), are similar to\n  custom attributes (\u00a721) except that\n  modifiers are part of a signature\n  rather than being attached to\n  adeclaration. Each modifer associates\n  a type reference with an item in the\n  signature.</p>\n<p id=\"so_2413097_2413376_1\">The CLI itself shall treat required\n  and optional modifiers in the same\n  manner. Two signatures that differ\n  only by the addition of a custom\n  modifier (required or optional) shall\n  not be considered to match. Custom\n  modifiers have no other effect on the\n  operation of the VES.</p>\n</blockquote>\n<p>So, the CLR says that Derived::Foo() is not a override, C++/CLI says it is.  The CLR wins.</p>\n<p>You could report the bug at connect.microsoft.com but it probably a waste of time.  I think this incompatibility was intentional.  They should have changed the language rules for C++/CLI but surely thought C++ compatibility to be more important.  CV modifiers are a pain anyway, there are other scenarios that are not well supported, const pointers to const for one.  This cannot be enforced at runtime anyway, the CLR has no support for it.</p>\n", "LastEditorUserId": "17034", "LastActivityDate": "2010-03-10T12:31:37.780", "Score": "8", "CreationDate": "2010-03-09T23:19:28.790", "ParentId": "2413097", "CommentCount": "13", "OwnerUserId": "17034", "LastEditDate": "2010-03-10T12:31:37.780"}, "2420230": {"Id": "2420230", "PostTypeId": "2", "Body": "<p>It's a bug, and it's not specific to C++/CLI.</p>\n<p><a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/100917/argument-const-ness-is-part-of-member-function-type-signature\" rel=\"nofollow noreferrer\">https://connect.microsoft.com/VisualStudio/feedback/details/100917/argument-const-ness-is-part-of-member-function-type-signature</a></p>\n<p>Fact is, the C++ compiler is supposed to strip off top-level const/volatile.  Only const/volatile on the pointed-to type of a pointer or reference matters.  If the compiler did that correctly, the CLR wouldn't have a say in what's going on.</p>\n<p>BTW this is the IL generated by the compiler with /clr:pure</p>\n<pre><code>.class private abstract auto ansi beforefieldinit Base\n    extends [mscorlib]System.Object\n{\n    .method public hidebysig specialname rtspecialname instance void .ctor() cil managed\n    {\n        .maxstack 1\n        L_0000: ldarg.0 \n        L_0001: call instance void [mscorlib]System.Object::.ctor()\n        L_0006: ret \n    }\n\n    .method public hidebysig newslot abstract virtual instance void Foo(int32 modopt([mscorlib]System.Runtime.CompilerServices.IsConst)) cil managed\n    {\n    }\n\n}\n\n.class private auto ansi beforefieldinit Derived\n    extends Base\n{\n    .method public hidebysig specialname rtspecialname instance void .ctor() cil managed\n    {\n        .maxstack 1\n        L_0000: ldarg.0 \n        L_0001: call instance void Base::.ctor()\n        L_0006: ret \n    }\n\n    .method public hidebysig virtual instance void Foo(int32 i) cil managed\n    {\n        .maxstack 0\n        L_0000: ret \n    }\n\n}\n</code></pre>\n<p>This definitely violates the rule James listed concerning deletion of top-level qualifiers.</p>\n<p>Further relevant sections of the C++/CLI spec:</p>\n<blockquote>\n<p id=\"so_2413097_2420230_0\">8.8.10.1 Function overriding</p>\n<p id=\"so_2413097_2420230_1\">[snip]</p>\n<ol>\n<li>A derived class function explicitly overrides a base class virtual function having the same name, parameter-type-list, and cv-qualification, by using the function modifier override, with the program being ill-formed if no such base class virtual function exists</li>\n</ol>\n<p id=\"so_2413097_2420230_2\">12.3 Declarator types</p>\n<p id=\"so_2413097_2420230_3\">The C++ Standard (\u00a78.3.5/3) is augmented, as follows:<br>\n  The resulting list of transformed parameter types and the presence or absence of the  ellipsis is the function\u2019s parameter-type-list.</br></p>\n</blockquote>\n<p>So I am led to believe that the rule on deletion of cv-qualifiers applies to C++/CLI as well, because the spec specifically calls out section 8.3.5/3 of ISO Standard C++.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2010-03-11T04:39:00.677", "Score": "3", "CreationDate": "2010-03-10T20:12:53.477", "ParentId": "2413097", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2010-03-11T04:39:00.677"}, "2413097": {"ViewCount": "2868", "Body": "<p>[All of the following was tested using Visual Studio 2008 SP1]</p>\n<p>In C++, const qualification of parameter types does not affect the type of a function (8.3.5/3:  \"Any cv-qualifier modifying a parameter type is deleted\")</p>\n<p>So, for example, in the following class hierarchy, <code>Derived::Foo</code> overrides <code>Base::Foo</code>:</p>\n<pre><code>struct Base\n{\n    virtual void Foo(const int i) { }\n};\n\nstruct Derived : Base\n{\n    virtual void Foo(int i) { }\n};\n</code></pre>\n<p>Consider a similar hierarchy in C++/CLI:</p>\n<pre><code>ref class Base abstract\n{\npublic:\n    virtual void Foo(const int) = 0;\n};\n\nref class Derived : public Base\n{\npublic:\n    virtual void Foo(int i) override { }\n};\n</code></pre>\n<p>If I then create an instance of <code>Derived</code>:</p>\n<pre><code>int main(array&lt;System::String ^&gt; ^args)\n{\n    Derived^ d = gcnew Derived;\n}\n</code></pre>\n<p>it compiles without errors or warnings.  When I run it, it throws the following exception and then terminates:</p>\n<blockquote>\n<p id=\"so_2413097_2413097_0\">An unhandled exception of type 'System.TypeLoadException' occurred in ClrVirtualTest.exe</p>\n<p id=\"so_2413097_2413097_1\">Additional information:  Method 'Foo' in type 'Derived'...does not have an implementation.</p>\n</blockquote>\n<p>That exception seems to indicate that the const qualification of the parameter <em>does</em> affect the type of the function in C++/CLI (or, at least it affects overriding in some way).  However, if I comment out the line containing the definition of <code>Derived::Foo</code>, the compiler reports the following error (on the line in <code>main</code> where the instance of <code>Derived</code> is instantiated):</p>\n<blockquote>\n<p id=\"so_2413097_2413097_2\">error C2259:  'Derived':  cannot instantiate abstract class</p>\n</blockquote>\n<p>If I add the const qualifier to the parameter of <code>Derived::Foo</code> or remove the const qualifier from the parameter of <code>Base::Foo</code>, it compiles and runs with no errors.</p>\n<p>I would think that if the const qualification of the parameter affects the type of the function, I should get this error if the const qualification of the parameter in the derived class virtual function does not match the const qualification of the parameter in the base class virtual function.</p>\n<p>If I change the type of <code>Derived::Foo</code>'s parameter from an <code>int</code> to a <code>double</code>, I get the following warning (in addition to the aforementioned error, C2259):</p>\n<blockquote>\n<p id=\"so_2413097_2413097_3\">warning C4490:  'override':  incorrect use of override specifier; 'Derived::Foo' does not match a base ref class method</p>\n</blockquote>\n<p>So, my question is, effectively, does the const qualification of function parameters affect the type of the function in C++/CLI?  If so, why does this compile and why are there no errors or warnings?  If not, why is an exception thrown?</p>\n", "AcceptedAnswerId": "2413376", "Title": "C++ vs. C++/CLI: Const qualification of virtual function parameters", "CreationDate": "2010-03-09T22:32:12.897", "Id": "2413097", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-03-09T20:21:03.977", "LastEditorUserId": "3204551", "LastActivityDate": "2015-03-09T20:21:03.977", "Score": "10", "OwnerUserId": "151292", "Tags": "<.net><visual-c++><c++-cli><virtual-functions>", "AnswerCount": "2"}});