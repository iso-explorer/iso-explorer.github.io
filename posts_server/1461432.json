post_cb({"1462103": {"ParentId": "1461432", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2009-09-22T19:27:11.377", "Score": "33", "LastEditorUserId": "12711", "LastEditDate": "2009-09-22T19:46:58.387", "Id": "1462103", "OwnerUserId": "12711", "Body": "<p>Here's what the standard says (C99 6.3.2.1/3 - Other operands - Lvalues, arrays, and function designators):</p>\n<blockquote>\n<p id=\"so_1461432_1462103_0\">Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a\n  string literal used to initialize an array, an expression that has type \u2018\u2018array of type\u2019\u2019 is\n  converted to an expression with type \u2018\u2018pointer to type\u2019\u2019 that points to the initial element of\n  the array object and is not an lvalue.</p>\n</blockquote>\n<p>This means that pretty much anytime the array name is used in an expression, it is automatically converted to a pointer to the 1st item in the array.</p>\n<p>Note that function names act in a similar way, but function pointers are used far less and in a much more specialized way that it doesn't cause nearly as much confusion as the automatic conversion of array names to pointers.</p>\n<p>The C++ standard (4.2 Array-to-pointer conversion) loosens the conversion requirement to (emphasis mine):</p>\n<blockquote>\n<p id=\"so_1461432_1462103_1\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d <strong>can</strong> be converted to an rvalue\n  of type \u201cpointer to T.\u201d</p>\n</blockquote>\n<p>So the conversion doesn't <em>have</em> to happen like it pretty much always does in C (this lets functions overload or templates match on the array type).</p>\n<p>This is also why in C you should avoid using array parameters in function prototypes/definitions (in my opinion - I'm not sure if there's any general agreement).  They cause confusion and are a fiction anyway - use pointer parameters and the confusion might not go away entirely, but at least the parameter declaration isn't lying.</p>\n", "LastActivityDate": "2009-09-22T19:46:58.387"}, "1461580": {"ParentId": "1461432", "CommentCount": "5", "CreationDate": "2009-09-22T17:55:23.120", "OwnerUserId": "25324", "PostTypeId": "2", "Id": "1461580", "Score": "7", "Body": "<p><b>Arrays, in C, have no value.</b></p>\n<p>Wherever the value of an object is expected but the object is an array, the address of its first element is used instead, with type <code>pointer to (type of array elements)</code>.</p>\n<p>In a function, all parameters are passed by value (arrays are no exception). When you pass an array in a function it \"decays into a pointer\" (sic); when you compare an array to something else, again it \"decays into a pointer\" (sic); ...</p>\n<pre><code>void foo(int arr[]);\n</code></pre>\n<p>Function foo expects the value of an array. But, in C, arrays have no value! So <code>foo</code> gets instead the address of the first element of the array.</p>\n<pre><code>int arr[5];\nint *ip = &amp;(arr[1]);\nif (arr == ip) { /* something; */ }\n</code></pre>\n<p>In the comparison above, <code>arr</code> has no value, so it becomes a pointer. It becomes a pointer to int. That pointer can be compared with the variable <code>ip</code>.</p>\n<p>In the array indexing syntax you are used to seeing, again, the arr is 'decayed to a pointer'</p>\n<pre><code>arr[42];\n/* same as *(arr + 42); */\n/* same as *(&amp;(arr[0]) + 42); */\n</code></pre>\n<p>The only times an array doesn't decay into a pointer are when it is the operand of the sizeof operator, or the &amp; operator (the 'address of' operator), or as a string literal used to initialize a character array.</p>\n", "LastActivityDate": "2009-09-22T17:55:23.120"}, "1461449": {"ParentId": "1461432", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2009-09-22T17:29:02.567", "Score": "186", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:55:18.423", "Id": "1461449", "OwnerUserId": "173019", "Body": "<p>It's said that arrays \"decay\" into pointers.  A C++ array declared as <code>int numbers [5]</code> cannot be re-pointed, i.e. you can't say <code>numbers = 0x5a5aff23</code>. More importantly the term decay signifies loss of type and dimension; <code>numbers</code> decay into <code>int*</code> by losing the dimension information (count 5) and the type is not <code>int [5]</code> any more. Look here for <a href=\"https://stackoverflow.com/questions/17752978/exception-to-array-not-decaying-into-a-pointer\">cases where the decay doesn't happen</a>.</p>\n<p>If you're passing an array by value, what you're really doing is copying a pointer - a pointer to the array's first element is copied to the parameter (whose type should also be a pointer the array element's type). This works due to array's decaying nature; once decayed, <code>sizeof</code> no longer gives the complete array's size, because it essentially becomes a pointer.  This is why it's preferred (among other reasons) to pass by reference or pointer.</p>\n<p>Three ways to pass in an array<sup>1</sup>:</p>\n<pre><code>void by_value(const T* array)   // const T array[] means the same\nvoid by_pointer(const T (*array)[U])\nvoid by_reference(const T (&amp;array)[U])\n</code></pre>\n<p>The last two will give proper <code>sizeof</code> info, while the first one won't since the array argument has decayed to be assigned to the parameter.</p>\n<p><sup>1 The constant U should be known at compile-time.</sup></p>\n", "LastActivityDate": "2015-03-10T10:02:44.357"}, "1461466": {"ParentId": "1461432", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2009-09-22T17:31:36.990", "Score": "67", "LastEditorUserId": "52963", "LastEditDate": "2016-03-23T23:04:32.613", "Id": "1461466", "OwnerUserId": "52963", "Body": "<p>Arrays are basically the same as pointers in C/C++, but not quite. Once you convert an array:</p>\n<pre><code>const int a[] = { 2, 3, 5, 7, 11 };\n</code></pre>\n<p>into a pointer (which works without casting, and therefore can happen unexpectedly in some cases):</p>\n<pre><code>const int* p = a;\n</code></pre>\n<p>you lose the ability of the <code>sizeof</code> operator to count elements in the array:</p>\n<pre><code>assert( sizeof(p) != sizeof(a) );  // sizes are not equal\n</code></pre>\n<p>This lost ability is referred to as \"decay\".</p>\n<p>For more details, check out this <a href=\"http://web.archive.org/web/20081208122434/http://www.transcendentaxis.com/dthompson/blog/archives/9\" rel=\"noreferrer\">article about array decay</a>.</p>\n", "LastActivityDate": "2016-03-23T23:04:32.613"}, "1461432": {"CommentCount": "7", "AcceptedAnswerId": "1461449", "PostTypeId": "1", "LastEditorUserId": "63550", "CreationDate": "2009-09-22T17:24:43.190", "LastActivityDate": "2016-03-23T23:04:32.613", "LastEditDate": "2015-11-04T05:35:06.383", "ViewCount": "31431", "FavoriteCount": "117", "Title": "What is array decaying?", "Id": "1461432", "Score": "245", "Body": "<p>What is decaying of an array? Is there any relation to array pointers?</p>\n", "Tags": "<c++><c><arrays><pointers>", "OwnerUserId": "177303", "AnswerCount": "7"}, "1462352": {"ParentId": "1461432", "CommentCount": "1", "CreationDate": "2009-09-22T20:21:27.960", "OwnerUserId": "134554", "PostTypeId": "2", "Id": "1462352", "Score": "19", "Body": "<p>\"Decay\" refers to the implicit conversion of an expression from an array type to a pointer type.  In most contexts, when the compiler sees an array expression it converts the type of the expression from \"N-element array of T\" to \"pointer to T\" and sets the value of the expression to the address of the first element of the array.  The exceptions to this rule are when an array is an operand of either the <code>sizeof</code> or <code>&amp;</code> operators, or the array is a string literal being used as an initializer in a declaration.  </p>\n<p>Assume the following code:</p>\n<pre><code>char a[80];\nstrcpy(a, \"This is a test\");\n</code></pre>\n<p>The expression <code>a</code> is of type \"80-element array of char\" and the expression \"This is a test\" is of type \"16-element array of char\" (in C; in C++ string literals are arrays of const char).  However, in the call to <code>strcpy()</code>, neither expression is an operand of <code>sizeof</code> or <code>&amp;</code>, so their types are implicitly converted to \"pointer to char\", and their values are set to the address of the first element in each.  What <code>strcpy()</code> receives are not arrays, but pointers, as seen in its prototype:</p>\n<pre><code>char *strcpy(char *dest, const char *src);\n</code></pre>\n<p>This is not the same thing as an array pointer.  For example:</p>\n<pre><code>char a[80];\nchar *ptr_to_first_element = a;\nchar (*ptr_to_array)[80] = &amp;a;\n</code></pre>\n<p>Both <code>ptr_to_first_element</code> and <code>ptr_to_array</code> have the same <em>value</em>; the base address of a.  However, they are different types and are treated differently, as shown below:</p>\n<pre><code>a[i] == ptr_to_first_element[i] == (*ptr_to_array)[i] != *ptr_to_array[i] != ptr_to_array[i]\n</code></pre>\n<p>Remember that the expression <code>a[i]</code> is interpreted as <code>*(a+i)</code> (which only works if the array type is converted to a pointer type), so both <code>a[i]</code> and <code>ptr_to_first_element[i]</code> work the same. The expression <code>(*ptr_to_array)[i]</code> is interpreted as <code>*(*a+i)</code>.  The expressions <code>*ptr_to_array[i]</code> and <code>ptr_to_array[i]</code> may lead to compiler warnings or errors depending on the context; they'll definitely do the wrong thing if you're expecting them to evaluate to <code>a[i]</code>.</p>\n<pre><code>sizeof a == sizeof *ptr_to_array == 80\n</code></pre>\n<p>Again, when an array is an operand of <code>sizeof</code>, it's not converted to a pointer type.  </p>\n<pre><code>sizeof *ptr_to_first_element == sizeof (char) == 1\nsizeof ptr_to_first_element == sizeof (char *) == whatever the pointer size\n                                                  is on your platform\n</code></pre>\n<p><code>ptr_to_first_element</code> is a simple pointer to char.  </p>\n", "LastActivityDate": "2009-09-22T20:21:27.960"}, "1461487": {"ParentId": "1461432", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2009-09-22T17:35:45.080", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:53.853", "Id": "1461487", "OwnerUserId": "25507", "Body": "<p>Array decaying means that, when an array is passed as a parameter to a function, it's treated identically to (\"decays to\") a pointer.</p>\n<pre><code>void do_something(int *array) {\n  // We don't know how big array is here, because it's decayed to a pointer.\n  printf(\"%i\\n\", sizeof(array));  // always prints 4 on a 32-bit machine\n}\n\nint main (int argc, char **argv) {\n    int a[10];\n    int b[20];\n    int *c;\n    printf(\"%i\\n\", sizeof(a)); //prints 40 on a 32-bit machine\n    printf(\"%i\\n\", sizeof(b)); //prints 80 on a 32-bit machine\n    printf(\"%i\\n\", sizeof(c)); //prints 4 on a 32-bit machine\n    do_something(a);\n    do_something(b);\n    do_something(c);\n}\n</code></pre>\n<p>There are two complications or exceptions to the above.</p>\n<p>First, when dealing with multidimensional arrays in C and C++, only the first dimension is lost.  This is because arrays are layed out contiguously in memory, so the compiler must know all but the first dimension to be able to calculate offsets into that block of memory.</p>\n<pre><code>void do_something(int array[][10])\n{\n    // We don't know how big the first dimension is.\n}\n\nint main(int argc, char *argv[]) {\n    int a[5][10];\n    int b[20][10];\n    do_something(a);\n    do_something(b);\n    return 0;\n}\n</code></pre>\n<p>Second, in C++, you can use templates to deduce the size of arrays.  Microsoft uses this for the C++ versions of Secure CRT functions like <a href=\"http://msdn.microsoft.com/en-us/library/td1esda9%28VS.80%29.aspx\" rel=\"nofollow noreferrer\">strcpy_s</a>, and you can use a similar trick to reliably <a href=\"https://stackoverflow.com/questions/469696/what-is-your-most-useful-c-c-snippet/470221#470221\">get the number of elements in an array</a>.</p>\n", "LastActivityDate": "2009-09-22T17:35:45.080"}, "bq_ids": {"n4140": {"so_1461432_1462103_1": {"section_id": 11, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_1461432_1462103_1": {"section_id": 8, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_1461432_1462103_1": {"section_id": 12, "quality": 0.9166666666666666, "length": 11}}}, "1461447": {"ParentId": "1461432", "CommentCount": "4", "CreationDate": "2009-09-22T17:28:58.527", "OwnerUserId": "95382", "PostTypeId": "2", "Id": "1461447", "Score": "6", "Body": "<p>It's when array rots and is being pointed at ;-)</p>\n<p>Actually, it's just that if you want to pass an array somewhere, but the pointer is passed instead (because who the hell would pass the whole array for you), people say that poor array decayed to pointer.</p>\n", "LastActivityDate": "2009-09-22T17:28:58.527"}});