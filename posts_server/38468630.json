post_cb({"38469635": {"ParentId": "38468630", "CommentCount": "1", "Body": "<p>Re</p>\n<blockquote>\n<p id=\"so_38468630_38469635_0\"><strong>\u201d</strong>  does the standard allow <code>std::vector&lt;int, A&gt;::iterator</code> be simply a typedef of <code>A::pointer</code></p>\n</blockquote>\n<p>As far as I know, yes. But not <code>std::vector&lt;bool, A&gt;</code>, because that's a specialization where a dereferenced iterator is a proxy object that accesses whatever representation is used, with the intent of supporting one bit per <code>bool</code>.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "38469635", "Score": "7", "CreationDate": "2016-07-19T22:39:06.250", "LastActivityDate": "2016-07-19T22:39:06.250"}, "38469498": {"ParentId": "38468630", "CommentCount": "18", "Body": "<blockquote>\n<p id=\"so_38468630_38469498_0\">Now the question is does the standard allow <code>std::vector&lt;int, A&gt;::iterator</code> be simply a typedef of <code>A::pointer</code>, thus making it just an <code>int*</code> for the default allocator?</p>\n</blockquote>\n<p>Not on just any implementation, I think.</p>\n<blockquote>\n<p id=\"so_38468630_38469498_1\"><strong>24.2 Iterator requirements [iterator.requirements]</strong></p>\n<p id=\"so_38468630_38469498_2\"><strong>24.2.1 In general [iterator.requirements.general]</strong></p>\n<p id=\"so_38468630_38469498_3\">11 In the following sections, <code>a</code> and <code>b</code> denote values of type <code>X</code> or <code>const X</code>, [...]</p>\n<p id=\"so_38468630_38469498_4\"><strong>24.2.7 Random access iterators [random.access.iterators]</strong></p>\n<pre>\nExpression | Return type    | Operational | Assertion/note\n           |                | semantics   | pre-/post-condition\n-----------+----------------+-------------+--------------------------------\n[...]\n-----------+----------------+-------------+--------------------------------\na &lt; b      | contextually   | b - a &gt; 0   | &lt; is a total ordering relation\n           | convertible to |             |\n           | bool           |             |\n</pre>\n</blockquote>\n<p>Note that unlike the earlier requirement on <code>-</code>, there is no precondition for <code>&lt;</code> that <code>a</code> and <code>b</code> are iterators of the same container. <code>&lt;</code> is required to form a total ordering relation for arbitrary iterators. <code>&lt;</code> is not required to form a total ordering relation for arbitrary pointers. While implementations are permitted to extend the definition of <code>&lt;</code> for raw pointer types to allow comparing unrelated pointer values, popular current real-world implementations do not do so, because such an extension would prevent some optimisation opportunities.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "38469498", "Score": "5", "CreationDate": "2016-07-19T22:24:40.800", "LastActivityDate": "2016-07-19T22:24:40.800"}, "bq_ids": {"n4140": {"so_38468630_38469498_3": {"section_id": 5565, "quality": 1.0, "length": 6}}, "n3337": {"so_38468630_38469498_3": {"section_id": 5347, "quality": 1.0, "length": 6}}, "n4659": {"so_38468630_38469498_3": {"section_id": 7012, "quality": 1.0, "length": 6}}}, "38468630": {"CommentCount": "6", "ViewCount": "990", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-07-19T21:13:21.367", "LastActivityDate": "2016-07-19T23:05:54.253", "Title": "Are super-SCARY iterators legal?", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:14:46.883", "Id": "38468630", "Score": "12", "Body": "<p>I understand that the standard allows <code>std::vector&lt;int, A&gt;</code> to have the same type of iterators for different allocators <code>A</code>. This is called <a href=\"https://stackoverflow.com/q/14391705/734069\">SCARY iterators</a>.</p>\n<p>Now the question is does the standard allow <code>std::vector&lt;int, A&gt;::iterator</code> be simply a typedef of <code>A::pointer</code>, thus making it just an <code>int*</code> for the default allocator? </p>\n<p>Or is there some (implicit) requirement for it to be a separate class type per container? If there is no such requirement then why all major implementations (including the SCARY ones) don't use this approach? It would presumably reduce compiler work even further, though now code that overloads on <code>int*</code> and <code>vector&lt;&gt;::iterator</code> will not compile.</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "277176", "AnswerCount": "2"}});