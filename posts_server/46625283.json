post_cb({"bq_ids": {"n4140": {"so_46625283_46625423_0": {"length": 20, "quality": 1.0, "section_id": 6299}}, "n3337": {"so_46625283_46625423_0": {"length": 20, "quality": 1.0, "section_id": 6056}}, "n4659": {"so_46625283_46625423_0": {"length": 20, "quality": 1.0, "section_id": 7808}}}, "46625423": {"Id": "46625423", "PostTypeId": "2", "Body": "<p>The rule in <a href=\"http://eel.is/c++draft/constraints#namespace.std-1.sentence-2\" rel=\"nofollow noreferrer\">[namespace.std]</a> is:</p>\n<blockquote>\n<p id=\"so_46625283_46625423_0\">A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>So, two criteria: \"depends on a user-defined type\" (a better term, that hopefully will be adopted, is program-defined type) and \"meets the standard library requirements for the original template.\" Your example meets the first criteria but breaks the second, so it's undefined behavior. </p>\n<p>However, if you go ahead and fill in the rest of the requirements (see <a href=\"http://eel.is/c++draft/container.requirements\" rel=\"nofollow noreferrer\">[container.requirements]</a> and <a href=\"http://eel.is/c++draft/sequence.reqmts\" rel=\"nofollow noreferrer\">[sequence.reqmts]</a> and <a href=\"http://eel.is/c++draft/vector\" rel=\"nofollow noreferrer\">[vector]</a>) to meet the second criteria, then it'll be fine. But questionable. Just write your own container, principle of least surprise and all that. When people see <code>std::vector&lt;T&gt;</code> they assume it's actually a <code>std::vector</code>. <code>std::vector&lt;bool&gt;</code> is bad enough, don't add another one. </p>\n", "LastActivityDate": "2017-10-07T21:46:47.203", "CommentCount": "2", "CreationDate": "2017-10-07T21:46:47.203", "ParentId": "46625283", "Score": "2", "OwnerUserId": "2069064"}, "46625283": {"ViewCount": "53", "Body": "<p>I am trying to get an std::vector to hold fixed-length strings without introducing indirection through a wrapper class. My idea is to have a specialization of <code>std::vector</code> for my custom type that behaves like an <code>std::vector</code> to the outside, but uses its own storage layout. Kind of like <code>std::vector&lt;bool&gt;</code>.</p>\n<p>I looked at \"<a href=\"http://en.cppreference.com/w/cpp/language/extending_std\" rel=\"nofollow noreferrer\">Extending the namespace std</a>\" and didn't find a reason why I shouldn't. Can I do the following, and if not, what type of hell am I facing?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass FixedString {};\n\nnamespace std {\n    template &lt;&gt;\n    class vector&lt;FixedString&gt; {\n    public:\n        void push_back( FixedString&amp;&amp; value ) {\n            std::cout &lt;&lt; \"Welcome to my vector. Let's play a game!\" &lt;&lt; std::endl;\n        }\n    };\n\n    // here be more vector methods.\n}\n\nint main () {\n    std::vector&lt;int&gt; a;\n    a.push_back(int{});\n\n    std::vector&lt;FixedString&gt; b;\n    b.push_back(FixedString{});\n}\n</code></pre>\n<p>Edit: I understand that there may be better ways of doing this and the discussion in the comments has helped me in understanding what's wrong with this. Still, I would like to understand if this is legal (even if undesirable) C++ code. People have hinted at [namespace.std] below, but I would like to understand which of the rules a fully specialized vector class would violate.</p>\n", "AcceptedAnswerId": "46625423", "Title": "Specializing the template of std::vector", "CreationDate": "2017-10-07T21:26:34.393", "Id": "46625283", "CommentCount": "14", "LastEditDate": "2017-10-07T21:51:02.853", "PostTypeId": "1", "LastEditorUserId": "2204581", "LastActivityDate": "2017-10-07T21:51:02.853", "Score": "0", "OwnerUserId": "2204581", "Tags": "<c++><templates><vector><stl><c++1z>", "AnswerCount": "1"}});