post_cb({"16973334": {"ParentId": "16971897", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>The main thing to keep in mind about access specifiers in C++ is that they control where a <em>name</em> can be used. It does not actually do anything to control access to objects. \"access to a member\" in the context of C++ means \"the ability to use a name\".</p>\n<p>Observe:</p>\n<pre><code>class Encapsulator {\n  protected:\n    int i;\n};\n\nstruct Gimme : Encapsulator {\n    using Encapsulator::i;\n};\n\nint main() {\n  Encapsulator e;\n  std::cout &lt;&lt; e.*&amp;Gimme::i &lt;&lt; '\\n';\n}\n</code></pre>\n<p>This, <code>e.*&amp;Gimme::i</code>, is allowed because it does not access a protected <em>member</em> at all. We are accessing the member created inside <code>Gimme</code> by the <code>using</code> declaration. That is, even though a <code>using</code> declaration does not imply any additional sub-objects in <code>Gimme</code> instances, it still creates an additional <em>member</em>. <strong><em>Members and sub-objects are not the same thing</em></strong>, and <code>Gimmie::i</code> is a distinct public member that can be used to access the same sub-objects as the protected member <code>Encapsulator::i</code>.</p>\n<hr>\n<p>Once the distinction between 'member of a class' and 'sub-object' is understood it should be clear that this is not actually a loophole or unintended failure of the contract specified by 11.4 p1.</p>\n<p>That one can create an accessible name for, or otherwise provide access to, an otherwise un-nameable object is the intended behavior even though it is different from some other languages and may be surprising.</p>\n</hr>", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2013-06-06T22:54:09.453", "Id": "16973334", "Score": "5", "CreationDate": "2013-06-06T22:32:06.343", "LastActivityDate": "2013-06-06T22:54:09.453"}, "16971961": {"ParentId": "16971897", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I have seen this technique, that I refer to as \"protected hack\", mentioned quite a few times here and elsewhere. Yes, this behavior is correct and it is indeed a legal way to circumvent protected access without resorting to any \"dirty\" hacks.</p>\n<p>When <code>m</code> is member of class <code>Base</code>, then the problem with making the <code>&amp;Derived::m</code> expression to produce a pointer of <code>Derived::*</code> type is that class member pointers are <em>contravariant</em>, not <em>covariant</em>. It would make the resultant pointers unusable with <code>Base</code> objects. For example, this code compiles</p>\n<pre><code>struct Base { int m; };\nstruct Derived : Base {};\n\nint main() {\n  int Base::*p = &amp;Derived::m; // &lt;- 1\n  Base b;\n  b.*p = 42;                  // &lt;- 2\n}\n</code></pre>\n<p>because <code>&amp;Derived::m</code> produces an <code>int Base::*</code> value. If it produced a <code>int Derived::*</code> value, the code would fail to compile at line 1. And if we attempted to fix it with </p>\n<pre><code>  int Derived::*p = &amp;Derived::m; // &lt;- 1\n</code></pre>\n<p>it would fail to compile at line 2. The only way to make it compile would be to perform a forceful cast</p>\n<pre><code>  b.*static_cast&lt;int Base::*&gt;(p) = 42; // &lt;- 2\n</code></pre>\n<p>which is not good.</p>\n<p>P.S. I agree, this is not a very convincing example (\"just use <code>&amp;Base:m</code> from the beginning and the problem is solved\"). However, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#203\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#203</a> has more info that sheds some light on why such decision was made originally. They state</p>\n<blockquote>\n<p id=\"so_16971897_16971961_0\">Notes from 04/00 meeting:</p>\n<p id=\"so_16971897_16971961_1\">The rationale for the current treatment is to permit the widest\n  possible use to be made of a given address-of-member expression. Since\n  a pointer-to-base-member can be implicitly converted to a\n  pointer-to-derived-member, making the type of the expression a\n  pointer-to-base-member allows the result to initialize or be assigned\n  to either a pointer-to-base-member or a pointer-to-derived-member.\n  Accepting this proposal would allow only the latter use.</p>\n</blockquote>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2013-06-06T21:19:44.047", "Id": "16971961", "Score": "11", "CreationDate": "2013-06-06T20:51:51.340", "LastActivityDate": "2013-06-06T21:19:44.047"}, "16971897": {"CommentCount": "10", "AcceptedAnswerId": "16971961", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-06-06T20:48:09.950", "LastActivityDate": "2013-06-06T22:54:09.453", "LastEditDate": "2017-05-23T12:14:07.677", "ViewCount": "765", "FavoriteCount": "6", "Title": "In C++11, protected means public?", "Id": "16971897", "Score": "13", "Body": "<p>Continuing something learned in <a href=\"https://stackoverflow.com/q/16971065/103167\">C++ error: base function is protected</a> ...</p>\n<p>The C++11 pointer-to-member rules effectively strip the <code>protected</code> keyword of any value, because protected members can be accessed in unrelated classes without any evil/unsafe casts.</p>\n<p>To wit:</p>\n<pre><code>class Encapsulator\n{\n  protected:\n    int i;\n  public:\n    Encapsulator(int v) : i(v) {}\n};\n\nEncapsulator f(int x) { return x + 2; }\n\n#include &lt;iostream&gt;\nint main(void)\n{\n    Encapsulator e = f(7);\n    // forbidden: std::cout &lt;&lt; e.i &lt;&lt; std::endl; because i is protected\n    // forbidden: int Encapsulator::*pi = &amp;Encapsulator::i; because i is protected\n    // forbidden: struct Gimme : Encapsulator { static int read(Encapsulator&amp; o) { return o.i; } };\n\n    // loophole:\n    struct Gimme : Encapsulator { static int Encapsulator::* it() { return &amp;Gimme::i; } };\n    int Encapsulator::*pi = Gimme::it();\n    std::cout &lt;&lt; e.*pi &lt;&lt; std::endl;\n}\n</code></pre>\n<ul>\n<li><a href=\"http://ideone.com/pEXk9W\" rel=\"nofollow noreferrer\">http://ideone.com/pEXk9W</a></li>\n<li><a href=\"http://ideone.com/kKlTvD\" rel=\"nofollow noreferrer\">http://ideone.com/kKlTvD</a></li>\n<li><a href=\"http://ideone.com/zJX5U6\" rel=\"nofollow noreferrer\">http://ideone.com/zJX5U6</a></li>\n</ul>\n<p>Is this <em>really</em> conformant behavior according to the Standard?</p>\n<p>(I consider this a defect, and claim the type of <code>&amp;Gimme::i</code> really should be <code>int Gimme::*</code> even though <code>i</code> is a member of the base class.  But I don't see anything in the Standard that makes it so, and there's a very specific example showing this.)</p>\n<hr>\n<p>I realize some people may be surprised that the third commented approach (second ideone test case) actually fails.  That's because the correct way to think about protected is not \"my derived classes have access and no one else\" but \"if you derive from me, you will have access to these inherited variables contained in your instances, and no one else will unless you grant it\".  For example, if <code>Button</code> inherits <code>Control</code>, then protected members of <code>Control</code> within a <code>Button</code> instance are accessible only to <code>Control</code>, and <code>Button</code>, and (assuming <code>Button</code> doesn't prohibit it) the actual dynamic type of the instance and any intervening bases.</p>\n<p>This loophole subverts that contract, and completely opposed the spirit of the rule 11.4p1:</p>\n<blockquote>\n<p id=\"so_16971897_16971897_0\">An additional access check beyond those described earlier in Clause 11 is applied when a non-static data member or non-static member function is a protected member of its naming class.\n  As described earlier, <strong>access to a protected member is granted because the reference occurs in a friend or member of some class <code>C</code></strong>. If the access is to form a pointer to member (5.3.1), the <em>nested-name-specifier</em> shall denote <code>C</code> or a class derived from <code>C</code>. All other accesses involve a (possibly implicit) object expression. In this case, <strong>the class of the object expression shall be <code>C</code> or a class derived from <code>C</code></strong>.</p>\n</blockquote>\n<hr>\n<p>Thanks to AndreyT for linking <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#203\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#203</a> which provides additional examples motivating a change, and calls for the issue to be brought up by the Evolution Working Group.</p>\n<hr>\n<p>Also relevant: <a href=\"http://www.gotw.ca/gotw/076.htm\" rel=\"nofollow noreferrer\">GotW 76: Uses and Abuses of Access Rights</a></p>\n</hr></hr></hr>", "Tags": "<c++><member><member-access>", "OwnerUserId": "103167", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16971897_16971897_0": {"section_id": 6695, "quality": 0.9824561403508771, "length": 56}}, "n3337": {"so_16971897_16971897_0": {"section_id": 6450, "quality": 0.9824561403508771, "length": 56}}, "n4659": {"so_16971897_16971897_0": {"section_id": 8170, "quality": 0.9824561403508771, "length": 56}}}});