post_cb({"4438350": {"ParentId": "4438281", "CommentCount": "3", "CreationDate": "2010-12-14T10:49:48.847", "OwnerUserId": "347137", "PostTypeId": "2", "Id": "4438350", "Score": "1", "Body": "<p>Yes, bar_space is hiding the original function and no, you can't make foo(5.0) callable from whithin bar_space without explicit scoping <strong>if</strong> foo(double) is defined in the global namespace.</p>\n", "LastActivityDate": "2010-12-14T10:49:48.847"}, "4438384": {"ParentId": "4438281", "CommentCount": "4", "CreationDate": "2010-12-14T10:53:37.487", "OwnerUserId": "168288", "PostTypeId": "2", "Id": "4438384", "Score": "4", "Body": "<p>In C++, there is a concept called <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8a.doc%2Flanguage%2Fref%2Fname_hiding.htm\" rel=\"nofollow\"><em>name hiding</em></a>.  Basically, a function or class name is \"hidden\" if there is a function/class of the same name in a nested scope.  This prevents the compiler from \"seeing\" the hidden name.  </p>\n<p>Section 3.3.7 of the C++ standard reads:</p>\n<blockquote>\n<p id=\"so_4438281_4438384_0\">A name can be hidden by an explicit\n  declaration of that same name in a\n  nested declarative region or derived\n  class (10.2)</p>\n</blockquote>\n<p>So, to answer your question: in your example <code>void foo(double a);</code> is <em>hidden</em> by <code>void bar_space::foo(Bar a);</code>  So you need to use the <code>::</code> scoping operator to invoke the outer function.</p>\n", "LastActivityDate": "2010-12-14T10:53:37.487"}, "4438702": {"ParentId": "4438281", "CommentCount": "1", "CreationDate": "2010-12-14T11:35:57.597", "OwnerUserId": "541875", "PostTypeId": "2", "Id": "4438702", "Score": "1", "Body": "<p>However, in your sample code you could use something like that</p>\n<pre><code>namespace bar_space \n{\n    using ::foo;\n    void baz()\n    {\n       Bar bar;\n       foo(5.0);\n       foo(bar);\n    }\n}\n</code></pre>\n", "LastActivityDate": "2010-12-14T11:35:57.597"}, "bq_ids": {"n4140": {"so_4438281_4438384_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_4438281_4438384_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_4438281_4438384_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}}}, "4438281": {"CommentCount": "3", "AcceptedAnswerId": "4438384", "CreationDate": "2010-12-14T10:41:29.260", "LastActivityDate": "2010-12-14T12:29:58.513", "PostTypeId": "1", "ViewCount": "1535", "FavoriteCount": "2", "Title": "Calling a function overloaded in several namespaces from inside one namespace", "Id": "4438281", "Score": "5", "Body": "<p>I have the following code snippet:</p>\n<pre><code>void foo(double a) {}\n\nnamespace bar_space\n{\n  struct Bar {};\n\n  void foo(Bar a) {}\n}\n</code></pre>\n<p>foo(double) is a general function from a library.\nI have my own namespace bar_space with my own struct, Bar. I would like to implement an overloading of foo() for Bar, thus making Bar more similar to the built-in types.</p>\n<p>Trouble appears when I attempt to call the original foo(double) from within the namespace:</p>\n<pre><code>namespace bar_space\n{\n  void baz()\n  {\n    foo(5.0); // error: conversion from \u2018double\u2019 to non-scalar type \u2018ssc::bar_space::Bar\u2019 requested\n  }\n}\n</code></pre>\n<p>This fails to compile on gcc on both my Fedora and Mac.</p>\n<p>Calling </p>\n<pre><code>foo(5.0)\n</code></pre>\n<p>from outside the namespace or using</p>\n<pre><code>namespace bar_space\n{\n  ::foo(5.0)\n}\n</code></pre>\n<p>works ok, but this doesnt make my new function quite as nice as I had hoped for (other developers are also working inside bar_space). </p>\n<p>Is bar_space hiding the original function? Is there a way to make foo(5.0) callable from within bar_space without explicit scoping (::)? Any help is appreciated.</p>\n", "Tags": "<c++><function-overloading>", "OwnerUserId": "541762", "AnswerCount": "3"}});