post_cb({"14361006": {"CommentCount": "1", "ViewCount": "732", "PostTypeId": "1", "ClosedDate": "2013-01-17T21:20:21.673", "LastEditorUserId": "-1", "CreationDate": "2013-01-16T14:47:33.677", "LastActivityDate": "2013-01-16T16:22:36.820", "Title": "class variables - alignment", "AcceptedAnswerId": "14361043", "LastEditDate": "2017-05-23T12:25:08.173", "Id": "14361006", "Score": "5", "Body": "<blockquote>\n<p id=\"so_14361006_14361006_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/14352373/classes-store-data-members-in-sequential-memory\">Classes store data members in sequential memory?</a> </br></p>\n</blockquote>\n<p>Just wanted to ask why the following is correct:</p>\n<pre><code>template&lt;class T&gt;\nclass Vec3 {\npublic:\n  // values\n  T x,y,z;\n\n  // returns i-th komponent (i=0,1,2) (RHS array operator)\n  const T operator[] (unsigned int i) const {\n    return *(&amp;x+i);\n  }\n}\n</code></pre>\n<p>or in other words: Why is it always guaranteed that x, y and z are always sizeof(T) units apart in memory. Can't there ever be fragmentation holes in between two of those varibles, thus letting this operator return a false value?</p>\n", "Tags": "<c++><operators>", "OwnerUserId": "1709708", "AnswerCount": "2"}, "14361043": {"ParentId": "14361006", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is <strong>not</strong> guaranteed that <code>x</code>, <code>y</code> and <code>z</code> are always <code>sizeof(T)</code> units apart in memory. There can be padding bytes added in between.<br>\nIt is left out as an implementation detail.<br>\nOnly thing guaranteed is that there will be no padding between beginning of the class/structure  and its first member for POD structures/classes. </br></br></p>\n<p>It is not guaranteed that the implementation of <code>operator[]</code> in your code will work always.</p>\n<p><strong>Reference:</strong><br>\nC++11: 9.2 Class members [class.mem]</br></p>\n<blockquote>\n<p id=\"so_14361006_14361043_0\">14) Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so\n  that later members have higher addresses within a class object. The order of allocation of non-static data\n  members with different access control is unspecified (11). <strong>Implementation alignment requirements might\n  cause two adjacent members not to be allocated immediately after each other;</strong> so might requirements for\n  space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2013-01-16T15:48:21.623", "Id": "14361043", "Score": "6", "CreationDate": "2013-01-16T14:48:43.920", "LastActivityDate": "2013-01-16T15:48:21.623"}, "bq_ids": {"n4140": {"so_14361006_14361043_0": {"section_id": 5873, "quality": 0.9423076923076923, "length": 49}}, "n3337": {"so_14361006_14361043_0": {"section_id": 5644, "quality": 0.9423076923076923, "length": 49}}, "n4659": {"so_14361006_14361043_0": {"section_id": 7356, "quality": 0.9423076923076923, "length": 49}}}, "14361357": {"ParentId": "14361006", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In order to avoid <em>fragmentation holes</em> you can control the alignment this way:</p>\n<pre><code>#ifdef compiling_with_msvc\n#pragma pack(1)\n#endif\ntemplate&lt;class T&gt;\nclass Vec3 {\npublic:\n    // values\n    T x,y,z;\n\n    // returns i-th komponent (i=0,1,2) (RHS array operator)\n    const T operator[] (unsigned int i) const {\n        return *(&amp;x+i);\n    }\n#ifdef compiling_with_gcc\n}__attribute__((packed));\n#else\n};\n#endif\n</code></pre>\n<p>If you can use a <a href=\"https://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport\" rel=\"nofollow\">C++11 compiler</a> you can control the alignment in a <a href=\"http://www.stroustrup.com/C++11FAQ.html#align\" rel=\"nofollow\">standard way</a>.</p>\n<p>But if you don't care about the memory representation of the class, think about to use an <code>union</code>:</p>\n<pre><code>template &lt;typename T&gt;\nunion Vec3\n{\n    T x, y, z;\n    struct\n    {\n        T value[3];\n    } vector;\n};\n</code></pre>\n<p>With the union, you don't have to care about the alignment in order to acces each component with <code>[]</code>:</p>\n<pre><code>Vec3&lt;unsigned int&gt; v3;\n\nv3.vector.value[0] = 1;\nv3.vector.value[1] = 2;\nv3.vector.value[2] = 3;\n</code></pre>\n", "OwnerUserId": "499359", "LastEditorUserId": "499359", "LastEditDate": "2013-01-16T16:22:36.820", "Id": "14361357", "Score": "0", "CreationDate": "2013-01-16T15:03:03.710", "LastActivityDate": "2013-01-16T16:22:36.820"}});