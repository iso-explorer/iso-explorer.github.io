post_cb({"11555950": {"CommentCount": "2", "CreationDate": "2012-07-19T07:32:45.943", "PostTypeId": "1", "AcceptedAnswerId": "11641816", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-25T02:21:46.077", "LastEditDate": "2017-05-23T12:07:16.610", "ViewCount": "781", "FavoriteCount": "4", "Title": "Distinguishing between user-defined conversion sequences by the initial standard conversion sequence", "Id": "11555950", "Score": "3", "Body": "<p>The standard appears to provide two rules for distinguishing between implicit conversion sequences that involve user-defined conversion operators:</p>\n<blockquote>\n<p id=\"so_11555950_11555950_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>13.3.3 Best viable function [over.match.best]</h3>\n<p id=\"so_11555950_11555950_1\">[...] a viable function F1 is de\ufb01ned to be a better function than another viable function\n  F2 if [...]</p>\n<ul>\n<li>the context is an initialization by user-de\ufb01ned conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type.</li>\n</ul>\n<h3>13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]</h3>\n<p id=\"so_11555950_11555950_2\">3 - Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of\n  the following rules applies: [...]</p>\n<ul>\n<li>User-de\ufb01ned conversion sequence U1 is a better conversion sequence than another user-de\ufb01ned conversion sequence U2 if they contain the same user-de\ufb01ned conversion function or constructor or aggregate\n  initialization and the second standard conversion sequence of U1 is better than the second standard\n  conversion sequence of U2.</li>\n</ul>\n</blockquote>\n<p>As I understand it, 13.3.3 allows the compiler to distinguish between <em>different user-defined conversion operators</em>, while 13.3.3.2 allows the compiler to distinguish between <em>different functions</em> (overloads of some function <code>f</code>) that each require a user-defined conversion in their arguments (see my sidebar to <a href=\"https://stackoverflow.com/questions/11545316/given-the-following-code-in-gcc-4-3-why-is-the-conversion-to-reference-calle/11545508#11545508\">Given the following code (in GCC 4.3) , why is the conversion to reference called twice?</a>).</p>\n<p>Are there any other rules that can distinguish between user-defined conversion sequences? The answer at <a href=\"https://stackoverflow.com/a/1384044/567292\">https://stackoverflow.com/a/1384044/567292</a> indicates that 13.3.3.2:3 can distinguish between user-defined conversion sequences based on the cv-qualification of the implicit object parameter (to a conversion operator) or of the single non-default parameter to a constructor or aggregate initialisation, but I don't see how that can be relevant given that that would require comparison between the first standard conversion sequences of the respective user-defined conversion sequences, which the standard doesn't appear to mention.</p>\n<p>Supposing that S1 is better than S2, where S1 is the first standard conversion sequence of U1 and S2 is the first standard conversion sequence of U2, does it follow that U1 is better than U2? In other words, is this code well-formed?</p>\n<pre><code>struct A {\n    operator int();\n    operator char() const;\n} a;\nvoid foo(double);\nint main() {\n    foo(a);\n}\n</code></pre>\n<p><a href=\"http://ideone.com/YUXog\" rel=\"nofollow noreferrer\">g++</a> (4.5.1), <a href=\"http://llvm.org/demo/index.cgi\" rel=\"nofollow noreferrer\">Clang</a> (3.0) and <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow noreferrer\">Comeau</a> (4.3.10.1) accept it, preferring the non-const-qualified <code>A::operator int()</code>, but I'd expect it to be rejected as ambiguous and thus ill-formed.  Is this a deficiency in the standard or in my understanding of it?</p>\n", "Tags": "<c++><constructor><implicit-conversion><language-lawyer><conversion-operator>", "OwnerUserId": "567292", "AnswerCount": "1"}, "11641816": {"ParentId": "11555950", "CommentCount": "3", "Body": "<p>The trick here is that converting from a class type to a non-class type doesn't actually rank any user-defined conversions as implicit conversion sequences.</p>\n<pre><code>struct A {\n    operator int();\n    operator char() const;\n} a;\nvoid foo(double);\nint main() {\n    foo(a);\n}\n</code></pre>\n<p>In the expression <code>foo(a)</code>, <code>foo</code> obviously names a non-overloaded non-member function.  The call requires copy-initializing (8.5p14) the function parameter, of type <code>double</code>, using the single expression <code>a</code>, which is an lvalue of class type <code>A</code>.</p>\n<p>Since the destination type <code>double</code> is not a cv-qualified class type but the source type <code>A</code>  is, the candidate functions are defined by section 13.3.1.5, with <code>S=A</code> and <code>T=double</code>.  Only conversion functions in class <code>A</code> and any base classes of <code>A</code> are considered.  A conversion function is in the set of candidates if:</p>\n<ul>\n<li>It is not hidden in class <code>A</code>, and</li>\n<li>It is not <code>explicit</code> (since the context is copy-initialization), and</li>\n<li>A standard conversion sequence can convert the function's return type (not including any reference qualifiers) to the destination type <code>double</code>.</li>\n</ul>\n<p>Okay, both conversion functions qualify, so the candidate functions are</p>\n<pre><code>A::operator int();        // F1\nA::operator char() const; // F2\n</code></pre>\n<p>Using the rules from 13.3.1p4, each function has the implicit object parameter as the only thing in its parameter list.  <code>F1</code>'s parameter list is \"(lvalue reference to <code>A</code>)\" and <code>F2</code>'s parameter list is \"(lvalue reference to <code>const A</code>)\".</p>\n<p>Next we check that the functions are viable (13.3.2).  Each function has one type in its parameter list, and there is one argument.  Is there an implicit conversion sequence for each argument/parameter pair?  Sure:</p>\n<ul>\n<li><code>ICS1(F1)</code>: Bind the implicit object parameter (type lvalue reference to <code>A</code>) to expression <code>a</code> (lvalue of type <code>A</code>).</li>\n<li><code>ICS1(F2)</code>: Bind the implicit object parameter (type lvalue reference to <code>const A</code>) to expression <code>a</code> (lvalue of type <code>A</code>).</li>\n</ul>\n<p>Since there's no derived-to-base conversion going on, these reference bindings are considered special cases of the identity conversion (13.3.3.1.4p1).  Yup, both functions are viable.</p>\n<p>Now we have to determine if one implicit conversion sequence is better than the other.  This falls under the fifth sub-item in the big list in 13.3.3.2p3: both are reference bindings to the same type except for top-level cv-qualifiers.  Since the referenced type for <code>ICS1(F2)</code> is more cv-qualified than the referenced type for <code>ICS1(F1)</code>, <code>ICS1(F1)</code> is better than <code>ICS1(F2)</code>.</p>\n<p>Therefore <code>F1</code>, or <code>A::operator int()</code>, is the most viable function.  And no user-defined conversions (with the strict definition of a type of ICS composed of SCS + (converting constructor or conversion function) + SCS) were even to be compared.</p>\n<p>Now if <code>foo</code> were overloaded, user-defined conversions on the argument <code>a</code> would need to be compared.  So then the user-defined conversion (identity + <code>A::operator int()</code> + <code>int</code> to <code>double</code>) would be compared to other implicit conversion sequences.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "11641816", "Score": "6", "CreationDate": "2012-07-25T02:21:46.077", "LastActivityDate": "2012-07-25T02:21:46.077"}, "bq_ids": {"n4140": {"so_11555950_11555950_1": {"section_id": 603, "quality": 0.7777777777777778, "length": 7}, "so_11555950_11555950_2": {"section_id": 639, "quality": 1.0, "length": 13}}, "n3337": {"so_11555950_11555950_1": {"section_id": 593, "quality": 0.7777777777777778, "length": 7}, "so_11555950_11555950_2": {"section_id": 629, "quality": 1.0, "length": 13}}, "n4659": {"so_11555950_11555950_1": {"section_id": 629, "quality": 0.7777777777777778, "length": 7}, "so_11555950_11555950_2": {"section_id": 667, "quality": 1.0, "length": 13}}}});