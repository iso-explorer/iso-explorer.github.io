post_cb({"31847672": {"ParentId": "31847540", "CommentCount": "0", "CreationDate": "2015-08-06T05:43:58.150", "OwnerUserId": "4672588", "PostTypeId": "2", "Id": "31847672", "Score": "4", "Body": "<p>After <code>b.reset();</code>, <code>b</code> is <em>empty</em> (i.e. does not point to any object). </p>\n<p>According to the standard (quoted from N4527 \u00a720.8.2.2.5[util.smartptr.shared.obs])</p>\n<blockquote>\n<pre><code>long use_count() const noexcept;\n</code></pre>\n<p id=\"so_31847540_31847672_0\">7 Returns: the number of <code>shared_ptr</code> objects, <code>*this</code> included, that <em>share ownership</em> with <code>*this</code>, <strong>or <code>0</code>\n  when <code>*this</code> is <em>empty</em></strong>.</p>\n</blockquote>\n", "LastActivityDate": "2015-08-06T05:43:58.150"}, "31847540": {"CommentCount": "2", "ViewCount": "179", "PostTypeId": "1", "LastEditorUserId": "4672588", "CreationDate": "2015-08-06T05:34:00.003", "LastActivityDate": "2017-05-15T00:54:18.243", "Title": "understanding use_count with shared_ptr", "AcceptedAnswerId": "31847672", "LastEditDate": "2017-05-15T00:54:18.243", "Id": "31847540", "Score": "1", "Body": "<p>I came up with the following example</p>\n<pre><code>std::shared_ptr&lt;foo&gt; a(new foo());\n{\n    std::shared_ptr&lt;foo&gt; b = a;\n    std::cout &lt;&lt; \"before\" &lt;&lt; b.use_count() &lt;&lt; \"\\n\"; //returns 2\n    b.reset();\n    std::cout &lt;&lt; \"after\" &lt;&lt; b.use_count() &lt;&lt; \"\\n\";  //returns 0\n} \nstd::cout &lt;&lt; \"Finished\\n\";\n</code></pre>\n<p>Now in the above code the second <code>use_count</code> statement returns zero.\nIn that case isnt the destructor suppose to be called before printing out <code>\"Finished\"</code>. Why is use_count in the second statement printing 0 ?\nI read that the definition of use_count is:</p>\n<blockquote>\n<p id=\"so_31847540_31847540_0\">Returns the number of shared_ptr objects that share ownership over the\n  same pointer as this object (including it).</p>\n</blockquote>\n<p>If I did a <code>reset()</code> before use count that simply means that its reference count decreased by 1. Please correct me If I am wrong.</p>\n<p>Here is my understanding of what is going on please correct me if I am wrong</p>\n<pre><code>std::shared_ptr&lt;foo&gt; a(new foo());   //reference count is 1\n{\n    std::shared_ptr&lt;foo&gt; b = a;      //reference count becomes 2\n    std::cout &lt;&lt; \"before\" &lt;&lt; b.use_count() &lt;&lt; \"\\n\"; //returns 2 //OK this I understand\n    b.reset(); //b smart pointer gives up its reference count so now it should be 1.\n    std::cout &lt;&lt; \"after\" &lt;&lt; b.use_count() &lt;&lt; \"\\n\";  //This should be 1 why is it 0 ?\n} \nstd::cout &lt;&lt; \"Finished\\n\";\n</code></pre>\n<p>So my question is why is <code>b.use_count()</code> returning 0 ?  </p>\n", "Tags": "<c++><c++11><shared-ptr>", "OwnerUserId": "990502", "AnswerCount": "2"}, "31847695": {"ParentId": "31847540", "CommentCount": "0", "CreationDate": "2015-08-06T05:45:27.697", "OwnerUserId": "5162155", "PostTypeId": "2", "Id": "31847695", "Score": "1", "Body": "<p>A shared pointer is a concept in C++ where you can have multiple pointers to an object in different scopes and only until the last scope returns your share pointer will be invalid, a unique pointer can only be passed to a function using std::move() because of it's definition, a unique pointer implies single ownership on that object that is being pointed to. Now since you have a share_ptr a(new foo()), and then you assign that to b, once reset is called on that b shared_ptr type, b isn't valid and therefore returns zero, however if you do the operation use_count() on a, you will get a result of 1 after reseting b.</p>\n", "LastActivityDate": "2015-08-06T05:45:27.697"}, "bq_ids": {"n4140": {"so_31847540_31847672_0": {"section_id": 4432, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_31847540_31847672_0": {"section_id": 4269, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_31847540_31847672_0": {"section_id": 5696, "quality": 0.8888888888888888, "length": 8}}}});