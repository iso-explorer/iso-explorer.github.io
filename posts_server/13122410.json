post_cb({"13122482": {"Id": "13122482", "PostTypeId": "2", "Body": "<p>Notice that <code>369 - 256 == 113</code>.</p>\n<p>4.7 Integral conversions, paragraphs 2 &amp; 3:</p>\n<blockquote>\n<p id=\"so_13122410_13122482_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2^n where n is the number of bits used to represent the unsigned type).</p>\n<p id=\"so_13122410_13122482_1\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>But whether <code>char</code> means the same as <code>unsigned char</code> or <code>signed char</code> is also implementation-defined.</p>\n<p>So this behavior does depend on the compiler, although most will do it this way.</p>\n", "LastActivityDate": "2012-10-29T13:22:30.633", "CommentCount": "1", "CreationDate": "2012-10-29T13:22:30.633", "ParentId": "13122410", "Score": "5", "OwnerUserId": "459640"}, "bq_ids": {"n4140": {"so_13122410_13122482_0": {"length": 18, "quality": 1.0, "section_id": 31}, "so_13122410_13122595_1": {"length": 12, "quality": 1.0, "section_id": 7210}, "so_13122410_13122482_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}, "so_13122410_13122595_3": {"length": 7, "quality": 0.875, "section_id": 7210}}, "n3337": {"so_13122410_13122482_0": {"length": 18, "quality": 1.0, "section_id": 28}, "so_13122410_13122595_1": {"length": 12, "quality": 1.0, "section_id": 6954}, "so_13122410_13122595_3": {"length": 7, "quality": 0.875, "section_id": 6954}, "so_13122410_13122482_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}}, "n4659": {"so_13122410_13122482_0": {"length": 18, "quality": 1.0, "section_id": 31}, "so_13122410_13122595_1": {"length": 12, "quality": 1.0, "section_id": 8719}, "so_13122410_13122595_3": {"length": 7, "quality": 0.875, "section_id": 8719}, "so_13122410_13122482_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "13122445": {"Id": "13122445", "PostTypeId": "2", "Body": "<p>It overflows. 369 - 256 = 113.</p>\n", "LastActivityDate": "2012-10-29T13:19:39.343", "CommentCount": "4", "CreationDate": "2012-10-29T13:19:39.343", "ParentId": "13122410", "Score": "2", "OwnerUserId": "361535"}, "13122410": {"ViewCount": "149", "Body": "<p>As we all know, a char is 8 bit so it can store values from 0 to 255,</p>\n<p>if I initialize a char with a greater value like 369, I get the same binary pattern than 113\ni.e:01110001 under MSVC12</p>\n<p>Is it a standard, or is it undefined behavior ?</p>\n", "AcceptedAnswerId": "13122482", "Title": "set a char equal to 369 give the same binary pattern than 113 is UB behavior?", "CreationDate": "2012-10-29T13:16:45.600", "Id": "13122410", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-10-29T13:32:25.623", "Score": "2", "OwnerUserId": "619570", "Tags": "<c++><binary>", "AnswerCount": "4"}, "13122595": {"Id": "13122595", "PostTypeId": "2", "Body": "<p>By standard <code>char</code> size is not necessary 8 bits and can be both signed or unsigned, so it's implementation-defined.</p>\n<p>Quote from C++11 standard:</p>\n<blockquote>\n<p id=\"so_13122410_13122595_0\"><strong>3.9.1 Fundamental types [basic.fundamental]</strong></p>\n<p id=\"so_13122410_13122595_1\">Objects declared as characters (char) shall be large enough to store\n  any member of the implementation\u2019s basic character set.</p>\n<p id=\"so_13122410_13122595_2\">...</p>\n<p id=\"so_13122410_13122595_3\">It is implementation-defined whether a char object can hold negative values.</p>\n</blockquote>\n", "LastActivityDate": "2012-10-29T13:29:39.420", "CommentCount": "0", "CreationDate": "2012-10-29T13:29:39.420", "ParentId": "13122410", "Score": "3", "OwnerUserId": "1599260"}, "13122556": {"Id": "13122556", "PostTypeId": "2", "Body": "<p>A <code>char</code> is not necessarily 8 bit. It can be any number of bits, depending on the platform. Even if on your platform <code>char</code> is an 8-bit type, it still does not mean that its range is <code>0..255</code>. The type can be signed, meaning that its range will be <code>-128..+127</code> (assuming 2's complement representation).</p>\n<p>If on your platform type char happens to be 8 bit and unsigned, then this behavior is guaranteed. Unsigned integer types follow the rules of modulo arithmetic. <code>369</code> is guaranteed to be truncated modulo <code>256</code> and produce <code>113</code>. </p>\n<p>If on your platform type char is 8 bit and signed, then the behavior is implementation-defined.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2012-10-29T13:32:25.623", "Score": "2", "CreationDate": "2012-10-29T13:26:49.887", "ParentId": "13122410", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2012-10-29T13:32:25.623"}});