post_cb({"bq_ids": {"n4140": {"so_48058545_48060029_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 5879}, "so_48058545_48060029_0": {"length": 15, "quality": 1.0, "section_id": 5879}, "so_48058545_48060029_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5768}, "so_48058545_48060029_2": {"length": 39, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_48058545_48060029_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 5650}, "so_48058545_48060029_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 5621}, "so_48058545_48060029_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 5541}, "so_48058545_48060029_2": {"length": 39, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_48058545_48060029_0": {"length": 15, "quality": 1.0, "section_id": 7363}, "so_48058545_48062024_1": {"length": 26, "quality": 1.0, "section_id": 7362}, "so_48058545_48060029_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 7363}, "so_48058545_48060029_2": {"length": 39, "quality": 1.0, "section_id": 8748}, "so_48058545_48060029_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 7225}, "so_48058545_48062024_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 7359}}}, "48058545": {"ViewCount": "259", "Body": "<p>Can I put a <code>T</code> and a wrapped <code>T</code> in an <code>union</code> and inspect them as I like?</p>\n<pre><code>union Example {\n    T value;\n    struct Wrapped { \n       T wrapped;\n    } wrapper;\n};\n</code></pre>\n<pre><code>// for simplicity T = int\n\nExample ex;\nex.value = 12;\ncout &lt;&lt; ex.wrapper.wrapped; // ?\n</code></pre>\n<p>The C++11 standards only guarantee save inspection of the common initial sequence, but <code>value</code> isn't a <code>struct</code>. I <em>guess</em> the answer is <strong>no</strong>, since <a href=\"https://stackoverflow.com/questions/46425250/does-a-phantom-type-have-the-same-alignment-as-the-original-one\">wrapped types aren't even guaranteed to be memory compatible to their unwrapped counterpart</a> and <a href=\"https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-and-undefined-behavior\">accessing inactive members is only well-defined on common initial sequences</a>.</p>\n", "Title": "Are there any guarantees for unions that contain a wrapped type and the type itself?", "CreationDate": "2018-01-02T09:37:09.310", "LastActivityDate": "2018-01-02T13:42:42.463", "CommentCount": "0", "PostTypeId": "1", "Id": "48058545", "Score": "9", "OwnerUserId": "1139697", "Tags": "<c++><struct><types><language-lawyer><unions>", "AnswerCount": "3"}, "48059275": {"Id": "48059275", "PostTypeId": "2", "Body": "<p>Union behavior is undefined when accessing a member that wasn't the last one written to.  So no, you can't depend on this behavior.</p>\n<p>It's identical in principle to the idea of having a union to extract specific bytes from an integer; but with additional risk of the fact that you're now depending on the compiler not adding any padding in your struct.  See <a href=\"https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-and-undefined-behavior\">Accessing inactive union member and undefined behavior?</a> for more details.</p>\n", "LastActivityDate": "2018-01-02T10:26:49.327", "Score": "-1", "CreationDate": "2018-01-02T10:26:49.327", "ParentId": "48058545", "CommentCount": "5", "OwnerUserId": "6387170"}, "48060029": {"Id": "48060029", "PostTypeId": "2", "Body": "<p>It should work because  both <code>Example</code> and <code>Wrapped</code> are <em>standard layout</em> classes, and C++14 standard has enough requirements to guarantee that in that case <code>value</code> and <code>wrapper.wrapped</code> are located at the same address. Draft n4296 says in 9.2 Class members [class.mem] \u00a720:</p>\n<blockquote>\n<p id=\"so_48058545_48060029_0\">If a standard-layout class object has any non-static data members, its address is the same as the address\n  of its first non-static data member.</p>\n</blockquote>\n<p>A note even says:</p>\n<blockquote>\n<p id=\"so_48058545_48060029_1\">[ Note: There might therefore be unnamed padding within a standard-layout struct\n  object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>That means that you at least respect the <em>strict aliasing rule</em> from 3.10 Lvalues and rvalues [basic.lval] \u00a710</p>\n<blockquote>\n<p id=\"so_48058545_48060029_2\">If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined\n  <br/>  \u2014 the dynamic type of the object,<br/>...<br/>\n  \u2014 an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic\n  data members (including, recursively, an element or non-static data member of a subaggregate\n  or contained union),</p>\n</blockquote>\n<p>So this is perfectly defined:</p>\n<pre><code>cout &lt;&lt; *(&amp;ex.wrapper.wrapped) &lt;&lt; endl\n</code></pre>\n<p>because <code>&amp;ex.wrapper.wrapped</code> is required to be the same as <code>&amp;ex.value</code> and the pointed object has the correct type.\n.\nBut as the standard is explicit only for <em>common subsequence</em>. So my understanding is <code>cout &lt;&lt; ex.wrapper.wrapped &lt;&lt; endl</code> invokes undefined behaviour, because of a note in 1.3.24 [defns.undefined] about \nundefined behavior\nsays (emphasize mine):</p>\n<blockquote>\n<p id=\"so_48058545_48060029_3\">Undefined behavior may be expected when this International Standard <strong>omits any explicit definition</strong> of\n  behavior...</p>\n</blockquote>\n<p>TL/DR: I would bet a coin that most if not all common implementation will accept it, but because of the note from 1.3.24 [defns.undefined], I would never use that in production code but would use <code>*(&amp;ex.wrapper.wrapped)</code> instead.</p>\n<hr>\n<p>In the more recent draft n4659 for C++17, the relevant notion is <em>inter-convertibility</em> ([basic.compound] \u00a74). </p>\n</hr>", "LastEditorUserId": "3545273", "LastActivityDate": "2018-01-02T13:42:42.463", "Score": "-1", "CreationDate": "2018-01-02T11:20:15.613", "ParentId": "48058545", "CommentCount": "12", "OwnerUserId": "3545273", "LastEditDate": "2018-01-02T13:42:42.463"}, "48062024": {"Id": "48062024", "PostTypeId": "2", "Body": "<p>I believe this is undefined behavior.</p>\n<p><a href=\"http://eel.is/c++draft/class#mem-21\" rel=\"nofollow noreferrer\">[class.mem]</a> gives us:</p>\n<blockquote>\n<p id=\"so_48058545_48062024_0\">The <em>common initial sequence</em> of two standard-layout struct types is the longest sequence of non-static data members and bit-fields in declaration order, starting with the first such entity in each of the structs, such that corresponding entities have layout-compatible types and either neither entity is a bit-field or both are bit-fields with the same width. [...]</p>\n<p id=\"so_48058545_48062024_1\">In a standard-layout union with an active member of struct type <code>T1</code>, it is permitted to read a non-static data member <code>m</code> of another union member of struct type <code>T2</code> provided m is part of the common initial sequence of <code>T1</code> and <code>T2</code>; the behavior is as if the corresponding member of <code>T1</code> were nominated.</p>\n</blockquote>\n<p>If <code>T</code> isn't a standard layout struct type, this is clearly undefined behavior. (Note that <code>int</code> is not a standard layout struct type, as it's not a class type at all).</p>\n<p>But even for standard layout struct types, what constitutes a \"common initial sequence\" is based strictly on <em>non-static data members</em>. That is, <code>T</code> and <code>struct { T val; }</code> do not have a common initial sequence - there are no data members in common at all! </p>\n<p>Hence, here:</p>\n<pre><code>template &lt;typename T&gt;\nunion Example {\n    T value;\n    struct Wrapped { \n       T wrapped;\n    } wrapper;\n};\n\n\nExample&lt;int&gt; ex;\nex.value = 12;\ncout &lt;&lt; ex.wrapper.wrapped; // (*)\n</code></pre>\n<p>you're accessing an inactive member of the union. That's undefined. </p>\n", "LastActivityDate": "2018-01-02T13:36:40.333", "Score": "3", "CreationDate": "2018-01-02T13:36:40.333", "ParentId": "48058545", "CommentCount": "0", "OwnerUserId": "2069064"}});