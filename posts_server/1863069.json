post_cb({"1863093": {"ParentId": "1863069", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>For types for which such cast is permitted (e.g. if <code>T1</code> is a POD-type and <code>T2</code> is <code>unsigned char</code>), the approach with <code>static_cast</code> is well-defined by the Standard.</p>\n<p>On the other hand, <code>reinterpret_cast</code> is entirely implementation-defined - the only guarantee that you get for it is that you can cast a pointer type to any other pointer type and then back, and you'll get the original value; and also, you can cast a pointer type to an integral type large enough to hold a pointer value (which varies depending on implementation, and needs not exist at all), and then cast it back, and you'll get the original value.</p>\n<p>To be more specific, I'll just quote the relevant parts of the Standard, highlighting important parts:</p>\n<p>5.2.10[expr.reinterpret.cast]:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_0\">The mapping performed by reinterpret_cast is <strong>implementation-defined</strong>. [Note: it might, or might not, produce a representation different from the original value.] ... A pointer to an object can be explicitly converted to a pointer to an object of different type.) Except that converting an rvalue of type \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, <strong>the result of such a pointer conversion is unspecified</strong>.</p>\n</blockquote>\n<p>So something like this:</p>\n<pre><code>struct pod_t { int x; };\npod_t pod;\nchar* p = reinterpret_cast&lt;char*&gt;(&amp;pod);\nmemset(p, 0, sizeof pod);\n</code></pre>\n<p>is effectively unspecified.</p>\n<p>Explaining why <code>static_cast</code> works is a bit more tricky. Here's the above code rewritten to use <code>static_cast</code> which I believe is guaranteed to always work as intended by the Standard:</p>\n<pre><code>struct pod_t { int x; };\npod_t pod;\nchar* p = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;pod));\nmemset(p, 0, sizeof pod);\n</code></pre>\n<p>Again, let me quote the sections of the Standard that, together, lead me to conclude that the above should be portable:</p>\n<p>3.9[basic.types]:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_1\">For any object (other than a base-class subobject) of POD type T, whether or not the object holds a valid value of type T, the underlying bytes (1.7) making up the object can be copied into an array of char or unsigned char. If the content of the array of char or unsigned char is copied back into the object, the object shall subsequently hold its original value.</p>\n<p id=\"so_1863069_1863093_2\">The object representation of an object of type T is the sequence of N unsigned char <strong>objects</strong> taken up by the object of type T, where N equals sizeof(T).</p>\n</blockquote>\n<p>3.9.2[basic.compound]:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_3\">Objects of cv-qualified (3.9.3) or cv-unqualified type <code>void*</code> (pointer to void), can be used to point to objects of unknown type. A <code>void*</code> shall be able to hold any object pointer. <strong>A cv-qualified or cv-unqualified (3.9.3) <code>void*</code> shall have the same representation and alignment requirements as a cv-qualified or cv-unqualified <code>char*</code></strong>.</p>\n</blockquote>\n<p>3.10[basic.lval]:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_4\">If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is undefined):</p>\n<ul>\n<li>...</li>\n<li><strong>a char or unsigned char type</strong>.</li>\n</ul>\n</blockquote>\n<p>4.10[conv.ptr]:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_5\">An rvalue of type \u201cpointer to cv T,\u201d where T is an object type, can be converted to an rvalue of type \u201cpointer to cv void.\u201d The result of converting a \u201cpointer to cv T\u201d to a \u201cpointer to cv void\u201d points to the start of the storage location where the object of type T resides, as if the object is a most derived object (1.8) of type T (that is, not a base class subobject).</p>\n</blockquote>\n<p>5.2.9[expr.static.cast]:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_6\">The inverse of any standard conversion sequence (clause 4), other than the lvalue-to-rvalue (4.1), array-topointer (4.2), function-to-pointer (4.3), and boolean (4.12) conversions, can be performed explicitly using static_cast.</p>\n</blockquote>\n<p><strong>[EDIT]</strong> On the other hand, we have this gem:</p>\n<p>9.2[class.mem]/17:</p>\n<blockquote>\n<p id=\"so_1863069_1863093_7\">A pointer to a POD-struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [Note: There might <strong>therefore</strong> be unnamed padding within a POD-struct object, but not at its beginning, as necessary to achieve appropriate alignment. ]</p>\n</blockquote>\n<p>which seems to imply that <code>reinterpret_cast</code> between pointers somehow implies \"same address\". Go figure. </p>\n", "OwnerUserId": "111335", "LastEditorUserId": "111335", "LastEditDate": "2009-12-07T22:11:33.310", "Id": "1863093", "Score": "23", "CreationDate": "2009-12-07T21:40:00.600", "LastActivityDate": "2009-12-07T22:11:33.310"}, "8486111": {"ParentId": "1863069", "CommentCount": "0", "Body": "<p>There is not the slightest doubt that the intent is that both forms are well defined, but the wording fails to capture that.</p>\n<p>Both forms will work in practice.</p>\n<p><code>reinterpret_cast</code> is more explicit about the intent and should be preferred.</p>\n", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "8486111", "Score": "6", "CreationDate": "2011-12-13T08:17:49.853", "LastActivityDate": "2011-12-13T08:17:49.853"}, "1863069": {"CommentCount": "5", "AcceptedAnswerId": "1863093", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2009-12-07T21:36:30.750", "LastActivityDate": "2011-12-13T17:59:21.760", "LastEditDate": "2011-12-13T08:06:36.633", "ViewCount": "4558", "FavoriteCount": "15", "Title": "casting via void* instead of using reinterpret_cast", "Id": "1863069", "Score": "34", "Body": "<p>I'm reading a book and I found that <code>reinterpret_cast</code> should not be used directly, but rather casting to void* in combination with <code>static_cast</code>:</p>\n<pre><code>T1 * p1=...\nvoid *pv=p1;\nT2 * p2= static_cast&lt;T2*&gt;(pv);\n</code></pre>\n<p>instead of:</p>\n<pre><code>T1 * p1=...\nT2 * p2= reinterpret_cast&lt;T2*&gt;(p1);\n</code></pre>\n<p>However, I can't find an explanation why is this better than the direct cast. I would very appreciate if someone can give me an explanation or point me to the answer.</p>\n<p>Thanks in advance</p>\n<p>p.s. I know what is reinterpret_cast used for, but I never saw that is used in this way</p>\n", "Tags": "<c++><casting><void-pointers><language-lawyer><reinterpret-cast>", "OwnerUserId": "116622", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_1863069_1863093_2": {"section_id": 7202, "quality": 0.8666666666666667, "length": 13}, "so_1863069_1863093_4": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}, "so_1863069_1863093_3": {"section_id": 7224, "quality": 0.6, "length": 18}, "so_1863069_1863093_6": {"section_id": 6033, "quality": 0.6666666666666666, "length": 12}, "so_1863069_1863093_1": {"section_id": 7200, "quality": 0.95, "length": 38}, "so_1863069_1863093_0": {"section_id": 6045, "quality": 0.5490196078431373, "length": 28}}, "n3337": {"so_1863069_1863093_2": {"section_id": 6946, "quality": 0.8666666666666667, "length": 13}, "so_1863069_1863093_4": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}, "so_1863069_1863093_3": {"section_id": 6968, "quality": 0.6, "length": 18}, "so_1863069_1863093_5": {"section_id": 37, "quality": 0.9117647058823529, "length": 31}, "so_1863069_1863093_6": {"section_id": 5801, "quality": 0.6666666666666666, "length": 12}, "so_1863069_1863093_1": {"section_id": 6944, "quality": 0.95, "length": 38}, "so_1863069_1863093_7": {"section_id": 5650, "quality": 0.9117647058823529, "length": 31}, "so_1863069_1863093_0": {"section_id": 5814, "quality": 0.6470588235294118, "length": 33}}, "n4659": {"so_1863069_1863093_2": {"section_id": 8711, "quality": 0.8666666666666667, "length": 13}, "so_1863069_1863093_4": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}, "so_1863069_1863093_3": {"section_id": 8734, "quality": 0.5333333333333333, "length": 16}, "so_1863069_1863093_6": {"section_id": 7532, "quality": 0.6666666666666666, "length": 12}, "so_1863069_1863093_1": {"section_id": 8709, "quality": 0.875, "length": 35}, "so_1863069_1863093_0": {"section_id": 7544, "quality": 0.5490196078431373, "length": 28}}}, "1863915": {"ParentId": "1863069", "CommentCount": "1", "Body": "<p>The real reason this is so is because of how C++ defines inheritance, and because of member pointers.</p>\n<p>With C, pointer is pretty much just an address, as it should be. In C++ it has to be more complex because of some of its features.</p>\n<p>Member pointers are really an offset into a class, so casting them is always a disaster using C style.</p>\n<p>If you have multiply inherited two virtual objects that also have some concrete parts, that's also a disaster for C style. This is the case in multiple inheritance that causes all the problems, though, so you should not ever want to use this anyway.</p>\n<p>Really hopefully you never use these cases in the first place. Also, if you are casting a lot that's another sign you are messing up in in your design.</p>\n<p>The only time I end up casting is with the primitives in areas C++ decides are not the same but where obviously they have to be. For actual objects, any time you want to cast something, start to question your design because you should be 'programming to the interface' most of the time. Of course, you can't change how 3rd party APIs work so you don't always have much choice.</p>\n", "OwnerUserId": "204739", "PostTypeId": "2", "Id": "1863915", "Score": "3", "CreationDate": "2009-12-08T01:03:56.903", "LastActivityDate": "2009-12-08T01:03:56.903"}});