post_cb({"2307021": {"ParentId": "2306587", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From 1.9 \"Program execution:</p>\n<blockquote>\n<p id=\"so_2306587_2307021_0\">conforming implementations are required to emulate (only) the observable behavior of the abstract machine</p>\n</blockquote>\n<p>and in an informational footnote:</p>\n<blockquote>\n<p id=\"so_2306587_2307021_1\">This provision is sometimes called the \u201cas-if\u201d rule, because an implementation is free to disregard any requirement of this International Standard as long as the result is as if the requirement had been obeyed, as far as can be determined from the observable behavior of the program.  For instance, an actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no side effects affecting the observable behavior of the program are produced.</p>\n</blockquote>\n<p>The standard does specifically note that the \"as-if\" requirement is binding on a replacement version of the nothrow version of <code>operator new()</code>.  However, as I read it, that requirement would fall to the programmer overriding <code>operator new()</code> not the compiler.  The flip side of this responsibility is that I think the standard pretty much requires the default implementation of the nothrow <code>operator new()</code> provided by the library must do something along the lines of calling the throwing <code>new</code> in a try/catch and return 0 if <code>std::bad_alloc</code> is caught.</p>\n<p>Where the \"as if rule\" could come in to play here is if the compiler/linker/whatever were smart enough to figure out that when the default throwing <code>new()</code> was in being used, the default non-throwing <code>new()</code> could take the shortcut, but if the default throwing <code>new()</code> was overridden, the default non-throwing <code>new()</code> would have to act differently.  I'm sure this is technically possible for an implementation (even if you probably can't express it in standard C++). I'd be surprised if there was ever an implementation that did this.</p>\n<p>I might be reading too much into the requirement, but I think that's what can be inferred.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-02-21T22:45:19.580", "Id": "2307021", "Score": "7", "CreationDate": "2010-02-21T18:57:48.547", "LastActivityDate": "2010-02-21T22:45:19.580"}, "2306587": {"CommentCount": "2", "AcceptedAnswerId": "2307021", "PostTypeId": "1", "LastEditorUserId": "1459996", "CreationDate": "2010-02-21T16:52:29.187", "LastActivityDate": "2012-06-23T02:42:58.350", "LastEditDate": "2012-06-23T02:42:58.350", "ViewCount": "567", "FavoriteCount": "1", "Title": "\"as if\" in language standards", "Id": "2306587", "Score": "13", "Body": "<p>What is the exact meaning of the phrase \"as if\" in the standard and how does it work when a user can modify individual parts of the behavior.</p>\n<p>The question is in regards to the C++ standard when talking about the nothrow version of <code>operator new</code>.  18.4.1.1/7 reads (my emphasis):</p>\n<blockquote>\n<p id=\"so_2306587_2306587_0\">This nothrow version of operator new returns a pointer obtained <strong>as if</strong> acquired from the ordinary version.</p>\n</blockquote>\n<p>My understanding is that \"as if\" does not require a specific implementation as long as the behavior is appropriate.  So if <code>operator new</code> was implemented like this (I know this is not a compliant implementation as there is no loop or use of the new_handler; but I'm shortening that to focus on my issue):</p>\n<pre><code>// NOTE - not fully compliant - for illustration purposes only.\nvoid *operator new(std::size_t s)\n{\n    void *p = malloc(s);\n    if (p == 0)\n        throw std::bad_alloc();\n    return p;\n}\n</code></pre>\n<p>Then it would be legal to write the nothrow version like this:</p>\n<pre><code>// NOTE - not fully compliant - for illustration purposes only.\nvoid *operator new(std::size_t s, const std::nothrow_t &amp;nt)\n{\n    return malloc(s);\n}\n</code></pre>\n<p>But let's say a program replaces <code>operator new</code> to use some other allocator.  Does \"as if\" mean the compiler has to automatically change the behavior of the nothrow version to use this other allocator?  Is the developer required to replace both the plain and nothrow versions?</p>\n", "Tags": "<c++><standards><standards-compliance>", "OwnerUserId": "29809", "AnswerCount": "3"}, "2306677": {"ParentId": "2306587", "CommentCount": "2", "Body": "<p>The developer <strong>should</strong> replace both the plain and nothrow versions.  Check out this <a href=\"http://www.gotw.ca/publications/mill15.htm\" rel=\"nofollow noreferrer\">article</a> on GOTW.</p>\n<p>My assumption is that the standard puts requirements on compiler (and runtime) default implementations.  So the \"as if\" you quote is meant to inform the compiler vendor that its default implementations of those methods must meet the specified criteria.  If a developer chooses to override only one version of operator new, I do not think it is the compiler's responsibility to make all other versions of operator new compliant.  It is the developer's responsibility.  But that's all my opinion, I don't have the spec handy at the moment to see what it says in the front matter.</p>\n", "OwnerUserId": "95559", "PostTypeId": "2", "Id": "2306677", "Score": "0", "CreationDate": "2010-02-21T17:22:00.993", "LastActivityDate": "2010-02-21T17:22:00.993"}, "bq_ids": {"n4140": {"so_2306587_2307021_0": {"section_id": 5797, "quality": 1.0, "length": 8}, "so_2306587_2307021_1": {"section_id": 5797, "quality": 0.9285714285714286, "length": 39}, "so_2306587_2306587_0": {"section_id": 6818, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_2306587_2307021_0": {"section_id": 5570, "quality": 1.0, "length": 8}, "so_2306587_2307021_1": {"section_id": 5570, "quality": 0.9285714285714286, "length": 39}, "so_2306587_2306587_0": {"section_id": 6573, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_2306587_2307021_0": {"section_id": 7256, "quality": 1.0, "length": 8}, "so_2306587_2307021_1": {"section_id": 7256, "quality": 0.9285714285714286, "length": 39}, "so_2306587_2306587_0": {"section_id": 8310, "quality": 0.6363636363636364, "length": 7}}}, "2306640": {"ParentId": "2306587", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If the change in allocator in <code>operator new</code> makes an observable difference in the behaviour of a compliant C++ program then yes, it might require a change in the implementation of the <em>no-throw</em> version. Specifically if <code>operator delete</code> expects only blocks allocated by the new allocator then the <em>no-throw</em> new must change.</p>\n<p>My reading is that the use of <em>as if</em> allows an implementation such as yours when the user hasn't overriden the standard <code>operator new</code>. As soon as he has, the implementation must not use a <code>malloc</code> based <em>no-throw</em> <code>operator new</code> and must either call the user declared version explicitly or at least re-use enough of the user declared version that a conforming program cannot tell that this isn't how the <em>no-throw</em> version has been implemented.</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2010-02-21T17:17:35.637", "Id": "2306640", "Score": "2", "CreationDate": "2010-02-21T17:11:06.867", "LastActivityDate": "2010-02-21T17:17:35.637"}});