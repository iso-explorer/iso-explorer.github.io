post_cb({"bq_ids": {"n4140": {"so_15852528_15852626_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}, "so_15852528_15852626_0": {"length": 30, "quality": 0.967741935483871, "section_id": 623}, "so_15852528_15852626_3": {"length": 20, "quality": 1.0, "section_id": 599}, "so_15852528_15852626_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}}, "n3337": {"so_15852528_15852626_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}, "so_15852528_15852626_0": {"length": 31, "quality": 1.0, "section_id": 613}, "so_15852528_15852626_3": {"length": 20, "quality": 1.0, "section_id": 589}, "so_15852528_15852626_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}}, "n4659": {"so_15852528_15852626_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}, "so_15852528_15852626_0": {"length": 30, "quality": 0.967741935483871, "section_id": 649}, "so_15852528_15852626_3": {"length": 20, "quality": 1.0, "section_id": 622}, "so_15852528_15852626_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}}}, "15852626": {"Id": "15852626", "PostTypeId": "2", "Body": "<p>It's a language quirk. The first <code>f</code> matches better because your <code>A</code> requires no conversion to match the argument type (<code>A</code>), but when the compiler attempts to make the call the fact that no suitable copy constructor can be found causes the call to fail. The language doesn't allow taking account of the feasibility of the actual call into consideration when performing the overload resolution step.</p>\n<p>Closest matching standard quote ISO/IEC 14882:2011 13.3.3.1.2 User-defined conversion sequences [over.ics.user]:</p>\n<blockquote>\n<p id=\"so_15852528_15852626_0\">A conversion of an expression of class type to the same class type is given Exact Match rank, and a conversion\n  of an expression of class type to a base class of that type is given Conversion rank, in spite of the fact that\n  a copy/move constructor (i.e., a user-defined conversion function) is called for those cases.</p>\n</blockquote>\n<p>For the list initialization case, you probably need to look at:\n13.3.3.1.2 User-defined conversion sequences [over.ics.user]</p>\n<blockquote>\n<p id=\"so_15852528_15852626_1\">When objects of non-aggregate class type T are list-initialized (8.5.4), overload resolution selects the constructor\n  in two phases:</p>\n<p id=\"so_15852528_15852626_2\">\u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the\n  argument list consists of the initializer list as a single argument.</p>\n<p id=\"so_15852528_15852626_3\">\u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the\n  candidate functions are all the constructors of the class T and the argument list consists of the elements\n  of the initializer list.</p>\n</blockquote>\n<p>Because the overload resolution has to look at viable contructors in each case for <code>f(A)</code> and <code>f(B)</code> it must reject the seqence trying to bind <code>A()</code> to <code>A(A&amp;)</code> but <code>B(const A&amp;)</code> is still viable.</p>\n", "LastEditorUserId": "19563", "LastActivityDate": "2013-04-06T15:42:20.057", "Score": "17", "CreationDate": "2013-04-06T15:21:24.490", "ParentId": "15852528", "CommentCount": "4", "OwnerUserId": "19563", "LastEditDate": "2013-04-06T15:42:20.057"}, "15852528": {"ViewCount": "2507", "Body": "<p>I have this code</p>\n<pre><code>struct A { A(); A(A&amp;); }; \nstruct B { B(const A&amp;); }; \n\nvoid f(A); \nvoid f(B); \n\nint main() { \n   f(A()); \n}\n</code></pre>\n<p>To my surprise this fails with GCC and Clang. Clang says for example</p>\n<pre><code>Compilation finished with errors:\nsource.cpp:8:10: error: no matching constructor for initialization of 'A'\n       f(A()); \n         ^~~\nsource.cpp:1:21: note: candidate constructor not viable: expects an l-value for 1st argument\n    struct A { A(); A(A&amp;); }; \n                    ^\nsource.cpp:1:16: note: candidate constructor not viable: requires 0 arguments, but 1 was provided\n    struct A { A(); A(A&amp;); }; \n               ^\nsource.cpp:4:13: note: passing argument to parameter here\n    void f(A); \n</code></pre>\n<p>Why do they choose the first <code>f</code>, when the second <code>f</code> works fine? If I remove the first <code>f</code>, then the call succeeds. What is more weird to me, if I use brace initialization, <em>it also works fine</em></p>\n<pre><code>int main() { \n   f({A()}); \n}\n</code></pre>\n<p>They all call the second <code>f</code>. </p>\n", "AcceptedAnswerId": "15852626", "Title": "Compiler thinks that \"A(A&)\" accepts rvalues for a moment?", "CreationDate": "2013-04-06T15:10:39.623", "Id": "15852528", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-04-06T15:15:48.257", "LastEditorUserId": "34509", "LastActivityDate": "2013-04-06T19:38:23.687", "Score": "20", "OwnerUserId": "34509", "Tags": "<c++><c++11><overload-resolution><brace-initialization>", "AnswerCount": "1"}});