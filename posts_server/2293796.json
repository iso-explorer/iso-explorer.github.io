post_cb({"2295550": {"ParentId": "2293796", "CommentCount": "7", "CreationDate": "2010-02-19T10:26:30.737", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "2295550", "Score": "2", "Body": "<blockquote>\n<p id=\"so_2293796_2295550_0\">In my understanding both int() and A() should be rvalues, no?</p>\n</blockquote>\n<p>Correct, the epxression <code>T()</code> is always an rvalue for scalar and user-defined types <code>T</code>. As long as no <code>const</code> is involved, the expression <code>T()</code> is a <em>modifiable rvalue</em>, to be more precise.</p>\n<p>Assignment involving scalar types requires a modifiable <em>lvalue</em> on the left hand side of the assignment operator. Since <code>int()</code> isn't an lvalue, you can't assign to <code>int()</code>.</p>\n<p>For user-defined types, assignment is a special member function, and member functions can also be called on <em>rvalues</em> (see \u00a73.10 section 10). That's why <code>A().operator=(a)</code> is well formed.</p>\n", "LastActivityDate": "2010-02-19T10:26:30.737"}, "2293875": {"ParentId": "2293796", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2010-02-19T03:26:25.480", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:32.147", "Id": "2293875", "OwnerUserId": "119280", "Body": "<p>From <a href=\"https://stackoverflow.com/questions/906734/does-c-do-value-initialization-of-a-pod-typedef\">Does C++ do value initialization of a POD typedef?</a>, which quotes the Standard:</p>\n<blockquote>\n<p id=\"so_2293796_2293875_0\">The expression T(), where T is a\n  simple-type-specifier (7.1.5.2) for a\n  non-array complete object type or the\n  (possibly cv-qualified) void type,\n  creates an rvalue of the specified\n  type, which is value-initialized</p>\n</blockquote>\n<p>Therefore int() is an rvalue and can't be assigned to, as you saw in your first case.</p>\n<p>A() would not be a simlle-type-specifyer and thus A() yields an lvalue</p>\n", "LastActivityDate": "2010-02-19T03:36:16.787"}, "2293926": {"ParentId": "2293796", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Rvalues are what you get from expressions (a useful simplification taken from the C standard, but not worded in C++ standardese).  Lvalues are \"locator values\".  Lvalues can be used as rvalues.  References are always lvalues, even if const.</p>\n<p>The major difference of which you have to be aware can be condensed to one item: you can't take the address of an rvalue (again, not standardese but a useful generalization of the rules).  Or to put it another way, you can't fix a precise <em>location</em> for an rvalue\u2014if you could, then you'd have an <em>lvalue</em>.  (You can, however, bind a const&amp; to an rvalue to \"fix it in place\", and 0x is changing the rules drastically.)</p>\n<p>User-defined types (UDTs), however, are slightly special: you can convert any rvalue into an lvalue, if the class's interface allows it:</p>\n<pre><code>struct Special {\n  Special&amp; get_lvalue() { return *this; }\n};\nvoid f() {\n  // remember \"Special()\" is an rvalue\n  Special* p = &amp;Special().get_lvalue(); // even though you can't dereference the\n  // pointer (because the object is destroyed), you still just took the address\n  // of a temporary\n\n  // note that the get_lvalue() method doesn't need to operate on a const\n  // object (though that would be fine too, if the return type matched)\n}\n</code></pre>\n<p>Something similar is happening for your <code>A() = a</code>, except through the compiler-supplied assignment operator, to turn the rvalue <code>A()</code> into <code>*this</code>.  To quote the standard, 12.8/10:</p>\n<blockquote>\n<p id=\"so_2293796_2293926_0\">If the class definition does not explicitly declare a copy assignment operator, one is declared <em>implicitly</em>.  The implicitly-declared copy assignment operator for a class X will have the form</p>\n<pre><code>X&amp; X::operator=(const X&amp;)\n</code></pre>\n</blockquote>\n<p>And then it goes on with more qualifications and specs, but that's the important bit here.  Since that's a member function, it can be called on rvalues, just like Special::get_lvalue can be, as if you had written <code>A().operator=(a)</code> instead of <code>A() = a</code>.</p>\n<p>The <code>int() = 1</code> is explicitly forbidden as you discovered, because ints don't have operator= implemented in the same way.  However, this slight discrepancy between types doesn't matter in practice (at least not that I've found).</p>\n<hr>\n<p>POD means Plain Old Data and is a collection of requirements that specify using memcpy is equivalent to copying.  Non-POD is any type for which you cannot use memcpy to copy (the natural opposite of POD, nothing hidden here), which tends to be most types you'll write in C++.  Being POD or non-POD doesn't change any of the above, and is really a separate issue.</p>\n</hr>", "Id": "2293926", "LastEditDate": "2010-02-19T04:12:07.010", "OwnerDisplayName": "Roger Pate", "Score": "17", "CreationDate": "2010-02-19T03:43:03.883", "LastActivityDate": "2010-02-19T04:12:07.010", "LastEditorDisplayName": "Roger Pate"}, "bq_ids": {"n4140": {"so_2293796_2293875_0": {"section_id": 6000, "quality": 0.7777777777777778, "length": 14}, "so_2293796_2293926_0": {"section_id": 467, "quality": 0.95, "length": 19}}, "n3337": {"so_2293796_2293875_0": {"section_id": 5768, "quality": 0.7777777777777778, "length": 14}, "so_2293796_2293926_0": {"section_id": 458, "quality": 0.95, "length": 19}}, "n4659": {"so_2293796_2293926_0": {"section_id": 490, "quality": 0.95, "length": 19}}}, "2293796": {"CommentCount": "0", "AcceptedAnswerId": "2293926", "CreationDate": "2010-02-19T02:54:33.093", "LastActivityDate": "2010-02-19T10:26:30.737", "PostTypeId": "1", "ViewCount": "4865", "FavoriteCount": "7", "Title": "PODs, non-PODs, rvalue and lvalues", "Id": "2293796", "Score": "20", "Body": "<p>Could anyone explain the details in terms of rvalues, lvalues, PODs, and non-PODs the reason why the first expression marked below is <strong>not</strong> ok while the second expression marked below is ok? In my understanding both int() and A() should be rvalues, no? </p>\n<pre><code>\nstruct A {};\n\nint main()\n{\n  int i;\n  A a;\n\n  int() = i; //Not OK (error).\n  A() = a; //OK.\n\n  return 0;\n}\n\n</code></pre>\n", "Tags": "<c++><pod><lvalue><rvalue>", "OwnerUserId": "276647", "AnswerCount": "3"}});