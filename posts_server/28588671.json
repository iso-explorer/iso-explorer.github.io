post_cb({"bq_ids": {"n4140": {"so_28588671_28588809_2": {"length": 29, "quality": 0.8055555555555556, "section_id": 3345}, "so_28588671_28588809_1": {"length": 58, "quality": 0.9354838709677419, "section_id": 3344}, "so_28588671_28588809_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 3343}}, "n3337": {"so_28588671_28588809_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 3213}, "so_28588671_28588809_1": {"length": 58, "quality": 0.9354838709677419, "section_id": 3214}, "so_28588671_28588809_2": {"length": 30, "quality": 0.8333333333333334, "section_id": 3215}}, "n4659": {"so_28588671_28588809_0": {"length": 15, "quality": 0.625, "section_id": 4109}}}, "28588739": {"Id": "28588739", "PostTypeId": "2", "Body": "<p>Yes any scope bound variables will be destroyed.</p>\n<pre><code>void work()\n{\n     Foo a;\n     Foo* b = new Foo;\n     // ... later\n\n     // exception thrown\n\n     delete b;\n}\n</code></pre>\n<p>In this example <code>a</code>'s destructor would be called when the exception was thrown as the stack unwound, but the memory pointed to by <code>b</code> would be leaked since it would never reach the <code>delete</code> call. This is one of the many reasons why RAII is so helpful.</p>\n", "LastActivityDate": "2015-02-18T16:33:29.377", "Score": "1", "CreationDate": "2015-02-18T16:33:29.377", "ParentId": "28588671", "CommentCount": "0", "OwnerUserId": "2296458"}, "28588671": {"ViewCount": "1434", "Body": "<p>Normally it would be destructed upon the scope ending.. I could see issues occurring if exceptions were thrown though.</p>\n", "AcceptedAnswerId": "28588809", "Title": "C++: If an exception is thrown, are objects that go out of scope destroyed?", "CreationDate": "2015-02-18T16:30:42.107", "Id": "28588671", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-18T18:45:40.637", "Score": "2", "OwnerUserId": "3339089", "Tags": "<c++><exception><visual-studio-2008><scope><throw>", "AnswerCount": "3"}, "28588809": {"Id": "28588809", "PostTypeId": "2", "Body": "<p>Yes.</p>\n<p>C++ Standard n3337</p>\n<h2>15 Exception handling</h2>\n<p><strong>\u00a7</strong> 15.2 Constructors and destructors</p>\n<blockquote>\n<p id=\"so_28588671_28588809_0\">1) As control passes from a throw-expression to a handler, destructors\n  are invoked for <strong>all automatic objects constructed since the try block\n  was entered</strong>. The automatic objects are destroyed in the reverse order\n  of the completion of their construction.</p>\n<p id=\"so_28588671_28588809_1\">2) An object of any storage duration whose initialization or\n  destruction is terminated by an exception will have destructors\n  executed for <strong>all</strong> of its <strong>fully constructed subobjects</strong> (excluding the\n  variant members of a union-like class), that is, for subobjects for\n  which the principal constructor (12.6.2) has completed execution and\n  the destructor has not yet begun execution. Similarly, if the\n  non-delegating constructor for an object has completed execution and a\n  delegating constructor for that object exits with an exception, the\n  object\u2019s destructor will be invoked. If the object was allocated in a\n  new-expression, the matching deallocation function (3.7.4.2, 5.3.4,\n  12.5), if any, is called to free the storage occupied by the object.</p>\n<p id=\"so_28588671_28588809_2\">3) The process of calling destructors for automatic objects\n  constructed on the path from a try block to a throw-expression is\n  called \u201cstack unwinding.\u201d If a destructor called during stack\n  unwinding exits with an exception, std::terminate is called (15.5.1).\n  [ Note: So destructors should generally catch exceptions and not let\n  them propagate out of the destructor. \u2014 end note ]</p>\n</blockquote>\n<p>example:</p>\n<pre><code>SomeClass c;              // declared before try{} so it is\n                          // still valid in catch{} block\ntry {\n    SomeClass t;\n    throw;\n} catch( ...) {\n    // t destroyed\n    // c valid\n}\n</code></pre>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2015-02-18T18:45:40.637", "Score": "4", "CreationDate": "2015-02-18T16:36:51.813", "ParentId": "28588671", "CommentCount": "1", "LastEditDate": "2015-02-18T18:45:40.637", "OwnerUserId": "1141471"}, "28588732": {"Id": "28588732", "PostTypeId": "2", "Body": "<p>Yes. When you leave a scope (whether normally or via exception) objects local to that scope are destroyed. This is the basic fact that makes RAII/SBRM work.</p>\n", "LastActivityDate": "2015-02-18T16:33:17.543", "Score": "0", "CreationDate": "2015-02-18T16:33:17.543", "ParentId": "28588671", "CommentCount": "0", "OwnerUserId": "179910"}});