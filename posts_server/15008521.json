post_cb({"bq_ids": {"n4140": {"so_15008521_15008594_1": {"length": 36, "quality": 0.972972972972973, "section_id": 721}}, "n3337": {"so_15008521_15008594_1": {"length": 36, "quality": 0.972972972972973, "section_id": 710}}, "n4659": {"so_15008521_15008594_1": {"length": 36, "quality": 0.972972972972973, "section_id": 752}}}, "15008594": {"Id": "15008594", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15008521_15008594_0\">If I delete vector temp, do I destroy the basket[1] object too?</p>\n</blockquote>\n<p><strong>No</strong>. First of all, you cannot <em>delete</em> <code>temp</code>; rather, it will get destroyed when going out of scope. And when this happens, the objects pointed by elements of the vector won't be  automatically <code>delete</code>d.</p>\n<p>This is, however, not a specific problem of <code>vector</code>: using <code>list</code> will not save you from this issue. The problem is rather with <em>raw pointers</em>. If you want the pointed objects to be automatically deallocated when the the lifetime of the last pointer which points to it ends, you should use smart pointers.</p>\n<p>Depending on the ownership policy that your application needs, you might choose between <code>shared_ptr</code> and <code>unique_ptr</code>. The caveat with <code>shared_ptr</code> is that referencing cycles shall be avoided, to prevent mutually referencing objects from keeping each other alive. You may want to check <code>weak_ptr</code> in this respect.</p>\n<p>Finally, unless you have a good reason for <em>not</em> using <code>vector</code>, <code>vector</code> should be the default choice for a container. From Paragraph 23.2.3/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15008521_15008594_1\">The sequence containers offer the programmer different complexity trade-offs and should be used accordingly. <strong><code>vector</code> or <code>array</code> is the type of sequence container that should be used by default</strong>. <code>list</code> or <code>forward_list</code> should be used when there are frequent insertions and deletions from the middle of the sequence. <code>deque</code> is the data structure of choice when most insertions and deletions take place at the beginning or at the end of the sequence.</p>\n</blockquote>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-21T17:33:00.550", "Score": "6", "CreationDate": "2013-02-21T17:27:59.130", "ParentId": "15008521", "CommentCount": "1", "OwnerUserId": "1932150", "LastEditDate": "2013-02-21T17:33:00.550"}, "15008571": {"Id": "15008571", "PostTypeId": "2", "Body": "<p>If either of the vectors, <code>basket</code> or <code>temp</code>, are destroyed none of the <code>Fruit</code>s are destroyed. Anything that is dynamically allocated with <code>new</code> must be <code>delete</code>d. When the vectors go out of scope, they do not <code>delete</code> the objects that are pointed to by their elements. If you <code>delete</code> an object through one vector that is pointed to in the other vector, both point at the now <code>delete</code>d object.</p>\n<p>Since your vectors have automatic storage duration, you definitely <em>must not</em> do <code>delete basket;</code> or <code>delete temp;</code>.</p>\n<p>It's not recommended to use raw pointers in general, especially with dynamically allocated storage that you may forget to <code>delete</code>. In this case, however, you <em>do</em> need polymorphic behaviour, which is provided by pointers. You should use a <em>smart pointer</em> to avoid the problems with raw pointers. Try a <code>std::vector&lt;std::shared_ptr&lt;Fruit&gt;&gt;</code>.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-02-21T17:38:29.260", "Score": "3", "CreationDate": "2013-02-21T17:26:32.183", "ParentId": "15008521", "CommentCount": "7", "OwnerUserId": "150634", "LastEditDate": "2013-02-21T17:38:29.260"}, "15008521": {"ViewCount": "149", "Body": "<p>I just wonder what's wrong with vector of pointer. some of my friend recommend me to use list instead of vector. will this cause a problem:</p>\n<pre><code>vector&lt;Fruit*&gt; basket;\nbasket.push_back(new Apple());\nbasket.push_back(new Orange());\nvector&lt;Fruit*&gt; temp;\ntemp.push_back(basket[1]);\n</code></pre>\n<p>If I delete vector temp, do I destroy the basket[1] object too? if not, what's the problem with using vector of pointer?</p>\n", "AcceptedAnswerId": "15008594", "Title": "vector of pointer", "CreationDate": "2013-02-21T17:23:54.910", "Id": "15008521", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-02-21T17:38:29.260", "Score": "3", "OwnerUserId": "2084477", "Tags": "<c++>", "AnswerCount": "2"}});