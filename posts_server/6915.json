post_cb({"18293": {"Body": "<p>I suppose saying don't do this because it's not safe and will probably break more often than just initializing this stuff in <code>main()</code> isn't going to be that popular.</p>\n<p>(And yes, I know that suggesting that means you shouldn't attempt to do interesting stuff in constructors of global objects. That's the point.)</p>\n", "CreationDate": "2008-08-20T16:13:40.890", "ParentId": "6915", "CommentCount": "0", "LastEditDate": "2012-07-03T14:56:23.780", "PostTypeId": "2", "OwnerDisplayName": "Mat Noguchi", "LastEditorUserId": "142162", "LastActivityDate": "2012-07-03T14:56:23.780", "Id": "18293", "Score": "0", "OwnerUserId": "1799"}, "1702537": {"PostTypeId": "2", "Body": "<ol>\n<li><p>read on weak memory model. It can break double-checked locks and spinlocks. Intel is strong memory model (yet), so on Intel it's easier</p></li>\n<li><p>carefully use \"volatile\" to avoid caching of parts the object in registers, otherwise you'll have initialized the object pointer, but not the object itself, and the other thread will crash</p></li>\n<li><p>the order of static variables initialization versus shared code loading is sometimes not trivial. I've seen cases when the code to destruct an object was already unloaded, so the program crashed on exit</p></li>\n<li><p>such objects are hard to destroy properly</p></li>\n</ol>\n<p>In general singletons are hard to do right and hard to debug. It's better to avoid them altogether.</p>\n", "LastActivityDate": "2009-11-09T17:32:29.957", "Id": "1702537", "CommentCount": "0", "CreationDate": "2009-11-09T17:32:29.957", "ParentId": "6915", "Score": "1", "OwnerUserId": "23420"}, "bq_ids": {"n4140": {"so_6915_6955_0": {"length": 35, "quality": 0.5932203389830508, "section_id": 7151}}, "n3337": {"so_6915_6955_0": {"length": 35, "quality": 0.5932203389830508, "section_id": 6895}}}, "6943": {"Body": "<p>Unfortunately, Matt's answer features what's called <em>double-checked locking</em> which isn't supported by the C/C++ memory model.  (It is supported by the Java 1.5 and later \u2014 and I think .NET \u2014 memory model.)  This means that between the time when the <code>pObj == NULL</code> check takes place and when the lock (mutex) is acquired, <code>pObj</code> may have already been assigned on another thread.  Thread switching happens whenever the OS wants it to, not between \"lines\" of a program (which have no meaning post-compilation in most languages).</p>\n<p>Furthermore, as Matt acknowledges, he uses an <code>int</code> as a lock rather than an OS primitive.  Don't do that.  Proper locks require the use of memory barrier instructions, potentially cache-line flushes, and so on; use your operating system's primitives for locking.  This is especially important because the primitives used can change between the individual CPU lines that your operating system runs on; what works on a CPU Foo might not work on CPU Foo2.  Most operating systems either natively support POSIX threads (pthreads) or offer them as a wrapper for the OS threading package, so it's often best to illustrate examples using them.</p>\n<p>If your operating system offers appropriate primitives, and if you absolutely need it for performance, instead of doing this type of locking/initialization you can use an <em>atomic compare and swap</em> operation to initialize a shared global variable.  Essentially, what you write will look like this:</p>\n<pre><code>MySingleton *MySingleton::GetSingleton() {\n    if (pObj == NULL) {\n        // create a temporary instance of the singleton\n        MySingleton *temp = new MySingleton();\n        if (OSAtomicCompareAndSwapPtrBarrier(NULL, temp, &amp;pObj) == false) {\n            // if the swap didn't take place, delete the temporary instance\n            delete temp;\n        }\n    }\n\n    return pObj;\n}\n</code></pre>\n<p>This only works if it's safe to create multiple instances of your singleton (one per thread that happens to invoke GetSingleton() simultaneously), and then throw extras away.  The <code>OSAtomicCompareAndSwapPtrBarrier</code> function provided on Mac OS X \u2014 most operating systems provide a similar primitive \u2014 checks whether <code>pObj</code> is <code>NULL</code> and only actually sets it to <code>temp</code> to it if it is.  This uses hardware support to really, literally only perform the swap <em>once</em> and tell whether it happened.</p>\n<p>Another facility to leverage if your OS offers it that's in between these two extremes is <code>pthread_once</code>.  This lets you set up a function that's run only once - basically by doing all of the locking/barrier/etc. trickery for you - no matter how many times it's invoked or on how many threads it's invoked.</p>\n", "CreationDate": "2008-08-09T23:09:01.400", "ParentId": "6915", "CommentCount": "0", "LastEditDate": "2008-08-20T16:41:35.143", "PostTypeId": "2", "LastEditorDisplayName": "Derek Park", "LastActivityDate": "2008-08-20T16:41:35.143", "LastEditorUserId": "872", "Id": "6943", "Score": "14", "OwnerUserId": "714"}, "7044": {"Body": "<p>While this question has already been answered, I think there are some other points to mention:</p>\n<ul>\n<li>If you want lazy-instantiation of the singleton while using a pointer to a dynamically allocated instance, you'll have to make sure you clean it up at the right point.</li>\n<li>You could use Matt's solution, but you'd need to use a proper mutex/critical section for locking, and by checking \"pObj == NULL\" both before and after the lock. Of course, <strong>pObj</strong> would also have to be <em>static</em> ;)\n.\nA mutex would be unnecessarily heavy in this case, you'd be better going with a critical section.</li>\n</ul>\n<p>But as already stated, you can't guarantee threadsafe lazy-initialisation without using at least one synchronisation primitive.</p>\n<p>Edit: Yup Derek, you're right. My bad. :)</p>\n", "CreationDate": "2008-08-10T04:34:59.793", "ParentId": "6915", "CommentCount": "0", "LastEditDate": "2008-08-10T05:18:14.963", "PostTypeId": "2", "LastEditorDisplayName": "OJ", "LastActivityDate": "2008-08-10T05:18:14.963", "LastEditorUserId": "611", "Id": "7044", "Score": "1", "OwnerUserId": "611"}, "6915": {"ViewCount": "21729", "Body": "<p>Is there a way to implement a singleton object in C++ that is:</p>\n<ol>\n<li>Lazily constructed in a thread safe manner (two threads might simultaneously be the first user of the singleton - it should still only be constructed once).</li>\n<li>Doesn't rely on static variables being constructed beforehand (so the singleton object is itself safe to use during the construction of static variables).</li>\n</ol>\n<p>(I don't know my C++ well enough, but is it the case that integral and constant static variables are initialized before any code is executed (ie, even before static constructors are executed - their values may already be \"initialized\" in the program image)?  If so - perhaps this can be exploited to implement a singleton mutex - which can in turn be used to guard the creation of the real singleton..)</p>\n<hr>\n<p>Excellent, it seems that I have a couple of good answers now (shame I can't mark 2 or 3 as being <strong>the answer</strong>).  There appears to be two broad solutions:</p>\n<ol>\n<li>Use static initialisation (as opposed to dynamic initialisation) of a POD static variable, and implementing my own mutex with that using the builtin atomic instructions.  This was the type of solution I was hinting at in my question, and I believe I knew already.</li>\n<li>Use some other library function like <a href=\"http://opengroup.org/onlinepubs/007908799/xsh/pthread_once.html\" rel=\"noreferrer\">pthread_once</a> or <a href=\"http://www.boost.org/doc/libs/1_33_1/doc/html/call_once.html\" rel=\"noreferrer\">boost::call_once</a>.  These I certainly didn't know about - and am very grateful for the answers posted.</li>\n</ol>\n</hr>", "AcceptedAnswerId": "6955", "Title": "Thread safe lazy construction of a singleton in C++", "CreationDate": "2008-08-09T21:16:29.193", "Id": "6915", "CommentCount": "0", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2011-10-20T07:35:25.127", "LastEditorDisplayName": "Alex Miller", "LastEditorUserId": "889260", "LastActivityDate": "2012-07-03T14:56:23.780", "Score": "31", "OwnerUserId": "755", "Tags": "<c++><multithreading><singleton><construction><lazy-initialization>", "AnswerCount": "10"}, "70994": {"PostTypeId": "2", "Body": "<p>For gcc, this is rather easy:</p>\n<pre><code>LazyType* GetMyLazyGlobal() {\n    static const LazyType* instance = new LazyType();\n    return instance;\n}\n</code></pre>\n<p>GCC will make sure that the initialization is atomic. <strong>For VC++, this is not the case</strong>. :-(</p>\n<p>One major issue with this mechanism is the lack of testability: if you need to reset the LazyType to a new one between tests, or want to change the LazyType* to a MockLazyType*, you won't be able to. Given this, it's usually best to use a static mutex + static pointer.</p>\n<p>Also, possibly an aside: It's best to always avoid static non-POD types. (Pointers to PODs are OK.) The reasons for this are many: as you mention, initialization order isn't defined -- neither is the order in which destructors are called though. Because of this, programs will end up crashing when they try to exit; often not a big deal, but sometimes a showstopper when the profiler you are trying to use requires a clean exit.</p>\n", "LastActivityDate": "2010-08-31T14:12:31.900", "LastEditorUserId": "194982", "Id": "70994", "CommentCount": "2", "CreationDate": "2008-09-16T10:21:51.773", "ParentId": "6915", "Score": "6", "OwnerUserId": "11521", "LastEditDate": "2010-08-31T14:12:31.900"}, "18350": {"PostTypeId": "2", "Body": "<p>@Mat</p>\n<blockquote>\n<p id=\"so_6915_18350_0\">I suppose saying don't do this because it's not safe and will probably break more often than just initializing this stuff in main() isn't going to be that popular.</p>\n<p id=\"so_6915_18350_1\">[And yes, I know that suggesting that means you shouldn't attempt to do interesting stuff in constructors of global objects. That's the point.]</p>\n<p id=\"so_6915_18350_2\">MSN</p>\n</blockquote>\n<p>He's not trying to do anything interesting in a global object constructor.  He's trying to <em>avoid</em> doing anything interesting, by delaying initialization until later (lazy construction).  Initializing a variable to 0 and initializing a mutex with a static initializer do not count as interesting, because they are both things that the compiler can do.</p>\n", "OwnerDisplayName": "Derek Park", "LastActivityDate": "2008-08-20T16:45:59.827", "Id": "18350", "CommentCount": "1", "CreationDate": "2008-08-20T16:45:59.827", "ParentId": "6915", "Score": "-1", "OwnerUserId": "872"}, "6955": {"Body": "<p>Basically, you're asking for synchronized creation of a singleton, without using any synchronization (previously-constructed variables).  In general, no, this is not possible.  You need something available for synchronization.</p>\n<p>As for your other question, yes, static variables which can be statically initialized (i.e. no runtime code necessary) are guaranteed to be initialized before other code is executed.  This makes it possible to use a statically-initialized mutex to synchronize creation of the singleton.</p>\n<p>From the 2003 revision of the C++ standard:</p>\n<blockquote>\n<p id=\"so_6915_6955_0\">Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place. Zero-initialization and initialization with a constant expression are collectively called static initialization; all other initialization is dynamic initialization. Objects of POD types (3.9) with static storage duration initialized with constant expressions (5.19) shall be initialized before any dynamic initialization takes place. Objects with static storage duration defined in namespace scope in the same translation unit and dynamically initialized shall be initialized in the order in which their definition appears in the translation unit.</p>\n</blockquote>\n<p>If you <em>know</em> that you will be using this singleton during the initialization of other static objects, I think you'll find that synchronization is a non-issue.  To the best of my knowledge, all major compilers initialize static objects in a single thread, so thread-safety during static initialization.  You can declare your singleton pointer to be NULL, and then check to see if it's been initialized before you use it.</p>\n<p>However, this assumes that you <em>know</em> that you'll use this singleton during static initialization.  This is also not guaranteed by the standard, so if you want to be completely safe, use a statically-initialized mutex.</p>\n<p>Edit: Chris's suggestion to use an atomic compare-and-swap would certainly work.  If portability is not an issue (and creating additional temporary singletons is not a problem), then it is a slightly lower overhead solution.</p>\n", "CreationDate": "2008-08-09T23:52:40.253", "ParentId": "6915", "CommentCount": "0", "LastEditDate": "2008-08-10T00:06:19.117", "PostTypeId": "2", "LastEditorDisplayName": "Derek", "LastActivityDate": "2008-08-10T00:06:19.117", "LastEditorUserId": "872", "Id": "6955", "OwnerDisplayName": "Derek", "Score": "12", "OwnerUserId": "872"}, "7052": {"Body": "<blockquote>\n<p id=\"so_6915_7052_0\">You could use Matt's solution, but you'd need to use a proper mutex/critical section for locking, and by checking \"pObj == NULL\" both before and after the lock. Of course, pObj would also have to be static ;) . A mutex would be unnecessarily heavy in this case, you'd be better going with a critical section.</p>\n</blockquote>\n<p>OJ, that doesn't work.  As Chris pointed out, that's double-check locking, which is not guaranteed to work in the current C++ standard.  See: <a href=\"http://www.ddj.com/184405726\" rel=\"nofollow noreferrer\">C++ and the Perils of Double-Checked Locking</a></p>\n<p>Edit: No problem, OJ.  It's really nice in languages where it does work.  I expect it will work in C++0x (though I'm not certain), because it's such a convenient idiom.</p>\n", "CreationDate": "2008-08-10T05:11:03.247", "ParentId": "6915", "CommentCount": "0", "LastEditDate": "2008-08-10T05:27:50.123", "PostTypeId": "2", "LastEditorDisplayName": "Derek Park", "LastActivityDate": "2008-08-10T05:27:50.123", "LastEditorUserId": "872", "Id": "7052", "Score": "1", "OwnerUserId": "872"}, "2867416": {"PostTypeId": "2", "Body": "<p>Here's a very simple lazily constructed singleton getter:</p>\n<pre><code>Singleton *Singleton::self() {\n    static Singleton instance;\n    return &amp;instance;\n}\n</code></pre>\n<p>This is lazy, and the next C++ standard (C++0x) requires it to be thread safe. In fact, I believe that at least g++ implements this in a thread safe manner. So if that's your target compiler <em>or</em> if you use a compiler which also implements this in a thread safe manner (maybe newer Visual Studio compilers do? I don't know), then this might be all you need.</p>\n<p>Also see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2513.html\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2513.html</a> on this topic.</p>\n", "LastActivityDate": "2010-05-19T16:20:12.490", "Id": "2867416", "CommentCount": "2", "CreationDate": "2010-05-19T16:20:12.490", "ParentId": "6915", "Score": "11", "OwnerUserId": "91757"}, "7036": {"PostTypeId": "2", "Body": "<p>You can't do it without any static variables, however if you are willing to tolerate one, you can use <a href=\"http://www.boost.org/doc/html/thread.html\" rel=\"noreferrer\">Boost.Thread</a> for this purpose. Read the \"one-time initialisation\" section for more info.</p>\n<p>Then in your singleton accessor function, use <code>boost::call_once</code> to construct the object, and return it.</p>\n", "LastActivityDate": "2008-08-10T04:13:08.543", "Id": "7036", "CommentCount": "1", "CreationDate": "2008-08-10T04:13:08.543", "ParentId": "6915", "Score": "9", "OwnerUserId": "13"}});