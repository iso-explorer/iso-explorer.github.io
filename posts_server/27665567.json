post_cb({"27678581": {"ParentId": "27665567", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>As correctly noted by you the copy assignment operator is implicitly <strong>declared</strong> and trivial. \nSame goes for the default constructor, which is also trivial and implicitly declared.</p>\n<p>Note though that both of these member functions aren't implicitly <strong>defined</strong> - that only happens when they are used, [class.ctor]/7:</p>\n<blockquote>\n<p id=\"so_27665567_27678581_0\">An implicitly-declared default constructor for a class is <em>implicitly\n  defined</em> when it is used to create an object of its class type (1.8).</p>\n</blockquote>\n<p>.. which is clearly not the case here.<br>\nThat's the key difference, and the reason that @dasblinkenlight's quote is irrelevant for this matter: The default constructor is never defined, thus the paragraph on missing <em>mem-initializer-id</em>s doesn't apply.</br></p>\n<p>How are <code>const</code> members and the assignment operator connected then? Here:</p>\n<blockquote>\n<p id=\"so_27665567_27678581_1\">An implicitly-declared copy assignment operator is <em>implicitly defined</em> <strong>when an object of its class type is assigned a value of its class type or a value of a class type derived from its class type.</strong>\n   A program is ill-formed if the class for which a copy assignment\n  operator is implicitly <strong>defined</strong> has:</p>\n<ul>\n<li><strong>a nonstatic data member of <code>const</code> type</strong>, or [..]</li>\n</ul>\n</blockquote>\n<p>Thus the program would be ill-formed if the copy assignment operator would be used. But it isn't. All the special member functions are solely declared, and any restrictions on the <code>const</code>-ness of non-static data members only apply on implicitly defined special member functions.</p>\n<p>As an example, take </p>\n<pre><code>struct A\n{\n    int i;\n    const int b;\n};\n\nint main()\n{\n    A a = {1, 1};\n}\n</code></pre>\n<p>Which <a href=\"http://coliru.stacked-crooked.com/a/51e646785c251020\" rel=\"nofollow\">compiles fine under GCC</a>. Your program should be well-formed, too, as all requirements on trivialty of special member functions of union members are met by <code>A</code>.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-12-28T17:19:43.487", "Id": "27678581", "Score": "2", "CreationDate": "2014-12-28T16:57:26.500", "LastActivityDate": "2014-12-28T17:19:43.487"}, "27665567": {"CommentCount": "3", "AcceptedAnswerId": "27678581", "PostTypeId": "1", "LastEditorUserId": "4071916", "CreationDate": "2014-12-27T08:16:08.560", "LastActivityDate": "2014-12-28T17:24:21.487", "LastEditDate": "2014-12-27T19:43:26.450", "ViewCount": "538", "FavoriteCount": "2", "Title": "POD structs containing constant member", "Id": "27665567", "Score": "8", "Body": "<p>With this code:</p>\n<pre><code>struct A\n{\n    int i;\n    const int b;\n};\n\n// The union is to verify that A is a type that can be used in a union.\nunion U\n{\n    A a;\n    int b;\n};\n\nint main()\n{\n    U a = {1, 1};\n    U b = {2, 1};\n}\n</code></pre>\n<p>g++ version 4.8.3 complains about an error:</p>\n<pre><code>a.cpp:9:4: error: member \u2018A U::a\u2019 with copy assignment operator not allowed in union\n  A a;\n    ^\na.cpp:9:4: note: unrestricted unions only available with -std=c++11 or -std=gnu++11\n</code></pre>\n<p>but clang 3.5.0 compiles this code without error. Which one is correct? Is this a compiler bug?</p>\n<p><strong>My attempt at solving this:</strong></p>\n<p>From the C++03 standard section 9.5 paragraph 1:</p>\n<blockquote>\n<p id=\"so_27665567_27665567_0\">In a union, at most one of the data members can be active at any time, that is, the value of at most one of the data members can be stored in a union at any time. [Note: one special guarantee is made in order to simplify the use of unions: If a POD-union contains several POD-structs that share a common initial sequence (9.2), and if an object of this POD-union type contains one of the POD-structs, it is permitted to inspect the common initial sequence of any of POD-struct members; see 9.2. ] The size of a union is sufficient to contain the largest of its data members. Each data member is allocated as if it were the sole member of a struct. A union can have member functions (including constructors and destructors), but not virtual (10.3) functions. A union shall not have base classes. A union shall not be used as a base class. <strong>An object of a class with a non-trivial constructor (12.1), a non-trivial copy constructor (12.8), a non-trivial destructor (12.4), or a non-trivial copy assignment operator (13.5.3, 12.8) cannot be a member of a union, nor can an array of such objects</strong>. If a union contains a static data member, or a member of reference type, the program is ill-formed.</p>\n</blockquote>\n<p>From the C++03 standard section 12.8 paragraphs 10 and 11:</p>\n<blockquote>\n<p id=\"so_27665567_27665567_1\">If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. The implicitly-declared copy assignment operator for a class X will have the form <code>X&amp; X::operator=(const X&amp;)</code> if each direct base class B of X has a copy assignment operator whose parameter is of type const B&amp;, const volatile B&amp; or B, and for all the nonstatic data members of X that are of a class type M (or array thereof), each such class type has a copy assignment operator whose parameter is of type const M&amp;, const volatile M&amp; or M.</p>\n<p id=\"so_27665567_27665567_2\"><code>Otherwise, the implicitly declared copy assignment operator will have the form X&amp; X::operator=(X&amp;)</code>\n  ...</p>\n<p id=\"so_27665567_27665567_3\"><strong>A copy assignment operator for class X is trivial if it is implicitly declared and if class X has no virtual functions (10.3) and no virtual base classes (10.1), and each direct base class of X has a trivial copy assignment operator, and for all the nonstatic data members of X that are of class type (or array thereof), each such class type has a trivial copy assignment operator</strong>; otherwise the copy assignment operator is non-trivial.</p>\n</blockquote>\n<p>I'm not sure which compiler is correct because I don't know if a constant member has a trivial copy assignment operator.</p>\n<p><strong>Edit:</strong>\nThe compilation commands are:</p>\n<pre><code>clang++ a.cpp -o a\ng++ a.cpp -o a\n</code></pre>\n<p><strong>Edit2:</strong>\nTo show that g++ isn't complaining about A::b being <code>const</code> but A doesn't have a constructor, I also tried this program:</p>\n<pre><code>struct A\n{\n    int i;\n    const int b;\n};\n\nint main()\n{\n    A a = {1, 1};\n}\n</code></pre>\n<p>This compiled without errors on both g++ and clang++:</p>\n<pre><code>g++ b.cpp -o b\nclang++ b.cpp -o b\n</code></pre>\n", "Tags": "<c++><const><language-lawyer><c++03>", "OwnerUserId": "4071916", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27665567_27678581_0": {"section_id": 489, "quality": 0.8333333333333334, "length": 10}, "so_27665567_27665567_3": {"section_id": 467, "quality": 0.6818181818181818, "length": 30}, "so_27665567_27665567_1": {"section_id": 467, "quality": 0.9636363636363636, "length": 53}, "so_27665567_27665567_2": {"section_id": 467, "quality": 0.8, "length": 8}}, "n3337": {"so_27665567_27678581_0": {"section_id": 480, "quality": 0.8333333333333334, "length": 10}, "so_27665567_27678581_1": {"section_id": 453, "quality": 0.5666666666666667, "length": 17}, "so_27665567_27665567_2": {"section_id": 458, "quality": 0.8, "length": 8}, "so_27665567_27665567_3": {"section_id": 458, "quality": 0.6818181818181818, "length": 30}, "so_27665567_27665567_1": {"section_id": 458, "quality": 0.9636363636363636, "length": 53}}, "n4659": {"so_27665567_27678581_0": {"section_id": 384, "quality": 0.75, "length": 9}, "so_27665567_27665567_3": {"section_id": 490, "quality": 0.6818181818181818, "length": 30}, "so_27665567_27665567_1": {"section_id": 490, "quality": 0.9636363636363636, "length": 53}, "so_27665567_27665567_2": {"section_id": 490, "quality": 0.8, "length": 8}}}});