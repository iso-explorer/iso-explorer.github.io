post_cb({"12883804": {"Id": "12883804", "PostTypeId": "2", "Body": "<p>Presumably you agree this is valid?</p>\n<pre><code>void foo( double ) {}  // pass-by-value\n\nint main()\n{\n    char ch = '!';\n    foo( ch );\n}\n</code></pre>\n<p>There's an implicit conversion from <code>char</code> to <code>double</code>, so the function is viable.</p>\n<p>It's the same in the example in your edited question, there's an implicit conversion that produces a temporary (i.e. an rvalue) and the rvalue-reference argument binds to that temporary.  You can make that conversion explicit if you prefer:</p>\n<pre><code>void foo( double&amp;&amp; ) {}  // pass-by-reference\n\nint main()\n{\n    char ch = '!';\n    foo( double(ch) );\n}\n</code></pre>\n<p>but that doesn't really change anything in this case.  That would be necessary if <code>double</code> -&gt; <code>char</code> could only be converted explicitly (e.g. for class types with explicit constructors or explicit conversion operators) but <code>double</code> to <code>char</code> is a valid implicit conversion.</p>\n<p>The \"an rvalue-reference cannot bind to an lvalue\" rule you're thinking of refers to binding a <code>T&amp;&amp;</code> to a <code>T</code> lvalue, and that rule isn't broken because the <code>double&amp;&amp;</code> doesn't bind to the <code>char</code>, it binds to a temporary created by the implicit conversion.  </p>\n<p>That rule doesn't only exist to prevent unnecessary extra copying, but to fix a real safety problem that existed with the previous rules, see <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2812.html\" rel=\"nofollow\">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2812.html</a></p>\n<p><strong>Edit:</strong> It was asked whether this behaviour is desirable on the committee reflector (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1414\" rel=\"nofollow\">DR 1414</a>) and it was decided that yes, this behaviour is intended and is correct.  One of the arguments used to reach that position was that this code is more efficient with the current rules:</p>\n<pre><code>std::vector&lt;std::string&gt; v;\nv.push_back(\"text\");\n</code></pre>\n<p>With the current rules a temporary <code>std::string</code> is created by an implicit conversion, then  <code>std::vector&lt;T&gt;::push_back(T&amp;&amp;)</code> is called, and the temporary is <em>moved</em> into the vector.  If that <code>push_back</code> overload Wasn't viable for the result of a conversion then the code above would call <code>std::vector&lt;T&gt;::push_back(const T&amp;)</code> which would cause a <em>copy</em>.  The current rules make this real-world use case more efficient.  If the rules said rvalue-refs cannot bind to the result of implicit conversions you would have to change the code above to get the efficiency of a move:</p>\n<pre><code>v.push_back( std::string{\"text\"} );\n</code></pre>\n<p>IMHO it makes no sense to have to explicitly construct a <code>std::string</code> when that constructor is not explicit. I want consistent behaviour from explicit/implicit constructors, and I want the first <code>push_back</code> example to be more efficient.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-10-14T21:05:23.533", "Score": "0", "CreationDate": "2012-10-14T15:45:17.433", "ParentId": "12881209", "CommentCount": "5", "OwnerUserId": "981959", "LastEditDate": "2012-10-14T21:05:23.533"}, "12881280": {"Id": "12881280", "PostTypeId": "2", "Body": "<p>I haven't check the spec but I guess <code>char</code> can be automatically cast to <code>int</code>. Since you cannot assign anything (it's r-value) the R-value to temporary variable of type <code>int</code> (to be more explicit to <code>(int)c</code> value) will be passed.</p>\n", "LastEditorDisplayName": "user529758", "LastActivityDate": "2012-10-14T10:20:12.623", "Score": "2", "CreationDate": "2012-10-14T10:16:40.123", "ParentId": "12881209", "CommentCount": "2", "OwnerUserId": "49107", "LastEditDate": "2012-10-14T10:20:12.623"}, "12881963": {"Id": "12881963", "PostTypeId": "2", "Body": "<p>I discovered that N3290 (identical to C++11 standard) contains non-normative example of binding <code>double&amp;&amp;</code> to rvalue generated from <code>int</code> lvalue, and the updated wording in <strong>\u00a78.5.3</strong></p>\n<blockquote>\n<p id=\"so_12881209_12881963_0\">\u201cIf T1 is reference-related to T2 and the reference is an rvalue reference,\n  the initializer expression shall not be an lvalue.\u201d</p>\n</blockquote>\n<p>The rules were reportedly designed to avoid inefficient extra copying. Although I fail to see how such copying could not be optimized away. Anyway, whether the rationale is reasonable or not  \u2013  and it certainly doesn't <em>seem</em> as a reasonable effect!  \u2013  the following code is allowed, and compiles with both MSVC 11 and MinGW g++ 4.7:</p>\n<pre><code>struct Foo {};\nstruct Bar { Bar( Foo ) {} };\n\nvoid ugh( Bar&amp;&amp; ) {}\n\nint main()\n{\n    Foo o;\n    ugh( o );\n}\n</code></pre>\n<p>So apparently MSVC 11 is wrong in not permitting the lvalue -&gt; rvalue conversion.\n<hr>\n<strong>EDIT</strong>: I learned that there is Defect Report about this issue, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1414\" rel=\"nofollow\">DR 1414</a>. The Feb 2012 conclusion was that the current behavior specification is \u201ccorrect\u201d, presumably with respect to how well it reflects the intention. It is however reportedly still discussed in the committee, presumably with respect to the practicality of the intention.</hr></p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2012-10-14T21:00:49.427", "Score": "2", "CreationDate": "2012-10-14T11:54:43.583", "ParentId": "12881209", "CommentCount": "4", "OwnerUserId": "464581", "LastEditDate": "2012-10-14T21:00:49.427"}, "bq_ids": {"n4140": {"so_12881209_12881963_0": {"length": 7, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_12881209_12881963_0": {"length": 7, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_12881209_12881963_0": {"length": 7, "quality": 1.0, "section_id": 4087}}}, "12881209": {"ViewCount": "2200", "Body": "<p>As an answer to <a href=\"https://stackoverflow.com/questions/12877546/how-do-i-avoid-implicit-casting-on-non-constructing-functions-c/12877827#12877827\">another question</a> I wanted to post the following code (that is, I wanted to post code based on this idea):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;      // std::is_same, std::enable_if\nusing namespace std;\n\ntemplate&lt; class Type &gt;\nstruct Boxed\n{\n    Type value;\n\n    template&lt; class Arg &gt;\n    Boxed(\n        Arg const&amp; v,\n        typename enable_if&lt; is_same&lt; Type, Arg &gt;::value, Arg &gt;::type* = 0\n        )\n        : value( v )\n    {\n        wcout &lt;&lt; \"Generic!\" &lt;&lt; endl;\n    }\n\n    Boxed( Type&amp;&amp; v ): value( move( v ) )\n    {\n        wcout &lt;&lt; \"Rvalue!\" &lt;&lt; endl;\n    }\n};\n\nvoid function( Boxed&lt; int &gt; v ) {}\n\nint main()\n{\n    int i = 5;\n    function( i );  //&lt;- this is acceptable\n\n    char c = 'a';\n    function( c );  //&lt;- I would NOT like this to compile\n}\n</code></pre>\n<p>However, while MSVC 11.0 chokes at the last call, as it IHMO should, MinGW g++ 4.7.1 just accepts it, and invokes the constructor with rvalue reference formal argument.</p>\n<p>It <em>looks</em> to me as if an lvalue is bound to an rvalue reference. A glib answer could be that the lvalue is converted to rvalue. But the question is, is this a compiler bug, and if it\u2019s not, how does the Holy Standard permit this?</p>\n<hr>\n<p><strong>EDIT</strong>: I managed to reduce it all to the following pretty short example:</p>\n<pre><code>void foo( double&amp;&amp; ) {}\n\nint main()\n{\n    char ch = '!';\n    foo( ch );\n}\n</code></pre>\n<p>Fails to compile with MSVC 11.0, does compile with MinGW 4.7.1, which is right?</p>\n</hr>", "AcceptedAnswerId": "12883804", "Title": "Binding lvalue to rvalue reference -- g++ bug?", "CreationDate": "2012-10-14T10:06:58.113", "Id": "12881209", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:06:36.993", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-14T21:05:23.533", "Score": "10", "OwnerUserId": "464581", "Tags": "<c++><compiler-errors>", "AnswerCount": "3"}});