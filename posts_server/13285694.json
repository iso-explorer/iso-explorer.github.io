post_cb({"13285694": {"CommentCount": "2", "ViewCount": "45", "CreationDate": "2012-11-08T09:02:27.777", "LastActivityDate": "2012-11-08T09:08:01.083", "Title": "Is guaranteed that class members are disposed at the time that the class is disposed", "AcceptedAnswerId": "13285777", "PostTypeId": "1", "Id": "13285694", "Score": "3", "Body": "<p>I have the following situation:</p>\n<p>I have class A that contains a stack member object from class B:</p>\n<pre><code>Class A{\n    B b;\n}\n</code></pre>\n<p>I am using B object to redefine the behavior of the initialization and destruction of A.</p>\n<pre><code>Class B{\n    B(){cout&lt;&lt;\"taken care of some specific context initialization\"&lt;&lt;endl;}\n    ~B(){cout&lt;&lt;\"cleaning the context initialization done before\"&lt;&lt;endl;}\n}\n</code></pre>\n<p>This is working so far because ~B() is being called when b is destroyed (I guess it is done after A destructor).</p>\n<p>This is the behavior I am looking for, but I am scared about the possibility of the compiler saying: \"Hey, you are not using the object, I am going to reclaim the memory before\". I guess it should to happen, but is it possible in any compiler? I mean, is it set on the standard that you have to wait for A to be destroyed?</p>\n<p>Thanks in advance</p>\n", "Tags": "<c++><destructor><composition>", "OwnerUserId": "1210060", "AnswerCount": "1"}, "13285777": {"ParentId": "13285694", "CommentCount": "0", "Body": "<p>C++ follows an as-if behavior, meaning it is <em>theoretically</em> possible for <code>b</code> to be destroyed before <strong>as long as the behavior of the program isn't affected</strong>. And if it isn't affected, it doesn't really matter when it is destroyed.</p>\n<p>In practice though, <code>b</code> will be destroyed right after the destructor of its owner <code>A</code> instance will be destroyed.</p>\n<p>It is guaranteed by:</p>\n<h3>12.4 Destructors [class.dtor]</h3>\n<blockquote>\n<p id=\"so_13285694_13285777_0\">8) <strong>After executing the body of the destructor</strong> and destroying any\n  automatic objects allocated within the body, <strong>a destructor for class X\n  calls the destructors for X\u2019s direct non-variant non-static data\n  members, the destructors for X\u2019s direct base classes</strong> and, if X is the\n  type of the most derived class (12.6.2), its destructor calls the\n  destructors for X\u2019s virtual base classes. [...] (emphasis mine)</p>\n</blockquote>\n<p>Note that an implementation whose observable behavior acts as-if this was happening is still standard-compliant. In your particular case, since the destructor has IO operations, it's guaranteed that this behavior actually takes place.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "13285777", "Score": "2", "CreationDate": "2012-11-08T09:08:01.083", "LastActivityDate": "2012-11-08T09:08:01.083"}, "bq_ids": {"n4140": {"so_13285694_13285777_0": {"section_id": 404, "quality": 0.918918918918919, "length": 34}}, "n3337": {"so_13285694_13285777_0": {"section_id": 395, "quality": 0.918918918918919, "length": 34}}, "n4659": {"so_13285694_13285777_0": {"section_id": 422, "quality": 0.918918918918919, "length": 34}}}});