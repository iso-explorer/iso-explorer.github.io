post_cb({"bq_ids": {"n4140": {"so_48028565_48028710_1": {"length": 38, "quality": 0.926829268292683, "section_id": 3201}, "so_48028565_48028710_0": {"length": 25, "quality": 1.0, "section_id": 3921}}, "n3337": {"so_48028565_48028710_1": {"length": 38, "quality": 0.926829268292683, "section_id": 3075}, "so_48028565_48028710_0": {"length": 20, "quality": 0.8, "section_id": 3781}}, "n4659": {"so_48028565_48028710_1": {"length": 38, "quality": 0.926829268292683, "section_id": 3962}, "so_48028565_48028710_0": {"length": 25, "quality": 1.0, "section_id": 4807}}}, "48028565": {"ViewCount": "183", "Body": "<p>After watching Louis Brandy talk at CppCon 2017 I was shocked to discover that this code actually compiles:</p>\n<pre><code>#include &lt;string&gt;\n\nint main() {\n\n    std::string(foo);\n\n    return 0;\n}    \n</code></pre>\n<p>And for some reason <code>std::string(foo)</code> it is identical to <code>std::string foo</code> i.e. declaring a variable. I find it absolutely counterintuitive and can't see any reason for C++ to work that way. I would expect this to give an error about undefined identifier <code>foo</code>.</p>\n<p>It actually makes expressions like <code>token1(token2)</code> have even more possible interpretations than I previously thought.</p>\n<p>So my question is: what is the reason for this horror? When is this rule actually necessary?</p>\n<p>P.S. Sorry for the poorly worded title, please, feel free to change it!</p>\n", "AcceptedAnswerId": "48028710", "Title": "Why does using parentheses with a default constructor result in creation of the variable?", "CreationDate": "2017-12-29T21:18:48.457", "LastActivityDate": "2017-12-31T18:22:01.660", "CommentCount": "19", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-12-31T18:22:01.660", "LastEditorUserId": "964243", "Id": "48028565", "ClosedDate": "2017-12-29T21:57:36.083", "Score": "6", "OwnerUserId": "1823524", "Tags": "<c++><language-lawyer><most-vexing-parse>", "AnswerCount": "1"}, "48028710": {"Id": "48028710", "PostTypeId": "2", "Body": "<p>Since this question is tagged <a class=\"post-tag\" href=\"/questions/tagged/language-lawyer\" rel=\"tag\" title=\"show questions tagged 'language-lawyer'\">language-lawyer</a>, the direct answer is that, from <a href=\"http://eel.is/c++draft/stmt.ambig\" rel=\"noreferrer\">[stmt.ambig]</a>:</p>\n<blockquote>\n<p id=\"so_48028565_48028710_0\">There is an ambiguity in the grammar involving <em>expression-statements</em> and declarations: An <em>expression-statement</em> with a function-style explicit type conversion as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a <code>(</code>. <strong>In those cases the statement is a declaration</strong>.</p>\n</blockquote>\n<p>And, similarly, for functions, in <a href=\"http://eel.is/c++draft/dcl.ambig.res\" rel=\"noreferrer\">[dcl.ambig.res]</a>:</p>\n<blockquote>\n<p id=\"so_48028565_48028710_1\">The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in [stmt.ambig] can also occur in the context of a declaration. In that context, the choice is between a function declaration with a redundant set of parentheses around a parameter name and an object declaration with a function-style cast as the initializer. Just as for the ambiguities mentioned in [stmt.ambig], the resolution is to <strong>consider any construct that could possibly be a declaration a declaration</strong>.</p>\n</blockquote>\n<p>Hence:</p>\n<blockquote>\n<p id=\"so_48028565_48028710_2\">Why oh why is <code>std::string(\"foo\")</code> so different from <code>std::string(foo)</code></p>\n</blockquote>\n<p>The former <em>cannot</em> be a declaration. The latter <em>can</em> be a declaration, with a redundant set of parentheses. Thus, the former <em>isn't</em> a declaration and the latter <em>is</em>.</p>\n<p>The underlying issue is that, grammaticaly, declarators can start with a <code>(</code> which could make it indistinguishable from a function-style explicit type conversion. Rather than come up with arbitrary complex rules to try to determine what the user meant, the language just picks one, and it's easy enough for the user to fix the code to actually do what he meant. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-12-29T21:47:45.383", "Score": "14", "CreationDate": "2017-12-29T21:37:15.517", "ParentId": "48028565", "CommentCount": "7", "OwnerUserId": "2069064", "LastEditDate": "2017-12-29T21:47:45.383"}});