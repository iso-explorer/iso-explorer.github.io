post_cb({"16958411": {"ParentId": "16957812", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There is no inheritance of the operator=() of <code>A</code>. Instead, the base assignment operator is called from the derived class assignment operator, since the implicit assignment operator \"simply\" assigns all members and base classes.</p>\n<p>(See Standard [Draft N3242] \u00a712.8 for information on when the default copy or move assignment is implicitly generated and in which form.)</p>\n<p>The standard (Draft N3242) says:</p>\n<h3>\u00a712.8 / 29</h3>\n<blockquote>\n<p id=\"so_16957812_16958411_0\">The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise copy-/move assignment of its subobjects. <strong>The direct base classes of X are assigned</strong> first, in the order of their declaration in the base-specifier-list, and then the immediate non-static data members of X are assigned, in the order in which they were declared in the class definition.</p>\n</blockquote>\n<p>There we get the assignment operator into place.</p>\n<p><code>X</code> is <code>B</code> and <code>direct base class</code> is <code>A</code>. So in the implicit assignment operator of <code>B</code>, it's sub-object of type <code>A</code> will be assigned using <code>A::operator=(...)</code>.</p>\n<p><em>Note: It is advantageous to provide your assignment operator parameter by const reference (or by value if using copy&amp;swap).</em></p>\n", "OwnerUserId": "951423", "LastEditorUserId": "951423", "LastEditDate": "2013-06-06T09:40:33.633", "Id": "16958411", "Score": "0", "CreationDate": "2013-06-06T09:26:38.520", "LastActivityDate": "2013-06-06T09:40:33.633"}, "16957955": {"ParentId": "16957812", "CommentCount": "0", "Body": "<p>According to <a href=\"http://www.linuxtopia.org/online_books/programming_books/thinking_in_c++/Chapter14_010.html\" rel=\"nofollow\">http://www.linuxtopia.org/online_books/programming_books/thinking_in_c++/Chapter14_010.html</a> , when you do not define a constructor, destructor or <code>=</code> operator for your class, it automatically creates a simple version of all three.</p>\n<p>\"In lieu of inheritance, these functions are synthesized by the compiler if you don\u2019t create them yourself. (With constructors, you can\u2019t create any constructors in order for the compiler to synthesize the default constructor and the copy-constructor.) The synthesized constructors use memberwise initialization and the synthesized operator= uses memberwise assignment.\"</p>\n<p>Thus, B has a synthesized <code>=</code> operator automatically generated by the compiler.</p>\n", "OwnerUserId": "497106", "PostTypeId": "2", "Id": "16957955", "Score": "0", "CreationDate": "2013-06-06T09:05:29.497", "LastActivityDate": "2013-06-06T09:05:29.497"}, "16957934": {"ParentId": "16957812", "CommentCount": "3", "Body": "<p>In fact, it is not correct to say that <code>operator =</code> is not inherited. The problem is that it is <em>hidden</em> by the implicitly-generated <code>operator =</code> for the derived class, so that (for instance), an assignment such as the one in the code below would be illegal:</p>\n<pre><code>A a;\nB b;\nb = a;\n</code></pre>\n<p>Since class <code>B</code> does not have any <code>operator =</code> accepting an <code>A</code>, but only an implicitly generated copy-assignment operator with the following signature:</p>\n<pre><code>B&amp; operator = (B const&amp;)\n</code></pre>\n<p>The situation is not different from the case of regular member functions in the derived class hiding member functions with the same name in the base class.</p>\n<p>And as for regular member functions, you can have a <code>using</code> declaration in your class that makes the base class's <code>operator =</code> available:</p>\n<pre><code>class B: public A\n{\npublic:\n    using A::operator =;\n//  ^^^^^^^^^^^^^^^^^^^^\n};\n</code></pre>\n<p>This would make the assignment in the previous example compile.</p>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "16957934", "Score": "0", "CreationDate": "2013-06-06T09:04:25.303", "LastActivityDate": "2013-06-06T09:04:25.303"}, "bq_ids": {"n4140": {"so_16957812_16958411_0": {"section_id": 477, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_16957812_16958411_0": {"section_id": 468, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_16957812_16958411_0": {"section_id": 500, "quality": 0.9428571428571428, "length": 33}}}, "16957812": {"CommentCount": "4", "AcceptedAnswerId": "16957934", "PostTypeId": "1", "LastEditorUserId": "1276952", "CreationDate": "2013-06-06T08:59:06.933", "LastActivityDate": "2013-06-06T09:40:33.633", "LastEditDate": "2013-06-06T09:02:18.183", "ViewCount": "406", "FavoriteCount": "1", "Title": "Functions that do not automatically inherit", "Id": "16957812", "Score": "0", "Body": "<p>In c++ i read in bruce eckel that functions that do not automatically inherit are :</p>\n<ol>\n<li>Constructors</li>\n<li>Destructors</li>\n<li>Operator = ( because it does the constructor like thing)</li>\n</ol>\n<p>but this code says something else                     </p>\n<pre><code>#include&lt;iostream&gt;             \nusing namespace std;`                   \n\nclass A {\n public:\n   A &amp; operator= (A &amp;a) {\n    cout&lt;&lt;\" base class assignment operator called \";\n    return *this;\n   }\n};\n\nclass B: public A { };\n\nint main()\n{\n  B a, b;\n  a.A::operator=(b); //calling base class assignment operator function\n                // using derived class\n  a = b; // this also works\n  //getchar();\n  return 0;\n\n}   \n</code></pre>\n<p>Output : base class assignment operator called</p>\n<p>please explain.</p>\n", "Tags": "<c++><inheritance><operator-overloading>", "OwnerUserId": "1276952", "AnswerCount": "3"}});