post_cb({"bq_ids": {"n4140": {"so_45584616_45585426_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 299}, "so_45584616_45585426_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 5456}}, "n4659": {"so_45584616_45585426_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 306}, "so_45584616_45585426_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 6882}}}, "45585426": {"Id": "45585426", "PostTypeId": "2", "LastEditDate": "2017-08-09T12:46:57.297", "CommentCount": "10", "LastEditorUserId": "567292", "LastActivityDate": "2017-08-09T12:46:57.297", "CreationDate": "2017-08-09T08:28:09.160", "ParentId": "45584616", "Score": "7", "Body": "<p>1) and 2) have the same answer; <a href=\"https://stackoverflow.com/questions/43034729/making-sfinae-works-for-functions-with-deduced-return-type\">SFINAE does not work</a> with <a href=\"https://stackoverflow.com/questions/24396819/sfinae-with-c14-return-type-deduction?rq=1\">return type deduction</a> since the body of a function is <a href=\"http://eel.is/c++draft/dcl.spec.auto#10\" rel=\"nofollow noreferrer\">not in immediate context</a>:</p>\n<blockquote>\n<p id=\"so_45584616_45585426_0\">10 - Return type deduction for a function template with a placeholder in its declared type occurs when the\n  definition is instantiated even if the function body contains a <code>return</code> statement with a non-type-dependent\n  operand. [ <em>Note:</em> Therefore, any use of a specialization of the function template will cause an implicit\n  instantiation. Any errors that arise from this instantiation are not in the immediate context of the function\n  type and can result in the program being ill-formed (17.8.2). <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>3) is <a href=\"https://stackoverflow.com/questions/22368022/why-does-the-order-of-template-argument-substitution-matter\">a more interesting question</a>; the short-circuiting is intentional, and is guaranteed by <a href=\"http://eel.is/c++draft/temp.deduct#7\" rel=\"nofollow noreferrer\">[temp.deduct]</a>:</p>\n<blockquote>\n<p id=\"so_45584616_45585426_1\">7 - [...] The substitution proceeds\n  <strong>in lexical order</strong> and stops when a condition that causes deduction to fail is encountered.</p>\n</blockquote>\n<p>This short-circuiting works for gcc, clang and ICC, but unfortunately MSVC (as of CL 19 2017 RTW) gets it wrong, <a href=\"https://godbolt.org/g/aapu5i\" rel=\"nofollow noreferrer\">for example</a>:</p>\n<pre><code>template&lt;class T&gt; auto f(T t) -&gt; decltype(t.spork) { return t.spork; }\ntemplate&lt;class T&gt; auto g(T t) { return t.spork; }\nint x(...);\ntemplate&lt;class...&gt; using V = void;\ntemplate&lt;class T&gt; auto x(T t) -&gt; V&lt;decltype(f(t)), decltype(g(t))&gt; {}\nint a = x(0);\n</code></pre>\n", "OwnerUserId": "567292"}, "45584616": {"ViewCount": "295", "LastEditDate": "2017-08-09T08:02:05.740", "AcceptedAnswerId": "45585426", "Title": "Confusion with hard error in SFINAE", "CreationDate": "2017-08-09T07:48:39.630", "LastActivityDate": "2017-08-09T12:46:57.297", "CommentCount": "0", "Body": "<p>With regards to the following code (<a href=\"https://wandbox.org/permlink/nhx4pheijpTF1ohf\" rel=\"noreferrer\">https://wandbox.org/permlink/nhx4pheijpTF1ohf</a> reproduced below for convenience)</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\nnamespace foo_name {\ntemplate &lt;typename T&gt;\nvoid foo();\ntemplate &lt;&gt;\nvoid foo&lt;int&gt;();\n\ntemplate &lt;typename T&gt;\nstruct c_size;\ntemplate &lt;&gt;\nstruct c_size&lt;int&gt; : public std::integral_constant&lt;int, 1&gt; {};\n} // namespace foo_name\n\ntemplate &lt;typename Type&gt;\nclass Foo {\npublic:\n    template &lt;typename T&gt;\n    static decltype(auto) impl(T&amp;&amp; t) {\n        using foo_name::foo;\n        return foo(std::forward&lt;T&gt;(t));\n    }\n};\n\nclass Something {};\n\ntemplate &lt;typename Type, typename T = std::decay_t&lt;Type&gt;&gt;\nusing EnableIfHasFoo = std::void_t&lt;\n    decltype(Foo&lt;T&gt;::impl(std::declval&lt;T&gt;())),\n    decltype(foo_name::c_size&lt;Type&gt;::value)&gt;;\n\ntemplate &lt;typename Type, typename = std::void_t&lt;&gt;&gt;\nclass Test {};\ntemplate &lt;typename Type&gt;\nclass Test&lt;Type, EnableIfHasFoo&lt;Type&gt;&gt; {};\n\nint main() {\n    static_cast&lt;void&gt;(Test&lt;Something&gt;{});\n}\n</code></pre>\n<p>The code above exits with an error because the instantiation of <code>Foo&lt;T&gt;::impl()</code> causes a hard error and is not usable in a SFINAE context.  But the strange thing here is that when you switch the order of things in the <code>void_t</code> in <code>EnableIfHasFoo</code> (to the following <a href=\"https://wandbox.org/permlink/at1KkeCraNwHGmUI\" rel=\"noreferrer\">https://wandbox.org/permlink/at1KkeCraNwHGmUI</a>), it will compile</p>\n<pre><code>template &lt;typename Type, typename T = std::decay_t&lt;Type&gt;&gt;\nusing EnableIfHasFoo = std::void_t&lt;\n    decltype(foo_name::c_size&lt;Type&gt;::value),\n    decltype(Foo&lt;T&gt;::impl(std::declval&lt;T&gt;()))&gt;;\n</code></pre>\n<p>Now the questions are</p>\n<ol>\n<li>Why does the code initially not compile?  The instantiation of <code>Foo&lt;T&gt;::impl()</code> is in context of the substitution, so it should work?</li>\n<li>Substituting <code>foo_name::foo(T)</code> in place of the first argument to <code>void_t</code> will make it compile (see <a href=\"https://wandbox.org/permlink/g3NaPFZxdUPBS7oj\" rel=\"noreferrer\">https://wandbox.org/permlink/g3NaPFZxdUPBS7oj</a>), why?  How does adding one extra layer of indirection make the situation different?</li>\n<li>Why does the order in <code>void_t</code> make a difference, does the compiler short circuit the expressions within the type pack?</li>\n</ol>\n", "PostTypeId": "1", "LastEditorUserId": "5501675", "Id": "45584616", "AnswerCount": "1", "Score": "15", "OwnerUserId": "5501675", "Tags": "<c++><templates><c++1z><sfinae>", "FavoriteCount": "4"}});