post_cb({"bq_ids": {"n4140": {"so_32442699_32443367_0": {"length": 18, "quality": 0.9, "section_id": 603}, "so_32442699_32443367_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 638}, "so_32442699_32443367_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 638}, "so_32442699_32443367_1": {"length": 6, "quality": 0.75, "section_id": 603}, "so_32442699_32443367_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 638}}, "n3337": {"so_32442699_32443367_1": {"length": 6, "quality": 0.75, "section_id": 593}, "so_32442699_32443367_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 628}, "so_32442699_32443367_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 628}, "so_32442699_32443367_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 628}, "so_32442699_32443367_0": {"length": 18, "quality": 0.9, "section_id": 593}}, "n4659": {"so_32442699_32443367_1": {"length": 6, "quality": 0.75, "section_id": 629}, "so_32442699_32443367_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 666}, "so_32442699_32443367_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 666}, "so_32442699_32443367_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 666}, "so_32442699_32443367_0": {"length": 18, "quality": 0.9, "section_id": 629}}}, "32442699": {"ViewCount": "107", "Body": "<p>When compiling a sample code on g++ (v4.7.3), got error:</p>\n<pre><code>$ g++ -std=c++11 te2b.cc\nte2b.cc: In function \u2018int main(int, char**)\u2019:\nte2b.cc:17:19: warning: ISO C++ says that these are ambiguous, even though the worst conversion for the first is better than the worst conversion for the second: [enabled by default]\nte2b.cc:10:6: note: candidate 1: void notify(std::string, int)\nte2b.cc:7:6: note: candidate 2: void notify(const char*, ...)\n</code></pre>\n<p>The following is sample code.  Don't see why the ambiguity: the compiler should know to map call to <code>notify()</code> in <code>main()</code> to the first declaration. <code>void notify(const char *fmt, ...)</code>.  </p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;stdarg.h&gt;\nusing namespace std;\nchar notifyBuf[0x100000] = \"\\x06\\x00\\x00\\x00\" \"notify\"\"s\";\nvoid notify(const char *fmt, ...) {\n    //....\n}\nvoid notify(string s, int maxSize = 0) {\n    if (maxSize &amp;&amp; (maxSize &lt; s.size())) {\n        s.erase(maxSize);\n    }\n    notify(\"%s\\n\", s.c_str());\n}\nint main(int argc, char *argv[]) {\n    notify(\"%5d \", 89);    \n    return 0;\n}\n</code></pre>\n<p>Any ideas?  Thanks.</p>\n", "AcceptedAnswerId": "32443367", "Title": "Why are the functions ambiguious", "CreationDate": "2015-09-07T16:16:40.550", "Id": "32442699", "CommentCount": "12", "PostTypeId": "1", "LastActivityDate": "2015-09-07T17:09:23.580", "Score": "1", "OwnerUserId": "3337677", "Tags": "<c++>", "AnswerCount": "1"}, "32443367": {"Id": "32443367", "PostTypeId": "2", "Body": "<p>\u00a7 13.3.3 [over.match.best]/p2:</p>\n<blockquote>\n<p id=\"so_32442699_32443367_0\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if <strong>for all arguments i, ICS<sub>i</sub>(F1) is not a worse conversion sequence</strong> than ICS<sub>i</sub>(F2), and then</p>\n<p id=\"so_32442699_32443367_1\"><sup>(1.3)</sup> \u2014 for some argument j, ICS<sub>j</sub>(F1) is a better conversion sequence than ICS<sub>j</sub>(F2), or, if not that, [...]</p>\n</blockquote>\n<p>Given function call <code>notify(\"%5d \", 89);</code> and two overloads:</p>\n<pre><code>void notify(const char*, ...);   // F1\nvoid notify(std::string, int);   // F2\n</code></pre>\n<p>the compiler has the following set of implicit conversion sequences for the arguments of <code>F1</code>:</p>\n<ul>\n<li>ICS<sub>0</sub>(F1) - a standard conversion sequence (an array to pointer conversion)</li>\n<li>ICS<sub>1</sub>(F1) - an ellipsis conversion sequence</li>\n</ul>\n<p>and the following set of implicit conversion sequences for the arguments of <code>F2</code>:</p>\n<ul>\n<li>ICS<sub>0</sub>(F2) - a user defined conversion sequence (via a constructor)</li>\n<li>ICS<sub>1</sub>(F2) - a standard conversion sequence (an identity conversion)</li>\n</ul>\n<p>Because ICS<sub>0</sub>(F1) is better than ICS<sub>0</sub>(F2), but, in turn, ICS<sub>1</sub>(F2) is better than ICS<sub>1</sub>(F1), the compiler can't choose between the two.*</p>\n<hr>\n<p>* \u00a7 13.3.3.2 [over.ics.rank]/p2:</p>\n<blockquote>\n<p id=\"so_32442699_32443367_2\">When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1):</p>\n<p id=\"so_32442699_32443367_3\">\u2014 a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and</p>\n<p id=\"so_32442699_32443367_4\">\u2014 a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-09-07T17:09:23.580", "Score": "3", "CreationDate": "2015-09-07T17:09:23.580", "ParentId": "32442699", "CommentCount": "1", "OwnerUserId": "3953764"}});