post_cb({"bq_ids": {"n4140": {"so_20857005_20857203_1": {"length": 35, "quality": 1.0, "section_id": 7193}, "so_20857005_20857203_0": {"length": 37, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_20857005_20857203_1": {"length": 35, "quality": 1.0, "section_id": 6937}, "so_20857005_20857203_0": {"length": 37, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_20857005_20857203_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 8702}}}, "20857203": {"Id": "20857203", "PostTypeId": "2", "Body": "<p>It's worth mentioning that the initialisation of non-local static variables (that aren't in class template data members) in a single translation unit is ordered (\u00a73.6.2/2):</p>\n<blockquote>\n<p id=\"so_20857005_20857203_0\">Definitions of explicitly specialized class template static data members [... not this]. Other class template static data members [... not this]. Other non-local variables with static storage duration have ordered initialization. Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit.</p>\n</blockquote>\n<p>So you know that <code>FIRST_KEY_</code> will be initialised before <code>SECOND_KEY_</code> will be initialised before <code>ACTIONS_PROCESSORS_MAP_</code>.</p>\n<p>But even if this weren't the case, it would still be okay. Since <code>std::string</code> has non-trivial construction, there is some time between its storage has been allocated and the beginning of its lifetime. In this time it is okay to have a pointer to the object, as long as you don't do certain things with it. Your code doesn't do anything with it but store the pointer - you're safe. \u00a73.8/5:</p>\n<blockquote>\n<p id=\"so_20857005_20857203_1\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways.</p>\n</blockquote>\n<p>The limited ways are basically anything that doesn't involve accessing the object. In fact, it's fine to even perform indirection through the pointer as long as it doesn't end up undergoing lvalue-to-rvalue conversion (which essentially represents reading the object from memory).</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2013-12-31T19:40:35.600", "Score": "5", "CreationDate": "2013-12-31T12:12:07.880", "ParentId": "20857005", "CommentCount": "0", "OwnerUserId": "150634", "LastEditDate": "2013-12-31T19:40:35.600"}, "20857005": {"ViewCount": "130", "Body": "<p>Let's say i have this code :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;functional&gt;\n\nusing const_string_ref = std::reference_wrapper&lt;const std::string&gt;;\n\nnamespace std\n{\n    template&lt;&gt;\n    struct hash&lt;const_string_ref&gt;\n    {\n        size_t operator()(const const_string_ref&amp; ref) const\n        {\n            return std::hash&lt;std::string&gt;()(ref);\n        }\n    };\n\n    bool    operator==(const const_string_ref&amp; lhs,\n                       const const_string_ref&amp; rhs)\n    {\n        return (lhs.get() == rhs.get());\n    }\n}\n\nclass test\n{\npublic:\n    void process(const std::string&amp; action)\n    {\n        (this-&gt;*(ACTIONS_PROCESSORS_MAP_.at(action)))();\n    }\n\nprivate:\n  using action_processor = void (test::*)();\n  using actions_map = std::unordered_map&lt;const_string_ref, action_processor&gt;;\n\nprivate:\n  static const std::string FIRST_KEY_;\n  static const std::string SECOND_KEY_;\n\n  static const actions_map ACTIONS_PROCESSORS_MAP_;\n\nprivate:      \n  void first_action()\n  {\n      std::cout &lt;&lt; \"first works\" &lt;&lt; std::endl;\n  }\n\n  void second_action()\n  {\n      std::cout &lt;&lt; \"second works\" &lt;&lt; std::endl;\n  }\n};\n\nconst std::string test::FIRST_KEY_ = \"first\";\nconst std::string test::SECOND_KEY_ = \"second\";\n\nconst test::actions_map test::ACTIONS_PROCESSORS_MAP_ =\n{{std::cref(FIRST_KEY_), &amp;test::first_action},\n {std::cref(SECOND_KEY_), &amp;test::second_action}};\n\n\nint main()\n{\n   test t;\n\n   t.process(\"first\");\n   t.process(\"second\");\n\n   return 0;\n}\n</code></pre>\n<hr>\n<p>The main question is:</p>\n<p>Am i guaranteed that at the point of entering the <code>main</code> function the references contained within the <code>reference_wrapper</code> used as keys in <code>test::ACTIONS_PROCESSORS_MAP_</code> will be corectly initialized to valid references to <code>test::FIRST_KEY_</code> and <code>test::SECOND_KEY_</code> respectivly, independently of the static order initialization ?</p>\n<p>This question could be more generally summed up as :</p>\n<p>Are pointers/references to satatic objects valid even before these objects initialization (i.e can the address change at some point) ?</p>\n</hr>", "AcceptedAnswerId": "20857203", "Title": "Is it safe to rely on static object adresses?", "CreationDate": "2013-12-31T11:56:07.677", "Id": "20857005", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-03-23T09:58:09.313", "LastEditorUserId": "1147772", "LastActivityDate": "2015-03-23T09:58:09.313", "Score": "4", "OwnerUserId": "1147772", "Tags": "<c++>", "AnswerCount": "2"}, "20857081": {"Id": "20857081", "PostTypeId": "2", "Body": "<p>Yes, you can safely take the address of an object once its storage has been allocated, even if it has not yet been initialised. The storage for static objects lasts for the duration of the program, so you can take the address at any time.</p>\n<p>Of course, accessing the object itself outside its lifetime is not allowed.</p>\n", "LastActivityDate": "2013-12-31T12:00:57.167", "CommentCount": "0", "CreationDate": "2013-12-31T12:00:57.167", "ParentId": "20857005", "Score": "7", "OwnerUserId": "204847"}});