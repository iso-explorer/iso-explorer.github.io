post_cb({"bq_ids": {"n4140": {"so_21000882_21004439_0": {"length": 36, "quality": 0.5714285714285714, "section_id": 5965}, "so_21000882_21004439_1": {"length": 35, "quality": 1.0, "section_id": 5520}}, "n3337": {"so_21000882_21004439_0": {"length": 38, "quality": 0.6031746031746031, "section_id": 5734}, "so_21000882_21004439_1": {"length": 35, "quality": 1.0, "section_id": 5306}}, "n4659": {"so_21000882_21004439_0": {"length": 34, "quality": 0.5396825396825397, "section_id": 7456}, "so_21000882_21004439_1": {"length": 35, "quality": 1.0, "section_id": 6955}}}, "21004378": {"Id": "21004378", "PostTypeId": "2", "Body": "<p>The 4 errors is what clued me in.</p>\n<p>Stateless lambdas have an implicit conversion to functions.  In MSVC, there are something like 4 calling conventions supported.</p>\n<p>So your lambda creates 4 function signatures <em>within</em> the <code>extern \"C\"</code> block, one per calling convention.  These function signatures pick up the <code>extern \"C\"</code> and become illegal, as they return <code>std::string</code>.</p>\n<p>A possible fix might be to split the body from the interface.  Either one step (<code>extern \"C\"</code> the prototype, then implement), or have your <code>extern \"C\"</code> function call a non-<code>extern</code> <code>inline</code> function that has the lambda.</p>\n<p>Another approach would be to create a dummy variable and capture it.</p>\n<p>It isn't the <code>operator()</code> that is generating the error, it is the signature-matching pure function pointers implied by a pure stateless lambda.</p>\n", "LastActivityDate": "2014-01-08T19:06:33.523", "CommentCount": "2", "CreationDate": "2014-01-08T19:06:33.523", "ParentId": "21000882", "Score": "3", "OwnerUserId": "1774667"}, "21000882": {"ViewCount": "734", "Body": "<p>The title more or less says it all.  I've got the following bit\nof code: </p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n\nstruct xloper12;\n\nclass Something\n{\npublic:\n    std::string asString() const;\n};\nextern std::vector&lt;Something&gt; ourSomethings;\n\nclass ExcelOutputLoader\n{\npublic:\n    void load( std::vector&lt;std::string&gt; const&amp; value );\n    xloper12* asXloper() const;\n};\n\nextern xloper12* ProcessException( std::string const&amp; functionName );\n\nextern \"C\" __declspec(dllexport) xloper12*\ngetSomethingList()\n{\n    try {\n        std::vector&lt;std::string&gt; results;\n        results.reserve( ourSomethings.size() );\n        std::transform(\n            ourSomethings.begin(),\n            ourSomethings.end(),\n            std::back_inserter(results),\n            []( Something const&amp; o ) { return o.asString(); } );\n        ExcelOutputLoader out;\n        out.load( results );\n        return out.asXloper();\n    } catch (...) {\n        return ProcessException( \"GetSomthing\" );\n    }\n}\n</code></pre>\n<p>I've replaced most of the non-standard headers with dummy\ndeclarations; the issue is in the last function (which is\ndesigned to be called from Excel).  Basically, when compiled\nwith Visual Studios 2012, I get the following warning:</p>\n<pre><code>falseWarning.cc(34) : warning C4190: '&lt;Unknown&gt;' has C-linkage specified, but re\nturns UDT 'std::basic_string&lt;_Elem,_Traits,_Alloc&gt;' which is incompatible with C\n\n        with\n        [\n            _Elem=char,\n            _Traits=std::char_traits&lt;char&gt;,\n            _Alloc=std::allocator&lt;char&gt;\n        ]\n</code></pre>\n<p>(repeated four times, for good measure).  But as I understand\nit, lambda defines a class with an <code>operator()</code> member, and not\na function.  And (\u00a77.5/4) \"A C language linkage is ignored in\ndetermining the language linkage of the names of class members\nand the function type of class member functions.\"  Which would\nmean that the <code>extern \"C\"</code> should be ignored on the lambda. </p>\n<p>It's not a big thing: it's only a warning, and it's easy to work\naround (have the <code>extern \"C\"</code> function call a C++ function which\ndoes the actual work).  But I would still like to know: is there\nsomething fundamental that I've not understood about lambda, or\nis it the people developing Visual C++ who don't understand it.\n(In the latter case, I'm worried.  Since portability isn't an\nissue, we've started using lambda intensively.  But if the\nauthor's of the compiler don't understand it, then I'm worried.)</p>\n<p>EDIT:</p>\n<p>Some more tests.  If I write something like:</p>\n<pre><code>extern \"C\" __declspec(dllexport) void\nfunct1()\n{\n    extern std::string another();\n}\n</code></pre>\n<p>I also get the warning.  This time, I would say it was correct.\n<code>another</code> <em>is</em> a function in namespace scope, and it is declared\ninside an <code>extern \"C\"</code> block, so it should have \"C\" linkage.\n(Interestingly enough, I also get a warning to the effect that\nI might have been bitten by the most vexing parse problem.  The\n<code>extern</code> should have been enough for the compiler to realize\nthat I wasn't trying to define a local variable.)</p>\n<p>On the other hand, if I write something like:</p>\n<pre><code>extern \"C\" __declspec(dllexport) void\nfunct2()\n{\n    class Whatever\n    {\n    public:\n        std::string asString() { return std::string(); }\n    };\n    std::string x = Whatever().asString();\n}\n</code></pre>\n<p>There is no warning.  In this case, the compiler does correctly\nignore the specified \"C\" linkage on a member function.</p>\n<p>Which makes me wonder a little bit.  Is the compiler treating\nthe lambda as a class with an <code>operator()</code> function (as it\nshould), or is it treating it as a function?  It looks like that\nlatter, and that makes me worry if there aren't other subtle\nproblems involved, probably only visible when there is capture\n(and probably only in very special cases then).</p>\n", "AcceptedAnswerId": "21004439", "Title": "Can a lambda have \"C\" linkage?", "CreationDate": "2014-01-08T16:13:52.300", "Id": "21000882", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-01-08T18:33:38.503", "LastEditorUserId": "649665", "LastActivityDate": "2014-01-08T19:17:06.347", "Score": "10", "OwnerUserId": "649665", "Tags": "<c++><visual-c++><c++11>", "AnswerCount": "2"}, "21004439": {"Id": "21004439", "PostTypeId": "2", "Body": "<p>This appears to be underspecified by the standard.</p>\n<p>5.1.2:</p>\n<blockquote>\n<p id=\"so_21000882_21004439_0\">3 - [...] The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding <em>lambda-expression</em>. [...]<br/>\n  5 - The closure type for a <em>lambda-expression</em> has a public inline function call operator [...]<br/>\n  6 - The closure type for a <em>lambda-expression</em> with no <em>lambda-capture</em> has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type's function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type's function call operator.</p>\n</blockquote>\n<p>7.5:</p>\n<blockquote>\n<p id=\"so_21000882_21004439_1\">4 - [...] In a <em>linkage-specification</em>, the specified language linkage applies to the function types of all function declarators, function names with external linkage, and variable names with external linkage declared within the <em>linkage-specification</em>. [...] A C language linkage is ignored in determining the language linkage of the names of class members and the function type of class member functions. [...]</p>\n</blockquote>\n<p>So neither the function call operator or the conversion function to function pointer have C language linkage as they are class member functions; but since 5.1.2p6 does not specify <em>where</em> the function returned by the conversion function is declared, its type may have C language linkage.</p>\n<p>On one hand, if we consider an example in 7.5p4:</p>\n<pre><code>extern \"C\" {\n  class X {\n  // ...\n  void mf2(void(*)()); // the name of the function mf2 has C++ language\n                       // linkage; the parameter has type pointer to\n                       // C function\n  };\n}\n</code></pre>\n<p>This suggests that a conversion to function pointer would have return type pointer to C function, as long as the C function type is declared inline of the conversion declaration or otherwise within the extern \"C\" block:</p>\n<pre><code>extern \"C\" {\n  class Y {\n    (*operator void())(); // return type pointer to C function\n  };\n}\n</code></pre>\n<p>On the other hand, the function is required to have <em>the same effect</em> as the function call operator, which is not possible if C language linkage prevents it; we <em>could</em> conclude that the function must be declared outside the extern \"C\" block and similarly the return type of the conversion function.  But this may impose extra workload on the compiler writers.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-01-08T19:17:06.347", "Score": "4", "CreationDate": "2014-01-08T19:09:26.753", "ParentId": "21000882", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2014-01-08T19:17:06.347"}});