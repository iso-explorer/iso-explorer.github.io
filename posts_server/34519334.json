post_cb({"34519334": {"CommentCount": "3", "ViewCount": "44", "CreationDate": "2015-12-29T21:26:28.147", "LastActivityDate": "2015-12-29T21:46:53.623", "Title": "Merge char* arrays to uint16_t", "AcceptedAnswerId": "34519365", "PostTypeId": "1", "Id": "34519334", "Score": "0", "Body": "<p>I'm trying to merge a char*-array into a <code>uint16_t</code>. This is my code so far:</p>\n<pre><code>char* arr = new char[2]{0};\narr[0] = 0x0; // Binary: 00000000\narr[1] = 0xBE; // Binary: 10111110\n\nuint16_t merged = (arr[0] &lt;&lt; 8) + arr[1]; \ncout &lt;&lt; merged &lt;&lt; \" As Bitset: \" &lt;&lt; bitset&lt;16&gt;(merged) &lt;&lt; endl; \n</code></pre>\n<p>I was expecting <code>merged</code> to be <code>0xBE</code>, or in binary <code>00000000 10111110</code>.</p>\n<p>But the output of the application is:</p>\n<pre><code>65470 As Bitset: 1111111110111110\n</code></pre>\n<p><em>In the following descriptions I'm reading bits from left to right</em>. </p>\n<p>So <code>arr[1]</code> is at the right position, which is the last 8 bits. \nThe first 8 bits however are set to <code>1</code>, which they should not be. </p>\n<p>Also, if I change the values to </p>\n<pre><code>arr[0] = 0x1; // Binary: 00000001\narr[1] = 0xBE; // Binary: 10111110\n</code></pre>\n<p>The output is:</p>\n<p><code>0000000010111110</code></p>\n<p>Again, <code>arr[1]</code> is at the right position. But now the first 8 bits are <code>0</code>, whereas the last on of the first 8 should be <code>1</code>. </p>\n<p>Basically what I wan't to do is append <code>arr[1]</code> to <code>arr[0]</code> and interpret the new number as whole.</p>\n", "Tags": "<c++><arrays><binary><bitwise-operators>", "OwnerUserId": "4621142", "AnswerCount": "2"}, "34519365": {"ParentId": "34519334", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Perhaps <code>char</code> is signed type in your case, and you are left-shifting <code>0xBE</code> vhich is interpreted as signed negative value (<code>-66</code> in a likely case of <a href=\"https://en.wikipedia.org/wiki/Two's_complement\" rel=\"nofollow\">two's complement</a>).</p>\n<p>It is undefined behavior according to the standard. In practice it is often results in extending the sign bit, hence leading ones.</p>\n<blockquote>\n<p id=\"so_34519334_34519365_0\"><strong>3.9.1 Fundamental types</strong><br>....<br/></br></p>\n<p id=\"so_34519334_34519365_1\">It is implementationdefined\n  whether a char object can hold negative values.</p>\n<hr>\n<p id=\"so_34519334_34519365_2\"><strong>5.8 Shift operators</strong><br>....<br/></br></p>\n<p id=\"so_34519334_34519365_3\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned\n  type, the value of the result is <code>E1 \u00d7 2</code><sup><code>E2</code></sup>, reduced modulo one more than the maximum value representable\n  in the result type. Otherwise, if <code>E1</code> has a signed type and non-negative value, and <code>E1\u00d72</code><sup><code>E2</code></sup> is representable\n  in the corresponding unsigned type of the result type, then that value, converted to the result type, is the\n  resulting value; otherwise, the behavior is undefined.</p>\n</hr></blockquote>\n", "OwnerUserId": "3246555", "LastEditorUserId": "3246555", "LastEditDate": "2015-12-29T21:46:53.623", "Id": "34519365", "Score": "1", "CreationDate": "2015-12-29T21:28:19.297", "LastActivityDate": "2015-12-29T21:46:53.623"}, "34519472": {"ParentId": "34519334", "CommentCount": "6", "Body": "<p>You need to assign to the wider type <em>before</em> shifting, otherwise you're shifting away<sup>\u2020</sup> your high bits before they ever even hit the only variable here that's big enough to hold them.</p>\n<pre><code>uint16_t merged = arr[0];\nmerged &lt;&lt;= 8;\nmerged += arr[1];\n</code></pre>\n<p>Or, arguably:</p>\n<pre><code>const uint16_t merged = ((uint16_t)arr[0] &lt;&lt; 8) + arr[1];\n</code></pre>\n<p>You also may want to consider converting through <code>unsigned char</code> first to avoid oddities with the high bit set. Try out a few different values in your unit test suite and see what happens.</p>\n<p><sub><sup>\u2020</sup> Well, your program has undefined behaviour from this out-of-range shift, so who knows what might happen!</sub></p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "34519472", "Score": "1", "CreationDate": "2015-12-29T21:37:23.037", "LastActivityDate": "2015-12-29T21:37:23.037"}, "bq_ids": {"n4140": {"so_34519334_34519365_1": {"section_id": 7210, "quality": 0.875, "length": 7}, "so_34519334_34519365_3": {"section_id": 6147, "quality": 0.9333333333333333, "length": 42}}, "n3337": {"so_34519334_34519365_1": {"section_id": 6954, "quality": 0.875, "length": 7}, "so_34519334_34519365_3": {"section_id": 5910, "quality": 0.7777777777777778, "length": 35}}, "n4659": {"so_34519334_34519365_1": {"section_id": 8719, "quality": 0.875, "length": 7}, "so_34519334_34519365_3": {"section_id": 7643, "quality": 0.9333333333333333, "length": 42}}}});