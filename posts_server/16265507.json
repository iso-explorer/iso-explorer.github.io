post_cb({"16265507": {"ViewCount": "1986", "Body": "<p>Compilers can make a lot of optimizations (like inlining some functions), and I'm slightly suspicious that not all memory allocated for local variables is cleared after the function call in my program (based on the system monitor of the OS X), so that's why I'm asking: is it guaranteed by the standard that all destructors of the local variables would be called exactly at the moment they go out of scope?</p>\n", "Title": "Is the destructor of the local variable always guaranteed to be called when it goes out of scope?", "CreationDate": "2013-04-28T17:13:28.993", "LastActivityDate": "2013-04-28T17:31:21.913", "CommentCount": "4", "LastEditDate": "2013-04-28T17:31:21.913", "PostTypeId": "1", "LastEditorUserId": "609063", "Id": "16265507", "Score": "5", "OwnerUserId": "609063", "Tags": "<c++><memory-management><destructor>", "AnswerCount": "5"}, "16265560": {"Id": "16265560", "PostTypeId": "2", "Body": "<h2>Yes, this will always occur. It is guaranteed by C++. From <a href=\"http://fisica.ciencias.uchile.cl/~jrogan/cursos/mfm0p01/c++-faq/dtors.html\" rel=\"nofollow\">C++ FAQ lite</a>:</h2>\n<p>[11.5] Should I explicitly call a destructor on a local variable?</p>\n<p>No!</p>\n<p>The destructor will get called again at the close } of the block in which the local was created. This is a guarantee of the language; it happens automagically; there's no way to stop it from happening. But you can get really bad results from calling a destructor on the same object a second time! Bang! You're dead!</p>\n<hr>\n<p>It goes a little beyond your question, but the base is the same.</p>\n</hr>", "LastActivityDate": "2013-04-28T17:20:20.150", "CommentCount": "0", "CreationDate": "2013-04-28T17:20:20.150", "ParentId": "16265507", "Score": "0", "OwnerUserId": "2000082"}, "16265530": {"Id": "16265530", "PostTypeId": "2", "Body": "<p>Yes. Per paragraph 3.7.3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16265507_16265530_0\">Block-scope variables explicitly declared <code>register</code> or not explicitly declared <code>static</code> or <code>extern</code> have <em>automatic\n  storage duration</em>. <strong>The storage for these entities lasts until the block in which they are created\n  exits</strong>.</p>\n</blockquote>\n<p>Notice, however, that this concerns variables with automatic storage duration. If you created an object dynamically with <code>new</code> and assigned the result to a local raw pointer, then <em>only the raw pointer</em> will be destroyed, and not the pointed object:</p>\n<pre><code>{\n    int* foo = new int(42);\n} // Here you have a memory leak: the foo pointer is destroyed,\n  // but not the object foo pointed to\n</code></pre>\n", "LastActivityDate": "2013-04-28T17:17:11.200", "CommentCount": "0", "CreationDate": "2013-04-28T17:17:11.200", "ParentId": "16265507", "Score": "7", "OwnerUserId": "1932150"}, "bq_ids": {"n4140": {"so_16265507_16265514_0": {"length": 19, "quality": 0.95, "section_id": 3917}, "so_16265507_16265530_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 7170}}, "n3337": {"so_16265507_16265514_0": {"length": 19, "quality": 0.95, "section_id": 3777}, "so_16265507_16265530_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6914}}, "n4659": {"so_16265507_16265514_0": {"length": 19, "quality": 0.95, "section_id": 4803}, "so_16265507_16265530_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 8678}}}, "16265532": {"Id": "16265532", "PostTypeId": "2", "Body": "<p>Yes, it's guaranteed.</p>\n<p>Monitoring memory usage with system monitor might be not precise, because application does not return memory to the system. Once allocated it belongs to the application and even if your objects are destroyed you might not see any difference.</p>\n<p>If you want to guarantee that your application does not have memory leaks you may want to use such tools as valgrind, or drMemory from google, or several others (google for \"memory leak detection\"). In this case you will have the most precise information about allocations, deallocations, leaks, memory access violations etc.</p>\n", "LastActivityDate": "2013-04-28T17:17:18.103", "CommentCount": "2", "CreationDate": "2013-04-28T17:17:18.103", "ParentId": "16265507", "Score": "6", "OwnerUserId": "1045850"}, "16265514": {"Id": "16265514", "PostTypeId": "2", "Body": "<p>Yes it is guaranteed that every variable that goes out of scope will get it's destructor called.</p>\n<h1>6.7 Declaration statement</h1>\n<blockquote>\n<p id=\"so_16265507_16265514_0\">2 Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is\n  executed. <strong>Variables with automatic storage duration declared in the block are destroyed on exit from the\n  block</strong> (6.6).</p>\n</blockquote>\n", "LastActivityDate": "2013-04-28T17:14:31.523", "CommentCount": "0", "CreationDate": "2013-04-28T17:14:31.523", "ParentId": "16265507", "Score": "3", "OwnerUserId": "2254782"}, "16265584": {"Id": "16265584", "PostTypeId": "2", "Body": "<p>It will if you have code like this:</p>\n<pre><code>void f()\n{\n  A a;  // create a local instance of A\n        // memory will be allocated on the stack, \n        // and the constructor for `a` will be called.\n\n  // various code here\n\n  // here at the end of the scope, \n  // the destructor for `a` will be called,\n  // and the memory on the stack will be freed.\n}\n</code></pre>\n", "LastActivityDate": "2013-04-28T17:22:35.767", "CommentCount": "0", "CreationDate": "2013-04-28T17:22:35.767", "ParentId": "16265507", "Score": "1", "OwnerUserId": "951890"}});