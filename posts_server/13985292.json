post_cb({"bq_ids": {"n4140": {"so_13985292_13985726_0": {"length": 12, "quality": 0.8, "section_id": 6686}}, "n3337": {"so_13985292_13985726_0": {"length": 12, "quality": 0.8, "section_id": 6441}}, "n4659": {"so_13985292_13985726_0": {"length": 12, "quality": 0.8, "section_id": 8161}}}, "13986933": {"Id": "13986933", "PostTypeId": "2", "Body": "<p>Use <code>friend std::conditional&lt;C, friendclass, void&gt;::type;</code> where <code>C</code> is your condition. A nonclass type friend will be ignored.</p>\n<p>The conditional template is easily implemented in C++03. However since C++03 does not support typedef friends you need to use the following syntax there</p>\n<pre><code>namespace detail { class friendclass {}; }\n\nclass Foo {\n  friend class std::conditional&lt;C, \n    friendclass, detail::friendclass&gt;::type::friendclass;\n};\n</code></pre>\n<p>Note that the detail dummy class name needs to match the name of the potential friend in this workaround.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2012-12-21T20:14:26.940", "Score": "7", "CreationDate": "2012-12-21T08:51:46.420", "ParentId": "13985292", "CommentCount": "4", "OwnerUserId": "34509", "LastEditDate": "2012-12-21T20:14:26.940"}, "13986959": {"Id": "13986959", "PostTypeId": "2", "Body": "<p><strong>Note:</strong> <a href=\"https://stackoverflow.com/a/13986933/11698\">Johannes</a> has pretty much nailed it.  In '03 you cannot befriend\na typedef - but if you know you have a class, then you can refer to\nit's <code>injected class name</code>.</p>\n<p>Johannes' answer also has the benefit of using standard library functionality which too is always a good thing.</p>\n<pre><code>#define some_compile_time_condition 0\n\nclass Foo;\n\ntemplate &lt;int Condition&gt; class  TestCondition {\nprivate:\n  friend class Foo;\n  struct Type {\n    struct Bar;\n  };\n};\n\ntemplate &lt;&gt; class TestCondition&lt;1&gt; {\npublic:\n  typedef Bar Type;\n};\n\nstruct Bar\n{\npublic:\n  void foo (Foo &amp;);\n};\n\nclass Foo {\nprivate:\n  friend struct TestCondition&lt; some_compile_time_condition &gt;::Type::Bar;\n  int m_i;\n};\n\nvoid Bar::foo (Foo &amp; foo)\n{\n  foo.m_i = 0;\n}\n</code></pre>\n<p>It's still different to the requirement in that <code>Foo</code> always has a\nfriend, but the befriended class changes based on the value of the\noption.</p>\n<p>An interesting side question is whether it is an ODR violation to have\nversions of <code>Foo</code> both with and without <code>some_compile_time_condition</code>\nset to 1.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-21T09:17:48.053", "Score": "0", "CreationDate": "2012-12-21T08:54:00.087", "ParentId": "13985292", "CommentCount": "0", "OwnerUserId": "11698", "LastEditDate": "2017-05-23T11:43:56.983"}, "13989963": {"Id": "13989963", "PostTypeId": "2", "Body": "<p>I think you take 1 preprocessor and write your source code inside that.</p>\n<pre><code>bool flag = false;\n#ifdef _MY_FRIEND_\n    friend class sample\n    flag = true;\n#endif\n\nif (flag)\n{\n ...\n ...\n ...\n}\n</code></pre>\n<hr>\n<pre><code>class Foo {\n#ifdef _MY_FRIEND_\n    friend class Bar;\n#endif\n}\n</code></pre>\n<p>};</p>\n<p>Here _MY_FRIEND_ is a preprocessor and if you add that preprocessor then at compile time your class Bar will be the friend class...you can use that preprocssor any where when you want to need class Bar as a friend class.other wise compile without the preprocessor then it wont allow u to add Bar as a friend class of Foo</p>\n<p>Please correct me if i understood the question wrong.</p>\n</hr>", "LastEditorUserId": "1896646", "LastActivityDate": "2012-12-21T14:28:28.907", "Score": "0", "CreationDate": "2012-12-21T12:11:28.233", "ParentId": "13985292", "CommentCount": "1", "OwnerUserId": "1896646", "LastEditDate": "2012-12-21T14:28:28.907"}, "13985292": {"ViewCount": "454", "Body": "<p>I want to declare a friend class only if some (compile-time) condition is true. For example:</p>\n<pre><code>// pseudo-C++\nclass Foo {\n    if(some_compile_time_condition) {\n        friend class Bar;\n    }\n};\n</code></pre>\n<p>I did not find any solution on the internet. I went through all the answers to the question <a href=\"https://stackoverflow.com/questions/11376149/generating-structures-dynamically-at-compile-time\">Generating Structures dynamically at compile time</a>. Many of them use the C++11 <code>std::conditional</code>, but I would like to know if it is possible to do this in C++03 <em>without using the preprocessor</em>. </p>\n<p>This solution <a href=\"https://stackoverflow.com/a/11376710/252576\">https://stackoverflow.com/a/11376710/252576</a> will not work because <code>friend</code>ship is not inherited ( <a href=\"https://stackoverflow.com/questions/13844129/friend-class-with-inheritance\">friend class with inheritance</a> ). </p>\n<p><strong>Edit</strong> Just to make this more easily visible, as mentioned below in the comment: This requirement is unusual. This is part of a new research project in hardware simulation, that I am working on. The testbench is written in C++, and I want to display the variables in a waveform. I have researched various other options, and figured out that I need to use a <code>friend class</code>, due to practical considerations. The friend will capture the values and generate the waveform, but I would prefer to have the friend only when the waveform is required, and not all the time. </p>\n", "AcceptedAnswerId": "13986933", "Title": "Can friend class be declared conditionally in C++03?", "CreationDate": "2012-12-21T06:26:07.697", "Id": "13985292", "CommentCount": "7", "LastEditDate": "2017-05-23T12:06:15.710", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-21T20:14:26.940", "Score": "4", "OwnerUserId": "252576", "Tags": "<c++><friend><c++03>", "AnswerCount": "5"}, "13985726": {"Id": "13985726", "PostTypeId": "2", "Body": "<p>[class.friend]/3 tells this :</p>\n<blockquote>\n<p id=\"so_13985292_13985726_0\">A friend declaration that does not declare a function shall have one of the following forms:<br>\n<code></code>  friend elaborated-type-specifier ;<br>\n<code></code>  friend simple-type-specifier ;<br>\n<code></code>  friend typename-specifier ;  </br></br></br></p>\n</blockquote>\n<p>therefore it is not possible to conditionally declare friends of a class, without a macro.</p>\n", "LastActivityDate": "2012-12-21T07:03:23.667", "CommentCount": "0", "CreationDate": "2012-12-21T07:03:23.667", "ParentId": "13985292", "Score": "2", "OwnerUserId": "476681"}, "13986087": {"Id": "13986087", "PostTypeId": "2", "Body": "<p>It <em>seems</em>, unfortunately, not possible within the C++ compiler: ie, it seems that only the preprocessor may help here. <em>Note: Johannes has a proposal, so there is hope!</em></p>\n<p>However I would note that:</p>\n<ul>\n<li>friendship does not require you to actually use it</li>\n<li>friendship is a pure compile-time construct (like access specifiers) and does not incur any runtime penalty on any major compiler</li>\n</ul>\n<p>there is no reason not to have <em>unconditional</em> friendship, but only use it if some conditions (static or dynamic) are met.</p>\n<p><em>Note: in the future, this is something that the</em> <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3329.pdf\" rel=\"nofollow\">static_if</a> <em>proposal could cover.</em></p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2012-12-21T09:09:16.773", "Score": "2", "CreationDate": "2012-12-21T07:35:52.780", "ParentId": "13985292", "CommentCount": "1", "OwnerUserId": "147192", "LastEditDate": "2012-12-21T09:09:16.773"}});