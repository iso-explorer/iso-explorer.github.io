post_cb({"bq_ids": {"n4140": {"so_39455328_39455421_1": {"length": 68, "quality": 0.8095238095238095, "section_id": 5467}}, "n3337": {"so_39455328_39455421_1": {"length": 68, "quality": 0.8095238095238095, "section_id": 5253}}, "n4659": {"so_39455328_39455421_2": {"length": 21, "quality": 0.875, "section_id": 4799}, "so_39455328_39455421_1": {"length": 68, "quality": 0.8095238095238095, "section_id": 6901}}}, "39455589": {"Id": "39455589", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39455328_39455589_0\">Is it semantically correct to store values in an enum that are not represented by an enumerator? Excerpts from the standard are most welcome.</p>\n</blockquote>\n<p>Yes if the value is in the range of the enumeration. Ben Voigt provided an excerpt from the standard. I prefer looking at <a href=\"http://en.cppreference.com/w/cpp/language/enum\" rel=\"nofollow\">cppreference</a> because I find it more readable (although it doesn't have the same authoritative value).</p>\n<blockquote>\n<p id=\"so_39455328_39455589_1\">Values of integer, floating-point, and other enumeration types can be converted, such as by static_cast, to any enumeration type. The result is unspecified (until C++17)undefined behavior (since C++17) if the value, converted to the enumeration's underlying type, is out of this enumeration's range. If the underlying type is fixed, the range is the range of the underlying type. If the underlying type is not fixed, the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration. Note that the value after such conversion may not necessarily equal any of the named enumerators defined for the type.</p>\n</blockquote>\n<p>\u00a0</p>\n<blockquote>\n<p id=\"so_39455328_39455589_2\">Which compiler is correct in the above linked examples, g++ or clang++?</p>\n</blockquote>\n<p>The problem is that your code invokes undefined behavior, but for a reason unrelated to enumerations, as pointed out in the comments and by Ben Voigt. So both compilers are correct.</p>\n<p>Note that you don't really need the <code>convert</code> function to experiment with these behaviors.</p>\n<pre><code>enum class val { foo = 1, bar = 2, baz = 4 };\n\nval operator|(val x, val y) {\n    return static_cast&lt;val&gt;(static_cast&lt;int&gt;(x) | static_cast&lt;int&gt;(y));\n}\n\nint main() {\n    std::cout &lt;&lt; static_cast&lt;int&gt;(val::foo | val::bar); // prints 3\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1f6158d7e37dbd05\" rel=\"nofollow\">Live example</a></p>\n<blockquote>\n<p id=\"so_39455328_39455589_3\">Is there a standard (or proposed) way to represent flags in C++?</p>\n</blockquote>\n<p>I would go for static constexpr variables in a structure (or class) for the scope.</p>\n<pre><code>struct Flags {\n    static constexpr unsigned int foo = 0x01;\n    static constexpr unsigned int bar = 0x02;\n    static constexpr unsigned int baz = 0x04;\n};\n</code></pre>\n", "LastEditorUserId": "3854570", "LastActivityDate": "2016-09-12T18:21:10.137", "Score": "3", "CreationDate": "2016-09-12T17:23:43.333", "ParentId": "39455328", "CommentCount": "2", "OwnerUserId": "3854570", "LastEditDate": "2016-09-12T18:21:10.137"}, "39456785": {"Id": "39456785", "PostTypeId": "2", "Body": "<p>Aside of the other answers (that already pointed out the problem), if you need a set of flags, consider an <code>std::bitset</code>, and eventually use an <code>enum</code> to give names to the bits (not their weigths), like</p>\n<pre><code>enum flags_names { f0, f1, f2, f3, NFlags }\ntypedef std::bitset&lt;NFlags&gt; flags;\n</code></pre>\n<p>Now you can do</p>\n<pre><code>flags fs;\nfs[f0] = true; fs[f2] = false;\nif(fs[f0]) ...\netc.\n</code></pre>\n", "LastActivityDate": "2016-09-12T18:45:56.847", "CommentCount": "2", "CreationDate": "2016-09-12T18:45:56.847", "ParentId": "39455328", "Score": "2", "OwnerUserId": "924727"}, "39455328": {"ViewCount": "299", "Body": "<p>Given <code>enum class val { foo = 1, bar = 2, baz = 4 };</code></p>\n<p>It is possible to define:</p>\n<pre><code>val operator|(val x, val y)\n{\n    return static_cast&lt;val&gt;(static_cast&lt;int&gt;(x) | static_cast&lt;int&gt;(y));\n}\n</code></pre>\n<p>However, is it semantically correct to do so?</p>\n<p>I am leaning towards <em><strong>no</strong></em>, as demonstrated in the following, seemingly well-behaving example:</p>\n<pre><code>int convert(val x)\n{\n    switch(x)\n    {\n    case val::foo: return 42;\n    case val::bar: return 53;\n    case val::baz: return 64;\n    }\n}\n</code></pre>\n<p>Calling <code>convert(val::foo | val::bar)</code> will return <code>0</code> when compiled with g++ and segmentation fault with clang++.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/fa09e63f6f769298\" rel=\"nofollow\">Here</a> is g++ version. And <a href=\"http://coliru.stacked-crooked.com/a/12c765f44f465303\" rel=\"nofollow\">here</a> is clang++ version.</p>\n<p>My question is two-fold:</p>\n<ol>\n<li>Is it semantically correct to store values in an enum that are not represented by an enumerator? Excerpts from the standard are most welcome.</li>\n</ol>\n<p>1.a Which compiler is correct in the above linked examples, g++ or clang++?</p>\n<ol start=\"2\">\n<li>Is there a standard (or proposed) way to represent flags in C++?</li>\n</ol>\n<p>I can think of several possible implementations:</p>\n<pre><code>enum class val { foo, bar, baz, size };\nusing val_flags = std::set&lt;val&gt;; // (1)\nusing val_flags = std::vector&lt;bool&gt;; // (2)\nusing val_flags = std::bitset&lt;val::size&gt;; // (3)\nusing val_flags = std::underlying_type&lt;val&gt;::type; // (4)\n</code></pre>\n<p><strong>UPDATE:</strong></p>\n<p>Thank you all for your answers. I ended up resurrecting my old enum operator template. In case anybody is interested, it can be found here: <a href=\"https://github.com/dimitry-ishenko-lib/lib/blob/master/operators.hpp\" rel=\"nofollow\">github.com</a></p>\n", "AcceptedAnswerId": "39455421", "Title": "Is it legal to cast to enum values not representable by enum?", "CreationDate": "2016-09-12T17:03:55.010", "Id": "39455328", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-09-13T13:39:30.587", "LastEditorUserId": "4358570", "LastActivityDate": "2016-09-13T13:39:30.587", "Score": "9", "OwnerUserId": "4358570", "Tags": "<c++><c++11><enums>", "AnswerCount": "3"}, "39455421": {"Id": "39455421", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39455328_39455421_0\">following, seemingly well-behaving example:</p>\n</blockquote>\n<p>It's not, but make one minor change:</p>\n<pre><code>int convert(val x)\n{\n    switch(x)\n    {\n    case val::foo: return 42;\n    case val::bar: return 53;\n    case val::baz: return 64;\n    }\n\n    return 9; // ADDED THIS LINE\n}\n</code></pre>\n<p>and all will be well.  An alternate fix would be to use a <code>default:</code> case and return there.</p>\n<p>Your existing code triggers undefined behavior<sup>1</sup> by reaching the closing brace of a function with a non-<code>void</code> return type.  Because it is undefined behavior, both compilers are correct.</p>\n<p>The semantics of holding values in an <code>enum</code> type which are bitwise OR combinations of enumerator values are well-defined and guaranteed.  The standard requires that instances of the <code>enum</code> can store any integer value with no more bits used than any of the enumerator values defined, which includes all bitwise-OR combinations.  The formal language used to say this is a bit messy, but here it is (note that your case is an <code>enum class</code>, these always have fixed underlying type and the first sentence applies):</p>\n<blockquote>\n<p id=\"so_39455328_39455421_1\">For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the\n  underlying type. Otherwise, for an enumeration where e<sub>min</sub> is the smallest enumerator and e<sub>max</sub> is the\n  largest, the values of the enumeration are the values in the range b<sub>min</sub> to b<sub>max</sub>, de\ufb01ned as follows: Let K\n  be 1 for a two\u2019s complement representation and 0 for a ones\u2019 complement or sign-magnitude representation.\n  b<sub>max</sub> is the smallest value greater than or equal to max(|e<sub>min</sub>| \u2212 K, |e<sub>min</sub>|) and equal to 2<sup>M</sup> \u2212 1, where\n  M is a non-negative integer. b<sub>min</sub> is zero if e<sub>min</sub> is non-negative and \u2212(b<sub>max</sub> + K) otherwise. The size of\n  the smallest bit-field large enough to hold all the values of the enumeration type is max(M, 1) if b<sub>min</sub> is\n  zero and M + 1 otherwise. It is possible to de\ufb01ne an enumeration that has values not defined by any of its enumerators. If the enumerator-list is empty, the values of the enumeration are as if the enumeration had a single enumerator with value 0.</p>\n</blockquote>\n<p>(from n4582, section 7.2 <code>[dcl.enum]</code>)</p>\n<hr>\n<p><sup>1</sup> From 6.6.3 <code>[stmt.return]</code>:</p>\n<blockquote>\n<p id=\"so_39455328_39455421_2\">Flowing off the end of a constructor, a destructor, or a function with a <em>cv</em> <code>void</code> return type is equivalent to a return with no operand. Otherwise, flowing off the end of a function other than main (3.6.1) results in unde\ufb01ned behavior.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2016-09-12T17:16:50.603", "Score": "6", "CreationDate": "2016-09-12T17:10:19.783", "ParentId": "39455328", "CommentCount": "5", "OwnerUserId": "103167", "LastEditDate": "2016-09-12T17:16:50.603"}});