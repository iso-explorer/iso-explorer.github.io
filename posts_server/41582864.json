post_cb({"41583216": {"ParentId": "41582864", "CommentCount": "0", "Body": "<p>See [conv.ptr]/1:</p>\n<blockquote>\n<p id=\"so_41582864_41583216_0\">A <em>null pointer constant</em> is an integer literal with value zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type [...]</p>\n</blockquote>\n<p>So the integer literal <code>0</code> can be converted to a null pointer.  But if you attempt to convert some other integer value, that is not a literal,  to a pointer type then the above quote does not apply. In fact there is no other implicit conversion  from integer to pointer (since none such is listed in [conv.ptr]), so your code fails.</p>\n<p>Note: Explicit conversion is covered by [expr.reinterpret.cast]/5.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "41583216", "Score": "1", "CreationDate": "2017-01-11T05:18:51.860", "LastActivityDate": "2017-01-11T05:18:51.860"}, "41582970": {"ParentId": "41582864", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_41582864_41582970_0\">Why has the compiler decided to treat the zero as an int?</p>\n</blockquote>\n<p>Because it is an integer.</p>\n<p>The literal 0 is a literal. Literals get to do funny things. String literals can be converted into <code>const char*</code> or <code>const char[N]</code>, where <code>N</code> is the length of the string + NUL terminator. The literal 0 gets to do funny things too; it can be used to initialize a pointer with a NULL pointer constant. And it can be used to initialize an object of type <code>nullptr_t</code>. And of course, it can be used to create an integer.</p>\n<p>But once it gets passed as a parameter, it can't be a magical compiler construct anymore. It becomes an actual C++ object with a concrete type. And when it comes to template argument deduction, it gets the most obvious type: <code>int</code>.</p>\n<p>Once it becomes an <code>int</code>, it <em>stops</em> being a literal 0 and behaves exactly like any other <code>int</code>. Not unless it is used in a <code>constexpr</code> context (like your <code>int(0)</code>), where the compiler can figure out that it is indeed a literal 0 and therefore can take on its magical properties. Function parameters are never <code>constexpr</code>, and thus they cannot partake in this.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2017-01-11T05:01:18.400", "Id": "41582970", "Score": "5", "CreationDate": "2017-01-11T04:54:26.763", "LastActivityDate": "2017-01-11T05:01:18.400"}, "41582864": {"CommentCount": "11", "ViewCount": "192", "CreationDate": "2017-01-11T04:44:47.507", "LastActivityDate": "2017-01-11T05:18:51.860", "Title": "Templated function can't convert 'int' to nullptr_t", "AcceptedAnswerId": "41582970", "PostTypeId": "1", "Id": "41582864", "Score": "1", "Body": "<p><strong>TL;DR:</strong></p>\n<p>Why can't templated functions access the same conversions that non-templated functions can?</p>\n<pre><code>struct A {\n    A(std::nullptr_t) {}\n};\n\ntemplate &lt;typename T&gt;\nA makeA(T&amp;&amp; arg) {\n    return A(std::forward&lt;T&gt;(arg));\n}\n\nvoid foo() {\n    A a1(nullptr); //This works, of course\n    A a2(0); //This works\n    A a3 = makeA(0); //This does not\n}\n</code></pre>\n<hr>\n<p><strong>Background</strong></p>\n<p>I'm trying to write some templated wrapper classes to use around existing types, with the goal of being drop-in replacements with minimal need to rewrite existing code that uses the now-wrapped values.</p>\n<p>One particular case I can't get my head around is as follows: we have a class which can be constructed from <code>std::nullptr_t</code> (here called A), and as such, there's plenty of places in the code base where someone has assigned zero to an instance.</p>\n<p>However, the wrapper cannot be assigned a zero, despite forwarding the constructors. I have made a very similar example that reproduces the issue without using an actual wrapper class - a simple templated function is sufficient to show the issue.</p>\n<p>I would like to allow that syntax of being able to assign zero to continue to be allowed - it isn't my favourite, but minimising friction to moving to newer code is often a necessity just to get people on board with using them.</p>\n<p>I also don't want to add a constructor that takes any int other than zero because that's very much absurd, was never allowed before, and it should continue to be caught at compile time.</p>\n<p>If such a thing is not possible, it would satisfy me to find an explanation, because with as much as I know so far, it makes no sense to me.</p>\n<p>This example has the same behaviour in VC++ (Intellisense seems to be OK with it though...), Clang, and GCC. Ideally a solution will also work in all 3 (4 with intellisense) compilers.</p>\n<p>A more directly applicable example is follows:</p>\n<pre><code>struct A {\n    A(){}\n    A(std::nullptr_t) {}\n};\n\ntemplate &lt;typename T&gt;\nstruct Wrapper {\n    A a;\n    Wrapper(const A&amp; a):a (a) {}\n\n    template &lt;typename T&gt;\n    Wrapper(T&amp;&amp; t): a(std::forward&lt;T&gt;(t)){}\n\n    Wrapper(){}\n};\n\nvoid foo2() {\n    A a1;\n    a1 = 0; // This works\n\n    Wrapper&lt;A&gt; a2;\n    a2 = 0; //This does not\n}\n</code></pre>\n</hr>", "Tags": "<c++><c++11><templates><template-meta-programming>", "OwnerUserId": "78823", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41582864_41583216_0": {"section_id": 39, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_41582864_41583216_0": {"section_id": 36, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_41582864_41583216_0": {"section_id": 39, "quality": 0.9090909090909091, "length": 20}}}});