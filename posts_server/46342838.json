post_cb({"bq_ids": {"n4140": {"so_46342838_46347559_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 5795}}, "n3337": {"so_46342838_46347559_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 5568}}, "n4659": {"so_46342838_46347559_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 7254}}}, "46342838": {"ViewCount": "176", "Body": "<p>We have empty base class optimization. Look at these two cases:</p>\n<p><strong>Case A</strong></p>\n<pre><code>struct Empty1 { };\nstruct Empty2 { };\nstruct One: Empty1, Empty2 { };\n</code></pre>\n<p>Here, <code>sizeof(One)</code> is 1. Addresses of <code>Empty1</code> and <code>Empty2</code> are the same.</p>\n<p><strong>Case B</strong></p>\n<pre><code>struct Empty { };\nstruct Empty1: public Empty { };\nstruct Empty2: public Empty { };\nstruct Two: Empty1, Empty2 { };\n</code></pre>\n<p>Here, <code>sizeof(Two)</code> is 2. Addresses of <code>Empty1</code> and <code>Empty2</code> differ, because both of them have <code>Empty</code> (and these <code>Empty</code>s should have differing addresses).</p>\n<p>Why does the standard allow to have the same address for differing types, but disallow for same types? What problem does this rule avoid?</p>\n<p>What problem will I have, if I create a <code>tuple</code> implementation where all empty members will have the same address (no matter of their types)?</p>\n", "AcceptedAnswerId": "46343655", "Title": "Reason behind that object addresses must differ if types are the same, but addresses can be the same if types differ", "CreationDate": "2017-09-21T11:31:45.193", "Id": "46342838", "CommentCount": "3", "LastEditDate": "2017-09-21T11:36:52.497", "PostTypeId": "1", "LastEditorUserId": "8157187", "LastActivityDate": "2017-09-21T20:07:55.563", "Score": "5", "OwnerUserId": "8157187", "Tags": "<c++>", "AnswerCount": "2"}, "46347559": {"Id": "46347559", "PostTypeId": "2", "Body": "<p>The rule is stated in the standard [intro.object]:</p>\n<blockquote>\n<p id=\"so_46342838_46347559_0\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address\n  of the first byte it occupies. Two objects a and b with overlapping lifetimes that are not bit-fields may have\n  the same address if one is nested within the other, or if at least one is a base class subobject of zero size and\n  they are of different types; otherwise, they have distinct addresses.</p>\n</blockquote>\n<p>One reason why an <em>empty base class</em> fall on this rule is because\none can cast an <em>empty base class</em> reference, to a reference of the base object.</p>\n<p>The best is to see it in action, I have added the assembly generated by gcc with -O3 optimization:</p>\n<pre><code>struct Empty1 { };\nstruct Empty2 { };\nstruct One: Empty1, Empty2 { \n  int i;\n};\nstruct Other{\n  int i;\n};\n\n//an Empty and a One may have the same address                                              \nint f(Empty1&amp; a,One&amp; b){   mov     DWORD PTR [rsi], 12  //write to *rsi\n  b.i=12;                  mov     DWORD PTR [rdi], 15  //may be rsi==rdi\n  auto&amp; a_one =            mov     eax, DWORD PTR [rsi] //reload from *rsi\n    static_cast&lt;One&amp;&gt;(a);  ret\n  a_one.i=15;                         \n  return b.i;                        \n}    \n\n//an int and a One may have the same address                                              \nint f(int&amp; a,One&amp; b){      mov     DWORD PTR [rsi], 12  //write to *rsi                           \n  b.i=12;                  mov     DWORD PTR [rdi], 15  //may be rsi==rdi                         \n  a=15;                    mov     eax, DWORD PTR [rsi] //reload from *rsi\n  return b.i;              ret                                                   \n}        \n\n//a long can not have the same address as a One \nint f(long&amp; a,One&amp; b){     mov     DWORD PTR [rsi], 12                        \n  b.i=12;                  mov     eax, 12  //aliasing optimization\n  a=15;                    mov     QWORD PTR [rdi], 15 //sure rsi!=rdi aliasing rule\n  return b.i;              ret                        \n}   \n\n//the int inside and Other can alias an int inside a One\nint f(Other&amp; a,One&amp; b){     mov     DWORD PTR [rsi], 12                        \n  b.i=12;                  mov     eax, 12  //aliasing optimization\n  a.i=15;                    mov     QWORD PTR [rdi], 15 //sure rsi!=rdi aliasing rule\n  return b.i;              ret                        \n}                                        \n</code></pre>\n<p>Only one complete object can exist at a given address. The complete object is the one that is not nested within another.</p>\n<p>It is impossible to succeed to have to object at the same address (without UB), with the same type. But since you object are empty, you do not need more than one in your optimized tuple. You will only need to implement a <code>get&lt;I&gt;</code> which referes to the same object for all <code>Is</code> that are meant to refer to object of of the same empty class.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2017-09-21T20:07:55.563", "Score": "1", "CreationDate": "2017-09-21T15:15:09.030", "ParentId": "46342838", "CommentCount": "2", "OwnerUserId": "5632316", "LastEditDate": "2017-09-21T20:07:55.563"}, "46343655": {"Id": "46343655", "PostTypeId": "2", "Body": "<p>The address is part of the identity of an object. Separate objects of the same type having separate addresses is a general rule. That's how you know that there is more than one object.</p>\n<p>In copy constructors you can often find a test for self-assignment <code>if (this != &amp;other)</code>. This would fail if different objects of the same type were to have the same address.</p>\n<p>Objects of different types cannot be compared like this anyway, so not a problem. And we also have a struct and its first member and an array and the first element that <em>have</em> the same address, but are of different types.</p>\n<p>The empty base class poses a problem here, but only if you have two base classes of the same type, or the base class happens to be of the same type as the first member of the derived class. So there are special rules to forbid the overlap of two identical objects in those cases.</p>\n<p>The idea is that they should be two separate sub-objects and work in a <code>this != &amp;that</code> test.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2017-09-21T12:33:10.727", "Score": "3", "CreationDate": "2017-09-21T12:13:49.473", "ParentId": "46342838", "CommentCount": "6", "OwnerUserId": "597607", "LastEditDate": "2017-09-21T12:33:10.727"}});