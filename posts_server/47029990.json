post_cb({"bq_ids": {"n4140": {"so_47029990_47030147_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}}, "n3337": {"so_47029990_47030147_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}}, "n4659": {"so_47029990_47030147_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}}}, "47029990": {"ViewCount": "57", "Body": "<p>I have a custom iterator class conforming to the bidirectional iterator requirements (but not random access).  However, the distance of two iterators can also be found in constant time.  Conceptually, <code>it2 - it1</code> is efficient, but <code>it += n</code> is not (neither of these operator overloads is actually implemented).</p>\n<p>Is it reasonable to overload <code>std::distance()</code> to allow standard library algorithms to compute distances efficiently with this iterator?</p>\n<p>I found conflicting information about the appropriateness of tampering with <code>std</code> namespace things.</p>\n", "AcceptedAnswerId": "47030147", "Title": "Is it reasonable to overload std functions such as std::distance?", "CreationDate": "2017-10-31T07:29:30.337", "Id": "47029990", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-10-31T07:41:14.560", "Score": "1", "OwnerUserId": "695132", "Tags": "<c++><iterator><c++-standard-library>", "AnswerCount": "1"}, "47030147": {"Id": "47030147", "PostTypeId": "2", "Body": "<p>With regard to namespace use, the holy standard says this:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4659/namespace.constraints#namespace.std-1\" rel=\"nofollow noreferrer\">[namespace.std]/1</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_47029990_47030147_0\">The behavior of a C++ program is undefined if it adds declarations or\n  definitions to namespace std or to a namespace within namespace std\n  unless otherwise specified. <strong>A program may add a template\n  specialization for any standard library template to namespace std only\n  if the declaration depends on a user-defined type and the\n  specialization meets the standard library requirements for the\n  original template and is not explicitly prohibited</strong>.</p>\n</blockquote>\n<p>So adding an overload is disallowed, since it's a new declaration. I couldn't find an explicit prohibition, and therefore believe that fully specializing the <code>std::distance</code> function template on your new iterator type should be fine. So long as you fulfill the requirements of the original template. The main requirement being that the return type must be the same as specified by the <code>std::iterator_traits&lt;InputIt&gt;::difference_type</code> meta-function. It may require you to specialize <code>std::iterator_traits</code> as well.</p>\n", "LastActivityDate": "2017-10-31T07:41:14.560", "CommentCount": "0", "CreationDate": "2017-10-31T07:41:14.560", "ParentId": "47029990", "Score": "2", "OwnerUserId": "817643"}});