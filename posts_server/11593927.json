post_cb({"11593927": {"ViewCount": "205", "Body": "<p>It seems that unlike the member functions, you don't get to specify which memory_order to use, so there's probably some 'default' that ends up being used.</p>\n", "AcceptedAnswerId": "11605751", "Title": "In C++11 std::atomic, what is the memory_order used for operators like ++, -- and +=?", "CreationDate": "2012-07-21T16:31:38.777", "Id": "11593927", "CommentCount": "0", "LastEditDate": "2012-07-23T07:30:52.373", "PostTypeId": "1", "LastEditorUserId": "777186", "LastActivityDate": "2012-07-23T07:30:52.373", "Score": "2", "OwnerUserId": "679688", "Tags": "<c++><c++11><std><atomic>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11593927_11605751_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 1181}}, "n3337": {"so_11593927_11605751_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 1179}}}, "11605751": {"PostTypeId": "2", "Body": "<p>According to the C++ Standard (\u00a729.7/35), the <strong>effect</strong> of calling <code>operator++</code> of an atomic type <code>A</code> with non-atomic base type <code>C</code>, i.e. one of these:</p>\n<pre><code>C A::operator++() volatile noexcept;\nC A::operator++() noexcept;\n</code></pre>\n<p><strong>is the same as that of calling the member function <code>fetch_add(1)</code></strong>, and according to \u00a729.5 (initial declarations), the latter is declared with a default argument:</p>\n<pre><code>C fetch_add(C, memory_order = memory_order_seq_cst) volatile noexcept;\nC fetch_add(C, memory_order = memory_order_seq_cst) noexcept;\n</code></pre>\n<p>for integral types <code>C</code>, and:</p>\n<pre><code>C* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile noexcept;\nC* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) noexcept;\n</code></pre>\n<p>for address types. <strong>In other words, the default memory order used by <code>operator++</code> is <code>memory_order_seq_cst</code>.</strong></p>\n<p>The Standard does not make any such statement about <code>operator+=</code>, although it seems natural to assume that what is true of <code>operator++</code> is also true of <code>operator+=</code> in this context.</p>\n<p>Also note there is the general rule for functions of atomic types defined by the Standard:</p>\n<blockquote>\n<p id=\"so_11593927_11605751_0\">(\u00a729.6.5/2) [...] the free functions not ending in <code>_explicit</code> have the semantics of their corresponding <code>_explicit</code> with memory_order arguments of <code>memory_order_seq_cst</code>.</p>\n</blockquote>\n", "LastActivityDate": "2012-07-23T02:26:00.397", "Id": "11605751", "CommentCount": "0", "CreationDate": "2012-07-23T02:26:00.397", "ParentId": "11593927", "Score": "6", "OwnerUserId": "777186"}, "11593955": {"PostTypeId": "2", "Body": "<p>Default is \"sequentially consistent\".</p>\n", "LastActivityDate": "2012-07-21T16:34:10.313", "Id": "11593955", "CommentCount": "0", "CreationDate": "2012-07-21T16:34:10.313", "ParentId": "11593927", "Score": "7", "OwnerUserId": "51831"}});