post_cb({"14065392": {"Id": "14065392", "PostTypeId": "2", "Body": "<p>The relevant quote from the Standard is actually this:</p>\n<blockquote>\n<p id=\"so_14065337_14065392_0\">(\u00a75.3.1/8) The operand of the unary - operator shall have arithmetic or unscoped enumeration type and the result is the negation of its operand. Integral promotion is performed on integral or enumeration operands. The negative of an unsigned quantity is computed by subtracting its value from 2<sup>n</sup>, where n is the number of bits in the promoted operand. The type of the result is the type of the promoted operand.</p>\n</blockquote>\n<p>(This is from C++11; it used to be 5.3.1/7 in older versions.)</p>\n<p>So <code>-num</code> will be evaluated as 2<sup>CHAR_BIT*sizeof(num)</sup> - num <sup>(&amp;ddagger;)</sup>. The result will be of the same type as the operand (after integer promotion), i.e. it will also be unsigned.</p>\n<p>I just tested with GCC and it seems to perform the operation in precisely the way described by the Standard. I'll assume this is the case for Visual C++ as well; otherwise it's a bug.</p>\n<hr>\n<p><sup>(&amp;ddagger;)</sup> This formula assumes that the relevant <em>number of bits</em> corresponds to the size (in bits) of the variable in memory. As Keith Thompson points out in the comment, this can't be true if there are padding bits (i.e. when not all bits participate in the representation of the numerical value, which is possible according to \u00a73.9.1/1). On a system that uses more bits to store the value than are used to represent the numerical value, the formula will not be accurate. (I, personally, am not actually aware of any such system, though.)</p>\n</hr>", "LastEditorUserId": "777186", "LastActivityDate": "2012-12-30T05:38:22.880", "Score": "12", "CreationDate": "2012-12-28T06:12:19.820", "ParentId": "14065337", "CommentCount": "2", "LastEditDate": "2012-12-30T05:38:22.880", "OwnerUserId": "777186"}, "14065337": {"ViewCount": "645", "Body": "<p>For example:</p>\n<pre><code>unsigned int numA = 66; // or anything really\nunsigned int numB = -numA;\nunsigned int numC = numA &amp; numB\n</code></pre>\n<p>I understand that the bitwise complement operator can be used to get the two's complement (in conjunction with a +1).</p>\n<p>The reason I ask is because I stumbled upon this in some code for a chess engine. Chess engines do a lot of 'hacky' things to get absolute speed, especially in the move generation functions that are called millions of times per second. (It doesn't help that it was an example of magic bitboard move generation - the most optimized of them all). This chess engine code in particular only works correctly under gcc compilation (I suspect).</p>\n<p>How do different compilers treat this? In particular, how does gcc handle this compared to the C++ compiler in VS Studio 2012 Express.</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "14065392", "Title": "What does the unary operator \"-\" do on unsigned data types in C/C++ (and on different compilers)?", "CreationDate": "2012-12-28T06:06:00.843", "Id": "14065337", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-12-30T04:17:12.237", "LastEditorUserId": "862773", "LastActivityDate": "2014-09-28T21:25:13.220", "Score": "6", "OwnerUserId": "862773", "Tags": "<c++><c><compiler-construction><unsigned>", "AnswerCount": "4"}, "26089823": {"Id": "26089823", "PostTypeId": "2", "Body": "<p>I was bitten by the typeof(-Unsigned) is Unsigned. The VS2012 compiler takes this to interesting levels of inscrutable behaviour:</p>\n<p>unsigned x = 0xFFFFFFFE;\nint y = -x/2;</p>\n<p>What is \"y\"?</p>\n<p>I would have expected x/2 = 0x7FFFFFFF, then -(x/2) = 0x80000001, i.e. -2**31-1.\nInstead, the compiler generates (-x) = 0x00000002, (-x)/2 = 0x00000001.</p>\n<p>I guess that for boundary values, it's all Deathstar 9000. Sigh.</p>\n", "LastActivityDate": "2014-09-28T21:25:13.220", "Score": "0", "CreationDate": "2014-09-28T21:25:13.220", "ParentId": "14065337", "CommentCount": "2", "OwnerUserId": "205874"}, "bq_ids": {"n4140": {"so_14065337_14065392_0": {"length": 35, "quality": 0.8974358974358975, "section_id": 6071}, "so_14065337_14088595_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 7213}, "so_14065337_14065375_0": {"length": 29, "quality": 0.90625, "section_id": 31}}, "n3337": {"so_14065337_14065392_0": {"length": 35, "quality": 0.8974358974358975, "section_id": 5839}, "so_14065337_14088595_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 6957}, "so_14065337_14065375_0": {"length": 29, "quality": 0.90625, "section_id": 28}}, "n4659": {"so_14065337_14065392_0": {"length": 35, "quality": 0.8974358974358975, "section_id": 7567}, "so_14065337_14088595_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 8722}, "so_14065337_14065375_0": {"length": 29, "quality": 0.90625, "section_id": 31}}}, "14088595": {"Id": "14088595", "PostTypeId": "2", "Body": "<p>You asked about both C and C++. Remember that they're two different languages. In this particular case, they have the same rules for operations on unsigned types, but they're expressed differently.</p>\n<p>Quoting the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">latest draft</a> of the current (2011) ISO C standard), section 6.2.5p9:</p>\n<blockquote>\n<p id=\"so_14065337_14088595_0\">A computation involving unsigned operands can never overflow, because\n  a result that cannot be represented by the resulting unsigned integer\n  type is reduced modulo the number that is one greater than the largest\n  value that can be represented by the resulting type.</p>\n</blockquote>\n<p>The description of the unary \"-\" operator merely says that the result is \"the negative of its (promoted) operand\"; it assumes that the reader has read 6.2.5 to figure out what the \"negative\" of an unsigned integer is.</p>\n<p>In either language, the result of:</p>\n<pre><code>unsigned int numA = 66;\nunsigned int numB = -numA;\n</code></pre>\n<p>is to store <code>UINT_MAX - 66U + 1U</code> in <code>numB</code>. (The <code>U</code> suffixes aren't really necessary, but I include them to emphasize that this is all defined in terms of unsigned values.)</p>\n", "LastActivityDate": "2012-12-30T05:39:03.637", "Score": "1", "CreationDate": "2012-12-30T05:39:03.637", "ParentId": "14065337", "CommentCount": "0", "OwnerUserId": "827263"}, "14065375": {"Id": "14065375", "PostTypeId": "2", "Body": "<p>Here's what C++ standard says under section 4.7.2 (Integral conversions):</p>\n<blockquote>\n<p id=\"so_14065337_14065375_0\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n\n  is the number of bits used to represent the unsigned type). [ Note: In\n  a two\u2019s complement representation, this conversion is conceptual and\n  there is no change in the bit pattern (if there is no truncation).\n  \u2014end note ]</p>\n</blockquote>\n<p>Hope this answers your question.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2012-12-30T05:23:10.740", "Score": "3", "CreationDate": "2012-12-28T06:10:13.920", "ParentId": "14065337", "CommentCount": "1", "LastEditDate": "2012-12-30T05:23:10.740", "OwnerUserId": "312291"}});