post_cb({"bq_ids": {"n4140": {"so_24398426_24398510_0": {"length": 73, "quality": 0.9012345679012346, "section_id": 7187}, "so_24398426_24398510_1": {"length": 12, "quality": 1.0, "section_id": 7223}}, "n3337": {"so_24398426_24398510_0": {"length": 68, "quality": 0.8395061728395061, "section_id": 6931}, "so_24398426_24398510_1": {"length": 12, "quality": 1.0, "section_id": 6967}}, "n4659": {"so_24398426_24398510_0": {"length": 72, "quality": 0.8888888888888888, "section_id": 8695}, "so_24398426_24398510_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 8732}}}, "24398510": {"Id": "24398510", "PostTypeId": "2", "Body": "<p>The Standard places implementations into two general categories:</p>\n<ul>\n<li>Those with strict pointer safety</li>\n<li>Those with relaxed pointer safety</li>\n</ul>\n<p>Your expression definitely is not a safely-derived pointer, so it's invalid in the first.</p>\n<p>Quote from 3.7.4.3:</p>\n<blockquote>\n<p id=\"so_24398426_24398510_0\">An implementation may have <em>relaxed pointer safety</em>, in which case the validity of a pointer value does not depend on whether it is a safely-derived pointer value.  Alternatively,  an implementation may have <em>strict pointer safety</em>, in which case a pointer value referring to an object with dynamic storage duration that is not a safely-derived pointer value is an invalid pointer value unless the referenced complete object has previously been declared reachable (20.7.4).  [ Note:  the effect of using an invalid pointer value (including passing it to a deallocation function) is undefined, see 3.7.4.2.  This is true even if the unsafely-derived pointer value might compare equal to some safely-derived pointer value.  \u2014 end note ] It is implementation defined whether an implementation has relaxed or strict pointer safety.</p>\n</blockquote>\n<p>For implementations with relaxed safety, it doesn't matter how the pointer value is gotten, just that (3.9.2):</p>\n<blockquote>\n<p id=\"so_24398426_24398510_1\">A valid value of an object pointer type represents either the address of a byte in memory (1.7) or a null pointer.</p>\n</blockquote>\n<p>Is <code>0x1</code> a valid memory address on your system?  Well, for some embedded systems it is.  For most OSes using virtual memory, the page beginning at zero is reserved as invalid.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-06-25T00:51:12.087", "Score": "8", "CreationDate": "2014-06-25T00:42:22.587", "ParentId": "24398426", "CommentCount": "6", "LastEditDate": "2014-06-25T00:51:12.087", "OwnerUserId": "103167"}, "24398426": {"ViewCount": "234", "Body": "<p>In the comments to <a href=\"https://stackoverflow.com/a/24398173/3002139\">this</a> answer I stumbled about a discussion about the meaning of \"valid pointer\". Since I think that that is interesting in general:</p>\n<p>What is a \"valid pointer\" in C++?</p>\n<p>In particular:</p>\n<p>Is <code>reinterpret_cast&lt;const void*&gt;(0x1)</code> a valid pointer?</p>\n", "AcceptedAnswerId": "24398510", "Title": "Meaning of valid pointer", "CreationDate": "2014-06-25T00:30:56.777", "Id": "24398426", "CommentCount": "1", "LastEditDate": "2017-05-23T12:10:59.870", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-25T00:51:12.087", "Score": "5", "OwnerUserId": "3002139", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});