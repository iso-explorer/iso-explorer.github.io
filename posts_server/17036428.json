post_cb({"bq_ids": {"n4140": {"so_17036428_17036478_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 1056}}, "n3337": {"so_17036428_17036478_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 1041}}}, "17036478": {"PostTypeId": "2", "Body": "<p>Yes, this is what <code>operator[]</code> of <code>std::map</code> is supposed to do. From the Standard (C++11, \u00a723.5.4.3):</p>\n<blockquote>\n<pre><code>mapped_type&amp; operator[](const key_type&amp; k);\nmapped_type&amp; operator[](key_type&amp;&amp; k);\n</code></pre>\n<p id=\"so_17036428_17036478_0\">[...]</p>\n<p id=\"so_17036428_17036478_1\">Effects: If the unordered_map does not already contain an element whose key is equivalent to k, the first operator inserts the value <code>value_type(k, mapped_type())</code> and the second operator inserts the value <code>value_type(std::move(k), mapped_type())</code>.</p>\n</blockquote>\n<p>Note that this would happen even if the element had never been inserted and then erased. Element access using <code>operator[]</code> simply inserts fresh, default-constructed values when you apply it to non-existing keys.</p>\n<p>If you don't want this, best use the <code>find</code> function of <code>std::map</code>. That will return an <code>end</code>-iterator if the key doesn't exist.</p>\n", "LastActivityDate": "2013-06-11T04:41:04.397", "LastEditorUserId": "777186", "Id": "17036478", "CommentCount": "0", "CreationDate": "2013-06-11T04:24:03.500", "ParentId": "17036428", "Score": "5", "OwnerUserId": "777186", "LastEditDate": "2013-06-11T04:41:04.397"}, "17036539": {"PostTypeId": "2", "Body": "<p>Yes, this is expected behaviour. In addition to reading the specification, you can infer this from the type signature:</p>\n<pre><code>T&amp; operator[] (const key_type&amp; k);\n</code></pre>\n<p>It can't tell if you'll end up assigning to the key because <code>operator =</code> is called on its return value, after the <code>[]</code> operator has already finished executing. There is also no way for the method to represent an empty value: it returns a reference, not a pointer.</p>\n", "LastActivityDate": "2013-06-11T04:31:27.127", "Id": "17036539", "CommentCount": "3", "CreationDate": "2013-06-11T04:31:27.127", "ParentId": "17036428", "Score": "2", "OwnerUserId": "768535"}, "17036428": {"ViewCount": "438", "Body": "<p>Playing around with C++ standard library's std::map class, and noticed if I erase an element, then attempt to reference it (the commented out line in the code below), the element will come back with a value of 0. Is this expected? Do you really have to use a find function to  access an element without accidentally creating one if it doesn't exist?</p>\n<p>compiler setup: I'm compiling on osx 10.8.3 with g++ i686-apple-darwin11-llvm-g++-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)</p>\n<pre><code>using namespace std;\n\nmap&lt;int,int&gt; myMap;\nmap&lt;int,int&gt;::iterator it;\n\nmyMap[1] = 5;\n\nfor (it=myMap.begin(); it!=myMap.end(); ++it)\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n';\n\nprintf(\"map test result: %d\\n\", myMap[1]);\n\nit = myMap.find(1);\nmyMap.erase( it );\n\n// If I uncomment this it will cause a 0 value to occur at key 1.\n//printf(\"map test result: %d\\n\", myMap[1]);\n\nif (myMap.find(1) == myMap.end())\n    puts(\"element key 1 is null, ok\");\nelse\n    puts(\"element @ key 1 exists, error\");\n\nif (myMap.empty())\n    puts(\"map is empty\");\nelse\n    puts(\"map is not empty, error\");\n\nfor (it=myMap.begin(); it!=myMap.end(); ++it)\n    std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n';\n</code></pre>\n<p>Just to clarify, if I run this with the second printf line commented, it runs as expected:</p>\n<pre class=\"lang-none prettyprint-override\"><code>1 =&gt; 5\nmap test result: 5\nelement key 1 is null, ok\nmap is empty\n</code></pre>\n<p>If I run with the line uncommented, the access of myMap[1] in the printf statement creates another element, and leaves this result:</p>\n<pre class=\"lang-none prettyprint-override\"><code>1 =&gt; 5\nmap test result: 5\nmap test result: 0\nelement @ key 1 exists, error\nmap is not empty, error\n1 =&gt; 0\n</code></pre>\n", "AcceptedAnswerId": "17036478", "Title": "C++ map element doesn't get erased if I refer to it", "CreationDate": "2013-06-11T04:18:06.983", "Id": "17036428", "CommentCount": "0", "LastEditDate": "2013-06-11T04:59:06.940", "PostTypeId": "1", "LastEditorUserId": "768535", "LastActivityDate": "2013-06-11T04:59:06.940", "Score": "2", "OwnerUserId": "314780", "Tags": "<c++><map><std>", "AnswerCount": "2"}});