post_cb({"bq_ids": {"n4140": {"so_37134319_37134453_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 6046}, "so_37134319_37134453_2": {"length": 27, "quality": 1.0, "section_id": 6049}, "so_37134319_37134453_0": {"length": 36, "quality": 0.9, "section_id": 6049}, "so_37134319_37134453_1": {"length": 20, "quality": 1.0, "section_id": 6049}}, "n3337": {"so_37134319_37134453_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 5814}, "so_37134319_37134453_2": {"length": 27, "quality": 1.0, "section_id": 5817}, "so_37134319_37134453_0": {"length": 36, "quality": 0.9, "section_id": 5817}, "so_37134319_37134453_1": {"length": 20, "quality": 1.0, "section_id": 5817}}, "n4659": {"so_37134319_37134453_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 7545}, "so_37134319_37134453_2": {"length": 27, "quality": 1.0, "section_id": 7548}, "so_37134319_37134453_0": {"length": 36, "quality": 0.9, "section_id": 7548}, "so_37134319_37134453_1": {"length": 20, "quality": 1.0, "section_id": 7548}}}, "37134453": {"Id": "37134453", "PostTypeId": "2", "Body": "<p>At <a href=\"http://eel.is/c++draft/expr.reinterpret.cast#10\" rel=\"nofollow\">[expr.reinterpret.cast]</a> the C++ draft states:</p>\n<blockquote>\n<p id=\"so_37134319_37134453_0\">A prvalue of type \u201cpointer to member of <code>X</code> of type <code>T1</code>\u201d can be explicitly converted to a prvalue of a different type \u201cpointer to member of <code>Y</code> of type <code>T2</code>\u201d if <code>T1</code> and <code>T2</code> are both function types or both object types.<sup>72</sup> The null member pointer value (<a href=\"http://eel.is/c++draft/conv.mem\" rel=\"nofollow\">[conv.mem]</a>) is converted to the null member pointer value of the destination type. The result of this conversion is unspecified, except in the following cases:</p>\n<ul>\n<li><p id=\"so_37134319_37134453_1\">converting a prvalue of type \u201cpointer to member function\u201d to a different pointer to member function type and back to its original type yields the original pointer to member value.</p></li>\n<li><p id=\"so_37134319_37134453_2\">converting a prvalue of type \u201cpointer to data member of <code>X</code> of type <code>T1</code>\u201d to the type \u201cpointer to data member of <code>Y</code> of type <code>T2</code>\u201d (where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer to member value. </p></li>\n</ul>\n</blockquote>\n<blockquote>\n<p id=\"so_37134319_37134453_3\">72) <code>T1</code> and <code>T2</code> may have different <em>cv</em>-qualifiers, subject to the overall restriction that a <code>reinterpret_cast</code> cannot cast away constness.</p>\n</blockquote>\n<p>Since you are converting your \"pointer to member function\" to a different \"pointer to member function\" type and back, it yields the original value. This is both legal and well-defined behaviour. So your code should work properly.</p>\n", "LastEditorUserId": "3919155", "LastActivityDate": "2016-07-28T12:04:17.100", "Score": "10", "CreationDate": "2016-05-10T09:30:58.447", "ParentId": "37134319", "CommentCount": "0", "OwnerUserId": "3919155", "LastEditDate": "2016-07-28T12:04:17.100"}, "37134319": {"ViewCount": "150", "Body": "<p>Is it legal to cast a pointer-to-member-function to another pointer-to-member-function of the same class using <code>reinterpret_cast</code>? The following example works. But is it legal?</p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;string&gt;\n\nclass A\n{\n    public:\n    void func_int(int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }\n    void func_string(std::string const&amp; x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    std::vector&lt;void(A::*)()&gt; v;\n    v.push_back(reinterpret_cast&lt;void(A::*)()&gt;(&amp;A::func_int));\n    v.push_back(reinterpret_cast&lt;void(A::*)()&gt;(&amp;A::func_string));\n    A a;\n    (a.*reinterpret_cast&lt;void(A::*)(int)&gt;(v[0]))(5);\n    (a.*reinterpret_cast&lt;void(A::*)(std::string const&amp;)&gt;(v[1]))(std::string{\"Test\"});\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "37134453", "Title": "Cast one pointer-to-member-function to another of same class", "CreationDate": "2016-05-10T09:24:46.883", "Id": "37134319", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-07-28T12:04:17.100", "Score": "9", "OwnerUserId": "3425723", "Tags": "<c++><member-function-pointers><reinterpret-cast>", "AnswerCount": "1"}});