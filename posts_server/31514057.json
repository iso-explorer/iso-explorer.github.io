post_cb({"31514057": {"CommentCount": "1", "ViewCount": "56", "CreationDate": "2015-07-20T10:22:00.203", "LastActivityDate": "2015-07-20T10:37:40.027", "Title": "Implicit conversion in the other direction", "AcceptedAnswerId": "31514112", "PostTypeId": "1", "Id": "31514057", "Score": "1", "Body": "<p>A wrapper class is nice when you can't modify the wrapped class. With the wrapper I can add certain functionality and convenience, and I can still make the wrapper accepted in functions that use the wrapped type by using an implicit conversion from the wrapper to the wrapped type. Something like this:</p>\n<pre><code>struct vec {\n    __m128 m128;\n    inline operator __m128 &amp;() {\n        return m128;\n    }\n    //convenience to add functionality related to the wrapped variable inserted here\n}\n</code></pre>\n<p>And this works well.</p>\n<p>Now my question is, can you implicitly convert the other way around, from __m128 to vec, when you have no access to the wrapped type source or can't modify it?</p>\n", "Tags": "<c++>", "OwnerUserId": "1525061", "AnswerCount": "2"}, "31514105": {"ParentId": "31514057", "CommentCount": "0", "Body": "<p>Yes, just write a constructor taking a single <code>__m128</code> which is not marked <code>explicit</code>:</p>\n<pre><code>vec (__m128 m128) //maybe take by const-ref (I don't know what __m128 is)\n  : m128(m128)\n{}\n</code></pre>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "31514105", "Score": "5", "CreationDate": "2015-07-20T10:24:28.973", "LastActivityDate": "2015-07-20T10:24:28.973"}, "31514112": {"ParentId": "31514057", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can just add a constructor that <sup>(1)</sup>accepts a single <code>__m128</code> argument. If you don't add <code>explicit</code> then it provides an implicit conversion. This is called a <strong>converting constructor</strong>.</p>\n\nC++03 12.3.1/1\n\n<blockquote>\n<p id=\"so_31514057_31514112_0\"><strong>\u201d</strong> A constructor declared without the <em>function-specifier</em> <code>explicit</code> that can be called with a single parameter specifies a conversion from the type of its first parameter to the type of its class. Such a constructor is called a converting constructor.</p>\n</blockquote>\n<p>C++11 (quite unreasonably, IMHO) extended the meaning of the term to cover \u201cconversion\u201d from multiple specified arguments, to the type of the constructor's class:</p>\n\nC++11 12.3.1/1\n\n<blockquote>\n<p id=\"so_31514057_31514112_1\"><strong>\u201d</strong> A constructor declared without the <em>function-specifier</em> <code>explicit</code> specifies a conversion from the types of its\n  parameters to the type of its class. Such a constructor is called a <em>converting constructor</em>.</p>\n</blockquote>\n<hr>\n<p><sup>\n<sup>1)</sup> If it has more arguments then these must be defaulted or be a <code>...</code> ellipsis.\n</sup></p>\n</hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2015-07-20T10:37:40.027", "Id": "31514112", "Score": "3", "CreationDate": "2015-07-20T10:24:48.753", "LastActivityDate": "2015-07-20T10:37:40.027"}, "bq_ids": {"n4140": {"so_31514057_31514112_0": {"section_id": 388, "quality": 0.6363636363636364, "length": 14}, "so_31514057_31514112_1": {"section_id": 388, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_31514057_31514112_0": {"section_id": 379, "quality": 0.6363636363636364, "length": 14}, "so_31514057_31514112_1": {"section_id": 379, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_31514057_31514112_0": {"section_id": 405, "quality": 0.6363636363636364, "length": 14}, "so_31514057_31514112_1": {"section_id": 405, "quality": 0.9411764705882353, "length": 16}}}});