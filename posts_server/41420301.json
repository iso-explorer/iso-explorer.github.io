post_cb({"41420301": {"ViewCount": "395", "Body": "<p>I've implemented a <code>constexpr</code> array like this:</p>\n<pre><code>template &lt;typename T&gt;\nclass const_array {\n  const T* p;\n  unsigned n;\npublic:\n  template &lt;unsigned N&gt;\n  constexpr const_array(const T(&amp;a)[N]): p(a), n(N) { }\n\n  constexpr unsigned size() const { return n; }\n};\n\nint main(int argc, char* argv[]) {\n  // works\n  static_assert(const_array&lt;double&gt;{{1.,2.,3.}}.size() == 3);\n\n  // doesn't compile\n  constexpr const_array&lt;double&gt; a{{1.,2.,3.}};\n  static_assert(a.size() == 3);\n}\n</code></pre>\n<p>Why is it that the first <code>static_assert</code> compiles, but initializing <code>a</code> fails?I'm using gcc 6.2.0. I'm getting</p>\n<pre><code>: In function 'int main(int, char**)':\n: error: 'const_array&lt;double&gt;{((const double*)(&amp;&lt;anonymous&gt;)), 3u}' is not a constant expression\n   constexpr const_array&lt;double&gt; a{{1.,2.,3.}};\n                                        ^\ntest/const_array.cc:17:3: error: non-constant condition for static assertion\n   static_assert(a.size() == 3);\n   ^~~~~~~~~~~~~\n</code></pre>\n", "AcceptedAnswerId": "42777137", "Title": "Cannot construct constexpr array from braced-init-list", "CreationDate": "2017-01-02T00:43:15.650", "Id": "41420301", "CommentCount": "6", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-03-13T16:04:09.863", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-16T17:12:49.783", "Score": "14", "OwnerUserId": "2640636", "Tags": "<c++><arrays><constructor><c++14><constexpr>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41420301_42777137_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6187}}, "n3337": {"so_41420301_42777137_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 5947}}, "n4659": {"so_41420301_42777137_0": {"length": 19, "quality": 1.0, "section_id": 7690}}}, "42840633": {"Id": "42840633", "PostTypeId": "2", "Body": "<p>The problem was that you cannot imbue the constant nature of the pointer to T in the inner template through the outer template's T parameter.</p>\n<pre><code>template &lt;typename T&gt; class const_array {\n    const T * p;\n    unsigned n;\npublic:\n    template &lt;unsigned N&gt;\n        constexpr const_array(const T(&amp; a)[N]): p(a), n(N) { }\n};\n\nint main(int argc, char* argv[]) {\n    constexpr const_array&lt;double&gt; ca{(const double []) { 1., 2. }};\n    return 0;\n}\n</code></pre>\n<p>I tried a few dozen permutations to get rid of the cast without success.</p>\n", "LastActivityDate": "2017-03-16T17:12:49.783", "CommentCount": "4", "CreationDate": "2017-03-16T17:12:49.783", "ParentId": "41420301", "Score": "0", "OwnerUserId": "5410835"}, "42777137": {"Id": "42777137", "PostTypeId": "2", "Body": "<p>The compiler is complaining that the initializer of <code>a.p</code> is not a constant expression. It's failing \u00a75.20/5.2:</p>\n<blockquote>\n<p id=\"so_41420301_42777137_0\">if the value is of pointer type, it contains the address of an object with static storage duration, the address past the end of such an object (5.7), the address of a function, or a null pointer value</p>\n</blockquote>\n<p>In other words, only pointer values known to the linker are valid constants. (Also, in your example the pointer is dangling.)</p>\n<p>The first <code>static_assert</code> doesn't trip this because <code>p</code> is discarded and the value of <code>n</code> is a constant expression. Constant expressions may have non-constant subexpressions.</p>\n<p>This works:</p>\n<pre><code>static constexpr double arr[] = { 1.,2.,3. };\nconstexpr const_array&lt;double&gt; a{ arr };\nstatic_assert( a.size() == 3 );\n</code></pre>\n<p>Credit to @Jarod42 for pointing out the issue in the comments.</p>\n", "LastActivityDate": "2017-03-14T03:13:04.580", "CommentCount": "8", "CreationDate": "2017-03-14T03:13:04.580", "ParentId": "41420301", "Score": "11", "OwnerUserId": "153285"}});