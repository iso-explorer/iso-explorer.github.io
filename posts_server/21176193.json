post_cb({"21176415": {"ParentId": "21176193", "CommentCount": "4", "Body": "<p>The use of a character type to inspect the representations of objects is a hack. However, it is historical, and some accommodation must be made to allow it.</p>\n<p>Mostly, in programming languages, we want strong typing. Something that is a <code>float</code> should be accessed as a <code>float</code> and not as an <code>int</code>. This has a number of benefits, including reducing human errors and enabling various optimizations.</p>\n<p>However, there are times when it is necessary to access or modify the bytes of an object. In C, this was done through character types. C++ continues that tradition, but it improves the situation slightly by eliminating the use of <code>signed char</code> for these purposes.</p>\n<p>Ideally, it might have been better to create a new type, say <code>byte</code>, and to allow byte access to object representations only through this type, thus separating the regular character types only for use as normal integers/characters. Perhaps it was thought there was too much existing code using <code>char</code> and <code>unsigned char</code> to support such a change. However, I have never seen <code>signed char</code> used to access the representation of an object, so it was safe to exclude it.</p>\n", "OwnerUserId": "298225", "PostTypeId": "2", "Id": "21176415", "Score": "5", "CreationDate": "2014-01-17T01:43:40.797", "LastActivityDate": "2014-01-17T01:43:40.797"}, "bq_ids": {"n4140": {"so_21176193_21176193_5": {"section_id": 7200, "quality": 0.975609756097561, "length": 40}, "so_21176193_21176278_0": {"section_id": 7210, "quality": 0.8709677419354839, "length": 27}, "so_21176193_21176193_3": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_21176193_21176193_5": {"section_id": 6944, "quality": 0.975609756097561, "length": 40}, "so_21176193_21176278_0": {"section_id": 6954, "quality": 0.8709677419354839, "length": 27}, "so_21176193_21176193_3": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_21176193_21176193_5": {"section_id": 8709, "quality": 0.9024390243902439, "length": 37}, "so_21176193_21176278_0": {"section_id": 8719, "quality": 0.8709677419354839, "length": 27}, "so_21176193_21176193_3": {"section_id": 8748, "quality": 1.0, "length": 14}}}, "21195047": {"ParentId": "21176193", "CommentCount": "1", "Body": "<p>Here's my take on the motivation:</p>\n<p>On a non-twos-complement system, <code>signed char</code> will not be suitable for accessing the representation of an object. This is because either there are two possible <code>signed char</code> representations which have the same value (+0 and -0), or one representation that has no value (a trap representation). In either case, this prevents you from doing most meaningful things you might do with the representation of an object. For example, if you have a 16-bit unsigned integer <code>0x80ff</code>, one or the other byte, as a <code>signed char</code>, is going to either trap or compare equal to 0.</p>\n<p>Note that on such an implementation (non-twos-complement), plain <code>char</code> needs to be defined as an unsigned type for accessing the representations of objects via <code>char</code> to work correctly. While there's no explicit requirement, I see this as a requirement derived from other requirements in the standard.</p>\n", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "21195047", "Score": "10", "CreationDate": "2014-01-17T20:15:13.403", "LastActivityDate": "2014-01-17T20:15:13.403"}, "21176278": {"ParentId": "21176193", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2014-01-17T01:30:52.010", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:37.033", "Id": "21176278", "OwnerUserId": "560648", "Body": "<p>I think what you're really asking is why <code>signed char</code> is disqualified from all the rules allowing type-punning to <code>char*</code> as a special case. To be honest, I don't know, especially since \u2014 as far as I can tell \u2014 <code>signed char</code> cannot have padding either:</p>\n<blockquote>\n<p id=\"so_21176193_21176278_0\"><code>[C++11: 3.9.1/1]:</code> <em>[..]</em> A <code>char</code>, a <code>signed char</code>, and an <code>unsigned char</code> occupy the same amount of storage and have the same alignment requirements (3.11); that is, they have the same object representation. For character types, all bits of the object representation participate in the value representation. <em>[..]</em></p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/q/653336/560648\">Empirical evidence suggests that it's not much more than convention</a>:</p>\n<ul>\n<li><code>char</code> is seen as a byte of ASCII;</li>\n<li><code>unsigned char</code> is seen as a byte with arbitrary \"binary\" content; and</li>\n<li><code>signed char</code> is left flapping in the wind.</li>\n</ul>\n<p>To me, it doesn't seem like enough of a reason to exclude it from these standard rules, but I honestly can't find any evidence to the contrary. I'm going to put it down to a mildly inexplicable oddity in the standard wording.</p>\n<p><sup>(It may be that we have to ask the <code>std-discussion</code> list about this.)</sup></p>\n", "LastActivityDate": "2014-01-17T01:36:52.943"}, "21176193": {"CommentCount": "16", "CreationDate": "2014-01-17T01:21:36.343", "PostTypeId": "1", "AcceptedAnswerId": "21195047", "LastEditorUserId": "1143634", "LastActivityDate": "2014-01-17T20:15:13.403", "LastEditDate": "2014-01-17T01:58:13.050", "ViewCount": "783", "FavoriteCount": "1", "Title": "Why C/C++ hate signed char so much?", "Id": "21176193", "Score": "10", "Body": "<p>Why does C allow accessing object using \"character type\":</p>\n<blockquote>\n<p id=\"so_21176193_21176193_0\"><strong>6.5 Expressions</strong> (C)</p>\n<p id=\"so_21176193_21176193_1\">An object shall have its stored value accessed only by an lvalue expression that has one ofthe following types:</p>\n<ul>\n<li>a character type.</li>\n</ul>\n</blockquote>\n<p>but C++ only allows <strong>char</strong> and <strong>unsigned char</strong>?</p>\n<blockquote>\n<p id=\"so_21176193_21176193_2\"><strong>3.10 Lvalues and rvalues</strong> (C++)</p>\n<p id=\"so_21176193_21176193_3\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>Another portion of signed char hatred (quote from C++ standard):</p>\n<blockquote>\n<p id=\"so_21176193_21176193_4\"><strong>3.9 Types</strong> (C++)</p>\n<p id=\"so_21176193_21176193_5\">For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object holds a valid value of type T, the underlying bytes making up the object can be copied into an array of <strong>char</strong> or <strong>unsigned char</strong>. If the content of the array of <strong>char</strong> or <strong>unsigned char</strong> is copied back into the object, the object shall subsequently hold its original value.</p>\n</blockquote>\n<p>And from C standard:</p>\n<blockquote>\n<p id=\"so_21176193_21176193_6\"><strong>6.2.6 Representations of types</strong> (C)</p>\n<p id=\"so_21176193_21176193_7\">Values stored in non-bit-field objects of any other object type consist of n \u00d7 CHAR_BIT bits, where n is the size of an object of that type, in bytes. The value may be copied into an object of type <strong>unsigned char</strong> [n] (e.g., by memcpy); the resulting set of bytes is called the object representation of the value.</p>\n</blockquote>\n<p>I can see many people on stackoverflow saying that is because <strong>unsigned char</strong> is the only character type that guaranteed to not have padding bits, but C99 Section <strong>6.2.6.2 Integer types</strong> says</p>\n<blockquote>\n<p id=\"so_21176193_21176193_8\">signed char shall not have any padding bits</p>\n</blockquote>\n<p>So what is the real reason behind this?</p>\n", "Tags": "<c++><c><char>", "OwnerUserId": "1143634", "AnswerCount": "3"}});