post_cb({"8380830": {"ParentId": "8379002", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>n3242 \u00a714.7.1/1</p>\n<blockquote>\n<p id=\"so_8379002_8380830_0\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),\n  <strong>the class template specialization is implicitly instantiated when the specialization is referenced in a context\n  that requires a completely-defined object type or <em>when the completeness of the class type affects the semantics\n  of the program.</em></strong> The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions or default arguments, of the class member functions,\n  member classes, static data members and member templates; and it causes the implicit instantiation\n  of the definitions of member anonymous unions. Unless a member of a class template or a member template\n  has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated\n  when the specialization is referenced in a context that requires the member definition to exist; in\n  particular, the initialization (and any associated side-effects) of a static data member does not occur unless\n  the static data member is itself used in a way that requires the definition of the static data member to exist.</p>\n</blockquote>\n<p>It seems to me that <code>static_cast</code> would require the instantiation of the declarations, but not of the definitions (as you are just dealing with pointers).</p>\n<p>n3242 \u00a714.6.5/1</p>\n<blockquote>\n<p id=\"so_8379002_8380830_1\">Friend classes or functions can be declared within a class template. When a template is instantiated, the\n  names of its friends are treated as if the specialization had been explicitly declared at its point of instantiation.</p>\n</blockquote>\n<p>I think that it should link, but maybe someone else can interpret better than I can.</p>\n", "OwnerUserId": "369872", "LastEditorUserId": "369872", "LastEditDate": "2011-12-07T01:27:51.530", "Id": "8380830", "Score": "8", "CreationDate": "2011-12-05T03:54:20.150", "LastActivityDate": "2011-12-07T01:27:51.530"}, "bq_ids": {"n4140": {"so_8379002_8380830_1": {"section_id": 225, "quality": 1.0, "length": 23}, "so_8379002_8380830_0": {"section_id": 233, "quality": 0.5769230769230769, "length": 60}}, "n3337": {"so_8379002_8380830_1": {"section_id": 218, "quality": 1.0, "length": 23}, "so_8379002_8380830_0": {"section_id": 226, "quality": 0.5769230769230769, "length": 60}}, "n4659": {"so_8379002_8380830_1": {"section_id": 233, "quality": 1.0, "length": 23}}}, "8383216": {"ParentId": "8379002", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It is not the cast that instantiates the class template specialization, but the function call, because the argument triggers ADL . The instantiation is done because the completeness of it may affect the semantics of the program.</p>\n<p>That clang does not follow the spec here is known and a PR was sent by me some time ago. See <a href=\"http://llvm.org/bugs/show_bug.cgi?id=9440\">http://llvm.org/bugs/show_bug.cgi?id=9440</a></p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-12-05T09:52:37.133", "Id": "8383216", "Score": "16", "CreationDate": "2011-12-05T09:29:01.157", "LastActivityDate": "2011-12-05T09:52:37.133"}, "8379002": {"CommentCount": "12", "AcceptedAnswerId": "8383216", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2011-12-04T22:14:53.743", "LastActivityDate": "2011-12-07T01:27:51.530", "LastEditDate": "2011-12-06T07:01:50.723", "ViewCount": "930", "FavoriteCount": "5", "Title": "Does casting to a pointer to a template instantiate that template?", "Id": "8379002", "Score": "28", "Body": "<p><code>static_cast&lt;the_template&lt;int&gt;*&gt;(0)</code> - does this instantiate <code>the_template</code> with type <code>int</code>?</p>\n<p>The reason for asking is the following code, which will error at linking time with an undefined reference to <code>check_error&lt;char&gt;(void*, long)</code> with Clang and GCC 4.4.5, indicating that it <em>does not</em> instantiate the template. MSVC and <a href=\"http://ideone.com/mqpSv\">GCC 4.5.1</a> however compile and link just fine, leading to the believe that it <em>does</em> instantiate the template. However, if you leave out the cast, MSVC and GCC (both 4.4.5 and 4.5.1) will error on <code>check_error&lt;char&gt;</code> only (the wanted behaviour), while Clang will error on both calls. Normally I believe Clang when it comes to conforming stuff, but I wonder:</p>\n<p><strong>Which compiler is correct and what does the standard say about it?</strong></p>\n<hr>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class T&gt;\nvoid check_error(void*, long);\n\ntemplate&lt;class T&gt;\nstruct foo{\n  template&lt;class U&gt;\n  friend typename std::enable_if&lt;\n    std::is_same&lt;T,U&gt;::value\n  &gt;::type check_error(foo&lt;T&gt;*, int){}\n};\n\ntemplate struct foo&lt;int&gt;;\n\nint main()\n{\n  check_error&lt;int&gt;(static_cast&lt;foo&lt;int&gt;*&gt;(0), 0);\n  check_error&lt;char&gt;(static_cast&lt;foo&lt;char&gt;*&gt;(0), 0);\n}\n</code></pre>\n</hr>", "Tags": "<c++><templates><c++11><language-lawyer>", "OwnerUserId": "500104", "AnswerCount": "2"}});