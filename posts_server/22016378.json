post_cb({"bq_ids": {"n4140": {"so_22016378_22017286_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 5444}}, "n3337": {"so_22016378_22017286_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 5239}}, "n4659": {"so_22016378_22017286_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 6871}}}, "22016378": {"ViewCount": "236", "Body": "<p>Suppose there is a code like this:</p>\n<pre><code>template &lt;typename T&gt;\nCLASS_KEY1 X{};\n\nPREFIX template CLASS_KEY2 X&lt;int&gt;;\n</code></pre>\n<p>where <code>CLASS_KEY1</code>, <code>CLASS_KEY2</code> and <code>PREFIX</code> are macros. <code>CLASS_KEY1</code> and <code>CLASS_KEY2</code> may be expanded to <code>class</code>, <code>struct</code> or <code>union</code> keywords. <code>PREFIX</code> may be expanded to empty set of characters or <code>extern</code> keyword.</p>\n<p>Here is the table which shows when such code compiles (<code>Yes</code> - compiles, <code>No</code> - does not compile) for all combinations of macros values (compiler gcc-4.8.1, option <code>-std=c++11</code>):</p>\n<pre><code>PREFIX                                        extern  extern  extern\nCLASS_KEY1\\CLASS_KEY2 class   struct  union   class   struct  union\nclass                 Yes     Yes?    No      Yes     Yes?    No\nstruct                Yes?    Yes     No      Yes?    Yes     No\nunion                 No      No      Yes     No      No      Yes\n</code></pre>\n<p>Is it a bug in gcc or standard requirement (strange cases are labeled with question marks)? What about other compilers?</p>\n", "AcceptedAnswerId": "22017286", "Title": "Template explicit instantiation (definition and declaration) in gcc", "CreationDate": "2014-02-25T13:59:07.337", "Id": "22016378", "CommentCount": "3", "PostTypeId": "1", "ClosedDate": "2014-02-25T18:17:25.783", "LastActivityDate": "2014-02-25T14:34:22.513", "Score": "0", "OwnerUserId": "3043539", "Tags": "<c++><templates><gcc><c++11><explicit-instantiation>", "AnswerCount": "1"}, "22017286": {"Id": "22017286", "PostTypeId": "2", "Body": "<p>Section 7.1.6.3 (Elaborated type specifiers) of the C++11 standard says :</p>\n<blockquote>\n<p id=\"so_22016378_22017286_0\">The <em>class-key</em> or <code>enum</code> keyword present in the <em>elaborated-type-specifier</em> shall agree in kind with the declaration to which the name in the <em>elaborated-type-specifier</em> refers. This rule also applies to the form of <em>elaborated-type-specifier</em> that declares a <em>class-name</em> or <code>friend</code> class since it can be construed as referring to the definition of the class. Thus, in any <em>elaborated-type-specifier</em>, the <code>enum</code> keyword shall be used to refer to an enumeration (7.2), the <code>union</code> <em>class-key</em> shall be used to refer to a <code>union</code> (Clause 9), and either the <code>class</code> or <code>struct</code> <em>class-key</em> shall be used to refer to a <code>class</code> (Clause 9) declared using the <code>class</code> or <code>struct</code> <em>class-key</em>.</p>\n</blockquote>\n<p>So, the behavior you're seeing is allowed.</p>\n", "LastActivityDate": "2014-02-25T14:34:22.513", "CommentCount": "1", "CreationDate": "2014-02-25T14:34:22.513", "ParentId": "22016378", "Score": "2", "OwnerUserId": "822669"}});