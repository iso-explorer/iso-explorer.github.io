post_cb({"bq_ids": {"n4140": {"so_48756139_48756210_0": {"length": 6, "quality": 0.75, "section_id": 3364}}, "n3337": {"so_48756139_48756210_0": {"length": 6, "quality": 0.75, "section_id": 3234}}, "n4659": {"so_48756139_48756210_0": {"length": 5, "quality": 0.625, "section_id": 4113}}}, "48756210": {"Id": "48756210", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48756139_48756210_0\">Can a pointer to an incomplete type be converted to a reference to an incomplete type?</p>\n</blockquote>\n<p>Yes.</p>\n<p>Using <code>*rawPtrToWidget</code> to just get a reference is legal even for an incomplete type. The following program compiles and builds for me with g++ 6.4.0.</p>\n<pre><code>struct Foo;\n\nvoid test(Foo&amp; ref) {}\nvoid test(Foo* ptr) { test(*ptr); }\n\nint main()\n{\n}\n</code></pre>\n", "LastActivityDate": "2018-02-12T21:59:30.427", "Score": "2", "CreationDate": "2018-02-12T21:59:30.427", "ParentId": "48756139", "CommentCount": "0", "OwnerUserId": "434551"}, "48756139": {"ViewCount": "60", "Body": "<p>Can a pointer to an incomplete type be converted to a reference to an incomplete type in c++? </p>\n<p>Let's say I have a class Widget and four different modules: Main, Maker, Widget, and Transformer. Main calls a function in Maker to make a special Widget:</p>\n<pre><code>// in Maker.h\nclass Widget;\nstd::unique_ptr&lt;Widget&gt; makeSpecialWidget();\n\n// in Maker.cpp\n#include \"Widget.h\"\nstd::unique_ptr&lt;Widget&gt; makeSpecialWidget() { ... }\n</code></pre>\n<p>All Maker.h has is a forward declaration to Widget. We'll say Widget is defined in Widget.h and we'll say Maker needs to know the internals of Widget so Widget.h is included in Maker.cpp </p>\n<p>Then Main does not need any knowledge of any of the internals of a Widget, but it needs to pass it to the Transformer module to do some special operation on the Widget. Now here is the function in Transformer.h:</p>\n<pre><code>// in Transformer.h\nclass Widget;\nstd::unique_ptr&lt;Widget&gt; transformWidget(const Widget&amp; widget);\n\n// in Transformer.cpp\n#include \"Widget.h\"\nstd::unique_ptr&lt;Widget&gt; transformWidget(const Widget&amp; widget) {...}\n</code></pre>\n<p>Notice that the transformer module takes a reference to a Widget so it can get away with an incomplete type declaration in its header.</p>\n<p>Now can Main pass a widget from Maker to Transformer without seeing the definition of Widget?</p>\n<p>i.e. ideally we'd want in Main.cpp:</p>\n<pre><code>  #include \"Maker.h\"\n  #include \"Transformer.h\"  \n\n  std::unique_ptr&lt;Widget&gt; makeAndTransformWidget() {\n      std::unique_ptr&lt;Widget&gt; uniquePtrToWidget = makeSpecialWidget();\n      Widget* rawPtrToWidget = uniquePtrToWidget.get();\n      return transformWidget(/* insert conversion code here */);\n  }\n</code></pre>\n<p>So is there any way for Main to pass the pointer returned by Maker to Transformer without seeing the definition of Widget.h or any other code being written? I'm not really interested in comments on the design of this system it's more for illustration, I'm just interested in the question</p>\n<p>Can a pointer to an incomplete type be converted to a reference to an incomplete type? </p>\n<p>Normally you would just do:</p>\n<pre><code>const Widget&amp; refToWidget = *rawPtrToWidget;\n</code></pre>\n<p>But you can't dereference an incomplete type. Is there any other mechanism in c++ to do this conversion?</p>\n", "Title": "How to convert a pointer to an incomplete type to a reference to an incomplete type with no dereferencing", "CreationDate": "2018-02-12T21:53:54.473", "LastActivityDate": "2018-02-12T21:59:30.427", "CommentCount": "0", "PostTypeId": "1", "Id": "48756139", "Score": "2", "OwnerUserId": "9352017", "Tags": "<c++><incomplete-type>", "AnswerCount": "1"}});