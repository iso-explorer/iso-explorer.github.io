post_cb({"8380946": {"ParentId": "8380805", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>There is a subtle difference between <em>string.h</em> and <em>cstring</em></p>\n<p>Answer of <a href=\"https://stackoverflow.com/users/464581/alf-p-steinbach\">Alf P. Steinbach</a> (can be found as a comment to the asked question):</p>\n<p><code>string.h</code> places the identifiers in the global namespace, and may also place them in the standard namespace. While <code>cstring</code> places the identifiers in the standard namespace, and may also place them in the global namespace. You definitely don't want that <code>cstring</code> behavior, because code that e.g. uses just <code>strlen</code> may work fine with one compiler, then fail to compile with another compiler. It's very unpleasant surprise. So for <strong>C and C++</strong>, use the more safe <code>string.h</code>.</p>\n", "OwnerUserId": "1008481", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:29.187", "Id": "8380946", "Score": "3", "CreationDate": "2011-12-05T04:13:54.497", "LastActivityDate": "2011-12-05T04:13:54.497"}, "8380805": {"CommentCount": "14", "ViewCount": "17887", "PostTypeId": "1", "LastEditorUserId": "68587", "CreationDate": "2011-12-05T03:51:53.663", "LastActivityDate": "2017-03-26T15:02:10.317", "Title": "Difference between string.h and cstring?", "FavoriteCount": "6", "LastEditDate": "2017-03-26T15:00:34.897", "Id": "8380805", "Score": "12", "Body": "<p>What is the difference between <code>string.h</code> and <code>cstring</code>? </p>\n<p>Which one should be used for C and which one for C++ (if at all)?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1008481", "AnswerCount": "6"}, "8380933": {"ParentId": "8380805", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can use string.h for both C &amp; C++.</p>\n<p>In C++ 98 spec, it define both the cstring (in main spec) and string.h (in Annex D.5, Standard C library headers, for compatibility), which define some string function the same as string.h in C. And in real world, all C++ compiler will provide string.h for compatibility to C code.</p>\n<p>So, in my opinion, as C++ code maybe maintain by C coder, and the habit from C, I prefer string.h. It's clear enough, wide known, and more compatibility (with C).</p>\n<p>BTW, I list the all 18 headers in C++ for compatibility with C, in C++ 98 spec:\nassert.h, iso646.h, setjmp.h, stdio.h, wchar.h, ctype.h, limits.h, signal.h, stdlib.h, wctype.h, errno.h, locale.h, stdarg.h, string.h, float.h, math.h, stddef.h, time.h</p>\n", "OwnerUserId": "1079182", "LastEditorUserId": "1079182", "LastEditDate": "2011-12-05T08:55:33.650", "Id": "8380933", "Score": "4", "CreationDate": "2011-12-05T04:10:36.187", "LastActivityDate": "2011-12-05T08:55:33.650"}, "8380944": {"ParentId": "8380805", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The C++ version of the header actually has some differences from the C version. In C some types are implemented as typedefs, but for C++ that prevents things like template specialization from working on those types*, so C++ makes some C typedefs into real types. This means that the C++ version of C headers that contain those typedefs must omit them. </p>\n<p>C++ also allows overloading and so the C++ version of <code>&lt;cstring&gt;</code> specifies some overloads to C functions to allow a function to return a pointer to non-const data if the input argument is a pointer to non-const data, whereas the C function takes and returns only pointers to const.</p>\n<p>Also I think, but can't find the bit in the standard to verify this right now, that the C++ versions of headers have to put their names in the std namespace and only put them in the global namespace as an optional extension.</p>\n<p>*\n For example the following code:</p>\n<pre><code>typedef int Foo;\ntemplate&lt;typename T&gt; struct Bar {};\ntemplate&lt;&gt; struct Bar&lt;int&gt; {};\ntemplate&lt;&gt; struct Bar&lt;Foo&gt; {};\n</code></pre>\n<p>results in the following error:</p>\n<pre><code>main.cpp:7:19: error: redefinition of 'Bar&lt;int&gt;'\ntemplate&lt;&gt; struct Bar&lt;Foo&gt; {};\n                  ^~~~~~~~\nmain.cpp:5:19: note: previous definition is here\ntemplate&lt;&gt; struct Bar&lt;int&gt; {};\n                  ^\n1 error generated.\n</code></pre>\n<p>In C wchar_t is a typedef, so this would prevent one from having a specialization that applies to wchar_t but not to whatever underlying type is used for wchar_t. The fact that MSVC 2010 implements char32_t and char16_t as typedefs prevents them from being able to offer the std::codecvt specializations for those types.</p>\n", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2011-12-05T05:35:56.957", "Id": "8380944", "Score": "2", "CreationDate": "2011-12-05T04:12:10.297", "LastActivityDate": "2011-12-05T05:35:56.957"}, "8380832": {"ParentId": "8380805", "CommentCount": "3", "Body": "<p>In C++, C language headers are defined under the namespace std. So, if you are using those headers in C++, use cstring and eliminate .h . </p>\n", "OwnerUserId": "124797", "PostTypeId": "2", "Id": "8380832", "Score": "4", "CreationDate": "2011-12-05T03:54:48.317", "LastActivityDate": "2011-12-05T03:54:48.317"}, "8380835": {"ParentId": "8380805", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>In C++ you should include <code>cstring</code> as the header while in c you should include <code>string.h</code> as the header.</p>\n<p><strong>In C++</strong> </p>\n<pre><code>#include &lt;cstring&gt;\n</code></pre>\n<p><strong>In C</strong></p>\n<pre><code>#include &lt;string.h&gt;\n</code></pre>\n<p>Features of C standard Library are also provided in the C++ Standard library and as a general naming convention they are pre-pended by an <code>c</code> to the corresponding names in C standard library.     </p>\n<p>For Example:<br>\n<code>string.h</code> becomes <code>cstring</code><br>\n<code>stdio.h</code> becomes <code>cstdio</code> and so on...</br></br></p>\n<hr>\n<p>Since other answers have added different dimensions to this discussion,I felt compelled to refer the holy standard to clear this bit.      </p>\n<p>As per <strong>C++11 20.9.14.6 &amp; 7</strong>:     </p>\n<blockquote>\n<p id=\"so_8380805_8380835_0\">Table 55 describes the header <code>&lt;cstring&gt;</code>.<br>\n  The contents are the same as the Standard C library header , with the change to <code>memchr()</code> specified in 21.7.    </br></p>\n</blockquote>\n<p>While <strong>21.7 Null-terminated sequence utilities</strong> states:     </p>\n<blockquote>\n<p id=\"so_8380805_8380835_1\">The function signature <code>memchr(const void*, int, size_t)</code> shall be replaced by the two declarations:      </p>\n<pre><code>const void* memchr(const void* s, int c, size_t n);\nvoid* memchr( void* s, int c, size_t n);\n</code></pre>\n<p id=\"so_8380805_8380835_2\">both of which shall have the same behavior as the original declaration.     </p>\n</blockquote>\n<p><strong>Annex D (normative) Compatibility features [depr]</strong> states:      </p>\n<p><strong>D.6 C standard library headers</strong> </p>\n<blockquote>\n<p id=\"so_8380805_8380835_3\">1 For compatibility with the C standard library and the C Unicode TR, the C++ standard library provides the 25 C headers, as shown in Table 151.</p>\n</blockquote>\n<p>Which include:         </p>\n<blockquote>\n<p id=\"so_8380805_8380835_4\"><code>&lt;assert.h&gt; &lt;float.h&gt; &lt;math.h&gt; &lt;stddef.h&gt; &lt;tgmath.h&gt;</code>\n<code>&lt;complex.h&gt; &lt;inttypes.h&gt; &lt;setjmp.h&gt; &lt;stdio.h&gt; &lt;time.h&gt;</code>\n<code>&lt;ctype.h&gt; &lt;iso646.h&gt; &lt;signal.h&gt; &lt;stdint.h&gt; &lt;uchar.h&gt;</code>\n<code>&lt;errno.h&gt; &lt;limits.h&gt; &lt;stdarg.h&gt; &lt;stdlib.h&gt; &lt;wchar.h&gt;</code>\n<code>&lt;fenv.h&gt; &lt;locale.h&gt; &lt;stdbool.h&gt; &lt;string.h&gt; &lt;wctype.h&gt;</code></p>\n</blockquote>\n<p>Further on,    </p>\n<blockquote>\n<p id=\"so_8380805_8380835_5\">2   <strong>Every C header, each of which has a name of the form <code>name.h</code>, behaves as if each name placed in the standard library namespace by the corresponding <code>cname header</code> is placed within the global namespace scope.</strong> It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace std and are then injected into the global namespace scope by explicit using-declarations (7.3.3).</p>\n<p id=\"so_8380805_8380835_6\">3 [ Example: The header <code>&lt;cstdlib&gt;</code> assuredly provides its declarations and definitions within the namespace std. It may also provide these names within the global namespace. The header <code>&lt;stdlib.h&gt;</code> assuredly provides the same declarations and definitions within the global namespace, much as in the C Standard. It may also provide these names within the namespace std. \u2014end example ]</p>\n</blockquote>\n<h2>Conclusion:</h2>\n<p>From the above references:<br>\nI stand corrected on my earlier suggestion, there seems to be no apparent advantage of using <code>cstring</code> over <code>string.h</code> while as @Alf suggested there might be some compilation issues due to use of unqualified function names when using <code>cstring</code> as header. So given hat there is no apparent dis-advantage of using <code>string.h</code> or advantage of using <code>cstring</code>, I think either can be used in C++ if used in a proper manner.</br></p>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "68587", "LastEditDate": "2017-03-26T15:02:10.317", "Id": "8380835", "Score": "18", "CreationDate": "2011-12-05T03:55:10.507", "LastActivityDate": "2017-03-26T15:02:10.317"}, "bq_ids": {"n4140": {"so_8380805_8380835_6": {"section_id": 4908, "quality": 0.8536585365853658, "length": 35}, "so_8380805_8380835_3": {"section_id": 4906, "quality": 0.7, "length": 7}, "so_8380805_8380835_1": {"section_id": 1893, "quality": 0.9, "length": 9}, "so_8380805_8380835_5": {"section_id": 4907, "quality": 0.926829268292683, "length": 38}, "so_8380805_8380835_2": {"section_id": 1524, "quality": 1.0, "length": 6}}, "n3337": {"so_8380805_8380835_6": {"section_id": 4703, "quality": 0.8536585365853658, "length": 35}, "so_8380805_8380835_3": {"section_id": 4701, "quality": 0.7, "length": 7}, "so_8380805_8380835_1": {"section_id": 1882, "quality": 0.9, "length": 9}, "so_8380805_8380835_5": {"section_id": 4702, "quality": 0.926829268292683, "length": 38}, "so_8380805_8380835_2": {"section_id": 1518, "quality": 1.0, "length": 6}}, "n4659": {"so_8380805_8380835_6": {"section_id": 6317, "quality": 0.8536585365853658, "length": 35}, "so_8380805_8380835_5": {"section_id": 6316, "quality": 0.926829268292683, "length": 38}}}, "17293736": {"ParentId": "8380805", "CommentCount": "0", "Body": "<p>Apparently <code>cstring</code> is for C++ and <code>string.h</code> is for C.</p>\n<p>One thing worth mentioning is, if you are switching from <code>string.h</code> to <code>cstring</code>, remember to add <code>std::</code> before all your string function calls.</p>\n", "OwnerUserId": "558892", "PostTypeId": "2", "Id": "17293736", "Score": "1", "CreationDate": "2013-06-25T09:30:28.960", "LastActivityDate": "2013-06-25T09:30:28.960"}});