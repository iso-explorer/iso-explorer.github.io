post_cb({"31348475": {"CommentCount": "6", "ViewCount": "250", "CreationDate": "2015-07-10T19:06:16.500", "LastActivityDate": "2015-07-12T16:18:05.013", "Title": "The member function Outer::f() is not a friend of class Outer::Inner. Why?", "FavoriteCount": "0", "PostTypeId": "1", "Id": "31348475", "Score": "12", "Body": "<p>According to <a href=\"http://coliru.stacked-crooked.com/a/e6f5043779cbb775\" rel=\"noreferrer\">clang</a>, gcc and vs2013, the function <code>Outer::f</code> is <strong>not</strong> a friend of the class <code>Outer::Inner</code>.</p>\n<pre><code>struct Outer {\n    void f() {}\n    class Inner {\n        friend void f();\n        static const int i = 0;\n    };\n};\n\nvoid f() { int i = Outer::Inner::i; }\n</code></pre>\n<p>From [namespace.memdef]/3 I would expect the function <code>Outer::f</code> to be a friend of <code>Outer::Inner</code>, instead of <code>::f</code>, because the friend declaration is not the <strong>first</strong> in its namespace containing the name <code>f</code>.</p>\n<p>[namespace,memdef]/3 (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_31348475_31348475_0\">Every name first declared in a namespace is a member of that\n  namespace. If a friend declaration in a non-local class <strong>first</strong>\n  declares a class, function, class template or function\n  template<sup>97</sup> the friend is a member of the innermost\n  enclosing namespace. The friend declaration does not by itself make\n  the name visible to unqualified lookup (3.4.1) or qualified lookup\n  (3.4.3). [ Note: The name of the friend will be visible in its\n  namespace if a matching declaration is provided at namespace scope\n  (either before or after the class definition granting friendship). \u2014\n  end note ] If a friend function or function template is called, its\n  name may be found by the name lookup that considers functions from\n  namespaces and classes associated with the types of the function\n  arguments (3.4.2). If the name in a friend declaration is neither\n  qualified nor a template-id and the declaration is a function or an\n  elaborated-type-specifier, the lookup to determine whether the entity\n  has been previously declared shall not consider any scopes outside the\n  innermost enclosing namespace.</p>\n</blockquote>\n", "Tags": "<c++><language-lawyer><c++14><friend>", "OwnerUserId": "1042389", "AnswerCount": "2"}, "31348965": {"ParentId": "31348475", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>According to [namespace.memdef]:</p>\n<blockquote>\n<p id=\"so_31348475_31348965_0\">If the name in a <code>friend</code> declaration is neither\n  qualified nor a template-id and the declaration is a function or an elaborated-type-specifier, the lookup to determine whether the entity has been previously declared shall not consider any scopes <strong>outside</strong> the innermost\n  enclosing namespace.</p>\n</blockquote>\n<p>What does \"outside\" mean? It could mean (1) external of (as in, all scopes within the innermost enclosing namespace are permitted, but no others) or it could mean (2) exclusive of (as in, only the innermost enclosing namespace is considered). The wording is potentially ambiguous. However, consider this example which is merged from OP's original question and OP's comments:</p>\n<pre><code>struct Outer {\n    void f() { }\n    class C { void foo(); };\n\n    class Inner {\n        friend class C;\n        friend void f();\n        static const int i = 0;\n    };\n};\n\nvoid f() { (void)Outer::Inner::i; }               // compiles on GCC,Clang\nvoid Outer::C::foo() { (void)Outer::Inner::i; }   // compiles on GCC,Clang\n\nint main() { }\n</code></pre>\n<p>Based on wording (1), <code>Outer::f</code> and <code>Outer::C</code> should be friends of <code>Inner</code>. Based on wording (2), <code>::f</code> and <code>::C</code> should be the friends. One or the other interpretation could make sense, however both GCC and Clang end up with <code>::f</code> and <code>Outer::C</code> as the friends, which clearly doesn't make any sense. I have filed <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66836\" rel=\"nofollow\">GCC Bug 66836</a> and <a href=\"https://llvm.org/bugs/show_bug.cgi?id=24088\" rel=\"nofollow\">Clang Bug 24088</a>. So either both compilers are wrong in one direction or another, or there's some part of the standard that explains this logic that definitely escapes me. I wouldn't bet against the latter. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-10T20:39:32.080", "Id": "31348965", "Score": "2", "CreationDate": "2015-07-10T19:37:29.317", "LastActivityDate": "2015-07-10T20:39:32.080"}, "bq_ids": {"n4140": {"so_31348475_31348673_0": {"section_id": 5485, "quality": 1.0, "length": 22}, "so_31348475_31348475_0": {"section_id": 5485, "quality": 0.9117647058823529, "length": 93}, "so_31348475_31348965_0": {"section_id": 5485, "quality": 1.0, "length": 22}}, "n3337": {"so_31348475_31348673_0": {"section_id": 5271, "quality": 1.0, "length": 22}, "so_31348475_31348475_0": {"section_id": 5271, "quality": 0.7647058823529411, "length": 78}, "so_31348475_31348965_0": {"section_id": 5271, "quality": 1.0, "length": 22}}, "n4659": {"so_31348475_31348673_0": {"section_id": 6920, "quality": 0.6818181818181818, "length": 15}, "so_31348475_31348475_0": {"section_id": 6920, "quality": 0.8431372549019608, "length": 86}, "so_31348475_31348965_0": {"section_id": 6920, "quality": 1.0, "length": 22}}}, "31348673": {"ParentId": "31348475", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>The first part of the standard that you quoted says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_31348475_31348673_0\">Every name first declared in a namespace is a member of that namespace. If a friend declaration in a nonlocal class first declares a class or function <strong>the friend class or function is a member of the innermost enclosing namespace.</strong></p>\n</blockquote>\n<p>You are assuming a class is the same as a namespace, which is not correct.</p>\n<pre><code>namespace Outer {\n    void f();\n    class Inner {\n        friend void f();\n        static const int i = 0;\n    };\n}\n\nvoid Outer::f() { int i = Outer::Inner::i; }\n</code></pre>\n<p>should work. To use the class member function as the friend, you'll have to use:</p>\n<pre><code>struct Outer {\n    void f();\n    class Inner {\n        friend void Outer::f();\n        static const int i = 0;\n    };\n};\n\nvoid Outer::f() { int i = Outer::Inner::i; }\n</code></pre>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2015-07-12T16:18:05.013", "Id": "31348673", "Score": "9", "CreationDate": "2015-07-10T19:17:48.873", "LastActivityDate": "2015-07-12T16:18:05.013"}});