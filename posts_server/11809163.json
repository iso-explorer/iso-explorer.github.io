post_cb({"11809217": {"ParentId": "11809163", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, <code>std::set</code> stores its elements in such a way that iterating over the elements will be done in sorted order (and the call to <code>std::adjacent_find</code> is to show that <code>std::set</code> stores unique items as well).</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;ios&gt;\n#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    auto const ss = std::set&lt;std::string&gt; { \"foo\", \"bar\", \"test\" };\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_sorted(begin(ss), end(ss)) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (std::adjacent_find(begin(ss), end(ss)) == end(ss)) &lt;&lt; \"\\n\";\n    std::copy(begin(ss), end(ss), std::ostream_iterator&lt;std::string&gt;(std::cout, \"\\n\"));\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/view?id=28285ace9dd073a8812f80c63e6591fe-1f48a68887043b2645051583fb11641d\" rel=\"nofollow\"><strong>Live Example</strong></a></p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-08-09T06:40:10.543", "Id": "11809217", "Score": "6", "CreationDate": "2012-08-04T14:00:08.163", "LastActivityDate": "2013-08-09T06:40:10.543"}, "11809171": {"ParentId": "11809163", "CommentCount": "2", "Body": "<p>By its definition <code>std::set</code> is a sorted container. Its part of the standard. Having it sorted helps maintain that its a set rather than just an arbitrary collection.</p>\n<p>Source: <a href=\"http://www.sgi.com/tech/stl/set.html\">http://www.sgi.com/tech/stl/set.html</a></p>\n", "OwnerUserId": "23528", "PostTypeId": "2", "Id": "11809171", "Score": "15", "CreationDate": "2012-08-04T13:51:50.227", "LastActivityDate": "2012-08-04T13:51:50.227"}, "41424708": {"ParentId": "11809163", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11 N3337 standard draft</a></strong> \n23.2.4 \"Associative containers\":</p>\n<blockquote>\n<p id=\"so_11809163_41424708_0\">1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds of\n  associative containers: set, multiset, map and multimap.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_11809163_41424708_1\">10 The fundamental property of iterators of associative containers is that they iterate through the containers\n  in the non-descending order of keys where non-descending is defined by the comparison that was used to\n  construct them.</p>\n</blockquote>\n<p>so yes, order is guaranteed, which as <a href=\"https://stackoverflow.com/a/11812871/895245\">https://stackoverflow.com/a/11812871/895245</a> mentioned basically requires a balanced search tree implementation.</p>\n<p>Also contrast with C++11 <code>unordered_set</code>, which may provide better performance since it has less restrictions: <a href=\"https://stackoverflow.com/questions/1349734/why-on-earth-would-anyone-use-set-instead-of-unordered-set\">Why on earth would anyone use set instead of unordered_set?</a> e.g. using a hash set.</p>\n", "OwnerUserId": "895245", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:04.637", "Id": "41424708", "Score": "2", "CreationDate": "2017-01-02T10:07:23.247", "LastActivityDate": "2017-01-02T10:07:23.247"}, "11809163": {"CommentCount": "0", "AcceptedAnswerId": "11809171", "PostTypeId": "1", "ClosedDate": "2017-01-02T16:02:58.583", "LastEditorUserId": "23528", "CreationDate": "2012-08-04T13:50:06.840", "LastActivityDate": "2017-01-02T10:07:23.247", "LastEditDate": "2012-08-04T13:55:10.083", "ViewCount": "11536", "FavoriteCount": "3", "Title": "Does `std::set` sort elements in every case?", "Id": "11809163", "Score": "7", "Body": "<p>From <a href=\"http://www.cplusplus.com/reference/stl/set/begin/\" rel=\"noreferrer\">cplusplus.com</a> reference it seems that <code>std::set</code> sorts elements.</p>\n<p>I need to have sorted strings, but I'm not sure if it will work well on every platform and compiler. Mainly GCC, MinGW, VC.</p>\n", "Tags": "<c++><sorting><stl><set><std>", "OwnerUserId": "409102", "AnswerCount": "4"}, "11812871": {"ParentId": "11809163", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Actualy std::set and std::map are not really sorted. Both of these containers are implemented as a <a href=\"http://en.wikipedia.org/wiki/Red%E2%80%93black_tree\" rel=\"nofollow noreferrer\">red-black trees</a>. So when you iterate such kind of containers, iterator walks through the tree in such way that it looks like that container is sorted. At first it visits the most left node then the parent of the most left one and so on...</p>\n", "OwnerUserId": "1576357", "LastEditorUserId": "11047", "LastEditDate": "2016-12-15T22:18:53.000", "Id": "11812871", "Score": "10", "CreationDate": "2012-08-04T23:49:20.547", "LastActivityDate": "2016-12-15T22:18:53.000"}, "bq_ids": {"n4140": {"so_11809163_41424708_1": {"section_id": 746, "quality": 0.95, "length": 19}, "so_11809163_41424708_0": {"section_id": 737, "quality": 0.95, "length": 19}}, "n3337": {"so_11809163_41424708_1": {"section_id": 735, "quality": 0.95, "length": 19}, "so_11809163_41424708_0": {"section_id": 726, "quality": 0.95, "length": 19}}, "n4659": {"so_11809163_41424708_1": {"section_id": 805, "quality": 0.95, "length": 19}, "so_11809163_41424708_0": {"section_id": 795, "quality": 0.95, "length": 19}}}});