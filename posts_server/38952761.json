post_cb({"42982225": {"ParentId": "38952761", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-03-23T16:48:23.860", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:14.630", "Id": "42982225", "OwnerUserId": "234420", "Body": "<p>Unfortunately ThreadSanitizer cannot comprehend memory fences. This is because it reasons in the terms of happens-before relation between accesses to certain objects, and there's no object in the fence operation.</p>\n<p>If you replace the relaxed load + acquire fence with an acquire load, and the release fence + relaxed store with a release store, TSan would correctly detect the happens-before relation between the store and the load.</p>\n<p>Also note GCC's TSan implementation may fail to instrument atomics at O0 (see <a href=\"https://stackoverflow.com/a/42905055/234420\">https://stackoverflow.com/a/42905055/234420</a>).</p>\n", "LastActivityDate": "2017-03-23T16:48:23.860"}, "38963036": {"ParentId": "38952761", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-08-15T21:04:27.123", "Score": "4", "LastEditorUserId": "2756719", "LastEditDate": "2016-08-15T21:18:22.200", "Id": "38963036", "OwnerUserId": "2756719", "Body": "<p><strong>TL;DR:</strong> This is a TSAN false positive. The code is valid.</p>\n<p>Thread 1:</p>\n<pre><code>  x=true;                                              // W\n  std::atomic_thread_fence(std::memory_order_release); // A\n  y.store(true,std::memory_order_relaxed);             // X\n</code></pre>\n<p>Thread 2:</p>\n<pre><code>  while(!y.load(std::memory_order_relaxed));           // Y\n  std::atomic_thread_fence(std::memory_order_acquire); // B\n  if(x)                                                // R\n     ++z;\n</code></pre>\n<p><a href=\"http://eel.is/c++draft/atomics.fences#2\" rel=\"nofollow\">[atomics.fences]/2</a>:</p>\n<blockquote>\n<p id=\"so_38952761_38963036_0\">A release fence A synchronizes with an acquire fence B if there exist\n  atomic operations X and Y, both operating on some atomic object M,\n  such that A is sequenced before X, X modifies M, Y is sequenced before\n  B, and Y reads the value written by X or a value written by any side\n  effect in the hypothetical release sequence X would head if it were a\n  release operation.</p>\n</blockquote>\n<p>Let's go through the list:</p>\n<ul>\n<li>[\u2714] \"there exist atomic operations X and Y, both operating on some atomic object M\": obvious. M is <code>y</code>.</li>\n<li>[\u2714] \"A is sequenced before X\": obvious (<a href=\"http://eel.is/c++draft/intro.execution#14\" rel=\"nofollow\">[intro.execution]/14</a> for those who want a citation).</li>\n<li>[\u2714] \"X modifies M\": obvious.</li>\n<li>[\u2714] \"Y is sequenced before B\" : obvious.</li>\n<li>[\u2714] \"and Y reads the value written by X...\": that's the only way that loop could terminate.</li>\n</ul>\n<p>Therefore, the release fence A synchronizes with the acquire fence B.</p>\n<p>The write W is sequenced before A, and the read R is sequenced after B, therefore W <em>inter-thread happens before</em>, and so <em>happens before</em>, R. <a href=\"http://eel.is/c++draft/intro.races#9\" rel=\"nofollow\">[intro.races]/9-10</a>:</p>\n<blockquote>\n<p id=\"so_38952761_38963036_1\">An evaluation A <em>inter-thread happens before</em> an evaluation B if</p>\n<ul>\n<li>A synchronizes with B, or</li>\n<li>A is dependency-ordered before B, or</li>\n<li>for some evaluation X\n  \n  <ul>\n<li>A synchronizes with X and X is sequenced before B, or</li>\n<li>A is sequenced before X and X inter-thread happens before B, or</li>\n<li>A inter-thread happens before X and X inter-thread happens before B.</li>\n</ul></li>\n</ul>\n<p id=\"so_38952761_38963036_2\">An evaluation A <em>happens before</em> an evaluation B (or, equivalently, B\n  <em>happens after</em> A) if:</p>\n<ul>\n<li>A is sequenced before B, or</li>\n<li>A inter-thread happens before B.</li>\n</ul>\n</blockquote>\n<p>There is no data race because of the happens-before relationship (<a href=\"http://eel.is/c++draft/intro.races#19\" rel=\"nofollow\">[intro.races]/19</a>):</p>\n<blockquote>\n<p id=\"so_38952761_38963036_3\">The execution of a program contains a <em>data race</em> if it contains two\n  potentially concurrent conflicting actions, at least one of which is\n  not atomic, and neither happens before the other, except for the\n  special case for signal handlers described below. Any such data race\n  results in undefined behavior.</p>\n</blockquote>\n<p>Moreover, the read R is guaranteed to read the value written by W, because W is the <em>visible side effect</em>, there being no other side effect on <code>x</code> after the threads started (<a href=\"http://eel.is/c++draft/intro.races#11\" rel=\"nofollow\">[intro.races]/11</a>): </p>\n<blockquote>\n<p id=\"so_38952761_38963036_4\">A visible side effect A on a scalar object or bit-field M with respect\n  to a value computation B of M satisfies the conditions:</p>\n<ul>\n<li>A happens before B and</li>\n<li>there is no other side effect X to M such that A happens before X and X happens before B.</li>\n</ul>\n<p id=\"so_38952761_38963036_5\">The value of a non-atomic scalar object or bit-field M, as determined\n  by evaluation B, shall be the value stored by the visible side effect\n  A.</p>\n</blockquote>\n", "LastActivityDate": "2016-08-15T21:18:22.200"}, "38953415": {"ParentId": "38952761", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2016-08-15T10:29:55.320", "Score": "1", "LastEditorUserId": "4082723", "LastEditDate": "2016-08-15T12:19:18.543", "Id": "38953415", "OwnerUserId": "4082723", "Body": "<p><code>memory_order_relaxed</code> imposes no restraints on reordering.</p>\n<p><code>memory_order_acquire</code> doesn't prevent reordering past the fence from above. It only prevents ordering from below. This means that the code can be executed as if:</p>\n<pre><code>std::atomic_thread_fence(std::memory_order_acquire);\nif(x)\n  ++z;\nwhile(!y.load(std::memory_order_relaxed));\n</code></pre>\n<p>This will cause a data race as the read in <code>if(x)</code> races with <code>x=true</code>.</p>\n<p>You need fences with <code>memory_order_acq_rel</code> or <code>memory_order_seq_cst</code> semantics in both functions which prevents reordering in both directions.</p>\n", "LastActivityDate": "2016-08-15T12:19:18.543"}, "bq_ids": {"n4140": {"so_38952761_38963036_4": {"section_id": 5826, "quality": 0.8181818181818182, "length": 9}, "so_38952761_38963036_5": {"section_id": 5826, "quality": 0.9230769230769231, "length": 12}, "so_38952761_38963036_1": {"section_id": 5824, "quality": 0.8, "length": 4}, "so_38952761_38963036_3": {"section_id": 5834, "quality": 0.90625, "length": 29}, "so_38952761_38963036_0": {"section_id": 1227, "quality": 1.0, "length": 35}, "so_38952761_38963036_2": {"section_id": 5824, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_38952761_38963036_4": {"section_id": 5597, "quality": 0.8181818181818182, "length": 9}, "so_38952761_38963036_5": {"section_id": 5597, "quality": 0.9230769230769231, "length": 12}, "so_38952761_38963036_1": {"section_id": 5595, "quality": 0.8, "length": 4}, "so_38952761_38963036_3": {"section_id": 5605, "quality": 0.625, "length": 20}, "so_38952761_38963036_0": {"section_id": 1225, "quality": 1.0, "length": 35}, "so_38952761_38963036_2": {"section_id": 5595, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_38952761_38963036_4": {"section_id": 7288, "quality": 0.8181818181818182, "length": 9}, "so_38952761_38963036_5": {"section_id": 7288, "quality": 0.9230769230769231, "length": 12}, "so_38952761_38963036_1": {"section_id": 7285, "quality": 0.8, "length": 4}, "so_38952761_38963036_3": {"section_id": 7296, "quality": 0.90625, "length": 29}, "so_38952761_38963036_0": {"section_id": 1316, "quality": 1.0, "length": 35}, "so_38952761_38963036_2": {"section_id": 7285, "quality": 0.7142857142857143, "length": 5}}}, "38952761": {"CommentCount": "3", "AcceptedAnswerId": "38963036", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-08-15T09:43:44.280", "LastActivityDate": "2017-03-23T16:48:23.860", "LastEditDate": "2017-05-23T11:54:09.103", "ViewCount": "261", "FavoriteCount": "1", "Title": "C++11 (g++ thread sanitized) Ordering nonatomic operations with atomics (false positive?)", "Id": "38952761", "Score": "13", "Body": "<p>I am experimenting with g++ and thread sanitizer and I think I am getting false positives. Is this true, or am I making some big mistake?</p>\n<p>Program (cut&amp;paste from Anthony Williams: C++ Concurrency in Action, page 145, listing 5.13)</p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;thread&gt;\n#include &lt;assert.h&gt;\nbool x=false;\nstd::atomic&lt;bool&gt; y;\nstd::atomic&lt;int&gt; z;\nvoid write_x_then_y()\n{\n  x=true;\n  std::atomic_thread_fence(std::memory_order_release);\n  y.store(true,std::memory_order_relaxed);\n}\nvoid read_y_then_x()\n{\n  while(!y.load(std::memory_order_relaxed));\n  std::atomic_thread_fence(std::memory_order_acquire);\n  if(x)\n    ++z;\n}\nint main()\n{\n  x=false;\n  y=false;\n  z=0;\n  std::thread a(write_x_then_y);\n  std::thread b(read_y_then_x);\n  a.join();\n  b.join();\n  assert(z.load()!=0);\n}\n</code></pre>\n<p>Compiled with:</p>\n<pre><code>g++ -o a -g -Og -pthread a.cpp -fsanitize=thread\n</code></pre>\n<p>g++ version</p>\n<pre><code>~/build/px&gt; g++ -v\nUsing built-in specs.\nCOLLECT_GCC=g++\nCOLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/6.1.1/lto-wrapper\nTarget: x86_64-redhat-linux\nConfigured with: ../configure --enable-bootstrap --enable-languages=c,c++,objc,obj-c++,fortran,ada,go,lto --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-plugin --enable-initfini-array --disable-libgcj --with-isl --enable-libmpx --enable-gnu-indirect-function --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux\nThread model: posix\ngcc version 6.1.1 20160621 (Red Hat 6.1.1-3) (GCC)\n</code></pre>\n<p>I am getting:</p>\n<pre><code>~/build/px&gt; ./a\n==================\nWARNING: ThreadSanitizer: data race (pid=13794)\n  Read of size 1 at 0x000000602151 by thread T2:\n    #0 read_y_then_x() /home/ostri/build/px/a.cpp:17 (a+0x000000401014)\n    #1 void std::_Bind_simple&lt;void (*())()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;) /usr/include/c++/6.1.1/functional:1400 (a+0x000000401179)\n    #2 std::_Bind_simple&lt;void (*())()&gt;::operator()() /usr/include/c++/6.1.1/functional:1389 (a+0x000000401179)\n    #3 std::thread::_State_impl&lt;std::_Bind_simple&lt;void (*())()&gt; &gt;::_M_run() /usr/include/c++/6.1.1/thread:196 (a+0x000000401179)\n    #4 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0x0000000baaae)\n\n  Previous write of size 1 at 0x000000602151 by thread T1:\n    #0 write_x_then_y() /home/ostri/build/px/a.cpp:9 (a+0x000000400fbd)\n    #1 void std::_Bind_simple&lt;void (*())()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;) /usr/include/c++/6.1.1/functional:1400 (a+0x000000401179)\n    #2 std::_Bind_simple&lt;void (*())()&gt;::operator()() /usr/include/c++/6.1.1/functional:1389 (a+0x000000401179)\n    #3 std::thread::_State_impl&lt;std::_Bind_simple&lt;void (*())()&gt; &gt;::_M_run() /usr/include/c++/6.1.1/thread:196 (a+0x000000401179)\n    #4 &lt;null&gt; &lt;null&gt; (libstdc++.so.6+0x0000000baaae)\n\n  Location is global 'x' of size 1 at 0x000000602151 (a+0x000000602151)\n\n  Thread T2 (tid=13797, running) created by main thread at:\n    #0 pthread_create &lt;null&gt; (libtsan.so.0+0x000000028380)\n    #1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0x0000000badc4)\n    #2 main /home/ostri/build/px/a.cpp:26 (a+0x000000401097)\n\n  Thread T1 (tid=13796, finished) created by main thread at:\n    #0 pthread_create &lt;null&gt; (libtsan.so.0+0x000000028380)\n    #1 std::thread::_M_start_thread(std::unique_ptr&lt;std::thread::_State, std::default_delete&lt;std::thread::_State&gt; &gt;, void (*)()) &lt;null&gt; (libstdc++.so.6+0x0000000badc4)\n    #2 main /home/ostri/build/px/a.cpp:25 (a+0x00000040108a)\n\nSUMMARY: ThreadSanitizer: data race /home/ostri/build/px/a.cpp:17 in read_y_then_x()\n==================\nThreadSanitizer: reported 1 warnings\n</code></pre>\n<p>I got this warning in more complex program, and I've thought it is my bug, but now even a \"school book program\" displays the same behaviour.\nIs it (i.e. some compiler switch is missing) me or g++?</p>\n<p><strong>UPDATED</strong>\nTaken from <a href=\"https://stackoverflow.com/questions/37552866/why-does-threadsanitizer-report-a-race-with-this-lock-free-example\">link</a></p>\n<pre><code>#if defined(__SANITIZE_THREAD__)\n#define TSAN_ENABLED\n#elif defined(__has_feature)\n#if __has_feature(thread_sanitizer)\n#define TSAN_ENABLED\n#endif\n#endif\n\n#ifdef TSAN_ENABLED\n#define TSAN_ANNOTATE_HAPPENS_BEFORE(addr) \\\n    AnnotateHappensBefore(__FILE__, __LINE__, (void*)(addr))\n#define TSAN_ANNOTATE_HAPPENS_AFTER(addr) \\\n    AnnotateHappensAfter(__FILE__, __LINE__, (void*)(addr))\nextern \"C\" void AnnotateHappensBefore(const char* f, int l, void* addr);\nextern \"C\" void AnnotateHappensAfter(const char* f, int l, void* addr);\n#else\n#define TSAN_ANNOTATE_HAPPENS_BEFORE(addr)\n#define TSAN_ANNOTATE_HAPPENS_AFTER(addr)\n#endif\n\n#include &lt;atomic&gt;\n#include &lt;thread&gt;\n#include &lt;assert.h&gt;\nbool x=false;\nstd::atomic&lt;bool&gt; y;\nstd::atomic&lt;int&gt; z;\nvoid write_x_then_y()\n{\n  x=true;\n  std::atomic_thread_fence(std::memory_order_release);\n  TSAN_ANNOTATE_HAPPENS_BEFORE(&amp;x);\n  y.store(true,std::memory_order_relaxed);\n}\nvoid read_y_then_x()\n{\n  while(!y.load(std::memory_order_relaxed));\n  std::atomic_thread_fence(std::memory_order_acquire);\n  TSAN_ANNOTATE_HAPPENS_AFTER(&amp;x);\n  if(x)\n    ++z;\n}\n{\n  x=false;\n  y=false;\n  z=0;\n  std::thread a(write_x_then_y);\n  std::thread b(read_y_then_x);\n  a.join();\n  b.join();\n  assert(z.load()!=0);\n}\n</code></pre>\n<p>Compile command</p>\n<pre><code>g++ -o a -g -Og -pthread a.cpp -fsanitize=thread -D__SANITIZE_THREAD__\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><thread-sanitizer>", "OwnerUserId": "6078185", "AnswerCount": "3"}});