post_cb({"8049048": {"ParentId": "8049013", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_8049013_8049048_0\">In case of const, it makes sense that calling a non-const member function violates the const-ness of the the object and hence it is prohibited. But why in the case of volatile?</p>\n</blockquote>\n<p>It's just the same for volatile. Volatile means every access to an object is a visible side effect and cannot be eliminated. If you called a nonvolatile method on a volatile object, you would violate this property (because the nonvolatile method would treat the object just as a normal object). Therefore, it is impossible.</p>\n", "OwnerUserId": "51831", "PostTypeId": "2", "Id": "8049048", "Score": "4", "CreationDate": "2011-11-08T10:32:58.310", "LastActivityDate": "2011-11-08T10:32:58.310"}, "8049102": {"ParentId": "8049013", "CommentCount": "5", "Body": "<p>From the standard:</p>\n<blockquote>\n<p id=\"so_8049013_8049102_0\">7.1.5.1. If an attempt is made to refer to an object defined with a volatile-quailified type through the use of an lvalue with a\n  non-volatile-quailified type, the program behaviour is undefined.</p>\n</blockquote>\n<p>I'm guessing your compiler posts an error to prevent undefined behavior. The standard stating so should be reason enough.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "8049102", "Score": "4", "CreationDate": "2011-11-08T10:37:16.973", "LastActivityDate": "2011-11-08T10:37:16.973"}, "8049061": {"ParentId": "8049013", "CommentCount": "2", "Body": "<p>The <code>volatile</code> qualifier works much in the same way as <code>const</code> works. To see <em>what</em> can be done thanks to this, take a look at <a href=\"http://drdobbs.com/cpp/184403766\" rel=\"nofollow\">this Alexandrescu article</a>.\nThat article should also give you some insight into the <em>why</em>.</p>\n", "OwnerUserId": "482317", "PostTypeId": "2", "Id": "8049061", "Score": "2", "CreationDate": "2011-11-08T10:33:49.953", "LastActivityDate": "2011-11-08T10:33:49.953"}, "bq_ids": {"n4140": {"so_8049013_8049102_0": {"section_id": 5435, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_8049013_8049102_0": {"section_id": 5230, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_8049013_8049102_0": {"section_id": 6862, "quality": 0.5333333333333333, "length": 8}}}, "8049013": {"CommentCount": "2", "ViewCount": "463", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2011-11-08T10:29:35.133", "LastActivityDate": "2011-11-08T10:38:02.340", "Title": "why can't a volatile object call nonvolatile member function", "AcceptedAnswerId": "8049048", "LastEditDate": "2011-11-08T10:38:02.340", "Id": "8049013", "Score": "5", "Body": "<p>Why can't a <code>volatile</code> object call a non-<code>volatile</code> member function?</p>\n<p>In case of <code>const</code>, it makes sense that calling a non-<code>const</code> member function violates the <em>constness</em> of the the object and hence it is prohibited. But <strong>why</strong> in the case of <code>volatile</code>?</p>\n", "Tags": "<c++><volatile><language-lawyer><member-functions>", "OwnerUserId": "377762", "AnswerCount": "3"}});