post_cb({"1032278": {"LastActivityDate": "2009-06-23T12:51:49.640", "CommentCount": "3", "Body": "<p>In your case Return Value Optimization will take place so std::string will not be copied.</p>\n", "CreationDate": "2009-06-23T12:35:26.163", "LastEditDate": "2009-06-23T12:51:49.640", "ParentId": "1032243", "Id": "1032278", "LastEditorUserId": "123111", "PostTypeId": "2", "Score": "5", "OwnerUserId": "123111"}, "1032265": {"CommentCount": "0", "Body": "<p>I agree with duffymo.  You should make an understandable working application first and then, if there is a need, attack optimization.  It is at this point that you will have an idea where the major bottlenecks are and will be able to more efficiently manage your time in making a faster app.</p>\n", "CreationDate": "2009-06-23T12:33:13.593", "ParentId": "1032243", "Id": "1032265", "LastActivityDate": "2009-06-23T12:33:13.593", "PostTypeId": "2", "Score": "1", "OwnerUserId": "127278"}, "1032243": {"CreationDate": "2009-06-23T12:27:58.817", "ViewCount": "30469", "FavoriteCount": "7", "Id": "1032243", "AcceptedAnswerId": "1032252", "Score": "64", "Title": "Should I return std::strings?", "CommentCount": "3", "Body": "<p>I'm trying to use <code>std::string</code> instead of <code>char*</code> whenever possible, but I worry I may be degrading performance too much. Is this a good way of returning strings (no error checking for brevity)?</p>\n<pre><code>std::string linux_settings_provider::get_home_folder() {\n    return std::string(getenv(\"HOME\"));\n}\n</code></pre>\n<p>Also, a related question: when accepting strings as parameters, should I receive them as <code>const std::string&amp;</code> or <code>const char*</code>?</p>\n<p>Thanks.</p>\n", "Tags": "<c++><string><return-value>", "LastActivityDate": "2012-11-16T09:26:51.470", "PostTypeId": "1", "AnswerCount": "12", "OwnerUserId": "106281"}, "1032252": {"CommentCount": "6", "Body": "<p>Return the string.</p>\n<p>I think the better abstraction is worth it.  Until you can measure a meaningful performance difference, I'd argue that it's a micro-optimization that only exists in your imagination.</p>\n<p>It took many years to get a good string abstraction into C++.  I don't believe that Bjarne Stroustroup, so famous for his conservative \"only pay for what you use\" dictum, would have permitted an obvious performance killer into the language.  Higher abstraction is good.</p>\n", "CreationDate": "2009-06-23T12:30:06.783", "ParentId": "1032243", "Id": "1032252", "LastActivityDate": "2009-06-23T12:30:06.783", "PostTypeId": "2", "Score": "63", "OwnerUserId": "37213"}, "1032537": {"LastActivityDate": "2012-11-16T09:26:51.470", "CommentCount": "0", "Body": "<p>Return the string, like everyone says.</p>\n<p><i>when accepting strings as parameters, should I receive them as <code>const std::string&amp;</code> or <code>const char*</code>?</i></p>\n<p>I'd say take any const parameters by reference, unless either they're lightweight enough to take by value, or in those rare cases where you need a null pointer to be a valid input meaning \"none of the above\". This policy isn't specific to strings.</p>\n<p>Non-const reference parameters are debatable, because from the calling code (without a good IDE), you can't immediately see whether they're passed by value or by reference, and the difference is important. So the code may be unclear. For const params, that doesn't apply. People reading the calling code can usually just assume that it's not their problem, so they'll only occasionally need to check the signature.</p>\n<p>In the case where you're going to take a copy of the argument in the function, your general policy should be to take the argument by value. Then you already have a copy you can use, and if you would have copied it into some specific location (like a data member) then you can move it (in C++11) or swap it (in C++03) to get it there. This gives the compiler the best opportunity to optimize cases where the caller passes a temporary object.</p>\n<p>For <code>string</code> in particular, this covers the case where your function takes a <code>std::string</code> by value, and the caller specifies as the argument expression a string literal or a <code>char*</code> pointing to a nul-terminated string. If you took a <code>const std::string&amp;</code> and copied it in the function, that would result in the construction of two strings.</p>\n", "CreationDate": "2009-06-23T13:20:05.420", "LastEditDate": "2012-11-16T09:26:51.470", "ParentId": "1032243", "Id": "1032537", "LastEditorUserId": "13005", "PostTypeId": "2", "Score": "14", "OwnerUserId": "13005"}, "1032271": {"CommentCount": "0", "Body": "<p>I agree with @duffymo. Don't optimize until you have measured, this holds double true when doing micro-optimizations. And always: measure <strong>before</strong> and <strong>after</strong> you've optimized, to see if you actually changed things to the better.</p>\n", "CreationDate": "2009-06-23T12:34:26.853", "ParentId": "1032243", "Id": "1032271", "LastActivityDate": "2009-06-23T12:34:26.853", "PostTypeId": "2", "Score": "1", "OwnerUserId": "13051"}, "1032516": {"CommentCount": "0", "Body": "<p>I agree with the other posters, that you should use string.</p>\n<p>But know, that depending on how aggressively your compiler optimizes temporaries, you will probably have some extra overhead (over using a dynamic array of chars).  (Note: The good news is that in C++0a, the judicious use of rvalue references will not require compiler optimizations to buy efficiency here - and programmers will be able to make some additional performance guarantees about their code without relying on the quality of the compiler.)</p>\n<p>In your situation, is the extra overhead worth introducing manual memory management?  Most reasonable programmers would disagree - but if your application does end up having performance issues, the next step would be to profile your application - thus, if you do introduce complexity, you only do it once you have good evidence that it is needed to improve overall efficiency.</p>\n<p>Someone mentioned that Return Value optimization (RVO) is irrelevant here - I disagree.</p>\n<p>The standard text (C++03) on this reads (12.2):</p>\n<p>[Begin Standard Quote]</p>\n<blockquote>\n<p id=\"so_1032243_1032516_0\">Temporaries of class type are created in various contexts: binding an rvalue to a reference (8.5.3), returning an rvalue (6.6.3), a conversion that creates an rvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1), entering a handler (15.3), and in some initializations (8.5). [Note: the lifetime of exception objects is described in 15.1. ] Even when the creation of the temporary object is avoided (12.8), all the semantic\n  restrictions must be respected as if the temporary object was created. [Example: even if the copy constructor is not called, all the semantic restrictions, such as accessibility (clause 11), shall be satisfied. ]</p>\n</blockquote>\n<pre>\n [Example:  \nstruct X {\n  X(int);\n  X(const X&amp;);\n  \u02dcX();\n};\n\nX f(X);\n\nvoid g()\n{\n  X a(1);\n  X b = f(X(2));\n  a = f(a);\n}\n</pre>\n<blockquote>\n<p id=\"so_1032243_1032516_1\">Here, an implementation might use a temporary in which to construct X(2) before passing it to f() using X\u2019s copy-constructor; alternatively, X(2) might be constructed in the space used to hold the argument.  Also, a temporary might be used to hold the result of f(X(2)) before copying it to b using X\u2019s copyconstructor; alternatively, f()\u2019s result might be constructed in b. On the other hand, the expression a=f(a) requires a temporary for either the argument a or the result of f(a) to avoid undesired aliasing of\n  a. ]</p>\n</blockquote>\n<p>[End Standard Quote]</p>\n<p>Essentially, the text above says that you can possibly rely on RVO in initialization situations, but not in assignment situations.  The reason is, when you are initializing an object, there is no way that what you are initializing it with could ever be aliased to the object itself (which is why you never do a self check in a copy constructor), but when you do an assignment, it could.</p>\n<p>There is nothing about your code, that inherently prohibits RVO - but read your compiler documentation to ensure that you can truly rely on it, if you do indeed need it.</p>\n", "CreationDate": "2009-06-23T13:16:16.083", "ParentId": "1032243", "Id": "1032516", "LastActivityDate": "2009-06-23T13:16:16.083", "PostTypeId": "2", "Score": "3", "OwnerUserId": "51103"}, "1034338": {"LastActivityDate": "2009-06-23T18:41:40.077", "CommentCount": "1", "Body": "<p>It's human nature to worry about performance especially when programming language supports low-level optimization. \nWhat we shouldn't forget as programmers though is that program performance is just one thing among many that we can optimize and admire. In addition to program speed we can find beauty in our own performance. We can minimize our efforts while trying to achieve maximum visual output and user-interface interactiveness. Do you think that could be more motivation that worrying about bits and cycles in a long run... So yes, return string:s. They minimize your code size, and your efforts, and make the amount of work you put in less depressing.</p>\n", "CreationDate": "2009-06-23T18:35:45.873", "LastEditDate": "2009-06-23T18:41:40.077", "ParentId": "1032243", "Id": "1034338", "LastEditorUserId": "11741", "PostTypeId": "2", "Score": "6", "OwnerUserId": "11741"}, "1032303": {"CommentCount": "0", "Body": "<p>Return the string, it's not that big of a loss in term of performance but it will surely ease your job afterward.</p>\n<p>Plus, you could always inline the function but most optimizer will fix it anyways.</p>\n", "CreationDate": "2009-06-23T12:39:25.173", "ParentId": "1032243", "Id": "1032303", "LastActivityDate": "2009-06-23T12:39:25.173", "PostTypeId": "2", "Score": "1", "OwnerUserId": "126912"}, "bq_ids": {"n4140": {"so_1032243_1032516_0": {"length": 34, "quality": 0.5666666666666667, "section_id": 378}, "so_1032243_1032516_1": {"length": 34, "quality": 0.8095238095238095, "section_id": 379}}, "n3337": {"so_1032243_1032516_0": {"length": 41, "quality": 0.6833333333333333, "section_id": 369}, "so_1032243_1032516_1": {"length": 34, "quality": 0.8095238095238095, "section_id": 370}}}, "1032262": {"LastActivityDate": "2009-06-23T12:35:46.600", "CommentCount": "0", "Body": "<p>Seems like a good idea.</p>\n<p>If this is not part of a realtime software (like a game) but a regular application, you should be more than fine.</p>\n<p>Remember, \"<a href=\"http://c2.com/cgi/wiki?PrematureOptimization\" rel=\"noreferrer\">Premature optimization is the root of all evil</a>\"</p>\n", "CreationDate": "2009-06-23T12:31:47.967", "LastEditDate": "2009-06-23T12:35:46.600", "ParentId": "1032243", "Id": "1032262", "LastEditorUserId": "20481", "PostTypeId": "2", "Score": "10", "OwnerUserId": "101421"}, "1033929": {"CommentCount": "0", "Body": "<p>If you pass a referenced string and you work on that string you don't need to return anything. ;)</p>\n", "CreationDate": "2009-06-23T17:14:53.030", "ParentId": "1032243", "Id": "1033929", "LastActivityDate": "2009-06-23T17:14:53.030", "PostTypeId": "2", "Score": "1", "OwnerUserId": "127716"}, "1032671": {"CommentCount": "6", "Body": "<p>The cost of copying strings by value varies based on the STL implementation you're working with:</p>\n<ul>\n<li><p>std::string under MSVC uses the short string optimisation, so that short strings (&lt; 16 characters iirc) don't require any memory allocation (they're stored within the std::string itself), while longer ones require a heap allocation every time the string is copied.</p></li>\n<li><p>std::string under GCC uses a reference counted implementation: when constructing a std::string from a char*, a heap allocation is done every time, but when passing by value to a function, a reference count is simply incremented, avoiding the memory allocation.</p></li>\n</ul>\n<p>In general, you're better off just forgetting about the above and returning std::strings by value, unless you're doing it thousands of times a second.</p>\n<p>re: parameter passing, keep in mind that there's a cost from going from char*-&gt;std::string, but not from going from std::string-&gt;char*. In general, this means you're better off accepting a const reference to a std::string. However, the best justification for accepting a const std::string&amp; as an argument is that then the callee doesn't have to have extra code for checking vs. null.</p>\n", "CreationDate": "2009-06-23T13:46:57.190", "ParentId": "1032243", "Id": "1032671", "LastActivityDate": "2009-06-23T13:46:57.190", "PostTypeId": "2", "Score": "12", "OwnerUserId": "127581"}, "1032504": {"CommentCount": "1", "Body": "<p>Beware when you cross module boundaries.</p>\n<p>Then it's best to return primitive types since C++ types are not necessarily binary compatible across even different versions of the same compiler.</p>\n", "CreationDate": "2009-06-23T13:14:12.450", "ParentId": "1032243", "Id": "1032504", "LastActivityDate": "2009-06-23T13:14:12.450", "PostTypeId": "2", "Score": "4", "OwnerUserId": "126225"}});