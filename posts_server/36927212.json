post_cb({"bq_ids": {"n4140": {"so_36927212_36927743_0": {"length": 33, "quality": 1.0, "section_id": 407}}, "n3337": {"so_36927212_36927743_0": {"length": 27, "quality": 0.8181818181818182, "section_id": 398}}, "n4659": {"so_36927212_36927743_0": {"length": 33, "quality": 1.0, "section_id": 425}}}, "36927743": {"Id": "36927743", "PostTypeId": "2", "Body": "<p>In a multi-threaded environment, you may be sharing the non-destructed class between threads.<br>\nIf the thread that allocates memory terminates, there is no reason a pointer to that allocated memory couldn't still be in use by another thread.  </br></p>\n<p>The standard implies that a constructed object with dynamic storage duration does not qualify for destructor invocation.</p>\n<p><strong>12.4  Destructors [class.dtor]</strong></p>\n<blockquote>\n<p id=\"so_36927212_36927743_0\">A destructor is invoked implicitly<br>\n   \u2014 for a constructed object with static storage duration at program termination,<br>\n   \u2014 for a constructed object with thread storage duration \n  at thread exit,<br>\n    \u2014 for a constructed object with automatic\n  storage duration when the block in which an object is created\n  exits,<br>\n    \u2014 for a constructed temporary object when its\n  lifetime ends.  </br></br></br></br></p>\n</blockquote>\n<hr>\n<p>We can see the benefits of this through a basic memory sharing example between threads:  </p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;iostream&gt;\n\n//shared object\nstruct A {\n\n    void say_hello(){ std::cout &lt;&lt; ++value &lt;&lt; '\\n'; }\n    ~A() = delete;\n    int value;\n};\n\n//two threads\nvoid creator();\nvoid user(A* a);\n\n//the creator allocates memory,\n//gives it to another thread (via pointer),\n//and then ends gracefully.  \n//It does not attempt to implicitly call the destructor.\n//Nor would we want it to for allocated memory we are sharing.\nvoid creator(){\n\n  A* a = new A();\n  a-&gt;value = 0;\n  std::thread t(user, a);\n  t.detach();\n}\n\n//The user recieves a pointer to memory,\n//and is free to continue using it\n//despite the creator thread ending\nvoid user(A* a){\n  while(1){\n    a-&gt;say_hello();\n  }\n}\n\n//main-&gt;creator-&gt;user\nint main(){\n  std::thread t(creator);\n  while(1){}\n}\n</code></pre>\n<hr>\n</hr></hr>", "LastEditorUserId": "908939", "LastActivityDate": "2016-04-29T01:05:12.110", "Score": "1", "CreationDate": "2016-04-29T00:45:14.153", "ParentId": "36927212", "CommentCount": "0", "OwnerUserId": "908939", "LastEditDate": "2016-04-29T01:05:12.110"}, "36927212": {"ViewCount": "208", "Body": "<p>If you have a class without a destructor:</p>\n<pre><code>struct A {\n    ~A() = delete;\n};\n</code></pre>\n<p>The standard does not let me \"locally\" allocate an instance of that class:</p>\n<pre><code>int main()\n{\n    A a; //error\n}\n</code></pre>\n<p>But it seems like it is ok if I allocate that on free-store:</p>\n<pre><code>int main()\n{\n    a *p = new A();\n}\n</code></pre>\n<p>As long as I dont call delete on that pointer:</p>\n<pre><code>int main()\n{\n    a *p = new A();\n    delete p; //error\n}\n</code></pre>\n<p>So my question is, why does the standard let me have a class without a destructor if I allocate it on free-store? I would guess there are some use cases for that? But what exactly? </p>\n", "AcceptedAnswerId": "36927909", "Title": "why does the standard let me free-store allocate classes without destructors?", "CreationDate": "2016-04-28T23:39:31.620", "Id": "36927212", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-04-29T00:01:32.607", "LastEditorUserId": "997527", "LastActivityDate": "2016-04-29T19:24:36.143", "Score": "5", "OwnerUserId": "997527", "Tags": "<c++><c++11><c++14>", "AnswerCount": "3"}, "36927909": {"Id": "36927909", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36927212_36927909_0\">So my question is, why does the standard let me have a class without a destructor if I allocate it on free-store?</p>\n</blockquote>\n<p>Because that's not how standard features work.</p>\n<p>The <code>= delete</code> syntax you're talking about was invented to solve a number of problems. One of them was very specific: making types that were move-only or immobile, for which the compiler would <a href=\"https://stackoverflow.com/questions/14085620/why-do-c11-deleted-functions-participate-in-overload-resolution/14085710#14085710\">issue a compile-time error</a> if you attempted to call a copy (or move) constructor/assignment operator.</p>\n<p>But the syntax has other purposes when applied generally. By <code>=delete</code>ing a function, you can prevent people from calling specific overloads of a function, mainly to stop certain kinds of problematic implicit conversions. If you don't call a function with a specific type, you get a compile-time error for calling a <code>delete</code>d overload. Therefore, <code>=delete</code> is allowed to be applied to any function.</p>\n<p>And the destructor of a class qualifies as \"any function\".</p>\n<p>The designed intent of the feature was not to make types which would be non-destructible. That's simply an outgrowth of permitting <code>=delete</code> on any function. It's not design or intent; it simply is.</p>\n<p>While there isn't much use to applying <code>=delete</code> to a destructor, there also isn't much use in having the specification to explicitly <em>forbid</em> its use on a destructor. And there <em>certainly</em> isn't much use in making <code>=delete</code> behave differently when applied to a destructor.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-04-29T01:04:47.250", "Score": "7", "CreationDate": "2016-04-29T01:04:47.250", "ParentId": "36927212", "CommentCount": "0", "OwnerUserId": "734069", "LastEditDate": "2017-05-23T11:52:41.043"}, "36927280": {"Id": "36927280", "PostTypeId": "2", "Body": "<p>With this:</p>\n<pre><code>A a;\n</code></pre>\n<p>You will call the destructor upon exiting the scope (and you have deleted the destructor, hence the error). With this:</p>\n<pre><code>A *a = new A();\n</code></pre>\n<p>You simply don't call the destructor (because you never use <code>delete</code>). The memory is cleaned up at the programs completion, but you are essentially guaranteeing a memory leak.  </p>\n<p>There is no reason for <code>c++</code> to disallow this behavior because this would create a very specific case to program into a compiler. For example, <code>c++</code> doesn't disallow this: </p>\n<pre><code>int *p; *p = 5;\n</code></pre>\n<p>Even though this is obviously bad, and will always be bad. It is up to the programmer to ensure they don't do this. </p>\n<p>There is no reason that you should delete your destructor because it is not a useful behavior. </p>\n", "LastEditorUserId": "1294207", "LastActivityDate": "2016-04-29T00:08:24.633", "Score": "5", "CreationDate": "2016-04-28T23:46:58.387", "ParentId": "36927212", "CommentCount": "7", "OwnerUserId": "1294207", "LastEditDate": "2016-04-29T00:08:24.633"}});