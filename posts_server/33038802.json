post_cb({"33038802": {"CommentCount": "6", "ViewCount": "627", "CreationDate": "2015-10-09T12:52:06.837", "LastActivityDate": "2015-10-09T16:26:43.353", "Title": "How to dynamically allocate a single int[10] object?", "AcceptedAnswerId": "33038925", "PostTypeId": "1", "Id": "33038802", "Score": "7", "Body": "<p>Obviously this won't work, because it's interpreted as allocating an array of <code>int</code>:</p>\n<pre><code>int (*ptr)[10] = new int[10];\n</code></pre>\n<p>Surprisingly, this doesn't work either:</p>\n<pre><code>typedef int arr10[10];\narr10 *ptr = new arr10;\n</code></pre>\n<p>This does work:</p>\n<pre><code>ptr = new int[1][10];\n</code></pre>\n<p>but it uses <code>new[]</code> rather than <code>new</code>.</p>\n<p>For my own curiosity, is it possible to use <code>new</code> to allocate a single object of type <code>int[10]</code>, rather than using <code>new[]</code> to allocate an array of 10 objects, or an array of one <code>int[10]</code> object?</p>\n", "Tags": "<c++>", "OwnerUserId": "1084944", "AnswerCount": "5"}, "33038967": {"ParentId": "33038802", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-09T13:01:02.423", "Score": "2", "LastEditorUserId": "60281", "LastEditDate": "2015-10-09T13:21:56.217", "Id": "33038967", "OwnerUserId": "60281", "Body": "<p>You <strong>are</strong> allocating an array of objects.</p>\n<p><code>T[10]</code> is 10 objects, not one. Actually, it's <em>eleven</em> objects -- an array (type <code>array of 10 T</code>), containing 10 <code>T</code> objects.</p>\n<p>This requires constructor calls for each <code>T</code>, and corresponding destructor calls when the array gets <code>delete</code>d, which is why <code>new[]</code> and <code>delete[]</code> are necessary for arrays, and <strong>if you try to work around that, your code will be broken.</strong></p>\n<p>So:</p>\n<pre><code>int * ptr = new int[10];\n\n// ...\n\ndelete [] ptr;\n</code></pre>\n<p>Or <a href=\"http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_array.htm\" rel=\"nofollow\">Boost it</a> (because naked pointers are ugly and error-prone):</p>\n<pre><code>boost::shared_array&lt; int &gt; ptr( new int[10] );\n\n// ...\n</code></pre>\n<p>Or (because not everyone likes Boost, and the standard has brought us <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow\">the <code>&lt;array&gt;</code> class</a>:</p>\n<pre><code>std::array&lt; int, 10 &gt; a;\n\n// ...\n</code></pre>\n<p>Or the old standby, <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\"><code>&lt;vector&gt;</code></a>:</p>\n<pre><code>std::vector&lt; int &gt; v( 10 );\n\n// ...\n</code></pre>\n", "LastActivityDate": "2015-10-09T13:21:56.217"}, "33038925": {"ParentId": "33038802", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-09T12:59:15.043", "Score": "7", "LastEditorUserId": "445517", "LastEditDate": "2015-10-09T16:15:46.467", "Id": "33038925", "OwnerUserId": "5427663", "Body": "<p>This is not possible. Arrays in C++ do not have first-class object semantics, for example they cannot be passed to functions* or returned from functions.</p>\n<p>You can use std::array in C++11. It has many advantages: object semantics, index checks in debug mode, iterator and STL interface, <code>size()</code> method, no implicit conversion to pointers. When you have access to a C++11 compiler, there's almost no reason to use plain old C arrays anymore.</p>\n<hr>\n<p>* It is only possible to pass pointers to elements or pointers/references to the array.</p>\n</hr>", "LastActivityDate": "2015-10-09T16:15:46.467"}, "33039030": {"ParentId": "33038802", "CommentCount": "0", "CreationDate": "2015-10-09T13:04:02.557", "OwnerUserId": "5420624", "PostTypeId": "2", "Id": "33039030", "Score": "1", "Body": "<p>The <code>new</code> operator allocate memory for one element of a type. It's the way it works. If you want to allocate a sequence of more than one element you need to use the array operator and specify the number of the element you want <code>new int[5]</code>. If you realy want to do something like that you can define a struct and set a array on it. So after that when you call new, this will allocate the array himself.</p>\n<pre><code>typedef struct TEST{\n    int testInt[5];\n};\n\nTEST* myVarTest = new TEST();\n</code></pre>\n", "LastActivityDate": "2015-10-09T13:04:02.557"}, "33039043": {"ParentId": "33038802", "CommentCount": "0", "CreationDate": "2015-10-09T13:04:48.877", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "33039043", "Score": "2", "Body": "<p><code>new int[10]</code> <em>does</em> allocate a single object of type <code>int[10]</code>, that is, an array of 10 <code>int</code>s. The return value of the expression is a pointer to the first element of this array, though. Quoting C++14, 5.3.4/5:</p>\n<blockquote>\n<p id=\"so_33038802_33039043_0\">When the allocated object is an array (that is, the <em>noptr-new-declarator syntax</em> is used or the <em>new-type-id</em> or\n  <em>type-id</em> denotes an array type), the <em>new-expression</em> yields a pointer to the initial element (if any) of the array.\n  [ <em>Note:</em> both <code>new int</code> and <code>new int[10]</code> have type <code>int*</code> and the type of new <code>int[i][10]</code> is <code>int (*)[10]</code>\n<em>\u2014end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2015-10-09T13:04:48.877"}, "bq_ids": {"n4140": {"so_33038802_33039043_0": {"section_id": 6086, "quality": 0.90625, "length": 29}, "so_33038802_33039097_0": {"section_id": 6290, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_33038802_33039043_0": {"section_id": 5854, "quality": 0.90625, "length": 29}, "so_33038802_33039097_0": {"section_id": 6050, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_33038802_33039043_0": {"section_id": 7582, "quality": 0.875, "length": 28}, "so_33038802_33039097_0": {"section_id": 7797, "quality": 0.5555555555555556, "length": 5}}}, "33039097": {"ParentId": "33038802", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2015-10-09T13:07:19.590", "Score": "2", "LastEditorUserId": "464581", "LastEditDate": "2015-10-09T16:26:43.353", "Id": "33039097", "OwnerUserId": "464581", "Body": "<p>One way, working <sup>1</sup>within the imperfect type system rules:</p>\n<pre><code>auto main() -&gt; int\n{\n    using Ten_ints = int [10];\n    Ten_ints* p_ints = []() -&gt; Ten_ints*\n    {\n        struct Wrapper{ Ten_ints a; };\n        return &amp;(new Wrapper)-&gt;a;\n    }();\n    (void) p_ints;\n}\n</code></pre>\n<p>A more direct way, taking charge of things:</p>\n<pre><code>auto main() -&gt; int\n{\n    using Ten_ints = int [10];\n    Ten_ints* p_ints = reinterpret_cast&lt;Ten_ints*&gt;( new Ten_ints );\n    (void) p_ints;\n}\n</code></pre>\n<p>The first snippet does what the OP asked (quoted at the end of this answer), using plain <code>new</code> instead of <code>new[]</code> to allocate the object. The second snippet shows the IMO most natural way to use <code>new[]</code> instead. The OP's suggestion of <code>new int[1][10]</code> is a second way to do that (and is thus a third way to obtain the pointer to array), and has the advantage of working within the type system, but the drawback that it's not very obvious.</p>\n<p>In conclusion, the answer to</p>\n<blockquote>\n<p id=\"so_33038802_33039097_0\"><strong>\u201d</strong> is it possible to use [non-array] <code>new</code> to allocate a single object of type <code>int[10]</code></p>\n</blockquote>\n<p>is, of course.</p>\n<hr>\n<p><sup>\n<sup>1</sup> The standard guarantees that there's no padding at the start of a POD <code>struct</code>. In practice that means that deallocation is no problem either. But for the formal one would need to use the same type for deallocation as for allocation.</sup></p>\n</hr>", "LastActivityDate": "2015-10-09T16:26:43.353"}});