post_cb({"bq_ids": {"n4140": {"so_430401_430513_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 7165}, "so_430401_430513_1": {"length": 12, "quality": 0.6, "section_id": 7164}}, "n3337": {"so_430401_430513_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 6909}, "so_430401_430513_1": {"length": 12, "quality": 0.6, "section_id": 6908}}, "n4659": {"so_430401_430513_2": {"length": 18, "quality": 0.8571428571428571, "section_id": 8673}, "so_430401_430513_1": {"length": 12, "quality": 0.6, "section_id": 8672}}}, "430401": {"ViewCount": "987", "Body": "<p>Anyone have a link to what the C++ standard says regarding a compiler removing global and static symbols?  I thought you weren't guaranteed that the compiler will remove global symbols if they're not referenced. A colleague of mine asserts that if your global symbols are included in the main translation unit, those symbols will not be removed even if they're not referenced.  </p>\n", "AcceptedAnswerId": "430513", "Title": "C++ Standard and Global Symbol Removal", "CreationDate": "2009-01-10T02:14:59.987", "Id": "430401", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "Michael Kelley", "LastActivityDate": "2009-01-12T15:12:01.027", "Score": "1", "OwnerUserId": "45459", "Tags": "<c++><compiler-construction><linker>", "AnswerCount": "3"}, "430947": {"Body": "<p>It's this way i believe (we had a lengthy discussion on this earlier on stack overflow in a comment-thread):</p>\n<ol>\n<li>If the initialization or destructor of an object with namespace scope (that are objects with static storage duration) has no side-effects, the objet can be optimized out if there is no use of a function or object in its translation unit. </li>\n<li>For objects whose initialization or destruction cause side effects, then the compiler may not optimize that variable out, even if there is no use of objects or functions of its translation units. </li>\n</ol>\n<p>In any case, the compiler has to initialize the objects before that use is done, but not necessarily before main. I did tests because someone at stackoverflow said that gcc effectively optimizes out initializations of objects having side effects if there is no such use. I tested that now, and I've seen gcc does not do that. Additionally, as i understand the Standard, it is not allowed to do so anyway. </p>\n<p>It suffices if you just take the address of an object or function of the translation unit of the object you want to have initialized. To be on the safe side, better always do that, even for objects having initializations with side effects. Assuming your friend is right, i think for the translation unit of main, <code>main</code> is always seen as being <em>used</em>, so that condition immediately is satisfied. Rules can be found in <code>3.6.2p3</code>, <code>3.7.1p2</code> and <code>3.2p2</code> (definition of <em>use</em>), <code>1.9p7</code> (definition of <em>side-effect</em>).</p>\n", "CreationDate": "2009-01-10T13:19:34.920", "ParentId": "430401", "CommentCount": "0", "LastEditDate": "2009-01-10T22:11:44.313", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-01-10T22:11:44.313", "LastEditorUserId": "34509", "Id": "430947", "OwnerDisplayName": "litb", "Score": "0", "OwnerUserId": "34509"}, "430513": {"Id": "430513", "PostTypeId": "2", "Body": "<p>Interestingly, all I can find on this in the C++2003 standard is this:</p>\n<blockquote>\n<p id=\"so_430401_430513_0\">3.7.1 Static storage duration [basic.stc.static]</p>\n<p id=\"so_430401_430513_1\">All objects which neither have dynamic\n  storage duration nor are local have\n  static storage duration. The storage\n  for these objects shall last for the\n  duration of the program (3.6.2,\n  3.6.3).</p>\n<p id=\"so_430401_430513_2\">If an object of static storage\n  duration has initialization or a\n  destructor with side effects, it shall\n  not be eliminated even if it appears\n  to be unused, except that a class\n  object or its copy may be eliminated\n  as specified in\n  12.8.</p>\n</blockquote>\n<p>This implies that the standard permits elimination of items in static storage if initialization and destruction of them have no side effects and they are otherwise unused.</p>\n<p>If there's a more direct permission, I didn't see it (but maybe someone else will).</p>\n<p>However, it should be noted that having the linker eliminate unused objects in the final image is a very common optimization.</p>\n", "OwnerDisplayName": "Michael Burr", "LastActivityDate": "2009-01-10T03:35:04.927", "Score": "3", "CreationDate": "2009-01-10T03:35:04.927", "ParentId": "430401", "CommentCount": "0", "OwnerUserId": "12711"}, "430646": {"Body": "<p>You're asking a question about linking, and although the C++ Standard says that linking should occur as the final phase of translation, it says nothing about <em>how</em> that should happen. For example, it says that function references are resolved, but it doesn't require them to be resolved by name, and it doesn't say what happens to the references after resolution.</p>\n<p>To determine what symbols the compiler includes in the object code, and which ones the linker does or doesn't remove, you'll need to consult the documentation for the compiler and linker, respectively, that you're using.</p>\n", "CreationDate": "2009-01-10T06:00:00.047", "ParentId": "430401", "CommentCount": "2", "LastEditDate": "2009-01-12T15:12:01.027", "PostTypeId": "2", "LastEditorDisplayName": "Rob Kennedy", "LastActivityDate": "2009-01-12T15:12:01.027", "LastEditorUserId": "33732", "Id": "430646", "OwnerDisplayName": "Rob Kennedy", "Score": "0", "OwnerUserId": "33732"}});