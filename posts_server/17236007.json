post_cb({"17236007": {"CommentCount": "1", "CreationDate": "2013-06-21T11:28:38.710", "PostTypeId": "1", "AcceptedAnswerId": "17236008", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-13T16:45:53.563", "AnswerCount": "2", "LastEditDate": "2017-05-23T10:33:55.337", "ViewCount": "1092", "FavoriteCount": "2", "Title": "const reference to a temporary object becomes broken after function scope (life time)", "Id": "17236007", "Score": "5", "Body": "<p>While asking <a href=\"https://stackoverflow.com/questions/15267676/reference-to-an-unnamed-temporary-object-life-time\">this question</a>, I learned const reference to a temporary object is valid in C++:</p>\n<pre><code>int main ()\n{\n  int a = 21;\n  int b = 21;\n\n  //error: invalid initialization of non-const reference\n  //int     &amp; sum = a + b;e [...]\n\n  //OK\n  int const &amp; sum = a + b;\n\n  return sum;\n}\n</code></pre>\n<p>But in the following example, the const reference <code>refnop</code> refers to a destroyed temporary object. I wonder why?</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;map&gt;\n\nstruct A\n{\n   // data \n   std::map &lt;std::string, std::string&gt;  m;\n   // functions\n   const A&amp; nothing()           const { return *this;    }\n   void init()                        { m[\"aa\"] = \"bb\";  }\n   bool operator!= (A const&amp; a) const { return a.m != m; }\n};\n\nint main()\n{\n  A a;\n  a.init();\n\n  A const&amp; ref    = A(a);\n  A const&amp; refnop = A(a).nothing();\n\n  int ret = 0;\n  if (a != ref)     ret += 2;\n  if (a != refnop)  ret += 4;\n\n  return ret;\n}\n</code></pre>\n<p>Tested using GCC 4.1.2 and MSVC 2010, it returns 4;</p>\n<pre><code>$&gt; g++ -g refnop.cpp\n$&gt; ./a.out ; echo $?\n4\n</code></pre>\n<p>The difference between <code>ref</code> and <code>refnop</code> is the call to <code>nothing()</code> which does really nothing. It seems after this call, the temporary object is destroyed!</p>\n<p>My question: <br>\n<strong>Why in the case of <code>refnop</code>, the life time of the temporary object is not the same as its const reference?</strong></br></p>\n", "Tags": "<c++><reference><scope><temporary-objects><const-reference>", "OwnerUserId": "938111", "OwnerDisplayName": "olibre"}, "24210020": {"ParentId": "17236007", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>My original example is complex.</p>\n<p>Therefore I post here a simpler example and I provide the corresponding <a href=\"https://stackoverflow.com/questions/7238958\">ISO C++ standard</a> paragraph.</p>\n<p>This simpler example is also available on <a href=\"http://coliru.stacked-crooked.com/a/44235a89f1bdb30e\" rel=\"nofollow noreferrer\">coliru.stacked-crooked.com/</a></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n  A(int i) { std::cout&lt;&lt;\"Cstr \"&lt;&lt; i&lt;&lt;'\\n'; p = new int(i); }\n ~A()      { std::cout&lt;&lt;\"Dstr \"&lt;&lt;*p&lt;&lt;'\\n'; delete p;       }\n\n  const A&amp; thiz() const { return *this; }\n\n  int *p;\n};\n\nconst A&amp; constref( const A&amp; a )\n{\n  return a;\n}\n\nint main()\n{\n  const A&amp; a4 = A(4);\n  const A&amp; a5 = A(5).thiz();\n  const A&amp; a6 = constref( A(6) );\n\n  std::cout &lt;&lt; \"a4 = \"&lt;&lt; *a4.p &lt;&lt;'\\n';\n  std::cout &lt;&lt; \"a5 = \"&lt;&lt; *a5.p &lt;&lt;'\\n';\n  std::cout &lt;&lt; \"a6 = \"&lt;&lt; *a6.p &lt;&lt;'\\n';\n}\n</code></pre>\n<p>The output using command line <code>g++-4.8 -std=c++11 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out</code>:   </p>\n<pre><code>Cstr 4\nCstr 5\nDstr 5\nCstr 6\nDstr 6\na4 = 4\na5 = 0\na6 = 0\nDstr 4\n</code></pre>\n<p>As you can see, the temporary objects referenced by <code>a5</code> and <code>a6</code> are destructed at the end of functions <code>thiz</code> and <code>constref</code> respectively.</p>\n<p>This is an extract of <em>\u00a712.2 Temporary objects</em>, where the bold part applies in this case:</p>\n<blockquote>\n<p id=\"so_17236007_24210020_0\">The second context is when a reference is bound to a temporary.\n  The temporary to which the reference is bound or the temporary \n  that is the complete object of a subobject to which the reference \n  is bound persists for the lifetime of the reference except:</p>\n<ul>\n<li>A temporary bound to a reference member in  a constructor\u2019s \n  ctor-initializer (12.6.2) persists until the constructor exits. </li>\n<li>A temporary bound to a reference parameter in a function call (5.2.2) \n  persists until the completion of the full-expression containing the call.</li>\n<li><strong>The lifetime of a temporary bound to the returned value in \n  a function return statement (6.6.3) is not extended; the temporary \n  is destroyed at the end of the full-expression in the return statement.</strong></li>\n<li>A temporary bound to a reference in a <em>new-initializer</em> (5.3.4) persists \n  until the completion of the full-expression containing the <em>new-initializer</em>.</li>\n</ul>\n</blockquote>\n<hr>\n<p>This is a more complete example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n     A()         { std::cout&lt;&lt;\"Cstr 9\\n\";         p = new int(v = 9);      }\n     A(int i)    { std::cout&lt;&lt;\"Cstr \"&lt;&lt;i&lt;&lt;'\\n';   p = new int(v = i);      }\n     A(const A&amp;o){ std::cout&lt;&lt;\"Copy \"&lt;&lt;o.v&lt;&lt;'\\n'; p = new int(v = 10+o.v); }\n    ~A()         { std::cout&lt;&lt;\"Del \"&lt;&lt;v&lt;&lt;' '&lt;&lt;*p&lt;&lt;'\\n'; *p = 88; delete p; }\n\n    const A&amp; thiz() const { return *this; }\n\n    int *p;\n    int  v;\n};\n\nconst A&amp; constref( const A&amp; a )\n{\n  return a;\n}\n\nstd::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const A&amp; a )\n{\n  os &lt;&lt;\"{ *p=\"&lt;&lt; *a.p &lt;&lt;\" , v=\"&lt;&lt; a.v &lt;&lt;\" }\\n\";\n  return os;\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"---const A  a1 = A(1)\"                \"\\n\";\n                     const A  a1 = A(1);\n    std::cout &lt;&lt; \"---const A  a2 = A(2).thiz()\"         \"\\n\";\n                     const A  a2 = A(2).thiz();\n    std::cout &lt;&lt; \"---const A  a3 = constref( A(3) )\"    \"\\n\";\n                     const A  a3 = constref( A(3) );\n    std::cout &lt;&lt; \"---const A&amp; a4 = A(4)\"                \"\\n\";\n                     const A&amp; a4 = A(4);\n    std::cout &lt;&lt; \"---const A&amp; a5 = A(5).thiz()\"         \"\\n\";\n                     const A&amp; a5 = A(5).thiz();\n    std::cout &lt;&lt; \"---const A&amp; a6 = constref( A(6) )\"    \"\\n\";\n                     const A&amp; a6 = constref( A(6) );\n\n    std::cout &lt;&lt; \"a1 = \"&lt;&lt; a1;\n    std::cout &lt;&lt; \"a2 = \"&lt;&lt; a2;\n    std::cout &lt;&lt; \"a3 = \"&lt;&lt; a3;\n    std::cout &lt;&lt; \"a4 = \"&lt;&lt; a4;\n    std::cout &lt;&lt; \"a5 = \"&lt;&lt; a5;\n    std::cout &lt;&lt; \"a6 = \"&lt;&lt; a6;\n}\n</code></pre>\n<p>And the corresponding output using same <code>g++</code> command line:</p>\n<pre><code>---const A  a1 = A(1)\nCstr 1\n---const A  a2 = A(2).thiz()\nCstr 2\nCopy 2\nDel 2 2\n---const A  a3 = constref( A(3) )\nCstr 3\nCopy 3\nDel 3 3\n---const A&amp; a4 = A(4)\nCstr 4\n---const A&amp; a5 = A(5).thiz()\nCstr 5\nDel 5 5\n---const A&amp; a6 = constref( A(6) )\nCstr 6\nDel 6 6\na1 = { *p=1 , v=1 }\na2 = { *p=12 , v=12 }\na3 = { *p=13 , v=13 }\na4 = { *p=4 , v=4 }\na5 = { *p=0 , v=5 }\na6 = { *p=0 , v=6 }\nDel 4 4\nDel 13 13\nDel 12 12\nDel 1 1\n</code></pre>\n</hr>", "OwnerUserId": "938111", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:28:34.480", "Id": "24210020", "Score": "1", "CreationDate": "2014-06-13T16:34:07.207", "LastActivityDate": "2014-06-13T16:39:21.820"}, "bq_ids": {"n4140": {"so_17236007_24210020_0": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_17236007_24210020_0": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_17236007_24210020_0": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}}}, "17236008": {"ParentId": "17236007", "CommentCount": "0", "Body": "<p>The lifetime-extension of a temporary object can be performed only once, when the temporary object gets bound to the first reference. After that, the knowledge that the reference refers to a temporary object is gone, so further lifetime extensions are not possible.</p>\n<p>The case that is puzzling you</p>\n<pre><code>A const&amp; refnop = A(a).nothing();\n</code></pre>\n<p>is similar to this case:</p>\n<pre><code>A const&amp; foo(A const&amp; bar)\n{\n    return bar;\n}\n//...\nA const&amp; broken = foo(A());\n</code></pre>\n<p>In both cases, the temporary gets bound to the function argument (the implicit <code>this</code> for <code>nothing()</code>, <code>bar</code> for <code>foo()</code>) and gets its lifetime 'extended' to the lifetime of the function argument. I put 'extended' in quotes, because the natural lifetime of the temporary is already longer, so no actual extension takes place.</p>\n<p>Because the lifetime extension property is non-transitive, returning a reference (that happens to refer to a temporary object) will not further extend the lifetime of the temporary object, with as result that both <code>refnop</code> and <code>broken</code> end up referring to objects that no longer exist.</p>\n", "OwnerUserId": "430719", "Id": "17236008", "PostTypeId": "2", "OwnerDisplayName": "Bart van Ingen Schenau", "Score": "9", "CreationDate": "2013-06-21T12:09:11.243", "LastActivityDate": "2013-06-21T12:09:11.243"}});