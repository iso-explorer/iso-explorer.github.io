post_cb({"44515378": {"CommentCount": "4", "ViewCount": "67", "PostTypeId": "1", "LastEditorUserId": "608639", "CreationDate": "2017-06-13T07:51:04.983", "LastActivityDate": "2017-06-13T14:06:45.623", "Title": "Understanding ARM assembly instructions and C/C++ pointers", "LastEditDate": "2017-06-13T14:06:45.623", "Id": "44515378", "Score": "-5", "Body": "<p>I am trying to decode the assembly instruction that operates on address, 16 bit ARM thumb instruction. So, I don't think I should care about data type. Because I'm only interested in the 16 bits store there. I have separate interpreter to make sense of those bits, I don't want to use that as data anyway.</p>\n<p>If I have a pointer <code>p</code> and I want to read 4 bytes (i.e data from <code>p</code> to <code>p+3</code> address). Will casting <code>p</code> to <code>int *</code> and dereferencing give me the data?</p>\n", "Tags": "<c++><linux><pointers>", "OwnerUserId": "5327962", "AnswerCount": "1"}, "44515398": {"ParentId": "44515378", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have a pointer <em>to-some-type</em>. Pointer arithmetic and dereferencing honors the data type.</p>\n<p><strong>Please note,</strong> you can only access the stored value of any variable (object) by an lvalue expression that has either a compatible type or a character pointer. Blindly forcing a pointer to cast to a different non-compatible type and attempt to dereference that will violate the strict aliasing rule and you'll face  <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a>.</p>\n<p>Quoting <code>C11</code>, chapter \u00a76.5</p>\n<blockquote>\n<p id=\"so_44515378_44515398_0\">An object shall have its stored value accessed only by an lvalue expression that has one of\n  the following types:<sup>88)</sup></p>\n<p id=\"so_44515378_44515398_1\">\u2014 a type compatible with the effective type of the object,</p>\n<p id=\"so_44515378_44515398_2\">\u2014 a qualified version of a type compatible with the effective type of the object,</p>\n<p id=\"so_44515378_44515398_3\">\u2014 a type that is the signed or unsigned type corresponding to the effective type of the\n  object,</p>\n<p id=\"so_44515378_44515398_4\">\u2014 a type that is the signed or unsigned type corresponding to a qualified version of the\n  effective type of the object,</p>\n<p id=\"so_44515378_44515398_5\">\u2014 an aggregate or union type that includes one of the aforementioned types among its\n  members (including, recursively, a member of a subaggregate or contained union), or</p>\n<p id=\"so_44515378_44515398_6\">\u2014 a character type.</p>\n</blockquote>\n<p>You can however, always use a <code>char *</code> to point to any type and dereference and increment (and repeat) to get the individual values for the bytes but you need to take care of endianness yourself.</p>\n<p>Related, quoting <code>C11</code>, chapter \u00a76.3.2.3</p>\n<blockquote>\n<p id=\"so_44515378_44515398_7\">[....] When a pointer to an object is converted to a pointer to a character type,\n  the result points to the lowest addressed byte of the object. Successive increments of the\n  result, up to the size of the object, yield pointers to the remaining bytes of the object.</p>\n</blockquote>\n", "OwnerUserId": "2173917", "LastEditorUserId": "2173917", "LastEditDate": "2017-06-13T08:06:33.750", "Id": "44515398", "Score": "4", "CreationDate": "2017-06-13T07:52:13.820", "LastActivityDate": "2017-06-13T08:06:33.750"}, "bq_ids": {"n4140": {"so_44515378_44515398_3": {"section_id": 7239, "quality": 0.875, "length": 7}, "so_44515378_44515398_4": {"section_id": 7239, "quality": 0.8, "length": 8}, "so_44515378_44515398_5": {"section_id": 7239, "quality": 1.0, "length": 16}, "so_44515378_44515398_2": {"section_id": 576, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_44515378_44515398_3": {"section_id": 6983, "quality": 0.875, "length": 7}, "so_44515378_44515398_4": {"section_id": 6983, "quality": 0.8, "length": 8}, "so_44515378_44515398_5": {"section_id": 6983, "quality": 1.0, "length": 16}, "so_44515378_44515398_2": {"section_id": 407, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_44515378_44515398_3": {"section_id": 8748, "quality": 0.875, "length": 7}, "so_44515378_44515398_4": {"section_id": 8748, "quality": 0.8, "length": 8}, "so_44515378_44515398_1": {"section_id": 802, "quality": 0.8, "length": 4}, "so_44515378_44515398_5": {"section_id": 8748, "quality": 1.0, "length": 16}, "so_44515378_44515398_2": {"section_id": 599, "quality": 0.5714285714285714, "length": 4}}}});