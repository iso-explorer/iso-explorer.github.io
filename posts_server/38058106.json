post_cb({"bq_ids": {"n4140": {"so_38058106_38059018_3": {"section_id": 7173, "quality": 0.8461538461538461, "length": 11}, "so_38058106_38059018_2": {"section_id": 7173, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_38058106_38059018_3": {"section_id": 6917, "quality": 0.8461538461538461, "length": 11}, "so_38058106_38059018_2": {"section_id": 6917, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_38058106_38059018_3": {"section_id": 8681, "quality": 0.8461538461538461, "length": 11}, "so_38058106_38059018_2": {"section_id": 8681, "quality": 0.8461538461538461, "length": 11}}}, "38058240": {"ParentId": "38058106", "LastEditDate": "2016-06-27T16:00:36.617", "CommentCount": "9", "CreationDate": "2016-06-27T15:48:50.427", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "PostTypeId": "2", "Id": "38058240", "Score": "0", "Body": "<blockquote>\n<p id=\"so_38058106_38058240_0\">When the program ends does the items in the heap are destroyed by order?</p>\n</blockquote>\n<p>No. Objects that have dynamic storage (i.e. objects that are stored \"on the heap\") are not destroyed when the program ends. They are destroyed when <code>delete</code> is called on the pointer that points to the object. That happens before the program has ended, unless the pointer was leaked. If the pointer had leaked, then the object will not be destroyed at all.</p>\n", "LastActivityDate": "2016-06-27T16:00:36.617"}, "38058106": {"CommentCount": "4", "ViewCount": "79", "PostTypeId": "1", "ClosedDate": "2016-06-27T17:30:47.237", "LastEditorUserId": "366904", "CreationDate": "2016-06-27T15:41:40.717", "LastActivityDate": "2016-06-27T16:34:36.903", "Title": "heap destruction of classes and globals", "LastEditDate": "2016-06-27T15:52:42.280", "Id": "38058106", "Score": "-2", "Body": "<p>When the program ends does the items in the heap are destroyed by order?</p>\n<p>What could be the result of the following scenario:</p>\n<ol>\n<li>create class a1,\nclass a1 contains static std::map </li>\n<li>create class b1, b1 destructor print the map content</li>\n<li><p>insert data to map</p>\n<pre><code>std::string mapkey = \"abcd\";\nmap.insert(make_pair(mapkey,20));\n</code></pre></li>\n<li><p>exit program</p></li>\n</ol>\n<p>In case class b1 destructor prints the value of 'mapkey', is it possible that map key string will be destroyed before class b since it was created after class b1? and therefore cause a core dump (since '\\0' will is not at the end of the array)?</p>\n", "Tags": "<c++><destructor><heap-memory><stdmap>", "OwnerUserId": "1540482", "AnswerCount": "2"}, "38059018": {"ParentId": "38058106", "CommentCount": "0", "Body": "<p>The standard says:</p>\n<blockquote>\n<p id=\"so_38058106_38059018_0\">3.7.3</p>\n<p id=\"so_38058106_38059018_1\">Dynamic storage duration [basic.stc.dynamic]</p>\n<blockquote>\n<p id=\"so_38058106_38059018_3\">1 Objects can be created dynamically during program execution (1.9),\n    using newexpressions (5.3.4), and destroyed using deleteexpressions\n    (5.3.5).</p>\n</blockquote>\n</blockquote>\n<p>What this means is that at the termination of your program, any object allocated with <code>new</code> that your program has not released with <code>delete</code> will still be extant and no attempt to destroy it or its members will be made. The object and all of its members will be 'leaked'. Most operating systems will simply reclaim the lost memory once the process is ended, but again, they won't c++-destroy the objects represented there.</p>\n<p>Example:</p>\n<pre><code>#include &lt;map&gt;\n\nstruct A {\n    std::map&lt;int, int&gt; m;\n    int i;\n};\n\nint main() {\n    A a1;  // cleaned up on scope exit\n    A* a2 = new A;  // pointer lost on scope exit -- leak\n}\n</code></pre>\n<p>Because we don't <code>delete</code> a2, neither the class nor any of its members are destroyed, all of the memory used by a2 and its members remains allocated until the operating system reclaims the processes memory.</p>\n<p>You can leverage <a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII</a> to manage this, indeed C++11 and beyond provide \"smart pointers\" to handle this. Basically, a smart pointer is an object wrapper around a pointer; when the object goes out of scope it is destructed, and the [default] destructor frees the pointer:</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;memory&gt;\n\nstruct A {\n    std::map&lt;int, int&gt; m;\n    int i;\n};\n\nint main() {\n    A a1;  // concreate instance: destructed on scope exit\n    std::unique_ptr&lt;A&gt; a2 = std::make_unique&lt;A&gt;();\n    // a2 is a concrete instance of a unique_ptr, so is destructed on scope exit\n    // and it's destructor will delete the object pointed to for us.\n}\n</code></pre>\n<p><code>unique_ptr</code>s have very minimal overhead, they are pretty much just a pointer with a wrapper that knows when it goes out of scope it needs to call it's objects' destructor for you.</p>\n<p>In the above example, we could have shorted our <code>unique_ptr</code>s definition to:</p>\n<pre><code>    auto a2 = std::make_unique&lt;A&gt;();\n</code></pre>\n", "OwnerUserId": "257645", "PostTypeId": "2", "Id": "38059018", "Score": "1", "CreationDate": "2016-06-27T16:34:36.903", "LastActivityDate": "2016-06-27T16:34:36.903"}});