post_cb({"12428096": {"ParentId": "12423460", "CommentCount": "4", "Body": "<p>Using <code>std::vector&lt;Bar&gt;</code> in a program where <code>Bar</code> does not meet the requirements for <code>std::vector</code> produces undefined behaviour. This is from 17.6.4.8 [res.on.functions] in the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_12423460_12428096_0\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C ++ standard library depends on components supplied by a C ++ program. If these components do not meet their requirements, the Standard places no requirements on the implementation.</p>\n<p id=\"so_12423460_12428096_1\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_12423460_12428096_2\">...</p>\n<p id=\"so_12423460_12428096_3\">\u2014 for types used as template arguments when instantiating a template component, if the operations on the type do not implement the semantics of the applicable Requirements subclause (17.6.3.5, 23.2, 24.2, 26.2). </p>\n<p id=\"so_12423460_12428096_4\">...</p>\n<p id=\"so_12423460_12428096_5\">\u2014 if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</p>\n</blockquote>\n", "OwnerUserId": "5597", "PostTypeId": "2", "Id": "12428096", "Score": "0", "CreationDate": "2012-09-14T16:00:59.883", "LastActivityDate": "2012-09-14T16:00:59.883"}, "12423460": {"CommentCount": "4", "ViewCount": "217", "PostTypeId": "1", "LastEditorUserId": "442284", "CreationDate": "2012-09-14T11:19:10.863", "LastActivityDate": "2012-09-14T16:00:59.883", "Title": "C++ meta-programming with \"invalid\" template parameters - is it permitted?", "LastEditDate": "2012-09-14T12:13:57.267", "Id": "12423460", "Score": "1", "Body": "<p>In some of my code where I use meta-programming techniques, we use templated arguments that get forwarded elsewhere and later converted, so we never actually create instances of some of these classes.</p>\n<p>In particular, we use <code>std::vector&lt;T&gt;</code> where T does not have the semantics to be included in a vector. In reality though we create a <code>std::vector&lt;shared_ptr&lt;T&gt; &gt;</code>.</p>\n<p>The code looks a bit like this:</p>\n<pre><code>class Bar : noncopyable\n{ \n    // whatever\n};\n\nclass Foo : public FooInterface\n{\n  public:\n    explicit Foo( std::vector&lt; shared_ptr&lt;Bar&gt; &gt; );\n};\n\ntypedef Builder1Param&lt; FooInterface, Foo, std::vector&lt;Bar&gt; &gt; FooBuilder;\n</code></pre>\n<p>through clever meta-programming techniques, FooBuilder knows that it will pass in a <code>vector&lt;shared_ptr&lt;Bar&gt; &gt;</code> to <code>Foo</code> and not a <code>vector&lt;Bar&gt;</code>. The issue is that because Bar is non-copyable it is an invalid type for a vector.</p>\n<p>Now the code compiles fine on any compiler that I have used this, but I would like to know if it is valid C++ (and will continue to be so into C++11 and beyond).</p>\n<p>I should possibly add that Bar may actually be abstract (and often will be). The purpose is to indicate that the parameter is a collection of these (in a sense in the style of Java/C# references). </p>\n", "Tags": "<c++><c++11><metaprogramming>", "OwnerUserId": "442284", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12423460_12428096_0": {"section_id": 6323, "quality": 0.9583333333333334, "length": 23}, "so_12423460_12428096_3": {"section_id": 6324, "quality": 0.7222222222222222, "length": 13}, "so_12423460_12428096_5": {"section_id": 6324, "quality": 1.0, "length": 11}, "so_12423460_12428096_1": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_12423460_12428096_3": {"section_id": 6081, "quality": 0.7222222222222222, "length": 13}, "so_12423460_12428096_0": {"section_id": 6080, "quality": 0.9583333333333334, "length": 23}, "so_12423460_12428096_5": {"section_id": 6081, "quality": 1.0, "length": 11}, "so_12423460_12428096_1": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_12423460_12428096_0": {"section_id": 7833, "quality": 0.9583333333333334, "length": 23}, "so_12423460_12428096_3": {"section_id": 7834, "quality": 0.7222222222222222, "length": 13}, "so_12423460_12428096_1": {"section_id": 7834, "quality": 1.0, "length": 5}, "so_12423460_12428096_5": {"section_id": 7834, "quality": 1.0, "length": 11}}}, "12423587": {"ParentId": "12423460", "CommentCount": "5", "Body": "<p>As long as you don't instantiate the type you're fine <em>technically</em>, same as with e.g. incomplete type.</p>\n<p>However, it's a horrible design.</p>\n<p>All that contortion in order make it possible to use more keypresses to write something misleading instead of just passing parameters.</p>\n<p>I would reconsider that design.</p>\n<p>E.g. do</p>\n<pre><code>typedef Builder1Param&lt; FooInterface, Foo, std::vector, Bar &gt; FooBuilder;\n</code></pre>\n<p>For the template definition part, <code>std::vector</code> is here a template template parameter.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "12423587", "Score": "1", "CreationDate": "2012-09-14T11:26:31.627", "LastActivityDate": "2012-09-14T11:26:31.627"}});