post_cb({"bq_ids": {"n4140": {"so_28264279_28264640_1": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_28264279_28462742_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 5908}, "so_28264279_28462742_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 7040}, "so_28264279_28264640_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 7040}}, "n3337": {"so_28264279_28264640_1": {"length": 10, "quality": 1.0, "section_id": 5946}, "so_28264279_28462742_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 5680}, "so_28264279_28462742_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 6785}, "so_28264279_28264640_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6785}}, "n4659": {"so_28264279_28462742_0": {"length": 24, "quality": 0.5714285714285714, "section_id": 7390}, "so_28264279_28462742_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 8537}, "so_28264279_28264640_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 8537}}}, "28264640": {"Id": "28264640", "PostTypeId": "2", "Body": "<p>C++11 reads</p>\n<blockquote>\n<p id=\"so_28264279_28264640_0\">A variable whose name appears as a potentially-evaluated expression is\n  <em>odr-used</em> <strong>unless it is an object that satisfies the requirements for\n  appearing in a constant expression (5.19)</strong> and the lvalue-to-rvalue\n  conversion (4.1) is immediately applied.</p>\n</blockquote>\n<p>Clearly the l-t-r conversion is immediately applied, and a <code>constexpr</code> variable of floating point type can appear in constant expressions as per [expr.const]/(2.7.1):</p>\n<blockquote>\n<p id=\"so_28264279_28264640_1\">A <em>conditional-expression</em> is a <em>core constant expression</em> unless it\n  involves one of the following as a potentially evaluated subexpression\n  [..]</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to\n  \n  <ul>\n<li><strong>a glvalue of literal type that refers to a non-volatile object defined with <code>constexpr</code></strong>, or that refers to a sub-object of such an\n  object, or</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Seems to be a Clang bug.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-12-04T15:52:42.517", "Score": "6", "CreationDate": "2015-02-01T15:57:46.203", "ParentId": "28264279", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2015-12-04T15:52:42.517"}, "28462742": {"Id": "28462742", "PostTypeId": "2", "Body": "<p>Interestingly, if we use <code>Blob::a</code> instead, <code>clang</code> does not complain:</p>\n<pre><code>auto c = Blob::a;\n</code></pre>\n<p>This should not matter for determining if the it is odr-used or not. So this looks like a <code>clang</code> bug which I can reproduce on <a href=\"http://melpon.org/wandbox/permlink/HZVocw6OXd5GmK0K\" rel=\"nofollow\">clang 3.7</a> using no optimization only. We can tell this is an odr issue since adding a out of class definition fixes the issue (<em><a href=\"http://melpon.org/wandbox/permlink/vm8eSE493RsNQUXm\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>constexpr float Blob::a ;\n</code></pre>\n<p>So when do you need to define a static constexpr class member? This is covered in section <code>9.4.2</code> <em>[class.static.data]</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_28264279_28462742_0\">A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014end note ] <strong>The member shall still be defined\n  in a namespace scope if it is odr-used (3.2)</strong> in the program and the namespace scope definition shall not\n  contain an initializer.</p>\n</blockquote>\n<p>It requires a definition if it is odr-used. Is it odr-used? No, it is not. The original C++11 wording in section <code>3.2</code> <em>[basic.def.odr]</em> says:</p>\n<blockquote>\n<p id=\"so_28264279_28462742_1\">An expression is potentially evaluated unless it is an unevaluated operand (Clause 5) or a subexpression\n  thereof. A variable whose name appears as a potentially-evaluated expression <strong>is odr-used unless</strong> it is an\n  object that <strong>satisfies the requirements for appearing in a constant expression</strong> (5.19) and <strong>the lvalue-to-rvalue\n  conversion (4.1) is immediately applied</strong>.</p>\n</blockquote>\n<p><code>a</code> satisfies both conditions, it is a constant expression and the lvalue-to-rvalue conversion is immediately applied. <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#712\" rel=\"nofollow\">Defect Report 712</a> has changed the wording which applies to C++11 since it is a defect report and <code>3.2</code> now says:</p>\n<blockquote>\n<p id=\"so_28264279_28462742_2\">A variable x whose name appears as a potentially-evaluated expression ex <strong>is odr-used unless</strong> applying the\n  lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.19) that does not invoke any non-trivial\n  functions and, if x is an object, ex is an element of the set of potential results of an expression e, where\n  either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression</p>\n</blockquote>\n<p>The potential result that matches would be:</p>\n<blockquote>\n<p id=\"so_28264279_28462742_3\">If e is an id-expression (5.1.1), the set contains only e.</p>\n</blockquote>\n<p>it is a constant expression and the lvalue-to-rvalue conversion is applied so it is not odr-used.</p>\n", "LastActivityDate": "2015-02-11T19:22:42.857", "CommentCount": "0", "CreationDate": "2015-02-11T19:22:42.857", "ParentId": "28264279", "Score": "3", "OwnerUserId": "1708801"}, "28264279": {"ViewCount": "3926", "Body": "<p>This code works:</p>\n<pre><code>struct Blob {\n    static constexpr int a = 10;\n};\n\nint main() {\n    Blob b;\n    auto c = b.a;\n}\n</code></pre>\n<p>But if I change <code>int</code> to <code>float</code> I get an error:</p>\n<pre><code>struct Blob {\n    static constexpr float a = 10.0f;\n};\n</code></pre>\n<blockquote>\n<p id=\"so_28264279_28264279_0\">/tmp/main-272d80.o: In function <code>main': main.cpp:(.text+0xe):\n  undefined reference to</code>Blob::a'</p>\n</blockquote>\n<p>Why can't I use a <code>constexpr float</code> in that way?</p>\n<p>Compiler:\nUbuntu clang version 3.5.0-4ubuntu2 (tags/RELEASE_350/final)</p>\n<p>Tested on gcc version 4.9.1 (Ubuntu 4.9.1-16ubuntu6) and there were no error.</p>\n<p><strong>EDIT:</strong></p>\n<p>It will compile if I use -O1, -O2, -O3 or -Os but fails with -O0</p>\n", "AcceptedAnswerId": "28264640", "Title": "undefined reference when accessing static constexpr float member", "CreationDate": "2015-02-01T15:20:42.197", "Id": "28264279", "CommentCount": "14", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-02-11T21:31:23.387", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-04T15:52:42.517", "Score": "8", "OwnerUserId": "1583225", "Tags": "<c++><clang><constexpr><one-definition-rule>", "AnswerCount": "2"}});