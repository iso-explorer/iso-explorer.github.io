post_cb({"37013517": {"CommentCount": "0", "ViewCount": "299", "PostTypeId": "1", "ClosedDate": "2016-05-03T20:51:48.853", "LastEditorUserId": "-1", "CreationDate": "2016-05-03T20:13:14.393", "LastActivityDate": "2016-05-03T20:42:16.133", "LastEditDate": "2017-05-23T10:28:08.827", "FavoriteCount": "1", "Title": "static_cast Conversion constructor vs Conversion operator", "Id": "37013517", "Score": "9", "Body": "<p>After reading <a href=\"https://stackoverflow.com/questions/1384007/conversion-constructor-vs-conversion-operator-precedence\">this</a> I tried making such conversion with <code>static_cast</code>:</p>\n<pre><code>class A;\n\nclass B { \n      public: \n         B(){} \n\n         B(const A&amp;) //conversion constructor\n         { \n              cout &lt;&lt; \"called B's conversion constructor\" &lt;&lt; endl; \n         } \n};\n\nclass A { \n      public: \n         operator B() const //conversion operator\n         { \n              cout &lt;&lt; \"called A's conversion operator\" &lt;&lt; endl; \n              return B(); \n         } \n};\n\nint main()\n{\n    A a;\n\n    //Original code, This is ambiguous, \n    //because both operator and constructor have same cv qualification (use -pedantic flag)\n    B b = a;\n\n    //Why isn't this ambiguous, Why is conversion constructor called, \n    //if both constructor and  operator have same c-v qualification\n    B c = static_cast&lt;B&gt;(a); \n    return 0;\n}\n</code></pre>\n<p>I expected it to not compile, because both constructor and operator have same <em>c-v qualification</em>. However it compiled, successfully and <code>static_cast</code> calls constructor instead of operator. Why? </p>\n<p>(compiled using gcc 4.8.1 with <code>pedantic</code> and <code>Wall</code> flags)</p>\n", "Tags": "<c++><gcc><casting><static-cast>", "OwnerUserId": "4932834", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37013517_37013647_1": {"section_id": 6030, "quality": 0.918918918918919, "length": 34}, "so_37013517_37013647_2": {"section_id": 6031, "quality": 1.0, "length": 13}}, "n3337": {"so_37013517_37013647_1": {"section_id": 5798, "quality": 0.9459459459459459, "length": 35}, "so_37013517_37013647_2": {"section_id": 5799, "quality": 1.0, "length": 13}}, "n4659": {"so_37013517_37013647_2": {"section_id": 7530, "quality": 1.0, "length": 13}}}, "37013647": {"ParentId": "37013517", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The C++11 Standard says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_37013517_37013647_0\"><strong>5.2.9 Static cast</strong></p>\n<p id=\"so_37013517_37013647_1\">4 Otherwise, an expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> <strong>if the declaration <code>T t(e);</code> is well-formed</strong>, for some invented temporary variable <code>t</code> (8.5). The effect of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion. The expression <code>e</code> is used as a glvalue if and only if the initialization uses it as a glvalue.</p>\n<p id=\"so_37013517_37013647_2\">5 Otherwise, the <code>static_cast</code> shall perform one of the conversions listed below. No other conversion shall be performed explicitly using a <code>static_cast</code>.</p>\n</blockquote>\n<p>That explains why the <code>static_cast</code> in</p>\n<pre><code>B c = static_cast&lt;B&gt;(a); \n</code></pre>\n<p>ends up calling the constructor of <code>B</code>.</p>\n<p>The conversion operator is used only if the <code>T t(e)</code> is not well-formed.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2016-05-03T20:42:16.133", "Id": "37013647", "Score": "7", "CreationDate": "2016-05-03T20:21:09.877", "LastActivityDate": "2016-05-03T20:42:16.133"}});