post_cb({"13820031": {"ParentId": "13819820", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>If <code>char</code> is signed, then performing arithmetic on a byte value with the high bit set will result in sign extension when promoting to <code>int</code>; so, for example:</p>\n<pre><code>char c = '\\xf0';\nint res = (c &lt;&lt; 24) | (c &lt;&lt; 16) | (c &lt;&lt; 8) | c;\n</code></pre>\n<p>will give <code>0xfffffff0</code> instead of <code>0xf0f0f0f0</code>.  This can be avoided by masking with <code>0xff</code>.</p>\n<p><code>char</code> may still be preferable if you're interfacing with libraries that use it instead of <code>unsigned char</code>.</p>\n<p>Note that a cast from <code>char *</code> to/from <code>unsigned char *</code> is always safe (3.9p2).  A philosophical reason to favour <code>unsigned char</code> is that 3.9p4 in the standard favours it, at least for representing byte arrays that could hold memory representations of objects:</p>\n<blockquote>\n<p id=\"so_13819820_13820031_0\">The <em>object representation</em> of an object of type <code>T</code> is the sequence of <code>N</code> <code>unsigned char</code> objects taken up by the object of type <code>T</code>, where <code>N</code> equals <code>sizeof(T)</code>.</p>\n</blockquote>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2012-12-11T12:10:03.557", "Id": "13820031", "Score": "10", "CreationDate": "2012-12-11T12:04:36.807", "LastActivityDate": "2012-12-11T12:10:03.557"}, "13819820": {"CommentCount": "1", "AcceptedAnswerId": "13820031", "PostTypeId": "1", "LastEditorUserId": "3425536", "CreationDate": "2012-12-11T11:52:35.783", "LastActivityDate": "2015-12-20T19:39:57.030", "LastEditDate": "2015-12-20T18:27:03.427", "ViewCount": "9295", "FavoriteCount": "5", "Title": "Char vs unsigned char for byte arrays", "Id": "13819820", "Score": "9", "Body": "<p>When storing \"byte arrays\" (blobs...) is it better to use <code>char</code> or <code>unsigned char</code> for the items (<code>unsigned char</code> a.k.a. <code>uint8_t</code>)? (Standard says that <code>sizeof</code> of both is precisely 1 Byte.)</p>\n<p>Does it matter at all? Or one is more convenient or prevalent than the other? Maybe, what libraries like Boost do use?</p>\n", "Tags": "<c++><gcc><c++11>", "OwnerUserId": "684534", "AnswerCount": "4"}, "34385030": {"ParentId": "13819820", "CommentCount": "0", "Body": "<p>One of the other problems with potentially using a signed value for blobs is that the value will depend on the sign representation, which is not part of the standard.  So, it's easier to invoke undefined behavior.</p>\n<p>For example...</p>\n<pre><code>signed char x = 0x80;\nint y = 0xffff00ff;\n\ny |= (x &lt;&lt; 8); // UB\n</code></pre>\n<p>The actual arithmetic value would also strictly depend two's complement, which may give some people surprises.  Using unsigned explicitly avoids these problems.</p>\n", "OwnerUserId": "3288910", "PostTypeId": "2", "Id": "34385030", "Score": "0", "CreationDate": "2015-12-20T19:39:57.030", "LastActivityDate": "2015-12-20T19:39:57.030"}, "13819885": {"ParentId": "13819820", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Theoretically, the size of a byte in C++ is dependant on the compiler-settings and target platform, but it is guaranteed to be at least 8 bits, which explains why <code>sizeof(uint8_t)</code> is required to be 1.</p>\n<p>Here's more precisely what the standard has to say about it </p>\n<p><em>\u00a71.71</em></p>\n<blockquote>\n<p id=\"so_13819820_13819885_0\">The fundamental storage unit in the C++ memory model is the byte. A\n  byte is at least large enough to contain any member of the basic\n  execution character set (2.3) and the eight-bit code units of the\n  Unicode UTF-8 encoding form and is composed of a contiguous sequence\n  of bits, the number of which is implementation-defined. The least\n  significant bit is called the low-order bit; the most significant bit\n  is called the high-order bit. The memory available to a C++ program\n  consists of one or more sequences of contiguous bytes. Every byte has\n  a unique address.</p>\n</blockquote>\n<p>So, if you are working on some special hardware where bytes are not 8 bits, it may make a practical difference. Otherwise, I'd say that it's a matter of taste and what information you want to communicate via the choice of type.</p>\n", "OwnerUserId": "980195", "LastEditorUserId": "980195", "LastEditDate": "2012-12-11T12:04:07.747", "Id": "13819885", "Score": "1", "CreationDate": "2012-12-11T11:56:12.287", "LastActivityDate": "2012-12-11T12:04:07.747"}, "bq_ids": {"n4140": {"so_13819820_13819885_0": {"section_id": 5785, "quality": 0.875, "length": 49}, "so_13819820_13820031_0": {"section_id": 7202, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_13819820_13819885_0": {"section_id": 5558, "quality": 0.875, "length": 49}, "so_13819820_13820031_0": {"section_id": 6946, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_13819820_13819885_0": {"section_id": 7242, "quality": 0.875, "length": 49}, "so_13819820_13820031_0": {"section_id": 8711, "quality": 0.8666666666666667, "length": 13}}}, "13820016": {"ParentId": "13819820", "CommentCount": "0", "Body": "<p>makes no practcial difference although maybe from a readability point of view it is more clear if the type is <code>unsigned char</code> implying values 0..255.</p>\n", "OwnerUserId": "45685", "PostTypeId": "2", "Id": "13820016", "Score": "0", "CreationDate": "2012-12-11T12:03:58.917", "LastActivityDate": "2012-12-11T12:03:58.917"}});