post_cb({"25344326": {"ParentId": "23360196", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>So after looking a bit further into the standard at the position where Angew pointed me before, I noticed footnote <code>34</code> in <code>[basic.start.init]\u00a74</code> of the standard that states:</p>\n<p><code>A non-local variable with static storage duration having initialization with side-effects must be initialized even if it is not odr-used (3.2, 3.7.1).</code> </p>\n<p>And that actually addresses the Problem which is mentioned here. The self registering class is not odr-used and modifies the state of the factory object, thus having an initialization with side-effects.</p>\n<p>So per this footnote it is actually safe to so a self registration like the one mentioned by me and Skizz.</p>\n<p>Edit: As Matt McNabb mentioned, I shouldn't have relied on the footnote. So here is the Part of the Specification that the footnote refers to: [Basic.stc.static] \u00a72</p>\n<p><code>If a variable with static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in 12.8.</code></p>\n", "OwnerUserId": "3573170", "LastEditorUserId": "3573170", "LastEditDate": "2014-08-21T14:18:05.693", "Id": "25344326", "Score": "2", "CreationDate": "2014-08-16T21:48:23.170", "LastActivityDate": "2014-08-21T14:18:05.693"}, "23360649": {"ParentId": "23360196", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>No, it is in general not guaranteed that the vairable <code>impl1</code> will ever be initialised. All the standard says is that a namespace-scope variable is guaranteed to be initialised before the first function defined in the same translation unit (the same <code>.cpp</code> file) is called, or a variable from that translation unit is first used.</p>\n<p>The letter of the law is C++11 <code>[basic.start.init]\u00a74</code>:</p>\n<blockquote>\n<p id=\"so_23360196_23360649_0\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of <code>main</code>. If the initialization is deferred to some point in time after the first statement of <code>main</code>, it shall occur before the first odr-use (3.2) of any function or variable defined in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>So if your <code>impl1.cpp</code> contains the registration variables only, they are not guaranteed to ever be initialised. However, if it contains any functions which will get exectued when your program runs (or a variable referenced from outside), you're guaranteed to have them initialised before any such function is run or variable is referenced.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2014-04-29T09:35:48.690", "Id": "23360649", "Score": "2", "CreationDate": "2014-04-29T09:25:13.050", "LastActivityDate": "2014-04-29T09:35:48.690"}, "34439236": {"ParentId": "23360196", "CommentCount": "0", "Body": "<p><a href=\"http://accu.org/index.php/journals/597#d0e137\" rel=\"nofollow\">Here</a>'s an implementation of this factory pattern that tackles this specific issue. </p>\n<p>It makes sure the factory singleton implementation is the one that calls the registrar methods on construction. Which means that, if the factory is used the registration will happen.</p>\n", "OwnerUserId": "2628257", "PostTypeId": "2", "Id": "34439236", "Score": "1", "CreationDate": "2015-12-23T15:48:42.760", "LastActivityDate": "2015-12-23T15:48:42.760"}, "23362665": {"ParentId": "23360196", "CommentCount": "6", "Body": "<p>I see two problems with the code. Firstly, you're using dynamic allocation and secondly, you're using function pointers. Here is my solution:-</p>\n<pre><code>    #include &lt;iostream&gt;\n    #include &lt;string&gt;\n    #include &lt;map&gt;\n\n    class FactoryBase\n    {\n    protected:\n        FactoryBase (const std::string &amp;name)\n        {\n            m_factory_items [name] = this;\n        }\n\n    public:\n        virtual ~FactoryBase ()\n        {\n        }\n\n        template &lt;class T&gt; static T *Create ()\n        {\n            return static_cast &lt;T *&gt; (m_factory_items [T::Name]-&gt;Create ());\n        }\n\n    private:\n        virtual void *Create () = 0;\n\n    private:\n        static std::map &lt;const std::string, FactoryBase *&gt;\n            m_factory_items;\n    };\n\n    std::map &lt;const std::string, FactoryBase *&gt;\n        FactoryBase::m_factory_items;\n\n    template &lt;class T&gt;\n        class FactoryItem : public FactoryBase\n    {\n    public:\n        FactoryItem () :\n            FactoryBase (T::Name)\n        {\n            std::cout &lt;&lt; \"Registering class: \" &lt;&lt; T::Name &lt;&lt; std::endl;\n        }\n\n        virtual ~FactoryItem ()\n        {\n        }\n\n    private:\n        virtual void *Create ()\n        {\n            return new T;\n        }\n    };\n\n    class A\n    {\n    public:\n        A ()\n        {\n            std::cout &lt;&lt; \"Creating A\" &lt;&lt; std::endl;\n        }\n\n        virtual ~A ()\n        {\n            std::cout &lt;&lt; \"Deleting A\" &lt;&lt; std::endl;\n        }\n\n        static const std::string\n            Name;\n\n    private:\n        static FactoryItem &lt;A&gt;\n            m_registration;\n    };\n\n    const std::string\n        A::Name (\"A\");\n\n    FactoryItem &lt;A&gt;\n        A::m_registration;\n\n    class B\n    {\n    public:\n        B ()\n        {\n            std::cout &lt;&lt; \"Creating B\" &lt;&lt; std::endl;\n        }\n\n        virtual ~B ()\n        {\n            std::cout &lt;&lt; \"Deleting B\" &lt;&lt; std::endl;\n        }\n\n        static const std::string\n            Name;\n\n    private:\n        static FactoryItem &lt;B&gt;\n            m_registration;\n    };\n\n    const std::string\n        B::Name (\"B\");\n\n    FactoryItem &lt;B&gt;\n        B::m_registration;\n\n    int main (int argc, char *argv [])\n    {\n        A\n            *item_a = FactoryBase::Create &lt;A&gt; ();\n\n        B\n            *item_b = FactoryBase::Create &lt;B&gt; ();\n\n        delete item_a;\n        delete item_b;\n    }\n</code></pre>\n<p>There's no error checking in the Create function, but I'll leave that as an exercise for the reader.</p>\n", "OwnerUserId": "1898", "PostTypeId": "2", "Id": "23362665", "Score": "3", "CreationDate": "2014-04-29T10:55:51.317", "LastActivityDate": "2014-04-29T10:55:51.317"}, "23360600": {"ParentId": "23360196", "CommentCount": "6", "Body": "<p>From a standards perspective you can be sure if that translation unit is included in the build. However, as of old there was a problem with Visual C++ static libraries. To be safe I'd use explicit module initializations at the top level of control, <em>or</em> the trick employed by original iostreams implementation, where the header file causes a small internal linkage thing to be initialized, which in turn causes module initialization if not already done.</p>\n<hr>\n<p>Oh well I have a question: does <em>anyone</em> remember \"Hoare envelopes\" module initialization feature, and perhaps direct me to some material? I remember re-searching some years ago, and only hitting my own earlier questions. Frustrating.</p>\n</hr>", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "23360600", "Score": "1", "CreationDate": "2014-04-29T09:22:45.020", "LastActivityDate": "2014-04-29T09:22:45.020"}, "23360196": {"CommentCount": "7", "AcceptedAnswerId": "25344326", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-04-29T09:04:46.927", "LastActivityDate": "2015-12-23T15:48:42.760", "LastEditDate": "2017-05-23T12:01:49.107", "ViewCount": "2805", "FavoriteCount": "2", "Title": "C++ how safe are self registering classes?", "Id": "23360196", "Score": "5", "Body": "<p>Coming from <a href=\"https://stackoverflow.com/questions/77817/c-runtime-knowledge-of-classes\">this thread</a> I implemented a similar system in c++ to the chosen solution there.</p>\n<p>My problem now is that it is stated there by the user Daniel James that this solution might not work with every compiler (I'm using gcc currently) and is not defined in the c++ standard.</p>\n<p>Suppose I have an abstract base-class for the interface and a factory-class as a singleton that stores pointers to a function that constructs the specific classes derived from that interface.</p>\n<p>then I have a helper class that looks roughly like this:</p>\n<p><i>base.hpp</i></p>\n<pre><code>...\nclass implRegistrator {\n    public:\n        implRegistrator(constructPointer) {\n            factory::registerImpl(constructPointer);\n        };\n}\n</code></pre>\n<p>And an implementation that (through a macro) creates an object of this class to register itself:</p>\n<p><i>impl1.cpp</i></p>\n<pre><code>...\nimplRegistrator* impl1 = new implRegistrator(getConstructPointer());\n</code></pre>\n<p>How compatible to the C++ standard is this solution? Is it safe to assume that the class instantiation ind impl1.cpp will even happen, since nothing from the main program will actually explicitly call it at compile-time?</p>\n<p>Thanks in advance for any answers.</p>\n", "Tags": "<c++><class><gcc><standards-compliance>", "OwnerUserId": "3573170", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_23360196_23360649_0": {"section_id": 7153, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_23360196_23360649_0": {"section_id": 6897, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_23360196_23360649_0": {"section_id": 8657, "quality": 0.6571428571428571, "length": 23}}}});