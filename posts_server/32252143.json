post_cb({"32252143": {"ViewCount": "1575", "Body": "<p>So, this is what I'm talking about: std is complex.</p>\n<p>In VS2013 this simple program will cause a deadlock.</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;windows.h&gt;\n\nvoid foo()\n{\n}\n\nvoid initialize()\n{\n    std::thread t(foo);\n}\n\nBOOL APIENTRY DllMain(HMODULE, DWORD reason, LPVOID)\n{\n    switch (reason)\n    {\n    case DLL_PROCESS_ATTACH:\n        initialize();\n        break;\n    case DLL_THREAD_ATTACH:\n        break;\n    case DLL_THREAD_DETACH:\n        break;\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n</code></pre>\n<p>Create a thread in DLLMain is totally wrong ? It's not true. From\nthe document \"Best Practices for Creating DLLs\" of Microsoft:\n\"<em>Creating a thread can work if you do not synchronize with other\nthreads</em>\". So CreateThread works, _beginthreadex works, and\nboost::thread works, but std::thread will not work. This is the\ncall stack:</p>\n<pre><code>ntdll.dll!_NtWaitForSingleObject@12()\nKernelBase.dll!_WaitForSingleObjectEx@12()\nmsvcr120d.dll!Concurrency::details::ExternalContextBase::Block() Line 151\nmsvcr120d.dll!Concurrency::Context::Block() Line 63\nmsvcr120d.dll!Concurrency::details::_Condition_variable::wait(Concurrency::critical_section &amp; _Lck) Line 595\nmsvcp120d.dll!do_wait(_Cnd_internal_imp_t * * cond, _Mtx_internal_imp_t * * mtx, const xtime * target) Line 54\nmsvcp120d.dll!_Cnd_wait(_Cnd_internal_imp_t * * cond, _Mtx_internal_imp_t * * mtx) Line 81\nmsvcp120d.dll!std::_Cnd_waitX(_Cnd_internal_imp_t * * _Cnd, _Mtx_internal_imp_t * * _Mtx) Line 93\nmsvcp120d.dll!std::_Pad::_Launch(_Thrd_imp_t * _Thr) Line 73\nmod.dll!std::_Launch&lt;std::_Bind&lt;1,void,void (__cdecl*const)(void)&gt; &gt;(_Thrd_imp_t * _Thr, std::_Bind&lt;1,void,void (__cdecl*const)(void)&gt; &amp;&amp; _Tg) Line 206\nmod.dll!std::thread::thread&lt;void (__cdecl&amp;)(void)&gt;(void (void) * _Fx) Line 49\nmod.dll!initialize() Line 17\nmod.dll!DllMain(HINSTANCE__ * __formal, unsigned long reason, void * __formal) Line 33\n</code></pre>\n<p>Okay, std::thread will \"synchronize with other threads\".</p>\n<p>But why ?</p>\n<p>I hope this never happens again in VS2015, I didn't test it yet.</p>\n", "AcceptedAnswerId": "32272900", "Title": "std::thread cause deadlock in DLLMain", "CreationDate": "2015-08-27T14:28:46.837", "Id": "32252143", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-05-15T11:19:01.053", "Score": "4", "OwnerUserId": "996540", "Tags": "<c++><visual-c++><msvc12>", "AnswerCount": "4"}, "37237606": {"Id": "37237606", "PostTypeId": "2", "Body": "<p>Use <code>detach()</code> member function to fix the crash. Example:</p>\n<pre><code>void Hook_Init();\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n    switch (fdwReason)\n    {\n    case DLL_PROCESS_ATTACH:\n        {\n            std::thread hookthread(Hook_Init);\n            hookthread.detach();\n            break;\n        }\n    }\n    return TRUE;\n}\n\nvoid Hook_Init()\n{\n    // Code\n}\n</code></pre>\n", "LastActivityDate": "2016-05-15T11:19:01.053", "CommentCount": "0", "CreationDate": "2016-05-15T11:19:01.053", "ParentId": "32252143", "Score": "0", "OwnerUserId": "6336853"}, "32252456": {"Id": "32252456", "PostTypeId": "2", "Body": "<p>You're mixing the platform level with <code>std</code> level. Calling the raw winapi function <code>CreateThread</code> can work in <code>DllMain</code>. But there's no guarantee about how <code>std::thread</code> will interact with the platform. <a href=\"http://blogs.msdn.com/b/oldnewthing/archive/2004/01/27/63401.aspx\" rel=\"nofollow\">It's well known that it's extremely dangerous to be doing things like this in <code>DllMain</code></a>, so I don't recommend it at all. If you insist on trying, then you're going to need to tip-toe around and call the winapi directly, avoiding consequences of the <code>std</code> implementation.</p>\n<p>As for \"why\", it shouldn't really matter, but after a very quick look in the debugger, it seems that the MSVC implementation has a handshake with the new thread for exchanging arguments and resources. So it requires synchronization to know when the resources have been handed off. Seems reasonable.</p>\n", "LastEditorUserId": "402169", "LastActivityDate": "2015-08-27T14:51:26.160", "Score": "0", "CreationDate": "2015-08-27T14:41:50.350", "ParentId": "32252143", "CommentCount": "8", "OwnerUserId": "402169", "LastEditDate": "2015-08-27T14:51:26.160"}, "bq_ids": {"n4140": {"so_32252143_32272900_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2711}}, "n3337": {"so_32252143_32272900_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 2672}}, "n4659": {"so_32252143_32272900_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 3451}}}, "32272900": {"Id": "32272900", "PostTypeId": "2", "Body": "<p>The specification for <code>std::thread</code> contains the following requirement (N4527 \u00a730.3.1.2[thread.thread.constr]/6):</p>\n<blockquote>\n<p id=\"so_32252143_32272900_0\"><em>Synchronization</em>: The completion of the invocation of the constructor synchronizes with the beginning of the invocation of the copy of <code>f</code>.</p>\n</blockquote>\n<p>(where <code>f</code> is the callable entity which is to be executed on the newly created thread.)</p>\n<p>The constructor for the <code>std::thread</code> cannot return until the new thread starts executing the thread procedure.  When a new thread is created, before the thread procedure is invoked, the entry point of each loaded DLL is invoked for <code>DLL_THREAD_ATTACH</code>.  To do this, the new thread must acquire the loader lock.  Unfortunately, your existing thread already holds the loader lock.</p>\n<p>Thus, you deadlock:  the existing thread cannot release the loader lock until the new thread starts executing the thread procedure but the new thread cannot execute the thread procedure until it can acquire the loader lock, which is held by the existing thread.</p>\n<p>Note that <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dn633971.aspx#general_best_practices\" rel=\"nofollow\">the documentation</a> expressly recommends against creation of threads from the DLL entry point:</p>\n<blockquote>\n<p id=\"so_32252143_32272900_1\">You should never perform the following tasks from within <code>DllMain</code>:  [...]  Call <code>CreateThread</code>. Creating a thread can work if you do not synchronize with other threads, but it is risky.</p>\n</blockquote>\n<p>(That page has a long list of things that should not be done from a DLL entry point; this is just one of them.)</p>\n", "LastActivityDate": "2015-08-28T14:02:34.770", "CommentCount": "4", "CreationDate": "2015-08-28T14:02:34.770", "ParentId": "32252143", "Score": "3", "OwnerUserId": "151292"}, "32253725": {"Id": "32253725", "PostTypeId": "2", "Body": "<p><code>std::thread</code> creates a C++ thread. It means you can rely on the C++ library in that thread. This means certain shared data structures must be set up, which force synchronization (you might create multiple threads in parallel). The stack trace clearly shows this: <code>std::_Cnd_waitX</code> is clearly a part of the Standard Library, and is clearly synchronizing. Synchronizing is blacklisted in the document you mentioned, so this crash isn't a big surprise.</p>\n<p>Further up the stack we see <code>Concurrency::</code>. This is specific to Visual Studio versions <a href=\"http://blogs.msdn.com/b/vcblog/archive/2015/07/14/stl-fixes-in-vs-2015-part-2.aspx\" rel=\"nofollow\">up to VS2015</a>. This means you may luck out in VS2015. Doing thread synchronization in <code>DllMain</code> is not a <em>guaranteed</em> crash. Just quite possible.</p>\n", "LastActivityDate": "2015-08-27T15:35:26.420", "CommentCount": "1", "CreationDate": "2015-08-27T15:35:26.420", "ParentId": "32252143", "Score": "0", "OwnerUserId": "15416"}});