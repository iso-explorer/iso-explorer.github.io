post_cb({"17154766": {"ParentId": "17132753", "CommentCount": "2", "Body": "<p>A partial specialization must redeclare the same name as the primary template for which it provides an alternative definition.</p>\n<p>When you write <code>struct Inner</code> within the scope of <code>Derived</code>, you are declaring <code>Derived::Inner</code>. <code>Base::Inner</code> is a distinct name from <code>Derived::Inner</code> and therefore declares a different class. It is not possible to specialize <code>Base::Inner</code> with a declaration that declares <code>Derived::Inner</code>. </p>\n<p>When you write <code>Derived::Inner</code> at namespace scope, name lookup resolves that name to <code>Base::Inner</code> - the specializations are all of the same class: <code>Base::Inner</code>, even if you refer to them as <code>Derived::Inner</code>.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_17132753_17154766_0\">[temp.class.spec]</p>\n<p id=\"so_17132753_17154766_1\">A partial specialization of a class template provides <strong>an alternative definition</strong> of the template that is used instead of the primary definition when the arguments in a specialization match those given in the partial specialization.</p>\n</blockquote>\n", "OwnerUserId": "1690864", "PostTypeId": "2", "Id": "17154766", "Score": "1", "CreationDate": "2013-06-17T18:56:37.133", "LastActivityDate": "2013-06-17T18:56:37.133"}, "17132811": {"ParentId": "17132753", "CommentCount": "2", "Body": "<p>Specializing templates isn't a part of polymorhpism.</p>\n<p>You're in fact declaring a type. So any compilation unit that can see the derived header file with the implementation for the template specialization will use that specialization for the nested template class.</p>\n<p>The compiler tries to find the best match class, and will always choose the specialized type over the default. So even if you try to access the scope of the base type it's still the same class.</p>\n<p>Same thing would happen if you specialize a template class in any other part of your code. The compiler will choose the best matching specialization, if there is non, it will take the \"default\".</p>\n", "OwnerUserId": "536086", "PostTypeId": "2", "Id": "17132811", "Score": "1", "CreationDate": "2013-06-16T11:28:25.770", "LastActivityDate": "2013-06-16T11:28:25.770"}, "bq_ids": {"n4140": {"so_17132753_17154766_1": {"section_id": 135, "quality": 1.0, "length": 19}}, "n3337": {"so_17132753_17154766_1": {"section_id": 129, "quality": 1.0, "length": 19}}, "n4659": {"so_17132753_17154766_1": {"section_id": 139, "quality": 1.0, "length": 19}}}, "17132753": {"CommentCount": "0", "ViewCount": "735", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-06-16T11:21:01.787", "LastActivityDate": "2013-06-17T18:56:37.133", "Title": "Understanding partial specialization of inherited nested class templates", "AcceptedAnswerId": "17154766", "LastEditDate": "2017-05-23T12:22:31.300", "Id": "17132753", "Score": "1", "Body": "<p>This question is connected to <a href=\"https://stackoverflow.com/questions/1413158/partial-specialization-of-a-class-template-in-derived-class-affects-base-class\">a previous Q&amp;A</a> in which a bug report for gcc was mentioned (supposedly fixed in gcc 4.5.0) and concerns some peculiarities for partial specialization of nested class template. </p>\n<p>My setup is that I have a class <code>Base</code> with a nested class template <code>Inner</code> that is partially specialized for <code>char</code> (using the dummy parameter trick, because explicit speciliaztion is not allowed in-class).</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;ios&gt;\n\nstruct Base\n{\n    // dummy template parameter...\n    template&lt;class U, class _ = void&gt; struct Inner: std::true_type {};\n\n    // ... to allow in-class partial specialization\n    template&lt;class _&gt; struct Inner&lt;char, _&gt;: std::false_type {};\n};\n</code></pre>\n<p>I now define a <code>Derived</code> class for which I further want to specialize <code>Inner</code>, which for some odd reason cannot be done in-class (even though it is still a partial specialization). </p>\n<pre><code>struct Derived\n:\n    Base\n{\n    // cannot partially specialize Inner inside Derived...\n    //template&lt;class _&gt;\n    //struct Inner&lt;int, _&gt;: std::false_type {};\n};\n\n// ... but specializing Derived::Inner at namespace scope, also specializes it for Base::Inner\ntemplate&lt;class _&gt; struct Derived::Inner&lt;int, _&gt;: std::false_type {};\n</code></pre>\n<p><strong>First question</strong>: why do I have to partially specialize <code>Derived::Inner</code> at namespace scope?</p>\n<p>But the strangest part is that when I call the various partial specializations of <code>Inner</code> from both <code>Base</code> and <code>Derived</code>, the partial specialization for <code>int</code> that I only did for <code>Derived</code>, also applies to <code>Base</code>.</p>\n<pre><code>int main()\n{\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; Base::Inner&lt;float&gt;::value &lt;&lt; \"\\n\";    \n    std::cout &lt;&lt; std::boolalpha &lt;&lt; Derived::Inner&lt;float&gt;::value &lt;&lt; \"\\n\";    \n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; Base::Inner&lt;char&gt;::value &lt;&lt; \"\\n\";    \n    std::cout &lt;&lt; std::boolalpha &lt;&lt; Derived::Inner&lt;char&gt;::value &lt;&lt; \"\\n\";    \n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; Base::Inner&lt;int&gt;::value &lt;&lt; \"\\n\";      // huh???\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; Derived::Inner&lt;int&gt;::value &lt;&lt; \"\\n\";   // OK \n}\n</code></pre>\n<p><strong>Second question</strong>: why is <code>Base::Inner&lt;int&gt;::value</code> equal to <code>false</code>, even though only <code>Derived::Inner&lt;int&gt;</code> was partially specialized?</p>\n<p><a href=\"http://coliru.stacked-crooked.com/view?id=e7ae5e3f663ca68b564ea3434e2c53b1-e54ee7a04e4b807da0930236d4cc94dc\" rel=\"nofollow noreferrer\">Online example using gcc 4.8.0</a>. I am specifically looking for quotes from the Standard that explain this behavior.</p>\n", "Tags": "<c++><templates><language-lawyer><nested-class><partial-specialization>", "OwnerUserId": "819272", "AnswerCount": "2"}});