post_cb({"17551583": {"CommentCount": "0", "ViewCount": "2521", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2013-07-09T14:59:23.200", "LastActivityDate": "2015-07-25T19:57:53.603", "Title": "Why is \"unsigned int ui = {-1};\" a narrowing conversion error?", "AcceptedAnswerId": "17551626", "LastEditDate": "2015-07-25T19:57:53.603", "Id": "17551583", "Score": "4", "Body": "<p>The Standard at \u00a7 8.5.4/7 explains what a <em>narrowing conversion</em> is:</p>\n<blockquote>\n<p id=\"so_17551583_17551583_0\">A narrowing conversion is an implicit conversion</p>\n<p id=\"so_17551583_17551583_1\">\u2014 from a floating-point type to an integer type, or</p>\n<p id=\"so_17551583_17551583_2\">\u2014 from long double to double or float, or from double to float, except where the source is a constant\n  expression and the actual value after conversion is within the range of values that can be represented\n  (even if it cannot be represented exactly), or</p>\n<p id=\"so_17551583_17551583_3\">\u2014 from an integer type or unscoped enumeration type to a floating-point type, except where the source\n  is a constant expression and the actual value after conversion will fit into the target type and will\n  produce the original value when converted back to the original type, or</p>\n<p id=\"so_17551583_17551583_4\">\u2014 from an integer type or unscoped enumeration type to an integer type that cannot represent all the\n  values of the original type, except where the source is a constant expression and the actual value after\n  conversion will fit into the target type and will produce the original value when converted back to the\n  original type.</p>\n</blockquote>\n<p>It then disallows such conversions in some list-initialization contexts, giving\nexamples:</p>\n<blockquote>\n<p id=\"so_17551583_17551583_5\">[ Note: As indicated above, such conversions are not allowed at the top level in list-initializations. \u2014 end\n  note ] [ Example:</p>\n</blockquote>\n<pre><code>int x = 999;        // x is not a constant expression\nconst int y = 999;\nconst int z = 99;\nchar c1 = x;    // OK, though it might narrow (in this case, it does narrow)\nchar c2{x};     // error: might narrow\nchar c3{y};     // error: narrows (assuming char is 8 bits)\nchar c4{z};     // OK: no narrowing needed\nunsigned char uc1 = {5};    // OK: no narrowing needed\nunsigned char uc2 = {-1};   // error: narrows\nunsigned int ui1 = {-1};    // error: narrows\nsigned int si1 =\n{ (unsigned int)-1 };   // error: narrows\nint ii = {2.0};         // error: narrows\nfloat f1 { x };         // error: might narrow\nfloat f2 { 7 };         // OK: 7 can be exactly represented as a float\nint f(int);\nint a[] =\n{ 2, f(2), f(2.0) }; // OK: the double-to-int conversion is not at the top level\n</code></pre>\n<blockquote>\n<p id=\"so_17551583_17551583_6\">\u2014 end example ]</p>\n</blockquote>\n<p>All 7 of the errors illustrated by the examples are reported as such by\nclang 3.2/3.3 with <code>-std=c++11</code>, e.g.</p>\n<pre><code>error: non-constant-expression cannot be narrowed from type 'int' to 'char' in initializer list [-Wc++11-narrowing]\n</code></pre>\n<p>None of them are reported as errors by gcc 4.7.2/4.8.1, but in each case\na similar warning is given, e.g.</p>\n<pre><code>warning: narrowing conversion of \u2018x\u2019 from \u2018int\u2019 to \u2018char\u2019 inside { } [-Wnarrowing]\n</code></pre>\n<p>(so gcc seems to know what compliance requires but opts to tolerate non-compliance\nby default.)</p>\n<p>What I do not understand is how the example:</p>\n<pre><code>unsigned int ui1 = {-1};    // error: narrows\n</code></pre>\n<p>qualifies as an example. (Likewise with the symmetrical <code>si1</code> example.) Evidently\nthe only words by which it <em>might</em> qualify as example are those of the fourth\nand final item in the definition of <em>narrowing conversion</em> given above; but\nif so then why does the example not escape by the qualification \n<em>except where the source is a constant expression and the actual value after \nconversion will fit into the target type and will produce the original value when converted back to the\noriginal type</em>? Surely <code>-1</code> there is an integer constant and, if converted to <code>unsigned</code> and back, \nstill yields <code>int -1</code>?</p>\n<p>What am I missing?</p>\n", "Tags": "<c++><c++11><type-conversion><language-lawyer><narrowing>", "OwnerUserId": "1362568", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17551583_17551583_3": {"section_id": 3329, "quality": 1.0, "length": 30}, "so_17551583_17551583_4": {"section_id": 3329, "quality": 0.7777777777777778, "length": 28}, "so_17551583_17551583_2": {"section_id": 3329, "quality": 1.0, "length": 24}, "so_17551583_17551583_1": {"section_id": 3329, "quality": 1.0, "length": 4}, "so_17551583_17551583_5": {"section_id": 3329, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_17551583_17551583_3": {"section_id": 3199, "quality": 1.0, "length": 30}, "so_17551583_17551583_4": {"section_id": 3199, "quality": 1.0, "length": 36}, "so_17551583_17551583_2": {"section_id": 3199, "quality": 1.0, "length": 24}, "so_17551583_17551583_1": {"section_id": 3199, "quality": 1.0, "length": 4}, "so_17551583_17551583_5": {"section_id": 3199, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_17551583_17551583_3": {"section_id": 4095, "quality": 1.0, "length": 30}, "so_17551583_17551583_4": {"section_id": 4095, "quality": 0.7777777777777778, "length": 28}, "so_17551583_17551583_2": {"section_id": 4095, "quality": 1.0, "length": 24}, "so_17551583_17551583_1": {"section_id": 37, "quality": 1.0, "length": 4}, "so_17551583_17551583_5": {"section_id": 4095, "quality": 0.6666666666666666, "length": 8}}}, "17551626": {"ParentId": "17551583", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_17551583_17551626_0\">Surely -1 there is an integer constant and, if converted to unsigned and back, still yields int -1?</p>\n</blockquote>\n<p>This is wrong. If you convert -1 to <code>unsigned</code> you get <code>UINT_MAX</code>. This is fine because converting to unsigned types is always defined. However, <code>UINT_MAX</code> does not fit in <code>int</code> and conversions to signed types are only defined by the standard when the value fits in the target type.</p>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "17551626", "Score": "6", "CreationDate": "2013-07-09T15:01:57.933", "LastActivityDate": "2013-07-09T15:01:57.933"}});