post_cb({"41595749": {"CommentCount": "2", "ViewCount": "80", "CreationDate": "2017-01-11T16:19:23.267", "LastActivityDate": "2017-01-11T16:46:07.257", "Title": "How does the compiler know which function to pick for a polymorphic type?", "AcceptedAnswerId": "41595932", "PostTypeId": "1", "Id": "41595749", "Score": "2", "Body": "<p>For example, I've overloaded <code>operator&lt;&lt;</code> in two different ways:</p>\n<p><code>ofstream &amp; operator&lt;&lt;(ofstream &amp; fout, const Thing &amp; t);</code></p>\n<p><code>ostream &amp; operator&lt;&lt;(ostream &amp; out, const Thing &amp; t);</code></p>\n<p>I've done this because I want the output to a file to be different than the output to console. As far as I am aware, <code>ofstream</code> is derived from <code>ostream</code>, so how does the compiler know to pick the overloaded operator with <code>ofstream</code> rather than just picking the one with <code>ostream</code> when I do something like</p>\n<pre><code>ofstream fout(\"file.txt\")\nfout.open();\nThing t;\nfout &lt;&lt; t;\n</code></pre>\n<p>Because even without the overloaded operator with <code>ofstream</code>, that code will still work with the <code>ostream</code> one.</p>\n", "Tags": "<c++>", "OwnerUserId": "6605200", "AnswerCount": "3"}, "41596032": {"ParentId": "41595749", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>ofstream</code> derives from <code>ostream</code>. So, </p>\n<ul>\n<li><p><code>ofstream</code> object <strong>will be</strong> used wherever <code>ofstream</code> object is acceptable. Otherwise,</p></li>\n<li><p><code>ofstream</code> object <strong>can be</strong> used wherever <code>ostream</code> object is acceptable. </p></li>\n</ul>\n<p>C++ spec N3690  on <strong>Reference binding</strong>:</p>\n<blockquote>\n<p id=\"so_41595749_41596032_0\">When a parameter of reference type binds directly (8.5.3) to an\n  argument expression, the implicit conversion sequence is the identity\n  conversion, unless the argument expression has a type that is a\n  derived class of the parameter type, in which case the implicit\n  conversion sequence is a derived-to-base Conversion (13.3.3.1).</p>\n<pre><code>struct A {};\nstruct B : public A {} b;\nint f(A&amp;);\nint f(B&amp;);\nint i = f(b); // calls f(B&amp;), an exact match, rather than\n            // f(A&amp;), a conversion\n</code></pre>\n</blockquote>\n<p>In simpler words: </p>\n<ul>\n<li><p>When the parameter has\na class type and the argument expression has the <em>same</em> type, the implicit conversion sequence is an <em>identity</em> conversion. </p></li>\n<li><p>When the parameter has a class type and the argument expression has a <em>derived</em> class type, the <em>implicit</em> conversion sequence is a derived-to-base Conversion from the derived class to the base class.</p></li>\n</ul>\n", "OwnerUserId": "1465553", "LastEditorUserId": "1465553", "LastEditDate": "2017-01-11T16:46:07.257", "Id": "41596032", "Score": "0", "CreationDate": "2017-01-11T16:34:43.090", "LastActivityDate": "2017-01-11T16:46:07.257"}, "bq_ids": {"n4140": {"so_41595749_41596032_0": {"section_id": 625, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_41595749_41596032_0": {"section_id": 615, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_41595749_41596032_0": {"section_id": 651, "quality": 0.9285714285714286, "length": 26}}}, "41595887": {"ParentId": "41595749", "CommentCount": "0", "Body": "<p>Overload resolution always prefer an exact match when available. Since there is an exact match for <code>std::ofstream</code>, See <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences\" rel=\"nofollow noreferrer\">this</a> for more information on overload resolution. The <code>std::ostream</code> also matches but has a lower priority. It will be used if all other higher priority overloads are removed, such as if you eliminate the <code>std::ofstream</code> overload.</p>\n", "OwnerUserId": "7359094", "PostTypeId": "2", "Id": "41595887", "Score": "0", "CreationDate": "2017-01-11T16:26:07.167", "LastActivityDate": "2017-01-11T16:26:07.167"}, "41595932": {"ParentId": "41595749", "CommentCount": "0", "Body": "<p>In general, the candidate function whose parameters match the arguments most closely is the one that is called. </p>\n<p>It picks the closest match, the ofstream overload is closer, but ostream is valid if the other overload isn't present. If there is an exact match, it will go for it.</p>\n<p>Before overload resolution begins, the functions selected by name lookup and template argument deduction are combined to form the set of candidate functions (the exact criteria depend on the context in which overload resolution takes place)</p>\n<p>The argument-parameter implicit conversion sequences considered by overload resolution correspond to implicit conversions used in copy initialization (for non-reference parameters), except that when considering conversion to the implicit object parameter or to the left-hand side of assignment operator, conversions that create temporary objects are not considered.\nEach type of standard conversion sequence is assigned one of three ranks:</p>\n<ol>\n<li><p>Exact match: no conversion required, lvalue-to-rvalue conversion,\nqualification conversion, function pointer conversion, (since C++17)\nuser-defined conversion of class type to the same class</p></li>\n<li><p>Promotion: integral promotion, floating-point promotion</p></li>\n<li><p>Conversion: integral conversion, floating-point conversion,\nfloating-integral conversion, pointer conversion, pointer-to-member\nconversion, boolean conversion, user-defined conversion of a derived\nclass to its base</p></li>\n</ol>\n<p>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to three conversions)</p>\n", "OwnerUserId": "3799743", "PostTypeId": "2", "Id": "41595932", "Score": "3", "CreationDate": "2017-01-11T16:28:49.227", "LastActivityDate": "2017-01-11T16:28:49.227"}});