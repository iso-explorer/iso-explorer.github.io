post_cb({"bq_ids": {"n4140": {"so_24533091_24533452_4": {"length": 36, "quality": 0.9, "section_id": 7103}, "so_24533091_24533452_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 224}, "so_24533091_24533452_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 224}, "so_24533091_24533452_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 224}, "so_24533091_24533452_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 7087}}, "n3337": {"so_24533091_24533452_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 6831}, "so_24533091_24533452_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 217}, "so_24533091_24533452_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 217}, "so_24533091_24533452_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 217}, "so_24533091_24533452_4": {"length": 34, "quality": 0.85, "section_id": 6847}}, "n4659": {"so_24533091_24533452_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 8588}, "so_24533091_24533452_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 232}, "so_24533091_24533452_2": {"length": 15, "quality": 0.8333333333333334, "section_id": 232}, "so_24533091_24533452_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 232}, "so_24533091_24533452_4": {"length": 36, "quality": 0.9, "section_id": 8604}}}, "24533091": {"ViewCount": "346", "Body": "<p>A quote from the Standard is appreciated.</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace X {\n    class A {};\n}\n\ntemplate &lt;typename T&gt;\ninline T const&amp; max(T const&amp; a, T const&amp; b, T const&amp; c)\n{\n    return max(max(a, b), c);\n}\n\ninline X::A const&amp; max(X::A const&amp; a, X::A const&amp; b)\n{\n    std::cout &lt;&lt; \"non-template\" &lt;&lt; '\\n';\n    return a;\n}\n\nint main()\n{\n    X::A a, b, c;\n    max(a, b, c);\n}\n\nnamespace X {\n    template &lt;typename T&gt;\n    inline T const&amp; max(T const&amp; a, T const&amp; b)\n    {\n        std::cout &lt;&lt; \"template\" &lt;&lt; '\\n';\n        return a;\n    }\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/1d206889631be5af\">Live example</a> </p>\n", "AcceptedAnswerId": "24533452", "Title": "How does the compiler find the template function X::max(T const&, T const&) through ADL in the code below?", "CreationDate": "2014-07-02T13:58:38.927", "Id": "24533091", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-07-02T14:29:41.517", "Score": "5", "OwnerUserId": "2548699", "Tags": "<c++><templates><c++11><language-lawyer><argument-dependent-lookup>", "AnswerCount": "1"}, "24533452": {"Id": "24533452", "PostTypeId": "2", "Body": "<h2>Standardese</h2>\n<p>The call to <code>max()</code> in the example entails a dependent name because its arguments depend on the template parameter <code>T</code>. Two-phase name lookup for such dependent names is defined in the Standard as follows:</p>\n<p><strong>14.6.4.2 Candidate functions [temp.dep.candidate]</strong></p>\n<blockquote>\n<p id=\"so_24533091_24533452_0\">1 For a function call where the post\ufb01x-expression is a dependent name,\n  the candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2) except that: </p>\n<p id=\"so_24533091_24533452_1\">\u2014 For the part of the lookup using unquali\ufb01ed name lookup (3.4.1), only function declarations from the template de\ufb01nition\n  context are found. </p>\n<p id=\"so_24533091_24533452_2\">\u2014 For the part of the lookup using associated\n  namespaces (3.4.2), only function declarations found in either the\n  template de\ufb01nition context or the template instantiation context are\n  found.</p>\n</blockquote>\n<p>Unqualified lookup is defined by</p>\n<p><strong>3.4.1 Unquali\ufb01ed name lookup [basic.lookup.unqual]</strong></p>\n<blockquote>\n<p id=\"so_24533091_24533452_3\">1 In all the cases listed in 3.4.1, the scopes are searched for a\n  declaration in the order listed in each of the respective categories;\n  <strong>name lookup ends as soon as a declaration is found</strong> for the name. If no\n  declaration is found, the program is ill-formed.</p>\n</blockquote>\n<p>and argument-dependent lookup (ADL) as</p>\n<p><strong>3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</strong></p>\n<blockquote>\n<p id=\"so_24533091_24533452_4\">1 When the postfix-expression in a function call (5.2.2) is <strong>an\n  unqualified-id</strong>, other namespaces not considered during the usual\n  unqualified lookup (3.4.1) may be searched, and in those namespaces,\n  namespace-scope friend function or function template declarations\n  (11.3) not otherwise visible may be found. These modifications to the\n  search <strong>depend on the types of the arguments</strong> (and for template template\n  arguments, the namespace of the template argument).</p>\n</blockquote>\n<h2>Why your code fails</h2>\n<p>In your example, unqualified lookup and ADL both do not find any overload <strong>at the point of definition</strong> because the compiler has not seen any two-argument <code>max()</code> yet. ADL also applies <strong>at the point of instantiation</strong>, and at that time, the compiler has seen the two-argument <code>template max(T, T)</code> which is the only one that can be called. (the difference is that template instantion happens after the entire translation unit has been parsed).</p>\n<h2>Better code</h2>\n<p>You should fix your code by putting the non-template <code>max(X::A, X::A)</code> overload inside the <code>namespace X</code> and move the <code>template max(T, T)</code> out of it.</p>\n<pre><code>#include &lt;iostream&gt;\n\n// generic code\n\ntemplate &lt;typename T&gt;\ninline T const&amp; max(T const&amp; a, T const&amp; b)\n{\n    std::cout &lt;&lt; \"template\" &lt;&lt; '\\n';\n    return a;\n}\n\ntemplate &lt;typename T&gt;\ninline T const&amp; max(T const&amp; a, T const&amp; b, T const&amp; c)\n{\n    using ::max; // fallback if no user-defined max\n    return max(max(a, b), c);\n}\n\n// X specific code\n\nnamespace X {\n\nclass A {};\n\ninline X::A const&amp; max(X::A const&amp; a, X::A const&amp; b)\n{\n    std::cout &lt;&lt; \"non-template\" &lt;&lt; '\\n';\n    return a;\n}\n\n} // namespace X\n\nint main()\n{\n    X::A a, b, c;\n    max(a, b, c);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f33f0db234aba004\" rel=\"nofollow\"><strong>Live-Example</strong></a> that prints \"non-template\" twice.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2014-07-02T14:29:41.517", "Score": "3", "CreationDate": "2014-07-02T14:14:42.693", "ParentId": "24533091", "CommentCount": "11", "LastEditDate": "2014-07-02T14:29:41.517", "OwnerUserId": "819272"}});