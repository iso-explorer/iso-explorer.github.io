post_cb({"1179962": {"ParentId": "1179937", "CommentCount": "0", "Body": "<p>It's not fixed - the compiler has a great freedom in how to implement a reference on a case by case basis. So in your second example it treats j as an alias for i, nothing else needed. When passing a ref parameter it could also use a stack-offset, again no overhead. But in other situations it could use a pointer.</p>\n", "OwnerUserId": "60761", "PostTypeId": "2", "Id": "1179962", "Score": "2", "CreationDate": "2009-07-24T20:20:55.417", "LastActivityDate": "2009-07-24T20:20:55.417"}, "1179950": {"ParentId": "1179937", "CommentCount": "0", "Body": "<p>References don't actually exist physically until they need to have a physical manifestation (i.e., as a member of an aggregate).</p>\n<p>Having an array of references is illegal probably due to the above. But nothing prevents you from creating an array of structs/classes that have reference members.</p>\n<p>I'm sure someone will point out the standard clause that mentions all this.</p>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "1179950", "Score": "3", "CreationDate": "2009-07-24T20:18:07.543", "LastActivityDate": "2009-07-24T20:18:07.543"}, "1179937": {"CommentCount": "1", "ViewCount": "12541", "LastActivityDate": "2017-01-16T09:25:21.653", "Body": "<p>Given:</p>\n<pre><code>int i = 42;\nint j = 43;\nint k = 44;\n</code></pre>\n<p>By looking at the variables addresses we know that each one takes up 4 bytes (on most platforms).</p>\n<p>However, considering:</p>\n<pre><code>int i = 42;\nint&amp; j = i;\nint k = 44;\n</code></pre>\n<p>We will see that variable <code>i</code> indeed takes 4 bytes, but <code>j</code> takes <strong>none</strong> and <code>k</code> takes again 4 bytes on the stack.</p>\n<p>What is happening here? It looks like <code>j</code> is simply non-existent in runtime. And what about a reference I receive as a function argument? That <em>must</em> take some space on the stack...</p>\n<p>And while we're at it - why can't I define an array or references?</p>\n<pre><code>int&amp;[] arr = new int&amp;[SIZE]; // compiler error! array of references is illegal\n</code></pre>\n", "PostTypeId": "1", "AcceptedAnswerId": "1179951", "FavoriteCount": "22", "Title": "How does a C++ reference look, memory-wise?", "Id": "1179937", "Score": "33", "CreationDate": "2009-07-24T20:15:38.923", "Tags": "<c++><memory-management><reference>", "OwnerUserId": "24545", "AnswerCount": "8"}, "1180249": {"ParentId": "1179937", "CommentCount": "0", "Body": "<p>Something that is only mentioned in passing elsewhere - how to get the compiler to devote some storage space to a reference:</p>\n<pre><code>class HasRef\n{\n    int &amp;r;\n\npublic:\n    HasRef(int &amp;n)\n        : r(n) { }\n};\n</code></pre>\n<p>This denies the compiler the opportunity to simply treat it as a compile-time alias (an alternative name for the same storage).</p>\n", "OwnerUserId": "27423", "PostTypeId": "2", "Id": "1180249", "Score": "5", "CreationDate": "2009-07-24T21:27:57.483", "LastActivityDate": "2009-07-24T21:27:57.483"}, "1179961": {"ParentId": "1179937", "CommentCount": "0", "Body": "<p>In practice, a reference is equivalent to a pointer, except that the extra constraints on how references are allowed to be used can allow a compiler to \"optimize it away\" in more cases (depending on how smart the compiler is, its optimization settings, etc etc of course).</p>\n", "OwnerUserId": "95810", "PostTypeId": "2", "Id": "1179961", "Score": "7", "CreationDate": "2009-07-24T20:20:43.373", "LastActivityDate": "2009-07-24T20:20:43.373"}, "1179959": {"ParentId": "1179937", "CommentCount": "0", "Body": "<p>You can't define an array of references because there is no syntax to initialize them.  C++ does not allow uninitialized references.  As for your first question, the compiler is under no obligation to allocate space for unnecessary variables.  There is no way to have j point to another variable, so it's effectively just an alias for i in the function's scope, and that's how the compiler treats it.</p>\n", "OwnerUserId": "114421", "PostTypeId": "2", "Id": "1179959", "Score": "6", "CreationDate": "2009-07-24T20:20:23.110", "LastActivityDate": "2009-07-24T20:20:23.110"}, "1179994": {"ParentId": "1179937", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_1179937_1179994_0\">How does a C++ reference look,\n  memory-wise?</p>\n</blockquote>\n<p>It doesn't. The C++ standard only says how it should behave, not how it should be implemented.</p>\n<p>In the general case, compilers usually implement references as pointers. But they generally have more information about what a reference may point to, and use that for optimization.</p>\n<p>Remember that the only requirement for a reference is that it behaves as an alias for the referenced object. So if the compiler encounters this code:</p>\n<pre><code>int i = 42;\nint&amp; j = i;\nint k = 44;\n</code></pre>\n<p>what it sees is not \"create a pointer to the variable <code>i</code>\" (although that is how the compiler may choose to implement it in some cases), but rather \"make a note in the symbol table that <code>j</code> is now an alias for <code>i</code>.\"</p>\n<p>The compiler doesn't have to create a new variable for <code>j</code>, it simply has to remember that whenever <code>j</code> is referenced from now on, it should really swap it out and use <code>i</code> instead.</p>\n<p>As for creating an array of references, you can't do it because it'd be useless and meaningless.</p>\n<p>When you create an array, all elements are default-constructed. What does it mean to default-construct a reference? What does it point to? The entire point in references is that they re <em>initialized</em> to reference another object, after which they can not be reseated. </p>\n<p>So if it could be done, you would end up with an array of references to <em>nothing</em>. And you'd be unable to change them to reference <em>something</em> because they'd been initialized already.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "1179994", "Score": "31", "CreationDate": "2009-07-24T20:27:24.093", "LastActivityDate": "2009-07-24T20:27:24.093"}, "1179951": {"ParentId": "1179937", "LastEditDate": "2017-05-23T12:26:38.723", "CommentCount": "6", "CreationDate": "2009-07-24T20:18:22.100", "OwnerUserId": "127893", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "1179951", "Score": "34", "Body": "<p>everywhere the reference <strong>j</strong> is encountered, it is replaced with <strong>the address of i</strong>. So basically the reference content address is resolved at compile time, and there is not need to dereference it like a pointer at run time.</p>\n<p><em>Just to clarify what I mean by the address of i</em> :</p>\n<pre><code>void function(int&amp; x)\n{\n    x = 10;\n}\n\nint main()\n{\n    int i = 5;\n    int&amp; j = i;\n\n    function(j);\n}\n</code></pre>\n<p>In the above code, <strong>j</strong> should not take space on the <strong><em>main stack</em></strong>, but the reference <strong>x</strong> of <strong>function</strong> will take a place on its stack. That means when calling <strong>function</strong> with <strong>j</strong> as an argument, <strong>the address of i</strong> that will be pushed on the stack of <strong>function</strong>. The compiler can and should not reserve space on the <strong>main stack</strong> for <strong>j</strong>.</p>\n<p>For the array part the standards say ::</p>\n<blockquote>\n<p id=\"so_1179937_1179951_0\"><strong>C++ Standard 8.3.2/4:</strong></p>\n<p id=\"so_1179937_1179951_1\">There shall be no references to references, no arrays of references,\n  and no pointers to references.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/1164266/why-arrays-of-references-are-illegal\">Why arrays of references are illegal?</a></p>\n", "LastActivityDate": "2009-07-24T20:59:31.627"}, "bq_ids": {"n4140": {"so_1179937_1179951_1": {"section_id": 3222, "quality": 1.0, "length": 7}}, "n3337": {"so_1179937_1179951_1": {"section_id": 3096, "quality": 1.0, "length": 7}}, "n4659": {"so_1179937_1179951_1": {"section_id": 3979, "quality": 1.0, "length": 7}}}, "38310081": {"ParentId": "1179937", "CommentCount": "0", "Body": "<p>Sorry for using assembly to explain this but I think this is the best way to understand references. </p>\n<pre><code>    #include &lt;iostream&gt;\n\n    using namespace std;\n\n    int main()\n    {\n        int i = 10;\n        int *ptrToI = &amp;i;\n        int &amp;refToI = i;\n\n        cout &lt;&lt; \"i = \" &lt;&lt; i &lt;&lt; \"\\n\";\n        cout &lt;&lt; \"&amp;i = \" &lt;&lt; &amp;i &lt;&lt; \"\\n\";\n\n        cout &lt;&lt; \"ptrToI = \" &lt;&lt; ptrToI &lt;&lt; \"\\n\";\n        cout &lt;&lt; \"*ptrToI = \" &lt;&lt; *ptrToI &lt;&lt; \"\\n\";\n        cout &lt;&lt; \"&amp;ptrToI = \" &lt;&lt; &amp;ptrToI &lt;&lt; \"\\n\";\n\n        cout &lt;&lt; \"refToNum = \" &lt;&lt; refToI &lt;&lt; \"\\n\";\n        //cout &lt;&lt; \"*refToNum = \" &lt;&lt; *refToI &lt;&lt; \"\\n\";\n        cout &lt;&lt; \"&amp;refToNum = \" &lt;&lt; &amp;refToI &lt;&lt; \"\\n\";\n\n        return 0;\n    }\n</code></pre>\n<p>Output of this code is like this </p>\n<pre><code>    i = 10\n    &amp;i = 0xbf9e52f8\n    ptrToI = 0xbf9e52f8\n    *ptrToI = 10\n    &amp;ptrToI = 0xbf9e52f4\n    refToNum = 10\n    &amp;refToNum = 0xbf9e52f8\n</code></pre>\n<p>Lets look at the disassembly(I used GDB for this. 8,9 and 10 here are line numbers of code)</p>\n<pre><code>8           int i = 10;\n0x08048698 &lt;main()+18&gt;: movl   $0xa,-0x10(%ebp)\n</code></pre>\n<p>Here <code>$0xa</code> is the 10(decimal) that we are assigning to <code>i</code>. <code>-0x10(%ebp)</code> here means content of <code>ebp register</code> \u201316(decimal). \n<code>-0x10(%ebp)</code> points to the address of <code>i</code> on stack.</p>\n<pre><code>9           int *ptrToI = &amp;i;\n0x0804869f &lt;main()+25&gt;: lea    -0x10(%ebp),%eax\n0x080486a2 &lt;main()+28&gt;: mov    %eax,-0x14(%ebp)\n</code></pre>\n<p>Assign address of <code>i</code> to <code>ptrToI</code>. <code>ptrToI</code> is again on stack located at address <code>-0x14(%ebp)</code>, that is <code>ebp</code> \u2013 20(decimal).</p>\n<pre><code>10          int &amp;refToI = i;\n0x080486a5 &lt;main()+31&gt;: lea    -0x10(%ebp),%eax\n0x080486a8 &lt;main()+34&gt;: mov    %eax,-0xc(%ebp)\n</code></pre>\n<p>Now here is the catch! Compare disassembly of line 9 and 10 and you will observer that ,<code>-0x14(%ebp)</code> is replaced by <code>-0xc(%ebp)</code> in line number 10. <code>-0xc(%ebp)</code> is the address of <code>refToNum</code>. It is allocated on stack. But you will never be able to get this address from you code because you are not required to know the address.</p>\n<p>So; a reference does occupy memory. In this case it is the stack memory since we have allocated it as a local variable. \nHow much memory does it occupy?\n As much a pointer occupies.</p>\n<p>Now lets see how we access the reference and pointers. For simplicity I have shown only part of the assembly snippet </p>\n<pre><code>16          cout &lt;&lt; \"*ptrToI = \" &lt;&lt; *ptrToI &lt;&lt; \"\\n\";\n0x08048746 &lt;main()+192&gt;:        mov    -0x14(%ebp),%eax\n0x08048749 &lt;main()+195&gt;:        mov    (%eax),%ebx\n19          cout &lt;&lt; \"refToNum = \" &lt;&lt; refToI &lt;&lt; \"\\n\";\n0x080487b0 &lt;main()+298&gt;:        mov    -0xc(%ebp),%eax\n0x080487b3 &lt;main()+301&gt;:        mov    (%eax),%ebx\n</code></pre>\n<p>Now compare the above two lines, you will see striking similarity.  <code>-0xc(%ebp)</code> is the actual address of <code>refToI</code> which is never accessible to you. \nIn simple terms, if you think of reference as a normal pointer, then accessing a reference is like fetching the value at address pointed to by the reference. Which means the below two lines of code will give you the same result</p>\n<pre><code>cout &lt;&lt; \"Value if i = \" &lt;&lt; *ptrToI &lt;&lt; \"\\n\";\ncout &lt;&lt; \" Value if i = \" &lt;&lt; refToI &lt;&lt; \"\\n\";\n</code></pre>\n<p>Now compare this</p>\n<pre><code>15          cout &lt;&lt; \"ptrToI = \" &lt;&lt; ptrToI &lt;&lt; \"\\n\";\n0x08048713 &lt;main()+141&gt;:        mov    -0x14(%ebp),%ebx\n21          cout &lt;&lt; \"&amp;refToNum = \" &lt;&lt; &amp;refToI &lt;&lt; \"\\n\";\n0x080487fb &lt;main()+373&gt;:        mov    -0xc(%ebp),%eax\n</code></pre>\n<p>I guess you are able to spot what is happening here. \nIf you ask for <code>&amp;refToI</code>, the contents of  <code>-0xc(%ebp)</code> address location are returned and <code>-0xc(%ebp)</code> is where <code>refToi</code> resides and its contents are nothing but address of <code>i</code>. </p>\n<p>One last thing, Why is this line commented?</p>\n<pre><code>//cout &lt;&lt; \"*refToNum = \" &lt;&lt; *refToI &lt;&lt; \"\\n\";\n</code></pre>\n<p>Because <code>*refToI</code> is not permitted and it will give you a compile time error. </p>\n", "OwnerUserId": "6186415", "PostTypeId": "2", "Id": "38310081", "Score": "4", "CreationDate": "2016-07-11T14:55:04.333", "LastActivityDate": "2016-07-11T14:55:04.333"}});