post_cb({"6517278": {"ParentId": "6517231", "CommentCount": "3", "Body": "<p>You should define copy constructors and assignment operators for both <code>Move</code> and <code>MoveTree</code> when using vector, otherwise it will use the compiler generated ones, which may cause problems.</p>\n", "OwnerUserId": "713026", "PostTypeId": "2", "Id": "6517278", "Score": "0", "CreationDate": "2011-06-29T07:42:40.210", "LastActivityDate": "2011-06-29T07:42:40.210"}, "6517325": {"ParentId": "6517231", "CommentCount": "13", "Body": "<p>The C++ Standard (2003) clearly says that instantiating a standard container with an incomplete type, invokes undefined-behavior.</p>\n<p>The spec says in \u00a717.4.3.6/2,</p>\n<blockquote>\n<p id=\"so_6517231_6517325_0\">In particular, the effects are undefined in the following cases:  </p>\n<p id=\"so_6517231_6517325_1\">__ [..]<br>\n  \u2014 if an incomplete type (3.9) is used as a template argument when instantiating a template component.<br>\n  __ [..]   </br></br></p>\n</blockquote>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "6517325", "Score": "24", "CreationDate": "2011-06-29T07:48:07.173", "LastActivityDate": "2011-06-29T07:48:07.173"}, "6517727": {"ParentId": "6517231", "CommentCount": "15", "Body": "<p>Use a pointer to the type in the Vector, this will be portable.</p>\n<pre><code>struct Move\n    {\n        int src;\n        int dst;\n    };\n\nstruct MoveTree;\n\nstruct MoveTree\n    {\n        Move move;\n        std::vector&lt;MoveTree*&gt; variation;\n    };\n</code></pre>\n", "OwnerUserId": "27417", "PostTypeId": "2", "Id": "6517727", "Score": "4", "CreationDate": "2011-06-29T08:29:43.377", "LastActivityDate": "2011-06-29T08:29:43.377"}, "6517244": {"ParentId": "6517231", "CommentCount": "1", "Body": "<p>The <code>MoveTree</code> elements in <code>std::vector</code> are in an allocated (as in <code>new []</code>) array.  Only the control information (the pointer to the array, the size, etc) are stored within the <code>std::vector</code> within <code>MoveTree</code>.</p>\n", "OwnerUserId": "479989", "PostTypeId": "2", "Id": "6517244", "Score": "2", "CreationDate": "2011-06-29T07:38:53.080", "LastActivityDate": "2011-06-29T07:38:53.080"}, "6517231": {"CommentCount": "1", "AcceptedAnswerId": "6517325", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-06-29T07:37:04.697", "LastActivityDate": "2011-06-29T22:21:40.127", "LastEditDate": "2017-05-23T11:53:29.427", "ViewCount": "2803", "FavoriteCount": "4", "Title": "Are C++ recursive type definitions possible, in particular can I put a vector<T> within the definition of T?", "Id": "6517231", "Score": "28", "Body": "<p>For one of my projects, what I really wanted to do was this (simplifying it to the bare minimum);</p>\n<pre><code>struct Move\n{\n    int src;\n    int dst;\n};\n\nstruct MoveTree\n{\n    Move move;\n    std::vector&lt;MoveTree&gt; variation;\n};\n</code></pre>\n<p>I must admit that I assumed that it wouldn't be possible to do this directly, I thought a vector of MoveTree s within a MoveTree would be verboten. But I tried it anyway, and it works beautifully. I am using Microsoft Visual Studio 2010 Express.</p>\n<p>Is this portable ? Is it good practise ? Do I have anything to worry about ?</p>\n<p>Edit: I've asked a second <a href=\"https://stackoverflow.com/questions/6527917/how-can-i-emulate-recursive-a-type-definition-in-c\">question</a> hoping to find a good way of doing this.</p>\n", "Tags": "<c++>", "OwnerUserId": "3955", "AnswerCount": "6"}, "6517305": {"ParentId": "6517231", "CommentCount": "3", "Body": "<p>No, it's not portable. <a href=\"http://codepad.org/C6O2A8H9\" rel=\"nofollow\">codepad.org</a> does not compile it.</p>\n<pre><code>t.cpp:14:   instantiated from here\nLine 215: error: '__gnu_cxx::_SGIAssignableConcept&lt;_Tp&gt;::__a' has incomplete type\ncompilation terminated due to -Wfatal-errors.\n</code></pre>\n", "OwnerUserId": "634336", "PostTypeId": "2", "Id": "6517305", "Score": "1", "CreationDate": "2011-06-29T07:46:11.867", "LastActivityDate": "2011-06-29T07:46:11.867"}, "6517261": {"ParentId": "6517231", "CommentCount": "1", "Body": "<p><code>MoveTree</code> is an incomplete type inside its definition. The standard does not guarantee instantiation of STL templates with incomplete types.</p>\n", "OwnerUserId": "33708", "PostTypeId": "2", "Id": "6517261", "Score": "4", "CreationDate": "2011-06-29T07:41:37.903", "LastActivityDate": "2011-06-29T07:41:37.903"}, "bq_ids": {"n4140": {"so_6517231_6517325_1": {"section_id": 6324, "quality": 1.0, "length": 8}, "so_6517231_6517325_0": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_6517231_6517325_1": {"section_id": 6081, "quality": 1.0, "length": 8}, "so_6517231_6517325_0": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_6517231_6517325_1": {"section_id": 7834, "quality": 1.0, "length": 8}, "so_6517231_6517325_0": {"section_id": 7834, "quality": 1.0, "length": 5}}}});