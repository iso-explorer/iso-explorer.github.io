post_cb({"bq_ids": {"n4140": {"so_32089214_32089365_1": {"length": 11, "quality": 1.0, "section_id": 5451}, "so_32089214_32089365_2": {"length": 18, "quality": 1.0, "section_id": 302}, "so_32089214_32089365_4": {"length": 10, "quality": 1.0, "section_id": 303}, "so_32089214_32089365_0": {"length": 26, "quality": 1.0, "section_id": 5356}}, "n3337": {"so_32089214_32089365_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5245}, "so_32089214_32089365_0": {"length": 26, "quality": 1.0, "section_id": 5153}, "so_32089214_32089365_4": {"length": 10, "quality": 1.0, "section_id": 294}, "so_32089214_32089365_2": {"length": 18, "quality": 1.0, "section_id": 293}}, "n4659": {"so_32089214_32089365_1": {"length": 11, "quality": 1.0, "section_id": 6889}, "so_32089214_32089365_0": {"length": 26, "quality": 1.0, "section_id": 6781}, "so_32089214_32089365_4": {"length": 10, "quality": 1.0, "section_id": 310}, "so_32089214_32089365_2": {"length": 18, "quality": 1.0, "section_id": 309}}}, "32089365": {"Id": "32089365", "PostTypeId": "2", "Body": "<p>N4296 2.13.5/8</p>\n<blockquote>\n<p id=\"so_32089214_32089365_0\">Ordinary string literals and UTF-8 string literals are also referred\n  to as narrow string literals. <strong>A narrow string literal has type \u201carray\n  of n const char\u201d</strong>, where n is the size of the string as defined below,\n  and has static storage duration (3.7).</p>\n</blockquote>\n<p>But since variable is initialized as in your code it is actually <code>const char*</code>, you can check it like this.</p>\n<pre><code>template&lt;typename&gt; struct TD;\n\nint main()\n{\n   auto a = \"Hello World\";\n   TD&lt;decltype(a)&gt; _;\n}\n</code></pre>\n<p>Here will be compile error in which you can see the actual type of <code>TD</code> instance, something like this with clang</p>\n<pre><code>error: implicit instantiation of undefined template 'TD&lt;const char *&gt;'\n</code></pre>\n<p>N4296 7.1.6.4</p>\n<blockquote>\n<p id=\"so_32089214_32089365_1\">If the placeholder is the auto type-specifier, the deduced type is\n  determined using the rules for template argument deduction.</p>\n</blockquote>\n<pre><code>template&lt;typename&gt; struct TD;\n\ntemplate&lt;typename T&gt;\nvoid f(T) \n{\n   TD&lt;T&gt; _;\n}\n\nint main()\n{\n   auto c = \"Hello\";\n   TD&lt;decltype(c)&gt; _;\n   f(\"Hello\");\n}\n</code></pre>\n<p>Both instantiated objects of type <code>TD</code> has type <code>TD&lt;const char*&gt;</code>.</p>\n<p>N4926 14.8.2.1</p>\n<blockquote>\n<p id=\"so_32089214_32089365_2\">Template argument deduction is done by comparing each function\n  template parameter type (call it P) with the type of the corresponding\n  argument of the call (call it A) as described below.</p>\n<p id=\"so_32089214_32089365_3\">If P is not a reference type:</p>\n<p id=\"so_32089214_32089365_4\">If A is an array type, the pointer type produced by the\n  array-to-pointer standard conversion (4.2) is used in place of A for\n  type deduction</p>\n</blockquote>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2015-08-19T08:24:57.933", "Score": "9", "CreationDate": "2015-08-19T07:41:42.007", "ParentId": "32089214", "CommentCount": "6", "OwnerUserId": "1498580", "LastEditDate": "2015-08-19T08:24:57.933"}, "32089508": {"Id": "32089508", "PostTypeId": "2", "Body": "<p>Unless you've reason to think it'd be implementation or un-defined, can just test:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; void f() { std::cout &lt;&lt; \"other\\n\"; }\ntemplate &lt;&gt; void f&lt;const char*&gt;() { std::cout &lt;&lt; \"const char*\\n\"; }\ntemplate &lt;&gt; void f&lt;const char* const&gt;()\n    { std::cout &lt;&lt; \"const char* const\\n\"; }\ntemplate &lt;&gt; void f&lt;const char(&amp;)[12]&gt;() { std::cout &lt;&lt; \"const char[12]\\n\"; }\n\nint main()\n{\n    auto a = \"Hello World\";\n    f&lt;decltype(a)&gt;();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>const char*\n</code></pre>\n<p>Checking that <code>++a</code> compiles is another clue (it does), and while implementation defined <code>#include &lt;typeinfo&gt;</code> / <code>typeid(a).name()</code> can often help answer such questions.</p>\n<p>Change to <code>auto&amp; a</code> and you'll see <code>a</code> changes to <code>const char(&amp;)[12]</code>.</p>\n", "LastActivityDate": "2015-08-19T07:48:25.820", "CommentCount": "0", "CreationDate": "2015-08-19T07:48:25.820", "ParentId": "32089214", "Score": "2", "OwnerUserId": "410767"}, "32089214": {"ViewCount": "409", "Body": "<p>In this line:</p>\n<pre><code>auto a = \"Hello World\";\n</code></pre>\n<p>What is the <strong>exact</strong> Type of <code>a</code>? I'd guess <code>char[]</code> or <code>const char* const</code> but I'm not sure.</p>\n", "AcceptedAnswerId": "32089365", "Title": "What is the exact type of \"\" when deduced by `auto`?", "CreationDate": "2015-08-19T07:33:48.560", "Id": "32089214", "CommentCount": "2", "LastEditDate": "2015-08-19T08:12:42.170", "PostTypeId": "1", "LastEditorUserId": "34509", "LastActivityDate": "2015-08-19T08:24:57.933", "Score": "4", "OwnerUserId": "3265278", "Tags": "<c++><c++11><auto><c-strings>", "AnswerCount": "3"}, "32089709": {"Id": "32089709", "PostTypeId": "2", "Body": "<p>You can print the type of a using <code>typeinfo</code></p>\n<pre><code>int main()\n{\n    auto a = \"Hello World\";\n    std::cout &lt;&lt; \"type is: \" &lt;&lt; typeid(a).name() &lt;&lt; '\\n';\n} \n</code></pre>\n<p>on gcc it will print</p>\n<blockquote>\n<p id=\"so_32089214_32089709_0\">pi is: PKc</p>\n</blockquote>\n<p>which stands for pointer to constant char\nIf you're in Windows the output will be a lot more readable, but you get used to this syntax too. </p>\n<p>If you know more or less which type you a re looking for, you can also check if two types are equivalent with:</p>\n<pre><code>#include &lt;typeinfo&gt;\nstd::cout &lt;&lt; std::is_same&lt;const char*, decltype(a)&gt;::value &lt;&lt; std::endl;\n</code></pre>\n", "LastEditorUserId": "1001195", "LastActivityDate": "2015-08-19T08:04:16.737", "Score": "1", "CreationDate": "2015-08-19T07:58:33.210", "ParentId": "32089214", "CommentCount": "3", "OwnerUserId": "1001195", "LastEditDate": "2015-08-19T08:04:16.737"}});