post_cb({"bq_ids": {"n4140": {"so_43243129_43243562_0": {"length": 19, "quality": 0.76, "section_id": 4188}}, "n3337": {"so_43243129_43243562_0": {"length": 19, "quality": 0.76, "section_id": 4031}}, "n4659": {"so_43243129_43243562_0": {"length": 23, "quality": 0.92, "section_id": 5448}}}, "43243129": {"ViewCount": "58", "Body": "<p>How can I check at compile-time whether or not an arbitrary type can be used with <code>std::pointer_traits</code>? I had hoped a simple SFINAE solution might work:</p>\n<pre><code>template &lt;typename T, typename = void&gt;\nstruct pointer_traits_ready : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct pointer_traits_ready&lt;\n         T,\n         std::void_t&lt;typename std::pointer_traits&lt;T&gt;::element_type&gt;\n       &gt; : std::true_type {};\n\nstatic_assert(!pointer_traits_ready&lt;int&gt;::value,\"\");\n</code></pre>\n<p>...but this invokes a static assert from within the standard library (ptr_traits.h). Obviously <code>std::is_pointer</code> doesn't accommodate smart pointers.</p>\n", "AcceptedAnswerId": "43243562", "Title": "Testing if std::pointer_traits can work with my type", "CreationDate": "2017-04-05T23:15:49.780", "Id": "43243129", "CommentCount": "1", "LastEditDate": "2017-04-06T00:06:37.330", "PostTypeId": "1", "LastEditorUserId": "2023370", "LastActivityDate": "2017-04-06T00:07:45.027", "Score": "2", "OwnerUserId": "2023370", "Tags": "<c++><pointers><smart-pointers><c++1z><typetraits>", "AnswerCount": "1"}, "43243562": {"Id": "43243562", "PostTypeId": "2", "Body": "<p>You can't. From <a href=\"http://eel.is/c++draft/pointer.traits.types\" rel=\"nofollow noreferrer\">[pointer.traits.types]</a>:</p>\n<blockquote>\n<pre><code>using element_type = see below ;\n</code></pre>\n<p id=\"so_43243129_43243562_0\"><em>Type:</em> <code>Ptr::element_type</code> if the <em>qualified-id</em> <code>Ptr::element_type</code> is valid and denotes a type (14.8.2); otherwise, <code>T</code> if <code>Ptr</code> is a class template instantiation of the form <code>SomePointer&lt;T, Args&gt;</code>, where Args is\n  zero or more type arguments; <strong>otherwise, the specialization is ill-formed.</strong></p>\n</blockquote>\n<p>In order to be SFINAE-friendly, we would need <code>pointer_traits&lt;Foo&gt;</code>  to simply lack a type alias named <code>element_type</code>. The problem is, <code>element_type</code> is specified as being ill-formed - not absent. So you simply cannot use <code>pointer_traits</code> as a detector for whether or not something can be used as a pointer type.</p>\n<p>Even if you wrote your own type that was a SFINAE-friendly version of that specification, you wouldn't be able to catch user specializations of <code>pointer_traits</code> for their own type. Sad panda. </p>\n", "LastActivityDate": "2017-04-06T00:07:45.027", "Score": "2", "CreationDate": "2017-04-06T00:07:45.027", "ParentId": "43243129", "CommentCount": "4", "OwnerUserId": "2069064"}});