post_cb({"bq_ids": {"n4140": {"so_13559255_13559392_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 477}, "so_13559255_13559392_1": {"length": 23, "quality": 1.0, "section_id": 477}, "so_13559255_13559392_2": {"length": 9, "quality": 1.0, "section_id": 477}, "so_13559255_13559392_3": {"length": 6, "quality": 1.0, "section_id": 477}}, "n3337": {"so_13559255_13559392_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 468}, "so_13559255_13559392_1": {"length": 23, "quality": 1.0, "section_id": 468}, "so_13559255_13559392_2": {"length": 9, "quality": 1.0, "section_id": 468}, "so_13559255_13559392_3": {"length": 6, "quality": 1.0, "section_id": 468}}, "n4659": {"so_13559255_13559392_0": {"length": 49, "quality": 0.9423076923076923, "section_id": 500}, "so_13559255_13559392_1": {"length": 23, "quality": 1.0, "section_id": 500}, "so_13559255_13559392_2": {"length": 9, "quality": 1.0, "section_id": 500}, "so_13559255_13559392_3": {"length": 6, "quality": 1.0, "section_id": 500}}}, "13559589": {"Id": "13559589", "PostTypeId": "2", "Body": "<p>Because the compiler generate assignment operator(s)</p>\n<pre><code>Point&amp; operator=(Point const&amp; rhs)\n{\n    Vector3::operator=(rhs);\n    return *this;\n}\n\nVector3&amp; operator=(Vector3 const&amp; rhs)\n{\n   // A class is a friend of irself.\n   // So an object of Type A can read any other object of type A\n   _x = rhs._x;\n   _y = rhs._y;\n   _z = rhs._z;\n   return *this;\n}\n</code></pre>\n", "LastEditorUserId": "14065", "LastActivityDate": "2012-11-26T06:27:50.533", "Score": "0", "CreationDate": "2012-11-26T06:17:23.013", "ParentId": "13559255", "CommentCount": "3", "OwnerUserId": "14065", "LastEditDate": "2012-11-26T06:27:50.533"}, "13559287": {"Id": "13559287", "PostTypeId": "2", "Body": "<p>Because the default copy operator of Vector3 is invoked (shallow copy).</p>\n", "LastActivityDate": "2012-11-26T05:47:15.617", "CommentCount": "1", "CreationDate": "2012-11-26T05:47:15.617", "ParentId": "13559255", "Score": "0", "OwnerUserId": "453492"}, "13559392": {"Id": "13559392", "PostTypeId": "2", "Body": "<pre><code>aPoint = anotherPoint;\n</code></pre>\n<p>This line triggers a call of <code>Point::operator=</code> (the assignment operator), which exists because the compiler generates a default implementation. This default implementation performs assignment operations for all members of the class, as well as calling <code>Vector3::operator=</code>, the assignment operator of the base class. This, in turn, is a member function of <code>Vector3</code> and therefore has access to all private members, which it makes copies of.</p>\n<hr>\n<p>(EDIT) A quote from the C++11 Standard to back this answer:</p>\n<blockquote>\n<p id=\"so_13559255_13559392_0\">(\u00a712.8/28) The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise copy-/move assignment of its subobjects. The direct base classes of X are assigned first, in the order of their declaration in the base-specifier-list, and then the immediate non-static data members of X are assigned, in the order in which they were declared in the class definition. Let x be either the parameter of the function or, for the move operator, an xvalue referring to the parameter. Each subobject is assigned in the manner appropriate to its type:  </p>\n<p id=\"so_13559255_13559392_1\">\u2014 if the subobject is of class type, as if by a call to operator= with the subobject as the object expression\n  and the corresponding subobject of x as a single function argument (as if by explicit qualification; that is, ignoring any possible virtual overriding functions in more derived classes);  </p>\n<p id=\"so_13559255_13559392_2\">\u2014 if the subobject is an array, each element is assigned, in the manner appropriate to the element type;  </p>\n<p id=\"so_13559255_13559392_3\">\u2014 if the subobject is of scalar type, the built-in assignment operator is used.</p>\n</blockquote>\n<p>Some of the other (now partly deleted) answers mentioned the idea of a bitwise copy performed by the assignment operation. There is some truth in this: If your class or struct defines a POD (plain old data) type, it is for all practical purposes identical to a C struct. In that case, it can be copied by performing <code>memcpy</code>, therefore you can <em>think</em> of the assignment operation as being basically equivalent to a bitwise copy. But the reason why this is a valid way of thinking about it is \u00a712.8/28 above, and that applies to non-POD types as well.</p>\n<p>Also note that from your code it is not necessarily clear that your data type is POD. You mentioned <em>constructors and stuff</em> in the base class: If this involves non-trivial copy constructors, assignment operators or possibly virtual functions, then your data type is no longer POD.</p>\n<hr>\n<p>About the question in the comment: In order to call the base-class assignment operator from within the derived-class implementation, just call it:</p>\n<pre><code>struct Base\n{\n};\n\nstruct Derived : Base\n{\n  Derived &amp;operator=(const Derived &amp;other)\n  { Base::operator=(other); return *this; }\n};\n</code></pre>\n</hr></hr>", "LastEditorUserId": "777186", "LastActivityDate": "2012-11-26T06:34:22.737", "Score": "4", "CreationDate": "2012-11-26T05:56:13.033", "ParentId": "13559255", "CommentCount": "4", "OwnerUserId": "777186", "LastEditDate": "2012-11-26T06:34:22.737"}, "13559255": {"ViewCount": "1691", "Body": "<p>My problem is very easily explained by this example : </p>\n<p><a href=\"http://pastebin.com/VDBE3miY\" rel=\"nofollow\">http://pastebin.com/VDBE3miY</a></p>\n<pre><code>class Vector3\n{\n  float                   _x;\n  float                   _y;\n  float                   _z;\n\npublic :\n /// constructors and stuff\n\n};\n\nclass Point : public Vector3\n{\n// some BS\n  Point(float _x):Vector3(float _x)\n  {}\n};\n\nmain()\n{\n   Point aPoint(3);\n   Point anotherPoint(4);\n\n   // WHY DOES THIS WORK and copy _x,_y &amp; _z properly\n   aPoint = anotherPoint;\n}\n</code></pre>\n<p>Basically, I am at a loss to understand why the <code>=</code> for the derived class can copy <code>_x</code>, <code>_y</code> and <code>_z</code>, even though it shouldn't have access to them since they are private.</p>\n", "Title": "Default assignment operator has access to private members of base class", "CreationDate": "2012-11-26T05:44:06.960", "LastActivityDate": "2012-11-26T06:34:22.737", "CommentCount": "5", "LastEditDate": "2012-11-26T05:49:44.757", "PostTypeId": "1", "LastEditorUserId": "777186", "Id": "13559255", "Score": "2", "OwnerUserId": "410422", "Tags": "<c++>", "AnswerCount": "3"}});