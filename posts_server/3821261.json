post_cb({"3822237": {"ParentId": "3821261", "CommentCount": "2", "Body": "<p>I would say the questions contains incomplete information. My shop still has a check for NULL before delete in our coding standard, as we still have one compiler/platform configuration that we must support that goes into undefined behavior with the defualt delete operator if it is passed NULL. If the original poster has a simular situation then there is a point to the check for NULL, otherwise, change the coding standard!</p>\n", "OwnerUserId": "270327", "PostTypeId": "2", "Id": "3822237", "Score": "1", "CreationDate": "2010-09-29T13:50:49.123", "LastActivityDate": "2010-09-29T13:50:49.123"}, "3821334": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p>From Standard docs, <em>18.5.1.1.13</em> under <code>delete</code>,</p>\n<blockquote>\n<p id=\"so_3821261_3821334_0\">Default behavior: <strong>If ptr is null, does nothing.</strong> Otherwise, reclaims the storage allocated by the earlier call to\n  operator new.</p>\n</blockquote>\n<p>So, you don't have to check <em>by default</em>..</p>\n", "OwnerUserId": "249490", "PostTypeId": "2", "Id": "3821334", "Score": "3", "CreationDate": "2010-09-29T11:54:30.587", "LastActivityDate": "2010-09-29T11:54:30.587"}, "3821692": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p>I would say it is the responsibility of an overloaded <code>delete</code> to behave like you expect <code>delete</code> to behave. That is, it <em>should</em> handle NULL pointers as a no-op.</p>\n<p>And so, when calling an overloaded delete, you should <em>not</em> check for NULL. You should rely on the overloaded delete to be implemented correctly.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "3821692", "Score": "6", "CreationDate": "2010-09-29T12:48:28.320", "LastActivityDate": "2010-09-29T12:48:28.320"}, "3821288": {"ParentId": "3821261", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_3821261_3821288_0\">Is it a good idea to check for NULL before calling delete for any object?</p>\n</blockquote>\n<p>No!</p>\n<pre><code>int *p = NULL;\ndelete p ; //no effect\n</code></pre>\n<p>The Standard says [Section 5.3.5/2]</p>\n<blockquote>\n<p id=\"so_3821261_3821288_1\">If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section.  In either alternative, <strong>if the value of the operand of delete is the null pointer the operation has no effect</strong>.</p>\n</blockquote>\n<p>Furthermore in Section <code>18.4.1.1/13</code></p>\n<p><code>void operator delete(void* ptr) throw();</code></p>\n<p><code>void operator delete(void* ptr, const std::nothrow_t&amp;) throw();</code></p>\n<blockquote>\n<p id=\"so_3821261_3821288_2\">Default behavior:</p>\n<p id=\"so_3821261_3821288_3\">\u2014  <strong>For a null value of ptr, do nothing</strong>.</p>\n<p id=\"so_3821261_3821288_4\">\u2014  Any  other  value  of ptr shall  be  a  value  returned  earlier  by  a  call  to  the  default operator new, which  was  not  invalidated  by  an  intervening  call  to operator delete(void*) (17.4.3.7).  For such a non-null value of ptr, reclaims storage allocated by the earlier call to the default operator new.</p>\n</blockquote>\n<p><strong>EDIT</strong> :  </p>\n<p>James Kanze <a href=\"http://bytes.com/topic/c/answers/853692-null-pointer-overloaded-operator-delete\" rel=\"nofollow\">here</a> says that</p>\n<blockquote>\n<p id=\"so_3821261_3821288_5\">It's still the responisiblity of operator delete (or delete[]) to check; the standard doesn't guarantee that it won't be given a null pointer; the standard requires that it be a no-op if given a null pointer. Or that the implementation is allowed to call it. According to the latest draft, \"The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect.\" I'm not quite sure what the implications of that \"is one supplied in the standard library\" are meant to be---taken literally, since his function is not one provided by the standard library, the sentence wouldn't seem to apply. But somehow, that doesn't make sense.</p>\n</blockquote>\n", "OwnerUserId": "165520", "LastEditorUserId": "165520", "LastEditDate": "2010-09-29T12:08:04.877", "Id": "3821288", "Score": "7", "CreationDate": "2010-09-29T11:46:38.983", "LastActivityDate": "2010-09-29T12:08:04.877"}, "bq_ids": {"n4140": {"so_3821261_3821288_1": {"section_id": 6106, "quality": 0.8888888888888888, "length": 24}, "so_3821261_3821334_0": {"section_id": 6828, "quality": 0.8571428571428571, "length": 12}, "so_3821261_3821277_0": {"section_id": 7175, "quality": 0.8, "length": 12}}, "n3337": {"so_3821261_3821288_1": {"section_id": 5872, "quality": 0.8888888888888888, "length": 24}, "so_3821261_3821334_0": {"section_id": 6580, "quality": 0.8571428571428571, "length": 12}, "so_3821261_3821277_0": {"section_id": 6919, "quality": 0.8, "length": 12}}, "n4659": {"so_3821261_3821288_1": {"section_id": 7603, "quality": 0.8888888888888888, "length": 24}, "so_3821261_3821334_0": {"section_id": 8320, "quality": 0.8571428571428571, "length": 12}, "so_3821261_3821277_0": {"section_id": 8683, "quality": 0.8, "length": 12}}}, "3821326": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p><code>delete (T*)0;</code> is valid and does nothing, similarly <code>free(NULL);</code> is also valid and does nothing. If you overload the <code>delete</code> operator, your implementation should carry the same semantics. The standard says how the standard <code>delete</code> will work, but I don't think it says how an overloaded <code>delete</code> should behave. For the sake of consistency with the standard/default behaviour, it should allow <code>(T*)0</code> as input.</p>\n", "OwnerUserId": "10320", "PostTypeId": "2", "Id": "3821326", "Score": "3", "CreationDate": "2010-09-29T11:53:16.160", "LastActivityDate": "2010-09-29T11:53:16.160"}, "3821261": {"CommentCount": "3", "AcceptedAnswerId": "3821277", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2010-09-29T11:43:02.953", "LastActivityDate": "2015-07-09T15:34:29.990", "LastEditDate": "2015-07-09T15:34:29.990", "ViewCount": "4287", "FavoriteCount": "1", "Title": "NULL check before deleting an object with an overloaded delete", "Id": "3821261", "Score": "26", "Body": "<p>This came up as one of the code review comments.</p>\n<p>Is it a good idea to check for NULL before calling delete for any object? </p>\n<p>I do understand delete operator checks for NULL internally and is redundant but the argument put forth was delete as an operator can be overloaded and if the overloaded version doesn't check for the NULL it may crash. So is it safe and reasonable to assume that if and when delete will be overloaded it will check for the NULL or not? \nIn my understanding its reasonable to assume the first case that overloaded delete shall take care of the NULL check, and the review point doesn't hold good. What do you think?</p>\n", "Tags": "<c++><null><delete-operator>", "OwnerUserId": "452307", "AnswerCount": "11"}, "3822050": {"ParentId": "3821261", "CommentCount": "3", "Body": "<p>A bit of C++ pedantry:\nNULL is not a built-in concept.  Yes we all know what it means but in C++ before C++0X the null pointer concept is simply the value 0.  NULL is usually a platform-specific macro that expands to 0.</p>\n<p>With C++0X we're getting nullptr which is clearer than a plain zero and is not convertible to any integral type except bool, and is a better concept than NULL (or perhaps a better implementation of the concept behind NULL).</p>\n", "OwnerUserId": "33987", "PostTypeId": "2", "Id": "3822050", "Score": "0", "CreationDate": "2010-09-29T13:29:13.707", "LastActivityDate": "2010-09-29T13:29:13.707"}, "3821277": {"ParentId": "3821261", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>No, don't check for null. The standard says that <code>delete (T*)0;</code> is valid. It will just complicate your code for no benefits. If <code>operator delete</code> is overloaded it's better to check for null in the implementation of the operator. Just saves code lines and bugs.</p>\n<p><strong>EDIT:</strong> This answer was accepted and upvoted, yet, in my opinion, it was not very informative. There is one missing piece in all answers here, and, for conscience sake, let me add this last piece here.</p>\n<p>The standard actually says in [basic.stc.dynamic], at least since C++03:</p>\n<blockquote>\n<p id=\"so_3821261_3821277_0\">Any allocation and/or deallocation functions defined in a C++ program, including the default versions in the library, shall conform to the semantics specified in 3.7.4.1 and 3.7.4.2.</p>\n</blockquote>\n<p>Where the referenced sections, as well as some other places in the standard listed in other answers, say that the semantics of passing a null pointer are a no-op.</p>\n", "OwnerUserId": "277176", "LastEditorUserId": "277176", "LastEditDate": "2012-07-18T08:03:56.990", "Id": "3821277", "Score": "35", "CreationDate": "2010-09-29T11:45:31.513", "LastActivityDate": "2012-07-18T08:03:56.990"}, "3822070": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p>Is it <strong>not</strong> necesary to check. If anyone overload the pethod, is his responsibility to to whatever with NULL.</p>\n", "OwnerUserId": "460306", "PostTypeId": "2", "Id": "3822070", "Score": "2", "CreationDate": "2010-09-29T13:31:56.540", "LastActivityDate": "2010-09-29T13:31:56.540"}, "3821683": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p>No need to check for NULL prior to deleting. If someone has overloading <code>delete</code> with something that does not behave in a standard way then <em>that's</em> the real problem. No-one should take lightly the task of overloading <code>delete</code> and should always support expected behaviour such as checking for NULL and taking no action.</p>\n<p>However, for what it's worth, you should <em>always</em> remember to assign zero to any pointer that you've just deleted, unless for example you are about to delete the pointer as well:</p>\n<pre><code>void MyObj::reset()\n{\n    delete impl_;\n    impl_ = 0;    // Needed here - impl_ may be reused / referenced.\n}\n\nMyObj::~MyObj()\n{\n    delete impl_; // No need to assign here as impl_ is going out of scope.\n}\n</code></pre>\n", "OwnerUserId": "258009", "PostTypeId": "2", "Id": "3821683", "Score": "2", "CreationDate": "2010-09-29T12:46:41.600", "LastActivityDate": "2010-09-29T12:46:41.600"}, "3821296": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p>No need to check null.  delete operator does chck for null so additional check is not required.</p>\n", "Id": "3821296", "PostTypeId": "2", "OwnerDisplayName": "user453425", "Score": "3", "CreationDate": "2010-09-29T11:48:25.487", "LastActivityDate": "2010-09-29T11:48:25.487"}, "3821280": {"ParentId": "3821261", "CommentCount": "0", "Body": "<p>I would say that that's more a reason to ensure that if you overload <code>operator delete</code>, then you should always have it check for <code>NULL</code>, otherwise you're breaking the semantics.</p>\n", "OwnerUserId": "129570", "PostTypeId": "2", "Id": "3821280", "Score": "19", "CreationDate": "2010-09-29T11:46:13.570", "LastActivityDate": "2010-09-29T11:46:13.570"}});