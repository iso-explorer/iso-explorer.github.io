post_cb({"31269746": {"Id": "31269746", "PostTypeId": "2", "Body": "<p>AFAIK, there is no syntax rule which tells that <code>long</code> <em><code>T</code></em> is a valid type once <em><code>T</code></em> is a valid type. (But there is some related rule for  <em>qualifiers</em> like <code>volatile</code> or <code>const</code>)</p>\n<p>In other words <code>long long</code> should <em>almost</em> be seen as a \"multi-word keyword\" (but the C &amp; C++ standardization committees are very reluctant to introduce new keywords).</p>\n<p>Hence, I don't expect the following to be valid</p>\n<pre><code> // probably invalid\n typedef int fooT;\n unsigned fooT barv;\n</code></pre>\n", "LastEditorUserId": "841108", "LastActivityDate": "2015-07-07T13:36:48.310", "Score": "3", "CreationDate": "2015-07-07T13:21:15.390", "ParentId": "31269660", "CommentCount": "3", "OwnerUserId": "841108", "LastEditDate": "2015-07-07T13:36:48.310"}, "31270540": {"Id": "31270540", "PostTypeId": "2", "Body": "<p>Paragraph 2 of <strong>[dcl.type]</strong> has the rules for <code>long</code>, <code>short</code>, <code>signed</code>, <code>unsigned</code>, <code>const</code> and <code>volatile</code>.</p>\n<blockquote>\n<p id=\"so_31269660_31270540_0\">As a general rule, at most one type-speci\ufb01er is allowed in the complete decl-speci\ufb01er-seq of a declaration or in a type-speci\ufb01er-seq or trailing-type-speci\ufb01er-seq. The only exceptions to this rule are the following: </p>\n<ul>\n<li><p id=\"so_31269660_31270540_1\">const can be combined with any type speci\ufb01er except itself. </p></li>\n<li><p id=\"so_31269660_31270540_2\">volatile can be combined with any type speci\ufb01er except itself. </p></li>\n<li><p id=\"so_31269660_31270540_3\">signed or unsigned can be combined with char, long, short, or int. </p></li>\n<li><p id=\"so_31269660_31270540_4\">short or long can be combined with int. </p></li>\n<li><p id=\"so_31269660_31270540_5\">long can be combined with double. </p></li>\n<li><p id=\"so_31269660_31270540_6\">long can be combined with long.</p></li>\n</ul>\n</blockquote>\n<p>Thus</p>\n<pre><code>typedef long i1;\ntypedef const i1 i2;\n</code></pre>\n<p>is valid since <code>const</code> can be combined with any type specifier while</p>\n<pre><code>typedef long i1;\ntypedef long i1 i2;\n</code></pre>\n<p>is not since <code>i1</code> is a name for <code>long</code> but it is not the specifier <code>long</code> itself.</p>\n<p><code>i1</code> in your example may syntactically be equivalent to a keyword but it is not among the allowed specifiers to be combined with <code>long</code>. It is a different keyword and thus the rule for combination with <code>long</code> does not apply to it.</p>\n", "LastEditorUserId": "951423", "LastActivityDate": "2015-07-07T13:59:38.977", "Score": "1", "CreationDate": "2015-07-07T13:53:21.790", "ParentId": "31269660", "CommentCount": "0", "OwnerUserId": "951423", "LastEditDate": "2015-07-07T13:59:38.977"}, "31270598": {"Id": "31270598", "PostTypeId": "2", "Body": "<p>Alright, I'll answer.</p>\n<p>First, looking at this:</p>\n<blockquote>\n<p id=\"so_31269660_31270598_0\">a typedef-name is syntactically equivalent to a keyword</p>\n</blockquote>\n<p>This only means that typedef-names follow the syntax of keywords. This does not mean that a typedef-name is equivalent to any particular keyword. It's like a new, unique keyword.</p>\n<p>Then we have,</p>\n<blockquote>\n<p id=\"so_31269660_31270598_1\">A typedef-name is thus a synonym for another type.</p>\n</blockquote>\n<p>So, given <code>typedef long i1;</code>, what is this \"another type\"? It is <code>long int</code>, not just <code>long</code>.</p>\n<p>In addition, what is a \"type\"? At the least, type-specifier is not a type. The type-specifier <code>long</code> represents the type \"long int\" (see Table 10 of n3337 or Table 9 of n4296).</p>\n<p>I'll copy my comment here:</p>\n<blockquote>\n<p id=\"so_31269660_31270598_2\"><code>i1</code> is a synonym for the <em>type</em> that is <code>long int</code>. It is not a synonym for the <em>keyword</em> <code>long</code>. Otherwise you could also say <code>i1 double</code> and get a <code>long double</code>.</p>\n</blockquote>\n<p>Though perhaps I should have said, <code>i1</code> is not a synonym for the <em>type-specifier</em> <code>long</code>, but it is a synonym for the <em>type</em> <code>long int</code>.</p>\n", "LastEditorUserId": "640397", "LastActivityDate": "2015-07-07T14:05:11.380", "Score": "4", "CreationDate": "2015-07-07T13:55:22.953", "ParentId": "31269660", "CommentCount": "1", "OwnerUserId": "640397", "LastEditDate": "2015-07-07T14:05:11.380"}, "bq_ids": {"n4140": {"so_31269660_31270540_4": {"length": 5, "quality": 1.0, "section_id": 5427}, "so_31269660_31270598_1": {"length": 5, "quality": 1.0, "section_id": 5407}, "so_31269660_31269660_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5427}, "so_31269660_31270540_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5427}, "so_31269660_31270598_0": {"length": 4, "quality": 1.0, "section_id": 5407}, "so_31269660_31269660_0": {"length": 31, "quality": 1.0, "section_id": 5407}, "so_31269660_31270540_6": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_31269660_31270540_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 5427}, "so_31269660_31270540_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5427}, "so_31269660_31270540_3": {"length": 8, "quality": 1.0, "section_id": 5427}, "so_31269660_31270540_5": {"length": 4, "quality": 1.0, "section_id": 5427}}, "n3337": {"so_31269660_31270540_4": {"length": 5, "quality": 1.0, "section_id": 5222}, "so_31269660_31270598_1": {"length": 5, "quality": 1.0, "section_id": 5202}, "so_31269660_31269660_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5222}, "so_31269660_31270540_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 5222}, "so_31269660_31270598_0": {"length": 4, "quality": 1.0, "section_id": 5202}, "so_31269660_31269660_0": {"length": 31, "quality": 1.0, "section_id": 5202}, "so_31269660_31270540_6": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_31269660_31270540_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 5222}, "so_31269660_31270540_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5222}, "so_31269660_31270540_3": {"length": 8, "quality": 1.0, "section_id": 5222}, "so_31269660_31270540_5": {"length": 4, "quality": 1.0, "section_id": 5222}}, "n4659": {"so_31269660_31270540_4": {"length": 5, "quality": 1.0, "section_id": 6855}, "so_31269660_31270598_1": {"length": 5, "quality": 1.0, "section_id": 6829}, "so_31269660_31269660_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 6855}, "so_31269660_31270598_0": {"length": 4, "quality": 1.0, "section_id": 6829}, "so_31269660_31270540_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 6855}, "so_31269660_31269660_0": {"length": 31, "quality": 1.0, "section_id": 6829}, "so_31269660_31270540_6": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_31269660_31270540_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 6855}, "so_31269660_31270540_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6855}, "so_31269660_31270540_3": {"length": 8, "quality": 1.0, "section_id": 6855}, "so_31269660_31270540_5": {"length": 4, "quality": 1.0, "section_id": 6855}}}, "31269660": {"ViewCount": "187", "Body": "<p>The following paragraph is taken from [dcl.typedef]:</p>\n<blockquote>\n<p id=\"so_31269660_31269660_0\">Within the scope of its declaration, a typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in the way described in Clause 8. A typedef-name is thus a synonym for another type. A typedef-name does not introduce a new type the way a class declaration (9.1) or enum declaration does.</p>\n</blockquote>\n<p>The other relevant passage we need is from [dcl.type]</p>\n<blockquote>\n<p id=\"so_31269660_31269660_1\">As a general rule, at most one type-specifier is allowed in the complete decl-specifier-seq of a declaration or in a type-specifier-seq or trailing-type-specifier-seq. The only exceptions to this rule are the following: \u2026 long can be combined with long.</p>\n</blockquote>\n<p>In the following code, <code>i1</code> is just a synonym for long. </p>\n<pre><code>typedef long i1;\ntypedef long i1 i2;\n</code></pre>\n<p>Thus, I expect the second line to be understood as <code>typedef long long i2</code>. However, MSVC2015RC fails with</p>\n<blockquote>\n<p id=\"so_31269660_31269660_2\">Error C2146   syntax error: missing ';' before identifier 'i2'</p>\n</blockquote>\n<p>Can anyone point to the part of the standard that invalidates my expectation?</p>\n<hr>\n<p>UPDATE</p>\n<p>My point is that, as far as I understand the grammar in [dcl.type], </p>\n<pre><code>type-specifier:\n    trailing-type-specifier\n    class-specifier\n    enum-specifier\ntrailing-type-specifier:\n    simple-type-specifier\n    elaborated-type-specifier\n    typename-specifier\n    cv-qualifier\ntype-specifier-seq:\n    type-specifier attribute-specifier-seq opt\n    type-specifier type-specifier-seq\ntrailing-type-specifier-seq:\n    trailing-type-specifier attribute-specifier-seq opt\n    trailing-type-specifier trailing-type-specifier-seq\n</code></pre>\n<p>a decl-specifier-seq does allow for a sequence of type specifiers as long as they satisfy the combination rules. It seems to me that a type is not the same as a type-specifier even though a type is specified by a type specifier ;-)</p>\n</hr>", "AcceptedAnswerId": "31270598", "Title": "The meaning of synonym in typedef", "CreationDate": "2015-07-07T13:17:11.893", "Id": "31269660", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-07T13:32:26.200", "LastEditorUserId": "2549876", "LastActivityDate": "2015-07-07T14:05:11.380", "Score": "3", "OwnerUserId": "2549876", "Tags": "<c++><c++11><standards>", "AnswerCount": "3"}});