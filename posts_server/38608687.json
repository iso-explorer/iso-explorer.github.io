post_cb({"bq_ids": {"n4140": {"so_38608687_38609839_1": {"length": 15, "quality": 0.9375, "section_id": 5493}}, "n3337": {"so_38608687_38609839_1": {"length": 15, "quality": 0.9375, "section_id": 5279}}, "n4659": {"so_38608687_38609839_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 6924}, "so_38608687_38609839_1": {"length": 15, "quality": 0.9375, "section_id": 6927}}}, "38608687": {"ViewCount": "186", "Body": "<p>Consider this example:</p>\n<pre><code>struct B { operator int(); };\n\ntemplate&lt;class T&gt;\nstruct X:B\n{\n    using B::operator T;\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2602ae50955f3977\">GCC</a> accepts the code, while <a href=\"http://coliru.stacked-crooked.com/a/39685d409341de73\">Clang</a> and MSVC rejects it.\nWhich is correct?</p>\n<p>Note that if the base type is dependent, all the compilers accept the code:</p>\n<pre><code>template&lt;class T&gt;\nstruct B { operator T(); };\n\ntemplate&lt;class T&gt;\nstruct X:B&lt;T&gt;\n{\n    using B&lt;T&gt;::operator T;\n};\n</code></pre>\n", "AcceptedAnswerId": "38609839", "Title": "Is `using Base::operator T` allowed where `T` is a template type parameter?", "CreationDate": "2016-07-27T09:15:00.430", "Id": "38608687", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-07-27T11:27:10.040", "Score": "12", "OwnerUserId": "2969631", "Tags": "<c++><templates><conversion-operator><using-declaration>", "AnswerCount": "2"}, "38609693": {"Id": "38609693", "PostTypeId": "2", "Body": "<p>Hmm... Gcc does not like the first one either. It compiles unless you try to create instance of <code>struct X</code> with template parameter other than <code>int</code>. What would be the meaning of <code>X&lt;double&gt;::operator double()</code>? Class B does not have such an operator but we would try to use it.\n<br><br>\nTo sum up: MSVC and clang try to warn you beforehand (even if you don't do anything veeeery stupid right now) while gcc does produce an error only if you attempt to create something incorrect. This does not compile in gcc (5.3.0):</br></br></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct B { operator int(); };\n\ntemplate&lt;class T&gt;\nstruct X:B\n{\n    using B::operator T;\n};\n\nint main(int argc, char **argv)\n{\n    X&lt;char&gt; x;\n    std::cout &lt;&lt; \"Hello!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2016-07-27T09:58:21.527", "CommentCount": "10", "CreationDate": "2016-07-27T09:58:21.527", "ParentId": "38608687", "Score": "-1", "OwnerUserId": "2581119"}, "38609839": {"Id": "38609839", "PostTypeId": "2", "Body": "<p>I think GCC is right, in \u00a77.3.3/1, we can find:</p>\n<blockquote>\n<p id=\"so_38608687_38609839_0\">The set of declarations introduced by the using-declaration is found by performing qualified name lookup (3.4.3, 10.2) for the name in the using-declaration, excluding functions that are hidden as described below.</p>\n</blockquote>\n<p>I don't see any reason why <code>operator T</code> would not be found, actually:</p>\n<pre><code>template&lt;class T&gt;\nstruct X: B {\n    T f () { return B::operator T; }\n};\n</code></pre>\n<p>...compiles fine with g++ and clang (did not test on MSVC).</p>\n<p>I cannot find anything in the standard specific to conversion functionsfor qualified name lookup except:</p>\n<blockquote>\n<p id=\"so_38608687_38609839_1\">Since specializations of member templates for conversion functions are not found by name lookup, they are not considered when a using-declaration specifies a conversion function (14.5.2).</p>\n</blockquote>\n<p>But <code>B::operator int</code> is not a specialization of a member function template, so it should not be taken into account by the above.</p>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2016-07-27T11:27:10.040", "Score": "3", "CreationDate": "2016-07-27T10:04:35.577", "ParentId": "38608687", "CommentCount": "0", "OwnerUserId": "2666289", "LastEditDate": "2016-07-27T11:27:10.040"}});