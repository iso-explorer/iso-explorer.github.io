post_cb({"bq_ids": {"n4140": {"so_28622970_28623297_0": {"length": 56, "quality": 0.9333333333333333, "section_id": 6695}}, "n3337": {"so_28622970_28623297_0": {"length": 56, "quality": 0.9333333333333333, "section_id": 6450}}, "n4659": {"so_28622970_28623297_0": {"length": 56, "quality": 0.9333333333333333, "section_id": 8170}}}, "28623192": {"Id": "28623192", "PostTypeId": "2", "Body": "<p>Seems I found the answer. If we could get pointer of member function we can call it for other objects of type <code>A</code> (not <code>this</code>) which is not allowed.</p>\n<p>It is not allowed to call protected member function in derived classes for objects other than <code>this</code>. Getting pointer would violent that.</p>\n<p>We can do something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\nprotected:\n    void foo()\n    {}\n};\n\nclass B : public A {\npublic:\n    void bar()\n    {\n        void (A::*fptr)() = &amp;A::foo;\n\n        A obj;\n        (obj.*fptr)();\n\n        // obj.foo(); //this is not compiled too.    \n    }\n};\n\nint main()\n{\n    B b;\n    b.bar();\n}\n</code></pre>\n", "LastEditorUserId": "1356110", "LastActivityDate": "2015-02-20T06:58:53.687", "Score": "1", "CreationDate": "2015-02-20T06:52:02.253", "ParentId": "28622970", "CommentCount": "0", "LastEditDate": "2015-02-20T06:58:53.687", "OwnerUserId": "1356110"}, "28623252": {"Id": "28623252", "PostTypeId": "2", "Body": "<p>I was curious and tried the following example:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A {\npublic:\n    void foo()\n    {\n    }\n};\n\nclass B : public A {\npublic:\n    void bar()\n    {\n       printf(\"%p\\n\", (&amp;A::foo));\n       printf(\"%p\\n\", (&amp;B::foo));\n    }\n};\n\nint main()\n{\n    B b;\n    b.bar();\n}\n</code></pre>\n<p>Actually, I see that <code>&amp;A::foo</code> == <code>&amp;B::foo</code>, so for protected member of base class you can use derived class member to take address. I suppose in case of virtual functions this will not work </p>\n", "LastActivityDate": "2015-02-20T06:55:56.333", "CommentCount": "0", "CreationDate": "2015-02-20T06:55:56.333", "ParentId": "28622970", "Score": "1", "OwnerUserId": "4460500"}, "28622970": {"ViewCount": "968", "Body": "<pre><code>#include &lt;iostream&gt;\n\nclass A {\nprotected:\n    void foo()\n    {}\n};\n\nclass B : public A {\npublic:\n    void bar()\n    {\n       std::cout &lt;&lt; (&amp;A::foo) &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    B b;\n    b.bar();\n}\n</code></pre>\n<p>Here I am trying to get address of protected member function of base class. I am getting this error.</p>\n<pre><code>main.cpp: In member function \u2018void B::bar()\u2019:\nmain.cpp:5: error: \u2018void A::foo()\u2019 is protected\nmain.cpp:13: error: within this context\nmake: *** [all] Error 1\n</code></pre>\n<p>Changing foo to public works. Also printing <code>&amp;B::foo</code> works. Can you please explain why we can't get address of protected member function of base class?</p>\n", "AcceptedAnswerId": "28623297", "Title": "Protected member function address in derived class is not accessible", "CreationDate": "2015-02-20T06:34:41.737", "Id": "28622970", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-20T06:59:18.813", "Score": "7", "OwnerUserId": "1356110", "Tags": "<c++><inheritance><protected><member-function-pointers>", "AnswerCount": "3"}, "28623297": {"Id": "28623297", "PostTypeId": "2", "Body": "<p><code>B</code> is allowed to access protected members of <code>A</code> as long as the access is performed through an object of type <code>B</code>. In your example you're trying to access <code>foo</code> through <code>A</code>, and in that context it is irrelevant whether <code>B</code> derives from <code>A</code> or not.</p>\n<p>From N3337, <em>\u00a711.4/1 <strong>[class.protected]</strong></em></p>\n<blockquote>\n<p id=\"so_28622970_28623297_0\">An additional access check beyond those described earlier in Clause 11 is applied when a non-static data member or non-static member function is a protected member of its naming class (11.2) As described \n  earlier, <strong>access to a protected member is granted because the reference occurs in a friend or member of some class <code>C</code>. If the access is to form a pointer to member (5.3.1), the <em>nested-name-specifier</em> shall denote <code>C</code> or a\n  class derived from <code>C</code></strong>. All other accesses involve a (possibly implicit) object expression (5.2.5). In this case, the class of the object expression shall be <code>C</code> or a class derived from <code>C</code>. [<em>Example:</em></p>\n<pre><code> class B {\n protected:\n   int i;\n   static int j;\n };\n class D1 : public B {\n };\n class D2 : public B {\n   friend void fr(B*,D1*,D2*);\n   void mem(B*,D1*);\n };\n // ...\n void D2::mem(B* pb, D1* p1) {\n   // ...\n   int B::* pmi_B = &amp;B::i; // ill-formed\n   int B::* pmi_B2 = &amp;D2::i; // OK\n   // ...\n }\n // ...\n</code></pre>\n<p id=\"so_28622970_28623297_1\"><em>\u2014end example</em>]</p>\n</blockquote>\n<p>Your example is very similar to the code in <code>D2::mem</code>, which shows that trying to form a pointer to a protected member through <code>B</code> instead of <code>D2</code> is ill-formed.</p>\n", "LastActivityDate": "2015-02-20T06:59:18.813", "CommentCount": "2", "CreationDate": "2015-02-20T06:59:18.813", "ParentId": "28622970", "Score": "5", "OwnerUserId": "241631"}});