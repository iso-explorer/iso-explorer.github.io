post_cb({"43930343": {"ParentId": "43910170", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-05-12T06:02:22.133", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:47.663", "Id": "43930343", "OwnerUserId": "4832499", "Body": "<p>Let me give a quick fix to the code, as there is already a <a href=\"https://stackoverflow.com/questions/9094422/how-to-check-if-a-stdthread-is-still-running\">detailed post</a>, this will not be long.</p>\n<p>This answer exists because there are many wrong answers here.</p>\n<p>My interpretation of your problem is you want a \"watch thread\" to do work while other threads are still alive, but stop whenever others stop.</p>\n<pre><code>#include &lt;fstream&gt;\n#include &lt;thread&gt;\n#include &lt;atomic&gt;  // this is REQUIRED, NOT OPTIONAL\n\nusing namespace std;\n\natomic_int count(1);  // REQUIRED to be atomic\n\nvoid f1() {\n    ofstream f1out{\"f1out.txt\"};\n    f1out &lt;&lt; \"thread t1\" &lt;&lt; endl;\n    for (int i=0; i&lt;1000; ++i) {\n       f1out &lt;&lt; \"t1: \" &lt;&lt; i &lt;&lt; endl;\n    }\n    count--;\n}\n\nvoid f2() {\n    ofstream f2out{\"f2out.txt\"};\n    f2out &lt;&lt; \"thread t2\" &lt;&lt; endl;\n    while (count &gt; 0) {\n       f2out &lt;&lt; \"t1 still running\" &lt;&lt; endl;\n    }\n}\n\nint main() {\n    thread t1(f1);\n    thread t2(f2);\n\n    t1.join();\n    t2.join();\n}\n</code></pre>\n<h1>Notes on <code>atomic</code></h1>\n<p>The syntax of <code>atomic_int</code> might look like an <code>int</code> but <strong>they are different and failing to use <code>atomic_int</code> is undefined behaviour</strong>.</p>\n<p>From <a href=\"http://eel.is/c++draft/intro.races\" rel=\"nofollow noreferrer\">[intro.races]</a>, emphasis mine  </p>\n<blockquote>\n<p id=\"so_43910170_43930343_0\">Two expression evaluations conflict if one of them modifies a memory location and the other one reads or modifies the same memory location. [...]</p>\n<p id=\"so_43910170_43930343_1\">The execution of a program contains a data race if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other [...] . <strong>Any such data race results in undefined behavior</strong>.</p>\n</blockquote>\n<h1>Notes on <code>cout</code></h1>\n<p>Likewise, <strong>it is a data race if the threads use <code>cout</code> concurrently</strong>, I can't find a simple replacement to preserve the meaning and effect. I opt into using <code>ofstream</code> in the end.</p>\n<h3>For people concerned</h3>\n<p>Yes, the atomic operations need not be sequentially consistent but that really doesn't help with clarity.</p>\n", "LastActivityDate": "2017-05-12T06:09:07.050"}, "43910328": {"ParentId": "43910170", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-05-11T08:31:15.817", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:03:02.317", "Id": "43910328", "OwnerUserId": "7890197", "Body": "<p>This <a href=\"https://stackoverflow.com//questions/9094422/how-to-check-if-a-stdthread-is-still-running\">link</a> might help you.\nAmongst a lot of solutions, one seems quite easy to implement : </p>\n<blockquote>\n<p id=\"so_43910170_43910328_0\">An easy solution is to have a boolean variable that the thread sets to true on regular intervals, and that is checked and set to false by the thread wanting to know the status. If the variable is false for to long then the thread is no longer considered active.<br>\n  A more thread-safe way is to have a counter that is increased by the child thread, and the main thread compares the counter to a stored value and if the same after too long time then the child thread is considered not active.</br></p>\n</blockquote>\n<p>May be you could set an array of boolean, one by thread you run, and then check it whenever you want to know if other threads are running ?</p>\n", "LastActivityDate": "2017-05-11T08:31:15.817"}, "43910504": {"ParentId": "43910170", "CommentCount": "10", "CreationDate": "2017-05-11T08:39:23.660", "OwnerUserId": "1695172", "PostTypeId": "2", "Id": "43910504", "Score": "2", "Body": "<p>You can just use a flag for it (<a href=\"http://cpp.sh/2h32m\" rel=\"nofollow noreferrer\">running example</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nbool T1_IS_RUNNING = true;\nvoid f1() {\n    cout &lt;&lt; \"thread t1\" &lt;&lt; endl;\n    for (int i=0; i&lt;1000; ++i) {\n       cout &lt;&lt; \"t1: \" &lt;&lt; i &lt;&lt; endl;\n    }\n    T1_IS_RUNNING = false;\n    cout &lt;&lt; \"thread t1 finish\" &lt;&lt; endl;\n}\n\nvoid f2() {\n    cout &lt;&lt; \"thread t2\" &lt;&lt; endl;\n    while (T1_IS_RUNNING) {\n       cout &lt;&lt; \"t1 still running\" &lt;&lt; endl;\n    }   \n    cout &lt;&lt; \"thread t2 finish\" &lt;&lt; endl;\n}\n\nint main() {\n    thread t1(f1);\n    thread t2(f2);\n\n    t1.join();\n    t2.join();\n\n    return 0;\n}\n</code></pre>\n<p>This is safe as long as only one of them writes the flag and the other reads it, otherwise you need to use an atomic flag, a mutex or a semaphore.</p>\n", "LastActivityDate": "2017-05-11T08:39:23.660"}, "43910170": {"CommentCount": "2", "ViewCount": "94", "PostTypeId": "1", "LastEditorUserId": "3467894", "CreationDate": "2017-05-11T08:24:03.450", "LastActivityDate": "2017-05-12T06:09:07.050", "Title": "How to find out if other threads are running?", "FavoriteCount": "0", "LastEditDate": "2017-05-11T08:56:46.020", "Id": "43910170", "Score": "0", "Body": "<p>I have a \"watch thread\" which checks whether other threads are running and calculates some data. If these threads end I want to finish my watch thread, too. How can I do it?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nvoid f1() {\n    cout &lt;&lt; \"thread t1\" &lt;&lt; endl;\n    for (int i=0; i&lt;1000; ++i) {\n       cout &lt;&lt; \"t1: \" &lt;&lt; i &lt;&lt; endl;\n    }   \n}\n\nvoid f2() {\n    cout &lt;&lt; \"thread t2\" &lt;&lt; endl;\n    while (T1_IS_RUNNING) {\n       cout &lt;&lt; \"t1 still running\" &lt;&lt; endl;\n    }   \n}\n\nint main() {\n    thread t1(f1);\n    thread t2(f2);\n\n    t1.join();\n    t2.join();\n\n    return 0;\n}\n</code></pre>\n<p>In the example above I need to implement <em>T1_IS_RUNNING</em>. Any ideas how to do it? My guess is to get number of running threads but I haven't found any related method in STL.</p>\n<p>There is a <a href=\"https://stackoverflow.com/questions/9094422/how-to-check-if-a-stdthread-is-still-running\">How to check if a std::thread is still running?</a> already, but I think they use too complicated solutions for my case. Isn't a simple thread counter (std::atomic) good enough?</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "3467894", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_43910170_43930343_1": {"section_id": 5834, "quality": 0.88, "length": 22}, "so_43910170_43930343_0": {"section_id": 5817, "quality": 0.875, "length": 14}}, "n3337": {"so_43910170_43930343_1": {"section_id": 5605, "quality": 0.8, "length": 20}, "so_43910170_43930343_0": {"section_id": 5588, "quality": 0.875, "length": 14}}, "n4659": {"so_43910170_43930343_1": {"section_id": 7296, "quality": 0.88, "length": 22}, "so_43910170_43930343_0": {"section_id": 7278, "quality": 0.9375, "length": 15}}}, "43925322": {"ParentId": "43910170", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-05-11T20:52:28.390", "Score": "1", "LastEditorUserId": "7902545", "LastEditDate": "2017-05-11T21:29:36.990", "Id": "43925322", "OwnerUserId": "7902545", "Body": "<p>With atomic_int:</p>\n<pre><code>int main(){\n    std::atomic_int poor_man_semaphore{0};\n    poor_man_semaphore++;\n    std::thread t1([&amp;]()\n    {\n        std::this_thread::sleep_for(std::chrono::seconds(100));\n        poor_man_semaphore--;\n    });\n    poor_man_semaphore++;\n    std::thread t2([&amp;]()\n    {\n         std::this_thread::sleep_for(std::chrono::seconds(1));\n         poor_man_semaphore--;\n    });\n    poor_man_semaphore++;\n    std::thread t3([&amp;]()\n    {\n         std::this_thread::sleep_for(std::chrono::seconds(1));\n         poor_man_semaphore--;\n    });\n\n    t2.join();\n    t3.join();\n    while ( poor_man_semaphore &gt; 0 )\n    {\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n\n    }\n    t1.join();\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2017-05-11T21:29:36.990"}});