post_cb({"36845264": {"ParentId": "36843514", "CommentCount": "0", "Body": "<p>AFAIK, there are no portable way to know what duration type a variable uses by simply knowing its address. But provided all your dynamic allocations use <code>new</code> you could use your own <em>replacement functions</em> for the different signatures of <code>operator new</code> and <code>operator delete</code>, and use them to manage a map or a set of all allocations. Reference in current C++ standard draft n4296:</p>\n<blockquote>\n<p id=\"so_36843514_36845264_0\">17.6.4.6 Replacement functions [replacement.functions]</p>\n<p id=\"so_36843514_36845264_1\">...<br/>\n  A C++ program may provide the definition for any of twelve dynamic memory allocation function signatures\n  declared in header &lt;new&gt; (3.7.4, 18.6):</p>\n<ul>\n<li>operator new(std::size_t)</li>\n<li>operator new(std::size_t, const std::nothrow_t&amp;)</li>\n<li>operator new</li>\n<li>operator new[](std::size_t, const std::nothrow_t&amp;)</li>\n<li>operator delete(void*)</li>\n<li>operator delete(void*, const std::nothrow_t&amp;)</li>\n<li>operator delete</li>\n<li>operator delete[](void*, const std::nothrow_t&amp;)</li>\n<li>operator delete(void*, std::size_t)</li>\n<li>operator delete(void*, std::size_t, const std::nothrow_t&amp;)</li>\n<li>operator delete[](void*, std::size_t)</li>\n<li>operator delete[](void*, std::size_t, const std::nothrow_t&amp;)</li>\n</ul>\n<p id=\"so_36843514_36845264_2\">The program\u2019s definitions are used instead of the default versions supplied by the implementation (18.6).\n  Such replacement occurs prior to program startup (3.2, 3.6). The program\u2019s declarations shall not be\n  specified as inline. No diagnostic is required.</p>\n</blockquote>\n<p>That would allow you to build a kind of <em>hand made</em> valgrind and store for example in an array - usage of standard containers inside operator new could be tedious because they do use operator new! - the list of allocated blocks. At a simple level something like that could help:</p>\n<pre><code>// use a SZ value big enough for your program...\n#define SZ 1000\nstruct Alloc {\n    void *p;\n    size_t size;\n} alloc[SZ];\n\nbool inited = false;\n\nvoid * operator new(size_t s) {\n    void * p = malloc(s);\n    if (p != NULL) {\n        // fprintf(stderr, \"Allocate %d at %p\\n\", s, p); // for debug\n        for (int i=0; i&lt;SZ; i++) {\n            if (alloc[i].p == NULL) {\n                alloc[i].p = p;\n                alloc[i].size = s;\n                break;\n            }\n        }\n    }\n    return p;\n}\n\nvoid operator delete(void *p) {\n    size_t s = 0;\n    if (p != NULL) {\n        for (int i=0; i&lt;SZ; i++) {\n            if (alloc[i].p == p) {\n                s = alloc[i].size;\n                alloc[i].p = NULL;\n                break;\n            }\n        }\n        free(p);\n    }\n    // fprintf(stderr,\"De-allocate %p (%d)\\n\", p, s); // for debug\n}\n</code></pre>\n<p>Note that I deliberately use C stdio functions for debugging traces to avoid any possibility of C++ allocation memory calls in C++ standard library io.</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "36845264", "Score": "2", "CreationDate": "2016-04-25T15:45:22.883", "LastActivityDate": "2016-04-25T15:45:22.883"}, "36843514": {"CommentCount": "2", "ViewCount": "64", "PostTypeId": "1", "LastEditorUserId": "4774918", "CreationDate": "2016-04-25T14:29:28.517", "LastActivityDate": "2016-04-25T15:45:22.883", "Title": "Check if a pointer points to statically allocated object?", "LastEditDate": "2016-04-25T14:30:23.780", "Id": "36843514", "Score": "0", "Body": "<p>I have implemented some leak detector of QObjects. To make long story short, During the removing of static objects I check what QObject was not removed.\nBut the problem is that some QObject is allocated staticly so I need to remove them from leak report.\nIs there are way to know if pointer points to statically allocated object?</p>\n", "Tags": "<c++><qt>", "OwnerUserId": "3376063", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36843514_36845264_1": {"section_id": 6317, "quality": 0.8571428571428571, "length": 12}, "so_36843514_36845264_2": {"section_id": 6318, "quality": 0.8095238095238095, "length": 17}}, "n3337": {"so_36843514_36845264_1": {"section_id": 6074, "quality": 0.7857142857142857, "length": 11}, "so_36843514_36845264_2": {"section_id": 6075, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_36843514_36845264_1": {"section_id": 7827, "quality": 0.7857142857142857, "length": 11}, "so_36843514_36845264_2": {"section_id": 7828, "quality": 0.8571428571428571, "length": 18}}}});