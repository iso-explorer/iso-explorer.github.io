post_cb({"24020013": {"ParentId": "24018932", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_24018932_24020013_0\">Which compiler is correct in its interpretation of the standard?</p>\n</blockquote>\n<p><code>gcc</code> is incorrect. \u00a79.4.2/3:</p>\n<blockquote>\n<p id=\"so_24018932_24020013_1\">A static data member of literal type can be declared in the class\n  definition with the constexpr specifier; if so, its declaration shall\n  specify a brace-or-equal-initializer in which every initializer-clause\n  that is an assignment-expression is a constant expression. <strong>The member\n  shall still be defined in a namespace scope <em>if it is odr-used</em></strong> (3.2) in\n  the program and the namespace scope definition shall not contain an\n  initializer.</p>\n</blockquote>\n<p>And the name is not odr-used as per \u00a73.2:</p>\n<blockquote>\n<p id=\"so_24018932_24020013_2\">A variable whose name appears as a potentially-evaluated expression is\n  <em>odr-used</em> <strong>unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue\n  conversion (4.1) is immediately applied</strong>.</p>\n</blockquote>\n<p>This is indeed the case: It does satisfy the requirements for appearing in a constant expression and the lvalue-to-rvalue conversion is immediately applied (it is used as an initializer for an object). So GCC's rejection is incorrect.</p>\n<hr>\n<p>A possible workaround is to define the member (but without a placeholder type). This definition is sufficient for both Clang and GCC:</p>\n<pre><code>template&lt; typename T &gt;\nconstexpr decltype(a) foo&lt;T&gt;::value;\n</code></pre>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-10-29T12:34:57.470", "Id": "24020013", "Score": "8", "CreationDate": "2014-06-03T16:13:42.980", "LastActivityDate": "2015-10-29T12:34:57.470"}, "24018932": {"CommentCount": "3", "AcceptedAnswerId": "24019645", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2014-06-03T15:20:28.007", "LastActivityDate": "2016-03-17T10:35:44.830", "LastEditDate": "2016-03-17T10:35:44.830", "ViewCount": "2405", "FavoriteCount": "3", "Title": "`static constexpr auto` data-member initialized with unnamed enum", "Id": "24018932", "Score": "26", "Body": "<p>I was working on a C++11 project solely using <code>clang++-3.4</code>, and decided to compile using <code>g++-4.8.2</code> in case there were any discrepancies in the errors produced. It turned out that g++ rejects some code that clang++ accepts. I have reduced the problem to the MWE given below.</p>\n<hr>\n<pre><code>enum { a };\n\ntemplate &lt;class T&gt;\nstruct foo\n{\n    static constexpr auto value = a;\n};\n\nint main()\n{\n    static constexpr auto r = foo&lt;int&gt;::value;\n}\n</code></pre>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_24018932_24018932_0\">foo.cpp:5:23: error: \u2018<code>const&lt;anonymous enum&gt; foo&lt;int&gt;::value</code>\u2019, declared using anonymous type, is used but never defined [-fpermissive]</p>\n<pre><code>static const auto value = A;\n</code></pre>\n</blockquote>\n<hr>\n<p>I would like some help answering the following two questions:</p>\n<ul>\n<li><p>Which compiler is correct in its interpretation of the standard? I am assuming that one compiler is right in either accepting or rejecting the code, and the other is wrong.</p></li>\n<li><p>How can I work around this issue? I can't name the anonymous enum, because it is from a third-party library (in my case, the enums were <code>Eigen::RowMajor</code> and <code>Eigen::ColMajor</code>).</p></li>\n</ul>\n</hr></hr>", "Tags": "<c++><c++11><enums><language-lawyer><auto>", "OwnerUserId": "414271", "AnswerCount": "3"}, "24019645": {"ParentId": "24018932", "PostTypeId": "2", "CommentCount": "4", "Body": "<h2>Who's to blame?</h2>\n<p><em>GCC</em>  is inaccurately rejecting your snippet, it is legal according to the <em>C++11</em> Standard (N3337). Quotations with proof and explanation is located the end of this post.</p>\n<p><strong>workaround (A)</strong> - <em>add the missing definition</em></p>\n<pre><code>template &lt;class T&gt;\nstruct foo {\n    static constexpr auto value = a;\n    typedef decltype(a) value_type;\n};\n\ntemplate&lt;class T&gt;\nconstexpr typename foo&lt;T&gt;::value_type foo&lt;T&gt;::value;\n</code></pre>\n<p><br/></p>\n<p><strong>workaround (B)</strong> - <em>use the underlying-type of the enumeration as placeholder</em></p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;class T&gt;\nstruct foo {\n  static const std::underlying_type&lt;decltype(a)&gt;::type value = a;\n};\n</code></pre>\n<hr>\n<h2>What does the Standard say?  (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3337.pdf\" rel=\"nofollow\">N3337</a>)</h2>\n<p>As stated, the snippet is legal <em>C++11</em>, as can be read in the following quoted sections.</p>\n<hr>\n<p><strong>When can we use a type without linkage?</strong></p>\n<p><code>[basic.link]p8</code> has detailed wording that describes when a type is <em>\"without linkage\"</em>, and it states that an unnamed enumeration count as such type.</p>\n<p><code>[basic.link]p8</code> also explicitly states three contexts where such a type cannot be used, but not one of the contexts apply to our usage, so we are safe. </p>\n<blockquote>\n<blockquote>\n<p id=\"so_24018932_24019645_1\">A type without linkage shall not be used as the type of a variable or function with external linkage unless</p>\n<ul>\n<li>the entity has C language linkage (7.5), or</li>\n<li>the entity is declared within an unnamed namespace (7.3.1), or</li>\n<li>the entity is not <a href=\"http://en.wikipedia.org/wiki/One_Definition_Rule\" rel=\"nofollow\">odr-used</a> (3.2) or is defined in the same translation unit</li>\n</ul>\n</blockquote>\n</blockquote>\n<p><br/></p>\n<h3>Are you sure we can use <code>auto</code> in such context?</h3>\n<p>Yes, and this can be proven by the following quote:</p>\n<blockquote>\n<p id=\"so_24018932_24019645_2\"><code>7.1.6.4p</code> <b><code>auto</code> specifier</b> <code>[dcl.spec.auto]</code></p>\n<blockquote>\n<p id=\"so_24018932_24019645_4\">A <code>auto</code> <em>type-specifier</em> can also be used in declaring a variable in the condition of a selection statement (6.4) or an iteration statement (6.5), in the <em>type-specifier-seq</em> in the <em>new-type-id</em> or <em>type-id</em> of a <em>new-expression</em> (5.3.4), in a <em>for-range-declaration</em>, and in declaring a static data member with a <em>brace-or-equal-initializer</em> that appears within the <em>member-specification</em> of a class definition (9.4.2).</p>\n</blockquote>\n</blockquote>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2014-06-09T19:52:03.780", "Id": "24019645", "Score": "13", "CreationDate": "2014-06-03T15:55:53.620", "LastActivityDate": "2014-06-09T19:52:03.780"}, "bq_ids": {"n4140": {"so_24018932_24019645_4": {"section_id": 5449, "quality": 0.6428571428571429, "length": 18}, "so_24018932_24019645_0": {"section_id": 7141, "quality": 1.0, "length": 7}, "so_24018932_24019645_1": {"section_id": 7141, "quality": 1.0, "length": 7}, "so_24018932_24020013_2": {"section_id": 7040, "quality": 0.5555555555555556, "length": 10}, "so_24018932_24020013_1": {"section_id": 5908, "quality": 0.96875, "length": 31}, "so_24018932_24019645_3": {"section_id": 5449, "quality": 0.6428571428571429, "length": 18}}, "n3337": {"so_24018932_24019645_4": {"section_id": 5243, "quality": 0.6785714285714286, "length": 19}, "so_24018932_24019645_0": {"section_id": 6885, "quality": 1.0, "length": 7}, "so_24018932_24019645_1": {"section_id": 6885, "quality": 1.0, "length": 7}, "so_24018932_24020013_2": {"section_id": 6785, "quality": 0.8888888888888888, "length": 16}, "so_24018932_24020013_1": {"section_id": 5680, "quality": 0.96875, "length": 31}, "so_24018932_24019645_3": {"section_id": 5243, "quality": 0.6785714285714286, "length": 19}}, "n4659": {"so_24018932_24020013_1": {"section_id": 7390, "quality": 0.75, "length": 24}, "so_24018932_24020013_2": {"section_id": 8537, "quality": 0.5555555555555556, "length": 10}, "so_24018932_24019645_1": {"section_id": 8642, "quality": 1.0, "length": 7}, "so_24018932_24019645_0": {"section_id": 8642, "quality": 1.0, "length": 7}}}, "24019036": {"ParentId": "24018932", "CommentCount": "1", "Body": "<p>Workaround with <code>decltype</code>:</p>\n<pre><code>enum { a };\n\ntemplate &lt;class T&gt;\nstruct foo\n{\n    static constexpr auto value = a;\n};\n\ntemplate &lt;class T&gt;\nconstexpr decltype(a) foo&lt;T&gt;::value;\n\nint main()\n{\n    static constexpr auto r = foo&lt;int&gt;::value;\n}\n</code></pre>\n", "OwnerUserId": "680982", "PostTypeId": "2", "Id": "24019036", "Score": "4", "CreationDate": "2014-06-03T15:25:17.647", "LastActivityDate": "2014-06-03T15:25:17.647"}});