post_cb({"2114807": {"Id": "2114807", "PostTypeId": "2", "Body": "<p>You can't specialize a member function without explicitly specializing the containing class.<br>\nWhat you can do however is forward calls to a member function of a partially specialized type:</br></p>\n<pre><code>template&lt;class T, class Tag&gt;\nstruct helper {\n    static void f(T);   \n};\n\ntemplate&lt;class T&gt;\nstruct helper&lt;T, tag1&gt; {\n    static void f(T) {}\n};\n\ntemplate&lt;class T&gt;\nstruct C {\n    // ...\n    template&lt;class Tag&gt;\n    void foo(T t) {\n        helper&lt;T, Tag&gt;::f(t);\n    }\n};\n</code></pre>\n", "LastEditorUserId": "168225", "LastActivityDate": "2010-01-22T04:48:52.927", "Score": "25", "CreationDate": "2010-01-22T03:47:54.160", "ParentId": "2097811", "CommentCount": "2", "OwnerUserId": "168225", "LastEditDate": "2010-01-22T04:48:52.927"}, "2097975": {"Id": "2097975", "PostTypeId": "2", "Body": "<p>I know this may not satisfy you, but I do not believe you may not have a specialization enclosed within a non-explicitly-specialized structure.</p>\n<pre><code>template&lt;&gt;\ntemplate&lt;&gt;\ninline void C&lt; tag1 &gt;::foo&lt; tag2 &gt;( t_type ) {}\n</code></pre>\n", "LastActivityDate": "2010-01-19T23:18:10.120", "CommentCount": "0", "CreationDate": "2010-01-19T23:18:10.120", "ParentId": "2097811", "Score": "0", "OwnerUserId": "20713"}, "2098016": {"Id": "2098016", "PostTypeId": "2", "Body": "<p>GCC is in the clear, here. MSVC has a non-standard extension that allows in-class specialization. The standard, however, says:</p>\n<blockquote>\n<p id=\"so_2097811_2098016_0\">14.7.3.2:<br>\n  2. An explicit specialization shall be declared in the namespace of\n  which the template is a member, or, for member templates, in the\n  namespace of which the enclosing class or enclosing class template is\n  a member. An explicit specialization of a member function, member\n  class or static data member of a class template shall be declared in\n  the namespace of which the class template is a member. </br></p>\n</blockquote>\n<p>Additionally, you can't partially specialize a function. (Though I'm unsure about the details in your case, that would be the final blow.)</p>\n<p>You <em>could</em> do this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct true_type {};\nstruct false_type {};\n\ntemplate &lt;typename T, typename U&gt;\nstruct is_same : false_type\n{\n    static const bool value = false;\n};\n\ntemplate &lt;typename T&gt;\nstruct is_same&lt;T, T&gt; : true_type\n{\n    static const bool value = true;\n};\n\nstruct tag1 {};\nstruct tag2 {};\n\ntemplate&lt; typename T &gt;\nstruct C\n{\n    typedef T t_type;\n\n    template&lt; typename Tag &gt;\n    void foo( t_type pX)\n    {\n        foo_detail( pX, is_same&lt;Tag, tag1&gt;() );\n    }\n\nprivate:\n    void foo_detail( t_type, const true_type&amp; )\n    {\n        std::cout &lt;&lt; \"In tag1 version.\" &lt;&lt; std::endl;\n    }\n    void foo_detail( t_type, const false_type&amp; )\n    {\n        std::cout &lt;&lt; \"In not tag1 version.\" &lt;&lt; std::endl;\n    }\n};\n\nint main(void)\n{\n    C&lt;int&gt; c;\n    c.foo&lt;tag1&gt;(int());\n    c.foo&lt;tag2&gt;(int());\n    c.foo&lt;double&gt;(int());\n}\n</code></pre>\n<p>Though this is somewhat ugly.</p>\n", "LastActivityDate": "2010-01-19T23:28:27.613", "CommentCount": "1", "CreationDate": "2010-01-19T23:28:27.613", "ParentId": "2097811", "Score": "7", "OwnerUserId": "87234"}, "2097811": {"ViewCount": "16175", "Body": "<p>I have code which works in VC9 (Microsoft Visual C++ 2008 SP1) but not in GCC 4.2 (on Mac):</p>\n<pre><code>struct tag {};\n\ntemplate&lt; typename T &gt;\nstruct C\n{   \n    template&lt; typename Tag &gt;\n    void f( T );                 // declaration only\n\n    template&lt;&gt;\n    inline void f&lt; tag &gt;( T ) {} // ERROR: explicit specialization in\n};                               // non-namespace scope 'structC&lt;T&gt;'\n</code></pre>\n<p>I understand that GCC would like me to move my explicit specialization outside the class but I can't figure out the syntax.  Any ideas?</p>\n<pre><code>// the following is not correct syntax, what is?\ntemplate&lt; typename T &gt;\ntemplate&lt;&gt;\ninline void C&lt; T &gt;::f&lt; tag &gt;( T ) {}\n</code></pre>\n", "AcceptedAnswerId": "2114807", "Title": "C++ syntax for explicit specialization of a template function in a template class?", "CreationDate": "2010-01-19T22:49:37.153", "Id": "2097811", "CommentCount": "0", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2010-01-24T20:41:07.547", "LastEditorUserId": "10559", "LastActivityDate": "2016-01-05T13:11:40.063", "Score": "28", "OwnerUserId": "10559", "Tags": "<c++><templates><gcc>", "AnswerCount": "4"}, "2097830": {"Id": "2097830", "PostTypeId": "2", "Body": "<p>Try this:</p>\n<pre><code>template &lt;&gt; template&lt;typename T&gt; inline void C&lt;T&gt; :: foo&lt;tag2&gt;(T) {}\n</code></pre>\n", "LastEditorUserId": "234053", "LastActivityDate": "2010-01-19T23:15:00.670", "Score": "1", "CreationDate": "2010-01-19T22:52:52.263", "ParentId": "2097811", "CommentCount": "3", "OwnerUserId": "234053", "LastEditDate": "2010-01-19T23:15:00.670"}, "bq_ids": {"n4140": {"so_2097811_2098016_0": {"length": 18, "quality": 0.5625, "section_id": 150}}, "n3337": {"so_2097811_2098016_0": {"length": 18, "quality": 0.5625, "section_id": 144}}, "n4659": {"so_2097811_2098016_0": {"length": 18, "quality": 0.5625, "section_id": 154}}}});