post_cb({"3617866": {"CommentCount": "3", "AcceptedAnswerId": "3618000", "PostTypeId": "1", "LastEditorUserId": "14065", "CreationDate": "2010-09-01T12:15:53.503", "LastActivityDate": "2014-05-02T10:01:41.917", "LastEditDate": "2010-09-01T12:24:40.860", "ViewCount": "812", "FavoriteCount": "2", "Title": "3.4.1 Unqualified name lookup", "Id": "3617866", "Score": "3", "Body": "<p>According to C++ standard :-</p>\n<blockquote>\n<p id=\"so_3617866_3617866_0\">The name lookup rules apply uniformly to all names (including typedef-names (7.1.3), namespace-names (7.3), concept-names (14.9), concept-map-names (14.9.2), and class-names (9.1)) wherever the grammar allows such names in the context discussed by a particular rule.</p>\n</blockquote>\n<p>Name lookup rules apply Before Overload resolution takes place?</p>\n<p><strong>There must be some reason behind that I do not understand.</strong></p>\n<p><strong>Following example is from Book C++ in a Nutshell :-</strong></p>\n<pre><code>void func(int i)\n{\n  std::cout &lt;&lt; \"int: \" &lt;&lt; i &lt;&lt; '\\n';\n}\n\n\n\nnamespace N \n{\n  void func(double d)\n  {\n    std::cout &lt;&lt; \"double: \" &lt;&lt; std::showpoint &lt;&lt; d &lt;&lt; '\\n';\n  }\n\n  void call_func(  )\n  {\n    // Even though func(int) is a better match, the compiler finds\n    // N::func(double) first.\n    func(3);\n  }\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "434946", "AnswerCount": "3"}, "23425463": {"ParentId": "3617866", "CommentCount": "0", "Body": "<p>Name-look up operates before the overload resolution. For the compiler to know 'which function is called', it operates in this order</p>\n<ul>\n<li>Name look-up</li>\n<li>Template Arguments Resolution</li>\n<li>Overload Resolution</li>\n<li>Access Control</li>\n<li>Virtual Functions</li>\n</ul>\n<p>For the why, you may refer to <a href=\"https://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8l.doc%2Flanguage%2Fref%2Fcplr315.htm\" rel=\"nofollow\">https://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8l.doc%2Flanguage%2Fref%2Fcplr315.htm</a> and to Channel 9 courses <a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-1-of-n\" rel=\"nofollow\">http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-1-of-n</a> .</p>\n<p>In fact, Overload-Resolution comes down to the choice of the most viable function, that is the search for the most appropriate function declaration corresponding to a function call.</p>\n<p>This search based on the number of function parameters, and then on the 'implicit conversion sequence' occurs in a set of pre-selected functions. If call to be resolved is <code>f()</code>, this set contains all functions with name <code>f()</code> that are visible from a certain point in the code. This set is determined by Name Look-Up.</p>\n", "OwnerUserId": "1141493", "PostTypeId": "2", "Id": "23425463", "Score": "0", "CreationDate": "2014-05-02T10:01:41.917", "LastActivityDate": "2014-05-02T10:01:41.917"}, "3617999": {"ParentId": "3617866", "CommentCount": "3", "Body": "<p>Yes. Name lookup attempts to find all names visible at the point of usage. Once the entire superset of declarations of the name is built up, overload resolution is done in case the name is determined to be the name of a function. The name lookup ends if a matching name is found else fails.</p>\n<p>If name lookup succeeds and if the name is determined to the name of a function, overload resolution is done to find the best viable function if any. Subsequently acess check is done to find out if the name is indeed accessible in the context of the access.</p>\n<p>Note that visibility of the name is important for name lookup and not accessibility.</p>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3617999", "Score": "1", "CreationDate": "2010-09-01T12:33:05.673", "LastActivityDate": "2010-09-01T12:33:05.673"}, "bq_ids": {"n4140": {"so_3617866_3617866_0": {"section_id": 7083, "quality": 0.7692307692307693, "length": 20}}, "n3337": {"so_3617866_3617866_0": {"section_id": 6827, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_3617866_3617866_0": {"section_id": 8584, "quality": 0.7692307692307693, "length": 20}}}, "3618000": {"ParentId": "3617866", "CommentCount": "0", "Body": "<p>If I am working in namespace N.<br>\nI just wrote a function called <code>func()</code> then I write some code to call this new function. It would seem counter intuitive for it to choose a function from another namespace before it used the function I just wrote.</br></p>\n<h3>Now consider the situation is reversed.</h3>\n<p>(ie. It uses overload resolution)</p>\n<p>I write a function <code>bob(double)</code>. It works perfectly as there is no conflict with a `bob(double) in the global namespace. I write my code and the application works perfectly.</p>\n<p>A year later somebody writes a function <code>bob(int)</code> in the global namespace and re-compiles the application. Suddenly with no change in my code. All my calls to <code>bob(5)</code> have been redirected to the <code>bob(int)</code> in the global namespace.   </p>\n<p>This is highly undesirable way for the application to work.</p>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "3618000", "Score": "9", "CreationDate": "2010-09-01T12:33:13.257", "LastActivityDate": "2010-09-01T12:33:13.257"}});