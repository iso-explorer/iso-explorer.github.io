post_cb({"2038534": {"ParentId": "2038453", "LastEditDate": "2010-01-11T02:36:15.830", "CommentCount": "2", "CreationDate": "2010-01-10T20:42:52.590", "OwnerUserId": "238128", "LastEditorUserId": "238128", "PostTypeId": "2", "Id": "2038534", "Score": "15", "Body": "<p>The iterators for set and multiset were changed from the standard iterator/const iterator pair to just being const iterators. The reason for this change was that they are ordered containers, and changing the element inside of an iterator can actually invalidate this ordering constraint.</p>\n<p>The version of GCC you're testing against has made this change, the version of VC that you're using has not. VC10 (and VC9 SP1, I believe) always return const_iterators from sets and multisets.</p>\n<p>23.2.4/6 of the latest draft of C++1x (n3000.pdf at the moment) says </p>\n<blockquote>\n<p id=\"so_2038453_2038534_0\">For associative containers where the\n  value type is the same as the key\n  type, both iterator and const_iterator\n  are constant iterators.</p>\n</blockquote>\n<p>std::set and std::multi_set are the associative containers where the value type is the same as the key type.</p>\n", "LastActivityDate": "2010-01-11T02:36:15.830"}, "2038453": {"CommentCount": "1", "ViewCount": "1171", "LastActivityDate": "2011-02-13T11:57:24.977", "Body": "<p>I recently ran into an odd issue where I'd get a <code>const_iterator</code> instead of the expected <code>iterator</code> when iterating through a multiset. It turned out to be a non-issue for MSVC but g++ gave me an error:</p>\n<blockquote>\n<p id=\"so_2038453_2038453_0\">error: invalid initialization of\n  reference of type 'myPtr&amp;' from\n  expression of type 'const\n  boost::shared_ptr'</p>\n</blockquote>\n<p>Relevant code:</p>\n<pre><code>typedef std::multiset&lt;myPtr&gt; myList;\nmyList _mystuff;\nvoid tick(float dt)\n{\n    for (myList::iterator i = _mystuff.begin(); i != _mystuff.end(); ++i)\n    {\n        myPtr &amp;mine = *i; // g++ problem here, not for MSVC\n        // const myPtr &amp;mine = *i; works fine for g++\n        mine-&gt;tick(dt);\n    }\n}\n</code></pre>\n<p>Quite a bit of research revealed that is a problem with lots of previous discussion. I found these relevant bits:</p>\n<ul>\n<li><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14990\" rel=\"noreferrer\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14990</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#322</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#103</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#279</a></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#528</a></li>\n</ul>\n<p>My background knowledge and grasp on the issue is limited and thus I'd like to know whether the standard doesn't define this behavior well enough in which case g++ and MSVC implement the behavior to their liking or whether either g++ or MSVC deviate from a well-defined standard.</p>\n<p>Thanks in advance.</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "2038534", "FavoriteCount": "1", "Title": "C++ Standard: Unexpected const_iterator in multiset", "Id": "2038453", "Score": "7", "CreationDate": "2010-01-10T20:19:05.960", "Tags": "<c++><g++><visual-c++><standards>", "OwnerUserId": "161775", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_2038453_2038534_0": {"section_id": 742, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_2038453_2038534_0": {"section_id": 731, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_2038453_2038534_0": {"section_id": 800, "quality": 0.9285714285714286, "length": 13}}}, "4979442": {"ParentId": "2038453", "LastEditDate": "2011-02-13T11:57:24.977", "CommentCount": "2", "CreationDate": "2011-02-12T17:24:48.083", "OwnerUserId": "614398", "LastEditorUserId": "614398", "PostTypeId": "2", "Id": "4979442", "Score": "1", "Body": "<p>How to fool the compiler for std::set::iterator?</p>\n<p>I have struct</p>\n<pre><code>struct _item {\n  int a;\n  int b;\n  bool operator &lt;(const _item&amp; x) const {return a&lt;x.a;}\n};\n</code></pre>\n<p>I want change only member b (b is irrelevant for sorting in set, only member a is compared).</p>\n<pre><code>std::set&lt;_item&gt; data;\nstd::set&lt;_item&gt;::iterator iter=data.begin();\niter-&gt;b=0;  // error !!!\n</code></pre>\n<p>Avada Kedavra !</p>\n<pre><code>struct _item {\n  int a;\n  int b;\n  _item* self;\n  _item() {self=this;} \n  bool operator &lt;(const _item&amp; x) const {return a&lt;x.a;}\n};\niter-&gt;self-&gt;b=0; // Success !! Tested on VC10\n</code></pre>\n<p>Of course more C + + correctly</p>\n<pre><code>struct _item {\n  int a;\n  int b;\n private:\n  _item* self;\n public:\n  _item() {self=this;} \n  bool operator &lt;(const _item&amp; x) const {return a&lt;x.a;}\n  int&amp; bReference() const {return self-&gt;b;}\n};\nstd::set&lt;_item&gt; items;\nstd::set&lt;_item&gt;::iterator iter=items.begin();\niter-&gt;bReference()=0; // Success !! Tested on VC1\n</code></pre>\n", "LastActivityDate": "2011-02-13T11:57:24.977"}});