post_cb({"6890908": {"CommentCount": "0", "Body": "<p>There are two errors here:</p>\n<ol>\n<li>You can't <code>delete</code> a pointer that wasn't returned by <code>new</code>.</li>\n<li>You can't <code>delete</code> a pointer that was returned by <code>new[]</code> \u2014 you need to use <code>delete[]</code>.</li>\n</ol>\n<p>So, the first snippet works only by coincidence, and there is no error only because you're using a primitive type. If it were UDT, the destructors wouldn't run.</p>\n<p>Also, you should be using containers and smart pointers, instead of raw <code>new</code> and <code>delete</code>.</p>\n", "CreationDate": "2011-07-31T17:00:05.950", "ParentId": "6890883", "Id": "6890908", "LastActivityDate": "2011-07-31T17:00:05.950", "PostTypeId": "2", "Score": "3", "OwnerUserId": "16102"}, "6890899": {"CommentCount": "0", "Body": "<p>Because you changed what address <code>q</code> points at, and then tried to delete it.</p>\n<p>You should only <strong>ever</strong> try to <code>delete</code> whatever <code>new</code> returns to you. Anything else is undefined behavior.</p>\n", "CreationDate": "2011-07-31T16:58:31.080", "ParentId": "6890883", "Id": "6890899", "LastActivityDate": "2011-07-31T16:58:31.080", "PostTypeId": "2", "Score": "0", "OwnerUserId": "576139"}, "6890901": {"CommentCount": "0", "Body": "<p>Because you have to pass the <em>unaltered</em> result of new to delete. That is just how things work, i.e. the API contract of new/delete.</p>\n", "CreationDate": "2011-07-31T16:58:44.357", "ParentId": "6890883", "Id": "6890901", "LastActivityDate": "2011-07-31T16:58:44.357", "PostTypeId": "2", "Score": "1", "OwnerUserId": "635879"}, "6890929": {"LastActivityDate": "2011-09-17T06:00:34.540", "CreationDate": "2011-07-31T17:04:52.187", "CommentCount": "0", "Body": "<p>Your code is causing an <strong>Undefined Behavior</strong>. An Undefined Behavior means anything can happen, the behavior cannot be defined. The program works just by pure luck its behavior cannot be explained.</p>\n<p>Basically, </p>\n<p>If you are allocating dynamic memory with <code>new</code> you <strong>MUST</strong> use <code>delete</code> to deallocate it.</p>\n<p>If you are allocating dynamic memory with <code>new[]</code> you <strong>MUST</strong> use <code>delete[]</code> to deallocate it.</p>\n<p>It is undefined behavior to pass any address to <code>delete</code> which was not returned by <code>new</code>.<br>\nHere is the quote from the Standard.</br></p>\n<p>As per <strong>C++03 Standard \u00a7 3.7.4.2-3:</strong></p>\n<blockquote>\n<p id=\"so_6890883_6890929_0\">If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect. Otherwise, the value supplied\n  to operator <code>delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either operator <code>new(std::size_t)</code> or <code>operator new(std::size_t, const std::nothrow_-t&amp;)</code> in the standard library, and the value supplied to operator <code>delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new[](std::size_t)</code> or\n  <code>operator new[](std::size_t, const std::nothrow_t&amp;)</code> in the standard library.</p>\n</blockquote>\n<p>In C++ it is better to use <strong><a href=\"https://stackoverflow.com/questions/395123/raii-and-smart-pointers-in-c\">RAII(SBRM)</a></strong> by using <strong>Smart pointers</strong> instead of raw pointers, which automatically take care of the memory deallocations.</p>\n", "Id": "6890929", "LastEditDate": "2017-05-23T09:58:56.150", "ParentId": "6890883", "OwnerUserId": "452307", "PostTypeId": "2", "Score": "9", "LastEditorUserId": "-1"}, "bq_ids": {"n4140": {"so_6890883_6890929_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 7182}}, "n3337": {"so_6890883_6890929_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 6926}}}, "6890883": {"CreationDate": "2011-07-31T16:56:23.250", "ViewCount": "122", "Id": "6890883", "AcceptedAnswerId": "6890929", "Score": "2", "Title": "Run-time detection of memory deletion", "CommentCount": "0", "Body": "<p>The code:</p>\n<pre><code>int *ptr = new int[10];\nint *q = ptr;\ndelete q;\n</code></pre>\n<p>works fine without any issues (no run-time error).</p>\n<p>However, the following code: </p>\n<pre><code>int *ptr = new int[10];\nint *q = ptr;\nq++;\ndelete q;\n</code></pre>\n<p>results in run-time error.</p>\n<p>I am using Microsoft Visual Studio-8 and Win-7 as platform. </p>\n<p>I am not able to figure out why there is a run-time error in the second case?</p>\n", "Tags": "<c++><windows><pointers><memory-corruption>", "LastActivityDate": "2011-09-17T06:00:34.540", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "571426"}});