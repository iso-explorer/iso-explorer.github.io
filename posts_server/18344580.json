post_cb({"18344580": {"ViewCount": "609", "Body": "<p>I ran into this strange behaviour when testing whether or not <code>typename</code> is required by clang. Both clang and gcc accept this code while msvc rejects it.</p>\n<pre><code>template&lt;class T1&gt;\nstruct A\n{\n    template&lt;class T2&gt;\n    struct B\n    {\n        static B f;\n        static typename A&lt;T2&gt;::template B&lt;T1&gt; g;\n    };\n};\n\ntemplate&lt;class T1&gt;\ntemplate&lt;class T2&gt;\ntypename A&lt;T2&gt;::template B&lt;T1&gt; // ok, typename/template required\n    A&lt;T1&gt;::B&lt;T2&gt;::g;\n\ntemplate&lt;class T1&gt;\ntemplate&lt;class T2&gt;\nA&lt;T1&gt;::B&lt;T2&gt; // clang/gcc accept, msvc rejects missing typename\n    A&lt;T1&gt;::B&lt;T2&gt;::f;\n</code></pre>\n<p>In general, a qualified-id <code>A&lt;T1&gt;::B&lt;T2&gt;</code> (where <code>A&lt;T1&gt;</code> is a dependent name) should be written <code>typename A&lt;T1&gt;::template B&lt;T2&gt;</code>. Is the behaviour of gcc/clang incorrect, or is there an exception to the general rule (quoted below) in this particular case?</p>\n<p>It could be argued that <code>A&lt;T1&gt;</code> is not a dependent name, or that <code>B&lt;T2&gt;</code> refers to a member of the current instantiation. However, at the point of parsing the type-specifier it's not possible to know that the current instantiation is <code>A&lt;T1&gt;</code>. It seems problematic to require the implementation to guess that <code>A&lt;T1&gt;</code> is the current instantiation.</p>\n<blockquote>\n<p id=\"so_18344580_18344580_0\">14.6 Name resolution [temp.res]</p>\n<p id=\"so_18344580_18344580_1\">A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename.</p>\n<p id=\"so_18344580_18344580_2\">14.2 Names of template specializations [temp.names]</p>\n<p id=\"so_18344580_18344580_3\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a postfix-expression or after a\n  nested-name-specifier in a qualified-id, and the object or pointer expression of the postfix-expression or the\n  nested-name-specifier in the qualified-id depends on a template parameter (14.6.2) but does not refer to a\n  member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword\n  template. Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n<p>To further investigate what clang is doing here, I also tried this:</p>\n<pre><code>template&lt;class T1&gt;\nstruct C\n{\n    template&lt;class T2&gt;\n    struct D\n    {\n        static typename A&lt;T1&gt;::template B&lt;T2&gt; f;\n        static typename A&lt;T1&gt;::template B&lt;T2&gt; g;\n    };\n};\n\ntemplate&lt;class T1&gt;\ntemplate&lt;class T2&gt;\ntypename A&lt;T1&gt;::template B&lt;T2&gt; // ok, typename/template required\n    C&lt;T1&gt;::D&lt;T2&gt;::f;\n\ntemplate&lt;class T1&gt;\ntemplate&lt;class T2&gt;\nA&lt;T1&gt;::B&lt;T2&gt; // clang rejects with incorrect error\n    C&lt;T1&gt;::D&lt;T2&gt;::g;\n</code></pre>\n<p>Clang gives <code>error: redefinition of 'g' with a different type</code>, but the type of <code>g</code> actually matches the declaration.</p>\n<p>I would instead expect to see a diagnostic suggesting the use of <code>typename</code> or <code>template</code>.</p>\n<p>This gives credit to the hypothesis that clang's behaviour in the first example is unintended.</p>\n", "Title": "Can typename be omitted in the type-specifier of an out of line member definition?", "CreationDate": "2013-08-20T20:41:35.860", "LastActivityDate": "2014-12-22T12:55:37.560", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-22T10:33:34.717", "LastEditorUserId": "1690864", "Id": "18344580", "Score": "12", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_18344580_27602255_3": {"length": 49, "quality": 0.98, "section_id": 174}, "so_18344580_18358008_2": {"length": 4, "quality": 1.0, "section_id": 72}, "so_18344580_18344580_3": {"length": 32, "quality": 0.8, "section_id": 72}, "so_18344580_18358008_1": {"length": 13, "quality": 1.0, "section_id": 194}, "so_18344580_27602255_5": {"length": 4, "quality": 1.0, "section_id": 72}, "so_18344580_27602255_1": {"length": 19, "quality": 1.0, "section_id": 169}, "so_18344580_18344580_1": {"length": 19, "quality": 1.0, "section_id": 169}, "so_18344580_27602255_2": {"length": 14, "quality": 0.875, "section_id": 170}, "so_18344580_18358008_3": {"length": 24, "quality": 1.0, "section_id": 191}, "so_18344580_18358008_0": {"length": 4, "quality": 1.0, "section_id": 72}}, "n3337": {"so_18344580_27602255_3": {"length": 49, "quality": 0.98, "section_id": 168}, "so_18344580_18358008_2": {"length": 4, "quality": 1.0, "section_id": 67}, "so_18344580_18344580_3": {"length": 32, "quality": 0.8, "section_id": 67}, "so_18344580_18358008_1": {"length": 13, "quality": 1.0, "section_id": 188}, "so_18344580_27602255_5": {"length": 4, "quality": 1.0, "section_id": 67}, "so_18344580_27602255_1": {"length": 19, "quality": 1.0, "section_id": 163}, "so_18344580_18344580_1": {"length": 19, "quality": 1.0, "section_id": 163}, "so_18344580_27602255_2": {"length": 14, "quality": 0.875, "section_id": 164}, "so_18344580_18358008_3": {"length": 24, "quality": 1.0, "section_id": 185}, "so_18344580_18358008_0": {"length": 4, "quality": 1.0, "section_id": 67}}, "n4659": {"so_18344580_27602255_3": {"length": 48, "quality": 0.96, "section_id": 179}, "so_18344580_18358008_2": {"length": 4, "quality": 1.0, "section_id": 200}, "so_18344580_27602255_5": {"length": 4, "quality": 1.0, "section_id": 200}, "so_18344580_18358008_1": {"length": 13, "quality": 1.0, "section_id": 200}, "so_18344580_27602255_1": {"length": 19, "quality": 1.0, "section_id": 174}, "so_18344580_18344580_1": {"length": 19, "quality": 1.0, "section_id": 174}, "so_18344580_27602255_2": {"length": 16, "quality": 1.0, "section_id": 175}, "so_18344580_18358008_3": {"length": 24, "quality": 1.0, "section_id": 196}, "so_18344580_18358008_0": {"length": 4, "quality": 1.0, "section_id": 196}}}, "27602255": {"Id": "27602255", "PostTypeId": "2", "Body": "<p>MSVC is correct.</p>\n<p>My reading of the C++11 standard suggests that <code>typename</code> is required. </p>\n<p>Without the <code>typename</code> keyword, a dependent name is assumed not to name a type.</p>\n<blockquote>\n<p id=\"so_18344580_27602255_0\">14.6 Name resolution [temp.res]</p>\n<p id=\"so_18344580_27602255_1\">2)\n  A name used in a template declaration or definition and that is dependent on a template-parameter is\n  assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified\n  by the keyword typename.</p>\n<p id=\"so_18344580_27602255_2\">3)\n  When a qualified-id is intended to refer to a type that is not a member of the current instantiation\n  and its nested-name-specifier refers to a dependent type, it shall be prefixed by the keyword typename</p>\n<p id=\"so_18344580_27602255_3\">7)\n  Within the definition of a class template or <em>within the definition of a member of a class template following\n  the declarator-id</em>, the keyword typename is not required when referring to the name of a previously declared\n  member of the class template that declares a type. [Note: such names can be found using unqualified name\n  lookup, <em>class member lookup into the current instantiation</em>, or class member access\n  expression lookup when the type of the object expression is the current instantiation</p>\n<p id=\"so_18344580_27602255_4\">14.6.2.1 Dependent types [temp.dep.type]</p>\n<p id=\"so_18344580_27602255_5\">A name refers to the <em>current instantiation</em> if it is</p>\n<ul>\n<li>in the definition of a primary class template or a member of a primary class template, the name of the\n  class template followed by the template argument list of the primary template (as described below)\n  enclosed in &lt;&gt;</li>\n</ul>\n</blockquote>\n<p>When <code>A&lt;T1&gt;</code> is used in the definition of a member of <code>A</code>, it refers to the <em>current instantiation</em>. When parsing the definition of <code>f</code> a type name qualified by <code>A&lt;T1&gt;::</code> can be found by <em>class member name lookup into the current instantiation</em>.</p>\n<p>However, when the C++ parser encounters <code>A&lt;T1&gt;</code> in the return-type of a member function definition - before the declarator-id - it has not yet encountered the name of the enclosing class. The parser cannot determine whether or not <code>A</code> refers to the enclosing class at this point.</p>\n<p>For this reason - regardless of whether or not <code>A&lt;T1&gt;</code> names the current instantiation - the standard does not permit omission of <code>typename</code> within the definition of a member of a class template before the declarator-id.</p>\n<p>This <a href=\"http://melpon.org/wandbox/permlink/NrXfYV6FeTvCUGl9\" rel=\"nofollow\">example</a> by Vaughn Cato demonstrates that the behaviour of Clang/GCC is inconsistent, and requires <code>typename</code> in a similar scenario:</p>\n<pre><code>template &lt;typename T&gt;\nstruct A {\n    typedef int X;\n    X f();\n};\n\ntemplate &lt;typename T&gt;\nA&lt;T&gt;::X A&lt;T&gt;::f() // error: missing 'typename'\n{\n}\n</code></pre>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2014-12-22T12:55:37.560", "Score": "1", "CreationDate": "2014-12-22T11:56:15.197", "ParentId": "18344580", "CommentCount": "0", "OwnerUserId": "1690864", "LastEditDate": "2014-12-22T12:55:37.560"}, "18358008": {"Id": "18358008", "PostTypeId": "2", "Body": "<p>clang and gcc are correct.</p>\n<p>The compiler knows <code>A&lt;T1&gt;::B&lt;T2&gt;</code> refers to a type and <code>B&lt;T2&gt;</code> is a template and that <code>A&lt;T1&gt;::B&lt;T2&gt;::f</code> is a member of the current instantiation. Therefore, the <code>typename</code> and <code>template</code> keywords are not necessary.</p>\n<p>From v14.6.2.1p4:</p>\n<blockquote>\n<p id=\"so_18344580_18358008_0\">A name is a member of the current instantiation if it is</p>\n<p id=\"so_18344580_18358008_1\">A qualified-id in which the nested-name-specifier refers to the\n  current instantiation and that, when looked up, refers to at least one\n  member of the current instantiation</p>\n</blockquote>\n<p><code>A&lt;T1&gt;::B&lt;T2&gt;</code> is a qualified-id and <code>A&lt;T1&gt;::</code> is the nested-name-specifier which refers to the current instantiation. We know that <code>A&lt;T1&gt;::</code> refers to the current instantiation from 14.6.2.1p1:</p>\n<blockquote>\n<p id=\"so_18344580_18358008_2\">A name refers to the current instantiation if it is</p>\n<p id=\"so_18344580_18358008_3\">\u2014 in <strong>the definition of</strong> a primary class template or <strong>a member of a\n  primary class template</strong>, <strong>the name of the class template followed by the\n  template argument list of the primary template</strong> (as described below)\n  enclosed in &lt;&gt; (or an equivalent template alias specialization),</p>\n</blockquote>\n<p>In your code, we have a definition of a member of a primary class template, i.e. <code>A&lt;T1&gt;::B&lt;T2&gt;::f</code>, and <code>A&lt;T1&gt;</code> is the name of the class template followed by the template argument list of the primary template.</p>\n<p>In your question, you say <code>However, at the point of parsing the type-specifier it's not possible to know that the current instantiation is A&lt;T1&gt;</code>. However, I cannot follow that because the name <code>A&lt;T1&gt;</code> does refer to the current instantiation as stated above.</p>\n", "LastEditorUserId": "906773", "LastActivityDate": "2013-08-21T13:44:30.647", "Score": "1", "CreationDate": "2013-08-21T12:54:46.073", "ParentId": "18344580", "CommentCount": "7", "OwnerUserId": "906773", "LastEditDate": "2013-08-21T13:44:30.647"}});