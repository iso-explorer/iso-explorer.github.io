post_cb({"29347317": {"ParentId": "23808357", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I've been dealing with this problem today and found a solution for it, though I can't stress enough how dangerous this solution may be (see below why it's dangerous).</p>\n<p>My particular problem was that I just wanted to extend a library struct with some methods of my own. I wanted to keep it POD with exactly the same layout as base since I wanted to use functions that take base as parameter.</p>\n<p>The solution goes like this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct BASE {\n  int x, y;\n};\n\nstruct FOO: BASE {\n  void Foo() { x = y = 1; }\n};\n\nint main() {\n  // const declaration\n  const BASE a = { 0, 1 };\n  const FOO &amp;b = *reinterpret_cast&lt;const FOO *&gt; (&amp;a);\n\n  // non-const declaration\n  BASE _a = { 0, 3 };\n  FOO &amp;c = *reinterpret_cast&lt;FOO *&gt; (&amp;_a);\n\n  cout &lt;&lt; \"base: \" &lt;&lt; a.x &lt;&lt; \", \" &lt;&lt; a.y &lt;&lt; endl;\n  cout &lt;&lt; \"foo 1: \" &lt;&lt; b.x &lt;&lt; \", \" &lt;&lt; b.y &lt;&lt; endl;\n  cout &lt;&lt; \"foo 2: \" &lt;&lt; c.x &lt;&lt; \", \" &lt;&lt; c.y &lt;&lt; endl;\n\n  return 0;\n}\n</code></pre>\n<p>However, note that this only works because the data layout between BASE and FOO is the same. Also only because I use pointers to cast to FOO type. In this case the type casting is done without any constructors, it just pretends that the memory is in correct format. If you try to reinterpret_cast without pointers, the compiler will instead try to construct a new object based on original.</p>\n<p>See <a href=\"https://stackoverflow.com/a/2205394/1760858\">this answer</a> for better explanation.</p>\n<p>Unfortunately, there doesn't seem to be a nice one-liner for this. A proper macro for declarations seems in order.</p>\n", "OwnerUserId": "1760858", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:25.210", "Id": "29347317", "Score": "0", "CreationDate": "2015-03-30T13:20:03.903", "LastActivityDate": "2015-03-31T20:18:15.747"}, "bq_ids": {"n4140": {"so_23808357_23809231_1": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}, "so_23808357_23809231_0": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_23808357_23809231_1": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}, "so_23808357_23809231_0": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_23808357_23809231_1": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}, "so_23808357_23809231_0": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}}}, "23808357": {"CommentCount": "4", "AcceptedAnswerId": "23809231", "PostTypeId": "1", "LastEditorUserId": "158263", "CreationDate": "2014-05-22T13:30:46.067", "LastActivityDate": "2015-03-31T20:18:15.747", "LastEditDate": "2014-05-23T07:57:25.440", "ViewCount": "1140", "FavoriteCount": "2", "Title": "brace initialization for inherited pod", "Id": "23808357", "Score": "7", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n\nstruct base_pod_t {\n    unsigned x;\n};\n\nstruct der_pod_t : public base_pod_t { };\n\nint main()\n{\n    std::cout &lt;&lt; \"base_pod_t is POD: \" &lt;&lt; std::is_pod&lt;base_pod_t&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"der_pod_t  is POD: \" &lt;&lt; std::is_pod&lt;der_pod_t&gt;::value &lt;&lt; std::endl;\n    base_pod_t b1 = {};     // OK\n    base_pod_t b2 = {3};    // OK\n\n    der_pod_t p1 = {};      // OK\n//    der_pod_t p2 = {4};   // ERROR!\n}\n</code></pre>\n<p>Last line results in error. How can I brace initialize <code>der_pod_t</code> with value?</p>\n<hr>\n<p>It seems that even though it's a POD it tries to use constructor? </p>\n<hr>\n<p><strong>EDIT:</strong>\nAs @Praetorian and @dyb suggested it is a POD thus <a href=\"http://ideone.com/GCbZeG\" rel=\"nofollow\"> result of <code>std::is_pod&lt;der_pod_t&gt;::value</code> is correct.</a></p>\n</hr></hr>", "Tags": "<c++><c++11><pod>", "OwnerUserId": "158263", "AnswerCount": "2"}, "23809231": {"ParentId": "23808357", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>base_pod_t</code> is an aggregate and the initialization you're performing is aggregate initialization. </p>\n<p>From <em>\u00a78.5.1 [dcl.init.aggr]</em></p>\n<blockquote>\n<p id=\"so_23808357_23809231_0\"><em>1</em> An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n<p id=\"so_23808357_23809231_1\"><em>2</em> When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each member is copy-initialized from the corresponding <em>initializer-clause</em>. ...</p>\n</blockquote>\n<p>However, <code>der_pod_t</code> is not an aggregate because it has a base class. It's a POD, and the same rules for list initialization do not apply. Now, when the compiler sees a non-empty <em>braced-init-list</em> it'll first search for a constructor that takes an <code>initializer_list</code>. If none are found it then attempts to match other constructors of the class. Since <code>der_pod_t</code> has no constructors that take a single <code>int</code> as argument, the error occurs.</p>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-05-22T18:57:57.353", "Id": "23809231", "Score": "10", "CreationDate": "2014-05-22T14:08:39.773", "LastActivityDate": "2014-05-22T18:57:57.353"}});