post_cb({"bq_ids": {"n4140": {"so_35256315_35256813_1": {"length": 15, "quality": 0.9375, "section_id": 390}, "so_35256315_35256813_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 370}}, "n3337": {"so_35256315_35256813_1": {"length": 15, "quality": 0.9375, "section_id": 381}, "so_35256315_35256813_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 360}}, "n4659": {"so_35256315_35256813_1": {"length": 15, "quality": 0.9375, "section_id": 407}, "so_35256315_35256813_0": {"length": 33, "quality": 0.868421052631579, "section_id": 384}}}, "35256315": {"ViewCount": "219", "Body": "<p>Are these class definitions equivalent?</p>\n<p>First definition:</p>\n<pre><code>class A\n{\n    std::string s;\n};\n</code></pre>\n<p>Second definition:</p>\n<pre><code>class A\n{\n    std::string s;\npublic:\n    A() : s() {  }\n    ~A(){  }\n    A(const A&amp; AA) : s(AA.s) {  }\n    A(A&amp;&amp; a) noexcept : s(std::move(a.s)) {  }\n    A&amp; operator=(const A&amp; AA){\n        s=AA.s;\n        return *this;\n    }\n    A&amp; operator=(A&amp;&amp; a) noexcept{\n        s=(std::move(a.s));\n        return *this;\n    }\n    const A* operator&amp;() const{ return this; }\n    A* operator&amp;(){ return this; }\n};\n</code></pre>\n<p>If they are not, could you show me a class definition that is equivalent to the first one, and explicitly defines all member functions of class A?</p>\n", "Title": "How do implicitly declared (object level) member functions work according to the ISO C++11 standard?", "CreationDate": "2016-02-07T16:57:20.130", "LastActivityDate": "2016-02-07T18:57:02.487", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-02-07T17:25:07.507", "LastEditorUserId": "5137315", "Id": "35256315", "Score": "3", "OwnerUserId": "5137315", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "35256813": {"Id": "35256813", "PostTypeId": "2", "Body": "<p>It depends on your definition of \"<strong>equivalent</strong>\".</p>\n<ul>\n<li>Assembly output of the code gen? <strong>Yes</strong>, for a good compiler and optimizer, they should be. :-)</li>\n<li>Compiler's assumptions while generating ASTs and making class representations or Intermediate code? <strong>No</strong>, why?</li>\n</ul>\n<p>... from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">C++14's standard draft n3797</a>(I believe it isn't so different from the main standard).. </p>\n<p>To make things brief, Of the special member functions, taking a case of default constructor, we see from this section: <em>(emphasis are mine)</em></p>\n<blockquote>\n<p id=\"so_35256315_35256813_0\"><strong>12.1.5:</strong> .... Before the defaulted default constructor for a class is implicitly defined, all the non-user-provided default constructors\n  for its base classes and its nonstatic data members shall have been\n  implicitly defined. <em>[ Note: An implicitly-declared default\n  constructor has an exception-specification. An explicitly-defaulted\n  definition <strong>might</strong> have an implicit exception specification, see 8.4.\n  \u2014end note ]</em></p>\n</blockquote>\n<p>The above doesn't exactly apply to you code, nonetheless, further supporting evidence is somewhere in</p>\n<blockquote>\n<p id=\"so_35256315_35256813_1\"><strong>12.6.3:</strong> A non-explicit copy/move constructor is a converting constructor. <em>An implicitly-declared copy/move constructor is <strong>not</strong> an explicit constructor; it may be called for implicit type conversions.</em></p>\n</blockquote>\n<p><em>Check for your self, there are many more supporting evidences</em>... So, in the standard's sense, once you explicitly define any special member function, its different from what the compiler would have created and its associated assumptions.</p>\n<p>But at the end of the day, the same code may be generated by the code generator. :-) . Just that the assumptions of the compiler during compilation may be different.</p>\n<p><strong>TLDR;</strong></p>\n<p>There are a lot of other paragraphs in the standard(draft) where it makes distinctions between the effects of implicitly defined special member functions and its converse(its mostly silent on that). You can pick the standard up and search for all occurrences of the phrase \"implicitly-defined\"</p>\n", "LastEditorUserId": "1621391", "LastActivityDate": "2016-02-07T18:57:02.487", "Score": "2", "CreationDate": "2016-02-07T17:42:05.277", "ParentId": "35256315", "CommentCount": "8", "LastEditDate": "2016-02-07T18:57:02.487", "OwnerUserId": "1621391"}});