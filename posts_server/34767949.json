post_cb({"34768115": {"ParentId": "34767949", "CommentCount": "0", "Body": "<p>Dereferencing a dangling pointer is Undefined Behaviour.</p>\n<p>When a program encounters Undefined Behaviour, it is free to do <em>anything</em>. Which includes crashing and making daemons fly out of your nose, but it also includes doing whatever you expected.</p>\n<p>In this case, there are no intervening operations that would overwrite that part of memory and access past the stack pointer (below it, because stack grows down on most platforms) is normally not checked.</p>\n<p>So yes, this is a false positive. The memory is not guaranteed to contain the values any more and is not guaranteed to be accessible at all, but it still happens to contain them and be accessible.</p>\n<p>Also note, that gcc optimizations are rather infamous for relying on the program not invoking undefined behaviour. Quite often if you have an undefined behaviour, the unoptimized version appears to work, but once you turn on optimizations, it starts doing something completely unexpected.</p>\n", "OwnerUserId": "201725", "PostTypeId": "2", "Id": "34768115", "Score": "11", "CreationDate": "2016-01-13T13:35:13.103", "LastActivityDate": "2016-01-13T13:35:13.103"}, "34768240": {"ParentId": "34767949", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You will find later in this chapter a Warning:</p>\n<blockquote>\n<p id=\"so_34767949_34768240_0\">Throwing a pointer requires that the object to which the pointer\n  points exist wherever the corresponding handler resides.</p>\n</blockquote>\n<p>so your example would be valid if <code>a</code> array were static or global, otherwise its UB. Or (as Jan Hudec writes in comment) in the enclosing block of the try/catch statement.</p>\n", "OwnerUserId": "471160", "LastEditorUserId": "471160", "LastEditDate": "2016-01-13T13:56:52.180", "Id": "34768240", "Score": "5", "CreationDate": "2016-01-13T13:41:27.013", "LastActivityDate": "2016-01-13T13:56:52.180"}, "34768113": {"ParentId": "34767949", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_34767949_34768113_0\">But surely the array elements of a would be destroyed when we exit the try block and enter the catch clause since we change block scope?</p>\n</blockquote>\n<p>Correct.</p>\n<blockquote>\n<p id=\"so_34767949_34768113_1\">Am I getting a false positive or are the array elements \"left alone\" (not deleted) during the duration of the catch clause?</p>\n</blockquote>\n<p>They're not \"left alone\". The array is destroyed as you correctly assumed. The program is accessing invalid memory. The behaviour is undefined.</p>\n<blockquote>\n<p id=\"so_34767949_34768113_2\">How is it that this program can produce correct output of 9876543210 (g++ 5.2.0)?</p>\n</blockquote>\n<p>There is no <em>correct</em> output when the behaviour is undefined. The program can produce what it did because it can produce any output when the behaviour is undefined.</p>\n<p>Reasoning about UB is usually pointless, but in this case, the contents of the invalid memory could be identical if the part of the memory had not yet been overwritten by the program.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-01-13T13:44:39.303", "Id": "34768113", "Score": "8", "CreationDate": "2016-01-13T13:35:02.670", "LastActivityDate": "2016-01-13T13:44:39.303"}, "34767949": {"CommentCount": "2", "AcceptedAnswerId": "34768115", "CreationDate": "2016-01-13T13:26:44.080", "LastActivityDate": "2016-01-13T13:56:52.180", "PostTypeId": "1", "ViewCount": "540", "FavoriteCount": "1", "Title": "Throwing an array local to a try block", "Id": "34767949", "Score": "14", "Body": "<p>From C++ Primer 18.1.1:</p>\n<blockquote>\n<p id=\"so_34767949_34767949_0\">If the [thrown] expression has an array or function type, the expression is\n  converted to its corresponding pointer type.</p>\n</blockquote>\n<p>How is it that this program can produce correct output of <code>9876543210</code> (g++ 5.2.0)?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main(){\n\n    try{\n        int a[10] = {9,8,7,6,5,4,3,2,1,0};\n        throw a;\n    }\n    catch(int* b) { for(int i = 0; i &lt; 10; ++i) cout &lt;&lt; *(b+i); }\n\n}\n</code></pre>\n<p>From the quote, <code>throw a</code> would create an exception object of type <code>int*</code> which is a pointer to the first element of the array. But surely the array elements of <code>a</code> would be destroyed when we exit the <code>try</code> block and enter the catch clause since we change block scope? Am I getting a false positive or are the array elements \"left alone\" (not deleted) during the duration of the catch clause?</p>\n", "Tags": "<c++><arrays><c++11><throw>", "OwnerUserId": "5627734", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_34767949_34767949_0": {"section_id": 3296, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_34767949_34767949_0": {"section_id": 3166, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_34767949_34767949_0": {"section_id": 4087, "quality": 0.7272727272727273, "length": 8}}}});