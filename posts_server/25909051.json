post_cb({"25909392": {"Id": "25909392", "PostTypeId": "2", "Body": "<p>It should be ambiguous.</p>\n<p><a href=\"http://rextester.com/JWPO98665\" rel=\"nofollow\">gcc</a></p>\n<p><a href=\"http://rextester.com/IDIIE77358\" rel=\"nofollow\">clang</a></p>\n<p><a href=\"http://rextester.com/JMK12091\" rel=\"nofollow\">vc++</a></p>\n", "LastActivityDate": "2014-09-18T09:47:48.637", "CommentCount": "0", "CreationDate": "2014-09-18T09:47:48.637", "ParentId": "25909051", "Score": "1", "OwnerUserId": "3309790"}, "25909147": {"Id": "25909147", "PostTypeId": "2", "Body": "<p>The call <code>CAgs (10, 0);</code> is ambiguous because the <code>int</code> <code>0</code> is a candidate for a <code>bool</code> <em>and</em> a pointer.  A non-zero <code>int</code> would call <code>CAgs (int ar, bool isReady);</code> however because <code>bool</code> is the <em>only</em> candidate in the non-zero case.</p>\n", "LastEditorUserId": "1312406", "LastActivityDate": "2014-09-18T09:49:57.917", "Score": "1", "CreationDate": "2014-09-18T09:36:33.663", "ParentId": "25909051", "CommentCount": "3", "OwnerUserId": "1312406", "LastEditDate": "2014-09-18T09:49:57.917"}, "25909597": {"Id": "25909597", "PostTypeId": "2", "Body": "<p>Both <code>int</code> to <code>bool</code> as well as <code>0</code> to pointer is an <em>integral conversion</em> (4.7 [conv.integral]) so that both conversions have the same order what makes them ambiguous. This however only applies if the <code>int</code> is a so called <em>null pointer constant</em> like <code>NULL</code> or <code>0</code>, otherwise the <code>int</code> to pointer conversion is no candidate and the <code>int</code> to <code>bool</code> one is choosen.</p>\n", "LastActivityDate": "2014-09-18T09:57:36.850", "CommentCount": "0", "CreationDate": "2014-09-18T09:57:36.850", "ParentId": "25909051", "Score": "1", "OwnerUserId": "3903983"}, "25909051": {"ViewCount": "121", "Body": "<p>I have legacy code which has following constructors.</p>\n<pre><code>CAgs (int ar, bool isReady);\nCAgs (int ar, const char* options[][2] = NULL); \n</code></pre>\n<p>It is compiling, but will it not be ambiguous call? If I call <code>CAgs (10, 0);</code>, which constructor will get called?</p>\n<p>Is this behaviour compiler dependant?</p>\n", "AcceptedAnswerId": "25909289", "Title": "Why two functions are not ambiguous?", "CreationDate": "2014-09-18T09:32:35.027", "Id": "25909051", "CommentCount": "7", "LastEditDate": "2014-09-18T17:34:47.030", "PostTypeId": "1", "LastEditorUserId": "1938163", "LastActivityDate": "2014-09-18T17:34:47.030", "Score": "2", "OwnerUserId": "744616", "Tags": "<c++><oop><overloading><ambiguity>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_25909051_25909939_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 30}, "so_25909051_25909289_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 39}, "so_25909051_25909939_6": {"length": 10, "quality": 0.5555555555555556, "section_id": 44}, "so_25909051_25909289_1": {"length": 28, "quality": 1.0, "section_id": 44}, "so_25909051_25909939_4": {"length": 7, "quality": 0.5384615384615384, "section_id": 44}}, "n3337": {"so_25909051_25909939_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 27}, "so_25909051_25909289_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 36}, "so_25909051_25909289_1": {"length": 28, "quality": 1.0, "section_id": 41}, "so_25909051_25909939_4": {"length": 7, "quality": 0.5384615384615384, "section_id": 41}}, "n4659": {"so_25909051_25909939_1": {"length": 10, "quality": 0.5555555555555556, "section_id": 30}, "so_25909051_25909289_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 39}, "so_25909051_25909939_6": {"length": 10, "quality": 0.5555555555555556, "section_id": 45}, "so_25909051_25909289_1": {"length": 28, "quality": 1.0, "section_id": 45}, "so_25909051_25909939_4": {"length": 7, "quality": 0.5384615384615384, "section_id": 45}}}, "25909289": {"Id": "25909289", "PostTypeId": "2", "Body": "<p>Nb. I interpreted your question as <em>\"why does it compile? Isn't it ambiguous <strong>if I were</strong> to call it like that?\"</em></p>\n<p>That call <a href=\"http://ideone.com/5MjRpI\" rel=\"nofollow\"><strong>is</strong> ambiguous</a> since calling each constructor would require an implicit conversion with <code>CAgs (10, 0);</code></p>\n<p>To cite some sources:</p>\n<p>\u00a7 4.10.1 for the <code>const char* options[][2]</code> type</p>\n<blockquote>\n<p id=\"so_25909051_25909289_0\">A null pointer constant is an integer literal (2.14.2) with value zero\n  or a prvalue of type std::nullptr_t. A null pointer constant can be\n  converted to a pointer type; the result is the null pointer value of\n  that type and is distinguishable from every other value of object\n  pointer or function pointer type. Such a conversion is called a null\n  pointer conversion.</p>\n</blockquote>\n<p>4.12.1 for the <code>bool</code> type</p>\n<blockquote>\n<p id=\"so_25909051_25909289_1\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to\n  member type can be converted to a prvalue of type bool. A zero value,\n  null pointer value, or null member pointer value is converted to\n  false; any other value is converted to true.</p>\n</blockquote>\n<p>The code surely compiles because the parameters are two different and valid types and if you pass something that doesn't need an ambiguous implicit conversion, it will properly work. But that doesn't mean it's not ambiguous for <code>CAgs (10, 0);</code></p>\n<p>As a small unrelated sidenote the default value for the pointer makes the following just work: <code>CAgs (10);</code>. The same for any other non-zero type (the <code>bool</code> constructor would be chosen).</p>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2014-09-18T10:04:12.920", "Score": "0", "CreationDate": "2014-09-18T09:42:51.840", "ParentId": "25909051", "CommentCount": "0", "OwnerUserId": "1938163", "LastEditDate": "2014-09-18T10:04:12.920"}, "25909939": {"Id": "25909939", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25909051_25909939_0\"><strong>Integral conversions</strong></p>\n<p id=\"so_25909051_25909939_1\">A prvalue of an integer type or of an unscoped enumeration type can be\n  converted to any other integer type. If the conversion is listed under\n  integral promotions, it is a promotion and not a conversion.</p>\n<ul>\n<li>If the destination type is unsigned, the resulting value is the    smallest unsigned value equal to the source value modulo 2n\n         where n is the number of bits used to represent the destination type. </li>\n<li>That is, depending on whether the destination type is wider or       narrower, signed integers are sign-extended[footnote 1] or truncated and unsigned integers are zero-extended or truncated respectively.</li>\n<li>If the destination type is signed, the value does not change if the      source integer can be represented in the destination type. Otherwise the result is implementation-defined.</li>\n<li>If the source type is bool, the value false is converted to zero and     the value true is converted to the value one of the\n  destination type     (note that if the destination type is int, this\n  is an integer       promotion, not an integer conversion)</li>\n<li>If the destination type is bool, this is a boolean conversion (see\n        below)</li>\n</ul>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_25909051_25909939_2\"><strong>Pointer conversions</strong></p>\n<ul>\n<li>A null pointer constant (see NULL), can be converted to any pointer    type, and the result is the null pointer value of that type. Such conversion (known as null pointer conversion) is allowed to convert to a cv-qualified type as a single conversion, that is, it's not considered a combination of numeric and qualifying conversions.</li>\n<li>A prvalue pointer to any (optionally cv-qualified) object type T can    be converted to a prvalue pointer to (identically cv-qualified)\n  void.    The resulting pointer represents the same byte in memory as\n  the    original pointer value. If the original pointer is a null\n  pointer    value, the result is a null pointer value of the\n  destination type.</li>\n<li>A prvalue pointer to a (optionally cv-qualified) derived class type can be converted to prvalue pointer to its accessible, unambiguous  (identically cv-qualified) base class. The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value \n  of the destination type.</li>\n</ul>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_25909051_25909939_3\"><strong>Boolean conversions</strong></p>\n<p id=\"so_25909051_25909939_4\">Prvalues of integral, floating-point, unscoped enumeration, pointer,\n  and pointer-to-member types can be converted to prvalues of type bool.</p>\n<p id=\"so_25909051_25909939_5\">The value zero (for integral, floating-point, and unscoped\n  enumeration) and the null pointer and the null pointer-to-member\n  values become false. All other values become true.</p>\n<p id=\"so_25909051_25909939_6\">Prvalue of type std::nullptr_t, including nullptr, can be converted to prvalue of type bool in context of direct-initialization (since C++14). The resulting value is false.</p>\n</blockquote>\n<p>Source: <a href=\"http://en.cppreference.com/w/cpp/language/implicit_cast\" rel=\"nofollow\">Implicit conversions</a> at cppreference</p>\n<p>Since they are both conversions, they have the same order, so this should be ambiguous. But only in the case of 0, because 0 can be converted to NULL.</p>\n", "LastEditorUserId": "2307070", "LastActivityDate": "2014-09-18T10:51:30.410", "Score": "1", "CreationDate": "2014-09-18T10:15:07.363", "ParentId": "25909051", "CommentCount": "0", "OwnerUserId": "3271131", "LastEditDate": "2014-09-18T10:51:30.410"}, "25909710": {"Id": "25909710", "PostTypeId": "2", "Body": "<p>This is ambiguous. To resolve, explicit cast is required, like:</p>\n<pre><code>CAgs(4, (bool)0);\n</code></pre>\n<p>or</p>\n<pre><code>CAgs(4, (char *)0);\n</code></pre>\n", "LastActivityDate": "2014-09-18T10:03:35.727", "CommentCount": "0", "CreationDate": "2014-09-18T10:03:35.727", "ParentId": "25909051", "Score": "1", "OwnerUserId": "2032021"}});