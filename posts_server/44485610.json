post_cb({"44485610": {"CommentCount": "0", "ViewCount": "681", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-06-11T15:36:59.017", "LastActivityDate": "2017-07-05T16:09:03.203", "LastEditDate": "2017-07-05T16:09:03.203", "AcceptedAnswerId": "44485702", "FavoriteCount": "1", "Title": "Will I be able to declare a constexpr lambda inside a template parameter?", "Id": "44485610", "Score": "17", "Body": "<p>I know it's like opening the Pandora box but it doesn't stop bothering me. Consider a simple example:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;auto&gt;\nstruct Foo: std::false_type { };\n\ntemplate &lt;&gt;\nstruct Foo&lt;[](){return 1;}()&gt;:std::true_type { };\n\nint main() {\n    static_assert(Foo&lt;1&gt;::value);\n}\n</code></pre>\n<p>I know lambdas cannot be declared inside unevaluated context, but obviously this is not the case here. What is even more weird clang 5.0.0 (which, I guess, first partially supports constexpr lambda) <a href=\"https://wandbox.org/permlink/IUISuUO7slQcURFF\" rel=\"noreferrer\">does compile it</a>.</p>\n<p>Is it a compiler bug or will C++17 allow this?</p>\n", "Tags": "<c++><templates><language-lawyer><c++1z><constexpr-lambda>", "OwnerUserId": "4324224", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44485610_44485702_0": {"section_id": 5961, "quality": 0.8461538461538461, "length": 22}, "so_44485610_44485702_1": {"section_id": 5961, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_44485610_44485702_1": {"section_id": 7448, "quality": 0.5555555555555556, "length": 5}, "so_44485610_44485702_0": {"section_id": 7448, "quality": 0.9615384615384616, "length": 25}}}, "44485702": {"ParentId": "44485610", "CommentCount": "4", "CreationDate": "2017-06-11T15:44:59.930", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "44485702", "Score": "23", "Body": "<p>No, that is a compiler bug. <a href=\"https://godbolt.org/g/0HToIg\" rel=\"noreferrer\">gcc 7.1</a> correctly rejects the code.</p>\n<p><a href=\"http://eel.is/c++draft/expr.prim.lambda#2\" rel=\"noreferrer\">[expr.prim.lambda]/2</a>:</p>\n<blockquote>\n<p id=\"so_44485610_44485702_0\">A lambda-expression is a prvalue whose result object is called the <em>closure object</em>. A lambda-expression shall not appear in an unevaluated operand, <strong>in a template-argument</strong>, in an alias-declaration, in a typedef declaration, or in the declaration of a function or function template outside its function body and default arguments.</p>\n</blockquote>\n<p>As you can see from the part that I marked as bold, a lambda expression cannot appear in a template argument list.</p>\n<p>This is also made clear in a subsequent note:</p>\n<blockquote>\n<p id=\"so_44485610_44485702_1\">[\u2009Note: The intention is to prevent lambdas from appearing in a signature. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>If I were to guess, I would say that the bug comes about because starting with C++17, lambdas are implicitly <code>constexpr</code>, which makes them valid to be called in compile time expressions, like template arguments. But actually defining a lambda in a template argument is still illegal.</p>\n", "LastActivityDate": "2017-06-11T15:44:59.930"}});