post_cb({"1832002": {"Id": "1832002", "PostTypeId": "2", "Body": "<p>Actually no serious advantage. If the void* points to something that is not a pointer to a polymorphic object you run into undefined behaviour (usually an access violation) immediately.</p>\n", "LastEditorUserId": "57428", "LastActivityDate": "2009-12-02T10:55:43.680", "Score": "2", "CreationDate": "2009-12-02T10:26:49.417", "ParentId": "1831991", "CommentCount": "1", "OwnerUserId": "57428", "LastEditDate": "2009-12-02T10:55:43.680"}, "1832192": {"Id": "1832192", "PostTypeId": "2", "Body": "<p>The safest way to handle pointers in C++ is to handle them typesafe.  This means:</p>\n<ul>\n<li>Never store pointers in anything else than a pointer</li>\n<li>Avoid void pointers</li>\n<li>Never pass pointers to other processes</li>\n<li>consider weak_ptr if you plan to use pointers over threads</li>\n</ul>\n<p>The reason for this is: what you are planning to do is unsafe and can be avoided unless you're interfacing with unsafe (legacy?) code.  In this case consider MSalters' answer, but be aware that it still is a hassle.</p>\n", "LastActivityDate": "2009-12-02T10:58:57.187", "CommentCount": "0", "CreationDate": "2009-12-02T10:58:57.187", "ParentId": "1831991", "Score": "0", "OwnerUserId": "104774"}, "1832104": {"Id": "1832104", "PostTypeId": "2", "Body": "<p>Type checking on <code>dynamic_cast</code> is implemented in different ways by different C++ implementations; if you want an answer for your specific implementation you should mention what implementation you are using. The only way to answer the question in general is to refer to ISO standard C++.</p>\n<p>By my reading of the standard, calling <code>dynamic_cast</code> on a void pointer is illegal:</p>\n<pre><code>dynamic_cast&lt;T&gt;(v)\n</code></pre>\n<blockquote>\n<p id=\"so_1831991_1832104_0\">\"If T is a pointer type, v shall be an rvalue of a pointer to complete class type\"</p>\n</blockquote>\n<p>(from 5.2.7.2 of the ISO C++ standard). <code>void</code> is not a complete class type, so the expression is illegal.</p>\n<p>Interestingly, the type being cast <em>to</em> is allowed to be a void pointer, i.e.</p>\n<pre><code>void * foo = dynamic_cast&lt;void *&gt;(some_pointer);\n</code></pre>\n<p>In this case, the <code>dynamic_cast</code> always succeeds, and the resultant value is a pointer to the most-derived object pointed to by <code>v</code>.</p>\n", "LastActivityDate": "2009-12-02T10:42:12.837", "CommentCount": "1", "CreationDate": "2009-12-02T10:42:12.837", "ParentId": "1831991", "Score": "2", "OwnerUserId": "174963"}, "1832107": {"Id": "1832107", "PostTypeId": "2", "Body": "<ul>\n<li><p>First of all \"reinterpreting\" <code>int</code> to <code>void *</code> is a bad idea. If <code>sizeof(int)</code> is 4 and <code>sizeof(void *)</code> is 8 (64x system) it is ill-formed.</p></li>\n<li><p>Moreover <code>dynamic_cast</code> is valid only for the case of the polymorphic classes.</p></li>\n</ul>\n", "LastActivityDate": "2009-12-02T10:42:46.423", "CommentCount": "0", "CreationDate": "2009-12-02T10:42:46.423", "ParentId": "1831991", "Score": "0", "OwnerUserId": "124161"}, "1832179": {"Id": "1832179", "PostTypeId": "2", "Body": "<p>Option 1 is your only (semi) portable/valid option.</p>\n<p>Option 2: is not valid C++ as the dynamic_cast (as void is not allowed).</p>\n<p>At an implementation level it requires type information from the source type to get to the destination type. There is no way (or there may be no way) to get the runtime source type information from a void* so this is not valid either.</p>\n<p>Dynamic_Cast is used to cas up and down the type hierarchy not from unknown types.</p>\n<p>As a side note you should probably be using void* rather than an integer to store an untyped pointer. There is potential for an int not to be large enough to store a pointer. </p>\n", "LastActivityDate": "2009-12-02T10:56:38.343", "CommentCount": "0", "CreationDate": "2009-12-02T10:56:38.343", "ParentId": "1831991", "Score": "0", "OwnerUserId": "14065"}, "bq_ids": {"n4140": {"so_1831991_1832104_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4701}}, "n3337": {"so_1831991_1832104_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4510}}, "n4659": {"so_1831991_1832104_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6097}}}, "1831991": {"ViewCount": "1041", "Body": "<p>I need to convert an integral type which contains an address to the actual pointer type. I could use reinterpret_cast as follows:</p>\n<pre><code>MyClass *mc1 = reinterpret_cast&lt;MyClass*&gt;(the_integer);\n</code></pre>\n<p>However, this does not perform any run-time checks to see if the address in question actually holds a MyClass object. I want to know if there is any benefit in first converting to a void* (using reinterpret_cast) and then using dynamic_cast on the result. Like this:</p>\n<pre><code>void *p = reinterpret_cast&lt;void*&gt;(the_integer);\nMyClass *mc1 = dynamic_cast&lt;MyClass*&gt;(p);\nassert(mc1 != NULL);\n</code></pre>\n<p>Is there any advantage in using the second method?</p>\n", "AcceptedAnswerId": "1832104", "Title": "C++: Safe way to cast an integer to a pointer", "CreationDate": "2009-12-02T10:24:19.517", "Id": "1831991", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2009-12-02T11:04:29.830", "Score": "1", "OwnerUserId": "45603", "Tags": "<c++><casting><dynamic-cast><reinterpret-cast>", "AnswerCount": "8"}, "1832136": {"Id": "1832136", "PostTypeId": "2", "Body": "<p>If you know for sure that <code>the_integer</code> points to a known base class (that has at least one virtual member), there might in fact be an advantage: knowing that the object is of a specific derived class. But you\u2019d have to <code>reinterpret_cast</code> to your base class first and then do the <code>dynamic_cast</code>:</p>\n<pre><code>BaseClass* obj = reinterpret_cast&lt;BaseClass*&gt;(the_integer);\nMyClass* myObj = dynamic_cast&lt;BaseClass*&gt;(obj);\n</code></pre>\n<p>Using a <code>void*</code> in <code>dynamic_cast</code> is useless and simply wrong. You cannot use <code>dynamic_cast</code> to check if there\u2019s a valid object at some arbitrary location in memory.</p>\n<p>You should also pay attention when storing addresses in non-pointer type variables. There are architectures where sizeof(void*) != sizeof(int), e.g. LP64.</p>\n", "LastEditorUserId": "104790", "LastActivityDate": "2009-12-02T11:04:29.830", "Score": "0", "CreationDate": "2009-12-02T10:48:38.310", "ParentId": "1831991", "CommentCount": "0", "OwnerUserId": "104790", "LastEditDate": "2009-12-02T11:04:29.830"}, "1832001": {"Id": "1832001", "PostTypeId": "2", "Body": "<p>No, there's no specific advantage in doing so. The moment you use <code>reinterpret_cast</code>, all bets are off. It's up to you to be sure the cast is valid.</p>\n", "LastActivityDate": "2009-12-02T10:26:34.660", "CommentCount": "0", "CreationDate": "2009-12-02T10:26:34.660", "ParentId": "1831991", "Score": "2", "OwnerUserId": "33708"}, "1832059": {"Id": "1832059", "PostTypeId": "2", "Body": "<p>The safe way is to keep a record of all live MyClass objects. It's best to keep this record in a <code>std::set&lt;void*&gt;</code>, which means you can easily add, remove and test elements. </p>\n<p>The reason for storing them as <code>void*</code>s is that you don't risk nastyness like creating unaligned <code>MyClass*</code> pointers from your integers.</p>\n", "LastActivityDate": "2009-12-02T10:35:38.807", "CommentCount": "0", "CreationDate": "2009-12-02T10:35:38.807", "ParentId": "1831991", "Score": "1", "OwnerUserId": "15416"}});