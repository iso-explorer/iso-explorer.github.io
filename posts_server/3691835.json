post_cb({"3692077": {"Id": "3692077", "PostTypeId": "2", "Body": "<p><strong>gcc, in C mode:</strong></p>\n<p>Uninitialised globals which are not declared <code>extern</code> are treated as \"common\" symbols, not weak symbols.</p>\n<p>Common symbols are merged at link time so that they all refer to the same storage; if more than one object attempts to initialise such a symbol, you will get a link-time error.  (If they aren't explicitly initialised anywhere, they will be placed in the BSS, i.e. initialised to 0.)</p>\n<p><strong>gcc, in C++ mode:</strong></p>\n<p>Not the same - it doesn't do the common symbols thing.  \"Uninitialised\" globals which are not declared <code>extern</code> are implicitly initialised to a default value (0 for simple types, or default constructor).</p>\n<hr>\n<p>In either case, a weak symbol allows an initialised symbol to be overridden by a non-weak initialised symbol of the same name at link time.</p>\n<hr>\n<p>To illustrate (concentrating on the C case here), I'll use 4 variants of a main program, which are all the same except for the way that <code>global</code> is declared:</p>\n<ol>\n<li><p><strong>main_init.c</strong>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint global = 999;\n\nint main(void) { printf(\"%d\\n\", global); return 0; }\n</code></pre></li>\n<li><p><strong>main_uninit.c</strong>, which omits the initialisation:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint global;\n\nint main(void) { printf(\"%d\\n\", global); return 0; }\n</code></pre></li>\n<li><p><strong>main_uninit_extern.c</strong>, which adds the <code>extern</code> keyword:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nextern int global;\n\nint main(void) { printf(\"%d\\n\", global); return 0; }\n</code></pre></li>\n<li><p><strong>main_weak_init.c</strong>, which initialises <code>global</code> and declares it to be a weak symbol:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint global __attribute__((weak)) = 999;\n\nint main(void) { printf(\"%d\\n\", global); return 0; }\n</code></pre></li>\n</ol>\n<p>and <strong>another_def.c</strong> which initialises the same global:</p>\n<pre><code>int global = 1234;\n</code></pre>\n<hr>\n<p>Using <code>main_uninit.c</code> on its own gives 0:</p>\n<pre><code>$ gcc -o test main_uninit.c &amp;&amp; ./test\n0\n</code></pre>\n<p>but when <code>another_def.c</code> is included as well, <code>global</code> is explicitly initialised and we get the expected result:</p>\n<pre><code>$ gcc -o test main_uninit.c another_def.c &amp;&amp; ./test\n1234\n</code></pre>\n<p>(Note that this case fails instead if you're using C++.)</p>\n<p>If we try with both <code>main_init.c</code> and <code>another.def.c</code> instead, we have 2 initialisations of <code>global</code>, which won't work:</p>\n<pre><code>$ gcc -o test main_init.c another_def.c &amp;&amp; ./test\n/tmp/cc5DQeaz.o:(.data+0x0): multiple definition of `global'\n/tmp/ccgyz6rL.o:(.data+0x0): first defined here\ncollect2: ld returned 1 exit status\n</code></pre>\n<hr>\n<p><code>main_uninit_extern.c</code> on its own won't work at all - the <code>extern</code> keyword causes the symbol to be an ordinary external reference rather than a common symbol, so the linker complains:</p>\n<pre><code>$ gcc -o test main_uninit_extern.c &amp;&amp; ./test\n/tmp/ccqdYUIr.o: In function `main':\nmain_uninit_extern.c:(.text+0x12): undefined reference to `global'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>It works fine once the initialisation from <code>another_def.c</code> is included:</p>\n<pre><code>$ gcc -o test main_uninit_extern.c another_def.c &amp;&amp; ./test\n1234\n</code></pre>\n<hr>\n<p>Using <code>main_init_weak.c</code> on its own gives the value we initialised the weak symbol to (999), as there is nothing to override it:</p>\n<pre><code>$ gcc -o test main_init_weak.c &amp;&amp; ./test\n999\n</code></pre>\n<p>But pulling in the other definition from <code>another_def.c</code> does work in this case, because the strong definition there overrides the weak definition in <code>main_init_weak.c</code>:</p>\n<pre><code>$ gcc -o test main_init_weak.c another_def.c &amp;&amp; ./test\n1234\n</code></pre>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "895245", "LastActivityDate": "2015-05-27T05:25:53.203", "Score": "27", "CreationDate": "2010-09-11T18:13:41.950", "ParentId": "3691835", "CommentCount": "9", "OwnerUserId": "242889", "LastEditDate": "2015-05-27T05:25:53.203"}, "3692486": {"Id": "3692486", "PostTypeId": "2", "Body": "<p>The question is based on an incorrect premise. Uninitialized global variables are not weak symbols.</p>\n<p>Apparently the question is referring to the ability to define the same uninitialized object with external linkage in multiple translation units. Formally, it is not allowed - it is an error in both C and C++. However, at least in C is recognized by C99 standard as \"common extension\" of the language, implemented in many real-life compilers</p>\n<blockquote>\n<p id=\"so_3691835_3692486_0\"><strong>J.5 Common extensions</strong></p>\n<p id=\"so_3691835_3692486_1\"><strong>J.5.11 Multiple external definitions</strong> </p>\n<p id=\"so_3691835_3692486_2\"><strong>1</strong> There may be more than one external\n  definition for the identifier of an\n  object, with or without the explicit\n  use of the keyword extern; if the\n  definitions disagree, or more than one\n  is initialized, the behavior is\n  undefined (6.9.2).</p>\n</blockquote>\n<p>Note, that contrary to the popular belief, C language explicitly prohibits introducing multiple definitions of entities with external linkage in the program, just like C++ does. </p>\n<blockquote>\n<p id=\"so_3691835_3692486_3\"><strong>6.9 External definitions</strong></p>\n<p id=\"so_3691835_3692486_4\"><strong>5</strong> An external definition is an\n  external declaration that is also a\n  definition of a function (other than\n  an inline definition) or an object. If\n  an identifier declared with external\n  linkage is used in an expression\n  (other than as part of the operand of\n  a sizeof operator whose result is an\n  integer constant), somewhere in the\n  entire program there shall be <strong>exactly\n  one</strong> external definition for the\n  identifier; otherwise, there shall be\n  <strong>no more than one</strong>.</p>\n</blockquote>\n<p>However, the extension allowing this has been pretty popular with many C compilers, of which GCC just happens to be one.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2014-06-27T06:19:08.790", "Score": "9", "CreationDate": "2010-09-11T20:11:29.513", "ParentId": "3691835", "CommentCount": "3", "OwnerUserId": "187690", "LastEditDate": "2014-06-27T06:19:08.790"}, "3691835": {"ViewCount": "5979", "Body": "<p>It seems uninitialized global variable is treated as weak symbol in Gcc. What is the reason  behind this?</p>\n", "AcceptedAnswerId": "3692077", "Title": "Why uninitialized global variable is weak symbol?", "CreationDate": "2010-09-11T16:59:05.413", "Id": "3691835", "CommentCount": "7", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2010-09-11T17:44:04.353", "LastEditorUserId": "240633", "LastActivityDate": "2015-05-27T05:25:53.203", "Score": "7", "OwnerUserId": "396383", "Tags": "<c++><c><gcc>", "AnswerCount": "4"}, "3692325": {"Id": "3692325", "PostTypeId": "2", "Body": "<p>Any multiple definition of a global symbol is undefined behavior, so gcc (or rather the GNU binutils linker) is free to do whatever it wants. In practice, it follows the traditional behavior to avoid breaking code that relies on this behavior.</p>\n", "LastEditorUserId": "379897", "LastActivityDate": "2010-09-12T14:53:11.390", "Score": "3", "CreationDate": "2010-09-11T19:21:38.110", "ParentId": "3691835", "CommentCount": "2", "OwnerUserId": "379897", "LastEditDate": "2010-09-12T14:53:11.390"}, "bq_ids": {"n4140": {"so_3691835_3692486_2": {"length": 12, "quality": 0.5454545454545454, "section_id": 7043}}, "n3337": {"so_3691835_3692486_2": {"length": 12, "quality": 0.5454545454545454, "section_id": 6788}}, "n4659": {"so_3691835_3692486_2": {"length": 12, "quality": 0.5454545454545454, "section_id": 8540}}}, "3692047": {"Id": "3692047", "PostTypeId": "2", "Body": "<p>Is this what you meant?</p>\n<p>weak.c</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint weak; /* global, weak, zero */\n\nint main(void) {\n  printf(\"weak value is %d.\\n\", weak);\n  return 0;\n}\n</code></pre>\n<p>strong.c</p>\n<pre><code>int weak = 42; /* global, strong, 42 */\n</code></pre>\n<p>Sample run</p>\n<pre>$ gcc weak.c\n$ ./a.out\nweak value is 0.\n$ gcc weak.c strong.c\n$ ./a.out\nweak value is 42.</pre>\n<p><s><strong>The <code>int weak;</code> in weak.c is a declaration, not a definition.</strong> Or you may say it's a tentative definition. <strong>The real definition is in <code>strong.c</code> when that object file is linked in the final program</strong> or in <code>weak.c</code> otherwise.</s>\nThis is a common extension, one that gcc uses (thanks Andrey).</p>\n", "LastEditorUserId": "25324", "LastActivityDate": "2010-09-11T20:44:52.317", "Score": "3", "CreationDate": "2010-09-11T18:04:47.837", "ParentId": "3691835", "CommentCount": "1", "OwnerUserId": "25324", "LastEditDate": "2010-09-11T20:44:52.317"}});