post_cb({"bq_ids": {"n4140": {"so_23186775_23186975_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 302}}, "n3337": {"so_23186775_23186975_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 293}}, "n4659": {"so_23186775_23186975_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 309}}}, "23186775": {"ViewCount": "1187", "Body": "<p>The code below is a minimal example of my problem. I created a simple template class containing a fixed-size array, and overloaded the assignment operator to accept any class defining the methods <code>size()</code> and <code>begin()</code> (eg, <code>initializer_list</code>s). I don't understand why g++ is not able to resolve my call to this operator (I'm using gcc 4.6):</p>\n<pre><code>***.cpp: In function \u2018int main()\u2019:\n***.cpp:46:22: error: no match for \u2018operator=\u2019 in \u2018a = {42, -1.0e+0, 3.14158999999999988261834005243144929409027099609375e+0}\u2019\n***.cpp:46:22: note: candidates are:\n***.cpp:23:8: note: template&lt;class U&gt; A&lt;T, N&gt;::self&amp; A::operator=(const U&amp;) [with U = U, T = double, unsigned int N = 3u, A&lt;T, N&gt;::self = A&lt;double, 3u&gt;]\n***.cpp:8:7: note: A&lt;double, 3u&gt;&amp; A&lt;double, 3u&gt;::operator=(const A&lt;double, 3u&gt;&amp;)\n***.cpp:8:7: note:   no known conversion for argument 1 from \u2018&lt;brace-enclosed initialiser list&gt;\u2019 to \u2018const A&lt;double, 3u&gt;&amp;\u2019\n***.cpp:8:7: note: A&lt;double, 3u&gt;&amp; A&lt;double, 3u&gt;::operator=(A&lt;double, 3u&gt;&amp;&amp;)\n***.cpp:8:7: note:   no known conversion for argument 1 from \u2018&lt;brace-enclosed initialiser list&gt;\u2019 to \u2018A&lt;double, 3u&gt;&amp;&amp;\u2019\n</code></pre>\n<p>The first candidate is listed correctly, but there is no error message associated. Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;initializer_list&gt;\n\n// ------------------------------------------------------------------------\n\ntemplate &lt;typename T, unsigned N&gt;\nclass A\n{\npublic:\n\n    typedef A&lt;T,N&gt; self;\n\n    // Default ctor\n    A() {}\n\n    // Copy ctor\n    template &lt;typename U&gt;\n    A( const U&amp; other ) { operator=(other); }\n\n    // Assignemnt\n    template &lt;typename U&gt;\n    self&amp; operator= ( const U&amp; other )\n    {\n        if ( other.size() == N )\n            std::copy_n( other.begin(), N, m_data );\n            return *this;\n    }\n\n    // Display contents\n    void print() const\n    {\n        for ( unsigned i = 0; i &lt; N; ++i )\n            std::cout &lt;&lt; m_data[i] &lt;&lt; \" \";\n        std::cout &lt;&lt; std::endl;\n    }\n\nprivate:\n    T m_data[N];\n};\n\n// ------------------------------------------------------------------------\n\nint main()\n{\n    A&lt;double,3&gt; a;\n    a = {42,-1.0,3.14159};\n    a.print();\n}\n</code></pre>\n<p>Does anyone know why this might be ambiguous, or what I did wrong?</p>\n<hr>\n<p>Note: Ideally, I would even like to replace the first two lines of my main by a single one <code>A&lt;double,3&gt; a = {42,-1.0,3.14159};</code> but I'm not sure how, I currently get the following error:</p>\n<pre><code>***: In function \u2018int main()\u2019:\n***:45:34: error: could not convert \u2018{42, -1.0e+0, 3.14158999999999988261834005243144929409027099609375e+0}\u2019 from \u2018&lt;brace-enclosed initialiser list&gt;\u2019 to \u2018A&lt;double, 3u&gt;\u2019\n</code></pre>\n</hr>", "AcceptedAnswerId": "23186975", "Title": "Assignment of initializer list", "CreationDate": "2014-04-20T19:39:16.970", "Id": "23186775", "CommentCount": "1", "LastEditDate": "2014-04-20T20:17:04.383", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-04-20T20:17:04.383", "Score": "0", "OwnerUserId": "472610", "Tags": "<c++><c++11><operator-overloading><initializer-list><overload-resolution>", "AnswerCount": "3"}, "23186822": {"Id": "23186822", "PostTypeId": "2", "Body": "<p>I'd say it's this:</p>\n<pre><code>A&lt;double,3&gt; a;\na = {42,-1.0,3.14159};\n</code></pre>\n<p>You are initializing <code>a</code> with default constructor, and then trying to use initializer list on already initialized object - which complains about lacking of appropriate <code>operator=</code> overload. Instead try:</p>\n<pre><code>A&lt;double,3&gt; a = {42,-1.0,3.14159};\n</code></pre>\n<p>EDIT:</p>\n<p>You also didn't defined required constructor:</p>\n<pre><code>template &lt;typename T, unsigned N&gt;\nclass A\n{\npublic:\n    A(std::initializer_list list) : m_data(list) {}\n\n//...\n}\n</code></pre>\n", "LastActivityDate": "2014-04-20T19:44:32.697", "CommentCount": "5", "CreationDate": "2014-04-20T19:44:32.697", "ParentId": "23186775", "Score": "-2", "OwnerUserId": "1305121"}, "23186942": {"Id": "23186942", "PostTypeId": "2", "Body": "<p>A brace-enclosed initializer list does not necessarily have the type <code>std::initializer_list&lt;T&gt;</code>, so you need to specify that the assignment operator template expects an <code>std::initializer_list</code>:</p>\n<pre><code>  template &lt;typename U&gt;\n  A&amp; operator=(std::initializer_list&lt;U&gt; other )\n  {\n    if ( other.size() == N )\n      std::copy_n( other.begin(), N, m_data );\n    return *this;\n  }\n</code></pre>\n<p>or</p>\n<pre><code>  A&amp; operator=(std::initializer_list&lt;double&gt; other )\n  {\n    if ( other.size() == N )\n      std::copy_n( other.begin(), N, m_data );\n    return *this;\n  }\n</code></pre>\n<p>I must say, an assignment operator that silently fails if the sizes don't match doesn't seem like a great idea.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2014-04-20T20:06:44.343", "Score": "1", "CreationDate": "2014-04-20T19:57:39.880", "ParentId": "23186775", "CommentCount": "3", "OwnerUserId": "661519", "LastEditDate": "2014-04-20T20:06:44.343"}, "23186975": {"Id": "23186975", "PostTypeId": "2", "Body": "<p>Unlike <code>auto</code>, where a braced-init-list is deduced as an <code>initializer_list</code>, template argument deduction considers it to be a non-deduced context, unless there exists a corresponding parameter of type <code>initializer_list&lt;T&gt;</code>, in which case the <code>T</code> can be deduced.</p>\n<p>From <em>\u00a714.8.2.1/1 [temp.deduct.call]</em> (emphasis added)</p>\n<blockquote>\n<p id=\"so_23186775_23186975_0\">Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with the type of the corresponding argument of the call (call it <code>A</code>) as described below. If removing references and cv-qualifiers from <code>P</code> gives <code>std::initializer_list&lt;P0&gt;</code> for some <code>P0</code> and the argument is an initializer\n  list (8.5.4), then deduction is performed instead for each element of the initializer list, taking <code>P0</code> as a function template parameter type and the initializer element as its argument. <strong>Otherwise, an initializer list argument causes the parameter to be considered a non-deduced context</strong> (14.8.2.5).</p>\n</blockquote>\n<p>Thus the argument to your <code>operator=</code> is not deduced to be an <code>initializer_list&lt;double&gt;</code>. For the code to work, you must define an <code>operator=</code> that takes an <code>initializer_list</code> argument.</p>\n<pre><code>template &lt;typename U&gt;\nself&amp; operator= ( const std::initializer_list&lt;T&gt;&amp; other )\n{\n    if ( other.size() == N )\n        std::copy_n( other.begin(), N, m_data );\n    return *this;\n}\n</code></pre>\n", "LastEditorUserId": "241631", "LastActivityDate": "2014-04-20T20:11:37.217", "Score": "2", "CreationDate": "2014-04-20T20:01:16.073", "ParentId": "23186775", "CommentCount": "3", "OwnerUserId": "241631", "LastEditDate": "2014-04-20T20:11:37.217"}});