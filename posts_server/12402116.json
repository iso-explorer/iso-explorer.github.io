post_cb({"12402880": {"Id": "12402880", "PostTypeId": "2", "Body": "<p>The standard doesn't say; as you say, it doesn't even require reference\ncounting.  On the other hand, there is (or was) a statement in the\nstandard (or at least in the C standard) that exceeding implementation\nlimits is undefined behavior.  So that's almost certainly the official\nanswer.</p>\n<p>In practice, I would expect most implementations to maintain the count\nas a <code>size_t</code> or a <code>ptrdiff_t</code>.  On machines with flat addressing, this\npretty much means that you cannot create enough references to cause an\noverflow.  (On such machines, a single object could occupy all of the\nmemory, and <code>size_t</code> or <code>ptrdiff_t</code> have the same size as a pointer. \nSince every reference counted pointer has a distinct address, there can\nnever be more than would fit in a pointer.)  On machines with segmented\narchitectures, however, overflow is quite conceivable.</p>\n<p>As Jon points out, the standard also requires\n<code>std::shared_ptr::use_count()</code> to return a <code>long</code>.  I'm not sure what\nthe rationale is here: either <code>size_t</code> or <code>ptrdiff_t</code> would make more\nsense here.  But if the implementation uses a different type for the\nreference count, presumably, the rules for conversion to <code>long</code> would\napply: \"the value is unchanged if it can be represented in the\ndestination type (and bit-field width); otherwise, the value is\nimplementation-defined.\"  (The C standard makes this somewhat clearer:\nthe \"implementation-defined value\" can be a signal.)</p>\n", "LastActivityDate": "2012-09-13T09:04:42.003", "CommentCount": "2", "CreationDate": "2012-09-13T09:04:42.003", "ParentId": "12402116", "Score": "7", "OwnerUserId": "649665"}, "12402116": {"ViewCount": "3189", "Body": "<p>If we assume that <code>std::shared_ptr</code> stores a reference count (which I realize the standard does not require, but I am unaware of any implementations that don't), that reference count has a limited number of bits, and that means there is a maximum number of references that are supported.  That leads to two questions:</p>\n<ul>\n<li>What is this maximum value?</li>\n<li>What happens if you try to exceed it (e.g., by copying a std::shared_ptr that refers to an object with the maximum reference count)?  Note that <code>std::shared_ptr</code>'s copy constructor is declared <code>noexcept</code>.</li>\n</ul>\n<p>Does the standard shed any light on either of these questions?  How about common implementations, e.g., gcc, MSVC, Boost?</p>\n", "AcceptedAnswerId": "12402162", "Title": "What is the maximum reference count in std::shared_ptr? What happens if you try to exceed it?", "CreationDate": "2012-09-13T08:17:42.570", "Id": "12402116", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-09-04T15:31:31.587", "LastEditorUserId": "1228", "LastActivityDate": "2016-09-18T10:27:39.450", "Score": "19", "OwnerUserId": "1426649", "Tags": "<c++><c++11><shared-ptr><reference-counting>", "AnswerCount": "5"}, "12402197": {"Id": "12402197", "PostTypeId": "2", "Body": "<p>I'm not sure what the standard suggests, but look at it practically:</p>\n<p>The <em>reference count</em> is most likely some sort of <code>std::size_t</code> variable. This variable can hold values up to <code>-1+2^32</code> in 32-Bit environments and up to <code>-1+2^64</code> in 64-Bit environments.</p>\n<p>Now Image what would have to happen for this variable to reach this value: you would need 2^32 or 2^64 <code>shared_ptr</code> instances. That's a lot. In fact, that's so many that all memory would be exhausted long before you reach this number, since a one <code>shared_ptr</code> is about 8/16 bytes large.</p>\n<p>Therefor, you are very unlikely to be able to reach the limit of the reference count if the size of the refcount variable is large enough.</p>\n", "LastEditorUserId": "429322", "LastActivityDate": "2012-09-13T08:41:26.483", "Score": "7", "CreationDate": "2012-09-13T08:24:08.297", "ParentId": "12402116", "CommentCount": "5", "OwnerUserId": "429322", "LastEditDate": "2012-09-13T08:41:26.483"}, "bq_ids": {"n4140": {"so_12402116_12402162_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4432}}, "n3337": {"so_12402116_12402162_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4269}}, "n4659": {"so_12402116_12402162_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5696}}}, "39556635": {"Id": "39556635", "PostTypeId": "2", "Body": "<p>The C++11 standard specifies <code>long</code> as the return type of the <code>use_count()</code> observer function, but doesn't explicitly specify if an implementation must support up to <code>2^(sizeof(long)*8-1)-1</code> shared ownerships.</p>\n<p>It also doesn't specify what happens when the reference counter overflows.</p>\n<p>The <code>boost::shared_ptr</code> implementation (e.g. 1.58 on Fedora 23, x86-64) internally uses 32 Bit counter and doesn't check for overflows.</p>\n<p>That means:</p>\n<ol>\n<li>the maximum reference count is <code>2^31-1</code>.</li>\n<li>if you have an overflow and release ownership you may end up with some use-after-free issues</li>\n</ol>\n<p>Since boost uses different low-level specializations for different platforms you can verify the details via setting a breakpoint in <code>*add_ref_lock</code> - on Fedora 23/x86-64 you'll stop here:</p>\n<pre><code>/usr/include/boost/smart_ptr/detail/sp_counted_base_gcc_x86.hpp\n[..]\nint use_count_;        // #shared\nint weak_count_;       // #weak + (#shared != 0)\n[..]\nbool add_ref_lock() // true on success\n{\n    return atomic_conditional_increment( &amp;use_count_ ) != 0;\n}\n</code></pre>\n<p>See also:</p>\n<ul>\n<li><a href=\"https://svn.boost.org/trac/boost/ticket/12335\" rel=\"nofollow\">Integer overflow in use counter of shared pointers - Boost Ticket 12335</a></li>\n<li><a href=\"https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2016-ccs.pdf\" rel=\"nofollow\">Twice the Bits, Twice the Trouble: Vulnerabilities Induced by Migrating to 64-Bit Platforms</a></li>\n</ul>\n<p>The GNU STL (libstdc++) shared_pointer implementation is based on Boost 1.32 one and also has this issue (on Fedora 23/x86-64) - there the <code>_Atomic_word</code> type is used for reference counting. It is also 'only' 32 bit and isn't checked for overflow.</p>\n<p>In contrast, the LLVM libc++ <code>shared_ptr</code> implementation uses a <code>long</code> as reference counter, i.e. on LP64 platforms like x86-64 you can share an object between up to <code>2^63-1</code> owners.</p>\n", "LastActivityDate": "2016-09-18T10:27:39.450", "CommentCount": "0", "CreationDate": "2016-09-18T10:27:39.450", "ParentId": "12402116", "Score": "0", "OwnerUserId": "427158"}, "12415141": {"Id": "12415141", "PostTypeId": "2", "Body": "<p>You can find out what will happen by instantiating shared pointers using placement new and never deleting them. You can then hit the 32-bit limit easily.</p>\n", "LastActivityDate": "2012-09-13T21:37:21.517", "CommentCount": "0", "CreationDate": "2012-09-13T21:37:21.517", "ParentId": "12402116", "Score": "2", "OwnerUserId": "213348"}, "12402162": {"Id": "12402162", "PostTypeId": "2", "Body": "<p>We can get some information from the <code>shared_ptr::use_count()</code> function. \u00a720.7.2.2.5 says:</p>\n<pre><code>long use_count() const noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_12402116_12402162_0\">Returns: the number of <code>shared_ptr</code> objects, <code>*this</code> included, that share\n  ownership with <code>*this</code>, or <code>0</code> when <code>*this</code> is empty.</p>\n<p id=\"so_12402116_12402162_1\">[Note: <code>use_count()</code> is not necessarily efficient.\u2014end note ]</p>\n</blockquote>\n<p>At first sight the <code>long</code> return type seems to answer the first question. However the note seems to imply that <code>shared_ptr</code> is free to use any type of reference counting it wants to, including things like a list of references. If this were the case then theoretically there would be no maximum reference count (although there would certainly be a <em>practical</em> limit).</p>\n<p>There is no other reference to limits on the number of references to the same object that I could find.</p>\n<p>It's interesting to note that <code>use_count</code> is documented to both not throw and (obviously) to report the count correctly; unless the implementation does use a <code>long</code> member for the count I don't see how both of these can be theoretically guaranteed at all times.</p>\n", "LastEditorUserId": "50079", "LastActivityDate": "2012-09-13T08:38:31.710", "Score": "19", "CreationDate": "2012-09-13T08:20:50.910", "ParentId": "12402116", "CommentCount": "5", "OwnerUserId": "50079", "LastEditDate": "2012-09-13T08:38:31.710"}});