post_cb({"2824058": {"Id": "2824058", "PostTypeId": "2", "Body": "<p>And the reason your IDE shows friend B::B() as invalid syntax in the latter case? An IDE error.</p>\n<p>A workaround I found in gcc for the template case if you can't upgrade is to move the implementation of B() to a member function, void B::init(), and grant friendship to that instead. I'll bet this shuts up your IDE too.</p>\n<p>Even if you get this to compile, though, you'll run into the stack overflow problem as soon as you try to instantiate a B.</p>\n", "LastActivityDate": "2010-05-13T02:06:50.007", "CommentCount": "1", "CreationDate": "2010-05-13T02:06:50.007", "ParentId": "2823485", "Score": "1", "OwnerUserId": "329289"}, "bq_ids": {"n4140": {"so_2823485_2824067_1": {"length": 10, "quality": 1.0, "section_id": 367}, "so_2823485_2823485_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 111}, "so_2823485_2824067_2": {"length": 4, "quality": 0.8, "section_id": 5414}, "so_2823485_2824067_0": {"length": 28, "quality": 0.875, "section_id": 7114}}, "n3337": {"so_2823485_2824067_1": {"length": 10, "quality": 1.0, "section_id": 356}, "so_2823485_2823485_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 106}, "so_2823485_2824067_3": {"length": 12, "quality": 0.6666666666666666, "section_id": 388}, "so_2823485_2824067_2": {"length": 5, "quality": 1.0, "section_id": 357}, "so_2823485_2824067_0": {"length": 32, "quality": 1.0, "section_id": 6858}}, "n4659": {"so_2823485_2824067_1": {"length": 10, "quality": 1.0, "section_id": 379}, "so_2823485_2823485_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 115}, "so_2823485_2824067_2": {"length": 4, "quality": 0.8, "section_id": 6836}, "so_2823485_2824067_0": {"length": 28, "quality": 0.875, "section_id": 8615}}}, "2823811": {"Id": "2823811", "PostTypeId": "2", "Body": "<p>My guess you;re way into quirks territory here with friend templated constructors. This compiles and runs fine on VS2010 but it produces a stack overflow when default constructor of <code>A</code> calls the default constructor of <code>B</code> which then instantiates <code>A</code> again.</p>\n", "LastActivityDate": "2010-05-13T00:51:54.297", "CommentCount": "1", "CreationDate": "2010-05-13T00:51:54.297", "ParentId": "2823485", "Score": "0", "OwnerUserId": "129404"}, "2824007": {"Id": "2824007", "PostTypeId": "2", "Body": "<p>Per the resolution to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#147\" rel=\"noreferrer\">CWG defect 147</a> (the resolution was incorporated into C++03), the correct way to name a nontemplate constructor of a class template specialization is:</p>\n<pre><code>B&lt;int&gt;::B();\n</code></pre>\n<p>and not</p>\n<pre><code>B&lt;int&gt;::B&lt;int&gt;();\n</code></pre>\n<p>If the latter were allowed, there is an ambiguity when you have a constructor template specialization of a class template specialization:  would the second <code>&lt;int&gt;</code> be for the class template or the constructor template?  (see the defect report linked above for further information about that)</p>\n<p>So, the correct way to declare the constructor of a class template specialization as a friend is:</p>\n<pre><code>friend B&lt;int&gt;::B();\n</code></pre>\n<p>Comeau 4.3.10.1 and Intel C++ 11.1 both accept that form.  Neither Visual C++ 2008 nor Visual C++ 2010 accept that form, but both accept the (incorrect) form <code>friend B&lt;int&gt;::B&lt;int&gt;();</code> (I will file a defect report on Microsoft Connect).</p>\n<p>gcc does not accept either form prior to version 4.5.  <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=5023\" rel=\"noreferrer\">Bug 5023</a> was reported against gcc 3.0.2, but the requested resolution in the bug report was the invalid form.  It appears the resolution to <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=9050\" rel=\"noreferrer\">bug 9050</a> also resolves this issue and gcc 4.5 accepts the correct form.  Georg Fritzsche verified this in a comment to the question.</p>\n", "LastActivityDate": "2010-05-13T01:52:43.473", "CommentCount": "3", "CreationDate": "2010-05-13T01:52:43.473", "ParentId": "2823485", "Score": "5", "OwnerUserId": "151292"}, "2824067": {"Id": "2824067", "PostTypeId": "2", "Body": "<p>Doesn't a typedef help?  e.g.</p>\n<pre><code>class A : public B&lt;int&gt;\n{\n    typedef B&lt;int&gt; Base;   \n    friend Base::Base();\n    int x;\n};\n</code></pre>\n<p>EDIT: The Final Committee Draft for C++0x includes the following language in section 3.4.3.1 [<em>class.qual</em>]:</p>\n<blockquote>\n<p id=\"so_2823485_2824067_0\">In a lookup in which the constructor is an acceptable lookup result and the <em>nested-name-specifier</em> nominates a class <strong>C</strong>: if the name specified after the <em>nested-name-specifier</em>, when looked up in <strong>C</strong>, is the injected-class-name of <strong>C</strong> (Clause 9), or if the name specified after the <em>nested-name-specifier</em> is the same as the <em>identifier</em> or the <em>simple-template-id</em>\u2019s <em>template-name</em> in the last component of the <em>nested-name-specifier</em>, the name is instead considered to name the constructor of class <strong>C</strong>.</p>\n</blockquote>\n<p>Sounds like the name (<code>Base</code>) specified after the <em>nested-name-specifier</em> (<code>Base::</code>) is the same as the <em>identifier</em> in the last component of the <em>nested-name-specifier</em>, so this code does name a constructor.</p>\n<p>But I can't reconcile this with section 12.1 [<em>class.ctor</em>]:</p>\n<blockquote>\n<p id=\"so_2823485_2824067_1\">Because constructors do not have names, they are never found during name lookup</p>\n</blockquote>\n<p>Oh really?  How's that language in 3.4.3.1 work again?</p>\n<blockquote>\n<p id=\"so_2823485_2824067_2\">A <em>typedef-name</em> shall not be used as the <em>class-name</em> in the <em>declarator-id</em> for a constructor declaration.</p>\n</blockquote>\n<p>This seems pretty clear, except that section 12.1 appears to discuss only the introducing declaration of a constructor as paragraph 1 excludes the <em>nested-name-specifier</em>, <code>friend</code>, and <code>using</code>.  If it does apply to friend declarations, it also appears to forbid <code>friend Base::B();</code></p>\n<blockquote>\n<p id=\"so_2823485_2824067_3\">A  special declarator syntax using an optional sequence of <em>function-specifiers</em> (7.1.2) followed by the constructor\u2019s class name followed by a parameter list is used to declare or define the constructor.</p>\n</blockquote>\n<p>Those <em>function-specifiers</em> are <code>inline</code>, <code>virtual</code>, <code>explicit</code>, and constructors can't be <code>virtual</code> anyway.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2010-05-13T14:12:17.837", "Score": "1", "CreationDate": "2010-05-13T02:08:44.130", "ParentId": "2823485", "CommentCount": "5", "OwnerUserId": "103167", "LastEditDate": "2010-05-13T14:12:17.837"}, "2823485": {"ViewCount": "1284", "Body": "<p>Why does</p>\n<pre><code>class A;\ntemplate&lt;typename T&gt; class B\n{\nprivate: \n    A* a;\n\npublic:  \n    B();\n};\n\n\nclass A : public B&lt;int&gt;\n{\nprivate:    \n    friend B&lt;int&gt;::B&lt;int&gt;();\n    int x;\n};\n\n\ntemplate&lt;typename T&gt;\nB&lt;T&gt;::B()\n{\n    a = new A;\n    a-&gt;x = 5;\n}\n\nint main() { return 0; }\n</code></pre>\n<p>result in</p>\n<blockquote>\n<p id=\"so_2823485_2823485_0\">../src/main.cpp:15: error: invalid use of constructor as a template<br>\n  ../src/main.cpp:15: note: use \u2018B::B\u2019 instead of \u2018B::class B\u2019 to name the constructor in a qualified name</br></p>\n</blockquote>\n<p>yet changing <code>friend B&lt;int&gt;::B&lt;int&gt;()</code> to <code>friend B&lt;int&gt;::B()</code> results in</p>\n<blockquote>\n<p id=\"so_2823485_2823485_1\">../src/main.cpp:15: error: no \u2018void B::B()\u2019 member function declared in class \u2018B\u2019</p>\n</blockquote>\n<p>while removing the template completely</p>\n<pre><code>class A;\nclass B\n{\nprivate:\n    A* a;\n\npublic:\n    B();\n};\n\n\nclass A : public B\n{\nprivate:\n    friend B::B();\n    int x;\n};\n\n\nB::B()\n{\n    a = new A;\n    a-&gt;x = 5;\n}\n\nint main() { return 0; }\n</code></pre>\n<p>compiles and executes just fine -- despite my IDE saying friend B::B() is invalid syntax?</p>\n", "AcceptedAnswerId": "2824007", "Title": "How to befriend a templated class's constructor?", "CreationDate": "2010-05-12T23:25:53.203", "Id": "2823485", "CommentCount": "9", "PostTypeId": "1", "LastActivityDate": "2010-05-13T14:12:17.837", "Score": "6", "OwnerUserId": "285883", "Tags": "<c++><templates><gcc><constructor><friend>", "AnswerCount": "4"}});