post_cb({"5818687": {"CommentCount": "0", "ViewCount": "317", "PostTypeId": "1", "LastEditorUserId": "227466", "CreationDate": "2011-04-28T12:37:06.523", "LastActivityDate": "2011-04-28T13:48:00.823", "Title": "set difference for duplicates in the second range, alternative remove_copy", "AcceptedAnswerId": "5819236", "LastEditDate": "2011-04-28T12:48:21.067", "Id": "5818687", "Score": "3", "Body": "<p>I have two arrays or vectors, say:</p>\n<pre><code>  int first[] = {0,0,1,1,2,2,3,3,3};\n  int second[] = {1,3};\n</code></pre>\n<p>I would like to get rid of the 1s and 3s in the first set, <strong>set_difference</strong> can only get rid of the first occurrences of these values however this is not what I want to have. </p>\n<p>Should I do this with <strong>remove_copy</strong> by iterating on the second range and each time remove one entry from the first set. </p>\n<p>What would be the best way to do this in C++?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "308476", "AnswerCount": "4"}, "5819015": {"ParentId": "5818687", "CommentCount": "4", "Body": "<p>Are you sure set_difference won't work? The standard in 25.3.5 says </p>\n<blockquote>\n<p id=\"so_5818687_5819015_0\">This section defines all the basic set\n  operations on sorted structures. They\n  also work with multisets containing\n  multiple copies of equivalent\n  elements.</p>\n</blockquote>\n<p>And the description of set_difference just says it gives you everything in first not in second, which is what you want.</p>\n", "OwnerUserId": "212870", "PostTypeId": "2", "Id": "5819015", "Score": "1", "CreationDate": "2011-04-28T13:00:25.757", "LastActivityDate": "2011-04-28T13:00:25.757"}, "5818730": {"ParentId": "5818687", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The general solution, for when <code>second</code> has more than a few elements: make an <code>std::set</code> (or <code>unordered_set</code>) of the elements in <code>second</code>, then loop through <code>first</code>, removing anything that is not the set. (By loop I mean <code>for</code>, <code>while</code>, <code>remove_if</code>, whatever.)</p>\n", "OwnerUserId": "166749", "LastEditorUserId": "166749", "LastEditDate": "2011-04-28T12:51:49.340", "Id": "5818730", "Score": "0", "CreationDate": "2011-04-28T12:39:45.507", "LastActivityDate": "2011-04-28T12:51:49.340"}, "5819236": {"ParentId": "5818687", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Write a specialised set_difference:</p>\n<pre><code>template &lt;typename InputIterator1, typename InputIterator2, typename OutputIterator&gt;\nOutputIterator set_difference_any( InputIterator1 first1, InputIterator1 last1,\n                                   InputIterator2 first2, InputIterator2 last2,\n                                   OutputIterator result )\n{\n  while ( first1 != last1 &amp;&amp; first2 != last2 )\n    if ( *first1 &lt; *first2 ) {\n      *result = *first1;\n      ++first1;\n      ++result;\n    } else if ( *first2 &lt; *first1 ) {\n      ++first2;\n    } else {\n      ++first1;\n      //++first2; // this is the difference to set_difference\n    }\n  return std::copy( first1, last1, result );\n}\n</code></pre>\n<p>Then apply it to the problem:</p>\n<pre><code>#include \"set_difference_any.h\"\n#include &lt;boost/range.hpp&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n\nstd::vector&lt;int&gt; result;\nset_difference_any( boost::begin( first ), boost::end( first ),\n                    boost::begin( second ), boost::end( second ),\n                    std::back_inserter( result ) );\n</code></pre>\n<p>This algorithm is linear (max. <code>last1-first1 + last2-first2</code> comparisions)</p>\n", "OwnerUserId": "134841", "LastEditorUserId": "134841", "LastEditDate": "2011-04-28T13:48:00.823", "Id": "5819236", "Score": "0", "CreationDate": "2011-04-28T13:17:07.140", "LastActivityDate": "2011-04-28T13:48:00.823"}, "5818956": {"ParentId": "5818687", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You should write simple function or functional which returns <code>true</code> if element is in <code>second</code> and <code>false</code> otherwise (lets call it <code>ok</code>). And then use <code>std::remove_if</code> or <code>std::remove_copy_if</code>:</p>\n<pre><code>first.erase(std::remove_if(first.begin(), first.end(), ok));\n</code></pre>\n<p>P.S. considered that <code>first</code> is <code>std::vector&lt;int&gt;</code> and not array.</p>\n", "OwnerUserId": "509233", "LastEditorUserId": "509233", "LastEditDate": "2011-04-28T13:12:15.727", "Id": "5818956", "Score": "1", "CreationDate": "2011-04-28T12:56:57.373", "LastActivityDate": "2011-04-28T13:12:15.727"}, "bq_ids": {"n4140": {"so_5818687_5819015_0": {"section_id": 1443, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_5818687_5819015_0": {"section_id": 1437, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_5818687_5819015_0": {"section_id": 1581, "quality": 0.9444444444444444, "length": 17}}}});