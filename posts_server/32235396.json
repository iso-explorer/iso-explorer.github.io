post_cb({"32235396": {"CommentCount": "3", "AcceptedAnswerId": "32235445", "PostTypeId": "1", "LastEditorUserId": "2784509", "CreationDate": "2015-08-26T19:43:53.220", "LastActivityDate": "2015-08-26T20:05:16.037", "LastEditDate": "2015-08-26T20:05:16.037", "ViewCount": "138", "FavoriteCount": "1", "Title": "enable_if for functions with no return type pulled in it", "Id": "32235396", "Score": "5", "Body": "<p>I've recently encountered an interesting version of <code>enable_if</code> usage to conditionally enable a function with slightly better readability because the function's return type is not part of <code>enable_if</code> (see <code>cleaner_usage</code>):</p>\n<pre><code>#include &lt;type_traits&gt;\n\nusing maybe_integral = int /* = or float -- then won't compile */;\nusing return_type = int;\n\ntypename std::enable_if&lt;std::is_integral&lt;maybe_integral&gt;::value, return_type&gt;::type\ntraditional_usage()\n{\n    return 1;\n}\n\ntemplate&lt;typename std::enable_if&lt;std::is_integral&lt;maybe_integral&gt;::value, int&gt;::type = 0&gt;\nreturn_type cleaner_usage()\n{\n    return 2;\n}\n\nint main()\n{\n    return traditional_usage() + cleaner_usage();\n}\n</code></pre>\n<p>For failure-case the mechanism is clear (no <code>type</code> member). </p>\n<p><strong>But how exactly does it work in other cases? Because it looks like <code>int</code> <code>typedef</code> field substituted into template type parameter with unexpected assignment.</strong></p>\n", "Tags": "<c++><c++11><enable-if>", "OwnerUserId": "2784509", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32235396_32235445_0": {"section_id": 57, "quality": 1.0, "length": 8}}, "n3337": {"so_32235396_32235445_0": {"section_id": 52, "quality": 1.0, "length": 8}}, "n4659": {"so_32235396_32235445_0": {"section_id": 59, "quality": 1.0, "length": 8}}}, "32235445": {"ParentId": "32235396", "CommentCount": "0", "Body": "<p>In the success-case:</p>\n<pre><code>template&lt;typename std::enable_if&lt;std::is_integral&lt;float&gt;::value, int&gt;::type = 0&gt;\nreturn_type cleaner_usage()\n{\n    return 2;\n}\n</code></pre>\n<p>would become equivalent to:</p>\n<pre><code>template&lt;int = 0&gt;\nreturn_type cleaner_usage()\n{\n    return 2;\n}\n</code></pre>\n<p>Which is perfectly legal, given that some value types are allowed to appear in template parameter context. I believe these are formally called <em>non-type template parameters</em>, as described by \u00a714.1/4:</p>\n<blockquote>\n<p id=\"so_32235396_32235445_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>\n<ul>\n<li>integral or enumeration type,</li>\n<li>pointer to object or pointer to function,</li>\n<li>lvalue reference to object or lvalue reference to function,</li>\n<li>pointer to member,</li>\n<li><code>std::nullptr_t</code>.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "493122", "PostTypeId": "2", "Id": "32235445", "Score": "5", "CreationDate": "2015-08-26T19:47:45.333", "LastActivityDate": "2015-08-26T19:47:45.333"}});