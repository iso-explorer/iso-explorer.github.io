post_cb({"42177900": {"ParentId": "42177791", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2017-02-11T15:53:16.640", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:00.903", "Id": "42177900", "OwnerUserId": "951890", "Body": "<p><a href=\"https://stackoverflow.com/users/273767/cubbi\" title=\"Cubbi\">Cubbi</a> has the right answer here.  The real issue is not joining the threads.  I'll leave the rest here for reference:</p>\n<p>You should be seeing the output in an unpredictable order, but it shouldn't be producing duplicate values.  In general <code>iostream</code>s are not thread safe:</p>\n<p>From C++14: 27.2.3 [iostreams.threadsafety]</p>\n<blockquote>\n<p id=\"so_42177791_42177900_0\">Concurrent access to a stream object (27.8, 27.9), stream buffer object (27.6), or C Library stream (27.9.2)\n  by multiple threads may result in a data race (1.10) unless otherwise specified (27.4). [ Note: Data races\n  result in undefined behavior (1.10). \u2014 end note ]</p>\n</blockquote>\n<p>However 27.4 gives an exception that applies in this case:</p>\n<blockquote>\n<p id=\"so_42177791_42177900_1\">FILEs, Concurrent access to a synchronized (27.5.3.4) standard iostream object\u2019s formatted and unformatted in-\n  put (27.7.2.1) and output (27.7.3.1) functions or a standard C stream by multiple threads shall not result\n  in a data race (1.10). [ Note: Users must still synchronize concurrent use of these objects and streams by\n  multiple threads if they wish to avoid interleaved characters. \u2014 end note ]</p>\n</blockquote>\n<p>Since <code>cout</code> is synchronized, this should be thread safe.</p>\n", "LastActivityDate": "2017-02-11T16:37:36.293"}, "42178292": {"ParentId": "42177791", "CommentCount": "0", "CreationDate": "2017-02-11T16:29:01.847", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "42178292", "Score": "2", "Body": "<p>Main problems of this program are:</p>\n<ol>\n<li>falling off the end of a function with a declared return type</li>\n<li>not joining the threads</li>\n<li>using std::cout from multiple threads without synchronization</li>\n</ol>\n<p>3 is technically not necessary (if you fix 1 and 2) because output through std::cout by default is thread-safe, as in, not a data race, but the output can be interleaved.</p>\n<p>Now, for the interesting part of the question</p>\n<blockquote>\n<p id=\"so_42177791_42178292_0\">the same number occures more than once. I'm not sure why is that.</p>\n</blockquote>\n<p>Assuming you're using Linux or something similar, when the main function exists, it executes <code>exit</code> which, in the GNU C runtime, executes <code>__run_exit_handlers</code>, which then calls <code>_IO_cleanup</code>. The job of <code>_IO_cleanup</code> is to write out any unwritten output buffers. If that happens <em>while</em> one of your other threads is in the middle of writing, such as inside the <code>write(2)</code> system call, <code>_IO_cleanup</code> will look at the buffer state and see that it's still \"full\" (<code>_IO_file_write</code> in the thread would update the buffer position indicator when it returns from <code>write(2)</code>). So according to cleanup, the buffer isn't written yet, and it initiates its own <code>write(2)</code> system call on the same buffer.</p>\n", "LastActivityDate": "2017-02-11T16:29:01.847"}, "42177791": {"CommentCount": "4", "ViewCount": "78", "PostTypeId": "1", "LastEditorUserId": "6695164", "CreationDate": "2017-02-11T15:44:58.277", "LastActivityDate": "2017-02-11T16:37:36.293", "Title": "Why does this code output the same number multiple times?", "AcceptedAnswerId": "42178292", "LastEditDate": "2017-02-11T16:33:13.170", "Id": "42177791", "Score": "2", "Body": "<p>Running the following code multiple times produces output where the same number occurs more than once. I'm not sure why is that. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n\nusing namespace std;\n\nconst int NUM_THREADS = 5;\n\nvoid* thread_entry(void *i){\n   cout&lt;&lt;(long)i&lt;&lt;endl;\n}\n\nint main () {\n  pthread_t threads[NUM_THREADS];\n\n  long i;\n  for(i=0;i&lt;NUM_THREADS;i++){\n    pthread_create(&amp;threads[i],NULL,&amp;thread_entry,(void *)i);\n  }\n\n  return 0;\n}\n</code></pre>\n<p>It is compiled with <code>g++ -std=c++11 main.cpp -lpthread</code>.</p>\n<p>The output:</p>\n<pre><code>$ ./a.out \n0\n1\n4\n$ ./a.out \n014\n14\n23\n$ ./a.out \n02\n2\n3\n</code></pre>\n", "Tags": "<c++><multithreading><pthreads>", "OwnerUserId": "6695164", "AnswerCount": "3"}, "42178050": {"ParentId": "42177791", "CommentCount": "0", "CreationDate": "2017-02-11T16:06:14.587", "OwnerUserId": "5483521", "PostTypeId": "2", "Id": "42178050", "Score": "0", "Body": "<p>In multithreading there is no guarantee that the code in a thread will run before or after the code in another thread without any synchronization mechanism between.</p>\n<p>You have a main thread and other threads created by the main thread and you cannot expect the number 'i' will not be cout'ed <em>before</em> the main thread's for loop increase it.</p>\n", "LastActivityDate": "2017-02-11T16:06:14.587"}, "bq_ids": {"n4140": {"so_42177791_42177900_1": {"section_id": 1922, "quality": 0.7692307692307693, "length": 30}, "so_42177791_42177900_0": {"section_id": 1907, "quality": 0.6875, "length": 22}}, "n3337": {"so_42177791_42177900_1": {"section_id": 1911, "quality": 0.7692307692307693, "length": 30}, "so_42177791_42177900_0": {"section_id": 1896, "quality": 0.6875, "length": 22}}, "n4659": {"so_42177791_42177900_1": {"section_id": 2193, "quality": 0.7692307692307693, "length": 30}, "so_42177791_42177900_0": {"section_id": 2177, "quality": 0.6875, "length": 22}}}});