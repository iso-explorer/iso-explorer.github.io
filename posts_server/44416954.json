post_cb({"bq_ids": {"n4140": {"so_44416954_44417452_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 190}}, "n3337": {"so_44416954_44417452_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 184}}, "n4659": {"so_44416954_44417452_0": {"length": 24, "quality": 1.0, "section_id": 195}}}, "44417428": {"Id": "44417428", "PostTypeId": "2", "Body": "<p>Yes, it is. Basically <code>data</code> depends on <code>T</code>. </p>\n<p>There is a mechanism called two-phase lookup. Non-(template)dependent names are resolved immediately - at the point of <em>definition</em>. Your <code>data</code> does not exist yet, because <code>Base&lt;T&gt;</code> does not exist yet, as it was not <em>instantiated</em>. Thus, it complains that <code>data</code> is not found.</p>\n<p>You need to hint compiler that <code>data</code> depends on the template, and the name lookup should be performed in the second phase, after template parameters are substituted, i.e. template class was instantiated. This can be done by using <code>this</code> or providing template dependent scope.</p>\n<p>So, either <code>this-&gt;f()</code> or <code>Base&lt;T&gt;::f()</code> will work.</p>\n", "LastEditorUserId": "1133179", "LastActivityDate": "2017-06-07T15:58:11.917", "Score": "15", "CreationDate": "2017-06-07T15:50:49.680", "ParentId": "44416954", "CommentCount": "0", "LastEditDate": "2017-06-07T15:58:11.917", "OwnerUserId": "1133179"}, "44417452": {"Id": "44417452", "PostTypeId": "2", "Body": "<p>Clang is correct.</p>\n<p><a href=\"http://eel.is/c++draft/temp.dep#3\" rel=\"noreferrer\">$17.6.2/3 Dependent names [temp.dep]</a></p>\n<blockquote>\n<p id=\"so_44416954_44417452_0\">In the definition of a class or class template, the scope of a dependent base class is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p>For <code>return data;</code>, <code>data</code> is <em>unqualified</em>, then unqualified name lookup will be employed. This means the name in the base class <code>Base&lt;T&gt;</code> (which is a dependent base class because it depends on the template parameter <code>T</code>) shouldn't be found; i.e. the non-dependent names are not looked up in dependent base classes.</p>\n<p><code>this-&gt;data</code> or <code>Base&lt;T&gt;::data</code> makes it <em>qualified</em>. This means the name will be looked up at the time of instantiation, and at that time the exact base specialization that must be explored will be known.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-06-08T13:58:21.277", "Score": "27", "CreationDate": "2017-06-07T15:51:36.450", "ParentId": "44416954", "CommentCount": "4", "LastEditDate": "2017-06-08T13:58:21.277", "OwnerUserId": "3309790"}, "44416954": {"ViewCount": "1013", "Body": "<p>This code compiles with MSVC 2015, but doesn't compile with Clang 5.0.0 (trunk 304874):</p>\n<pre><code>template &lt;typename T&gt;\nstruct Base\n{\n  T data;\n};\n\ntemplate &lt;typename T&gt;\nstruct Derived : Base&lt;T&gt;\n{\n  auto getData() const\n  {\n    return data;\n  }\n};\n</code></pre>\n<p>Replacing <code>data</code> with <strong><code>this-&gt;data</code></strong> in <code>Derived::getdata()</code> makes Clang happy.</p>\n<p>Which compiler is correct according to the C++ standard?</p>\n<p>Must <code>this-&gt;</code> be used in template code to access an identifier of a base class?</p>\n", "AcceptedAnswerId": "44417452", "Title": "Is this-> mandatory to access Base<T> identifiers from derived classes?", "CreationDate": "2017-06-07T15:29:57.520", "Id": "44416954", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-06-07T16:05:19.950", "LastEditorUserId": "3309790", "LastActivityDate": "2017-06-10T21:10:47.363", "Score": "26", "OwnerUserId": "1629821", "Tags": "<c++><templates><inheritance><language-lawyer><name-lookup>", "AnswerCount": "2"}});