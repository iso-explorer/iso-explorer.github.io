post_cb({"17625758": {"ParentId": "17625635", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As long as they are <a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\" rel=\"nofollow\">is_trivially_copyable</a>, it is safe.</p>\n<p>\u00a7 3.9.2</p>\n<blockquote>\n<p id=\"so_17625635_17625758_0\">For any object (other than a base-class subobject) of <strong>trivially copyable type T</strong>, whether or not the object holds a valid value of type T, the underlying bytes (1.7) making up the object can be copied into an array of char or unsigned char.40 If the content of the array of char or unsigned char is copied back into the object, the object shall subsequently hold its original value.  </p>\n</blockquote>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj; // obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N); // between these two calls to std::memcpy,\n                           // obj might be modified\nstd::memcpy(&amp;obj, buf, N); // at this point, each subobject of obj of scalar type\n                           // holds its original value\n</code></pre>\n<p>\u00a7 3.9.3</p>\n<p>For any <strong>trivially copyable type T</strong>, if two pointers to T point to distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a base-class subobject, if the underlying bytes (1.7) making up obj1 are copied into obj2,41 obj2 shall subsequently hold the same value as obj1. [ Example:</p>\n<pre><code>T* t1p;\nT* t2p;\n    // provided that t2p points to an initialized object ...\nstd::memcpy(t1p, t2p, sizeof(T));\n    // at this point, every subobject of trivially copyable type in *t1p contains\n    // the same value as the corresponding subobject in *t2p\n</code></pre>\n", "OwnerUserId": "951757", "LastEditorUserId": "951757", "LastEditDate": "2013-07-13T01:24:10.680", "Id": "17625758", "Score": "5", "CreationDate": "2013-07-13T00:15:12.763", "LastActivityDate": "2013-07-13T01:24:10.680"}, "17625664": {"ParentId": "17625635", "CommentCount": "2", "Body": "<p>You should consider the template <a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\"><code>is_trivially_copyable</code></a> provided by C++11 that is useful to understand if it safe to <code>memcpy</code> a given type. If the value is <code>false</code> then the result is undefined.</p>\n", "OwnerUserId": "121747", "PostTypeId": "2", "Id": "17625664", "Score": "7", "CreationDate": "2013-07-13T00:01:00.187", "LastActivityDate": "2013-07-13T00:01:00.187"}, "17625635": {"CommentCount": "3", "ViewCount": "736", "CreationDate": "2013-07-12T23:57:41.400", "LastActivityDate": "2013-07-13T01:24:10.680", "Title": "moving an object in memory using std::memcpy", "AcceptedAnswerId": "17625758", "PostTypeId": "1", "Id": "17625635", "Score": "3", "Body": "<p>Is it allowed to move a class instance object from one location to another (for example, by using <code>std::memcpy</code> or <code>std::memove</code>? Assume both source and destination locations have the same alignment. Then casting the destination \"object\" into the type of the source object and calling into it. What part of the C++11 standard forbids this?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1095108", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17625635_17625758_0": {"section_id": 7200, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_17625635_17625758_0": {"section_id": 6944, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_17625635_17625758_0": {"section_id": 8709, "quality": 0.8780487804878049, "length": 36}}}});