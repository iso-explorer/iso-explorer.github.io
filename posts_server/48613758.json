post_cb({"bq_ids": {"n4140": {"so_48613758_48614393_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 5408}, "so_48613758_48627879_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5408}, "so_48613758_48627879_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5415}, "so_48613758_48613758_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 5408}, "so_48613758_48613758_1": {"length": 21, "quality": 1.0, "section_id": 5415}, "so_48613758_48613758_2": {"length": 24, "quality": 1.0, "section_id": 7137}}, "n3337": {"so_48613758_48614393_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 5203}, "so_48613758_48627879_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5203}, "so_48613758_48613758_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 5203}, "so_48613758_48627879_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5210}, "so_48613758_48613758_1": {"length": 21, "quality": 1.0, "section_id": 5210}, "so_48613758_48613758_2": {"length": 24, "quality": 1.0, "section_id": 6881}}, "n4659": {"so_48613758_48614393_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 6830}, "so_48613758_48627879_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6830}, "so_48613758_48613758_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 6830}, "so_48613758_48627879_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6837}, "so_48613758_48613758_1": {"length": 21, "quality": 1.0, "section_id": 6837}, "so_48613758_48613758_2": {"length": 24, "quality": 1.0, "section_id": 8638}}}, "48627879": {"Id": "48627879", "PostTypeId": "2", "Body": "<p>It looks like the standard is unclear on this.</p>\n<p>On one hand, </p>\n<blockquote>\n<p id=\"so_48613758_48627879_0\"><strong>[dcl.typedef]</strong> A <em>typedef-name</em> can also be introduced by an <em>alias-declaration</em>. [...] Such a <em>typedef-name</em> has the same semantics as if it were introduced by the <code>typedef</code> specifier.</p>\n</blockquote>\n<p>On the other hand, the standard clearly separates the notions of typedef declaration and <em>alias-declaration</em> (the latter term is a grammar production name, so it is italicised and hyphenated; the former is not). In some contexts it talks about \"a typedef declaration or <em>alias-declaration</em>\", making them equivalent in these contexts; and sometimes it talks solely about \"a typedef declaration\". In particular, whenever the standard talks about linkage and typedef declarations, it only talks about typedef declarations and does not mention <em>alias-declaration</em>. This includes the key passage</p>\n<blockquote>\n<p id=\"so_48613758_48627879_1\"><strong>[dcl.typedef]</strong> If the typedef declaration defines an unnamed class (or enum), the first <em>typedef-name</em> declared by the declaration to be that class type (or enum type) is used to denote the class type (or enum type) for linkage\n  purposes only.</p>\n</blockquote>\n<p>Note the standard insists on the <strong>first</strong> <em>typedef-name</em> being used for linkage. This means that in</p>\n<pre><code>typedef struct { int x; } A, B;\n</code></pre>\n<p>only <code>A</code> is used for linkage, and <code>B</code> is not. Nothing in the standard indicates that a name introduced by <em>alias-declaration</em> should behave like <code>A</code> and not like <code>B</code>.</p>\n<p>It is my opinion that the standard is insufficiently clear in this area. If the intent is to make only typedef declaration work for linkage, then it would be appropriate to state explicitly in [dcl.typedef] that <em>alias-declaration</em> does not. If the intent is to make <em>alias-declaration</em> work for linkage, this should be stated explicitly too, as is done in other contexts.</p>\n", "LastActivityDate": "2018-02-05T17:10:25.847", "Score": "3", "CreationDate": "2018-02-05T17:10:25.847", "ParentId": "48613758", "CommentCount": "3", "OwnerUserId": "775806"}, "48614393": {"Id": "48614393", "PostTypeId": "2", "Body": "<p>This looks to me like a bug in GCC.</p>\n<blockquote>\n<p id=\"so_48613758_48614393_0\">Note that [decl.typedef] does not say that an alias declaration is a typedef declaration</p>\n</blockquote>\n<p>You're right, [dcl.dcl]p9 gives a definition of the term <em>typedef declaration</em> which excludes <em>alias-declaration</em>s. However, [dcl.typedef] does explicitly say, as you quoted in your question:</p>\n<blockquote>\n<p id=\"so_48613758_48614393_1\">2 A <em>typedef-name</em> can also be introduced by an <em>alias-declaration</em>. The <em>identifier</em> following the <code>using</code> keyword becomes a <em>typedef-name</em> and the optional <em>attribute-specifier-seq</em> following the <em>identifier</em> appertains to that <em>typedef-name</em>. <strong>It has the same semantics as if it were introduced by the <code>typedef</code> specifier.</strong> [...]</p>\n</blockquote>\n<p>\"The same semantics\" doesn't leave any doubt. Under GCC's interpretation, <code>typedef</code> and <code>using</code> have different semantics, therefore the only reasonable conclusion is that GCC's interpretation is wrong. Any rules applying to typedef declarations must be interpreted as applying to alias-declarations as well.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2018-02-05T16:24:41.750", "Score": "10", "CreationDate": "2018-02-05T00:29:21.760", "ParentId": "48613758", "CommentCount": "5", "OwnerUserId": "743382", "LastEditDate": "2018-02-05T16:24:41.750"}, "48613758": {"ViewCount": "417", "Body": "<h2>Background</h2>\n<p>Everybody agrees that</p>\n<pre><code>using &lt;typedef-name&gt; = &lt;type&gt;;\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>typedef &lt;type&gt; &lt;typedef-name&gt;;\n</code></pre>\n<p>and that the former is to be preferred to the latter for various reasons (see Scott Meyers, Effective Modern C++ and various related questions on stackoverflow).</p>\n<p>This is backed by [dcl.typedef]:</p>\n<blockquote>\n<p id=\"so_48613758_48613758_0\">A typedef-name can also be introduced by an alias-declaration. The identifier following the using keyword\n  becomes a typedef-name and the optional attribute-specifier-seq following the identifier appertains to that\n  typedef-name. Such a typedef-name has the same semantics as if it were introduced by the typedef specifier.</p>\n</blockquote>\n<p>However, consider a declaration such as</p>\n<pre><code>typedef struct {\n    int val;\n} A;\n</code></pre>\n<p>For this case, [dcl.typedef] specifies:</p>\n<blockquote>\n<p id=\"so_48613758_48613758_1\">If the typedef declaration defines an unnamed class (or enum), the first typedef-name declared by the\n  declaration to be that class type (or enum type) is used to denote the class type (or enum type) for linkage\n  purposes only (3.5).</p>\n</blockquote>\n<p>The referenced section 3.5 [basic.link] says</p>\n<blockquote>\n<p id=\"so_48613758_48613758_2\">A name having namespace scope that has not\n  been given internal linkage above has the same linkage as the enclosing namespace if it is the name of\n  [...]\n  an unnamed class defined in a typedef declaration in which the class has\n  the typedef name for linkage purposes [...]</p>\n</blockquote>\n<p>Assuming the typedef declaration above is done in the global namespace, the struct <code>A</code> would have external linkage, since the global namespace has external linkage.</p>\n<h2>Question</h2>\n<p>The question is now whether the same is true, if the typedef declaration is replaced by an alias declaration according to the common notion that they are equivalent:</p>\n<pre><code>using A = struct {\n    int val;\n};\n</code></pre>\n<p>In particular, does the type <code>A</code> declared via the alias declaration (\"using\") have the same linkage as the one declared via the typedef declaration?</p>\n<p>Note that [decl.typedef] does not say that an alias declaration <em>is a</em> typedef declaration (it only says that both introduce a typedef-name) and that [decl.typedef] speaks only of a <em>typedef declaration</em> (not an alias declaration) having the property of introducing a <em>typedef name for linkage purposes</em>.\nIf the alias declaration is not capable of introducing a typedef name for linkage purposes, <code>A</code> would just be an alias for an anonymous type and have no linkage at all.</p>\n<p>IMO, that's at least one possible, albeit strict, interpretation of the standard. Of course, I may be overlooking something.</p>\n<p>This raises the subsequent questions:</p>\n<ul>\n<li>If there is indeed this subtle difference, is it by intention or is\nit an oversight in the standard?</li>\n<li>What is the expected behavior of compilers/linkers? </li>\n</ul>\n<h2>Research</h2>\n<p>The following minimal program consisting of three files (we need at least two separate compilation units) is used to investigate the issue.</p>\n<h3>a.hpp</h3>\n<pre><code>#ifndef A_HPP\n#define A_HPP\n\n#include &lt;iosfwd&gt;\n\n#if USING_VS_TYPEDEF\nusing A = struct {\n     int val;\n};\n#else\ntypedef struct {\n     int val;\n} A;\n#endif\n\nvoid print(std::ostream&amp; os, A const&amp; a);\n\n#endif // A_HPP\n</code></pre>\n<h3>a.cpp</h3>\n<pre><code>#include \"a.hpp\"\n#include &lt;iostream&gt;\n\nvoid print(std::ostream&amp; os, A const&amp; a)\n{\n   os &lt;&lt; a.val &lt;&lt; \"\\n\";\n}\n</code></pre>\n<h3>main.cpp</h3>\n<pre><code>#include \"a.hpp\"\n#include &lt;iostream&gt;\n\nint main()\n{\n    A a;\n    a.val = 42;\n    print(std::cout, a);\n}\n</code></pre>\n<h2>GCC</h2>\n<p>Compiling this with gcc 7.2 with the \"typedef\" variant compiles cleanly and provides the expected output:</p>\n<pre><code>&gt; g++ -Wall -Wextra -pedantic-errors -DUSING_VS_TYPEDEF=0 a.cpp main.cpp\n&gt; ./a.out\n42\n</code></pre>\n<p>The compilation with the \"using\" variant produces a compile error:</p>\n<pre><code>&gt; g++ -Wall -Wextra -pedantic-errors -DUSING_VS_TYPEDEF=1 a.cpp main.cpp\na.cpp:4:6: warning: \u2018void print(std::ostream&amp;, const A&amp;)\u2019 defined but not used [-Wunused-function]\nvoid print(std::ostream&amp; os, A const&amp; a)\n     ^~~~~\nIn file included from main.cpp:1:0:\na.hpp:16:6: error: \u2018void print(std::ostream&amp;, const A&amp;)\u2019, declared using unnamed type, is used but never defined [-fpermissive]\nvoid print(std::ostream&amp; os, A const&amp; a);\n     ^~~~~\na.hpp:9:2: note: \u2018using A = struct&lt;unnamed&gt;\u2019 does not refer to the unqualified type, so it is not used for linkage\n};\n ^\na.hpp:16:6: error: \u2018void print(std::ostream&amp;, const A&amp;)\u2019 used but never defined\nvoid print(std::ostream&amp; os, A const&amp; a);\n     ^~~~~\n</code></pre>\n<p>This looks like GCC follows the strict interpretation of the standard above and makes a difference concerning linkage between the typedef and the alias declaration.</p>\n<h2>Clang</h2>\n<p>Using clang 6, both variants compile and run cleanly without any warnings:</p>\n<pre><code>&gt; clang++ -Wall -Wextra -pedantic-errors -DUSING_VS_TYPEDEF=0 a.cpp main.cpp\n&gt; ./a.out\n42\n\n&gt; clang++ -Wall -Wextra -pedantic-errors -DUSING_VS_TYPEDEF=1 a.cpp main.cpp\n&gt; ./a.out\n42\n</code></pre>\n<p>One could therefore also ask</p>\n<ul>\n<li>Which compiler is correct?</li>\n</ul>\n", "Title": "using vs. typedef - is there a subtle, lesser known difference?", "CreationDate": "2018-02-04T22:44:22.793", "LastActivityDate": "2018-02-05T17:10:25.847", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-02-04T23:07:17.017", "LastEditorUserId": "7210792", "Id": "48613758", "Score": "18", "OwnerUserId": "7210792", "Tags": "<c++11><gcc><c++14><language-lawyer><clang++>", "AnswerCount": "2"}});