post_cb({"bq_ids": {"n4140": {"so_22248587_22248587_0": {"length": 12, "quality": 0.8, "section_id": 5799}}, "n3337": {"so_22248587_22248587_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5572}}, "n4659": {"so_22248587_22248587_0": {"length": 12, "quality": 0.8, "section_id": 7258}, "so_22248587_22248646_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 180}}}, "22248646": {"Id": "22248646", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22248587_22248646_0\">Is the order for variadic template pack expansion defined in the standard?</p>\n</blockquote>\n<p>Yes. The expanded elements are in an order that corresponds to the original order of the pack.</p>\n<p>In the test, the expansion <code>[](...){}(print(i++, args)...);</code> is equivalent to: <code>[](...){}(print(i++, a), print(i++, b), print(i++, c));</code>.</p>\n<p>The test is flawed in that it tests the order of evaluation of function arguments, which is a completely different matter. If you try and execute the expanded form presented above, you will observe the same behaviour. Or you would if the code didn't have undefined behaviour, since the variable <code>i</code> is incremented several times without the increments being sequenced.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2014-03-07T14:15:11.520", "Score": "12", "CreationDate": "2014-03-07T11:17:32.060", "ParentId": "22248587", "CommentCount": "1", "LastEditDate": "2014-03-07T14:15:11.520", "OwnerUserId": "46642"}, "22248587": {"ViewCount": "447", "Body": "<p>I thought that expanding a <a href=\"http://en.cppreference.com/w/cpp/language/parameter_pack\" rel=\"nofollow\">parameter pack</a> had the following behavior:</p>\n<pre><code>// for Args ... p\nf(p)...;\n// was equivalent to\nf(p1); f(p2); ...; f(pn);\n</code></pre>\n<p>But I just found out that gcc (4.6, 4.7 and 4.8) does it the other way around:</p>\n<pre><code>f(pn); ...; f(p2); f(p1);\n</code></pre>\n<p>Whereas clang does it as I expected.</p>\n<p>Is that a bug in GCC or are they both valid according to the standard?</p>\n<p><em><strong>Minimal example</strong></em></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\ntemplate&lt;typename T&gt;\nbool print(const unsigned index, const T&amp; value){\n  std::cerr &lt;&lt; \"Parameter \" &lt;&lt; index &lt;&lt; \" is \" &lt;&lt; value &lt;&lt; std::endl; \n  return true;\n}\n\ntemplate&lt;typename ... Args&gt;\nvoid printAll(Args ... args){\n  unsigned i = 0;\n  [](...){}(print(i++, args)...);\n}\n\nint main(){\n  int a = 1; float b = 3.14; std::string c(\"hello\");\n  printAll(a, b, c);\n}\n</code></pre>\n<p>Compiling and executing:</p>\n<pre><code>$&gt; clang++ -std=c++11 -o test test.cpp\n$&gt; ./test\nParameter 0 is 1\nParameter 1 is 3.14\nParameter 2 is hello\n$&gt; g++ -std=c++11 -o test test.cpp\n$&gt; ./test\nParameter 0 is hello\nParameter 1 is 3.14\nParameter 2 is 1\n</code></pre>\n<p><em><strong>Answer</strong></em></p>\n<p>It didn't take long for Martinho Fernandes to spot the error here. The problem is the order of evaluation of parameters, which is not defined by the standard (1.9.3):</p>\n<blockquote>\n<p id=\"so_22248587_22248587_0\">Certain other aspects and operations of the abstract machine are described in this International Standard as\n  unspecified (for example, order of evaluation of arguments to a function).</p>\n</blockquote>\n", "AcceptedAnswerId": "22248646", "Title": "Is the order for variadic template pack expansion defined in the standard?", "CreationDate": "2014-03-07T11:15:06.257", "Id": "22248587", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-03-07T11:26:40.187", "LastEditorUserId": "401200", "LastActivityDate": "2014-03-07T14:15:11.520", "Score": "3", "OwnerUserId": "401200", "Tags": "<c++><c++11><variadic-templates>", "AnswerCount": "1"}});