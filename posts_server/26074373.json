post_cb({"26074986": {"ParentId": "26074373", "CommentCount": "0", "Body": "<p>Yes, you can use a pointer to an object once it's been declared (and so has storage allocated) but not yet initialised. Accessing the object itself [except in very restricted ways] gives undefined behaviour; but you don't do that. This is described by C++11 3.8/5:</p>\n<blockquote>\n<p id=\"so_26074373_26074986_0\">Before the lifetime of an object has started but after the storage which the object will occupy has been allocated [...] any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. [...] Using the pointer as if the pointer were of type <code>void*</code>, is well-defined.</p>\n</blockquote>\n<p>You simply pass it to <code>bind</code>, which copies the pointer value into the bound function wrapper, which counts as using it as if it were <code>void*</code>.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "26074986", "Score": "3", "CreationDate": "2014-09-27T13:07:15.093", "LastActivityDate": "2014-09-27T13:07:15.093"}, "26074373": {"CommentCount": "2", "ViewCount": "571", "CreationDate": "2014-09-27T11:53:24.020", "LastActivityDate": "2014-09-27T14:05:48.367", "Title": "Is there anything wrong with using an object in its own construction?", "AcceptedAnswerId": "26074486", "PostTypeId": "1", "Id": "26074373", "Score": "13", "Body": "<p>I'm storing an action that needs to operate on an object but I don't want to use inheritance. So the technique I'm using is to have a non-member function that accepts a pointer to an object and then store it in the object, like so:</p>\n<pre><code>struct command\n{\n    command()\n    {\n    }\n\n    command(const std::function&lt;void()&gt;&amp; action)\n        : action(action)\n    {\n    }\n\n    int n;\n    std::function&lt;void()&gt; action;\n};\n\nvoid test_action(command* this_ptr)\n{\n    this_ptr-&gt;n = 5;\n}\n\n\nint main()\n{\n    command com(std::bind(test_action, &amp;com));\n    com.action();\n    std::cout &lt;&lt; com.n;\n}\n</code></pre>\n<p>My question is it safe to do <code>command com(std::bind(test_action, &amp;com));</code>? Or is it undefined behavior?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4085715", "AnswerCount": "2"}, "26074486": {"ParentId": "26074373", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>First off: what is an object?</p>\n<p><em>[intro.object]\\1</em></p>\n<blockquote>\n<p id=\"so_26074373_26074486_0\">[...] An object is a\n  region of storage [...]</p>\n</blockquote>\n<p>The storage is allocated before the lifetime of an object starts:</p>\n<p><em>[basic.life]</em></p>\n<blockquote>\n<p id=\"so_26074373_26074486_1\">Before the lifetime of an object has started but after the storage\n  which the object will occupy has been allocated [..] any pointer that\n  refers to the storage location where the object will be or was located\n  may be used but only in limited ways. For an object under construction or destruction, see 12.7 [construction and destruction]. Otherwise,\n  such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type void*,\n  is well-defined.</p>\n</blockquote>\n<p>Thus the pointer refers to allocated space and there's no harm in using it. You're just asking for a stack address and any compiler should be able to figure it out correctly. No initialization operation by the object itself is required in this specific instance.</p>\n<p>This makes sense since in a classic AST-fashion compiler if you to take a look at the standard hierarchy for declarators, in a simple toy-code like</p>\n<pre><code>class command {\npublic:\n  command(int) {\n  }\n};\n\nint funct(command*) {\n    return 2;\n}\n\nint main() {\n    command com(funct(&amp;com));\n}\n</code></pre>\n<p>the line</p>\n<pre><code>command com(funct(&amp;com));\n</code></pre>\n<p>is interpreted as follows:</p>\n<p><em>[dcl.decl]</em></p>\n<pre><code>simple-declaration:\n    attribute-specifier-seqopt decl-specifier-seqopt init-declarator-listopt;\n       ...\n         initializer:\n            brace-or-equal-initializer\n                ( expression-list ) // The declaration statement is already specified\n</code></pre>\n<p>And finally for your code this is how gcc compiles this line (<em>-O0</em>)</p>\n<pre><code>command com(std::bind(test_action, &amp;com));\n\n-&gt;\n\nmovq    %rax, -104(%rbp)\nleaq    -104(%rbp), %rdx\nleaq    -96(%rbp), %rcx\nmovl    test_action(command*), %esi\nmovq    %rcx, %rdi\nmovq    %rax, -136(%rbp)        # 8-byte Spill\nmovq    %rcx, -144(%rbp)        # 8-byte Spill\ncallq   _ZSt4bindIRFvP7commandEJS1_EENSt12_Bind_helperIT_JDpT0_EE4typeEOS5_DpOS6_\nleaq    -80(%rbp), %rax\nmovq    %rax, %rdi\nmovq    -144(%rbp), %rsi        # 8-byte Reload\nmovq    %rax, -152(%rbp)        # 8-byte Spill\ncallq   _ZNSt8functionIFvvEEC1ISt5_BindIFPFvP7commandES5_EEEET_NSt9enable_ifIXntsr11is_integralISA_EE5valueENS1_8_UselessEE4typeE\nmovq    -136(%rbp), %rdi        # 8-byte Reload\nmovq    -152(%rbp), %rsi        # 8-byte Reload\ncallq   command::command(std::function&lt;void ()&gt; const&amp;)\n</code></pre>\n<p>which is: just a bunch of stack addresses from the base pointer which get passed to the binding function before invoking the constructor.</p>\n<p>Things would be different if you actually tried to use the object before its construction (things might get tricky with virtual function tables).</p>\n<p>Sidenote: this is <strong>NOT</strong> guaranteed to be safe if you're copying around or passing by value the object and going out-of-scope (and still keeping an address to the stack location). Also: if the compiler decides to store it (for whatever architecture/reason) as an offset from the base frame, you're probably off to undefined behaviorland.</p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "1938163", "LastEditDate": "2014-09-27T14:05:48.367", "Id": "26074486", "Score": "7", "CreationDate": "2014-09-27T12:05:14.933", "LastActivityDate": "2014-09-27T14:05:48.367"}, "bq_ids": {"n4140": {"so_26074373_26074486_1": {"section_id": 7193, "quality": 0.8958333333333334, "length": 43}, "so_26074373_26074986_0": {"section_id": 7193, "quality": 0.96875, "length": 31}}, "n3337": {"so_26074373_26074486_1": {"section_id": 6937, "quality": 0.8958333333333334, "length": 43}, "so_26074373_26074986_0": {"section_id": 6937, "quality": 0.96875, "length": 31}}, "n4659": {"so_26074373_26074486_1": {"section_id": 8702, "quality": 0.875, "length": 42}, "so_26074373_26074986_0": {"section_id": 8702, "quality": 0.9375, "length": 30}}}});