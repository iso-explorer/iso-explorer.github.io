post_cb({"bq_ids": {"n4140": {"so_48749440_48751288_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 480}, "so_48749440_48751168_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 480}, "so_48749440_48751168_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 480}, "so_48749440_48751288_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 480}}, "n3337": {"so_48749440_48751288_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 471}, "so_48749440_48751168_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 471}, "so_48749440_48751168_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 471}, "so_48749440_48751288_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 471}}, "n4659": {"so_48749440_48751288_1": {"length": 40, "quality": 0.975609756097561, "section_id": 502}, "so_48749440_48751168_1": {"length": 40, "quality": 0.975609756097561, "section_id": 502}, "so_48749440_48751168_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 502}, "so_48749440_48751288_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 502}}}, "48749440": {"ViewCount": "53", "Body": "<p>i was fooling around with the following code and got different results using my visual studio 2017 application and two different online compilers. in release mode visual studio does elide the copy/move in both cases, while the two online compilers just do it in case of the unparenthesized return statement. my question is: who is right and more importantly what are the underlaying rules. (i know you can use the parentheses in conjunction with the <code>decltype(auto)</code>syntax. but this is not the current usecase).</p>\n<p>example code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdio&gt;\n\nstruct Foo\n{\n    Foo() { std::cout &lt;&lt; \"default constructor\" &lt;&lt; std::endl; }\n    Foo(const Foo&amp; rhs) { std::cout &lt;&lt; \"copy constructor\" &lt;&lt; std::endl; }\n    Foo(Foo&amp;&amp; rhs) { std::cout &lt;&lt; \"move constructor\" &lt;&lt; std::endl; }\n    Foo&amp; operator=(const Foo&amp; rhs) { std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; return *this; }\n    Foo&amp; operator=(Foo&amp;&amp; rhs) { std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; return *this; }\n};\n\nFoo foo_normal()\n{\n    Foo a{};\n    return a;\n}\n\nFoo foo_parentheses()\n{\n    Foo a{};\n    return (a);\n}\n\nint main()\n{\n    auto a = foo_normal();\n    auto b = foo_parentheses();\n    std::getchar();\n}\n</code></pre>\n<p>online compiler 1:\n<a href=\"http://cpp.sh/75bux\" rel=\"nofollow noreferrer\">http://cpp.sh/75bux</a></p>\n<p>online compiler 2:\n<a href=\"http://coliru.stacked-crooked.com/a/c266852b9e1712f3\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/c266852b9e1712f3</a></p>\n<p>the output for visual studio in release mode is:</p>\n<pre><code>default constructor\ndefault constructor\n</code></pre>\n<p>in the two other compilers the output is:</p>\n<pre><code>default constructor\ndefault constructor\nmove constructor\n</code></pre>\n", "AcceptedAnswerId": "48751288", "Title": "C++ nrvo/copy elision with return statement in parentheses", "CreationDate": "2018-02-12T15:06:26.720", "LastActivityDate": "2018-02-12T16:37:52.827", "CommentCount": "4", "LastEditDate": "2018-02-12T15:24:39.880", "PostTypeId": "1", "LastEditorUserId": "3783662", "Id": "48749440", "Score": "2", "OwnerUserId": "3783662", "Tags": "<c++><language-lawyer><copy-elision><nrvo>", "AnswerCount": "2"}, "48751168": {"Id": "48751168", "PostTypeId": "2", "Body": "<p>This is <a href=\"http://eel.is/c++draft/class.copy.elision#1.1\" rel=\"nofollow noreferrer\">the relevant quote from the standard</a>:</p>\n<blockquote>\n<p id=\"so_48749440_48751168_0\">This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<p id=\"so_48749440_48751168_1\">(1.1) - in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function parameter or a variable introduced by the exception-declaration of a handler ([except.handle])) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function call's return object</p>\n</blockquote>\n<p>So the requirements are</p>\n<ol>\n<li>in a return statement</li>\n<li>in a function</li>\n<li>with a class return type</li>\n<li>when the expression is the name of a non-volatile automatic object (other than a function parameter or a variable introduced by the exception-declaration of a handler ([except.handle]))</li>\n<li>with the same type (ignoring cv-qualification) as the function return type</li>\n</ol>\n<p>I would argue that requirements 1, 2, 3 and 5 are fulfilled, but requirement 4 is not. <code>(a)</code> is not the name of an object. Therefore for the given code copy-elision does not apply. Since the move-constructor has side-effects it also cannot be elided under the as-if rule.</p>\n<p>Therefore gcc is right and visual studio (and <a href=\"https://wandbox.org/permlink/VR30T1Y3fDt1eNuP\" rel=\"nofollow noreferrer\">clang</a>) are wrong here.</p>\n", "LastActivityDate": "2018-02-12T16:32:20.477", "Score": "2", "CreationDate": "2018-02-12T16:32:20.477", "ParentId": "48749440", "CommentCount": "0", "OwnerUserId": "3484570"}, "48751288": {"Id": "48751288", "PostTypeId": "2", "Body": "<p>GCC is right. </p>\n<p>According to <a href=\"http://eel.is/c++draft/class.copy.elision#1\" rel=\"nofollow noreferrer\">[class.copy.elision] paragraph 1</a>:</p>\n<blockquote>\n<p id=\"so_48749440_48751288_0\">This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li><p id=\"so_48749440_48751288_1\">in a <code>return</code> statement in a function with a class return type, when the <em>expression</em> is <strong>the name of a non-volatile automatic object</strong> (other than a function parameter or a variable introduced by the <em>exception-declaration</em> of a <em>handler</em> ([except.handle])) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function call's return object</p></li>\n<li><p id=\"so_48749440_48751288_2\">...</p></li>\n</ul>\n</blockquote>\n<p>Parenthesized expression in <code>return</code> statement does not meet the criteria for copy elision.</p>\n<p>In fact, until the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"nofollow noreferrer\">CWG 1597</a>, parenthesized id-expression in <code>return</code> statement cannot even be considered as an rvalue to perform a move.</p>\n", "LastActivityDate": "2018-02-12T16:37:52.827", "Score": "3", "CreationDate": "2018-02-12T16:37:52.827", "ParentId": "48749440", "CommentCount": "1", "OwnerUserId": "5376789"}});