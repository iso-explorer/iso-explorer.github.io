post_cb({"bq_ids": {"n4140": {"so_16680992_16681036_0": {"length": 38, "quality": 0.95, "section_id": 5965}}, "n3337": {"so_16680992_16681036_0": {"length": 38, "quality": 0.95, "section_id": 5734}}, "n4659": {"so_16680992_16681036_0": {"length": 34, "quality": 0.85, "section_id": 7456}}}, "16681052": {"Id": "16681052", "PostTypeId": "2", "Body": "<p>I think that the problem is that your:</p>\n<pre><code>void generate(rgb_tuple predicate(const unsigned char&amp; index));\n</code></pre>\n<p>should be:</p>\n<pre><code>void generate(rgb_tuple (*predicate)(const unsigned char&amp; index));\n</code></pre>\n<p>You cannot pass functions around! Just pointers to functions.</p>\n<p>But alas! lambdas can only be converted to pointer-to-functions if they have an empty capture set, and your lambda does not.</p>\n<p>So you can try with <code>std::function</code>:</p>\n<pre><code>void generate(std::function&lt;rgb_tuple(const unsigned char&amp; index)&gt; predicate);\n</code></pre>\n<p>PS: A bit of explanation is in order... your error message is:</p>\n<blockquote>\n<p id=\"so_16680992_16681052_0\">Convertion of the parameter 1 from 'create_random_color_map::' to 'rgb_tuple (__cdecl *)(const unsigned char &amp;)' not possible</p>\n</blockquote>\n<p>The first part <code>create_random_color_map::</code> is the VC++ way of telling you that it does not know the type of the object it is trying to convert, but it is something local to <code>create_random_color_map</code>: that is obviously the lambda itself.</p>\n<p>The second part <code>rgb_tuple (__cdecl *)(const unsigned char &amp;)</code> is simply a pointer to function of the appropriate type.</p>\n<p>And the error says that the first cannot be converted to the latter.</p>\n", "LastEditorUserId": "865874", "LastActivityDate": "2013-05-21T23:22:28.570", "Score": "0", "CreationDate": "2013-05-21T23:16:18.130", "ParentId": "16680992", "CommentCount": "0", "OwnerUserId": "865874", "LastEditDate": "2013-05-21T23:22:28.570"}, "16680992": {"ViewCount": "137", "Body": "<p>Hy @ all,\nwe have to realize the following functioncall:\n</p>\n<pre><code>std::mt19937 engine;\ncolor_table lut = create_random_color_map(engine);\n</code></pre>\n<p><br/><br/>\nThe engine has to be exchangeable. We tried to implement it this way:<br/>\n<strong>*.hpp</strong></p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;random&gt;\n\ntypedef std::tuple&lt;unsigned char,unsigned char,unsigned char&gt; rgb_tuple;\n\nclass color_table{\n    public:\n        [...]\n        void generate(rgb_tuple predicate(const unsigned char&amp; index));\n\n\n\n\n\n };\ntemplate &lt;class RANDOM&gt;\nstatic rgb_tuple random_color(RANDOM engine){\n    std::uniform_int_distribution&lt;int&gt; dist1 (0,255);\n    unsigned char red   = (unsigned char) dist1();\n    unsigned char green = (unsigned char) dist1(engine);\n    unsigned char blue  = (unsigned char) dist1(engine);\n    return std::make_tuple(red, green, blue);\n}\n\ntemplate &lt;class RANDOM&gt;\nstatic color_table create_random_color_map(RANDOM engine){\n    color_table lut;\n    lut.generate([&amp;](const unsigned char&amp; i)-&gt;rgb_tuple {\n        return random_color&lt;decltype(engine)&gt;(engine);\n    } );\n    return lut;\n}\n</code></pre>\n<p>*<strong>.cpp</strong></p>\n<pre><code>...\nvoid color_table::generate(rgb_tuple predicate(const unsigned char&amp; index)){\n    for(int i = 0; i &lt; 256; ++i){\n        std::tie(red_table[i], green_table[i], blue_table[i]) = predicate(i);\n    }\n}\n</code></pre>\n<p>When we try to compile, the following error occurs:</p>\n<blockquote>\n<p id=\"so_16680992_16680992_0\">error C2664: 'color_table::generate': Convertion of the parameter 1\n  from \n  'create_random_color_map::'\n  to 'rgb_tuple (__cdecl *)(const unsigned char &amp;)' not possible 1&gt;<br>\n  No userdefined convertionoperator available, that can execute the\n  convertion or the operator cannot be invoked.     ...\n  Function-template \"color_table\n  create_random_color_map(RANDOM)\".          with   [<br>\n  RANDOM=std::mt19937           ]</br></br></p>\n</blockquote>\n<p>We are completely clueless about that failure and google isn't our friend in that case! :/</p>\n<p>We appreciate any help!</p>\n<p>Regards\nHymir</p>\n", "AcceptedAnswerId": "16681036", "Title": "Template Conversion Failure with Lambda Function", "CreationDate": "2013-05-21T23:10:19.343", "Id": "16680992", "CommentCount": "0", "LastEditDate": "2013-05-21T23:28:18.367", "PostTypeId": "1", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-21T23:37:36.173", "Score": "1", "OwnerUserId": "1354911", "Tags": "<c++><templates><c++11><lambda>", "AnswerCount": "2"}, "16681036": {"Id": "16681036", "PostTypeId": "2", "Body": "<p><strong>First (major) issue:</strong></p>\n<p>Your function <code>generate()</code> accepts a <em>function pointer</em> as its argument, and you are trying to pass a capturing lambda. Unfortunately, capturing lambdas cannot be converted implicitly to function pointers. Per paragraph 5.1.2/6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16680992_16681036_0\">The closure type for a <em>lambda-expression</em> <strong>with no <em>lambda-capture</em></strong> has a public non-virtual non-explicit const\n  conversion function to pointer to function having the same parameter and return types as the closure type\u2019s\n  function call operator. The value returned by this conversion function shall be the address of a function\n  that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>You could change your design and let <code>generate()</code> become a function template, accepting a callable object as its argument:</p>\n<pre><code> class color_table{\n    public:\n        template&lt;typename P&gt;\n        void generate(P predicate);\n };\n</code></pre>\n<p>Alternatively, you could use an <code>std::function</code> wrapper to achieve flexibility without recurring to templates (but with some run-time overhead):</p>\n<pre><code>#include &lt;functional&gt; // &lt;== NEEDED FOR std::function\n\nclass color_table{\n    public:\n        void generate(std::function&lt;rgb_tuple(const unsigned char&amp;)&gt; predicate);\n};\n</code></pre>\n<p>Here is a <a href=\"http://ideone.com/TrPobZ\" rel=\"nofollow\"><strong>live example</strong></a> that shows your code compiling with the above solution.</p>\n<p><strong>Second (minor) issue:</strong></p>\n<p>You should not specify the template arguments for <code>random_color()</code> explicitly. Rather let the compiler do its job and perform type deduction:</p>\n<pre><code>lut.generate([&amp;](const unsigned char&amp; i)-&gt;rgb_tuple {\n    return random_color(engine);\n//         ^^^^^^^^^^^^^^^^^^^^^\n});\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-05-21T23:37:36.173", "Score": "3", "CreationDate": "2013-05-21T23:15:00.093", "ParentId": "16680992", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-05-21T23:37:36.173"}});