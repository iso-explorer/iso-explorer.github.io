post_cb({"bq_ids": {"n4140": {"so_30245014_30245429_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 3402}}, "n3337": {"so_30245014_30245429_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 3271}}, "n4659": {"so_30245014_30245429_0": {"length": 28, "quality": 0.7368421052631579, "section_id": 4159}}}, "30245014": {"ViewCount": "172", "Body": "<p><strong>The Problem:</strong> C++11 has made some changes to complex numbers so that <code>real()</code> and <code>imag()</code> can no longer be used and abused like member variables.\nI have some code that I am converting over that passes <code>real()</code> and <code>imag()</code> to <code>sincosf()</code> by reference. It looks a little like this:</p>\n<pre><code>sincosf(/*...*/, &amp;cplx.real(), &amp;cplx.imag());\n</code></pre>\n<p>This now gives a <code>error: lvalue required as unary '&amp;' operand</code></p>\n<p>which error was not received prior to c++11.</p>\n<p><strong>My Question:</strong> Is there an easy inline fix? or do I have to create temporary variables to get the result and then pass those to the complex number via setters?</p>\n<p>Thanks</p>\n", "AcceptedAnswerId": "30246820", "Title": "Passing Complex real and imag by reference", "CreationDate": "2015-05-14T18:48:17.723", "Id": "30245014", "CommentCount": "6", "LastEditDate": "2015-05-14T21:07:19.503", "PostTypeId": "1", "LastEditorUserId": "3738040", "LastActivityDate": "2015-05-14T21:07:19.503", "Score": "3", "OwnerUserId": "4852019", "Tags": "<c++><c++11><reference><complex-numbers><rvalue>", "AnswerCount": "3"}, "30246820": {"Id": "30246820", "PostTypeId": "2", "Body": "<p>Just do</p>\n<pre><code>cplx = std::polar(1.0f, /*...*/);\n</code></pre>\n", "LastActivityDate": "2015-05-14T20:33:16.637", "CommentCount": "2", "CreationDate": "2015-05-14T20:33:16.637", "ParentId": "30245014", "Score": "2", "OwnerUserId": "1554020"}, "30245429": {"Id": "30245429", "PostTypeId": "2", "Body": "<p>As T.C. <a href=\"https://stackoverflow.com/questions/30245014/passing-complex-real-and-imag-by-reference-c11#comment48591195_30245014\">mentions</a> in the comments, the standard allows you to <code>reinterpret_cast</code> <code>std::complex</code> to your heart's content. </p>\n<p>From N3337, <em>\u00a726.4/4 [complex.numbers]</em></p>\n<blockquote>\n<p id=\"so_30245014_30245429_0\">If <code>z</code> is an lvalue expression of type <em>cv</em> <code>std::complex&lt;T&gt;</code> then:<br/>\n  \u2014 the expression <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)</code> shall be well-formed,<br/>\n  \u2014 <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[0]</code> shall designate the real part of <code>z</code>, and<br/>\n  \u2014 <code>reinterpret_cast&lt;cv T(&amp;)[2]&gt;(z)[1]</code> shall designate the imaginary part of <code>z</code>.<br/>\n  Moreover, if <code>a</code> is an expression of type <em>cv</em> <code>std::complex&lt;T&gt;*</code> and the expression <code>a[i]</code> is well-defined for an integer expression <code>i</code>, then:<br/>\n  \u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> shall designate the real part of <code>a[i]</code>, and<br/>\n  \u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i + 1]</code> shall designate the imaginary part of <code>a[i]</code>.<br/></p>\n</blockquote>\n<p>So make the following replacement in your code</p>\n<pre><code>sincosf(/*...*/, \n        &amp;reinterpret_cast&lt;T*&gt;(&amp;cplx)[0], \n        &amp;reinterpret_cast&lt;T*&gt;(&amp;cplx)[1]);\n</code></pre>\n", "LastActivityDate": "2015-05-14T19:11:29.480", "CommentCount": "1", "CreationDate": "2015-05-14T19:11:29.480", "ParentId": "30245014", "Score": "3", "OwnerUserId": "241631"}, "30245456": {"Id": "30245456", "PostTypeId": "2", "Body": "<p>Do not that declaring temporaries still is a good option and should be just as efficient as what you are previously doing, given a good optimizing compiler (say, <code>gcc -O3</code>).</p>\n<p>See the resulting assembly from <code>gcc -O3</code> here: <a href=\"https://goo.gl/uCPAa9\" rel=\"nofollow\">https://goo.gl/uCPAa9</a></p>\n<p>Using this code:</p>\n<pre><code>#include&lt;complex&gt;\n\nstd::complex&lt;float&gt; scf1(float x) {\n  float r = 0., i = 0.;\n  sincosf(x, &amp;r, &amp;i);\n  return std::complex&lt;float&gt;(r, i);\n}\n\nvoid scf2(std::complex&lt;float&gt;&amp; cmp, float x) {\n  float r = 0., i = 0.;\n  sincosf(x, &amp;r, &amp;i);\n  cmp.real(r);\n  cmp.imag(i);\n}\n\nvoid scf3(std::complex&lt;float&gt;&amp; cmp, float x) {\n  float r = 0., i = 0.;\n  sincosf(x, &amp;cmp.real(), &amp;cmp.imag());\n}\n</code></pre>\n<p>Where <code>scf2</code> is equivalent to your statement, you can see very similar assembly in the three cases.</p>\n<pre><code>scf1(float):\n    subq    $24, %rsp\n    leaq    8(%rsp), %rsi\n    leaq    12(%rsp), %rdi\n    call    sincosf\n    movss   12(%rsp), %xmm0\n    movss   %xmm0, (%rsp)\n    movss   8(%rsp), %xmm0\n    movss   %xmm0, 4(%rsp)\n    movq    (%rsp), %xmm0\n    addq    $24, %rsp\n    ret\nscf2(std::complex&lt;float&gt;&amp;, float):\n    pushq   %rbx\n    movq    %rdi, %rbx\n    subq    $16, %rsp\n    leaq    8(%rsp), %rsi\n    leaq    12(%rsp), %rdi\n    call    sincosf\n    movss   12(%rsp), %xmm0\n    movss   %xmm0, (%rbx)\n    movss   8(%rsp), %xmm0\n    movss   %xmm0, 4(%rbx)\n    addq    $16, %rsp\n    popq    %rbx\n    ret\nscf3(std::complex&lt;float&gt;&amp;, float):\n    pushq   %rbx\n    movq    %rdi, %rbx\n    subq    $16, %rsp\n    leaq    8(%rsp), %rsi\n    leaq    12(%rsp), %rdi\n    call    sincosf\n    movss   12(%rsp), %xmm0\n    movss   %xmm0, (%rbx)\n    movss   8(%rsp), %xmm0\n    movss   %xmm0, 4(%rbx)\n    addq    $16, %rsp\n    popq    %rbx\n    ret\n</code></pre>\n", "LastActivityDate": "2015-05-14T19:12:32.703", "CommentCount": "0", "CreationDate": "2015-05-14T19:12:32.703", "ParentId": "30245014", "Score": "0", "OwnerUserId": "864313"}});