post_cb({"5627278": {"ParentId": "5627030", "PostTypeId": "2", "CommentCount": "5", "Body": "<pre><code>double pow(double, int);\n</code></pre>\n<p>hasn't been removed from the spec.  It has simply been reworded.  It now lives in [c.math]/p11.  How it is computed is an implementation detail.  The only C++03 signature that has changed is:</p>\n<pre><code>float pow(float, int);\n</code></pre>\n<p>This now returns double:</p>\n<pre><code>double pow(float, int);\n</code></pre>\n<p>And <em>this</em> change was done for C compatibility.</p>\n<p><strong>Clarification</strong>:</p>\n<p>26.8 [cmath] / p11 says:</p>\n<blockquote>\n<p id=\"so_5627030_5627278_0\">Moreover, there shall be additional\n  overloads sufficient to ensure:</p>\n<ol>\n<li><p id=\"so_5627030_5627278_1\">If any argument corresponding to a double parameter has type long double,\n  then all arguments corresponding to\n  double parameters are effectively cast\n  to long double.</p></li>\n<li><p id=\"so_5627030_5627278_2\">Otherwise, if any argument corresponding to a double parameter\n  has type double or an integer type,\n  then all arguments corresponding to\n  double parameters are effectively cast\n  to double.</p></li>\n<li><p id=\"so_5627030_5627278_3\">Otherwise, all arguments corresponding to double parameters are\n  effectively cast to float.</p></li>\n</ol>\n</blockquote>\n<p>This paragraph implies a whole host of overloads, including:</p>\n<pre><code>double pow(double, int);\ndouble pow(double, unsigned);\ndouble pow(double, unsigned long long);\n</code></pre>\n<p>etc.</p>\n<p>These may be actual overloads, or may be implemented with restricted templates.  I've personally implemented it both ways and strongly favor the restricted template implementation.</p>\n<p><strong>Second update to address optimization issues:</strong></p>\n<p>The implementation is allowed to optimize any overload.  But recall that an optimization should be <em>only</em> that.  The optimized version ought to return the same answer.  The experience from implementors of functions like pow is that by the time you go to the trouble to ensure that your implementation taking an integral exponent gives the same answer as the implementation taking a floating point exponent, the \"optimization\" is often slower.</p>\n<p>As a demonstration the following program prints out <code>pow(.1, 20)</code> twice, once using std::pow, and the second time using an \"optimized\" algorithm taking advantage of the integral exponent:</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main()\n{\n    std::cout &lt;&lt; std::setprecision(17) &lt;&lt; std::pow(.1, 20) &lt;&lt; '\\n';\n    double x = .1;\n    double x2 = x * x;\n    double x4 = x2 * x2;\n    double x8 = x4 * x4;\n    double x16 = x8 * x8;\n    double x20 = x16 * x4;\n    std::cout &lt;&lt; x20 &lt;&lt; '\\n';\n}\n</code></pre>\n<p>On my system this prints out:</p>\n<pre><code>1.0000000000000011e-20\n1.0000000000000022e-20\n</code></pre>\n<p>Or in hex notation:</p>\n<pre><code>0x1.79ca10c92422bp-67\n0x1.79ca10c924232p-67\n</code></pre>\n<p>And yes, implementors of pow really do worry about all of those bits down at the low end.</p>\n<p>So while the freedom is there to shuffle <code>pow(double, int)</code> off to a separate algorithm, most implementors I'm aware of have given up on that strategy, with the possible exception of checking for very small integral exponents.  And in that event, it is usually advantageous to put that check in the implementation with the floating point exponent so as to get the biggest bang for your optimization buck.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2011-04-11T22:01:57.340", "Id": "5627278", "Score": "79", "CreationDate": "2011-04-11T20:39:06.677", "LastActivityDate": "2011-04-11T22:01:57.340"}, "5627030": {"CommentCount": "3", "AcceptedAnswerId": "5627278", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-11T20:17:13.860", "LastActivityDate": "2012-03-09T01:34:20.870", "LastEditDate": "2017-05-23T12:09:33.230", "ViewCount": "9139", "FavoriteCount": "14", "Title": "Why was std::pow(double, int) removed from C++11?", "Id": "5627030", "Score": "61", "Body": "<p>While looking into <a href=\"https://stackoverflow.com/questions/5625431\">Efficient way to compute p^q (exponentiation), where q is an integer</a> and reviewing the C++98 and C++11 standards I noticed that apparently the <code>std::pow(double, int)</code> overload was removed in C++11.</p>\n<p>In C++98 26.5/6 it has the <code>double pow(double, int);</code> signature.</p>\n<p>In C++11 26.8 all I could find was overloads taking a pair of <code>float</code>, <code>double</code>, or <code>long double</code>, and an explicit note that in case of a mixture of parameter types integral&amp;double, that the <code>pow(double, double)</code> overload should be picked.</p>\n<p>Is this just a clarification of the previous intention, were they incorrectly added in C++98, were they actually removed in C++11, or something else?</p>\n<p>Obviously the <code>pow(double, int)</code> version provides a nice opportunity for optimization so it seems odd that they would be removed. Would a compiler still be standards conforming to provide such an optimized overload?</p>\n", "Tags": "<c++><c++11><c++-standard-library>", "OwnerUserId": "251738", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_5627030_5627278_1": {"section_id": 3876, "quality": 1.0, "length": 17}, "so_5627030_5627278_3": {"section_id": 3876, "quality": 1.0, "length": 9}, "so_5627030_5627278_0": {"section_id": 3876, "quality": 1.0, "length": 6}, "so_5627030_5627278_2": {"section_id": 3876, "quality": 1.0, "length": 18}}, "n3337": {"so_5627030_5627278_1": {"section_id": 3736, "quality": 1.0, "length": 17}, "so_5627030_5627278_3": {"section_id": 3736, "quality": 1.0, "length": 9}, "so_5627030_5627278_0": {"section_id": 3736, "quality": 1.0, "length": 6}, "so_5627030_5627278_2": {"section_id": 3736, "quality": 1.0, "length": 18}}, "n4659": {"so_5627030_5627278_2": {"section_id": 4690, "quality": 1.0, "length": 18}, "so_5627030_5627278_3": {"section_id": 4690, "quality": 1.0, "length": 9}, "so_5627030_5627278_0": {"section_id": 4690, "quality": 0.8333333333333334, "length": 5}, "so_5627030_5627278_1": {"section_id": 4690, "quality": 1.0, "length": 17}}}});