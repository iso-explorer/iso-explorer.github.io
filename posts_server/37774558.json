post_cb({"37774558": {"ViewCount": "120", "Body": "<p>Consider the following, where we have two file scoped objects in different translation units, which is the usual setup for undefined-behavior by way of the initialization order fiasco:</p>\n<p><strong>a.hpp</strong>:</p>\n<pre><code>struct thing {\npublic:\n    thing(int value);\n    ~thing();\n\n    int value() const;\n\n    static int count();\n\nprivate:\n    int _value;\n};\n</code></pre>\n<p><strong>a.cpp</strong>:</p>\n<pre><code>#include \"a.hpp\"\n\n#include &lt;atomic&gt;\n\nnamespace {\n    std::atomic&lt;int&gt; things;\n}\n\nthing::thing(int value) : _value(value) {\n    ++things;\n}\n\nthing::~thing() {\n    --things;\n}\n\nint thing::value() const {\n    return _value;\n}\n\nint thing::count() {\n    return things.load();\n}\n</code></pre>\n<p><strong>b.cpp</strong>:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include \"a.hpp\"\n\nnamespace {\n    thing static_thing(42);\n}\n\nvoid foo() {\n    std::cout &lt;&lt; static_thing.value() &lt;&lt; ' ' &lt;&lt; thing::count() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Is this code subject to an initialization order fiasco between the file scoped atomic <code>things</code> in <strong>a.cpp</strong> and the file scoped <code>static_thing</code> in <strong>b.cpp</strong>? If not, why not? In particular, what is special about std::atomic that removes what would otherwise be a clear init order fiasco? Is there a particular concept that can be named to enforce this with a static assert? Something like:</p>\n<pre><code>static_assert(std::is_trivial&lt;decltype(things)&gt;::value, \"file static counter is not trivial\");\n</code></pre>\n<p>If not <code>std::is_trivial</code>, is there another concept and associated type trait that better models this?</p>\n<p>Conversely, is there a de-initialization fiasco? Same questions about if so, why, or why not.</p>\n", "Title": "Are file scoped atomics subject to the initialization order fiasco?", "CreationDate": "2016-06-12T13:03:23.457", "LastActivityDate": "2016-06-13T16:26:07.400", "CommentCount": "4", "LastEditDate": "2016-06-12T13:56:23.630", "PostTypeId": "1", "LastEditorUserId": "776473", "Id": "37774558", "Score": "9", "OwnerUserId": "776473", "Tags": "<c++><c++11><static><initialization><undefined-behavior>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37774558_37794674_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 7151}, "so_37774558_37794674_2": {"length": 18, "quality": 0.9, "section_id": 7151}}, "n3337": {"so_37774558_37794674_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 6895}, "so_37774558_37794674_2": {"length": 18, "quality": 0.9, "section_id": 6895}}, "n4659": {"so_37774558_37794674_1": {"length": 9, "quality": 0.6, "section_id": 4051}, "so_37774558_37794674_2": {"length": 14, "quality": 0.7, "section_id": 8652}}}, "37794674": {"Id": "37794674", "PostTypeId": "2", "Body": "<p><code>std::atomic&lt;&gt;</code> is a standard layout type with trivial default constructors, and trivial destructors. Therefore, it is initialized at <em>static initialization</em> phase, before the <em>dynamic initialization</em> phase when constructors of global objects get called.</p>\n<p>In other words, no initialization order fiasco happens here.</p>\n<p>Since you do not explicitly initialize the namespace scoped <code>std::atomic&lt;int&gt;</code>, it is going to be zero-initialized.</p>\n<blockquote>\n<p id=\"so_37774558_37794674_0\">\u00a7 3.6.2 Initialization of non-local variables</p>\n<p id=\"so_37774558_37794674_1\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place. </p>\n<p id=\"so_37774558_37794674_2\">Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place. </p>\n</blockquote>\n", "LastEditorUserId": "412080", "LastActivityDate": "2016-06-13T16:26:07.400", "Score": "2", "CreationDate": "2016-06-13T16:20:35.340", "ParentId": "37774558", "CommentCount": "1", "OwnerUserId": "412080", "LastEditDate": "2016-06-13T16:26:07.400"}, "37791483": {"Id": "37791483", "PostTypeId": "2", "Body": "<p>My understanding of the C++ \"initialisation order fiasco\" is that it only applies when constructors need to be called at runtime. If the code can devolve down into the initialisation of a memory location to a fixed value, then that value gets put in the \"initialised data\" linker section (<code>.data</code>) like every other pre-initialised POD (Plain Ol' Data), and there is no fiasco.</p>\n<p>I'd suggest that an <code>atomic</code> meets that very criterion.</p>\n", "LastActivityDate": "2016-06-13T13:48:24.833", "CommentCount": "0", "CreationDate": "2016-06-13T13:48:24.833", "ParentId": "37774558", "Score": "1", "OwnerUserId": "6445597"}});