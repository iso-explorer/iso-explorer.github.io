post_cb({"44524156": {"Id": "44524156", "PostTypeId": "2", "Body": "<p><strong>C</strong>: Highly unrecommended, but doable:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n#define BAR_STRUCT struct { int x; }\n\ntypedef BAR_STRUCT bar;\n\ntypedef struct {\n    union {\n        bar b;\n        BAR_STRUCT;\n    };\n} foo;\n\nint main() {\n  foo f;\n  f.x = 989898;\n  printf(\"%d %d\", f.b.x, f.x);\n\n  return 0;\n}\n</code></pre>\n<p>Anonymous structs are a widly-spread extension in standards before C11.</p>\n<p><strong>C++</strong>:\nThe same as in C, you can do here but anonymous structs are not part of any C++ standard, but an extension.\nBetter use inheritance, or do not use this shortcut at all.</p>\n<p>Of course, do not use something like <code>#define x b.x</code>)).</p>\n", "LastEditorUserId": "8005438", "LastActivityDate": "2017-06-13T14:32:13.317", "CommentCount": "4", "CreationDate": "2017-06-13T14:18:31.117", "ParentId": "44523717", "Score": "7", "OwnerUserId": "8005438", "LastEditDate": "2017-06-13T14:32:13.317"}, "44523717": {"ViewCount": "816", "Body": "<p>If I have these structures:</p>\n<pre><code>typedef struct { int x; } foo;\ntypedef struct { foo f; } bar;\n</code></pre>\n<p>Normally you would access <code>x</code> through <code>b.f.x</code>, but is there a way to set this up so that you can access element <code>x</code> without referring to <code>f</code>?</p>\n<pre><code>bar b;\nb.x = ...\n</code></pre>\n<p>My first intuition is that you can't since there would be a possibility for name conflicts if two sub structures both had a member x and I can't figure out what the compile error would be.  However, I recall working in some frameworks where this was possible.</p>\n<p>In C++ I worked in a framework once where <code>bar</code> existed, and you could access its members as member variables <code>this-&gt;x</code> from a different class.  I'm trying to figure out how that could be done.</p>\n", "AcceptedAnswerId": "44524573", "Title": "Accessing child variables through higher level structures", "CreationDate": "2017-06-13T13:58:11.613", "Id": "44523717", "CommentCount": "0", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-06-13T19:43:04.547", "Score": "16", "OwnerUserId": "1723954", "Tags": "<c++><c>", "AnswerCount": "8"}, "44523885": {"PostTypeId": "2", "Body": "<p>In C++, it is possible in two ways.  The first is to use inheritence.  The second is for <code>bar</code> to contain a reference member named <code>x</code> (<code>int &amp;x</code>), and  constructors that initialise <code>x</code> to refer to <code>f.x</code>.</p>\n<p>In C, it is not possible.</p>\n", "LastActivityDate": "2017-06-13T14:05:03.887", "Id": "44523885", "CommentCount": "0", "CreationDate": "2017-06-13T14:05:03.887", "ParentId": "44523717", "Score": "0", "OwnerUserId": "4706785"}, "44524573": {"Id": "44524573", "PostTypeId": "2", "Body": "<p>You can with C11:</p>\n<p><strong>\u00a7 6.7.2.1 -- 11</strong></p>\n<blockquote>\n<p id=\"so_44523717_44524573_0\">An unnamed member whose type specifier is a structure specifier with no tag is called an\n  anonymous structure; an unnamed member whose type specifier is a union specifier with\n  no tag is called an anonymous union. The members of an anonymous structure or union\n  are considered to be members of the containing structure or union. This applies\n  recursively if the containing structure or union is also anonymous.</p>\n</blockquote>\n<p>So this code <em>might</em> work:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct { int x; } foo;\ntypedef struct { foo; } bar;\n\nint main(void)\n{\n    bar b;\n    b.x = 1;\n    printf(\"%d\\n\", b.x);\n}\n</code></pre>\n<p>The problem here is that different compilers disagree in my tests on whether a <em>typedef</em> is acceptable as a <em>struct specifier with no tag</em> The standard specifies:</p>\n<p><strong>\u00a7 6.7.8 -- 3</strong></p>\n<blockquote>\n<p id=\"so_44523717_44524573_1\">In a declaration whose storage-class specifier is <code>typedef</code>, each declarator defines an\n  identifier to be a typedef name that denotes the type specified for the identifier in the way\n  described in 6.7.6. <em>[...]</em> A <code>typedef</code> declaration does not introduce a new type, only <strong>a\n  synonym for the type so specified.</strong></p>\n</blockquote>\n<p>(emphasis mine) -- But does <em>synonym</em> also mean a <em>typdef-name</em> specifier is exchangeable for a <em>struct specifier</em>? <code>gcc</code> accepts this, <code>clang</code> doesn't.</p>\n<p>Of course, there's no way to express <em>the whole member of type <code>foo</code></em> with these declarations, you sacrifice your named member <code>f</code>.</p>\n<p>Concerning your doubt about name collisions, this is what <code>gcc</code> has to say when you put another <code>int x</code> inside <code>bar</code>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>structinherit.c:4:27: error: duplicate member 'x'\n typedef struct { foo; int x; } bar;\n                           ^\n</code></pre>\n<p>To avoid ambiguity, you can just <em>repeat the struct</em>, possibly <code>#define</code>d as a macro, but of course, this looks a bit ugly:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct { int x; } foo;\ntypedef struct { struct { int x; }; } bar;\n\nint main(void)\n{\n    bar b;\n    b.x = 1;\n    printf(\"%d\\n\", b.x);\n}\n</code></pre>\n<p>But <strong>any conforming compiler should accept this code</strong>, so stick to this version.</p>\n<p>&lt;opinion&gt;This is a pity, I like the syntax accepted by <code>gcc</code> much better, but as the wording of the standard doesn't make it <em>explicit</em> to allow this, the only <em>safe bet</em> is to assume it's forbidden, so <code>clang</code> is not to blame here...&lt;/opinion&gt;</p>\n<p>If you want to refer to <code>x</code> by <em>either</em> <code>b.x</code> <em>or</em> <code>b.f.x</code>, you can use an additional anonymous union like this:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntypedef struct { int x; } foo;\ntypedef struct {\n    union { struct { int x; }; foo f; };\n} bar;\n\nint main(void)\n{\n    bar b;\n    b.f.x = 2;\n    b.x = 1;\n    printf(\"%d\\n\", b.f.x); // &lt;-- guaranteed to print 1\n}\n</code></pre>\n<p>This will <em>not</em> cause aliasing issues because of</p>\n<p><strong>\u00a7 6.5.2.3 -- 6</strong></p>\n<blockquote>\n<p id=\"so_44523717_44524573_2\">One special guarantee is made in order to simplify the use of unions: if a union contains several structures that share a common initial sequence (see below), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere that a declaration of the completed type of the union is visible. Two structures share a common initial sequence if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members</p>\n</blockquote>\n", "LastEditorUserId": "2371524", "LastActivityDate": "2017-06-13T19:43:04.547", "CommentCount": "2", "CreationDate": "2017-06-13T14:36:17.240", "ParentId": "44523717", "Score": "18", "OwnerUserId": "2371524", "LastEditDate": "2017-06-13T19:43:04.547"}, "bq_ids": {"n4140": {"so_44523717_44524573_2": {"length": 33, "quality": 0.6, "section_id": 5878}}, "n3337": {"so_44523717_44524573_2": {"length": 33, "quality": 0.6, "section_id": 5649}}}, "44524027": {"PostTypeId": "2", "Body": "<p>In C++, you can use inheritance and member name conflicts are sort of resolvable with <code>::</code> and treating the base classes as members.</p>\n<pre><code>struct foo { int x; };\nstruct bar : foo { };\n\nstruct foo1 { int x; };\nstruct bar1 : foo1 { char const* x; };\n\nbar b;\nbar1 b1;\nint main()\n{\n    return b.x + b1.foo1::x;\n}\n</code></pre>\n<p>In standard C, it's impossible, however several compilers (gcc, clang, tinycc) support a similar thing as an extension (usually accessible with <code>-fms-extensions</code> (on gcc also with <code>-fplan9-extensions</code> which is a superset of <code>-fms-extensions</code>)), which allows you to do:</p>\n<pre><code>struct foo { int x; };\nstruct bar { struct foo; };\nstruct bar b = { 42 }; \nint main()\n{\n   return b.x;\n}\n</code></pre>\n<p>However, there's no resolution for conflicting member names with it, AFAIK.</p>\n", "LastActivityDate": "2017-06-13T14:12:12.263", "Id": "44524027", "CommentCount": "0", "CreationDate": "2017-06-13T14:12:12.263", "ParentId": "44523717", "Score": "2", "OwnerUserId": "1084774"}, "44523970": {"Id": "44523970", "PostTypeId": "2", "Body": "<p>In C (99 and onward) you can access the common initial sub-sequence of union members, even if they weren't the last member written to<sup>1</sup>.</p>\n<p>In C11, you can have anonymous union members. So:</p>\n<pre><code>typedef struct { int x; } foo;\ntypedef struct {\n  union {\n    foo f;\n    int x;\n  };\n} bar;\n</code></pre>\n<hr>\n<ol>\n<li>Yes, that applies to structures. But according to the standard:\n\n<ul>\n<li>A structure pointer, suitably converted, points to the first member.</li>\n<li>A union pointer, suitably converted, points to any union member.</li>\n<li>So their location in memory is the same.</li>\n</ul></li>\n</ol>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2017-06-13T14:14:38.777", "CommentCount": "0", "CreationDate": "2017-06-13T14:09:37.137", "ParentId": "44523717", "Score": "3", "OwnerUserId": "817643", "LastEditDate": "2017-06-13T14:14:38.777"}, "44523783": {"PostTypeId": "2", "Body": "<p>This is not possible in C. In C++ however you can use inheritance which is probably what you were thinking about.</p>\n", "LastActivityDate": "2017-06-13T14:01:05.407", "Id": "44523783", "CommentCount": "0", "CreationDate": "2017-06-13T14:01:05.407", "ParentId": "44523717", "Score": "2", "OwnerUserId": "3320702"}, "44524155": {"Id": "44524155", "PostTypeId": "2", "Body": "<p>Since the C standard guarantees that there isn't padding before the first member of a struct, there isn't padding before the <code>foo</code> in <code>bar</code>, and there isn't padding before the <code>x</code> in <code>foo</code>.  So, a raw memory access to the start of <code>bar</code> will access <code>bar::foo::x</code>.</p>\n<p>You could do something like this:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct _foo\n{\n    int x;\n} foo;\n\ntypedef struct _bar\n{\n    foo f;\n} bar;\n\nint main()\n{\n    bar b;\n    int val = 10;\n\n    // Setting the value:\n    memcpy(&amp;b, &amp;val, sizeof(int));\n    printf(\"%d\\n\", b.f.x);\n\n    b.f.x = 100;\n\n\n    // Reading the value:\n    memcpy(&amp;val, &amp;b, sizeof(int));\n    printf(\"%d\\n\", val);\n    return 0;\n}\n</code></pre>\n<p>As others have noted, C++ offers a more elegant way of doing this through inheritance.</p>\n", "LastEditorUserId": "1773434", "LastActivityDate": "2017-06-13T14:24:41.430", "CommentCount": "0", "CreationDate": "2017-06-13T14:18:30.120", "ParentId": "44523717", "Score": "0", "OwnerUserId": "1773434", "LastEditDate": "2017-06-13T14:24:41.430"}, "44524016": {"PostTypeId": "2", "Body": "<p>In C you can't access members of members like this.</p>\n<p>You can however access members of an anonymous inner struct:</p>\n<pre><code>struct bar {\n    struct {\n        int x;\n    }\n};\n\n...\nstruct bar b;\nb.x = 1;\n</code></pre>\n<p>In C++ you use inheritance:</p>\n<pre><code>struct foo {\n    int x;\n};\n\nstruct bar: public foo {\n};\n\n...\nstruct bar b;\nb.x = 1;\n</code></pre>\n", "LastActivityDate": "2017-06-13T14:11:39.367", "Id": "44524016", "CommentCount": "0", "CreationDate": "2017-06-13T14:11:39.367", "ParentId": "44523717", "Score": "5", "OwnerUserId": "1687119"}});