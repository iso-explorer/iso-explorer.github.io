post_cb({"28883895": {"ParentId": "28883510", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Quoting N4140 [dcl.constexpr]/9:</p>\n<blockquote>\n<p id=\"so_28883510_28883895_0\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have literal type and shall be initialized.</p>\n</blockquote>\n<p>Literal type is defined in [basic.types]/10:</p>\n<blockquote>\n<p id=\"so_28883510_28883895_1\">A type is a literal type if it is:</p>\n<p id=\"so_28883510_28883895_2\">(10.1) \u2014 <code>void</code>; or</p>\n<p id=\"so_28883510_28883895_3\">(10.2) \u2014 a scalar type; or</p>\n<p id=\"so_28883510_28883895_4\">(10.3) \u2014 a reference type; or</p>\n<p id=\"so_28883510_28883895_5\">(10.4) \u2014 an array of literal type; or</p>\n<p id=\"so_28883510_28883895_6\">(10.5) \u2014 a class type (Clause 9) that has all of the following properties:</p>\n<p id=\"so_28883510_28883895_7\">(10.5.1) \u2014 it has a trivial destructor,</p>\n<p id=\"so_28883510_28883895_8\">(10.5.2) \u2014 it is an aggregate type (8.5.1) or has at least one <code>constexpr</code> constructor or constructor template that is not a copy or move constructor, and</p>\n<p id=\"so_28883510_28883895_9\">(10.5.3) \u2014 all of its non-static data members and base classes are of non-volatile literal types.</p>\n</blockquote>\n<p>Scalar type is in paragraph 9:</p>\n<blockquote>\n<p id=\"so_28883510_28883895_10\">Arithmetic types (3.9.1), enumeration types, pointer types, pointer to member types (3.9.2), <code>std::nullptr_t</code>, and cv-qualified versions of these types (3.9.3) are collectively called <em>scalar types</em>.</p>\n</blockquote>\n<p><code>int</code> is arithmetic, so <code>volatile int</code> is a scalar type and hence a literal type. <code>constexpr volatile int i = 5;</code> is thus a well-formed declaration.</p>\n<p>Interestingly, an expression that evaluates <code>i</code> cannot be a <em>core-constant-expression</em> since it applies an lvalue-to-rvalue conversion to a glvalue of volatile type ([expr.const]/2). Consequently, expressions that evaluate <code>i</code> are neither <em>integral constant expressions</em> nor <em>constant expressions</em>. I'm not sure that the <code>constexpr</code> in that declaration has any effect beyond making <code>i</code> implicitly <code>const</code>, and (nod to <a href=\"https://stackoverflow.com/questions/28883510/can-constexpr-be-combined-with-volatile#comment46030204_28883895\">@T.C.</a>) requiring its initializer to be a constant expression.</p>\n<p>I've reported this as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65327\" rel=\"nofollow noreferrer\">GCC bug 65327</a>, we'll see what the GCC folks have to say.</p>\n<p>2015-03-16 Update: Bug has been fixed for GCC 5.</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:06.667", "Id": "28883895", "Score": "17", "CreationDate": "2015-03-05T17:22:26.580", "LastActivityDate": "2015-03-16T20:40:41.223"}, "28883510": {"CommentCount": "17", "CreationDate": "2015-03-05T17:02:29.390", "PostTypeId": "1", "AcceptedAnswerId": "28885047", "LastEditorUserId": "1708801", "LastActivityDate": "2015-03-16T20:40:41.223", "LastEditDate": "2015-03-05T19:04:39.413", "ViewCount": "871", "FavoriteCount": "3", "Title": "Can constexpr be combined with volatile?", "Id": "28883510", "Score": "24", "Body": "<p>The following snippet works fine in Clang 3.5 but not in GCC 4.9.2:</p>\n<pre><code>int main()\n{\n    constexpr volatile int i = 5;\n}\n</code></pre>\n<p>with error:</p>\n<blockquote>\n<p id=\"so_28883510_28883510_0\">error: both 'volatile' and 'constexpr' cannot be used here</p>\n</blockquote>\n<p>If I inspect the assembly that Clang generates, it shows <code>5</code> as expected:</p>\n<pre><code>movl    $5, -4(%rsp)\n</code></pre>\n<p>In GCC, <code>constexpr int i = 5</code> is optimized away, but <code>volatile int i = 5</code> also shows <code>5</code> in the assembly. <code>volatile const int i = 5</code> compiles in both compilers. It's not a foreign concept for something to be both volatile and const at the same time.</p>\n<p>Which compiler is correct by the standards?</p>\n", "Tags": "<c++><c++11><gcc><clang><language-lawyer>", "OwnerUserId": "4637702", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28883510_28883895_10": {"section_id": 7207, "quality": 0.85, "length": 17}, "so_28883510_28883895_0": {"section_id": 5425, "quality": 1.0, "length": 13}, "so_28883510_28883895_9": {"section_id": 7208, "quality": 0.9090909090909091, "length": 10}, "so_28883510_28883895_6": {"section_id": 7208, "quality": 0.8571428571428571, "length": 6}, "so_28883510_28883895_8": {"section_id": 7208, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_28883510_28883895_10": {"section_id": 6951, "quality": 0.8, "length": 16}, "so_28883510_28883895_0": {"section_id": 5220, "quality": 1.0, "length": 13}, "so_28883510_28883895_9": {"section_id": 6952, "quality": 0.8181818181818182, "length": 9}, "so_28883510_28883895_6": {"section_id": 6952, "quality": 0.8571428571428571, "length": 6}, "so_28883510_28883895_8": {"section_id": 6952, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_28883510_28883895_9": {"section_id": 8717, "quality": 0.9090909090909091, "length": 10}, "so_28883510_28883895_8": {"section_id": 8717, "quality": 0.8461538461538461, "length": 11}, "so_28883510_28883895_10": {"section_id": 8716, "quality": 0.85, "length": 17}, "so_28883510_28883895_6": {"section_id": 8717, "quality": 0.8571428571428571, "length": 6}, "so_28883510_28883895_0": {"section_id": 6847, "quality": 1.0, "length": 13}}}, "28885047": {"ParentId": "28883510", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Yes, this is valid, there was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4093.html#1688\" rel=\"nofollow noreferrer\">defect report 1688: Volatile constexpr variables </a> that was filed for this, saying:</p>\n<blockquote>\n<p id=\"so_28883510_28885047_0\">There does not appear to be language in the current wording stating\n  that constexpr cannot be applied to a variable of volatile-qualified\n  type. Also, the wording in 5.19 [expr.const] paragraph 2 referring to\n  \u201ca non-volatile object defined with constexpr\u201d might lead one to infer\n  that the combination is permitted but that such a variable cannot\n  appear in a constant expression. What is the intent?</p>\n</blockquote>\n<p>it was rejected as not a defect(<em>NAD</em>), the response and rationale was:</p>\n<blockquote>\n<p id=\"so_28883510_28885047_1\">The combination is intentionally permitted and could be used in some\n  circumstances to force constant initialization.</p>\n</blockquote>\n<p>As the DR points out such a variable is itself not usable in a <em>constant expression</em>:</p>\n<pre><code>constexpr volatile int i = 5;    \nconstexpr int y = i ;         // Not valid since i is volatile\n</code></pre>\n<p>Section <em>[expr.const]/2</em> includes all the cases that makes a conditional-expression not a core constant expression including:</p>\n<blockquote>\n<p id=\"so_28883510_28885047_2\">an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n</blockquote>\n<p>and all the exception require:</p>\n<blockquote>\n<p id=\"so_28883510_28885047_3\">[...]that refers to a non-volatile [...] object [...]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-03-09T12:52:08.853", "Id": "28885047", "Score": "22", "CreationDate": "2015-03-05T18:25:17.420", "LastActivityDate": "2015-03-09T12:52:08.853"}});