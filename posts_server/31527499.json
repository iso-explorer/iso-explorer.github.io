post_cb({"bq_ids": {"n4140": {"so_31527499_31527581_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5435}, "so_31527499_31527581_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5435}}, "n3337": {"so_31527499_31527581_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5230}, "so_31527499_31527581_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5230}}, "n4659": {"so_31527499_31527581_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 6862}, "so_31527499_31527581_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 6862}}}, "31527499": {"ViewCount": "143", "Body": "<p>Does volatile write to volatile const introduce undefined behavior? What if I drop volatile when writing?</p>\n<pre><code>volatile const int x = 42;\nconst volatile int *p = &amp;x;\n*(volatile int *)p = 8; // Does this line introduce undefined behavior?\n*(int *)p = 16; // And what about this one?\n</code></pre>\n<p><a href=\"http://codepad.org/aTRVq51D\" rel=\"nofollow\">Compilable code</a></p>\n", "Title": "Can indirect change of volatile const be treated as undefined behavior?", "CreationDate": "2015-07-20T22:37:35.703", "LastActivityDate": "2015-07-21T00:01:04.200", "CommentCount": "1", "PostTypeId": "1", "Id": "31527499", "Score": "3", "OwnerUserId": "4928642", "Tags": "<c++><c><volatile><undefined-behavior>", "AnswerCount": "2"}, "31527587": {"Id": "31527587", "PostTypeId": "2", "Body": "<p>Writing to a variable that is originally <code>const</code> is undefined behaviour, so all your example writes to <code>*p</code> are undefined. </p>\n<p>Removing <code>volatile</code> in itself is not undefined in and of itself. </p>\n<p>However, if we have something like <code>const volatile int *p = (const volatile int*)0x12340000; /* Address of hw register */</code>, then removing <code>volatile</code> may cause the hardware to update the register value, but your program doesn't pick it up. (E.g. if we \"busy wait\" with <code>while(*p &amp; 0x01) ;</code>, the compiler should reload the value pointed to by <code>p</code> every time, but <code>while((*(const int *)p) &amp; 1) ;</code>, the compiler is entirely free to read the value ones, and re-use the initial value to loop forever if bit 0 is set).</p>\n<p><strike>You could of course have <code>extern volatie int x;</code> and then use <code>const volatile int *p = &amp;x;</code> in some code, and <code>x</code> gets updated by some other piece of code outside of your current translation unit (e.g. another thread) - in which case removing either <code>const</code> or <code>volatile</code> is valid, but as above, you may \"miss\" updated values because the compiler doesn't expect the global value to get updated outside of your module unless you call functions.</strike> [Edit, no, taking away <code>volatile</code> by casting the value is also forbidden in the standard - it is however valid to add <code>const</code> or <code>volatile</code> to something, and then remove it again if it the original object referred to did not have it]. </p>\n<p>Edti2: <code>volatile</code> is needed to tell the compiler that \"the value may change at any time, even if you think nothing should have changed it\". This happens, in general, in two situations:</p>\n<ol>\n<li>Hardware registers that are updated outside of the software altogether - such as status registers for a serial port, a timer-counter register, or interrupt status of the interrupt controller, to name a few case - there are thousands of other variations, but it's all the same idea: The hardware changes the value, without direct relation to the software that is accessing such registers.</li>\n<li>Variabled updated by another thread within the process (or in case of shared memory, by another process) - again, the compiler won't be able to \"see\" such changes. Often, one can write code that appear to function correctly by calling a function inside wait-loops and such, and the compiler will the reload values of non-local variables anyway, but some time later the compiler decides to inline that function call, and then realizes that the code is not updating that value, so doesn't reload the value -&gt; bug when you inspect the \"updated\" value and find the same old value that the compiler had already loaded earlier.</li>\n</ol>\n<p>Note also that <code>volatile</code> is NOT a guarantee for any kind of thread/process correctness - it will just guarantee that the compiler doesn't skip over reads or writes to that variable. It is still up to the programmer to ensure that for example multiple values that are dependent on ordering are indeed updated in the correct order, and on systems where caches are not coherent between processing units, that the caches are made coherent via the software [for example a CPU and a GPU may not use coherent memory updates, so a write by the CPU does not reach the GPU until the cache has been flushed on the CPU - no amount of applying <code>volatile</code> to the code will fix this]</p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2015-07-20T23:45:30.493", "Score": "5", "CreationDate": "2015-07-20T22:47:52.443", "ParentId": "31527499", "CommentCount": "10", "LastEditDate": "2015-07-20T23:45:30.493", "OwnerUserId": "1919155"}, "31527581": {"Id": "31527581", "PostTypeId": "2", "Body": "<p>It is undefined behavior (for both statements) as you attempt to modify the \"initial\" <code>const</code> object. From C11 (N1570) 6.7.3/p6 <em>Type qualifiers</em> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_31527499_31527581_0\">If an attempt is made to modify an object defined with a\n  const-qualified type through use of an lvalue with <strong>non-const-qualified\n  type</strong>, the behavior is undefined.</p>\n</blockquote>\n<p>For completeness it may be worth adding, that Standard says also that:</p>\n<blockquote>\n<p id=\"so_31527499_31527581_1\">If an attempt is made to refer to an object defined with a\n  volatile-qualified type through use of an lvalue with\n  <strong>non-volatile-qualified type</strong>, the behavior is undefined.</p>\n</blockquote>\n<p>Hence latter statement, that is:</p>\n<pre><code>*(int *)p = 16;\n</code></pre>\n<p>is undefined for second phrase as well (it's a \"double UB\").</p>\n<p>I believe that rules are the same for C++, but don't own copy of C++14 to confirm.</p>\n", "LastEditorUserId": "586873", "LastActivityDate": "2015-07-21T00:01:04.200", "Score": "8", "CreationDate": "2015-07-20T22:46:58.830", "ParentId": "31527499", "CommentCount": "9", "LastEditDate": "2015-07-21T00:01:04.200", "OwnerUserId": "586873"}});