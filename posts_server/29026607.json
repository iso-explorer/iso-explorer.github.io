post_cb({"bq_ids": {"n4140": {"so_29026607_29027437_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 3075}}, "n3337": {"so_29026607_29027437_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 2952}}, "n4659": {"so_29026607_29027437_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 3835}}}, "29027456": {"Id": "29027456", "PostTypeId": "2", "Body": "<p>Yes, future::wait() synchronizes with making the future valid (e.g. return of a async or setting a promise), so what you are doing is safe as far I can tell from that part of the code.</p>\n<p>However, I find your using of a shared pointer questionable: Giving a shared pointer to another thread means giving that thread (shared) ownership, but calling std::move on the contents of a shared_ptr is almost as bad as manually calling delete on it.</p>\n", "LastActivityDate": "2015-03-13T08:07:41.210", "Score": "0", "CreationDate": "2015-03-13T08:07:41.210", "ParentId": "29026607", "CommentCount": "3", "OwnerUserId": "2881849"}, "29026607": {"ViewCount": "151", "Body": "<p>I am writing an application that asynchronously accesses a database. In my example serialization is handled by the <code>handleAllGroups</code> function. This functions takes a functor, that actually works on the database objects. Since I am not happy with the returned type I wrap up everything in a deferred async call, to create what I want. Everything seems to work smoothly. Still I am a bit concerned about data races since I have no atomic or mutex protection. </p>\n<p>QUESTION: May it be possible, that the compiler decides to perform <code>std::move(*data)</code> before <code>fut.wait()</code>? This is important, since, data is shared with an other thread! (ftor takes shared ownership and is invoked in the database thread, via handleAllGroups)</p>\n<p>Any help is appreciated!</p>\n<pre><code>handleGroupCol_ftor\nmake_getGroupNamesFtor(std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt;&amp; data);\n\nstd::future&lt;MayBeStrVector&gt;\ngetAllGroupNames()\n{\n  // FIXME: This function is fine, but relies on ftor not\n  // sharing ownership of data in other places (the move)\n  auto data = std::make_shared&lt;std::vector&lt;std::string&gt;&gt;();\n  auto ftor = make_getGroupNamesFtor(data);\n  return std::async(std::launch::deferred,\n        [data](std::future&lt;result&gt;&amp;&amp; fut)-&gt;MayBeStrVector{\n          fut.wait();\n          return {fut.get(), std::move(*data)};\n        },\n        handleAllGroups(ftor));\n}\n</code></pre>\n", "AcceptedAnswerId": "29027437", "Title": "Data race with C++ std::future. Compiler reorder", "CreationDate": "2015-03-13T07:05:10.190", "Id": "29026607", "CommentCount": "8", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-03-13T08:07:41.210", "Score": "0", "OwnerUserId": "3436431", "Tags": "<c++><multithreading>", "AnswerCount": "2"}, "29027437": {"Id": "29027437", "PostTypeId": "2", "Body": "<p>On the assumption that all writes to what <code>data</code> pointed to on the other thread is sequenced before the making-<code>fut</code>-ready, you are safe. [futures.state]/p9:</p>\n<blockquote>\n<p id=\"so_29026607_29027437_0\">Calls to functions that successfully set the stored result of a shared\n  state synchronize with (1.10) calls to functions successfully\n  detecting the ready state resulting from that setting. The storage of\n  the result (whether normal or exceptional) into the shared state\n  synchronizes with (1.10) the successful return from a call to a\n  waiting function on the shared state.</p>\n</blockquote>\n<p>Without getting bogged down in standardese, the <em>synchronize with</em> relationship here means that everything that is sequenced before the call that set the stored result in the thread setting the result <em>happens before</em> everything sequenced after the <code>wait()</code> call. </p>\n", "LastActivityDate": "2015-03-13T08:06:12.583", "Score": "1", "CreationDate": "2015-03-13T08:06:12.583", "ParentId": "29026607", "CommentCount": "0", "OwnerUserId": "2756719"}});