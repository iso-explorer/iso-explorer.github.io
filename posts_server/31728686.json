post_cb({"bq_ids": {"n4140": {"so_31728686_31728949_0": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_31728686_31728949_1": {"length": 25, "quality": 0.7142857142857143, "section_id": 599}, "so_31728686_31729647_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 602}, "so_31728686_31729647_1": {"length": 24, "quality": 0.6666666666666666, "section_id": 630}, "so_31728686_31729647_0": {"length": 13, "quality": 0.8125, "section_id": 3296}}, "n3337": {"so_31728686_31728949_0": {"length": 21, "quality": 0.875, "section_id": 3195}, "so_31728686_31728949_1": {"length": 25, "quality": 0.7142857142857143, "section_id": 589}, "so_31728686_31729647_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 592}, "so_31728686_31729647_1": {"length": 20, "quality": 0.5555555555555556, "section_id": 621}, "so_31728686_31729647_0": {"length": 13, "quality": 0.8125, "section_id": 3166}}, "n4659": {"so_31728686_31729647_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 628}, "so_31728686_31728949_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 622}, "so_31728686_31728949_0": {"length": 21, "quality": 0.875, "section_id": 4091}, "so_31728686_31729647_1": {"length": 24, "quality": 0.6666666666666666, "section_id": 658}, "so_31728686_31729647_0": {"length": 13, "quality": 0.8125, "section_id": 4058}}}, "31728949": {"Id": "31728949", "PostTypeId": "2", "Body": "<p>Visual Studio is wrong in accepting your code - it is ill-formed, and should fail to compile. gcc and clang are correct in rejecting it.</p>\n<p>The key bullet point in list-initialization here is:</p>\n<blockquote>\n<p id=\"so_31728686_31728949_0\">Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated\n  and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see\n  below) is required to convert any of the arguments, the program is ill-formed.</p>\n</blockquote>\n<p>For which we reference [over.match.list]:</p>\n<blockquote>\n<p id=\"so_31728686_31728949_1\">When objects of non-aggregate class type T are list-initialized such that 8.5.4 specifies that overload resolution\n  is performed according to the rules in this section, overload resolution selects the constructor in two phases:<br>\n  \u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the\n  argument list consists of the initializer list as a single argument.</br></p>\n</blockquote>\n<p>We have two such candidate functions - <code>(1)</code> and <code>(2)</code>. Neither is a better match than the other, since both conversions from <code>double</code> to <code>int</code> and <code>float</code> have Conversion rank. So the call is ambiguous. Note that even though there is a candidate with Exact Rank (<code>A(double )</code>), we consider the <code>initializer_list</code> constructors <em>first</em>. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-30T17:19:00.043", "Score": "2", "CreationDate": "2015-07-30T16:12:12.340", "ParentId": "31728686", "CommentCount": "12", "OwnerUserId": "2069064", "LastEditDate": "2015-07-30T17:19:00.043"}, "31729647": {"Id": "31729647", "PostTypeId": "2", "Body": "<p>The code is ill-formed. \u00a78.5.4/(3.6) applies:</p>\n<blockquote>\n<p id=\"so_31728686_31729647_0\">Otherwise, if <code>T</code> is a class type, constructors are considered. The\n  applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7).</p>\n</blockquote>\n<p>Now, \u00a713.3.3.1.5 goes</p>\n<blockquote>\n<p id=\"so_31728686_31729647_1\">When an argument is an initializer list (8.5.4), it is not an expression and special rules apply for converting\n  it to a parameter type. [\u2026]\n  if the parameter type is <code>std::initializer_list&lt;X&gt;</code> and all\n  the elements of the initializer list can be implicitly converted to <code>X</code>,\n  <strong>the implicit conversion sequence is the worst conversion necessary to\n  convert an element of the list to <code>X</code></strong>, or if the initializer list has no\n  elements, the identity conversion.</p>\n</blockquote>\n<p>Converting <code>1.1</code>, which is of type <code>double</code> (!), to <code>int</code> is a Floating-integral conversion with Conversion rank, while the conversion from <code>1.1</code> to <code>float</code> is a Floating point conversion - also having Conversion rank.</p>\n<p><a href=\"https://i.stack.imgur.com/BiGoz.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/BiGoz.png\"/></a></p>\n<p>Thus both conversions are equally good, and since \u00a713.3.3.2/(3.1) cannot distinguish them either, the call is ambiguous. Note that narrowing doesn't play a role until after overload resolution is done and hence cannot affect the candidate set or the selection process. More precisely, a candidate must meet the requirement set in 13.3.2/3:</p>\n<blockquote>\n<p id=\"so_31728686_31729647_2\">Second, for <code>F</code> to be a viable function, there shall exist for each\n  argument an <em>implicit conversion sequence</em> (13.3.3.1) that converts\n  that argument to the corresponding parameter of <code>F</code>.</p>\n</blockquote>\n<p>However, as shown in the second quote, the implicit conversion sequence that converts <code>{1.1}</code> to <code>std::initializer_list&lt;int&gt;</code> is the worst conversion from <code>1.1</code> to <code>int</code>, which is a Floating-integral conversion - and a valid (and existing!) one at that. </p>\n<p><hr>\nIf instead you pass <code>{1.1f}</code> or alter the <code>initializer_list&lt;float&gt;</code> to <code>&lt;double&gt;</code>, the code is well-formed, as converting <code>1.1f</code> to <code>float</code> is an identity conversion. The standard gives a corresponding example in (3.6):</hr></p>\n<blockquote>\n<p id=\"so_31728686_31729647_3\">[ <em>Example</em>:</p>\n<pre><code>struct S {\n    S(std::initializer_list&lt;double&gt;); // #1\n    S(std::initializer_list&lt;int&gt;);    // #2\n\n};\nS s1 = { 1.0, 2.0, 3.0 }; // invoke #1\n</code></pre>\n<p id=\"so_31728686_31729647_4\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Even more interestingly,</p>\n<pre><code>struct S {\n    S(std::initializer_list&lt;double&gt;); // #1\n    S(std::initializer_list&lt;int&gt;);    // #2\n\n};\nS s1 = { 1.f }; // invoke #1 \n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/5867eac14f1c78e7\" rel=\"nofollow noreferrer\"><strong>Is also valid</strong></a> - because the conversion from <code>1.f</code> to <code>double</code> is a Floating point <strong>promotion</strong>, having Promotion rank, which is better than Conversion rank. </p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-07-30T17:20:55.730", "Score": "3", "CreationDate": "2015-07-30T16:49:25.283", "ParentId": "31728686", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2015-07-30T17:20:55.730"}, "31728686": {"ViewCount": "317", "Body": "<p>I tested the following code on Visual Studio and it compiles and prints \"A(double)\".</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nstruct A {\n    A(std::initializer_list&lt;int&gt;) { puts(\"initializer_list&lt;int&gt;\"); }        // (1)\n    A(std::initializer_list&lt;float&gt;) { puts(\"initializer_list&lt;float&gt;\"); }    // (2)\n    A(double) { puts(\"A(double)\"); }                                        // (3)\n};\n\nint main() {\n    A var{ 1.1 };   \n}\n</code></pre>\n<p>However both IntelliSense and <a href=\"http://ideone.com/ZS1Mcm\" rel=\"nofollow\">http://ideone.com/ZS1Mcm</a> disagree, saying that more than one instance of constructor \"A::A\" matches the argument list (meaning both initializer-list constructors). Note that if either (1) or (2) is removed, code does not compile anymore, as \"conversion from 'double' to 'float' requires a narrowing conversion\".</p>\n<p>Is this a bug? The behaviour feels inconsistent, but I see the same behaviour in VS13 and VS15 so maybe there is more to it? </p>\n", "AcceptedAnswerId": "31729647", "Title": "Ambiguous overload resolution with initializer_list", "CreationDate": "2015-07-30T15:59:16.317", "Id": "31728686", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-30T17:17:28.067", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-30T17:20:55.730", "Score": "10", "OwnerUserId": "4461183", "Tags": "<c++><visual-studio><c++11>", "AnswerCount": "2"}});