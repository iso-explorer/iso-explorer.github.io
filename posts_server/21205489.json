post_cb({"21205834": {"ParentId": "21205489", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_21205489_21205834_0\">What I don't know is whether the last method has still read access to the objects?</p>\n</blockquote>\n<p>The standard defines two cases in which the lifetime of a temporary is extended, at \u00a712.2/4:</p>\n<blockquote>\n<p id=\"so_21205489_21205834_1\">The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument is sequenced before the construction of the next array element, if any.</p>\n</blockquote>\n<p>which is supposed to allow initializations of arrays. The second, which is of more concern is connected to <em>references</em> (at \u00a712.2/5):</p>\n<blockquote>\n<p id=\"so_21205489_21205834_2\">The second context is when a reference is bound to a temporary.118 The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n</blockquote>\n<p>As you can see, if a temporary object is bounded to a reference, the lifetime of the object extends to that of the reference. After the \"except:\" it is listed:</p>\n<blockquote>\n<p id=\"so_21205489_21205834_3\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</p>\n</blockquote>\n<p>This basically says, that no matter how you define the function body of <code>add</code>, if <code>add</code>'s signature is <code>T add(const Obj&amp;)</code> (with any <code>T</code>), the temporary object will be destroyed at the end of the call to that function. This means that in:</p>\n<pre><code>s.add(Obj(...));\n</code></pre>\n<p>The temporary object will be destroyed at the end of the function execution.</p>\n<p>Therefore, for the above reasons: no. It won't still have read access to the object. You'll have a reference to a deallocated object.</p>\n<hr>\n<blockquote>\n<p id=\"so_21205489_21205834_4\">Storing actual object by value in the Set won't work, because Obj is polymorph.</p>\n</blockquote>\n<p>You can have a polymorphic behavior and still hold the objects. You can use for example an <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\"><code>std::vector</code></a> of <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow\"><code>std::unique_ptr&lt;Obj&gt;</code></a>. The creation of a new object will happen like this:</p>\n<pre><code>vector.emplace_back(std::unique_ptr&lt;Obj&gt;(new Derived()));\n</code></pre>\n<p>and you will have a polymorphic vector that also store the values.</p>\n</hr>", "OwnerUserId": "493122", "PostTypeId": "2", "Id": "21205834", "Score": "0", "CreationDate": "2014-01-18T15:06:12.937", "LastActivityDate": "2014-01-18T15:06:12.937"}, "21205489": {"CommentCount": "2", "ViewCount": "101", "CreationDate": "2014-01-18T14:35:02.207", "LastActivityDate": "2014-01-18T15:06:12.937", "Title": "Lifetime of temporary objects passed to a member storing a constant reference", "AcceptedAnswerId": "21205834", "PostTypeId": "1", "Id": "21205489", "Score": "1", "Body": "<p>Suppose I have an object Obj and a Set s. The Set is collecting const Obj&amp; references in an array. How long will the actual Obj's be available:</p>\n<pre><code>{\n    Set s;\n    s.add(Obj(...));\n    s.add(Obj(...));\n\n    s.doWhateverWithTheObjs();\n\n}\n// after this it's guaranteed to not work anymore, if s was on the heap. Obj's will die with stack\n</code></pre>\n<p>I have not implemented that yet as I first want to confirm that this is actually going to work.</p>\n<p>I know it won't work when the Set is on the heap and it's lifetime is longer then the lifetime of the caller (I made brackets to illustrate this).</p>\n<p>What I don't know is whether the last method has still read access to the objects? Storing actual object by value in the Set won't work, because Obj is polymorph. If possible, I don't want to use pointers for usability reasons.</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "420097", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_21205489_21205834_1": {"section_id": 381, "quality": 0.9629629629629629, "length": 26}, "so_21205489_21205834_2": {"section_id": 382, "quality": 0.8571428571428571, "length": 18}, "so_21205489_21205834_3": {"section_id": 382, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_21205489_21205834_1": {"section_id": 372, "quality": 0.9629629629629629, "length": 26}, "so_21205489_21205834_2": {"section_id": 373, "quality": 0.8571428571428571, "length": 18}, "so_21205489_21205834_3": {"section_id": 373, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_21205489_21205834_1": {"section_id": 396, "quality": 0.9629629629629629, "length": 26}, "so_21205489_21205834_2": {"section_id": 397, "quality": 0.8095238095238095, "length": 17}, "so_21205489_21205834_3": {"section_id": 397, "quality": 0.9230769230769231, "length": 12}}}, "21205510": {"ParentId": "21205489", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As long as you're inside the function, unless you replicate the object inside <code>s.add</code> (which, according to your question, you don't (Set is collecting const Obj&amp; references in an array).</p>\n<p>Second thought, not even during the function, since each <code>Obj</code> instance is allocated on the stack of the function <strong>only temporarily</strong>, during the call to <code>s.add(Obj(...));</code>.</p>\n<p>In other words, don't do it this way (you must replicate the object inside <code>s.add</code>).</p>\n<p><strong>Supplemental:</strong></p>\n<p>There is nothing wrong with having const Obj&amp; references in an array, but you gotta have the actual instances allocated somewhere, whether it's on the heap, or in the data-section (as global variables)... or on the stack of the calling function (as local variables) if you're not using them outside the function.</p>\n", "OwnerUserId": "1382251", "LastEditorUserId": "1382251", "LastEditDate": "2014-01-18T14:43:20.163", "Id": "21205510", "Score": "0", "CreationDate": "2014-01-18T14:37:44.947", "LastActivityDate": "2014-01-18T14:43:20.163"}});