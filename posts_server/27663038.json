post_cb({"bq_ids": {"n4140": {"so_27663038_27666854_6": {"length": 4, "quality": 1.0, "section_id": 194}, "so_27663038_27666854_2": {"length": 6, "quality": 1.0, "section_id": 202}, "so_27663038_27666854_3": {"length": 6, "quality": 1.0, "section_id": 202}, "so_27663038_27666854_4": {"length": 9, "quality": 0.75, "section_id": 202}}, "n3337": {"so_27663038_27666854_4": {"length": 11, "quality": 0.9166666666666666, "section_id": 196}, "so_27663038_27666854_2": {"length": 6, "quality": 1.0, "section_id": 196}, "so_27663038_27666854_3": {"length": 6, "quality": 1.0, "section_id": 196}, "so_27663038_27666854_6": {"length": 4, "quality": 1.0, "section_id": 188}}, "n4659": {"so_27663038_27666854_4": {"length": 9, "quality": 0.75, "section_id": 208}, "so_27663038_27666854_2": {"length": 6, "quality": 1.0, "section_id": 208}, "so_27663038_27666854_3": {"length": 6, "quality": 1.0, "section_id": 208}, "so_27663038_27666854_6": {"length": 4, "quality": 1.0, "section_id": 74}}}, "27663038": {"ViewCount": "166", "Body": "<p>I came across an inconsistency in the way current C++ compilers (clang/gcc) determine whether a name is dependent. In the following example, <code>A::f</code> is dependent but <code>::f</code> is not, resulting in an error when the latter is used.</p>\n<pre><code>template&lt;typename&gt;\nstruct B\n{\n    typedef int Type;\n};\n\ntemplate&lt;typename U&gt;\nstatic U f(U u);\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    template&lt;typename U&gt;\n    static U f(U u);\n\n    typename B&lt;decltype(f(0))&gt;::Type m1; // typename required\n    B&lt;decltype(::f(0))&gt;::Type m2; // typename not required\n};\n</code></pre>\n<p>The inconsistent part is that the declaration of <code>A::f</code> does not depend on a template parameter of <code>A</code>, meaning it seems unnecessary to treat it as a dependent name.</p>\n<p>This behaviour seems to be covered by the following wording in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_27663038_27663038_0\">[temp.dep.expr]/3</p>\n<p id=\"so_27663038_27663038_1\">An id-expression is type-dependent if it contains</p>\n<ul>\n<li>an identifier associated by name lookup with one or more declarations declared with a dependent type</li>\n</ul>\n<p id=\"so_27663038_27663038_2\">[temp.dep.type]/3</p>\n<p id=\"so_27663038_27663038_3\">A type is dependent if it is</p>\n<ul>\n<li>a compound type constructed from any dependent type</li>\n</ul>\n</blockquote>\n<p>The declaration of <code>::f</code> is clearly not dependent, as its type depends only on its own template parameters. Why should <code>A::f</code> be treated differently?</p>\n", "AcceptedAnswerId": "27666854", "Title": "Is a function type dependent if it depends only on its own template parameters?", "CreationDate": "2014-12-26T23:35:30.273", "Id": "27663038", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-27T13:03:11.410", "LastEditorUserId": "1690864", "LastActivityDate": "2014-12-27T13:16:41.433", "Score": "4", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><dependent-name>", "AnswerCount": "1"}, "27666854": {"Id": "27666854", "PostTypeId": "2", "Body": "<p>I think that based on the standard, <code>f</code> is non-dependent, actually.</p>\n<blockquote>\n<p id=\"so_27663038_27666854_0\"><strong>14.6.2.2 Type-dependent expressions [temp.dep.expr]</strong></p>\n<p id=\"so_27663038_27666854_1\">3 An <em>id-expression</em> is type-dependent if it contains</p>\n<ul>\n<li>an <em>identifier</em> associated by name lookup with one or more declarations declared with a dependent type,</li>\n</ul>\n</blockquote>\n<p>This applies equally to the global template function as it does to the member template function: not at all. The return type of <code>U</code> is dependent inside the definitions of the template functions, but for the caller, the function type of <code>f&lt;int&gt;</code> has already been transformed from <code>U(U)</code> to <code>int(int)</code>. At any rate, it wouldn't explain why compilers treat the two cases differently, and it also would not explain why a non-template member function is also treated as dependent.</p>\n<blockquote id=\"so_27663038_27666854_2\">\n<ul>\n<li>a <em>template-id</em> that is dependent,</li>\n<li>a <em>conversion-function-id</em> that specifies a dependent type, or</li>\n</ul>\n</blockquote>\n<p>These do not apply. There is no <code>&lt;</code> or <code>&gt;</code> that must always be present in a <em>template-id</em>, and there is no conversion function being called.</p>\n<blockquote id=\"so_27663038_27666854_3\">\n<ul>\n<li>a <em>nested-name-specifier</em> or a <em>qualified-id</em> that names a member of an unknown specialization;</li>\n</ul>\n</blockquote>\n<p>See below.</p>\n<blockquote>\n<p id=\"so_27663038_27666854_4\">or if it names a static data member of the current instantiation that has type \"array of unknown bound of <code>T</code>\" for some <code>T</code> (14.5.1.3).</p>\n</blockquote>\n<p>This also does not apply: there are no arrays involved.</p>\n<p>So it depends on whether <code>f</code> is a member of an unknown specialization. But it isn't:</p>\n<blockquote>\n<p id=\"so_27663038_27666854_5\"><strong>14.6.2.1 Dependent types [temp.dep.type]</strong></p>\n<p id=\"so_27663038_27666854_6\">5 A name is a <em>member of an unknown specialization</em> if it is</p>\n<ul>\n<li>A <em>qualified-id</em> in which [...].</li>\n<li>A <em>qualified-id</em> in which [...].</li>\n<li>An <em>id-expression</em> denoting the member in a class member access expression (5.2.5) in which [...].</li>\n</ul>\n</blockquote>\n<p>These cannot apply: <code>f</code> is neither qualified nor part of a class member access expression.</p>\n<p>Since the only way <code>f</code> can be dependent is if it is a member of an unknown specialization, and it is not a member of an unknown specialization, <code>f</code> must not be dependent.</p>\n<p>As for why compilers nonetheless treat it as dependent, I have no answer. Either some part of my answer here is wrong, the compilers have bugs, or the compilers follow a different version of the C++ standard. Testing with an example that works regardless of whether names are dependent shows a few variations in compiler treatment:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nvoid f(const char *s, ...) { std::printf(\"%s: non-dependent\\n\", s); }\n\nstruct S1 { };\n\ntemplate &lt;typename T&gt;\nstruct S2 {\n  static S1 a;\n  static S1 b() { return {}; }\n  template &lt;typename U&gt;\n  static U c() { return {}; }\n  static void z() {\n    f(\"S1()\", S1()); // sanity check: clearly non-dependent\n    f(\"T()\", T()); // sanity check: clearly dependent\n    f(\"a\", a); // compiler agreement: non-dependent\n    f(\"b()\", b()); // compiler disagreement: dependent according to GCC 4.8, non-dependent according to clang\n    f(\"c&lt;T&gt;()\", c&lt;T&gt;()); // sanity check: clearly dependent\n    f(\"c&lt;S1&gt;()\", c&lt;S1&gt;()); // compiler agreement: dependent\n    f(\"decltype(b())()\", decltype(b())()); // compiler agreement: dependent\n  }\n};\n\nvoid f(const char *s, S1) { std::printf(\"%s: dependent\\n\", s); }\n\n// Just to show it's possible to specialize the members\n// without specializing the full template.\ntemplate &lt;&gt;\nS1 S2&lt;S1&gt;::b() { return {}; }\ntemplate &lt;&gt;\ntemplate &lt;&gt;\nS1 S2&lt;S1&gt;::c&lt;S1&gt;() { return {}; }\n\nint main() {\n  S2&lt;S1&gt;::z();\n}\n</code></pre>\n<p>This difference in clang's treatment of <code>b()</code>, <code>decltype(b())()</code>, and <code>c&lt;S1&gt;()</code> is particularly troubling to me. It just doesn't make any sense. They're clearly all equally dependent. I can understand from an implementation point-of-view that care must be taken not to generate code for the member functions just yet because there might be specialisations of <code>S2&lt;S1&gt;::b</code> or <code>S2&lt;S1&gt;::c&lt;S1&gt;</code>, but that applies to all, and has no effect on the return type.</p>\n", "LastEditorUserId": "743382", "LastActivityDate": "2014-12-27T12:39:36.473", "Score": "3", "CreationDate": "2014-12-27T11:39:04.267", "ParentId": "27663038", "CommentCount": "5", "OwnerUserId": "743382", "LastEditDate": "2014-12-27T12:39:36.473"}});