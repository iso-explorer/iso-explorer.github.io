post_cb({"4863368": {"Id": "4863368", "PostTypeId": "2", "Body": "<p>The established way of doing it is with an automatic local variable:</p>\n<pre><code>ParamClass myParam;\nmyOjbect.myMethod(myParam);\n</code></pre>\n<p>By using <code>new</code> in the way you did, you're generating a memory leak. Nothing will dispose of that object once the function returns - C++ does not have garbage collection as some other languages do.</p>\n", "LastActivityDate": "2011-02-01T13:49:30.763", "CommentCount": "0", "CreationDate": "2011-02-01T13:49:30.763", "ParentId": "4863324", "Score": "1", "OwnerUserId": "5987"}, "bq_ids": {"n4140": {"so_4863324_4863373_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 382}, "so_4863324_4863373_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 382}, "so_4863324_4863373_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 380}}, "n3337": {"so_4863324_4863373_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 373}, "so_4863324_4863373_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 373}, "so_4863324_4863373_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 371}}, "n4659": {"so_4863324_4863373_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 397}, "so_4863324_4863373_1": {"length": 13, "quality": 0.7647058823529411, "section_id": 397}, "so_4863324_4863373_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 395}}}, "4863383": {"Id": "4863383", "PostTypeId": "2", "Body": "<p>You need to be aware of the lifetime of the object. If you pass <code>*new ParamClass</code> to a function, you're giving ownership of the new object to the function. If the function does not destroy it (and it should never do that given a reference), you'll get a memory leak.</p>\n<p>Instead, you should do something like this:</p>\n<pre><code>ParamClass myParamClass(...);\nmyObject.myMethod(myParamClass);\n</code></pre>\n", "LastActivityDate": "2011-02-01T13:51:28.363", "CommentCount": "0", "CreationDate": "2011-02-01T13:51:28.363", "ParentId": "4863324", "Score": "0", "OwnerUserId": "12416"}, "4863373": {"Id": "4863373", "PostTypeId": "2", "Body": "<p>You should try not to use <code>new</code>, to begin with, as using it brings the trouble of memory management.</p>\n<p>For your example, just do the following:</p>\n<pre><code>int main(int, char*[])\n{\n  SomeObject myObject;\n\n  // two phases\n  ParamClass foo(...);\n  myObject.myMethod(foo);\n\n  // one phase\n  myObject.myMethod(ParamClass(...));\n\n  return 0;\n}\n</code></pre>\n<p>I recommend the first method (in two times) because there are subtle gotchas with the second.</p>\n<p><strong>EDIT</strong>: comments are not really appropriate to describe the gotchas I was referring to.</p>\n<p>As <code>@Fred Nurk</code> cited, the standard says a few things about the lifetime of temporaries:</p>\n<p><strong>[class.temporary]</strong></p>\n<blockquote>\n<p id=\"so_4863324_4863373_0\">(3) Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception. The value computations and side effects of destroying a temporary object are associated only with the full-expression, not with any specific subexpression.</p>\n<p id=\"so_4863324_4863373_1\">(5) The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference [note: except in a number of cases...]</p>\n<p id=\"so_4863324_4863373_2\">(5) [such as...] A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</p>\n</blockquote>\n<p>This can lead to two subtle bugs, that most compilers do not catch:</p>\n<pre><code>Type const&amp; bound_bug()\n{\n  Type const&amp; t = Type(); // binds Type() to t, lifetime extended to that of t\n  return t;\n} // t is destroyed, we've returned a reference to an object that does not exist\n\nType const&amp; forwarder(Type const&amp; t) { return t; }\n\nvoid full_expression_bug()\n{\n  T const&amp; screwed = forwarder(T()); // T() lifetime ends with `;`\n  screwed.method(); // we are using a reference to ????\n}\n</code></pre>\n<p>Argyrios patched up Clang at my request so that it detects the first case (and a few more actually that I had not initially thought of). However the second can be very difficult to evaluate if the implementation of <code>forwarder</code> is not inline.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2011-02-01T15:14:37.743", "Score": "13", "CreationDate": "2011-02-01T13:49:50.920", "ParentId": "4863324", "CommentCount": "27", "LastEditDate": "2011-02-01T15:14:37.743", "OwnerUserId": "147192"}, "4863359": {"Id": "4863359", "PostTypeId": "2", "Body": "<p>Try:\n<code>myObject.myMethod(ParamClass(...));</code>\nin C++, unlike Java, you do not always need to say <code>new</code> to create a new object.</p>\n", "LastActivityDate": "2011-02-01T13:48:47.100", "CommentCount": "0", "CreationDate": "2011-02-01T13:48:47.100", "ParentId": "4863324", "Score": "3", "OwnerUserId": "545127"}, "18404556": {"Id": "18404556", "PostTypeId": "2", "Body": "<p>Just note that there is big difference between assigning the value of an object (I mean the object of the user defined class) previously created to new object  in java and c++\n , and it is about :</p>\n<p><strong>1- in C++</strong> : object new =(object) older [ create a copy of the object older to newer and when you   modify newer ,the older <strong><em>will not</em></strong> change !]</p>\n<p><strong>2- in java</strong> :  object new =(object) older [create a reference to the older object and when you modify the newer , the older also <strong><em>will</em></strong> change (very very important)]</p>\n<p><strong>conclusion :</strong> </p>\n<p>in java : \"object new =(object) older\" is the same as \"object &amp;new =(object) older\" in c++.</p>\n", "LastActivityDate": "2013-08-23T13:50:40.897", "CommentCount": "0", "CreationDate": "2013-08-23T13:50:40.897", "ParentId": "4863324", "Score": "0", "OwnerUserId": "2580505"}, "4863324": {"ViewCount": "18294", "Body": "<p>I am just learning C++, and I've come across the following conundrum:</p>\n<p>As a C++ newbie, I've read that using reference instead of pointers (when possible) is generally a good idea, so I'm trying to get into the habit early. As a result, I have a lot of methods which have the general form of</p>\n<pre><code>void myMethod(ParamClass const&amp; param);\n</code></pre>\n<p>Now, I'm wondering what is the best way to call these methods. Of course, each call will need a different object passed as a parameter, and as far as I know the only way to create it is the new operator, so now I'm doing the following:</p>\n<pre><code>myObject.myMethod(*new ParamClass(...));\n</code></pre>\n<p>While this method totally works, I'm wondering if there isn't another already-established \"c++ way\" of doing this. </p>\n<p>Thanks for the help!\nDan</p>\n", "AcceptedAnswerId": "4863373", "Title": "Create reference to new object", "CreationDate": "2011-02-01T13:46:10.037", "Id": "4863324", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-08-23T13:50:40.897", "Score": "11", "OwnerUserId": "598465", "Tags": "<c++><parameter-passing><reference-type>", "AnswerCount": "6"}, "4863411": {"Id": "4863411", "PostTypeId": "2", "Body": "<p>When you write </p>\n<pre><code>myObject.myMethod(*new ParamClass(...)); \n</code></pre>\n<p>you lose the pointer to the new'd object. That is, this will work, but you won't be able to later <code>delete</code> the object. So you can do this:</p>\n<pre><code>ParamClass pc(...);\nmyObject.myMethod(pc);\n</code></pre>\n<p>or, easier</p>\n<pre><code>myObject.myMethod(ParamClass(...));\n</code></pre>\n<p>or, if dynamic allocation is necessary for some inexplicable reason</p>\n<pre><code>ParamClass* pPc = new ParamClass(...);\nmyObject.myMethod(*pPc);\n...\ndelete pPc;\n</code></pre>\n<p>or, use smart pointers to avoid manual deletion. Something like:</p>\n<pre><code>boost::scoped_ptr&lt;ParamClass&gt; spPc(new ParamClass(...));\nmyObject.myMethod(*pPc);\n</code></pre>\n<p>Hope this helps</p>\n", "LastEditorUserId": "469935", "LastActivityDate": "2011-02-01T14:00:23.143", "Score": "0", "CreationDate": "2011-02-01T13:54:56.923", "ParentId": "4863324", "CommentCount": "0", "LastEditDate": "2011-02-01T14:00:23.143", "OwnerUserId": "469935"}});