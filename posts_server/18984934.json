post_cb({"18985066": {"Id": "18985066", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18984934_18985066_0\">Storage: how much space does it take, ignoring alignment?</p>\n</blockquote>\n<p>Implementation defined, but in practice one byte. It can't usually be smaller, since that's the smallest possible object size. Exceptions are:</p>\n<ul>\n<li>bitfield class members can be a single bit;</li>\n<li><code>std::vector&lt;bool&gt;</code> packs values so that each takes a single bit; but doesn't really hold objects of type <code>bool</code>. Other types (like <code>std::bitset</code>) do similar things, but don't pretend to be storing <code>bool</code>.</li>\n</ul>\n<blockquote>\n<p id=\"so_18984934_18985066_1\">Is there any requirement for the value that will be stored to represent <code>true</code> and <code>false</code>?</p>\n</blockquote>\n<p>No; just the requirement that, when converted to a numeric type, <code>true</code> becomes 1 and <code>false</code> becomes 0. In practice that means that an implementation is likely to use those values; although, on some platforms, other representations might work better.</p>\n<blockquote>\n<p id=\"so_18984934_18985066_2\">Values taken: Let <code>b</code> be an object of type <code>bool</code>, does the assertion <code>(b == true) || (b == false)</code> hold?</p>\n</blockquote>\n<p>The assertion will hold if <code>b</code> has been initialised or assigned with a valid value. If it's uninitialised, then it may not hold; but you have undefined behaviour anyway, if you use an uninitialised value. In fact, the standard contains a specific footnote (referenced by C++11 3.9.1/6) warning about this:</p>\n<blockquote>\n<p id=\"so_18984934_18985066_3\">47) Using a bool value in ways described by this International Standard as \u201cundefined,\u201d such as by examining the value of an uninitialized automatic object, might cause it to behave as if it is neither true nor false.</p>\n</blockquote>\n<p>UPDATE: the question keeps on growing:</p>\n<blockquote>\n<p id=\"so_18984934_18985066_4\">Is <code>(false &lt; true)</code> well-formed, and does it hold?</p>\n</blockquote>\n<p>Yes, and yes. The operands are promoted to <code>int</code>, giving <code>0 &lt; 1</code>, which is true.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-09-24T15:13:21.573", "Score": "24", "CreationDate": "2013-09-24T14:55:57.043", "ParentId": "18984934", "CommentCount": "1", "OwnerUserId": "204847", "LastEditDate": "2013-09-24T15:13:21.573"}, "18985085": {"Id": "18985085", "PostTypeId": "2", "Body": "<p>With respect to the size of <code>bool</code> if we look at section <code>5.3.3</code> <em>Sizeof</em> from the draft C++ standard it says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_18984934_18985085_0\">[...]sizeof(char), sizeof(signed char) and sizeof(unsigned char) are 1. The result of sizeof applied to any other fundamental type (3.9.1) is implementation-defined. [ Note: in particular, <strong>sizeof(bool), sizeof(char16_t), sizeof(char32_t), and sizeof(wchar_t) are implementation-defined</strong>.<sup>74</sup> \u2014end note ] [...]</p>\n</blockquote>\n<p>and with respect to the values of <code>bool</code> if we look at section <code>3.9.1</code> <em>Fundamental types</em> paragraph <em>6</em> says:</p>\n<blockquote>\n<p id=\"so_18984934_18985085_1\">Values of type bool are either true or false.<sup>47</sup></p>\n</blockquote>\n<p>You also asked:</p>\n<blockquote>\n<p id=\"so_18984934_18985085_2\">Values taken: Let b be an object of type bool, does the assertion (b == true) || (b == false) hold? Is (false &lt; true) well-formed, and does it hold?</p>\n</blockquote>\n<p>section <code>4.5</code> <em>Integral promotions</em> says in paragraph <em>6</em>:</p>\n<blockquote>\n<p id=\"so_18984934_18985085_3\">A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true becoming one.</p>\n</blockquote>\n<p>Since operands to <code>&lt;</code> are promoted to <code>int</code> then <code>(false &lt; true)</code> holds assuming that <code>b</code> is properly initialized(<em>you are not invoking undefined behavior</em>) then <code>(b == true) || (b == false)</code> also holds.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-09-24T15:18:18.563", "Score": "7", "CreationDate": "2013-09-24T14:56:45.850", "ParentId": "18984934", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-09-24T15:18:18.563"}, "18985021": {"Id": "18985021", "PostTypeId": "2", "Body": "<p>There are two possible values, <code>true</code> and <code>false</code>.</p>\n<p>Anything else you may observe is the result of undefined behavior.</p>\n", "LastActivityDate": "2013-09-24T14:54:15.510", "CommentCount": "0", "CreationDate": "2013-09-24T14:54:15.510", "ParentId": "18984934", "Score": "6", "OwnerUserId": "8922"}, "18984934": {"ViewCount": "2403", "Body": "<p>The question is not so obvious as it seems, and I have trouble finding much information about the <code>bool</code> type in the standard.</p>\n<p>According to the C++11 standard, what are the guarantees associated with the <code>bool</code> type with regards to:</p>\n<ul>\n<li>Storage: how much space does it take, ignoring alignment? Is there any requirement for the value that will be stored to represent <code>true</code>and <code>false</code>?</li>\n<li>Values taken: Let <code>b</code> be of type <code>bool</code>, does the assertion <code>(b == true) || (b == false)</code> hold? Is <code>(false &lt; true)</code> well-formed, and does it hold?</li>\n</ul>\n", "AcceptedAnswerId": "18985007", "Title": "What are all the possible values of a bool value in C++?", "CreationDate": "2013-09-24T14:50:38.237", "Id": "18984934", "CommentCount": "11", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-09-24T17:16:33.423", "LastEditorUserId": "26658", "LastActivityDate": "2013-09-25T12:44:53.367", "Score": "33", "OwnerUserId": "2071258", "Tags": "<c++><c++11>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_18984934_18985066_3": {"length": 19, "quality": 0.9047619047619048, "section_id": 7215}, "so_18984934_18985007_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7215}, "so_18984934_18985085_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 7215}, "so_18984934_18985007_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 7215}, "so_18984934_18985085_3": {"length": 14, "quality": 1.0, "section_id": 26}, "so_18984934_18985085_0": {"length": 16, "quality": 0.6956521739130435, "section_id": 6076}}, "n3337": {"so_18984934_18985066_3": {"length": 19, "quality": 0.9047619047619048, "section_id": 6959}, "so_18984934_18985007_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6959}, "so_18984934_18985085_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6959}, "so_18984934_18985007_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 6959}, "so_18984934_18985085_3": {"length": 14, "quality": 1.0, "section_id": 23}, "so_18984934_18985085_0": {"length": 16, "quality": 0.6956521739130435, "section_id": 5844}}, "n4659": {"so_18984934_18985066_3": {"length": 19, "quality": 0.9047619047619048, "section_id": 8724}, "so_18984934_18985007_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8724}, "so_18984934_18985085_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 8724}, "so_18984934_18985007_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 8724}, "so_18984934_18985085_3": {"length": 14, "quality": 1.0, "section_id": 26}, "so_18984934_18985085_0": {"length": 16, "quality": 0.6956521739130435, "section_id": 7572}}}, "18985042": {"Id": "18985042", "PostTypeId": "2", "Body": "<p>Under normal use cases, all non-zero values of data cast as a bool is interpreted as true, and all zero values of data cast as a bool are false. A bool must be at least 1 byte, as all types in C++ must observe this quality.</p>\n<p>But I have been enlightened here, and everyone above me deserves an upvote. In an undefined behavior scenario (such as uninitialized or malformed data) bool's can be both true and false at the same time. Such strange behavior, but then again what's undefined is always strange. Thanks everyone for the info.</p>\n<p>In the comments: <a href=\"https://stackoverflow.com/questions/4518951/engineered-bool-compares-equal-to-both-true-and-false-why\">this link</a> to a relevant post.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-25T12:44:53.367", "Score": "0", "CreationDate": "2013-09-24T14:55:20.257", "ParentId": "18984934", "CommentCount": "4", "OwnerUserId": "1404233", "LastEditDate": "2017-05-23T11:51:05.997"}, "18985007": {"Id": "18985007", "PostTypeId": "2", "Body": "<p><code>bool</code> types are described in section \u00a73.9.1, Fundamental types. Of relevance here is a sentence from paragraph 6:</p>\n<blockquote>\n<p id=\"so_18984934_18985007_0\">Values of type <code>bool</code> are either <code>true</code> or <code>false</code>.<sup>47</sup></p>\n</blockquote>\n<p>The reference footnote 47 provides some interesting additional information:</p>\n<blockquote>\n<p id=\"so_18984934_18985007_1\"><sup>47</sup>) Using a <code>bool</code> value in ways described by this International Standard as \u201cundefined,\u201d such as by examining the value of an uninitialized automatic object, might cause it to behave as if it is neither <code>true</code> nor <code>false</code>.</p>\n</blockquote>\n<p>This is just a direct consequence of the standard imposing no requirements on programs with undefined behaviour.</p>\n<p>There are no size requirements on <code>bool</code>, other than the implicit \"at least one byte\" that applies to all types as a consequence of the C++ memory model.</p>\n<p>There are also no requirements on the internal representation of <code>bool</code> objects, however, due to the requirements regarding integral conversions (<code>true</code> must convert to <code>1</code> and <code>false</code> to <code>0</code>), implementations may be inclined to pick the same representations for <code>true</code> and <code>1</code>, and for <code>false</code> and <code>0</code>, since that makes such conversions unnecessary.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2013-09-24T15:00:00.937", "Score": "41", "CreationDate": "2013-09-24T14:53:45.140", "ParentId": "18984934", "CommentCount": "33", "OwnerUserId": "46642", "LastEditDate": "2013-09-24T15:00:00.937"}});