post_cb({"bq_ids": {"n4140": {"so_36805521_36805521_1": {"length": 13, "quality": 0.6190476190476191, "section_id": 7245}, "so_36805521_36805521_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7240}}, "n3337": {"so_36805521_36805521_0": {"length": 7, "quality": 0.5833333333333334, "section_id": 6989}, "so_36805521_36805521_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 6989}, "so_36805521_36805521_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6984}}, "n4659": {"so_36805521_36805521_1": {"length": 13, "quality": 0.6190476190476191, "section_id": 8754}, "so_36805521_36805521_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 8749}}}, "36805521": {"ViewCount": "359", "Body": "<p>Can the <code>alignof(char)</code> be anything but 1?</p>\n<p>From the <a href=\"http://en.cppreference.com/w/c/language/object#Alignment\">unofficial cppreference.com wiki</a>:</p>\n<blockquote>\n<p id=\"so_36805521_36805521_0\">The weakest (smallest) alignment is the alignment of the types <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>, and it is usually 1.</p>\n</blockquote>\n<p>The \"usually\" seems to imply that it could be something else.</p>\n<p>The only thing the C standard stipulates regarding the alignment of <code>char</code> is (C11 N1570 6.2.8 paragraph 1):</p>\n<blockquote>\n<p id=\"so_36805521_36805521_1\">The alignment requirement of a complete type can be queried using an <code>_Alignof</code> expression. The types <code>char</code>, <code>signed char</code>, and <code>unsigned char</code>shall have the weakest alignment requirement.</p>\n</blockquote>\n<p>However, consider the definition of alignment (C11 N1570 6.2.8 paragraph 1, and defined similarly for C++11):</p>\n<blockquote>\n<p id=\"so_36805521_36805521_2\">An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated.</p>\n</blockquote>\n<p>From this, I don't think it makes sense for the alignment of <code>char</code> to be anything but <code>1</code> due to the requirement that <code>sizeof(char) \u2261 1</code>, which implies the distance between adjacent <code>char</code> elements can only be <code>1</code> byte.</p>\n<p>Does this make sense?</p>\n", "AcceptedAnswerId": "36806276", "Title": "Is the alignment of char in C (and C++) guaranteed to be 1?", "CreationDate": "2016-04-23T01:19:30.890", "LastActivityDate": "2016-04-23T03:23:30.970", "CommentCount": "10", "LastEditDate": "2016-04-23T03:14:54.767", "PostTypeId": "1", "Tags": "<c++><c><language-lawyer>", "Id": "36805521", "AnswerCount": "2", "Score": "12", "OwnerUserId": "440302", "ClosedDate": "2016-04-23T06:56:55.037", "LastEditorUserId": "440302"}, "36806079": {"Id": "36806079", "PostTypeId": "2", "Body": "<p>I'm not a language lawyer, but if we look at section 6.5.3.4 paragraph 3 of C:</p>\n<blockquote>\n<p id=\"so_36805521_36806079_0\">When applied to an operand that has type char, unsigned char, or signed char,\n  (or a qualified version thereof) the result is 1.</p>\n</blockquote>\n<p>To me, this doesn't seem to be a requirement that the size of <code>char</code> must be one, just the result of the operand <code>sizeof</code> must return 1. Alignment also is not the same thing as size. Alignment is dictated by the ABI, not the C or C++ standards. Of course, it is true that the alignment of <code>char</code> is 1 on x86, x86_64 and so on but it's not a hard requirement.</p>\n", "LastActivityDate": "2016-04-23T02:47:26.827", "CommentCount": "1", "CreationDate": "2016-04-23T02:47:26.827", "ParentId": "36805521", "Score": "1", "OwnerUserId": "6243180"}, "36806276": {"Id": "36806276", "PostTypeId": "2", "Body": "<p><strong>Yes</strong>. Although this statement is not explicitly specified in the standards, I suppose it can inferred from them:</p>\n<p>N1570 <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.5.3.4\">6.5.3.4 The sizeof and _Alignof operators</a></p>\n<blockquote>\n<p id=\"so_36805521_36806276_0\">4 When <code>sizeof</code> is applied to an operand that has <code>type char</code>,\n  <code>unsigned char</code>, or <code>signed char</code>, (or a qualified version thereof)\n  the result is <code>1</code>. When applied to an operand that has array type, the\n  result is the total number of bytes in the array.</p>\n</blockquote>\n<p>Taking <code>char</code> for example. Say we have an <code>char charArr[2];</code>. <code>sizeof charArr</code> is guaranteed to be <code>2</code>, and <code>sizeof charArr[0]</code> = <code>sizeof charArr[1]</code> = <code>1</code>. This means two adjacent <code>char</code> objects take the place of 2 bytes.</p>\n<p>Consequently, it can be inferred that \"the number of bytes between successive addresses at which a char can be allocated\" is at least <code>1</code>. Also, the alignment of <code>char</code> most be a positive integer, so it can't be any number other than <code>1</code>.</p>\n", "LastActivityDate": "2016-04-23T03:23:30.970", "CommentCount": "0", "CreationDate": "2016-04-23T03:23:30.970", "ParentId": "36805521", "Score": "6", "OwnerUserId": "5399734"}});