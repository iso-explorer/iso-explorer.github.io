post_cb({"bq_ids": {"n4140": {"so_44907303_44907759_1": {"length": 69, "quality": 0.9857142857142858, "section_id": 6151}, "so_44907303_44907759_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}}, "n3337": {"so_44907303_44907759_1": {"length": 39, "quality": 0.5571428571428572, "section_id": 5913}, "so_44907303_44907759_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}}, "n4659": {"so_44907303_44907759_1": {"length": 50, "quality": 0.7142857142857143, "section_id": 7648}, "so_44907303_44907759_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7638}, "so_44907303_44907759_3": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}}}, "44907789": {"Id": "44907789", "PostTypeId": "2", "Body": "<p>No, there is absolutely no guarantee about the relational position of memory from different allocations.</p>\n<blockquote>\n<p id=\"so_44907303_44907789_0\">If this is not valid, how it passed the test cases of an online judge?</p>\n</blockquote>\n<p>The easy answer (from me) is to say you got (un)lucky. The truth is that the mechanism of memory allocation/mapping is complex and covers more layers: application (<code>malloc</code>), C library implementation, OS and hardware. It is possible and in some situations even probable that consecutive <code>malloc</code> requests return memory that is somewhat consecutive. This is in by no way a guarantee and can easily break (e.g. after a series of intertwined <code>malloc</code>s and <code>free</code>s).</p>\n<p>Moreover, as @StoryTeller shows, comparing pointers (except equality) to different objects is UB.</p>\n", "LastActivityDate": "2017-07-04T13:51:10.097", "CommentCount": "0", "CreationDate": "2017-07-04T13:51:10.097", "ParentId": "44907303", "Score": "2", "OwnerUserId": "2805305"}, "44907303": {"ViewCount": "120", "Body": "<p>I'm trying to solve a problem. </p>\n<p><strong>Problem definition:</strong>  Given a singly linked list containing n nodes. Modify the value of first half nodes such that 1st node\u2019s new value is equal to the last node\u2019s value minus first node\u2019s current value, 2nd node\u2019s new value is equal to the second last node\u2019s value minus 2nd node\u2019s current value, likewise for first half nodes. If n is odd then the value of the middle node remains unchanged. Note that the half nodes of linked list remain unmodified. </p>\n<p>EG :  6 3 5 4 10</p>\n<p>ans: \n-4 -1 5 4 10</p>\n<p>I wrote a program to keep track of nodes in the second half in reverse order needed for processing using recursion. But, out of carelessness, I compared <strong>both the pointers</strong> to check whether both the pointers have crossed each other to stop processing them. </p>\n<p>I am getting the output, everytime correctly. </p>\n<p><strong>FULL CODE</strong>:</p>\n<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nstruct Node\n{\n    int data;\n    struct Node* next;\n};\nstruct Node* modifyTheList(struct Node *head);\nvoid push(struct Node **head_ref, int new_data)\n{\n  struct Node* new_node =(struct Node*) malloc(sizeof(struct Node));\n  new_node-&gt;data = new_data;\n  new_node-&gt;next = *head_ref;    \n  *head_ref = new_node;\n}\nvoid printList(struct Node *head)\n{\n    if (!head)\n        return;\n    while (head-&gt;next != NULL)\n    {\n        cout &lt;&lt; head-&gt;data &lt;&lt; \" \";\n        head = head-&gt;next;\n    }\n    cout &lt;&lt; head-&gt;data &lt;&lt; endl;\n}\nint main()\n{\n    int t;\n    cin&gt;&gt;t;\n    while(t--){\n        int n;\n        cin&gt;&gt;n;\n        struct Node *head = NULL;\n        while(n--){\n            int a;\n            cin&gt;&gt;a;\n            push(&amp;head, a);\n        }\n        head = modifyTheList(head);\n        printList(head);\n    }\n    return 0;\n}\n\nvoid modify(Node *head ,Node** left)\n{\n    if(head!=NULL)\n    {\n        modify(head-&gt;next,left);\n        if(head &gt;= *left )            //line of concern, comparing pointers\n            return;\n        else\n        {\n            (*left)-&gt;data=(*left)-&gt;data-head-&gt;data;\n            (*left)=(*left)-&gt;next;\n        }\n    }\n}\nstruct Node* modifyTheList(struct Node *head)\n{\n    if(head==NULL || head-&gt;next==NULL )\n        return head;\n    struct Node *temp = head;\n    modify(head,&amp;temp);\n    return head;\n}\n</code></pre>\n<ol>\n<li><p>Can someone tell me is it valid to compare this way? </p></li>\n<li><p>If this is not valid, how it passed the test cases of an online judge?</p></li>\n</ol>\n", "AcceptedAnswerId": "44907759", "Title": "Are Structs in C++ allocated memory sequentially? Somehow getting correct answer for pointer comparison everytime", "CreationDate": "2017-07-04T13:27:05.003", "Id": "44907303", "CommentCount": "9", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-07-04T13:32:51.143", "LastEditorUserId": "6609678", "LastActivityDate": "2017-07-04T13:56:21.827", "Score": "2", "OwnerUserId": "6609678", "Tags": "<c++><pointers><recursion><linked-list>", "AnswerCount": "2"}, "44907759": {"Id": "44907759", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44907303_44907759_0\">Can someone tell me is it valid to compare this way?</p>\n</blockquote>\n<p>You can't directly compare pointers unless they point to subobjects of the same array, or members of the same object. Formally, objects that are not part of the same array are considered part of <em>separate</em> 1-element arrays. There is no defined result for comparing their pointers. To quote N4296:</p>\n<p><strong>\u00a75.9 Relational operators [expr.rel] \u05b0\u05b0\u00b63</strong></p>\n<blockquote>\n<p id=\"so_44907303_44907759_1\">Comparing pointers to objects<sup>86</sup> is defined as follows:<br>\n  (3.1) \u2014 If two pointers point to different elements of the same array, or to\n  subobjects thereof, the pointer to the element with the higher\n  subscript compares greater.<br>\n  (3.2) \u2014 If one pointer points to an\n  element of an array, or to a subobject thereof, and another pointer\n  points one past the last element of the array, the latter pointer\n  compares greater.<br>\n  (3.3) \u2014 If two pointers point to different\n  non-static data members of the same object, or to subobjects of such\n  members, recursively, the pointer to the later declared member\n  compares greater provided the two members have the same access control\n  (Clause 11) and provided their class is not a union.  </br></br></br></p>\n<hr>\n<p id=\"so_44907303_44907759_2\">86) An object that is not an array element is considered to belong to a single-element array for this purpose; see 5.3.1.</p>\n</hr></blockquote>\n<p>So you can't compare directly, and your program is officially with undefined behavior. However, such comparison can be useful, which is why the standard gives you another way:</p>\n<p><strong>\u00a720.9.6 Comparisons [comparisons] \u05b0\u05b0\u00b614</strong></p>\n<blockquote>\n<p id=\"so_44907303_44907759_3\">For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type\n  yield a total order, even if the built-in operators &lt;, &gt;, &lt;=, &gt;= do not.</p>\n</blockquote>\n<p>So your code can be made well defined, by simply replacing <code>head &gt;= *left</code> with a call to <code>std::greater_equal&lt;Node*&gt;(head, *left)</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_44907303_44907759_4\">If this is not valid, how it passed the test cases of an online judge?</p>\n</blockquote>\n<p>Undefined behavior means any outcome is allowed by the language specification. \"Working\" is a possible outcome. You just can't rely on it to <em>always</em> be the outcome. </p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2017-07-04T13:56:21.827", "Score": "2", "CreationDate": "2017-07-04T13:49:55.287", "ParentId": "44907303", "CommentCount": "2", "OwnerUserId": "817643", "LastEditDate": "2017-07-04T13:56:21.827"}});