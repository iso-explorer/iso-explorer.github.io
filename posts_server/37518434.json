post_cb({"bq_ids": {"n4140": {"so_37518434_37518676_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 382}, "so_37518434_37518676_0": {"length": 15, "quality": 0.9375, "section_id": 5947}}, "n3337": {"so_37518434_37518676_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 373}, "so_37518434_37518676_0": {"length": 15, "quality": 0.9375, "section_id": 5717}}, "n4659": {"so_37518434_37518676_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 397}, "so_37518434_37518676_0": {"length": 15, "quality": 0.9375, "section_id": 7433}}}, "37518676": {"Id": "37518676", "PostTypeId": "2", "Body": "<p>Numeric literals can't be bound to any reference, neither an rvalue reference nor an lvalue reference. Conceptually, a numeric literal creates a temporary object initialized from the literal value and this temporary can be bound to an rvalue references or to <code>const</code> lvalue reference (<code>int const&amp; r = 17;</code>). It seems the relevant quote on literals is 5.1.1 [expr.prim.general] paragraph 1:</p>\n<blockquote>\n<p id=\"so_37518434_37518676_0\">A literal is a primary expression. Its type depends on its form (2.14). A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p>When binding a reference directly to a temporary, it's life-time gets extended until the reference goes out of scope. The relevant section for the life time issue is 12.2 [class.temporary] paragraph 5:</p>\n<blockquote>\n<p id=\"so_37518434_37518676_1\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference except:</p>\n<ul>\n<li>A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits.</li>\n<li>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</li>\n<li>The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not extended; the temporary is destroyed at the end of the full-expression in the return statement.</li>\n<li>A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the full-expression containing the new-initializer.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2016-05-30T06:26:50.917", "Score": "12", "CreationDate": "2016-05-30T06:08:29.830", "ParentId": "37518434", "CommentCount": "5", "OwnerUserId": "1120273", "LastEditDate": "2016-05-30T06:26:50.917"}, "37518434": {"ViewCount": "299", "Body": "<p>Since c++ provides references to rvalues i.e. rvalue references which are mainly used to perform move semantics and other memory efficient tasks. But in the following case reference is changing the value of an literal but as we know that literals are read only so how could a reference change the value of some read only variable. Does a rvalue reference allocate it's own memory or it simply changes the value of literal?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int a = 5;\n    int&amp;&amp; b = 3;\n    int&amp; c = a;\n    b++;\n    c++;\n    cout &lt;&lt; \" Value for b \" &lt;&lt; b &lt;&lt; \" Value for c \" &lt;&lt; c &lt;&lt; endl;\n}\n</code></pre>\n<p>Secondly, when a temporary object is assigned with a reference, reference works with the data of that object. But according to the definition of temporary objects they are deleted as when the expression using them ends. How could the reference act as an alias name to that temporary object if that temporary object is out of memory?</p>\n", "AcceptedAnswerId": "37518676", "Title": "C++: rvalue reference memory", "CreationDate": "2016-05-30T05:50:15.737", "Id": "37518434", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-05-30T06:26:50.917", "Score": "6", "OwnerUserId": "6397369", "Tags": "<c++><c++11>", "AnswerCount": "1"}});