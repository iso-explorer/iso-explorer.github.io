post_cb({"bq_ids": {"n4140": {"so_46044682_46044783_1": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}, "so_46044682_46044783_2": {"section_id": 7239, "quality": 0.9, "length": 9}}, "n3337": {"so_46044682_46044783_1": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}, "so_46044682_46044783_2": {"section_id": 6983, "quality": 0.9, "length": 9}}, "n4659": {"so_46044682_46044783_1": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}, "so_46044682_46044783_2": {"section_id": 8748, "quality": 0.9, "length": 9}}}, "46044710": {"ParentId": "46044682", "CommentCount": "6", "Body": "<pre><code>$ cat omg.cpp &amp;&amp; g++ omg.cpp &amp;&amp; echo ========== &amp;&amp; ./a.out\n#include &lt;iostream&gt;\n\nstruct numpair {\n    unsigned short a,b;\n};\n\nstruct bignum {\n    unsigned long a;\n};\n\nint main() {\n    std::cout &lt;&lt; sizeof(numpair) &lt;&lt; \" != \" &lt;&lt; sizeof(bignum) &lt;&lt; std::endl;\n}\n==========\n4 != 8\n</code></pre>\n<p>Why do you think the types are the same?</p>\n", "OwnerUserId": "2749717", "PostTypeId": "2", "Id": "46044710", "Score": "2", "CreationDate": "2017-09-04T22:29:36.437", "LastActivityDate": "2017-09-04T22:29:36.437"}, "46044783": {"ParentId": "46044682", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>struct A\n{\n    int x;\n};\n\nstruct B\n{\n    int x;\n};\n</code></pre>\n<p>You can't even reinterpret cast between these two types. It would violate the strict aliasing rule. So no, you cannot do what you want.</p>\n<blockquote>\n<p id=\"so_46044682_46044783_0\">\u00a73.10 Lvalues and rvalues [basic.lval]</p>\n<p id=\"so_46044682_46044783_1\">10 If a program attempts to access the stored value of an object\n  through a glvalue of other than one of the following types the\n  behavior is undefined:<sup>54</sup></p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including,\n  recursively, an element or non-static data member of a subaggregate or\n  contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object, \u2014 a char or unsigned char type.</li>\n</ul>\n<p id=\"so_46044682_46044783_2\">54) The intent of this list is to specify those circumstances in which\n  an object may or may not be aliased.</p>\n</blockquote>\n", "OwnerUserId": "2805305", "LastEditorUserId": "2805305", "LastEditDate": "2017-09-04T22:55:01.030", "Id": "46044783", "Score": "3", "CreationDate": "2017-09-04T22:41:10.800", "LastActivityDate": "2017-09-04T22:55:01.030"}, "46044682": {"CommentCount": "8", "ViewCount": "90", "PostTypeId": "1", "LastEditorUserId": "6410634", "CreationDate": "2017-09-04T22:25:24.223", "LastActivityDate": "2017-09-04T22:55:01.030", "Title": "reinterpret_cast-ing vector of one type to a vector of another type which is of the same type", "LastEditDate": "2017-09-04T22:49:03.247", "Id": "46044682", "Score": "-2", "Body": "<p>I'm not sure if the question <a href=\"https://stackoverflow.com/questions/30841015/reinterpret-cast-vector-of-class-a-to-vector-of-class-b\">here</a> answers this question due to the weird wording, but:</p>\n<p>if i have:</p>\n<pre><code>struct numpair\n{\n    some_type_with_a_size_of_2 a,b;\n};\n\nstruct bignum\n{\n    some_type_with_a_size_of_4 a;\n};\n</code></pre>\n<p>Can I reinterpret_cast a vector of bignums to a vector of numpairs? If not, are there other workarounds that don't require me to make a new vector and go through reinterpret casting each element?</p>\n<p>edit: on visual studio 2017 windows, which i am using, these two types are the same size.</p>\n<p>edit: I have now learned if this strict aliasing rule. This is supposed to be binary data, viewed with different interfaces. Putting aside reinterpret_cast, could I possibly use a union of vectors of these types?</p>\n", "Tags": "<c++><vector><reinterpret-cast>", "OwnerUserId": "6410634", "AnswerCount": "2"}});