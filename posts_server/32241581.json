post_cb({"32241581": {"CommentCount": "5", "ViewCount": "241", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2015-08-27T05:49:43.523", "LastActivityDate": "2016-07-05T21:51:53.133", "Title": "C++ preprocessors are not aware of template arguments?", "AcceptedAnswerId": "32262498", "LastEditDate": "2016-07-05T21:51:53.133", "Id": "32241581", "Score": "5", "Body": "<p>As it appears, C++ preprocessor fails if a template instantiation with multiple arguments passed to a macro as an argument. </p>\n<p>See an example below.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n#define FOO(v) printf(\"%d\\n\",v::val())\n\ntemplate&lt;int N&gt;\nstruct bar {\n    static int val() { return N; }\n};\ntemplate&lt;int N, int M&gt;\nstruct baz {\n    static int val() { return N+M; }\n};\n\nint main() {\n    printf(\"%d\\n\",bar&lt;1&gt;::val());\n    printf(\"%d\\n\",baz&lt;1,2&gt;::val());\n    FOO(bar&lt;10&gt;);       // OK\n    FOO(baz&lt;20,30&gt;);    // error: too many arguments provided to function-like macro invocation\n    FOO((baz&lt;20,30&gt;));  // error: '::val' has not been declared\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f9a9d86edd833207\" rel=\"nofollow\">Tested</a> with clang++ and g++</p>\n<p>Should it be considered as a bug?</p>\n", "Tags": "<c++><templates><parameters><arguments><c-preprocessor>", "OwnerUserId": "1315118", "AnswerCount": "3"}, "32245164": {"ParentId": "32241581", "CommentCount": "0", "Body": "<p>The macro's argument is treated as plain text string and the arguments are separated using commas. Hence the comma in the template will be treated as a delimiter. Thus the preprocessor will think that you have passed on two arguments to a single argument macro, hence the error. </p>\n", "OwnerUserId": "1818208", "PostTypeId": "2", "Id": "32245164", "Score": "1", "CreationDate": "2015-08-27T09:10:58.483", "LastActivityDate": "2015-08-27T09:10:58.483"}, "32262498": {"ParentId": "32241581", "CommentCount": "0", "Body": "<p>The C/C++ preprocessor recognizes commas as macro argument separators unless they are nested inside parentheses. Just parentheses. Brackets, braces and template markers don't count:</p>\n<blockquote>\n<p id=\"so_32241581_32262498_0\">The individual arguments within the list are separated by comma preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate arguments. (C++14 \u00a716.3/11; C11 \u00a76.10.3/11)</p>\n</blockquote>\n<p>(A side effect of the above is that you can use unbalanced braces and brackets as macro arguments. That's usually not a very good idea, but you can do it if you have to.)</p>\n<p>Problems occasionally crop up as a result; a common one is unwanted multiple arguments when the argument is supposed to be a block of code:</p>\n<pre><code>MY_FANCY_MACRO(1000, { int i=0, j=42; ... })\n</code></pre>\n<p>Here, the macro is called with (at least) 3 arguments, although it was probably written to accept 2.</p>\n<p>With modern C++ (and C) compilers, you have a few options. In a fairly subjective order:</p>\n<ol>\n<li><p>Rewrite the macro as an inline function. If the argument is a code block, consider using a templated function which could accept a lambda or other functor. If the argument is a type, make it a template argument instead.</p></li>\n<li><p>If surrounding the argument with redundant parentheses is syntactically valid, do that. But in such a case it is almost certainly the case that suggestion (1) above would have worked.</p></li>\n<li><p>Define:</p>\n<pre><code>#define COMMA ,\n</code></pre>\n<p>and use it where necessary:</p>\n<pre><code> FOO(baz&lt;20 COMMA 30&gt;);\n</code></pre>\n<p>This doesn't require modifying the macro definition in any way, but it will fail if the macro passes the argument to another macro. (The replacement will be done before the inner macro call is parsed, so the multiple argument problem will just be deferred to the inner call.)</p></li>\n<li><p>If you expect that one macro argument might contain unprotected commas, and it is the last or only argument, and you're in a position to modify the macro, and you're using C++11/C99 or better (or gcc, which has allowed this as an extension for some time), make the macro variadic:</p>\n<pre><code>#define FOO(...) printf(\"%d\\n\",__VA_ARGS__::val())\n</code></pre></li>\n</ol>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "32262498", "Score": "2", "CreationDate": "2015-08-28T02:36:04.457", "LastActivityDate": "2015-08-28T02:36:04.457"}, "32241916": {"ParentId": "32241581", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, it's not a bug.</p>\n<p>The c preprocessor is a different beast from the rest of the language and it plays by its own rules. Changing this would break compatibility in a massive way, CPP is highly rigorously standardized.</p>\n<p>The usual way to work around these comma issues is, </p>\n<pre><code>typedef baz&lt;20,30&gt; baz2030_type;\nFOO(baz2030_type);\n</code></pre>\n", "OwnerUserId": "3598119", "LastEditorUserId": "3598119", "LastEditDate": "2015-08-27T08:28:13.683", "Id": "32241916", "Score": "11", "CreationDate": "2015-08-27T06:13:57.407", "LastActivityDate": "2015-08-27T08:28:13.683"}, "bq_ids": {"n4140": {"so_32241581_32262498_0": {"section_id": 521, "quality": 0.782608695652174, "length": 18}}, "n3337": {"so_32241581_32262498_0": {"section_id": 512, "quality": 0.782608695652174, "length": 18}}, "n4659": {"so_32241581_32262498_0": {"section_id": 542, "quality": 0.782608695652174, "length": 18}}}});