post_cb({"29432462": {"ParentId": "29432283", "CommentCount": "1", "CreationDate": "2015-04-03T12:46:44.913", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "29432462", "Score": "12", "Body": "<p>Unfortunately, you simply cannot do this!</p>\n<p>Some <code>static constexpr</code> members may be initialised inline:</p>\n<blockquote>\n<p id=\"so_29432283_29432462_0\"><code>[C++11 9.4.2/3]:</code> <em>[..]</em> A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. <em>[..]</em></p>\n</blockquote>\n<p><code>Cursor</code> is a literal type, so this counts.</p>\n<p>And the use of <code>Cursor</code> itself as a <code>static</code> data member within its own type is not a problem, as long as you initialise it at lexical namespace scope:</p>\n<blockquote>\n<p id=\"so_29432283_29432462_1\"><code>[C++11: 9.4.2/2]:</code> <strong>The declaration of a <code>static</code> data member in its class definition is not a definition and may be of an incomplete type</strong> other than cv-qualified void. <strong>The definition for a <code>static</code> data member shall appear in a namespace scope enclosing the member\u2019s class definition.</strong> In the definition at namespace scope, the name of the <code>static</code> data member shall be qualified by its class name using the <code>::</code> operator. <strong>The <em>initializer</em> expression in the definition of a <code>static</code> data member is in the scope of its class</strong> (3.3.7).</p>\n</blockquote>\n<p>But you can't do that with <code>constexpr</code>:</p>\n<blockquote>\n<p id=\"so_29432283_29432462_2\"><code>[C++11: 7.1.5/9]:</code> A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have literal type and shall be initialized. <em>[..]</em></p>\n</blockquote>\n<p>I think all of this wording could be improved but, in the meantime, I think you're going to have to make <code>ZERO</code> a non-member in the enclosing namespace.</p>\n", "LastActivityDate": "2015-04-03T12:46:44.913"}, "29441042": {"ParentId": "29432283", "CommentCount": "0", "CreationDate": "2015-04-03T23:27:29.897", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "29441042", "Score": "5", "Body": "<blockquote>\n<p id=\"so_29432283_29441042_0\">is there any way I can have ZERO belonging to Cursor and still being <code>constexpr</code>?</p>\n</blockquote>\n<p>Yes, if you count nested subclasses as \"belonging to\" the containing class:</p>\n<pre><code>struct Cursor\n{\n    size_t row,column;\n\n    struct Constants;\n};\n\nstruct Cursor::Constants\n{\n    static constexpr Cursor ZERO {0,0};\n};\n</code></pre>\n", "LastActivityDate": "2015-04-03T23:27:29.897"}, "41570881": {"ParentId": "29432283", "CommentCount": "0", "CreationDate": "2017-01-10T14:12:19.163", "OwnerUserId": "2042388", "PostTypeId": "2", "Id": "41570881", "Score": "3", "Body": "<p>You can if you accept to have a function, not a variable</p>\n<pre><code>struct Cursor\n{\n    size_t row,column;\n\n    static constexpr Cursor ZERO() { return Cursor{0,0}; }\n};\n</code></pre>\n", "LastActivityDate": "2017-01-10T14:12:19.163"}, "bq_ids": {"n4140": {"so_29432283_29432462_1": {"section_id": 5907, "quality": 0.8888888888888888, "length": 48}, "so_29432283_29432462_2": {"section_id": 5425, "quality": 0.8666666666666667, "length": 13}, "so_29432283_29432462_0": {"section_id": 5908, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_29432283_29432462_1": {"section_id": 5679, "quality": 0.8888888888888888, "length": 48}, "so_29432283_29432462_2": {"section_id": 5220, "quality": 0.8666666666666667, "length": 13}, "so_29432283_29432462_0": {"section_id": 5680, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_29432283_29432462_1": {"section_id": 7389, "quality": 0.8518518518518519, "length": 46}, "so_29432283_29432462_0": {"section_id": 7390, "quality": 0.5909090909090909, "length": 13}, "so_29432283_29432462_2": {"section_id": 6847, "quality": 0.8666666666666667, "length": 13}}}, "29432283": {"CommentCount": "11", "AcceptedAnswerId": "29432462", "PostTypeId": "1", "LastEditorUserId": "2339551", "CreationDate": "2015-04-03T12:33:58.887", "LastActivityDate": "2017-01-10T14:12:19.163", "LastEditDate": "2015-04-03T14:01:11.017", "ViewCount": "946", "FavoriteCount": "2", "Title": "C++ static constexpr field with incomplete type", "Id": "29432283", "Score": "18", "Body": "<p>I'm trying to compile this code, but g++ complains about <code>ZERO</code> having an incomplete type. Does this mean that in C++ a struct cannot contain a <code>static constexpr</code> instance of itself? If so, why?</p>\n<pre><code>struct Cursor\n{\n    size_t row,column;\n\n    static constexpr Cursor ZERO {0,0};\n    //error: constexpr const Cursor Cursor::ZERO has incomplete type\n};\n</code></pre>\n<p>EDIT: I understand that <code>Cursor</code> cannot have a complete type when I declare <code>ZERO</code>. What I'd like to know is: is there any way I can have <code>ZERO</code> belonging to <code>Cursor</code> and still being <code>constexpr</code>?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2339551", "AnswerCount": "3"}});