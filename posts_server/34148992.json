post_cb({"bq_ids": {"n4140": {"so_34148992_34151014_9": {"length": 4, "quality": 0.6666666666666666, "section_id": 6173}, "so_34148992_34153294_6": {"length": 14, "quality": 0.6666666666666666, "section_id": 6149}, "so_34148992_34153294_7": {"length": 16, "quality": 1.0, "section_id": 6153}, "so_34148992_34153294_0": {"length": 9, "quality": 0.9, "section_id": 7212}, "so_34148992_34153294_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 6173}, "so_34148992_34151014_0": {"length": 9, "quality": 0.9, "section_id": 7212}}, "n3337": {"so_34148992_34151014_9": {"length": 4, "quality": 0.6666666666666666, "section_id": 5934}, "so_34148992_34153294_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 5934}, "so_34148992_34153294_7": {"length": 16, "quality": 1.0, "section_id": 5916}, "so_34148992_34153294_6": {"length": 14, "quality": 0.6666666666666666, "section_id": 5912}}, "n4659": {"so_34148992_34151014_9": {"length": 4, "quality": 0.6666666666666666, "section_id": 7675}, "so_34148992_34153294_3": {"length": 4, "quality": 0.8, "section_id": 7709}, "so_34148992_34153294_7": {"length": 16, "quality": 1.0, "section_id": 7650}, "so_34148992_34153294_6": {"length": 14, "quality": 0.6666666666666666, "section_id": 7646}, "so_34148992_34153294_0": {"length": 9, "quality": 0.9, "section_id": 8721}, "so_34148992_34153294_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 7675}, "so_34148992_34151014_0": {"length": 9, "quality": 0.9, "section_id": 8721}}}, "34148992": {"ViewCount": "311", "Body": "<p>Consider the following code on a one's complement architecture:</p>\n<pre><code>int zero = 0;\nint negzero = -0;\nstd::cout&lt;&lt;(negzero &lt; zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(negzero &lt;= zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(negzero == zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(~negzero)&lt;&lt;(~zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(1 &lt;&lt; negzero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(1 &gt;&gt; negzero)&lt;&lt;std::endl;\n</code></pre>\n<ul>\n<li>What output would the code produce?</li>\n<li>What lines are defined by the standard, what lines are implementation dependent, and what lines are undefined behaviour?</li>\n</ul>\n", "AcceptedAnswerId": "34151014", "Title": "Behaviour of negative zero on a one's complement architecture?", "CreationDate": "2015-12-08T05:57:08.157", "Id": "34148992", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-12-08T11:38:40.620", "Score": "9", "OwnerUserId": "882932", "Tags": "<c++><c++11><integer><standards><ones-complement>", "AnswerCount": "3"}, "34151014": {"Id": "34151014", "PostTypeId": "2", "Body": "<p>Based on my interpretation of the standard:</p>\n<p>The C++ standard in <em>\u00a73.9.1/p3 Fundamental types [basic.fundamental]</em> actually throws the ball in the C standard:</p>\n<blockquote>\n<p id=\"so_34148992_34151014_0\">The signed and unsigned integer types shall satisfy the constraints\n  given in the C standard, section 5.2.4.2.1.</p>\n</blockquote>\n<p>Now if we go to ISO/IEC 9899:2011 section 5.2.4.2.1 it gives as a forward reference to <em>\u00a76.2.6.2/p2 Integer types</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_34148992_34151014_1\">If the sign bit is zero, it shall not affect the resulting value. If\n  the sign bit is one, the value shall be modified in one of the\n  following ways:</p>\n<ul>\n<li><p id=\"so_34148992_34151014_2\">the corresponding value with sign bit 0 is negated (sign and\n  magnitude);</p></li>\n<li><p id=\"so_34148992_34151014_3\">the sign bit has the value \u2212(2^M) (two\u2019s complement);</p></li>\n<li><p id=\"so_34148992_34151014_4\">the sign bit has the value \u2212(2^M \u2212 1) (ones\u2019 complement).</p></li>\n</ul>\n<p id=\"so_34148992_34151014_5\"><strong>Which of these applies is implementation-defined</strong>, as is whether the value with sign bit 1 and all value bits zero (for the first two),\n  or with sign bit and all value bits 1 (for ones\u2019 complement), is a\n  trap representation or a normal value. <strong>In the case of sign and\n  magnitude and ones\u2019 complement, if this representation is a normal\n  value it is called a negative zero.</strong></p>\n</blockquote>\n<p><strong>Consequently, the existence of negative zero is implementation defined.</strong></p>\n<p>If we proceed further in paragraph 3:</p>\n<blockquote>\n<p id=\"so_34148992_34151014_6\">If the implementation supports negative zeros, they shall be generated\n  only by:</p>\n<ul>\n<li><p id=\"so_34148992_34151014_7\">the &amp;, |, ^, ~, &lt;&lt;, and &gt;&gt; operators with operands that produce such\n  a value;</p></li>\n<li><p id=\"so_34148992_34151014_8\">the +, -, *, /, and % operators where one operand is a negative zero\n  and the  result is zero;</p></li>\n<li><p id=\"so_34148992_34151014_9\">compound assignment operators based on the above cases.</p></li>\n</ul>\n<p id=\"so_34148992_34151014_10\"><strong>It is unspecified whether these cases actually generate a negative\n  zero or a normal zero, and whether a negative zero becomes a normal\n  zero when stored in an object.</strong></p>\n</blockquote>\n<p><strong>Consequently, it is unspecified whether the related cases that you displayed are going to generate a negative zero at all.</strong></p>\n<p>Now proceeding in paragraph 4:</p>\n<blockquote>\n<p id=\"so_34148992_34151014_11\">If the implementation does not support negative zeros, the behavior of\n  the &amp;, |, ^, ~, &lt;&lt;, and &gt;&gt; operators with operands that would produce\n  such a value is undefined.</p>\n</blockquote>\n<p><strong>Consequently, whether the related operations result in undefined behaviour, depends on whether the implementation supports negative zeros.</strong></p>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2015-12-08T11:38:40.620", "Score": "3", "CreationDate": "2015-12-08T08:18:29.260", "ParentId": "34148992", "CommentCount": "13", "OwnerUserId": "2352671", "LastEditDate": "2015-12-08T11:38:40.620"}, "34150232": {"Id": "34150232", "PostTypeId": "2", "Body": "<p>First of all one's complement architectures (or even distinguish negative zero) are rather rare, and there's a reason for that. It's basically easier to (hardware-wise) add two's complement than one's complement.</p>\n<p>The code you've posted doesn't seem to have undefined behavior or even implementation defined behavior, it should probably not result in negative zero (or it shouldn't be distinguished from normal zero). </p>\n<p>Negative zeros should not be that easy to produce (and if you manage to do that it's implementation defined behavior at best). If it's a ones-complement architecture they would be produced by <code>~0</code> (bit-wise inversion) rather than <code>-0</code>.</p>\n<p>The C++ standard is rather vague about the actual representation and requirements on the behavior of basic types (which means that the specification only deals with the actual meaning of the number). What this means is that you basically are out of luck in relating internal representation of the number and it's actual value. So even if you did this right and used <code>~0</code> (or whatever way is proper for the implementation) the standard still doesn't seem to bother with the representation as the value of negative zero is still zero.</p>\n<pre><code>#define zero (0)\n#define negzero (~0)\nstd::cout&lt;&lt;(negzero &lt; zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(negzero &lt;= zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(negzero == zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(~negzero)&lt;&lt;(~zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(1 &lt;&lt; negzero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(1 &gt;&gt; negzero)&lt;&lt;std::endl;\n</code></pre>\n<p>the three first lines should produce the same output as if <code>negzero</code> was defined the same as <code>zero</code>. The third line should output two zeros (as the standard requires that <code>0</code> to be rendered as <code>0</code> without sign-sign). The two last should output ones.</p>\n<p>There are some <strong>hints</strong> (on how to produce negative zeros) that can be found in the C standard which actually mentions negative zero, but I don't think there's any mentions about they should compare less than normal zero. The C-standard suggests that negative zero might not survive storage in object (that's why I avoided that in the above example).</p>\n<p>The way C and C++ are related it's reasonable to think that a negative zero would be produced in the same way in C++ as in C, and the standard seem to allow for that. While the C++ standard allows for other ways (via undefined behavior), but no other seem to be available via defined behavior. So it's rather certain that if a C++ implementation is to be able to produce negative zeros in an reasonable way it would be the same as for a similar C implementation. </p>\n", "LastEditorUserId": "4498329", "LastActivityDate": "2015-12-08T09:20:46.773", "Score": "-2", "CreationDate": "2015-12-08T07:26:04.223", "ParentId": "34148992", "CommentCount": "24", "OwnerUserId": "4498329", "LastEditDate": "2015-12-08T09:20:46.773"}, "34153294": {"Id": "34153294", "PostTypeId": "2", "Body": "<p>First of all, your first premise is wrong: </p>\n<pre><code>int negzero = -0;\n</code></pre>\n<p>should produce a normal zero on any conformant architecture.</p>\n<p>References for that were given in @101010's answer:</p>\n<p>3.9.1 Fundamental types [basic.fundamental] \u00a73:</p>\n<blockquote>\n<p id=\"so_34148992_34153294_0\">... The signed and unsigned integer\n  types shall satisfy the constraints given in the C standard, section 5.2.4.2.1.</p>\n</blockquote>\n<p>Later in C reference:\n5.2.4.2.1 Sizes of integer types </p>\n<blockquote>\n<p id=\"so_34148992_34153294_1\">... Forward references: representations of types (6.2.6)</p>\n</blockquote>\n<p>and (still C):\n6.2.6 Representations of types / 6.2.6.2 Integer types \u00a7 3</p>\n<blockquote>\n<p id=\"so_34148992_34153294_2\">If the implementation supports negative zeros, they shall be generated only by:</p>\n<ul>\n<li><p id=\"so_34148992_34153294_3\">the &amp;, |, ^, ~, &lt;&lt;, and &gt;&gt; operators with arguments that produce such a value;</p></li>\n<li><p id=\"so_34148992_34153294_4\">the +, -, *, /, and % operators where one argument is a negative zero and the result is\n  zero;</p></li>\n<li><p id=\"so_34148992_34153294_5\">compound assignment operators based on the above cases.</p></li>\n</ul>\n</blockquote>\n<p>So <code>negzero = -0</code> is <strong>not</strong> such a construct and <strong>shall not</strong> produce a negative 0.</p>\n<p>For following lines, I will assume that <strong>the negative 0 was produced in a bitwise manner, on an implementation that supports it</strong>.</p>\n<p>C++ standard does not speak at all of negative zeros, and C standard just say of them that their existence is implementation dependant. I could not find any paragraph explicitly saying whether a negative zero  should or not be equal to a normal zero for relational or equality operator.</p>\n<p>So I will just cite in C reference : 6.5.8 Relational operators \u00a76</p>\n<blockquote>\n<p id=\"so_34148992_34153294_6\">Each of the operators &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), and &gt;=\n  (greater than or equal to) shall yield 1 if the specified relation is true and 0 if it is false.92)\n  The result has type int.</p>\n</blockquote>\n<p>and in C++ 5.9 Relational operators [expr.rel] \u00a75</p>\n<blockquote>\n<p id=\"so_34148992_34153294_7\">If both operands (after conversions) are of arithmetic or enumeration type, each of the operators shall yield\n  true if the specified relationship is true and false if it is false.</p>\n</blockquote>\n<p>My interpretation of standard is that an implementation may allow an alternate representation of the integer value 0 (<em>negative zero</em>) but it is still a representation of the value 0 and it should perform accordingly in any arithmetic expression, because C 6.2.6.2 Integer types \u00a7 3 says:</p>\n<blockquote>\n<p id=\"so_34148992_34153294_8\">negative zeros[...] shall be generated only by [...] <strong>the +, -, *, /, and % operators where one argument is a negative zero and the result is\n  zero</strong></p>\n</blockquote>\n<p>That means that if the result is not 0, a negative 0 should perform as a normal zero.</p>\n<p>So these two lines at least are perfectly defined and should produce <code>1</code>:</p>\n<pre><code>std::cout&lt;&lt;(1 &lt;&lt; negzero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(1 &gt;&gt; negzero)&lt;&lt;std::endl;\n</code></pre>\n<p>This line is clearly defined to be implementation dependant:</p>\n<pre><code>std::cout&lt;&lt;(~negzero)&lt;&lt;(~zero)&lt;&lt;std::endl;\n</code></pre>\n<p>because an implementation could have padding bits. If there are no padding bits, on a one's complement architecture <code>~zero</code> <strong>is</strong> <code>negzero</code>, so <code>~negzero</code> should produce a <code>0</code> but I could not find in standard if a negative zero should display as <code>0</code> or as <code>-0</code>. A negative <strong>floating point</strong> 0 should be displayed with a minus sign, but nothing seems explicit for an <em>integer</em> negative value.</p>\n<p>For the last 3 line involving relational and equality operators, there is nothing explicit in standard, so I would say it is implementation defined</p>\n<p>TL/DR:</p>\n<p>Implementation-dependent:</p>\n<pre><code>std::cout&lt;&lt;(negzero &lt; zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(negzero &lt;= zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(negzero == zero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(~negzero)&lt;&lt;(~zero)&lt;&lt;std::endl;\n</code></pre>\n<p>Perfectly defined and should produce 1:</p>\n<pre><code>std::cout&lt;&lt;(1 &lt;&lt; negzero)&lt;&lt;std::endl;\nstd::cout&lt;&lt;(1 &gt;&gt; negzero)&lt;&lt;std::endl;\n</code></pre>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2015-12-08T10:53:50.623", "Score": "3", "CreationDate": "2015-12-08T10:18:14.293", "ParentId": "34148992", "CommentCount": "0", "OwnerUserId": "3545273", "LastEditDate": "2015-12-08T10:53:50.623"}});