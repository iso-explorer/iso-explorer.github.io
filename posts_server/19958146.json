post_cb({"bq_ids": {"n4140": {"so_19958146_19958413_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 86}}, "n3337": {"so_19958146_19958413_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 81}}}, "19958413": {"LastActivityDate": "2013-11-13T16:10:27.020", "CommentCount": "0", "Body": "<p>The expression <code>mul3</code> has a <em>function type</em>: <code>float(float)</code> and not a <em>function pointer type</em> (like <code>float (*)(float)</code>). Therefore, the ctor template of <code>float_func</code> deduces <code>T</code> to be this function type <code>float(float)</code>:</p>\n<pre><code>template &lt;typename T&gt; float_func(const T&amp; ptr)\n</code></pre>\n<p>After substitution:</p>\n<pre><code>float_func(float (&amp;ptr)(float)) // T = float(float)\n</code></pre>\n<p>This leads to the instantiation of <code>impl&lt;float(float)&gt;</code> which in turn tries to declare a member of this function type (<code>T ptr_</code>) -- but this is illegal [temp.arg.type]/3:</p>\n<blockquote>\n<p id=\"so_19958146_19958413_0\">If a declaration acquires a function type through a type dependent on a <em>template-parameter</em> and this causes a declaration that does not use the syntactic form of a function declarator to have function type, the program is ill-formed. [<em>Example:</em></p>\n<pre><code>template&lt;class T&gt; struct A {\n    static T t;\n};\ntypedef int function();\nA&lt;function&gt; a; // ill-formed: would declare A&lt;function&gt;::t\n               // as a static member function\n</code></pre>\n<p id=\"so_19958146_19958413_1\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<hr>\n<p>The simplest solution I can think of is to take the sink argument by value:</p>\n<pre><code>template &lt;typename T&gt; float_func(T ptr)\n</code></pre>\n<p>This deduces a function pointer type for expressions of function type (forcing a function-to-pointer conversion).</p>\n<p>Another way is to instantiate <code>impl</code> with a decayed <code>T</code>, e.g. <code>new impl&lt; typename std::decay&lt;T&gt;::type &gt;(ptr)</code></p>\n</hr>", "CreationDate": "2013-11-13T15:57:01.000", "LastEditDate": "2013-11-13T16:10:27.020", "ParentId": "19958146", "Id": "19958413", "LastEditorUserId": "420683", "PostTypeId": "2", "Score": "4", "OwnerUserId": "420683"}, "19958146": {"CreationDate": "2013-11-13T15:45:58.610", "ViewCount": "1351", "Id": "19958146", "AcceptedAnswerId": "19958413", "Score": "2", "Title": "Acquire a function type for a member of a class template?", "CommentCount": "2", "Body": "<p>I am trying to write a float(float) function class</p>\n<pre><code>#pragma once\nclass float_func\n{\n    struct concept \n    {\n        virtual ~concept() {}\n        virtual float operator()(float) = 0;\n        virtual concept* clone() = 0;\n    };\n    template &lt;typename T&gt;\n        class impl : public concept\n    {\n        public:\n            impl(const T&amp; ptr) : ptr_(ptr) {};\n            virtual float operator()(float arg1) {\n                return ptr_(arg1);\n            }\n            virtual concept* clone() {\n                return new impl&lt;T&gt;(ptr_);\n            }\n        private:\n            T ptr_;\n\n    };\n\n    public:\n    float_func() { object_ = nullptr; }\n    template &lt;typename T&gt; float_func(const T&amp; ptr) : object_(new impl&lt;T&gt;(ptr)) {}\n    float_func(const float_func&amp; other) : object_(other.object_-&gt;clone()) {}\n    ~float_func() { delete object_; }\n    template &lt;typename T&gt; \n    float_func&amp; operator=(const T&amp; ptr) {\n        delete object_;\n        object_ = new impl&lt;T&gt;(ptr);\n        return *this;\n    }\n    float_func&amp; operator=(const float_func&amp; other) {\n        delete object_;\n        object_ = other.object_-&gt;clone();\n        return *this;\n    }\n    float operator()(float arg1) {\n        return (*object_)(arg1);\n    }\n    private:\n    concept* object_;\n};\n</code></pre>\n<p>Try to use it:</p>\n<pre><code>    #include &lt;iostream&gt;\n    #include &lt;functional&gt;\n    #include \"float_func.h\"\n\n    struct FloatFunctor\n    {\n        float operator()(float a) {\n            return a * 2.f;\n        }\n    };\n\n    float mul3(float a) {\n        return a * 3.f;\n    }\n\n    int main()\n    {\n        float_func f1 = FloatFunctor();\n        float_func f2 = &amp;mul3;\n        //float_func f3 = mul3; //! does not compile\n        std::function&lt;float(float)&gt; sf = mul3;\n        std::function&lt;float(float)&gt; sf2 = &amp;mul3;\n        std::cout &lt;&lt; f1(1) &lt;&lt; \" \" &lt;&lt;  f2(2) &lt;&lt;  \" \" &lt;&lt; sf(3) &lt;&lt; \" \" &lt;&lt; sf2(4) &lt;&lt; std::endl;\n        return 0;\n    };\n</code></pre>\n<p><code>float_func f3 = mul3</code> does not compile, but the stl version does compile. </p>\n<p>The error message:</p>\n<pre><code>float_func.cc\nC:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\VC\\INCLUDE\\xlocale(336) : wa\nrning C4530: C++ exception handler used, but unwind semantics are not enabled. S\npecify /EHsc\ne:\\src\\tmp\\type_erasure\\float_func.h(14) : warning C4180: qualifier applied to f\nunction type has no meaning; ignored\n        e:\\src\\tmp\\type_erasure\\float_func.h(28) : see reference to class templa\nte instantiation 'float_func::impl&lt;T&gt;' being compiled\n        with\n        [\n            T=float (float)\n        ]\n        float_func.cc(20) : see reference to function template instantiation 'fl\noat_func::float_func&lt;float(float)&gt;(T (__cdecl &amp;))' being compiled\n        with\n        [\n            T=float (float)\n        ]\ne:\\src\\tmp\\type_erasure\\float_func.h(22) : error C2207: 'float_func::impl&lt;T&gt;::pt\nr_' : a member of a class template cannot acquire a function type\n</code></pre>\n<p>Could you explain the error? </p>\n<p>How does std::function handle this kind of template argument or how could I modify my code to support  <code>float_func f3 = mul3</code>?</p>\n", "Tags": "<c++><templates>", "LastActivityDate": "2013-11-13T16:10:27.020", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "193251"}});