post_cb({"11637902": {"Id": "11637902", "PostTypeId": "2", "Body": "<p>I first had these two quotes, but now I think they actually just specify that things like <code>int &amp;ref = t.mem;</code> must happen during the lifetime of <code>t</code>.  Which it does, in your example.</p>\n<p>12.7 paragraph 1:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_0\">For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior.</p>\n</blockquote>\n<p>And paragraph 3:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_1\">To form a pointer to (or access the value of) a direct non-static member of an object <code>obj</code>, the construction of <code>obj</code> shall have started and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing the member value) results in undefined behavior.</p>\n</blockquote>\n<p>We have here a complete object of type <code>T</code> and a member subobject of type <code>int</code>.</p>\n<p>3.8 paragraph 1:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_2\">The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n<p id=\"so_11637611_11637902_3\">The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>By the way, 3.7.3 p1:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_4\">The storage for these [automatic storage duration] entities lasts until the block in which they are created exits.</p>\n</blockquote>\n<p>And 3.7.5:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_5\">The storage duration of member subobjects, base class subobjects and array elements is that of their complete object (1.8).</p>\n</blockquote>\n<p>So no worries about the compiler \"releasing\" the storage before the <code>exit</code> in this example.</p>\n<p>A non-normative note in 3.8p2 mentions that \"12.6.2 describes the lifetime of base and member subobjects,\" but the language there only talks about initialization and destructors, not \"storage\" or \"lifetime\", so I conclude that section does not affect the definition of \"lifetime\" for subobjects of trivial type.</p>\n<p>If I'm interpreting all this right, when <code>renew</code> is false, the lifetime of the complete class object ends at the end of the explicit destructor call, BUT the lifetime of the <code>int</code> subobject continues to the end of the program.</p>\n<p>3.8 paragraphs 5 and 6 say that pointers and references to \"allocated storage\" before or after any object's lifetime can be used in limited ways, and list a whole lot of things you may not do with them.  Lvalue-to-rvalue conversion, like the expression <code>ref == 42</code> requires, is one of those things, but that's not an issue if the lifetime of the <code>int</code> has not yet ended.</p>\n<p>So I think with <code>renew</code> false, the program is well-formed and the <code>assert</code> succeeds!</p>\n<p>With <code>renew</code> true, the storage is \"reused\" by the program, so the lifetime of the original <code>int</code> is over, and the lifetime of another <code>int</code> begins.  But then we get into 3.8 paragraph 7:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_6\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<ul>\n<li>the storage for the new object exactly overlays the storage location which the original object occupied, and</li>\n<li>the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</li>\n<li>the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and</li>\n<li>the original object was a most derived object (1.8) of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</li>\n</ul>\n</blockquote>\n<p>The first bullet point here is the trickiest one.  For a standard-layout class like your <code>T</code>, the same member certainly must always be in the same storage.  I'm not certain whether or not this is technically required when the type is not standard-layout.</p>\n<p>Although whether <code>ref</code> may still be used or not, there's another issue in this example.  </p>\n<p>12.6.2 paragraph 8:</p>\n<blockquote>\n<p id=\"so_11637611_11637902_7\">After the call to a constructor for class <code>X</code> has completed, if a member of <code>X</code> is neither initialized nor given a value during execution of the <em>compound-statement</em> of the body of the constructor, the member has indeterminate value.</p>\n</blockquote>\n<p>Meaning the implementation is compliant if it sets <code>t.mem</code> to zero or <code>0xDEADBEEF</code> (and sometimes debug modes will actually do such things before calling a constructor).</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2012-07-24T20:52:36.013", "Score": "3", "CreationDate": "2012-07-24T19:24:11.990", "ParentId": "11637611", "CommentCount": "7", "OwnerUserId": "459640", "LastEditDate": "2012-07-24T20:52:36.013"}, "bq_ids": {"n4140": {"so_11637611_11637902_7": {"length": 19, "quality": 1.0, "section_id": 435}, "so_11637611_11637902_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}, "so_11637611_11637902_6": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_11637611_11637902_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_11637611_11637902_1": {"length": 27, "quality": 1.0, "section_id": 446}, "so_11637611_11637902_4": {"length": 8, "quality": 0.6666666666666666, "section_id": 7170}, "so_11637611_11637902_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_11637611_11637902_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 7188}}, "n3337": {"so_11637611_11637902_7": {"length": 19, "quality": 1.0, "section_id": 427}, "so_11637611_11637902_5": {"length": 12, "quality": 0.9230769230769231, "section_id": 6932}, "so_11637611_11637902_6": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_11637611_11637902_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_11637611_11637902_1": {"length": 27, "quality": 1.0, "section_id": 437}, "so_11637611_11637902_4": {"length": 8, "quality": 0.6666666666666666, "section_id": 6914}, "so_11637611_11637902_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_11637611_11637902_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}}, "n4659": {"so_11637611_11637902_7": {"length": 19, "quality": 1.0, "section_id": 454}, "so_11637611_11637902_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}, "so_11637611_11637902_6": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_11637611_11637902_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_11637611_11637902_1": {"length": 27, "quality": 1.0, "section_id": 468}, "so_11637611_11637902_4": {"length": 8, "quality": 0.6666666666666666, "section_id": 8678}, "so_11637611_11637902_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}}}, "11637681": {"Id": "11637681", "PostTypeId": "2", "Body": "<p>You have not destroyed memory, you only manually called destructor (in this context it's not different then calling normal method). Memory (stack part) of your <code>t</code> variable was not 'released'. So this assert will always pass with your current code.</p>\n", "LastActivityDate": "2012-07-24T19:08:33.083", "CommentCount": "3", "CreationDate": "2012-07-24T19:08:33.083", "ParentId": "11637611", "Score": "0", "OwnerUserId": "1549474"}, "11637611": {"ViewCount": "392", "Body": "<p>Consider this code (for different values of <code>renew</code> and <code>cleanse</code>):</p>\n<pre><code>struct T {\n    int mem;\n    T() { }\n    ~T() { mem = 42; }\n};\n\n// identity functions, \n// but breaks any connexion between input and output\nint &amp;cleanse_ref(int &amp;r) {\n    int *volatile pv = &amp;r; // could also use cin/cout here\n    return *pv;\n}\n\nvoid foo () {\n    T t;\n    int &amp;ref = t.mem;\n    int &amp;ref2 = cleanse ? cleanse_ref(ref) : ref;\n    t.~T();\n    if (renew)\n        new (&amp;t) T;\n    assert(ref2 == 42);\n    exit(0);\n}\n</code></pre>\n<p>Is the <code>assert</code> guaranteed to pass?</p>\n<p>I understand that this style is <em>not</em> recommended. <em>Opinions</em> like \"this is not a sound practice\" are <em>not</em> of interest here.</p>\n<p>I want an answer showing a <strong>complete logical proof from standard quotes</strong>. The opinion of compiler writers might also be interesting.</p>\n<p>EDIT: now with two questions in one! See the <code>renew</code> parameter (with <code>renew == 0</code>, this is the original question).</p>\n<p>EDIT 2: I guess my question really is: what is a member object?</p>\n<p>EDIT 3: now with another <code>cleanse</code> parameter!</p>\n", "AcceptedAnswerId": "11637902", "Title": "After an object is destroyed, what happens to subobjects of scalar type?", "CreationDate": "2012-07-24T19:04:48.777", "Id": "11637611", "CommentCount": "9", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-08-19T15:50:27.463", "LastEditorUserId": "963864", "LastActivityDate": "2012-08-19T15:50:27.463", "Score": "-2", "OwnerUserId": "963864", "Tags": "<c++><destructor><language-lawyer><object-lifetime><explicit-destructor-call>", "AnswerCount": "2"}});