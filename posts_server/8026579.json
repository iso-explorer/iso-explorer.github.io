post_cb({"8026643": {"ParentId": "8026579", "CommentCount": "11", "Body": "<p>As @Charles's post pretty much answers the question directly quoting from the spec.</p>\n<p>Now, I think why <em>anonymous</em> type cannot be the return type of a function, is because suppose <code>f</code> returns an anonymous type, then what would one write at the calling site?</p>\n<pre><code>?????  obj = f();\n</code></pre>\n<p>What should be written in place of <code>?????</code> in the above code?</p>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "8026643", "Score": "1", "CreationDate": "2011-11-06T11:19:30.627", "LastActivityDate": "2011-11-06T11:19:30.627"}, "8026579": {"CommentCount": "1", "AcceptedAnswerId": "8030933", "PostTypeId": "1", "LastEditorUserId": "3964927", "CreationDate": "2011-11-06T11:01:17.520", "LastActivityDate": "2017-11-10T16:21:05.677", "LastEditDate": "2015-10-07T14:39:20.303", "ViewCount": "2550", "FavoriteCount": "3", "Title": "Can anonymous class be used as return types in C++?", "Id": "8026579", "Score": "11", "Body": "<p>Is there any way to use anonymous classes in C++ as return types?</p>\n<p>I googled that this may work:</p>\n<pre><code>struct Test {} * fun()\n{\n}\n</code></pre>\n<p>But this piece of code doesn't compile, the error message is: </p>\n<blockquote>\n<p id=\"so_8026579_8026579_0\">new types may not be defined in a return type</p>\n</blockquote>\n<p>Actually the code doesn't make any sense, I just want to figure out whether an anonymous class can be used as return type in C++.</p>\n<p>Here is my code:</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n    int mx = [] () -&gt; struct { int x, y ; } { return { 99, 101 } ; } ().x ;\n    return 0;\n}\n</code></pre>\n<p>I compile this code with g++ xx.cpp -std=c++0x, the compiler compains:</p>\n<pre><code>expected primary-expression before '[' token.\n</code></pre>\n", "Tags": "<c++><anonymous-types><anonymous-class>", "OwnerUserId": "508305", "AnswerCount": "6"}, "8030933": {"ParentId": "8026579", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Notice: These code snippets no longer work in the latest versions of g++. I compiled them with version 4.5.2, but versions 4.6.1 and 4.7.0 no longer accept them.  </p>\n<hr>\n<p>You <em>can</em> declare an anonymous struct as the return type of a lambda function in C++11. But it's not pretty. This code assigns the value 99 to <code>mx</code>:</p>\n<pre><code>int mx = [] () -&gt; struct { int x, y ; } { return { 99, 101 } ; } ().x ;\n</code></pre>\n<p>The ideone output is here: <a href=\"http://ideone.com/2rbfM\" rel=\"nofollow noreferrer\">http://ideone.com/2rbfM</a></p>\n<p>In response to cheng's request:</p>\n<p>The lambda function is a new feature in C++11. It's basically an anonymous function. Here is a simpler example of a lambda function, that takes no arguments and returns an <code>int</code>:</p>\n<pre><code>[] () -&gt; int { return 99 ; }\n</code></pre>\n<p>You can assign this to a variable (you have to use <code>auto</code> to do this):</p>\n<pre><code>auto f = [] () -&gt; int { return 99 ; } ;\n</code></pre>\n<p>Now you can call it like this:</p>\n<pre><code>int mx = f() ;\n</code></pre>\n<p>Or you can call it directly (which is what my code does):</p>\n<pre><code>int mx = [] () -&gt; int { return 99 ; } () ;\n</code></pre>\n<p>My code just uses <code>struct { int x, y ; }</code> in place of <code>int</code>. The <code>.x</code> at the end is the normal <code>struct</code> member syntax applied to the function's return value.</p>\n<p>This feature is not as useless as it might appear. You can call the function more than once, to access different members:</p>\n<pre><code>auto f = [] () -&gt; struct {int x, y ; } { return { 99, 101 } ; } ;\ncout &lt;&lt; f().x &lt;&lt; endl ;\ncout &lt;&lt; f().y &lt;&lt; endl ;\n</code></pre>\n<p>You don't even have to call the function twice. This code does exactly what the OP asked for:</p>\n<pre><code>auto f = [] () -&gt; struct {int x, y ; } { return { 99, 101 } ; } () ;\ncout &lt;&lt; f.x &lt;&lt; endl ;\ncout &lt;&lt; f.y &lt;&lt; endl ;\n</code></pre>\n</hr>", "OwnerUserId": "428857", "LastEditorUserId": "3980929", "LastEditDate": "2017-06-23T19:37:58.570", "Id": "8030933", "Score": "5", "CreationDate": "2011-11-06T22:33:23.703", "LastActivityDate": "2017-06-23T19:37:58.570"}, "bq_ids": {"n4140": {"so_8026579_8026579_0": {"section_id": 300, "quality": 0.6666666666666666, "length": 4}, "so_8026579_8026593_0": {"section_id": 3245, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_8026579_8026579_0": {"section_id": 291, "quality": 0.6666666666666666, "length": 4}, "so_8026579_8026593_0": {"section_id": 3118, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_8026579_8026579_0": {"section_id": 307, "quality": 0.6666666666666666, "length": 4}, "so_8026579_8026593_0": {"section_id": 4003, "quality": 0.5333333333333333, "length": 16}}}, "8026649": {"ParentId": "8026579", "CommentCount": "7", "Body": "<pre><code>struct Test {} * a;\ndecltype(a) fun() {\n  return a;\n}\n</code></pre>\n<p>btw, <code>struct Test {}</code> is not an anonymous struct.</p>\n", "OwnerUserId": "4279", "PostTypeId": "2", "Id": "8026649", "Score": "3", "CreationDate": "2011-11-06T11:21:34.140", "LastActivityDate": "2011-11-06T11:21:34.140"}, "8026593": {"ParentId": "8026579", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Not they can't. As indicated in the error message, from ISO/IEC 14882:2011 8.3.5/9:</p>\n<blockquote>\n<p id=\"so_8026579_8026593_0\">Types shall not be defined in return or parameter types. The type of a parameter or the return type for a function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition is nested within the member-specification for that class (including definitions in nested classes defined within the class).</p>\n</blockquote>\n<p>And you can't, of course, name an existing anonymous type as the return type in a function declaration as an anonymous class has no name.</p>\n<p>Although you can create a <code>typedef</code> for an unnamed class and use that as a return type, as the typedef name becomes the name of the class type for linkage purposes the class isn't really anonymous any more.</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2011-11-06T11:18:34.887", "Id": "8026593", "Score": "5", "CreationDate": "2011-11-06T11:05:16.557", "LastActivityDate": "2011-11-06T11:18:34.887"}, "47227092": {"ParentId": "8026579", "CommentCount": "0", "Body": "<p>The closest you can get to what you want is this, in C++14: </p>\n<pre><code>auto f() { \n    struct {\n        int x, y;\n    } ret{10,24};\n    return ret;\n}\nint main() {\n  printf(\"%i\", f().x);\n}\n</code></pre>\n<p>The struct is anonymous (ret is a variable name, not a type name), and is returned.</p>\n<p>You can still get it if needed with </p>\n<pre><code>using my_struct = decltype(f());\nmy_struct another; another.x++;\n</code></pre>\n", "OwnerUserId": "1495627", "PostTypeId": "2", "Id": "47227092", "Score": "0", "CreationDate": "2017-11-10T16:21:05.677", "LastActivityDate": "2017-11-10T16:21:05.677"}, "8026584": {"ParentId": "8026579", "CommentCount": "1", "Body": "<p>No, you can not do anonymous types like that in C++. </p>\n<p>You could however, use <code>typedef</code> to assign anonymous types new names.</p>\n<pre><code>typedef struct\n{\n    unsigned x;\n    unsigned y;\n} TPoint;\n</code></pre>\n", "OwnerUserId": "67606", "PostTypeId": "2", "Id": "8026584", "Score": "2", "CreationDate": "2011-11-06T11:03:28.130", "LastActivityDate": "2011-11-06T11:03:28.130"}});