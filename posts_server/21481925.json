post_cb({"21481925": {"CommentCount": "0", "ViewCount": "328", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-01-31T14:01:52.087", "LastActivityDate": "2014-01-31T14:14:23.790", "Title": "Extra curly braces while initializing a string", "AcceptedAnswerId": "21482157", "LastEditDate": "2017-05-23T11:56:06.220", "Id": "21481925", "Score": "4", "Body": "<p>According to question <a href=\"https://stackoverflow.com/questions/21481462/what-does-this-code-mean-and-why-does-it-work\">What does string array[] = \"\"; mean and why does it work?</a> I want to ask what difference between <em>s1</em> and <em>s2</em> in the code below:</p>\n<pre><code>int main() {\n    const char* s1 = { \"Hello\" }; // strange but work as followed\n    const char* s2 = \"Hello\"; // ordinary case \n    return 0;\n}\n</code></pre>\n<p>Why extra curly braces are permitted? Any reference to C++ standard will be useful.</p>\n", "Tags": "<c++><initialization>", "OwnerUserId": "3240681", "AnswerCount": "2"}, "21482059": {"ParentId": "21481925", "CommentCount": "4", "Body": "<p>The simple answer is: because the standard says so.  \u00a78.5.2/1:</p>\n<blockquote>\n<p id=\"so_21481925_21482059_0\">A char array (whether plain char, signed char, or unsigned\n  char), char16_t array, char32_t array, or wchar_t array can\n  be initialized by a narrow character literal, char16_t\n  string literal, char32_t string literal, or wide string\n  literal, respectively, <strong>or by an appropriately-typed string\n  literal enclosed in braces</strong>.  Successive characters of the\n  value of the string literal initialize the elements of the\n  array.</p>\n</blockquote>\n<p>(That's C++11, but earlier versions said the same thing, minus\nthe references to the new types.) </p>\n<p>The reason this is allowed is because C allowed it.  As to why\nC allowed it, I have no idea.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "21482059", "Score": "-1", "CreationDate": "2014-01-31T14:08:12.533", "LastActivityDate": "2014-01-31T14:08:12.533"}, "bq_ids": {"n4140": {"so_21481925_21482157_1": {"section_id": 3325, "quality": 1.0, "length": 16}, "so_21481925_21482059_0": {"section_id": 3314, "quality": 0.7906976744186046, "length": 34}}, "n3337": {"so_21481925_21482157_1": {"section_id": 3195, "quality": 0.6875, "length": 11}, "so_21481925_21482059_0": {"section_id": 3184, "quality": 1.0, "length": 43}}, "n4659": {"so_21481925_21482157_1": {"section_id": 4091, "quality": 1.0, "length": 16}, "so_21481925_21482059_0": {"section_id": 4080, "quality": 0.7906976744186046, "length": 34}}}, "21482157": {"ParentId": "21481925", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In C++98 (and C++03) this is pretty simple; in clause 8.5:</p>\n<blockquote>\n<p id=\"so_21481925_21482157_0\">14 - If <code>T</code> is a scalar type, then a declaration of the form\n  <code>T x = { a };</code>\n  is equivalent to\n  <code>T x = a;</code></p>\n</blockquote>\n<p>In C++11 this is covered by list-initialization (8.5.4p3):</p>\n<blockquote>\n<p id=\"so_21481925_21482157_1\">[...] if the initializer list has a single element of type E and either T is not a reference type or\n  its referenced type is reference-related to E, the object or reference is initialized from that element [...]</p>\n</blockquote>\n<p>I <em>think</em> this is the same question as <a href=\"https://stackoverflow.com/questions/14232184/initializing-scalars-with-braces?lq=1\">Initializing scalars with braces</a>.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:11:44.953", "Id": "21482157", "Score": "11", "CreationDate": "2014-01-31T14:13:41.493", "LastActivityDate": "2014-01-31T14:13:41.493"}});