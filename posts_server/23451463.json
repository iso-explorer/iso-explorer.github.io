post_cb({"bq_ids": {"n4140": {"so_23451463_23451463_0": {"length": 45, "quality": 0.8490566037735849, "section_id": 5485}}, "n3337": {"so_23451463_23451463_0": {"length": 32, "quality": 0.6037735849056604, "section_id": 5271}}, "n4659": {"so_23451463_23451463_0": {"length": 45, "quality": 0.8490566037735849, "section_id": 6920}}}, "23451463": {"ViewCount": "323", "Body": "<p>I attempted to get friend name injection to work with the following snippet:</p>\n<pre><code>struct foo\n{\n  friend foo f() { return {}; }\n};\n\nint main()\n{\n  auto x = f();\n  return 0;\n}\n</code></pre>\n<p>This fails to compile:</p>\n<pre><code>test.cc:8:10: error: use of undeclared identifier 'f'\n  auto x = f();\n           ^\n1 error generated.\n</code></pre>\n<p>I have to declare <code>f</code> in the outer namespace for the error to vanish.</p>\n<p>The standard has an explanation in paragraph 3 of \u00a77.3.1.2:</p>\n<blockquote>\n<p id=\"so_23451463_23451463_0\">If a friend declaration in a\n  non-local class first declares a class, function, class template or function template97 the friend is a member of the innermost enclosing namespace. The friend declaration does not by itself make the name visible to unqualified lookup (3.4.1) or qualified lookup (3.4.3). [Note: The name of the friend will be visible in its namespace <strong>if a matching declaration is provided at namespace scope (either before or after the class definition granting friendship)</strong>. \u2014 end note ]</p>\n</blockquote>\n<p>My question: why do we need an extra declaration of <code>f</code> at namespace scope for this to compile? Does it have to do with ADL? Is there a (hacky) way around this requirement?</p>\n", "AcceptedAnswerId": "23451534", "Title": "Issues with friend name injection", "CreationDate": "2014-05-04T00:59:57.017", "Id": "23451463", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-05-04T01:40:16.147", "Score": "2", "OwnerUserId": "1170277", "Tags": "<c++><friend>", "AnswerCount": "2"}, "23451488": {"Id": "23451488", "PostTypeId": "2", "Body": "<p>friend works on a declaration, not a definition.</p>\n<pre><code>struct foo\n{\n  friend foo f();\n};\n\nfoo f() { return {}; }\n\nint main()\n{\n  auto x = f();\n  return 0;\n}\n</code></pre>\n<p>compiles</p>\n", "LastActivityDate": "2014-05-04T01:05:20.427", "CommentCount": "4", "CreationDate": "2014-05-04T01:05:20.427", "ParentId": "23451463", "Score": "0", "OwnerUserId": "2015579"}, "23451534": {"Id": "23451534", "PostTypeId": "2", "Body": "<p>You can force ADL:</p>\n<pre><code>struct foo {\n  friend foo f(foo *) { return {}; }\n};\n\nint main()\n{\n  auto x = f((foo *) 0);\n  return 0;\n}\n</code></pre>\n<p>Compiles with g++ 4.9.0 and clang++ 3.4. Of course, might not be practical.</p>\n<p>ADDENDUM: Thanks to Richard Hodges, here is another possible workaround, but it might be a g++ 4.9.0 bug. There are differences between clang++ and g++. I'll try to look into what the standard says, if I have time. If the OP wants to post this as a new question asking about which compiler is wrong, please do.</p>\n<pre><code>struct foo {\n  friend foo f1() { return {}; }\n  friend foo f2(foo *) { return {}; }\n  template&lt;typename T = void&gt;\n  friend foo f3() { return {}; }\n};\n\nint main()\n{\n  auto x1 = f1(); // Error, f1() not visible.\n  auto x2 = f2((foo *) 0); // Force ADL.\n  auto x3 = f3&lt;void&gt;(); // Use template, okay with g++, fails with clang++.\n  auto x4 = f3(); // Use template with default param, okay with g++, fails with clang++.\n  return 0;\n}\n</code></pre>\n", "LastEditorUserId": "3521733", "LastActivityDate": "2014-05-04T01:40:16.147", "Score": "2", "CreationDate": "2014-05-04T01:13:28.577", "ParentId": "23451463", "CommentCount": "5", "OwnerUserId": "3521733", "LastEditDate": "2014-05-04T01:40:16.147"}});