post_cb({"bq_ids": {"n4140": {"so_425576_425715_0": {"length": 33, "quality": 1.0, "section_id": 255}}, "n3337": {"so_425576_425715_0": {"length": 33, "quality": 1.0, "section_id": 246}}, "n4659": {"so_425576_425715_0": {"length": 33, "quality": 1.0, "section_id": 262}}}, "425576": {"ViewCount": "1879", "Body": "<p>An explicit instantiation of a static template member function keeps failing to compile with the message <code>error C2785: 'at_Intermediate CUtil::convert_variant(const VARIANT &amp;)' and '&lt;Unknown&gt;' have different return types</code></p>\n<p>When I make a corresponding class with non-static member functions, the compiler likes me.  </p>\n<pre><code>// utility class - static methods\nstruct CUtil {\n      template&lt; typename at_Intermediate &gt; static at_Intermediate convert_variant( const VARIANT &amp;v ) ;\n\n      template&lt;&gt; static VARIANT convert_variant&lt;VARIANT &gt;( const VARIANT &amp;v ) { return v; } // \n      template&lt;&gt; static double  convert_variant&lt;double  &gt;( const VARIANT &amp;v ) { return v.dblVal; }\n      template&lt;&gt; static long    convert_variant&lt;long    &gt;( const VARIANT &amp;v ) { return v.lVal  ; }\n      template&lt;&gt; static BSTR    convert_variant&lt;BSTR    &gt;( const VARIANT &amp;v ) { return v.bstrVal; }\n};\n</code></pre>\n<p>This is a composed question:</p>\n<ol>\n<li><p>Why does the compiler complain about a function \"Unknown\" while it's clearly known?</p></li>\n<li><p>What triggers this message - it disappears when the function is made global or non-static.</p></li>\n</ol>\n<p>EDIT:</p>\n<p>after some useful hints from Josh: is it not allowed to explicitly instantiate template functions within the class declaration?</p>\n", "AcceptedAnswerId": "425715", "Title": "Template instantiation with VARIANT return type", "CreationDate": "2009-01-08T19:38:33.820", "Id": "425576", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-01-08T20:15:58.487", "LastEditorDisplayName": "xtofl", "OwnerDisplayName": "xtofl", "LastEditorUserId": "6610", "LastActivityDate": "2009-01-08T20:24:04.570", "Score": "3", "OwnerUserId": "6610", "Tags": "<c++><templates>", "AnswerCount": "2"}, "425715": {"Body": "<p>Apparently you may only use explicit template specialization at namespace scope although I can't find this in the standard (but GCC says as much). The following works for me (on GCC):</p>\n<pre><code>struct CUtil {\n    template&lt; typename at_Intermediate &gt; static at_Intermediate convert_variant( const VARIANT &amp;v ) ;\n};\n\ntemplate&lt;&gt; VARIANT CUtil::convert_variant&lt;VARIANT &gt;( const VARIANT &amp;v ) { return v; }\ntemplate&lt;&gt; double  CUtil::convert_variant&lt;double  &gt;( const VARIANT &amp;v ) { return v.dblVal; }\ntemplate&lt;&gt; long    CUtil::convert_variant&lt;long    &gt;( const VARIANT &amp;v ) { return v.lVal  ; }\ntemplate&lt;&gt; BSTR    CUtil::convert_variant&lt;BSTR    &gt;( const VARIANT &amp;v ) { return v.bstrVal; }\n</code></pre>\n<p><strong>EDIT</strong> It <em>is</em> in the standard:</p>\n<p>14.7.2.5:</p>\n<blockquote>\n<p id=\"so_425576_425715_0\">An explicit instantiation of a class or function template specialization is placed in the namespace in which the template is defined. An explicit instantiation for a member of a class template is placed in the namespace where the enclosing class is defined. <em>An explicit instantiation for a <strong>member template</strong> is placed in the namespace where the enclosing class or class template is defined.</em></p>\n</blockquote>\n<p>(All emphasis added by me.)</p>\n", "CreationDate": "2009-01-08T20:15:49.313", "ParentId": "425576", "CommentCount": "7", "LastEditDate": "2009-01-08T20:24:04.570", "PostTypeId": "2", "LastEditorDisplayName": "Konrad Rudolph", "LastActivityDate": "2009-01-08T20:24:04.570", "LastEditorUserId": "1968", "Id": "425715", "OwnerDisplayName": "Konrad Rudolph", "Score": "2", "OwnerUserId": "1968"}, "425671": {"Body": "<p>Try it this way:</p>\n<pre><code>struct CUtil {\n    template&lt; typename T &gt; \n    static T convert_variant(const VARIANT &amp;);\n};\n\ntemplate&lt;&gt; int CUtil::convert_variant&lt;int&gt;(const VARIANT &amp;);\ntemplate&lt;&gt; VARIANT CUtil::convert_variant&lt;VARIANT&gt;(const VARIANT &amp;);\n</code></pre>\n<p>You can't explicitly specialize a template inside a class scope.  <a href=\"http://msdn.microsoft.com/en-us/library/8zft3014.aspx\" rel=\"nofollow noreferrer\">See here</a>.</p>\n<p>The wierd issue with VS2008 is that this does work.</p>\n<pre><code>struct CUtil {\n    template&lt; typename T &gt; \n    static T convert_variant(const VARIANT &amp;);\n    template&lt;&gt; \n    static int convert_variant&lt;int&gt;(const VARIANT &amp;);\n};\n</code></pre>\n<p>And this:</p>\n<pre><code>struct CUtil {\n    template&lt; typename T &gt; static void convert_variant(T);\n    template&lt;&gt; static void convert_variant&lt;VARIANT &gt;(VARIANT);\n};\n</code></pre>\n", "CreationDate": "2009-01-08T20:02:57.467", "ParentId": "425576", "CommentCount": "8", "LastEditDate": "2009-01-08T20:17:32.820", "PostTypeId": "2", "LastEditorDisplayName": "Josh", "LastActivityDate": "2009-01-08T20:17:32.820", "LastEditorUserId": "8701", "Id": "425671", "OwnerDisplayName": "Josh", "Score": "2", "OwnerUserId": "8701"}});