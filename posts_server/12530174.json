post_cb({"bq_ids": {"n4140": {"so_12530174_12531411_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 214}}, "n3337": {"so_12530174_12531411_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 208}}, "n4659": {"so_12530174_12531411_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 222}}}, "12531196": {"Id": "12531196", "PostTypeId": "2", "Body": "<p>The observed behavior is correct, as <code>foo(a)</code> is a type dependent expression according to:</p>\n<pre><code>14.6.2.2 Type-dependent expressions                         [temp.dep.expr]\n\n1) Except as described below, an expression is type-dependent if any\n   subexpression is type-dependent.\n\n2) this is type-dependent if the class type of the enclosing member\n   function is dependent (14.6.2.1).\n\n3) An id-expression is type-dependent if it contains\n\n    \u2014 an identifier associated by name lookup with one or more declarations \n      declared with a dependent type,\n    ...\n</code></pre>\n<p>and under 14.6.4 (Dependent name resoultion):</p>\n<pre><code>14.6.4.2 Candidate functions                              [temp.dep.candidate]\n\nFor a function call that depends on a template parameter, the candidate\nfunctions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except\nthat:\n\n\u2014 For the part of the lookup using unqualified name lookup (3.4.1) or qualified\n  name lookup (3.4.3), only function declarations from the template definition \n  context are found.\n\u2014 For the part of the lookup using associated namespaces (3.4.2), only function\n  declarations found in either the template definition context or the template\n  instantiation context are found.\n\nIf the function name is an unqualified-id and the call would be ill-formed or\nwould find a better match had the lookup within the associated namespaces\nconsidered all the function declarations with external linkage introduced in\nthose namespaces in all translation units, not just considering those\ndeclarations found in the template definition and template instantiation\ncontexts, then the program has undefined behavior.\n</code></pre>\n<p>The \"wrong\" <code>foo()</code> is picked because that's the only one visible at <em>the point of template definition</em>, and the \"right\" <code>foo()</code> is not considered because it's not in a <em>namespace associated with the types of the function arguments</em>.</p>\n<p>If you modify your code so that the \"right\" <code>foo()</code> would be in an associated namespace, it would be picked instead of the \"wrong\" <code>foo()</code>. (In this particular case, it's not allowed by the standard, so don't do the below, but with your own namespace / types this is how it should work)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename A&gt; void foo(A&amp; a)\n{\n    std::cout &lt;&lt; \"the wrong foo\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename A&gt;\nvoid do_stuff(A&amp; a) {\n    foo(a);\n}\n\nnamespace std { // evil, don't do this with namespace std!\n\ntemplate&lt;typename X&gt;\nvoid foo(std::vector&lt;X&gt;&amp; a) {\n    std::cout &lt;&lt; \"the right foo\" &lt;&lt; std::endl;\n}\n\n}\n\nint main()\n{\n    std::vector&lt;int&gt; q;\n    do_stuff(q); // calls the \"right\" foo()\n}\n</code></pre>\n", "LastEditorUserId": "18645", "LastActivityDate": "2012-09-21T14:31:50.283", "Score": "3", "CreationDate": "2012-09-21T13:06:28.233", "ParentId": "12530174", "CommentCount": "6", "OwnerUserId": "18645", "LastEditDate": "2012-09-21T14:31:50.283"}, "12531411": {"Id": "12531411", "PostTypeId": "2", "Body": "<p>Within a template definition, name lookup for a non-dependent name (that is, one like <code>foo</code> that doesn't depend on the template parameters) is performed where the template is defined, not where it's instantiated. This is specified by the standard:</p>\n<blockquote>\n<p id=\"so_12530174_12531411_0\">C++11 14.6.3 Non-dependent names used in a template definition are found using the usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>and illustrated by an example similar to yours:</p>\n<pre><code>void g(double);\nvoid h();\n\ntemplate&lt;class T&gt; class Z {\npublic:\n  void f() {\n    g(1);           // calls g(double)\n    h++;            // ill-formed: cannot increment function;\n                    // this could be diagnosed either here or\n                    // at the point of instantiation\n  }\n};\n\nvoid g(int);        // not in scope at the point of the template\n                    // definition, not considered for the call g(1)\n</code></pre>\n<p>Regarding your update: I believe that, with both <code>foo</code> declarations placed after <code>do_stuff</code>, the program should be ill-formed, and GCC is incorrect to (apparently) defer lookup until the point of instantiation when it fails at the point of use.</p>\n<p><strong>UPDATE:</strong> As noted in the comments, this behaviour is indeed incorrect, and was fixed in gcc-4.7.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2012-09-21T14:25:03.420", "Score": "3", "CreationDate": "2012-09-21T13:19:27.893", "ParentId": "12530174", "CommentCount": "4", "OwnerUserId": "204847", "LastEditDate": "2012-09-21T14:25:03.420"}, "12530174": {"ViewCount": "218", "Body": "<p>Consider this piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename A&gt;\nvoid foo(A&amp; a) {\n    std::cout &lt;&lt; \"the wrong foo\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename A&gt;\nvoid do_stuff(A&amp; a) {\n    foo(a);\n}\n\ntemplate&lt;typename X&gt;\nvoid foo(std::vector&lt;X&gt;&amp; a) {\n    std::cout &lt;&lt; \"the right foo\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::vector&lt;int&gt; q;\n    do_stuff(q);\n}\n</code></pre>\n<p>Why is it calling the \"wrong\" foo? If the first declaration of foo is removed the right foo is called.</p>\n<p>I am using gcc 4.6.3.</p>\n<p><strong>Update:</strong>\nIf functions are declared in the following order, the right foo is called.</p>\n<pre><code>template&lt;typename A&gt; void do_stuff(A&amp; a) { ... }\ntemplate&lt;typename A&gt; void foo(A&amp; a) { ... }\ntemplate&lt;typename X&gt; void foo(std::vector&lt;X&gt;&amp; a) { ... }\n</code></pre>\n", "AcceptedAnswerId": "12531196", "Title": "Template function lookup", "CreationDate": "2012-09-21T11:59:13.233", "Id": "12530174", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-09-21T12:47:28.220", "LastEditorUserId": "316448", "LastActivityDate": "2012-09-21T14:31:50.283", "Score": "7", "OwnerUserId": "316448", "Tags": "<c++><templates>", "AnswerCount": "3"}, "12530425": {"Id": "12530425", "PostTypeId": "2", "Body": "<p>When you call <code>do_stuff</code> the type of <code>a</code> is <code>std::vector&lt;int&gt;</code>. The compiler then searches for a <code>foo</code> that takes <code>std::vector&lt;int&gt;</code> and finds that it can use <code>foo(A&amp;)</code> (the 'wrong' <code>foo</code>), <code>foo(std::vector&lt;B&gt;&amp;)</code> has yet to be declared. If you remove this declaration you should get a compiler error as templates must be defined before they are used. If you don't it may be down to a bug in the template system of gcc rather than a feature of the language. Try it with <code>clang++</code> and you should see:</p>\n<pre><code>test.cpp:6:5: error: call to function 'foo' that is neither visible in the template definition nor found by\n  argument-dependent lookup\nfoo(a);\n^\n</code></pre>\n<p>EDIT: It seems that this is actually an error in the way <code>clang++</code> deals with templates, it should be able to resolve the call to the second <code>foo</code> that appears before the instantiation of the template.</p>\n", "LastEditorUserId": "1353098", "LastActivityDate": "2012-09-21T12:36:18.880", "Score": "2", "CreationDate": "2012-09-21T12:14:41.253", "ParentId": "12530174", "CommentCount": "7", "OwnerUserId": "1353098", "LastEditDate": "2012-09-21T12:36:18.880"}});