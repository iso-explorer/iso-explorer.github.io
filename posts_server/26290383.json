post_cb({"26290383": {"CommentCount": "4", "ViewCount": "124", "CreationDate": "2014-10-10T01:09:23.430", "LastActivityDate": "2014-10-10T01:22:13.700", "Title": "When sharing a const across files using extern, why is extern needed on the definition?", "AcceptedAnswerId": "26290498", "PostTypeId": "1", "Id": "26290383", "Score": "1", "Body": "<p>Page 60 of C++ Primer 5th edition talks about sharing const variables across files like so</p>\n<pre><code>//file_1.cc\nextern const int bufSize = fcn();\n\n//file_1.h\nextern const int bufSize;\n</code></pre>\n<p>When would bufSize be defined and what is the purpose of extern on file_1.cc? I understand that file_1.cc would define it, but Page 45 of the same book says that providing an initializer for a variable overrides the extern, so why is it necessary to have extern on the const's definition?</p>\n", "Tags": "<c++>", "OwnerUserId": "4127594", "AnswerCount": "1"}, "26290498": {"ParentId": "26290383", "CommentCount": "0", "Body": "<p>According to the standard,</p>\n<blockquote>\n<p id=\"so_26290383_26290498_0\">A name having namespace scope (3.3.6) has internal linkage if it is the name of ... a non-volatile variable that is explicitly declared <code>const</code> or <code>constexpr</code> and neither explicitly declared\n  <code>extern</code> nor previously declared to have external linkage</p>\n</blockquote>\n<p>So there is a special rule that variables at namespace scope have internal linkage when <code>const</code> or <code>constexpr</code> even if they would otherwise have external linkage. I'm not entirely sure why this rule exists but I suspect it's to allow the compiler to inline <code>const</code> variables and hence not allocate any storage for them at all. The <code>extern</code> specifier explicitly overrides this and makes the variable have external linkage again.</p>\n<blockquote>\n<p id=\"so_26290383_26290498_1\">providing an initializer for a variable overrides the extern</p>\n</blockquote>\n<p>Now this is a bit different. By default a declaration of a variable is also a definition, but <code>extern</code> suppresses this so you can declare a variable without defining it (i.e. because its definition is in another translation unit). But if you have an initializer then it overrides the <code>extern</code> and the declaration once again becomes a definition. This isn't really related to the rules about internal and external linkage above.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "26290498", "Score": "2", "CreationDate": "2014-10-10T01:22:13.700", "LastActivityDate": "2014-10-10T01:22:13.700"}, "bq_ids": {"n4140": {"so_26290383_26290498_0": {"section_id": 7136, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_26290383_26290498_0": {"section_id": 6880, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_26290383_26290498_0": {"section_id": 8637, "quality": 0.8333333333333334, "length": 20}}}});