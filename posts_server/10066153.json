post_cb({"10066310": {"ParentId": "10066153", "CommentCount": "9", "Body": "<p>c++ has big problems with order of calling global objects constructors\nsomebody calls it \"global initialization fiasco\"\nIt's not related with multithreading, but related with initialization\nIf your program has many global objects then it may cause some problems (of course there are some methods to solve that problem)</p>\n<p>You can use pattern 'singleton' but I'm not sure will it be useful in your case</p>\n", "OwnerUserId": "1320433", "PostTypeId": "2", "Id": "10066310", "Score": "-1", "CreationDate": "2012-04-08T20:38:31.730", "LastActivityDate": "2012-04-08T20:38:31.730"}, "10073976": {"ParentId": "10066153", "CommentCount": "0", "Body": "<p>By using global variables in your classes you make them difficult to test. Their behaviour now depends on a global state, which makes it difficult to reason about them. One class depends on the global variable. Another class depends on it, too. Both can change the state of the global variable any time. In essence you have a created a mutual dependency between both classes. With every access to the global variable you are one step closer to one version of the dependency hell.</p>\n<p>You have mentioned that you do not want to pass them around as pointers. Actually I would prefer that method. By explicitly passing a dependency (your global variables) to a method or constructor you tell the world about it. If you need to pass ten dependencies to your method, you might want to rethink your solution. It might be a lot of work, but helps to improve the architecture of your program.</p>\n<p>You have written that your classes \"tend to present really broad functionality\". This might be an indicator that they should be broken down into smaller components, so that you only have to pass around the functionality that you actually need.</p>\n<p>My advice is that</p>\n<ul>\n<li>you should avoid using global variables, especially in the form of singletons</li>\n<li>try to find out more about <a href=\"http://martinfowler.com/articles/injection.html\" rel=\"nofollow\">dependency injection</a> to properly pass around your dependencies</li>\n<li>watch video <a href=\"https://www.youtube.com/watch?v=RlfLCWKxHJ0\" rel=\"nofollow\">Don't look for things</a> (Clean Code Talks, Misko Hevery)</li>\n</ul>\n", "OwnerUserId": "1275714", "PostTypeId": "2", "Id": "10073976", "Score": "0", "CreationDate": "2012-04-09T13:31:23.863", "LastActivityDate": "2012-04-09T13:31:23.863"}, "10066153": {"CommentCount": "4", "ViewCount": "385", "PostTypeId": "1", "LastEditorUserId": "734069", "CreationDate": "2012-04-08T20:17:10.367", "LastActivityDate": "2012-04-10T05:50:45.403", "Title": "C++: Is it bad to use global variables that are pointers to instantiations of single-instance-only classes?", "AcceptedAnswerId": "10066175", "LastEditDate": "2012-04-08T20:20:42.440", "Id": "10066153", "Score": "0", "Body": "<p>In my program, I've got a bunch of classes that will only ever have one created instance for the duration of the program. They are created only once on initialization, and destroyed only once on closing.</p>\n<p>These classes all tend to present really broad functionality that is used by many different parts of the program, and so having them as global externs is really clean and easy to understand, rather than encapsulating them in another class or passing around pointers.</p>\n<p>The program is multi-threaded, and all of these classes contain their own mutex for access.</p>\n<p>Are there any problems with this approach? If so, what are the recommended alternatives.</p>\n", "Tags": "<c++><global-variables>", "OwnerUserId": "280832", "AnswerCount": "4"}, "10066195": {"ParentId": "10066153", "CommentCount": "3", "Body": "<p>You can use a Singleton, but be sure of thread safety. For a tutorial, take a look at <a href=\"http://www.oaklib.org/docs/oak/singleton.html\" rel=\"nofollow\">SINGLETON PATTERN - 1. THREAD SAFETY</a></p>\n<p>An example would be </p>\n<pre><code>static SomeSingleton* getInstance()\n{\n    lock_mutex();\n    if(!pInstance_)\n        pInstance_ = new SomeSingleton();\n    unlock_mutex();\n    return pInstance_;\n}\n</code></pre>\n", "OwnerUserId": "1157214", "PostTypeId": "2", "Id": "10066195", "Score": "0", "CreationDate": "2012-04-08T20:24:42.397", "LastActivityDate": "2012-04-08T20:24:42.397"}, "bq_ids": {"n4140": {"so_10066153_10066175_0": {"section_id": 7151, "quality": 1.0, "length": 11}}, "n3337": {"so_10066153_10066175_0": {"section_id": 6895, "quality": 1.0, "length": 11}}, "n4659": {"so_10066153_10066175_0": {"section_id": 8653, "quality": 0.6363636363636364, "length": 7}}}, "10066175": {"ParentId": "10066153", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Use a singleton pattern as follows:</p>\n<pre><code>Foo&amp; foo() { static Foo x; return x; }\n</code></pre>\n<p>This is completely thread-safe. See here: <a href=\"https://stackoverflow.com/questions/9533649/g-4-6-std-gnu0x-static-local-variable-constructor-call-timing-and-thread-s\">G++ 4.6 -std=gnu++0x: Static Local Variable Constructor Call Timing and Thread Safety</a></p>\n<p>It is guaranteed by the current standard.</p>\n<p>Furthermore this is superior to static initialized global variables because if you have multiple of the above they will be initialized lazily in the correct dependency order.</p>\n<pre><code>Foo&amp; foo() { static Foo x; return x; }\n\nBar&amp; bar() { static Bar x; return x; }\n</code></pre>\n<p>and in Bar::Bar there is a call to foo(), then the Foo singleton will be created before Bar.</p>\n<p>If I had of used global variables:</p>\n<pre><code>// Foo.cpp\nFoo foo;\n\n// Bar.cpp\nBar bar;\n</code></pre>\n<p>No such ordering is guaranteed.</p>\n<h3>3.6.2 Initialization of non-local variables</h3>\n<blockquote>\n<p id=\"so_10066153_10066175_0\">...the initialization of a variable is indeterminately sequenced with respect to the initialization of a variable defined in a different translation unit....</p>\n</blockquote>\n", "OwnerUserId": "1131467", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:34:38.073", "Id": "10066175", "Score": "2", "CreationDate": "2012-04-08T20:21:56.403", "LastActivityDate": "2012-04-10T05:50:45.403"}});