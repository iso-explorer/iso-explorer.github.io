post_cb({"5950457": {"ViewCount": "7538", "Body": "<p>I am in need of your help once again...</p>\n<p>I had the following code, which was causing <strong>explicit specialization in non-namespace scope</strong> error:</p>\n<pre><code>namespace __test\n{\n    template &lt;int A, int B, typename C&gt; class Test\n    {\n        template &lt;int V&gt; void check(C &amp; a) { }\n        template &lt;&gt; void check&lt;0&gt;(C &amp; a) { } //error: explicit specialization in non-namespace scope 'class __test::Test&lt;A, B, C&gt;'\n    };\n}\n</code></pre>\n<p><br>\nSince I already know how to fix this kind of errors, I defined specialization outside of the class scope, however I got another error - <strong>... used without template parameters</strong>:</br></p>\n<pre><code>namespace __test\n{\n    template &lt;&gt; void Test::check&lt;0&gt;(C &amp; a) { } //error: 'template&lt;int A, int B, class C&gt; class __test::Test' used without template parameters\n}\n</code></pre>\n<p><br>\nI'm probably just being stupid, but I don't understand the cause of this problem and I don't know how to fix it... Please help!</br></p>\n", "AcceptedAnswerId": "5951103", "Title": "... used without template parameters error", "CreationDate": "2011-05-10T13:04:17.403", "Id": "5950457", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-05-13T00:57:16.960", "Score": "4", "OwnerUserId": "714964", "Tags": "<c++><templates><gcc>", "AnswerCount": "2"}, "5950924": {"Id": "5950924", "PostTypeId": "2", "Body": "<p>By my reading of the standard, what you want to do appears to be legal. Quoting \u00a714.7.3/18:</p>\n<blockquote>\n<p id=\"so_5950457_5950924_0\">In an explicit specialization declaration for a member of a class template or a member template that appears in namespace scope, the member template and some of its enclosing class templates may remain unspecialized, <strong>except that the declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well</strong>. In such explicit specialization declaration, the keyword <code>template</code> followed by a <em>template-parameter-list</em> shall be provided instead of the <code>template&lt;&gt;</code> preceding the explicit specialization declaration of the member. The types of the <em>template-parameters</em> in the <em>template-parameter-list</em> shall be the same as those specified in the primary template definition.</p>\n</blockquote>\n<p>As you're explicitly specializing a <em>member function template</em> rather than a <em>class member template</em>, it should be fine; however, neither Comeau, GCC, nor VC++ allow the following, which <em>should</em> be correct syntax:</p>\n<pre><code>namespace test\n{\n    template&lt;int A, int B, typename C&gt;\n    class Test\n    {\n        template&lt;int V&gt;\n        void check(C&amp; a) { }\n    };\n\n    template&lt;int A, int B, typename C&gt;\n    template&lt;&gt;\n    void Test&lt;A, B, C&gt;::check&lt;0&gt;(C&amp; a) { }\n}\n</code></pre>\n<ul>\n<li>Comeau says <code>error: a template declaration containing a template parameter list may not be followed by an explicit specialization declaration</code>, which makes sense if we apply the rule in \u00a714.7.3/18 to member function templates as well</li>\n<li>GCC says <code>invalid explicit specialization before '&gt;' token</code>; <code>enclosing class templates are not explicitly specialized</code>, which again makes sense if we apply the rule in \u00a714.7.3/18 to member function templates as well</li>\n<li>VC++ says <code>error C2768: 'test::Test&lt;A,B,C&gt;::check' : illegal use of explicit template arguments</code>, which isn't a helpful error message, but generally falls in line with the others</li>\n</ul>\n<p>My <strong>guess</strong> is that there must be a defect report filed that also disallows explicit specializations of member function templates when the enclosing class templates are not explicitly specialized as well; however, I can't say this definitively since the wording for \u00a714.7.3/18 hasn't changed between the C++03 standard and the C++0x FDIS (which it would if a DR was filed against C++03 and accepted).</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2011-05-13T00:57:16.960", "Score": "4", "CreationDate": "2011-05-10T13:36:29.507", "ParentId": "5950457", "CommentCount": "1", "OwnerUserId": "636019", "LastEditDate": "2011-05-13T00:57:16.960"}, "5951103": {"Id": "5951103", "PostTypeId": "2", "Body": "<p>You need to either fully specialize everything, like this:</p>\n<pre><code>namespace __test {\n\ntemplate &lt;int A, int B, typename C&gt;\nclass Test\n{\n    template &lt;int V&gt; void check(C &amp; a) { }\n};\n\ntemplate &lt;&gt;\ntemplate &lt;&gt;\nvoid Test&lt;1, 2, int&gt;::check&lt;0&gt; (int &amp;)\n{\n}\n\n}\n</code></pre>\n<p>Or use a helper structure to avoid trying to partially specialize template method of a template class (which GCC and many others won't understand):</p>\n<pre><code>namespace __test {\n\ntemplate &lt;typename C, int V&gt;\nstruct TestHelper\n{\n    static void check (C &amp; a)\n    {\n    }\n};\n\ntemplate &lt;typename C&gt;\nstruct TestHelper&lt;C, 0&gt;\n{\n    static void check (C &amp; a)\n    {\n    }\n};\n\ntemplate &lt;int A, int B, typename C&gt;\nclass Test\n{\n    template &lt;int V&gt; void check(C &amp; a)\n    {\n        TestHelper&lt;C, V&gt;::check (a);\n    }\n};\n\n}\n</code></pre>\n", "OwnerDisplayName": "user405725", "LastActivityDate": "2011-05-10T13:49:37.913", "Score": "3", "CreationDate": "2011-05-10T13:49:37.913", "ParentId": "5950457", "CommentCount": "3"}, "bq_ids": {"n4140": {"so_5950457_5950924_0": {"length": 60, "quality": 0.9836065573770492, "section_id": 278}}, "n3337": {"so_5950457_5950924_0": {"length": 60, "quality": 0.9836065573770492, "section_id": 269}}, "n4659": {"so_5950457_5950924_0": {"length": 60, "quality": 0.9836065573770492, "section_id": 285}}}});