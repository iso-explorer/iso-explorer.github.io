post_cb({"bq_ids": {"n4140": {"so_16635822_16636025_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 603}, "so_16635822_16636025_4": {"length": 5, "quality": 1.0, "section_id": 111}, "so_16635822_16636025_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 603}, "so_16635822_16636025_1": {"length": 6, "quality": 0.75, "section_id": 603}}, "n3337": {"so_16635822_16636025_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 593}, "so_16635822_16636025_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 593}, "so_16635822_16636025_4": {"length": 5, "quality": 1.0, "section_id": 106}, "so_16635822_16636025_1": {"length": 6, "quality": 0.75, "section_id": 593}}, "n4659": {"so_16635822_16636025_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 629}, "so_16635822_16636025_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 629}, "so_16635822_16636025_4": {"length": 5, "quality": 1.0, "section_id": 115}, "so_16635822_16636025_1": {"length": 6, "quality": 0.75, "section_id": 629}}}, "16635939": {"Id": "16635939", "PostTypeId": "2", "Body": "<p>The first is an exact match, the second requires a conversion. Exact matches have priority over conversions.</p>\n<p>Those other questions you linked are mostly unrelated to yours.</p>\n<p>Some advice: don't use template conversion operators. Name it <code>convert_to</code> instead.</p>\n", "LastActivityDate": "2013-05-19T14:49:20.363", "CommentCount": "1", "CreationDate": "2013-05-19T14:49:20.363", "ParentId": "16635822", "Score": "5", "OwnerUserId": "964135"}, "16636025": {"Id": "16636025", "PostTypeId": "2", "Body": "<p><strong>The first (template) overload should be picked</strong>.</p>\n<p>Paragraph 13.3.3/1 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_16635822_16636025_0\">[...] a viable function <code>F1</code> is defined to be a <strong>better function than another viable function</strong>\n<code>F2</code> if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then</p>\n<p id=\"so_16635822_16636025_1\">\u2014 for some argument <code>j</code>, <code>ICSj(F1)</code> is a better conversion sequence than <code>ICSj(F2)</code>, or, if not that,</p>\n<p id=\"so_16635822_16636025_2\">\u2014 <strong>the context is an initialization by user-defined conversion</strong> (see 8.5, 13.3.1.5, and 13.3.1.6) <strong>and the\n  standard conversion sequence from the return type of <code>F1</code> to the destination type</strong> (i.e., the type of the\n  entity being initialized) <strong>is a better conversion sequence than the standard conversion sequence from\n  the return type of <code>F2</code> to the destination type</strong>. [ <em>Example</em>:</p>\n<pre><code>struct A {\n    A();\n    operator int();\n    operator double();\n} a;\nint i = a; // a.operator int() followed by no conversion\n           // is better than a.operator double() followed by\n           // a conversion to int\nfloat x = a; // ambiguous: both possibilities require conversions,\n             // and neither is better than the other\n</code></pre>\n<p id=\"so_16635822_16636025_3\">\u2014<em>end example</em> ] or, <strong>if not that</strong>,</p>\n<p id=\"so_16635822_16636025_4\">\u2014 <code>F1</code> is a non-template function and <code>F2</code> is a function template specialization, or, if not that,</p>\n<p id=\"so_16635822_16636025_5\">[...]</p>\n</blockquote>\n<p>As you can see the, fact that the first conversion operator is a template only becomes relevant when the standard conversion sequence from its return type (<code>char</code>, in this case) to the destination type (<code>char</code>, in this case) is <strong>not</strong> better than the standard conversion sequence from the return type of the non-template overload (<code>int</code>, in this case) to the destination type (<code>char</code>, in this case).</p>\n<p>However, a standard conversion from <code>char</code> to <code>char</code> is an <em>Exact Match</em>, while a standard conversion from <code>int</code> to <code>char</code> is not. Therefore, the third item of \u00a7 13.3.3/1 does not apply, and the second item does.</p>\n<p>This means that <strong>the first (template) overload should be picked</strong>.</p>\n", "LastActivityDate": "2013-05-19T14:59:18.853", "CommentCount": "2", "CreationDate": "2013-05-19T14:59:18.853", "ParentId": "16635822", "Score": "9", "OwnerUserId": "1932150"}, "16635822": {"ViewCount": "204", "Body": "<p>The following C++ program compiles without warnings in all compilers I have tried (gcc 4.6.3, llvm 3.0, icc 13.1.1, SolarisStudio 12.1/12.3):</p>\n<pre><code>struct CClass\n{\n  template&lt;class T&gt;\n  operator T() const { return 1; }\n\n  operator int() const { return 2; }\n};\n\nint main(void)\n{\n  CClass x;\n  return static_cast&lt;char&gt;(x);\n}\n</code></pre>\n<p><em>However, all but the SolarisStudio compilers return 2, SolarisStudio (either version) returns 1, which I would consider the most logical result.</em> </p>\n<p>Using <code>return x.operator char();</code> results in all compilers returning 1.</p>\n<p>Obviously, since figuring this out, I have been using the latter notation. However, I would like to know which of compilers is correct and why. (One would think that majority rules, but this still doesn't explain the <em>why</em>.)</p>\n<p>This question seems to be related to the SO questions <a href=\"https://stackoverflow.com/questions/1116654/function-template-with-an-operator\">here</a>, <a href=\"https://stackoverflow.com/questions/12892774/conversion-operator-overloading-ambiguity-compilers-differ\">here</a>, and <a href=\"https://stackoverflow.com/questions/7741531/conversion-operator-template-specialization\">here</a>, but these \"only\" give solutions to problems, no explanations (that I was able to apply to my particular problem anyway).</p>\n<p>Note that adding an additional overloaded casting operator, say <code>operator float() const { return 3; }</code> results in all compilers except SolarisStudio complaining about ambiguity.</p>\n", "AcceptedAnswerId": "16636025", "Title": "Different casting operators used by different compilers", "CreationDate": "2013-05-19T14:37:00.360", "Id": "16635822", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:18:52.563", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-19T15:14:32.463", "Score": "14", "OwnerUserId": "2398989", "Tags": "<c++><templates><casting><operator-overloading><overload-resolution>", "AnswerCount": "2"}});