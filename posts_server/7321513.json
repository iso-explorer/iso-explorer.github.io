post_cb({"7321513": {"CommentCount": "4", "AcceptedAnswerId": "7321802", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-09-06T14:27:06.550", "LastActivityDate": "2011-09-06T15:08:22.013", "LastEditDate": "2017-05-23T12:00:46.550", "ViewCount": "3583", "FavoriteCount": "4", "Title": "Do I understand C/C++ strict-aliasing correctly?", "Id": "7321513", "Score": "6", "Body": "<p>I've read <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow noreferrer\">this article about C/C++ strict aliasing</a>. I think the same applies to C++. </p>\n<p>As I understand, strict aliasing is used to rearrange the code for performance optimization. That's why two pointers of different (and unrelated in C++ case) types cannot refer to the same memory location. </p>\n<p>Does this mean that problems can occur only if memory is modified? Apart of possible problems <a href=\"https://stackoverflow.com/questions/7320766/where-can-i-find-documentation-on-c-memory-alignment-across-different-platforms\">with memory alignment</a>.</p>\n<p>For example, handling network protocol, or de-serialization. I have a byte array, dynamically allocated and packet struct is properly aligned. Can I <code>reinterpret_cast</code> it to my packet struct? </p>\n<pre><code>char const* buf = ...; // dynamically allocated\nunsigned int i = *reinterpret_cast&lt;unsigned int*&gt;(buf + shift); // [shift] satisfies alignment requirements\n</code></pre>\n", "Tags": "<c++><c><strict-aliasing>", "OwnerUserId": "453271", "AnswerCount": "2"}, "7321802": {"ParentId": "7321513", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The problem here is not strict aliasing so much as structure representation requirements.</p>\n<p>First, it is safe to alias between <code>char</code>, <code>signed char</code>, or <code>unsigned char</code> and <em>any one</em> other type (in your case, <code>unsigned int</code>. This allows you to write your own memory-copy loops, as long as they're defined using a <code>char</code> type. This is authorized by the following language in C99 (\u00a76.5):</p>\n<blockquote>\n<p id=\"so_7321513_7321802_0\">\u00a06. The effective type of an object for an access to its stored value is the declared type of the object, if any. [Footnote: Allocated objects have no declared type] [...] If a value is copied into an object having no declared type using\n  memcpy or memmove, or is copied as an array of character type, then the effective type\n  of the modified object for that access and for subsequent accesses that do not modify the\n  value is the effective type of the object from which the value is copied, if it has one. For\n  all other accesses to an object having no declared type, the effective type of the object is\n  simply the type of the lvalue used for the access.</p>\n<p id=\"so_7321513_7321802_1\">\u00a07. An object shall have its stored value accessed only by an lvalue expression that has one of the following types: [Footnote: The intent of this list is to specify those circumstances in which an object may or may not be aliased.]</p>\n<ul>\n<li>a type compatible with the effective type of the object,</li>\n<li>[...]</li>\n<li>a character type.</li>\n</ul>\n</blockquote>\n<p>Similar language can be found in the C++0x draft N3242 \u00a73.11/10, although it is not as clear when the 'dynamic type' of an object is assigned (I'd appreciate any further references on what the dynamic type is of a char array, to which a POD object has been copied as a char array with proper alignment).</p>\n<p>As such, aliasing is not a problem here. However, a strict reading of the standard indicates that a C++ implementation has a great deal of freedom in choosing a representation of an <code>unsigned int</code>. </p>\n<p>As one random example, <code>unsigned int</code>s might be a 24-bit integer, represented in four bytes, with 8 padding bits interspersed; if any of these padding bits does not match a certain (constant) pattern, it is viewed as a trap representation, and dereferencing the pointer will result in a crash. Is this a likely implementation? Perhaps not. But there have been, historically, systems with parity bits and other oddness, and so directly reading from the network into an <code>unsigned int</code>, <em>by a strict reading of the standard</em>, is not kosher.</p>\n<p>Now, the problem of padding bits is mostly a theoretical issue on most systems today, but it's worth noting. If you plan to stick to PC hardware, you don't really need to worry about it (but don't forget your <code>ntohl</code>s - endianness is still a problem!)</p>\n<p>Structures make it even worse, of course - alignment representations depend on your platform. I have worked on an embedded platform in which all types have an alignment of 1 - no padding is <em>ever</em> inserted into structures. This can result in inconsistencies when using the same structure definitions on multiple platforms. You can either manually work out the byte offsets for data structure members and reference them directly, or use a compiler-specific alignment directive to control padding.</p>\n<p>So you must be careful when directly casting from a network buffer to native types or structures. But the aliasing itself is not a problem in this case.</p>\n", "OwnerUserId": "36723", "LastEditorUserId": "36723", "LastEditDate": "2011-09-06T15:08:22.013", "Id": "7321802", "Score": "7", "CreationDate": "2011-09-06T14:48:29.723", "LastActivityDate": "2011-09-06T15:08:22.013"}, "7321815": {"ParentId": "7321513", "CommentCount": "3", "Body": "<p>Actually this code already has UB at the point you dereference the <code>reinterpret_cast</code>ed integer pointer without even needing to invoke strict-aliasing rules. Not only that, but if you aren't rather careful, reinterpreting directly to your packet structure could cause all sorts of issues depending on struct packing and endianness.</p>\n<p>Given all that, and that you're already invoking UB I suspect that it's \"likely to work\" on multiple compilers and you're free to take that (possibly measurable) risk.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "7321815", "Score": "0", "CreationDate": "2011-09-06T14:49:04.663", "LastActivityDate": "2011-09-06T14:49:04.663"}, "bq_ids": {"n4140": {"so_7321513_7321802_1": {"section_id": 7239, "quality": 0.6363636363636364, "length": 14}}, "n3337": {"so_7321513_7321802_1": {"section_id": 6983, "quality": 0.6363636363636364, "length": 14}}, "n4659": {"so_7321513_7321802_1": {"section_id": 8748, "quality": 0.6363636363636364, "length": 14}}}});