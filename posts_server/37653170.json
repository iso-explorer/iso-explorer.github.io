post_cb({"37653674": {"ParentId": "37653170", "LastEditDate": "2016-06-06T09:31:53.570", "CommentCount": "0", "CreationDate": "2016-06-06T09:17:50.397", "OwnerUserId": "4932834", "LastEditorUserId": "4932834", "PostTypeId": "2", "Id": "37653674", "Score": "6", "Body": "<p>N3337 10.3/9</p>\n<blockquote>\n<p id=\"so_37653170_37653674_0\">[ Note: The interpretation of the call of a virtual function <strong>depends on the type of the object for which it is\n  called</strong> (<strong>the dynamic type)</strong>, whereas the interpretation of a call of a non-virtual member function depends\n  only on the type of the pointer or reference denoting that object (the static type) (5.2.2). \u2014 end note ]</p>\n</blockquote>\n<p>The dynamic type is type to which pointer <em>really</em> points, not type that was <em>declared</em> as pointed type.</p>\n<p>Therefore:</p>\n<pre><code>D d;\nd.g(); //this results in C::g as expected\n</code></pre>\n<p>is same as:</p>\n<pre><code>B* b = new D;\nb-&gt;g();\n</code></pre>\n<p>And because inside your <code>B::f</code> call to <code>g()</code> is (<em>implicitly</em>) called on <code>this</code> pointer whose <em>dynamic type</em> is <code>D</code>, call resolves to <code>D::f</code>, which is <code>C::f</code>. </p>\n<p>If you look closely, it's the (<em>exactly</em>) same behaviour as shown in code above, only that <code>b</code> is now <em>implicit</em> <code>this</code> instead.</p>\n<p>That's the whole point of virtual functions.</p>\n", "LastActivityDate": "2016-06-06T09:31:53.570"}, "37653170": {"CommentCount": "12", "ViewCount": "435", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2016-06-06T08:51:03.303", "LastActivityDate": "2016-06-11T08:42:00.057", "Title": "Calling a function of sister class C++", "AcceptedAnswerId": "37653674", "LastEditDate": "2016-06-11T00:54:37.120", "Id": "37653170", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    virtual void f() = 0;\n    virtual void g() = 0;\n};\n\nclass B : virtual public A\n{\npublic:\n    virtual void f()\n    {\n        g();\n    }\n};\n\nclass C : virtual public A\n{\npublic:\n    virtual void g()\n    {\n        std::cout &lt;&lt; \"C::g\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public C, public B\n{\n};\n\nint main()\n{\n    B* b = new D;\n    b-&gt;f();\n}\n</code></pre>\n<p>The output of the following program is <code>C::g</code>.</p>\n<p>How does the compiler invoke a function of a sister class of class B??</p>\n", "Tags": "<c++><inheritance><multiple-inheritance><override><virtual-inheritance>", "OwnerUserId": "1856429", "AnswerCount": "4"}, "37653436": {"ParentId": "37653170", "CommentCount": "0", "Body": "<p><code>g</code> is resolved at runtime, like all virtual functions. Because of the way <code>D</code> is defined it's resolved into whatever C implements.</p>\n<p>If you don't want this behaviour you should either call a non-virtual implementation of <code>g</code> (you can delegate to that function from the virtual one as well), or explicitly call <code>B</code>'s implementation using <code>B::g()</code>.</p>\n<p>Though if you do this your design will be a lot more complicated than it probably needs to be so try to find a solution that doesn't rely on all these tricks.</p>\n", "OwnerUserId": "241013", "PostTypeId": "2", "Id": "37653436", "Score": "1", "CreationDate": "2016-06-06T09:05:39.110", "LastActivityDate": "2016-06-06T09:05:39.110"}, "37653312": {"ParentId": "37653170", "CommentCount": "0", "Body": "<p>It's the behavior of <code>virtual</code>: <code>B</code> call <code>g</code> through <code>f</code> but <code>g</code> is resolve at runtime (like <code>f</code>). So, at runtime, the only available override of <code>g</code> for <code>D</code> is the one implemented in <code>C</code></p>\n", "OwnerUserId": "3932569", "PostTypeId": "2", "Id": "37653312", "Score": "2", "CreationDate": "2016-06-06T08:59:30.427", "LastActivityDate": "2016-06-06T08:59:30.427"}, "37653612": {"ParentId": "37653170", "LastEditDate": "2016-06-11T08:42:00.057", "CommentCount": "1", "CreationDate": "2016-06-06T09:15:19.973", "OwnerUserId": "6255513", "LastEditorUserId": "6255513", "PostTypeId": "2", "Id": "37653612", "Score": "0", "Body": "<p>Virtual function calls are resolved at runtime, by reference to the instance's <code>VTable</code>. A distinct <code>VTable</code> exists for any virtual class (so in above each of <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code> have a <code>VTable</code>). Every runtime instance has a pointer to one of these tables, determined by its dynamic type. </p>\n<p>The <code>VTable</code> lists every virtual function in the class, mapping it to the actual function that should be called at runtime. For normal inheritance these are listed in order of declaration, so a base class can use the <code>VTable</code> of a derived class to resolve virtual functions that it declares (because the derived class, listing the functions in declaration order, will have all the base class's functions listed first in excatly the same order the base class's own <code>VTable</code>). For virtual inheritance (as above), this is slightly more complicated, but essentially the base class within the derived class still has its own <code>VTable</code> pointer that points to the relevant section inside the derived's <code>VTable</code>. </p>\n<p>In practice this means your <code>D</code> class has a <code>VTable</code> entry for <code>g</code> that points to <code>C</code>'s implementation. Even when accessed through the <code>B</code> static type it will still refer to this same <code>VTable</code> to resolve <code>g</code>.</p>\n", "LastActivityDate": "2016-06-11T08:42:00.057"}, "bq_ids": {"n4140": {"so_37653170_37653674_0": {"section_id": 7010, "quality": 0.8275862068965517, "length": 24}}, "n3337": {"so_37653170_37653674_0": {"section_id": 6756, "quality": 0.8275862068965517, "length": 24}}, "n4659": {"so_37653170_37653674_0": {"section_id": 8507, "quality": 0.8275862068965517, "length": 24}}}});