post_cb({"32134757": {"ParentId": "11928089", "LastEditDate": "2017-05-23T12:18:02.977", "CommentCount": "2", "CreationDate": "2015-08-21T07:32:18.100", "OwnerUserId": "1242873", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "32134757", "Score": "4", "Body": "<p>An update on <a href=\"https://stackoverflow.com/a/12558623/1242873\">Richard Smith's answer</a>, attempt 3 now compiles on both GCC 4.9 and 5.1, as well as clang 3.4.</p>\n<pre><code>struct Foo {\n  std::size_t v;\n  constexpr Foo() : v(){}\n  static const Foo f;\n};\n\nconstexpr const Foo Foo::f = Foo();\n\nstd::array&lt;int, Foo::f.v&gt; a;\n</code></pre>\n<p>However, when Foo is a class template, clang 3.4 fails, but GCC 4.9 and 5.1 still work ok:</p>\n<pre><code>template &lt; class T &gt;\nstruct Foo {\n  T v;\n  constexpr Foo() : v(){}\n  static const Foo f;\n};\n\ntemplate &lt; class T &gt;\nconstexpr const Foo&lt;T&gt; Foo&lt;T&gt;::f = Foo();\n\nstd::array&lt;int, Foo&lt;std::size_t&gt;::f.v&gt; a; // gcc ok, clang complains\n</code></pre>\n<p>Clang error :</p>\n<pre><code>error: non-type template argument is not a constant expression\nstd::array&lt;int, Foo&lt;std::size_t&gt;::f.v&gt; a;\n                ^~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n", "LastActivityDate": "2015-08-21T07:32:18.100"}, "11929560": {"ParentId": "11928089", "LastEditDate": "2012-08-13T07:10:02.343", "CommentCount": "3", "CreationDate": "2012-08-13T07:04:45.683", "OwnerUserId": "777186", "LastEditorUserId": "777186", "PostTypeId": "2", "Id": "11929560", "Score": "29", "Body": "<p>If I interpret the Standard correctly, it isn't possible.</p>\n<blockquote>\n<p id=\"so_11928089_11929560_0\">(\u00a79.4.2/3) [...] A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression. [...]</p>\n</blockquote>\n<p>From the above (along with the fact that there is no separate statement about non-literal types in static data member declarations), I believe it follows that a static data member that is <code>constexpr</code> must be <strong>a literal type</strong> (as defined in \u00a73.9/10), <strong>and</strong> it must have its <strong>definition included in the declaration</strong>. The latter condition could be satisfied by using the following code:</p>\n<pre><code>struct Foo {\n  constexpr Foo() {}\n  static constexpr Foo f {};\n};\n</code></pre>\n<p>which is similar to your Attempt 1, but without the class-external definition.</p>\n<p>However, since <code>Foo</code> is incomplete at the time of declaration/definition of the static member, the compiler can't check whether it is a literal type (as defined in \u00a73.9/10), so it rejects the code.</p>\n<p>Note that there is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3308.pdf\" rel=\"noreferrer\">this post-C++-11 document (N3308)</a> which discusses various problems of the current definition of <code>constexpr</code> in the Standard, and makes suggestions for amendments. Specifically, the \"Proposed Wording\" section suggests an amendment of \u00a73.9/10 that implies the inclusion of incomplete types as one kind of literal type. If that amendment was to be accepted into a future version of the Standard, your problem would be solved.</p>\n", "LastActivityDate": "2012-08-13T07:10:02.343"}, "12558623": {"ParentId": "11928089", "CommentCount": "5", "Body": "<p>I believe GCC is incorrect to reject your Attempt 3. There is no rule in the C++11 standard (or any of its accepted defect reports) which says that a redeclaration of a variable must be <code>constexpr</code> iff the prior declaration was. The closest the standard comes to that rule is in <strong>[dcl.constexpr](7.1.5)/1_</strong>:</p>\n<blockquote>\n<p id=\"so_11928089_12558623_0\">If any declaration of a function or function template has <code>constexpr</code> speci\ufb01er, then all its declarations shall contain the <code>constexpr</code> speci\ufb01er.</p>\n</blockquote>\n<p>Clang's implementation of <code>constexpr</code> accepts your Attempt 3.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "12558623", "Score": "8", "CreationDate": "2012-09-24T03:52:20.497", "LastActivityDate": "2012-09-24T03:52:20.497"}, "11928089": {"CommentCount": "0", "CreationDate": "2012-08-13T04:08:00.353", "PostTypeId": "1", "AcceptedAnswerId": "11929560", "LastEditorUserId": "777186", "LastActivityDate": "2015-08-21T07:32:18.100", "LastEditDate": "2012-08-13T07:33:16.293", "ViewCount": "3299", "FavoriteCount": "8", "Title": "static constexpr member of same type as class being defined", "Id": "11928089", "Score": "32", "Body": "<p>I would like a class C to have a static constexpr member of type C. Is this possible in C++11?</p>\n<p>Attempt 1:</p>\n<pre><code>struct Foo {\n    constexpr Foo() {}\n    static constexpr Foo f = Foo();\n};\nconstexpr Foo Foo::f;\n</code></pre>\n<p>g++ 4.7.0 says: 'invalid use of incomplete type' referring to the <code>Foo()</code> call.</p>\n<p>Attempt 2:</p>\n<pre><code>struct Foo {\n    constexpr Foo() {}\n    static constexpr Foo f;\n};\nconstexpr Foo Foo::f = Foo();\n</code></pre>\n<p>Now the problem is the lack of an initializer for the <code>constexpr</code> member <code>f</code> inside the class definition.</p>\n<p>Attempt 3:</p>\n<pre><code>struct Foo {\n    constexpr Foo() {}\n    static const Foo f;\n};\nconstexpr Foo Foo::f = Foo();\n</code></pre>\n<p>Now g++ complains about a redeclaration of <code>Foo::f</code> differing in <code>constexpr</code>.</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "1395057", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_11928089_12558623_0": {"section_id": 5417, "quality": 0.8461538461538461, "length": 11}, "so_11928089_11929560_0": {"section_id": 5908, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_11928089_12558623_0": {"section_id": 5212, "quality": 0.8461538461538461, "length": 11}, "so_11928089_11929560_0": {"section_id": 5680, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_11928089_12558623_0": {"section_id": 6839, "quality": 0.8461538461538461, "length": 11}, "so_11928089_11929560_0": {"section_id": 7390, "quality": 0.6190476190476191, "length": 13}}}});