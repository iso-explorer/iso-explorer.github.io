post_cb({"28767216": {"ParentId": "2935201", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The language linkage of the function pointer results from a conversion of a capture-less lambda was not specified in the C++11 standard but was addressed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3834.html#1557\" rel=\"nofollow\">defect report 1557</a> which says:</p>\n<blockquote>\n<p id=\"so_2935201_28767216_0\">5.1.2 [expr.prim.lambda] paragraph 6 does not specify the language linkage of the function type of the closure type's conversion function.</p>\n</blockquote>\n<p>and the resolution was that the language linkage should be C++:</p>\n<blockquote>\n<p id=\"so_2935201_28767216_1\">The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function with C++ language linkage (7.5 [dcl.link]). having the same parameter and return types as the closure type's function call operator. The value returned... </p>\n</blockquote>\n<p>we can find this language in the draft C++14 standard, since the status is <code>DRWP</code> it seems like this does not apply to C++11.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2016-01-15T17:01:19.867", "Id": "28767216", "Score": "1", "CreationDate": "2015-02-27T14:19:32.330", "LastActivityDate": "2016-01-15T17:01:19.867"}, "2935799": {"ParentId": "2935201", "CommentCount": "2", "Body": "<p>There's no particularly good reason that this shouldn't be extended to capturing lambdas. It requires some dynamic code generation, but it shouldn't be beyond the wit of compiler writers, and it would make interop with old C APIs orders of magnitude easier--no more need to pass parameters through untyped void*s (which not all APIs even offer).</p>\n", "OwnerUserId": "2131", "PostTypeId": "2", "Id": "2935799", "Score": "2", "CreationDate": "2010-05-29T16:38:29.293", "LastActivityDate": "2010-05-29T16:38:29.293"}, "2935201": {"CommentCount": "1", "AcceptedAnswerId": "2935230", "PostTypeId": "1", "LastEditorUserId": "34509", "LastEditorDisplayName": "Roger Pate", "CreationDate": "2010-05-29T13:18:00.090", "LastActivityDate": "2016-01-15T17:01:19.867", "LastEditDate": "2011-10-01T13:59:38.750", "ViewCount": "1999", "FavoriteCount": "4", "Title": "Will C++0x support __stdcall or extern \"C\" capture-nothing lambdas?", "Id": "2935201", "Score": "15", "Body": "<p>Yesterday I was thinking about whether it would be possible to use the convenience of C++0x lambda functions to write callbacks for Windows API functions.</p>\n<p>For example, what if I wanted to use a lambda as an <a href=\"http://msdn.microsoft.com/en-us/library/ms633493.aspx\" rel=\"noreferrer\"><code>EnumChildProc</code></a> with <a href=\"http://msdn.microsoft.com/en-us/library/ms633494.aspx\" rel=\"noreferrer\"><code>EnumChildWindows</code></a>? Something like:</p>\n<pre><code>EnumChildWindows(hTrayWnd, CALLBACK [](HWND hWnd, LPARAM lParam) {\n        // ...\n        return static_cast&lt;BOOL&gt;(TRUE); // continue enumerating\n    }, reinterpret_cast&lt;LPARAM&gt;(&amp;myData));\n</code></pre>\n<p>Another use would be to write <code>extern \"C\"</code> callbacks for C routines. E.g.:</p>\n<pre><code>my_class *pRes = static_cast&lt;my_class*&gt;(bsearch(&amp;key, myClassObjectsArr, myClassObjectsArr_size, sizeof(my_class), extern \"C\" [](const void *pV1, const void *pV2) {\n        const my_class&amp; o1 = *static_cast&lt;const my_class*&gt;(pV1);\n        const my_class&amp; o2 = *static_cast&lt;const my_class*&gt;(pV2);\n\n        int res;\n        // ...\n        return res;\n    }));\n</code></pre>\n<p>Is this possible?</p>\n<p>I can understand that lambdas that capture variables will never be compatible with C, but it at least seems possible to me that <em>capture-nothing</em> lambdas can be compatible.</p>\n", "Tags": "<c++><c><lambda><c++11>", "OwnerUserId": "196844", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2935201_28767216_1": {"section_id": 5965, "quality": 0.896551724137931, "length": 26}, "so_2935201_2935230_0": {"section_id": 5965, "quality": 0.925, "length": 37}, "so_2935201_28767216_0": {"section_id": 5965, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_2935201_28767216_1": {"section_id": 5734, "quality": 0.8275862068965517, "length": 24}, "so_2935201_2935230_0": {"section_id": 5734, "quality": 0.925, "length": 37}}, "n4659": {"so_2935201_28767216_1": {"section_id": 7456, "quality": 0.7586206896551724, "length": 22}, "so_2935201_2935230_0": {"section_id": 7456, "quality": 0.825, "length": 33}, "so_2935201_28767216_0": {"section_id": 7456, "quality": 0.5384615384615384, "length": 7}}}, "2935230": {"ParentId": "2935201", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Lambdas without a capture <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3052.html\" rel=\"noreferrer\">are implicitly convertible</a> to a pointer to function (by a non-explicit conversion function defined by the closure type). </p>\n<p>The FCD does not seem to specify what language linkage the function type of that function pointer type has, so if you need to pass this function pointer to C functions, the calling convention of C++ functions and C functions need to be the same. I believe that on Windows, that is the case though. So you should be able to pass the lambda to Windows API functions</p>\n<pre><code>typedef void(*callbackType)(void *userData);\nextern \"C\" void someCFunction(callbackType callback);\n\nint main() {\n  someCFunction([](void *userData) { /* ... */ });\n}\n</code></pre>\n<p>FCD wording at <code>5.1.2/6</code>:</p>\n<blockquote>\n<p id=\"so_2935201_2935230_0\">The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same e\ufb00ect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>I think the final Standard should have a note that says that there is a conversion function to both C linkage function pointers and C++ linkage function pointers, as convertibility to C function pointers is one of the goal of this functionality.</p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-05-29T13:35:19.600", "Id": "2935230", "Score": "14", "CreationDate": "2010-05-29T13:28:02.657", "LastActivityDate": "2010-05-29T13:35:19.600"}});