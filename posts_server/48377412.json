post_cb({"bq_ids": {"n4140": {"so_48377412_48379707_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_48377412_48379707_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_48377412_48379707_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "48379707": {"Id": "48379707", "PostTypeId": "2", "Body": "<p>You cannot access an <code>unsigned char</code> object value through a glvalue of an other type. But the opposite is authorized, you can access the value of any object through an <code>unsigned char</code> glvalue <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.lval#8.8\" rel=\"nofollow noreferrer\">[basic.lval]</a>:</p>\n<blockquote>\n<p id=\"so_48377412_48379707_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined: [...]</p>\n<ul>\n<li>a <code>char</code>, <code>unsigned char</code>, or <code>std\u200b::\u200bbyte</code> type. </li>\n</ul>\n</blockquote>\n<p>So, to be 100% standard compliant, the idea is to reverse the <code>reinterpret_cast</code>:</p>\n<pre><code>uint64_t i;\nstd::memcpy(&amp;i, blob.data() + 7*sizeof(uint64_t), sizeof(uint64_t));\nstd::cout &lt;&lt; i &lt;&lt; std::endl;\n</code></pre>\n<p>And it will produces the exact same <a href=\"https://godbolt.org/g/JPrQgr\" rel=\"nofollow noreferrer\">assembly</a>.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-22T13:51:04.243", "Score": "6", "CreationDate": "2018-01-22T10:43:26.733", "ParentId": "48377412", "CommentCount": "7", "OwnerUserId": "5632316", "LastEditDate": "2018-01-22T13:51:04.243"}, "48377412": {"ViewCount": "227", "Body": "<p>Suppose we take a very big array of <code>unsigned char</code>s.</p>\n<pre><code>std::array&lt;uint8_t, 100500&gt; blob;\n// ... fill array ...\n</code></pre>\n<p>(Note: it is aligned already, question is not about alignment.)\nThen we take it as <code>uint64_t[]</code> and trying to access it:</p>\n<pre><code>const auto ptr = reinterpret_cast&lt;const uint64_t*&gt;(blob.data());\nstd::cout &lt;&lt; ptr[7] &lt;&lt; std::endl;\n</code></pre>\n<p>Casting to <code>uint64_t</code> and then reading from it looks suspicious as for me.</p>\n<p>But UBsan, <code>-Wstrict-aliasing</code> is not triggering about it.\nGoogle uses this technique in <a href=\"https://github.com/google/flatbuffers/blob/master/include/flatbuffers/flatbuffers.h#L67\" rel=\"nofollow noreferrer\">FlatBuffers</a>.\nAlso, Cap'n'Proto uses this <a href=\"https://github.com/capnproto/capnproto/blob/master/c%2B%2B/src/capnp/layout.h#L1218\" rel=\"nofollow noreferrer\">too</a>.</p>\n<p>Is it undefined behavior?</p>\n", "AcceptedAnswerId": "48379707", "Title": "reinterpret_cast unsigned char* as uint64_t* - is this UB?", "CreationDate": "2018-01-22T08:32:15.637", "LastActivityDate": "2018-01-22T13:51:04.243", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-22T09:04:39.433", "LastEditorUserId": "1555823", "Id": "48377412", "Score": "5", "OwnerUserId": "1555823", "Tags": "<c++><undefined-behavior>", "AnswerCount": "2"}, "48379712": {"Id": "48379712", "PostTypeId": "2", "Body": "<p>The cast itself is well defined (a <code>reinterpret_cast</code> never has UB), but the lvalue to rvalue conversion in expression \"<code>ptr[7]</code>\" would be UB if no <code>uint64_t</code> object has been constructed in that address.</p>\n<p>As \"<code>// ... fill array ...</code>\" is not shown, there could have been constructed a <code>uint64_t</code> object in that address (assuming as you say, the address has sufficient alignment):</p>\n<pre><code>const uint64_t* p = new (blob.data() + 7 * sizeof(uint64_t)) uint64_t();\n</code></pre>\n<p>If a <code>uint64_t</code> object has been constructed in that address, then the code in question has well defined behaviour.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2018-01-22T11:51:58.050", "Score": "1", "CreationDate": "2018-01-22T10:43:41.740", "ParentId": "48377412", "CommentCount": "23", "OwnerUserId": "2079303", "LastEditDate": "2018-01-22T11:51:58.050"}});