post_cb({"32990334": {"Id": "32990334", "PostTypeId": "2", "LastEditDate": "2015-10-08T07:45:55.220", "CommentCount": "11", "LastEditorUserId": "2020827", "LastActivityDate": "2015-10-08T07:45:55.220", "CreationDate": "2015-10-07T10:52:37.773", "ParentId": "32990177", "Score": "2", "Body": "<blockquote>\n<p id=\"so_32990177_32990334_0\">Will there be any problem in executing the program...</p>\n</blockquote>\n<p>It can happen (and, as Murphy said:\n<em>\"if anything can go wrong it will go wrong\"</em>).</p>\n<h3>Rational</h3>\n<p>Incrementing is <em>not atomic</em>, usually it is implemented using the following three basic operations:</p>\n<ol>\n<li>read the value from memory</li>\n<li>add 1 to the value</li>\n<li>write the value back to memory</li>\n</ol>\n<p>Note: <code>printf()</code> isn't atomic too.</p>\n<p>A context switch between threads might occur at any time,\nduring <code>n++</code>, during <code>printf()</code> or between those two operations.\nA race condition can occur during context switching,\nif the access to <code>n</code> is not synchronized.</p>\n<h3>Example</h3>\n<p>Consider the following scenario:</p>\n<ol>\n<li>thread 1 reads the value (value is 10)</li>\n<li>thread 2 reads the value (value is 10)</li>\n<li>thread 1 adds a 1 to the value</li>\n<li>thread 1 writes the value to memory (value is 11)</li>\n<li>thread 2 adds a 1 to the value</li>\n<li>thread 2 writes the value to memory (value is still 11)</li>\n</ol>\n<p>You would expect the value to be 12, but it is 11. </p>\n<h3>Conclusion</h3>\n<p><code>n</code> is a shared resource.</p>\n<p>Concurrent (read write) access to shared resources has to be synchronized!</p>\n", "OwnerUserId": "2020827"}, "bq_ids": {"n4140": {"so_32990177_32990225_0": {"length": 31, "quality": 0.6458333333333334, "section_id": 5834}}, "n4659": {"so_32990177_32990225_0": {"length": 32, "quality": 0.6666666666666666, "section_id": 7296}}}, "32990225": {"Id": "32990225", "PostTypeId": "2", "LastEditDate": "2015-10-07T13:56:37.753", "CommentCount": "7", "LastEditorUserId": "981959", "LastActivityDate": "2015-10-07T13:56:37.753", "CreationDate": "2015-10-07T10:46:47.540", "ParentId": "32990177", "Score": "7", "Body": "<p>The C++ standard says this program has undefined behaviour, anything can happen. <strong>Anything</strong>, including printing the same number repeatedly, not printing anything, crashing the program, or wiping your hard disk.</p>\n<p>1.10 [intro.multithread]</p>\n<blockquote>\n<p id=\"so_32990177_32990225_0\">Two expression evaluations conflict if one of them modifies a memory location (1.7) and the other one reads or modifies the same memory location.<br>\n  ...<br>\n  The execution of a program contains a data race if it contains two potentially concurrent conflicting actions, at least one of which is not atomic, and neither happens before the other, except for the special case for signal handlers described below. Any such data race results in undefined behavior.</br></br></p>\n</blockquote>\n<p>You should use <code>std::atomic&lt;int&gt;</code> for a variable concurrently modified by multiple threads, or synchronise with a mutex, to avoid undefined behaviour due to data races.</p>\n<p>For your use case you need to ensure that every time the variable is updated you print its value, i.e. <em>the increment and the print</em> must happen atomically. Simply updating the integer atomically is not sufficient, you must ensure the result of that increment is printed, rather than printing the value of the variable at some later time (when the other thread might have already changed it, as shown in Rotem's answer).</p>\n<p>That could be done like so:</p>\n<pre><code>std::atomic&lt;int&gt; n{0}; // global variable\n</code></pre>\n<p>Thread 1:</p>\n<pre><code>printf(\"%d\", ++n);\n</code></pre>\n<p>Thread 2:</p>\n<pre><code>printf(\"%d\", ++n);\n</code></pre>\n<p>Now every time a thread increments the variable the result of that increment will be passed straight to <code>printf</code>.</p>\n<p>This assumes that writing to <code>stdout</code> is thread-safe and happens in order, to avoid  that assumption use a mutex to create a critical section that updates the variable and prints it, preventing the other thread from either incrementing the variable or printing while the mutex is locked:</p>\n<pre><code>int n = 0 //global variable\nstd::mutex mtx; // global mutex\n</code></pre>\n<p>Thread 1:</p>\n<pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lock(mtx);\n  ++n;\n  printf(\"%d\", n);\n}\n</code></pre>\n<p>Thread 2:</p>\n<pre><code>{\n  std::lock_guard&lt;std::mutex&gt; lock(mtx);\n  ++n;\n  printf(\"%d\", n);\n}\n</code></pre>\n<p>N.B. there is still no guarantee that the two threads will alternate incrementing and printing, it is entirely possible that the first thread will perform ten increments and print the entire output, without the second thread ever getting a chance to run.</p>\n", "OwnerUserId": "981959"}, "32990177": {"ViewCount": "161", "LastEditDate": "2015-10-07T10:49:55.703", "Title": "C++ multithreading without synchronization", "CreationDate": "2015-10-07T10:44:48.940", "LastActivityDate": "2015-10-08T07:45:55.220", "CommentCount": "2", "Body": "<p>C++ : I have 2 threads, each one increments 'n' by doing n++ (n being the global variable) Assuming i am not using any thread synchronization, my requirement is to print 0,1,2,....10.</p>\n<pre><code>int n = 0 //global variable\n</code></pre>\n<p>thread 1:</p>\n<pre><code>n++;\nprintf(\"%d\", n);\n</code></pre>\n<p>thread 2:</p>\n<pre><code>n++;\nprintf(\"%d\", n);\n</code></pre>\n<p>Will there be any problem in executing the program without thread synchronization, or it will fulfill my requirement (1,2,3...10).</p>\n", "PostTypeId": "1", "LastEditorUserId": "4460500", "Id": "32990177", "Score": "1", "OwnerUserId": "3296363", "Tags": "<c++><multithreading>", "AnswerCount": "2"}});