post_cb({"23930395": {"ParentId": "23930319", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>What part of <strong>Run-Time</strong> Type Identification do you think works at compile-time?  The rules for constant expressions disallow:</p>\n<blockquote>\n<p id=\"so_23930319_23930395_0\">\u2014 a <code>typeid</code> expression (5.2.8) whose operand is a glvalue of a polymorphic class type;</p>\n</blockquote>\n<p>so your template would only work for some types.</p>\n<p>And with RTTI turned off you can't use <code>typeid</code> at all.</p>\n<p>C++11 already provides a mechanism to hash a type:</p>\n<pre><code>return ::std::hash&lt;::std::type_index&gt;()(::std::type_index(typeid(T)));\n</code></pre>\n<p>But it's not going to be a constant expression for all types.</p>\n<p>You could use the <code>type_index</code> of a pointer to each type, as a pointer is not a polymorphic class type and will still give a unique type:</p>\n<pre><code>return ::std::hash&lt;::std::type_index&gt;()(::std::type_index(typeid(T*)));\n</code></pre>\n<p>Now the problem is \"only\" that the <code>type_index</code> constructor is not <code>constexpr</code> and neither is the hash function.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2014-05-29T09:52:08.483", "Id": "23930395", "Score": "4", "CreationDate": "2014-05-29T09:46:14.670", "LastActivityDate": "2014-05-29T09:52:08.483"}, "29288244": {"ParentId": "23930319", "CommentCount": "0", "Body": "<p>typeid(<em>type-id</em>) and typeid(<em>expr</em>) can both be used in constant expressions, except if (as has been mentioned) <em>expr</em>'s result is a glvalue of polymorphic class type.</p>\n<p>However, since none of <code>type_info</code>'s standard members are <code>constexpr</code> (including the <code>hash_code()</code> method), you cannot do anything with that object except take its address. There's not even a guarantee in the standard that the object is initialized. And even taking the address is only barely useful because there is no guarantee that typeid() has the same result when used with the same type. E.g. the following assertion may fail:</p>\n<pre><code>static_assert(&amp;typeid(int) == &amp;typeid(int), \"Multiple type_infos for int\");\n</code></pre>\n<p>This is a contrived example, but it's not unheard of that <code>typeid(T)</code> yields different results for the same <code>T</code> in multiple shared libraries used in a program, and possibly even in different translation units.</p>\n", "OwnerUserId": "4083309", "PostTypeId": "2", "Id": "29288244", "Score": "5", "CreationDate": "2015-03-26T20:30:21.177", "LastActivityDate": "2015-03-26T20:30:21.177"}, "23930319": {"CommentCount": "0", "ViewCount": "1006", "PostTypeId": "1", "LastEditorUserId": "1095108", "CreationDate": "2014-05-29T09:42:14.637", "LastActivityDate": "2015-03-26T20:30:21.177", "Title": "constexpr and RTTI", "AcceptedAnswerId": "23930395", "LastEditDate": "2014-05-29T10:22:33.817", "Id": "23930319", "Score": "2", "Body": "<p>I'd like to do something like this:</p>\n<pre><code>template &lt;typename T&gt;\nconstexpr ::std::size_t type_name_hash()\n{\n  return ::std::hash&lt;::std::string&gt;()(typeid(T).name());\n}\n</code></pre>\n<p>Now, I know neither <code>hash</code> nor <code>string</code> are <code>constexpr</code>, but this could be worked around, assume they are <code>constexpr</code>. What I want to ask is, if <code>RTTI</code> was turned on, should a <code>constexpr</code> function computing a hash of <code>typeid(T).name()</code> still produce a compile-time constant? How about when <code>RTTI</code>  is turned off?</p>\n", "Tags": "<c++11><constexpr>", "OwnerUserId": "1095108", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23930319_23930395_0": {"section_id": 6185, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_23930319_23930395_0": {"section_id": 5946, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_23930319_23930395_0": {"section_id": 7687, "quality": 0.8888888888888888, "length": 8}}}});