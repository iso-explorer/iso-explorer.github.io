post_cb({"27471684": {"FavoriteCount": "3", "ViewCount": "636", "Id": "27471684", "AcceptedAnswerId": "27472839", "Score": "11", "Title": "Are C++11 stateful allocators interchangeable across type boundaries?", "LastEditorUserId": "-1", "CommentCount": "3", "Body": "<p>My question here is basically a follow up to :</p>\n<p><strong><a href=\"https://stackoverflow.com/questions/24278803/how-can-i-write-a-stateful-allocator-in-c11-given-requirements-on-copy-constr?rq=1\">How can I write a stateful allocator in C++11, given requirements on copy construction?</a></strong></p>\n<p>Basically, despite the fact that the C++11 standard now allows for stateful allocators, we still have the requirement that if you copy a certain <code>Allocator</code>, the copy must compare equal via the <code>==</code> operator with the original.  This indicates that the copy can safely <em>deallocate</em> memory which was allocated by the original, and vice-versa.</p>\n<p>So, right off the bat this already prohibits an allocator from maintaining unique internal state, like a slab-allocator or memory pool or something.  One solution would be to use a <code>shared_ptr</code> pointer-to-implementation idiom for the internal state, so that all copies of some original <code>Allocator</code> use the same underlying memory pool.  That's not too bad.  Except...</p>\n<p>According to the above referenced question, as well as the accepted answer, the standard <em>also</em> seems to require that <code>Allocator&lt;T&gt;</code> has an interoperable copy constructor with <code>Allocator&lt;U&gt;</code>, so that:</p>\n<pre><code>Allocator&lt;T&gt; alloc1;\nAllocator&lt;U&gt; alloc2(alloc1);\nassert(alloc1 == alloc2); // must hold true\n</code></pre>\n<p>So in other words, allocator types must be <em>interoperable</em> regardless of different template parameters.  That means if I allocate some memory using <code>Allocator&lt;T&gt;</code>, I must be able to deallocate that memory using an <code>Allocator&lt;U&gt;</code> instance constructed from the original <code>Allocator&lt;T&gt;</code>.</p>\n<p>...and that's pretty much a show-stopper for any attempt to write an allocator that uses some sort of size-based memory pool, like a simple_segregated_storage pool that only returns chunks of a certain size based on <code>sizeof(T)</code>.  </p>\n<p>But... is this really true?</p>\n<p>I realize the interoperable copy constructor is required for <code>Allocator&lt;T&gt;::rebind</code> so users of containers don't need to know the internal details of say, a linked-list node type or something.  But as far as I can see, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow noreferrer\"><strong>standard itself</strong></a> doesn't seem to say anything so draconian as the requirement that an <code>Allocator&lt;U&gt;</code> constructed from an <code>Allocator&lt;T&gt;</code> must compare equal with the original <code>Allocator&lt;T&gt;</code> instance.</p>\n<p>The standard basically requires the following semantics, where <strong>X</strong> is a type <code>Allocator&lt;T&gt;</code>, <strong>a1</strong> and <strong>a2</strong> are instances of <strong>X</strong>, <strong>Y</strong> is a type <code>Allocator&lt;U&gt;</code>, and <strong>b</strong> is an instance of <code>Allocator&lt;U&gt;</code>.</p>\n<p>From: <strong>\u00a7 17.6.3.5</strong> (Allocator requirements)</p>\n<pre><code>a1 == a2 returns true only if storage allocated from each can be deallocated via the other.\n\noperator == shall be reflexive, symmetric, and transitive, and shall not exit via an exception.\n\na1 != a2 : same as !(a1 == a2)\n\na == b : same as a == Y::rebind&lt;T&gt;::other(b)\n\na != b : same as !(a == b)\n\nX a1(a); Shall not exit via an exception. post: a1 == a\n\nX a(b); Shall not exit via an exception. post: Y(a) == b, a == X(b)\n</code></pre>\n<p><br/></p>\n<p>So, the way I read this, instances of <code>Allocator&lt;T&gt;</code> constructed from <code>Allocator&lt;U&gt;</code> are <em>not</em> necessarily interchangeable.  The standard merely requires that <code>a == b</code> must be equivalent to <code>Y(a) == b</code>, \u00a0<strong><em>not</em></strong> that <code>a == b</code> must be <em>true</em>! </p>\n<p>I think the requirement for the cross-type-boundary copy constructor makes this confusing.  But, the way I read this, if I have an <code>Allocator&lt;T&gt;</code>, it must have a copy constructor that takes an <code>Allocator&lt;U&gt;</code>, but that <em>doesn't</em> imply that:</p>\n<pre><code>Allocator&lt;T&gt; alloc1;\nAllocator&lt;U&gt; alloc2(alloc1);\nassert(alloc2 == alloc1); \n</code></pre>\n<p>In other words, the way I read this, the above assertion is allowed to fail.  But I'm not confident in my understanding here, because:</p>\n<ol>\n<li><p>The <a href=\"https://stackoverflow.com/questions/24278803/how-can-i-write-a-stateful-allocator-in-c11-given-requirements-on-copy-constr\">accepted answer to this question</a> says otherwise, and the answerer is a guy with 108K reputation</p></li>\n<li><p>The interaction between copy constructor requirements and equality requirements in the standard is a bit confusing, and I may be misunderstanding the verbiage.</p></li>\n</ol>\n<p>So, I am I correct here?  (Incidentally, the implementation of <a href=\"http://www.boost.org/doc/libs/1_53_0/libs/pool/doc/html/boost_pool/pool/interfaces.html\" rel=\"nofollow noreferrer\"><code>boost::pool_allocator</code></a> seems to imply I am correct, assuming the boost developer cares about standards compliance, since this allocator is not interchangeable accross type boundaries.)</p>\n", "Tags": "<c++><c++11><allocator>", "CreationDate": "2014-12-14T16:59:37.197", "LastEditDate": "2017-05-23T12:09:05.820", "LastActivityDate": "2014-12-14T18:55:11.860", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "2923952"}, "bq_ids": {"n4140": {"so_27471684_27472839_0": {"length": 4, "quality": 0.8, "section_id": 716}}, "n3337": {"so_27471684_27472839_0": {"length": 4, "quality": 0.8, "section_id": 705}}}, "27472839": {"CommentCount": "0", "Body": "<p>The last line that you quote:</p>\n<blockquote>\n<p id=\"so_27471684_27472839_0\"><code>X a(b)</code>; Shall not exit via an exception. post: <code>Y(a) == b</code>, <code>a == X(b)</code></p>\n</blockquote>\n<p>Conflicts with your conclusion.</p>\n<pre><code>using X = Allocator&lt;T&gt;;\nusing Y = Allocator&lt;U&gt;;\nY b;\nX a(b);\nassert(Y(a) == b);\nassert(a == X(b));\n// therefore\nassert(a == b);\n</code></pre>\n", "CreationDate": "2014-12-14T18:55:11.860", "ParentId": "27471684", "Id": "27472839", "LastActivityDate": "2014-12-14T18:55:11.860", "PostTypeId": "2", "Score": "3", "OwnerUserId": "576911"}});