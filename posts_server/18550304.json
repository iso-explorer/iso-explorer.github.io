post_cb({"bq_ids": {"n4140": {"so_18550304_18550460_0": {"length": 15, "quality": 0.9375, "section_id": 6109}}, "n3337": {"so_18550304_18550460_0": {"length": 15, "quality": 0.9375, "section_id": 5875}}, "n4659": {"so_18550304_18550460_0": {"length": 15, "quality": 0.9375, "section_id": 7606}}}, "18550460": {"Id": "18550460", "PostTypeId": "2", "Body": "<p>Yep, that's what the (draft) standard says (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">\u00a75.3.5.5</a>);</p>\n<blockquote>\n<p id=\"so_18550304_18550460_0\">If the object being deleted has incomplete class type at the point of deletion and the complete class has a\n  non-trivial destructor or a deallocation function, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p>(a non trivial destructor being one you defined yourself)</p>\n<p>To fix it, just <code>#include \"Character.h\"</code> in <code>header.cpp</code> before invoking <code>delete</code> to allow the type to be completely declared.</p>\n", "LastActivityDate": "2013-08-31T16:49:02.283", "CommentCount": "2", "CreationDate": "2013-08-31T16:49:02.283", "ParentId": "18550304", "Score": "1", "OwnerUserId": "477878"}, "18550304": {"ViewCount": "2310", "Body": "<p>Two of my classes had to include each other. I made forward declarations instead, compilation is ok. One function of these classes is to call the destructor of the other. And that the compiler spits warnings at me, the destructor will not be called. What can I do? I can avoid this problem by creating another class for the function I need, avoiding the forward declarations but that would not be educative for me...</p>\n<p>Here is my first class Header.h :</p>\n<pre><code>#ifndef H_HEADER\n#define H_HEADER\n\n#include \"SDL/SDL.h\"\n#include \"SDL/SDL_image.h\"\n#include \"SDL/SDL_ttf.h\"\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;vector&gt;\n#include &lt;sstream&gt;\n#include \"DataFiles.h\"\n\nclass Character; // forward declaration  Header &lt;-&gt; Character\n\nclass Header {\n\nprivate:\n Character * ch; \n};\n\nvoid cleanUp(std::vector &lt;SDL_Surface*&gt; &amp; Vsurface, std::vector &lt;TTF_Font*&gt; &amp; Vfont, std::vector &lt;Character*&gt; &amp; Vchar);\n\n// ... Other functions use in main.cpp\n\n#endif\n</code></pre>\n<p>HEre is the Header.cpp:</p>\n<pre><code>#include \"Header.h\"\nusing namespace std;\n\n\nvoid cleanUp(vector &lt;SDL_Surface*&gt; &amp; Vsurface, vector &lt;TTF_Font*&gt; &amp; Vfont, vector &lt;Character*&gt; &amp; Vchar) {\n\n for(unsigned int i(0); i &lt; Vsurface.size(); i++) \n  SDL_FreeSurface(Vsurface[i]);\n for(unsigned int i(0); i &lt; Vfont.size(); i++)\n  TTF_CloseFont(Vfont[i]);\n for(unsigned int i(0); i &lt; Vchar.size(); i++)\n  delete Vchar[i];\n\n TTF_Quit();\n SDL_Quit();\n\n}\n</code></pre>\n<p>And here is the other Character.h class:</p>\n<pre><code>#ifndef H_CHARACTER\n#define H_CHARACTER\n\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include &lt;/usr/include/SDL/SDL_image.h&gt;\n#include &lt;/usr/include/SDL/SDL.h&gt;\n#include &lt;/usr/include/SDL/SDL_ttf.h&gt;\n\n#include \"DataFiles.h\"\n#include \"CharFrame.h\"\n\nclass Header; // Forward declaration  Header &lt;-&gt; Character\n\nclass Character {\n\npublic:\n Character(std::string&amp; dataPath);\n ~Character();\n // .. other functions \n\nprivate:\n\n Header * h;\n // ... other attributes\n};\n#endif\n</code></pre>\n<p>And here is my Character destructor:</p>\n<pre><code>Character::~Character() {\n\n cout &lt;&lt; \"Character \" &lt;&lt; m_name &lt;&lt; \" deleted.\\n-----------------------------------\\n\" &lt;&lt; endl;\n\n}\n</code></pre>\n<p>So when my program ends, I call upon the Header's function \"cleanUp()\" giving it a vector of pointers to Characters. Every pointer should then be deleted through the Character's destructor ~Character();\nHowever compilation gives me three warnings:</p>\n<pre><code>Header.cpp: In function \u2018void cleanUp(std::vector&lt;SDL_Surface*&gt;&amp;, std::vector&lt;_TTF_Font*&gt;&amp;, std::vector&lt;Character*&gt;&amp;)\u2019:\nHeader.cpp:66:17: warning: possible problem detected in invocation of delete operator: [enabled by default]\nHeader.cpp:66:17: warning: invalid use of incomplete type \u2018struct Character\u2019 [enabled by default]\nHeader.h:27:7: warning: forward declaration of \u2018struct Character\u2019 [enabled by default]\nHeader.cpp:66:17: note: neither the destructor nor the class-specific operator delete will be called, even if they are declared when the class is defined\n</code></pre>\n<p>And once my program terminates, the character's destructor's message won't show up which means the destructor clearly isn't called.</p>\n<p>What am I doing wrong with the forward declarations?</p>\n", "AcceptedAnswerId": "18550460", "Title": "C++ Forward declaration and destructor", "CreationDate": "2013-08-31T16:32:46.187", "Id": "18550304", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-08-31T17:17:30.420", "Score": "2", "OwnerUserId": "2386252", "Tags": "<c++><destructor><forward-declaration>", "AnswerCount": "2"}, "18550787": {"Id": "18550787", "PostTypeId": "2", "Body": "<p>When you use <code>class MyClass;</code> to forward declare your class, this only declares that the thing with the name <code>MyClass</code> is a <code>class</code>, it does not declare the internal methods of the class.</p>\n<p>Whenever you need to use one of the internal methods (such as a non-trivial destructor) you need to include the full declaration of the class (this means include the header file containing the class definition).  Without this, the compiler has no way of knowing what the internal structure of your class actually looks like.</p>\n<p>Here is an example:</p>\n<pre><code>// main.cpp\n#include \"head1.hpp\"        // An instance of Head1 is created in this file\n#include \"head2.hpp\"        // An instance of Head2 is created in this file\n\nint main(int argc, char** argv)\n{\n    Head1 head1(true);\n    Head2 head2(true);\n    return 0;\n}\n</code></pre>\n<hr>\n<pre><code>// head1.hpp\n#ifndef HEAD1_HPP\n#define HEAD1_HPP\n\nclass Head2;      // A pointer to a class is declared, but no instance is created\n                  // so here we only need a forward declaration\n\nclass Head1\n{\npublic:\n    Head1(bool real=false);\n    ~Head1();\n\nprivate:\n    Head2* myHead2;\n};\n\n#endif /* #ifndef HEAD1_HPP */\n</code></pre>\n<hr>\n<pre><code>// head2.hpp\n#ifndef HEAD2_HPP\n#define HEAD2_HPP\n\nclass Head1;                        // Same as above\n\nclass Head2\n{\npublic:\n    Head2(bool real=false);\n    ~Head2();\n\nprivate:\n    Head1* myHead1;\n};\n\n#endif /* #ifndef HEAD2_HPP */\n</code></pre>\n<hr>\n<pre><code>// head1.cpp\n#include \"head1.hpp\"               // Include the header we are defining methods for\n#include \"head2.hpp\"               // We also create an instance of Head2 in here\n#include &lt;iostream&gt;\nusing namespace std;\n\nHead1::Head1(bool real) {\n    myHead2 = real ? new Head2() : NULL;\n    cout &lt;&lt; \"Hello Head 1\" &lt;&lt; endl;\n}\n\nHead1::~Head1() {\n    cout &lt;&lt; \"Bye Head 1\" &lt;&lt; endl;\n    if (myHead2 != NULL) delete myHead2;\n}\n</code></pre>\n<hr>\n<pre><code>// head2.cpp\n#include \"head2.hpp\"                     // As above\n#include \"head1.hpp\"\n#include &lt;iostream&gt;\nusing namespace std;\n\nHead2::Head2(bool real) {\n    myHead1 = real ? new Head1() : NULL;\n    cout &lt;&lt; \"Hello Head 2\" &lt;&lt; endl;\n}\n\nHead2::~Head2() {\n    cout &lt;&lt; \"Bye Head 2\" &lt;&lt; endl;\n    if (myHead1 != NULL) delete myHead1;\n}\n</code></pre>\n</hr></hr></hr></hr>", "LastActivityDate": "2013-08-31T17:17:30.420", "CommentCount": "0", "CreationDate": "2013-08-31T17:17:30.420", "ParentId": "18550304", "Score": "0", "OwnerUserId": "2372604"}});