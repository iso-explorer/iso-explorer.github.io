post_cb({"bq_ids": {"n4140": {"so_30628742_30631419_4": {"length": 9, "quality": 1.0, "section_id": 6043}, "so_30628742_30631419_3": {"length": 14, "quality": 0.875, "section_id": 6144}, "so_30628742_30631419_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6043}, "so_30628742_30631419_1": {"length": 28, "quality": 0.9333333333333333, "section_id": 6044}, "so_30628742_30631419_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 6143}}, "n3337": {"so_30628742_30631419_4": {"length": 9, "quality": 1.0, "section_id": 5811}, "so_30628742_30631419_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 5811}, "so_30628742_30631419_1": {"length": 28, "quality": 0.9333333333333333, "section_id": 5812}, "so_30628742_30631419_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 5907}}, "n4659": {"so_30628742_30631419_4": {"length": 9, "quality": 1.0, "section_id": 7542}, "so_30628742_30631419_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7542}, "so_30628742_30631419_1": {"length": 28, "quality": 0.9333333333333333, "section_id": 7543}, "so_30628742_30631419_3": {"length": 12, "quality": 0.75, "section_id": 7640}, "so_30628742_30631419_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 7639}}}, "30654393": {"Id": "30654393", "PostTypeId": "2", "Body": "<p>The Standard guarantees that converting a pointer to an <code>uintptr_t</code> will yield a value of some unsigned type which, if cast to the original pointer type, will yield the original pointer.  It also mandates that any pointer can be decomposed into a sequence of <code>unsigned char</code> values, and that using such a sequence of <code>unsigned char</code> values to construct a pointer will yield the original.  Neither guarantee, however, would forbid an implementation from including padding bits within pointer types, nor would either guarantee require that the padding bits behave in any consistent fashion.</p>\n<p>If code avoided storing pointers, and instead cast to <code>uintptr_t</code> every pointer returned from <code>malloc</code>, later casting those values back to pointers as required, then the resulting <code>uintptr_t</code> values would form a ranking.  The ranking might not have any relationship to the order in which objects were created, nor to their arrangement in memory, but it would be a ranking.  If any pointer gets converted to <code>uintptr_t</code> more than once, however, the resulting values might rank entirely independently.</p>\n", "LastActivityDate": "2015-06-04T21:22:14.757", "CommentCount": "0", "CreationDate": "2015-06-04T21:22:14.757", "ParentId": "30628742", "Score": "1", "OwnerUserId": "363751"}, "30628742": {"ViewCount": "285", "Body": "<p><em>(related to <a href=\"https://stackoverflow.com/questions/30617158/how-does-stdless-work\">my previous question</a>)</em></p>\n<p>In QT, the <a href=\"http://doc.qt.io/qt-5/qmap.html#details\" rel=\"nofollow noreferrer\"><code>QMap</code> documentation</a> says:</p>\n<blockquote>\n<p id=\"so_30628742_30628742_0\">The key type of a QMap must provide <code>operator&lt;()</code> specifying a <strong>total order</strong>.</p>\n</blockquote>\n<p>However, in <code>qmap.h</code>, they seem to use something similar to <code>std::less</code> to compare pointers:</p>\n<pre><code>/*\n    QMap uses qMapLessThanKey() to compare keys. The default\n    implementation uses operator&lt;(). For pointer types,\n    qMapLessThanKey() casts the pointers to integers before it\n    compares them, because operator&lt;() is undefined on pointers\n    that come from different memory blocks. (In practice, this\n    is only a problem when running a program such as\n    BoundsChecker.)\n*/\n\ntemplate &lt;class Key&gt; inline bool qMapLessThanKey(const Key &amp;key1, const Key &amp;key2)\n{\n    return key1 &lt; key2;\n}\n\ntemplate &lt;class Ptr&gt; inline bool qMapLessThanKey(const Ptr *key1, const Ptr *key2)\n{\n    Q_STATIC_ASSERT(sizeof(quintptr) == sizeof(const Ptr *));\n    return quintptr(key1) &lt; quintptr(key2);\n}\n</code></pre>\n<p>They just cast the pointers to <code>quintptr</code>s (which is the QT-version of <code>uintptr_t</code>, that is, an unsigned int that is capable of <a href=\"https://stackoverflow.com/a/22624888\">storing a pointer</a>) and compare the results.</p>\n<blockquote>\n<p id=\"so_30628742_30628742_1\">The following type designates an unsigned integer type with the property that any valid pointer to void can be converted to this type, then converted back to a pointer to void, and the result will compare equal to the original pointer: <code>uintptr_t</code></p>\n</blockquote>\n<p>Do you think this implementation of <code>qMapLessThanKey()</code> on pointers is ok?</p>\n<p>Of course, there is a total order on integral types. But I think this is not sufficient to conclude that this operation defines a total order on pointers.</p>\n<p>I think that it is true only if <code>p1 == p2</code> implies <code>quintptr(p1) == quintptr(p2)</code>, which, AFAIK, is not specified.</p>\n<p>As a counterexample of this condition, imagine a target using 40 bits for pointers; it could convert pointers to <code>quintptr</code>, setting the 40 lowest bits to the pointer address and leaving the 24 highest bits unchanged (random). This is sufficient to respect the convertibility between <code>quintptr</code> and pointers, but this does not define a total order for pointers.</p>\n<p>What do you think?</p>\n", "AcceptedAnswerId": "30631419", "Title": "Does casting pointers to integers define a total order on pointers?", "CreationDate": "2015-06-03T19:17:27.280", "Id": "30628742", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:14:28.500", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-04T21:22:14.757", "Score": "3", "OwnerUserId": "1987178", "Tags": "<c++><qt><pointers><undefined-behavior><partial-ordering>", "AnswerCount": "2"}, "30631419": {"Id": "30631419", "PostTypeId": "2", "Body": "<p>I think that you can't assume that there is a total order on pointers.  The guarantees given by the standard for pointer to int conversions are rather limited:</p>\n<blockquote>\n<p id=\"so_30628742_30631419_0\"><strong>5.2.10/4:</strong> A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-defined.</p>\n<p id=\"so_30628742_30631419_1\"><strong>5.2.10/5:</strong> A value of integral type or enumeration type can be explicitly converted to a pointer.  A pointer converted to an integer\n  of sufficient size (...) and back to the same pointer type will have\n  its original value; mappings between pointers and integers are\n  otherwise implementation-defined.</p>\n</blockquote>\n<p><strong>From a practical point of view</strong>, most of the mainstream compilers will convert a pointer to an integer in a bitwise manner, and you'll have a total order.    </p>\n<h1>The theoretical problem:</h1>\n<p>But this is not guaranteed.  It might not work on past platforms (<a href=\"https://en.wikipedia.org/wiki/X86_memory_segmentation\" rel=\"nofollow\">x86 real and protected mode</a>), on exotic platform (embedded systems ?) , and -who knows- on some future platforms (?). </p>\n<p>Take the example of <a href=\"https://en.wikipedia.org/wiki/Intel_Memory_Model\" rel=\"nofollow\">segmented memory</a> of the 8086: The real address  is given by the combination of a segment (e.g.  DS register for data segment, an SS for stack segment,...) and an offest:  </p>\n<pre><code>Segment:   XXXX YYYY YYYY YYYY 0000    16 bits shifted by 4 bits\nOffset:    0000 ZZZZ ZZZZ ZZZZ ZZZZ    16 bits not sifted\n           ------------------------\nAddress:   AAAA AAAA AAAA AAAA AAAA    20 bits address                      \n</code></pre>\n<p>Now imagine that the compiler would convert the pointer to int, by simply doing the address math and put 20 bits in the integer: your safe and have a total order.  </p>\n<p>But another equally valid approach would be to store the segment on 16 upper bits and the offset on the 16 lower bits.  In fact, this way would significantly facilitate/accelerate the load of pointer values into cpu registers.  </p>\n<p>This approach is compliant with standard c++ requirements, but each single address could be represented by 16 different pointers: your total order is lost !! </p>\n<p>**Are there alternatives for the order ? **</p>\n<p>One could imagine using pointer arithmetics.  There are strong constraints on pointer arithmetics for elements in a same array:     </p>\n<blockquote>\n<p id=\"so_30628742_30631419_2\"><strong>5.7/6:</strong> When two pointers to elements of the same array object are subtracted, the result is the difference of the subscripts of the two\n  array elements.</p>\n</blockquote>\n<p>And subscripts are ordered.  </p>\n<p>Array can be of maximum <code>size_t</code> elements. So, naively, if <code>sizeof(pointer) &lt;= sizof(size_t)</code> one could assume that taking an arbitrary reference pointer and doing some pointer arithmetic  should lead to a total order.  </p>\n<p>Unfortunately, here also, the standard is very prudent: </p>\n<blockquote>\n<p id=\"so_30628742_30631419_3\"><strong>5.7.7:</strong>  For addition or subtraction, if the expressions P or Q have type \u201cpointer to cv T\u201d, where T is different from the\n  cv-unqualified array element type, the behavior is undefined.</p>\n</blockquote>\n<p>So pointer arithmetic won't do the trick for arbitrary pointers either.  Again,  back to the segmented memory models, helps to understand:  arrays could have maximum 65535 bytes to fit completely in one segment. But different arrays could use different segments so that pointer arithmetic wouldn't be reliable for a total order either.  </p>\n<h1>Conclusion</h1>\n<p>There's a subtle note in the standard on the mapping between pointer and interal value:  </p>\n<blockquote>\n<p id=\"so_30628742_30631419_4\">It is intended to be unsurprising to those who know the addressing\n  structure of the underlying machine.</p>\n</blockquote>\n<p>This means that must be be possible to determine a total order.  But keep in mind that it'll be non portable.  </p>\n", "LastActivityDate": "2015-06-03T21:51:31.710", "CommentCount": "0", "CreationDate": "2015-06-03T21:51:31.710", "ParentId": "30628742", "Score": "1", "OwnerUserId": "3723423"}});