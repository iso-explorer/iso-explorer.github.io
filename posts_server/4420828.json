post_cb({"4420839": {"Id": "4420839", "PostTypeId": "2", "Body": "<h2>Why GCC and Clang think they are right</h2>\n<p><code>K</code>, which is the injected class name, has a dual nature in the scope of <code>K&lt;int&gt;</code>. You can use it without template arguments. Then it refers to <code>K&lt;int&gt;</code> (to its own type). </p>\n<p>It can be followed by a template argument list too. IMO it's reasonable to say that you need to prefix it with <code>template</code> because of the parser ambiguity with the <code>&lt;</code> that follows. It then refers to the specified type that's determined by the template arguments. </p>\n<p>So it can be treated as a member template and as a nested type, depending on whether it's followed by a template argument list. Of course, <code>K</code> is not really a member template. The dual nature of the injected class name seems to me more of a hack anyway, though. </p>\n<p>The Standard has an example that reads like this:</p>\n<pre><code>template &lt;class T&gt; struct Base { };\ntemplate &lt;class T&gt; struct Derived: Base&lt;int&gt;, Base&lt;char&gt; {\n   typename Derived::Base b; // error: ambiguous\n   typename Derived::Base&lt;double&gt; d; // OK\n};\n</code></pre>\n<p>One might be inclined to conclude from this that the intent is that you could leave off the <code>template</code>. The Standard says </p>\n<blockquote>\n<p id=\"so_4420828_4420839_0\">For a template-name to be explicitly qualified by the template arguments, the name must be known to refer to a template.</p>\n</blockquote>\n<p>I can't see how this wouldn't apply to <code>T::K&lt;T&gt;</code>. If <code>T</code> is a dependent type then you can just lean back because you can't know what <code>K</code> refers to when parsing it, so to make any sense of the code, you just have to be able to prefix it with <code>template</code>. Notice that n3225 has that example too, but it's not a defect there: You can officially leave off <code>template</code> if you lookup into the template's own scope in C++0x (it's called the \"current instantiation\").</p>\n<p>So until now, Clang and GCC are fine.</p>\n<hr>\n<h2>Why Comeau is right</h2>\n<p>Just to make it even more complicated, we will have to consider the constructors of <code>K&lt;int&gt;</code>. There is a default constructor and a copy constructor implicitly declared. A name <code>K&lt;int&gt;::K</code> will refer to the constructor(s) of <code>K&lt;int&gt;</code> <em>unless</em> the name lookup used will ignore function (constructor) names. Will <code>typename T::K</code> ignore function names? 3.4.4/3 says about elaborated type specifiers, which <code>typename ...</code> is one of:</p>\n<blockquote>\n<p id=\"so_4420828_4420839_1\">If the name is a qualified-id, the name is looked up according its qualifications, as described in 3.4.3, but ignoring any non-type names that have been declared. </p>\n</blockquote>\n<p>However, a <code>typename ...</code> uses different lookup. 14.6/4 says</p>\n<blockquote>\n<p id=\"so_4420828_4420839_2\">The usual qualified name lookup (3.4.3) is used to find the qualified-id even in the presence of typename.</p>\n</blockquote>\n<p>The usual qualified lookup of 3.4.3 won't ignore non-type names, as illustrated by the example attached to 14.6/4. So, we will find the constructor(s) as specified by 3.4.3.1/1a (the additional twist that this only happens when non-types are <em>not</em> ignored was added by a later defect report, which all popular C++03 compilers implement though):</p>\n<blockquote>\n<p id=\"so_4420828_4420839_3\">If the nested-name-specifier nominates a class C, and the name specified after the nested-name-specifier, when looked up in C, is the injected-class-name of C (clause 9), the name is instead considered to name the constructor of class C. Such a constructor name shall be used only in the declarator-id of a constructor definition that appears outside of the class definition. </p>\n</blockquote>\n<p>So in the end, I think comeau is correct to diagnose this, because you try to put a template argument list onto a non-template and also violate the requirement quoted in the last part (you use the name elsewhere). </p>\n<p>Let's change it by accessing the injected name by a <em>derived</em> class, so no constructor name translation occurs, and you <em>really</em> access the type so that you <em>really</em> can append the template arguments:</p>\n<pre><code>// just replace struct X with this:\ntemplate&lt;typename T&gt;\nstruct X\n{\n   struct Derived : T { };\n   typename Derived::template K&lt;T&gt; *p;\n};\n</code></pre>\n<p>Everything compiles now with comeau too! Notice I already did problem report to clang about this exact thing. See <a href=\"http://llvm.org/bugs/show_bug.cgi?id=8263\">Incorrect constructor name resolution</a>. BTW, if you declare a default constructor in <code>K</code>, you can see comeau give a better error message if you use <code>T::K&lt;int&gt;</code></p>\n<pre><code>\"ComeauTest.c\", line 13: error: overloaded function \"N::K&lt;T&gt;::K [with T=int]\" is\n          not a template\n     typename T::template K&lt;T&gt; *p;\n</code></pre>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2010-12-12T09:45:55.713", "Score": "44", "CreationDate": "2010-12-12T08:23:58.000", "ParentId": "4420828", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2010-12-12T09:45:55.713"}, "4420828": {"ViewCount": "3130", "Body": "<p>Check out the following code (written just for fun)</p>\n<pre><code>namespace N\n{\n   template&lt;typename T&gt;\n   struct K\n   {\n\n   };\n}\ntemplate&lt;typename T&gt;\nstruct X\n{\n   typename T::template K&lt;T&gt; *p; //should give error \n                                 //N::K&lt;int&gt; has no template member named `K`\n};\n\nint main()\n{\n   X&lt;N::K&lt;int&gt; &gt; l;\n}\n</code></pre>\n<p>The code gets compiled on g++(4.5.1) and Clang whereas Comeau and Intel C++ give (similar) errors.</p>\n<p>The errors that I get on Comeau are :</p>\n<pre><code>\"ComeauTest.c\", line 13: error: class \"N::K&lt;int&gt;\" has no member \"K\"\n     typename T::template K&lt;T&gt; *p;\n                          ^\n          detected during instantiation of class \"X&lt;T&gt; [with T=N::K&lt;int&gt;]\" at\n                    line 18\n\n\"ComeauTest.c\", line 13: error: expected an identifier\n     typename T::template K&lt;T&gt; *p;\n                           ^\n          detected during instantiation of class \"X&lt;T&gt; [with T=N::K&lt;int&gt;]\" at\n                    line 18\n</code></pre>\n<p>So my question is \"Is the code sample ill-formed ?\" According to me \"Yes\". Does that mean this is yet another bug in g++/Clang?</p>\n", "AcceptedAnswerId": "4420839", "Title": "Another bug in g++/Clang? [C++ Templates are fun]", "CreationDate": "2010-12-12T08:18:41.037", "Id": "4420828", "CommentCount": "2", "FavoriteCount": "17", "PostTypeId": "1", "LastEditDate": "2010-12-12T12:58:39.263", "LastEditorUserId": "165520", "LastActivityDate": "2011-03-20T16:37:06.067", "Score": "31", "OwnerUserId": "165520", "Tags": "<c++><templates>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_4420828_4420839_3": {"length": 19, "quality": 0.7307692307692307, "section_id": 7114}, "so_4420828_4420839_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 171}, "so_4420828_4420839_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 70}, "so_4420828_4420839_1": {"length": 9, "quality": 0.5625, "section_id": 7124}}, "n3337": {"so_4420828_4420839_3": {"length": 19, "quality": 0.7307692307692307, "section_id": 6858}, "so_4420828_4420839_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 165}, "so_4420828_4420839_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 65}, "so_4420828_4420839_1": {"length": 9, "quality": 0.5625, "section_id": 6868}}, "n4659": {"so_4420828_4420839_3": {"length": 19, "quality": 0.7307692307692307, "section_id": 8615}, "so_4420828_4420839_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 176}, "so_4420828_4420839_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 72}, "so_4420828_4420839_1": {"length": 9, "quality": 0.5625, "section_id": 8625}}}});