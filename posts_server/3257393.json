post_cb({"3257755": {"ParentId": "3257393", "CommentCount": "1", "Body": "<p>This test is broken even if dereferencing was not an UB. It breaks when this-adjustments for multiple inheritance come into the play:</p>\n<pre><code>#include &lt;stdio.h&gt;\nclass B\n{\n    int value;\n    public:\n    void foo()\n    {\n        if (!this)\n            printf(\"this==0\\n\");\n        else \n            printf(\"safe\\n\");\n    }\n};\nclass A { public: int anotherValue; };\nclass Z : public A,public B {};\n\nint main()\n{\n    Z *z=0;\n    z-&gt;foo();\n}\n</code></pre>\n<p>prints \"safe\" here.</p>\n", "OwnerUserId": "385433", "PostTypeId": "2", "Id": "3257755", "Score": "7", "CreationDate": "2010-07-15T16:34:53.810", "LastActivityDate": "2010-07-15T16:34:53.810"}, "3257461": {"ParentId": "3257393", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It doesn't matter if it is legal, it is confusing to the reader. In the implementation where this code works, the vtable is being accessed by type, certainly not by object.</p>\n<p>Moreover, I expect that this code was put in to cover for a constructor failure, which would mask a variety of problems elsewhere. Constructor failure should be handled correctly, not with a nasty kludge like the example.</p>\n", "OwnerUserId": "282912", "LastEditorUserId": "282912", "LastEditDate": "2010-07-15T16:22:33.513", "Id": "3257461", "Score": "1", "CreationDate": "2010-07-15T16:01:45.373", "LastActivityDate": "2010-07-15T16:22:33.513"}, "3257590": {"ParentId": "3257393", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This will probably work on most systems, but it is Undefined Behaviour. Quoth the Standard:</p>\n<blockquote>\n<p id=\"so_3257393_3257590_0\">5.2.5.3</p>\n<p id=\"so_3257393_3257590_1\">If <code>E1</code> has the type \u201cpointer to class X,\u201d then the expression <code>E1-&gt;E2</code> is converted to the equivalent form <code>(*(E1)).E2</code> [...]</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_3257393_3257590_2\">5.2.5.1</p>\n<p id=\"so_3257393_3257590_3\">A postfix expression followed by a dot <code>.</code> or an arrow <code>-&gt;</code>, optionally followed by the keyword <code>template</code> (14.8.1), and then followed by an <em>id-expression</em>, is a postfix expression. The postfix expression before the dot or arrow is evaluated;<sup>58)</sup> [...]</p>\n<p id=\"so_3257393_3257590_4\"><sup>58)</sup> This evaluation happens even if the result is unnecessary to determine the value of the entire postfix expression, for example if the id-expression denotes a static member.</p>\n</blockquote>\n<p>Evaluation of <code>*x</code> where <code>x</code> is a null pointer results in Undefined Behaviour, so yours is clearly a case of UB, before the function is even entered.</p>\n", "OwnerUserId": "14637", "LastEditorUserId": "14637", "LastEditDate": "2010-07-15T16:23:48.190", "Id": "3257590", "Score": "13", "CreationDate": "2010-07-15T16:15:40.783", "LastActivityDate": "2010-07-15T16:23:48.190"}, "3257504": {"ParentId": "3257393", "CommentCount": "0", "Body": "<p>It is UB.  A good way to make it crash is to use it as a base class of a derived class that uses multiple inheritance.  YMMV.</p>\n", "OwnerUserId": "17034", "PostTypeId": "2", "Id": "3257504", "Score": "1", "CreationDate": "2010-07-15T16:04:35.243", "LastActivityDate": "2010-07-15T16:04:35.243"}, "3257498": {"ParentId": "3257393", "CommentCount": "0", "Body": "<p>This is (all together now) <em>undefined behavior</em>. However, for many compilers it will work, with the additional constraint that the method must be non-virtual.</p>\n", "OwnerUserId": "8078", "PostTypeId": "2", "Id": "3257498", "Score": "1", "CreationDate": "2010-07-15T16:04:25.663", "LastActivityDate": "2010-07-15T16:04:25.663"}, "bq_ids": {"n4140": {"so_3257393_3257590_3": {"section_id": 6004, "quality": 0.8636363636363636, "length": 19}, "so_3257393_3257590_4": {"section_id": 6004, "quality": 0.9375, "length": 15}, "so_3257393_3257590_1": {"section_id": 6005, "quality": 0.9, "length": 9}}, "n3337": {"so_3257393_3257590_3": {"section_id": 5772, "quality": 0.8636363636363636, "length": 19}, "so_3257393_3257590_4": {"section_id": 5772, "quality": 0.9375, "length": 15}, "so_3257393_3257590_1": {"section_id": 5773, "quality": 0.9, "length": 9}}, "n4659": {"so_3257393_3257590_3": {"section_id": 7503, "quality": 0.8636363636363636, "length": 19}, "so_3257393_3257590_4": {"section_id": 7503, "quality": 0.9375, "length": 15}, "so_3257393_3257590_1": {"section_id": 7504, "quality": 0.9, "length": 9}}}, "3257393": {"CommentCount": "1", "AcceptedAnswerId": "3257590", "CreationDate": "2010-07-15T15:55:33.960", "LastActivityDate": "2010-07-15T16:34:53.810", "PostTypeId": "1", "ViewCount": "475", "FavoriteCount": "4", "Title": "Is it legal/well-defined C++ to call a non-static method that doesn't access members through a null pointer?", "Id": "3257393", "Score": "7", "Body": "<p>I came across the following code recently:</p>\n<pre><code>class Foo\n{\npublic:\n    void bar();\n    // .. other stuff\n};\n\nvoid Foo::bar()\n{\n    if(!this) {\n        // .. do some stuff without accessing any data members\n        return;\n    }\n\n    // .. do normal actions using data members\n}\n</code></pre>\n<p>The code compiles because in C++ methods are just functions that are implicitly passed a pointer for 'this' and 'this' can be checked to be NULL just like any other pointer. Obviously this code is confusing and bad practice even though it doesn't crash; it would be pretty confusing to step through the code in the debugger, see a NULL pointer is about to have a method called on it and then not see the expected crash. My question is: does it violate the C++ standard to call <code>SomeFooPtr-&gt;bar()</code> where <code>SomeFooPtr == NULL</code>?</p>\n<p>It occurs to me that it may not because the user defined operator-&gt; returns a pointer, which means that even if that pointer is NULL it definitely hasn't been dereferenced (dereferencing a NULL pointer I'm sure is regarded by the standard as illegal or undefined). On the other hand the semantics of raw pointers don't necessarily have to match the semantics of user defined pointers -- perhaps operator-&gt; on them is considered a dereference even though the compiler won't generate one.</p>\n", "Tags": "<c++><pointers><null><methods><standards>", "OwnerUserId": "50385", "AnswerCount": "5"}});