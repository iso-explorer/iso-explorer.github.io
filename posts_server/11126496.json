post_cb({"11126858": {"ParentId": "11126496", "CommentCount": "0", "CreationDate": "2012-06-20T19:33:24.297", "OwnerUserId": "1253222", "PostTypeId": "2", "Id": "11126858", "Score": "3", "Body": "<p>Because <code>fn()</code> is not declared <code>static</code>, as @RobKennedy points out, you're venturing into UB land. In this specific case, <code>-O0</code> probably disables inlining, which means that one of the emitted non-inlined versions of the function will be kept and the other discarded, and both calls will be to the one non-inlined version. Whether the A version is always kept may depend on the order in which you specify your files on the command line, or any number of other things. <code>-O1</code> probably included inlining, in which case, even if there is a non-inlined copy of the function emitted, the two calls may still be inlined, which gives the (erroneously) expected results.</p>\n", "LastActivityDate": "2012-06-20T19:33:24.297"}, "11126496": {"CommentCount": "3", "AcceptedAnswerId": "11126548", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2012-06-20T19:09:02.980", "LastActivityDate": "2015-12-26T18:12:39.253", "LastEditDate": "2015-12-26T18:12:39.253", "ViewCount": "636", "FavoriteCount": "1", "Title": "Accessing static globals in an inline function", "Id": "11126496", "Score": "5", "Body": "<p>I was having an odd problem that I narrowed down to the following test case:</p>\n<p>inl.h:</p>\n<pre><code>inline const char *fn() { return id; }\n</code></pre>\n<p>a.cc:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstatic const char *id = \"This is A\";\n\n#include \"inl.h\"\n\nvoid A()\n{\n    printf(\"In A we get: %s\\n\", fn());\n}\n</code></pre>\n<p>b.cc:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstatic const char *id = \"This is B\";\n\n#include \"inl.h\"\n\nvoid B()\n{\n    printf(\"In B we get: %s\\n\", fn());\n}\n\nextern void A();\n\nint main()\n{\n    A();\n    B();\n    return 0;\n}\n</code></pre>\n<p>Now when I compile this with <code>g++ -O1 a.cc b.cc</code> it seems to work correctly.  I get:</p>\n<pre><code>In A we get: This is A\nIn B we get: This is B\n</code></pre>\n<p>but if I compile with <code>g++ -O0 a.cc b.cc</code> I get:</p>\n<pre><code>In A we get: This is A\nIn B we get: This is A\n</code></pre>\n<p>Note that I'm actually trying to use C11 semantics here, but I'm using g++ as gcc doesn't support C11 yet.</p>\n<p>Now as far as I can see, looking at both the C11 spec and the C++ spec (C++11 and older specs -- the semantics of inline and static globals does not seem to have changed), it should do what I want, and the failure when using <code>-O0</code> is a bug in gcc.</p>\n<p>Is this correct, or is there something somewhere in the spec that I'm missing that would make this undefined behavior?</p>\n<p><strong>Edit</strong></p>\n<p>The common answer seems to claim that <code>fn</code> needs to be declared as <code>static</code> for this to work.  But according to 6.7.4.6 of the C99 spec (6.7.4.7 in the C11 spec -- not sure about the C++ spec):</p>\n<blockquote>\n<p id=\"so_11126496_11126496_0\">If all of the file scope declarations for a function in a translation unit include the inline function\n  specifier without extern, then the definition in that translation unit is an inline\n  definition. An inline definition does not provide an external definition for the function,\n  and does not forbid an external definition in another translation unit.</p>\n</blockquote>\n<p>So since there's no explicit <code>extern</code> here, these should be two independent inline functions with no interaction with each other.  No explicit <code>static</code> is required.</p>\n<p>Using an explicit static fixes the problem for C, but doesn't work for C++ inline member functions, as the <code>static</code> keyword has a completely different meaning in that case.</p>\n", "Tags": "<c++><gcc>", "OwnerUserId": "16406", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11126496_11126548_0": {"section_id": 7043, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_11126496_11126548_0": {"section_id": 6788, "quality": 0.9705882352941176, "length": 33}, "so_11126496_11126548_1": {"section_id": 5191, "quality": 1.0, "length": 15}}, "n4659": {"so_11126496_11126548_0": {"section_id": 8540, "quality": 0.9705882352941176, "length": 33}, "so_11126496_11126548_1": {"section_id": 8640, "quality": 0.5333333333333333, "length": 8}}}, "11126548": {"ParentId": "11126496", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-06-20T19:12:30.770", "Score": "8", "LastEditorUserId": "33732", "LastEditDate": "2012-06-20T21:27:49.797", "Id": "11126548", "OwnerUserId": "33732", "Body": "<p>You've violated the one-definition rule. The non-static function <code>fn</code> is defined differently in your two translation units. One binds with the <code>id</code> variable defined in <em>a.cc</em>, where as the other binds with the <code>id</code> variable in <em>b.cc</em>. The definitions are <em>textually</em> identical, but that's not enough to satisfy the one-definition rule, even with the exception set out for functions declared <code>inline</code>, so you get undefined behavior.</p>\n<p>You're using a C++ compiler, not a C compiler, so whatever C11 says is irrelevant with regard to the behavior your C++ program exhibits. In C++11, the standard (at \u00a73.2/5) seems to state the rule about how <code>fn</code> is allowed to reference <code>id</code> (emphasis and ellipses mine):</p>\n<blockquote>\n<p id=\"so_11126496_11126548_0\">There can be more than one definition of a \u2026 inline function\n  with external linkage (7.1.2) \u2026 in a program\n  provided that each definition appears in a different translation unit,\n  and provided the definitions satisfy the following requirements. Given\n  such an entity named <code>D</code> defined in more than one translation unit, then</p>\n<ul>\n<li>each definition of <code>D</code> shall consist of the same sequence of tokens; and</li>\n<li>in each definition of <code>D</code>, corresponding names, looked up\n  according to 3.4, <strong>shall refer to an entity defined within the\n  definition of <code>D</code>, or shall refer to the same entity</strong>, after overload\n  resolution (13.3) and after matching of partial template\n  specialization (14.8.3), except that a name can refer to a <code>const</code>\n  object with internal or no linkage if the object has the same literal\n  type in all definitions of <code>D</code>, and the object is initialized with a\n  constant expression (5.19), and the value (but not the address) of the\n  object is used, and the <strong>object has the same value in all definitions</strong>\n  of <code>D</code>; and</li>\n<li>\u2026</li>\n</ul>\n</blockquote>\n<p>Your definitions of <code>fn</code> consist of the same sequence of tokens, but they refer to <code>id</code>, which is not defined within <code>D</code>, is not the same entity in both translation units, and does not have the same value in all definitions. I see no provision in the C++ standard for an inline function acquiring internal linkage implicitly. C++11 \u00a77.1.1/7 says this:</p>\n<blockquote>\n<p id=\"so_11126496_11126548_1\">A name declared in a namespace scope without a <em>storage-class-specifier</em> has external linkage unless it has internal linkage because of a previous declaration and provided it is not declared <code>const</code>.</p>\n</blockquote>\n<p>If you got your expected behavior at certain optimization levels, or from certain versions of certain compilers, then you were just getting the particularly nefarious version of undefined behavior, where things appear to work despite being wrong.</p>\n", "LastActivityDate": "2012-06-20T21:27:49.797"}});