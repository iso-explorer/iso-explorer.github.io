post_cb({"15286450": {"CommentCount": "16", "AcceptedAnswerId": "17635374", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2013-03-08T03:58:31.373", "LastActivityDate": "2013-07-14T00:18:33.907", "LastEditDate": "2013-03-08T08:23:09.477", "ViewCount": "3063", "FavoriteCount": "3", "Title": "lifetime of a std::initializer_list return value", "Id": "15286450", "Score": "21", "Body": "<p>GCC's implementation destroys a <code>std::initializer_list</code> array returned from a function at the end of the return full-expression. Is this correct?</p>\n<p>Both test cases in this program show the destructors executing before the value can be used:</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n\nstruct noisydt {\n    ~noisydt() { std::cout &lt;&lt; \"destroyed\\n\"; }\n};\n\nvoid receive( std::initializer_list&lt; noisydt &gt; il ) {\n    std::cout &lt;&lt; \"received\\n\";\n}\n\nstd::initializer_list&lt; noisydt &gt; send() {\n    return { {}, {}, {} };\n}\n\nint main() {\n    receive( send() );\n    std::initializer_list&lt; noisydt &gt; &amp;&amp; il = send();\n    receive( il );\n}\n</code></pre>\n<p>I think the program should work. But the underlying standardese is a bit convoluted.</p>\n<p>The return statement initializes a return value object as if it were declared </p>\n<pre><code>std::initializer_list&lt; noisydt &gt; ret = { {},{},{} };\n</code></pre>\n<p>This initializes one temporary <code>initializer_list</code> and its underlying array storage from the given series of initializers, then initializes another <code>initializer_list</code> from the first one. What is the array's lifetime? \"The lifetime of the array is the same as that of the <code>initializer_list</code> object.\" But there are two of those; which one is ambiguous. The example in 8.5.4/6, if it works as advertised, should resolve the ambiguity that the array has the lifetime of the copied-to object. Then the return value's array should also survive into the calling function, and it should be possible to preserve it by binding it to a named reference.</p>\n<p>On <a href=\"http://liveworkspace.org/code/2ZlWsj%240\">LWS</a>, GCC erroneously kills the array before returning, but it preserves a named <code>initializer_list</code> per the example. Clang also processes the example correctly, but objects in the list are <em>never</em> destroyed; this would cause a memory leak. ICC doesn't support <code>initializer_list</code> at all.</p>\n<p>Is my analysis correct?</p>\n<hr>\n<p>C++11 \u00a76.6.3/2:</p>\n<blockquote>\n<p id=\"so_15286450_15286450_0\">A  return statement with a <em>braced-init-list</em> initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n</blockquote>\n<p>8.5.4/1:</p>\n<blockquote>\n<p id=\"so_15286450_15286450_1\">\u2026 list-initialization in a copy-initialization context is called <em>copy-list-initialization</em>.</p>\n</blockquote>\n<p>8.5/14:</p>\n<blockquote>\n<p id=\"so_15286450_15286450_2\">The initialization that occurs in the form <code>T x = a;</code> \u2026 is called <em>copy-initialization</em>.</p>\n</blockquote>\n<p>Back to 8.5.4/3:</p>\n<blockquote>\n<p id=\"so_15286450_15286450_3\">List-initialization of an object or reference of type T is defined as follows: \u2026</p>\n<p id=\"so_15286450_15286450_4\">\u2014 Otherwise, if T is a specialization of <code>std::initializer_list&lt;E&gt;</code>, an <code>initializer_list</code> object is constructed as described below and used to initialize the object according to the rules for initialization of an object from a class of the same type (8.5).</p>\n</blockquote>\n<p>8.5.4/5:</p>\n<blockquote>\n<p id=\"so_15286450_15286450_5\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated an array of <em>N</em> elements of type <em>E</em>, where <em>N</em> is the number of elements in the initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array. If a narrowing conversion is required to initialize any of the elements, the program is ill-formed.</p>\n</blockquote>\n<p>8.5.4/6:</p>\n<blockquote>\n<p id=\"so_15286450_15286450_6\">The lifetime of the array is the same as that of the <code>initializer_list</code> object. <em>[Example:</em></p>\n<pre><code>typedef std::complex&lt;double&gt; cmplx;\n std::vector&lt;cmplx&gt; v1 = { 1, 2, 3 };\n void f() {\n   std::vector&lt;cmplx&gt; v2{ 1, 2, 3 };\n   std::initializer_list&lt;int&gt; i3 = { 1, 2, 3 };\n }\n</code></pre>\n<p id=\"so_15286450_15286450_7\">For <code>v1</code> and <code>v2</code>, the <code>initializer_list</code> object and array createdfor <code>{ 1, 2, 3 }</code> have full-expression lifetime. For <code>i3</code>, the initializer_list object and array have automatic lifetime. <em>\u2014 end example]</em></p>\n</blockquote>\n<hr>\n<h2>A little clarification about returning a braced-init-list</h2>\n<p>When you return a bare list enclosed in braces, </p>\n<blockquote>\n<p id=\"so_15286450_15286450_8\">A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n</blockquote>\n<p>This doesn't imply that the object returned to the calling scope is copied from something. For example, this is valid:</p>\n<pre><code>struct nocopy {\n    nocopy( int );\n    nocopy( nocopy const &amp; ) = delete;\n    nocopy( nocopy &amp;&amp; ) = delete;\n};\n\nnocopy f() {\n    return { 3 };\n}\n</code></pre>\n<p>this is not:</p>\n<pre><code>nocopy f() {\n    return nocopy{ 3 };\n}\n</code></pre>\n<p>Copy-list-initialization simply means the equivalent of the syntax <code>nocopy X = { 3 }</code> is used to initialize the object representing the return value. This doesn't invoke a copy, and it happens to be identical to the 8.5.4/6 example of an array's lifetime being extended.</p>\n<p>And Clang and GCC do <a href=\"http://liveworkspace.org/code/ClVhK%241\">agree</a> on this point.</p>\n<hr>\n<h2>Other notes</h2>\n<p>A review of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf\">N2640</a> doesn't turn up any mention of this corner case. There has been extensive discussion about the individual features combined here, but I don't see anything about their interaction.</p>\n<p>Implementing this gets hairy as it comes down to returning an optional, variable-length array by value. Because the <code>std::initializer_list</code> doesn't own its contents, the function has to also return something else which does. When passing to a function, this is simply a local, fixed-size array. But in the other direction, the VLA needs to be returned on the stack, along with the <code>std::initializer_list</code>'s pointers. Then the caller needs to be told whether to dispose of the sequence (whether they're on the stack or not).</p>\n<p>The issue is very easy to stumble upon by returning a braced-init-list from a lambda function, as a \"natural\" way to return a few temporary objects without caring how they're contained.</p>\n<pre><code>auto &amp;&amp; il = []() -&gt; std::initializer_list&lt; noisydt &gt;\n               { return { noisydt{}, noisydt{} }; }();\n</code></pre>\n<p>Indeed, this is similar to how I arrived here. But, it would be an error to leave out the <code>-&gt;</code> trailing-return-type because lambda return type deduction only occurs when an expression is returned, and a braced-init-list is not an expression.</p>\n</hr></hr></hr>", "Tags": "<c++><c++11><initializer-list><lifetime><brace-initialization>", "OwnerUserId": "153285", "AnswerCount": "2"}, "17635374": {"ParentId": "15286450", "CommentCount": "4", "Body": "<p>The wording you refer to in 8.5.4/6 is defective, and was corrected (somewhat) by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1290\">DR1290</a>. Instead of saying:</p>\n<blockquote>\n<p id=\"so_15286450_17635374_0\">The lifetime of the array is the same as that of the <code>initializer_list</code> object.</p>\n</blockquote>\n<p>... the amended standard now says:</p>\n<blockquote>\n<p id=\"so_15286450_17635374_1\">The array has the same lifetime as any other temporary object (12.2 [class.temporary]), except that initializing an <code>initializer_list</code> object from the array extends the lifetime of the array exactly like binding a reference to a temporary.</p>\n</blockquote>\n<p>Therefore the controlling wording for the lifetime of the temporary array is 12.2/5, which says:</p>\n<blockquote>\n<p id=\"so_15286450_17635374_2\">The lifetime of a temporary bound to the returned value in a function return statement is not extended; the temporary is destroyed at the end of the full-expression in the return statement</p>\n</blockquote>\n<p>Therefore the <code>noisydt</code> objects are destroyed before the function returns.</p>\n<p>Until recently, Clang had a bug that caused it to fail to destroy the underlying array for an <code>initializer_list</code> object in some circumstances. I've fixed that for Clang 3.4; the output for your test case from Clang trunk is:</p>\n<pre><code>destroyed\ndestroyed\ndestroyed\nreceived\ndestroyed\ndestroyed\ndestroyed\nreceived\n</code></pre>\n<p>... which is correct, per DR1290.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "17635374", "Score": "11", "CreationDate": "2013-07-14T00:18:33.907", "LastActivityDate": "2013-07-14T00:18:33.907"}, "bq_ids": {"n4140": {"so_15286450_15286450_0": {"section_id": 3913, "quality": 0.9230769230769231, "length": 12}, "so_15286450_17635374_0": {"section_id": 3328, "quality": 0.6666666666666666, "length": 4}, "so_15286450_15286450_8": {"section_id": 3913, "quality": 0.9230769230769231, "length": 12}, "so_15286450_15286450_7": {"section_id": 3328, "quality": 0.5294117647058824, "length": 9}, "so_15286450_15286450_3": {"section_id": 3325, "quality": 1.0, "length": 6}, "so_15286450_15286450_1": {"section_id": 3323, "quality": 1.0, "length": 5}, "so_15286450_15286450_2": {"section_id": 3294, "quality": 0.6666666666666666, "length": 4}, "so_15286450_15286450_5": {"section_id": 3327, "quality": 1.0, "length": 35}, "so_15286450_15286450_6": {"section_id": 3328, "quality": 0.5714285714285714, "length": 4}, "so_15286450_17635374_2": {"section_id": 382, "quality": 0.9375, "length": 15}, "so_15286450_15286450_4": {"section_id": 3325, "quality": 1.0, "length": 17}, "so_15286450_17635374_1": {"section_id": 3328, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_15286450_15286450_3": {"section_id": 3195, "quality": 1.0, "length": 6}, "so_15286450_15286450_0": {"section_id": 3773, "quality": 0.9230769230769231, "length": 12}, "so_15286450_15286450_1": {"section_id": 3193, "quality": 1.0, "length": 5}, "so_15286450_15286450_6": {"section_id": 3198, "quality": 0.7142857142857143, "length": 5}, "so_15286450_15286450_7": {"section_id": 3198, "quality": 0.7058823529411765, "length": 12}, "so_15286450_17635374_2": {"section_id": 373, "quality": 0.9375, "length": 15}, "so_15286450_15286450_8": {"section_id": 3773, "quality": 0.9230769230769231, "length": 12}, "so_15286450_15286450_4": {"section_id": 3195, "quality": 1.0, "length": 17}, "so_15286450_17635374_0": {"section_id": 3198, "quality": 0.8333333333333334, "length": 5}, "so_15286450_15286450_2": {"section_id": 3164, "quality": 0.6666666666666666, "length": 4}, "so_15286450_15286450_5": {"section_id": 3197, "quality": 1.0, "length": 35}}, "n4659": {"so_15286450_15286450_1": {"section_id": 4089, "quality": 0.8, "length": 4}, "so_15286450_17635374_0": {"section_id": 4094, "quality": 0.6666666666666666, "length": 4}, "so_15286450_15286450_6": {"section_id": 4094, "quality": 0.5714285714285714, "length": 4}, "so_15286450_15286450_7": {"section_id": 4094, "quality": 0.5294117647058824, "length": 9}, "so_15286450_15286450_3": {"section_id": 4091, "quality": 1.0, "length": 6}, "so_15286450_15286450_4": {"section_id": 4091, "quality": 0.5882352941176471, "length": 10}, "so_15286450_17635374_1": {"section_id": 4094, "quality": 0.8636363636363636, "length": 19}, "so_15286450_15286450_2": {"section_id": 4056, "quality": 0.6666666666666666, "length": 4}, "so_15286450_17635374_2": {"section_id": 397, "quality": 0.9375, "length": 15}, "so_15286450_15286450_5": {"section_id": 4093, "quality": 0.9142857142857143, "length": 32}}}, "15291159": {"ParentId": "15286450", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong><code>std::initializer_list</code> is not a container, don't use it to pass values around and expect them to persist</strong></p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1290\" rel=\"noreferrer\">DR 1290</a> changed the wording, you should also be aware of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1565\" rel=\"noreferrer\">1565</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1599\" rel=\"noreferrer\">1599</a> which aren't ready yet.</p>\n<blockquote>\n<p id=\"so_15286450_15291159_0\">Then the return value's array should also survive into the calling function, and it should be possible to preserve it by binding it to a named reference.</p>\n</blockquote>\n<p>No, that doesn't follow. The array's lifetime doesn't keep being extended along with the <code>initializer_list</code>.  Consider:</p>\n<pre><code>struct A {\n    const int&amp; ref;\n    A(const int&amp; i = 0) : ref(i) { }\n};\n</code></pre>\n<p>The reference <code>i</code> binds to the temporary <code>int</code>, and then the reference <code>ref</code> binds to it as well, but that doesn't extend the lifetime of <code>i</code>, it still goes out of scope at the end of the constructor, leaving a dangling reference.  You don't extend the underlying temporary's lifetime by binding another reference to it.</p>\n<p>Your code <em>might</em> be safer if <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1565\" rel=\"noreferrer\">1565</a> is approved and you make <code>il</code> a copy not a reference, but that issue is still open and doesn't even have proposed wording, let alone implementation experience.</p>\n<p>Even if your example is meant to work, the wording regarding lifetime of the underlying array is obviously still being improved and it will take a while for compilers to implement whatever final semantics are settled on.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2013-03-08T10:06:39.217", "Id": "15291159", "Score": "15", "CreationDate": "2013-03-08T09:54:37.203", "LastActivityDate": "2013-03-08T10:06:39.217"}});