post_cb({"17478621": {"CommentCount": "10", "CreationDate": "2013-07-04T22:02:39.037", "PostTypeId": "1", "AcceptedAnswerId": "17497838", "LastEditorUserId": "1690864", "LastActivityDate": "2013-10-11T20:09:26.647", "LastEditDate": "2013-07-07T10:00:52.030", "ViewCount": "579", "FavoriteCount": "1", "Title": "When instantiating a template, should members of its incomplete argument types be visible?", "Id": "17478621", "Score": "6", "Body": "<p>In the following example, <code>A</code> has a member typedef <code>Instantiate</code> which causes the instantiation of <code>B&lt;A&gt;</code>. </p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    typedef typename T::Before Before; // ok\n    typedef typename T::After After; // error: no type named 'After' in 'A&lt;int&gt;'\n};\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    typedef int Before;\n    typedef typename B&lt;A&gt;::After Instantiate;\n    typedef int After;\n};\n\ntemplate struct A&lt;int&gt;; // instantiate A&lt;int&gt;\n</code></pre>\n<p>All the compilers I've tried report that, while <code>A::Before</code> is visible, <code>A::After</code> is not. Is this behaviour compliant with the standard? If so, where does the standard specify which names in <code>A</code> should be visible during instantiation of <code>B&lt;A&gt;</code>?</p>\n<p>If dependent names are \"looked up at the point of the template instantiation\", what does this mean in the scenario of a name qualified by a template parameter such as <code>T::After</code>? </p>\n<p>EDIT: Note that the same behaviour occurs when A is not a template:</p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    typedef typename T::Before Before; // ok\n    typedef typename T::After After; // error: no type named 'After' in 'A'\n};\n\nstruct A\n{\n    typedef int Before;\n    typedef B&lt;A&gt;::After Instantiate;\n    typedef int After;\n};\n</code></pre>\n<p>.. and G++ accepts the following, but Clang does not: </p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    static const int value = 0;\n    static const int i = T::value; // clang error: not a constant expression\n};\n\nstruct A\n{\n    static const int value = B&lt;A&gt;::value;\n};\n</code></pre>\n<p>EDIT: After some reading of the C++03 standard:</p>\n<blockquote>\n<p id=\"so_17478621_17478621_0\">[temp.dep.type] A type is dependent if it is a template parameter</p>\n</blockquote>\n<p>Therefore <code>T</code> is dependent.</p>\n<blockquote>\n<p id=\"so_17478621_17478621_1\">[temp.res] When looking for the declaration of a name used in a template definition, the usual lookup rules are used for nondependent names. The lookup of names dependent on the template parameters is postponed until the actual template argument is known.</p>\n</blockquote>\n<p>The lookup of <code>T::After</code> is therefore postponed until the argument for <code>T</code> is known. </p>\n<blockquote>\n<p id=\"so_17478621_17478621_2\">[temp.inst] Unless a class template specialization has been explicitly instantiated ... the class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type.</p>\n</blockquote>\n<p>Therefore the declaration of <code>A&lt;int&gt;::Instantiate</code> requires the instantiation of <code>B&lt;A&gt;</code> (because it is used in a nested-name-specifier.)</p>\n<p><code>A&lt;int&gt;::After</code> is not visible at the point of declaration of <code>A&lt;int&gt;::Instantiate</code>, so the behaviour of the compiler makes sense - but I haven't seen anything in C++03 that explicitly describes this behaviour. The closest thing was this somewhat vague paragraph:</p>\n<blockquote>\n<p id=\"so_17478621_17478621_3\">[temp.dep.res]\n  In resolving dependent names, names from the following sources are considered:</p>\n<p id=\"so_17478621_17478621_4\">\u2014 Declarations that are visible at the point of definition of the template.</p>\n</blockquote>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "1690864", "AnswerCount": "2"}, "17497838": {"ParentId": "17478621", "CommentCount": "3", "Body": "<p>Whether <code>typename T::Before</code> is valid is not explicitly said by the spec. It is subject of a defect report (because the Standard can very reasonably be read to forbid it): <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#287</a> . </p>\n<p>Whether <code>typename T::After</code> is invalid can also very reasonably be read to be true by the spec, and actually it makes quite a bit of sense (and aforementioned DR still keeps it ill-formed). Because you have an instantiation of a class <code>A&lt;Foo&gt;</code>, which references another class <code>A&lt;Bar&gt;</code> during a period where a member <code>Baz</code> has not yet been declared, and that makes a reference back to <code>A&lt;Foo&gt;::Bar</code>. That is ill-formed in the case of non-templates aswell (try to \"forget\" for a moment that you are dealing with templates: surely the lookup of <code>B&lt;A&gt;::After</code> is done <em>after</em> the <code>A</code> template was completely parsed, but <em>not</em> after the specific instantiation of it was completely created. And it is the instantiation of it that actually will do the reference!).</p>\n<pre><code>struct A {\n   typedef int Foo;\n   typedef A::Foo Bar; // valid\n   typedef A::Baz Lulz; // *not* valid\n   typedef int Baz; \n};\n</code></pre>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "17497838", "Score": "4", "CreationDate": "2013-07-05T22:58:13.073", "LastActivityDate": "2013-07-05T22:58:13.073"}, "17479105": {"ParentId": "17478621", "LastEditDate": "2017-05-23T10:32:07.837", "CommentCount": "9", "CreationDate": "2013-07-04T23:07:39.943", "OwnerUserId": "420683", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "17479105", "Score": "2", "Body": "<p><code>T::Before</code> and <code>T::After</code> are dependent names due to [temp.dep.type]/8 and /5.</p>\n<p>Dependent names are looked up \"at the point of the template instantiation (14.6.4.1) in both the context of the template definition and the context of the point of instantiation.\" [temp.dep]/1</p>\n<p>I interpret this as: They're looked up when the template is instantiated. Where are they looked up? At the context of the template definition and the context of the point of instantiation.</p>\n<p>[temp.dep.type]/7 On the other hand states:</p>\n<blockquote>\n<p id=\"so_17478621_17479105_0\">If, for a given set of template arguments, a specialization of a template is instantiated that refers to a member of the current instantiation with a <em>qualified-id</em> or class member access expression, the name in the <em>qualified-id</em> or class member access expression is looked up in the template instantiation context.</p>\n</blockquote>\n<p>[temp.point]/7 Defines the <em>instantiation context</em> as follows:</p>\n<blockquote>\n<p id=\"so_17478621_17479105_1\">The instantiation context of an expression that depends on the template arguments is the set of declarations with external linkage declared prior to the point of instantiation of the template specialization in the same translation unit.</p>\n</blockquote>\n<p>Therefore, we need to know what the point of instantiation is.</p>\n<p>[temp.point]/4</p>\n<blockquote>\n<p id=\"so_17478621_17479105_2\">For a class template specialization [...], if the specialization is implicitly instantiated because it is referenced from within another template specialization, if the context from which the specialization is referenced depends on a template parameter, and if the specialization is not instantiated previous to the instantiation of the\n  enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing template.</p>\n</blockquote>\n<p><strike>Although the injected class name <code>A</code> is arguably a context that <em>depends</em> (as a layman term) on the template parameters of <code>A</code>, the name <code>A</code> itself is not a dependent name.</strike> Correction by <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a>: It <em>is</em> a dependent name. See [temp.local]/1 and [temp.dep.type]/8 =&gt; <code>A</code> is a dependent type.</p>\n<p>Therefore, this condition <strong>is</strong> <strike>not</strike> fulfilled, and <code>B&lt;A&gt;</code> should be instantiated before <code>A&lt;int&gt;</code>.</p>\n", "LastActivityDate": "2013-10-11T20:09:26.647"}, "bq_ids": {"n4140": {"so_17478621_17478621_3": {"section_id": 215, "quality": 0.8571428571428571, "length": 6}, "so_17478621_17479105_0": {"section_id": 197, "quality": 1.0, "length": 26}, "so_17478621_17478621_0": {"section_id": 198, "quality": 0.8, "length": 4}, "so_17478621_17478621_4": {"section_id": 215, "quality": 1.0, "length": 5}, "so_17478621_17479105_2": {"section_id": 219, "quality": 0.9696969696969697, "length": 32}, "so_17478621_17479105_1": {"section_id": 222, "quality": 0.95, "length": 19}, "so_17478621_17478621_1": {"section_id": 176, "quality": 0.9166666666666666, "length": 22}, "so_17478621_17478621_2": {"section_id": 233, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_17478621_17478621_3": {"section_id": 209, "quality": 0.8571428571428571, "length": 6}, "so_17478621_17478621_0": {"section_id": 192, "quality": 0.8, "length": 4}, "so_17478621_17478621_2": {"section_id": 226, "quality": 0.9047619047619048, "length": 19}, "so_17478621_17478621_4": {"section_id": 209, "quality": 1.0, "length": 5}, "so_17478621_17479105_2": {"section_id": 212, "quality": 0.9696969696969697, "length": 32}, "so_17478621_17479105_1": {"section_id": 215, "quality": 0.95, "length": 19}, "so_17478621_17478621_1": {"section_id": 170, "quality": 0.9166666666666666, "length": 22}, "so_17478621_17479105_0": {"section_id": 191, "quality": 1.0, "length": 26}}, "n4659": {"so_17478621_17478621_3": {"section_id": 223, "quality": 0.8571428571428571, "length": 6}, "so_17478621_17479105_0": {"section_id": 203, "quality": 1.0, "length": 26}, "so_17478621_17478621_0": {"section_id": 146, "quality": 0.8, "length": 4}, "so_17478621_17478621_4": {"section_id": 223, "quality": 1.0, "length": 5}, "so_17478621_17479105_2": {"section_id": 227, "quality": 0.9696969696969697, "length": 32}, "so_17478621_17479105_1": {"section_id": 230, "quality": 0.95, "length": 19}, "so_17478621_17478621_1": {"section_id": 181, "quality": 0.9166666666666666, "length": 22}, "so_17478621_17478621_2": {"section_id": 242, "quality": 0.9047619047619048, "length": 19}}}});