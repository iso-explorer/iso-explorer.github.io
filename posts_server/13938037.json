post_cb({"13938037": {"ViewCount": "107", "Body": "<p>Why does the following code prints different results on different compilers?</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo() { std::cout &lt;&lt; \"::foo() \\n\"; }\n\nnamespace Foo\n{\n   struct Bar\n   {\n      friend void foo() { std::cout &lt;&lt; \"Bar::foo() \\n\"; }\n      void bar() { foo(); }\n      void baz();\n   };\n\n   void Bar::baz() { foo(); }\n}\n\nint main()\n{\n   Foo::Bar instance;\n   instance.bar();\n   instance.baz();\n}\n</code></pre>\n<p><strong>Output</strong></p>\n<p>gcc 4.7.2</p>\n<blockquote id=\"so_13938037_13938037_0\">\n<pre><code>::foo()\n::foo()\n</code></pre>\n</blockquote>\n<p>MSVC-10.0</p>\n<blockquote id=\"so_13938037_13938037_1\">\n<pre><code>Bar::foo()\nBar::foo()\n</code></pre>\n</blockquote>\n<p>MSVC-11.0</p>\n<blockquote id=\"so_13938037_13938037_2\">\n<pre><code>error C3861: 'foo': identifier not found\nerror C3861: 'foo': identifier not found\n</code></pre>\n</blockquote>\n<p>Who is right? And why is it so?</p>\n", "Title": "Different output on different compilers", "CreationDate": "2012-12-18T17:08:51.477", "LastActivityDate": "2012-12-18T17:47:05.233", "CommentCount": "2", "PostTypeId": "1", "Id": "13938037", "Score": "3", "OwnerUserId": "1608835", "Tags": "<c++>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13938037_13938383_0": {"length": 24, "quality": 0.6486486486486487, "section_id": 5485}}, "n3337": {"so_13938037_13938383_0": {"length": 28, "quality": 0.7567567567567568, "section_id": 5271}}, "n4659": {"so_13938037_13938383_0": {"length": 24, "quality": 0.6486486486486487, "section_id": 6920}}}, "13938383": {"Id": "13938383", "PostTypeId": "2", "Body": "<p>I think gcc is right:</p>\n<p>7.3.1.2/3 in C++11:</p>\n<blockquote>\n<p id=\"so_13938037_13938383_0\">If a friend declaration in a non-\n  local class \ufb01rst declares a class or function the friend class or\n  function is a member of the innermost enclosing namespace. The name of\n  the friend is not found by unquali\ufb01ed lookup (3.4.1) or by quali\ufb01ed\n  lookup (3.4.3) until a matching declaration is provided in that\n  namespace scope (either before or after the class de\ufb01nition</p>\n</blockquote>\n<p>C++03 has similar language in the same place.</p>\n<p>I'm not sure why MSVC-11 fails to find <code>::foo</code>, but I suppose you <em>could</em> read this text to mean that the name <code>foo</code> can't be looked up at all. I think the intended meaning is that the name in the innermost enclosing namespace can't be found, but the identically-spelled name in the outer scope can. But if Microsoft wants to argue the intended meaning I'm not the person they'd argue it with.</p>\n<p>MSVC-10 is wrong, because it found a name that the standard specifically says is not found. So the explanation for the MSVC-11 behavior might be as simple as \"it was reported as a bug in 10, they tried to fix it and went too far\".</p>\n<p>Anyway, the fix is to introduce a declaration of <code>foo</code> in namespace <code>Foo</code>:</p>\n<pre><code>namespace Foo\n{\n   void foo(); // this is a matching declaration\n   struct Bar\n   {\n      friend void foo() { std::cout &lt;&lt; \"Bar::foo() \\n\"; }\n      void bar() { foo(); }\n      void baz();\n   };\n\n   void Bar::baz() { foo(); }\n}\n</code></pre>\n<p>This makes gcc find the friend function. I haven't tested on any version of MSVC.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-12-18T17:47:05.233", "Score": "2", "CreationDate": "2012-12-18T17:30:59.973", "ParentId": "13938037", "CommentCount": "4", "LastEditDate": "2012-12-18T17:47:05.233", "OwnerUserId": "13005"}});