post_cb({"10820974": {"CommentCount": "2", "AcceptedAnswerId": "10821000", "CreationDate": "2012-05-30T17:08:35.460", "LastActivityDate": "2012-05-30T17:38:07.377", "PostTypeId": "1", "ViewCount": "214", "FavoriteCount": "1", "Title": "C++ virtual method not working", "Id": "10820974", "Score": "3", "Body": "<p>Given the following example:</p>\n<pre><code>class BaseClass\n{\n  BaseClass()\n  {\n  };\n\n  virtual ~BaseClass()\n  {\n    this-&gt;Cleanup();\n  };\n\n  virtual void Cleanup()\n  {\n    // Do cleanup here.\n  };\n};\n\nclass Level1DerivedClass : public BaseClass\n{\n  Level1DerivedClass()\n  {\n  };\n\n  virtual ~Level1DerivedClass()\n  {\n  };\n\n  virtual void Cleanup()\n  {\n    // Call my base cleanup.\n    BaseClass::Cleanup();\n\n    // Do additional cleanup here.\n  };\n};\n\nclass Level2DerivedClass : public Level1DerivedClass\n{\n  Level2DerivedClass()\n  {\n  };\n\n  ~Level2DerivedClass()\n  {\n  };\n\n  void Cleanup()\n  {\n    // Call my base cleanup.\n    Level1DerivedClass::Cleanup();\n\n    // Do additional cleanup here.\n  };  \n};\n\n\nmain()\n{\n  Level2DerivedClass * derived2 = new Level2DerivedClass();\n  delete derived2;\n  return 0;\n}\n</code></pre>\n<p>When I delete my derived class reference, I would <strong>EXPECT</strong> the flow would be as follows:</p>\n<ol>\n<li><em>Level2DerivedClass</em> destructor is executed.</li>\n<li>Because <em>Level1DerivedClass</em> destructor is virtual, it would be executed.</li>\n<li>Because <em>BaseClass</em> destructor is virtual, it would be executed.</li>\n<li>Because <em>BaseClass::Cleanup</em> and <em>Level1DerivedClass::Cleanup</em> are both virtual, the call from the <em>BaseClass</em> 'this' pointer in the <em>BaseClass</em> destructor would executed the implementation of the most derived class - <em>Level2DerivedClass::Cleanup</em>.</li>\n<li><em>Level2DerivedClass::Cleanup</em> calls its parent's <em>Cleanup</em> implementation.</li>\n<li><em>Level1DerivedClass::Cleanup</em> calls its parent's <em>Cleanup</em> implementation.</li>\n</ol>\n<p>What is happening is that it is calling the destructors for each level of inheritance (1 - 3) above the way I'm expecting. But when <em>this-&gt;Cleanup()</em> is called from the <em>BaseClass</em> destructor, it only executes its own implementation. I don't understand why this is happening because normally when you instantiate a derived class pointer, cast it as a base class pointer, and call a virtual method from the base class pointer (in this case, 'this'), it still runs the derived class implementation (the whole point of 'virtual', yes?). In my example, <em>Level2DerivedClass::Cleanup</em> and <em>Level1DerivedClass::Cleanup</em> never gets called.</p>\n<p>The reason I'm setting it up this way is I want to be able to call my Cleanup code without having to destroy my object, which is why I'm abstracting it from the actual destructor body.</p>\n<p>If you have suggestions on a more proper way to do this, I'm all ears. But I would also like an explanation of why my setup doesn't work - what am I misunderstanding?</p>\n<p>Thank you in advance for your time.</p>\n", "Tags": "<c++><function><inheritance><methods><virtual>", "OwnerUserId": "381246", "AnswerCount": "2"}, "10821320": {"ParentId": "10820974", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-05-30T17:32:56.273", "Score": "2", "LastEditorUserId": "775806", "LastEditDate": "2012-05-30T17:38:07.377", "Id": "10821320", "OwnerUserId": "775806", "Body": "<p>The Proper Way Of Doing Things is: <em>clean after yourself, and yourself only, in the destructor</em>.  Don't clean after your kids or your parents.</p>\n<p>If you want to clean up things <em>not</em> from the destructor, You Are Doing It Wrong. In C++ we have this little thing called RAII, Resource Acquisition Is Initialization. But there's also its dual, which does not seem to have an officially sounding name, but here's something that could work: RDID, Resource Disposal Is Destruction.</p>\n<p>Of course you don't have to adhere to the RAII/RDID philosophy, but that would be Not The C++ Way.</p>\n", "LastActivityDate": "2012-05-30T17:38:07.377"}, "bq_ids": {"n4140": {"so_10820974_10821000_0": {"section_id": 447, "quality": 0.5416666666666666, "length": 26}}, "n3337": {"so_10820974_10821000_0": {"section_id": 438, "quality": 0.5416666666666666, "length": 26}}, "n4659": {"so_10820974_10821000_0": {"section_id": 469, "quality": 0.5416666666666666, "length": 26}}}, "10821000": {"ParentId": "10820974", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-05-30T17:10:46.517", "Score": "7", "LastEditorUserId": "129570", "LastEditDate": "2012-05-30T17:18:52.457", "Id": "10821000", "OwnerUserId": "129570", "Body": "<p>The rule of thumb is: <a href=\"http://www.artima.com/cppsource/nevercall.html\" rel=\"nofollow\"><em>Never Call Virtual Functions during Construction or Destruction</em></a>.</p>\n<p>They don't behave as you might expect; as each destructor finishes, the dynamic type of <code>this</code> is effectively modified.  From [class.cdtor] in the C++ standard:</p>\n<blockquote>\n<p id=\"so_10820974_10821000_0\">When a virtual function is called directly or indirectly from a constructor (including the mem-initializer or\n  brace-or-equal-initializer for a non-static data member) or from a destructor, and the object to which the\n  call applies is the object under construction or destruction, the function called is the one defined in the\n  constructor or destructor\u2019s own class or in one of its bases, but not a function overriding it in a class derived\n  from the constructor or destructor\u2019s class, or overriding it in one of the other base classes of the most derived\n  object.</p>\n</blockquote>\n", "LastActivityDate": "2012-05-30T17:18:52.457"}});