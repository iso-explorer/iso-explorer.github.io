post_cb({"bq_ids": {"n4140": {"so_8766576_8766619_0": {"section_id": 214, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_8766576_8766619_0": {"section_id": 208, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_8766576_8766619_0": {"section_id": 222, "quality": 0.9166666666666666, "length": 11}}}, "8766576": {"CommentCount": "12", "AcceptedAnswerId": "8766619", "PostTypeId": "1", "ClosedDate": "2012-01-07T11:08:17.350", "LastEditorUserId": "-1", "CreationDate": "2012-01-07T01:29:54.730", "LastActivityDate": "2012-01-07T11:11:26.633", "LastEditDate": "2017-05-23T11:48:07.613", "ViewCount": "326", "FavoriteCount": "1", "Title": "Protected member of templated superclass should be visible in subclass, but (sometimes) isn\u2019t", "Id": "8766576", "Score": "1", "Body": "<blockquote>\n<p id=\"so_8766576_8766576_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/605497/accessing-inherited-variable-from-templated-parent-class\">Accessing inherited variable from templated parent class</a> </br></p>\n</blockquote>\n<p>I have been implementing a binary heap as a subclass of priority_queue, and run into a situation I cannot understand, despite considerable effort. Here is the <strong>working</strong> version of the code. (Background: <code>c</code> is priority_queue\u2019s backing vector.)</p>\n<pre><code>#include &lt;queue&gt;\nusing namespace std;\n\ntemplate &lt;class nodetype&gt;\nclass BinaryHeap : public priority_queue&lt;int&gt; {\npublic:\n    BinaryHeap() { vec = &amp;c; }\n    vector&lt;nodetype&gt; *vec;\n};\n\nint main() {\n    BinaryHeap&lt;int&gt; b;\n}\n</code></pre>\n<p>However, when you change the superclass to:</p>\n<pre><code>class BinaryHeap : public priority_queue&lt;nodetype&gt;\n</code></pre>\n<p>...the compiler complains about the usage of <code>c</code>:</p>\n<pre><code>h.cpp: In constructor \u2018BinaryHeap&lt;nodetype&gt;::BinaryHeap()\u2019:\nh.cpp:10: error: \u2018c\u2019 was not declared in this scope\n</code></pre>\n<p>This seems all the more strange because:</p>\n<ol>\n<li><p>\u201c[c] is equivalent to this-&gt;c\u201d (<a href=\"http://ben.am/eH\" rel=\"nofollow noreferrer\">ref</a>) \u2013\u00a0and if you use <code>vec = &amp;this-&gt;c</code>, it does indeed compile.</p></li>\n<li><p>If you add a using-declaration, <code>using priority_queue&lt;nodetype&gt;::c</code> to BinaryHeap, again, it compiles. But this using-declaration ought to be unnecessary.</p></li>\n</ol>\n<p><strong>Edit:</strong></p>\n<p>So, apparently this happens because \u201cthe compiler does not look in dependent base classes when looking up nondependent names\u201d (<a href=\"http://www.parashift.com/c++-faq-lite/templates.html#faq-35.19\" rel=\"nofollow noreferrer\">ref</a>) \u2013\u00a0\u201c<code>c</code>\u201d does not depend on a template parameter, and so is nondependent, and <code>priority_queue&lt;nodetype&gt;</code> does depend on a template parameter \u2013 <code>nodetype</code> \u2013 so is dependent.</p>\n<p><code>priority_queue&lt;int&gt;</code>, on the other hand, doesn\u2019t depend on <code>nodetype</code>, and so is nondependent, and so the compiler <em>does</em> look in it for names when resolving other nondependent names.</p>\n<p>Is this correct? And if so:</p>\n<p>Why does the standard mandate this behaviour, when \u201c[looking] in dependent base classes when looking up nondependent names\u201d is clearly <em>possible</em>. What is the benefit? A compile-time performance optimisation?</p>\n", "Tags": "<c++><templates><inheritance>", "OwnerUserId": "196312", "AnswerCount": "1"}, "8766619": {"ParentId": "8766576", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In the end its simply a matter of the standard defining such a behaviour for templates. The (C++11) standard says the following about non dependent name resolution in <strong>[temp.nondep] (14.6.3)</strong> :</p>\n<blockquote>\n<p id=\"so_8766576_8766619_0\">Non-dependent names used in a template de\ufb01nition are found using the usual name lookup and bound at the point they are used.</p>\n</blockquote>\n<p>Since <code>c</code> doesn't obviously depend on a template parameter the compiler treats it as a non-dependent name. So what happens is basically the following: When the compiler looks at <code>BinaryHeap</code> the actual type of <code>notetype</code> is unknown and therefore <code>priority_queue&lt;nodetype&gt;</code> is too, since it depends on <code>nodetype</code> (it could be a partial specialization). Therefore the compiler can't look into that type for the resolution (since we are talking about the point where the template is defined, not where it is instantiated). So it looks in the containing scopes for something called <code>c</code>, finding none and therefore rejecting the code.  Using <code>this-&gt;c</code> (or <code>using priority_queue&lt;nodetype&gt;::c</code>) makes <code>c</code> a dependent name (since its not a member of <code>BinaryHeap</code> it must be a member of <code>priority_queue&lt;nodetype&gt;</code>), so the name lookup is delayed until the point of instantiation of the template, where <code>notetype</code> is known and the compiler can therefore search in <code>priority_queue&lt;nodetype&gt;</code>.</p>\n<p>For your edit: yes, that is correct</p>\n", "OwnerUserId": "201270", "LastEditorUserId": "201270", "LastEditDate": "2012-01-07T02:51:53.793", "Id": "8766619", "Score": "2", "CreationDate": "2012-01-07T01:38:30.560", "LastActivityDate": "2012-01-07T02:51:53.793"}});