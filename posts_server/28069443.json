post_cb({"38524181": {"ParentId": "28069443", "CommentCount": "0", "Body": "<p>N.B. there are a couple of issues with your code. In C++14 if you replace <code>operator delete(void*)</code> then you must also replace <code>operator delete(void*, std::size)t)</code>. You can use a feature-test macro to see if the compiler requires that:</p>\n<pre><code>void operator delete( void *p ) {\n    free( p );\n}\n#if __cpp_sized_deallocation\n// Also define sized-deallocation function:\nvoid operator delete( void *p, std::size_t ) {\n    free( p );\n}\n#endif\n</code></pre>\n<p>Secondly the correct printf format specifier for <code>size_t</code> is <code>zu</code> not <code>u</code>, so you should be using <code>%Izu</code>.</p>\n<blockquote>\n<p id=\"so_28069443_38524181_0\">AFAICT, MSVC's <code>std::mutex</code> does an unavoidable heap allocation, and therefore, so does <code>std::promise</code> which uses it. Is this a conformant behaviour?</p>\n</blockquote>\n<p>It's certainly questionable whether <code>std::mutex</code> should use dynamic allocation. Its constructor can't, because it must be <code>constexpr</code>. It could delay the allocation until the first call to <code>lock()</code> or <code>try_lock()</code> but <code>lock()</code> doesn't list failure to acquire resources as a valid error condition, and it means <code>try_lock()</code> could fail to lock an uncontended mutex if it can't allocate the resources it needs. That's allowed, if you squint at it, but is not ideal.</p>\n<p>But regarding your main question, as you quoted, the standard only says this for <code>promise</code>:</p>\n<blockquote>\n<p id=\"so_28069443_38524181_1\">The second constructor uses the allocator <code>a</code> to allocate memory for the shared state.</p>\n</blockquote>\n<p>That doesn't say anything about <em>other</em> resources needed by the promise. It's reasonable to assume that any synchronization objects like mutexes are part of the shared state, not the promise, but that wording doesn't require that the allocator is used for memory the shared state's members require, only for the memory needed by the shared state itself.</p>\n<p>For <code>packaged_task</code> the wording is broader and implies that all internal state should use the allocator, although it could be argued that it means the allocator is used to obtain memory for the stored task and the shared state, but again that members of the shared state don't have to use the allocator.</p>\n<p>In summary, I don't think the standard is 100% clear whether the MSVC implementation is allowed, but IMHO an implementation that does not need additional memory from <code>malloc</code> or <code>new</code> is better (and that's how the libstdc++ <code>&lt;future&gt;</code> implementation works).</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "38524181", "Score": "1", "CreationDate": "2016-07-22T10:30:32.593", "LastActivityDate": "2016-07-22T10:30:32.593"}, "28069443": {"CommentCount": "3", "AcceptedAnswerId": "38524181", "PostTypeId": "1", "LastEditorUserId": "1558356", "CreationDate": "2015-01-21T14:20:03.890", "LastActivityDate": "2016-07-22T10:30:32.593", "LastEditDate": "2015-01-22T09:10:58.827", "ViewCount": "335", "FavoriteCount": "1", "Title": "Custom allocators vs. promises and packaged tasks", "Id": "28069443", "Score": "7", "Body": "<p>Are the allocator-taking constructors of standard <code>promise</code>/<code>packaged_task</code> supposed to use the allocator for just the state object itself, or should this be guaranteed for <em>all</em> (internal) related objects?</p>\n<blockquote>\n<p id=\"so_28069443_28069443_0\">[futures.promise]: \"...allocate memory for the shared state\"<br>\n  [futures.task.members]: \"...allocate memory needed to store the internal data structures\"</br></p>\n</blockquote>\n<p>In particular, are the below bugs or features?</p>\n<p>*MSVC 2013.4, Boost 1.57, <a href=\"http://howardhinnant.github.io/short_alloc.h\">short_alloc.h by Howard Hinnant</a></p>\n<p><strong>Example 1</strong></p>\n<pre><code>#define BOOST_THREAD_VERSION 4\n#include &lt;boost/thread/future.hpp&gt;\n#include \"short_alloc.h\"\n#include &lt;cstdio&gt;\n\nvoid *operator new( std::size_t s ) {\n    printf( \"alloc %Iu\\n\", s );\n    return malloc( s );\n}\n\nvoid operator delete( void *p ) {\n    free( p );\n}\n\nint main() {\n\n    const int N = 1024;\n    arena&lt; N &gt; a;\n    short_alloc&lt; int, N &gt; al( a );\n\n    printf( \"[promise]\\n\" );\n    auto p = boost::promise&lt; int &gt;( std::allocator_arg, al );\n    p.set_value( 123 );\n\n    printf( \"[packaged_task]\\n\" );\n    auto q = boost::packaged_task&lt; int() &gt;( std::allocator_arg, al, [] { return 123; } );\n    q();\n\n    return 0;\n\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>...\n[promise]\nalloc 8\nalloc 12\nalloc 8\nalloc 24\n[packaged_task]\nalloc 8\nalloc 12\nalloc 8\nalloc 24\n</code></pre>\n<p>FWIW, the output with the default allocator is</p>\n<pre><code>...\n[promise]\nalloc 144\nalloc 8\nalloc 12\nalloc 8\nalloc 16\n[packaged_task]\nalloc 160\nalloc 8\nalloc 12\nalloc 8\nalloc 16\n</code></pre>\n<p><strong>Example 2</strong></p>\n<p>AFAICT, MSVC's <code>std::mutex</code> does an unavoidable heap allocation, and therefore, so does <code>std::promise</code> which uses it. Is this a conformant behaviour?</p>\n", "Tags": "<visual-c++><c++11><boost><language-lawyer><c++14>", "OwnerUserId": "1558356", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28069443_38524181_1": {"section_id": 3081, "quality": 0.8888888888888888, "length": 8}, "so_28069443_28069443_0": {"section_id": 3172, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_28069443_38524181_1": {"section_id": 2958, "quality": 0.8888888888888888, "length": 8}, "so_28069443_28069443_0": {"section_id": 3045, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_28069443_38524181_1": {"section_id": 3841, "quality": 0.8888888888888888, "length": 8}}}});