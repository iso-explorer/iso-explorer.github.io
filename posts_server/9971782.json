post_cb({"9971931": {"ParentId": "9971782", "CommentCount": "0", "Body": "<p>If a constructor throws exception, then the destructor of the class will not be called, because the object is not fully constructed.</p>\n<p>See this link how to manage resources in such situation:</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.10\" rel=\"nofollow\">http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.10</a></p>\n", "OwnerUserId": "790713", "PostTypeId": "2", "Id": "9971931", "Score": "0", "CreationDate": "2012-04-02T06:44:57.857", "LastActivityDate": "2012-04-02T06:44:57.857"}, "9971824": {"ParentId": "9971782", "CommentCount": "6", "Body": "<p>Because calling the destructor doesn't make sense in this case.</p>\n<p>You only destruct things which are constructed, yet your object never fully constructs. Your class <em>members</em> have been constructed, though, and will have their destructors called.</p>\n", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "9971824", "Score": "7", "CreationDate": "2012-04-02T06:36:41.487", "LastActivityDate": "2012-04-02T06:36:41.487"}, "9971782": {"CommentCount": "1", "AcceptedAnswerId": "9972063", "PostTypeId": "1", "LastEditorUserId": "806299", "CreationDate": "2012-04-02T06:32:25.370", "LastActivityDate": "2012-04-02T10:20:05.190", "LastEditDate": "2012-04-02T09:30:34.507", "ViewCount": "4513", "FavoriteCount": "4", "Title": "Destructor not invoked when an exception is thrown in the constructor", "Id": "9971782", "Score": "7", "Body": "<p>Why is the destructor not invoked in this code?</p>\n<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;\n#include &lt;iostream&gt;\n\nclass MyClass {\nboost::scoped_ptr&lt;int&gt; ptr;\npublic:\nMyClass() : ptr(new int) { *ptr = 0; throw; std::cout&lt;&lt;\"MyClass Allocated\\n\"; }\n~MyClass() { std::cout&lt;&lt;\"MyClass De-allocated\\n\"; }\nint increment() { return ++*ptr; }\n};\n\nint main()\n{\n    boost::scoped_ptr&lt;MyClass&gt; myinst(new MyClass);\n    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\\n';\n    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\\n';\n}\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>From the answers, In understand that when an exception happens in the constructor, destructor will not be invoked. But if the exception happens in the main(), ie after the MyClass object is fully instantiated, will the MyClass destructor be invoked? If not, then why it is a smart pointer?</p>\n<p>Adding the code</p>\n<pre><code>#include &lt;boost/scoped_ptr.hpp&gt;\n#include &lt;iostream&gt;\n\nclass MyClass {\n    boost::scoped_ptr&lt;int&gt; ptr;\n    public:\n    MyClass() : ptr(new int) { *ptr = 0; std::cout&lt;&lt;\"MyClass Allocated\\n\"; }\n    ~MyClass() { std::cout&lt;&lt;\"MyClass De-allocated\\n\"; }\n    int increment() { return ++*ptr; }\n};\n\nint main()\n{\n    boost::scoped_ptr&lt;MyClass&gt; myinst(new MyClass);\n    throw 3;\n    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\\n';\n    std::cout &lt;&lt; myinst-&gt;increment() &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>MyClass Allocated\nterminate called after throwing an instance of 'int'\nAborted\n</code></pre>\n", "Tags": "<c++><boost><scoped-ptr>", "OwnerUserId": "806299", "AnswerCount": "5"}, "9971832": {"ParentId": "9971782", "CommentCount": "0", "Body": "<p>When the exception is thrown from the constructor (beginning or half way or at the end of the call), then it's assured that the object is not constructed.<br>\nSo it's well defined not to invoke the destructor of an object which was never constructed.</br></p>\n<p>Here is one related <a href=\"http://www2.research.att.com/~bs/bs_faq2.html#ctor-exceptions\" rel=\"nofollow\">FAQ</a> from Bjarne's website.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "9971832", "Score": "0", "CreationDate": "2012-04-02T06:37:21.183", "LastActivityDate": "2012-04-02T06:37:21.183"}, "9971918": {"ParentId": "9971782", "CommentCount": "0", "Body": "<p>The destructor for <code>MyClass</code> was never invoked because no objects of type <code>MyClass</code> were ever constructed. Each attempt to construct one was aborted, due to the exception being thrown.</p>\n<p>As an aside, if you want your debug messages to display -- especially if you're dealing with the program crashing -- you <em>really</em> ought to flush the streams: i.e. using <code>std::endl</code> instead of <code>'\\n'</code> at the end of line. (or inserting <code>std::flush</code>)</p>\n<p>While merely using <code>'\\n'</code> often works, there are enough situations where it fails and it's really, <em>really</em> confusing to debug if you don't make a habit of doing things right.</p>\n", "OwnerUserId": "1084944", "PostTypeId": "2", "Id": "9971918", "Score": "0", "CreationDate": "2012-04-02T06:44:01.153", "LastActivityDate": "2012-04-02T06:44:01.153"}, "bq_ids": {"n4140": {"so_9971782_9972063_10": {"section_id": 3382, "quality": 0.9047619047619048, "length": 19}, "so_9971782_9972063_12": {"section_id": 3383, "quality": 0.8648648648648649, "length": 32}}, "n3337": {"so_9971782_9972063_10": {"section_id": 3251, "quality": 0.9047619047619048, "length": 19}, "so_9971782_9972063_12": {"section_id": 3252, "quality": 0.8648648648648649, "length": 32}}, "n4659": {"so_9971782_9972063_10": {"section_id": 4142, "quality": 0.9047619047619048, "length": 19}, "so_9971782_9972063_12": {"section_id": 4143, "quality": 0.8648648648648649, "length": 32}}}, "9972063": {"ParentId": "9971782", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>A C++ object's lifetime begins only after its constructor completes successfully.<br>\nSince the exception was thrown before constructor call was complete you don't have an complete object and hence no destructor.     </br></p>\n<p>Herb Sutter <a href=\"http://www.gotw.ca/publications/mill13.htm\" rel=\"noreferrer\">explains this nicely</a>, to quote him: </p>\n<blockquote>\n<p id=\"so_9971782_9972063_0\"><strong>Q:</strong> <strong>What does emitting an exception from a constructor mean?</strong></p>\n<p id=\"so_9971782_9972063_1\">A:   It means that construction has failed, the object never existed, its lifetime never began. Indeed, the only way to report the failure of construction -- that is, the inability to correctly build a functioning object of the given type -- is to throw an exception. (Yes, there is a now-obsolete programming convention that said, \"if you get into trouble just set a status flag to 'bad' and let the caller check it via an IsOK() function.\" I'll comment on that presently.)</p>\n<p id=\"so_9971782_9972063_2\">In biological terms,<br>\n<strong><em>conception took place -- the constructor began -- but despite best efforts it was followed by a miscarriage -- the constructor never ran to term(ination).</em></strong> </br></p>\n<p id=\"so_9971782_9972063_3\">Incidentally, <strong><em>this is why a destructor will never be called if the constructor didn't succeed -- there's nothing to destroy. <code>\"It cannot die, for it never lived.\"</code> Note that this makes the phrase <code>\"an object whose constructor threw an exception\"</code> really an oxymoron. Such a thing is even less than an ex-object... it never lived, never was, never breathed its first. It is a non-object.</em></strong></p>\n<p id=\"so_9971782_9972063_4\">We might summarize the C++ constructor model as follows:</p>\n<p id=\"so_9971782_9972063_5\">Either:</p>\n<p id=\"so_9971782_9972063_6\">(a) The constructor returns normally by reaching its end or a return statement, and the object exists.</p>\n<p id=\"so_9971782_9972063_7\">Or:</p>\n<p id=\"so_9971782_9972063_8\">(b) The constructor exits by emitting an exception, and the object not only does not now exist, but never existed as an object.</p>\n</blockquote>\n<p><strong>EDIT 1:</strong><br>\n<strong>But if the exception happens in the <code>main()</code>, ie after the <code>MyClass</code> object is fully instantiated, will the <code>MyClass</code> destructor be invoked?</strong> </br></p>\n<p>Yes, it will be!<br>\nThat is the purpose of using <code>scoped_ptr</code>, Once an exception is thrown in <code>main</code>, Stack Unwinding would cause all local objects to be deallocated, this means that <code>myinst</code>(which resides on stack) will also be deallocated, which in turn will call the destructor of <code>MyClass</code>.     </br></p>\n<p>Refer the <strong><a href=\"http://www.boost.org/doc/libs/1_38_0/libs/smart_ptr/scoped_ptr.htm\" rel=\"noreferrer\">Boost doccumentation</a></strong> when in doubt:   </p>\n<blockquote>\n<p id=\"so_9971782_9972063_9\">The <code>scoped_ptr</code> class template stores a pointer to a dynamically allocated object. (Dynamically allocated objects are allocated with the C++ new expression.) <strong>The object pointed to is guaranteed to be deleted, either on destruction of the <code>scoped_ptr</code>, or via an explicit <code>reset</code></strong> </p>\n</blockquote>\n<p><strong>EDIT 2:</strong><br>\n<strong>Why does your edited program crash?</strong><br>\nYour program shows crashes because, You throw an exception but you never catch it. when such a scenario occurs an special function called <code>terminate()</code> is called whose default behavior is to call <code>abort()</code>.It is implementation defined behavior whether stack is Unwound before <code>terminate()</code> is called in this particular scenario<sup>Ref 1</sup>.Seems your implementation doesn't &amp; you should not rely on this behavior as well.     </br></br></p>\n<p>You can modify your program as follows to handle the exception and you should get the behavior you were expecting:      </p>\n<pre><code>#include &lt;boost/scoped_ptr.hpp&gt; \n#include &lt;iostream&gt; \n\nclass MyClass { \n    boost::scoped_ptr&lt;int&gt; ptr; \n    public: \n    MyClass() : ptr(new int) { *ptr = 0; std::cout&lt;&lt;\"MyClass Allocated\\n\"; } \n    ~MyClass() { std::cout&lt;&lt;\"MyClass De-allocated\\n\"; } \n    int increment() { return ++*ptr; } \n}; \n\nvoid doSomething()\n{\n    boost::scoped_ptr&lt;MyClass&gt; myinst(new MyClass); \n    throw 3; \n} \n\nint main() \n{\n    try \n    {\n        doSomething();    \n    }\n    catch(int &amp;obj)\n    {\n        std::cout&lt;&lt;\"Exception Handled\";\n    }\n\n} \n</code></pre>\n<hr>\n<p><sup>Ref<a href=\"http://www.gotw.ca/publications/mill13.htm\" rel=\"noreferrer\">1</a></sup><strong>C++03 15.5.1 The terminate() function</strong> </p>\n<blockquote>\n<p id=\"so_9971782_9972063_10\">In the following situations exception handling must be abandoned for less subtle error handling techniques:<br>\n  ....<br>\n  \u2014 when the exception handling mechanism cannot find a handler for a thrown exception (15.3),<br>\n  ....      </br></br></br></p>\n<p id=\"so_9971782_9972063_11\">In such cases,     </p>\n<ol start=\"2\">\n<li>void terminate();</li>\n</ol>\n<p id=\"so_9971782_9972063_12\">is called (18.6.3). In the situation where no matching handler is found, it is implementation-defined whether or not the stack is unwound before <code>terminate()</code> is called. In all other situations, the stack shall not be unwound before <code>terminate()</code> is called. An implementation is not permitted to finish stack unwinding prematurely based on a determination that the unwind process will eventually cause a call to <code>terminate()</code>.      </p>\n</blockquote>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-04-02T10:20:05.190", "Id": "9972063", "Score": "19", "CreationDate": "2012-04-02T06:58:15.827", "LastActivityDate": "2012-04-02T10:20:05.190"}});