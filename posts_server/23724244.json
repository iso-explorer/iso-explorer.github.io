post_cb({"23724244": {"CommentCount": "1", "ViewCount": "59", "CreationDate": "2014-05-18T16:29:41.910", "LastActivityDate": "2014-05-18T16:37:40.233", "Title": "Why every constant expression can be cast to enumeration type", "AcceptedAnswerId": "23724337", "PostTypeId": "1", "Id": "23724244", "Score": "1", "Body": "<p>When we're defining enumeration (scoped or unscoped) any enumerator has the type of its enumeration. For instance, consider the following:</p>\n<pre><code>enum E { z=5 } //This unscoped enumerator has underlying type int implcitly\n</code></pre>\n<p>So <code>const int</code> can be casts to <code>E</code>. Is there a standard conversion?</p>\n", "Tags": "<c++><enums><implicit-conversion>", "OwnerUserId": "2786156", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23724244_23724337_1": {"section_id": 23, "quality": 0.9625, "length": 77}}, "n3337": {"so_23724244_23724337_1": {"section_id": 20, "quality": 0.9625, "length": 77}}, "n4659": {"so_23724244_23724337_1": {"section_id": 23, "quality": 0.9625, "length": 77}}}, "23724337": {"ParentId": "23724244", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_23724244_23724337_0\">Is there a standard conversion?</p>\n</blockquote>\n<p>The standard specifies, at \u00a74.5/3, that:</p>\n<blockquote>\n<p id=\"so_23724244_23724337_1\">A prvalue of an unscoped enumeration type whose underlying type is not\n  fixed (7.2) <strong>can be converted to a prvalue of the first of the\n  following types that can represent all the values of the enumeration\n  (i.e., the values in the range bmin to bmax as described in 7.2): int,\n  unsigned int, long int, unsigned long int, long long int, or unsigned\n  long long int.</strong> If none of the types in that list can represent all the\n  values of the enumeration, a prvalue of an unscoped enumeration type\n  can be converted to a prvalue of the extended integer type with lowest\n  integer conversion rank (4.13) greater than the rank of long long in\n  which all the values of the enumeration can be represented. If there\n  are two such extended types, the signed one is chosen.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Section \u00a77.2/10 also specifies that an enumerator type can be converted to an integer by integral promotion, but not the other way around:</p>\n<pre><code>enum color { red, yellow, green=20, blue };\ncolor c = 1; // error: type mismatch\nint i = yellow; // OK: yellow converted to integral value 1\n</code></pre>\n<p>(example from the standard)</p>\n<p><em>Note: All quotes are taken from the <a href=\"https://github.com/cplusplus/draft/blob/master/papers/N3936.pdf\" rel=\"nofollow\">N3936 draft</a>.</em></p>\n", "OwnerUserId": "493122", "PostTypeId": "2", "Id": "23724337", "Score": "2", "CreationDate": "2014-05-18T16:37:40.233", "LastActivityDate": "2014-05-18T16:37:40.233"}});