post_cb({"bq_ids": {"n4140": {"so_17127094_17127227_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 550}, "so_17127094_17127227_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 550}, "so_17127094_17127227_2": {"length": 6, "quality": 0.6, "section_id": 550}}, "n3337": {"so_17127094_17127227_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 541}, "so_17127094_17127227_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 541}, "so_17127094_17127227_2": {"length": 6, "quality": 0.6, "section_id": 541}}, "n4659": {"so_17127094_17127227_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 571}, "so_17127094_17127227_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 571}}}, "17127227": {"Id": "17127227", "PostTypeId": "2", "Body": "<h1>C++0x / C++11 availability</h1>\n<p>The only way I am aware to detect whether GCC is using C++0x/C++11, as of today, is to check for the predefined macro <code>__GXX_EXPERIMENTAL_CXX0X__</code>:</p>\n<pre><code>#ifdef __GXX_EXPERIMENTAL_CXX0X__\n    // C++11 code\n#else\n    // C++03 code\n#endif\n</code></pre>\n<p>Note that this may change in the future (hence the <code>EXPERIMENTAL</code> part of the macro).</p>\n<p><strong>Edit:</strong> in fact there's a better way I didn't know of until @stephan pointed it out in a comment:</p>\n<blockquote>\n<p id=\"so_17127094_17127227_0\"><strong>16.8/1 [cpp.predefined]</strong></p>\n<p id=\"so_17127094_17127227_1\">The following macro names shall be defined by the implementation:</p>\n<pre><code>__cplusplus\n</code></pre>\n<p id=\"so_17127094_17127227_2\">The name <code>__cplusplus</code> is defined to the value <code>201103L</code> when\n  compiling a C ++ translation unit.<sup>157</sup></p>\n<p id=\"so_17127094_17127227_3\">157) It is intended that future versions of this standard will replace\n  the value of this macro with a greater value. Non-conforming compilers\n  should use a value with at most five decimal digits.</p>\n</blockquote>\n<p>So I guess you could do:</p>\n<pre><code>#if defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L)\n</code></pre>\n<p>But I fear this wouldn't work with pre-standard C++0x GCC versions. So I'd probably use both <code>__GXX_EXPERIMENTAL_CXX0X__</code> and <code>__cplusplus</code> together:</p>\n<pre><code>#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L))\n</code></pre>\n<hr>\n<h1>C++0x / C++11 compatibility</h1>\n<p>However this may not always be enough to just detect whether C++0x/C++11 support is enabled: C++11 support has changed a lot throughout GCC versions, not only at the core language level but at the library level too.</p>\n<p>My best bet would be to find which minimal GCC version you find acceptable for C++11 support and combine the above tests with a GCC version test, eg:</p>\n<pre><code>#if (((__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 7)) || (__GNUC__ &gt;= 5)) // for GCC 4.7+\n</code></pre>\n<hr>\n<h1>Switching between <code>boost</code> and <code>std</code></h1>\n<p>Now, to switch between <code>boost::shared_ptr</code> and <code>std::shared_ptr</code> it's a bit cumbersome because C++03 doesn't support templated typedefs. I for one would wrap the required definitions in a <code>template struct</code>:</p>\n<pre><code>#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || (defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201103L))) \\\n        &amp;&amp; (((__GNUC__ == 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 7)) || (__GNUC__ &gt;= 5))\n    template&lt;typename T&gt;\n    struct my_shared_ptr {\n        typedef std::shared_ptr&lt;T&gt; type;\n        // you may also want to forward make_shared etc, this is left as an exercise\n    };\n#else\n    template&lt;typename T&gt;\n    struct my_shared_ptr {\n        typedef boost::shared_ptr&lt;T&gt; type;\n        // you may also want to forward make_shared etc, this is left as an exercise\n    };\n#endif\n\nmy_shared_ptr&lt;int&gt;::type ptr(new int);\n</code></pre>\n<p><strong>Edit:</strong> (again) whoops I just noticed @ComicSansMS's way of importing the right <code>shared_ptr</code> with a simple non-template <code>using</code> directive. Dunno why I didn't think about that.</p>\n<p>Still, I stand with the way I described of detecting C++0x/C++11 on GCC.</p>\n</hr></hr>", "LastEditorUserId": "2070725", "LastActivityDate": "2013-06-15T20:12:40.390", "Score": "4", "CreationDate": "2013-06-15T19:37:59.867", "ParentId": "17127094", "CommentCount": "0", "LastEditDate": "2013-06-15T20:12:40.390", "OwnerUserId": "2070725"}, "17127184": {"Id": "17127184", "PostTypeId": "2", "Body": "<p>You can just pull them into a custom namespace</p>\n<pre><code>#ifdef HAS_STD_SHARED_PTR\n    #include &lt;memory&gt;\n    #define SHARED_PTR_NAMESPACE std\n#else\n    #include &lt;boost/shared_ptr.hpp&gt;\n    #define SHARED_PTR_NAMESPACE boost\n#endif\n\nnamespace my_namespace {\n     using SHARED_PTR_NAMESPACE::shared_ptr;\n     using SHARED_PTR_NAMESPACE::make_shared;\n}\n\n#undef SHARED_PTR_NAMESPACE\n</code></pre>\n<p>The <code>HAS_STD_SHARED_PTR</code> flag needs to be set by the build environment. <a href=\"http://www.cmake.org/cmake/help/v2.8.9/cmake.html\" rel=\"nofollow\">CMake</a> allows for generic ways of <a href=\"https://pageant.ghulbus.eu/?p=664\" rel=\"nofollow\">detecting such features</a>.</p>\n", "LastActivityDate": "2013-06-15T19:33:32.297", "Score": "3", "CreationDate": "2013-06-15T19:33:32.297", "ParentId": "17127094", "CommentCount": "6", "OwnerUserId": "577603"}, "17127094": {"ViewCount": "553", "Body": "<p>We all know that both boost and c++11 has support for shared_ptr. Some compiler has support for c++11 while some doesn't. I would like to write my code so that when compiler support c++11 shared_ptr, it uses std::shared_ptr; when it doesn't, use boost::shared_ptr. What is the common/best practice for that?</p>\n<p>Let me confine the discussion to GCC but not to particular version. </p>\n", "AcceptedAnswerId": "17127184", "Title": "boost::shared_ptr and std::shared_ptr co-existence", "CreationDate": "2013-06-15T19:21:41.877", "Id": "17127094", "CommentCount": "3", "LastEditDate": "2013-06-17T14:08:37.420", "PostTypeId": "1", "LastEditorUserId": "218902", "LastActivityDate": "2013-06-17T14:08:37.420", "Score": "7", "OwnerUserId": "1246521", "Tags": "<c++><boost><c++11><shared-ptr>", "AnswerCount": "2"}});