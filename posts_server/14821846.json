post_cb({"bq_ids": {"n4140": {"so_14821846_14821846_0": {"length": 11, "quality": 0.55, "section_id": 6036}, "so_14821846_14821846_2": {"length": 12, "quality": 0.5217391304347826, "section_id": 6036}}, "n3337": {"so_14821846_14821846_0": {"length": 11, "quality": 0.55, "section_id": 5804}, "so_14821846_14821846_2": {"length": 12, "quality": 0.5217391304347826, "section_id": 5804}}, "n4659": {"so_14821846_14821846_0": {"length": 11, "quality": 0.55, "section_id": 7535}}}, "14821846": {"ViewCount": "2542", "Body": "<p>I have some template code that works fine with Xcode 4.5 and LLVM 3.0, but fails with the VS 2010 Express C++ toolchain (v 10.0.30319.1).</p>\n<p>I'm using a third-party API that I have no control over. It provides values to my code as black-box 'blobs' that can only be interpreted by API functions:</p>\n<pre><code>// API_Secret is a black-box encapsulation of a floating-point number or a boolean value.\n// It is provided by a third-party API, with associated access functions.\n// For all intents and purposes, it's a complete black box.\n// This enum represents the internal 'type' of a secret value.\nenum API_SecretTypeEnum {\n  API_Number,\n  API_Boolean,\n};\n// Other API declarations:\nAPI_SecretTypeEnum API_GetType(const API_Secret &amp;value);\ndouble API_AsNumber(const API_Secret &amp;value);\nbool API_AsBoolean(const API_Secret &amp;value);\n\n// my code:\ntemplate &lt;typename ValueType&gt;\nclass Extractor {\n public:\n  ValueType extract(API_Secret value) {\n    if (API_GetType(value) == API_Number) {\n      return static_cast&lt;ValueType&gt;(API_AsNumber(value));\n    } else if (API_GetType(value) == API_Boolean) {\n      return API_AsBoolean(value) ? ValueType(1) : ValueType(0);\n    }\n    return ValueType();\n  }\n};\n\n// boolean specialization - not 100% sure it's needed though\ntemplate&lt;&gt;\nclass Extractor &lt;bool&gt; {\n public:\n  bool extract(API_Secret value) {\n    return API_AsBoolean(value);\n  }\n};\n</code></pre>\n<p>Then, later:</p>\n<pre><code>API_Secret API_GetSomeValue(int some_sort_of_handle);\n\n// get some black-box values from the API\nAPI_Secret secret0 = API_GetSomeValue(0);\nAPI_Secret secret1 = API_GetSomeValue(1);\nAPI_Secret secret2 = API_GetSomeValue(2);\n\n// for certain external reasons we expect this to be an integer representation:\nExtractor&lt;int&gt; e0;\nint v0 = e0.extract(secret0);\n\n// for certain external reasons we expect this to be a double representation:\nExtractor&lt;double&gt; e1;\ndouble v1 = e1.extract(secret1);\n\n// for certain external reasons we expect this to be a boolean representation:\nExtractor&lt;bool&gt; e2;\nbool v2 = e2.extract(secret2);\n</code></pre>\n<p>Now for the difference between Xcode, LLVM and VS 2010. In Xcode &amp; LLVM, the following will compile (as part of the full program):</p>\n<pre><code>enum MyEnum {\n  Enum0,\n  Enum1,\n};\nExtractor&lt;MyEnum&gt; ee;\nMyEnum ve = ee.extract(secret0);\n</code></pre>\n<p>I.e. the class template uses a <code>static_cast</code> to <em>convert from a floating point number to an enum</em>. This seems to work fine, and the explanation section of <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow\">this page</a> suggests this is valid:</p>\n<blockquote>\n<p id=\"so_14821846_14821846_0\">8) Integer, <strong>floating-point</strong>, or enumeration type can be converted to any enumeration type (the result is unspecified if the value of expression, converted to the enumeration's underlying type, is not one of the target enumeration values)</p>\n</blockquote>\n<p>However with VS2010, the following compiler error is encountered:</p>\n<blockquote>\n<p id=\"so_14821846_14821846_1\">error C2440: 'static_cast' : cannot convert from 'double' to 'MyEnum'</p>\n<pre><code>     Conversions between enumeration and floating point values are no longer allowed\n</code></pre>\n</blockquote>\n<p>And this <a href=\"http://msdn.microsoft.com/en-us/library/c36yw7x9.aspx\" rel=\"nofollow\">MSDN article</a> seems to confirm this by not mentioning floating-point types and explicitly stating 'integral' value:</p>\n<blockquote>\n<p id=\"so_14821846_14821846_2\">The static_cast operator can explicitly convert an integral value to an enumeration type. If the value of the integral type does not fall within the range of enumeration values, the resulting enumeration value is undefined.</p>\n</blockquote>\n<p>So it appears that there is a significant difference here between VS 2010 and the other compilers. I am wondering whether this is something that can be bypassed in VS 2010? Is it a newer feature of the language that VS 2010 simply doesn't support? However I query this as the error message says \"no longer allowed\", implying it's explicitly disallowed.</p>\n<p>I know of a workaround - instead of casting to an enum (with <code>Extractor&lt;MyEnum&gt;</code>), I can use an <code>Extractor&lt;int&gt;</code> instead, and then simply assign this to the target MyEnum variable. However this template is actually used as part of a larger system that calls wrapped functions, and in this case the wrapped function takes a MyEnum value. This prevents the template from matching properly as the ValueType parameter is actually picked up automatically from the signature of the wrapped function.</p>\n<p>Alternatively, is it possible to write a template specialization of Extractor that matches <code>enum</code> types only? Then I can cast to an integral type first. Or maybe the base template could always cast to an int first, then I could write a floating-point specialization that doesn't do this - but I'm not sure how to write a template that catches all floating-point types (float, double, ...).</p>\n", "AcceptedAnswerId": "14821986", "Title": "C++ casting a floating point value to an enum - but not with VS 2010", "CreationDate": "2013-02-11T22:09:55.593", "Id": "14821846", "CommentCount": "2", "LastEditDate": "2015-08-25T01:50:59.397", "PostTypeId": "1", "LastEditorUserId": "143397", "LastActivityDate": "2015-08-25T01:50:59.397", "Score": "6", "OwnerUserId": "143397", "Tags": "<c++><visual-studio-2010><casting><enums><compiler-errors>", "AnswerCount": "1"}, "14821986": {"Id": "14821986", "PostTypeId": "2", "Body": "<p>I'm pretty sure <a href=\"http://msdn.microsoft.com/en-us/library/vstudio/bb982077%28v=vs.100%29.aspx\" rel=\"nofollow\">Visual Studio-2010 supports <code>&lt;type_traits&gt;</code></a>. You can use <code>std::enable_if</code> along with <code>std::is_enum</code>.</p>\n<pre><code>template &lt;typename ValueType, typename Enable = void&gt;\nclass Extractor {\n public:\n  ValueType extract(API_Secret value);\n};\n\ntemplate &lt;typename ValueType&gt;\nclass Extractor&lt;ValueType, typename std::enable_if&lt;std::is_enum&lt;ValueType&gt;::value&gt;::type&gt;\n{\n ...\n};\n</code></pre>\n<p><br>\nYou can do the same to match floating point types using <code>std::is_floating_point</code>.  </br></p>\n", "LastEditorUserId": "168288", "LastActivityDate": "2013-02-12T06:45:20.820", "Score": "3", "CreationDate": "2013-02-11T22:19:04.653", "ParentId": "14821846", "CommentCount": "3", "OwnerUserId": "168288", "LastEditDate": "2013-02-12T06:45:20.820"}});