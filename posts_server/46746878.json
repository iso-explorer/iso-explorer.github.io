post_cb({"bq_ids": {"n4140": {"so_46746878_49118876_5": {"length": 6, "quality": 0.6666666666666666, "section_id": 568}}, "n3337": {"so_46746878_49118876_5": {"length": 6, "quality": 0.6666666666666666, "section_id": 559}}, "n4659": {"so_46746878_49118876_5": {"length": 6, "quality": 0.6666666666666666, "section_id": 591}}}, "46746878": {"ViewCount": "550", "Body": "<p>Suppose I have three compiled objects, all produced by the <em>same compiler/version</em>:</p>\n<ol>\n<li>A was compiled with the C++11 standard</li>\n<li>B was compiled with the C++14 standard</li>\n<li>C was compiled with the C++17 standard</li>\n</ol>\n<p>For simplicity, let's assume all headers were written in C++11, <em>using only constructs whose semantics haven't changed between all three standard versions</em>, and so any interdependencies were correctly expressed with header inclusion and the compiler did not object.</p>\n<p>Which combinations of these objects is it and isn't it safe to link into a single binary? Why?</p>\n<hr>\n<p>EDIT: answers covering major compilers (e.g. gcc, clang, vs++) are welcome</p>\n</hr>", "Title": "Is it safe to link C++17, C++14, and C++11 objects", "CreationDate": "2017-10-14T16:36:35.583", "LastActivityDate": "2018-03-05T22:05:04.407", "CommentCount": "23", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2018-03-05T21:20:08.057", "LastEditorUserId": "563765", "Id": "46746878", "Score": "25", "OwnerUserId": "563765", "Tags": "<c++><c++11><linker><c++14><abi>", "AnswerCount": "3"}, "49108020": {"Id": "49108020", "PostTypeId": "2", "Body": "<p>New C++ standards are come in two parts: language features and standard library components.</p>\n<p>As you mean by <em>new standard</em>, changes in language itself (e.g. ranged-for) there's almost no problem (sometimes conflicts are exists in 3rd party library headers with newer standard language features).</p>\n<p>But standard library...</p>\n<p>Each compiler version comes with an implementation of C++ standard library (libstdc++ with gcc, libc++ with clang, MS C++ standard library with VC++,...) and exactly one implementaion, not many implementation for each standard version. Also in some cases you may use other implementation of standard library than compiler provided. What you should care is linking an older standard library implementation with a newer one.</p>\n<p>The conflict that could occur between 3rd party libraries and your code is the standard library (and other libraries) that links to that 3rd party libraries.</p>\n", "LastEditorUserId": "3001070", "LastActivityDate": "2018-03-05T11:22:51.097", "Score": "2", "CreationDate": "2018-03-05T10:15:13.733", "ParentId": "46746878", "CommentCount": "5", "OwnerUserId": "3001070", "LastEditDate": "2018-03-05T11:22:51.097"}, "49119902": {"Id": "49119902", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46746878_49119902_0\">Which combinations of these objects is it and isn't it safe to link into a single binary? Why?</p>\n</blockquote>\n<p><strong>For GCC</strong> it is safe to link together any combination of objects A, B, and C. If they are all built with the same version then they are ABI compatible, the standard version (i.e. the <code>-std</code> option) doesn't make any difference.</p>\n<p>Why? Because that's an important property of our implementation which we work hard to ensure.</p>\n<p>Where you have problems is if you link together objects compiled with different versions of GCC <strong>and</strong> you have used unstable features from a new C++ standard before GCC's support for that standard is complete. For example, if you compile an object using GCC 4.9 and <code>-std=c++11</code> and another object with GCC 5 and <code>-std=c++11</code> you will have problems. The C++11 support was experimental in GCC 4.x, and so there were incompatible changes between the GCC 4.9 and 5 versions of C++11 features. Similarly, if you compile one object with GCC 7 and <code>-std=c++17</code> and another object with GCC 8 and <code>-std=c++17</code> you will have problems, because C++17 support in GCC 7 and 8 is still experimental and evolving.</p>\n<p>On the other hand, any combination of the following objects will work (although see note below about <code>libstdc++.so</code> version):</p>\n<ul>\n<li>object D compiled with GCC 4.9 and <code>-std=c++03</code></li>\n<li>object E compiled with GCC 5 and <code>-std=c++11</code></li>\n<li>object F compiled with GCC 7 and <code>-std=c++17</code></li>\n</ul>\n<p>This is because C++03 support is stable in all three compiler versions used, and so the C++03 components are compatible between all the objects. C++11 support is stable since GCC 5, but object D doesn't use any C++11 features, and objects E and F both use versions where C++11 support is stable. C++17 support is not stable in any of the used compiler versions, but only object F uses C++17 features and so there is no compatibility issue with the other two objects (the only features they share come from C++03 or C++11, and the versions used make those parts OK). If you later wanted to compile a fourth object, G, using GCC 8 and <code>-std=c++17</code> then you would need to recompile F with the same version (or not link to F) because the C++17 symbols in F and G are incompatible.</p>\n<p>The only caveat for the compatibility described above between D, E and F is that your program must use the <code>libstdc++.so</code> shared library from GCC 7 (or later). Because object F was compiled with GCC 7, you need to use the shared library from that release, because compiling any part of the program with GCC 7 might introduce dependencies on symbols that are not present in the <code>libstdc++.so</code> from GCC 4.9 or GCC 5. Similarly, if you linked to object G, built with GCC 8, you would need to use the <code>libstdc++.so</code> from GCC 8 to ensure all symbols needed by G are found. The simple rule is to ensure the shared library the program uses at run-time is at least as new as the version used to compile any of the objects.</p>\n<p>Another caveat when using GCC, already mentioned in the comments on your question, is that since GCC 5 there are <em>two implementations of <code>std::string</code></em> available in libstdc++. The two implementations are not link-compatible (they have different mangled names, so can't be linked together) but can co-exist in the same binary (they have different mangled names, so don't conflict if one object uses <code>std::string</code> and the other uses <code>std::__cxx11::string</code>). If your objects use <code>std::string</code> then usually they should all be compiled with the same string implementation. Compile with <code>-D_GLIBCXX_USE_CXX11_ABI=0</code> to select the original <code>gcc4-compatible</code> implementation, or <code>-D_GLIBCXX_USE_CXX11_ABI=1</code> to select the new <code>cxx11</code> implementation (don't be fooled by the name, it can be used in C++03 too, it's called <code>cxx11</code> because it conforms to the C++11 requirements). Which implementation is the default depends on how GCC was configured, but the default can always be overridden at compile-time with the macro.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2018-03-05T22:05:04.407", "Score": "18", "CreationDate": "2018-03-05T21:38:55.870", "ParentId": "46746878", "CommentCount": "10", "OwnerUserId": "981959", "LastEditDate": "2018-03-05T22:05:04.407"}, "49118876": {"Id": "49118876", "PostTypeId": "2", "Body": "<p>There are two parts to the answer. Compatibility at the compiler level and compatibility at the linker level. Let's start with the former.</p>\n<blockquote>\n<p id=\"so_46746878_49118876_0\">let's assume all headers were written in C++11</p>\n</blockquote>\n<p>Using the same compiler means that the same standard library header and source files (the onces associated with the compiler) will be used irrespective of the target C++ standard. Therefore, the header files of the standard library are written to be compatible with all C++ versions supported by the compiler.</p>\n<p>That said, if the compiler options used to compile a translation unit specify a particular C++ standard, then the any features that are only available in newer standards should not be accessible. This is done using the <code>__cplusplus</code> directive. See the <a href=\"https://github.com/gcc-mirror/gcc/blob/da8dff89fa9398f04b107e388cb706517ced9505/libstdc%2B%2B-v3/include/debug/vector\" rel=\"noreferrer\">vector</a> source file for an interesting example of how it's used. Similarly, the compiler will reject any syntactic features offered by newer versions of the standard.</p>\n<p>All of that means that your assumption can only apply to the header files you wrote. These header files can cause incompatibilities when included in different translation units targeting different C++ standards. This is discussed in Annex C of the C++ standard. There are 4 clauses, I'll only discuss the first one, and briefly mention the rest.</p>\n<p>C.3.1 Clause 2: lexical conventions</p>\n<p>Single quotes delimit a character literal in C++11, whereas they are digit separators in C++14 and C++17. Assume you have the following macro definition in one of the pure C++11 header files:</p>\n<pre><code>#define M(x, ...) __VA_ARGS__\n\n// Maybe defined as a field in a template or a type.\nint x[2] = { M(1'2,3'4) };\n</code></pre>\n<p>Consider two translation units that include the header file, but target C++11 and C++14, respectively. When targeting C++11, the comma within the quotes is not considered to be a parameter separator; there is only once parameter. Therefore, the code would be equivalent to:</p>\n<pre><code>int x[2] = { 0 }; // C++11\n</code></pre>\n<p>On the other hand, when targeting C++14, the single quotes are interpreted as digit separators. Therefore, the code would be equivalent to:</p>\n<pre><code>int x[2] = { 34, 0 }; // C++14 and C++17\n</code></pre>\n<p>The point here is that using single quotes in one of the pure C++11 header files can result in surprising bugs in the translation units that target C++14/17. Therefore, even if a header file is written in C++11, it has to be written carefully to ensure that it's compatible with later versions of the standard. The <code>__cplusplus</code> directive may be useful here.</p>\n<p>The other three clauses from the standard include:</p>\n<p>C.3.2 Clause 3: basic concepts</p>\n<blockquote>\n<p id=\"so_46746878_49118876_1\"><strong>Change</strong>: New usual (non-placement) deallocator</p>\n<p id=\"so_46746878_49118876_2\"><strong>Rationale</strong>: Required for sized deallocation.</p>\n<p id=\"so_46746878_49118876_3\"><strong>Effect on original feature</strong>: Valid C++2011 code could declare a global placement allocation function and deallocation function as follows: </p>\n<pre><code>void operator new(std::size_t, std::size_t); \nvoid operator delete(void*, std::size_t) noexcept;\n</code></pre>\n<p id=\"so_46746878_49118876_4\">In this International Standard, however, the declaration of operator\n  delete might match a predefined usual (non-placement) operator delete\n  (3.7.4). If so, the program is ill-formed, as it was for class member\n  allocation functions and deallocation functions (5.3.4).</p>\n</blockquote>\n<p>C.3.3 Clause 7: declarations</p>\n<blockquote>\n<p id=\"so_46746878_49118876_5\"><strong>Change</strong>: constexpr non-static member functions are not implicitly const\n  member functions. </p>\n<p id=\"so_46746878_49118876_6\"><strong>Rationale</strong>: Necessary to allow constexpr member functions to mutate the \n  object. </p>\n<p id=\"so_46746878_49118876_7\"><strong>Effect on original feature</strong>: Valid C++2011 code may fail to compile in this \n  International Standard.</p>\n<p id=\"so_46746878_49118876_8\">For example, the following code is valid in C++2011 but invalid in\n  this International Standard because it declares the same member\n  function twice with different return types:</p>\n<pre><code>struct S {\nconstexpr const int &amp;f();\nint &amp;f();\n};\n</code></pre>\n</blockquote>\n<p>C.3.4 Clause 27: input/output library</p>\n<blockquote>\n<p id=\"so_46746878_49118876_9\"><strong>Change</strong>: gets is not defined.</p>\n<p id=\"so_46746878_49118876_10\"><strong>Rationale</strong>: Use of gets is considered dangerous.</p>\n<p id=\"so_46746878_49118876_11\"><strong>Effect on original feature</strong>: Valid C++2011 code that uses the gets\n  function may fail to compile in this International Standard.</p>\n</blockquote>\n<p>Potential incompatibilities between C++14 and C++17 are discussed in C.4. Since all the non-standard header files are written in C++11 (as specified in the question), these issues will not occur, so I will not mention them here.</p>\n<p>Now I'll discuss compatibility at the linker level. In general, potential reasons for incompatibilities include the following:</p>\n<ul>\n<li>The format of the object files.</li>\n<li>Program startup and termination routines and the <code>main</code> entry point.</li>\n<li><a href=\"https://msdn.microsoft.com/en-us/magazine/dn904673.aspx\" rel=\"noreferrer\">Whole program optimization</a> (WPO).</li>\n</ul>\n<p>If the format of the resulting object file depends on the target C++ standard, the linker must be able to link the different object files. In GCC, LLVM, and VC++, this is fortunately not the case. That is, the format of objects files is the same irrespective of the target standard, although it is highly dependent on the compiler itself. In fact, none of the linkers of GCC, LLVM, and VC++ require knowledge about the target C++ standard. This also means that we can link object files that are already compiled (statically linking the runtime).</p>\n<p>If the program startup routine (the function that calls <code>main</code>) is different for different C++ standards and the different routines are not compatible with each other, then it would not be possible to link the object files. In GCC, LLVM, and VC++, this is fortunately not the case. In addition, the signature of the <code>main</code> function (and the restrictions that apply on it, see Section 3.6 of the standard) is the same in all C++ standards, so it doesn't matter in which translation unit it exists.</p>\n<p>In general, WPO may not work well with object files compiled using different C++ standards. This depends on exactly which stages of the compiler require knowledge of the target standard and which stages don't and the impact that it has on inter-procedural optimizations that cross object files. Fortunately, GCC, LLVM, and VC++ are well designed and don't have this issue (not that I'm aware of).</p>\n<p>Therefore, GCC, LLVM, and VC++ have been designed to enable <strong>binary</strong> compatibility across different versions of the C++ standard. This is not really a requirement of the standard itself though.</p>\n<p>By the way, although the VC++ compiler offers the <a href=\"https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version\" rel=\"noreferrer\">std switch</a>, which enables you to target a particular version of the C++ standard, it does not support targeting C++11. The minimum version that can be specified is C++14, which is the default starting from Visual C++ 2013 Update 3.  You could use an older version of VC++ to target C++11, but then you would have to use different VC++ compilers to compile different translation units that target different versions of the C++ standard, which would at the very least break WPO.</p>\n<p><strong>CAVEAT: My answer may not be complete or very precise.</strong></p>\n", "LastActivityDate": "2018-03-05T20:26:23.240", "CommentCount": "4", "CreationDate": "2018-03-05T20:26:23.240", "ParentId": "46746878", "Score": "7", "OwnerUserId": "4230618"}});