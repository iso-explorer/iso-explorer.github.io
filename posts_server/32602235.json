post_cb({"32988737": {"CommentCount": "0", "Body": "<p>I think that what Alexandrescu is referring to in the \"Mechanics\" paragraph is expounded upon in the rest of the chapter. He's referring to how much more flexible policy-based class design is than inheritance-based class design, particularly with respect to the various ways in which policies can be implemented and combined - this in comparison to the single implementation and combination allowed through multiple inheritance.</p>\n<p>For instance, when discussing the <code>Creator</code> policy he points out that the policy requires only a Create() method that returns a pointer to the class being created, but doesn't specify that it be virtual or non-static. And he shows several ways in which each policy could be created: a straightforward policy class such as (from section 1.5, skipping the MallocCreator and PrototypeCreator policies)</p>\n<blockquote>\n<pre><code>template&lt;class T&gt;\nstruct OpNewCreator\n{\n  static T* Create()\n  {\n    return new T;\n  }\n}; \n</code></pre>\n<p id=\"so_32602235_32988737_0\">...</p>\n</blockquote>\n<pre><code>&gt;     //Library code\n&gt;     template &lt;class CreationPolicy&gt;\n&gt;     class WidgetManager:public CreationPolicy\n&gt;     {\n&gt;     ...\n&gt;     };\n</code></pre>\n<blockquote>\n<p id=\"so_32602235_32988737_1\">...</p>\n<pre><code>// Application Code\ntypedef WidgetManager&lt;OpNewCreator&lt;Widget&gt; &gt; MyWidgetMgr;\n</code></pre>\n</blockquote>\n<p>or it could be implemented with template template parameters (section 1.5.1) as</p>\n<blockquote id=\"so_32602235_32988737_2\">\n<pre><code>//Library Code\ntemplate &lt;template &lt;class&gt; class Creation Policy&gt;\nclass WidgetManager : public CreationPolicy &lt;Widget&gt;\n{\n...\n}\n\n// Application Code\ntypedef WidgetManager&lt;OpNewCreator&gt; MyWidgetMgr\n</code></pre>\n</blockquote>\n<p>or (section 1.5.2) - implemented as a template member function:</p>\n<blockquote id=\"so_32602235_32988737_3\">\n<pre><code>struct OpNewCreator\n{\n  template &lt;class T&gt;\n  static T* Create()\n  {\n    return new T;\n  }\n</code></pre>\n</blockquote>\n<p>}</p>\n<p>These are examples of the flexible mechanics that are available in a template-based policy class solution and not available in a multiple inheritance solution. These particular examples are not maybe all that exciting, probably because they have to be short and simple for pedagogical reasons.</p>\n", "CreationDate": "2015-10-07T09:32:47.040", "ParentId": "32602235", "Id": "32988737", "LastActivityDate": "2015-10-07T09:32:47.040", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1384748"}, "32602235": {"CreationDate": "2015-09-16T07:26:11.090", "ViewCount": "141", "Id": "32602235", "Score": "4", "Title": "Mechanics of multiple inheritance compared to templates wrt building flexible designs", "LastEditorUserId": "-1", "CommentCount": "0", "Body": "<p>This is a narrower version of the <a href=\"https://stackoverflow.com/questions/32549573/understanding-the-exposition-of-alexandrescu-about-the-weaknesses-of-multiple-in\">question</a> put on hold due to being too broad. </p>\n<p>On pages 6-7 of <strong>Modern C++ Design</strong>, Andrei Alexandrescu lists three ways in which the <em>multiple inheritance</em> is weaker than <em>templates</em> with respect to building flexible designs. In particular, he states that the <em>mechanics</em> provided by <em>multiple inheritance</em> is poor (the text in square brackets and formatting are mine as per <em>my</em> understanding of the context):</p>\n<blockquote>\n<p id=\"so_32602235_32602235_0\">In such a setting [i.e. <em>multiple inheritance</em>], [to build a flexible <code>SmartPtr</code>,] the user would build a multithreaded, reference-counted smart pointer class by inheriting some <code>BaseSmartPtr</code> class and two classes: <code>MultiThreaded</code> and <code>RefCounted</code>. Any experienced class designer knows\n  that such a na\u00efve design does not work.</p>\n<p id=\"so_32602235_32602235_1\">...</p>\n<ol>\n<li><em>Mechanics.</em> There is no boilerplate code to assemble the inherited components in a controlled\n  manner. The only tool that combines BaseSmartPtr, MultiThreaded, and RefCounted\n  is a language mechanism called multiple inheritance. The language applies\n  simple superposition in combining the base classes and establishes a set of simple rules\n  for accessing their members. This is unacceptable except for the simplest cases. Most\n  of the time, you need to <strong>orchestrate</strong> the workings of the inherited classes carefully to\n  obtain the desired behavior.</li>\n</ol>\n</blockquote>\n<p>When using <em>multiple inheritance</em>, one can achieve some pretty flexible orchestration by writing member functions that call member functions of several base classes. So, what is the orchestration that is missing from <em>multiple inheritance</em> and present in templates?  </p>\n<p>Please note that not every disadvantage of <em>multiple inheritance</em> compared to <em>templates</em> goes as an answer here, but only a disadvantage in what Andei calls <em>mechanics</em> in the above quote. In particular, please make sure that you are not talking about one of the other two weaknesses of <em>multiple inheritance</em> listed by Andrei: </p>\n<blockquote>\n<ol start=\"2\">\n<li><p id=\"so_32602235_32602235_2\"><em>Type information</em>. The base classes do not have enough type information to carry on\n  their tasks. For example, imagine you try to implement deep copy for your smart\n  pointer class by deriving from a DeepCopy base class. But what interface would DeepCopy\n  have? It must create objects of a type it doesn\u2019t know yet.</p></li>\n<li><p id=\"so_32602235_32602235_3\"><em>State manipulation</em>. Various behavioral aspects implemented with base classes must manipulate\n  the same state. This means that they must use virtual inheritance to inherit a\n  base class that holds the state. This complicates the design and makes it more rigid because\n  the premise was that user classes inherit library classes, not vice versa.</p></li>\n</ol>\n</blockquote>\n", "Tags": "<c++><templates><multiple-inheritance><policy-based-design>", "LastEditDate": "2017-05-23T12:06:40.590", "LastActivityDate": "2015-10-07T09:32:47.040", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "2725810"}, "bq_ids": {"n4140": {"so_32602235_32988737_3": {"length": 5, "quality": 0.625, "section_id": 6290}}, "n3337": {"so_32602235_32988737_3": {"length": 5, "quality": 0.625, "section_id": 6050}}}});