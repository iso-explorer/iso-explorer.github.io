post_cb({"4417219": {"CommentCount": "4", "ViewCount": "1706", "PostTypeId": "1", "LastEditorUserId": "368896", "CreationDate": "2010-12-11T14:38:47.217", "LastActivityDate": "2013-12-30T20:23:29.417", "Title": "Use of qualified name in function parameter", "AcceptedAnswerId": "4417294", "LastEditDate": "2013-12-30T20:23:29.417", "Id": "4417219", "Score": "2", "Body": "<p>According to the C++ Standard, function parameter's name is parsed by a <em>declarator-id</em>, and a <em>declarator-id</em> can also be a qualified name. That means, the following code is perfectly  valid (if I've understood the relevant sections from the Standard correctly):</p>\n<pre><code>template&lt;class T&gt;\nstruct Sample\n{\n    int fun(int T::count); //T::count is qualified variable name\n};\n</code></pre>\n<p>My question basically is, why would anyone write such code? In what situations, the use of qualified name (in function parameter-list) can be advantageous?</p>\n<hr>\n<p>EDIT:</p>\n<p>It seems I understood the sections incorrectly. Instead of the above code, we can probably write the following code (as per the C++ standard):</p>\n<pre><code>template&lt;class T&gt;\nstruct sample\n{\n  void fun(int arr[T::count]);\n};\n</code></pre>\n<p>gcc-4.3.4 <a href=\"http://www.ideone.com/qbvPo\" rel=\"nofollow\">compiles</a> it perfectly. But then, I'm not totally satisfied, because T::count is not a parameter anymore (I guess).</p>\n</hr>", "Tags": "<c++><templates><parameters><qualified-name>", "OwnerUserId": "415784", "AnswerCount": "3"}, "4417294": {"ParentId": "4417219", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2010-12-11T14:57:13.943", "Score": "2", "LastEditorUserId": "33006", "LastEditDate": "2010-12-11T17:49:13.813", "Id": "4417294", "OwnerUserId": "33006", "Body": "<p>It's invalid. The syntax allows arbitrary declarators, but 8.3.5p8 says</p>\n<blockquote>\n<p id=\"so_4417219_4417294_0\">An identifier can optionally be\n  provided as a parameter name; if\n  present in a function definition\n  (8.4), it names a parameter (sometimes\n  called \u201cformal argument\u201d)</p>\n</blockquote>\n<p><strong>Edit</strong> Another quote which syntactically constraints declarators (8.3p1, [dcl.meaning]):</p>\n<blockquote>\n<p id=\"so_4417219_4417294_1\">Each declarator contains exactly one\n  declarator-id; it names the identifier\n  that is declared. The id-expression of\n  a declarator-id shall be a simple\n  identifier except for the declaration\n  of some special functions (12.3, 12.4,\n  13.5) and for the declaration of template specializations or partial\n  specializations (14.7). A declarator-id\n  shall not be qualified except for the\n  definition of a member function (9.3)\n  or static data member (9.4) or nested\n  class (9.7) outside of its class, the\n  definition or explicit instantiation\n  of a function, variable or class\n  member of a namespace outside of its\n  namespace, or the definition of a\n  previously declared explicit\n  specialization outside of its\n  namespace, or the declaration of a\n  friend function that is a member of\n  another class or namespace (11.4).</p>\n</blockquote>\n<p>So in a parameter declaration, you must not use qualified names.</p>\n<p><strong>Edit</strong>: In the edited form, the function parameter type decays to an <code>int*</code>, even before a test is being made whether <code>T::count</code> actually exists and is an integer constant. If you want an example where a qualified name in such a signature would do something meaningful, consider</p>\n<pre><code>template&lt;class T&gt;\nstruct sample\n{\n  void fun(int S=T::count);\n};\n</code></pre>\n<p>When <code>fun</code> gets called without parameter, the compiler needs to determine the default argument, which then fails if <code>T</code> does not have a <code>count</code> member, or that cannot be converted to <code>int</code>.</p>\n", "LastActivityDate": "2010-12-11T17:49:13.813"}, "bq_ids": {"n4140": {"so_4417219_4417421_0": {"section_id": 3208, "quality": 0.9459459459459459, "length": 35}, "so_4417219_4417294_0": {"section_id": 3247, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_4417219_4417421_0": {"section_id": 3082, "quality": 0.9459459459459459, "length": 35}, "so_4417219_4417294_0": {"section_id": 3120, "quality": 1.0, "length": 15}, "so_4417219_4417294_1": {"section_id": 3082, "quality": 0.8115942028985508, "length": 56}}, "n4659": {"so_4417219_4417421_0": {"section_id": 3965, "quality": 0.9459459459459459, "length": 35}, "so_4417219_4417294_0": {"section_id": 4005, "quality": 0.7333333333333333, "length": 11}}}, "4417421": {"ParentId": "4417219", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-12-11T15:33:12.013", "Score": "1", "LastEditorUserId": "165520", "LastEditDate": "2010-12-11T15:40:01.250", "Id": "4417421", "OwnerUserId": "165520", "Body": "<p>As far as I understand your code is ill formed because</p>\n<blockquote>\n<p id=\"so_4417219_4417421_0\">$8.3/1 : When the declarator-id is qualified, <strong>the declaration  shall  refer  to  a  previously  declared  member  of  the  class  or namespace  to  which  the  qualifier  refers</strong>,  and  the  member  shall  not  have  been  introduced  by  a  using-declaration  in  the  scope  of  the  class  or  namespace  nominated  by  the  nested-name-specifier  of  the declarator-id.  [Note: if the qualifier is the global ::scope resolution operator, the declarator-id refers to a name declared in the global namespace scope.  ]</p>\n</blockquote>\n<p>P.S: I am not 100% sure. Please correct me if I am wrong. :)</p>\n<hr>\n<blockquote>\n<p id=\"so_4417219_4417421_1\">In what situations, the use of qualified name (in function parameter-list) can be advantageous?</p>\n</blockquote>\n<p>Read Items 31 and 32 from Exceptional C++ by Herb Sutter. Both the items deal with Koenig lookup and the Interface principle.</p>\n</hr>", "LastActivityDate": "2010-12-11T15:40:01.250"}, "4417469": {"ParentId": "4417219", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-12-11T15:43:44.933", "Score": "0", "LastEditorUserId": "415784", "LastEditDate": "2010-12-11T15:53:25.850", "Id": "4417469", "OwnerUserId": "415784", "Body": "<p>It seems I understood the sections incorrectly. Instead of that code, we can probably write the following code (as per the C++ standard):</p>\n<pre><code>template&lt;class T&gt;\nstruct sample\n{\n  void fun(int arr[T::count]);\n};\n</code></pre>\n<p>gcc-4.3.4 <a href=\"http://www.ideone.com/qbvPo\" rel=\"nofollow\">compiles</a>  it perfectly. But then, I'm not totally satisfied, because <code>T::count</code> is not a <em>parameter</em> anymore (I guess).</p>\n", "LastActivityDate": "2010-12-11T15:53:25.850"}});