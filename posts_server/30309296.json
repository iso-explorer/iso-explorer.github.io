post_cb({"bq_ids": {"n4140": {"so_30309296_30309577_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5404}}, "n3337": {"so_30309296_30309577_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5199}}, "n4659": {"so_30309296_30309577_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6853}}}, "30309577": {"Id": "30309577", "PostTypeId": "2", "Body": "<p>Your program has undefined behavior, because you are violating the rule found in 7.1.2:</p>\n<blockquote>\n<p id=\"so_30309296_30309577_0\">An inline function shall be defined in every translation unit in which it is <em>odr-used</em> and shall have exactly the same de\ufb01nition in every case (3.2).</p>\n</blockquote>\n<p>Remove the <code>inline</code> keyword from these definitions.</p>\n<p>You also are not following the guidance in 18.6.1, which says that user code may replace array <code>::operator new[]()</code>, but when doing so, should provide all of the following:</p>\n<pre><code>void* operator new[](std::size_t size);\nvoid operator delete[](void* ptr) noexcept;\nvoid operator delete[](void* ptr, std::size_t size) noexcept;\n</code></pre>\n<p>You have failed to provide the two-parameter <code>::operator delete[]</code> overload, used when a constructor throws, and you do not have the correct <code>noexcept</code> annotation on your replacement <code>::operator delete[]</code> versions.</p>\n", "LastActivityDate": "2015-05-18T17:35:58.563", "CommentCount": "3", "CreationDate": "2015-05-18T17:35:58.563", "ParentId": "30309296", "Score": "4", "OwnerUserId": "103167"}, "30309296": {"ViewCount": "45", "Body": "<p>I wrote a test program using googletest. The program links two libraries, <code>gtestd.lib</code> and <code>util.lib</code>, both of them are built using VS2010 with /MDd</p>\n<p>In <code>util.lib</code>, the C++ operators new and delete are overridden.</p>\n<pre><code>inline  void * _cdecl operator new[]( size_t cb )\n{\n    Assert(cb &lt;= UINT_MAX);\n    return MemAlloc((DWORD)cb);\n}\n\ninline void __cdecl operator delete[]( void * pv )\n{\n    MemFree(pv);\n}\n</code></pre>\n<p>Now the strange thing happens in file <code>gtest-filepath.cc</code> inside <code>gtestd.lib</code></p>\n<pre><code>void FilePath::Normalize() {\n  .....\n  const char* src = pathname_.c_str();\n  char* const dest = new char[pathname_.length() + 1];\n\n  .....\n  delete[] dest;\n}\n</code></pre>\n<p>\"new[]\" calls into \"msvcr100d.dll!operator new[]\", but \"delete[]\" calls into \"mytestapp.exe!operator delete[]\" which is defined in util.lib</p>\n<p>I would expect both <code>new[]</code> and <code>delete[]</code> will call VS runtime library because that is what <code>gtestd.lib</code> linking to. But no matter what, I do not understand why <code>new[]</code> calls into VS runtime library but <code>delete[]</code> calls into the overridden one. </p>\n", "Title": "Function in one library calls overridden delete[] in another library", "CreationDate": "2015-05-18T17:20:26.687", "LastActivityDate": "2015-05-18T17:35:58.563", "CommentCount": "0", "LastEditDate": "2015-05-18T17:32:45.790", "PostTypeId": "1", "LastEditorUserId": "2959769", "Id": "30309296", "Score": "2", "OwnerUserId": "3225426", "Tags": "<c++><visual-studio-2010>", "AnswerCount": "1"}});