post_cb({"bq_ids": {"n4140": {"so_25542390_25543147_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 7207}, "so_25542390_25543147_1": {"length": 50, "quality": 0.6944444444444444, "section_id": 5878}, "so_25542390_25543147_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 5917}}, "n3337": {"so_25542390_25543147_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 5689}, "so_25542390_25543147_1": {"length": 50, "quality": 0.6944444444444444, "section_id": 5649}, "so_25542390_25543147_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 6951}}, "n4659": {"so_25542390_25543147_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 7410}, "so_25542390_25543147_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 8716}}}, "25542390": {"ViewCount": "1844", "Body": "<p>How would you go about doing this in standard C++11/14 ? Because if I'm not mistaken this isn't standard compliant code with the anonymous structs.</p>\n<p>I wish to access the members the same way as you would with this.</p>\n<pre><code>template &lt;typename some_type&gt;\nstruct vec\n{\n    union {\n        struct { some_type x, y, z; };\n        struct { some_type r, g, b; };\n\n        some_type elements[3];\n    };\n};\n</code></pre>\n", "AcceptedAnswerId": "25543147", "Title": "Anonymous union and struct", "CreationDate": "2014-08-28T06:46:42.527", "Id": "25542390", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-09-16T02:40:16.470", "LastEditorUserId": "718379", "LastActivityDate": "2014-09-16T02:40:16.470", "ClosedDate": "2014-08-28T16:02:48.980", "Score": "16", "OwnerUserId": "1760269", "Tags": "<c++><c++11><struct><unions>", "AnswerCount": "3"}, "25543081": {"Id": "25543081", "PostTypeId": "2", "Body": "<p>Anonymous unions are allowed in C++11/14. See the example of their usage  at <a href=\"http://www.stroustrup.com/C++11FAQ.html#unions\" rel=\"nofollow noreferrer\">Bjarne Stroustrup's C++11 FAQ</a></p>\n<p>Regarding anonymous structs see <a href=\"https://stackoverflow.com/q/8622459/3959454\">Why does C++11 not support anonymous structs, while C11 does?</a> and <a href=\"https://stackoverflow.com/questions/2253878/why-does-c-disallow-anonymous-structs-and-unions\">Why does C++ disallow anonymous structs and unions?</a></p>\n<p>Though most compilers support anonymous structs, if you want your code to be standard compliant you have to write something like this:</p>\n<pre><code>template &lt;typename some_type&gt;\nstruct vec\n{\n    union {\n       struct { some_type x, y, z; } s1;\n       struct { some_type r, g, b; } s2;\n\n       some_type elements[3];\n    };\n};\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-28T07:44:53.633", "Score": "7", "CreationDate": "2014-08-28T07:27:41.697", "ParentId": "25542390", "CommentCount": "0", "LastEditDate": "2017-05-23T11:45:38.010", "OwnerUserId": "3959454"}, "25543147": {"Id": "25543147", "PostTypeId": "2", "Body": "<p>Yes, neither C++11 nor C++14 allow anonymous structs. <a href=\"https://stackoverflow.com/a/8622520/241631\">This answer</a> contains some reasoning why this is the case. You need to name the structs, and they also cannot be defined within the anonymous union.</p>\n<p><em>\u00a79.5/5 [class.union]</em></p>\n<blockquote>\n<p id=\"so_25542390_25543147_0\"><code>...</code> The <em>member-specification</em> of an anonymous union shall only define non-static data members. [ <em>Note:</em> Nested types, anonymous unions, and functions cannot be declared within an anonymous union. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So move the struct definitions outside of the union.</p>\n<pre><code>template &lt;typename some_type&gt;\nstruct vec\n{\n    struct xyz { some_type x, y, z; };\n    struct rgb { some_type r, g, b; };\n\n    union {\n        xyz a;\n        rgb b;\n        some_type elements[3];\n    };\n};\n</code></pre>\n<p>Now, we require <code>some_type</code> to be <em>standard-layout</em> because that makes all the members of the anonymous union <em>layout compatible</em>. <a href=\"http://en.cppreference.com/w/cpp/concept/StandardLayoutType\" rel=\"nofollow noreferrer\">Here are the requirements</a> for a standard layout type. These are described in section \u00a79/7 of the standard.</p>\n<p>Then, from <em>\u00a79.2 [class.mem]</em></p>\n<blockquote>\n<p id=\"so_25542390_25543147_1\"><em>16</em> \u00a0 Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).<br/>\n<em>18</em> \u00a0 If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them. Two standard-layout structs share a common initial sequence if corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.<br/></p>\n</blockquote>\n<p>And for the array member, from <em>\u00a73.9/9 [basic.types]</em></p>\n<blockquote>\n<p id=\"so_25542390_25543147_2\"><code>...</code> Scalar types, standard-layout class types (Clause 9), arrays of such types\n  and cv-qualified versions of these types (3.9.3) are collectively called <em>standard-layout types</em>.</p>\n</blockquote>\n<p>To ensure that <code>some_type</code> is standard layout, add the following within the definition of <code>vec</code></p>\n<pre><code>static_assert(std::is_standard_layout&lt;some_type&gt;::value, \"not standard layout\");\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/types/is_standard_layout\" rel=\"nofollow noreferrer\"><code>std::is_standard_layout</code></a> is defined in the <code>type_traits</code> header. Now all 3 members of your union are standard layout, the two structs and the array are layout compatible, and so the 3 union members share a common initial sequence, which allows you to write and then inspect (read) any members belonging to the common initial sequence (the entire thing in your case).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-28T07:44:59.723", "Score": "12", "CreationDate": "2014-08-28T07:31:46.407", "ParentId": "25542390", "CommentCount": "12", "LastEditDate": "2017-05-23T12:09:14.080", "OwnerUserId": "241631"}, "25543633": {"Id": "25543633", "PostTypeId": "2", "Body": "<p>I think the other answers sort of missed the point of the question:</p>\n<blockquote>\n<p id=\"so_25542390_25543633_0\">I wish to access the members the same way as you would with this.</p>\n</blockquote>\n<p>In other words, the question is really \"how do I define a type <code>vec</code> in a standard-compliant manner such that given an object <code>u</code> of that type, <code>u.x</code>, <code>u.r</code>, and <code>u.elements[0]</code> all refer to the same thing?\" </p>\n<p>Well, if you insist on that syntax...then the obvious answer is: references.</p>\n<p>So:</p>\n<pre><code>template &lt;typename some_type&gt;\nstruct vec\n{\n    vec() = default;\n    vec(const vec&amp; other) : elements{ other.elements[0], other.elements[1], other.elements[2] } {}\n\n    vec &amp; operator=(const vec &amp;other) {\n        elements[0] = other.elements[0];\n        elements[1] = other.elements[1];\n        elements[2] = other.elements[2];\n        return *this;\n    }\n\n    some_type elements[3];\n    some_type &amp;x = elements[0], &amp;y = elements[1], &amp;z = elements[2];\n    some_type &amp;r = elements[0], &amp;g = elements[1], &amp;b = elements[2];    \n};\n</code></pre>\n<p>The first problem with this approach is that you need extra space for 6 reference members - which is rather expensive for such a small struct. </p>\n<p>The second problem with this approach is that given <code>const vec&lt;double&gt; v;</code>, <code>v.x</code> is still of type <code>double &amp;</code>, so you could write <code>v.x = 20;</code> and have it compile without warning or error - only to get undefined behavior. Pretty bad.</p>\n<p>So, in the alternative, you might consider using accessor functions:</p>\n<pre><code>template &lt;typename some_type&gt;\nstruct vec\n{   \n    some_type elements[3];\n    some_type &amp;x() { return elements[0]; }\n    const some_type &amp;x() const { return elements[0]; }\n\n    some_type &amp;y() { return elements[1]; }\n    const some_type &amp;y() const { return elements[1]; }\n\n    some_type &amp;z() { return elements[2]; }\n    const some_type &amp;z() const { return elements[2]; }\n\n    some_type &amp;r() { return elements[0]; }\n    const some_type &amp;r() const { return elements[0]; }\n\n    some_type &amp;g() { return elements[1]; }\n    const some_type &amp;g() const { return elements[1]; }\n\n    some_type &amp;b() { return elements[2]; }\n    const some_type &amp;b() const { return elements[2]; }\n};\n</code></pre>\n<p>You would have to write <code>u.x()</code> etc. instead of <code>u.x</code>, but the space savings is considerable, you can also rely on the compiler-generated special member functions, it's trivially copyable if <code>some_type</code> is (which enables some optimizations), it's an aggregate and so can use the aggregate initialization syntax, and it's also const-correct.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e35f50dc5614235d\" rel=\"nofollow\">Demo</a>. Note that <code>sizeof(vec&lt;double&gt;)</code> is 72 for the first version and only 24 for the second.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-28T08:12:10.523", "Score": "5", "CreationDate": "2014-08-28T07:57:04.727", "ParentId": "25542390", "CommentCount": "1", "LastEditDate": "2014-08-28T08:12:10.523", "OwnerUserId": "2756719"}});