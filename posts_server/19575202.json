post_cb({"19575566": {"Id": "19575566", "PostTypeId": "2", "Body": "<p>Global variables (and function local statics) with constructors can cause a lot of unexpected problems in many situations. As programs grow in size and complexity these things can get to be very hard to manage.</p>\n<p>You will be better off if you manage them explicitly - because then you get explicit control over the order of construction/destruction and when these things happen.</p>\n<p>If you use a vector as suggested above, then as the program exits the vector will be freed. But, you cannot directly control the order in which this happens, so if getNextPass() is called as part of something else which is being cleaned up (so, after main() returns), it will likely crash and you will have to puzzle out why and how to get the ordering correct.</p>\n<p>Also note that function local static initialization is not thread-safe in general. GCC has a thread-safe initialization mechanism, but other compilers (like VC) do not. Even when supported it isn't free and may require an option to enable.</p>\n<p>Doing it manually (very similar to the auto-generated code by the compiler):</p>\n<pre><code>inline char* getNextPass()\n{\n    static bool initialized;\n    static int chars_num;\n    static int pass_len;\n    static int *cur_pos;\n    if (!initialized) {\n        chars_num = chars_data.charset_len;\n        pass_len = chars_data.pass_len ;\n        cur_pos = new int[pass_len];    \n\n        for(int aa = 0; aa &lt; pass_len; aa++)  \n            cur_pos[aa] = 0 ;\n        initialized = true;\n    }\n    ...\n\n}\n</code></pre>\n<p>To clarify a bit \"with constructors\" means an initialization which requires code to execute to do.\nSo, \"static int x = 5;\" does not, but \"static int y = rand();\" does.</p>\n", "LastEditorUserId": "1791696", "LastActivityDate": "2013-10-24T20:16:23.910", "Score": "0", "CreationDate": "2013-10-24T20:05:40.537", "ParentId": "19575202", "CommentCount": "0", "OwnerUserId": "1791696", "LastEditDate": "2013-10-24T20:16:23.910"}, "bq_ids": {"n4140": {"so_19575202_19575287_1": {"length": 7, "quality": 1.0, "section_id": 3290}, "so_19575202_19575287_6": {"length": 6, "quality": 1.0, "section_id": 3287}, "so_19575202_19575287_3": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_19575202_19575287_11": {"length": 17, "quality": 1.0, "section_id": 3285}, "so_19575202_19575287_5": {"length": 12, "quality": 0.75, "section_id": 3287}, "so_19575202_19575287_14": {"length": 4, "quality": 1.0, "section_id": 3285}, "so_19575202_19575287_4": {"length": 12, "quality": 0.7058823529411765, "section_id": 3286}, "so_19575202_19575287_12": {"length": 14, "quality": 0.875, "section_id": 3285}, "so_19575202_19575287_9": {"length": 5, "quality": 1.0, "section_id": 3285}, "so_19575202_19575287_15": {"length": 10, "quality": 0.6666666666666666, "section_id": 3285}, "so_19575202_19575287_13": {"length": 5, "quality": 1.0, "section_id": 3285}}, "n3337": {"so_19575202_19575287_1": {"length": 7, "quality": 1.0, "section_id": 3160}, "so_19575202_19575287_11": {"length": 17, "quality": 1.0, "section_id": 3155}, "so_19575202_19575287_5": {"length": 16, "quality": 1.0, "section_id": 3157}, "so_19575202_19575287_14": {"length": 4, "quality": 1.0, "section_id": 3155}, "so_19575202_19575287_4": {"length": 16, "quality": 0.9411764705882353, "section_id": 3157}, "so_19575202_19575287_9": {"length": 5, "quality": 1.0, "section_id": 3155}, "so_19575202_19575287_15": {"length": 13, "quality": 0.8666666666666667, "section_id": 3155}, "so_19575202_19575287_13": {"length": 5, "quality": 1.0, "section_id": 3155}, "so_19575202_19575287_6": {"length": 6, "quality": 1.0, "section_id": 3157}, "so_19575202_19575287_3": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_19575202_19575287_12": {"length": 14, "quality": 0.875, "section_id": 3155}, "so_19575202_19575287_10": {"length": 11, "quality": 0.9166666666666666, "section_id": 3155}}, "n4659": {"so_19575202_19575287_1": {"length": 7, "quality": 1.0, "section_id": 4052}, "so_19575202_19575287_6": {"length": 6, "quality": 1.0, "section_id": 4049}, "so_19575202_19575287_11": {"length": 16, "quality": 0.9411764705882353, "section_id": 4047}, "so_19575202_19575287_5": {"length": 11, "quality": 0.6875, "section_id": 4049}, "so_19575202_19575287_14": {"length": 4, "quality": 1.0, "section_id": 4047}, "so_19575202_19575287_4": {"length": 11, "quality": 0.6470588235294118, "section_id": 4049}, "so_19575202_19575287_12": {"length": 14, "quality": 0.875, "section_id": 4047}, "so_19575202_19575287_9": {"length": 4, "quality": 0.8, "section_id": 653}, "so_19575202_19575287_15": {"length": 10, "quality": 0.6666666666666666, "section_id": 4047}, "so_19575202_19575287_13": {"length": 5, "quality": 1.0, "section_id": 4047}}}, "19575202": {"ViewCount": "375", "Body": "<p>I know that variable which is declared with 'static' modifier in a C++ function is initialized only once and what I want to do is to initialize static dynamically allocated array with appropriate content. Here is my code fragment:</p>\n<pre><code>inline char* getNextPass()\n{\n    static int chars_num = chars_data.charset_len, pass_len = chars_data.pass_len ;\n    static int *cur_pos = new int[pass_len] ;  // this is static variable in function, what means it's initialized only once\n\n    ...\n    for(int aa = 0; aa &lt; pass_len; aa++)  // this is executed every time the function is called. How can I make this code execute only once ?\n    cur_pos[aa] = 0 ;\n    ...\n}\n</code></pre>\n<p>I know of course that I could do something like this:</p>\n<pre><code>...\nflag = true ;\n...\ninline char* getNextPass()\n{\n    ...\n    if(flag)\n    for(int aa = 0; aa &lt; pass_len; aa++)\n    cur_pos[aa] = 0 ;\n    flag = false ;\n    ...\n}\n</code></pre>\n<p>but it's probably not optimal way of coding and can be done somehow more effectively. Can I use 'static' moddifier some way to make more optimized implementation ?</p>\n", "AcceptedAnswerId": "19575301", "Title": "How to make static initialization of a static dynamically allocated array in C++?", "CreationDate": "2013-10-24T19:46:46.200", "Id": "19575202", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2013-10-24T20:16:23.910", "Score": "2", "OwnerUserId": "1978386", "Tags": "<c++><static><initialization>", "AnswerCount": "4"}, "19575329": {"Id": "19575329", "PostTypeId": "2", "Body": "<p>Create a static function called AllocAndInit and call it like this (inside the function allocate and init the array you allocated):</p>\n<pre><code>static int *cur_pos = AllocAndInit(pass_len);\n</code></pre>\n<p>the AllocAndInit method should look like this :</p>\n<pre><code>int * AllocAndInit(pass_len)\n{\n    int * ret = new int[pass_len];\n    for (int i = 0 ; i &lt; pass_len; ++i)\n    // init here ....\n\n    return ret;\n}\n</code></pre>\n", "LastActivityDate": "2013-10-24T19:53:32.953", "CommentCount": "0", "CreationDate": "2013-10-24T19:53:32.953", "ParentId": "19575202", "Score": "0", "OwnerUserId": "2878178"}, "19575301": {"Id": "19575301", "PostTypeId": "2", "Body": "<p>Ditch the pointer and use <code>vector</code></p>\n<pre><code>static vector&lt;int&gt; cur_pos(pass_len, 0);\n</code></pre>\n<p>The benefit is that it cleans itself up (no more calling <code>delete</code>.) cha-ching!</p>\n", "LastActivityDate": "2013-10-24T19:52:00.580", "CommentCount": "0", "CreationDate": "2013-10-24T19:52:00.580", "ParentId": "19575202", "Score": "3", "OwnerUserId": "154744"}, "19575287": {"Id": "19575287", "PostTypeId": "2", "Body": "<p>If you want it prefilled with zeros (and it appears you do), the most-minimal change I can think of is to value-initialize that array with a C++11 compliant toolchain. I.e. </p>\n<pre><code>static int *cur_pos = new int[pass_len](); // note the tail-parens.\n</code></pre>\n<p>Regarding why it works, highlighted portions applicable to how your initial allocation is filled with zeros if done as I describe.</p>\n<blockquote>\n<p id=\"so_19575202_19575287_0\"><strong>C++11 \u00a7 8.5,p10</strong></p>\n<p id=\"so_19575202_19575287_1\">An object whose initializer is an empty set of parentheses, i.e., <strong>()</strong>, shall be <strong>value-initialized</strong>.</p>\n</blockquote>\n<p>By the definition of <em>value initialization</em>:</p>\n<blockquote>\n<p id=\"so_19575202_19575287_2\"><strong>C++11 \u00a7 8.5,p7</strong></p>\n<p id=\"so_19575202_19575287_3\">To value-initialize an object of type T means:</p>\n<ul>\n<li><p id=\"so_19575202_19575287_4\">if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p></li>\n<li><p id=\"so_19575202_19575287_5\">if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</p></li>\n<li><p id=\"so_19575202_19575287_6\">if T is an array type, then <strong>each element is value-initialized;</strong></p></li>\n<li><p id=\"so_19575202_19575287_7\">otherwise, the object is <strong>zero-initialized.</strong></p></li>\n</ul>\n</blockquote>\n<p>Which brings us to what it means for your object-type to be <em>zero-initialized</em>:</p>\n<blockquote>\n<p id=\"so_19575202_19575287_8\"><strong>C++11 \u00a7 8.5,p5</strong></p>\n<p id=\"so_19575202_19575287_9\">To zero-initialize an object or reference of type T means:</p>\n<ul>\n<li><p id=\"so_19575202_19575287_10\"><strong>if T is a scalar type (3.9), the object is set to the value 0 (zero), taken as an integral constant expression, converted to T <sub>(103)</sub></strong></p></li>\n<li><p id=\"so_19575202_19575287_11\">if T is a (possibly cv-qualified) non-union class type, each non-static data member and each base-class subobject is zero-initialized** and padding is initialized to zero bits;</p></li>\n<li><p id=\"so_19575202_19575287_12\">if T is a (possibly cv-qualified) union type, the object\u2019s first non-static named data member is zero- initialized and padding is initialized to zero bits;</p></li>\n<li><p id=\"so_19575202_19575287_13\">if T is an array type, each element is zero-initialized;</p></li>\n<li><p id=\"so_19575202_19575287_14\">if T is a reference type, no initialization is performed.</p></li>\n</ul>\n<p id=\"so_19575202_19575287_15\">103) As specified in 4.10, converting an integral constant expression whose value is 0 to a pointer type results in a null pointer value.</p>\n</blockquote>\n", "LastEditorUserId": "1322972", "LastActivityDate": "2013-10-24T20:01:58.843", "Score": "1", "CreationDate": "2013-10-24T19:51:19.143", "ParentId": "19575202", "CommentCount": "8", "OwnerUserId": "1322972", "LastEditDate": "2013-10-24T20:01:58.843"}});