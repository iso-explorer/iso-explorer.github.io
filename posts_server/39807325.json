post_cb({"bq_ids": {"n4140": {"so_39807325_39807325_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 261}}, "n3337": {"so_39807325_39807325_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 252}}, "n4659": {"so_39807325_39807325_0": {"length": 38, "quality": 0.9047619047619048, "section_id": 268}}}, "42353137": {"Id": "42353137", "PostTypeId": "2", "Body": "<p>This question is covered by Herb Sutter's <a href=\"http://www.gotw.ca/gotw/076.htm\" rel=\"nofollow noreferrer\">GotW #76</a>. Member functions are expected to be able to access private members of a class. When member function is a template, you would expect to be able to specialize such template. This is a conflict between the C++ access control model and the template model, which could be avoided by complicating (already complex) C++ standard. While it is possible to bypass C++ access controls and access private members in this way, you are strongly advised against doing that.</p>\n<p><em>Note: @Xeo already explained most of these points in his comments above.</em></p>\n", "LastActivityDate": "2017-02-20T19:52:45.903", "CommentCount": "0", "CreationDate": "2017-02-20T19:52:45.903", "ParentId": "39807325", "Score": "1", "OwnerUserId": "301644"}, "39807325": {"ViewCount": "156", "Body": "<p>[temp.explicit] contains this wording:</p>\n<blockquote>\n<p id=\"so_39807325_39807325_0\">The usual access checking rules do not apply to names used to specify explicit instantiations. <em>[Note:</em> In\n  particular, the template arguments and names used in the function declarator (including parameter types,\n  return types and exception specifications) may be private types or objects which would normally not be\n  accessible and the template may be a member template or member function which would not normally be\n  accessible. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Why are those rules disabled specifically for this case? In the extreme, this allows for <a href=\"https://stackoverflow.com/a/3173080/2069064\">arbitrary access of any private member of any class</a> in a well-defined way (<a href=\"http://coliru.stacked-crooked.com/a/6281562bf1aac906\" rel=\"nofollow noreferrer\">demo</a> - zero warnings):</p>\n<blockquote id=\"so_39807325_39807325_1\">\n<pre><code>struct A {\nprivate:\n  int member;\n};\n\ntemplate&lt;typename Tag, typename Tag::type M&gt;\nstruct Rob { \n  friend typename Tag::type get(Tag) {\n    return M;\n  }\n};\n\n// tag used to access A::member\nstruct A_member { \n  typedef int A::*type;\n  friend type get(A_member);\n};\n\ntemplate struct Rob&lt;A_member, &amp;A::member&gt;;\n\nint main() {\n  A a;\n  a.*get(A_member()) = 42; // write 42 to it\n  std::cout &lt;&lt; \"proof: \" &lt;&lt; a.*get(A_member()) &lt;&lt; std::endl;\n}\n</code></pre>\n</blockquote>\n<p>So that's the downside of this rule. What's the upside? Why do we need this hole to avoid access checking?</p>\n", "Title": "Why does a hole for access checking exist for explicit template instantiations?", "CreationDate": "2016-10-01T13:39:47.177", "LastActivityDate": "2017-02-20T19:52:45.903", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:54:20.443", "Tags": "<c++><templates>", "Id": "39807325", "LastEditorUserId": "-1", "Score": "11", "OwnerUserId": "2069064", "ClosedDate": "2017-06-07T10:45:44.550", "AnswerCount": "1"}});