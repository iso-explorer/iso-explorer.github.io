post_cb({"20800786": {"ParentId": "20800684", "CommentCount": "2", "Body": "<p>The problem is that according to the C++ Standard </p>\n<blockquote>\n<p id=\"so_20800684_20800786_0\">Except where noted, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>So this expression</p>\n<pre><code>a=(a+b)-(b=a);\n</code></pre>\n<p>has undefined behavioir.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "20800786", "Score": "5", "CreationDate": "2013-12-27T12:31:44.900", "LastActivityDate": "2013-12-27T12:31:44.900"}, "20805492": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_20800684_20805492_0\">My Question is - Is this an acceptable solution to swap two integers?</p>\n</blockquote>\n<p>Acceptable to who? If you're asking if it is acceptable to me, that would not get past any code review I was in, believe me.</p>\n<blockquote>\n<p id=\"so_20800684_20805492_1\">why is a=(a+b)-(b=a) a bad choice for swapping two integers?</p>\n</blockquote>\n<p>For the following reasons:</p>\n<p>1) As you note, there is no guarantee in C that it actually does that. It could do anything.</p>\n<p>2) Suppose for the sake of argument that it really does swap two integers, as it does in C#. (C# guarantees that side effects happen left-to-right.) The code would still be unacceptable because it is completely not obvious what its meaning is!  Code shouldn't be a bunch of clever tricks. Write code for the person coming after you who has to read and understand it.</p>\n<p>3) Again, suppose that it works. The code is still unacceptable because this is just plain false:</p>\n<blockquote>\n<p id=\"so_20800684_20805492_2\">I stumbled into this code for swapping two integers without using a Temporary variable or the use of bit-wise operators.</p>\n</blockquote>\n<p>That's simply false. This trick uses a temporary variable to store the computation of <code>a+b</code>. The variable is generated by the compiler on your behalf and not given a name, but it's there.  If the goal is to eliminate temporaries, this makes it worse, not better! And why would you want to eliminate temporaries in the first place? They're cheap!</p>\n<p>4) This only works for integers. Lots of things need to be swapped other than integers.</p>\n<p>In short, spend your time concentrating on writing code that is obviously correct, rather than trying to come up with clever tricks that actually make things worse.</p>\n", "OwnerUserId": "88656", "LastEditorUserId": "2455888", "LastEditDate": "2013-12-27T18:30:15.920", "Id": "20805492", "Score": "48", "CreationDate": "2013-12-27T17:59:06.100", "LastActivityDate": "2013-12-27T18:30:15.920"}, "20800684": {"CommentCount": "20", "ViewCount": "7048", "PostTypeId": "1", "LastEditorDisplayName": "user1508519", "CreationDate": "2013-12-27T12:24:38.120", "LastActivityDate": "2016-12-09T17:34:50.300", "LastEditDate": "2013-12-27T20:43:06.160", "AcceptedAnswerId": "20800762", "FavoriteCount": "15", "Title": "Why is a = (a+b) - (b=a) a bad choice for swapping two integers?", "Id": "20800684", "Score": "57", "Body": "<p>I stumbled into this code for swapping two integers without using a temporary variable or the use of bitwise operators.</p>\n<pre><code>int main(){\n\n    int a=2,b=3;\n    printf(\"a=%d,b=%d\",a,b);\n    a=(a+b)-(b=a);\n    printf(\"\\na=%d,b=%d\",a,b);\n    return 0;\n}\n</code></pre>\n<p>But I think this code has undefined behavior in the swap statement <code>a = (a+b) - (b=a);</code> as it does not contain any <strong>sequence points</strong> to determine the order of evaluation. </p>\n<p>My question is: <em>Is this an acceptable solution to swap two integers?</em></p>\n", "Tags": "<c++><c><swap><undefined-behavior><sequence-points>", "OwnerUserId": "2412425", "AnswerCount": "10"}, "20800762": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>No. This is not acceptable. This code invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\"><strong>Undefined behavior</strong></a>. This is because of the operation on <code>b</code> is not defined. In the expression  </p>\n<pre><code>a=(a+b)-(b=a);  \n</code></pre>\n<p>it is not certain whether <code>b</code> gets modified first or its value gets used in the expression (<code>a+b</code>) because of the lack of the <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">sequence point</a>.<br>\nSee what standard syas:  </br></p>\n<h2>C11: 6.5 Expressions:</h2>\n<blockquote>\n<p id=\"so_20800684_20800762_0\">If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or <strong>a value computation using the value of the same scalar\n  object</strong>, the behavior is undefined. <strong>If there are multiple allowable orderings of the\n  subexpressions of an expression, the behavior is undefined if such an unsequenced side\n  effect occurs in any of the orderings.84)</strong><sub>1</sub>.   </p>\n</blockquote>\n<p>Read <a href=\"http://www.c-faq.com/expr/seqpoints.html\" rel=\"nofollow noreferrer\">C-faq- 3.8</a> and this <a href=\"https://stackoverflow.com/a/17629411/2455888\">answer</a> for more detailed explanation of sequence point and undefined behavior.   </p>\n<hr>\n<p><sub>1. Emphasis is mine.</sub></p>\n</hr>", "OwnerUserId": "2455888", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:17.443", "Id": "20800762", "Score": "83", "CreationDate": "2013-12-27T12:29:58.810", "LastActivityDate": "2015-06-03T09:21:51.203"}, "bq_ids": {"n4140": {"so_20800684_20805797_7": {"section_id": 5811, "quality": 0.95, "length": 19}, "so_20800684_20800786_0": {"section_id": 5811, "quality": 1.0, "length": 11}, "so_20800684_20805797_9": {"section_id": 5811, "quality": 0.5833333333333334, "length": 21}, "so_20800684_20800762_0": {"section_id": 5811, "quality": 0.5833333333333334, "length": 21}}, "n3337": {"so_20800684_20805797_7": {"section_id": 5584, "quality": 0.95, "length": 19}, "so_20800684_20800786_0": {"section_id": 5584, "quality": 1.0, "length": 11}, "so_20800684_20805797_9": {"section_id": 5584, "quality": 0.5833333333333334, "length": 21}, "so_20800684_20800762_0": {"section_id": 5584, "quality": 0.5833333333333334, "length": 21}}, "n4659": {"so_20800684_20805797_7": {"section_id": 7272, "quality": 0.65, "length": 13}, "so_20800684_20800786_0": {"section_id": 7272, "quality": 1.0, "length": 11}}}, "20800837": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There are at least two problems with <code>a=(a+b)-(b=a)</code>.</p>\n<p>One you mention yourself: the lack of sequence points means that the behavior is undefined. As such, anything at all could happen. For example, there is no guarantee of which is evaluated first: <code>a+b</code> or <code>b=a</code>. The compiler may choose to generate code for the assignment first, or do something completely different.</p>\n<p>Another problem is the fact that the overflow of signed arithmetic is undefined behavior. If <code>a+b</code> overflows there is no guarantee of the results; even an exception might be thrown.</p>\n", "OwnerUserId": "318758", "LastEditorUserId": "318758", "LastEditDate": "2013-12-27T18:14:29.587", "Id": "20800837", "Score": "32", "CreationDate": "2013-12-27T12:35:48.190", "LastActivityDate": "2013-12-27T18:14:29.587"}, "20800814": {"ParentId": "20800684", "CommentCount": "0", "Body": "<p>The statement:</p>\n<pre><code>a=(a+b)-(b=a);\n</code></pre>\n<p>invokes undefined behavior. The second shall in the quoted paragraph is violated:</p>\n<blockquote>\n<p id=\"so_20800684_20800814_0\">(C99, 6.5p2) \"Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. <strong>Furthermore, the prior value shall be read only to determine the value to be stored.</strong>\"</p>\n</blockquote>\n", "OwnerUserId": "1119701", "PostTypeId": "2", "Id": "20800814", "Score": "8", "CreationDate": "2013-12-27T12:33:45.570", "LastActivityDate": "2013-12-27T12:33:45.570"}, "20804586": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>If you use gcc and <code>-Wall</code> the compiler already warns you </p>\n<blockquote>\n<p id=\"so_20800684_20804586_0\">a.c:3:26: warning: operation on \u2018b\u2019 may be undefined [-Wsequence-point]  </p>\n</blockquote>\n<p>Whether to use such a construct is debatable from an performance point as well. When you look at </p>\n<pre><code>void swap1(int *a, int *b)\n{\n    *a = (*a + *b) - (*b = *a);\n}\n\nvoid swap2(int *a, int *b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n</code></pre>\n<p>and examine the assembly code </p>\n<pre><code>swap1:\n.LFB0:\n    .cfi_startproc\n    movl    (%rdi), %edx\n    movl    (%rsi), %eax\n    movl    %edx, (%rsi)\n    movl    %eax, (%rdi)\n    ret\n    .cfi_endproc\n\nswap2:\n.LFB1:\n    .cfi_startproc\n    movl    (%rdi), %eax\n    movl    (%rsi), %edx\n    movl    %edx, (%rdi)\n    movl    %eax, (%rsi)\n    ret\n    .cfi_endproc\n</code></pre>\n<p>you can see no benefit for obfuscating the code.</p>\n<hr>\n<p>Looking at C++ (g++) code, which does basically the same, but takes <code>move</code> into account </p>\n<pre><code>#include &lt;algorithm&gt;\n\nvoid swap3(int *a, int *b)\n{\n    std::swap(*a, *b);\n}\n</code></pre>\n<p>gives identical assembly output </p>\n<pre><code>_Z5swap3PiS_:\n.LFB417:\n    .cfi_startproc\n    movl    (%rdi), %eax\n    movl    (%rsi), %edx\n    movl    %edx, (%rdi)\n    movl    %eax, (%rsi)\n    ret\n    .cfi_endproc\n</code></pre>\n<p>Taking gcc's warning into account and seeing no technical gain, I would say, stick with standard techniques. If this ever becomes a bottleneck, you can still investigate, how to improve or avoid this small piece of code.</p>\n</hr>", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2015-04-18T10:09:43.283", "Id": "20804586", "Score": "28", "CreationDate": "2013-12-27T16:57:55.850", "LastActivityDate": "2015-04-18T10:09:43.283"}, "20800796": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Apart from the other answers, about undefined behavior and style, if you write simple code that just uses a temporary variable the compiler can likely trace the values and not actually swap them in the generated code, and just use the swapped values later on in some cases. It cant do that with your code. The compiler is usually better than you at micro optimizations. </p>\n<p>So it's likely your code is slower, harder to understand, and probably unreliable undefined behavior too.</p>\n", "OwnerUserId": "417292", "LastEditorUserId": "417292", "LastEditDate": "2013-12-27T13:03:50.707", "Id": "20800796", "Score": "29", "CreationDate": "2013-12-27T12:32:30.417", "LastActivityDate": "2013-12-27T13:03:50.707"}, "20805797": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A question was posted back in <a href=\"https://stackoverflow.com/questions/3647331/how-to-swap-two-numbers-without-using-temp-variables-or-arithmetic-operations?rq=1\">2010</a> with the exact same example.</p>\n<pre><code>a = (a+b) - (b=a);\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/3647331/how-to-swap-two-numbers-without-using-temp-variables-or-arithmetic-operations?rq=1#comment3835074_3647331\">Steve Jessop</a> warns against it:</p>\n<blockquote>\n<p id=\"so_20800684_20805797_0\">Behaviour of that code is undefined, by the way. Both a and b are read\n  and written without an intervening sequence point. For starters, the\n  compiler would be well within its rights to evaluate b=a before\n  evaluating a+b.</p>\n</blockquote>\n<p>Here's an explanation from a question posted in <a href=\"https://stackoverflow.com/questions/13317684/why-does-the-expression-a-a-b-b-a-give-a-sequence-point-warning-in-c\">2012</a>. Note that the sample is not <em>exactly</em> the same because of the lack of parentheses, but the answer is still relevant nonetheless.</p>\n<blockquote>\n<p id=\"so_20800684_20805797_1\">In C++, subexpressions in arithmetic expressions do not have temporal\n  ordering.</p>\n<p id=\"so_20800684_20805797_2\"><code>a = x + y;</code></p>\n<p id=\"so_20800684_20805797_3\">Is x evaluated first, or y? The compiler can choose either, or it can\n  choose something completely different. The order of evaluation is not\n  the same thing as operator precedence: operator precedence is strictly\n  defined, and <b>order of evaluation is only defined to the granularity\n  that your program has sequence points.</b></p>\n<p id=\"so_20800684_20805797_4\">In fact, on some architectures it is possible to emit code that\n  evaluates both x and y at the same time -- for example, VLIW\n  architectures.</p>\n</blockquote>\n<p>Now for C11 standard quotes from N1570:</p>\n<h3>Annex J.1/1</h3>\n<p>It is unspecified behavior when:</p>\n<blockquote>\n<p id=\"so_20800684_20805797_5\">\u2014 The order\n  in which subexpressions are evaluated and the order in which side\n  effects take place, except as specified for the function-call <code>()</code>, <code>&amp;&amp;</code>,\n  <code>||</code>, <code>? :</code>, and comma operators (6.5).</p>\n<p id=\"so_20800684_20805797_6\">\u2014 The order in which the operands of an assignment operator are evaluated (6.5.16).</p>\n</blockquote>\n<h3>Annex J.2/1</h3>\n<p>It is undefined behavior when:</p>\n<blockquote>\n<p id=\"so_20800684_20805797_7\">\u2014 A side effect on a scalar object is unsequenced relative to either a\n  different side effect on the same scalar object or a value computation\n  using the value of the same scalar object (6.5).</p>\n</blockquote>\n<h3>6.5/1</h3>\n<blockquote>\n<p id=\"so_20800684_20805797_8\">An expression is a sequence of operators and operands that specifies\n  computation of a value, or that designates an object or a function, or\n  that generates side effects, or that performs a combination thereof.\n  The value computations of the operands of an operator are sequenced\n  before the value computation of the result of the operator.</p>\n</blockquote>\n<h3>6.5/2</h3>\n<blockquote>\n<p id=\"so_20800684_20805797_9\">If a side effect on a scalar object is unsequenced relative to either\n  a different side effect on the same scalar object or a value\n  computation using the value of the same scalar object, the behavior is\n  undefined. If there are multiple allowable orderings of the\n  subexpressions of an expression, the behavior is undefined if such an\n  unsequenced side effect occurs in any of the orderings.84)</p>\n</blockquote>\n<h3>6.5/3</h3>\n<blockquote>\n<p id=\"so_20800684_20805797_10\">The grouping of operators and operands is indicated by the syntax.85)\n  Except as specified later, side effects and value computations of\n  subexpressions are unsequenced.86)</p>\n</blockquote>\n<p>You shouldn't rely on undefined behavior.</p>\n<p>Some alternatives: In C++ you can use</p>\n<pre><code>  std::swap(a, b);\n</code></pre>\n<p>XOR-swap:</p>\n<pre><code>  a = a^b;\n  b = a^b;\n  a = a^b;\n</code></pre>\n", "Id": "20805797", "LastEditDate": "2017-05-23T12:17:05.377", "OwnerDisplayName": "user1508519", "Score": "8", "CreationDate": "2013-12-27T18:24:11.860", "LastActivityDate": "2013-12-28T14:04:59.537", "LastEditorUserId": "-1"}, "20807498": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Besides the problems invoked by the other users, this type of swap has another problem: <strong>the domain</strong>.</p>\n<p>What if <code>a+b</code> goes beyond it's limit? Let's say we work with number from <code>0</code> to <code>100</code>. <code>80+ 60</code> would go out of range.</p>\n", "OwnerUserId": "870659", "LastEditorUserId": "2455888", "LastEditDate": "2013-12-28T13:01:30.143", "Id": "20807498", "Score": "4", "CreationDate": "2013-12-27T20:38:12.193", "LastActivityDate": "2013-12-28T13:01:30.143"}, "20800709": {"ParentId": "20800684", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>You can use <a href=\"http://en.wikipedia.org/wiki/XOR_swap_algorithm\" rel=\"nofollow\">XOR swap algorithm</a> to prevent any overflow issues and still have a one-liner.</p>\n<p>But, since you've got a <code>c++</code> tag, I'd prefer just a simple <code>std::swap(a, b)</code> to make it more easily readable. </p>\n", "OwnerUserId": "1280800", "LastEditorUserId": "2455888", "LastEditDate": "2013-12-29T07:54:34.070", "Id": "20800709", "Score": "5", "CreationDate": "2013-12-27T12:26:11.553", "LastActivityDate": "2013-12-29T07:54:34.070"}});