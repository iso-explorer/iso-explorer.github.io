post_cb({"bq_ids": {"n4140": {"so_27746467_27746467_0": {"length": 15, "quality": 1.0, "section_id": 5446}, "so_27746467_27747057_0": {"length": 10, "quality": 1.0, "section_id": 5455}}, "n3337": {"so_27746467_27746467_0": {"length": 9, "quality": 0.6, "section_id": 5541}, "so_27746467_27747057_0": {"length": 6, "quality": 0.6, "section_id": 3191}}, "n4659": {"so_27746467_27746467_0": {"length": 15, "quality": 1.0, "section_id": 6873}, "so_27746467_27747057_0": {"length": 10, "quality": 1.0, "section_id": 6881}}}, "27747057": {"Id": "27747057", "PostTypeId": "2", "Body": "<p>The applicable rule is found in \u00a77.1.6.4 [dcl.spec.auto]/p11:</p>\n<blockquote>\n<p id=\"so_27746467_27747057_0\">If the type of an entity with an undeduced placeholder type is needed\n  to determine the type of an expression, the program is ill-formed.</p>\n</blockquote>\n<p>There's an example:</p>\n<pre><code>auto f();\nvoid g() { &amp;f; }  // error, f\u2019s return type is unknown\n</code></pre>\n<p>You need the type of <code>gen_data</code> to determine the type of the expression <code>x.gen_data()</code>; hence the program is ill-formed. To use such a function, the definition must be visible to the compiler.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-01-02T18:57:43.167", "Score": "2", "CreationDate": "2015-01-02T18:50:48.080", "ParentId": "27746467", "CommentCount": "5", "LastEditDate": "2015-01-02T18:57:43.167", "OwnerUserId": "2756719"}, "27746467": {"ViewCount": "194", "Body": "<p>I'm having some trouble understanding how the C++14 extension of the <code>auto</code> type-specifier described in <a href=\"http://isocpp.org/files/papers/N3638.html\" rel=\"nofollow\">N3638</a> can possibly be implemented, and what, exactly, is allowed.</p>\n<p>Specifically, one of the changes to the standard says,</p>\n<blockquote>\n<p id=\"so_27746467_27746467_0\">If the declared return type of the function contains a placeholder type, the return type of the function is deduced from return statements in the body of the function, if any.</p>\n</blockquote>\n<p>It is easy enough to see how this works when body of the function is in the same file as the declaration; but consider the case where a header file declares a method using the <code>auto</code> placeholder but <em>does not define</em> it. How can translation units that include this header file but do <em>not</em> include the file that defines the method be successfully compiled?</p>\n<p>For instance, given the file <code>foo.hpp</code>:</p>\n<pre><code>class foo\n{\n  public:\n    auto gen_data();\n};\n</code></pre>\n<p>...and file <code>foo.cpp</code>:</p>\n<pre><code>struct data_struct\n{\n  int a;\n  int b;\n  int c;\n  double x;\n  char data[37];\n};\n\nauto foo::gen_data()\n{\n  data_struct d;\n  // initialize members in d...\n  return d;\n}\n</code></pre>\n<p>...and file <code>main.cpp</code>:</p>\n<pre><code>#include \"foo.hpp\"\n\ntemplate&lt;typename T&gt;\ndouble get_x(T f)\n{\n  return f.gen_data().x;\n}\n\nint make_and_get_x()\n{\n  foo f;\n  return get_x&lt;foo&gt;(f);\n}\n</code></pre>\n<p>...is it legal to compile <code>main.cpp</code> on its own? If not, why not? If so, how is <code>get_x</code> instantiated, since there's no way for the compiler to know whether or not the return type of <code>gen_data</code> even has a member named <code>x</code>, let alone what its offset is?</p>\n<p>This seems like it would be a problem even without worrying about template instantiation, though; for instance, what would happen if you tried accessing <code>f.gen_data().x</code> directly, or passing it to a function?</p>\n", "Title": "Using functions that return placeholder types defined in another translation unit", "CreationDate": "2015-01-02T18:01:31.593", "LastActivityDate": "2015-01-02T18:57:43.167", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-01-02T18:09:27.967", "LastEditorUserId": "3953764", "Id": "27746467", "Score": "3", "OwnerUserId": "1858225", "Tags": "<c++><auto><c++14><return-type-deduction><translation-unit>", "AnswerCount": "1"}});