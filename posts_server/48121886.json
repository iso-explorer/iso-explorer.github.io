post_cb({"bq_ids": {"n4140": {"so_48121886_48144113_2": {"length": 8, "quality": 0.8, "section_id": 5879}}, "n3337": {"so_48121886_48144113_2": {"length": 6, "quality": 0.6, "section_id": 4512}}, "n4659": {"so_48121886_48144113_4": {"length": 16, "quality": 1.0, "section_id": 8733}, "so_48121886_48144113_2": {"length": 10, "quality": 1.0, "section_id": 8733}}}, "48121886": {"ViewCount": "71", "Body": "<p>What is the main aim of accessing data via a pointer address using reinterpret_cast. Is it faster, if so, how exactly?</p>\n<p>Below a program, which prints same struct data via . operator and via pointer(reinterpret cast).</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct values{\n    int one;\n    int two;\n    char three;\n    int four;\n};\n\nint main()\n{\n    values v { 8, 5, 'k', 653};\n\n    // access via . (or -&gt;) operator\n    cout &lt;&lt; v.one &lt;&lt; endl;\n    cout &lt;&lt; v.two &lt;&lt; endl;\n    cout &lt;&lt; v.three &lt;&lt; endl;\n    cout &lt;&lt; v.four &lt;&lt; endl;\n\n\n    //via pointer access - how can this be beneficial?\n    values* vPtr = &amp;v;\n    int* intPtr = reinterpret_cast&lt;int*&gt;(vPtr);\n    cout &lt;&lt; *intPtr &lt;&lt; endl;\n    intPtr++;\n    cout &lt;&lt; *intPtr &lt;&lt; endl;\n    intPtr++;\n    char* charPtr = reinterpret_cast&lt;char*&gt;(intPtr);\n    cout &lt;&lt; *charPtr &lt;&lt; endl;\n    charPtr += 4;\n    int* intPtr2 = reinterpret_cast&lt;int*&gt;(charPtr);\n    cout &lt;&lt; *intPtr2&lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "48144113", "Title": "Accessing data via pointer(reinterpret cast) vs . or -> operator", "CreationDate": "2018-01-05T22:01:03.687", "LastActivityDate": "2018-01-08T09:14:16.283", "CommentCount": "6", "LastEditDate": "2018-01-05T22:06:18.300", "PostTypeId": "1", "LastEditorUserId": "3893262", "Id": "48121886", "Score": "-1", "OwnerUserId": "7084234", "Tags": "<c++><pointers><disk><pointer-arithmetic><reinterpret-cast>", "AnswerCount": "3"}, "48142971": {"Id": "48142971", "PostTypeId": "2", "Body": "<p>What you have isn't reliable because when you increment intPtr, it advances through memory by the size of an integer (that's what you told it to point to).  There is no guarantee that the fields in the struct are integer-size apart.  They're not all integer-sized items, of course, and the compiler is free to add padding between fields in a struct.  Incrementing a pointer doesn't try to find where the next thing actually is, it just goes by the size of what it points to.  Which only works on arrays.</p>\n<p>Reinterpret_cast mostly tells the compiler to let you do something that it knows is a bad idea.  Such as trying to treat a struct as an array.  It's not going to speed anything up, unless it's something you shouldn't do.</p>\n", "LastActivityDate": "2018-01-08T00:44:32.477", "Score": "1", "CreationDate": "2018-01-08T00:44:32.477", "ParentId": "48121886", "CommentCount": "0", "OwnerUserId": "9166558"}, "48144113": {"Id": "48144113", "PostTypeId": "2", "Body": "<p>You can only access the first member via your so-called pointer access. This is permitted because <code>v</code> and <code>v.one</code> are pointer-interconvertible according to <a href=\"http://www.eel.is/c++draft/basic.compound#4\" rel=\"nofollow noreferrer\">[basic.compound] paragraph 4</a>:</p>\n<blockquote>\n<p id=\"so_48121886_48144113_0\">Two objects a and b are <em>pointer-interconvertible</em> if:</p>\n<ul>\n<li><p id=\"so_48121886_48144113_1\">...</p></li>\n<li><p id=\"so_48121886_48144113_2\">one is a standard-layout class object and the other is the first non-static data member of that object, or, ...</p></li>\n<li><p id=\"so_48121886_48144113_3\">...</p></li>\n</ul>\n<p id=\"so_48121886_48144113_4\">If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a <code>reinterpret_\u00adcast</code>.</p>\n</blockquote>\n<p>However, the only benefit I can see is that you can access the member even if you don't know its name (i.e. <code>one</code> in your example). </p>\n<p>Note: I believe there <strong>should be</strong> no performance gain. Otherwise, an optimizer can optimize the evaluation of <code>v.one</code> as if <code>reinterpret_cast&lt;int*&gt;(&amp;v)</code> is evaluated instead <strong>with knowing they are equivalent at compile time</strong>.</p>\n<hr>\n<p>Accessing other members via pointer access in your example is undefined behavior. As @TWBennet said, one reason is that there may be paddings between adjacent members. However, even if there is no padding, <code>intptr++</code> only obtains a <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.compound#3.2\" rel=\"nofollow noreferrer\">pointer past-the-end</a>, which will not automatically point to the member even at the same address. You can see details in <a href=\"https://stackoverflow.com/questions/48062346/is-a-pointer-with-the-right-address-and-type-still-always-a-valid-pointer-since\">that question</a>.</p>\n</hr>", "LastEditorUserId": "5376789", "LastActivityDate": "2018-01-08T09:14:16.283", "Score": "1", "CreationDate": "2018-01-08T04:08:58.847", "ParentId": "48121886", "CommentCount": "0", "OwnerUserId": "5376789", "LastEditDate": "2018-01-08T09:14:16.283"}, "48121999": {"Id": "48121999", "PostTypeId": "2", "Body": "<p>No it is not faster. (Although it depends on exactly what you want to do)</p>\n<p>Modifying your example a bit</p>\n<pre><code>char* charPtr = reinterpret_cast&lt;char*&gt;(&amp;v);\n</code></pre>\n<p>says, 'Let me treat this object as a raw array of bytes'. There are many reasons to want to do this. Many of them will be to do with copying things around via read,write,send,memcpy etc.</p>\n<p>you can also see the inverse</p>\n<pre><code>values *v = reinterpret_cast&lt;values*&gt;(buff);\n</code></pre>\n<p>Where you have an array of bytes that you want to treat as a struct (you just did a read of something you wrote before.</p>\n<p>Note that this is an advanced technique with many pitfalls to do with padding, byte order etc. Not a 100 level thing </p>\n", "LastActivityDate": "2018-01-05T22:11:16.713", "Score": "2", "CreationDate": "2018-01-05T22:11:16.713", "ParentId": "48121886", "CommentCount": "0", "OwnerUserId": "173397"}});