post_cb({"22002331": {"CommentCount": "0", "ViewCount": "81", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2014-02-25T00:43:11.667", "LastActivityDate": "2014-02-25T20:22:17.157", "Title": "nested exceptions and primitive types", "AcceptedAnswerId": "22002567", "LastEditDate": "2014-02-25T00:57:21.630", "Id": "22002331", "Score": "1", "Body": "<p>Can I use <code>std::throw_with_nested</code> when my captured exception is of primitive type?</p>\n<p>It is said, that the new type is derived from the captured exception and the new exception. But I can not derive from primitives types like <code>int</code>. Therefore I can not use nested exceptions with primitive types. Is that true?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "503521", "AnswerCount": "3"}, "22010235": {"ParentId": "22002331", "LastEditDate": "2014-02-25T20:22:17.157", "CommentCount": "0", "CreationDate": "2014-02-25T09:46:08.373", "OwnerUserId": "365460", "LastEditorUserId": "365460", "PostTypeId": "2", "Id": "22010235", "Score": "1", "Body": "<p>The exception thrown is an unspecified type derived from the <em>new</em> exception and <code>std::nested_exception</code> (not the new and the captured). The <code>std::nested_exception</code> then contains a <code>std::exception_ptr</code> to the captured exception (obtained from <code>std::current_exception</code>).</p>\n<p>So:</p>\n<p>If the <em>new</em> exception is an <code>int</code> then you throw an <code>int</code> as other answers have stated.</p>\n<p>If you <em>capture</em> an <code>int</code> then you throw (a type derived from) the new exception with the thrown <code>int</code> in the <code>std::nested_exception</code>.</p>\n", "LastActivityDate": "2014-02-25T20:22:17.157"}, "22002570": {"ParentId": "22002331", "CommentCount": "0", "Body": "<p>The standard says about <code>throw_with_nested(T &amp;&amp; t)</code>, with <code>U = remove_reference&lt;T&gt;::type</code>:</p>\n<blockquote>\n<p id=\"so_22002331_22002570_0\"><em>Throws:</em>  if <code>U</code> is a non-union class type not derived from <code>nested_exception</code>, an exception of unspecified type that is publicly derived from both <code>U</code> and <code>nested_exception</code> and constructed from <code>std::forward&lt;T&gt;(t)</code>, otherwise <code>std::forward&lt;T&gt;(t)</code>.</p>\n</blockquote>\n<p>The \"otherwise\" clause seems to say that if you don't have a class type, you just throw the original argument.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "22002570", "Score": "1", "CreationDate": "2014-02-25T01:05:56.050", "LastActivityDate": "2014-02-25T01:05:56.050"}, "22002567": {"ParentId": "22002331", "CommentCount": "0", "Body": "<p>My copy of the standard says this:</p>\n<blockquote>\n<p id=\"so_22002331_22002567_0\"><strong>18.8.6/7</strong> <em>Throws</em>: if <code>U</code> is a non-union class type not derived from <code>nested_exception</code>, an exception of unspecified type that is publicly derived from both <code>U</code> and <code>nested_exception</code> and constructed from <code>std::forward&lt;T&gt;(t)</code>, otherwise <code>std::forward&lt;T&gt;(t)</code>.</p>\n</blockquote>\n<p>So <code>throw_with_nested(42)</code> should <code>throw 42;</code></p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "22002567", "Score": "1", "CreationDate": "2014-02-25T01:05:42.440", "LastActivityDate": "2014-02-25T01:05:42.440"}, "bq_ids": {"n4140": {"so_22002331_22002570_0": {"section_id": 6952, "quality": 0.9411764705882353, "length": 16}, "so_22002331_22002567_0": {"section_id": 6952, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_22002331_22002570_0": {"section_id": 6699, "quality": 0.9411764705882353, "length": 16}, "so_22002331_22002567_0": {"section_id": 6699, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_22002331_22002570_0": {"section_id": 8449, "quality": 0.6470588235294118, "length": 11}, "so_22002331_22002567_0": {"section_id": 8449, "quality": 0.6111111111111112, "length": 11}}}});