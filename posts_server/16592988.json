post_cb({"16593038": {"ParentId": "16592988", "LastEditDate": "2013-11-11T21:35:03.410", "CommentCount": "0", "CreationDate": "2013-05-16T16:41:39.930", "OwnerUserId": "1520907", "LastEditorUserId": "1520907", "PostTypeId": "2", "Id": "16593038", "Score": "13", "Body": "<p><strong>First Case:</strong> 2 Identifiers</p>\n<pre><code>int x;\nvoid x();\n</code></pre>\n<p><strong>Second Case:</strong> 1 Identifier, 1 Typename</p>\n<pre><code>int x;\nclass x {};\n</code></pre>\n<p>The compiler can't handle the first case because you have 2 identifiers with the same name, so there could be an ambiguity. (Example: Try getting the memory address of one of them. That's one case where an ambiguity could arise)</p>\n<p>The compiler can handle the second case because one is a type and the other is an identifier, and because it knows where to expect a type and where to expect an identifier, there is no ambiguity.</p>\n", "LastActivityDate": "2013-11-11T21:35:03.410"}, "16593453": {"ParentId": "16592988", "CommentCount": "0", "Body": "<p>What's going on here is specific to C++. The use of <code>x</code> as a class name is hidden.</p>\n<p>Section 3.3.7 (Name Hiding) paragraph 2:</p>\n<blockquote>\n<p id=\"so_16592988_16593453_0\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of an object, function, or enumerator declared in the same scope. If a class or enumeration name and an object, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the object, function, or enumerator name is visible.</p>\n</blockquote>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "16593453", "Score": "5", "CreationDate": "2013-05-16T17:08:08.777", "LastActivityDate": "2013-05-16T17:08:08.777"}, "16593281": {"ParentId": "16592988", "CommentCount": "0", "Body": "<p>This is needed for backward-compatibility with C (if I recall, some UNIX headers define both a struct and a variable with the same name).</p>\n<p>You can disambiguate between a class and a variable/function:</p>\n<pre><code>int x;\n\nclass x {};\n\nint main()\n{\n    x = 42; // global int x\n\n    //x obj; // error\n    class x obj; // use class-tag to disambiguate\n}\n</code></pre>\n<p>But you cannot disambiguate between a variable and a function.</p>\n<p>See also the book <em>\"The Design and Evolution of C++\"</em> by Bjarne Stroustrup, \u00a72.8.2.</p>\n", "OwnerUserId": "688659", "PostTypeId": "2", "Id": "16593281", "Score": "4", "CreationDate": "2013-05-16T16:57:12.577", "LastActivityDate": "2013-05-16T16:57:12.577"}, "16593248": {"ParentId": "16592988", "LastEditDate": "2013-05-16T17:35:54.990", "CommentCount": "8", "CreationDate": "2013-05-16T16:55:04.180", "OwnerUserId": "2040925", "LastEditorUserId": "2040925", "PostTypeId": "2", "Id": "16593248", "Score": "2", "Body": "<p><code>union</code>, <code>enum</code> and <code>struct</code> (and I suppose <code>class</code> too) together have seperate \"name buckets\" (has nothing to do with C++ namespaces!) from ordinary identifiers. This becomes clear in C, because you have to prefix the names with <code>struct</code> etc.</p>\n<p>I don't have it for C++, but this is from the C standard:</p>\n<pre><code>6.2.3 Name spaces of identifiers\n\nIf more than one declaration of a particular identifier is visible at\nany point in a translation unit, the syntactic context disambiguates uses\nthat refer to different entities.\n\n Thus, there are separate name spaces for various categories of identifiers,\nas follows:\n\u2014 label names (disambiguated by the syntax of the label declaration and use);\n\n\u2014 the tags of structures, unions, and enumerations (disambiguated by \n following any32) of the keywords struct, union, or enum);\n\n\u2014 the members of structures or unions; each structure or union has a \nseparate name space for its members (disambiguated by the type of the \nexpression used to access themember via the . or -&gt; operator);\n\n\u2014 all other identifiers, called ordinary identifiers (declared in ordinary \n  declarators or as enumeration constants).\n</code></pre>\n", "LastActivityDate": "2013-05-16T17:35:54.990"}, "16592988": {"CommentCount": "1", "ViewCount": "593", "CreationDate": "2013-05-16T16:39:22.567", "LastActivityDate": "2013-11-11T21:35:03.410", "Title": "Definition of class and variable with the same name", "AcceptedAnswerId": "16593453", "PostTypeId": "1", "Id": "16592988", "Score": "7", "Body": "<p>There is this code:</p>\n<pre><code>int x;\n\n//void x(); // error: redefinition of 'x' as different kind of symbol\n\nclass x {}; // works ok\n\nint main() {\n   return 0;\n}\n</code></pre>\n<p>Why is it legal to define variable and class with the same name but it is not legal to define variable and function with the same name?</p>\n", "Tags": "<c++>", "OwnerUserId": "738811", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_16592988_16593453_0": {"section_id": 7079, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_16592988_16593453_0": {"section_id": 6823, "quality": 0.9142857142857143, "length": 32}}, "n4659": {"so_16592988_16593453_0": {"section_id": 8580, "quality": 0.9142857142857143, "length": 32}}}});