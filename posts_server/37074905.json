post_cb({"37074905": {"ViewCount": "1202", "Body": "<p>Considering a code like this:</p>\n<pre><code>std::string str = \"abcdef\";\nconst size_t num = 50;\n\nconst size_t baselen = str.length();\nwhile (str.length() &lt; num)\n    str.append(str, 0, baselen);\n</code></pre>\n<p>Is it safe to call <code>std::basic_string&lt;T&gt;::append()</code> on itself like this? Cannot the source memory get invalidated by enlarging before the copy operation?</p>\n<p>I could not find anything in the standard specific to that method. It says the above is equivalent to <code>str.append(str.data(), baselen)</code>, which I think might not be entirely safe unless there is another detection of such cases inside <code>append(const char*, size_t)</code>.</p>\n<p>I checked a few implementations and they seemed safe one way or another, but my question is if this behavior is guaranteed. E.g. \"<a href=\"https://stackoverflow.com/questions/14791984/appending-stdvector-to-itself-undefined-behavior\">Appending std::vector to itself, undefined behavior?</a>\" says it's not for <code>std::vector</code>.</p>\n", "AcceptedAnswerId": "37075341", "Title": "Is it safe to append std::string to itself?", "CreationDate": "2016-05-06T14:25:36.370", "Id": "37074905", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:30:00.753", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-03T11:03:05.970", "Score": "22", "OwnerUserId": "3543211", "Tags": "<c++><stl>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37074905_37075372_0": {"length": 5, "quality": 1.0, "section_id": 1573}, "so_37074905_37075341_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 1642}}, "n3337": {"so_37074905_37075372_0": {"length": 5, "quality": 1.0, "section_id": 1637}, "so_37074905_37075341_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 1639}}, "n4659": {"so_37074905_37075372_0": {"length": 5, "quality": 1.0, "section_id": 1726}, "so_37074905_37075341_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 1801}}}, "37075372": {"Id": "37075372", "PostTypeId": "2", "Body": "<p>This is complicated.</p>\n<p>One thing that can be said for certain. If you use iterators:</p>\n<pre><code>std::string str = \"abcdef\";\nstr.append(str.begin(), str.end());\n</code></pre>\n<p>then you are <em>guaranteed</em> to be safe. Yes, really. Why? Because the specification states that the behavior of the iterator functions is equivalent to calling <code>append(basic_string(first, last))</code>. That obviously creates a temporary copy of the string. So if you need to insert a string into itself, you're guaranteed to be able to do it with the iterator form.</p>\n<p>Granted, implementations don't have to actually copy it. But they do need to respect the standard specified behavior. An implementation could choose to make a copy only if the iterator range is inside of itself, but the implementation would still have to check.</p>\n<p>All of the other forms of <code>append</code> are defined to be equivalent to calling <code>append(const charT *s, size_t len)</code>. That is, your call to append above is equivalent to you doing <code>append(str.data(), str.size())</code>. So what does the standard say about what happens if <code>s</code> is inside of <code>*this</code>?</p>\n<p>Nothing at all.</p>\n<p>The only requirement of <code>s</code> is:</p>\n<blockquote>\n<p id=\"so_37074905_37075372_0\"><code>s</code> points to an array of at least <code>n</code> elements of <code>charT</code>.</p>\n</blockquote>\n<p>Since it does not <em>expressly</em> forbid <code>s</code> pointing into <code>*this</code>, then it must be allowed. It would also be exceedingly strange if the iterator version allows self-assignment, but the pointer&amp;size version did not.</p>\n", "LastActivityDate": "2016-05-06T14:48:49.590", "Score": "6", "CreationDate": "2016-05-06T14:48:49.590", "ParentId": "37074905", "CommentCount": "0", "OwnerUserId": "734069"}, "37075341": {"Id": "37075341", "PostTypeId": "2", "Body": "<p>According to \u00a721.4.6.2/\u00a721.4.6.3:</p>\n<blockquote>\n<p id=\"so_37074905_37075341_0\">The function  [<i><code>basic_string&amp; append(const charT* s, size_type n);</code></i>] replaces the string controlled by *this with a string of length size() + n whose first size() elements are a copy of the original string controlled by *this and whose remaining elements are a copy of the initial n elements of s.</p>\n</blockquote>\n<p><i>Note: This applies to every <code>append</code> call, as every <code>append</code> can be implemented in terms of <code>append(const charT*, size_type)</code>, as defined by the standard (\u00a721.4.6.2/\u00a721.4.6.3).</i></p>\n<p>So basically, <code>append</code> makes a copy of <code>str</code> (let's call the copy <code>strtemp</code>), appends <code>n</code> characters of <code>str2</code> to <code>strtemp</code>, and then replaces <code>str</code> with <code>strtemp</code>.</p>\n<p>For the case that <code>str2</code> is <code>str</code>, nothing changes, as the string is enlarged when the temporary copy is assigned, not before.</p>\n<p>Even though it is not explicitly stated in the standard, it is guaranteed (if the implementation is exactly as stated in the standard) by the definition of <code>std::basic_string&lt;T&gt;::append</code>.</p>\n<p>Thus, this is not undefined behavior.</p>\n", "LastEditorUserId": "3980929", "LastActivityDate": "2016-10-03T11:03:05.970", "Score": "15", "CreationDate": "2016-05-06T14:47:26.293", "ParentId": "37074905", "CommentCount": "1", "LastEditDate": "2016-10-03T11:03:05.970", "OwnerUserId": "3980929"}});