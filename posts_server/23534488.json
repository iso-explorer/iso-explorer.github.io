post_cb({"23534770": {"ParentId": "23534488", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-05-08T06:52:33.610", "Score": "1", "LastEditorUserId": "1782465", "LastEditDate": "2014-05-08T09:05:17.767", "Id": "23534770", "OwnerUserId": "1782465", "Body": "<p>Yes, it's undefined behaviour, since the references inside the lambdas become dangling as soon as <code>captureFunc()</code> exits (*).</p>\n<p>What's probably happening in your case is that the references (which are just pointers under the hood) still point to the space on the stack where <code>i</code> was on the first invocation of <code>captureFunc()</code>, and it ends up in exactly the same location on the second invocation of <code>captureFunc()</code>; so the net effect is that all of <code>get1</code>, <code>get2</code>, <code>set1</code>, <code>set2</code> have their internal <code>i</code> reference pointed to the same (currently unused) location in memory, so they modify it for each other.</p>\n<p>Of course, the above is just speculation, and could change next time you (or run) the program, since <em>Undefined Behaviour is Undefined.</em></p>\n<p>(*) Quoting C++11, [expr.prim.lambda]\u00a722:</p>\n<blockquote>\n<p id=\"so_23534488_23534770_0\">[ <em>Note:</em> If an entity is implicitly or explicitly captured by reference, invoking the function call operator of\n  the corresponding <em>lambda-expression</em> after the lifetime of the entity has ended is likely to result in undefined\n  behavior. <em>\u2014end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2014-05-08T09:05:17.767"}, "23534488": {"CommentCount": "0", "ViewCount": "236", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-05-08T06:38:33.183", "LastActivityDate": "2014-05-08T09:22:28.820", "Title": "lambda captures; c++ vs elisp", "AcceptedAnswerId": "23534770", "LastEditDate": "2017-05-23T11:50:22.890", "Id": "23534488", "Score": "2", "Body": "<p>Reading the answer from <a href=\"https://stackoverflow.com/questions/21443023/capturing-a-reference-by-reference-in-a-c11-lambda\">Capturing a reference by reference in a C++11 lambda</a> makes me think that the following code generates undefined behavior because of the ended lifetime of <code>i</code> in the lambda-capture. Is that right for C++1y? I am asking because <code>g++ 4.8.2</code> translates the code just fine.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nauto captureFct( ) {\n    int i=0;\n    auto set = [&amp;i](int _i){ i=_i; };\n    auto get = [&amp;i](){ return i; };\n    return std::pair&lt;decltype(set),decltype(get)&gt;(set,get);\n}\n\n\nint main() {\n    auto myPair = captureFct();\n    auto set1 = myPair.first;\n    auto get1 = myPair.second;\n\n    auto myPair1 = captureFct();\n    auto set2 = myPair1.first;\n    auto get2 = myPair1.second;\n\n    std::cout &lt;&lt; \"\\nget1:\" &lt;&lt; get1() &lt;&lt; \" get2:\" &lt;&lt; get2() &lt;&lt; '\\n';\n    set1(1); set2(2);\n    std::cout &lt;&lt; \"\\nget1:\" &lt;&lt; get1() &lt;&lt; \" get2:\" &lt;&lt; get2();\n}\n\n/*\n    Local Variables:\n    compile-command: \"g++ -std=c++1y lambda.cc -o a.exe &amp;&amp; ./a.exe\"\n    End:\n */\n</code></pre>\n<p>The output is interesting:</p>\n<pre><code>get1:0 get2:0\n\nget1:2 get2:2\n</code></pre>\n<p>It seems that the same reference is used for all lambdas.</p>\n<p>This behavior differs from the behavior of the following elisp code (as close to the c++ code as possible):</p>\n<pre class=\"lang-lisp prettyprint-override\"><code>(defun captureFct ()\n  (lexical-let ((i 0))\n    (list :set (lambda (_i) (setq i _i))\n      :get (lambda () i))))\n\n(setq myPair (captureFct))\n(setq myPair1 (captureFct))\n\n(message \"\\nget1: %d get2: %d\"\n     (funcall (plist-get myPair :get))\n     (funcall (plist-get myPair1 :get)))\n\n(funcall (plist-get myPair :set) 1)\n(funcall (plist-get myPair1 :set) 2)\n\n(message \"\\nget1: %d get2: %d\"\n     (funcall (plist-get myPair :get))\n     (funcall (plist-get myPair1 :get)))\n</code></pre>\n<p>The output of the elisp code is:</p>\n<pre><code>get1: 0 get2: 0\n\nget1: 1 get2: 2\n</code></pre>\n<p>I think I know already the answer. But, I post this question anyway since it is interesting for folks that do both elisp and c++.</p>\n<p>Last but not least a C++ version that works like the elisp version:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nauto captureFct( ) {\n    std::shared_ptr&lt;int&gt; pi(new int(0));\n    auto set = [pi](int _i){ *pi=_i; };\n    auto get = [pi](){ return *pi; };\n    return std::pair&lt;decltype(set),decltype(get)&gt;(set,get);\n}\n\n\nint main() {\n\n    auto myPair = captureFct();\n    auto set1 = myPair.first;\n    auto get1 = myPair.second;\n\n    auto myPair1 = captureFct();\n    auto set2 = myPair1.first;\n    auto get2 = myPair1.second;\n\n\n\n    std::cout &lt;&lt; \"\\nget1:\" &lt;&lt; get1() &lt;&lt; \" get2:\" &lt;&lt; get2() &lt;&lt; '\\n';\n    set1(1); set2(2);\n    std::cout &lt;&lt; \"\\nget1:\" &lt;&lt; get1() &lt;&lt; \" get2:\" &lt;&lt; get2();\n}\n\n/*\n    Local Variables:\n    compile-command: \"g++ -std=c++1y lambda.cc -o a.exe &amp;&amp; ./a.exe\"\n    End:\n */\n</code></pre>\n", "Tags": "<c++11><lambda><elisp><c++14>", "OwnerUserId": "2708138", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23534488_23534770_0": {"section_id": 5982, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_23534488_23534770_0": {"section_id": 5750, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_23534488_23534770_0": {"section_id": 7479, "quality": 0.8636363636363636, "length": 19}}}});