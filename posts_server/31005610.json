post_cb({"31005610": {"CommentCount": "7", "ViewCount": "221", "CreationDate": "2015-06-23T14:28:19.873", "LastActivityDate": "2015-06-23T16:45:22.973", "Title": "Friend lookup exception from template-id?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "31005610", "Score": "14", "Body": "<p>Consider the following clause in [namespace.memdef]/3:</p>\n<blockquote>\n<p id=\"so_31005610_31005610_0\">If the name in a <code>friend</code> declaration is neither\n  qualified nor a <em>template-id</em> and the declaration is a function or an <em>elaborated-type-specifier</em>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the innermost\n  enclosing namespace.</p>\n</blockquote>\n<p>Is there a reason for the exception for <em>template-id</em> along with the qualified name? For that matter, is there a reason for the lookup of an unqualified name that isn't a <em>template-id</em> to be restricted to the innermost enclosing namespace? Is there a specific problem or use-case that this clause solves?</p>\n", "Tags": "<c++><c++11><friend>", "OwnerUserId": "2069064", "AnswerCount": "1"}, "31008701": {"ParentId": "31005610", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-06-23T16:45:22.973", "OwnerUserId": "420683", "CommunityOwnedDate": "2015-06-23T16:45:22.973", "Id": "31008701", "Score": "5", "Body": "<h1>Why doesn't the restriction apply to qualified names and template-ids?</h1>\n<p>Qualified names and template-ids cannot introduce new members into the enclosing namespace, this is what the note in [namespace.memdef]p3 tries to say:</p>\n<blockquote>\n<p id=\"so_31005610_31008701_0\">[ <em>Note:</em> The other forms of <code>friend</code> declarations cannot declare a new\n  member of the innermost enclosing namespace and thus follow the usual\n  lookup rules. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Therefore, no such restriction is necessary for qualified names and template-ids.</p>\n<p>Note that template-ids lack the declaration of the template-parameters, and qualified-ids could introduce names into distant, unrelated namespaces.</p>\n<hr>\n<h1>Why is there a restriction at all?</h1>\n<p><strong>This part of the answer is still incomplete, but represents the current state of \"research\". Feel free to contribute.</strong></p>\n<p>The restriction has (probably?) been introduced due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1995/N0783.pdf\" rel=\"noreferrer\">N0783 - Namespace Issues and Proposed Resolutions</a> which \"attempts to clarify a number of namespace issues that are currently either undefined or incompletely specified\".</p>\n<p>This paper from 1995 contains two enlightening discussions of issues related to declarations of entities introduced via friend-declarations. Bear in mind that the name lookup rules back then were different:</p>\n<ul>\n<li>Argument-dependent lookup had not yet been introduced<sup>(*)</sup></li>\n<li>Names introduced via friend-declarations are not found via pure unqualified lookup (no ADL) according to current rules, see [namespace.memdef]p3 and <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1477\" rel=\"noreferrer\">CWG 1477</a>. The examples from N0878 suggest that those names could be found via pure unqualified lookup at that time.</li>\n</ul>\n<p><sup>(*)</sup> The best I could find was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1996/N0878.pdf\" rel=\"noreferrer\">N0878</a> from March 1996, which says <em>\"A change was recently made to the working paper to add the \u201cKoenig lookup rule\u201d\"</em></p>\n<p>First, the example from N0783 for functions:</p>\n<blockquote id=\"so_31005610_31008701_1\">\n<pre><code>void f(char);\n\nnamespace A {\n    class B {\n        friend void f(char);   // ::f(char) is a friend\n        friend void f(int);    // A::f(int) is a friend\n\n        void bf();\n    };\n    void B::bf()\n    {\n        f(1);  // calls A::f(int);\n        f('x');  // also calls A::f(int) because ::f is hidden\n    }\n}\n</code></pre>\n</blockquote>\n<p>The second friend declaration must introduce a new function. N0783 tries to specify in which scope this declaration is introduced. It suggests</p>\n<blockquote>\n<p id=\"so_31005610_31008701_2\">All friend declarations for a given name must declare entities in one\n  particular scope.</p>\n</blockquote>\n<p>as a general rule, to avoid the surprises of situations such as the above.</p>\n<blockquote>\n<p id=\"so_31005610_31008701_3\">So the question is, which scope do they declare entities in? There are\n  two possibilities, either</p>\n<ol>\n<li>When looking for a previous declaration of the function, look until the nearest enclosing namespace is reached, or</li>\n<li>When looking for a previous declaration, look in all enclosing scopes for the <em>name</em> of the function that was declared. If a previous\n  use of the name is found, the declaration is injected into that scope.\n  If no previous use of the name is found the friend is injected into\n  the nearest enclosing namespace scope.</li>\n</ol>\n<p id=\"so_31005610_31008701_4\">Rule #2 would mean that the presence of any function called <code>f</code> in an\n  enclosing scope, whether or not the types match, would be enough to\n  cause a friend declaration to inject into that scope.</p>\n<p id=\"so_31005610_31008701_5\">I believe that rule #2 is clearly unacceptable. A friend declaration\n  in a namespace would be affected by <em>any</em> global declaration of that\n  name. Consider what this would mean for operator functions! The\n  presence of <em>any</em> <code>operator+</code> function in the global scope would force\n  all friend <code>operator+</code> operators to appear in the global scope too!\n  The presence of a template in the global scope would have the same\n  effect.</p>\n</blockquote>\n<p>For class types:</p>\n<blockquote id=\"so_31005610_31008701_6\">\n<pre><code>namespace N {\n    class A { void f(); };\n}\n\nusing namespace N;\n\nnamespace M {\n    class B {\n        friend class A;  // Without this rule\n                         // makes N::A a friend\n        B();\n    };\n    class A { void f(); };\n}\n\nvoid N::A::f() { M::B  b; }  // A friend under current rules\n\nvoid M::A::f() { M::B  b; }  // A friend under proposed rules\n</code></pre>\n</blockquote>\n<p>Both examples are not as interesting under the current rules because names introduced via friend declarations are only found via ADL. It is possible this restriction is a historical artefact. <strong>More \"research\" is required to follow the development of this restriction after the introduction of ADL.</strong></p>\n</hr>", "LastActivityDate": "2015-06-23T16:45:22.973"}, "bq_ids": {"n4140": {"so_31005610_31008701_2": {"section_id": 5522, "quality": 0.5454545454545454, "length": 6}, "so_31005610_31008701_0": {"section_id": 5485, "quality": 0.8, "length": 16}, "so_31005610_31005610_0": {"section_id": 5485, "quality": 1.0, "length": 22}}, "n3337": {"so_31005610_31008701_0": {"section_id": 5271, "quality": 0.8, "length": 16}, "so_31005610_31008701_2": {"section_id": 5308, "quality": 0.5454545454545454, "length": 6}, "so_31005610_31005610_0": {"section_id": 5271, "quality": 1.0, "length": 22}}, "n4659": {"so_31005610_31008701_2": {"section_id": 6957, "quality": 0.5454545454545454, "length": 6}, "so_31005610_31008701_0": {"section_id": 6920, "quality": 0.8, "length": 16}, "so_31005610_31005610_0": {"section_id": 6920, "quality": 1.0, "length": 22}}}});