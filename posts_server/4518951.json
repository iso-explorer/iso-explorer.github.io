post_cb({"4518951": {"CommentCount": "1", "AcceptedAnswerId": "4519138", "PostTypeId": "1", "LastEditorUserId": "50079", "CreationDate": "2010-12-23T12:59:47.393", "LastActivityDate": "2010-12-23T13:43:44.743", "LastEditDate": "2010-12-23T13:08:21.823", "ViewCount": "1111", "FavoriteCount": "2", "Title": "Engineered bool compares equal to both true and false, why?", "Id": "4518951", "Score": "21", "Body": "<p>The example bellows compiles, but the output is rather strange :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstruct A\n{\n    int a;\n    char b;\n    bool c;\n};\n\nint main()\n{\n    A v;\n    std::memset( &amp;v, 0xff, sizeof(v) );\n\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; ( true == v.c ) &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; ( false == v.c ) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>the output is :</p>\n<pre><code>true\ntrue\n</code></pre>\n<p>Can someone explains why?</p>\n<p>If it matters, I am using g++ 4.3.0</p>\n", "Tags": "<c++>", "OwnerUserId": "476681", "AnswerCount": "5"}, "4518989": {"ParentId": "4518951", "CommentCount": "1", "Body": "<p>A boolean value whose memory is set to a value that is not one or zero has undefined behaviour.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "4518989", "Score": "2", "CreationDate": "2010-12-23T13:05:16.227", "LastActivityDate": "2010-12-23T13:05:16.227"}, "4519145": {"ParentId": "4518951", "CommentCount": "1", "Body": "<p>I thing I found the answer. 3.9.1-6 says :</p>\n<blockquote>\n<p id=\"so_4518951_4519145_0\">Values of type bool are either true or\n  false.42) [Note: there are no signed,\n  unsigned, short, or long bool types or\n  values. ] As described below, bool\n  values behave as integral types.\n  Values of type bool participate in\n  integral promotions (4.5).</p>\n</blockquote>\n<p>Where the note 42 says :</p>\n<blockquote>\n<p id=\"so_4518951_4519145_1\">42) Using a bool value in ways\n  described by this International\n  Standard as \u2018\u2018undefined,\u2019\u2019 such as by\n  examining the value of an\n  uninitialized automatic variable,\n  might cause it to behave as if it is\n  neither true nor false.</p>\n</blockquote>\n", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "4519145", "Score": "2", "CreationDate": "2010-12-23T13:28:07.573", "LastActivityDate": "2010-12-23T13:28:07.573"}, "4518969": {"ParentId": "4518951", "CommentCount": "11", "Body": "<p>The result of overwriting memory location used by <code>v</code> is <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behaviour</a>.\nEverything may happen, according to the standard (including your computer flying off and eating your breakfast).</p>\n", "OwnerUserId": "276994", "PostTypeId": "2", "Id": "4518969", "Score": "2", "CreationDate": "2010-12-23T13:01:55.607", "LastActivityDate": "2010-12-23T13:01:55.607"}, "4519177": {"ParentId": "4518951", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>I can't seem to find anything in the standard that indicates why this would happen (most possibly my fault here) -- this does include the reference provided by 7vies, which is not in itself very helpful. It is definitely undefined behavior, but I can't explain <em>the specific behavior that is observed by the OP</em>.</p>\n<p>As a practical matter, I 'm very surprised that the output is</p>\n<pre><code>true\ntrue\n</code></pre>\n<p>Using VS2010, the output is the much more easy to explain:</p>\n<pre><code>false\nfalse\n</code></pre>\n<p>In this latter case, what happens is:</p>\n<ul>\n<li>comparisons to boolean <code>true</code> are implemented by the compiler as tests for equality to <code>0x01</code>, and since <code>0xff != 0x01</code> the result is <code>false</code>.</li>\n<li>same goes for comparisons to boolean <code>false</code>, only the value compared with is now <code>0x00</code>.</li>\n</ul>\n<p>I can't think of any implementation detail that would cause <code>false</code> to compared equal to the value <code>0xff</code> when interpreted as <code>bool</code>. Anyone have any ideas about that?</p>\n", "OwnerUserId": "50079", "LastEditorUserId": "50079", "LastEditDate": "2010-12-23T13:43:44.743", "Id": "4519177", "Score": "0", "CreationDate": "2010-12-23T13:32:38.767", "LastActivityDate": "2010-12-23T13:43:44.743"}, "bq_ids": {"n4140": {"so_4518951_4519138_0": {"section_id": 7215, "quality": 0.8571428571428571, "length": 18}, "so_4518951_4519145_0": {"section_id": 7215, "quality": 0.6428571428571429, "length": 18}, "so_4518951_4519145_1": {"section_id": 7215, "quality": 0.8571428571428571, "length": 18}}, "n3337": {"so_4518951_4519138_0": {"section_id": 6959, "quality": 0.8571428571428571, "length": 18}, "so_4518951_4519145_0": {"section_id": 6959, "quality": 0.6428571428571429, "length": 18}, "so_4518951_4519145_1": {"section_id": 6959, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_4518951_4519138_0": {"section_id": 8724, "quality": 0.8571428571428571, "length": 18}, "so_4518951_4519145_0": {"section_id": 8724, "quality": 0.6428571428571429, "length": 18}, "so_4518951_4519145_1": {"section_id": 8724, "quality": 0.8571428571428571, "length": 18}}}, "4519138": {"ParentId": "4518951", "CommentCount": "8", "Body": "<p>Found this in the C++ standard, section 3.9.1 \"Fundamental types\" (note the magic footnote 42):</p>\n<pre><code>6. Values of type bool are either true or false. 42)\n</code></pre>\n<blockquote>\n<p id=\"so_4518951_4519138_0\">42) Using a bool value in ways described by this International Standard as \u2018\u2018undefined,\u2019\u2019 such as by examining the value of an uninitialized automatic variable, might cause it to behave as if it is neither true nor false.</p>\n</blockquote>\n<p>This is not perfectly clear for me, but seems to answer the question.</p>\n", "OwnerUserId": "347716", "PostTypeId": "2", "Id": "4519138", "Score": "11", "CreationDate": "2010-12-23T13:26:57.553", "LastActivityDate": "2010-12-23T13:26:57.553"}});