post_cb({"26557853": {"ParentId": "26557830", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Yes, that's guaranteed. C++14 [class.dtor]/8:</p>\n<blockquote>\n<p id=\"so_26557830_26557853_0\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class <code>X</code> calls the destructors for <code>X</code>\u2019s direct non-variant non-static data members, the destructors for <code>X</code>\u2019s direct base classes and, if <code>X</code> is the type of the most derived class (12.6.2), its destructor calls the destructors for <code>X</code>\u2019s virtual base classes.</p>\n</blockquote>\n<p>Specifically, for any type <code>T</code> you can always do this:</p>\n<pre><code>void * addr = ::operator new(sizeof T);\nT * p = ::new (addr) T(/* ctor args */);\np-&gt;~T();                                    // !\n::operator delete(addr);\n</code></pre>\n<p>Or, if you didn't want to invoke an allocator:</p>\n<pre><code>{\n    std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; storage;\n    T * p = ::new (static_cast&lt;void *&gt;(std::addressof(storage))) T(/* args */);\n    p-&gt;~T();\n}\n</code></pre>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2014-10-25T10:59:42.030", "Id": "26557853", "Score": "3", "CreationDate": "2014-10-24T23:48:53.343", "LastActivityDate": "2014-10-25T10:59:42.030"}, "bq_ids": {"n4140": {"so_26557830_26557853_0": {"section_id": 404, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_26557830_26557853_0": {"section_id": 395, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_26557830_26557853_0": {"section_id": 422, "quality": 0.9714285714285714, "length": 34}}}, "26557830": {"CommentCount": "3", "ViewCount": "452", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-10-24T23:45:04.200", "LastActivityDate": "2014-10-25T10:59:42.030", "Title": "Does Explicitly Calling Child Destructors also call Parent Destructors", "AcceptedAnswerId": "26557853", "LastEditDate": "2017-05-23T10:33:35.413", "Id": "26557830", "Score": "0", "Body": "<p>For a memory manager that I am writing in C++ as a proof of concept, in order to keep track of allocated objects I am allocating memory with <code>malloc()</code> in a function, then returning the pointer to that memory and using the placement new operator. Then, to track when the object is deleted, I pass the pointer into another function to call <code>free()</code> on the pointer.</p>\n<p>However, since I am using <code>free()</code> instead of <code>delete</code>, the object's constructor is not automatically called like it usually is, so I have to call it myself. Also, since the memory manager is designed to work with any object, it is conceivable (and even likely) that at some point in it's lifetime it will have to free an object that potentially has multiple parent classes or is deep within an inheritance tree.</p>\n<p>My initial solution to this would be to call the base objects destructor, which would call all of the child destructors (if <a href=\"https://stackoverflow.com/questions/1036019/does-calling-a-destructor-explicitly-destroy-an-object-completely\">this question</a> is to be believed), but since the objects could literally be anything and have any set of inheritance, there is no way to know what the true base class for it is. </p>\n<p>So my question is: will explicitly calling the child classes destructor automatically call all of the base destructors as well, like with delete, or is there no way to easily do this?</p>\n", "Tags": "<c++><memory><memory-management>", "OwnerUserId": "2256041", "AnswerCount": "1"}});