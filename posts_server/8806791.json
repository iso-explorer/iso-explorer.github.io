post_cb({"8806931": {"ParentId": "8806791", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2012-01-10T16:40:58.900", "Score": "4", "LastEditorUserId": "560648", "LastEditDate": "2012-01-10T16:54:30.600", "Id": "8806931", "OwnerUserId": "560648", "Body": "<p>A C-style cast tries different C++ cast types in turn:</p>\n<blockquote>\n<p id=\"so_8806791_8806931_0\"><code>[C++11: 5.4/5]:</code> <strong>The conversions performed by</strong></p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11),</li>\n<li>a <code>static_cast</code> (5.2.9),</li>\n<li>a <code>static_cast</code> followed by a <code>const_cast</code>,</li>\n<li><strong>a <code>reinterpret_cast</code> (5.2.10)</strong>, or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>`const_cast</code>,</li>\n</ul>\n<p id=\"so_8806791_8806931_1\"><strong>can be performed using the cast notation of explicit type conversion.</strong> The same semantic restrictions and behaviors apply, with the exception that in performing a static_cast in the following situations the conversion is valid even if the base class is inaccessible:</p>\n<ul>\n<li>[..]</li>\n</ul>\n</blockquote>\n<p>And then follows various complex rules that I can't be bothered to parse in detail.</p>\n<p>You get the requisite warnings that it's a stupid cast, but since it's what you asked for it's what's attempted.</p>\n<p>Compare with:</p>\n<pre><code>class Bar {};\n\nint main() {\n  Bar *b = 0;\n  typedef const Bar&amp; type;\n  const type t = static_cast&lt;type&gt;(b);\n}\n\n// In function 'int main()':\n// Line 6: error: invalid static_cast from type 'Bar*' to type 'const Bar&amp;'\n// compilation terminated due to -Wfatal-errors.\n</code></pre>\n", "LastActivityDate": "2012-01-10T16:54:30.600"}, "8806791": {"CommentCount": "10", "AcceptedAnswerId": "8806931", "PostTypeId": "1", "ClosedDate": "2012-01-10T16:50:59.373", "LastEditorUserId": "-1", "CreationDate": "2012-01-10T16:33:18.657", "LastActivityDate": "2012-01-10T16:54:30.600", "LastEditDate": "2017-05-23T12:03:14.907", "ViewCount": "648", "FavoriteCount": "0", "Title": "Typedef const reference from a pointer", "Id": "8806791", "Score": "4", "Body": "<blockquote>\n<p id=\"so_8806791_8806791_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/5924248/why-is-it-allowed-to-cast-a-pointer-to-a-reference\">Why is it allowed to cast a pointer to a reference?</a> </br></p>\n</blockquote>\n<p>Why does this compile:</p>\n<pre><code>class Bar {};\n\nint main() {\n  Bar i;\n  Bar *b = &amp;i;\n  typedef const Bar&amp; type;\n  type t = type(b);\n}\n</code></pre>\n<p>G++ (<a href=\"http://www.ideone.com/huvDG\" rel=\"nofollow noreferrer\">4.5</a>, 4.7 snapshots), <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow noreferrer\">Comeau</a> and MSVC all are happy but warn about unused variables.</p>\n<p>What does the compiler think it means? Is it UB? Why isn't it an error?</p>\n<p>I think it should be an error because I've accidentally made a <code>Bar*</code> into <code>const Bar&amp;</code> without dereferencing or crazy casts. I thought every part of this was completely safe.</p>\n", "Tags": "<c++>", "OwnerUserId": "168175", "AnswerCount": "3"}, "8806877": {"ParentId": "8806791", "CommentCount": "1", "CreationDate": "2012-01-10T16:38:07.827", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "8806877", "Score": "1", "Body": "<p>Because you are casting to it.</p>\n<pre><code>class Bar {};\n\nint main() {\n  Bar *b = 0;\n  typedef const Bar&amp; type;\n  const type t = b;\n  (void)t;\n}\n</code></pre>\n<p>The example above spits next error:</p>\n<pre><code>error: invalid initialization of reference of type 'type {aka const Bar&amp;}' from expression of type 'Bar*'\n</code></pre>\n", "LastActivityDate": "2012-01-10T16:38:07.827"}, "bq_ids": {"n4140": {"so_8806791_8806931_1": {"section_id": 6126, "quality": 0.96, "length": 24}}, "n3337": {"so_8806791_8806931_1": {"section_id": 5890, "quality": 0.96, "length": 24}}, "n4659": {"so_8806791_8806931_1": {"section_id": 7623, "quality": 0.96, "length": 24}}}, "8806908": {"ParentId": "8806791", "CommentCount": "0", "CreationDate": "2012-01-10T16:39:40.760", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "8806908", "Score": "0", "Body": "<p>It appears that references are castable to pointers. Your expression is essentially,</p>\n<pre><code>Bar &amp; r = reinterpret_cast&lt;Bar&amp;&gt;(b);\n</code></pre>\n<p>But in this explicit form, I get <em>two</em> warnings:</p>\n<pre><code>warning: casting \u2018Bar*\u2019 to \u2018Bar&amp;\u2019 does not dereference pointer [enabled by default]\nwarning: dereferencing type-punned pointer will break strict-aliasing rules [-Wstrict-aliasing]\n</code></pre>\n<p>But this isn't an error, it would seem.</p>\n", "LastActivityDate": "2012-01-10T16:39:40.760"}});