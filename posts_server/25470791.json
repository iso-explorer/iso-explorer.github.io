post_cb({"bq_ids": {"n4140": {"so_25470791_25470791_5": {"length": 18, "quality": 0.9, "section_id": 7151}, "so_25470791_25470791_3": {"length": 13, "quality": 1.0, "section_id": 7151}, "so_25470791_25470791_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}}, "n3337": {"so_25470791_25470791_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}, "so_25470791_25470791_3": {"length": 11, "quality": 0.8461538461538461, "section_id": 6895}, "so_25470791_25470791_5": {"length": 18, "quality": 0.9, "section_id": 6895}}, "n4659": {"so_25470791_25470791_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}, "so_25470791_25470791_3": {"length": 8, "quality": 0.6153846153846154, "section_id": 8652}, "so_25470791_25470791_5": {"length": 14, "quality": 0.7, "section_id": 8652}}}, "25471391": {"Id": "25471391", "PostTypeId": "2", "Body": "<p>\"it may also invoke constexpr constructors\", Y::Y() is not constexpr constructor so B bobj falls to dynamic initialization.</p>\n", "LastActivityDate": "2014-08-24T11:48:54.167", "CommentCount": "6", "CreationDate": "2014-08-24T11:48:54.167", "ParentId": "25470791", "Score": "0", "OwnerUserId": "3945377"}, "25470791": {"ViewCount": "139", "Body": "<p>I'm reading clause 12.7 of N3797. The following example is given:</p>\n<pre><code>struct X { int i; };\nstruct Y : X { Y(); };  // non-trivial\nstruct A { int a; };\nstruct B : public A { int j; Y y; }; // non-trivial\n\nextern B bobj;\nB* pb = &amp;bobj; //1\nint* p1 = &amp;bobj.a; //2 undefined, refers to base class member\nint* p2 = &amp;bobj.y.i; //3 undefined, refers to member\u2019s member\nA* pa = &amp;bobj;\nB bobj;\nextern X xobj;\nint* p3 = &amp;xobj.i;\nX xobj;\n</code></pre>\n<p>This example must reflect the rule:</p>\n<blockquote>\n<p id=\"so_25470791_25470791_0\">For an object with a non-trivial constructor, referring to any\n  non-static member or base class of the object before the constructor\n  begins execution results in undefined behavior.</p>\n</blockquote>\n<p>But I've one doubt. If an implementation doesn't perform dynamic initialization for <code>//1</code>, <code>//2</code>, and <code>//3</code> in a static way, we have no undefined behavior at <code>//2</code> and <code>//3</code>, because (3.6.2/1): </p>\n<blockquote>\n<p id=\"so_25470791_25470791_1\">Constant initialization is performed: </p>\n<p id=\"so_25470791_25470791_2\">[...] </p>\n<p id=\"so_25470791_25470791_3\">\u2014 if an object with static or thread storage duration is initialized by a <strong>constructor</strong>\n<strong>call</strong>, and if the initialization full-expression is a constant initializer for\n  the object; </p>\n<p id=\"so_25470791_25470791_4\">[...]</p>\n<p id=\"so_25470791_25470791_5\">Together, zero-initialization and constant initialization are called\n  static initialization; all other initialization is dynamic\n  initialization. <strong>Static initialization shall be performed before</strong> any\n  dynamic initialization takes place.</p>\n</blockquote>\n<p>That is, we have that constructor has called before a non-static and base. So the result of that example is implementation defined.</p>\n<p>Is my reasoning correct?</p>\n", "AcceptedAnswerId": "25471391", "Title": "Understanding class object construction", "CreationDate": "2014-08-24T10:35:03.500", "Id": "25470791", "CommentCount": "13", "LastEditDate": "2014-08-24T11:28:22.507", "PostTypeId": "1", "LastEditorDisplayName": "user2953119", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-08-24T11:48:54.167", "Score": "5", "Tags": "<c++><constructor>", "AnswerCount": "1"}});