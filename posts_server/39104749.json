post_cb({"39104749": {"CommentCount": "12", "ViewCount": "275", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-08-23T15:05:51.327", "LastActivityDate": "2016-08-23T21:30:58.063", "Title": "Template arguments deduction for parameter type of function pointer involving non-deduced parameter pack", "FavoriteCount": "3", "LastEditDate": "2017-05-23T11:51:46.490", "Id": "39104749", "Score": "13", "Body": "<p>This is similar to the <a href=\"https://stackoverflow.com/q/36640883/2969631\">question</a>, but a more specific case. This time, no compiler work as expected.</p>\n<pre><code>template&lt;class T&gt;\nstruct nondeduced\n{\n    using type = T;\n};\n\ntemplate&lt;class T&gt;\nusing nondeduced_t = typename nondeduced&lt;T&gt;::type;\n\ntemplate&lt;class... T, class U&gt;\nvoid f(void(*)(nondeduced_t&lt;T&gt;..., U)) {}\n\nvoid g(int, char) { }\n\nint main()\n{\n    f&lt;int&gt;(g); // error?\n}\n</code></pre>\n<p>In the above example, the parameter pack <code>T</code> cannot be deduced, but the compiler should be able to deduce <code>U</code> after explicit arguments substitution for pack <code>T</code> (i.e. single <code>int</code> in this case).</p>\n<p>The above is expected to work without the <code>nondeduced_t</code> trick as well:</p>\n<pre><code>template&lt;class... T, class U&gt;\nvoid f(void(*)(T..., U)) {}\n</code></pre>\n<p>Because the parameter pack <code>T</code> is already in non-deduced context according to\n<a href=\"http://eel.is/c++draft/temp.deduct.type#5\" rel=\"nofollow noreferrer\">[temp.deduct.type]p5</a></p>\n<blockquote>\n<p id=\"so_39104749_39104749_0\">The non-deduced contexts are:</p>\n<ul>\n<li>A function parameter pack that does not occur at the end of the parameter-declaration-list.</li>\n</ul>\n</blockquote>\n<p>Unfortunately, no compiler I tested (g++/clang) accept the code.\nNotably something like below works on both g++ &amp; clang.</p>\n<pre><code>template&lt;class... T&gt;\nvoid f(void(*)(nondeduced_t&lt;T&gt;..., char)) {}\n</code></pre>\n<p>And again, this doesn't work on both:</p>\n<pre><code>template&lt;class... T&gt;\nvoid f(void(*)(T..., char)) {}\n</code></pre>\n<p>Is my expectation wrong?</p>\n", "Tags": "<c++><c++11><language-lawyer><variadic-templates><template-deduction>", "OwnerUserId": "2969631", "AnswerCount": "1"}, "39110987": {"ParentId": "39104749", "CommentCount": "1", "CreationDate": "2016-08-23T21:30:58.063", "OwnerUserId": "1316462", "PostTypeId": "2", "Id": "39110987", "Score": "0", "Body": "<p>By <a href=\"http://eel.is/c++draft/temp.deduct.type\" rel=\"nofollow\">[temp.deduct.type]p5</a> one of the <em>non-deduced-context</em> is</p>\n<blockquote>\n<p id=\"so_39104749_39110987_0\">A function parameter pack that does not occur at the end of the parameter-declaration-list.</p>\n</blockquote>\n<p>Parameter packs that doesn't appear as the last argument of a template functions are never deduced, but is completely right to specify the parameter types disabling the deduction. e.g</p>\n<pre><code>template&lt;class T1, class ... Types&gt; void g1(Types ..., T1);\n\ng1&lt;int, int, int&gt;(1,2,3);  // works by non-deduction\ng1(1,2,3)                  // violate the rule above by non-deduced context\n</code></pre>\n<p>But changing the order of function argument even leaving the template parameters as they are, remove the non-deduced context condition and break the infinite expansion of parameter pack. e.g</p>\n<pre><code>template&lt;class T1, class ... Types&gt; void g1(T1, Types ...);\ng1(1,2,3)                 // works because its a deduced context.\n</code></pre>\n<p>There're two reasons your code don't compile:</p>\n<ol>\n<li><p>The order of function argument create a <em>non-deduced-context</em> which cause the type of the parameter pack <strong>T</strong> in the pattern stated in function <strong>f</strong> would never be deduced.</p></li>\n<li><p>The template parameter T appears only as a qualifiers in function arguments(e.g <em>nondeduced_t</em>) and not directly specified as a function argument(which allow argument deduction). </p></li>\n</ol>\n<p>To make the code compile you have either place the expansion of the parameter pack as it is forgetting the <em>nondeduced_t</em> indirect, as</p>\n<pre><code>template&lt;class... T,class U&gt;\nvoid f( void(*)(U,T...) ) { }\n\nf(g);\n</code></pre>\n<p>or changing the order of template parameters and specify the template argument on function call, as</p>\n<pre><code>template&lt;class U,class... T&gt;\nvoid f( void(*)(U,typename nondeduced&lt;T&gt;::type...) ) {}\n\nf&lt;int,char&gt;(g);    \n</code></pre>\n", "LastActivityDate": "2016-08-23T21:30:58.063"}, "bq_ids": {"n4140": {"so_39104749_39110987_0": {"section_id": 336, "quality": 1.0, "length": 7}}, "n3337": {"so_39104749_39110987_0": {"section_id": 293, "quality": 1.0, "length": 7}}, "n4659": {"so_39104749_39110987_0": {"section_id": 345, "quality": 1.0, "length": 7}}}});