post_cb({"36670657": {"ParentId": "36670354", "CommentCount": "0", "CreationDate": "2016-04-16T22:45:41.673", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "36670657", "Score": "0", "Body": "<p>Part of the point of undefined behaviour is that the compiler is allowed to do anything at all.   I'll leave others to quote the standardese, and focus on the philosophy in your question.</p>\n<p>Generally speaking, declaring a variable <code>const</code>, throwing away <code>const</code>ness, and then doing something that modifies the <code>const</code> variable is one area where compilers will not do anything in particular to protect you - after all, if you are doing such things, there are many different things you might intend and a compiler (or the programmers developing it) have no reason to assume any of them.</p>\n<p>In your example the code which defines <code>x</code> (as distinct from just declaring it) may well be in a different compilation unit than the code which uses the <code>const_cast</code> in order to modify it.  (It depends on how declarations, definitions, and code are organised in your source files).</p>\n<p>gcc is a compiler that, mostly, does not peak into compilation units of your projects other than the one it is compiling.   Which means it has no way of detecting such cases in general, and no way of ensuring that what happens in one compilation unit is consistent (i.e. in a manner that protects you) with what happens in another.    For example, it might optimise one function in one compilation unit based on the assumption that <code>x</code> is <code>12</code>, so that function will never change its behaviour after the statement <code>*const_cast&lt;int*&gt;(&amp;x) = 13</code> is executed in another function.</p>\n", "LastActivityDate": "2016-04-16T22:45:41.673"}, "36670545": {"ParentId": "36670354", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-04-16T22:31:59.413", "Score": "1", "LastEditorUserId": "3723423", "LastEditDate": "2016-04-16T22:37:27.757", "Id": "36670545", "OwnerUserId": "3723423", "Body": "<p>Indeed, you can cast away constness of a pointer:  </p>\n<blockquote>\n<p id=\"so_36670354_36670545_0\"><strong>5.2.11/7</strong> Depending on the type of the object, a write operation through the pointer, lvalue or pointer to data member resulting from a\n  const_cast that casts away a const-qualifier  <strong>may</strong> produce undefined\n  behavior</p>\n</blockquote>\n<p>If the object referred to is a const, this is undefined behavior</p>\n<blockquote>\n<p id=\"so_36670354_36670545_1\"><strong>7.1.6.1/4:</strong> Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime\n  (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>And undefined behavior is... undefined:  </p>\n<blockquote>\n<p id=\"so_36670354_36670545_2\"><strong>1.3.24:</strong> behavior for which this International Standard imposes no requirements (...) <strong>Permissible</strong> undefined behavior ranges from ignoring\n  the situation completely with unpredictable results, to behaving\n  during translation or program execution in a documented manner\n  characteristic of the environment (with or without the issuance of a\n  diagnostic message), to terminating a translation or execution (with\n  the issuance of a diagnostic message).</p>\n</blockquote>\n<p>So, let's imagine what could happen:  may be it will work, may be it will segfault (for example, because the const data would be stored in a const memory segment), may be it will not work as expected (for example, the write is ignored), may be you can get a warning or an error at compilation.   So the best is to avoid this !  </p>\n<p><strong>Quote of the day:</strong> \"<em>C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off</em>\" - <a href=\"http://www.stroustrup.com/bs_faq.html#really-say-that\" rel=\"nofollow\">Bjarne Stroustrup</a> </p>\n", "LastActivityDate": "2016-04-16T22:37:27.757"}, "36670563": {"ParentId": "36670354", "CommentCount": "0", "CreationDate": "2016-04-16T22:33:47.703", "OwnerUserId": "2749717", "PostTypeId": "2", "Id": "36670563", "Score": "0", "Body": "<p>gcc is known for regularly changing actual behaviour when encountering UB. Version 1 tried to run nethack and then printed \"99 bottles\". I remember at some moment a critical exploit has appeared in Linux kernel when gcc started optimizing away condition in a code something like</p>\n<pre><code>int x = s-&gt;x;\nif(s != NULL) {\n</code></pre>\n<p>Because it assumed that when you dereference a pointer, you know it is non-NULL (otherwise it was UB by the standard).</p>\n", "LastActivityDate": "2016-04-16T22:33:47.703"}, "36670354": {"CommentCount": "5", "ViewCount": "84", "CreationDate": "2016-04-16T22:09:41.653", "LastActivityDate": "2016-04-16T22:45:41.673", "Title": "const_cast and Shooting your own Foot", "AcceptedAnswerId": "36670545", "PostTypeId": "1", "Id": "36670354", "Score": "3", "Body": "<p>I realize that this results in undefined behavior:</p>\n<pre><code>const int x = 12;\n*const_cast&lt;int*&gt;(&amp;x) = 13;\n</code></pre>\n<p>But does gcc do anything to prevent this from killing you, or does it just let you stand back and say \"Hey you know better\".  </p>\n<p>Maybe it just silently removes the const modifier in the whole program or something (I don't know I am just guessing here).</p>\n<p>Any thoughts?</p>\n", "Tags": "<c++><gcc><const-cast>", "OwnerUserId": "6149078", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36670354_36670545_1": {"section_id": 5433, "quality": 0.8947368421052632, "length": 17}, "so_36670354_36670545_0": {"section_id": 6057, "quality": 0.9523809523809523, "length": 20}, "so_36670354_36670545_2": {"section_id": 5768, "quality": 0.9375, "length": 30}}, "n3337": {"so_36670354_36670545_1": {"section_id": 5228, "quality": 0.8947368421052632, "length": 17}, "so_36670354_36670545_0": {"section_id": 5825, "quality": 0.9523809523809523, "length": 20}, "so_36670354_36670545_2": {"section_id": 5541, "quality": 0.9375, "length": 30}}, "n4659": {"so_36670354_36670545_1": {"section_id": 6861, "quality": 0.8947368421052632, "length": 17}, "so_36670354_36670545_0": {"section_id": 7555, "quality": 0.9523809523809523, "length": 20}, "so_36670354_36670545_2": {"section_id": 7225, "quality": 0.9375, "length": 30}}}});