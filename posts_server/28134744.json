post_cb({"28134744": {"ViewCount": "843", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\nclass T\n{\n    public:\n        using Names = std::tuple&lt;char const*, char const*&gt;;\n        static constexpr Names names {\"First\", \"Second\"};\n};\n\nint main()\n{\n    std::cout &lt;&lt; std::get&lt;0&gt;(T::names);\n}\n</code></pre>\n<p>As <code>names</code> is a <code>constexpr</code> I expected this to work. But I get a linker error:</p>\n<p>The compiler:</p>\n<pre><code>&gt; g++ --version\nConfigured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1\nApple LLVM version 6.0 (clang-600.0.56) (based on LLVM 3.5svn)\nTarget: x86_64-apple-darwin14.0.0\nThread model: posix\n</code></pre>\n<p>The error:</p>\n<pre><code>&gt; g++ -std=c++1y pl.cpp\nUndefined symbols for architecture x86_64:\n  \"T::names\", referenced from:\n      _main in pl-377031.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n<p><a href=\"http://ideone.com/R8F0gW\" rel=\"nofollow\">[live demo]</a></p>\n", "AcceptedAnswerId": "28134991", "Title": "constexpr of static tuple class member has linker error", "CreationDate": "2015-01-25T08:50:25.200", "Id": "28134744", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-01-25T18:10:33.830", "LastEditorUserId": "14065", "LastActivityDate": "2015-01-25T18:21:41.740", "Score": "5", "OwnerUserId": "14065", "Tags": "<c++><c++11><constexpr>", "AnswerCount": "2"}, "28139818": {"Id": "28139818", "PostTypeId": "2", "Body": "<p>@Columbo posted the correct solution.</p>\n<p>Unfortunately I am trying to build a header only library. The solution requires that the static member be compiled into one compilation unit (which is what I was using <code>constexpr</code> in the hopes of avoiding).</p>\n<p>So I needed to stick another twist into the works to make it work. This is just to share my solution:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass T\n{\n    public:\n        using Names = std::tuple&lt;char const*, char const*&gt;;\n        template&lt;std::size_t index&gt;\n        static char const* getName()\n        {\n            static constexpr Names names {\"First\", \"Second\"};\n            return std::get&lt;index&gt;(names);\n        }\n};\n\nint main()\n{\n    std::cout &lt;&lt; T::getName&lt;0&gt;() &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastActivityDate": "2015-01-25T18:21:41.740", "CommentCount": "0", "CreationDate": "2015-01-25T18:21:41.740", "ParentId": "28134744", "Score": "2", "OwnerUserId": "14065"}, "28134991": {"Id": "28134991", "PostTypeId": "2", "Body": "<p>A declaration of a <code>static</code> data member in class is never a definition<sup>1</sup>.<br>\nA definition is necessary whenever a variable is odr-used<sup>2</sup>. \n<code>std::get&lt;&gt;</code> takes arguments <strong>per reference</strong>, and binding a variable to a reference odr-uses it immediately<sup>3</sup>.  </br></p>\n<p>Simply define <code>names</code> outside:</p>\n<pre><code>constexpr T::Names T::names; // Edit: This goes *outside* the class \"as is\"!\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4d5f7e403b342cbc\"><strong>Demo</strong></a>.</p>\n<hr>\n<p><sup>1)</sup> [basic.def]/2:</p>\n<blockquote>\n<p id=\"so_28134744_28134991_0\">A declaration is a definition unless [..] it declares a <code>static</code> data\n  member in a class definition (9.2, 9.4)</p>\n</blockquote>\n<p><sup>2)</sup> [basic.def.odr]/4:</p>\n<blockquote>\n<p id=\"so_28134744_28134991_1\">Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used  in that program; no diagnostic\n  required.</p>\n</blockquote>\n<p><sup>3)</sup> According to [basic.def.odr]/3:</p>\n<blockquote>\n<p id=\"so_28134744_28134991_2\">A variable <code>x</code> whose name appears as a potentially-evaluated expression\n  <code>ex</code> is odr-used by <code>ex</code> unless applying the lvalue-to-rvalue conversion\n  (4.1) to <code>x</code> yields a constant expression (5.19) that does not invoke\n  any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of\n  the set of potential results of an expression <code>e</code>, where either the\n  lvalue-to-rvalue conversion (4.1) is applied to <code>e</code>, or <code>e</code> is a\n  discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>Here the id-expression <code>T::names</code> refers to the variable in question. The only superexpression <code>e</code> that contains all the potential results of <code>T::names</code> is <code>T::names</code> itself, because the set of potential results of a function call, i.e. <code>std::get&lt;0&gt;(T::names)</code>, is empty. However, the lvalue-to-rvalue conversion is clearly not applied, and the value of <code>T::names</code> is also clearly not discarded (as it is passed to a function).<br>\nThus it is odr-used and requires a definition.</br></p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-01-25T18:09:05.023", "Score": "7", "CreationDate": "2015-01-25T09:30:28.620", "ParentId": "28134744", "CommentCount": "4", "OwnerUserId": "3647361", "LastEditDate": "2015-01-25T18:09:05.023"}, "bq_ids": {"n4140": {"so_28134744_28134991_1": {"length": 12, "quality": 1.0, "section_id": 7041}, "so_28134744_28134991_2": {"length": 30, "quality": 0.9375, "section_id": 7040}, "so_28134744_28134991_0": {"length": 7, "quality": 0.875, "section_id": 5907}}, "n3337": {"so_28134744_28134991_1": {"length": 12, "quality": 1.0, "section_id": 6786}, "so_28134744_28134991_0": {"length": 7, "quality": 0.875, "section_id": 5679}}, "n4659": {"so_28134744_28134991_1": {"length": 12, "quality": 1.0, "section_id": 8538}, "so_28134744_28134991_2": {"length": 30, "quality": 0.9375, "section_id": 8537}, "so_28134744_28134991_0": {"length": 7, "quality": 0.875, "section_id": 7389}}}});