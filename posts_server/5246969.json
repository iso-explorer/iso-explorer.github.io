post_cb({"5247007": {"ParentId": "5246969", "CommentCount": "1", "Body": "<p>In the second case, you are declaring two arrays, and each one of them will have a different address. So no, the addresses will not be the same.</p>\n<p>You can easily test it by printing the address of <code>foo</code> and <code>bar</code> (in both cases, <code>&amp;foo != &amp;bar</code>, but that in the first case only means that the pointers are in different locations, while in the second case it means that the arrays are in different locations: <code>(void*)&amp;foo == (void*)&amp;foo[0]</code> for the array case)</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "5247007", "Score": "1", "CreationDate": "2011-03-09T14:13:44.050", "LastActivityDate": "2011-03-09T14:13:44.050"}, "5246969": {"CommentCount": "0", "AcceptedAnswerId": "5247009", "CreationDate": "2011-03-09T14:10:58.067", "LastActivityDate": "2011-03-09T15:13:21.417", "PostTypeId": "1", "ViewCount": "155", "FavoriteCount": "2", "Title": "string literal uniqueness requirements", "Id": "5246969", "Score": "2", "Body": "<p>I've always understood that the storage of string literals is implementation defined, so the compiler is free to roll up multiple literals such that, given</p>\n<pre><code>static const char* foo = \"blah\";\nstatic const char* bar = \"blah\";\n</code></pre>\n<p>foo and bar can point to the same memory. However, I can't figure out if thats also true when:</p>\n<pre><code>static const char foo[] = \"blah\";\nstatic const char bar[] = \"blah\";\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "27491", "AnswerCount": "4"}, "5247799": {"ParentId": "5246969", "CommentCount": "0", "Body": "<p>@Ben Voight cited the Standard:</p>\n<blockquote>\n<p id=\"so_5246969_5247799_0\"><strong>[intro.object]</strong> says:<br>\n  Two distinct objects that are neither bit-\ufb01elds nor base class subobjects of zero size shall have distinct addresses.</br></p>\n</blockquote>\n<p>But there is another rule in the standard that is equally important: the <em>as-if</em> rule.</p>\n<p>That is, the standard guarantees that two distinct objects of which you observe the address shall be distinct.</p>\n<p>But, as far as I understand it, <em>if the compiler can prove</em> that you do not observe the address of one object, it could merge it with an existing one (and since you do not observe its address, you would not realize it!)</p>\n<p>Could it be a typical case of the measure perturbing the experiment :) ?</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "5247799", "Score": "1", "CreationDate": "2011-03-09T15:13:21.417", "LastActivityDate": "2011-03-09T15:13:21.417"}, "5247009": {"ParentId": "5246969", "PostTypeId": "2", "CommentCount": "23", "Body": "<p><strike>A well-formed program cannot tell whether <code>foo</code> and <code>blah</code> are stored at the same address or not, so I believe that yes the optimizer could fold the constants together.</strike></p>\n<p><code>[expr.rel]</code> (draft 3225) says:</p>\n<blockquote>\n<p id=\"so_5246969_5247009_0\">If two pointers <code>p</code> and <code>q</code> of the same type point to di\ufb00erent objects that are not members of the same\n  object or elements of the same array or to di\ufb00erent functions, or if only one of them is <code>null</code>, the results\n  of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspeci\ufb01ed.</p>\n</blockquote>\n<p><code>[expr.eq]</code> says:</p>\n<blockquote>\n<p id=\"so_5246969_5247009_1\">The <code>==</code> (equal to) and the <code>!=</code> (not equal to) operators have the same semantic restrictions, conversions, and\n  result type as the relational operators except for their lower precedence and truth-value result.</p>\n</blockquote>\n<p><code>[expr.add]</code> says:</p>\n<blockquote>\n<p id=\"so_5246969_5247009_2\">When two pointers to elements of the same array object are subtracted</p>\n</blockquote>\n<p>(snip)</p>\n<blockquote>\n<p id=\"so_5246969_5247009_3\">Unless both pointers point to elements of the same array object, or\n  one past the last element of the array object, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p></p>\n<hr>\n<p>FOOTNOTE: <strong>This has to be wrong</strong>, but it's my interpretation of what the standard says.  I'd love to see the section of the <strong>C++ standard</strong> that overrules this language.</p>\n<p>I think it may be this:</p>\n<p><code>[intro.object]</code> says: </p>\n<blockquote>\n<p id=\"so_5246969_5247009_4\">Two distinct objects that are neither bit-\ufb01elds nor base class subobjects of zero\n  size shall have distinct addresses.</p>\n</blockquote>\n<p><code>[expr.eq]</code> says:</p>\n<blockquote>\n<p id=\"so_5246969_5247009_5\">Two pointers of the same type compare equal if\n  and only if they are both null, both point to the same function, or both represent the same address</p>\n</blockquote>\n<p>So in conclusion, yes you could tell if the arrays were folded, so they can't be.  But most ways of telling have unspecified results, you have to use <code>==</code> or <code>!=</code> directly on pointers.  As @aschelper points out, <code>std::less</code> and its relations will also work.</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-03-09T14:45:32.777", "Id": "5247009", "Score": "1", "CreationDate": "2011-03-09T14:14:02.977", "LastActivityDate": "2011-03-09T14:45:32.777"}, "bq_ids": {"n4140": {"so_5246969_5247009_3": {"section_id": 6143, "quality": 0.875, "length": 14}, "so_5246969_5247009_5": {"section_id": 6155, "quality": 0.8235294117647058, "length": 14}, "so_5246969_5247009_4": {"section_id": 5795, "quality": 0.6428571428571429, "length": 9}, "so_5246969_5247799_0": {"section_id": 5795, "quality": 0.5625, "length": 9}, "so_5246969_5247009_2": {"section_id": 6143, "quality": 1.0, "length": 8}}, "n3337": {"so_5246969_5247009_4": {"section_id": 5568, "quality": 0.6428571428571429, "length": 9}, "so_5246969_5247009_1": {"section_id": 5917, "quality": 0.9473684210526315, "length": 18}, "so_5246969_5247009_0": {"section_id": 5913, "quality": 0.85, "length": 17}, "so_5246969_5247009_2": {"section_id": 5907, "quality": 1.0, "length": 8}, "so_5246969_5247009_3": {"section_id": 5907, "quality": 0.875, "length": 14}, "so_5246969_5247009_5": {"section_id": 5917, "quality": 1.0, "length": 17}, "so_5246969_5247799_0": {"section_id": 5568, "quality": 0.5625, "length": 9}}, "n4659": {"so_5246969_5247799_0": {"section_id": 7254, "quality": 0.5625, "length": 9}, "so_5246969_5247009_5": {"section_id": 7652, "quality": 0.6470588235294118, "length": 11}, "so_5246969_5247009_4": {"section_id": 7254, "quality": 0.6428571428571429, "length": 9}, "so_5246969_5247009_2": {"section_id": 7639, "quality": 1.0, "length": 8}}}, "5247131": {"ParentId": "5246969", "CommentCount": "1", "Body": "<p>In the second case, the two variables are actually arrays, and hence they would definitely point to <strong>different</strong> location.</p>\n<pre><code>static const char foo[] = \"blah\";\nstatic const char bar[] = \"blah\";\ncout &lt;&lt; sizeof(foo) &lt;&lt; \" : \" &lt;&lt; (void*)foo &lt;&lt; endl;\ncout &lt;&lt; sizeof(bar) &lt;&lt; \" : \" &lt;&lt; (void*)bar &lt;&lt; endl;\n</code></pre>\n<p>Output: <strong>(5 is the size of array)</strong></p>\n<pre><code>5 : 0x8048a99\n5 : 0x8048a94\n</code></pre>\n<p>See output here : <a href=\"http://www.ideone.com/hoH5v\" rel=\"nofollow\">http://www.ideone.com/hoH5v</a>\n(when you run, the address may be different however than shown above)</p>\n<hr>\n<p>In the first case however, both are pointers and would point to the <strong>same</strong> location (for most compilers)!</p>\n<pre><code>static const char *foo = \"blah\";\nstatic const char *bar = \"blah\";\ncout &lt;&lt; sizeof(foo) &lt;&lt; \" : \" &lt;&lt; (void*)foo &lt;&lt; endl;\ncout &lt;&lt; sizeof(bar) &lt;&lt; \" : \" &lt;&lt; (void*)bar &lt;&lt; endl;\n</code></pre>\n<p>Output: <strong>(now 4 is the size of pointer)</strong></p>\n<pre><code>4 : 0x8048a94\n4 : 0x8048a94\n</code></pre>\n<p>Did you notice the address is same for both pointers?</p>\n<p>See : <a href=\"http://www.ideone.com/keaoC\" rel=\"nofollow\">http://www.ideone.com/keaoC</a></p>\n</hr>", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "5247131", "Score": "0", "CreationDate": "2011-03-09T14:23:20.320", "LastActivityDate": "2011-03-09T14:23:20.320"}});