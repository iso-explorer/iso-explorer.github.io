post_cb({"bq_ids": {"n4140": {"so_34336024_34336157_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 640}, "so_34336024_34336157_0": {"length": 37, "quality": 1.0, "section_id": 24}}, "n3337": {"so_34336024_34336157_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 630}, "so_34336024_34336157_0": {"length": 37, "quality": 1.0, "section_id": 21}}, "n4659": {"so_34336024_34336157_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 668}, "so_34336024_34336157_0": {"length": 37, "quality": 1.0, "section_id": 24}}}, "34336024": {"ViewCount": "367", "Body": "<p>I would like to use operator&lt;&lt; to write an enum with a specified base type. To my surprise, it seems I must write out the operator myself. For example, the code I would like to write is</p>\n<pre><code>#include &lt;iostream&gt;\nenum myenum : uint16_t\n{\n    X = 0,\n};\nint main ()\n{\n    std::cout &lt;&lt; \"Value is\" &lt;&lt; X &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>gcc 4.8 and visual studio 2015 have no problems with this. clang++-3.6 errors with</p>\n<pre><code># clang++-3.6 -std=c++11 -O0 ostream.cpp -o test.exe\nostream.cpp:18:29: error: use of overloaded operator '&lt;&lt;' is ambiguous (with operand types\n      'basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;' and 'myenum')\n    std::cout &lt;&lt; \"Value is\" &lt;&lt; X &lt;&lt; std::endl;\n    ~~~~~~~~~~~~~~~~~~~~~~~ ^  ~\n/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream:181:7: note: \n      candidate function\n      operator&lt;&lt;(unsigned short __n)\n      ^\n/usr/bin/../lib/gcc/x86_64-linux-gnu/4.8/../../../../include/c++/4.8/ostream:189:7: note: \n      candidate function\n      operator&lt;&lt;(int __n);\n      ^\n      ... another 14 candidates along the same lines ...\n</code></pre>\n<p>In general, I'm inclined to believe clang when it comes to strict conformance, so maybe the use really is ambiguous. The enum certainly is convertible to other sorts of integers. I hoped that the compiler would prefer the version corresponding to the base type of the enum.</p>\n<p>I can work around by using some other language feature instead of enum ... : uint16_t or by explicitly typing out the operator in which case clang is also content.</p>\n<pre><code>static inline std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, myenum const &amp; s)\n{\n    out &lt;&lt; static_cast&lt;std::underlying_type&lt;myenum&gt;::type&gt; (s);\n    return out;\n}\n</code></pre>\n<p>This looks absurd though. Is clang's behaviour expected or erroneous?</p>\n", "AcceptedAnswerId": "34336157", "Title": "Ambiguous overload when writing an enum with an enum-base, but only with clang", "CreationDate": "2015-12-17T13:39:36.623", "Id": "34336024", "CommentCount": "0", "LastEditDate": "2015-12-17T13:46:31.480", "PostTypeId": "1", "LastEditorUserId": "2756719", "LastActivityDate": "2015-12-17T13:53:08.150", "Score": "3", "OwnerUserId": "3726169", "Tags": "<c++><c++11><clang++>", "AnswerCount": "1"}, "34336157": {"Id": "34336157", "PostTypeId": "2", "Body": "<p>Clang problem. Minimized repro:</p>\n<pre><code>enum myenum : unsigned short\n{\n    X = 0,\n};\n\nvoid f(unsigned short);\nvoid f(int);\nint main ()\n{\n    f(X);\n    return 0;\n}\n</code></pre>\n<p>[conv.prom]/4:</p>\n<blockquote>\n<p id=\"so_34336024_34336157_0\">A prvalue of an unscoped enumeration type whose underlying type is\n  fixed (7.2) can be converted to a prvalue of its underlying type.\n  Moreover, if integral promotion can be applied to its underlying type,\n  a prvalue of an unscoped enumeration type whose underlying type is\n  fixed can also be converted to a prvalue of the promoted underlying\n  type.</p>\n</blockquote>\n<p>[over.ics.rank]/4.2 - this bullet was added by <a href=\"http://wg21.link/CWG1601\">CWG1601</a> as a DR against C++11:</p>\n<blockquote>\n<p id=\"so_34336024_34336157_1\">Standard conversion sequences are ordered by their ranks: an Exact\n  Match is a better conversion than a Promotion, which is a better\n  conversion than a Conversion. Two conversion sequences with the same\n  rank are indistinguishable unless one of the following rules applies:</p>\n<ul>\n<li>[...]</li>\n<li>A conversion that promotes an enumeration whose underlying type is\n  fixed to its underlying type is better than one that promotes to the\n  promoted underlying type, if the two are different.</li>\n</ul>\n</blockquote>\n<p><code>myenum</code>-&gt;<code>unsigned short</code> and <code>myenum</code>-&gt;<code>int</code> have the same rank (Promotion). Per [over.ics.rank]/4.2, the first is better than the second. There's no ambiguity here.</p>\n<p>OTOH, GCC silently calls the wrong overload (the <code>int</code> one), which isn't that much better.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-12-17T13:53:08.150", "Score": "5", "CreationDate": "2015-12-17T13:46:25.850", "ParentId": "34336024", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2015-12-17T13:53:08.150"}});