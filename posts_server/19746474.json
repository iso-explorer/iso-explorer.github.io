post_cb({"bq_ids": {"n4140": {"so_19746474_19746828_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 466}, "so_19746474_19746828_0": {"length": 24, "quality": 1.0, "section_id": 451}}, "n3337": {"so_19746474_19746828_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 457}, "so_19746474_19746828_0": {"length": 24, "quality": 1.0, "section_id": 442}}, "n4659": {"so_19746474_19746828_1": {"length": 41, "quality": 0.9761904761904762, "section_id": 489}, "so_19746474_19746828_0": {"length": 24, "quality": 1.0, "section_id": 474}}}, "19746828": {"Id": "19746828", "PostTypeId": "2", "Body": "<p>I think there's a simple answer for a possibly unexpected reason:</p>\n<p>A copy-/move constructor or assignment-operator is <em>never</em> a template (specialization). E.g. [class.copy]/2</p>\n<blockquote>\n<p id=\"so_19746474_19746828_0\">A non-template constructor for class <code>X</code> is a copy constructor if its first parameter is of type <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>, and either there are no other parameters or else all other parameters have default arguments.</p>\n</blockquote>\n<p>Also, footnote 122 says:</p>\n<blockquote>\n<p id=\"so_19746474_19746828_1\">Because a template assignment operator or an assignment operator taking an rvalue reference parameter is never a copy assignment operator, the presence of such an assignment operator does not suppress the implicit declaration of a copy assignment operator. Such assignment operators participate in overload resolution with other assignment operators, including copy assignment operators, and, if selected, will be used to assign an object.</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;class T&gt;\nstruct X\n{\n    X() {}\n\n    template&lt;class U&gt;\n    X(X&lt;U&gt;&amp;&amp;)\n    {\n        std::cout &lt;&lt; \"template \\\"move\\\" ctor\\n\";\n    }\n\n    template&lt;class U&gt;\n    X&amp; operator= (X&lt;U&gt;&amp;&amp;)\n    {\n        std::cout &lt;&lt; \"template \\\"move\\\" assignment-op\\n\";\n        return *this;\n    }\n};\n\nint main()\n{\n    X&lt;int&gt; x;                     // no output\n    X&lt;int&gt; y(x);                  // no output\n    y = std::move(x);             // no output\n    X&lt;double&gt; z( std::move(x) );  // output\n    y = std::move(z);             // output\n}\n</code></pre>\n<p>In this example, the implicitly-declared move constructor and move assignment-operator are used.</p>\n<hr>\n<p>Therefore, if you don't declare a non-template move ctor and move assignment-operator, they might be declared implicitly. They're not declared implicitly e.g. for the move assignment-op, if you have a user-declared dtor; for details see [class.copy]/11 and [class.copy]/20.</p>\n<p>Example: Adding a dtor to the example above:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\ntemplate&lt;class T&gt;\nstruct X\n{\n    X() {}\n    ~X() {}\n\n    template&lt;class U&gt;\n    X(X&lt;U&gt;&amp;&amp;)\n    {\n        std::cout &lt;&lt; \"template \\\"move\\\" ctor\\n\";\n    }\n\n    template&lt;class U&gt;\n    X&amp; operator= (X&lt;U&gt;&amp;&amp;)\n    {\n        std::cout &lt;&lt; \"template \\\"move\\\" assignment-op\\n\";\n        return *this;\n    }\n};\n\nint main()\n{\n    X&lt;int&gt; x;                     // no output\n    X&lt;int&gt; y(x);                  // no output\n    y = std::move(x);             // output\n    X&lt;double&gt; z( std::move(x) );  // output\n    y = std::move(z);             // output\n}\n</code></pre>\n<p>Here, the first move-assignment <code>y = std::move(x);</code> calls a specialization of the assignment-operator template, because there's no implicitly declared move assignment-operator.</p>\n</hr>", "LastActivityDate": "2013-11-02T21:01:27.827", "CommentCount": "2", "CreationDate": "2013-11-02T21:01:27.827", "ParentId": "19746474", "Score": "2", "OwnerUserId": "420683"}, "19746474": {"ViewCount": "228", "Body": "<p>Let us say I have a move-only type.  We stop the default-provided constructors from existing, but Rvalue references introduce a new \"flavor\" we can use for the moving-versions of the signatures:</p>\n<pre><code>class CantCopyMe\n{\nprivate:\n    CantCopyMe (CantCopyMe const &amp; other) = delete;\n    CantCopyMe &amp; operator= (CantCopyMe const &amp; other) = delete;\n\npublic:\n    CantCopyMe (CantCopyMe &amp;&amp; other) {\n        /* ... */\n    }\n\n    CantCopyMe &amp; operator= (CantCopyMe &amp;&amp; other) {\n        /* ... */\n    }\n};\n</code></pre>\n<p>I recently thought you were <em>always</em> supposed to pass movable types by Rvalue reference.  Now it's looking like only very special cases need to do that...like these two.  Things had seemed to work most of the time if you put them everywhere, but I just found one case of the compiler not running the part of the code transferring ownership.</p>\n<p>(It was a situation like passing a unique pointer held in a variable with <code>std::move</code> to something taking a <code>unique_ptr&lt;foo&gt; &amp;&amp;</code> parameter...but noticing the variable at the callsite hadn't been nulled.  Changing the parameter to <code>unique_ptr&lt;foo&gt;</code> fixed it and it was properly nulled, thus preventing a double-delete.  :-/  I haven't isolated why <em>this one</em> was bad when it seemed to work elsewhere, but a smoking gun is it worked the first time but not the subsequent calls.)</p>\n<p>I'm sure there's a good reason for that, and many of you can saliently sum it up.  In the meantime I've started going around like a good <a href=\"http://en.wikipedia.org/wiki/Cargo_cult_programming\" rel=\"nofollow\">cargo-cult programmer</a> removing the &amp;&amp;s.</p>\n<p>But what if you're writing a templated class, where it looked like this?</p>\n<pre><code>template &lt;class FooType&gt;\nclass CantCopyMe\n{\nprivate:\n    CantCopyMe (CantCopyMe const &amp; other) = delete;\n    CantCopyMe &amp; operator= (CantCopyMe const &amp; other) = delete;\n\npublic:\n    template&lt;class OtherFooType&gt;\n    CantCopyMe (CantCopyMe&lt;OtherFooType&gt; &amp;&amp; other) {\n        /* ... */\n    }\n\n    template&lt;class OtherFooType&gt;\n    CantCopyMe &amp; operator= (CantCopyMe&lt;OtherFooType&gt; &amp;&amp; other) {\n        /* ... */\n    }\n};\n</code></pre>\n<p>Is that bad practice for some reason, and you should break out separately when OtherFooType and FooType aren't the same... then it just passes by value?</p>\n<pre><code>template &lt;class FooType&gt;\nclass CantCopyMe\n{\nprivate:\n    CantCopyMe (CantCopyMe const &amp; other) = delete;\n    CantCopyMe &amp; operator= (CantCopyMe const &amp; other) = delete;\n\npublic:\n    CantCopyMe (CantCopyMe &amp;&amp; other) {\n        /* ... */\n    }\n\n    CantCopyMe &amp; operator= (CantCopyMe &amp;&amp; other) {\n        /* ... */\n    }\n\n    template&lt;class OtherFooType&gt;\n    CantCopyMe (CantCopyMe&lt;OtherFooType&gt; other) {\n        /* ... */\n    }\n\n    template&lt;class OtherFooType&gt;\n    CantCopyMe &amp; operator= (CantCopyMe&lt;OtherFooType&gt; other) {\n        /* ... */\n    }\n};\n</code></pre>\n", "AcceptedAnswerId": "19746828", "Title": "Should templates make non-Rvalue-reference constructors/assigns for move only parameters of different type?", "CreationDate": "2013-11-02T20:23:05.413", "Id": "19746474", "CommentCount": "6", "LastEditDate": "2013-11-02T20:54:18.327", "PostTypeId": "1", "LastEditorUserId": "211160", "LastActivityDate": "2013-11-02T21:01:27.827", "Score": "1", "OwnerUserId": "211160", "Tags": "<c++><templates><c++11><rvalue-reference>", "AnswerCount": "1"}});