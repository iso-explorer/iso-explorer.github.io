post_cb({"2358680": {"ParentId": "2358516", "CommentCount": "0", "CreationDate": "2010-03-01T20:05:03.250", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "2358680", "Score": "0", "Body": "<p>In the current version of C++ (i.e. no move constructors) then pointers into items embedded in a std::list will be invalidated along with the list iterators.</p>\n<p>If however you used a std::list*&gt;, then the vector* could move around but the vector would not, so your pointer into the vector would remain valid.</p>\n<p>With the addition of move constructors in C++0x the vector content is likely to stay put unless the vector itself is resized, but any such assumption would be inherently non-portable.</p>\n", "LastActivityDate": "2010-03-01T20:05:03.250"}, "2358622": {"ParentId": "2358516", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2010-03-01T19:56:10.377", "Score": "1", "LastEditorUserId": "83839", "LastEditDate": "2010-03-01T20:30:18.403", "Id": "2358622", "OwnerUserId": "83839", "Body": "<p>If the parent's vector's contents is re-allocated after spawning your worker threads, then their pointers, references, iterators, or whatever are <em>almost certainly</em> invalid.  A list MAY be different (given how they're allocated) but I don't know, and may even be platform-dependent.</p>\n<p>Basically, if you have multiple worker threads, it's probably safest to actually have a method on the parent class to dump the results back into as long as the copy isn't that taxing.  Sure it's not as good as allocating directly into the parent, but then you need to ensure the container you're dumping into doesn't get \"lost\" on re-allocation.</p>\n<p>If the list you're using is guaranteed not to re-allocate its \"other\" space when members are added (or deleted), then that would achieve what you're looking for, but the vector is definitely unsafe.  But either way, the way in which you access it (pointer, reference, or iterator) <em>probably</em> doesn't matter that much as long as your \"root container\" isn't going to move around its contents.</p>\n<p>Edit:</p>\n<p>As mentioned in the comments below, here's a block about the list from <a href=\"http://www.sgi.com/tech/stl/List.html\" rel=\"nofollow noreferrer\">SGI's website</a> (emphasis mine) :</p>\n<blockquote>\n<p id=\"so_2358516_2358622_0\"><strong>Lists have the important property that\n  insertion and splicing do not\n  invalidate iterators to list elements,\n  and that even removal invalidates only\n  the iterators that point to the\n  elements that are removed.</strong> The\n  ordering of iterators may be changed\n  (that is, list::iterator might have\n  a different predecessor or successor\n  after a list operation than it did\n  before), but the iterators themselves\n  will not be invalidated or made to\n  point to different elements unless\n  that invalidation or mutation is\n  explicit.</p>\n</blockquote>\n<p>So this basically says \"use a list as your master store\" and then each worker can dump into its own, and knows it won't get invalidated when another worker is completely done and their vector is deleted from the list.</p>\n", "LastActivityDate": "2010-03-01T20:30:18.403"}, "2358540": {"ParentId": "2358516", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-03-01T19:40:56.630", "Score": "6", "LastEditorUserId": "29809", "LastEditDate": "2010-03-01T20:22:55.487", "Id": "2358540", "OwnerUserId": "29809", "Body": "<p>If an iterator is invalidated, it would also invalidate a pointer/reference that the iterator was converted into.  If you have this:</p>\n<pre><code>std::vector&lt;T&gt;::iterator it = ...;\nT *p = &amp;(*it);\nT &amp;r = *p;\n</code></pre>\n<p>if the iterator is invalidated (for example a call to push_back can invalidate all existing vector iterators), the pointer and the reference will also be invalidated.</p>\n<p>From the standard 23.2.4.2/5 (vector capacity):</p>\n<blockquote>\n<p id=\"so_2358516_2358540_0\">Notes: Reallocation invalidates all the references, pointers, and iterators referring to the elements in the sequence.</p>\n</blockquote>\n<p>The same general principal holds for std::list.  If an iterator is invalidated, the pointers and references the iterator is converted into are also invalidated.</p>\n<p>The difference between std::list and std::vector is what causes iterator invalidation.  A std::list iterator is valid as long as you don't remove the element it is referring to.  So where as <code>std::vector&lt;&gt;::push_back</code> can invalidate an iterator, <code>std::list&lt;&gt;::push_back</code> cannot.</p>\n", "LastActivityDate": "2010-03-01T20:22:55.487"}, "2358516": {"CommentCount": "0", "AcceptedAnswerId": "2358540", "CreationDate": "2010-03-01T19:37:17.560", "LastActivityDate": "2010-03-01T20:30:18.403", "PostTypeId": "1", "ViewCount": "6885", "FavoriteCount": "2", "Title": "Iterator vs. Reference vs. Pointer", "Id": "2358516", "Score": "6", "Body": "<p>I have a class that spawns an arbitrary number of worker object that compute their results into a <code>std::vector</code>. I'm going to remove some of the worker objects at certain points but I'd like to keep their results in a certain ordering only known to the class that <code>spawned</code> them. Thus I'm providing the vectors for the output in the class A.</p>\n<p>I have (IMO) three options: I could either have pointers to the vectors, references or iterators as members. While the iterator option has certain draw backs (The iterator could be incremented.) I'm unsure if pointers or references are clearer.\nI feel references are better because they can't be NULL and a cruncher would require the presence of a vector.</p>\n<p>What I'm most unsure about is the validity of the references. Will they be invalidated by some operations on the <code>std::list&lt; std::vector&lt;int&gt; &gt;</code>? Are those operations the same as invalidating the iterators of <code>std::list</code>? Is there another approach I don't see right now? Also the coupling to a container doesn't feel right: I force a specific container to the Cruncher class.</p>\n<p>Code provided for clarity:</p>\n<pre><code>#include &lt;list&gt;\n#include &lt;vector&gt;\n#include &lt;boost/ptr_container/ptr_list.hpp&gt;\n\nclass Cruncher {\n  std::vector&lt;int&gt;* numPointer;\n  std::vector&lt;int&gt;&amp; numRef;\n  std::list&lt; std::vector&lt;int&gt; &gt;::iterator numIterator;\npublic:\n  Cruncher(std::vector&lt;int&gt;*);\n  Cruncher(std::vector&lt;int&gt;&amp;);\n  Cruncher(std::list&lt; std::vector&lt;int&gt; &gt;::iterator);\n};\n\nclass A {\n  std::list&lt; std::vector&lt;int&gt; &gt; container;\n  boost::ptr_list&lt; std::vector&lt;int&gt; &gt; container2;\n  std::vector&lt;Cruncher&gt; cruncherList;\n};\n</code></pre>\n", "Tags": "<c++><design>", "OwnerUserId": "105672", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_2358516_2358540_0": {"section_id": 972, "quality": 0.9, "length": 9}}, "n3337": {"so_2358516_2358540_0": {"section_id": 961, "quality": 0.9, "length": 9}}, "n4659": {"so_2358516_2358540_0": {"section_id": 1034, "quality": 0.9, "length": 9}}}, "2358797": {"ParentId": "2358516", "CommentCount": "5", "CreationDate": "2010-03-01T20:21:24.197", "OwnerUserId": "282334", "PostTypeId": "2", "Id": "2358797", "Score": "0", "Body": "<p>I like the pointer parameter.  It is a matter of style.  I prefer this parameter type style:</p>\n<ul>\n<li>Const reference:  Large object is being passed for reading.  Reference avoids wasteful copying.  Looks just like pass-by-value at the point of call.</li>\n<li>Pointer: Object is being passed for reading <em>and writing</em>.  The call will have an \"&amp;\" to get the pointer, so the writing is made obvious during code review.</li>\n<li>Non-const reference: banned, because code review can't tell which parameters might get changed as a side effect.</li>\n</ul>\n<p>As you say, an iterator creates a pointless dependency on the parent container type.  (std::list is implemented as a double-linked list, so only deleting its entry invalidates a vector. So it would work.)</p>\n", "LastActivityDate": "2010-03-01T20:21:24.197"}});