post_cb({"34008281": {"ParentId": "34007190", "CommentCount": "0", "Body": "<p>It's well defined and safe to throw from a destructor as far as that instance is concerned.  Where you start running into problems is in arrays (because it can't finish deleting the array and you have no way of getting it back) and catch clauses (can end up calling terminate).  It's also difficult (I think it's actually impossible, but not ready to claim that from memory) to write exception safe code if destructors throw.</p>\n<p>I've used throwing destructors to do things though.  For example I was working with an API that might return an error code and allocate an error blob.  I wrote a little scope guard thing that would hand out references to put that data in, and check in the destructor for error conditions.  If it saw one it would convert it into an exception and throw it.</p>\n<p>Constructs like this are technically safe, but you kinda want to avoid it until you know what you're doing.  You have to make it clear that these things cannot be stored in vectors or arrays and might render exception safe code unsafe.  The main issue is that pretty much everyone expects all destructors to be nothrow.</p>\n", "OwnerUserId": "301883", "PostTypeId": "2", "Id": "34008281", "Score": "0", "CreationDate": "2015-11-30T21:25:48.690", "LastActivityDate": "2015-11-30T21:25:48.690"}, "34007190": {"CommentCount": "3", "CreationDate": "2015-11-30T20:15:59.517", "PostTypeId": "1", "AcceptedAnswerId": "34007608", "LastEditorUserId": "2692339", "LastActivityDate": "2015-12-01T13:38:27.263", "LastEditDate": "2015-11-30T20:31:21.893", "ViewCount": "676", "FavoriteCount": "1", "Title": "Is throwing an exception from destructor safe for the vtable?", "Id": "34007190", "Score": "17", "Body": "<p>Please consider the following example:</p>\n<pre><code>#include &lt;csignal&gt;\n\nclass A\n{\npublic:\n    virtual ~A() {}\n    virtual void foo() = 0;\n};\n\nclass B : public A\n{\npublic:\n    virtual ~B() { throw 5; } \n    virtual void foo() {}\n};\n\nint main(int, char * [])\n{\n    A * b = new B();\n\n    try\n    {\n        delete b;\n    }\n    catch ( ... )\n    {\n        raise(SIGTRAP);\n    }\n    return 0;\n}\n</code></pre>\n<p>I've always thought (naive me) that when the program gets in this case, into <code>catch</code> section, then object <code>B</code> at which <code>b</code> points will be intact because it's quite logical that the exception will have \"cancelled\" (if programmed safely) the effect of destructor. But when I tried to run this snippet in gdb and got to the breakpoint in <code>catch</code> section I saw that B object was gone and only A base object left because the vtable looked like this:</p>\n<pre><code>(gdb) i vtbl b\nvtable for 'A' @ 0x400cf0 (subobject @ 0x603010):\n[0]: 0x0\n[1]: 0x0\n[2]: 0x4008e0 &lt;__cxa_pure_virtual@plt&gt;\n</code></pre>\n<p><strong>My question:</strong> is there a way to avoid (half-)destruction of the vtable if I passionately want to throw an exception from a destructor?</p>\n", "Tags": "<c++><exception-handling>", "OwnerUserId": "1649450", "AnswerCount": "3"}, "34007856": {"ParentId": "34007190", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-11-30T20:56:48.643", "Score": "6", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:13.470", "Id": "34007856", "OwnerUserId": "321013", "Body": "<blockquote>\n<p id=\"so_34007190_34007856_0\">when the program gets in this\n  case, into catch section, then object B at which b points will be\n  intact because it's quite logical that the exception will have\n  \"cancelled\" (if programmed safely) the effect of destructor.</p>\n</blockquote>\n<p>No. The <a href=\"https://stackoverflow.com/questions/8611468/lifetime-of-object-is-over-before-destructor-is-called\"><em>lifetime of an object ends</em> when its destructor <strong>starts</strong></a>.</p>\n<p>You cannot cancel a destructor.</p>\n<p>As others said, throwing destructors in C++ are weird and you want to avoid them <a href=\"https://stackoverflow.com/a/4098662/321013\">except for special cases</a>.</p>\n", "LastActivityDate": "2015-11-30T20:56:48.643"}, "bq_ids": {"n4140": {"so_34007190_34007608_2": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_34007190_34007608_3": {"section_id": 7189, "quality": 0.875, "length": 7}, "so_34007190_34007608_1": {"section_id": 3344, "quality": 0.96875, "length": 31}}, "n3337": {"so_34007190_34007608_2": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_34007190_34007608_3": {"section_id": 6933, "quality": 0.875, "length": 7}, "so_34007190_34007608_1": {"section_id": 3214, "quality": 0.96875, "length": 31}}, "n4659": {"so_34007190_34007608_2": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_34007190_34007608_3": {"section_id": 8697, "quality": 0.875, "length": 7}}}, "34007608": {"ParentId": "34007190", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-11-30T20:41:42.540", "Score": "17", "LastEditorUserId": "3002139", "LastEditDate": "2015-12-01T13:38:27.263", "Id": "34007608", "OwnerUserId": "3002139", "Body": "<blockquote>\n<p id=\"so_34007190_34007608_0\">I've always thought (naive me) that when the program gets in this case, into catch section, then object B at which b points will be intact because it's quite logical that the exception will have \"cancelled\" (if programmed safely) the effect of destructor.</p>\n</blockquote>\n<p>This is not true. The standard says:</p>\n<blockquote>\n<p id=\"so_34007190_34007608_1\">An object of any storage duration whose initialization or destruction is terminated by an exception will\n  have destructors executed for all of its fully constructed subobjects (excluding the variant members of a\n  union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution\n  and the destructor has not yet begun execution.</p>\n</blockquote>\n<p>(15.2/2 in N4140)</p>\n<p>and, probably more importantly:</p>\n<blockquote>\n<p id=\"so_34007190_34007608_2\">The lifetime of an object of type T ends when:</p>\n<p id=\"so_34007190_34007608_3\">\u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts</p>\n</blockquote>\n<p>(3.8/1.3 in N4140)</p>\n<p>As every member and base of <code>b</code> is completely constructed and non of their destructors where entered yet they will be considered destroyed. <strong>So in your <code>catch</code> block, the entire object <code>b</code> points to is already dead.</strong></p>\n<p>The rational behind this is probably forbidding \"half destructed\" objects, as it is unclear what the state of an object that cannot be destroyed should be. For instance, what if only some of the members where destroyed already?</p>\n<p>Even the standard itself advises against exceptions leaving destructors. As I wrote in a comment earlier, throwing destructors are weird.</p>\n<p>One good rule we can take from the quote above: <em>An object starts to exist when its constructor is <strong>done</strong> without throwing, and it ceases to exist as soon as its destructor <strong>begins</strong> execution, regardless of how it exits.</em> (This is restated more clearly at other places in the standard. There are exceptions to this, don't care about them.)</p>\n<p>So in conclusion:</p>\n<blockquote>\n<p id=\"so_34007190_34007608_4\">is there a way to avoid (half-)destruction of the vtable if I passionately want to throw an exception from a destructor?</p>\n</blockquote>\n<p>No. As soon as you enter the destructor, your object is done for.</p>\n", "LastActivityDate": "2015-12-01T13:38:27.263"}});