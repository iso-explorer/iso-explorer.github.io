post_cb({"bq_ids": {"n4140": {"so_37446947_37447085_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 3298}}, "n3337": {"so_37446947_37447085_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3168}}, "n4659": {"so_37446947_37447085_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 4063}}}, "37447085": {"Id": "37447085", "PostTypeId": "2", "Body": "<p>In C++11, an aggregate was defined in [dcl.init.aggr] as:</p>\n<blockquote>\n<p id=\"so_37446947_37447085_0\">An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), <strong>no brace-or-equal-initializers for non-static data members (9.2)</strong>, no private or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n<p>That has since been improved, as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3605.html\" rel=\"nofollow\">N3605</a> to remove that condition (and has since then been reformatted to show those conditions as a bulleted list. Yay readability). </p>\n<p>So as a result, in C++11, this:</p>\n<pre><code>struct S { int index = -1; };\n\nint main() {\n    S s{10};\n}\n</code></pre>\n<p>is ill-formed because <code>S</code> doesn't qualify as an aggregate, so we don't attempt to do aggregate initialization, and there's no matching constructor for an <code>int</code>. </p>\n<p>But as of C++14, <code>S</code> is an aggregate, so the code is well-formed. So either you're compiling in C++11 mode or VS2015 doesn't support C++14 aggregate initialization yet. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-05-25T21:31:32.943", "Score": "6", "CreationDate": "2016-05-25T20:32:00.407", "ParentId": "37446947", "CommentCount": "2", "LastEditDate": "2016-05-25T21:31:32.943", "OwnerUserId": "2069064"}, "37446947": {"ViewCount": "93", "Body": "<p>Consider this struct:</p>\n<pre><code>struct S { int index; };\n</code></pre>\n<p>It can be initialized using the braced-list like so:</p>\n<pre><code>S s{10}; //s::index becomes 10\n</code></pre>\n<p>However if I specify a default value for a member:</p>\n<pre><code>struct S { int index = -1; };\n</code></pre>\n<p>The braced-list initialization gives me a compiler error that it cannot convert  <code>initializer list</code> to <code>S</code>. I suspect it might have to do with the default constructors being generated for the struct because I have specified the default value. But why cannot the initializer list override that?</p>\n<p>The reason I want this is that I want to either initialize the struct with values or default it to some \"invalid\" default values. Because of this restriction I have to either specify a constructor myself or initialize the \"invalid\" defaults explicitly every time.</p>\n<p>I am using VS2015 compiler.</p>\n", "AcceptedAnswerId": "37447085", "Title": "Why do default member values prohibit use of braced-list initialization?", "CreationDate": "2016-05-25T20:23:45.327", "LastActivityDate": "2016-05-25T21:31:32.943", "CommentCount": "6", "LastEditDate": "2016-05-25T20:42:50.483", "PostTypeId": "1", "Tags": "<c++><struct><visual-studio-2015>", "Id": "37446947", "AnswerCount": "1", "Score": "1", "OwnerUserId": "2194193", "ClosedDate": "2016-05-25T22:00:47.363", "LastEditorUserId": "2194193"}});