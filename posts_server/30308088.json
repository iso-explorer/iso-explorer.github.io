post_cb({"bq_ids": {"n4140": {"so_30308088_30308215_0": {"length": 24, "quality": 1.0, "section_id": 5322}}, "n3337": {"so_30308088_30308215_0": {"length": 24, "quality": 1.0, "section_id": 5119}}, "n4659": {"so_30308088_30308215_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 6743}}}, "30308184": {"Id": "30308184", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/language/string_literal\" rel=\"nofollow noreferrer\">Raw string literals</a> let you specify an almost arbitrary* delimiter:</p>\n<pre><code>//choose ### as the delimiter so only )###\" ends the string\nR\"###(  \n    Some Text)\"  \n)###\";  \n</code></pre>\n<hr>\n<p><sub>*The exact rules are: \"any member of the basic source character set except:\nspace, the left parenthesis (, the right parenthesis ), the backslash \\,\nand the control characters representing horizontal tab,\nvertical tab, form feed, and newline\" (N3936 \u00a72.14.5 [lex.string] grammar) and \"at most 16 characters\" (\u00a72.14.5/2)</sub></p>\n</hr>", "LastEditorUserId": "8715", "LastActivityDate": "2017-08-02T17:19:02.677", "Score": "55", "CreationDate": "2015-05-18T16:15:42.923", "ParentId": "30308088", "CommentCount": "0", "OwnerUserId": "962089", "LastEditDate": "2017-08-02T17:19:02.677"}, "30308215": {"Id": "30308215", "PostTypeId": "2", "Body": "<p>Escaping won't help you since this is a raw literal, but the syntax is designed to allow clear demarcation of start and end, by introducing a little arbitrary phrase like <code>aha</code>.</p>\n<pre><code>R\"aha(  \n    Some Text)\"  \n)aha\";\n</code></pre>\n<p>By the way note the order of <code>)</code> and <code>\"</code> at the end, opposite of your example.</p>\n<hr>\n<p>Regarding the formal, at first sight (studying the standard) it might seem as if escaping works the same in raw string literals as in ordinary literals. Except one knows that it doesn't, so how is that possible, when no exception is noted in the rules? Well, when raw string literals were introduced in C++11 it was by way of introducing an extra <strong><em>undoing</em></strong> translation phase, undoing the effect of e.g. escaping!, to wit, \u2026</p>\n<b>C++11 \u00a72.5/3</b>\n<blockquote>\n<p id=\"so_30308088_30308215_0\"><strong>\u201d</strong> Between the\n  initial and final double quote characters of the raw string, any transformations performed in phases 1\n  and 2 (trigraphs, universal-character-names, and line splicing) are reverted; this reversion shall apply\n  before any <em>d-char</em>, <em>r-char</em>, or delimiting parenthesis is identified.</p>\n</blockquote>\n<p>This takes care of Unicode character specifications (the <em>universal-character-names</em> like <code>\\u0042</code>), which although they look and act like escapes are formally, in C++, not escape sequences.</p>\n<p>The true formal escapes are handled, or rather, not handled!, by using a custom grammar rule for the content of a raw string literal. Namely that in C++ \u00a72.14.5 the <em>raw-string</em> grammar entity is defined as</p>\n<blockquote>\n<p id=\"so_30308088_30308215_1\"><code>\"</code> <em>d-char-sequence</em><sub>opt</sub> <code>(</code> <em>r-char-sequence</em><sub>opt</sub> <code>)</code> <em>d-char-sequence</em><sub>opt</sub> <code>\"</code></p>\n</blockquote>\n<p>where an <em>r-char-sequence</em> is defined as a sequence of <em>r-char</em>, each of which is</p>\n<blockquote>\n<p id=\"so_30308088_30308215_2\"><strong>\u201d</strong> any member of the source character set, except\n  a right parenthesis <code>)</code> followed by the initial <em>d-char-sequence</em>\n  [like <code>aha</code> above] (which may be empty) followed by a double quote <code>\"</code></p>\n</blockquote>\n<hr>\n<p>Essentially the above means that not only can you not use escapes directly in raw strings (which is much of the point, it's positive, not negative), you can't use Unicode character specifications directly either.</p>\n<p>Here's how to do it indirectly:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nauto main() -&gt; int\n{\n    cout &lt;&lt; \"Ordinary string with a '\\u0042' character.\\n\";\n    cout &lt;&lt; R\"(Raw string without a '\\u0042' character, and no \\n either.)\" \"\\n\";\n    cout &lt;&lt; R\"(Raw string without a '\\u0042' character, i.e. no ')\" \"\\u0042\" R\"(' character.)\" \"\\n\";\n}\n</code></pre>\n<p>Output:</p>\n<pre>\nOrdinary string with a 'B' character.\nRaw string without a '\\u0042' character, and no \\n either.\nRaw string without a '\\u0042' character, i.e. no 'B' character.\n</pre>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2015-05-18T17:02:03.957", "Score": "23", "CreationDate": "2015-05-18T16:17:18.277", "ParentId": "30308088", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2015-05-18T17:02:03.957"}, "30308602": {"Id": "30308602", "PostTypeId": "2", "Body": "<p>You can use, </p>\n<pre><code>R\"aaa(  \n    Some Text)\"  \n)aaa\"; \n</code></pre>\n<p>Here <code>aaa</code> will be your string delimiter. </p>\n", "LastActivityDate": "2015-05-18T16:38:12.863", "CommentCount": "0", "CreationDate": "2015-05-18T16:38:12.863", "ParentId": "30308088", "Score": "2", "OwnerUserId": "744616"}, "30308088": {"ViewCount": "4499", "Body": "<p>The two characters <code>)\"</code> terminate the raw string literal in the example below. <br>\nThe sequence <code>)\"</code> could appear in my text at some point, and I want the string to continue even if this sequence is found within it.</br></p>\n<pre><code>R\"(  \n    Some Text)\"  \n)\";       // ^^\n</code></pre>\n<p>How can I include the sequence <code>)\"</code> within the string literal without terminating it?</p>\n", "AcceptedAnswerId": "30308184", "Title": "Include )\" in raw string literal without terminating said literal", "CreationDate": "2015-05-18T16:10:47.167", "Id": "30308088", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2016-04-16T17:44:03.923", "LastEditorUserId": "3677097", "LastActivityDate": "2017-08-02T17:19:02.677", "Score": "30", "OwnerUserId": "3677097", "Tags": "<c++><c++11><string-literals>", "AnswerCount": "3"}});