post_cb({"bq_ids": {"n4140": {"so_17142130_17147477_0": {"length": 6, "quality": 1.0, "section_id": 7221}, "so_17142130_17147477_9": {"length": 5, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_11": {"length": 7, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_12": {"length": 11, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_5": {"length": 6, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_4": {"length": 21, "quality": 0.5833333333333334, "section_id": 3244}, "so_17142130_17147477_2": {"length": 7, "quality": 0.875, "section_id": 3222}, "so_17142130_17147477_7": {"length": 7, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_3": {"length": 7, "quality": 0.875, "section_id": 3227}, "so_17142130_17147477_6": {"length": 16, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_13": {"length": 7, "quality": 1.0, "section_id": 300}, "so_17142130_17147477_8": {"length": 18, "quality": 0.8571428571428571, "section_id": 300}, "so_17142130_17147477_10": {"length": 6, "quality": 0.8571428571428571, "section_id": 300}}, "n3337": {"so_17142130_17147477_0": {"length": 6, "quality": 1.0, "section_id": 6965}, "so_17142130_17147477_5": {"length": 6, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_11": {"length": 7, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_12": {"length": 11, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_2": {"length": 7, "quality": 0.875, "section_id": 3096}, "so_17142130_17147477_8": {"length": 18, "quality": 0.8571428571428571, "section_id": 291}, "so_17142130_17147477_9": {"length": 5, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_7": {"length": 7, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_3": {"length": 7, "quality": 0.875, "section_id": 3100}, "so_17142130_17147477_6": {"length": 16, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_13": {"length": 7, "quality": 1.0, "section_id": 291}, "so_17142130_17147477_4": {"length": 21, "quality": 0.5833333333333334, "section_id": 3117}, "so_17142130_17147477_10": {"length": 6, "quality": 0.8571428571428571, "section_id": 291}}, "n4659": {"so_17142130_17147477_0": {"length": 6, "quality": 1.0, "section_id": 8730}, "so_17142130_17147477_2": {"length": 7, "quality": 0.875, "section_id": 3979}, "so_17142130_17147477_11": {"length": 7, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_12": {"length": 11, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_5": {"length": 6, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_9": {"length": 5, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_7": {"length": 7, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_3": {"length": 6, "quality": 0.75, "section_id": 3984}, "so_17142130_17147477_6": {"length": 16, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_13": {"length": 7, "quality": 1.0, "section_id": 307}, "so_17142130_17147477_8": {"length": 18, "quality": 0.8571428571428571, "section_id": 307}, "so_17142130_17147477_10": {"length": 6, "quality": 0.8571428571428571, "section_id": 307}}}, "17147477": {"Body": "<p>Compound types can be constructed using the declarator syntax - found in <code>[dcl.decl]</code>.</p>\n<p>Underlying this syntax are six fundamental constructs, within which any <code>T</code> can be substituted by any of the other constructs in the list. [In the following, <code>(T)</code> represents a list of zero or more types (which may end in '...'), and <code>&lt;T&gt;</code> represents a list of one or more types.]</p>\n<pre><code>T // T\nT* // pointer to T\nT&amp; // reference to T\nT[n] // array of size 'n' of T\nT C::* // pointer to C::member of type T\nT (T) // function taking '(T)' and returning T\n</code></pre>\n<p><strong>EDIT</strong>: The type of a class template specialization can be subsituted for any <code>T</code>:</p>\n<pre><code>C&lt;T&gt; // specialization of class template C with arguments '&lt;T&gt;'\n</code></pre>\n<p>There are combinations of the above that produce constructs which have special significance:</p>\n<pre><code>T (*)(T) // pointer to function taking '(T)' and returning T\nT (C::*)(T) // pointer to C::member-function taking '(T)' and returning T\n</code></pre>\n<p>Additionally, some of the constructs may be cv-qualified:</p>\n<pre><code>const T // const T\nT* const // const pointer to T\nT C::* const // const pointer to C::member of type T\n</code></pre>\n<p>Not all of the combinations result in valid types. According to <code>[basic.compound]</code>, only the following combinations can be used:</p>\n<blockquote>\n<p id=\"so_17142130_17147477_0\">Compound types can be constructed in the following ways:</p>\n<ul>\n<li>arrays of objects of a given type</li>\n<li>functions, which have parameters of given types and return void or references or objects of a given type</li>\n<li>pointers to void or objects or functions (including static members of classes) of a given type </li>\n<li>references to objects or functions of a given type</li>\n<li>pointers to non-static class members, which identify members of a given type within objects of a given class</li>\n</ul>\n</blockquote>\n<p>Additional restrictions are mentioned:</p>\n<blockquote>\n<p id=\"so_17142130_17147477_1\"><code>[dcl.ptr]</code> there are no pointers to references</p>\n<p id=\"so_17142130_17147477_2\"><code>[dcl.ref]</code> There shall be no references to references, no arrays of references, and no pointers to references</p>\n<p id=\"so_17142130_17147477_3\"><code>[dcl.mptr]</code> A pointer to member shall not point to ... a member with reference type, or\n  \"cv void.\"</p>\n<p id=\"so_17142130_17147477_4\"><code>[dcl.fct]</code> The parameter list (void) is equivalent to the empty parameter list. Except for this special case, void shall not be a parameter type. ... If the type of a parameter includes a type of the form \u201cpointer to array of unknown bound of T\u201d or \u201creference\n  to array of unknown bound of T,\u201d the program is ill-formed. Functions shall not have a return type of type array or function.</p>\n</blockquote>\n<p>Some of the possible constructs <strong>cannot</strong> be used as template-arguments. When you explicitly specify a set of template-arguments, the compiler must check that the template-arguments can be substituted for the template-parameters without resulting in an 'invalid type'. According to <code>[temp.deduct]\\2</code>, the following constructs constitute invalid types:</p>\n<blockquote>\n<p id=\"so_17142130_17147477_5\">Type deduction may fail for the following reasons:</p>\n<ul>\n<li><p id=\"so_17142130_17147477_6\">Attempting to create an array with an element type that is void, a function type, or a reference type, or attempting to create an array with a size that is zero or negative.</p>\n<pre><code>template &lt;class T&gt; int f(T[5]);\nint I = f&lt;int&gt;(0);\nint j = f&lt;void&gt;(0); // invalid array\n</code></pre></li>\n<li><p id=\"so_17142130_17147477_7\">Attempting to use a type that is not a class type in a qualified name.</p>\n<pre><code>template &lt;class T&gt; int f(typename T::B*);\nint i = f&lt;int&gt;(0);\n</code></pre></li>\n<li><p id=\"so_17142130_17147477_8\">Attempting to use a type in the qualifier portion of a qualified name that names a type  when that type does not contain the specified member, or if the specified member is not a type where a type is required.</p>\n<pre><code>template &lt;class T&gt; int f(typename T::B*);\nstruct A {};\nstruct C { int B; };\nint i = f&lt;A&gt;(0);\nint j = f&lt;C&gt;(0);\n</code></pre></li>\n<li><p id=\"so_17142130_17147477_9\">Attempting to create a pointer to reference type.</p></li>\n<li><p id=\"so_17142130_17147477_10\">Attempting to create a reference to a reference type or a reference to void.</p></li>\n<li><p id=\"so_17142130_17147477_11\">Attempting to create \"pointer to member of T\" when T is not a class type.</p>\n<pre><code>template &lt;class T&gt; int f(int T::*);\nint i = f&lt;int&gt;(0);\n</code></pre></li>\n<li><p id=\"so_17142130_17147477_12\">Attempting to perform an invalid conversion in either a template argument expression, or an expression used in the function declaration.</p>\n<pre><code>template &lt;class T, T*&gt; int f(int);\nint i2 = f&lt;int,1&gt;(0); // can\u2019t conv 1 to int*\n</code></pre></li>\n<li><p id=\"so_17142130_17147477_13\">Attempting to create a function type in which a parameter has a type of void.</p></li>\n<li>Attempting to create a cv-qualified function type.</li>\n</ul>\n</blockquote>\n<p><strong>EDIT:</strong> This is based on C++03, but also applies to C++11 (which adds rvalue reference types)</p>\n", "CreationDate": "2013-06-17T12:26:48.703", "ParentId": "17142130", "CommentCount": "6", "LastEditDate": "2013-06-17T20:00:47.897", "Id": "17147477", "PostTypeId": "2", "LastActivityDate": "2013-06-17T20:00:47.897", "LastEditorUserId": "1690864", "CommunityOwnedDate": "2013-06-17T17:55:26.927", "Score": "12", "OwnerUserId": "1690864"}, "17144134": {"Id": "17144134", "PostTypeId": "2", "Body": "<p>I'm not entirely sure what you are asking about. I thought the sample you gave was interesting and played a little bit with it.</p>\n<p>I came up with an implementation that makes <code>span&lt;a,b&gt;</code> to be a <em>template alias</em> for <code>indexes&lt;a, ..., b&gt;</code>, using the trick of type deduction in <code>constexpr</code> functions:</p>\n<pre><code>template &lt;int a, int b&gt; using span = decltype(expand_span&lt;a,b&gt;());\n</code></pre>\n<p>Now you can have your cake and eat it:</p>\n<pre><code>////////////////////////////////////////////////////////////////\n// using indirect template arguments\ntemplate&lt;typename&gt; struct indirect_work { };\n\nvoid test_indirect()\n{\n    indirect_work&lt;indexes&lt;1,2,3,4&gt;&gt; x;\n    indirect_work&lt;span&lt;1,4&gt;&gt;        y;\n\n    x = y; // x and y are of identical types\n    static_assert(std::is_same&lt;indexes&lt;1,2,3,4&gt;, span&lt;1,4&gt;&gt;::value, \"fact check\");\n}\n</code></pre>\n<p>But, perhaps more interestingly, <strong>you can still have your primary <code>work</code> template take a raw <code>&lt;int...&gt;</code></strong> template argument list:    </p>\n<pre><code>////////////////////////////////////////////////////////////////\n// using direct template arguments\ntemplate&lt;int...&gt; struct direct_work { };\n\n// deduction alias:\ntemplate&lt;int... direct&gt; constexpr direct_work&lt;direct...&gt; deduction_helper(indexes&lt;direct...&gt;);\ntemplate &lt;typename Idx&gt; using deduce = decltype(deduction_helper(Idx{}));\n\nvoid test_direct()\n{\n    direct_work&lt;1,2,3,4&gt; x;\n    deduce&lt;indexes&lt;1,2,3,4&gt;&gt; y;\n    deduce&lt;span&lt;1,4&gt;&gt; z;\n\n    static_assert(std::is_same&lt;decltype(x), decltype(y)&gt;::value, \"fact check\");\n    static_assert(std::is_same&lt;decltype(x), decltype(z)&gt;::value, \"fact check\");\n}\n</code></pre>\n<p>See a complete working demonstration here: <a href=\"http://ideone.com/U2geNF\" rel=\"noreferrer\">gcc on ideone</a>. I compiled it with clang locally.</p>\n<hr>\n<h3>Full code</h3>\n<p>Code for <code>expand_span</code> duplicated here in case link should go dead:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;int...&gt; struct indexes {};\n\nnamespace {\n    template&lt;int a, int... other&gt;\n        constexpr indexes&lt;a, other...&gt; combine(indexes&lt;other...&gt; deduce);\n\n    template&lt;int a, int b, typename Enable = void&gt; struct expand_span_; // primary\n\n    template&lt;int a, int b&gt;\n    struct expand_span_&lt;a, b, typename std::enable_if&lt; (a==b), void &gt;::type&gt; {\n        static constexpr indexes&lt;a&gt; dispatch();\n    };\n\n    template&lt;int a, int b&gt;\n    struct expand_span_&lt;a, b, typename std::enable_if&lt; (a&lt;b), void &gt;::type&gt; {\n        static constexpr decltype(combine&lt;a&gt;(expand_span_&lt;a+1, b&gt;::dispatch())) \n            dispatch();\n    };\n\n    template&lt;int a, int b&gt;\n    constexpr auto expand_span() -&gt; decltype(expand_span_&lt;a,b&gt;::dispatch());\n}\n\ntemplate &lt;int a, int b&gt; using span = decltype(expand_span&lt;a,b&gt;());\n\n////////////////////////////////////////////////////////////////\n// using indirect template arguments\ntemplate&lt;typename&gt; struct indirect_work { };\n\nvoid test_indirect()\n{\n    indirect_work&lt;indexes&lt;1,2,3,4&gt;&gt; x;\n    indirect_work&lt;span&lt;1,4&gt;&gt;        y;\n\n    x = y; // x and y are of identical types\n    static_assert(std::is_same&lt;indexes&lt;1,2,3,4&gt;, span&lt;1,4&gt;&gt;::value, \"fact check\");\n}\n\n////////////////////////////////////////////////////////////////\n// using direct template arguments\ntemplate&lt;int...&gt; struct direct_work { };\n\n// deduction alias:\ntemplate&lt;int... direct&gt; constexpr direct_work&lt;direct...&gt; deduction_helper(indexes&lt;direct...&gt;);\ntemplate &lt;typename Idx&gt; using deduce = decltype(deduction_helper(Idx{}));\n\nvoid test_direct()\n{\n    direct_work&lt;1,2,3,4&gt; x;\n    deduce&lt;indexes&lt;1,2,3,4&gt;&gt; y;\n    deduce&lt;span&lt;1,4&gt;&gt; z;\n\n    static_assert(std::is_same&lt;decltype(x), decltype(y)&gt;::value, \"fact check\");\n    static_assert(std::is_same&lt;decltype(x), decltype(z)&gt;::value, \"fact check\");\n}\n\nint main()\n{\n    test_indirect();\n    test_direct();\n}\n</code></pre>\n</hr>", "LastEditorUserId": "85371", "LastActivityDate": "2013-06-17T10:11:49.700", "Score": "6", "CreationDate": "2013-06-17T09:17:56.643", "ParentId": "17142130", "CommentCount": "10", "OwnerUserId": "85371", "LastEditDate": "2013-06-17T10:11:49.700"}, "17142130": {"ViewCount": "566", "Body": "<p>I was working with a templated class which takes a set of integers. The code was like,</p>\n<pre><code>template&lt;unsigned... Idx&gt;\nstruct work{ ... };\n</code></pre>\n<p>Then I realized, user may need to provide either a set of integers, or a range of integers. So, I changed the syntax little to support instantiation like,</p>\n<pre><code>work&lt;indexes&lt;1,3,2,4&gt; &gt; //instead of work&lt;1,3,2,4&gt;\nwork&lt;span&lt;1,4&gt; &gt; //same as work&lt;1,2,3,4&gt; \n</code></pre>\n<p>While, in C++ we have large number of operators, and can be used to formulate exotic expression templates (say <code>boost::xpressive</code>, <code>boost::lambda</code>, <code>boost::spirit</code> etc) , possibilities for type manipulation is much less.</p>\n<p>In a boostcon keynote by Sean Parent, he noted one still can not write <code>pair&lt;int&gt;</code> to denote <code>a pair of integers</code>. In my persinal library, I made a syntax like <code>tuple&lt;int[3]&gt;</code> to denote a tuple of 3 integers, instead of writing a tuple with 3 int in the type arguments, noting that I do not write a raw array as tuple argument anywhere! (note: <code>std::array&lt;int,3&gt;</code> is not same as the above, as std::array can not store references while <code>tuple</code> can, say <code>std::tuple&lt;int&amp;,int&amp;,int&amp;&gt;</code> is possible)</p>\n<p>So, I want to know what are the different kind of \"type expressions\" I can write? </p>\n<p>So far I can think of object type, function type, reference type, with/without cv modifiers, pointers etc. e.g</p>\n<pre><code>    template&lt;class T&gt;\n    struct tpl;\n\n    using t1 = tpl&lt;int&gt;;//simple type\n    //function (can have function pointer/reference also) \n    // e.g. void(*)(int,float) or void(&amp;)(int,float)\n    using t2 = tpl&lt;void(int,float)&gt;;\n    //array can have pointer / reference also\n    //e.g. int(&amp;)[4] or int (*)[4]\n    using t3 = tpl&lt;int[4]&gt;;\n    using t4 = tpl&lt;int[]&gt;;\n    using t5 = tpl&lt;int const&gt;;//with cv modifiers\n    using t6 = tpl&lt;int*&gt;;//with pointer\n    using t7 = tpl&lt;int&amp;&gt;;//with reference (&amp; or &amp;&amp;)\n    using t8 = tpl&lt;tpl&lt;int&gt; &gt;; //template itself\n    using t9 = tpl&lt;void(...)&gt;; //variadic functions\n    using t10 = tpl&lt;R C::*&gt;; //pointer to member\n</code></pre>\n<p>But I believe, many more are possible.</p>\n<p>NOTE: This question is purely theoretical, <strong>I just want to know all kinds of syntax I can write inside &lt;&gt; as type argument</strong>, and not about the readability/morality aspect of it, or even how can I implement some of the examples I had given, like the work class.   </p>\n", "AcceptedAnswerId": "17147477", "Title": "What are the expression syntax over types C++ support?", "CreationDate": "2013-06-17T07:12:16.833", "Id": "17142130", "CommentCount": "7", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2013-06-18T05:46:58.677", "LastEditorUserId": "60515", "LastActivityDate": "2013-06-18T05:46:58.677", "Score": "16", "OwnerUserId": "60515", "Tags": "<c++><templates><c++11>", "AnswerCount": "2"}});