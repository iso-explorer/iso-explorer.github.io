post_cb({"10783921": {"ParentId": "10782863", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2012-05-28T11:27:27.860", "Score": "19", "LastEditorUserId": "434551", "LastEditDate": "2017-10-24T15:30:48.247", "Id": "10783921", "OwnerUserId": "649665", "Body": "<p>Sequence points only define a <em>partial</em> ordering.  In your case, you have\n(once overload resolution is done):</p>\n<pre><code>std::cout.operator&lt;&lt;( a++ ).operator&lt;&lt;( a );\n</code></pre>\n<p>There is a sequence point between the <code>a++</code> and the first call to\n<code>std::ostream::operator&lt;&lt;</code>, and there is a sequence point between the\nsecond <code>a</code> and the second call to <code>std::ostream::operator&lt;&lt;</code>, but there\nis no sequence point between <code>a++</code> and <code>a</code>; the only ordering\nconstraints are that <code>a++</code> be fully evaluated (including side effects)\nbefore the first call to <code>operator&lt;&lt;</code>, and that the second <code>a</code> be fully\nevaluated before the second call to <code>operator&lt;&lt;</code>.  (There are also \ncausual ordering constraints: the second call to <code>operator&lt;&lt;</code> cannot\npreced the first, since it requires the results of the first as an\nargument.)  \u00a75/4 (C++03) states:</p>\n<blockquote id=\"so_10782863_10783921_0\">\nExcept where noted, the order of\nevaluation of operands of individual operators and subexpressions of\nindividual expressions, and the order in which side effects take place,\nis unspecified.  Between the previous and next sequence point a scalar\nobject shall have its stored value modified at most once by the\nevaluation of an expression. Furthermore, the prior value shall be\naccessed only to determine the value to be stored.  The requirements of\nthis paragraph shall be met for each allowable ordering of the\nsubexpressions of a full expression; otherwise the behavior is\nundefined.\n</blockquote>\n<p>One of the allowable orderings of your expression is <code>a++</code>, <code>a</code>, first\ncall to <code>operator&lt;&lt;</code>, second call to <code>operator&lt;&lt;</code>; this modifies the\nstored value of <code>a</code> (<code>a++</code>), and accesses it other than to determine\nthe new value (the second <code>a</code>), the behavior is undefined.</p>\n", "LastActivityDate": "2017-10-24T15:30:48.247"}, "10782963": {"ParentId": "10782863", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2012-05-28T10:16:27.537", "Score": "67", "LastEditorUserId": "434551", "LastEditDate": "2017-10-24T15:28:48.237", "Id": "10782963", "OwnerUserId": "452307", "Body": "<p>Technically, overall this is <strong>Undefined Behavior</strong>.     </p>\n<p>But, there are two important aspects to the answer.    </p>\n<p>The code statement: </p>\n<pre><code>std::cout &lt;&lt; a++ &lt;&lt; a;\n</code></pre>\n<p>is evaluated as:</p>\n<pre><code>std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, a++), a);\n</code></pre>\n<p>The standard does not define the order of evaluation of arguments to an function.<br>\nSo Either:      </br></p>\n<ul>\n<li><code>std::operator&lt;&lt;(std::cout, a++)</code> is evaluated first or      </li>\n<li><code>a</code>is evaluated first or    </li>\n<li>it might be any implementation defined order.           </li>\n</ul>\n<p>This order is <strong>Unspecified</strong><sup>[Ref 1]</sup> as per the standard.</p>\n<p><sup>[Ref 1]</sup><strong>C++03 5.2.2 Function call</strong><br>\n<strong>Para 8</strong> </br></p>\n<blockquote>\n<p id=\"so_10782863_10782963_0\"><strong>The order of evaluation of arguments is unspecified</strong>. All side effects of argument expression evaluations take effect before the function is entered. The order of evaluation of the postfix expression and the argument expression list is unspecified.</p>\n</blockquote>\n<p>Further, there is no sequence point between evaluation of arguments to a function but a sequence point exists only after evaluation of all arguments<sup>[Ref 2]</sup>.</p>\n<p><sup>[Ref 2]</sup><strong>C++03 1.9 Program execution [intro.execution]:</strong><br>\n<strong>Para 17:</strong> </br></p>\n<blockquote>\n<p id=\"so_10782863_10782963_1\">When calling a function (whether or not the function is inline), there is a sequence point after the evaluation of all function arguments (if any) which takes place before execution of any expressions or statements in the function body.</p>\n</blockquote>\n<p>Note that, here the value of <code>c</code> is being accessed more than once without an intervening sequence point, regarding this the standard says:</p>\n<p><sup>[Ref 3]</sup><strong>C++03 5 Expressions [expr]:</strong><br>\n<strong>Para 4:</strong> </br></p>\n<blockquote>\n<p id=\"so_10782863_10782963_2\">....<br>\n<strong>Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored</strong>. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full\n  expression; <strong>otherwise the behavior is undefined</strong>. </br></p>\n</blockquote>\n<p>The code modifies <code>c</code> more than once without intervening sequence point and it is not being accessed to determine the value of the stored object. This is clear violation of the above clause and hence the result as mandated by the standard is <strong>Undefined Behavior</strong><sup>[Ref 3]</sup>.</p>\n", "LastActivityDate": "2017-10-24T15:28:48.237"}, "10782972": {"ParentId": "10782863", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2012-05-28T10:17:17.497", "Score": "139", "LastEditorUserId": "434551", "LastEditDate": "2017-10-24T15:25:43.373", "Id": "10782972", "OwnerUserId": "412080", "Body": "<p>You can think of:</p>\n<pre><code>cout &lt;&lt; a++ &lt;&lt; a;\n</code></pre>\n<p>As:</p>\n<pre><code>std::operator&lt;&lt;(std::operator&lt;&lt;(std::cout, a++), a);\n</code></pre>\n<p>C++ guarantees that all side effects of previous evaluations will have been performed at <a href=\"http://en.wikipedia.org/wiki/Sequence_point\" rel=\"nofollow noreferrer\">sequence points</a>. There are no sequence points in between function arguments evaluation which means that argument <code>a</code> can be evaluated before argument <code>std::operator&lt;&lt;(std::cout, a++)</code> or after. So the result of the above is undefined.</p>\n<hr>\n<p><strong>C++17 update</strong></p>\n<p>In C++17 the rules have been updated. In particular:</p>\n<blockquote>\n<p id=\"so_10782863_10782972_0\">In a shift operator expression <code>E1&lt;&lt;E2</code> and <code>E1&gt;&gt;E2</code>, every value computation and side-effect of <code>E1</code> is sequenced before every value computation and side effect of <code>E2</code>.</p>\n</blockquote>\n<p>Which means that it requires the code to produce result <code>b</code>, which outputs <code>01</code>.</p>\n<p>See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf\" rel=\"nofollow noreferrer\">P0145R3 Refining Expression Evaluation Order for Idiomatic C++</a> for more details.</p>\n</hr>", "LastActivityDate": "2017-10-24T15:25:43.373"}, "10782863": {"CommentCount": "13", "AcceptedAnswerId": "10782972", "PostTypeId": "1", "LastEditorUserId": "434551", "CreationDate": "2012-05-28T10:09:54.620", "LastActivityDate": "2017-10-24T15:30:48.247", "LastEditDate": "2017-10-24T15:24:20.907", "ViewCount": "6620", "FavoriteCount": "33", "Title": "What is the correct answer for cout << a++ << a;?", "Id": "10782863", "Score": "96", "Body": "<p>Recently in an interview there was a following objective type question.</p>\n<pre><code>int a = 0;\ncout &lt;&lt; a++ &lt;&lt; a;\n</code></pre>\n<p>Answers:</p>\n<p>a. 10<br>\nb. 01<br>\nc. undefined behavior</br></br></p>\n<p>I answered choice b, i.e. output would be \"01\".</p>\n<p>But to my surprise later I was told by an interviewer that the correct answer is option c: undefined.</p>\n<p>Now, I do know the concept of sequence points in C++. The behavior is undefined for the following statement:</p>\n<pre><code>int i = 0;\ni += i++ + i++;\n</code></pre>\n<p>but as per my understanding for the statement <code>cout &lt;&lt; a++ &lt;&lt; a</code> , the <code>ostream.operator&lt;&lt;()</code> would be called twice, first with <code>ostream.operator&lt;&lt;(a++)</code> and later <code>ostream.operator&lt;&lt;(a)</code>.</p>\n<p>I also checked the result on VS2010 compiler and its output is also '01'.</p>\n", "Tags": "<c++><c++-faq>", "OwnerUserId": "1381823", "AnswerCount": "4"}, "10806714": {"ParentId": "10782863", "CommentCount": "1", "CreationDate": "2012-05-29T21:06:08.217", "OwnerUserId": "1392922", "PostTypeId": "2", "Id": "10806714", "Score": "4", "Body": "<p>The correct answer is to question the question. The statement is unacceptable because a reader  cannot see a clear answer. Another way to look at it is that we have introduced side-effects (c++) that make the statement much harder to interpret. Concise code is great, providing it's meaning is clear.</p>\n", "LastActivityDate": "2012-05-29T21:06:08.217"}, "bq_ids": {"n4140": {"so_10782863_10782972_0": {"section_id": 6164, "quality": 0.6875, "length": 11}}, "n3337": {"so_10782863_10782972_0": {"section_id": 5925, "quality": 0.6875, "length": 11}}, "n4659": {"so_10782863_10782972_0": {"section_id": 7684, "quality": 0.6875, "length": 11}}}});