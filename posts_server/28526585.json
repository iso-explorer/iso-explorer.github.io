post_cb({"28527093": {"Id": "28527093", "PostTypeId": "2", "Body": "<p>A given type of <code>struct</code> always has the same size.  This is a guarantee from the Standard.  When you define a <code>struct</code>, you are saying \"I have an object of <i>this size</i> (sum of sizes of members + possible padding for alignment for each member), and they are to be in <i>this order</i> in memory (same order of member definitions in containing <code>struct</code> definition)\":</p>\n<blockquote>\n<p id=\"so_28526585_28527093_0\">(N4296)\n  9.2<br/>\n  /12 [ <i>Example:</i> A simple example of a class definition is</p>\n</blockquote>\n<pre><code>struct tnode {\n  char tword[20];\n  int count;\n  tnode* left;\n  tnode* right;\n};\n</code></pre>\n<p>which contains an array of twenty characters, an integer, and two pointers to objects of the same type. [...] <i> -end example</i></p>\n<blockquote>\n<p id=\"so_28526585_28527093_1\">/13 Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with different access control is unspecified (Clause 11). Implementation alignment requirements\n  might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>Note the \"<i>with the same access control</i>\" qualifier.  If your structure has a mix of data members with different access specifiers, the layout may not be what you might expect, other than the guarantee that given something like:</p>\n<pre><code>public:\n   some_type public_1;\nprivate:\n   some_type private_1;\npublic:\n   some_type public_2;\n</code></pre>\n<p><code>public_2</code> will be at a higher address than <code>public_1</code>.  Beyond that - unspecified.  <code>private_1</code> could be at a lower or higher address.</p>\n<p>Regarding your other question (asked in comments):</p>\n<blockquote>\n<p id=\"so_28526585_28527093_2\">Would it be better to use a class instead of a struct then?</p>\n</blockquote>\n<p>In C++, a <code>struct</code> and <code>class</code> are essentially the same, the only difference being that members (and inheritance) of a <code>struct</code> are <code>public</code> by default, whereas with a <code>class</code> they are <code>private</code> by default.  This is made even clearer in a note and example from the Standard: </p>\n<blockquote>\n<p id=\"so_28526585_28527093_3\">\u00a73.1 Declarations and definitions  [basic.def] <br/>\n  /3 [ <i>Note:</i> In some circumstances, C ++\n  implementations implicitly define the default constructor (12.1), copy\n  constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4) member functions. <i>\u2014end note</i> ] [ <i>Example:</i> given</p>\n</blockquote>\n<pre><code>#include &lt;string&gt;\nstruct C {\n    std::string s; // std::string is the standard library class (Clause 21)\n};\nint main() {\n    C a;\n    C b = a;\n    b = a;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_28526585_28527093_4\">the implementation will implicitly define functions to make the definition of C equivalent to</p>\n</blockquote>\n<pre><code>struct C {\n    std::string s;\n    C() : s() { }\n    C(const C&amp; x): s(x.s) { }\n    C(C&amp;&amp; x): s(static_cast&lt;std::string&amp;&amp;&gt;(x.s)) { }\n    // : s(std::move(x.s)) { }\n    C&amp; operator=(const C&amp; x) { s = x.s; return *this; }\n    C&amp; operator=(C&amp;&amp; x) { s = static_cast&lt;std::string&amp;&amp;&gt;(x.s); return *this; }\n    // { s = std::move(x.s); return *this; }\n    ~C() { }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_28526585_28527093_5\"><i>\u2014end example</i> ]</p>\n</blockquote>\n<p>Note that the example from the Standard uses a <code>struct</code> rather than a <code>class</code> to illustrate this point for non-POD <code>structs</code>.  This is even more clear when you consider that the definition of a <code>struct</code> in the Standard is in Section 9 - \"Classes.\"</p>\n", "LastEditorUserId": "4257674", "LastActivityDate": "2015-02-15T14:35:12.373", "Score": "1", "CreationDate": "2015-02-15T14:29:25.467", "ParentId": "28526585", "CommentCount": "0", "OwnerUserId": "4257674", "LastEditDate": "2015-02-15T14:35:12.373"}, "28526748": {"Id": "28526748", "PostTypeId": "2", "Body": "<p>As it is said earlier, <code>struct</code> is always fixed-size.\nThere are several ways to overcome this limitation:</p>\n<ol>\n<li>Store the pointer and allocate heap memory for it.</li>\n<li>Use \"unbound\" array of <code>char[1]</code> as the last member, and allocate memory for the <code>struct</code> itself on the heap.</li>\n<li>Use <code>union</code> to save some space for overlapping members.</li>\n</ol>\n", "LastActivityDate": "2015-02-15T13:49:36.367", "CommentCount": "0", "CreationDate": "2015-02-15T13:49:36.367", "ParentId": "28526585", "Score": "-1", "OwnerUserId": "4419802"}, "28526736": {"Id": "28526736", "PostTypeId": "2", "Body": "<p>Do not worry, it would take considerably more than you think.</p>\n<p>There are two factors: data alignment and internal type implementation.\nFirst, about data alignment: all the types in your structure are <em>naturally</em> aligned, which means that <code>char</code> can be at any address, but <code>void*</code> may require alignment of 4 or 8 depending on architecture.</p>\n<p>So, if we guess, that std::string uses simply <code>char*</code> internally to keep you string the layout on x32 would be:</p>\n<pre><code>struct rtok {\n  char type;\n  char* val; // here char * for simplicity\n  bool term;\n};\n</code></pre>\n<p>The <code>sizeof(rtok)</code> operator would give 12 bytes, not 6, and the memory footprint would look like:</p>\n<pre><code>00: type (one byte)\n01: padding\n02: padding\n03: padding\n04-07: char * (4 bytes)\n08: term (one byte)\n09-0a: padding (3 bytes)\n</code></pre>\n<p>Now, if we replace <code>char*</code> with <code>std::string</code>, we would find that the structure size has grown, as <code>sizeof(std::string)</code> is typically larger, than 4 bytes.</p>\n<p>BUT, we have not computed the string value itself... And here we get into area of heap management and allocation.</p>\n<p>The memory for storing the value is allocated on heap, and the code usually requests as much as it needs, so for string of 10 characters it would be 11 bytes (10 characters plus 1 byte for null terminator).</p>\n<p>And heap has own complex structure with small-block heap etc. In practice, it means, that the minimum amount consumed is something like 16 bytes or more. This amount is not what you can use, this amount is for managing heap internal structures, and the only usable amount can be as little as 1 byte.</p>\n<p>If you add up everything, you would find out that even when you plan to use only two characters plus type, the amount of memory consumed would be much-much-much larger.</p>\n", "LastActivityDate": "2015-02-15T13:48:19.617", "CommentCount": "0", "CreationDate": "2015-02-15T13:48:19.617", "ParentId": "28526585", "Score": "2", "OwnerUserId": "1405614"}, "bq_ids": {"n4140": {"so_28526585_28527093_3": {"length": 21, "quality": 0.6176470588235294, "section_id": 7035}, "so_28526585_28527093_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5872}, "so_28526585_28527093_4": {"length": 8, "quality": 1.0, "section_id": 7035}, "so_28526585_28527093_1": {"length": 50, "quality": 0.9433962264150944, "section_id": 5873}}, "n3337": {"so_28526585_28527093_3": {"length": 21, "quality": 0.6176470588235294, "section_id": 6781}, "so_28526585_28527093_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5643}, "so_28526585_28527093_4": {"length": 8, "quality": 1.0, "section_id": 6781}, "so_28526585_28527093_1": {"length": 49, "quality": 0.9245283018867925, "section_id": 5644}}, "n4659": {"so_28526585_28527093_3": {"length": 20, "quality": 0.5882352941176471, "section_id": 8532}, "so_28526585_28527093_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7355}, "so_28526585_28527093_4": {"length": 8, "quality": 1.0, "section_id": 8532}, "so_28526585_28527093_1": {"length": 50, "quality": 0.9433962264150944, "section_id": 7356}}}, "28526585": {"ViewCount": "764", "Body": "<p>I have a struct that looks like this:</p>\n<pre><code>struct rtok {\n    char type;\n    std::string val;\n    bool term;\n};\n</code></pre>\n<p>I'm writing a simple interpreter and this \"rtok\" struct is how I represent a token. I have a vector of \"rtoks\" that I iterate through to generate the parse tree.</p>\n<p>My question is, if I have 3 members in my struct and I only give a value to 1 member, will the other members still take up memory?</p>\n<p>What I mean is, if I set \"val\" equal to \"test\" would my token take up just 4 bytes or would it take up 6 bytes? (4 bytes for \"val\", 1 byte for type, 1 byte for term)</p>\n", "AcceptedAnswerId": "28526625", "Title": "C++ struct member memory allocation", "CreationDate": "2015-02-15T13:31:39.723", "Id": "28526585", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-02-15T14:35:12.373", "Score": "0", "OwnerUserId": "3810411", "Tags": "<c++><memory><struct><interpreter>", "AnswerCount": "4"}, "28526625": {"Id": "28526625", "PostTypeId": "2", "Body": "<p>Assuming you don't have additional members or virtual functions, your struct will always occupy <code>sizeof(char) + sizeof(string) + sizeof(bool) + possible padding</code>. The <code>string</code> part allocates itself a chunk of memory, which it deallocates at destruction. However, this memory is not technically part of the one allocated for the <code>struct</code>. </p>\n<p>So no matter of the values you give (or omit) for the members, the struct will always have the same size.</p>\n", "LastEditorUserId": "3019689", "LastActivityDate": "2015-02-15T14:05:58.693", "Score": "4", "CreationDate": "2015-02-15T13:36:10.033", "ParentId": "28526585", "CommentCount": "0", "OwnerUserId": "3093378", "LastEditDate": "2015-02-15T14:05:58.693"}});