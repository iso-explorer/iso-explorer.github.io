post_cb({"25650661": {"ParentId": "25650592", "CommentCount": "0", "Body": "<p>I would use <code>NULL</code> since that is what C uses (also, <code>nullptr</code> is new in C++11, so if you are not using C++11 then you have to use <code>NULL</code>).  On the other hand, you could simply not check for either value explicitly, do an implicit comparison instead, let the compiler check for <code>!= 0</code> for you:</p>\n<pre><code>if (CreateEventEx(myEventHandleHere))\n{\n    ...\n}\n</code></pre>\n<p>You should assign the value to a variable so you can free it later (if that is what the C API requires):</p>\n<pre><code>TypeName event = CreateEventEx(myEventHandleHere);\nif (event)\n{\n    ...\n    free event when done...\n}\n</code></pre>\n", "OwnerUserId": "65863", "PostTypeId": "2", "Id": "25650661", "Score": "0", "CreationDate": "2014-09-03T17:51:44.267", "LastActivityDate": "2014-09-03T17:51:44.267"}, "25650592": {"CommentCount": "4", "ViewCount": "2002", "PostTypeId": "1", "LastEditorUserId": "2602718", "CreationDate": "2014-09-03T17:46:24.513", "LastActivityDate": "2014-09-04T13:56:38.450", "Title": "C++: Compare return value of C function to NULL or nullptr?", "LastEditDate": "2014-09-03T18:13:26.203", "Id": "25650592", "Score": "3", "Body": "<p>I'm coding in C++, and using a C function that returns NULL in case of a failure. What would be the correct think to do, compare its return value to NULL or nullptr? </p>\n<pre><code>if ((CreateEventEx(myEventHandleHere) == NULL)\n{\n    ...\n}\n</code></pre>\n<p>or</p>\n<pre><code>if ((CreateEventEx(myEventHandleHere) == nullptr)\n{\n    ...\n}\n</code></pre>\n", "Tags": "<c++><null><nullptr>", "OwnerUserId": "1127228", "AnswerCount": "4"}, "25651510": {"ParentId": "25650592", "CommentCount": "2", "Body": "<p>They are exactly and totally equivalent, so use <code>nullptr</code> because <code>NULL</code> is a primitive C-ism that has no reason to live anymore.</p>\n<p>But in the case of CreateEventEx you have the hilarious bonus of not all invalid <code>HANDLE</code>s being <code>nullptr</code>, some of them are <code>INVALID_HANDLE_VALUE</code> instead. So neither is really \"safe\" in the case of <code>HANDLE</code>. You need to check exactly what CreateEventEx returns on failure.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "25651510", "Score": "2", "CreationDate": "2014-09-03T18:45:11.870", "LastActivityDate": "2014-09-03T18:45:11.870"}, "25656153": {"ParentId": "25650592", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"noreferrer\">draft C++ standard</a> in appendix <code>C.4</code> <em>C Standard library</em> which is non-normative says:</p>\n<blockquote>\n<p id=\"so_25650592_25656153_0\">The macro NULL, defined in any of &lt;clocale&gt;, &lt;cstddef&gt;, &lt;cstdio&gt;,\n  &lt;cstdlib&gt;, &lt;cstring&gt;, &lt;ctime&gt;, or &lt;cwchar&gt;, is an\n  implementation-defined C++ null pointer constant in this International\n  Standard (18.2).</p>\n</blockquote>\n<p>the respective normative sections agree for example <code>18.2</code> says:</p>\n<blockquote>\n<p id=\"so_25650592_25656153_1\">The macro NULL is an implementation-defined C++ null pointer constant\n  in this International Standard (4.10).194</p>\n</blockquote>\n<p>which would mean if you are using the those particular headers <code>NULL</code> should be compatible with <code>nullptr</code> and then I would just use <code>nullptr</code>.</p>\n<p>In appendix <code>D</code> which covers compatibility does not seem to make a similar statement for <code>.h</code> header files, so although we would expect that <code>NULL</code> and <code>nullptr</code> should be compatible <em>null pointer constants</em> and we would be surprised if they were not from the standard point of view it seems at minimum to be underspecified. Which leaves us with a dilemma, from a practical perspective we are pretty sure they are compatible but we don't have enough information from the standard to prove it. </p>\n<p>So I would use <code>NULL</code> as defined by the specific header file you are using or we can use <code>!= 0</code> since fortunately both C99 and C++11 tell us that <code>0</code> is a <em>null pointer constant</em>.</p>\n<p>From C99 section <code>6.3.2.3</code> <em>Pointers</em>:</p>\n<blockquote>\n<p id=\"so_25650592_25656153_2\">An integer constant expression with the value 0, or such an expression\n  cast to type void *, is called a null pointer constant.55) If a null\n  pointer constant is converted to a pointer type, the resulting\n  pointer, called a null pointer, is guaranteed to compare unequal to a\n  pointer to any object or function.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_25650592_25656153_3\">Any pointer type may be converted to an integer type. Except as\n  previously specified, the result is implementation-defined</p>\n</blockquote>\n<p>and C++ section <code>4.10</code> <em>Pointer conversions</em> tells us:</p>\n<blockquote>\n<p id=\"so_25650592_25656153_4\">A null pointer constant is an integer literal (2.14.2) with value zero\n  or a prvalue of type std::nullptr_t. A null pointer constant can be\n  converted to a pointer type; the result is the null pointer value of\n  that type and is distinguishable from every other value of object\n  pointer or function pointer type.[...]</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-09-04T13:56:38.450", "Id": "25656153", "Score": "5", "CreationDate": "2014-09-04T01:49:17.673", "LastActivityDate": "2014-09-04T13:56:38.450"}, "25651131": {"ParentId": "25650592", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I'm not sure why it matters if the function returns NULL. That is an implementation detail. There are many old C++ functions which return NULL. And many new functions will return <code>nullptr</code>. So, if you decide to switch from <code>NULL</code> to <code>nullptr</code> for null pointer values in your <em>own</em> code, then you should be consistent about that, regardless of whether the function happens to originally written as C. When it is compiled as C++, it becomes a C++ function.</p>\n<p>However. In this case, the return type is a <code>HANDLE</code>. The fact that <code>HANDLE</code> is actually a typedef for a <code>void*</code> is an implementation detail. The WinAPI documentation says that when a <code>HANDLE</code> is invalid, it is comparable to <code>NULL</code>. In this case, I would suggest you go with the WinAPI documentation, and use <code>NULL</code>. If the WinAPI didn't use typedefs, and just documented all its functions as returning <code>void*</code>, then I would use <code>nullptr</code>, if you use <code>nullptr</code> in the rest of your C++ code.</p>\n", "OwnerUserId": "440119", "LastEditorUserId": "440119", "LastEditDate": "2014-09-03T18:35:56.060", "Id": "25651131", "Score": "-1", "CreationDate": "2014-09-03T18:22:23.140", "LastActivityDate": "2014-09-03T18:35:56.060"}, "bq_ids": {"n4140": {"so_25650592_25656153_0": {"section_id": 2515, "quality": 0.7777777777777778, "length": 14}, "so_25650592_25656153_4": {"section_id": 39, "quality": 0.90625, "length": 29}, "so_25650592_25656153_3": {"section_id": 6044, "quality": 0.5833333333333334, "length": 7}, "so_25650592_25656153_1": {"section_id": 2515, "quality": 0.7, "length": 7}}, "n3337": {"so_25650592_25656153_2": {"section_id": 36, "quality": 0.5333333333333333, "length": 16}, "so_25650592_25656153_4": {"section_id": 36, "quality": 0.84375, "length": 27}, "so_25650592_25656153_3": {"section_id": 5812, "quality": 0.5833333333333334, "length": 7}, "so_25650592_25656153_1": {"section_id": 6460, "quality": 0.7, "length": 7}}, "n4659": {"so_25650592_25656153_0": {"section_id": 3249, "quality": 0.7777777777777778, "length": 14}, "so_25650592_25656153_4": {"section_id": 39, "quality": 0.90625, "length": 29}, "so_25650592_25656153_3": {"section_id": 7543, "quality": 0.5833333333333334, "length": 7}, "so_25650592_25656153_1": {"section_id": 3249, "quality": 0.6, "length": 6}}}});