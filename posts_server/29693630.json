post_cb({"bq_ids": {"n4140": {"so_29693630_29694017_0": {"length": 36, "quality": 0.72, "section_id": 2710}, "so_29693630_29694017_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 2689}}, "n3337": {"so_29693630_29694017_0": {"length": 36, "quality": 0.72, "section_id": 2671}, "so_29693630_29694017_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 2651}}, "n4659": {"so_29693630_29694017_0": {"length": 35, "quality": 0.7, "section_id": 3450}, "so_29693630_29694017_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 3429}}}, "29694017": {"Id": "29694017", "PostTypeId": "2", "Body": "<p>1) This \"thread-accessible storage\" bit of text is not represented directly in the standard. The standard simply says that the function is invoked with arguments obtained by <code>decay_copy</code>.</p>\n<p>2) If you study <code>decay_copy</code> closely, you will find that it returns <em>by value</em> (because its return type is <code>std::decay</code> of something). So the function <code>f</code> is called with rvalue arguments (prvalue arguments, in fact).</p>\n<p>If you want to pass lvalues (references), you can use <code>std::ref</code> and <code>std::cref</code> to wrap them.</p>\n<p>The exact quote, C++11 30.3.1.2/4:</p>\n<blockquote>\n<p id=\"so_29693630_29694017_0\"><em>Effects:</em> Constructs an object of type <code>thread</code>. The new thread of execution executes <em><code>INVOKE(DECAY_COPY ( std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code></em> with the calls to\n  <em><code>DECAY_COPY</code></em> being evaluated in the constructing thread. Any return value from this invocation is\n  ignored. [ <em>Note:</em> This implies that any exceptions not thrown from the invocation of the copy of <code>f</code>\n  will be thrown in the constructing thread, not the new thread. <em>\u2014end note</em> ] If the invocation of\n  <em><code>INVOKE(DECAY_COPY ( std::forward&lt;F&gt;(f)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code></em> terminates\n  with an uncaught exception, <code>std::terminate</code> shall be called.</p>\n</blockquote>\n<p><em><code>DECAY_COPY</code></em> is defined in 30.2.6/1:</p>\n<blockquote>\n<p id=\"so_29693630_29694017_1\">In several places in this Clause the operation <em><code>DECAY_COPY(x)</code></em> is used. All such uses mean call the function\n  <code>decay_copy(x)</code> and use the result, where <code>decay_copy</code> is defined as follows:</p>\n<pre><code>template &lt;class T&gt; typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v)\n{ return std::forward&lt;T&gt;(v); }\n</code></pre>\n</blockquote>\n<p><em><code>INVOKE</code></em> is defined in 20.8.2 pretty much in the same way as cppreference describes the invocation in the link you've provided.</p>\n", "LastActivityDate": "2015-04-17T08:25:33.977", "CommentCount": "2", "CreationDate": "2015-04-17T08:25:33.977", "ParentId": "29693630", "Score": "2", "OwnerUserId": "1782465"}, "29693630": {"ViewCount": "363", "Body": "<p>I'm interested in (and confused about) the details of constructing a <code>std::thread</code> object. According to <a href=\"http://en.cppreference.com/w/cpp/thread/thread/thread\" rel=\"nofollow\">cppreference</a>, both the thread function and all arguments are value-copied to some thread-accessible storage, and then invoke. </p>\n<p><strong>1) What exactly is this thread-accessible storage?</strong> Is it semantically equivalent to some kind of thread-local storage, and the variables are destructed after the thread function returned?</p>\n<p><strong>2) What is the value-category of the arguments when passed to the thread function?</strong> The description on cppreference suggests that they are passed as l-values (they are given names anyway). My tests on GCC and clang seem to suggest the opposite, i.e., r-values. Specifically, the following code does not compile:</p>\n<pre><code>void f(int&amp; a) {\n  std::cout &lt;&lt; ++a &lt;&lt; '\\n';\n}\n\nint main() {\n    std::thread t(&amp;f, 1);\n    t.join();\n    return 0;\n}\n</code></pre>\n<p>It compiles if we change <code>f</code> to</p>\n<pre><code>void f(int&amp;&amp; a) {\n  std::cout &lt;&lt; ++a &lt;&lt; '\\n';\n}\n\nint main() {\n    std::thread t(&amp;f, 1);\n    t.join();\n    return 0;\n}\n</code></pre>\n<p>So, what does the standard say about this?</p>\n", "AcceptedAnswerId": "29694017", "Title": "Details in the process of constructing a std::thread object", "CreationDate": "2015-04-17T08:05:10.460", "Id": "29693630", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-04-17T08:25:33.977", "Score": "3", "OwnerUserId": "1348273", "Tags": "<c++><multithreading><c++11><language-lawyer><stdthread>", "AnswerCount": "1"}});