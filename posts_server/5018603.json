post_cb({"bq_ids": {"n4140": {"so_5018603_5019603_0": {"section_id": 6066, "quality": 0.5806451612903226, "length": 18}}, "n3337": {"so_5018603_5019603_0": {"section_id": 5834, "quality": 0.5806451612903226, "length": 18}}, "n4659": {"so_5018603_5019603_0": {"section_id": 7562, "quality": 0.5161290322580645, "length": 16}}}, "5018794": {"ParentId": "5018603", "CommentCount": "7", "Body": "<p>In the first case you're taking the address of pointer-to-member <code>B::b</code>. Since such a pointer is NOT a member of the parent of <code>A</code> but a separate object, it can't access it via the protected mechanism.</p>\n<p>In the SECOND case where it works you're asking for the address of the <em>specific instance</em> of <code>b</code>, qualifying it with its base class so that in the case of multiple inheritance the compiler would know which base class you mean. In this context the protected attribute is visible.</p>\n<p>Note that this compiles:</p>\n<pre><code>class B\n{\nprotected:\nint b;\n};\n\nclass A : public B\n{\npublic:\nvoid foo(){ &amp;A::b; }  // Note here &amp;A:: instead of &amp;B::\n};\n</code></pre>\n<p>As an added example it doesn't work for the same reason that the following (hopefully more familiar) code doesn't work:</p>\n<pre><code>class B\n{\nprotected:\nint b;\n};\n\nclass A : public B\n{\npublic:\nvoid foo(const B* b_obj) { b_obj-&gt;b; }\n};\n</code></pre>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "5018794", "Score": "13", "CreationDate": "2011-02-16T16:05:11.797", "LastActivityDate": "2011-02-16T16:05:11.797"}, "5018911": {"ParentId": "5018603", "CommentCount": "3", "Body": "<p>The differece between the two statements becomes more obvious when you try and return the value:</p>\n<pre><code>int*     foo()    { return &amp;(B::b);}  // This is a pointer to an int\n\n\nint A::* foo()    { return &amp;B::b; }   // This is a pointer to a member of type int\n</code></pre>\n<p>What you want to do is access it via the A object:</p>\n<pre><code>int A::* foo()    { return &amp;A::b; }   // This is a pointer to a member of type int\n</code></pre>\n<p>As from the A you are allowed to access it.<br>\nAccessing it via B like that is accessing it from outside and thus triggers the access specifiers.</br></p>\n", "OwnerUserId": "14065", "PostTypeId": "2", "Id": "5018911", "Score": "6", "CreationDate": "2011-02-16T16:12:36.190", "LastActivityDate": "2011-02-16T16:12:36.190"}, "5018603": {"CommentCount": "2", "AcceptedAnswerId": "5018794", "CreationDate": "2011-02-16T15:50:15.397", "LastActivityDate": "2011-02-16T17:07:43.983", "PostTypeId": "1", "ViewCount": "477", "FavoriteCount": "3", "Title": "a question about the precedence of C++ operators \"address of\" and \"scope resolution\"", "Id": "5018603", "Score": "23", "Body": "<p>Hello I have this code with a compiler error (error is from Microsoft Visual Studio 2008):</p>\n<pre><code>class B\n{\nprotected:\nint b;\n};\n\nclass A : public B\n{\npublic:\nvoid foo(){ &amp;B::b; }//  error C2248: 'B::b' : cannot access protected member declared in class 'B'\n};\n</code></pre>\n<p>while this code is error free:</p>\n<pre><code>class B\n{\nprotected:\nint b;\n};\n\nclass A : public B\n{\npublic:\nvoid foo(){ &amp;(B::b); }\n};\n</code></pre>\n<p>The two snippets seem to me equivalent based on my knowledge of the precedence of operators, because :: has an higher precedence than &amp; (see for example table 2 at page 137 of \"JOINT STRIKE FIGHTER AIR VEHICLE C++ CODING STANDARDS FOR THE SYSTEM DEVELOPMENT AND DEMONSTRATION PROGRAM\" <a href=\"http://www2.research.att.com/~bs/JSF-AV-rules.pdf\" rel=\"noreferrer\">http://www2.research.att.com/~bs/JSF-AV-rules.pdf</a> )</p>\n<p>But they are different... I think it is something related to \"pointer-to-data-member\" but I do not know how does it fit with the operators precedence.</p>\n<p>Any explanation?</p>\n<p>Thank you,\nAlessandro</p>\n", "Tags": "<c++><precedence><pointer-to-member>", "OwnerUserId": "15485", "AnswerCount": "3"}, "5019603": {"ParentId": "5018603", "CommentCount": "1", "Body": "<p>This is just a supplementation.<br>\n\u00a75.3.1/2 says:</br></p>\n<blockquote>\n<p id=\"so_5018603_5019603_0\">The result of the unary &amp; operator is\n  a pointer to its operand. The operand\n  shall be an lvalue or a qualified-id.\n  In the first case, if the type of the\n  expression is \u201cT,\u201d the type of the\n  result is \u201cpointer to T.\u201d\n  ...<br>\n  For a\n  qualified-id, ... If the member is a\n  non-static member of class C of type\n  T, the type of the result is \u201cpointer\n  to member of class C of type T.\u201d</br></p>\n</blockquote>\n<p>According to \u00a75.1/7, <code>B::b</code> comes under the qualified-id case, but <code>(B::b)</code> doesn't.\nSo, compiler interprets it as an lvalue.</p>\n", "OwnerUserId": "547710", "PostTypeId": "2", "Id": "5019603", "Score": "7", "CreationDate": "2011-02-16T17:07:43.983", "LastActivityDate": "2011-02-16T17:07:43.983"}});