post_cb({"bq_ids": {"n4140": {"so_42420116_42420597_3": {"length": 12, "quality": 0.6, "section_id": 5879}, "so_42420116_42420229_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 6040}, "so_42420116_42420597_2": {"length": 7, "quality": 0.7, "section_id": 5913}}, "n3337": {"so_42420116_42420229_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 5808}, "so_42420116_42420597_2": {"length": 6, "quality": 0.6, "section_id": 5685}}, "n4659": {"so_42420116_42420597_5": {"length": 28, "quality": 0.9032258064516129, "section_id": 8733}, "so_42420116_42420597_3": {"length": 19, "quality": 0.95, "section_id": 8733}, "so_42420116_42420229_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 7539}, "so_42420116_42420597_4": {"length": 6, "quality": 1.0, "section_id": 8733}, "so_42420116_42420597_2": {"length": 9, "quality": 0.9, "section_id": 8733}}}, "42420597": {"Id": "42420597", "PostTypeId": "2", "Body": "<p><strong>TL;DR</strong>: The compiler must inspect <code>reinterpret_cast</code>s and figure out that (standard library) specializations of <code>std::complex</code> are involved. We cannot conformably mimic the semantics.</p>\n<p>I think it's fairly clear that treating three distinct members as array elements is not going to work, since pointer arithmetic on pointers to them is extremely restricted (e.g. adding 1 yields a <a href=\"http://eel.is/c++draft/basic.compound#3\" rel=\"nofollow noreferrer\">pointer past-the-end</a>).</p>\n<p>So let's assume <code>vec3</code> contained an array of three <code>int</code>s instead.\nEven then, the underlying <code>reinterpret_cast&lt;int*&gt;(&amp;v)</code> you implicitly need (where <code>v</code> is a <code>vec3</code>) does not leave you with a pointer to the first element. See the exhaustive requirements on <a href=\"http://eel.is/c++draft/basic.compound#4\" rel=\"nofollow noreferrer\">pointer-interconvertibility</a>:</p>\n<blockquote>\n<p id=\"so_42420116_42420597_0\">Two objects <code>a</code> and <code>b</code> are <em>pointer-interconvertible</em> if:</p>\n<ul>\n<li><p id=\"so_42420116_42420597_1\">they are the same object, or</p></li>\n<li><p id=\"so_42420116_42420597_2\">one is a standard-layout union object and the other is a non-static data member of that object ([class.union]), or</p></li>\n<li><p id=\"so_42420116_42420597_3\">one is a standard-layout class object and the other is the first non-static data member of that object, or, if the object has no\n  non-static data members, the first base class subobject of that object\n  ([class.mem]), or</p></li>\n<li><p id=\"so_42420116_42420597_4\">there exists an object <code>c</code> such that <code>a</code> and <code>c</code> are pointer-interconvertible, and <code>c</code> and <code>b</code> are\n  pointer-interconvertible.</p></li>\n</ul>\n<p id=\"so_42420116_42420597_5\">If two objects are pointer-interconvertible, then they have the same\n  address, and it is possible to obtain a pointer to one from a pointer\n  to the other via a <code>reinterpret_\u00adcast</code>. [\u2009<em>Note</em>: <strong>An array object\n  and its first element are not pointer-interconvertible, even though\n  they have the same address.</strong> \u2009\u2014\u2009<em>end note</em>\u2009]</p>\n</blockquote>\n<p>That's quite unequivocal; while we can get a pointer to the array (being the first member), and while pointer-interconvertibility is transitive, we cannot obtain a pointer to its first element.</p>\n<p>And finally, even if you managed to obtain a pointer to the first element of your member array, if you had an array of <code>vec3</code>s, you cannot  <em>traverse</em> all the member arrays using simple pointer increments, since we get pointers past-the-end of the arrays in between. launder doesn't solve this problem either, because the objects that the pointers are associated with don't share any storage (cf <a href=\"http://eel.is/c++draft/ptr.launder#1\" rel=\"nofollow noreferrer\">[ptr.launder]</a> for specifics).</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2017-02-24T00:19:28.650", "Score": "9", "CreationDate": "2017-02-23T15:59:47.267", "ParentId": "42420116", "CommentCount": "9", "LastEditDate": "2017-02-24T00:19:28.650", "OwnerUserId": "3647361"}, "42420116": {"ViewCount": "511", "Body": "<p>Since C++11 <code>std::complex&lt;T&gt;[n]</code> is guaranteed to be aliasable as <code>T[n*2]</code>, with well defined values. Which is exactly what one would expect for any mainstream architecture. Is this guarantee achievable with standard C++ for my own types, say <code>struct vec3 { float x, y, z; }</code> or is it only possible with special support from the compiler?</p>\n", "AcceptedAnswerId": "42420597", "Title": "`std::complex<T>[n]` and `T[n*2]` type aliasing", "CreationDate": "2017-02-23T15:38:37.630", "Id": "42420116", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-02-24T00:19:28.650", "Score": "15", "OwnerUserId": "1554020", "Tags": "<c++><language-lawyer><strict-aliasing><type-punning>", "AnswerCount": "3"}, "42420229": {"Id": "42420229", "PostTypeId": "2", "Body": "<p>It's only possible with special support from the compiler, mostly.</p>\n<p>Unions don't get you there because the common approach actually has undefined behaviour, although there are exceptions for layout-compatible initial sequences, and you may inspect an object through an <code>unsigned char*</code> as a special case. That's it, though.</p>\n<p>Interestingly, unless we assume a broad and useless meaning of \"below\", the standard is technically contradictory in this regard:</p>\n<blockquote>\n<p id=\"so_42420116_42420229_0\"><code>[C++14: 5.2.10/1]:</code> <em>[..]</em> Conversions that can be performed explicitly using reinterpret_cast are listed below. No other conversion can be performed explicitly using reinterpret_cast.</p>\n</blockquote>\n<p>The case for <code>complex&lt;T&gt;</code> is then not mentioned. Finally the rule you're referring to is introduced much, much later, in <code>[C++14: 26.4/4]</code>.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2017-02-23T15:50:16.533", "Score": "5", "CreationDate": "2017-02-23T15:44:17.857", "ParentId": "42420116", "CommentCount": "3", "LastEditDate": "2017-02-23T15:50:16.533", "OwnerUserId": "560648"}, "42420305": {"Id": "42420305", "PostTypeId": "2", "Body": "<p>I think it would work for a single <code>vec3</code> if your type contained <code>float x[3]</code> instead, and you ensure <code>sizeof(vec3) == 3*sizeof(float) &amp;&amp; is_standard_layout_v&lt;vec3&gt;</code>. Given those conditions, the standard guarantees that the first member is at zero offset so the address of the first <code>float</code> is the address of the object, and you can perform array arithmetic to get the other elements in the array:</p>\n<pre><code>struct vec3 { float x[3]; } v = { };\nfloat* x = reinterpret_cast&lt;float*&gt;(&amp;v);  // points to first float\nassert(x == v.x);\nassert(&amp;x[0] == &amp;v.x[0]);\nassert(&amp;x[1] == &amp;v.x[1]);\nassert(&amp;x[2] == &amp;v.x[2]);\n</code></pre>\n<p>What you can't do is treat an array of <code>vec3</code> as an array of floats three times the length. Array arithmetic on the array inside each <code>vec3</code> won't allow you to access the array inside the next <code>vec3</code>. <a href=\"http://wg21.link/cwg2182\" rel=\"nofollow noreferrer\">CWG 2182</a> is relevant here.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2017-02-23T15:53:34.197", "Score": "4", "CreationDate": "2017-02-23T15:47:20.857", "ParentId": "42420116", "CommentCount": "2", "LastEditDate": "2017-02-23T15:53:34.197", "OwnerUserId": "981959"}});