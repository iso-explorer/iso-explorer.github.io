post_cb({"1271669": {"LastActivityDate": "2017-11-03T08:38:56.063", "CommentCount": "0", "Body": "<p>This is not OS specific, rather its compiler specific. </p>\n<p>You have given the answer, initialization is done in <code>__init</code>.</p>\n<p>For the second part, in gcc you can guarantee the order of initialization with a <code>____attribute____((init_priority(PRIORITY)))</code> attached to a variable definition, where <code>PRIORITY</code> is some relative value, with lower numbers initialized first.</p>\n", "CreationDate": "2009-08-13T12:33:42.583", "LastEditDate": "2017-11-03T08:38:56.063", "ParentId": "1271248", "Id": "1271669", "LastEditorUserId": "1000551", "PostTypeId": "2", "Score": "10", "OwnerUserId": "154980"}, "1271692": {"LastActivityDate": "2009-08-13T12:43:21.110", "CommentCount": "6", "Body": "<p>When talking about non-local static objects there are not many guarantees. As you already know (and it's also been mentioned here), it should not write code that depends on that. The static initialization order fiasco...</p>\n<p>Static objects goes through a two-phase initialization: static initialization and dynamic initialization. The former happens first and performs zero-initialization or initialization by constant expressions. The latter happens after all static initialization is done. This is when constructors are called, for example.</p>\n<p>In general, this initialization happens at some time before main(). However, as opposed to what many people think even that is not guaranteed by the C++ standard. What is in fact guaranteed is that the initialization is done before the use of any function or object defined in the same translation unit as the object being initialized. Notice that this is not OS specific. This is C++ rules. Here's a quote from the Standard:</p>\n<blockquote id=\"so_1271248_1271692_0\">\nIt is implementation-defined whether or not the dynamic initialization (8.5, 9.4, 12.1, 12.6.1) of an object of\nnamespace scope is done before the first statement of main. If the initialization is deferred to some point\nin time after the first statement of main, it shall occur before the first use of any function or object defined\nin the same translation unit as the object to be initialized\n</blockquote>\n", "CreationDate": "2009-08-13T12:36:56.560", "LastEditDate": "2009-08-13T12:43:21.110", "ParentId": "1271248", "Id": "1271692", "LastEditorUserId": "155191", "PostTypeId": "2", "Score": "16", "OwnerUserId": "155191"}, "1271248": {"CreationDate": "2009-08-13T10:48:24.350", "ViewCount": "17574", "FavoriteCount": "11", "Id": "1271248", "AcceptedAnswerId": "1271692", "Score": "23", "Title": "C++: When (and how) are C++ Global Static Constructors Called?", "LastEditorUserId": "118364", "CommentCount": "0", "Body": "<p>I'm working on some C++ code and I've run into a question which has been nagging me for a while... Assuming I'm compiling with GCC on a Linux host for an ELF target, where are global static constructors and destructors called?</p>\n<p>I've heard there's a function _init in crtbegin.o, and a function _fini in crtend.o. Are these called by crt0.o? Or does the dynamic linker actually detect their presence in the loaded binary and call them? If so, <em>when</em> does it actually call them?</p>\n<p>I'm mainly interested to know so I can understand what's happening behind the scenes as my code is loaded, executed, and then unloaded at runtime.</p>\n<p>Thanks in advance!</p>\n<p>Update: I'm basically trying to figure out the general time at which the constructors are called. I don't want to make assumptions in my code based on this information, it's more or less to get a better understanding of what's happening at the lower levels when my program loads. I understand this is quite OS-specific, but I have tried to narrow it down a little in this question.</p>\n", "Tags": "<c++><gcc><static><global><constructor>", "LastEditDate": "2009-08-13T11:08:34.740", "LastActivityDate": "2017-11-03T08:38:56.063", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "118364"}, "1273257": {"LastActivityDate": "2009-08-15T19:04:06.277", "CommentCount": "4", "Body": "<p>The grantees you have:</p>\n<ul>\n<li>All static non-local objects in the global namespace are constructed before main()</li>\n<li>All static non-local objects in another namespace are constructed before any functions/methods in that namespace are used (Thus allowing the compiler to potentially lazy evaluate them [but don't count on this behavior]).</li>\n<li>All static non-local objects in a translation unit are constructed in the order of declaration.</li>\n<li>Nothing is defined about the order between translation units.</li>\n<li>All static non-local objects are destroyed in the reverse order of creation. (This includes the static function variables (which are lazily created on first use).</li>\n</ul>\n<p>If you have globals that have dependencies on each other you have two options:</p>\n<ul>\n<li>Put them in the same translation unit.</li>\n<li>Transform them into static function variables retrieved and constructed on first use.</li>\n</ul>\n<h3>Example 1: Global A's constructor uses Global log</h3>\n<pre><code>class AType\n{    AType()  { log.report(\"A Constructed\");}};\n\nLogType    log;\nAType      A;\n\n// Or \nClass AType() \n{    AType()  { getLog().report(\"A Constructed\");}};\nLogType&amp; getLog()\n{\n    static LogType  log;\n    return log;\n}\n// Define A anywhere;\n</code></pre>\n<h3>Example Global B's destructor uses Global log</h3>\n<p>Here you have to grantee that the object log is not destroyed before the object B. This means that log must be fully constructed before B (as the reverse order of destruction rule will then apply). Again the same techniques can be used. Either put them in the same translation unit or use  a function to get log.</p>\n<pre><code>class BType\n{    ~BType()  { log.report(\"B Destroyed\");}};\n\nLogType    log;\nBType      B;   // B constructed after log (so B will be destroyed first)\n\n// Or \nClass BType() \n{    BType()    { getLog();}\n     /*\n      * If log is used in the destructor then it must not be destroyed before B\n      * This means it must be constructed before B \n      * (reverse order destruction guarantees that it will then be destroyed after B)\n      *\n      * To achieve this just call the getLog() function in the constructor.\n      * This means that 'log' will be fully constructed before this object.\n      * This means it will be destroyed after and thus safe to use in the destructor.\n      */\n    ~BType()    { getLog().report(\"B Destroyed\");}\n};\nLogType&amp; getLog()\n{\n    static LogType  log;\n    return log;\n}\n// Define B anywhere;\n</code></pre>\n", "CreationDate": "2009-08-13T16:57:00.003", "LastEditDate": "2009-08-15T19:04:06.277", "ParentId": "1271248", "Id": "1273257", "LastEditorUserId": "14065", "PostTypeId": "2", "Score": "6", "OwnerUserId": "14065"}, "1271588": {"LastActivityDate": "2009-08-14T08:07:16.153", "CommentCount": "6", "Body": "<p>According to the C++ standard they are called before any function or object of their translation unit is used. Note that for objects in the global namespace this would mean they are initialized before <code>main()</code> is called. (See <a href=\"https://stackoverflow.com/questions/1271248/c-when-and-how-are-c-global-static-constructors-called/1271692#1271692\">ltcmelo's</a> and <a href=\"https://stackoverflow.com/questions/1271248/c-when-and-how-are-c-global-static-constructors-called/1273257#1273257\">Martin's</a> answers for mote details and a discussion of this.)</p>\n", "CreationDate": "2009-08-13T12:12:58.010", "LastEditDate": "2017-05-23T12:17:57.623", "ParentId": "1271248", "Id": "1271588", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "5", "OwnerUserId": "140719"}, "bq_ids": {"n4140": {"so_1271248_1271692_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 7153}}, "n3337": {"so_1271248_1271692_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 6897}}}, "1271277": {"CommentCount": "2", "Body": "<p>This depends heavy on the compiler and runtime. It's not a good idea to make any assumptions on the time global objects are constructed.</p>\n<p>This is especially a problem if you have a static object which depends on another one being already constructed.</p>\n<p>This is called \"<a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12\" rel=\"noreferrer\">static initialization order fiasco</a>\". Even if thats not the case in your code, the C++Lite FAQ articles on that topic are worth a read.</p>\n", "CreationDate": "2009-08-13T10:57:07.183", "ParentId": "1271248", "Id": "1271277", "LastActivityDate": "2009-08-13T10:57:07.183", "PostTypeId": "2", "Score": "10", "OwnerUserId": "104480"}});