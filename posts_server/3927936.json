post_cb({"3928128": {"Id": "3928128", "PostTypeId": "2", "Body": "<p>Two important things:</p>\n<ol>\n<li><p>You have undefined behaviour because <code>a</code> is null. Undefined behaviour means that anything goes, the C++ standard imposes no restrictions on a program with undefined behaviour.</p></li>\n<li><p>The order of evaluation of the operands to the arithmetic operators is <em>unspecified</em>. That means the compiler may generate code that calls <code>getX()</code> first in both of the two <code>getSum</code> functions, even though you have ordered them differently. In your particular case the order of evaluation of the operands is consistent.</p>\n<blockquote>\n<p id=\"so_3927936_3928128_0\"><strong>\u00a75/5</strong> \u201cExpressions\u201d: Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified.</p>\n</blockquote></li>\n</ol>\n", "LastActivityDate": "2010-10-13T21:21:22.493", "CommentCount": "0", "CreationDate": "2010-10-13T21:21:22.493", "ParentId": "3927936", "Score": "0", "OwnerUserId": "10320"}, "bq_ids": {"n4140": {"so_3927936_3928128_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 5811}}, "n3337": {"so_3927936_3928128_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 5584}}, "n4659": {"so_3927936_3928128_0": {"length": 10, "quality": 0.5555555555555556, "section_id": 7272}}}, "32987183": {"Id": "32987183", "PostTypeId": "2", "Body": "<p>\"When is the segfault thrown?\" Sometimes is <strong>never</strong> thrown, when should be thrown. \nBase of <strong>most implementation</strong> is Operation System with <strong>protection of memory</strong>. When OS is absent (embedded), or is very simply (CP/M, DOS), or has \"low profile\" goal (embedded), or CPU haven't such functionality (&lt;80186) problem is hidden or delayed. It is very bad news. <em>Houston, we have BIG invisible problem.</em></p>\n<p>Note:\nC++ in protected environment can realise scenarios when problem is hidden too (pointer is bad but in valid area)</p>\n<p>General rule how to understand C/C++ is key <strong>\"undefined behaviour\"</strong> (like many answers say), sometimes such exception</p>\n", "LastActivityDate": "2015-10-07T08:20:19.433", "CommentCount": "0", "CreationDate": "2015-10-07T08:20:19.433", "ParentId": "3927936", "Score": "0", "OwnerUserId": "794606"}, "3927973": {"Id": "3927973", "PostTypeId": "2", "Body": "<p>When you called those functions on a null pointer, you got <a href=\"https://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-behav\">undefined behavior</a>. That's really all that should be said; anything can happen, don't do it.</p>\n<p>The reason it segfaults is because there is no <code>A</code> at null. Attempting to access those members is attempting to access an invalid address. (This happens in <code>getx</code> and <code>getSum2</code>, hence the segfault report.)</p>\n<p>No, it cannot say the segfault happened in <code>main</code> because null wasn't accessed in main. (You still entered undefined behavior in main, no doubt, but in practice it just called a function with <code>this</code> set to null.) You accessed it in those functions. In practice, if a function never uses <code>this</code>, it won't crash with a null pointer.</p>\n<p>But don't.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-10-13T21:02:20.897", "Score": "1", "CreationDate": "2010-10-13T21:02:20.897", "ParentId": "3927936", "CommentCount": "2", "OwnerUserId": "87234", "LastEditDate": "2017-05-23T11:58:22.093"}, "3928074": {"Id": "3928074", "PostTypeId": "2", "Body": "<p>By the time the coredump is happening you're not really in C++ anymore. Some statements in the compiled code caused bad things to happen, such as attempting to access an invalid memory address, in your case via a null pointer.</p>\n<p>I guess that you're hoping that the diagnostics in the core dump might pin-point the problem rather than (seemingly in this case) giving slightly indeterminate results.</p>\n<p>The thing is that going back from compiled binarys to lines of source is somewhat tricky because there's plenbty of scope in the language for some \"as-if\" kind of reordering of statements and other cleverness. </p>\n<p>So, C++ itself, in the language spec,  won't specify what the core dump will tell you, and as has already been observed explicitly gives underfined behaviours when de-referencing null pointers.</p>\n<p>The thing is I don't really think this matters too much. For this kind of error getting a \"close-enough\" indictor of where the problem is soon leads to the source of the problem. Far nastier are the heap corruption problems that occur where symptom and cause can be many steps remote from each other and core dumps are less use.</p>\n", "LastActivityDate": "2010-10-13T21:15:28.357", "CommentCount": "0", "CreationDate": "2010-10-13T21:15:28.357", "ParentId": "3927936", "Score": "0", "OwnerUserId": "82511"}, "3927965": {"Id": "3927965", "PostTypeId": "2", "Body": "<p>Calling accessing members and calling member functions on null pointers is undefined behaviour.</p>\n<p>The segfault happens when the program tries to access x or y, which is why it happens in getx() in the first one and getSum2() in the second.</p>\n", "LastActivityDate": "2010-10-13T21:01:41.777", "CommentCount": "0", "CreationDate": "2010-10-13T21:01:41.777", "ParentId": "3927936", "Score": "0", "OwnerUserId": "235825"}, "3927936": {"ViewCount": "138", "Body": "<p>Suppose I have a class like</p>\n<pre><code>class A {\n    int x;\n    int y;\n  public:\n    getSum1() const {\n        return getx() + y;\n    }\n    getSum2() const {\n        return y + getx();\n    }\n    getx() const {\n        return x;\n    }\n}\n</code></pre>\n<p>And then I have</p>\n<pre><code>int main(int argc, char **argv) {\n    A *a = 0;\n    switch(argc) {\n    case 0:\n        a-&gt;getsum1();\n        break;\n    default:\n        a-&gt;getsum2();\n        break;\n    }\n    return 1;\n}\n</code></pre>\n<p>This program will segfault. I noticed that on my machine, when getsum1 executes, the core\ndump says the segfault was caused in getx, and when getsum2 executes it says the fault happened in getsum2.</p>\n<p>This makes sense. I have 2 questions:<br>\n1. is this behaviour specified, or is it implementation dependent?<br>\nAnd most importantly:<br>\n2. Could the core dump say that the segfault happened in main, when a was dereferenced? (i.e. at a-&gt;getsum*)</br></br></br></p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "3927973", "Title": "When is the segfault thrown?", "CreationDate": "2010-10-13T20:58:02.407", "Id": "3927936", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-10-07T08:20:19.433", "Score": "1", "OwnerUserId": "371623", "Tags": "<c++><segmentation-fault>", "AnswerCount": "5"}});