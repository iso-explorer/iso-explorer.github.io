post_cb({"35927106": {"ParentId": "35926728", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The body of an inline member function is not processed until the class definition has been fully processed.</p>\n<p>Hence, you can use:</p>\n<pre><code>class A \n{\n   class B;\n   B getB() { return B(); }\n\n   class B {};\n};\n</code></pre>\n<p>That also allows member variables that are not yet declared to be used in inline member function definition.</p>\n<pre><code>class Foo\n{\n   int getBar() { return bar; }\n\n   int bar;\n};\n</code></pre>\n<p>I am guessing the same logic is extended to inline definitions of member functions of nested classes -- i.e. they are not processed until the containing class definition is completely processed.</p>\n<p><strong>PS</strong> I am unable to quickly locate the reference in the standard that would verify my claim.</p>\n<p><strong>PS 2</strong> <a href=\"https://stackoverflow.com/a/35927869/434551\">The answer by Barry</a> has the reference in the standard that makes the code in the question valid.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:18.353", "Id": "35927106", "Score": "9", "CreationDate": "2016-03-10T20:56:15.863", "LastActivityDate": "2016-03-10T22:36:39.297"}, "35927869": {"ParentId": "35926728", "CommentCount": "1", "Body": "<p>I believe this is a consequence of <a href=\"http://eel.is/c++draft/basic.scope.class#1\" rel=\"noreferrer\">[basic.scope.class]</a>:</p>\n<blockquote>\n<p id=\"so_35926728_35927869_0\">The potential scope of a name declared in a class consists not only of the declarative region following the\n  name\u2019s point of declaration, but also of all function bodies, default arguments, <em>exception-specifications</em>, and <em>brace-or-equal-initializers</em> of non-static data members in that class (including such things in nested\n  classes).</p>\n</blockquote>\n<p>That is, the scope of the <em>full</em> declaration of <code>B</code> includes the body of the member function of the nested class:</p>\n<pre><code>class C {\n    class B; // (1)\n\n    class A { \n        B getB() {\n            return B(); // both (1) and (2) in scope here\n                        // since (2) is the complete type declaration,\n                        // this is perfectly fine\n        }\n    };\n\n    class B { // (2)\n    };\n};\n</code></pre>\n<p>By comparison, if <code>C</code> were a namespace instead of a class, the scope of the full declaration of class <code>B</code> would not extend into <code>A::getB()</code>. The only visible declaration would be the forward-declaration of <code>B</code> that I labeled <code>(1)</code> -  so <code>B()</code> would be the construction of an incomplete type there. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "35927869", "Score": "10", "CreationDate": "2016-03-10T21:41:25.937", "LastActivityDate": "2016-03-10T21:41:25.937"}, "35927073": {"ParentId": "35926728", "CommentCount": "2", "Body": "<p>The standard is explicit in mandating that the method's body is interpreted after the class that encloses it.</p>\n<p>Thus at the time of evaluating the body of <code>C::A::getB()</code>, <code>A</code>, <code>B</code> and <code>C</code> are all complete types.</p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "35927073", "Score": "5", "CreationDate": "2016-03-10T20:54:17.523", "LastActivityDate": "2016-03-10T20:54:17.523"}, "35926728": {"CommentCount": "0", "AcceptedAnswerId": "35927869", "CreationDate": "2016-03-10T20:35:35.170", "LastActivityDate": "2017-05-10T12:16:03.867", "PostTypeId": "1", "ViewCount": "985", "FavoriteCount": "2", "Title": "C++ Forward Declaring Classes Within Classes", "Id": "35926728", "Score": "17", "Body": "<p>The following simple piece of code compiles, although I don't understand why:</p>\n<pre><code>class C {\n    class B;\n\n    class A {\n        B getB() { return B(); }\n    };\n\n    class B {\n    };\n};\n\nint main(int, char**)\n{\n    return 0;\n}\n</code></pre>\n<p>If I then comment out the \"<code>class C</code>\" stuff, so that the forward declaration of <code>B</code>, the definition of <code>A</code> and the definition of <code>B</code> are no longer nested within a class, the code does not compile, since <code>B</code> is of an incomplete type:</p>\n<pre><code>main.cpp: In member function 'B A::getB()':\nmain.cpp:6: error: return type 'struct B' is incomplete\nmain.cpp:6: error: invalid use of incomplete type 'struct B'\nmain.cpp:3: error: forward declaration of 'struct B'\n</code></pre>\n<p>I understand what it means for a type to be incomplete, namely that it has not been defined yet and so the compiler can't possibly know how much space to allocate for it. But why is <code>B</code> not considered incomplete in the code above, where <code>A</code> and <code>B</code> are both declared and defined inside of <code>C</code>?</p>\n", "Tags": "<c++>", "OwnerUserId": "5689220", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_35926728_35927869_0": {"section_id": 7070, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_35926728_35927869_0": {"section_id": 6814, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_35926728_35927869_0": {"section_id": 8567, "quality": 0.9354838709677419, "length": 29}}}, "43849708": {"ParentId": "35926728", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Besides that when I've got the need to forward declare nested classes I tend to smell some bad design in my code, the trick I use is:</p>\n<pre><code>// Foo.h\nclass Foo {\n    class Bar {\n    };\n};\nclass Foobar : public Foo::Bar {};\n\n\n// Zoo.h\n/* Fwd declare */\nclass FooBar;\n</code></pre>\n", "OwnerUserId": "2772731", "LastEditorUserId": "2772731", "LastEditDate": "2017-05-10T12:16:03.867", "Id": "43849708", "Score": "0", "CreationDate": "2017-05-08T14:01:52.060", "LastActivityDate": "2017-05-10T12:16:03.867"}});