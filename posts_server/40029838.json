post_cb({"40029838": {"CommentCount": "1", "ViewCount": "39", "CreationDate": "2016-10-13T19:57:01.100", "LastActivityDate": "2016-10-13T20:18:59.027", "Title": "Deallocating object that holds mutex while locking", "AcceptedAnswerId": "40030219", "PostTypeId": "1", "Id": "40029838", "Score": "2", "Body": "<p>I ran into a problem with mutexes that are stored in instances. To give an example, I wrote this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;shared_mutex&gt;\n#include &lt;thread&gt;\n#include \"Sleep.h\"\n\nstruct Test\n{\n    std::shared_mutex mutex;\n};\n\nTest* test = new Test();\n\nvoid t1()\n{\n    std::unique_lock&lt;std::shared_mutex&gt; lock(test-&gt;mutex);\n    SLEEP(200);\n    delete test;\n    std::cout &lt;&lt; \"thread 1\" &lt;&lt; std::endl;\n}\n\nvoid t2()\n{\n    SLEEP(100);\n    std::cout &lt;&lt; \"hold\" &lt;&lt; std::endl;\n    std::shared_lock&lt;std::shared_mutex&gt; lock(test-&gt;mutex);\n    std::cout &lt;&lt; \"thread 2\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    std::thread trd1 = std::thread(&amp;t1);\n    std::thread trd2 = std::thread(&amp;t2);\n    trd1.join();\n    trd2.join();\n\n    std::cin.get();\n    return 0;\n}\n</code></pre>\n<p>What I want is that as soon as <code>test</code> is deleted and with it the mutex <em>reference</em>(?) the <em>shared_lock</em> unlocks. The goal is to make the deletion of an object, which is used by multiple threads, thread safe. As for what happens after the <em>shared_lock</em> isn't important (I am aware that I cannot use <code>test</code> there anymore).</p>\n<p>The output is:</p>\n<pre><code>hold\nthread 1\n(here should be 'thread 2')\n</code></pre>\n<p>But unfortunately, <code>t2</code> seems to deadlock.</p>\n<h3>Questions</h3>\n<ol>\n<li>Is there a way to make the <code>shared_lock</code> continue after <code>unique_lock</code> runs out of scope? (It is important that the mutex of the instance is used)</li>\n<li>While testing, I also tried replacing the <code>shared_mutex</code> with a <code>shared_timed_mutex</code>. For my surprise it causes a crash at the end of <code>t1()</code>. Why is that?</li>\n</ol>\n", "Tags": "<c++><multithreading><mutex><deadlock>", "OwnerUserId": "6235391", "AnswerCount": "1"}, "40030219": {"ParentId": "40029838", "CommentCount": "0", "Body": "<p>You're invoking Undefined Behavior by deleting the mutex held by the <code>unique_lock</code> while the lock is still using the mutex.</p>\n<p>From the language standard, description of the <code>unique_lock</code> class (\u00a7 30.4.2.2):</p>\n<blockquote>\n<p id=\"so_40029838_40030219_0\">The behavior of a program is undefined if [the mutex held by the lock] does not exist for the entire remaining lifetime of the unique_lock object.</p>\n</blockquote>\n<p>You have to destroy or release the lock before destroying the mutex (or class that contains the mutex).</p>\n", "OwnerUserId": "5231607", "PostTypeId": "2", "Id": "40030219", "Score": "3", "CreationDate": "2016-10-13T20:18:59.027", "LastActivityDate": "2016-10-13T20:18:59.027"}, "bq_ids": {"n4140": {"so_40029838_40030219_0": {"section_id": 2856, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_40029838_40030219_0": {"section_id": 2777, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_40029838_40030219_0": {"section_id": 3606, "quality": 0.6923076923076923, "length": 9}}}});