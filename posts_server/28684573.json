post_cb({"28684841": {"ParentId": "28684573", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The address will not change, but the value stored at that address will.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main()\n{\n    std::vector&lt; int &gt; vect{ 1, 2, 3, 4, 5 };\n\n    std::cout &lt;&lt; \"Before Shuffle: \" &lt;&lt; std::endl;\n    for( int i = 0; i &lt; vect.size();  ++i )\n    {\n        std::cout &lt;&lt; \"Value: \" &lt;&lt; vect.at( i ) &lt;&lt; \" Address: \" &lt;&lt;  &amp;vect.at( i ) &lt;&lt; std::endl;\n    }\n\n    auto engine = std::default_random_engine{};\n    std::shuffle( vect.begin(), vect.end(), engine);\n\n    std::cout &lt;&lt; \"After Shuffle: \" &lt;&lt; std::endl;\n    for( int i = 0; i &lt; vect.size();  ++i )\n    {\n        std::cout &lt;&lt; \"Value: \" &lt;&lt; vect.at( i ) &lt;&lt; \" Address: \" &lt;&lt;  &amp;vect.at( i ) &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Before Shuffle: \nValue: 1 Address: 0x16eb320\nValue: 2 Address: 0x16eb324\nValue: 3 Address: 0x16eb328\nValue: 4 Address: 0x16eb32c\nValue: 5 Address: 0x16eb330\nAfter Shuffle: \nValue: 3 Address: 0x16eb320\nValue: 1 Address: 0x16eb324\nValue: 5 Address: 0x16eb328\nValue: 4 Address: 0x16eb32c\nValue: 2 Address: 0x16eb330\n</code></pre>\n", "OwnerUserId": "1519323", "LastEditorUserId": "1519323", "LastEditDate": "2015-02-23T23:00:17.580", "Id": "28684841", "Score": "8", "CreationDate": "2015-02-23T22:33:48.687", "LastActivityDate": "2015-02-23T23:00:17.580"}, "28684671": {"ParentId": "28684573", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The pointer will continue to point to the same <em>location</em>, so when you shuffle, it'll point to whatever element has been moved into the location you specified.</p>\n<p>When you expand the size of a vector, all existing pointers and iterators into the vector can become invalid. When you shuffle, they continue to refer to the same location, which will (usually) contain a different value than it did before shuffling.</p>\n<p>Reducing the size of a vector will depend on exactly how you do that. One way is to create a temporary vector as a copy of the current vector, swap the two, then destroy the temporary (usually implicitly, by letting it go out of scope). If you do this, the pointers will be into the temporary, and be invalidated when it's destroyed.</p>\n<p>If you use <code>shrink_to_fit</code> that (probably) won't invalidate iterators/pointers, but may not have any effect (the standard specifies that it's a non-binding request, and doesn't say anything about it invalidating iterators/pointers).</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-02-24T00:18:49.350", "Id": "28684671", "Score": "17", "CreationDate": "2015-02-23T22:23:28.860", "LastActivityDate": "2015-02-24T00:18:49.350"}, "28684667": {"ParentId": "28684573", "CommentCount": "3", "Body": "<p>If the vector is shuffled without being resized then the pointer still points to the same location , which will probably contain a different element.</p>\n<p>If the vector is resized to be larger, then the pointer is said to be \"invalidated\" and it has the same status as an uninitialized pointer, i.e. evaluating it or trying to read through it causes undefined behaviour.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "28684667", "Score": "10", "CreationDate": "2015-02-23T22:23:24.520", "LastActivityDate": "2015-02-23T22:23:24.520"}, "28684573": {"CommentCount": "4", "AcceptedAnswerId": "28684671", "PostTypeId": "1", "LastEditorUserId": "1519323", "CreationDate": "2015-02-23T22:17:09.053", "LastActivityDate": "2015-02-24T19:23:15.700", "LastEditDate": "2015-02-24T19:23:15.700", "ViewCount": "2571", "FavoriteCount": "3", "Title": "What happens to a pointer that points to an element in a vector when I shuffle it?", "Id": "28684573", "Score": "16", "Body": "<p>I have a <code>std::vector&lt;int&gt;</code> and a pointer <code>int*</code> that points to an element in the vector. Let\u2019s say the pointer points to the third element: <code>pointer=&amp;vector.at(2)</code>. If I now shuffle the vector, will it still point to the same element (the third) or will it point the the new location where the element which used to be the third has now moved?</p>\n<p>After that, I\u2019d like to make the question a little bit more general: How do pointers and iterators to elements in a vector behave when the vector is expanded or reduced?</p>\n", "Tags": "<c++><pointers><vector>", "OwnerUserId": "3392714", "AnswerCount": "8"}, "28684914": {"ParentId": "28684573", "CommentCount": "4", "Body": "<p>In practice, a vector is a code-maintained contiguous buffer of data.  Each element is set up adjacent to the next in an array-like fashion.</p>\n<p>When elements move around, in practice, they just move around.  Pointers point to locations in that buffer, so if the element moves, in practice the pointer just ends up pointing somewhere else.</p>\n<p>However, the C++ standard is more strict.  When an iterator is invalidated, so are references and pointers to that location.  There are a number of operations that can invalidate an iterator that do not, logically, change the fact that the array is actually going to be the same buffer.  For example, if you <code>.erase</code> an element, it invalidates every iterator at that location and afterwards.</p>\n<p>In practice a pointer to the element will end up pointing at what was the \"next\" element in the list, but the standard doesn't guarantee that.</p>\n<p><code>std::shuffle</code> does not invalidate any iterators.  It just changes the values stored there.  So a pointer to the nth element will both in practice, and in theory, still point to the nth element.</p>\n<p>When the vector is expanded, if you expand it beyond <code>.capacity()</code>, all iterators are invalidated.  In practice it actually moves the data to a new location, and the pointers are now danging pointers.</p>\n<p>When you reduce (via <code>.erase(it)</code> or <code>.erase(a,b)</code>), all iterators at or after the first argument are invalidated.  This means that references and pointers to these elements are also invalidated.  In practice, they will now refer to elements \"further down the chain\" (if such elements exist), as neither <code>.erase</code> will cause your buffer to reallocate, but this is not guaranteed by the standard.</p>\n<p>There are other operations that can invalidate iterators.  <code>.shrink_to_fit()</code> can, as can <code>vector&lt;X&gt;(vec).swap(vec)</code> (the C++03 version of shrink-to-fit), and <code>.reserve()</code> and operations that grow the size beyond <code>.capacity()</code>.</p>\n<p>The operations that cause <code>.capcity()</code> to change will actually make your pointers invalid (or those that make the pointers point beyond-the-end) in practice and in theory.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "28684914", "Score": "6", "CreationDate": "2015-02-23T22:38:11.610", "LastActivityDate": "2015-02-23T22:38:11.610"}, "28684694": {"ParentId": "28684573", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_28684573_28684694_0\">If I now shuffle the vector, will it still point to the same element (the third) or will it point the the new location where the used-to-third element has moved?</p>\n</blockquote>\n<p>Shuffling elements is just a matter of copying/swapping elements through the various \"buckets\" in the array, while your pointer just points to \"that fixed position in memory\". So, it'll keep pointing to whatever stays in third position in the array.</p>\n<blockquote>\n<p id=\"so_28684573_28684694_1\">Then I like to make the question a little bit more general: How do pointer and iterators to elements in a vector behave when the vector is expanded, reduced or shuffled?</p>\n</blockquote>\n<p>Expand: all iterators/references/pointers may be invalidated.</p>\n<p>Reduced: as far as they point to elements before those removed, they are kept valid <em>unless</em> you do a <code>shrink_to_fit</code>. Iterators/pointers to elements you removed are obviously invalid.</p>\n<p>Shuffled: you are moving around stuff without causing reallocations, so iterators and references are still valid.</p>\n<p>Notice that all this stuff is typically reported in most C++ documentation sources.</p>\n<hr>\n<p>The conceptual rule to remember for vectors is that they are just a box around a dynamic array, and iterators and pointers to elements are conceptually the same thing (actually, <code>std::vector&lt;T&gt;::iterator</code> could be a <code>typedef</code> for <code>T *</code>). The same holds for references (which are pointers in disguise).</p>\n<p>If an operation may need reallocate the array (=the array needs to grow, or you explicitly requested it to shrink), then all iterators/pointers/references are going to be invalidated. If you remove elements, then pointers pointing past the \"conceptual end\" of the vector will point to invalid elements. If the size stays the same, no reallocation needs to occur.</p>\n</hr>", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2015-02-23T23:18:10.290", "Id": "28684694", "Score": "10", "CreationDate": "2015-02-23T22:24:47.560", "LastActivityDate": "2015-02-23T23:18:10.290"}, "28684971": {"ParentId": "28684573", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>As people have mentioned, the pointer is \"pointing\" to a location in memory, regardless of the contents that are there. There is actually some really interesting stuff you can do, like having an array of 5 elements, but printing out the value at position 6, even though it is not within the scope of your array. By accessing an array with something like array[5] when you have only declared it to be 5 elements long, you will end up with undefined behaviour, essentially meaning that a variety of things could happen, with each run potentially returning something completely different. See philipxy's comments below for some very useful links delving into this concept.</p>\n<p>So with that out of the way, here is a little bit of code you could test to actually see this effect. </p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    vector&lt;int&gt; values (5);\n\n    for (int i = 0; i &lt; 5; i++)\n        values[i] = i;\n\n    for (int i = 0; i &lt; 5; i++)\n        cout &lt;&lt; values[i] &lt;&lt; \" \";\n\n    //Initialise the pointer so that it is pointing at the first element in vector\n    int* pointer = &amp;values[0];\n\n    //By incrementing, we expect it to be pointing at the second element, which should be 1\n    pointer++;\n\n    cout &lt;&lt; endl &lt;&lt; \"Pointer \" &lt;&lt; *pointer &lt;&lt; endl;\n\n    //Reverse the order of the vector\n    reverse(values.begin(), values.end());\n\n    for (int i = 0; i &lt; 5; i++)\n        cout &lt;&lt; values[i] &lt;&lt; \" \";\n\n    cout &lt;&lt; endl &lt;&lt; \"Pointer \" &lt;&lt; *pointer &lt;&lt; endl; \n\n    return 0;\n}\n</code></pre>\n<p>The result of this code is:</p>\n<p><img alt=\"Results of output from code\" src=\"https://i.stack.imgur.com/1krYi.png\"/></p>\n<p>So we can see that the pointer hasn't actually changed where it is pointing, but that cell in memory has been altered, so dereferencing the pointer will yield a different result.</p>\n", "OwnerUserId": "4259466", "LastEditorUserId": "4259466", "LastEditDate": "2015-02-24T10:58:07.570", "Id": "28684971", "Score": "3", "CreationDate": "2015-02-23T22:42:06.627", "LastActivityDate": "2015-02-24T10:58:07.570"}, "28685987": {"ParentId": "28684573", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It completely depends on how \"std::vector\" is implemented. I am not sure if there are <strong>any</strong> guarantees about that.</p>\n<p>EDIT: I just learned, that the C++ standard indeed is a lot stricter than I thought (thanks to philipxy). It does specify that vector must internally behave like a C Array. See </p>\n<p><a href=\"http://herbsutter.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/\" rel=\"nofollow\">http://herbsutter.com/2008/04/07/cringe-not-vectors-are-guaranteed-to-be-contiguous/</a></p>\n<p>So forget about the rest, at least if you have an implementation which conforms to at least C++03. </p>\n<p>If you would for example implement std::vector as a linked list (not likely), then shuffling, reducing size, etc will not do anything.</p>\n<p>If the \"std::vector\" internally uses something like \"int []\" to store its elements (likely), then reshuffling the elements will probably mean that your pointer will now point to a different value then before (what Stevo tried out). <br>\nIf you resize your vector in this case, then again it depends entirely on internal implementation. A resize <strong>might</strong> allocate a new \"int []\" and copy the old content over. In this case your pointer will point to now unallocated memory, so all havoc might break loose.<br>\nIf you are lucky (depending on the implementation) then a shrinking or growing of the vector by a \"small\" amount might not do anything (your pointer is still valid).</br></br></p>\n<p>Summary: Don't do that ;-) (using pointers and afterwards modifying your container).</p>\n", "OwnerUserId": "1917520", "LastEditorUserId": "1917520", "LastEditDate": "2015-02-24T10:05:17.163", "Id": "28685987", "Score": "2", "CreationDate": "2015-02-24T00:06:10.987", "LastActivityDate": "2015-02-24T10:05:17.163"}, "28687991": {"ParentId": "28684573", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Read the <em>documentation</em> for every function you call. If you don't know when and how you may call it and what it does then why are you using it?</p>\n<p>In general you cannot rely on implementation notions like addresses or arrays and you cannot rely on a test program. You must read when an iterator is or is not invalidated for what elements for a particular container, iterator and operator.</p>\n<p><strong><code>vector::shrink_to_fit</code> invalidates all iterators</strong><br>\n<strong><code>vector::resize</code> to same or smaller invalidates exactly the iterators beyond the new size</strong><br>\n<strong><code>vector::resize</code> to larger invalidates all iterators</strong> </br></br></p>\n<p>From the C++14 standard [iterator.requirements.general]:</p>\n<blockquote>\n<p id=\"so_28684573_28687991_0\">[P]ointers are iterators. The effect of dereferencing an iterator that\n  has been invalidated is undefined.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/vector</a></p>\n<blockquote>\n<p id=\"so_28684573_28687991_1\"><code>std::vector</code> is a sequence container that encapsulates dynamic size arrays.<br>\n  The elements are stored contiguously, which means that elements can be\n  accessed not only through iterators, but also using offsets on regular\n  pointers to elements.</br></p>\n<p id=\"so_28684573_28687991_2\">iterator  \u00a0\u00a0\u00a0\u00a0RandomAccessIterator</p>\n<p id=\"so_28684573_28687991_3\">Iterator invalidation<br>\n<code>swap, std::swap</code>  \u00a0\u00a0\u00a0\u00a0Never<br>\n<code>shrink_to_fit</code>  \u00a0\u00a0\u00a0\u00a0Always<br>\n<code>resize</code>  \u00a0\u00a0\u00a0\u00a0If the vector changed capacity, all of them.\n  If not, only those after the insertion point.  </br></br></br></p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/vector/resize\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/vector/resize</a></p>\n<blockquote>\n<p id=\"so_28684573_28687991_4\">Vector capacity is never reduced when resizing to smaller size because\n  that would invalidate all iterators, rather than only the ones that\n  would be invalidated by the equivalent sequence of <code>pop_back()</code> calls.</p>\n</blockquote>\n<p><strong>After <code>vector::shuffle</code> iterators/pointers are unchanged but dereference to new values.</strong></p>\n<p>Because <code>shuffle</code> uses <code>swap</code> which leaves iterators unchanged:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/algorithm/random_shuffle\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/algorithm/random_shuffle</a></p>\n<blockquote>\n<pre><code>template&lt; class RandomIt, class URNG &gt;\nvoid shuffle( RandomIt first, RandomIt last, URNG&amp;&amp; g );\n</code></pre>\n<p id=\"so_28684573_28687991_5\">RandomIt must meet the requirements of ValueSwappable and\n  RandomAccessIterator.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/concept/Iterator\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/concept/Iterator</a></p>\n<blockquote>\n<p id=\"so_28684573_28687991_6\">Iterator is the base concept used by other iterator types:\n  InputIterator, OutputIterator, ForwardIterator, BidirectionalIterator,\n  and RandomAccessIterator. Iterators can be thought of as an\n  abstraction of pointers.\n  [...]  </p>\n<p id=\"so_28684573_28687991_7\">`- lvalues of type It satisfy Swappable\n  [...]  </p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/concept/ValueSwappable\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/concept/ValueSwappable</a></p>\n<blockquote>\n<p id=\"so_28684573_28687991_8\">Type T is ValueSwappable if<br>\n  \u00a0\u00a0\u00a0\u00a01) Type T satisfies the Iterator requirements<br>\n  \u00a0\u00a0\u00a0\u00a02) For any dereferencable object x of type T (that is, any value other\n  than the end iterator), *x satisfies the Swappable requirements.</br></br></p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/concept/Swappable\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/concept/Swappable</a></p>\n<blockquote>\n<pre><code>using std::swap;\nswap(u, t);\n</code></pre>\n<p id=\"so_28684573_28687991_9\">After the call, the value of t is the value held by u before the call,\n  and the value of u is the value held by t before the call.</p>\n</blockquote>\n", "OwnerUserId": "3404097", "LastEditorUserId": "3404097", "LastEditDate": "2015-02-24T06:12:49.363", "Id": "28687991", "Score": "5", "CreationDate": "2015-02-24T04:08:44.660", "LastActivityDate": "2015-02-24T06:12:49.363"}, "bq_ids": {"n4140": {"so_28684573_28687991_0": {"section_id": 5564, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_28684573_28687991_0": {"section_id": 5346, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_28684573_28687991_0": {"section_id": 7011, "quality": 0.7777777777777778, "length": 7}}}});