post_cb({"10455244": {"ParentId": "10455131", "CommentCount": "0", "Body": "<p>The Standard legalese is <em>ODR-used</em>: a function that is ODR-used must be defined, otherwise it is an error.</p>\n<p>The rules for marking a function as ODR-used are quite complicated, basically it means that the function is used in some way. In your second example, the function is not used, so it is unnecessary.</p>\n<p>There is one <em>special caveat</em>: a <code>virtual</code> function (unless it is pure) is <strong>always</strong> considered ODR-used.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "10455244", "Score": "2", "CreationDate": "2012-05-04T19:50:26.130", "LastActivityDate": "2012-05-04T19:50:26.130"}, "10455131": {"CommentCount": "1", "ViewCount": "423", "PostTypeId": "1", "LastEditorUserId": "54364", "CreationDate": "2012-05-04T19:41:32.040", "LastActivityDate": "2012-05-04T20:02:26.653", "Title": "Why does the linker give me an error in the virtual case but not in the non-virtual case?", "AcceptedAnswerId": "10455221", "LastEditDate": "2012-05-04T19:46:05.367", "Id": "10455131", "Score": "3", "Body": "<p>When I have something like this:</p>\n<pre><code>class A\n{\n  virtual void rat();\n};\n\nclass B : public A\n{\n  virtual void rat() { ; } //implemented!\n};\n\nint main(int argc, char **argv)\n{\n  A *a = new B;\n  delete a;\n}\n</code></pre>\n<p>I get linker errors:</p>\n<p>unless I make the base rat a pure virtual.</p>\n<p>However, when I have this:</p>\n<pre><code>class A\n{\n  public:\n  void rat();\n};\n\nint main(int argc, char **argv)\n{\n  A a;\n}\n</code></pre>\n<p>This compiles fine and doesn't give me an undefined reference link error unless I explicitly try to call the rat function in my main (<code>a.rat();</code>). What is the rule on unimplemented base class virtual functions which are, however, implemented in a derived class as in the first failing code snippet?</p>\n", "Tags": "<c++><inheritance><virtual>", "OwnerUserId": "970171", "AnswerCount": "5"}, "10455206": {"ParentId": "10455131", "CommentCount": "3", "Body": "<p>Because <code>A::rat()</code> is <em>not</em> pure virtual, it <em>must</em> have an implementation.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "10455206", "Score": "2", "CreationDate": "2012-05-04T19:47:37.060", "LastActivityDate": "2012-05-04T19:47:37.060"}, "10455221": {"ParentId": "10455131", "CommentCount": "1", "Body": "<p>When both classes define virtual functions, C++ compiler needs to build <a href=\"http://en.wikipedia.org/wiki/Virtual_method_table\" rel=\"noreferrer\">vtables</a> for both classes <code>A</code> and <code>B</code>. To build <code>A</code>'s vtable, the compiler needs <code>A::rat()</code> - that is where the reference is coming from.</p>\n<p>When <code>A</code> has no virtual functions, there are no reference to <code>A::rat</code> from anywhere, hence you do not get a compile error.</p>\n<p>As I'm sure you know, you can fix this error by making <code>A::rat</code> a pure virtual, thus providing the needed value for the vtable (in this case, the value is zero).</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "10455221", "Score": "5", "CreationDate": "2012-05-04T19:48:22.853", "LastActivityDate": "2012-05-04T19:48:22.853"}, "10455390": {"ParentId": "10455131", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Because the C++ standard requires it to be implemented.  From C++03 \u00a710.3/8:</p>\n<blockquote>\n<p id=\"so_10455131_10455390_0\">A virtual function declared in a class shall be defined, or declared pure (10.4) in that class, or both; but no diagnostic is required (3.2).</p>\n</blockquote>\n<p>So you need to either declare it pure (with the <code>= 0</code> suffix after the right parenthesis) or define its implementation.</p>\n<p>As for why you don't get an error when you don't call the function in the non-virtual case, refer to C++03 \u00a73.2/2-3 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_10455131_10455390_1\">2) An expression is <em>potentially evaluated</em> unless it appears where an integral constant expression is required\n  (see 5.19), is the operand of the <code>sizeof</code> operator (5.3.3), or is the operand of the <code>typeid</code> operator and\n  the expression does not designate an lvalue of polymorphic class type (5.2.8). An object or non-overloaded\n  function is <em>used</em> if its name appears in a potentially-evaluated expression. <strong>A virtual member function is\n  used if it is not pure.</strong> [...]</p>\n<p id=\"so_10455131_10455390_2\">3) Every program shall contain <strong>exactly one definition of every non-inline function or object that is used</strong> in that\n  program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the\n  standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8).\n  An inline function shall be defined in every translation unit in which it is used.</p>\n</blockquote>\n<p>So, in the non-virtual case, if it's not used, a definition is not required.  But in the non-pure virtual case, even if it's not explicitly referenced in code, it's still considered to be used by the standard, so its definition is required.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/4145915/a-virtual-member-function-is-used-if-it-is-not-pure\">A virtual member function is used if it is not pure?</a>.</p>\n", "OwnerUserId": "9530", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:08:57.170", "Id": "10455390", "Score": "2", "CreationDate": "2012-05-04T20:02:26.653", "LastActivityDate": "2012-05-04T20:02:26.653"}, "10455195": {"ParentId": "10455131", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Every non-pure virtual function needs to be implemented.</p>\n<pre><code>class A \n{ \n   public: void rat(); \n};\n\nint main(int argc, char **argv) \n{ \n  A a; \n}\n</code></pre>\n<p>The above code is altogether a different scenario. In a situation where you don't call a non-pure virtual function, you neither get a compiler/linker error because you are not calling it at all despite it's declaration in class definition.</p>\n<p>Now in the code below, compiler just checks whether there is a member function named <code>rat()</code> or not in <code>A</code>.</p>\n<pre><code>A a;\na.rat();   // Compiler passes. But linker bombs.\n</code></pre>\n<p>Now you should get a linker error. </p>\n", "OwnerUserId": "528724", "LastEditorUserId": "528724", "LastEditDate": "2012-05-04T19:56:35.690", "Id": "10455195", "Score": "4", "CreationDate": "2012-05-04T19:46:25.343", "LastActivityDate": "2012-05-04T19:56:35.690"}, "bq_ids": {"n4140": {"so_10455131_10455390_2": {"section_id": 7041, "quality": 0.8529411764705882, "length": 29}, "so_10455131_10455390_0": {"section_id": 7012, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_10455131_10455390_2": {"section_id": 6786, "quality": 0.8529411764705882, "length": 29}, "so_10455131_10455390_0": {"section_id": 6758, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_10455131_10455390_2": {"section_id": 8538, "quality": 0.8529411764705882, "length": 29}, "so_10455131_10455390_0": {"section_id": 8509, "quality": 0.8461538461538461, "length": 11}}}});