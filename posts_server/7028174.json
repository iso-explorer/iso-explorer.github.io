post_cb({"bq_ids": {"n4140": {"so_7028174_7028681_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 3242}}, "n3337": {"so_7028174_7028681_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 3115}}}, "7028681": {"LastActivityDate": "2011-08-11T17:46:32.893", "CreationDate": "2011-08-11T15:33:16.923", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_7028174_7028681_0\">8.3.5/ A cv-qualifier-seq shall only be part of the function type for\n  a nonstatic member function, the function type to which a pointer to\n  member refers, or the top-level function type of a function typedef\n  declaration. The effect of a cv-qualifier-seq in a function declarator\n  is not the same as adding cv-qualification on top of the function\n  type, i.e., it does not create a cv-qualified function type.</p>\n</blockquote>\n<p>If I read correctly, you <em>can</em> return a pointer to non const member in a const member function. You just won't be able to call it with a non const object.</p>\n<p>A way to forbid the calling is:</p>\n<pre><code>private:\n    struct private_ \n    {\n        void this_type_does_not_support_comparisons() {}\n    };\n\npublic:\n    typedef void (private_::*bool_type)() const;\n\n    operator bool_type() const\n    {\n        return ok_ ? &amp;private_::this_type_does_not_support_comparisons : 0;\n    }\n</code></pre>\n<p>Pointer to member functions can still be compared for equality. You have to write an <code>operator==</code> and <code>operator!=</code> for <code>Testable::bool_type</code> types which trigger an error. Easier to do with the CRTP form of the safe bool idiom since those operators become templates and thus can have an erroneous body.</p>\n<p>Example:</p>\n<pre><code>template &lt;typename T&gt;\nclass safe_bool_concept\n{\n    // Implementation detail of safe bool\nprotected:\n    ~safe_bool_concept() {}\n\npublic:\n    operator safe_bool() const\n    {\n        return static_cast&lt;const T*&gt;(this)-&gt;is_null() ? ...;\n    }\n};\n\nstruct Foo : safe_bool_concept&lt;Foo&gt;\n{\n    ...\n\nprivate:\n    friend class safe_bool_concept&lt;Foo&gt;;\n    bool is_null() const { ... }\n};\n</code></pre>\n<p>then you can do (do the same with <code>!=</code>):</p>\n<pre><code>template &lt;typename T&gt;\nvoid operator==(const safe_bool_concept&lt;T&gt;&amp; x, const safe_bool_concept&lt;T&gt;&amp;)\n{\n    x.some_private_member(); // invalid, but won't be generated\n                             // unless safe_bool classes are compared\n}\n</code></pre>\n<p>This means that the safe bool idiom should be implemented via CRTP if you want to forbid comparisons. Comparisons to zero will still work however.</p>\n<p>If you go the non-member function route, you'll have to provide <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&gt;=</code> too.</p>\n", "Id": "7028681", "LastEditDate": "2011-08-11T17:46:32.893", "ParentId": "7028174", "OwnerUserId": "373025", "PostTypeId": "2", "Score": "1", "LastEditorUserId": "373025"}, "7028721": {"LastActivityDate": "2011-08-11T15:52:55.837", "CreationDate": "2011-08-11T15:36:13.527", "CommentCount": "7", "Body": "<p>The \"safe bool idiom\" is the technical answer to the question \"i want a vehicle that is both sports car and tractor, and maybe a boat\". The practical answer is not the technical answer\u2026</p>\n<p>That said, the problem it solves is just to give a result that is convertible to <code>bool</code> but not to much of anything else (otherwise an instance of the class could be passed as actual argument where e.g. the formal argument was <code>int</code>, say). A data pointer could be convertible to <code>void*</code>. A function pointer isn't, at least formally within the C++ standard (Posix is something else, practice also).</p>\n<p>Using a member function pointer protects against accidentally calling the function, given the pointer from the safe bool operator. <del>The <code>const</code> constricts it a bit, but if fate has put someone on the path of making maximum number of silly mistakes, that person might still manage to call the do-nothing function. Instead of the <code>const</code></del> I think I would just let it have an argument of a private type, where other code cannot provide such an argument, and then it doesn't have to be a silly member function type anymore.</p>\n<p>Can look like this:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass Foo\n{\nprivate:\n    enum PrivateArg {};\n    typedef void (*SafeBool)( PrivateArg );\n    static void safeTrue( PrivateArg ) {}\n\n    bool    state_;\n\npublic:\n    Foo( bool state ): state_( state ) {}\n\n    operator SafeBool () const\n    { return (state_? &amp;safeTrue : 0); }\n};\n\nint main()\n{\n    if( Foo( true ) ) { printf( \"true\\n\" ); }\n    if( Foo( false ) ) { printf( \"false\\n\" ); } // No output.\n\n    //int const x1 = Foo( false );        // No compilado!\n    //void* const x2 = Foo( false );      // No compilado!\n}\n</code></pre>\n<p>Of course, the practical answer is instead something like this:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nclass Foo\n{\nprivate:\n    bool    isEmpty_;\n\npublic:\n    Foo( bool asInitiallyEmpty )\n        : isEmpty_( asInitiallyEmpty )\n    {}\n\n    bool isEmpty() const { return isEmpty_; }\n};\n\nint main()\n{\n    if( Foo( true ).isEmpty() ) { printf( \"true\\n\" ); }\n    if( Foo( false ).isEmpty() ) { printf( \"false\\n\" ); } // No output.\n\n    //bool const x0 = Foo( false );       // No compilado!\n    //int const x1 = Foo( false );        // No compilado!\n    //void* const x2 = Foo( false );      // No compilado!\n}\n</code></pre>\n<p>Summary wrt. questions asked:</p>\n<ul>\n<li>How come the bool_type (the typedef) and this_type_does_not_support_comparisons are const?</li>\n</ul>\n<p>Somebody didn't quite understand what they coded. Or <em>maybe</em> they intended to restrict the ability to call, a little. But then, pretty futile measure.</p>\n<ul>\n<li>Nobody is supposed to actually call the member function through the return pointer anyway, right?</li>\n</ul>\n<p>Right.</p>\n<ul>\n<li>Is const necessary here?</li>\n</ul>\n<p>No.</p>\n<ul>\n<li>Would operator bool_type (the member function) violate const-correctness otherwise?</li>\n</ul>\n<p>No.</p>\n<p>Cheers &amp; hth.,</p>\n", "Id": "7028721", "LastEditDate": "2011-08-11T15:52:55.837", "ParentId": "7028174", "OwnerUserId": "464581", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "464581"}, "7028174": {"CreationDate": "2011-08-11T15:00:45.370", "LastActivityDate": "2011-08-11T17:46:32.893", "Id": "7028174", "AcceptedAnswerId": "7028721", "ViewCount": "654", "Score": "9", "Title": "const-correctness and the safe bool idiom", "CommentCount": "3", "Body": "<p>I have another question related to the safe bool idiom:</p>\n<pre><code>typedef void (Testable::*bool_type)() const;             // const necessary?\nvoid this_type_does_not_support_comparisons() const {}   // const necessary?\n\noperator bool_type() const\n{\n    return ok_ ? &amp;Testable::this_type_does_not_support_comparisons : 0;\n}\n</code></pre>\n<p>How come the <code>bool_type</code> (the typedef) and <code>this_type_does_not_support_comparisons</code> are <code>const</code>?\nNobody is supposed to actually <em>call</em> the member function through the return pointer anyway, right?\nIs <code>const</code> necessary here? Would <code>operator bool_type</code> (the member function) violate const-correctness otherwise? </p>\n", "Tags": "<c++><const><member-function-pointers><const-correctness><safe-bool-idiom>", "FavoriteCount": "0", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "252000"}});