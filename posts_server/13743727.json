post_cb({"bq_ids": {"n4140": {"so_13743727_13743727_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 5971}, "so_13743727_13743727_1": {"length": 18, "quality": 0.75, "section_id": 7187}, "so_13743727_13743727_3": {"length": 30, "quality": 0.9375, "section_id": 5978}, "so_13743727_13743727_0": {"length": 12, "quality": 0.8, "section_id": 7188}}, "n3337": {"so_13743727_13743727_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 5739}, "so_13743727_13743727_1": {"length": 21, "quality": 0.875, "section_id": 6931}, "so_13743727_13743727_3": {"length": 30, "quality": 0.9375, "section_id": 5746}, "so_13743727_13743727_0": {"length": 12, "quality": 0.8, "section_id": 6932}}, "n4659": {"so_13743727_13743727_2": {"length": 7, "quality": 0.5833333333333334, "section_id": 7470}, "so_13743727_13743727_1": {"length": 18, "quality": 0.75, "section_id": 8695}, "so_13743727_13743727_3": {"length": 30, "quality": 0.9375, "section_id": 7477}}}, "13743727": {"ViewCount": "228", "Body": "<p>I didn't know this before, but <a href=\"https://stackoverflow.com/questions/13743357/location-of-members-of-an-object/13743395#comment18884848_13743395\">it turns out</a> that:</p>\n<blockquote>\n<p id=\"so_13743727_13743727_0\"><code>[C++11: 3.7.5]:</code> The storage duration of member subobjects, base class subobjects and array elements is that of their complete object (1.8).</p>\n</blockquote>\n<p>That means that <code>x-&gt;a</code> in the example below has dynamic storage duration.</p>\n<p>I'm wondering whether there are any elsewhere-defined semantics that make reference to storage duration that imbue member <code>a</code> with different behaviour between object <code>*x</code> and <code>y</code>? An example would be the rules governing object lifetime.</p>\n<pre><code>struct T\n{\n   int a;\n};\n\nint main()\n{\n   std::unique_ptr&lt;T&gt; x(new T);\n   T y;\n}\n</code></pre>\n<p>And how about if <code>T</code> were non-POD (and other kinds of UDTs)?</p>\n<p>In short, my lizard brain expects any declaration looking like <code>int a;</code> to have automatic (or static) storage duration, and I wonder whether any standard wording accidentally expects this too.</p>\n<hr>\n<p><strong>Update:</strong></p>\n<p>Here's an example:</p>\n<blockquote>\n<p id=\"so_13743727_13743727_1\"><code>[C++11: 3.7.4.3/4]:</code> [..] Alternatively, an implementation may have strict pointer safety, in which case a pointer value that is not a safely-derived pointer value is an invalid pointer value <strong>unless the referenced complete object is of dynamic storage duration</strong> [..]</p>\n</blockquote>\n<p>On the surface of it, I wouldn't expect the semantics to differ between my <code>x-&gt;a</code> and my <code>y.a</code>, but it's clear that there are areas, that are not obviously related to object lifetime, where they do.</p>\n<p>I'm also concerned about lambda capture rules, which explicitly state \"with automatic storage duration\" in a number of places, e.g.:</p>\n<blockquote>\n<p id=\"so_13743727_13743727_2\"><code>[C++11: 5.1.2/11]:</code> If a <em>lambda-expression</em> has an associated <em>capture-default</em> and its <em>compound-statement</em> odr-uses (3.2) <code>this</code> or <strong>a variable with automatic storage duration</strong> [..]</p>\n<p id=\"so_13743727_13743727_3\"><code>[C++11: 5.1.2/18]:</code> Every occurrence of <code>decltype((x))</code> where <code>x</code> is a possibly parenthesized <em>id-expression</em> that names <strong>an entity of automatic storage duration</strong> is treated as if <code>x</code> were transformed into an access to a corresponding data member of the closure type that would have been declared if <code>x</code> were an odr-use of the denoted entity.</p>\n</blockquote>\n<p>and others.</p>\n</hr>", "AcceptedAnswerId": "13743932", "Title": "Are there any unintuitive side-effects of member subobjects inheriting storage duration?", "CreationDate": "2012-12-06T12:32:21.847", "Id": "13743727", "CommentCount": "16", "LastEditDate": "2017-05-23T10:34:57.367", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-06T14:11:46.093", "Score": "7", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}, "13743932": {"Id": "13743932", "PostTypeId": "2", "Body": "<p>No. This storage duration inheritance is what makes subobjects work. Doing anything else would simply be quite impossible. Else, you could not design any type that could be allocated both statically and dynamically.</p>\n<p>Simply put, any violation of this rule would simply break everything.</p>\n", "LastActivityDate": "2012-12-06T12:44:58.943", "CommentCount": "7", "CreationDate": "2012-12-06T12:44:58.943", "ParentId": "13743727", "Score": "2", "OwnerUserId": "298661"}});