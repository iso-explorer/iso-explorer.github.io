post_cb({"42588542": {"ViewCount": "144", "Body": "<p>You'll find the following text in <code>[basic.def.odr]/2</code> in C++11:</p>\n<blockquote>\n<p id=\"so_42588542_42588542_0\">A virtual member function is odr-used if it is not pure. <strong>A\n  non-overloaded function whose name appears as a potentially-evaluated\n  expression</strong> or a member of a set of candidate functions, if selected by\n  overload resolution when referred to from a potentially-evaluated\n  expression, <strong>is odr-used, unless it is a pure virtual function and its\n  name is not explicitly qualified</strong>.</p>\n</blockquote>\n<p>According to highlighted text above, it's possible to invoke a pure virtual function as a potentially-evaluated expression, without its name being explicitly qualified. <a href=\"https://stackoverflow.com/a/2089176/1042389\">This answer</a> by <a href=\"https://stackoverflow.com/users/12711/michael-burr\">Michael Burr</a> seems to show the only way, one can call a pure virtual function, and it has to use a qualified name.</p>\n<p>PS: For those wondering why am I still referring the question to the C++11 Standard, please see my prior question <a href=\"https://stackoverflow.com/q/42534495/4463557\">here</a>.</p>\n", "AcceptedAnswerId": "42588753", "Title": "How can a pure-virtual function be invoked without its name being explicitly qualified?", "CreationDate": "2017-03-03T21:15:10.560", "Id": "42588542", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:00:13.920", "LastEditorUserId": "-1", "LastActivityDate": "2017-03-05T17:15:52.127", "Score": "3", "OwnerUserId": "4463557", "Tags": "<c++><c++11><language-lawyer><virtual-functions><one-definition-rule>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42588542_42588542_0": {"length": 21, "quality": 0.6774193548387096, "section_id": 7040}}, "n3337": {"so_42588542_42588542_0": {"length": 31, "quality": 1.0, "section_id": 6785}}, "n4659": {"so_42588542_42588542_0": {"length": 21, "quality": 0.6774193548387096, "section_id": 8537}}}, "42588753": {"Id": "42588753", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42588542_42588753_0\">How can a pure-virtual function be invoked without its name being explicitly qualified?</p>\n</blockquote>\n<p>That's the ordinary case. To borrow Yakk's example from the comments:</p>\n<pre><code>struct Foo {\n    virtual void bar() = 0;\n};\n\nvoid quux(Foo* f) {\n    f-&gt;bar();\n}\n</code></pre>\n<p>Here the pure virtual function <code>Foo::bar</code> is being invoked without explicit qualification. Therefore, according to the quoted paragraph, <code>Foo::bar</code> is <strong>not</strong> odr-used, and therefore it doesn't need to be defined. Instead, its non-pure overriders in derived classes are odr-used, and they are the functions that need to be defined.</p>\n<p>But if you explicitly qualify a call to a pure virtual function, then you cause it to become odr-used, and it requires a definition. This most commonly happens with pure virtual destructors, because a derived class destructor always invokes base class destructors <em>as though they were fully qualified</em>. That's why pure virtual destructors need to be defined.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-03-05T17:15:52.127", "Score": "3", "CreationDate": "2017-03-03T21:30:03.553", "ParentId": "42588542", "CommentCount": "6", "OwnerUserId": "481267", "LastEditDate": "2017-03-05T17:15:52.127"}});