post_cb({"15412927": {"ParentId": "15412762", "PostTypeId": "2", "CommentCount": "6", "Body": "<pre><code>complx two = complx(3,4);\n</code></pre>\n<p>This is a <em>copy-initialization</em>. The particular semantics for this initializer are covered by this rule:</p>\n<blockquote>\n<p id=\"so_15412762_15412927_0\">If the initialization is direct-initialization, or <strong>if it is copy-initialization where the cv-unqualified version of the source type is the same class as [...] the class of the destination</strong>, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). [...]</p>\n</blockquote>\n<p>That is, a copy-initialization where the source type is the same as the destination type behaves like a direct-initialization. So that makes the declaration equivalent to:</p>\n<pre><code>complx two(complx(3,4));\n</code></pre>\n<p>This constructs a temporary <code>complx</code> object and then uses the copy/move constructor to construct <code>two</code>.</p>\n<p>However, this copy/move may be elided:</p>\n<blockquote>\n<p id=\"so_15412762_15412927_1\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type, the copy/move operation can be omitted by constructing the temporary object directly into the target of the omitted copy/move</p>\n</blockquote>\n<p>However, the copy constructor must still be accessible, as <em>though</em> it were being called.</p>\n<p>Can the two initializations be distinguished? Assuming the copy/move is valid, not reliably, no. If the compiler does elide the copy in the copy-initialization or if the copy is well behaved and doesn't have any extra side effects, then both will behave exactly the same. If it does not elide the copy and the copy has some extra side effects, then you will notice a difference.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-03-14T15:24:15.760", "Id": "15412927", "Score": "4", "CreationDate": "2013-03-14T15:07:37.377", "LastActivityDate": "2013-03-14T15:24:15.760"}, "15412835": {"ParentId": "15412762", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>First is known as <strong>Direct Initialization</strong>.<br>\nIt simply calls the best match constructor.     </br></p>\n<p>Second case is known as <strong>Copy initialization</strong>.<br>\nit creates a object of type <code>Complx</code> and then copies that object to create the <code>two</code> object.<br>\nso it involves call to the constructor followed by a copy constructor call.      </br></br></p>\n<p>The compilers are allowed to elide the copy constructor call in general whenever they can(<em>there are special conditions, the code example meet those conditions</em>). But none of the optimizations are guaranteed and they depend on the efficiency of the compiler implementation so the copy constructor needs to be available for second example to compile.</p>\n<blockquote>\n<p id=\"so_15412762_15412835_0\"><strong>Is it possible to distinguish the two types of initializations ?</strong> </p>\n</blockquote>\n<p>Yes, second example will not compile unless a copy constructor is available and accessible.  </p>\n<hr>\n<p><strong>Good Read:</strong> </p>\n<p><strong><a href=\"http://www.gotw.ca/gotw/036.htm\" rel=\"nofollow\">GotW #36: Initialization</a></strong></p>\n</hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2013-03-14T15:14:33.913", "Id": "15412835", "Score": "3", "CreationDate": "2013-03-14T15:04:09.230", "LastActivityDate": "2013-03-14T15:14:33.913"}, "15412823": {"ParentId": "15412762", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>In C++ you can distinguish the two types of initializations by implementing a move constructor or a copy constructor like this</p>\n<pre><code>struct complx\n\n{\n  complx(complx &amp;&amp; aOther){} // &lt;- move constructor (C++11)\n  complx(const complx &amp; aOther){} // &lt;- copy constructor (C++03)\n  complx(float a, float b) {} // &lt;- normal constructor\n};\n</code></pre>\n<p>Your first line of code will call the normal constructor.\nYour second line of code is called copy initialization with an rvalue, and will call the move constructor in C++11 and the copy constructor in C++03. Note that in C++03, <code>complx(complx &amp;&amp; aOther){}</code> is not recognized (invalid syntax), and should be removed.</p>\n", "OwnerUserId": "2135355", "LastEditorUserId": "2135355", "LastEditDate": "2013-03-14T15:20:40.243", "Id": "15412823", "Score": "0", "CreationDate": "2013-03-14T15:03:47.113", "LastActivityDate": "2013-03-14T15:20:40.243"}, "bq_ids": {"n4140": {"so_15412762_15412927_0": {"section_id": 3296, "quality": 0.8888888888888888, "length": 32}, "so_15412762_15412927_1": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_15412762_15412927_0": {"section_id": 3166, "quality": 0.8888888888888888, "length": 32}, "so_15412762_15412927_1": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_15412762_15412927_0": {"section_id": 4058, "quality": 0.8888888888888888, "length": 32}, "so_15412762_15412927_1": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}}}, "15412762": {"CommentCount": "6", "AcceptedAnswerId": "15412927", "CreationDate": "2013-03-14T15:00:33.287", "LastActivityDate": "2013-03-14T15:24:15.760", "PostTypeId": "1", "ViewCount": "109", "FavoriteCount": "0", "Title": "Will I get a copy or assignment with this initialization?", "Id": "15412762", "Score": "3", "Body": "<p>Compare these two initialization methods in C++ for a trivial complex number class.</p>\n<pre><code>complx one(1,3);\ncomplx two = complx(3,4);\n</code></pre>\n<p>In the second case, will I get a constructor followed by an assignment, followed by a copy, or just the constructor? </p>\n<p>Is it possible to distinguish the two types of initializations ?</p>\n", "Tags": "<c++>", "OwnerUserId": "78374", "AnswerCount": "3"}});