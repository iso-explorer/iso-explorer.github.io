post_cb({"43956125": {"CommentCount": "6", "CreationDate": "2017-05-13T17:40:22.930", "PostTypeId": "1", "AcceptedAnswerId": "44221983", "LastEditorUserId": "1413395", "LastActivityDate": "2017-05-27T22:01:18.407", "LastEditDate": "2017-05-27T18:56:31.550", "ViewCount": "175", "FavoriteCount": "1", "Title": "std::bitset hash function algorithm", "Id": "43956125", "Score": "1", "Body": "<p>Does anybody know what algorithm thw hash function for bitset is using,</p>\n<p>this is from website : <a href=\"http://en.cppreference.com/w/cpp/utility/bitset/hash\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/bitset/hash</a> </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;functional&gt;\n\nint main()\n{\n    std::bitset&lt;4&gt; b1(1);\n    std::bitset&lt;4&gt; b2(2);\n    std::bitset&lt;4&gt; b3(b2);\n    std::bitset&lt;4&gt; b4(8);\n    std::cout&lt;&lt;b4&lt;&lt;'\\n';\n    std::hash&lt;std::bitset&lt;4&gt;&gt; hash_fn;\n\n    size_t h1 = hash_fn(b1);\n    size_t h2 = hash_fn(b2);\n    size_t h3 = hash_fn(b4);\n\n    std::cout &lt;&lt; h1 &lt;&lt; '\\n';\n    std::cout &lt;&lt; h2 &lt;&lt; '\\n';\n    std::cout &lt;&lt; h3 &lt;&lt; '\\n';\n}\n</code></pre>\n<p>and the output is </p>\n<pre><code>1000\n4334672815104069193\n16667047557902998627\n2258353126044249582\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/bitset/hash\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/bitset/hash</a></p>\n<p>Also why doesn't it convert the bits to unsigend long and generate a hash value? </p>\n", "Tags": "<c++><bitset>", "OwnerUserId": "2562775", "AnswerCount": "1"}, "44221983": {"ParentId": "43956125", "CommentCount": "3", "Body": "<p>As <a href=\"https://stackoverflow.com/questions/43956125/#comment74945542_43956125\">noted by Igor</a>, C++ standard does not specify algorithm, it <a href=\"http://eel.is/c++draft/bitset#hash\" rel=\"nofollow noreferrer\">only</a> <a href=\"http://eel.is/c++draft/unord.hash\" rel=\"nofollow noreferrer\">requires</a> that hash value depends only on object and will be same for the duration of the program: <a href=\"http://eel.is/c++draft/hash.requirements\" rel=\"nofollow noreferrer\">http://eel.is/c++draft/hash.requirements</a></p>\n<blockquote>\n<p id=\"so_43956125_44221983_0\">20.5.3.4 Hash requirements [hash.requirements]\n  1  A type H meets the Hash requirements if:</p>\n<ul>\n<li>(1.1) it is a function object type,</li>\n<li>(1.2) it satisfies the requirements of CopyConstructible and Destructible, and</li>\n<li>(1.3)\n  the expressions shown in Table 29 are valid and have the indicated semantics.</li>\n</ul>\n<p id=\"so_43956125_44221983_1\">2 Given Key is an argument type for function objects of type H, in Table 29 h is a value of type (possibly const) H, u is an lvalue of type Key, and k is a value of a type convertible to (possibly const) Key.</p>\n<p id=\"so_43956125_44221983_2\">Table 29 \u2014 Hash requirements</p>\n<ul>\n<li>Expression   Return type Requirement</li>\n<li>h(k)  size_\u00adt The value returned shall depend only on the argument k for the duration of the program. [\u2009Note: Thus all evaluations of the\n  expression h(k) with the same value for k yield the same result for a\n  given execution of the program. \u2014\u2009end note\u2009] [\u2009Note: For two different\n  values t1 and t2, the probability that h(t1) and h(t2) compare equal\n  should be very small, approaching 1.0 /\n  numeric_\u00adlimits\u200b::\u200bmax(). \u2014\u2009end note\u2009]</li>\n<li>h(u)  size_\u00adt Shall not modify u.</li>\n</ul>\n</blockquote>\n<p>Gcc's libstdc++ implementation of bitset uses std::hash: <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/debug/bitset\" rel=\"nofollow noreferrer\">https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/debug/bitset</a></p>\n<pre><code>#if __cplusplus &gt;= 201103L\n  // DR 1182.\n  /// std::hash specialization for bitset.\n  template&lt;size_t _Nb&gt;\n    struct hash&lt;__debug::bitset&lt;_Nb&gt;&gt;\n    : public __hash_base&lt;size_t, __debug::bitset&lt;_Nb&gt;&gt;\n    {\n      size_t\n      operator()(const __debug::bitset&lt;_Nb&gt;&amp; __b) const noexcept\n      { return std::hash&lt;_GLIBCXX_STD_C::bitset&lt;_Nb&gt;&gt;()(__b._M_base()); }\n    };\n#endif\n</code></pre>\n<p><a href=\"https://github.com/gcc-mirror/gcc/blob/1cb6c2eb3b8361d850be8e8270c597270a1a7967/libstdc%2B%2B-v3/include/std/bitset#L1561\" rel=\"nofollow noreferrer\">https://github.com/gcc-mirror/gcc/blob/1cb6c2eb3b8361d850be8e8270c597270a1a7967/libstdc%2B%2B-v3/include/std/bitset#L1561</a></p>\n<pre><code>  // DR 1182.\n  /// std::hash specialization for bitset.\n  template&lt;size_t _Nb&gt;\n    struct hash&lt;_GLIBCXX_STD_C::bitset&lt;_Nb&gt;&gt;\n    : public __hash_base&lt;size_t, _GLIBCXX_STD_C::bitset&lt;_Nb&gt;&gt;\n    {\n      size_t\n      operator()(const _GLIBCXX_STD_C::bitset&lt;_Nb&gt;&amp; __b) const noexcept\n      {\n        const size_t __clength = (_Nb + __CHAR_BIT__ - 1) / __CHAR_BIT__;\n        return std::_Hash_impl::hash(__b._M_getdata(), __clength);\n      }\n    };\n</code></pre>\n<p>LLVM's libcxx uses own implementation for bitset, xoring all words: <a href=\"https://github.com/llvm-mirror/libcxx/blob/2c4b8af9aada61d83610330416eb8a39a8aa5494/include/bitset#L417\" rel=\"nofollow noreferrer\">https://github.com/llvm-mirror/libcxx/blob/2c4b8af9aada61d83610330416eb8a39a8aa5494/include/bitset#L417</a></p>\n<pre><code>template &lt;size_t _Size&gt;\nstruct _LIBCPP_TEMPLATE_VIS hash&lt;bitset&lt;_Size&gt; &gt;\n    : public unary_function&lt;bitset&lt;_Size&gt;, size_t&gt;\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const bitset&lt;_Size&gt;&amp; __bs) const _NOEXCEPT\n        {return __bs.__hash_code();}\n};\n\ntemplate &lt;size_t _N_words, size_t _Size&gt;\ninline\nsize_t\n__bitset&lt;_N_words, _Size&gt;::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    for (size_type __i = 0; __i &lt; _N_words; ++__i)\n        __h ^= __first_[__i];\n    return __h;\n}\n</code></pre>\n<p>and simpler variant for 1 word bitset:</p>\n<pre><code>inline\nsize_t\n__bitset&lt;1, _Size&gt;::__hash_code() const _NOEXCEPT\n{\n    return __first_;\n}\n</code></pre>\n", "OwnerUserId": "196561", "PostTypeId": "2", "Id": "44221983", "Score": "4", "CreationDate": "2017-05-27T22:01:18.407", "LastActivityDate": "2017-05-27T22:01:18.407"}, "bq_ids": {"n4140": {"so_43956125_44221983_1": {"section_id": 6288, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_43956125_44221983_1": {"section_id": 6048, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_43956125_44221983_1": {"section_id": 7795, "quality": 0.9523809523809523, "length": 20}}}});