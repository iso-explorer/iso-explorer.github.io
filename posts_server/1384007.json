post_cb({"bq_ids": {"n4140": {"so_1384007_1384044_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}, "so_1384007_1384044_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 593}, "so_1384007_1384044_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 594}, "so_1384007_1384044_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 3296}}, "n3337": {"so_1384007_1384044_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 583}, "so_1384007_1384044_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}, "so_1384007_1384044_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 3166}, "so_1384007_1384044_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 584}}, "n4659": {"so_1384007_1384044_2": {"length": 18, "quality": 1.0, "section_id": 616}, "so_1384007_1384044_4": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}, "so_1384007_1384044_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 4058}, "so_1384007_1384044_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 617}}}, "1384044": {"Id": "1384044", "PostTypeId": "2", "Body": "<p>You do copy initialization, and the candidate functions that are considered to do the conversions in the conversion sequence are conversion functions and converting constructors. These are in your case</p>\n<pre><code>B(const A&amp;)\noperator B() \n</code></pre>\n<p>Now, that are the way you declare them. Overload resolution abstracts away from that, and transforms each candidate into a list of parameters that correspond to the arguments of the call. The parameters are</p>\n<pre><code>B(const A&amp;)\nB(A&amp;)\n</code></pre>\n<p>The second one is because the conversion function is a member function. The <code>A&amp;</code> is the so-called implicit object parameter that's generated when a candidate is a member function. Now, the argument has type <code>A</code>. When binding the implicit object parameter, a non-const reference <em>can</em> bind to an rvalue. So, another rule says that when you have two viable functions whose parameters are references, then the candidate having the <em>fewest</em> const qualification will win. That's why your conversion function wins. Try making <code>operator B</code> a const member function. You will notice an ambiguity. </p>\n<blockquote>\n<p id=\"so_1384007_1384044_0\">From an object-oriented philosophical standpoint, is this the way the code should behave? Who knows more about how an A object should become a B object, A or B? According to C++, the answer is A -- is there anything in object-oriented practice that suggests this should be the case? To me personally, it would make sense either way, so I'm interested to know how the choice was made.</p>\n</blockquote>\n<p>For the record, if you make the conversion function a const member function, then GCC will chose the constructor (so GCC seems to think that <code>B</code> has more business with it?). Switch to pedantic mode (<code>-pedantic</code>) to make it cause a diagnostic.</p>\n<hr>\n<p>Standardese, <code>8.5/14</code></p>\n<blockquote>\n<p id=\"so_1384007_1384044_1\">Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3).</p>\n</blockquote>\n<p>And <code>13.3.1.4</code></p>\n<blockquote>\n<p id=\"so_1384007_1384044_2\">Overload resolution is used to select the user-defined conversion to be invoked. Assuming that \"cv1 T\" is the type of the object being initialized, with T a class type, the candidate functions are selected as follows:</p>\n<ul>\n<li>The converting constructors (12.3.1) of T are candidate functions.</li>\n<li>When the type of the initializer expression is a class type \"cv S\", the conversion functions of S and its base classes are considered. Those that are not hidden within S and yield a type whose cv-unqualified version is the same type as T or is a derived class thereof are candidate functions. Conversion functions that return \"reference to X\" return lvalues of type X and are therefore considered to yield X for this process of selecting candidate functions.</li>\n</ul>\n<p id=\"so_1384007_1384044_3\">In both cases, the argument list has one argument, which is the initializer expression. [Note: this argument will be compared against the first parameter of the constructors and against the implicit object parameter of the conversion functions. ]</p>\n</blockquote>\n<p>And <code>13.3.3.2/3</code></p>\n<blockquote id=\"so_1384007_1384044_4\">\n<ul>\n<li>Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if [...] S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers is more cv-qualified than the type to which the reference initialized by S1 refers.</li>\n</ul>\n</blockquote>\n</hr>", "LastEditorUserId": "759866", "LastActivityDate": "2013-12-23T16:07:14.233", "Score": "42", "CreationDate": "2009-09-05T19:05:22.580", "ParentId": "1384007", "CommentCount": "4", "OwnerUserId": "34509", "LastEditDate": "2013-12-23T16:07:14.233"}, "1384007": {"ViewCount": "10716", "Body": "<p>Reading some questions here on SO about conversion operators and constructors got me thinking about the interaction between them, namely when there is an 'ambiguous' call. Consider the following code:</p>\n<pre><code>class A;\n\nclass B { \n      public: \n         B(){} \n\n         B(const A&amp;) //conversion constructor\n         { \n              cout &lt;&lt; \"called B's conversion constructor\" &lt;&lt; endl; \n         } \n};\n\nclass A { \n      public: \n         operator B() //conversion operator\n         { \n              cout &lt;&lt; \"called A's conversion operator\" &lt;&lt; endl; \n              return B(); \n         } \n};\n\nint main()\n{\n    B b = A(); //what should be called here? apparently, A::operator B()\n    return 0;\n}\n</code></pre>\n<p>The above code displays \"called A's conversion operator\", meaning that the conversion operator is called as opposed to the constructor. If you remove/comment out the <code>operator B()</code> code from <code>A</code>, the compiler will happily switch over to using the constructor instead (with no other changes to the code). </p>\n<p>My questions are:</p>\n<ol>\n<li>Since the compiler doesn't consider <code>B b = A();</code> to be an ambiguous call, there must be some type of precedence at work here. Where exactly is this precedence established? (a reference/quote from the C++ standard would be appreciated)</li>\n<li>From an object-oriented philosophical standpoint, is this the way the code should behave? Who knows more about how an <code>A</code> object should become a <code>B</code> object, <code>A</code> or <code>B</code>? According to C++, the answer is <code>A</code> -- is there anything in object-oriented practice that suggests this should be the case? To me personally, it would make sense either way, so I'm interested to know how the choice was made.</li>\n</ol>\n<p>Thanks in advance</p>\n", "AcceptedAnswerId": "1384044", "Title": "Conversion constructor vs. conversion operator: precedence", "CreationDate": "2009-09-05T18:47:32.170", "Id": "1384007", "CommentCount": "2", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2010-04-10T18:32:56.707", "LastEditorUserId": "164901", "LastActivityDate": "2013-12-23T16:07:14.233", "Score": "54", "OwnerUserId": "157098", "Tags": "<c++><constructor><operators><type-conversion><conversion-operator>", "AnswerCount": "2"}, "1384087": {"Id": "1384087", "PostTypeId": "2", "Body": "<p>It seems MSVS2008 has its own opinion about constructor selection: it calls copy constructor in B regardless of constness of A's operator. So be careful here even while standard specifies the correct behavior.</p>\n<p>I thought MSVS just search for suitable constructor before conversions operator, but then found that it starts calling A's operator B() if you remove const word from B's constructor. Probably it has some special behavior for temporaries, because the following code still calls B's constructor:</p>\n<pre><code>A a;\n\nB b = a;\n</code></pre>\n", "LastEditorUserId": "168947", "LastActivityDate": "2009-09-05T19:52:17.680", "Score": "3", "CreationDate": "2009-09-05T19:27:57.620", "ParentId": "1384007", "CommentCount": "0", "OwnerUserId": "168947", "LastEditDate": "2009-09-05T19:52:17.680"}});