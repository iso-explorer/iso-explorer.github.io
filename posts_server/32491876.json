post_cb({"32491876": {"CommentCount": "4", "ViewCount": "160", "PostTypeId": "1", "LastEditorUserId": "5071902", "CreationDate": "2015-09-10T01:59:37.390", "LastActivityDate": "2015-09-11T07:11:16.313", "Title": "why this user defined conversion sequence is not prohibited?", "FavoriteCount": "1", "LastEditDate": "2015-09-10T03:14:31.867", "Id": "32491876", "Score": "3", "Body": "<p>According to c++ standard, </p>\n<p>[over.best.ics]</p>\n<blockquote>\n<p id=\"so_32491876_32491876_0\">4 However, if the target is</p>\n<p id=\"so_32491876_32491876_1\">(4.1) \u2014 the first parameter of a constructor or</p>\n<p id=\"so_32491876_32491876_2\">(4.2) \u2014 the implicit object parameter of a user-defined conversion function</p>\n<p id=\"so_32491876_32491876_3\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0and the constructor or user-defined conversion function is a candidate by</p>\n<p id=\"so_32491876_32491876_4\">(4.3) \u2014 13.3.1.3, when the argument is the temporary in the second step of a class copy-initialization, or</p>\n<p id=\"so_32491876_32491876_5\">(4.4) \u2014 13.3.1.4, 13.3.1.5, or 13.3.1.6 (in all cases),</p>\n<p id=\"so_32491876_32491876_6\">user-defined conversion sequences are not considered. [ Note: These rules prevent more than one user-defined\n  conversion from being applied during overload resolution, thereby avoiding infinite recursion. \u2014 end note ]</p>\n</blockquote>\n<pre><code>struct Y { Y(int); };\nstruct A{operator Y();};\nY y1 = A(); //[[ 1 ]]but this compiles, why this use-defined conversion sequence is considered?\n</code></pre>\n<p>in line [[ 1 ]], it's obvious that a \"A-&gt;A-&gt;Y-&gt;Y\" user defined conversion \nsequence is used here. A-&gt;A  is identity conversion A-&gt;Y is conversion function, Y-&gt;Y is identity conversion.</p>\n", "Tags": "<c++><type-conversion>", "OwnerUserId": "1986903", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32491876_32491876_6": {"section_id": 609, "quality": 0.8260869565217391, "length": 19}, "so_32491876_32491876_3": {"section_id": 609, "quality": 1.0, "length": 5}, "so_32491876_32502276_1": {"section_id": 611, "quality": 0.9565217391304348, "length": 22}, "so_32491876_32502276_0": {"section_id": 611, "quality": 1.0, "length": 13}, "so_32491876_32491876_2": {"section_id": 609, "quality": 1.0, "length": 6}, "so_32491876_32491876_4": {"section_id": 609, "quality": 0.875, "length": 7}}, "n3337": {"so_32491876_32491876_3": {"section_id": 599, "quality": 1.0, "length": 5}, "so_32491876_32502276_0": {"section_id": 601, "quality": 1.0, "length": 13}, "so_32491876_32491876_4": {"section_id": 599, "quality": 0.875, "length": 7}, "so_32491876_32502276_1": {"section_id": 601, "quality": 0.9565217391304348, "length": 22}, "so_32491876_32491876_2": {"section_id": 629, "quality": 1.0, "length": 6}}, "n4659": {"so_32491876_32491876_6": {"section_id": 635, "quality": 0.8260869565217391, "length": 19}, "so_32491876_32491876_3": {"section_id": 586, "quality": 1.0, "length": 5}, "so_32491876_32502276_1": {"section_id": 637, "quality": 0.9565217391304348, "length": 22}, "so_32491876_32502276_0": {"section_id": 637, "quality": 1.0, "length": 13}, "so_32491876_32491876_2": {"section_id": 635, "quality": 1.0, "length": 6}, "so_32491876_32491876_4": {"section_id": 635, "quality": 0.875, "length": 7}}}, "32502276": {"ParentId": "32491876", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I assume you saw the first example (and modified it):</p>\n<pre><code>struct Y { Y(int); };\nstruct A { operator int(); };\nY y1 = A(); // error: A::operator int() is not a candidate\n</code></pre>\n<p>The crux is that invoking the converting constructor for <code>int -&gt; Y</code> constitutes a user-defined conversion, but <code>Y -&gt; Y</code> [<code>const&amp;</code>] does not. [over.best.ics]/6:</p>\n<blockquote>\n<p id=\"so_32491876_32502276_0\">When the parameter has a class type and the argument expression has the same type, the implicit conversion sequence is an identity conversion.</p>\n</blockquote>\n<p>I.e. in your code, there is one sole user-defined conversion sequence, not two; It consists of two standard conversion sequences (being identity conversions) and the intermediate user-defined conversion <code>A -&gt; Y</code>. You could also have returned a subclass:</p>\n<pre><code>struct X{}; struct Y : X {};\nstruct A { operator Y(); };\nX y = A();\n</code></pre>\n<p>\u2026now the second standard conversion sequence has Conversion Rank - [over.best.ics]/6 again:</p>\n<blockquote>\n<p id=\"so_32491876_32502276_1\">When the parameter has a class type and the argument expression has a\n  derived class type, the implicit conversion sequence is a\n  derived-to-base Conversion from the derived class to the base class. [\u2026] A derived-to-base Conversion has Conversion rank (13.3.3.1.1).</p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-09-11T07:11:16.313", "Id": "32502276", "Score": "1", "CreationDate": "2015-09-10T12:44:38.977", "LastActivityDate": "2015-09-11T07:11:16.313"}});