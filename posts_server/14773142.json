post_cb({"bq_ids": {"n4140": {"so_14773142_14773502_0": {"length": 9, "quality": 0.9, "section_id": 7217}}, "n3337": {"so_14773142_14773502_0": {"length": 9, "quality": 0.9, "section_id": 6961}}, "n4659": {"so_14773142_14773502_0": {"length": 9, "quality": 0.9, "section_id": 8726}}}, "14773292": {"Id": "14773292", "PostTypeId": "2", "Body": "<p>From C99:</p>\n<blockquote>\n<p id=\"so_14773142_14773292_0\">6.3.1.5 Real floating types<br>\n  1 When a float is promoted to double or long double, or a double is promoted to long double, its value is unchanged.<br>\n  2 When a double is demoted to float, a long double is demoted to double or float, or a value being represented in greater precision and range than required by its semantic type (see 6.3.1.8) is explicitly converted to its semantic type, if the value being converted can be represented exactly in the new type, it is unchanged...</br></br></p>\n</blockquote>\n<p>I think, this guarantees you that a float-&gt;double-&gt;float conversion is going to preserve the original float value.</p>\n<p>The standard also defines the macros <code>INFINITY</code> and <code>NAN</code> in <code>7.12 Mathematics &lt;math.h&gt;</code>:</p>\n<blockquote>\n<p id=\"so_14773142_14773292_1\">4 The macro INFINITY expands to a constant expression of type float representing positive or unsigned infinity, if available; else to a positive constant of type float that overflows at translation time.<br>\n  5 The macro NAN is defined if and only if the implementation supports quiet NaNs for the float type. It expands to a constant expression of type float representing a quiet NaN.</br></p>\n</blockquote>\n<p>So, there's provision for such special values and conversions may just work for them as well (including for the minus infinity and negative zero).</p>\n", "LastEditorUserId": "968261", "LastActivityDate": "2013-02-08T13:24:16.243", "Score": "16", "CreationDate": "2013-02-08T13:08:30.860", "ParentId": "14773142", "CommentCount": "2", "OwnerUserId": "968261", "LastEditDate": "2013-02-08T13:24:16.243"}, "14773142": {"ViewCount": "1505", "Body": "<p>Assuming <a href=\"http://en.wikipedia.org/wiki/IEEE_floating_point\">IEEE-754</a> conformance, is a float guaranteed to be preserved when transported through a double?</p>\n<p>In other words, will the following assert always be satisfied?</p>\n<pre><code>int main()\n{\n    float f = some_random_float();\n    assert(f == (float)(double)f);\n}\n</code></pre>\n<p>Assume that <code>f</code> could acquire any of the special values defined by IEEE, such as NaN and Infinity.</p>\n<p>According to IEEE, is there a case where the assert will be satisfied, but the exact bit-level representation is not preserved after the transportation through double?</p>\n<p>The code snippet is valid in both C and C++.</p>\n", "AcceptedAnswerId": "14773502", "Title": "Is a float guaranteed to be preserved when transported through a double in C/C++?", "CreationDate": "2013-02-08T13:00:04.420", "Id": "14773142", "CommentCount": "15", "LastEditDate": "2013-02-12T22:00:00.540", "PostTypeId": "1", "LastEditorUserId": "63550", "LastActivityDate": "2013-02-13T20:32:52.330", "Score": "34", "OwnerUserId": "1698548", "Tags": "<c++><c><floating-point><double><ieee-754>", "AnswerCount": "3"}, "14773502": {"Id": "14773502", "PostTypeId": "2", "Body": "<p>You don't even need to assume IEEE. C89 says in 3.1.2.5:</p>\n<blockquote>\n<p id=\"so_14773142_14773502_0\">The set of values of the type <code>float</code> is a subset of the set of values\n  of the type <code>double</code></p>\n</blockquote>\n<p>And every other C and C++ standard says equivalent things. As far as I know, NaNs and infinities are \"values of the type <code>float</code>\", albeit values with some special-case rules when used as operands.</p>\n<p>The fact that the float -&gt; double -&gt; float conversion restores the original value of the <code>float</code> follows (in general) from the fact that numeric conversions all preserve the value if it's representable in the destination type.</p>\n<p>Bit-level representations are a slightly different matter. Imagine that there's a value of <code>float</code> that has two distinct bitwise representations. Then nothing in the C standard prevents the float -&gt; double -&gt; float conversion from switching one to the other. In IEEE that won't happen for \"actual values\" unless there are padding bits, but I don't know whether IEEE rules out a single NaN having distinct bitwise representations. NaNs don't compare equal to themselves anyway, so there's also no standard way to tell whether two NaNs are \"the same NaN\" or \"different NaNs\" other than maybe converting them to strings. The issue may be moot.</p>\n<p>One thing to watch out for is non-conforming modes of compilers, in which they keep super-precise values \"under the covers\", for example intermediate results left in floating-point registers and reused without rounding. I don't think that would cause your example code to fail, but as soon as you're doing floating-point <code>==</code> it's the kind of thing you start worrying about.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2013-02-08T13:56:20.107", "Score": "30", "CreationDate": "2013-02-08T13:20:12.447", "ParentId": "14773142", "CommentCount": "7", "OwnerUserId": "13005", "LastEditDate": "2013-02-08T13:56:20.107"}, "14822692": {"Id": "14822692", "PostTypeId": "2", "Body": "<p>The assertion will fail in flush-to-zero and/or denormalized-is-zero mode (e.g. code compiled with -mfpmath=sse, -fast-math, etc, but also on heaps of compilers and architectures as default, such as Intel's C++ compiler) if f is denormalized.</p>\n<p>You cannot produce a denormalized float in that mode though, but the scenario is still possible:</p>\n<p>a) Denormalized float comes from external source.</p>\n<p>b) Some libraries tamper with FPU modes but forget (or intentionally avoid) setting them back after each function call to it, making it possible for caller to mismatch normalization.</p>\n<p>Practical example which prints following:</p>\n<pre><code>f = 5.87747e-39\nf2 = 5.87747e-39\n\nf = 5.87747e-39\nf2 = 0\nerror, f != f2!\n</code></pre>\n<p>The example works both for VC2010 and GCC 4.3 but assumes that VC uses SSE for math as default and GCC uses FPU for math as default. The example may fail to illustrate the problem otherwise.</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\n#ifdef _MSC_VER\n#include &lt;xmmintrin.h&gt;\n#endif\n\ntemplate &lt;class T&gt;bool normal(T t)\n{\n    return (t != 0 || fabsf( t ) &gt;= std::numeric_limits&lt;T&gt;::min());\n}\n\nvoid csr_flush_to_zero()\n{\n#ifdef _MSC_VER\n    _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);\n#else\n    unsigned csr = __builtin_ia32_stmxcsr();\n    csr |= (1 &lt;&lt; 15);\n    __builtin_ia32_ldmxcsr(csr);\n#endif\n}\n\nvoid test_cast(float f) \n{\n    std::cout &lt;&lt; \"f = \" &lt;&lt; f &lt;&lt; \"\\n\";\n    double d = double(f);\n    float f2 = float(d);\n    std::cout &lt;&lt; \"f2 = \" &lt;&lt; f2 &lt;&lt; \"\\n\";\n\n    if(f != f2)\n        std::cout &lt;&lt; \"error, f != f2!\\n\";\n\n    std::cout &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    float f = std::numeric_limits&lt;float&gt;::min() / 2.0;\n\n    test_cast(f);\n    csr_flush_to_zero();\n    test_cast(f);\n}\n</code></pre>\n", "LastEditorUserId": "2063054", "LastActivityDate": "2013-02-13T20:32:52.330", "Score": "2", "CreationDate": "2013-02-11T23:12:28.310", "ParentId": "14773142", "CommentCount": "5", "OwnerUserId": "2063054", "LastEditDate": "2013-02-13T20:32:52.330"}});