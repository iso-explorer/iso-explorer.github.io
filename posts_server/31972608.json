post_cb({"31972608": {"Tags": "<c++><clang><compiler-bug><c++1z><fold-expression>", "ViewCount": "522", "LastEditDate": "2015-08-12T18:24:06.617", "CreationDate": "2015-08-12T18:18:38.120", "LastEditorUserId": "3233393", "Title": "Clang and the binary fold expressions \u2014 The curse of the empty parameter pack", "CommentCount": "3", "AcceptedAnswerId": "31972828", "Score": "10", "OwnerUserId": "3233393", "Id": "31972608", "LastActivityDate": "2016-11-14T04:29:50.003", "Body": "<p>Specifically Clang 3.6.0, the one currently hosted by Coliru.</p>\n<p>All these snippets are called from :</p>\n<pre><code>int main() {\n    foo();\n    std::cout &lt;&lt; \"\\n----\\n\";\n    foo(1, 2, 3);\n}\n</code></pre>\n<p>The following code :</p>\n<pre><code>template &lt;class... Args&gt;\nvoid foo(Args... args) {\n    std::cout &lt;&lt; ... &lt;&lt; args;\n}\n</code></pre>\n<p>Triggers the following compilation error :</p>\n<pre><code>main.cpp:7:17: error: expected ';' after expression\n    std::cout &lt;&lt; ... &lt;&lt; args;\n                ^\n                ;\nmain.cpp:7:15: error: expected expression\n    std::cout &lt;&lt; ... &lt;&lt; args;\n              ^\n</code></pre>\n<p>So I tried putting parentheses around the expression :</p>\n<pre><code>(std::cout &lt;&lt; ... &lt;&lt; args);\n</code></pre>\n<p>It works, but triggers a warning :</p>\n<pre><code>main.cpp:7:6: warning: expression result unused [-Wunused-value]\n    (std::cout &lt;&lt; ... &lt;&lt; args);\n     ^~~~~~~~~\nmain.cpp:11:5: note: in instantiation of function template specialization 'foo&lt;&gt;' requested here\n    foo();\n    ^\n</code></pre>\n<p>So I tried to discard the value of the expression with a function-style cast to <code>void</code> :</p>\n<pre><code>void(std::cout &lt;&lt; ... &lt;&lt; args);\n</code></pre>\n<p>But :</p>\n<pre><code>main.cpp:7:20: error: expected ')'\n    void(std::cout &lt;&lt; ... &lt;&lt; args);\n                   ^\nmain.cpp:7:9: note: to match this '('\n    void(std::cout &lt;&lt; ... &lt;&lt; args);\n        ^\n</code></pre>\n<p>I tried a <code>static_cast</code> too, for the same result.</p>\n<p>So I tried with a C-cast instead  :</p>\n<pre><code>(void)(std::cout &lt;&lt; ... &lt;&lt; args);\n</code></pre>\n<p>But then :</p>\n<pre><code>main.cpp:6:18: warning: unused parameter 'args' [-Wunused-parameter]\nvoid foo(Args... args) {\n                 ^\n</code></pre>\n<p>... and my output is only <code>----</code> : <code>foo(1, 2, 3);</code> doesn't output anymore !</p>\n<p>Is Clang cursed by an evil force from future standards, does it have a bug, or is the problem sitting on my chair right now ?</p>\n", "PostTypeId": "1", "AnswerCount": "3"}, "31972993": {"ParentId": "31972608", "Score": "2", "CreationDate": "2015-08-12T18:41:07.207", "Id": "31972993", "OwnerUserId": "2069064", "LastActivityDate": "2015-08-12T18:41:07.207", "Body": "<p>A fold expression, from [expr.prim.fold] is:</p>\n<blockquote>\n<p id=\"so_31972608_31972993_0\">A fold expression performs a fold of a template parameter pack (14.5.3) over a binary operator.<br>\n  \u00a0\u00a0\u00a0\u00a0<em>fold-expression</em>:<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0( <em>cast-expression</em> <em>fold-operator</em> ... )<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0( ... <em>fold-operator</em> <em>cast-expression</em> )<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0( <em>cast-expression</em> <em>fold-operator</em> ... <em>fold-operator</em> <em>cast-expression</em> )</br></br></br></br></p>\n</blockquote>\n<p>Note that in all cases, the parentheses are part of the grammar. So your initial example is syntactically incorrect, and must be:</p>\n<pre><code>template &lt;class... Args&gt;\nvoid foo(Args... args) {\n    (std::cout &lt;&lt; ... &lt;&lt; args);\n}\n</code></pre>\n<p>That will then give you a warning in the case of an empty pack, since the binary fold reduces to just <code>std::cout;</code> To get rid of that warning, you can go the usual route of casting to <code>void</code> - just that the inner set of parentheses are part of the grammar so you need <em>two</em>:</p>\n<pre><code>void((std::cout &lt;&lt; ... &lt;&lt; args));\n</code></pre>\n<p>Or you could just throw in an extra <code>endl</code> or the like:</p>\n<pre><code>(std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; std::endl;\n</code></pre>\n<p>Or return the result:</p>\n<pre><code>template &lt;class... Args&gt;\nstd::ostream&amp; foo(Args... args) {\n    return (std::cout &lt;&lt; ... &lt;&lt; args);\n}\n</code></pre>\n", "PostTypeId": "2", "CommentCount": "0"}, "31972828": {"ParentId": "31972608", "Score": "9", "CreationDate": "2015-08-12T18:31:49.437", "LastActivityDate": "2015-08-12T18:51:46.167", "LastEditDate": "2015-08-12T18:51:46.167", "OwnerUserId": "241631", "LastEditorUserId": "241631", "Body": "<p>You need an extra set of parentheses when casting to <code>void</code> using the functional notation cast, otherwise the parentheses are considered part of the cast expression instead of the fold expression. The <a href=\"http://en.cppreference.com/w/cpp/language/fold\" rel=\"nofollow\">fold expression syntax</a> itself requires a set of parentheses.</p>\n<p>All of the following work without producing any warnings:</p>\n<pre><code>void((std::cout &lt;&lt; ... &lt;&lt; args));\n(void)((std::cout &lt;&lt; ... &lt;&lt; args));\n</code></pre>\n<p>Or just call some <code>ostream</code> member function to avoid the unused result warning</p>\n<pre><code>(std::cout &lt;&lt; ... &lt;&lt; args).flush();\n</code></pre>\n<hr>\n<p>As T.C. mentions in the comments below, the behavior with <code>(void)(std::cout &lt;&lt; ... &lt;&lt; args);</code> seems like a clang bug. The syntax for a cast notation is specified in <em>5.4 [expr.cast]</em></p>\n<blockquote>\n<p id=\"so_31972608_31972828_0\"><em>cast-expression</em>:<br/>\n  \u00a0\u00a0<em>unary-expression</em><br/>\n  \u00a0\u00a0<em>( type-id ) cast-expression</em></p>\n</blockquote>\n<p>Since parentheses are not required as part of the cast expression, that usage shouldn't be producing warnings, and more importantly, it should result in printing the arguments.</p>\n</hr>", "Id": "31972828", "PostTypeId": "2", "CommentCount": "3"}, "bq_ids": {"n4659": {"so_31972608_31972993_0": {"length": 18, "section_id": 7481, "quality": 0.9}}}, "40581906": {"ParentId": "31972608", "Score": "2", "CreationDate": "2016-11-14T04:29:50.003", "Id": "40581906", "OwnerUserId": "962089", "LastActivityDate": "2016-11-14T04:29:50.003", "Body": "<p>I decided to take a better look at this bug in the Clang source. Here's the offending section of code. This case happens when it's just finished parsing <code>(&lt;type&gt;)</code> and is now parsing a following parenthesized expression:</p>\n<pre><code>} else if (isTypeCast) {\n  // Parse the expression-list.\n  InMessageExpressionRAIIObject InMessage(*this, false);\n\n  ExprVector ArgExprs;\n  CommaLocsTy CommaLocs;\n\n  if (!ParseSimpleExpressionList(ArgExprs, CommaLocs)) {\n    // FIXME: If we ever support comma expressions as operands to\n    // fold-expressions, we'll need to allow multiple ArgExprs here.\n    if (ArgExprs.size() == 1 &amp;&amp; isFoldOperator(Tok.getKind()) &amp;&amp;\n        NextToken().is(tok::ellipsis))\n    return ParseFoldExpression(Result, T);\n\n    ExprType = SimpleExpr;\n    Result = Actions.ActOnParenListExpr(OpenLoc, Tok.getLocation(),\n                                        ArgExprs);\n  }\n}\n\n// The beginning of ParseFoldExpression(LHS, T):\nif (LHS.isInvalid()) {\n  T.skipToEnd();\n  return true;\n}\n</code></pre>\n<p>The specific part of the code responsible for this bug is here:</p>\n<pre><code>return ParseFoldExpression(Result, T);\n</code></pre>\n<p>It turns out that <code>Result</code> is never set apart from its initial <code>true</code> value. I believe it should be set to <code>ArgExprs.front()</code>, which now holds <code>std::cout</code>. </p>\n<p>Now you'll notice the FIXME as well. While unrelated to this issue in particular, it might be worth fixing alongside this.</p>\n<p>Being my first Clang fix, I still have several things to do before submitting a change (for reference, Clang 4.0 is currently in development). I would be more than happy for this to be fixed at all, whether it's by me or someone else. At the very least, my findings are documented somewhere for now.</p>\n", "PostTypeId": "2", "CommentCount": "0"}});