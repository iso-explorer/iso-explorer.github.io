post_cb({"36562133": {"ParentId": "36561826", "Score": "11", "CreationDate": "2016-04-12T01:34:12.033", "LastActivityDate": "2016-04-12T20:47:15.387", "LastEditDate": "2016-04-12T20:47:15.387", "OwnerUserId": "481267", "LastEditorUserId": "481267", "Body": "<p>This is explained <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2296\" rel=\"nofollow\">here</a>.</p>\n<blockquote>\n<p id=\"so_36561826_36562133_0\">Introduce the following new definition to the existing list in 17.3\n  [definitions]: [Drafting note: If LWG 2234 is accepted before this\n  issue, the accepted wording for the new definition should be used\n  instead \u2014 end drafting note]</p>\n<pre><code>**constant subexpression** [defns.const.subexpr]\n\nan expression whose evaluation as a subexpression of a *conditional-expression* *CE* (5.16 [expr.cond]) would not prevent *CE* from being a core constant expression (5.20 [expr.const]).\n</code></pre>\n</blockquote>\n<p>So \"constant subexpression\" roughly means \"you can use it in a constant expression\".</p>\n<blockquote>\n<p id=\"so_36561826_36562133_1\">What is an example where std::addressof(E) will be a constant expression?</p>\n</blockquote>\n<p>I believe it's intended to give a constant expression whenever <code>&amp;E</code> does (assuming that <code>&amp;</code> invokes the built-in address-of operator).</p>\n<pre><code>constexpr int x  = 42; // static storage duration\nconstexpr int* p1 = &amp;x; // x is an lvalue constant subexpression\nconstexpr int* p2 = std::addressof(x); // x is an lvalue constant subexpression\n</code></pre>\n<blockquote>\n<p id=\"so_36561826_36562133_2\">What is an example where std::addressof(E) will NOT be a constant expression?</p>\n</blockquote>\n<pre><code>std::map&lt;int, int&gt; m;\nvoid f() {\n    int&amp; r = m[42];\n    constexpr int* z1 = &amp;r; // error: r is not a constant subexpression\n    constexpr int* z2 = std::addressof(r); // likewise\n\n    constexpr int x = 43; // automatic storage duration\n    constexpr const int y1 = *&amp;x;                // ok; x is a constant subexpression\n    constexpr const int y2 = *std::addressof(x); // likewise\n    constexpr const int* p1 = &amp;x;                // error: p1 points to an automatic object\n    constexpr const int* p2 = std::addressof(x); // likewise\n\n}\n</code></pre>\n", "Id": "36562133", "PostTypeId": "2", "CommentCount": "8"}, "36561826": {"Tags": "<c++><memory><constexpr><c++1z><addressof>", "ViewCount": "237", "LastEditDate": "2016-04-12T07:24:15.633", "CreationDate": "2016-04-12T01:00:30.280", "LastEditorUserId": "1364752", "Title": "std::addressof as a constant expression in C++17", "CommentCount": "0", "AcceptedAnswerId": "36562133", "Score": "10", "OwnerUserId": "882932", "Id": "36561826", "LastActivityDate": "2016-04-12T20:47:15.387", "Body": "<p>The specification of <code>std::addressof</code> was changed for C++17: it is now allowed to be a constant expression. However, <a href=\"http://en.cppreference.com/w/cpp/memory/addressof\" rel=\"nofollow\">cppreference</a> says that:</p>\n<blockquote>\n<p id=\"so_36561826_36561826_0\">The expression <code>std::addressof(E)</code> is a constant subexpression, if <code>E</code> is\n  an lvalue constant subexpression.</p>\n</blockquote>\n<ul>\n<li>What is a constant subexpression?</li>\n<li>What is an example where <code>std::addressof(E)</code> will be a constant expression?</li>\n<li>What is an example where <code>std::addressof(E)</code> will NOT be a constant expression?</li>\n</ul>\n", "PostTypeId": "1", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_36561826_36561826_0": {"length": 6, "section_id": 5508, "quality": 0.75}, "so_36561826_36562133_1": {"length": 4, "section_id": 7687, "quality": 0.5714285714285714}}}});