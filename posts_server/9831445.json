post_cb({"9831445": {"CommentCount": "6", "AcceptedAnswerId": "9831732", "PostTypeId": "1", "LastEditorUserId": "82320", "CreationDate": "2012-03-22T22:23:10.040", "LastActivityDate": "2012-03-23T03:58:52.783", "LastEditDate": "2012-03-23T03:58:52.783", "ViewCount": "200", "FavoriteCount": "1", "Title": "Does the standard require that objects in automatic storage have the correct alignment for any type (e.g. as malloc does)?", "Id": "9831445", "Score": "7", "Body": "<p>I'm curious if allocating a buffer on the stack is required to have correct alignment for any type, similar to how <code>malloc</code> works, or if I would be forced to use something like <code>std::aligned_storage</code>.</p>\n<p>Consider the following block of code:</p>\n<pre><code>typedef enum _KEY_VALUE_INFORMATION_CLASS {\n    KeyValueBasicInformation            = 0,\n    // Others\n} KEY_VALUE_INFORMATION_CLASS;\n\ntypedef struct _KEY_VALUE_BASIC_INFORMATION {\n    ULONG TitleIndex;\n    ULONG Type;\n    ULONG NameLength;\n    WCHAR Name[1];\n} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;\n\nstd::vector&lt;std::wstring&gt; RegistryKey::EnumerateValueNames() const\n{\n    std::vector&lt;std::wstring&gt; result;\n    ULONG index = 0;\n    const ULONG valueNameStructSize = 16384 * sizeof(wchar_t) +\n        sizeof(KEY_VALUE_BASIC_INFORMATION);\n\n    // Stack buffer here\n    unsigned char buff[valueNameStructSize];\n    // Casted here\n    KEY_VALUE_BASIC_INFORMATION const* basicValueInformation =\n        reinterpret_cast&lt;KEY_VALUE_BASIC_INFORMATION const*&gt;(buff);\n    for(;;)\n    {\n        ULONG resultLength;\n        NTSTATUS errorCheck = PNtEnumerateValueKeyFunc(\n            hKey_,\n            index++,\n            KeyValueBasicInformation,\n            buff,\n            valueNameStructSize,\n            &amp;resultLength);\n        if (NT_SUCCESS(errorCheck))\n        {\n            result.emplace_back(std::wstring(basicValueInformation-&gt;Name,\n                basicValueInformation-&gt;NameLength / sizeof(wchar_t)));\n        }\n        else if (errorCheck == STATUS_NO_MORE_ENTRIES)\n        {\n            break;\n        }\n        else\n        {\n            Win32Exception::ThrowFromNtError(errorCheck);\n        }\n    }\n    return result;\n}\n</code></pre>\n<p>Note how the value <code>buff</code> is a character buffer put on the stack, sized to hold a given maximum amount of data. However, I'm concerned that the cast required to interpret the buffer as a string may cause an alignment fault if this code were to be ported to another (say ARM or IA64) platform.</p>\n<p>EDIT: If anyone's curious, I redid this in terms of <code>std::aligned_storage</code> and <code>std::alignment_of</code>:</p>\n<pre><code>std::vector&lt;std::wstring&gt; RegistryKey::EnumerateValueNames() const\n{\n    std::vector&lt;std::wstring&gt; result;\n    ULONG index = 0;\n    const ULONG valueNameStructSize = 16384 * sizeof(wchar_t) +\n        sizeof(KEY_VALUE_BASIC_INFORMATION);\n    std::aligned_storage&lt;valueNameStructSize,\n        std::alignment_of&lt;KEY_VALUE_BASIC_INFORMATION&gt;::value&gt;::type buff;\n    auto basicValueInformation =\n        reinterpret_cast&lt;KEY_VALUE_BASIC_INFORMATION*&gt;(&amp;buff);\n    for(;;)\n    {\n        ULONG resultLength;\n        NTSTATUS errorCheck = PNtEnumerateValueKeyFunc(\n            hKey_,\n            index++,\n            KeyValueBasicInformation,\n            basicValueInformation,\n            valueNameStructSize,\n            &amp;resultLength);\n        if (NT_SUCCESS(errorCheck))\n        {\n            result.emplace_back(std::wstring(basicValueInformation-&gt;Name,\n                basicValueInformation-&gt;NameLength / sizeof(wchar_t)));\n        }\n        else if (errorCheck == STATUS_NO_MORE_ENTRIES)\n        {\n            break;\n        }\n        else\n        {\n            Win32Exception::ThrowFromNtError(errorCheck);\n        }\n    }\n    return std::move(result);\n}\n</code></pre>\n", "Tags": "<c++><windows><visual-c++>", "OwnerUserId": "82320", "AnswerCount": "1"}, "9831732": {"ParentId": "9831445", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>The standard makes no requirements on the alignment of automatic variables (or variables with static storage for that matter), other than the compiler must make sure that accessing them works.</p>\n<ul>\n<li>C++03 3.9/5 Types</li>\n</ul>\n<blockquote>\n<p id=\"so_9831445_9831732_0\">Object types have alignment requirements (3.9.1, 3.9.2).  The\n  alignment of a complete object type is an implementation-defined\n  integer value representing a number of bytes; an object is allocated\n  at an address that meets the alignment requirements of its object type</p>\n</blockquote>\n<p>Note: \"object type\" here means a type that's not a function, reference or void type, (i.e., it applies to <code>unsigned char</code>).</p>\n<p>One way to get an aligned buffer might be to declare <code>buff</code> like so:</p>\n<pre><code>KEY_VALUE_BASIC_INFORMATION buff[valueNameStructSize/sizeof(KEY_VALUE_BASIC_INFORMATION) + 1];\n</code></pre>\n<p>And you'll be able to get rid of the <code>reinterpret_cast&lt;&gt;</code> to boot.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2012-03-22T23:41:46.977", "Id": "9831732", "Score": "5", "CreationDate": "2012-03-22T22:53:15.017", "LastActivityDate": "2012-03-22T23:41:46.977"}, "bq_ids": {"n4140": {"so_9831445_9831732_0": {"section_id": 7240, "quality": 0.5925925925925926, "length": 16}}, "n3337": {"so_9831445_9831732_0": {"section_id": 6984, "quality": 0.5925925925925926, "length": 16}}, "n4659": {"so_9831445_9831732_0": {"section_id": 8749, "quality": 0.5555555555555556, "length": 15}}}});