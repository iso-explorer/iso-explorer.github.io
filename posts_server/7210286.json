post_cb({"7210286": {"CommentCount": "1", "AcceptedAnswerId": "7901567", "PostTypeId": "1", "LastEditorUserId": "459640", "CreationDate": "2011-08-26T20:32:51.243", "LastActivityDate": "2011-10-26T10:42:28.207", "LastEditDate": "2011-10-26T00:51:00.580", "ViewCount": "1321", "FavoriteCount": "5", "Title": "Incomplete class usage in template", "Id": "7210286", "Score": "14", "Body": "<p>I am very surprised that on various sampled versions of g++, the following compiles without error or warning:</p>\n<pre><code>// Adapted from boost::checked_delete()\ntemplate &lt;class T&gt; inline void assert_complete()\n{\n  typedef char type_must_be_complete[ sizeof(T) ? 1 : -1 ];\n  (void) sizeof(type_must_be_complete);\n}\n\nclass X;\n\nvoid f()\n{\n  assert_complete&lt;X&gt;();\n}\n\nclass X {};\n\nint main() {}\n</code></pre>\n<p>If the definition of <code>X</code> is missing or in a different translation unit, I do get errors.  </p>\n<p>But in the program as above, isn't the definition of <code>f</code> the single instantiation point of my template?  And isn't the incompleteness of <code>X</code> at that instantiation point a semantic error?</p>\n<p>Does the (C++03 and/or C++11 Draft) Standard call this program well-formed, ill-formed, ill-formed but diagnostic not required, or undefined behavior?</p>\n<p>Edit: @David Rodriguez - dribeas reports that clang++, comeau, and Visual Studio 2010 also accept similar code.</p>\n", "Tags": "<c++><templates><incomplete-type>", "OwnerUserId": "459640", "AnswerCount": "2"}, "7901567": {"ParentId": "7210286", "CommentCount": "9", "CreationDate": "2011-10-26T10:42:28.207", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "7901567", "Score": "12", "Body": "<p>(I was waiting to Alf Steinbach to post an answer, but since he is not doing it, I will post the reference that he mentioned in the Lounge C++ chat):</p>\n<p>The standard indicates that template instantiations are performed <em>after</em> the translation unit has already been translated, so that in time, template instantiations happen <em>after</em> all the non templated elements have already been processed. This is described in section 2.2 Phases of translation:</p>\n<p>Paragraphs 1-6 define the preprocessor work and basic <em>textual</em> operations (conversions of the character set, concatenation of literals...)</p>\n<blockquote>\n<p id=\"so_7210286_7901567_0\">7/  White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The resulting tokens are syntactically and semantically analyzed and translated as a translation unit.</p>\n<p id=\"so_7210286_7901567_1\">8/ Translated translation units and instantiation units are combined as follows: Each translated translation unit is examined to produce a list of required instantiations. The definitions of the required templates are located. It is implementation-defined whether the source of the translation units containing these definitions is required to be available. All the required instantiations are performed to produce instantiation units. [ Note: These are similar to translated translation units, but contain no references to uninstantiated templates and no template definitions. \u2014 end note ] The program is ill-formed if any instantiation fails.</p>\n</blockquote>\n<p>I have removed some of the notes for brevity. Now the important bit seems to be that the code is translated without triggering template instantiations in one step, and then in a later step the templates are instantiated. This in turn means that if the type is <em>complete</em> anywhere in the translation unit, it will have been processed by the time the compiler gets to the instantiation.</p>\n<p><em>Disclaimer:</em> This seems like a good reason for all of the compilers that I have tried showing the exact same behavior (gcc, clang, comeau, VS 2010), but this only states <em>when</em> in time the instantiation is performed, it does not explicitly state that the type can be incomplete at the point of instantiation of the template.</p>\n", "LastActivityDate": "2011-10-26T10:42:28.207"}, "bq_ids": {"n4140": {"so_7210286_7901567_1": {"section_id": 5313, "quality": 0.8571428571428571, "length": 48}, "so_7210286_7210958_0": {"section_id": 7204, "quality": 0.9666666666666667, "length": 87}, "so_7210286_7901567_0": {"section_id": 5313, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_7210286_7901567_1": {"section_id": 5110, "quality": 0.8571428571428571, "length": 48}, "so_7210286_7210958_0": {"section_id": 6948, "quality": 0.9666666666666667, "length": 87}, "so_7210286_7901567_0": {"section_id": 5110, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_7210286_7901567_1": {"section_id": 6737, "quality": 0.8571428571428571, "length": 48}, "so_7210286_7210958_0": {"section_id": 8713, "quality": 0.9333333333333333, "length": 84}, "so_7210286_7901567_0": {"section_id": 6737, "quality": 0.9523809523809523, "length": 20}}}, "7210958": {"ParentId": "7210286", "CommentCount": "2", "CreationDate": "2011-08-26T21:57:51.887", "OwnerUserId": "766580", "PostTypeId": "2", "Id": "7210958", "Score": "6", "Body": "<p>This line completes the type:</p>\n<pre><code>class X {};\n</code></pre>\n<p>So long as the type is completed somewhere in the translation unit then any earlier incomplete instances will be completed.</p>\n<p>Here's the relevant section from the standard [basic.types] (3.9 paragraph 7):</p>\n<blockquote>\n<p id=\"so_7210286_7210958_0\">A class type (such as \u201cclass X\u201d) might be incomplete at one point in a translation unit and complete later on; the type \u201cclass X\u201d is the same type at both points. The declared type of an array object might be an array of incomplete class type and therefore incomplete; if the class type is completed later on in the translation unit, the array type becomes complete; the array type at those two points is the same type. The declared type of an array object might be an array of unknown size and therefore be incomplete at one point in a translation unit and complete later on; the array types at those two points (\u201carray of unknown bound of T\u201d and \u201carray of N T\u201d) are different types. The type of a pointer to array of unknown size, or of a type defined by a typedef declaration to be an array of unknown size, cannot be completed.</p>\n</blockquote>\n", "LastActivityDate": "2011-08-26T21:57:51.887"}});