post_cb({"bq_ids": {"n4140": {"so_17642624_17648572_2": {"length": 15, "quality": 0.6, "section_id": 194}, "so_17642624_17642624_0": {"length": 75, "quality": 0.974025974025974, "section_id": 577}, "so_17642624_17648572_1": {"length": 7, "quality": 0.875, "section_id": 7039}, "so_17642624_17648572_0": {"length": 42, "quality": 0.8571428571428571, "section_id": 5891}}, "n3337": {"so_17642624_17648572_2": {"length": 13, "quality": 0.52, "section_id": 188}, "so_17642624_17642624_0": {"length": 75, "quality": 0.974025974025974, "section_id": 567}, "so_17642624_17648572_1": {"length": 7, "quality": 0.875, "section_id": 6785}, "so_17642624_17648572_0": {"length": 42, "quality": 0.8571428571428571, "section_id": 5662}}, "n4659": {"so_17642624_17648572_2": {"length": 15, "quality": 0.6, "section_id": 200}, "so_17642624_17642624_0": {"length": 75, "quality": 0.974025974025974, "section_id": 600}, "so_17642624_17648572_1": {"length": 7, "quality": 0.875, "section_id": 8536}, "so_17642624_17648572_0": {"length": 42, "quality": 0.8571428571428571, "section_id": 7374}}}, "17642624": {"ViewCount": "344", "Body": "<p>Another one for the language lawyers.</p>\n<p>For the following code, regardless of whether the explicit instantiation of <code>A&lt;int&gt;</code> is present:</p>\n<p>clang 3.0 requires <code>typename</code> in the declaration of <code>Type1</code> and <code>Type3</code>, but not of <code>Type2</code>.</p>\n<p>gcc 4.8.1 requires <code>typename</code> in the declaration of <code>Type1</code>, but not of <code>Type2</code> or <code>Type3</code>.</p>\n<pre><code>struct C\n{\n    int f1();\n    static int f2();\n    int m;\n};\n\ntemplate&lt;int i&gt;\nstruct S\n{\n    typedef int Type;\n};\n\ntemplate&lt;typename T&gt;\nstruct B : C\n{\n};\n\ntemplate&lt;typename T&gt;\nstruct A : B&lt;T&gt;\n{\n    void f()\n    {\n        typedef typename S&lt;sizeof(C::f1())&gt;::Type Type1; // typename required\n        typedef S&lt;sizeof(C::f2())&gt;::Type Type2; // typename not required\n        typedef typename S&lt;sizeof(C::m)&gt;::Type Type3; // typename not required?\n    }\n};\n\ntemplate struct A&lt;int&gt;;\n</code></pre>\n<p>I figure <code>typename</code> is required in the declaration of <code>Type1</code> because the implied object argument for a call to a nonstatic member is <code>(*this)</code>, the type of which is dependent.\nSee [over.call.func]:</p>\n<blockquote>\n<p id=\"so_17642624_17642624_0\">In unqualified function calls, the name is not qualified by an <code>-&gt;</code> or <code>.</code> operator and has the more general form of a primary-expression. The name is looked up in the context of the function call following the normal rules for name lookup in function calls. The function declarations found by that lookup constitute the set of candidate functions. Because of the rules for name lookup, the set of candidate functions consists (1) entirely of non-member functions or (2) entirely of member functions of some class T. In case (1), the argument list is the same as the expression-list in the call. In case (2), the argument list is the expression-list in the call augmented by the addition of an implied object argument as in a qualified function call. If the keyword <code>this</code> is in scope and refers to class <code>T</code>, or a derived class of <code>T</code>, then the implied object argument is\n  <code>(*this)</code>.</p>\n</blockquote>\n<p>Following this logic, <code>typename</code> is not required in the declaration of <code>Type2</code> because the member is static. Nor is <code>typename</code> required in the declaration of <code>Type3</code> because the expression is not a call to a nonstatic member.</p>\n<p>I've read through this: <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889\">Where and why do I have to put the \"template\" and \"typename\" keywords?</a>\n.. and through the rules in [temp.dep.type] and [temp.dep.expr]. I can't see anything that specifies whether a nonstatic member function name should be given special treatment when determining if an expression is dependent. Does the standard specify this?</p>\n<p>EDIT: removed discussion of transformation into class member access expressions based on [class.mfct.non-static] - Casey's answer discusses this in much greater detail. </p>\n", "AcceptedAnswerId": "17648572", "Title": "Is 'typename' required when template argument contains name of non-static member?", "CreationDate": "2013-07-14T19:00:32.260", "Id": "17642624", "CommentCount": "1", "LastEditDate": "2017-05-23T12:01:00.037", "CommunityOwnedDate": "2013-07-15T18:51:59.930", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-15T19:05:55.500", "Score": "2", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><typename>", "AnswerCount": "2"}, "17648572": {"Id": "17648572", "PostTypeId": "2", "Body": "<p><code>C</code> is a non-dependent name resolved during phase 1 lookup through unqualified name lookup. <code>C::f1</code> and <code>C::f2</code> are non-dependent names resolved through qualified name lookup also in the first phase of template lookup. This is true whether or not <code>C</code> is a base of <code>A</code>.</p>\n<p>The text of [class.mfct.non-static] quoted in the question seems to be from C++03. The C++11 text (9.3.1/3) reads:</p>\n<blockquote>\n<p id=\"so_17642624_17648572_0\">When an <em>id-expression</em> (5.1) that is not part of a class member access syntax (5.2.5) and not used to form a pointer to member (5.3.1) is used in a member of class <code>X</code> in a context where <code>this</code> can be used (5.1.1), if name lookup (3.4) resolves the name in the <em>id-expression</em> to a non-static non-type member of some class <code>C</code>, and if either the <em>id-expression</em> is <strong>potentially evaluated</strong> [emph. mine] or <code>C</code> is <code>X</code> or a base class of <code>X</code>, the <em>id-expression</em> is transformed into a class member access expression (5.2.5) using <code>(*this)</code> (9.3.2) as the <em>postfix-expression</em> to the left of the <code>.</code> operator.</p>\n</blockquote>\n<p><code>C::f1</code> is <em>potentially evaluated</em> in a context where <code>this</code> can be used, so <code>C::f1</code> is transformed into <code>(*this).C::f1</code>. Since <code>B&lt;T&gt;</code> explicitly depends on a template parameter, <code>(*this).C::f1</code> is a <em>member of an unknown specialization</em> per 14.6.2.1/5. [The standard uses this term \"member of an unknown specialization\" to indicate expressions that <em>could</em> indicate members for <em>some</em> specialization of the template but are not provably so for <em>all</em> specializations. ]</p>\n<p>Since <code>(*this).C::f1</code> denotes a <em>member of an unknown specialization</em>, it is a <em>type-dependent</em> class member access expression per 14.6.2.2/5. By extension, <code>(*this).C::f1()</code> is type-dependent per 14.6.2.2/1.  <code>sizeof((*this).C::f1())</code> is then <em>value-dependent</em> per 14.6.2.3/2. <code>S&lt;sizeof((*this).C::f1())&gt;</code> - a <em>simple-template-id</em> with a value-dependent argument expression - is then a dependent type per 14.6.2.1/8.</p>\n<p>Since <code>S&lt;sizeof((*this).C::f1())&gt;</code> is dependent, </p>\n<p><code>S&lt;sizeof((*this).C::f1())&gt;::Type</code></p>\n<p>is dependent per 14.6.2/1 \"...if the <em>unqualified-id</em> of the <em>id-expression</em> is a <em>template-id</em> in which any of the template arguments depends on a template parameter.\" And last - but not least, 14.6/2 requires the keyword <code>typename</code> be used to indicate that a dependent name refers to a type:</p>\n<p><code>typename S&lt;sizeof((*this).C::f1())&gt;::Type</code></p>\n<p>I <em>think</em> that's the full chain of reasoning.</p>\n<p>EDIT: This answer appears to be wrong. The phrase \"potentially evaluated\" is defined in 3.2/2 One Definition Rule [basic.def.odr]:</p>\n<blockquote>\n<p id=\"so_17642624_17648572_1\">An expression is <em>potentially evaluated</em> unless it is an unevaluated operand (Clause 5) or a subexpression thereof.</p>\n</blockquote>\n<p><code>C::f1</code> in the example is certainly a subexpression of <code>C::f1()</code> which is an unevaluated operand of <code>sizeof</code> per 5.3.3/1 Sizeof [expr.sizeof].</p>\n<p>EDIT: I believe the expression <code>qualified-id()</code> is currently not but should be considered type-dependent when (1) it appears inside a member function of a class template and (2) the <em>qualified-id</em> is a non-dependent name that denotes an overload set of non-static member functions of some class and  (3) the type of <code>this</code> is dependent. Determining the type of the expression requires overload resolution per 13.3.1.1.1/3 which is impossible when <code>this</code> is in scope without determining the type of the class to which <code>this</code> refers.</p>\n<p>I think this could be achieved by adding a bullet to 14.6.2.1/5 [temp.dep.type] that reads:</p>\n<blockquote id=\"so_17642624_17648572_2\">\n<ul>\n<li>A <em>qualified-id</em> used in an unqualified function call (13.3.1.1.1/3 [over.call.func]) that denotes a set of member functions of some class <code>T</code> that is not the current instantiation or a non-dependent base class, when the current instantiation has at least one dependent base class.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-07-15T18:17:46.140", "Score": "3", "CreationDate": "2013-07-15T07:11:11.837", "ParentId": "17642624", "CommentCount": "6", "OwnerUserId": "923854", "LastEditDate": "2013-07-15T18:17:46.140"}, "17642672": {"Id": "17642672", "PostTypeId": "2", "Body": "<p>I'm not totally sure, but here's an explanation  that uses your quote:</p>\n<ul>\n<li><p><code>C::f2</code> is just a plain function, so it is known unconditionally, and <code>sizeof(C::f2())</code> does not depend on the template parameter <code>T</code> -- it's just a plain type, like <code>S&lt;6&gt;</code>.</p></li>\n<li><p><code>C::f1()</code> is actually <code>this-&gt;f1()</code>, and since <code>this</code> depends on the template parameter <code>T</code>, <code>S&lt;sizeof(this-&gt;f1())&gt;</code> is a dependent type, and thus needs disambiguation.</p></li>\n</ul>\n", "LastActivityDate": "2013-07-14T19:05:47.513", "CommentCount": "6", "CreationDate": "2013-07-14T19:05:47.513", "ParentId": "17642624", "Score": "2", "OwnerUserId": "596781"}});