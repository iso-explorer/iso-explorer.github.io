post_cb({"bq_ids": {"n4140": {"so_22950500_22950739_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7023}, "so_22950500_22950739_1": {"length": 20, "quality": 1.0, "section_id": 5768}}, "n3337": {"so_22950500_22950739_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6769}, "so_22950500_22950739_1": {"length": 20, "quality": 1.0, "section_id": 5541}}, "n4659": {"so_22950500_22950739_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 8520}, "so_22950500_22950739_1": {"length": 20, "quality": 1.0, "section_id": 7225}}}, "22950500": {"ViewCount": "78", "Body": "<pre><code>class A{\npublic:\nA(){\nthis-&gt;draw();\n}\n  virtual void draw()=0;\n};\n</code></pre>\n<p>Does it cause compile error. If yes, why. If no, why?</p>\n", "Title": "2 Calling pure virtual function in constructor gives an error?", "CreationDate": "2014-04-09T00:05:42.577", "Id": "22950500", "CommentCount": "3", "LastEditDate": "2014-04-09T00:16:02.627", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-04-09T02:15:53.590", "Tags": "<c++>", "Score": "-2", "OwnerUserId": "3487199", "ClosedDate": "2014-04-09T03:16:15.830", "AnswerCount": "2"}, "22950739": {"Id": "22950739", "PostTypeId": "2", "Body": "<p>First, the call of the pure virtual from the constructor is Undefined Behavior.</p>\n<p>C++11 \u00a710.4/6:</p>\n<blockquote>\n<p id=\"so_22950500_22950739_0\">\u201cthe effect of making a\n  virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed)\n  from such a constructor (or destructor) is undefined.\u201d</p>\n</blockquote>\n<p>Then your question is if UB in general, as this is, requires a diagnostic.</p>\n<p>It does not.</p>\n<p>Although notes are not <em>normative</em>, the following note from C++11 \u00a71.3.24 clarifies:</p>\n<blockquote>\n<p id=\"so_22950500_22950739_1\">\u201cPermissible undefined behavior\n  ranges from ignoring the situation completely with unpredictable results, to behaving during translation or\n  program execution in a documented manner characteristic of the environment (with or without the issuance of\n  a diagnostic message)\u201d</p>\n</blockquote>\n<p>Your compiler, with the specific options that you choose, may or may not emit a diagnostic, and then may or may not produce an executable. If it does, execution of the constructor may or may not result in some run time error. In short, it's Undefined Behavior.</p>\n<hr>\n<p><em>Why</em> is the call Undefined Behavior? Why could it not, for example, call an implementation in a derived class?</p>\n<p>Well, if it could, then code in the derived class could be executed before the derived class instance was initialized, which means that it could be executed with faulty assumptions about instance variable values, which means it could easily lead to bugs.</p>\n<p>And that's the situation in e.g. Java and C#.</p>\n<p>In C++, however, execution of code in a constructor or destructor of a class <code>T</code> is performed with the <code>*this</code> object of <strong>dynamic type</strong> <code>T</code>. Calls to virtual functions here have the same effect <em>as if</em> the object was originally instantiated as <code>T</code> (even if <code>T</code> has pure virtual functions). This ensures that the effect of the code is independent of what may be done in derived classes, that you as the <code>T</code> programmer really know what you have at hand.</p>\n<p>And with these more type safe rules there can't be any derived class implementation of the pure virtual function, because in this context there is no derived class part of the object: it's purely a <code>T</code> object.</p>\n</hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-04-09T00:45:02.567", "Score": "0", "CreationDate": "2014-04-09T00:34:18.600", "ParentId": "22950500", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2014-04-09T00:45:02.567"}, "22951605": {"Id": "22951605", "PostTypeId": "2", "Body": "<p>Yes, it will cause an error.</p>\n<p>Pure virtual functions are used to make your class abstract meaning that any class that inherits from that class must implement your virtual function.</p>\n<p>For example say you have a class B which inherits from your class A, you must implement the draw() method there, and you may call it there. But you never call a pure virtual function in the class that it is defined in.</p>\n", "LastActivityDate": "2014-04-09T02:15:53.590", "CommentCount": "0", "CreationDate": "2014-04-09T02:15:53.590", "ParentId": "22950500", "Score": "0", "OwnerUserId": "3399493"}});