post_cb({"20653456": {"ParentId": "20653322", "CommentCount": "0", "Body": "<p>it is not difficult for the compiler, it is prohibited by the standard (with one exception):\nSection 9.2.12:</p>\n<blockquote>\n<p id=\"so_20653322_20653456_0\">Nonstatic data members of a (non-union) class declared without an\n  intervening access-specifier are allocated so that later members have\n  higher addresses within a class object. The order of allocation of\n  nonstatic data members separated by an access-specifier is unspecified</p>\n</blockquote>\n<p>exception being, members with different access modifier can be reorderes so:</p>\n<pre><code>class A\n{\npublic:\n  int a;\n  int b;\nprivate:\n  int c;\n int d;\n{'\\;\n</code></pre>\n<p>a and b, cannot be reordered. c and d, cannot be reorderd, but (a and b) can be reordered wit (c and d)</p>\n", "OwnerUserId": "3054091", "PostTypeId": "2", "Id": "20653456", "Score": "1", "CreationDate": "2013-12-18T08:53:12.650", "LastActivityDate": "2013-12-18T08:53:12.650"}, "20653477": {"ParentId": "20653322", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The compiler cannot reorder because of requirements of the standard (roughly: unique, incremental adresses, and for C++ classes grouped by access modifier). </p>\n<p>That's why reordering needs to be done by hand. \nGenerally, you are lucky here: better alignment of existing data types means both smaller size and better performance, no clnflict here. </p>\n<p>However, sometimes the larger data (element) size means simpler instructions. For example, using bit fields to shave off a few bytes means much more complex code, there's a tradeoff between code size and data size; increasing an inner loop by 500 bytes to shave off 2k data can be disastrous for optimization and memory locality of the code. </p>\n<p>[edit] Tools like PVS Studio can emit a <em>warning</em> when structure element order is suboptimal and can be improved. </p>\n<hr>\n<p>[edit2] As for <em>\"Why do these rules exist\"</em>:</p>\n<p><strong>tl;dr:</strong> this is interesting but not important, it's just for the sake of curiosity. </p>\n<p>First (ruthless copy from another SO answer) the relevant sections of the standard:</p>\n<blockquote>\n<p id=\"so_20653322_20653477_0\">Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>\n<p id=\"so_20653322_20653477_1\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note ] </p>\n</blockquote>\n<p>(Note that this pertains to C, C++ is a bit more complex.)</p>\n<p>The standard says little about <em>reasons</em>, most are \"educated guesses\" here: </p>\n<p><strong>Distinct adresses</strong> is a requirement arising from other concerns of the standard. </p>\n<p><strong>Making a pointer to the struct cast-equivalent to a pointer to the first member</strong> is certainly due to existing programming practice. (It allows \"Data polymorphy\" in C by nesting the \"base struct\" as first member of the \"derived struct\")</p>\n<p><strong>Preserving the order</strong> as specified by the programmer:  </p>\n<p>The \"vanilla guess\" would be not to destroy hand-optimizations for data locality. Putting the most commonly accessed member on top may improve locality within the struct (allowing better caching, or shorter addressing instructions). If the compiler reorders, these optimizations might be lost for a comparedly small gain in total struct size. </p>\n<p><strong>C++ requiring grouping by access specifiers:</strong> (i.e. \"all public vars together, all protected vars together, all private vars together): I never found a reason for that (and I must say, it's been a bit surprising). I could imagine that (maybe) the intent was to allow compiler implementations to exploit hardware access control (\"this segment of code may not access that piece of memory\"). OTOH I know of no architecture that would allow this fine level of control, an I've never seen access specifiers been considered as a secuirty mechanism. </p>\n</hr>", "OwnerUserId": "31317", "LastEditorUserId": "31317", "LastEditDate": "2013-12-18T12:38:52.647", "Id": "20653477", "Score": "0", "CreationDate": "2013-12-18T08:54:21.097", "LastActivityDate": "2013-12-18T12:38:52.647"}, "20653389": {"ParentId": "20653322", "CommentCount": "6", "Body": "<p>It is very difficult.  A structure is specifically required to order the fields in the exact same order as the definition of the structure.</p>\n<p>This requirement was probably in reaction to Pascal not having such a requirement and causing surprising results.</p>\n<p>Anyway, not all CPU architectures require alignment or padding.  On most, it causes a slight performance penalty.  In the era of modern processors, that one or two cycles extra in the memory fetch might well disappear due to other aspects of the CPU pipeline.</p>\n", "OwnerUserId": "198536", "PostTypeId": "2", "Id": "20653389", "Score": "4", "CreationDate": "2013-12-18T08:48:52.800", "LastActivityDate": "2013-12-18T08:48:52.800"}, "20653322": {"CommentCount": "3", "ViewCount": "417", "PostTypeId": "1", "LastEditorUserId": "198536", "CreationDate": "2013-12-18T08:44:26.053", "LastActivityDate": "2013-12-18T12:38:52.647", "Title": "Memory alignment optimization of not only performance but also the memory size", "LastEditDate": "2013-12-18T08:45:33.847", "Id": "20653322", "Score": "4", "Body": "<p>We know that there is a difference in size of <code>A</code> when you define <code>A</code> like this:</p>\n<pre><code>class A \n{\n  short a;\n  double b;\n  short c;\n};\n</code></pre>\n<p>or like this </p>\n<pre><code>class A \n{\n  short a;\n  short c;\n  double b;\n};\n</code></pre>\n<p>I assume we are compiling for 32 bit OS and we have told compiler to align to 32 bits.</p>\n<p>Is it really difficult for the compiler to reorder the definitions to obtain the minimal size by also achieving the same performance?</p>\n", "Tags": "<c++><performance><memory><memory-alignment>", "OwnerUserId": "163394", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_20653322_20653477_1": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}, "so_20653322_20653456_0": {"section_id": 5873, "quality": 0.7692307692307693, "length": 20}}, "n3337": {"so_20653322_20653477_0": {"section_id": 5650, "quality": 0.575, "length": 23}, "so_20653322_20653477_1": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}, "so_20653322_20653456_0": {"section_id": 5644, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_20653322_20653477_1": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}, "so_20653322_20653456_0": {"section_id": 7356, "quality": 0.7692307692307693, "length": 20}}}});