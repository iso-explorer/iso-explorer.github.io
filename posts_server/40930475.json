post_cb({"41928071": {"ParentId": "40930475", "CommentCount": "2", "Body": "<p>\"Core Issue 1776: Replacement of class objects containing reference members\" is based on an obvious and serious interpretation error, and as such should be dismissed. The error is here:</p>\n<blockquote>\n<p id=\"so_40930475_41928071_0\">Drafting note: this maintains the status quo that malloc alone is not\n  sufficient to create an object</p>\n</blockquote>\n<p>This goes against the status quo that \"malloc alone\" is indeed sufficient to create an object, as malloc returns suitably aligned storage, which is and has always been sufficient to create an object.</p>\n<p>A core issue is not the standard. It is an opinion about the standard. That opinion is in error.</p>\n", "OwnerUserId": "963864", "PostTypeId": "2", "Id": "41928071", "Score": "-1", "CreationDate": "2017-01-30T01:54:15.700", "LastActivityDate": "2017-01-30T01:54:15.700"}, "40938486": {"ParentId": "40930475", "PostTypeId": "2", "CommentCount": "10", "Body": "<h3>On <code>create1</code></h3>\n<blockquote id=\"so_40930475_40938486_0\">\n<pre><code>std::unique_ptr&lt;Foo, destroy1&gt;(reinterpret_cast&lt;Foo*&gt;(p.release()), destroy1());\n</code></pre>\n</blockquote>\n<p>This doesn't work, because you're using the wrong pointer.</p>\n<p><code>p.release()</code> thinks it points to an <code>unsigned char[]</code>. However, that's not the object you want to point to. What you want to point to is the object that lives inside this array, the <code>Foo</code> you've created.</p>\n<p>So you are now subject to [basic.life]/8. The gist of that is that you can only use the previous pointer as a pointer to the new object if they are of the same type. Which they're not in your case.</p>\n<p>Now, I could tell you to <code>launder</code> the pointer, but the more reasonable way to handle this is to just store the pointer returned by the placement-new call:</p>\n<pre><code>auto p = std::make_unique&lt;unsigned char[]&gt;(sizeof(Foo));\nauto ret = std::unique_ptr&lt;Foo, destroy1&gt;(new(p.get()) Foo(), destroy1());\np.release();\nreturn ret;\n</code></pre>\n<p>That pointer will always be correct.</p>\n<p>Your use of of placement-new is <em>not optional</em>. [intro.object]/1 tells us:</p>\n<blockquote>\n<p id=\"so_40930475_40938486_1\">An object is created by a definition (3.1), by a new-expression (5.3.4), when implicitly changing the active member of a union (9.3), or when a temporary object is created (4.4, 12.2).</p>\n</blockquote>\n<p>When you allocate an <code>unsigned char[]</code>, that's the object you have created in that storage. You cannot simply pretend that it is a <code>Foo</code>, just because <code>Foo</code> is an aggregate. [intro.object]/1 doesn't allow that. You must explicitly create that object via one of the mechanisms listed above. Since you can't use a definition, <code>union</code> member activation, or temporary objects with arbitrary memory buffers to create objects from existing storage, the only recourse you have to create objects is a new-expression.</p>\n<p>Specifically, placement-new.</p>\n<p>As for <code>delete1</code>, you do need a custom deleter, since the default deleter will call <code>delete</code> on the <code>Foo</code> pointer. Your code is as follows:</p>\n<pre><code>auto memory = std::unique_ptr&lt;unsigned char[]&gt;(reinterpret_cast&lt;unsigned char*&gt;(p));\np-&gt;~Foo();\n</code></pre>\n<p><code>unsigned char[]</code> has some special logic to it, in terms of how it behaves when objects are allocated in their storage, thanks to [intro.object]/3-4. If the object entirely overlays the storage of the <code>unsigned char[]</code>, then it functions as if the object were allocated within the array. That means that the <code>unsigned char[]</code> is still technically there; it has not destroy the byte array.</p>\n<p>As such, you can still delete the byte array, which your code here does.</p>\n<h3>On <code>create2</code></h3>\n<p>This is also wrong, due to further violations of [basic.life]/8. A fixed version would be similar to the above:</p>\n<pre><code>auto p = malloc_ptr(reinterpret_cast&lt;unsigned char*&gt;(std::malloc(sizeof(Foo))));\nauto ret std::unique_ptr&lt;Foo, destroy2&gt;(new(p.get()) Foo(), destroy2());\np.release();\nreturn ret;\n</code></pre>\n<p>Unlike new-expressions, <code>malloc</code> never creates an object via [intro.object]/1; it only acquires storage. As such, placement-new is again required.</p>\n<p>Similarly, <code>free</code> just releases memory; it doesn't deal with objects. So your <code>delete2</code> is essentially fine (though the use of <code>malloc_ptr</code> there makes it needlessly confusing).</p>\n<h3>On <code>provide</code></h3>\n<p>This has the same [basic.life]/8 problems that the rest of your examples have:</p>\n<pre><code>alignas(Foo) static unsigned char storage[sizeof(Foo)];\nstatic auto pCandidate = std::shared_ptr&lt;Foo&gt;(new(storage) Foo(), nodelete());\nreturn pCandidate;\n</code></pre>\n<p>But other than that, it's fine (so long as you don't break it elsewhere). Why? That's complex.</p>\n<p>[basic.start.term]/1 tells us that static objects are destroyed in the reverse order of their initialization. And [stmt.decl]/4 tells us that block-scoped static objects are initialized in the order they are encountered in a function.</p>\n<p>Therefore, we know that <code>pCandidate</code> will be destroyed <em>before</em> <code>storage</code>. So long as you don't keep a copy of that <code>shared_ptr</code> in a static variable, or otherwise fail to destroy/reset all such shared objects before termination, you should be fine.</p>\n<hr>\n<p>That all being said, using blocks of <code>unsigned char</code> is really pre-C++11. We have <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow noreferrer\"><code>std::aligned_storage</code></a> and <a href=\"http://en.cppreference.com/w/cpp/types/aligned_union\" rel=\"nofollow noreferrer\"><code>std::aligned_union</code></a> now. Use them.</p>\n</hr>", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2016-12-02T21:28:21.137", "Id": "40938486", "Score": "5", "CreationDate": "2016-12-02T18:10:07.663", "LastActivityDate": "2016-12-02T21:28:21.137"}, "40930475": {"CommentCount": "4", "AcceptedAnswerId": "40938486", "LastEditDate": "2016-12-03T11:48:43.873", "LastEditorUserId": "1364752", "CreationDate": "2016-12-02T10:52:10.003", "LastActivityDate": "2017-01-30T01:54:15.700", "PostTypeId": "1", "ViewCount": "398", "FavoriteCount": "2", "Title": "clarification of specifics of P0137", "Id": "40930475", "OwnerUserId": "2015579", "Body": "<p>In the following code I have been meticulous in the following of the standard's words (plus in the light of the wording of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0137r1.html\" rel=\"noreferrer\">P0137</a>) on object lifetimes.</p>\n<p>Note that all memory allocation is through suitably-aligned storage of type unsigned char, as per P0137.</p>\n<p>Note also that <code>Foo</code> is a POD, with a trivial constructor.</p>\n<h1>Questions:</h1>\n<p>A. If I have misunderstood the standard, and there is any UB here, please kindly point it out (or alternatively confirm that there is no UB)</p>\n<p>B. Are the initialisations at A, B, C, D, E, F <em>strictly</em> necessary in light of the fact that the construction is trivial, and performs no actual initialisation. If so, please indicate which part of the standard contradicts or clarifies [object.lifetime] in this regard.</p>\n<h1>code:</h1>\n<pre><code>#include &lt;memory&gt;\n\n// a POD with trivial constructor\nstruct Foo \n{\n  int x;\n};\n\nstruct destroy1\n{\n  void operator()(Foo* p)\n  {\n    // RAII to guarantee correct destruction order\n    auto memory = std::unique_ptr&lt;unsigned char[]&gt;(reinterpret_cast&lt;unsigned char*&gt;(p));\n    p-&gt;~Foo(); // A\n  }\n};\nstd::unique_ptr&lt;Foo, destroy1&gt; create1()\n{\n  // RAII to guarantee correct exception handling\n  auto p = std::make_unique&lt;unsigned char[]&gt;(sizeof(Foo));\n  auto pCandidate = reinterpret_cast&lt;Foo*&gt;(p.get());\n  new (pCandidate) Foo(); // B\n  return std::unique_ptr&lt;Foo, destroy1&gt;(reinterpret_cast&lt;Foo*&gt;(p.release()), \n                                        destroy1());\n}\n\nstruct call_free\n{\n  void operator()(void *p) const { std::free(p); } \n};\nusing malloc_ptr = std::unique_ptr&lt;unsigned char, call_free&gt;;\n\nstruct destroy2\n{\n  void operator()(Foo *pfoo) const {\n    // RAII to guarantee correct destruction order\n    auto memory = malloc_ptr(reinterpret_cast&lt;unsigned char*&gt;(pfoo));\n    pfoo-&gt;~Foo(); // C\n  }\n};\n\nstd::unique_ptr&lt;Foo, destroy2&gt; create2()\n{\n    // RAII to guarantee correct exception handling\n  auto p = malloc_ptr(reinterpret_cast&lt;unsigned char*&gt;(std::malloc(sizeof(Foo))));\n  auto pCandidate = reinterpret_cast&lt;Foo*&gt;(p.get());\n  new (pCandidate) Foo(); // D\n  return std::unique_ptr&lt;Foo, destroy2&gt;(reinterpret_cast&lt;Foo*&gt;(p.release()), \n                                        destroy2());\n}\n\nstruct nodelete {\n  void operator()(Foo * p) {\n    p-&gt;~Foo();  // E\n  }\n};\n\nstd::shared_ptr&lt;Foo&gt; provide()\n{\n  alignas(Foo) static unsigned char  storage[sizeof(Foo)];\n\n  auto make = [] {\n    auto p = reinterpret_cast&lt;Foo*&gt;(storage);\n    new (p) Foo (); // F\n    return std::shared_ptr&lt;Foo&gt;(p, nodelete());\n  };\n\n  static std::shared_ptr&lt;Foo&gt; pCandidate = make();\n\n  return pCandidate;\n}\n\n\nint main()\n{\n  auto foo1 = create1();\n  auto foo2 = create2();\n  auto foo3 = provide();\n\n  foo1-&gt;x = 1;\n  foo2-&gt;x = 2;\n  foo3-&gt;x = 3;\n}\n</code></pre>\n", "Tags": "<c++><language-lawyer><c++1z>", "Score": "10", "AnswerCount": "2"}, "bq_ids": {"n4659": {"so_40930475_40938486_1": {"section_id": 7247, "quality": 0.8125, "length": 13}}}});