post_cb({"26078055": {"Id": "26078055", "PostTypeId": "2", "Body": "<p>The spec currently requires user-provided default constructors but it appears that GCC is implementing a change based on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253\" rel=\"nofollow\">DR 253</a> which says that if all sub-objects would be initialized without a user provided default constructor then a user-provided default constructor is not required.</p>\n<p>This change is only draft status, has not been accepted yet and is not part of the standard. So I think think this is behavior intended by GCC developers but I'm not sure if this is a conforming extension though.</p>\n<p>Here's a change to the first example which causes GCC to produce an error:</p>\n<pre><code>class A {\npublic:\n    void f() {}\n\n    int i;\n};\n\nint main()\n{\n    A a;       // OK\n    const A b; // ERROR\n\n    a.f();\n    return 0;\n}\n</code></pre>\n<p>Note that gcc downgrades the error to a warning with the -fpermissive flag.</p>\n<p><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=42844\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=42844</a></p>\n", "LastEditorUserId": "365496", "LastActivityDate": "2014-12-20T23:18:33.590", "Score": "6", "CreationDate": "2014-09-27T18:56:45.477", "ParentId": "26077807", "CommentCount": "6", "OwnerUserId": "365496", "LastEditDate": "2014-12-20T23:18:33.590"}, "bq_ids": {"n4140": {"so_26077807_26077807_0": {"length": 4, "quality": 1.0, "section_id": 3286}, "so_26077807_26077807_3": {"length": 11, "quality": 1.0, "section_id": 3286}, "so_26077807_26077807_4": {"length": 5, "quality": 1.0, "section_id": 3291}, "so_26077807_26077807_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3286}}, "n3337": {"so_26077807_26077807_0": {"length": 4, "quality": 1.0, "section_id": 3156}, "so_26077807_26077807_3": {"length": 11, "quality": 1.0, "section_id": 3156}, "so_26077807_26077807_4": {"length": 5, "quality": 1.0, "section_id": 3161}, "so_26077807_26077807_1": {"length": 13, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_26077807_26077807_4": {"length": 5, "quality": 1.0, "section_id": 4053}, "so_26077807_26077807_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 382}, "so_26077807_26077807_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 4049}}}, "26077807": {"ViewCount": "1343", "Body": "<p>Recently <a href=\"https://stackoverflow.com/questions/26077570/why-does-a-const-object-requires-a-user-provided-default-constructor#comment40859717_26077570\">Why does a const object requires a user-provided default constructor?</a> was marked a duplicate of <a href=\"https://stackoverflow.com/questions/7411515/why-does-c-require-a-user-provided-default-constructor-to-default-construct-a\">Why does C++ require a user-provided default constructor to default-construct a const object?</a>. I'm using <a href=\"http://coliru.stacked-crooked.com/\">coliru</a> and <a href=\"http://rextester.com/\">rextexter</a> to test out the various versions of gcc (g++-4.7, g++-4.8, g++-4.9) and clang (3.4 and 3.5) to see whether or not this behavior was introduced in newer versions of the compiler. Here we have two test cases, pulled from both questions respectively:</p>\n<pre><code>class A {\npublic:\n    void f() {}\n\n};\n\nint main()\n{\n    A a;       // OK\n    const A b; // ERROR\n\n    a.f();\n    return 0;\n}\n</code></pre>\n<p>and:</p>\n<pre><code>struct B{\n  B():x(42){}\n  int doSomeStuff() const{return x;}\n  int x;\n};\n\nstruct A{\n  A(){}//other than \"because the standard says so\", why is this line required?\n\n  B b;//not required for this example, just to illustrate\n      //how this situation isn't totally useless\n};\n\nint main(){\n  const A a;\n}\n</code></pre>\n<p>clang errors out with:</p>\n<pre><code> error: default initialization of an object of const type 'const A' requires a user-provided default constructor\n  A const a;\n          ^\n</code></pre>\n<p>expectedly but not gcc and neither does MSVC. I thought perhaps I might be going crazy because the standard quotes clearly say:</p>\n<p>\u00a7 8.5</p>\n<blockquote>\n<p id=\"so_26077807_26077807_0\">6 To default-initialize an object of type T means: </p>\n<p id=\"so_26077807_26077807_1\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9), the default constructor\n  for T is called (and the initialization is ill-formed if T has no\n  accessible default constructor); </p>\n<p id=\"so_26077807_26077807_2\">[...] </p>\n<p id=\"so_26077807_26077807_3\">If a program calls for the\n  default initialization of an object of a const-qualified type T, T\n  shall be a class type with a user-provided default constructor.</p>\n<p id=\"so_26077807_26077807_4\">11 If no initializer is specified for an object, the object is\n  default-initialized; [...]</p>\n</blockquote>\n<p>The non-POD language present in the second question seems to be missing from n3337 so perhaps I'm missing something that might've changed. Is this a bug, duplicate or am I missing something?</p>\n", "AcceptedAnswerId": "26078055", "Title": "Why does gcc allow a const object without a user-declared default constructor but not clang?", "CreationDate": "2014-09-27T18:28:37.547", "LastActivityDate": "2014-12-20T23:18:33.590", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "OwnerDisplayName": "user3920237", "Id": "26077807", "Score": "10", "Tags": "<c++><gcc><clang>", "AnswerCount": "1"}});