post_cb({"bq_ids": {"n4140": {"so_48576514_48577182_2": {"length": 13, "quality": 1.0, "section_id": 3919}, "so_48576514_48577182_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3919}}, "n3337": {"so_48576514_48577182_2": {"length": 13, "quality": 1.0, "section_id": 3779}, "so_48576514_48577182_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3779}}, "n4659": {"so_48576514_48577182_2": {"length": 13, "quality": 1.0, "section_id": 4805}, "so_48576514_48577182_0": {"length": 18, "quality": 1.0, "section_id": 4805}}}, "48576514": {"ViewCount": "69", "Body": "<p>For classes with mutex as members, when I create the copy constructor, I need to decide which mutex to lock. For the following code, I am wondering why I only need to lock <strong>rhs.mu_</strong> but don't have to lock <strong>this-&gt;mu_</strong>? Could it be possible that the copy constructor being called by multiple threads for the same object?</p>\n<pre><code>class Obj {\n public:\n  std::mutex mu_;\n  std::string data_;\n\n  // copy ctor\n  Obj(const Obj&amp; rhs) {\n    std::unique_lock&lt;std::mutex&gt; lk(rhs.mu_); // why only lock rhs.mu_?\n    data_ = rhs.data_;\n  }\n}\n</code></pre>\n<p><strong>Updates:</strong>\nIs this piece of code calling the copy ctor at the same time using <strong>new</strong>?</p>\n<pre><code>Obj* t = nullptr;\nObj someObj;\n\n// ... populate someObj\n\nstd::thread t1([&amp;]() { t = new Obj(someObj); });\nstd::thread t2([&amp;]() { t = new Obj(someObj); });\n</code></pre>\n", "AcceptedAnswerId": "48577883", "Title": "Copy ctor with mutex as data member", "CreationDate": "2018-02-02T05:55:14.013", "LastActivityDate": "2018-02-03T00:52:14.333", "CommentCount": "8", "LastEditDate": "2018-02-02T18:18:37.983", "PostTypeId": "1", "LastEditorUserId": "1804543", "Id": "48576514", "Score": "0", "OwnerUserId": "1804543", "Tags": "<c++><mutex>", "AnswerCount": "2"}, "48577182": {"Id": "48577182", "PostTypeId": "2", "Body": "<p>If your variable is local, it's unaccessible to other threads during construction, because other thread can't name a local variable in this thread.</p>\n<p>If your variable has static lifetime, thread safety is guaranteed by C++ standard:</p>\n<p><a href=\"http://www.eel.is/c++draft/stmt.dcl#4\" rel=\"nofollow noreferrer\">[stmt.dcl]</a></p>\n<blockquote>\n<p id=\"so_48576514_48577182_0\">Dynamic initialization of a block-scope variable with static storage duration or thread storage duration is performed the first time control passes through its declaration; </p>\n<p id=\"so_48576514_48577182_1\">...</p>\n<p id=\"so_48576514_48577182_2\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>Thus the constructor won't be called twice.</p>\n", "LastActivityDate": "2018-02-02T06:50:01.993", "Score": "3", "CreationDate": "2018-02-02T06:50:01.993", "ParentId": "48576514", "CommentCount": "0", "OwnerUserId": "8605791"}, "48577883": {"Id": "48577883", "PostTypeId": "2", "Body": "<p>You'll need to lock the mutex of the copied-from object (to make sure you're copying an object in a consistent state), while you can leave alone the lock of the object being constructed. </p>\n<p>This is true in general for constructors: a constructor call is single-thread by definition:</p>\n<ul>\n<li>local variables are local to the current thread (as the stack is per-thread); an instance of them is constructed whenever a particular thread enters the relevant scope;</li>\n<li>thread local variables are thread local (duh), the construction of each thread local instance happens in the relevant thread;</li>\n<li>static storage duration variables (globals, <code>static</code> locals, <code>static</code> class fields) are guaranteed to be initialized once by the standard (the compiler injects something similar to <code>call_once</code>);</li>\n<li>objects allocated through \"regular\" <code>new</code> are, again, safe, as each thread running an expression like <code>new A</code> will allocate a different instance over which the constructor will run.</li>\n</ul>\n<p>The only problem you can have is if some client of yours plays with placement <code>new</code>, but in that case I'd argue that it's the caller's responsibility not to call placement <code>new</code> constructor concurrently over the same object - as:</p>\n<ul>\n<li>even in the non concurrent case, calling placement <code>new</code> twice over the same memory location (without a destructor call in between) is a contract violation on your caller's part, so serializing through a mutex in your constructor would not solve anything;</li>\n<li>besides, a mutex instance member wouldn't solve anything, as you'd have a race condition anyway on the initialization of the mutex itself. To make it work you would need a global mutex, and you'd still not solve the point above. </li>\n</ul>\n<p>So, long story short, don't worry about locking <em>the object being constructed</em> in construction. The language guarantees you that object construction is nonconcurrent. </p>\n", "LastEditorUserId": "214671", "LastActivityDate": "2018-02-03T00:52:14.333", "Score": "2", "CreationDate": "2018-02-02T07:38:42.047", "ParentId": "48576514", "CommentCount": "0", "OwnerUserId": "214671", "LastEditDate": "2018-02-03T00:52:14.333"}});