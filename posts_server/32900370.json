post_cb({"bq_ids": {"n4140": {"so_32900370_32900419_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 5804}}, "n3337": {"so_32900370_32900419_2": {"length": 4, "quality": 0.5714285714285714, "section_id": 5577}}, "n4659": {"so_32900370_32900419_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 7687}}}, "32900370": {"ViewCount": "197", "Body": "<p>Will the 2nd line of the following code</p>\n<pre><code>int bar;\nint foo = bar * 3 * 5;\n</code></pre>\n<p>be optimized to</p>\n<pre><code>int bar;\nint foo = bar * 15;\n</code></pre>\n<p>Or even more:</p>\n<pre><code>int foo = 3 * bar * 5;\n</code></pre>\n<p>can be optimized?</p>\n<p>The purpose is actually to ask if I can just write</p>\n<pre><code>int foo = bar * 3 * 5;\n</code></pre>\n<p>instead of</p>\n<pre><code>int foo = bar * (3 * 5);\n</code></pre>\n<p>to save the parentheses. (and the relieve the need to manually manipulate those constant ordering =&gt; and in many case grouping constants with related variables are more meaningful rather than grouping constants for optimization)</p>\n", "AcceptedAnswerId": "32900419", "Title": "Will C/C++ compiler do reorder for commutative operators (eg: +, *) to optimize constants", "CreationDate": "2015-10-02T03:58:59.940", "Id": "32900370", "CommentCount": "15", "PostTypeId": "1", "LastActivityDate": "2015-10-02T13:36:06.950", "Score": "4", "OwnerUserId": "4007560", "Tags": "<c++><optimization>", "AnswerCount": "3"}, "32900408": {"Id": "32900408", "PostTypeId": "2", "Body": "<p>A given implementation may or may not optimise any of those expressions. If you really want to know what it's doing for a given set of inputs, examine the generated assembler code.</p>\n<p>But there's no guarantee you'll get the same optimisation from another compiler, the same compiler with different options or even the exact same compiler/options on Tuesday a week from now.</p>\n<p>The general rule to follow is the <strong><em>\"as if\"</em></strong> rule, the compiler does things <em>as if</em> it was doing exactly what is specified in the standard. That doesn't mean it has to do it in any given way.</p>\n<p>In other words, a compiler if free to do whatever it wants as long as it has the same effect as what the standard mandates.</p>\n<p>The standard actually starts focusing on this aspect very early on, in the definitions section <code>3.4</code>, where it defines behaviour as the \"<strong><em>external</em></strong> appearance or action\", and further examples pepper the document throughout.</p>\n", "LastEditorUserId": "14860", "LastActivityDate": "2015-10-02T07:49:35.090", "Score": "2", "CreationDate": "2015-10-02T04:04:50.437", "ParentId": "32900370", "CommentCount": "0", "OwnerUserId": "14860", "LastEditDate": "2015-10-02T07:49:35.090"}, "32900419": {"Id": "32900419", "PostTypeId": "2", "Body": "<p>Almost all compilers will do it for integers, because even if a constant collapse might overflow in a different way, overflow may be ignored by the standard, so they can do what they like.</p>\n<p>It often will not work for floating point values if it's adhering to strict floating point math; the order of evaluation with floating point math can affect the outcome, so strict compliance can't reorder floating point math.</p>\n<blockquote>\n<p id=\"so_32900370_32900419_0\">5.1.2.3 Program execution</p>\n<p id=\"so_32900370_32900419_1\">[#1] The semantic descriptions in this International Standard describe the behavior of an abstract machine in which issues of optimization are irrelevant.</p>\n<p id=\"so_32900370_32900419_2\">[#3] In the abstract machine, all expressions are evaluated as specified by the semantics.</p>\n<p id=\"so_32900370_32900419_3\">[#13] EXAMPLE 5 Rearrangement for floating-point expressions is often restricted because of limitations in precision as well as range. The implementation cannot generally apply the mathematical associative rules for addition or multiplication, nor the distributive rule, because of roundoff error, even in the absence of overflow and underflow. (<a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf#page=27\">Source</a>)</p>\n</blockquote>\n<p>It's not describing the use with constants precisely, but it's clearly noting that seemingly equivalent operations are not actually equivalent in the bizarro world that is floating point arithmetic (e.g. <code>x / 5.0</code> cannot be translated to <code>x * 0.2</code> with complete equivalence, <code>x + x * y</code> cannot be equivalently represented as <code>x * (1.0 + y)</code>).</p>\n", "LastEditorUserId": "364696", "LastActivityDate": "2015-10-02T04:36:34.270", "Score": "7", "CreationDate": "2015-10-02T04:06:31.660", "ParentId": "32900370", "CommentCount": "3", "OwnerUserId": "364696", "LastEditDate": "2015-10-02T04:36:34.270"}, "32900464": {"Id": "32900464", "PostTypeId": "2", "Body": "<p>Here's an example of what an optimizer will do.  Compiling this code with g++ 4.9.2 using -O2:</p>\n<pre><code>int calculate(int bar)     \n{\n    return bar*3*5;\n}\n</code></pre>\n<p>is translated into this assembly code:</p>\n<pre><code>movl    %edi, %eax        # copy argument into eax\nsall    $4, %eax          # shift eax left 4 bits\nsubl    %edi, %eax        # subtract original value from eax\nret                       # return (with eax as result)\n</code></pre>\n<p>Not only did it not do two multiplications, it didn't even do one.  It converted the multipication by 15 into something equivalent to this:</p>\n<pre><code>int calculate(int bar)     \n{\n    return (bar&lt;&lt;4)-bar;\n}\n</code></pre>\n", "LastEditorUserId": "951890", "LastActivityDate": "2015-10-02T13:36:06.950", "Score": "3", "CreationDate": "2015-10-02T04:15:00.557", "ParentId": "32900370", "CommentCount": "2", "OwnerUserId": "951890", "LastEditDate": "2015-10-02T13:36:06.950"}});