post_cb({"bq_ids": {"n4140": {"so_42369314_42369314_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 5957}, "so_42369314_42369766_1": {"length": 4, "quality": 0.8, "section_id": 5957}, "so_42369314_42369314_0": {"length": 61, "quality": 0.9682539682539683, "section_id": 5464}}, "n3337": {"so_42369314_42369314_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 5726}, "so_42369314_42369766_1": {"length": 4, "quality": 0.8, "section_id": 5726}, "so_42369314_42369314_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 5251}}, "n4659": {"so_42369314_42369314_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 7445}, "so_42369314_42369766_1": {"length": 4, "quality": 0.8, "section_id": 7445}, "so_42369314_42369314_0": {"length": 59, "quality": 0.9365079365079365, "section_id": 6898}}}, "42369766": {"Id": "42369766", "PostTypeId": "2", "Body": "<p>I think the standard contradicts itself here as you have in 5.1.1/11</p>\n<blockquote>\n<p id=\"so_42369314_42369766_0\">The result is the enumerator. (1) </p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_42369314_42369766_1\">The type of the result is the type of the enumeration. (2)</p>\n</blockquote>\n<p>If (1) is true, then the result type shall be the type of the enumerator, which, according to 7.2/5, is either the underlying type of the enumeration or the type defined by the enumeration depending if it is before or after the closing brace.</p>\n<p>Meaning that your code sample should compile fine because <code>E::B</code> is <code>B</code> and the type of <code>B</code> is <code>short</code>.</p>\n<p>Now if you take (2) into account, it does not change anything after the closing brace. But if (2) is true before the closing brace, it means that the type of <code>E::B</code> is <code>E</code> and at the same time the type of <code>B</code> is <code>short</code>, so you end up with <code>E::B != B</code> which contradicts (1).</p>\n", "LastActivityDate": "2017-02-21T14:15:51.413", "Score": "3", "CreationDate": "2017-02-21T14:15:51.413", "ParentId": "42369314", "CommentCount": "0", "OwnerUserId": "2667360"}, "42369314": {"ViewCount": "211", "Body": "<p>In C++, specifically in C++14 n4296, there are two paragraps talking about type of an enumerator, which seem to be contradictory to me. See 7.2/5 (which is 10.2/5 in <code>n4659</code>):</p>\n<blockquote>\n<p id=\"so_42369314_42369314_0\">Each enumeration defines a type that is different from all other types. Each enumeration also has an underlying type. The underlying type can be explicitly specified using an enum-base. For a scoped enumeration type, the underlying type is int if it is not explicitly specified. In both of these cases, the underlying type is said to be fixed. Following the closing brace of an enum-specifier, each enumerator has the type of its enumeration. <strong>If the underlying type is fixed, the type of each enumerator prior to the closing brace is the underlying type</strong> and the constant-expression in the enumerator-definition shall be a converted constant expression of the underlying type [...]</p>\n</blockquote>\n<p>And 5.1.1/11 (which is 8.1.4.2/4 in <code>n4659</code>) writes:</p>\n<blockquote>\n<p id=\"so_42369314_42369314_1\">A nested-name-specifier that denotes an enumeration (7.2), followed by the name of an enumerator of that enumeration, is a qualified-id that refers to the enumerator. The result is the enumerator. <strong>The type of the result is the type of the enumeration.</strong> The result is a prvalue.</p>\n</blockquote>\n<p>Then, what happens when we refer to an enumerator through nested-name-specifier prior to closing brace of the declaration? Take for example the following snippet:</p>\n<pre><code>template &lt; typename T1, typename T2 &gt;\nstruct fail_if_not_same {\n    static_assert(std::is_same&lt;T1, T2&gt;::value, \"Fail!\");\n    static constexpr int value = 0;\n};\n\nenum class E : short {\n    A,\n    B = A + 1,\n    C = fail_if_not_same&lt;decltype(B), short&gt;::value,\n    D = fail_if_not_same&lt;decltype(E::B), short&gt;::value\n};\n</code></pre>\n<p>What is the type of the expression <code>E::B</code> above? Is this a contradiction in standard? Both gcc and clang follows the 7.2/5.</p>\n", "AcceptedAnswerId": "42369766", "Title": "Type of an enumerator in the declaration of its enum", "CreationDate": "2017-02-21T13:56:47.760", "Id": "42369314", "CommentCount": "1", "LastEditDate": "2017-11-23T20:43:55.447", "PostTypeId": "1", "LastEditorUserId": "6209703", "LastActivityDate": "2017-11-23T20:43:55.447", "Score": "6", "OwnerUserId": "6209703", "Tags": "<c++><c++14><language-lawyer><enumerator>", "AnswerCount": "1"}});