post_cb({"17277487": {"CommentCount": "11", "AcceptedAnswerId": "17277945", "PostTypeId": "1", "LastEditorUserId": "322333", "CreationDate": "2013-06-24T14:05:47.867", "LastActivityDate": "2013-06-24T23:05:57.187", "LastEditDate": "2013-06-24T15:22:55.133", "ViewCount": "1302", "FavoriteCount": "2", "Title": "Why won't template parameter pack be deduced to multiple type arguments in function call?", "Id": "17277487", "Score": "18", "Body": "<p>I have a class templated on a type parameter and parameter pack, and am confused about type-deduction of this type; while writing an output-streaming operator I discovered a parameter pack on <code>operator&lt;&lt;</code> will not match both the type and pack parameters for the template class:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T, class... Ts&gt;\nstruct foo\n{ /* ... */ };\n\ntemplate&lt; class... Ts &gt;\nstd::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const foo&lt;Ts...&gt;&amp; )\n{\n  return os &lt;&lt; 42;\n}\n\n\nint main()\n{\n  std::cout &lt;&lt; foo&lt;int&gt;();\n}\n</code></pre>\n<p>This fails to compile on both gcc-4.7.2 and clang-3.0, so I guess I'm misunderstanding the rules here.</p>\n<p>gcc says (where line 16 is the output stream call):</p>\n<pre><code>t.cpp:16:28: error: cannot bind \u2018std::ostream {aka std::basic_ostream&lt;char&gt;}\u2019 lvalue to \u2018std::basic_ostream&lt;char&gt;&amp;&amp;\u2019\nIn file included from /usr/lib/gcc/x86_64-redhat-linux/4.7.2/../../../../include/c++/4.7.2/iostream:40:0,\n                 from t.cpp:1:\n/usr/lib/gcc/x86_64-redhat-linux/4.7.2/../../../../include/c++/4.7.2/ostream:600:5: error:   initializing argument 1 of \u2018std::basic_ostream&lt;_CharT, _Traits&gt;&amp; std::operator&lt;&lt;(std::basic_ostream&lt;_CharT, _Traits&gt;&amp;&amp;, const _Tp&amp;) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Tp = foo&lt;int&gt;]\u2019\n</code></pre>\n<p>and clang says:</p>\n<pre><code>t.cpp:16:16: error: invalid operands to binary expression ('ostream' (aka 'basic_ostream&lt;char&gt;') and 'foo&lt;int&gt;')\n        std::cout &lt;&lt; foo&lt;int&gt;();\n        ~~~~~~~~~ ^  ~~~~~~~~~~\n\n[--- snip: lots of non-viable candidates from standard library ---]\n\nt.cpp:8:19: note: candidate template ignored: substitution failure [with Ts = &lt;&gt;]\n    std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const foo&lt;Ts...&gt;&amp; )\n                  ^\n</code></pre>\n<p>Could someone please enlighten me as to why the parameter pack for <code>operator&lt;&lt;</code> cannot be deduced to be the type parameter <em>and</em> parameter pack for <code>foo</code>?</p>\n", "Tags": "<c++><c++11><variadic-templates>", "OwnerUserId": "322333", "AnswerCount": "2"}, "17286565": {"ParentId": "17277487", "CommentCount": "0", "Body": "<p>Wow, I would have thought this was fixed already, but it still doesn't work in prerelease GCC 4.9 and Clang 3.4 builds (courtesy <a href=\"http://coliru.stacked-crooked.com/\" rel=\"nofollow\">Coliru</a>).</p>\n<p>The workaround is simple: use partial specialization to deduce the template arguments elsewhere.</p>\n<pre><code>template&lt;class... Ts&gt;\nstruct foo; // unimplemented\n\ntemplate&lt;class T, class... Ts&gt;\nstruct foo&lt; T, Ts ... &gt; // specialization for at least one argument\n{ /* ... */ };\n\ntemplate&lt; class... Ts &gt;\nstd::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const foo&lt;Ts...&gt;&amp; )\n{\n  return os &lt;&lt; 42;\n}\n</code></pre>\n<p>Why <em>both</em> GCC and Clang can't solve this years-old bug by imitating the workaround in the general case, I don't know. The compiler vendors are perhaps facing an unfortunate choice between performance and correctness.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "17286565", "Score": "0", "CreationDate": "2013-06-24T23:05:57.187", "LastActivityDate": "2013-06-24T23:05:57.187"}, "17277945": {"CommentCount": "4", "CreationDate": "2013-06-24T14:28:02.750", "CommunityOwnedDate": "2013-06-24T16:07:07.310", "LastEditorUserId": "1131467", "LastActivityDate": "2013-06-24T16:07:07.310", "ParentId": "17277487", "PostTypeId": "2", "LastEditDate": "2013-06-24T16:07:07.310", "Id": "17277945", "Score": "11", "Body": "<p>What is happening is that a template function with a template parameter pack <code>class... Ts</code>, and a parameter type (P) of <code>foo&lt;Ts...&gt;</code> is being deduced against an argument type (A) of <code>foo&lt;int&gt;</code>.</p>\n<p>14.8.2.5/9 says of this:</p>\n<blockquote>\n<p id=\"so_17277487_17277945_0\">If P has a form that contains <code>&lt;T&gt;</code> or <code>&lt;i&gt;</code> [it does], then each argument Pi [<code>Ts...</code>] of the respective template argument list\n  P is compared with the corresponding argument Ai [<code>int</code>] of the corresponding template argument list of A. If\n  the template argument list of P contains a pack expansion that is not the last template argument, the\n  entire template argument list is a non-deduced context. [the pack expansion is last, so the previous doesnt apply] <strong>If Pi is a pack expansion [<code>Ts...</code>, it is], then the pattern of Pi\n  is compared with each remaining argument in the template argument list of A (<code>int</code>). Each comparison deduces\n  template arguments for subsequent positions in the template parameter packs expanded by Pi.</strong></p>\n</blockquote>\n<p>So <code>class... Ts</code> should be deduced as the one element list <code>int</code>, and consequently the function template should be instantiated with the parameter type <code>const foo&lt;int&gt;&amp;</code>, and be viable.</p>\n<p>It is a compiler bug.  Your code is well-formed.</p>\n<p>More succinctly this is well-formed:</p>\n<pre><code>template&lt;class A, class... B&gt; struct S { };\n\ntemplate&lt;class... C&gt; void f(S&lt;C...&gt;) { }\n\nint main() { f(S&lt;int&gt;()); }\n</code></pre>\n<p>but fails similarly on at least gcc 4.7.2 with:</p>\n<pre><code> error: parameter 1 of \u2018void f(S&lt;C ...&gt;) [with C = {int, C}]\u2019\n        has incomplete type \u2018S&lt;int, C&gt;\u2019\n</code></pre>\n<p><code>C</code> is incorrectly deduced as <code>C = {int, C}</code> (a nonsensical recursion) instead of <code>C = {int}</code>.  The broken deduction of <code>C</code> leads to further garbage that <code>S&lt;int, C&gt;</code> has an incomplete type.</p>\n", "OwnerUserId": "1131467"}, "bq_ids": {"n4140": {"so_17277487_17277945_0": {"section_id": 340, "quality": 0.8548387096774194, "length": 53}}, "n3337": {"so_17277487_17277945_0": {"section_id": 330, "quality": 0.8548387096774194, "length": 53}}, "n4659": {"so_17277487_17277945_0": {"section_id": 349, "quality": 0.8548387096774194, "length": 53}}}});