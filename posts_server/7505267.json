post_cb({"7505531": {"ParentId": "7505267", "CommentCount": "2", "Body": "<p>Apart from the relevant answer given by @bdonlan, note also that <code>f(n) = n * log(n)</code> does have a well-defined limit as <code>n</code> goes to zero, namely <code>0</code>. This is because the logarithm diverges more slowly than any polynomial, in particular, slower than <code>n</code>. So all is well :-)</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "7505531", "Score": "3", "CreationDate": "2011-09-21T19:30:38.090", "LastActivityDate": "2011-09-21T19:30:38.090"}, "7505267": {"CommentCount": "1", "CreationDate": "2011-09-21T19:08:09.100", "PostTypeId": "1", "AcceptedAnswerId": "7505576", "LastEditorUserId": "-1", "LastActivityDate": "2011-09-21T19:41:56.977", "LastEditDate": "2017-05-23T12:16:47.310", "ViewCount": "427", "FavoriteCount": "2", "Title": "Is it defined to provide an empty range to C++ standard algorithms?", "Id": "7505267", "Score": "3", "Body": "<p>Following on from <a href=\"https://stackoverflow.com/questions/7504921/is-it-defined-to-provide-an-inverted-range-to-c-standard-algorithms\">my previous question</a>, <strong>can we <em>prove</em> that the standard allows us to pass an empty range to a standard algorithm?</strong></p>\n<p>Paragraph 24.1/7 defines an \"empty range\" as the range <code>[i,i)</code> (where <code>i</code> is valid), and <code>i</code> would appear to be \"reachable\" from itself, but I'm not sure that this qualifies as a proof. </p>\n<p>In particular, we run into trouble when looking at the sorting functions. For example, <code>std::sort</code>:</p>\n<blockquote>\n<p id=\"so_7505267_7505267_0\">Complexity: <code>O(N log(N))</code> (where <code>N</code> == <code>last</code> - <code>first</code>) comparisons</p>\n</blockquote>\n<p>Since <code>log(0)</code> is generally considered to be undefined, and I don't know what <code>0*undefined</code> is, could there be a problem here?</p>\n<hr>\n<p><sup>(Yes, ok, I'm being a bit pedantic. Of course no self-respecting <em>stdlib</em> implementation would cause a practical problem with an empty range passed to <code>std::sort</code>. But I'm wondering whether there's a potential hole in the standard wording here.)</sup></p>\n</hr>", "Tags": "<c++><c++11><language-lawyer><std>", "OwnerUserId": "560648", "AnswerCount": "3"}, "7505295": {"ParentId": "7505267", "LastEditDate": "2011-09-21T19:41:56.977", "CommentCount": "5", "CreationDate": "2011-09-21T19:10:38.010", "OwnerUserId": "36723", "LastEditorUserId": "36723", "PostTypeId": "2", "Id": "7505295", "Score": "10", "Body": "<p>Big-O notation is defined in terms of the limit of the function. An algorithm with <em>actual</em> running time <code>g(N)</code> is <code>O(f(N))</code> if and only if <strike><code>lim N\u2192\u221e g(N)/f(N)</code> is a non-negative real number</strike> <code>g(N)/f(N)</code> is less than some positive real number <code>C</code> for all values <code>N</code> greater than some constant <code>k</code> (the exact values of <code>C</code> and <code>k</code> are immaterial; you just have to be able to find <em>any</em> <code>C</code> and <code>k</code> that makes this true). (thanks for the correction, Jesse!)</p>\n<p>You'll note that the <em>actual</em> number of elements is not relevant in big-O analysis. Big-O analysis says nothing about the behavior of the algorithm for small numbers of elements; therefore, it does not matter if <code>f(N)</code> is defined at <code>N=0</code>. More importantly, the <em>actual</em> runtime behavior is controlled by a <em>different</em> function <code>g(N)</code>, which may well be defined at <code>N=0</code> even if <code>f(0)</code> is undefined.</p>\n", "LastActivityDate": "2011-09-21T19:41:56.977"}, "7505576": {"ParentId": "7505267", "LastEditDate": "2011-09-21T19:39:54.740", "CommentCount": "1", "CreationDate": "2011-09-21T19:33:51.997", "OwnerUserId": "179910", "LastEditorUserId": "179910", "PostTypeId": "2", "Id": "7505576", "Score": "6", "Body": "<p>I don't seem <em>much</em> room for question. In \u00a724.1/6 we're told:</p>\n<blockquote>\n<p id=\"so_7505267_7505576_0\">An iterator j is called reachable from an iterator i if and only if there is a finite sequence of applications of the expression ++i that makes i == j.</p>\n</blockquote>\n<p>and in $24.1/7:</p>\n<blockquote>\n<p id=\"so_7505267_7505576_1\">Range [i, j) is valid if and only if j is reachable from i.</p>\n</blockquote>\n<p>Since <code>0</code> is finite, <code>[i, i)</code> is a valid range. \u00a724.1/7 goes on to say:</p>\n<blockquote>\n<p id=\"so_7505267_7505576_2\">The result of the application of functions in the library to invalid ranges is\n  undefined.</p>\n</blockquote>\n<p>That doesn't go quite so far as to say that a valid range guarantees defined results (reasonable, since there are other requirements, such as on the comparison function) but certainly seems to imply that a range being empty, in itself, should not lead to UB or anything like that. In particular, however, the standard makes an empty range just another valid range; there's no real differentiation between empty and non-empty valid ranges, so what applies to a non-empty valid range applies equally well to an empty valid range.</p>\n", "LastActivityDate": "2011-09-21T19:39:54.740"}, "bq_ids": {"n4140": {"so_7505267_7505576_0": {"section_id": 5560, "quality": 0.9, "length": 9}, "so_7505267_7505267_0": {"section_id": 1402, "quality": 0.6666666666666666, "length": 4}, "so_7505267_7505576_2": {"section_id": 5561, "quality": 0.875, "length": 7}}, "n3337": {"so_7505267_7505576_0": {"section_id": 5342, "quality": 0.9, "length": 9}, "so_7505267_7505267_0": {"section_id": 1396, "quality": 0.6666666666666666, "length": 4}, "so_7505267_7505576_2": {"section_id": 5343, "quality": 0.875, "length": 7}}, "n4659": {"so_7505267_7505576_0": {"section_id": 7007, "quality": 0.9, "length": 9}, "so_7505267_7505267_0": {"section_id": 1523, "quality": 0.6666666666666666, "length": 4}, "so_7505267_7505576_2": {"section_id": 7008, "quality": 0.875, "length": 7}}}});