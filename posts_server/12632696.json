post_cb({"bq_ids": {"n4140": {"so_12632696_12633038_0": {"length": 32, "quality": 0.6037735849056604, "section_id": 87}, "so_12632696_12633038_1": {"length": 70, "quality": 0.9333333333333333, "section_id": 87}}, "n3337": {"so_12632696_12633038_0": {"length": 30, "quality": 0.5660377358490566, "section_id": 82}, "so_12632696_12633038_1": {"length": 70, "quality": 0.9333333333333333, "section_id": 82}}}, "12633038": {"Id": "12633038", "PostTypeId": "2", "Body": "<p>C++98 says that non-type template arguments shall be one of</p>\n<blockquote id=\"so_12632696_12633038_0\">\n<ul>\n<li>an integral <em>constant-expression</em> of integral or enumeration type; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>the name of an object or function with external linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed as <em>id-expression</em>; or</li>\n<li>the address of an object or function with external linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed as &amp;<em>id-expression</em> where the &amp; is option if the name refers to a function or array; or</li>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n</ul>\n</blockquote>\n<p>Null pointers do not fall under any item of this list, and therefore it is not valid to pass a null pointer as a non-type template parameter.</p>\n<p>C++11 updates this list to</p>\n<blockquote id=\"so_12632696_12633038_1\">\n<ul>\n<li>for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the <em>template-parameter</em>; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a function with external or internal linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as &amp; <em>id-expression</em>, except that the &amp; may be omitted if the name refers to a function or array and shall be omitted if the corresponding <em>template-parameter</em> is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n</ul>\n</blockquote>\n<p>The updated requirements do cover null pointers. Therefore, to use null pointers as non-type template arguments you must use C++11.</p>\n", "LastEditorUserId": "365496", "LastActivityDate": "2012-09-28T04:07:59.633", "CommentCount": "3", "CreationDate": "2012-09-28T03:01:44.470", "ParentId": "12632696", "Score": "5", "OwnerUserId": "365496", "LastEditDate": "2012-09-28T04:07:59.633"}, "12632696": {"ViewCount": "4616", "Body": "<p>I understand from bunch of other Stackoverflow threads (like <a href=\"https://stackoverflow.com/questions/1418019/casting-pointer-as-template-argument-comeau-msvc-compile-gcc-fails\">this</a>) that Template arguments are evaluated at Compile Time. \nAlso, non-type template-parameter should be either a constant expression, integral expression or pointer to an object with external linkage.</p>\n<p>And, I am not using --std=c++0x in my g++ command in Makefile.</p>\n<p>So, is it possible to instantiate a template class with NULL passed as argument?</p>\n<pre><code>// I have a template class like this - \ntemplate&lt;class T, T invalidVal, int e&gt; class A\n{ \n    static inline bool dummy(T value) \n    {\n       return 0;\n    }\n}\n\n#define MY_INVALID_VAL ((void *)0)\n\n// Now I want create class from the above template class with \n// T=void*, invalidVal=NULL &amp; e=0 \ntypedef A&lt;void *, MY_INVALID_VAL, 1&gt; ClassA;\n</code></pre>\n<p>The above code compiles fine on MS Visual Studio 2008.\nOn g++ - I get the error - \"a cast to a type other than an integral or enumeration type cannot appear in a constant-expression\"</p>\n<p>I tried out a few options after googling -</p>\n<p>Declare \"extern void *MY_INVALID_VAL;\" in a header file - include it and do\n  void <em>MY_INVALID_VAL=NULL; before template instantiation.\n  In that case, I get error \"MY_INVALID_VAL is not a valid template argument for type  'void</em>' because it is not a constant pointer\" </p>\n<p>So my question is -\nIs there no way of instantiating a template class with NULL argument without using c++0x standard?</p>\n<p>Thanks!</p>\n<p>EDIT:</p>\n<p>Thanks for all the comments and thanks for citing exact section from standards' draft.</p>\n<p>Just listing down the things I tried -</p>\n<p>1) Passing \"0\" directly doesn't work.\n   Error I get is - \"could not convert '0' to template argument void *\"</p>\n<p>2) Declaring static const void *my_null=0; and passing my_null doesn't work.\n   It gave error - \"my_null can not appear in constant expression\"</p>\n<p>3) Tried the pointer to null Object (null object pattern) approach suggested in one of the comments \n   See below -</p>\n<pre><code>class my_null\n{\n public:\n     my_null() { my_null_ptr = NULL; }\n     void * get() { return my_null_ptr; }\n private:\n    void *my_null_ptr;\n};\nmy_null my_null_obj;\nmy_null *ptr = &amp;my_null_obj;\n\ntypedef A&lt;void *, (void *)ptr, 1&gt; ClassA;\n</code></pre>\n<p>Still I get error - \"ptr can not appear in constant expression\"</p>\n<p>So now this has me wondering - what value should I pass to make it work?\nOr is there no possible to make it work? (I mean a way that does not involve using c++11 std)\nI haven't -yet- found a value that will succeed the compilation.</p>\n<p>Any help appreciated (and needed :-P)!</p>\n<p>As a sidenote, one more thing that I would want to ask is - is there any pointer value that I can use for non-type template argument?</p>\n", "AcceptedAnswerId": "12633038", "Title": "Instantiating a template class with NULL argument", "CreationDate": "2012-09-28T02:13:01.710", "Id": "12632696", "CommentCount": "2", "LastEditDate": "2017-05-23T10:28:24.583", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-28T18:09:22.813", "Score": "3", "OwnerUserId": "922421", "Tags": "<c++><templates><g++>", "AnswerCount": "2"}, "12632958": {"PostTypeId": "2", "Body": "<p>Try this:</p>\n<pre><code>static const void* my_null_pointer = 0;\ntypedef A&lt;void *, my_null_pointer, 1&gt; ClassA;\n</code></pre>\n<p>Something like that worked for me on MSVC and gcc as well.\nPassing 0 as that template parameter <em>should</em> work as well.</p>\n<pre><code>typedef A&lt;void *, 0, 1&gt; ClassA;\n</code></pre>\n", "LastActivityDate": "2012-09-28T02:49:05.927", "Id": "12632958", "CommentCount": "3", "CreationDate": "2012-09-28T02:49:05.927", "ParentId": "12632696", "Score": "0", "OwnerUserId": "162380"}});