post_cb({"13996008": {"Id": "13996008", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13995748_13996008_0\">Which of the casts is allowing me to convert an <code>int*</code> to an <code>unsigned char*</code>?</p>\n</blockquote>\n<p>That C-style cast in this case is the same as <code>reinterpret_cast&lt;unsigned char*&gt;</code>.</p>\n<blockquote>\n<p id=\"so_13995748_13996008_1\">Can I cast any T* type like this?</p>\n</blockquote>\n<p>Yes and no. The yes part: You can safely cast any pointer type to a <code>char*</code> or <code>unsigned char*</code> (with the appropriate <code>const</code> and/or <code>volatile</code> qualifiers). The result is implementation-defined, but it is legal.</p>\n<p>The no part: The standard explicitly allows <code>char*</code> and <code>unsigned char*</code> as the target type. However, you cannot (for example) safely cast a <code>double*</code> to an <code>int*</code>. Do this and you've crossed the boundary from implementation-defined behavior to undefined behavior. It violates the strict aliasing rule.</p>\n", "LastActivityDate": "2012-12-21T19:26:00.673", "CommentCount": "1", "CreationDate": "2012-12-21T19:26:00.673", "ParentId": "13995748", "Score": "12", "OwnerUserId": "774499"}, "13995915": {"Id": "13995915", "PostTypeId": "2", "Body": "<p>The implementation behaviour in your example is the endianness attribute of your system, in this case your CPU is a little endian.<br/>\nAbout the type casting, when you cast an <code>int*</code> to <code>char*</code> all what you are doing is telling the compiler to interpret what <code>cp</code> is pointing to as a char, so it will read the first byte only and interpret it as a character.</p>\n", "LastActivityDate": "2012-12-21T19:18:07.327", "CommentCount": "0", "CreationDate": "2012-12-21T19:18:07.327", "ParentId": "13995748", "Score": "2", "OwnerUserId": "869277"}, "13995920": {"Id": "13995920", "PostTypeId": "2", "Body": "<p>Your cast maps to:</p>\n<pre><code>unsigned char* cp = reinterpret_cast&lt;unsigned char*&gt;(&amp;x);\n</code></pre>\n<p>The underlying representation of an <code>int</code> is implementation defined, and viewing it as characters allows you to examine that.  In your case, it is 32-bit little endian.</p>\n<p>There is nothing special here -- this method of examining the internal representation is valid for any data type.</p>\n<blockquote>\n<p id=\"so_13995748_13995920_0\">C++03 5.2.10.7: A pointer to an object can be explicitly converted to a pointer to an object of different type.  Except that converting an rvalue of type \"pointer to T1\" to the type \"pointer to T2\" (where T1 and T2 are object types and where the alignment requirements of T2 are no stricter than those of T1) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n<p>This suggests that the cast results in <em>unspecified behavior</em>.  But pragmatically speaking, casting from any pointer type to <code>char*</code> will always allow you to examine (and modify) the internal representation of the referenced object.</p>\n", "LastEditorUserId": "86967", "LastActivityDate": "2012-12-21T19:34:36.710", "Score": "5", "CreationDate": "2012-12-21T19:18:28.773", "ParentId": "13995748", "CommentCount": "3", "OwnerUserId": "86967", "LastEditDate": "2012-12-21T19:34:36.710"}, "13995962": {"Id": "13995962", "PostTypeId": "2", "Body": "<p>Unless you have a cast operator, then a cast is simply telling to \"see\" that memory area in a different way. Nothing really fancy, I would say.</p>\n<p>Then, you are reading the memory area byte-by-byte; as long as you do not change it, it is just fine. Of course, the result of what you see depends a lot from the platform: think about endianness, word size, padding, and so on.</p>\n", "LastActivityDate": "2012-12-21T19:22:35.810", "CommentCount": "0", "CreationDate": "2012-12-21T19:22:35.810", "ParentId": "13995748", "Score": "0", "OwnerUserId": "43927"}, "bq_ids": {"n4140": {"so_13995748_13995920_0": {"length": 28, "quality": 0.7, "section_id": 6045}, "so_13995748_13996021_0": {"length": 36, "quality": 0.631578947368421, "section_id": 6046}}, "n3337": {"so_13995748_13995920_0": {"length": 33, "quality": 0.825, "section_id": 5814}, "so_13995748_13996021_0": {"length": 51, "quality": 0.8947368421052632, "section_id": 5814}}, "n4659": {"so_13995748_13995920_0": {"length": 28, "quality": 0.7, "section_id": 7544}, "so_13995748_13996021_0": {"length": 36, "quality": 0.631578947368421, "section_id": 7545}}}, "13996021": {"Id": "13996021", "PostTypeId": "2", "Body": "<p>The C-style cast in this case is equivalent to reinterpret_cast. The Standard describes the semantics in 5.2.10. Specifically, in paragraph 7:</p>\n<blockquote>\n<p id=\"so_13995748_13996021_0\">\"A pointer to an object can be explicitly converted to a pointer to a\n  different object type.70 When a prvalue v of type \u201cpointer to T1\u201d is\n  converted to the type \u201cpointer to cvT2\u201d, the result is\n  <code>static_cast&lt;cvT2*&gt;(static_cast&lt;cvvoid*&gt;(v))</code> if both T1 and T2 are\n  standard-layout types (3.9) and the alignment requirements of T2 are\n  no stricter than those of T1. Converting a prvalue of type \u201cpointer to\n  T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are object types and\n  where the alignment requirements of T2 are no stricter than those of\n  T1) and back to its original type yields the original pointer value.\n  The result of any other such pointer conversion is unspecified.\"</p>\n</blockquote>\n<p>What it means in your case, the alignment requirements are satisfied, and the result is unspecified.</p>\n", "LastActivityDate": "2012-12-21T19:26:53.710", "CommentCount": "1", "CreationDate": "2012-12-21T19:26:53.710", "ParentId": "13995748", "Score": "3", "OwnerUserId": "491591"}, "13996009": {"Id": "13996009", "PostTypeId": "2", "Body": "<p>Just reverse the byte order then it becomes </p>\n<pre><code>00 00 01 ff\n</code></pre>\n<p>Which is 256 (01) + 255 (ff) = 511</p>\n<p>This is because your platfom is little endian. </p>\n", "LastActivityDate": "2012-12-21T19:26:02.277", "CommentCount": "0", "CreationDate": "2012-12-21T19:26:02.277", "ParentId": "13995748", "Score": "0", "OwnerUserId": "474034"}, "13995924": {"Id": "13995924", "PostTypeId": "2", "Body": "<p>The cast between pointers are themselves always possible since all pointers are nothing more than memory addresses and whatever type, in memory, can always be thought as a sequence of bytes. </p>\n<p>But -of course- the way the sequence is formed depends on how the decomposed type is represented in memory, and that's out of the scope of the C++ specifications.</p>\n<p>That said, unless of very pathological cases, you can expect that representation to be the same on all the code produced by a same compiler for all the machines of a same platform (or family), and you should not expect same results on different platforms.</p>\n<p>In general one thing to avoid is to express the relation between type sizes as \"predefined\":\nin your sample you assume <code>sizeof(int) == 4*sizeof(char)</code>: that's not necessarily always true.</p>\n<p>But it is always true that sizeof(T) = N*sizeof(char), hence whatever T can always be seen as a integer number of char-s</p>\n", "LastActivityDate": "2012-12-21T19:19:07.463", "CommentCount": "3", "CreationDate": "2012-12-21T19:19:07.463", "ParentId": "13995748", "Score": "1", "OwnerUserId": "924727"}, "13995748": {"ViewCount": "2365", "Body": "<p>We can look at the representation of an object of type <code>T</code> by converting a <code>T*</code> that points at that object into a <code>char*</code>. At least in practice:</p>\n<pre><code>int x = 511;\nunsigned char* cp = (unsigned char*)&amp;x;\nstd::cout &lt;&lt; std::hex &lt;&lt; std::setfill('0');\nfor (int i = 0; i &lt; sizeof(int); i++) {\n  std::cout &lt;&lt; std::setw(2) &lt;&lt; (int)cp[i] &lt;&lt; ' ';\n}\n</code></pre>\n<p>This outputs the representation of <code>511</code> on my system: <code>ff 01 00 00</code>.</p>\n<p>There is (surely) some implementation defined behaviour occurring here. Which of the casts is allowing me to convert an <code>int*</code> to an <code>unsigned char*</code> and which conversions does that cast entail? Am I invoking undefined behaviour as soon as I cast? Can I cast any <code>T*</code> type like this? What can I rely on when doing this?</p>\n", "AcceptedAnswerId": "13996008", "Title": "When and how is conversion to char pointer allowed?", "CreationDate": "2012-12-21T19:04:14.497", "Id": "13995748", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-12-21T19:34:36.710", "Score": "17", "OwnerUserId": "150634", "Tags": "<c++><memory><casting><representation>", "AnswerCount": "7"}});