post_cb({"25354833": {"CommentCount": "9", "ViewCount": "564", "CreationDate": "2014-08-18T00:15:19.973", "LastActivityDate": "2014-08-18T01:48:16.247", "Title": "VS 2013 - IntelliSense reporting false positives?", "AcceptedAnswerId": "25355365", "PostTypeId": "1", "Id": "25354833", "Score": "0", "Body": "<p>I'm working on a C++ project where, among other things, I have an interface with a few pure virtual methods. The problem arises when I try to implement that interface - IntelliSense doesn't seem to agree with the derived class's method declaration. An example of such a method:</p>\n<pre><code>// DLL_EXPORT -&gt; #define DLL_EXPORT __declspec(dllexport)\n// IPlayer\nDLL_EXPORT virtual const Grid&amp; GetGrid() const = 0;\n</code></pre>\n<p>Declaration in one of the derived classes:</p>\n<pre><code>// Human : IPlayer\nDLL_EXPORT const Grid&amp; IPlayer::GetGrid() const;\n</code></pre>\n<p>The error it keeps nagging me with - \"IntelliSense: declaration must correspond to a pure virtual member function in the indicated base class\". The code compiles without errors and runs fine, all of the \"problematic\" methods do their jobs as expected during run time. What is worth mentioning is that the error disappears if I remove the IPlayer:: scope qualifier in the derived class. I wanted to keep it there for readability reasons. Also, I am NOT proficient in C++ so there could be something obviously wrong with the example I've provided.</p>\n", "Tags": "<c++><visual-studio><intellisense>", "OwnerUserId": "1922744", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25354833_25355365_3": {"section_id": 5861, "quality": 0.96, "length": 48}, "so_25354833_25355365_2": {"section_id": 3208, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_25354833_25355365_0": {"section_id": 3082, "quality": 0.9722222222222222, "length": 35}, "so_25354833_25355365_3": {"section_id": 5631, "quality": 0.96, "length": 48}, "so_25354833_25355365_2": {"section_id": 3082, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_25354833_25355365_2": {"section_id": 3965, "quality": 0.9705882352941176, "length": 33}}}, "25355365": {"ParentId": "25354833", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Minimized example:</p>\n<pre><code>struct C { virtual void f() = 0; };\n\nstruct D : C { void C::f() { } };\n</code></pre>\n<p>This doesn't compile in any version of g++ or clang that I tested. Intellisense in VS2013 uses the EDG frontend, and to <a href=\"https://stackoverflow.com/questions/25241516/different-cast-operator-called-by-different-compilers#comment39323916_25241516\">quote Jonathan Wakely</a>, \"If GCC, Clang and EDG all agree and MSVC disagrees that usually means MSVC is wrong.\"</p>\n<p>To make things more interesting, the relevant paragraphs in the standard actually changed between C++11 and C++14.</p>\n<p>In C++11, this is flat-out illegal (N3337 \u00a78.3 [dcl.meaning]/p1):</p>\n<blockquote>\n<p id=\"so_25354833_25355365_0\">A <em>declarator-id</em> shall not be qualified except for the definition of a\n  member function (9.3) or static data member (9.4) outside of its\n  class, the definition or explicit instantiation of a function or\n  variable member of a namespace outside of its namespace, or the\n  definition of an explicit specialization outside of its namespace, or\n  the declaration of a friend function that is a member of another class\n  or namespace (11.3).</p>\n</blockquote>\n<p>This sentence was removed in C++14 as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#482\" rel=\"nofollow noreferrer\">CWG issue 482</a>. The proposed resolution for that issue has the following note:</p>\n<blockquote>\n<p id=\"so_25354833_25355365_1\">[Drafting note: The omission of \u201coutside of its class\u201d here does not\n  give permission for redeclaration of class members; that is still\n  prohibited by 9.2 [class.mem] paragraph 1. The removal of the\n  enumeration of the kinds of declarations in which a qualified-id can\n  appear does allow a typedef declaration to use a qualified-id, which\n  was not permitted before; if that is undesirable, the prohibition can\n  be reinstated here.]</p>\n</blockquote>\n<p>In C++14, the only applicable rule in \u00a78.3 [dcl.meaning]/p1 is now (quoting N3936):</p>\n<blockquote>\n<p id=\"so_25354833_25355365_2\">When the <em>declarator-id</em> is qualified, the declaration shall refer to a\n  previously declared member of the class or namespace to which the\n  qualifier refers (or, in the case of a namespace, of an element of the\n  inline namespace set of that namespace (7.3.1)) or to a specialization\n  thereof; the member shall not merely have been introduced by a\n  <em>using-declaration</em> in the scope of the class or namespace nominated by\n  the <em>nested-name-specifier</em> of the <em>declarator-id</em>.</p>\n</blockquote>\n<p>The relevant part of \u00a79.2 [class.mem]/p1 is:</p>\n<blockquote>\n<p id=\"so_25354833_25355365_3\">Except when used to declare friends (11.3) or to introduce the name of\n  a member of a base class into a derived class (7.3.3),\n  <em>member-declarations</em> declare members of the class, and each such\n  <em>member-declaration</em> shall declare at least one member name of the \n  class. A member shall not be declared twice in the\n  <em>member-specification</em>, except that a nested class or member class \n  template can be declared and then later defined, and except that an\n  enumeration can be introduced with an <em>opaque-enum-declaration</em> and\n  later redeclared with an <em>enum-specifier</em>.</p>\n</blockquote>\n<p>Since a <em>using-declaration</em> \"to introduce a member of a base class into a derived class\" is made an explicit exception, it appears that base class members are not considered members for the purposes of the rule that \"<em>member-declarations</em> declare members of the class, and each such <em>member-declaration</em> shall declare at least one member name of the class\". If so, then it follows that using a <em>qualified-id</em> like <code>void C::f() { }</code> in a <em>member-declaration</em> is also not allowed in C++14, since that <em>qualified-id</em> refers to a member of <code>C</code>, not a member of <code>D</code>.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:29:26.933", "Id": "25355365", "Score": "1", "CreationDate": "2014-08-18T01:48:16.247", "LastActivityDate": "2014-08-18T01:48:16.247"}});