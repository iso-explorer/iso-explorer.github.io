post_cb({"28224259": {"CommentCount": "4", "ViewCount": "174", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-01-29T20:45:43.667", "LastActivityDate": "2016-03-18T11:46:30.783", "Title": "C++ overload resolution, conversion operators and const", "AcceptedAnswerId": "28224463", "LastEditDate": "2016-03-18T11:46:30.783", "Id": "28224259", "Score": "4", "Body": "<p>In this case</p>\n<pre><code>void f(int *);\nvoid f(const int *);\n...\nint i;\nf(&amp;i);\n</code></pre>\n<p>the situation is pretty clear - f(int *) gets called which seems right.</p>\n<p>However, if I have this (it was done like that by mistake(*) ):</p>\n<pre><code>class aa\n{\npublic:\n    operator bool() const;\n    operator char *();\n};\n\nvoid func(bool);\n\naa a;\nfunc(a);\n</code></pre>\n<p>operator char *() gets called. I cannot figure out why would such decision path be better than going to operator bool(). Any ideas?</p>\n<p>(*) If const is added to the second operator, the code works as expected, of course.</p>\n", "Tags": "<c++><overloading><language-lawyer><conversion-operator><const-method>", "OwnerUserId": "2643237", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_28224259_28224463_2": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_28224259_28224463_0": {"section_id": 603, "quality": 0.85, "length": 17}, "so_28224259_28224463_1": {"section_id": 603, "quality": 0.75, "length": 6}}, "n3337": {"so_28224259_28224463_2": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_28224259_28224463_0": {"section_id": 593, "quality": 0.85, "length": 17}, "so_28224259_28224463_1": {"section_id": 593, "quality": 0.75, "length": 6}}, "n4659": {"so_28224259_28224463_2": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_28224259_28224463_0": {"section_id": 629, "quality": 0.85, "length": 17}, "so_28224259_28224463_1": {"section_id": 629, "quality": 0.75, "length": 6}}}, "28224349": {"ParentId": "28224259", "CommentCount": "0", "Body": "<p><code>a</code> is a non-const instance of <code>aa</code> so the non-const conversion operator is a better (exact) match than the const one (requires adding constness), even though the return types don't match as well.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "28224349", "Score": "1", "CreationDate": "2015-01-29T20:51:07.920", "LastActivityDate": "2015-01-29T20:51:07.920"}, "28224354": {"ParentId": "28224259", "CommentCount": "5", "Body": "<p>Your \"aa\" object is not const, so C++ prefers the non-const conversion.</p>\n<p>If you make \"aa\" const, then the const bool() conversion operator will be used.</p>\n", "OwnerUserId": "2727470", "PostTypeId": "2", "Id": "28224354", "Score": "0", "CreationDate": "2015-01-29T20:51:14.637", "LastActivityDate": "2015-01-29T20:51:14.637"}, "28224463": {"ParentId": "28224259", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>Because for user-defined conversions with a conversion operator the conversion of the returned type to the destination type (i.e. <code>char*</code> to <code>bool</code>) is considered <strong>after</strong> the object argument conversion, i.e. the conversion of the object argument <code>a</code> to the implicit object parameter.  [over.match.best]/1:</p>\n<blockquote>\n<p id=\"so_28224259_28224463_0\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  better function than another viable function <code>F2</code> if for all arguments\n  <em>i</em>, <em>ICS</em><sub><em>i</em></sub> <em>(</em><code>F1</code><em>)</em> is not a worse conversion sequence than <em>ICS</em><sub><em>i</em></sub><em>(</em><code>F2</code><em>)</em>, and then</p>\n<ul>\n<li><p id=\"so_28224259_28224463_1\">for some argument <em>j</em>, <em>ICS</em><sub><em>j</em></sub><em>(</em><code>F1</code><em>)</em> is a better conversion sequence than <em>ICS</em><sub><em>j</em></sub><em>(</em><code>F2</code><em>)</em>, <strong>or, if not that</strong>,</p></li>\n<li><p id=\"so_28224259_28224463_2\">the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) <strong>and the\n       standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the\n      entity being initialized) is a better conversion sequence than the standard conversion sequence from\n     the return type of <code>F2</code> to the destination type</strong>.</p></li>\n</ul>\n</blockquote>\n<p>So because the implicit object parameter, which is a reference, is not a <code>const</code>-reference for <code>operator char*</code>, it is a better match according to the first bullet point.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-29T21:05:48.190", "Id": "28224463", "Score": "3", "CreationDate": "2015-01-29T20:57:23.263", "LastActivityDate": "2015-01-29T21:05:48.190"}});