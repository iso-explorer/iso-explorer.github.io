post_cb({"35853459": {"ParentId": "35852493", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The C++ standard does not define <code>mmap</code>, or any other method of mapping memory. The C++ standard only concerns about one way to view the memory. If the system uses virtual memory, then the standard is only concerned about virtual memory. No relation between virtual and physical memory is specified as far as I know.</p>\n<p>What the standard says about memory:</p>\n<blockquote>\n<p id=\"so_35852493_35853459_0\">The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address.</p>\n</blockquote>\n<p>What the standard says about objects:</p>\n<blockquote>\n<p id=\"so_35852493_35853459_1\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they <strong>shall have distinct addresses</strong>.</p>\n</blockquote>\n<p>So, when you ask:</p>\n<blockquote>\n<p id=\"so_35852493_35853459_2\">Is it undefined behavior to have <strong>two pointers with different values referring to the same object</strong>?</p>\n</blockquote>\n<p>The two premises are contradictory. You can never have two pointers with different value referring to the same object. What you have is two different objects from the point of view of the standard. Even if the both virtual addresses are mapped to the same physical memory.</p>\n<p>If we we're to assume that in the following code, the pointers <code>a</code> and <code>b</code> are magically mapped to same physical memory:</p>\n<pre><code>int *a, *b; // initialize with magic mapping of your choice\n*a = 1;\nif(a != b) {\n    *b = 2;\n    std::cout &lt;&lt; *a; // what is the value of *a?\n}\n</code></pre>\n<p>As far as the standard is concerned, <code>*a</code> and <code>*b</code> are different objects. They must be, because they have a different address. A compiler is free to optimize the reading of <code>*a</code> away and use the constant 1, because at no point between <code>*a = 1</code> and reading <code>*a</code>, is anything other than <code>*b</code> modified, which is an unrelated object.</p>\n<p>So, if the compiler chooses to optimize, and use a constant, the output will be <code>1</code>. But, if the memory is actually read, and the virtual address is actually mapped to physical memory to which, <code>2</code> was just written, the output could be different. I don't know if it's explicitly undefined behaviour, but it's definitely unspecified at the very least.</p>\n<p>Memory mapping is specified by the implementation, and so, the implementation specifies how memory mapped objects behave.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-03-07T20:49:12.223", "Id": "35853459", "Score": "3", "CreationDate": "2016-03-07T20:33:54.723", "LastActivityDate": "2016-03-07T20:49:12.223"}, "35852493": {"CommentCount": "34", "AcceptedAnswerId": "35853481", "PostTypeId": "1", "LastEditorUserId": "1422197", "CreationDate": "2016-03-07T19:39:51.940", "LastActivityDate": "2016-03-14T19:52:21.533", "LastEditDate": "2016-03-09T12:03:40.090", "ViewCount": "703", "FavoriteCount": "2", "Title": "Is it undefined behavior to have two pointers with different values referring to the same object?", "Id": "35852493", "Score": "4", "Body": "<p><strong>Note</strong>: if after reading this question you think, \"how can that even happen\", that is ok. If you want to keep an open mind, there are some points after the question that you can follow and that show how this can happen and why this is useful. Just remember that this is just a question and not a tutorial on any of these topics. The comments have enough noise already and they are hard to follow. If you have questions about these topics, I would appreciate if you post them as questions in SO instead of in the comments.</p>\n<hr>\n<hr>\n<p><strong>Question</strong>: If I have an object of type <code>int</code> stored at the address pointed by <code>c</code> </p>\n<pre><code>int* c = /* allocate int (returns unique address) */;\n*c = 3;\n</code></pre>\n<p>referred by two pointers <code>a</code> and <code>b</code>:</p>\n<pre><code>int* a = /* create pointer to (*c) */;\nint* b = /* create pointer to (*c) */;\n</code></pre>\n<p>such that: </p>\n<pre><code>assert(a != b);  // the pointers point to a different address\nassert(*b == 3);\n*a = 2;\nassert(*b == 2);  // but they refer to the same value\n</code></pre>\n<p>Is this undefined behavior? If yes, which part of the C++ standard disallows this? If not, which parts of the C++ standard allows this?</p>\n<p><strong>Note:</strong> the memory <code>c</code> points to is allocated with a memory allocation function that returns an unique address (<code>new</code>, <code>malloc</code>, ...). The way to create these pointers with different values is very platform specific, although in most unix systems it can be done with <code>mmap</code> and on windows it can be done with <code>VirtualAlloc</code>.</p>\n<hr>\n<hr>\n<p><strong>Background</strong>: most operating systems (those that have a userspace that is not on ring 0) run their processes on virtual memory, and have a map from virtual memory pages to physical memory pages. Some of these systems (Linux/MacOS/BSDs/Unixes and 64bit windows) provide some system calls (like <code>mmap</code> or <code>VirtualAlloc</code>) that can be used to map two virtual memory pages to the same physical memory page. When a process performs this, it can essentially access the same page of physical memory from two different virtual memory addresses. That is, those two pointers will have a different value, but they will access the same physical memory storage. Keywords to google for: <code>mmap</code>, virtual memory, memory pages. Data-structures that use this feature for profit are \"magic ring buffer\"s (that's the technical term), and non-reallocating dynamically-sized vectors (that is, vectors that do not need to reallocate memory when they grow). Google provides more information about these than I could ever fit here.</p>\n<p><strong>Very minimal probably non-working example (unix only)</strong>:</p>\n<p>We first allocate an int on the heap. The following request an anonymous, non-file-backed, mapping of virtual memory. One must request here at least a whole memory page, but for simplicity I'll just request the size of an <code>int</code> (<code>mmap</code> will allocate a whole memory page anyways): </p>\n<pre><code>int* c= mmap(NULL, sizeof(int), PROT_NONE, MAP_ANONYMOUS | MAP_PRIVATE,-1, 0);\n</code></pre>\n<p>Now we need to map this to two independent memory locations, so we map it to the same memory-mapped file, twice, to, e.g., two adjacent memory locations. We won't really use this file, but we still need to create it and open it:</p>\n<pre><code>mmap(c, sizeof(int), PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, some_fd, 0);\nmmap(c + 1, sizeof(int), PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED, some_fd, 0);\n</code></pre>\n<p>Now we are almost done:</p>\n<pre><code>int* a = c;\nint* b = c + 1;\n</code></pre>\n<p>These are obviously different <em>virtual</em> addresses:</p>\n<pre><code>assert(a != b);\n</code></pre>\n<p>But they point to the same, non-file-backed, <em>physical</em> memory page:</p>\n<pre><code>*a = 314;\nassert(*b == 314);\n</code></pre>\n<p>So there you go. Using <code>VirtualAlloc</code> the same can be done on Windows, but the API is a bit different.</p>\n</hr></hr></hr></hr>", "Tags": "<c++><operating-system><undefined-behavior><memory-address>", "OwnerUserId": "1422197", "AnswerCount": "7"}, "35886283": {"ParentId": "35852493", "CommentCount": "3", "Body": "<p>You don't have to resort to MMU tricks to figure out how to construct two addresses that point to the same region of memory. There are segmented memory architectures, ARM Cortex bit-banding, etc. The C compiler isn't allowed itself to construct an object with two different addresses (this is actually nonsensical according to the way the language defines terms like \"address\" and \"object\") but the standard is written in such a way that it's expected that writing to some objects will cause things to happen as a side-effect, and that arbitrary other things other than your program writing to an object may change its value between reads. You're expected to know about these and mark them as <code>volatile</code>, though.</p>\n<p>So your situation has nothing to do with Undefined Behavior; UB is part of the contract between programmer and compiler that says how the compiler is constrained (or not) by the programmer's use of the language. If you go <em>outside</em> the language, you can arbitrarily screw things up if you don't know what you're doing, but this has nothing to do with the compiler's obligations to you with regard to the standard. In this case, you have simply created two <code>volatile</code> objects that happen to be linked via side-effects to contain the same data. This is not a strange situation at all in the world of device drivers and memory-mapped registers!</p>\n", "OwnerUserId": "2662193", "PostTypeId": "2", "Id": "35886283", "Score": "1", "CreationDate": "2016-03-09T08:18:39.473", "LastActivityDate": "2016-03-09T08:18:39.473"}, "35996774": {"ParentId": "35852493", "CommentCount": "0", "Body": "<p>Having pointers to each of two or more addresses which identify the same region of storage, and modifying the object using either of them, would create a situation equivalent to that of having an implementation modify the storage underlying an object behind the compiler's back for any other reason.  One should not expect any particular behavior unless both pointers are of a <code>volatile</code>-qualified type, but if both pointers are thus qualified behavior should be as expected on most implementations.  The Standard doesn't specify exactly what the effect of <code>volatile</code> should be, but nor does it define any means by which the situation you describe could exist.  Implementations in which the situation you describe could exist will generally document a means of ensuring that volatile reads or writes will physically access the region of address space identified by the pointer, and that all such accesses will be performed in the order given, but the Standard does not require that a <code>volatile</code> qualifier will necessarily be sufficient.</p>\n<p>Note that even when <code>volatile</code> accesses are sequenced relative to each other, implementations might not sequence them relative to non-<code>volatile</code> accesses.  It would be helpful if there were a means by which a compiler could be told to write a bunch of information in any order, and then only write to a <code>volatile</code> location after all the other writes were complete, but there is no standard means of doing that except perhaps to make all of the data <code>volatile</code> (which would limit optimization opportunities, and may or may not be sufficient anyway).</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "35996774", "Score": "1", "CreationDate": "2016-03-14T19:52:21.533", "LastActivityDate": "2016-03-14T19:52:21.533"}, "35853371": {"ParentId": "35852493", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Yes it is possible using multiple inheritance, like this:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A { int a; };\n\nclass B { int b; };\n\nclass C : public A, public B { };\n\nvoid f(A &amp;a) { cout &lt;&lt; &amp;a &lt;&lt; endl; }\n\nvoid g(B &amp;b) { cout &lt;&lt; &amp;b &lt;&lt; endl; }\n\nint main() {\n    C c;\n    f(c);\n    g(c);\n}\n</code></pre>\n<p>which produces something like:</p>\n<pre><code>0x7fff5aba2878\n0x7fff5aba287c\n</code></pre>\n<p>Now you can encapsulte mechanism to obtain the same shared value in the child class C:</p>\n<pre><code>class A {\n  int a;\npublic:\n  virtual int getValue() { return a; }\n  virtual void setValue(int v) { a = v; }\n};\n\nclass B {\n  int b;\npublic:\n  virtual int getValue() { return b; }\n  virtual void setValue(int v) { b = v; }\n};\n\nclass C : public A, public B {\n  int c;\npublic:\n  virtual int getValue() { return c; }\n  virtual void setValue(int v) { c = v; }\n};\n\nvoid f(A &amp;a) {\n  cout &lt;&lt; &amp;a &lt;&lt; endl;\n  cout &lt;&lt; a.getValue() &lt;&lt; endl;\n  a.setValue(5);\n  cout &lt;&lt; a.getValue() &lt;&lt; endl;\n}\n\nvoid g(B &amp;b) {\n  cout &lt;&lt; &amp;b &lt;&lt; endl;\n  cout &lt;&lt; b.getValue() &lt;&lt; endl;\n}\n\nint main() {\n    C c;\n    c.setValue(3);\n    f(c);\n    g(c);\n}\n</code></pre>\n<p>In that case you can observe:</p>\n<pre><code>0x7fff51063860\n3\n5\n0x7fff51063870\n5\n</code></pre>\n<p>Where it look like there is two objects (in real one object with <em>two addresses</em>) but that share the same value.</p>\n<p>Note, there is some info about how carefully you should consider address(es) of object on ISO faq <a href=\"https://isocpp.org/wiki/faq/multiple-inheritance\" rel=\"nofollow\">What special considerations do I need to know about when I use virtual inheritance?</a></p>\n", "OwnerUserId": "719263", "LastEditorUserId": "719263", "LastEditDate": "2016-03-07T20:43:02.453", "Id": "35853371", "Score": "1", "CreationDate": "2016-03-07T20:28:56.407", "LastActivityDate": "2016-03-07T20:43:02.453"}, "35869956": {"ParentId": "35852493", "CommentCount": "0", "Body": "<p>The problem with your hypothetical implementation is actually <code>assert(a != b);</code></p>\n<p>A simple thought experiment shows why. On the classic 8086, the two pointers <code>0000:0010</code> and <code>0001:0000</code> are <strong>equal</strong>, because both pointers refer to the same object. The implementation must ensure that these two pointers aren't compared bitwise.</p>\n<p>In general, if your implementation allows two unique <strong>bitpatterns</strong> to refer to the same object, then those bitpatterns (interpreted as pointers) must compare equal. </p>\n<p>You'll find that there are very few C++ implementations that contain a <code>mmap</code> function, though. That typically is an OS function, and the OS isn't bound by C++ rules. Calling OS functions tends to be UB anyhow.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "35869956", "Score": "1", "CreationDate": "2016-03-08T14:26:25.453", "LastActivityDate": "2016-03-08T14:26:25.453"}, "35853253": {"ParentId": "35852493", "CommentCount": "11", "Body": "<p>It is perfectly allowed to have two different pointers pointing to the same object, under the condition that they have the same type than\nthe original object.  Nothing prevent this and it's certainly not undefined behaviour.  </p>\n<p>What is undefined behaviour is when you don't respect the <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow\">strict aliasing rule</a>, i.e. you have two pointers of different type refering to the same object. This is stated in the standard, section 3.10/10.  But it's not the case of your example.  </p>\n<p>Now the difficult part of your question:  can you have two pointers of different value that point to the same object ? </p>\n<ul>\n<li>Pointer management is implementation defined. On some older CPU architectures, compiler used memory models making use of <a href=\"https://en.wikipedia.org/wiki/X86_memory_segmentation\" rel=\"nofollow\">segment registers</a> and offset registers.  Both are then combined to find out which unique address in memory they refer to.  Depending on how the pointers were stored, e.g.if they were stored as the juxtaposition of segment and offset, you could indeed have two pointers of different value pointing to the same object.  </li>\n<li>However by definition of the equality operator (standard, section 5.10/3),  two pointers pointing to the same object are equal.  And this shall be true regardless of how the compiler implements the pointers (i.e. even if the bitwise value would be different, the comparison should return true if they refer to the same object)  </li>\n</ul>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "35853253", "Score": "1", "CreationDate": "2016-03-07T20:21:54.047", "LastActivityDate": "2016-03-07T20:21:54.047"}, "bq_ids": {"n4140": {"so_35852493_35853459_2": {"section_id": 480, "quality": 0.6, "length": 6}, "so_35852493_35853481_1": {"section_id": 5790, "quality": 0.8, "length": 72}, "so_35852493_35853459_0": {"section_id": 5785, "quality": 0.9230769230769231, "length": 12}, "so_35852493_35853481_4": {"section_id": 5785, "quality": 0.875, "length": 49}, "so_35852493_35853459_1": {"section_id": 5795, "quality": 0.9743589743589743, "length": 38}, "so_35852493_35853481_2": {"section_id": 5795, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_35852493_35853459_2": {"section_id": 471, "quality": 0.6, "length": 6}, "so_35852493_35853481_1": {"section_id": 5563, "quality": 0.8, "length": 72}, "so_35852493_35853459_0": {"section_id": 5558, "quality": 0.9230769230769231, "length": 12}, "so_35852493_35853481_4": {"section_id": 5558, "quality": 0.875, "length": 49}, "so_35852493_35853459_1": {"section_id": 5568, "quality": 0.9743589743589743, "length": 38}, "so_35852493_35853481_2": {"section_id": 5568, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_35852493_35853459_2": {"section_id": 502, "quality": 0.6, "length": 6}, "so_35852493_35853481_2": {"section_id": 7254, "quality": 0.9487179487179487, "length": 37}, "so_35852493_35853459_0": {"section_id": 7242, "quality": 0.9230769230769231, "length": 12}, "so_35852493_35853481_4": {"section_id": 7242, "quality": 0.875, "length": 49}, "so_35852493_35853459_1": {"section_id": 7254, "quality": 0.9487179487179487, "length": 37}, "so_35852493_35853481_1": {"section_id": 7247, "quality": 0.7111111111111111, "length": 64}}}, "35853481": {"ParentId": "35852493", "CommentCount": "7", "Body": "<p>First lets look at what the standard has to say about an object</p>\n<blockquote>\n<p id=\"so_35852493_35853481_0\"><strong>[intro.object]</strong></p>\n<p id=\"so_35852493_35853481_1\">The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. \u2014end note ] An object is created by a definition (3.1), by a new-expression (5.3.4) or by the implementation (12.2) when needed. The properties of an object are determined when the object is created. An object can have a name (Clause 3). An object has a storage duration (3.7) which influences its lifetime (3.8). An object has a type (3.9). The term object type refers to the type with which the object is created. Some objects are polymorphic (10.3); the implementation generates information associated with each such object that makes it possible to determine that object\u2019s type during program execution. For other\n  objects, the interpretation of the values found therein is determined by the type of the expressions (Clause 5) used to access them.</p>\n</blockquote>\n<p>And then we have</p>\n<blockquote>\n<p id=\"so_35852493_35853481_2\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses.</p>\n</blockquote>\n<p>So we know that an object has an address and it is the first byte of the storage it uses.  If we look at what a byte is we have</p>\n<blockquote>\n<p id=\"so_35852493_35853481_3\"><strong>[intro.memory]</strong></p>\n<p id=\"so_35852493_35853481_4\">The fundamental storage unit in the C++ memory model is the byte. A byte is at least large enough to contain any member of the basic execution character set (2.3) and the eight-bit code units of the Unicode UTF-8 encoding form and is composed of a contiguous sequence of bits, the number of which is implementationdefined. The least significant bit is called the low-order bit; the most significant bit is called the high-order bit. The memory available to a C++ program consists of one or more sequences of contiguous bytes. <strong>Every byte has a unique address.</strong></p>\n</blockquote>\n<p><sup>Emphasis mine</sup></p>\n<p>So if we have a pointer to an object the pointer is going to hold a unique value(address).  If we have another pointer to that same object then it will also have to have that same value(address).  Undefined behavior does not even enter the equation as you simply cannot have two pointers to the same object that have different values.  </p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "35853481", "Score": "5", "CreationDate": "2016-03-07T20:35:19.663", "LastActivityDate": "2016-03-07T20:35:19.663"}});