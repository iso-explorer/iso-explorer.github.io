post_cb({"46065770": {"ViewCount": "88", "Body": "<p>I am studying this site: <a href=\"https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\" rel=\"noreferrer\">https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync</a>, which is very helpful to understand the topic about atomic class.</p>\n<p>But this example about relaxed mode is hard to understand:</p>\n<pre><code>    /*Thread 1:*/\n\n    y.store (20, memory_order_relaxed)\n    x.store (10, memory_order_relaxed)\n    /*Thread 2*/\n if (x.load (memory_order_relaxed) == 10)\n      {\n        assert (y.load(memory_order_relaxed) == 20) /* assert A */\n        y.store (10, memory_order_relaxed)\n      }\n /*Thread 3*/\n     if (y.load (memory_order_relaxed) == 10)\n        assert (x.load(memory_order_relaxed) == 10) /* assert B */\n</code></pre>\n<p>To me assert B should never fail, since x must be 10 and y=10 because of thread 2 has conditioned on this.</p>\n<p>But the website says either assert in this example can actually FAIL.</p>\n", "AcceptedAnswerId": "46068191", "Title": "confused about atomic class: memory_order_relaxed", "CreationDate": "2017-09-06T02:12:15.397", "Id": "46065770", "CommentCount": "3", "LastEditDate": "2017-09-06T02:28:58.293", "PostTypeId": "1", "LastEditorUserId": "6524007", "LastActivityDate": "2017-09-06T07:39:30.397", "Score": "7", "OwnerUserId": "6009185", "Tags": "<c++>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_46065770_46069339_1": {"length": 16, "quality": 1.0, "section_id": 1150}, "so_46065770_46069339_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 5819}}, "n3337": {"so_46065770_46069339_1": {"length": 16, "quality": 1.0, "section_id": 1147}, "so_46065770_46069339_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 5590}}, "n4659": {"so_46065770_46069339_1": {"length": 16, "quality": 1.0, "section_id": 1244}, "so_46065770_46069339_0": {"length": 41, "quality": 0.9111111111111111, "section_id": 7280}}}, "46068191": {"Id": "46068191", "PostTypeId": "2", "Body": "<p>I find it much easier to understand atomics with some knowledge of what might be causing them, so here's some background knowledge. Know that these concepts are in no way stated in the C++ language itself, but is some of the possible reasons why things are the way they are.</p>\n<h2>Compiler reordering</h2>\n<p>Compilers, often when optimizing, will choose to refactor the program as long as its effects are the same <strong>on a single threaded program</strong>. This is circumvented with the use of atomics, which will tell the compiler (among other things) that the variable might change at any moment, and that its value might be read elsewhere.</p>\n<p>Formally, atomics ensures one thing: there will be no data races. That is, accessing the variable will not make your computer explode. </p>\n<h2>CPU reordering</h2>\n<p>CPU might reorder instructions as it is executing them, which means the instructions might get reordered on the hardware level, independent of how you wrote the program. </p>\n<h2>Caching</h2>\n<p>Finally there are effects of caches, which are faster memory that sorta contains a partial copy of the global memory. Caches are not always in sync, meaning they don't always agree on what is \"correct\". Different threads may not be using the same cache, and due to this, they may not agree on what values variables have.</p>\n<h2>Back to the problem</h2>\n<p>What the above surmounts to is pretty much what C++ says about the matter: unless <strong>explicitly</strong> stated otherwise, the ordering of side effects of each instruction is totally and completely unspecified. It might not even be the same viewed from different threads.</p>\n<p>Formally, the guarantee of an ordering of side effects is called a <em>happens-before</em> relation. Unless a side effect <em>happens-before</em> another, it is not. Loosely, we just say call it synchronization.</p>\n<p>Now, what is <code>memory_order_relaxed</code>? It is telling the compiler to stop meddling, but don't worry about how the CPU and cache (and possibly other things) behave. Therefore, one possibility of why you see the \"impossible\" assert might be</p>\n<ol>\n<li>Thread 1 stores <code>20</code> to <code>y</code> and then <code>10</code> to <code>x</code>  to its cache.</li>\n<li>Thread 2 reads the new values and stores <code>10</code> to <code>y</code> to its cache.</li>\n<li>Thread 3 didn't read the values from thread 1, but reads those of thread 2, and then the assert fails.</li>\n</ol>\n<p>This might be completely different from what happens in reality, the point is <em>anything</em> can happen.</p>\n<p>To ensure a <em>happens-before</em> relation between the multiple reads and writes, see <a href=\"https://stackoverflow.com/a/46066462/4832499\">Brian's answer</a>.</p>\n<p>Another construct that provides <em>happens-before</em> relations is <code>std::mutex</code>, which is why they are free from such insanities.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-09-06T06:29:12.403", "Score": "1", "CreationDate": "2017-09-06T06:23:56.693", "ParentId": "46065770", "CommentCount": "3", "LastEditDate": "2017-09-06T06:29:12.403", "OwnerUserId": "4832499"}, "46069339": {"Id": "46069339", "PostTypeId": "2", "Body": "<p>The answer to your question is the C++ standard.</p>\n<p>The section [intro.races] is surprisingly very clear (which is not the rule of normative text kind: formalism consistency oftenly hurts readability).</p>\n<p>I have read many books and tuto which treats the subject of memory order, but it just confused me.\nFinally I have read the C++ standard, the section [intro.multithread] is the clearest I have found. Taking the time to read it carefully (twice) may save you some time! </p>\n<p>The answer to your question is in [intro.races]/4:</p>\n<blockquote>\n<p id=\"so_46065770_46069339_0\">All modifications to a particular atomic object M occur in some particular total order, called the modification\n  order of M. [ Note: There is a separate order for each atomic object. There is no requirement that these can\n  be combined into a single total order for all objects. In general this will be impossible since different threads\n  may observe modifications to different objects in inconsistent orders. \u2014 end note ]</p>\n</blockquote>\n<p>You were expecting a single total order on all atomic operations. There is such an order, but only for atomic operations that are <code>memory_order_seq_cst</code> as explained in [atomics.order]/3:</p>\n<blockquote>\n<p id=\"so_46065770_46069339_1\">There shall be a single total order S on all <code>memory_order_seq_cst</code> operations, consistent with the \u201chappens\n  before\u201d order and modification orders for all affected locations [...]</p>\n</blockquote>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2017-09-06T07:39:30.397", "Score": "1", "CreationDate": "2017-09-06T07:33:25.253", "ParentId": "46065770", "CommentCount": "0", "LastEditDate": "2017-09-06T07:39:30.397", "OwnerUserId": "5632316"}, "46066462": {"Id": "46066462", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46065770_46066462_0\">To me assert B should never fail, since x must be 10 and y=10 because of thread 2 has conditioned on this.</p>\n</blockquote>\n<p>In effect, your argument is that since in thread 2 the store of 10 into <code>x</code> occurred before the store of 10 into <code>y</code>, in thread 3 the same must be the case.</p>\n<p>However, since you are only using relaxed memory operations, there is nothing in the code that requires two different threads to agree on the ordering between modifications of <em>different</em> variables. So indeed thread 2 may see the store of 10 into <code>x</code> before the store of 10 into <code>y</code> while thread 3 sees those two operations in the opposite order.</p>\n<p>In order to ensure that assert B succeeds, you would, in effect, need to ensure that when thread 3 sees the value 10 of <code>y</code>, it also sees any other side effects performed by the thread that stored 10 into <code>y</code> before the time of the store. That is, you need the store of 10 into <code>y</code> to <em>synchronize</em> with the load of 10 from <code>y</code>. This can be done by having the store perform a release and the load perform an acquire:</p>\n<pre><code>// thread 2\ny.store (10, memory_order_release);\n\n// thread 3\nif (y.load (memory_order_acquire) == 10)\n</code></pre>\n<p>A release operation synchronizes with an acquire operation that reads the value stored. Now because the store in thread 2 synchronizes with the load in thread 3, anything that happens after the load in thread 3 will see the side effects of anything that happens before the store in thread 2. Hence the assertion will succeed.</p>\n<p>Of course, we also need to make sure assertion A succeeds, by making the <code>x.store</code> in thread 1 use release and the <code>x.load</code> in thread 2 use acquire.</p>\n", "LastActivityDate": "2017-09-06T03:46:06.130", "Score": "5", "CreationDate": "2017-09-06T03:46:06.130", "ParentId": "46065770", "CommentCount": "1", "OwnerUserId": "481267"}});