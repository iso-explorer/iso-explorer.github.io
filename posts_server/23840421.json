post_cb({"23840421": {"CommentCount": "1", "AcceptedAnswerId": "23840454", "PostTypeId": "1", "LastEditorUserId": "2399879", "CreationDate": "2014-05-24T01:27:44.993", "LastActivityDate": "2014-05-24T01:34:47.953", "LastEditDate": "2014-05-24T01:32:42.950", "ViewCount": "526", "FavoriteCount": "2", "Title": "Pointer to function parameter vs function parameter?", "Id": "23840421", "Score": "10", "Body": "<p>I'd like to understand what is the difference between the 2 declarations, <code>f1</code> and <code>f2</code>, below:\nIn <code>f1</code> I declare the parameter to be a pointer to a function of type <code>void()</code>, how is the <code>f2</code> declaration different from the <code>f1</code>? Are the declarations equivalent? In <code>main</code> I can invoke both of them with functions of prototype <code>void ()</code>. I understand the concept of passing by value/pointer/reference, however these are functions and don't really understand the difference. It is not like I can \"modify\" the function passed as parameter in <code>f1</code>... Thanks!</p>\n<p>PS: came by this question when bumping into the well known Most Vexing Parsing problem :)</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nvoid f1(void (*x)())\n{\n    x();\n}\n\nvoid f2(void x())\n{\n    x();\n}\n\nvoid g1()\n{\n    cout &lt;&lt; \"Invoking f1(g1())\" &lt;&lt; endl;\n}\n\nvoid g2()\n{\n    cout &lt;&lt; \"Invoking f2(g2())\" &lt;&lt; endl;\n}\n\n\nint main() \n{\n    f1(g1);\n    f2(g2);\n}\n</code></pre>\n<p>The program compiles and the output is</p>\n<pre><code>Invoking f1(g1())\nInvoking f2(g2())\n</code></pre>\n", "Tags": "<c++><pointers>", "OwnerUserId": "3093378", "AnswerCount": "3"}, "23840460": {"ParentId": "23840421", "CommentCount": "1", "Body": "<p>In both C and C++, if you declare a function parameter to have function type, its type will be adjusted to function pointer.</p>\n<p>C99, \u00a76.7.5.3/8</p>\n<blockquote>\n<p id=\"so_23840421_23840460_0\">A declaration of a parameter as \u2018\u2018function returning type\u2019\u2019 shall be adjusted to \u2018\u2018pointer to\n             function returning type\u2019\u2019, as in 6.3.2.1.</p>\n</blockquote>\n<p>C++11, \u00a78.3.5/5</p>\n<blockquote>\n<p id=\"so_23840421_23840460_1\">... After\n  determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is\n  adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively...</p>\n</blockquote>\n<p>Thus, in C++, for example, we can write the types of both <code>f1</code> and <code>f2</code> as <code>void(void(*)())</code>.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "23840460", "Score": "13", "CreationDate": "2014-05-24T01:34:47.953", "LastActivityDate": "2014-05-24T01:34:47.953"}, "23840454": {"ParentId": "23840421", "CommentCount": "1", "Body": "<p>They're equivalent.  You're getting confused by the implicit pointer conversion that happens with arguments.</p>\n<p>Since you can't pass a function as an argument to a function (you can't do anything with functions in C other than call them or take their address), the compiler silently changes the argument into a pointer to a function.</p>\n<p>This is much the same as happens with arrays -- you can't pass arrays as function arguments either, so any time you declare a function argument as an array, it silently gets changed into a pointer.</p>\n", "OwnerUserId": "16406", "PostTypeId": "2", "Id": "23840454", "Score": "7", "CreationDate": "2014-05-24T01:34:19.717", "LastActivityDate": "2014-05-24T01:34:19.717"}, "bq_ids": {"n4140": {"so_23840421_23840460_1": {"section_id": 3241, "quality": 1.0, "length": 16}, "so_23840421_23840460_0": {"section_id": 558, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_23840421_23840460_1": {"section_id": 3114, "quality": 1.0, "length": 16}, "so_23840421_23840460_0": {"section_id": 549, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_23840421_23840460_1": {"section_id": 3997, "quality": 0.75, "length": 12}, "so_23840421_23840460_0": {"section_id": 581, "quality": 0.7272727272727273, "length": 8}}}, "23840455": {"ParentId": "23840421", "CommentCount": "0", "Body": "<p>They are alternative syntax for the exact same thing. In both cases a function pointer is passed, but you are allowed to use non-pointer syntax in the parameter list.  Use of a function name always decays to a pointer to function (and this can happen recursively).</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "23840455", "Score": "2", "CreationDate": "2014-05-24T01:34:30.147", "LastActivityDate": "2014-05-24T01:34:30.147"}});