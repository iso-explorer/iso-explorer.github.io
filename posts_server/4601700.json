post_cb({"4601798": {"ParentId": "4601700", "CommentCount": "0", "Body": "<p>I believe 17.4.2.1 [lib.using.headers] forbids including standard library headers in a namespace :</p>\n<blockquote>\n<p id=\"so_4601700_4601798_0\"><strong>A translation unit shall include a header only outside of any external declaration or definition</strong>, and shall\n  include the header lexically before the first reference to any of the entities it declares or first defines in that\n  translation unit.</p>\n</blockquote>\n<p>I don't think there is anything you can do besides filing a request to the library author.</p>\n", "OwnerUserId": "451980", "PostTypeId": "2", "Id": "4601798", "Score": "6", "CreationDate": "2011-01-05T07:40:01.463", "LastActivityDate": "2011-01-05T07:40:01.463"}, "4602216": {"ParentId": "4601700", "CommentCount": "0", "Body": "<p>This approach will most likely lead you to trouble. You could approach the problem by manually including each such standard header <em>before</em> entering the namespace, and the include guards would take care of not re-including the header inside the namespace.</p>\n<p>That would take care of your current error, but it would on the other hand break too many other things --if the library is precompiled then the symbols used in your code and the symbols in the binary library would be different symbols (<code>libname::foo()</code> used in your code, <code>::foo()</code> defined in the binary). Even if the library is header only, any fully qualified access to the library within the library itself would break (<code>void foo() { ::bar(); }</code> where <code>foo</code> and <code>bar</code> are inside the library).</p>\n<p>A valid approach that you might want to try (even if cumbersome, and requiring real work) would be writting a wrapper that is within it's own namespace, and uses the library. Then include your wrapper instead of the actual library headers.</p>\n<p>My advice, on the other hand, would be ignoring the problem altogether. Declare your own objects within your namespaces and that would take care of the possible name collisions. As long as you keep away from <code>using namespace</code> statements you will be fine.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "4602216", "Score": "1", "CreationDate": "2011-01-05T08:51:26.197", "LastActivityDate": "2011-01-05T08:51:26.197"}, "4601700": {"CommentCount": "4", "ViewCount": "599", "CreationDate": "2011-01-05T07:22:32.573", "LastActivityDate": "2011-01-05T08:51:26.197", "Title": "Why we can't include std headers within a namespace in C++", "AcceptedAnswerId": "4601798", "PostTypeId": "1", "Id": "4601700", "Score": "1", "Body": "<p>The following code will cause compile errors in g++4.4:</p>\n<pre><code>// File test.cpp\nnamespace A\n{\n    #include &lt;iostream&gt;\n}\n\nint main()\n{\n    return 0;\n}\n</code></pre>\n<p>I have this requirement because some third party library comes without namespace protected, and if I directly include these headers, my namespace is polluted.<br>\nAs a result, I tried to create namespaces for those libraries, but if the library includes some \"std headers\" the above approach will fail.</br></p>\n<p>Can anybody help?</p>\n<p>Thank You!</p>\n", "Tags": "<c++>", "OwnerUserId": "538753", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_4601700_4601798_0": {"section_id": 6270, "quality": 0.75, "length": 15}}, "n3337": {"so_4601700_4601798_0": {"section_id": 6030, "quality": 0.75, "length": 15}}, "n4659": {"so_4601700_4601798_0": {"section_id": 7776, "quality": 0.7, "length": 14}}}, "4601752": {"ParentId": "4601700", "CommentCount": "0", "Body": "<p>Use fully qualified names when using calls to standard libraries like <code>std::cout</code> instead of writing <code>using namespace std;</code>. This way, both can coexist.</p>\n", "OwnerUserId": "17537", "PostTypeId": "2", "Id": "4601752", "Score": "0", "CreationDate": "2011-01-05T07:32:14.667", "LastActivityDate": "2011-01-05T07:32:14.667"}});