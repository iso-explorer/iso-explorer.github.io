post_cb({"bq_ids": {"n4140": {"so_24423651_24423821_1": {"section_id": 38, "quality": 0.7916666666666666, "length": 19}}, "n3337": {"so_24423651_24423821_1": {"section_id": 35, "quality": 0.7916666666666666, "length": 19}}, "n4659": {"so_24423651_24423821_1": {"section_id": 38, "quality": 0.7083333333333334, "length": 17}}}, "24423821": {"ParentId": "24423651", "CommentCount": "1", "Body": "<p>Referring to c++03 here.</p>\n<blockquote>\n<p id=\"so_24423651_24423821_0\">4.9 Floating-integral conversions [conv.fpint]</p>\n<p id=\"so_24423651_24423821_1\">An rvalue of an integer type or of an enumeration type can be\n  converted to an rvalue of a floating point type. The result is exact\n  if possible. Otherwise, it is an implementation-defined choice of\n  either the next lower or higher representable value.</p>\n</blockquote>\n<p>If your system can represent 1.0 exactly (and looks like it can), then the expressions are same.</p>\n", "OwnerUserId": "503352", "PostTypeId": "2", "Id": "24423821", "Score": "3", "CreationDate": "2014-06-26T06:30:53.030", "LastActivityDate": "2014-06-26T06:30:53.030"}, "24423651": {"CommentCount": "2", "ViewCount": "217", "PostTypeId": "1", "LastEditorUserId": "1009479", "CreationDate": "2014-06-26T06:20:09.690", "LastActivityDate": "2014-06-26T09:03:23.403", "Title": "is there any difference between f+=1 and f+=1.0 if f is a double?", "AcceptedAnswerId": "24423821", "LastEditDate": "2014-06-26T06:34:24.067", "Id": "24423651", "Score": "3", "Body": "<p>Suppose we have <code>double f;</code></p>\n<p>Is any difference between <code>f+=1</code> and <code>f+=1.0</code> ?</p>\n<p>How does the compiler handler these situations?</p>\n<p>I tried on my computer and loop 10<sup>10</sup> times, the elapsed time is almost the same</p>\n", "Tags": "<c++>", "OwnerUserId": "3318504", "AnswerCount": "4"}, "24423825": {"ParentId": "24423651", "CommentCount": "2", "Body": "<p>There can be a slight difference in a <strong>non-optimized</strong> build: the integer constant 1 can (should ?) be promoted to double at run-time rather than compile-time.</p>\n", "OwnerUserId": "1196549", "PostTypeId": "2", "Id": "24423825", "Score": "0", "CreationDate": "2014-06-26T06:31:01.613", "LastActivityDate": "2014-06-26T06:31:01.613"}, "24426447": {"ParentId": "24423651", "CommentCount": "2", "Body": "<p>You can always <a href=\"http://ideone.com/3GJslN\" rel=\"nofollow\">check</a> it for your system :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\nint main() \n{\n    double f(0.);\n    cout &lt;&lt; std::is_same&lt;decltype(f+1), decltype(f+1.)&gt;::value &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p><sup>If anyone finds a case where they differ I'd appreciate a comment</sup></p>\n", "OwnerUserId": "2567683", "PostTypeId": "2", "Id": "24426447", "Score": "0", "CreationDate": "2014-06-26T09:03:23.403", "LastActivityDate": "2014-06-26T09:03:23.403"}, "24423822": {"ParentId": "24423651", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No difference in any self respecting compiler, the implicit cast will surely be performed at compile time, probably even with optimizations disabled. If you have some doubt however  you can always check the generated assembly. </p>\n<p>Now, stylistically speaking, I prefer to always have my constants of the \"correct\" type (especially in expressions where some terms may get changed to int later), although some people think that all the trailing  <code>.0</code> just add visual clutter (but: you can avoid the trailing <code>0</code> and just leave the dot to specify a double literal - as in <code>1.</code>).  </p>\n", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2014-06-26T07:37:12.423", "Id": "24423822", "Score": "2", "CreationDate": "2014-06-26T06:30:55.193", "LastActivityDate": "2014-06-26T07:37:12.423"}});