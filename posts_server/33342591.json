post_cb({"bq_ids": {"n4140": {"so_33342591_33342789_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4088}}, "n4659": {"so_33342591_33342789_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4996}}}, "33342591": {"ViewCount": "44", "LastEditDate": "2015-10-26T10:03:42.077", "Title": "Extracts the element of a tuple by type and ambiguity", "CreationDate": "2015-10-26T09:43:09.947", "LastActivityDate": "2015-10-26T10:17:09.740", "CommentCount": "3", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/utility/tuple/get\" rel=\"nofollow\">The article</a> states that for free <code>std::get</code> function overloadings (from 4-6 items) they</p>\n<blockquote>\n<p id=\"so_33342591_33342591_0\">Extracts the element of the tuple t whose type is T. Fails to compile if the tuple has more than one element of that type.</p>\n</blockquote>\n<p>Is the last statement a requirements or just a possibility?</p>\n<p>I ask the question because <code>std::get&lt; int &gt;(std::make_tuple(1, 2))</code> compiles fine by <code>clang++ -std=gnu++1z -stdlib=libc++</code> (<a href=\"http://coliru.stacked-crooked.com/a/af1759a3b2261d4a\" rel=\"nofollow\"><kbd>live example</kbd></a>). Is this tuple's behaviour a <em>libc++</em> bug or is one conformant to the Standard?</p>\n", "PostTypeId": "1", "LastEditorUserId": "1430927", "Id": "33342591", "Score": "1", "OwnerUserId": "1430927", "Tags": "<c++><clang><tuples><libc++><iterable-unpacking>", "AnswerCount": "1"}, "33342789": {"Id": "33342789", "PostTypeId": "2", "LastEditDate": "2015-10-26T10:17:09.740", "CommentCount": "0", "LastEditorUserId": "493122", "LastActivityDate": "2015-10-26T10:17:09.740", "CreationDate": "2015-10-26T09:54:22.343", "ParentId": "33342591", "Score": "2", "Body": "<p>From the standard \u00a720.4.2.6/8, the requirements are:</p>\n<blockquote>\n<p id=\"so_33342591_33342789_0\">Requires: The type T occurs exactly once in Types.... Otherwise, the program is ill-formed.</p>\n</blockquote>\n<p>So your program is ill-formed.</p>\n<p>The standard even provides an example which is very similar to your situation:</p>\n<pre><code>const tuple&lt;int, const int, double, double&gt; t(1, 2, 3.4, 5.6);\nconst int &amp;i1 = get&lt;int&gt;(t); // OK. Not ambiguous. i1 == 1\nconst int &amp;i2 = get&lt;const int&gt;(t); // OK. Not ambiguous. i2 == 2\nconst double &amp;d = get&lt;double&gt;(t); // ERROR. ill-formed\n</code></pre>\n<p>which if you <a href=\"http://coliru.stacked-crooked.com/a/ba7290dcfe3dbf63\" rel=\"nofollow\">plug in Clang</a> compiles. </p>\n", "OwnerUserId": "493122"}});