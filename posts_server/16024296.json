post_cb({"bq_ids": {"n4140": {"so_16024296_16024312_0": {"length": 32, "quality": 0.6153846153846154, "section_id": 6869}}, "n3337": {"so_16024296_16024312_0": {"length": 50, "quality": 0.9615384615384616, "section_id": 6615}}, "n4659": {"so_16024296_16024312_0": {"length": 32, "quality": 0.6153846153846154, "section_id": 8361}}}, "16024389": {"Id": "16024389", "PostTypeId": "2", "Body": "<p>Nothing guarantees that <code>delete p;</code> will release memory back to the OS -- ever. In fact, in quite a few (most?) implementations, it will do nothing of the sort.</p>\n<p>Exactly how much <em>does</em> happen when you call <code>delete</code> varies though -- in some cases it's nearly instant (just links the block to a list of free memory blocks). In others it does rather more work: destroying objects, and perhaps searching the current free list for adjacent blocks that can be coalesced with the one being freed.</p>\n", "LastActivityDate": "2013-04-15T20:42:39.563", "CommentCount": "0", "CreationDate": "2013-04-15T20:42:39.563", "ParentId": "16024296", "Score": "7", "OwnerUserId": "179910"}, "16024296": {"ViewCount": "871", "Body": "<p>I was wondering if the call to operator <code>delete</code> is synchronous or not. In other words, if I do:</p>\n<pre><code>delete p;\n</code></pre>\n<p>Does the C++ Standard guarantee that only after this call finishes execution the memory is freed? Or is the call asynchronous and simply schedules a task for OS to free this memory as soon as it decides that it is the best time to do so?</p>\n<p>If the first case is the valid one, then does it mean that we have to implement our own asynchronous deleter facility? I'm asking because I'd say that most of the time we (programmers) don't care when the memory is freed exactly, and therefore we don't want our code to freeze and wait for this (most likely expensive?) system call to finish, but rather schedule a task for deletion and immediately continue the execution. Does C++ provide any standard facility (maybe through standard library?) to do this without reinventing the wheel?</p>\n", "AcceptedAnswerId": "16024361", "Title": "Is the call to operator 'delete' synchronous?", "CreationDate": "2013-04-15T20:36:13.430", "Id": "16024296", "CommentCount": "4", "LastEditDate": "2014-08-11T07:49:06.667", "PostTypeId": "1", "LastEditorUserId": "3622940", "LastActivityDate": "2014-08-11T07:49:06.667", "Score": "15", "OwnerUserId": "1743860", "Tags": "<c++><memory-management><asynchronous>", "AnswerCount": "4"}, "16024386": {"Id": "16024386", "PostTypeId": "2", "Body": "<p>The free call in C/C++ is already extremely fast no matter what. \nThere is no reason why you would delay a delete it for a more opportune time in that regard. \nAny book keeping you would need to do for that purpose would more than offset the actual free call duration.</p>\n<p>If your destructor does more work like closing sockets of DB connections then you could do that type of work at a later time but that should be more of an exceptional case.</p>\n", "LastActivityDate": "2013-04-15T20:42:22.867", "CommentCount": "2", "CreationDate": "2013-04-15T20:42:22.867", "ParentId": "16024296", "Score": "0", "OwnerUserId": "7743"}, "16024312": {"Id": "16024312", "PostTypeId": "2", "Body": "<p>As far as you are concerned, everything behaves exactly as you expect, and there are no hidden traps or gotchas. You can always say <code>T * p = new T; delete p;</code> and that's correct, no matter in what context this occurs.</p>\n<p>Given that the operating system routinely has to allocate memory for all sorts of processes and threads concurrently, you can assume that that problem has already been solved correctly.</p>\n<p>More formally, 18.6.1.4/1 (\"Data Races\") says:</p>\n<blockquote>\n<p id=\"so_16024296_16024312_0\">For purposes of determining the existence of data races, the library versions of <code>operator new</code>, user replacement versions of global <code>operator new</code>, and the C standard library functions <code>calloc</code> and <code>malloc</code> shall behave as though they accessed and modified only the storage referenced by the return value. The library versions\n  of <code>operator delete</code>, user replacement versions of <code>operator delete</code>, and the C standard library function <code>free</code> shall behave as though they accessed and modified only the storage referenced by their first argument.</p>\n</blockquote>\n<p>Regarding \"blockingness\": It all boils down to what the C library's allocation function does. Nothing is specified beyond \"this function returns a pointer to some memory\". It's up to the platform how it provides memory allocation.</p>\n", "LastEditorUserId": "3622940", "LastActivityDate": "2014-08-11T07:47:59.617", "Score": "4", "CreationDate": "2013-04-15T20:37:24.537", "ParentId": "16024296", "CommentCount": "4", "OwnerUserId": "596781", "LastEditDate": "2014-08-11T07:47:59.617"}, "16024361": {"Id": "16024361", "PostTypeId": "2", "Body": "<p><code>delete</code> is synchronous. Now, that doesn\u2019t mean that the underlying memory is actually freed at that time by the operating system but from the view of the C++ system it behaves as if.</p>\n<blockquote>\n<p id=\"so_16024296_16024361_0\">I'm asking because I'd say that most of the time we (programmers) don't care when the memory is freed exactly</p>\n</blockquote>\n<p>But <code>delete</code> isn\u2019t mainly about memory, it\u2019s just as much about calling a destructor in a deterministic fashion \u2013 it\u2019s a general-purpose resource-freeing mechanism, not restricted to memory. And here it <em>is</em> important to have synchronicity, otherwise one of the core aspects of C++ \u2013 <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"noreferrer\">RAII</a> \u2013\u00a0wouldn\u2019t work.</p>\n", "LastActivityDate": "2013-04-15T20:40:46.950", "CommentCount": "7", "CreationDate": "2013-04-15T20:40:46.950", "ParentId": "16024296", "Score": "15", "OwnerUserId": "1968"}});