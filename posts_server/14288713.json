post_cb({"bq_ids": {"n4140": {"so_14288713_14289291_0": {"length": 46, "quality": 0.8518518518518519, "section_id": 5462}}, "n3337": {"so_14288713_14289291_0": {"length": 46, "quality": 0.8518518518518519, "section_id": 5249}}, "n4659": {"so_14288713_14289291_0": {"length": 46, "quality": 0.8518518518518519, "section_id": 6896}}}, "14288759": {"Id": "14288759", "PostTypeId": "2", "Body": "<p>Within the class definition itself, items must appear in order (with dependent items appearing before the items that depend on them) like they do at any other scope. Inside a class method <em>body</em> (even if inlined) the entire definition of the class is available.</p>\n", "LastActivityDate": "2013-01-12T00:16:37.263", "CommentCount": "0", "CreationDate": "2013-01-12T00:16:37.263", "ParentId": "14288713", "Score": "3", "OwnerUserId": "251738"}, "14289291": {"Id": "14289291", "PostTypeId": "2", "Body": "<p>In C++ any referenced non-built-in name must have been declared somewhere earlier.</p>\n<p>It might appear that this rule has an exception for class definitions, because the following works fine:</p>\n<pre><code>struct S\n{\n    void foo() { cout &lt;&lt; x_ &lt;&lt; endl; }\n    int x_;\n    S(): x_( 42 ) {}\n};\n</code></pre>\n<p>However, the rule about declaration-before-use applies to the transformed code</p>\n<pre><code>struct S\n{\n    inline void foo();\n    int x_;\n    inline S();\n};\n\nvoid S::foo() { cout &lt;&lt; x_ &lt;&lt; endl; }\nS::S() : x_( 42 ) {}\n</code></pre>\n<p>which is what the compiler \"proper\" sees. And here there is no use of anything that hasn't already been declared.</p>\n<p>The proper C++03 solution to your problem is to define the enumeration type before its first use. With C++11 you can alternatively forward-declare it, but then an underlying type must be specified,</p>\n<blockquote>\n<p id=\"so_14288713_14289291_0\"><strong>C++11 \u00a77.2/3</strong>:<br>\n  \u201cAn <em>opaque-enum-declaration</em> is either a redeclaration of an enumeration in the current scope or a declaration\n  of a new enumeration. [<em>Note:</em> An enumeration declared by an <em>opaque-enum-declaration</em> has fixed underlying\n  type and is a complete type. The list of enumerators can be provided in a later redeclaration with an <em>enum-\n  specifier</em>. <em>\u2014end note</em> ] A scoped enumeration shall not be later redeclared as unscoped or with a different\n  underlying type. An unscoped enumeration shall not be later redeclared as scoped and each redeclaration\n  shall include an <em>enum-base</em> specifying the same underlying type as in the original declaration.\u201d</br></p>\n</blockquote>\n", "LastActivityDate": "2013-01-12T01:35:29.923", "CommentCount": "0", "CreationDate": "2013-01-12T01:35:29.923", "ParentId": "14288713", "Score": "3", "OwnerUserId": "464581"}, "14288713": {"ViewCount": "1567", "Body": "<p>I am using visual studio 2010, and can't quite get, how is this class wrong (syntax error : identifier 'EnumType ') and won't compile:</p>\n<pre><code>class BrokenClassWithEnum\n{\nprivate:\n    void useEnum (EnumType enumType); //syntax error : identifier 'EnumType '\npublic:\n    enum EnumType \n    {\n        VAL1,\n        VAL2,\n        VAL3\n    };\n}\n</code></pre>\n<p>And this is OK:</p>\n<pre><code>class WorkingClassWithEnum\n{\npublic:\n    enum EnumType \n    {\n        VAL1,\n        VAL2,\n        VAL3\n    };\nprivate:\n    void useEnum (EnumType enumType);\n}\n</code></pre>\n<p>What happened to the class scope?</p>\n", "AcceptedAnswerId": "14289291", "Title": "C++ Enum inside a class - order of declaration matters?", "CreationDate": "2013-01-12T00:11:24.493", "Id": "14288713", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-01-12T01:35:29.923", "Score": "2", "OwnerUserId": "1374322", "Tags": "<c++><visual-studio-2010>", "AnswerCount": "3"}, "14288756": {"Id": "14288756", "PostTypeId": "2", "Body": "<p>I don't think the order of definition (not declaration) matters but a forward declaration will resolve this error - at least in MSVC++ 6.  Outside of MSVC++ 6 you should specify a storage type to forward declare an enum (the requirement for specifying the storage type in a forward enum was in the C++0x standard)</p>\n<p>NOTE: VC++ 6 will allow the storage type to be omitted, but if you are forward declaring an enum, you should declare the storage type (SEE BELOW):</p>\n<p><h3>This will resolve the error in VC++6.  However, VC++6 does not appear to support a STORAGE TYPE for an enum inside a class as required by the C++0x standard:</h3></p>\n<pre><code>class BrokenClassWithEnum {\npublic:\n    enum EnumType;\n\nprivate:\n    void useEnum (EnumType enumType); \npublic:\n    enum EnumType {\n        VAL1,\n        VAL2,\n        VAL3\n    };\n};\n</code></pre>\n<p><hr/></p>\n<p><h3>Normally I.E. within a C++0x compliant compiler you would use something like:</h3></p>\n<pre><code>class BrokenClassWithEnum {\npublic:\n    enum EnumType : int;\n\nprivate:\n    void useEnum (EnumType enumType);\npublic:\n    enum EnumType : int {\n        VAL1,\n        VAL2,\n        VAL3\n    };\n};\n</code></pre>\n<p><b>NOTE:</b>Forward declaration of enums is possible in some but not all C++ versions:</p>\n<p><a href=\"https://stackoverflow.com/questions/71416/forward-declaring-an-enum-in-c\">Forward declaring an enum in c++</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-12T00:31:37.333", "Score": "5", "CreationDate": "2013-01-12T00:16:09.547", "ParentId": "14288713", "CommentCount": "2", "OwnerUserId": "1298874", "LastEditDate": "2017-05-23T11:53:01.437"}});