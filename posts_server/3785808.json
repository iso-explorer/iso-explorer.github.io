post_cb({"3785838": {"Body": "<p>The order in which destructors for automatic, global, and static objects are called is always well defined: it's the reverse of the order in which the constructors were called. So if object <code>A</code> references an object <code>B</code> and <code>B</code> was <em>constructed before</em> <code>A</code>, you can be sure that <code>B</code> is <em>destructed after</em> <code>A</code>. That leaves us with the question of the order of constructors. </p>\n<p>Here's what I remember: </p>\n<ol>\n<li>Global and static objects are constructed before <code>main()</code> is called. </li>\n<li>Class-local statics are constructed before any object of their class. </li>\n<li>Function-local statics are constructed when their scope is reached for the first time. </li>\n<li>Global and static objects <em>within the same translation unit</em> are constructed in the order they are defined. (That means that the order of inclusion of headers might affect this!)</li>\n<li>The order of construction of global and static objects <em>across translation units</em> is undefined. </li>\n</ol>\n<p>I'm a bit hazy on some of these, so please correct me if you think this isn't right. </p>\n", "CreationDate": "2010-09-24T09:40:07.097", "ParentId": "3785808", "CommentCount": "6", "LastEditDate": "2010-09-24T09:45:37.530", "Id": "3785838", "PostTypeId": "2", "LastActivityDate": "2010-09-24T09:45:37.530", "LastEditorUserId": "140719", "CommunityOwnedDate": "2010-09-25T09:50:06.400", "Score": "2", "OwnerUserId": "140719"}, "3822635": {"PostTypeId": "2", "Body": "<p>Okay I tried to read the C++ standard myself to find some answers. I see from the answers I get that there is a lot of confusion about difference between constructing an object and allocating it.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_3785808_3822635_0\">3.6.2\n  Initialization of non-local objects</p>\n<p id=\"so_3785808_3822635_1\">Objects with static storage duration\n  (3.7.1) shall be zero-initialized\n  (8.5) before any other initialization\n  takes place. A  reference with static\n  storage duration and an object of POD\n  type with static storage duration can\n  be initialized with a constant\n  expression (5.19); this is called\n  constant initialization. Together,\n  zero-initialization and constant\n  initialization are called static\n  initialization; all other\n  initialization is dynamic\n  initialization. Static initialization\n  shall be performed before any dynamic\n  initialization takes place. Dynamic\n  initialization of an object is either\n  ordered or unordered.</p>\n</blockquote>\n<p>My interpretatio of this is that a <strong>const char[]</strong> will always be guaranteed to have been set before any constructor is run. </p>\n<blockquote>\n<p id=\"so_3785808_3822635_2\">3.6.3 Termination\n  Destructors (12.4) for initialized objects of static storage duration (declared at block scope or at namespace scope) are\n   called as a result of returning from main and as a result of calling std::exit (18.3). These objects are destroyed in the\n  reverse order of the completion of their constructor or of the completion of their dynamic initialization. If an object is\n  initialized statically, the object is destroyed in the same order as if the object was dynamically initialized.</p>\n</blockquote>\n<p>From what I can read from this <em>POD</em> types with constant expression will be initialized before any object types and destroyed after any object types. Meaning no code will run that can access them while they are not valid.</p>\n<p>Which should explain why Google's C++ code standard says you should only use <a href=\"http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=Static_and_Global_Variables#Static_and_Global_Variables\" rel=\"nofollow\">POD types with constant expressions.</a>:</p>\n<blockquote>\n<p id=\"so_3785808_3822635_3\">As a result we only allow static variables to contain POD data. This rule completely disallows vector (use C arrays instead), or string (use const char []). </p>\n</blockquote>\n", "LastActivityDate": "2010-09-29T14:34:30.060", "Id": "3822635", "CommentCount": "1", "CreationDate": "2010-09-29T14:34:30.060", "ParentId": "3785808", "Score": "1", "OwnerUserId": "66634"}, "bq_ids": {"n4140": {"so_3785808_3822635_1": {"length": 42, "quality": 0.7636363636363637, "section_id": 7151}, "so_3785808_3822635_2": {"length": 30, "quality": 0.6666666666666666, "section_id": 7156}}, "n3337": {"so_3785808_3822635_1": {"length": 43, "quality": 0.7818181818181819, "section_id": 6895}, "so_3785808_3822635_2": {"length": 30, "quality": 0.6666666666666666, "section_id": 6900}}}, "3785808": {"ViewCount": "699", "Body": "<p>Say I have defined a variable like this (C++):</p>\n<pre><code>static const char str[] = \"Here is some string data\";\n</code></pre>\n<p>And I have a statically allocated class instance which references this array in its destructor, can this go wrong? E.g. could the <em>str</em> variable somehow get invalid?</p>\n<pre><code>class A {\n ~A() {\n   cout &lt;&lt; str &lt;&lt; endl;\n }\n};\n\nstatic A a;\n</code></pre>\n<p>My assumption is that it can't go wrong, but I can find it clearly stated anywhere. I want to know this for sure. My assumption is that we can not predict the sequence in which destructors for statically allocated objects are called but that the data itself is never really freed until the process is torn down. Meaning pointers to POD should be safe, but not object instances.</p>\n<p>Meaning e.g. this:</p>\n<pre><code>static const QString str = \"Here is some string data\";\n</code></pre>\n<p>or</p>\n<pre><code>static const std::string str = \"Here is some string data\";\n</code></pre>\n<p>Can not safely be used in <em>A</em>'s destructor because they both allocate their string data on the heap and this might be freed by the destructor before <em>A</em>'s destructor is called.</p>\n<p>Is my assumption right and are there any sections in the C++ standard explaining this or some link to some other authority who can verify this?</p>\n", "AcceptedAnswerId": "3822635", "Title": "Can static allocated memory become invalid during static deinitialization?", "CreationDate": "2010-09-24T09:35:39.383", "Id": "3785808", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-09-29T14:34:30.060", "Score": "2", "OwnerUserId": "66634", "Tags": "<c++><memory><static><destructor>", "AnswerCount": "3"}, "3785950": {"PostTypeId": "2", "Body": "<p>If I remember correctly, global object initialization is not defined in the standard (or poorly defined) making global objects hard to reference each other. </p>\n<p>If you want to be sure about initialization order, use a global function with your static object in it, that just return it. You're now garanteed that the static object will be initialized on first function call. </p>\n<p>Destruction will occur at the end of the application, once out of main().</p>\n", "LastActivityDate": "2010-09-24T09:57:02.390", "Id": "3785950", "CommentCount": "2", "CreationDate": "2010-09-24T09:57:02.390", "ParentId": "3785808", "Score": "0", "OwnerUserId": "2368"}});