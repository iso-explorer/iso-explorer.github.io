post_cb({"7644228": {"ParentId": "7644113", "CommentCount": "0", "Body": "<p>The relevant paragraph of the C++03 standard is \u00a77.2.5:</p>\n<blockquote>\n<p id=\"so_7644113_7644228_0\">The underlying type of an enumeration is an integral type that can represent all the enumerator values\n  defined in the enumeration. <strong>It is implementation-defined which integral type is used as the underlying type\n  for an enumeration</strong> except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is\n  as if the enumeration had a single enumerator with value 0. The value of sizeof() applied to an enumeration type, an object of enumeration type, or an enumerator, is the value of sizeof() applied to the\n  underlying type.</p>\n</blockquote>\n<p>So it's implementation defined. The only thing you are guaranteed is that if you define an enum where all values fit into an <code>int</code>, then the enumeration type's size won't be greater than <code>int</code>. (But since <code>int</code>'s size is also implementation-defined, that doesn't give you much.)</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "7644228", "Score": "6", "CreationDate": "2011-10-04T06:53:26.133", "LastActivityDate": "2011-10-04T06:53:26.133"}, "7645538": {"ParentId": "7644113", "CommentCount": "0", "Body": "<p>If you know that your enum list is only ever going to be a certain size it might be worth type casting it when used, and also have an assert for if that size is ever exceeded, at least thats how I use enums when sending packets</p>\n", "OwnerUserId": "94192", "PostTypeId": "2", "Id": "7645538", "Score": "0", "CreationDate": "2011-10-04T09:06:18.543", "LastActivityDate": "2011-10-04T09:06:18.543"}, "7644113": {"CommentCount": "1", "ViewCount": "113", "CreationDate": "2011-10-04T06:39:22.940", "LastActivityDate": "2011-10-04T13:58:24.050", "Title": "Is there a guaranteed width of the underlying int for an enum?", "AcceptedAnswerId": "7644228", "PostTypeId": "1", "Id": "7644113", "Score": "1", "Body": "<p>In the example in N2347 one advantage if the new <em>stongly typed enums</em> (C++11) compared the current (C++03) is explained by an example with an \"old\" enum:</p>\n<pre><code>enum Version { Ver1 = 1, Ver2 = 2 };\nstruct Packet {\n    Version ver;\n    // ... more data ...\n    // bad, size can vary by implementation\n   Version getVersion() const { return ver; }\n};\n</code></pre>\n<p>I wonder: means \"varying\" here that the <strong>compiler can even choose a 8bit</strong> representation, i.e. that the enum-elements occupy only one word? Or is there a minimum length guaranteed and the <strong>choice may only be between <code>int</code> and <code>long</code></strong>?</p>\n<p>In other words, if I have a <code>Version</code> enum like this:</p>\n<pre><code>enum VersionXyz { Ver1 = 100, Ver2 = 200 };\nstruct Packet {\n    VersionXyz ver;\n    // ... more data ...\n};\n</code></pre>\n<p>Is it possible that this takes only <code>8bit</code> in <code>Packet</code>. And after a software update to:</p>\n<pre><code>enum VersionXyz { Ver1 = 100, Ver2 = 200, Ver3=300 };\n</code></pre>\n<p><strong>now <code>Packet</code> has not the same size anymore</strong> because the enum has grown?</p>\n", "Tags": "<c++><enums>", "OwnerUserId": "472245", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7644113_7644228_0": {"section_id": 5466, "quality": 0.6428571428571429, "length": 36}}, "n3337": {"so_7644113_7644228_0": {"section_id": 5252, "quality": 0.6607142857142857, "length": 37}}, "n4659": {"so_7644113_7644228_0": {"section_id": 6900, "quality": 0.6428571428571429, "length": 36}}}});