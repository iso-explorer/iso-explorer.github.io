post_cb({"25863716": {"ParentId": "25863485", "CommentCount": "0", "Body": "<p>You cannot do that probably because member functions has different signature visible by compiler, which is</p>\n<pre><code>void foo(double)\n</code></pre>\n<p>vs</p>\n<pre><code>void obj::foo(int)\n</code></pre>\n", "OwnerUserId": "4035785", "PostTypeId": "2", "Id": "25863716", "Score": "1", "CreationDate": "2014-09-16T08:12:16.573", "LastActivityDate": "2014-09-16T08:12:16.573"}, "25865297": {"ParentId": "25863485", "LastEditDate": "2014-09-16T17:59:40.510", "CommentCount": "1", "CreationDate": "2014-09-16T09:32:58.993", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "25865297", "Score": "1", "Body": "<p>This is plain old unqualified name lookup, specified in \u00a73.4.1 [basic.lookup.unqual]:</p>\n<blockquote>\n<p id=\"so_25863485_25865297_0\">1 In all the cases listed in 3.4.1, the scopes are searched for a\n  declaration in the order listed in each of the respective categories;\n  name lookup ends as soon as a declaration is found for the name. If no\n  declaration is found, the program is ill-formed.</p>\n<p id=\"so_25863485_25865297_1\">8 For the members of a class <code>X</code>, a name used in a member function\n  body, in a default argument, in an <em>exception-specification</em>, in the\n  <em>brace-or-equal-initializer</em> of a non-static data member (9.2), or in the definition of a class member outside of the definition of X,\n  following the member\u2019s <em>declarator-id</em>, shall be declared in one of\n  the following ways:</p>\n<ul>\n<li>before its use in the block in which it is used or in an enclosing block (6.3), or</li>\n<li>shall be a member of class <code>X</code> or be a member of a base class of <code>X</code> (10.2), or</li>\n<li>if <code>X</code> is a nested class of class <code>Y</code> (9.7), shall be a member of <code>Y</code>, or shall be a member of a base class of <code>Y</code> (this lookup applies\n  in turn to <code>Y</code>\u2019s enclosing classes, starting with the innermost\n  enclosing class), or</li>\n<li>if <code>X</code> is a local class (9.8) or is a nested class of a local class, before the definition of class <code>X</code> in a block enclosing the definition\n  of class <code>X</code>, or</li>\n<li>if <code>X</code> is a member of namespace <code>N</code>, or is a nested class of a class that is a member of <code>N</code>, or is a local class or a nested class within\n  a local class of a function that is a member of <code>N</code>, before the use of\n  the name, in namespace <code>N</code> or in one of <code>N</code>\u2019s enclosing namespaces.</li>\n</ul>\n</blockquote>\n<p>Note first that name lookup stops as soon as a declaration is found. So if you have <code>using ::foo;</code> in <code>callFoo()</code>, lookup for <code>foo</code> will end there and never touch the second bullet point; if you don't have it, lookup for <code>foo</code> will find the member <code>foo()</code> at the second bullet point and never search elsewhere. The way unqualified name lookup is specified means that you will either find class members or non-class-members, but never both.</p>\n<p>This is also noted in \u00a713.1.1.1 [over.call.func]/p3:</p>\n<blockquote>\n<p id=\"so_25863485_25865297_2\">In unqualified function calls, the name is not qualified by an -&gt; or .\n  operator and has the more general form of a <em>primary-expression</em>. The\n  name is looked up in the context of the function call following the\n  normal rules for name lookup in function calls (3.4). The function\n  declarations found by that lookup constitute the set of candidate\n  functions. Because of the rules for name lookup, the set of candidate\n  functions consists (1) entirely of non-member functions or (2)\n  entirely of member functions of some class <code>T</code>. In case (1), the argument list\n  is the same as the <em>expression-list</em> in the call. In case (2), the\n  argument list is the <em>expression-list</em> in the call augmented by the\n  addition of an implied object argument as in a qualified function\n  call.</p>\n</blockquote>\n<hr>\n<p>A <em>using-declaration</em> at class scope must name a base class member (\u00a77.3.3 [namespace.udecl]/p3):</p>\n<blockquote>\n<p id=\"so_25863485_25865297_3\">In a <em>using-declaration</em> used as a <em>member-declaration</em>, the\n  <em>nested-name-specifier</em> shall name a base class of the class being defined.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2014-09-16T17:59:40.510"}, "25863649": {"ParentId": "25863485", "LastEditDate": "2014-09-16T08:16:12.823", "CommentCount": "0", "CreationDate": "2014-09-16T08:08:23.997", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "PostTypeId": "2", "Id": "25863649", "Score": "4", "Body": "<p>I doubt you can make the compiler call one or the other based on the type. You can of course use a local wrapper function, something like this:</p>\n<pre><code>  void callFoo() { \n    foo(6.4); \n    foo(0); \n  }\nprivate:\n  void foo(double val) { ::foo(val); }\n</code></pre>\n<p>The wrapper function should nicely inline into nothing, so there is no actual overhead when compiled with optimisation.</p>\n<p>Or don't call the member and the global function the same name, which makes life a whole lot easier!</p>\n", "LastActivityDate": "2014-09-16T08:16:12.823"}, "25863485": {"CommentCount": "6", "CreationDate": "2014-09-16T07:58:16.743", "PostTypeId": "1", "AcceptedAnswerId": "25865297", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-16T17:59:40.510", "LastEditDate": "2017-05-23T12:21:40.387", "ViewCount": "430", "FavoriteCount": "1", "Title": "Is it possible to bring global function into the overload resolution with member function?", "Id": "25863485", "Score": "5", "Body": "<p><a href=\"https://stackoverflow.com/q/25862633/3309790\">Here</a> is the corresponding question, what I want to know is, Is it possible to bring global function into the overload resolution with member function?</p>\n<p>I tried in 2 ways, but both don't work:</p>\n<pre><code>void foo(double val) { cout &lt;&lt; \"double\\n\";}\n\nclass obj {\npublic:\n  using ::foo; // (1) compile error: using-declaration for non-member at class scope\n  void callFoo() { \n    using ::foo; // (2\uff09will cause the global version always be called\n    foo(6.4); \n    foo(0); \n  }\nprivate:\n  void foo(int val) {cout &lt;&lt; \"class member foo\\n\"; }\n};\n</code></pre>\n", "Tags": "<c++><function-overloading>", "OwnerUserId": "3309790", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_25863485_25865297_2": {"section_id": 577, "quality": 0.9701492537313433, "length": 65}, "so_25863485_25865297_1": {"section_id": 7094, "quality": 0.9615384615384616, "length": 25}, "so_25863485_25865297_0": {"section_id": 7087, "quality": 0.9545454545454546, "length": 21}, "so_25863485_25865297_3": {"section_id": 5492, "quality": 1.0, "length": 9}}, "n3337": {"so_25863485_25865297_2": {"section_id": 567, "quality": 0.9701492537313433, "length": 65}, "so_25863485_25865297_1": {"section_id": 6838, "quality": 0.5384615384615384, "length": 14}, "so_25863485_25865297_0": {"section_id": 6831, "quality": 0.9545454545454546, "length": 21}, "so_25863485_25865297_3": {"section_id": 5278, "quality": 1.0, "length": 9}}, "n4659": {"so_25863485_25865297_2": {"section_id": 600, "quality": 0.9701492537313433, "length": 65}, "so_25863485_25865297_1": {"section_id": 8595, "quality": 0.9230769230769231, "length": 24}, "so_25863485_25865297_3": {"section_id": 6926, "quality": 1.0, "length": 9}, "so_25863485_25865297_0": {"section_id": 8588, "quality": 0.9545454545454546, "length": 21}}}, "25863799": {"ParentId": "25863485", "LastEditDate": "2014-09-16T09:02:40.913", "CommentCount": "2", "CreationDate": "2014-09-16T08:17:11.127", "OwnerUserId": "442284", "LastEditorUserId": "442284", "PostTypeId": "2", "Id": "25863799", "Score": "1", "Body": "<p>What it appears you are trying to do is use the parameter type to choose the correct overload, and to bring the external foo into your class or member function.</p>\n<p>Bringing it into the class is easy. You just declare another overload as a class member that forwards to the external one.</p>\n<p>Bringing into the function is tricky but can be done by use of helper functions e.g. <code>fooCaller( double )</code> and <code>fooCaller( int )</code> which you can call from callFoo.</p>\n<p>If you don't want to expose these to the external user, i.e. hide them away in the cpp file, it can be done but is trickier, due to the fact that <code>foo</code> in your class is private. You would have to have your <code>callFoo</code> function pass in the private function as a member function to \"call\" for the int overload.</p>\n", "LastActivityDate": "2014-09-16T09:02:40.913"}});