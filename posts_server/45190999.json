post_cb({"45192353": {"ParentId": "45190999", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-07-19T13:39:19.943", "Score": "1", "LastEditorUserId": "3545273", "LastEditDate": "2017-07-19T13:51:36.470", "Id": "45192353", "OwnerUserId": "3545273", "Body": "<p><code>char</code> is a <em>fundamental</em> type (ref 3.9.1 Fundamental types [basic.fundamental] in draft n4296 for C++14). It has neither constructor nor destructor and can be used in <code>constexpr</code>.</p>\n<p>On the other hand, <code>std::string</code> is a class type. More exactly it is a specialization of <code>basic_string</code>, namely <code>basic_string&lt;char&gt;</code>. And the <code>basic_string</code> class has a lot of constructors, including the one taking a <code>const char *</code> parameter that is used in you code, but none is declared <code>constexpr</code>, so you cannot build a <code>constexpr std::string</code>. It makes sense, because the creation of a <code>std::string</code> is far from trivial and include dynamic allocation of a char array:</p>\n<blockquote>\n<pre><code>basic_string(const charT* s, const Allocator&amp; a = Allocator());\n</code></pre>\n<p id=\"so_45190999_45192353_0\">... an allocated copy of\n  the array whose first element is pointed at by s</p>\n</blockquote>\n<p>But IMHO the correct way would to declare an array:</p>\n<pre><code>class myClass\n{\n     static constexpr const char S[] =\"aa\";\n}\nconst char A::S[];  // do not forget to define the static element if it is later odr-used...\n</code></pre>\n<p>By the way, static data members shall be defined outside of their class definition if they are later odr used in the program. Implementations often allow integral constants or pointers to not be defined outside the class definition (anyway, no diagnostic is required for the <em>one definition rule</em> and undefined behaviour allows expected results), but strict C++ semantics do not.</p>\n<p>Ref from n4296 draft for C++14 : 9.4.2 Static data members [class.static.data] \u00a73</p>\n<blockquote>\n<p id=\"so_45190999_45192353_1\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignmentexpression\n  is a constant expression (5.20). A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014end note ] The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer.</p>\n</blockquote>\n", "LastActivityDate": "2017-07-19T13:51:36.470"}, "45190999": {"CommentCount": "5", "ViewCount": "279", "PostTypeId": "1", "LastEditorUserId": "817643", "CreationDate": "2017-07-19T12:43:33.733", "LastActivityDate": "2017-07-19T13:51:36.470", "Title": "Why initilizing static const string member is not possible in class body", "AcceptedAnswerId": "45192353", "LastEditDate": "2017-07-19T13:12:13.257", "Id": "45190999", "Score": "0", "Body": "<p>I am using c++ 14.\nI need to use static const string  in my class. But when I write </p>\n<pre><code>class myClass\n{\n     static constexpr const std::string S=\"aa\";\n}\n</code></pre>\n<p>it doesn't compile. The result from compiler(g++) is</p>\n<pre class=\"lang-none prettyprint-override\"><code>type 'const string {aka const std::__cxx11::basic_string&lt;char&gt;}' of constexpr variable 'S::S' is not literal\n</code></pre>\n<p>If I write it with char pointer like:</p>\n<pre><code>class myClass\n{\n     static constexpr const *char S=\"aa\";\n}\n</code></pre>\n<p>it is compiled.</p>\n<p>I know that string can be initialized outside class.\nMy question is why 1-st variant is not compiled, second does. I would like to know what standard say.</p>\n", "Tags": "<c++><c++14>", "OwnerUserId": "3393524", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_45190999_45192353_1": {"section_id": 5908, "quality": 0.9206349206349206, "length": 58}, "so_45190999_45192353_0": {"section_id": 1569, "quality": 1.0, "length": 7}}, "n3337": {"so_45190999_45192353_1": {"section_id": 5680, "quality": 0.9206349206349206, "length": 58}, "so_45190999_45192353_0": {"section_id": 1565, "quality": 1.0, "length": 7}}, "n4659": {"so_45190999_45192353_0": {"section_id": 1718, "quality": 1.0, "length": 7}}}});