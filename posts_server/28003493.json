post_cb({"28003780": {"ParentId": "28003493", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Clang is correct here. Friend functions defined inside classes can only be found using argument-dependent-lookup on their arguments, not by ordinary lookup. Because <code>Print</code> is not an associated scope to <code>Object</code>, the <code>operator&lt;&lt;</code> should not be found. Partial quote from the Standard:</p>\n<p><strong>7.3.1.2 Namespace member definitions [namespace.memdef]</strong></p>\n<blockquote>\n<p id=\"so_28003493_28003780_0\">3 Every name first declared in a namespace is a member of that\n  namespace. If a friend declaration in a non-local class first declares\n  a class, function, class template or function template97 the friend is\n  a member of the innermost enclosing namespace. <strong>The friend declaration\n  does not by itself make the name visible to unqualified lookup (3.4.1)\n  or qualified lookup (3.4.3).</strong> [ Note: The name of the friend will be\n  visible in its namespace if a matching declaration is provided at\n  namespace scope (either before or after the class definition granting\n  friendship). \u2014 end note ] <strong>If a friend function or function template is\n  called, its name may be found by the name lookup that considers\n  functions from namespaces and classes associated with the types of the\n  function arguments (3.4.2).</strong></p>\n</blockquote>\n<p>As @sehe mentions, the proper way to add an <code>operator&lt;&lt;</code> to <code>Object</code> is to define it as a global function (using <code>Object</code> interface) or as a <code>friend</code> function inside itself (using <code>private</code> functions from <code>Object</code>), not in some auxiliary class. See also Herb Sutter's old GotW column <a href=\"http://www.gotw.ca/publications/mill02.htm\"><strong>\"What's in a class?\"</strong></a></p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2015-01-17T20:14:22.407", "Id": "28003780", "Score": "9", "CreationDate": "2015-01-17T20:07:53.997", "LastActivityDate": "2015-01-17T20:14:22.407"}, "28003785": {"ParentId": "28003493", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The iffy thing is to declare an static (friend) operator in <em>another</em> class (that is unrelated). </p>\n<ol>\n<li><p>You could just create it in the surrounding scope, there's </p>\n<ul>\n<li>no difference semantically</li>\n<li>no reason to have it a friend (as <code>Printer</code> is not used any way)</li>\n<li>you can still make it a friend if you needed to</li>\n</ul>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/927f08ebe7c9ab13\" rel=\"nofollow\">Live On Coliru</a></strong></p></li>\n<li><p>Alternatively, <strong>make</strong> the other class <em>related</em>; </p>\n<p>There are many ways to associate namespaces (\u00a73.4.2) with a type for function lookup. For example this hack would be enought to associate the <code>Print</code> class namespace with the <code>Object</code> type so ADL will still work:</p>\n<pre><code>template &lt;typename&gt; struct Object_ {};\ntypedef Object_&lt;class Print&gt; Object;\n</code></pre>\n<p>See this <strong><a href=\"http://coliru.stacked-crooked.com/a/2f3aac5a030efa86\" rel=\"nofollow\">Live On Coliru</a></strong> as well</p></li>\n</ol>\n", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2015-01-17T20:45:59.037", "Id": "28003785", "Score": "4", "CreationDate": "2015-01-17T20:08:44.017", "LastActivityDate": "2015-01-17T20:45:59.037"}, "28003493": {"CommentCount": "4", "AcceptedAnswerId": "28003780", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2015-01-17T19:42:05.927", "LastActivityDate": "2015-01-17T20:45:59.037", "LastEditDate": "2015-01-17T20:18:00.560", "ViewCount": "726", "FavoriteCount": "1", "Title": "clang/g++ difference with friend function", "Id": "28003493", "Score": "11", "Body": "<p>Why code below well compiled in g++ but get error on clang?</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Object {};\n\nclass Print\n{\npublic:\n    template &lt;typename CharT&gt;\n    inline friend std::basic_ostream&lt;CharT&gt; &amp; operator&lt;&lt;(std::basic_ostream&lt;CharT&gt; &amp; out, const Object&amp;)\n    {\n        return (out &lt;&lt; \"object\");\n    }\n    static void f( const Object&amp; str )\n    {\n        std::cout &lt;&lt; str;\n    }\n};\n\nint main()\n{\n    std::cout &lt;&lt; Object() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Proof links: <a href=\"http://coliru.stacked-crooked.com/a/afc00647b7baec34\" rel=\"noreferrer\">g++</a> / <a href=\"http://coliru.stacked-crooked.com/a/1f60d9ce71a838d1\" rel=\"noreferrer\">clang++</a></p>\n<p>When I moved friend function to global namespace, code well compiled for both compilers (<a href=\"http://coliru.stacked-crooked.com/a/b3bd205ead6be4b0\" rel=\"noreferrer\">clang++</a> / <a href=\"http://coliru.stacked-crooked.com/a/bf1ef812b90602b0\" rel=\"noreferrer\">g++</a>).</p>\n<p>Which implementation in this case is more C++ Standart compatible? </p>\n", "Tags": "<c++><g++><clang++><friend-function><name-lookup>", "OwnerUserId": "3240681", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28003493_28003780_0": {"section_id": 5485, "quality": 0.8875, "length": 71}}, "n3337": {"so_28003493_28003780_0": {"section_id": 5271, "quality": 0.7, "length": 56}}, "n4659": {"so_28003493_28003780_0": {"section_id": 6920, "quality": 0.8, "length": 64}}}});