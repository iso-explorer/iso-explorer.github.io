post_cb({"14273128": {"Id": "14273128", "PostTypeId": "2", "Body": "<p>There is one thing to keep in mind: You can't use <code>const_cast</code> to make a <code>const</code> variable writable. You can only use it to retrieve a non-const reference from a const reference if that const reference refers to a non-const object. Sounds complicated? Example:</p>\n<pre><code>// valid:\nint x;\nint const&amp; x1 = x;\nconst_cast&lt;int&amp;&gt;(x1) = 0;\n// invalid:\nint const y = 42;\nint const&amp; y1 = y;\nconst_cast&lt;int&amp;&gt;(y1) = 0;\n</code></pre>\n<p>In reality, both of these will compile and sometimes even \"work\". However, the second one causes undefined behaviour and in many cases will terminate the program when the constant object is placed in read-only memory.</p>\n<p>That said, a few more things: <code>reinterpret_cast</code> is the most powerful cast, but also the most dangerous one, so don't use it unless you have to. When you need to go from <code>void*</code> to <code>sometype*</code>, use <code>static_cast</code>. When going the opposite direction, use the built-in implicit conversion or use an explicit <code>static_cast</code>, too. Similarly with adding or removing <code>const</code>, which is also added implicitly. Concerning <code>reinterpret_cast</code>, see also the discussion at <a href=\"https://stackoverflow.com/questions/6594395/c-when-should-we-prefer-to-use-a-two-chained-static-cast-over-reinterpret-cast\">C++ When should we prefer to use a two chained static_cast over reinterpret_cast</a> where an alternative that is less hackish is discussed.</p>\n<p>Uli</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-01-11T06:48:56.137", "Score": "1", "CreationDate": "2013-01-11T06:48:56.137", "ParentId": "14272578", "CommentCount": "0", "LastEditDate": "2017-05-23T12:33:56.653", "OwnerUserId": "1968182"}, "14272923": {"Id": "14272923", "PostTypeId": "2", "Body": "<p>The only place where I can think of for relating reinterpret_cast with const-ness is when passing a const object to an API that accepts a void pointer -</p>\n<pre><code>UINT ThreadFunction(void* param)\n{\n    const MyClass* ptr = reinterpret_cast&lt;const MyClass*&gt;(param);\n}\n</code></pre>\n", "LastActivityDate": "2013-01-11T06:32:03.393", "Score": "0", "CreationDate": "2013-01-11T06:32:03.393", "ParentId": "14272578", "CommentCount": "0", "OwnerUserId": "657259"}, "14273224": {"Id": "14273224", "PostTypeId": "2", "Body": "<p>yeah, as you know, const_cast means that it removes constness from a specific type.</p>\n<p>But, when we need to add constness to a type. Is there a reason we have to do it?</p>\n<p>for example, </p>\n<pre><code>void PrintAnything(void* pData)\n{\n    const CObject* pObject = reinterpret_cast&lt;CObject*&gt;(pData);\n    // below is bla-bla-bla.\n}\n</code></pre>\n<p>reinterpret_cast has nothing to do with 'const'.</p>\n<p>const_cast means two things.\nfirst one is to remove constness from a type and the other is to give its code explicitness. Because you can use cast it using C-style cast, but this is not explicit so that is not recommended.</p>\n<p>They do not function same. it is definitely different.</p>\n", "LastActivityDate": "2013-01-11T06:57:36.603", "Score": "0", "CreationDate": "2013-01-11T06:57:36.603", "ParentId": "14272578", "CommentCount": "0", "OwnerUserId": "1047044"}, "bq_ids": {"n4140": {"so_14272578_14272578_1": {"length": 14, "quality": 0.7, "section_id": 6046}}, "n3337": {"so_14272578_14272578_1": {"length": 17, "quality": 0.85, "section_id": 5814}}, "n4659": {"so_14272578_14272578_1": {"length": 14, "quality": 0.7, "section_id": 7545}}}, "14272734": {"Id": "14272734", "PostTypeId": "2", "Body": "<p><code>reinterpret_cast</code> changes the interpretation of the data within the object. <code>const_cast</code> adds or removes the <code>const</code> qualifier. Data representation and constness are orthogonal. So it makes sense to have different cast keywords.</p>\n<blockquote>\n<p id=\"so_14272578_14272734_0\">So if I add constness using reinterpret_cast and if you reinterpret_cast the result back to the original type, it should result back to the original type and should not be UB, but that violates the fact that one should only use const_cast to remove the constness</p>\n</blockquote>\n<p>That wouldn't even compile:</p>\n<pre><code>int * n = new int;\nconst * const_added = reinterpret_cast&lt;const int *&gt;(n);\nint * original_type = reinterpret_cast&lt;int*&gt;(const_added);\n    // error: reinterpret_cast from type \u2018const int*\u2019 to type \u2018int*\u2019 casts away qualifiers\n</code></pre>\n", "LastEditorUserId": "75889", "LastActivityDate": "2013-09-24T06:14:07.847", "Score": "9", "CreationDate": "2013-01-11T06:16:11.700", "ParentId": "14272578", "CommentCount": "2", "LastEditDate": "2013-09-24T06:14:07.847", "OwnerUserId": "75889"}, "14272746": {"Id": "14272746", "PostTypeId": "2", "Body": "<p>You shouldn't <em>just</em> be adding <code>const</code> with <code>reinterpret_cast</code>. A <code>reinterpret_cast</code> should be primarily that: reinterpreting the pointer (or whatever).</p>\n<p>In other words, if you're going from <code>const char*</code> to <code>char*</code> (hopefully because there's a bad API you can't change), then <code>const_cast</code> is your friend. That's really all it's intended to be.</p>\n<p>But if you need to go from <code>MyPODType*</code> to <code>const char*</code>, you need <code>reinterpret_cast</code>, and it's just being nice by not requiring a <code>const_cast</code> on top of it.</p>\n", "LastActivityDate": "2013-01-11T06:16:52.250", "Score": "3", "CreationDate": "2013-01-11T06:16:52.250", "ParentId": "14272578", "CommentCount": "0", "OwnerUserId": "2624511"}, "14272578": {"ViewCount": "11207", "Body": "<p>Referring the SO C++ FAQ <a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterpret-cast-be-used\">When should static_cast, dynamic_cast and reinterpret_cast be used?</a>.</p>\n<p>const_cast is used to remove or add const to a variable and its the only reliable, defined and legal way to remove the constness. \nreinterpret_cast is used to change the interpretation of a type.</p>\n<p>I understand in a reasonable way, why a const variable should be casted to non-const only using const_cast, but I cannot figure out a reasonable justification of issues using reinterpret_cast instead of const_cast to add constness.</p>\n<p>I understand that using reinterpret_cast for even adding constness is not sane but would it be an UB or potential time bomb for using reinterpret_cast to add constness?</p>\n<p>The reason I was confused here is because of the statement</p>\n<blockquote>\n<p id=\"so_14272578_14272578_0\">Largely, the only guarantee you get with reinterpret_cast is that if\n  you cast the result back to the original type, you will get the exact\n  same value.</p>\n</blockquote>\n<p>So if I add constness using reinterpret_cast and if you reinterpret_cast the result back to the original type, it should result back to the original type and should not be UB, but that violates the fact that one should only use const_cast to remove the constness</p>\n<p>On a separate Note, the standard guarantees that You can add Constness using reinterpret case</p>\n<blockquote>\n<p id=\"so_14272578_14272578_1\">5.2.10 Reinterpret cast (7) ......When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is\n  static_cast(static_cast(v)) if both T1 and T2 are\n  standard-layout types (3.9) and the alignment requirements of T2 are\n  no stricter than those of T1........</p>\n</blockquote>\n", "AcceptedAnswerId": "14272734", "Title": "const_cast vs reinterpret_cast", "CreationDate": "2013-01-11T06:01:12.513", "Id": "14272578", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:33:56.653", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-24T06:14:07.847", "Score": "6", "OwnerUserId": "977038", "Tags": "<c++><casting><const><reinterpret-cast>", "AnswerCount": "5"}});