post_cb({"bq_ids": {"n4140": {"so_27067433_27067700_3": {"length": 9, "quality": 1.0, "section_id": 7104}, "so_27067433_27067700_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 224}, "so_27067433_27067700_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 224}, "so_27067433_27067700_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 188}, "so_27067433_27067700_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 224}, "so_27067433_27067700_4": {"length": 59, "quality": 0.9833333333333333, "section_id": 7104}}, "n3337": {"so_27067433_27067700_3": {"length": 9, "quality": 1.0, "section_id": 6848}, "so_27067433_27067700_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 217}, "so_27067433_27067700_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 217}, "so_27067433_27067700_7": {"length": 7, "quality": 1.0, "section_id": 182}, "so_27067433_27067700_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 217}, "so_27067433_27067700_4": {"length": 60, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_27067433_27067700_3": {"length": 9, "quality": 1.0, "section_id": 8605}, "so_27067433_27067700_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 232}, "so_27067433_27067700_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 232}, "so_27067433_27067700_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 193}, "so_27067433_27067700_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 232}, "so_27067433_27067700_4": {"length": 59, "quality": 0.9833333333333333, "section_id": 8605}}}, "27067700": {"Id": "27067700", "PostTypeId": "2", "Body": "<pre><code>template&lt;typename T, typename... Ts&gt;\nvoid fooImpl(char const *cp, T val, Ts... args) { /* ... */ }\n</code></pre>\n<p>You are declaring an overload (!) of the original template.</p>\n<p>Since in the call</p>\n<pre><code>fooImpl(s.c_str(), args...);\n</code></pre>\n<p>there is a pack-expansion in the argument list, the unqualified-id denotes a dependent name<sup>1</sup>. Dependent name resolution applies. [temp.dep.candidate]:</p>\n<blockquote>\n<p id=\"so_27067433_27067700_0\">For a function call that depends on a template parameter, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><p id=\"so_27067433_27067700_1\"><strong>For the part of the lookup using unqualified name lookup (3.4.1) [..] only function declarations from the\n  template definition context are found.</strong></p></li>\n<li><p id=\"so_27067433_27067700_2\">For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition\n  context or the template instantiation context are found.</p></li>\n</ul>\n</blockquote>\n<p>It's safe to say that unqualified name lookup won't find the second overload as it solely considers declarations from the definition context of the template.<br/></p>\n<p><strong>ADL does apply here, but the global namespace will not be associated with any of the types in the parameter pack</strong>. We have <code>std::string, char const*, double, int</code>. [basic.lookup.argdep]/2 specifies:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_27067433_27067700_3\">If <code>T</code> is a fundamental type, its associated sets of namespaces and\n  classes are both empty.</p></li>\n<li><p id=\"so_27067433_27067700_4\">If <code>T</code> is a class type (including unions), its associated classes are:\n  the class itself; the class of which it is a member, if any; and its\n  direct and indirect base classes. Its associated namespaces are the\n  namespaces of which its associated classes are members. Furthermore,\n  if <code>T</code> is a class template specialization, its associated namespaces and\n  classes also include: the namespaces and classes associated with the\n  types of the template arguments provided for template type parameters\n  (excluding template template parameters); the namespaces of which any\n  template template arguments are members; and the classes of which any\n  member templates used as template template arguments are members.</p></li>\n</ul>\n</blockquote>\n<p>So neither the fundamental types nor <code>std::string</code> include the global namespace as an associated namespace. </p>\n<h3>Long story short...</h3>\n<p>... the global namespace isn't searched in during ADL and the second overload isn't found. Thus the first overload of the function template is the only one found and subsequently chosen by overload resolution. The first overload isn't defined though, hence your linker error is issued.</p>\n<p><hr>\n<sup>1)</sup> [temp.dep]/1:</hr></p>\n<blockquote>\n<p id=\"so_27067433_27067700_5\">In an expression of the form:</p>\n<p id=\"so_27067433_27067700_6\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>postfix-expression</em> <code>(</code>\n<em>expression-list</em><sub>opt</sub> <code>)</code></p>\n<p id=\"so_27067433_27067700_7\">where the postfix-expression is an <em>id-expression</em>, the\n  <em>id-expression</em> denotes a <em>dependent name</em> if</p>\n<ul>\n<li>any of the expressions in the <em>expression-list</em> is a pack expansion (14.5.3),</li>\n<li>[..]</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-21T18:29:31.397", "Score": "5", "CreationDate": "2014-11-21T18:13:07.973", "ParentId": "27067433", "CommentCount": "3", "LastEditDate": "2014-11-21T18:29:31.397", "OwnerUserId": "3647361"}, "27067433": {"ViewCount": "497", "Body": "<p>I have a program with variadic templates and a helper function:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing std::cout;\n\ntemplate&lt;typename... Ts&gt;\nvoid fooImpl(char const *cp, Ts... args);\n\ntemplate&lt;typename... Ts&gt;\ninline void foo(const std::string &amp;s, Ts... args)\n{\n    fooImpl(s.c_str(), args...);\n}\n\nvoid fooImpl(char const *cp)\n{\n    // do something\n}\n\ntemplate&lt;typename T, typename... Ts&gt;\nvoid fooImpl(char const *cp, T val, Ts... args)\n{\n    char special{'@'};\n\n    while (*cp)\n    {\n        if (*cp == special)\n        {\n            // handle val ...\n\n            // recurse over remaining args\n            fooImpl(cp, args...);\n            return;\n        }\n        ++cp;\n    }    \n}\n\nint main()\n{\n    std::string s = \"Hello!\";\n    foo(\"Text\", s, \"C++\", 3.14159, 42);\n}\n</code></pre>\n<p>This gives a linker error:</p>\n<blockquote>\n<p id=\"so_27067433_27067433_0\"><code>/tmp/ccZpPMC2.o:vt-test.cc:</code> function <code>void foo&lt;std::string, char const*, double, int&gt;(std::string const&amp;, std::string, char const*, double, int)</code>: error:<br> undefined reference to '<code>void fooImpl&lt;std::string, char const*, double, int&gt;(char const*, std::string, char const*, double, int)</code>'</br></p>\n</blockquote>\n<p>It compiles and links fine if I put the definition of <code>foo</code> down just before <code>main()</code>.\nSo I assume it's just a bug, but I get this with GCC 4.9 and clang 3.5, so maybe I'm missing something?</p>\n", "AcceptedAnswerId": "27067700", "Title": "Linker error for variadic template", "CreationDate": "2014-11-21T17:56:08.017", "Id": "27067433", "CommentCount": "1", "LastEditDate": "2014-11-21T18:38:00.000", "PostTypeId": "1", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-21T18:38:00.000", "Score": "3", "OwnerUserId": "4015098", "Tags": "<c++><linker-errors><variadic-templates>", "AnswerCount": "1"}});