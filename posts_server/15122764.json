post_cb({"15122912": {"ParentId": "15122764", "CommentCount": "7", "CreationDate": "2013-02-27T21:36:49.930", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "15122912", "Score": "6", "Body": "<p>Your prefix and postfix operator do the same thing because you defined them to do the same thing:</p>\n<pre><code>Iterator&lt;T&gt; operator++()    { pointer = pointer-&gt;next; }\nIterator&lt;T&gt; operator++(int) { pointer = pointer-&gt;next; }\n</code></pre>\n<p>The code is identical, but most importantly, it has <strong>Undefined Behavior</strong>, because your functions are supposed to return a value of type <code>Iterator&lt;T&gt;</code> and, instead, they return nothing. Per Paragraph 6.6.3/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15122764_15122912_0\">[...] Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function.</p>\n</blockquote>\n<p>You should change your prefix iterator into something like this:</p>\n<pre><code>Iterator&lt;T&gt; operator++() \n{ \n    pointer = pointer-&gt;next; \n    return *this;\n}\n</code></pre>\n<p>And your postfix iterator into something like this:</p>\n<pre><code>Iterator&lt;T&gt; operator++(int) \n{ \n    node&lt;T&gt;* previous = pointer;\n    pointer = pointer-&gt;next; \n    return Iterator&lt;T&gt;(previous);\n}\n</code></pre>\n<p>Also, if I understand your design correctly, I really don't think you should be doing this:</p>\n<pre><code>iterator begin() { return iterator(new node&lt;T&gt;(b)); }\n</code></pre>\n<p>I would rather do:</p>\n<pre><code>iterator begin() { return iterator(b); }\n</code></pre>\n", "LastActivityDate": "2013-02-27T21:36:49.930"}, "15122764": {"CommentCount": "0", "ViewCount": "1835", "CreationDate": "2013-02-27T21:28:10.570", "LastActivityDate": "2013-02-27T21:37:29.537", "Title": "Prefix and postfix ++ on custom iterator doing the same", "AcceptedAnswerId": "15122912", "PostTypeId": "1", "Id": "15122764", "Score": "2", "Body": "<p>First of all I'm fairly new to C++ so if this is a beginner coding mistake then I'm sorry.</p>\n<p>I'm currently working on a graphing class for a homework I got at school. I'm supposed to be able to store edges in a set, array and linked list. As I have done all of these in a separate classes I'm now trying to make them all work in one through templating. Everything works fine for ie. std::set, but when i use my own linked list implementation it somehow fails - it looks like my iterators get messed up somewhere, and both prefix and postfix operators on them result in the same behavior (in a for loop). I'll also add that I'm not using std::list because I'm supposed to make my own implementation of linked list.</p>\n<p>My current implementation of the iterator:</p>\n<pre><code>template&lt;typename T&gt;\nclass Iterator{\n    public: node&lt;T&gt;* pointer;\n    public:\n        Iterator(): pointer(0){}\n        Iterator(node&lt;T&gt;* _pointer): pointer(_pointer){}\n\n        Iterator&lt;T&gt; operator++()    { pointer = pointer-&gt;next; }\n        Iterator&lt;T&gt; operator++(int) { pointer = pointer-&gt;next; }\n\n        bool operator!=(Iterator&lt;T&gt; rval){ return !(pointer == rval.pointer); }\n        bool operator==(Iterator&lt;T&gt; rval){ return (pointer == rval.pointer); }\n\n        node&lt;T&gt;* operator()(){ return pointer; }\n\n        T operator*(){ return pointer-&gt;data; }\n\n};\n</code></pre>\n<p>Single linked list node:</p>\n<pre><code>template &lt;typename T&gt;\nstruct node{\n    node(): next(0){}\n    node(T val): data(val), next(0){}\n    node(node&lt;T&gt;* _next): data(0), next(_next){}\n    node(T val, node&lt;T&gt;* _next): data(val), next(_next){}\n\n    T data;\n    node&lt;T&gt;* next;\n};\n</code></pre>\n<p>And how my list class implements begin() and end():</p>\n<pre><code>typedef Iterator&lt;T&gt; iterator;\niterator  begin()   { return iterator(new node&lt;T&gt;(b)); }\niterator  end()     { return iterator(); } \n</code></pre>\n<p>Note that <code>b</code> points to the first element in the linked list</p>\n<p>And finally how I'm accessing the elements (this is in a different class that includes the list):</p>\n<pre><code>void tree_recurse_f(int node, std::ofstream* file, int level = 0){\n   [some output code here]\n   typename T::iterator it;\n   for (it = Database[node].first.begin(); it != Database[node].first.end(); ++it){\n      tree_recurse_f(*it, file, (level+1));\n   }\n}\n</code></pre>\n<p><code>Database</code> is an <code>std::map&lt;int,std::pair&lt;&gt;&gt;</code> and <code>.first</code> points to the type specified by <code>T</code> (set, list or vector)</p>\n<p>Now to the problems:</p>\n<ol>\n<li>Somehow with the current implementation of the lists' <code>begin()</code>, it points to an empty node in the output function (++it, and it++ result in the same thing)</li>\n<li>Changing the <code>begin()</code> to <code>return iterator(b)</code> seems to remove the error in the for loop, though ++it and it++ both result in the same thing</li>\n<li>I've managed to discover these two errors by testing only the list class - if i implement it into the graphing class it enters a never ending loop in the output function (*it always points to 0 and doesn't seem to increase with ++it)</li>\n</ol>\n<p>Looks like some strange stuff with the iterator to me (especially the fact that alone it works, but inside the other class it doesn't)</p>\n<p>// if someone was curious I'm loosely following the linked list tutorial on <a href=\"http://www.cplusplus.com/articles/Lw6AC542/\" rel=\"nofollow\">http://www.cplusplus.com/articles/Lw6AC542/</a></p>\n", "Tags": "<c++><iterator><iteration>", "OwnerUserId": "1124783", "AnswerCount": "3"}, "15122900": {"ParentId": "15122764", "CommentCount": "1", "CreationDate": "2013-02-27T21:35:59.040", "OwnerUserId": "582", "PostTypeId": "2", "Id": "15122900", "Score": "0", "Body": "<p>Your prefix and postfix <code>++</code> operators aren't actually returning anything. I'm surprised your compiler isn't complaining.</p>\n<p>The prefix <code>++</code> operator should just return <code>*this</code>. The postfix <code>++</code> operator should create a temp copy of <code>*this</code> before the modification and then return that copy.</p>\n", "LastActivityDate": "2013-02-27T21:35:59.040"}, "bq_ids": {"n4140": {"so_15122764_15122912_0": {"section_id": 3913, "quality": 1.0, "length": 12}}, "n3337": {"so_15122764_15122912_0": {"section_id": 3773, "quality": 1.0, "length": 12}}, "n4659": {"so_15122764_15122912_0": {"section_id": 4799, "quality": 0.75, "length": 9}}}, "15122919": {"ParentId": "15122764", "CommentCount": "0", "CreationDate": "2013-02-27T21:37:29.537", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "15122919", "Score": "2", "Body": "<p>The <code>operator++</code> implementations here don't have a <code>return</code> statement. The return value is the key difference between pre- and post-increment. Pre-increment takes an iterator, increments it, and returns the new iterator value. It typically returns by reference, because the original iterator is the same as the returned value. Post-increment takes an iterator, squirrels it away, increments the original iterator, and returns the saved copy. This typically returns by value, because it returns an iterator that's different from the iterator it was applied to. So change the signatures to match these:</p>\n<pre><code>Iterator&lt;T&gt;&amp; operator++();\nIterator&lt;T&gt; operator++(int);\n</code></pre>\n<p>and change the implementations to match what I described.</p>\n", "LastActivityDate": "2013-02-27T21:37:29.537"}});