post_cb({"bq_ids": {"n4140": {"so_34164076_34164076_0": {"length": 34, "quality": 1.0, "section_id": 6114}}, "n3337": {"so_34164076_34164076_0": {"length": 18, "quality": 0.5294117647058824, "section_id": 6925}}}, "34164076": {"CreationDate": "2015-12-08T19:12:02.123", "ViewCount": "65", "Score": "1", "Id": "34164076", "Title": "\u00a75.3.5/10 doesn't seem to apply to class-specific versions of the deallocation function. Is that correct?", "CommentCount": "10", "Body": "<p><strong>\u00a75.3.5[expr.delete]/10:</strong> </p>\n<blockquote>\n<p id=\"so_34164076_34164076_0\">If the type is complete and if deallocation function lookup finds both\n  a usual deallocation function with only a pointer parameter and a\n  usual deallocation function with both a pointer parameter and a size\n  parameter, then the selected deallocation function shall be the one\n  with two parameters. Otherwise, the selected deallocation function\n  shall be the function with one parameter.</p>\n</blockquote>\n<p>In the snippet below we try to verify the alluded paragraph for deallocation functions in the global scope and in class scope. <code>g++</code> and <code>VS2015</code> choose the correct deallocation function in the global scope, but they fail to invoke the two parameter deallocation function in class scope. Why is this?</p>\n<p><code>clang</code> seems to fail on both scopes. See <a href=\"http://coliru.stacked-crooked.com/a/073c43a6c9b7ecd9\" rel=\"nofollow\">live example</a>.</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid operator delete(void* p) noexcept\n{\n    free(p);\n    std::cout &lt;&lt; \"operator delete(void*)\" &lt;&lt; '\\n';\n}\n\nvoid operator delete(void* p, size_t s)\n{\n    free(p);\n    std::cout &lt;&lt; \"operator delete(void* , size_t)  size_t = \" &lt;&lt; s &lt;&lt; '\\n';\n}\n\nclass A { int i = 1; };\n\nclass Base {\npublic:\n    void operator delete(void* p) {\n        free(p);\n        std::cout &lt;&lt; \"Base::operator delete(void*)\" &lt;&lt; '\\n';\n    }\n    void operator delete(void* p, size_t s) {\n        free(p);\n        std::cout &lt;&lt; \"Base::operator delete(void*, size_t)  size_t = \" &lt;&lt; s &lt;&lt; '\\n';\n    }\n    virtual ~Base() {};\n};\n\nclass Derived : public Base {\n    int i;\npublic:\n    ~Derived() {};\n};\n\nint main()\n{\n    A *a = new A{};\n    delete a;\n\n    Base* b = new Derived{};\n    delete b;\n}\n</code></pre>\n<p>This is the output obtained by <code>g++</code> and <code>VS2015</code>:</p>\n<pre><code>operator delete(void* , size_t)  size_t = 4\nBase::operator delete(void*)\n</code></pre>\n<p>Output from <code>clang</code>:</p>\n<pre><code>operator delete(void*)\nBase::operator delete(void*)\n</code></pre>\n", "Tags": "<c++><memory-management><language-lawyer><c++14><delete-operator>", "LastActivityDate": "2015-12-08T19:12:02.123", "PostTypeId": "1", "AnswerCount": "0", "OwnerUserId": "1042389"}});