post_cb({"38479774": {"ParentId": "38479375", "CommentCount": "0", "Body": "<p>The class exception does not own any string. When you slice your exception object you get an basic exception object which has no a overrided what() virtual function.</p>\n<p>The magic of the what() function is in the virtual function what() and is in your derived class. You could pass a const char * stored in the static memory to the exception object and it will not be copied. </p>\n<p>Note that the copy of objects when you raise and exception could raise new exceptions and it is not recomended (for example, after a bad_alloc it is possible you can not create a new string object). This is why the exceptions are better catched by reference, not by value.</p>\n", "OwnerUserId": "6578349", "PostTypeId": "2", "Id": "38479774", "Score": "0", "CreationDate": "2016-07-20T11:16:41.513", "LastActivityDate": "2016-07-20T11:16:41.513"}, "38479375": {"CommentCount": "4", "AcceptedAnswerId": "38482856", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2016-07-20T10:58:07.003", "LastActivityDate": "2016-07-20T14:27:37.477", "LastEditDate": "2016-07-20T13:44:33.437", "ViewCount": "428", "FavoriteCount": "2", "Title": "Does std::exception own what?", "Id": "38479375", "Score": "2", "Body": "<p>I'm deriving my own exception, call it <code>MyException</code>, from <code>std::system_error</code> and have overridden <code>what()</code> to calculate and return my message. <code>MyException</code>'s initializer list doesn't call the system_error constructor override that takes a message.</p>\n<p>If I catch a <code>MyException</code> and copy it to a <code>std::exception</code> the result of calling <code>what()</code> on the <code>std::exception</code> is <code>nullptr</code>. This makes sense.</p>\n<p>My question is, if I do use the constructor of system_exception that takes a message when initializing <code>MyException</code>, is it specified that system_error will take a copy of the message and own it and free it?</p>\n<p>I'm assuming this would enable a <code>std::exception</code> copy of <code>MyException</code> to be able to return a valid <code>what()</code>. Although I would take a performance hit in that the 'what' needs calculating every time a new one of <code>MyExceptions</code> is created; I can't lazily calculate it only when what() is first called.</p>\n<p>I'm slightly worried about the ownership of the 'what' string as <code>what()</code> returns a <code>char*</code> and not a <code>const std::string&amp;</code>.</p>\n<p>The code is something like this (I haven't compiled this):</p>\n<pre><code>    class MyException : public std::system_error\n    {\n        std::string what_;\n    public:\n        MyException(int errorValue, const std::error_category&amp; category)\n            : std::system_error(errorValue, category)\n        {}\n\n        char* what() const\n        {\n           what_ = \"MyException: \" + to_string(code().value());\n           return what_.c_str();\n        }\n    };\n\n    int main()\n    {\n        std::exception ex;\n\n        try\n        {\n            throw MyException(4, system_category());\n        }\n        catch( const MyException&amp; e )\n        {\n            ex = e;\n        }\n\n        printf(\"what= %s\", ex.what());\n\n        return 1;\n    }\n</code></pre>\n", "Tags": "<c++><exception><std><c++14><system-error>", "OwnerUserId": "11898", "AnswerCount": "3"}, "38480378": {"ParentId": "38479375", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-07-20T11:43:28.983", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:52.320", "Id": "38480378", "OwnerUserId": "5294025", "Body": "<p>Your question is related to understanding the lifecycle of an exception.  That question is discussed in posts <a href=\"https://stackoverflow.com/questions/12999448/exception-object-lifetime\">here</a> and <a href=\"https://stackoverflow.com/questions/25935372/lifecycle-of-thrown-exceptions-in-c\">here</a> and may be helpful.</p>\n<p>You could guarantee that the lifetime of your exception is extended using a smart pointer.  I'm not sure what the performance implications would be, but you could probably use this to hang on to your own extension of the <code>std::system_error</code> and avoid the copy construction altogether.  (Actually, I don't guarantee the copy construction would be avoided.  Creation of the smart pointer may or may not copy the exception, it seems.  But it would copy your exception, which should do the right thing if you provide the copy constructor that you should provide.)  Your main function would end up looking more like this.</p>\n<pre><code>#include &lt;exception&gt; // std::exception_ptr\n\nint main()\n{\n    std::exception_ptr p;\n\n    try\n    {\n        throw MyException(4, system_category());\n    }\n    catch( const MyException&amp; e )\n    {\n        p = std::current_exception();\n    }\n\n    try\n    {\n        std::rethrow_exception(p);\n    }\n    catch (const std::exception&amp; e)\n    {\n        printf(\"what= %s\", e.what());\n    }\n\n    return 1;\n}\n</code></pre>\n<p>This is basically just a rewrite of the example of using an exception pointer that I read about on cplusplus.com <a href=\"http://www.cplusplus.com/reference/exception/exception_ptr/\" rel=\"nofollow noreferrer\">here</a>, but I've used your exception class rather than a standard exception like <code>std::logic_error</code>.</p>\n<p>As to your original question, it seems that it is difficult to make hard guarantees.  I did find the following statement in the documentation of the assignment operator for exception as applies to C++11.  In C++98 not even this guarantee is provided.</p>\n<blockquote>\n<p id=\"so_38479375_38480378_0\">Every exception within the C++ standard library (including this) has, at least, a copy assignment operator overload that preserves the string representation returned by member what when the dynamic types match.</p>\n</blockquote>\n<p>However, the dynamic type of <code>std::system_error</code> would not match the dynamic type of <code>std::exception</code> in your case, so I don't think it would be guaranteed to work.</p>\n", "LastActivityDate": "2016-07-20T11:54:29.763"}, "bq_ids": {"n4140": {"so_38479375_38482856_3": {"section_id": 6909, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_38479375_38482856_3": {"section_id": 6655, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_38479375_38482856_3": {"section_id": 8407, "quality": 0.9743589743589743, "length": 38}}}, "38482856": {"ParentId": "38479375", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-07-20T13:35:39.750", "Score": "6", "LastEditorUserId": "636019", "LastEditDate": "2016-07-20T14:27:37.477", "Id": "38482856", "OwnerUserId": "636019", "Body": "<blockquote>\n<p id=\"so_38479375_38482856_0\">My question is, if I do use the constructor of system_exception that takes a message when initializing <code>MyException</code>, is it specified that system_error will take a copy of the message and own it and free it?</p>\n</blockquote>\n<p>Yes, this is guaranteed by the standard.</p>\n<p>To start, <code>std::exception</code> does not own <code>what</code> \u2013 <code>std::runtime_error</code> does. <code>std::runtime_error</code>'s constructors are defined thusly ([runtime.error]p2-5):</p>\n<blockquote>\n<pre><code>runtime_error(const string&amp; what_arg);\n</code></pre>\n<p id=\"so_38479375_38482856_1\"><em>Effects:</em> Constructs an object of class <code>runtime_error</code>.<br>\n<em>Postcondition:</em> <code>strcmp(what(), what_arg.c_str()) == 0</code>.</br></p>\n<pre><code>runtime_error(const char* what_arg);\n</code></pre>\n<p id=\"so_38479375_38482856_2\"><em>Effects:</em> Constructs an object of class <code>runtime_error</code>.<br>\n<em>Postcondition:</em> <code>strcmp(what(), what_arg) == 0</code>.</br></p>\n</blockquote>\n<p>So, it must store a <em>copy</em> of <code>what_arg</code> internally, as there are no requirements about the lifetime of the value passed in.</p>\n<p>Next there's [exception]p2:</p>\n<blockquote>\n<p id=\"so_38479375_38482856_3\">Each standard library class <code>T</code> that derives from class <code>exception</code> shall have a publicly accessible copy constructor and a publicly accessible copy assignment operator that do not exit with an exception. These member functions shall meet the following postcondition: If two objects <code>lhs</code> and <code>rhs</code> both have dynamic type <code>T</code> and <code>lhs</code> is a copy of <code>rhs</code>, then <code>strcmp(lhs.what(), rhs.what())</code> shall equal <code>0</code>.</p>\n</blockquote>\n<p>So, there must be a copy constructor, it must never throw, and copies must maintain the same return value for <code>what()</code>. Likewise for the copy-assignment operator.</p>\n<p>Putting this all together, we can surmise that <code>std::runtime_error</code> must retain the value you pass for <code>what_arg</code> internally in a reference counted string (to avoid exceptions from allocations when copying), and the value will persist regardless of copying and/or slicing \u2013 but only down to <code>std::runtime_error</code>, <em><strong>not</strong></em> down to <code>std::exception</code>! (More information about the rationales and requirements regarding <code>what</code>'s storage can be found in this very interesting answer by <a href=\"https://stackoverflow.com/users/576911/\">@HowardHinnant</a>: <a href=\"https://stackoverflow.com/a/28013886/636019\">move constructor for std::runtime_error</a>)</p>\n<p><code>std::system_error</code> inherits from <code>std::runtime_error</code>, so all the same holds true for it and any type deriving from it (as long as the derived type maintains the non-throwing copy constructor invariant).</p>\n<blockquote>\n<p id=\"so_38479375_38482856_4\">I'm assuming this would enable a <code>std::exception</code> copy of <code>MyException</code> to be able to return a valid <code>what()</code>.</p>\n</blockquote>\n<p>No! When you make a <code>std::exception</code> <em>copy</em> of <code>MyException</code>, you are <a href=\"https://stackoverflow.com/a/274634/636019\">slicing</a> the object down to a less derived type than where <code>what</code>'s value is physically stored. If you <em>must</em> make a copy of your exception, the least derived type you can use is <code>std::runtime_error</code>. (You can always safely make a <code>std::exception</code> <em>reference</em> to a <code>MyException</code>, of course.) To put it another way, it is <em>never</em> possible to get a meaningful string from a <code>std::exception</code> <em>object</em>'s <code>what()</code>.</p>\n<hr>\n<p>This code has the behavior you want, portably:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;stdexcept&gt;\n#include &lt;system_error&gt;\n#include &lt;string&gt;\n\nclass MyException : public std::system_error {\npublic:\n    MyException(int errorValue, std::error_category const&amp; category)\n      : std::system_error(\n            errorValue, category,\n            \"MyException: \" + std::to_string(errorValue)\n        )\n    { }\n};\n\nint main() {\n    std::runtime_error ex;\n\n    try {\n        throw MyException(4, system_category());\n    } catch(MyException const&amp; e) {\n        ex = e;\n    }\n\n    std::printf(\"what= %s\", ex.what());\n}\n</code></pre>\n<p>I would say that it's poor form to write an exception constructor that allocates (for obvious reasons), but given that every current standard library implementation that I'm aware of uses <a href=\"https://stackoverflow.com/a/10319672/636019\">short-string optimization</a> for <code>std::basic_string&lt;&gt;</code>, this is extremely unlikely to ever be an issue in practice.</p>\n</hr>", "LastActivityDate": "2016-07-20T14:27:37.477"}});