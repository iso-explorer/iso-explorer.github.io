post_cb({"bq_ids": {"n4140": {"so_38267148_39675770_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5791}, "so_38267148_39675770_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5948}}, "n3337": {"so_38267148_39675770_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5564}, "so_38267148_39675770_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5718}}, "n4659": {"so_38267148_39675770_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7248}, "so_38267148_39675770_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7434}}}, "38267148": {"ViewCount": "194", "Body": "<p>(Initial note: this question is not the same question as whether or not it is safe to delete a void pointer, though that issue has some relation to the problem identified in Update 2. The question here is why a base class obtains a different value from <code>this</code> than is obtained by the derived class for the same object. In cases where the derived object will call a suicide method of the base class, the base class must have a virtual destructor, <em>and</em> the pointer being deleted must be of type pointer-to-base class; storing it in a void* isn't a safe way to delete an object from a base class method.)</p>\n<p>I have a diamond-shaped multiple inheritance where my child class has two parents that both inherit from the same grand-parent, thus:</p>\n<pre><code>class Grand\nclass Mom : public virtual Grand\nclass Dad : public Grand\nclass Child : Mom, Dad\n</code></pre>\n<p>I wrote <code>Mom</code> and <code>Child</code>, but <code>Grand</code> and <code>Dad</code> are library classes I didn't write (that's why <code>Mom</code> inherits virtually from <code>Grand</code>, but <code>Dad</code> doesn't).</p>\n<p><code>Mom</code> implements a pure virtual method declared in <code>Grand</code>. <code>Dad</code> does not. Therefore, <code>Child</code> also implements that same method (because otherwise the compiler would object that <code>Dad</code>'s declaration of that method, inherited by <code>Child</code>, had no implementation). <code>Child</code>'s implementation merely calls <code>Mom</code>'s implementation. Here's the code (I've included code for <code>Dad</code> and <code>Grand</code>, as this is a SSCCE, not the code I'm stuck using that relies on library classes I didn't write):</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Grand\n{\npublic:\n    virtual void WhoAmI(void) = 0;\n};\n\nclass Mom : public virtual Grand\n{\npublic:\n    virtual void WhoAmI()\n    {\n        void* momThis = this;\n    }\n\n    //virtual int getZero() = 0;\n};\n\nclass Dad : public Grand\n{\n};\n\nclass Child : Mom, Dad\n{\npublic:\n    void WhoAmI()\n    {\n        void* childThis = this;\n        return Mom::WhoAmI();\n    }\n\n    int getZero()\n    {\n        return 0;\n    }\n};\n\nint main()\n{\n    Child* c = new Child;\n\n    c-&gt;WhoAmI();\n    return 0;\n}\n</code></pre>\n<p>Note that the <code>getZero</code> method in <code>Child</code> is never called.</p>\n<p>Stepping through execution with the debugger, I see that the address in <code>Child* c</code> is <code>0x00dcdd08</code>. Stepping into <code>Child::WhoAmI</code>, I see that the address in <code>void* childThis</code> is also <code>0x00dcdd08</code>, which is what I expect. Stepping further into <code>Mom::WhoAmI</code>, I see that <code>void* momThis</code> is assigned <code>0x00dcdd0c</code>, which I interpret to be the address of the <code>Mom</code> subobject of my multiply inherited <code>Child</code> object (but I admit I'm a bit out of my depth at this point).</p>\n<p>Okay, the fact that <code>Child</code>'s <code>this</code> and <code>Mom</code>'s <code>this</code> are different doesn't shock me. Here's what does: if I uncomment the declaration of <code>getZero</code> in <code>Mom</code>, and step through all of that again, <code>Mom::this</code> and <code>Child::this</code> are the same!</p>\n<p>How can the addition of <code>virtual int getZero() = 0</code> to the <code>Mom</code> class result in the <code>Mom</code> subobject and the <code>Child</code> object having the same address? I thought maybe the compiler recognized that all of <code>Mom</code>'s methods were virtual and its vtable was the same as <code>Child</code>'s, so they somehow became the \"same\" object, but adding more, and different, methods to each class doesn't change this behavior.</p>\n<p>Can anyone help me understand what governs when <code>this</code> is the same for the parent and child of a multiply inherited child and when it is different?</p>\n<hr>\n<h1>Update</h1>\n<p>I've tried to simplify things to focus as narrowly as I can on the issue of when <code>this</code> has a different value in a parent object than it has in that parent's child object. To do that, I've changed the inheritance to make it a true diamond, with <code>Dad</code> and <code>Mom</code> both inheriting virtually from <code>Grand</code>. I've eliminated all virtual methods and no longer need to specify which parent class's method I am calling. Instead, I have a unique method in each parent class that will let me use the debugger to see what value <code>this</code> has in each parental object. What I see is that <code>this</code> is the same for one parent and the child, but different for the other parent. Moreover, which parent has the different value changes when the order of the parents is changed in the child's class declaration.</p>\n<p>This turns out to have catastrophic consequences if either of the parent objects tries to delete itself. Here's code that, on my machine, runs fine:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Grand\n{\n};\n\nclass Mom : public virtual Grand\n{\npublic:\n    void WhosYourMommy()\n    {\n        void* momIam = this; // momIam == 0x0137dd0c\n    }\n};\n\nclass Dad : public virtual Grand\n{\npublic:\n    void WhosYourDaddy()\n    {\n        void* dadIam = this; // dadIam == 0x0137dd08\n        delete dadIam; // this works\n    }\n};\n\nclass Child : Dad, Mom\n{\npublic:\n    void WhoAmI()\n    {\n        void* childThis = this;\n\n        WhosYourMommy();\n        WhosYourDaddy();\n\n        return;\n    }\n};\n\nint main()\n{\n    Child* c = new Child; // c == 0x0137dd08\n\n    c-&gt;WhoAmI();\n\n    return 0;\n}\n</code></pre>\n<p>However, if I change <code>class Child : Dad, Mom</code> to <code>class Child : Mom, Dad</code>, it crashes at run-time:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Grand\n{\n};\n\nclass Mom : public virtual Grand\n{\npublic:\n    void WhosYourMommy()\n    {\n        void* momIam = this; // momIam == 0x013bdd08\n    }\n};\n\nclass Dad : public virtual Grand\n{\npublic:\n    void WhosYourDaddy()\n    {\n        void* dadIam = this; // dadIam == 0x013bdd0c\n        delete dadIam; // this crashes\n    }\n};\n\nclass Child : Mom, Dad\n{\npublic:\n    void WhoAmI()\n    {\n        void* childThis = this;\n\n        WhosYourMommy();\n        WhosYourDaddy();\n\n        return;\n    }\n};\n\nint main()\n{\n    Child* c = new Child; // c == 0x013bdd08\n\n    c-&gt;WhoAmI();\n\n    return 0;\n}\n</code></pre>\n<p>This is a problem when you have a class that includes methods that can delete objects of that class (a \"suicide method\"), and those methods might be called from derived classes.</p>\n<p>But, I think I have found the solution: any base class that includes a method that might delete instances of itself and that might have those methods called from instances of classes derived from that class must have a virtual destructor.</p>\n<p>Adding one to the code above make the crash go away:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Grand\n{\n};\n\nclass Mom : public virtual Grand\n{\npublic:\n    void WhosYourMommy()\n    {\n        void* momIam = this; // momIam == 0x013bdd08\n    }\n};\n\nclass Dad : public virtual Grand\n{\npublic:\n    virtual ~Dad() {};\n\n    void WhosYourDaddy()\n    {\n        void* dadIam = this; // dadIam == 0x013bdd0c\n        delete dadIam; // this crashes\n    }\n};\n\nclass Child : Mom, Dad\n{\npublic:\n    void WhoAmI()\n    {\n        void* childThis = this;\n\n        WhosYourMommy();\n        WhosYourDaddy();\n\n        return;\n    }\n};\n\nint main()\n{\n    Child* c = new Child; // c == 0x013bdd08\n\n    c-&gt;WhoAmI();\n\n    return 0;\n}\n</code></pre>\n<p>A number of people I've met are aghast at the idea of an object deleting itself, but it is legal and a necessary idiom when implementing COM's IUnknown::Release method. I found <a href=\"https://isocpp.org/wiki/faq/freestore-mgmt#delete-this\" rel=\"nofollow\">good guidelines</a> on how to use <code>delete this</code> safely, and some equally <a href=\"https://isocpp.org/wiki/faq/virtual-functions#virtual-dtors\" rel=\"nofollow\">good guidelines</a> on using virtual destructors to solve this problem.</p>\n<p>I note, however, that unless the person who coded your parent class coded it with a virtual destructor, calling any suicide method of that parent class from an instance of a class derived from that parent is probably going to crash, and do so unpredictably. Perhaps a reason to include virtual destructors, even when you don't think you need one.</p>\n<hr>\n<h1>Update 2</h1>\n<p>Well, the problem comes back if you add a virtual destructor to both <code>Dad</code> <em>and</em> <code>Mom</code>. This code crashes when it attempts to delete <code>Dad</code>'s <code>this</code> pointer, which does not match <code>Child</code>'s <code>this</code> pointer:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Grand\n{\n};\n\nclass Mom : public virtual Grand\n{\npublic:\n    virtual ~Mom() {};\n\n    void WhosYourMommy()\n    {\n        void* momIam = this; // momIam == 0x013bdd08\n    }\n};\n\nclass Dad : public virtual Grand\n{\npublic:\n    virtual ~Dad() {};\n\n    void WhosYourDaddy()\n    {\n        void* dadIam = this; // dadIam == 0x013bdd0c\n        delete dadIam; // this crashes\n    }\n};\n\nclass Child : Mom, Dad\n{\npublic:\n    virtual ~Child() {};\n\n    void WhoAmI()\n    {\n        void* childThis = this;\n\n        WhosYourMommy();\n        WhosYourDaddy();\n\n        return;\n    }\n};\n\nint main()\n{\n    Child* c = new Child; // c == 0x013bdd08\n\n    c-&gt;WhoAmI();\n\n    return 0;\n}\n</code></pre>\n<hr>\n<h1>Update 3</h1>\n<p>Thanks to BeyelerStudios for asking the right question: deleting a <code>void*</code> instead of deleting a <code>Dad*</code> prevented C++ from knowing what it was really deleting and, therefore, stopped it from calling the virtual destructors of the base and derived classes. Replacing <code>delete dadIam</code> with <code>delete this</code> solves that problem, and the code runs fine.</p>\n<p>Although it would be somewhat ridiculous, replacing <code>delete dadIam</code> with <code>delete (Dad*)dadIam</code> also runs fine, and helps illustrate that the type of the pointer operated on by <code>delete</code> makes a difference to what <code>delete</code> does. (Something I should hardly find surprising in a polymorphic language.)</p>\n<p>BeyelerStudios, if you want to post that as an answer, I'll check the box for you.</p>\n<p>Thanks!</p>\n</hr></hr></hr>", "Title": "Why does \"this\" change in parent of class with multiple base classes?", "CreationDate": "2016-07-08T12:49:54.830", "LastActivityDate": "2016-09-24T11:28:25.893", "CommentCount": "15", "LastEditDate": "2016-07-08T17:02:28.927", "PostTypeId": "1", "LastEditorUserId": "1160997", "Id": "38267148", "Score": "5", "OwnerUserId": "1160997", "Tags": "<c++><inheritance><visual-studio-2015><multiple-inheritance>", "AnswerCount": "1"}, "39675770": {"Id": "39675770", "PostTypeId": "2", "Body": "<p>As mentioned by the standard [intro.object]:</p>\n<blockquote>\n<p id=\"so_38267148_39675770_0\">Objects can contain other objects, called\u00a0subobjects. A subobject can be [...] a\u00a0base class subobject [...].</p>\n</blockquote>\n<p>Moreover [expr.prim.this]:</p>\n<blockquote>\n<p id=\"so_38267148_39675770_1\">The keyword\u00a0this\u00a0names a pointer to the object for which a non-static member function is invoked [...].</p>\n</blockquote>\n<p>It goes without saying that two different classes (derived and base) are different objects, thus can have different values for the <code>this</code> pointer.</p>\n<blockquote>\n<p id=\"so_38267148_39675770_2\">Can anyone help me understand what governs when\u00a0this\u00a0is the same for the parent and child of a multiply inherited child and when it is different?</p>\n</blockquote>\n<p>When and why they differ is not ruled by the standard (of course, it's mainly due to the existence of a vtable associated to the object, but please note that vtables are simply a common, convenient way to deal with polymorphism and the standard never mentions them).<br>\nIt usually derives from the chosen/implemented ABI (see <a href=\"https://mentorembedded.github.io/cxx-abi/abi.html\" rel=\"nofollow\">here</a> for further details about a common one, the Itanium C++ ABI).</br></p>\n<p>It follows a minimal, working example to reproduce the case:</p>\n<pre><code>#include&lt;iostream&gt;\n\nstruct B {\n    int i;\n    void f() { std::cout &lt;&lt; this &lt;&lt; std::endl; }\n};\n\nstruct D: B {\n    void f() { std::cout &lt;&lt; this &lt;&lt; std::endl; }\n    virtual void g() {}\n};\n\nint main() {\n    D d;\n    d.f();\n    d.B::f();\n}\n</code></pre>\n<p>An example output is:</p>\n<blockquote>\n<p id=\"so_38267148_39675770_3\">0xbef01ac0<br>\n  0xbef01ac4</br></p>\n</blockquote>\n", "LastEditorUserId": "4987285", "LastActivityDate": "2016-09-24T11:28:25.893", "Score": "0", "CreationDate": "2016-09-24T11:22:59.043", "ParentId": "38267148", "CommentCount": "0", "OwnerUserId": "4987285", "LastEditDate": "2016-09-24T11:28:25.893"}});