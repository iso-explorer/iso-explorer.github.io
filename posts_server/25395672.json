post_cb({"bq_ids": {"n4140": {"so_25395672_25395833_0": {"length": 30, "quality": 0.75, "section_id": 6186}}, "n3337": {"so_25395672_25395833_0": {"length": 24, "quality": 0.6, "section_id": 5947}}, "n4659": {"so_25395672_25395833_0": {"length": 26, "quality": 0.65, "section_id": 7688}}}, "25395672": {"ViewCount": "1496", "Body": "<p>As we all know, the array length in C++ must be determined. Then we can use:</p>\n<pre><code>const int MAX_Length=100;\n</code></pre>\n<p>or:</p>\n<pre><code>#define MAX_LENGTH 100\n</code></pre>\n<p>to determined the length of an array before compilation. But, when I read the book c++ primer by lippman, in chapter 3.5.1 in 5th Edition, it says: the length of an array must be an constant expression. Then the problem comes:</p>\n<pre><code>typedef enum Length{LEN1=100, LEN2, LEN3, LEN4}LEN; \nLEN MAX_Length=LEN2;  //101\nint iArray[LEN2];     //attention\n</code></pre>\n<p>the code compiled successfully in mingw32-g++. But failed in VS2008, and the errors are:</p>\n<pre><code>error C2057: expected constant expression\nerror C2466: cannot allocate an array of constant size 0\nerror C2133: 'iArray' : unknown size\n</code></pre>\n<p>And I think the enum value is constant, so it should be used as an array's length. right?</p>\n<p>I am confused, could you help me? Thank you.</p>\n", "AcceptedAnswerId": "25395833", "Title": "enum type value as the length of a array in C++", "CreationDate": "2014-08-20T02:05:12.313", "Id": "25395672", "CommentCount": "7", "LastEditDate": "2014-08-21T05:48:30.413", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-16T13:28:43.100", "Score": "6", "OwnerUserId": "3828819", "Tags": "<c++><arrays><visual-studio><enums><constant-expression>", "AnswerCount": "1"}, "25395833": {"Id": "25395833", "PostTypeId": "2", "Body": "<p>In both C++11 and C++03 enumerators(<em>unscoped enums in C++11</em>) are integer constant expressions and therefore usable an array bounds. We can see this for C++11 by going to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>5.19</code> <em>[expr.const]</em> which says:</p>\n<blockquote>\n<p id=\"so_25395672_25395833_0\">An integral constant expression is an expression of integral or\n  unscoped enumeration type, implicitly converted to a prvalue, where\n  the converted expression is a core constant expression. [ Note: Such\n  expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field\n  lengths (9.6), as enumerator initializers if the underlying type is\n  not fixed (7.2), as null pointer constants (4.10), and as alignments\n  (7.6.2). \u2014end note ]</p>\n</blockquote>\n<p>and or C++03 we can see this from the draft C++03 standard or the <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow\">closest we can get</a> same section paragraph <em>1</em> which says:</p>\n<blockquote>\n<p id=\"so_25395672_25395833_1\">[...]An integral constant-expression can involve only literals of\n  arithmetic types (2.13, 3.9.1), enumerators, non-volatile const\n  variables or static data members of integral or enumeration types\n  initialized with constant expressions (8.5), non-type template\n  parameters of integral or enumeration types, and sizeof\n  expressions[...]</p>\n</blockquote>\n<p>On rextester this code <a href=\"http://rextester.com/ONPX65320\" rel=\"nofollow\">compiles fine</a> for VC++, so this is no longer an issue in current versions this must have been a bug in 2008 that was eventually fixed. Also tested on <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow\">webcompiler</a> which was last updated December 3rd 2015 so this works on one of the latest releases as well.</p>\n<p>One alternative may be to use a <em>const int</em> for example:</p>\n<pre><code>const int len = LEN2 ;\n</code></pre>\n<p>this will depends on whether Visual Studio 2008 considers enumerators to not be integer constant expressions or whether it is just in the context of array bounds, hopefully it is just the later.</p>\n<p><b>C++98</b></p>\n<p>As far as I can tell this also applies to C++98 as well, both <code>gcc</code> and <code>clang</code> allow this when using <code>-std=c++98</code>, there are no draft C++98 standards available to the public so I can confirm beyond that.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-16T13:28:43.100", "Score": "6", "CreationDate": "2014-08-20T02:25:35.410", "ParentId": "25395672", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2015-12-16T13:28:43.100"}});