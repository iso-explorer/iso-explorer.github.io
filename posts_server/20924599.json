post_cb({"bq_ids": {"n4140": {"so_20924599_20925002_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 7104}}, "n3337": {"so_20924599_20925002_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 6848}}, "n4659": {"so_20924599_20925002_0": {"length": 31, "quality": 0.8378378378378378, "section_id": 8605}}}, "20925002": {"Id": "20925002", "PostTypeId": "2", "Body": "<p>Argument-dependent lookup only searches the associated classes and namespaces of the argument type. A typedef is just a transparent alias, similarly a using-declaration.</p>\n<p>From the draft Standard n3485, [basic.lookup.argdep]/2 about argument-dependent lookup:</p>\n<blockquote>\n<p id=\"so_20924599_20925002_0\">For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument). <strong>Typedef names and using-declarations used to specify the types do not contribute to this set.</strong></p>\n</blockquote>\n<p>[emphasis mine]</p>\n<hr>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\npublic:\n    void f(T, T){};\n};\n\nnamespace ns\n{\n    typedef int TT;\n    void f(int, int){};\n};\n\ntemplate&lt;typename T&gt;\nclass B : public A&lt;T&gt; // note the base class is dependent\n{\npublic:\n    void g()\n    {\n        //f(T(), T()); // it's fine for error here\n        typedef ns::TT TTT;\n        f(TTT(), T()); // why this issued an error?\n        f(ns::TT(), T()); // and this?\n    }\n};\n</code></pre>\n<p>As the base class is dependent, it won't be searched during unqualified lookup. Therefore, <code>f</code> can be found using argument-dependent lookup. You correctly stated that <code>f</code> will be searched for only during the \"second phase\" (at the point of instantiation), as in your invocations, at least one argument is dependent on a template-parameter.</p>\n<p>However, <code>ns</code> is <em>not</em> a dependent name, as well as <code>TT</code> (in <code>ns::TT</code>). Therefore, the namespace and <code>TT</code> must be declared before they're used in the definition of <code>g</code>.</p>\n<p>Whether you write <code>f(ns::TT(), T())</code> or <code>f(T(), T())</code> does not influence the general rule where <code>f</code> is searched during argument-dependent lookup: Only the associated namespaces and classes of the types of the arguments (of <code>T</code> and <code>ns::TT</code>). Both are <code>int</code>s for <code>B&lt;int&gt;::g()</code>, so there are no associated classes and namespaces.</p>\n<p><code>f(TTT(), TTT())</code> changes lookup insofar as <code>f</code> now is lookup up in the first name lookup phase (it's not a dependent name).</p>\n<hr>\n<p>Here's an example of argument-dependent lookup:</p>\n<pre><code>namespace ns\n{\n    struct TT {};\n    void f(TT, TT) {}\n}\n\nint main()\n{\n    ns::TT x;\n    f(x, x);\n}\n</code></pre>\n<p>Now, you can do this as well inside a member function of a class template:</p>\n<pre><code>namespace ns\n{\n    struct TT {};\n    void f(TT, TT) {}\n}\n\ntemplate&lt;typename T&gt;\nstruct B\n{\n    void g()\n    {\n        f(T(), T());\n    }\n};\n\nint main()\n{\n    B&lt;ns::TT&gt; x;\n    x.g();\n}\n</code></pre>\n<p>But, as I said, argument-dependent name lookup doesn't work for fundamental types such as <code>int</code>.</p>\n<p>In the example above, <code>f</code> is again dependent, as at least one of the arguments is dependent on a template-parameter. Therefore, you could write as well:</p>\n<pre><code>template&lt;typename T&gt;\nstruct B\n{\n    void g()\n    {\n        f(T(), T()); // looked up during the second phase,\n                     // from the point of instantiation\n    }\n};\n\nnamespace ns\n{\n    struct TT {};\n    void f(TT, TT) {}\n}\n\nint main()\n{\n    B&lt;ns::TT&gt; x;\n    x.g();\n}\n</code></pre>\n</hr></hr>", "LastActivityDate": "2014-01-04T18:32:59.633", "Score": "3", "CreationDate": "2014-01-04T18:32:59.633", "ParentId": "20924599", "CommentCount": "8", "OwnerUserId": "420683"}, "20924599": {"ViewCount": "164", "Body": "<p>Recently I was studying the exact meaning of the well-known \"two-phase name lookup\" for the names in template classes. Although I have read a lot of articles about this, I still cannot know everything about this. Now I was confusing about the code shown below:</p>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\npublic:\n    void f(T, T){};\n};\n\nnamespace ns\n{\n    typedef int TT;\n    void f(int, int){};\n};\n\ntemplate&lt;typename T&gt;\nclass B : public A&lt;T&gt;\n{\npublic:\n    void g()\n    {\n\n        //f(T(), T()); // it's fine for error here\n        typedef ns::TT TTT;\n        f(TTT(), T()); // why this issued an error?\n        f(ns::TT(), T()); // and this?\n    }\n};\n\n/* I also think it's OK to move ns here */\n// namespace ns\n// {\n//  typedef int TT;\n//  void f(int, int){};\n//};\n\nint main()\n{\n    B&lt;int&gt; b;\n    b.g();\n}\n</code></pre>\n<p>Please notice the second comment. Since \"f\" is a dependent name, its lookup should be delayed until the instantiation in the \"main\" function. And at that time, the compiler should perform an argument dependent name lookup at the scope of the main function. I think now it should discover the function in namespace ns, but it still issued a compile error:</p>\n<pre><code>1.cpp: In instantiation of 'void B&lt;T&gt;::g() [with T = int]':\n1.cpp:30:6:   required from here\n1.cpp:23:15: error: 'f' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]    f(TTT(), T()); //why this issued an error?\n               ^\n1.cpp:23:15: note: declarations in dependent base 'A&lt;int&gt;' are not found by unqualified lookup\n1.cpp:23:15: note: use 'this-&gt;f' instead\n</code></pre>\n<p>Could someone explain this to me? Thanks.</p>\n", "AcceptedAnswerId": "20925002", "Title": "Strange behavior when perform argument dependent name lookup in template", "CreationDate": "2014-01-04T18:00:03.303", "Id": "20924599", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-04T19:05:50.020", "LastEditorUserId": "1162062", "LastActivityDate": "2014-01-04T19:05:50.020", "Score": "5", "OwnerUserId": "1162062", "Tags": "<c++><templates><name-lookup>", "AnswerCount": "1"}});