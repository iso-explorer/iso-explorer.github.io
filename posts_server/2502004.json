post_cb({"2502004": {"CommentCount": "0", "AcceptedAnswerId": "2502041", "PostTypeId": "1", "LastEditorUserId": "2246344", "CreationDate": "2010-03-23T17:09:44.507", "LastActivityDate": "2014-08-14T11:20:07.517", "LastEditDate": "2014-08-14T11:20:07.517", "ViewCount": "613", "FavoriteCount": "1", "Title": "Undefined behavior on deleting char array trought void *", "Id": "2502004", "Score": "6", "Body": "<p>Is it true that the following yields undefined behavior:</p>\n<pre><code>void * something = NULL;\nchar * buffer = new char[10];\n\nsomething = buffer;\nbuffer = NULL;\n\ndelete [] something; // undefined??\n</code></pre>\n<p>Do I first need to cast <code>something</code> to <code>char *</code> ?</p>\n", "Tags": "<c++><memory-management><undefined><delete-operator>", "OwnerUserId": "300139", "AnswerCount": "2"}, "2502067": {"ParentId": "2502004", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes. </p>\n<p>From the Standard (5.3.5 Delete):</p>\n<blockquote>\n<p id=\"so_2502004_2502067_0\">The value of the operand of delete\n  shall be the pointer value which\n  resulted from a previous array\n  new-expression.72) If not, the\n  behavior is undefined. [Note: this means that the syntax of\n  the delete-expression must match the\n  type of the object allocated by new,\n  not the syntax of the new-expression.\n  ]</p>\n<p id=\"so_2502004_2502067_1\">In the first alternative (delete\n  object), if the static type of the\n  operand is different from its dynamic\n  type, the static type shall be a base\n  class of the operand\u2019s dynamic type\n  and the static type shall have a\n  virtual destructor or the behavior is\n  undefined. In the second alternative\n  (delete array) if the dynamic type of\n  the object to be deleted differs from\n  its static type, the behavior is\n  undefined*.</p>\n</blockquote>\n<p>**This implies that an object cannot be deleted using a pointer of type void* because there are no objects of type void.</p>\n", "OwnerUserId": "116622", "LastEditorUserId": "116622", "LastEditDate": "2010-03-23T17:32:13.007", "Id": "2502067", "Score": "5", "CreationDate": "2010-03-23T17:17:51.547", "LastActivityDate": "2010-03-23T17:32:13.007"}, "bq_ids": {"n4140": {"so_2502004_2502067_0": {"section_id": 6106, "quality": 0.875, "length": 21}, "so_2502004_2502067_1": {"section_id": 6107, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_2502004_2502067_0": {"section_id": 5872, "quality": 0.875, "length": 21}, "so_2502004_2502067_1": {"section_id": 5873, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_2502004_2502067_0": {"section_id": 7603, "quality": 0.875, "length": 21}, "so_2502004_2502067_1": {"section_id": 7604, "quality": 0.8974358974358975, "length": 35}}}, "2502041": {"ParentId": "2502004", "CommentCount": "0", "Body": "<p>Yes, strictly when you use <code>delete[]</code> the static type of the pointer that you <code>delete[]</code> must match the type of the array that you originally allocated or you get undefined behaviour.</p>\n<p>Typically, in many implementations, <code>delete[]</code> called on a <code>void*</code> which is actually an array of a type that has no non-trivial destructor works, but it's not guaranteed.</p>\n<pre><code>delete[] buffer\n</code></pre>\n<p>or</p>\n<pre><code>delete[] (char*)something\n</code></pre>\n<p>would both be valid.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "2502041", "Score": "4", "CreationDate": "2010-03-23T17:14:26.193", "LastActivityDate": "2010-03-23T17:14:26.193"}});