post_cb({"43681535": {"ParentId": "43665610", "CommentCount": "2", "CreationDate": "2017-04-28T13:34:48.160", "OwnerUserId": "627587", "PostTypeId": "2", "Id": "43681535", "Score": "6", "Body": "<p>I reduced your test case to this:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nconstexpr auto f = [](auto size) {\n  return [=](){\n    constexpr auto s = size();\n    return 1;\n  };\n};\n\nstatic_assert(f(std::integral_constant&lt;int, 100&gt;{})(), \"\");\n\nint main() { }\n</code></pre>\n<p>As said in the comments above, this happens because <code>size</code> is not a constant expression from within the function body. This is not specific to Hana. As a workaround, you can use</p>\n<pre><code>constexpr auto f = [](auto size) {\n  return [=](){\n    constexpr auto s = decltype(size)::value;\n    return 1;\n  };\n};\n</code></pre>\n<p>or anything similar.</p>\n", "LastActivityDate": "2017-04-28T13:34:48.160"}, "43665610": {"CommentCount": "4", "ViewCount": "373", "PostTypeId": "1", "LastEditorUserId": "800347", "CreationDate": "2017-04-27T18:38:54.357", "LastActivityDate": "2017-05-02T18:56:54.600", "LastEditDate": "2017-04-27T22:09:04.357", "AcceptedAnswerId": "43688785", "FavoriteCount": "1", "Title": "Why is this nested lambda not considered constexpr?", "Id": "43665610", "Score": "7", "Body": "<p>I'm trying to create a curried interface using nested constexpr lambdas, but the compiler does not consider it to be a constant expression.</p>\n<pre><code>namespace hana = boost::hana;\nusing namespace hana::literals;\n\nstruct C1 {};\n\ntemplate &lt; typename T,\n           std::size_t size &gt;\nstruct Array {};\n\nconstexpr auto array_ = [] (auto size) {\n      return [=] (auto type) {\n        return hana::type_c&lt;Array&lt;typename decltype(type)::type, size()&gt;&gt;;\n      };\n    };\n\nint main() {\n\n  constexpr auto c1 = hana::type_c&lt;C1&gt;;\n  constexpr auto test = hana::type_c&lt;Array&lt;typename decltype(c1)::type, hana::size_c&lt;100&gt;()&gt;&gt;;\n  constexpr auto test2 = array_(hana::size_c&lt;100&gt;)(c1);\n}\n</code></pre>\n<p>I post a question earlier because I found a different minimal example, but it wasn't enough.</p>\n<p><strong>Error:</strong></p>\n<pre><code>test2.cpp: In instantiation of \u2018&lt;lambda(auto:1)&gt;::&lt;lambda(auto:2)&gt; [with auto:2 = boost::hana::type_impl&lt;C1&gt;::_; auto:1 = boost::hana::integral_constant&lt;long unsigned int, 100&gt;]\u2019:\ntest2.cpp:31:54:   required from here\ntest2.cpp:20:16: error: \u2018__closure\u2019 is not a constant expression\n         return hana::type_c&lt;Array&lt;typename decltype(type)::type, size()&gt;&gt;;\n                ^~~~\ntest2.cpp:20:16: note: in template argument for type \u2018long unsigned int\u2019 \ntest2.cpp: In function \u2018int main()\u2019:\ntest2.cpp:31:18: error: \u2018constexpr const void test2\u2019 has incomplete type\n   constexpr auto test2 = array_(hana::size_c&lt;100&gt;)(c1);\n</code></pre>\n<p><code>__closure is not a constant expression</code> : if someone could explain me this error that would be a great help. I ran into that error before but can't remember why.</p>\n", "Tags": "<c++><lambda><metaprogramming><c++1z><boost-hana>", "OwnerUserId": "5890258", "AnswerCount": "2"}, "43688785": {"ParentId": "43665610", "LastEditDate": "2017-05-02T18:56:54.600", "CommentCount": "3", "CreationDate": "2017-04-28T20:58:09.843", "Score": "5", "LastEditorUserId": "1639256", "PostTypeId": "2", "Id": "43688785", "OwnerUserId": "1639256", "Body": "<p>The problem is you are trying to odr-use one of a lambda's captured variables in a template non-type argument.</p>\n<pre><code>  return hana::type_c&lt;Array&lt;typename decltype(type)::type, size()&gt;&gt;;\n//                                                         ^~~~\n</code></pre>\n<p>A template non-type argument must be a constant expression. Inside a lambda, you can't odr-use a captured variable in a constant expression. Whether or not the lambda is <code>constexpr</code> is irrelevant.</p>\n<p>But you can odr-use ordinary variables in constant expressions, even if they are not <code>constexpr</code> variables. For example, this is legal:</p>\n<pre><code>std::integral_constant&lt;int, 100&gt; i; // i is not constexpr\nstd::array&lt;int, i()&gt; a; // using i in a constant expression\n</code></pre>\n<p>So why can't we odr-use captured variables in constant expressions? I don't know the motivation for this rule, but here it is in the standard:</p>\n<blockquote>\n<p id=\"so_43665610_43688785_0\">[expr.const]</p>\n<p id=\"so_43665610_43688785_1\">(\u00b62) A <em>conditional-expression</em> is a <em>core constant expression</em> unless...\n  (\u00b62.11) in a <em>lambda-expression</em>, a reference to <code>this</code> or to a variable with automatic storage duration defined outside that <em>lambda-expression</em>, where the reference would be an odr-use.</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1613\" rel=\"nofollow noreferrer\">CWG1613</a> may hold some clue.</p>\n<p>If we were to rewrite the inner lambda as a named class, we would have a different but related problem:</p>\n<pre><code>template &lt;typename T&gt;\nstruct Closure {\n  T size;\n  constexpr Closure(T size_) : size(size_) {}\n\n  template &lt;typename U&gt;\n  constexpr auto operator()(U type) const {\n    return hana::type_c&lt;Array&lt;typename decltype(type)::type, size()&gt;&gt;;\n  }\n};\nconstexpr auto array_ = [] (auto size) {\n  return Closure { size };\n};\n</code></pre>\n<p>Now the error would be the implicit use of the <code>this</code> pointer in a template non-type argument.</p>\n<pre><code>  return hana::type_c&lt;Array&lt;typename decltype(type)::type, size()&gt;&gt;;\n//                                                         ^~~~~\n</code></pre>\n<p>I declared <code>Closure::operator()()</code> as a <code>constexpr</code> function for consistency, but that is immaterial. The <code>this</code> pointer is forbidden to be used in a constant expression ([expr.const] \u00b62.1). Functions declared <code>constexpr</code> do not get special dispensation to relax the rules for the constant expressions that may appear within them.</p>\n<p>Now the original error makes a little bit more sense, because captured variables are transformed into data members of the lambda's closure type, so using captured variables is a little bit like indirecting through the lambda's own \"<code>this</code> pointer\".</p>\n<p>This is the workaround that introduces the least alteration to the code:</p>\n<pre><code>constexpr auto array_ = [] (auto size) {\n  return [=] (auto type) {\n    const auto size_ = size;\n    return hana::type_c&lt;Array&lt;typename decltype(type)::type, size_()&gt;&gt;;\n  };\n};\n</code></pre>\n<p>Now we are using the captured variable outside of a constant expression, to initialize an ordinary variable which we can then use in the template non-type argument.</p>\n<p>This answer has been edited a few times, so the comments below may reference previous revisions.</p>\n", "LastActivityDate": "2017-05-02T18:56:54.600"}, "bq_ids": {"n4140": {"so_43665610_43688785_1": {"section_id": 6185, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_43665610_43688785_1": {"section_id": 7687, "quality": 0.8333333333333334, "length": 15}}}});