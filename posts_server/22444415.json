post_cb({"22444415": {"CommentCount": "0", "ViewCount": "123", "PostTypeId": "1", "OwnerDisplayName": "user1994036", "LastEditorDisplayName": "user1994036", "CreationDate": "2014-03-16T23:16:27.537", "LastActivityDate": "2014-03-18T20:27:40.443", "LastEditDate": "2014-03-16T23:35:26.817", "AcceptedAnswerId": "22490313", "FavoriteCount": "3", "Title": "Since there are two ways to define a conversion in C++ how do they interact when there are two possibilities for the same conversion?", "Id": "22444415", "Score": "7", "Body": "<p>I am just looking for clarification on how C++ works, this isn't really about solving a particular problem in my code.</p>\n<p>In C++ you can say that type A should implicitly convert to type B in two different ways.</p>\n<p>If you are the author of A you can add something like this to A:</p>\n<pre><code>operator B() {\n   // code\n}\n</code></pre>\n<p>If you are the author of B you can add something like this to B:</p>\n<pre><code>B(const A &amp;a) {\n    // code\n}\n</code></pre>\n<p>Either one of these, if I understand correctly, will allow A to implicitly convert to B.  So if both are defined which one is used?  Is that even allowed?</p>\n<p>NOTE: I understand that you should probably never be in a situation where you do this.  You would either make the constructor explicit or even more likely only have one of the two.  I am just wondering what the C++ specification says and I don't know how to look that up.</p>\n", "Tags": "<c++><implicit-conversion><conversion-operator>", "AnswerCount": "2"}, "22444656": {"ParentId": "22444415", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_22444415_22444656_0\"><code>[C++11: 12.3/2]:</code> User-defined conversions are applied only where they are unambiguous. <em>[..]</em></p>\n</blockquote>\n<p>12.3 goes on to list the two kinds you identified.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "22444656", "Score": "1", "CreationDate": "2014-03-16T23:41:51.193", "LastActivityDate": "2014-03-16T23:41:51.193"}, "bq_ids": {"n4140": {"so_22444415_22490313_0": {"section_id": 621, "quality": 0.9090909090909091, "length": 20}, "so_22444415_22444656_0": {"section_id": 384, "quality": 0.75, "length": 6}}, "n3337": {"so_22444415_22490313_0": {"section_id": 611, "quality": 0.9090909090909091, "length": 20}, "so_22444415_22444656_0": {"section_id": 375, "quality": 0.75, "length": 6}}, "n4659": {"so_22444415_22490313_0": {"section_id": 647, "quality": 0.9090909090909091, "length": 20}, "so_22444415_22444656_0": {"section_id": 401, "quality": 0.75, "length": 6}}}, "22490313": {"ParentId": "22444415", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Unfortunately, the answer to this question is probably more complex than what you were looking for. It is true that the compiler will reject ambiguous conversions as Lightness Races in Orbit points out, but are the conversions ambiguous? Let's examine a few cases. All references are to the C++11 standard.</p>\n<h1>Explicit conversion</h1>\n<p>This doesn't address your question directly because you asked about implicit conversion, but since Lightness Races in Orbit gave an example of explicit conversion, I'll go over it anyway.</p>\n<p>Explicit conversion is performed from <code>A</code> to <code>B</code> when:</p>\n<ul>\n<li>you use the syntax <code>(B)a</code>, where <code>a</code> is of type <code>A</code>, which in this case will be equivalent to <code>static_cast&lt;B&gt;(a)</code> (C++11 standard, \u00a75.4/4).</li>\n<li>you use a static cast, which in this case will create a temporary which is initialized in the same way that the declaration <code>B t(a);</code> initializes <code>t</code>; (\u00a75.2.9/4)</li>\n<li>you use the syntax <code>B(a)</code>, which is equivalent to <code>(B)a</code> and hence also does the same thing as the initialization in the declaration <code>B t(a);</code> (\u00a75.2.3/1)</li>\n</ul>\n<p>In each case, therefore, direct initialization is performed of a prvalue of type <code>B</code> using a value of type <code>A</code> as the argument. \u00a78.5/16 specifies that <strong>only constructors are considered</strong>, so <code>B::B(const A&amp;)</code> will be called. (For slightly more detail, see my answer here: <a href=\"https://stackoverflow.com/a/22444974/481267\">https://stackoverflow.com/a/22444974/481267</a>)</p>\n<h1>Copy-initialization</h1>\n<p>In the copy-initialization</p>\n<pre><code>B b = a;\n</code></pre>\n<p>the value <code>a</code> of type <code>A</code> is first converted to a temporary of type <code>B</code> using a user-defined conversion sequence, which is an implicit conversion sequence. Then this temporary is used to direct-initialize <code>b</code>.</p>\n<p>Because this is copy-initialization of a class type by an object of a different class type, <em>both</em> the converting constructor <code>B::B(const A&amp;)</code> and the conversion function <code>A::operator B()</code> are candidates for the conversion (\u00a713.3.1.4). The latter is called because it <em>wins overload resolution</em>. Note that if <code>B::B</code> had argument <code>A&amp;</code> rather than <code>const A&amp;</code>, the overload would be ambiguous and the program wouldn't compile. For details and references to the Standard see this answer: <a href=\"https://stackoverflow.com/a/1384044/481267\">https://stackoverflow.com/a/1384044/481267</a></p>\n<h1>Copy-list-initialization</h1>\n<p>The copy-list-initialization</p>\n<pre><code>B b = {a};\n</code></pre>\n<p>only considers constructors of <code>B</code> (\u00a78.5.4/3), and not conversion functions of <code>A</code>, so <code>B::B(const A&amp;)</code> will be called, just like in explicit conversion.</p>\n<h1>Implicit conversion of function arguments</h1>\n<p>If we have</p>\n<pre><code>void f(B b);\nA a;\nf(a);\n</code></pre>\n<p>then the compiler has to select the best implicit conversion sequence to convert <code>a</code> to type <code>B</code> in order to pass it to <code>f</code>. For this purpose, user-defined conversion sequences are considered which consist of a standard conversion followed by a user-defined conversion followed by another standard conversion (\u00a713.3.3.1.2/1). A user-defined conversion can occur through either the converting constructor <code>B::B(const A&amp;)</code> or through the conversion function <code>A::operator B()</code>.</p>\n<p>Here's where it gets tricky. There is some confusing wording in the standard:</p>\n<blockquote>\n<p id=\"so_22444415_22490313_0\">Since an implicit conversion sequence is an initialization, the special rules for initialization\n  by user-defined conversion apply when selecting the best user-defined conversion for a user-defined conversion\n       sequence (see 13.3.3 and 13.3.3.1).</p>\n</blockquote>\n<p>(\u00a713.3.3.1.2/2)</p>\n<p>To make a long story short, this means that the user-defined conversion in the user-defined conversion sequence from <code>A</code> to <code>B</code> is itself subject to overload resolution; <code>A::operator B()</code> wins over <code>B::B(const A&amp;)</code> because the former has less cv-qualification (as in the copy-initialization case) and ambiguity would result if we had had <code>B::B(A&amp;)</code> rather than <code>B::B(const A&amp;)</code>. Note that this cannot result in the infinite recursion of overload resolution, since user-defined conversions are not allowed for converting the argument to the parameter type of the user-defined conversion.</p>\n<h1>Return statement</h1>\n<p>In</p>\n<pre><code>B foo() {\n    return A();\n}\n</code></pre>\n<p>the expression <code>A()</code> is implicitly converted to type <code>B</code> (\u00a76.6.3/2) so the same rules apply as in implicit conversion of function arguments; <code>A::operator B()</code> will be called, and the overload would be ambiguous if we had <code>B::B(A&amp;)</code>. However, if it were instead</p>\n<pre><code>return {A()};\n</code></pre>\n<p>then this would be a copy-list-initialization instead (\u00a76.6.3/2 again); <code>B::B(const A&amp;)</code> will be called.</p>\n<p><strong>Note:</strong> user-defined conversions are not tried when handling exceptions; a <code>catch(B)</code> block won't handle a <code>throw A();</code>.</p>\n", "OwnerUserId": "481267", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:12:57.743", "Id": "22490313", "Score": "1", "CreationDate": "2014-03-18T20:27:40.443", "LastActivityDate": "2014-03-18T20:27:40.443"}});