post_cb({"1136844": {"CommentCount": "2", "ViewCount": "548", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2009-07-16T11:00:09.643", "LastActivityDate": "2017-08-20T01:11:56.807", "AnswerCount": "6", "LastEditDate": "2017-08-20T01:11:56.807", "FavoriteCount": "1", "Title": "C++: memory leaks", "Id": "1136844", "Score": "4", "Body": "<p>The question: At what value of variable <strong>n</strong> the following code will cause memory leaks?</p>\n<p>That's the code:</p>\n<hr>\n<pre><code>int* Bar(int n)\n{\n  if (n == 1)\n    throw \"exception\";\n  return new int[n];\n}\n\nvoid Foo(int n)\n{\n  int *a = Bar(n);\n  if (n &lt;= 2)\n    return;\n  delete[] a;\n}\n</code></pre>\n<ul>\n<li>It's clear that if n is 2 there\nwill be memory leaks. </li>\n<li>If n is 0 there    possibly will<br>\nbe memory leaks (acording    to\n<a href=\"https://stackoverflow.com/questions/1087042/c-new-int0-will-it-allocate-memory\">C++ new int[0] -- will it allocate memory?</a>)</br></li>\n</ul>\n<blockquote>\n<p id=\"so_1136844_1136844_0\">From 5.3.4/7</p>\n<p id=\"so_1136844_1136844_1\">When the value of the expression in a\n  direct-new-declarator is zero, the\n  allocation function is called to\n  allocate an array with no elements.</p>\n<p id=\"so_1136844_1136844_2\">From 3.7.3.1/2</p>\n<p id=\"so_1136844_1136844_3\">The effect of dereferencing a pointer\n  returned as a request for zero size is\n  undefined.</p>\n<p id=\"so_1136844_1136844_4\">Also</p>\n<p id=\"so_1136844_1136844_5\">Even if the size of the space\n  requested [by new] is zero, the\n  request can fail.</p>\n<p id=\"so_1136844_1136844_6\">That means you can do it, but you can\n  not legally (in a well defined manner\n  across all platforms) dereference the\n  memory that you get - you can only\n  pass it to array delete - and you\n  should delete it.</p>\n<p id=\"so_1136844_1136844_7\">Here is an interesting foot-note (i.e\n  not a normative part of the standard,\n  but included for expository puprposes)\n  attached to the sentence from\n  3.7.3.1/2</p>\n<p id=\"so_1136844_1136844_8\">[32. The intent is to have operator\n  new() implementable by calling\n  malloc() or calloc(), so the rules are\n  substantially the same. C++ differs\n  from C in requiring a zero request to\n  return a non-null pointer.]</p>\n</blockquote>\n<ul>\n<li>And if n is 1 we get:</li>\n</ul>\n<p>int *a = Bar(1) and Bar(1) throws exception. Will it be the exception in constructor of variable a? And will it cause memory leaks?</p>\n</hr>", "Tags": "<c++><memory-leaks><new-operator>", "OwnerDisplayName": "skabanov"}, "1136926": {"ParentId": "1136844", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre>\nIf n &lt; 0            you'll more likely get exception std::bad_alloc (because of n will be converted to size_t which is unsigned) - no memory leak.\nIf n == 1           you'll get exception (invoked by `throw \"exception\"`) - no memory leak.\nIf n == 0 || n == 2 you'll never call delete - memory leak.\nIf n &gt; 2            you'll call delete - no memory leak.\n</pre>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-07-16T11:32:46.567", "Id": "1136926", "Score": "2", "CreationDate": "2009-07-16T11:18:38.080", "LastActivityDate": "2009-07-16T11:32:46.567"}, "38956140": {"ParentId": "1136844", "CommentCount": "0", "Body": "<p>Yes, with <code>0</code> and <code>2</code> you will get memory leaks.</p>\n<hr>\n<p>Also this is very bad practice to manage dynamic memory like that.\nOn C++ it's much natural/better way to create a class which will manage memory (for example, in constructor it allocates some memory and in destructor it releases it). This would be more leaks-free and safer</p>\n</hr>", "OwnerUserId": "6714653", "PostTypeId": "2", "Id": "38956140", "Score": "0", "CreationDate": "2016-08-15T13:37:02.253", "LastActivityDate": "2016-08-15T13:37:02.253"}, "1136901": {"ParentId": "1136844", "CommentCount": "0", "Body": "<p>Your assessment is mostly correct - n = 2 will cause a memory leak, n = 0 will theoretically result in a memory leak - n = 1 will throw an exception (so new int is never executed), so no memory leak. </p>\n<p>Any value for n &gt; 2 will NOT result in a memory leak.   </p>\n<p>Now if n &lt; 0 - you have undefined behavior - and you may get a memory leak (that is a negative int can be converted to a large positive unsigned value - and bad things may happen)</p>\n", "OwnerUserId": "51103", "PostTypeId": "2", "Id": "1136901", "Score": "0", "CreationDate": "2009-07-16T11:14:24.547", "LastActivityDate": "2009-07-16T11:14:24.547"}, "1136871": {"ParentId": "1136844", "CommentCount": "2", "Body": "<p>No, If i understand your question correctly, the bar function will throw the exception and the Foo function never actually catches it which means that it will pass on out of that function as well.  But no it shouldn't cause memory leaks because you throw before the allocation is made.</p>\n", "OwnerUserId": "131140", "PostTypeId": "2", "Id": "1136871", "Score": "0", "CreationDate": "2009-07-16T11:06:16.403", "LastActivityDate": "2009-07-16T11:06:16.403"}, "1136865": {"ParentId": "1136844", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It can cause them if a == 0 or a == 2.</p>\n<p>If a == 1 an exception is thrown and no memory allocated. If a &gt; 2 memory is both allocated and freed.</p>\n<p>If a == 0 memory must be allocated since new is not allowed to return null pointers. You must free allocated memory with delete[].</p>\n<p>If a == 2 memory is allocated and function returns. That's an obvious leak.</p>\n", "OwnerUserId": "57428", "LastEditorUserId": "57428", "LastEditDate": "2009-07-16T11:11:06.970", "Id": "1136865", "Score": "7", "CreationDate": "2009-07-16T11:04:25.067", "LastActivityDate": "2009-07-16T11:11:06.970"}, "1136906": {"ParentId": "1136844", "CommentCount": "0", "Body": "<p>Since there are no catcher to the exception thrown, it will proceed further and return.\nBut since we declared as a integer pointer, if you send the 'n' as Zero, a default pointer will be created. You can check the size of the pointer as well. But it will not result in any memory leak. The reason behind, when you do a return, since it is a single integer pointer and being a local variable, the  memory occupied will be freed by default.\nSo, there will be no memory leak that will happen in the case mentioned by you.</p>\n", "OwnerUserId": "137310", "PostTypeId": "2", "Id": "1136906", "Score": "0", "CreationDate": "2009-07-16T11:14:50.350", "LastActivityDate": "2009-07-16T11:14:50.350"}, "bq_ids": {"n4140": {"so_1136844_1136844_3": {"section_id": 7177, "quality": 0.7777777777777778, "length": 7}, "so_1136844_1136844_1": {"section_id": 6088, "quality": 0.7272727272727273, "length": 8}, "so_1136844_1136844_8": {"section_id": 7177, "quality": 0.8421052631578947, "length": 16}, "so_1136844_1136844_5": {"section_id": 7177, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_1136844_1136844_3": {"section_id": 6921, "quality": 0.8888888888888888, "length": 8}, "so_1136844_1136844_1": {"section_id": 5856, "quality": 0.9090909090909091, "length": 10}, "so_1136844_1136844_8": {"section_id": 6921, "quality": 0.8421052631578947, "length": 16}, "so_1136844_1136844_5": {"section_id": 6921, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_1136844_1136844_3": {"section_id": 8685, "quality": 0.7777777777777778, "length": 7}, "so_1136844_1136844_1": {"section_id": 7584, "quality": 0.7272727272727273, "length": 8}, "so_1136844_1136844_8": {"section_id": 8685, "quality": 0.8421052631578947, "length": 16}, "so_1136844_1136844_5": {"section_id": 8685, "quality": 0.8888888888888888, "length": 8}}}});