post_cb({"15157689": {"ParentId": "15157591", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-03-01T12:22:12.177", "Score": "49", "LastEditorUserId": "150634", "LastEditDate": "2013-03-27T12:26:47.670", "Id": "15157689", "OwnerUserId": "150634", "Body": "<p>The proposal doesn't introduce a garbage collector - it just allows for it in certain situations <em>if the implementation chooses</em>. The standard will just describe these situations as causing undefined behaviour. In doing this, it relaxes the requirements of the implementation, giving the minimal leeway for a garbage collector.</p>\n<p>The simple example given in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm\" rel=\"noreferrer\">the proposal</a> considers when you take a pointer to a dynamically allocated object, XOR it with another value, thereby hiding the pointer value, and then recover the original pointer value to access the object through it. Before C++11, this would be perfectly fine and it would still be valid to use. However, now such an operation may be (see next paragraph) considered undefined behaviour, which means that an implementation <em>may</em> do garbage collection on the object that was pointed to.</p>\n<p>The standard states that an implementation can either have <em>relaxed pointer safety</em>, in which case the behaviour is as it was before, or <em>strict pointer safety</em>, which allows for the introduction of a garbage collector.</p>\n<blockquote>\n<p id=\"so_15157591_15157689_0\">An implementation may have <em>relaxed pointer safety</em>, in which case the validity of a pointer value does not depend on whether it is a safely-derived pointer value. Alternatively, an implementation may have <em>strict pointer safety</em>, in which case a pointer value that is not a safely-derived pointer value is an invalid pointer value unless the referenced complete object is of dynamic storage duration and has previously been declared reachable (20.6.4). [...] It is implementation defined whether an implementation\n  has relaxed or strict pointer safety.</p>\n</blockquote>\n<p>A pointer value is a safely-derived pointer value if it points at a dynamically allocated object and hasn't had any funny business happen to it (defined more specifically in \u00a73.7.4.3).</p>\n<p>If your implementation has strict pointer safety yet you still want to do said funny business to a pointer without introducing undefined behaviour, you can declare a pointer <code>p</code> as being reachable like so:</p>\n<pre><code>declare_reachable(p);\n</code></pre>\n<p>This function is defined in the <code>&lt;memory&gt;</code> header, along with related functions such as <code>undeclare_reachable</code>, <code>declare_no_pointers</code>, and <code>undeclare_no_pointers</code>. You can also determine the strictness of your implementation using <code>get_pointer_safety</code>.</p>\n", "LastActivityDate": "2013-03-27T12:26:47.670"}, "15157591": {"CommentCount": "13", "AcceptedAnswerId": "15157689", "CreationDate": "2013-03-01T12:17:17.657", "LastActivityDate": "2013-03-27T12:26:47.670", "PostTypeId": "1", "ViewCount": "7481", "FavoriteCount": "9", "Title": "C++11 Garbage Collector - Why and Hows", "Id": "15157591", "Score": "33", "Body": "<p>In <a href=\"http://gcc.gnu.org/projects/cxx0x.html\" rel=\"noreferrer\">C++11's language feature list</a> there is: </p>\n<blockquote>\n<p id=\"so_15157591_15157591_0\">Minimal support for garbage collection and reachability-based leak\n  detection</p>\n</blockquote>\n<p>(but it seems not implemented in either GCC and Clang.)</p>\n<p>Why the standard committee introduced this garbage collection C++ langauge feature?</p>\n<p>Does C++ really need a GC? Isn't RAII such an excellent pattern (that can be used uniformly for both memory and non-memory resources, like sockets, files, textures...)?</p>\n<p>Will a GC break the uniformity of C++ code pattern that uses RAII?</p>\n<p>Some people say that a GC can come in handy to break circular dependencies, but isn't it just OK to use smart pointers like <code>weak_ptr</code> for this purpose?</p>\n<p>And what happens in case of exceptions thrown? How will the stack unwind semantics be modified to take a GC into consideration?</p>\n<p>And will a C#-like <code>IDisposable</code> pattern be introduced as well?</p>\n<p>Moreover, assuming that a GC is introduced in C++, will the pointer syntax be different? e.g. Will we have some hat-like \"pointers\" <code>^</code> like in C++/CLI or C++/CX extensions? There should be a way to differentiate from ordinary raw pointers vs. \"managed\" pointers, right?</p>\n", "Tags": "<c++><c++11><garbage-collection>", "OwnerUserId": "1629821", "AnswerCount": "2"}, "15157770": {"ParentId": "15157591", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-03-01T12:26:24.397", "Score": "18", "LastEditorUserId": "252000", "LastEditDate": "2013-03-01T13:42:35.120", "Id": "15157770", "OwnerUserId": "657700", "Body": "<p>From Bjarne Stroustrup:</p>\n<blockquote>\n<p id=\"so_15157591_15157770_0\">Actually, what I said was something like \"When (not if) automatic garbage collection becomes part of C++, it will be optional\".</p>\n</blockquote>\n<p><a href=\"http://www.stroustrup.com/slashdot_interview.html\">http://www.stroustrup.com/slashdot_interview.html</a></p>\n", "LastActivityDate": "2013-03-01T13:42:35.120"}, "bq_ids": {"n4140": {"so_15157591_15157689_0": {"section_id": 7187, "quality": 0.8823529411764706, "length": 45}, "so_15157591_15157591_0": {"section_id": 4273, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_15157591_15157689_0": {"section_id": 6931, "quality": 0.9411764705882353, "length": 48}, "so_15157591_15157591_0": {"section_id": 4114, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_15157591_15157689_0": {"section_id": 8695, "quality": 0.8627450980392157, "length": 44}, "so_15157591_15157591_0": {"section_id": 5529, "quality": 0.5714285714285714, "length": 4}}}});