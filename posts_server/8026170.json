post_cb({"8026170": {"CommentCount": "0", "CreationDate": "2011-11-06T09:30:07.703", "PostTypeId": "1", "AcceptedAnswerId": "8026489", "LastEditorUserId": "-1", "LastActivityDate": "2011-11-06T10:41:14.963", "LastEditDate": "2017-05-23T12:17:33.783", "ViewCount": "2044", "FavoriteCount": "4", "Title": "Lifetime of lambda objects in relation to function pointer conversion", "Id": "8026170", "Score": "27", "Body": "<p>Following <a href=\"https://stackoverflow.com/questions/4726768/returning-functions-in-c/4730655#4730655\">this answer</a> I'm now wondering what the rules are for the lifetime of lambdas and how the relate to the lifetime of function pointers which are created by automatic conversion. There are several questions about the lifetime of lambdas (e.g. <a href=\"https://stackoverflow.com/questions/7941562/what-is-the-lifetime-of-a-c-lambda-expression\">here</a> and <a href=\"https://stackoverflow.com/questions/5207467/what-is-lifetime-of-lambda-derived-implicit-functors-in-c\">here</a>), in which case the answers are \"they behave exactly like you wrote the full functor object yourself\", however neither address the conversion to function pointer which could quite sensibly be a special case.</p>\n<p>I put together this small working example that illustrates my concern:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef int (*func_t)(int);\n\n// first case\nfunc_t retFun1() {\n  static auto lambda = [](int) { return 1; };\n  // automatically converted to func_t\n  return lambda;\n}\n\n// second case\nfunc_t retFun2() {\n  // no static\n  auto lambda = [](int) { return 2; };\n  // automatically converted to func_t and \n  // the local variable lambda reaches the end of its life\n  return lambda;\n}\n\nint main() {\n  const int a = retFun1()(0);\n  const int b = retFun2()(0);\n  std::cout &lt;&lt; a &lt;&lt; \",\" &lt;&lt; b &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>Is this well defined for both cases? Or only for <code>retFun1()</code>? The question is: \"is the function that the function pointer points required to be calling the functor object itself, or reimplementing the body in a separate function?\" Either one would make sense, but the fact that the conversion to function pointer specifically requires a capture-less lambda suggests that it may actually be the latter.</p>\n<hr>\n<p>Put another way - I can see at least two sensible ways a compiler might want to implement such lambdas. One possible, legal implementation might be for a compiler to synthesize code like:</p>\n<pre><code>func_t retFun3() {\n  struct __voodoo_magic_lambda_implementation {\n    int operator()(int) const {\n      return 3;\n    }\n    static int plainfunction(int) {\n      return 3;\n    }\n    operator func_t() const {\n      return plainfunction;\n    }\n  } lambda;\n  return lambda;\n}\n</code></pre>\n<p>in which case both the <code>static</code> and non-<code>static</code> variants of <code>retFun</code> would be fine. If however it's also legal for a compiler to implement the lambda like:</p>\n<pre><code>static int __voodoo_impl_function(int x);\nstatic struct __voodoo_maigc_impl2 {\n  int operator()(int) const {\n    return 4;\n  }\n  operator func_t() const {\n    return __voodoo_impl_function;\n  }\n} *__magic_functor_ptr;\nstatic int __voodoo_impl_function(int x) {\n  return (*__magic_functor_ptr)(x);\n}\n\nfunc_t retFun4() {\n  __voodoo_maigc_impl2 lambda;\n  // non-static, local lifetime\n  __magic_functor_ptr = &amp;lambda; //Or do the equivalent of this in the ctor\n  return lambda;\n}\n</code></pre>\n<p>then <code>retFun2()</code> is undefined behaviour.</p>\n</hr>", "Tags": "<c++><c++11><lambda><object-lifetime>", "OwnerUserId": "168175", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8026170_8026489_0": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_8026170_8026489_0": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_8026170_8026489_0": {"section_id": 7456, "quality": 0.85, "length": 34}}}, "8026489": {"ParentId": "8026170", "CommentCount": "5", "Body": "<p>\u00a75.1.2/6 says:</p>\n<blockquote>\n<p id=\"so_8026170_8026489_0\">The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function <em>shall be the address of a function</em> that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<p>In other words: because it's an address of a function, and functions have no lifetime, you are free to call that function whenever you'd like. Everything you have is well-defined.</p>\n<p>It's a bit as if you'd done:</p>\n<pre><code>func_t retFun2()\n{\n    int __lambda0(int)\n    {\n        return 2;\n    }\n\n    struct\n    {\n        int operator(int __arg0) const\n        {\n            return __lambda0(__arg0);\n        }\n\n        operator decltype(__lambda0)() const\n        {\n            return __lambda0;\n        }\n    } lambda;\n\n    return lambda; // just the address of a regular ol' function\n}\n</code></pre>\n", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "8026489", "Score": "15", "CreationDate": "2011-11-06T10:41:14.963", "LastActivityDate": "2011-11-06T10:41:14.963"}});