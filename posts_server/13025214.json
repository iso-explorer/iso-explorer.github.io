post_cb({"13025237": {"ParentId": "13025214", "CommentCount": "6", "CreationDate": "2012-10-23T07:10:05.197", "OwnerUserId": "1756636", "PostTypeId": "2", "Id": "13025237", "Score": "1", "Body": "<p>The only difference between <code>struct</code> and <code>class</code> is the default access modifier to its members. In <code>struct</code> it's <code>public</code> and in <code>class</code> it's <code>private</code> (until stated otherwise). Besides that <code>struct</code> and <code>class</code> are identical in C++.\nSometimes structs are prefered for PDO (Plain Data Objects) over classes for readability but that's really up to a coding convention.</p>\n", "LastActivityDate": "2012-10-23T07:10:05.197"}, "13025534": {"ParentId": "13025214", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-10-23T07:32:21.623", "Score": "5", "LastEditorUserId": "147192", "LastEditDate": "2012-10-23T09:35:51.487", "Id": "13025534", "OwnerUserId": "147192", "Body": "<p>Whether you can use a bitwise copy or not has nothing to do with the <code>struct</code> or <code>class</code> tag and only depends on whether said <code>struct</code> or <code>class</code> <a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\" rel=\"nofollow\"><code>is_trivially_copiable</code></a>. Whether they are is defined in the Standard (9/6 [class]) and <em>it basically boils down to not having to declare any other special member methods than constructors</em>.</p>\n<p>The bitwise copy is then allowed by the Standard in 3.9/2 [basic.types]</p>\n<blockquote>\n<p id=\"so_13025214_13025534_0\">For any object (other than a base-class subobject) of trivially copyable type <code>T</code>, whether or not the object holds a valid value of type <code>T</code>, the underlying bytes (1.7) making up the object can be copied into an array of <code>char</code> or <code>unsigned char</code>. If the content of the array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the object shall subsequently hold its original value. [ <em>Example:</em></p>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj; // obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N); // between these two calls to std::memcpy,\n                           // `obj` might be modified\nstd::memcpy(&amp;obj, buf, N); // at this point, each subobject of `obj`\n                           // of scalar type holds its original value\n</code></pre>\n<p id=\"so_13025214_13025534_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p><em>Note: a bitwise copy of padding bytes will lead to reports in Valgrind.</em></p>\n<p>Using <code>std::copy</code> to the same effect:</p>\n<pre><code>char const* b = reinterpret_cast&lt;char const*&gt;(&amp;obj);\nstd::copy(b, b + N, buf);\n</code></pre>\n", "LastActivityDate": "2012-10-23T09:35:51.487"}, "bq_ids": {"n4140": {"so_13025214_13025534_0": {"section_id": 7200, "quality": 0.9523809523809523, "length": 40}}, "n3337": {"so_13025214_13025534_0": {"section_id": 6944, "quality": 0.9523809523809523, "length": 40}}, "n4659": {"so_13025214_13025534_0": {"section_id": 8709, "quality": 0.8809523809523809, "length": 37}}}, "13025214": {"CommentCount": "3", "AcceptedAnswerId": "13025534", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-23T07:08:02.110", "LastActivityDate": "2012-10-23T09:35:51.487", "LastEditDate": "2017-05-23T12:32:43.387", "ViewCount": "5103", "FavoriteCount": "2", "Title": "Struct inheritance vs class inheritance in C++", "Id": "13025214", "Score": "4", "Body": "<p>I just discovered from this <a href=\"https://stackoverflow.com/questions/979211/struct-inheritance-in-c\">Q/A</a> that structs are inheritable in C++ but, is it a good practice, or is it preferable to use classes? In which cases is preferable and in which ones is not?</p>\n<p>I have never needed this, but now I have a bunch of messages of different types, but same longitude. I got them in binary in a char array, and I just copy them with memcpy to the struct to fill its fields (I don't know if it is even possible to do it with std::copy).</p>\n<p>I guess it would be great to be able to inherit every struct from a base struct with common headers, that is why I searched for this. So a second question would be: if I do this with classes, is it possible to do a memcpy (or std:copy) from a buffer to a class?</p>\n", "Tags": "<c++><inheritance><struct><memcpy>", "OwnerUserId": "808091", "AnswerCount": "2"}});