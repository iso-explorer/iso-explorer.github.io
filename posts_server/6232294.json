post_cb({"bq_ids": {"n4140": {"so_6232294_6232526_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 72}}, "n3337": {"so_6232294_6232526_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 67}}}, "6232526": {"LastActivityDate": "2011-06-03T21:03:22.107", "CreationDate": "2011-06-03T20:49:35.920", "CommentCount": "1", "Body": "<p>GCC is right. <code>AttributeType</code> is a dependent template-name which is followed by angle bracket <code>&lt;</code>, so the keyword <code>template</code> is required here to remove the ambiguity<sup>1</sup>, making it clear to the compiler that what is followed is a template-name. The rule is mentioned in \u00a714.2/4:</p>\n<blockquote>\n<p id=\"so_6232294_6232526_0\">When the name of a member template\n  specialization appears after . or -&gt;\n  in a postfix-expression, or after\n  nested-name-specifier in a\n  qualified-id, and the\n  postfix-expression or qualified-id\n  explicitly depends on a\n  template-parameter (14.6.2), the\n  member template name must be prefixed\n  by the keyword template. Otherwise the\n  name is assumed to name a\n  non-template.</p>\n</blockquote>\n<p><sup>1</sup> @Johannes has written a very good explanation here:</p>\n<p><a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-template-and-typename-on-dependent-names/613132#613132\">Where and why do I have to put the \"template\" and \"typename\" keywords?</a></p>\n", "Id": "6232526", "LastEditDate": "2017-05-23T10:34:35.170", "ParentId": "6232294", "OwnerUserId": "415784", "PostTypeId": "2", "Score": "10", "LastEditorUserId": "-1"}, "6232294": {"FavoriteCount": "3", "ViewCount": "685", "Id": "6232294", "AcceptedAnswerId": "6232526", "Score": "15", "Title": "Which compiler is right? 'template' before templated return type needed?", "LastEditorUserId": "-1", "CommentCount": "8", "Body": "<p><a href=\"http://ideone.com/icNly\" rel=\"nofollow noreferrer\">This snippet</a> (taken from <a href=\"https://stackoverflow.com/questions/6232085/template-spaghetti\">this question</a>) compiles fine with g++ (as seen), so long the <code>template</code> before the return type is there. In contrast, VC10 does not compile that code with the following error:</p>\n<blockquote>\n<p id=\"so_6232294_6232294_0\">error C2244: 'A::getAttr' : unable to match function definition to an existing declaration</p>\n</blockquote>\n<p>If I remove the <code>template</code>, VC10 is happy but g++ screams this error:</p>\n<blockquote>\n<p id=\"so_6232294_6232294_1\">error: non-template 'AttributeType' used as template<br>\n  note: use 'A::template AttributeType' to indicate that it is a template</br></p>\n</blockquote>\n<p>Is it again because of VC's broken two-phase look-up or what is the cause? Which compiler is right here? I suspect g++ to be correct, as I have a vague memory of <code>template</code> being needed here, like with the <code>rebind</code> template inside of allocators.</p>\n<hr>\n<p><strong>Edit</strong>: We have a winner: g++/GCC (surprise surprise...).</p>\n<hr>\n<pre><code>template &lt;typename T, typename K&gt;\nclass A {\npublic:\n    T t;\n    K k;\n\n    template &lt;int i, int unused = 0&gt;\n    struct AttributeType{\n    };\n\n    template &lt;int i&gt;\n    AttributeType&lt;i&gt; getAttr();\n\n};\n\ntemplate &lt;typename T, typename K&gt;\ntemplate &lt;int i&gt;\ntypename A&lt;T, K&gt;::template AttributeType&lt;i&gt; A&lt;T, K&gt;::getAttr() {\n//                ^^^^^^^^ -- needed or not?\n    return t;\n}\n\n\nint main(){\n    A&lt;int,int&gt; a;\n}\n</code></pre>\n</hr></hr>", "Tags": "<c++><templates><visual-c++><g++><correctness>", "CreationDate": "2011-06-03T20:26:04.013", "LastEditDate": "2017-05-23T12:34:56.710", "LastActivityDate": "2011-06-03T21:04:16.023", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "500104"}});