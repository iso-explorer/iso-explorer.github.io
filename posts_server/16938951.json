post_cb({"16939183": {"Id": "16939183", "PostTypeId": "2", "Body": "<p>In the given case, it is probably a compiler bug, because the variable thrown (and moved from) is referenced afterwards.</p>\n<p>In general case invoking move on <code>throw</code> is conceptually same as moving on <code>return</code>. It is good to invoke move automatically when it is known that the variable could not be referenced after the given point (<code>throw</code> or <code>return</code>).</p>\n", "LastEditorUserId": "426288", "LastActivityDate": "2013-06-05T11:55:38.220", "Score": "5", "CreationDate": "2013-06-05T11:50:11.307", "ParentId": "16938951", "CommentCount": "1", "OwnerUserId": "426288", "LastEditDate": "2013-06-05T11:55:38.220"}, "bq_ids": {"n4140": {"so_16938951_16939177_1": {"length": 101, "quality": 0.9711538461538461, "section_id": 480}, "so_16938951_16939177_0": {"length": 13, "quality": 0.7222222222222222, "section_id": 3336}}, "n3337": {"so_16938951_16939177_1": {"length": 98, "quality": 0.9423076923076923, "section_id": 471}, "so_16938951_16939177_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 3206}}, "n4659": {"so_16938951_16939177_1": {"length": 102, "quality": 0.9807692307692307, "section_id": 502}, "so_16938951_16939177_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 4103}}}, "16939177": {"Id": "16939177", "PostTypeId": "2", "Body": "<p>C++ standard says (15.1.3): </p>\n<blockquote id=\"so_16938951_16939177_0\">Throwing an exception <b>copy-initializes (8.5, 12.8) a temporary object</b>, called the exception object. The temporary is an lvalue and is used to initialize the variable named in the matching handler (15.3).</blockquote>\n<p>This paragraph may be also relevant here (12.8.31):</p>\n<blockquote id=\"so_16938951_16939177_1\">\nWhen certain criteria are met, <b>an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects</b>. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object\noccurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):<br/>\n<br/>\n(...)<br/>\n<br/>\n\u2014 <b>in a throw-expression</b>, when the operand is the name of a non-volatile automatic object (other than a function or catch-clause parameter) <b>whose scope does not extend beyond the end of the innermost enclosing try-block (if there is one)</b>, the copy/move operation from the operand to the exception object (15.1) can be omitted by constructing the automatic object directly into the exception object</blockquote>\n<p>Checked in Visual Studio 2012, effect:</p>\n<pre><code>Exception!\nblabla\n</code></pre>\n<p>It looks like a bug in GCC indeed. </p>\n", "LastEditorUserId": "453803", "LastActivityDate": "2013-06-05T12:01:44.163", "Score": "7", "CreationDate": "2013-06-05T11:49:41.450", "ParentId": "16938951", "CommentCount": "5", "OwnerUserId": "453803", "LastEditDate": "2013-06-05T12:01:44.163"}, "16938951": {"ViewCount": "515", "Body": "<p>Recently, I've \"played\" with rvalues to understand their behavior. Most result didn't surprize me, but then I saw that if I throw a local variable, the move constructor is invoked.</p>\n<p>Until then, I thought that the purpose of move semantics rules is to guarantee that object will move (and become invalid) only if the compiler can detect that it will not be used any more (as in temporary objects), or the user promise not to use it (as in std::move).</p>\n<p>However, in the following code, none of this condition held, and my variable is still being moved (at least on g++ 4.7.3).</p>\n<p>Why is that?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main() {\n    string s=\"blabla\";\n    try {\n        throw s;\n    }\n    catch(...) {\n        cout&lt;&lt;\"Exception!\\n\";\n    }\n    cout&lt;&lt;s; //prints nothing\n}\n</code></pre>\n", "AcceptedAnswerId": "16939183", "Title": "Why throw local variable invokes moves constructor?", "CreationDate": "2013-06-05T11:39:51.213", "Id": "16938951", "CommentCount": "7", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-06-05T12:01:44.163", "Score": "19", "OwnerUserId": "1055952", "Tags": "<c++><exception><c++11><move-semantics>", "AnswerCount": "2"}});