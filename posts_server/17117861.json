post_cb({"17118011": {"Id": "17118011", "PostTypeId": "2", "Body": "<p>It would still conform to the ISO C++ standard, which doesn't even mention name mangling in normative text let alone restrict how it can be done, but would not conform to the cross-vendor <a href=\"http://mentorembedded.github.io/cxx-abi/\" rel=\"noreferrer\">ABI standard</a> that GCC uses for most platforms.</p>\n", "LastActivityDate": "2013-06-14T22:10:39.433", "CommentCount": "0", "CreationDate": "2013-06-14T22:10:39.433", "ParentId": "17117861", "Score": "5", "OwnerUserId": "981959"}, "bq_ids": {"n4140": {"so_17117861_17118037_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 5517}}, "n3337": {"so_17117861_17118037_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 5303}}, "n4659": {"so_17117861_17118037_1": {"length": 43, "quality": 0.9148936170212766, "section_id": 6952}}}, "17118037": {"Id": "17118037", "PostTypeId": "2", "Body": "<p>The Standard is quite silent on this matter, on purpose: all that relates to ABI and name mangling is implementation specific. The closest thing to an information on the subject is, I believe:</p>\n<blockquote>\n<p id=\"so_17117861_17118037_0\"><strong>7.5/1 [dcl.link]</strong></p>\n<p id=\"so_17117861_17118037_1\">All function types, function names with external linkage, and variable\n  names with external linkage have a language linkage. [ Note: <strong>Some of\n  the properties associated with an entity with language linkage are\n  specific to each implementation and are not described here. For\n  example, a particular language linkage may be associated with a\n  particular form of representing names of objects and functions with\n  external linkage, or with a particular calling convention, etc.</strong> \u2014 end\n  note ]</p>\n</blockquote>\n<p>As such, each implementation is free to do <em>anything</em> it wants concerning name mangling as long as the mangled names are valid on the underlying OS.</p>\n", "LastEditorUserId": "2070725", "LastActivityDate": "2013-06-15T00:22:33.320", "Score": "4", "CreationDate": "2013-06-14T22:13:38.880", "ParentId": "17117861", "CommentCount": "2", "OwnerUserId": "2070725", "LastEditDate": "2013-06-15T00:22:33.320"}, "17117861": {"ViewCount": "199", "Body": "<p>Okay, the question title was kind of a hook. I already get that there is no C++ standard ABI. That said, I've not deceived you eager upvote-gatherers. I'm wondering if there is ANY limitation to the C++ ABI. It seems common, for example, for at least the name of a class to be mangled <em>somewhere</em> in the ABI name.</p>\n<p><strong>A more explicit question</strong></p>\n<p>Let's say I have a collision-free hash function over all strings. Let's then say GCC added one more step to its name mangling: appending the hash of the current mangled name to an underscore. This would break almost everything under the sun, but would GCC still be as C++ standards conforming as it was before?</p>\n<p><strong>EDIT:</strong></p>\n<p>Okay, apparently the 'explicit question' bit was kind of a poorly chosen subsection name. I really wanted to know more about any common ABI standards that people follow. This was informed by the existence of binaries I have being compiled with Mingw32 linking successfully with binaries I have being compiled with MSVC.</p>\n", "AcceptedAnswerId": "17118011", "Title": "C++ ABI standards compliance w/ arbitrary name mangling", "CreationDate": "2013-06-14T21:57:53.487", "Id": "17117861", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-06-15T04:46:07.543", "LastEditorUserId": "1467466", "LastActivityDate": "2013-06-15T04:46:07.543", "ClosedDate": "2013-06-15T13:45:26.940", "Score": "-1", "OwnerUserId": "1467466", "Tags": "<c++><abi>", "AnswerCount": "3"}, "17119361": {"Id": "17119361", "PostTypeId": "2", "Body": "<p>Yes, it would of course still be just as standards compliant.  However, as awesome as it is to be standards compliant, it is certainly not the be all and end all.  </p>\n<p>Such a change would literally break backwards compatibility for every single library or application written in C++ and compiled using said version of GCC.  Backwards compatibility is incredibly important to the GCC developers, and they spend quite some time on the mailing lists (just look) discussing the relative benefit of even incredibly minor ABI changes in the face of such breakage.  Oftentimes they will go to considerable lengths to offer workarounds that can preserve backwards compatibility.</p>\n<p>Something tells me that most distros would refuse to upgrade if they changed this policy.  Might get a bunch of them to move to clang even...</p>\n<p>At least we could rest assured that they would add yet another <code>-f</code> option that would switch off the new 'feature'.</p>\n", "LastActivityDate": "2013-06-15T01:23:23.350", "CommentCount": "0", "CreationDate": "2013-06-15T01:23:23.350", "ParentId": "17117861", "Score": "0", "OwnerUserId": "251860"}});