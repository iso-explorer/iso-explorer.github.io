post_cb({"41003472": {"Id": "41003472", "PostTypeId": "2", "Body": "<p>Let's consider this piece of code:</p>\n<pre><code>((T)(y)).doSomething();\n</code></pre>\n<p>Here <em>C-style</em> cast <em>(T)(y)</em> is applied.</p>\n<p>Basically compiler performs <em>static_cast</em> from <em>T&amp;</em> to <em>T</em> in this situation (look <a href=\"http://en.cppreference.com/w/cpp/language/explicit_cast\" rel=\"nofollow noreferrer\">here</a> for details).</p>\n<p>Now from the <em>cppreference.com</em> <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow noreferrer\">static_cast</a>:</p>\n<blockquote>\n<p id=\"so_41003088_41003472_0\">static_cast &lt; new_type &gt; ( expression )</p>\n<p id=\"so_41003088_41003472_1\">...</p>\n<p id=\"so_41003088_41003472_2\">1) If there is an implicit conversion sequence from expression to\n  new_type, ... then static_cast(expression) returns the\n  imaginary variable Temp initialized as if by new_type\n  Temp(expression);</p>\n</blockquote>\n<p>There is an implicit conversion from <em>T&amp;</em> to <em>T</em>, so temporary is created by <em>static_cast</em>.</p>\n", "LastActivityDate": "2016-12-06T19:39:17.497", "CommentCount": "1", "CreationDate": "2016-12-06T19:39:17.497", "ParentId": "41003088", "Score": "3", "OwnerUserId": "5507349"}, "bq_ids": {"n4140": {"so_41003088_41003364_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 6123}, "so_41003088_41003364_1": {"length": 4, "quality": 0.8, "section_id": 6124}, "so_41003088_41003364_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 367}, "so_41003088_41003364_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 5999}}, "n3337": {"so_41003088_41003364_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5887}, "so_41003088_41003364_1": {"length": 4, "quality": 0.8, "section_id": 5888}, "so_41003088_41003364_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 356}, "so_41003088_41003364_4": {"length": 12, "quality": 0.8571428571428571, "section_id": 5767}}, "n4659": {"so_41003088_41003364_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 7620}, "so_41003088_41003364_1": {"length": 4, "quality": 0.8, "section_id": 7621}, "so_41003088_41003364_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 379}, "so_41003088_41003364_4": {"length": 10, "quality": 0.7142857142857143, "section_id": 7499}}}, "41003088": {"ViewCount": "70", "Body": "<p>In Effective STL item 22 Meyers appears to imply that casting a <code>T&amp;</code> to a <code>T</code> instantiates a temporary; that is</p>\n<pre><code>T x;\nT&amp; y = x;\n((T)(y)).doSomething();\n</code></pre>\n<p>results in <code>doSomething()</code> being done on a temporary rather than <code>x</code>.</p>\n<p>Why must the cast result in a temporary? </p>\n", "AcceptedAnswerId": "41003364", "Title": "Why does casting a type T& to T create a temporary?", "CreationDate": "2016-12-06T19:15:29.747", "Id": "41003088", "CommentCount": "1", "LastEditDate": "2016-12-06T19:26:13.503", "PostTypeId": "1", "LastEditorUserId": "3980929", "LastActivityDate": "2016-12-06T20:07:39.267", "Score": "2", "OwnerUserId": "974040", "Tags": "<c++><casting><reference>", "AnswerCount": "2"}, "41003364": {"Id": "41003364", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41003088_41003364_0\">Why must the cast result in a temporary?</p>\n</blockquote>\n<p>According to the standard, <code>(T)(y)</code> <em>constructs a temporary value</em> of type <code>T</code>. </p>\n<p>The behavior of the explicit type conversion using the cast notation is described in the C++11 Standard as follows:</p>\n<blockquote>\n<p id=\"so_41003088_41003364_1\"><strong>5.4 Explicit type conversion (cast notation)</strong></p>\n<p id=\"so_41003088_41003364_2\">1 The result of the expression <code>(T)</code> <em>cast-expression</em> is of type <code>T</code>. The result is an lvalue if <code>T</code> is an lvalue reference type or an rvalue reference to function type and an xvalue if <code>T</code> is an rvalue reference to object type; otherwise the result is a prvalue.</p>\n</blockquote>\n<p>In your case,</p>\n<p><code>T</code> is not an lvalue reference.<br>\n<code>T</code> is not an rvalue reference to function type.<br>\n<code>T</code> is not an rvalue reference to object type.</br></br></p>\n<p>Hence, the result is a prvalue of type <code>T</code>.</p>\n<p>If you look further into the definitions of prvalue and rvalue (Section 3.10), the result is a temporary object.</p>\n<p>The temporary object is constructed using the <strong>Explicit type conversion (funtional notation)</strong>.</p>\n<p>From the C++11 Standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_41003088_41003364_3\"><strong>5.2.3 Explicit type conversion (functional notation)</strong></p>\n<p id=\"so_41003088_41003364_4\">1 A <em>simple-type-specifier</em> (7.1.6.2) or <em>typename-specifier</em> (14.6) followed by a parenthesized <em>expression-list</em> <strong>constructs a value of the specified type</strong> given the expression list.</p>\n</blockquote>\n", "LastEditorUserId": "434551", "LastActivityDate": "2016-12-06T20:07:39.267", "Score": "7", "CreationDate": "2016-12-06T19:31:57.863", "ParentId": "41003088", "CommentCount": "1", "OwnerUserId": "434551", "LastEditDate": "2016-12-06T20:07:39.267"}});