post_cb({"12004297": {"Id": "12004297", "PostTypeId": "2", "Body": "<p>That's because you don't have assignment operator implemented and so a memberwise assignment is done instead. So this line:</p>\n<pre><code>obj = test(4);\n</code></pre>\n<p>causes <code>id</code> in the very first object (<code>test obj(1)</code>) to be overwritten to <code>4</code>. The last line <code>dying: 4</code> is from destroying that very object.</p>\n", "LastActivityDate": "2012-08-17T10:44:42.697", "CommentCount": "5", "CreationDate": "2012-08-17T10:44:42.697", "ParentId": "12004258", "Score": "6", "OwnerUserId": "57428"}, "12004947": {"Id": "12004947", "PostTypeId": "2", "Body": "<p>Regarding the <strong>in-practice behavior</strong>, the statement</p>\n<pre><code>    obj = test(4);\n</code></pre>\n<p>changes the value of the <code>id</code> member to <code>4</code>. Consequently, when that object is destroyed, it reports that the object with id <code>4</code> is destroyed. The assignment performs a memberwise assignment because you haven't defined the copy assignment operator.</p>\n<p>Regarding the <strong>formally guaranteed behavior</strong>, you only have that (for a hosted implementation) if the non-standard <code>\"stdafx.h\"</code> header in your code defines the macros <code>_tmain</code> and <code>_TCHAR</code> such that preprocessing yields a standard <code>main</code> function as required by the standard:</p>\n<blockquote>\n<p id=\"so_12004258_12004947_0\"><strong>C++11 \u00a73.6.1/1</strong>:<br>\n  \u201cA program shall contain a global function called <code>main</code>, which is the designated start of the program. It\n  is implementation-defined whether a program in a freestanding environment is required to define a main function.\u201d</br></p>\n</blockquote>\n<p>Although unlikely, this means that if the header does <em>not</em> define those macros appropriately, then you <em>can</em>, in principle, get the output you see <em>regardless of the rest of the code</em>.</p>\n<p>One way to ensure that that undefined behavior does not happen, is to simply use a standard <code>main</code>.</p>\n<p>After all, as of 2012 there is absolutely no advantage in using those Microsoft macros that are designed to support Windows 9x, especially considering that Microsoft, with the Layer for Unicode, made those macros <em>obsolete</em> already in 2001.</p>\n<p>I.e., continuing to use them over 10 years after, is simply meaningless obfuscation and added work, including that you can't formally say that your program must produce any particular result.</p>\n", "LastActivityDate": "2012-08-17T11:30:06.713", "CommentCount": "0", "CreationDate": "2012-08-17T11:30:06.713", "ParentId": "12004258", "Score": "0", "OwnerUserId": "464581"}, "12004258": {"ViewCount": "618", "Body": "<p>Today I was wondering about c++ destructors so I wrote a small test program. That answered my original question but raised a new one which is:<br/>\nThe following program:</p>\n<pre><code>#include \"stdafx.h\"\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nclass test\n{\npublic:\n    int id;\n    vector&lt;test&gt; collection;\n    test(){}\n    test(int id_in){id = id_in;}\n    ~test(){cout &lt;&lt; \"dying: \" &lt;&lt; id &lt;&lt; \"\\n\";}\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    {\n        test obj(1);\n        obj.collection.push_back(test(2));\n        obj.collection.push_back(test(3));\n        cout &lt;&lt; \"before overwrite\\n\";\n        obj = test(4);\n        cout &lt;&lt; \"before scope exit\\n\";\n    }\n    int x;\n    cin &gt;&gt; x;\n}\n</code></pre>\n<p>produces the following output:</p>\n<pre><code>dying: 2\ndying: 2\ndying: 3\nbefore overwrite\ndying: 2\ndying: 3\ndying: 4\nbefore scope exit\ndying: 4\n</code></pre>\n<p>Why don't I see a destructor for my test object with id 1? If its destructor isn't called when it is overwritten, than what calls the destructors of the instances in its vector?</p>\n", "AcceptedAnswerId": "12004325", "Title": "Destructor not called when object on stack is overwritten", "CreationDate": "2012-08-17T10:41:35.563", "Id": "12004258", "CommentCount": "0", "LastEditDate": "2012-08-17T10:49:21.983", "PostTypeId": "1", "LastEditorUserId": "27615", "LastActivityDate": "2012-08-17T11:30:06.713", "Score": "6", "OwnerUserId": "1109444", "Tags": "<c++><destructor>", "AnswerCount": "5"}, "12004318": {"Id": "12004318", "PostTypeId": "2", "Body": "<p><code>obj</code> is not destructed when you do this:</p>\n<pre><code>obj = test(4);\n</code></pre>\n<p>All that's happening is that a <code>test(4)</code> is being created and assigned onto the existing object so the <code>id</code> of 1 will be overwritten with 4, which is why you see the last one as:</p>\n<pre><code>dying: 4\n</code></pre>\n", "LastActivityDate": "2012-08-17T10:47:14.870", "CommentCount": "0", "CreationDate": "2012-08-17T10:47:14.870", "ParentId": "12004258", "Score": "3", "OwnerUserId": "258009"}, "bq_ids": {"n4140": {"so_12004258_12004947_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7145}}, "n3337": {"so_12004258_12004947_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6889}}, "n4659": {"so_12004258_12004947_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 8646}}}, "12004325": {"Id": "12004325", "PostTypeId": "2", "Body": "<p>You violate the <a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\">Rule of Three</a> by creating a destructor, but no assignment operator.</p>\n<p>From reading that, you can interpret your code as follows:</p>\n<p>When the line</p>\n<pre><code>obj = test(4);\n</code></pre>\n<p>is compiled, a temporary instance of <code>test</code> is created with id 4.</p>\n<p>Then, the assignment operator is called. Since you did not provide one, the compiler generated one for you that looks like this:</p>\n<pre><code>test&amp; operator=(const test&amp; other)\n{\n    id = other.id;\n    collection = other.collection;\n    return *this;\n}\n</code></pre>\n<p>The id 1 is simply overwritten with the 4 from the temporary, and for the collection assignment, the assignment operator of <code>std::vector</code> is called.</p>\n<p><code>std::vector</code>'s assignment operator deletes all previously contained elements, which is why you see</p>\n<pre><code>dying: 2\ndying: 3\n</code></pre>\n<p>in your output. Finally, the temporarily created obj instance with id 4 is deleted, causing</p>\n<pre><code>dying: 4\n</code></pre>\n<p>to appear for the first time. When <code>obj</code> goes out of scope, you see the </p>\n<pre><code>dying: 4\n</code></pre>\n<p>output once more.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-17T11:29:35.237", "Score": "6", "CreationDate": "2012-08-17T10:47:48.530", "ParentId": "12004258", "CommentCount": "4", "LastEditDate": "2017-05-23T12:20:08.793", "OwnerUserId": "1810"}, "12004320": {"Id": "12004320", "PostTypeId": "2", "Body": "<p>You don't see 1 because you destruct obj at the very end. And before you have rewritten it by test(4). Therefore 1 is rewritten by 4.</p>\n", "LastActivityDate": "2012-08-17T10:47:19.693", "CommentCount": "0", "CreationDate": "2012-08-17T10:47:19.693", "ParentId": "12004258", "Score": "0", "OwnerUserId": "747050"}});