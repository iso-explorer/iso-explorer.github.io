post_cb({"29241728": {"ParentId": "29121176", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>So my understanding is that you are doing something like that:</p>\n<pre><code>enum MType { J,K };\nstruct MessageX { MType type; };\n\nstruct MessageJ {\n    MType type{ J };\n    int id{ 5 };\n    //some other members\n};\nconst char* popMessage() {\n    return reinterpret_cast&lt;char*&gt;(new MessageJ());\n}\nvoid MessageServer(const char* foo) {\n    const MessageX* msgx = reinterpret_cast&lt;const MessageX*&gt;(foo);\n    switch (msgx-&gt;type) {\n        case J: {\n            const MessageJ* msgJ = reinterpret_cast&lt;const MessageJ*&gt;(foo);\n            std::cout &lt;&lt; msgJ-&gt;id &lt;&lt; std::endl;\n        }\n    }\n}\n\nint main() {\n    const char* foo = popMessage();\n    MessageServer(foo);\n}\n</code></pre>\n<p>If that is correct, then the expression <code>msgJ-&gt;id</code> is ok (as would be any access to <code>foo</code>), as <code>msgJ</code> has the correct dynamic type. <code>msgx-&gt;type</code> on the other hand does incur UB, because <code>msgx</code> has a unrelated type. The fact that the the pointer to <code>MessageJ</code> was cast to <code>const char*</code> in between is completely irrelevant.</p>\n<p>As was cited by others, here is the relevant part in the standard (the \"glvalue\" is the result of dereferencing the pointer):</p>\n<blockquote>\n<p id=\"so_29121176_29241728_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:52</p>\n<ol>\n<li>the dynamic type of the object,</li>\n<li><strong>a cv-qualified version of the dynamic type of the object,</strong> </li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,  </li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,  </li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,  </li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate or contained union),  </li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,  </li>\n<li>a char or unsigned char type. </li>\n</ol>\n</blockquote>\n<p>As far as the discussion \"cast to <code>char*</code>\" vs \"cast from <code>char*</code>\" is concerned:<br>\nYou might know that the standard doesn't talk about strict aliasing as such, it only provides the list above. Strict aliasing is one analysis technique based on that list for compilers to determine which pointers can potentially alias each other. As far as optimizations are concerned, it doesn't make a difference, if a pointer to a <code>MessageJ</code> object was cast to <code>char*</code> or vice versa. The compiler cannot (without further analysis) assume that a <code>char*</code> and <code>MessageX*</code> point to distinct objects and will not perform any optimizations (e.g. reordering) based on that.</br></p>\n<p>Of course that doesn't change the fact that accessing a char array via a pointer to a different type would still be UB in C++ (I assume mostly due to alignment issues) and the compiler might perform other optimizations that could ruin your day.</p>\n<p>EDIT:  </p>\n<blockquote>\n<p id=\"so_29121176_29241728_1\">What I'm asking is: Will the initialization of a const object, by\n  casting from a char*, ever be optimized below where that object is\n  cast to another type of object, such that I am casting from\n  uninitialized data?</p>\n</blockquote>\n<p>No it will not. Aliasing analysis doesn't influence how the pointer itself is handled, but the access through that pointer. The compiler will NOT reorder the write access (store memory address in the pointer variable) with the read access (copy to other variable / load of address in order to access the memory location) to the same variable.</p>\n", "OwnerUserId": "2881849", "LastEditorUserId": "2881849", "LastEditDate": "2015-03-26T13:01:28.597", "Id": "29241728", "Score": "2", "CreationDate": "2015-03-24T19:57:32.173", "LastActivityDate": "2015-03-26T13:01:28.597"}, "29170286": {"ParentId": "29121176", "CommentCount": "0", "Body": "<p>The other answer answered the question well enough (it's a direct quotation from the C++ standard in <a href=\"https://isocpp.org/files/papers/N3690.pdf\" rel=\"nofollow\">https://isocpp.org/files/papers/N3690.pdf</a> page 75), so I'll just point out other problems in what you're doing.</p>\n<p>Note that your code may run into alignment problems. For example, if the alignment of MessageJ is 4 or 8 bytes (typical on 32-bit and 64-bit machines), strictly speaking, it is undefined behaviour to access an arbitrary character array pointer as a MessageJ pointer.</p>\n<p>You won't run into any problems on x86/AMD64 architectures as they allow unaligned access. However, someday you may find that the code you're developing is ported to a mobile ARM architecture and the unaligned access would be a problem then.</p>\n<p>It therefore seems you're doing something you shouldn't be doing. I would consider using serialization instead of accessing a character array as a MessageJ type. The only problem isn't potential alignment problems, an additional problem is that the data may have a different representation on 32-bit and 64-bit architectures.</p>\n", "OwnerUserId": "4679661", "PostTypeId": "2", "Id": "29170286", "Score": "0", "CreationDate": "2015-03-20T15:33:52.970", "LastActivityDate": "2015-03-20T15:33:52.970"}, "29122056": {"ParentId": "29121176", "CommentCount": "4", "Body": "<p>There is no aliasing problem as you use (<code>const</code>)<code>char*</code> type, see the last point of:</p>\n<blockquote>\n<p id=\"so_29121176_29122056_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among -its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "29122056", "Score": "0", "CreationDate": "2015-03-18T12:27:56.463", "LastActivityDate": "2015-03-18T12:27:56.463"}, "29217925": {"ParentId": "29121176", "PostTypeId": "2", "CommentCount": "22", "Body": "<blockquote>\n<p id=\"so_29121176_29217925_0\">My company uses a messaging server which <em>gets a message into a const char*</em> and then casts it to the message type.</p>\n</blockquote>\n<p>So long as you mean that it does a reinterpret_cast (or a C-style cast that devolves to a reinterpret_cast):</p>\n<pre><code>MessageJ *j = new MessageJ();\n\nMessageServer(reinterpret_cast&lt;char*&gt;(j)); \n// or PushMessage(reinterpret_cast&lt;char*&gt;(j));\n</code></pre>\n<p>and later takes that <strong>same</strong> pointer and reinterpret_cast's it back to the actual underlying type, then that process is completely legitimate:</p>\n<pre><code>MessageServer(char *foo)\n{\n  if (somehow figure out that foo is actually a MessageJ*)\n  {\n    MessageJ *bar = reinterpret_cast&lt;MessageJ*&gt;(foo);\n    // operate on bar\n  }      \n}\n\n// or\n\nMessageServer()\n{\n  char *foo = PopMessage();\n\n  if (somehow figure out that foo is actually a MessageJ*)\n  {\n    MessageJ *bar = reinterpret_cast&lt;MessageJ*&gt;(foo);\n    // operate on bar\n  }      \n}\n</code></pre>\n<p>Note that I specifically dropped the const's from your examples as their presence or absence doesn't matter.  The above is legitimate when the underlying object that <code>foo</code> points at <strong>actually is</strong> a <code>MessageJ</code>, otherwise it is undefined behavior.  The reinterpret_cast'ing to <code>char*</code> and back again yields the original typed pointer.  Indeed, you could reinterpret_cast to a pointer of <strong>any</strong> type and back again and get the original typed pointer.  From <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\">this reference</a>:</p>\n<blockquote>\n<p id=\"so_29121176_29217925_1\">Only the following conversions can be done with reinterpret_cast ...</p>\n<p id=\"so_29121176_29217925_2\">6) An lvalue expression of type T1 can be converted to reference to another type T2. The result is an lvalue or xvalue referring to the same object as the original lvalue, but with a different type. No temporary is created, no copy is made, no constructors or conversion functions are called. The resulting reference can only be accessed safely if allowed by the type aliasing rules (see below) ...</p>\n<p id=\"so_29121176_29217925_3\">Type aliasing</p>\n<p id=\"so_29121176_29217925_4\">When a pointer or reference to object of type T1 is reinterpret_cast (or C-style cast) to a pointer or reference to object of a different type T2, the cast always succeeds, but the resulting pointer or reference may only be accessed if both T1 and T2 are standard-layout types and one of the following is true:</p>\n<ul>\n<li><em>T2 is the (possibly cv-qualified) dynamic type of the object</em> ...</li>\n</ul>\n</blockquote>\n<p>Effectively, reinterpret_cast'ing between pointers of different types simply instructs the compiler to reinterpret the pointer as pointing at a different type.  More importantly for your example though, round-tripping back to the original type again and then operating on it is safe.  That is because all you've done is instructed the compiler to reinterpret a pointer as pointing at a different type and then told the compiler again to reinterpret that same pointer as pointing back at the original, underlying type.</p>\n<p>So, the round trip conversion of your pointers is legitimate, but what about potential aliasing problems?  </p>\n<blockquote>\n<p id=\"so_29121176_29217925_5\">Is an aliasing problem possible here, or does the fact that foo is only initialized, and never modified save me?</p>\n</blockquote>\n<p>The strict aliasing rule allows compilers to assume that references (and pointers) to unrelated types do not refer to the same underlying memory.  This assumption allows lots of optimizations because it decouples operations on unrelated reference types as being completely independent.</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(int *x, long *y)  \n{\n  // foo can assume that x and y do not alias the same memory because they have unrelated types\n  // so it is free to reorder the operations on *x and *y as it sees fit\n  // and it need not worry that modifying one could affect the other\n  *x = -1;\n  *y =  0;\n  return *x;\n}\n\nint main()\n{\n  long a;\n  int  b = foo(reinterpret_cast&lt;int*&gt;(&amp;a), &amp;a);  // violates strict aliasing rule\n\n  // the above call has UB because it both writes and reads a through an unrelated pointer type\n  // on return b might be either 0 or -1; a could similarly be arbitrary\n  // technically, the program could do anything because it's UB\n\n  std::cout &lt;&lt; b &lt;&lt; ' ' &lt;&lt; a &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>In this example, thanks to the strict aliasing rule, the compiler can assume in <code>foo</code> that setting <code>*y</code> cannot affect the value of <code>*x</code>.  So, it can decide to just return -1 as a constant, for example.  Without the strict aliasing rule, the compiler would have to assume that altering <code>*y</code> might actually change the value of <code>*x</code>.  Therefore, it would have to enforce the given order of operations and reload <code>*x</code> after setting <code>*y</code>.  In this example it might seem reasonable enough to enforce such paranoia, but in less trivial code doing so will greatly constrain reordering and elimination of operations and force the compiler to reload values much more often.</p>\n<p>Here are the results on my machine when I compile the above program differently (Apple LLVM v6.0 for x86_64-apple-darwin14.1.0): </p>\n<pre><code>$ g++ -Wall test58.cc\n$ ./a.out\n0 0\n$ g++ -Wall -O3 test58.cc\n$ ./a.out\n-1 0\n</code></pre>\n<p>In your first example, <code>foo</code> is a <code>const char *</code> and <code>bar</code> is a <code>const MessageJ *</code> reinterpret_cast'ed from <code>foo</code>.  You further stipulate that the object's underlying type actually is a <code>MessageJ</code> and that no reads are done through the <code>const char *</code>.  Instead, it is only casted to the <code>const MessageJ *</code> from which only reads are then done.  Since you do not read nor write through the <code>const char *</code> alias, then there can be no aliasing optimization problem with your accesses through your second alias in the first place.  This is because there are no potentially conflicting operations performed on the underlying memory through your aliases of unrelated types.  However, even if you did read through <code>foo</code>, then there could still be no potential problem as such accesses are allowed by the type aliasing rules (see below) and any ordering of reads through <code>foo</code> or <code>bar</code> would yield the same results because there are no writes occurring here.</p>\n<p>Let us now drop the const qualifiers from your example and presume that <code>MessageServer</code> does do some write operations on <code>bar</code> and furthermore that the function also reads through <code>foo</code> for some reason (e.g. - prints a hex dump of memory).  Normally, there might be an aliasing problem here as we have reads and writes happening through two pointers to the same memory through unrelated types.  However, in this specific example, we are saved by the fact that <code>foo</code> is a <code>char*</code>, which gets special treatment by the compiler:</p>\n<blockquote>\n<p id=\"so_29121176_29217925_6\">Type aliasing</p>\n<p id=\"so_29121176_29217925_7\">When a pointer or reference to object of type T1 is reinterpret_cast (or C-style cast) to a pointer or reference to object of a different type T2, the cast always succeeds, but the resulting pointer or reference may only be accessed if both T1 and T2 are standard-layout types and one of the following is true: ...</p>\n<ul>\n<li><em>T2 is char or unsigned char</em></li>\n</ul>\n</blockquote>\n<p>The strict-aliasing optimizations that are allowed for operations through references (or pointers) of unrelated types are <strong>specifically disallowed</strong> when a <code>char</code> reference (or pointer) is in play.  The compiler instead must be paranoid that operations through the <code>char</code> reference (or pointer) can affect and be affected by operations done through other references (or pointers).  In the modified example where reads and writes operate on both <code>foo</code> and <code>bar</code>, you can still have defined behavior because <code>foo</code> is a <code>char*</code>.  Therefore, the compiler is not allowed to optimize to reorder or eliminate operations on your two aliases in ways that conflict with the serial execution of the code as written.  Similarly, it is forced to be paranoid about reloading values that may have been affected by operations through either alias.</p>\n<p>The answer to your question is that, so long as your functions are properly round tripping pointers to a type through a <code>char*</code> back to its original type, then your function is safe, even if you were to interleave reads (and potentially writes, see caveat at end of EDIT) through the <code>char*</code> alias with reads+writes through the underlying type alias.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing\" rel=\"nofollow\">These</a> two <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">technical references (3.10.10)</a> are useful for answering your question.  <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow\">These</a> other <a href=\"http://dbp-consulting.com/tutorials/StrictAliasing.html\" rel=\"nofollow\">references</a> help give a better understanding of the technical information.</p>\n<p>====<br>\n<strong>EDIT</strong>: In the comments below, zmb objects that while <code>char*</code> can legitimately alias a different type, that the converse is not true as several sources seem to say in varying forms: that the <code>char*</code> exception to the strict aliasing rule is an asymmetric, \"one-way\" rule.</br></p>\n<p>Let us modify my above strict-aliasing code example and ask would this new version similarly result in undefined behavior?</p>\n<pre><code>#include &lt;iostream&gt;\n\nchar foo(char *x, long *y)\n{\n  // can foo assume that x and y cannot alias the same memory?\n  *x = -1;\n  *y =  0;\n  return *x;\n}\n\nint main()\n{\n  long a;\n  char b = foo(reinterpret_cast&lt;char*&gt;(&amp;a), &amp;a);  // explicitly allowed!\n\n  // if this is defined behavior then what must the values of b and a be?\n\n  std::cout &lt;&lt; (int) b &lt;&lt; ' ' &lt;&lt; a &lt;&lt; std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>I argue that this is defined behavior and that both a and b must be zero after the call to <code>foo</code>.  From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">C++ standard (3.10.10)</a>:</p>\n<blockquote>\n<p id=\"so_29121176_29217925_8\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:^52 </p>\n<ul>\n<li><p id=\"so_29121176_29217925_9\">the dynamic type of the object ... </p></li>\n<li><p id=\"so_29121176_29217925_10\">a char or unsigned char type ... </p></li>\n</ul>\n<p id=\"so_29121176_29217925_11\">^52: The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>\n</blockquote>\n<p>In the above program, I am accessing the stored value of an object through both its actual type and a char type, so it is defined behavior and the results have to comport with the serial execution of the code as written.</p>\n<p>Now, there is no general way for the compiler to always statically know in <code>foo</code> that the pointer <code>x</code> actually aliases <code>y</code> or not (e.g. - imagine if <code>foo</code> was defined in a library).  Maybe the program could detect such aliasing at run time by examining the values of the pointers themselves or consulting RTTI, but the overhead this would incur wouldn't be worth it.  Instead, the better way to generally compile <code>foo</code> and allow for defined behavior when <code>x</code> and <code>y</code> do happen to alias one another is to always assume that they could (i.e. - disable strict alias optimizations when a <code>char*</code> is in play).</p>\n<p>Here's what happens when I compile and run the above program:</p>\n<pre><code>$ g++ -Wall test59.cc\n$ ./a.out\n0 0\n$ g++ -O3 -Wall test59.cc\n$ ./a.out\n0 0\n</code></pre>\n<p>This output is at odds with the earlier, similar strict-aliasing program's.  This is not dispositive proof that I'm right about the standard, but the different results from the same compiler provides decent evidence that I may be right (or, at least that one important compiler seems to understand the standard the same way).</p>\n<p>Let's examine some of the <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow\">seemingly</a> <a href=\"https://stackoverflow.com/questions/28239793/once-again-strict-aliasing-rule-and-char\">conflicting</a> <a href=\"https://stackoverflow.com/questions/23848188/strict-aliasing-rule-and-char-pointers\">sources</a>:</p>\n<blockquote>\n<p id=\"so_29121176_29217925_12\">The converse is not true. Casting a char* to a pointer of any type other than a char* and dereferencing it is usually in volation of the strict aliasing rule.  In other words, <em>casting from a pointer of one type to pointer of <strong>an unrelated type</strong> through a char* is undefined</em>.</p>\n</blockquote>\n<p>The bolded bit is why this quote doesn't apply to the problem addressed by my answer nor the example I just gave.  In both my answer and the example, the aliased memory is being accessed both through a <code>char*</code> and the actual type of the object itself, which can be defined behavior.</p>\n<blockquote>\n<p id=\"so_29121176_29217925_13\">Both C and C++ allow accessing any object type via char * (or specifically, an lvalue of type char). They do not allow accessing <em><strong>a char object</strong> via an arbitrary type</em>. So yes, the rule is a \"one way\" rule.\"</p>\n</blockquote>\n<p>Again, the bolded bit is why this statement doesn't apply to my answers.  In this and similar counter-examples, an array of characters is being accessed through a pointer of an unrelated type.  Even in C, this is UB because the character array might not be aligned according to the aliased type's requirements, for example.  In C++, this is UB because such access does not meet any of the type aliasing rules as the underlying type of the object actually is <code>char</code>.</p>\n<p>In my examples, we first have a valid pointer to a properly constructed type that is then aliased by a <code>char*</code> and then reads and writes through these two aliased pointers are interleaved, which can be defined behavior.  So, there seems to be some confusion and conflation out there between the strict aliasing exception for <code>char</code> and not accessing an underlying object through an incompatible reference.</p>\n<pre><code>int   value;  \nint  *p = &amp;value;  \nchar *q = reinterpret_cast&lt;char*&gt;(&amp;value);\n</code></pre>\n<blockquote>\n<p id=\"so_29121176_29217925_14\">Both p and p refer to the same address, they are aliasing the same memory. What the language does is provide a set of rules defining the behaviors that are guaranteed: write through p read through q fine, <em>other way around not fine</em>.</p>\n</blockquote>\n<p>The standard and many examples clearly state that \"write through q, then read through p (or value)\" can be well defined behavior.  What is not as abundantly clear, but what I'm arguing for here, is that \"write through p (or value), then read through q\" is <strong>always</strong> well defined.  I claim even further, that \"reads and writes through p (or value) can be arbitrarily interleaved with reads and writes to q\" with well defined behavior.</p>\n<p>Now there is one caveat to the previous statement and why I kept sprinkling the word \"can\" throughout the above text.  If you have a type <code>T</code> reference and a <code>char</code> reference that alias the same memory, then arbitrarily interleaving reads+writes on the <code>T</code> reference with reads on the <code>char</code> reference is <strong>always</strong> well defined.  For example, you might do this to repeatedly print out a hex dump of the underlying memory as you modify it multiple times through the <code>T</code> reference.  The standard guarantees that strict aliasing optimizations will not be applied to these interleaved accesses, which otherwise might give you undefined behavior.</p>\n<p>But what about writes through a <code>char</code> reference alias?  Well, such writes may or may not be well defined.  If a write through the <code>char</code> reference violates an invariant of the underlying <code>T</code> type, then you can get undefined behavior.  If such a write improperly modified the value of a <code>T</code> member pointer, then you can get undefined behavior.  If such a write modified a <code>T</code> member value to a trap value, then you can get undefined behavior.  And so on.  However, in other instances, writes through the <code>char</code> reference can be completely well defined.  Rearranging the endianness of a <code>uint32_t</code> or <code>uint64_t</code> by reading+writing to them through an aliased <code>char</code> reference is <strong>always</strong> well defined, for example.  So, whether such writes are completely well defined or not depends on the particulars of the writes themselves.  Regardless, the standard guarantees that its strict aliasing optimizations will not reorder or eliminate such writes w.r.t. other operations on the aliased memory in a manner that itself could lead to undefined behavior.</p>\n", "OwnerUserId": "4564515", "LastEditorUserId": "4564515", "LastEditDate": "2015-03-25T13:49:27.623", "Id": "29217925", "Score": "2", "CreationDate": "2015-03-23T18:40:28.067", "LastActivityDate": "2015-03-25T13:49:27.623"}, "29121176": {"CommentCount": "24", "AcceptedAnswerId": "29217925", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-03-18T11:45:14.170", "LastActivityDate": "2015-03-26T13:01:28.597", "LastEditDate": "2017-05-23T11:50:43.910", "ViewCount": "589", "FavoriteCount": "3", "Title": "Can Aliasing Problems be Avoided with const Variables", "Id": "29121176", "Score": "6", "Body": "<p>My company uses a messaging server which gets a message into a <code>const char*</code> and then casts it to the message type.</p>\n<p>I've become concerned about this after asking <a href=\"https://stackoverflow.com/q/28697626/2642059\">this question</a>. I'm not aware of any bad behavior in the messaging server. Is it possible that <code>const</code> variables do not incur aliasing problems?</p>\n<p>For example say that foo is defined in <code>MessageServer</code> in one of these ways:</p>\n<ol>\n<li>As a parameter: <code>void MessageServer(const char* foo)</code></li>\n<li>Or as const variable at the top of <code>MessageServer</code>: <code>const char* foo = PopMessage();</code></li>\n</ol>\n<p>Now <code>MessageServer</code> is a huge function, but it never assigns anything to <code>foo</code>, however at 1 point in <code>MessageServer</code>'s logic <code>foo</code> <em>will</em> be cast to the selected message type.</p>\n<pre><code>auto bar = reinterpret_cast&lt;const MessageJ*&gt;(foo);\n</code></pre>\n<p><code>bar</code> will only be read from subsequently, but will be used extensively for object setup.</p>\n<p>Is an aliasing problem possible here, or does the fact that <code>foo</code> is only initialized, and never modified save me?</p>\n<p><strong>EDIT:</strong></p>\n<p><a href=\"https://stackoverflow.com/a/29122056/2642059\">Jarod42's answer</a> finds no problem with casting from a <code>const char*</code> to a <code>MessageJ*</code>, but I'm not sure this makes sense.</p>\n<p>We know this is illegal:</p>\n<pre><code>MessageX* foo = new MessageX;\nconst auto bar = reinterpret_cast&lt;MessageJ*&gt;(foo);\n</code></pre>\n<p>Are we saying this somehow makes it legal?</p>\n<pre><code>MessageX* foo = new MessageX;\nconst auto temp = reinterpret_cast&lt;char*&gt;(foo);\nauto bar = reinterpret_cast&lt;const MessageJ*&gt;(temp);\n</code></pre>\n<p>My understanding of <a href=\"https://stackoverflow.com/a/29122056/2642059\">Jarod42's answer</a> is that the cast to <code>temp</code> makes it legal.</p>\n<p><strong>EDIT:</strong></p>\n<p>I've gotten some comments with relation to serialization, alignment, network passing, and so on. That's not what this question is about.</p>\n<p><strong>This is a question about <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow noreferrer\">strict aliasing</a>.</strong></p>\n<blockquote>\n<p id=\"so_29121176_29121176_0\">Strict aliasing is an assumption, made by the C (or C++) compiler, that dereferencing pointers to objects of different types will never refer to the same memory location (i.e. alias eachother.)</p>\n</blockquote>\n<p>What I'm asking is: <strong>Will the initialization of a <code>const</code> object, by casting from a <code>char*</code>, ever be optimized below where that object is cast to another type of object, such that I am casting from uninitialized data?</strong></p>\n", "Tags": "<c++><const><alias><reinterpret-cast><strict-aliasing>", "OwnerUserId": "2642059", "AnswerCount": "5"}, "29224947": {"ParentId": "29121176", "CommentCount": "5", "Body": "<p>First of all, casting pointers does not cause any aliasing violations (although it might cause alignment violations).</p>\n<p>Aliasing refers to the process of <em>reading or writing</em> an object through a glvalue of different type than the object. </p>\n<p>If an object has type <code>T</code>, and we read/write it via a <code>X&amp;</code> and a <code>Y&amp;</code> then the questions are:</p>\n<ul>\n<li>Can <code>X</code> alias <code>T</code>?</li>\n<li>Can <code>Y</code> alias <code>T</code>?</li>\n</ul>\n<p>It does not directly matter whether <code>X</code> can alias <code>Y</code> or vice versa, as you seem to focus on in your question. But, the compiler can infer if <code>X</code> and <code>Y</code> are completely incompatible that there is no such type <code>T</code> that can be aliased by both <code>X</code> and <code>Y</code>, therefore it can assume that the two references refer to different objects.</p>\n<p>So, to answer your question, it all hinges on what <code>PopMessage</code> does. If the code is something like:</p>\n<pre><code>const char *PopMessage()\n{\n     static MessageJ foo = .....;\n     return reinterpret_cast&lt;const char *&gt;(&amp;foo);\n}\n</code></pre>\n<p>then it is fine to write:</p>\n<pre><code>const char *ptr = PopMessage();\nauto bar = reinterpret_cast&lt;const MessageJ*&gt;(foo);\n\nauto baz = *bar;    // OK, accessing a `MessageJ` via glvalue of type `MessageJ`\nauto ch = ptr[4];   // OK, accessing a `MessageJ` via glvalue of type `char`\n</code></pre>\n<p>and so on.  The <code>const</code> has nothing to do with it. In fact if you did not use <code>const</code> here (or you cast it away) then you could also write through <code>bar</code> and <code>ptr</code> with no problem.</p>\n<p>On the other hand, if PopMessage was something like:</p>\n<pre><code>const char *PopMessage()\n{\n    static char buf[200];\n    return buf;\n}\n</code></pre>\n<p>then the line <code>auto baz = *bar;</code> would cause UB because <code>char</code> cannot be aliased by <code>MessageJ</code>.  Note that you can use placement-new to change the dynamic type of an object (in that case, <code>char buf[200]</code> is said to have stopped existing, and the new object created by placement-new exists and its type is <code>T</code>).</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "29224947", "Score": "3", "CreationDate": "2015-03-24T04:17:44.057", "LastActivityDate": "2015-03-24T04:17:44.057"}, "bq_ids": {"n4140": {"so_29121176_29241728_0": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}, "so_29121176_29217925_10": {"section_id": 45, "quality": 1.0, "length": 4}, "so_29121176_29217925_11": {"section_id": 7239, "quality": 0.9, "length": 9}, "so_29121176_29122056_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_29121176_29217925_8": {"section_id": 7239, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_29121176_29217925_10": {"section_id": 42, "quality": 1.0, "length": 4}, "so_29121176_29217925_11": {"section_id": 6983, "quality": 0.9, "length": 9}, "so_29121176_29122056_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_29121176_29217925_8": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}, "so_29121176_29241728_0": {"section_id": 6983, "quality": 0.9285714285714286, "length": 13}, "so_29121176_29217925_2": {"section_id": 5818, "quality": 0.525, "length": 21}}, "n4659": {"so_29121176_29241728_0": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}, "so_29121176_29217925_10": {"section_id": 46, "quality": 1.0, "length": 4}, "so_29121176_29217925_11": {"section_id": 8748, "quality": 0.9, "length": 9}, "so_29121176_29122056_0": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_29121176_29217925_8": {"section_id": 8748, "quality": 0.9285714285714286, "length": 13}}}});