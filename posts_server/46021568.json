post_cb({"bq_ids": {"n4140": {"so_46021568_46027039_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6046}, "so_46021568_46027039_0": {"length": 41, "quality": 0.7192982456140351, "section_id": 6039}}, "n3337": {"so_46021568_46027039_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 5814}, "so_46021568_46027039_0": {"length": 30, "quality": 0.5263157894736842, "section_id": 5807}}, "n4659": {"so_46021568_46027039_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 7545}, "so_46021568_46027039_0": {"length": 56, "quality": 0.9824561403508771, "section_id": 7538}}}, "46027039": {"Id": "46027039", "PostTypeId": "2", "Body": "<p>According to [expr.static.cast]:</p>\n<blockquote>\n<p id=\"so_46021568_46027039_0\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue of type \u201cpointer to cv2 T\u201d, where T is\n  an object type and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. If the original\n  pointer value represents the address A of a byte in memory and A does not satisfy the alignment requirement\n  of T, then the resulting pointer value is unspecified. Otherwise, if the original pointer value points to an\n  object a, and there is an object b of type T (ignoring cv-qualification) that is pointer-interconvertible (6.9.2)\n  with a, the result is a pointer to b. Otherwise, the pointer value is unchanged by the conversion.</p>\n</blockquote>\n<p>According to [expr.reinterpret.cast]:</p>\n<blockquote>\n<p id=\"so_46021568_46027039_1\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue v of\n  object pointer type is converted to the object pointer type \u201cpointer to cv T\u201d, the result is static_cast(static_cast(v)).</p>\n</blockquote>\n<p>So I will suppose b point to an element of the array of three unsigned char.</p>\n", "LastActivityDate": "2017-09-03T19:18:06.763", "CommentCount": "0", "CreationDate": "2017-09-03T19:18:06.763", "ParentId": "46021568", "Score": "1", "OwnerUserId": "5632316"}, "46021568": {"ViewCount": "50", "Body": "<p>Let's suppose I have the following code:</p>\n<pre><code>int* p = new (new unsigned char[3*sizeof(int)]) int{};\nunsigned char* b = reinterpret_cast&lt;unsigned char*&gt;(p);\nauto b2 = b + 2*sizeof(int);//it is UB if compilers do not assume that\n                            //b is pointer to an unsigned char[3*sizeof(int)]\nint* p2 = new (b2) int{}; \n</code></pre>\n<p>If <code>b</code> is not a pointer to the array of <code>3*sizeof(int)</code> unsigned char that provides storage for <code>*p</code>, then the section [expr.add] of the C++ standard implies that <code>b+2*sizeof(int)</code> is undefined behavior (UB). Otherwise if the compiler must assume that <code>b</code> is also a pointer to the array of unsigned char that provides storage for <code>*p</code> then it is not UB.</p>\n<p>So is it specified in the standard that compilers must assume that <code>b</code> is a pointer to the <code>unsigned char[3*sizeof(int)]</code>that provides storage for <code>*p</code>?</p>\n", "Title": "Pointer to element of object representation or pointer to an element of the provided storage?", "CreationDate": "2017-09-03T08:25:08.633", "LastActivityDate": "2017-09-03T19:18:06.763", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-09-03T08:57:54.783", "LastEditorUserId": "7018546", "Id": "46021568", "Score": "3", "OwnerUserId": "5632316", "Tags": "<c++><pointers><language-lawyer>", "AnswerCount": "1"}});