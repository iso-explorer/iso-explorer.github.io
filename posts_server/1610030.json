post_cb({"1610030": {"ViewCount": "39525", "Body": "<p>Ever since I realized many years ago, that this doesn't produce an error by default, (in gcc at least) I've always wondered why?</p>\n<p>I understand that you can issue compiler flags to produce a warning, but shouldn't it always be an error? Why does it make sense for a non-void function not returning value to be valid?</p>\n<p>An example as requested in the comments:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint stringSize()\n{\n}\n\nint main()\n{\n    char cstring[5];\n    printf( \"the last char is: %c\\n\", cstring[stringSize()-1] ); \n    return 0;\n}\n</code></pre>\n<p>...compiles.</p>\n", "AcceptedAnswerId": "1610454", "Title": "Why does flowing off the end of a non-void function without returning a value not produce a compiler error?", "CreationDate": "2009-10-22T21:21:24.220", "Id": "1610030", "CommentCount": "2", "FavoriteCount": "44", "PostTypeId": "1", "LastEditDate": "2016-03-22T03:42:22.510", "LastEditorUserId": "1505939", "LastActivityDate": "2016-09-23T18:41:39.877", "Score": "137", "OwnerUserId": "106797", "Tags": "<c++><c><gcc><compiler-construction><g++>", "AnswerCount": "8"}, "1610077": {"Id": "1610077", "PostTypeId": "2", "Body": "<p>Sounds like you need to turn up your compiler warnings:</p>\n<pre><code>$ gcc -Wall -Wextra -Werror -x c -\nint main(void) { return; }\ncc1: warnings being treated as errors\n&lt;stdin&gt;: In function \u2018main\u2019:\n&lt;stdin&gt;:1: warning: \u2018return\u2019 with no value, in function returning non-void\n&lt;stdin&gt;:1: warning: control reaches end of non-void function\n$\n</code></pre>\n", "LastActivityDate": "2009-10-22T21:28:11.780", "CommentCount": "13", "CreationDate": "2009-10-22T21:28:11.780", "ParentId": "1610030", "Score": "0", "OwnerUserId": "60777"}, "1610063": {"Id": "1610063", "PostTypeId": "2", "Body": "<p>Under what circumstances doesn't it produce an error?  If it declares a return type and doesn't return something, it sounds like an error to me.  </p>\n<p>The one exception I can think of is the <code>main()</code> function, which doesn't need a <code>return</code> statement at all (at least in C++; I don't have either of the C standards handy).  If there is no return, it will act as if <code>return 0;</code> is the last statement.</p>\n", "LastActivityDate": "2009-10-22T21:25:37.830", "CommentCount": "4", "CreationDate": "2009-10-22T21:25:37.830", "ParentId": "1610030", "Score": "0", "OwnerUserId": "14148"}, "1610071": {"Id": "1610071", "PostTypeId": "2", "Body": "<p>You mean, why flowing off the end of a value-returning function (i.e. exiting without an explicit <code>return</code>) is not an error?</p>\n<p>Firstly, in C whether a function returns something meaningful or not is only critical when the executing code actually <em>uses</em> the returned value. Maybe the language didn't want to force you to return anything when you know that you are not going to use it anyway most of the time.</p>\n<p>Secondly, apparently the language specification did not want to force the compiler authors to detect and verify all possible control paths for the presence of an explicit <code>return</code> (although in many cases this is not that difficult to do). Also, some control paths might lead into to <em>non-returning functions</em> - the trait that is generally non known to the compiler. Such paths can become a source of annoying false positives.</p>\n<p>Note also, that C and C++ differ in their definitions of the behavior in this case. In C++ just flowing off the end of a value returning function is always undefined behavior (regardless of whether the function's result is used by the calling code). In C this causes undefined behavior only if the calling code tries to use the returned value.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-09-23T18:41:39.877", "Score": "13", "CreationDate": "2009-10-22T21:27:37.117", "ParentId": "1610030", "CommentCount": "2", "LastEditDate": "2016-09-23T18:41:39.877", "OwnerUserId": "187690"}, "1610111": {"Id": "1610111", "PostTypeId": "2", "Body": "<p>gcc does not by default check that all code paths return a value because in general this cannot be done. It assumes you know what you are doing. Consider a common example using enumerations:</p>\n<pre><code>Color getColor(Suit suit) {\n    switch (suit) {\n        case HEARTS: case DIAMONDS: return RED;\n        case SPADES: case CLUBS:    return BLACK;\n    }\n\n    // Error, no return?\n}\n</code></pre>\n<p>You the programmer know that, barring a bug, this method always returns a color. gcc trusts that you know what you are doing so it doesn't force you to put a return at the bottom of the function.</p>\n<p>javac, on the other hand, tries to verify that all code paths return a value and throws an error if it cannot prove that they all do. This error is mandated by the Java language specification. Note that sometimes it is wrong and you have to put in an unnecessary return statement.</p>\n<pre><code>char getChoice() {\n    int ch = read();\n\n    if (ch == -1 || ch == 'q') {\n        System.exit(0);\n    }\n    else {\n        return (char) ch;\n    }\n\n    // Cannot reach here, but still an error.\n}\n</code></pre>\n<p>It's a philosophical difference. C and C++ are more permissive and trusting languages than Java or C# and so some errors in the newer languages are warnings in C/C++ and some warnings are ignored or off by default.</p>\n", "LastEditorUserId": "68587", "LastActivityDate": "2009-10-22T22:18:29.743", "Score": "41", "CreationDate": "2009-10-22T21:34:11.360", "ParentId": "1610030", "CommentCount": "7", "LastEditDate": "2009-10-22T22:18:29.743", "OwnerUserId": "68587"}, "bq_ids": {"n4140": {"so_1610030_1610454_0": {"length": 9, "quality": 1.0, "section_id": 3913}, "so_1610030_1610454_1": {"length": 9, "quality": 1.0, "section_id": 7149}, "so_1610030_1610148_5": {"length": 13, "quality": 0.7222222222222222, "section_id": 3913}, "so_1610030_1610148_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7218}}, "n3337": {"so_1610030_1610454_0": {"length": 9, "quality": 1.0, "section_id": 3773}, "so_1610030_1610454_1": {"length": 9, "quality": 1.0, "section_id": 6893}, "so_1610030_1610148_5": {"length": 13, "quality": 0.7222222222222222, "section_id": 3773}, "so_1610030_1610148_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6962}}, "n4659": {"so_1610030_1610454_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4799}, "so_1610030_1610148_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 4799}, "so_1610030_1610148_5": {"length": 12, "quality": 0.6666666666666666, "section_id": 4799}}}, "1610454": {"Id": "1610454", "PostTypeId": "2", "Body": "<p>C99 and C++ standards don't require functions to return a value. The missing return statement in a value-returning function will be defined (to return <code>0</code>) only in the <code>main</code> function.</p>\n<p>The rationale includes that checking if every code path returns a value is quite difficult, and a return value could be set with embedded assembler or other tricky methods.</p>\n<p>From <a href=\"https://stackoverflow.com/a/4653479/1505939\">C++11</a> draft:</p>\n<p>\u00a7 6.6.3/2</p>\n<blockquote>\n<p id=\"so_1610030_1610454_0\">Flowing off the end of a function [...] results in undefined behavior in a value-returning function.</p>\n</blockquote>\n<p>\u00a7 3.6.1/5</p>\n<blockquote>\n<p id=\"so_1610030_1610454_1\">If control reaches the end of <code>main</code> without encountering a <code>return</code>  statement, the effect is that of executing  </p>\n<pre><code>return 0;\n</code></pre>\n</blockquote>\n<p>Note that the behaviour described in C++ 6.6.3/2 is not the same in C.  </p>\n<hr>\n<p>gcc will give you a warning if you call it with -Wreturn-type option.</p>\n<blockquote>\n<p id=\"so_1610030_1610454_2\"><strong>-Wreturn-type</strong> Warn whenever a function is defined with a return-type that\n  defaults to int. Also warn about any\n  return statement with no return-value\n  in a function whose return-type is not\n  void (falling off the end of the\n  function body is considered returning\n  without a value), and about a return\n  statement with an expression in a\n  function whose return-type is void.  </p>\n<p id=\"so_1610030_1610454_3\">This warning is enabled by <strong>-Wall</strong>.</p>\n</blockquote>\n<hr>\n<p>Just as a curiosity, look what this code does:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo() {\n   int a = 5;\n   int b = a + 1;\n}\n\nint main() { std::cout &lt;&lt; foo() &lt;&lt; std::endl; } // may print 6\n</code></pre>\n<p>This code has formally undefined behaviour, and in practice it's <a href=\"http://en.wikipedia.org/wiki/X86_calling_conventions\" rel=\"noreferrer\">calling convention</a> and <a href=\"http://en.wikipedia.org/wiki/X86\" rel=\"noreferrer\">architecture</a> dependent. On one particular system, with one particular compiler, the return value is the result of last expression evaluation, stored in the <code>eax</code> register of that system's processor.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-22T18:12:37.163", "Score": "137", "CreationDate": "2009-10-22T22:51:22.653", "ParentId": "1610030", "CommentCount": "18", "LastEditDate": "2017-05-23T11:54:36.703", "OwnerUserId": "147336"}, "37503481": {"Id": "37503481", "PostTypeId": "2", "Body": "<p>It is legal under C/C++ to not return from a function that claims to return something.  There are a number of use cases, such as calling <code>exit(-1)</code>, or a function that calls it or throws an exception.</p>\n<p>The compiler is not going to reject legal C++ even if it leads to UB if you are asking it not to.  In particular, you are asking for <em>no warnings</em> to be generated.  (Gcc still turns on some by default, but when added those seem to align with new features not new warnings for old features)</p>\n<p>Changing the default no-arg gcc to emit some warnings could be a breaking change for existing scripts or make systems.  Well designed ones either <code>-Wall</code> and deal with warnings, or toggle individual warnings.</p>\n<p>Learning to use a C++ tool chain is a barrier to learning to be a C++ programmer, but C++ tool chains are typically written by and for experts.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2016-05-28T20:30:18.507", "Score": "3", "CreationDate": "2016-05-28T20:28:11.933", "ParentId": "1610030", "CommentCount": "5", "LastEditDate": "2016-05-28T20:30:18.507", "OwnerUserId": "1774667"}, "1610148": {"Id": "1610148", "PostTypeId": "2", "Body": "<p>It is a constraint violation in c99, but not in c89.  Contrast:</p>\n<p>c89:</p>\n<blockquote>\n<p id=\"so_1610030_1610148_0\">3.6.6.4 The <code>return</code> statement</p>\n<p id=\"so_1610030_1610148_1\">Constraints</p>\n<p id=\"so_1610030_1610148_2\">A <code>return</code> statement with an expression shall not appear in a\n  function whose return type is <code>void</code> .</p>\n</blockquote>\n<p>c99:</p>\n<blockquote>\n<p id=\"so_1610030_1610148_3\">6.8.6.4 The <code>return</code> statement</p>\n<p id=\"so_1610030_1610148_4\">Constraints</p>\n<p id=\"so_1610030_1610148_5\">A <code>return</code> statement with an expression shall not appear in a function whose return type is <code>void</code>. A <code>return</code> statement without an expression shall only appear in a function whose return type is <code>void</code>.</p>\n</blockquote>\n<p>Even in <code>--std=c99</code> mode, gcc will only throw a warning (although without needing to enable additional <code>-W</code> flags, as is required by default or in c89/90).</p>\n<p>Edit to add that in c89, \"reaching the <code>}</code> that terminates a function is equivalent to\nexecuting a <code>return</code> statement without an expression\" (3.6.6.4).  However, in c99 the behavior is undefined (6.9.1).</p>\n", "LastEditorUserId": "176071", "LastActivityDate": "2009-10-22T21:51:41.403", "Score": "-2", "CreationDate": "2009-10-22T21:41:12.320", "ParentId": "1610030", "CommentCount": "2", "LastEditDate": "2009-10-22T21:51:41.403", "OwnerUserId": "176071"}, "29682800": {"Id": "29682800", "PostTypeId": "2", "Body": "<p>I believe this is because of legacy code (C never required return statement so did C++). There is probably huge code base relying on that \"feature\". But at least there is <code>-Werror=return-type</code> \nflag on many compilers (including gcc and clang).</p>\n", "LastActivityDate": "2015-04-16T18:11:18.180", "CommentCount": "0", "CreationDate": "2015-04-16T18:11:18.180", "ParentId": "1610030", "Score": "0", "OwnerUserId": "4797786"}});