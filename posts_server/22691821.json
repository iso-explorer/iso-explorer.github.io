post_cb({"bq_ids": {"n4140": {"so_22691821_22691915_0": {"length": 22, "quality": 1.0, "section_id": 5857}}, "n3337": {"so_22691821_22691915_0": {"length": 22, "quality": 1.0, "section_id": 5627}}, "n4659": {"so_22691821_22691915_0": {"length": 22, "quality": 1.0, "section_id": 7336}}}, "22691821": {"ViewCount": "410", "Body": "<p>I found myself with a nested class and a member function which had the same name. The member function is intended to return an instance of the nested class:</p>\n<pre><code>class Foo\n{\npublic:\n    class Lock\n    {\n        // Operations that require the lock...\n    };\n\n    Lock Lock() noexcept {return Lock;}\n};\n</code></pre>\n<p>This understandably did not work so I was looking for a way around it and tried:</p>\n<pre><code>return typename Foo::Lock();\n</code></pre>\n<p>This worked fine on g++ 4.7 and 4.8 but when run on clang++ 3.4 I get errors:</p>\n<p>Without c++11: <code>error: typename specifier refers to non-type member 'Lock' in 'Foo'</code>\nWith c++11: <code>'error: typename specifier refers to non-type member 'Lock' in 'Foo'</code></p>\n<p>This leads to my questions:</p>\n<ul>\n<li>Which of these is correct?</li>\n<li>Is there a way to reference the nested class in the member function as in the example?</li>\n</ul>\n", "AcceptedAnswerId": "22691915", "Title": "Nested class and member function with same name", "CreationDate": "2014-03-27T15:13:13.720", "Id": "22691821", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-03-27T15:38:28.287", "Score": "3", "OwnerUserId": "918124", "Tags": "<c++><c++11><g++><clang++>", "AnswerCount": "1"}, "22691915": {"Id": "22691915", "PostTypeId": "2", "Body": "<p>I'd advise against it, as it will just make the code really hard to read. But if you really want to go ahead, you have to keep prefixing the nested class with the <code>class</code> keyword. Where that's syntactically invalid, use a typedef:</p>\n<pre><code>class Foo\n{\npublic:\n    class Lock\n    {\n        // Operations that require the lock...\n    };\n\n    class Lock Lock() noexcept {\n      typedef class Lock cLock;\n      return cLock();\n    }\n};\n</code></pre>\n<p><a href=\"http://ideone.com/mFN8mz\" rel=\"nofollow\"><strong>Live example</strong></a></p>\n<p>As to the errors, clang is correct on this one. You cannot use <code>typename</code> for disambiguation like this, and I don't think it's supposed to be usable outside of templates at all.</p>\n<p>Standard references:</p>\n<ul>\n<li><p><code>C++11[class.name]\u00a74</code> specifies how <code>Lock</code> hides <code>class Lock</code> and how it can be accessed as <code>class Lock</code>.</p></li>\n<li><p><code>C++11[class.name]\u00a72</code> states that:</p>\n<blockquote>\n<p id=\"so_22691821_22691915_0\">If a class name is declared in a scope where a variable, function, or enumerator of the same name is also declared, then when both declarations are in scope, the class can be referred to only using an <em>elaborated-type-specifier</em></p>\n</blockquote>\n<p>An <em>elaborated-type-specifier</em> is the <code>class X</code> form. Note this implies that <code>typename Foo::Lock</code> is not a valid way of referring to it.</p></li>\n</ul>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2014-03-27T15:38:28.287", "Score": "1", "CreationDate": "2014-03-27T15:17:02.830", "ParentId": "22691821", "CommentCount": "3", "OwnerUserId": "1782465", "LastEditDate": "2014-03-27T15:38:28.287"}});