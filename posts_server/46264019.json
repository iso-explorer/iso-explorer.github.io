post_cb({"bq_ids": {"n4140": {"so_46264019_46264301_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}, "n3337": {"so_46264019_46264301_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 29}}, "n4659": {"so_46264019_46264301_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}}, "46264019": {"ViewCount": "93", "Body": "<p>Here are two very similar snippets:</p>\n<pre><code>vector&lt;int&gt; a;\nint n = static_cast&lt;int&gt;(a.size());\n// ---------\nint f(const vector&lt;int&gt;&amp; a) {\n    return static_cast&lt;int&gt;(a.size());\n}\n</code></pre>\n<p>Here I explicitly cast a value of type <code>size_t</code> to type <code>int</code>. If I omit <code>static_cast</code> then the same cast applies implicitly.</p>\n<p>Of which kind would this implicit cast be? Is it safe to omit <code>static_cast</code> in explicit assignments and return statements?</p>\n", "AcceptedAnswerId": "46264301", "Title": "Should I use static_cast in assignments and return statements and why?", "CreationDate": "2017-09-17T12:21:56.653", "Id": "46264019", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-09-17T12:53:32.130", "Score": "3", "OwnerUserId": "2159939", "Tags": "<c++><casting><static-cast>", "AnswerCount": "3"}, "46264118": {"Id": "46264118", "PostTypeId": "2", "Body": "<p>This would be an integral conversion. And a narrowing one at that.</p>\n<p>For the variable initialization, if you want a specific type, a good approach is to do what Herb Sutter suggests in his \"Almost Always Auto\" <a href=\"https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/\" rel=\"nofollow noreferrer\">GotW article</a>:</p>\n<pre><code>auto n = int{a.size()};\n</code></pre>\n<p>Use list initialization whenever possible. It will prevent narrowing conversions and you'll be flagged by your compiler to use an explicit cast when required (such as the case above).</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-09-17T12:50:52.587", "Score": "3", "CreationDate": "2017-09-17T12:32:57.090", "ParentId": "46264019", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2017-09-17T12:50:52.587"}, "46264194": {"Id": "46264194", "PostTypeId": "2", "Body": "<p>The necessarily of casting is determined by the necessarily of conversion. So the real question here should \"be why would I return / store an <code>int</code> instead of <code>vector&lt;int&gt;::size_type</code>?\" If your program logic doesn't really require such conversion then don't perform it at all. If your program logic requires such conversion (for example you need to pass this value into a call to a third-party function that accepts <code>int</code>) then you should use <code>static_cast</code>. Omitting <code>static_cast</code> in this case would be a sign of unintended narrowing conversion and will trigger corresponding compiler warnings, such as <code>warning C4267: 'initializing': conversion from 'size_t' to 'int', possible loss of data</code> or <code>warning: conversion to 'int' from 'std::vector&lt;int&gt;::size_type {aka long unsigned int}' may alter its value [-Wconversion]</code></p>\n", "LastEditorUserId": "7860670", "LastActivityDate": "2017-09-17T12:47:35.550", "Score": "2", "CreationDate": "2017-09-17T12:41:52.813", "ParentId": "46264019", "CommentCount": "0", "OwnerUserId": "7860670", "LastEditDate": "2017-09-17T12:47:35.550"}, "46264301": {"Id": "46264301", "PostTypeId": "2", "Body": "<p>This cast is not that safe, actualy the value of <code>n</code> may be implementation defined (c++ standard [conv.integral]):</p>\n<blockquote>\n<p id=\"so_46264019_46264301_0\">If the destination type is signed, the value is unchanged if it can be represented in the destination type otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>If you enable all warning, and don't use the static_cast, your compiler may inform you about a narrowing conversion. If you use the <code>static_cast</code>, you inform reader of your code that you know for sure that <code>a.size() &lt;= std::numeric_limits&lt;int&gt;::max()</code> or that you know what your implementation is going to do if such a condition does not hold.</p>\n<p>(notice that it could be possible that previous comparison also invokes implementation defined conversion if std::size_t is smaller than int, the c++ standard allowes it)</p>\n", "LastActivityDate": "2017-09-17T12:53:32.130", "CommentCount": "2", "CreationDate": "2017-09-17T12:53:32.130", "ParentId": "46264019", "Score": "1", "OwnerUserId": "5632316"}});