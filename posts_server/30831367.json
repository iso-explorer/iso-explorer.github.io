post_cb({"bq_ids": {"n4140": {"so_30831367_30831411_0": {"length": 58, "quality": 0.8787878787878788, "section_id": 5908}}, "n3337": {"so_30831367_30831411_0": {"length": 58, "quality": 0.8787878787878788, "section_id": 5680}}}, "30831367": {"ViewCount": "345", "Body": "<p>I have the following code:</p>\n<pre><code>#include&lt;chrono&gt;\n#include&lt;iostream&gt;\n\nusing namespace std::chrono_literals;\n\n#define MSG \"hello\"\n#define DUR 1000ms\n\nclass mwe{\n    public: \n    static constexpr auto msg = MSG;\n    static constexpr auto dur_1 = DUR;\n    static constexpr std::chrono::milliseconds dur_2 = DUR;\n    static const std::chrono::milliseconds dur_3;\n    static constexpr decltype(DUR) dur_4 = DUR;\n};\n\nconstexpr std::chrono::milliseconds mwe::dur_2; \nconst std::chrono::milliseconds mwe::dur_3 = DUR; \nconstexpr decltype(DUR) mwe::dur_4;\n\nint main(void) {\n    std::cout &lt;&lt; \"str: \" &lt;&lt; mwe::msg &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"dur_1: \" &lt;&lt; mwe::dur_1.count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"dur_2: \" &lt;&lt; mwe::dur_2.count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"dur_3: \" &lt;&lt; mwe::dur_3.count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"dur_4: \" &lt;&lt; mwe::dur_4.count() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>If I compile it (g++ 4.9), via</p>\n<pre><code>g++ -std=c++14 -O2 test.cpp\n</code></pre>\n<p>everything works like expected, but if I compile it via</p>\n<pre><code>g++ -std=c++14 -O0 test.cpp\n</code></pre>\n<p>I get the following Error:</p>\n<pre><code>undefined reference to `mwe::dur_1'\n</code></pre>\n<p>I personally like the way, dur_1 is defined and declared most, but it doesn't work with g++ in my version, if no optimisations are enabled.\nBecause all other ways I know (dur_2, dur_3, dur_4) have their drawbacks (redundancy of the value, no auto type deduction, if I would for example change 1000ms to 1s, aso.)</p>\n<p>Do you know, if this is a gcc bug, that the compilation works on production mode, but doesn't work without optimisation?</p>\n<p>And is there anoter possible way of getting this working, without defining the location for dur_x outside of the class?</p>\n", "AcceptedAnswerId": "30831411", "Title": "undefined reference for static constexpr on g++ 4.9 with no optimisation", "CreationDate": "2015-06-14T15:47:29.630", "Id": "30831367", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-06-14T15:51:35.443", "Score": "2", "OwnerUserId": "4867923", "Tags": "<c++><c++11><gcc><c++14>", "AnswerCount": "1"}, "30831411": {"PostTypeId": "2", "Body": "<p>It is not a bug in your compiler; it is a bug in you.</p>\n<p>You <em>odr-used</em> <code>dur1</code> but never defined it. And, no, neither the <code>constexpr</code> nor the inline initialiser make that declaration a definition.</p>\n<blockquote>\n<p id=\"so_30831367_30831411_0\"><code>[C++11, C++14: 9.4.2/3]:</code> If a non-volatile const <code>static</code> data member is of integral or enumeration type, its declaration in the class definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression (5.19). <strong>A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression.</strong> [ Note: In both these cases, the member may appear in constant expressions. \u2014end note ] <strong>The member shall still be defined in a namespace scope if it is <em>odr-used</em> (3.2) in the program and the namespace scope definition shall not contain an initializer.</strong></p>\n</blockquote>\n<p>As always, optimisation levels may affect the extent to which the compiler is able and/or willing to report such mistakes.</p>\n<p>You may write the following to avoid the so-called \"problems\" you identify:</p>\n<pre><code>#include&lt;chrono&gt;\n\nusing namespace std::chrono_literals;\n\n#define DUR 1000ms\n\nstruct T\n{\n   static constexpr auto dur_1 = DUR;\n};\n\nconstexpr decltype(T::dur_1) T::dur_1;\n</code></pre>\n", "LastActivityDate": "2015-06-14T15:51:35.443", "Id": "30831411", "CommentCount": "3", "CreationDate": "2015-06-14T15:51:35.443", "ParentId": "30831367", "Score": "6", "OwnerUserId": "560648"}});