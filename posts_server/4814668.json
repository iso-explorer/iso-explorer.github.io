post_cb({"4814889": {"ParentId": "4814668", "CommentCount": "7", "CreationDate": "2011-01-27T09:56:17.290", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "4814889", "Score": "5", "Body": "<p>When you do any arithmetic operation on <code>char</code> type, the result it returns is of  <code>int</code> type.</p>\n<p>See this:</p>\n<pre><code>char c = 'A';\ncout &lt;&lt; sizeof(c) &lt;&lt; endl;\ncout &lt;&lt; sizeof(+c) &lt;&lt; endl;\ncout &lt;&lt; sizeof(-c) &lt;&lt; endl;\ncout &lt;&lt; sizeof(c-c) &lt;&lt; endl;\ncout &lt;&lt; sizeof(c+c) &lt;&lt; endl;\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_4814668_4814889_0\">1<br>\n  4<br>\n  4<br>\n  4<br>\n  4  </br></br></br></br></p>\n</blockquote>\n<p>Demonstration at ideone : <a href=\"http://www.ideone.com/jNTMm\" rel=\"noreferrer\">http://www.ideone.com/jNTMm</a></p>\n", "LastActivityDate": "2011-01-27T09:56:17.290"}, "4814756": {"ParentId": "4814668", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-01-27T09:43:29.273", "Score": "3", "LastEditorUserId": "455257", "LastEditDate": "2011-01-27T10:01:50.753", "Id": "4814756", "OwnerUserId": "455257", "Body": "<p>when you are adding these two characters with each other they are first being promoted to int.</p>\n<p><strong>The result of an addition is an rvalue which is implicitly promoted to\ntype int if necessary, and if an int can contain the resulting value.\nThis is true on any platform where sizeof(int) &gt; sizeof(char).\nBut beware of the fact that char might be treated as signed char by\nyour compiler.</strong></p>\n<p>These links can be of further help - <a href=\"http://en.wikipedia.org/wiki/Type_conversion#Type_promotion_in_C-like_languages\" rel=\"nofollow\">wiki</a> and <a href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules\" rel=\"nofollow\">securecoding</a></p>\n", "LastActivityDate": "2011-01-27T10:01:50.753"}, "bq_ids": {"n4140": {"so_4814668_4814901_7": {"section_id": 5943, "quality": 0.8, "length": 4}, "so_4814668_4814901_0": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_4814668_4814901_5": {"section_id": 25, "quality": 0.9512195121951219, "length": 39}, "so_4814668_4814901_1": {"section_id": 5943, "quality": 0.5555555555555556, "length": 45}, "so_4814668_4814901_3": {"section_id": 21, "quality": 0.5625, "length": 18}, "so_4814668_4814901_4": {"section_id": 22, "quality": 0.76, "length": 19}, "so_4814668_4814901_6": {"section_id": 26, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_4814668_4814901_7": {"section_id": 5714, "quality": 0.8, "length": 4}, "so_4814668_4814901_0": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_4814668_4814901_5": {"section_id": 22, "quality": 0.9512195121951219, "length": 39}, "so_4814668_4814901_1": {"section_id": 5714, "quality": 0.5555555555555556, "length": 45}, "so_4814668_4814901_3": {"section_id": 18, "quality": 0.5625, "length": 18}, "so_4814668_4814901_4": {"section_id": 19, "quality": 0.76, "length": 19}, "so_4814668_4814901_6": {"section_id": 23, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_4814668_4814901_7": {"section_id": 7428, "quality": 0.8, "length": 4}, "so_4814668_4814901_0": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_4814668_4814901_5": {"section_id": 25, "quality": 0.9512195121951219, "length": 39}, "so_4814668_4814901_1": {"section_id": 7428, "quality": 0.5555555555555556, "length": 45}, "so_4814668_4814901_3": {"section_id": 21, "quality": 0.5625, "length": 18}, "so_4814668_4814901_4": {"section_id": 22, "quality": 0.76, "length": 19}, "so_4814668_4814901_6": {"section_id": 26, "quality": 0.8571428571428571, "length": 12}}}, "4814901": {"ParentId": "4814668", "CommentCount": "11", "CreationDate": "2011-01-27T09:57:57.483", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "4814901", "Score": "23", "Body": "<p>What you're seeing is the result of the so-called \"usual arithmetic conversions\" that occur during arithmetic expressions, particularly those that are binary in nature (take two arguments).</p>\n<p>This is described in \u00a75/9:</p>\n<blockquote>\n<p id=\"so_4814668_4814901_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield result types in a similar way. The purpose is to yield a common type, which is also the type of the result. This pattern is called the <em>usual arithmetic conversions</em>, which are defined as follows:  </p>\n<p id=\"so_4814668_4814901_1\">\u2014 If either operand is of type <code>long double</code>, the other shall be converted to<code>long double</code>.<br>\n  \u2014 Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.<br>\n  \u2014 Otherwise, if either operand is <code>float</code>, the other shall be converted to <code>float</code>.<br>\n  \u2014 Otherwise, the integral promotions (4.5) shall be performed on both operands.<sup>54)</sup><br>\n  \u2014 Then, if either operand is <code>unsigned long</code> the other shall be converted to <code>unsigned long</code>.<br>\n  \u2014 Otherwise, if one operand is a <code>long int</code> and the other <code>unsigned int</code>, then if a <code>long int</code> can represent all the values of an <code>unsigned int</code>, the <code>unsigned int</code> shall be converted to a <code>long int</code>; otherwise both operands shall be converted to <code>unsigned long\n   int</code>.<br>\n  \u2014 Otherwise, if either operand is <code>long</code>, the other shall be converted to <code>long</code>.<br>\n  \u2014 Otherwise, if either operand is <code>unsigned</code>, the other shall be converted to <code>unsigned</code>.  </br></br></br></br></br></br></br></p>\n<p id=\"so_4814668_4814901_2\">[Note: otherwise, the only remaining case is that both operands are <code>int</code>]</p>\n</blockquote>\n<p>The promotions alluded to in \u00a74.5 are:</p>\n<blockquote>\n<p id=\"so_4814668_4814901_3\">1 An rvalue of type <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short int</code>, or <code>unsigned short int</code>can be converted to an rvalue of type <code>int</code> if <code>int</code> can represent all the values of the source type; otherwise, the source rvalue can be converted to an rvalue of type <code>unsigned int</code>.  </p>\n<p id=\"so_4814668_4814901_4\">2 An rvalue of type <code>wchar_t</code> (3.9.1) or an enumeration type (7.2) can be converted to an rvalue of the first of the following types that can represent all the values of its underlying type: <code>int</code>, <code>unsigned int</code>, <code>long</code>, or <code>unsigned long</code>.  </p>\n<p id=\"so_4814668_4814901_5\">3 An rvalue for an integral bit-field (9.6) can be converted to an rvalue of type <code>int</code> if <code>int</code> can represent all the values of the bit-field; otherwise, it can be converted to <code>unsigned int</code> if <code>unsigned int</code> can represent all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the bit-field has an enumerated type, it is treated as any other value of that type for promotion purposes.  </p>\n<p id=\"so_4814668_4814901_6\">4 An rvalue of type <code>bool</code> can be converted to an rvalue of type <code>int</code>, with <code>false</code> becoming zero and <code>true</code> becoming <code>one</code>.  </p>\n<p id=\"so_4814668_4814901_7\">5 These conversions are called integral promotions.</p>\n</blockquote>\n<p>From here, sections such as \"<strong>Multiplicative operators</strong>\" or \"<strong>Additive operators</strong>\" all have the phrase: \"<em>The usual arithmetic conversions are performed...</em>\" to specify the type of the expression.</p>\n<p>In other words, when you do integral arithmetic the type is determined with the categories above. In your case, the promotion is covered by \u00a74.5/1 and the type of the expressions are <code>int</code>.</p>\n", "LastActivityDate": "2011-01-27T09:57:57.483"}, "4814668": {"CommentCount": "1", "AcceptedAnswerId": "4814901", "PostTypeId": "1", "LastEditorUserId": "431528", "CreationDate": "2011-01-27T09:34:48.837", "LastActivityDate": "2011-05-17T01:22:53.520", "LastEditDate": "2011-05-17T01:22:53.520", "ViewCount": "8931", "FavoriteCount": "6", "Title": "Addition of two chars produces int", "Id": "4814668", "Score": "20", "Body": "<p>I've made a simple program and compiled it with GCC 4.4/4.5 as follows:</p>\n<pre><code>int main ()\n{\n  char u = 10;\n  char x = 'x';\n  char i = u + x;\n\n  return 0;\n}\n</code></pre>\n<p>g++ -c -Wconversion a.cpp</p>\n<p>And I've got the following:</p>\n<pre><code>a.cpp: In function \u2018int main()\u2019:\na.cpp:5:16: warning: conversion to \u2018char\u2019 from \u2018int\u2019 may alter its value\n</code></pre>\n<p>The same warning I've got for the following code:</p>\n<pre><code>  unsigned short u = 10;\n  unsigned short x = 0;\n  unsigned short i = u + x;\n\na.cpp: In function \u2018int main()\u2019:\na.cpp:5:16: warning: conversion to \u2018short unsigned int\u2019 from \u2018int\u2019 may alter its value\n</code></pre>\n<p>Could anyone please explain me why addition of two chars (or two unsigned shorts) produces int? \nIs it a compiler bug or is it standard compliant?</p>\n<p>Thanks.</p>\n", "Tags": "<c++><integer><integer-overflow><integer-promotion>", "OwnerUserId": "465662", "AnswerCount": "3"}});