post_cb({"bq_ids": {"n4140": {"so_33904462_33904463_4": {"length": 37, "quality": 0.925, "section_id": 341}, "so_33904462_33904463_1": {"length": 28, "quality": 0.8484848484848485, "section_id": 304}, "so_33904462_33904463_3": {"length": 52, "quality": 0.8666666666666667, "section_id": 341}}, "n3337": {"so_33904462_33904463_1": {"length": 28, "quality": 0.8484848484848485, "section_id": 295}, "so_33904462_33904463_4": {"length": 37, "quality": 0.925, "section_id": 331}, "so_33904462_33904463_3": {"length": 52, "quality": 0.8666666666666667, "section_id": 331}}, "n4659": {"so_33904462_33904463_1": {"length": 29, "quality": 0.8787878787878788, "section_id": 311}, "so_33904462_33904463_4": {"length": 37, "quality": 0.925, "section_id": 350}, "so_33904462_33904463_3": {"length": 53, "quality": 0.8833333333333333, "section_id": 350}}}, "33904463": {"Id": "33904463", "PostTypeId": "2", "Body": "<h2>Overview</h2>\n<p>It is known that since C++11, a parameter of type <code>T&amp;&amp;</code> is called an <em>rvalue reference</em> [<em>ISO/IEC 14882:2011 \u00a78.3.2/p2 References [dcl.ref]</em> ]. That is, unless <code>T</code> is a template parameter type or <code>auto</code> or a <code>typedef</code> for some lvalue reference type.</p>\n<blockquote>\n<p id=\"so_33904462_33904463_0\">examples:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T&amp;&amp; p) { // -&gt; T is a template parameter\n  ...\n}\n\nauto &amp;&amp;p = expression;\n</code></pre>\n</blockquote>\n<p>Although technically <code>T&amp;&amp;</code> in the examples above is still an rvalue reference, its behaviour differs significantly from a regular one.</p>\n<p>Naturally, you would ask \"why this special case doesn't have a special syntax\". The answer is that the <code>&amp;&amp;</code> syntax was intentionally overloaded for this special construct by the C++ committee. However, they missed to name this special case. </p>\n<p>In the absence of a distinct name for this particular construct, <a href=\"http://www.aristeia.com/\" rel=\"noreferrer\">Scott Meyers</a> coined the widely known term/name <a href=\"https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\" rel=\"noreferrer\"><strong>universal references</strong></a>.</p>\n<p>The committee however, decided that this name is not proper for a number of reasons. As such, the proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf\" rel=\"noreferrer\">N4164</a> made by <a href=\"https://en.wikipedia.org/wiki/Herb_Sutter\" rel=\"noreferrer\">Herb Sutter</a>, <a href=\"https://en.wikipedia.org/wiki/Bjarne_Stroustrup\" rel=\"noreferrer\">Bjarne Stroustrup</a> and <a href=\"http://www.axiomatics.org/~gdr/\" rel=\"noreferrer\">Gabriel Dos Reis</a> proposed to change the name to <strong>Forwarding References</strong>.</p>\n<p>The name <strong>Forwarding References</strong> had the most support in informal discussions among committee members, including the authors of the proposal mentioned earlier. Interestingly enough, it was Scott Meyers himself that introduced that term in his original \u201cUniversal References\u201d talk. However, later he decided to go along with the name <em>universal references</em>. For this decision played role the fact that at the time he didn't think that the term <em>forwarding references</em> included also the <code>auto&amp;&amp;</code> case.</p>\n<h2>Why not <em>universal references</em>?</h2>\n<p>According to the proposal the term <em>Universal references</em> although is a reasonable name with an obvious meaning, it happens to be wrong in several aspects.</p>\n<p>A <em>universal reference</em> must mean the following:</p>\n<ul>\n<li>A reference that can be used everywhere; or</li>\n<li>A reference that can be used for everything; or</li>\n<li>something similar.</li>\n</ul>\n<p>Obviously this is not the case nor is the appropriate use of this construct. Furthermore, this name would encourage many people to consider that something having such a name is meant to be used \"universally\". Something that the committee considered it a bad thing. </p>\n<p>Moreover, \"universal references\" aren\u2019t even really\nreferences per se, but rather a set of rules for using references in a particular way in a particular context with some language support for that use, and <strong>that use is forwarding</strong>.</p>\n<h2>Why <code>auto&amp;&amp;</code> is Also Considered a Forwarding case</h2>\n<p><code>auto&amp;&amp;</code> is also considered a forward case since it follows the <a href=\"http://en.cppreference.com/w/cpp/language/reference\" rel=\"noreferrer\">reference collapsing rules</a>. For example in:</p>\n<ul>\n<li>Generic lambdas of the form,  <code>[](auto&amp;&amp; x){ \u2026 }</code></li>\n<li><code>for</code>-ranged loop of the form, <code>for(auto &amp;&amp;i : v) { ... }</code></li>\n<li>Finally, in general is true that <code>auto&amp;&amp;</code> local variables are for forwarding.</li>\n</ul>\n<h2>Standard Wordings for Forwarding References</h2>\n<p>The term <strong>forwarding references</strong> is mentioned in the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"noreferrer\">draft standard N4527</a> in the following places:</p>\n<p><em>\u00a714.8.2.1/ Deducing template arguments from a function call [temp.deduct.call]</em> <strong>(Emphasis Mine)</strong>:</p>\n<blockquote>\n<p id=\"so_33904462_33904463_1\">If P is a cv-qualified type, the top level cv-qualifiers of P\u2019s type\n  are ignored for type deduction. If P is a reference type, the type\n  referred to by P is used for type deduction. A <strong>forwarding\n  reference</strong> is an rvalue reference to a cv-unqualified template\n  parameter. If P is a <strong>forwarding reference</strong> and the argument is an\n  lvalue, the type \u201clvalue reference to A\u201d is used in place of A for\n  type deduction. [ Example:</p>\n<pre><code>template &lt;class T&gt; int f(T&amp;&amp; heisenreference);\ntemplate &lt;class T&gt; int g(const T&amp;&amp;);\nint i;\nint n1 = f(i); // calls f&lt;int&amp;&gt;(int&amp;)\nint n2 = f(0); // calls f&lt;int&gt;(int&amp;&amp;)\nint n3 = g(i); // error: would call g&lt;int&gt;(const int&amp;&amp;), which\n// would bind an rvalue reference to an lvalue\n</code></pre>\n<p id=\"so_33904462_33904463_2\">\u2014 end example ]</p>\n</blockquote>\n<p><em>\u00a714.8.2.5/p10 Deducing template arguments from a type [temp.deduct.type]:</em></p>\n<blockquote>\n<p id=\"so_33904462_33904463_3\">Similarly, if P has a form that contains (T), then each parameter type\n  Pi of the respective parameter-typelist of P is compared with the\n  corresponding parameter type Ai of the corresponding\n  parameter-type-list of A. If P and A are function types that\n  originated from deduction when taking the address of a function\n  template (14.8.2.2) or when deducing template arguments from a\n  function declaration (14.8.2.6) and Pi and Ai are parameters of the\n  top-level parameter-type-list of P and A, respectively, Pi is adjusted\n  if it is a <strong>forwarding reference</strong> (14.8.2.1) and Ai is an lvalue\n  reference, in which case the type of Pi is changed to be the template\n  parameter type (i.e., T&amp;&amp; is changed to simply T). [ Note: As a\n  result, when Pi is <code>T&amp;&amp;</code> and Ai is <code>X&amp;</code>, the adjusted Pi will be T,\n  causing T to be deduced as <code>X&amp;</code>. \u2014 end note ] [Example:</p>\n<pre><code>template &lt;class T&gt; void f(T&amp;&amp;);\ntemplate &lt;&gt; void f(int&amp;) { } // #1\ntemplate &lt;&gt; void f(int&amp;&amp;) { } // #2\nvoid g(int i) {\nf(i); // calls f&lt;int&amp;&gt;(int&amp;), i.e., #1\nf(0); // calls f&lt;int&gt;(int&amp;&amp;), i.e., #2\n}\n</code></pre>\n<p id=\"so_33904462_33904463_4\">\u2014 end example ] If the parameter-declaration corresponding to Pi is a\n  function parameter pack, then the type of its declaratorid is compared\n  with each remaining parameter type in the parameter-type-list of A.\n  Each comparison deduces template arguments for subsequent positions in\n  the template parameter packs expanded by the function parameter pack.\n  During partial ordering (14.8.2.4), if Ai was originally a function\n  parameter pack:</p>\n</blockquote>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2015-11-25T09:29:58.133", "Score": "27", "CreationDate": "2015-11-24T21:46:17.447", "ParentId": "33904462", "CommentCount": "11", "OwnerUserId": "2352671", "LastEditDate": "2015-11-25T09:29:58.133"}, "33904462": {"ViewCount": "1057", "Body": "<p>I know that if a variable or parameter is declared to have type <code>T&amp;&amp;</code> for some deduced type <code>T</code>, that variable or parameter is widely called a <strong>universal reference</strong>.</p>\n<p>The term <strong>universal reference</strong> was introduced by Scott Meyers in his original talk  <a href=\"https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11\">\u201cUniversal References in C++11\u201d</a>. However, I wonder what's the official/standard term for <strong>universal references</strong>.</p>\n", "AcceptedAnswerId": "33904463", "Title": "What's the standard/official name for universal references?", "CreationDate": "2015-11-24T21:46:17.447", "Id": "33904462", "CommentCount": "0", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-12-09T11:34:36.963", "LastEditorUserId": "3204551", "LastActivityDate": "2015-12-09T11:34:36.963", "Score": "22", "OwnerUserId": "2352671", "Tags": "<c++><c++11><c++14><universal-reference><forwarding-reference>", "AnswerCount": "1"}});