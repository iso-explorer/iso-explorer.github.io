post_cb({"bq_ids": {"n4140": {"so_15497004_15497032_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 603}, "so_15497004_15497032_0": {"length": 18, "quality": 0.9, "section_id": 603}, "so_15497004_15497032_1": {"length": 6, "quality": 0.75, "section_id": 603}, "so_15497004_15497032_5": {"length": 42, "quality": 0.9767441860465116, "section_id": 161}, "so_15497004_15497032_3": {"length": 5, "quality": 1.0, "section_id": 111}, "so_15497004_15497032_2": {"length": 25, "quality": 0.9259259259259259, "section_id": 603}}, "n3337": {"so_15497004_15497032_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 593}, "so_15497004_15497032_0": {"length": 18, "quality": 0.9, "section_id": 593}, "so_15497004_15497032_1": {"length": 6, "quality": 0.75, "section_id": 593}, "so_15497004_15497032_5": {"length": 42, "quality": 0.9767441860465116, "section_id": 155}, "so_15497004_15497032_3": {"length": 5, "quality": 1.0, "section_id": 106}, "so_15497004_15497032_2": {"length": 25, "quality": 0.9259259259259259, "section_id": 593}}, "n4659": {"so_15497004_15497032_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 629}, "so_15497004_15497032_0": {"length": 18, "quality": 0.9, "section_id": 629}, "so_15497004_15497032_1": {"length": 6, "quality": 0.75, "section_id": 629}, "so_15497004_15497032_5": {"length": 42, "quality": 0.9767441860465116, "section_id": 165}, "so_15497004_15497032_3": {"length": 5, "quality": 1.0, "section_id": 115}, "so_15497004_15497032_2": {"length": 25, "quality": 0.9259259259259259, "section_id": 629}}}, "15497004": {"ViewCount": "637", "Body": "<p>Given the following code : </p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nvoid test(T &amp; value) {\n  cout &lt;&lt; \"most generic\" &lt;&lt; endl;\n}\n\ntemplate&lt;typename T&gt;\nvoid test(shared_ptr&lt;T&gt; &amp; value) {\n  cout &lt;&lt; \"shared_ptr\" &lt;&lt; endl;\n}\n\nclass A {};\n\nint main(int argc, char ** argv) {\n  A a;\n  shared_ptr&lt;A&gt; p(new A());\n  test(a);\n  test(p);\n  return 0;\n}\n</code></pre>\n<p>Why is the call </p>\n<pre><code>test(p)\n</code></pre>\n<p>instantiating the second form of test with T = A instead of complaining that it cannot distinguish between the two signatures ?</p>\n", "AcceptedAnswerId": "15497032", "Title": "C++ template selection", "CreationDate": "2013-03-19T10:31:30.710", "Id": "15497004", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-03-23T10:32:18.527", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-23T10:32:18.527", "Score": "9", "OwnerUserId": "1121403", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}, "15497032": {"Id": "15497032", "PostTypeId": "2", "Body": "<p>Because even though they are both viable choices for overload resolution, the second function template is <em>more specialized</em> than the first one.</p>\n<p>Per Paragraph 13.3.3/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15497004_15497032_0\">[...] Given these definitions, a viable function F1 is defined to be a <strong>better</strong> function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_15497004_15497032_1\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p>\n<p id=\"so_15497004_15497032_2\">\u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type. [...] or, if not that,</p>\n<p id=\"so_15497004_15497032_3\">\u2014 F1 is a non-template function and F2 is a function template specialization, or, if not that,</p>\n<p id=\"so_15497004_15497032_4\">\u2014 F1 and F2 are function template specializations, and <strong>the function template for F1 is more specialized\n  than the template for F2</strong> according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>\u00a7 14.5.6.2 then says how a function template is determined to be more specialized than another function template. In particular, per 14.5.6.2/2:</p>\n<blockquote>\n<p id=\"so_15497004_15497032_5\">Partial ordering selects which of two function templates is more specialized than the other by transforming\n  each template in turn (see next paragraph) and performing template argument deduction using the function\n  type. The deduction process determines whether one of the templates is more specialized than the other. If\n  so, the more specialized template is the one chosen by the partial ordering process.</p>\n</blockquote>\n<p>Formal definitions in the Standard can be pretty hard to decipher, but their complexity is normally meant to <strong>unambiguously make the language behave like we would naturally expect</strong> in <em>most</em> situations.</p>\n<p>The intuitive expectations we could have about the overloads you provide is that the one accepting a <code>std::shared_ptr&lt;T&gt;</code> should be selected when the argument is of type <code>std::shared_ptr&lt;int&gt;</code>, because it appears to be dealing with <code>std::shared_ptr&lt;&gt;</code> objects specifically and, therefore, it looks like a better (<em>more specialized</em>) candidate than the unconstrained overload.</p>\n<p>The formal procedure for translating this intuitive expectation into an unambiguous set of rules may sound complex, but following it is not particularly hard in our situation, where we want to determine if this overload:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(std::shared_ptr&lt;T&gt;);\n</code></pre>\n<p>Is more specialized than this:</p>\n<pre><code>template&lt;typename U&gt;\nvoid f(U);\n</code></pre>\n<p>Although in this case it is easy for us to tell which one is more specialized just based on our intuition, a compiler must rely on an <em>algorithm</em>, and this algorithm must work in all situations. </p>\n<p>In this case, the mechanism would go as follows:</p>\n<ol>\n<li>Take the <em>first</em> overload, substitute its template parameter <code>T</code> for a type argument (<em>any</em> type argument), for instance <code>int</code>, and instantiate the corresponding signature - the function parameter would have type <code>std::shared_ptr&lt;int&gt;</code>;</li>\n<li>Is it always possible to call the <em>second</em> overload by providing an object of that type (<code>shared_ptr&lt;int&gt;</code> in this case) as its input, and deduce the type <code>U</code> from it?</li>\n<li>Well, the answer is <strong>Yes</strong>. <code>U</code> will just be deduced to be <code>std::shared_ptr&lt;int&gt;</code>;</li>\n<li>The other way round now: Take the <em>second</em> overload, substitute its template parameter <code>U</code> for any type argument, for instance <code>bool</code>, and instantiate the corresponding signature - the function parameter would have type <code>bool</code>;</li>\n<li>Is it always possible to call the <em>first</em> overload by providing an object of that type (<code>bool</code>) as its argument and deduce the type <code>T</code> from it?</li>\n<li>The answer here is <strong>No</strong>, of course. There is no way to deduce <code>T</code> so that <code>std::shared_ptr&lt;T&gt;</code> would match <code>bool</code>;</li>\n<li>Conclusion: <strong>The first overload is more specialized than the second</strong>.</li>\n</ol>\n<p>Of course, things get slightly more complicated when there is more than one template parameter and more than one function parameter, but the mechanism is pretty much the same.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-19T11:59:15.353", "Score": "18", "CreationDate": "2013-03-19T10:32:39.543", "ParentId": "15497004", "CommentCount": "2", "OwnerUserId": "1932150", "LastEditDate": "2013-03-19T11:59:15.353"}});