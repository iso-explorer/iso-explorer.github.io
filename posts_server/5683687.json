post_cb({"5683771": {"ParentId": "5683687", "CommentCount": "2", "Body": "<p><sub>Only speculation, totally not sure. :)</sub></p>\n<pre><code>[ Example:\nstruct A { int x; }; // S(x,A) = { { A::x }, { A } }\nstruct B { float x; }; // S(x,B) = { { B::x }, { B } }\nstruct C: public A, public B { }; // S(x,C) = { invalid, { A in C, B in C } }\nstruct D: public virtual C { }; // S(x,D) = S(x,C)\nstruct E: public virtual C { char x; }; // S(x,E) = { { E::x }, { E } }\nstruct F: public D, public E { }; // S(x,F) = S(x,E)\nint main() {\nF f;\nf.x = 0; // OK, lookup finds E::x\n}\nS(x, F) is unambiguous because the A and B base subobjects of D are also base subobjects of E, so S(x,D)\nis discarded in the first merge step. \u2014end example ]\n</code></pre>\n<p>Is the example from 10.2p7, where <code>S(f,C)</code> denotes the lookup set. The sentence provided at the end is essential: Since both <code>D</code> and <code>E</code> have the same <code>C</code> base class, and <code>E::x</code> <em>hides</em> the <code>x</code> from that <code>C</code>, making the final use of <code>F::x</code> unambigiuous.<br>\nNow, in your example, nothing hides the <code>f</code> of the base classes of <code>D</code>, so the use of <code>D::f</code> is still ambigiuous and I can't see how 10.2p7 applies to your case. Like said at the top, totally not sure. ;)</br></p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "5683771", "Score": "0", "CreationDate": "2011-04-16T01:05:56.993", "LastActivityDate": "2011-04-16T01:05:56.993"}, "5684366": {"ParentId": "5683687", "CommentCount": "4", "Body": "<p>Instead of addressing the question directly, I'm going to try to argue that pretending there exist <code>f</code> functions in each of the derived classes doesn't work:</p>\n<p>There's only one candidate function, and it has type</p>\n<pre><code>void A::(void)\n</code></pre>\n<p>Although you can form a pointer-to-member to that function with</p>\n<pre><code>void (A::*F0)(void) = &amp;A::f;\nvoid (B::*F1)(void) = F0;\nvoid (C::*F2)(void) = F0;\n</code></pre>\n<p>This is because the pointer-to-member contains additional information necessary to calculate the parameter of the function.  The pointer-to-member call site finds an <code>A</code> subobject of the actual target instance, to provide the <code>this</code> pointer of <code>f</code>.  There's no logic inside the function to find A's members from a <code>this</code> pointer of derived type.  So one can't talk about <code>void F1(B* this)</code> and <code>void F2(C* this)</code> as your question suggests.</p>\n<p>If the functions are considered members of the derived class, it is as</p>\n<pre><code>void B::A::f(void);\nvoid C::A::f(void);\n</code></pre>\n<p>But as <code>B::A</code> and <code>C::A</code> are the same base class, ultimately there is only one function in the candidate list, although it is in the list twice.  Then virtual inheritance provides that both candidates are calling the same function on the same object, there is no ambiguity.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "5684366", "Score": "0", "CreationDate": "2011-04-16T04:00:12.350", "LastActivityDate": "2011-04-16T04:00:12.350"}, "5683687": {"CommentCount": "0", "ViewCount": "675", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-04-16T00:43:54.210", "LastActivityDate": "2011-10-03T13:12:24.630", "Title": "C++0x confusion with using declarations", "FavoriteCount": "3", "LastEditDate": "2011-10-03T13:12:24.630", "Id": "5683687", "Score": "15", "Body": "<p>What should happen for this case:</p>\n<pre><code>struct A {\n  void f();\n};\n\nstruct B : virtual A {\n  using A::f;\n};\n\nstruct C : virtual A {\n  using A::f;\n};\n\nstruct D : B, C { \n  void g() {\n    f();\n  }\n};\n</code></pre>\n<p>The line of interest is  <code>f()</code>. Clearly the lookup of <code>f</code> according to <code>10.2</code> of the FDIS succeeds and finds <code>A::f</code>. However, what candidates will overload resolution consider? The spec says at <code>13.3.1p4</code>:</p>\n<blockquote>\n<p id=\"so_5683687_5683687_0\">For non-conversion functions introduced by a using-declaration into a derived class, the function is considered to be a member of the derived class for the purpose of defining the type of the implicit object parameter. </p>\n</blockquote>\n<p>The intent of this is that for a single class, if such a class contains both own member functions and a using declaration bringing names of base class functions into scope, that during overload resolution all the function candidates have the same class type in their implicit object parameter. But what does this mean for the above example? Will the candidates be the following?</p>\n<pre><code>void F1(B&amp;)\nvoid F2(C&amp;)\n// call arguments: (lvalue D)\n</code></pre>\n<p>This appears to be wrong, because we only have one declaration in the lookup result set according to <code>10.2p7</code>. How shall we interpret this??</p>\n", "Tags": "<c++><c++11><overload-resolution><using-declaration>", "OwnerUserId": "34509", "AnswerCount": "4"}, "5688335": {"ParentId": "5683687", "CommentCount": "0", "Body": "<p>I think the key is in 10.2p5, where the standard refers to checking each \"direct base class subobject\".</p>\n<p>Because <code>A</code> is inherited virtually, it is a \"direct base class subobject\" of <code>D</code> (10.1p4).</p>\n<p>Then three subobjects of <code>D</code> are considered: <code>A</code>, <code>B</code>, and <code>C</code>.  By 10.2p6 <code>B</code> and <code>C</code> are eliminated (<code>A</code> is a base of these), and only <code>A::f</code> is a candidate.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "5688335", "Score": "0", "CreationDate": "2011-04-16T17:38:41.053", "LastActivityDate": "2011-04-16T17:38:41.053"}, "5683867": {"ParentId": "5683687", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2011-04-16T01:30:31.627", "Score": "1", "LastEditorUserId": "179910", "LastEditDate": "2011-04-16T02:10:33.463", "Id": "5683867", "OwnerUserId": "179910", "Body": "<p>I think that since the lookup set resulting from 10.2/7 results in only one declaration, there's no function overloading present at all. 13.3.1/4 would only apply when/if the lookup set resulting from 10.2/7 contained two or more declarations.</p>\n<p>Edit: Perhaps I wasn't as clear as I'd hoped. Even if <code>f</code> is overloaded in <code>A</code>, I think most of the same reasoning applies. Perhaps it's best to take things step by step. (Note, that in this case, I'm using the same S(f, X) notation as the standard, but since your most derived class is D, your S(f, D) corresponds to their S(f, C), and your S(f, B) ans S(f, C) correspond to its S(f, B<sub>1</sub>) and S(f, B<sub>2</sub>).</p>\n<p>First s(f, D) is empty, because we have no declaration of f directly contained in D. Based on that, we get to 10.2/5.</p>\n<p>In 10.2/6, we start by merging s(f, B) into S(f, D). Since s(f, D) is currently empty, we follow the second condition under the first bullet point, and S(f, D) becomes a copy of S(f, B).</p>\n<p>Then we have to merge S(f, C) into S(f, D). In this case, each of the subobject members of S(f, C) is a subobject member of S(f, D). This satisfies the first condition of the first bullet point, so we leave S(f, D) unchanged, and the merge is complete.</p>\n<p>At that point, there are no more base classes B<sub>i</sub> to consider, so our S(f, D) = S(f, B). <em>None</em> of the declarations from S(f, C) is present in the final overload set <em>at all</em>.</p>\n<p>Then, if S(f, B) contained two or more functions, we proceed to 13.3.1, and resolve the overload set -- but since the entire set came via B, the situation posited in the question simply doesn't exist.</p>\n", "LastActivityDate": "2011-04-16T02:10:33.463"}, "bq_ids": {"n4140": {"so_5683687_5683687_0": {"section_id": 568, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_5683687_5683687_0": {"section_id": 559, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_5683687_5683687_0": {"section_id": 591, "quality": 0.9444444444444444, "length": 17}}}});