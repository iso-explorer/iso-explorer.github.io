post_cb({"bq_ids": {"n4140": {"so_27826824_27826995_0": {"length": 11, "quality": 1.0, "section_id": 675}, "so_27826824_27826824_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 653}, "so_27826824_27826995_1": {"length": 13, "quality": 1.0, "section_id": 582}, "so_27826824_27826995_2": {"length": 40, "quality": 0.9302325581395349, "section_id": 583}}, "n3337": {"so_27826824_27826995_0": {"length": 11, "quality": 1.0, "section_id": 665}, "so_27826824_27826824_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 643}, "so_27826824_27826995_1": {"length": 13, "quality": 1.0, "section_id": 572}, "so_27826824_27826995_2": {"length": 40, "quality": 0.9302325581395349, "section_id": 573}}, "n4659": {"so_27826824_27826995_0": {"length": 11, "quality": 1.0, "section_id": 703}, "so_27826824_27826824_0": {"length": 53, "quality": 0.9814814814814815, "section_id": 681}, "so_27826824_27826995_1": {"length": 13, "quality": 1.0, "section_id": 605}, "so_27826824_27826995_2": {"length": 40, "quality": 0.9302325581395349, "section_id": 606}}}, "27826824": {"ViewCount": "151", "Body": "<p>Well, maybe it is not so surprising. Stackoverflow has a lot of questions and contributions to that point. Only they are not EXACTLY to the point.</p>\n<p>Here an extract from the C++ standard (in fact a c++14 draft, but I assume the passage is the same in current C++11 standard):</p>\n<blockquote>\n<p id=\"so_27826824_27826824_0\">An operator function shall either be a non-static member function or be a non-member function that has\n  at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an\n  enumeration. It is not possible to change the precedence, grouping, or number of operands of operators.\n  The meaning of the operators =, (unary) &amp;, and , (comma), predefined for each type, can be changed for\n  specific class and enumeration types by defining operator functions that implement these operators. Operator\n  functions are inherited in the same manner as other base class functions.</p>\n</blockquote>\n<p>Thus, to my understanding, it is perfectly legal to have 1 class type and one non-class type as parameters to operator&gt;&gt;(,). The standard does not say \"The first\" or \"The second\" parameter. Just \"One\" of them must be a class type.</p>\n<p>Here a code snippet which surprises me:</p>\n<pre><code>int operator&gt;&gt; ( int v, std::function&lt;int(int)&gt; transformer )\n{\n    int v1 = transformer(v);\n    DGS::CLogger::GetLogger()-&gt;Log&lt;int&gt;(&amp;IntFormatter, v1 );\n    return v1;\n}\nstatic int DoItLoggedAndCompact( int value )\n{\n    int x = operator&gt;&gt;( operator&gt;&gt;(value, DoIt) , AnotherIntCalculation ); // compiles and works!\n    return x;\n// The following line produces (with clang++):\n// error: invalid operands to binary expression ('int' and 'int (*)(int)')\n//      return value &gt;&gt; DoIt &gt;&gt; AnotherIntCalculation; : \n}\n</code></pre>\n<p>Please note that \"A function pointer is not a class type\", while being a correct statement, is not a comprehensive answer. As you see in the rewritten code starting with <code>int x = ...</code> and the definition of operator&gt;&gt; second parameter, the function pointer is silently converted to a std::function.</p>\n<p>I cannot find anywhere in the standard a passage which states, that the conversion rules for those two (allegedly) synonymous forms differ.</p>\n<p>So, is this a compiler bug, a community wide over-interpretation of the C++ specification or...something else we see here? Or simply some stupid oversight on my part?</p>\n", "AcceptedAnswerId": "27826995", "Title": "operator>>(,) overload behaving in a surprising way", "CreationDate": "2015-01-07T19:09:06.573", "Id": "27826824", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-01-07T19:35:08.823", "Score": "5", "OwnerUserId": "2225104", "Tags": "<c++><overloading>", "AnswerCount": "1"}, "27826995": {"Id": "27826995", "PostTypeId": "2", "Body": "<p>But <strong>\"A function pointer is not a class type\"</strong> <em>is</em> the correct answer.</p>\n<p>There's the following note in clause 13.6:</p>\n<blockquote>\n<p id=\"so_27826824_27826995_0\">operator overload resolution occurs only when an operand expression originally has class\n  or enumeration type</p>\n</blockquote>\n<p>The normative rule is in 13.3.1.2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_27826824_27826995_1\">If no operand of an operator in an expression has a type that is a class or an enumeration,  the operator is assumed to be a built-in operator and interpreted according to Clause 5.</p>\n<p id=\"so_27826824_27826995_2\"><strong>If either operand has a type that is a class or an enumeration</strong>, a user-de\ufb01ned operator function might be declared that implements this operator or a user-de\ufb01ned conversion can be necessary to convert the operand to a type that is appropriate for a built-in operator.  In this case, overload resolution is used to determine which  operator  function  or  built-in  operator  is  to  be  invoked  to  implement  the  operator.   Therefore,  <strong>the operator notation is first transformed to the equivalent function-call notation</strong> as summarized in Table 11.</p>\n</blockquote>\n<p>The forms are synonymous only when one of the operands is a class type.  Since neither one is here, the rewrite as <code>operator&gt;&gt;()</code> doesn't occur.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2015-01-07T19:35:08.823", "Score": "6", "CreationDate": "2015-01-07T19:19:10.410", "ParentId": "27826824", "CommentCount": "18", "LastEditDate": "2015-01-07T19:35:08.823", "OwnerUserId": "103167"}});