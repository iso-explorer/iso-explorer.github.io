post_cb({"29654728": {"CommentCount": "2", "AcceptedAnswerId": "29654925", "PostTypeId": "1", "LastEditorUserId": "1013719", "CreationDate": "2015-04-15T15:42:40.060", "LastActivityDate": "2015-04-15T18:32:43.807", "LastEditDate": "2015-04-15T18:30:04.210", "ViewCount": "895", "FavoriteCount": "0", "Title": "What does the C++ standard say about std::vector<int> v1,v2; std::distance(v1.begin(),v2.begin())?", "Id": "29654728", "Score": "27", "Body": "<p>I have this code</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char* argv[])\n{\n   std::vector&lt;int&gt; v1,v2;\n   std::cout &lt;&lt; std::distance(v1.begin(),v2.begin());\n   return 0;\n}\n</code></pre>\n<p>and it has a bug because it is not meaningful to compare the iterators of two different vectors.</p>\n<p>I had a look at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\">N3376</a> at <em>24.4.4 Iterator operations</em> at page 815:</p>\n<blockquote>\n<pre><code>template&lt;class InputIterator&gt;\ntypename iterator_traits&lt;InputIterator&gt;::difference_type\ndistance(InputIterator first, InputIterator last);\n</code></pre>\n<p id=\"so_29654728_29654728_0\"><em>Requires</em>: If <code>InputIterator</code> meets the requirements of random access iterator, <code>last</code> shall be reachable from <code>first</code> or <code>first</code> shall be\n  reachable from <code>last</code>; otherwise, <code>last</code> shall be reachable from\n  <code>first</code>.</p>\n</blockquote>\n<p>Now I think that <em>Requires</em> is not fulfilled.</p>\n<p>What does the standard state should happen in this case?</p>\n", "Tags": "<c++><iterator><standards><language-lawyer><c++-standard-library>", "OwnerUserId": "15485", "AnswerCount": "4"}, "29654949": {"ParentId": "29654728", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In this case will be undefined behavior. Because <code>last</code> is not reachable from <code>first</code> by (possibly repeatedly) incrementing <code>first</code>.</p>\n", "OwnerUserId": "3207189", "LastEditorUserId": "15485", "LastEditDate": "2015-04-15T18:32:43.807", "Id": "29654949", "Score": "3", "CreationDate": "2015-04-15T15:50:31.677", "LastActivityDate": "2015-04-15T18:32:43.807"}, "29654925": {"ParentId": "29654728", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>[iterator.requirements.general]:</p>\n<blockquote>\n<p id=\"so_29654728_29654925_0\">An iterator <code>j</code> is called <em>reachable</em> from an iterator <code>i</code> if and only\n  if there is a finite sequence of applications of  the expression <code>++i</code>\n  that makes <code>i == j</code>. </p>\n</blockquote>\n<p>The problem is that once you incremented <code>v1.begin()</code> <code>v1.size()-1</code> times, the next increment operation induces undefined behavior, so <code>v2.begin()</code> cannot be reached from <code>v1.begin()</code>. The same argument makes <code>v1.begin()</code> unreachable from <code>v2.begin()</code>.</p>\n<hr>\n<p>In case your question was \"What happens if a condition in a <em>Requires</em> section is violated?\", look at [res.on.required]:</p>\n<blockquote>\n<p id=\"so_29654728_29654925_1\">Violation of the preconditions specified in a function\u2019s <em>Requires:</em>\n  paragraph results in undefined behavior unless the function\u2019s <em>Throws:</em>\n  paragraph specifies throwing an exception when the precondition is\n  violated.</p>\n</blockquote>\n</hr>", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-15T15:54:47.630", "Id": "29654925", "Score": "28", "CreationDate": "2015-04-15T15:49:34.083", "LastActivityDate": "2015-04-15T15:54:47.630"}, "29654844": {"ParentId": "29654728", "CommentCount": "0", "Body": "<p>The <code>requires</code> is not met, which means the code has undefined behavior: Anything could happen.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "29654844", "Score": "3", "CreationDate": "2015-04-15T15:46:50.303", "LastActivityDate": "2015-04-15T15:46:50.303"}, "29655566": {"ParentId": "29654728", "CommentCount": "0", "Body": "<p>In some implementations of <code>std::distance</code>, the first iterator is incremented until it reaches the second iterator.  The iterations are counted:  </p>\n<pre><code>unsigned int counts = 0;\nwhile (iter1 != iter2)\n{\n  ++counts;\n  ++iter1;\n}\n</code></pre>\n<p>If the iterators point to containers in different address spaces, the loop many not terminate.  Using the terms in the standard, the second iterator is not <em>reachable</em>.  </p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "29655566", "Score": "5", "CreationDate": "2015-04-15T16:18:38.753", "LastActivityDate": "2015-04-15T16:18:38.753"}, "bq_ids": {"n4140": {"so_29654728_29654925_1": {"section_id": 6328, "quality": 0.8888888888888888, "length": 16}, "so_29654728_29654925_0": {"section_id": 5560, "quality": 0.9, "length": 9}, "so_29654728_29654728_0": {"section_id": 5597, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_29654728_29654925_1": {"section_id": 6085, "quality": 0.8888888888888888, "length": 16}, "so_29654728_29654728_0": {"section_id": 5380, "quality": 0.9411764705882353, "length": 16}, "so_29654728_29654925_0": {"section_id": 5342, "quality": 0.9, "length": 9}}, "n4659": {"so_29654728_29654925_1": {"section_id": 7838, "quality": 0.8888888888888888, "length": 16}, "so_29654728_29654728_0": {"section_id": 7041, "quality": 0.9411764705882353, "length": 16}, "so_29654728_29654925_0": {"section_id": 7007, "quality": 0.9, "length": 9}}}});