post_cb({"bq_ids": {"n4140": {"so_20559603_20559713_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3913}}, "n3337": {"so_20559603_20559713_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3773}}}, "20559603": {"ViewCount": "404", "Body": "<p>In the following code I am not allowed to declare an <em>explicit</em> ctor because the compiler says I am using it in a <em>copy-initializing</em> context (clang 3.3 and gcc 4.8).\nI try to prove the compilers wrong by making the ctor non explicit and then declaring the copy constructors as deleted.</p>\n<p>Are the compilers wrong or is there any other explanation?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct xyz\n{\n    constexpr xyz (xyz const &amp;)    = delete;\n    constexpr xyz (xyz &amp;&amp;)         = delete;\n    xyz &amp; operator = (xyz const &amp;) = delete;\n    xyz &amp; operator = (xyz &amp;&amp;)      = delete;\n    T i;\n    /*explicit*/ constexpr xyz (T i): i(i) { }\n};\n\ntemplate &lt;typename T&gt;\nxyz&lt;T&gt; make_xyz (T &amp;&amp; i)\n{\n    return {std::forward&lt;T&gt;(i)};\n}\n\nint main ()\n{\n    //auto &amp;&amp; x = make_xyz(7);\n    auto &amp;&amp; x (make_xyz(7)); // compiler sees copy-initialization here too\n    std::cout &lt;&lt; x.i &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>Update</strong> An unrealistic but much simpler version</p>\n<pre><code>struct xyz {\n    constexpr xyz (xyz const &amp;) = delete;\n    constexpr xyz (xyz &amp;&amp;) = delete;\n    xyz &amp; operator = (xyz const &amp;) = delete;\n    xyz &amp; operator = (xyz &amp;&amp;) = delete;\n    int i;\n    explicit constexpr xyz (int i): i(i) { }\n};\n\nxyz make_xyz (int &amp;&amp; i) {\n    return {i};\n}\n\nint main () {\n    xyz &amp;&amp; x = make_xyz(7); \n}\n</code></pre>\n", "AcceptedAnswerId": "20559713", "Title": "This is not copy-initializing, or is it?", "CreationDate": "2013-12-13T05:18:26.407", "Id": "20559603", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-12-13T14:39:16.503", "LastEditorUserId": "2712726", "LastActivityDate": "2013-12-13T14:39:16.503", "Score": "7", "OwnerUserId": "2712726", "Tags": "<c++><c++11><explicit-constructor><copy-initialization>", "AnswerCount": "1"}, "20559713": {"Id": "20559713", "PostTypeId": "2", "Body": "<p>The <code>=</code> notation should not affect the complaint because reference binding doesn't behave differently whether expressed by direct- or copy-initialization. What's being initialized here is the return value object, which does not have its own name.</p>\n<p>Unfortunately, GCC is right to complain, as does Clang. According to \u00a76.6.3/2 [stmt.return],</p>\n<blockquote>\n<p id=\"so_20559603_20559713_0\">A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n</blockquote>\n<p>So, there is an invisible <code>=</code> sign there and you can't get around it.</p>\n", "CommentCount": "6", "LastEditorUserId": "153285", "LastActivityDate": "2013-12-13T05:34:31.633", "CreationDate": "2013-12-13T05:28:50.560", "ParentId": "20559603", "Score": "7", "OwnerUserId": "153285", "LastEditDate": "2013-12-13T05:34:31.633"}});