post_cb({"bq_ids": {"n4140": {"so_1613341_1613383_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 3286}, "so_1613341_1613383_2": {"length": 22, "quality": 0.5365853658536586, "section_id": 3287}, "so_1613341_1613383_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 3285}}, "n3337": {"so_1613341_1613383_1": {"length": 21, "quality": 0.875, "section_id": 3156}, "so_1613341_1613383_2": {"length": 30, "quality": 0.7317073170731707, "section_id": 3157}, "so_1613341_1613383_0": {"length": 39, "quality": 1.0, "section_id": 3155}}, "n4659": {"so_1613341_1613383_1": {"length": 16, "quality": 0.6666666666666666, "section_id": 4049}, "so_1613341_1613383_2": {"length": 21, "quality": 0.5121951219512195, "section_id": 4049}, "so_1613341_1613383_0": {"length": 35, "quality": 0.8974358974358975, "section_id": 4047}}}, "1613383": {"Id": "1613383", "PostTypeId": "2", "Body": "<p>C++03 Standard 8.5/5:</p>\n<blockquote>\n<p id=\"so_1613341_1613383_0\">To <strong><em>zero-initialize</em></strong> an object of type T means:<br>\n  \u2014 if T is a scalar type (3.9), the object is set to the value of 0 (zero) converted to T;<br>\n  \u2014 if T is a non-union class type, each nonstatic data member and each base-class subobject is zero-initialized;<br>\n  \u2014 if T is a union type, the object\u2019s first named data member is zero-initialized;<br>\n  \u2014 if T is an array type, each element is zero-initialized;<br>\n  \u2014 if T is a reference type, no initialization is performed.  </br></br></br></br></br></p>\n<p id=\"so_1613341_1613383_1\">To <strong><em>default-initialize</em></strong> an object of type T means:<br>\n  \u2014 if T is a non-POD class type (clause 9), the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);<br>\n  \u2014 if T is an array type, each element is default-initialized;<br>\n  \u2014  otherwise, the object is zero-initialized. </br></br></br></p>\n<p id=\"so_1613341_1613383_2\">To <strong><em>value-initialize</em></strong> an object of type T means:<br>\n  \u2014 if T is a class type (clause 9) with a user-declared constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);<br>\n  \u2014 if T is a non-union class type without a user-declared constructor, then every non-static data member and base-class component of T is value-initialized;<br>\n  \u2014 if T is an array type, then each element is value-initialized;<br>\n  \u2014  otherwise, the object is zero-initialized</br></br></br></br></p>\n<p id=\"so_1613341_1613383_3\">A program that calls for default-initialization or value-initialization of an entity of reference type is ill-formed. If T is a cv-qualified type, the cv-unqualified version of T is used for these definitions of zero-initialization, default-initialization, and value-initialization.  </p>\n</blockquote>\n", "LastActivityDate": "2009-10-23T13:20:55.977", "CommentCount": "2", "CreationDate": "2009-10-23T13:20:55.977", "ParentId": "1613341", "Score": "76", "OwnerUserId": "123111"}, "1613341": {"ViewCount": "25286", "Body": "<p>What do the following phrases mean in C++:</p>\n<ul>\n<li><p>zero-initialization,</p></li>\n<li><p>default-initialization, and</p></li>\n<li><p>value-initialization</p></li>\n</ul>\n<p>What should a C++ developer know about them?</p>\n", "AcceptedAnswerId": "1613578", "Title": "What do the following phrases mean in C++: zero-, default- and value-initialization?", "CreationDate": "2009-10-23T13:14:45.477", "Id": "1613341", "CommentCount": "2", "FavoriteCount": "106", "PostTypeId": "1", "LastEditDate": "2016-03-10T19:27:01.290", "LastEditorUserId": "3777958", "LastActivityDate": "2016-03-10T19:27:01.290", "Score": "153", "OwnerUserId": "26449", "Tags": "<c++><initialization><c++-faq>", "AnswerCount": "2"}, "1613578": {"Id": "1613578", "PostTypeId": "2", "Body": "<p>One thing to realize is that 'value-initialization' is new with the C++ 2003 standard - it doesn't exist in the original 1998 standard (I think it might be the only difference that's more than a clarification).  See <a href=\"https://stackoverflow.com/questions/1613341/what-do-the-following-phrases-mean-in-c-zero-default-and-value-initializati/1613383#1613383\">Kirill V. Lyadvinsky's answer</a> for the definitions straight from the standard.</p>\n<p>See this previous answer about the behavior of <code>operator new</code> for details on the the different behavior of these type of initialization and when they kick in (and when they differ from c++98 to C++03):</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/620137/syntax-of-new/620402#620402\">Do the parentheses after the type name make a difference with new?</a></li>\n</ul>\n<p>The main point of the answer is:</p>\n<blockquote>\n<p id=\"so_1613341_1613578_0\">Sometimes the memory returned by the new operator will be initialized, and sometimes it won't depending on whether the type you're newing up is a POD, or if it's a class that contains POD members and is using a compiler-generated default constructor.</p>\n<ul>\n<li>In C++1998 there are 2 types of initialization: zero and default</li>\n<li>In C++2003 a 3rd type of initialization, value initialization was added.</li>\n</ul>\n</blockquote>\n<p>To say they least, it's rather complex and when the different methods kick in are subtle.</p>\n<p>One thing to certainly be aware of is that MSVC follows the C++98 rules, even in VS 2008 (VC 9 or cl.exe version 15.x).</p>\n<p>The following snippet shows that MSVC and Digital Mars follow C++98 rules, while GCC 3.4.5 and Comeau follow the C++03 rules:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;new&gt;\n\nstruct A { int m; }; // POD\nstruct B { ~B(); int m; }; // non-POD, compiler generated default ctor\nstruct C { C() : m() {}; ~C(); int m; }; // non-POD, default-initialising m\n\nint main()\n{\n    char buf[sizeof(B)];\n    memset( buf, 0x5a, sizeof( buf));\n\n    // use placement new on the memset'ed buffer to make sure \n    //  if we see a zero result it's due to an explicit \n    //  value initialization\n    B* pB = new(buf) B();   //C++98 rules - pB-&gt;m is uninitialized\n                            //C++03 rules - pB-&gt;m is set to 0\n    printf( \"m  is %d\\n\", pB-&gt;m);\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2009-10-23T14:26:19.170", "Score": "54", "CreationDate": "2009-10-23T13:48:46.657", "ParentId": "1613341", "CommentCount": "6", "OwnerUserId": "12711", "LastEditDate": "2017-05-23T12:10:44.930"}});