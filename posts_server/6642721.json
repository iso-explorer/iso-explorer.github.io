post_cb({"6644062": {"Id": "6644062", "PostTypeId": "2", "Body": "<p>The name before the scope operator <code>::</code> must always be a namespace or class (or enumeration) name, and namespace names can't be dependent.  So you don't have to tell the compiler that this is a class name.</p>\n<hr>\n<p>I'm not just making this up, the standard says (section <code>[temp.res]</code>):</p>\n<blockquote>\n<p id=\"so_6642721_6644062_0\">A qualified name used as the name in a mem-initializer-id, a base-specifier, or an elaborated-type-specifier is implicitly assumed to name a type, without the use of the <code>typename</code> keyword. In a <em>nested-name-specifier</em> that immediately contains a <em>nested-name-specifier</em> that depends on a template parameter, the identifier or simple-template-id is implicitly assumed to name a type, without the use of the <code>typename</code> keyword. [ Note:\n  The <code>typename</code> keyword is not permitted by the syntax of these constructs.  \u2014 end note ]</p>\n</blockquote>\n<p><code>T::</code>, <code>T::Type::</code>, and <code>T::Type::Type::</code> are <em>nested-name-specifiers</em>, they do not need to be marked with <code>typename</code>.</p>\n<p>This section clearly could have, and arguably should have, included the <em>type-specifier</em> of a typedef declaration in the list of exemptions.  But remember that <em>type-specifiers</em> can get really complicated, especially in typedef declarations.  Right now it's quite possible to need the <code>typename</code> keyword multiple times in a typedef <em>type-specifier</em>, so a lot more analysis would be needed to convince me that <code>typename</code> is never necessary in a typedef.</p>\n<p>In <code>typedef typename T::Type::Type Type</code>, <code>T::Type::Type</code> requires use of the <code>typename</code> keyword, because its <em>nested-name-specifier</em> (<code>T::Type::</code>) is a dependent name, and the standard says (same section):</p>\n<blockquote>\n<p id=\"so_6642721_6644062_1\">When a qualified-id is intended to refer to a type that is not a member of the current instantiation (14.6.2.1) and its nested-name-specifier refers to a dependent type, it shall be pre\ufb01xed by the keyword typename, forming a typename-specifier.  If the qualified-id in a typename-specifier does not denote a type, the program is ill-formed.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-07-11T14:17:36.300", "Score": "7", "CreationDate": "2011-07-10T22:08:05.363", "ParentId": "6642721", "CommentCount": "4", "OwnerUserId": "103167", "LastEditDate": "2011-07-11T14:17:36.300"}, "6642794": {"Id": "6642794", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6642721_6642794_0\">typedef typename T::Type::Type Type; \n  //(1)//legal?</p>\n</blockquote>\n<p>I myself <strong>don't understand</strong> the need of <code>typename</code> here. Becuase <code>typedef</code> can be applied only to a <code>typename</code>. Maybe C++ grammer is designed this way.</p>\n<blockquote>\n<p id=\"so_6642721_6642794_1\">enum {value = T::Type::Type::value };\n  //(2)//legal?</p>\n</blockquote>\n<p>You <strong>cannot</strong> use <code>typename</code> because, it's expected to be a value. It's implicitly logical, that when you write <code>enum { value = ??? };</code>, then <code>???</code> must always be a value only.</p>\n", "LastEditorUserId": "469935", "LastActivityDate": "2011-07-10T18:26:19.977", "Score": "-1", "CreationDate": "2011-07-10T17:52:03.387", "ParentId": "6642721", "CommentCount": "3", "OwnerUserId": "514235", "LastEditDate": "2011-07-10T18:26:19.977"}, "6642862": {"Id": "6642862", "PostTypeId": "2", "Body": "<p>The <code>typename</code> refers to the first dependent type. In your particular case :  </p>\n<pre><code>typedef typename T::type1::type2 Type;\n</code></pre>\n<p>it refers to <code>T::type1</code>, telling it is a dependent name (depending on the template parameter T).</p>\n<p>For a constant value, you do not need a typename, because it is a value - not a type. If the value is not defined, you'll get a compilation error.</p>\n<p><strong>EDIT</strong></p>\n<pre><code>struct S1\n{\n    enum { value = 42 };\n};\ntemplate &lt;class T&gt; struct S2\n{\n    typedef S1 Type;\n};\ntemplate &lt;class T&gt; struct S3\n{\n    typedef S2&lt;T&gt; Type; \n};\ntemplate &lt;class T&gt; struct S4\n{\n    typedef typename T::Type::Type Type;  //(1)//legal?\n    enum {value = T::Type::Type::value }; //(2)//legal?\n};\n</code></pre>\n<p>Lets go slowly through the example. What happens in this <code>S4&lt;S3&lt;S2&lt;S2&lt;S1&gt; &gt; &gt; &gt;</code> type is this : since T is <code>S3&lt;S2&lt;S2&lt;S1&gt; &gt; &gt;</code>, then <code>typename T::Type</code> expands to <code>S2&lt;S2&lt;S1&gt; &gt;::Type</code>, which is a full type (not depending in any way on the template parameter any further). For that reason you do not need to use typename after the first dependent typename.</p>\n", "LastEditorUserId": "476681", "LastActivityDate": "2011-07-10T18:37:47.410", "Score": "-3", "CreationDate": "2011-07-10T18:02:52.390", "ParentId": "6642721", "CommentCount": "7", "OwnerUserId": "476681", "LastEditDate": "2011-07-10T18:37:47.410"}, "6643974": {"Id": "6643974", "PostTypeId": "2", "Body": "<p>The point of typename is to allow basic checking of a template definition before it is instantiated. Parsing C++ is impossible without knowing whether a name is a type or not (is <code>a*b;</code> an expression statement or a declaration of a pointee <code>b</code>).</p>\n<p>In a template definition the category (type or non-type) of a simple identifier is always known. But a qualified (dependent) name cannot be - for arbitrary T, T::x could be either.</p>\n<p>So the language allows you to tell the compiler that a qualified name represents a type by using the typename keyword. If you don't, the compiler is required to assume it to be a value type. In either case it is an error to mislead the compiler.</p>\n<p>The rule applies even in some cases where it is obvious a type is required (eg in a typedef).</p>\n<p>Only the full qualified name requires this disambiguation - <code>typename A::B::C</code> tells you C is a type; there's no need to know anything about A or B to parse the context in which the qualified name appears.</p>\n<p>In your example (1) the typename is saying that <code>T::Type::Type</code> is a type. In (2) you must not use typename, because <code>T::Type::value</code> is not a type. Neither case says anything about <code>T::Type</code> because this is irrelevant. (Although one can deduce that it must be a type, because otherwise you couldn't apply <code>::</code> to it.)</p>\n<p>I suspect your problem with MSVC is simply a bug in that compiler (it's notorious that it doesn't handle two-phase lookup properly), although I have to admit I'm not 100% certain.</p>\n", "LastActivityDate": "2011-07-10T21:53:08.273", "CommentCount": "12", "CreationDate": "2011-07-10T21:53:08.273", "ParentId": "6642721", "Score": "3", "OwnerUserId": "212870"}, "bq_ids": {"n4140": {"so_6642721_6644062_1": {"length": 20, "quality": 0.8, "section_id": 170}, "so_6642721_6644062_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 172}}, "n3337": {"so_6642721_6644062_1": {"length": 20, "quality": 0.8, "section_id": 164}, "so_6642721_6644062_0": {"length": 34, "quality": 0.8947368421052632, "section_id": 166}}, "n4659": {"so_6642721_6644062_1": {"length": 23, "quality": 0.92, "section_id": 175}, "so_6642721_6644062_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 177}}}, "6642721": {"ViewCount": "2921", "Body": "<p>This question was inspired by <a href=\"https://stackoverflow.com/questions/6642050/boost-static-assertion-for-type-comparision\">this other question</a>. While trying to answer that question, I understood that I have a lot of questions myself. So... Consider the following:</p>\n<pre><code>struct S1\n{\n    enum { value = 42 };\n};\n\ntemplate &lt;class T&gt; struct S2\n{\n    typedef S1 Type;\n};\n\ntemplate &lt;class T&gt; struct S3\n{\n    typedef S2&lt;T&gt; Type; \n};\n\ntemplate &lt;class T&gt; struct S4\n{\n    typedef typename T::Type::Type Type;  //(1)//legal?\n    enum {value = T::Type::Type::value }; //(2)//legal?\n};\n\nint main()\n{\n    S4&lt;S3&lt;S2&lt;S2&lt;S1&gt; &gt; &gt; &gt;::value;\n}\n</code></pre>\n<p>This compiles successfully with MSVC9.0 and Online Comeau. However, <strong><em>what's bothering me is that I don't understand what <code>typename</code> refers to in (1) and why wouldn't we need <code>typename</code> in (2).</em></strong></p>\n<p>I have tried these 2 syntaxes (syntaces?) of what I think it should be both of which fail on MSVC:</p>\n<pre><code>    typedef typename T::typename Type::Type Type;\n    enum {value = typename T::typename Type::Type::value }; \n</code></pre>\n<p>and</p>\n<pre><code>    typedef typename (typename T::Type)::Type Type;\n    enum {value = (typename (typename T::Type)::Type)::value }; \n</code></pre>\n<p>Of course, a workaround is to use consecutive <code>typedef</code>s like this:</p>\n<pre><code>   typedef typename T::Type T1;\n   typedef typename T1::Type Type;\n   enum { value = Type::value};  \n</code></pre>\n<p>Good style left aside, do we syntactically <strong><em>have to</em></strong> use the workaround I mentioned?</p>\n<p><strong><em>The rest is just an interesting example. No need to read. Not that relevant to the question.</em></strong></p>\n<p>Please note, that although MSVC accepts the original strange syntax without multiple <code>typename</code>s(I mean (1) and (2)), it leads to strange behavior as in the mentioned question. I think I'll present that example in concise form here as well:</p>\n<pre><code>struct Good\n{\n    enum {value = 1}; \n};\nstruct Bad\n{\n    enum {value = -1};  \n};\n\ntemplate &lt;class T1, class T2&gt;\nstruct ArraySize\n{\n    typedef Bad Type;\n};\ntemplate &lt;class T&gt;\nstruct ArraySize&lt;T, T&gt;\n{\n    typedef Good Type;\n};\n\ntemplate &lt;class T&gt;\nstruct Boom\n{\n    char arr[ArraySize&lt;T, Good&gt;::Type::value]; //error, negative subscript, even without any instantiation\n};\n\nint main()\n{\n    Boom&lt;Good&gt; b; //with or without this line, compilation fails.\n}\n</code></pre>\n<p>This doesn't compile. The workaround I mentioned solves the problem, but I am sure the problem here is my initial question - missing typename, but you don't really know where to stick one.\nThanks very much in advance.</p>\n", "AcceptedAnswerId": "6644062", "Title": "multiple nested dependent names - where to stick the typename keyword?", "CreationDate": "2011-07-10T17:42:12.527", "Id": "6642721", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:33:22.350", "LastEditorUserId": "-1", "LastActivityDate": "2011-07-11T14:17:36.300", "Score": "9", "OwnerUserId": "469935", "Tags": "<c++><templates><typename><dependent-name>", "AnswerCount": "5"}, "6643071": {"Id": "6643071", "PostTypeId": "2", "Body": "<pre><code>typedef typename T::Type::Type Type;  //(1)//legal?\nenum {value = T::Type::Type::value }; //(2)//legal?\n</code></pre>\n<p>in (1) you say that T::Type::<strong>Type</strong> is a type name</p>\n<p>in (2) you say nothing about T::Type::Type::<strong>value</strong> and by default it will be parsed as non-type</p>\n", "LastActivityDate": "2011-07-10T18:36:41.980", "CommentCount": "0", "CreationDate": "2011-07-10T18:36:41.980", "ParentId": "6642721", "Score": "2", "OwnerUserId": "837811"}});