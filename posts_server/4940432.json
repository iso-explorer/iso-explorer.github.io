post_cb({"4940526": {"ParentId": "4940432", "CommentCount": "5", "Body": "<p>Assuming your string class will store the current value in an ASCIIZ buffer, you can use <code>strstr()</code>.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "4940526", "Score": "1", "CreationDate": "2011-02-09T01:38:43.617", "LastActivityDate": "2011-02-09T01:38:43.617"}, "4940677": {"ParentId": "4940432", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_4940432_4940677_0\">Please make notice that I'm writing my own String class because I'm taking an object oriented programing course at school to learn about classes. Because of that I cannot use \"find()\" from the standard library string class because that ruins the purpose.</p>\n</blockquote>\n<p>It would not make sense to use the standard library string class, but it does make sense to use container-agnostic algorithms:</p>\n<blockquote>\n<pre><code>template&lt;class ForwardIterator1, class ForwardIterator2&gt;\nForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n                        ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate&lt;class ForwardIterator1, class ForwardIterator2, class BinaryPredicate&gt;\nForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1,\n                        ForwardIterator2 first2, ForwardIterator2 last2,\n                        BinaryPredicate pred);\n</code></pre>\n<p id=\"so_4940432_4940677_1\"><strong>Returns:</strong> The first iterator i in the range [first1, last1 - (last2 - first2)) such that for any non-negative integer n less than last2 - first2 the following corresponding conditions hold: *(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false. Returns last1 if no such iterator is found.</p>\n<p id=\"so_4940432_4940677_2\">[Source: C++03 \u00a725.1.9]</p>\n</blockquote>\n<p>Std::search does exactly what you want to do.  If you are still not allowed to use container-agnostic algorithms, then you can implement std::search yourself under a new name and use that.  (Such a prevention on std::search is a braindead requirement precisely because you can imitate it exactly without relying on any details of your String class.)</p>\n<p>Here is a naive (meaning obvious and it works, but perhaps more slowly than possible) implementation:</p>\n<pre><code>template&lt;class IterA, class IterB&gt;\nIterA search(IterA a_begin, IterA a_end, IterB b_begin, IterB b_end) {\n  for (IterA start = a_begin; start != a_end; ++start) {\n    IterA a = start;\n    for (IterB b = b_begin; a != a_end; ++b, ++a) {\n      if (b == b_end) return start;\n      if (*b != *a) break;\n    }\n  }\n  return a_end;\n}\n</code></pre>\n<p>Note it's more verbose to call std::equal from this implementation because you don't know that distance(b_begin, b_end) &lt;= distance(a_begin, a_end), and std::equal has that requirement.</p>\n", "OwnerUserId": "511601", "LastEditorUserId": "511601", "LastEditDate": "2011-02-09T02:24:45.657", "Id": "4940677", "Score": "0", "CreationDate": "2011-02-09T02:16:07.500", "LastActivityDate": "2011-02-09T02:24:45.657"}, "4940444": {"ParentId": "4940432", "CommentCount": "1", "Body": "<p>Although this might not be of direct help, it is practical: I suggest using the standard library strings rather than try to build your own class. It takes time and is bound to be error prone.</p>\n", "OwnerUserId": "374253", "PostTypeId": "2", "Id": "4940444", "Score": "2", "CreationDate": "2011-02-09T01:20:39.017", "LastActivityDate": "2011-02-09T01:20:39.017"}, "bq_ids": {"n4140": {"so_4940432_4940677_1": {"section_id": 1280, "quality": 0.7931034482758621, "length": 23}}, "n3337": {"so_4940432_4940677_1": {"section_id": 1275, "quality": 0.7931034482758621, "length": 23}}, "n4659": {"so_4940432_4940677_1": {"section_id": 1400, "quality": 0.7931034482758621, "length": 23}}}, "4940432": {"CommentCount": "2", "ViewCount": "838", "PostTypeId": "1", "LastEditorUserId": "609067", "CreationDate": "2011-02-09T01:17:52.857", "LastActivityDate": "2011-02-09T02:24:45.657", "Title": "Replace a substring inside a string (c++)", "AcceptedAnswerId": "4940526", "LastEditDate": "2011-02-09T01:31:54.243", "Id": "4940432", "Score": "1", "Body": "<p>I'm building my own String class\nand I want to write my own replace method for the class</p>\n<p>However I don't know how to get the position (int) of the first occurrence of substring inside the string.</p>\n<p>My replace method should take 2 arguments, String searchString, String newString. It works like this</p>\n<pre><code>String example=\"AppLe\";\n\nexample.replace(\"L\", \"banana\");\n</code></pre>\n<p>I need to somehow obtain the position of L inside example string. for my replace function to have as result \"Appbananae\"</p>\n<p>Please make notice that I'm writing my own String class because I'm taking an object oriented programing course at school to learn about classes. Because of that I cannot use \"find()\" from the standard library string class because that ruins the purpose. Thanks a lot</p>\n", "Tags": "<c++><string>", "OwnerUserId": "609067", "AnswerCount": "3"}});