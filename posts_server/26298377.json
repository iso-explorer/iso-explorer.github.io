post_cb({"26298377": {"CommentCount": "4", "AcceptedAnswerId": "26652633", "CreationDate": "2014-10-10T11:29:12.123", "LastActivityDate": "2014-10-30T12:08:45.040", "PostTypeId": "1", "ViewCount": "535", "FavoriteCount": "1", "Title": "Why doesn't std::bind account for function arity?", "Id": "26298377", "Score": "9", "Body": "<p>If I have this simple case:</p>\n<pre><code>struct Foo \n{\n    void bar();\n    void baz(int );\n};\n</code></pre>\n<p>It makes sense that this would compile:</p>\n<pre><code>Foo foo;\nauto f = std::bind(&amp;Foo::bar, &amp;foo);\n</code></pre>\n<p>But why would <code>bind</code> be designed in such a way that this compiles:</p>\n<pre><code>auto g = std::bind(&amp;Foo::baz, &amp;foo);\n</code></pre>\n<p>I can call <code>f</code>, but I cannot ever call <code>g</code>. Why even make that compile? What is the rationale behind requiring me to have to do:</p>\n<pre><code>auto g2 = std::bind(&amp;Foo::baz, &amp;foo, std::placeholders::_1);\n</code></pre>\n<p>I can understand using the placeholders if you want to mess with <em>which</em> arguments get passed and in what order, but why not just have the default pass <em>all</em> the arguments in the right order without having to specify it?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2069064", "AnswerCount": "1"}, "26652633": {"ParentId": "26298377", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_26298377_26652633_0\">But why would bind be designed in such a way that this compiles:<br>\n<code>auto g = std::bind(&amp;Foo::baz, &amp;foo);</code><br>\n  I can call <code>f</code>, but I cannot ever call <code>g</code>. Why even make that compile? </br></br></p>\n</blockquote>\n<p>The <a href=\"http://www.boost.org/doc/libs/1_56_0/libs/bind/bind.html#err_num_args\" rel=\"nofollow\">Boost.Bind FAQ</a> says that Boost.Bind will usually diagnose such errors at \"bind time\" (i.e. on the line where you call <code>bind</code>). However the standard doesn't require that for <code>std::bind</code>, instead it has the following in the <em>Requires</em> element for <code>std::bind</code>:</p>\n<blockquote>\n<p id=\"so_26298377_26652633_1\"><code>INVOKE (fd, w1, w2, ..., wN)</code> (20.9.2) shall be a valid expression for some values <em>w1, w2, ..., wN</em>, where <code>N == sizeof...(bound_args)</code>.</p>\n</blockquote>\n<p>This means your code violates the function's precondition, which results in undefined behaviour. The standard library implementation is not obliged to check for precondition violations, that's your job. The library isn't forbidden to check them either, so it would be conforming for an implementation to reject it, as Boost.Bind does. I would make a request to your library vendor asking them to diagnose invalid bind expressions where it is possible to do so, as a \"Quality of Implementation\" enhancement.</p>\n<blockquote>\n<p id=\"so_26298377_26652633_2\">why not just have the default pass <em>all</em> the arguments in the right order without having to specify it?</p>\n</blockquote>\n<p>I can think of two reasons.</p>\n<p>Firstly, the behaviour of the call wrapper created by <code>bind</code> is to drop arguments that do not correspond to a placeholder, so you can call <code>x(1, 2, 3)</code> and have it ignore all the arguments and call <code>foo.bar()</code>. This is part of a general pattern where you can wrap an N-arity function using <code>bind</code> to create a call wrapper with a completely different arity that might add arguments, remove them, fix some to specific bound values etc. It would be impossible to have <code>x(1, 2, 3)</code> drop all arguments if the default behaviour when no placeholders are used in the bind expression was to forward all the arguments.</p>\n<p>Secondly, it's more consistent to always require you to be explicit about which arguments you want passed in which order. In general it would only make sense to pass all the invocation arguments when there are no bound arguments, otherwise how should <code>bind</code> know whether to pass the invocation arguments before or after the bound arguments?</p>\n<p>e.g. given</p>\n<pre><code>struct X {\n  void f(int, int) { }\n} x;\nauto h = bind(&amp;X::f, &amp;x, 1);\nh(2);\n</code></pre>\n<p>Should the call to <code>h(2)</code> result in <code>x.f(1, 2)</code> or <code>x.f(2, 1)</code>? Since the correct behaviour when there are bound arguments is not obvious, automatically forwarding all arguments when there were no placeholders used only really makes sense when there are no bound arguments (because then there's no question of whether the bound arguments should come first or last), which is a fairly special case. Changing a significant feature of the API to work with that special case would be of questionable value, especially when it makes the <code>x(1, 2, 3)</code> -&gt; <code>foo.bar()</code> case impossible to achieve.</p>\n<p>An alternative solution is to continue requiring users to be explicit about what they want, but provide an explicit way to say \"just forward everything\", as proposed by Tomasz Kami\u0144ski in <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4171.html\" rel=\"nofollow\">N4171</a> which will be discussed at the C++ committee meeting next week. The <code>_all</code> placeholder solves the problem of deciding whether the invocation arguments should come before or after the bound arguments, because you can explicitly say whether you want <code>bind(f, arg1, arg2, std::placeholders::_all)</code> or <code>bind(f, std::placeholders::_all, arg1, arg2)</code> or even <code>bind(f, arg1, std::placeholders::_all, arg2)</code></p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "26652633", "Score": "3", "CreationDate": "2014-10-30T12:08:45.040", "LastActivityDate": "2014-10-30T12:08:45.040"}, "bq_ids": {"n4140": {"so_26298377_26652633_1": {"section_id": 4633, "quality": 0.75, "length": 6}}, "n3337": {"so_26298377_26652633_1": {"section_id": 4444, "quality": 0.75, "length": 6}}, "n4659": {"so_26298377_26652633_1": {"section_id": 6003, "quality": 0.75, "length": 6}}}});