post_cb({"23493716": {"Id": "23493716", "PostTypeId": "2", "Body": "<p>It's for member initialisation. This is the only place you can init members without them being default initialised.</p>\n<p>If you do it within curly braces, the default constructor for members has already been invoked and your assigning new value to it. With the colon syntax, you decide how members are initialised (in terms of value fortrivial types and in terms of constructor with non trivial ones).</p>\n", "LastActivityDate": "2014-05-06T11:40:46.340", "CommentCount": "0", "CreationDate": "2014-05-06T11:40:46.340", "ParentId": "23493598", "Score": "0", "OwnerUserId": "2198692"}, "bq_ids": {"n4140": {"so_23493598_23493639_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 434}, "so_23493598_23493639_8": {"length": 4, "quality": 1.0, "section_id": 3312}, "so_23493598_23493639_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 3323}, "so_23493598_23493639_0": {"length": 11, "quality": 1.0, "section_id": 430}}, "n3337": {"so_23493598_23493639_8": {"length": 4, "quality": 1.0, "section_id": 3182}, "so_23493598_23493639_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 426}, "so_23493598_23493639_2": {"length": 41, "quality": 0.9318181818181818, "section_id": 3193}, "so_23493598_23493639_0": {"length": 11, "quality": 1.0, "section_id": 422}}, "n4659": {"so_23493598_23493639_8": {"length": 4, "quality": 1.0, "section_id": 382}, "so_23493598_23493639_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 452}, "so_23493598_23493639_2": {"length": 38, "quality": 0.8636363636363636, "section_id": 4089}, "so_23493598_23493639_0": {"length": 11, "quality": 1.0, "section_id": 448}, "so_23493598_23493639_16": {"length": 4, "quality": 0.6666666666666666, "section_id": 7225}}}, "23493639": {"Id": "23493639", "PostTypeId": "2", "Body": "<p>The colon character <code>:</code> is used to denote the constructor <em>member initializer list</em>. This is the place where you can initiailze members of a class or call a base class constructor.</p>\n<p>C++ Standard n3337 12.6.2 <strong>\u00a7</strong> 3:</p>\n<blockquote>\n<p id=\"so_23493598_23493639_0\">A mem-initializer-list can initialize a base class using any\n  class-or-decltype that denotes that base class type.</p>\n</blockquote>\n<p>C++ Standard n3337 12.6.2 <strong>\u00a7</strong> 7:</p>\n<blockquote>\n<p id=\"so_23493598_23493639_1\">The expression-list or braced-init-list in a mem-initializer is used\n  to initialize the designated subobject (or, in the case of a\n  delegating constructor, the complete class object) according to the\n  initialization rules of 8.5 for direct-initialization.</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>class Foo {\n   int a;\n};\n</code></pre>\n<p>If you would like integer <code>a</code> to have determined value after call to constructor is made you have to give <code>a</code> this value in constructor. There are two options:</p>\n<ul>\n<li><p>in constructor body</p>\n<pre><code>Foo::Foo() {\n    a = 70;\n}\n</code></pre></li>\n<li><p>in it's member initializer list</p>\n<pre><code>Foo::Foo() : a( 70) {\n}\n</code></pre></li>\n</ul>\n<h2>Initialization via a member initilization list should be preferred</h2>\n<p>It is always <strong>legal</strong>, is never less efficient than assignment inside the body of the constructor, and is often <strong>more efficient</strong>. The very <strong>important thing</strong> about initialization list is that it allows to direct initialize class member omitting a default construction of a member being subject to such a process.</p>\n<p>As Scott Myers pointed out in his \"Effective C++\", if you fail to specify an initialization argument for class member, it's default constructor will be called. When you later perform an assignment to it inside your class constructor, you will call <code>operator=</code> on member variable. That will total two calls to member functions: one for the default constructor and one more for the assignment. You can omit a first call by specifying an initializer. Also as Scott Myers pointed out in his \"Effective C++\" : \"from a purely pragmatic point of view, there are times when the initialization list must be used. In particular, <code>const</code> and reference members may only be initialized, never assigned\". </p>\n<h2>A trap</h2>\n<p>(At least) Equally important thing is that members are not initialized in order of their appearance in initialization list but in order of declaration in class. Remember this to avoid errors like </p>\n<pre><code>/* trying to allocate very large block of memory\n   as a result of initializing a vector with\n   uninitialized integer: std::vector&lt;int&gt; v( N)\n*/\nclass SearchEngine {\n    std::vector&lt;int&gt; v;\n    int N;\n    explicit SearchEngine( std::vector&lt;int&gt; const&amp; keys)\n                  : N( keys.size()), v( N), {\n</code></pre>\n<p>C++ Standard n3337 8.5.4 <strong>\u00a7</strong> 1:</p>\n<blockquote>\n<p id=\"so_23493598_23493639_2\">List-initialization is initialization of an object or reference from a\n  braced-init-list. Such an initializer is called an initializer list,\n  and the comma-separated initializer-clauses of the list are called the\n  elements of the initializer list. An initializer list may be empty.\n  List-initialization can occur in direct-initialization or copy-\n  initialization contexts; list-initialization in a\n  direct-initialization context is called direct-list-initialization and\n  list-initialization in a copy-initialization context is called\n  copy-list-initialization. [ Note: List-initialization can be used \u2014 as\n  the initializer in a variable definition (8.5) </p>\n<p id=\"so_23493598_23493639_3\">\u2014 as the initializer in\n  a new expression (5.3.4) </p>\n<p id=\"so_23493598_23493639_4\">\u2014 in a return statement (6.6.3) </p>\n<p id=\"so_23493598_23493639_5\">\u2014 as a\n  function argument (5.2.2) </p>\n<p id=\"so_23493598_23493639_6\">\u2014 as a subscript (5.2.1)  </p>\n<p id=\"so_23493598_23493639_7\">\u2014 as an argument to\n  a constructor invocation (8.5, 5.2.3) </p>\n<p id=\"so_23493598_23493639_8\">\u2014 as an initializer for a\n  non-static data member (9.2)  </p>\n<p id=\"so_23493598_23493639_9\">\u2014 in a mem-initializer (12.6.2)  </p>\n<p id=\"so_23493598_23493639_10\">\u2014 on the\n  right-hand side of an assignment (5.17)  </p>\n<p id=\"so_23493598_23493639_11\">[ Example:  </p>\n<p id=\"so_23493598_23493639_12\">int a = {1}; </p>\n<p id=\"so_23493598_23493639_13\">std::complex z{1,2}; </p>\n<p id=\"so_23493598_23493639_14\">new std::vector{\"once\",\n  \"upon\", \"a\", \"time\"}; // 4 string elements</p>\n<p id=\"so_23493598_23493639_15\">f( {\"Nicholas\",\"Annemarie\"}\n  ); // pass list of two elements </p>\n<p id=\"so_23493598_23493639_16\">return { \"Norah\" }; // return list of\n  one element  </p>\n<p id=\"so_23493598_23493639_17\">int* e {}; // initialization to zero / null pointer </p>\n<p id=\"so_23493598_23493639_18\">x =\n  double{1}; // explicitly construct a double </p>\n<p id=\"so_23493598_23493639_19\">std::map\n  anim = { {\"bear\",4}, {\"cassowary\",2}, {\"tiger\",7} };</p>\n<p id=\"so_23493598_23493639_20\">\u2014 end example ] \u2014 end note ]</p>\n</blockquote>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2016-01-14T12:25:03.477", "Score": "7", "CreationDate": "2014-05-06T11:36:42.043", "ParentId": "23493598", "CommentCount": "1", "OwnerUserId": "1141471", "LastEditDate": "2016-01-14T12:25:03.477"}, "23493714": {"Id": "23493714", "PostTypeId": "2", "Body": "<p>Initialization list. It is useful when you want to initialize the member objects right after construction. And you have to use it when a member object has a not a default constuctor.</p>\n<p>And it's not just another way to initialize members, sometimes you have to use it, and most of the time you should use it to keep the code consistence.</p>\n<p>Here is an example for a situation that you have to use it: </p>\n<pre><code>struct A\n{\n   const X x; // X has not default constructor\n\n   A() : x(some_value) {}\n};\n</code></pre>\n<p>Even if a member object has a default constructor, you should initialize it by initialization-list to avoid redundant construction.</p>\n<pre><code>struct A\n{\n   string x;\n\n   A() : x(\"Hello\") {}\n};\n</code></pre>\n<p>In the above case, if you assign <code>\"Hello\"</code> inside the constructor's body, then you made an unnecessary call to <code>string::string()</code> and then <code>x = \"Hello\";</code>, which it can be replaced  by just one call to <code>string::string(\"Hello\")</code>.</p>\n", "LastEditorUserId": "952747", "LastActivityDate": "2014-05-06T11:46:56.533", "Score": "0", "CreationDate": "2014-05-06T11:40:40.677", "ParentId": "23493598", "CommentCount": "0", "OwnerUserId": "952747", "LastEditDate": "2014-05-06T11:46:56.533"}, "23493598": {"ViewCount": "913", "Body": "<p>I am moving from structural C to OOP C++ and I frequently found a special use of \"<code>:</code>\" symbol as an operator when declaring/defining constructors in C++. I roughly understood the use of this style but somebody explain me the exact programming technique with this constructor definition.</p>\n<p>e.g.: 1</p>\n<pre><code>class time_stamp\n{\npublic:\n    time_stamp(time &amp;t_time)\n        : m_time(t_time)\n    {}\n\n    ~time_stamp()\n    {\n        m_time.update(); // as soon as I'm destroyed, update the time\n    }\nprivate:\n    time &amp;m_time;\n};\n</code></pre>\n<p>e.g.: 2</p>\n<pre><code>class threaded_class\n{\npublic:\n    threaded_class()\n        : m_stoprequested(false), m_running(false)\n    {\n        pthread_mutex_init(&amp;m_mutex);\n    }\n\n    ~threaded_class()\n    {\n        pthread_mutex_destroy(&amp;m_mutex);\n    }\n\n    /** Some other member declarations */\n\n}\n</code></pre>\n<p>Please explain me use of \"<code>:</code>\" in below lines of codes from above 2 examples\n<code>time_stamp(time &amp;t_time) : m_time(t_time){}</code> and </p>\n<pre><code>threaded_class(): m_stoprequested(false), m_running(false)\n{\n   pthread_mutex_init(&amp;m_mutex);\n}\n</code></pre>\n", "AcceptedAnswerId": "23493639", "Title": "Use of \":\" symbol to define a constructor in C++", "CreationDate": "2014-05-06T11:34:33.743", "Id": "23493598", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-05-06T11:35:54.367", "LastEditorUserId": "531840", "LastActivityDate": "2016-01-14T12:25:03.477", "ClosedDate": "2014-05-06T12:34:51.043", "Score": "-2", "OwnerUserId": "3458841", "Tags": "<c++><oop>", "AnswerCount": "3"}});