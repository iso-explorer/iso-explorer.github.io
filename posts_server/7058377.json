post_cb({"bq_ids": {"n4140": {"so_7058377_7058502_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7177}, "so_7058377_7058469_0": {"length": 15, "quality": 0.9375, "section_id": 6089}}, "n3337": {"so_7058377_7058502_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6921}, "so_7058377_7058469_0": {"length": 16, "quality": 1.0, "section_id": 5857}}, "n4659": {"so_7058377_7058502_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 8685}, "so_7058377_7058469_0": {"length": 15, "quality": 0.9375, "section_id": 7585}}}, "7058668": {"Id": "7058668", "PostTypeId": "2", "Body": "<p>The confusion is between different versions of the standard.  The older standard did not make the guarentee about <code>new char[n]</code> and the newer one does.</p>\n<p>Note the bit in both cases where <code>new char[n]</code> might NOT return the same pointer it got back from the underlying <code>operator new(size_t)</code> -- that's because when allocating an array, the runtime may use the space at the beginning of the allocated block (the space between what <code>operator new(size_t)</code> returned and what <code>new char[n]</code> returns) to store the size of the array -- and that size might not require the full worst-case alignment padding.  An implementation is not <em>required</em> to do this -- it might note that, since <code>char</code> has no destructor, it doesn't need to record the size of the array to know how many destructor calls to make when <code>delete[]</code> is called.  But an implementation is free to treat all arrays uniformly.</p>\n", "LastActivityDate": "2011-08-14T18:04:50.083", "CommentCount": "0", "CreationDate": "2011-08-14T18:04:50.083", "ParentId": "7058377", "Score": "0", "OwnerUserId": "16406"}, "7058377": {"ViewCount": "767", "Body": "<p>With regard to alignment, there is something I don't understand about the difference between an explicit call to <code>T* t = (T*) ::operator new(sizeof(T))</code> and <code>T* t = (T*)new char[sizeof(T)]</code>, where <code>T</code> is a C-like struct.</p>\n<p>In the book \"C++ Solutions Companion to The C++ Programming Language, Third Edition\" (see exercise 12.9), the author says: \"<i>Note that one should not use the expression new char[n] to allocate raw memory because that memory may not satisfy the alignment requirements of a T, while an explicit call of the global operator new is guaranteed to yield storage that is sufficiently aligned for any C++ object.</i>\". This is also stated in an article I read on internet: <a href=\"http://www.scs.stanford.edu/~dm/home/papers/c++-new.html\" rel=\"nofollow noreferrer\">http://www.scs.stanford.edu/~dm/home/papers/c++-new.html</a> (see the \"delete vs. delete[] and free\" paragraph).</p>\n<p>On the other hand, in my previous post <a href=\"https://stackoverflow.com/questions/7054176/data-alignment-in-c-standard-and-portability\">Data alignment in C++, standard and portability</a> a guy quoted the standard, plus a note at the end of the quote which contradicts the above people:</p>\n<p>\"<i>A new-expression passes the amount of space requested to the allocation function as the first argument of type std::size_t. That argument shall be no less than the size of the object being created; it may be greater than the size of the object being created only if the object is an array. For arrays of char and unsigned char, the difference between the result of the new-expression and the address returned by the allocation function shall be an integral multiple of the strictest fundamental alignment requirement (3.11) of any object type whose size is no greater than the size of the array being created. [ Note: Because allocation functions are assumed to return pointers to storage that is appropriately aligned for objects of any type with fundamental alignment, this constraint on array allocation overhead permits the common idiom of allocating character arrays into which objects of other types will later be placed. \u2014 end note ]</i>\"</p>\n<p>I am confused. Could you please tell me who is right here according to the standard and, in case, why is <code>::operator new()</code> different from <code>new char[]</code>?</p>\n", "Title": "What is the difference between ::operator new(size_t n) and new char[n] with regard to alignment?", "CreationDate": "2011-08-14T17:14:32.647", "LastActivityDate": "2013-06-26T20:17:11.870", "CommentCount": "0", "LastEditDate": "2017-05-23T11:52:56.563", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "7058377", "Score": "3", "OwnerUserId": "893504", "Tags": "<c++>", "AnswerCount": "3"}, "7058502": {"Id": "7058502", "PostTypeId": "2", "Body": "<p>C++98 \u00a73.7.3.1/2, about allocation functions:</p>\n<blockquote>\n<p id=\"so_7058377_7058502_0\">The pointer returned shall be suitably aligned so that it can be converted to a pointer of\n  any complete object type and then used to access the object or array in the storage allocated</p>\n</blockquote>\n<p>Together with your quote of \u00a75.3.4/10 about new-expressions, \"A new-expression passes the amount...\", this means <code>new char[n]</code> can't offer weaker alignment guarantees, it can't be less aligned.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2011-08-14T17:51:32.960", "Score": "1", "CreationDate": "2011-08-14T17:33:35.497", "ParentId": "7058377", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2011-08-14T17:51:32.960"}, "7058469": {"Id": "7058469", "PostTypeId": "2", "Body": "<p>That's right, <code>new char[n]</code> delegates to <code>operator new[](size_t)</code>, see 5.3.4 \"New\" \u00a78:</p>\n<blockquote>\n<p id=\"so_7058377_7058469_0\">A <em>new-expression</em> obtains storage for the object by calling an allocation function [...]\n  If the allocated type is an array type, the allocation function's name is <code>operator new[]</code></p>\n</blockquote>\n<p>Hence, there is absolutely no way the former could somehow yield \"less aligned\" memory than the latter.</p>\n<p>Sadly, when it comes to technical details, most C++ books out there just plain suck.</p>\n", "LastActivityDate": "2011-08-14T17:27:31.003", "CommentCount": "0", "CreationDate": "2011-08-14T17:27:31.003", "ParentId": "7058377", "Score": "2", "OwnerUserId": "252000"}});