post_cb({"bq_ids": {"n4140": {"so_24718555_24719009_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 599}, "so_24718555_24719013_0": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_24718555_24719013_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_24718555_24719009_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 589}}, "n4659": {"so_24718555_24719013_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_24718555_24719009_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 622}}}, "24719009": {"Id": "24719009", "PostTypeId": "2", "Body": "<p>In the expression </p>\n<pre><code>std::map&lt;std::string, int&gt; myMap = {\n     { \"One\",   1 },\n     { \"Two\",   2 },\n     { \"Three\", 3 }\n};\n</code></pre>\n<p>on the right side you have a <em>braced-init-list</em> where each element is also a braced-init-list. The first thing that happens is that the initializer list constructor of <code>std::map</code> is considered. </p>\n<pre><code>map(initializer_list&lt;value_type&gt;,\n    const Compare&amp; = Compare(),\n    const Allocator&amp; = Allocator());\n</code></pre>\n<p><code>map&lt;K, V&gt;::value_type</code> is a typedef for <code>pair&lt;const K, V&gt;</code>, in this case <code>pair&lt;const string, int&gt;</code>. The inner braced-init-lists can be successfully converted to <code>map::value_type</code> because <code>std::pair</code> has a constructor that takes references to its two constituent types, and <code>std::string</code> has an implicit conversion constructor that takes a <code>char const *</code>.</p>\n<p>Thus the initializer list constructor of <code>std::map</code> is viable, and the construction can happen from the nested braced-init-lists.</p>\n<p>The relevant standardese is present in <em>\u00a713.3.1.7/1 [over.match.list]</em></p>\n<blockquote>\n<p id=\"so_24718555_24719009_0\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor in two phases:<br/>\n  \u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.<br/> \n  \u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements of the initializer list.<br/></p>\n</blockquote>\n<p>The first bullet is what causes the <code>initializer_list</code> constructor of <code>map</code> to be selected for the outer braced-init-list, while the second bullet results in the selection of the correct <code>pair</code> constructor for the inner braced-init-lists.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2014-07-13T05:42:27.707", "Score": "9", "CreationDate": "2014-07-13T02:25:09.283", "ParentId": "24718555", "CommentCount": "1", "OwnerUserId": "241631", "LastEditDate": "2014-07-13T05:42:27.707"}, "24718555": {"ViewCount": "345", "Body": "<p>In C++11, it seems like it's legal to initialize a <code>std::map&lt;std::string, int&gt;</code> as follows:</p>\n<pre><code>std::map&lt;std::string, int&gt; myMap = {\n     { \"One\",   1 },\n     { \"Two\",   2 },\n     { \"Three\", 3 }\n};\n</code></pre>\n<p>Intuitively, this makes sense - the brace-enclosed initializer is a list of pairs of strings, and <code>std::map&lt;std::string, int&gt;::value_type</code> is <code>std::pair&lt;std::string, int&gt;</code> (possibly with some <code>const</code> qualifications.</p>\n<p>However, I'm not sure I understand how the typing works here. If we eliminate the variable declaration here and just have the brace-enclosed initializer, the compiler wouldn't know that it was looking at a <code>std::initializer_list&lt;std::pair&lt;std::string, int&gt;&gt;</code> because it wouldn't know that the braced pairs represented <code>std::pair</code>s. Therefore, it seems as though the compiler is somehow deferring the act of assigning a type to the brace-enclosed initializer until it has enough type information from the <code>std::map</code> constructor to realize that the nested braces are for pairs. I don't remember anything like this happening in C++03; to the best of my knowledge, the type of an expression never depended on its context.</p>\n<p>What language rules permit this code to compile correctly and for the compiler to determine what type to use for the initializer list? I'm hoping for answers with specific references to the C++11 spec, since it's really interesting that this works!</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "24719009", "Title": "What language rules permit C++11 to deduce that this is an initializer_list of pairs?", "CreationDate": "2014-07-13T00:41:31.787", "Id": "24718555", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-07-13T05:42:27.707", "Score": "9", "OwnerUserId": "501557", "Tags": "<c++><c++11><language-lawyer><initializer-list><brace-initialization>", "AnswerCount": "2"}, "24719013": {"Id": "24719013", "PostTypeId": "2", "Body": "<p>This is <em>list-initialization</em>. The rules are found in \u00a78.5.4[dcl.init.list]/p3 of the standard:</p>\n<blockquote>\n<p id=\"so_24718555_24719013_0\">List-initialization of an object or reference of type T is defined as\n  follows:</p>\n<ul>\n<li>If the initializer list has no elements and T is a class type with a default constructor, the object is value-initialized.</li>\n<li>Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1). [example omitted]</li>\n<li>Otherwise, if T is a specialization of <code>std::initializer_list&lt;E&gt;</code>, an <code>initializer_list</code> object is constructed as described below and\n  used to initialize the object according to the rules for\n  initialization of an object from a class of the same type (8.5).</li>\n<li>Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7). If a narrowing\n  conversion (see below) is required to convert any of the arguments,\n  the program is ill-formed.</li>\n<li>[example and remainder of the rules omitted]</li>\n</ul>\n</blockquote>\n<p>Note that overload resolution will prefer <code>std::initializer_list</code> constructors in these cases (\u00a713.3.1.7 [over.match.list]).</p>\n<p>Thus when the compiler sees an braced list used to initialize a object of a non-aggregate, non-<code>std::initializer_list</code> class type, it will perform overload resolution to select the appropriate constructor, preferring the <code>initializer_list</code> constructor if a viable one exists (as it does for <code>std::map</code>).</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-07-13T02:32:17.000", "Score": "2", "CreationDate": "2014-07-13T02:25:33.473", "ParentId": "24718555", "CommentCount": "0", "OwnerUserId": "2756719", "LastEditDate": "2014-07-13T02:32:17.000"}});