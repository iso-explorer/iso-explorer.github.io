post_cb({"47495432": {"Id": "47495432", "PostTypeId": "2", "Body": "<p>The compiler uses the arguments <em>passed</em> to deduce the template type. If there's no arguments, then how would the compiler be able to deduce the template type?</p>\n<p>You can use <em>overloading</em> instead of default arguments here.</p>\n<p>The overloaded non-argument function can simply call the function with the \"default\" argument:</p>\n<pre><code>template&lt;bool b, typename T&gt; void foo(const T&amp; t) {\n  // implementation here\n}\n\ntemplate&lt;bool b&gt; void foo() {\n  foo&lt;b&gt;([]() {});\n}\n</code></pre>\n", "LastEditorUserId": "440558", "LastActivityDate": "2017-11-26T11:13:58.540", "Score": "1", "CreationDate": "2017-11-26T11:07:46.310", "ParentId": "47495384", "CommentCount": "1", "OwnerUserId": "440558", "LastEditDate": "2017-11-26T11:13:58.540"}, "47495384": {"ViewCount": "70", "Body": "<p>Consider the following code</p>\n<pre><code>template&lt;bool b, typename T&gt; void foo(const T&amp; t = []() {}) {\n  // implementation here\n}\n\nvoid bar() {\n  foo&lt;true&gt;([&amp;](){ /* implementation here */ }); // this compiles\n  foo&lt;true&gt;(); // this doesn't compile\n}\n</code></pre>\n<p>In the case that doesn't compile I get the following errors:</p>\n<pre><code>error C2672: 'foo': no matching overloaded function found\nerror C2783: 'void foo(const T&amp;)': could not deduce template argument for 'T'\n</code></pre>\n<p>I think it's clear what I want to achieve: let <code>foo</code> be called with and without a client-provided lambda. The compiler is MSVC++2017 version 15.4.4 toolset v141.</p>\n", "AcceptedAnswerId": "47495432", "Title": "Default lambda as templated parameter of a function", "CreationDate": "2017-11-26T11:02:50.810", "Id": "47495384", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-11-26T15:09:54.977", "Score": "2", "OwnerUserId": "1915854", "Tags": "<c++><templates><lambda><c++1z><default-parameters>", "AnswerCount": "5"}, "47497562": {"Id": "47497562", "PostTypeId": "2", "Body": "<p>Another (very efficient) way - default T to be a null functor.</p>\n<pre><code>// no_op is a function object which does nothing, regardless of how many\n// arguments you give it. It will be elided completely unless you compile with\n// -O0\nstruct no_op \n{ \n    template&lt;class...Args&gt;\n    constexpr void operator()(Args&amp;&amp;...) const {} \n};\n\n// foo defaults to using a default-constructed no_op as its function object\ntemplate&lt;bool b, typename T = no_op&gt; void foo(T&amp;&amp; t = T()) \n{    \n  // implementation here\n    t();\n}\n\nvoid bar() {\n  foo&lt;true&gt;([&amp;](){ std::cout &lt;&lt; \"something\\n\"; }); // this compiles\n  foo&lt;true&gt;(); // this now compiles\n}\n</code></pre>\n", "LastActivityDate": "2017-11-26T15:09:54.977", "CommentCount": "0", "CreationDate": "2017-11-26T15:09:54.977", "ParentId": "47495384", "Score": "1", "OwnerUserId": "2015579"}, "bq_ids": {"n4140": {"so_47495384_47495416_0": {"length": 14, "quality": 1.0, "section_id": 336}, "so_47495384_47495429_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 322}, "so_47495384_47495429_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 322}, "so_47495384_47495416_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 350}}, "n3337": {"so_47495384_47495416_0": {"length": 14, "quality": 1.0, "section_id": 326}, "so_47495384_47495429_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 312}, "so_47495384_47495429_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 312}, "so_47495384_47495416_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 340}}, "n4659": {"so_47495384_47495416_0": {"length": 14, "quality": 1.0, "section_id": 345}, "so_47495384_47495429_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 330}, "so_47495384_47495429_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 330}, "so_47495384_47495416_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 66}}}, "47495416": {"Id": "47495416", "PostTypeId": "2", "Body": "<p>Consider overloading it directly:</p>\n<pre><code>template &lt;bool b&gt;\nvoid foo(void) {\n  foo([](){});\n}\n</code></pre>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/template_argument_deduction\" rel=\"nofollow noreferrer\">CppReference</a>:</p>\n<blockquote>\n<h3>Non-deduced contexts</h3>\n<p id=\"so_47495384_47495416_0\">4) A template parameter used in the parameter type of a function parameter that has a default argument that is being used in the call for which argument deduction is being done:</p>\n</blockquote>\n<blockquote>\n<p id=\"so_47495384_47495416_1\">Type template parameter cannot be deduced from the type of a function default argument:\n  template void f(T = 5, T = 7);</p>\n<pre><code>void g()\n{\n    f(1);     // OK: calls f&lt;int&gt;(1, 7)\n    f();      // error: cannot deduce T\n    f&lt;int&gt;(); // OK: calls f&lt;int&gt;(5, 7)\n}\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "5958455", "LastActivityDate": "2017-11-26T11:16:39.383", "Score": "1", "CreationDate": "2017-11-26T11:06:23.963", "ParentId": "47495384", "CommentCount": "1", "OwnerUserId": "5958455", "LastEditDate": "2017-11-26T11:16:39.383"}, "47495443": {"Id": "47495443", "PostTypeId": "2", "Body": "<p>You are trying to say something that makes no sense. You are asking the compiler to guess <code>T</code> from your arguments, but then you do not provide any argument.</p>\n<p>The following code does compile, and does what you want:</p>\n<pre><code>template&lt;bool b, typename T&gt; void foo(const T&amp; t) {\n  // implementation here\n}\n\ntemplate&lt;bool b&gt; void foo() {\n  foo&lt;b&gt;([]() {}); // Call actual implementation with empty lambda\n}\n\nvoid bar() {\n  foo&lt;true&gt;([&amp;](){ /* implementation here */ }); // this compiles\n  foo&lt;true&gt;(); // this now compiles as well\n}\n</code></pre>\n", "LastActivityDate": "2017-11-26T11:08:32.830", "CommentCount": "0", "CreationDate": "2017-11-26T11:08:32.830", "ParentId": "47495384", "Score": "0", "OwnerUserId": "1510211"}, "47495429": {"Id": "47495429", "PostTypeId": "2", "Body": "<p>Default function arguments are not part of the template argument deduction process. To quote <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct#partial-3\" rel=\"noreferrer\">[temp.deduct.partial]/3</a>:</p>\n<blockquote>\n<p id=\"so_47495384_47495429_0\">The types used to determine the ordering depend on the context in\n  which the partial ordering is done:</p>\n<ul>\n<li>In the context of a function call, the types used are those function parameter types for which the function call has arguments.\n  <sup>141</sup></li>\n</ul>\n<p id=\"so_47495384_47495429_1\"><sub>\n  141) Default arguments are not considered to be arguments in this\n  context; they only become arguments after a function has been\n  selected.\n  </sub></p>\n</blockquote>\n<p>That bullet and note indicate that since you didn't provide an argument for <code>t</code> in the call to <code>foo</code>, the type <code>T</code> cannot be deduced. The default lambda argument can only be taken into account if the function is selected to be called, not before. </p>\n<p>The solution, as all the others have noted, is to provide an overload without parameters, that will call the templated one with the default lambda you have in mind.</p>\n", "LastActivityDate": "2017-11-26T11:07:33.630", "CommentCount": "0", "CreationDate": "2017-11-26T11:07:33.630", "ParentId": "47495384", "Score": "8", "OwnerUserId": "817643"}});