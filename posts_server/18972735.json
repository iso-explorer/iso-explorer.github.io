post_cb({"18994158": {"ParentId": "18972735", "CommentCount": "2", "Body": "<p><sup><em>Comments turned into an answer</em></sup></p>\n<p>Interesting question!</p>\n<p>The C standard can leave more of the conversions unstated because they are implementation-defined (and C has no raw strings to confuse the issue).</p>\n<ol>\n<li>What it says in the C standard is sufficient \u2014 except that it leaves your question 1 unanswerable.</li>\n<li>Q2 has to be 'Phase 5', I think, with caveats about it being 'the token stream is equivalent'.</li>\n<li>Q3 is strictly N/A, but Phase 7 is probably the answer.</li>\n<li>Q4 is 'yes', and it says so because it mentions 'escape sequences' and UCNs are escape sequences.</li>\n<li>Q5 is 'Phase 5' too.</li>\n</ol>\n<blockquote>\n<p id=\"so_18972735_18994158_0\">Can the C++11-mandated processes in Phase 1 and 5 be taken as compliant within the wording of C11 (putting aside raw strings)?</p>\n</blockquote>\n<p>I think they are effectively the same; the difference arises primarily from the raw literal issue which is specific to C++. Generally, the C and C++ standards try not to make things gratuitously different, and in particular try to the workings of the preprocessor and the low-level character parsing the same in both (which has been easier since C99 added support for C++ <code>//</code> comments, but which evidently got harder with the addition of raw literals to C++11).</p>\n<p>One day, I'll have to study the raw literal notations and their implications more thoroughly.</p>\n", "OwnerUserId": "15168", "PostTypeId": "2", "Id": "18994158", "Score": "2", "CreationDate": "2013-09-25T00:12:16.943", "LastActivityDate": "2013-09-25T00:12:16.943"}, "19730912": {"ParentId": "18972735", "CommentCount": "0", "Body": "<p>First, please note that these distinction exist since 1998; UCN were first introduced in C++98, a new standard (ISO/IEC 14882, 1st edition:1998), and then made their way into the C99 revision of the C standard; but the C committee (and existing implementers, and their pre-existing implementations) did not feel the C++ way was the only way to achieve the trick, particularly with corner cases and the use of smaller character sets than Unicode, or just different; for example, the requirement to ship the mapping tables from <em>whatever-supported-encodings</em> to Unicode was a preoccupation for C vendors in 1998.</p>\n<ol>\n<li>The C standard (consciously) avoids deciding this, and let the compiler chooses how to proceed. While your reasoning takes obviously place with the context of UTF-8 character sets used for both source and execution, there are a large (and pre-existing) range of different C99/C11 compilers available which are using different sets; and the committee felt it should not restrict the implementers too much on this issue. In my experience, most compilers keep it distinct in practice (for performance reasons.)</li>\n<li>Because of this freedom, some compilers can have it identical after phase 1 (like a C++ compiler shall), while other can left it distinct as late as phase 7 for the first degree character; the second degree characters (in the string) ought to be the same after phase 5, assuming the degree character is part of the extended execution character set supported by the implementation.</li>\n</ol>\n<p>For the other answers, I won't add anything to Jonathan's.</p>\n<p>About your additional question about the C++ more deterministic process to be Standard-C-compliant, it is clearly a goal to be so; and if you find a corner case which shows otherwise (a C++11-compliant preprocessor which would not conform to the C99 and C11 standards), then you should consider asking the WG14 committee about a potential defect.</p>\n<p>Obviously, the reverse is not true: it is possible to write a pre-processor with handling of UCN which complies to C99/C11 but not to the C++ standards; the most obvious difference is with</p>\n<pre><code>#define str(t) #t\n#define str_is(x, y)  const char * x = y \" is \" str(y)\nstr_is(hell\u00b0,      \"hell\u00b0\");\nstr_is(hell\\u00B0, \"hell\\u00B0\");\n</code></pre>\n<p>which a C-compliant preprocessor can render in a similar same way as your examples (and most do so) and as such, will have distinct renderings; but I am under the impression that a C++-compliant preprocessor is required to transform into (strictly equivalent)</p>\n<pre><code>const char* hell\u00b0      = \"hell\u00b0\"       \" is \" \"\\\"hell\\\\u00b0\\\"\";\nconst char* hell\\u00b0 = \"hell\\\\u00b0\" \" is \" \"\\\"hell\\\\u00b0\\\"\";\n</code></pre>\n<p>Last, but not least, I believe not much compilers are fully compliant to this very level of details!</p>\n", "OwnerUserId": "656988", "PostTypeId": "2", "Id": "19730912", "Score": "1", "CreationDate": "2013-11-01T16:21:47.953", "LastActivityDate": "2013-11-01T16:21:47.953"}, "18972735": {"CommentCount": "4", "AcceptedAnswerId": "18994158", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2013-09-24T03:59:21.420", "LastActivityDate": "2015-12-26T18:47:58.987", "LastEditDate": "2015-12-26T18:47:58.987", "ViewCount": "349", "FavoriteCount": "1", "Title": "C11 Compilation. Phase of translation #1 and #5. Universal character names", "Id": "18972735", "Score": "4", "Body": "<p>\nI'm trying to understand Universal Character Names in the C11 standard and found that the N1570 draft of the C11 standard has much less detail than the C++11 standard with respect to Translation Phases 1 and 5 and the formation and handling of UCNs within them. This is what each has to say:</p>\n<h3>Translation Phase 1</h3>\n<p>N1570 Draft C11 5.1.1.2p1.1: </p>\n<blockquote>\n<p id=\"so_18972735_18972735_0\">Physical source file <strong>multibyte</strong> characters are mapped, in an implementation-defined manner, to the source character set (introducing new-line characters for end-of-line indicators) if necessary. Trigraph sequences are replaced by corresponding single-character internal representations.</p>\n</blockquote>\n<p>C++11 2.2p1.1:</p>\n<blockquote>\n<p id=\"so_18972735_18972735_1\">Physical source file characters are mapped, in an implementation-defined manner, to the <strong>basic</strong> source character set (introducing new-line characters for end-of-line indicators) if necessary. The set of physical source file characters accepted is implementation-defined. Trigraph sequences (2.4) are replaced by corresponding single-character internal representations. Any source file character not in the basic source character set (2.3) is replaced by the universal-character-name that designates that character. (An implementation may use any internal encoding, so long as an actual extended character encountered in the source file, and the same extended character expressed in the source file as a universal-character-name (i.e., using the \\uXXXX notation), are handled equivalently except where this replacement is reverted in a raw string literal.)</p>\n</blockquote>\n<h3>Translation Phase 5</h3>\n<p>N1570 Draft C11 5.1.1.2p1.5:</p>\n<blockquote>\n<p id=\"so_18972735_18972735_2\">Each source character set member and escape sequence in character constants and string literals is converted to the corresponding member of the execution character set; [...]</p>\n</blockquote>\n<p>C++ 2.2p1.5:</p>\n<blockquote>\n<p id=\"so_18972735_18972735_3\">Each source character set member in a character literal or a string literal, <strong>as well as each escape sequence and universal-character-name in a character literal or a non-raw string literal</strong>, is converted to the corresponding member of the execution character set; [...]</p>\n</blockquote>\n<p>(emphasis was added on differences)</p>\n<h3>The Questions</h3>\n<ol>\n<li><p>In the C++11 standard, it is very clear that source file characters not in the basic source character set are converted to UCNs, and that they are treated exactly as would have been a UCN in that same place, with the sole exception of raw-strings. Is the same true of C11? When a C11 compiler sees a multi-byte UTF-8 character such as <code>\u00b0</code>, does it too translate this to <code>\\u00b0</code> in phase 1, and treat it just as if <code>\\u00b0</code> had appeared there instead?</p></li>\n<li><p>To put it in a different way, at the end of which translation phase, if any, are the following snippets of code transformed into <em>textually equivalent</em> forms for the first time in C11?</p>\n<pre class=\"lang-c prettyprint-override\"><code>const char* hell\u00b0 = \"hell\u00b0\";\n</code></pre>\n<p>and</p>\n<pre class=\"lang-c prettyprint-override\"><code>const char* hell\\u00b0 = \"hell\\u00b0\";\n</code></pre></li>\n<li><p>If in 2., the answer is \"in none\", then during which translation phase are those two identifiers first understood to refer to the same thing, despite being textually different? </p></li>\n<li>In C11, are UCNs in character/string literals also converted in phase 5? If so, why omit this from the draft standard?</li>\n<li>How are UCNs in identifiers (as opposed to in character/string literals as already mentioned) handled in both C11 and C++11? Are they also converted in phase 5? Or is this something implementation-defined? Does GCC for instance print out such identifiers in UCN-coded form, or in actual UTF-8?</li>\n</ol>\n", "Tags": "<c++><c><c++11><unicode><c11>", "OwnerUserId": "2809095", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_18972735_18972735_3": {"section_id": 5313, "quality": 1.0, "length": 25}, "so_18972735_18972735_0": {"section_id": 5313, "quality": 0.875, "length": 21}, "so_18972735_18972735_2": {"section_id": 5313, "quality": 0.8823529411764706, "length": 15}, "so_18972735_18972735_1": {"section_id": 5313, "quality": 0.92, "length": 69}}, "n3337": {"so_18972735_18972735_3": {"section_id": 5110, "quality": 1.0, "length": 25}, "so_18972735_18972735_0": {"section_id": 5110, "quality": 0.875, "length": 21}, "so_18972735_18972735_2": {"section_id": 5110, "quality": 0.8823529411764706, "length": 15}, "so_18972735_18972735_1": {"section_id": 5110, "quality": 0.92, "length": 69}}, "n4659": {"so_18972735_18972735_3": {"section_id": 6737, "quality": 1.0, "length": 25}, "so_18972735_18972735_0": {"section_id": 6737, "quality": 0.75, "length": 18}, "so_18972735_18972735_2": {"section_id": 6737, "quality": 0.8823529411764706, "length": 15}, "so_18972735_18972735_1": {"section_id": 6737, "quality": 0.84, "length": 63}}}});