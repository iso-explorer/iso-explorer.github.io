post_cb({"25101393": {"ParentId": "25100855", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Let's start from \u00a713.3.1.2 [over.match.oper]/p2-3:</p>\n<blockquote>\n<p id=\"so_25100855_25101393_0\">If either operand has a type that is a class or an enumeration, a\n  user-defined operator function might be declared that implements this\n  operator or a user-defined conversion can be necessary to convert the\n  operand to a type that is appropriate for a built-in operator. In this\n  case, overload resolution is used to determine which operator function\n  or built-in operator is to be invoked to implement the operator.</p>\n<p id=\"so_25100855_25101393_1\">[...]</p>\n<p id=\"so_25100855_25101393_2\">for a binary operator <code>@</code> with a left operand of a type whose\n  cv-unqualified version is <code>T1</code> and a right operand of a type whose\n  cv-unqualified version is <code>T2</code>, three sets of candidate functions,\n  designated member candidates, nonmember candidates and built-in\n  candidates, are constructed as follows:</p>\n<ul>\n<li>If T1 is a complete class type or a class currently being defined, the set of member candidates is the result of the qualified lookup of\n  <code>T1::operator@</code> (13.3.1.1.1); otherwise, the set of member candidates is\n  empty.</li>\n<li>The set of non-member candidates is the result of the unqualified lookup of <code>operator@</code> in the context of the expression according to the\n  usual rules for name lookup in unqualified function calls (3.4.2)\n  except that all member functions are ignored. [...]</li>\n<li>For the operator <code>,</code>, the unary operator <code>&amp;</code>, or the operator <code>-&gt;</code>, the built-in candidates set is empty. For all other operators, the\n  built-in candidates include all of the candidate operator functions\n  defined in 13.6 that, compared to the given operator,\n  <ul>\n<li>have the same operator name, and</li>\n<li>accept the same number of operands, and</li>\n<li>accept operand types to which the given operand or operands can be converted according to\n  13.3.3.1, and</li>\n<li>do not have the same parameter-type-list as any non-member candidate that is not a function template specialization.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So, given the expression <code>2.1 + a</code>, let's construct the candidate sets:</p>\n<ul>\n<li><code>T1</code> is <code>double</code>, not a class type, so the set of member candidates is empty.</li>\n<li><p>The non-member candidate set consists of:</p>\n<pre><code>Foo&lt;int&gt; operator+(Foo&lt;int&gt; lhs, const Foo&lt;int&gt;&amp; rhs);\n</code></pre>\n<p>(plus lots of other overloads for different instantiations of <code>Foo</code> that's obviously a worse match than this one.)</p></li>\n<li><p>The built-in candidate set consists of a long list of functions you can see in clang's output on your code, specified in \u00a713.6 [over.built]/p12:</p>\n<blockquote>\n<p id=\"so_25100855_25101393_3\">For every pair of promoted arithmetic types <code>L</code> and <code>R</code>, there exist\n  candidate operator functions of the form [...] <code>LR operator+(L , R );</code>\n  [...] where <code>LR</code> is the result of the usual arithmetic conversions\n  between types <code>L</code> and <code>R</code>.</p>\n</blockquote></li>\n</ul>\n<p>Overload resolution can succeed only if a unique best match can be found among this pile of candidates.</p>\n<p>First, note that of the numerous possible built-in operators below, none can possibly be the unique best match, because <code>Foo&lt;int&gt;</code> is convertible to every possible type of the right operand:</p>\n<pre><code>operator+(double, unsigned long long)\noperator+(double, unsigned long)\noperator+(double, unsigned int)\noperator+(double, __int128)\noperator+(double, long long)\noperator+(double, long)\noperator+(double, float)\noperator+(double, double)\noperator+(double, long double)\noperator+(double, int)\n</code></pre>\n<p>(I only listed ones whose first argument is of type <code>double</code>, since that's the type of the first argument, and hence the other built-ins can't possibly be better than any of those.)</p>\n<p>Thus, overload resolution can succeed if and only if your overload of <code>operator +</code> is a better match than every one of them. Without loss of generality, we consider the following two functions:</p>\n<pre><code>    operator+(double, int);  // built-in\n    Foo&lt;int&gt; operator+(Foo&lt;int&gt; lhs, const Foo&lt;int&gt;&amp; rhs); // overload\n</code></pre>\n<p>given an argument list of <code>(double, Foo&lt;int&gt;)</code>. For the first candidate, the first argument is an exact match, the second one requires a user-defined conversion. For the second candidate, the first argument requires a user-defined conversion, and the second one is an exact match. </p>\n<p>We thus have a criss-cross situation, which means that neither candidate function is better than the other. (The first requirement of one function F1 being better than the other F2 is that for each argument the conversion required for F1 is not worse than F2 - \u00a713.3.3 [over.match.best]/p2.)</p>\n<p>As a result, there's no unique best overload, overload resolution fails, and the program is ill-formed. Clang is correct in rejecting this code, and g++ is broken in failing to reject it.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-03T03:59:45.080", "Id": "25101393", "Score": "3", "CreationDate": "2014-08-03T03:37:00.980", "LastActivityDate": "2014-08-03T03:59:45.080"}, "25100855": {"CommentCount": "10", "ViewCount": "226", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2014-08-03T01:42:54.340", "LastActivityDate": "2014-08-03T04:07:47.437", "Title": "user-defined conversion operators precedence, compiles in g++ but not clang++", "AcceptedAnswerId": "25101393", "LastEditDate": "2014-08-03T02:00:02.397", "Id": "25100855", "Score": "2", "Body": "<p>I have the following code, which is a wrapper for POD into a template class <code>Foo&lt;T&gt;</code>, where <code>T</code> is the wrapped type (can be <code>int</code>, <code>double</code> etc). I define a templated conversion operator, and also the friend addition <code>operator+</code>, see code below. \nIn the last line of <code>main()</code>, I define <code>Foo&lt;int&gt; a = 10</code> then compute</p>\n<pre><code>cout &lt;&lt; 2.1 + a &lt;&lt; endl; // outputs 12\n</code></pre>\n<p>What is the rule here? It looks like the expression is being translated as </p>\n<pre><code>operator+(2.1, a)\n</code></pre>\n<p>which then becomes <code>operator+(Foo&lt;int&gt;(2.1), a)</code>. Why doesn't the compiler try to first convert <code>a</code> into a <code>double</code> then perform the addition? I.e. why don't we have the expression evaluated as </p>\n<pre><code>2.1 + a.operator double()\n</code></pre>\n<p>Thanks!</p>\n<p>PS: Just realized that <code>clang++</code> fails to compile the code, saying that overloaded call to <code>operator+</code> is ambiguous. However <code>g++4.9</code> compiles it without problems, even with all warning flags turned on.</p>\n<p>Code snippet below:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nclass Foo // wrapper class for a POD\n{\n    T val_; // this is the wrapped value\npublic:\n    Foo(T val = {}): val_(val) {};\n\n    template&lt;typename S&gt; // conversion operator\n    operator S ()\n    {\n        std::cout &lt;&lt; \"Calling conversion operator\" &lt;&lt; std::endl;\n        return val_;\n    }\n\n    // the += operator\n    Foo&amp; operator+=(const Foo&amp; rhs)\n    {\n        val_ += rhs.val_; \n        return *this;\n    }\n\n    // the + operator\n    friend Foo operator+(Foo lhs, const Foo&amp; rhs)\n    {\n        cout &lt;&lt; \"Calling operator+\" &lt;&lt; endl;\n        return lhs += rhs;\n    }\n\n    // stream operator\n    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Foo &amp;rhs)\n    {\n        return os &lt;&lt; rhs.val_;\n    }\n};\n\nint main()\n{\n    Foo&lt;int&gt; a = 10;\n\n    // operator+(2.1, a), why not\n    // 2.1 + a. operator int() ?\n    cout &lt;&lt; 2.1 + a &lt;&lt; endl; // outputs 12\n}\n</code></pre>\n", "Tags": "<c++><templates><c++11><operator-overloading>", "OwnerUserId": "3093378", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25100855_25101393_0": {"section_id": 583, "quality": 1.0, "length": 33}, "so_25100855_25101393_3": {"section_id": 686, "quality": 0.9, "length": 18}, "so_25100855_25101393_2": {"section_id": 584, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_25100855_25101393_0": {"section_id": 573, "quality": 1.0, "length": 33}, "so_25100855_25101393_3": {"section_id": 676, "quality": 0.9, "length": 18}, "so_25100855_25101393_2": {"section_id": 574, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_25100855_25101393_0": {"section_id": 606, "quality": 1.0, "length": 33}, "so_25100855_25101393_3": {"section_id": 715, "quality": 0.9, "length": 18}, "so_25100855_25101393_2": {"section_id": 607, "quality": 0.8888888888888888, "length": 24}}}, "25101194": {"ParentId": "25100855", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><strike>I don't have the manual handy, but C++ prefers to implicitly typecast <em>to</em> objects over typecasting <em>from</em> objects. In other words, it'll interpret <code>double + Foo&lt;int&gt;</code> as <code>Foo&lt;int&gt;(double) + Foo&lt;int&gt;</code> if <code>Foo&lt;int&gt;</code> has a constructor that can take a <code>double</code>. (\"Can take a <code>double</code>\" allows implicit typecasting of the <code>double</code> to other things like <code>int</code> <em>unless</em> the constructor in question is declared <code>explicit</code>.)</strike></p>\n<p><strike>If <code>Foo&lt;int&gt;</code> doesn't have a suitable constructor, only then would it consider calling <code>Foo&lt;int&gt;::operator double()</code> to degrade the object to a <code>double</code>... and I'm not even sure the language will even try that implicitly!</strike></p>\n<p>If you really want to make <code>double + Foo&lt;int&gt;</code> convert the <code>Foo&lt;int&gt;</code> to a <code>double</code> first, then add, you'll need to write:</p>\n<pre><code>double operator +(double a, const Foo&lt;int&gt;&amp; b)\n{\n    return a + double(b);\n}\n</code></pre>\n<p>or some kind of template equivalent. No <code>friend</code> declaration needed so long as <code>Foo&lt;int&gt;::operator double()</code> exists.</p>\n", "OwnerUserId": "2624511", "LastEditorUserId": "2624511", "LastEditDate": "2014-08-03T04:07:47.437", "Id": "25101194", "Score": "1", "CreationDate": "2014-08-03T02:53:16.347", "LastActivityDate": "2014-08-03T04:07:47.437"}});