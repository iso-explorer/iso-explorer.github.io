post_cb({"32804644": {"ParentId": "32803708", "CommentCount": "0", "Body": "<p>I can't seem to find a compelling passage or example in the standard that directly addresses the issue of calling a constexpr member function on a non-constexpr instance, but here are some that may be of help (from draft N4140):</p>\n<p><code>[C++14: 7.1.5/5]</code>:</p>\n<blockquote>\n<p id=\"so_32803708_32804644_0\">For a non-template, non-defaulted <code>constexpr</code> function or a non-template, non-defaulted, non-inheriting\n  <code>constexpr</code> constructor, if no argument values exist such that an invocation of the function or constructor\n  could be an evaluated subexpression of a core constant expression (5.19), the program is ill-formed; no\n  diagnostic required.</p>\n</blockquote>\n<pre><code>constexpr int f(bool b)\n    { return b ? throw 0 : 0; }       // OK\nconstexpr int f() { return f(true); } // ill-formed, no diagnostic required\n</code></pre>\n<p>From this I take that the program is not outright ill-formed just because a constexpr function has a possible non-constexpr path.</p>\n<p><code>[C++14: 5.19]</code>:</p>\n<pre><code>int x; // not constant\nstruct A {\n    constexpr A(bool b) : m(b?42:x) { }\n    int m;\n};\nconstexpr int v = A(true).m; // OK: constructor call initializes\n                             // m with the value 42\nconstexpr int w = A(false).m; // error: initializer for m is\n                              // x, which is non-constant\n</code></pre>\n<p>This is somewhat closer to your example programs, here a constexpr constructor may reference a non-constexpr variable depending on the value of the argument, but there is no error if this path is not actually taken.</p>\n<p>So I don't <em>think</em> either program you presented should be ill-formed, but I cannot offer convincing proof :)</p>\n", "OwnerUserId": "996886", "PostTypeId": "2", "Id": "32804644", "Score": "0", "CreationDate": "2015-09-27T04:41:01.163", "LastActivityDate": "2015-09-27T04:41:01.163"}, "32803708": {"CommentCount": "0", "ViewCount": "700", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2015-09-27T01:31:59.000", "LastActivityDate": "2015-09-27T13:19:42.753", "Title": "constexpr member functions that don't use this?", "AcceptedAnswerId": "32804642", "LastEditDate": "2015-09-27T04:06:25.077", "Id": "32803708", "Score": "5", "Body": "<p>Please consider the following two C++14 programs:</p>\n<p>Program 1:</p>\n<pre><code>struct S { constexpr int f() const { return 42; } };\nS s;\nint main() { constexpr int x = s.f(); return x; }\n</code></pre>\n<p>Program 2:</p>\n<pre><code>struct S { constexpr int f() const { return 42; } };\nint g(S s) { constexpr int x = s.f(); return x; }\nint main() { S s; return g(s); }\n</code></pre>\n<p>Are neither, either or both of these programs ill-formed?</p>\n<p>Why/why not?</p>\n", "Tags": "<c++><c++14><constexpr>", "OwnerUserId": "1131467", "AnswerCount": "3"}, "32804390": {"ParentId": "32803708", "LastEditDate": "2015-09-27T03:55:46.953", "CommentCount": "14", "CreationDate": "2015-09-27T03:50:33.663", "OwnerUserId": "2745183", "LastEditorUserId": "2745183", "PostTypeId": "2", "Id": "32804390", "Score": "-3", "Body": "<p>This sounds like a quiz question, and not presented by a student, but the professor testing the public on stackoverflow, but let's see...</p>\n<p>Let's start with the One Definition Rule. It's clear neither version violates that, so they both pass that part.</p>\n<p>Then, to syntax. Neither have syntax failures, they'll both compile without issue if you don't mind the potential blend of a syntax and semantic issue. </p>\n<p>First, the simpler semantic issue. This isn't a syntax problem, but <code>f()</code>, in both versions, is the member of a struct, and the function clearly makes no change to the owning struct, it's returning a constant. Although the function is declared constexpr, it is not declared as const, which means if there were some reason to call this as a runtime function, it would generate an error if that attempt were made on a const S. That affects both versions.</p>\n<p>Now, the potentially ambiguous <code>return g(S());</code> Clearly the outer g is a function call, but S may not be so clear as it would be if written <code>return g(S{});</code> With {} initializing S, there would be no ambiguity in the future should <code>struct S</code> be expanded with an operator() (the struct nearly resembles a functor already). The constructor invoked is automatically generated now, and there is no operator() to create confusion for the compiler at this version, but modern C++14 is supposed to offer clearer alternatives to avoid the \"Most Vexing Parse\", which g(S()) resembles. </p>\n<p>So, I'd have to say that based on semantic rules, they both fail (not so badly though). </p>\n", "LastActivityDate": "2015-09-27T03:55:46.953"}, "32804642": {"ParentId": "32803708", "LastEditDate": "2015-09-27T13:19:42.753", "CommentCount": "0", "CreationDate": "2015-09-27T04:40:41.657", "OwnerUserId": "951890", "LastEditorUserId": "951890", "PostTypeId": "2", "Id": "32804642", "Score": "2", "Body": "<p>Both programs are well-formed. The C++14 standard requires that <code>s.f()</code> be a constant expression because it is being used to initialize a <code>constexpr</code> variable, and in fact it is a core constant expression because there's no reason for it not to be.  The reasons that an expression might not be a core constant expression are listed in section 5.19 p2.  In particular, it states that the <strong>evaluation</strong> of the expression would have to do one of several things, none of which are done in your examples.</p>\n<p>This may be surprising since, in some contexts, passing a non-constant expression to a <code>constexpr</code> function can cause the result to be a non-constant expression even if the argument isn't used.  For example:</p>\n<pre><code>constexpr int f(int) { return 42; }\n\nint main()\n{\n    int x = 5;\n    constexpr y = f(x); // ill-formed\n}\n</code></pre>\n<p>however, the reason this is ill-formed is because of the lvalue-to-rvalue conversion of a non-constant expression, which is one of the things that the <strong>evaluation</strong> of the expression is not allowed to do.  An lvalue-to-rvalue conversion doesn't occur in the case of calling <code>s.f()</code>.</p>\n", "LastActivityDate": "2015-09-27T13:19:42.753"}, "bq_ids": {"n4140": {"so_32803708_32804644_0": {"section_id": 5421, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_32803708_32804644_0": {"section_id": 5216, "quality": 0.5925925925925926, "length": 16}}, "n4659": {"so_32803708_32804644_0": {"section_id": 6843, "quality": 0.7407407407407407, "length": 20}}}});