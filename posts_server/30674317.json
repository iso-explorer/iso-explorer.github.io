post_cb({"bq_ids": {"n4140": {"so_30674317_30675023_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 433}}, "n3337": {"so_30674317_30675023_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 425}}, "n4659": {"so_30674317_30675023_0": {"length": 38, "quality": 0.7037037037037037, "section_id": 4110}, "so_30674317_30674317_0": {"length": 38, "quality": 0.7037037037037037, "section_id": 4110}}}, "30674317": {"ViewCount": "379", "Body": "<p>I've got a test case where I have a class with 3 subobjects (<code>A</code>, <code>B</code> and <code>C</code>), and the 2nd subobject <code>B</code> throws an exception during construction. As I understand C++, the compiler should rewind the construction of the big class and destroy the 1st object <code>A</code>, but not the 2nd (<code>B</code>) or 3rd (<code>C</code>) objects.</p>\n<p>What I see is that if I use \"In-class initialization\" of the first object <code>A</code>, then instead of the first object <code>A</code> getting destroyed, <em>the 3rd object <code>C</code> gets destroyed</em>. Of course it is <strong>VERY BAD</strong> to destroy an object that has not been constructed!  If, for example, <code>C</code> was a <code>std:unique_ptr&lt;T&gt;</code>, it will probably signal a segmentation violation when it tries to free a garbage pointer.</p>\n<p>If I use old school \"member initialization\", then this problem doesn't happen.</p>\n<p>I don't see this with gcc 4.8</p>\n<p>Here's the code.  The class <code>D</code> exposes the bug. The class <code>E</code> should have identical function, but it does not expose the bug.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nstruct A {\n    A(const string&amp; x) : x_(x) { cout &lt;&lt; \"A::A()\" &lt;&lt; (void*)this &lt;&lt;endl; }\n    ~A() { cout &lt;&lt; \"A::~A() \" &lt;&lt; (void*)this&lt;&lt; endl;}\n    string x_;\n};\n\nstruct B {\n    B(const A&amp; a)  { cout &lt;&lt; \"B::B()\" &lt;&lt; endl; throw \"dead\"; }\n    ~B() { cout &lt;&lt; \"B::~B()\" &lt;&lt; endl;}\n};\n\nstruct C {\n    C()  { cout &lt;&lt; \"C::C()\" &lt;&lt; endl; }\n    ~C() { cout &lt;&lt; \"C::~C()\" &lt;&lt; endl;}\n};\n\n\nstruct D  {\n    A a{\"foo\"}; // \"new school In-class initialization\"\n    B b{a};\n    C c;\n    D() { cout &lt;&lt;\"D::D()\" &lt;&lt; endl; }\n    ~D() { cout &lt;&lt;\"D::~D()\" &lt;&lt; endl; }\n};\n\nstruct E {\n    A a;\n    B b;\n    C c;\n    E()\n        :a{\"foo\"}  // \"old school member initialization\"\n        ,b(a)\n        { cout &lt;&lt;\"E::E()\" &lt;&lt; endl; }\n    ~E() { cout &lt;&lt;\"E::~E()\" &lt;&lt; endl; }\n};\n\nint main()\n{\n   try {\n       D d;\n   }\n   catch(...)\n   {\n       cout &lt;&lt; \"got exception\" &lt;&lt; endl;\n   }\n\n   try {\n       E e;\n   }\n   catch(...)\n   {\n       cout &lt;&lt; \"got exception\" &lt;&lt; endl;\n   }\n\n   return 0;\n}\n</code></pre>\n<p>Here is the output. I expect to see <code>A</code> constructed, <code>B</code> partially constructed then throws, then <code>A</code> destroyed, but that is not what I see for the <code>D</code> case.</p>\n<pre><code>$ icpc -std=c++11 test.cpp\n$ ./a.out\nA::A()0x7fffe0a5ee90\nB::B()\nC::~C()\ngot exception\n\nA::A()0x7fffe0a5eea0\nB::B()\nA::~A() 0x7fffe0a5eea0\ngot exception\n</code></pre>\n<p>-- update --</p>\n<p>The section of the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4431.pdf\" rel=\"nofollow\">standard</a> that describes what should happen is 15.2.3</p>\n<blockquote>\n<p id=\"so_30674317_30674317_0\">For an object of class type of any storage duration whose\n  initialization or destruction is terminated by an exception, the\n  destructor is invoked for each of the object\u2019s fully constructed\n  subobjects, that is, for each subobject for which the principal\n  constructor (12.6.2) has completed execution and the destructor has\n  not yet begun execution, except that in the case of destruction, the\n  variant members of a union-like class are not destroyed. The\n  subobjects are destroyed in the reverse order of the completion of\n  their construction. Such destruction is sequenced before entering a\n  handler of the function-try-block of the constructor or destructor, if\n  any.</p>\n</blockquote>\n", "Title": "Intel 2015 compiler bug, RAII destruction not correct, is this a bug or am I doing something wrong?", "CreationDate": "2015-06-05T19:26:38.763", "LastActivityDate": "2015-06-05T22:17:50.240", "CommentCount": "1", "LastEditDate": "2015-06-05T20:30:57.947", "PostTypeId": "1", "LastEditorUserId": "364818", "Id": "30674317", "Score": "13", "OwnerUserId": "364818", "Tags": "<c++><c++11><icc>", "AnswerCount": "2"}, "30676614": {"Id": "30676614", "PostTypeId": "2", "Body": "<p>Intel has confirmed this is an issue.</p>\n<p>The compiler I used was</p>\n<pre><code>icpc (ICC) 15.0.2 20150121\n</code></pre>\n<p>You can follow the Intel forum for updates on when it is resolved.</p>\n<p><a href=\"https://software.intel.com/en-us/comment/1827356\" rel=\"nofollow\">https://software.intel.com/en-us/comment/1827356</a></p>\n", "LastActivityDate": "2015-06-05T22:17:50.240", "CommentCount": "0", "CreationDate": "2015-06-05T22:17:50.240", "ParentId": "30674317", "Score": "1", "OwnerUserId": "364818"}, "30675023": {"Id": "30675023", "PostTypeId": "2", "Body": "<p>This is definitely a compiler bug, and you've answered your own question with the correct reference from the standard: [except.ctor]/3, with added emphasis:</p>\n<blockquote>\n<p id=\"so_30674317_30675023_0\">For an object of class type of any storage duration whose initialization or destruction is terminated by an\n  exception, the destructor is invoked for each of the object\u2019s <strong>fully constructed</strong> subobjects, that is, for each\n  subobject for which the <strong>principal constructor (12.6.2) has completed execution</strong> and the destructor has not\n  yet begun execution, except that in the case of destruction, the variant members of a union-like class are not\n  destroyed. The subobjects are destroyed in the reverse order of the completion of their construction. Such\n  destruction is sequenced before entering a handler of the function-try-block of the constructor or destructor,\n  if any.</p>\n</blockquote>\n<p>Where:</p>\n<blockquote>\n<p id=\"so_30674317_30675023_1\">The <em>principal constructor</em> is the first constructor invoked\n  in the construction of an object (that is, not a target constructor for that object\u2019s construction).</p>\n</blockquote>\n<p><code>C</code> has not been fully constructed - its principal constructor has not even been called yet - so it's destructor should not be called yet. </p>\n", "LastActivityDate": "2015-06-05T20:12:03.270", "CommentCount": "2", "CreationDate": "2015-06-05T20:12:03.270", "ParentId": "30674317", "Score": "4", "OwnerUserId": "2069064"}});