post_cb({"11058422": {"CommentCount": "2", "AcceptedAnswerId": "11058463", "PostTypeId": "1", "LastEditorUserId": "384137", "CreationDate": "2012-06-15T21:28:01.280", "LastActivityDate": "2017-01-30T12:18:26.637", "LastEditDate": "2013-10-20T19:51:54.523", "ViewCount": "4845", "FavoriteCount": "0", "Title": "map operator [] and bool as value", "Id": "11058422", "Score": "18", "Body": "<p>We know that if we try to access a nonexistent key of <code>std::map</code> with the operator [] , the function will insert a new element with that key. </p>\n<p>We have: <code>std::map&lt;std::string, bool&gt; map_xxx;</code></p>\n<p>Is it guaranteed that after accessing the nonexistent key of <code>map_xxx[\"nonexistent_key\"]</code>, the value of the second argument will always be <code>false</code> ?</p>\n<p>ps. if no, any ideas how to have this behavior?</p>\n", "Tags": "<c++><stl><map>", "OwnerUserId": "1179191", "AnswerCount": "1"}, "11058463": {"ParentId": "11058422", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>Yes.  The value to be inserted is guaranteed to be <code>false</code>.</strong></p>\n<hr>\n<p>In C++98, the mechanism was called default initialization, specified as zero initialization for non-classes; that's <code>false</code> for Booleans.</p>\n<p>Since C++03, the mechanism is called value initialization, still specified as zero initialization for non-classes; and thus still <code>false</code> for Booleans.  For example, let's see what C++14 has to say on this.</p>\n<p>From \u00a723.4.4.3; just substitute <code>bool</code> for \"T\".</p>\n<blockquote>\n<p id=\"so_11058422_11058463_0\"><strong>T</strong>&amp; operator[](const key_type&amp; x);</p>\n<ol>\n<li>Effects: If there is no key equivalent to x in the map, inserts value_type(x, <strong>T()</strong>) into the map.</li>\n<li>Requires: key_type shall be CopyInsertable and mapped_type shall be DefaultInsertable into\n  *this.</li>\n</ol>\n</blockquote>\n<p>From \u00a78.5, digest the paragraphs from the bottom up:</p>\n<blockquote>\n<p id=\"so_11058422_11058463_1\">To zero-initialize an object or reference of type T means:</p>\n<p id=\"so_11058422_11058463_2\">\u2014 if T is a scalar type (3.9), the object is initialized to the value obtained by <strong>converting</strong> the integer literal <strong>0</strong> (zero) to T;</p>\n<p id=\"so_11058422_11058463_3\">...</p>\n<p id=\"so_11058422_11058463_4\">To <strong>value-initialize</strong> an object of type T means:</p>\n<p id=\"so_11058422_11058463_5\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is user-provided or deleted, then the object is default-initialized;</p>\n<p id=\"so_11058422_11058463_6\">\u2014 if T is a (possibly cv-qualified) class type without a user-provided or deleted default constructor, then the object is zero-initialized and the semantic constraints for default-initialization are checked, and if T has a non-trivial default constructor, the object is default-initialized;</p>\n<p id=\"so_11058422_11058463_7\">\u2014 if T is an array type, then each element is value-initialized;</p>\n<p id=\"so_11058422_11058463_8\">\u2014 otherwise, the object is <strong>zero-initialized</strong>.</p>\n<p id=\"so_11058422_11058463_9\">...</p>\n<p id=\"so_11058422_11058463_10\">An object whose initializer is an empty set of parentheses, i.e., <strong>()</strong>, shall be <strong>value-initialized</strong>.</p>\n</blockquote>\n<p>From \u00a74.12:</p>\n<blockquote>\n<p id=\"so_11058422_11058463_11\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. A <strong>zero value</strong>, null pointer value, or null member pointer value <strong>is converted to false</strong>; any other value is converted to true. For direct-initialization (8.5), a prvalue of type std::nullptr_t can be converted to a prvalue of type bool; the resulting value is false.</p>\n</blockquote>\n</hr>", "OwnerUserId": "1235565", "LastEditorUserId": "1235565", "LastEditDate": "2017-01-30T12:18:26.637", "Id": "11058463", "Score": "25", "CreationDate": "2012-06-15T21:30:52.350", "LastActivityDate": "2017-01-30T12:18:26.637"}, "bq_ids": {"n4140": {"so_11058422_11058463_4": {"section_id": 3287, "quality": 1.0, "length": 4}, "so_11058422_11058463_5": {"section_id": 3287, "quality": 0.9375, "length": 15}, "so_11058422_11058463_7": {"section_id": 3287, "quality": 1.0, "length": 6}, "so_11058422_11058463_11": {"section_id": 44, "quality": 0.975609756097561, "length": 40}, "so_11058422_11058463_2": {"section_id": 3285, "quality": 1.0, "length": 10}, "so_11058422_11058463_10": {"section_id": 3290, "quality": 1.0, "length": 7}, "so_11058422_11058463_1": {"section_id": 3285, "quality": 1.0, "length": 5}, "so_11058422_11058463_6": {"section_id": 3287, "quality": 1.0, "length": 20}}, "n3337": {"so_11058422_11058463_4": {"section_id": 3157, "quality": 1.0, "length": 4}, "so_11058422_11058463_5": {"section_id": 3157, "quality": 0.6875, "length": 11}, "so_11058422_11058463_7": {"section_id": 3157, "quality": 1.0, "length": 6}, "so_11058422_11058463_11": {"section_id": 41, "quality": 0.9512195121951219, "length": 39}, "so_11058422_11058463_2": {"section_id": 3155, "quality": 0.6, "length": 6}, "so_11058422_11058463_10": {"section_id": 3160, "quality": 1.0, "length": 7}, "so_11058422_11058463_1": {"section_id": 3155, "quality": 1.0, "length": 5}}, "n4659": {"so_11058422_11058463_6": {"section_id": 4049, "quality": 1.0, "length": 20}, "so_11058422_11058463_7": {"section_id": 4049, "quality": 1.0, "length": 6}, "so_11058422_11058463_11": {"section_id": 45, "quality": 0.975609756097561, "length": 40}, "so_11058422_11058463_2": {"section_id": 4047, "quality": 1.0, "length": 10}, "so_11058422_11058463_5": {"section_id": 4049, "quality": 0.9375, "length": 15}, "so_11058422_11058463_10": {"section_id": 4052, "quality": 1.0, "length": 7}, "so_11058422_11058463_1": {"section_id": 653, "quality": 0.8, "length": 4}}}});