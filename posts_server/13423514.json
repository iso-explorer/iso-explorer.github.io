post_cb({"13423817": {"ParentId": "13423514", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>C++11, \u00a727.7.2.4/1:</p>\n<blockquote>\n<p id=\"so_13423514_13423817_0\">If <code>ws</code> stops extracting characters because there are no more available it sets <code>eofbit</code>, but not <code>failbit</code>.</p>\n</blockquote>\n<p>So, the <code>ws</code> manipulator doesn't set <code>failbit</code> directly. However, as Marshall Clow points out in his answer, it doesn't have to--it is required to create a sentry object, and the sentry object is required to set the failbit if <code>!stream.good()</code>.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2016-12-27T19:49:47.303", "Id": "13423817", "Score": "3", "CreationDate": "2012-11-16T20:18:05.260", "LastActivityDate": "2016-12-27T19:49:47.303"}, "13423514": {"CommentCount": "1", "ViewCount": "407", "CreationDate": "2012-11-16T19:56:33.520", "LastActivityDate": "2016-12-27T19:49:47.303", "Title": "Should std::ws raise failbit at end of file?", "AcceptedAnswerId": "13423817", "PostTypeId": "1", "Id": "13423514", "Score": "9", "Body": "<p><strong>Should extracting from a stream using the std::ws manipulator ever raise the fail bit?</strong> In the following code, a Clang-compiled (within Xcode 4.5.1) program fails the final assertion. Evidently <code>s &gt;&gt; std::ws</code> at EOF causes a fail. Yet GCC 4.7.2 passes the assertion. Which is correct?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;cassert&gt;\n\nint main(int argc, const char * argv[])\n{\n    {\n        // Read string with trailing ws.\n        std::istringstream s( \"test   \" );\n        std::string test;\n\n        s &gt;&gt; std::ws;\n        assert( !s.fail() );    // No ws to skip, but no failure.\n\n        s &gt;&gt; test;\n        assert( test == \"test\" );\n        assert( !s.fail() );\n\n        s &gt;&gt; std::ws;\n        assert( !s.fail() );    // No prob skipping trailing ws.\n    }\n    {\n        // Retry with no trailing ws.\n        std::istringstream s( \"test\" );\n        std::string test;\n\n        s &gt;&gt; std::ws;\n        assert( !s.fail() );    // No ws to skip, but no failure.\n\n        s &gt;&gt; test;\n        assert( test == \"test\" );\n        assert( !s.fail() );\n\n        s &gt;&gt; std::ws;\n        assert( !s.fail() );    // CLANG: Skipping absent ws at eof raises failbit.\n    }\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><gcc><clang><iostream><manipulators>", "OwnerUserId": "358475", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13423514_23201350_1": {"section_id": 2181, "quality": 0.9166666666666666, "length": 11}, "so_13423514_23201350_2": {"section_id": 2181, "quality": 0.8, "length": 4}, "so_13423514_23201350_3": {"section_id": 2182, "quality": 0.9, "length": 9}, "so_13423514_23201350_0": {"section_id": 2252, "quality": 0.9107142857142857, "length": 51}, "so_13423514_13423817_0": {"section_id": 2252, "quality": 1.0, "length": 11}}, "n3337": {"so_13423514_23201350_1": {"section_id": 2169, "quality": 0.9166666666666666, "length": 11}, "so_13423514_23201350_2": {"section_id": 2169, "quality": 0.8, "length": 4}, "so_13423514_23201350_3": {"section_id": 2170, "quality": 0.9, "length": 9}, "so_13423514_23201350_0": {"section_id": 2240, "quality": 0.9107142857142857, "length": 51}, "so_13423514_13423817_0": {"section_id": 2240, "quality": 1.0, "length": 11}}, "n4659": {"so_13423514_23201350_1": {"section_id": 2454, "quality": 0.9166666666666666, "length": 11}, "so_13423514_23201350_2": {"section_id": 2454, "quality": 0.8, "length": 4}, "so_13423514_23201350_3": {"section_id": 2455, "quality": 0.9, "length": 9}, "so_13423514_23201350_0": {"section_id": 2525, "quality": 0.875, "length": 49}, "so_13423514_13423817_0": {"section_id": 2525, "quality": 1.0, "length": 11}}}, "23201350": {"ParentId": "13423514", "CommentCount": "5", "Body": "<p>I believe that libc++ is implementing the standard correctly.</p>\n<p>[ I'm quoting from N3290, which is the draft C++11 standard. C++14 does not change this. ]</p>\n<p><code>ws</code> is described in [istream.manip], which states:</p>\n<blockquote>\n<p id=\"so_13423514_23201350_0\">Effects: Behaves as an unformatted input function (as described in\n  27.7.2.3, paragraph 1), except that it does not count the number of \n  characters extracted and does not affect the value returned by\n  subsequent calls to is.gcount(). After constructing a sentry object\n  extracts characters as long as the next available character c is\n  whitespace or until there are no more characters in the sequence.\n  Whitespace characters are distinguished with the same criterion as\n  used by sentry::sentry (27.7.2.1.3). If ws stops extracting characters\n  because there are no more available it sets eofbit, but not fail bit.</p>\n</blockquote>\n<p>The key phrase here for determining the correct behavior is \"after constructing a sentry object\".</p>\n<p>Sentry objects are described in [istream::sentry], and the text there begins...</p>\n<blockquote>\n<p id=\"so_13423514_23201350_1\">1 The class sentry defines a class that is responsible for doing exception safe prefix and suffix operations. </p>\n<p id=\"so_13423514_23201350_2\">explicit sentry(basic_istream&amp; is, bool noskipws = false);</p>\n<p id=\"so_13423514_23201350_3\">2 Effects: If is.good() is false, calls is.setstate(failbit). Otherwise, prepares for \n  formatted or &gt; unformatted input. ...<em>and so on</em>...</p>\n</blockquote>\n<p>That's the only sentry constructor that is available, so that's the one that libc++ uses.</p>\n<p>So the fail bit gets set before extracts any characters, so the text at the end of the paragraph does not apply. if the stream contained <code>\" \"</code> (i.e, a single space at the end), then calling <code>std::ws</code> does not set the fail bit, just eof (which is what the OP expected to happen).</p>\n", "OwnerUserId": "992490", "PostTypeId": "2", "Id": "23201350", "Score": "4", "CreationDate": "2014-04-21T16:24:23.540", "LastActivityDate": "2014-04-21T16:24:23.540"}});