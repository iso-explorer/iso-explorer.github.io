post_cb({"7530548": {"ParentId": "7530476", "CommentCount": "1", "CreationDate": "2011-09-23T14:26:07.447", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "7530548", "Score": "1", "Body": "<p>No, this is undefined behavior regardless of whether or not the item has a trivial destructor. If the destructor is trivial it may <em>appear</em> to \"work\" when in fact it's leaking memory, etc.</p>\n", "LastActivityDate": "2011-09-23T14:26:07.447"}, "7530505": {"ParentId": "7530476", "CommentCount": "2", "CreationDate": "2011-09-23T14:23:06.140", "OwnerUserId": "469935", "PostTypeId": "2", "Id": "7530505", "Score": "8", "Body": "<p>This doesn't <em>work</em> in any case, if we assume <em>work</em> means having well-defined behavior rather than appearing to work (i.e. not crashing)</p>\n", "LastActivityDate": "2011-09-23T14:23:06.140"}, "bq_ids": {"n4140": {"so_7530476_7531156_0": {"section_id": 6106, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_7530476_7531156_0": {"section_id": 5872, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_7530476_7531156_0": {"section_id": 7603, "quality": 0.8666666666666667, "length": 13}}}, "7531156": {"ParentId": "7530476", "CommentCount": "0", "CreationDate": "2011-09-23T15:07:39.357", "OwnerUserId": "293791", "PostTypeId": "2", "Id": "7531156", "Score": "1", "Body": "<p>I'm going to say this is somewhere between implementation defined and undefined.  </p>\n<blockquote>\n<p id=\"so_7530476_7531156_0\">5.3.5/2: \"In the first alternative (delete object), the value of the\n  operand of delete may be ... a pointer to a\n  non-array object created by a previous new-expression ... .</p>\n</blockquote>\n<p>The value of the pointer does not change when used the way you did so, so this should work as expected, provided <code>sizeof(char*) == sizeof(int*)</code>.  The result of that particular comparison is implementation defined, and if the assumption is false then the behavior is undefined.</p>\n<p>So it really really isn't particularly safe.</p>\n", "LastActivityDate": "2011-09-23T15:07:39.357"}, "7530476": {"CommentCount": "1", "ViewCount": "496", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2011-09-23T14:20:47.323", "LastActivityDate": "2015-08-12T17:39:30.223", "Title": "Deleting an aliased pointer", "AcceptedAnswerId": "7530505", "LastEditDate": "2015-08-12T17:39:30.223", "Id": "7530476", "Score": "3", "Body": "<p>Doing this:</p>\n<pre><code> union{\n     int * integer;\n     char * character;\n } u;\n u.integer = new int;\n delete u.character;\n\n u.integer = new int[5];\n delete [] u.character;\n</code></pre>\n<p>I assume this wouldn't work if any of these types have non trivial destructors, but is this ok?</p>\n", "Tags": "<c++><pointers><unions><delete-operator>", "OwnerUserId": "333749", "AnswerCount": "4"}, "7540720": {"ParentId": "7530476", "CommentCount": "0", "CreationDate": "2011-09-24T17:43:16.643", "OwnerUserId": "801651", "PostTypeId": "2", "Id": "7540720", "Score": "0", "Body": "<p>It is easy to see this is a dangerous error. The two types might have completely different and incompatible ways of memory allocation and deallocation. This includes padding, garbage collection, bookkeeping, class-specific memory manipulation, etc. Just don't do it.</p>\n<pre><code>#include &lt;cstddef&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A\n{\n\n    public:\n\n        void* operator new (size_t size)\n        {\n            cout &lt;&lt; \"A::operator new (size_t)\" &lt;&lt; endl;\n            return malloc(size);\n        }\n\n        void* operator new [] (size_t size)\n        {\n            cout &lt;&lt; \"A::operator new [] (size_t)\" &lt;&lt; endl;\n            return malloc(size);\n        }\n\n        void operator delete (void* ptr)\n        {\n            cout &lt;&lt; \"A::operator delete (void*)\" &lt;&lt; endl;\n            free(ptr);\n        }\n\n        void operator delete [] (void* ptr)\n        {\n            cout &lt;&lt; \"A::operator delete [] (void*)\" &lt;&lt; endl;\n            free(ptr);\n        }\n\n};\n\nclass B\n{\n\n    public:\n\n        void* operator new (size_t size)\n        {\n            cout &lt;&lt; \"B::operator new (size_t) with some B-specific stuff\" &lt;&lt; endl;\n            return malloc(size);\n        }\n\n        void* operator new [] (size_t size)\n        {\n            cout &lt;&lt; \"B::operator new [] (size_t) with some B-specific stuff\" &lt;&lt; endl;\n            return malloc(size);\n        }\n\n        void operator delete (void* ptr)\n        {\n            cout &lt;&lt; \"B::operator delete (void*) with some B-specific stuff\" &lt;&lt; endl;\n            free(ptr);\n        }\n\n        void operator delete [] (void* ptr)\n        {\n            cout &lt;&lt; \"B::operator delete [] (void*) with some B-specific stuff\" &lt;&lt; endl;\n            free(ptr);\n        }\n\n};\n\n\nint main (int, char**)\n{\n\n    union{\n        A* a;\n        B* b;\n    } u;\n\n    u.a = new A();\n    delete u.b;\n\n    u.a = new A[5];\n    delete [] u.b;\n\n}\n</code></pre>\n", "LastActivityDate": "2011-09-24T17:43:16.643"}});