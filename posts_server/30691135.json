post_cb({"bq_ids": {"n4140": {"so_30691135_30692887_8": {"length": 25, "quality": 0.8928571428571429, "section_id": 1148}, "so_30691135_30692887_12": {"length": 28, "quality": 0.8484848484848485, "section_id": 5832}, "so_30691135_30692887_7": {"length": 13, "quality": 1.0, "section_id": 5819}, "so_30691135_30692887_6": {"length": 13, "quality": 1.0, "section_id": 5819}, "so_30691135_30692887_4": {"length": 15, "quality": 1.0, "section_id": 1158}, "so_30691135_30692887_2": {"length": 13, "quality": 1.0, "section_id": 5819}, "so_30691135_30692887_10": {"length": 15, "quality": 1.0, "section_id": 5818}, "so_30691135_30692887_3": {"length": 21, "quality": 0.84, "section_id": 5819}, "so_30691135_30691135_0": {"length": 15, "quality": 1.0, "section_id": 1158}, "so_30691135_30691135_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 5819}, "so_30691135_30692887_9": {"length": 13, "quality": 1.0, "section_id": 5818}, "so_30691135_30692887_11": {"length": 14, "quality": 0.8235294117647058, "section_id": 5821}, "so_30691135_30692887_1": {"length": 15, "quality": 0.6, "section_id": 1222}}, "n3337": {"so_30691135_30692887_12": {"length": 28, "quality": 0.8484848484848485, "section_id": 5603}, "so_30691135_30692887_4": {"length": 15, "quality": 1.0, "section_id": 1156}, "so_30691135_30692887_7": {"length": 13, "quality": 1.0, "section_id": 5590}, "so_30691135_30692887_6": {"length": 13, "quality": 1.0, "section_id": 5590}, "so_30691135_30692887_8": {"length": 25, "quality": 0.8928571428571429, "section_id": 1145}, "so_30691135_30692887_2": {"length": 13, "quality": 1.0, "section_id": 5590}, "so_30691135_30692887_10": {"length": 15, "quality": 1.0, "section_id": 5589}, "so_30691135_30692887_3": {"length": 21, "quality": 0.84, "section_id": 5590}, "so_30691135_30691135_0": {"length": 15, "quality": 1.0, "section_id": 1156}, "so_30691135_30691135_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 5590}, "so_30691135_30692887_9": {"length": 13, "quality": 1.0, "section_id": 5589}, "so_30691135_30692887_11": {"length": 14, "quality": 0.8235294117647058, "section_id": 5592}, "so_30691135_30692887_1": {"length": 15, "quality": 0.6, "section_id": 1220}}, "n4659": {"so_30691135_30692887_12": {"length": 28, "quality": 0.8484848484848485, "section_id": 7294}, "so_30691135_30692887_4": {"length": 15, "quality": 1.0, "section_id": 1252}, "so_30691135_30692887_7": {"length": 7, "quality": 0.5384615384615384, "section_id": 7290}, "so_30691135_30692887_6": {"length": 12, "quality": 0.9230769230769231, "section_id": 7280}, "so_30691135_30692887_8": {"length": 25, "quality": 0.8928571428571429, "section_id": 1242}, "so_30691135_30692887_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 7280}, "so_30691135_30692887_10": {"length": 15, "quality": 1.0, "section_id": 7279}, "so_30691135_30691135_0": {"length": 15, "quality": 1.0, "section_id": 1252}, "so_30691135_30691135_1": {"length": 14, "quality": 0.5384615384615384, "section_id": 7280}, "so_30691135_30692887_9": {"length": 13, "quality": 1.0, "section_id": 7279}, "so_30691135_30692887_11": {"length": 14, "quality": 0.8235294117647058, "section_id": 7282}, "so_30691135_30692887_1": {"length": 15, "quality": 0.6, "section_id": 1311}}}, "30691672": {"Id": "30691672", "PostTypeId": "2", "Body": "<p>I think what you're missing is that <code>test_and_set</code> is atomic, period. There is no memory ordering setting that makes this operation not atomic. If all we needed was an atomic test and set, we could specify any memory ordering.</p>\n<p>However, in this case, we need more than just an atomic \"test and set\" operation. We need to ensure that memory operations we performed after we confirmed that the lock was ours to take aren't re-ordered to before we observed the mutex to be unlocked. (Because those operations won't be atomic operations.)</p>\n<p>Consider:</p>\n<ol>\n<li>Some reads of data not protected by the mutex.</li>\n<li>Some writes to data not protected by the mutex.</li>\n<li>We try to lock the mutex.</li>\n<li>We see the mutex as locked and fail to lock it.</li>\n<li>We see the mutex as unlocked and atomically lock it.</li>\n<li>Some reads of data protected by the mutex.</li>\n<li>Some writes to data protected by the mutex.</li>\n</ol>\n<p>What is the one thing that must not happen? It's that the reads and writes in step 6 and 7 somehow get re-ordered to before step 5, stepping on another thread accessing shared data under protection of the mutex.</p>\n<p>The <code>test_and_set</code> operation is already atomic, so steps 4 and 5 are inherently safe. And steps 1 and 2 can't modify protected data (because they occur before we even try to lock) so there's no harm in re-ordering them around our lock operation.</p>\n<p>But steps 6 and 7 -- those must not be re-ordered to prior to us observing that the lock was unlocked so that we could atomically lock it. That would be a catastrophe.</p>\n<p>The definition of memory_order_acquire: \"<em>A load operation with this memory order performs the acquire operation on the affected memory location: no memory accesses in the current thread can be reordered before this load.</em>\"</p>\n<p>Exactly what we need.</p>\n", "LastEditorUserId": "721269", "LastActivityDate": "2015-06-09T17:52:02.590", "Score": "14", "CreationDate": "2015-06-07T08:48:52.640", "ParentId": "30691135", "CommentCount": "20", "OwnerUserId": "721269", "LastEditDate": "2015-06-09T17:52:02.590"}, "30691253": {"Id": "30691253", "PostTypeId": "2", "Body": "<p>As you said, <code>test_and_set</code> is a RMW operation. However, for testing it is only important that the correct value is read. Thus, <code>memory_order_acquire</code> seems sufficient.</p>\n<p>See also table <code>Constants</code> in <a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/atomic/memory_order</a></p>\n", "LastEditorUserId": "2516756", "LastActivityDate": "2015-06-07T08:04:35.800", "Score": "1", "CreationDate": "2015-06-07T07:48:33.710", "ParentId": "30691135", "CommentCount": "8", "OwnerUserId": "2516756", "LastEditDate": "2015-06-07T08:04:35.800"}, "30691135": {"ViewCount": "1693", "Body": "<p>There is a popular spin-lock mutex version which is spreaded across the Internet and which one might encounter in the Anthony Williams book(C++ Concurrency in Action). Here it is:</p>\n<pre><code>class SpinLock\n{\n    std::atomic_flag locked;\npublic:\n    SpinLock() :\n        locked{ATOMIC_FLAG_INIT}\n    {\n    }\n    void lock() \n    {\n        while(locked.test_and_set(std::memory_order_acquire));\n    }\n    void unlock() \n    {\n        locked.clear(std::memory_order_release);\n    }\n};\n</code></pre>\n<p>The thing I do not understand is why everybody uses <code>std::memory_order_acquire</code> for the <code>test_and_set</code> which is an RMW operation. Why is it not <code>std::memory_acq_rel</code>?\nSuppose we have 2 threads simultaneously trying to acquire a lock:</p>\n<pre><code>T1: test_and_set -&gt; ret false\nT2: test_and_set -&gt; ret false\n</code></pre>\n<p>The situation should be possible since we have 2 <code>acquire</code> operations which don't form any <code>sync with</code> relationship between each other. Yes, after we have unlocked the mutex we have a <code>release</code> operation which heads a subsequent <code>release sequence</code> and life becomes colorful and everyone is happy. But why is it safe before the <code>release sequence</code> is headed?</p>\n<p>Since many people mention exactly that implementation I suppose it should work correctly. So what am I missing?</p>\n<p><strong>UPDATE 1:</strong></p>\n<p>I perfectly understand that the operation is atomic, that operations between <code>lock</code> and <code>unlock</code> can't go out of the critical section. This is not a problem. The problem is that I don't see how the code above prevents 2 mutexes coming into the critical section <em>simultaneously</em>. To prevent it from happening there should be <em>happens before</em> relationship between 2 <code>lock</code>s. Could someone show me, using the C++ standard notions, that the code is perfectly safe?</p>\n<p><strong>UPDATE 2:</strong></p>\n<p>Ok, we are close to the correct answer, I believe. I've found the following in the standard:</p>\n<p><strong>[atomics.order] clause 11</strong></p>\n<blockquote>\n<p id=\"so_30691135_30691135_0\">Atomic read-modify-write operations shall always read the last value\n  (<strong>in the modification order</strong>) written before the write associated with\n  the read-modify-write operation.</p>\n</blockquote>\n<p>And on this major note I could happily close the question but I still have my doubts. What about <code>in the modification order</code> part?\nStandard is pretty clear about it:</p>\n<p><strong>[intro.multithread] clause 8</strong></p>\n<blockquote>\n<p id=\"so_30691135_30691135_1\">All modifications to a particular atomic object M occur in some\n  particular total order, called the modification order of M . If A and\n  B are modifications of an atomic object M and A <strong>happens before</strong>(as defined \n  below) B, then A shall precede B in the modification order of M ,\n  which is defined below.</p>\n</blockquote>\n<p>So according to that clause for an RMW operation to have the latest written value, the latest write operation should <em>happen before</em> the reading part or RMW operation. Which is not the case in the question. Right?</p>\n<p><strong>UPDATE 3:</strong></p>\n<p>I more and more think that the code for a spin lock is broken. Here is my reasoning. C++ specify 3 types of operations:</p>\n<ul>\n<li>Acquire, release, acquire-release - these are sync ops.</li>\n<li>Relaxed - these are no sync ops</li>\n<li>RMW - these are operations with \"special\" characteristic</li>\n</ul>\n<p>Let's start with RMW and find out what so special about them. First, they are a valuable asset in forming <code>release sequence</code>, second they have a special clause([atomics.order] clause 11) cited above. Nothing else special I found.</p>\n<p>Acquire/release are sync ops and <code>release sync with acquire</code> so forming a <code>happens before</code> relationship. Relaxed operations are just plain atomics and don't participate in the modification order at all. </p>\n<p>What we have in our code? We have an RMW operation which uses acquire memory semantics so whenever first unlock(release) is reached it serves 2 roles: </p>\n<ol>\n<li>It forms a <code>sync with</code> relationship with the previous <code>release</code></li>\n<li>It participates in the <code>release sequence</code>.\nBut that's all true only after the first <code>unlock</code> has finished.</li>\n</ol>\n<p>Before that, if we have 2+ threads which are simultaneously running our <code>lock</code> code then we can enter pass the <code>lock</code> simultaneously since 2 <code>acquire</code> operations don't form any kind of relationship. They are as unordered as relaxed operations would. Since they are unordered we can't use any special clauses about RMW operations since there is no <code>happens before</code> relationship and hence no modification order for the <code>locked</code> flag.</p>\n<p>So either my logic is flawed or code is broken. Please, whoever knows the truth - comment on this.</p>\n", "AcceptedAnswerId": "30692887", "Title": "Basic spin-lock mutex implementation ordering", "CreationDate": "2015-06-07T07:26:31.990", "Id": "30691135", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-06-08T05:48:04.503", "LastEditorUserId": "643393", "LastActivityDate": "2016-12-02T12:07:58.867", "Score": "16", "OwnerUserId": "643393", "Tags": "<c++><multithreading><atomic>", "AnswerCount": "3"}, "30692887": {"Id": "30692887", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_30691135_30692887_0\">Could someone show me, using the C++ standard notions, that the code is perfectly safe?</p>\n</blockquote>\n<p>I initially had the same concerns as you. I think the key is understanding that operations on the <code>std::atomic_flag</code> variable are atomic with respect to all processors/cores. Two atomic 'test and set' operations in separate threads cannot simultaneously succeed, regardless of the memory ordering specified, since they then could not be atomic; the operation must apply to the actual variable, not a <em>cached local copy</em> (which is, I think, not even a concept in C++).</p>\n<p><strong>A full chain of reasoning:</strong></p>\n<p>29.7 p5 (talking about the test-and-set operation):</p>\n<blockquote>\n<p id=\"so_30691135_30692887_1\">Effects: Atomically sets the value pointed to by object or by this to true. Memory is affected according to the value of order. These operations are atomic read-modify-write operations (1.10).\n  Returns: Atomically, the value of the object immediately before the effects.</p>\n</blockquote>\n<p>1.10 p6:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_2\">All modifications to a particular atomic object M occur in some particular total order, called the modification order of M ...</p>\n</blockquote>\n<p>So, if as this case two threads attempt to lock the spinlock at the same time, one of them must be first and the other one second. We now just need to show that the second one will by necessity return that the flag was already set, thus preventing that thread from entering the critical section.</p>\n<p>Paragraph 6 goes on to say:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_3\">... If A and B are modifications of an atomic object M and A happens before (as defined below) B, then A shall precede B in the modification order of M , which is defined below. [ Note: This states that the modification orders must respect the \u201chappens before\u201d relationship. \u2014 end note ]</p>\n</blockquote>\n<p>There is no \"happens before\" relationship between the two test-and-set operations happening in the two threads, so we cannot determine which comes first in the modification order; however, due to the first sentence in p6 (which states that there is a total ordering), one must definitely come before the other. Now, from 29.3 p12:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_4\">Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.</p>\n</blockquote>\n<p>This shows that the test-and-set ordered second must see the value written by the test-and-set ordered first. Any acquire/release choices do not affect this.</p>\n<p><em>Therefore, if two test-and-set operations are performed \"simultaneously\", they will be given an arbitrary order, and the second shall see the flag value that was set by the first.</em> As such the memory order constraints specified for the test-and-set operation do not matter; they are used to control ordering of writes to other variables during the period where the spinlock is acquired.</p>\n<p><strong>Response to \"Update 2\" of the question:</strong></p>\n<blockquote>\n<p id=\"so_30691135_30692887_5\">So according to that clause for an RMW operation to have the latest written value, the latest write operation should happen before the reading part or RMW operation. Which is not the case in the question. Right?</p>\n</blockquote>\n<p>Correct that there is no \"happen before\" relationship, but incorrect that an RMW operation needs such a relationship in order to be guaranteed the latest written value. The statement you list as \"[atomics.order] clause 11\" does not require a \"happens before\" relationship, just that one operation is before the other in the \"modification order\" for the atomic flag. Clause 8 states that there will be such an order, and it will be a total ordering:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_6\">All modifications to a particular atomic object M occur in some particular total order, called the modification order of M ...</p>\n</blockquote>\n<p>... it then goes on to say that the total ordering must be consistent with any \"happens before\" relationships:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_7\">... If A and B are modifications of an atomic object M and A happens before (as defined below) B, then A shall precede B in the modification order of M, which is defined below.</p>\n</blockquote>\n<p>However, in the absence of a \"happens before\" relationship, there is still a total ordering - it's just that this ordering has a degree of arbitrariness. That is, if there is no \"happens before\" relationship between A and B, then it is not specified whether A is ordered before or after B. But it must be one or the other, because there is a <strong>particular total order</strong>.</p>\n<p><strong>Why is memory_order_acquire needed, then?</strong></p>\n<p>A mutex such as a spinlock is often used to protect other, non-atomic variables and data structures. Using <code>memory_order_acquire</code> when locking the spinlock assures that a read from such variables will see the correct values (i.e. the values written by any other thread that previously held the spinlock). For the unlock, <code>memory_order_release</code> is also needed in order to allow other threads to see the written values.</p>\n<p>The acquire/release both prevent the compiler from re-ordering reads/writes past the acquisition/release of the lock, and ensure that any necessary instructions to ensure appropriate levels of cache coherency are generated.</p>\n<p><strong>Further evidence:</strong></p>\n<p>First, this note from 29.3:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_8\">Note: Atomic operations specifying memory_order_relaxed are relaxed with respect to memory ordering. Implementations must still guarantee that any given atomic access to a particular atomic object be indivisible with respect to all other atomic accesses to that object. \u2014 end note</p>\n</blockquote>\n<p>This is essentially saying that the memory ordering specified does not affect the atomic operation itself. The access must \"be indivisible with respect to all other atomic accesses\" <em>including those from other threads</em>. To allow two test-and-set operations to read the same value would effectively be dividing at least one of them, so that it was no longer atomic.</p>\n<p>Also, from 1.10 paragraph 5:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_9\">In addition, there are relaxed atomic operations, which are not synchronization operations, and atomic read-modify-write operations, which have special characteristics.</p>\n</blockquote>\n<p>(A test-and-set falls into this latter category) and especially:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_10\">\u201cRelaxed\u201d atomic operations are not synchronization operations even though, like synchronization operations, <em>they cannot contribute to data races</em>.</p>\n</blockquote>\n<p>(emphasis mine). A case where two threads both simultaneously executed an atomic test-and-set (and both performed the 'set' part) would be such a data race, so this text again indicates that this cannot happen.</p>\n<p>1.10 p8:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_11\">Note: The specifications of the synchronization operations define when one reads the value written by another. For atomic objects, the definition is clear.</p>\n</blockquote>\n<p>It means one <em>thread</em> reads the value written by another. It says that for atomic objects the definition is clear, meaning that <em>no other synchronisation is necessary</em> - it is enough to perform the operation on the atomic object; the effect will be seen immediately by other threads.</p>\n<p>In particular, 1.10 p19:</p>\n<blockquote>\n<p id=\"so_30691135_30692887_12\">[ Note: The four preceding coherence requirements effectively disallow compiler reordering of atomic operations to a single object, even if both operations are relaxed loads. This effectively makes the cache coherence\n  guarantee provided by most hardware available to C ++ atomic operations. \u2014 end note ]</p>\n</blockquote>\n<p>Note the mention of <em>cache coherence</em> even in the presence of relaxed loads. This clearly shows that the test-and-set can only succeed in one thread at a time, since for one to fail either cache coherence is broken or the operation is not atomic.</p>\n", "LastEditorUserId": "388661", "LastActivityDate": "2016-12-02T12:07:58.867", "Score": "11", "CreationDate": "2015-06-07T11:16:58.103", "ParentId": "30691135", "CommentCount": "17", "OwnerUserId": "388661", "LastEditDate": "2016-12-02T12:07:58.867"}});