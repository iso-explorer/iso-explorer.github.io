post_cb({"25524490": {"Id": "25524490", "PostTypeId": "2", "Body": "<p>As floating point operations are implemented at a low level by CPUs, the C++ standard does not mandate a size for either a <code>float</code>, <code>double</code> or <code>long double</code>. All it says is that the order I specified them is in equal or increasing order of precision.</p>\n<p>Your best bet is to use <code>static_assert</code>, <code>sizeof</code>, <code>typedef</code> and <code>#define</code> carefully in order to define cross platform floating point types.</p>\n", "LastActivityDate": "2014-08-27T10:15:54.657", "Score": "2", "CreationDate": "2014-08-27T10:15:54.657", "ParentId": "25524355", "CommentCount": "1", "OwnerUserId": "2380830"}, "bq_ids": {"n4140": {"so_25524355_25524458_0": {"length": 65, "quality": 0.9285714285714286, "section_id": 7217}}, "n3337": {"so_25524355_25524458_0": {"length": 65, "quality": 0.9285714285714286, "section_id": 6961}}, "n4659": {"so_25524355_25524458_0": {"length": 63, "quality": 0.9, "section_id": 8726}}}, "25524605": {"Id": "25524605", "PostTypeId": "2", "Body": "<p>The C++ standard doesn't say anything, but in most of the platforms C++ use the single/double precision standard from IEEE, which define single precision as 4 bytes, and double precision as 8 bytes.</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Single-precision_floating-point_format\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Single-precision_floating-point_format</a>\n<a href=\"http://en.wikipedia.org/wiki/Double-precision_floating-point_format\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Double-precision_floating-point_format</a></p>\n<p>I'm not sure about the exceptions for these cases.</p>\n", "LastActivityDate": "2014-08-27T10:20:43.527", "Score": "3", "CreationDate": "2014-08-27T10:20:43.527", "ParentId": "25524355", "CommentCount": "2", "OwnerUserId": "1742659"}, "25524699": {"Id": "25524699", "PostTypeId": "2", "Body": "<p>I want to point out that even if you have same size floats you <strong>can not</strong> be sure these floats are equally interpreted on different platforms. You can read a lot of papers about 'floats over network'. Floats non-determinism is a known problem.</p>\n", "LastActivityDate": "2014-08-27T10:26:17.533", "Score": "0", "CreationDate": "2014-08-27T10:26:17.533", "ParentId": "25524355", "CommentCount": "2", "OwnerUserId": "966376"}, "25526273": {"Id": "25526273", "PostTypeId": "2", "Body": "<p>In the case of X86, even if using IEEE single and double precision numbers, the internal calculations are affected by a floating point control word (FCW). The internal calculations are normally 64 bit or 80 bit (long double). You can override this using inline assembly code, but there's no guarantee that some double precision library function won't set it back.</p>\n<p>Microsoft supported 80 bit long doubles with their 16 bit compilers, but dropped support for them with their 32 bit and 64 bit compilers, and long doubles are now the same as doubles at 64 bits.</p>\n", "LastActivityDate": "2014-08-27T11:42:53.317", "Score": "0", "CreationDate": "2014-08-27T11:42:53.317", "ParentId": "25524355", "CommentCount": "0", "OwnerUserId": "3282056"}, "25524458": {"Id": "25524458", "PostTypeId": "2", "Body": "<p>Does not say anything about the size.</p>\n<p>3.9.1.8</p>\n<blockquote>\n<p id=\"so_25524355_25524458_0\">There are three floating point types: float, double, and long double.\n  The type double provides at least as much precision as float, and the\n  type long double provides at least as much precision as double. The\n  set of values of the type float is a subset of the set of values of\n  the type double; the set of values of the type double is a subset of\n  the set of values of the type long double. The value representation of\n  floating-point types is implementation-defined. Integral and floating\n  types are collectively called arithmetic types. Specializations of the\n  standard template std::numeric_limits (18.3) shall specify the maximum\n  and minimum values of each arithmetic type for an implementation.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-27T10:14:15.467", "Score": "9", "CreationDate": "2014-08-27T10:14:15.467", "ParentId": "25524355", "CommentCount": "0", "OwnerUserId": "3190928"}, "25524745": {"Id": "25524745", "PostTypeId": "2", "Body": "<p>Excerpt from the C99 standard, normative annex F (The C++-standard does not explicitly mention this annex, though it includes all affected functions without change per reference. Also, the types have to match for compatibility.):</p>\n<blockquote>\n<h2>IEC 60559 floating-point arithmetic</h2>\n<h3>F.1 Introduction</h3>\n<p id=\"so_25524355_25524745_0\">1 This annex specifies C language support for the IEC 60559 floating-point standard. The\n  IEC 60559 floating-point standard is specifically Binary floating-point arithmetic for\n  microprocessor systems, second edition (IEC 60559:1989), previously designated\n  IEC 559:1989 and as IEEE Standard for Binary Floating-Point Arithmetic\n  (ANSI/IEEE 754\u22121985). IEEE Standard for Radix-Independent Floating-Point\n  Arithmetic (ANSI/IEEE 854\u22121987) generalizes the binary standard to remove\n  dependencies on radix and word length. IEC 60559 generally refers to the floating-point\n  standard, as in IEC 60559 operation, IEC 60559 format, etc. An implementation that\n  defines <code>__STDC_IEC_559__</code> shall conform to the specifications in this annex.356)\n  Where a binding between the C language and IEC 60559 is indicated, the\n  IEC 60559-specified behavior is adopted by reference, unless stated otherwise. Since\n  negative and positive infinity are representable in IEC 60559 formats, all real numbers lie\n  within the range of representable values.</p>\n</blockquote>\n<p>So, include <code>&lt;math.h&gt;</code> (or in C++ maybe <code>&lt;cmath&gt;</code>), and test for <code>__STDC_IEC_559__</code>.</p>\n<p>If the macro is defined, not only are the types better specified (<code>float</code> being 32bits and <code>double</code> being 64bits among others), but also the behavior of builtin operators and standard-functions is more specified.<br>\nLack of the macro does not give any guarantees.</br></p>\n<p>For x86 and x86_64 (amd64), you can rely on the types <code>float</code> and <code>double</code> being IEC-60559-conformant, though functions using them and operations on them might not be.</p>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2017-02-13T18:58:02.550", "Score": "8", "CreationDate": "2014-08-27T10:27:59.087", "ParentId": "25524355", "CommentCount": "3", "LastEditDate": "2017-02-13T18:58:02.550", "OwnerUserId": "3204551"}, "25524549": {"Id": "25524549", "PostTypeId": "2", "Body": "<p>You can try to use a library offering cross-platform data types compatibility.</p>\n<p><em>\"The integral types C++ inherited from C are a cross-platform hazard. int, long and friends have different sizes on different platforms (32-bit and 64-bit on today's systems, maybe 128-bit later). For some applications it might seem irrelevant because they never approach the 32-bit limit (or rather 31-bit if you use unsigned integers), but if you serialize your objects on a 64-bit system and deserialize on a 32-bit system you might be unpleasantly surprised.<br>\nAPR provides a set of typedefs for basic types that might be different on different platforms. These typedefs provide a guaranteed size and avoid the fuzzy built-in types. However, for some applications (mostly numerical) it is sometimes important to use the native machine word size (typically what int stands for) to achieve maximal performance.\"</br></em></p>\n<p>Gigi SAYFAN - <strong>Building Your Own Plugin Framework</strong> <em>(From <a href=\"http://philippe.ameline.free.fr/techytechy/071125_PluginFramework.htm\" rel=\"nofollow\">http://philippe.ameline.free.fr/techytechy/071125_PluginFramework.htm</a>)</em></p>\n", "LastActivityDate": "2014-08-27T10:18:42.947", "Score": "0", "CreationDate": "2014-08-27T10:18:42.947", "ParentId": "25524355", "CommentCount": "2", "OwnerUserId": "3922315"}, "25524355": {"ViewCount": "35857", "Body": "<p>I was looking to see if there is any standard type similar to <code>uint32_t</code> which always would map into a 32-bit unsigned integral type but I could not find any.</p>\n<p>Is the size of <code>float</code> always 4 byte on all platform?<br>\nIs the size of <code>double</code> always 8?</br></p>\n<p>Does either standard say anything on the matter?</p>\n<p>I want to make sure that my size is always the same on all platforms (x86 and x64) so I am using standard int types, but I could not find any similar typedef for <code>float</code> and <code>double</code>.</p>\n", "Title": "What is the size of float and double in C and C++?", "CreationDate": "2014-08-27T10:09:33.293", "LastActivityDate": "2017-02-13T18:58:02.550", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-27T11:06:23.097", "Tags": "<c++><c><floating-point><x86><64bit>", "Id": "25524355", "LastEditorUserId": "3204551", "Score": "10", "OwnerUserId": "654019", "ClosedDate": "2014-08-28T09:21:16.363", "AnswerCount": "7"}});