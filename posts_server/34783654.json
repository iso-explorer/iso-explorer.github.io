post_cb({"34784880": {"LastActivityDate": "2016-01-14T08:35:54.660", "ParentId": "34783654", "Id": "34784880", "Score": "0", "Body": "<p>std::strings are refcounted , generally a copy on write happens when ever you modify .thats why c's address changes </p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "944028", "CreationDate": "2016-01-14T08:35:54.660"}, "34783859": {"LastActivityDate": "2016-01-14T07:29:26.000", "ParentId": "34783654", "Id": "34783859", "Score": "0", "Body": "<p><code>b</code> is a reference to <code>a</code>. Hence, <code>b.c_str()</code> and <code>a.c_str()</code> must return the same pointer value.</p>\n<p><code>c.c_str()</code> will return the same value as <code>a.c_str()</code> only if both point to the same data for efficiency reasons.</p>\n<p>It looks like the g++ implementation of <code>std::string</code> uses reference counted data. It would make sense, then, that they copy the data only when it is modified.</p>\n<p>From file basic_string.h:</p>\n<blockquote id=\"so_34783654_34783859_0\">\n<pre><code>*                                        [_Rep]\n*                                        _M_length\n*   [basic_string&lt;char_type&gt;]            _M_capacity\n*   _M_dataplus                          _M_refcount\n*   _M_p ----------------&gt;               unnamed array of char_type\n</code></pre>\n</blockquote>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "434551", "CreationDate": "2016-01-14T07:29:26.000"}, "34783654": {"Tags": "<c++><string><stl>", "AnswerCount": "4", "OwnerUserId": "2239066", "Body": "<p>When I suffered strange string conversion, I found different string variables point same address.</p>\n<p>I made 3 string variable in sample. I think a and b should point same address because b is reference variable of a.</p>\n<p>But variable c also point same address as a and b. I don`t understand this...</p>\n<p>I would really appreciate, if you give me any advice.</p>\n<hr>\n<p><strong>Question:</strong></p>\n<ol>\n<li><p>Why do a, b and c variable point same address? </p></li>\n<li><p>After change \"c[2]\" value, c changed to point different address. Could you explain?</p></li>\n<li><p>What is difference between two approches?</p></li>\n</ol>\n<blockquote>\n<p id=\"so_34783654_34783654_0\">c[2] = 'z';</p>\n<p id=\"so_34783654_34783654_1\">// Variable c changed value, but address is still same.</p>\n<p id=\"so_34783654_34783654_2\">char <em>temp = (char</em>)c.c_str(); temp[2] = 'z';</p>\n</blockquote>\n<hr>\n<p>compiler version:\ng++ (GCC) 4.4.7 20120313 (Red Hat 4.4.7-11)</p>\n<p>compile option:\ng++ -o test test.c</p>\n<p>Here is my code.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid print(std::string var_name, const std::string &amp;s)\n{\n    const char *ps = s.c_str();\n    printf(\"[%s] value=%s, address=%p\\n\", var_name.c_str(), s.c_str(), ps);\n}\n\nint main()\n{\n    std::string a = \"ab;cd;ef;gh\";\n    const std::string &amp;b = a;\n    std::string c;\n    c = b;\n\n    print(\"a\", a);\n    print(\"b\", b);\n    print(\"c\", c);\n\n    c[2] = 'z';\n    //char *temp = (char*)c.c_str();\n    //temp[2] = 'z';\n\n    print(\"a\", a);\n    print(\"b\", b);\n    print(\"c\", c);\n#if 0\n    std::cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"c=\" &lt;&lt; c &lt;&lt; std::endl;\n\n    //c[0] = 'z';\n\n    std::cout &lt;&lt; \"after change\";\n\n    char *temp = (char*)c.c_str();\n    temp[2] = '1';\n\n    std::cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b=\" &lt;&lt; b &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"c=\" &lt;&lt; c &lt;&lt; std::endl;\n#endif\n    return 0;\n}\n</code></pre>\n<p>result:</p>\n<p>[a] value=ab;cd;ef;gh, address=0x705028</p>\n<p>[b] value=ab;cd;ef;gh, address=0x705028</p>\n<p>[c] value=ab;cd;ef;gh, address=0x705028</p>\n<p>[a] value=ab;cd;ef;gh, address=0x705028</p>\n<p>[b] value=ab;cd;ef;gh, address=0x705028</p>\n<p>[c] value=abzcd;ef;gh, address=0x705058</p>\n</hr></hr>", "CommentCount": "3", "PostTypeId": "1", "CreationDate": "2016-01-14T07:13:52.803", "ViewCount": "130", "LastActivityDate": "2016-01-14T08:35:54.660", "Id": "34783654", "LastEditorUserId": "1968182", "Title": "different string variable point same address", "Score": "1", "LastEditDate": "2016-01-14T07:34:19.550"}, "34784245": {"CreationDate": "2016-01-14T07:54:32.627", "LastActivityDate": "2016-01-14T08:28:36.863", "LastEditorUserId": "-1", "ParentId": "34783654", "Score": "0", "Id": "34784245", "OwnerUserId": "5788338", "Body": "<p><a href=\"https://stackoverflow.com/a/34783723/785671\">As Joachim Pileborg said</a>, you have created <code>b</code> as an <strong>alias</strong> or  <strong>automatic reference</strong>. </p>\n<p>So, whenever you use <code>b</code>, you are also using <code>a</code>. </p>\n<p>For <code>b</code> <strong>no actual memory is created</strong> in the data section in your RAM; instead <code>b</code> is an alias of <code>a</code>.</p>\n<p>When it comes to <code>c</code>, you have <strong>created actual memory</strong> and you assigned data in <code>a</code> to it:</p>\n<pre><code>std::string c;\nc = b;\n</code></pre>\n<p>Hence, <code>c</code> will have a different memory address to <code>a</code>. <code>b</code> has the same address as <code>a</code>.</p>\n", "CommentCount": "0", "PostTypeId": "2", "LastEditDate": "2017-05-23T12:23:31.560"}, "34783723": {"CreationDate": "2016-01-14T07:19:14.967", "LastActivityDate": "2016-01-14T07:24:19.903", "LastEditorUserId": "440558", "ParentId": "34783654", "Score": "2", "Id": "34783723", "OwnerUserId": "440558", "Body": "<p>First of all you have to learn about <em>references</em>. A reference is basically an <em>alias</em> of something else. Once you initialize <code>b</code> as a reference to <code>a</code>, <code>b</code> is effectively an alias of <code>a</code>, and when you use <code>b</code> the compiler (one way or another) translates it to <code>a</code>.</p>\n<p>As for why the addresses are the same, it might simply be an optimization of the compiler and the standard library. Both <code>a</code> and <code>c</code> are initialized to the same contents, so why not share the contents? Saves memory. When a string is modified it copies the string to its own memory.</p>\n<hr>\n<p>As for your usage of <code>temp</code>, that's very wrong and leads to <em>undefined behavior</em>. From <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/c_str\" rel=\"nofollow\">this <code>c_str</code> reference</a>: </p>\n<blockquote>\n<p id=\"so_34783654_34783723_0\">Writing to the character array accessed through <code>c_str()</code> is undefined behavior.</p>\n</blockquote>\n<p>The <code>c</code> in <code>c_str</code> stands for <em>Constant</em> (i.e. read-only). That you need to use a C-style cast is indicative of you doing something that might be dangerous and most often bad.</p>\n</hr>", "CommentCount": "1", "PostTypeId": "2", "LastEditDate": "2016-01-14T07:24:19.903"}, "bq_ids": {"n3337": {"so_34783654_34783654_1": {"section_id": 6788, "quality": 0.5714285714285714, "length": 4}}}});