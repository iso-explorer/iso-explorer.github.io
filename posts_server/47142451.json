post_cb({"47142451": {"CommentCount": "0", "ViewCount": "68", "PostTypeId": "1", "LastEditorUserId": "1051764", "CreationDate": "2017-11-06T17:23:56.783", "LastActivityDate": "2017-11-06T21:15:51.170", "Title": "MSVC fails to compile an explicit template instantiation with a private type as an argument", "FavoriteCount": "1", "LastEditDate": "2017-11-06T21:15:51.170", "Id": "47142451", "Score": "1", "Body": "<p>Consider the following example, consisting of 4 files.</p>\n<hr>\n<p><br/>\n<strong>Outer.h</strong></p>\n<pre><code>#pragma once\n\n#include \"genericAlgorithm.h\"\n\nclass Outer\n{\nprivate:\n    struct Inner {};    // Note that Inner is private\n\n    const Inner inner;\n\npublic:\n    Outer() : inner() {}\n\n    inline void method()\n    {\n        genericAlgorithm(inner);\n    }\n};\n</code></pre>\n<p><br/>\n<strong>genericAlgorithm.h</strong></p>\n<pre><code>#pragma once\n\ntemplate &lt;typename T&gt;\nvoid genericAlgorithm(const T&amp; value);\n</code></pre>\n<p><br/>\n<strong>genericAlgorithm.cpp</strong></p>\n<pre><code>#include \"genericAlgorithm.h\"\n\n#include \"Outer.h\"\n\ntemplate &lt;typename T&gt;\nvoid genericAlgorithm(const T&amp; value) {}\n\n// Explicit template instantiation (compiles on GCC, Clang; error C2248 on MSVC)\ntemplate void genericAlgorithm&lt;Outer::Inner&gt;(const Outer::Inner&amp; value);\n</code></pre>\n<p><br/>\n<strong>main.cpp</strong></p>\n<pre><code>#include \"Outer.h\"\n\nint main()\n{\n    Outer outer;\n    outer.method();\n    return 0;\n}\n</code></pre>\n<hr>\n<p>As you can see, in <code>genericAlgorithm.cpp</code> there is an explicit instantiation of <code>genericAlgorithm()</code> function template for argument <code>Outer::Inner</code>, which is a private inner struct of class <code>Outer</code>.</p>\n<p>It is my understanding that this is legal, since, according to <a href=\"http://en.cppreference.com/w/cpp/language/class_template#Explicit_instantiation\" rel=\"nofollow noreferrer\">cppreference.com</a>...</p>\n<blockquote>\n<p id=\"so_47142451_47142451_0\">Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.</p>\n</blockquote>\n<p>And in fact, this code compiles perfectly fine on GCC 6.3 and Clang 4.0.</p>\n<p>However, <strong>MSVC (Visual Studio 2017 15.2)</strong> seems to take issue with it and produces the following compilation error:</p>\n<pre><code>genericalgorithm.cpp(9): error C2248: 'Outer::Inner': cannot access private struct declared in class 'Outer'\n</code></pre>\n<hr>\n<p>So, is this a bug in MSVC or am I missing something and in fact there is a problem with my code that needs to be fixed? If so, does it mean that it's GCC and Clang, along with cppreference.com, who are wrong?</p>\n<hr>\n<p>UPDATE: I believe I found a relevant passage in \u00a714.7.2 [templ.explicit] (item 12) of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">n4296</a> and <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf\" rel=\"nofollow noreferrer\">n4567</a> working drafts of the standard:</p>\n<blockquote>\n<p id=\"so_47142451_47142451_1\">The usual access checking rules do not apply to names used to specify explicit instantiations. [Note: In\n  particular, the template arguments and names used in the function declarator (including parameter types,\n  return types and exception specifications) may be private types or objects which would normally not be\n  accessible and the template may be a member template or member function which would not normally be\n  accessible. \u2014 end note]</p>\n</blockquote>\n<p>Unless I'm misinterpreting what's written, it seems that this behaviour of MSVC is indeed non-compliant. Granted, these are just drafts - I unfortunately don't have access to the actual <a href=\"https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS/ISO/IEC+14882:2014+(2016)\" rel=\"nofollow noreferrer\">$133 per copy</a> standard, so I can't be sure if this item has been retained.</p>\n</hr></hr></hr></hr>", "Tags": "<c++><gcc><visual-c++><clang><explicit-instantiation>", "OwnerUserId": "1051764", "AnswerCount": "1"}, "47143456": {"ParentId": "47142451", "CommentCount": "9", "Body": "<p>I would read that to mean that the explicit instantiation definition ignores access specifiers in <em>the thing you are explicitly specifying</em>.  It doesn't magically grant you access to private members of other items.  </p>\n<p>Type \"Inner\" is private to the thing you are using as an argument, not to type genericAlgorithm</p>\n", "OwnerUserId": "5869304", "PostTypeId": "2", "Id": "47143456", "Score": "0", "CreationDate": "2017-11-06T18:32:10.343", "LastActivityDate": "2017-11-06T18:32:10.343"}, "bq_ids": {"n4140": {"so_47142451_47142451_0": {"section_id": 261, "quality": 0.5384615384615384, "length": 7}, "so_47142451_47142451_1": {"section_id": 261, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_47142451_47142451_0": {"section_id": 252, "quality": 0.5384615384615384, "length": 7}, "so_47142451_47142451_1": {"section_id": 252, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_47142451_47142451_0": {"section_id": 268, "quality": 0.5384615384615384, "length": 7}, "so_47142451_47142451_1": {"section_id": 268, "quality": 0.9047619047619048, "length": 38}}}});