post_cb({"2072973": {"ParentId": "2068022", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>After searching and several breaks while attacking other problems, I found an answer which is clear and succinct (for standardese, anyway):</p>\n<blockquote>\n<p id=\"so_2068022_2072973_0\">Calling a function through an expression whose function type has a language linkage that is different from the language linkage of the function type of the called function's definition is undefined. [5.2.2/1]</p>\n</blockquote>\n<p>I still maintain that it is problematic at a fundamental level to use text from the C++ standard to define the behavior of a C library compiled with a C compiler, and exactly how that interlanguage interoperability works is very implementation-specific; however, this is the closest I think either standard can (currently) hope to define such interaction.</p>\n<p>In particular, this is undefined behavior (and isn't using a C library so that issue doesn't arise):</p>\n<pre><code>void call(void (*pf)()) { pf(); } // pf() is the UB\nextern \"C\" void f();\nint main() { call(f); }\n// though I'm unsure if a diagnostic is required for call(f)\n</code></pre>\n<p><a href=\"http://comeaucomputing.com/tryitout/\" rel=\"noreferrer\">Comeau</a> does give a diagnostic at <code>call(f)</code> (though it can do that even if the diagnostic isn't required).</p>\n<p>This isn't undefined behavior, and shows how to include language linkage in a function pointer type (which is through a typedef):</p>\n<pre><code>extern \"C\" typedef void F();\nvoid call(F* pf) { pf(); }\nextern \"C\" void f();\nint main() { call(f); }\n</code></pre>\n<p>Or could be written:</p>\n<pre><code>extern \"C\" {\ntypedef void F();\nvoid f();\n}\nvoid call(F* pf) { pf(); }\nint main() { call(f); }\n</code></pre>\n", "Id": "2072973", "LastEditDate": "2010-01-15T17:56:08.937", "OwnerDisplayName": "Roger Pate", "Score": "6", "CreationDate": "2010-01-15T16:09:36.257", "LastActivityDate": "2010-01-15T17:56:08.937", "LastEditorDisplayName": "Roger Pate"}, "2068048": {"CommentCount": "18", "CreationDate": "2010-01-14T22:32:25.187", "LastEditorUserId": "-1", "LastActivityDate": "2010-01-15T02:05:29.080", "ParentId": "2068022", "LastEditDate": "2017-05-23T12:31:05.787", "LastEditorDisplayName": "Roger Pate", "PostTypeId": "2", "Id": "2068048", "Score": "20", "Body": "<p>It is not safe per the C++ standard. As stated in <a href=\"https://stackoverflow.com/questions/1738313/c-using-class-method-as-a-function-pointer-type/1738425#1738425\">this SO posting</a>:</p>\n<blockquote>\n<p id=\"so_2068022_2068048_0\">A C callback function implemented in C++ must be extern \"C\". It may seem to work as a static function in a class because class-static functions often use the same calling convention as a C function. However, doing that is a bug waiting to happen (see comments below), so please don't - go through an extern \"C\" wrapper instead.</p>\n</blockquote>\n<p>And according to comments made by <a href=\"https://stackoverflow.com/users/14065/martin-york\">Martin York</a> in that answer there are real-world problems trying to do so on some platforms.</p>\n<p>Make your C ABI callbacks <code>extern \"C\"</code>.</p>\n<hr>\n<p>Edit: Adding some supporting quotes from the standard (emphasis mine):</p>\n<p>3.5 \"Program and linkage\": </p>\n<blockquote>\n<p id=\"so_2068022_2068048_1\">After all adjustments of types (during which typedefs (7.1.3) are replaced by their definitions), <strong>the types specified by all declarations referring to a given object or function shall be identical</strong>, except that declarations for an array object can specify array types that differ by the presence or absence of a major array bound (8.3.4). A violation of this rule on type identity does not require a diagnostic. [3.5/10]</p>\n<p id=\"so_2068022_2068048_2\">[Note: linkage to non-C++ declarations can be achieved using a linkage-specification (7.5). ] [3.5/11]</p>\n</blockquote>\n<p>And</p>\n<p>7.5 \"Linkage specifications\":</p>\n<blockquote>\n<p id=\"so_2068022_2068048_3\">... Two function types with different language linkages are <strong>distinct types</strong> even if they are otherwise identical. [7.5/1]</p>\n</blockquote>\n<p>So if the code making the callback is using C language bindings for the callback, then the callback target (in the C++ program) must as well.</p>\n</hr>", "OwnerUserId": "12711"}, "2068022": {"CommentCount": "1", "AcceptedAnswerId": "2068048", "PostTypeId": "1", "LastEditorDisplayName": "anon", "CreationDate": "2010-01-14T22:28:39.557", "LastActivityDate": "2010-01-15T17:56:08.937", "LastEditDate": "2010-01-14T22:31:16.690", "ViewCount": "3177", "FavoriteCount": "10", "Title": "In C++, is it safe/portable to use static member function pointer for C API callbacks?", "Id": "2068022", "Score": "26", "Body": "<p>In C++, is it safe/portable to use static member function pointer for C API callbacks? Is the ABI of a static member function the same as a C function?</p>\n", "Tags": "<c++><callback><portability>", "OwnerUserId": "245265", "AnswerCount": "4"}, "2068045": {"ParentId": "2068022", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>For all the Windows C++ compilers that I'm aware of, the answer is yes, but nothing in the language standard guarantees this. I wouldn't let that stop you however, it's a very common way of implementing callbacks using C++ - you may find you need to declare the static functions as WINAPI however. This is taken from an old threading library of my own:</p>\n<pre><code>class Thread {\n   ...\n   static DWORD WINAPI ThreadFunction( void * args );\n};\n</code></pre>\n<p>where this is the callback use by te Windows threading API.</p>\n", "Id": "2068045", "LastEditDate": "2010-01-14T22:43:46.463", "OwnerDisplayName": "anon", "Score": "5", "CreationDate": "2010-01-14T22:32:16.207", "LastActivityDate": "2010-01-14T22:43:46.463", "LastEditorDisplayName": "anon"}, "bq_ids": {"n4140": {"so_2068022_2068048_2": {"section_id": 7144, "quality": 0.5555555555555556, "length": 5}, "so_2068022_2068048_3": {"section_id": 5517, "quality": 0.9230769230769231, "length": 12}, "so_2068022_2072973_0": {"section_id": 5988, "quality": 0.9473684210526315, "length": 18}, "so_2068022_2068048_1": {"section_id": 7143, "quality": 0.9047619047619048, "length": 38}}, "n3337": {"so_2068022_2068048_2": {"section_id": 6888, "quality": 0.5555555555555556, "length": 5}, "so_2068022_2068048_3": {"section_id": 5303, "quality": 0.9230769230769231, "length": 12}, "so_2068022_2072973_0": {"section_id": 5756, "quality": 0.9473684210526315, "length": 18}, "so_2068022_2068048_1": {"section_id": 6887, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_2068022_2068048_2": {"section_id": 8645, "quality": 0.5555555555555556, "length": 5}, "so_2068022_2068048_3": {"section_id": 6952, "quality": 0.9230769230769231, "length": 12}, "so_2068022_2072973_0": {"section_id": 7488, "quality": 0.7368421052631579, "length": 14}, "so_2068022_2068048_1": {"section_id": 8644, "quality": 0.9047619047619048, "length": 38}}}, "2068050": {"ParentId": "2068022", "PostTypeId": "2", "CommentCount": "22", "Body": "<p>ABI isn't covered by either the C or C++ standards, even though C++ does give you \"language linkage\" through <code>extern \"C\"</code>.  Therefore, ABI is fundamentally compiler/platform specific.  Both standards leave many, many things up to the implementation, and this is one of them.</p>\n<p>Consequently, writing 100% portable code\u2014or switching compilers\u2014is hard to impossible, but allows vendors and users considerable flexibility in their specific products.  This flexibility allows more space and time efficient programs, in ways that don't have to be anticipated in advance by the standards committees.</p>\n<hr>\n<p>As I understand it, ISO's rules do not allow a standard more often than once every 10 years (but there can be various publications, such as TC1 and TR1 for C++).  Plus there is the idea (I'm not sure if this comes from ISO, is carried over from the C committee, or even from elsewhere) to \"distill\"/standardize existing practice rather than going off into left field, and there are <em>many</em> existing practices, some of which conflict.</p>\n</hr>", "Id": "2068050", "LastEditDate": "2010-01-14T23:26:27.793", "OwnerDisplayName": "Roger Pate", "Score": "3", "CreationDate": "2010-01-14T22:32:52.860", "LastActivityDate": "2010-01-14T23:26:27.793", "LastEditorDisplayName": "Roger Pate"}});