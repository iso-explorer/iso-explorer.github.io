post_cb({"bq_ids": {"n4140": {"so_33344259_33344927_0": {"length": 32, "quality": 0.8, "section_id": 480}}, "n3337": {"so_33344259_33344927_0": {"length": 32, "quality": 0.8, "section_id": 471}}, "n4659": {"so_33344259_33344927_0": {"length": 37, "quality": 0.925, "section_id": 502}}}, "33347378": {"Id": "33347378", "PostTypeId": "2", "Body": "<p>Just to add a little more fuel, how would this function if RVO were in play?  The caller has put an instance of <code>A</code> somewhere in memory and then calls <code>foo</code> to assign to it (even better, let's assume that that <code>A</code> was a part of a larger struct, and let's assume that it is correctly aligned such that the next member of the struct is immediately after that instance of <code>A</code>).  Assuming RVO were in play, the <code>first</code> portion of <code>p</code> is located where the caller wanted it, but where does the <code>int</code> that is <code>second</code> get placed?  It has to go right after the instance of <code>A</code> in order to keep the <code>pair</code> functioning correctly, but at the source location, there's some other member right after that instance of <code>A</code>.</p>\n<p>I would expect that RVO would not be happening in this place as you are only returning a portion of a larger object.   A move could happen as <code>first</code> would have to be left in a destructible state.</p>\n", "LastActivityDate": "2015-10-26T13:48:05.947", "CommentCount": "0", "CreationDate": "2015-10-26T13:48:05.947", "ParentId": "33344259", "Score": "8", "OwnerUserId": "1987633"}, "33345101": {"Id": "33345101", "PostTypeId": "2", "Body": "<p>@atkins got here first with the answer. Just adding this little test program which you may find useful in future when tracking move/assign behaviour.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std::string_literals;\n\nstruct A {\n    A()\n    : history(\"created\")\n    {\n    }\n\n    A(A&amp;&amp; r)\n    : history(\"move-constructed,\"s + r.history)\n    {\n        r.history = \"zombie: was \"s + r.history;\n    }\n    A(const A&amp; r)\n    : history(\"copied from: \" + r.history)\n    {\n    }\n    ~A() {\n        history = \"destroyed,\"s + history;\n        std::cout &lt;&lt; history &lt;&lt; std::endl;\n    }\n    A&amp; operator=(A&amp;&amp; r) {\n        history = \"move-assigned from \" + r.history + \" (was \"s + history + \")\"s;\n        r.history = \"zombie: was \"s + r.history;\n        return *this;\n    }\n    A&amp; operator=(const A&amp;r ) {\n        history = \"copied from \" + r.history;\n        return *this;\n    }\n    std::string history;\n};\n\nA foo() {\n    auto p = std::make_pair(A{}, 2);\n    // ... do something\n    return p.first;\n}\n\n\n\nauto main() -&gt; int\n{\n    auto a = foo();\n    return 0;\n}\n</code></pre>\n<p>example output:</p>\n<pre><code>destroyed,zombie: was created\ndestroyed,move-constructed,created\ndestroyed,copied from: move-constructed,created\n</code></pre>\n", "LastActivityDate": "2015-10-26T11:52:02.773", "CommentCount": "0", "CreationDate": "2015-10-26T11:52:02.773", "ParentId": "33344259", "Score": "3", "OwnerUserId": "2015579"}, "33354387": {"Id": "33354387", "PostTypeId": "2", "Body": "<p>Consider following code:</p>\n<pre><code>struct A {};\nstruct B {};\nstruct C { B c[100000]; };\n\nA callee()\n{\n    struct S\n    {\n        A a;\n        C c;\n    } s;\n    return s.a;\n}\n\nvoid caller()\n{\n    A a = callee();\n    // here should lie free unused spacer of size B[100000]\n    B b;\n}\n</code></pre>\n<p>\"Partial\" RVO should result in excessive stack usage bloating in caller, because (I think) <code>S</code> can be constructed only entirely in caller stack frame.</p>\n<p>Another issue is <code>~S()</code> behaviour:</p>\n<pre><code>// a.hpp\nstruct A {};\nstruct B {};\nstruct C { A a; B b; ~C(); };\n// a.cpp\n#include \"a.hpp\"\n~C() { /* ... */; }\n// main.cpp\n#include \"a.hpp\"\nA callee()\n{\n    C c;\n    return c.a;\n} // How to destruct c partially, having the user defined ~C() in another TU?\n// Even if destructor is inline and its body is visible,\n// how to automatically change its logic properly?\n// It is impossible in general case.\nvoid caller() { A a = callee(); }\n</code></pre>\n", "LastEditorUserId": "1430927", "LastActivityDate": "2015-10-27T08:05:23.327", "Score": "0", "CreationDate": "2015-10-26T19:50:07.740", "ParentId": "33344259", "CommentCount": "2", "OwnerUserId": "1430927", "LastEditDate": "2015-10-27T08:05:23.327"}, "33344927": {"Id": "33344927", "PostTypeId": "2", "Body": "<p>I've found in Visual Studio 2010 and in gcc-5.1 RVO is <strong>not</strong> applied (see for example <a href=\"http://coliru.stacked-crooked.com/a/17666dd9e532da76\">http://coliru.stacked-crooked.com/a/17666dd9e532da76</a>).</p>\n<p>The relevant section of the standard is 12.8.31.1 [class.copy]. It states that copy elision is permitted (my highlighting):</p>\n<blockquote>\n<p id=\"so_33344259_33344927_0\">in a return statement in a function with a class return type, when the expression is the <strong>name of a non-volatile automatic object</strong> (other than a function parameter or a variable introduced by the exception-declaration of a handler ([except.handle])) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function's return value</p>\n</blockquote>\n<p>Since <code>p.first</code> is not the name of an object, RVO is prohibited.</p>\n", "LastEditorUserId": "995218", "LastActivityDate": "2015-10-26T12:05:55.240", "Score": "9", "CreationDate": "2015-10-26T11:43:27.943", "ParentId": "33344259", "CommentCount": "21", "OwnerUserId": "995218", "LastEditDate": "2015-10-26T12:05:55.240"}, "33344259": {"ViewCount": "580", "Body": "<p>Consider the following:</p>\n<pre><code>struct A { /* ... */ };\n\nA foo() {\n  auto p = std::make_pair(A{}, 2);\n  // ... do something\n  return p.first;\n}\n\nauto a = foo();\n</code></pre>\n<p>Will <code>p.first</code> be copied, moved or RVO-ed?</p>\n", "AcceptedAnswerId": "33344927", "Title": "Does RVO work on object members?", "CreationDate": "2015-10-26T11:09:30.243", "Id": "33344259", "CommentCount": "11", "LastEditDate": "2015-10-28T12:57:23.670", "PostTypeId": "1", "LastEditorUserId": "963864", "LastActivityDate": "2015-10-28T12:57:23.670", "Score": "11", "OwnerUserId": "725978", "Tags": "<c++><c++11><visual-c++><c++14><return-value-optimization>", "AnswerCount": "4"}});