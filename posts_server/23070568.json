post_cb({"23071358": {"Id": "23071358", "PostTypeId": "2", "Body": "<p>An <code>unsigned short</code> is a 16-bit value that doesn't use a sign bit \u2014 all values are assumed to be positive.</p>\n<p>The decimal value 50,000 stored in binary is</p>\n<pre><code>1100 0011 0101 0000\n^\n</code></pre>\n<p>The leftmost bit (Most Significant Bit - MSB) is <code>1</code> and represents <code>2^15</code> which is 32,768</p>\n<p>The whole bit pattern is 32,768 + 16,384 + 512 + 256 + 64 + 16 = 50,000</p>\n<p>When you cast this to a <em>signed</em> short, the bit pattern is <em>not changed</em>, but the MSB no longer represents 32,768 \u2014 it now represents the <em>sign</em> of the number, and the remaining bits are the 2's-complement of the value.  In a signed value, that top bit is the sign, and 1 is <em>negative</em>.</p>\n<p>This doesn't happen with 30,000 because that is</p>\n<pre><code>0111 0101 0011 0000\n^\n</code></pre>\n<p>When this is converted to <em>signed</em> the left-most <code>0</code> represents the sign, and 0 is <em>positive</em> so the rest of the bits are still interpreted as they are, not as a 2's-complement, and they therefore still represent the same value of 30,000</p>\n", "LastActivityDate": "2014-04-14T22:13:29.950", "CommentCount": "3", "CreationDate": "2014-04-14T22:13:29.950", "ParentId": "23070568", "Score": "0", "OwnerUserId": "17300"}, "23070668": {"Id": "23070668", "PostTypeId": "2", "Body": "<p>50,000 is represented in binary as - 1100 0011 0101 0000.</p>\n<p>In a signed bit, the leftmost bit is the sign. In a signed integer, a '0' would represent a negative(hence the -15536), where in an unsigned integer this would make no difference. As for why the number itself changed, I have no idea.</p>\n", "LastActivityDate": "2014-04-14T21:22:05.387", "CommentCount": "2", "CreationDate": "2014-04-14T21:22:05.387", "ParentId": "23070568", "Score": "0", "OwnerUserId": "1901789"}, "23070643": {"Id": "23070643", "PostTypeId": "2", "Body": "<p>your answer and the books answer are correct</p>\n<pre><code>50000 = 0xc350\n</code></pre>\n<p>a signed 16 bit short containing 0xc350 is interpreted as -15,536</p>\n<p>So they are correct (interpretation of bit pattern)</p>\n<p>if i was a 32 bit int then putting 0xc350 in it would be interpretted as 50,000</p>\n<p>so you are correct (I too small)</p>\n", "LastActivityDate": "2014-04-14T21:20:20.983", "CommentCount": "3", "CreationDate": "2014-04-14T21:20:20.983", "ParentId": "23070568", "Score": "3", "OwnerUserId": "173397"}, "23070872": {"Id": "23070872", "PostTypeId": "2", "Body": "<p>You are correct and the book is also correct. An <code>unsigned short</code> can have values from 0 to 65535. A <code>signed short</code> can have values from -32768 to 32767.  Therefore, any value between 0 and 32767 works for both <code>signed</code> and <code>unsigned</code>.  </p>\n<p>However, a number like 50000 is too big for a <code>signed short</code>, so when you assign 50000 to a <code>signed short</code>, it causes numeric overflow.  </p>\n", "LastActivityDate": "2014-04-14T21:33:56.460", "CommentCount": "4", "CreationDate": "2014-04-14T21:33:56.460", "ParentId": "23070568", "Score": "0", "OwnerUserId": "3386109"}, "bq_ids": {"n4140": {"so_23070568_23070889_4": {"length": 15, "quality": 0.9375, "section_id": 33}, "so_23070568_23070889_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}, "so_23070568_23070889_1": {"length": 18, "quality": 1.0, "section_id": 30}, "so_23070568_23070889_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 34}, "so_23070568_23070889_2": {"length": 29, "quality": 0.90625, "section_id": 31}}, "n3337": {"so_23070568_23070889_2": {"length": 29, "quality": 0.90625, "section_id": 28}, "so_23070568_23070889_4": {"length": 15, "quality": 0.9375, "section_id": 30}, "so_23070568_23070889_3": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}, "so_23070568_23070889_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 31}, "so_23070568_23070889_1": {"length": 18, "quality": 1.0, "section_id": 27}}, "n4659": {"so_23070568_23070889_1": {"length": 18, "quality": 1.0, "section_id": 30}, "so_23070568_23070889_4": {"length": 15, "quality": 0.9375, "section_id": 33}, "so_23070568_23070889_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}, "so_23070568_23070889_5": {"length": 8, "quality": 0.8888888888888888, "section_id": 34}, "so_23070568_23070889_2": {"length": 29, "quality": 0.90625, "section_id": 31}}}, "23070568": {"ViewCount": "505", "Body": "<p>Just double checking. On some tutorial I found such code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n/* This program shows the difference between\n * signed and unsigned integers.\n*/\nint main()\n{\n   short int i;           // a signed short integer\n   short unsigned int j;  // an unsigned short integer\n\n   j = 50000;\n\n   i = j;\n   cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j;\n\n   return 0;\n}\n</code></pre>\n<p>output: -15536 50000</p>\n<p>Then it explains the output: <em>\"The above result is because the bit pattern that represents 50,000 as a short unsigned integer is interpreted as -15,536 by a short.\"</em></p>\n<p>I think this is a wrong explanation - or it is an English issue?\nI think the reason negative value is output is that 50000 didn't fit in the 2 byte signed int, am I wrong?</p>\n", "AcceptedAnswerId": "23070889", "Title": "What is happening with signed/unsigned int conversion?", "CreationDate": "2014-04-14T21:15:31.103", "LastActivityDate": "2014-04-14T22:13:29.950", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-04-14T21:16:30.183", "OwnerDisplayName": "user2793162", "LastEditorUserId": "2864740", "Id": "23070568", "Score": "2", "Tags": "<c++>", "AnswerCount": "6"}, "23070889": {"Id": "23070889", "PostTypeId": "2", "Body": "<p>The reasoning in the explanation is perhaps accurate for a specific platform, but in my opinion its irrelevant to what is ultimately printed. It would be far more accurate to say </p>\n<blockquote>\n<p id=\"so_23070568_23070889_0\">\"The above result is because the bit pattern returned from an implementation-defined conversion of an <code>unsigned short int</code> value of 50000 to a <code>signed short int</code> results in a value of -15,536.\"</p>\n</blockquote>\n<p>Not shockingly, sending said-value to <code>std::cout</code> will produce the proper output for the <code>signed short int</code> result of said-value. The <em>source</em> of the change (the conversion) is important, and in this case it is implementation-defined. Their phrasing is weak, and the <em>identical</em> statement could be applied by assigning <em>any</em> value to <em>any</em> integral value, so in reality their explanation is ultimately <em>pointless</em>. </p>\n<hr>\n<p>Not wanting to waste the previous answer (before I understood the question better), enjoy some light reading. To know <em>for sure</em> why this is happening you must consult your implementation documentation for conversion of this nature. Not the answer you likely want to hear, but there is reason behind it.</p>\n<p>This is happening because of <em>value promotion</em> via integer conversion <em>rank</em>. The value you received is, in fact, implementation-dependent, and the specific reason for why are covered in the standard.</p>\n<p>I'll leave out the most basic stuff and just get to the meat of it:</p>\n<p><strong>C++11 \u00a74.7 Integral promotions [conv.integral]</strong></p>\n<blockquote>\n<ol>\n<li><p id=\"so_23070568_23070889_1\">A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped enumeration type can be converted to a prvalue of an integer type.</p></li>\n<li><p id=\"so_23070568_23070889_2\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2n where n is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014 end note ]</p></li>\n<li><p id=\"so_23070568_23070889_3\"><strong>If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</strong></p></li>\n<li><p id=\"so_23070568_23070889_4\">If the destination type is bool, see 4.12. If the source type is bool, the value false is converted to zero and the value true is converted to one.</p></li>\n<li><p id=\"so_23070568_23070889_5\">The conversions allowed as integral promotions are excluded from the set of integral conversions.</p></li>\n</ol>\n</blockquote>\n<p>The value 50000 cannot be represented in a <code>signed short int</code> on your platform. Therefore the results are implementation-defined. By the looks of it your implementation just stores the bytes from one to the other, the result being the sign-bit (also covered in the standard but left out for brevity) is lit and the reported number is negative. Remember, though, this is implementation defined and <em>you cannot rely on this result on all platforms</em>.</p>\n</hr>", "LastEditorUserId": "1322972", "LastActivityDate": "2014-04-14T21:55:52.733", "Score": "3", "CreationDate": "2014-04-14T21:34:57.630", "ParentId": "23070568", "CommentCount": "7", "OwnerUserId": "1322972", "LastEditDate": "2014-04-14T21:55:52.733"}, "23070969": {"Id": "23070969", "PostTypeId": "2", "Body": "<p>First, integral types are required to be represented using a pure binary system, and so far the tutorial is correct.</p>\n<p>Second, a <code>short</code> is required to be at least 16 bits. If it's more, then you won't see the effect that you did, or any effect. It's unclear from your description whether the tutorial blindly assumes that <code>short</code> is necessarily 16 bits (wrong), or whether it's just using <em>some</em> concrete example, with the understanding that it depends on compiler etc.</p>\n<p>Third, the conversion to signed type \u2026 <del>is formally Implementation Defined Behavior if the value cannot be represented. This means that you are not guaranteed a change of value. Instead you <em>can</em>, in principle, get any effect, such as a crash.</del></p>\n<p><del>[example of other behavior lacking because I'm unable to cajole g++ 4.8.2 into trapping for your example code, even with <code>-ftrapv</code>]</del></p>\n<p>\u2026 yields a value that's either the same, if it can be represented, or otherwise defined by the implementation.</p>\n<p>That said, C++ guarantees that <strong>unsigned arithmetic</strong> is performed modulo 2<sup><em>n</em></sup>, where <em>n</em> is the number of value representation bits, e.g. 16 in your example. And with the very common <strong>two's complement form</strong> representation of signed integers, a negative integer value -<em>x</em> is represented as the bitpattern for -<em>x</em> + 2<sup><em>n</em></sup>. So if you start with the latter value (the interpretation of the bitpattern as unsigned) as 50\u00a0000, with 16 value bits and two's complement form, you get the signed value 50\u00a0000 - 2<sup>16</sup> = 50\u00a0000 - 65\u00a0536 = -15\u00a0536</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2014-04-14T22:05:23.837", "Score": "1", "CreationDate": "2014-04-14T21:41:41.360", "ParentId": "23070568", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2014-04-14T22:05:23.837"}});