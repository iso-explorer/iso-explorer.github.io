post_cb({"22770318": {"CommentCount": "14", "ViewCount": "1468", "PostTypeId": "1", "LastEditorUserId": "3043539", "CreationDate": "2014-03-31T19:21:13.867", "LastActivityDate": "2014-03-31T23:02:12.340", "Title": "Incomplete types in template code", "FavoriteCount": "2", "LastEditDate": "2014-03-31T19:37:32.217", "Id": "22770318", "Score": "14", "Body": "<p>Suppose we have two types (complete and incomplete):</p>\n<pre><code>struct CompleteType{};\n\nstruct IncompleteType;\n</code></pre>\n<p>Also we have template code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename = X(T)&gt;\nstruct Test : std::false_type {};\n\ntemplate &lt;&gt;\nstruct Test&lt;T&gt; : std::true_type {};\n</code></pre>\n<p><code>T</code> can be <code>CompleteType</code> or <code>IncompleteType</code> here and <code>X(T)</code> can be <code>T</code>, <code>decltype(T())</code> or <code>decltype(T{})</code> (suppose <code>X(T)</code> is a macro).</p>\n<p>This code is used in the following manner:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; Test&lt;&gt;::value &lt;&lt; std::endl;\n</code></pre>\n<p>Below you can see how different compilers deal with such code:</p>\n<hr>\n<p><em>clang 3.4</em></p>\n<pre><code>X(T) \\ T       CompleteType  IncompleteType\nT              true          true      \ndecltype(T())  true          --- (1, 2)\ndecltype(T{})  true          --- (1, 2)\n</code></pre>\n<ol>\n<li><p><code>error: invalid use of incomplete type 'IncompleteType'</code> is given even on template class declarations with incomplete types (both for <code>decltype(T())</code> and <code>decltype(T{})</code>, but not for simple <code>T</code>) without using <code>Test&lt;&gt;::value</code> in the code.</p></li>\n<li><p><code>error: too few template arguments for class template 'Test'</code></p></li>\n</ol>\n<hr>\n<p><em>g++ 4.8.1</em></p>\n<pre><code>X(T) \\ T       CompleteType  IncompleteType\nT              true          true      \ndecltype(T())  true          true      \ndecltype(T{})  true          true      \n</code></pre>\n<hr>\n<p><em>vc++ 18.00.21005.1</em></p>\n<pre><code>X(T) \\ T       CompleteType  IncompleteType\nT              true          true      \ndecltype(T())  true          --- (1)   \ndecltype(T{})  true          --- (2)   \n</code></pre>\n<ol>\n<li><p><code>error C2514: 'IncompleteType' : class has no constructors</code></p></li>\n<li><p><code>error C2440: '&lt;function-style-cast&gt;' : cannot convert from 'initializer-list' to 'IncompleteType' Source or target has incomplete type</code></p></li>\n</ol>\n<hr>\n<p><strong>What compiler acts in accordance with standard?</strong> Note that simple string like <code>std::cout &lt;&lt; typeid(X(IncompleteType)).name() &lt;&lt; std::endl;</code> does not compile on all compilers for all variants of <code>X</code> (except for <em>vc++</em> <strong>and</strong> <code>X(T) == T</code>).</p>\n</hr></hr></hr></hr>", "Tags": "<c++><templates><c++11><incomplete-type>", "OwnerUserId": "3043539", "AnswerCount": "1"}, "22773745": {"ParentId": "22770318", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I believe that the behavior of Clang and MSVC are consistent with the standard in this situation. I think GCC is taking a bit of a short-cut here.</p>\n<p>Let's put a few facts on the table first. The operand of a <code>decltype</code> expression is what is called an <em>unevaluated operand</em>, which are treated a bit differently due to fact that they are ultimately never evaluated. </p>\n<p>Particularly, there are fewer requirements about the types being complete. Basically, if you have any temporary object (as parameters or return values in the functions or operators involved in the expression), they are not required to be complete (see Sections 5.2.2/11 and 7.1.6.2/5). But this only lifts the usual restriction of \"you cannot declare an object of an incomplete type\", but it does not lift the other restriction on incomplete types, which is that \"you cannot call a member function of an incomplete type\". And that's the kicker.</p>\n<p>The expression <code>decltype(T())</code> or <code>decltype(T{})</code>, where <code>T</code> is incomplete, must necessarily look-up the constructor(s) of the type <code>T</code>, as it's a (special) member function of that class. It's only the fact that it's a constructor call that creates a bit of an ambiguity (i.e., Is it just creating a temporary object? Or is it calling a constructor?). If it was any other member function, there would be no debate. Fortunately, the standard does settle that debate:</p>\n<blockquote>\n<p id=\"so_22770318_22773745_0\">12.2/1</p>\n<p id=\"so_22770318_22773745_1\">Even when the creation of the temporary object is unevaluated (Clause\n  5) or otherwise avoided (12.8),  all the semantic restrictions shall\n  be respected as if the temporary object had been created and  later\n  destroyed. [ Note: even if there is no call to the destructor or\n  copy/move constructor, all  the semantic restrictions, such as\n  accessibility (Clause 11) and whether the function is  deleted\n  (8.4.3), shall be satisfied. However, in the special case of a\n  function call used as the  operand of a decltype-specifier (5.2.2), no\n  temporary is introduced, so the foregoing does not apply  to the\n  prvalue of any such function call. - end note ]</p>\n</blockquote>\n<p>The last sentence might be a bit confusing, but that only applies to the return-value of a function call. In other words, if you have <code>T f();</code> function, and you declare <code>decltype(f())</code>, then <code>T</code> is not required to be complete or have any semantic checks on whether there is a constructor / destructor available and accessible for it.</p>\n<p>In fact, this whole issue is exactly why there is a <code>std::declval</code> utility, because when you cannot use <code>decltype(T())</code>, you can just use <code>decltype(std::declval&lt;T&gt;())</code>, and <code>declval</code> is nothing more than a (fake) function that returns a prvalue of type <code>T</code>. But of course, <code>declval</code> is intended to be used in less trivial situations, such as <code>decltype( f( std::declval&lt;T&gt;() ) )</code> where <code>f</code> would be a function taking an object of type <code>T</code>. And <code>declval</code> does not require that the type is complete (see Section 20.2.4). This is basically the way you get around this whole problem.</p>\n<p>So, as far as GCC's behavior is concerned, I believe that it takes a short-cut as it attempts to figure out what the type of <code>T()</code> or <code>T{}</code> is. I think that as soon as GCC finds that <code>T</code> refers to a type name (not a function name), it deduces that this is a constructor call, and therefore, regardless of what the look-up finds as the actual constructor being called, the return type will be <code>T</code> (well, strictly speaking constructors don't have a return type, but you understand what I mean). The point here is that this could be a useful (faster) short-cut in an unevaluated expression. But this is not standard-compliant behavior, as far as I can tell.</p>\n<p>And if GCC allows for <code>CompleteType</code> with the constructor either deleted or private, then that is also in direct contradiction with the above-quoted passage of the standard. The compiler is required to enforce all semantic restrictions in that situation, even if the expression is not evaluated.</p>\n<blockquote>\n<p id=\"so_22770318_22773745_2\">Note that simple string like <code>std::cout &lt;&lt; typeid(X(IncompleteType)).name() &lt;&lt; std::endl;</code> does not compile on all compilers for all variants of X (except for vc++ and X(T) == T).</p>\n</blockquote>\n<p>This is expected (except for MSVC and X(T) == T). The <code>typeid</code> and <code>sizeof</code> operators are similar to <code>decltype</code> in the sense that their operands are unevaluated, however, both of them have the additional requirement that the type of the resulting expression must be a complete type. It is conceivable that a compiler could resolve <code>typeid</code> for incomplete types (or at least, with partial type-info), but the standard requires a complete type such that compilers don't have to do this. I guess this is what MSVC is doing.</p>\n<p>So, in this case, the <code>T()</code> and <code>T{}</code> cases fail for the same reason as for <code>decltype</code> (as I just explained), and the <code>X(T) == T</code> case fails because <code>typeid</code> requires a complete type (but MSVC manages to lift that requirement). And on GCC, it fails due to <code>typeid</code> requiring a complete type for all the <code>X(T)</code> cases (i.e., the short-cut GCC takes doesn't affect the outcome in the case of <code>sizeof</code> or <code>typeid</code>).</p>\n<p>So, all in all, I think that Clang is the most standard-compliant of the three (not taking short-cuts or making extensions).</p>\n", "OwnerUserId": "491645", "LastEditorUserId": "491645", "LastEditDate": "2014-03-31T23:02:12.340", "Id": "22773745", "Score": "11", "CreationDate": "2014-03-31T22:53:30.660", "LastActivityDate": "2014-03-31T23:02:12.340"}, "bq_ids": {"n4140": {"so_22770318_22773745_1": {"section_id": 378, "quality": 0.6724137931034483, "length": 39}}, "n3337": {"so_22770318_22773745_1": {"section_id": 369, "quality": 0.896551724137931, "length": 52}}, "n4659": {"so_22770318_22773745_1": {"section_id": 392, "quality": 0.5689655172413793, "length": 33}}}});