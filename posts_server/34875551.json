post_cb({"bq_ids": {"n4140": {"so_34875551_34875841_1": {"length": 24, "quality": 0.96, "section_id": 6697}, "so_34875551_34875841_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6696}}, "n3337": {"so_34875551_34875841_1": {"length": 24, "quality": 0.96, "section_id": 6452}, "so_34875551_34875841_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6451}}, "n4659": {"so_34875551_34875841_1": {"length": 24, "quality": 0.96, "section_id": 8172}, "so_34875551_34875841_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8171}}}, "34875551": {"ViewCount": "702", "Body": "<p>I have encountered a piece of code with method being exposed via public interface while the implementation is private. I'm not sure what should be the expected behavior. Simplified example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Interface\n{\npublic:\n    virtual ~Interface() {}\n    virtual void myIfMethod() = 0;\n};\n\nclass Derived : public Interface\n{\nprivate:\n    void myIfMethod(){std::cout &lt;&lt; \"private method invoked via public interface\" &lt;&lt; std::endl;}\n};\n\nint main()\n{\n    Interface* myObj = new Derived;\n    myObj-&gt;myIfMethod();\n    delete myObj;\n    return 0;\n}\n</code></pre>\n<p>This sample compiles and executes without a warning: <a href=\"http://ideone.com/1Ouwk4\" rel=\"nofollow\">http://ideone.com/1Ouwk4</a></p>\n<p>Is this a correct and well-defined behavior? And if so, why?</p>\n<p>Note, the question <strong>isn't about private interface method with public implementation</strong> (there are multiple such questions on SO) but <strong>the other way around</strong>.</p>\n", "AcceptedAnswerId": "34875841", "Title": "Private implementation for public interface method", "CreationDate": "2016-01-19T11:25:41.253", "Id": "34875551", "CommentCount": "2", "PostTypeId": "1", "ClosedDate": "2016-01-19T11:47:08.707", "LastActivityDate": "2016-01-19T11:38:59.283", "Score": "4", "OwnerUserId": "1756636", "Tags": "<c++><interface>", "AnswerCount": "1"}, "34875841": {"Id": "34875841", "PostTypeId": "2", "Body": "<p>C++ standard draft</p>\n<p>Access to virtual functions [class.access.virt]</p>\n<blockquote>\n<p id=\"so_34875551_34875841_0\">1 The access rules (Clause 11) for a virtual function are determined by its declaration and are not affected by\n  the rules for a function that later overrides it.</p>\n<p id=\"so_34875551_34875841_1\">2 Access is checked at the call point using the type of the expression used to denote the object for which the member function is called (B* in the example above). The access of the member function in the class in which it was defined (D in the example above) is in general not known.</p>\n</blockquote>\n<p>The function is called through a pointer of type <code>Interface</code> in which the member function is public, so the access is allowed. The access of the derived member function is not known and has no effect. The behaviour is correct and well defined as far as the standard is concerned.</p>\n<p>Of course, it might be quite pointless to define the overriding function private since it's accessible through virtual dispatch anyway.</p>\n", "LastActivityDate": "2016-01-19T11:38:59.283", "CommentCount": "3", "CreationDate": "2016-01-19T11:38:59.283", "ParentId": "34875551", "Score": "1", "OwnerUserId": "2079303"}});