post_cb({"31438775": {"Id": "31438775", "PostTypeId": "2", "Body": "<blockquote id=\"so_31429127_31438775_0\">\n<ul>\n<li>Is it unreasonable of me to expect the compiler to resolve which template to use ?</li>\n</ul>\n</blockquote>\n<p>The compiler is not allowed to resolve which template to use based on the C++ language rules. The relevant <a href=\"http://en.cppreference.com/w/cpp/utility/functional/function/function\" rel=\"nofollow\"><code>std::function</code></a> constructor is:</p>\n<pre><code>template&lt; class F &gt; \nfunction( F f );\n</code></pre>\n<p>And, according to [temp.deduct.type]:</p>\n<blockquote>\n<p id=\"so_31429127_31438775_1\">If a template parameter is used only in non-deduced\n  contexts and is not explicitly specified, template argument deduction fails.</p>\n<p id=\"so_31429127_31438775_2\">The non-deduced contexts are:<br>\n  \u2014 [...]<br>\n  \u2014 A function parameter for which argument deduction cannot be done because the associated function\n  argument is a function, or <strong>a set of overloaded functions</strong> (13.4), and one or more of the following apply:<br>\n  \u00a0\u00a0\u00a0\u00a0\u2014 <strong>more than one function matches the function parameter type (resulting in an ambiguous deduction)</strong>,\n  or<br>\n  \u00a0\u00a0\u00a0\u00a0\u2014 no function matches the function parameter type, or<br>\n  \u00a0\u00a0\u00a0\u00a0\u2014 the set of functions supplied as an argument contains one or more function templates.<br>\n  \u2014 [...]  </br></br></br></br></br></br></p>\n</blockquote>\n<p>So passing in <code>&amp;foo&lt;double&gt;</code> is a non-deduced context, template deduction fails, hence the compile error.</p>\n<blockquote id=\"so_31429127_31438775_3\">\n<ul>\n<li>What is the most elegant way to create the std::function is the above situation?</li>\n</ul>\n</blockquote>\n<p>I would just use a cast:</p>\n<pre><code>std::function&lt;double(double)&gt; afunc = \n    static_cast&lt;double(*)(double)&gt;(&amp;foo&lt;double&gt;);\n</code></pre>\n<p>and then complain to the standards committee about why <code>std::function&lt;Sig&gt;</code> doesn't have a constructor that takes a <code>Sig*</code>. In whatever order you want. </p>\n", "LastActivityDate": "2015-07-15T18:55:25.963", "CommentCount": "2", "CreationDate": "2015-07-15T18:55:25.963", "ParentId": "31429127", "Score": "1", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_31429127_31438775_1": {"length": 10, "quality": 1.0, "section_id": 335}, "so_31429127_31438775_2": {"length": 45, "quality": 0.9574468085106383, "section_id": 336}}, "n3337": {"so_31429127_31438775_1": {"length": 10, "quality": 1.0, "section_id": 325}, "so_31429127_31438775_2": {"length": 45, "quality": 0.9574468085106383, "section_id": 326}}, "n4659": {"so_31429127_31438775_1": {"length": 10, "quality": 1.0, "section_id": 344}, "so_31429127_31438775_2": {"length": 45, "quality": 0.9574468085106383, "section_id": 345}}}, "31429127": {"ViewCount": "93", "Body": "<p>I would like to create a <code>std::function</code> from an overloaded template function. Compiling with g++ -std=c++14 I obtain an overload resolution error. I have a hack to massage the function template into a form which the compiler recognises, but I would like to know if there are more elegant approaches.  Below is code illustrating the error and my hack,</p>\n<pre><code>#include &lt;functional&gt;\n\ntemplate &lt;typename T&gt;\nT foo(T t) { return t; }\n\ntemplate &lt;typename T&gt;\nT foo(T t1, T t2){ return t1 + t2; }\n\nint main (){\n    //error: conversion from \u2018&lt;unresolved overloaded function type&gt;\u2019 \n    //to non-scalar type \u2018std::function&lt;double(double)&gt;\u2019 requested\n    std::function&lt;double(double)&gt; afunc = &amp;foo&lt;double&gt;; \n\n    //my workaround to 'show' compiler which template \n    //function to instantiate \n    double (*kmfunc1)(double) = &amp;foo&lt;double&gt;;\n    std::function&lt;double(double)&gt; afunc = kmfunc1;  \n}\n</code></pre>\n<p>I have two questions</p>\n<ul>\n<li>Is it unreasonable of me to expect the compiler to resolve which template to use ?</li>\n<li>What is the most elegant way to create the std::function is the above situation?</li>\n</ul>\n", "Title": "overloaded function resolution with std::function: helping compilers disambiguate", "CreationDate": "2015-07-15T11:27:31.483", "LastActivityDate": "2015-07-16T13:17:00.410", "CommentCount": "3", "LastEditDate": "2015-07-16T13:17:00.410", "PostTypeId": "1", "LastEditorUserId": "989935", "Id": "31429127", "Score": "2", "OwnerUserId": "989935", "Tags": "<c++><templates><c++11><overloading>", "AnswerCount": "2"}, "31437839": {"Id": "31437839", "PostTypeId": "2", "Body": "<pre><code>#define OVERLOAD_SET(...) \\\n  [](auto&amp;&amp;...args)-&gt; \\\n    decltype(__VA_ARGS__(decltype(args)(args)...)) \\\n  { \\\n    return __VA_ARGS__(decltype(args)(args)...); \\\n  }\n</code></pre>\n<p>creates a single object that represents the complete (global) overload set of its argument.  (I use <code>...</code> as macros do not understand all uses of <code>,</code> in modern C++)</p>\n<pre><code>std::function&lt;double(double)&gt; afunc = OVERLOAD_SET(foo&lt;double&gt;);\nstd::function&lt;double(double,double)&gt; bfunc = OVERLOAD_SET(foo&lt;double&gt;);\n</code></pre>\n<p>both should work, as should</p>\n<pre><code>std::function&lt;double(double)&gt; afunc = OVERLOAD_SET(foo);\nstd::function&lt;double(double,double)&gt; bfunc = OVERLOAD_SET(foo);\n</code></pre>\n<p>while we are at it.  The idea here is we defer overload resolution until the point where the arguments are determined.</p>\n<p><code>OVERLOAD_SET(foo)</code> compiles to:</p>\n<pre><code>[](auto&amp;&amp;...args)\n-&gt;decltype(foo(decltype(args)(args)...))\n{\n  return foo(decltype(args)(args)...);\n}\n</code></pre>\n<p>which is a stateless lambda that returns whatever invoking <code>foo</code> on its arguments would do.  It uses perfect forwarding, with its usual imperfections.</p>\n", "LastActivityDate": "2015-07-15T18:04:01.837", "CommentCount": "0", "CreationDate": "2015-07-15T18:04:01.837", "ParentId": "31429127", "Score": "2", "OwnerUserId": "1774667"}});