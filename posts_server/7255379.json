post_cb({"7255637": {"ParentId": "7255379", "CommentCount": "1", "Body": "<p>You are correct, this is a bug. According to N3291, section 5.1.1, paragraph 3:</p>\n<blockquote>\n<p id=\"so_7255379_7255637_0\">If a declaration declares a member function or member function template of a class X, the expression this is a prvalue of type \u201cpointer to cv-quali\ufb01er-seq X\u201d between the optional cv-qualifer-seq and the end of the function-de\ufb01nition, member-declarator, or declarator. It shall not appear before the optional cv-quali\ufb01er-seq and it shall not appear within the declaration of a static member function (although its type and value category are de\ufb01ned within a static member function as they are within a non-static member function). [Note: this is because declaration matching does not occur until the complete declarator is known. \u2014end note ] Unlike the object expression in other contexts, *this is not required to be of complete type for purposes of class member access (5.2.5) outside the member function body. [Note: only class members declared prior to the declaration are visible. \u2014end note ]</p>\n</blockquote>\n<p>But this was a recent change between the last working draft and N3291. So GCC was right less than 6 months ago; that's the danger of writing code to a moving specification.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "7255637", "Score": "10", "CreationDate": "2011-08-31T10:26:28.457", "LastActivityDate": "2011-08-31T10:26:28.457"}, "7255379": {"CommentCount": "2", "AcceptedAnswerId": "7255637", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2011-08-31T10:00:19.130", "LastActivityDate": "2012-01-27T19:53:32.247", "LastEditDate": "2012-01-27T19:53:32.247", "ViewCount": "2099", "FavoriteCount": "1", "Title": "Trailing return types, decltype and const-ness", "Id": "7255379", "Score": "16", "Body": "<p>I was merily experimenting with the new trailing return types, where I hit a problem with this (simplified) code</p>\n<pre><code>#include &lt;list&gt;\n\nclass MyContainer{\n  std::list&lt;int&gt; ints;\n\n  auto begin( ) -&gt; decltype(ints.begin())\n  {\n    return ints.begin();\n  }\n\n  auto begin( ) const -&gt; decltype(ints.begin())\n  {\n    return ints.begin();\n  }\n};\n</code></pre>\n<p>Ignore the fact of how pointless this code is. The important part is the compiler error generated when using GCC 4.6.1 (with <code>-std=c++0x</code> flag):</p>\n<pre><code>In member function 'std::list&lt;int&gt;::iterator MyContainer::begin() const':\nerror: could not convert '((const MyContainer*)this)-&gt;MyContainer::ints.std::list&lt;_Tp, _Alloc&gt;::begin [with _Tp = int, _Alloc = std::allocator&lt;int&gt;, std::list&lt;_Tp, _Alloc&gt;::const_iterator = std::_List_const_iterator&lt;int&gt;]()' from 'std::list&lt;int&gt;::const_iterator {aka std::_List_const_iterator&lt;int&gt;}' to 'std::list&lt;int&gt;::iterator {aka std::_List_iterator&lt;int&gt;}'\n</code></pre>\n<p>In case you're not of fan of error involving templates, the short story is that in the body of the <code>const</code> version of <code>MyContainer::begin</code>, the expression <code>ints.begin()</code> returns a value of type <code>std::list&lt;int&gt;::const_iterator</code> (since <code>ints</code> is <code>const</code> in such a context). However, <code>decltype(ints.begin())</code> produces the type <code>std::list&lt;int&gt;::iterator</code>, i.e. <code>decltype</code> <em>ignores</em> the <code>const</code> qualifier of the <code>begin</code> method when deciding the type of the expression. Unsurprisingly, a conflict in types is the result.</p>\n<p>This seems to me to be a bug in the GCC compiler. It would only make sense for <code>decltype</code> to honor the <code>const</code> qualifier and produce the <code>const_iterator</code> type. Can anyone confirm or deny (maybe even explain) this? Maybe I am overlooking something in the mechanics of <code>decltype</code>, but this looks like a pretty straightforward  scenario.</p>\n<p>Note: as far as I can tell, the same behaviour holds not only for <code>std::list&lt;int&gt;</code>, but for any type with member functions overloaded on <code>const</code>-ness which return incompatible types.</p>\n", "Tags": "<c++><c++11><const-correctness><decltype><trailing-return-type>", "OwnerUserId": "616815", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7255379_7255637_0": {"section_id": 5949, "quality": 0.8674698795180723, "length": 72}}, "n3337": {"so_7255379_7255637_0": {"section_id": 5719, "quality": 0.8674698795180723, "length": 72}}, "n4659": {"so_7255379_7255637_0": {"section_id": 7435, "quality": 0.8554216867469879, "length": 71}}}});