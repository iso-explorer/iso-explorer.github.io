post_cb({"28786890": {"ParentId": "28786590", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A union is probably the cleanest way:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef unsigned short Uint16;\n\nstruct S {\n  Uint16 id : 8;\n  Uint16 health : 6;\n  Uint16 visible : 1;\n  Uint16 structural : 1;\n};\nunion U {\n Uint16 asInt;\n S asStruct;\n};\n\nint main() {\n  U u;\n  u.asStruct.id = 0xAB;\n  u.asStruct.health = 0xF;\n  u.asStruct.visible = 1;\n  u.asStruct.structural = 1;\n  std::cout &lt;&lt; std::hex &lt;&lt; u.asInt &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This prints out <code>cfab</code>.</p>\n<p><strong>Update:</strong></p>\n<p>After further consideration and reading more deeply about this I have decided that any kind of type punning is bad.  Instead I would recommend just biting the bullet and explicitly do the bit-twiddling to construct your value for serialization:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef unsigned short Uint16;\n\nstruct Block\n{\n  Uint16 id : 8;\n  Uint16 health : 6;\n  Uint16 visible : 1;\n  Uint16 structural : 1;\n\n  operator Uint16() {\n    return structural | visible &lt;&lt; 2 | health &lt;&lt; 4 | id &lt;&lt; 8;\n  }\n};\n\nint main() {\n  Block b{0xAB, 0xF, 1, 1};\n  std::cout &lt;&lt; std::hex &lt;&lt; Uint16(b) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This has the further bonus that it prints <code>abf5</code> which matches the initializer order.</p>\n<p>If you are worried about performance, instead of using the <code>operator</code> member function you could have a function that the compiler optimizes away:</p>\n<pre><code>...\n\nconstexpr Uint16 serialize(const Block&amp; b) {\n  return b.structural | b.visible &lt;&lt; 2 | b.health &lt;&lt; 4 | b.id &lt;&lt; 8;\n}\n\nint main() {\n  Block b{0xAB, 0xF, 1, 1};\n  std::cout &lt;&lt; std::hex &lt;&lt; serialize(b) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>And finally if speed is more important than memory, I would recommend getting rid of the bit fields:</p>\n<pre><code>struct Block\n{\n  Uint16 id;\n  Uint16 health;\n  Uint16 visible;\n  Uint16 structural;\n};\n</code></pre>\n", "OwnerUserId": "978525", "LastEditorUserId": "978525", "LastEditDate": "2015-03-01T00:54:32.917", "Id": "28786890", "Score": "0", "CreationDate": "2015-02-28T21:05:50.357", "LastActivityDate": "2015-03-01T00:54:32.917"}, "28787001": {"ParentId": "28786590", "PostTypeId": "2", "CommentCount": "1", "Body": "<h3>Living on the edge (of <em>undefined-behavior</em>)..</h3>\n<p>The naive solution would be to <em>reinterpret_cast</em> a reference to the object to the underlying type of your bit-field, abusing the fact that the first non-static data-member of a <em>standard-layout</em> class is located at the same address as the object itself.</p>\n<pre><code>struct A {         \n  uint16_t         id : 8;\n  uint16_t     health : 6;\n  uint16_t    visible : 1;\n  uint16_t structural : 1;\n};\n</code></pre>\n<p><sup></sup></p>\n<pre><code>A a { 0, 0, 0, 1 };\nuint16_t x = reinterpret_cast&lt;uint16_t const&amp;&gt; (a);\n</code></pre>\n<p>The above might look accurate, and it will <em>often</em> (not always) yield the expected result - but it suffers from two big problems:</p>\n<ul>\n<li>The allocation of <em>bit-fields</em> within an object is <em>implementation-defined</em>, and;</li>\n<li>the class type must be <em>standard-layout</em>.</li>\n</ul>\n<p><br/>\nThere is nothing saying that the <em>bit-fields</em> will, physically, be stored in the order you declare them, and even if that was the case a compiler might insert padding between every bit-field (as this is allowed). </p>\n<p>To sum things up; how <em>bit-fields</em> end up in memory is highly <em>implementation-defined</em>, trying to reason about the behavior requires you to look into your implementations documentation on the matter.</p>\n<hr>\n<h3>What about using a <code>union</code>?</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/11373203/accessing-inactive-union-member-undefined\">Accessing inactive union member - undefined?</a></li>\n</ul>\n<hr>\n<h3>Recommendation</h3>\n<p>Stick with the <em>bit-fiddling</em> approach, unless you can absolutely prove that every implementation on which the code is ran handles it the way you would want it to.</p>\n<hr>\n<h3>What does the standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a>) say?</h3>\n<blockquote>\n<p id=\"so_28786590_28787001_0\">9.6p1 <strong>Bit-fields</strong> <code>[class.bit]</code></p>\n<blockquote>\n<p id=\"so_28786590_28787001_2\"><strong>[...]</strong> Allocation of bit-fields within a class object is <em>implementation-defined</em>. Alignment of bit-fields is <em>implementation-defined</em>. <strong>[...]</strong></p>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_28786590_28787001_3\">9.2p20 <strong>Classes</strong> <code>[class]</code></p>\n<blockquote>\n<p id=\"so_28786590_28787001_5\">If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member. <strong>[...]</strong></p>\n</blockquote>\n</blockquote>\n</hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:50:51.183", "Id": "28787001", "Score": "1", "CreationDate": "2015-02-28T21:15:02.407", "LastActivityDate": "2015-02-28T21:15:02.407"}, "28786785": {"ParentId": "28786590", "CommentCount": "0", "Body": "<p>This isn't a good usage of bit fields (and really, there are very few). </p>\n<p>There is no guarantee that the order of your bit fields will be the same as the order they're declared in; it could change between builds of your application.</p>\n<p>You'll have to manually store your members in a <code>uint16_t</code> using the shift and bitwise-or operators. As a general rule, you should never just dump or blindly copy data when dealing with external storage; you should manually serialize/deserialize it, to ensure it's in the format you expect.</p>\n", "OwnerUserId": "214796", "PostTypeId": "2", "Id": "28786785", "Score": "0", "CreationDate": "2015-02-28T20:55:55.140", "LastActivityDate": "2015-02-28T20:55:55.140"}, "28786852": {"ParentId": "28786590", "CommentCount": "0", "Body": "<p>You can use union:</p>\n<pre><code>typedef union\n{\n    struct\n    {\n        Uint16 id : 8;\n        Uint16 health : 6;\n        Uint16 visible : 1;\n        Uint16 structural : 1;\n    } Bits;\n\n    Uint16 Val;\n} TMyStruct;\n</code></pre>\n", "OwnerUserId": "1124262", "PostTypeId": "2", "Id": "28786852", "Score": "0", "CreationDate": "2015-02-28T21:01:18.783", "LastActivityDate": "2015-02-28T21:01:18.783"}, "28786590": {"CommentCount": "0", "ViewCount": "121", "PostTypeId": "1", "LastEditorUserId": "4232755", "CreationDate": "2015-02-28T20:35:56.827", "LastActivityDate": "2015-03-01T00:54:32.917", "Title": "Getting entire value from bitfields", "AcceptedAnswerId": "28786890", "LastEditDate": "2015-02-28T21:13:08.180", "Id": "28786590", "Score": "1", "Body": "<p>I wish to create a Block struct for use in a voxel game I am building (just background context), however I have run into issues with my saving and loading.</p>\n<p>I can either represent a block as a single Uint16 and shift the bits to get the different elements such as blockID and health, or I can use a bitfield such as the one below:</p>\n<pre><code>struct Block\n{\n    Uint16 id : 8;\n    Uint16 health : 6;\n    Uint16 visible : 1;\n    Uint16 structural : 1;\n}\n</code></pre>\n<p>With the first method, when I wish to save the Block data I can simply convert the value of the Uint16 into a hex value and write it to a file. With loading I can simply read and convert the number back, then go back to reading the individual bits with manual bit shifting.</p>\n<p>My issue is that I cannot figure out how to get the whole value of the Uint16 I am using with the bitfields method, which means I cannot save the block data as a single hex value.</p>\n<p>So, the question is how do I go about getting the actual single Uint16 stored inside my block struct that is made up from the different bit fields. If it is not possible then that is fine, as I have already stated my manual bit shifting approach works just fine. I just wanted to profile to see which method of storing and modifying data is faster really.</p>\n<p>If I have missed out a key detail or there is any extra information you need to help me out here, by all means do ask.</p>\n", "Tags": "<c++><bit-shift><bit-fields>", "OwnerUserId": "4232755", "AnswerCount": "5"}, "28786794": {"ParentId": "28786590", "CommentCount": "0", "Body": "<p>There are at least two methods for what you want:  </p>\n<ul>\n<li>Bit Shifting</li>\n<li>Casting</li>\n</ul>\n<h2>Bit Shifting</h2>\n<p>You can build a <code>uint16_t</code> from your structure by shifting the bit fields into a <code>uint16_t</code>:  </p>\n<pre><code>uint16_t halfword;\nstruct Bit_Fields my_struct;\nhalfword = my_struct.id &lt;&lt; 8;\nhalfword = halfword | (my_struct.health &lt;&lt; 2);\nhalfword = halfword | (my_struct.visible &lt;&lt; 1);\nhalfword = halfword | (my_struct.structural);\n</code></pre>\n<h2>Casting</h2>\n<p>Another method is to cast the instance of the structure to a <code>uint16_t</code>:  </p>\n<pre><code>uint16_t halfword;\nstruct Bit_Fields my_struct;\nhalfword = (uint16_t) my_struct;\n</code></pre>\n<h2>Endianess</h2>\n<p>One issue of concern is Endianness; or the byte ordering of multi-byte values.  This may play a part with where the bits lie within the 16-bit unit.  </p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "28786794", "Score": "1", "CreationDate": "2015-02-28T20:56:45.020", "LastActivityDate": "2015-02-28T20:56:45.020"}, "bq_ids": {"n4140": {"so_28786590_28787001_2": {"section_id": 5921, "quality": 0.7777777777777778, "length": 7}, "so_28786590_28787001_5": {"section_id": 5879, "quality": 1.0, "length": 15}, "so_28786590_28787001_1": {"section_id": 5921, "quality": 0.7777777777777778, "length": 7}, "so_28786590_28787001_4": {"section_id": 5879, "quality": 1.0, "length": 15}}, "n3337": {"so_28786590_28787001_2": {"section_id": 5693, "quality": 0.7777777777777778, "length": 7}, "so_28786590_28787001_5": {"section_id": 5621, "quality": 0.6666666666666666, "length": 10}, "so_28786590_28787001_1": {"section_id": 5693, "quality": 0.7777777777777778, "length": 7}, "so_28786590_28787001_4": {"section_id": 5621, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_28786590_28787001_2": {"section_id": 7395, "quality": 0.7777777777777778, "length": 7}, "so_28786590_28787001_5": {"section_id": 7363, "quality": 1.0, "length": 15}, "so_28786590_28787001_1": {"section_id": 7395, "quality": 0.7777777777777778, "length": 7}, "so_28786590_28787001_4": {"section_id": 7363, "quality": 1.0, "length": 15}}}});