post_cb({"11224278": {"ParentId": "11224210", "CommentCount": "0", "Body": "<p>The same bit pattern can be interpreted in many different ways. The only difference between a signed and an unsigned integer is in the way their bit patterns are interpreted. Your code instructs <code>printf</code> to interpret an unsigned int as signed, that's why you see a negative number.</p>\n<p>As a matter of experimenting, try this:</p>\n<pre><code>printf(\"%u\\n\", -1);\n</code></pre>\n<p>This will produce a large positive number - a situation directly opposite of what you described in your post. Again, <code>printf</code> is asked to interpret a signed number as an unsigned, so it happily throws the sign away, and prints the value as if it were unsigned.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "11224278", "Score": "6", "CreationDate": "2012-06-27T10:35:14.747", "LastActivityDate": "2012-06-27T10:35:14.747"}, "bq_ids": {"n4140": {"so_11224210_11224210_3": {"section_id": 7213, "quality": 0.875, "length": 14}, "so_11224210_11224210_4": {"section_id": 7212, "quality": 0.8, "length": 8}, "so_11224210_11224210_5": {"section_id": 7213, "quality": 0.9642857142857143, "length": 27}, "so_11224210_11224210_2": {"section_id": 7212, "quality": 0.9242424242424242, "length": 61}}, "n3337": {"so_11224210_11224210_3": {"section_id": 6957, "quality": 1.0, "length": 16}, "so_11224210_11224210_4": {"section_id": 6956, "quality": 0.8, "length": 8}, "so_11224210_11224210_5": {"section_id": 6957, "quality": 0.9642857142857143, "length": 27}, "so_11224210_11224210_2": {"section_id": 6956, "quality": 0.9242424242424242, "length": 61}}, "n4659": {"so_11224210_11224210_3": {"section_id": 8722, "quality": 0.875, "length": 14}, "so_11224210_11224210_4": {"section_id": 8721, "quality": 0.8, "length": 8}, "so_11224210_11224210_5": {"section_id": 8722, "quality": 0.9642857142857143, "length": 27}, "so_11224210_11224210_2": {"section_id": 8721, "quality": 0.9545454545454546, "length": 63}}}, "11224210": {"CommentCount": "1", "ViewCount": "2148", "PostTypeId": "1", "ClosedDate": "2015-05-27T23:33:50.817", "LastEditorUserId": "1400768", "LastActivityDate": "2012-06-27T10:37:49.240", "Body": "<p>Can someone explain why unsigned int it taking the negative value? As <code>unsigned int</code> should only take positive values. </p>\n<p>From <a href=\"http://en.wikipedia.org/wiki/Integer_%28computer_science%29\" rel=\"nofollow\">Wikipedia</a>:</p>\n<blockquote>\n<p id=\"so_11224210_11224210_0\">word, long, doubleword, longword, int</p>\n<p id=\"so_11224210_11224210_1\">Unsigned: From 0 to 4,294,967,295 which equals 2^32 \u2212 1</p>\n</blockquote>\n<pre><code>#include &lt;stdio.h&gt;\ntypedef unsigned int uint32;\n\nint main()\n{\n     uint32 i;\n     int x = -1;\n     i = x%32;\n     printf(\"\\n\\n Value of uint32 i = %d\", i);\n     return (0);\n}\n</code></pre>\n<h2>Output:</h2>\n<pre><code>Value of uint32 i = -1\n</code></pre>\n<p>Here the below explanation which I found in cpp standard which I am unable to interpret it.</p>\n<blockquote>\n<p id=\"so_11224210_11224210_2\">For each of the signed integer types, there exists a corresponding (but different) unsigned integer type: \u201cunsigned char\u201d, \u201cunsigned short int\u201d, \u201cunsigned int\u201d, and \u201cunsigned long int,\u201d each of which occupies the same amount of storage and has the same alignment requirements (3.9) as the corresponding signed integer type40) ; that is, each signed integer type has the same object representation as its corresponding unsigned integer type. The range of nonnegative values of a signed integer type is a subrange of the corresponding unsigned integer type, and the value representation of each corresponding signed/unsigned type shall be the same.</p>\n<p id=\"so_11224210_11224210_3\">4 Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2n where n is the number of bits in the value representation of that particular size of integer</p>\n<p id=\"so_11224210_11224210_4\">40) See 7.1.5.2 regarding the correspondence between types and the sequences of type-specifiers that designate them.</p>\n<p id=\"so_11224210_11224210_5\">41) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer\n  type.</p>\n</blockquote>\n", "LastEditDate": "2012-06-27T10:37:49.240", "AcceptedAnswerId": "11224255", "Title": "Unsigned int takes negative values", "Id": "11224210", "Score": "1", "CreationDate": "2012-06-27T10:31:57.770", "Tags": "<c++><c>", "OwnerUserId": "617554", "AnswerCount": "2"}, "11224255": {"ParentId": "11224210", "CommentCount": "0", "Body": "<p>You are using the wrong flag for <code>printf</code>. It should be <code>%u</code>.</p>\n<p><code>printf(\"\\n\\n Value of uint32 i = %u\", i);</code></p>\n", "OwnerUserId": "551045", "PostTypeId": "2", "Id": "11224255", "Score": "13", "CreationDate": "2012-06-27T10:34:07.020", "LastActivityDate": "2012-06-27T10:34:07.020"}});