post_cb({"3539001": {"Id": "3539001", "PostTypeId": "2", "Body": "<p>I think in #3 you've made an error in your analysis.  As far as I know, <code>const</code> does not imply anything about linkage.  I'm not sure how you're coming to the conclusion that the compiler makes the linkage internal.  Most compilers will (as an optimization) replace all references to the const variable by the value it's been initialized to, so the symbol may not appear at all in the code.</p>\n<p>And even if you didn't, it's clear from #1 that if something with internal linkage is subsequently declared with the <code>extern</code> keyword that it remains with internal linkage.  So I don't know why you would expect an error.</p>\n<p>And if <code>const</code> implied internal linkage, then #4 should be an error for the same reason #2 is.</p>\n", "LastEditorUserId": "167958", "LastActivityDate": "2010-08-21T21:18:51.723", "Score": "0", "CreationDate": "2010-08-21T21:12:08.683", "ParentId": "3538807", "CommentCount": "1", "OwnerUserId": "167958", "LastEditDate": "2010-08-21T21:18:51.723"}, "4049392": {"Id": "4049392", "PostTypeId": "2", "Body": "<p>Having both (e) and (f) in the same namespace scope is simply invalid, by \u00a77.1.1/7 \"The linkages implied by successive declarations for a given entity shall agree.\".</p>\n<p>This rule requires a diagnostic.</p>\n<p>However, at least Comeau Online does not diagnose the violation.</p>\n<p>Cheers &amp; hth.,</p>\n<p><strong>EDIT</strong>: He he, I looked up <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#426\" rel=\"nofollow\">DR 426</a>, as mentioned in another answer here, and it seems those who drafted the proposed resolution, making it UB instead of diagnosable, were not aware of \u00a77.1.1/7. I'm not going to comment on the issue or even raise it in comp.std.c++ because I found the standardization work to be far too political and nonsensical (mumbo-jumbo arguments) for me. But either way, the code's not valid.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2010-10-29T06:13:36.233", "Score": "0", "CreationDate": "2010-10-29T06:02:36.343", "ParentId": "3538807", "CommentCount": "2", "OwnerUserId": "464581", "LastEditDate": "2010-10-29T06:13:36.233"}, "3538807": {"ViewCount": "1807", "Body": "<p>I have a few questions about the linkage from the following variables. By examples of 7.1.1/7 of C++03 and experimenting with compilers (Comeau, Clang and GCC), I came to the following linkage kinds:</p>\n<ol>\n<li><p>First <code>static</code>, then <code>extern</code></p>\n<pre><code>static int a; // (a)\nextern int a; // (b) valid, 'a' still internal\n</code></pre>\n<p>It's clear to me with accordance to section 3.5: (a) implies internal linkage. And (b) also implies internal linkage, because the name \"a\" is declared static (by (a)). </p></li>\n<li><p>First <code>extern</code>, then <code>static</code></p>\n<pre><code>extern int b; // (c)\nstatic int b; // (d) invalid!\n</code></pre>\n<p>First, (c) implies external linkage. But (d) implies internal linkage because the name \"b\" is declared static by (d). This is invalid according to 7.1.1/7, since the linkage implied is not consistent. </p></li>\n<li><p>First <code>const</code>, then <code>extern</code></p>\n<pre><code>const double pi1 = 3.14; // (e)\nextern const double pi1; // (f) valid and 'pi1' is internal\n</code></pre>\n<p>First, (e) implies internal linkage, because it is const, and neither declared explicit extern nor previously implied external linkage. And (f) should imply extern linkage and be an error, because it explicitly declares the name extern, but the compilers keep it internal! <strong>Why so?</strong> <em>That's my question.</em></p></li>\n<li><p>First <code>extern</code>, then <code>const</code></p>\n<pre><code>extern const double pi2; // (g)\nconst double pi2 = 3.14; // (h) valid and 'pi2' is external\n</code></pre>\n<p>Now, (g) implies external linkage because we explicitly declared extern. And (h) also implies external linkage because (g) explicitly declared extern. </p></li>\n</ol>\n<hr>\n<p>I have experimentally found out the linkage for 3 and 4 with the following template (the second argument is required to have external linkage)</p>\n<pre><code>template&lt;typename T, T&amp;&gt; struct ensure { };\n\nensure&lt;const double, pi1&gt; e1; // failed\nensure&lt;const double, pi2&gt; e2; // succeeded\n</code></pre>\n<hr>\n<p><strong>Summary:</strong> The Discussion with <a href=\"https://stackoverflow.com/users/19563/charles-bailey\">Charles Bailey</a> turned out to be quite fruitful and showed there are two possible interpretations of <code>3.5/3</code>, where the important bullet point reads</p>\n<blockquote>\n<p id=\"so_3538807_3538807_0\">A name having namespace scope (3.3.5) has internal linkage if it is the name of</p>\n<ul>\n<li>an object or reference that is explicitly declared const and neither explicitly declared extern nor\n  previously declared to have external linkage; </li>\n</ul>\n</blockquote>\n<p>If we look at point <code>(f)</code>, then the two interpretations come to different conclusions, as shown below</p>\n<ol>\n<li><p>The first interpretation notes that <code>pi1</code> is declared <code>const</code> but is also declared <code>extern</code>. The variable has thus <em>external</em> linkage. </p></li>\n<li><p>The second interpretation interpretes both occurences of \"declared\" to refer to the same declaration. In this way, it means that it <em>is declared <code>const</code>, but not <code>extern const</code></em>. We note that <code>(e)</code> is declared <code>const</code> and not <code>extern const</code>, thus we give <code>pi1</code> internal linkage. </p></li>\n</ol>\n<p>Now what interpretation is correct? I can't determine from that wording, but compilers seem to interpret this the second way. In particular, if we take the first interpretation, then the last quoted part of <code>3.5/3</code> would be superfluous, because there would be no valid scenario in which a name would be declared <code>const</code> and previously declared with external linkage but without an explicit <code>extern</code>. </p>\n</hr></hr>", "AcceptedAnswerId": "3539664", "Title": "Linkage of various const/static variables", "CreationDate": "2010-08-21T20:18:22.817", "Id": "3538807", "CommentCount": "20", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:46:01.853", "LastEditorUserId": "-1", "LastActivityDate": "2010-10-29T06:13:36.233", "Score": "6", "OwnerUserId": "34509", "Tags": "<c++><static><extern><linkage>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_3538807_3538807_0": {"length": 7, "quality": 0.875, "section_id": 7136}}, "n3337": {"so_3538807_3538807_0": {"length": 7, "quality": 0.875, "section_id": 6880}}, "n4659": {"so_3538807_3538807_0": {"length": 7, "quality": 0.875, "section_id": 8637}}}, "3539664": {"Id": "3539664", "PostTypeId": "2", "Body": "<pre><code>const double pi1 = 3.14; // (e)\nextern const double pi1; // (f) valid and 'pi1' is internal\n</code></pre>\n<p>My interpretation is as follows. When considering the linkage of a name we consider previous declarations as well as the one being interpreted at this point in the parse. This is why <code>static int a; extern int a;</code> is OK, but <code>extern int b; static int b;</code> is not.</p>\n<p>On encountering the first declaration we note that <code>pi1</code> is explicitly declared <code>const</code> but neither explicitly declared <code>extern</code> nor previously declared to have external linkage. This matches one of the options of 3.5/2 therefore <code>pi1</code> has internal linkage.</p>\n<p>On encountering the second declaration we ask is <code>pi1</code> the name of an object that is explicitly declared <code>const</code> but neither explicitly declared <code>extern</code> nor [... blah ...]. I contend that it is because it was so declared at point (e). Sure, it isn't declared that way everywhere but in the same way <code>a</code> was the name of an object declared <code>static</code> when we were considering the <code>extern int a;</code> declaration even though it wasn't declared <code>static</code> everywhere. This, to me, means that the declaration (f) doesn't imply a different linkage from declaration (e).</p>\n", "LastActivityDate": "2010-08-22T00:55:37.723", "CommentCount": "2", "CreationDate": "2010-08-22T00:55:37.723", "ParentId": "3538807", "Score": "4", "OwnerUserId": "19563"}});