post_cb({"30495807": {"Id": "30495807", "PostTypeId": "2", "Body": "<p>The binary search algorithm relies on strict weak ordering. Meaning that the elements are supposed to be partitioned according to the <code>operator &lt;</code> or according to a custom comparator that has the same guarantees. This means that there isn't necessarily only one element that could be found for a given query. Thus you need the <code>lower_bound</code>, <code>upper_bound</code> and <code>equal_range</code> functions to retrieve iterators.</p>\n", "LastEditorUserId": "1279096", "LastActivityDate": "2015-05-28T01:46:23.567", "Score": "2", "CreationDate": "2015-05-28T01:35:38.737", "ParentId": "30495744", "CommentCount": "0", "OwnerUserId": "1279096", "LastEditDate": "2015-05-28T01:46:23.567"}, "30495744": {"ViewCount": "856", "Body": "<p>According to draft <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4431.pdf\" rel=\"noreferrer\">N4431</a>, the function <code>std::binary_search</code> in the algorithms library returns a <code>bool</code>, [binary.search]:</p>\n<blockquote>\n<pre><code>  template&lt;class ForwardIterator, class T&gt;\n  bool binary_search(ForwardIterator first, ForwardIterator last,\n                     const T&amp; value);\n\n  template&lt;class ForwardIterator, class T, class Compare&gt;\n  bool binary_search(ForwardIterator first, ForwardIterator last,\n                     const T&amp; value, Compare comp);\n</code></pre>\n<p id=\"so_30495744_30495744_0\"><em>Requires</em>: The elements <code>e</code> of <code>[first,last)</code> are partitioned with respect to the expressions <code>e &lt; value</code> and <code>!(value &lt; e)</code> or <code>comp(e, value)</code> and <code>!comp(value, e)</code>. Also, for all elements <code>e</code> of <code>[first,last)</code>, <code>e &lt; value</code> implies <code>!(value &lt; e)</code> or <code>comp(e, value)</code> <code>implies !comp(value, e)</code>.</p>\n<p id=\"so_30495744_30495744_1\"><em>Returns</em>: <code>true</code> if there is an iterator <code>i</code> in the range <code>[first,last)</code> that satisfies the corresponding conditions:\n  <code>!(*i &lt; value) &amp;&amp; !(value &lt; *i)</code> or <code>comp(*i, value) == false &amp;&amp; comp(value, *i) ==\n  false</code>.</p>\n<p id=\"so_30495744_30495744_2\"><em>Complexity</em>: At most log<sub>2</sub>(last - first) + O(1) comparisons.</p>\n</blockquote>\n<p>Does anyone know why this is the case?  </p>\n<p>Most other generic algorithms either return an iterator to the element or an iterator that is equivalent to the iterator denoting the end of the sequence of elements (i.e., one after the last element to be considered in the sequence), which is what I would have expected.</p>\n", "AcceptedAnswerId": "30534100", "Title": "Why does std::binary_search return bool?", "CreationDate": "2015-05-28T01:27:49.867", "Id": "30495744", "CommentCount": "11", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-05-28T01:43:58.347", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-29T16:02:12.937", "Score": "5", "OwnerUserId": "2329304", "Tags": "<c++><c++11><stl-algorithm>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_30495744_30495744_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 1431}, "so_30495744_30495744_1": {"length": 14, "quality": 0.875, "section_id": 1432}}, "n3337": {"so_30495744_30495744_2": {"length": 4, "quality": 0.8, "section_id": 1427}, "so_30495744_30495744_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 1425}, "so_30495744_30495744_1": {"length": 14, "quality": 0.875, "section_id": 1426}}, "n4659": {"so_30495744_30495744_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 1551}, "so_30495744_30495744_1": {"length": 14, "quality": 0.875, "section_id": 1552}}}, "30495783": {"Id": "30495783", "PostTypeId": "2", "Body": "<p>It's split into multiple different functions in C++, as for the reasoning it's nearly impossible to tell why someone made something one way or another. <a href=\"http://en.cppreference.com/w/cpp/algorithm/binary_search\" rel=\"nofollow\"><code>binary_search</code></a> will tell you if such an element exists. If you need to know the location of them use <a href=\"http://en.cppreference.com/w/cpp/algorithm/lower_bound\" rel=\"nofollow\"><code>lower_bound</code></a> and <a href=\"http://en.cppreference.com/w/cpp/algorithm/upper_bound\" rel=\"nofollow\"><code>upper_bound</code></a> which will give the begin/end iterator respectively. There's also <a href=\"http://en.cppreference.com/w/cpp/algorithm/equal_range\" rel=\"nofollow\"><code>equal_range</code></a> that gives you both the begin and end at once.</p>\n<hr>\n<p>Since others seem to think that it's obvious why it was created that way I'll argue my points why it's hard/impossible to answer if you aren't Alexander Stepanov or someone who worked with him.</p>\n<p>Sadly the <a href=\"https://www.sgi.com/tech/stl/FAQ.html\" rel=\"nofollow\">SGI STL FAQ</a> doesn't mention <code>binary_search</code> at all. It explains reasoning for <code>list&lt;&gt;::size</code> being linear time or <code>pop</code> returning <code>void</code>. It doesn't seem like they deemed <code>binary_search</code> special enough to document it.</p>\n<p><strong>Let's look at the possible performance improvement mentioned by @user2899162:</strong></p>\n<p>You can find the original implementation of the SGI STL algorithm <code>binary_search</code> <a href=\"https://www.sgi.com/tech/stl/stl_algo.h\" rel=\"nofollow\">here</a>. Looking at it one can pretty much simplify it (we all know how awful the internal names in the standard library are) to:</p>\n<pre><code>template &lt;class ForwardIter, class V&gt;\nbool binary_search(ForwardIter first, ForwardIter last, const V&amp; value) {\n    ForwardIter it = lower_bound(first, last, value);\n    return it != last &amp;&amp; !(value &lt; *it);\n}\n</code></pre>\n<p>As you can see it was implemented in terms of <code>lower_bound</code> and got the same exact performance. If they really wanted it to take advantage of possible performance improvements they wouldn't have implemented it in terms of the slower one, so it doesn't seem like that was the reason they did it that way.</p>\n<p><strong>Now let's look at it simply being a convenience function</strong></p>\n<p>It being simply a convenience function seems more likely, but looking through the STL you'll find numerous other algorithms where this could have been possible. Looking at the above implementation you'll see that it's only trivially more to do than a <code>std::find(begin, end, value) != end;</code> yet we have to write that all the time and don't have a convenience function that returns a <code>bool</code>. Why exactly here and not all the other algorithms too? It's not really obvious and can't simply be explained. </p>\n<p><strong>In conclusion I find it far from obvious and don't really know if I could confidently and honestly answer it.</strong></p>\n</hr>", "LastEditorUserId": "1942027", "LastActivityDate": "2015-05-28T02:36:25.397", "Score": "0", "CreationDate": "2015-05-28T01:32:18.763", "ParentId": "30495744", "CommentCount": "3", "OwnerUserId": "1942027", "LastEditDate": "2015-05-28T02:36:25.397"}, "30495802": {"Id": "30495802", "PostTypeId": "2", "Body": "<p>The standard library contains variants of binary search algorithm that return iterators. They are called <a href=\"http://en.cppreference.com/w/cpp/algorithm/lower_bound\" rel=\"nofollow\">std::lower_bound</a> and <a href=\"http://en.cppreference.com/w/cpp/algorithm/upper_bound\" rel=\"nofollow\">std::upper_bound</a>. I think the rationale behind <code>std::binary_search</code> returning bool is that it wouldn't be clear what iterator to return in case of equivalent elements, while in case of <code>std::lower_bound</code> and <code>std::upper_bound</code> it is clear.</p>\n<p>There might have been performance considerations as well, because in theory <code>std::binary_search</code> could be implemented to perform better in case of multiple equivalent elements and certain types. However, at least one popular implementation of the standard library (<code>libstdc++</code>) implements <code>std::binary_search</code> using <code>std::lower_bound</code> and, moreover, they have the same theoretical complexity.</p>\n", "LastEditorUserId": "471164", "LastActivityDate": "2015-05-28T03:14:01.077", "Score": "0", "CreationDate": "2015-05-28T01:34:36.227", "ParentId": "30495744", "CommentCount": "2", "OwnerUserId": "471164", "LastEditDate": "2015-05-28T03:14:01.077"}, "30495813": {"Id": "30495813", "PostTypeId": "2", "Body": "<p>If you want to get an iterator on a value, you can use <a href=\"http://en.cppreference.com/w/cpp/algorithm/equal_range\" rel=\"nofollow\">std::equal_range</a> which will return 2 iterators, one on the lower bound and one on the higher bound of the range of values that are equal to the one you're looking for. </p>\n<p>Since the only requirement is that values are sorted and not unique, there's is no simple \"find\" that would return an iterator on the one element you're looking for. If there's only one element equal to the value you're looking for, there will only be a difference of 1 between the two iterators.</p>\n", "LastEditorUserId": "3748622", "LastActivityDate": "2015-05-28T01:53:41.860", "Score": "-1", "CreationDate": "2015-05-28T01:36:30.523", "ParentId": "30495744", "CommentCount": "2", "OwnerUserId": "3748622", "LastEditDate": "2015-05-28T01:53:41.860"}, "30534100": {"Id": "30534100", "PostTypeId": "2", "Body": "<p>The name of this function in 1994 version of STL was <code>isMember</code>. I think you'd agree that a function with that name should return <code>bool</code></p>\n<p><a href=\"http://www.stepanovpapers.com/Stepanov-The_Standard_Template_Library-1994.pdf\">http://www.stepanovpapers.com/Stepanov-The_Standard_Template_Library-1994.pdf</a></p>\n", "LastActivityDate": "2015-05-29T16:02:12.937", "CommentCount": "1", "CreationDate": "2015-05-29T16:02:12.937", "ParentId": "30495744", "Score": "5", "OwnerUserId": "273767"}});