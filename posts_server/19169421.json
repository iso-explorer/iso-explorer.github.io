post_cb({"19169421": {"CommentCount": "4", "AcceptedAnswerId": "19169458", "PostTypeId": "1", "LastEditorUserId": "952747", "CreationDate": "2013-10-03T21:19:13.430", "LastActivityDate": "2013-10-19T17:29:43.190", "LastEditDate": "2013-10-04T07:23:11.743", "ViewCount": "184", "FavoriteCount": "1", "Title": "Hidden move-construction", "Id": "19169421", "Score": "4", "Body": "<p>Why sometimes doesn't move-constructor call? Testing move-semantics <a href=\"http://coliru.stacked-crooked.com/a/c0dc0b228a66d1d1\" rel=\"nofollow\"><em>(Live code)</em></a>:</p>\n<pre><code>struct Test {\n    int id;\n    Test(int id) : id(id) {\n        cout &lt;&lt; id &lt;&lt; \"  Test() \" &lt;&lt; endl;\n    }\n    ~Test() {\n        cout &lt;&lt; id &lt;&lt; \"  ~Test() \" &lt;&lt; endl;\n    }\n    Test(const Test &amp;t) : id(t.id) {\n        cout &lt;&lt; id &lt;&lt; \"  Test(const Test &amp;t) \" &lt;&lt; endl;\n    }\n    Test(Test &amp;&amp;t) : id(t.id) {\n        cout &lt;&lt; id &lt;&lt; \"  Test(Test &amp;&amp;t) \" &lt;&lt; endl;\n    }\n    Test &amp;operator=(const Test &amp;t) {\n        cout &lt;&lt; id &lt;&lt; \"  operator=(const Test &amp;t) \" &lt;&lt; endl;\n        return *this;\n    }\n    Test &amp;operator=(Test &amp;&amp;t) {\n        cout &lt;&lt; id &lt;&lt; \"  operator=(Test &amp;&amp;t) \" &lt;&lt; endl;\n        return *this;\n    }\n};\n\nvoid f(Test z) {\n    cout &lt;&lt; z.id &lt;&lt; \"  f(Test z) \" &lt;&lt; endl;\n}\n\nint main() {\n    f(Test(1));\n\n    Test t(2); f(t);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>1  Test() \n1  f(Test t)               &lt;---// where is move constructor ?!\n1  ~Test() \n2  Test() \n2  Test(const Test &amp;t)     &lt;---// copy constructor of t(2)\n2  f(Test t) \n2  ~Test() \n2  ~Test()\n</code></pre>\n<p>Test shows copy-constructor is invoked.</p>\n<p>But, after <code>f(Test(1));</code> function <code>f</code> was called without invoking move-constructor for rvalue object of <code>Test(1)</code>.</p>\n<p>Is it an implicit compiler optimization? or I missed an important point?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "952747", "AnswerCount": "2"}, "19468922": {"ParentId": "19169421", "CommentCount": "0", "Body": "<p>To complete this discussion. We can disable this optimization (copy elision) in gcc by this  option:</p>\n<pre><code>-fno-elide-constructors\n</code></pre>\n", "OwnerUserId": "952747", "PostTypeId": "2", "Id": "19468922", "Score": "0", "CreationDate": "2013-10-19T17:29:43.190", "LastActivityDate": "2013-10-19T17:29:43.190"}, "bq_ids": {"n4140": {"so_19169421_19169458_0": {"section_id": 480, "quality": 0.9848484848484849, "length": 65}}, "n3337": {"so_19169421_19169458_0": {"section_id": 471, "quality": 0.9393939393939394, "length": 62}}, "n4659": {"so_19169421_19169458_0": {"section_id": 502, "quality": 0.9848484848484849, "length": 65}}}, "19169458": {"ParentId": "19169421", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The compiler is explicitly allowed to elide copies (or moves) of temporary objects. Basically, the object is constructed in the place where the effective result is expected. This elision is even allowed if the constructor or the destructor have side effects.</p>\n<p>The relevant clause is 12.8 [class.copy] paragraph 31:</p>\n<blockquote>\n<p id=\"so_19169421_19169458_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization. This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies): ...</p>\n</blockquote>\n<p>The cases where copy elision can be used are basically</p>\n<ol>\n<li>In <code>return</code> statements when returning a temporary or a local variable.</li>\n<li>In <code>throw</code> expressions when throwing a temporary or a local variable.</li>\n<li>When a temporary object would be copied.</li>\n<li>When catching an object by value.</li>\n</ol>\n<p>The exact conditions under which the copy can be elided are listed in 12.8 [class.copy] paragraph 31.</p>\n<p>The easiest approach to prevent copy/move elision is to pass it through a function which returns a suitable reference, e.g., using</p>\n<pre><code>f(std::move(Test(1)));\n</code></pre>\n<p>should prevent the move elision.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2013-10-03T21:29:11.140", "Id": "19169458", "Score": "8", "CreationDate": "2013-10-03T21:21:50.710", "LastActivityDate": "2013-10-03T21:29:11.140"}});