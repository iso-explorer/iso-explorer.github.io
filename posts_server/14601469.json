post_cb({"14601722": {"Id": "14601722", "PostTypeId": "2", "Body": "<p>The standard does not generally guarantee that swap doesn't throw.</p>\n<p>From 20.2.2/1:</p>\n<blockquote>\n<p id=\"so_14601469_14601722_0\">template void swap(T&amp; a, T&amp; b) noexcept(<em>see below</em>);</p>\n<p id=\"so_14601469_14601722_1\">Remark: The expression inside noexcept is equivalent to:</p>\n<pre><code> is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;\n is_nothrow_move_assignable&lt;T&gt;::value\n</code></pre>\n</blockquote>\n", "LastActivityDate": "2013-01-30T10:27:18.503", "CommentCount": "0", "CreationDate": "2013-01-30T10:27:18.503", "ParentId": "14601469", "Score": "9", "OwnerUserId": "585729"}, "14601469": {"ViewCount": "681", "Body": "<p>The C++ standard guarantees that <code>std::swap</code> will throw no exception. However, what if an object to swap throws an exception during swapping? Next, how should the caller find an exception has happened? and what measures should the caller take? </p>\n<p>PS: It is very common that a constructor throws an exception.</p>\n<pre><code>struct A\n{\n    A(const A&amp;)\n    {\n        throw 1;\n    }\n\n    A&amp; operator =(const A&amp;)\n    {\n        throw 2;\n        return *this;\n    }\n};\n\nint main()\n{\n    A a1, a2;\n    std::swap(a1, a2); // An exception happened, but the caller doesn't know.\n    // How to do here ???\n}\n</code></pre>\n", "AcceptedAnswerId": "14601648", "Title": "What if an object passed into std::swap throws an exception during swapping?", "CreationDate": "2013-01-30T10:15:15.153", "Id": "14601469", "CommentCount": "4", "LastEditDate": "2013-01-30T11:12:35.573", "PostTypeId": "1", "LastEditorUserId": "508343", "LastActivityDate": "2013-01-30T11:40:48.563", "Score": "5", "OwnerUserId": "508343", "Tags": "<c++><exception><c++11><standards><swap>", "AnswerCount": "2"}, "14601648": {"Id": "14601648", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_14601469_14601648_0\">The C++ standard guarantees that std::swap will throw no exception.</p>\n</blockquote>\n<p>No, it doesn't. See 20.2.2 or <a href=\"http://en.cppreference.com/w/cpp/algorithm/swap\">the reference</a>. There are two noexcept specifications for the two <code>std::swap</code> overloads:</p>\n<pre><code>template&lt;class T&gt; void swap(T&amp; a, T&amp; b)\nnoexcept(noexcept(\n    std::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp;\n    std::is_nothrow_move_assignable&lt;T&gt;::value\n))\n\ntemplate&lt;class T, size_t N&gt;\nvoid swap(T (&amp;a)[N], T (&amp;b)[N])    \nnoexcept(noexcept(swap(*a, *b)))\n</code></pre>\n<p>When these conditions aren't satisfied, <code>std::swap</code> can throw and you can catch it.</p>\n<hr>\n<p>In case of the class you have presented, the predicates <code>std::is_nothrow_move_constructible</code> and <code>std::is_nothrow_move_assignable</code> are false, so the instantiation <code>std::swap&lt;A&gt;</code> doesn't have the no-throw guarantee. It's perfectly legal to catch exceptions from this swap.</p>\n</hr>", "LastEditorUserId": "399317", "LastActivityDate": "2013-01-30T11:34:26.943", "Score": "15", "CreationDate": "2013-01-30T10:23:09.053", "ParentId": "14601469", "CommentCount": "4", "OwnerUserId": "399317", "LastEditDate": "2013-01-30T11:34:26.943"}, "bq_ids": {"n4140": {"so_14601469_14601722_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3937}}, "n3337": {"so_14601469_14601722_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 3797}}, "n4659": {"so_14601469_14601722_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 4824}}}});