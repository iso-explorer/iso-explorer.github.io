post_cb({"bq_ids": {"n4140": {"so_21554577_21554578_4": {"length": 14, "quality": 1.0, "section_id": 5999}, "so_21554577_21554578_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 6004}, "so_21554577_21554578_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6004}, "so_21554577_21554578_2": {"length": 21, "quality": 1.0, "section_id": 6004}, "so_21554577_21554578_5": {"length": 27, "quality": 0.9310344827586207, "section_id": 380}, "so_21554577_21554578_3": {"length": 18, "quality": 1.0, "section_id": 5810}, "so_21554577_21554578_6": {"length": 20, "quality": 0.9523809523809523, "section_id": 378}}, "n3337": {"so_21554577_21554578_4": {"length": 14, "quality": 1.0, "section_id": 5767}, "so_21554577_21554578_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5772}, "so_21554577_21554578_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5772}, "so_21554577_21554578_6": {"length": 20, "quality": 0.9523809523809523, "section_id": 369}, "so_21554577_21554578_5": {"length": 27, "quality": 0.9310344827586207, "section_id": 371}, "so_21554577_21554578_3": {"length": 18, "quality": 1.0, "section_id": 5583}, "so_21554577_21554578_2": {"length": 21, "quality": 1.0, "section_id": 5772}}, "n4659": {"so_21554577_21554578_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 7503}, "so_21554577_21554578_6": {"length": 18, "quality": 0.8571428571428571, "section_id": 392}, "so_21554577_21554578_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 7503}, "so_21554577_21554578_5": {"length": 27, "quality": 0.9310344827586207, "section_id": 395}, "so_21554577_21554578_3": {"length": 18, "quality": 1.0, "section_id": 7271}, "so_21554577_21554578_2": {"length": 21, "quality": 1.0, "section_id": 7503}}}, "21554578": {"Id": "21554578", "PostTypeId": "2", "Body": "<p>Yes, the standard requires the implementation to perform all computations and side effects of the constructor of <code>A</code> before accessing <code>state</code>.\n<hr/></p>\n<h3>Reference:</h3>\n<p>The expression <code>X(Y).Z</code> is a Postfix expression as per 5.2.5/1 of C++11:</p>\n<blockquote>\n<p id=\"so_21554577_21554578_0\">A postfix expression followed by a dot . or an arrow -&gt;, optionally followed by the keyword template (14.2), and then followed by an id-expression, is a postfix expression.</p>\n</blockquote>\n<p>The expression <code>X(Y)</code> is evaluated as per the same paragraph:</p>\n<blockquote>\n<p id=\"so_21554577_21554578_1\">The postfix expression before the dot or arrow is evaluated.<sup>64</sup></p>\n<p id=\"so_21554577_21554578_2\"><sup>64</sup>: <em>If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary to determine the value of the entire postfix expression, for example if the id-expression denotes a static member.</em></p>\n</blockquote>\n<p>That's where 1.9/14 applies:</p>\n<blockquote>\n<p id=\"so_21554577_21554578_3\">Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<p>Therefore, the computations and side effects of <code>X(Y)</code> are done as soon as the dot operator is evaluated.</p>\n<p>This expression however generates a fully constructed object <code>X</code> as per 5.2.3/1:</p>\n<blockquote>\n<p id=\"so_21554577_21554578_4\">[...] the expression <code>T(x1, x2, ...)</code> is equivalent in effect to the declaration <code>T t(x1, x2, ...);</code> for some invented temporary variable <code>t</code>, with the result being the value of <code>t</code> as a prvalue.</p>\n</blockquote>\n<p>and 12.2/3:</p>\n<blockquote>\n<p id=\"so_21554577_21554578_5\">When an implementation introduces a temporary object of a class that has a non-trivial constructor (12.1, 12.8), it shall ensure that a constructor is called for the temporary object. [...] Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>\n</blockquote>\n<p>The standard requires the program to behave that way even if the acutal creation of the temporary object has not been performed (12.2/1):</p>\n<blockquote>\n<p id=\"so_21554577_21554578_6\">Even when the creation of the temporary object is unevaluated (Clause 5) or otherwise avoided (12.8), all the semantic restrictions shall be respected as if the temporary object had been created and later destroyed.</p>\n</blockquote>\n", "LastActivityDate": "2014-02-04T14:00:37.793", "CommentCount": "0", "CreationDate": "2014-02-04T14:00:37.793", "ParentId": "21554577", "Score": "4", "OwnerUserId": "951423"}, "21554577": {"ViewCount": "77", "Body": "<p>Can I access the member of an object if I create a temporary object by using <code>class-type-name(parameters).member</code> and presume that the constructor is done?</p>\n<p>Consider the following example:</p>\n<pre><code>struct A\n{\n  enum status \n    { ERROR = -1, SUCCESS } state;\n  A (int a) \n    : state(a &gt; 0 ? SUCCESS : ERROR)\n  {\n    // do some stuff here\n    // may change state\n  }\n};\n\nint main (void)\n{\n  // Is this guaranteed to work?\n  A::status S(A(5).state);\n}\n</code></pre>\n<p>Is the constructor of A required to be done as soon as I access <code>state</code>?</p>\n", "AcceptedAnswerId": "21554578", "Title": "Can I access members of temporary objects?", "CreationDate": "2014-02-04T14:00:37.793", "Id": "21554577", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-02-04T14:00:37.793", "Score": "1", "OwnerUserId": "951423", "Tags": "<c++><member><temporary-objects>", "AnswerCount": "1"}});