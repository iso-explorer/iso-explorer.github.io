post_cb({"bq_ids": {"n4140": {"so_41826412_41826643_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 6169}}, "n3337": {"so_41826412_41826643_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5946}, "so_41826412_41826643_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5930}}, "n4659": {"so_41826412_41826643_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 7667}, "so_41826412_41826643_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 4087}}}, "41826643": {"Id": "41826643", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41826412_41826643_0\">I can understand that one operand would be implicitly converted ..., but not both</p>\n</blockquote>\n<p>Then you've misunderstood. EDIT: According to the experts in comments, argument dependent lookup appears to be a case where your assumption is correct. But yours isn't a case of ADL.</p>\n<blockquote>\n<p id=\"so_41826412_41826643_1\">What rule in the C++ standard allows for the implicit conversion of both operands</p>\n</blockquote>\n<p>From standard draft:</p>\n<blockquote>\n<p id=\"so_41826412_41826643_2\">[over.match] (2.9)</p>\n<ul>\n<li>Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed\n  to match <strong>each argument</strong> to the corresponding parameter of each viable function.</li>\n</ul>\n</blockquote>\n<p>My emphasis on \"each argument\". Not \"a single argument\".</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2017-01-24T11:35:11.473", "Score": "5", "CreationDate": "2017-01-24T11:07:31.740", "ParentId": "41826412", "CommentCount": "7", "LastEditDate": "2017-01-24T11:35:11.473", "OwnerUserId": "2079303"}, "41826412": {"ViewCount": "146", "Body": "<p>The following code compiles and executed without error even though no equality operator is defined:</p>\n<pre><code>class A {\npublic:\n    operator bool() const { return true; }\n};\n\n\nint main()\n{\n    A a, b;\n    a == b; //why does this compile?\n    return 0;\n}\n</code></pre>\n<p>What happens internally for <code>a == b</code> is that the <code>operator bool() const</code> is called for <strong>both</strong> operands, and then the two booleans are compared for equality (this happened in our production code where <code>class A</code> was a smart pointer type, and gave semantically dubious results).</p>\n<p>My question is: What rule in the C++ standard allows for the implicit conversion of <strong>both</strong> operands in this case? I can understand that <strong>one</strong> operand would be implicitly converted to <code>bool</code> for the test for equality <strong>if</strong> the other operand was already a <code>bool</code>, but not both.</p>\n", "AcceptedAnswerId": "41826643", "Title": "Implicit conversion of both operands for operator==", "CreationDate": "2017-01-24T10:57:57.607", "Id": "41826412", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-01-24T11:35:11.473", "Score": "10", "OwnerUserId": "3736861", "Tags": "<c++>", "AnswerCount": "1"}});