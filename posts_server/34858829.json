post_cb({"34859003": {"ParentId": "34858829", "CommentCount": "3", "Body": "<p>I believe that this is implied by <code>[basic.fundamental]/4</code> (N3337):</p>\n<blockquote>\n<p id=\"so_34858829_34859003_0\">Unsigned integers, declared <code>unsigned</code>, shall obey the laws of arithmetic modulo <code>2^n</code> where <code>n</code> is the number\n  of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "34859003", "Score": "15", "CreationDate": "2016-01-18T16:00:27.410", "LastActivityDate": "2016-01-18T16:00:27.410"}, "34859199": {"ParentId": "34858829", "CommentCount": "2", "Body": "<p>C++ specifies the ranges of the integral types by reference to the C standard. The C standard says:</p>\n<blockquote>\n<p id=\"so_34858829_34859199_0\">For unsigned integer types other than <code>unsigned char</code>, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter). If there are <em>N</em> value bits, each bit shall represent a different power of 2 between 1 and 2<sup><em>N</em>\u00a0\u2212\u00a01</sup>, so that objects of that type shall be capable of\n  representing values from 0 to 2<sup><em>N</em>\u00a0\u2212\u00a01</sup> using a pure binary representation; this shall be known as the value representation. The values of any padding bits are unspecified.</p>\n</blockquote>\n<p>Moreover, C++ requires:</p>\n<blockquote>\n<p id=\"so_34858829_34859199_1\">Unsigned integers shall obey the laws of arithmetic modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits in the value representation of that particular size of integer.</p>\n</blockquote>\n<p>Putting all this together, we find that an unsigned integral type has <em>n</em> value bits, represents the values in the range [0, 2<sup><em>n</em></sup>) and obeys the laws of arithmetic modulo 2<sup><em>n</em></sup>.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "34859199", "Score": "15", "CreationDate": "2016-01-18T16:10:27.507", "LastActivityDate": "2016-01-18T16:10:27.507"}, "bq_ids": {"n4140": {"so_34858829_34859003_0": {"section_id": 7213, "quality": 0.875, "length": 14}, "so_34858829_34859199_1": {"section_id": 7213, "quality": 1.0, "length": 14}}, "n3337": {"so_34858829_34859003_0": {"section_id": 6957, "quality": 1.0, "length": 16}, "so_34858829_34859199_1": {"section_id": 6957, "quality": 1.0, "length": 14}}, "n4659": {"so_34858829_34859003_0": {"section_id": 8722, "quality": 0.875, "length": 14}, "so_34858829_34859199_1": {"section_id": 8722, "quality": 1.0, "length": 14}}}, "34858829": {"CommentCount": "1", "CreationDate": "2016-01-18T15:53:20.313", "PostTypeId": "1", "AcceptedAnswerId": "34859199", "LastEditorUserId": "635608", "LastActivityDate": "2016-01-18T19:23:48.773", "LastEditDate": "2016-01-18T19:23:48.773", "ViewCount": "958", "FavoriteCount": "3", "Title": "Does the C++ standard require the maximum of unsigned integer numbers to be of the form 2^N-1?", "Id": "34858829", "Score": "20", "Body": "<p>For <code>T</code> so that <code>std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value</code> is <code>true</code>, does the C++ standard guarantee that :</p>\n<pre><code>std::numeric_limits&lt;T&gt;::max() == 2^(std::numeric_limits&lt;T&gt;::digits)-1\n</code></pre>\n<p>in the mathematical sense? I am looking for a proof of that based on quotes from the standard.</p>\n", "Tags": "<c++><c++11><standards><language-lawyer><unsigned>", "OwnerUserId": "882932", "AnswerCount": "2"}});