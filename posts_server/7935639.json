post_cb({"7935639": {"CommentCount": "6", "AcceptedAnswerId": "7938941", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2011-10-28T22:46:39.747", "LastActivityDate": "2011-10-29T17:16:38.773", "LastEditDate": "2011-10-29T16:48:23.503", "ViewCount": "1752", "FavoriteCount": "5", "Title": "Can we return objects having a deleted/private copy/move constructor by value from a function?", "Id": "7935639", "Score": "14", "Body": "<p>In C++03 it is impossible to return an object of a class having a private non-defined copy constructor by value:</p>\n<pre><code>struct A { A(int x) { ... } private: A(A const&amp;); };\n\nA f() {\n  return A(10); // error!\n  return 10;    // error too!\n}\n</code></pre>\n<p>I was wondering, was this restriction lifted in C++11, making it possible to write functions having a class type return type for classes without constructors used for copy or move? I remember it could be useful to allow callers of a function use the newly returned object, but that they are not able to copy the value and store it somewhere. </p>\n", "Tags": "<c++><c++11><copy-constructor>", "OwnerUserId": "34509", "AnswerCount": "5"}, "7935781": {"ParentId": "7935639", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_7935639_7935781_0\">I was wondering, was this restriction lifted in C++11?</p>\n</blockquote>\n<p>How could it be? By returning something by value, you are by definition copying (or moving) it. And while C++ can allow that copy/move to be elided in certain circumstances, it's still copying (or moving) by the specification.</p>\n<blockquote>\n<p id=\"so_7935639_7935781_1\">I remember it could be useful to allow callers of a function use the returned object, but that they are not able to copy the value and store it somewhere. </p>\n</blockquote>\n<p>Yes. You get rid of the copy constructor/assignment, but allow the value to be <em>moved</em>. <code>std::unique_ptr</code> does this.</p>\n<p>You can return a <code>unique_ptr</code> by value. But in doing so, you are returning an \"prvalue\": a temporary that is being destroyed. Therefore, if you have a function <code>g</code> as such:</p>\n<pre><code>std::unique_ptr&lt;SomeType&gt; g() {...}\n</code></pre>\n<p>You can do this:</p>\n<pre><code>std::unique_ptr&lt;SomeType&gt; value = g();\n</code></pre>\n<p>But not <em>this</em>:</p>\n<pre><code>std::unique_ptr&lt;SomeType&gt; value1 = g();\nstd::unique_ptr&lt;SomeType&gt; value2 = g();\nvalue1 = value 2;\n</code></pre>\n<p>But this <em>is</em> possible:</p>\n<pre><code>std::unique_ptr&lt;SomeType&gt; value = g();\nvalue = g();\n</code></pre>\n<p>The second line invokes the move assignment operator on <code>value</code>. It will delete the old pointer and <em>move</em> the new pointer into it, leaving the old value empty.</p>\n<p>In this way, you can ensure that the contents of any <code>unique_ptr</code> is only ever stored in one place. You can't stop them from referencing it in multiple places (via pointers to <code>unique_ptr</code> or whatever), but there will be at most one location in memory where the actual pointer is stored.</p>\n<p>Removing both the copy and move constructors creates an <em>immobile</em> object. Where it is created is where it's values stay, <em>forever</em>. Movement allows you to have unique ownership, but without being immobile.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2011-10-29T17:16:38.773", "Id": "7935781", "Score": "1", "CreationDate": "2011-10-28T23:08:42.647", "LastActivityDate": "2011-10-29T17:16:38.773"}, "7935954": {"ParentId": "7935639", "CommentCount": "0", "Body": "<p>The restriction has not been lifted. As per the access specifier, there is a note in \u00a712.8/32 that explains:</p>\n<blockquote>\n<p id=\"so_7935639_7935954_0\">two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided.</p>\n</blockquote>\n<p>As of the deleted copy/move constructors \u00a78.4.3/2 states that</p>\n<blockquote>\n<p id=\"so_7935639_7935954_1\">A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed. [ Note: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member to the function. It applies even for references in expressions that are not potentially-evaluated. If a function is overloaded, it is referenced only if the function is selected by overload resolution. \u2014 end note ]</p>\n</blockquote>\n<p>Not sure about this particular case, but my understanding of the quote is that, if after the overload resolution in \u00a712.8/32 the deleted copy/move constructor is selected, even if the operation is elided, that could constitute a <em>reference</em> to the function, and the program would be ill formed.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "7935954", "Score": "5", "CreationDate": "2011-10-28T23:41:54.760", "LastActivityDate": "2011-10-28T23:41:54.760"}, "7936273": {"ParentId": "7935639", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You could probably hack together a proxy to do the trick if you really wanted, and have a converting constructor that copies the value stored within the proxy.</p>\n<p>Something along the lines of:</p>\n<pre><code>template&lt;typename T&gt;\nstruct ReturnProxy {\n    //This could be made private, provided appropriate frienship is granted\n    ReturnProxy(T* p_) : p(p_) { }\n    ReturnProxy(ReturnProxy&amp;&amp;) = default;\n\nprivate:\n    //don't want these Proxies sticking around...\n    ReturnProxy(const ReturnProxy&amp;) = delete;\n    void operator =(const ReturnProxy&amp;) = delete;\n    void operator =(ReturnProxy&amp;&amp;) = delete;\n\n    struct SUPER_FRIENDS { typedef T GO; };\n    friend struct SUPER_FRIENDS::GO;\n    unique_ptr&lt;T&gt; p;\n};\n\nstruct Object {\n    Object() : data(0) { }\n\n    //Pseudo-copy constructor\n    Object(ReturnProxy&lt;Object&gt;&amp;&amp; proxy)\n      : data(proxy.p ? proxy.p-&gt;data : throw \"Don't get sneaky with me \\\\glare\") \n    {\n      //steals `proxy.p` so that there isn't a second copy of this object floating around\n      //shouldn't be necessary, but some men just want to watch the world burn.\n      unique_ptr&lt;Object&gt; thief(std::move(proxy.p));\n    }\nprivate:\n    int data;\n\n    Object(const Object&amp;) = delete;\n    void operator =(const Object&amp;) = delete;\n};\n\nReturnProxy&lt;Object&gt; func() {\n    return ReturnProxy(new Object);\n}\n\nint main() {\n    Object o(func());\n}\n</code></pre>\n<p>You could probably do the same in 03, though, using <code>auto_ptr</code>s.  And it obviously doesn't prevent storage of the resultant <code>Object</code>, although it does limit you to one copy per instance.</p>\n", "OwnerUserId": "293791", "LastEditorUserId": "293791", "LastEditDate": "2011-10-29T01:26:41.983", "Id": "7936273", "Score": "0", "CreationDate": "2011-10-29T00:56:36.783", "LastActivityDate": "2011-10-29T01:26:41.983"}, "7935673": {"ParentId": "7935639", "CommentCount": "1", "Body": "<p>The above code is still ill-formed in C++11.  But you could add a public move constructor to <code>A</code> and then it would be legal:</p>\n<pre><code>struct A\n{\n    A(int x) {}\n    A(A&amp;&amp;);\nprivate:\n    A(A const&amp;);\n};\n\nA f() {\n  return A(10); // Ok!\n}\n</code></pre>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "7935673", "Score": "4", "CreationDate": "2011-10-28T22:51:57.303", "LastActivityDate": "2011-10-28T22:51:57.303"}, "7938941": {"ParentId": "7935639", "CommentCount": "15", "Body": "<p>Here is how it can work</p>\n<pre><code>A f() {\n  return { 10 };\n}\n</code></pre>\n<p>This works even though <code>A</code> has no working copy or move constructor and no other constructor that could copy or move an <code>A</code>!</p>\n<p>To make use of this feature of C++11, the constructor (taking <code>int</code> in this case) has to be non-explicit though.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "7938941", "Score": "14", "CreationDate": "2011-10-29T12:36:56.400", "LastActivityDate": "2011-10-29T12:36:56.400"}, "bq_ids": {"n4140": {"so_7935639_7935954_0": {"section_id": 481, "quality": 1.0, "length": 23}, "so_7935639_7935954_1": {"section_id": 3277, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_7935639_7935954_0": {"section_id": 472, "quality": 1.0, "length": 23}, "so_7935639_7935954_1": {"section_id": 3148, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_7935639_7935954_0": {"section_id": 504, "quality": 1.0, "length": 23}, "so_7935639_7935954_1": {"section_id": 4035, "quality": 0.8823529411764706, "length": 30}}}});