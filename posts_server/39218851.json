post_cb({"bq_ids": {"n4140": {"so_39218851_39220703_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 176}, "so_39218851_39220554_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 204}}, "n3337": {"so_39218851_39220703_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 170}, "so_39218851_39220554_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 198}}, "n4659": {"so_39218851_39220703_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 181}, "so_39218851_39220554_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 210}}}, "39220224": {"Id": "39220224", "PostTypeId": "2", "Body": "<p>Your example can be simplified even further:</p>\n<pre><code>template &lt;typename T&gt; struct A {\n    void f() { this = 1; }\n};\nint main() {\n    A&lt;int&gt; a;\n}\n</code></pre>\n<p>The statement <code>this = 1;</code> should never compile and that can't be fixed even if <code>A&lt;T&gt;</code> has a type-dependent base class. However the compiler doesn't complain until the function <code>A&lt;T&gt;::f()</code> is instantiated.</p>\n<p>As <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub - litb</a> has already <a href=\"https://stackoverflow.com/a/39220554/6394138\">answered</a> this may be a \"no diagnostic required\" situation.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-30T06:52:07.533", "Score": "0", "CreationDate": "2016-08-30T06:27:04.107", "ParentId": "39218851", "CommentCount": "0", "LastEditDate": "2017-05-23T12:16:22.260", "OwnerUserId": "6394138"}, "39218851": {"ViewCount": "239", "Body": "<p>The following code can be compiled without error:</p>\n<pre><code>template &lt;typename T&gt; struct A {\n    void f() { this-&gt;whatever; } // whatever is not declared before\n};\nint main() {\n    A&lt;int&gt; a;\n}\n</code></pre>\n<p>And I know it's because <code>this</code> is a type-dependent expression, which makes name lookup for <code>whatever</code> is postponed until the actual template argument is known. Since member function <code>f()</code> is never used in this case, so that no instantiation of <code>A&lt;T&gt;::f</code> exists, and name lookup for <code>whatever</code> is never performed.</p>\n<p>I can understand that <code>this</code> is type-dependent if the class template has a type-dependent base like:</p>\n<pre><code>template &lt;typename T&gt; struct B { T whatever; };\ntemplate &lt;typename T&gt; struct A : B&lt;T&gt; {\n    void f() { this-&gt;whatever; }\n};\nint main() {\n    A&lt;int&gt; a;\n}\n</code></pre>\n<p>When parsing the definition of template class <code>A</code>, it's impossible to know what's type of its base, which makes <code>this-&gt;whatever</code> potentially legal (<code>B&lt;T&gt;</code> could has a member named <code>whatever</code>). On the contrary, I haven't see any potential that <code>this-&gt;whatever</code> would be legal in the first example as soon as member function <code>f</code> is used somewhere.</p>\n<p>So, could <code>this-&gt;whatever</code> be legal at some points in the first example? If not, is there any other reason that <code>this</code> should be treated as type-dependent expression in that case?</p>\n", "AcceptedAnswerId": "39220554", "Title": "Why `this` is a type-dependent expression even if the template class has no base class?", "CreationDate": "2016-08-30T04:37:07.367", "Id": "39218851", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-08-30T06:14:28.187", "LastEditorUserId": "5845611", "LastActivityDate": "2016-08-30T06:55:21.250", "Score": "11", "OwnerUserId": "5845611", "Tags": "<c++><templates><dependent-name>", "AnswerCount": "3"}, "39220703": {"Id": "39220703", "PostTypeId": "2", "Body": "<p>This is the name lookup rules about dependent names.</p>\n<p><a href=\"http://eel.is/c++draft/temp.res#9\" rel=\"nofollow\">$14.6/9 Name resolution\n[temp.res]</a>:</p>\n<blockquote>\n<p id=\"so_39218851_39220703_0\">When looking for the declaration of a name used in a template definition, the usual lookup rules ([basic.lookup.unqual], [basic.lookup.argdep]) are used for non-dependent names. The lookup of names dependent on the template parameters is postponed until the actual template argument is known ([temp.dep]).</p>\n</blockquote>\n<p>The intent is, the information is not sufficient if the name depends on template parameter, until the actual template argument is known. The complier won't distinguish the dependent names' type (formed by <code>this</code> or others), won't check the details like the class has a dependent base class or not. The result might not change like sample code you showed, but it just postpones the name lookup until the type is known, to make the most accurate decision.</p>\n", "LastActivityDate": "2016-08-30T06:55:21.250", "Score": "0", "CreationDate": "2016-08-30T06:55:21.250", "ParentId": "39218851", "CommentCount": "0", "OwnerUserId": "3309790"}, "39220554": {"Id": "39220554", "PostTypeId": "2", "Body": "<p>Your code is \"ill-formed, no diagnostic required\", because there is never a valid specialization for <code>A::f</code>. In fact, the spec says that <code>this-&gt;whatever</code> is neither a member of an unknown specialization (because there is no dependent base class), nor a member of the current instantiation (because it's not declared in a non-dependent base class, nor in the class template itself). This in addition renders your code invalid, and again no diagnostic is required (but allowed). This is explained in more details at <a href=\"https://stackoverflow.com/a/17579889/34509\">https://stackoverflow.com/a/17579889/34509</a></p>\n<p><code>this</code> is type-dependent because you don't know the template parameter values yet in the definition. So for instance <code>SomeOtherTemplate&lt;decltype(*this)&gt;</code> cannot be resolved immediately, but needs to wait till the class template of <code>this</code> is instantiated (so you need a <code>typename</code> before <code>SomeOtherTemplate&lt;decltype(*this)&gt;::type</code>).</p>\n<p>However, just because <code>this</code> is type dependent, doesn't mean that <code>this-&gt;whatever</code> is aswell. As described above, the spec has tools to correctly categorize this as invalid, and in fact also does <em>not</em> make <code>this-&gt;whatever</code> type dependent. It says</p>\n<blockquote>\n<p id=\"so_39218851_39220554_0\">A class member access expression ([expr.ref]) is type-dependent if the expression refers to a member of the current instantiation and the type of the referenced member is dependent, or the class member access expression refers to a member of an unknown specialization.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-30T06:52:55.733", "Score": "4", "CreationDate": "2016-08-30T06:47:17.143", "ParentId": "39218851", "CommentCount": "1", "LastEditDate": "2017-05-23T12:00:55.833", "OwnerUserId": "34509"}});