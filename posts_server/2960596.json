post_cb({"2960669": {"Id": "2960669", "PostTypeId": "2", "Body": "<p>When you say the last line is blank what do you mean? If you mean that the second to last line ends with a carriage return/line feed then you don't technically have a last line, and it sounds like getline() is behaving as I would expect it to.</p>\n<p>Consider your example:</p>\n<pre><code>Line A\nLine B\nLine C\n</code></pre>\n<p>This is actually three lines that end in \\r\\n, and the third line's \\r\\n is what puts the cursor on the 4th line. There isn't actually a 4th line.</p>\n", "LastActivityDate": "2010-06-02T18:53:29.980", "CommentCount": "0", "CreationDate": "2010-06-02T18:53:29.980", "ParentId": "2960596", "Score": "0", "OwnerUserId": "356076"}, "11145292": {"Id": "11145292", "PostTypeId": "2", "Body": "<p>The C++ standard has this to say about <code>getline</code>:</p>\n<blockquote>\n<p id=\"so_2960596_11145292_0\">C++ 2003, 21.3.7.9/5</p>\n<p id=\"so_2960596_11145292_1\">[<code>getline(is, str, delim)</code>] \u2026 extracts characters from <code>is</code> \u2026 until any of the following occurs:</p>\n<ul>\n<li>end-of-file occurs on the input sequence \u2026</li>\n<li><code>c == delim</code> [<strong>N.b. default delim is <code>'\\n'</code></strong>] for the next available input character <code>c</code> (in which case, c is extracted but not appended)</li>\n<li><code>str.max_size()</code> characters are stored</li>\n</ul>\n</blockquote>\n<p><sup>Bracketd editorial comments added</sup></p>\n<p>To put it in your vernacular, <code>getline</code> treats <code>'\\n'</code> as a terminator, not a separator.</p>\n", "LastActivityDate": "2012-06-21T19:22:09.530", "CommentCount": "1", "CreationDate": "2012-06-21T19:22:09.530", "ParentId": "2960596", "Score": "2", "OwnerUserId": "8747"}, "2960596": {"ViewCount": "1048", "Body": "<p>I'm using <code>std::getline()</code> to enumerate through the lines in a file, and it's mostly working. It's left me curious however - <code>std::getline()</code> is skipping the very last line in my file, but only if it's blank. Using this minimal example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n        std::string line;\n        while(std::getline(std::cin, line))\n                std::cout &lt;&lt; \"Line: \u201c\" &lt;&lt; line &lt;&lt; \"\u201d\\n\";\n        return 0;\n}\n</code></pre>\n<p>If I feed it this:</p>\n<pre><code>Line A\nLine B\nLine C\n</code></pre>\n<p>I get those lines back at me. But this:</p>\n<pre><code>Line A\nLine B\nLine C\n[* line is present but blank, ie, the file end is: \"...B\\nLine C\\n\" *]\n</code></pre>\n<p>(I unfortunately can't have a blank line in SO's little code box thing...)\nSo, first file has three lines ( [\"Line A\", \"Line B\", \"Line C\"] ), second file has four ( [\"Line A\", \"Line B\", \"Line C\", \"\"] )</p>\n<p>This to me seems wrong - I have a four line file, and enumerating it with getline() leaves me with 3. What's really got me scratching my head is that this is exactly what the standard says it should do. (21.3.7.9)</p>\n<p>Even Python has similar behaviour (but it gives me the newlines too - C++ chops them off.) Is this some weird thing where C++ is expected lines to be terminated, and not separated by '\\n', and I'm feeding it differently?</p>\n<h2>Edit</h2>\n<p>Clearly, I need to expand a bit here. I've met up with two philosophies of determining what a \"line\" in a file is:</p>\n<ul>\n<li><strong>Lines are <em>terminated</em> by newlines</strong> - Dominant in systems such as Linux, and editors like vim. Possible to have a slightly \"odd\" file by not having a final '\\n' (a \"noeol\" in vim). Impossible to have a blank line at the end of a file.</li>\n<li><strong>Lines are <em>separated</em> by newlines</strong> - Dominant in just about every Windows editor I've ever come across. Every file is valid, and it's possible to have the last line be blank.</li>\n</ul>\n<p>Of course, YMMV as to what a newline is.</p>\n<p>I've always treated these as two completely different schools of thought. One earlier point I tried to make was to ask if the C++ standard was explicitly or merely implicitly following the first.</p>\n<p>Thus, getting back to the question at hand, the second example, which can be thought of as \"A\\nB\\nC\\n\" has <em>four</em> lines, following the separated philosophy. Now, does C++ explicitly follow a terminated philosophy, or is this just the way the standard is? (They don't record much reasoning in standards...) I'm hesitant to say it was explicit, since it's a bit painful to tell if you have what vim calls a \"noeol\" file with C++. (Python, for example, leaves the newlines in, so you can tell that way)</p>\n<p>Since everything in Windows follows the separated philosophy, I'm looking for something a bit deeper than \"Both examples have 3 lines.\"</p>\n<p>(Curiously, where is Mac? terminated or separated?)</p>\n", "Title": "getline() sets failbit and skips last line", "CreationDate": "2010-06-02T18:46:19.043", "LastActivityDate": "2012-06-21T19:22:09.530", "CommentCount": "3", "LastEditDate": "2010-06-03T00:30:06.873", "PostTypeId": "1", "LastEditorUserId": "101999", "Id": "2960596", "Score": "1", "OwnerUserId": "101999", "Tags": "<c++>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2960596_11145292_1": {"length": 5, "quality": 0.625, "section_id": 1855}}, "n3337": {"so_2960596_11145292_1": {"length": 5, "quality": 0.625, "section_id": 1849}}, "n4659": {"so_2960596_11145292_1": {"length": 5, "quality": 0.625, "section_id": 2028}}}, "2960659": {"Id": "2960659", "PostTypeId": "2", "Body": "<p>I count only three lines in both your data sets.  The first data set is simply missing a line ending character which is present in the second data set.</p>\n<p>Your editor represents an empty line after 'Line C' for convenience.  If you pipe its contents through wc -l you will find it says 3.</p>\n", "LastActivityDate": "2010-06-02T18:52:37.003", "CommentCount": "0", "CreationDate": "2010-06-02T18:52:37.003", "ParentId": "2960596", "Score": "1", "OwnerUserId": "350821"}});