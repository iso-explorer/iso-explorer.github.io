post_cb({"2960546": {"ParentId": "2960496", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>This has nothing to do with wasting memory and more with memory organization.</p>\n<p>When you work with the memory space, you have to assume that anything not directly \"Belonging to you\" is shared by the entire system or illegal for you to access. An address \"belongs to you\" if you have taken the address of something on the stack that is still on the stack, or if you have received it from a dynamic memory allocator and have not yet recycled it. Some OS calls will also provide you with legal areas. </p>\n<p>In the good old days of real mode (e.g., DOS), all the beginning of the machine's address space was not meant to be written by user programs at all. Some of it even mapped to things like I/O. \nFor instance, writing to the address space at 0xB800 (fairly low) would actually let you capture the screen! Nothing was ever placed at address 0, and many memory controller would not let you access it, so it was a great choice for NULL. In fact, the memory controller on some PCs would have gone bonkers if you tried writing there.</p>\n<p>Today the operating system protects you with a virtual address space. Nevertheless, no process is allowed to access addresses not allocated to it. Most of the addresses are not even mapped to an actual memory page, so accessing them will trigger a general protection fault or the equivalent in your operating system. This is why 0 is not wasted - even though all the processes on your machine \"have an address 0\", if they try to access it, it is not mapped anywhere. </p>\n", "OwnerUserId": "23072", "LastEditorUserId": "23072", "LastEditDate": "2010-06-02T18:53:23.210", "Id": "2960546", "Score": "10", "CreationDate": "2010-06-02T18:41:09.450", "LastActivityDate": "2010-06-02T18:53:23.210"}, "2961450": {"ParentId": "2960496", "CommentCount": "0", "Body": "<p>You are correct in noting that the address space at 0 is not usable storate for your program.  For a number of reasons a variety of systems do not consider this a valid address space for your program anyway.</p>\n<p>Allowing any valid address to be used would require a null value flag for all pointers.  This would exceed the overhead of the lost memory at address 0.  It would also require additional code to check and see if the address were null or not, wasting memory and processor cycles. </p>\n<p>Ideally, the address that NULL pointer is using (usually 0) should return an error on access.  VAX/VMS never mapped a page to address 0 so following the NULL pointer would result in a failure.</p>\n", "OwnerUserId": "147481", "PostTypeId": "2", "Id": "2961450", "Score": "0", "CreationDate": "2010-06-02T20:42:51.590", "LastActivityDate": "2010-06-02T20:42:51.590"}, "2977745": {"ParentId": "2960496", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I don't see the answers directly addressing what i <em>think</em> you were asking, so here goes:</p>\n<p>Yes, at least 1 address value is \"wasted\" (made unavailable for use) because of the constant used for <em>null</em>. Whether it maps to 0 in linear map of process memory is not relevant. </p>\n<p>And the reason that address won't be used for data storage is that you need that special status of the null pointer, to be able to distinguish from any other real pointer. Just like in the case of ASCIIZ strings (C-string, NUL-terminated), where the NUL character is designated as end of character string and cannot be used inside strings. Can you still use it inside? Yeah but that will mislead library functions as of where string ends.</p>\n<p>I can think of at least one implementation of LISP i was learning, in which NIL (Lisp's null) was not 0, nor was it an invalid address but a real object. The reason was very clever - the standard required that CAR(NIL)=NIL and CDR(NIL)=NIL (Note: CAR(l) returns pointer to the head/first element of a list, where CDR(l) returns ptr to the tail/rest of the list.). So instead of adding if-checks in CAR and CDR whether the pointer is NIL - which will slow every call - they just allocated a CONS (think list) and assigned its head and tail to point to itself. There! - this way CAR and CDR will work and that address in memory won't be reused (because it is taken by the object devised as NIL)</p>\n<p>ps. i just remembered that many-many years ago i read about some bug of Lattice-C that was related to NULL - must have been in the dark MS-DOS segmentation times, where you worked with separate code segment and data segment - so i remember there was an issue that it was possible for the first function from a linked library to have address 0, thus pointer to it will be considered invalid since ==NULL</p>\n", "OwnerUserId": "226086", "LastEditorUserId": "226086", "LastEditDate": "2010-06-04T21:54:51.270", "Id": "2977745", "Score": "1", "CreationDate": "2010-06-04T20:55:30.913", "LastActivityDate": "2010-06-04T21:54:51.270"}, "2960558": {"ParentId": "2960496", "CommentCount": "0", "Body": "<p>The zero address and the NULL pointer are not (necessarily) the same thing. Only a <em>literal</em> zero is a null pointer. In other words:</p>\n<pre><code>char* p = 0; // p is a null pointer\n\nchar* q = 1;\nq--; // q is NOT necessarily a null pointer\n</code></pre>\n<p>Systems are free to represent the null pointer internally in any way they choose, and this representation may or may not \"waste\" a byte of memory by making the actual 0 address illegal. However, a compiler is required to convert a <em>literal</em> zero pointer into whatever the system's internal representation of NULL is. A pointer that comes to point to the zero address by some way other than being assigned a literal zero is not necessarily null.</p>\n<p>Now, most systems do use 0 for NULL, but they don't have to.</p>\n", "OwnerUserId": "39375", "PostTypeId": "2", "Id": "2960558", "Score": "6", "CreationDate": "2010-06-02T18:42:28.430", "LastActivityDate": "2010-06-02T18:42:28.430"}, "2961273": {"ParentId": "2960496", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As people already have pointed out, the bit representation of the NULL pointer has not to be the same as the bit represention of a 0 value. It is though in nearly all cases (the old dinosaur computers that had special addresses can be neglected) because a NULL pointer can also be used as a boolean and by using an integer (of suffisent size) to hold the pointer value it is easier to represent in the common ISAs of modern CPU. The code to handle it is then much more straight forward, thus less error prone.</p>\n", "OwnerUserId": "146377", "LastEditorUserId": "146377", "LastEditDate": "2010-06-02T20:30:26.050", "Id": "2961273", "Score": "0", "CreationDate": "2010-06-02T20:15:32.983", "LastActivityDate": "2010-06-02T20:30:26.050"}, "2960567": {"ParentId": "2960496", "CommentCount": "3", "Body": "<p>But since modern operating systems can map the physical memory to logical memory addresses (or better: modern CPUs starting with the 386), not even a single byte is wasted.</p>\n", "OwnerUserId": "331515", "PostTypeId": "2", "Id": "2960567", "Score": "0", "CreationDate": "2010-06-02T18:43:20.043", "LastActivityDate": "2010-06-02T18:43:20.043"}, "2960559": {"ParentId": "2960496", "CommentCount": "0", "Body": "<p>On many processors address zero is the reset vector, wherein lies the bootrom (BIOS on a PC), so you are unlikely to be storing anything at that physical address.  On a processor with an MMU and a supporting OS, the physical and logical address addresses need not be the same, and the address zero may not be a valid logical address in the executing process context.</p>\n", "OwnerUserId": "168986", "PostTypeId": "2", "Id": "2960559", "Score": "3", "CreationDate": "2010-06-02T18:42:29.540", "LastActivityDate": "2010-06-02T18:42:29.540"}, "2960544": {"ParentId": "2960496", "CommentCount": "2", "Body": "<p>The memory at that address is reserved for use by the operating system.  0 - 64k is reserved.  0 is used as a special value to indicate to developers \"not a valid address\".</p>\n", "OwnerUserId": "47589", "PostTypeId": "2", "Id": "2960544", "Score": "-1", "CreationDate": "2010-06-02T18:41:04.233", "LastActivityDate": "2010-06-02T18:41:04.233"}, "bq_ids": {"n4140": {"so_2960496_2960528_0": {"section_id": 39, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_2960496_2960528_0": {"section_id": 36, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_2960496_2960528_0": {"section_id": 7687, "quality": 0.6153846153846154, "length": 8}}}, "2960565": {"ParentId": "2960496", "CommentCount": "0", "Body": "<p>It is not necessarily an illegal memory location.  I have stored data by dereferencing a pointer to zero... it happens the datum was an interrupt vector being stored at the vector located at address zero.</p>\n<p>By convention it is not normally used by application code since historically many systems had important system information starting at zero.  It could be the boot rom or a vector table or even unused address space.</p>\n", "OwnerUserId": "350821", "PostTypeId": "2", "Id": "2960565", "Score": "5", "CreationDate": "2010-06-02T18:43:04.747", "LastActivityDate": "2010-06-02T18:43:04.747"}, "2960528": {"ParentId": "2960496", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>There is no requirement that a null pointer be equal to the 0-address, it's just that most compilers implement it this way. It is perfectly possible to implement a null pointer by storing some other value and in fact <a href=\"http://c-faq.com/null/machexamp.html\" rel=\"noreferrer\">some systems do this</a>. The <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"noreferrer\">C99 specification</a> \u00a76.3.2.3 (Pointers) specifies only that an integer constant expression with the value 0 is a null pointer constant, but it does not say that a null pointer when converted to an integer has value 0.</p>\n<blockquote>\n<p id=\"so_2960496_2960528_0\">An integer constant expression with the value 0, or such an expression cast to type\n  void *, is called a null pointer constant.</p>\n<p id=\"so_2960496_2960528_1\">Any pointer type may be converted to an integer type. Except as previously specified, the\n  result is implementation-defined. If the result cannot be represented in the integer type,\n  the behavior is undefined. The result need not be in the range of values of any integer\n  type.</p>\n</blockquote>\n<p>On some embedded systems the zero memory address is used for something addressable.</p>\n", "OwnerUserId": "61974", "LastEditorUserId": "61974", "LastEditDate": "2010-06-02T18:54:41.133", "Id": "2960528", "Score": "6", "CreationDate": "2010-06-02T18:39:47.717", "LastActivityDate": "2010-06-02T18:54:41.133"}, "2960496": {"CommentCount": "6", "AcceptedAnswerId": "2960543", "CreationDate": "2010-06-02T18:36:36.360", "LastActivityDate": "2010-06-04T23:30:14.537", "PostTypeId": "1", "ViewCount": "5391", "FavoriteCount": "7", "Title": "Why is NULL/0 an illegal memory location for an object?", "Id": "2960496", "Score": "12", "Body": "<p>I understand the purpose of the <code>NULL</code> constant in C/C++, and I understand that it needs to be represented <em>some</em> way internally.</p>\n<p>My question is: Is there some fundamental reason why the 0-address would be an invalid memory-location for an object in C/C++? Or are we <strong>in theory</strong> \"wasting\" one byte of memory due to this reservation?</p>\n", "Tags": "<c++><c><null><memory-management>", "OwnerUserId": "276052", "AnswerCount": "12"}, "2960616": {"ParentId": "2960496", "CommentCount": "1", "Body": "<p><code>NULL</code> is typically the zero address, but it is the zero address in your applications <em>virtual address space</em>.  The virtual addresses that you use in most modern operating systems have exactly nothing to do with actual physical addresses, the OS maps from the virtual address space to the physical addresses for you.  So, no, having the virtual address 0 representing <code>NULL</code> does not waste any memory.</p>\n<p>Read up on <a href=\"http://en.wikipedia.org/wiki/Virtual_memory\" rel=\"nofollow noreferrer\">virtual memory</a> for a more involved discussion if you're curious.</p>\n", "OwnerUserId": "215568", "PostTypeId": "2", "Id": "2960616", "Score": "1", "CreationDate": "2010-06-02T18:48:46.253", "LastActivityDate": "2010-06-02T18:48:46.253"}, "2960543": {"ParentId": "2960496", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The null pointer does not actually have to be 0. It's guaranteed in the C spec that when a constant 0 value is given in the context of a pointer it is treated as null by the compiler, however if you do</p>\n<pre><code>char *foo = (void *)1;\n--foo;\n// do something with foo\n</code></pre>\n<p>You will access the 0-address, not necessarily the null pointer. In most cases this happens to actually be the case, but it's not necessary, so we don't really have to waste that byte. Although, in the larger picture, if it isn't 0, it has to be something, so a byte is being wasted <em>somewhere</em></p>\n<p>Edit: Edited out the use of NULL due to the confusion in the comments. Also, the main message here is \"null pointer != 0, and here's some C/pseudo code that shows the point I'm trying to make.\" Please don't actually try to compile this or worry about whether the types are proper; the meaning is clear.</p>\n", "OwnerUserId": "144846", "LastEditorUserId": "144846", "LastEditDate": "2010-06-04T23:30:14.537", "Id": "2960543", "Score": "20", "CreationDate": "2010-06-02T18:41:01.847", "LastActivityDate": "2010-06-04T23:30:14.537"}});