post_cb({"23298586": {"CommentCount": "6", "ViewCount": "85", "PostTypeId": "1", "LastEditorUserId": "2869509", "CreationDate": "2014-04-25T16:37:11.127", "LastActivityDate": "2014-04-25T17:21:38.027", "Title": "Boilerplate function name", "AcceptedAnswerId": "23298844", "LastEditDate": "2014-04-25T17:21:38.027", "Id": "23298586", "Score": "1", "Body": "<p>On projects I have been on, most have boilerplate code for creating a local variable for the function name.  What is the fastest/best way?  Or, is there a faster/better way to do it?  We are certain these functions will be called frequently, and it's a performance-critical project. So, what's the best way to initialize our function names? </p>\n<p>Some I have seen:</p>\n<pre><code>/*1*/  const static std::string functionName(\"function1\");\n/*2*/  const static std::string functionName( __PRETTY_FUNCTION__ );\n/*3*/  const std::string functionName(\"function1\");\n/*4*/  const char functionName [] = \"function1\";  \n</code></pre>\n<p>Edit: I figured this would be obvious, but the reason we use such a declaration is so we can use the functionName variable to print out debugging information in the function. Maybe the reason it's not obvious is because we aren't implementing it well. I would love to hear about other ways to implement this. </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "2869509", "AnswerCount": "2"}, "23298779": {"ParentId": "23298586", "CommentCount": "1", "Body": "<p>There is no time needed to initialize the function name pointer, because this will be done during compile/link time if you use only a pointer to the function name, which is a compile time constant.</p>\n<pre><code>void foo()\n{\n    static const char* myname =  __PRETTY_FUNCTION__ ;\n\n}\n</code></pre>\n", "OwnerUserId": "878532", "PostTypeId": "2", "Id": "23298779", "Score": "2", "CreationDate": "2014-04-25T16:46:58.473", "LastActivityDate": "2014-04-25T16:46:58.473"}, "bq_ids": {"n4140": {"so_23298586_23298844_0": {"section_id": 3269, "quality": 0.875, "length": 7}, "so_23298586_23298844_1": {"section_id": 3269, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_23298586_23298844_0": {"section_id": 3141, "quality": 0.875, "length": 7}, "so_23298586_23298844_1": {"section_id": 3141, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_23298586_23298844_0": {"section_id": 4027, "quality": 0.875, "length": 7}, "so_23298586_23298844_1": {"section_id": 4027, "quality": 0.9333333333333333, "length": 14}}}, "23298844": {"ParentId": "23298586", "CommentCount": "1", "Body": "<p>C++11 8.4.1/8:</p>\n<blockquote>\n<p id=\"so_23298586_23298844_0\">The function-local predefined variable <code>__func__</code> is defined as if a definition of the form</p>\n<pre><code>static const char __func__[] = \"function-name\";\n</code></pre>\n<p id=\"so_23298586_23298844_1\">had been provided, where <em>function-name</em> is an implementation-defined string. It is unspecified whether such a variable has an address distinct from that of any other object in the program.</p>\n<p id=\"so_23298586_23298844_2\">[ Example:</p>\n<pre><code>  struct S {\n    S() : s(__func__) { } // OK\n    const char *s;\n  };\n\n  void f(const char * s = __func__); // error: __func__ is undeclared\n</code></pre>\n<p id=\"so_23298586_23298844_3\">\u2014end example ]</p>\n</blockquote>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "23298844", "Score": "4", "CreationDate": "2014-04-25T16:50:20.620", "LastActivityDate": "2014-04-25T16:50:20.620"}});