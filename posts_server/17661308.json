post_cb({"17661308": {"CommentCount": "0", "ViewCount": "399", "LastActivityDate": "2015-03-10T15:19:12.047", "Body": "<p>While I was searching for clues about a compilation problem I have had in my source, I have come across this <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=587103\">bug report (against Mozilla's JavaScript engine source)</a> related to functions lookup. Quoting from the bug report:</p>\n<blockquote>\n<p id=\"so_17661308_17661308_0\">TypedArrayTemplate is (obviously) a template, and it is referencing INT_TO_JSVAL, a static inline function, without prefixing it with \"::\". This breaks xlC because it can not resolve INT_TO_JSVAL. The standard does not require that statics be considered if the unqualified name is not found in the context of the template arguments. g++ does this fallback, xlC does not.</p>\n</blockquote>\n<p>Informative message from the compiler:</p>\n<pre><code>(I) Static declarations are not considered for a function call if the function is not qualified.\n</code></pre>\n<p>In my case the code that was failing was similar to this:</p>\n<pre><code>namespace N\n{\n\nstatic bool foo (std::string const &amp;);\n\ntemplate &lt;typename T&gt;\nvoid bar (T const &amp;, std::string const &amp; s)\n{\n    // expected unqualified call to N::foo()\n    foo (s);\n}\n\nvoid baz (std::string const &amp; s)\n{\n    bar (s);\n}\n\n} // namespace N\n</code></pre>\n<p>Is the behaviour that xlC implements really correct? Where does the 2003 or 2011 standard talk about this?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "17662745", "FavoriteCount": "2", "Title": "static function lookup from a template function issue with xlC", "Id": "17661308", "Score": "9", "CreationDate": "2013-07-15T18:31:16.807", "Tags": "<c++><templates><name-lookup><xlc>", "OwnerUserId": "341065", "AnswerCount": "2"}, "17677861": {"ParentId": "17661308", "LastEditDate": "2015-03-10T15:19:12.047", "CommentCount": "0", "CreationDate": "2013-07-16T13:28:06.137", "OwnerUserId": "2108084", "LastEditorUserId": "341065", "PostTypeId": "2", "Id": "17677861", "Score": "4", "Body": "<p>V12.1 of the compiler has the new behaviour by default.</p>\n<p>If you are using an earlier version of the xlC compiler use option <code>-qdebug=KeepUnqualifiedStaticCandidate</code></p>\n", "LastActivityDate": "2015-03-10T15:19:12.047"}, "17662745": {"ParentId": "17661308", "LastEditDate": "2013-07-15T21:11:23.727", "CommentCount": "3", "CreationDate": "2013-07-15T19:56:23.990", "OwnerUserId": "923854", "LastEditorUserId": "923854", "PostTypeId": "2", "Id": "17662745", "Score": "9", "Body": "<p>Prior to C++11 this was the correct behavior: unqualified name resolution of names used in templates was defined to only find functions with external linkage.</p>\n<p>C++03 section 14.6.4.2 Candidate Functions [temp.dep.candidate] paragraph 1:</p>\n<blockquote>\n<p id=\"so_17661308_17662745_0\">For a function call that depends on a template parameter, if the function name is an unqualified-id but not a\n  template-id, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li><p id=\"so_17661308_17662745_1\">For the part of the lookup using unqualified name lookup (3.4.1), only function declarations with external\n  linkage from the template definition context are found.</p></li>\n<li><p id=\"so_17661308_17662745_2\">For the part of the lookup using associated namespaces (3.4.2), only function declarations with external\n  linkage found in either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n</blockquote>\n<p>which changes in C++11 to:</p>\n<blockquote>\n<p id=\"so_17661308_17662745_3\">For a function call that depends on a template parameter, the candidate functions are found using the usual\n  lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><p id=\"so_17661308_17662745_4\">For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only\n  function declarations from the template definition context are found.</p></li>\n<li><p id=\"so_17661308_17662745_5\">For the part of the lookup using associated namespaces (3.4.2), only function declarations found in\n  either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2013-07-15T21:11:23.727"}, "bq_ids": {"n4140": {"so_17661308_17662745_5": {"section_id": 224, "quality": 0.8888888888888888, "length": 16}, "so_17661308_17662745_1": {"section_id": 224, "quality": 0.75, "length": 12}, "so_17661308_17662745_2": {"section_id": 224, "quality": 0.8, "length": 16}, "so_17661308_17662745_3": {"section_id": 224, "quality": 0.5882352941176471, "length": 10}, "so_17661308_17662745_4": {"section_id": 224, "quality": 0.6666666666666666, "length": 12}}, "n3337": {"so_17661308_17662745_5": {"section_id": 217, "quality": 0.8888888888888888, "length": 16}, "so_17661308_17662745_4": {"section_id": 217, "quality": 0.8333333333333334, "length": 15}, "so_17661308_17662745_0": {"section_id": 217, "quality": 0.6190476190476191, "length": 13}, "so_17661308_17662745_1": {"section_id": 217, "quality": 0.75, "length": 12}, "so_17661308_17662745_2": {"section_id": 217, "quality": 0.8, "length": 16}, "so_17661308_17662745_3": {"section_id": 217, "quality": 0.7647058823529411, "length": 13}}, "n4659": {"so_17661308_17662745_5": {"section_id": 232, "quality": 0.8888888888888888, "length": 16}, "so_17661308_17662745_1": {"section_id": 232, "quality": 0.75, "length": 12}, "so_17661308_17662745_2": {"section_id": 232, "quality": 0.8, "length": 16}, "so_17661308_17662745_3": {"section_id": 232, "quality": 0.5882352941176471, "length": 10}, "so_17661308_17662745_4": {"section_id": 232, "quality": 0.6666666666666666, "length": 12}}}});