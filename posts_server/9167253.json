post_cb({"9167286": {"ParentId": "9167253", "CommentCount": "0", "CreationDate": "2012-02-06T21:08:34.963", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "9167286", "Score": "4", "Body": "<p>Arrays are neither copyable nor assignable. However, structure with array members have generated copy construction and copy assignment. This is a special rule: i.e. they don't need to be copyable or assignable themselves.</p>\n", "LastActivityDate": "2012-02-06T21:08:34.963"}, "9167278": {"ParentId": "9167253", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-02-06T21:07:45.523", "Score": "20", "LastEditorUserId": "103167", "LastEditDate": "2012-02-06T21:13:14.227", "Id": "9167278", "OwnerUserId": "103167", "Body": "<p>The defaulted copy constructor and assignment operator use copy construction and assignment individually on each member.  When there's an array, copy construction or assignment is used on each element of the array (which is quite well-defined).</p>\n<p>Here's the rule, from section 12.8 (<code>[class.copy]</code>):</p>\n<blockquote>\n<p id=\"so_9167253_9167278_0\">The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a memberwise copy/move of its bases and members.  [ Note: <em>brace-or-equal-initializers</em> of non-static data members are ignored.  See also the example in 12.6.2.  \u2014 end note ] The order of initialization is the same as the order of initialization of bases and members in a user-defined constructor (see 12.6.2).   Let <code>x</code> be either the parameter of the\n  constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data member is copied/moved in the manner appropriate to its type:</p>\n<ul>\n<li><strong>if the member is an array, each element is direct-initialized with the corresponding subobject of <code>x</code></strong>;</li>\n<li>if a member m has rvalue reference type <code>T&amp;&amp;</code>, it is direct-initialized with <code>static_cast&lt;T&amp;&amp;&gt;(x.m)</code>;</li>\n<li>otherwise, the base or member is direct-initialized with the corresponding base or member of <code>x</code>.</li>\n</ul>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_9167253_9167278_1\">The implicitly-defined copy/move assignment operator for a non-union class <code>X</code> performs memberwise copy/move assignment of its subobjects.  The direct base classes of <code>X</code> are assigned first, in the order of their declaration in the <em>base-specifier-list</em>, and then the immediate non-static data members of <code>X</code> are assigned, in the order in which they were declared in the class de\ufb01nition. Let <code>x</code> be either the parameter of the function or, for the move operator, an xvalue referring to the parameter.  Each subobject is assigned in the manner appropriate to its type:</p>\n<ul>\n<li>if the subobject is of class type, as if by a call to operator= with the subobject as the object expression and the corresponding subobject of x as a single function argument (as if by explicit qualification; that is, ignoring any possible virtual overriding functions in more derived classes);</li>\n<li><strong>if the subobject is an array, each element is assigned, in the manner appropriate to the element type</strong>;</li>\n<li>if the subobject is of scalar type, the built-in assignment operator is used.</li>\n</ul>\n</blockquote>\n<p>The rule for signature selection between <code>C::C(const C&amp;)</code> vs <code>C::C(C&amp;)</code> et al also includes language referring to the array element type.</p>\n", "LastActivityDate": "2012-02-06T21:13:14.227"}, "bq_ids": {"n4140": {"so_9167253_9167278_1": {"section_id": 477, "quality": 0.9411764705882353, "length": 48}, "so_9167253_9167278_0": {"section_id": 464, "quality": 0.8727272727272727, "length": 48}}, "n3337": {"so_9167253_9167278_1": {"section_id": 468, "quality": 0.9411764705882353, "length": 48}, "so_9167253_9167278_0": {"section_id": 455, "quality": 0.8727272727272727, "length": 48}}, "n4659": {"so_9167253_9167278_1": {"section_id": 500, "quality": 0.9411764705882353, "length": 48}, "so_9167253_9167278_0": {"section_id": 487, "quality": 0.8545454545454545, "length": 47}}}, "9167253": {"CommentCount": "3", "AcceptedAnswerId": "9167278", "CreationDate": "2012-02-06T21:05:14.753", "LastActivityDate": "2012-02-06T21:13:14.227", "PostTypeId": "1", "ViewCount": "596", "FavoriteCount": "0", "Title": "I thought array was non copyable", "Id": "9167253", "Score": "13", "Body": "<p>I was under the impression that array were non copyable (or assignable).</p>\n<pre><code>int x[5] = {1,2,3,4,5};\nint y[5] = {6,7,8,9,0};\n\nx = y; // Fails to compile\n</code></pre>\n<p>But when I put an array inside a class the copy constructor and assignment operator work (I would say as expected but its not what I expected).</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X\n{\n    virtual ~X(){} // Just in case it was something to do with POD \n                   // make sure its not a POD\n    int x[5];\n};\n\nint main()\n{\n    X   a;\n\n    a.x[0]  = 0;\n    a.x[1]  = 1;\n    a.x[2]  = 2;\n    a.x[3]  = 3;\n    a.x[4]  = 4;\n\n    // Make a copy of a and test it\n    X   b(a);          \n    std::cout &lt;&lt; a.x[0] &lt;&lt; \" : \" &lt;&lt; b.x[0] &lt;&lt; \"\\n\";\n\n    b.x[0]  = 10;\n    b.x[1]  = 11;\n    b.x[2]  = 12;\n    b.x[3]  = 13;\n    b.x[4]  = 14;\n\n    // Now that we have modified 'b' make sure it is unique.\n    std::cout &lt;&lt; a.x[0] &lt;&lt; \" : \" &lt;&lt; b.x[0] &lt;&lt; \"\\n\";\n\n    // Use assignment and see if it worked.\n    b   = a;\n    std::cout &lt;&lt; a.x[0] &lt;&lt; \" : \" &lt;&lt; b.x[0] &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Compile and Run</p>\n<pre><code>&gt; g++ t.cpp\n&gt; ./a.out\n0 : 0\n0 : 10\n0 : 0\n</code></pre>\n<p>What is going on here?</p>\n", "Tags": "<c++><arrays><copy-constructor><assignment-operator>", "OwnerUserId": "14065", "AnswerCount": "2"}});