post_cb({"bq_ids": {"n4140": {"so_19159753_19160538_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1021}, "so_19159753_19160538_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1021}}, "n3337": {"so_19159753_19160538_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1006}, "so_19159753_19160538_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1006}}, "n4659": {"so_19159753_19160538_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 1094}, "so_19159753_19160538_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1094}}}, "19160538": {"Id": "19160538", "PostTypeId": "2", "Body": "<p>Sure it makes sense, if it makes sense in your program.</p>\n<p>The Standard doesn't mind if you have a <code>multimap</code> with duplicate values:</p>\n<h2>23.3.2 Class template multimap</h2>\n<blockquote>\n<p id=\"so_19159753_19160538_0\">1/A multimap is a kind of associative container that supports\n  equivalent keys (possibly containing multiple copies of the same key\n  value) and provides for fast retrieval of values of another type T\n  based on the keys.</p>\n<p id=\"so_19159753_19160538_1\">The multimap class supports bidirectional iterators.</p>\n</blockquote>\n<p>So the question isn't if this makes sense from a language perspective -- the question is does it make sense in terms of what you are trying to do?</p>\n<p>Off the top of my head I can see this making sense if you want a count of the number of items of a particular value associated with a single key.  Perhaps each value might compare equal and still have different attributes (ex: student roster where equality is determined based on name.  Foolish, perhaps, but possible.)</p>\n<p>It occurs to me that there is at least some similarity between a map with duplicate values and a hash map.  There are some obvious differences as well, least of which being domain applicability, but enough similarity to make me think if you are considering having a <code>multimap</code> with duplicate values, you might actually need a hash map (<code>unordered_map</code> in C++11).</p>\n", "LastActivityDate": "2013-10-03T13:29:50.227", "CommentCount": "0", "CreationDate": "2013-10-03T13:29:50.227", "ParentId": "19159753", "Score": "1", "OwnerUserId": "241536"}, "19160552": {"Id": "19160552", "PostTypeId": "2", "Body": "<p>This makes sense.  </p>\n<p>For example, I want to cross-reference all restaurants in a city within a certain proximity to restaurants I own.  The data type in this data structure will be the same, however, the grouping of the entities is significant in my business logic and criteria.</p>\n<p>When you are using a hash data type, you are essentially grouping objects by a common key.  It doesn't matter if the key is the same type or not.  To say, \"I want to group all points by this one reference point,\" is a legitimate use of that data type.</p>\n", "LastEditorUserId": "20133", "LastActivityDate": "2013-10-03T13:50:11.343", "Score": "1", "CreationDate": "2013-10-03T13:30:21.540", "ParentId": "19159753", "CommentCount": "1", "OwnerUserId": "20133", "LastEditDate": "2013-10-03T13:50:11.343"}, "19159753": {"ViewCount": "144", "Body": "<p>Does a <code>std::multimap</code> make any sense if the key and the value of it are of the same type?</p>\n<p>The real code is much more complicated, but for example, I have a class <code>Point</code> and I want to find similar objects of that type:</p>\n<pre><code>bool\nComparePoints::operator()(Point* const p1, Point* const p2) const {\n  if (p1-&gt;x &gt; p2-&gt;x) return false;\n  if (p1-&gt;x &lt; p2-&gt;x) return true;\n  ...\n  return false;\n}\n</code></pre>\n<p>I can use a <code>std::multimap</code> with comparison function for that purpose, and then using MultiMap::equal_range get a group of objects. </p>\n<pre><code>std::multimap&lt;Point*, Point*, ComparePoints&gt; pointsMap;\n</code></pre>\n<p>This work fine for me, but I kind of feel that the value field has become redundant. Do I need to seek for a better solution?</p>\n<p><strong>Edited:</strong></p>\n<p>I'm mapping from an object to the exact same object </p>\n<pre><code>pointsMap.insert(std::pair&lt;Point*, Point*&gt;(p, p));\n</code></pre>\n<p>making the value redundant, so I probably should use std::multiset instead as @john mentioned.</p>\n", "AcceptedAnswerId": "19160552", "Title": "Does a multimap with the key and the value being of the same type make any sense?", "CreationDate": "2013-10-03T12:53:38.503", "Id": "19159753", "CommentCount": "2", "LastEditDate": "2013-10-04T00:18:17.207", "PostTypeId": "1", "LastEditorUserId": "2343705", "LastActivityDate": "2013-10-04T00:18:17.207", "Score": "1", "OwnerUserId": "2343705", "Tags": "<c++><stl><multimap>", "AnswerCount": "2"}});