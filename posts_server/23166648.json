post_cb({"23191394": {"Id": "23191394", "PostTypeId": "2", "Body": "<p>Sample 1 is incorrect, because the multiplication of <code>m * n</code> may exceed the range of representable values for the signed integer type, which leads to Undefined Behaviour. See n1570 S6.5/5:</p>\n<blockquote>\n<p id=\"so_23166648_23191394_0\">If an exceptional condition occurs during the evaluation of an expression (that is, if the\n  result is not mathematically defined or not in the range of representable values for its\n  type), the behavior is undefined.</p>\n</blockquote>\n<p>This is of practical importance since one of the things the compiler is permitted to do is to assume that Undefined Behaviour has not happened, and it may use this to optimise the code so that the <code>if</code> statement disappears and is of no effect.</p>\n<p>Note that this applies only to the signed type. Unsigned arithmetic does not overflow. See n1570 S6.2.5/9.</p>\n<blockquote>\n<p id=\"so_23166648_23191394_1\">A computation involving unsigned operands can never overflow,\n  because a result that cannot be represented by the resulting unsigned integer type is\n  reduced modulo the number that is one greater than the largest value that can be\n  represented by the resulting type.</p>\n</blockquote>\n<p>Sample 2 is incorrect, because the multiplication of <code>m * n</code> is evaluated as a signed integer expression, which may again result in Undefined Behaviour. However in this case there is less likelihood of a practical effect. The result will most likely produce the correct bit-wise result and once cast to an unsigned the value is likely to be correct. The sample is wrong, but better, at least for 32 bit processors.</p>\n<p>Edit: The above para will be true if <code>unsigned int</code> and <code>size_t</code> are the same size, as they usually are for 32 bit processors. Sample 2 will not work correctly where <code>size_t</code> is larger than <code>unsigned int</code>, as it usually is on 64 bit processors. The signed multiply will overflow and produce wrong behaviour for some values. </p>\n<p>Sample 3 is almost certainly correct. With the multiplication of <code>m * n</code> evaluated as an unsigned integer expression, there is no possibility of Undefined Behaviour. [As noted in another answer, only one cast operation is actually required.]</p>\n<p>The exact behaviour here is subtly dependent on the definitions of <code>int</code>, <code>unsigned int</code>, <code>size_t</code> and <code>SIZE_MAX</code>. The usual assumption is that <code>size_t</code> is the same as <code>unsigned int</code> (or perhaps larger) and that <code>SIZE_MAX</code> is an unsigned integer literal, but these are not actually requirements. Indeed, <code>SIZE_MAX</code> is only required to be at least <code>65535</code>. At least <code>size_t</code> is required to be unsigned.</p>\n<p>Since I have not been able to find any plausible (or even implausible) definitions for them that would cause the sample to fail, on that basis I say that Sample 3 works correctly.</p>\n", "LastEditorUserId": "1105562", "LastActivityDate": "2014-04-30T06:53:19.990", "Score": "0", "CreationDate": "2014-04-21T05:30:57.383", "ParentId": "23166648", "CommentCount": "4", "OwnerUserId": "1105562", "LastEditDate": "2014-04-30T06:53:19.990"}, "23184251": {"Id": "23184251", "PostTypeId": "2", "Body": "<p>1 and 2 are wrong because <code>n * m</code> may overflow. The fact that you go on to assign it to a <code>size_t</code> doesn't \"reverse\" the overflow.</p>\n<p>I think 3 is correct. (The cast on <code>m</code> is superfluous BTW). If anyone disagrees please post sample values for <code>m</code> and <code>n</code> and <code>SIZE_MAX</code> that makes the test incorrect!</p>\n<p>Also I cannot see a problem with:</p>\n<pre><code>if ( m &gt; 0 &amp;&amp; n &gt; 0 &amp;&amp; (size_t)m * n / n == m )\n    size_t bytes = (size_t)m * n;\n</code></pre>\n", "LastActivityDate": "2014-04-20T15:34:34.447", "CommentCount": "5", "CreationDate": "2014-04-20T15:34:34.447", "ParentId": "23166648", "Score": "0", "OwnerUserId": "1505939"}, "bq_ids": {"n4140": {"so_23166648_23191394_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 7213}, "so_23166648_23191394_0": {"length": 13, "quality": 0.8125, "section_id": 5937}}, "n3337": {"so_23166648_23191394_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 6957}, "so_23166648_23191394_0": {"length": 13, "quality": 0.8125, "section_id": 5709}}, "n4659": {"so_23166648_23191394_1": {"length": 22, "quality": 0.8148148148148148, "section_id": 8722}, "so_23166648_23191394_0": {"length": 13, "quality": 0.8125, "section_id": 7421}}}, "23166648": {"ViewCount": "588", "Body": "<p>Which if any of the following does \"the right thing\" in a standards-compliant manner? You can assume that <code>m</code> and <code>n</code> are of type <code>int</code> (signed integer). The main issue is signed integer overflow.</p>\n<p>Sample 1.</p>\n<pre><code>size_t bytes = n * m;\nif (n &gt; 0 &amp;&amp; m &gt; 0 &amp;&amp; SIZE_MAX/n &gt;= m) {\n    /* allocate \u201cbytes\u201d space */\n}\n</code></pre>\n<p>Sample 2.</p>\n<pre><code>if (n &gt; 0 &amp;&amp; m &gt; 0 &amp;&amp; SIZE_MAX/n &gt;= m) {\n    size_t bytes = n * m;\n    /* allocate \u201cbytes\u201d space */\n}\n</code></pre>\n<p>Sample 3.</p>\n<pre><code>if (n &gt; 0 &amp;&amp; m &gt; 0 &amp;&amp; SIZE_MAX/n &gt;= m) {\n    size_t bytes = (size_t)n * (size_t)m;\n    /* allocate \u201cbytes\u201d space */\n}\n</code></pre>\n<p>I think they're all wrong, but not all for the same reason. So what would be correct?</p>\n<p>These snippets are taken from <a href=\"http://randomascii.wordpress.com/2014/04/17/buggy-security-guidance-from-apple/\" rel=\"nofollow\">here</a>.</p>\n<hr>\n<p>Edited to emphasise that the main issue is multiplying signed integers, which can lead to Undefined Behaviour (which unsigned does not).</p>\n<p>I now think that the last sample works correctly provided that integer, signed integer, size_t and SIZE_MAX have the \"usual\" values, or at least that they comply with relevant standards.</p>\n</hr>", "AcceptedAnswerId": "23191394", "Title": "Which way to test for signed integer overflow on multiply?", "CreationDate": "2014-04-19T06:17:57.947", "Id": "23166648", "CommentCount": "16", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-04-20T10:52:56.210", "LastEditorUserId": "1105562", "LastActivityDate": "2014-04-30T06:53:19.990", "Score": "5", "OwnerUserId": "1105562", "Tags": "<c++><c><language-lawyer>", "AnswerCount": "2"}});