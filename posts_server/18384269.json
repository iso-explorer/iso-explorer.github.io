post_cb({"18384600": {"ParentId": "18384269", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think, cppreference is incorrect here. Take loot at the Standard(N3337 25.4.2):</p>\n<blockquote>\n<pre><code>template&lt;class RandomAccessIterator&gt;\nvoid nth_element\n(\n    RandomAccessIterator first,\n    RandomAccessIterator nth,\n    RandomAccessIterator last\n);\n</code></pre>\n<hr>\n<p id=\"so_18384269_18384600_0\">... For any iterator <code>i</code> in the range <code>[first,nth)</code> and any iterator <code>j</code> in\n  the range <code>[nth,last)</code> it holds that: <strong><code>!(*j &lt; *i)</code></strong> or <strong><code>comp(*j,\n  *i) == false</code></strong>.</p>\n</hr></blockquote>\n<p>So, elements in range <code>[first,nth)</code> will be less or equal than elements in range <code>[nth,last)</code>.</p>\n", "OwnerUserId": "1532460", "LastEditorUserId": "1532460", "LastEditDate": "2013-08-22T16:23:09.817", "Id": "18384600", "Score": "13", "CreationDate": "2013-08-22T15:20:49.053", "LastActivityDate": "2013-08-22T16:23:09.817"}, "18384666": {"ParentId": "18384269", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><a href=\"http://www.cplusplus.com/reference/algorithm/nth_element/\" rel=\"nofollow\">Here</a> is a better definition of std::nth_element:</p>\n<blockquote>\n<p id=\"so_18384269_18384666_0\">Rearranges the elements in the range [first,last), in such a way that\n  the element at the nth position is the element that would be in that\n  position in a sorted sequence.</p>\n<p id=\"so_18384269_18384666_1\">The other elements are left without any specific order, except that\n  none of the elements preceding nth are greater than it, and none of\n  the elements following it are less.</p>\n</blockquote>\n", "OwnerUserId": "2606524", "LastEditorUserId": "2606524", "LastEditDate": "2013-08-22T15:37:36.050", "Id": "18384666", "Score": "5", "CreationDate": "2013-08-22T15:24:20.910", "LastActivityDate": "2013-08-22T15:37:36.050"}, "30367912": {"ParentId": "18384269", "CommentCount": "0", "Body": "<p>No, it does not sort equal or less! nth_element randomly picks one of the values, that could be at the nth position in the sorted array. Since this would be the nth position there is no way, it can put all equal on the left side, since then it would not be the nth element anymore. Test it! The values equal appear on both sides of the nth position. </p>\n", "OwnerUserId": "4120316", "PostTypeId": "2", "Id": "30367912", "Score": "0", "CreationDate": "2015-05-21T08:03:00.273", "LastActivityDate": "2015-05-21T08:03:00.273"}, "bq_ids": {"n4140": {"so_18384269_18384600_0": {"section_id": 1418, "quality": 0.7, "length": 7}}, "n3337": {"so_18384269_18384600_0": {"section_id": 1412, "quality": 0.7, "length": 7}}, "n4659": {"so_18384269_18384600_0": {"section_id": 1539, "quality": 0.7, "length": 7}}}, "18384269": {"CommentCount": "0", "AcceptedAnswerId": "18384600", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2013-08-22T15:06:57.207", "LastActivityDate": "2015-05-21T08:03:00.273", "LastEditDate": "2013-08-22T15:17:25.633", "ViewCount": "470", "FavoriteCount": "1", "Title": "Is std::nth_element defined for ranges containing same values?", "Id": "18384269", "Score": "12", "Body": "<p>From the documentation of <a href=\"http://en.cppreference.com/w/cpp/algorithm/nth_element\" rel=\"noreferrer\">std::nth_element</a> we have:</p>\n<pre><code>template&lt; class RandomIt &gt;\nvoid nth_element( RandomIt first, RandomIt nth, RandomIt last );\n</code></pre>\n<blockquote>\n<p id=\"so_18384269_18384269_0\">Partially sorts the range [first, last) in ascending order so that all\n  elements in the range [first, nth) are <strong>less</strong> than those in the range\n  [nth, last).</p>\n</blockquote>\n<p>The thing that bothers me is the <strong>less</strong> word. Shouldn't it be <strong>less or equal</strong>? If the range is for example:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; numbers = {3, 2, 2, 2, 1};\n    auto middlePosition = numbers.begin() + 2;\n    std::nth_element(numbers.begin(), middlePosition, numbers.end());\n\n    for (int x : numbers)\n        std::cout &lt;&lt; x &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>The algorithm <strong>cannot</strong> make <em>both</em> numbers before the <code>middlePosition</code> <strong>less</strong> than 2, because there is only <em>one</em> such number. The algorithm does its best and the output is as desired:</p>\n<pre><code>1\n2\n2\n3\n2\n</code></pre>\n<p>Can I rely on such nice behavior?</p>\n<p>My implementation (gcc 4.7) uses the <a href=\"http://en.wikipedia.org/wiki/Selection_algorithm#Introselect\" rel=\"noreferrer\">introselect</a> algorithm. Unfortunately I couldn't find the requirements on input of the algorithm. Does <strong>introselect</strong> need all values to be different?</p>\n", "Tags": "<c++><algorithm><c++11><c++-standard-library>", "OwnerUserId": "1097451", "AnswerCount": "3"}});