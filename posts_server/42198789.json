post_cb({"42198838": {"Id": "42198838", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42198789_42198838_0\">could I still convert to an integral type other than int say by</p>\n<pre><code>unsigned long long iflags = static_cast&lt;unsigned long long&gt;(flags);\n</code></pre>\n</blockquote>\n<p>No, you can't.</p>\n<p>The above is equivalent to:</p>\n<pre><code>unsigned long long temp(flags);\nunsigned long long iflags = temp;\n</code></pre>\n<p>The first line is wrong since <code>flags</code> cannot be implicitly converted to <code>unsigned long long</code>.</p>\n<p>Given the definition of <code>Flags</code>, the only legal C++ method to initialize <code>iflags</code> is to use:</p>\n<pre><code> unsigned long long iflags = static_cast&lt;unsigned int&gt;(flags);\n</code></pre>\n<hr>\n<p>If you remove the <code>explicit</code> qualifier from the conversion operator</p>\n<pre><code>class Flags {\n    unsigned int v;\n    public:\n       operator unsigned int() { return v; }\n}\n</code></pre>\n<p>then you can use</p>\n<pre><code>unsigned long long iflags = static_cast&lt;unsigned long long&gt;(flags);\n</code></pre>\n</hr>", "LastEditorUserId": "434551", "LastActivityDate": "2017-02-13T20:59:50.553", "Score": "1", "CreationDate": "2017-02-13T07:40:10.940", "ParentId": "42198789", "CommentCount": "3", "OwnerUserId": "434551", "LastEditDate": "2017-02-13T20:59:50.553"}, "42198789": {"ViewCount": "87", "Body": "<p>I have a flags class witch is just a wrapper around an integer and I want to implement explicit conversion to to arbitrary integers types based on the conversion rules for the underlying integer type.</p>\n<p>i.e.</p>\n<p>say I have the class along the lines of (ignoring non-relevant members)</p>\n<pre><code>class Flags {\n    unsigned int v;\n    explicit operator unsigned int() { return v; }\n}\n</code></pre>\n<p>could I still convert to an integral type other than int say by </p>\n<pre><code>unsigned long long iflags = static_cast&lt;unsigned long long&gt;(flags);\n</code></pre>\n<p>rather than </p>\n<pre><code>unsigned long long iflags = static_cast&lt;unsigned int&gt;(flags);\n</code></pre>\n<p>or would I need to explicitly define a conversion operator for every integral type to be able to do this?</p>\n<p>Note I'm using C++14</p>\n<p>I've read <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/cast_operator</a> but can't see any thing specific to integral types which makes me think I need to explicit define all valid conversion which I want to avoid. I would also be happy with a template conversion function which will fail if conversion to the target type isn't possible, noting I know the max value of the internal integer i.e. all flag bits turned on, as a macro/constant <code>FLAGS_MAX</code>, if this is of any use.</p>\n", "Title": "C++ explicit integral user-defined conversion", "CreationDate": "2017-02-13T07:37:30.623", "LastActivityDate": "2017-02-13T20:59:50.553", "CommentCount": "3", "PostTypeId": "1", "Id": "42198789", "Score": "0", "OwnerUserId": "530051", "Tags": "<c++><type-conversion><c++14><user-defined-types>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_42198789_42201902_0": {"length": 35, "quality": 0.7, "section_id": 595}}, "n3337": {"so_42198789_42201902_0": {"length": 35, "quality": 0.7, "section_id": 585}}, "n4659": {"so_42198789_42201902_0": {"length": 35, "quality": 0.7, "section_id": 618}}}, "42201902": {"Id": "42201902", "PostTypeId": "2", "Body": "<p>That <code>static_cast</code> attempt falls under <a href=\"https://timsong-cpp.github.io/cppwp/expr.static.cast#4\" rel=\"nofollow noreferrer\">[expr.static.cast]/4</a>, which roughly says that you can do <code>static_cast&lt;T&gt;(e)</code> if you can do <code>T t(e);</code> for some invented variable <code>t</code> (there's some fun dance in the wording to take care of guaranteed elision and C-style cast oddities, which we can ignore for our purposes).</p>\n<p>That initialization is controlled by <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.7\" rel=\"nofollow noreferrer\">[dcl.init]/17.7</a>, which says you do overload resolution on the conversion functions of <code>Flags</code>, with a pointer to <a href=\"https://timsong-cpp.github.io/cppwp/over.match.conv\" rel=\"nofollow noreferrer\">[over.match.conv]</a>, which has this to say about candidates:</p>\n<blockquote>\n<p id=\"so_42198789_42201902_0\">Those non-explicit conversion functions that are not hidden within\n  [<code>Flags</code>] and yield type [<code>unsigned long long</code>] or a type that can be\n  converted to type  [<code>unsigned long long</code>] via a standard conversion\n  sequence are candidate functions. For direct-initialization, those\n  explicit conversion functions that are not hidden within [<code>Flags</code>] and\n  yield type  [<code>unsigned long long</code>] or a type that can be converted to\n  type  [<code>unsigned long long</code>] with a qualification conversion are also\n  candidate functions.</p>\n</blockquote>\n<p>Your <code>explicit operator unsigned int()</code> neither yields <code>unsigned long long</code> nor a type that can be converted to it via a qualification conversion (which is irrelevant here - that conversion only applies to pointer-y things); it is therefore not a candidate. Since the candidate set is empty, overload resolution fails, so the initialization is ill-formed, and so is the <code>static_cast</code>.</p>\n", "LastActivityDate": "2017-02-13T10:32:29.510", "CommentCount": "0", "CreationDate": "2017-02-13T10:32:29.510", "ParentId": "42198789", "Score": "1", "OwnerUserId": "2756719"}});