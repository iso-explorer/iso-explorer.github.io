post_cb({"19265920": {"CommentCount": "7", "AcceptedAnswerId": "19266022", "PostTypeId": "1", "LastEditorUserId": "1619294", "CreationDate": "2013-10-09T07:41:25.833", "LastActivityDate": "2013-10-13T12:01:55.640", "LastEditDate": "2013-10-09T08:11:15.790", "ViewCount": "4966", "FavoriteCount": "10", "Title": "What's the exact semantics of a deleted function in C++11?", "Id": "19265920", "Score": "43", "Body": "<pre><code>struct A\n{\n    A();\n\n    A(const A&amp;);\n    A&amp; operator =(const A&amp;);\n\n    A(A&amp;&amp;) = delete;\n    A&amp; operator =(A&amp;&amp;) = delete;\n};\n\nstruct B\n{\n    B();\n\n    B(const B&amp;);\n    B&amp; operator =(const B&amp;);    \n};\n\nint main()\n{\n    A a;\n    a = A(); // error C2280\n\n    B b;\n    b = B(); // OK\n}\n</code></pre>\n<p>My compiler is VC++ 2013 RC.</p>\n<blockquote>\n<p id=\"so_19265920_19265920_0\">error C2280: 'A &amp;A::operator =(A &amp;&amp;)' : attempting to reference a\n  deleted function</p>\n</blockquote>\n<p>I just wonder why the compiler doesn't try <code>A&amp; operator =(const A&amp;);</code> when <code>A&amp; operator =(A&amp;&amp;)</code> is deleted?</p>\n<p>Is this behavior defined by the C++ standard?</p>\n", "Tags": "<c++><c++11><overloading><semantics><language-lawyer>", "OwnerUserId": "508343", "AnswerCount": "2"}, "19266242": {"ParentId": "19265920", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>When you <code>=delete</code> a function, you actually are deleting its <em>definition</em>.</p>\n<blockquote>\n<h3>8.4.3 Deleted definitions [dcl.fct.def.delete]</h3>\n<p id=\"so_19265920_19266242_0\"><sup>1</sup> A function definition of the form:</p>\n<p id=\"so_19265920_19266242_1\"><em>attribute-specifier-seqopt decl-specifier-seqopt declarator = delete ;</em></p>\n<p id=\"so_19265920_19266242_2\">is called a <em>deleted definition</em>. A function with a deleted definition is also called a <em>deleted function</em>.</p>\n</blockquote>\n<p>But by doing so, you are also <em>declaring</em> that function. Quoting from the standard <sup>[1]</sup>:</p>\n<blockquote>\n<p id=\"so_19265920_19266242_3\"><sup>4</sup> A deleted function is implicitly inline. [ Note: The one-definition rule (3.2) applies to deleted definitions.\n  \u2014end note ] <strong>A deleted definition of a function shall be the first declaration of the function</strong> [...]</p>\n</blockquote>\n<p>And so by doing <code>a = A()</code>, the compiler actually resolves to <code>A::operator=(A&amp;&amp;)</code> because it has been declared (not <code>A::operator(const A&amp;)</code>, because <code>A&amp;&amp;</code> is \"more binding\" to r-values). However with its definition being deleted, the line is ill-formed.</p>\n<blockquote>\n<p id=\"so_19265920_19266242_4\"><sup>2</sup> A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.</p>\n</blockquote>\n<hr>\n<p><sup>[1]</sup> The tone of the emphasized sentence here is actually imperative. The standard directs that declaring a function <code>=delete</code>d must first appear before other declarations of it. But still, it supports the fact that deleting a function also declares the function.</p>\n</hr>", "OwnerUserId": "1619294", "LastEditorUserId": "1619294", "LastEditDate": "2013-10-09T08:07:44.137", "Id": "19266242", "Score": "22", "CreationDate": "2013-10-09T08:00:11.543", "LastActivityDate": "2013-10-09T08:07:44.137"}, "19266022": {"ParentId": "19265920", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>a = A(); // error C2280\n</code></pre>\n<p>The expression on the right is a temporary which means it will look for <code>operator=(A&amp;&amp;)</code> and sees it is deleted. Hence the error. There is no further search. </p>\n<p><code>=delete</code> does <strong>not</strong> mean \"don't use me, instead use <em>next</em> best one\". It rather means, \"don't use me <em>when you need me</em> \u2014 instead be alone in the wild.\"</p>\n<p>Here is another example. If I want the instances of my class <code>X</code> to be created with only <code>long</code> and <em>no other type</em> (even if it converts into long!), then I would declare <code>class X</code> as:</p>\n<pre><code>struct X\n{\n     X(long arg); //ONLY long - NO int, short, char, double, etc!\n\n     template&lt;typename T&gt;\n     X(T) = delete;\n};\n\nX a(1);  //error - 1 is int \nX b(1L); //ok    - 1L is long\n</code></pre>\n<p>That means, the overload resolution is <em>performed before</em> the compiler sees the <code>=delete</code> part \u2014 and thus results in an error because the <em>selected</em> overload is found deleted.</p>\n<p>Hope that helps.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-10-09T08:05:04.180", "Id": "19266022", "Score": "67", "CreationDate": "2013-10-09T07:48:20.063", "LastActivityDate": "2013-10-09T08:05:04.180"}, "bq_ids": {"n4140": {"so_19265920_19266242_3": {"section_id": 3279, "quality": 0.7894736842105263, "length": 15}, "so_19265920_19266242_2": {"section_id": 3276, "quality": 0.8, "length": 8}, "so_19265920_19266242_4": {"section_id": 3277, "quality": 1.0, "length": 9}}, "n3337": {"so_19265920_19266242_3": {"section_id": 3150, "quality": 0.7894736842105263, "length": 15}, "so_19265920_19266242_2": {"section_id": 3147, "quality": 0.8, "length": 8}, "so_19265920_19266242_4": {"section_id": 3148, "quality": 1.0, "length": 9}}, "n4659": {"so_19265920_19266242_3": {"section_id": 4037, "quality": 0.7894736842105263, "length": 15}, "so_19265920_19266242_2": {"section_id": 4034, "quality": 0.8, "length": 8}, "so_19265920_19266242_4": {"section_id": 4035, "quality": 1.0, "length": 9}}}});