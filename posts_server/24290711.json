post_cb({"24290755": {"ParentId": "24290711", "CommentCount": "3", "Body": "<p><code>f.begin()+1</code> is out of bounds and that is the reason for the segmentation fault.</p>\n<p>Use <code>f.begin()</code> for the beginning of the array.And that will be safe to use.</p>\n", "OwnerUserId": "1373124", "PostTypeId": "2", "Id": "24290755", "Score": "1", "CreationDate": "2014-06-18T16:31:11.670", "LastActivityDate": "2014-06-18T16:31:11.670"}, "24290871": {"ParentId": "24290711", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>std::sort</code> expects the <code>[begin, end)</code> to be a valid range such that if you keep incrementing <code>begin</code> you would eventually reach the <code>end</code>. In your case, <code>begin()+1</code> is past the <code>end()</code>, so <code>std::sort</code> has no way of knowing that it is looking past the end of the range.</p>\n<p><code>std::sort</code> takes iterators, not pointers. It is because of this that it is unable to run a <code>begin &lt; end</code> check: this would fail if you passed <code>rbegin()</code> and <code>rend()</code> for the two iterators.</p>\n<p>If you would like to sort a portion of the <code>std::vector</code> that excludes the initial element, you need to make sure that the container is not empty. Otherwise, <code>begin()+1</code> would produce an invalid iterator.</p>\n<p>Note: although technically the undefined behavior takes place when you do <code>begin()+1</code> on an empty container, the crash in your case is nearly certainly coming from a dereference inside <code>std::sort</code>. Also note that if you have a C++11-compliant compiler, using <code>std::next(v.begin(), 1)</code> is preferable to <code>v.begin() + 1</code>.</p>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2014-06-18T16:59:42.480", "Id": "24290871", "Score": "3", "CreationDate": "2014-06-18T16:38:58.280", "LastActivityDate": "2014-06-18T16:59:42.480"}, "24290711": {"CommentCount": "4", "AcceptedAnswerId": "24290755", "ClosedDate": "2014-06-19T00:13:18.803", "CreationDate": "2014-06-18T16:28:21.423", "LastActivityDate": "2014-08-03T09:13:32.743", "PostTypeId": "1", "ViewCount": "1486", "Title": "std::sort on empty vector", "Id": "24290711", "Score": "-6", "Body": "<p>Is <code>std::sort</code> supposed to work correctly if it gets an empty range?</p>\n<p>I get a segmentation fault (gcc 4.8.3) for this code:</p>\n<pre><code>std::vector&lt;float&gt; f;\nstd::sort( f.begin() + 1, f.end() );\n</code></pre>\n<p>Standard says that for an empty vector <code>begin()</code> and <code>end()</code> return same value. So I expected <code>sort</code> to do nothing in the case above because it should get an empty range: <code>begin()+1</code> should be greater than <code>end()</code>.</p>\n<p>There is no problem for this empty range sort:</p>\n<pre><code>std::sort( f.begin(), f.end() );\n</code></pre>\n", "Tags": "<c++><sorting><c++11><vector>", "OwnerUserId": "2052436", "AnswerCount": "3"}, "24290895": {"ParentId": "24290711", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Increment on input iterators has a <em>precondition</em> that the iterator must be <em>dereferenceable</em>. With an empty vector, <code>v.begin()</code> is not dereferenceable so attempting to do <code>v.begin() + 1</code> (which in turn is defined in terms of increment) is undefined behavior.</p>\n<p>Moreover, <code>std::sort(begin, end)</code> requires <code>[begin, end)</code> to be a valid range, and the standard says  that (\u00a724.2.1 [iterator.requirements.general]/p7)</p>\n<blockquote>\n<p id=\"so_24290711_24290895_0\">Range <code>[i,j)</code> is valid if and only if <code>j</code> is reachable from <code>i</code>. The result of the application of functions in the library to invalid ranges is undefined.</p>\n</blockquote>\n<p>For most random access iterators (the only type of iterators for which <code>&lt;</code> and <code>&gt;</code> are defined), if <code>a &gt; b</code> then <code>a</code> is not reachable from <code>b</code>, and so <code>[a, b)</code> does <em>not</em> denote the empty range - it doesn't denote a valid range at all.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-08-03T09:13:32.743", "Id": "24290895", "Score": "2", "CreationDate": "2014-06-18T16:40:11.737", "LastActivityDate": "2014-08-03T09:13:32.743"}, "bq_ids": {"n4140": {"so_24290711_24290895_0": {"section_id": 5561, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_24290711_24290895_0": {"section_id": 5343, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_24290711_24290895_0": {"section_id": 7008, "quality": 0.9090909090909091, "length": 10}}}});