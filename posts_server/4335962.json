post_cb({"40226628": {"Id": "40226628", "PostTypeId": "2", "Body": "<p>The original poster clarified that they are actually asking for a way to identify an InputIterator (see <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/concept/InputIterator</a>) because they want to be able to increment and dereference the iterator. This has a very simple SFINAE solution in standard C++11, e.g. similar to that from the gcc STL:</p>\n<pre><code>template&lt;typename InputIterator&gt;\nusing RequireInputIterator = typename\n    std::enable_if&lt;std::is_convertible&lt;typename\n                                       std::iterator_traits&lt;InputIterator&gt;::iterator_category,\n                                       std::input_iterator_tag&gt;::value&gt;::type;\n\n...\n\n// Example: declare a vector constructor from a pair of input iterators.\ntemplate &lt;typename InputIterator, typename = RequireInputIterator&lt;InputIterator&gt; &gt;\n    MyVector(InputIterator first, InputIterator last) { /* ... */ };\n</code></pre>\n<p>This relies on the iterator type traits classes, which define the typedefs that Armen Tsirunyan thought were required of the iterators themselves. (The iterators <em>can</em> provide those typedefs, but they can also provide them in traits classes, which is necessary in order to use naked pointers as iterators, and the standard library implementations are required to do so.)</p>\n", "LastActivityDate": "2016-10-24T20:05:20.373", "CommentCount": "0", "CreationDate": "2016-10-24T20:05:20.373", "ParentId": "4335962", "Score": "0", "OwnerUserId": "334142"}, "4335997": {"Id": "4335997", "PostTypeId": "2", "Body": "<p>Well, you could check for the type to have a nested typedef called <code>iterator_category</code> This can be done using <code>SFINAE</code>, and the exact technique can be found in <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"nofollow\">wiki page for <code>SFINAE</code></a>. This isn't a 100% method, but all decent iterators should provide the common typedefs for iterators, and the iterator_category is one that is unique to iterators. Also don't forget to check if TYPE is simply a pointer. Pointers are iterators.</p>\n", "LastActivityDate": "2010-12-02T14:24:01.377", "CommentCount": "9", "CreationDate": "2010-12-02T14:24:01.377", "ParentId": "4335962", "Score": "2", "OwnerUserId": "469935"}, "4335962": {"ViewCount": "2271", "Body": "<pre><code>template&lt;class T&gt;\nstruct is_iterator\n{\n    static const bool value = ??? // What to write ???\n};\n\nint main()\n{\n    assert(false == is_iterator&lt;int&gt;::value);\n    assert(true == is_iterator&lt;vector&lt;int&gt;::iterator&gt;::value);\n    assert(true == is_iterator&lt;list&lt;int&gt;::iterator&gt;::value);\n    assert(true == is_iterator&lt;string::iterator&gt;::value);\n    assert(true == is_iterator&lt;char*&gt;::value); // a raw pointer is also an iterator\n}\n</code></pre>\n<p>The question is: <strong>How to make the five assert statements pass?</strong></p>\n", "AcceptedAnswerId": "4336298", "Title": "How to check if a template parameter is an iterator type or not?", "CreationDate": "2010-12-02T14:20:30.457", "Id": "4335962", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-07-14T14:30:16.773", "LastEditorUserId": "2069064", "LastActivityDate": "2016-10-24T20:05:20.373", "Score": "8", "OwnerUserId": "508343", "Tags": "<c++><templates><sfinae>", "AnswerCount": "5"}, "31409532": {"Id": "31409532", "PostTypeId": "2", "Body": "<p>Coming in here a few years later, where C++11 and C++14 make it a lot easier to do such things. An <a href=\"http://en.cppreference.com/w/cpp/concept/Iterator\" rel=\"nofollow noreferrer\">iterator</a> is, at its core, something that is dereferencable, incrementable. If it's an <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\" rel=\"nofollow noreferrer\">input iterator</a>, then also comparable. Let's go with the latter - since that looks like what you want.</p>\n<p>The simplest version would be to use <a href=\"https://isocpp.org/files/papers/N3911.pdf\" rel=\"nofollow noreferrer\"><code>void_t</code></a>:</p>\n<pre><code>template &lt;typename... &gt;\nusing void_t = void;\n</code></pre>\n<p>Base case:</p>\n<pre><code>template &lt;typename T, typename = void&gt;\nstruct is_input_iterator : std::false_type { };\n</code></pre>\n<p>Valid case specialization:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_input_iterator&lt;T,\n    void_t&lt;decltype(++std::declval&lt;T&amp;&gt;()),                       // incrementable,\n           decltype(*std::declval&lt;T&amp;&gt;()),                        // dereferencable,\n           decltype(std::declval&lt;T&amp;&gt;() == std::declval&lt;T&amp;&gt;())&gt;&gt;  // comparable\n    : std::true_type { };\n</code></pre>\n<p>Alias:</p>\n<pre><code>template &lt;typename T&gt;\nusing is_input_iterator_t = typename is_input_iterator&lt;T&gt;::type;\n</code></pre>\n<p>No need to rely on <code>iterator_category</code> or using the tedious C++03 style of check things using overload resolution. Expression SFINAE is where it's at. </p>\n<hr/>\n<p>As Mr. Wakely points out in the comments, [iterator.traits] requires that:</p>\n<blockquote>\n<p id=\"so_4335962_31409532_0\">it is required that if <code>Iterator</code> is the type of\n  an iterator, the types</p>\n<pre><code>iterator_traits&lt;Iterator&gt;::difference_type\niterator_traits&lt;Iterator&gt;::value_type\niterator_traits&lt;Iterator&gt;::iterator_category\n</code></pre>\n<p id=\"so_4335962_31409532_1\">be defined as the iterator\u2019s difference type, value type and iterator category, respectively.</p>\n</blockquote>\n<p>So we can define our iterator trait to simply check for that:</p>\n<pre><code>template &lt;class T, class = void&gt;\nstruct is_iterator : std::false_type { };\n\ntemplate &lt;class T&gt;\nstruct is_iterator&lt;T, void_t&lt;\n    typename std::iterator_traits&lt;T&gt;::iterator_category\n&gt;&gt; : std::true_type { };\n</code></pre>\n<p>If <code>iterator_traits&lt;T&gt;::iterator_category</code> is ill-formed, then <code>T</code> is not an iterator. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-10-17T19:49:55.360", "Score": "7", "CreationDate": "2015-07-14T14:28:14.403", "ParentId": "4335962", "CommentCount": "3", "OwnerUserId": "2069064", "LastEditDate": "2016-10-17T19:49:55.360"}, "bq_ids": {"n4140": {"so_4335962_31409532_1": {"length": 9, "quality": 1.0, "section_id": 5583}, "so_4335962_31409532_0": {"length": 5, "quality": 1.0, "section_id": 5583}}, "n3337": {"so_4335962_31409532_1": {"length": 9, "quality": 1.0, "section_id": 5365}, "so_4335962_31409532_0": {"length": 5, "quality": 1.0, "section_id": 5365}}, "n4659": {"so_4335962_31409532_1": {"length": 9, "quality": 1.0, "section_id": 7030}, "so_4335962_31409532_0": {"length": 5, "quality": 1.0, "section_id": 7030}}}, "11535776": {"Id": "11535776", "PostTypeId": "2", "Body": "<pre><code>template &lt; class T, class Enabler = void &gt;\nstruct is_iterator : public boost::false_type { };\n\ntemplate &lt; class T &gt;\nstruct is_iterator&lt; T, typename boost::enable_if_c&lt;\n        sizeof(*(*(T*)0)) + sizeof((*(T*)0)++) + sizeof(++(*(T*)0)) +\n        sizeof((*(T*)0) == (*(T*)0)) + sizeof((*(T*)0) != (*(T*)0)) +\n        sizeof((*(T*)0) = (*(T*)0)) &gt;::type &gt; : public boost::true_type { };\n</code></pre>\n", "LastActivityDate": "2012-07-18T06:51:53.177", "CommentCount": "1", "CreationDate": "2012-07-18T06:51:53.177", "ParentId": "4335962", "Score": "1", "OwnerUserId": "1533860"}, "4336298": {"Id": "4336298", "PostTypeId": "2", "Body": "<pre><code>template&lt;class T&gt;\nstruct is_iterator\n{   \n    static T makeT();\n    typedef void * twoptrs[2];  // sizeof(twoptrs) &gt; sizeof(void *)\n    static twoptrs &amp; test(...); // Common case\n    template&lt;class R&gt; static typename R::iterator_category * test(R); // Iterator\n    template&lt;class R&gt; static void * test(R *); // Pointer\n\n    static const bool value = sizeof(test(makeT())) == sizeof(void *); \n};\n</code></pre>\n", "LastEditorUserId": "469935", "LastActivityDate": "2010-12-03T08:40:26.583", "Score": "6", "CreationDate": "2010-12-02T14:55:43.387", "ParentId": "4335962", "CommentCount": "8", "OwnerUserId": "124161", "LastEditDate": "2010-12-03T08:40:26.583"}});