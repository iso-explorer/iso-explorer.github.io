post_cb({"3898757": {"CommentCount": "3", "ViewCount": "1459", "PostTypeId": "1", "LastEditorUserId": "456795", "CreationDate": "2010-10-10T02:27:06.847", "LastActivityDate": "2010-10-10T06:47:53.373", "Title": "C++ overloading", "AcceptedAnswerId": "3898926", "LastEditDate": "2010-10-10T03:01:02.853", "Id": "3898757", "Score": "1", "Body": "<p>The following code is giving me a compilation error. Can anyone please tell me why?</p>\n<pre><code>class mytype {\npublic:\n    int value;\n    mytype(int a) {\n        value = a;\n    }\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; stream, const mytype&amp; a) {\n        stream &lt;&lt; a.value;//works\n        return stream;\n    }\n    friend ostringstream&amp; operator&lt;&lt;(ostringstream&amp; stream, const mytype&amp; a) {\n        stream &lt;&lt; (a.value);//compilation error\n        return stream;\n    }\n};\n</code></pre>\n<p>Error:</p>\n<blockquote>\n<p id=\"so_3898757_3898757_0\">error C2027: use of undefined type\n  'std::basic_ostringstream&lt;_Elem,_Traits,_Alloc&gt;'</p>\n</blockquote>\n<p>Upon fixing that:</p>\n<blockquote>\n<p id=\"so_3898757_3898757_1\">error C2666: 'operator &lt;&lt;' : 18 overloads have similar conversions</p>\n</blockquote>\n<p>Final fix:</p>\n<blockquote>\n<p id=\"so_3898757_3898757_2\">Declare constructor as explicit. Works on MSVC then.</p>\n</blockquote>\n<p>I wonder why.</p>\n", "Tags": "<c++><visual-studio-2010><visual-c++><stream>", "OwnerUserId": "456795", "AnswerCount": "2"}, "3898787": {"ParentId": "3898757", "PostTypeId": "2", "CommentCount": "24", "CreationDate": "2010-10-10T02:40:42.947", "Score": "7", "LastEditorUserId": "153285", "LastEditDate": "2010-10-10T06:47:53.373", "Id": "3898787", "OwnerUserId": "153285", "Body": "<blockquote>\n<p id=\"so_3898757_3898787_0\">error C2027: use of undefined type 'std::basic_ostringstream&lt;_Elem,_Traits,_Alloc&gt;'</p>\n</blockquote>\n<p>You need <code>#include &lt;sstream&gt;</code> to get the <code>[i/o]stringstream</code> classes.</p>\n<h2>About the other errors</h2>\n<p>The problem with an overload of the form</p>\n<pre><code>ostringstream&amp; operator&lt;&lt;(ostringstream&amp; stream, const mytype&amp; a)\n</code></pre>\n<p>is that it matches an <code>ostringstream</code> <em>exactly</em>. Why is it a bad thing to have a more exact overload? From the standard, \u00a713.3.3/1-2:</p>\n<blockquote>\n<p id=\"so_3898757_3898787_1\">a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2) \u2026 </p>\n<p id=\"so_3898757_3898787_2\">If there is exactly one viable function that is a better function than all other viable functions, then it is the\n  one selected by overload resolution; otherwise the call is ill-formed</p>\n</blockquote>\n<p>Therefore if <code>operator&lt;&lt;( ostream &amp;, int )</code> and <code>operator&lt;&lt;( ostringstream &amp;, mytype const &amp; )</code> are both candidates for <code>stream &lt;&lt; value</code>, the former matches <code>int</code> exactly with no conversion but the latter matches <code>ostringstream</code> exactly. Therefore neither can be \"not worse\" for <em>all</em> arguments, and neither candidate may be chosen.</p>\n<p>But the code <em>is</em> valid because of a loophole. Your overload is not a candidate at all, except when you actually use your type in the function call. When you declare/define a <code>friend</code> inside a class block, it does not introduce it to any namespace scope; it merely <em>associates</em> it with the class scope, which allows it to be found if that class type describes one of the arguments being passed.</p>\n<p>The standard has this to say about friend declarations, although it's in another section (14.6.5):</p>\n<blockquote>\n<p id=\"so_3898757_3898787_3\">Friend declarations do not introduce new names into any scope\u2026</p>\n</blockquote>\n<p>So, MSVC tried to be nice and proactively introduced your friend to its enclosing namespace. Strike against MSVC.</p>\n<p>However, when I attempted to add a declaration equivalent to what MSVC did \"for free,\" Comeau and GCC nicely resolved the resulting overloading conflict \u2014 strike against them. Or is it? As it turns out, the overloaded call occurs earlier in the file than my recommended declaration. If I move the declaration <em>before</em> <code>class mytype {</code> (which requires forward-declaring <code>mytype</code>), then both properly complain about the ambiguity.</p>\n<p>Using an overload before it is declared in namespace scope appears to be well and good according to \u00a73.3-3.4 of the Standard. So actually GCC and Comeau were both in the right. The point of declaration is right after the name of the declared object. (And last I checked, self-referential function declarations can <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=44175\" rel=\"nofollow\">still crash GCC</a>.) ADL invokes unqualified lookup into the enclosing namespace at a point immediately before the enclosing class. (3.4.1/8 final bullet, 3.4.1/9, 3.4.2/2a.) If the friend hasn't been declared before the class, it's legitimately not a candidate. (7.3.1.2/3) Isn't C++ a beautiful language?</p>\n<h2>How keep the simplified example on GCC, but break subsequent code.</h2>\n<pre><code>    friend ostringstream&amp; operator&lt;&lt;(ostringstream&amp; stream, const mytype&amp; a) {\n        stream &lt;&lt; (a.value);//compilation error\n        return stream;\n    }\n};\n\nostringstream&amp; operator&lt;&lt;(ostringstream&amp; stream, const mytype&amp; a); // &lt;- here\n</code></pre>\n<p>Following this declaration, it will be impossible to write an <code>int</code> into an <code>ostringstream</code>.</p>\n<h2>How to break everything uniformly, with simpler declaration semantics.</h2>\n<pre><code>class mytype; // &lt;- here\n              // and here:\ninline ostringstream&amp; operator&lt;&lt;(ostringstream&amp; stream, const mytype&amp; a);\n\nclass mytype {\npublic:\n</code></pre>\n<p>Following this declaration, it will be impossible to write an <code>int</code> into an <code>ostringstream</code>\u2026 including the friend declarations inside <code>class mytype {}</code>.</p>\n<h2>Actual solution.</h2>\n<p>The stream classes are supposed to be indistinguishable. If you really want to determine whether a given stream feeds a string in memory (and you shouldn't), it's best to look at its internal <code>streambuf</code> object, returned by <code>rdbuf()</code>, which actually performs the I/O gruntwork. Even a generic <code>ostream</code> object can have <code>ostringstream</code> functionality if given a <code>stringbuf</code>.</p>\n<pre><code> if ( typeid( stream.rdbuf() ) == typeid( stringbuf * ) ) {\n     // this is effectively a stringstream\n } else {\n     // not a stringstream\n }\n</code></pre>\n", "LastActivityDate": "2010-10-10T06:47:53.373"}, "3898926": {"ParentId": "3898757", "CommentCount": "3", "CreationDate": "2010-10-10T03:41:54.383", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "3898926", "Score": "2", "Body": "<p>There is an overload ambiguity in the call to <code>operator&lt;&lt;</code> in the <code>ostringstream</code> overload.</p>\n<pre><code>stream &lt;&lt; a.value;\n</code></pre>\n<p>There are a number of <code>operator&lt;&lt;</code> overloads that are members of the <code>ostream</code> class, which is a base class of <code>ostringstream</code>.  One of these is declared as:</p>\n<pre><code>ostream&amp; ostream::operator&lt;&lt;(int);\n</code></pre>\n<p>This overload is an exact match for the right-hand side (<code>a.value</code> is an <code>int</code>) but requires a derived-to-base conversion on the left-hand side (<code>stream</code> is an <code>ostringstream</code>, which is derived from <code>ostream</code>).</p>\n<p>However, there is also your <code>ostringstream</code> overload:</p>\n<pre><code>ostringstream&amp; operator&lt;&lt;(ostringstream&amp;, const mytype&amp;);\n</code></pre>\n<p>This overload is an exact match for the left-hand side (<code>stream</code> is an <code>ostringstream</code>), and a user-defined converting constructor (your <code>mytype(int)</code> constructor) can be used to convert <code>a.value</code> (an <code>int</code>) to a <code>mytype</code>.</p>\n<p>Since one overload matches the first argument better and the other overload matches the second argument better, there is an ambiguity.  You can fix this either by:</p>\n<ul>\n<li>Explicitly converting the left-hand side to an <code>ostream</code> (using <code>(ostream&amp;)stream = a.value;</code>), or</li>\n<li>Remove the user-defined conversion by making the constructor <code>explicit</code>.</li>\n</ul>\n", "LastActivityDate": "2010-10-10T03:41:54.383"}, "bq_ids": {"n4140": {"so_3898757_3898787_1": {"section_id": 603, "quality": 0.8235294117647058, "length": 14}, "so_3898757_3898787_3": {"section_id": 7059, "quality": 1.0, "length": 7}, "so_3898757_3898787_2": {"section_id": 604, "quality": 1.0, "length": 20}}, "n3337": {"so_3898757_3898787_1": {"section_id": 593, "quality": 0.8235294117647058, "length": 14}, "so_3898757_3898787_3": {"section_id": 6803, "quality": 1.0, "length": 7}, "so_3898757_3898787_2": {"section_id": 594, "quality": 1.0, "length": 20}}, "n4659": {"so_3898757_3898787_1": {"section_id": 629, "quality": 0.8235294117647058, "length": 14}, "so_3898757_3898787_3": {"section_id": 8556, "quality": 1.0, "length": 7}, "so_3898757_3898787_2": {"section_id": 630, "quality": 1.0, "length": 20}}}});