post_cb({"bq_ids": {"n4140": {"so_21534435_21534435_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 231}}, "n3337": {"so_21534435_21534435_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 224}}, "n4659": {"so_21534435_21534435_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 239}}}, "21555649": {"Id": "21555649", "PostTypeId": "2", "Body": "<p>After another look at the standard, it seems to me that the only reasonable option is to use single explicit template class instantiation combined with explicit member function instantiations of a small number of \"difficult\" functions.</p>\n<p>This (according to 14.7.2p9) will instantiate the class and all members which have been defined up to this point (which should include everything <strong>except</strong> \"difficult\" members). Then those selected members can be explicitly instantiated in other translation units containing their definitions.</p>\n<p>That would make my example look like below (assuming that <em>TA1.cpp</em> contains easy functions and the only \"difficult\" function in <strong>TA</strong> is <strong>func2</strong>)</p>\n<p><em>file TA1.cpp:</em></p>\n<pre><code>template &lt;typename T&gt;\nvoid TA&lt;T&gt;::func1() { /* \"simple\" function definition */ }\n\ntemplate class TA&lt;sometype&gt;; /* expl. inst. of class */\n</code></pre>\n<p><em>file TA2.cpp:</em></p>\n<pre><code>template &lt;typename T&gt;\nvoid TA&lt;T&gt;::func2() { /* \"difficult\" function definition */ }\n\ntemplate void TA&lt;sometype&gt;::func2(); /* expl. inst. of member */\n</code></pre>\n<p>This method requires us to write explicit instantiation definition for every \"difficult\" function, which is tedious but also makes us think twice whether we really want to keep it separately or not.</p>\n<p><strong>Disclaimer</strong></p>\n<p>When that can be useful? Not often. As other people here mentioned, it is not advised to split definitions of classes over several files. In my particular case \"difficult\" functions contain complicated mathematical operations on instances of non-trivial classes. C++ templates are not famous for fast compilation speeds, but in this case it was unbearable. These functions call each other which sends compiler on long and memory-consuming journey of expanding/inlining overloaded operators/templates/etc to optimize everything it sees, with pretty much zero improvement, but making compilation last for hours. This trick of isolating some functions in separate files speeds up compilation 20 times (and allows to parallelize it as well).</p>\n", "LastActivityDate": "2014-02-04T14:50:35.580", "CommentCount": "0", "CreationDate": "2014-02-04T14:50:35.580", "ParentId": "21534435", "Score": "1", "OwnerUserId": "399692"}, "21534435": {"ViewCount": "892", "Body": "<p><strong>Summary</strong><br>\n This question is about achieving separate compilation of a single template class instantiation in a several different translation units.</br></p>\n<p><strong>Question</strong><br>\nFor non-template classes one can put definitions in several .cpp files and compile them separately. For instance:</br></p>\n<p><em>file A.h:</em></p>\n<pre><code>class A {\npublic:\n  void func1();\n  void func2();\n  void func3() { /* defined in class declaration */}\n}\n</code></pre>\n<p><em>file A1.cpp:</em></p>\n<pre><code>void A::func1() { /* do smth */ }\n</code></pre>\n<p><em>file A2.cpp:</em></p>\n<pre><code>void A::func2() { /* do smth else */ }\n</code></pre>\n<p>Now I tried to do something similar with template classes. Since I know exactly which instances I will need, I'm explicitly instantiating templates. I'm compiling each instantiation separately, because member functions contain rather large mathematical expressions, which could slow down compiler considerably on high optimization levels. So I tried the following:</p>\n<p><em>file TA.h:</em></p>\n<pre><code>template &lt;typename T&gt;\nclass TA {\npublic:\n  void func1();\n  void func2();\n  void func3() { /* defined in class declaration */}\n}\n</code></pre>\n<p><em>file TA1.cpp:</em></p>\n<pre><code>template &lt;typename T&gt;\nvoid TA&lt;T&gt;::func1() { /* do smth */ }\ntemplate class TA&lt;sometype&gt;;\n</code></pre>\n<p><em>file TA2.cpp:</em></p>\n<pre><code>template &lt;typename T&gt;\nvoid TA&lt;T&gt;::func2() { /* do smth else */ }\ntemplate class TA&lt;sometype&gt;;\n</code></pre>\n<p>It works with clang and GCC on Linux, but fails with GCC on Mac during linking during duplicate symbols error (in this example due to func3, which got instantiated in both TA1.cpp and TA2.cpp).</p>\n<p>Then I stumbled upon this sentence in the standard:</p>\n<blockquote>\n<p id=\"so_21534435_21534435_0\">C++11.14.7, paragraph 5:<br>\n    For a given template and a given set of template-arguments,<br>\n     -- an explicit instantiation de\ufb01nition shall appear at most once in a program,<br>\n  -- ...</br></br></br></p>\n</blockquote>\n<p>Does it mean that separate compilation of template classes is not possible (not allowed) even when using explicit instantiation (it is obviously not possible with implicit instantiation)?</p>\n<p>PS I don't care since I've got my answer, but whoever thinks it is answered in here <a href=\"https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file\">https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file</a> is wrong.</p>\n", "AcceptedAnswerId": "21555649", "Title": "Separate compilation and template explicit instantiation", "CreationDate": "2014-02-03T18:07:47.250", "Id": "21534435", "CommentCount": "3", "LastEditDate": "2014-02-04T14:24:56.213", "PostTypeId": "1", "LastEditorUserId": "399692", "LastActivityDate": "2014-02-04T14:50:35.580", "Score": "2", "OwnerUserId": "399692", "Tags": "<c++><templates><explicit-instantiation>", "AnswerCount": "2"}, "21534772": {"Id": "21534772", "PostTypeId": "2", "Body": "<p>Separate compilation of templates is tricky but allowed. What you cannot do is to explicitly instantiate the type in multiple translation units, in the same way that you cannot define the same function in two translation units.</p>\n", "LastActivityDate": "2014-02-03T18:23:09.660", "CommentCount": "5", "CreationDate": "2014-02-03T18:23:09.660", "ParentId": "21534435", "Score": "1", "OwnerUserId": "36565"}});