post_cb({"23555612": {"CommentCount": "2", "AcceptedAnswerId": "23558302", "CreationDate": "2014-05-09T02:15:15.553", "LastActivityDate": "2014-05-09T07:00:56.493", "PostTypeId": "1", "ViewCount": "698", "FavoriteCount": "2", "Title": "Can a C++11 thread_local variable inherit its initial value from the parent thread?", "Id": "23555612", "Score": "4", "Body": "<p>I'd like to have a <code>thread_local</code> variable to change the level of logging applied in each thread of my application.  Something like so:</p>\n<pre><code>enum class trace_level { none, error, warning, log, debug, verbose };\nstatic thread_local trace_level min_level = trace_level::log;\n</code></pre>\n<p>The default value should be <code>trace_level::log</code> for the main thread when the application starts, but if it is changed before launching other threads, then I would like the child threads to start with the current value of the parent.</p>\n<p>Is there any way to do this using a <code>thread_local</code> variable?  Since this code is buried in a library it is not an option to simply set the value manually at the start of each thread.</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "1651000", "AnswerCount": "2"}, "23558302": {"ParentId": "23555612", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This already happens if the initialization is dynamic. The standard requires that variables with \"thread storage duration\"  and dynamic initialization be initialized sometime between the start of the thread and the 'first odr-use'. However, since you generally can't control exactly when that initialization will occur (other than sometime after the thread object is created and sometime before the thread ends - assuming the thread local variable actually gets used by the thread) the problem is that the thread local variable might get initialized with a value that your main thread sets <em>after</em> the thread is created.</p>\n<p>For a concrete example, consider:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;thread&gt;\n#include &lt;string&gt;\n\nusing std::string;\n\nenum class trace_level { none, error, warning, log, debug, verbose };\n\ntrace_level log_level = trace_level::log;\n\n\nstatic thread_local trace_level min_level = log_level;\nvoid f(string const&amp; s)\n{\n\n    printf(\"%s, min_level == %d\\n\", s.c_str(), (int) min_level);\n}\n\n\n\nint main()\n{\n    std::thread t1{std::bind(f,\"thread 1\")};\n\n    //TODO: std::this_thread::sleep_for(std::chrono::milliseconds(50));\n\n    log_level = trace_level::verbose;\n    std::thread t2{std::bind(f,\"thread 2\")};\n\n    t1.join();\n    t2.join();\n}\n</code></pre>\n<p>With the <code>sleep_for()</code> call commented out as above, I get the following output (usually):</p>\n<pre><code>C:\\so-test&gt;test\nthread 1, min_level  == 5\nthread 2, min_level  == 5\n</code></pre>\n<p>However, with the <code>sleep_for()</code> uncommented, I get (again - usually):</p>\n<pre><code>C:\\so-test&gt;test\nthread 1, min_level  == 3\nthread 2, min_level  == 5\n</code></pre>\n<p>So as long as you're willing to live with a bit of uncertainty regarding which logging level a thread will get if the level gets changed in the main thread soon after the thread starts, you can probably just do what you're looking to do pretty naturally.</p>\n<p>There's one remaining caveat - data races. The code above has a data race on the <code>log_level</code> variable, so it actually has undefined behavior. The fix for that is to make the variable either an atomic type or wrap it in a class that uses a mutex to protect updates and reads from data races. So change the declaration of the global  <code>log_level</code> to:</p>\n<pre><code>std::atomic&lt;trace_level&gt; log_level(trace_level::log);\n</code></pre>\n<hr>\n<p>Standards citations:</p>\n<blockquote>\n<p id=\"so_23555612_23558302_0\">3.6.2 Initialization of non-local variables [basic.start.init]</p>\n<p id=\"so_23555612_23558302_1\">...  Non-local variables with thread storage duration are initialized\n  as a consequence of thread execution. ...</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_23555612_23558302_2\">3.7.2/2 Thread storage duration [basic.stc.thread]</p>\n<p id=\"so_23555612_23558302_3\">A variable with thread storage duration shall be initialized before\n  its first odr-use (3.2) and, if constructed, shall be destroyed on\n  thread exit.</p>\n</blockquote>\n</hr>", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2014-05-09T07:00:56.493", "Id": "23558302", "Score": "1", "CreationDate": "2014-05-09T06:52:44.273", "LastActivityDate": "2014-05-09T07:00:56.493"}, "23556920": {"ParentId": "23555612", "CommentCount": "0", "Body": "<p>You can create a global pointer to a parent thread local variable.</p>\n<p>In global scope</p>\n<pre><code>thread_local trace_level min_level = trace_level::log;\ntrace_level *min_level_ptr = nullptr;\n</code></pre>\n<p>Then, in each thread you can do:</p>\n<pre><code>if (!min_level_ptr)\n    min_level_ptr = &amp;min_level;\nelse\n    min_level = *min_level_ptr;\n</code></pre>\n<p>(Possibly, make the <code>min_level_ptr</code> atomic for added safety and use atomic compare exchange instead of assignment).</p>\n<p>The idea goes as following: each thread's local storage occupies a different region in memory, so <code>min_level</code> variable in one thread has unique storage address different from all other. <code>min_level_ptr</code>, on the other hand, has the same address, no matter which thread is accessing it. As \"parent\" thread starts before all other, it will claim the globally shared pointer with its own <code>min_level</code> address. The children will then initialize their values from that location.</p>\n", "OwnerUserId": "2702398", "PostTypeId": "2", "Id": "23556920", "Score": "1", "CreationDate": "2014-05-09T05:00:11.067", "LastActivityDate": "2014-05-09T05:00:11.067"}, "bq_ids": {"n4140": {"so_23555612_23558302_1": {"section_id": 7150, "quality": 1.0, "length": 9}, "so_23555612_23558302_3": {"section_id": 7169, "quality": 1.0, "length": 13}}, "n3337": {"so_23555612_23558302_1": {"section_id": 6894, "quality": 1.0, "length": 9}, "so_23555612_23558302_3": {"section_id": 6913, "quality": 1.0, "length": 13}}, "n4659": {"so_23555612_23558302_1": {"section_id": 8651, "quality": 0.7777777777777778, "length": 7}, "so_23555612_23558302_3": {"section_id": 8677, "quality": 1.0, "length": 13}}}});