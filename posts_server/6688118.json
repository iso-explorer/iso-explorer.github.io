post_cb({"bq_ids": {"n4140": {"so_6688118_6688543_0": {"section_id": 7151, "quality": 1.0, "length": 57}, "so_6688118_6688626_0": {"section_id": 233, "quality": 0.5769230769230769, "length": 60}, "so_6688118_6688626_1": {"section_id": 241, "quality": 0.9230769230769231, "length": 12}, "so_6688118_6688599_0": {"section_id": 257, "quality": 0.8421052631578947, "length": 16}, "so_6688118_6688626_2": {"section_id": 7043, "quality": 0.8769230769230769, "length": 57}, "so_6688118_6688599_1": {"section_id": 234, "quality": 0.9047619047619048, "length": 19}, "so_6688118_6688626_4": {"section_id": 7043, "quality": 0.9375, "length": 15}}, "n3337": {"so_6688118_6688543_0": {"section_id": 6895, "quality": 1.0, "length": 57}, "so_6688118_6688626_0": {"section_id": 226, "quality": 0.5769230769230769, "length": 60}, "so_6688118_6688626_1": {"section_id": 233, "quality": 0.9230769230769231, "length": 12}, "so_6688118_6688599_0": {"section_id": 248, "quality": 0.8421052631578947, "length": 16}, "so_6688118_6688626_2": {"section_id": 6788, "quality": 0.8769230769230769, "length": 57}, "so_6688118_6688599_1": {"section_id": 227, "quality": 0.9047619047619048, "length": 19}, "so_6688118_6688626_4": {"section_id": 6788, "quality": 1.0, "length": 16}}, "n4659": {"so_6688118_6688626_2": {"section_id": 8540, "quality": 0.8769230769230769, "length": 57}, "so_6688118_6688599_1": {"section_id": 244, "quality": 1.0, "length": 21}, "so_6688118_6688626_4": {"section_id": 8540, "quality": 0.9375, "length": 15}, "so_6688118_6688626_1": {"section_id": 55, "quality": 0.5384615384615384, "length": 7}, "so_6688118_6688599_0": {"section_id": 264, "quality": 0.8421052631578947, "length": 16}}}, "6688416": {"ParentId": "6688118", "CommentCount": "0", "Body": "<p>Following is my observation (based on gcc):</p>\n<blockquote>\n<p id=\"so_6688118_6688416_0\">Whatever appears first, is instantiated first.</p>\n</blockquote>\n<p>If in a given translation unit (i.e. preprocessed <code>.cpp</code> file), if the compiler (parser) sees the usage <code>X&lt;A&gt;::t</code> first then it's instantiated first or if it sees <code>X&lt;B&gt;::t</code> first then that is instantiated first. Note, that this is before compilation (not runtime).</p>\n<p>For example,</p>\n<pre><code>struct A { static int a; };\nstruct B { static int b; };\n\ntemplate&lt;typename T&gt; struct X { static T t; };\ntemplate&lt;typename T&gt; T X&lt;T&gt;::t;\n\nvoid foo ()\n{\n  B *p = &amp;(X&lt;B&gt;::t);\n}\n\nint main ()\n{\n  A *p = &amp;(X&lt;A&gt;::t);\n  foo();\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>X&lt;B&gt;::t instantiated first\nX&lt;A&gt;::t instantiated second\n</code></pre>\n<p>Reason:</p>\n<blockquote>\n<p id=\"so_6688118_6688416_1\"><code>X&lt;B&gt;::t</code> appears first inside <code>foo()</code></p>\n</blockquote>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "6688416", "Score": "1", "CreationDate": "2011-07-14T04:15:06.027", "LastActivityDate": "2011-07-14T04:15:06.027"}, "6688118": {"CommentCount": "1", "ViewCount": "708", "CreationDate": "2011-07-14T03:21:03.260", "LastActivityDate": "2011-07-14T04:52:50.653", "Title": "What is the initialization order for static data members of template class in a file?", "AcceptedAnswerId": "6688626", "PostTypeId": "1", "Id": "6688118", "Score": "7", "Body": "<p>In a given file if I have,</p>\n<pre><code>struct A { static int a; };\nstruct B { static int b; };\nint A::a;\nint B::b;\n</code></pre>\n<p>Then, I can always expect that <code>A::a</code> gets initialized before <code>B::b</code>. Now for the same file, take the <code>template</code> case,</p>\n<pre><code>template&lt;typename T&gt;\nstruct X { static T t; };\ntemplate&lt;typename T&gt;\nT X&lt;T&gt;::t;\n</code></pre>\n<p>Suppose, <code>X</code> is instantiated with <code>A</code> and <code>B</code> and its <code>static</code> member is used arbitrarily somewhere in the code as, <code>X&lt;A&gt;::t</code> and <code>X&lt;B&gt;::t</code>, then what should be the order for initialization of <code>template</code> static member <code>X&lt;T&gt;::t;</code> ? Is it well defined ?</p>\n", "Tags": "<c++><class><templates><static-members>", "OwnerUserId": "514235", "AnswerCount": "4"}, "6688626": {"ParentId": "6688118", "CommentCount": "1", "Body": "<p>As long as the templates only have one definition (e.g. you only have one translation unit), it's well-defined.  The static members are initialized in the order that the template specializations are instantiated <em>in contexts that require the definition of the static data member</em>.  From \u00a714.7.1/1 [temp.inst] of the C++03 standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_6688118_6688626_0\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3), the class template specialization is implicitly instantiated when the specialization is referenced in a context that requires a completely-defined object type or when the completeness of the class type affects the semantics of the program. The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, static data members and member templates; and it causes the implicit instantiation of the definitions of member anonymous unions. Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; <strong>in particular, the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist.</strong></p>\n</blockquote>\n<p>\u00a714.7.1/7 also states:</p>\n<blockquote>\n<p id=\"so_6688118_6688626_1\">The implicit instantiation of a class template does not cause any static data members of that class to be implicitly instantiated.</p>\n</blockquote>\n<p>However, things get more complicated when you have multiple translation units that define the template.  \u00a73.2/5 [basic.def.odr] states:</p>\n<blockquote>\n<p id=\"so_6688118_6688626_2\">There can be more than one definition of a class type (clause 9), enumeration type (7.2), inline function with external linkage (7.1.2), class template (clause 14), non-static function template (14.5.5), static data member of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for which some template parameters are not specified (14.7, 14.5.4) in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then  </p>\n<p id=\"so_6688118_6688626_3\">(list of conditions...)</p>\n<p id=\"so_6688118_6688626_4\">If the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D. If the definitions of D do not satisfy these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>Note that the standard doesn't specify <em>which</em> definition is taken as the single definition, only that <em>some</em> definition is chosen.  So, if multiple translation units instantiate the templates in different orders, there's no guarantee what the order of initialization will be.</p>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "6688626", "Score": "4", "CreationDate": "2011-07-14T04:52:50.653", "LastActivityDate": "2011-07-14T04:52:50.653"}, "6688543": {"ParentId": "6688118", "CommentCount": "0", "Body": "<p>From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf\" rel=\"nofollow\">C++0x draft standard</a>, section 3.6.2:</p>\n<blockquote>\n<p id=\"so_6688118_6688543_0\">Dynamic initialization of a non-local variable with static storage duration is either ordered or unordered. Definitions of explicitly specialized class template static data members have ordered initialization. Other class template static data members (i.e., implicitly or explicitly instantiated specializations) have unordered initialization. Other non-local variables with static storage duration have ordered initialization. Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit.</p>\n</blockquote>\n<p>So to answer your question, static data members of explicitly-instantiated templates are not guaranteed to be initialized in any particular order in C++0x.</p>\n<p>I leave it to others to find the corresponding language (or lack thereof) in the earlier standard(s).</p>\n", "OwnerUserId": "768469", "PostTypeId": "2", "Id": "6688543", "Score": "1", "CreationDate": "2011-07-14T04:38:00.947", "LastActivityDate": "2011-07-14T04:38:00.947"}, "6688599": {"ParentId": "6688118", "CommentCount": "1", "Body": "<p>From 14.7.2/7:</p>\n<blockquote>\n<p id=\"so_6688118_6688599_0\">The explicit instantiation of a class template specialization implies\n  the instantiation of all of its members not previously explicitly\n  specialized in the translation unit containing the explicit\n  instantiation.</p>\n</blockquote>\n<p>So we can conclude that templates that are explicitly instantiated have their static members instantiated/constructed in the same order.</p>\n<p>For implicitly instantiated templates however, we go to 14.7.1/1:</p>\n<blockquote>\n<p id=\"so_6688118_6688599_1\">...in particular, the initialization (and any associated side effects) of\n  a static data member does not occur unless the static data member is\n  itself used in a way that requires the definition of the static data\n  member to exist.</p>\n</blockquote>\n<p>From this I don't think we can safely draw any conclusions about the order in which they may be instantiated for implicitly instantiated templates.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "6688599", "Score": "1", "CreationDate": "2011-07-14T04:48:00.643", "LastActivityDate": "2011-07-14T04:48:00.643"}});