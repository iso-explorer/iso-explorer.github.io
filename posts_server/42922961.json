post_cb({"42922961": {"CommentCount": "3", "AcceptedAnswerId": "42923438", "ClosedDate": "2017-03-21T09:50:24.710", "CreationDate": "2017-03-21T09:26:46.603", "LastActivityDate": "2017-03-21T09:49:06.310", "PostTypeId": "1", "ViewCount": "61", "Title": "Declaration and implementation of templated member functions", "Id": "42922961", "Score": "0", "Body": "<p>I'm trying to make a quick utility class that extends <code>std::vector</code> through composition. For this, I want to make it as generic as possible.</p>\n<p>The class works well when declared and implemented in a single file (i.e. main.cpp):</p>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nclass FVector {\n\npublic:\n\n    FVector(std::vector&lt;T&gt; vector): _vector(vector) {}\n\n    template &lt;typename unaryOperation&gt;\n    void forEach(unaryOperation op) {\n        std::for_each(_vector.begin(),_vector.end(),op);\n    };\n\nprivate:\n\n    std::vector&lt;T&gt; _vector;\n\n};\n\nint main(int argc, const char * argv[]) {\n\n    auto printInt = [](int i){ std::cout &lt;&lt; i &lt;&lt; std::endl; };\n    std::vector&lt;int&gt; numbers{1, 2, 3, 4, 5};\n    FVector&lt;int&gt; fNumbers{numbers};\n    fNumbers.forEach(printInt);\n\n    return 0;\n\n}\n</code></pre>\n<p>But when I try to put the class in its own .h and .cpp file, the compiler won't find the Constructor nor the function. </p>\n<p><strong>FVector.h</strong></p>\n<pre><code>...\n#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nclass FVector {\n\npublic:\n\n    FVector( std::vector&lt;T&gt; );\n\n    template &lt;typename unaryOperation&gt;\n    void forEach(unaryOperation);\n\nprivate:\n\n    std::vector&lt;T&gt; _vector;\n\n\n};\n...\n</code></pre>\n<p><strong>FVector.cpp</strong></p>\n<pre><code>#include \"FVector.hpp\"\n#include &lt;algorithm&gt;\n\ntemplate &lt;typename T&gt;\nFVector&lt;T&gt;::FVector( std::vector&lt;T&gt; vector ): _vector(vector) {}\n\ntemplate &lt;typename T&gt;\ntemplate &lt;typename unaryOperation&gt;\nvoid FVector&lt;T&gt;::forEach(unaryOperation op) {\n    std::for_each(_vector.begin(),_vector.end(),op);\n}\n</code></pre>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include \"FVector.hpp\"\n\nint main(int argc, const char * argv[]) {\n\n    auto printInt = [](int i){ std::cout &lt;&lt; i &lt;&lt; std::endl; };\n    std::vector&lt;int&gt; numbers{1, 2, 3, 4, 5};\n    FVector&lt;int&gt; fNumbers{numbers};\n    fNumbers.forEach(printInt);\n\n    return 0;\n\n}\n</code></pre>\n<p><strong>error</strong></p>\n<blockquote>\n<p id=\"so_42922961_42922961_0\">Function 'FVector::forEach&lt;(lambda at blah/main.cpp:95:21)&gt;' has\n  internal linkage but is not defined</p>\n</blockquote>\n<p>Clearly something in my syntax is very wrong, but I can't find how to declare/implement the functions.</p>\n<p>Thanks!</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "981079", "AnswerCount": "2"}, "42923438": {"ParentId": "42922961", "CommentCount": "0", "Body": "<p>C++ templates are special animals: each instanciation of the template is a different class. That means that if you try to put the template class definition in its own cpp, as no instanciation will be required in that translation unit, the compiler will generate none. And when you will try to use one from another translation unit, the linker will complain because it cannot find the concrete definition.</p>\n<p>The standard declares in draft n4296 (emphasize mine):</p>\n<blockquote>\n<p id=\"so_42922961_42923438_0\">14 Templates [temp]<br/>...<br/>\n  A function template, member function of a class template, variable template, or static data member of a\n  class template <strong>shall be defined in every translation unit in which it is implicitly instantiated</strong> (14.7.1) unless\n  the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is\n  required.</p>\n</blockquote>\n<p>That's why the common use is to write the full definition on a template in the header file, to make sure that the definition will be present in every translation unit.</p>\n", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "42923438", "Score": "1", "CreationDate": "2017-03-21T09:49:06.310", "LastActivityDate": "2017-03-21T09:49:06.310"}, "42923180": {"ParentId": "42922961", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Right now, there is only a recipe how to create an instance for FVector, but none is created. You need to instantiate one. The source file has no way to \"know\" which instances are needed since it is not included somewhere where a class from the template is used, that is the problem (well, incorrectly formulated, but I hope you get the point - basically, when a file includes a header, it can use everything in the header to create a class out of a template, but not what is in some source it does not even know)</p>\n<p>This can be done by writing something like</p>\n<pre><code>template class FVector&lt;double&gt;;\n</code></pre>\n<p>at the end of your source file to specialize it over double, and then the same for every forEach-specialization that should exist. I usually have another file, ClassNameSpecialization.h (that is FVectorSpecialization.h in your case), which contains only such lines and is included at the end of the source file. Makes it easy to add some specializations.</p>\n<p>If you want FVector to be dynamic, being able to work with any template parameter given that could possibly work with the code, you need to implement it in the header, although this is ugly of course.</p>\n", "OwnerUserId": "5114342", "LastEditorUserId": "5114342", "LastEditDate": "2017-03-21T09:43:22.353", "Id": "42923180", "Score": "1", "CreationDate": "2017-03-21T09:37:43.877", "LastActivityDate": "2017-03-21T09:43:22.353"}, "bq_ids": {"n4140": {"so_42922961_42923438_0": {"section_id": 53, "quality": 0.875, "length": 28}}, "n3337": {"so_42922961_42923438_0": {"section_id": 48, "quality": 0.8125, "length": 26}}, "n4659": {"so_42922961_42923438_0": {"section_id": 55, "quality": 0.875, "length": 28}}}});