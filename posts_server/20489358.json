post_cb({"20489469": {"ParentId": "20489358", "CommentCount": "1", "Body": "<p>I think that if you are trying to deleate the pointer, you are actually deleting the place in tye memory of the object that the pointer points. You can do it using reference:</p>\n<pre><code>int *p = NULL;\n\ndelete &amp;p;\n</code></pre>\n", "OwnerUserId": "2797066", "PostTypeId": "2", "Id": "20489469", "Score": "-1", "CreationDate": "2013-12-10T08:29:06.477", "LastActivityDate": "2013-12-10T08:29:06.477"}, "20489358": {"CommentCount": "3", "ViewCount": "144", "PostTypeId": "1", "LastEditorUserId": "2000726", "CreationDate": "2013-12-10T08:22:38.423", "LastActivityDate": "2013-12-10T10:24:30.117", "Title": "Deleting dynamically allocated memory", "LastEditDate": "2013-12-10T08:24:43.543", "Id": "20489358", "Score": "0", "Body": "<p>I'm facing some conceptual issues in dynamic memory allocation. Firstly if I write the following piece of code</p>\n<pre><code>int *p = NULL;\ndelete p;\n</code></pre>\n<p>why I get no error? I'm trying to delete the pointer (on the stack) which is not pointing to anything. Also if I write the following statement</p>\n<pre><code>int *p = new int;\np = NULL;\ndelete p;\n</code></pre>\n<p>I again get no compile or runt-time error. Why ? \nMoving on if I write the following code I get a runtime error</p>\n<pre><code>int *p = new int;\np = NULL;\ndelete p;\ndelete p;\n</code></pre>\n<p>Why? And if I write the following code, I get no error</p>\n<pre><code>int *p = NULL;\ndelete p;\ndelete p;\n</code></pre>\n<p>Why ? Can anyone explain conceptually the reasons behind this ?</p>\n", "Tags": "<c++>", "OwnerUserId": "3054062", "AnswerCount": "6"}, "20490043": {"ParentId": "20489358", "CommentCount": "0", "Body": "<p>\"I'm trying to delete the pointer (on the stack) which is not pointing to anything.\"</p>\n<p>This is not true. You cannot delete from stack. With <code>delete</code> you delete memory blocks on the heap whose adress is stored in a pointer. The pointer itself is a stack variable.</p>\n", "OwnerUserId": "2947694", "PostTypeId": "2", "Id": "20490043", "Score": "0", "CreationDate": "2013-12-10T09:02:11.447", "LastActivityDate": "2013-12-10T09:02:11.447"}, "bq_ids": {"n4140": {"so_20489358_20489408_1": {"section_id": 6106, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_20489358_20489408_1": {"section_id": 5872, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_20489358_20489408_1": {"section_id": 7603, "quality": 0.5454545454545454, "length": 6}}}, "20489567": {"ParentId": "20489358", "CommentCount": "0", "Body": "<p>I assume that in your third example you meant to write</p>\n<pre><code>int *p = new int;\ndelete p;\ndelete p;\n</code></pre>\n<p>Formally this causes undefined behaviour, which means that anything could happen. In practice you are probably using a memory allocator that checks whether the pointer you are deleting points within its free memory pool.</p>\n<p>Others already pointed out that deleting a null pointer doesn't cause an error by definition, so it doesn't matter how many times you do it.</p>\n", "OwnerUserId": "838975", "PostTypeId": "2", "Id": "20489567", "Score": "1", "CreationDate": "2013-12-10T08:35:35.213", "LastActivityDate": "2013-12-10T08:35:35.213"}, "20489408": {"ParentId": "20489358", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Passing a null pointer to the delete operator is a no-op.  The standard says so:</p>\n<blockquote>\n<p id=\"so_20489358_20489408_0\">5.3.5/2</p>\n<p id=\"so_20489358_20489408_1\">In either alternative [delete and delete[]], if the value of the operand of delete is the null pointer the operation has no effect.</p>\n</blockquote>\n<hr>\n<p>Consider an object that owns a pointer to another object.  Usually, when the destructor of the owning object is run, it would clean up the memory for the owned object by deleting it.  But in the case where the owned object could also be null, what would we do to clean up the memory?  One option would be to wrap every single delete in an \"if (X) delete x\" kind of wrapper.  But that's horrendously noisy, for no real added benefit.  Therefore, the delete operator does it for you.</p>\n</hr>", "OwnerUserId": "24913", "LastEditorUserId": "24913", "LastEditDate": "2013-12-10T08:49:36.870", "Id": "20489408", "Score": "0", "CreationDate": "2013-12-10T08:25:35.990", "LastActivityDate": "2013-12-10T08:49:36.870"}, "20491862": {"ParentId": "20489358", "CommentCount": "0", "Body": "<p>In every case you are only deleting a nullpointer, which by definition is always \"safe\" because it is a no-op (the C++ standard explicitly says so).</p>\n<p>In your second and third example, you are reassigning a new value (the nullpointer) to the pointer before deleting it, which means that you are leaking the previously allocated integer. This is something that should not normally happen (in this case, you won't die from leaking a single integer, but it's not a good thing).</p>\n<p>The double deletion in the third and fourth examples are normally serious programming errors, but they are \"harmless\" in your example because the deleted pointer is the nullpointer (so it's a no-op).</p>\n<hr/>\n<p><strong>Going a bit O/T:</strong><br>\nNote that I have put \"safe\" and \"harmless\" in quotes above for good reason. I personally disagree with Mr. Stroustrup's design decision here.<br>\nMaking the deletion of a nullpointer a \"harmless no-op\" is actually not a very good idea, even if the intent was probably good. Mr. Stroustrup even goes further by allowing <code>delete</code> to set the pointer to the nullponter and saying he wished that implementations actually did that (luckily no implementation that I know does!).</br></br></p>\n<p>In my opinion, every object that was allocated should be deleted exactly once, none less and not more often.</p>\n<p>When and how often a well-behaved, non-broken program may (and must) delete a pointer is exactly defined, it is not a random unknown thing. Deletion must happen exactly once, and the program must be exactly aware of it because it must be certain whether or not an object is valid (because it's illegal to use the object if it isn't valid!).</p>\n<p>Setting a pointer to the nullpointer after deleting the object will cause a fault when dereferencing the deleted object afterwards (this is a good thing), but it does <strong>not</strong> protect from double deletion. Instead, it <em>hides</em> this serious programming error, ignoring it silently.</p>\n<p>If a program deletes a pointer twice, then the program logic is broken, it is not working properly. This is not something that can be ignored, it must be fixed. Therefore, such a program <em>should crash</em>. Allocators usually detect double deletion, but by resetting a pointer to the nullpointer, one has effectively disabled this detection mechanism.</p>\n<p>If one chooses to reset a pointer after deleting it, one should (in my opinion) set it to an invalid non-nullpointer value, for example <code>(T*)1</code> or <code>(T*)-1</code>. This will guarantee that <strong>both</strong> dereferencing and deleting the pointer will crash on the first occasion.</p>\n<p>Nobody likes to see program crashes. But crashing early and crashing at the first occasion is a <em>good thing</em> compared to an incorrect program logic continuing for an indeterminate time, and possibly crashing or silently corrupting data at a random occasion.</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "20491862", "Score": "0", "CreationDate": "2013-12-10T10:24:30.117", "LastActivityDate": "2013-12-10T10:24:30.117"}, "20489488": {"ParentId": "20489358", "CommentCount": "2", "Body": "<p>The inner implementation is transparent to us programmers. As you see, <code>delete</code> a <code>NULL</code> pointer may be harmless, but generally you should avoid this. You may have seen words like 'please do not re-delete dynamic pointers'</p>\n", "OwnerUserId": "2823146", "PostTypeId": "2", "Id": "20489488", "Score": "-1", "CreationDate": "2013-12-10T08:30:42.643", "LastActivityDate": "2013-12-10T08:30:42.643"}});