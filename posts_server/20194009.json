post_cb({"20195234": {"ParentId": "20194009", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> says <em>sizeof shall not be applied to a bit-field</em> in section <code>5.3.3</code> <em>Sizeof</em> paragraph <em>1</em>. If you have control of the source then using an <em>enum</em> sounds much simpler and neater:</p>\n<pre><code>struct mybits\n{\n    enum bitFieldSizes\n    {\n        field1 = 15,\n        field2 = 2,\n        field3 = 4,\n        field4 = 8,\n        field5 = 31\n    };\n\n    unsigned int one : field1 ;  \n    unsigned int two : field2 ;  \n    unsigned int three : field3 ;\n    unsigned int four : field4 ;\n    unsigned int five : field5 ;\n};\n</code></pre>\n<p>If you don't have control of the source it is possible to use bit hacks to obtain the size of your bit-field and <a href=\"http://en.cppreference.com/w/cpp/utility/bitset\" rel=\"nofollow\">std::bitset</a> makes it easier:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n\nstruct mybits\n{\n    unsigned int one : 15 ;  \n    unsigned int two : 2 ;  \n    unsigned int three : 4 ;\n    unsigned int four : 8 ;\n    unsigned int five : 31 ;\n};\n\nint main()\n{\n    mybits mb1 ;\n\n    mb1.one   =  ~0 ;\n    mb1.two   =  ~0 ;\n    mb1.three =  ~0 ;\n    mb1.four  =  ~0 ;\n    mb1.five  =  ~0 ;\n\n    std::bitset&lt;sizeof(unsigned int)*8&gt; b1(mb1.one);\n    std::bitset&lt;sizeof(unsigned int)*8&gt; b2(mb1.two);\n    std::bitset&lt;sizeof(unsigned int)*8&gt; b3(mb1.three);\n    std::bitset&lt;sizeof(unsigned int)*8&gt; b4(mb1.four);\n    std::bitset&lt;sizeof(unsigned int)*8&gt; b5(mb1.five);\n\n    std::cout &lt;&lt; b1 &lt;&lt; \":\" &lt;&lt; b1.count() &lt;&lt; std::endl ;\n    std::cout &lt;&lt; b2 &lt;&lt; \":\" &lt;&lt; b2.count() &lt;&lt; std::endl ;\n    std::cout &lt;&lt; b3 &lt;&lt; \":\" &lt;&lt; b3.count() &lt;&lt; std::endl ;\n    std::cout &lt;&lt; b4 &lt;&lt; \":\" &lt;&lt; b4.count() &lt;&lt; std::endl ;\n    std::cout &lt;&lt; b5 &lt;&lt; \":\" &lt;&lt; b5.count() &lt;&lt; std::endl ;\n}\n</code></pre>\n<p>which produces the following output:</p>\n<pre><code>00000000000000000111111111111111:15\n00000000000000000000000000000011:2\n00000000000000000000000000001111:4\n00000000000000000000000011111111:8\n01111111111111111111111111111111:31\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2013-11-25T19:23:47.087", "Id": "20195234", "Score": "1", "CreationDate": "2013-11-25T14:11:35.170", "LastActivityDate": "2013-11-25T19:23:47.087"}, "42773543": {"ParentId": "20194009", "CommentCount": "0", "Body": "<p>Here is a little bit tricky generalized version:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;bitset&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nT umaxof()\n{\n      T t;\n      memset(&amp;t, 0xFF, sizeof(T));\n      return t;\n}\n\ntemplate &lt;class T&gt;\nsize_t bitsof(const T&amp; umax)\n{\n    return bitset&lt;sizeof(T)*8&gt;(umax).count();\n}\n\nint main() \n{\n    struct A\n    {\n        uint32_t bf1:19;\n        uint32_t bf2:1;\n    };\n\n    cout &lt;&lt; bitsof(umaxof&lt;A&gt;().bf1) &lt;&lt; \"\\n\";\n    cout &lt;&lt; bitsof(umaxof&lt;A&gt;().bf2) &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>It can be tried out at <a href=\"https://ideone.com/v4BiBH\" rel=\"nofollow noreferrer\">https://ideone.com/v4BiBH</a></p>\n<p>Note: Works with unsigned bit fields only.</p>\n", "OwnerUserId": "7705264", "PostTypeId": "2", "Id": "42773543", "Score": "0", "CreationDate": "2017-03-13T21:14:12.400", "LastActivityDate": "2017-03-13T21:14:12.400"}, "20194009": {"CommentCount": "1", "AcceptedAnswerId": "20194422", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2013-11-25T13:12:37.923", "LastActivityDate": "2017-03-13T21:14:12.400", "LastEditDate": "2013-11-26T01:20:53.553", "ViewCount": "1329", "FavoriteCount": "5", "Title": "Size of a bitfield member?", "Id": "20194009", "Score": "13", "Body": "<p>Would anyone know how to extract the size of a <em>bit-field</em> member.  The below code naturally gives me the size of an integer, but how do I find out how many bits or bytes are in <code>mybits.one</code>? I've tried <code>sizeof(test.one)</code> but which clearly won't work.   I realize this is a measure of bits:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n{\n    struct mybits {\n        unsigned int one:15;\n    };\n\n    mybits test;\n    test.one = 455;\n    cout &lt;&lt; test.one &lt;&lt; endl;\n    cout &lt;&lt; \"The size of test.one is:  \" &lt;&lt; sizeof(test) &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><bits><bit-fields>", "OwnerUserId": "2758100", "AnswerCount": "5"}, "20194135": {"ParentId": "20194009", "CommentCount": "3", "Body": "<p>Because of padding it is not possible to see number of bits in a bit field using sizeof operator.</p>\n<p>The only way is to open up the header where the structure is defined, and look it up.</p>\n", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "20194135", "Score": "1", "CreationDate": "2013-11-25T13:19:53.877", "LastActivityDate": "2013-11-25T13:19:53.877"}, "20194172": {"ParentId": "20194009", "CommentCount": "0", "Body": "<p>There is no way to get this information (apart from reading the declaration yourself). As per the standard, <code>[C++11]expr.sizeof\u00a71</code>, it's illegal to call <code>sizeof</code> on a bit-field:</p>\n<blockquote>\n<p id=\"so_20194009_20194172_0\">The sizeof operator shall not be applied to ... an lvalue that designates a bit-field.</p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "20194172", "Score": "1", "CreationDate": "2013-11-25T13:22:02.293", "LastActivityDate": "2013-11-25T13:22:02.293"}, "bq_ids": {"n4140": {"so_20194009_20194172_0": {"section_id": 6076, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_20194009_20194172_0": {"section_id": 5844, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_20194009_20194172_0": {"section_id": 7572, "quality": 0.7142857142857143, "length": 5}}}, "20194422": {"ParentId": "20194009", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Runtime solution, the idea from this discussion: <a href=\"http://social.msdn.microsoft.com/Forums/en-US/7e4f01b6-2e93-4acc-ac6a-b994702e7b66/finding-size-of-bitfield\" rel=\"nofollow\">http://social.msdn.microsoft.com/Forums/en-US/7e4f01b6-2e93-4acc-ac6a-b994702e7b66/finding-size-of-bitfield</a></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint BitCount(unsigned int value)\n{\n    int result = 0;\n\n    while(value)\n    {\n        value &amp;= (value - 1);\n        ++result;\n    }\n\n    return result;\n}\n\nint main()\n{\n    struct mybits {\n        unsigned int one:15;\n    };\n\n    mybits test;\n    test.one = ~0;\n\n    cout &lt;&lt; BitCount(test.one) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Prints 15.</p>\n", "OwnerUserId": "279313", "LastEditorUserId": "279313", "LastEditDate": "2013-11-25T14:16:11.607", "Id": "20194422", "Score": "5", "CreationDate": "2013-11-25T13:33:06.060", "LastActivityDate": "2013-11-25T14:16:11.607"}});