post_cb({"8163317": {"Id": "8163317", "PostTypeId": "2", "Body": "<p>From the standard section 9.4.2:</p>\n<blockquote>\n<p id=\"so_8162994_8163317_0\">If a static data member is of const integral or const enumeration\n  type, its declaration in the class definition can specify a\n  constant-initializer which shall be an integral constant expression.\n  In that case, the member can appear in integral constant expressions\n  within its scope. <strong>The member shall still be defined in a namespace\n  scope</strong> if it is used in the program and the namespace scope definition\n  shall not contain an initializer.</p>\n</blockquote>\n<p>Basically, local classes have no linkage, and static data members require a linkage.</p>\n<p>Since there's no way to define a static data member of a local class in namespace scope (a declaration with an initializer is not a definition), they are not allowed, whether they are of const integral type or not. On the surface it may seem like the compiler should just be able to inline the value, but then what happens if you try to access a pointer to the member? With namespace scoped classes you'd just get a linker error, but local classes have no linkage.</p>\n<p>I guess in theory they could just allow you to use static const integral types in local classes as long as they are only used in integral constant expressions, but it would probably just put too much of a burden on the standards body and compiler vendors to differentiate for very little practical value; local static variables are accessible from local classes, so using a local static const should be just as good.</p>\n", "LastEditorUserId": "19404", "LastActivityDate": "2011-11-17T08:38:30.437", "Score": "18", "CreationDate": "2011-11-17T07:07:20.257", "ParentId": "8162994", "CommentCount": "1", "OwnerUserId": "19404", "LastEditDate": "2011-11-17T08:38:30.437"}, "8163048": {"Id": "8163048", "PostTypeId": "2", "Body": "<p>Static members of a class need to be defined in global scope, e.g.</p>\n<pre><code>  abc.h\n\n   class myClass {\n   static int number;\n  };\n     abc.cpp\n\n   int myClass::number = 314;\n</code></pre>\n<p>Now, since the scope inside void abc(int x) is not global, there is no scope to define the static member. </p>\n", "LastActivityDate": "2011-11-17T06:33:23.483", "CommentCount": "3", "CreationDate": "2011-11-17T06:33:23.483", "ParentId": "8162994", "Score": "2", "OwnerUserId": "786935"}, "8162994": {"ViewCount": "4590", "Body": "<p>What is the reasoning to why <code>static const</code> members cannot exist in local classes? It seems like a rather silly restriction.</p>\n<p>Example:</p>\n<pre><code>void foo() {\n  struct bar {\n    int baz() { return 0; }   // allowed\n    static const int qux = 0; // not allowed?!?\n  };\n}\n\nstruct non_local_bar {\n  int baz() { return 0; }   // allowed\n  static const int qux = 0; // allowed\n};\n</code></pre>\n<p>Quote from standard (9.8.4):</p>\n<blockquote>\n<p id=\"so_8162994_8162994_0\">A local class shall not have static data members.</p>\n</blockquote>\n", "AcceptedAnswerId": "8163317", "Title": "Why aren't static data members allowed in local classes?", "CreationDate": "2011-11-17T06:27:17.223", "Id": "8162994", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-04-28T17:34:34.417", "LastEditorUserId": "103167", "LastActivityDate": "2014-05-15T08:26:44.180", "Score": "17", "OwnerUserId": "964135", "Tags": "<c++><static><static-members><local-class>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_8162994_8162994_0": {"length": 6, "quality": 1.0, "section_id": 5910}, "so_8162994_8163317_0": {"length": 28, "quality": 0.717948717948718, "section_id": 5908}}, "n3337": {"so_8162994_8162994_0": {"length": 6, "quality": 1.0, "section_id": 5682}, "so_8162994_8163317_0": {"length": 28, "quality": 0.717948717948718, "section_id": 5680}}, "n4659": {"so_8162994_8162994_0": {"length": 6, "quality": 1.0, "section_id": 7392}, "so_8162994_8163317_0": {"length": 24, "quality": 0.6153846153846154, "section_id": 7390}}}, "8163064": {"Id": "8163064", "PostTypeId": "2", "Body": "<p>I dont think there is a.reason. Normal static datamembers are disallowed because there is no way to define them after being declared.</p>\n<p>Also dont forget you can create a local const variable outside the.class that you can use inside the class as long as you only read its value (that is, as long as you dont take.its.address).</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-11-17T06:48:12.047", "Score": "4", "CreationDate": "2011-11-17T06:34:34.137", "ParentId": "8162994", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2011-11-17T06:48:12.047"}, "23672940": {"Id": "23672940", "PostTypeId": "2", "Body": "<p>As things progress, we now have C++11 and with that you can define integral constants variable members in your classes.</p>\n<pre><code>class test\n{\npublic:\n    const int FOO = 123;\n\n    [...snip...]\n};\n</code></pre>\n<p>That works when you compile with C++11. Notice that the <code>static</code> keyword is not used. When compiling with optimizations turned on, those variables will likely all get optimized out. In debug, though, they appear in your structure as regular variable members.</p>\n<p>Note, however, that the size of the class/structure will still include that variable. So here it is likely 4 bytes for the variable FOO.</p>\n<p>However, in most cases, classes defined in a function will completely be optimized out so this is a great way of doing things (a good 50% of my classes have such variable members!)</p>\n", "LastActivityDate": "2014-05-15T08:26:44.180", "CommentCount": "0", "CreationDate": "2014-05-15T08:26:44.180", "ParentId": "8162994", "Score": "-1", "OwnerUserId": "212378"}});