post_cb({"bq_ids": {"n4140": {"so_34590885_34596711_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 6091}, "so_34590885_34596711_0": {"length": 14, "quality": 0.875, "section_id": 6091}}, "n4659": {"so_34590885_34596711_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 7587}, "so_34590885_34596711_0": {"length": 14, "quality": 0.875, "section_id": 7587}}}, "34590885": {"ViewCount": "371", "LastEditDate": "2016-01-04T18:37:28.930", "AcceptedAnswerId": "34596711", "Title": "Optimization of raw new[]/delete[] vs std::vector", "CreationDate": "2016-01-04T12:12:05.400", "LastActivityDate": "2016-01-04T18:37:28.930", "CommentCount": "10", "Body": "<p>Let's mess around with very basic dynamically allocated memory. We take a vector of 3, set its elements and return the sum of the vector.</p>\n<p>In the first test case I used a raw pointer with <code>new[]</code>/<code>delete[]</code>. In the second I used <code>std::vector</code>:</p>\n<pre><code>#include &lt;vector&gt;   \n\nint main()\n{\n  //int *v = new int[3];        // (1)\n  auto v = std::vector&lt;int&gt;(3); // (2)\n\n\n  for (int i = 0; i &lt; 3; ++i)\n    v[i] = i + 1;\n\n  int s = 0;\n  for (int i = 0; i &lt; 3; ++i)\n    s += v[i];\n\n  //delete[] v;                 // (1)\n  return s;\n}\n</code></pre>\n<p>Assembly of (1) (<code>new[]</code>/<code>delete[]</code>)</p>\n<pre><code>main:                                   # @main\n        mov     eax, 6\n        ret\n</code></pre>\n<p>Assembly of (2) (<code>std::vector</code>)</p>\n<pre><code>main:                                   # @main\n        push    rax\n        mov     edi, 12\n        call    operator new(unsigned long)\n        mov     qword ptr [rax], 0\n        movabs  rcx, 8589934593\n        mov     qword ptr [rax], rcx\n        mov     dword ptr [rax + 8], 3\n        test    rax, rax\n        je      .LBB0_2\n        mov     rdi, rax\n        call    operator delete(void*)\n.LBB0_2:                                # %std::vector&lt;int, std::allocator&lt;int&gt; &gt;::~vector() [clone .exit]\n        mov     eax, 6\n        pop     rdx\n        ret\n</code></pre>\n<p>Both outputs taken from <a href=\"https://gcc.godbolt.org/\" rel=\"nofollow\">https://gcc.godbolt.org/</a> with <code>-std=c++14 -O3</code></p>\n<p>In both versions the returned value is computed at compile time so we see just <code>mov eax, 6; ret</code>.</p>\n<p>With the raw <code>new[]</code>/<code>delete[]</code> the dynamic allocation was completely removed. With <code>std::vector</code> however, the memory is allocated, set and freed.</p>\n<p>This happens <strong>even with an unused variable</strong> <code>auto v = std::vector&lt;int&gt;(3)</code>: call to <code>new</code>, memory is set and then call to <code>delete</code>.</p>\n<p>I realize this is most likely a near impossible answer to give, but maybe someone has some insights and some interesting answers might pop out.</p>\n<p><strong>What are the contributing factors that don't allow compiler optimizations to remove the memory allocation in the <code>std::vector</code> case, like in the raw memory allocation case?</strong></p>\n", "PostTypeId": "1", "LastEditorUserId": "1386054", "Id": "34590885", "AnswerCount": "2", "Score": "7", "OwnerUserId": "2805305", "Tags": "<c++><vector><c++14><compiler-optimization>", "FavoriteCount": "2"}, "34596711": {"Id": "34596711", "PostTypeId": "2", "Body": "<p>When using a pointer to a dynamically allocated array (directly using new[] and delete[]), the compiler optimized away the calls to <code>operator new</code> and <code>operator delete</code> even though they have observable side effects. This optimization is allowed by the C++ standard section 5.3.4 paragraph 10:</p>\n<blockquote>\n<p id=\"so_34590885_34596711_0\">An implementation is allowed to omit a call to a replaceable global\n  allocation function (18.6.1.1, 18.6.1.2). When it does so, the storage\n  is instead provided by the implementation or...</p>\n</blockquote>\n<p>I'll show the rest of the sentence, which is crucial, at the end.</p>\n<p>This optimization is relatively new because it was first allowed in C++14 (proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html\" rel=\"noreferrer\">N3664</a>). <a href=\"http://clang.llvm.org/cxx_status.html\" rel=\"noreferrer\">Clang supported it since 3.4</a>. The latest version of gcc, namely 5.3.0, doesn't take advantage of this relaxation of the as-if rule. It produces the following code:</p>\n<pre><code>main:\n        sub     rsp, 8\n        mov     edi, 12\n        call    operator new[](unsigned long)\n        mov     DWORD PTR [rax], 1\n        mov     DWORD PTR [rax+4], 2\n        mov     rdi, rax\n        mov     DWORD PTR [rax+8], 3\n        call    operator delete[](void*)\n        mov     eax, 6\n        add     rsp, 8\n        ret\n</code></pre>\n<p>MSVC 2013 also doesn't support this optimization. It produces the following code:</p>\n<pre><code>main:\n  sub         rsp,28h  \n  mov         ecx,0Ch  \n  call        operator new[] ()  \n  mov         rcx,rax  \n  mov         dword ptr [rax],1  \n  mov         dword ptr [rax+4],2  \n  mov         dword ptr [rax+8],3  \n  call        operator delete[] ()  \n  mov         eax,6  \n  add         rsp,28h  \n  ret \n</code></pre>\n<p>I currently don't have access to MSVC 2015 Update 1 and therefore I don't know whether it supports this optimization or not.</p>\n<p>Finally, here is the assembly code generated by icc 13.0.1:</p>\n<pre><code>main:\n        push      rbp                                          \n        mov       rbp, rsp                                   \n        and       rsp, -128                                    \n        sub       rsp, 128                                     \n        mov       edi, 3                                       \n        call      __intel_new_proc_init                         \n        stmxcsr   DWORD PTR [rsp]                               \n        mov       edi, 12                                 \n        or        DWORD PTR [rsp], 32832                       \n        ldmxcsr   DWORD PTR [rsp]                               \n        call      operator new[](unsigned long)\n        mov       rdi, rax                                      \n        mov       DWORD PTR [rax], 1                            \n        mov       DWORD PTR [4+rax], 2                          \n        mov       DWORD PTR [8+rax], 3                         \n        call      operator delete[](void*)\n        mov       eax, 6    \n        mov       rsp, rbp                           \n        pop       rbp                                   \n        ret                                          \n</code></pre>\n<p>Clearly, it doesn't support this optimization. I don't have access to the latest version of icc, namely 16.0.</p>\n<p>All of these code snippets have been produced with optimizations enabled.</p>\n<p>When using <code>std::vector</code>, all of these compilers didn't optimize away the allocation. When a compiler doesn't perform an optimization, it's either because it cannot for some reason or it's just not yet supported.</p>\n<blockquote>\n<p id=\"so_34590885_34596711_1\">What are the contributing factors that don't allow compiler\n  optimizations to remove the memory allocation in the std::vector case,\n  like in the raw memory allocation case?</p>\n</blockquote>\n<p>The compiler didn't perform the optimization because it's not allowed to. To see this, let's see the rest of the sentence of paragraph 10 from 5.3.4:</p>\n<blockquote>\n<p id=\"so_34590885_34596711_2\">An implementation is allowed to omit a call to a replaceable global\n  allocation function (18.6.1.1, 18.6.1.2). When it does so, the storage\n  is instead provided by the implementation or provided by extending the\n  allocation of <strong>another new-expression</strong>.</p>\n</blockquote>\n<p>What this is saying is that you can omit a call to a replaceable global allocation function only if it originated from a new-expression. A new-expression is defined in paragraph 1 of the same section.</p>\n<p>The following expression</p>\n<pre><code>new int[3]\n</code></pre>\n<p>is a new-expression and therefore the compiler is allowed to optimize away the associated allocation function call.</p>\n<p>On the other hand, the following expression:</p>\n<pre><code>::operator new(12)\n</code></pre>\n<p>is NOT a new-expression (see 5.3.4 paragraph 1). This is just a function call expression. In other words, this is treated as a typical function call. This function cannot be optimized away because its imported from another shared library (even if you linked the runtime statically, the function itself calls another imported function).</p>\n<p>The default allocator used by <code>std::vector</code> allocates memory using <code>::operator new</code> and therefore the compiler is not allowed to optimize it away.</p>\n<p>Let's test this. Here's the code:</p>\n<pre><code>int main()\n{\n  int *v =  (int*)::operator new(12);\n\n  for (int i = 0; i &lt; 3; ++i)\n    v[i] = i + 1;\n\n  int s = 0;\n  for (int i = 0; i &lt; 3; ++i)\n    s += v[i];\n\n  delete v;\n  return s;\n}\n</code></pre>\n<p>By compiling using Clang 3.7, we get the following assembly code:</p>\n<pre><code>main:                                   # @main\n        push    rax\n        mov     edi, 12\n        call    operator new(unsigned long)\n        movabs  rcx, 8589934593\n        mov     qword ptr [rax], rcx\n        mov     dword ptr [rax + 8], 3\n        test    rax, rax\n        je      .LBB0_2\n        mov     rdi, rax\n        call    operator delete(void*)\n.LBB0_2:\n        mov     eax, 6\n        pop     rdx\n        ret\n</code></pre>\n<p>This is exactly the same as assembly code generated when using <code>std::vector</code> except for <code>mov     qword ptr [rax], 0</code> which comes from the constructor of std::vector (the compiler should have removed it but failed to do so because of a flaw in its optimization algorithms).</p>\n", "Score": "13", "LastActivityDate": "2016-01-04T17:37:52.123", "CreationDate": "2016-01-04T17:37:52.123", "ParentId": "34590885", "CommentCount": "3", "OwnerUserId": "4230618"}, "34591814": {"Id": "34591814", "PostTypeId": "2", "Body": "<p>There are a few factors that may be in play.</p>\n<p>First first one is quality of implementation of the compiler, and how deeply it analyses code when inlining functions in order to optimise.   That type of analysis is complicated - particularly in association with template machinery in a C++ compiler - so potentially takes significant developer effort to implement in the compiler.  Such code will probably be quite demanding when compiling code (e.g. increasing compilation times, increasing amount of memory or other resources needed by the compiler).   The more complicated and costly it is to implement something in the compiler, the case for implementing it needs to be stronger (e.g. likely to benefit real-world developers, not likely to make said real-world developers moan about excessive compilation times, not likely to make the compiler developers moan about implementing that capability in the compiler, etc, etc).</p>\n<p>Dynamic allocation using operator <code>new</code> and deallocation using operator <code>delete</code> are part of the language.   As such, when used in the same function, the compiler can detect that, even in an early parsing stage.   Things may change if, for example, you place either the <code>new</code> or <code>delete</code> statement into a separate function.   Of if the pointer, or pointers to elements or [the list goes on] is passed to another function.    But, in your case, the analysis is pretty simple.</p>\n<p>In comparison, <code>std::vector</code> is part of the standard library.  Now, okay, it is a template, so the complete definition might be visible to the compiler (this depends on how the library is implemented, and on compiler and compilation options, but is often true in practice).   Even if the compiler has complete visibility, it will need to examine all of the operations involving the vector (construction, use of its allocator, behaviour of member functions like <code>operator[]</code>, destructor, etc etc).   Now, the definition of <code>std::vector</code> and its member functions involves a fair amount of machinery other than simple <code>new</code> and <code>delete</code>, and it would take some pretty complicated machinery - often in later phases of compilation/optimisation - to analyse what that code is doing. Refer my preceding comment about the complexity of implementing such things in a compiler.  There is probably also an argument that could be made: if someone is using <code>std::vector</code>, they are probably less fussed if the compiler does not optimise out all the machinery involved i.e. the case for accepting the complexity in implementation of the compiler needs to be stronger, and probably isn't.</p>\n<p>Obviously, the specifics of arguments like the above depend on the workings of the team who produce the compiler and library.   But, generically speaking ....</p>\n", "Score": "0", "LastActivityDate": "2016-01-04T13:01:59.913", "CreationDate": "2016-01-04T13:01:59.913", "ParentId": "34590885", "CommentCount": "0", "OwnerUserId": "4706785"}});