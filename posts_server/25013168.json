post_cb({"bq_ids": {"n4140": {"so_25013168_25013874_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 1243}}, "n3337": {"so_25013168_25013874_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 1241}}, "n4659": {"so_25013168_25013874_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 1331}}}, "25013168": {"ViewCount": "2266", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1453.html\" rel=\"noreferrer\">standard on std::reference_wrapper</a> explains that <code>std::sort</code> now accepts <code>std::reference_wrapper</code>, allowing one to pass a comparator by reference.</p>\n<p>Is there a reason <code>std::sort</code> didn't accept the comparator by reference in the first place?</p>\n", "AcceptedAnswerId": "25013874", "Title": "Why doesn't std::sort accept comparator by reference?", "CreationDate": "2014-07-29T10:29:23.650", "Id": "25013168", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-11-25T19:25:41.237", "Score": "17", "OwnerUserId": "55094", "Tags": "<c++><c++11><stl>", "AnswerCount": "2"}, "25013874": {"Id": "25013874", "PostTypeId": "2", "Body": "<p>In short, there was no need to take it by reference; it amounts to a \"by design\" decision.</p>\n<p>I believe the reasoning centres around a few fundamentals that have existed in C++ and the Standard Library for a long time;</p>\n<ul>\n<li>Value semantics</li>\n<li>Imposing as few limitations on the implementation as possible</li>\n</ul>\n<p>The value semantics can be seen pretty much everywhere. Almost all the algorithms, containers etc. expect the data contained therein to obey the normal rules of values, i.e. behave as if they were built-in type. That's one of the reasons behind the C++ type system as well, to enable user types to behave as if they where built-in types.</p>\n<p>The implementation of the algorithm(s) are free to copy the function arguments around as they require. Limiting the signature to a reference when the implementation is allowed to copy the functor around is not very useful; so just allow the copy from the outset. What this means is that the function objects shouldn't contain any state, it may not be preserved; in turn this effectively makes the functors very light and there is no reason for the reference anyway.</p>\n<blockquote>\n<p id=\"so_25013168_25013874_0\">25.1/10 <em>Algorithms library</em> (C++ draft n3797)</p>\n<p id=\"so_25013168_25013874_1\">[ Note: Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy those function objects freely. Programmers for whom object identity is important should consider using a wrapper class that points to a noncopied implementation object such as reference_wrapper (20.9.3), or some equivalent solution. \u2014end note ]</p>\n</blockquote>\n<p>A general note on API design. API design for specifications and standards, especially with templates, is a non-trivial task at the best of times. Would the committee have designed the function differently today with r-values, reference collapsing, perfect forwarding and move semantics? I don't know. In my opinion, taking the function object by value balances the issues relating to internal copies and moves, possible optimizations, and binding to temporary objects (pr-values/x-values). A \"universal reference\" here may have been better, but I get the feeling that the legacy argument would outweigh an argument in favour of the change.</p>\n", "LastEditorUserId": "3747990", "LastActivityDate": "2014-11-25T19:25:41.237", "Score": "17", "CreationDate": "2014-07-29T11:08:46.017", "ParentId": "25013168", "CommentCount": "2", "OwnerUserId": "3747990", "LastEditDate": "2014-11-25T19:25:41.237"}, "25014328": {"Id": "25014328", "PostTypeId": "2", "Body": "<p>In C++03, accepting the comparator by reference would prevent binding to a non-<code>const</code> rvalue, e.g. a function pointer expression:</p>\n<pre><code>bool comp(T const&amp;, T const&amp;);\nsort(first, last, &amp;comp);\n</code></pre>\n<p>Or a temporary functor:</p>\n<pre><code>struct Comparator { bool operator()(T const&amp;, T const&amp;) { ... } };\nsort(first, last, Comparator());\n</code></pre>\n<p>In C++11, taking the comparator by universal reference would avoid this issue, but is an unnecessary change because we have <code>reference_wrapper</code>.</p>\n", "LastActivityDate": "2014-07-29T11:34:57.720", "CommentCount": "2", "CreationDate": "2014-07-29T11:34:57.720", "ParentId": "25013168", "Score": "7", "OwnerUserId": "567292"}});