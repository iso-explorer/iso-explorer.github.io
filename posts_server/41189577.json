post_cb({"bq_ids": {"n4140": {"so_41189577_41190113_0": {"length": 36, "quality": 1.0, "section_id": 6142}, "so_41189577_41190370_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7200}, "so_41189577_41190370_0": {"length": 18, "quality": 0.9, "section_id": 5785}, "so_41189577_41190253_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 6142}}, "n3337": {"so_41189577_41190113_0": {"length": 36, "quality": 1.0, "section_id": 5906}, "so_41189577_41190370_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 6944}, "so_41189577_41190370_0": {"length": 18, "quality": 0.9, "section_id": 5558}, "so_41189577_41190253_0": {"length": 106, "quality": 0.9814814814814815, "section_id": 5906}}, "n4659": {"so_41189577_41190370_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 8709}, "so_41189577_41190370_0": {"length": 18, "quality": 0.9, "section_id": 7242}}}, "41190370": {"Id": "41190370", "PostTypeId": "2", "Body": "<p>The problem here is the <em>strict aliasing rule</em> that exists in my draft n3337 for C++11 in 3.10 Lvalues and rvalues [basic.lval] \u00a7 10. This is an exhaustive list that does not explicetely allow to alias a multidimensional array to an unidimensional one of the whole size.</p>\n<p>So even if it is indeed required that arrays are allocated consecutively in memory, which proves that the size of a multidimensional array, say for example <code>T arr[n][m]</code> is the product of is dimensions by the size of an element: <code>n * m *sizeof(T)</code>. When converted to char pointers, you can even do arithmetic pointer operations on the whole array, because any pointer to an object can be converted to a char pointer, and that char pointer can be used to access the consecutive bytes of the object (*).</p>\n<p>But unfortunately, for any other type, the standard only allow arithmetic pointer operations inside one array (and <em>by definition</em> dereferening an array element <strong>is the same</strong> as dereferencing a pointer after pointer arithmetics: <code>a[i]</code> <strong>is</strong> <code>*(a + i)</code>). So if you both respect the rule on pointer arithmetics and the strict aliasing rule, the global indexing of a multi-dimensional array is not defined by C++11 standard, unless you go through char pointer arithmetics:</p>\n<pre><code>int a[3][4];\nint *p = &amp;a[0][0]; // perfectly defined\nint b = p[3];      // ok you are in same row which means in same array\nb = p[5];          // OUPS: you dereference past the declared array that builds first row\n\nchar *cq = (((char *) p) + 5 * sizeof(int)); // ok: char pointer arithmetics inside an object\nint *q = (int *) cq; // ok because what lies there is an int object\nb = *q;            // almost the same as p[5] but behaviour is defined\n</code></pre>\n<p>That <em>char pointer arithmetics</em> along with the fear of breaking a lot of existing code explains why all well known compiler silently accept the aliasing of a multi-dimensional array with a 1D one of same global size (it leads to same internal code), but technically, the global pointer arithmetics is only valid for char pointers.</p>\n<hr>\n<p>(*) The standard declares in 1.7 The C++ memory model [intro.memory] that</p>\n<blockquote>\n<p id=\"so_41189577_41190370_0\">The fundamental storage unit in the C++ memory model is the byte... The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every\n  byte has a unique address.</p>\n</blockquote>\n<p>and later in 3.9 Types [basic.types] \u00a72</p>\n<blockquote>\n<p id=\"so_41189577_41190370_1\">For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object\n  holds a valid value of type T, the underlying bytes making up the object can be copied into an array\n  of char or unsigned char.</p>\n</blockquote>\n<p>and to copy them you must access them through a <code>char *</code> or <code>unsigned char *</code></p>\n</hr>", "LastEditorUserId": "3545273", "LastActivityDate": "2016-12-16T19:08:37.910", "Score": "6", "CreationDate": "2016-12-16T18:29:21.557", "ParentId": "41189577", "CommentCount": "12", "OwnerUserId": "3545273", "LastEditDate": "2016-12-16T19:08:37.910"}, "41190113": {"Id": "41190113", "PostTypeId": "2", "Body": "<p>if you declare</p>\n<pre><code>int  arr[3][4][5];\n</code></pre>\n<p>the type of <code>arr</code> is <code>int[3][4][5]</code>, type of <code>arr[3]</code> is <code>int[4][5]</code>, etc. Array of array  of arrays, but NOT an array of pointers. Let's see what happens if we increment first index? It would shift pointer forward by size of array element, but array element of arr is a two-dimensional array! It is equivalent to  incrementing: <code>arr + sizeof(int[4][5])/sizeof(int)</code> or arr + 20.</p>\n<p>Iterating this way we'll find that <code>arr[a][b][c]</code> equals to <code>*(*(*(arr + a) + b) + c)</code>, provided that there is never any padding with arrays (to comply with  mandatory compatibility of POD types with C99):</p>\n<pre><code>*((int*)arr + 20*a +  5*b + c)\n</code></pre>\n<blockquote>\n<p id=\"so_41189577_41190113_0\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression</p>\n</blockquote>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2016-12-17T10:39:06.893", "Score": "0", "CreationDate": "2016-12-16T18:11:17.530", "ParentId": "41189577", "CommentCount": "6", "OwnerUserId": "2742717", "LastEditDate": "2016-12-17T10:39:06.893"}, "41190253": {"Id": "41190253", "PostTypeId": "2", "Body": "<p>I believe the behavior in your example is technically undefined.</p>\n<p>The standard has no concept of a multidimensional array.  What you've actually declared is an \"array of 5 arrays of 4 ints\".  That is <code>a[0]</code> and <code>a[1]</code> are actually two different arrays of 4 ints, both of which are contained in the array <code>a</code>.  What this means is that <code>a[0][0]</code> and <code>a[1][0]</code> are not elements of the same array.</p>\n<p>[expr.add]/4 says the following (emphasis mine)</p>\n<blockquote>\n<p id=\"so_41189577_41190253_0\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. If the pointer operand points to an element of an array object, and the array is\n  large enough, the result points to an element offset from the original element such that the difference of\n  the subscripts of the resulting and original array elements equals the integral expression. In other words, if\n  the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P))\n  and (P)-N (where N has the value n) point to, respectively, the i + n-th and i \u2212 n-th elements of the array\n  object, provided they exist. Moreover, if the expression P points to the last element of an array object,\n  the expression (P)+1 points one past the last element of the array object, and if the expression Q points\n  one past the last element of an array object, the expression (Q)-1 points to the last element of the array\n  object. <strong>If both the pointer operand and the result point to elements of the same array object, or one past\n  the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is\n  undefined</strong></p>\n</blockquote>\n<p>So, since <code>p[11]</code> expands to <code>*(p + 11)</code> and since <code>p</code> and <code>p + 11</code> are not elements of the same array (one is an element of <code>a[0]</code> and the other is more than one element past the end of <code>a[0]</code>), the behavior of that addition is undefined.</p>\n<p>I would, however, be very surprised to find any implementation where such an addition resulted in anything other than the one you expect.</p>\n", "LastActivityDate": "2016-12-16T18:21:08.707", "CommentCount": "17", "CreationDate": "2016-12-16T18:21:08.707", "ParentId": "41189577", "Score": "9", "OwnerUserId": "4151599"}, "41189577": {"ViewCount": "339", "Body": "<p>As far as I know, multidimensional array on stack will occupy continuous memory in row order. Is it undefined behavior to index multidimensional array using a pointer to elements according to ISO C++ Standard? For example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nint main() {\n  int a[5][4]{{1,2,3,4},{},{5,6,7,8}};\n  constexpr auto sz = sizeof(a) / sizeof(std::remove_all_extents&lt;decltype(a)&gt;::type);\n  int *p = &amp;a[0][0];\n  int i = p[11];  // &lt;-- here\n  p[19] = 20;  // &lt;-- here\n  for (int k = 0; k &lt; sz; ++k)\n    std::cout &lt;&lt; p[k] &lt;&lt; ' ';  // &lt;-- and here\n  return 0;\n}\n</code></pre>\n<p>Above code will compile and run correctly if pointer does not go out of the boundary of array <code>a</code>. But is this happen because of compiler defined behavior or language standard? Any reference from the ISO C++ Standard would be best.</p>\n", "AcceptedAnswerId": "41190370", "Title": "Multidimensional array indexing using pointer to elements", "CreationDate": "2016-12-16T17:30:24.097", "Id": "41189577", "CommentCount": "7", "LastEditDate": "2016-12-17T05:03:11.040", "PostTypeId": "1", "LastEditorUserId": "5340808", "LastActivityDate": "2016-12-17T10:39:06.893", "Score": "12", "OwnerUserId": "5340808", "Tags": "<c++><c++11>", "AnswerCount": "3"}});