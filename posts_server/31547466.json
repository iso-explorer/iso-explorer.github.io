post_cb({"31547466": {"CommentCount": "4", "AcceptedAnswerId": "31547722", "PostTypeId": "1", "LastEditorUserId": "855050", "CreationDate": "2015-07-21T19:00:28.610", "LastActivityDate": "2015-07-29T19:01:37.770", "LastEditDate": "2015-07-21T20:26:16.953", "ViewCount": "2615", "FavoriteCount": "4", "Title": "Is `x = std::move(x)` undefined?", "Id": "31547466", "Score": "56", "Body": "<p>Let <code>x</code> be a variable of some type that has been previously initialized. Is the following line:</p>\n<pre><code>x = std::move(x)\n</code></pre>\n<p>undefined? Where is this in the standard and what does it say about it?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14>", "OwnerUserId": "855050", "AnswerCount": "3"}, "31547740": {"ParentId": "31547466", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>All that does is call <code>X::operator=(X&amp;&amp;)</code> (with an lvalue qualified \"<code>*this</code>\").</p>\n<p>On primitive types, <code>std::move</code> does little of interest, and does not interact with <code>=</code> at all.  So this only applies to objects of class type.</p>\n<p>Now, for a type within <code>std</code> (or generated by one of its templates), objects <code>move</code>d from tend to be left in an unspecified (yet valid) state.  This is not undefined behavior, but it isn't useful behavior.</p>\n<p>The semantics of a each given <code>X::operator=(X&amp;&amp;)</code> would have to be examined, examining every type within <code>std</code> would be \"too broad\" for a stack overflow answer.  They even may contradict themselves.</p>\n<p>In general, when <code>move</code>ing from an object, you are communicating to the consumer that \"you don't care what state the object is in afterwards\".  The use of a <code>x = std::move(x)</code> is thus impolite, as you (usually) <em>do</em> care what state <code>x</code> is in after the operation completes (as you are assigning to it).  You are using the same object as both an lvalue and an rvalue within the same operation, and that is not good a practice.</p>\n<p>An interesting exception is the default <code>std::swap</code>, which goes something like this:</p>\n<pre><code>template&lt;class T&gt;\nvoid swap(T&amp; lhs, T&amp; rhs) {\n  T tmp = std::move(lhs);\n  lhs = std::move(rhs);\n  rhs = std::move(tmp);\n}\n</code></pre>\n<p>the middle line, <code>lhs = std::move(rhs)</code>, does an <code>x = std::move(x)</code> if you call swap twice on the same object.</p>\n<p>Note, however, that we do not care what state <code>x</code> is in after this line is completed; we have already stored the state of <code>x</code> in <code>tmp</code>, and we will restore it on the next line.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2015-07-21T19:42:22.280", "Id": "31547740", "Score": "9", "CreationDate": "2015-07-21T19:16:57.707", "LastActivityDate": "2015-07-21T19:42:22.280"}, "31547722": {"ParentId": "31547466", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>No, this is not undefined behavior, it is going to be implementation defined behavior, it will depend on how move assignment is implemented.</p>\n<p>Relevant to this is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2468\">LWG issue 2468: Self-move-assignment of library types </a>, note this is an active issue and does not have an official proposal so this should be considered indicative rather than definitive, but it does point out the sections that are involved for the standard library and points out they currently conflict. It says:</p>\n<blockquote>\n<p id=\"so_31547466_31547722_0\">Suppose we write</p>\n<pre><code>vector&lt;string&gt; v{\"a\", \"b\", \"c\", \"d\"};\nv = move(v);\n</code></pre>\n<p id=\"so_31547466_31547722_1\">What should be the state of v be? The standard doesn't say anything\n  specific about self-move-assignment. There's relevant text in several\n  parts of the standard, and it's not clear how to reconcile them.</p>\n<p id=\"so_31547466_31547722_2\">[...]</p>\n<p id=\"so_31547466_31547722_3\">It's not clear from the text how to put these pieces together, because it's not clear which one takes precedence. Maybe 17.6.4.9 [res.on.arguments] wins (it imposes an implicit precondition that isn't mentioned in the MoveAssignable requirements, so v = move(v) is undefined), or maybe 23.2.1 [container.requirements.general] wins (it explicitly gives additional guarantees for Container::operator= beyond what's guaranteed for library functions in general, so v = move(v) is a no-op), or maybe something else.</p>\n<p id=\"so_31547466_31547722_4\">On the existing implementations that I checked, for what it's worth, v = move(v) appeared to clear the vector; it didn't leave the vector unchanged and it didn't cause a crash. </p>\n</blockquote>\n<p>and proposes:</p>\n<blockquote>\n<p id=\"so_31547466_31547722_5\">Informally: change the MoveAssignable and Container requirements tables (and any other requirements tables that mention move assignment, if any) to make it explicit that x = move(x) is defined behavior and it leaves x in a valid but unspecified state. That's probably not what the standard says today, but it's probably what we intended and it's consistent with what we've told users and with what implementations actually do. </p>\n</blockquote>\n<p>Note, for built-in types this is basically a copy, we can see from draft C++14 standard section <code>5.17</code> <em>[expr.ass]</em>:</p>\n<blockquote>\n<p id=\"so_31547466_31547722_6\">In simple assignment (=), the value of the expression replaces that of the object referred to by the left\n  operand.</p>\n</blockquote>\n<p>which is different than the case for classes, where <code>5.17</code> says:</p>\n<blockquote>\n<p id=\"so_31547466_31547722_7\">If the left operand is of class type, the class shall be complete. Assignment to objects of a class is defined\n  by the copy/move assignment operator (12.8, 13.5.3).</p>\n</blockquote>\n<p>Note, clang has a <a href=\"http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20150105/121045.html\">self move warning</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-07-29T19:01:37.770", "Id": "31547722", "Score": "51", "CreationDate": "2015-07-21T19:15:54.523", "LastActivityDate": "2015-07-29T19:01:37.770"}, "bq_ids": {"n4140": {"so_31547466_31547722_7": {"section_id": 6176, "quality": 0.8666666666666667, "length": 13}, "so_31547466_31547722_6": {"section_id": 6174, "quality": 1.0, "length": 9}}, "n3337": {"so_31547466_31547722_7": {"section_id": 5937, "quality": 0.8666666666666667, "length": 13}, "so_31547466_31547722_6": {"section_id": 5935, "quality": 1.0, "length": 9}}, "n4659": {"so_31547466_31547722_7": {"section_id": 7678, "quality": 0.8666666666666667, "length": 13}, "so_31547466_31547722_6": {"section_id": 7676, "quality": 1.0, "length": 9}}}, "31547549": {"ParentId": "31547466", "CommentCount": "1", "Body": "<p>It will call <code>X::operator = (X&amp;&amp;)</code>, so it is up to the implementation to manage this case (as it is done for <code>X::operator = (const X&amp;)</code>)</p>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "31547549", "Score": "14", "CreationDate": "2015-07-21T19:05:19.457", "LastActivityDate": "2015-07-21T19:05:19.457"}});