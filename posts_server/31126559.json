post_cb({"31128008": {"ParentId": "31126559", "PostTypeId": "2", "CommentCount": "7", "Body": "\n<p>This is not possible.</p>\n<p>When you have two candidate functions like these, the overload taking an lvalue reference to function type is <em>always</em> preferred over the rvalue reference overload. Functions are considered lvalues in all cases so the conversion to an lvalue reference is the strongest. Here is some standard wording ([over.ics.rank]/p3.2.4):</p>\n<blockquote>\n<p id=\"so_31126559_31128008_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence <code>S2</code> if</p>\n<ul>\n<li><p id=\"so_31126559_31128008_1\">S1 and S2 are reference bindings (8.5.3) and S1 binds an lvalue reference to a function lvalue and <code>S2</code> binds an rvalue reference to a function lvalue. <em>[ Example:</em></p>\n<pre class=\"lang-c++ prettyprint-override\"><code>int f(void(&amp;)()); // #1\nint f(void(&amp;&amp;)()); // #2\nvoid g();\nint i1 = f(g); // calls #1\n</code></pre></li>\n</ul>\n<p id=\"so_31126559_31128008_2\"><em>\u2014 end example]</em></p>\n</blockquote>\n<hr>\n<p>The code from my comment presented here calls overload #2 in gcc and is rejected by clang.</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>void foo(void(&amp;)(int)); // #1\nvoid foo(void(&amp;&amp;)(int)); // #2\n\nvoid f(int);\nstruct wrap {\n    using T = void(&amp;&amp;)(int);\n    operator T() { return f; }\n};\n\nint main() {\n    foo(wrap{}); // Calls #2 in gcc, error in clang\n}\n</code></pre>\n<p>The Clang error is:</p>\n<blockquote>\n<p id=\"so_31126559_31128008_3\">non-const lvalue reference to type <code>void (int)</code> cannot bind to a temporary of type <code>wrap</code></p>\n</blockquote>\n<p>GCC is obviously wrong because of the above quote, but Clang is also wrong as well. The result of the operator function is an lvalue so it should bind to the lvalue overload, but it seems that clang is not attempting the conversion. A simpler example is:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>void (&amp;r)(int) = wrap{}; // OK in gcc, error in clang\n</code></pre>\n<p>So this looks like a bug in Clang and GCC.</p>\n</hr>", "OwnerUserId": "701092", "LastEditorUserId": "701092", "LastEditDate": "2015-06-30T13:42:43.470", "Id": "31128008", "Score": "2", "CreationDate": "2015-06-30T01:13:05.960", "LastActivityDate": "2015-06-30T13:42:43.470"}, "31126559": {"CommentCount": "7", "ViewCount": "165", "PostTypeId": "1", "ClosedDate": "2015-06-30T18:43:43.220", "LastEditorUserId": "2069064", "CreationDate": "2015-06-29T22:21:41.843", "LastActivityDate": "2015-06-30T13:42:43.470", "Title": "Overloading on valueness (rvalue/lvalue) of a function type", "LastEditDate": "2015-06-29T23:27:18.310", "Id": "31126559", "Score": "-4", "Body": "<p>Is it possible to call a function which takes an rvalue reference to a function? For example:</p>\n<pre><code>#include &lt;iostream&gt;    \n\nvoid foo(void(&amp;f)(int))\n{\n    std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n}\n\nvoid foo(void(&amp;&amp;f)(int))\n{\n     std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Can I call the overload of <code>foo</code> that prints \"B\"?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1601719", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31126559_31128008_1": {"section_id": 639, "quality": 0.8571428571428571, "length": 12}, "so_31126559_31128008_0": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}, "so_31126559_31128008_3": {"section_id": 6169, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_31126559_31128008_1": {"section_id": 629, "quality": 0.8571428571428571, "length": 12}, "so_31126559_31128008_3": {"section_id": 5930, "quality": 0.5454545454545454, "length": 6}, "so_31126559_31128008_0": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_31126559_31128008_1": {"section_id": 667, "quality": 0.8571428571428571, "length": 12}, "so_31126559_31128008_0": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}}}});