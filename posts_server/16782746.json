post_cb({"bq_ids": {"n4140": {"so_16782746_16782797_0": {"section_id": 5913, "quality": 1.0, "length": 19}}, "n3337": {"so_16782746_16782797_0": {"section_id": 5685, "quality": 1.0, "length": 19}}, "n4659": {"so_16782746_16782797_0": {"section_id": 7404, "quality": 1.0, "length": 19}}}, "16782797": {"ParentId": "16782746", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It looks like <em>Martin Ankerl</em> has a few of articles on this, <a href=\"http://martin.ankerl.com/2012/01/25/optimized-approximative-pow-in-c-and-cpp/\" rel=\"nofollow noreferrer\">Optimized Approximative pow() in C / C++</a> is one and it has two fast versions, one is as follows:</p>\n<pre><code>inline double fastPow(double a, double b) {\n  union {\n    double d;\n    int x[2];\n  } u = { a };\n  u.x[1] = (int)(b * (u.x[1] - 1072632447) + 1072632447);\n  u.x[0] = 0;\n  return u.d;\n}\n</code></pre>\n<p>which relies on type punning through a union which is undefined behavior in C++, from the draft standard section <code>9.5</code> <em>[class.union]</em>:</p>\n<blockquote>\n<p id=\"so_16782746_16782797_0\">In a union, at most one of the non-static data members can be active at any time, that is, the value of at\n  most one of the non-static data members can be stored in a union at any time. [...]</p>\n</blockquote>\n<p>but most compilers including <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.7.1/gcc/Optimize-Options.html#Type_002dpunning\" rel=\"nofollow noreferrer\">gcc support this with well defined behavior</a>:</p>\n<blockquote>\n<p id=\"so_16782746_16782797_1\">The practice of reading from a different union member than the one most recently written to (called \u201ctype-punning\u201d) is common. Even with -fstrict-aliasing, type-punning is allowed, provided the memory is accessed through the union type</p>\n</blockquote>\n<p>but this is not universal as <a href=\"http://blog.regehr.org/archives/959\" rel=\"nofollow noreferrer\">this article points out</a> and as I <a href=\"https://stackoverflow.com/a/31080901/1708801\">point out in my answer here</a> using <code>memcpy</code> should generate identical code and does not invoke undefined behavior.</p>\n<p>He  also links to a second one <a href=\"http://martin.ankerl.com/2007/10/04/optimized-pow-approximation-for-java-and-c-c/\" rel=\"nofollow noreferrer\">Optimized pow() approximation for Java, C / C++, and C#</a>.</p>\n<p>The first article also links to his microbenchmarks <a href=\"http://pastebin.com/DRvPJL2K\" rel=\"nofollow noreferrer\">here</a></p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:42.083", "Id": "16782797", "Score": "14", "CreationDate": "2013-05-28T02:03:47.440", "LastActivityDate": "2015-09-07T00:18:02.510"}, "16782746": {"CommentCount": "10", "AcceptedAnswerId": "16782797", "PostTypeId": "1", "LastEditorUserId": "1760345", "CreationDate": "2013-05-28T01:55:45.037", "LastActivityDate": "2015-09-07T00:18:02.510", "LastEditDate": "2013-05-28T01:57:12.737", "ViewCount": "11624", "FavoriteCount": "4", "Title": "What is faster than std::pow?", "Id": "16782746", "Score": "17", "Body": "<p>My program spends 90% of CPU time in the <code>std::pow(double,int)</code> function. Accuracy is not a primary concern here, so I was wondering if there were any faster alternatives. One thing I was thinking of trying is casting to float, performing the operation and then back to double (haven't tried this yet); I am concerned that this is not a portable way of improving performance (don't most CPUs operate on doubles intrinsically anyway?)</p>\n<p>Cheers</p>\n", "Tags": "<c++><performance>", "OwnerUserId": "1613983", "AnswerCount": "3"}, "16782840": {"ParentId": "16782746", "CommentCount": "5", "Body": "<p>How big are your integers? Are they known at compile time? It's far better to compute <code>x^2</code> as <code>x*x</code> as opposed to <code>pow(x,2)</code>. Note: Almost all applications of <code>pow()</code> to an integer power involve raising some number to the second or third power (or the multiplicative inverse in the case of negative exponents). Using <code>pow()</code> is overkill in such cases. Use a template for these small integer powers, or just use <code>x*x</code>.</p>\n<p>If the integers are small, but not known at compile time, say between -12 and +12, multiplication will still beat <code>pow()</code> and won't lose accuracy. You don't need eleven multiplications to compute x^12. Four will do. Use the fact that x^(2n) = (x^n)^2 and x^(2n+1) = x*((x^n)^2). For example, x^12 is ((x*x*x)^2)^2. Two multiplications to compute x^3 (x*x*x), one more to compute x^6, and one final one to compute x^12.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "16782840", "Score": "4", "CreationDate": "2013-05-28T02:10:43.507", "LastActivityDate": "2013-05-28T02:10:43.507"}, "16782768": {"ParentId": "16782746", "CommentCount": "0", "Body": "<p>Depending on what you need to do, operating in the log domain might work \u2014 that is, you replace all of your values with their logarithms; multiplication becomes addition, division becomes subtraction, and exponentiation becomes multiplication. But now <em>addition and subtraction</em> become expensive and somewhat error-prone operations.</p>\n", "OwnerUserId": "152948", "PostTypeId": "2", "Id": "16782768", "Score": "9", "CreationDate": "2013-05-28T01:59:06.283", "LastActivityDate": "2013-05-28T01:59:06.283"}});