post_cb({"42388926": {"Id": "42388926", "PostTypeId": "2", "Body": "<p>Because <code>using std::swap;</code> does not mean \"henceforth, every 'swap' should use <code>std::swap</code>\", but \"bring all overloads of <code>swap</code> from <code>std</code> into the current scope\". </p>\n<p>In this case, the effect is the same as if you had written <code>using namespace std;</code> inside the function.</p>\n", "LastActivityDate": "2017-02-22T10:42:44.340", "Score": "10", "CreationDate": "2017-02-22T10:42:44.340", "ParentId": "42388431", "CommentCount": "5", "OwnerUserId": "404970"}, "42573292": {"Id": "42573292", "PostTypeId": "2", "Body": "<p>The <em>using-declaration</em> <code>using std::swap</code> does not hide the functions you have declared to swap <code>HasPtr</code> and <code>Foo</code>. It brings the name <code>swap</code> form the <code>std</code> namespace to the declarative region. With that, <code>std::swap</code> can take part in overload resolution.</p>\n<p>From the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_42388431_42573292_0\"><strong>7.3.3 The using declaration</strong></p>\n<p id=\"so_42388431_42573292_1\">1 A <em>using-declaration</em> introduces a name into the declarative region in which the using-declaration appears.</p>\n<p id=\"so_42388431_42573292_2\"><em>using-declaration:</em> </p>\n<p id=\"so_42388431_42573292_3\"><code>using typename</code><sub><em>opt</em></sub> <em>nested-name-specifier unqualified-id ;</em><br>\n<code>using ::</code> <em>unqualified-id ;</em> </br></p>\n<p id=\"so_42388431_42573292_4\">The member name specified in a <em>using-declaration</em> is declared in the declarative region in which the <em>using-declaration</em> appears. [ <em>Note:</em> Only the specified name is so declared; specifying an enumeration name in a <em>using-declaration</em> does not declare its enumerators in the <em>using-declaration</em>\u2019s declarative region. <em>\u2014end note</em> ] If a <em>using-declaration</em> names a constructor (3.4.3.1), it implicitly declares a set of constructors in the class in which the <em>using-declaration</em> appears (12.9); otherwise the name specified in a <em>using-declaration</em> is a synonym for the name of some entity declared elsewhere.</p>\n</blockquote>\n<p>In your case, you have:</p>\n<pre><code>void swap(Foo &amp;lhs, Foo &amp;rhs)\n{\n    using std::swap;\n    swap(lhs.h, rhs.h);\n}\n</code></pre>\n<p>The <code>using std::swap;</code> declaration introduces the name <code>swap</code> from the <code>std</code> namespace into the declarative region, which is the body of the <code>swap(Foo&amp;, Foo&amp;)</code> function. The name <code>swap</code> from the global namespace is still accessible in the body of the function.</p>\n<p>If what you posted is the entirety of the function, then you don't need the <code>using std::swap</code> declaration. You could get by with just:</p>\n<pre><code>void swap(Foo &amp;lhs, Foo &amp;rhs)\n{\n    swap(lhs.h, rhs.h);\n}\n</code></pre>\n<p>since <code>swap(HasPtr &amp;lhs, HasPtr &amp;rhs)</code> is visible from the function.</p>\n<p>Now, take a look at the example below.</p>\n<pre><code>struct Bar {};\n\nvoid swap(Bar&amp; lhs, Bar&amp; rhs)\n{\n}\n\nstruct Foo\n{\n   int a;\n   Bar b;\n};\n\nvoid swap(Foo&amp; lhs, Foo&amp; rhs)\n{\n   swap(lhs.a, rhs.a);  // A problem\n   swap(lhs.b, rhs.b);\n}\n</code></pre>\n<p>The line marked <code>A problem</code> is a problem since there is no function named <code>swap</code> that can work with  two objects of type<code>int&amp;</code> as argument. You can fix that using one of the following methods:</p>\n<ol>\n<li><p>Use <code>std::swap</code> explicitly.</p>\n<pre><code>void swap(Foo&amp; lhs, Foo&amp; rhs)\n{\n   std::swap(lhs.a, rhs.a);\n   swap(lhs.b, rhs.b);\n}\n</code></pre></li>\n<li><p>Introduce <code>std::swap</code> in the function.</p>\n<pre><code>void swap(Foo&amp; lhs, Foo&amp; rhs)\n{\n   using std::swap;\n   swap(lhs.a, rhs.a);\n   swap(lhs.b, rhs.b);\n}\n</code></pre></li>\n</ol>\n", "LastEditorUserId": "434551", "LastActivityDate": "2017-03-03T17:38:02.983", "Score": "6", "CreationDate": "2017-03-03T07:43:23.633", "ParentId": "42388431", "CommentCount": "7", "LastEditDate": "2017-03-03T17:38:02.983", "OwnerUserId": "434551"}, "bq_ids": {"n4140": {"so_42388431_42573292_1": {"length": 8, "quality": 1.0, "section_id": 5490}, "so_42388431_42573292_4": {"length": 38, "quality": 0.76, "section_id": 5490}}, "n3337": {"so_42388431_42573292_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 5724}, "so_42388431_42573292_1": {"length": 8, "quality": 1.0, "section_id": 5276}, "so_42388431_42573292_4": {"length": 43, "quality": 0.86, "section_id": 5276}}, "n4659": {"so_42388431_42573292_1": {"length": 7, "quality": 0.875, "section_id": 6924}}}, "42686834": {"Id": "42686834", "PostTypeId": "2", "Body": "<p>Actually, The <code>swap</code> for HasPtr is hidden while <code>using std::swap</code> in the inner scope, but in this case the <code>std::swap</code> in the inner scope is the same as the <code>swap</code> for HasPtr in the outer scope.</p>\n", "LastActivityDate": "2017-03-09T04:35:47.503", "Score": "0", "CreationDate": "2017-03-09T04:35:47.503", "ParentId": "42388431", "CommentCount": "0", "OwnerUserId": "7408377"}, "42563365": {"Id": "42563365", "PostTypeId": "2", "Body": "<p>The using declaration means to consider all of the std::swap overloads as if they were defined in the same namespace as the function. Since the using declaration appears in a function body, this only has an effect temporarily: within that scope. </p>\n<p>It is identical in effect to the following:</p>\n<pre><code>void swap(HasPtr &amp;lhs, HasPtr &amp;rhs)\n{...}\n\nvoid swap(int &amp;lhs, int &amp;rhs) { std::swap(lhs, rhs); }\nvoid swap(char &amp;lhs, char &amp;rhs) { std::swap(lhs, rhs); }\n// etc. for other std::swap overloads of common types\n\nvoid swap(Foo &amp;lhs, Foo &amp;rhs)\n{\n    swap(lhs.h, rhs.h);\n    // the other overloads of swap go out of scope here.\n}\n</code></pre>\n<p>The regular rules of overloading ensure that the first swap is the one that gets called. This is in contrast to declaring a local variable named \"swap\", which <i>would</i> hide the first overload.</p>\n", "LastActivityDate": "2017-03-02T18:40:14.803", "Score": "0", "CreationDate": "2017-03-02T18:40:14.803", "ParentId": "42388431", "CommentCount": "0", "OwnerUserId": "1612012"}, "42388431": {"ViewCount": "594", "Body": "<p>My confusion comes from \"C++ Primer 5th edition\" section 13.3, page 518.</p>\n<blockquote>\n<p id=\"so_42388431_42388431_0\">Very careful readers may wonder why the <code>using</code> declaration inside <code>swap</code> does not hide the declarations for the <code>HasPtr</code> version of <code>swap</code>.</p>\n</blockquote>\n<p>I tried to read its reference but still did not understand why. Could anyone explain it a little bit please? Thanks. Here is the code sample of the question.</p>\n<p>Assume class <code>Foo</code> has a member named <code>h</code>, which has type <code>HasPtr</code>.</p>\n<pre><code>void swap(HasPtr &amp;lhs, HasPtr &amp;rhs)\n{...}\n\nvoid swap(Foo &amp;lhs, Foo &amp;rhs)\n{\n    using std::swap;\n    swap(lhs.h, rhs.h);\n}\n</code></pre>\n<p>Why <code>swap</code> for <code>HasPtr</code> is not hidden which seems to be declared in outer scope while <code>using std::swap</code> is in the inner scope? Thanks.</p>\n", "Title": "Function hiding and using-declaration in C++", "CreationDate": "2017-02-22T10:05:47.347", "LastActivityDate": "2017-03-09T18:52:36.647", "CommentCount": "1", "PostTypeId": "1", "Id": "42388431", "Score": "14", "OwnerUserId": "1311827", "Tags": "<c++><scope><namespaces>", "AnswerCount": "5"}, "42389196": {"Id": "42389196", "PostTypeId": "2", "Body": "<p>Effective C++ Third Edition by Scott Meyers (Item 24)</p>\n<blockquote>\n<p id=\"so_42388431_42389196_0\">When compilers see the call to swap, they search for the right swap to\n  invoke. C++\u2019s name lookup rules ensure that this will find any\n  T-specific swap at global scope or in the same namespace as the type\n  T.</p>\n</blockquote>\n<p>In this case and in the second block of code, compilers look for a HasPtr swap and if they don't find it they fall back on the general version in std.</p>\n", "LastActivityDate": "2017-02-22T10:53:58.700", "Score": "0", "CreationDate": "2017-02-22T10:53:58.700", "ParentId": "42388431", "CommentCount": "0", "OwnerUserId": "7240762"}});