post_cb({"bq_ids": {"n4140": {"so_42459750_42497336_3": {"length": 9, "quality": 0.9, "section_id": 5943}, "so_42459750_42497336_11": {"length": 13, "quality": 0.9285714285714286, "section_id": 5943}, "so_42459750_42497384_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5943}, "so_42459750_42497336_2": {"length": 15, "quality": 0.9375, "section_id": 5943}, "so_42459750_42497336_8": {"length": 23, "quality": 0.9583333333333334, "section_id": 5943}, "so_42459750_42497336_6": {"length": 11, "quality": 0.8461538461538461, "section_id": 5943}, "so_42459750_42497336_5": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_42459750_42497336_1": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_42459750_42497336_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5341}, "so_42459750_42497336_4": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_42459750_42497336_9": {"length": 23, "quality": 0.9583333333333334, "section_id": 5943}, "so_42459750_42497336_7": {"length": 8, "quality": 0.8888888888888888, "section_id": 5943}, "so_42459750_42497336_10": {"length": 25, "quality": 0.9615384615384616, "section_id": 5943}}, "n3337": {"so_42459750_42497336_3": {"length": 9, "quality": 0.9, "section_id": 5714}, "so_42459750_42497336_11": {"length": 13, "quality": 0.9285714285714286, "section_id": 5714}, "so_42459750_42497384_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5714}, "so_42459750_42497336_5": {"length": 7, "quality": 0.875, "section_id": 5714}, "so_42459750_42497336_7": {"length": 8, "quality": 0.8888888888888888, "section_id": 5714}, "so_42459750_42497336_6": {"length": 11, "quality": 0.8461538461538461, "section_id": 5714}, "so_42459750_42497336_2": {"length": 15, "quality": 0.9375, "section_id": 5714}, "so_42459750_42497336_1": {"length": 7, "quality": 0.875, "section_id": 5714}, "so_42459750_42497336_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5138}, "so_42459750_42497336_4": {"length": 7, "quality": 0.875, "section_id": 5714}, "so_42459750_42497336_9": {"length": 23, "quality": 0.9583333333333334, "section_id": 5714}, "so_42459750_42497336_8": {"length": 23, "quality": 0.9583333333333334, "section_id": 5714}, "so_42459750_42497336_10": {"length": 25, "quality": 0.9615384615384616, "section_id": 5714}}, "n4659": {"so_42459750_42497336_3": {"length": 9, "quality": 0.9, "section_id": 7428}, "so_42459750_42497336_11": {"length": 13, "quality": 0.9285714285714286, "section_id": 7428}, "so_42459750_42497384_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 7428}, "so_42459750_42497336_5": {"length": 7, "quality": 0.875, "section_id": 7428}, "so_42459750_42497336_8": {"length": 23, "quality": 0.9583333333333334, "section_id": 7428}, "so_42459750_42497336_6": {"length": 11, "quality": 0.8461538461538461, "section_id": 7428}, "so_42459750_42497336_2": {"length": 15, "quality": 0.9375, "section_id": 7428}, "so_42459750_42497336_1": {"length": 7, "quality": 0.875, "section_id": 7428}, "so_42459750_42497336_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6762}, "so_42459750_42497336_4": {"length": 7, "quality": 0.875, "section_id": 7428}, "so_42459750_42497336_9": {"length": 23, "quality": 0.9583333333333334, "section_id": 7428}, "so_42459750_42497336_7": {"length": 8, "quality": 0.8888888888888888, "section_id": 7428}, "so_42459750_42497336_10": {"length": 25, "quality": 0.9615384615384616, "section_id": 7428}}}, "42497384": {"Id": "42497384", "PostTypeId": "2", "Body": "<p>That standard rules that come into play are:</p>\n<ol>\n<li><p>The guaranteed minimum ranges of the various integer types, specifically signed int and unsigned long.  In this case, the actual ranges depend on the compilers and the platform being targeted.  MSVC targeting x86 is going to give \n[-2^31..2^31) for signed int and [0..2^32) for unsigned long.  gcc and clang targeting a 64-bit platform other than Windows is going to give the same range for signed int, but [0..2^64) for unsigned long.</p></li>\n<li><p>The fact that signed integer overflow invokes undefined behavior [Section 3.9.1, paragraph 4].  Compilers are allowed to regroup operations according to the ordinary commutative and associative rules if the regrouping doesn't affect the result.  [Section 1.9]  Given that the result can be anything once you incur signed integer overflow, this bar may be lower than you realize.</p></li>\n<li><p>The \"usual arithmetic conversions,\" specifically:</p></li>\n</ol>\n<blockquote>\n<p id=\"so_42459750_42497384_0\">[I]f the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type shall be converted to the type of the operand with unsigned integer type. [Section 5.]</p>\n</blockquote>\n<p>So given your example:</p>\n<pre><code>unsigned long b = 35000000;\nunsigned long n = ( 100 * 30000000 ) / b;\n</code></pre>\n<p>In the subexpression <code>100 * 30000000</code>, both operands are <code>signed int</code>.  When you multiply 30 million by 100, you get 3 billion.  That's an overflow for signed 32-bit ints, so you've invoked undefined behavior.</p>\n<p>The obvious thing, which is apparently what MSVC does, is to just treat the 32-bit pattern as two's-complement, yielding -1294967296.  So now we have <code>-1294967296 / 35000000ul</code>.  The usual arithmetic conversion rule tells us to convert the signed int into an unsigned long.  With MSVC, this gives back the 3 billion, and the integral division results in the expected 85.</p>\n<p>A few things are different with gcc or clang.  First, your probably targeting a 64-bit non-Windows platform, which means unsigned longs are 64 bits wide rather than 32.  Second, those compilers might be more aggressive about optimizations (like constant folding) by relying on the \"legal fiction\" that there won't be any signed integer overflows.  Third, whatever the result of the overflow will now be converted to a wider unsigned type before the division.</p>\n", "LastActivityDate": "2017-02-27T23:02:22.697", "CommentCount": "0", "CreationDate": "2017-02-27T23:02:22.697", "ParentId": "42459750", "Score": "4", "OwnerUserId": "1386054"}, "42497336": {"Id": "42497336", "PostTypeId": "2", "Body": "<p>The rule for determining the type of an integer literal is, from <a href=\"http://eel.is/c++draft/lex.icon#2\" rel=\"noreferrer\">[lex.icon]</a>:</p>\n<blockquote>\n<p id=\"so_42459750_42497336_0\">The type of an integer literal is the first of the corresponding list in Table 7 in which its value can be represented.</p>\n</blockquote>\n<p>Where, with no suffix, the list of types is <code>int</code> then <code>long int</code> then <code>long long int</code>. After that, when we do math, the rule is always \"the usual arithmetic conversions,\", which are enumerated in <a href=\"http://eel.is/c++draft/expr#11\" rel=\"noreferrer\">[expr]</a>:</p>\n<blockquote>\n<p id=\"so_42459750_42497336_1\">This pattern is called the usual arithmetic conversions, which are defined as follows:</p>\n<p id=\"so_42459750_42497336_2\">(11.1)\n  If either operand is of scoped enumeration type, no conversions are performed; if the other operand does not have the same type, the expression is ill-formed.</p>\n<p id=\"so_42459750_42497336_3\">(11.2)\n  If either operand is of type long double, the other shall be converted to long double.</p>\n<p id=\"so_42459750_42497336_4\">(11.3)\n  Otherwise, if either operand is double, the other shall be converted to double.</p>\n<p id=\"so_42459750_42497336_5\">(11.4)\n  Otherwise, if either operand is float, the other shall be converted to float.</p>\n<p id=\"so_42459750_42497336_6\">(11.5)\n  Otherwise, the integral promotions shall be performed on both operands.63 Then the following rules shall be applied to the promoted operands:</p>\n<p id=\"so_42459750_42497336_7\">(11.5.1)\n  If both operands have the same type, no further conversion is needed.</p>\n<p id=\"so_42459750_42497336_8\">(11.5.2)\n  Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank shall be converted to the type of the operand with greater rank.</p>\n<p id=\"so_42459750_42497336_9\">(11.5.3)\n  Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the rank of the type of the other operand, the operand with signed integer type shall be converted to the type of the operand with unsigned integer type.</p>\n<p id=\"so_42459750_42497336_10\">(11.5.4)\n  Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, the operand with unsigned integer type shall be converted to the type of the operand with signed integer type.</p>\n<p id=\"so_42459750_42497336_11\">(11.5.5)\n  Otherwise, both operands shall be converted to the unsigned integer type corresponding to the type of the operand with signed integer type.</p>\n</blockquote>\n<hr/>\n<p>Let's go through your examples:</p>\n<pre><code>int b = 35000000;\nunsigned long a = 30000000;\nunsigned long n = ( 100 * a ) / b;\n</code></pre>\n<p>This is fine because the type of <code>100 * a</code> is an <code>unsigned long</code> (because of 11.5.3), which is wide enough to hold that result.</p>\n<p>The rest don't work because the multiplication yields a type <code>int</code>. Two <code>int</code>s multiplied together yields an <code>int</code> (because of 11.5.1), and in the first case we explicitly declare <code>a</code> to be <code>int</code> and in the rest of the cases the literal <code>30000000</code> has type <code>int</code> (because it is small enough to be represented by <code>int</code>)</p>\n<p>Note that in this last example:</p>\n<pre><code>unsigned long b= 35000000;\nunsigned long n = ( 100 * 30000000 ) / b;\n</code></pre>\n<p>It doesn't matter that <code>b</code> or <code>n</code> are declared <code>unsigned long</code>, the expression <code>(100 * 30000000)</code> is still two <code>int</code>s multiplied together, and so has type <code>int</code>, regardless of representation. Both gcc and clang warn about this overflow. </p>\n<p>To fix it, you can always add suffixes to your literals. In this case, either <code>100u</code> or <code>30000000u</code> would do the trick. This makes the literal of type <code>unsigned int</code> (per [lex.icon]), which makes the type of the multiplication <code>unsigned int</code> (per [expr]/11.5.3), which would not overflow. </p>\n", "LastActivityDate": "2017-02-27T22:58:38.210", "CommentCount": "0", "CreationDate": "2017-02-27T22:58:38.210", "ParentId": "42459750", "Score": "6", "OwnerUserId": "2069064"}, "42459750": {"ViewCount": "146", "Body": "<p>I had some code which I did a long time ago (I was using visual studio 2003 back then). Now I'm using gcc and some values are overflowing, I took a look at what was happening and it kind of surprises me.</p>\n<p>Let me show what is going on:</p>\n<p>Works (Output = 85):</p>\n<pre><code>int b = 35000000;\nunsigned long a = 30000000;\nunsigned long n = ( 100 * a ) / b;\n</code></pre>\n<p>Doesn't works (Overflow):</p>\n<pre><code>int b = 35000000;\nint a = 30000000;\nunsigned long n = ( 100 * a ) / b;\n</code></pre>\n<p>Doesn't works (Overflow):</p>\n<pre><code>int b = 35000000;\nunsigned long n = ( 100 * 30000000 ) / b;\n</code></pre>\n<p>This should all be correct. Now what bugs me is that:</p>\n<pre><code>unsigned long b= 35000000;\nunsigned long n = ( 100 * 30000000 ) / b;\n</code></pre>\n<p>Used to work! Now it doesn't.</p>\n<p>Well, actually it still works with microsoft compilers, but it doesn't work with clang and gcc. Go ahead and compile it with different compilers if you'd like: <a href=\"http://rextester.com/BZU89042\" rel=\"nofollow noreferrer\">http://rextester.com/BZU89042</a> </p>\n<ul>\n<li><code>Output = 85</code> - Microsoft (R) C/C++ Optimizing Compiler Version 19.00.23506 for x86</li>\n<li><code>Output = 527049830640</code> - g++  5.4.0</li>\n<li><code>Output = 527049830640</code> - clang 3.8.0</li>\n</ul>\n<p>What is the standard C++ rule about these?</p>\n", "AcceptedAnswerId": "42497336", "Title": "What is the standard rule on arithmetic operations when storing temporary values to a certain data type?", "CreationDate": "2017-02-25T18:09:26.433", "Id": "42459750", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-02-27T22:59:14.900", "LastEditorUserId": "2069064", "LastActivityDate": "2017-02-27T23:02:22.697", "Score": "3", "OwnerUserId": "1513286", "Tags": "<c++><language-lawyer><standards><compiler-warnings><integer-overflow>", "AnswerCount": "2"}});