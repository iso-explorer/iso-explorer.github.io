post_cb({"33642597": {"ParentId": "33642579", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes you can. You should <a href=\"https://stackoverflow.com/a/33642598/4143855\">prefer this answer</a> by @ApproachingDarknessFish for using <code>std::vector::data</code> which was introduced in C++11.</p>\n<p>However, if you are using an older version of C++ you can just use <code>&amp;foo[0]</code> to get an <code>int*</code> to the start of the container.</p>\n<p>See <a href=\"https://stackoverflow.com/questions/10740094/stdvector-vec-data-or-vec0\">this question</a> for why <code>std::vector::data</code> is preferred over <code>&amp;foo.front()</code> and <code>&amp;foo[0]</code> (both which will produce undefined behaviour if <code>foo</code> is empty!)</p>\n<p>Have a look at this <a href=\"https://stackoverflow.com/questions/849168/are-stdvector-elements-guaranteed-to-be-contiguous\">this answer</a> regarding the contiguous layout of <code>std::vector</code> memory which references the standard:</p>\n<blockquote>\n<p id=\"so_33642579_33642597_0\"><strong>23.2.6 Class template vector [vector]</strong></p>\n<p id=\"so_33642579_33642597_1\">1 A vector is a sequence container that supports random access iterators. In addition, it supports (amortized) constant time insert and erase operations at the end; insert and erase in the middle take linear time. Storage management is handled automatically, though hints can be given to improve efficiency. The elements of a vector are stored contiguously, meaning that if v is a vector where T is some type other than bool, then it obeys the identity &amp;v[n] == &amp;v[0] + n for all 0 &lt;= n &lt; v.size().</p>\n</blockquote>\n", "OwnerUserId": "4143855", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:02.660", "Id": "33642597", "Score": "3", "CreationDate": "2015-11-11T01:06:12.440", "LastActivityDate": "2015-11-11T01:15:14.123"}, "33642598": {"ParentId": "33642579", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can't cast the vector directly to an array because the vector object consists of pointers to the array data, not the array data itself, which is dynamically allocated. To access the underlying array, use the <code>data()</code> member function:</p>\n<pre><code>std::vector&lt;int&gt; vec;\n\nint *arr = vec.data();\n</code></pre>\n<p>Or</p>\n<pre><code>std::vector&lt;int&gt; *vecp = new std::vector&lt;int&gt;;\n\nint *arr = vecp-&gt;data();\n</code></pre>\n", "OwnerUserId": "1530508", "LastEditorUserId": "1530508", "LastEditDate": "2017-01-26T20:51:52.613", "Id": "33642598", "Score": "9", "CreationDate": "2015-11-11T01:06:27.330", "LastActivityDate": "2017-01-26T20:51:52.613"}, "bq_ids": {"n4140": {"so_33642579_33642597_1": {"section_id": 955, "quality": 0.96, "length": 48}}, "n3337": {"so_33642579_33642597_1": {"section_id": 943, "quality": 0.96, "length": 48}}, "n4659": {"so_33642579_33642597_1": {"section_id": 1016, "quality": 0.54, "length": 27}}}, "33642579": {"CommentCount": "0", "ViewCount": "1015", "PostTypeId": "1", "ClosedDate": "2015-11-11T01:15:16.107", "LastEditorUserId": "2092686", "CreationDate": "2015-11-11T01:04:51.187", "LastActivityDate": "2017-01-26T20:51:52.613", "Title": "Can I cast std::vector<int>* to int*?", "AcceptedAnswerId": "33642598", "LastEditDate": "2015-11-11T01:07:25.757", "Id": "33642579", "Score": "2", "Body": "<p>Let's say I have a <code>std::vector&lt;int&gt;* foo;</code> and I have to use it as <code>int*</code> (array of int, not pointer to an int) for an old C type library PVM. As far as I am concerned this might work since the <code>vector</code> stores it's elements next to each other in memory just like arrays. So I tried <code>(int*)foo</code>, but somehow I get an error which I'm unable to debug, so I think this must be the problem. Any ideas, thoughts, elegant workarounds?</p>\n", "Tags": "<c++><arrays><vector><pvm>", "OwnerUserId": "2092686", "AnswerCount": "2"}});