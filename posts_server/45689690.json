post_cb({"45691283": {"ParentId": "45689690", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>According to C++14 [expr.delete]/7:</p>\n<blockquote>\n<p id=\"so_45689690_45691283_0\">If the value of the operand of the delete-expression is not a null pointer value, then:</p>\n<ul>\n<li>[ ...omitted... ]</li>\n</ul>\n<p id=\"so_45689690_45691283_1\">Otherwise, it is unspecified whether the deallocation function will be called.</p>\n</blockquote>\n<p>So both compilers do comply with the standard, because it's unspecified whether <code>operator delete</code> is called for deletion of a null pointer.</p>\n<p>Note that the godbolt online compiler just compiles the source file without linking. So the compiler at that stage must allow for the possibility that <code>operator delete</code> will be replaced by another source file.</p>\n<p>As already speculated in another answer -- gcc may be angling for consistent behaviour in the case of a replacement <code>operator delete</code>; this implementation would mean that someone can overload that function for debug purposes and break on all invocations of the <code>delete</code> expression, even when it happened to be deleting a null pointer.</p>\n<p>UPDATED: Removed speculation that this might not be a practical issue, since OP provided benchmarks showing that it in fact is.</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2017-08-16T22:16:20.073", "Id": "45691283", "Score": "30", "CreationDate": "2017-08-15T10:43:51.527", "LastActivityDate": "2017-08-16T22:16:20.073"}, "45689690": {"CommentCount": "10", "ViewCount": "5173", "PostTypeId": "1", "LastEditorUserId": "531762", "CreationDate": "2017-08-15T09:01:51.163", "LastActivityDate": "2017-08-16T22:16:20.073", "Title": "Why doesn't GCC optimize out deletion of null pointers in C++?", "FavoriteCount": "7", "LastEditDate": "2017-08-15T23:28:07.147", "Id": "45689690", "Score": "45", "Body": "<p>Consider a simple program: </p>\n<pre><code>int main() {\n  int* ptr = nullptr;\n  delete ptr;\n}\n</code></pre>\n<p>With GCC (7.2), there is a <code>call</code> instruction regarding to <code>operator delete</code> in the resulting program. With Clang and Intel compilers, there are no such instructions, the null pointer deletion is completely optimized out (<code>-O2</code> in all cases). You can test here: <a href=\"https://godbolt.org/g/JmdoJi\" rel=\"noreferrer\">https://godbolt.org/g/JmdoJi</a>.</p>\n<p>I wonder whether such an optimization can be somehow turned on with GCC? (My broader motivation stems from a problem of custom <code>swap</code> vs <code>std::swap</code> for movable types, where deletion of null pointers can represent a performance penalty in the second case; see <a href=\"https://stackoverflow.com/a/45689282/580083\">https://stackoverflow.com/a/45689282/580083</a> for details.)</p>\n<p><strong>UPDATE</strong></p>\n<p>To clarify my motivation for the question: If I use just <code>delete ptr;</code> without <code>if (ptr)</code> guard in a <em>move assignment operator</em> and a <em>destructor</em> of some class, then <code>std::swap</code> with objects of that class yields 3 <code>call</code> instructions with GCC. This might be a considerable performance penalty, e.g., when sorting an array of such objects.</p>\n<p>Moreover, I can write <code>if (ptr) delete ptr;</code> everywhere, but wonder, whether this cannot be a performance penalty as well, since <code>delete</code> expression needs to check <code>ptr</code> as well. But, here, I guess, compilers will generate a single check only.</p>\n<p>Also, I really like the possibility to call <code>delete</code> without the guard and it was a surprise for me, that it could yield different (performance) outcomes.</p>\n<p><strong>UPDATE</strong></p>\n<p>I just did a simple benchmark, namely sorting objects, which invoke <code>delete</code> in their move assignment operator and destructor. The source is here: <a href=\"https://godbolt.org/g/7zGUvo\" rel=\"noreferrer\">https://godbolt.org/g/7zGUvo</a></p>\n<p>Running times of <code>std::sort</code> measured with GCC 7.1 and <code>-O2</code> flag on Xeon E2680v3:</p>\n<p><strong>There is a bug in the linked code, it compares pointers, not pointed values. Corrected results are as follows:</strong></p>\n<ol>\n<li>without <code>if</code> guard: <s>17.6 [s]</s> <strong>40.8 [s]</strong>,</li>\n<li>with <code>if</code> guard: <s>10.6 [s]</s> <strong>31.5 [s]</strong>,</li>\n<li>with <code>if</code> guard and custom <code>swap</code>: <s>10.4 [s]</s> 31.3 [s].</li>\n</ol>\n<p>These results were absolutely consistent across many runs with minimal deviation.  The performance difference between first two cases is significant and I wouldn't say that this is some \"exceedingly rare corner case\" like code.</p>\n", "Tags": "<c++><gcc><null><compiler-optimization><delete-operator>", "OwnerUserId": "580083", "AnswerCount": "6"}, "45690345": {"ParentId": "45689690", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Standard actually states when  allocation and deallocation functions shall be called and where they not. This clause (@ n4296)</p>\n<blockquote>\n<p id=\"so_45689690_45690345_0\">The library provides default definitions for the global allocation and\n  deallocation functions. Some global allocation and deallocation\n  functions are replaceable (18.6.1). A C++ program shall provide at\n  most one definition of a replaceable allocation or deallocation\n  function. Any such function definition replaces the default version\n  provided in the library (17.6.4.6). The following allocation and\n  deallocation functions (18.6) are implicitly declared in global scope\n  in each translation unit of a program.</p>\n</blockquote>\n<p>probably would be main reason why those function calls aren't omitted arbitrary. If they were, the replacement of their implementation of library would cause incoherent function of compiled program.</p>\n<blockquote>\n<p id=\"so_45689690_45690345_1\">In the first alternative (delete object), the value of the operand of\n  delete may be a null pointer value, a pointer to a non-array object\n  created by a previous new-expression, or a pointer to a subobject\n  (1.8) representing a base class of such an object (Clause 10). If not,\n  the behavior is undefined.</p>\n<p id=\"so_45689690_45690345_2\">If the argument given to a deallocation function in the standard\n  library is a pointer that is not the null pointer value (4.10), the\n  deallocation function shall deallocate the storage referenced by the\n  pointer, rendering invalid all pointers referring to any part of the\n  deallocated storage. Indirection through an invalid pointer value and\n  passing an invalid pointer value to a deallocation function have\n  undefined behavior. Any other use of an invalid pointer value has\n  implementation-defined behavior.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_45689690_45690345_3\">If the value of the operand of the delete-expression is not a null\n  pointer value, then</p>\n<ul>\n<li><p id=\"so_45689690_45690345_4\">If the allocation call for the new-expression for the object to be deleted was not omitted and the allocation was not extended (5.3.4),\n  the delete-expression shall call a deallocation function (3.7.4.2).\n  The value returned from the allocation call of the new-expression\n  shall be passed as the first argument to the deallocation function.</p></li>\n<li><p id=\"so_45689690_45690345_5\">Otherwise, if the allocation was extended or was provided by extending the allocation of another newexpression, and the delete-expression for every other pointer value produced by a new-expression that had storage provided by the extended new-expression has been evaluated, the delete-expression shall call a\n  deallocation function. The value returned from the allocation call of\n  the extended new-expression shall be passed as the first argument to\n  the deallocation function.</p>\n<ul>\n<li>Otherwise, the delete-expression will not call a deallocation function</li>\n</ul></li>\n</ul>\n<p id=\"so_45689690_45690345_6\">Otherwise, it is unspecified whether the deallocation function will be called.</p>\n</blockquote>\n<p>Standard states what should be done if  pointer is NOT null. Implying that delete in that case is noop, but to what end, is not specified.</p>\n", "OwnerUserId": "2742717", "LastEditorUserId": "2742717", "LastEditDate": "2017-08-15T11:33:19.650", "Id": "45690345", "Score": "7", "CreationDate": "2017-08-15T09:41:18.510", "LastActivityDate": "2017-08-15T11:33:19.650"}, "45690111": {"ParentId": "45689690", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>I think, the compiler has no knowledge about \"delete\", especially that \"delete null\" is a NOOP. </p>\n<p>You may write it explicit, so the compiler does not need to imply knowledge about delete.</p>\n<p>WARNING: I do not recommend this as general implementation. The following example should show, how you could \"convince\" a limited compiler to remove code anyway in that very special and limited program</p>\n<pre><code>int main() {\n int* ptr = nullptr;\n\n if (ptr != nullptr) {\n    delete ptr;\n }\n}\n</code></pre>\n<p>Where I remember right, there is a way to replace \"delete\" with an own function. And in the case an optimization by the compiler would went wrong.</p>\n<hr>\n<p>@RichardHodges: Why should it be an de-optimization when one give the compiler the hint to remove a call?</p>\n<p>delete null is in general a NOOP (no operation). However, since it is possible to replace or overwrite delete there is no garanty for all cases.</p>\n<p>So it is up to the compiler to know and to decide whether to use the knowledge that delete null could always removed. there are good arguments for both choises</p>\n<p>However, the compiler is always allowed to remove dead code, this \"if (false) {...}\" or \"if (nullptr != nullptr) {...}\"</p>\n<p>So a compiler will remove dead code and then when using explicit checking, it looks like</p>\n<pre><code>int main() {\n int* ptr = nullptr;\n\n // dead code    if (ptr != nullptr) {\n //        delete ptr;\n //     }\n}\n</code></pre>\n<p>Please tell me, where is there a de-optimization?</p>\n<p>I call my proposal a defensive style of coding, but not a de-optimization </p>\n<p>If someone may argue, that now the non-nullptr will causes two-times checking on nullptr, I have to reply</p>\n<ol>\n<li>Sorry, this wasn't the original question</li>\n<li>if the compiler knows about delete, especially that delete null is a noop, than the compiler could remove the outer if either. However, I would not expect compilers to be so specific</li>\n</ol>\n<hr>\n<p>@Peter Cordes: I agree guarding with an if is not an general optimization rule. However, general optimization was NOT the question of the opener. The question was why some compiler do not elimate the delete in a very short, non-sense program. I showed a way to make the compiler to eliminate it anyway.</p>\n<p>If a situation happen like in that short program, probably something other is wrong. In general I would try to avoid new/delete (malloc/free) as the calls are rather expensive. If possible I prefer to use the stack (auto).</p>\n<p>When I take a look at the meanwhile documented real case, I would say, class X is designed wrong, causing poor performance and too much memory.\n(<a href=\"https://godbolt.org/g/7zGUvo\" rel=\"nofollow noreferrer\">https://godbolt.org/g/7zGUvo</a>)</p>\n<p>Instead of </p>\n<pre><code>class X {\n  int* i_;\n  public:\n  ...\n</code></pre>\n<p>in would design</p>\n<pre><code>class X {\n  int i;\n  bool valid;\n  public:\n  ...\n</code></pre>\n<p>or more earlier, I would ask of the sense of sorting empty/invalid items. In the end I would like to get rid of \"valid\", too.</p>\n</hr></hr>", "OwnerUserId": "732454", "LastEditorUserId": "732454", "LastEditDate": "2017-08-15T19:21:06.163", "Id": "45690111", "Score": "2", "CreationDate": "2017-08-15T09:26:57.823", "LastActivityDate": "2017-08-15T19:21:06.163"}, "45694526": {"ParentId": "45689690", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First of all, I'll just agree with some previous answerers in that it's not a bug, and GCC may do as it pleases here. That said, I was wondering whether this means that some common and simple RAII code may be slower on GCC than Clang because a straightforward optimization is not done.</p>\n<p>So I wrote a small test case for RAII:</p>\n<pre><code>struct A\n{\n    explicit A() : ptr(nullptr) {}\n    A(A &amp;&amp;from)\n        : ptr(from.ptr)\n    {\n        from.ptr = nullptr;\n    }\n\n    A &amp;operator =(A &amp;&amp;from)\n    {\n        if ( &amp;from != this )\n        {\n            delete ptr;\n            ptr = from.ptr;\n            from.ptr = nullptr;\n        }\n        return *this;\n    }\n\n    int *ptr;\n};\n\nA a1;\n\nA getA2();\n\nvoid setA1()\n{\n    a1 = getA2();\n}\n</code></pre>\n<p>As you may see <a href=\"https://godbolt.org/g/pUyFss\" rel=\"nofollow noreferrer\">here</a>, GCC <em>does</em> elide the second call to <code>delete</code> in <code>setA1</code> (for the moved-from temporary that was created in the call to <code>getA2</code>). The first call is necessary for program correctness because <code>a1</code> or <code>a1.ptr</code> may have been previously assigned to.</p>\n<p>Obviously I would prefer more \"rhyme and reason\" \u2013 why is the optimization done sometimes but not always \u2013 but I'm not willing to sprinkle redundant <code>if ( ptr != nullptr )</code> checks all over my RAII code just yet.</p>\n", "OwnerUserId": "4083309", "LastEditorUserId": "4083309", "LastEditDate": "2017-08-15T16:05:38.763", "Id": "45694526", "Score": "2", "CreationDate": "2017-08-15T14:04:32.840", "LastActivityDate": "2017-08-15T16:05:38.763"}, "45693275": {"ParentId": "45689690", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's always safe (for correctness) to let your program call <code>operator delete</code> with a nullptr.</p>\n<p>For performance, it's very rare that having the compiler-generated asm actually do an extra test and conditional branch to skip a call to <code>operator delete</code> will be a win.  (You can help gcc optimize away compile-time <code>nullptr</code> deletion without adding a runtime check, though; see below).</p>\n<p>First of all, larger code-size outside of a real hot-spot increases pressure on the L1I cache, and the even smaller decoded-uop cache on x86 CPUs that have one (Intel SnB-family, AMD Ryzen).</p>\n<p>Second, extra conditional branches use up entries in the branch-prediction caches (BTB = Branch Target Buffer and so on).  Depending on the CPU, even a branch that's never taken may worsen predictions for other branches if it aliases them in the BTB.  (On others, such a branch never gets an entry in the BTB, to save entries for branches where the default static prediction of fall-through is accurate.)  See <a href=\"https://xania.org/201602/bpu-part-one\" rel=\"nofollow noreferrer\">https://xania.org/201602/bpu-part-one</a>.</p>\n<p>If <code>nullptr</code> is rare in a given code path, then on average checking &amp; branch to avoid the <code>call</code> ends up with your program spending more time on the check than the check saves.</p>\n<p>If profiling shows you have a hot-spot that includes a <code>delete</code>, and instrumentation / logging shows that it often actually calls <code>delete</code> with a nullptr, then it's worth trying<br>\n<code>if (ptr) delete ptr;</code> instead of just <code>delete ptr;</code></br></p>\n<p>Branch prediction might have better luck in that one call site than for the branch inside <code>operator delete</code>, especially if there's any correlation with other nearby branches.  (Apparently modern BPUs don't just look at each branch in isolation.)  This is on top of saving the unconditional <code>call</code> into the library function (plus another <code>jmp</code> from the PLT stub, from dynamic linking overhead on Unix/Linux).</p>\n<hr>\n<p>If you are checking for null for any other reason, then it could make sense to put the <code>delete</code> inside the non-null branch of your code.</p>\n<p><strong>You can avoid <code>delete</code> calls in cases where gcc can prove (after inlining) that a pointer is null, but without doing a runtime check if not</strong>:</p>\n<pre><code>static inline bool \nis_compiletime_null(const void *ptr) {\n#ifdef   __GNUC__\n    // __builtin_constant_p(ptr) is false even for nullptr,\n    // but the checking the result of booleanizing works.\n    return __builtin_constant_p(!ptr) &amp;&amp; !ptr;\n#else\n    return false;\n#endif\n}\n</code></pre>\n<p>It will always return false with clang because it evaluates <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\" rel=\"nofollow noreferrer\"><code>__builtin_constant_p</code></a> before inlining.  But since clang already skips <code>delete</code> calls when it can prove a pointer is null, you don't need it.</p>\n<p>This might actually help in <code>std::move</code> cases, and you can safely use it anywhere with (in theory) no performance downside.  I always compiles to <code>if(true)</code> or <code>if(false)</code>, so it's very different from <code>if(ptr)</code>, which is likely to result in a runtime branch because the compiler probably can't prove the pointer is non-null in most cases either.  (A dereference might, though, because a null deref would be UB, and modern compilers optimized based on the assumption that the code doesn't contain any UB).</p>\n<p>You could make this a macro to avoid bloating non-optimized builds (and so it would \"work\" without having to inline first).  You can use a GNU C statement-expression to avoid double-evaluating the macro arg (<a href=\"https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html#Statement-Exprs\" rel=\"nofollow noreferrer\">see examples for GNU C <code>min()</code> and <code>max()</code></a>).  For the fallback for compilers without GNU extensions, you could write <code>((ptr), false)</code> or something to evaluate the arg once for side effects while producing a <code>false</code> result.</p>\n<p>Demonstration:  <a href=\"https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'static+inline+bool+%0Ais_compiletime_null(const+void+*ptr)+%7B%0A%23ifdef+++__GNUC__%0A++++//+__builtin_constant_p(ptr)+is+false+even+for+nullptr,%0A++++//+so+explicitly+test+whether+it!'s+known+to+booleanize%0A++++return+__builtin_constant_p(!!ptr)+%26%26+!!ptr%3B%0A%23else%0A++++return+false%3B%0A%23endif%0A%7D%0A%0Avoid+foo(int+*ptr)+%7B%0A++++if+(!!is_compiletime_null(ptr))%0A++++++++delete+ptr%3B%0A%7D%0A%0Avoid+bar()+%7B%0A++++foo(nullptr)%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:33.333333333333336,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g63,filters:(___0:(),b:'0',commentOnly:'0',directives:'0',intel:'0',jquery:'3.2.1',length:1,prevObject:(___0:(sizzle1502802042608:(undefined:(legend:!(5,0,'1')))),length:1,prevObject:(___0:(jQuery321036897353499783291:(display:''),sizzle1502802042608:(undefined:(legend:!(5,0,'1')))),length:1))),options:'-std%3Dgnu%2B%2B11+-Wall+-O3',source:1),l:'5',n:'0',o:'x86-64+gcc+6.3+(Editor+%231,+Compiler+%231)',t:'0')),k:33.333333333333336,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cl19_64,filters:(___0:(),b:'0',commentOnly:'0',directives:'0',intel:'0',jquery:'3.2.1',length:1,prevObject:(___0:(sizzle1502802042608:(undefined:(legend:!(10,0,'1')))),length:1,prevObject:(___0:(jQuery321036897353499783291:(display:''),sizzle1502802042608:(undefined:(legend:!(10,0,'1')))),length:1))),options:'-Ox',source:1),l:'5',n:'0',o:'x86-64+CL+19+2017+RTW+(Editor+%231,+Compiler+%232)',t:'0')),k:33.33333333333333,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">asm from gcc6.3 -O3 on the Godbolt compiler explorer</a></p>\n<pre><code>void foo(int *ptr) {\n    if (!is_compiletime_null(ptr))\n        delete ptr;\n}\n\n    # compiles to a tailcall of operator delete\n    jmp     operator delete(void*)\n\n\nvoid bar() {\n    foo(nullptr);\n}\n\n    # optimizes out the delete\n    rep ret\n</code></pre>\n<p>It compiles correctly with MSVC (also on the compiler explorer link), but with the test always returning false, <code>bar()</code> is:</p>\n<pre><code>    # MSVC doesn't support GNU C extensions, and doesn't skip nullptr deletes itself\n    mov      edx, 4\n    xor      ecx, ecx\n    jmp      ??3@YAXPEAX_K@Z      ; operator delete\n</code></pre>\n<p>Interesting to note that MSVC's <code>operator delete</code> takes the object size as \na function arg (<code>mov edx, 4</code>), but gcc/Linux/libstdc++ code just passes the pointer.</p>\n<hr>\n<p>Related: I found <a href=\"https://gustedt.wordpress.com/2013/08/22/testing-compile-time-constness-and-null-pointers-with-c11s-_generic/\" rel=\"nofollow noreferrer\">this blog post</a>, using C11 (not C++11) <code>_Generic</code> to try to portably do something like <code>__builtin_constant_p</code> null-pointer checks inside static initializers.</p>\n</hr></hr>", "OwnerUserId": "224132", "LastEditorUserId": "224132", "LastEditDate": "2017-08-16T19:22:20.230", "Id": "45693275", "Score": "4", "CreationDate": "2017-08-15T12:54:45.697", "LastActivityDate": "2017-08-16T19:22:20.230"}, "45690773": {"ParentId": "45689690", "CommentCount": "4", "Body": "<p>It's a QOI issue. clang does indeed elide the test:</p>\n<p><a href=\"https://godbolt.org/g/nBSykD\" rel=\"noreferrer\">https://godbolt.org/g/nBSykD</a></p>\n<pre><code>main:                                   # @main\n        xor     eax, eax\n        ret\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "45690773", "Score": "8", "CreationDate": "2017-08-15T10:08:43.797", "LastActivityDate": "2017-08-15T10:08:43.797"}, "bq_ids": {"n4140": {"so_45689690_45690345_0": {"section_id": 7174, "quality": 0.8723404255319149, "length": 41}, "so_45689690_45691283_1": {"section_id": 6111, "quality": 1.0, "length": 7}, "so_45689690_45690345_1": {"section_id": 6106, "quality": 0.9629629629629629, "length": 26}, "so_45689690_45691283_0": {"section_id": 6111, "quality": 1.0, "length": 7}, "so_45689690_45690345_2": {"section_id": 7183, "quality": 0.9565217391304348, "length": 44}, "so_45689690_45690345_5": {"section_id": 6111, "quality": 0.975, "length": 39}, "so_45689690_45690345_6": {"section_id": 6111, "quality": 1.0, "length": 7}, "so_45689690_45690345_3": {"section_id": 6111, "quality": 1.0, "length": 7}, "so_45689690_45690345_4": {"section_id": 6111, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_45689690_45690345_0": {"section_id": 6918, "quality": 0.8723404255319149, "length": 41}, "so_45689690_45691283_1": {"section_id": 5877, "quality": 1.0, "length": 7}, "so_45689690_45690345_1": {"section_id": 5872, "quality": 0.9629629629629629, "length": 26}, "so_45689690_45691283_0": {"section_id": 5876, "quality": 0.8571428571428571, "length": 6}, "so_45689690_45690345_6": {"section_id": 5877, "quality": 1.0, "length": 7}, "so_45689690_45690345_3": {"section_id": 5876, "quality": 0.8571428571428571, "length": 6}, "so_45689690_45690345_2": {"section_id": 6927, "quality": 0.6304347826086957, "length": 29}}, "n4659": {"so_45689690_45690345_0": {"section_id": 8682, "quality": 0.8723404255319149, "length": 41}, "so_45689690_45691283_1": {"section_id": 7608, "quality": 1.0, "length": 7}, "so_45689690_45690345_1": {"section_id": 7603, "quality": 0.9629629629629629, "length": 26}, "so_45689690_45690345_4": {"section_id": 7608, "quality": 0.8888888888888888, "length": 24}, "so_45689690_45690345_5": {"section_id": 7608, "quality": 0.975, "length": 39}, "so_45689690_45690345_6": {"section_id": 7608, "quality": 1.0, "length": 7}, "so_45689690_45690345_3": {"section_id": 7608, "quality": 1.0, "length": 7}, "so_45689690_45690345_2": {"section_id": 8671, "quality": 0.5434782608695652, "length": 25}, "so_45689690_45691283_0": {"section_id": 7608, "quality": 1.0, "length": 7}}}});