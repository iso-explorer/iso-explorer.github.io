post_cb({"6845850": {"Id": "6845850", "PostTypeId": "2", "Body": "<p>'Compatible types' means one of the following:</p>\n<ol>\n<li>Types that have a parent-child relationship</li>\n<li>Compatible built-in types (double to float, int to bool, etc)</li>\n<li>Types that have a defined conversion operator to some other otherwise unrelated type. For example, I might make a custom Fraction class and I can define <code>operator double()</code> for it, which will make my class convertible to a double.</li>\n<li>One type can be constructed from the other. For example, I can make a <code>Fraction::Fraction(double)</code> constructor, which will make a double convertible to my class.</li>\n</ol>\n", "LastEditorUserId": "15416", "LastActivityDate": "2011-07-28T07:53:19.127", "Score": "3", "CreationDate": "2011-07-27T14:10:05.230", "ParentId": "6845695", "CommentCount": "0", "OwnerUserId": "627005", "LastEditDate": "2011-07-28T07:53:19.127"}, "6845823": {"Id": "6845823", "PostTypeId": "2", "Body": "<pre><code>void foo( base *bPtr )\n{\n     derived *dPtr = static_cast&lt; derived*&gt; (bPtr) ; \n         // Safe as long as the bPtr has the derived class sub object too.\n         // But what if bPtr is just pointing to a base* ?\n}\n\nderived* objOne = new derived() ;\nfoo( objOne ) ; // safe\n\nbase* obj = new base() ;\nfoo( obj ) ; // unsafe\n</code></pre>\n<p>In the function, it doesn't check the type compatibility and returns a <code>derived*</code>.</p>\n<p>Demo: <a href=\"http://ideone.com/YwHJn\" rel=\"nofollow\">http://ideone.com/YwHJn</a></p>\n", "LastActivityDate": "2011-07-27T14:08:15.877", "CommentCount": "4", "CreationDate": "2011-07-27T14:08:15.877", "ParentId": "6845695", "Score": "-1", "OwnerUserId": "528724"}, "6845921": {"Id": "6845921", "PostTypeId": "2", "Body": "<p>In addition to the base - derived - base conversion, <code>static_cast</code> can also be used when an implicit or explicit conversion exists between two types.</p>\n<p>Examples of implicit type conversion:</p>\n<pre><code>// From int to double\nint i = 0;\ndouble d = i;\n\nclass Integer\n{\npublic:\n    Integer(int value)\n    :   value_(value)\n    {\n        // ...\n    }\n\nprivate:\n    int value_;\n};\n\n// From int to Integer\nint a = 0;\nInteger b = a;\n</code></pre>\n<p>Examples of explicit type conversion:</p>\n<pre><code>// From double to int\ndouble d = 0.0;\nint i = static_cast&lt;int&gt;(d);\n\nclass Integer\n{\npublic:\n    explicit Integer(int value)\n    :   value_(value)\n    {\n        // ...\n    }\n\nprivate:\n    int value_;\n};\n\n// From int to Integer\nint a = 0;\nInteger b(a);\nInteger c = static_cast&lt;Integer&gt;(a);\n</code></pre>\n<p>See: <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">Type Casting</a></p>\n", "LastActivityDate": "2011-07-27T14:15:15.700", "CommentCount": "0", "CreationDate": "2011-07-27T14:15:15.700", "ParentId": "6845695", "Score": "0", "OwnerUserId": "838751"}, "6845695": {"ViewCount": "2032", "Body": "<p>I understand that static_cast can convert between base and derived and between derived and base.  dynamic_cast will check resulting object is a 'complete' object.</p>\n<p>dynamic_cast uses RTTI feature.  But how does static_cast work?  What does 'compatible types' mean?</p>\n<p>My question was really about what compatible types meant.  But I am happy that have learnt something from posts.  This sample demonstrates how the compiler interprets compatible types.  Last few lines are most interesting.  note interesting results.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\nusing namespace std;\n\nclass CBase { virtual void dummy() {} };\nclass CDerived: public CBase {  public: CDerived() : a(20) {} int a; };\nclass CDerived2: public CBase { public: CDerived2() : b(7) {} int b; };\nclass CDerived3: public CBase { public: CDerived3() : c('A') {} char c; };\nclass CNotDerived { int doit() const { return 9; } };\n\nint main () {\n  try {\n      CBase * pba = new CDerived;\n      CBase * pbb = new CBase;\n      CDerived * pd;\n      CNotDerived* pnot = new CNotDerived;\n      CDerived2* pd2 = 0; \n      CDerived2* pdx = new CDerived2;\n      CDerived3* pd3 = 0;\n\n\n      pd = dynamic_cast&lt;CDerived*&gt;(pba);\n      if (pd==0) cout &lt;&lt; \"Null pointer on first type-cast\" &lt;&lt; endl;   //ok\n\n      pd = dynamic_cast&lt;CDerived*&gt;(pbb);\n      if (pd==0) cout &lt;&lt; \"Null pointer on second type-cast\" &lt;&lt; endl;  //null ptr here\n\n      pd = static_cast&lt;CDerived*&gt;(pbb);  //non-null pointer returned (not really what you want)\n      if (pd==0) cout &lt;&lt; \"Null pointer on third type-cast\" &lt;&lt; endl;\n</code></pre>\n<p>//        pd = dynamic_cast(pnot); //error C2683: 'dynamic_cast' : 'CNotDerived' is not a polymorphic type\n  //      if (pnot==0) cout &lt;&lt; \"Null pointer on fourth type-cast\" &lt;&lt; endl;  </p>\n<p>//        pd = static_cast(pnot); //error C2440: 'static_cast' : cannot convert from 'CNotDerived *' to 'CDerived *'\n//        if (pnot==0) cout &lt;&lt; \"Null pointer on fourth type-cast\" &lt;&lt; endl;</p>\n<pre><code>      //below lines compiled with ms vs2008 - I believe compiler SHOULD have flagged below as an error - but did not.\n      pd2 = static_cast&lt;CDerived2*&gt;(pba); //compiles ok but obviously incorrect\n      if (pd2==0) cout &lt;&lt; \"Null pointer on fourth type-cast\" &lt;&lt; endl;\n      cout &lt;&lt; pd2-&gt;b &lt;&lt; endl;  //compiler had decided to give us CDerived-&gt;a value! Incorrect.\n\n      pd2 = static_cast&lt;CDerived2*&gt;(pdx); //compiles ok \n      if (pd2==0) cout &lt;&lt; \"Null pointer on fourth type-cast\" &lt;&lt; endl;\n      cout &lt;&lt; pd2-&gt;b &lt;&lt; endl;  //gives correct value for b (7)\n\n      pd3 = static_cast&lt;CDerived2*&gt;(pdx); //error C2440: '=' : cannot convert from 'CDerived2 *' to 'CDerived3 *'\n      if (pd3==0) cout &lt;&lt; \"Null pointer on fourth type-cast\" &lt;&lt; endl;\n      cout &lt;&lt; pd3-&gt;c &lt;&lt; endl; \n\n  } catch (exception&amp; e) {\n      cout &lt;&lt; \"Exception: \" &lt;&lt; e.what();\n  }\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "6845752", "Title": "static_cast - what does conversion between compatible types mean?", "CreationDate": "2011-07-27T14:01:25.963", "Id": "6845695", "CommentCount": "0", "LastEditDate": "2011-07-29T10:50:04.043", "PostTypeId": "1", "LastEditorUserId": "619818", "LastActivityDate": "2011-07-29T10:50:04.043", "Score": "2", "OwnerUserId": "619818", "Tags": "<c++><casting>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_6845695_6845752_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 6032}, "so_6845695_6845752_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 6030}, "so_6845695_6845752_4": {"length": 8, "quality": 0.8, "section_id": 6039}, "so_6845695_6845752_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 6028}, "so_6845695_6845752_3": {"length": 8, "quality": 1.0, "section_id": 6036}}, "n3337": {"so_6845695_6845752_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 5800}, "so_6845695_6845752_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5798}, "so_6845695_6845752_4": {"length": 8, "quality": 0.8, "section_id": 5807}, "so_6845695_6845752_2": {"length": 29, "quality": 0.9354838709677419, "section_id": 5796}, "so_6845695_6845752_3": {"length": 8, "quality": 1.0, "section_id": 5804}}, "n4659": {"so_6845695_6845752_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 7531}, "so_6845695_6845752_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 2}, "so_6845695_6845752_4": {"length": 8, "quality": 0.8, "section_id": 7538}, "so_6845695_6845752_2": {"length": 23, "quality": 0.7419354838709677, "section_id": 7527}, "so_6845695_6845752_3": {"length": 8, "quality": 1.0, "section_id": 7535}}}, "6845883": {"Id": "6845883", "PostTypeId": "2", "Body": "<p>In case of static cast it is completely upto the programmer to decide if the casting will result in defined behaviour or undefined behaviour whereas in case of dynamic cast the check can be performed at runtime. </p>\n<p>Thus the only difference between static cast and dynamic cast is that static cast does not require the run time overhead of that of dynamic cast.</p>\n", "LastActivityDate": "2011-07-27T14:12:37.740", "CommentCount": "0", "CreationDate": "2011-07-27T14:12:37.740", "ParentId": "6845695", "Score": "0", "OwnerUserId": "434233"}, "6845844": {"Id": "6845844", "PostTypeId": "2", "Body": "<p>Compared to <code>dynamic_cast</code>, <code>static_cast</code> could perform downcast on type that has no vtable while <code>dynamic_cast</code> cannot. <code>static_cast</code> will not check if the cast is valid at run time. It just adjusts pointer offset at compile time.</p>\n<p>Compatible types means</p>\n<ul>\n<li>native numeric types like <code>double</code> to <code>long</code></li>\n<li>base types and derived types</li>\n<li>type that can cast to other types via cast operators</li>\n</ul>\n", "LastActivityDate": "2011-07-27T14:09:50.163", "CommentCount": "0", "CreationDate": "2011-07-27T14:09:50.163", "ParentId": "6845695", "Score": "0", "OwnerUserId": "555515"}, "6845752": {"Id": "6845752", "PostTypeId": "2", "Body": "<p>The main cases are they have a parent-child relationship or are both builtin numeric types. It's also valid if one object can be constructed from the other, integral types can be converted to enumerated types, and void pointers can be cast to pointer-to-object.</p>\n<p>EDIT for the main cases (I omitted some more obscure cases like pointer-to-member casts):</p>\n<p>5.2.9/2:</p>\n<blockquote>\n<p id=\"so_6845695_6845752_0\">An expression e can be explicitly converted to a type T using a\n  static_cast of the form static_cast(e) if the declaration \u201cT t(e);\u201d\n  is wellformed, for some invented temporary variable t (8.5).</p>\n</blockquote>\n<p>5.2.9/4:</p>\n<blockquote>\n<p id=\"so_6845695_6845752_1\">Any expression can be explicitly converted to type \u201ccv void.\u201d The\n  expression value is discarded.</p>\n</blockquote>\n<p>5.2.9/5:</p>\n<blockquote>\n<p id=\"so_6845695_6845752_2\">An lvalue of type \u201ccv1 B\u201d, where B is a class type, can be cast to\n  type \u201creference to cv2 D\u201d, where D is a class derived (clause 10) from\n  B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to\n  B\u201d exists (4.10), cv2 is the same cvqualification as, or greater\n  cvqualification than, cv1, and B is not a virtual base class of D.</p>\n</blockquote>\n<p>7.2.9/7:</p>\n<blockquote>\n<p id=\"so_6845695_6845752_3\">A value of integral type can be explicitly converted to an enumeration\n  type.</p>\n</blockquote>\n<p>7.2.9/10:</p>\n<blockquote>\n<p id=\"so_6845695_6845752_4\">An rvalue of type \u201cpointer to cv void\u201d can be explicitly converted to\n  a pointer to object type.</p>\n</blockquote>\n", "LastEditorUserId": "251738", "LastActivityDate": "2011-07-27T14:11:20.753", "Score": "3", "CreationDate": "2011-07-27T14:04:28.927", "ParentId": "6845695", "CommentCount": "0", "OwnerUserId": "251738", "LastEditDate": "2011-07-27T14:11:20.753"}});