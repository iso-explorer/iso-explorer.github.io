post_cb({"7474169": {"ParentId": "7474126", "CommentCount": "0", "Body": "<p>Yes, <code>insert()</code> can invalidate all iterators. Therefore, I don't think there's a way to avoid the (implicit) lookup. The good news is that the latter is likely to be cheap.</p>\n", "OwnerUserId": "367273", "PostTypeId": "2", "Id": "7474169", "Score": "1", "CreationDate": "2011-09-19T16:26:36.253", "LastActivityDate": "2011-09-19T16:26:36.253"}, "7474221": {"ParentId": "7474126", "CommentCount": "1", "Body": "<p>The whole point of the unordered containers is to have the fastest possible lookup time. Worrying about the time it takes to erase an element by key sounds like the classic example of premature optimization.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "7474221", "Score": "5", "CreationDate": "2011-09-19T16:30:19.453", "LastActivityDate": "2011-09-19T16:30:19.453"}, "7475106": {"ParentId": "7474126", "CommentCount": "0", "Body": "<p>If it matters a great deal to you, because you're keeping the iterator for some other reason, then C++0x says of <code>std::unordered_map</code> (quoting from the FDIS), in 23.2.5/11:</p>\n<blockquote>\n<p id=\"so_7474126_7475106_0\">The insert and emplace members shall not a\ufb00ect the validity of\n  iterators if (N+n) &lt; z * B, where N is the number of elements in the\n  container prior to the insert operation, n is the number of elements\n  inserted, B is the container\u2019s bucket count, and z is the container\u2019s\n  maximum load factor.</p>\n</blockquote>\n<p>I haven't checked whether the <code>tr1</code> spec has the same guarantee, but it's fairly logical based on the expected implementation.</p>\n<p>If you can use this guarantee, then you can protect your iterators up to a point. As Mark says, though, lookup in <code>unordered_map</code> is supposed to be fast. Keeping a key rather than an iterator is worse than keeping an index rather than an iterator in a <code>vector</code>, but better than the equivalent for <code>map</code>.</p>\n", "OwnerUserId": "13005", "PostTypeId": "2", "Id": "7475106", "Score": "2", "CreationDate": "2011-09-19T17:50:33.093", "LastActivityDate": "2011-09-19T17:50:33.093"}, "bq_ids": {"n4140": {"so_7474126_7475106_0": {"section_id": 767, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_7474126_7475106_0": {"section_id": 754, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_7474126_7475106_0": {"section_id": 827, "quality": 0.9166666666666666, "length": 22}}}, "7474126": {"CommentCount": "0", "ViewCount": "1755", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2011-09-19T17:50:33.093", "Body": "<p>I am experimenting with tr1::unordered_map and stumbled upon the problem how to\nefficiently delete elements. The 'erase' method offers to delete either by key or\nby iterator. I would assume the latter to be more efficient, since the former\npresumably involves an implicit find operation. On the other hand my investigations\non the internet have revealed that iterators may become invalid after calling\nthe insert() method.</p>\n<p>I am interested in a typical real-world situation, where objects put into a hash table\nhave a life span which is long enough such that calls to insert() happen during that\nlife span. Thus may I conclude that in such a situation deletion by key is the only\noption left? Are there any alternatives how to delete objects more efficiently? I am\nfully aware that the question only matters in applications, where deletions happen\noften. Whether this will be the case for my current project, remains to be seen, but\nI would rather learn about these issues while designing my project rather than when\nthere is already a lot of code present.</p>\n", "Title": "Efficiently erasing elements in tr1::unordered_map", "FavoriteCount": "1", "LastEditDate": "2011-09-19T16:32:36.693", "Id": "7474126", "Score": "4", "CreationDate": "2011-09-19T16:23:02.250", "Tags": "<c++><erase><unordered-map>", "OwnerUserId": "953087", "AnswerCount": "3"}});