post_cb({"28267655": {"ParentId": "28267484", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>C++ Standard defines <a href=\"http://en.cppreference.com/w/cpp/error/current_exception\"><code>current_exception()</code></a> in section \u00a7 18.8.5 [propagation] :</p>\n<p>(emphasis mine)</p>\n<blockquote>\n<p id=\"so_28267484_28267655_0\"><code>exception_ptr current_exception() noexcept;</code></p>\n<p id=\"so_28267484_28267655_1\">Returns: An exception_ptr object that refers to the currently handled\n  exception (15.3) or a copy of <strong>the currently handled exception</strong>, or a\n  null exception_ptr object if no exception is being handled. The\n  referenced object shall remain valid at least as long as there is an\n  exception_ptr object that refers to it.</p>\n</blockquote>\n<p>And \u00a7 15.3 [except.handle], notes 7 and 8 :</p>\n<blockquote>\n<ol start=\"7\">\n<li><p id=\"so_28267484_28267655_2\">A handler is considered <strong>active</strong> when initialization is complete for the\n  parameter (if any) of the catch clause. [ Note: <strong>The stack will have\n  been unwound at that point</strong>. \u2014 end note ]</p></li>\n<li><p id=\"so_28267484_28267655_3\">The exception with the most recently activated <strong>handler that is still\n  active</strong> is called the <strong>currently handled exception</strong>.</p></li>\n</ol>\n</blockquote>\n<p>The exception returned by <a href=\"http://en.cppreference.com/w/cpp/error/current_exception\"><code>current_exception()</code></a> is defined as the \"currently handled exception\", which is the exception of the most recent active handler, and a handler is active only when stack unwinding completed.</p>\n<hr>\n<p>As your tests have shown, there is no \"active handler\" <em>during</em> stack unwinding, so there is no \"currently handled exception\" either : in that case, <a href=\"http://en.cppreference.com/w/cpp/error/current_exception\"><code>current_exception()</code></a> will return a null <code>exception_ptr</code>.</p>\n</hr>", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2015-02-02T13:31:26.693", "Id": "28267655", "Score": "18", "CreationDate": "2015-02-01T20:45:33.780", "LastActivityDate": "2015-02-02T13:31:26.693"}, "28267484": {"CommentCount": "0", "AcceptedAnswerId": "28267655", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-02-01T20:28:47.337", "LastActivityDate": "2016-08-11T10:55:49.023", "LastEditDate": "2017-05-23T11:53:37.693", "ViewCount": "1328", "FavoriteCount": "2", "Title": "Can I use std::current_exception during stack unwinding?", "Id": "28267484", "Score": "25", "Body": "<p>Should it be possible to use std::current_exception inside destructors of objects that are destroyed during stack unwinding?</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/error/current_exception\" rel=\"nofollow noreferrer\">Documentation on cppreference</a> says:</p>\n<blockquote>\n<p id=\"so_28267484_28267484_0\">If called during exception handling (typically, in a catch clause), captures the current exception object (...)</p>\n</blockquote>\n<p>But it's not clear for me whether stack unwinding is a part of exception handling.</p>\n<p>In some <a href=\"https://stackoverflow.com/a/18963673/200121\">highest-ranked answer</a> on stackoverflow author assumes that it's possible.</p>\n<p>I did some test on my compiler (g++ (Ubuntu 4.8.2-19ubuntu1) 4.8.2) and it seems, that std::current_exception returns empty pointer in this case.</p>\n<pre><code>#include &lt;exception&gt;\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n\n\nstruct A\n{\n    ~A()\n    {\n        std::clog &lt;&lt; \"in destructor\"&lt;&lt;std::endl;\n        std::clog &lt;&lt; \"uncaught_exception: \" &lt;&lt; std::uncaught_exception() &lt;&lt; std::endl;\n        std::clog &lt;&lt; \"current_exception: \" &lt;&lt; (bool)std::current_exception() &lt;&lt; std::endl;\n    }\n};\n\nint main(int argc, char **)\n{\n    try\n    {\n        A aa;\n        std::clog &lt;&lt; \"before throw\"&lt;&lt;std::endl;\n        if(argc&gt;1)\n            throw std::runtime_error(\"oh no\");\n    }\n    catch(...)\n    {\n        std::clog &lt;&lt; \"in catch block\"&lt;&lt;std::endl;\n        std::clog &lt;&lt; \"uncaught_exception: \" &lt;&lt; std::uncaught_exception() &lt;&lt; std::endl;\n        std::clog &lt;&lt; \"current_exception: \" &lt;&lt; (bool)std::current_exception() &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>before throw\nin destructor\nuncaught_exception: 1\ncurrent_exception: 0\nin catch block\nuncaught_exception: 0\ncurrent_exception: 1\n</code></pre>\n<p>Does anybody know what the standard says?</p>\n", "Tags": "<c++><c++11><exception-handling>", "OwnerUserId": "200121", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28267484_28267655_1": {"section_id": 6940, "quality": 0.896551724137931, "length": 26}, "so_28267484_28267655_3": {"section_id": 3353, "quality": 0.8333333333333334, "length": 10}, "so_28267484_28267655_2": {"section_id": 3352, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_28267484_28267655_1": {"section_id": 6688, "quality": 0.896551724137931, "length": 26}, "so_28267484_28267655_3": {"section_id": 3223, "quality": 0.8333333333333334, "length": 10}, "so_28267484_28267655_2": {"section_id": 3222, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_28267484_28267655_1": {"section_id": 8437, "quality": 0.896551724137931, "length": 26}, "so_28267484_28267655_2": {"section_id": 4119, "quality": 0.7777777777777778, "length": 14}, "so_28267484_28267655_3": {"section_id": 4120, "quality": 0.8333333333333334, "length": 10}}}});