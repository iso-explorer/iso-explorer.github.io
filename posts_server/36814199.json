post_cb({"36815188": {"Id": "36815188", "PostTypeId": "2", "Body": "<p>There is no <em>minimal execution time</em> for a C or C++ executable because execution time depends on many platform specific issues such as:</p>\n<ol>\n<li>Processor clock rate.</li>\n<li>Clock cycles per instruction.</li>\n<li>Internal processor execution optimizations.</li>\n<li>Interruptions.</li>\n<li>Processor instruction set / capabilities.</li>\n</ol>\n<p>Some processors support multiplication, others don't.  The processors that don't support multiplication would take longer to execute a program than a process that has multiplication instructions.  Same with floating point.  </p>\n<p>The internal operating speed of a processor varies.  There is a common unit of time measurement called a \"clock cycle\".  Most processor vendors specify the duration of an instruction in clock cycles.  This measurement may be difficult due to internal support, such as cache management.  </p>\n<p>Some processors have logic that can optimize the execution of instructions, or instruction patterns.  One optimization is <em>branch prediction</em>.  </p>\n<p>Many platforms have interrupts.  For example, there may be a \"system tick\" interrupt which allows the operating system to know when to switch execution to another program.  Some are not so periodic, such as when I/O occurs.  A minimum execution time cannot be guaranteed when the program gets interrupted.  </p>\n<p>Stating a minimum execution time would play havoc with the C and C++ language portability.  Some platforms would want to execute code faster than the minimum time.  Other platforms may not be able to achieve a minimum execution time (but they could benefit from a high level language like C).  </p>\n<p>Also, how would the time be measured?  </p>\n<p>Does the minimum execution time apply for delay loops or polling?</p>\n", "LastActivityDate": "2016-04-23T19:05:59.440", "CommentCount": "1", "CreationDate": "2016-04-23T19:05:59.440", "ParentId": "36814199", "Score": "7", "OwnerUserId": "225074"}, "36814954": {"Id": "36814954", "PostTypeId": "2", "Body": "<p>You did not specify the compiler, but let's assume it's <code>gcc</code>.</p>\n<p>gcc does <em>not</em> remove empty loops, at least not according to the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Non-bugs.html#Non-bugs\">documentation</a>. It contains the following text:</p>\n<blockquote>\n<p id=\"so_36814199_36814954_0\">Historically, GCC has not deleted \u201cempty\u201d loops under the assumption that the most likely reason you would put one in a program is to have a delay, so deleting them will not make real programs run any faster.</p>\n</blockquote>\n<p>However, it can remove empty loops if they are \"emptied\" by the optimizer, that is, if the loop contains code that the optimizer can move outside the loop, and the resulting loop is empty.</p>\n<p>It is not clear from the documentation if this is still true in the most recent version. The manual mentions \"historically\" without specifying why. If you update your question with information about your exact platform and compiler, maybe a better answer can be given.</p>\n", "LastEditorUserId": "5725780", "LastActivityDate": "2016-04-23T18:57:42.500", "Score": "28", "CreationDate": "2016-04-23T18:45:16.090", "ParentId": "36814199", "CommentCount": "5", "OwnerUserId": "5725780", "LastEditDate": "2016-04-23T18:57:42.500"}, "36814227": {"Id": "36814227", "PostTypeId": "2", "Body": "<p>No, time spent does not count as observable behaviour to be protected by the as-if rule:</p>\n<blockquote>\n<p id=\"so_36814199_36814227_0\"><code>[C++14: 1.8/5]:</code> <strong>A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input.</strong> However, if any such execution contains an undefined operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</p>\n<p id=\"so_36814199_36814227_1\"><code>[C++14: 1.5/8]:</code> The least requirements on a conforming implementation are:</p>\n<ul>\n<li>Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</li>\n<li>At program termination, all data written into files shall be identical to one of the possible results that execution of the program according to the abstract semantics would have produced.</li>\n<li>The input and output dynamics of interactive devices shall take place in such a fashion that prompting output is actually delivered before a program waits for input. What constitutes an interactive device is implementation-defined.</li>\n</ul>\n<p id=\"so_36814199_36814227_2\"><strong>These collectively are referred to as the <em>observable behavior</em> of the program.</strong> <em>[ Note:</em> More stringent correspondences between abstract and actual semantics may be defined by each implementation. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Those loops can be legally optimised out and, indeed, there are scenarios in which the standard makes <em>deliberate</em> attempts to make doing so even easier:</p>\n<blockquote>\n<p id=\"so_36814199_36814227_3\"><code>[C++14: 1.10/24]:</code> The implementation may assume that any thread will eventually do one of the following:</p>\n<ul>\n<li>terminate,</li>\n<li>make a call to a library I/O function,</li>\n<li>access or modify a volatile object, or</li>\n<li>perform a synchronization operation or an atomic operation.</li>\n</ul>\n<p id=\"so_36814199_36814227_4\"><em>[ Note:</em> This is intended to allow compiler transformations such as removal of empty loops, even when termination cannot be proven. <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Your compiler may in fact be being \"polite\" in noticing that the intent of the loop in <em>these</em> programs appears to be in slowing down the emission of repeated text output. :)</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2016-04-23T17:46:11.723", "Score": "43", "CreationDate": "2016-04-23T17:40:06.767", "ParentId": "36814199", "CommentCount": "4", "OwnerUserId": "560648", "LastEditDate": "2016-04-23T17:46:11.723"}, "bq_ids": {"n4140": {"so_36814199_36814227_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 5838}, "so_36814199_36814227_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5804}, "so_36814199_36814227_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 5838}, "so_36814199_36814227_2": {"length": 13, "quality": 0.6842105263157895, "section_id": 5804}, "so_36814199_36814227_0": {"length": 37, "quality": 0.925, "section_id": 5801}}, "n3337": {"so_36814199_36814227_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 5608}, "so_36814199_36814227_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 5577}, "so_36814199_36814227_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 5608}, "so_36814199_36814227_2": {"length": 13, "quality": 0.6842105263157895, "section_id": 5577}, "so_36814199_36814227_0": {"length": 37, "quality": 0.925, "section_id": 5574}}, "n4659": {"so_36814199_36814227_4": {"length": 13, "quality": 0.7647058823529411, "section_id": 7300}, "so_36814199_36814227_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 7300}, "so_36814199_36814227_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 7262}, "so_36814199_36814227_2": {"length": 13, "quality": 0.6842105263157895, "section_id": 7262}, "so_36814199_36814227_0": {"length": 37, "quality": 0.925, "section_id": 7260}}}, "36819715": {"Id": "36819715", "PostTypeId": "2", "Body": "<p>No, there is no guarantee: (quotation from <a href=\"http://port70.net/~nsz/c/c11/n1570.html#5.1.2.3p1\" rel=\"nofollow\">N1570, 5.1.2.3 Program execution</a>)</p>\n<blockquote>\n<p id=\"so_36814199_36819715_0\">1 The semantic descriptions in this International Standard describe\n  the behavior of an abstract machine in which issues of optimization\n  are irrelevant.</p>\n</blockquote>\n<p>Anyway, the C standard only specifies the behaviour of your program when it is executed on an abstract machine, which can have infinite memory and/or CPUs.</p>\n", "LastActivityDate": "2016-04-24T05:42:21.947", "CommentCount": "7", "CreationDate": "2016-04-24T05:42:21.947", "ParentId": "36814199", "Score": "4", "OwnerUserId": "5399734"}, "36814199": {"ViewCount": "2976", "Body": "<p>Why do compilers seems to be polite toward loops that do nothing and do not eliminate them?  </p>\n<p>Does the C standard require loops to take some time?</p>\n<p>Example, the following code:</p>\n<pre><code>void foo(void) {\n    while(1) {\n        for(int k = 0; k &lt; 1000000000; ++k);\n        printf(\"Foo\\n\");\n    }\n}\n</code></pre>\n<p>runs slower than this one:</p>\n<pre><code>void foo(void) {\n    while(1) {\n        for(int k = 0; k &lt; 1000; ++k);\n        printf(\"Foo\\n\");\n    }\n}\n</code></pre>\n<p>even with <code>-O3</code> optimization level.\nI would expect removing empty loops allowed and thus get the same speed on both codes.  </p>\n<p>Is \"time spent\" a side effect that should be preserved by a compiler?</p>\n", "AcceptedAnswerId": "36814227", "Title": "Does C/C++ offer any guarantee on minimal execution time?", "CreationDate": "2016-04-23T17:37:46.763", "Id": "36814199", "CommentCount": "18", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2016-04-23T18:51:19.643", "LastEditorUserId": "225074", "LastActivityDate": "2016-04-24T05:42:21.947", "Score": "42", "OwnerUserId": "504286", "Tags": "<c++><c><language-lawyer><compiler-optimization>", "AnswerCount": "4"}});