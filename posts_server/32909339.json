post_cb({"bq_ids": {"n4140": {"so_32909339_32909764_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 278}}, "n3337": {"so_32909339_32909764_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 269}}, "n4659": {"so_32909339_32909764_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 285}}}, "32909339": {"ViewCount": "79", "Body": "<p>I'm trying to specialise a templatised function inside a templatised class. It works fine until I add the specialisation: then it doesn't compile anymore.</p>\n<p>Here's a simplified example of what kind of thing I'm trying to do:</p>\n<pre><code>template &lt;typename TString, typename TStringStream, typename TChar&gt;\nclass TestClass\n{\npublic:\n    template &lt;typename T&gt;\n    static T convert(const TChar* text);\n};\n\n\n//This specialisation doesn't compile\ntemplate &lt;typename TString, typename TStringStream, typename TChar&gt;\ntemplate &lt;&gt;\ninline bool TestClass&lt;TString, TStringStream, TChar&gt;::convert(const TChar* text)\n{\n    return strcmp(text, \"true\");\n}\n\n\ntemplate &lt;typename TString, typename TStringStream, typename TChar&gt;\ntemplate &lt;typename T&gt;\nT TestClass&lt;TString, TStringStream, TChar&gt;::convert(const TChar* text)\n{\n    TStringStream textStream(text);\n    T result;\n    textStream &gt;&gt; result;\n    return result;\n}\n\n\nvoid main()\n{\n    TestClass&lt;RString, RStringstream, char&gt;::convert&lt;bool&gt;(\"0\");\n}\n</code></pre>\n<p>This is the compiler error Visual Studio 2010 returns when I try to compile this:</p>\n<pre><code>error C2244: 'TestClass&lt;TString,TStringStream,TChar&gt;::convert' : unable to match function definition to an existing declaration\n    definition\n    'bool TestClass&lt;TString,TStringStream,TChar&gt;::convert(const TChar *)'\n    existing declarations\n    'T TestClass&lt;TString,TStringStream,TChar&gt;::convert(const TChar *)'\n</code></pre>\n<p>What am I doing wrong here?</p>\n<p>(This question is different from <a href=\"https://stackoverflow.com/questions/15911890/overriding-return-type-in-function-template-specialization\">this one</a> because in that link they are trying to return a different type from what the template is, a very special case that I am not trying to do here.)</p>\n", "AcceptedAnswerId": "32909862", "Title": "Why does this function template specialisation not compile?", "CreationDate": "2015-10-02T14:21:40.290", "Id": "32909339", "CommentCount": "4", "LastEditDate": "2017-05-23T11:58:24.830", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-02T14:51:16.117", "Score": "2", "OwnerUserId": "2792060", "Tags": "<c++><templates><template-specialization>", "AnswerCount": "2"}, "32909862": {"Id": "32909862", "PostTypeId": "2", "Body": "<p>Your source is not valid C++, <code>template&lt;&gt;</code> cannot follow a template parameter list.</p>\n<p>The template <code>TestClass&lt;TString, TStringStream, TChar&gt;::convert</code> can also be fully specialized, but only for a given instance of <code>TestClass&lt;TString, TStringStream, TChar&gt;</code>. Such as:</p>\n<pre><code>template &lt;&gt;\ntemplate &lt;&gt;\ninline bool TestClass&lt;RString, RStringstream, char&gt;::convert&lt;bool&gt;(const char* text)\n{\n    return text == \"true\";\n}\n</code></pre>\n", "LastActivityDate": "2015-10-02T14:47:43.630", "CommentCount": "3", "CreationDate": "2015-10-02T14:47:43.630", "ParentId": "32909339", "Score": "3", "OwnerUserId": "3309790"}, "32909764": {"Id": "32909764", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32909339_32909764_0\"><strong>[temp.expl.spec]/16</strong> In an explicit specialization declaration for a member of a class template or a member template that appears in namespace scope, the member template and some of its enclosing class templates may remain unspecialized, except that the declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well... [ <em>Example:</em></p>\n<pre><code>template &lt;class Y&gt; template &lt;&gt;\nvoid A&lt;Y&gt;::B&lt;double&gt;::mf2() { } // ill-formed; B&lt;double&gt; is specialized but\n                                // its enclosing class template A is not\n</code></pre>\n<p id=\"so_32909339_32909764_1\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>Basically, anything that starts with <code>template&lt;something&gt; template&lt;/*nothing*/&gt;</code> is ill-formed.</p>\n", "LastActivityDate": "2015-10-02T14:42:59.220", "CommentCount": "0", "CreationDate": "2015-10-02T14:42:59.220", "ParentId": "32909339", "Score": "4", "OwnerUserId": "1670129"}});