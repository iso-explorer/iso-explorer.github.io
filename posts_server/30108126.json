post_cb({"30108126": {"CommentCount": "3", "ViewCount": "287", "PostTypeId": "1", "ClosedDate": "2015-05-07T18:29:34.580", "LastEditorUserId": "2069064", "CreationDate": "2015-05-07T17:39:20.953", "LastActivityDate": "2015-05-07T21:11:05.403", "Title": "C++11: () or {} in List-initialization?", "AcceptedAnswerId": "30108217", "LastEditDate": "2015-05-07T21:11:05.403", "Id": "30108126", "Score": "3", "Body": "<p>I am referring to \"<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">The working draft N3337</a>\", which <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11\" rel=\"nofollow\">is said most similar to the published C++11 standard</a>.</p>\n<p>If there are matchable constructors, then it call constructors.</p>\n<pre><code>Example (p200):\nstruct S {\n    // no initializer-list constructors\n    S(int, double, double); // #1\n    S(); // #2\n    // ...\n};\n\nS s1 = { 1, 2, 3.0 }; // OK: invoke #1\nS s2 { 1.0, 2, 3 }; // error: narrowing\n</code></pre>\n<p>Otherwise, it will use aggregate initialization.</p>\n<p>Now, <a href=\"http://www.stroustrup.com/C++11FAQ.html#init-list\" rel=\"nofollow\">here</a> is an example using <code>vector</code>, which has an explicit constructor from <code>size_t</code> and an <code>initializer_list</code> constructor:</p>\n<pre><code>vector&lt;double&gt; v1(7);   // ok: v1 has 7 elements\nvector&lt;double&gt; v1{7};   // ok: v1 has 1 element (with its value 7.0)\n</code></pre>\n<p>Here I am confused. Why is there different behavior for the <code>vector</code> constructors than there was for <code>S</code>?</p>\n", "Tags": "<c++><c++11><vector><initialization><list-initialization>", "OwnerUserId": "1914692", "AnswerCount": "1"}, "30108217": {"ParentId": "30108126", "CommentCount": "2", "Body": "<p>Because the <code>initializer_list</code> overload is strongly preferred to all the other ones. From [over.match.list]:</p>\n<blockquote>\n<p id=\"so_30108126_30108217_0\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor\n  in two phases:</p>\n<p id=\"so_30108126_30108217_1\">(1.1) \u2014 Initially, the candidate functions are the <em>initializer-list</em> constructors (8.5.4) of the class <code>T</code> and the\n  argument list consists of the initializer list as a single argument.<br>\n  (1.2) \u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the\n  candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements\n  of the initializer list.</br></p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"nofollow\"><code>vector</code></a> is a non-aggregate class, which has two relevant constructors:</p>\n<pre><code>explicit vector( size_type count );           // (3)\nvector( std::initializer_list&lt;T&gt; init,        // (7)\n    const Allocator&amp; alloc = Allocator() );\n</code></pre>\n<p>Based on the ordering described in [over.match.best], since (7) is a viable constructor candidate, we don't get to point (1.2) where (3) would be considered.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30108217", "Score": "3", "CreationDate": "2015-05-07T17:44:06.810", "LastActivityDate": "2015-05-07T17:44:06.810"}, "bq_ids": {"n4140": {"so_30108126_30108217_0": {"section_id": 599, "quality": 0.9230769230769231, "length": 12}, "so_30108126_30108217_1": {"section_id": 599, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_30108126_30108217_0": {"section_id": 589, "quality": 0.9230769230769231, "length": 12}, "so_30108126_30108217_1": {"section_id": 589, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_30108126_30108217_0": {"section_id": 622, "quality": 0.9230769230769231, "length": 12}, "so_30108126_30108217_1": {"section_id": 622, "quality": 0.9705882352941176, "length": 33}}}});