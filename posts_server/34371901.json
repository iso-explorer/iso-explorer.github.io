post_cb({"bq_ids": {"n4140": {"so_34371901_34372209_1": {"length": 46, "quality": 0.9787234042553191, "section_id": 4}, "so_34371901_34372209_3": {"length": 11, "quality": 1.0, "section_id": 6106}, "so_34371901_34372209_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6105}}, "n3337": {"so_34371901_34372209_3": {"length": 11, "quality": 1.0, "section_id": 5872}, "so_34371901_34372209_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 5890}, "so_34371901_34372209_2": {"length": 15, "quality": 0.8823529411764706, "section_id": 5871}}, "n4659": {"so_34371901_34372209_1": {"length": 46, "quality": 0.9787234042553191, "section_id": 4}, "so_34371901_34372209_3": {"length": 11, "quality": 1.0, "section_id": 7603}, "so_34371901_34372209_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7602}, "so_34371901_34372209_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 8732}}}, "34372193": {"Id": "34372193", "PostTypeId": "2", "Body": "<p>The <code>delete</code> expression takes a cast expression as argument, which can be const or not.  </p>\n<p><code>vec.front()</code> is not const, but it must first be converted to a pointer for <code>delete</code>.  So both candidates <code>const int*</code> and <code>int*</code> are possible candidates; the compiler cannot choose which one you want.  </p>\n<p>The eaiest to do is to use a cast to resolve the choice.  For example: </p>\n<pre><code>delete (int*)vec.front();\n</code></pre>\n<p><strong>Remark:</strong>  it works when you use a <code>get()</code> function instead of a conversion, because the rules are different.  The choice of the overloaded function is based on the type of the parameters and the object and not on the return type. Here the non const is the <a href=\"http://ideone.com/NEazSu\" rel=\"nofollow\">best viable</a> function as  <code>vec.front()</code>is not const. </p>\n", "LastEditorUserId": "3723423", "LastActivityDate": "2015-12-19T15:58:23.470", "Score": "1", "CreationDate": "2015-12-19T15:12:22.013", "ParentId": "34371901", "CommentCount": "1", "OwnerUserId": "3723423", "LastEditDate": "2015-12-19T15:58:23.470"}, "34372209": {"Id": "34372209", "PostTypeId": "2", "Body": "<p>[expr.delete]/1:</p>\n<blockquote>\n<p id=\"so_34371901_34372209_0\">The operand shall be of pointer to object type or of class type. If of\n  class type, the operand is contextually implicitly converted (Clause\n  [conv]) to a pointer to object type.</p>\n</blockquote>\n<p>[conv]/5, emphasis mine:</p>\n<blockquote>\n<p id=\"so_34371901_34372209_1\">Certain language constructs require conversion to a value having one\n  of a specified set of types appropriate to the construct. An\n  expression <code>e</code> of class type <code>E</code> appearing in such a context is said\n  to be <em>contextually implicitly converted</em> to a specified type <code>T</code> and\n  is well-formed if and only if e can be implicitly converted to a type\n  <code>T</code> that is determined as follows: <code>E</code> is searched for non-explicit\n  conversion functions whose return type is <code>cv T</code> or reference to <code>cv T</code>\n  such that <code>T</code> is allowed by the context. <strong>There shall be exactly\n  one such <code>T</code>.</strong></p>\n</blockquote>\n<p>In your code, there are two such <code>T</code>s (<code>int *</code> and <code>const int *</code>). It is therefore ill-formed, before you even get to overload resolution.</p>\n<hr>\n<p>Note that there's a change in this area between C++11 and C++14. C++11 [expr.delete]/1-2 says</p>\n<blockquote>\n<p id=\"so_34371901_34372209_2\">The operand shall have a pointer to object type, or a class type\n  having a single non-explicit conversion function (12.3.2) to a pointer\n  to object type. [...]</p>\n<p id=\"so_34371901_34372209_3\">If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, [...]</p>\n</blockquote>\n<p>Which would, if read literally, permit your code and always call <code>operator const int*() const</code>, because <code>int* &amp;</code> is a reference type, not a pointer to object type. In practice, implementations consider conversion functions to \"reference to pointer to object\" like <code>operator int*&amp;()</code> as well, and then reject the code because it has more than one qualifying non-explicit conversion function.</p>\n</hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2015-12-19T15:22:30.160", "Score": "8", "CreationDate": "2015-12-19T15:14:35.837", "ParentId": "34371901", "CommentCount": "2", "OwnerUserId": "2756719", "LastEditDate": "2015-12-19T15:22:30.160"}, "34371901": {"ViewCount": "235", "Body": "<p>I was trying to post this code as an answer to <a href=\"https://stackoverflow.com/questions/34371345/how-to-prevent-a-function-which-filters-vector-of-pointers-from-non-const-access\">this question</a>, by making this pointer wrapper (replacing raw pointer). The idea is to delegate <code>const</code> to its pointee, so that the <code>filter</code> function can't modify the values.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nclass my_pointer\n{\n    T *ptr_;\n\npublic:\n    my_pointer(T *ptr = nullptr) : ptr_(ptr) {}\n\n    operator T* &amp;()             { return ptr_; }\n    operator T const*() const   { return ptr_; }\n};\n\nstd::vector&lt;my_pointer&lt;int&gt;&gt; filter(std::vector&lt;my_pointer&lt;int&gt;&gt; const&amp; vec)\n{\n    //*vec.front() = 5; // this is supposed to be an error by requirement\n    return {};\n}\n\nint main()\n{\n    std::vector&lt;my_pointer&lt;int&gt;&gt; vec = {new int(0)};\n    filter(vec);\n    delete vec.front(); // ambiguity with g++ and clang++\n}\n</code></pre>\n<p>Visual C++ 12 and 14 compile this without an error, but GCC and <a href=\"http://coliru.stacked-crooked.com/a/a22d22faa0b0c986\" rel=\"nofollow noreferrer\">Clang on Coliru</a> claim that there's an ambiguity. I was expecting them to choose non-const <code>std::vector::front</code> overload and then <code>my_pointer::operator T* &amp;</code>, but no. Why's that?</p>\n", "AcceptedAnswerId": "34372209", "Title": "g++ and clang++ - delete pointer acquired by overloaded conversion operator ambiguity", "CreationDate": "2015-12-19T14:36:40.623", "Id": "34371901", "CommentCount": "2", "LastEditDate": "2017-05-23T12:31:43.057", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-04T16:30:58.893", "Score": "5", "OwnerUserId": "3552770", "Tags": "<c++><c++11><c++14><ambiguous>", "AnswerCount": "2"}});