post_cb({"12059282": {"PostTypeId": "2", "Body": "<p>Yes, you can do that, as long as the buffer is never empty.</p>\n<p>If the vector is ever empty, then <code>&amp;buffer[0]</code> is an error, and it will likely crash even though the called function wouldn't normally dereference the pointer because the size is 0.</p>\n", "LastActivityDate": "2012-08-21T16:31:47.717", "Id": "12059282", "CommentCount": "0", "CreationDate": "2012-08-21T16:31:47.717", "ParentId": "12058838", "Score": "3", "OwnerUserId": "1386054"}, "12058838": {"ViewCount": "741", "Body": "<p>I want to rewrite some code that uses a lot of <code>unsigned char</code> arrays, to instead make use of <code>std::vector&lt;unsigned char&gt;</code> objects. The problem I have is that these are currently used to store the data that will be written to either a serial port or socket write buffer and the library functions to do this take either <code>void*</code> or <code>unsigned char*</code> . An example of such a function is</p>\n<pre><code>  WriteToSocketBuffer(unsigned char* pBuffer, int iSize);\n</code></pre>\n<p>so currently I have code of the form</p>\n<pre><code> unsigned char* pArray = new unsigned char[iSize];\n //   populate array with data\n WriteToSocketBuffer(pArray,iSize);\n delete [] pArray;\n</code></pre>\n<p>My question is the following: If I change my class to have a <code>std::vector&lt;unsigned char&gt;</code> instead of a raw array can I simply call my library function using</p>\n<pre><code>  std::vector&lt;unsigned char&gt; myVector;\n  WriteToSocketBuffer(&amp;myVector[0],myVector.size());\n</code></pre>\n<p>Does passing the address of the first element in the vector act in the same was as passing in the address of the first element in a raw array. Is it this simple?</p>\n", "AcceptedAnswerId": "12058871", "Title": "Can I call functions that take an array/pointer argument using a std::vector instead?", "CreationDate": "2012-08-21T16:02:29.913", "Id": "12058838", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2012-08-21T16:31:47.717", "Score": "5", "OwnerUserId": "1342730", "Tags": "<c++><arrays><pointers><stl><vector>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_12058838_12058871_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 955}}, "n3337": {"so_12058838_12058871_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 943}}}, "12058871": {"PostTypeId": "2", "Body": "<p>Yes, The elements of a vector are assured to be contiguous similar to an array.</p>\n<p>Reference:    </p>\n<p><strong>C++03 Standard:</strong> <strong>[lib.vector] 23.2.4 Class template vector</strong> </p>\n<blockquote>\n<p id=\"so_12058838_12058871_0\">......<br>\n<strong>The elements of a vector are stored contiguously</strong>, meaning that if <code>v</code> is a <code>vector&lt;T, Allocator&gt;</code> where <code>T</code> is some type other than <code>bool</code>, then it obeys the identity <code>&amp;v[n] == &amp;v[0] + n</code> for all <code>0 &lt;= n &lt; v.size()</code></br></p>\n</blockquote>\n", "LastActivityDate": "2012-08-21T16:19:33.443", "LastEditorUserId": "36565", "Id": "12058871", "CommentCount": "1", "CreationDate": "2012-08-21T16:04:45.563", "ParentId": "12058838", "Score": "12", "OwnerUserId": "452307", "LastEditDate": "2012-08-21T16:19:33.443"}, "12058905": {"PostTypeId": "2", "Body": "<p>C++98 didn't mandate contiguous allocation for the data in an <code>std::vector</code>, but that's what all known implementations did anyway.</p>\n<p>As of C++03, that was standardized as a requirement, so it's now required, not just how things happen to be.</p>\n", "LastActivityDate": "2012-08-21T16:07:17.487", "Id": "12058905", "CommentCount": "0", "CreationDate": "2012-08-21T16:07:17.487", "ParentId": "12058838", "Score": "6", "OwnerUserId": "179910"}});