post_cb({"38669010": {"CommentCount": "2", "ViewCount": "239", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2016-07-29T23:55:24.310", "LastActivityDate": "2016-07-30T03:41:39.503", "Title": "C++11: reinterpreting array of structs as array of struct's member", "AcceptedAnswerId": "38669123", "LastEditDate": "2016-07-30T00:02:37.093", "Id": "38669010", "Score": "11", "Body": "<p>Consider the following type:</p>\n<pre><code>struct S\n{\n    char v;\n};\n</code></pre>\n<p>Given an array of <code>const S</code>, is it possible to, <em>in a standard conformant way</em>, reinterpret it as an array of <code>const char</code> whose elements correspond to the value of the member <code>v</code> for each of the original array's elements, and vice-versa? For example:</p>\n<pre><code>const S a1[] = { {'a'}, {'4'}, {'2'}, {'\\0'} };\nconst char* a2 = reinterpret_cast&lt; const char* &gt;(a1);\n\nfor (int i = 0; i &lt; 4; ++i)\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (a1[i].v == a2[i]) &lt;&lt; ' ';\n</code></pre>\n<p>Is the code above portable and would it print <code>true true true true</code>? If not, is there any other way of achieving this?</p>\n<p>Obviously, it is possible to create a new array and initialize it with the member <code>v</code> of each element of the original array, but the whole idea is to avoid creating a new array.</p>\n", "Tags": "<c++><c++11><reinterpret-cast>", "OwnerUserId": "4551082", "AnswerCount": "4"}, "38669123": {"ParentId": "38669010", "LastEditDate": "2016-07-30T03:41:39.503", "CommentCount": "14", "CreationDate": "2016-07-30T00:12:10.390", "Score": "6", "LastEditorUserId": "464581", "PostTypeId": "2", "Id": "38669123", "OwnerUserId": "464581", "Body": "<p>Formally the <code>struct</code> may have padding so that its size is greater than 1.</p>\n<p>I.e., formally you can't <code>reinterpret_cast</code> and have fully portable code, except for \u00b9an array of only one item.</p>\n<p>But for the in-practice, some years ago someone asked if there was now any compiler that by default would give <code>sizeof(T) &gt; 1</code> for <code>struct T{ char x; };</code>. I have yet to see any example. So in practice one can just <code>static_assert</code> that the size is 1, and not worry at all that this <code>static_assert</code> will fail on some system.</p>\n<p>I.e.,</p>\n<pre><code>S const a1[] = { {'a'}, {'4'}, {'2'}, {'\\0'} };\nstatic_assert( sizeof( S ) == 1, \"!\" );\n\nchar const* const a2 = reinterpret_cast&lt;char const*&gt;( a1 );\n\nfor( int i = 0; i &lt; 4; ++i )\n{\n    assert( a1[i].v == a2[i] );\n}\n</code></pre>\n<hr>\n<p>Since it's <em>possible</em> to interpret the C++14 and later standards in a way where the indexing has Undefined Behavior, based on a peculiar interpretation of \"array\" as referring to some original array, one might instead write this code in a more awkward and verbose but guaranteed valid way:</p>\n<pre><code>// I do not recommend this, but it's one way to avoid problems with some compiler that's\n// based on an unreasonable, impractical interpretation of the C++14 standard.\n#include &lt;assert.h&gt;\n#include &lt;new&gt;\n\nauto main() -&gt; int\n{\n    struct S\n    {\n        char v;\n    };\n\n    int const compiler_specific_overhead    = 0;    // Redefine per compiler.\n    // With value 0 for the overhead the internal workings here, what happens\n    // in the machine code, is the same as /without/ this verbose work-around\n    // for one impractical interpretation of the standard.\n    int const n = 4;\n    static_assert( sizeof( S ) == 1, \"!\" );\n    char storage[n + compiler_specific_overhead]; \n    S* const a1 = ::new( storage ) S[n];\n    assert( (void*)a1 == storage + compiler_specific_overhead );\n\n    for( int i = 0; i &lt; n; ++i ) { a1[i].v = \"a42\"[i]; }    //  Whatever\n\n    // Here a2 points to items of the original `char` array, hence no indexing\n    // UB even with impractical interpretation of the C++14 standard.\n    // Note that the indexing-UB-free code from this point, is exactly the same\n    // source code as the first code example that some claim has indexing UB.\n    char const* const a2 = reinterpret_cast&lt;char const*&gt;( a1 );\n\n    for( int i = 0; i &lt; n; ++i )\n    {\n        assert( a1[i].v == a2[i] );\n    }\n}\n</code></pre>\n<hr>\n<p><sup>\n<em>Notes:</em><br>\n\u00b9 The standard guarantees that there's no padding at the start of the <code>struct</code>.\n</br></sup></p>\n</hr></hr>", "LastActivityDate": "2016-07-30T03:41:39.503"}, "38669571": {"ParentId": "38669010", "CommentCount": "2", "CreationDate": "2016-07-30T01:39:10.910", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "38669571", "Score": "2", "Body": "<p>I think I'd be inclined to use a compile-time transformation if the source data is constant:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nstruct S\n{\n    char v;\n};\n\nnamespace detail {\n    template&lt;std::size_t...Is&gt;\n    constexpr auto to_cstring(const S* p, std::index_sequence&lt;Is...&gt;)\n    {\n        return std::array&lt;char, sizeof...(Is)&gt; {\n            p[Is].v...\n        };\n    }\n}\n\ntemplate&lt;std::size_t N&gt;\nconstexpr auto to_cstring(const S (&amp;arr)[N])\n{\n    return detail::to_cstring(arr, std::make_index_sequence&lt;N&gt;());\n}\n\nint main()\n{\n    const /*expr if you wish*/ S a1[] = { {'a'}, {'4'}, {'2'}, {'\\0'} };\n\n    const /*expr if you wish*/ auto a2 = to_cstring(a1);\n\n\n    for (int i = 0; i &lt; 4; ++i)\n        std::cout &lt;&lt; std::boolalpha &lt;&lt; (a1[i].v == a2[i]) &lt;&lt; ' ';\n}\n</code></pre>\n<p>output:</p>\n<pre><code>true true true true\n</code></pre>\n<p>even when the data is not a constexpr, gcc and clang are pretty good at constant folding complex sequences like this.</p>\n", "LastActivityDate": "2016-07-30T01:39:10.910"}, "38669109": {"ParentId": "38669010", "CommentCount": "3", "CreationDate": "2016-07-30T00:08:52.940", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "38669109", "Score": "8", "Body": "<p>Trivially, no - the <code>struct</code> may have padding. And that flat out breaks any reinterpretation as an array.</p>\n", "LastActivityDate": "2016-07-30T00:08:52.940"}, "bq_ids": {"n4140": {"so_38669010_38669662_0": {"section_id": 6144, "quality": 0.8387096774193549, "length": 26}}, "n4659": {"so_38669010_38669662_0": {"section_id": 7640, "quality": 0.8709677419354839, "length": 27}}}, "38669662": {"ParentId": "38669010", "LastEditDate": "2016-07-30T02:04:24.397", "CommentCount": "15", "CreationDate": "2016-07-30T01:55:55.163", "Score": "4", "LastEditorUserId": "981959", "PostTypeId": "2", "Id": "38669662", "OwnerUserId": "981959", "Body": "<p>The pointer arithmetic in <code>a2[i]</code> is undefined, see C++14 5.7 [expr.add] p7:</p>\n<blockquote>\n<p id=\"so_38669010_38669662_0\">For addition or subtraction, if the expressions <code>P</code> or <code>Q</code> have type \"pointer to <em>cv</em> <code>T</code>\", where <code>T</code> and the array element type are not similar (4.5), the behavior is undefined. [ Note: In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type. \u2014 end note ]</p>\n</blockquote>\n<p>Because of this rule, even if there is no padding and the sizes match, type-based alias analysis allows the compiler to assume that <code>a1[i]</code> and <code>a2[i]</code> do not overlap (because the pointer arithmetic is only valid if <code>a2</code> really is an array of <code>char</code> not just something with the same size and alignment, and if it's really an array of <code>char</code> it must be a separate object from an array of <code>S</code>).</p>\n", "LastActivityDate": "2016-07-30T02:04:24.397"}});