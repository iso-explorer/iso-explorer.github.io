post_cb({"35361496": {"ParentId": "35361408", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><code>std::initializer_list</code> can't be deduced by a template argument, which means you'll have to tell the lambda what it is explicitly:</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    auto foo = []() -&gt; std::initializer_list&lt;int&gt; { return {1, 2}; };\n    std::vector&lt;int&gt; bar{foo()};\n    for (int x : bar) { std::cout &lt;&lt; x &lt;&lt; \"  \"; };\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a57d386394368219\" rel=\"nofollow\">Demo</a>.  Here's the rationale behind this from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf\" rel=\"nofollow\">initializer list proposal</a>:</p>\n<blockquote>\n<p id=\"so_35361408_35361496_0\">Can an initializer list be used as a template argument? Consider: </p>\n<pre><code>template&lt;class T&gt; void f(const T&amp;);\nf({ }); // error\nf({1});\nf({1,2,3,4,5,6});\nf({1,2.0}); // error\nf(X{1,2.0}); // ok: T is X\n</code></pre>\n<p id=\"so_35361408_35361496_1\">There is obviously no problem with the last call (provided <strong>X{1,2.0}</strong> itself is valid)<br>\n  because the template argument is an <strong>X</strong>. Since we are not introducing arbitrary lists of<br>\n  types (product types), we cannot deduce <strong>T</strong> to be <strong>{int,double}</strong> for <strong>f({1,2.0})</strong>, so that call is<br>\n  an error. Plain {} does not have a type, so <strong>f({})</strong> is also an error.  </br></br></br></p>\n<p id=\"so_35361408_35361496_2\">This leaves the homogeneous lists. Should <strong>f({1})</strong> and <strong>f({1,2,3,4,5,6})</strong> be accepted? If so,<br>\n  with what meaning? If so, the answer must be that the deduced type, <strong>T</strong>, is<br>\n<strong>initializer_list</strong>. Unless someone comes up with at least one good use of this simple<br>\n  feature (a homogeneous list of elements of type <strong>E</strong> is deduced to be an<br>\n<strong>initializer_list</strong>), we won\u2019t propose it and all the examples will be  errors: No template<br>\n  argument can be deduced from an (unqualified) initializer list. One reason to be cautious<br>\n  here is that we can imagine someone getting confused about the possible interpretations<br>\n  of single-element lists. For example, could <strong>f({1})</strong> invoke <strong>f&lt;int&gt;(1)</strong>? No, that would be<br>\n  quite inconsistent. </br></br></br></br></br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "4859885", "LastEditorUserId": "4859885", "LastEditDate": "2016-10-10T20:38:58.713", "Id": "35361496", "Score": "5", "CreationDate": "2016-02-12T11:29:36.603", "LastActivityDate": "2016-10-10T20:38:58.713"}, "35361408": {"CommentCount": "4", "AcceptedAnswerId": "35361729", "PostTypeId": "1", "LastEditorUserId": "4523099", "CreationDate": "2016-02-12T11:25:01.427", "LastActivityDate": "2017-08-01T00:08:20.240", "LastEditDate": "2017-08-01T00:08:20.240", "ViewCount": "1256", "FavoriteCount": "1", "Title": "Why I can not return initializer list from lambda", "Id": "35361408", "Score": "14", "Body": "<p>Why this code is not valid?</p>\n<pre><code>  auto foo=[](){\n    return {1,2};     \n  };\n</code></pre>\n<p>However, this is valid since the <code>initializer list</code> is used just to initialize a <code>vector</code> not to return itself:</p>\n<pre><code>auto foo=[]()-&gt;std::vector&lt;int&gt;{\n  return {1,2};     \n};\n</code></pre>\n<p>Why I can not return <code>initializer list</code>? It could be useful. For example, a lambda that can be used to initialize a <code>vector</code> or a <code>list</code> or ... with some default values for something.</p>\n", "Tags": "<c++><c++11><lambda><c++14><initializer-list>", "OwnerUserId": "4523099", "AnswerCount": "3"}, "35361729": {"ParentId": "35361408", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Lambda return type deduction uses the <code>auto</code> rules, which normally would have deduced <code>std::initializer_list</code> just fine. However, the language designers banned deduction from a braced initializer list in a return statement ([dcl.spec.auto]/7):</p>\n<blockquote>\n<p id=\"so_35361408_35361729_0\">If the deduction is for a <code>return</code> statement and the initializer is a\n  <em>braced-init-list</em> ([dcl.init.list]), the program is ill-formed.</p>\n</blockquote>\n<p>The reason for this is that <code>std::initializer_list</code> has reference semantics (<a href=\"http://eel.is/c++draft/dcl.init.list#6\" rel=\"noreferrer\">[dcl.init.list]/6</a>). <br/> <code>[]() -&gt; std::initializer_list&lt;int&gt; { return {1, 2}; }</code> is every bit as bad as <br/><code>[]() -&gt; const int &amp; { return 1; }</code>. The lifetime of the backing array of the <code>initializer_list</code> object ends when the lambda returns, and you are left with a dangling pointer (or two).</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4833dabea31f75ca\" rel=\"noreferrer\">Demo</a>:</p>\n<pre><code>#include &lt;vector&gt;\n\nstruct Noisy {\n    Noisy()  { __builtin_printf(\"%s\\n\", __PRETTY_FUNCTION__); }\n    Noisy(const Noisy&amp;) { __builtin_printf(\"%s\\n\", __PRETTY_FUNCTION__); }\n    ~Noisy() { __builtin_printf(\"%s\\n\", __PRETTY_FUNCTION__); }\n};\n\nint main()\n{\n    auto foo = []() -&gt; std::initializer_list&lt;Noisy&gt; { return {Noisy{}, Noisy{}}; };\n    std::vector&lt;Noisy&gt; bar{foo()};\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Noisy::Noisy()\nNoisy::Noisy()\nNoisy::~Noisy()\nNoisy::~Noisy()\nNoisy::Noisy(const Noisy&amp;)\nNoisy::Noisy(const Noisy&amp;)\nNoisy::~Noisy()\nNoisy::~Noisy()\n</code></pre>\n<p>Note how the copy constructors are called after all the <code>Noisy</code> objects created so far have been destroyed already.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2016-02-12T11:58:55.737", "Id": "35361729", "Score": "18", "CreationDate": "2016-02-12T11:41:33.260", "LastActivityDate": "2016-02-12T11:58:55.737"}, "bq_ids": {"n4140": {"so_35361408_35361496_0": {"section_id": 302, "quality": 0.6666666666666666, "length": 4}, "so_35361408_35361729_0": {"section_id": 5451, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_35361408_35361496_0": {"section_id": 293, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_35361408_35361496_0": {"section_id": 309, "quality": 0.6666666666666666, "length": 4}, "so_35361408_35361729_0": {"section_id": 6888, "quality": 0.7142857142857143, "length": 5}}}, "35361704": {"ParentId": "35361408", "CommentCount": "0", "Body": "<p>You can return an <code>initializer_list</code> from the function either like that:</p>\n<pre><code>return std::initializer_list&lt;int&gt;{1, 2};\n</code></pre>\n<p>or</p>\n<pre><code>auto ret = {1, 2};\nreturn ret;\n</code></pre>\n<p>The reason is, that the <code>auto</code> variable declaration uses different rules than the <code>auto</code> return type deduction. The first one has a special rule for this case, and the second one uses plain template type deduction.</p>\n<p>This is discussed at length in Scott Meyers Effective Modern C++, Item 2. There is also a <a href=\"https://www.youtube.com/watch?v=wQxj20X-tIU\" rel=\"nofollow\">video</a> and <a href=\"http://www.aristeia.com/TalkNotes/C++TypeDeductionandWhyYouCareCppCon2014.pdf\" rel=\"nofollow\">slides</a> from him about the topic.</p>\n", "OwnerUserId": "620382", "PostTypeId": "2", "Id": "35361704", "Score": "1", "CreationDate": "2016-02-12T11:40:33.110", "LastActivityDate": "2016-02-12T11:40:33.110"}});