post_cb({"11262385": {"ParentId": "11262367", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is likely an effect of <a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow\">copy elision</a>. The compiler is free to avoid copying objects wherever it doesn't make an impact on the program. Side effects of copy-constructor/destructor are not considered as an impact on the program in this caser. In general it will avoid copying a temporary for use as a function parameter, since the temporary would be destroyed afterwards anyways.</p>\n<p>This can be found in \u00a712.8.32 in the standard:</p>\n<blockquote>\n<p id=\"so_11262367_11262385_0\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class  object, even if the copy/move\n  constructor and/or destructor for the object have side e\ufb00ects. In such\n  cases,  the implementation treats the source and target of the omitted\n  copy/move operation as simply two di\ufb00erent  ways of referring to the\n  same object, and the destruction of that object occurs at the later of\n  the times when the two objects would have been destroyed without the\n  optimization. This elision of copy/move \n  operations, called copyelision, is permitted in the following\n  circumstances (which maybe combined to  eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when    the expression is the name of a non-volatile automatic object with<br>\n  the same cv-unquali\ufb01ed type as the function return type, the<br>\n  copy/move operation can be omitted by constructing the automatic<br>\n  object directly into the function\u2019s return value</br></br></br></li>\n<li>in a throw-expression, when the operand is the name of a non-volatile    automatic object whose scope does not extend beyond\n  the end of the    innermost enclosing try-block (if there is one), the\n  copy/move    operation from the operand to the exception object (15.1)\n  can be    omitted by constructing the automatic object directly into\n  the    exception object</li>\n<li>when a temporary class object that has not been bound to  a reference    (12.2) would becopied/moved to a class object witht he\n  same    cv-unquali\ufb01ed type, the copy/move operation can be omitted by \n  constructing the temporary object directly into the target of the<br>\n  omitted copy/move </br></li>\n<li>when the exception-declaration of an exception handler (Clause 15)       declares an object of the same type (except for cv-quali\ufb01cation) as<br>\n  the exception object (15.1), the copy/move operation can be omitted<br>\n  bytreatingthe exception-declaration as an alias for the exception<br>\n  object if the meaning of the program will be unchanged except for the \n  execution of constructors and destructors for the object declared by<br>\n  the exception-declaration.</br></br></br></br></li>\n</ul>\n</blockquote>\n<p>In this case it will likely simply use the object returned by <code>f</code> as input for the <code>operator=</code>, since it is a temporary and would therefore be destroyed right afterwards anyways.</p>\n", "OwnerUserId": "201270", "LastEditorUserId": "201270", "LastEditDate": "2012-06-29T13:26:29.730", "Id": "11262385", "Score": "3", "CreationDate": "2012-06-29T13:07:55.210", "LastActivityDate": "2012-06-29T13:26:29.730"}, "11262367": {"CommentCount": "1", "ViewCount": "158", "PostTypeId": "1", "ClosedDate": "2012-06-29T13:16:54.103", "LastEditorUserId": "-1", "CreationDate": "2012-06-29T13:06:33.557", "LastActivityDate": "2012-06-29T13:26:29.730", "Title": "Copy Constructor didn't call, why?", "LastEditDate": "2017-05-23T12:27:52.157", "Id": "11262367", "Score": "1", "Body": "<blockquote>\n<p id=\"so_11262367_11262367_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/1758142/why-copy-constructor-is-not-called-in-this-case\">Why copy constructor is not called in this case?</a> </br></p>\n</blockquote>\n<p>I have following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;new&gt;\n\nusing namespace std;\n\nclass test {  \n    int *p;  \npublic:\n    test operator=(test a);\n    test()  {\n        p = new int [2];\n        cout &lt;&lt;\"Default Constructor was done here.\" &lt;&lt; \"\\n\";\n    }\n\n    test(const test &amp;a) {\n        p = new int [2];\n        this-&gt;p[0] = a.p[0];\n        this-&gt;p[1] = a.p[1];\n        cout &lt;&lt; \"Copy Constructor was done here.\" &lt;&lt; \"\\n\";\n    }\n\n    ~test() {\n        delete p;\n        cout &lt;&lt; \"Destructor was done here.\" &lt;&lt; \"\\n\";\n    }\n    int set (int a, int b) {\n        p[0] = a;\n        p[1] = b;\n        return 1;\n    }\n\n    int show () {\n        cout &lt;&lt; p[0] &lt;&lt; \" \" &lt;&lt; p[1] &lt;&lt; \"\\n\";\n        return 2;\n    }\n};    \n\ntest test::operator=(test a) {\n    p[0] = a.p[0]; \n    p[1] = a.p[1]; \n    cout &lt;&lt; \"Operator = was done here\" &lt;&lt; \"\\n\";\n    return *this;\n}\n\ntest f(test x) {\n    x.set(100, 100);\n    return x;\n}\n\nint main () {\n    test first;\n    test second;\n    first.set(12, 12);\n\n    //f(first);\n    //second = first;\n    second = f(first);\n\n\n    first.show();\n    second.show();\n\n    getchar ();\n    return 0;\n}\n</code></pre>\n<p>Copy Constructor was called only three times? Why?\nIf I understand, we made four copies (we send object to func, func returns value, we send object to operator=, operator= returns value).</p>\n", "Tags": "<c++>", "OwnerUserId": "1491182", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11262367_11262385_0": {"section_id": 480, "quality": 0.9047619047619048, "length": 57}}, "n3337": {"so_11262367_11262385_0": {"section_id": 471, "quality": 0.9206349206349206, "length": 58}}, "n4659": {"so_11262367_11262367_0": {"section_id": 396, "quality": 0.5714285714285714, "length": 4}, "so_11262367_11262385_0": {"section_id": 502, "quality": 0.9047619047619048, "length": 57}}}});