post_cb({"23294156": {"Id": "23294156", "PostTypeId": "2", "Body": "<p>Nested member of friend class has access to names of private and protected members of class granting friendship.</p>\n<p>C++ Standard n3337 11.3 <strong>\u00a7</strong>  2:</p>\n<blockquote>\n<p id=\"so_23293561_23294156_0\">Declaring a class to be a friend implies that the names of private and\n  protected members from the class granting friendship can be accessed\n  in the base-specifiers <strong>and member declarations of the befriended\n  class</strong>. [ Example:</p>\n<pre><code>class A {           // *your Foo\n\n    class B { };    // *private \n\n    friend class X; // *your Bar\n</code></pre>\n<p id=\"so_23293561_23294156_1\">}; </p>\n<pre><code>struct X : A::B { // OK: A::B accessible to friend\n\n    A::B mx;      // OK: A::B accessible to member of friend\n\n    class Y {       // *your Impl\n\n        A::B my;  // OK: A::B accessible to nested member of friend\n\n    }; \n};\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2014-04-25T13:27:25.903", "Score": "1", "CreationDate": "2014-04-25T13:10:43.377", "ParentId": "23293561", "CommentCount": "0", "OwnerUserId": "1141471", "LastEditDate": "2014-04-25T13:27:25.903"}, "23294004": {"Id": "23294004", "PostTypeId": "2", "Body": "<p>Well, this is an interesting question. However, the reason is plain: nested classes are members of their enclosing class. And as members they have access rights to all the other members of the enclosing class and to all of its friends. The C++03 standard states so (\u00a79.2/1 (C++03)) </p>\n", "LastActivityDate": "2014-04-25T13:04:12.707", "CommentCount": "0", "CreationDate": "2014-04-25T13:04:12.707", "ParentId": "23293561", "Score": "0", "OwnerUserId": "3563431"}, "bq_ids": {"n4140": {"so_23293561_23294156_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6685}}, "n3337": {"so_23293561_23294156_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6440}}, "n4659": {"so_23293561_23294156_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 8160}}}, "23293561": {"ViewCount": "781", "Body": "<p>This code seems to work, but I'm not sure why:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo {\n  friend class Bar;\npublic:\n  void printNum() {std::cout &lt;&lt; num_ &lt;&lt; \"\\n\";}\nprivate:\n  // This constructor is private, should be accessible only to Bar\n  Foo(int num) : num_(num) {}\n  int num_;\n};\n\nclass Bar {\npublic:\n  Bar(int num);\n  void printFooNum();\n  ~Bar();\nprivate:\n  class Impl_;\n  Impl_ * pImpl_;\n};\n\nstruct Bar::Impl_ {\n  Impl_(int num);\n  Foo foo_;\n};\n\nBar::Impl_::Impl_(int num)\n  : foo_(num)\n{}\n\nBar::Bar(int num)\n  : pImpl_(new Impl_(num))\n{}\n\nvoid Bar::printFooNum() {\n  pImpl_-&gt;foo_.printNum();\n}\n\nBar::~Bar() { delete pImpl_;}\n\nint main() {\n  Bar bar(5);\n\n  bar.printFooNum();\n\n  return 0;\n}\n</code></pre>\n<p>Here, I'm trying to ensure that objects of class <code>Foo</code> can be constructed inside an object of class <code>Bar</code>, which is implemented using the pImpl pattern. I actually don't mind that the constructor <code>Bar::Impl_()</code> is apparently able to call the <code>Foo</code> constructor, but I'm not sure why that should work. This code was compiled using several different compilers (both GCC and Intel), and it seems to give me the desired result, but I'm not sure if that's because the compilers are being permissive or if the code is actually correct.</p>\n<p>Why does it seem that <code>Bar::Impl_()</code> can call the <code>Foo</code> constructor when <code>Foo</code> has only befriended <code>Bar</code> and not <code>Bar::Impl_</code>?</p>\n", "Title": "Nested class constructor calls private constructor, and it works?", "CreationDate": "2014-04-25T12:44:25.630", "LastActivityDate": "2014-04-25T13:27:25.903", "CommentCount": "0", "LastEditDate": "2014-04-25T12:49:47.903", "PostTypeId": "1", "LastEditorUserId": "1639256", "Id": "23293561", "Score": "3", "OwnerUserId": "1643973", "Tags": "<c++><constructor><friend>", "AnswerCount": "4"}, "23293918": {"Id": "23293918", "PostTypeId": "2", "Body": "<p>Nested classes have the same access rights as methods: they have access to <code>private</code> parts of the containing class,</p>\n<pre><code>class Outer {\n    struct Nested {\n        static void touch_private(Outer &amp;x) {\n            x.private_member = 1;\n        }\n    };\n\n    int private_member;\n\n  public:\n    Nested() {\n        Inner::touch_private(*this);\n    }\n};\n</code></pre>\n<p>... and to the outer class's friends, which are like its private parts. (Insert joke here.)</p>\n", "LastActivityDate": "2014-04-25T13:00:21.513", "CommentCount": "0", "CreationDate": "2014-04-25T13:00:21.513", "ParentId": "23293561", "Score": "0", "OwnerUserId": "166749"}, "23293824": {"Id": "23293824", "PostTypeId": "2", "Body": "<p>Apparently all members of a friend class have access to all members of the class that declared them friends. Since nested structs are treated as members, your nested Bar has access to all Foo's members. See here: <a href=\"http://www.drdobbs.com/friendly-nesting/184401866\" rel=\"nofollow\">http://www.drdobbs.com/friendly-nesting/184401866</a></p>\n", "LastActivityDate": "2014-04-25T12:55:56.017", "CommentCount": "1", "CreationDate": "2014-04-25T12:55:56.017", "ParentId": "23293561", "Score": "1", "OwnerUserId": "2899478"}});