post_cb({"bq_ids": {"n4140": {"so_25329576_25329691_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 6009}, "so_25329576_25329576_1": {"length": 51, "quality": 0.8225806451612904, "section_id": 6106}, "so_25329576_25329711_1": {"length": 34, "quality": 0.8947368421052632, "section_id": 6111}, "so_25329576_25329691_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 6009}, "so_25329576_25329576_3": {"length": 64, "quality": 1.0, "section_id": 6106}, "so_25329576_25329711_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 6110}}, "n3337": {"so_25329576_25329691_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 5777}, "so_25329576_25329691_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5777}, "so_25329576_25329576_3": {"length": 64, "quality": 1.0, "section_id": 5872}, "so_25329576_25329576_1": {"length": 51, "quality": 0.8225806451612904, "section_id": 5872}, "so_25329576_25329711_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5876}}, "n4659": {"so_25329576_25329691_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 7508}, "so_25329576_25329576_1": {"length": 51, "quality": 0.8225806451612904, "section_id": 7603}, "so_25329576_25329711_1": {"length": 34, "quality": 0.8947368421052632, "section_id": 7608}, "so_25329576_25329691_7": {"length": 5, "quality": 0.7142857142857143, "section_id": 7508}, "so_25329576_25329576_3": {"length": 64, "quality": 1.0, "section_id": 7603}, "so_25329576_25329711_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7607}}}, "25329576": {"ViewCount": "3052", "Body": "<p>In the C++03 Standard, I see:</p>\n<blockquote>\n<p id=\"so_25329576_25329576_0\"><strong>5.3.5 Delete</strong></p>\n<p id=\"so_25329576_25329576_1\">2 If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. <strong>In either alternative, if the value of the operand of <code>delete</code> is the null pointer the operation has no effect.</strong> In the first alternative (<em>delete object</em>), the value of the operand of <code>delete</code> shall be a pointer to a non-array object or a pointer to a sub-object (1.8) representing a base class of such an object (clause 10). If not, the behavior is undefined. In the second alternative (<em>delete array</em>), the value of the operand of <code>delete</code> shall be the pointer value which resulted from a previous array new-expression.72) If not, the behavior is undefined.</p>\n</blockquote>\n<p>In the C++11 Draft Standard (N3337), I see:</p>\n<blockquote>\n<p id=\"so_25329576_25329576_2\"><strong>5.3.5 Delete</strong></p>\n<p id=\"so_25329576_25329576_3\">2 If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned conversion function, and the converted operand is used in place of the original operand for the remainder of this section. In the first alternative (<em>delete object</em>), <strong>the value of the operand of <code>delete</code> may be a null pointer value,</strong> a pointer to a non-array object created by a previous <em>new-expression</em>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined. In the second alternative (<em>delete array</em>), the value of the operand of delete may be a null pointer value or a pointer value that resulted from a previous array <em>new-expression</em>. If not, the behavior is undefined.</p>\n</blockquote>\n<p>I have highlighted the differences between the specifications in the two standards. I find it strange that the 2003 standard was more emphatic on how NULL pointers must be dealt with while the 2011 standard says nothing about what an implementation must do.</p>\n<ol>\n<li><p>Did the verbiage of the C++11 standard change between the draft standard and the actual standard? If so, how?</p></li>\n<li><p>If the verbiage of the draft standard remains unchanged in the actual standard, what was the rationale for changing a very strong statement to almost nothing between 2003 and 2011?</p></li>\n</ol>\n", "AcceptedAnswerId": "25329691", "Title": "Calling delete on NULL pointers - C++03 vs C++11", "CreationDate": "2014-08-15T15:44:11.423", "Id": "25329576", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-08-16T01:58:32.830", "LastEditorUserId": "1708801", "LastActivityDate": "2017-06-30T19:04:58.437", "Score": "22", "OwnerUserId": "434551", "Tags": "<c++><c++11><language-lawyer><c++03><delete-operator>", "AnswerCount": "2"}, "25329691": {"Id": "25329691", "PostTypeId": "2", "Body": "<p>It looks like we can find a rationale for this change in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3383.html#348\" rel=\"noreferrer\">defect report 348</a>, which says:</p>\n<blockquote>\n<p id=\"so_25329576_25329691_0\">Specifically, standard says in 5.3.5 [expr.delete] paragraph 2:</p>\n<blockquote>\n<p id=\"so_25329576_25329691_7\">...if the value of the operand of delete is the null pointer the operation has no effect.</p>\n</blockquote>\n<p id=\"so_25329576_25329691_2\">Standard doesn't specify term \"has no effect\". It is not clear from\n  this context, whether the called deallocation function is required to\n  have no effect, or delete-expression shall not call the deallocation\n  function.</p>\n<p id=\"so_25329576_25329691_3\">Furthermore, in para 4 standard says on default deallocation function:</p>\n<blockquote>\n<p id=\"so_25329576_25329691_8\">If the delete-expression calls the implementation deallocation\n    function (3.7.4.2 [basic.stc.dynamic.deallocation]), if the operand of\n    the delete expression is not the null pointer constant, ...</p>\n</blockquote>\n<p id=\"so_25329576_25329691_5\">Why it is so specific on interaction of default deallocation function and delete-expr?</p>\n<p id=\"so_25329576_25329691_6\">If \"has no effect\" is a requirement to the deallocation function, then\n  it should be stated in 3.7.4.2 [basic.stc.dynamic.deallocation], or in\n  18.6.1.1 [new.delete.single] and 18.6.1.2 [new.delete.array], and it should be stated explicitly.</p>\n</blockquote>\n<p>part of the resolution was the change in wording that you noted, although the language around that phrasing has changed quite a bit but the logic of getting rid of the <em>has no effect</em> language still stands, it is not a well defined term and so should be replaced with well specified language.</p>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2017-06-30T19:04:58.437", "Score": "25", "CreationDate": "2014-08-15T15:50:45.527", "ParentId": "25329576", "CommentCount": "1", "LastEditDate": "2017-06-30T19:04:58.437", "OwnerUserId": "1708801"}, "25329711": {"Id": "25329711", "PostTypeId": "2", "Body": "<p>The latest C++14 draft (N3797) has roughly equivalent wording in this section. But the behaviour is equally-strongly specified, just not in quite the same paragraph.</p>\n<blockquote>\n<p id=\"so_25329576_25329711_0\">If the value of the operand of the delete-expression is not a null\n  pointer value, the delete-expression will invoke the destructor (if\n  any) for the object or the elements of the array being deleted. In the\n  case of an array, the elements will be destroyed in order of\n  decreasing address (that is, in reverse order of the completion of\n  their constructor; see\n  12.6.2 ).</p>\n<p id=\"so_25329576_25329711_1\">If the value of the operand of the delete-expression is not a null\n  pointer value, then: \u2014 If the allocation call for the new-expression\n  for the object to be deleted was not omitted (\n  5.3.4 ), the delete-expression shall call a deallocation function (\n  3.7.4.2 ). The value returned from the allocation call of the new-expression shall be passed as the first argument to the\n  deallocation function. \u2014 Otherwise, the delete-expression will not\n  call a deallocation function (\n  3.7.4.2 ).</p>\n</blockquote>\n<p>These paragraphs are clearly just as strong as C++03. The Committee could not have broken the behaviour of programs which <code>delete</code> null pointers, as these are widespread and the cost of fixing would be much too large. It would have made C++11 unimplementable.</p>\n", "LastActivityDate": "2014-08-15T15:51:45.693", "Score": "10", "CreationDate": "2014-08-15T15:51:45.693", "ParentId": "25329576", "CommentCount": "9", "OwnerUserId": "298661"}});