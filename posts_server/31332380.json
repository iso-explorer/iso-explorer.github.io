post_cb({"31333627": {"ParentId": "31332380", "CommentCount": "0", "Body": "<p>There is no standard support for bigint in C++ unlike Python and Java. But there are many libraries that will provide you the required support. Here is an implementation of bigint in C++ that I use sometimes in competitive programming:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;string&gt;\n#include &lt;ctime&gt;\nusing namespace std;\n\nconst int base = 1000000000;\nconst int base_digits = 9;\n\nstruct bigint\n{\nvector&lt;int&gt; a;\nint sign;\n\nbigint() :\n    sign(1)\n{\n}\n\nbigint(long long v)\n{\n    *this = v;\n}\n\nbigint(const string &amp;s)\n{\n    read(s);\n}\n\nvoid operator=(const bigint &amp;v)\n{\n    sign = v.sign;\n    a = v.a;\n}\n\nvoid operator=(long long v)\n{\n    sign = 1;\n    if (v &lt; 0)\n        sign = -1, v = -v;\n    for (; v &gt; 0; v = v / base)\n        a.push_back(v % base);\n}\n\nbigint operator+(const bigint &amp;v) const\n{\n    if (sign == v.sign)\n    {\n        bigint res = v;\n\n        for (int i = 0, carry = 0; i &lt; (int) max(a.size(), v.a.size()) || carry; ++i)\n        {\n            if (i == (int) res.a.size())\n                res.a.push_back(0);\n            res.a[i] += carry + (i &lt; (int) a.size() ? a[i] : 0);\n            carry = res.a[i] &gt;= base;\n            if (carry)\n                res.a[i] -= base;\n        }\n        return res;\n    }\n    return *this - (-v);\n}\n\nbigint operator-(const bigint &amp;v) const\n{\n    if (sign == v.sign)\n    {\n        if (abs() &gt;= v.abs())\n        {\n            bigint res = *this;\n            for (int i = 0, carry = 0; i &lt; (int) v.a.size() || carry; ++i)\n            {\n                res.a[i] -= carry + (i &lt; (int) v.a.size() ? v.a[i] : 0);\n                carry = res.a[i] &lt; 0;\n                if (carry)\n                    res.a[i] += base;\n            }\n            res.trim();\n            return res;\n        }\n        return -(v - *this);\n    }\n    return *this + (-v);\n}\n\nvoid operator*=(int v)\n{\n    if (v &lt; 0)\n        sign = -sign, v = -v;\n    for (int i = 0, carry = 0; i &lt; (int) a.size() || carry; ++i)\n    {\n        if (i == (int) a.size())\n            a.push_back(0);\n        long long cur = a[i] * (long long) v + carry;\n        carry = (int) (cur / base);\n        a[i] = (int) (cur % base);\n    }\n    trim();\n}\n\nbigint operator*(int v) const\n{\n    bigint res = *this;\n    res *= v;\n    return res;\n}\n\nfriend pair&lt;bigint, bigint&gt; divmod(const bigint &amp;a1, const bigint &amp;b1)\n{\n    int norm = base / (b1.a.back() + 1);\n    bigint a = a1.abs() * norm;\n    bigint b = b1.abs() * norm;\n    bigint q, r;\n    q.a.resize(a.a.size());\n\n    for (int i = a.a.size() - 1; i &gt;= 0; i--)\n    {\n        r *= base;\n        r += a.a[i];\n        int s1 = r.a.size() &lt;= b.a.size() ? 0 : r.a[b.a.size()];\n        int s2 = r.a.size() &lt;= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];\n        int d = ((long long) base * s1 + s2) / b.a.back();\n        r -= b * d;\n        while (r &lt; 0)\n            r += b, --d;\n        q.a[i] = d;\n    }\n\n    q.sign = a1.sign * b1.sign;\n    r.sign = a1.sign;\n    q.trim();\n    r.trim();\n    return make_pair(q, r / norm);\n}\n\nbigint operator/(const bigint &amp;v) const\n{\n    return divmod(*this, v).first;\n}\n\nbigint operator%(const bigint &amp;v) const\n{\n    return divmod(*this, v).second;\n}\n\nvoid operator/=(int v)\n{\n    if (v &lt; 0)\n        sign = -sign, v = -v;\n    for (int i = (int) a.size() - 1, rem = 0; i &gt;= 0; --i)\n    {\n        long long cur = a[i] + rem * (long long) base;\n        a[i] = (int) (cur / v);\n        rem = (int) (cur % v);\n    }\n    trim();\n}\n\nbigint operator/(int v) const\n{\n    bigint res = *this;\n    res /= v;\n    return res;\n}\n\nint operator%(int v) const\n{\n    if (v &lt; 0)\n        v = -v;\n    int m = 0;\n    for (int i = a.size() - 1; i &gt;= 0; --i)\n        m = (a[i] + m * (long long) base) % v;\n    return m * sign;\n}\n\nvoid operator+=(const bigint &amp;v)\n{\n    *this = *this + v;\n}\nvoid operator-=(const bigint &amp;v)\n{\n    *this = *this - v;\n}\nvoid operator*=(const bigint &amp;v)\n{\n    *this = *this * v;\n}\nvoid operator/=(const bigint &amp;v)\n{\n    *this = *this / v;\n}\n\nbool operator&lt;(const bigint &amp;v) const\n{\n    if (sign != v.sign)\n        return sign &lt; v.sign;\n    if (a.size() != v.a.size())\n        return a.size() * sign &lt; v.a.size() * v.sign;\n    for (int i = a.size() - 1; i &gt;= 0; i--)\n        if (a[i] != v.a[i])\n            return a[i] * sign &lt; v.a[i] * sign;\n    return false;\n}\n\nbool operator&gt;(const bigint &amp;v) const\n{\n    return v &lt; *this;\n}\nbool operator&lt;=(const bigint &amp;v) const\n{\n    return !(v &lt; *this);\n}\nbool operator&gt;=(const bigint &amp;v) const\n{\n    return !(*this &lt; v);\n}\nbool operator==(const bigint &amp;v) const\n{\n    return !(*this &lt; v) &amp;&amp; !(v &lt; *this);\n}\nbool operator!=(const bigint &amp;v) const\n{\n    return *this &lt; v || v &lt; *this;\n}\n\nvoid trim()\n{\n    while (!a.empty() &amp;&amp; !a.back())\n        a.pop_back();\n    if (a.empty())\n        sign = 1;\n}\n\nbool isZero() const\n{\n    return a.empty() || (a.size() == 1 &amp;&amp; !a[0]);\n}\n\nbigint operator-() const\n{\n    bigint res = *this;\n    res.sign = -sign;\n    return res;\n}\n\nbigint abs() const\n{\n    bigint res = *this;\n    res.sign *= res.sign;\n    return res;\n}\n\nlong long longValue() const\n{\n    long long res = 0;\n    for (int i = a.size() - 1; i &gt;= 0; i--)\n        res = res * base + a[i];\n    return res * sign;\n}\n\nfriend bigint gcd(const bigint &amp;a, const bigint &amp;b)\n{\n    return b.isZero() ? a : gcd(b, a % b);\n}\nfriend bigint lcm(const bigint &amp;a, const bigint &amp;b)\n{\n    return a / gcd(a, b) * b;\n}\n\nvoid read(const string &amp;s)\n{\n    sign = 1;\n    a.clear();\n    int pos = 0;\n    while (pos &lt; (int) s.size() &amp;&amp; (s[pos] == '-' || s[pos] == '+'))\n    {\n        if (s[pos] == '-')\n            sign = -sign;\n        ++pos;\n    }\n    for (int i = s.size() - 1; i &gt;= pos; i -= base_digits)\n    {\n        int x = 0;\n        for (int j = max(pos, i - base_digits + 1); j &lt;= i; j++)\n            x = x * 10 + s[j] - '0';\n        a.push_back(x);\n    }\n    trim();\n}\n\nfriend istream&amp; operator&gt;&gt;(istream &amp;stream, bigint &amp;v)\n{\n    string s;\n    stream &gt;&gt; s;\n    v.read(s);\n    return stream;\n}\n\nfriend ostream&amp; operator&lt;&lt;(ostream &amp;stream, const bigint &amp;v)\n{\n    if (v.sign == -1)\n        stream &lt;&lt; '-';\n    stream &lt;&lt; (v.a.empty() ? 0 : v.a.back());\n    for (int i = (int) v.a.size() - 2; i &gt;= 0; --i)\n        stream &lt;&lt; setw(base_digits) &lt;&lt; setfill('0') &lt;&lt; v.a[i];\n    return stream;\n}\n\nstatic vector&lt;int&gt; convert_base(const vector&lt;int&gt; &amp;a, int old_digits, int new_digits)\n{\n    vector&lt;long long&gt; p(max(old_digits, new_digits) + 1);\n    p[0] = 1;\n    for (int i = 1; i &lt; (int) p.size(); i++)\n        p[i] = p[i - 1] * 10;\n    vector&lt;int&gt; res;\n    long long cur = 0;\n    int cur_digits = 0;\n    for (int i = 0; i &lt; (int) a.size(); i++)\n    {\n        cur += a[i] * p[cur_digits];\n        cur_digits += old_digits;\n        while (cur_digits &gt;= new_digits)\n        {\n            res.push_back(int(cur % p[new_digits]));\n            cur /= p[new_digits];\n            cur_digits -= new_digits;\n        }\n    }\n    res.push_back((int) cur);\n    while (!res.empty() &amp;&amp; !res.back())\n        res.pop_back();\n    return res;\n}\n\ntypedef vector&lt;long long&gt; vll;\n\nstatic vll karatsubaMultiply(const vll &amp;a, const vll &amp;b)\n{\n    int n = a.size();\n    vll res(n + n);\n    if (n &lt;= 32)\n    {\n        for (int i = 0; i &lt; n; i++)\n            for (int j = 0; j &lt; n; j++)\n                res[i + j] += a[i] * b[j];\n        return res;\n    }\n\n    int k = n &gt;&gt; 1;\n    vll a1(a.begin(), a.begin() + k);\n    vll a2(a.begin() + k, a.end());\n    vll b1(b.begin(), b.begin() + k);\n    vll b2(b.begin() + k, b.end());\n\n    vll a1b1 = karatsubaMultiply(a1, b1);\n    vll a2b2 = karatsubaMultiply(a2, b2);\n\n    for (int i = 0; i &lt; k; i++)\n        a2[i] += a1[i];\n    for (int i = 0; i &lt; k; i++)\n        b2[i] += b1[i];\n\n    vll r = karatsubaMultiply(a2, b2);\n    for (int i = 0; i &lt; (int) a1b1.size(); i++)\n        r[i] -= a1b1[i];\n    for (int i = 0; i &lt; (int) a2b2.size(); i++)\n        r[i] -= a2b2[i];\n\n    for (int i = 0; i &lt; (int) r.size(); i++)\n        res[i + k] += r[i];\n    for (int i = 0; i &lt; (int) a1b1.size(); i++)\n        res[i] += a1b1[i];\n    for (int i = 0; i &lt; (int) a2b2.size(); i++)\n        res[i + n] += a2b2[i];\n    return res;\n}\n\nbigint operator*(const bigint &amp;v) const\n{\n    vector&lt;int&gt; a6 = convert_base(this-&gt;a, base_digits, 6);\n    vector&lt;int&gt; b6 = convert_base(v.a, base_digits, 6);\n    vll a(a6.begin(), a6.end());\n    vll b(b6.begin(), b6.end());\n    while (a.size() &lt; b.size())\n        a.push_back(0);\n    while (b.size() &lt; a.size())\n        b.push_back(0);\n    while (a.size() &amp; (a.size() - 1))\n        a.push_back(0), b.push_back(0);\n    vll c = karatsubaMultiply(a, b);\n    bigint res;\n    res.sign = sign * v.sign;\n    for (int i = 0, carry = 0; i &lt; (int) c.size(); i++)\n    {\n        long long cur = c[i] + carry;\n        res.a.push_back((int) (cur % 1000000));\n        carry = (int) (cur / 1000000);\n    }\n    res.a = convert_base(res.a, 6, base_digits);\n    res.trim();\n    return res;\n}\n};\n\nint main()\n{\nbigint     a(\"99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\");\nbigint b(\"19999999999999999999999999999999999999999999999999999999999999999999999999999999999999998\");\ncout &lt;&lt; a * b &lt;&lt; endl;\ncout &lt;&lt; a / b &lt;&lt; endl;\n\nstring sa, sb;\nfor (int i = 0; i &lt; 100000; i++)\n    sa += i % 10 + '0';\nfor (int i = 0; i &lt; 20000; i++)\n    sb += i % 10 + '0';\na = bigint(sa);\nb = bigint(sb);\n\nclock_t start = clock();\nbigint c = a / b;\nfprintf(stderr, \"time=%.3lfsec\\n\", 0.001 * (clock() - start));\nreturn 0;\n}\n</code></pre>\n", "OwnerUserId": "1117699", "PostTypeId": "2", "Id": "31333627", "Score": "0", "CreationDate": "2015-07-10T06:10:47.403", "LastActivityDate": "2015-07-10T06:10:47.403"}, "31332657": {"ParentId": "31332380", "CommentCount": "2", "Body": "<p>You can write a function yourself:</p>\n<pre><code>unsigned int get_uint(const std::string &amp;s) {\n    unsigned int r = 0U;\n    for(auto c : s) {\n        assert(std::isdigit(c));\n        r = r * 10 + (c - '0');\n    }\n    return r;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/SsQjy0\" rel=\"nofollow\">Live example</a></p>\n<p>This works because <strong>unsigned overflow</strong> works as modulo arithmetic in C++.</p>\n<p>From 3.9.1/4</p>\n<blockquote>\n<p id=\"so_31332380_31332657_0\">Unsigned integers, declared unsigned, shall obey the laws of\n  arithmetic modulo 2^n where n is the number of bits in the value\n  representation of that particular size of integer</p>\n</blockquote>\n", "OwnerUserId": "2659313", "PostTypeId": "2", "Id": "31332657", "Score": "3", "CreationDate": "2015-07-10T04:48:50.047", "LastActivityDate": "2015-07-10T04:48:50.047"}, "31332380": {"CommentCount": "3", "ViewCount": "143", "PostTypeId": "1", "LastEditorUserId": "2659313", "CreationDate": "2015-07-10T04:18:47.023", "LastActivityDate": "2015-07-10T06:13:44.533", "Title": "C++ integer from string", "AcceptedAnswerId": "31332657", "LastEditDate": "2015-07-10T04:52:42.573", "Id": "31332380", "Score": "1", "Body": "<p>How do you convert a <code>std::string</code> to an unsigned integer, and allowing very long inputs?</p>\n<p>For example, an input of <code>5000000000</code> should return <code>705032704</code> (<code>5000000000 mod 2^32</code>), assuming here that unsigned is 32 bits. An input of <code>9999999999999999999999999999</code> should return <code>268435455</code>.</p>\n<p><code>std::stoi</code> and friends give an <code>std::out_of_range</code> when such a large number is provided.</p>\n<p>Using <code>std::istringstream::operator&gt;&gt;(unsigned)</code> simply fails given such input.</p>\n<p>Is there any function to convert a string to an integer, without bailing out in the case of large inputs? (I'd prefer to avoid writing one myself if possible.)</p>\n", "Tags": "<c++><type-conversion><unsigned>", "OwnerUserId": "5101266", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_31332380_31332657_0": {"section_id": 7213, "quality": 0.875, "length": 14}}, "n3337": {"so_31332380_31332657_0": {"section_id": 6957, "quality": 1.0, "length": 16}}, "n4659": {"so_31332380_31332657_0": {"section_id": 8722, "quality": 0.875, "length": 14}}}, "31333670": {"ParentId": "31332380", "CommentCount": "0", "Body": "<p>Use <code>std::stoull</code> if fits in your range, otherwise go for BigInteger libraries in C++</p>\n<pre><code>unsigned long long stoull(const std::string &amp; str, std::size_t * pos = 0, int base = 10);\n</code></pre>\n<p>A nice bigint library is <a href=\"https://mattmccutchen.net/bigint/\" rel=\"nofollow\">https://mattmccutchen.net/bigint/</a>.</p>\n", "OwnerUserId": "2425366", "PostTypeId": "2", "Id": "31333670", "Score": "0", "CreationDate": "2015-07-10T06:13:44.533", "LastActivityDate": "2015-07-10T06:13:44.533"}});