post_cb({"bq_ids": {"n4140": {"so_43152787_43153258_1": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_43152787_43153258_2": {"length": 9, "quality": 0.9, "section_id": 7239}}, "n3337": {"so_43152787_43153258_1": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_43152787_43153258_2": {"length": 9, "quality": 0.9, "section_id": 6983}}, "n4659": {"so_43152787_43153258_1": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_43152787_43153258_2": {"length": 9, "quality": 0.9, "section_id": 8748}}}, "43153258": {"Id": "43153258", "PostTypeId": "2", "Body": "<p>Your code's problem is the use of <code>bool*</code> when you should have been using <code>unsigned char*</code>, which allowed GCC 5 to proceed with a pointer alias optimization.</p>\n<p>The two dumps of the machine code for function <code>Main()</code>, produced both by GCC 4.8.5 and 5.3.1, are at the end of this answer in appendix for reference.</p>\n<p>Looking at the code:</p>\n<h3>Decompilation</h3>\n<p>After the prologue, <code>T sep</code>'s <code>_bits</code> are initialized to zero...</p>\n<pre><code>  _bits[0] = _bits[1] = _bits[2] = _bits[3] = _mm256_set1_epi32(0);\n  _bits[4] = _bits[5] = _bits[6] = _bits[7] = _mm256_set1_epi32(0);\n\n  40063d:       c5 fd 7f 44 24 60               vmovdqa %ymm0,0x60(%rsp)\n  400643:       c5 fd 7f 44 24 40               vmovdqa %ymm0,0x40(%rsp)\n  400649:       c5 fd 7f 44 24 20               vmovdqa %ymm0,0x20(%rsp)\n  40064f:       c5 fd 7f 04 24                  vmovdqa %ymm0,(%rsp)\n  400654:       c5 fd 7f 84 24 e0 00 00 00      vmovdqa %ymm0,0xe0(%rsp)\n  40065d:       c5 fd 7f 84 24 c0 00 00 00      vmovdqa %ymm0,0xc0(%rsp)\n  400666:       c5 fd 7f 84 24 a0 00 00 00      vmovdqa %ymm0,0xa0(%rsp)\n  40066f:       c5 fd 7f 84 24 80 00 00 00      vmovdqa %ymm0,0x80(%rsp)\n</code></pre>\n<p>and then written to in a loop based on <code>char* s</code>.</p>\n<pre><code>  char c;\n  while ((c = *s++))\n    (*this)[c] = true;\n\n  400680:       48 83 c2 01                     add    $0x1,%rdx\n  400684:       c6 04 04 01                     movb   $0x1,(%rsp,%rax,1)\n  400688:       0f b6 42 ff                     movzbl -0x1(%rdx),%eax\n  40068c:       84 c0                           test   %al,%al\n  40068e:       75 f0                           jne    400680 &lt;_Z4Mainv+0x60&gt;\n</code></pre>\n<p>Both compilers then initialize <code>T end</code> to 0s:</p>\n<pre><code>  400690:       c5 f9 ef c0                     vpxor  %xmm0,%xmm0,%xmm0\n  400694:       31 c0                           xor    %eax,%eax\n  400696:       c5 fd 7f 84 24 60 01 00 00      vmovdqa %ymm0,0x160(%rsp)\n  40069f:       c5 fd 7f 84 24 40 01 00 00      vmovdqa %ymm0,0x140(%rsp)\n  4006a8:       c5 fd 7f 84 24 20 01 00 00      vmovdqa %ymm0,0x120(%rsp)\n  4006b1:       c5 fd 7f 84 24 00 01 00 00      vmovdqa %ymm0,0x100(%rsp)\n  4006ba:       c5 fd 7f 84 24 e0 01 00 00      vmovdqa %ymm0,0x1e0(%rsp)\n  4006c3:       c5 fd 7f 84 24 c0 01 00 00      vmovdqa %ymm0,0x1c0(%rsp)\n  4006cc:       c5 fd 7f 84 24 a0 01 00 00      vmovdqa %ymm0,0x1a0(%rsp)\n  4006d5:       c5 fd 7f 84 24 80 01 00 00      vmovdqa %ymm0,0x180(%rsp)\n</code></pre>\n<p>Both compilers then optimize out the <code>_mm256_or_si256()</code> operations because <code>T end</code> is known to be <code>0</code>. But then, GCC 4.8.5 <strong>copies from <code>T sep</code> to <code>T res</code></strong> (which is computationally what happens when you OR anything into a zero variable), while GCC 5.3.1 <strong>initializes <code>T res</code> to <code>0</code></strong>. It's entitled to do that because in your <code>operator []</code> method you cast a pointer of type <code>__m256i*</code> to <code>bool*</code>, and the compiler is permitted to assume the pointers do not alias. Thus in GCC 4.8.5 you see</p>\n<pre><code>  4006de:       c5 fd 6f 04 24                  vmovdqa (%rsp),%ymm0\n  4006e3:       c5 fd 7f 84 24 00 02 00 00      vmovdqa %ymm0,0x200(%rsp)\n  4006ec:       c5 fd 6f 44 24 20               vmovdqa 0x20(%rsp),%ymm0\n  4006f2:       c5 fd 7f 84 24 20 02 00 00      vmovdqa %ymm0,0x220(%rsp)\n  4006fb:       c5 fd 6f 44 24 40               vmovdqa 0x40(%rsp),%ymm0\n  400701:       c5 fd 7f 84 24 40 02 00 00      vmovdqa %ymm0,0x240(%rsp)\n  40070a:       c5 fd 6f 44 24 60               vmovdqa 0x60(%rsp),%ymm0\n  400710:       c5 fd 7f 84 24 60 02 00 00      vmovdqa %ymm0,0x260(%rsp)\n  400719:       c5 fd 6f 84 24 80 00 00 00      vmovdqa 0x80(%rsp),%ymm0\n  400722:       c5 fd 7f 84 24 80 02 00 00      vmovdqa %ymm0,0x280(%rsp)\n  40072b:       c5 fd 6f 84 24 a0 00 00 00      vmovdqa 0xa0(%rsp),%ymm0\n  400734:       c5 fd 7f 84 24 a0 02 00 00      vmovdqa %ymm0,0x2a0(%rsp)\n  40073d:       c5 fd 6f 84 24 c0 00 00 00      vmovdqa 0xc0(%rsp),%ymm0\n  400746:       c5 fd 7f 84 24 c0 02 00 00      vmovdqa %ymm0,0x2c0(%rsp)\n  40074f:       c5 fd 6f 84 24 e0 00 00 00      vmovdqa 0xe0(%rsp),%ymm0\n  400758:       c5 fd 7f 84 24 e0 02 00 00      vmovdqa %ymm0,0x2e0(%rsp)\n</code></pre>\n<p>while in GCC 5.3.1 you see</p>\n<pre><code>  4006fa:       c5 fd 7f 85 f0 fe ff ff         vmovdqa %ymm0,-0x110(%rbp)\n  400702:       c5 fd 7f 85 10 ff ff ff         vmovdqa %ymm0,-0xf0(%rbp)\n  40070a:       c5 fd 7f 85 30 ff ff ff         vmovdqa %ymm0,-0xd0(%rbp)\n  400712:       c5 fd 7f 85 50 ff ff ff         vmovdqa %ymm0,-0xb0(%rbp)\n  40071a:       c5 fd 7f 85 70 ff ff ff         vmovdqa %ymm0,-0x90(%rbp)\n  400722:       c5 fd 7f 45 90                  vmovdqa %ymm0,-0x70(%rbp)\n  400727:       c5 fd 7f 45 b0                  vmovdqa %ymm0,-0x50(%rbp)\n  40072c:       c5 fd 7f 45 d0                  vmovdqa %ymm0,-0x30(%rbp)\n</code></pre>\n<p>Whereupon the reads for the <code>assert()</code> then fail.</p>\n<h3>The Standard's Ruling on Pointer Aliasing:</h3>\n<p>ISO C++11 refers to aliasing under the following section, which makes clear that variables of type <code>__m256i*</code> cannot be accessed using <code>bool*</code>, but may be accessed with a <code>char*/unsigned char*</code>:</p>\n<blockquote>\n<h3>\u00a7 3.10 Lvalues and rvalues [basic.lval]</h3>\n<p id=\"so_43152787_43153258_0\">[...]</p>\n<p id=\"so_43152787_43153258_1\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined: [52]</p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a <code>char</code> or <code>unsigned char</code> type.</li>\n</ul>\n<hr>\n<p id=\"so_43152787_43153258_2\">52) The intent of this list is to specify those circumstances in which an object may or may not be aliased.</p>\n</hr></blockquote>\n<h1>Appendix</h1>\n<h3>GCC 4.8.5:</h3>\n<pre><code>0000000000400620 &lt;_Z4Mainv&gt;:\n  400620:       55                              push   %rbp\n  400621:       c5 f9 ef c0                     vpxor  %xmm0,%xmm0,%xmm0\n  400625:       ba e5 08 40 00                  mov    $0x4008e5,%edx\n  40062a:       b8 20 00 00 00                  mov    $0x20,%eax\n  40062f:       48 89 e5                        mov    %rsp,%rbp\n  400632:       48 83 e4 e0                     and    $0xffffffffffffffe0,%rsp\n  400636:       48 81 ec 00 03 00 00            sub    $0x300,%rsp\n  40063d:       c5 fd 7f 44 24 60               vmovdqa %ymm0,0x60(%rsp)\n  400643:       c5 fd 7f 44 24 40               vmovdqa %ymm0,0x40(%rsp)\n  400649:       c5 fd 7f 44 24 20               vmovdqa %ymm0,0x20(%rsp)\n  40064f:       c5 fd 7f 04 24                  vmovdqa %ymm0,(%rsp)\n  400654:       c5 fd 7f 84 24 e0 00 00 00      vmovdqa %ymm0,0xe0(%rsp)\n  40065d:       c5 fd 7f 84 24 c0 00 00 00      vmovdqa %ymm0,0xc0(%rsp)\n  400666:       c5 fd 7f 84 24 a0 00 00 00      vmovdqa %ymm0,0xa0(%rsp)\n  40066f:       c5 fd 7f 84 24 80 00 00 00      vmovdqa %ymm0,0x80(%rsp)\n  400678:       0f 1f 84 00 00 00 00 00         nopl   0x0(%rax,%rax,1)\n  400680:       48 83 c2 01                     add    $0x1,%rdx\n  400684:       c6 04 04 01                     movb   $0x1,(%rsp,%rax,1)\n  400688:       0f b6 42 ff                     movzbl -0x1(%rdx),%eax\n  40068c:       84 c0                           test   %al,%al\n  40068e:       75 f0                           jne    400680 &lt;_Z4Mainv+0x60&gt;\n  400690:       c5 f9 ef c0                     vpxor  %xmm0,%xmm0,%xmm0\n  400694:       31 c0                           xor    %eax,%eax\n  400696:       c5 fd 7f 84 24 60 01 00 00      vmovdqa %ymm0,0x160(%rsp)\n  40069f:       c5 fd 7f 84 24 40 01 00 00      vmovdqa %ymm0,0x140(%rsp)\n  4006a8:       c5 fd 7f 84 24 20 01 00 00      vmovdqa %ymm0,0x120(%rsp)\n  4006b1:       c5 fd 7f 84 24 00 01 00 00      vmovdqa %ymm0,0x100(%rsp)\n  4006ba:       c5 fd 7f 84 24 e0 01 00 00      vmovdqa %ymm0,0x1e0(%rsp)\n  4006c3:       c5 fd 7f 84 24 c0 01 00 00      vmovdqa %ymm0,0x1c0(%rsp)\n  4006cc:       c5 fd 7f 84 24 a0 01 00 00      vmovdqa %ymm0,0x1a0(%rsp)\n  4006d5:       c5 fd 7f 84 24 80 01 00 00      vmovdqa %ymm0,0x180(%rsp)\n  4006de:       c5 fd 6f 04 24                  vmovdqa (%rsp),%ymm0\n  4006e3:       c5 fd 7f 84 24 00 02 00 00      vmovdqa %ymm0,0x200(%rsp)\n  4006ec:       c5 fd 6f 44 24 20               vmovdqa 0x20(%rsp),%ymm0\n  4006f2:       c5 fd 7f 84 24 20 02 00 00      vmovdqa %ymm0,0x220(%rsp)\n  4006fb:       c5 fd 6f 44 24 40               vmovdqa 0x40(%rsp),%ymm0\n  400701:       c5 fd 7f 84 24 40 02 00 00      vmovdqa %ymm0,0x240(%rsp)\n  40070a:       c5 fd 6f 44 24 60               vmovdqa 0x60(%rsp),%ymm0\n  400710:       c5 fd 7f 84 24 60 02 00 00      vmovdqa %ymm0,0x260(%rsp)\n  400719:       c5 fd 6f 84 24 80 00 00 00      vmovdqa 0x80(%rsp),%ymm0\n  400722:       c5 fd 7f 84 24 80 02 00 00      vmovdqa %ymm0,0x280(%rsp)\n  40072b:       c5 fd 6f 84 24 a0 00 00 00      vmovdqa 0xa0(%rsp),%ymm0\n  400734:       c5 fd 7f 84 24 a0 02 00 00      vmovdqa %ymm0,0x2a0(%rsp)\n  40073d:       c5 fd 6f 84 24 c0 00 00 00      vmovdqa 0xc0(%rsp),%ymm0\n  400746:       c5 fd 7f 84 24 c0 02 00 00      vmovdqa %ymm0,0x2c0(%rsp)\n  40074f:       c5 fd 6f 84 24 e0 00 00 00      vmovdqa 0xe0(%rsp),%ymm0\n  400758:       c5 fd 7f 84 24 e0 02 00 00      vmovdqa %ymm0,0x2e0(%rsp)\n  400761:       0f 1f 80 00 00 00 00            nopl   0x0(%rax)\n  400768:       80 3c 04 00                     cmpb   $0x0,(%rsp,%rax,1)\n  40076c:       0f b6 8c 04 00 02 00 00         movzbl 0x200(%rsp,%rax,1),%ecx\n  400774:       ba 01 00 00 00                  mov    $0x1,%edx\n  400779:       75 08                           jne    400783 &lt;_Z4Mainv+0x163&gt;\n  40077b:       0f b6 94 04 00 01 00 00         movzbl 0x100(%rsp,%rax,1),%edx\n  400783:       38 d1                           cmp    %dl,%cl\n  400785:       0f 85 b2 00 00 00               jne    40083d &lt;_Z4Mainv+0x21d&gt;\n  40078b:       48 83 c0 01                     add    $0x1,%rax\n  40078f:       48 3d 00 01 00 00               cmp    $0x100,%rax\n  400795:       75 d1                           jne    400768 &lt;_Z4Mainv+0x148&gt;\n  400797:       c5 fd 6f 8c 24 00 02 00 00      vmovdqa 0x200(%rsp),%ymm1\n  4007a0:       31 c0                           xor    %eax,%eax\n  4007a2:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  4007a7:       0f 94 c0                        sete   %al\n  4007aa:       0f 85 88 00 00 00               jne    400838 &lt;_Z4Mainv+0x218&gt;\n  4007b0:       c5 fd 6f 8c 24 20 02 00 00      vmovdqa 0x220(%rsp),%ymm1\n  4007b9:       31 c0                           xor    %eax,%eax\n  4007bb:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  4007c0:       0f 94 c0                        sete   %al\n  4007c3:       75 73                           jne    400838 &lt;_Z4Mainv+0x218&gt;\n  4007c5:       c5 fd 6f 8c 24 40 02 00 00      vmovdqa 0x240(%rsp),%ymm1\n  4007ce:       31 c0                           xor    %eax,%eax\n  4007d0:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  4007d5:       0f 94 c0                        sete   %al\n  4007d8:       75 5e                           jne    400838 &lt;_Z4Mainv+0x218&gt;\n  4007da:       c5 fd 6f 8c 24 60 02 00 00      vmovdqa 0x260(%rsp),%ymm1\n  4007e3:       31 c0                           xor    %eax,%eax\n  4007e5:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  4007ea:       0f 94 c0                        sete   %al\n  4007ed:       75 49                           jne    400838 &lt;_Z4Mainv+0x218&gt;\n  4007ef:       c5 fd 6f 8c 24 80 02 00 00      vmovdqa 0x280(%rsp),%ymm1\n  4007f8:       31 c0                           xor    %eax,%eax\n  4007fa:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  4007ff:       0f 94 c0                        sete   %al\n  400802:       75 34                           jne    400838 &lt;_Z4Mainv+0x218&gt;\n  400804:       c5 fd 6f 8c 24 a0 02 00 00      vmovdqa 0x2a0(%rsp),%ymm1\n  40080d:       31 c0                           xor    %eax,%eax\n  40080f:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  400814:       0f 94 c0                        sete   %al\n  400817:       75 1f                           jne    400838 &lt;_Z4Mainv+0x218&gt;\n  400819:       c5 fd 6f 8c 24 c0 02 00 00      vmovdqa 0x2c0(%rsp),%ymm1\n  400822:       31 c0                           xor    %eax,%eax\n  400824:       c4 e2 7d 17 c9                  vptest %ymm1,%ymm1\n  400829:       0f 94 c0                        sete   %al\n  40082c:       75 0a                           jne    400838 &lt;_Z4Mainv+0x218&gt;\n  40082e:       31 c0                           xor    %eax,%eax\n  400830:       c4 e2 7d 17 c0                  vptest %ymm0,%ymm0\n  400835:       0f 94 c0                        sete   %al\n  400838:       c5 f8 77                        vzeroupper \n  40083b:       c9                              leaveq \n  40083c:       c3                              retq   \n  40083d:       b9 20 09 40 00                  mov    $0x400920,%ecx\n  400842:       ba 26 00 00 00                  mov    $0x26,%edx\n  400847:       be e9 08 40 00                  mov    $0x4008e9,%esi\n  40084c:       bf f8 08 40 00                  mov    $0x4008f8,%edi\n  400851:       c5 f8 77                        vzeroupper \n  400854:       e8 97 fc ff ff                  callq  4004f0 &lt;__assert_fail@plt&gt;\n  400859:       0f 1f 80 00 00 00 00            nopl   0x0(%rax)\n</code></pre>\n<h3>GCC 5:</h3>\n<pre><code>0000000000400630 &lt;_Z4Mainv&gt;:\n  400630:       4c 8d 54 24 08                  lea    0x8(%rsp),%r10\n  400635:       48 83 e4 e0                     and    $0xffffffffffffffe0,%rsp\n  400639:       b8 20 00 00 00                  mov    $0x20,%eax\n  40063e:       c5 f9 ef c0                     vpxor  %xmm0,%xmm0,%xmm0\n  400642:       ba 25 08 40 00                  mov    $0x400825,%edx\n  400647:       41 ff 72 f8                     pushq  -0x8(%r10)\n  40064b:       55                              push   %rbp\n  40064c:       48 89 e5                        mov    %rsp,%rbp\n  40064f:       41 52                           push   %r10\n  400651:       48 81 ec 08 03 00 00            sub    $0x308,%rsp\n  400658:       c5 fd 7f 85 50 fd ff ff         vmovdqa %ymm0,-0x2b0(%rbp)\n  400660:       c5 fd 7f 85 30 fd ff ff         vmovdqa %ymm0,-0x2d0(%rbp)\n  400668:       c5 fd 7f 85 10 fd ff ff         vmovdqa %ymm0,-0x2f0(%rbp)\n  400670:       c5 fd 7f 85 f0 fc ff ff         vmovdqa %ymm0,-0x310(%rbp)\n  400678:       c5 fd 7f 85 d0 fd ff ff         vmovdqa %ymm0,-0x230(%rbp)\n  400680:       c5 fd 7f 85 b0 fd ff ff         vmovdqa %ymm0,-0x250(%rbp)\n  400688:       c5 fd 7f 85 90 fd ff ff         vmovdqa %ymm0,-0x270(%rbp)\n  400690:       c5 fd 7f 85 70 fd ff ff         vmovdqa %ymm0,-0x290(%rbp)\n  400698:       0f 1f 84 00 00 00 00 00         nopl   0x0(%rax,%rax,1)\n  4006a0:       48 83 c2 01                     add    $0x1,%rdx\n  4006a4:       c6 84 05 f0 fc ff ff 01         movb   $0x1,-0x310(%rbp,%rax,1)\n  4006ac:       0f b6 42 ff                     movzbl -0x1(%rdx),%eax\n  4006b0:       84 c0                           test   %al,%al\n  4006b2:       75 ec                           jne    4006a0 &lt;_Z4Mainv+0x70&gt;\n  4006b4:       c5 f9 ef c0                     vpxor  %xmm0,%xmm0,%xmm0\n  4006b8:       31 c0                           xor    %eax,%eax\n  4006ba:       c5 fd 7f 85 50 fe ff ff         vmovdqa %ymm0,-0x1b0(%rbp)\n  4006c2:       c5 fd 7f 85 30 fe ff ff         vmovdqa %ymm0,-0x1d0(%rbp)\n  4006ca:       c5 fd 7f 85 10 fe ff ff         vmovdqa %ymm0,-0x1f0(%rbp)\n  4006d2:       c5 fd 7f 85 f0 fd ff ff         vmovdqa %ymm0,-0x210(%rbp)\n  4006da:       c5 fd 7f 85 d0 fe ff ff         vmovdqa %ymm0,-0x130(%rbp)\n  4006e2:       c5 fd 7f 85 b0 fe ff ff         vmovdqa %ymm0,-0x150(%rbp)\n  4006ea:       c5 fd 7f 85 90 fe ff ff         vmovdqa %ymm0,-0x170(%rbp)\n  4006f2:       c5 fd 7f 85 70 fe ff ff         vmovdqa %ymm0,-0x190(%rbp)\n  4006fa:       c5 fd 7f 85 f0 fe ff ff         vmovdqa %ymm0,-0x110(%rbp)\n  400702:       c5 fd 7f 85 10 ff ff ff         vmovdqa %ymm0,-0xf0(%rbp)\n  40070a:       c5 fd 7f 85 30 ff ff ff         vmovdqa %ymm0,-0xd0(%rbp)\n  400712:       c5 fd 7f 85 50 ff ff ff         vmovdqa %ymm0,-0xb0(%rbp)\n  40071a:       c5 fd 7f 85 70 ff ff ff         vmovdqa %ymm0,-0x90(%rbp)\n  400722:       c5 fd 7f 45 90                  vmovdqa %ymm0,-0x70(%rbp)\n  400727:       c5 fd 7f 45 b0                  vmovdqa %ymm0,-0x50(%rbp)\n  40072c:       c5 fd 7f 45 d0                  vmovdqa %ymm0,-0x30(%rbp)\n  400731:       0f 1f 80 00 00 00 00            nopl   0x0(%rax)\n  400738:       0f b6 94 05 f0 fc ff ff         movzbl -0x310(%rbp,%rax,1),%edx\n  400740:       0f b6 8c 05 f0 fe ff ff         movzbl -0x110(%rbp,%rax,1),%ecx\n  400748:       84 d2                           test   %dl,%dl\n  40074a:       75 08                           jne    400754 &lt;_Z4Mainv+0x124&gt;\n  40074c:       0f b6 94 05 f0 fd ff ff         movzbl -0x210(%rbp,%rax,1),%edx\n  400754:       38 d1                           cmp    %dl,%cl\n  400756:       75 2c                           jne    400784 &lt;_Z4Mainv+0x154&gt;\n  400758:       48 83 c0 01                     add    $0x1,%rax\n  40075c:       48 3d 00 01 00 00               cmp    $0x100,%rax\n  400762:       75 d4                           jne    400738 &lt;_Z4Mainv+0x108&gt;\n  400764:       c5 f9 ef c0                     vpxor  %xmm0,%xmm0,%xmm0\n  400768:       31 c0                           xor    %eax,%eax\n  40076a:       c4 e2 7d 17 c0                  vptest %ymm0,%ymm0\n  40076f:       0f 94 c0                        sete   %al\n  400772:       c5 f8 77                        vzeroupper \n  400775:       48 81 c4 08 03 00 00            add    $0x308,%rsp\n  40077c:       41 5a                           pop    %r10\n  40077e:       5d                              pop    %rbp\n  40077f:       49 8d 62 f8                     lea    -0x8(%r10),%rsp\n  400783:       c3                              retq   \n  400784:       b9 60 08 40 00                  mov    $0x400860,%ecx\n  400789:       ba 26 00 00 00                  mov    $0x26,%edx\n  40078e:       be 29 08 40 00                  mov    $0x400829,%esi\n  400793:       bf 38 08 40 00                  mov    $0x400838,%edi\n  400798:       c5 f8 77                        vzeroupper \n  40079b:       e8 50 fd ff ff                  callq  4004f0 &lt;__assert_fail@plt&gt;\n</code></pre>\n", "LastEditorUserId": "2809095", "LastActivityDate": "2017-04-01T06:43:18.053", "Score": "7", "CreationDate": "2017-04-01T05:39:10.537", "ParentId": "43152787", "CommentCount": "8", "OwnerUserId": "2809095", "LastEditDate": "2017-04-01T06:43:18.053"}, "43152787": {"ViewCount": "148", "Body": "<p>I wrote the following class \"T\" to accelerate manipulations of\n\"sets of characters\" using AVX2. Then I found that it doesn't work in\ngcc 5 and later when I use \"-O3\".\nCan anyone help me trace this down to some programming construct that\nis known not to work on the latest compilers/systems?</p>\n<p>How this code works: The underlying structure (\"_bits\") is a block of 256 bytes (aligned and allocated for AVX2), which can be accessed either as char[256] or AVX2 elements, depending on whether an element is accessed or the whole thing is used in a vector operation. Seems like it should work perfectly well on the AVX2 platform. No?</p>\n<p>This is really hard to debug, because \"valgrind\" says it's clean,\nand I can't use a debugger (due to the problem disappearing when\nI remove \"-O3\"). But I am not happy with just going with the \"|=\"\nworkaround because if this code is really wrong, then I'm probably\nmaking the same mistake in other places and screwing up everything\nI develop!</p>\n<p>It is interesting to note that the \"|\" operator has the problem but the\n\"|=\" does not. Could the problem be related to returning a struct from\na function? But I thought that returning a struct has worked since 1990\nor something.</p>\n<pre><code>// g++ -std=c++11 -mavx2 -O3 gcc_fail.cpp\n\n#include \"assert.h\"\n#include \"immintrin.h\" // AVX\n\nclass T {\npublic:\n  __m256i _bits[8];\n  inline bool&amp; operator[](unsigned char c)       {return ((bool*)_bits)[c];}\n  inline bool  operator[](unsigned char c) const {return ((bool*)_bits)[c];}\n  inline          T()                   {}\n  inline explicit T(char const*);\n  inline T     operator| (T const&amp; b) const;\n  inline T &amp;   operator|=(T const&amp; b);\n  inline bool  operator! ()           const;\n};\n\nT::T(char const* s)\n{\n  _bits[0] = _bits[1] = _bits[2] = _bits[3] = _mm256_set1_epi32(0);\n  _bits[4] = _bits[5] = _bits[6] = _bits[7] = _mm256_set1_epi32(0);\n  char c;\n  while ((c = *s++))\n    (*this)[c] = true;\n}\n\nT T::operator| (T const&amp; b) const\n{\n  T res;\n  for (int i = 0; i &lt; 8; i++)\n    res._bits[i] = _mm256_or_si256(_bits[i], b._bits[i]);\n\n\n  // FIXME why does the above code fail with -O3 in new gcc?\n  for (int i=0; i&lt;256; i++)\n    assert(res[i] == ((*this)[i] || b[i]));\n  // gcc 4.7.0 - PASS\n  // gcc 4.7.2 - PASS\n  // gcc 4.8.0 - PASS\n  // gcc 4.9.2 - PASS\n  // gcc 5.2.0 - FAIL\n  // gcc 5.3.0 - FAIL\n  // gcc 5.3.1 - FAIL\n  // gcc 6.1.0 - FAIL\n\n\n  return res;\n}\n\nT &amp; T::operator|=(T const&amp; b)\n{\n  for (int i = 0; i &lt; 8; i++)\n    _bits[i] = _mm256_or_si256(_bits[i], b._bits[i]);\n  return *this;\n}\n\nbool T::operator! () const\n{\n  for (int i = 0; i &lt; 8; i++)\n    if (!_mm256_testz_si256(_bits[i], _bits[i]))\n      return false;\n  return true;\n}\n\nint Main()\n{\n  T sep (\" ,\\t\\n\");\n  T end (\"\");\n  return !(sep|end);\n}\n\nint main()\n{\n  return Main();\n}\n</code></pre>\n", "AcceptedAnswerId": "43153258", "Title": "AVX2 support in GCC 5 and later", "CreationDate": "2017-04-01T04:20:06.967", "Id": "43152787", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-04-01T04:39:58.893", "LastEditorUserId": "5896591", "LastActivityDate": "2017-04-01T06:43:18.053", "Score": "2", "OwnerUserId": "5896591", "Tags": "<c++><gcc><avx2>", "AnswerCount": "1"}});