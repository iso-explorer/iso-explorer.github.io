post_cb({"8869179": {"ParentId": "8869104", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, input iterators are one-pass iterators. You can only iterate over them once, while forward iterators are multi-pass.</p>\n<p>From <code>\u00a724.2.3 [input.iterators] p2 (the table)</code>, pre-/postcondition column of <code>++r</code>:</p>\n<blockquote>\n<p id=\"so_8869104_8869179_0\">pre: <code>r</code> is dereferenceable.<br>\n  post: <code>r</code> is dereferenceable or <code>r</code> is past-the-end.<br>\n<strong>post: any copies of the previous value of <code>r</code> are no longer required either to be dereferenceable or to be in the domain of <code>==</code>.</strong></br></br></p>\n</blockquote>\n<p>The last postcondition implies that for <code>a == b</code>, <code>++a == ++b</code> is not required to be <code>true</code>.<br>\nSame clause, paragraph 3:</br></p>\n<blockquote>\n<p id=\"so_8869104_8869179_1\">[ <em>Note:</em> For input iterators, <em>a == b</em> does not imply <em>++a == ++b</em>. (Equality does not guarantee the substitution property or referential transparency.) Algorithms on input iterators should never attempt to pass through the same iterator twice. They should be <em>single pass</em> algorithms. [...] These algorithms can be used with istreams as the source of the input data through the <code>istream_iterator</code> class template. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>From <code>\u00a724.2.5 [forward.iterators]</code></p>\n<blockquote>\n<p id=\"so_8869104_8869179_2\">p1 A class or pointer type <code>X</code> satisfies the requirements of a forward iterator if</p>\n<ul>\n<li>[...]</li>\n<li>objects of type <code>X</code> offer the multi-pass guarantee, described below.</li>\n</ul>\n<p id=\"so_8869104_8869179_3\">p3 Two dereferenceable iterators a and b of type <code>X</code> offer the <em>multi-pass guarantee</em> if:</p>\n<ul>\n<li><code>a == b</code> implies <code>++a == ++b</code> and</li>\n<li><code>X</code> is a pointer type or the expression <code>(void)++X(a), *a</code> is equivalent to the expression <code>*a</code>.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2012-01-15T11:13:17.483", "Id": "8869179", "Score": "20", "CreationDate": "2012-01-15T10:58:27.363", "LastActivityDate": "2012-01-15T11:13:17.483"}, "bq_ids": {"n4140": {"so_8869104_8869179_3": {"section_id": 5575, "quality": 0.8571428571428571, "length": 6}, "so_8869104_8869179_2": {"section_id": 5573, "quality": 1.0, "length": 7}, "so_8869104_8869179_1": {"section_id": 5570, "quality": 0.85, "length": 34}, "so_8869104_8869179_0": {"section_id": 5569, "quality": 1.0, "length": 14}}, "n3337": {"so_8869104_8869179_3": {"section_id": 5357, "quality": 0.8571428571428571, "length": 6}, "so_8869104_8869179_2": {"section_id": 5355, "quality": 1.0, "length": 7}, "so_8869104_8869179_1": {"section_id": 5352, "quality": 0.85, "length": 34}, "so_8869104_8869179_0": {"section_id": 5351, "quality": 1.0, "length": 14}}, "n4659": {"so_8869104_8869179_3": {"section_id": 7022, "quality": 0.8571428571428571, "length": 6}, "so_8869104_8869179_2": {"section_id": 7020, "quality": 1.0, "length": 7}, "so_8869104_8869179_1": {"section_id": 7017, "quality": 0.85, "length": 34}, "so_8869104_8869179_0": {"section_id": 7016, "quality": 0.7857142857142857, "length": 11}}}, "8869104": {"CommentCount": "0", "AcceptedAnswerId": "8869179", "PostTypeId": "1", "LastEditorUserId": "918414", "CreationDate": "2012-01-15T10:45:22.780", "LastActivityDate": "2012-06-29T07:54:26.017", "LastEditDate": "2012-06-29T07:54:26.017", "ViewCount": "1943", "FavoriteCount": "2", "Title": "What's the difference between input iterators and read-only forward iterators?", "Id": "8869104", "Score": "12", "Body": "<p>What's the difference between input iterators and read-only forward iterators?</p>\n<p>Because the latter are read-only, they obviously don't satisfy requirements of output iterators. And, because of that, they're effectively input iterators with additional guarantees (if any). The problem is, what additional guarantees?</p>\n<p>My guess would be that forward iterators are multi-pass and input iterators are not, am I right? </p>\n", "Tags": "<c++><iterator><c++-standard-library>", "OwnerUserId": "784668", "AnswerCount": "1"}});