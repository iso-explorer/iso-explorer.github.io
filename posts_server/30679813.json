post_cb({"30683666": {"ParentId": "30679813", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>One example of different default arguments in different scopes for the same template is when they are declared in different translation units:</p>\n<pre><code>// x.hpp\ntemplate &lt;class T&gt; class X;\n\n// a.cpp\n#include \"x.hpp\"\ntemplate &lt;class T = int&gt; class X;\n\n// b.cpp\n#include \"x.hpp\"\ntemplate &lt;class T = float&gt; class X;\n</code></pre>\n<p>Here, we have two translation units creating two scopes which both declare the same entity (class template X). And in each global scope, we have a new declaration of X with different default template parameters. This is okay because they are in different scopes.</p>\n", "OwnerUserId": "951890", "LastEditorUserId": "951890", "LastEditDate": "2015-06-06T16:08:12.050", "Id": "30683666", "Score": "0", "CreationDate": "2015-06-06T13:52:18.023", "LastActivityDate": "2015-06-06T16:08:12.050"}, "30682526": {"ParentId": "30679813", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I'm not sure I can follow your thoughts fully, but I think the standard simply uses overly clear wording. It is probably meant to clarify that the \"same\" template in a <em>different</em> scope may have different default parameters. Example:</p>\n<pre><code>namespace A\n{\n    template&lt; int = 42 &gt; struct X;\n}\n\nnamespace B\n{\n    template&lt; int = 123 &gt; struct X;\n\n    namespace C\n    {\n        template&lt; int = 0 &gt; struct X;\n    }\n}\n</code></pre>\n<p>Of course, those templates are <em>not</em> the same template (even thought a beginner may think so at first glance) but they are different templates. The standard's wording is most likely just meant to emphasis this.</p>\n<p>One example where you could have different defaults is a template alias with <code>using</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nnamespace A\n{\n    template&lt; int I = 42 &gt;\n    struct X { static void f() { std::cout &lt;&lt; I &lt;&lt; std::endl; } };\n}\n\nnamespace B\n{\n    template&lt; int I = 0 &gt;\n    using X = A::X&lt; I &gt;; \n}\n\nint main()\n{\n    A::X&lt;&gt;::f();\n    B::X&lt;&gt;::f();\n    static_assert( std::is_same&lt; B::X&lt;&gt;, A::X&lt;0&gt; &gt;::value, \"Oops\" );\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/6f51f3dc9d10f2ea\" rel=\"nofollow noreferrer\"><strong>Live example</strong></a></p>\n<p>The problem with this is, that it looks like it matches your description at first, but interestingly while <code>B::X&lt;&gt;</code> and <code>A::X&lt;0&gt;</code> are the same <strong>type</strong>, <code>B::X</code> is <em>currently not</em> the same <strong>template</strong> as <code>A::X</code>. See <a href=\"https://stackoverflow.com/a/30243528/2073257\">this answer</a> for more information.</p>\n<p>There is a DR (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1286\" rel=\"nofollow noreferrer\">CWG issue 1286</a>) to fix this, though. The different default parameters OTOH are a concern mentioned in the DR, so even if the DR will be resolved, it might not allow different default values.</p>\n", "OwnerUserId": "2073257", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:14:09.357", "Id": "30682526", "Score": "2", "CreationDate": "2015-06-06T11:52:38.250", "LastActivityDate": "2015-06-06T12:11:34.677"}, "bq_ids": {"n4140": {"so_30679813_30679813_0": {"section_id": 65, "quality": 1.0, "length": 9}}, "n3337": {"so_30679813_30679813_0": {"section_id": 60, "quality": 1.0, "length": 9}}, "n4659": {"so_30679813_30679813_0": {"section_id": 67, "quality": 1.0, "length": 9}}}, "30679813": {"CommentCount": "2", "ViewCount": "315", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-06-06T06:41:26.217", "LastActivityDate": "2015-06-06T16:08:12.050", "Title": "Scope and Default Arguments in Template Declarations in C++ : Clarifying Standardese", "AcceptedAnswerId": "30682526", "LastEditDate": "2017-05-23T11:51:18.263", "Id": "30679813", "Score": "6", "Body": "<p>I was reading through the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4431.pdf\" rel=\"nofollow noreferrer\">C++14 standard's</a> section on templates in an attempt to improve my understanding of the subject, and stumbled across this particular rule:</p>\n<p>\u00a7 14.1 </p>\n<blockquote>\n<p id=\"so_30679813_30679813_0\">12 A template-parameter shall not be given default arguments by two different declarations in the same scope.  </p>\n<p id=\"so_30679813_30679813_1\">[Example:  </p>\n<pre><code>template&lt;class T = int&gt; class X;\ntemplate&lt;class T = int&gt; class X { /\u2217... \u2217/ }; // error  \n</code></pre>\n<p id=\"so_30679813_30679813_2\">\u2014 end example ]</p>\n</blockquote>\n<p>To my (relatively uninformed) reading, the specification of \"same scope\" implies the ability to declare templates in different scopes from where they are defined.</p>\n<p>According to <a href=\"http://www.drdobbs.com/cpp/scope-regions-in-c/240002006?pgno=2\" rel=\"nofollow noreferrer\">this article on Dr. Dobbs</a></p>\n<blockquote>\n<p id=\"so_30679813_30679813_3\">C++ identifies five kinds of scope: function, function prototype, local, namespace, and class.</p>\n</blockquote>\n<p>Of those, it's my understanding that:</p>\n<ul>\n<li>function &amp; (I assume function prototype, since it extends past functions only to declarations) scope <a href=\"https://stackoverflow.com/questions/3449112/why-cant-templates-be-declared-in-a-function\">cannot contain template declarations</a></li>\n<li>local scope falls within function scope, and so has the same limitations as above</li>\n<li>you cannot (re)declare any member of a class outside of that class' declaration.</li>\n</ul>\n<p>Thus, the potential odd case of allowing declarations outside of the defined scope (potentially with altered default arguments, dependent on scope!) seemed to fall squarely on the shoulders of the namespace scope. I experimented a bit:  </p>\n<p>[<a href=\"http://coliru.stacked-crooked.com/a/035ac3c5db86bf42\" rel=\"nofollow noreferrer\">Coliru</a>]</p>\n<hr>\n<p><strong>Command:</strong></p>\n<pre><code>g++ -std=c++1z -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n</code></pre>\n<p><strong>Code:</strong>\n</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace math{ \n\n    template &lt;int I, int J&gt;\n    struct Plus{\n        constexpr static int Value_ = I + J;\n    };\n\n    template &lt;int I, int J = 5&gt;\n    struct Minus; // template declaration.\n\n}\n\n// global-scope template declaration?\n//template &lt;int I, int J&gt;\n//struct math::Minus; // error: does not name a type (if no declaration @ line 9)\n                      // error: invalid use of math::Minus w/o argument list\n                      //                             (if declaration @ line 9)\n\n\nnamespace math{\n\n    template &lt;int I, int J&gt;\n    struct Minus{\n        static int value();\n    };\n\n    namespace{ // anonymous namespace\n\n        //template &lt;int I, int J = 5&gt;\n        //struct Minus; compiles, but is a declaration of another class,\n                       // which I assume hides the math scope class\n\n        // error: incomplete type--I assume this means the above \n        // doesn't declare math::Minus, but math::&lt;anon&gt;::Minus\n        //constexpr int twominus5= Minus&lt;2&gt;::value(); \n\n    } // end anonymous namespace\n\n} // end math namespace\n\n//template &lt;int I, int J&gt;\n//class math::Minus; // error: invalid use of math::Minus w/o argument list\n\ntemplate &lt;int I, int J&gt;\nint math::Minus&lt;I,J&gt;::value(){return I - J;}\n\n\nint main()\n{\n    std::cout \n        &lt;&lt; math::Minus&lt;5,1&gt;::value() &lt;&lt; std::endl\n        &lt;&lt; math::Minus&lt;0&gt;::value() &lt;&lt; std::endl;\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>4\n-5\n</code></pre>\n<hr>\n<p>...and the declaration rules seemed to conform to what I would have expected before reading this little snippet of the standard. Clearly, my understanding is wrong somewhere. Is it with my initial reading of the c++ standard's template default argument declaration clause as I suspect, or have I missed some method of declaring templates outside of their native scope?  </p>\n<p>Naturally, an odd corner of the language like this (if it indeed <em>exists</em>) should be used sparingly and with great caution, especially since it would alter the behavior of partially specified templates elsewhere dependent on the most applicable scope (Would it cause name collision issues? How would an otherwise fully-qualified name even <em>resolve</em> in a scope with no default declarations, if there were default parameters in the scope of the template definition?), but it's aroused my curiosity.</p>\n<p>I'll use aliases regardless since that's less ambiguous for everyone involved, but as I said above: I'm curious now whether this is an odd language feature I failed utterly to deliberately use, or a non-feature I simply imagined.</p>\n</hr></hr>", "Tags": "<c++><templates><language-lawyer><c++14>", "OwnerUserId": "4892076", "AnswerCount": "2"}});