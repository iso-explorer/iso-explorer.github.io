post_cb({"bq_ids": {"n4140": {"so_29056890_29057190_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 283}, "so_29056890_29057190_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 283}}, "n3337": {"so_29056890_29057190_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 274}, "so_29056890_29057190_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 274}}, "n4659": {"so_29056890_29057190_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 290}, "so_29056890_29057190_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 290}}}, "29057190": {"Id": "29057190", "PostTypeId": "2", "Body": "<p>This does not seem like a valid optimization according to the draft C++11 standard section <code>14.8</code> <em>[temp.fct.spec]</em> says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_29056890_29057190_0\">Each function template specialization instantiated from a template <strong>has\n  its own copy of any static variable</strong>. [ Example:</p>\n<pre><code>template&lt;class T&gt; void f(T* p) {\nstatic T s;\n};\nvoid g(int a, char* b) {\n    f(&amp;a); // calls f&lt;int&gt;(int*)\n    f(&amp;b); // calls f&lt;char*&gt;(char**)\n}\n</code></pre>\n<p id=\"so_29056890_29057190_1\">Here f(int*) has a static variable s of type int and\n  f(char**) has a static variable s of type char*. \u2014end example ]</p>\n</blockquote>\n<p>Since your taking the address of the variable folding them effects observable behavior which would violate the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow noreferrer\">as-if rule</a>.</p>\n<p>T.C. points out that <code>/opt:noicf</code> prevents the non-conforming behavior.</p>\n<p>Matt McNabb points out that the <a href=\"https://msdn.microsoft.com/en-us/library/bxwfs976.aspx\" rel=\"nofollow noreferrer\">/OPT (Optimizations) documentation</a> contains the following note:</p>\n<blockquote>\n<p id=\"so_29056890_29057190_2\">Because /OPT:ICF can cause the same address to be assigned to\n  different functions or read-only data members (const variables\n  compiled by using /Gy), <strong>it can break a program that depends on unique\n  addresses for functions or read-only data members</strong>. For more\n  information, see /Gy (Enable Function-Level Linking).</p>\n</blockquote>\n<p>Which suggests this could be intentional non-conforming behavior. Ben Voigt <a href=\"http://chat.stackoverflow.com/rooms/73053/discussion-on-answer-by-shafik-yaghmour-is-visual-studio-2013-optimizing-correct\">says in a comment now moved to chat</a> that this indeed means the optimizations can be <em>non-conforming</em> but this points is debatable.</p>\n<p>User usr <a href=\"https://stackoverflow.com/questions/29056890/is-visual-studio-2013-optimizing-correctly-in-the-presence-of-opticf#comment46359307_29056890\">linked</a> to an <a href=\"http://blogs.msdn.com/b/vcblog/archive/2013/09/11/introducing-gw-compiler-switch.aspx\" rel=\"nofollow noreferrer\">MS blog post: Introducing \u2018/Gw\u2019 Compiler Switch</a> and it says:</p>\n<blockquote>\n<p id=\"so_29056890_29057190_3\">Please note, the <strong>ICF optimization will only be applied for identical\n  COMDATs where their address is not taken</strong>, and they are read only. If a\n  data is not address taken, then breaking address uniqueness by ICF\n  won't lead to any observable difference, thus it is valid and\n  conformant to the standard.</p>\n</blockquote>\n<p>and a later comment says:</p>\n<blockquote>\n<p id=\"so_29056890_29057190_4\">Even though it's on it's own completely standards complaint, when\n  combined with /Gy potentially breaking behavior can result.</p>\n</blockquote>\n<p>From what I can tell in order for <code>/Gy</code> to effect <em>const</em> variables <em>__declspec(selectany)</em> has to be used but it could be clearer in the documentation.</p>\n<p>At minimum we can see that <code>/Gw</code> should not introduce non-conforming behavior but <code>/Gy</code> in combination with <code>/Gw</code> may.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-17T09:32:33.557", "Score": "14", "CreationDate": "2015-03-15T04:15:52.957", "ParentId": "29056890", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:24:15.203"}, "29056890": {"ViewCount": "1176", "Body": "<p>I expect the following program to return 0 all of the time. However with Visual Studio 2013 (Update 4), the program exits 1 in release builds. I'm not sure if this is a bug or if the compiler's optimizer is correct and is relying on some edge behavior. If the CONST macro is turned off, the release exe returns 0. If the optimizer is indeed correct, could I get the reason why it is allowed to emit the code it does?</p>\n<pre><code>#if 1\n#   define CONST const\n#else\n#   define CONST\n#endif\n\n\nclass TypeId {\npublic:\n    bool operator== (TypeId const &amp; other) const\n    {\n        return id == other.id;\n    }\n\nprivate:\n    TypeId (void const * id)\n        : id(id)\n    {}\n\npublic:\n    template &lt;typename T&gt;\n    static TypeId Get ()\n    {\n        static char CONST uniqueMemLoc = 0;\n        return TypeId(&amp;uniqueMemLoc);\n    }\n\nprivate:\n    void const * id;\n};\n\n\nint main(int, char **)\n{\n    typedef int A;\n    typedef unsigned int B;\n\n    if (TypeId::Get&lt;A&gt;() == TypeId::Get&lt;B&gt;()) {\n        return 1;\n    }\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "29057190", "Title": "Is Visual Studio 2013 optimizing correctly in the presence of /OPT:ICF?", "CreationDate": "2015-03-15T03:22:21.330", "Id": "29056890", "CommentCount": "16", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-03-15T11:16:31.620", "LastEditorUserId": "122718", "LastActivityDate": "2015-03-17T09:32:33.557", "Score": "22", "OwnerUserId": "239916", "Tags": "<c++><c++11><visual-studio-2013><optimization>", "AnswerCount": "2"}, "29057171": {"Id": "29057171", "PostTypeId": "2", "Body": "<p>No, this optimization does not conform to the C++ standard. The declaration of <code>uniqueMemLoc</code> defines a unique object for each instance of the template, and each object has its own address.</p>\n<p>(If you had used a string literal, it would be a different story. The optimization would be valid in that case.)</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-03-15T13:54:36.770", "Score": "7", "CreationDate": "2015-03-15T04:13:36.917", "ParentId": "29056890", "CommentCount": "0", "OwnerUserId": "153285", "LastEditDate": "2015-03-15T13:54:36.770"}});