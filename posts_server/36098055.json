post_cb({"36648819": {"ParentId": "36098055", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-04-15T13:40:34.757", "Score": "4", "LastEditorUserId": "2671214", "LastEditDate": "2016-05-02T09:38:17.827", "Id": "36648819", "OwnerUserId": "2671214", "Body": "<p>Apparently it's the way a defect in the standard was fixed, but you're not the only one confused about it.</p>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2094\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2094</a>: </p>\n<blockquote>\n<ol start=\"2094\">\n<li>Trivial copy/move constructor for class with volatile member</li>\n</ol>\n<p id=\"so_36098055_36648819_0\">Section: 12.8  [class.copy]     Status: open     Submitter: Daveed Vandevoorde     Date: 2015-03-06 </p>\n<p id=\"so_36098055_36648819_1\">The resolution of issue 496 included\n  the addition of 12.8 [class.copy] paragraph 25.2, making a class's\n  copy/move constructor non-trivial if it has a non-static data member\n  of volatile-qualified type. This change breaks the IA-64 ABI, so it\n  has been requested that CWG reconsider this aspect of the resolution.</p>\n<p id=\"so_36098055_36648819_2\">On a related note, the resolution of issue 496 also changed 3.9\n  [basic.types] paragraph 9, which makes volatile-qualified scalar types\n  \u201ctrivial\u201d but not \u201ctrivially copyable.\u201d It is not clear why there is a\n  distinction made here; the only actual use of \u201ctrivial type\u201d in the\n  Standard appears to be in the description of qsort, which should\n  probably use \u201ctrivially copyable.\u201d (See also issue 1746.)</p>\n</blockquote>\n<p>From the description of issue (from 30.12.2004):</p>\n<blockquote>\n<ol start=\"496\">\n<li>Is a volatile-qualified type really a POD? :</li>\n</ol>\n<p id=\"so_36098055_36648819_3\">However in 3.9 [basic.types] paragraph 3, the standard makes it clear\n  that PODs can be copied \u201cas if\u201d they were a collection of bytes by\n  memcpy:</p>\n<p id=\"so_36098055_36648819_4\">For any POD type T, if two pointers to T point to distinct T objects\n  obj1 and obj2, where neither obj1 nor obj2 is a base-class subobject,\n  if the value of obj1 is copied into obj2, using the std::memcpy\n  library function, obj2 shall subsequently hold the same value as obj1.\n  The problem with this is that a volatile qualified type may need to be\n  copied in a specific way (by copying using only atomic operations on\n  multithreaded platforms, for example) in order to avoid the \u201cmemory\n  tearing\u201d that may occur with a byte-by-byte copy.</p>\n<p id=\"so_36098055_36648819_5\">I realise that the standard says very little about volatile qualified\n  types, and nothing at all (yet) about multithreaded platforms, but\n  nonetheless this is a real issue, for the following reason:</p>\n<p id=\"so_36098055_36648819_6\">The forthcoming TR1 will define a series of traits that provide information about the properties of a type, including whether a type is a POD and/or has trivial construct/copy/assign operations. Libraries can use this information to optimise their code as appropriate, for example an array of type T might be copied with a memcpy rather than an element-by-element copy if T is a POD. This was one of the main motivations behind the type traits chapter of the TR1. However it's not clear how volatile types (or POD's which have a volatile type as a member) should be handled in these cases.Notes from the April, 2005 meeting:</p>\n<p id=\"so_36098055_36648819_7\">It is not clear whether the volatile qualifier actually guarantees atomicity in this way. Also, the work on the memory model for multithreading being done by the Evolution Working Group seems at this point likely to specify additional semantics for volatile data, and that work would need to be considered before resolving this issue.</p>\n</blockquote>\n", "LastActivityDate": "2016-05-02T09:38:17.827"}, "36098055": {"CommentCount": "12", "AcceptedAnswerId": "36648819", "PostTypeId": "1", "LastEditorUserId": "2294360", "CreationDate": "2016-03-19T05:01:28.127", "LastActivityDate": "2016-05-02T09:38:17.827", "LastEditDate": "2016-03-19T16:16:21.857", "ViewCount": "446", "FavoriteCount": "1", "Title": "std::is_trivially_copyable - Why are volatile scalar types not trivially copyable?", "Id": "36098055", "Score": "18", "Body": "<p>The current standards for C++17 (and I've observed similar wording for C++11) have very confusing wording for trivially copyable types. I first stumbled upon this problem with the following code (GCC 5.3.0):</p>\n<pre><code>class TrivialClass {};\nstd::is_trivially_copyable&lt;int volatile&gt;::value; // 0\nstd::is_trivially_copyable&lt;TrivialClass volatile&gt;::value; // 1 ??\n</code></pre>\n<p>Making the confusion even worse, I tried checking to see what <code>std::is_trivial</code> had to say about the matter, only being brought to more confusion.</p>\n<pre><code>class TrivialClass {};\nstd::is_trivial&lt;int volatile&gt;::value; // 1 ??\nstd::is_trivial&lt;TrivialClass volatile&gt;::value; // 1\n</code></pre>\n<p>Confused, I checked the latest C++17 draft to see if something was amiss, and I found some slightly ambiguous wording which might be the culprit:</p>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.73\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.73</a></p>\n<blockquote>\n<p id=\"so_36098055_36098055_0\">cv-unqualified scalar types, trivially copyable class types (Clause 9), arrays of such types, and non-volatile const-qualified versions of these types (3.9.3) are collectively called trivially copyable types.</p>\n</blockquote>\n<p>Here is the information on trivially copyable classes:</p>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.226\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.226</a></p>\n<blockquote>\n<p id=\"so_36098055_36098055_1\">A trivially copyable class is a class that:</p>\n<p id=\"so_36098055_36098055_2\">\u2014 (6.1) has no non-trivial copy constructors (12.8),</p>\n<p id=\"so_36098055_36098055_3\">\u2014 (6.2) has no non-trivial move constructors (12.8),</p>\n<p id=\"so_36098055_36098055_4\">\u2014 (6.3) has no non-trivial copy assignment operators (13.5.3, 12.8),</p>\n<p id=\"so_36098055_36098055_5\">\u2014 (6.4) has no non-trivial move assignment operators (13.5.3, 12.8), and</p>\n<p id=\"so_36098055_36098055_6\">\u2014 (6.5) has a trivial destructor (12.4).</p>\n</blockquote>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#section.12.8\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#section.12.8</a></p>\n<p><strong>Constructors:</strong></p>\n<blockquote>\n<p id=\"so_36098055_36098055_7\">A copy/move constructor for class X is trivial if it is not user-provided, its parameter-type-list is equivalent to the parameter-type-list of an implicit declaration, and if</p>\n<p id=\"so_36098055_36098055_8\">\u2014 (12.1) class X has no virtual functions (10.3) and no virtual base classes (10.1), and</p>\n<p id=\"so_36098055_36098055_9\">\u2014 (12.2) class X has <strong>no non-static data members of volatile-qualified type</strong>, and</p>\n<p id=\"so_36098055_36098055_10\">\u2014 (12.3) the constructor selected to copy/move each direct base class subobject is trivial, and</p>\n<p id=\"so_36098055_36098055_11\">\u2014 (12.4) for each non-static data member of X that is of class type (or array thereof), the constructor selected to copy/move that member is trivial;</p>\n<p id=\"so_36098055_36098055_12\">otherwise the copy/move constructor is non-trivial.</p>\n</blockquote>\n<p><strong>Assignment:</strong></p>\n<blockquote>\n<p id=\"so_36098055_36098055_13\">A copy/move assignment operator for class X is trivial if it is not user-provided, its parameter-type-list is equivalent to the parameter-type-list of an implicit declaration, and if</p>\n<p id=\"so_36098055_36098055_14\">\u2014 (25.1) class X has no virtual functions (10.3) and no virtual base classes (10.1), and</p>\n<p id=\"so_36098055_36098055_15\">\u2014 (25.2) class X has <strong>no non-static data members of volatile-qualified type</strong>, and</p>\n<p id=\"so_36098055_36098055_16\">\u2014 (25.3) the assignment operator selected to copy/move each direct base class subobject is trivial, and</p>\n<p id=\"so_36098055_36098055_17\">\u2014 (25.4) for each non-static data member of X that is of class type (or array thereof), the assignment operator selected to copy/move that member is trivial;</p>\n<p id=\"so_36098055_36098055_18\">otherwise the copy/move assignment operator is non-trivial.</p>\n</blockquote>\n<p><strong>Note: Updated this section with more information. I now believe this to be a bug in GCC. However this alone doesn't answer all my questions.</strong></p>\n<p>I could see that maybe it's because TrivialClass has no non-static members, as that would pass the above rules, so I added an int, and it still returns as trivially copyable.</p>\n<pre><code>class TrivialClass { int foo; };\nstd::is_trivially_copyable&lt;int volatile&gt;::value; // 0\nstd::is_trivially_copyable&lt;TrivialClass volatile&gt;::value; // 1 ??\n</code></pre>\n<p>The standard states that volatile should be inherited by sub-objects of a volatile object. Meaning <code>TrivialClass volatile</code>'s non-static data member <code>foo</code> should now be of type <code>int volatile</code>.</p>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.76\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.76</a></p>\n<blockquote>\n<p id=\"so_36098055_36098055_19\">A volatile object is an object of type volatile T, a subobject of such an object, or a mutable subobject of a const volatile object</p>\n</blockquote>\n<p>We can confirm this is working in GCC via:</p>\n<pre><code>std::is_same&lt;decltype(((TrivialClass volatile*)nullptr)-&gt;foo), int volatile&gt;::value; // 1! (Expected)\n</code></pre>\n<p>Confused, I then added a volatile to <code>int foo</code> itself. It still passes, which is obviously a bug!</p>\n<p><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68905#c1\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68905#c1</a></p>\n<pre><code>class TrivialClass { int volatile foo; };\nstd::is_trivially_copyable&lt;int volatile&gt;::value; // 0\nstd::is_trivially_copyable&lt;TrivialClass volatile&gt;::value; // 1 ??\n</code></pre>\n<p>Moving on, we see that <code>std::is_trivial</code> is also working as expected:</p>\n<p><a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.73\">http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf#page.73</a></p>\n<blockquote>\n<p id=\"so_36098055_36098055_20\">Scalar types, trivial class types (Clause 9), arrays of such types and cv-qualified versions of these types (3.9.3) are collectively called trivial types.</p>\n</blockquote>\n<p>Okay, so I have a lot of questions here.</p>\n<ul>\n<li><strong>Why does volatile matter for is_trivially_copyable and not is_trivial?</strong></li>\n<li><strong>What's the deal with is_trivially_copyable and object types, is it a bug or an issue with the standard?</strong></li>\n<li><strong>Why does it matter if something is volatile anyways?</strong></li>\n</ul>\n<p>Can anyone help me wrap my head around this, I'm really at a loss here.</p>\n", "Tags": "<c++><c++11><standards><volatile><typetraits>", "OwnerUserId": "1477705", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_36098055_36098055_11": {"section_id": 461, "quality": 0.9285714285714286, "length": 13}, "so_36098055_36098055_10": {"section_id": 461, "quality": 0.9, "length": 9}, "so_36098055_36098055_0": {"section_id": 7207, "quality": 0.8571428571428571, "length": 18}, "so_36098055_36098055_9": {"section_id": 461, "quality": 0.8571428571428571, "length": 6}, "so_36098055_36098055_20": {"section_id": 7207, "quality": 0.8823529411764706, "length": 15}, "so_36098055_36098055_12": {"section_id": 461, "quality": 1.0, "length": 4}, "so_36098055_36098055_18": {"section_id": 474, "quality": 1.0, "length": 5}, "so_36098055_36098055_19": {"section_id": 7225, "quality": 0.9230769230769231, "length": 12}, "so_36098055_36098055_7": {"section_id": 461, "quality": 1.0, "length": 11}, "so_36098055_36098055_8": {"section_id": 369, "quality": 0.6666666666666666, "length": 6}, "so_36098055_36098055_4": {"section_id": 5850, "quality": 0.6666666666666666, "length": 4}, "so_36098055_36098055_14": {"section_id": 369, "quality": 0.6666666666666666, "length": 6}, "so_36098055_36098055_5": {"section_id": 5850, "quality": 0.6666666666666666, "length": 4}, "so_36098055_36098055_16": {"section_id": 474, "quality": 0.9090909090909091, "length": 10}, "so_36098055_36098055_1": {"section_id": 4706, "quality": 1.0, "length": 4}, "so_36098055_36098055_15": {"section_id": 461, "quality": 0.8571428571428571, "length": 6}, "so_36098055_36098055_13": {"section_id": 474, "quality": 1.0, "length": 12}, "so_36098055_36098055_17": {"section_id": 474, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_36098055_36098055_11": {"section_id": 452, "quality": 0.9285714285714286, "length": 13}, "so_36098055_36098055_10": {"section_id": 452, "quality": 0.9, "length": 9}, "so_36098055_36098055_0": {"section_id": 6951, "quality": 0.7142857142857143, "length": 15}, "so_36098055_36098055_9": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_36098055_36098055_20": {"section_id": 6951, "quality": 0.8823529411764706, "length": 15}, "so_36098055_36098055_12": {"section_id": 452, "quality": 1.0, "length": 4}, "so_36098055_36098055_18": {"section_id": 465, "quality": 1.0, "length": 5}, "so_36098055_36098055_19": {"section_id": 6969, "quality": 0.6153846153846154, "length": 8}, "so_36098055_36098055_8": {"section_id": 359, "quality": 0.6666666666666666, "length": 6}, "so_36098055_36098055_4": {"section_id": 5620, "quality": 0.6666666666666666, "length": 4}, "so_36098055_36098055_14": {"section_id": 359, "quality": 0.6666666666666666, "length": 6}, "so_36098055_36098055_5": {"section_id": 5620, "quality": 0.6666666666666666, "length": 4}, "so_36098055_36098055_16": {"section_id": 465, "quality": 0.9090909090909091, "length": 10}, "so_36098055_36098055_1": {"section_id": 4515, "quality": 1.0, "length": 4}, "so_36098055_36098055_15": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_36098055_36098055_17": {"section_id": 465, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_36098055_36098055_11": {"section_id": 484, "quality": 0.9285714285714286, "length": 13}, "so_36098055_36098055_0": {"section_id": 8716, "quality": 0.7619047619047619, "length": 16}, "so_36098055_36098055_9": {"section_id": 382, "quality": 0.7142857142857143, "length": 5}, "so_36098055_36098055_10": {"section_id": 484, "quality": 0.9, "length": 9}, "so_36098055_36098055_18": {"section_id": 495, "quality": 0.8, "length": 4}, "so_36098055_36098055_19": {"section_id": 8735, "quality": 0.9230769230769231, "length": 12}, "so_36098055_36098055_8": {"section_id": 383, "quality": 0.6666666666666666, "length": 6}, "so_36098055_36098055_14": {"section_id": 383, "quality": 0.6666666666666666, "length": 6}, "so_36098055_36098055_1": {"section_id": 6103, "quality": 1.0, "length": 4}, "so_36098055_36098055_16": {"section_id": 497, "quality": 0.9090909090909091, "length": 10}, "so_36098055_36098055_20": {"section_id": 8716, "quality": 0.8823529411764706, "length": 15}, "so_36098055_36098055_15": {"section_id": 382, "quality": 0.7142857142857143, "length": 5}, "so_36098055_36098055_17": {"section_id": 497, "quality": 0.9333333333333333, "length": 14}}}});