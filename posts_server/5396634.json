post_cb({"bq_ids": {"n4140": {"so_5396634_5396710_0": {"length": 28, "quality": 1.0, "section_id": 986}}, "n3337": {"so_5396634_5396710_0": {"length": 28, "quality": 1.0, "section_id": 971}}, "n4659": {"so_5396634_5396710_0": {"length": 28, "quality": 1.0, "section_id": 1049}}}, "5396634": {"ViewCount": "1438", "Body": "<p>Is this example code valid?</p>\n<pre><code>#include&lt;vector&gt;\nusing namespace std;\n\nint main() {\n  vector&lt;int&gt; vec(10); // create with 10 elements\n  vec.reserve(100);    // set capacity to 100\n  vector&lt;int&gt;::iterator iter = vec.end(); // points 1 past vec[9]\n\n  vec.push_back( 777 );\n\n  bool is_this_valid_and_true =  *iter == vec[10]; // ?\n\n  // VS2010 runtime error in debug build:\n  // Expression: vector iterator not dereferencable\n  // Works in release build\n\n  iter = vec.end() + 1; // points 2 past vec[10]?\n  vec.push_back( 888 );\n  vec.push_back( 999 );\n\n  is_this_valid_and_true =  *iter == vec[12]; // ?\n}\n</code></pre>\n<p><strike>The error in VS2010 may be related to this <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/557029/visual-c-iterator-debugging-incorrectly-raises-assertion-on-correct-use-of-return-value-of-std-vector-erase#details\" rel=\"nofollow\">bug</a>.</strike></p>\n<p>If I set the command line option <code>/D_HAS_ITERATOR_DEBUGGING=0</code> or set</p>\n<pre><code>#define _HAS_ITERATOR_DEBUGGING 0\n#include&lt;vector&gt;\n</code></pre>\n<p>there is no error.</p>\n<p><strong>Edit:</strong></p>\n<p>In light of the answers, I think this code should cause an error. There is no bug in the compiler. It only works in release mode because iterators are implemented as pointers.</p>\n", "AcceptedAnswerId": "5396748", "Title": "Is an Iterator to vec.end() still valid after vec.push_back() when there is no reallocation", "CreationDate": "2011-03-22T19:21:14.877", "Id": "5396634", "CommentCount": "1", "LastEditDate": "2011-03-22T20:24:28.827", "PostTypeId": "1", "LastEditorUserId": "446788", "LastActivityDate": "2011-03-22T20:24:28.827", "Score": "1", "OwnerUserId": "446788", "Tags": "<c++><iterator>", "AnswerCount": "2"}, "5396748": {"Id": "5396748", "PostTypeId": "2", "Body": "<p>You are thinking of iterators as pointers.</p>\n<p>Iterators may use pointers as an implementation detail but they are not actual pointers.</p>\n<p>Thus:</p>\n<pre><code>iter = vec.end() + 1; // This is not valid.\n</code></pre>\n<p>There is no such thing as two elements passed the end of data.</p>\n<p>vec.end() returns an iterator that when decrement is a reference to the last elements (assuming there are elements). While an iterator referencing the last element when incremented is equivalent to the iterator returned by end().</p>\n<pre><code>// Note: Assuming vector iterators were not invalidated after an insert anyway.\n//       But for arguments sake lets play this out.\n//\nvector&lt;int&gt;::iterator iter = vec.end(); // points 1 past vec[9]\nvec.push_back( 777 );\nbool is_this_valid_and_true =  *iter == vec[10]; // Not valid.\n                                                 // This is the end() iterator\n                                                 // de-referencing it is UB\n</code></pre>\n<p>But de-referenceing the iterator representing by end() is undefined behavior() (even if you have reserved space) (the implementation may not be using pointers. For example some of the DeBug STL implementations will do extensive error checking in the iterator code).</p>\n", "LastEditorUserId": "14065", "LastActivityDate": "2011-03-22T19:37:03.740", "Score": "6", "CreationDate": "2011-03-22T19:30:56.263", "ParentId": "5396634", "CommentCount": "5", "LastEditDate": "2011-03-22T19:37:03.740", "OwnerUserId": "14065"}, "5396710": {"Id": "5396710", "PostTypeId": "2", "Body": "<p>23.2.4.3/1: </p>\n<blockquote>\n<p id=\"so_5396634_5396710_0\">Causes reallocation if the new size is\n  greater than the old capacity. If no\n  reallocation happens, all the\n  iterators and references <strong>before</strong>\n  the insertion point remain valid. If\n  an exception is thrown other than by\n  the copy constructor or assignment\n  operator of T there are no effects.</p>\n</blockquote>\n<p>So no, <code>end()</code> doesn't have to be valid after <code>push_back</code>. The quote is in relation to <code>vector.insert</code>, <code>push_back</code> is defined in terms of <code>insert</code></p>\n", "LastActivityDate": "2011-03-22T19:27:37.270", "Score": "7", "CreationDate": "2011-03-22T19:27:37.270", "ParentId": "5396634", "CommentCount": "1", "OwnerUserId": "616700"}});