post_cb({"bq_ids": {"n4140": {"so_43609186_43609303_0": {"length": 111, "quality": 0.940677966101695, "section_id": 3919}, "so_43609186_43609303_2": {"length": 58, "quality": 0.90625, "section_id": 3344}}, "n3337": {"so_43609186_43609303_2": {"length": 58, "quality": 0.90625, "section_id": 3214}, "so_43609186_43609303_0": {"length": 111, "quality": 0.940677966101695, "section_id": 3779}}, "n4659": {"so_43609186_43609303_0": {"length": 61, "quality": 0.5169491525423728, "section_id": 4805}}}, "43609186": {"ViewCount": "126", "Body": "<p>How should I work with exceptions throwed from constructors of local static objects? For example I have following code:</p>\n<pre><code>class A\n{\npublic:\n    A() {throw runtime_error(\"Ooops\");}\n};\n\nvoid foo()\n{\n    static A a = A();\n    cout &lt;&lt; \"Continue\" &lt;&lt; endl;\n}\n\nint main(void)\n{\n    try\n    {\n        foo();\n    }\n    catch(...)\n    {\n    }\n    foo(); // Prints continue\n    return 0;\n}\n</code></pre>\n<p>As I understand, in the case of second calling <code>foo</code> method, object <code>a</code> is treated as fully constructed object, and constructor is not called. (More over, it seems like destructor of <code>a</code> due first exception throwing is not called)</p>\n", "AcceptedAnswerId": "43609303", "Title": "Local static object and exception", "CreationDate": "2017-04-25T11:15:26.317", "Id": "43609186", "CommentCount": "16", "LastEditDate": "2017-04-25T11:26:46.907", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2017-04-25T11:31:43.217", "Score": "3", "OwnerUserId": "4444768", "Tags": "<c++><visual-studio-2015>", "AnswerCount": "2"}, "43609303": {"Id": "43609303", "PostTypeId": "2", "Body": "<p><strong>If that's true, then that is a compiler bug.</strong></p>\n<p><em>(However, <a href=\"https://stackoverflow.com/questions/43609186/local-static-object-and-exception/43609303#comment74267311_43609300\">VTT claims that this code produces the expected result with Visual Studio 2015</a>, so I recommend double-checking your results.)</em></p>\n<p>Here's the standard-mandated behaviour:</p>\n<blockquote>\n<p id=\"so_43609186_43609303_0\"><code>[C++14: 6.7/4]:</code> The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a block-scope entity with static storage duration, if applicable, is performed before its block is first entered. An implementation is permitted to perform early initialization of other block-scope variables with static or\n  thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. <strong>If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration.</strong> If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization. If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined. <em>[..]</em></p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/4b0827340e3da9f8\" rel=\"nofollow noreferrer\">GCC 6.3.0 correctly attempts to reconstruct the <code>A</code></a> (and thus throws again).</p>\n<hr>\n<blockquote>\n<p id=\"so_43609186_43609303_1\">More over, it seems like destructor of a due first exception throwing is not called</p>\n</blockquote>\n<p>No, it won't be. You can't destroy an object that was never successfully created in the first place.</p>\n<blockquote>\n<p id=\"so_43609186_43609303_2\"><code>[C++14: 15.2/2]:</code> An object of any storage duration whose initialization or destruction is terminated by an exception will have destructors executed for all of its fully constructed subobjects (excluding the variant members of a union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution. Similarly, <strong>if the non-delegating constructor for an object has completed execution and a delegating constructor for that object exits with an exception, the object\u2019s destructor will be invoked.</strong> If the object was allocated in a <em>new-expression</em>, the matching deallocation function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.</p>\n</blockquote>\n<hr>\n<p>By the way, this doesn't fix the problem, but you should just write:</p>\n<pre><code>static A a;\n</code></pre>\n<p>The copy-initialisation from a temporary is pointless.</p>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2017-04-25T11:31:43.217", "Score": "4", "CreationDate": "2017-04-25T11:21:30.330", "ParentId": "43609186", "CommentCount": "5", "OwnerUserId": "560648", "LastEditDate": "2017-04-25T11:31:43.217"}, "43609300": {"Id": "43609300", "PostTypeId": "2", "Body": "<p>Each instance of static local variable also implicitly creates a global Boolean variable that will be set to true after static variable is constructed. If constructor throws than the next time method is called there will be another attempt to construct a static variable.</p>\n", "LastActivityDate": "2017-04-25T11:21:21.653", "CommentCount": "3", "CreationDate": "2017-04-25T11:21:21.653", "ParentId": "43609186", "Score": "2", "OwnerUserId": "7860670"}});