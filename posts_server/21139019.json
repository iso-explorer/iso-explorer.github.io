post_cb({"21139095": {"ParentId": "21139019", "CommentCount": "0", "Body": "<p>There are no runtime checks.  <code>printf</code> will just blindly read whatever gibberish is on the stack (or whatever var-arg mechanism is being used).  In the case of <code>%s</code>, it interprets the gibberish as a pointer, and then attempts to read stuff from that address, typically leading to an access violation.<sup>*</sup></p>\n<p>In essence, what you're seeing is <em>undefined behaviour</em>.</p>\n<hr>\n<p><sub>* Ok, I guess this is a sort-of runtime check, at the OS/HW level.</sub></p>\n</hr>", "OwnerUserId": "129570", "PostTypeId": "2", "Id": "21139095", "Score": "2", "CreationDate": "2014-01-15T13:45:10.217", "LastActivityDate": "2014-01-15T13:45:10.217"}, "21139234": {"ParentId": "21139019", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In this case the <em>C++</em> standard fall back on the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">C99 draft standard</a> which says this is undefined behavior in section <code>7.19.6.1</code> <em>The fprintf function</em> which covers <code>printf</code> with respect format specifiers, says:</p>\n<blockquote>\n<p id=\"so_21139019_21139234_0\">[...]If there are insufficient arguments for the format, the behavior is\n  undefined.</p>\n</blockquote>\n<p>So as the standard says in the definition for undefined behavior:</p>\n<blockquote>\n<p id=\"so_21139019_21139234_1\">Possible undefined behavior ranges from ignoring the situation completely with unpredictable\n  results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</p>\n</blockquote>\n<p>anything can happen. </p>\n<p>Since <code>printf</code> is a <a href=\"http://en.cppreference.com/w/cpp/utility/variadic\" rel=\"nofollow\">variadic function</a> it has to rely on the caller to correctly represent the data passed in. So run time checking is not possible. Although several compilers do provide compile time checking, for example <code>gcc</code> even provides this checking as an attribute <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.0.1/gcc/Function-Attributes.html#Function-Attributes\" rel=\"nofollow\">format (archetype, string-index, first-to-check)</a> which can be used with your own functions.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-01-15T15:07:28.013", "Id": "21139234", "Score": "5", "CreationDate": "2014-01-15T13:51:00.760", "LastActivityDate": "2014-01-15T15:07:28.013"}, "21139019": {"CommentCount": "14", "AcceptedAnswerId": "21139234", "PostTypeId": "1", "LastEditorUserId": "241536", "CreationDate": "2014-01-15T13:41:56.473", "LastActivityDate": "2014-01-15T15:14:46.620", "LastEditDate": "2014-01-15T14:08:52.563", "ViewCount": "453", "FavoriteCount": "0", "Title": "Different run-time checking of printf() for %s?", "Id": "21139019", "Score": "2", "Body": "<p>I know that, to use <a href=\"http://en.cppreference.com/w/cpp/io/c/fprintf\" rel=\"nofollow\"><code>printf()</code></a> correctly, we need to further pass in same number of values according to what are defined in the <code>const char* format</code>, i.e. <code>%s/%f/%d...</code>.</p>\n<pre><code>int printf( const char* format, ... );\n</code></pre>\n<p>I just noticed that, although not recommended, it will run without any run-time errors if we don't pass in any values, like the following (of course, we will get un-expected results):</p>\n<pre><code>printf(\"%a\"); // ok\nprintf(\"%c\"); // ok\nprintf(\"%d\"); // ok\nprintf(\"%e\"); // ok\nprintf(\"%f\"); // ok\nprintf(\"%g\"); // ok\nprintf(\"%i\"); // ok\nprintf(\"%o\"); // ok\nprintf(\"%p\"); // ok\nprintf(\"%u\"); // ok\nprintf(\"%x\"); // ok\n</code></pre>\n<p>If this will holds for all formats, I will feel no surprised by thinking that <code>printf()</code> doesn't do any run-time checking. Weird thing is that, it will give run-time error for <code>%s</code> (also seems the only one).</p>\n<pre><code>printf(\"%s\"); // run-time error: Access violation reading location\n</code></pre>\n<p>Even more interesting thing is that, it seems that it only run-time checks for the first or consecutive of <code>%s</code>. Check out the following examples:</p>\n<pre><code>printf(\"%s%s\", \"xxx\"); // run-time error: Access violation reading location\nprintf(\"%s%d%s\", \"xxx\"); // ok\n</code></pre>\n<p>So, my question is that:</p>\n<ul>\n<li>Does <code>printf()</code> run-time check differently for <code>%s</code> compared with other formats? And why?</li>\n<li>Why does <code>printf()</code> only run-time check for the first or consecutive of <code>%s</code>?</li>\n</ul>\n<p>ps: I tested it under VS2010, OS: Win7x64.</p>\n", "Tags": "<c++><runtime-error><printf>", "OwnerUserId": "2589776", "AnswerCount": "6"}, "21139153": {"ParentId": "21139019", "CommentCount": "0", "Body": "<p>It is undefined behaviour, so anything may happen. In practice the difference you see may be due to the fact that all other specifiers you used refer to values directly on the stack, so garbage is displayed, but it does not crash. With %s it is different - the random value is treated as pointer, and your program accesses the random area of memory, so most likely it crashes.\nHaving said that, it is still undefined and should not be used.</p>\n", "OwnerUserId": "2382136", "PostTypeId": "2", "Id": "21139153", "Score": "0", "CreationDate": "2014-01-15T13:47:41.407", "LastActivityDate": "2014-01-15T13:47:41.407"}, "21139171": {"ParentId": "21139019", "CommentCount": "0", "Body": "<p><code>printf(\"%d\")</code>: An attempt to read 4 bytes from a possibly-illegal memory address.</p>\n<p><code>printf(\"%s\")</code>: An attempt to read an unknown number of bytes from a possibly-illegal memory address, until a byte with value 0 is encountered.</p>\n<p>In both cases, it's a \"matter of luck\" whether or not a memory access violation will take place.</p>\n<p>But as you can understand, these chances are much higher in the case of <code>\"%s\"</code>.</p>\n", "OwnerUserId": "1382251", "PostTypeId": "2", "Id": "21139171", "Score": "0", "CreationDate": "2014-01-15T13:48:10.257", "LastActivityDate": "2014-01-15T13:48:10.257"}, "21139162": {"ParentId": "21139019", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There are no runtime checks, techically hard to do those. But there are compilation checks available.</p>\n<p>With GCC it's <code>-Wall</code>.<br>With Visual Studio you need to run it's static analysis tool (available on the more expensive versions).</br></p>\n", "OwnerUserId": "3005057", "LastEditorUserId": "3005057", "LastEditDate": "2014-01-15T15:14:46.620", "Id": "21139162", "Score": "1", "CreationDate": "2014-01-15T13:47:51.640", "LastActivityDate": "2014-01-15T15:14:46.620"}, "bq_ids": {"n4140": {"so_21139019_21139234_0": {"section_id": 521, "quality": 0.6666666666666666, "length": 4}, "so_21139019_21139234_1": {"section_id": 5768, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_21139019_21139234_0": {"section_id": 512, "quality": 0.6666666666666666, "length": 4}, "so_21139019_21139234_1": {"section_id": 5541, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_21139019_21139234_0": {"section_id": 542, "quality": 0.6666666666666666, "length": 4}, "so_21139019_21139234_1": {"section_id": 7225, "quality": 0.9615384615384616, "length": 25}}}, "21139070": {"ParentId": "21139019", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>[ED: Note this question was originally tagged C++, and this answer assumes OP is compiling as C++]</p>\n<blockquote>\n<p id=\"so_21139019_21139070_0\">although not recommended, it will run without any run-time errors if\n  we don't pass in any values,</p>\n</blockquote>\n<p>No, this yields Undefined Behavior.  Anything can happen, including <em>what you expect</em>.  Doesn't mean its OK.</p>\n<p><code>printf</code> does <em>no</em> runtime checking of whatever junk you send it, if you send it anything at all.  The onus is upon <strong>you</strong> to ensure you write correct code.</p>\n<p>By the way ion your later case where you were getting \"unhandled exception\" errors -- this was not the result of <code>sprintf</code> doing runtiime checking.  This was another manifestation of Undefined Behavior.</p>\n<p>All of this odd and dangerous behavior is a result of the fact that sprintf is a type-unsafe, dangerous function.  It is very easy to write code that the compiler will happily accept, and will seem to run fine in testing or even in production for a while, but exhibits Undefined Behavior in some subtle way.  This usually bites you on Fridays an hour before you're going out for the weekend.</p>\n<p>The life lesson here is:  <strong>don't use sprintf in C++</strong>.  Use something modern and type-safe instead, like streams.</p>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2014-01-15T14:17:12.670", "Id": "21139070", "Score": "2", "CreationDate": "2014-01-15T13:44:10.807", "LastActivityDate": "2014-01-15T14:17:12.670"}});