post_cb({"bq_ids": {"n4140": {"so_14687396_14687642_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 7189}, "so_14687396_14687642_2": {"length": 64, "quality": 0.8767123287671232, "section_id": 7193}, "so_14687396_14687396_1": {"length": 13, "quality": 0.8125, "section_id": 440}}, "n3337": {"so_14687396_14687642_1": {"length": 33, "quality": 0.8048780487804879, "section_id": 6933}, "so_14687396_14687642_2": {"length": 67, "quality": 0.9178082191780822, "section_id": 6937}, "so_14687396_14687396_1": {"length": 13, "quality": 0.8125, "section_id": 431}}, "n4659": {"so_14687396_14687642_1": {"length": 29, "quality": 0.7073170731707317, "section_id": 8697}, "so_14687396_14687642_2": {"length": 63, "quality": 0.863013698630137, "section_id": 8702}, "so_14687396_14687396_1": {"length": 13, "quality": 0.8125, "section_id": 460}}}, "14687642": {"Id": "14687642", "PostTypeId": "2", "Body": "<p>I think that it is UB.</p>\n<p>As Mike said:</p>\n<blockquote>\n<p id=\"so_14687396_14687642_0\">At that point, storage has been allocated for the complete object, but only the base subobject has been initialised. Therefore, you can only use the rest of an object in the \"limited ways\" described in C++11.</p>\n</blockquote>\n<p>and it's my interpretation that this is not one of those ways.</p>\n<p>More formally:</p>\n<blockquote>\n<p id=\"so_14687396_14687642_1\"><code>[C++11: 3.8/1]:</code> The lifetime of an object is a runtime property of the object. <strong>An object is said to have non-trivial initialization if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial default constructor.</strong> [ <em>Note:</em> initialization by a trivial copy/move constructor is non-trivial initialization. \u2014\n  <em>end note</em> ] <strong>The lifetime of an object of type <code>T</code> begins when:</strong></p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li><strong>if the object has non-trivial initialization, its initialization is complete.</strong></li>\n</ul>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_14687396_14687642_2\"><code>[C++11: 3.8/5]:</code> <strong>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated</strong> or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, <strong>any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways.</strong> For an object under construction or destruction, see 12.7. Otherwise,\n  such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type <code>void*</code>, is well-defined. Such a pointer may be dereferenced but the resulting lvalue may only be used in limited ways, as described below. <strong>The program has undefined behavior if:</strong></p>\n<ul>\n<li>the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a <em>delete-expression</em>,</li>\n<li>the pointer is used to access a non-static data member or call a non-static member function of the object, or</li>\n<li>the pointer is implicitly converted (4.10) to a pointer to a base class type, or</li>\n<li><strong>the pointer is used as the operand of a <code>static_cast</code></strong> (5.2.9) (except when the conversion is to <code>void*</code>, or to <code>void*</code> and subsequently to <code>char*</code>, or <code>unsigned char*</code>), or </li>\n<li>the pointer is used as the operand of a <code>dynamic_cast</code> <em>[..]</em></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2013-02-04T13:19:35.900", "CommentCount": "7", "CreationDate": "2013-02-04T13:19:35.900", "ParentId": "14687396", "Score": "4", "OwnerUserId": "560648"}, "14687396": {"ViewCount": "190", "Body": "<p>Given the following example of CRTP:</p>\n<pre><code>template &lt;typename T&gt;\nint foo(T* const)\n{\n   return 0;\n}\n\ntemplate &lt;typename Derived&gt;\nstruct Base\n{\n   Base() : bar(foo(static_cast&lt;Derived*&gt;(this)) {};\n   int bar;\n};\n\nstruct Derived1 : Base&lt;Derived1&gt; {};\n</code></pre>\n<p><strong>Is the conversion of <code>this</code> to <code>Derived*</code> here valid?</strong> I seem to recall that it may not be, but can find no concrete evidence of this now.</p>\n<p>The \"natural\" type of <code>this</code> at this stage is <code>Base* const</code>, and there are certainly some occasions in which even statically casting the <code>this</code> pointer during initialisation is not okay, such as <em>upcasting</em> before base construction has completed (12.7/3).</p>\n<p>@DeadMG says:</p>\n<blockquote>\n<p id=\"so_14687396_14687396_0\">there's an explicit exception in the Standard w.r.t. obtaining this in the initializer list. it's for passing pointers to yourself to subobjects.</p>\n</blockquote>\n<p>12.6.2/12 does say:</p>\n<blockquote>\n<p id=\"so_14687396_14687396_1\">[ Note: Because the mem-initializer are evaluated in the scope of the constructor, the this pointer can be used in the expression-list of a mem-initializer to refer to the object being initialized. \u2014end note ]</p>\n</blockquote>\n<p>... though this is not sufficient to say that the conversion to <code>Derived*</code> is valid.</p>\n<p>My intuition is that, during this phase of the object's initialisation, <code>this</code> does <em>not</em> point to an instance of <code>Derived</code> and, as such, even just <em>having</em> a pointer to it with type <code>Derived*</code> is, strictly speaking, UB. That's because it's neither a valid pointer nor a null pointer.</p>\n<p>(This potentially has practical ramifications for approaches like <a href=\"https://stackoverflow.com/a/14686833/560648\">this</a>, though in that answer and my example above the whole thing could be side-stepped by simply writing <code>static_cast&lt;Derived*&gt;(0)</code> instead.)</p>\n", "Title": "Is it legal to cast this to `Derived*` in the base ctor-initialiser?", "CreationDate": "2013-02-04T13:05:13.880", "LastActivityDate": "2013-02-04T13:19:35.900", "CommentCount": "9", "LastEditDate": "2017-05-23T12:32:36.900", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "14687396", "Score": "12", "OwnerUserId": "560648", "Tags": "<c++><language-lawyer>", "AnswerCount": "1"}});