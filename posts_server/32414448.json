post_cb({"32414448": {"ViewCount": "44", "Body": "<p>For example:</p>\n<pre><code>template &lt;typename T&gt; void g(T &amp;&amp;val);\nint i = 0; const int ci = i;\ng(i = ci);\n</code></pre>\n<p>What is the template argument of <code>g</code>?</p>\n", "AcceptedAnswerId": "32414467", "Title": "Is the assignment expression a lvalue refrence?", "CreationDate": "2015-09-05T14:55:44.217", "Id": "32414448", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-09-05T14:58:10.133", "Score": "3", "OwnerUserId": "1546088", "Tags": "<c++>", "AnswerCount": "1"}, "32414467": {"Id": "32414467", "PostTypeId": "2", "Body": "<p>As per \u00a75.18/1:</p>\n<blockquote>\n<p id=\"so_32414448_32414467_0\">The assignment operator (=) and the compound assignment operators all group right-to-left. All require a modifiable lvalue as their left operand and return an lvalue referring to the left operand. [...]</p>\n</blockquote>\n<p>So, in</p>\n<pre><code>g(i = ci)\n</code></pre>\n<p>the left operand, <code>i</code>, is returned and therefore <code>T</code> is deduced to <code>int&amp;</code>.</p>\n<p>You can check this via this snippet:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt; \nvoid g(T &amp;&amp;val) {\n    static_assert(std::is_same&lt;T, int&amp;&gt;::value, \"Nope\");\n}\n\nint main() {\n    int i = 0; const int ci = i;\n    g(i = ci);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bb8d006d78558c19\"><kbd>Live demo</kbd></a></p>\n", "LastActivityDate": "2015-09-05T14:58:10.133", "CommentCount": "0", "CreationDate": "2015-09-05T14:58:10.133", "ParentId": "32414448", "Score": "5", "OwnerUserId": "493122"}, "bq_ids": {"n4140": {"so_32414448_32414467_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6173}}, "n3337": {"so_32414448_32414467_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5934}}, "n4659": {"so_32414448_32414467_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 7675}}}});