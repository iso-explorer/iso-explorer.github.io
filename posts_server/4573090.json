post_cb({"bq_ids": {"n4140": {"so_4573090_4573103_0": {"length": 7, "quality": 0.7, "section_id": 5428}}, "n3337": {"so_4573090_4573103_0": {"length": 7, "quality": 0.7, "section_id": 5223}}}, "4573103": {"PostTypeId": "2", "Body": "<p>Your problem isn't that the struct is unnamed, it's that the struct is declared locally.  Using local types as template arguments is not permitted in C++03.  It will be in C++0x though, so you might try upgrading your compiler.</p>\n<p>EDIT: Actually, your problem is that inside a template argument list isn't a legal place to put a class definition, with or without a name, according to the C++ standard.</p>\n<p>litb points out that although it fits into the C++0x grammar, defining a type here is forbidden by <code>[dcl.type]</code>:</p>\n<blockquote>\n<p id=\"so_4573090_4573103_0\">A type-speci\ufb01er-seq shall not de\ufb01ne a class or enumeration unless it appears in the type-id of an alias-declaration (7.1.3) that is not the declaration of a template-declaration.</p>\n</blockquote>\n<pre><code>simple-template-id:\n    template-name &lt; template-argument-list_opt &gt;\n\ntemplate-argument-list:\n    template-argument ..._opt\n    template-argument-list , template-argument ..._opt\n\ntemplate-argument:\n    constant-expression\n    type-id\n    id-expression\n\ntype-id:\n    type-speci\ufb01er-seq abstract-declarator_opt\n\ntype-speci\ufb01er-seq:\n    type-speci\ufb01er attribute-speci\ufb01er-seq_opt\n    type-speci\ufb01er type-speci\ufb01er-seq\n\ntype-speci\ufb01er:\n    trailing-type-speci\ufb01er\n    class-speci\ufb01er\n    enum-speci\ufb01er\n\nclass-speci\ufb01er:\n    class-head { member-speci\ufb01cation_opt }\n</code></pre>\n<p>For a while I had a question about typedef names, but litb cleared that up.  They are allowed as template arguments via:</p>\n<pre><code>trailing-type-speci\ufb01er:\n    simple-type-speci\ufb01er\n    elaborated-type-speci\ufb01er\n    typename-speci\ufb01er\n    cv-quali\ufb01er\n\nsimple-type-speci\ufb01er:\n    :: opt nested-name-speci\ufb01er_opt type-name\n    :: opt nested-name-speci\ufb01er template simple-template-id\n    char\n    char16_t\n    char32_t\n    wchar_t\n    bool\n    short\n    int\n    long\n    signed\n    unsigned\n    float\n    double\n    void\n    auto\n    decltype-speci\ufb01er\n\ntype-name:\n    class-name\n    enum-name\n    typedef-name\n    simple-template-id\n</code></pre>\n", "LastActivityDate": "2011-01-01T05:35:59.667", "LastEditorUserId": "103167", "Id": "4573103", "CommentCount": "13", "CreationDate": "2011-01-01T03:35:56.697", "ParentId": "4573090", "Score": "4", "OwnerUserId": "103167", "LastEditDate": "2011-01-01T05:35:59.667"}, "4573104": {"PostTypeId": "2", "Body": "<p>You are not allowed to <em>define</em> an unnamed type as a template argument in C++03 or even in C++0x.</p>\n<p>The best you can do it to create a named struct local to main (in C++0x<sup>1</sup>)</p>\n<p><sub>1 :  You are not allowed to use a local type as template argument in C++03, however C++0x allows it.</sub></p>\n<p>Also check out the Defect Report <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#62\" rel=\"noreferrer\">here</a>. The proposed solution mentions </p>\n<blockquote>\n<p id=\"so_4573090_4573104_0\">The following types shall not be used as a template-argument for a template type-parameter:</p>\n<ul>\n<li>a type whose name has no linkage</li>\n<li><strong>an unnamed class or enumeration type that has no name for linkage purposes (7.1.3 [dcl.typedef])</strong></li>\n<li>a cv-qualified version of one of the types in this list</li>\n<li>a type created by application of declarator operators to one of the types in this list</li>\n<li>a function type that uses one of the types in this list</li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_4573090_4573104_1\">The compiler complains when I try to use an anonymous struct as a template parameter.</p>\n</blockquote>\n<p>Did you mean template argument? Template parameter is different from template argument.</p>\n<p>For example</p>\n<pre><code>template &lt; typename T &gt; // T is template parameter\nclass demo {};\n\nint main()\n{\n   demo &lt;int&gt; x; // int is template argument\n}\n</code></pre>\n</hr>", "LastActivityDate": "2011-01-01T09:04:35.100", "LastEditorUserId": "165520", "Id": "4573104", "CommentCount": "6", "CreationDate": "2011-01-01T03:36:48.837", "ParentId": "4573090", "Score": "7", "OwnerUserId": "165520", "LastEditDate": "2011-01-01T09:04:35.100"}, "4573090": {"ViewCount": "4721", "Body": "<p>The title is pretty self-explanatory, but here's a simplified example:</p>\n<pre><code>#include &lt;cstdio&gt;\n\ntemplate &lt;typename T&gt;\nstruct MyTemplate {\n\n    T member;\n\n    void printMemberSize() {\n        printf(\"%i\\n\", sizeof(T));\n    }\n\n};\n\nint main() {\n\n    MyTemplate&lt;struct { int a; int b; }&gt; t; // &lt;-- compiler doesn't like this\n\n    t.printMemberSize();\n\n    return 0;\n\n}\n</code></pre>\n<p>The compiler complains when I try to use an anonymous struct as a template argument.  What's the best way to achieve something like this without having to have a separate, named struct definition?</p>\n", "AcceptedAnswerId": "4573104", "Title": "Can we have an anonymous struct as template argument?", "CreationDate": "2011-01-01T03:28:03.133", "Id": "4573090", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-01-01T04:27:42.263", "LastEditorUserId": "276606", "LastActivityDate": "2011-01-01T09:04:35.100", "Score": "10", "OwnerUserId": "276606", "Tags": "<c++><templates><parameters><struct><anonymous-types>", "AnswerCount": "2"}});