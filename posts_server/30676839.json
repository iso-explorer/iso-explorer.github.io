post_cb({"32572451": {"ParentId": "30676839", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I would like to argue that the Standard does not support SFINAE in partial specializations, due to a wording defect. Let's start with [temp.class.spec.match]:</p>\n<blockquote>\n<p id=\"so_30676839_32572451_0\">A partial specialization matches a given actual template argument list if the template arguments of the\n  partial specialization <strong>can be deduced</strong> from the actual template argument list (14.8.2).</p>\n</blockquote>\n<p>And, from [temp.deduct], the SFINAE clause:</p>\n<blockquote>\n<p id=\"so_30676839_32572451_1\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is\n  one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note:\n  If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution\n  process. \u2014end note ] Only invalid types and expressions in the immediate context of <strong>the function type and its template parameter types</strong> can result in a deduction failure.</p>\n</blockquote>\n<p>The slightly-modified example<sup>\u2020</sup> from CWG is:</p>\n<pre><code>template &lt;class T, class U&gt; struct X   {\n    typedef char member;\n};\n\ntemplate&lt;class T&gt; struct X&lt;T,\n     typename enable_if&lt;(sizeof(T)&gt;sizeof(\n float)), float&gt;::type&gt;\n{\n    typedef long long member;\n};\n\nint main() {\n    cout &lt;&lt; sizeof(X&lt;char, float&gt;::member);\n}\n</code></pre>\n<p>Name lookup on <code>X</code> finds the primary, with <code>T == char, U == float</code>. We look at the one partial specialization, and see if it \"matches\" - which means that the template arguments \"can be deduced\" - which is to say:</p>\n<pre><code>+-------------+--------+-------------------------------------------------+\n|             | arg1     arg2                                            |\n+-------------+--------+-------------------------------------------------+\n| deduce T in | T      | enable_if_t&lt;(sizeof(T) &gt; sizeof(float), float&gt;  |\n| from        | char   | float                                           |\n+-------------+--------+-------------------------------------------------+\n</code></pre>\n<p>Normal template deduction rules apply. The second \"argument\" is a non-deducible context, so we deduce <code>T</code> as <code>char</code>. <code>sizeof(char) &gt; sizeof(float)</code>, is false, and <code>enable_if_t&lt;false, float&gt;</code> is an invalid type, so type deduction should fail... but, deduction failure can only occur</p>\n<blockquote>\n<p id=\"so_30676839_32572451_2\">in the immediate context of <strong>the function type and its template parameter types</strong></p>\n</blockquote>\n<p>and we're not dealing with a function type or function template parameter types, we're dealing with <em>class template</em> parameter types. A class is not a function, so the SFINAE exclusion should not apply if we take everything literally - and the modified CWG example should lead to a hard error. </p>\n<p>However, the spirit of the rule seems to be more along the lines of:</p>\n<blockquote>\n<p id=\"so_30676839_32572451_3\">Only invalid types and expressions in the immediate context of the <em>deduction process</em> can result in a deduction failure. </p>\n</blockquote>\n<p>I do not know what the reason would be to specifically exclude class partial specialization deduction. Furthermore, <em>partial ordering</em> of class template partial specializations also look like functions. From [temp.class.order]:</p>\n<blockquote>\n<p id=\"so_30676839_32572451_4\">For two class template partial specializations, the first is more specialized than the second if, given the\n  following <strong>rewrite to two function templates</strong>, [...]</p>\n</blockquote>\n<p>The Standard thus already <em>in the very next section</em> exhibits a duality between class template partial specializations and function templates. The fact that this only applies to partial specialization ordering, and not substitution failure during partial specialization argument deduction, strikes me as a defect. </p>\n<hr/>\n<p><sup>\u2020</sup>The example itself was <code>X&lt;double, float&gt;</code>. But this actually doesn't demonstrate or require SFINAE, as there would be no substitution failure anywhere. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "34509", "LastEditDate": "2015-11-08T01:56:56.653", "Id": "32572451", "Score": "9", "CreationDate": "2015-09-14T19:28:26.030", "LastActivityDate": "2015-11-08T01:56:56.653"}, "bq_ids": {"n4140": {"so_30676839_32572451_3": {"section_id": 300, "quality": 0.75, "length": 9}, "so_30676839_32572451_1": {"section_id": 300, "quality": 0.9183673469387755, "length": 45}, "so_30676839_32572451_2": {"section_id": 300, "quality": 1.0, "length": 8}, "so_30676839_32572451_0": {"section_id": 144, "quality": 0.9473684210526315, "length": 18}, "so_30676839_32572451_4": {"section_id": 147, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_30676839_32572451_3": {"section_id": 291, "quality": 0.75, "length": 9}, "so_30676839_32572451_1": {"section_id": 291, "quality": 0.7959183673469388, "length": 39}, "so_30676839_32572451_2": {"section_id": 291, "quality": 1.0, "length": 8}, "so_30676839_32572451_0": {"section_id": 138, "quality": 0.9473684210526315, "length": 18}, "so_30676839_32572451_4": {"section_id": 141, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_30676839_32572451_3": {"section_id": 307, "quality": 0.75, "length": 9}, "so_30676839_32572451_0": {"section_id": 148, "quality": 0.9473684210526315, "length": 18}, "so_30676839_32572451_2": {"section_id": 307, "quality": 1.0, "length": 8}, "so_30676839_32572451_1": {"section_id": 307, "quality": 0.9183673469387755, "length": 45}, "so_30676839_32572451_4": {"section_id": 151, "quality": 0.8823529411764706, "length": 15}}}, "30676839": {"CommentCount": "5", "AcceptedAnswerId": "32572451", "CreationDate": "2015-06-05T22:38:20.977", "LastActivityDate": "2015-11-08T01:56:56.653", "PostTypeId": "1", "ViewCount": "1991", "FavoriteCount": "7", "Title": "SFINAE and partial class template specializations", "Id": "30676839", "Score": "26", "Body": "<p>I have been using SFINAE-based approaches for quite some time, especially to enable/disable specific class template specializations via <code>std::enable_if</code>.</p>\n<p>I was thus a bit puzzled while reading the paper describing the proposed <code>void_t</code> alias / detection idiom:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4502.pdf</a></p>\n<p>Section 4 is devoted to the discussion of the validity of the idiom, and refers to a discussion in which two parties argue about the applicability of SFINAE in partial class template specializations (with Richard Smith pointing out that the standard is lacking wording about this topic). Towards the end of the section, the following CWG issue is mentioned</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2054\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2054</a></p>\n<p>Here again it is stated that the standard does not explicitly allows the example reproduced in the issue.</p>\n<p>I am a bit baffled because it seems to me that, e.g., the usage of <code>enable_if</code> in partial specializations has been standard practice for quite some time (see for instance the Boost documentation, which explicitly mentions partial specializations).</p>\n<p>Am I misunderstanding the points in the documents above or is this really a grey area?</p>\n", "Tags": "<c++><templates><c++11><c++14>", "OwnerUserId": "453925", "AnswerCount": "1"}});