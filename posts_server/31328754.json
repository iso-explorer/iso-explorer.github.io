post_cb({"31329015": {"ParentId": "31328754", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Because it makes sense to allow to use only the functions that are actually well formed.</p>\n<p>Take <code>vector::push_back(const T&amp;)</code>, that requires <code>T</code> to be copyable. But you can still use most of <code>vector</code> even if <code>T</code> is a movable non-copyable type.</p>\n", "OwnerUserId": "666785", "LastEditorUserId": "666785", "LastEditDate": "2015-07-10T08:07:18.743", "Id": "31329015", "Score": "6", "CreationDate": "2015-07-09T22:01:42.500", "LastActivityDate": "2015-07-10T08:07:18.743"}, "31328754": {"CommentCount": "2", "ViewCount": "666", "PostTypeId": "1", "LastEditorUserId": "1593297", "CreationDate": "2015-07-09T21:42:21.997", "LastActivityDate": "2015-07-10T08:07:18.743", "Title": "Why do template classes allows functions which cannot compile?", "AcceptedAnswerId": "31328843", "LastEditDate": "2015-07-09T21:48:02.700", "Id": "31328754", "Score": "16", "Body": "<pre><code>class P\n{\n};\n\ntemplate&lt; typename P &gt;\nclass C : public P\n{\n  public:\n  void f()\n  {\n    P::f();\n  }\n};\n\nint main() {\n  C&lt;P&gt; c1;\n  return 0;\n}\n</code></pre>\n<p>Just in case my question leaves any room for miscommunication, theres the code example. If <code>C</code> was <em>not</em> templated but inherited from <code>P</code> directly then the sample would fail to compile because clearly function <code>f()</code> attempts to call a function on base class <code>P</code> which is non-existent.</p>\n<p>However if <code>C</code> is templated then this is only picked up if <code>f()</code> is actually called. </p>\n<p>I'd like to know why there is this difference. In both instances <code>f()</code> would be dead code and stripped anyway, yet the program is ill-formed in the non-template scenario.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "3495829", "AnswerCount": "5"}, "31328962": {"ParentId": "31328754", "CommentCount": "0", "Body": "<p>If I write a non-template class which inherits from <code>P</code>, calling a non-existent function on that class from a member function is obviously an error as there is no use for it whatsoever.</p>\n<p>If <code>C</code> is a template class, however, maybe that erroneous call is valid for some other <code>P</code>. Maybe that member function represents some extended functionality for types which support some given interface. <code>C</code> could be instantiated from some external library that I have no knowledge of when instantiating for <code>P</code>. As such, throwing a compiler error for an unused function in a template class which could be valid for certain types would limit the expressive power of templates. It also brings down compile-times, binary sizes, etc. because that unneeded template function doesn't need to be generated for types when it is not used.</p>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "31328962", "Score": "3", "CreationDate": "2015-07-09T21:57:26.220", "LastActivityDate": "2015-07-09T21:57:26.220"}, "31328842": {"ParentId": "31328754", "CommentCount": "0", "Body": "<p>Inside the template class, identifier <code>P</code> is a template parameter typename, it <em>does not</em> refer to the <code>class P</code> defined before. So you can't say <code>P::f()</code> is not-existent, as you do not know what class will be substituted for parameter <code>P</code>.</p>\n<p>And later, when you invoke the template to declare the <code>c1</code> variable, the function is not needed, so there is no 'dead code' \u2013 there is just a template, which has never been expanded to an actual code.</p>\n", "OwnerUserId": "733637", "PostTypeId": "2", "Id": "31328842", "Score": "5", "CreationDate": "2015-07-09T21:49:27.397", "LastActivityDate": "2015-07-09T21:49:27.397"}, "31328880": {"ParentId": "31328754", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Variable <code>C&lt;P&gt; c1;</code> is not used and the <code>C::f()</code> function is never called. Compiler doesn't create body of function until it is used. This is a simple optimization which speeds up the compilation.</p>\n", "OwnerUserId": "3052438", "LastEditorUserId": "3052438", "LastEditDate": "2015-07-10T07:49:09.593", "Id": "31328880", "Score": "2", "CreationDate": "2015-07-09T21:51:47.853", "LastActivityDate": "2015-07-10T07:49:09.593"}, "bq_ids": {"n4140": {"so_31328754_31328843_0": {"section_id": 234, "quality": 1.0, "length": 12}}, "n3337": {"so_31328754_31328843_0": {"section_id": 227, "quality": 1.0, "length": 12}}, "n4659": {"so_31328754_31328843_0": {"section_id": 244, "quality": 1.0, "length": 12}}}, "31328843": {"ParentId": "31328754", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Actually, the program you posted is not ill-formed. While the \"implicit instantiation\" <code>C&lt;P&gt; c1;</code> instantiates all member <em>declarations</em>, </p>\n<blockquote>\n<p id=\"so_31328754_31328843_0\">the specialization of the member is implicitly instantiated when the specialization is referenced\n  in a context that requires the member definition to exist</p>\n</blockquote>\n<p>[N4140, 14.7.1(2)] Since you never use <code>C&lt;P&gt;::f</code>, its <em>definition</em> is never needed and thus never instantiated.</p>\n<p>This is different to an \"explicit instantiation\" like</p>\n<pre><code>template class C&lt;P&gt;;\n</code></pre>\n<p>which would instantiate the <em>definition</em> of all members of <code>C&lt;P&gt;</code> and thus result in an error.</p>\n", "OwnerUserId": "3002139", "LastEditorUserId": "3002139", "LastEditDate": "2015-07-09T22:00:36.147", "Id": "31328843", "Score": "17", "CreationDate": "2015-07-09T21:49:34.977", "LastActivityDate": "2015-07-09T22:00:36.147"}});