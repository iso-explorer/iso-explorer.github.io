post_cb({"25186641": {"ParentId": "25186264", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is what the C++11 Standard has to say ([class.base.init]/10):</p>\n<blockquote>\n<p id=\"so_25186264_25186641_0\">In a non-delegating constructor, initialization proceeds in the following order:<br>\n  \u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class <em>base-specifier-list</em>.<br>\n  \u2014 Then, direct base classes are initialized in declaration order as they appear in the <em>base-specifier-list</em> (regardless of the order of the <em>mem-initializers</em>).<br>\n  \u2014 Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the <em>mem-initializers</em>).<br>\n  \u2014 Finally, the <em>compound-statement</em> of the constructor body is executed.<br>\n  [ <em>Note:</em> The declaration order is mandated to ensure that base and member subobjects are destroyed in the reverse order of initialization. \u2014 <em>end note</em> ]</br></br></br></br></br></p>\n</blockquote>\n<p>So, the base class is initialized before non-static data members. Your code may invoke undefined behavior if it actually uses the uninitialized data in any way.</p>\n<hr>\n<p>In comments, we discussed one possible solution to your design problem is to use has-a rather than is-a. You worried that has-a would violate DRY (don't repeat yourself).</p>\n<p>There are two ways I use to avoid WET (write everything (at least) twice) when using has-a. One is using conversion operators that allow your object to be passed to a function expecting your \"derived\" type.  The other is using a delegation operator.</p>\n<pre><code>class Object { /* ... */ };\n\nclass FakeDerivedObject {\n    Foo foo;\n    Object obj;\n    //...\n\n    // conversions\n    operator Object &amp; () { return obj; }\n    operator const Object &amp; () const { return obj; }\n    operator Object * () { return &amp;obj; }\n    operator const Object * () const { return &amp;obj; }\n\n    // delegation\n    Object * operator -&gt; () { return &amp;obj; }\n    const Object * operator -&gt; () const { return &amp;obj; }\n};\n</code></pre>\n<p>This way, you do not have to \"re-implement\" the interface of the underlying object.</p>\n<pre><code>FakeDerivedObject d;\n\nd-&gt;SomeMethodOfUnderlyingObject();\nSomeFunctionThatExpectsUnderlyingObject(d);\n</code></pre>\n</hr>", "OwnerUserId": "315052", "LastEditorUserId": "315052", "LastEditDate": "2014-08-07T16:52:12.023", "Id": "25186641", "Score": "5", "CreationDate": "2014-08-07T15:39:28.597", "LastActivityDate": "2014-08-07T16:52:12.023"}, "25186264": {"CommentCount": "13", "ViewCount": "172", "PostTypeId": "1", "ClosedDate": "2014-08-07T18:02:41.610", "LastEditorUserId": "315052", "CreationDate": "2014-08-07T15:20:56.143", "LastActivityDate": "2014-08-07T16:53:10.743", "Title": "Are the C++ member classes constructed before parent classes?", "AcceptedAnswerId": "25186641", "LastEditDate": "2014-08-07T16:53:10.743", "Id": "25186264", "Score": "3", "Body": "<p>In the scenario:</p>\n<pre><code>class A : public B {\nprivate:\n   C m_C; \npublic:\n   A();\n}\n</code></pre>\n<p>is </p>\n<pre><code>A::A() : \n   m_C(5),\n   B(m_C) \n{} \n</code></pre>\n<p>legal? Would <code>B::B(m_C)</code> be invoked after <code>C::C(int)</code>? If so, what should I do to avoid it?</p>\n<hr>\n<p><strong>How did this came about in practice:</strong></p>\n<pre><code>class MyValidator : public QRegExpValidator {\nprivate:\n    QRegExp myRegExp;\npublic:\n    MyValidator(); \n    virtual void fixup(QString &amp;f); \n}\n\nMyValidator::MyValidator() \n    QRegExpValidator(QRegExp(\"foo\")); \n{}\n\nvoid MyValidator::fixup(QString &amp;f){ \n    // A QRegExp(\"foo\") is also needed here. \n}\n</code></pre>\n<p>I already discovered the </p>\n<pre><code>const QRegExp &amp; QRegExpValidator::regExp() const; \n</code></pre>\n<p>Which alleviates the need to keep my own reference to <code>myRegExp</code>, so my particular problem is solved.. </p>\n<p>what remains, is what would be the best pattern if <code>QRegExpValidator</code> did not have such feature to retrieve it's initializer.. manually plumbing all the functions to a member class, instead of inheritance? </p>\n</hr>", "Tags": "<c++><inheritance><constructor>", "OwnerUserId": "407528", "AnswerCount": "3"}, "25186437": {"ParentId": "25186264", "CommentCount": "2", "Body": "<p>Example:</p>\n<pre><code>class Base {\npublic:\n    Base(){}\n};\n\nclass Derived: public Base {\npublic:\n    Derived();\n\nprivate:\n    int _v1;\n    int _v2;\n};\n</code></pre>\n<p>The construction order will be ever <code>Base --&gt; _v1 --&gt; _v2</code></p>\n", "OwnerUserId": "3860767", "PostTypeId": "2", "Id": "25186437", "Score": "0", "CreationDate": "2014-08-07T15:29:35.920", "LastActivityDate": "2014-08-07T15:29:35.920"}, "bq_ids": {"n4140": {"so_25186264_25186641_0": {"section_id": 438, "quality": 0.9518072289156626, "length": 79}}, "n3337": {"so_25186264_25186641_0": {"section_id": 429, "quality": 0.9518072289156626, "length": 79}}, "n4659": {"so_25186264_25186641_0": {"section_id": 458, "quality": 0.9518072289156626, "length": 79}}}, "25187343": {"ParentId": "25186264", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_25186264_25187343_0\">Is</p>\n<p id=\"so_25186264_25187343_1\"><code>A::A() :     m_C(5),    B(m_C)  {}</code> </p>\n<p id=\"so_25186264_25187343_2\">legal?</p>\n</blockquote>\n<p>Yes.  You can list initializers in any order you choose.</p>\n<blockquote>\n<p id=\"so_25186264_25187343_3\">Would B::B(m_C) be invoked after C::C(int)</p>\n</blockquote>\n<p>No.  The compiler will ignore the order you listed the initializers, and initialize bases first in the order they are listed in the class declaration, followed by members in the order they are declared in the class declaration.</p>\n<p>Note that most compilers have a warning level which will warn you when initializers are listed in an order other than that matching how the initializers will <em>actually</em> be invoked.  According to some coding standards, it is required to list the initializers in the order in which they will be invoked.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "25187343", "Score": "1", "CreationDate": "2014-08-07T16:12:21.983", "LastActivityDate": "2014-08-07T16:12:21.983"}});