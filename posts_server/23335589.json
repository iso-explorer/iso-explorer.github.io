post_cb({"23337348": {"ParentId": "23335589", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There are formally <em>two</em> operations. A copy from the reference returned by <code>*ptr</code> to the temporary return value and the move from the temporary to the final destination in <code>r</code>.</p>\n<p>The first copy can't be optimized away<sup>1</sup>, because there is <em>no way for the compiler to control the memory referenced by the pointer.</em> It simply can't make the shared pointer point to wherever it wants to construct the return value and it can't use the memory of the pointer either, because it can't assume anything about it's life-time.</p>\n<p>The second copy/move <em>can</em> be optimized away as the return temporary can be constructed in <code>r</code> directly as permitted by this clause in \u00a712.8/31:</p>\n<blockquote id=\"so_23335589_23337348_0\">\n<ul>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</li>\n</ul>\n</blockquote>\n<p><sup>1</sup><sub>You can explicitly make it a move by using <code>std::move</code>. Because <code>std::shared_ptr::operator*</code> returns an <i>l</i>value reference, the compiler will deduce copy by default.</sub></p>\n", "OwnerUserId": "201725", "LastEditorUserId": "201725", "LastEditDate": "2014-04-28T12:27:51.593", "Id": "23337348", "Score": "4", "CreationDate": "2014-04-28T09:28:31.503", "LastActivityDate": "2014-04-28T12:27:51.593"}, "23336083": {"ParentId": "23335589", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++ 11 standard explains the condition of RVO in \u00a712.8/31:</p>\n<blockquote id=\"so_23335589_23336083_0\">\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n</ul>\n</blockquote>\n<p>Note that it says \"<strong>name</strong> of a non-volatile automatic object\". The compiler cannot do copy/move ellision here as <code>*ptr</code> is not a name.</p>\n<p><em>Edit:</em></p>\n<p>And thinking further about about it:</p>\n<p>If there were no copy made at all here, the variable <code>r</code> in <code>main()</code> would somehow magically use the same memory as the memory pointed to by <code>ptr</code> inside <code>foo()</code>. Memory which would be deleted as soon as the pointer goes out of scope. So the copy is not only unavoidable, it is absolutely vital!</p>\n", "OwnerUserId": "3578084", "LastEditorUserId": "201725", "LastEditDate": "2014-04-28T09:21:43.730", "Id": "23336083", "Score": "1", "CreationDate": "2014-04-28T08:27:20.883", "LastActivityDate": "2014-04-28T09:21:43.730"}, "23335589": {"CommentCount": "4", "ViewCount": "174", "PostTypeId": "1", "LastEditorUserId": "641235", "CreationDate": "2014-04-28T08:00:54.513", "LastActivityDate": "2014-04-28T12:27:51.593", "Title": "Will RVO work when returning a object in shared_ptr?", "LastEditDate": "2014-04-28T08:08:14.653", "Id": "23335589", "Score": "1", "Body": "<p>See the piece of code below:</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct A {/*...*/};\n\nvoid goo(std::shared_ptr &amp; p) {\n  p = std::shared_ptr&lt;A&gt;(new A);\n}\n\nA foo() {\n  std::shared_ptr&lt;A&gt; ptr;\n  goo(ptr);\n  return *ptr;\n}\n\nint main(int argc, char *argv[])\n{\n  auto r = foo();\n  return 0;\n}\n</code></pre>\n<p>I am confused about the return value of the <code>foo</code> function, will the compiler copy a <code>A-object</code> here? If it will, RVO is ignored in this case, so the performance can be bad?</p>\n", "Tags": "<c++><memory><c++11><return><shared-ptr>", "OwnerUserId": "641235", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_23335589_23337348_0": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}, "so_23335589_23336083_0": {"section_id": 480, "quality": 1.0, "length": 35}}, "n3337": {"so_23335589_23337348_0": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}, "so_23335589_23336083_0": {"section_id": 471, "quality": 1.0, "length": 35}}, "n4659": {"so_23335589_23337348_0": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}, "so_23335589_23336083_0": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}}}, "23335718": {"ParentId": "23335589", "CommentCount": "2", "Body": "<p>with RVO and inlined method, compiler may optimize your code to something like</p>\n<pre><code>struct A {/*...*/};\n\nint main(int argc, char *argv[])\n{\n  std::shared_ptr&lt;A&gt; ptr;\n  goo(ptr);\n  A r {*ptr};\n  return 0;\n}\n</code></pre>\n<p>so A is copied once</p>\n", "OwnerUserId": "642626", "PostTypeId": "2", "Id": "23335718", "Score": "1", "CreationDate": "2014-04-28T08:07:33.517", "LastActivityDate": "2014-04-28T08:07:33.517"}});