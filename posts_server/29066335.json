post_cb({"bq_ids": {"n4140": {"so_29066335_29066655_1": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_29066335_29066655_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 7239}}, "n3337": {"so_29066335_29066655_1": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_29066335_29066655_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 6983}}, "n4659": {"so_29066335_29066655_1": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_29066335_29066655_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 8748}}}, "29066335": {"ViewCount": "230", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt; using Underlying = std::underlying_type_t&lt;T&gt;;\n\nenum class ETest : int\n{\n    Zero = 0,\n    One = 1,\n    Two = 2\n};\n\ntemplate&lt;typename T&gt; auto&amp; castEnum(T&amp; mX) noexcept\n{\n    // `static_cast` does not compile\n    // return static_cast&lt;Underlying&lt;T&gt;&amp;&gt;(mX);\n\n    return reinterpret_cast&lt;Underlying&lt;T&gt;&amp;&gt;(mX);\n}\n\nint main()\n{\n    auto x(ETest::Zero);\n    castEnum(x) = 1;\n    assert(x == ETest::One);\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/IjzyAQ\" rel=\"nofollow\"><strong>ideone</strong></a></p>\n<p>Is this code guaranteed to always work? Or is it undefined behavior?</p>\n", "AcceptedAnswerId": "29066655", "Title": "Using `reinterpret_cast` on an enum class - valid or undefined behavior?", "CreationDate": "2015-03-15T21:23:21.857", "Id": "29066335", "CommentCount": "2", "LastEditDate": "2015-03-15T21:46:03.260", "PostTypeId": "1", "LastEditorUserId": "1413395", "LastActivityDate": "2015-03-15T21:57:33.737", "Score": "0", "OwnerUserId": "598696", "Tags": "<c++><language-lawyer><c++14><reinterpret-cast><enum-class>", "AnswerCount": "1"}, "29066655": {"Id": "29066655", "PostTypeId": "2", "Body": "<p>The standard is a bit unclear:</p>\n<blockquote>\n<p id=\"so_29066335_29066655_0\"><strong>3.10 Lvalues and rvalues [basic.lval]</strong></p>\n<p id=\"so_29066335_29066655_1\">10 If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<p id=\"so_29066335_29066655_2\">[...]</p>\n<p id=\"so_29066335_29066655_3\">(10.4) -- a type that is the signed or unsigned type corresponding to the dynamic type of the object,</p>\n<p id=\"so_29066335_29066655_4\">[...]</p>\n</blockquote>\n<p>This could be legitimately read as saying that the signed or unsigned type corresponding to an enumeration type is its underlying type, but I'd think this is meant to cover <em>only</em> accessing integer types through their other-signed corresponding type, that the underlying type of an enumeration type does not count as the (un)signed type corresponding to that enumeration type.</p>\n<p>At least GCC agrees with this: it gives an aliasing warning for</p>\n<pre><code>enum E : int { };\nint f(E e) { return *(int *) &amp;e; }\n</code></pre>\n<pre>\nwarning: dereferencing type-punned pointer will break strict-aliasing rules [-Wstrict-aliasing]\n</pre>\n<p>strongly hinting that it will optimise on the assumption that no such aliasing takes place in your program.</p>\n", "LastActivityDate": "2015-03-15T21:57:33.737", "CommentCount": "5", "CreationDate": "2015-03-15T21:57:33.737", "ParentId": "29066335", "Score": "1", "OwnerUserId": "743382"}});