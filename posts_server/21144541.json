post_cb({"21144619": {"ParentId": "21144541", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-01-15T17:46:28.043", "Score": "3", "LastEditorUserId": "2925287", "LastEditDate": "2014-01-15T18:07:44.453", "Id": "21144619", "OwnerUserId": "2925287", "Body": "<p>To resume, the syntax is :</p>\n<pre><code>typedef keywords alias;\n</code></pre>\n<p>so <code>typedef unsigned int my_uint32</code> is the same as <code>typedef int unsigned my_uint32;</code>.</p>\n<p>You may be carefull when you define your own type. In your case, you wanna have a 4 bytes type, you should use types defined in stdint.h (uint32_t) if you code in C, or in cstdint if you code in C++, because 'int' is \"at least 4 bytes\" and not in each case \"4 bytes\".</p>\n", "LastActivityDate": "2014-01-15T18:07:44.453"}, "21144887": {"ParentId": "21144541", "CommentCount": "7", "Body": "<p>First, you cannot create your own types that are marked <code>unsigned</code>/<code>signed</code>, so it could <em>only</em> apply to the pre-existing type.</p>\n<p>Second, yes it is valid to swap the position of that qualifier:</p>\n<blockquote>\n<p id=\"so_21144541_21144887_0\"><code>[C++11: 7.1.6.2/3]:</code> When multiple <em>simple-type-specifiers</em> are allowed, they can be freely intermixed with other <em>decl-specifiers</em> in any order. <em>[..]</em></p>\n</blockquote>\n<p><strong>So, the two declarations are equivalent.</strong></p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "21144887", "Score": "1", "CreationDate": "2014-01-15T17:58:30.107", "LastActivityDate": "2014-01-15T17:58:30.107"}, "21145719": {"ParentId": "21144541", "CommentCount": "0", "Body": "<p>A C++ declaration (in the simplest case) consists of two parts:\na declaration specifier, and a declarator.  Everything up to\neither what is being declared or the first \"operator\" (e.g. <code>*</code>\nor <code>&amp;</code>) is part of the declaration specifier, where order\ndoesn't matter.  So you're free to write things like:</p>\n<pre><code>int const unsigned static i;\n</code></pre>\n<p>(if you don't care what your co-worker think of your code).</p>\n<p>C has deprecated putting the storage class specifier (<code>static</code>,\n<code>extern</code>, etc.) anywhere but in the first position, and this was\na generally accepted convention since the earliest days of C.\nFor the rest: </p>\n<ul>\n<li><p>I've always seen the modifier precede the basic type (e.g.\n<code>unsigned int</code>), <em>when</em> the basic type appears.  Most of the\nplaces I've worked will use simply <code>unsigned</code>, rather than\n<code>unsigned int</code>.</p></li>\n<li><p>I've also always seen the <code>signed</code>/<code>unsigned</code> precede any\nlength modifiers: <code>unsigned long</code>, rather than <code>long unsigned</code>.</p></li>\n<li><p>The position of <code>const</code> or <code>volatile</code> tends to vary.  Most of\nthe more experienced programmers I know put it at the very end\nof the declaration specifier, but this is a somewhat recent\ndevelopment, and a lot of people continue to use the older\nconvention, and put it immediately after the storage class\nspecifier.</p></li>\n</ul>\n<p>For all but the storage class specifiers, this is fairly\narbitrary; about the only other rule I'd say is universal is to\nnot split up the actual type information, as I did in my\nexample.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "21145719", "Score": "1", "CreationDate": "2014-01-15T18:45:05.737", "LastActivityDate": "2014-01-15T18:45:05.737"}, "21144612": {"ParentId": "21144541", "CommentCount": "0", "Body": "<p>The declarations are equivalent.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "21144612", "Score": "0", "CreationDate": "2014-01-15T17:46:13.417", "LastActivityDate": "2014-01-15T17:46:13.417"}, "21144541": {"CommentCount": "2", "ViewCount": "79", "CreationDate": "2014-01-15T17:43:06.837", "LastActivityDate": "2014-01-15T18:45:05.737", "Title": "Placement of the unsigned keyword", "AcceptedAnswerId": "21144887", "PostTypeId": "1", "Id": "21144541", "Score": "3", "Body": "<p>Is</p>\n<pre><code>unsigned int a;\n</code></pre>\n<p>the same as</p>\n<pre><code>int unsigned a;\n</code></pre>\n<p>?</p>\n<p>I.e., what I want to know, in the following code:</p>\n<pre><code>typedef int unsigned my_uint32;\n</code></pre>\n<p>does the 'unsigned' \"refer\" to my_uint32 or to int? So is it the same as</p>\n<pre><code>typedef unsigned int my_uint32;\n</code></pre>\n<p>?</p>\n", "Tags": "<c++>", "OwnerUserId": "1345959", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_21144541_21144887_0": {"section_id": 5439, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_21144541_21144887_0": {"section_id": 5234, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_21144541_21144887_0": {"section_id": 6866, "quality": 0.8461538461538461, "length": 11}}}});