post_cb({"40099376": {"CommentCount": "13", "ViewCount": "231", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2016-10-18T04:12:52.497", "LastActivityDate": "2016-10-18T10:30:21.600", "Title": "Store lambda as a member using template arguments deduction", "LastEditDate": "2016-10-18T10:30:21.600", "Id": "40099376", "Score": "2", "Body": "<p>Previously, when <em>C++11</em> became available I tried to store a lambda as a class field using <code>auto</code> specifier and member initializers. It was an unsuccessfull attempt:</p>\n<pre><code>struct Y\n{\n    auto x = [] { ; };\n};\n</code></pre>\n<p>Error:</p>\n<blockquote>\n<p id=\"so_40099376_40099376_0\">error: non-static data member declared with placeholder 'auto'</p>\n</blockquote>\n<p>Despite of size of lambda (w/o lost of generality, with capture) is known at time of definition of a class member, it not allowed to use <code>auto</code> specifier. Why? Not too clear restriction.</p>\n<p>Now <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r3.html\" rel=\"nofollow\">template argument deduction for class templates</a> available in GCC 7.0.0 trunk. And I tried to do it again:</p>\n<pre><code>template&lt; typename F &gt;\nstruct X\n    : F\n{\n    using F::operator ();\n    X(F &amp;&amp; f) : F(static_cast&lt; F &amp;&amp; &gt;(f)) { ; }\n};\n\nstruct Y\n{\n    X x = [] { ; };\n};\n</code></pre>\n<p>But I get an error:</p>\n<blockquote>\n<p id=\"so_40099376_40099376_1\">error: invalid use of template-name 'X' without an argument list</p>\n</blockquote>\n<p>I suspect, that the implementation is partial or even maybe inconsistent. Will it allow me to achieve desired w/o type erasure (and dynamic allocation of a memory)?</p>\n<p>Free non-member definition is allowed:</p>\n<pre><code>X x = [] { ; };\n</code></pre>\n<h3>ADDITIONAL:</h3>\n<p>People asks what the problem I tried to solve? I need a terse syntax for in-class defined functors.</p>\n<p>If I can write (following code is valid):</p>\n<pre><code>struct point_of_parabaloid // aggregate\n{\n    double x, y;\n    double z = [&amp;] { return x * x + y * y; }();\n};\n\npoint_of_parabaloid p = {1.0, 2.0};\nassert(p.z == 5.0);\n</code></pre>\n<p>Why can't I define an in-class lambda (say, for lazy evaluation of <code>z</code>)?</p>\n<p>I don't need to capture something abnormal, just a class members (or <code>this</code>) as in <code>point_of_parabaloid</code> definition.</p>\n", "Tags": "<c++><lambda><auto><c++1z><type-deduction>", "OwnerUserId": "1430927", "AnswerCount": "3"}, "40101877": {"ParentId": "40099376", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>By looking at your attempt in C++17, you can already do something similar in C++11.<br>\nAs an example:</br></p>\n<pre><code>#include&lt;utility&gt;\n\ntemplate&lt;typename F&gt;\nstruct S {\n    S(F f): f{f} {}\n    F f;\n};\n\ntemplate&lt;typename F&gt;\nstruct T: F {\n    T(F f): F{f} {}\n};\n\nint main() {\n    auto l = [](){ ; };\n\n    S&lt;decltype(l)&gt; s{l};\n    s.f();\n\n    T&lt;decltype(l)&gt; t{l};\n    t();\n}\n</code></pre>\n<p>You can hide the ugly <code>decltype</code> behind a factory method if needed:</p>\n<pre><code>template&lt;typename L&gt;\nstatic auto create(L l) {\n       return S&lt;decltype(l)&gt;{l};\n}\n</code></pre>\n<p>The limitation regarding this:</p>\n<pre><code>struct Y { auto x = [] { ; }; };\n</code></pre>\n<p>It is not because of the lambda. Instead, it's because of the <code>auto</code> placeholder. According with the standard, it cannot be used to declare non-static data members.<br>\nI guess the reason is that the type of a static data member is known at compile-time time (sooner or later you must put in an unique definition), while the type of a non-static data member could require to be solved at runtime. As an example, imagine an <code>if/else</code> statement where you use two different lambdas to initialize your object.</br></p>\n", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-10-18T07:50:17.857", "Id": "40101877", "Score": "0", "CreationDate": "2016-10-18T07:16:38.667", "LastActivityDate": "2016-10-18T07:50:17.857"}, "40099571": {"ParentId": "40099376", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You can work around it with <code>decltype</code> if the lambda is known before hand:</p>\n<pre><code>auto lambda = [](){};\n\nstruct C {\n  decltype(lambda) member = lambda;\n};\n</code></pre>\n<p>Not exactly pretty, but it works.</p>\n<p>I think your template technique would work if rewritten as:</p>\n<p><code>auto x = X([](){});</code></p>\n<p>However, gcc-7 (snapshot) does not accept that either. I suspect that it is because it's still work in progress.</p>\n<p>[just tested again with g++ 7 trunk built on 20161014, and then the above works]</p>\n<p>You can work around it with a maker function</p>\n<pre><code>template &lt;typename L&gt;\nstruct X {\n  L member;\n};\n\ntemplate &lt;typename T&gt;\nauto make_x(T t) { return X&lt;T&gt;{t}; }\n\nauto x = make_x([](){});\n</code></pre>\n", "OwnerUserId": "4966163", "LastEditorUserId": "4966163", "LastEditDate": "2016-10-18T05:01:33.483", "Id": "40099571", "Score": "1", "CreationDate": "2016-10-18T04:34:26.573", "LastActivityDate": "2016-10-18T05:01:33.483"}, "bq_ids": {"n4140": {"so_40099376_40099376_0": {"section_id": 5970, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_40099376_40099376_0": {"section_id": 5742, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_40099376_40099376_0": {"section_id": 242, "quality": 0.5714285714285714, "length": 4}}}, "40105445": {"ParentId": "40099376", "CommentCount": "3", "Body": "<p>Your problem is that you're trying to capture <code>this</code> outside a member function, in a class definition. To be precise, <code>double z = [&amp;] { return x * x + y * y; }();</code> needs <code>this-&gt;x</code> and <code>this-&gt;y</code>.</p>\n<p>You now get into a circular dependency: The type of the lambda depends on whats captured (<code>this</code>, which is a <code>point_of_parabaloid*</code>) but <code>point_of_parabaloid</code> depends on the type of its members including that very lambda.</p>\n<p>This is a circular dependency in your design; the exact C++ constructs don't matter much. You can break it; <code>point_of_parabaloid*</code> only requires a forward declaration of <code>struct point_of_parabaloid;</code>. But breaking that circle isn't going to give you that terse syntax.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "40105445", "Score": "1", "CreationDate": "2016-10-18T10:12:41.790", "LastActivityDate": "2016-10-18T10:12:41.790"}});