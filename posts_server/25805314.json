post_cb({"25805502": {"ParentId": "25805314", "CommentCount": "1", "Body": "<ol>\n<li>The type of object being kept in smart pointer must be known in place where smart pointer is being destructed, so proper destructor of kept object can be called</li>\n<li>does your class (the one which holds smart pointer) have destructor? If no - add one in your cpp file. Otherwise compiler tries to add one when it sees your class definition and cannot do it because smart pointer's destructor tries to access unknown type.</li>\n</ol>\n", "OwnerUserId": "1749713", "PostTypeId": "2", "Id": "25805502", "Score": "8", "CreationDate": "2014-09-12T09:52:16.300", "LastActivityDate": "2014-09-12T09:52:16.300"}, "25805314": {"CommentCount": "0", "AcceptedAnswerId": "25805502", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2014-09-12T09:43:35.527", "LastActivityDate": "2014-09-12T10:26:05.620", "LastEditDate": "2014-09-12T09:46:05.377", "ViewCount": "842", "FavoriteCount": "1", "Title": "QScopedPointer, boost::scoped_ptr - why complaining about incomplete types?", "Id": "25805314", "Score": "5", "Body": "<p>I have c-Structure that I want to embed in an cpp class without poisoning of my global namespace so I do not want to include the c-header.</p>\n<p>That's why I want to use a smart scoped pointer (<code>QScopedPointer</code> or <code>boost::scoped_ptr</code>) with a forward declared structure name.</p>\n<p>What I do not understand is the implementation of both mentioned scoped pointers that fails on compile:</p>\n<p>boost:</p>\n<blockquote>\n<p id=\"so_25805314_25805314_0\">error C2027: use of undefined type 'xxx'</p>\n</blockquote>\n<pre><code>template&lt;class T&gt; inline void checked_delete(T * x)\n{\n    // intentionally complex - simplification causes regressions\n    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ]; // &lt; here\n    (void) sizeof(type_must_be_complete);\n    delete x;\n}\n</code></pre>\n<p>and the same in Qt:</p>\n<blockquote>\n<p id=\"so_25805314_25805314_1\">error C2027: use of undefined type 'xxx'</p>\n</blockquote>\n<pre><code>template &lt;typename T&gt;\nstruct QScopedPointerDeleter\n{\n    static inline void cleanup(T *pointer)\n    {\n        // Enforce a complete type.\n        // If you get a compile error here, read the section on forward declared\n        // classes in the QScopedPointer documentation.\n        typedef char IsIncompleteType[ sizeof(T) ? 1 : -1 ]; // &lt; here\n        (void) sizeof(IsIncompleteType);\n\n        delete pointer;\n    }\n};\n</code></pre>\n<p>The referenced documentation did not helped me. it says that the destructor of the forward declared class does not have to be inline and must be available at every possible instantiation of the cleanup of the scoped pointer. But my c-structure does not have an destructor.</p>\n<p>So I have 2 questions:</p>\n<ol>\n<li>Why this check at all? Because it seems to be irrelevant to know the size for calling delete.</li>\n<li>How to deal with this?</li>\n</ol>\n", "Tags": "<c++><c><boost><qt4><smart-pointers>", "OwnerUserId": "2331592", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25805314_25805877_1": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n3337": {"so_25805314_25805877_1": {"section_id": 5875, "quality": 1.0, "length": 16}}, "n4659": {"so_25805314_25805877_1": {"section_id": 7606, "quality": 1.0, "length": 16}}}, "25805877": {"ParentId": "25805314", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_25805314_25805877_0\">my c-Structure does not have a destructor.</p>\n</blockquote>\n<p>For one thing, <strong>No</strong>. Your struct actually have a destructor - <em><a href=\"http://en.cppreference.com/w/cpp/language/destructor\" rel=\"nofollow\">implicitly-declared destructor</a></em>.</p>\n<hr/>\n<p>Anyway, let's go ahead.</p>\n<pre><code>delete pointer;\n</code></pre>\n<p>When compiling this code, we should call the destructor of <code>*pointer</code>. However, if <code>*pointer</code> is incomplete type, we can't know the destructor to call. In this case, standard [expr.delete] says it causes <strong>undefined behavior</strong>.</p>\n<blockquote>\n<p id=\"so_25805314_25805877_1\">If the object being deleted has incomplete class type at the point of deletion and the complete class <em>has a non-trivial destructor or a deallocation function</em>, the behavior is undefined.</p>\n</blockquote>\n<p>As you can see, if your struct doesn't have non-trivial destructor or a deallocation function (class-specific <code>operator delete</code>), it's not UB. However, you probably can add a destructor into your struct - you <strong>will</strong> do. If you do without fixing this point, it becomes really buggy bug. (Compiler doesn't have to report it; it's just UB, not illegal code.) So it's <em>not</em> considered as a good practice.</p>\n<p>Because of this, deleting incomplete types is really what we should avoid. To avoid that, we uses this trick.</p>\n<pre><code>typedef char type_must_be_complete[ sizeof(T)? 1: -1 ]; // &lt; here\n(void) sizeof(type_must_be_complete);\n</code></pre>\n<p>Since <code>sizeof(T)</code> is illegal code if <code>T</code> is incomplete type, so it can reduce compile-time error before your program goes being crazy due to UB.</p>\n<p>I highly recommend you to just include it despite slower compliation speed; Although your struct is trivial and doesn't have <code>operator delete</code>, they can be added without fixing, which causes UB.</p>\n", "OwnerUserId": "2729109", "LastEditorUserId": "2729109", "LastEditDate": "2014-09-12T10:26:05.620", "Id": "25805877", "Score": "6", "CreationDate": "2014-09-12T10:11:29.473", "LastActivityDate": "2014-09-12T10:26:05.620"}});