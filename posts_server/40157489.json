post_cb({"bq_ids": {"n4140": {"so_40157489_40159402_0": {"length": 20, "quality": 1.0, "section_id": 155}}, "n3337": {"so_40157489_40159402_0": {"length": 20, "quality": 1.0, "section_id": 149}}, "n4659": {"so_40157489_40159402_0": {"length": 20, "quality": 1.0, "section_id": 159}}}, "40159402": {"Id": "40159402", "PostTypeId": "2", "Body": "<p>The issue comes from the <code>&lt;unresolved-name&gt;</code> construct in the ABI. Why would we ever want to use an unresolved name? It's all about declaration matching and overloads. C++14 \u00a714.5.6.1/3 notes,</p>\n<blockquote>\n<p id=\"so_40157489_40159402_0\">Two distinct function templates may have identical function return types and function parameter lists, even if overload resolution alone cannot distinguish them.</p>\n</blockquote>\n<p>You can have another function in a different file,</p>\n<pre><code>template &lt;typename T&gt;\nvoid baz(int quux) { std::abort(); }\n</code></pre>\n<p>Although this signature can't peacefully coexist in the same file \u2014 it cannot be named because of overload ambiguity \u2014 it can exist in a different file so it needs a distinct mangling.</p>\n<p>(Even this level of coexistence is not guaranteed by the standard for all templates. It's a matter of QOI that the compiler uses the exact form of a function template declaration to perform declaration matching, so that copy-pasting a declaration into a definition will tend to provide an exact match and not a surprising conflict with another function template that resolves to the same  signature. See \u00a714.5.6.1/5-6.)</p>\n<p>As for raining on <code>default_order</code>'s parade, the problem is that template-ids implicitly pull default arguments from templates. So the user could unintentionally have a dependent typename in a signature just by mentioning <code>std::set</code>.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2017-05-15T10:30:48.450", "Score": "5", "CreationDate": "2016-10-20T16:07:08.247", "ParentId": "40157489", "CommentCount": "16", "OwnerUserId": "153285", "LastEditDate": "2017-05-15T10:30:48.450"}, "40157489": {"ViewCount": "353", "Body": "<p>For example:</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo\n{\n    using bar = int;\n};\n\n// _Z3bazi\nvoid baz(foo&lt;int&gt;::bar quux) {\n}\n\ntemplate &lt;typename T&gt;\nvoid baz(typename foo&lt;T&gt;::bar quux) {\n}\n\n// _Z3bazIiEvN3fooIT_E3barE\ntemplate void baz&lt;int&gt;(foo&lt;int&gt;::bar quux);\n</code></pre>\n<p>Why does the mangled form of <code>baz&lt;int&gt;</code> mention <code>foo</code> at all?  How come it's not <code>_Z3bazIiEvi</code>?</p>\n<p>This is apparently the reason that the C++17 <code>std::default_order&lt;T&gt;</code> proposal is dead in the water.</p>\n", "AcceptedAnswerId": "40159402", "Title": "In the Itanium C++ ABI, why does the mangled name for template functions not resolve dependent typedefs?", "CreationDate": "2016-10-20T14:37:06.387", "Id": "40157489", "CommentCount": "5", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2016-10-20T14:55:59.833", "LastEditorUserId": "502399", "LastActivityDate": "2017-05-15T10:30:48.450", "Score": "20", "OwnerUserId": "502399", "Tags": "<c++><templates><name-mangling><itanium-abi>", "AnswerCount": "1"}});