post_cb({"37504962": {"ParentId": "12486285", "CommentCount": "0", "Body": "<p>The c++ standard does not standardize the size of each type (accept char) but the difference in size in relation to each other.</p>\n<pre><code>A char has to be 1 byte.\nA short has to be &gt;= to a char.\nAn int has to be &gt;= to a short.\nA long has to be &gt;= to an int.\nand a long long has to be &gt;= to a long.\n</code></pre>\n<p>same goes for float types.</p>\n<p>I believe most compilers now support up to 8-byte integers</p>\n<p>however I know for a fact some, if not most don't have 16-byte integers.</p>\n<p>I also think that there are some object classes/structs that people have developed to emulate a 16-byte integer that would work on most compilers.</p>\n", "OwnerUserId": "4747783", "PostTypeId": "2", "Id": "37504962", "Score": "0", "CreationDate": "2016-05-29T00:20:01.707", "LastActivityDate": "2016-05-29T00:20:01.707"}, "12486300": {"ParentId": "12486285", "CommentCount": "5", "Body": "<p>Nope, only guaranteed sizes are for <code>char</code>, <code>unsigned char</code> &amp; <code>signed char</code>, and they are <code>1</code>:</p>\n<p><strong>5.3.3 Sizeof [expr.sizeof]</strong></p>\n<blockquote>\n<p id=\"so_12486285_12486300_0\">1 The sizeof operator yields the number of bytes in the object\n  representation of its operand. The operand is either an expression,\n  which is not evaluated, or a parenthesized type-id. The sizeof\n  operator shall not be applied to an expression that has function or\n  incomplete type, or to an enumeration type before all its enumerators\n  have been declared, or to the parenthesized name of such types, or to\n  an lvalue that designates a bit-field. <strong>sizeof(char), sizeof(signed\n  char) and sizeof(unsigned char) are 1. The result of sizeof applied to\n  any other fundamental type (3.9.1) is implementation-defined.</strong> [ Note:\n  in particular, sizeof(bool) and sizeof(wchar_t) are\n  implementation-defined.74) \u2014end note ] [ Note: See 1.7 for the\n  definition of byte and 3.9 for the definition of object\n  representation. \u2014end note ]</p>\n</blockquote>\n<p>(emphasis mine)</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "12486300", "Score": "2", "CreationDate": "2012-09-18T23:02:41.953", "LastActivityDate": "2012-09-18T23:02:41.953"}, "bq_ids": {"n4140": {"so_12486285_12486300_0": {"section_id": 6076, "quality": 0.7605633802816901, "length": 54}}, "n3337": {"so_12486285_12486300_0": {"section_id": 5844, "quality": 0.7746478873239436, "length": 55}}, "n4659": {"so_12486285_12486300_0": {"section_id": 7572, "quality": 0.6338028169014085, "length": 45}}}, "12486285": {"CommentCount": "5", "ViewCount": "4295", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-09-18T23:00:49.393", "LastActivityDate": "2016-05-29T00:20:01.707", "Title": "16 bytes-long integer types", "FavoriteCount": "1", "LastEditDate": "2012-09-18T23:23:22.050", "Id": "12486285", "Score": "4", "Body": "<p>I'm compiling a C++ program using GCC on 64bits - machine/OS/ (with <code>-m64</code> option passed to <code>g++</code>). As expected, <code>sizeof(long double) == 16</code> \u2013 I'm wondering whether there is 16 bytes-long standard type for integers?</p>\n<p>P.S. <code>__int128_t</code> is an artificial extension that emulates standard type as I understood. Other than that I didn't find anything.</p>\n", "Tags": "<c++><types><64bit>", "OwnerUserId": "1681646", "AnswerCount": "2"}});