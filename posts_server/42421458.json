post_cb({"bq_ids": {"n4140": {"so_42421458_42422428_8": {"length": 24, "quality": 0.8275862068965517, "section_id": 6172}, "so_42421458_42422428_7": {"length": 12, "quality": 1.0, "section_id": 6171}, "so_42421458_42422442_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 6171}, "so_42421458_42422428_2": {"length": 10, "quality": 1.0, "section_id": 6170}, "so_42421458_42422428_0": {"length": 47, "quality": 0.5802469135802469, "section_id": 6169}, "so_42421458_42422428_3": {"length": 24, "quality": 0.9230769230769231, "section_id": 6171}, "so_42421458_42422428_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 686}, "so_42421458_42422428_6": {"length": 7, "quality": 1.0, "section_id": 686}, "so_42421458_42422428_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 6169}, "so_42421458_42422428_4": {"length": 22, "quality": 1.0, "section_id": 583}}, "n3337": {"so_42421458_42422428_0": {"length": 46, "quality": 0.5679012345679012, "section_id": 5930}, "so_42421458_42422428_8": {"length": 24, "quality": 0.8275862068965517, "section_id": 5933}, "so_42421458_42422428_7": {"length": 12, "quality": 1.0, "section_id": 5932}, "so_42421458_42422428_4": {"length": 22, "quality": 1.0, "section_id": 573}, "so_42421458_42422428_2": {"length": 10, "quality": 1.0, "section_id": 5931}, "so_42421458_42422442_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 5932}, "so_42421458_42422428_3": {"length": 24, "quality": 0.9230769230769231, "section_id": 5932}, "so_42421458_42422428_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 676}, "so_42421458_42422428_6": {"length": 7, "quality": 1.0, "section_id": 676}, "so_42421458_42422428_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 5930}}, "n4659": {"so_42421458_42422428_8": {"length": 28, "quality": 0.9655172413793104, "section_id": 7670}, "so_42421458_42422428_7": {"length": 12, "quality": 1.0, "section_id": 7669}, "so_42421458_42422428_4": {"length": 22, "quality": 1.0, "section_id": 606}, "so_42421458_42422428_2": {"length": 10, "quality": 1.0, "section_id": 7668}, "so_42421458_42422428_0": {"length": 80, "quality": 0.9876543209876543, "section_id": 7667}, "so_42421458_42422442_0": {"length": 36, "quality": 0.9473684210526315, "section_id": 7669}, "so_42421458_42422428_3": {"length": 24, "quality": 0.9230769230769231, "section_id": 7669}, "so_42421458_42422428_5": {"length": 11, "quality": 0.9166666666666666, "section_id": 715}, "so_42421458_42422428_6": {"length": 7, "quality": 1.0, "section_id": 715}, "so_42421458_42422428_1": {"length": 12, "quality": 1.0, "section_id": 7667}}}, "42422442": {"Id": "42422442", "PostTypeId": "2", "Body": "<p>The relevant paragraph from [expr.cond] is <a href=\"http://eel.is/c++draft/expr.cond#6\" rel=\"noreferrer\">6</a>:</p>\n<blockquote>\n<p id=\"so_42421458_42422442_0\">Otherwise, the result is a prvalue. If the second and third operands\n  do not have the same type, and either has (possibly cv-qualified)\n  class type, overload resolution is used to determine the conversions\n  (if any) to be applied to the operands (13.3.1.2, 13.6). If the\n  overload resolution fails, the program is ill-formed. Otherwise, the\n  conversions thus determined are applied, and the converted operands\n  are used in place of the original operands for the remainder of this\n  section.</p>\n</blockquote>\n<p><code>integral_constant&lt;int&gt;</code> has a conversion operator to <code>int</code>, so this can work.\nFollowing through to <a href=\"http://eel.is/c++draft/over.match.oper\" rel=\"noreferrer\">13.3.1.2</a>, we see that by <a href=\"http://eel.is/c++draft/over.match.oper#3.3\" rel=\"noreferrer\">paragraph 3.2</a>, all builtin <code>?:</code> operators taking integer and floating point arguments are candidates. </p>\n<p>Now overload resolution is performed for all these, given our three arguments. As per <a href=\"http://eel.is/c++draft/over.match#over.ics.rank-3.3\" rel=\"noreferrer\">[over.ics.rank]/3.3</a>, we tie-break by comparing the standard conversion sequences from <code>int</code> (the return type of <code>integral_constant&lt;int&gt;</code>'s conversion operator) to the builtin operators' parameter types. </p>\n<p>However, a look at <a href=\"http://eel.is/c++draft/over.ics.scs#tab:over.conversions\" rel=\"noreferrer\">table 13</a> is enough; conversions to the floating point types have Conversion rank, and since <code>int</code> is a promoted type, converting to any integral type <strong>but <code>int</code></strong> (which is an identity conversion) is an integral conversion with Conversion rank. Hence the best viable candidate is, unambiguously, <code>operator?:(bool, int, int)</code>. That is, MSVC is wrong.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2017-02-23T17:41:58.297", "Score": "6", "CreationDate": "2017-02-23T17:27:03.047", "ParentId": "42421458", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2017-02-23T17:41:58.297"}, "42421458": {"ViewCount": "183", "Body": "<p>MSVC and clang/gcc disagree on whether two different integral constants can be used in a ternary operator (and as a consequence whether they have a <code>common_type</code>):</p>\n<pre><code>#include &lt;utility&gt;\n\nint main()\n{\n    return false\n        ? std::integral_constant&lt;int, 1&gt;() \n        : std::integral_constant&lt;int, 2&gt;();\n}\n</code></pre>\n<p>The above snippet compiles fine in clang and gcc, but not in MSVC. What is the correct behavior according to the standard? And if it's clang/gcc behavior then what are the conversion sequences used to deduce the common type of these two distinct types?</p>\n", "AcceptedAnswerId": "42422428", "Title": "integral_constants in ternary operator", "CreationDate": "2017-02-23T16:38:08.467", "Id": "42421458", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-02-23T17:41:58.297", "Score": "11", "OwnerUserId": "3589890", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "42422428": {"Id": "42422428", "PostTypeId": "2", "Body": "<p>tldr; The code is well-formed. The conditional expression will have type <code>int</code> and value <code>2</code>. This is an MSVC bug.</p>\n<hr/>\n<p>From [expr.cond]:</p>\n<blockquote>\n<p id=\"so_42421458_42422428_0\">Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class type, or [...], an attempt is made to form an implicit conversion sequence (13.3.3.1) from each of those operands to the type of the other. [...] Attempts are made to form an implicit conversion sequence from an operand expression <code>E1</code> of type <code>T1</code> to a target type related to the type <code>T2</code> of the operand expression <code>E2</code> as follows: [...]<br>\n  \u2014 If E2 is an lvalue, [...]<br>\n  \u2014 If E2 is an xvalue, [...]<br>\n  \u2014 If E2 is a prvalue or if neither of the conversion sequences above can be formed and at least one of the\n  operands has (possibly cv-qualified) class type:<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014 if T1 and T2 are the same class type (ignoring cv-qualification), or one is a base class of the other,\n  and T2 is at least as cv-qualified as T1, the target type is T2,<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014 otherwise, the target type is the type that E2 would have after applying the lvalue-to-rvalue (4.1),\n  array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions.</br></br></br></br></br></p>\n</blockquote>\n<p>So we're trying to form an implicit conversion sequence from type <code>std::integral_constant&lt;int, 1&gt;</code> to type <code>std::integral_constant&lt;int, 2&gt;</code>. That's not viable. Nor is the implicit conversion sequence in the reverse direction viable either. These types are simply not interconvertible.</p>\n<p>So we continue:</p>\n<blockquote>\n<p id=\"so_42421458_42422428_1\">If no conversion\n  sequence can be formed, the operands are left unchanged and further checking is performed as described\n  below. [...]  </p>\n<p id=\"so_42421458_42422428_2\">If the second and third operands are glvalues of the same value category and have the same type, [...]  </p>\n<p id=\"so_42421458_42422428_3\">Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either\n  has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be\n  applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed.</p>\n</blockquote>\n<p>Ok, what overload resolution can we perform? From [over.match.oper]:</p>\n<blockquote>\n<p id=\"so_42421458_42422428_4\">If either operand has a type that is a class or an enumeration, a user-defined operator function might be declared that implements this operator or <strong>a user-defined conversion can be necessary</strong> to convert the operand to\n  a type that is appropriate for a built-in operator.</p>\n</blockquote>\n<p>Where the builtins are specified in [over.built] as:</p>\n<blockquote>\n<p id=\"so_42421458_42422428_5\">For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form</p>\n<pre><code>LR operator?:(bool, L , R );\n</code></pre>\n<p id=\"so_42421458_42422428_6\">where LR is the result of the usual arithmetic conversions between types L and R.</p>\n</blockquote>\n<p>One of those builtins would be <code>int operator?:(bool, int, int)</code>. Since <code>std::integral_constant&lt;int, V&gt;</code> does have an <code>operator int()</code>, this is a viable conversion for both arguments. </p>\n<p>We continue in [expr.cond]:</p>\n<blockquote>\n<p id=\"so_42421458_42422428_7\">Otherwise, the conversions thus determined are applied, and the converted operands are used in place of the original operands for the remainder of this section.  </p>\n<p id=\"so_42421458_42422428_8\">Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed\n  on the second and third operands. After those conversions, one of the following shall hold:<br>\n  \u2014 The second and third operands have the same type; the result is of that type and the result object is initialized using the selected operand.</br></p>\n</blockquote>\n<p>At this point, the second and third operands <em>do</em> have the same type: <code>int</code>. So the result object is initialized as an <code>int</code>, and the expression is well-formed. </p>\n", "LastActivityDate": "2017-02-23T17:26:12.610", "CommentCount": "0", "CreationDate": "2017-02-23T17:26:12.610", "ParentId": "42421458", "Score": "8", "OwnerUserId": "2069064"}});