post_cb({"5728797": {"ParentId": "5728512", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When objects for <code>Bar&lt;type&gt;</code> are declared <strong>with actual types then definitely, Yes;</strong> it will instantiate <code>Foo::read&lt;type&gt;()</code>. However, it will be limited only to that function (say <code>Foo::write&lt;type&gt;()</code> will not be instantiated).</p>\n<p>In other way, if you try something like this:</p>\n<pre><code>template&lt;typename T&gt;\nstruct X\n{\n  Bar&lt;T&gt; b1;  // this is required but not sufficient to instantiate Foo::read&lt;T&gt;()\n};\n</code></pre>\n<p>Then <code>Foo::read&lt;int&gt;()</code> will not be instantiated until you declare <code>X&lt;int&gt;</code>.</p>\n<p><strong>Edit</strong>:\nIn above example, directly declaring <code>Bar&lt;int&gt; b1;</code> (<code>int</code> instead of <code>T</code>) inside <code>X</code>  is also NOT sufficient. Its containing type <code>X&lt;&gt;</code> has to be instantiated with actual (i.e. non-template) type.</p>\n", "OwnerUserId": "514235", "LastEditorUserId": "514235", "LastEditDate": "2011-04-20T10:48:31.960", "Id": "5728797", "Score": "1", "CreationDate": "2011-04-20T10:20:18.053", "LastActivityDate": "2011-04-20T10:48:31.960"}, "5733666": {"ParentId": "5728512", "CommentCount": "0", "Body": "<p>Yes, your solution is portable. Here is a different way</p>\n<pre><code>template &lt;typename T, T&gt; struct user { };\ntemplate &lt;typename T&gt; struct Bar {\n    typedef user&lt; void (Foo::*)(T&amp;), &amp;Foo::read&lt;T&gt; &gt; user_type;\n};\n</code></pre>\n<p>Now whenever <code>Bar&lt;T&gt;</code> is implicitly instantiated, it will implicitly instanitate <code>Foo::read&lt;T&gt;</code>. No object needs to be created. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5733666", "Score": "2", "CreationDate": "2011-04-20T16:36:43.890", "LastActivityDate": "2011-04-20T16:36:43.890"}, "5728887": {"ParentId": "5728512", "CommentCount": "0", "Body": "<p>14.7.1 is where it's at. /2 says:</p>\n<blockquote>\n<p id=\"so_5728512_5728887_0\">Unless a function template\n  specialization has been explicitly\n  instantiated or explicitly\n  specialized, the function template\n  specialization is implicitly\n  instantiated when the specialization\n  is referenced in a context that\n  requires a function definition to\n  exist.</p>\n</blockquote>\n<p>Just like calling a function, taking a member function pointer requires that the function is defined in the program (perhaps in another TU). I believe that's what \"requires a function definition to exist\" means, so this is what causes the instantiation.</p>\n<p>There's also /9:</p>\n<blockquote>\n<p id=\"so_5728512_5728887_1\">An implementation shall not implicitly\n  instantiate a function template, a\n  member template, a non-virtual member\n  function, a member class or a static\n  data member of a class template that\n  does not require instantiation.</p>\n</blockquote>\n<p>So the fact that GCC and Intel instantiate it suggests that everyone else should, since that which is not required is forbidden. Assuming everyone conforms, of course.</p>\n", "OwnerUserId": "13005", "PostTypeId": "2", "Id": "5728887", "Score": "2", "CreationDate": "2011-04-20T10:31:41.207", "LastActivityDate": "2011-04-20T10:31:41.207"}, "5728512": {"CommentCount": "2", "AcceptedAnswerId": "5733666", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-20T09:57:45.143", "LastActivityDate": "2011-04-20T16:36:43.890", "LastEditDate": "2017-05-23T11:59:28.537", "ViewCount": "626", "FavoriteCount": "1", "Title": "Will the pointer to a template member function inside a constructor force instantiation?", "Id": "5728512", "Score": "2", "Body": "<p>Consider the following header file:</p>\n<pre><code>// Foo.h\nclass Foo {\n    public: template &lt;typename T&gt; void read(T&amp; value);\n};\n</code></pre>\n<p>It seems that assigning a pointer to <code>Foo::read&lt;T&gt;</code> in the constructor of a class, of which variable is then declared, cause instantiation:</p>\n<pre><code>// Foo.cc\n#include \"Foo.h\"\n\ntemplate &lt;typename T&gt;\nvoid Foo::read(T&amp; value) { /* do something */ }\n\ntemplate &lt;typename T&gt; struct Bar {\n    Bar&lt;T&gt;() { void (Foo::*funPtr)(T&amp;) = &amp;Foo::read&lt;T&gt;; }\n};\n\nstatic Bar&lt;int  &gt; bar1;\nstatic Bar&lt;long &gt; bar2;\nstatic Bar&lt;float&gt; bar3;\n</code></pre>\n<p>Is this solution reliable / portable / standard-conformant? (It works at least with Intel and GNU compilers.)</p>\n<p>If you wonder why not to simply use <code>template Foo::read&lt;int&gt;(int&amp;);</code> see <a href=\"https://stackoverflow.com/q/5715586/580083\">this question</a>.</p>\n", "Tags": "<c++><templates><constructor><instantiation><explicit>", "OwnerUserId": "580083", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_5728512_5728887_1": {"section_id": 243, "quality": 1.0, "length": 20}, "so_5728512_5728887_0": {"section_id": 235, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_5728512_5728887_1": {"section_id": 235, "quality": 1.0, "length": 20}, "so_5728512_5728887_0": {"section_id": 228, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_5728512_5728887_0": {"section_id": 245, "quality": 0.9545454545454546, "length": 21}, "so_5728512_5728887_1": {"section_id": 250, "quality": 0.9, "length": 18}}}});