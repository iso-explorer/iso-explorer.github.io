post_cb({"12953145": {"Id": "12953145", "PostTypeId": "2", "Body": "<h2>Standard reference</h2>\n<p>For a less technical view &amp; introduction - <a href=\"https://stackoverflow.com/a/12953129/673730\">skip to this answer</a>.</p>\n<p>For common cases where copy elision occurs - <a href=\"https://stackoverflow.com/a/12953150/673730\">skip to this answer</a>.</p>\n<p><strong>Copy elision</strong> is defined in the standard in:</p>\n<h3>12.8 Copying and moving class objects [class.copy]</h3>\n<p>as</p>\n<blockquote>\n<p id=\"so_12953127_12953145_0\">31) When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases,\n  the implementation treats the source and target of the omitted copy/move operation as simply two different\n  ways of referring to the same object, and the destruction of that object occurs at the later of the times\n  when the two objects would have been destroyed without the optimization.<sup>123</sup> This elision of copy/move\n  operations, called <em>copy elision</em>, is permitted in the following circumstances (which may be combined to\n  eliminate multiple copies):</p>\n<p id=\"so_12953127_12953145_1\">\u2014 in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified\n  type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value</p>\n<p id=\"so_12953127_12953145_2\">\u2014 in a throw-expression, when the operand is the name of a non-volatile automatic object (other than a\n  function or catch-clause parameter) whose scope does not extend beyond the end of the innermost\n  enclosing try-block (if there is one), the copy/move operation from the operand to the exception\n  object (15.1) can be omitted by constructing the automatic object directly into the exception object</p>\n<p id=\"so_12953127_12953145_3\">\u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</p>\n<p id=\"so_12953127_12953145_4\">\u2014 when the exception-declaration of an exception handler (Clause 15) declares an object of the same type\n  (except for cv-qualification) as the exception object (15.1), the copy/move operation can be omitted\n  by treating the exception-declaration as an alias for the exception object if the meaning of the program\n  will be unchanged except for the execution of constructors and destructors for the object declared by\n  the exception-declaration.</p>\n<p id=\"so_12953127_12953145_5\"><sub>123) Because only one object is destroyed instead of two, and one copy/move constructor is not executed, there is still one\n  object destroyed for each one constructed.</sub></p>\n</blockquote>\n<p>The example given is:</p>\n<pre><code>class Thing {\npublic:\n  Thing();\n  ~Thing();\n  Thing(const Thing&amp;);\n};\nThing f() {\n  Thing t;\n  return t;\n}\nThing t2 = f();\n</code></pre>\n<p>and explained:</p>\n<blockquote>\n<p id=\"so_12953127_12953145_6\">Here the criteria for elision can be combined to eliminate two calls to the copy constructor of class <code>Thing</code>:\n  the copying of the local automatic object <code>t</code> into the temporary object for the return value of function <code>f()</code>\n  and the copying of that temporary object into object <code>t2</code>. Effectively, the construction of the local object <code>t</code>\n  can be viewed as directly initializing the global object <code>t2</code>, and that object\u2019s destruction will occur at program\n  exit. Adding a move constructor to Thing has the same effect, but it is the move construction from the\n  temporary object to <code>t2</code> that is elided.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-18T11:03:51.627", "Score": "66", "CreationDate": "2012-10-18T11:03:51.627", "ParentId": "12953127", "CommentCount": "0", "LastEditDate": "2017-05-23T12:03:07.500", "OwnerUserId": "673730"}, "12953127": {"ViewCount": "33776", "Body": "<p>What is copy elision? What is (named) return value optimization? What do they imply?</p>\n<p>In what situations can they occur? What are limitations?</p>\n<ul>\n<li>If you were referenced to this question, you're probably looking for <a href=\"https://stackoverflow.com/a/12953129/673730\"><strong>the introduction</strong></a>.</li>\n<li>For a technical overview, see <a href=\"https://stackoverflow.com/a/12953145/673730\"><strong>the standard reference</strong></a>.</li>\n<li>See <a href=\"https://stackoverflow.com/a/12953150/673730\"><strong>common cases</strong> here</a>.</li>\n</ul>\n", "AcceptedAnswerId": "12953129", "Title": "What are copy elision and return value optimization?", "CreationDate": "2012-10-18T11:03:03.340", "Id": "12953127", "CommentCount": "4", "FavoriteCount": "146", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:03:07.500", "LastEditorUserId": "-1", "LastActivityDate": "2017-10-09T14:52:55.830", "Score": "229", "OwnerUserId": "673730", "Tags": "<c++><optimization><c++-faq><return-value-optimization><copy-elision>", "AnswerCount": "4"}, "12953150": {"Id": "12953150", "PostTypeId": "2", "Body": "<h2>Common forms of copy elision</h2>\n<p>For a technical overview - <a href=\"https://stackoverflow.com/a/12953145/673730\">skip to this answer</a>.</p>\n<p>For a less technical view &amp; introduction - <a href=\"https://stackoverflow.com/a/12953129/673730\">skip to this answer</a>.</p>\n<p>(Named) Return value optimization is a common form of copy elision. It refers to the situation where an object returned by value from a method has its copy elided. The example set forth in the standard illustrates <strong>named return value optimization</strong>, since the object is named. </p>\n<pre><code>class Thing {\npublic:\n  Thing();\n  ~Thing();\n  Thing(const Thing&amp;);\n};\nThing f() {\n  Thing t;\n  return t;\n}\nThing t2 = f();\n</code></pre>\n<p>Regular <strong>return value optimization</strong> occurs when a temporary is returned:</p>\n<pre><code>class Thing {\npublic:\n  Thing();\n  ~Thing();\n  Thing(const Thing&amp;);\n};\nThing f() {\n  return Thing();\n}\nThing t2 = f();\n</code></pre>\n<p>Other common places where copy elision takes place is when a <strong>temporary is passed by value</strong>:</p>\n<pre><code>class Thing {\npublic:\n  Thing();\n  ~Thing();\n  Thing(const Thing&amp;);\n};\nvoid foo(Thing t);\n\nfoo(Thing());\n</code></pre>\n<p>or when an <strong>exception is thrown and caught by value</strong>:</p>\n<pre><code>struct Thing{\n  Thing();\n  Thing(const Thing&amp;);\n};\n\nvoid foo() {\n  Thing c;\n  throw c;\n}\n\nint main() {\n  try {\n    foo();\n  }\n  catch(Thing c) {  \n  }             \n}\n</code></pre>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/ms364057%28v=vs.80%29.aspx#nrvo_cpp05_topic3\" rel=\"nofollow noreferrer\">Common limitations of copy elision are:</a></p>\n<ul>\n<li>multiple return points</li>\n<li>conditional initialization</li>\n</ul>\n<p>Most commercial-grade compilers support copy elision &amp; (N)RVO (depending on optimization settings). </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-08T14:05:51.940", "Score": "61", "CreationDate": "2012-10-18T11:04:05.947", "ParentId": "12953127", "CommentCount": "2", "LastEditDate": "2017-05-23T12:34:37.587", "OwnerUserId": "673730"}, "bq_ids": {"n4140": {"so_12953127_12953145_5": {"length": 17, "quality": 0.8947368421052632, "section_id": 480}, "so_12953127_12953145_3": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}, "so_12953127_12953145_0": {"length": 61, "quality": 0.953125, "section_id": 480}, "so_12953127_12953145_1": {"length": 35, "quality": 1.0, "section_id": 480}, "so_12953127_12953145_6": {"length": 54, "quality": 1.0, "section_id": 480}, "so_12953127_12953145_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 480}, "so_12953127_12953145_4": {"length": 28, "quality": 0.8484848484848485, "section_id": 480}}, "n3337": {"so_12953127_12953145_3": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_12953127_12953145_5": {"length": 17, "quality": 0.8947368421052632, "section_id": 471}, "so_12953127_12953145_0": {"length": 62, "quality": 0.96875, "section_id": 471}, "so_12953127_12953145_1": {"length": 35, "quality": 1.0, "section_id": 471}, "so_12953127_12953145_6": {"length": 54, "quality": 1.0, "section_id": 471}, "so_12953127_12953145_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 471}, "so_12953127_12953145_4": {"length": 29, "quality": 0.8787878787878788, "section_id": 471}}, "n4659": {"so_12953127_12953145_3": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}, "so_12953127_12953145_5": {"length": 17, "quality": 0.8947368421052632, "section_id": 502}, "so_12953127_12953145_0": {"length": 61, "quality": 0.953125, "section_id": 502}, "so_12953127_12953145_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}, "so_12953127_12953145_6": {"length": 39, "quality": 0.7222222222222222, "section_id": 503}, "so_12953127_12953145_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 502}, "so_12953127_12953145_4": {"length": 31, "quality": 0.9393939393939394, "section_id": 502}}}, "27916892": {"Id": "27916892", "PostTypeId": "2", "Body": "<p>Copy elision is a compiler optimization technique that eliminates unnecessary copying/moving of objects. </p>\n<p>In the following circumstances, a compiler is allowed to omit copy/move operations and hence not to call the associated constructor:</p>\n<ol>\n<li><strong>NRVO (Named Return Value Optimization)</strong>: If a function returns a class type by value and the return statement's expression is the name of a non-volatile object with automatic storage duration (which isn't a function parameter), then the copy/move that would be performed by a non-optimising compiler can be omitted. If so, the returned value is constructed directly in the storage to which the function's return value would otherwise be moved or copied.</li>\n<li><strong>RVO (Return Value Optimization)</strong>: If the function returns a nameless temporary object that would be moved or copied into the destination by a naive compiler, the copy or move can be omitted as per 1.</li>\n</ol>\n<pre><code>#include &lt;iostream&gt;  \nusing namespace std;\n\nclass ABC  \n{  \npublic:   \n    const char *a;  \n    ABC()  \n     { cout&lt;&lt;\"Constructor\"&lt;&lt;endl; }  \n    ABC(const char *ptr)  \n     { cout&lt;&lt;\"Constructor\"&lt;&lt;endl; }  \n    ABC(ABC  &amp;obj)  \n     { cout&lt;&lt;\"copy constructor\"&lt;&lt;endl;}  \n    ABC(ABC&amp;&amp; obj)  \n    { cout&lt;&lt;\"Move constructor\"&lt;&lt;endl; }  \n    ~ABC()  \n    { cout&lt;&lt;\"Destructor\"&lt;&lt;endl; }  \n};\n\nABC fun123()  \n{ ABC obj; return obj; }  \n\nABC xyz123()  \n{  return ABC(); }  \n\nint main()  \n{  \n    ABC abc;  \n    ABC obj1(fun123());//NRVO  \n    ABC obj2(xyz123());//NRVO  \n    ABC xyz = \"Stack Overflow\";//RVO  \n    return 0;  \n}\n\n**Output without -fno-elide-constructors**  \nroot@ajay-PC:/home/ajay/c++# ./a.out   \nConstructor    \nConstructor  \nConstructor  \nConstructor  \nDestructor  \nDestructor  \nDestructor  \nDestructor  \n\n**Output with -fno-elide-constructors**  \nroot@ajay-PC:/home/ajay/c++# g++ -std=c++11 copy_elision.cpp -fno-elide-constructors    \nroot@ajay-PC:/home/ajay/c++# ./a.out   \nConstructor  \nConstructor  \nMove constructor  \nDestructor  \nMove constructor  \nDestructor  \nConstructor  \nMove constructor  \nDestructor  \nMove constructor  \nDestructor  \nConstructor  \nMove constructor  \nDestructor  \nDestructor  \nDestructor  \nDestructor  \nDestructor  \n</code></pre>\n<p>Even when copy elision takes place and the copy-/move-constructor is not called, it must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed.</p>\n<p>You should permit such copy elision only in places where it won\u2019t affect the observable behavior of your software. Copy elision is the only form of optimization permitted to have (i.e. elide) observable side-effects. Example:</p>\n<pre><code>#include &lt;iostream&gt;     \nint n = 0;    \nclass ABC     \n{  public:  \n ABC(int) {}    \n ABC(const ABC&amp; a) { ++n; } // the copy constructor has a visible side effect    \n};                     // it modifies an object with static storage duration    \n\nint main()   \n{  \n  ABC c1(21); // direct-initialization, calls C::C(42)  \n  ABC c2 = ABC(21); // copy-initialization, calls C::C( C(42) )  \n\n  std::cout &lt;&lt; n &lt;&lt; std::endl; // prints 0 if the copy was elided, 1 otherwise\n  return 0;  \n}\n\nOutput without -fno-elide-constructors  \nroot@ajay-PC:/home/ayadav# g++ -std=c++11 copy_elision.cpp  \nroot@ajay-PC:/home/ayadav# ./a.out   \n0\n\nOutput with -fno-elide-constructors  \nroot@ajay-PC:/home/ayadav# g++ -std=c++11 copy_elision.cpp -fno-elide-constructors  \nroot@ajay-PC:/home/ayadav# ./a.out   \n1\n</code></pre>\n<p>GCC provides the <code>-fno-elide-constructors</code> option to disable copy elision. \nIf you want to avoid possible copy elision, use <code>-fno-elide-constructors</code>. </p>\n<p>Now almost all compilers provide copy elision when optimisation is enabled (and if no other option is set to disable it).  </p>\n<h1>Conclusion</h1>\n<p>With each copy elision, one construction and one matching destruction of the copy are omitted, thus saving CPU time, and one object is not created, thus saving space on the stack frame.</p>\n", "LastEditorUserId": "2757035", "LastActivityDate": "2016-06-27T20:37:11.833", "Score": "26", "CreationDate": "2015-01-13T07:26:05.853", "ParentId": "12953127", "CommentCount": "3", "LastEditDate": "2016-06-27T20:37:11.833", "OwnerUserId": "2575399"}, "12953129": {"Id": "12953129", "PostTypeId": "2", "Body": "<h2>Introduction</h2>\n<p>For a technical overview - <a href=\"https://stackoverflow.com/a/12953145/673730\">skip to this answer</a>.</p>\n<p>For common cases where copy elision occurs - <a href=\"https://stackoverflow.com/a/12953150/673730\">skip to this answer</a>.</p>\n<p>Copy elision is an optimization implemented by most compilers to prevent extra (potentially expensive) copies in certain situations. It makes returning by value or pass-by-value feasible in practice (restrictions apply).</p>\n<p>It's the only form of optimization that elides (ha!) the as-if rule - <strong>copy elision can be applied even if copying/moving the object has side-effects</strong>. </p>\n<p>The following example taken from <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"noreferrer\">Wikipedia</a>:</p>\n<pre><code>struct C {\n  C() {}\n  C(const C&amp;) { std::cout &lt;&lt; \"A copy was made.\\n\"; }\n};\n\nC f() {\n  return C();\n}\n\nint main() {\n  std::cout &lt;&lt; \"Hello World!\\n\";\n  C obj = f();\n}\n</code></pre>\n<p>Depending on the compiler &amp; settings, the following outputs <strong>are all valid</strong>:</p>\n<blockquote>\n<p id=\"so_12953127_12953129_0\">Hello World!  <br/>\n  A copy was made. <br/>\n  A copy was made. <br/></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_12953127_12953129_1\">Hello World! <br/>\n  A copy was made.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_12953127_12953129_2\">Hello World!</p>\n</blockquote>\n<p>This also means fewer objects can be created, so you also can't rely on a specific number of destructors being called. You shouldn't have critical logic inside copy/move-constructors or destructors, as you can't rely on them being called.</p>\n<p>If a call to a copy or move constructor is elided, that constructor must still exist and must be accessible. This ensures that copy elision does not allow copying objects which are not normally copyable, e.g. because they have a private or deleted copy/move constructor.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-28T14:29:13.350", "Score": "143", "CreationDate": "2012-10-18T11:03:03.340", "ParentId": "12953127", "CommentCount": "8", "LastEditDate": "2017-05-23T12:18:20.277", "OwnerUserId": "673730"}});