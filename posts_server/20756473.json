post_cb({"20758245": {"Id": "20758245", "PostTypeId": "2", "Body": "<p>The following source code demonstrates my comment about virtual inheritance with an example. It compiles and runs fine.</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n\nstruct PureVirtual {\n    virtual void Function() = 0;\n};\n\nstruct FunctionImpl : public virtual PureVirtual {\n    virtual void Function() {\n        std::cout &lt;&lt; \"FunctionImpl::Function()\" &lt;&lt; std::endl;\n    }   \n};\n\nstruct NonPureVirtual : public FunctionImpl, public virtual PureVirtual {\n    using FunctionImpl::Function;\n};\n\nint main() {\n    NonPureVirtual c;\n    c.Function();\n}\n\n\n/*\nLocal Variables:\ncompile-command: \"g++ ./test.cc\"\nEnd:\n */\n</code></pre>\n", "LastActivityDate": "2013-12-24T09:27:08.810", "CommentCount": "0", "CreationDate": "2013-12-24T09:27:08.810", "ParentId": "20756473", "Score": "1", "OwnerUserId": "2708138"}, "bq_ids": {"n4140": {"so_20756473_20756473_0": {"length": 13, "quality": 1.0, "section_id": 7021}}, "n3337": {"so_20756473_20756473_0": {"length": 13, "quality": 1.0, "section_id": 6767}}, "n4659": {"so_20756473_20756473_0": {"length": 13, "quality": 1.0, "section_id": 8518}}}, "20756544": {"Id": "20756544", "PostTypeId": "2", "Body": "<p>When you derive from a pure virtual class you need to override all pure virtual functions if you want to create an instance of the class. The <code>FunctionImpl</code> is completely unrelated to <code>PureVirtual</code></p>\n<p>So</p>\n<pre><code>struct NonPureVirtual : public FunctionImpl, public PureVirtual {\n    using FunctionImpl::Function;\n};\n</code></pre>\n<p>is not enough, you need to implement void Function in the class NonPureVirtual</p>\n<pre><code>struct NonPureVirtual : public FunctionImpl, public PureVirtual {\n    void Function() {}\n};\n</code></pre>\n", "LastActivityDate": "2013-12-24T07:13:50.933", "CommentCount": "0", "CreationDate": "2013-12-24T07:13:50.933", "ParentId": "20756473", "Score": "0", "OwnerUserId": "45685"}, "20756473": {"ViewCount": "1270", "Body": "<p>Consider following example</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct PureVirtual {\n    virtual void Function() = 0;\n};\n\nstruct FunctionImpl {\n    virtual void Function() {\n        std::cout &lt;&lt; \"FunctionImpl::Function()\" &lt;&lt; std::endl;\n    }   \n};\n\nstruct NonPureVirtual : public FunctionImpl, public PureVirtual {\n    using FunctionImpl::Function;\n};\n\nint main() {\n    NonPureVirtual c;\n    c.Function();\n}\n</code></pre>\n<p>Compiler (GCC 4.9, Clang 3.5) is exits with error</p>\n<pre><code>test.cpp:18:20: error: variable type 'NonPureVirtual' is an abstract class\n    NonPureVirtual c;\n                   ^\ntest.cpp:4:18: note: unimplemented pure virtual method 'Function' in 'NonPureVirtual'\n    virtual void Function() = 0;\n             ^\n</code></pre>\n<p>But when I don't derive form <code>Pure Virtual</code> everything is OK. This is weird because Standard 10.4.4 says</p>\n<blockquote>\n<p id=\"so_20756473_20756473_0\">A class is abstract if it <em>contains or inherits at</em> least one <em>pure virtual function</em> for which the final overrider is <em>pure virtual</em>.</p>\n</blockquote>\n<p>They are not saying anything about what the final overrider is but I suppose it should be <code>FunctionImpl::Function()</code> especially when I made it available through using directive. So why is still <em>Non Pure Virtual</em> abstract class and how can I fix this ?</p>\n", "AcceptedAnswerId": "20756538", "Title": "How to implement pure virtual function", "CreationDate": "2013-12-24T07:08:58.297", "Id": "20756473", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-12-24T09:04:20.190", "LastEditorUserId": "635608", "LastActivityDate": "2013-12-24T09:27:08.810", "Score": "2", "OwnerUserId": "3131721", "Tags": "<c++><polymorphism><pure-virtual>", "AnswerCount": "3"}, "20756538": {"Id": "20756538", "PostTypeId": "2", "Body": "<p><code>FunctionImpl::Function</code> and <code>PureVirtual::Function</code> are different functions from different classes.</p>\n<p>Their respective types are <code>void (FunctionImpl::*)()</code> and <code>void (PureVirtual::*)()</code>.\nSince PureVirtual and FunctionImpl are unrelated classes, these function types are unrelated.</p>\n<p>They happen to have the same name and the same parameters and return type, but since they're different, the using FunctionImpl::Function line doesn't make that function an override of the one in PureVirtual.</p>\n<p>And if you declared a variable of type <code>void (PureVirtual::*)()</code>, you wouldn't be able to assign FunctionImpl::Function to it.</p>\n<p>In other words, the final override of PureVirtual::Function is the original one in PureVirtual, which is pure virtual.</p>\n", "LastActivityDate": "2013-12-24T07:13:17.260", "CommentCount": "0", "CreationDate": "2013-12-24T07:13:17.260", "ParentId": "20756473", "Score": "1", "OwnerUserId": "1412010"}});