post_cb({"31681788": {"CommentCount": "3", "ViewCount": "173", "CreationDate": "2015-07-28T16:11:52.540", "LastActivityDate": "2015-07-28T17:19:06.370", "Title": "May C++11 standard libraries use internal static const variables without syncronization?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "31681788", "Score": "3", "Body": "<p>I'm trying to design a thread-safety specification for parts of our existing C++ library.  I thought it would be a good idea to look at the guarantees given by the standard library, and stumbled upon \u00a717.6.5.9[res.on.data.races] (from the C++11 standard), which is puzzling me:</p>\n<blockquote id=\"so_31681788_31681788_0\">\n<ol start=\"2\">\n<li>A C ++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function's arguments, including <code>this</code>.</li>\n<li>A C ++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function's non-const arguments, including <code>this</code>.</li>\n<li><em>[ Note:</em> This means, for example, that implementations can't use a static object for internal purposes without synchronization because it could cause a data race even in programs that do not explicitly share objects between threads. <em>\u2014 end note ]</em></li>\n</ol>\n</blockquote>\n<p>(I've included 3. and 4. here because 4. clarifies the preceeding paragraphs in that an object is not considered accessible if I use syncronization to coordinate the accesses.  But I am mostly concerned with 2.)</p>\n<p>If I apply that to my own library, I cannot have a function like this:</p>\n<pre><code>double area_of_circle(double radius)\n{\n  static const double pi = acos(-1.0); // syncronized\n  return pi*radius*radius; // unsyncronized access to pi\n}\n</code></pre>\n<p>The initialization of <code>pi</code> is syncronized as per \u00a76.7[stmt.dcl]/4, but reading <code>pi</code> in the return statement could happen concurrently from multiple threads.  This cannot introduce a race, since the unsyncronized accesses are only reads, yet paragraph 2. above seems to forbid this.</p>\n<p>Note that there is also paragraph 7:</p>\n<blockquote id=\"so_31681788_31681788_1\">\n<ol start=\"7\">\n<li>Implementations may share their own internal objects between threads if the objects are not visible to users and are protected against data races.</li>\n</ol>\n</blockquote>\n<p>This just seems to reiterate 2. and 3.  Unless \"protected against data races\" means something less strict than \"not accessible by threads other than the current thread\".  But I'm not really sure what is actually meant here.</p>\n<p>So my questions are:</p>\n<ol>\n<li>Am I interpreting the legalese of the standard correctly?  If I want to offer the same guarantees as the standard library with regard to threading in my own library, would I need to use locking when accessing <code>pi</code> in the example above?</li>\n<li>If yes, is this intended, or was this an oversight?</li>\n<li>If this was inteded, what are the reasons?</li>\n</ol>\n", "Tags": "<c++><multithreading><c++11><standards>", "OwnerUserId": "5165306", "AnswerCount": "1"}, "31683096": {"ParentId": "31681788", "CommentCount": "2", "CreationDate": "2015-07-28T17:19:06.370", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "31683096", "Score": "1", "Body": "<p>In this case, I believe \"accessed\" basically translates to \"odr-used\".</p>\n<p>If you can live with that interpretation, then I believe the above is safe (\u00a73.2/3):</p>\n<blockquote>\n<p id=\"so_31681788_31683096_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is <em>odr-used</em> by <code>ex</code> unless applying the lvalue-to-rvalue conversion (4.1) to <code>x</code> yields a constant expression (5.20) that does not invoke any nontrivial functions [...]</p>\n</blockquote>\n<p>Since in this case, the lvalue-to-rvalue conversion yields a constant expression that does not invoke any functions (nontrivial or otherwise), your use of <code>pi</code> doesn't qualify as <code>odr-used</code>, so you're not accessing an object. In other words, precisely as you'd expect, it basically treats the <code>pi</code> here about the same as if you had just used something like <code>#define pi 3.14159265358979</code>.</p>\n", "LastActivityDate": "2015-07-28T17:19:06.370"}, "bq_ids": {"n4140": {"so_31681788_31683096_0": {"section_id": 7040, "quality": 0.8888888888888888, "length": 16}, "so_31681788_31681788_1": {"section_id": 6352, "quality": 1.0, "length": 16}}, "n3337": {"so_31681788_31683096_0": {"section_id": 6785, "quality": 0.5555555555555556, "length": 10}, "so_31681788_31681788_1": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n4659": {"so_31681788_31683096_0": {"section_id": 8537, "quality": 0.8888888888888888, "length": 16}, "so_31681788_31681788_1": {"section_id": 7861, "quality": 1.0, "length": 16}}}});