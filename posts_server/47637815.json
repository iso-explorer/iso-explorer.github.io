post_cb({"47637815": {"ViewCount": "50", "Body": "<p>I was researching possible implementations for the <a href=\"http://en.cppreference.com/w/cpp/thread/lock\" rel=\"nofollow noreferrer\"><code>std::lock</code></a> function and stumbled upon <a href=\"https://codereview.stackexchange.com/questions/11935/stdlock-implementation-in-c-with-pthreads\">an implementation posted on the code review community</a>.</p>\n<p>Quoting the accepted answer (emphasis mine):</p>\n<blockquote>\n<p id=\"so_47637815_47637815_0\">No this does <strong>not meet the definition</strong> of std::lock().</p>\n<p id=\"so_47637815_47637815_1\">It (std::lock) guarantees that no matter what order you specify the\n  locks in the parameter list you will not fall into a deadlock\n  situation.</p>\n<p id=\"so_47637815_47637815_2\">[...]</p>\n<p id=\"so_47637815_47637815_3\">This also means that <strong>if a lock in the list is already locked it must\n  be released</strong> so that the locks are acquired in the correct order.</p>\n</blockquote>\n<p>I cannot find a conclusive answer whether or not the last statement is correct.</p>\n<p><strong>My question:</strong> is it allowed (i.e. defined behavior) to pass a locked resource, owned by the calling thread, as an argument to the standard <code>std::lock</code> function?</p>\n<pre><code>std::mutex m1, m2;\nm1.lock();\nstd::lock(m1, m2);\n</code></pre>\n<hr>\n<p>My gut feeling says this is actually not allowed. The function expects two or more <a href=\"http://en.cppreference.com/w/cpp/concept/Lockable\" rel=\"nofollow noreferrer\">Lockable</a> objects and there is no way to check if a Lockable object is already locked by the current thread of execution. So it seems impossible to implement <code>std::lock</code> that way.</p>\n</hr>", "Title": "May a call to std::lock pass a resource that is already locked by the calling thread?", "CreationDate": "2017-12-04T16:29:57.800", "LastActivityDate": "2017-12-04T19:14:05.007", "CommentCount": "0", "LastEditDate": "2017-12-04T19:14:05.007", "PostTypeId": "1", "LastEditorUserId": "4841248", "Id": "47637815", "Score": "0", "OwnerUserId": "4841248", "Tags": "<c++><multithreading>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47637815_47640001_0": {"length": 45, "quality": 0.9, "section_id": 2968}}, "n3337": {"so_47637815_47640001_0": {"length": 45, "quality": 0.9, "section_id": 2837}}, "n4659": {"so_47637815_47640001_0": {"length": 45, "quality": 0.9, "section_id": 3726}}}, "47638755": {"Id": "47638755", "PostTypeId": "2", "Body": "<p>I guess you ask your questing regarding a second std::lock in the thread on the mutex that is already locked in the same thread before. If an already locked resource is recursive_mutex, it is allowed. If it is a general mutex, you reach a deadlock.</p>\n", "LastActivityDate": "2017-12-04T17:26:29.803", "Score": "0", "CreationDate": "2017-12-04T17:26:29.803", "ParentId": "47637815", "CommentCount": "2", "OwnerUserId": "6752050"}, "47640001": {"Id": "47640001", "PostTypeId": "2", "Body": "<p>My local draft of the standard says of <code>lock</code>, in 30.4.3/5</p>\n<blockquote>\n<p id=\"so_47637815_47640001_0\">Effects: All arguments are locked via a sequence of calls to lock(), try_lock(), or unlock() on each\n  argument. The sequence of calls shall not result in deadlock, but is otherwise unspecified. [ Note: A\n  deadlock avoidance algorithm such as try-and-back-off must be used, but the specific algorithm is not\n  specified to avoid over-constraining implementations. \u2014 end note ] If a call to lock() or try_lock()\n  throws an exception, unlock() shall be called for any argument that had been locked by a call to\n  lock() or try_lock().</p>\n</blockquote>\n<p>So, it's clear that it may release locks acquired while working, but it doesn't say anything about whether locks held before entry may be have been released when it exits.</p>\n<p>Presumably, so long as either</p>\n<ol>\n<li>it succeeds and all lockables are locked, or</li>\n<li>it throws, and exactly those lockables previously locked by this thread still are (no previously un-held locks held, and no previously-locked items now released)</li>\n</ol>\n<p>it <em>shouldn't</em> make any difference what happens inside. Note that the language <em>\"... a sequence of calls ... on each argument\"</em> certainly seems to allow calling <code>unlock</code> on something locked before entry.</p>\n", "LastActivityDate": "2017-12-04T18:50:13.220", "Score": "1", "CreationDate": "2017-12-04T18:50:13.220", "ParentId": "47637815", "CommentCount": "1", "OwnerUserId": "212858"}});