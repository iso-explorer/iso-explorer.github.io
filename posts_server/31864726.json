post_cb({"31865055": {"ParentId": "31864726", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-08-06T20:20:02.890", "Score": "2", "LastEditorUserId": "3747990", "LastEditDate": "2015-08-06T20:38:37.130", "Id": "31865055", "OwnerUserId": "3747990", "Body": "<p>The code compiles in the last sample not because of any implicit move constructor or move assignment but because a copy constructor is generated of the form;</p>\n<pre><code>X(X const&amp;);\n</code></pre>\n<p>Which happily binds to the temporary. </p>\n<p>In your third sample, the code fails to compile (not related to move) because you have a copy constructor <code>X(X&amp;);</code>, but it is of an inappropriate form to bind to the temporary, it would need to be <code>X(X const&amp;);</code>. Temporaries can bind to const references.</p>\n<p>I believe the compilers are correct. </p>\n", "LastActivityDate": "2015-08-06T20:38:37.130"}, "31864726": {"CommentCount": "2", "ViewCount": "91", "CreationDate": "2015-08-06T20:00:01.690", "LastActivityDate": "2015-08-06T20:50:44.330", "Title": "I don't understand the results obtained in clang and GCC vis-\u00e0-vis [class.copy]/9 in C++14.", "AcceptedAnswerId": "31865055", "PostTypeId": "1", "Id": "31864726", "Score": "2", "Body": "<p>One can see in the snippet below, that the user-declared move constructor is called to initialize the objects <code>y</code>and <code>z</code> of type <code>X</code>. See <a href=\"http://coliru.stacked-crooked.com/a/fac0cfb0dd1b4339\" rel=\"nofollow\">live-example</a>.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct X{\n    X(){}\n    X(X&amp;&amp;) = default;\n//  X(X&amp;);\n//  X&amp; operator=(const X&amp; x);\n//  ~X() = default;\n};\nX f() { X x; return x; }\nX y = f();\nX z = X();\nint main(){}\n</code></pre>\n<p>Now, if we comment out the declaration of this move constructor, the code continues to execute without a problem, with the implicitly declared move constructor. And this is OK.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct X{\n    X(){}\n//  X(X&amp;&amp;) = default;\n//  X(X&amp;);\n//  X&amp; operator=(const X&amp; x);\n//  ~X() = default;\n};\nX f() { X x; return x; }\nX y = f();\nX z = X();\nint main(){}\n</code></pre>\n<p>Now, let's uncomment below the declaration of the copy constructor <code>X(X&amp;);</code>. As we can see in the next <a href=\"http://coliru.stacked-crooked.com/a/346c359be54b24b6\" rel=\"nofollow\">live-example</a>, the code doesn't compile, because the move constructor is not implicitly generated by the compiler. And this <strong>is correct</strong> according to bullet point (9.1) of \u00a712.8/9 (N4140).</p>\n<pre><code>#include &lt;iostream&gt;\nstruct X{\n    X(){}\n//  X(X&amp;&amp;) = default;\n    X(X&amp;);\n//  X&amp; operator=(const X&amp; x);\n//  ~X() = default;\n};\nX f() { X x; return x; }\nX y = f();\nX z = X();\nint main(){}\n</code></pre>\n<p>The problem seems to start now, when we comment out again the declaration of the copy constructor and uncomment the declaration of the copy assignment operator (see below). Now we have a user-declared copy assignment operator and according to bullet point (9.2) in \u00a712.8/9 the code <strong>should not compile</strong>. But it does, in clang and GCC.</p>\n<pre><code>#include &lt;iostream&gt;\nstruct X{\n    X(){}\n//  X(X&amp;&amp;) = default;\n//  X(X&amp;);\n    X&amp; operator=(const X&amp; x);\n//  ~X() = default;\n};\nX f() { X x; return x; }\nX y = f();\nX z = X();\nint main(){}\n</code></pre>\n<p>The same happens when we comment out again the declaration for the copy assignment operator and uncomment the declaration for the default destructor. Again, according to bullet point (9.4) in \u00a712.8/9 the code <strong>should not compile</strong>, but it does in clang and GCC.</p>\n<p>I may be missing something here, but I just don't know where did I fail in my exposition above.  </p>\n", "Tags": "<c++><language-lawyer><copy-constructor><c++14><move-constructor>", "OwnerUserId": "1042389", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31864726_31865584_1": {"section_id": 456, "quality": 0.9230769230769231, "length": 36}, "so_31864726_31865584_0": {"section_id": 458, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_31864726_31865584_1": {"section_id": 447, "quality": 0.9230769230769231, "length": 36}, "so_31864726_31865584_0": {"section_id": 449, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_31864726_31865584_1": {"section_id": 479, "quality": 0.9487179487179487, "length": 37}, "so_31864726_31865584_0": {"section_id": 481, "quality": 1.0, "length": 19}}}, "31865584": {"ParentId": "31864726", "CommentCount": "5", "CreationDate": "2015-08-06T20:50:44.330", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31865584", "Score": "1", "Body": "<p>This code:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct X{\n    X(){}\n    X&amp; operator=(const X&amp; x);\n};\nX f() { X x; return x; }\nX y = f();\nX z = X();\nint main(){}\n</code></pre>\n<p>is perfectly fine. [class.copy] does say:</p>\n<blockquote>\n<p id=\"so_31864726_31865584_0\">If the definition of a class X does not explicitly declare a move constructor, a non-explicit one will be implicitly\n  declared as defaulted if and only if [...] X does not have a user-declared copy assignment operator, [...]</p>\n</blockquote>\n<p>As a result, <code>X</code> will not have an implicitly defaulted move constructor. However, note that the alternative is not a <em>deleted</em> move constructor. Simply a non-existent one. If the implicitly-declared move constructor were deleted, then the code would fail to compile. But that is not the case here.</p>\n<p>But what does it say about the <em>copy</em> constructor?</p>\n<blockquote>\n<p id=\"so_31864726_31865584_1\">If the class definition does not explicitly declare a copy constructor, a non-explicit one is declared implicitly.\n  If the class definition declares a move constructor or move assignment operator, the implicitly declared copy\n  constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if\n  the class has a user-declared copy assignment operator or a user-declared destructor.</p>\n</blockquote>\n<p><code>X</code> has neither a move constructor nor move assignment operator, so <code>X</code> has an implicitly-declared defaulted copy constructor. This case is <strong>deprecated</strong>, but still valid code. It is likely that in some future standard it will be well-formed, but not yet! </p>\n<p>As a result, our <code>X</code> really is:</p>\n<pre><code>struct X{\n    X(){}\n    X(const X&amp;) = default;\n    X&amp; operator=(const X&amp; x);\n};\n</code></pre>\n<p>and the expression <code>X y = f();</code> copy-initializes <code>y</code>. It cannot move-initialize <code>y</code>, since we have no move constructor, but the copy constructor is still a match for <code>X</code>. </p>\n", "LastActivityDate": "2015-08-06T20:50:44.330"}});