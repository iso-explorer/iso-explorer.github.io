post_cb({"1787657": {"Id": "1787657", "PostTypeId": "2", "Body": "<p>Since object is being passed as a parameter, you cannot access private/protected functions directly.</p>\n<p>Edit:\nChanged myclass to object</p>\n", "LastEditorUserId": "64626", "LastActivityDate": "2009-11-24T03:55:17.623", "Score": "2", "CreationDate": "2009-11-24T03:50:02.503", "ParentId": "1787643", "CommentCount": "2", "OwnerUserId": "64626", "LastEditDate": "2009-11-24T03:55:17.623"}, "bq_ids": {"n4140": {"so_1787643_1787671_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6695}}, "n3337": {"so_1787643_1787671_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6450}}, "n4659": {"so_1787643_1787671_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8170}}}, "1787721": {"Id": "1787721", "PostTypeId": "2", "Body": "<p>This is correct. The relevant part of the Standard has been quoted above, but here's the rationale for what it's worth.</p>\n<p>The semantics of <code>protected</code> in C++ means \"this member can be accessed from methods of this class or any derived classes, but <em>only when dynamic type of object being accessed is guaranteed to be the same as, or derived from, the type of</em> <code>*this</code>\".</p>\n<p>The latter bit may not quite be obvious, so here is an example:</p>\n<pre><code> class Base {\n protected:\n     int X;\n };\n\nclass Derived : public Base {\n   void Foo(Base* b, Derived* d) {\n       this-&gt;X = 123; // okay - `this` is definitely either Derived\n                      // or inherited from Derived\n\n       d-&gt;X = 456;    // also okay, for the same reason\n\n       b-&gt;X = 789;    // NOT OKAY; b could point to instance of some other class\n                      // Derived2, which isn't inherited from Derived!\n   }\n};\n</code></pre>\n<p>This is by design - the idea is that <code>Derived2</code> could have its own opinion on how its protected members should be handled (what are the invariants, etc), and it should be strictly between it and its base class (and its derived classes, but only if it decides to not hide that field by making it <code>private</code>). Cross-hierarchy access is contrary to this model, since it would effectively mean that the base class decides for the entire hierarchy in advance; for very abstract classes on top of deep hierarchies, this can be undesirable.</p>\n<p>Now back to your specific problem - it should be fairly obvious by now. Once you obtain a member function pointer, you may call the function pointed to by that pointer with any receiver of a matching type. For a protected method of a base class, this means that, if you could obtain a pointer to it typed to the base class (rather than your own class), you could then call it, passing it a pointer to a type different from your class (or derived from it), violating the rules for protected access outlined above. Therefore, you are not permitted to do this.</p>\n", "LastEditorUserId": "111335", "LastActivityDate": "2009-11-24T04:23:56.303", "Score": "13", "CreationDate": "2009-11-24T04:10:41.227", "ParentId": "1787643", "CommentCount": "5", "OwnerUserId": "111335", "LastEditDate": "2009-11-24T04:23:56.303"}, "1787643": {"ViewCount": "334", "Body": "<p>The following simple piece of code, compiles with VC2008 but g++ rejects the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass myclass\n{\nprotected:\n    void print() { std::cout &lt;&lt; \"myclass::print();\"; }\n};\n\nstruct access : private myclass\n{\n    static void access_print(myclass&amp; object)\n    {\n        // g++ and Comeau reject this line but not VC++\n        void (myclass::*function) () = &amp;myclass::print;\n\n        (object.*function)();\n    }\n};\n\nint main()\n{\n    myclass object;\n    access::access_print(object);\n}\n</code></pre>\n<p><code>(/W4)</code> is turned on in VC, but it doesn't give any warning.</p>\n<p>g++ 4.4.1 gives me an error:</p>\n<pre><code>correct.cpp: In static member function \u2018static void access::access_print(myclass&amp;)\u2019:\ncorrect.cpp:6: error: \u2018void myclass::print()\u2019 is protected\n</code></pre>\n<p>If g++ is correct, how do I access a protected member of a class? is there another way?</p>\n<hr>\n<p>@Suroot Do you mean that I shouldn't pass an object of type <code>myclass</code>? It doesn't matter actually, g++ gives the same error but VC compiles the code without any warning.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass myclass\n{\nprotected:\n    void print() { std::cout &lt;&lt; \"myclass::print();\"; }\n};\n\nstruct access : private myclass\n{\n    static void access_print()\n    {\n        myclass object;\n        void (myclass::*function) () = &amp;myclass::print;\n\n        (object.*function)();\n    }\n};\n\nint main()\n{\n    access::access_print();\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "1787671", "Title": "Is this a standard C++ code?", "CreationDate": "2009-11-24T03:45:51.730", "Id": "1787643", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2009-11-24T03:58:30.690", "LastEditorUserId": "127893", "LastActivityDate": "2009-11-24T04:23:56.303", "Score": "4", "OwnerUserId": "127893", "Tags": "<c++><standards><standards-compliance>", "AnswerCount": "3"}, "1787671": {"Id": "1787671", "PostTypeId": "2", "Body": "<p>I believe g++ and comeau are correct. The specifier for a protected member must be of type \"access\" or derived, so I believe the code:</p>\n<pre><code>void (myclass::*function) () = &amp;access::print;\n</code></pre>\n<p>would compile.</p>\n<p>I believe this is because of 11.5.1:</p>\n<blockquote>\n<p id=\"so_1787643_1787671_0\">... If the access [ed. to a protected\n  member ] is to form a pointer to\n  member, the nested-name-specifier\n  shall name the derived class (or any\n  class derived from that class).</p>\n</blockquote>\n", "LastActivityDate": "2009-11-24T03:54:06.597", "CommentCount": "6", "CreationDate": "2009-11-24T03:54:06.597", "ParentId": "1787643", "Score": "6", "OwnerUserId": "54858"}});