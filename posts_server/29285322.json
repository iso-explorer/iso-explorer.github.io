post_cb({"29285322": {"CommentCount": "1", "ViewCount": "424", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-03-26T17:43:16.593", "LastActivityDate": "2015-09-24T14:54:48.403", "Title": "Does C++11 require allocators to be default constructible, libstdc++ and libc++ disagree?", "FavoriteCount": "5", "LastEditDate": "2017-05-23T12:23:52.130", "Id": "29285322", "Score": "9", "Body": "<p>Using a slightly modified version of <a href=\"http://howardhinnant.github.io/short_alloc.h\" rel=\"nofollow noreferrer\">Howard Hinnants's C++11 stack allocator</a> which is <a href=\"http://howardhinnant.github.io/stack_alloc.html\" rel=\"nofollow noreferrer\">documented here</a> and <a href=\"https://stackoverflow.com/q/11648202/1708801\">here</a>, with <code>std::basic_string</code> and compiling with <code>gcc</code> which is using <code>libstdc++</code>, the following example (<em><a href=\"http://coliru.stacked-crooked.com/a/d53788fce6665a7f\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>const unsigned int N = 200;\n\narena&lt;N&gt; a;\nshort_alloc&lt;char, N&gt; ac(a) ;\n\nstd::basic_string&lt;char,std::char_traits&lt;char&gt;,short_alloc&lt;char, N&gt;&gt; empty(ac);\n</code></pre>\n<p>gives the following error(<em>amongst others</em>):</p>\n<pre><code>error: no matching function for call to 'short_alloc&lt;char, 200ul&gt;::short_alloc()'\n   if (__n == 0 &amp;&amp; __a == _Alloc())\n                       ^\n</code></pre>\n<p>However it works without error when compiling with <code>clang</code> and using <code>libc++</code> (<em><a href=\"http://coliru.stacked-crooked.com/a/4ff2950f84a451b4\" rel=\"nofollow noreferrer\">see it live</a></em>).</p>\n<p>The <code>stdlibc++</code> implementation of <code>std::basic_string</code> expects the allocator to have a default constructor.</p>\n<p>Does C++11 require allocators to be default constructible? Which implementation is correct?</p>\n", "Tags": "<c++><c++11><language-lawyer><libstdc++><allocator>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29285322_29285323_7": {"section_id": 5058, "quality": 0.5714285714285714, "length": 4}, "so_29285322_29285323_0": {"section_id": 6296, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_29285322_29285323_7": {"section_id": 4855, "quality": 0.5714285714285714, "length": 4}, "so_29285322_29285323_0": {"section_id": 6053, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_29285322_29285323_7": {"section_id": 6479, "quality": 0.5714285714285714, "length": 4}, "so_29285322_29285323_0": {"section_id": 7804, "quality": 0.8181818181818182, "length": 9}}}, "29285323": {"ParentId": "29285322", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>No, C++11 does not require an allocator have default constructor, if we look at the draft C++11 standard section <code>17.6.3.5</code> <em>[allocator.requirements]</em> it contains Table <code>28</code> <em>Allocator requirements</em> which does not contain a requirement for a default constructor and later on in the section a minimal conforming interface is provided:</p>\n<blockquote>\n<p id=\"so_29285322_29285323_0\">[ Example: the following is an allocator class template supporting the\n  minimal interface that satisfies the requirements of Table 28:</p>\n<pre><code>template &lt;class Tp&gt;\nstruct SimpleAllocator {\n    typedef Tp value_type;\n    SimpleAllocator(ctor args );\n\n    template &lt;class T&gt; SimpleAllocator(const SimpleAllocator&lt;T&gt;&amp; other);\n\n    Tp *allocate(std::size_t n);\n    void deallocate(Tp *p, std::size_t n);\n};\n</code></pre>\n<p id=\"so_29285322_29285323_1\">\u2014end example ]</p>\n</blockquote>\n<p>which does not contain a default constructor.</p>\n<p>There is a <code>libstdc++</code> bug report: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56437\" rel=\"nofollow\">basic_string assumes that allocators are default-constructible</a> which says:</p>\n<blockquote>\n<p id=\"so_29285322_29285323_2\">The empty-string optimization of basic_string assumes that allocators\n  are default constructible. While this used to be the case in C++98, it\n  is no longer true in C++11, as now allocators are allowed to have\n  state.</p>\n<p id=\"so_29285322_29285323_3\">Consider the attached example program. Compiling with</p>\n<pre><code>g++ -std=c++11 -c t.cpp\n</code></pre>\n<p id=\"so_29285322_29285323_4\">produces an error message, even though it should compile fine. The\n  problem is the the \"_S_construct\" calls \"_Alloc()\", which does not\n  exist.</p>\n<p id=\"so_29285322_29285323_5\">Note that the C++11 standard does not require default constructors.\n  (Section 17.6.3.5, Table 28). In particular, the SimpleAllocator\n  example from Section 17.6.3.5 would trigger the same bug, too.</p>\n</blockquote>\n<p>and the response was:</p>\n<blockquote>\n<p id=\"so_29285322_29285323_6\">This is hardly the only C++11 allocator requirement missing from\n  std::string, ALL of the new requirements are missing, and unlikely to\n  be implemented until we switch to a non-COW string implementation.</p>\n</blockquote>\n<p>This is fixed as of <code>gcc 5.0</code>:</p>\n<blockquote>\n<p id=\"so_29285322_29285323_7\">Fixed for GCC 5 (when using the new string ABI)</p>\n</blockquote>\n<p>We can confirm this using <a href=\"http://melpon.org/wandbox/permlink/luTlAV5HglUEjZ5M\" rel=\"nofollow\">gcc 5 on wandbox</a></p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-03-27T17:22:02.423", "Id": "29285323", "Score": "7", "CreationDate": "2015-03-26T17:43:16.593", "LastActivityDate": "2015-03-27T17:22:02.423"}});