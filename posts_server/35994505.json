post_cb({"bq_ids": {"n4140": {"so_35994505_35995627_1": {"length": 28, "quality": 0.8, "section_id": 3492}}, "n3337": {"so_35994505_35995627_1": {"length": 28, "quality": 0.8, "section_id": 3357}}, "n4659": {"so_35994505_35995627_1": {"length": 27, "quality": 0.7714285714285715, "section_id": 4255}}}, "35995606": {"Id": "35995606", "PostTypeId": "2", "Body": "<p>Let me offer one rationale: When using integers, you sometimes use them to implement a choice. So you have N values, each of which must be equally likely. Sometimes, the highest possible value could even be the highest value representable in that integer type, so N+1 would be out of range and overflow.</p>\n<p>For floating point values, you often can't represent the limits of the range anyway (e.g. <code>0.1</code>) and since the numbers are not compared for equality usually (e.g. <code>1.0/10.0</code> may or may not compare equal to <code>0.1</code>), you ignore the fact that the limiting value doesn't occur.</p>\n", "LastActivityDate": "2016-03-14T18:46:49.357", "CommentCount": "0", "CreationDate": "2016-03-14T18:46:49.357", "ParentId": "35994505", "Score": "2", "OwnerUserId": "1968182"}, "35995627": {"Id": "35995627", "PostTypeId": "2", "Body": "<p>The uniform real distribution over <code>[a, b)</code> is almost statistically indistinguishable from the distribution <code>[a, b]</code>.</p>\n<p>The <a href=\"https://en.wikipedia.org/wiki/Total_variation_distance_of_probability_measures\" rel=\"nofollow\">statistical distance</a> between these two distibutions is, very nearly, one divided by the number of floating point numbers between <code>a</code> and <code>b</code>.</p>\n<p>That is to say, there is no statistical test which returns either <code>0</code> or <code>1</code> for any given sample, such that the probability of observing a <code>1</code> with the first distribution differs from the probability of observing a <code>1</code> with the second distribution, by more than <code>2^{-32}</code>. (Assuming that you are driving e.g. <code>std::uniform_real_distribution&lt;float&gt;</code> using pure entropy from <code>std::random_device</code>.)</p>\n<p>Thus in most real applications there is no meaningful difference.</p>\n<p>If you want to do something like, have a range <code>(a, b]</code> instead in order to prevent a (highly unlikely) divide by zero error or something, you can test if you got exactly <code>a</code> and replace it with <code>b</code> if it is some critical system of some sort.</p>\n<hr>\n<p>Also FWIW I suspect that your solution of \"next after b\" will not always do what you think -- most of the time, what is going to happen is, the adaptor is going to compute <code>b - a</code> as a floating point number, then take a sample from the entropy source, convert it to a floating point number in the range <code>0-1</code> with a static cast, then multiply by the factor <code>b-a</code>, add <code>a</code> and return the result.</p>\n<p>An epsilon change in <code>b</code> is likely to get lost in the floating point subtraction, if <code>a</code> and <code>b</code> are not of exactly the same scale, and then the change would have no effect.</p>\n<p>The reason that this is not a bug is that the standard does not require that the distribution adaptor produces <strong>exactly</strong> the specified distribution, only that it converges to the target in an approximate sense.</p>\n<p>The standard makes a hard guarantee that the distribution won't ever generate something outside it's stated range:</p>\n<blockquote>\n<p id=\"so_35994505_35995627_0\">26.5.8.1 In General [rand.dist.general]<br>\n  1. Each type instantiated from a class template specified in this section 26.5.8 satisfies the requirements of a\n  random number distribution (26.5.1.6) type.<br>\n   ...<br>\n  3. The algorithms for producing each of the specified distributions are implementation-defined.<br>\n  4. The value of each probability density function <code>p(z)</code> and of each discrete probability function <code>P (z i )</code> specified\n  in this section is <code>0</code> everywhere outside its stated domain.</br></br></br></br></p>\n</blockquote>\n<p>But, the standard also says this about uniform random number generators:</p>\n<blockquote>\n<p id=\"so_35994505_35995627_1\">26.5.3.1  [rand.req.urng]<br>\n  1. A <em>uniform random number generator</em> <code>g</code> of type <code>G</code> is a function object returning unsigned integer values such\n  that each value in the range of possible results has (ideally) equal probability of being returned. [ Note: The\n  degree to which <code>g</code>\u2019s results approximate the ideal is often determined statistically. \u2014 end note ]  </br></p>\n</blockquote>\n<p>Since <code>[a, b)</code> and <code>[a, b + epsilon)</code> are basically statistically indistinguishable, you shouldn't consider it to be a bug if even if with your <code>b + epsilon</code> trick you still never see a <code>b</code> in the output, even if you exhaustively try every possible seed.</p>\n<p>If this were not the standpoint of the standard, then all of these adaptors would have to be painstakingly written so that they can always get exactly the right distribution on every architecture, and they would have to run much slower. In most applications minute sampling inaccuracies like this are tolerable and it's more important to be efficient.</p>\n</hr>", "LastEditorUserId": "3598119", "LastActivityDate": "2016-03-14T19:43:13.437", "Score": "6", "CreationDate": "2016-03-14T18:47:53.943", "ParentId": "35994505", "CommentCount": "1", "OwnerUserId": "3598119", "LastEditDate": "2016-03-14T19:43:13.437"}, "35994505": {"ViewCount": "375", "Body": "<p><code>uniform_int_distribution</code> has the interval <code>[a, b]</code> but <code>uniform_real_distribution</code> has the interval <code>[a, b)</code>. A naive approach is to do something like  <code>b + 0.1</code>, but then you start to get into infinitesimals...luckily the correct approach is simple:</p>\n<pre><code>std::uniform_real_distribution&lt;&gt; dis(start, std::nextafter(stop, DBL_MAX));\n</code></pre>\n<p>But why is this necessary? More specifically, what's the rationale that these two are different?</p>\n", "Title": "Why is uniform_int_distribution closed range but uniform_real_distribution is half-open range?", "CreationDate": "2016-03-14T17:47:43.157", "LastActivityDate": "2016-03-14T19:43:13.437", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "Id": "35994505", "Score": "5", "OwnerUserId": "6062211", "Tags": "<c++><c++11><random>", "AnswerCount": "2"}});