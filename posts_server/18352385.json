post_cb({"18352385": {"CommentCount": "4", "AcceptedAnswerId": "18353789", "PostTypeId": "1", "LastEditorUserId": "1131467", "CreationDate": "2013-08-21T08:24:54.520", "LastActivityDate": "2013-08-21T09:40:27.703", "LastEditDate": "2013-08-21T09:37:12.130", "ViewCount": "1220", "FavoriteCount": "3", "Title": "Is taking the address of a local variable a constant expression in C++11?", "Id": "18352385", "Score": "17", "Body": "<p>The following C++11 program:</p>\n<pre><code>int x = 42;\n\nvoid f()\n{\n        int y = 43;\n\n        static_assert(&amp;x &lt; &amp;y, \"foo\");\n}\n\nint main()\n{\n        f();\n}\n</code></pre>\n<p>Doesn't compile with gcc 4.7 as it complains:</p>\n<pre><code>error: \u2018&amp;y\u2019 is not a constant expression\n</code></pre>\n<p>This would agree with my intuition.  The address of <code>y</code> potentially changes with each invocation of <code>f</code>, so of course it cannot be calculated during translation.</p>\n<p>However none of the bullet points in 5.19 [expr.const] seem to preclude it from being a constant expression.</p>\n<p>The only two contenders I see are:</p>\n<blockquote>\n<p id=\"so_18352385_18352385_0\">an lvalue-to-rvalue conversion...</p>\n</blockquote>\n<p>but unless I am mistaken (?) there are no lvalue-to-rvalue conversions in the program.</p>\n<p>And</p>\n<blockquote>\n<p id=\"so_18352385_18352385_1\">an <code>id-expression</code> that refers to a variable [snip] unless:</p>\n<ul>\n<li>it is initialized with a constant expression</li>\n</ul>\n</blockquote>\n<p>which <code>y</code> is - it is initialized with the constant expression <code>43</code>.</p>\n<p>So is this an error in the standard, or am I missing something?</p>\n<p><strong>Update:</strong></p>\n<p>It's confusing as hell, but I think I am on top of it, so let me show an example that will show off what is going on:</p>\n<pre><code>int x = 42;\n\nvoid f()\n{\n        int y = 43;\n\n        // address constant expressions:    \n        constexpr int* px = &amp;x; // OK\n        constexpr int* py = &amp;y; // ERROR: pointer context for local variable\n\n        // boolean constant expressions:\n        constexpr bool bx = &amp;x; // OK\n        constexpr bool by = &amp;y; // OK\n\n        // comparison constant expressions:\n        constexpr bool eq = (&amp;x == &amp;y); // OK\n        constexpr bool lt = (&amp;x &lt; &amp;y); // ERROR: undefined behaviour disqualifies \n                                                 a constant expression\n}\n\nint main()\n{\n        f();\n}\n</code></pre>\n<p>First distinguish between a core constant expression (5.19p2) and a constant expression (5.19p4).  Specifcally sub-expressions of a constant expression only have to be core constant expressions, not constant expressions.  That is, being a constant expression is a property of the full expression, not sub-expressions.  It further requires to look at the context it which the full expression is used.</p>\n<p>So, as it turns out the gcc error is misleading.  Firstly <code>&amp;y</code> may be a constant expression in some contexts.  Secondly, the reason <code>&amp;x &lt; &amp;y</code> isn't a constant expression is because of the comparison of unrelated pointers, not of the sub-expression <code>&amp;y</code>.</p>\n", "Tags": "<c++><c++11><language-lawyer><constexpr><pointer-arithmetic>", "OwnerUserId": "1131467", "AnswerCount": "6"}, "18352687": {"ParentId": "18352385", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Sorry, I agree that the previous answer was probably an incorrect reading of the items. Instead, the actual relevant clause is 5.19 [expr.const] paragraph 3 which reads (highlightening added):</p>\n<blockquote>\n<p id=\"so_18352385_18352687_0\">A literal constant expression is a prvalue core constant expression of literal type, <strong>but not pointer type</strong>. An\n  integral constant expression is a literal constant expression of integral or unscoped enumeration type. [ Note:\n  Such expressions may be used as array bounds (8.3.4, 5.3.4), as bit-field lengths (9.6), as enumerator initializers\n  if the underlying type is not fixed (7.2), as null pointer constants (4.10), and as alignments (7.6.2). \u2014end\n  note ] A converted constant expression of type T is a literal constant expression, implicitly converted to type T,\n  where the implicit conversion (if any) is permitted in a literal constant expression and the implicit conversion\n  sequence contains only user-defined conversions, lvalue-to-rvalue conversions (4.1), integral promotions (4.5),\n  and integral conversions (4.7) other than narrowing conversions (8.5.4). [ Note: such expressions may be used\n  as case expressions (6.4.2), as enumerator initializers if the underlying type is fixed (7.2), and as integral or\n  enumeration non-type template arguments (14.3). \u2014end note ] A reference constant expression is an lvalue\n  core constant expression that designates an object with static storage duration or a function. <strong>An address\n  constant expression</strong> is a prvalue core constant expression of pointer type that evaluates to the <strong>address of an\n  object with static storage duration</strong>, to the address of a function, or to a null pointer value, or a prvalue core\n  constant expression of type std::nullptr_t. <strong>Collectively, literal constant expressions, reference constant\n  expressions, and address constant expressions are called constant expressions.</strong></p>\n</blockquote>\n<p>A core constant expression isn't directly a constant expression, there are additional conditions which are spelled out in this third paragraph.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2013-08-21T09:04:20.440", "Id": "18352687", "Score": "1", "CreationDate": "2013-08-21T08:40:05.997", "LastActivityDate": "2013-08-21T09:04:20.440"}, "18352801": {"ParentId": "18352385", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In C++ pre-C++11: </p>\n<blockquote>\n<p id=\"so_18352385_18352801_0\">Other expressions [than integral constant expressions] are\n  considered constantexpressions only for the purpose of\n  nonlocal static object initialization (3.6.2).  Such\n  constant expressions shall evaluate to one of the following:</p>\n<p id=\"so_18352385_18352801_1\">[...]</p>\n<p id=\"so_18352385_18352801_2\">-- an address constant expression,</p>\n<p id=\"so_18352385_18352801_3\">[...]</p>\n<p id=\"so_18352385_18352801_4\">An address constant expression is a pointer to an lvalue\n  designating an object of static storage duration, a string\n  literal (2.13.4), or a function.</p>\n</blockquote>\n<p>Since <code>y</code> doesn't have static storage duration, <code>&amp;y</code> would not\nbe a constant expression.</p>\n<p>C++11 seems to have changed this; I suspect that this is an\noversignt, however.  (C++ pre-C++11 lists the things that are\nconstant expressions.  C++11 lists the things that aren't.  It\nwould be easy for one to have been forgotten.)</p>\n<p>Regardless, of course: your comparison isn't usable in standard\nC++; the results of comparing two addresses which don't point\ninto the same object is unspecified.  (On the other hand, I have\noccasionally used something similar in machine dependent code.\nNot statically, but on platforms like Linux on PC or Solaris,\nit's possible to determine whether a pointer points to an object\nwith static lifetime, and auto variable, or dynamically\nallocated memory with such tricks.)</p>\n<h2>EDIT:</h2>\n<p>The answser by paxdiablo has quoted the passage I didn't find in\nmy reading of C++11; C++11 follows the same rule as C++ pre-11\nin this respect, and in order to be a constant address\nexpression, the address must be that of an object with static\nlifetime (or a function, or a null pointer).</p>\n", "OwnerUserId": "649665", "LastEditorUserId": "649665", "LastEditDate": "2013-08-21T08:53:07.950", "Id": "18352801", "Score": "0", "CreationDate": "2013-08-21T08:45:23.587", "LastActivityDate": "2013-08-21T08:53:07.950"}, "18353789": {"CommentCount": "3", "CreationDate": "2013-08-21T09:30:47.523", "CommunityOwnedDate": "2013-08-21T09:30:47.523", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-21T09:40:27.703", "ParentId": "18352385", "PostTypeId": "2", "LastEditDate": "2017-05-23T11:44:40.557", "Id": "18353789", "Score": "10", "Body": "<p>Let's try to determine which requirements the expression in the <em>static_assert-declaration</em> has to fulfil step-by-step, using n3485.</p>\n<p>[dcl.dcl]/1</p>\n<blockquote>\n<p id=\"so_18352385_18353789_0\"><em>static_assert-declaration:</em><br/>\n<code>static_assert (</code><em>constant-expression</em><code>,</code><em>string-literal</em><code>) ;</code></p>\n</blockquote>\n<p>[dcl.dcl]/4</p>\n<blockquote>\n<p id=\"so_18352385_18353789_1\">In a <em>static_assert-declaration</em> the <em>constant-expression</em> shall be a constant expression that can be contextually converted to <code>bool</code>.</p>\n</blockquote>\n<p>[expr.const]/4</p>\n<blockquote>\n<p id=\"so_18352385_18353789_2\">Collectively, <em>literal constant expressions</em>, <em>reference constant expressions</em>, and <em>address constant expressions</em> are called <em>constant expressions</em>.</p>\n</blockquote>\n<hr>\n<p>So what type of constant expression is <code>&amp;x &lt; &amp;y</code>? It is <strong>not</strong> an <em>address constant expression</em>:</p>\n<p>[expr.const]/4</p>\n<blockquote>\n<p id=\"so_18352385_18353789_3\">An <em>address constant expression</em> is a prvalue core constant expression (after conversions as required by the context) of type <code>std::nullptr_t</code> or of pointer type [...].</p>\n</blockquote>\n<p>The type of <code>&amp;x &lt; &amp;y</code> is <code>bool</code> as per [expr.rel]/1.</p>\n<p>It isn't a <em>reference constant expression</em> either, so it must be a <em>literal constant expression</em>, <strong>if any</strong>.</p>\n<blockquote>\n<p id=\"so_18352385_18353789_4\">A <em>literal constant expression</em> is a prvalue core constant expression of literal type [...]</p>\n</blockquote>\n<p>Therefore, <code>&amp;x &lt; &amp;y</code> has to fulfil the requirements of a <em>core constant expression</em>.</p>\n<hr>\n<p>As <a href=\"https://stackoverflow.com/a/18352680/420683\">pointed out by TemplateRex</a> and <a href=\"https://stackoverflow.com/users/743382/hvd\">hvd</a> in the comments, in this particular case, <code>&amp;x &lt; &amp;y</code> does not fulfil the requirements of a <em>core constant expression</em>:</p>\n<p>[expr.const]/2</p>\n<blockquote>\n<p id=\"so_18352385_18353789_5\">[a core constant expression must not contain] a relational or equality operator where the result is unspecified;</p>\n</blockquote>\n<p>[expr.rel]/2</p>\n<blockquote>\n<p id=\"so_18352385_18353789_6\">If two pointers <code>p</code> and <code>q</code> of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null, the results of <code>p&lt;q</code>, <code>p&gt;q</code>, <code>p&lt;=q</code>, and <code>p&gt;=q</code> are unspecified.</p>\n</blockquote>\n<p>However, for an example like</p>\n<pre><code>int arr[2] = {1, 2};\nstatic_assert(&amp;a[0] &lt; &amp;a[1], \"\");\n</code></pre>\n<p>The expression <code>a &lt; a+1</code> fulfils this requirement as well.</p>\n</hr></hr>", "OwnerUserId": "420683"}, "18352847": {"ParentId": "18352385", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-08-21T08:48:09.637", "OwnerUserId": "1782465", "CommunityOwnedDate": "2013-08-21T08:48:09.637", "Id": "18352847", "Score": "1", "Body": "<p>5.19p2 does not define <em>constant expressions,</em> it defines <em>core constant expressions.</em></p>\n<p>A <em>core constant expression</em> only becomes a <em>constant expression</em> if it conforms to one of the rules in 5.19p3. There, the relevant part was already pointed out by jrok:</p>\n<blockquote>\n<p id=\"so_18352385_18352847_0\">An <em>address constant expression</em> is a prvalue core constant expression of pointer type that evaluates to the address of an object with static storage duration, to the address of a function, or to a null pointer value, or a prvalue core constant expression of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p>Your core constant expression <code>&amp;y</code> does not evaluate to any of those, so it's not an <em>address constant expression,</em> and thus not a <em>constant expression.</em></p>\n", "LastActivityDate": "2013-08-21T08:48:09.637"}, "18352474": {"ParentId": "18352385", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Yes, you're missing the fact that, while <code>y</code> itself is initialised with a constant expression, that's <em>not</em> the same as <code>&amp;y</code>.</p>\n<p>The address of <code>y</code> can vary a great deal depending on your call stack history.</p>\n<p>Paragraph 3 of <code>C++11 5.19 Constant expressions</code> states the conditions under which the address-of operator can be considered a constant expression (how core constant expressions detailed in paragraph 2 are allowed to morph into \"real\" constant expressions):</p>\n<blockquote>\n<p id=\"so_18352385_18352474_0\">... An address constant expression is a prvalue core constant expression of pointer type that evaluates to <strong>the address of an object with static storage duration,</strong> to <strong>the address of a function,</strong> or to a <strong>null pointer value,</strong> or a <strong>prvalue core constant expression of type std::nullptr_t.</strong> Collectively, literal constant expressions, reference constant expressions, and address constant expressions are called constant expressions.</p>\n</blockquote>\n<p>Since <code>&amp;y</code> is none of those things, it's not considered a constant expression.</p>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2013-08-21T09:00:59.217", "Id": "18352474", "Score": "7", "CreationDate": "2013-08-21T08:29:20.677", "LastActivityDate": "2013-08-21T09:00:59.217"}, "bq_ids": {"n4140": {"so_18352385_18353789_5": {"section_id": 6185, "quality": 0.7272727272727273, "length": 8}, "so_18352385_18352847_0": {"section_id": 87, "quality": 0.6153846153846154, "length": 16}, "so_18352385_18353789_4": {"section_id": 6185, "quality": 0.7777777777777778, "length": 7}, "so_18352385_18352801_4": {"section_id": 7151, "quality": 0.6428571428571429, "length": 9}, "so_18352385_18353789_1": {"section_id": 5382, "quality": 1.0, "length": 8}, "so_18352385_18353789_3": {"section_id": 91, "quality": 0.5333333333333333, "length": 8}}, "n3337": {"so_18352385_18353789_5": {"section_id": 5946, "quality": 0.7272727272727273, "length": 8}, "so_18352385_18352847_0": {"section_id": 5947, "quality": 0.9615384615384616, "length": 25}, "so_18352385_18353789_2": {"section_id": 5947, "quality": 0.9230769230769231, "length": 12}, "so_18352385_18353789_6": {"section_id": 5913, "quality": 1.0, "length": 20}, "so_18352385_18353789_4": {"section_id": 5947, "quality": 0.8888888888888888, "length": 8}, "so_18352385_18352801_4": {"section_id": 6895, "quality": 0.6428571428571429, "length": 9}, "so_18352385_18352687_0": {"section_id": 5947, "quality": 0.8741721854304636, "length": 132}, "so_18352385_18353789_1": {"section_id": 5176, "quality": 1.0, "length": 8}, "so_18352385_18353789_3": {"section_id": 86, "quality": 0.6, "length": 9}, "so_18352385_18352474_0": {"section_id": 5947, "quality": 0.9487179487179487, "length": 37}}, "n4659": {"so_18352385_18353789_5": {"section_id": 7687, "quality": 0.7272727272727273, "length": 8}, "so_18352385_18352847_0": {"section_id": 7690, "quality": 0.6923076923076923, "length": 18}, "so_18352385_18353789_1": {"section_id": 6806, "quality": 0.625, "length": 5}, "so_18352385_18353789_3": {"section_id": 7690, "quality": 0.6, "length": 9}, "so_18352385_18353789_4": {"section_id": 7687, "quality": 0.7777777777777778, "length": 7}}}, "18352680": {"ParentId": "18352385", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Taking the address of something is not the culprit here, but rather the pointer comparison using <code>operator&lt;</code> on unrelated objects.</p>\n<p>Relational operators on pointers is only specified for pointers to objects within the same class or within an array (5.9 Relational operators [expr.rel], points 3 and 4.) <strong>Relational comparison for pointers to unrelated objects is unspecified.</strong></p>\n<p>Comparing the address for <strong>equality</strong> rather than <strong>ordering</strong> does work:</p>\n<pre><code>int x = 42;\n\nvoid f()\n{\n        int y = 43;\n\n        static_assert(&amp;x != &amp;y, \"foo\");\n                         ^^ &lt;--- \"&lt;\" on unrelated objects is unspecified\n}\n\nint main()\n{\n        f();\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/view?id=6abc2127ed22884a374317aa7f334f1a-7fa5748cb8ba984550f021f5e689240a\" rel=\"nofollow\"><strong>Live example</strong></a></p>\n<p>Just to show that this has nothing to do with const-expressions per se, </p>\n<pre><code>void f()\n{\n        int y[2] = { 42, 43 };\n\n        static_assert(&amp;y[0] &lt; &amp;y[1], \"foo\");\n                            ^ &lt;--- \"&lt;\" on objects within an array is specified\n}\n\nint main()\n{\n        f();\n}\n</code></pre>\n<p>Another <a href=\"http://coliru.stacked-crooked.com/view?id=482a8061502961a9e1e31acfc39f9d4f-6b864d01527066fb211cc4a5466784d9\" rel=\"nofollow\"><strong>live example</strong></a>.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-08-21T09:01:52.960", "Id": "18352680", "Score": "4", "CreationDate": "2013-08-21T08:39:54.237", "LastActivityDate": "2013-08-21T09:01:52.960"}});