post_cb({"bq_ids": {"n4140": {"so_22494302_22494503_0": {"length": 18, "quality": 0.9, "section_id": 5988}, "so_22494302_22494302_0": {"length": 32, "quality": 0.6956521739130435, "section_id": 5988}}, "n3337": {"so_22494302_22494503_0": {"length": 19, "quality": 0.95, "section_id": 5756}, "so_22494302_22494302_0": {"length": 45, "quality": 0.9782608695652174, "section_id": 5756}}, "n4659": {"so_22494302_22494503_0": {"length": 18, "quality": 0.9, "section_id": 7488}, "so_22494302_22494302_0": {"length": 36, "quality": 0.782608695652174, "section_id": 7488}}}, "22494302": {"ViewCount": "394", "Body": "<p>What do the characters in bold mean in this sentence extracted from paragraph \u00a75.2.2/1 of the C++11 Standard?</p>\n<blockquote>\n<p id=\"so_22494302_22494302_0\">There are two kinds of function call: ordinary function call and member function (9.3) call. A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute the arguments to the function. <strong>For an ordinary function call, the postfix expression shall be either an lvalue that refers to a function (in which case the function-to-pointer standard conversion (4.3) is suppressed on the postfix expression), or it shall have pointer to function type</strong>.</p>\n</blockquote>\n<p><strong>Edit</strong></p>\n<p>Basically what I'm asking is: when the Standard says \"(in which case the function-to-pointer standard conversion is suppressed on the postfix expression)\" does it mean that this suppression is for good or that it will be revoked later (e.g. after function overloading)?</p>\n<p><strong>Edit1</strong></p>\n<p>In my opinion the word \"suppressed\" above is misleading since it gives the impression that the conversion from function name to a function pointer might never be done by the compiler. I believe that's not the case. This conversion will always occur after the function overloading process is finished, since only at this point, the compiler knows exactly which function to call. That's not the case when the program initializes a function pointer. In this situation, the compiler knows the function to be called, so there will be no overloading, as the example below shows.</p>\n<pre><code>#include &lt;iostream&gt;\nint foo(int i) { std::cout &lt;&lt; \"int\" &lt;&lt; '\\n'; return i * i; }\ndouble foo(double d) { std::cout &lt;&lt; \"double\" &lt;&lt; '\\n'; return d * d; }\n\nint main()\n{\n    int(*pf)(int) = foo;                //  no overloading here!\n    std::cout &lt;&lt; pf(10.) &lt;&lt; '\\n';       //  calls foo(int)\n    std::cout &lt;&lt; foo(10.) &lt;&lt; '\\n';      //  call foo(double) after function overloading. Therefore, only after function\n                                        //  overloading is finished, the function name foo() is converted into a function-pointer.\n}\n</code></pre>\n<p>The code prints:</p>\n<blockquote>\n<p id=\"so_22494302_22494302_1\">int<br/>\n  100<br/>\n  double<br/>\n  100</p>\n</blockquote>\n", "Title": "What is the meaning of this statement in the C++11 Standard?", "CreationDate": "2014-03-19T01:11:21.797", "LastActivityDate": "2014-03-19T13:38:56.540", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-03-19T12:58:21.113", "LastEditorUserId": "2548699", "Id": "22494302", "Score": "6", "OwnerUserId": "2548699", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}, "22496341": {"Id": "22496341", "PostTypeId": "2", "Body": "<p>Absent any statement in the Standard to the contrary, the suppression is presumably permanent. I think the conversion is suppressed because (i) overload resolution needs to take place and (ii) it is not necessary in this situation. Indeed, it would be impossible to convert to a pointer before we knew exactly which function is being called. After overload resolution, we know we are directly calling the function, so a conversion would be pointless.</p>\n", "LastActivityDate": "2014-03-19T04:39:51.907", "CommentCount": "0", "CreationDate": "2014-03-19T04:39:51.907", "ParentId": "22494302", "Score": "1", "OwnerUserId": "2673243"}, "22494503": {"Id": "22494503", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_22494302_22494503_0\">For an ordinary function call, the postfix expression shall be either an lvalue that refers to a function (in which case the function-to-pointer standard conversion (4.3) is suppressed on the postfix expression), or it shall have pointer to function type.</p>\n</blockquote>\n<p>So, \"postfix expression\" is defined in 5.2/1... it's a grammatical element that doesn't necessary mean the \"<code>x++</code>\" kind of postfix... have a look at the list itself.  Basically, the point is that there's an expression that:</p>\n<ul>\n<li>\"shall be either an lvalue that refers to a function (in which case the function-to-pointer standard conversion (4.3) is suppressed on the postfix expression)\"</li>\n</ul>\n<p>This means the expression is actually the identifier for a function, or something like <code>(x ? fn1 : fn2)</code>.  It doesn't need to undergo conversion to a pointer - the compiler will already know how to call a function.</p>\n<p>(The reason it's noteworthy that it must not undergo conversion is Operator Precedence - specifically suffixed <code>++</code> and <code>--</code>, <code>()</code> for function calls, <code>[]</code>, <code>.</code>, and <code>-&gt;</code> all have identical precedence and left-to-right associativity, so e.g. <code>[1]f(1,2,3)</code> is treated as <code>[1](f(1,2,3))</code> because it's the only parsing match, whereas if decay to a pointer took place then the left-to-right associativity would treat it as <code>([1]f)(1,2,3)</code>.)</p>\n<ul>\n<li>\" or it shall have pointer to function type.\"</li>\n</ul>\n<p>So, you can also provide a function pointer.</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-03-19T13:38:56.540", "Score": "8", "CreationDate": "2014-03-19T01:30:13.457", "ParentId": "22494302", "CommentCount": "12", "OwnerUserId": "410767", "LastEditDate": "2014-03-19T13:38:56.540"}});