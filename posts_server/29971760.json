post_cb({"29972783": {"Id": "29972783", "PostTypeId": "2", "Body": "<p>Historically, the purpose for making the use of such tokens \"undefined behavior\" is that compilers are free to attach any meaning they want to any such token that are not defined within the C standard.  For example, on some embedded processors, using __xdata as a storage class for a variable will ask that it be stored in an area of RAM which is slower to access than the normal variable-storage area, but is much larger.  On typical processors of that family, storage for \"normal\" variables would be limited to about 100 bytes, but storage for xdata variables may be much larger--up to 64K.  The standard says basically nothing about what compilers are allowed to do with such directives, although typically (I'm not sure if the standard mandates this behavior, though I'm unaware of compilers violating it) such tokens are generally ignored within code that is disabled using a <code>#if</code> or similar directives.</p>\n<p>Some libraries' header files will start their own internal identifiers with something that starts with two underscores but includes a pattern that's unlikely to be used by a compiler for any purpose (e.g. version 23 of the Foozle library might precede its identifiers with use <code>__FZ23</code>).  It would be perfectly legitimate for a future compilers to use identifiers starting with __FZ23 for other purposes, and if that were to happen the Foozle library would need to be changed to use something else.  If, however, it is likely that a major compiler upgrade would likely necessitate rewrites of the Foozle library for other reasons anyway, that risk may be acceptable compared to the risk of identifiers conflicting with outside code.</p>\n<p>Note also that some project header files which are targeted toward a processor that requires <code>__</code> directives may conditionally define macros with those names when compiled for other processors, for example:</p>\n<pre><code>#ifndef USE_XDATA\n#define __XDATA\n#endif\n</code></pre>\n<p>though a somewhat better pattern would generally be:</p>\n<pre><code>#ifdef USE_XDATA\n#define XDATA __XDATA\n#else\n#define XDATA\n#endif\n</code></pre>\n<p>When writing new code, the latter pattern is often better, but the former pattern may sometimes be useful when adapting existing code written on a platform that requires __XDATA so that it may be used both on platforms that use/require that directive and on platforms that do not.</p>\n", "LastEditorUserId": "363751", "LastActivityDate": "2015-04-30T16:33:23.650", "Score": "2", "CreationDate": "2015-04-30T16:13:40.090", "ParentId": "29971760", "CommentCount": "4", "OwnerUserId": "363751", "LastEditDate": "2015-04-30T16:33:23.650"}, "29972267": {"Id": "29972267", "PostTypeId": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1882\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1882</a></p>\n<blockquote>\n<p id=\"so_29971760_29972267_0\">Each identifier that contains a double understore __ or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.</p>\n</blockquote>\n<p><em>any use</em>.  (similar text occurs both before and after that defect fix is applied)</p>\n<p><code>__cplusplus</code> is defined by the standard. <code>_ALGORITHM</code> is reserved by the standard to be used by implementations. These seem quite different?  (The two sections of the standard do conflict, in that one states that <code>__cplusplus</code> is reserved for any use, and another uses it specifically, but I think that the winner of that conflict is clear).</p>\n<p>The <code>_ALGORITHM</code> identifier could, under the standard, be used as part of a pre-processing step to say \"replace this source code with hard drive deleting code\".  Its existence (prior to pre-processing, or after) could be sufficient to completely change your program behavior.</p>\n<p>Now this is unlikely, but I do not think it results in an non-conforming implementation.  It is a matter of quality of implementation only.</p>\n<p>An implementation is free to document and define what <code>_ALGORITHM</code> means.  For example, it could document that it is a header guard for <code>&lt;algorithm&gt;</code>, and indicates if that header file has been included.  Treating your current <code>&lt;algorithm&gt;</code> implementation as documentation is probably going to far.</p>\n<p>I'd guess using <code>__cplusplus</code> in C mode is technically \"just as bad\" as using <code>_ALGORITHM</code>, but this question is a <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> question, not a <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> question.  I haven't delved into the <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> standard to look for quotes about it.</p>\n", "LastActivityDate": "2015-04-30T15:48:05.080", "CommentCount": "13", "CreationDate": "2015-04-30T15:48:05.080", "ParentId": "29971760", "Score": "4", "OwnerUserId": "1774667"}, "29971953": {"Id": "29971953", "PostTypeId": "2", "Body": "<p>Whether it's legal or not is implementation-specific (and identifier-specific).</p>\n<p>When the Standard gives the implementation the sole right to use these names, that includes the right to make the names available in user code.  If an implementation does so, great.</p>\n<p>But if an implementation doesn't expressly give you the right, it is clear from \"shall not be used otherwise\" that the Standard does not, and you have undefined behavior.</p>\n", "LastActivityDate": "2015-04-30T15:34:12.650", "CommentCount": "1", "CreationDate": "2015-04-30T15:34:12.650", "ParentId": "29971760", "Score": "18", "OwnerUserId": "103167"}, "29971970": {"Id": "29971970", "PostTypeId": "2", "Body": "<p>The important part is <strong>\"reserved to the implementation\"</strong>. It means that the compiler vendor may use those names and even document them. Your code may then use those names as documented. This is often used for extensions like <code>__builtin_expect</code>, where the compiler vendor avoids any clash with your identifiers (that are <em>declared</em> by your code) by using those reserved names. Even the standard uses them for things like <code>__attribute__</code> to make sure it doesn't break existing (legal) code when adding new features.</p>\n", "LastActivityDate": "2015-04-30T15:35:10.333", "CommentCount": "2", "CreationDate": "2015-04-30T15:35:10.333", "ParentId": "29971760", "Score": "17", "OwnerUserId": "2073257"}, "bq_ids": {"n4140": {"so_29971760_29972267_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6307}, "so_29971760_29971760_1": {"length": 8, "quality": 0.8, "section_id": 6307}, "so_29971760_29971760_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 5335}}, "n3337": {"so_29971760_29972267_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6064}, "so_29971760_29971760_1": {"length": 8, "quality": 0.8, "section_id": 6064}, "so_29971760_29971760_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 5132}}, "n4659": {"so_29971760_29972267_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6756}, "so_29971760_29971760_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 6756}}}, "29975642": {"Id": "29975642", "PostTypeId": "2", "Body": "<p>Whether or not it is legal is a matter of local law. Whether it means anything, and if so, what, is a matter for the language definition. When you use a name that's reserved to the implementation the behavior of your program is undefined. That means that the language definition does not tell you what the program does. Nothing more, nothing less. If the compiler you're using documents what a particular reserved identifier does, then you can use that identifier with that compiler. If you hunt through headers and guess what various un-documented identifiers mean you might be able to use them, but don't be surprised if your code breaks when a subsequent update changes something.</p>\n<p>Don't get hung up on <code>__cplusplus</code>. It's core language, and the stuff about double underscores, etc. is library. If that's not convincing, just consider it a glitch. You can use <code>__cplusplus</code> in C++ programs; its meaning is well defined.</p>\n", "LastActivityDate": "2015-04-30T18:58:42.003", "CommentCount": "10", "CreationDate": "2015-04-30T18:58:42.003", "ParentId": "29971760", "Score": "0", "OwnerUserId": "1593860"}, "29977405": {"Id": "29977405", "PostTypeId": "2", "Body": "<p>The names in [cpp.predefined] are different. Those have a specified meaning, so an implementation can't reserve them for any use, and using them in a program has a well-defined portable meaning. Using an implementation-specific identifier like the example of _ALGORITHM is ill-formed because it violates a shall-rule. </p>\n<p>Yes, I'm fully aware of multiple examples where the library specification uses \"shall\" to mean \"this is a requirement on user code, and violations are UB, not ill-formed\". </p>\n<p>Regarding whether it's UB or implementation-defined, running an ill-formed program results in UB. The standard wording clearly says the program is ill-formed, UB occurs if the implementation still chooses to accept the program and run it.</p>\n<p>So, if a program uses the identifier _ALGORITHM, that program is ill-formed, and running such a program is UB, but that does not mean it doesn't work fine on an implementation that uses _ALGORITHM as an include guard, nor does it mean that it doesn't work fine on an implementation that doesn't.</p>\n<p>If users are concerned about such ill-formedness and potential UB, and said users want to write portable C++, they shouldn't use reserved identifiers in portable C++ programs. If users accept that regardless of the standard prohibiting such a use, no practical implementation will wipe your hard drive, they can freely use such reserved identifiers, but by the letter of the standard, such uses are still ill-formed.</p>\n", "LastActivityDate": "2015-04-30T20:40:50.723", "CommentCount": "25", "CreationDate": "2015-04-30T20:40:50.723", "ParentId": "29971760", "Score": "4", "OwnerUserId": "1315421"}, "29971760": {"ViewCount": "1960", "Body": "<p>On the <em>std-proposals</em> list, the following code was given:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nvoid foo(const std::vector&lt;int&gt; &amp;v) {\n#ifndef _ALGORITHM\n  std::for_each(v.begin(), v.end(), [](int i){std::cout &lt;&lt; i; }\n#endif\n}\n</code></pre>\n<p>Let's ignore, for the purposes of <em>this</em> question, why that code was given and why it was written that way (as there was a good reason but it's irrelevant here). It supposes that <code>_ALGORITHM</code> is a header guard inside the standard header <code>&lt;algorithm&gt;</code> as shipped with some known standard library implementation. There is no inherent intention of portability here.</p>\n<p>Now, <code>_ALGORITHM</code> would of course be a reserved name, per:</p>\n<blockquote>\n<p id=\"so_29971760_29971760_0\"><code>[C++11: 2.11/3]:</code> In addition, some identifiers are reserved for use by C++ implementations and standard libraries (17.6.4.3.2) and shall not be used otherwise; no diagnostic is required.</p>\n<p id=\"so_29971760_29971760_1\"><code>[C++11: 17.6.4.3.2/1]:</code> Certain sets of names and function signatures are always reserved to the implementation:</p>\n<ul>\n<li>Each name that contains a double underscore <code>_ _</code> or begins with an underscore followed by an uppercase letter (2.12) is reserved to the implementation for any use.</li>\n<li>Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</li>\n</ul>\n</blockquote>\n<p>I was always under the impression that the intent of this passage was to prevent programmers from <em>defining</em>/<em>mutating</em>/<em>undefining</em> names that fall under the above criteria, so that the standard library implementors may use such names without any fear of conflicts with client code.</p>\n<p>But, on the <em>std-proposals</em> list, it was claimed that this code is itself ill-formed for merely referring to such a reserved name. I can now see how the use of the phrase \"shall not be used otherwise\" from <code>[C++11: 2.11/3]:</code> may indeed suggest that.</p>\n<p>One practical rationale given was that the macro <code>_ALGORITHM</code> could expand to some code that wipes your hard drive, for example. However, taking into account the likely intention of the rule, I'd say that such an eventuality has more to do with the obvious implementation-defined* nature of the <code>_ALGORITHM</code> name, and less to do with it being outright illegal to refer to it.</p>\n<p><em>* \"implementation-defined\" in its English language sense, not the C++ standard sense of the phrase</em></p>\n<p>I'd say that, as long as we're happy that we are going to have implementation-defined results and that we should investigate what that macro means on our implementation (if it exists at all!), it should not be inherently illegal to refer to such a macro provided we do not attempt to modify it.</p>\n<p>For example, code such as the following is used <em>all over the place</em> to distinguish between code compiled as C and code compiled as C++:</p>\n<pre><code>#ifdef __cplusplus\nextern \"C\" {\n#endif\n</code></pre>\n<p>and I've never heard a complaint about that.</p>\n<p>So, what do you think? Does \"shall not be used otherwise\" include simply writing such a name? Or is it probably not intended to be so strict (which may point to an opportunity to adjust the standard wording)?</p>\n", "AcceptedAnswerId": "29971953", "Title": "Is it definitely illegal to refer to a reserved name?", "CreationDate": "2015-04-30T15:26:52.033", "Id": "29971760", "CommentCount": "17", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-04-30T15:42:46.677", "LastEditorUserId": "560648", "LastActivityDate": "2015-04-30T20:40:50.723", "Score": "28", "OwnerUserId": "560648", "Tags": "<c++><c++11><language-lawyer><c++14>", "AnswerCount": "6"}});