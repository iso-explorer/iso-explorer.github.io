post_cb({"bq_ids": {"n4140": {"so_28079317_28086248_1": {"length": 14, "quality": 0.875, "section_id": 603}, "so_28079317_28086248_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 571}}, "n3337": {"so_28079317_28086248_1": {"length": 14, "quality": 0.875, "section_id": 593}, "so_28079317_28086248_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 562}}, "n4659": {"so_28079317_28086248_1": {"length": 14, "quality": 0.875, "section_id": 629}, "so_28079317_28086248_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 594}}}, "28079398": {"Id": "28079398", "PostTypeId": "2", "Body": "<p>Function template explicit specializations don't take part in overload resolution. Only function declarations synthesized from primary templates are considered. If one such function is chosen as the best viable function by the overload resolution process, an explicit specialization of the corresponding primary template will be used if suitable.</p>\n<p>In this case, overload resolution needs to choose between a function declaration synthesized from your <code>swap</code> function template overload taking <code>foo&lt;T&gt;&amp;</code> and one synthesized from the <code>std::swap</code> primary template taking <code>T&amp;</code>.</p>\n<p>None of these two functions can be chosen over the other based on conversions (they have the same function parameters), both are template specializations, so partial ordering of function templates is considered, which yields your <code>swap</code> function template as <em>more specialized</em>, so the function declaration synthesized from your <code>swap</code> overload wins.</p>\n", "LastEditorUserId": "4326278", "LastActivityDate": "2015-01-22T01:54:26.143", "Score": "8", "CreationDate": "2015-01-22T00:26:10.390", "ParentId": "28079317", "CommentCount": "4", "OwnerUserId": "4326278", "LastEditDate": "2015-01-22T01:54:26.143"}, "28086248": {"Id": "28086248", "PostTypeId": "2", "Body": "<p>As mentioned in other answers, the reason is that the signature of the\nexplicit function specialization is not taking part in overload\nresolution.</p>\n<p>A simple rule of thumb for explicit specializations is that they change the the definition that will be used when it's primary template is called with the specific template arguments.</p>\n<pre><code>template &lt;typename T&gt; void foo (T) {\n  // definition used for 'foo' when T is not 'int'\n}\n\ntemplate &lt;&gt; void foo&lt;int&gt; (int) {\n  // definition used for 'foo' when T is 'int'\n}\n</code></pre>\n<p>The compiler performs the following steps when selecting the best <code>swap</code> (I'll ignore exception specifications for brevity):</p>\n<pre><code>namespace A\n{\n  template &lt;typename T&gt; struct Foo { };\n\n  template &lt;typename T&gt; void swap (Foo&lt;T&gt; &amp;, Foo&lt;T&gt; &amp;);\n}\n\nnamespace std\n{\n  // swap provided by the STL\n  template &lt;typename T&gt; void swap (T &amp;, T &amp;);\n\n  // explicit specialization of std::swap\n  template &lt;&gt; void swap (Foo&lt;int&gt; &amp;, Foo&lt;intT&gt; &amp;) { }\n}\n</code></pre>\n<p>Specializations of the primary templates are generated for both <code>swaps</code>:</p>\n<blockquote>\n<p id=\"so_28079317_28086248_0\">13.3.1p7: In each case where a candidate is a function template,\n  candidate function template specializations are generated using\n  template argument deduction (14.8.3, 14.8.2). Those candidates are\n  then handled as candidate functions in the usual way.</p>\n</blockquote>\n<p><strong>NB:</strong> The explicit specialization is not part of this.</p>\n<p>For <code>swap(a,b)</code> the <em>candidate set</em> used by overload resolution will\ncontain the following generated function template specializations:</p>\n<pre><code>A::swap(Foo&lt;int&gt;&amp;, Foo&lt;int&gt;)&amp;);\nstd::swap(Foo&lt;int&gt;&amp;, Foo&lt;int&gt;)&amp;);\n</code></pre>\n<p>Both are generated template specializations and both have exactly the same conversion sequences for the arguments so to determine which template to use the following bullet in the Best Viable Function says:</p>\n<blockquote>\n<p id=\"so_28079317_28086248_1\">13.3.3p1b7: F1 and F2 are function template specializations, and the\n  function template for F1 is more specialized than the template for\n  F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>Partial ordering comes down to comparing the function parameter lists to find which is more specialized.  In this example, <code>Foo&lt;T&gt;</code> is more specialized than <code>T</code> and so <code>swap(Foo&lt;T&gt;&amp;, Foo&lt;T&gt;&amp;)</code> is considered a better match than <code>swap(T&amp;,T&amp;)</code>.  The result is that <code>A::swap</code> is selected and so the explicit specialization of <code>std::swap</code> is ignored.</p>\n<p>If the code is changed so the explicit specialization is for <code>A::swap</code> rather than <code>std::swap</code> then as <code>A::swap</code> wins overload resolution, then the explicit specialization will be used:</p>\n<pre><code>namespace A\n{\n  template &lt;typename T&gt; struct Foo { };\n\n  template &lt;typename T&gt; void swap (Foo&lt;T&gt; &amp;, Foo&lt;T&gt; &amp;);\n\n  // explicit specialization of A::swap\n  template &lt;&gt; void swap (Foo&lt;int&gt; &amp;, Foo&lt;intT&gt; &amp;) { }\n}\n</code></pre>\n", "LastActivityDate": "2015-01-22T10:18:08.407", "CommentCount": "1", "CreationDate": "2015-01-22T10:18:08.407", "ParentId": "28079317", "Score": "2", "OwnerUserId": "11698"}, "28079317": {"ViewCount": "277", "Body": "<p>Consider the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt; // std::swap C++98\n#include &lt;utility&gt; // std::swap C++11\n\nnamespace A\n{\ntemplate&lt;typename T&gt;\nstruct Foo {};\n\ntemplate&lt;typename T&gt;\nvoid swap(Foo&lt;T&gt; &amp;lhs, Foo&lt;T&gt; &amp;rhs)\n{\n    std::cout &lt;&lt; \"A::swap&lt;T&gt;\" &lt;&lt; std::endl;\n}\n\n} /* end namespace A */\n\nnamespace std // we explicitly specialize std::swap here\n{\n\ntemplate&lt;&gt; // explicit template specialization for std::swap&lt;int&gt;\nvoid swap(A::Foo&lt;int&gt; &amp;lhs, A::Foo&lt;int&gt; &amp;rhs) \nnoexcept \n(is_nothrow_move_constructible&lt;A::Foo&lt;int&gt;&gt;::value &amp;&amp; is_nothrow_move_assignable&lt;A::Foo&lt;int&gt;&gt;::value)\n{\n    std::cout &lt;&lt; \"std::swap&lt;int&gt;\" &lt;&lt; std::endl;\n} \n\n} /* end namespace std */\n\nint main()\n{\n    using std::swap;\n    A::Foo&lt;int&gt; a, b; \n    A::Foo&lt;double&gt; x, y;\n\n    swap(a, b); // ADL, expected to call std::swap&lt;Foo&lt;int&gt;&gt;, but NO\n    swap(x, y); // ADL, expected to call A::swap&lt;T&gt;, YES\n}\n</code></pre>\n<p>I would expect the <code>std::swap</code> explicit specialization to be a better candidate in the call <code>swap(a, b)</code>, however it seems that the <em>overload</em> <code>A::swap</code> is always preferred, i.e. the output is:</p>\n<blockquote id=\"so_28079317_28079317_0\">\n<pre><code>A::swap&lt;T&gt;\nA::swap&lt;T&gt;\n</code></pre>\n</blockquote>\n<p>Can anyone explain why this behaviour? </p>\n", "AcceptedAnswerId": "28079376", "Title": "why is overload preferred to explicit specialization in ADL", "CreationDate": "2015-01-22T00:16:57.053", "Id": "28079317", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-01-22T12:31:17.903", "Score": "3", "OwnerUserId": "3093378", "Tags": "<c++><templates><c++11><overloading><argument-dependent-lookup>", "AnswerCount": "3"}, "28079376": {"Id": "28079376", "PostTypeId": "2", "Body": "<p>Explicit function template specializations never change which function template or overload is called, only the implementation of the template if it is called.</p>\n<p>Overload resolution ignore specializations (as opposed to overloads, which can look a lot like partial specialization to someone unfamiliar with C++ function template quirks).</p>\n<p>I can imagine why: mixing both overload and template specialization selection rules would make the rules even harder to follow and get right.</p>\n<p>In general, it is rarely a good idea to specialize a function template: overloads, or dispatching to a template class, is usually better.</p>\n<p>Note that the language talks about 'more specialized' in overload resolution: do not confuse this with 'template specialization': they are distinct concepts that unfortunetally share a word.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2015-01-22T12:31:17.903", "Score": "7", "CreationDate": "2015-01-22T00:23:36.517", "ParentId": "28079317", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2015-01-22T12:31:17.903"}});