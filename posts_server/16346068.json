post_cb({"16346171": {"ParentId": "16346068", "CommentCount": "2", "CreationDate": "2013-05-02T19:27:13.650", "OwnerUserId": "2330574", "PostTypeId": "2", "Id": "16346171", "Score": "0", "Body": "<p>I am not sure what exactly you are trying to achieve but as you are allocating memory within scope of function() returning that object. This object goes out of scope once the call to function() returns and hence it can be freed by the compiler. You can face a lot of troubles in later phases. I think you need to redesign the problem solution.</p>\n", "LastActivityDate": "2013-05-02T19:27:13.650"}, "16346662": {"ParentId": "16346068", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-05-02T19:59:08.913", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:29:43.090", "Id": "16346662", "OwnerUserId": "2313258", "Body": "<p>func().k is an lvalue and func().i is an xvalue. </p>\n<p>You can see this for more details:\n<a href=\"https://stackoverflow.com/questions/3007728/rvalues-and-temporary-objects-in-the-fcd\">rvalues and temporary objects in the FCD</a></p>\n<p>Althrough, it is not difficult to test whether they are lvalues or rvalues:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    static int k;\n    int i;\n};\n\nint A::k = 10;\n\nA func( ){ A a; return a; }\n\nvoid f (int &amp; ) { std::cout &lt;&lt; \"int&amp; \" &lt;&lt; std::endl; }\n\nint main ()\n{\n    func().k = 0;  //ok, because func().k is an r\n    f(func().k);\n    func().i = 1; //compile error: \"using temporary as lvalue\"\n    f(func().i);  //compile error because func().i is an rvalue of type \u2018int\u2019\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2013-05-02T19:59:08.913"}, "16346068": {"CommentCount": "7", "AcceptedAnswerId": "16346662", "PostTypeId": "1", "LastEditorUserId": "19563", "CreationDate": "2013-05-02T19:20:22.673", "LastActivityDate": "2014-02-08T14:38:35.030", "LastEditDate": "2013-05-02T20:49:04.530", "ViewCount": "1080", "FavoriteCount": "2", "Title": "How to test lvalue or rvalue in this case", "Id": "16346068", "Score": "2", "Body": "<p>The code is as following:</p>\n<pre><code>struct\u00a0A\n{\n   static\u00a0int\u00a0k;\n\u00a0  int\u00a0i;\n};\n\u00a0\nint\u00a0A::k\u00a0=\u00a010;\n\u00a0\nA\u00a0func() {\u00a0A\u00a0a;\u00a0return\u00a0a;\u00a0}\n</code></pre>\n<p>My question is, how can I tell whether <code>func().k</code> or <code>func().i</code> is an lvalue or not? If both are lvalues/rvalues, how can I test them?</p>\n<pre><code>func().k = 0; // compile ok under g++-4.4 and g++-4.6\nfunc().i = 1; // compile ok with g++-4.4, but g++-4.4 gives an error: \n              //\"using temporary as lvalue [-fpermissive]\"\n</code></pre>\n", "Tags": "<c++><lvalue><rvalue>", "OwnerUserId": "1431641", "AnswerCount": "4"}, "16346322": {"ParentId": "16346068", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-05-02T19:37:01.700", "Score": "2", "LastEditorUserId": "1602696", "LastEditDate": "2014-02-08T14:38:35.030", "Id": "16346322", "OwnerUserId": "1602696", "Body": "<p>There is no need to actually \"test\" whether a given value is an lvalue or an rvalue. </p>\n<p>Etymologically/Historically, an lvalue is what is on the left side of the assigment operator, and an rvalue what is on the right side. (This definition is not exactly correct though.) Note that rvalues can be lvalues.</p>\n<p><strong>Simple rule of thumb: If you can take its address, it's an lvalue.</strong> However, in C++11 there are rvalue references which makes things not <em>that</em> simple. So the rule is more like: if you can take its address using <code>&amp;</code>.</p>\n<p>Maybe some examples will clear things up:</p>\n<pre><code>int a = 5; // a is an lvalue, 5 is an rvalue\nint b = fun(); // fun is an rvalue\nfun() = a; // illegal, can't assign to an rvalue (suppose foo returns int)\n</code></pre>\n<p>See <a href=\"http://en.wikipedia.org/wiki/Value_%28computer_science%29\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Value_%28computer_science%29</a> for more.</p>\n", "LastActivityDate": "2014-02-08T14:38:35.030"}, "16347248": {"ParentId": "16346068", "CommentCount": "0", "CreationDate": "2013-05-02T20:35:49.023", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "16347248", "Score": "2", "Body": "<p>\"Assignability\" isn't a good test for <em>lvalueness</em> as we can have non-mutable <em>lvalues</em> (e.g. const reference expressions) and assignment may be a member function call which can be made on an <em>rvalue</em> of class type.</p>\n<p>You have to refer to the standard (ISO/IEC 14882:2011).</p>\n<blockquote>\n<p id=\"so_16346068_16347248_0\">5.2.2/10: A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n<p>So <code>func()</code> is a <em>prvalue</em>.</p>\n<blockquote>\n<p id=\"so_16346068_16347248_1\">5.2.5/4:  If <code>E2</code> is declared to have type \"reference to <code>T</code>,\" then <code>E1.E2</code> is an lvalue; the type of <code>E1.E2</code> is <code>T</code>. Otherwise, one of the following rules applies.</p>\n<ul>\n<li>If <code>E2</code> is a static data member and the type of <code>E2</code> is <code>T</code>, then <code>E1.E2</code> is an lvalue; the expression designates the named member of the class. The type of <code>E1.E2</code> is T`.</li>\n</ul>\n</blockquote>\n<p>So <code>func().k</code> is an <em>lvalue</em>.</p>\n<blockquote id=\"so_16346068_16347248_2\">\n<ul>\n<li>If <code>E2</code> is a non-static data member and the type of <code>E1</code> is \"<em>cq1 vq1</em> <code>X</code>\", and the type of <code>E2</code> is \"<em>cq2 vq2</em> <code>T</code>\", the expression designates the named member of the object designated by the first expression. If <code>E1</code> is an lvalue, then <code>E1.E2</code> is an lvalue; if <code>E1</code> is an xvalue, then <code>E1.E2</code> is an xvalue; otherwise, it is a prvalue. [...]</li>\n</ul>\n</blockquote>\n<p>So <code>func().i</code> is a <em>prvalue</em>.</p>\n", "LastActivityDate": "2013-05-02T20:35:49.023"}, "bq_ids": {"n4140": {"so_16346068_16347248_2": {"section_id": 6007, "quality": 0.8518518518518519, "length": 23}, "so_16346068_16347248_1": {"section_id": 6007, "quality": 0.9333333333333333, "length": 14}, "so_16346068_16347248_0": {"section_id": 5997, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_16346068_16347248_2": {"section_id": 5775, "quality": 0.9259259259259259, "length": 25}, "so_16346068_16347248_1": {"section_id": 5775, "quality": 0.9333333333333333, "length": 14}, "so_16346068_16347248_0": {"section_id": 5765, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_16346068_16347248_2": {"section_id": 7506, "quality": 0.8518518518518519, "length": 23}, "so_16346068_16347248_1": {"section_id": 7506, "quality": 0.9333333333333333, "length": 14}, "so_16346068_16347248_0": {"section_id": 7498, "quality": 0.9545454545454546, "length": 21}}}});