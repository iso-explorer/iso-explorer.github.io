post_cb({"37873303": {"CommentCount": "3", "ViewCount": "60", "PostTypeId": "1", "LastEditorUserId": "3299580", "CreationDate": "2016-06-17T04:45:36.583", "LastActivityDate": "2016-06-17T11:30:02.513", "Title": "get succesor Binary Search Tree c++ Data structure", "AcceptedAnswerId": "37878471", "LastEditDate": "2016-06-17T04:55:23.050", "Id": "37873303", "Score": "0", "Body": "<p>I have binary search tree and i want get successor of it's elements i see that my code is fine but i don't know what's wrong 115 is run time error and 5 is 5 and it should be 6 </p>\n<pre><code>    #include&lt;bits/stdc++.h&gt;\n    using namespace std;\n\n    struct Node\n    {\n        int data;\n        Node *root;\n        Node *left;\n        Node *right;\n\n    };\n\n    typedef Node *ptr;\n\n     ptr search(ptr tree,int key)\n    {\n        if(tree==NULL)return tree;\n        if(tree-&gt;data==key)\n            return tree;\n        else if(tree-&gt;data&gt;key)\n            search(tree-&gt;right,key);\n        else search(tree-&gt;left,key);\n    }\n\n    ptr most_left(ptr tree)\n    {\n        ptr result=tree;\n        if(tree==NULL)return NULL;\n        while(result-&gt;left!=NULL)\n            result=result-&gt;left;\n        return result;\n    }\n\n    ptr most_right(ptr tree)\n    {\n        ptr result=tree;\n        if(tree==NULL)return NULL;\n        while(result-&gt;right!=NULL)\n            result=result-&gt;right;\n        return result;\n    }\n\n    ptr min_element(ptr tree)\n    {\n        ptr result=tree;\n        if(tree==NULL)return NULL;\n        while(result-&gt;left!=NULL)\n            result=result-&gt;left;\n        return result;\n    }\n\n    ptr max_element(ptr tree)\n    {\n        ptr result=tree;\n        if(tree==NULL)return NULL;\n        while(result-&gt;right!=NULL)\n            result=result-&gt;right;\n        return result;\n    }\n    ptr temp=NULL;\n    ptr insert_element(ptr &amp;tree,int key)\n    {\n\n        if(tree==NULL)\n        {\n        tree=new Node();\n        tree-&gt;data=key;\n        tree-&gt;root=temp;\n        return tree;\n        }\n        else if(tree-&gt;data&gt;=key)\n        {\n        temp=tree;  \n        insert_element(tree-&gt;left,key);\n        }\n        else \n        {\n            temp=tree;\n            insert_element(tree-&gt;right,key);\n        }\n\n    }\n\n    void in_order(ptr tree)\n    {\n        if(tree == NULL) return;\n        in_order(tree-&gt;left);\n        cout&lt;&lt;tree-&gt;data&lt;&lt;\" \";\n        in_order(tree-&gt;right);\n    }\n\n    void pre_order(ptr tree)\n    {\n        if(tree == NULL) return;\n\n        cout&lt;&lt;tree-&gt;data&lt;&lt;\" \";\n        pre_order(tree-&gt;left);\n        pre_order(tree-&gt;right);\n    }\n\n    void post_order(ptr tree)\n    {\n        if(tree == NULL) return;\n        post_order(tree-&gt;left);\n        post_order(tree-&gt;right);\n        cout&lt;&lt;tree-&gt;data&lt;&lt;\" \";\n    }\n\n    ptr succesor(ptr node)\n    {\n        if(node-&gt;right != NULL) return min_element(node-&gt;right);\n         ptr y = node-&gt;root;\n        while(y != NULL &amp;&amp; node == y-&gt;right ) {\n            node = y;\n            y = y-&gt;root;\n\n        }\n        return y;\n    }\n\n    int main() \n    {   \n        ptr tree = NULL;\n        insert_element(tree,7);\n        insert_element(tree,5);\n        insert_element(tree,55);\n        insert_element(tree,6);\n        insert_element(tree,15);\n        insert_element(tree,60);\n        insert_element(tree,10);\n        insert_element(tree,115);\n        ptr inserted = insert_element(tree,5);\n        insert_element(tree,6);\n        insert_element(tree,12);\n        cout&lt;&lt;\"succesor \"&lt;&lt;succesor(inserted)-&gt;data;\n        cout&lt;&lt;\"\\nData Inserted \\n\"&lt;&lt;\"In order : \";\n        in_order(tree);\n        cout&lt;&lt;endl;\n        cout&lt;&lt;\"Pre order : \";\n        pre_order(tree);\n        cout&lt;&lt;endl;\n        cout&lt;&lt;\"Post order : \";\n        post_order(tree);\n        cout&lt;&lt;endl;\n        cout&lt;&lt;\"Minimum : \"&lt;&lt;min_element(tree)-&gt;data&lt;&lt;endl;\n        cout&lt;&lt;\"Maximum : \"&lt;&lt;max_element(tree)-&gt;data&lt;&lt;endl;\n        return 0;\n    }\n</code></pre>\n", "Tags": "<c++><data-structures><tree><binary-search-tree>", "OwnerUserId": "6261602", "AnswerCount": "1"}, "37878471": {"ParentId": "37873303", "PostTypeId": "2", "CommentCount": "1", "Body": "<ol>\n<li><p>\"5 should be 6\"<br>\nNo, the program is absolutely right.<br>\nIn the <code>insert_element</code> function you check for <code>tree-&gt;data &gt;= key</code> (notice the <strong>&gt;=</strong>), so if there is already an element with the same data as the key to be inserted, the new key will be inserted into the left subtree. This is why the successor of the last inserted 5 ist the previous inserted 5. If you replace <code>&gt;=</code> with <code>&gt;</code> the second 5 will be inserted into the right subtree, so its successor is 6 as expected.</br></br></p></li>\n<li><p>runtime error for successor of 115<br>\nOf course, there is no successor of 115 because this is the greatest value. So the succesor function returns a NULL pointer which, if dereferenced, leads to undefined behavior.</br></p></li>\n</ol>\n<p>By the way, the program has more undefined behavior. The functions <code>search</code> and <code>insert_element</code> may flow off the end of the functions without returning a value. The standard says:</p>\n<blockquote>\n<p id=\"so_37873303_37878471_0\">Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function. (6.6.3)</p>\n</blockquote>\n<p>In this case you are lucky because in most implementations the location where return values are stored keeps its value from the return statement of the recursive calls, but, of course, this should be fixed.</p>\n", "OwnerUserId": "6478742", "LastEditorUserId": "3982001", "LastEditDate": "2016-06-17T11:30:02.513", "Id": "37878471", "Score": "2", "CreationDate": "2016-06-17T09:52:03.273", "LastActivityDate": "2016-06-17T11:30:02.513"}, "bq_ids": {"n4140": {"so_37873303_37878471_0": {"section_id": 3913, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_37873303_37878471_0": {"section_id": 3773, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_37873303_37878471_0": {"section_id": 4799, "quality": 0.6923076923076923, "length": 9}}}});