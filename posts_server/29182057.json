post_cb({"bq_ids": {"n4140": {"so_29182057_29182379_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 3354}, "so_29182057_29182379_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 3345}, "so_29182057_29182379_0": {"length": 22, "quality": 0.9166666666666666, "section_id": 3343}}, "n3337": {"so_29182057_29182379_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 3224}, "so_29182057_29182379_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 3213}, "so_29182057_29182379_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 3215}}, "n4659": {"so_29182057_29182379_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 4121}, "so_29182057_29182379_0": {"length": 15, "quality": 0.625, "section_id": 4109}}}, "29182379": {"Id": "29182379", "PostTypeId": "2", "Body": "<p>In your case, yes there is a memory leak (not that it matters much, since the program will terminate immediately and the OS will reclaim the memory).</p>\n<p>To unerstand this, you need to be aware that stack unwinding (that is, destroying local variables when going up the call stack) is only guaranteed by the standard <em>if the exception is caught.</em> If the exception is never caught and goes straight to <code>std::terminate</code>, whether or not unwinding happens is up to the compiler &amp; standard library.</p>\n<p>Quoting C++11:</p>\n<p>15.2:</p>\n<blockquote>\n<p id=\"so_29182057_29182379_0\">1 As control passes from a <em>throw-expression</em> to a handler, destructors are invoked for all automatic objects\n  constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the\n  completion of their construction.</p>\n<p id=\"so_29182057_29182379_1\">3 The process of calling destructors for automatic objects constructed on the path from a try block to a\n  <em>throw-expression</em> is called <em>\u201cstack unwinding.\u201d</em> ...</p>\n</blockquote>\n<p>15.3:</p>\n<blockquote>\n<p id=\"so_29182057_29182379_2\">9 If no matching handler is found, the function <code>std::terminate()</code> is called; whether or not the stack is\n  unwound before this call to <code>std::terminate()</code> is implementation-defined (15.5.1).</p>\n</blockquote>\n", "LastActivityDate": "2015-03-21T11:51:55.920", "CommentCount": "2", "CreationDate": "2015-03-21T11:51:55.920", "ParentId": "29182057", "Score": "1", "OwnerUserId": "1782465"}, "29182057": {"ViewCount": "216", "Body": "<p>I tested C++11 shared_ptr, and was surprised\nIn this example</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;exception&gt;\n\nusing namespace std;\n\nclass MyExc\n{\n\n};\n\nclass Slot\n{\npublic:\n    Slot(const std::string &amp;str = \"NONAME\") : m_name(str)\n    {\n        cout &lt;&lt; \"Constructor of slot: \" &lt;&lt; m_name &lt;&lt; endl;\n    }\n\n    virtual ~Slot()\n    {\n        cout &lt;&lt; \"Destructor of slot: \" &lt;&lt; m_name &lt;&lt; endl;\n    }\n\n    void sayName()\n    {\n        cout &lt;&lt; \"Slot name is: \" &lt;&lt; m_name &lt;&lt; endl;\n//       throw MyExc();\n    }\n\nprivate:\n    string m_name;\n};\n\n\nvoid testShared(shared_ptr&lt;Slot&gt; &amp; m_share)\n{\n    m_share-&gt;sayName();\n}\n\nint main()\n{\n    vector&lt;shared_ptr&lt;Slot&gt;&gt; vec {make_shared&lt;Slot&gt;(\"0\"), make_shared&lt;Slot&gt;(\"1\"), make_shared&lt;Slot&gt;(\"2\"), make_shared&lt;Slot&gt;(\"3\"), make_shared&lt;Slot&gt;(\"4\")};\n    for (auto&amp; x:vec)\n        testShared(x);\n\n\n    return 0;\n}\n</code></pre>\n<p>I see right output  </p>\n<p>Constructor of slot: 0<br>\nConstructor of slot: 1<br>\nConstructor of slot: 2<br>\nConstructor of slot: 3<br>\nConstructor of slot: 4<br>\nSlot name is: 0<br>\nSlot name is: 1<br>\nSlot name is: 2<br>\nSlot name is: 3<br>\nSlot name is: 4<br>\nDestructor of slot: 0<br>\nDestructor of slot: 1<br>\nDestructor of slot: 2<br>\nDestructor of slot: 3<br>\nDestructor of slot: 4 </br></br></br></br></br></br></br></br></br></br></br></br></br></br></p>\n<p>But if I uncomment line</p>\n<pre><code>throw MyExc();\n</code></pre>\n<p>output has changed, and destructor calling message didn't show</p>\n<p>terminate called after throwing an instance of 'MyExc'\nConstructor of slot: 0<br>\nConstructor of slot: 1<br>\nConstructor of slot: 2<br>\nConstructor of slot: 3<br>\nConstructor of slot: 4<br>\nSlot name is: 0  </br></br></br></br></br></p>\n<p>Does it mean that memory leak is placed here?</p>\n", "Title": "Why shared_ptr doesn't call a destructor of a pointer when exception occured", "CreationDate": "2015-03-21T11:14:46.107", "LastActivityDate": "2015-03-21T11:51:55.920", "CommentCount": "0", "PostTypeId": "1", "Id": "29182057", "Score": "1", "OwnerUserId": "4696976", "Tags": "<c++11><shared-ptr>", "AnswerCount": "1"}});