post_cb({"6538950": {"ParentId": "6538632", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-06-30T17:51:17.780", "Score": "0", "LastEditorUserId": "774499", "LastEditDate": "2011-06-30T18:13:42.983", "Id": "6538950", "OwnerUserId": "774499", "Body": "<p>That reinterpret_cast generates a reference with unspecified behavior. Don't do that! Use const_iterators.</p>\n<pre><code>class A {\npublic:\n  typedef std::map&lt;int, float*&gt; MapType;\n  typedef MapType::const_iterator const_iterator;\n\n  const_iterator begin () const { return m_Map.begin(); }\n\n  const_iterator end () const { return m_Map.end(); }\n\nprivate:\n  std::map&lt;int, float*&gt; m_Map;\n};\n\n\nvoid some_function () {\n  A my_map;\n\n  // Code to build the map elided\n\n  for (A::const_iterator iter = my_map.begin(); iter &lt; my_map.end(); ++iter) {\n    do_something_with_but_not_to (*iter);\n  }\n</code></pre>\n<p>Note that you can also export things such as find that return a const_iterator.</p>\n", "LastActivityDate": "2011-06-30T18:13:42.983"}, "13571624": {"ParentId": "6538632", "CommentCount": "0", "CreationDate": "2012-11-26T19:22:23.697", "OwnerUserId": "455304", "PostTypeId": "2", "Id": "13571624", "Score": "0", "Body": "<p>One good reason why it might cause trouble: Even if binary implementation is usually the same (and it usually is, but who knows), then types are still different. Some containers might use some static (or TLS now in C++11) fields (eg. for optimizations/debugging purposes), and those must be different for different types.</p>\n<p>Imagine, that such a field would be a (null-initialized) pointer, that is given some significant value in constructor (if not assigned already). As long as no object of this type are constructed it's safe to assume that nobody will deference it, and after first constructor call, it's OK to deference it without checking if it's non-null. Your code can produce container that was never constructed, but it's methods deference internal pointer, leading to difficult to track segfault.</p>\n", "LastActivityDate": "2012-11-26T19:22:23.697"}, "6538632": {"CommentCount": "2", "ViewCount": "1621", "PostTypeId": "1", "LastEditorUserId": "823513", "CreationDate": "2011-06-30T17:21:44.560", "LastActivityDate": "2012-11-26T19:22:23.697", "Title": "How to expose a map of pointers as a map of const pointers?", "AcceptedAnswerId": "6538690", "LastEditDate": "2011-06-30T17:51:38.170", "Id": "6538632", "Score": "5", "Body": "<p>I have a class with an std::map of pointers as a member. Now, I'd like to expose that member in a read only fashion: modification is not allowed for neither the map, nor the objects pointed to. Internally I need those pointers to be non-const, and I want to expose them as const.</p>\n<p>I do have a solution that compiles at least, but I'd like to know if there's any hidden problems I'll run into with this.</p>\n<pre><code>class A\n{\npublic:\n  const std::map&lt;int, const float*&gt;&amp; GetMap() const { return *(reinterpret_cast&lt; const std::map&lt;int, const float*&gt;* &gt;( &amp;m_Map)); }\n\nprivate:\n  std::map&lt;int, float*&gt; m_Map;\n};\n</code></pre>\n<p>There's a possible problem I can think of: if the internal layout of std::map is different for maps of pointers and maps of const pointers, then this will cause ugly bugs. But I cannot think of any sane reason why that would be the case. Anybody has any idea?</p>\n<p>To clarify: I am aware that this is a hack, and there are safer solutions (like separate accessor functions). I am just wondering if this would break right away because of some piece of information I'm missing.</p>\n", "Tags": "<c++><pointers><stl><map><const>", "OwnerUserId": "823513", "AnswerCount": "4"}, "6538690": {"ParentId": "6538632", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2011-06-30T17:26:47.357", "Score": "9", "LastEditorUserId": "251738", "LastEditDate": "2011-06-30T17:59:01.013", "Id": "6538690", "OwnerUserId": "251738", "Body": "<p>This is of course undefined (EDIT: it looks like it's actually only unspecified) behavior because the two maps are (from the language point of view) totally unrelated types. It may appear to work now but sometime it's going to break and cause a ton of headaches.</p>\n<p>Did you consider that instead of exposing an implementation detail (that you're using map internally) you could provide <code>const_iterator</code>s and a <code>find</code> method for your class's public interface instead?</p>\n<p>EDIT:\nSee 5.2.10/7:</p>\n<blockquote>\n<p id=\"so_6538632_6538690_0\">A pointer to an object can be\n  explicitly converted to a pointer to\n  an object of different type. 65) Except\n  that converting an rvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer\n  to T2\u201d (where T1 and T2 are object\n  types and where the alignment\n  requirements of T2 are no stricter\n  than those of T1) and back to its\n  original type yields the original\n  pointer value, the result of such a\n  pointer conversion is unspecified.</p>\n</blockquote>\n<p>From that quote we conclude that casting from the map with non-const value type to the map with const value type has unspecified behavior. Further, actually dereferencing the converted pointer would probably violate the strict aliasing rules and result in undefined behavior.</p>\n", "LastActivityDate": "2011-06-30T17:59:01.013"}, "bq_ids": {"n4140": {"so_6538632_6538690_0": {"section_id": 6045, "quality": 0.7368421052631579, "length": 28}}, "n3337": {"so_6538632_6538690_0": {"section_id": 5814, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_6538632_6538690_0": {"section_id": 7544, "quality": 0.7368421052631579, "length": 28}}}, "6538760": {"ParentId": "6538632", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-06-30T17:32:43.833", "Score": "1", "LastEditorUserId": "212870", "LastEditDate": "2011-06-30T20:27:43.127", "Id": "6538760", "OwnerUserId": "212870", "Body": "<p>You could hold it as a map&lt;int, const float *&gt; and const_cast internally when you need to. This is ugly but legal (as long as you know that all the values pointed to really aren't const). </p>\n<p>At least it doesn't involve Undefined Behaviour which I'm pretty certain your solution does. Although as you say it will probably work most of the time on most platforms.</p>\n", "LastActivityDate": "2011-06-30T20:27:43.127"}});