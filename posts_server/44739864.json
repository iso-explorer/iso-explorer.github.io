post_cb({"bq_ids": {"n4140": {"so_44739864_44740285_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5908}, "so_44739864_44740285_2": {"length": 9, "quality": 0.6, "section_id": 5908}}, "n3337": {"so_44739864_44740285_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 5680}, "so_44739864_44740285_2": {"length": 9, "quality": 0.6, "section_id": 5680}}, "n4659": {"so_44739864_44740285_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 7390}, "so_44739864_44740285_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 7390}}}, "44739864": {"ViewCount": "86", "Body": "<p>Consider following example:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f (T t) {\n    std::cout &lt;&lt; t &lt;&lt; std::endl;\n}\n\n\ntemplate &lt;typename T&gt;\nstruct F { \n    static constexpr void (*m) (T) = &amp;f; \n};\n</code></pre>\n<p>and usage:</p>\n<pre><code>F&lt;int&gt;::m (10);\n</code></pre>\n<p>So far, so good. Problem shows up when I want to store pointer to function template which takes for example an lambda expression. Consider this one:</p>\n<pre><code>template &lt;typename T, typename C&gt;\nvoid g (T t, C c) {\n    std::cout &lt;&lt; c (t) &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename T, typename C&gt;\nstruct G { \n    static constexpr void (*m) (T, C) = &amp;g; \n}; \n</code></pre>\n<p>and usage:</p>\n<pre><code>auto l = [] (auto v) { return v; };\nG&lt;int, decltype (l)&gt;::m (20, l); \n</code></pre>\n<p>When compiling on GCC 5.3.1 with:</p>\n<pre><code>g++-5 -std=c++14 -Wall -Wextra -Wpedantic -Werror=return-type main.cpp -o main\n</code></pre>\n<p>I got:</p>\n<pre><code>\u2018constexpr void (* const G&lt;int, main(int, char**)::&lt;lambda(auto:1)&gt; &gt;::m)(int, main(int, char**)::&lt;lambda(auto:1)&gt;)\u2019, declared using local type \u2018main(int, char**)::&lt;lambda(auto:1)&gt;\u2019, is used but never defined [-fpermissive]\n</code></pre>\n<p><strong>Why this happens?</strong></p>\n<p><strong>Is there any way I can achieve this code to work?</strong> </p>\n<p>One possible solution that I am not interested in:</p>\n<pre><code>struct O { \n    template &lt;typename T&gt;\n    T operator() (T v) {\n        return v;\n    }   \n};\n</code></pre>\n<p>with usage:</p>\n<pre><code>G&lt;int, O&gt;::m (20, O {});\n</code></pre>\n", "AcceptedAnswerId": "44740285", "Title": "How to store pointer to function template which takes Callable object as one of its parameters", "CreationDate": "2017-06-24T18:52:14.450", "Id": "44739864", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-06-24T19:45:40.917", "Score": "1", "OwnerUserId": "3671410", "Tags": "<c++><c++14>", "AnswerCount": "1"}, "44740285": {"Id": "44740285", "PostTypeId": "2", "Body": "<p>The error, if you remove some stuff, says:</p>\n<blockquote>\n<p id=\"so_44739864_44740285_0\">[...] <code>m</code> [...] is used but never defined [-fpermissive]</p>\n</blockquote>\n<p>So just follow the compiler's orders, and define it:</p>\n<pre><code>template &lt;class T, class C&gt;\nconstexpr void (*G&lt;T,C&gt;::m)(T,C);\n</code></pre>\n<p>And now it works. This is because in C++14, you are required to add a definition for static constexpr data members, from <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]</a>:</p>\n<blockquote>\n<p id=\"so_44739864_44740285_1\">The [static data] member shall still be defined in a namespace scope if it is odr-used ([basic.def.odr]) in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<hr/>\n<p>This is no longer necessary in C++17 for <code>constexpr</code> static data members, as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf\" rel=\"nofollow noreferrer\">p0386</a>. The text <a href=\"http://eel.is/c++draft/class.static.data#3.sentence-4\" rel=\"nofollow noreferrer\">now reads</a>:</p>\n<blockquote>\n<p id=\"so_44739864_44740285_2\">If the [static data] member is declared with the <code>constexpr</code> specifier, it <strong>may be</strong> redeclared in namespace scope with no initializer (this usage is deprecated; see [depr.static_constexpr]).</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-06-24T19:45:40.917", "Score": "3", "CreationDate": "2017-06-24T19:39:06.430", "ParentId": "44739864", "CommentCount": "7", "OwnerUserId": "2069064", "LastEditDate": "2017-06-24T19:45:40.917"}});