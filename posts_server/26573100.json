post_cb({"26573207": {"Id": "26573207", "PostTypeId": "2", "Body": "<p>That is standard behavior. Any other behavior would lead to crazy behavior. In particular, the non-const function would not be callable at all.</p>\n", "LastActivityDate": "2014-10-26T12:56:26.293", "CommentCount": "0", "CreationDate": "2014-10-26T12:56:26.293", "ParentId": "26573100", "Score": "1", "OwnerUserId": "874660"}, "26573202": {"Id": "26573202", "PostTypeId": "2", "Body": "<p>Reference bindings are an identity category <em>\u00a713.3.3.1.4</em>) but since the latter is more cv-qualified, for \u00a713.3.3.2, the non-const is preferred (sample code from the standard):</p>\n<pre><code>int f(const int &amp;);\nint f(int &amp;);\n\nint i;\nint j = f(i); // calls f(int &amp;)\n</code></pre>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2014-10-26T13:10:27.027", "Score": "3", "CreationDate": "2014-10-26T12:56:05.503", "ParentId": "26573100", "CommentCount": "0", "OwnerUserId": "1938163", "LastEditDate": "2014-10-26T13:10:27.027"}, "26573125": {"Id": "26573125", "PostTypeId": "2", "Body": "<p>Because calling the function taking <code>std::string const&amp;</code> requires two implicit conversions: one to <code>std::string const</code>, one to <code>std::string const&amp;</code>; whereas calling the function taking <code>std::string&amp;</code> requires merely one implicit conversion (to <code>std::string&amp;</code>), so that one is preferred.</p>\n", "LastActivityDate": "2014-10-26T12:48:18.520", "CommentCount": "7", "CreationDate": "2014-10-26T12:48:18.520", "ParentId": "26573100", "Score": "0", "OwnerUserId": "1804599"}, "26573271": {"Id": "26573271", "PostTypeId": "2", "Body": "<p>The reason is this section in [over.ics.rank]/3 where this case is explicitly covered:</p>\n<blockquote>\n<p id=\"so_26573100_26573271_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than\n  standard conversion sequence <code>S2</code> if <br> [\u2026] <br> \u2014 <code>S1</code> and <code>S2</code> are reference\n  bindings (8.5.3), and the types to which the references refer are the\n  same type except for top-level cv-qualifiers, and the type to which\n  the reference initialized by <code>S2</code> refers is more cv-qualified than the\n  type to which the reference initialized by <code>S1</code> refers.</br></br></p>\n</blockquote>\n<p><code>S1</code> corresponds to the second overload and <code>S2</code> to the first. </p>\n<blockquote>\n<p id=\"so_26573100_26573271_1\">What the reason it calls the function without <code>const</code></p>\n</blockquote>\n<p>You always try to select the most specialized thing. That is the case in overload resolution just as it is in partial ordering of function templates. The second overload is more specialized than the first because the first can be called with arguments which the second cannot be called with - that is the basic reasoning behind this rule.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-10-26T13:11:24.150", "Score": "1", "CreationDate": "2014-10-26T13:03:40.827", "ParentId": "26573100", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-10-26T13:11:24.150"}, "26573100": {"ViewCount": "81", "Body": "<p>I'm working on g++ and here I have tried to overload a function by just adding <code>const</code> to parameter. It works fine and when it runs, it calls the function without <code>const</code></p>\n<ol>\n<li>Is this behavior specified in the C++ standard? </li>\n<li><p>What the reason it calls the function without <code>const</code></p>\n<pre><code>void print(const std::string&amp; str){std::cout &lt;&lt; \"const\" &lt;&lt; str &lt;&lt; std::endl;}\n\nvoid print(std::string&amp; str){std::cout &lt;&lt; str &lt;&lt; std::endl;}\n\nint main()\n{\n   std::string temp = \"hello\";\n   print(temp);\n   return 0;\n}\n</code></pre></li>\n</ol>\n", "Title": "Behavior of function overloading with const", "CreationDate": "2014-10-26T12:44:11.130", "LastActivityDate": "2014-10-26T13:46:22.750", "CommentCount": "4", "LastEditDate": "2014-10-26T12:59:12.307", "PostTypeId": "1", "LastEditorUserId": "1938163", "Id": "26573100", "Score": "3", "OwnerUserId": "1268258", "Tags": "<c++><function-overloading>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_26573100_26573271_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 639}}, "n3337": {"so_26573100_26573271_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 629}}, "n4659": {"so_26573100_26573271_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 667}}}, "26573530": {"Id": "26573530", "PostTypeId": "2", "Body": "<p>Overloading works by matching the types of the arguments, including the qualifiers.  In your case <code>temp</code> has type <code>std::string</code> not <code>const std::string</code>.  You have only initialised it with a literal constant, it is not itself constant.</p>\n<p>Consider the following:</p>\n<pre><code>std::string temp( \"hello\" ) ;\nprint(temp);                                    // hello   \nprint( std::string(\"hello\") ) ;                 // consthello\nprint( \"hello\" ) ;                              // consthello\nprint( static_cast&lt;const std::string&gt;(temp) ) ; // consthello\n\nconst std::string temp2( \"hello\" ) ;\nprint(temp2);                                    // consthello   \n</code></pre>\n<p>If you were to remove the non-const version, all three will call the remaining const overload.  In this example, only the const version is in fact necessary (and preferred) since neither version modify the string object. </p>\n<p>If on the other hand you removed the non-const version, there would be no function matching any but the first example above, and the build would fail.  That is to say a non-const object can safely be passed as a const argument, but a const object cannot be passed as a non-const argument, because the function is not \"promising\" not to modify the object.  You can force a const into a non-const argument by a <code>const_cast</code> as in:</p>\n<pre><code>const std::string temp2(\"hello\") ;\nprint( const_cast&lt;std::string&amp;&gt;(temp2) ) ;    // hello\n</code></pre>\n<p>But if <code>print()</code> were to attempt to modify the object in this case the results are <em>undefined</em>, so consider the practice unsafe.</p>\n<p>Making an argument const indicates intent, allows the compiler to issue a diagnostic if the code is attempts to modify the object or pass it via a non-const argument to some other function. It may also potentially provide the compiler with optimisation possibilities.</p>\n", "LastEditorUserId": "168986", "LastActivityDate": "2014-10-26T13:46:22.750", "Score": "1", "CreationDate": "2014-10-26T13:31:49.993", "ParentId": "26573100", "CommentCount": "0", "OwnerUserId": "168986", "LastEditDate": "2014-10-26T13:46:22.750"}, "26573265": {"Id": "26573265", "PostTypeId": "2", "Body": "<p>const is part of method signature. Overriding works only for methods with the same signature. \nThis behavior was made to avoid reverse situation when you use const method of base class to call not const method of child class.</p>\n", "LastActivityDate": "2014-10-26T13:03:12.307", "CommentCount": "0", "CreationDate": "2014-10-26T13:03:12.307", "ParentId": "26573100", "Score": "1", "OwnerUserId": "4156374"}});