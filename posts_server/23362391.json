post_cb({"23430144": {"Id": "23430144", "PostTypeId": "2", "Body": "<p><strong>Edit</strong>: This answer only works because of a bug in GCC 4.8.1</p>\n<hr>\n<p>Your code works as expected if you drop the keyword <code>template</code> in your specialization:</p>\n<pre><code>template &lt;typename String, template&lt;class&gt; class Allocator, typename T&gt;\nstruct get_data_object_value\n{\n    void foo() { std::cout &lt;&lt; \"general\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename String, template&lt;class&gt; class Allocator, typename T&gt;\nstruct get_data_object_value\n&lt;String, Allocator,\ntypename basic_data_object&lt;String, Allocator&gt;::array_container&lt;T&gt;&gt;\n//                                         ^^^^^^ no template!\n{\n    void foo() { std::cout &lt;&lt; \"special\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>Example tested with GCC 4.8.1:</p>\n<pre><code>int main()  {\n    get_data_object_value&lt;std::string,std::allocator,std::vector&lt;int&gt;&gt; obj;\n    obj.foo(); // prints \"special\"\n}\n</code></pre>\n</hr>", "LastEditorUserId": "316448", "LastActivityDate": "2014-05-02T15:54:20.647", "Score": "1", "CreationDate": "2014-05-02T14:08:25.473", "ParentId": "23362391", "CommentCount": "12", "OwnerUserId": "316448", "LastEditDate": "2014-05-02T15:54:20.647"}, "23442613": {"Id": "23442613", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23362391_23442613_0\">Alternatively what is the best (smallest / cleanest) way to make this work?</p>\n</blockquote>\n<p>Arguably, it is:</p>\n<ul>\n<li>Write a SFINAE trait template <code>Tr&lt;String,Allocator,T&gt;</code> that determines whether <code>T</code> is the\nsame as <code>basic_data_object&lt;String,Allocator&gt;::array_container&lt;T::E&gt;</code>\nfor some type <code>E</code> - <em>if such there be</em> - that is <code>T::value_type</code>.</li>\n<li>Provide template <code>get_data_object_value</code> with a 4th parameter\ndefaulting to <code>Tr&lt;String,Allocator,T&gt;::value</code></li>\n<li>Write partial specializations of <code>get_data_object_value</code> instantiating that\n4th parameter as <code>true</code>, <code>false</code> respectively.</li>\n</ul>\n<p>Here is a demo program:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename String, template&lt;class&gt; class Allocator&gt;\nstruct basic_data_object\n{\n    template&lt;typename T&gt;\n    using array_container = std::vector&lt;T, Allocator&lt;T&gt;&gt;;\n};\n\ntemplate&lt;typename T, typename String, template&lt;class&gt; class Allocator&gt;\nstruct is_basic_data_object_array_container\n/* \n    A trait template that has a `static const bool` member `value` equal to\n    `true` if and only if parameter type `T` is a container type\n    with `value_type E` s.t. \n        `T` = `basic_data_object&lt;String,Allocator&gt;::array_container&lt;T::E&gt;`\n*/ \n{\n    template&lt;typename A&gt; \n    static constexpr bool\n    test(std::is_same&lt;\n            A,\n            typename basic_data_object&lt;String,Allocator&gt;::template\n                array_container&lt;typename A::value_type&gt;\n            &gt; *) {\n        return std::is_same&lt;\n            A,\n            typename basic_data_object&lt;String,Allocator&gt;::template\n                array_container&lt;typename A::value_type&gt;\n            &gt;::value;\n    }\n    template&lt;typename A&gt; \n    static constexpr bool test(...) {\n        return false;\n    }\n    static const bool value = test&lt;T&gt;(nullptr);\n};\n\n\ntemplate &lt;\n    typename String, \n    template&lt;class&gt; class Allocator,\n    typename T,\n    bool Select = \n        is_basic_data_object_array_container&lt;T,String,Allocator&gt;::value\n&gt;           \nstruct get_data_object_value;\n\n\ntemplate &lt;\n    typename String, \n    template&lt;class&gt; class Allocator,\n    typename T\n&gt;           \nstruct get_data_object_value&lt;\n    String,\n    Allocator,\n    T,\n    false\n&gt;\n{\n    static void demo() {\n        std::cout &lt;&lt; \"Is NOT a basic_data_object array_container\" &lt;&lt; std::endl;\n    }\n};\n\ntemplate &lt;\n    typename String, \n    template&lt;class&gt; class Allocator,\n    typename T&gt;\nstruct get_data_object_value&lt;\n    String, \n    Allocator,\n    T,\n    true\n&gt;\n{\n    static void demo() {\n        std::cout &lt;&lt; \"Is a basic_data_object array_container\" &lt;&lt; std::endl;\n    }\n};\n\n#include &lt;list&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n    get_data_object_value&lt;string,allocator,std::vector&lt;short&gt;&gt;::demo();\n    get_data_object_value&lt;string,allocator,std::list&lt;short&gt;&gt;::demo();\n    get_data_object_value&lt;string,allocator,short&gt;::demo();\n    return 0;\n}\n</code></pre>\n<p>Built with gcc 4.8.2, clang 3.4. Output:</p>\n<pre><code>Is a basic_data_object array_container\nIs NOT a basic_data_object array_container\nIs NOT a basic_data_object array_container\n</code></pre>\n<p>VC++ 2013 will not compile this for lack of <code>constexpr</code> support. To accommodate that\ncompiler the following less natural implementation of the trait may be used:</p>\n<pre><code>template&lt;typename T, typename String, template&lt;class&gt; class Allocator&gt;\nstruct is_basic_data_object_array_container\n{\n    template&lt;typename A&gt;\n    static\n    auto test(\n        std::is_same&lt;\n            A,\n            typename basic_data_object&lt;String, Allocator&gt;::template\n                array_container&lt;typename A::value_type&gt;\n            &gt; *\n        ) -&gt;\n            std::integral_constant&lt;\n                bool,\n                std::is_same&lt;\n                    A,\n                    typename basic_data_object&lt;String, Allocator&gt;::template\n                        array_container&lt;typename A::value_type&gt;\n                &gt;::value\n            &gt;{}\n    template&lt;typename A&gt;\n    static std::false_type test(...);\n    using type = decltype(test&lt;T&gt;(nullptr));\n    static const bool value = type::value;\n};\n</code></pre>\n", "LastEditorUserId": "1362568", "LastActivityDate": "2014-05-03T11:02:45.563", "Score": "2", "CreationDate": "2014-05-03T09:31:11.627", "ParentId": "23362391", "CommentCount": "2", "OwnerUserId": "1362568", "LastEditDate": "2014-05-03T11:02:45.563"}, "23362391": {"ViewCount": "983", "Body": "<p>This is probably only a syntax problem.</p>\n<p>So i have this template class :</p>\n<pre><code>template &lt;typename String, template&lt;class&gt; class Allocator&gt;\nclass basic_data_object\n{\n  template&lt;typename T&gt;\n  using array_container = std::vector&lt;T, Allocator&lt;T&gt;&gt;;\n};\n</code></pre>\n<p>And another one :</p>\n<pre><code>template &lt;typename String, template&lt;class&gt; class Allocator, typename T&gt;\nstruct get_data_object_value\n{\n};\n</code></pre>\n<p>Now i want to specialize the second one's <code>T</code> parameter with the first one's inner typedef <code>array_container</code> for any given type.</p>\n<pre><code>template &lt;typename String, template&lt;class&gt; class Allocator, typename T&gt;\nstruct get_data_object_value\n&lt;String, Allocator,\ntypename basic_data_object&lt;String, Allocator&gt;::template array_container&lt;T&gt;&gt;\n{\n};\n</code></pre>\n<p>But this specialization doesn't seem to be matched when i pass an std::vector as the last parameter.</p>\n<p>If i create a temporary hard coded typedef:</p>\n<pre><code>typedef basic_data_object&lt;std::string, std::allocator&lt;std::string&gt;&gt; data_object;\n</code></pre>\n<p>And use it for the specialization, everything works :</p>\n<pre><code>template &lt;typename String, template&lt;class&gt; class Allocator, typename T&gt;\nstruct get_data_object_value\n&lt;String, Allocator,\ndata_object::template array_container&lt;T&gt;&gt;\n{\n};\n</code></pre>\n<p>What did i miss ? :)</p>\n<hr>\n<p>Alternatively what is the best (smallest / cleanest) way to make this work ?</p>\n</hr>", "AcceptedAnswerId": "23432100", "Title": "Template specialization on template member of template class", "CreationDate": "2014-04-29T10:43:45.750", "Id": "23362391", "CommentCount": "15", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-05-02T09:18:00.833", "LastEditorUserId": "1147772", "LastActivityDate": "2014-05-09T13:41:42.353", "Score": "19", "OwnerUserId": "1147772", "Tags": "<c++><templates><c++11><specialization>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_23362391_23430522_1": {"length": 15, "quality": 1.0, "section_id": 337}, "so_23362391_23430522_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 144}}, "n3337": {"so_23362391_23430522_1": {"length": 15, "quality": 1.0, "section_id": 327}, "so_23362391_23430522_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 138}}, "n4659": {"so_23362391_23430522_1": {"length": 15, "quality": 1.0, "section_id": 346}, "so_23362391_23430522_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 148}}}, "23430522": {"Id": "23430522", "PostTypeId": "2", "Body": "<p>The C++ standard says, in [temp.class.spec.match] paragraph 2:</p>\n<blockquote>\n<p id=\"so_23362391_23430522_0\">A partial specialization matches a given actual template\n   argument list if the template arguments of the partial\n   specialization can be deduced from the actual template\n   argument list (14.8.2).</p>\n</blockquote>\n<p>14.8.2 is [temp.arg.deduct] i.e. the clause describing template argument deduction for function templates.</p>\n<p>If you modify your code to use a similar function template and attempt to call it, you will see that the arguments cannot be deduced:</p>\n<pre><code>template &lt;typename String, typename T&gt;\nvoid deduction_test(String,\n                    typename basic_data_object&lt;String, std::allocator&gt;::template array_container&lt;T&gt;)\n{ }\n\nint main()\n{\n  deduction_test(std::string{}, std::vector&lt;int, std::allocator&lt;int&gt;&gt;{});\n}\n</code></pre>\n<p>(I removed the <code>Allocator</code> parameter, since there's no way to pass a template template parameter as a function argument and in the <code>basic_data_object</code> type it's a non-deduced context, I don't believe it affects the result.)</p>\n<p>Both clang and GCC say they cannot deduce <code>T</code> here. Therefore the partial specialization will not match the same types used as template arguments.</p>\n<p>So I haven't really answered the question yet, only clarified that the reason is in the rules of template argument deduction, and shown an equivalence with deduction in function templates.</p>\n<p>In 14.8.2.5 [temp.deduct.type] we get a list of <em>non-deduced contexts</em> that prevent deduction, and the following rule in paragraph 6:</p>\n<blockquote>\n<p id=\"so_23362391_23430522_1\">When a type name is specified in a way that includes a non-deduced context, all of the types that comprise that type name are also non-deduced.</p>\n</blockquote>\n<p>Since <code>basic_data_object&lt;String, Allocator&gt;</code> is in a non-deduced context (it is a <em>nested-name-specifier</em>, i.e. appears before <code>::</code>) that means the type <code>T</code> is also non-deduced, which is exactly what Clang and GCC tell us.</p>\n<hr>\n<p>With your temporary hardcoded typedef there is no non-deduced context, and so deduction for <code>T</code> succeeds using the <code>deduction_test</code> function template:</p>\n<pre><code>template &lt;typename String, typename T&gt;\nvoid deduction_test(String,\n                    typename data_object::template array_container&lt;T&gt;)\n{ }\n\nint main()\n{\n  deduction_test(std::string{}, std::vector&lt;int, std::allocator&lt;int&gt;&gt;{}); // OK\n}\n</code></pre>\n<p>And so, correspondingly, your class template partial specialization can be matched when it uses that type.</p>\n<hr>\n<p>I don't see a way to make it work without changing the definition of <code>get_data_object_value</code>, but if that's an option you can remove the need to deduce the <code>array_container</code> type and instead use a trait to detect whether a type is the type you want, and specialize on the result of the trait:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename String, template&lt;class&gt; class Allocator&gt;\nclass basic_data_object\n{\npublic:\n  template&lt;typename T&gt;\n  using array_container = std::vector&lt;T, Allocator&lt;T&gt;&gt;;\n\n  template&lt;typename T&gt;\n    struct is_ac : std::false_type { };\n\n  template&lt;typename T&gt;\n    struct is_ac&lt;array_container&lt;T&gt;&gt; : std::true_type { };\n};\n\ntemplate &lt;typename String, template&lt;class&gt; class Allocator, typename T, bool = basic_data_object&lt;String, Allocator&gt;::template is_ac&lt;T&gt;::value&gt;\nstruct get_data_object_value\n{\n};\n\ntemplate &lt;typename String, template&lt;class&gt; class Allocator, typename T&gt;\nstruct get_data_object_value&lt;String, Allocator, T, true&gt;\n{\n  void f() { }\n};\n\nint main()\n{\n  get_data_object_value&lt;std::string,std::allocator,std::vector&lt;short&gt;&gt; obj;\n  obj.f();\n}\n</code></pre>\n<p>This doesn't really scale if you wanted several class template partial specializations, as you would need to add several <code>bool</code> template parameters with default arguments.</p>\n</hr></hr>", "LastEditorUserId": "981959", "LastActivityDate": "2014-05-02T15:43:35.427", "Score": "8", "CreationDate": "2014-05-02T14:27:24.033", "ParentId": "23362391", "CommentCount": "11", "OwnerUserId": "981959", "LastEditDate": "2014-05-02T15:43:35.427"}, "23431650": {"Id": "23431650", "PostTypeId": "2", "Body": "<p>For some reason, the problem seems to stem from the double level of templates. I'll leave you check the 3 test cases below, they are simple:</p>\n<ol>\n<li>Remove the template arguments of <code>First</code>: works as expected</li>\n<li>Make <code>First</code> a template, but the inner type a plain one: works as expected</li>\n<li>Make both <code>First</code> and the inner type templates: compiles but the output is unexpected</li>\n</ol>\n<p><em>Note: the template template parameter <code>Allocator</code> is useless to reproduce the issue, so I left it out.</em></p>\n<p><em>Note: both GCC (ideone's version, 4.8.1 I believe) and Clang (Coliru version, 3.4) compile the code, and yet produce the same baffling result</em></p>\n<p><strike>From the 3 above examples, I deduce:</strike></p>\n<ul>\n<li><strike>that this is NOT a non-deducible context issue; otherwise why would (2) work ?</strike></li>\n<li><strike>that this is NOT an alias issue; otherwise why would (1) work ?</strike></li>\n</ul>\n<p><strike>And therefore that either the problem is much hairier than the current hints would make us believe OR that both gcc and Clang have a bug.</strike></p>\n<p><strong>EDIT</strong>: Thanks to Jonathan Wakely who patiently educated me enough that I could finally understand both the Standard wording related to this case and how it applied. I will now attempt to explain this (again) in my own words. Please refer to Jonathan's answer for the exact Standard quotes (it all sits in <strong>[temp.deduct.type]</strong>)</p>\n<ul>\n<li>When deducing template parameters (P<sub>i</sub>), whether for functions or classes, <strong>the deduction is done independently for each and every argument</strong>.</li>\n<li>Each argument need provide zero or one <em>candidate</em> C<sub>i</sub> for each parameter; if an argument would provide more than one <em>candidate</em>, it provides none instead.</li>\n<li>Thus, each argument produces a dictionary D<sub>n</sub>: P<sub>i</sub> -&gt; C<sub>i</sub> which maps a subset (possibly empty) of the template parameters to be deduced to their candidate.</li>\n<li>The dictionaries D<sub>n</sub> are merged together, parameter by parameter:\n<ul>\n<li>if only one dictionary has a candidate for a given parameter, then this parameter is accepted, with this candidate</li>\n<li>if several dictionaries have the same candidate for a given parameter, then this parameter is accepted, with this candidate</li>\n<li>if several dictionaries have different incompatible (*) candidates for a given parameter, then this parameter is rejected</li>\n</ul></li>\n<li>If the final dictionary is complete (maps each and every parameter to an accepted candidate) then deduction succeeds, otherwise it fails</li>\n</ul>\n<p>(*) there seems to be a possibility for finding a \"common type\" from the available candidates... it is of no consequence here though.</p>\n<p>Now we can apply this to the previous examples:</p>\n<p>1) A single template parameter <code>T</code> exists:</p>\n<ul>\n<li>pattern matching <code>std::vector&lt;int&gt;</code> against <code>typename First::template ArrayType&lt;T&gt;</code> (which is <code>std::vector&lt;T&gt;</code>), we get D<sub>0</sub>: <code>{ T -&gt; int }</code></li>\n<li>merging the only dictionary yields <code>{ T -&gt; int }</code>, thus <code>T</code> is deduced to be <code>int</code></li>\n</ul>\n<p>2) A single template parameter <code>String</code> exists</p>\n<ul>\n<li>pattern matching <code>std::vector&lt;int&gt;</code> against <code>String</code>, we get D<sub>0</sub>: <code>{ String -&gt; std::vector&lt;int&gt; }</code></li>\n<li>pattern matching <code>std::vector&lt;int&gt;</code> against <code>typename First&lt;String&gt;::ArrayType</code> we hit a non-deducible context (many values of <code>String</code> could fit), we get D<sub>1</sub>: <code>{}</code></li>\n<li>merging the two dictionaries yields <code>{ String -&gt; std::vector&lt;int&gt; }</code>, thus <code>String</code> is deduced to be <code>std::vector&lt;int&gt;</code></li>\n</ul>\n<p>3) <strong>Two</strong> template parameters <code>String</code> and <code>T</code> exist</p>\n<ul>\n<li>pattern matching <code>std::vector&lt;char&gt;</code> against <code>String</code>, we get D<sub>0</sub>: <code>{ String -&gt; std::vector&lt;char&gt; }</code></li>\n<li>pattern matching <code>std::vector&lt;int&gt;</code> against <code>typename First&lt;String&gt;::template ArrayType&lt;T&gt;</code> we hit a non-deducible context, we get D<sub>1</sub>: <code>{}</code></li>\n<li>merging the two dictionaries yields <code>{ String -&gt; std::vector&lt;char&gt; }</code>, which is an incomplete dictionary (<code>T</code> is absent) <strong>deduction fails</strong></li>\n</ul>\n<p>I must admit I had not considered yet that the arguments were resolved independently from one another, and therefore than in this last case, when computing D<sub>1</sub> the compiler could not take advantage of the fact that D<sub>0</sub> had already deduced a value for <code>String</code>. Why it is done in this fashion, however, is probably a full question of its own.</p>\n<hr>\n<p><a href=\"http://ideone.com/M41HOR\" rel=\"nofollow\">Without the outer template, it works</a>, as in it prints \"Specialized\":</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct First {\n    template &lt;typename T&gt;\n    using ArrayType = std::vector&lt;T&gt;;\n};\n\ntemplate &lt;typename T&gt;\nstruct Second {\n    void go() { std::cout &lt;&lt; \"General\\n\"; }\n};\n\ntemplate &lt;typename T&gt;\nstruct Second &lt; typename First::template ArrayType&lt;T&gt; &gt; {\n    void go() { std::cout &lt;&lt; \"Specialized\\n\"; }\n};\n\nint main() {\n    Second &lt; std::vector&lt;int&gt; &gt; second;\n    second.go();\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/e6HVfR\" rel=\"nofollow\">Without the inner template, it works</a>, as in it prints \"Specialized\":</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename String&gt;\nstruct First {\n    using ArrayType = std::vector&lt;int&gt;;\n};\n\ntemplate &lt;typename String, typename T&gt;\nstruct Second {\n    void go() { std::cout &lt;&lt; \"General\\n\"; }\n};\n\ntemplate &lt;typename String&gt;\nstruct Second &lt; String, typename First&lt;String&gt;::ArrayType &gt; {\n    void go() { std::cout &lt;&lt; \"Specialized\\n\"; }\n};\n\n\nint main() {\n    Second &lt; std::vector&lt;int&gt;, std::vector&lt;int&gt; &gt; second;\n    second.go();\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/K18pLl\" rel=\"nofollow\">With both, it fails</a>, as in it prints \"General\":</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\ntemplate &lt;typename String&gt;\nstruct First {\n    template &lt;typename T&gt;\n    using ArrayType = std::vector&lt;T&gt;;\n};\n\ntemplate &lt;typename String, typename T&gt;\nstruct Second {\n    void go() { std::cout &lt;&lt; \"General\\n\"; }\n};\n\ntemplate &lt;typename String, typename T&gt;\nstruct Second &lt; String, typename First&lt;String&gt;::template ArrayType&lt;T&gt; &gt; {\n    void go() { std::cout &lt;&lt; \"Specialized\\n\"; }\n};\n\nint main() {\n    Second &lt; std::vector&lt;char&gt;, std::vector&lt;int&gt; &gt; second;\n    second.go();\n    return 0;\n}\n</code></pre>\n</hr>", "LastEditorUserId": "147192", "LastActivityDate": "2014-05-02T17:24:53.607", "Score": "6", "CreationDate": "2014-05-02T15:25:23.670", "ParentId": "23362391", "CommentCount": "8", "OwnerUserId": "147192", "LastEditDate": "2014-05-02T17:24:53.607"}, "23432100": {"Id": "23432100", "PostTypeId": "2", "Body": "<p>The answer of Jonathan Wakely gives the reason why your code does not work.</p>\n<p>My answer shows you how to solve the problem.</p>\n<hr>\n<p>In your example, the container type over which you want to specialize is defined outside of <code>basic_data_object</code> thus you can of course use it directly in your specialization:</p>\n<pre><code>template &lt;typename S, template&lt;class&gt; class A, typename T&gt;\nstruct get_data_object_value&lt;S,A,std::vector&lt;T,A&gt;&gt;\n{ };\n</code></pre>\n<p>This definitely conforms with the standard and works with all compilers.</p>\n<hr>\n<p>In the case where the type is defined in <code>basic_data_object</code>, you can move it out of the class.</p>\n<p><strong>Example:</strong> Instead of </p>\n<pre><code>template&lt;typename S, template&lt;class&gt; class A&gt;\nstruct a_data_object\n{\n    template&lt;typename T&gt;\n    struct a_container\n    { };\n};\n</code></pre>\n<p>write this:</p>\n<pre><code>template&lt;typename S, template&lt;class&gt; class A, typename T&gt;\n// you can perhaps drop S and A if not needed...\nstruct a_container\n{ };\n\ntemplate&lt;typename S, template&lt;class&gt; class A, typename T&gt;\nstruct a_data_object\n{\n    // use a_container&lt;S,A,T&gt;\n};\n</code></pre>\n<p>Now you can specialize with:</p>\n<pre><code>template &lt;typename S, template&lt;class&gt; class A, typename T&gt;\nstruct get_data_object_value&lt;S,A,a_container&lt;S,A,T&gt;&gt;\n{ };\n</code></pre>\n<hr>\n<p><strong>Note</strong>: The next \"solution\" is apparently a bug with GCC 4.8.1.</p>\n<p>If the container is only defined in an enclosing template and can not be moved out you can do this:</p>\n<ol>\n<li><p>Get the container type out of <code>basic_data_object</code>:</p>\n<pre><code>template&lt;typename S, template&lt;class&gt; class A, typename T&gt;\nusing bdo_container = basic_data_object&lt;S,A&gt;::array_container&lt;T&gt;;\n</code></pre></li>\n<li><p>Write a specialization for this type:</p>\n<pre><code>template &lt;typename S, template&lt;class&gt; class A, typename T&gt;\nstruct get_data_object_value&lt;S,A,bdo_container&lt;S,A,T&gt;&gt;\n{ };\n</code></pre></li>\n</ol>\n</hr></hr></hr>", "LastEditorUserId": "316448", "LastActivityDate": "2014-05-09T13:41:42.353", "Score": "5", "CreationDate": "2014-05-02T15:49:56.147", "ParentId": "23362391", "CommentCount": "11", "OwnerUserId": "316448", "LastEditDate": "2014-05-09T13:41:42.353"}});