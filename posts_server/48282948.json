post_cb({"48283366": {"Id": "48283366", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48282948_48283366_0\">Scott says it would not be leaked because it is a non-pointer data\n  member,</p>\n</blockquote>\n<p>What Scott Meyer means is that all data members are destroyed anyway, but unlike a <code>std::string</code> whose destructor does all the clean-up work, raw pointers don't automatically call <code>delete</code> on themselves when they are destroyed.</p>\n<blockquote>\n<p id=\"so_48282948_48283366_1\">but if the destructor of <code>AnimalLoverProfile</code> is never called, then who destroys <code>theName</code>?</p>\n</blockquote>\n<p>All data members which were created are automatically destroyed, whether it's an <code>int</code>, a <code>std::string</code> or an <code>Image*</code>. It's a C++ rule which the compiler has to implement, or else exceptions would be almost unusable in constructors.</p>\n", "LastActivityDate": "2018-01-16T14:20:34.170", "CommentCount": "0", "CreationDate": "2018-01-16T14:20:34.170", "ParentId": "48282948", "Score": "1", "OwnerUserId": "3313064"}, "48282948": {"ViewCount": "72", "Body": "<p>This question is based on an example Scott Meyers provided in his book \"More Effective C++\". Consider the following class:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// A class to represent the profile of a user in a dating site for animal lovers.\nclass AnimalLoverProfile\n{\npublic:\n    AnimalLoverProfile(const string&amp; name,\n                       const string&amp; profilePictureFileName = \"\",\n                       const string&amp; pictureOfPetFileName = \"\");\n    ~AnimalLoverProfile();\n\nprivate:\n    string theName;\n    Image * profilePicture;\n    Image * pictureOfPet;\n};\n\nAnimalLoverProfile::AnimalLoverProfile(const string&amp; name,\n                                       const string&amp; profilePictureFileName,\n                                       const string&amp; pictureOfPetFileName)\n : theName(name)\n{\n    if (profilePictureFileName != \"\")\n    {\n        profilePicture = new Image(profilePictureFileName);\n    }\n\n    if (pictureOfPetFileName != \"\")\n    {\n        pictureOfPet = new Image(pictureOfPetFileName); // Consider exception here!\n    }\n}\n\nAnimalLoverProfile::~AnimalLoverProfile()\n{\n    delete profilePicture;\n    delete pictureOfPet;\n}\n</code></pre>\n<p>In his book, Scott explains that if an exception is thrown in the constructor of an object, then that object's destructor will never be called, because C++ cannot destroy a partially constructed object. In the example above, if the call <code>new Image(pictureOfPetFileName)</code> throws an exception, then the destructor of the class is never called, which causes the already allocated <code>profilePicture</code> to be leaked.</p>\n<p>He described many different approaches to deal with this issue, but what I am interested in is the member variable <code>theName</code>. If either of the calls to <code>new Image</code> in the constructor threw an exception, wouldn't this member variable be leaked? Scott says it would not be leaked because it is a non-pointer data member, but if the destructor of <code>AnimalLoverProfile</code> is never called, then who destroys <code>theName</code>?</p>\n", "AcceptedAnswerId": "48283038", "Title": "Destroying the member variables of an object when an exception is thrown in its constructor in C++", "CreationDate": "2018-01-16T13:58:42.740", "LastActivityDate": "2018-01-16T14:40:15.887", "CommentCount": "5", "LastEditDate": "2018-01-16T14:13:32.923", "PostTypeId": "1", "LastEditorUserId": "3266738", "Id": "48282948", "Score": "0", "OwnerUserId": "3266738", "Tags": "<c++><exception><memory-leaks><constructor><destructor>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_48282948_48283104_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 438}, "so_48282948_48283104_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 438}, "so_48282948_48283104_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 438}}, "n3337": {"so_48282948_48283104_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 429}, "so_48282948_48283104_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 429}, "so_48282948_48283104_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 429}}, "n4659": {"so_48282948_48283116_0": {"length": 53, "quality": 0.9636363636363636, "section_id": 4110}, "so_48282948_48283104_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 458}, "so_48282948_48283104_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 458}, "so_48282948_48283104_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 458}}}, "48283116": {"Id": "48283116", "PostTypeId": "2", "Body": "<p>All subobject already constructed are destroyed if an exception is thrown during construction. See <a href=\"https://timsong-cpp.github.io/cppwp/n4659/except.ctor#3\" rel=\"nofollow noreferrer\">[except.ctor]/3</a>:</p>\n<blockquote>\n<p id=\"so_48282948_48283116_0\">If the initialization or destruction of an object other than by delegating constructor is terminated by an exception, the destructor is invoked for each of the object's direct subobjects and, for a complete object, virtual base class subobjects, whose initialization has completed ([dcl.init]) and whose destructor has not yet begun execution, except that in the case of destruction, the variant members of a union-like class are not destroyed. The subobjects are destroyed in the reverse order of the completion of their construction. Such destruction is sequenced before entering a handler of the function-try-block of the constructor or destructor, if any.</p>\n</blockquote>\n<hr>\n<p>Nota, I have just discovered that even the first initialized variant member is also destroyed, so that inside the constructor, if you change the active member of the variant, the anactivated member will still be destroyed while it is not within its lifetime!</p>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-16T14:24:03.753", "Score": "1", "CreationDate": "2018-01-16T14:06:32.053", "ParentId": "48282948", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2018-01-16T14:24:03.753"}, "48283104": {"Id": "48283104", "PostTypeId": "2", "Body": "<p>Scott is right. Consider about the <a href=\"http://en.cppreference.com/w/cpp/language/initializer_list#Initialization_order\" rel=\"nofollow noreferrer\">intialization steps</a> for a class:</p>\n<blockquote>\n<p id=\"so_48282948_48283104_0\">1) If the constructor is for the most-derived class, virtual base\n  classes are initialized in the order in which they appear in\n  depth-first left-to-right traversal of the base class declarations\n  (left-to-right refers to the appearance in base-specifier lists)</p>\n<p id=\"so_48282948_48283104_1\">2) Then, direct base classes are initialized in left-to-right order as\n  they appear in this class's base-specifier list</p>\n<p id=\"so_48282948_48283104_2\">3) Then, non-static data members are initialized in order of\n  declaration in the class definition.</p>\n<p id=\"so_48282948_48283104_3\">4) Finally, the body of the constructor is executed</p>\n</blockquote>\n<p>That means, before entering the body of constructor, the data members have been initialized. And if any exception is thrown inside the body of constructor, the destructor of the class won't be invoked (because the constructor is not completed yet), but the data members will be destroyed via their destructors (i.e. <code>std::string::~string()</code> for <code>theName</code>), because their initialization has been finished. And that's why we should use smart pointers instead of raw pointers for such exception guarantee issues.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2018-01-16T14:11:25.297", "Score": "2", "CreationDate": "2018-01-16T14:06:07.147", "ParentId": "48282948", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2018-01-16T14:11:25.297"}, "48283038": {"Id": "48283038", "PostTypeId": "2", "Body": "<p>The destructor of <code>AnimalLoverProfile</code> is never called because this object is not constructed yet, while the destructor for <code>theName</code> will be called because this object is properly constructed (even though it is a field of an object that has not been completely constructed yet). It is possible to avoid any memory leaks here by using smart pointers:</p>\n<pre><code>::std::unique_ptr&lt;Image&gt; profilePicture;\n::std::unique_ptr&lt;Image&gt; pictureOfPet;\n</code></pre>\n<p>In this case, when <code>new Image(pictureOfPetFileName)</code> throws, the <code>profilePicture</code> object will have already been constructed, which means that its destructor will be called, just as the destructor of <code>theName</code> is called.</p>\n", "LastEditorUserId": "3266738", "LastActivityDate": "2018-01-16T14:40:15.887", "Score": "6", "CreationDate": "2018-01-16T14:02:48.203", "ParentId": "48282948", "CommentCount": "4", "OwnerUserId": "7860670", "LastEditDate": "2018-01-16T14:40:15.887"}});