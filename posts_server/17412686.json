post_cb({"bq_ids": {"n4140": {"so_17412686_17412835_0": {"length": 60, "quality": 0.8823529411764706, "section_id": 321}, "so_17412686_17412835_1": {"length": 29, "quality": 0.90625, "section_id": 330}}, "n3337": {"so_17412686_17412835_0": {"length": 60, "quality": 0.8823529411764706, "section_id": 311}, "so_17412686_17412835_1": {"length": 29, "quality": 0.90625, "section_id": 320}}, "n4659": {"so_17412686_17412835_0": {"length": 60, "quality": 0.8823529411764706, "section_id": 329}, "so_17412686_17412835_1": {"length": 29, "quality": 0.90625, "section_id": 339}}}, "17412686": {"ViewCount": "423", "Body": "<p>Consider a case where one needs to verify a type <code>T</code> with another template <code>g</code> (could be some <code>enable_if</code> expression, for example) inside a dummy parameter of another template, like this:</p>\n<pre><code>template&lt;class&gt;        struct g { typedef void type; };\ntemplate&lt;class, class&gt; struct f {};\ntemplate&lt;class T&gt;      struct f&lt;T, void&gt; {};                  // Case A\ntemplate&lt;class T&gt;      struct f&lt;T*, typename g&lt;T&gt;::type&gt; {};  // Case B\n\nint main() { f&lt;int*, void&gt; test; }\n</code></pre>\n<p>Here, for the sake of simplicity <code>g</code> doesn't really do anything.  The second parameter in <strong>Case B</strong> is in a nondeduced context, therefore intuitively one would think that <strong>Case B</strong> is more specialized than <strong>Case A</strong>.  Sadly, both gcc and clang will complain that the template is ambiguous in the instantiation above.</p>\n<p>If the dummy parameter were to be removed, then it compiles just fine.  How does the addition of a nondeduced parameter somehow destroy the reasonable expectation that <code>T*</code> is more specialized than <code>T</code>?</p>\n<p>Here's a quick check using the substitution algorithm:</p>\n<pre><code>   f&lt;Q , void      &gt;\n-&gt; f&lt;T*, g&lt;Q&gt;::type&gt; // [failed]\n\n   f&lt;Q*, g&lt;Q&gt;::type&gt;\n-&gt; f&lt;T , void      &gt; // [to fail or not to fail?]\n// One would assume that 2nd parameter is ignored, but guess not?\n</code></pre>\n", "AcceptedAnswerId": "17412835", "Title": "Ambiguous template with SFINAE dummy parameter", "CreationDate": "2013-07-01T20:01:05.717", "Id": "17412686", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-07-01T20:07:58.403", "LastEditorUserId": "440302", "LastActivityDate": "2013-07-01T21:08:03.273", "Score": "7", "OwnerUserId": "440302", "Tags": "<c++><template-specialization><template-meta-programming><sfinae>", "AnswerCount": "1"}, "17412835": {"Id": "17412835", "PostTypeId": "2", "Body": "<p>When ambiguity arises, partial ordering of templates is used to resolve it. However, this partial ordering is established on the templates as they are <em>before</em> any substitution happens, and not <em>after</em> (partial or complete) substitution has been performed - which is what you are expecting by replacing <code>int</code> for <code>T</code> in <code>typename g&lt;T&gt;::type</code>, which yields <code>typename g&lt;int&gt;::type</code> and therefore (because of the definition of <code>g</code>) <code>void</code>.</p>\n<p>Paragraph 14.8.2.4/2 specifies how partial ordering is established (see <a href=\"https://stackoverflow.com/a/17008568/1932150\">this answer on SO</a> for a more detailed discussion of the paragraph below):</p>\n<blockquote>\n<p id=\"so_17412686_17412835_0\">Two sets of types are used to determine the partial ordering. For each of the templates involved there is\n  the original function type and the transformed function type. [ Note: The creation of the transformed type\n  is described in 14.5.6.2. \u2014end note ] The deduction process uses the transformed type as the argument\n  template and the original type of the other template as the parameter template. This process is done twice\n  for each type involved in the partial ordering comparison: once using the transformed template-1 as the\n  argument template and template-2 as the parameter template and again using the transformed template-2\n  as the argument template and template-1 as the parameter template.</p>\n</blockquote>\n<p>Before any substitution, without knowing what value <code>T</code> will assume, you cannot tell (and neither the compiler can tell) whether <em>case B</em> is more or less specialized than <em>case A</em>. Therefore, neither of the two specializations is more specialized than the other.</p>\n<p>In other words, the question isn't whether this partial specialization:</p>\n<pre><code>template&lt;class T&gt; struct f&lt;T, void&gt;; // Case A\n</code></pre>\n<p>Is more specialized than this one (obtained through partial substitution):</p>\n<pre><code>template&lt;class T&gt; struct f&lt;T*, void&gt;; // Case B\n</code></pre>\n<p>If that were what you have, the answer would be obviously that <em>case B</em> is more specialized. Instead, the question is whether for <strong>any possible <code>T</code></strong>, this specialization:</p>\n<pre><code>template&lt;class T&gt; struct f&lt;T, void&gt;; // Case A\n</code></pre>\n<p>Is more specialized than this one:</p>\n<pre><code>template&lt;class T&gt; struct f&lt;T*, typename g&lt;T&gt;::type&gt;; // Case B\n</code></pre>\n<p>Since that cannot be established for any <code>T</code>, case B is neither more specialized nor less specialized than <em>case A</em>, and when both are viable, you get an ambiguity.</p>\n<p>If you are wondering whether parameters in a non-deduced context are taken into consideration for partial ordering, this is mentioned in a note to Paragraph 14.8.2.4/11:</p>\n<blockquote>\n<p id=\"so_17412686_17412835_1\">In most cases, all template parameters must have values in order for deduction to succeed, but for partial\n  ordering purposes a template parameter may remain without a value provided it is not used in the types\n  being used for partial ordering. [ <strong>Note: A template parameter used in a non-deduced context is considered\n  used. \u2014end note</strong> ]</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-01T21:08:03.273", "Score": "5", "CreationDate": "2013-07-01T20:12:15.260", "ParentId": "17412686", "CommentCount": "6", "OwnerUserId": "1932150", "LastEditDate": "2017-05-23T12:05:27.660"}});