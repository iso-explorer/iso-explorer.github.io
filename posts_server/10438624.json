post_cb({"10438624": {"CommentCount": "3", "ViewCount": "97", "CreationDate": "2012-05-03T20:10:50.437", "LastActivityDate": "2012-05-03T20:27:49.763", "Title": "template method specialization on *nix", "FavoriteCount": "1", "PostTypeId": "1", "Id": "10438624", "Score": "4", "Body": "<p>I have a variant class which uses some function template specialization for getting and setting different types which compiled and worked fine with Visual Studio 2010. However this code was located in a common solution which also needs to compile on redhat, ubuntu, etc.</p>\n<p>I received an error along the lines of explicit specialization in non-namespace scope. I figured the easy fix was to simply define my specializations outside the class with scope qualifier for the class in the same namespace.</p>\n<p>However now I'm getting errors that the specialization occurs after the instantiation as other methods of the class for converting from various types are using this template within the class.</p>\n<p>So what is the correct way to do something like this:</p>\n<pre><code>namespace Example\n{\n    class CSomeVariant\n    {\n    public:\n        bool toString(std::string&amp; out)\n        {\n            return get(out);\n        }\n    private:\n        template &lt;typename T&gt;\n        bool get(T&amp; val)\n        {\n            try {\n                val = boost::any_cast&lt;T&gt;(m_stored);\n            }\n            catch (...) {\n                return false;\n            }\n            return true;\n        }\n\n        boost::any m_stored;\n    };\n\n    template&lt;&gt;\n    bool CSomeVariant::get(std::string&amp; val)\n    {\n        try {\n            if (m_stored.type() != typeid(std::string))\n               val = convertToString();\n            else\n               val = boost::any_cast&lt;std::string&gt;(m_stored);\n        }\n        catch(...) {\n            return false;\n        }\n        return true;\n    }\n}\n</code></pre>\n<p>Note: This is not the actual code but I believe it shows the problem.</p>\n", "Tags": "<c++><linux><templates><gcc>", "OwnerUserId": "516725", "AnswerCount": "1"}, "10438746": {"ParentId": "10438624", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The problem is that you're using the <code>get()</code> function in the class definition and then specializing it afterwards, which is not allowed.  From 14.7.3 paragraph 6</p>\n<blockquote>\n<p id=\"so_10438624_10438746_0\">If a template, a member template or the member of a class template is\n  explicitly specialized then that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs; no diagnostic is required. If the program\n  does not provide a definition for an explicit specialization and\n  either the specialization is used in a way that would cause an\n  implicit instantiation to take place or the member is a virtual member\n  function, the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>One solution is to reorder the class definition so that the specialization is declared before any uses.  In this case, I was able to move the inline use of the function till after the specialization.  </p>\n<pre><code>#include &lt;string&gt;\n#include &lt;boost/any.hpp&gt;\nnamespace Example\n{\n    class CSomeVariant\n    {\n    public:\n        bool toString(std::string&amp; out);\n\n    private:\n       template &lt;typename T&gt;\n       bool get(T&amp; val)\n       {\n           try {\n              val = boost::any_cast&lt;T&gt;(m_stored);\n           }\n           catch (...) {\n               return false;\n           }\n           return true;\n       }\n\n       boost::any m_stored;\n   };\n\n   template&lt;&gt;\n   bool CSomeVariant::get(std::string&amp; val)\n   {\n       try {\n           if (m_stored.type() != typeid(std::string))\n              val = convertToString();\n           else\n              val = boost::any_cast&lt;std::string&gt;(m_stored);\n       }\n       catch(...) {\n           return false;\n       }\n       return true;\n   }\n\n\n   inline bool CSomeVariant::toString(std::string&amp; out)\n   {\n        return get(out);\n   }\n}\n</code></pre>\n", "OwnerUserId": "862231", "LastEditorUserId": "862231", "LastEditDate": "2012-05-03T20:27:49.763", "Id": "10438746", "Score": "3", "CreationDate": "2012-05-03T20:19:43.727", "LastActivityDate": "2012-05-03T20:27:49.763"}, "bq_ids": {"n4140": {"so_10438624_10438746_0": {"section_id": 268, "quality": 1.0, "length": 50}}, "n3337": {"so_10438624_10438746_0": {"section_id": 259, "quality": 1.0, "length": 50}}, "n4659": {"so_10438624_10438746_0": {"section_id": 275, "quality": 1.0, "length": 50}}}});