post_cb({"bq_ids": {"n4140": {"so_15424831_15424831_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6694}, "so_15424831_15425371_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3208}}, "n3337": {"so_15424831_15424831_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6449}, "so_15424831_15425371_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3082}}, "n4659": {"so_15424831_15424831_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 8169}, "so_15424831_15425371_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 3965}}}, "15424831": {"ViewCount": "833", "Body": "<p>I'm trying to figure out whether to file a bug report against Clang, GCC, or both (I've tested against Clang trunk and GCC 4.7.2: if someone could verify this against GCC trunk that would be helpful):</p>\n<p>Basically, the following code three-line file compiles fine with <code>-fsyntax-only</code>, in default and C++11 modes:</p>\n<pre><code>class A {\n    friend void f();\n};\n</code></pre>\n<p>Note that there's no prior declaration of <code>f()</code>, but this is explicitly OK.</p>\n<p>However, Clang (but not GCC) rejects the following:</p>\n<pre><code>class A {\n    friend void ::f();\n};\n</code></pre>\n<p>The error from Clang is \"no function named 'f' with type 'void ()' was found in the specified scope\", but I can't find any justification in the standard for treating this case differently than the previous one, so I think it's a bug; I might be wrong though (I'm reading from N3242, however, which AFAIK is the last public draft before C++11).</p>\n<p>This next example, however, is rejected by GCC rather than Clang:</p>\n<pre><code>void f() { }\n\nvoid g()\n{\n    class A {\n        friend void ::f();\n    };\n}\n</code></pre>\n<p>The error from GCC is \"friend declaration \u2018void f()\u2019 in local class without prior declaration\", which doesn't seem to make sense since <code>void ::f()</code> should refer to the <code>f()</code> in the global namespace, which is declared. (Never mind that <code>friend</code>-ing a global function from a local class is nonsensical, it doesn't seem to be illegal...)</p>\n<p>Finally, this last example is rejected both by Clang and GCC:</p>\n<pre><code>void g()\n{\n    class A {\n        friend void ::f();\n    };\n}\n</code></pre>\n<p>The errors are \"friend declaration \u2018void f()\u2019 in local class without prior declaration\" and \"no function named 'f' with type 'void ()' was found in the specified scope\", respectively. Now, there does appear to be some justification for rejecting a friend declaration of a previously undeclared function in a local class, from 11.4p11, but the paragraph actually reads:</p>\n<blockquote>\n<p id=\"so_15424831_15424831_0\">If a friend declaration appears in a local class (9.8) <strong>and the name specified is an unqualified name</strong>, a prior\n  declaration is looked up without considering scopes that are outside the innermost enclosing non-class scope.\n  For a friend function declaration, if there is no prior declaration, the program is ill-formed...</p>\n</blockquote>\n<p>The illegality of this declaration apparently is based on the second sentence in this paragraph, but it's unclear to me whether the sentence should apply in the case of a qualified name as well, as is used in this case. (Arguably, it could be that the entire paragraph applies to the \"local class\" case regardless of whether or not an \"unqualified name\" is used, and the \"and the name specified is an unqualified name\" clause only applies to the lookup described in the first sentence, but it seems like a stretch...the only reason I'm imagining this as a possibility is because both compilers reject it.)</p>\n<p>Anyway, so from what I can tell, all four of these cases (regardless of how sensible they are or not) should be legal; even if not, at least one of Clang and GCC is wrong in the second and third cases. Can anyone find an error in my logic?</p>\n<p>The third and fourth cases are admittedly nonsensical; but I can see the second case breaking someone's valid and useful code so I'm somewhat surprised it's never been caught, if it is indeed a bug.</p>\n", "AcceptedAnswerId": "15425371", "Title": "Clang vs. GCC: Friend-ing a global function via qualified/unqualified names", "CreationDate": "2013-03-15T04:36:00.650", "Id": "15424831", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-16T03:21:57.913", "LastEditorUserId": "2008149", "LastActivityDate": "2013-03-16T03:21:57.913", "Score": "15", "OwnerUserId": "2008149", "Tags": "<c++><gcc><clang><language-lawyer>", "AnswerCount": "1"}, "15425371": {"Id": "15425371", "PostTypeId": "2", "Body": "<p>I think this sentence from 8.3/1 is relevant:</p>\n<blockquote>\n<p id=\"so_15424831_15425371_0\">When the <em>declarator-id</em> is qualified, the declaration shall refer to a previously declared member of the class or namespace to which the qualifier refers (or, in the case of a namespace, of an element of the inline namespace set of that namespace (7.3.1)) or to a specialization thereof; the member shall not merely have been introduced by a <em>using-declaration</em> in the scope of the class or namespace nominated by the <em>nested-name-specifier</em> of the <em>declarator-id</em>.</p>\n</blockquote>\n<p>The paragraph is talking about declarators in general, in any type of declaration.  So I think examples 2 and 4 are ill-formed, clang is correct, and gcc is wrong.</p>\n<p>(Example 3 might become more realistic if the global declaration were a template function.  It might be useful to friend a global function template or a specialization from a local class.  And if that's allowed, your example 3 as written might as well be legal for consistency.)</p>\n", "LastActivityDate": "2013-03-15T05:25:59.533", "CommentCount": "2", "CreationDate": "2013-03-15T05:25:59.533", "ParentId": "15424831", "Score": "4", "OwnerUserId": "459640"}});