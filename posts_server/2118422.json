post_cb({"2118718": {"ParentId": "2118422", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Stephan T. Lavavej, a member of the MSVC team, addresses the reality of this situation (and some of the refinements to the standard) in this comment on one of his blog postings (<a href=\"http://blogs.msdn.com/vcblog/archive/2008/08/28/the-mallocator.aspx#8904359\" rel=\"noreferrer\">http://blogs.msdn.com/vcblog/archive/2008/08/28/the-mallocator.aspx#8904359</a>):</p>\n<blockquote>\n<p id=\"so_2118422_2118718_0\">&gt; also, <code>&lt;cstddef&gt;</code>, <code>&lt;cstdlib&gt;</code>, and <code>std::size_t</code> etc should be used!</p>\n<p id=\"so_2118422_2118718_1\">I used to be very careful about that. C++98 had a splendid dream wherein <code>&lt;cfoo</code>&gt; would declare everything within namespace std, and <code>&lt;foo.h&gt;</code> would include <code>&lt;cfoo&gt;</code> and then drag everything into the global namespace with using-declarations. (This is D.5 [depr.c.headers].)</p>\n<p id=\"so_2118422_2118718_2\">This was ignored by lots of implementers (some of which had very little control over the C Standard Library headers). So, C++0x has been changed to match reality. As of the N2723 Working Paper, <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf\" rel=\"noreferrer\">http://open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf</a> , now <code>&lt;cfoo&gt;</code> is guaranteed to declare everything within namespace std, and may or may not declare things within the global namespace. <code>&lt;foo.h&gt;</code> is the opposite: it is guaranteed to declare everything within the global namespace, and may or may not declare things within namespace std.</p>\n<p id=\"so_2118422_2118718_3\">In reality and in C++0x, including <code>&lt;cfoo&gt;</code> is no safeguard against everything getting declared in the global namespace anyways. That's why I'm ceasing to bother with <code>&lt;cfoo&gt;</code>.</p>\n<p id=\"so_2118422_2118718_4\">This was Library Issue 456, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456</a> .</p>\n<p id=\"so_2118422_2118718_5\">(C++0x still deprecates the <code>&lt;foo.h&gt;</code> headers from the C Standard Library, which is hilarious.)</p>\n</blockquote>\n<p>I'm in 100% agreement with Lavavej, except I never tried to be very careful about using the <code>&lt;cfoo&gt;</code> style headers even when I first started using C++ - the standard C ones were just too ingrained - and there was never any real world problem using them (and apparently there was never any real world benefit to using the <code>&lt;cfoo&gt;</code> style headers).</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-01-22T16:53:07.060", "Id": "2118718", "Score": "8", "CreationDate": "2010-01-22T16:28:16.290", "LastActivityDate": "2010-01-22T16:53:07.060"}, "2118460": {"ParentId": "2118422", "CommentCount": "1", "Body": "<p>Why do you say \"This would compile fine\" when it violates the Standard?  Who allows you to use those names without qualifying the namespace?  Have you tested this on a particular implementation and found that it works?</p>\n<p>I strongly advise against using some particular non-standard feature because it happens to work on your compiler of choice.  Such things break easily, perhaps with a later version of the same compiler.</p>\n", "OwnerUserId": "14148", "PostTypeId": "2", "Id": "2118460", "Score": "1", "CreationDate": "2010-01-22T15:54:02.213", "LastActivityDate": "2010-01-22T15:54:02.213"}, "2118454": {"ParentId": "2118422", "CommentCount": "0", "Body": "<p>You are probably missing using a standards-conformant compiler (or the one you use is configured to be compatible with pre-standard code). </p>\n", "OwnerUserId": "20402", "PostTypeId": "2", "Id": "2118454", "Score": "0", "CreationDate": "2010-01-22T15:52:33.630", "LastActivityDate": "2010-01-22T15:52:33.630"}, "2118422": {"CommentCount": "8", "AcceptedAnswerId": "2118718", "PostTypeId": "1", "LastEditorUserId": "257581", "CreationDate": "2010-01-22T15:48:17.240", "LastActivityDate": "2010-01-22T16:53:07.060", "LastEditDate": "2010-01-22T15:53:25.873", "ViewCount": "903", "FavoriteCount": "1", "Title": "Scope of C libraries in C++ - <X.h> vs <cX>", "Id": "2118422", "Score": "4", "Body": "<p>The C++ Programming Language : Special Edition states on page 431 that...</p>\n<p><code>For every header &lt; X.h &gt; defining part of the C standard library in the global namespace and also in namespace std, there is a header &lt; cX &gt; defining the same names in the std namespace only.</code></p>\n<p>However, when I use C headers in the &lt; cX &gt; style, I don't need to qualify the namespace. For example...</p>\n<pre><code>#include &lt;cmath&gt;\nvoid f() {\n  double var = sqrt( 17 );\n}\n</code></pre>\n<p>This would compile fine. Even though the book says that using the &lt; cX &gt; header defines names in the std namespace only, you are allowed to use those names without qualifying the namespace. What am I missing here?</p>\n<p>P.S. Using the GNU.GCC compiler</p>\n", "Tags": "<c++><gcc><gnu>", "OwnerUserId": "257581", "AnswerCount": "5"}, "2118538": {"ParentId": "2118422", "CommentCount": "1", "Body": "<p>It's hard to fix this without implementing the C library twice.  See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#456\" rel=\"nofollow noreferrer\">DR 456</a>, which basically proposes giving up on the problem.</p>\n", "OwnerUserId": "237688", "PostTypeId": "2", "Id": "2118538", "Score": "4", "CreationDate": "2010-01-22T16:03:24.850", "LastActivityDate": "2010-01-22T16:03:24.850"}, "bq_ids": {"n4140": {"so_2118422_2118535_1": {"section_id": 6259, "quality": 1.0, "length": 16}}, "n3337": {"so_2118422_2118535_1": {"section_id": 6019, "quality": 1.0, "length": 16}}, "n4659": {"so_2118422_2118535_1": {"section_id": 7763, "quality": 1.0, "length": 16}}}, "2118535": {"ParentId": "2118422", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The rule for the C libraries differs from C++ libraries for namespaces</p>\n<p>gcc interprets the standard in <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch03s02.html\" rel=\"nofollow noreferrer\">Gcc docs</a> as</p>\n<blockquote>\n<p id=\"so_2118422_2118535_0\">The standard specifies that if one includes the C-style header (&lt;math.h&gt; in this case), the symbols will be available in the global namespace and perhaps in namespace std:: (but this is no longer a firm requirement.) One the other hand, including the C++-style header (&lt;cmath&gt;) guarantees that the entities will be found in namespace std and perhaps in the global namespace. </p>\n</blockquote>\n<p>In the draft C0X++ spec it says in section 17.6.2.3 Headers </p>\n<blockquote>\n<p id=\"so_2118422_2118535_1\">It is unspecified whether these names are first declared within the global namespace scope and are then injected\n  into namespace std by explicit using-declarations</p>\n</blockquote>\n", "OwnerUserId": "151019", "LastEditorUserId": "151019", "LastEditDate": "2010-01-22T16:09:00.447", "Id": "2118535", "Score": "6", "CreationDate": "2010-01-22T16:03:25.763", "LastActivityDate": "2010-01-22T16:09:00.447"}});