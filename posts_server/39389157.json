post_cb({"bq_ids": {"n4140": {"so_39389157_39389744_0": {"length": 35, "quality": 1.0, "section_id": 447}}, "n3337": {"so_39389157_39389744_0": {"length": 35, "quality": 1.0, "section_id": 438}}, "n4659": {"so_39389157_39389744_0": {"length": 35, "quality": 1.0, "section_id": 469}}}, "39389527": {"Id": "39389527", "PostTypeId": "2", "Body": "<p>When your class has a pure virtual function, that does not mean you cannot also have an implementation for it (!!). So that implies you can have an abstract class, which is also fully implemented. The constructor of your abstract class has to be able to call all functions - even the pure virtual ones, because of this point - that exist for it so far. </p>\n<p>If you'd have substituted the client one, you'd get different behaviour for the base class constructor depending on the deriving class - not a great idea, so that's not allowed. You could put in place no vtable and statically resolve all function calls - that works, but it implies handling the constructor specially compared to all other functions and requires inlining all other functions to do this (since a function called from the constructor may also call a virtual etc.) - not very practical.</p>\n<p>So it just implements a vtable for the constructor and destructor to use during construction and destruction. It allows you to use typeid and dynamic_cast in the c'tor and d'tor with the predictable result and get reliable behaviour out of the virtual functions you have. No alternative solution would do that.</p>\n", "LastActivityDate": "2016-09-08T11:17:57.583", "CommentCount": "2", "CreationDate": "2016-09-08T11:17:57.583", "ParentId": "39389157", "Score": "-1", "OwnerUserId": "272708"}, "39392250": {"Id": "39392250", "PostTypeId": "2", "Body": "<p>vtables are implementation issues in C++, they are not part of the standard.</p>\n<p>vtables are used for both dynamic dispatching of methods and for RTTI.  While a nullptr vtable pointer would work for dynamic dispatching (as the vtable pointer is only used when you have an instance of that type) in a pure-abstract class, a <code>dynamic_cast</code> to a pure abstract class is legal, and it may require that the vtable itself exist.</p>\n<p>Designers of the C++ implementation and ABI might have simply given the purely abstract class (a class with no implemented methods, just <code>=0</code> ones) a vtable to make their implementation simpler.  Every class has a vtable, and the vtable pointer gets set during construction of that class.  Code can then rely on the fact that the vtable pointer exists and does not have to check for null every time.  Code doesn't have to ask questions like \"is this a purely abstract class\".</p>\n<p>For a non-pure abstract class (where some methods have implementations but some are pure virtual), during construction/destruction you can have defined (if unexpected) behavior that involves invoking exactly this class's version of a given method, and not the base class method or an inherited method.  For this to work, you need to have a vtable set up.  With a pure abstract class, there is no defined result of such a call, so the vtable is redundant, but for an abstract class that isn't totally abstract this does not hold.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2016-09-09T22:15:51.500", "Score": "0", "CreationDate": "2016-09-08T13:26:46.580", "ParentId": "39389157", "CommentCount": "5", "OwnerUserId": "1774667", "LastEditDate": "2016-09-09T22:15:51.500"}, "39389157": {"ViewCount": "444", "Body": "<p>Regarding <a href=\"https://stackoverflow.com/questions/2592438/does-an-abstact-classes-have-a-vtable\" title=\"this\">this</a> post:</p>\n<blockquote>\n<p id=\"so_39389157_39389157_0\">For implementations that use vtable, the answer is: Yes, usually. You\n  might think that vtable isn't required for abstract classes because\n  the derived class will have its own vtable, <strong>but it is needed during</strong>\n<strong>construction: While the base class is being constructed, it sets the</strong>\n<strong>vtable pointer to its own vtable. Later when the derived class</strong>\n<strong>constructor is entered, it will use its own vtable instead.</strong></p>\n</blockquote>\n<p>I'm assuming the answer is correct, but I don't quite get it. Why is the vtable needed exactly for construction?</p>\n", "Title": "Why does an abstract class have a vtable?", "CreationDate": "2016-09-08T10:58:05.447", "LastActivityDate": "2016-09-09T22:15:51.500", "CommentCount": "3", "LastEditDate": "2017-05-23T11:53:47.503", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "39389157", "Score": "4", "OwnerUserId": "2660756", "Tags": "<c++><constructor><abstract-class><vtable><pure-virtual>", "AnswerCount": "3"}, "39389744": {"Id": "39389744", "PostTypeId": "2", "Body": "<p>Because the standard says so.</p>\n<p><a href=\"http://eel.is/c++draft/class.cdtor#4\" rel=\"nofollow\">[class.cdtor]/4</a></p>\n<blockquote>\n<p id=\"so_39389157_39389744_0\">When a virtual function is called directly or indirectly from a\n  constructor or from a destructor, including during the construction or\n  destruction of the class's non-static data members, and the object to\n  which the call applies is the object (call it x) under construction or\n  destruction, the function called is the final overrider in the\n  constructor's or destructor's class and not one overriding it in a\n  more-derived class.</p>\n</blockquote>\n<p>The rationale is that <em>first</em> the base class is constructed, <em>then</em> the derived one. If a virtual function is called inside the base class' constructor, it would be bad to call the derived class, since the derived class isn't initialized yet.</p>\n<p>Remember that an abstract class may have non-pure virtual functions. Also, for debugging purposes, it is good to point pure virtual functions to a debugging trap (e.g. MSVC calls <code>_purecall()</code>).</p>\n", "LastActivityDate": "2016-09-08T11:29:20.843", "CommentCount": "0", "CreationDate": "2016-09-08T11:29:20.843", "ParentId": "39389157", "Score": "1", "OwnerUserId": "485343"}});