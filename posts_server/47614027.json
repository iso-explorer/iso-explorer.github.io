post_cb({"47614027": {"Tags": "<c++><language-lawyer><c++1z><class-template><argument-deduction>", "ViewCount": "26", "CreationDate": "2017-12-03T00:26:52.697", "FavoriteCount": "1", "Title": "Anonymous temporaries and class template argument deduction - gcc vs clang", "CommentCount": "0", "AnswerCount": "1", "Score": "4", "OwnerUserId": "598696", "Id": "47614027", "LastActivityDate": "2017-12-03T03:39:12.463", "Body": "<p>Consider the following code snippet:</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo\n{\n    foo(T) { }\n};\n\nint main()\n{\n    foo{0};\n}\n</code></pre>\n<p><strong>g++ 7</strong> happily creates a temporary object of type <code>foo</code>, deducing <code>T = int</code>.</p>\n<p><strong>clang++ 5 and 6</strong> refuse to compile the code:</p>\n<blockquote id=\"so_47614027_47614027_0\">\n<pre><code>error: expected unqualified-id\n    foo{0};\n       ^\n</code></pre>\n</blockquote>\n<p><a href=\"https://wandbox.org/permlink/AZDF7bb4dbs7DT5e\" rel=\"nofollow noreferrer\"><strong>live example on wandbox</strong></a></p>\n<hr>\n<p>Is this a clang bug, or is there something in the Standard that prevents <em>class template argument deduction</em> from kicking in for unnamed temporaries?</p>\n</hr>", "PostTypeId": "1"}, "47615018": {"ParentId": "47614027", "Score": "1", "CreationDate": "2017-12-03T03:39:12.463", "Id": "47615018", "OwnerUserId": "2069064", "LastActivityDate": "2017-12-03T03:39:12.463", "Body": "<p>clang bug.</p>\n<p>From <a href=\"http://eel.is/c++draft/dcl.type.class.deduct#2\" rel=\"nofollow noreferrer\">[dcl.type.class.deduct]</a>:</p>\n<blockquote>\n<p id=\"so_47614027_47615018_0\">A placeholder for a deduced class type can also be used in [...] <strong>or as the <em>simple-type-specifier</em> in an <a href=\"http://eel.is/c++draft/expr.type.conv#1\" rel=\"nofollow noreferrer\">explicit type conversion (functional notation)</a></strong>. A placeholder for a deduced class type shall not appear in any other context. \n  <em>[\u2009Example:</em></p>\n<pre><code>template&lt;class T&gt; struct container {\n    container(T t) {}\n    template&lt;class Iter&gt; container(Iter beg, Iter end);\n};\n\ntemplate&lt;class Iter&gt;\ncontainer(Iter b, Iter e) -&gt; container&lt;typename std::iterator_traits&lt;Iter&gt;::value_type&gt;;\nstd::vector&lt;double&gt; v = { /* ... */ };\n\ncontainer c(7);                         // OK, deduces int for T\nauto d = container(v.begin(), v.end()); // OK, deduces double for T\ncontainer e{5, 6};                      // error, int is not an iterator\n</code></pre>\n<p id=\"so_47614027_47615018_1\"><em>\u2014\u2009end example\u2009]</em></p>\n</blockquote>\n", "PostTypeId": "2", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_47614027_47615018_0": {"length": 19, "section_id": 6892, "quality": 0.95}}}});