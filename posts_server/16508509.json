post_cb({"16533013": {"ParentId": "16508509", "CommentCount": "0", "Body": "<p>In C++11 n3242 (which is slightly old draft) in <code>23.2.3</code> table 100 we learn that for the iterator pair <code>insert</code> function, <code>pre: i and j are not iterators into a</code>. I believe based on that wording I would choose to broadly interpret that as <code>i and j shall not access a</code>, and that both of your iterators are undefined behavior.</p>\n<p>But let's say that my broad interpretation is not what was intended by the standard. Then to answer your question, for input iterators the result is almost certainly going to be: <code>3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 5, 6, 7</code> while for forward iterators or better one of <code>3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7</code> or <code>3, 4, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 5, 6, 7</code> depending on whether the size is updated before or after the elements are copied into the open space. I don't see anywhere that the results for forward iterators in such a case would be specified.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "16533013", "Score": "1", "CreationDate": "2013-05-13T23:56:55.447", "LastActivityDate": "2013-05-13T23:56:55.447"}, "16516338": {"ParentId": "16508509", "CommentCount": "0", "Body": "<p>Basically, the only reason to invalidate iterators/references for vector is a reallocation, since otherwise you are still pointing at some part of your vector.</p>\n<p>C++11 23.3.6.3/5:</p>\n<blockquote>\n<p id=\"so_16508509_16516338_0\">Remarks: Reallocation invalidates all the references, pointers, and iterators referring to the elements\n  in the sequence. It is guaranteed that no reallocation takes place during insertions that happen after\n  a call to reserve() until the time when an insertion would make the size of the vector greater than\n  the value of capacity().</p>\n</blockquote>\n<p>This is again reiterated in the remarks to the insert functions C++11 23.3.6.5/1:</p>\n<blockquote>\n<p id=\"so_16508509_16516338_1\">Remarks: Causes reallocation if the new size is greater than the old capacity. If no reallocation happens,\n  all the iterators and references before the insertion point remain valid. [...]</p>\n</blockquote>\n<p>With <code>vector</code>, you can consider your iterators to behave very much like pointers (which shows why exactly reallocation will cause problems). In fact, the <code>reference</code> type is <code>value_type&amp;</code>, as defined by the standard, showing that references are indeed not even wrapped.</p>\n<p>Note, that the iterators' target may change by the insertion, since the underlying data changes. Also, to be standards compliant, you would need to ensure that reallocation does not happen (e.g. with a call to reserve).</p>\n", "OwnerUserId": "65678", "PostTypeId": "2", "Id": "16516338", "Score": "1", "CreationDate": "2013-05-13T06:54:13.530", "LastActivityDate": "2013-05-13T06:54:13.530"}, "16508509": {"CommentCount": "7", "AcceptedAnswerId": "16533013", "PostTypeId": "1", "LastEditorUserId": "298661", "CreationDate": "2013-05-12T14:41:37.547", "LastActivityDate": "2013-05-13T23:56:55.447", "LastEditDate": "2013-05-12T15:32:20.613", "ViewCount": "216", "FavoriteCount": "2", "Title": "How does the Standard deal with self-referencing iterators in container insert functions?", "Id": "16508509", "Score": "9", "Body": "<p>When dealing with C++ Standard Library containers like <code>std::vector</code>, how do their range-based insertion methods handle the user using iterators that reference the vector's own contents?</p>\n<p>Presumably if they are say, <code>vector::iterator</code> already, then the implementation can special-case this scenario, but if they are a user-defined type which eventually results in accessing the vector, how does the vector deal with keeping those iterators valid whilst evaluating the range? Does the Standard simply ban referencing the vector in the range?</p>\n<p>For a simple example, consider an iterator whose value_type is size_t, and the result of de-referencing it is the size of the vector being inserted into.</p>\n<pre><code>struct silly_iterator {\n    vector&lt;std::size_t&gt;* v;\n    unsigned number;\n    std::size_t operator*() { return v-&gt;size(); }\n    operator++() { --number; }\n    bool operator==(silly_iterator other) const { return number == 0; }\n    // other methods\n};\nstd::vector&lt;std::size_t&gt; vec = { 3, 4, 5, 6, 7 };\nvector.insert(vector.begin() + 2, silly_iterator(&amp;vec, 10), silly_iterator());\n</code></pre>\n<p>What is the contents of <code>vec</code> after this code has executed?</p>\n<p>For another example,</p>\n<pre><code>struct silly_iterator { \n    std::vector&lt;std::size_t&gt;* v; \n    std::size_t operator*() { return 0; } \n    operator++() { --number; v-&gt;push_back((*v)[4]); } \n    bool operator==(silly_iterator other) const { return number == 0; } \n    // other methods \n}; \nstd::vector&lt;std::size_t&gt; vec = { 3, 4, 5, 6, 7 }; \nvec.insert(vec.begin() + 2, silly_iterator(&amp;vec, 10), silly_iterator());\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "298661", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_16508509_16516338_0": {"section_id": 972, "quality": 0.90625, "length": 29}, "so_16508509_16516338_1": {"section_id": 986, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_16508509_16516338_0": {"section_id": 961, "quality": 0.96875, "length": 31}, "so_16508509_16516338_1": {"section_id": 971, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_16508509_16516338_0": {"section_id": 1034, "quality": 0.90625, "length": 29}, "so_16508509_16516338_1": {"section_id": 1049, "quality": 0.9473684210526315, "length": 18}}}});