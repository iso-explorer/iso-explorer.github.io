post_cb({"40070352": {"CommentCount": "3", "ViewCount": "88", "PostTypeId": "1", "LastEditorUserId": "6695690", "CreationDate": "2016-10-16T12:40:43.800", "LastActivityDate": "2016-10-16T13:13:56.730", "Title": "Strict aliasing rule violation", "AcceptedAnswerId": "40070652", "LastEditDate": "2016-10-16T13:03:12.227", "Id": "40070352", "Score": "2", "Body": "<p>In this <a href=\"https://isocpp.org/wiki/faq/dtors#placement-new\" rel=\"nofollow\">link from the isocpp.org faq</a> in the example provided, a Fred object is being constructed with placement new to a buffer that is being allocated for another object i.e. for </p>\n<pre><code>char memory[sizeof(Fred)]\n</code></pre>\n<p>As I know the strict aliasing rules allows us to do the opposite i.e. for an object of whatever type, we are allowed to have a <code>char*</code> point at it and we can dereference that pointer and use it as we want.</p>\n<p>But here in the example the opposite is happening. What am I missing?</p>\n", "Tags": "<c++><strict-aliasing>", "OwnerUserId": "6695690", "AnswerCount": "2"}, "40070428": {"ParentId": "40070352", "CommentCount": "3", "Body": "<p>The strict aliasing rules doesn't mention that <code>Fred*</code> must be cast to <code>char*</code>. Only that variables of type <code>char*</code> and <code>Fred*</code> may point to the same object, and be used to access it.</p>\n<p>Quoting <a href=\"http://eel.is/c++draft/basic.lval#8\" rel=\"nofollow\">[basic.lval] paragraph 8</a></p>\n<blockquote>\n<p id=\"so_40070352_40070428_0\">If a program attempts to access the stored value of an object through\n  a glvalue of other than one of the following types the behavior is\n  undefined:</p>\n<ul>\n<li><p id=\"so_40070352_40070428_1\">the dynamic type of the object,</p>\n<p id=\"so_40070352_40070428_2\">[..]</p></li>\n<li><p id=\"so_40070352_40070428_3\">a char or unsigned char type.</p></li>\n</ul>\n</blockquote>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "40070428", "Score": "2", "CreationDate": "2016-10-16T12:49:15.627", "LastActivityDate": "2016-10-16T12:49:15.627"}, "40070652": {"ParentId": "40070352", "CommentCount": "7", "Body": "<p>Placement-new creates a new object. It doesn't alias the old object. The old object (the <code>char</code> array in this example) is considered to stop existing when the placement-new executes. </p>\n<p>Before placement-new, there is storage filled with <code>char</code> objects. After placement-new, there is storage filled with one <code>Fred</code> object.</p>\n<p>Since there is no aliasing, there are no strict-aliasing problems.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "40070652", "Score": "1", "CreationDate": "2016-10-16T13:13:56.730", "LastActivityDate": "2016-10-16T13:13:56.730"}, "bq_ids": {"n4140": {"so_40070352_40070428_0": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_40070352_40070428_3": {"section_id": 45, "quality": 1.0, "length": 4}}, "n3337": {"so_40070352_40070428_0": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_40070352_40070428_3": {"section_id": 42, "quality": 1.0, "length": 4}}, "n4659": {"so_40070352_40070428_0": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_40070352_40070428_3": {"section_id": 46, "quality": 1.0, "length": 4}}}});