post_cb({"bq_ids": {"n4140": {"so_48489861_48491775_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4660}}, "n3337": {"so_48489861_48491775_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4470}}, "n4659": {"so_48489861_48491775_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6020}}}, "48491775": {"Id": "48491775", "PostTypeId": "2", "Body": "<p>From C++11 Standard \u00a7 20.8.11.2:</p>\n<blockquote>\n<pre><code>template&lt;class R, class... ArgTypes&gt;\nclass function&lt;R(ArgTypes...)&gt; { /* ... */ };\n\ntemplate&lt;class F&gt; function(F f);\n</code></pre>\n<p id=\"so_48489861_48491775_0\">Requires: <code>f</code> shall be <em>Callable</em> for argument types <code>ArgTypes</code>\n  and return type <code>R</code>.</p>\n</blockquote>\n<p>In your first case, <em>Callable</em> means that </p>\n<pre><code>INVOKE(f, declval&lt;string&gt;(), declval&lt;string&gt;(), bool)\n</code></pre>\n<p>is well formed, where <code>f</code> is lambda and <code>declval</code> represents rvalue objects of type <code>string</code>. Since rvalues cannot be bound to <em>non-const lvalue references</em>, this condition is not satisfied here.</p>\n<p>On the contrary, rvalues can be bound to <em>const lvalue references</em>, thus the second case is ok.</p>\n", "LastEditorUserId": "580083", "LastActivityDate": "2018-01-28T22:13:16.010", "Score": "1", "CreationDate": "2018-01-28T21:58:20.993", "ParentId": "48489861", "CommentCount": "0", "OwnerUserId": "580083", "LastEditDate": "2018-01-28T22:13:16.010"}, "48489861": {"ViewCount": "89", "Body": "<p>The following line gives error in c++ 11: </p>\n<pre><code>function&lt;bool(string,string)&gt; comp = [] (string&amp; s1, string&amp; s2) {return s1.length() &gt; s2.length(); };\n</code></pre>\n<p>but this does not:</p>\n<pre><code>function&lt;bool(string,string)&gt; comp = [] (const string&amp; s1, const string&amp; s2) {return s1.length() &gt; s2.length(); };\n</code></pre>\n<p>The second call has const in parameters. Any explanation?</p>\n", "AcceptedAnswerId": "48495692", "Title": "C++ lambda to std::function error with non const strings", "CreationDate": "2018-01-28T18:25:47.240", "Id": "48489861", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2018-01-29T06:53:09.150", "Score": "0", "OwnerUserId": "2018942", "Tags": "<c++><c++11><lambda>", "AnswerCount": "3"}, "48495692": {"Id": "48495692", "PostTypeId": "2", "Body": "<p>In your first case,</p>\n<pre><code>function&lt;bool(string,string)&gt; comp = [] (string&amp; s1, string&amp; s2) {return s1.length() &gt; s2.length(); };\n</code></pre>\n<p>you are trying to compile something like this:</p>\n<pre><code>bool comp(string&amp; s1, string&amp; s2){/*...*/}\ncomp(string(), string());//passing a lvalue reference to a rvalue \n</code></pre>\n<p>The error here is you are trying to get a non-const lvalue reference to a rvalue, that's a violation of standard.</p>\n<p>Fixing solution 1, using <code>function&lt;bool(string &amp;, string &amp;)&gt;</code>(I think you probably trying to using this version):</p>\n<pre><code>function&lt;bool(string&amp;,string&amp;)&gt; comp = [] (string&amp; s1, string&amp; s2) {return s1.length() &gt; s2.length(); };\n</code></pre>\n<p>Fixing solution 2, using rvalue reference:</p>\n<pre><code>function&lt;bool(string,string)&gt; comp = [] (string&amp;&amp; s1, string&amp;&amp; s2) {return s1.length() &gt; s2.length(); };\n</code></pre>\n<p>In your second case,</p>\n<pre><code>function&lt;bool(string,string)&gt; comp = [] (const string&amp; s1, const string&amp; s2) {return s1.length() &gt; s2.length(); };\n</code></pre>\n<p>you are trying to get a const lvalue reference to a rvalue, and this violates nothing of standard.</p>\n", "LastEditorUserId": "6243726", "LastActivityDate": "2018-01-29T06:53:09.150", "Score": "0", "CreationDate": "2018-01-29T06:41:27.613", "ParentId": "48489861", "CommentCount": "0", "OwnerUserId": "6243726", "LastEditDate": "2018-01-29T06:53:09.150"}, "48490441": {"Id": "48490441", "PostTypeId": "2", "Body": "<p>It doesn't really have anything to do with lambdas. When you declare a function as taking a <em>const reference</em>, you activate <a href=\"http://%20http://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary%20%22lifetime%20extension%22.\" rel=\"nofollow noreferrer\">lifetime extension</a>.</p>\n<pre><code>void foo(const std::string&amp; ref){ . . . }\nvoid bar(std::string&amp; ref){ . . . }\n\nfoo(std::string(\"hello\")); \n</code></pre>\n<p>Is allowed - the lifetime of the string containing hello is <em>extended</em> throughout the exection of <code>foo</code>.</p>\n<p>For non-const references, there is no such extension rule, so the compiler will not allow:</p>\n<pre><code>bar(std::string(\"farewell\")); \n</code></pre>\n<p>because if it did, at the point <code>foo</code> starts, it would only have a reference to the destructed remnants of what was once the farewell string.</p>\n", "LastActivityDate": "2018-01-28T19:28:24.923", "CommentCount": "0", "CreationDate": "2018-01-28T19:28:24.923", "ParentId": "48489861", "Score": "1", "OwnerUserId": "1149664"}});