post_cb({"bq_ids": {"n4140": {"so_8098858_8100124_0": {"length": 24, "quality": 1.0, "section_id": 91}}, "n3337": {"so_8098858_8100124_0": {"length": 24, "quality": 1.0, "section_id": 86}}}, "8099951": {"PostTypeId": "2", "Body": "<p>Do  you really need to pass nullObject instance as part of the template?  Could you do it through a constructor instead?</p>\n<p>The following compiles using g++</p>\n<pre><code>#include &lt;string&gt;\n\n\ntemplate &lt;class object_t, long size&gt;\nclass lf_deque\n{\npublic:\n    lf_deque(const object_t&amp; nullObject){\n        //...\n    };\n\nprotected:\n    lf_deque(){\n        // ... \n    };  \n};\n\nint main(){\n\n    lf_deque&lt;int,10&gt; intDeque(0);\n    lf_deque&lt;std::string,10&gt; myStringDeque(\"\");\n\n    int myInt = 4;\n    lf_deque&lt;int*,10&gt; intPtrDeque(&amp;myInt);\n\n    lf_deque&lt;int*,10&gt; intPtrDequeZero(0);\n\n    return 0;\n}\n</code></pre>\n<p>If this isn't workable maybe you could store the value as a static member instead.</p>\n<pre><code>#include &lt;string&gt;\n\ntemplate &lt;class object_t, long size&gt;\nclass lf_deque \n{\npublic:\n    lf_deque(){\n        //..\n    }\n    static object_t nullObject;\n};\ntemplate&lt;class object_t, long size&gt; object_t lf_deque&lt;object_t,size&gt;::nullObject;\n\nint main(){\n\n    lf_deque&lt;int,10&gt;::nullObject = 0;\n    lf_deque&lt;int,10&gt; intDeque;\n\n    lf_deque&lt;int*,10&gt;::nullObject = 0;\n    lf_deque&lt;int*,10&gt; intPtrDeque;\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2011-11-14T14:49:23.173", "LastEditorUserId": "620304", "Id": "8099951", "CommentCount": "3", "CreationDate": "2011-11-11T21:03:44.360", "ParentId": "8098858", "Score": "2", "OwnerUserId": "620304", "LastEditDate": "2011-11-14T14:49:23.173"}, "8100124": {"PostTypeId": "2", "Body": "<p>Here's what the standard (ISO/IEC 14882:2011(E)) has to say, in \"14.3.21 Template non-type arguments [temp.arg.nontype] [#5], page 331:</p>\n<blockquote>\n<p id=\"so_8098858_8100124_0\">Although 0 is a valid template-argument for a non-type template-parameter of\n  integral type, it is not\n  a valid template-argument for a non-type template-parameter of pointer type. However, both <code>(int*)0</code>\n  and <code>nullptr</code> are valid template-arguments for a non-type template-parameter of type \u201cpointer to int.\u201d</p>\n</blockquote>\n<p>In particular, argument dependent lookup has nothing to do in this case, the reason of the error is that the only allowed conversions for a pointer nontype  template argument are: qualification conversions, array-to-pointer conversion\n or, if the template argument is of type <code>std::nullptr_t</code> - null pointer conversion.</p>\n", "LastActivityDate": "2011-11-11T21:31:18.263", "LastEditorUserId": "390807", "Id": "8100124", "CommentCount": "0", "CreationDate": "2011-11-11T21:21:32.623", "ParentId": "8098858", "Score": "3", "OwnerUserId": "390807", "LastEditDate": "2011-11-11T21:31:18.263"}, "8098895": {"PostTypeId": "2", "Body": "<p>In templates when a function/class is resolved with <strike>ADL(Argument Dependent Lookup)</strike> <em>Function Template Argument Deduction</em>, there is no implicit conversion. Only exactly matching paramters can resolve to instantiate a appropriate template function/class. That is the root cause of the error.  </p>\n<p>The compiler tells you that it cannot implicitly convert last parameter <code>0</code> to <code>int *</code>, Since when you pass first argument as <code>int *</code>, <code>object_t</code> is <code>int *</code> and the compiler expects an <code>int *</code> as the third argument as well. It tells you that <code>0</code> is an invalid type as the third argument for the class template.</p>\n", "LastActivityDate": "2011-11-14T17:23:48.907", "LastEditorUserId": "452307", "Id": "8098895", "CommentCount": "4", "CreationDate": "2011-11-11T19:24:52.563", "ParentId": "8098858", "Score": "3", "OwnerUserId": "452307", "LastEditDate": "2011-11-14T17:23:48.907"}, "8098858": {"ViewCount": "1594", "Body": "<p>I am trying to implement a template </p>\n<pre><code>template &lt;class object_t, long size, object_t nullObject&gt;\nclass lf_deque\n{\n  // ...\n}\n</code></pre>\n<p>when I try to instantiate this template with an int, it compiles fine, but if I try to instantiate with a pointer i get the error:</p>\n<pre><code>could not convert template argument '0' to 'int*'\n</code></pre>\n<p><b></b></p>\n<pre><code>lf_deque&lt;int,  10, 0&gt; intDeque; // WORKS\nlf_deque&lt;int*, 10, 0&gt; ptrDeque; // ERROR\n</code></pre>\n<p>any thoughts or ideas why i would get this inconsistency?</p>\n", "AcceptedAnswerId": "8098895", "Title": "C++ Template w/ Pointers - Could not convert template argument", "CreationDate": "2011-11-11T19:21:36.257", "Id": "8098858", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-11-14T17:23:48.907", "Score": "3", "OwnerUserId": "439274", "Tags": "<c++><templates>", "AnswerCount": "3"}});