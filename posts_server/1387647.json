post_cb({"1387647": {"ViewCount": "1751", "Body": "<p>When using C++ STL containers, under what conditions must reference values be accessed?\nFor example are any references invalidated after the next function call to the container?</p>\n<pre><code>{\nstd::vector&lt;int&gt; vector;\nvector.push_back (1);\nvector.push_back (2);\nvector.push_back (3);\n\nvector[0] = 10;       //modifies 0'th element\n\nint&amp; ref = vector[0];\nref = 10;             //modifies 0'th element\n\nvector.push_back (4);\nref = 20;             //modifies 0'th element???\n\nvector.clear ();\nref = 30;             //clearly obsurd\n}\n</code></pre>\n<p>I understand that in most implementations of the stl this would work, but I'm interested in what the standard declaration requires.</p>\n<p>--edit:\nIm interested becuase I wanted to try out the STXXL (<a href=\"http://stxxl.sourceforge.net/\" rel=\"noreferrer\">http://stxxl.sourceforge.net/</a>) library for c++, but I realised that the references returned by the containers were not persistent over multiple reads, and hence not compatible without making changes (however superficial) to my existing stl code. An example:</p>\n<pre><code>{\nstd::vector&lt;int&gt; vector;\nvector.push_back (1);\nvector.push_back (2);\n\n\nint&amp; refA = vector[0];\nint&amp; refB = vector[1]; //refA is not gaurenteed to be valid anymore\n}\n</code></pre>\n<p>I just wanted to know if this meant that STXXL containers where not 100% compatible, or indeed if I had been using STL containers in an unsafe/implementation dependant way the whole time.</p>\n", "AcceptedAnswerId": "1387747", "Title": "Persistant references in STL Containers", "CreationDate": "2009-09-07T05:18:26.180", "Id": "1387647", "CommentCount": "3", "LastEditDate": "2009-09-07T06:43:48.287", "PostTypeId": "1", "LastEditorUserId": "40175", "LastActivityDate": "2009-09-07T06:43:48.287", "Score": "6", "OwnerUserId": "40175", "Tags": "<c++><stl>", "AnswerCount": "4"}, "1387676": {"Id": "1387676", "PostTypeId": "2", "Body": "<p>Vector will invalidate its iterator and references when it reallocates, which depends upon  its current capacity. Although the above code might work in some cases, you shouldn't rely on this as the reference might be invalidated after the push_back(4) call.</p>\n", "LastActivityDate": "2009-09-07T05:30:09.303", "Score": "1", "CreationDate": "2009-09-07T05:30:09.303", "ParentId": "1387647", "CommentCount": "0", "OwnerUserId": "39742"}, "bq_ids": {"n4140": {"so_1387647_1387747_1": {"length": 5, "quality": 0.625, "section_id": 820}, "so_1387647_1387747_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 986}}, "n3337": {"so_1387647_1387747_1": {"length": 5, "quality": 0.625, "section_id": 809}, "so_1387647_1387747_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 971}}, "n4659": {"so_1387647_1387747_1": {"length": 6, "quality": 0.75, "section_id": 879}, "so_1387647_1387747_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 1049}}}, "1387728": {"Id": "1387728", "PostTypeId": "2", "Body": "<p>Some basic rules for vector:</p>\n<ul>\n<li>Reallocation invalidates all\nreferences, pointers, and iterators\nfor elements of the vector.</li>\n<li>Insertions <em>may</em> invalidate references,\npointers, and iterators.</li>\n<li>Inserting or removing elements\ninvalidates references, pointers, and\niterators that refer to the following\nelements.</li>\n<li>If an insertion causes reallocation,\nit invalidates all references,\niterators, and pointers.</li>\n</ul>\n", "LastActivityDate": "2009-09-07T05:50:51.180", "Score": "7", "CreationDate": "2009-09-07T05:50:51.180", "ParentId": "1387647", "CommentCount": "1", "OwnerUserId": "64960"}, "1387747": {"Id": "1387747", "PostTypeId": "2", "Body": "<p>About inserting into vectors, the standard says in 23.2.4.3/1:</p>\n<blockquote>\n<p id=\"so_1387647_1387747_0\">[<code>insert()</code>] causes reallocation if the\n  new size is greater than the old\n  capacity. If no reallocation happens,\n  all the iterators and references\n  before the insertion point remain\n  valid.</p>\n</blockquote>\n<p>(Although this in fact this talks about <code>insert()</code>, Table 68 indicates that <code>a.push_back(x)</code> must be equivalent to <code>a.insert(a.end(), x)</code> for any vector <code>a</code> and value <code>x</code>.)  This means that if you <code>reserve()</code> enough memory beforehand, then (and only then) iterators and references are guaranteed not to be invalidated when you <code>insert()</code> or <code>push_back()</code> more items.</p>\n<p>Regarding removing items, 23.2.4.3/3 says:</p>\n<blockquote>\n<p id=\"so_1387647_1387747_1\">[<code>erase()</code>] invalidates all the\n  iterators and references after the\n  point of the erase.</p>\n</blockquote>\n<p>According to Table 68 and Table 67 respectively, <code>pop_back()</code> and <code>clear()</code> are equivalent to appropriate calls to <code>erase()</code>.</p>\n", "LastActivityDate": "2009-09-07T05:58:36.857", "Score": "12", "CreationDate": "2009-09-07T05:58:36.857", "ParentId": "1387647", "CommentCount": "4", "OwnerUserId": "47984"}, "1387655": {"Id": "1387655", "PostTypeId": "2", "Body": "<p>I expect that references would be invalidated only by any explicit or implicit <code>resize()</code> (see also the <code>max_size</code>, <code>capacity</code>, and <code>reserve</code> methods).</p>\n", "LastActivityDate": "2009-09-07T05:22:14.590", "Score": "1", "CreationDate": "2009-09-07T05:22:14.590", "ParentId": "1387647", "CommentCount": "2", "OwnerUserId": "49942"}});