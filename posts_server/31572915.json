post_cb({"31574338": {"ParentId": "31572915", "CommentCount": "3", "Body": "<p>The comments suggest that MSVC 2008 uses a temporary that g++ doesn't, to pass the parameter. If so, this is a bug. From C++03 [dcl.init]/12:</p>\n<blockquote>\n<p id=\"so_31572915_31574338_0\">The initialization that occurs in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and brace-enclosed initializer lists (8.5.1) is called <em>copy-initialization</em> and is equivalent to the form\n  <code>T x = a;</code></p>\n</blockquote>\n<p>Now here is the crucial bit.  In <code>T x = a;</code>, if <code>a</code> is <em>not</em> a <code>T</code> or derived from <code>T</code>, then that is equivalent to <code>T x = T(a);</code>, and an extra temporary is conceptually used. (This temporary is eligible for copy-elision).</p>\n<p>However, if <code>a</code> is a <code>T</code> or derived from <code>T</code>, then there must not be an extra temporary.It is the same as <code>T x(a);</code>.</p>\n<p>In this question's code, since <code>B</code> derives from <code>A</code>, there must not be a temporary.</p>\n<p>The supporting text in C++03 is under [dcl.init]/14 (I have highlighted the parts relevant to this question's code sample):</p>\n<blockquote>\n<p id=\"so_31572915_31574338_1\">If the destination type is a (possibly cv-qualified) class type:</p>\n<ul>\n<li>If the class is an aggregate (8.5.1), and the initializer is a brace-enclosed list, see 8.5.1.</li>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, <strong>or a derived class of</strong>, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). <strong>The constructor so selected is called to initialize the object, with the initializer expression(s) as its argument(s)</strong>. If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n<li><strong>Otherwise</strong> (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed. The function selected is called with the initializer expression as its argument; if the function is a constructor, <strong>the call initializes a temporary</strong> of the destination type. The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization. In certain cases, an imple-\n  mentation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "31574338", "Score": "5", "CreationDate": "2015-07-22T21:30:50.570", "LastActivityDate": "2015-07-22T21:30:50.570"}, "bq_ids": {"n4140": {"so_31572915_31574338_1": {"section_id": 3296, "quality": 1.0, "length": 6}, "so_31572915_31574338_0": {"section_id": 3294, "quality": 0.5238095238095238, "length": 11}}, "n3337": {"so_31572915_31574338_1": {"section_id": 3166, "quality": 1.0, "length": 6}, "so_31572915_31574338_0": {"section_id": 3164, "quality": 0.5238095238095238, "length": 11}}, "n4659": {"so_31572915_31574338_1": {"section_id": 4058, "quality": 1.0, "length": 6}, "so_31572915_31574338_0": {"section_id": 4056, "quality": 0.5238095238095238, "length": 11}}}, "31572915": {"CommentCount": "18", "AcceptedAnswerId": "31574338", "PostTypeId": "1", "LastEditorUserId": "2757035", "CreationDate": "2015-07-22T20:02:07.930", "LastActivityDate": "2015-07-22T21:30:50.570", "LastEditDate": "2015-07-22T20:45:24.257", "ViewCount": "186", "FavoriteCount": "2", "Title": "Spurious C++ destructor call under Visual Studio 2008 (absent under GCC)", "Id": "31572915", "Score": "12", "Body": "<p>Take the following (contrived) class hierarchy that prints to the console from the constructors and destructors:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A { \npublic:\n  A() { std::cout &lt;&lt; \"A\"; }\n  ~A() { std::cout &lt;&lt; \"~A\"; } \n};\n\nclass B : public A { \npublic:   \n  B() { std::cout &lt;&lt; \"B\"; }\n  ~B() { std::cout &lt;&lt; \"~B\"; } \n};\n\nvoid func(A a) { }\n\nint main() {   \n  B b;\n  func(b);\n  std::cout &lt;&lt; \"X\";\n  return 0; \n}\n</code></pre>\n<p>Compiled under linux with gcc, it prints <code>AB~AX~B~A</code> as expected (the <code>~A</code> printed before <code>X</code> is a result of the pass-by-value to <code>func</code> which creates a copy that is destructed when the function returns). </p>\n<p>But compiled under windows with VS2008 it prints <code>AB~A~AX~B~A</code> - where does the extra <code>~A</code> come from? It vanishes if the copy xtor is explicitly defined <code>A(A&amp; that) {};</code> or if the destructor is declared virtual (as it should be, arguably).</p>\n", "Tags": "<c++><visual-c++><gcc>", "OwnerUserId": "2948126", "AnswerCount": "1"}});