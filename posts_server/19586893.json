post_cb({"19595117": {"ParentId": "19586893", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, there was a change between C++98 and C++11. I believe your example to be well-defined under C++11 rules, while exhibiting undefined behavior under C++98 rules.</p>\n<p>As a simpler example, <code>x = ++x;</code> is undefined in C++98 but is well-defined in C++11. Note that <code>x = x++;</code> is still undefined (side effect of post-increment is unsequenced with the evaluation of the expression, while side effect of pre-increment is sequenced before the same).</p>\n", "OwnerUserId": "1670129", "LastEditorUserId": "1670129", "LastEditDate": "2013-10-25T16:57:35.660", "Id": "19595117", "Score": "7", "CreationDate": "2013-10-25T16:34:35.037", "LastActivityDate": "2013-10-25T16:57:35.660"}, "19670459": {"ParentId": "19586893", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>After doing a little research, I am convinced your codes behaviour is well defined in C++11.</p>\n<p>$1.9/15 states:</p>\n<blockquote>\n<p id=\"so_19586893_19670459_0\">The value computations of the operands of an operator are sequenced before\n  the value computation of the result of the operator.</p>\n</blockquote>\n<p>$5.17/1 states:</p>\n<blockquote>\n<p id=\"so_19586893_19670459_1\">The assignment operator (<code>=</code>) and the compound assignment operators all group\n  right-to-left.</p>\n</blockquote>\n<p>If I understand correctly, in your example</p>\n<pre><code>a = (a+=1) = 10;\n</code></pre>\n<p>this implies that the value computations of <code>(a+=1)</code> and <code>10</code> have to be made before the value computation of <code>(a+=1) = 10</code> and the value computation of this expression has to be finished before <code>a = (a+=1) = 10;</code> is evaluated.  </p>\n<p>$5.17/1 states:</p>\n<blockquote>\n<p id=\"so_19586893_19670459_2\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>This implies that the assignment must happen before the value computation, and therefore, due to transitivity, the evaluation of <code>(a+=1) = 10</code> can only begin after the assignment <code>a+=1</code> (Because its value may only be computed after the side effect).</p>\n<p>The same is true for the second and third assignment.</p>\n<p>See also this <a href=\"https://stackoverflow.com/a/9581666/1760583\">excellent answer</a>, which explains the sequenced-before relation in much more detail and way better than I could.</p>\n", "OwnerUserId": "1760583", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:59.333", "Id": "19670459", "Score": "3", "CreationDate": "2013-10-29T22:34:32.830", "LastActivityDate": "2013-10-30T11:40:05.637"}, "19586893": {"CommentCount": "3", "AcceptedAnswerId": "19682808", "PostTypeId": "1", "LastEditorUserId": "1961634", "CreationDate": "2013-10-25T10:06:40.773", "LastActivityDate": "2017-02-19T14:38:22.233", "LastEditDate": "2013-10-25T11:32:57.410", "ViewCount": "2001", "FavoriteCount": "2", "Title": "Double assignment of the same variable in one expression in C++11", "Id": "19586893", "Score": "10", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">The C++11 standard</a> (5.17, expr.ass) states that </p>\n<blockquote>\n<p id=\"so_19586893_19586893_0\">In all cases, the assignment is sequenced after the value computation\n  of the right and left operands, and before the value computation of\n  the assignment expression. With respect to an\n  indeterminately-sequenced function call, the operation of a compound\n  assignment is a single evaluation</p>\n</blockquote>\n<p>As I understand it, all expressions which are a part of the given assignment will be evaluated before the assignment itself. This rule should work even if I modify the same variable twice in the same assignment, which, I am fairly certain, was undefined behavior before.</p>\n<p>Will the given code:</p>\n<pre><code>int a = 0;\na = (a+=1) = 10;\n\nif ( a == 10 ) {\n    printf(\"this is defined\");\n} else {\n    printf(\"undefined\"); \n}\n</code></pre>\n<p>always evaluate to <code>a==10</code>?</p>\n", "Tags": "<c++><c++11><variable-assignment><order-of-evaluation><expression-evaluation>", "OwnerUserId": "1961634", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_19586893_19670459_1": {"section_id": 6173, "quality": 0.8888888888888888, "length": 8}, "so_19586893_19670459_2": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_19586893_19670459_0": {"section_id": 5811, "quality": 0.9090909090909091, "length": 10}, "so_19586893_19682808_0": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_19586893_19586893_0": {"section_id": 6173, "quality": 0.96, "length": 24}}, "n3337": {"so_19586893_19670459_1": {"section_id": 5934, "quality": 0.8888888888888888, "length": 8}, "so_19586893_19670459_2": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_19586893_19670459_0": {"section_id": 5584, "quality": 0.9090909090909091, "length": 10}, "so_19586893_19682808_0": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_19586893_19586893_0": {"section_id": 5934, "quality": 0.96, "length": 24}}, "n4659": {"so_19586893_19670459_1": {"section_id": 7675, "quality": 0.8888888888888888, "length": 8}, "so_19586893_19670459_2": {"section_id": 7675, "quality": 1.0, "length": 15}, "so_19586893_19670459_0": {"section_id": 7272, "quality": 0.9090909090909091, "length": 10}, "so_19586893_19586893_0": {"section_id": 7675, "quality": 0.96, "length": 24}, "so_19586893_19682808_0": {"section_id": 7675, "quality": 1.0, "length": 15}}}, "19682808": {"ParentId": "19586893", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Let's rewrite your code as</p>\n<pre><code>E1 = (E2 = E3)\n</code></pre>\n<p>where E1 is the expression <code>a</code>, E2 is the expression <code>a += 1</code> and E3 is the expression <code>10</code>. Here we ussed, that the assignment operator groups right-to-left (\u00a75.17/1 in C++11 Standard).</p>\n<p>\u00a75.17/1 moreover states:</p>\n<blockquote>\n<p id=\"so_19586893_19682808_0\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>Applying this to our expression means that we first must evaluate the subexpressions <code>E1</code> and <code>E2 = E3</code>. Note that there is no \"sequenced-before\" relationship between these two evaluations, but that causes no problems.</p>\n<p>The evaluation of the <em>id-expression</em> <code>E1</code> is trivial (the result is <code>a</code> itself). The evaluation of the <em>assignment-expression</em> <code>E2 = E3</code> proceeds as follows: </p>\n<p>First both subexpressions have to be evaluated. The evaluation of the <em>literal</em> <code>E3</code>is again trivial (gives a prvalue of value 10).</p>\n<p>The evaluation of the (compound) <em>assignment-expression</em> <code>E2</code> is done in the following steps:</p>\n<p>1) The behavior of <code>a += 1</code>is equivalent to <code>a = a + 1</code> but <code>a</code> is only evaluated once (\u00a75.17/7). After evaluating the subexpressions <code>a</code> and <code>1</code> (in an arbitrary order), an <em>lvalue-to-rvalue</em> conversion is applied to <code>a</code> in order to read the value stored in <code>a</code>.</p>\n<p>2) The values of <code>a</code> (which is <code>0</code>) and of <code>1</code> are added (<code>a + 1</code>) and the result of this addition is a prvalue of value <code>1</code>.</p>\n<p>3) Before we can compute the result of the assignment <code>a = a + 1</code> the value of the object the left operand refers to is replaced by the value of the right operand (\u00a75.17/2). The result of <code>E2</code> is then an lvalue refereing to the new value <code>1</code>. Note that the side effect (updating the value of the left operand) is sequenced before the value computation of the assignment expression. This is \u00a75.17/1 cited above.</p>\n<p>Now that we have evaluated the subexpressions <code>E2</code>and <code>E3</code>, the value of the expression <code>E2</code>refers to is replaced by the value of <code>E3</code>, which is <code>10</code>. Hence the result of <code>E2 = E3</code> is an lvalue of value <code>10</code>.</p>\n<p>Finally, the value expression <code>E1</code> refers to is replaced by the value of the expression <code>E2 = E3</code>, which we computed to be <code>10</code>. Thus, the variable <code>a</code>ends up to contain the value <code>10</code>.</p>\n<p>Since all these steps are well-defined, the whole expression yields a well-defined value.</p>\n", "OwnerUserId": "1770418", "LastEditorUserId": "1033581", "LastEditDate": "2017-02-19T14:38:22.233", "Id": "19682808", "Score": "6", "CreationDate": "2013-10-30T12:54:25.620", "LastActivityDate": "2017-02-19T14:38:22.233"}});