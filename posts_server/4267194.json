post_cb({"4267234": {"Id": "4267234", "PostTypeId": "2", "Body": "<p>The parameter is pass by value. In the function call, f(-n1), the operator is applied before passing the parameter to the function. Hence the warning. </p>\n", "OwnerDisplayName": "JP19", "LastActivityDate": "2010-11-24T13:23:53.950", "Score": "2", "CreationDate": "2010-11-24T13:23:53.950", "ParentId": "4267194", "CommentCount": "0"}, "4267194": {"ViewCount": "4676", "Body": "<p>I have this sample code which generates the following warning (VS2008 compiler with SP1):</p>\n<blockquote>\n<p id=\"so_4267194_4267194_0\">warning C4146: unary minus operator\n  applied to unsigned type, result still\n  unsigned</p>\n</blockquote>\n<p>Code:</p>\n<pre><code>void f(int n)\n{\n}\n\nint main()\n{\n    unsigned int n1 = 9;\n    f(-n1);\n}\n</code></pre>\n<p>But since function <code>f</code> is taking it's parameter as an <code>int</code> shouldn't this code compile without any warnings?</p>\n", "AcceptedAnswerId": "4267258", "Title": "Compiler warning for unary operation on unsigned int", "CreationDate": "2010-11-24T13:18:16.223", "Id": "4267194", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-07-11T12:01:52.270", "Score": "6", "OwnerUserId": "39742", "Tags": "<c++><compiler-warnings><unsigned>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_4267194_4267258_0": {"length": 34, "quality": 0.918918918918919, "section_id": 6071}, "so_4267194_4267258_1": {"length": 20, "quality": 0.6060606060606061, "section_id": 21}}, "n3337": {"so_4267194_4267258_0": {"length": 34, "quality": 0.918918918918919, "section_id": 5839}, "so_4267194_4267258_1": {"length": 20, "quality": 0.6060606060606061, "section_id": 18}}, "n4659": {"so_4267194_4267258_0": {"length": 34, "quality": 0.918918918918919, "section_id": 7567}, "so_4267194_4267258_1": {"length": 20, "quality": 0.6060606060606061, "section_id": 21}}}, "4952076": {"Id": "4952076", "PostTypeId": "2", "Body": "<p>The compiler is warning you that applying unary minus to an unsigned int is an unusual thing to do and may not give the result you expect. The result you get in this case will be equivalent to calling f(4294967287u) if you are using a 32-bit compiler.</p>\n", "LastActivityDate": "2011-02-10T00:18:57.840", "CommentCount": "0", "CreationDate": "2011-02-10T00:18:57.840", "ParentId": "4267194", "Score": "0", "OwnerUserId": "610614"}, "4267205": {"Id": "4267205", "PostTypeId": "2", "Body": "<p>if <code>x</code> is of type <code>unsigned int</code>, then so is <code>-x</code> and it is virtually equivalent to <code>2<sup>n</sup>-x</code> (where <code>n</code> is most likely 32). To avoid the warning <em>and</em> get correct behavior, cast to <code>int</code>:</p>\n<pre><code>f(-static_cast&lt;int&gt;(n));\n</code></pre>\n<p>I would recommend reading the \"Expressions\" chapter of the C++ standard. There you'll see that in the expression <code>-x</code> integral promotions take place on <code>x</code>, which means that almost anything gets promoted to <code>int</code>, but <code>unsigned int</code> is not. </p>\n<p>Look at this very interesting example:</p>\n<pre><code>template&lt;class T&gt;\nvoid f(T x)\n{\n  //somehow print type info about x, e.g. cout &lt;&lt; typeid(x).name() or something\n}\n\nint main()\n{\n  char x;\n  f(x);\n  f(+x);\n  f(-x);\n}\n</code></pre>\n<p>prints:</p>\n<pre><code>char\nint \nint\n</code></pre>\n<p>But <code>char</code> -&gt; <code>int</code> is an integral promotion, whereas <code>unsigned int</code> -&gt; <code>int</code> is a conversion</p>\n", "LastEditorUserId": "1336150", "LastActivityDate": "2013-07-11T12:01:52.270", "Score": "15", "CreationDate": "2010-11-24T13:19:42.620", "ParentId": "4267194", "CommentCount": "2", "OwnerUserId": "469935", "LastEditDate": "2013-07-11T12:01:52.270"}, "4267258": {"Id": "4267258", "PostTypeId": "2", "Body": "<p>Standard 5.3.1/7</p>\n<blockquote>\n<p id=\"so_4267194_4267258_0\">The operand of the unary - operator\n  shall have arithmetic or enumeration\n  type and the result is the negation of\n  its operand. Integral promotion is\n  performed on integral or enumeration\n  operands. The negative of an unsigned\n  quantity is computed by subtracting\n  its value from 2n, where n is the\n  number of bits in the promoted\n  operand. The type of the result is the\n  type of the promoted operand.</p>\n</blockquote>\n<p>And the paragraph on Integral Promotion 4.5/1</p>\n<blockquote>\n<p id=\"so_4267194_4267258_1\">An rvalue of type char, signed char,\n  unsigned char, short int, or unsigned\n  short int can be converted to an\n  rvalue of type int if int can\n  represent all the values of the source\n  type; otherwise, the source rvalue can\n  be converted to an rvalue of type\n  unsigned int.</p>\n</blockquote>\n<p>i.e. an unsigned int will not be promoted to an int.</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2010-11-24T14:25:42.627", "Score": "12", "CreationDate": "2010-11-24T13:25:06.150", "ParentId": "4267194", "CommentCount": "0", "OwnerUserId": "125672", "LastEditDate": "2010-11-24T14:25:42.627"}});