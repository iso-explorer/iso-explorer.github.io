post_cb({"12780629": {"Id": "12780629", "PostTypeId": "2", "Body": "<p>I believe clang is right to reject this. Passing the argument to <code>f(Y&amp;&amp;)</code> requires two conversion steps, the first being your <code>operator const Y()</code> and the second being <code>Y</code>'s copy constructor. Both count as user-defined conversions, I think, and both are implicit, which violates the principle that an implicit conversion sequence only includes one user-defined conversion. </p>\n<p>This <a href=\"https://stackoverflow.com/questions/8716330/purpose-of-returning-by-const-value\">Purpose of returning by const value?</a> contains some interesting insights into the semantics of returning a <code>const T</code>.</p>\n<p>Hm, if I try adding an overload <code>void f(const Y&amp;y)</code> as the edited question now does, clang behaves pretty strangly. It still complains about being unable to convert <code>X</code> to <code>Y</code>, and doesn't even list the overload <code>f(const Y&amp; y)</code> in its diagnostic. But once I change the overload to take <code>Y</code> by value, i.e. write <code>void f(const Y y)</code>, it complains about the call to <code>f</code> being ambiguous.</p>\n<p>This is with XCode 4.5's clang which reports <code>Apple clang version 4.1 (tags/Apple/clang-421.11.66) (based on LLVM 3.1svn)</code>. If you can reproduce this with a vanilla clang, you should probably report this on the clang mailing list - sure seems to there's a bug lurking there <em>somewhere</em>...</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-08T12:11:47.063", "Score": "6", "CreationDate": "2012-10-08T11:16:43.263", "ParentId": "12779630", "CommentCount": "3", "OwnerUserId": "1582403", "LastEditDate": "2017-05-23T10:24:09.250"}, "bq_ids": {"n4140": {"so_12779630_12782315_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_12779630_12782315_4": {"length": 18, "quality": 0.72, "section_id": 3321}, "so_12779630_12782315_1": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_12779630_12782315_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3321}}, "n3337": {"so_12779630_12782315_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_12779630_12782315_1": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_12779630_12782315_4": {"length": 21, "quality": 0.84, "section_id": 3191}, "so_12779630_12782315_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3191}}, "n4659": {"so_12779630_12782315_2": {"length": 12, "quality": 1.0, "section_id": 4087}, "so_12779630_12782315_1": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_12779630_12782315_4": {"length": 18, "quality": 0.72, "section_id": 4087}, "so_12779630_12782315_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 4086}}}, "12779630": {"ViewCount": "667", "Body": "<p>The following code compiles fine with <code>g++ (GCC) 4.7.1 20120721</code>, but\nfails with a recently build <code>clang version 3.2 (trunk)</code>.</p>\n<pre><code>struct Y {};\n\nstruct X {\n  operator const Y() const { return Y(); }\n};\n\nvoid f(Y&amp;&amp; y) {}\n\nint main()\n{\n  f(X());\n  return 0;\n}\n</code></pre>\n<p>Changing the conversion operator to <code>operator Y() const</code> is sufficient\nto make the code compile on both compilers.</p>\n<p>Which compiler is actually standard compliant in this case? What does\nthe standard actually say about this?</p>\n<p>The verbatim error as requested:</p>\n<pre><code>bla.cpp:14:5: error: no viable conversion from 'X' to 'Y'\n  f(X());\n    ^~~\nbla.cpp:1:8: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'X' to\n      'const Y &amp;' for 1st argument\nstruct Y {\n       ^\nbla.cpp:1:8: note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'X' to\n      'Y &amp;&amp;' for 1st argument\nstruct Y {\n       ^\nbla.cpp:6:3: note: candidate function\n  operator const Y() const { return Y(); }\n  ^\nbla.cpp:10:12: note: passing argument to parameter 'y' here\nvoid f(Y&amp;&amp; y) {}\n       ^\n</code></pre>\n<p><strong>EDIT:</strong> Unfortunately even adding the overload</p>\n<pre><code>void f(const Y&amp;) {}\n</code></pre>\n<p>still makes clang choose the rvalue reference overload and so this\nbreaks existing code that used to compile fine, e.g. with standard\ncontainers.</p>\n", "AcceptedAnswerId": "12780629", "Title": "Conversion to `const Y` not applicable for `R&&` on clang", "CreationDate": "2012-10-08T10:15:13.890", "Id": "12779630", "CommentCount": "13", "LastEditDate": "2012-10-08T12:00:03.087", "PostTypeId": "1", "LastEditorUserId": "105672", "LastActivityDate": "2012-10-08T13:02:07.620", "Score": "5", "OwnerUserId": "105672", "Tags": "<c++><c++11><g++><clang><move-semantics>", "AnswerCount": "2"}, "12782315": {"Id": "12782315", "PostTypeId": "2", "Body": "<p>The example is ill-formed.</p>\n<p>Some N3242 quotes.</p>\n<p>8.5.3 paragraph 4:</p>\n<blockquote>\n<p id=\"so_12779630_12782315_0\">Given types \u201c<em>cv1</em> <code>T1</code>\u201d and \u201c<em>cv2</em> <code>T2</code>,\u201d \u201c<em>cv1</em> <code>T1</code>\u201d is reference-related to \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is the same type as <code>T2</code>, or <code>T1</code> is a base class of <code>T2</code>. \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is reference-related to <code>T2</code> and <em>cv1</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>.</p>\n</blockquote>\n<p>paragraph 5 (bullet labels are mine):</p>\n<blockquote>\n<p id=\"so_12779630_12782315_1\">A reference to type \"<em>cv1</em> <code>T1</code>\" is initialized by an expression of type \"<em>cv2</em> <code>T2</code>\" as follows:</p>\n<ol>\n<li>If the reference is an lvalue reference and ...</li>\n<li><p id=\"so_12779630_12782315_2\">Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e. <em>cv1</em> shall be <code>const</code>), or the reference shall be an rvalue reference.</p>\n<p id=\"so_12779630_12782315_3\">a. If the initializer expression</p>\n<ul>\n<li>i. is an xvalue, class prvalue, array prvalue or function lvalue and \"<em>cv1</em> <code>T1</code>\" is reference-compatible with \"<em>cv2</em> <code>T2</code>\", or</li>\n<li>ii. has a class type (i.e. <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be implicitly converted to an xvalue, class prvalue, or function lvalue of type \"<em>cv3</em> <code>T3</code>\", where \"<em>cv1</em> <code>T1</code>\" is reference-compatible with \"<em>cv3</em> <code>T3</code>\",</li>\n<li>then the reference is bound to ....</li>\n</ul>\n<p id=\"so_12779630_12782315_4\">b. Otherwise, a temporary of type \"<em>cv1</em> <code>T1</code>\" is created and initialized from the initializer expression using the rules for a non-reference copy-initialization (8.5).  The reference is then bound to the temporary.  If <code>T1</code> is reference-related to <code>T2</code>, <em>cv1</em> shall be the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>.  ...</p></li>\n</ol>\n</blockquote>\n<p>For the function parameter initialization, <code>T1</code> is <code>Y</code>, <code>T2</code> is <code>X</code>, and <em>cv1</em> and <em>cv2</em> are both empty.  1 is out: the reference is an rvalue reference, not lvalue reference.  2.a.i. is out: <code>X</code> is not reference-compatible with <code>Y</code>.  2.b. is out because copy-initializing an <code>Y</code> from a prvalue of type <code>X</code> involves two user-defined conversions: the conversion function and then the copy constructor of <code>Y</code>.  (The exact prohibition is in 13.3.3.1p4.)</p>\n<p>For case 2.a.ii., the obvious choice for \"<em>cv3</em> <code>T3</code>\" is <code>const Y</code>, but that's no good because <code>Y</code> is not reference-compatible with <code>const Y</code>.  You might argue for trying <code>T3</code> is <code>Y</code> and <em>cv3</em> is empty, but then you're back to needing the copy constructor of <code>Y</code> as the second implicit user-defined conversion.</p>\n", "LastActivityDate": "2012-10-08T13:02:07.620", "CommentCount": "1", "CreationDate": "2012-10-08T13:02:07.620", "ParentId": "12779630", "Score": "2", "OwnerUserId": "459640"}});