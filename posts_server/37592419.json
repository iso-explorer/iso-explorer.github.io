post_cb({"bq_ids": {"n4140": {"so_37592419_37593204_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 7136}}, "n3337": {"so_37592419_37593204_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 6880}}, "n4659": {"so_37592419_37593204_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 8637}}}, "37593204": {"Id": "37593204", "PostTypeId": "2", "Body": "<p>As noticed by Quentin, the draft n4296 is explicit about that in chapter 3.5 Program and linkage [basic.link] \u00a73 (emphasize mine)</p>\n<blockquote>\n<p id=\"so_37592419_37593204_0\">A name having namespace scope (3.3.6) has internal linkage if it is the name of<br/>\n  (3.1) \u2014 a variable, function or function template that is explicitly declared static; or,<br/>\n  (3.2) \u2014 <strong>a variable of non-volatile const-qualified type</strong> that is neither explicitly declared extern nor previously\n  declared to have external linkage;</p>\n</blockquote>\n<p>When you declare <code>arr</code> to be const, it is implicitely given internal linkage. The fix is trivial: </p>\n<pre><code>/* main.cpp */\nextern const char* const arr[2] = {\"Hello\", \"World\"};\n</code></pre>\n<p>But best practice would recommend to have <code>extern const char* const arr[2];</code> in a header included in all files using <code>arr</code> in order to correctly share the declaration and then add in one of those files <code>const char* const arr[2] = {\"Hello\", \"World\"};</code>, effectively yielding:</p>\n<pre><code>/* main.cpp */\nextern const char* const arr[2]; // directly or more likely through an include...\n...\nconst char* const arr[2] = {\"Hello\", \"World\"};\n</code></pre>\n", "LastActivityDate": "2016-06-02T13:25:10.173", "CommentCount": "0", "CreationDate": "2016-06-02T13:25:10.173", "ParentId": "37592419", "Score": "3", "OwnerUserId": "3545273"}, "37592419": {"ViewCount": "98", "Body": "<p>This issue is reproducible in the g++ prior to <code>-std=c++14</code>. A linking error is generated due to highlighted <code>const</code> shown in below codes. It disappears, if the RHS <code>const</code> is removed.</p>\n<pre><code>/* main.cpp */\nconst char* const arr[2] = {\"Hello\", \"World\"};\n//          ^^^^^\nint main () {}\n</code></pre>\n<p>and</p>\n<pre><code>/* foo.cpp */\nextern const char* const arr[2];\n//                 ^^^^^\nconst char* foo () { return arr[0]; }\n</code></pre>\n<p>While compiling: <code>g++ [-std=c++11] main.cpp foo.cpp</code>, it gives following linking error:</p>\n<pre><code>In function `foo()': undefined reference to `arr'  \n</code></pre>\n<p>Is it a compiler bug or a language limitation/feature?</p>\n", "AcceptedAnswerId": "37593204", "Title": "Linking error due to constness of the pointer array in C++03/C++11", "CreationDate": "2016-06-02T12:51:37.217", "Id": "37592419", "CommentCount": "4", "LastEditDate": "2016-06-03T03:32:58.317", "PostTypeId": "1", "LastEditorUserId": "514235", "LastActivityDate": "2016-06-03T03:32:58.317", "Score": "5", "OwnerUserId": "514235", "Tags": "<c++><c++11><const><linker-errors><compiler-bug>", "AnswerCount": "1"}});