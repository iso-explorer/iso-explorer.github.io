post_cb({"29867841": {"CommentCount": "7", "ViewCount": "173", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-04-25T16:35:05.677", "LastActivityDate": "2015-04-27T15:42:06.450", "Title": "Can a forwarding reference be aliased with an alias template?", "AcceptedAnswerId": "29868348", "LastEditDate": "2017-05-23T11:51:05.557", "Id": "29867841", "Score": "3", "Body": "<p>This is a continuation of my previous question:</p>\n<p><a href=\"https://stackoverflow.com/q/29851098/391022\">Can an identity alias template be a forwarding reference?</a></p>\n<p>It seems that the following code works in both Clang 3.7.0 (<a href=\"http://melpon.org/wandbox/permlink/wARbV34NxrIYnhcn\" rel=\"nofollow noreferrer\">demo</a>) and GCC 6.0.0 (<a href=\"http://melpon.org/wandbox/permlink/Qol48AzNGaArEubd\" rel=\"nofollow noreferrer\">demo</a>):</p>\n<pre><code>template &lt;class T&gt;\nusing forwarding_reference = T&amp;&amp;;\n\ntemplate &lt;class T&gt;\nvoid foo(forwarding_reference&lt;T&gt;) {}\n\nint main()\n{\n  int i{};\n  foo(i);\n  foo(1);\n}\n</code></pre>\n<p>Are the compilers right to substitute the alias template for a forwarding reference and this could be a fancy way of writing one?</p>\n", "Tags": "<c++><templates><alias><c++14><forwarding-reference>", "OwnerUserId": "391022", "AnswerCount": "1"}, "29868348": {"ParentId": "29867841", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>This is indeed standard compliant. \u00a714.5.7/2:</p>\n<blockquote>\n<p id=\"so_29867841_29868348_0\">When a <em>template-id</em> refers to the specialization of an alias template,\n  <strong>it is equivalent to the associated type obtained by substitution of\n  its <em>template-arguments</em> for the <em>template-parameters</em> in the <em>type-id</em> of\n  the alias template.</strong></p>\n</blockquote>\n<p>Now, consider that during template argument deduction, only the type of the parameter (in terms of template parameters) is inspected - \u00a714.8.2.1/1:</p>\n<blockquote>\n<p id=\"so_29867841_29868348_1\">Template argument deduction is done by comparing each <strong>function\n  template parameter type (call it <code>P</code>)</strong> with the type of the\n  corresponding argument of the call (call it <code>A</code>) as described below.</p>\n</blockquote>\n<p>According to the first quote, the type of the parameter, i.e. <code>forwarding_reference&lt;T&gt;</code>, is equivalent to <code>T&amp;&amp;</code>. Hence <code>P</code> is <code>T&amp;&amp;</code> and there can be no difference regarding deduction.</p>\n<p>This same conclusion was made by the committee in a defect report concerning this exact scenario, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1700\" rel=\"nofollow\"><strong>#1700</strong></a>:</p>\n<blockquote>\n<p id=\"so_29867841_29868348_2\">Because the types of the function parameters are the same, regardless\n  of whether written directly or via an alias template, deduction must\n  be handled the same way in both cases.</p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-27T15:42:06.450", "Id": "29868348", "Score": "3", "CreationDate": "2015-04-25T17:19:44.013", "LastActivityDate": "2015-04-27T15:42:06.450"}, "bq_ids": {"n4140": {"so_29867841_29868348_0": {"section_id": 166, "quality": 1.0, "length": 17}, "so_29867841_29868348_1": {"section_id": 302, "quality": 1.0, "length": 18}}, "n3337": {"so_29867841_29868348_0": {"section_id": 160, "quality": 1.0, "length": 17}, "so_29867841_29868348_1": {"section_id": 293, "quality": 1.0, "length": 18}}, "n4659": {"so_29867841_29868348_0": {"section_id": 170, "quality": 1.0, "length": 17}, "so_29867841_29868348_1": {"section_id": 309, "quality": 1.0, "length": 18}}}});