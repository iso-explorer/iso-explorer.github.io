post_cb({"185624": {"CommentCount": "0", "AcceptedAnswerId": "189162", "PostTypeId": "1", "LastEditorUserId": "3001761", "CreationDate": "2008-10-09T01:43:08.383", "LastActivityDate": "2017-05-08T16:04:12.570", "LastEditDate": "2015-02-19T21:53:35.417", "ViewCount": "19010", "FavoriteCount": "30", "Title": "static variables in an inlined function", "Id": "185624", "Score": "52", "Body": "<p>I have a function that is declared and defined in a header file. This is a problem all by itself. When that function is not inlined, every translation unit that uses that header gets a copy of the function, and when they are linked together there are duplicated. I \"fixed\" that by making the function inline, but I'm afraid that this is a fragile solution because as far as I know, the compiler doesn't guarantee inlining, even when you specify the \"inline\" keyword. If this is not true, please correct me.</p>\n<p>Anyways, the real question is, what happens to static variables inside this function? How many copies do I end up with?</p>\n", "Tags": "<c++><header><linker><inline-functions>", "OwnerUserId": "13562", "AnswerCount": "9"}, "189162": {"CommentCount": "2", "CreationDate": "2008-10-09T20:51:02.370", "LastEditorUserId": "14089", "LastActivityDate": "2016-02-26T22:04:27.447", "ParentId": "185624", "LastEditDate": "2016-02-26T22:04:27.447", "OwnerDisplayName": "paercebal", "PostTypeId": "2", "Id": "189162", "Score": "78", "Body": "<p>I guess you're missing something, here.</p>\n<h2>static function?</h2>\n<p>Declaring a function static will make it \"hidden\" in its compilation unit.</p>\n<blockquote>\n<p id=\"so_185624_189162_0\">A name having namespace scope (3.3.6) has internal linkage if it is the name of</p>\n<p id=\"so_185624_189162_1\">\u2014 a variable, function or function template that is explicitly declared static;</p>\n<p id=\"so_185624_189162_2\">3.5/3 - C++14 (n3797)</p>\n<p id=\"so_185624_189162_3\">When a name has internal linkage , the entity it denotes can be referred to by names from other scopes in the same translation unit.</p>\n<p id=\"so_185624_189162_4\">3.5/2 - C++14 (n3797)</p>\n</blockquote>\n<p>If you declare this static function in a header, then all the compilation units including this header will have their own copy of the function.</p>\n<p>The thing is, if there are static variables inside that function, each compilation unit including this header will also have their own, personal version.</p>\n<h2>inline function?</h2>\n<p>Declaring it inline makes it a candidate for inlining (it does not mean a lot nowadays in C++, as the compiler will inline or not, sometimes ignoring the fact the keyword inline is present or absent):</p>\n<blockquote>\n<p id=\"so_185624_189162_5\">A function declaration (8.3.5, 9.3, 11.3) with an inline specifier declares an inline function. The inline specifier indicates to the implementation that inline substitution of the function body at the point of call is to be preferred to the usual function call mechanism. An implementation is not required to perform this inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules for inline functions defined by 7.1.2 shall still be respected.</p>\n<p id=\"so_185624_189162_6\">7.1.2/2 - C++14 (n3797)</p>\n</blockquote>\n<p>In a header, its has an interesting side effect: The inlined function can be defined multiple times in the same module, and the linker will simply join \"them\" into one (if they were not inlined for compiler's reason).</p>\n<p>For static variables declared inside, the standard specifically says there one, and only one of them:</p>\n<blockquote>\n<p id=\"so_185624_189162_7\">A static local variable in an extern inline function always refers to the same object.</p>\n<p id=\"so_185624_189162_8\">7.1.2/4 - C++98/C++14 (n3797)</p>\n</blockquote>\n<p>(functions are by default extern, so, unless you specifically mark your function as static, this applies to that function)</p>\n<p>This has the advantage of \"static\" (i.e. it can be defined in a header) without its flaws (it exists at most once if it is not inlined)</p>\n<h2>static local variable?</h2>\n<p>Static local variables have no linkage (they can't be referred to by name outside their scope), but has static storage duration (i.e. it is global, but its construction and destruction obey to specific rules).</p>\n<h2>static + inline?</h2>\n<p>Mixing inline and static will then have the consequences you described (even if the function is inlined, the static variable inside won't be, and you'll end with as much static variables as you have compilation units including the definition of your static functions).</p>\n<h2>Answer to author's additional question</h2>\n<blockquote>\n<p id=\"so_185624_189162_9\">Since I wrote the question I tried it out with Visual Studio 2008. I tried to turn on all the options that make VS act in compliance with standards, but it's possible that I missed some. These are the results:</p>\n<p id=\"so_185624_189162_10\">When the function is merely \"inline\", there is only one copy of the static variable.</p>\n<p id=\"so_185624_189162_11\">When the function is \"static inline\", there are as many copies as there are translation units.</p>\n<p id=\"so_185624_189162_12\">The real question is now whether things are supposed to be this way, or if this is an idiosyncrasy of the Microsoft C++ compiler.</p>\n</blockquote>\n<p>So I suppose you have something like that:</p>\n<pre><code>void doSomething()\n{\n   static int value ;\n}\n</code></pre>\n<p>You must realise that the static variable inside the function, simply put, a global variable hidden to all but the function's scope, meaning that only the function it is declared inside can reach it.</p>\n<p>Inlining the function won't change anything:</p>\n<pre><code>inline void doSomething()\n{\n   static int value ;\n}\n</code></pre>\n<p>There will be only one hidden global variable. The fact the compiler will try to inline the code won't change the fact there is only one global hidden variable.</p>\n<p>Now, if your function is declared static:</p>\n<pre><code>static void doSomething()\n{\n   static int value ;\n}\n</code></pre>\n<p>Then it is \"private\" for each compilation unit, meaning that every CPP file including the header where the static function is declared will have its own private copy of the function, including its own private copy of global hidden variable, thus as much variables as there are compilation units including the header.</p>\n<p>Adding \"inline\" to a \"static\" function with a \"static\" variable inside:</p>\n<pre><code>inline static void doSomething()\n{\n   static int value ;\n}\n</code></pre>\n<p>has the same result than not adding this \"inline\" keyword, as far as the static variable inside is concerned.</p>\n<p><b>So the behaviour of VC++ is correct, and you are mistaking the real meaning of \"inline\" and \"static\".</b></p>\n", "OwnerUserId": "14089"}, "1350268": {"ParentId": "185624", "CommentCount": "0", "Body": "<p>Static means one copy is distributed throughout the program , but inline means it requires the same code for several time in the same program , so it is not possible to make a variable static inside the inline function.</p>\n", "Id": "1350268", "PostTypeId": "2", "OwnerDisplayName": "Sanjeeb Kumar Sahu", "Score": "-1", "CreationDate": "2009-08-29T02:34:12.577", "LastActivityDate": "2009-08-29T02:34:12.577"}, "185682": {"ParentId": "185624", "CommentCount": "2", "Body": "<p>Since I wrote the question I tried it out with Visual Studio 2008. I tried to turn on all the options that make VS act in compliance with standards, but it's possible that I missed some. These are the results:</p>\n<p>When the function is merely \"inline\", there is only one copy of the static variable.</p>\n<p>When the function is \"static inline\", there are as many copies as there are translation units.</p>\n<p>The real question is now whether things are supposed to be this way, or if this is an ideosyncracy of the Microsoft C++ compiler.</p>\n", "OwnerUserId": "13562", "PostTypeId": "2", "Id": "185682", "Score": "3", "CreationDate": "2008-10-09T02:19:25.390", "LastActivityDate": "2008-10-09T02:19:25.390"}, "bq_ids": {"n4140": {"so_185624_189162_0": {"section_id": 7136, "quality": 0.875, "length": 7}, "so_185624_189162_5": {"section_id": 5402, "quality": 0.8888888888888888, "length": 40}, "so_185624_1384400_0": {"section_id": 5404, "quality": 1.0, "length": 30}, "so_185624_189162_1": {"section_id": 7136, "quality": 1.0, "length": 7}, "so_185624_189162_3": {"section_id": 7135, "quality": 0.9285714285714286, "length": 13}, "so_185624_189162_10": {"section_id": 480, "quality": 0.5555555555555556, "length": 5}, "so_185624_189162_7": {"section_id": 5404, "quality": 1.0, "length": 10}}, "n3337": {"so_185624_189162_0": {"section_id": 6880, "quality": 0.875, "length": 7}, "so_185624_189162_5": {"section_id": 5197, "quality": 0.8888888888888888, "length": 40}, "so_185624_1384400_0": {"section_id": 5199, "quality": 1.0, "length": 30}, "so_185624_189162_1": {"section_id": 6880, "quality": 1.0, "length": 7}, "so_185624_189162_3": {"section_id": 6879, "quality": 0.9285714285714286, "length": 13}, "so_185624_189162_10": {"section_id": 471, "quality": 0.5555555555555556, "length": 5}, "so_185624_189162_7": {"section_id": 5199, "quality": 1.0, "length": 10}}, "n4659": {"so_185624_189162_3": {"section_id": 8636, "quality": 0.9285714285714286, "length": 13}, "so_185624_189162_0": {"section_id": 8637, "quality": 0.875, "length": 7}, "so_185624_189162_5": {"section_id": 6849, "quality": 0.8666666666666667, "length": 39}, "so_185624_189162_1": {"section_id": 8637, "quality": 1.0, "length": 7}, "so_185624_1384400_0": {"section_id": 6853, "quality": 0.7666666666666667, "length": 23}, "so_185624_189162_10": {"section_id": 502, "quality": 0.5555555555555556, "length": 5}, "so_185624_189162_7": {"section_id": 6853, "quality": 0.9, "length": 9}}}, "185677": {"ParentId": "185624", "CommentCount": "0", "Body": "<p>Besides any design issues this all may imply, since you're already stuck with it, you should use static in this case not inline. That way everyone shares the same variables. (Static function)</p>\n", "OwnerUserId": "15124", "Id": "185677", "PostTypeId": "2", "OwnerDisplayName": "Robert Gould", "Score": "0", "CreationDate": "2008-10-09T02:15:13.857", "LastActivityDate": "2008-10-09T02:15:13.857"}, "185630": {"ParentId": "185624", "CommentCount": "0", "Body": "<p>I believe you will end up with one per translation unit. You've effectively got many versions of that function (and its declared static variable), one for every translation unit that includes the header.</p>\n", "OwnerUserId": "2193", "Id": "185630", "PostTypeId": "2", "OwnerDisplayName": "Jason Etheridge", "Score": "0", "CreationDate": "2008-10-09T01:47:40.963", "LastActivityDate": "2008-10-09T01:47:40.963"}, "185723": {"CommentCount": "2", "CreationDate": "2008-10-09T02:33:24.410", "LastEditorUserId": "22689", "LastActivityDate": "2008-10-10T18:41:19.890", "ParentId": "185624", "PostTypeId": "2", "LastEditorDisplayName": "RaphaelSP", "LastEditDate": "2008-10-10T18:41:19.890", "Id": "185723", "Score": "5", "Body": "<p>It is supposed to be this way.\n\"static\" tells the compiler you want the function to be local to the compilation unit, therefore you want one copy per compilation unit and one copy of the static variables per instance of the function.</p>\n<p>\"inline\" used to tell the compiler you want the function to be inlined; nowadays, it just takes it as \"it's ok if there are several copies of the code, just make sure it's the same function\". So everybody shares the static variables.</p>\n<p>Note: this answer was written in response to the answer the original poster posted to himself.</p>\n", "OwnerUserId": "22689", "OwnerDisplayName": "RaphaelSP"}, "1384400": {"ParentId": "185624", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I found Mark Ransom's answer helpful - that the compiler creates many copies of the static variable, but the linker chooses one and enforces it across all translation units. </p>\n<p>Elsewhere I found this:</p>\n<p><strong>See [dcl.fct.spec]/4</strong></p>\n<blockquote>\n<p id=\"so_185624_1384400_0\">[..] An inline function with external linkage shall have the same \n  address in all translation units. A static local variable in an extern \n  inline function always refers to the same object. A string literal in an \n  extern inline function is the same object in different translation units. </p>\n</blockquote>\n<p>I don't have a copy of the standard to check, but it matches with my experience examining the assembly in VS Express 2008</p>\n", "OwnerUserId": "169116", "LastEditorUserId": "5470596", "LastEditDate": "2017-02-07T09:04:05.673", "Id": "1384400", "Score": "7", "CreationDate": "2009-09-05T22:27:13.483", "LastActivityDate": "2017-02-07T09:04:05.673"}, "185640": {"ParentId": "185624", "CommentCount": "0", "Body": "<p>Inlining means that executable code (instructions) is inlined into the calling function's code.  The compiler can choose to do that regardless of whether you've asked it to.  That has no effect on the variables (data) declared in the function.</p>\n", "OwnerUserId": "23705", "Id": "185640", "PostTypeId": "2", "OwnerDisplayName": "Windows programmer", "Score": "0", "CreationDate": "2008-10-09T01:51:32.233", "LastActivityDate": "2008-10-09T01:51:32.233"}, "185730": {"CommentCount": "4", "CreationDate": "2008-10-09T02:35:58.853", "LastEditorUserId": "5987", "LastActivityDate": "2017-05-08T16:04:12.570", "ParentId": "185624", "PostTypeId": "2", "LastEditorDisplayName": "Mark Ransom", "LastEditDate": "2017-05-08T16:04:12.570", "Id": "185730", "Score": "28", "Body": "<p>I believe the compiler creates many copies of the variable, but the linker picks one and makes all the others reference it.  I had similar results when I tried an experiment to create different versions of an inline function; if the function wasn't actually inlined (debug mode), all calls went to the same function regardless of the source file they were called from.</p>\n<p>Think like a compiler for a moment - how could it be otherwise?  Each compilation unit (source file) is independent of the others, and can be compiled separately; each one must therefore create a copy of the variable, thinking it is the only one.  The linker has the ability to reach across those boundaries and adjust the references for both variables and functions.</p>\n", "OwnerUserId": "5987", "OwnerDisplayName": "Mark Ransom"}});