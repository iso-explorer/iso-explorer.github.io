post_cb({"bq_ids": {"n4140": {"so_26290598_26291984_0": {"length": 6, "quality": 1.0, "section_id": 3222}, "so_26290598_26290598_2": {"length": 17, "quality": 1.0, "section_id": 9}, "so_26290598_26290598_0": {"length": 11, "quality": 1.0, "section_id": 7230}, "so_26290598_26290598_3": {"length": 8, "quality": 0.5714285714285714, "section_id": 5768}}, "n3337": {"so_26290598_26291984_0": {"length": 6, "quality": 1.0, "section_id": 3096}, "so_26290598_26290598_2": {"length": 10, "quality": 0.5882352941176471, "section_id": 6}, "so_26290598_26290598_1": {"length": 4, "quality": 1.0, "section_id": 5947}, "so_26290598_26290598_0": {"length": 11, "quality": 1.0, "section_id": 6974}, "so_26290598_26290598_3": {"length": 14, "quality": 1.0, "section_id": 5}}, "n4659": {"so_26290598_26291984_0": {"length": 6, "quality": 1.0, "section_id": 3979}, "so_26290598_26290598_2": {"length": 14, "quality": 0.8235294117647058, "section_id": 10}, "so_26290598_26290598_0": {"length": 11, "quality": 1.0, "section_id": 8741}, "so_26290598_26290598_3": {"length": 8, "quality": 0.5714285714285714, "section_id": 7225}}}, "26290598": {"ViewCount": "271", "Body": "<p>I'm using N3936 as a reference here (please correct this question if any of the C++14 text differs).</p>\n<p>Under 3.10 <em>Lvalues and rvalues</em> we have:</p>\n<blockquote>\n<p id=\"so_26290598_26290598_0\">Every expression belongs to exactly one of the fundamental classifications in this taxonomy: lvalue, xvalue, or prvalue.</p>\n</blockquote>\n<p>However the definition of <em>lvalue</em> reads:</p>\n<blockquote>\n<p id=\"so_26290598_26290598_1\">An <em>lvalue</em> [...] designates a function or an object.</p>\n</blockquote>\n<p>In 4.1 <em>Lvalue-to-rvalue conversion</em> the text appears:</p>\n<blockquote>\n<p id=\"so_26290598_26290598_2\">[...] In all other cases, the result of the conversion is determined according to the following rules:\n   [...]\n   Otherwise, the value contained in the object indicated by the glvalue is the prvalue result.</p>\n</blockquote>\n<p>My question is: what happens in code where the lvalue does not designate an object? There are two canonical examples:</p>\n<p><strong>Example 1:</strong></p>\n<pre><code>int *p = nullptr;\n*p;\nint &amp;q = *p;\nint a = *p;\n</code></pre>\n<p><strong>Example 2:</strong></p>\n<pre><code>int arr[4];\nint *p = arr + 4;\n*p;\nint &amp;q = *p;\nstd::sort(arr, &amp;q);\n</code></pre>\n<p>Which lines (if any) are ill-formed and/or cause undefined behaviour?</p>\n<p>Referring to Example 1: is <code>*p</code> an lvalue? According to my first quote it must be. However, my second quote excludes it since <code>*p</code> does not designate an object. (It's certainly not an xvalue or a prvalue either).  </p>\n<p>But if you interpret my second quote to mean that <code>*p</code> is actually an lvalue, then it is not covered at all by the lvalue-to-rvalue conversion rules.  You may take the catch-all rule that \"anything not defined by the Standard is undefined behaviour\" but then you must permit null references to exist, so long as there is no lvalue-to-rvalue conversion performed.</p>\n<p><strong>History:</strong> This issue was raised in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\">DR 232</a> . In C++11 the resolution from DR232 did in fact appear. Quoting from N3337 <em>Lvalue-to-rvalue conversion</em>:</p>\n<blockquote>\n<p id=\"so_26290598_26290598_3\">If the object to which the glvalue refers is not an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program that necessitates this conversion has undefined behavior. </p>\n</blockquote>\n<p>which still appears to permit null references to exist - it only clears up the issue of performing lvalue-to-rvalue conversion on one. <a href=\"https://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-beha/2474021#2474021\">Also discussed on this SO thread</a></p>\n<p>The resolution from DR232 no longer appears in N3797 or N3936 though.</p>\n", "Title": "Lvalues which do not designate objects in C++14", "CreationDate": "2014-10-10T01:34:09.773", "LastActivityDate": "2014-10-14T12:28:49.640", "CommentCount": "11", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:25:06.330", "LastEditorUserId": "-1", "Id": "26290598", "Score": "6", "OwnerUserId": "1505939", "Tags": "<c++><language-lawyer><c++14><lvalue>", "AnswerCount": "2"}, "26306319": {"Id": "26306319", "PostTypeId": "2", "Body": "<p>I think the answer to this although probably not the answer you really want, is that this is under-specified or ill-specified and therefore we can not really say whether the examples you have provided are ill-formed or invoke undefined behavior according the current draft standard.</p>\n<p>We can see this by looking <code>DR 232</code> and <code>DR 453</code>.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow\">DR 232</a>  tells us that the standard conflicts on whether derferencing a null pointer is undefined behavior:</p>\n<blockquote>\n<p id=\"so_26290598_26306319_0\">At least a couple of places in the IS state that indirection through a\n  null pointer produces undefined behavior: 1.9 [intro.execution]\n  paragraph 4 gives \"dereferencing the null pointer\" as an example of\n  undefined behavior, and 8.3.2 [dcl.ref] paragraph 4 (in a note) uses\n  this supposedly undefined behavior as justification for the\n  nonexistence of \"null references.\"</p>\n<p id=\"so_26290598_26306319_1\">However, 5.3.1 [expr.unary.op] paragraph 1, which describes the unary\n  \"*\" operator, does not say that the behavior is undefined if the\n  operand is a null pointer, as one might expect. Furthermore, at least\n  one passage gives dereferencing a null pointer well-defined behavior:\n  5.2.8 [expr.typeid] paragraph 2 says</p>\n</blockquote>\n<p>and introduces the concept of an <em>empty lvalue</em> which is the result of indiretion on a null pointer or one past the end of an array:</p>\n<blockquote>\n<p id=\"so_26290598_26306319_2\">if any. If the pointer is a null pointer value (4.10 [conv.ptr]) or\n  points one past the last element of an array object (5.7 [expr.add]),\n  the result is an empty lvalue and does not refer to any object or\n  function.</p>\n</blockquote>\n<p>and proposes that the <em>lvaue-to-rvalue</em> conversion of such is undefined behavior.</p>\n<p>and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#453\" rel=\"nofollow\">DR 453</a> tell us that we don't know what a valid object is:</p>\n<blockquote>\n<p id=\"so_26290598_26306319_3\">What is a \"valid\" object? In particular the expression \"valid object\"\n  seems to exclude uninitialized objects, but the response to Core Issue\n  363 clearly says that's not the intent.</p>\n</blockquote>\n<p>and suggests that binding a reference to an <em>empty value</em> is undefined behavior.</p>\n<blockquote>\n<p id=\"so_26290598_26306319_4\">If an lvalue to which a reference is directly bound designates neither\n  an existing object or function of an appropriate type (8.5.3\n  [dcl.init.ref]), nor a region of memory of suitable size and alignment\n  to contain an object of the reference's type (1.8 [intro.object], 3.8\n  [basic.life], 3.9 [basic.types]), the behavior is undefined.</p>\n</blockquote>\n<p>and includes the following examples in the proposal:</p>\n<pre><code>int&amp; f(int&amp;);\nint&amp; g();\n\nextern int&amp; ir3;\nint* ip = 0;\n\nint&amp; ir1 = *ip;     // undefined behavior: null pointer\nint&amp; ir2 = f(ir3);  // undefined behavior: ir3 not yet initialized\nint&amp; ir3 = g();\nint&amp; ir4 = f(ir4);  // ill-formed: ir4 used in its own initializer\n</code></pre>\n<p>So if we want to restrict ourselves to dealing only with the intent then I feel that <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow\">DR 232</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#453\" rel=\"nofollow\">DR 453</a> provide the information we need to say that the intention is that lvalue-to-rvalue conversion of a null pointer is undefined behavior and a reference to a null pointer or an <em>indeterminate value</em> is also undefined behavior.</p>\n<p>Now although it has taken a while for both of these report resolutions to be sorted out, they are both active with relatively recent updates and apparently the committee so far does not disagree with the main premise that the defects reported are actual defects. So it follows without knowing these two items it would imply it is not possible to provide an answer to your question using the current draft standards.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-10-14T12:28:49.640", "Score": "1", "CreationDate": "2014-10-10T19:03:07.350", "ParentId": "26290598", "CommentCount": "1", "LastEditDate": "2014-10-14T12:28:49.640", "OwnerUserId": "1708801"}, "26291984": {"Id": "26291984", "PostTypeId": "2", "Body": "<p>It isn't possible to create a reference to null or a reference to the off-the-end element of an array, because section 8.3.2 says (reading from draft n3936) that</p>\n<blockquote>\n<p id=\"so_26290598_26291984_0\">A reference shall be initialized to refer to a valid object or function.</p>\n</blockquote>\n<p>However, it is not clear that forming an expression with a value category of lvalue constitutes \"initialization of a reference\".  Quite the contrary, in fact, temporary objects are objects, and references are not objects, so it cannot be said that <code>*(a+n)</code> initializes a temporary object of reference type.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-10-10T12:24:15.073", "Score": "2", "CreationDate": "2014-10-10T04:32:27.883", "ParentId": "26290598", "CommentCount": "7", "LastEditDate": "2014-10-10T12:24:15.073", "OwnerUserId": "103167"}});