post_cb({"29340160": {"CommentCount": "2", "AcceptedAnswerId": "29342850", "CreationDate": "2015-03-30T07:02:30.873", "LastActivityDate": "2015-03-30T09:38:37.453", "PostTypeId": "1", "ViewCount": "1196", "FavoriteCount": "2", "Title": "Passing reference of packed struct member to template. gcc bug?", "Id": "29340160", "Score": "2", "Body": "<p>I encountered a problem, passing struct member to a template function. The function's goal is to take the address and size of the member. Here is simple example:</p>\n<p>This is the struct. It has packed attribute.</p>\n<pre><code>struct TestStruct {\n    unsigned char       elem1;\n    unsigned char       elem2;\n    uint64_t            elem3;\n    char                buf[10000];\n    int                 elem4;\n    unsigned char       elem5;\n}\n__attribute__ ((packed));\n</code></pre>\n<p>this is the template function, which should get a member's address</p>\n<pre><code>template&lt;typename T&gt;\nvoid addData(const T &amp;val)\n{\n        printf (\"address inside func: %p \\n\",&amp;val);\n}\n\nint main(int argc, char *argv[])\n{\n        TestStruct testdata;\n        testdata.elem4 = 0;\n        printf (\"struct address is:   %p \\n\",&amp;testdata);\n        printf (\"elem4  address is:   %p \\n\",&amp;testdata.elem4);\n        addData(testdata.elem4);\n        return 0;\n}\n</code></pre>\n<p>The problem: When  <strong>attribute</strong> ((packed)); is set (like in the example)\nthe template function receives wrong address of the member:</p>\n<p>Output:</p>\n<pre><code>struct address is:   0x7fff735bb4e0 \nelem4  address is:   0x7fff735bdbfa \naddress inside func: 0x7fff735bb4dc\n</code></pre>\n<p>If I remove the \"packed\" attribute, everything is OK.\nThere is no error and no warning (even with -Wall -Wextra), but not the right address is passed to the function.</p>\n<p>I read this:</p>\n<p><a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36566\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36566</a></p>\n<p>and found that there is an issue, getting references to packed-struct members.\nInteresting enough, replacing const T&amp; with T&amp; in my template function, produces the error message:</p>\n<pre><code>error: cannot bind packed field \u2018testdata.TestStruct::elem4\u2019 to \u2018int&amp;\u2019\n</code></pre>\n<p>So, I have 2 questions:</p>\n<ol>\n<li><p>Why cannot packed-struct members be passed as const references, when their address can be passed as pointer</p></li>\n<li><p>What happens in the const T&amp; case? There is no error, no warning, but the incorrect address is passed to the function. As we know, the address of reference is the address of the variable, the reference points to.</p></li>\n</ol>\n", "Tags": "<c++><struct><reference>", "OwnerUserId": "935512", "AnswerCount": "1"}, "29342850": {"ParentId": "29340160", "CommentCount": "0", "Body": "<p>Both of your questions are answered at the link you posted.</p>\n<p><em>1. Why cannot packed-struct members be passed as const references, when their address can be passed as pointer</em></p>\n<p>Gabriel M. Beddingfield wrote in <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36566#c6\" rel=\"nofollow\">his comment</a>:</p>\n<blockquote>\n<p id=\"so_29340160_29342850_0\">All assignments of obj.s to type short&amp; and short* are incorrect, and ideally they would all result in compiler errors.</p>\n<p id=\"so_29340160_29342850_1\">The C++ spec (C++03, Sects. 3.9, 3.9.1, 3.9.2) are very clear that T and \"pointer to T\" have implementation-specific alignment requirements.  If you have a \"pointer to T\" then you may assume that it meets the alignment requirements.  I'm sure the C spec has similar language.</p>\n</blockquote>\n<p>I can only add to this the corresponding quote from C++14 standard ([basic.align]/1):</p>\n<blockquote>\n<p id=\"so_29340160_29342850_2\">Object types have <em>alignment requirements</em> (3.9.1, 3.9.2) which place restrictions on the addresses at which an object of that type may be allocated. An <em>alignment</em> is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. An object type imposes an alignment requirement on every object of that type; stricter alignment can be requested using the alignment specifier</p>\n</blockquote>\n<p>The bottom line of it is that even taking an addres of a packed struct member should be an error.</p>\n<p><em>2. What happens in the const T&amp; case? There is no error, no warning, but the incorrect address is passed to the function. As we know, the address of reference is the address of the variable, the reference points to.</em></p>\n<p>Jonathan Wakely <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=36566#c8\" rel=\"nofollow\">wrote</a>:</p>\n<blockquote>\n<p id=\"so_29340160_29342850_3\">A const-reference causes a temporary to be created, you didn't bind to the packed field</p>\n</blockquote>\n<hr>\n<p>The bottom line is that it's not a bug itself that you can't bind a non-const reference to a packed struct field, a bug is that at the same time you can take an address of it. The compiler should either allow or disallow both.</p>\n</hr>", "OwnerUserId": "3959454", "PostTypeId": "2", "Id": "29342850", "Score": "2", "CreationDate": "2015-03-30T09:38:37.453", "LastActivityDate": "2015-03-30T09:38:37.453"}, "bq_ids": {"n4140": {"so_29340160_29342850_2": {"section_id": 7240, "quality": 0.8837209302325582, "length": 38}}, "n3337": {"so_29340160_29342850_2": {"section_id": 6984, "quality": 0.8837209302325582, "length": 38}}, "n4659": {"so_29340160_29342850_2": {"section_id": 8749, "quality": 0.8604651162790697, "length": 37}}}});