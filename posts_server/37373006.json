post_cb({"37373006": {"CommentCount": "0", "ViewCount": "86", "PostTypeId": "1", "LastEditorUserId": "3445587", "CreationDate": "2016-05-22T10:14:18.683", "LastActivityDate": "2016-05-22T15:58:47.250", "Title": "Plain Old Data - Alignment requirements", "AcceptedAnswerId": "37373209", "LastEditDate": "2016-05-22T13:33:41.010", "Id": "37373006", "Score": "4", "Body": "<p>Suppose I have two POD structs <code>A</code> and <code>B</code> with the same initial sequence of members, but some differences later (I know, this could easily be solved with inheritance).</p>\n<pre><code>struct A {\n    int x;\n    uint64_t y;\n    int z;\n};\nstruct B {\n    int x;\n    uint64_t y;\n    int8_t z;\n};\n</code></pre>\n<p>A pointer to the struct needs to point to the intitial member (\u00a79.2.20 [class.mem]).</p>\n<p>Now two additional questions:</p>\n<ul>\n<li>Where in the standard to I find that members cannot be reordered. I am pretty sure that this is the case, because the structs need to be fully compatible with C, and for C is prescribed that memory addresses must be increasing in the order of declaration.</li>\n<li><p>Must the alignment of the common members in both structs be the same? I.e., is the following always true:</p>\n<pre><code>A a;\nB b;\nassert(offsetof(A, y) == offsetof(B, y));\n</code></pre>\n<p>If not: At least if I put the structs into a union, then this should hold, because the standard (\u00a79.2.19 [class.mem]) says</p>\n<blockquote>\n<p id=\"so_37373006_37373006_0\">If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them.</p>\n</blockquote></li>\n</ul>\n<hr>\n<p>I add here an additional example.</p>\n<pre><code>struct A {\n    int x;\n    uint64_t y;\n    int z;\n};\nstruct B {\n    int x;\n    uint64_t y;\n    int8_t z;\n};\nB convertToB(A&amp; a);\nvoid g() {\n    A a;\n    // at this point, I cannot rely on offset(A, y) == offset(B, y)\n    B b = convertToB(a);\n    // since I do the copy over the union, offset(A, y) == offset(B, y) holds\n}\nunion U {\n     A asA; \n     B asB;\n};\nB convertToB(A&amp; a) {\n    U u;\n    // at this point, offset(A, y) == offset(B, y) holds\n    u.asA = a;\n    return u.asB;\n}\n</code></pre>\n<p>Since I have no chance to know whether at some point, a copy over a union happens, and a struct must be the same everywhere, I claim, that <code>offset(A, y) == offset(B, y)</code> must hold.</p>\n</hr>", "Tags": "<c++><struct><language-lawyer>", "OwnerUserId": "3445587", "AnswerCount": "1"}, "37373209": {"ParentId": "37373006", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You can find oredering requirements for object members here:</p>\n<blockquote>\n<p id=\"so_37373006_37373209_0\"><strong>9.2/13:</strong> Nonstatic data members of a (non-union) class <strong>with the same access control</strong> are allocated so that later members have higher\n  addresses within a class object. The order of allocation of non-static\n  data members with <strong>different access control is unspecified</strong>.\n  Implementation alignment requirements might cause two adjacent members\n  not to be allocated immediately after each other; so might\n  requirements for space for managing virtual functions and virtual base\n  classes.</p>\n</blockquote>\n<p>In your <code>struct</code> all the members have the same access class, so you have here a guarantee about the order.    </p>\n<p>Note however the last sentence of the quote: it is not guaranteed that the space between two consecutive members would be the same (although not very probable). This is why I'd recommend to go for the <code>union</code> approach.  Not only would you benefit from the standard's guarantees, but in addition you would clearly communicate your intent in the source code.</p>\n<hr>\n<p><strong>Edit</strong></p>\n<p>There's another aspect that we can consider:  a POD type is a trivial type and has a standard layout.  </p>\n<blockquote>\n<p id=\"so_37373006_37373209_1\"><strong>9.2/16:</strong> Two standard-layout struct types are layout-compatible if they have the same number of non-static data members and corresponding\n  non-static data members (in declaration order) have layout-compatible\n  types </p>\n<p id=\"so_37373006_37373209_2\"><strong>3.9/11:</strong> If two types T1 and T2 are the same type, then T1 and T2 are layout-compatible types.</p>\n</blockquote>\n<p>Once again, you see that you have no guarantees, as soon as your struct diverge at some point.  However I understand that this gives you the guarantee that <code>u.asB</code> is layout compatible with the <code>B</code> object it returns.  </p>\n<p>Finally, I hoped to find a more tangible guarantee with trivially copiable objects:  </p>\n<blockquote>\n<p id=\"so_37373006_37373209_3\"><strong>3.9/2:</strong> For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object holds a valid\n  value of type T, the underlying bytes making up the object can be\n  copied into an array of char or unsigned char. If the content of the\n  array of char or unsigned char is copied back into the object, the\n  object shall subsequently hold its original value.</p>\n</blockquote>\n<p>I think that one can deduce from this, that in your case, storing one value in the union but reading the other would work. However be aware that this is not a general truth according to this (non normative) note: </p>\n<blockquote>\n<p id=\"so_37373006_37373209_4\"><strong>9.5/4:</strong> [Note: In general, one must use explicit destructor calls and placement new operators to change the active member of a union.\n  \u2014end note]</p>\n</blockquote>\n</hr>", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2016-05-22T15:58:47.250", "Id": "37373209", "Score": "0", "CreationDate": "2016-05-22T10:34:16.863", "LastActivityDate": "2016-05-22T15:58:47.250"}, "bq_ids": {"n4140": {"so_37373006_37373006_0": {"section_id": 5878, "quality": 1.0, "length": 25}, "so_37373006_37373209_1": {"section_id": 5876, "quality": 0.9090909090909091, "length": 20}, "so_37373006_37373209_0": {"section_id": 5873, "quality": 0.96, "length": 48}, "so_37373006_37373209_3": {"section_id": 7200, "quality": 0.9523809523809523, "length": 40}, "so_37373006_37373209_2": {"section_id": 7209, "quality": 0.75, "length": 6}, "so_37373006_37373209_4": {"section_id": 5916, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_37373006_37373006_0": {"section_id": 5649, "quality": 1.0, "length": 25}, "so_37373006_37373209_1": {"section_id": 5647, "quality": 0.9545454545454546, "length": 21}, "so_37373006_37373209_0": {"section_id": 5644, "quality": 0.96, "length": 48}, "so_37373006_37373209_3": {"section_id": 6944, "quality": 0.9523809523809523, "length": 40}, "so_37373006_37373209_2": {"section_id": 6953, "quality": 0.875, "length": 7}, "so_37373006_37373209_4": {"section_id": 5688, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_37373006_37373006_0": {"section_id": 7404, "quality": 0.72, "length": 18}, "so_37373006_37373209_1": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}, "so_37373006_37373209_0": {"section_id": 7356, "quality": 0.96, "length": 48}, "so_37373006_37373209_3": {"section_id": 8709, "quality": 0.8809523809523809, "length": 37}, "so_37373006_37373209_2": {"section_id": 6124, "quality": 0.625, "length": 5}, "so_37373006_37373209_4": {"section_id": 7409, "quality": 0.6666666666666666, "length": 12}}}});