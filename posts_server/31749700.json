post_cb({"bq_ids": {"n4140": {"so_31749700_31750080_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 4279}, "so_31749700_31750080_0": {"length": 24, "quality": 0.96, "section_id": 4276}}, "n3337": {"so_31749700_31750080_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 4120}, "so_31749700_31750080_0": {"length": 24, "quality": 0.96, "section_id": 4117}}, "n4659": {"so_31749700_31750080_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 5535}, "so_31749700_31750080_0": {"length": 24, "quality": 0.96, "section_id": 5532}}}, "31749700": {"ViewCount": "162", "Body": "<p>Recently I tried to reinvent <em>scope guard</em> via <code>std::unique_ptr</code> (<strong>NOTE</strong>: <em>Deleter</em> has the member typedef <code>pointer</code> \u2014 is a specially handled case of <code>std::unique_ptr</code>):</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\n#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n\nnamespace\n{\n\ntemplate&lt; typename lambda &gt;\nauto\nmake_scope_guard(lambda &amp;&amp; _lambda)\n{\n    struct lambda_caller\n    {\n\n        using pointer = std::decay_t&lt; lambda &gt;;\n\n        void\n        operator () (lambda &amp; l) const noexcept\n        {\n            std::forward&lt; lambda &gt;(l)();\n        }\n\n    };\n    return std::unique_ptr&lt; std::decay_t&lt; lambda &gt;, lambda_caller &gt;(std::forward&lt; lambda &gt;(_lambda));\n}\n\n}\n\nint\nmain()\n{\n    std::cout &lt;&lt; 1 &lt;&lt; std::endl;\n    {\n        std::cout &lt;&lt; 2 &lt;&lt; std::endl;\n        [[gnu::unused]] auto &amp;&amp; guard_ = make_scope_guard([&amp;] { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; });\n        std::cout &lt;&lt; 3 &lt;&lt; std::endl;\n    }\n    std::cout &lt;&lt; 5 &lt;&lt; std::endl;\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Such an approach works fine for simple pointer to free function <code>void f() { std::cout &lt;&lt; 4 &lt;&lt; std::endl; }</code> passed to <code>make_scope_guard</code>, but not for any lambda passed to <code>make_scope_guard</code>.</p>\n<p>This is due to an abundance of <code>... = pointer()</code> into the <code>std::unique_ptr</code> definition (function default parameter, defaulting data memebers etc), but I can't find the <em>DefaultConstructible</em> requirement for <code>pointer</code> into this <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr\" rel=\"nofollow\">article</a>.</p>\n<p>Is it mandatory, that the <code>pointer</code> should match the <code>std::is_default_constructible</code> requirement?</p>\n<p>It tested against <code>libc++</code> and against <code>libstdc++</code> using not too old <code>clang++ -std=gnu++1z</code>.</p>\n<p>Seems, there should be language extension for lambdas: if <code>auto l = [/* possible capture list */] (Args...) { /* code */; };</code> then <code>using L = decltype(l);</code> is equivalent to <code>struct L { constexpr void operator () (Args...) const noexcept { ; } };</code> for some <code>Args...</code>, isn't it?</p>\n<p><strong>ADDITIONAL:</strong></p>\n<p>Providing the instance <code>D{}</code> of following <em>DefaultConstructible</em> class to <code>make_scope_guard(D{})</code> requires commented out code to be uncommented in the context <code>if (p) { ...</code>, where <code>p</code> is of type <code>D</code>:</p>\n<pre><code>struct D { void operator () () const noexcept { std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl; } /* constexpr operator bool () const { return true; } */ };\n</code></pre>\n", "Title": "unique_ptr and default constructible pointer", "CreationDate": "2015-07-31T15:18:44.257", "LastActivityDate": "2015-07-31T16:46:40.020", "CommentCount": "0", "LastEditDate": "2015-07-31T16:46:40.020", "PostTypeId": "1", "LastEditorUserId": "1430927", "Id": "31749700", "Score": "5", "OwnerUserId": "1430927", "Tags": "<c++><c++11><lambda><c++14><unique-ptr>", "AnswerCount": "1"}, "31750080": {"Id": "31750080", "PostTypeId": "2", "Body": "<p>A <code>unique_ptr</code> is still a pointer. You cannot shoehorn a lambda into it. From [unique.ptr]:</p>\n<blockquote>\n<p id=\"so_31749700_31750080_0\">A <em>unique pointer</em> is an object that owns another object and manages that other object through a <strong>pointer</strong>.\n  More precisely, a unique pointer is an object u that stores a <strong>pointer</strong> to a second object p and will dispose of\n  p when u is itself destroyed</p>\n<p id=\"so_31749700_31750080_1\">[...]</p>\n<p id=\"so_31749700_31750080_2\">Additionally, <em>u</em> can, upon request, transfer ownership to another unique pointer <em>u2</em>. Upon completion of\n  such a transfer, the following post-conditions hold: [...] <em>u.p</em> is equal to <code>nullptr</code></p>\n</blockquote>\n<p>A lambda is not a pointer. A lambda cannot equal <code>nullptr</code>.</p>\n<p>That said, you're already making your own local struct, why not just use <em>that</em> to do the RAII scope guarding itself instead of deferring to <code>unique_ptr</code>? That seems like a hack at best, and takes more code to boot. You could instead just do:</p>\n<pre><code>template&lt; typename lambda &gt;\nauto\nmake_scope_guard(lambda &amp;&amp; _lambda)\n{\n    struct lambda_caller\n    {\n        lambda _lambda;\n\n        ~lambda_caller()\n        {\n            _lambda();\n        }\n\n    };\n\n    return lambda_caller{std::forward&lt;lambda&gt;(_lambda)};\n}\n</code></pre>\n<p>If you need to support <code>release</code>, you can wrap <code>_lambda</code> inside of <code>boost::optional</code> so that <code>lambda_caller</code> becomes:</p>\n<pre><code>struct lambda_caller\n{\n    boost::optional&lt;lambda&gt; _lambda;\n\n    ~lambda_caller()\n    {\n        if (_lambda) {\n            (*_lambda)();\n            _lambda = boost::none;\n        }\n    }\n\n    void release() {\n        _lambda = boost::none;\n    }\n};\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-31T16:35:30.393", "Score": "4", "CreationDate": "2015-07-31T15:38:35.337", "ParentId": "31749700", "CommentCount": "8", "OwnerUserId": "2069064", "LastEditDate": "2015-07-31T16:35:30.393"}});