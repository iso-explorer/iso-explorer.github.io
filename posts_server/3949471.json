post_cb({"3972350": {"ParentId": "3949471", "CommentCount": "1", "Body": "<p>Although it's certainly unusual, C++ does allow <code>int</code> to be <code>NaN</code>.</p>\n<p>First, it's possible for <code>int</code> to store information besides its numeric value. \u00a73.9.1/1:</p>\n<blockquote>\n<p id=\"so_3949471_3972350_0\">For character types, all bits of the object representation participate in the value representation. For unsigned character types, all possible bit patterns of the value representation represent numbers. <strong>These requirements do not hold for other types.</strong></p>\n</blockquote>\n<p>Then, <code>numeric_limits&lt;int&gt;::has_quiet_NaN</code> and <code>has_signaling_NaN</code> are not required to be <code>false</code> for any type. \u00a718.2.1.2/34-36:</p>\n<blockquote>\n<pre><code>static const bool has_quiet_NaN;\n</code></pre>\n<p id=\"so_3949471_3972350_1\">34    True if the type has a\n  representation for a quiet\n  (non-signaling) \u2018\u2018Not a Number.\u2019\u2019</p>\n<p id=\"so_3949471_3972350_2\">35    Meaningful for all floating point\n  types.</p>\n<p id=\"so_3949471_3972350_3\">36    Shall be true for all\n  specializations in which is_iec559 !=\n  false.</p>\n</blockquote>\n<p>\"Meaningful for all floating point types\" is a little troublesome as it opens the possibility that the value could be meaningless,  but that's certainly an extrapolation.</p>\n<p>If <code>numeric_limits&lt;int&gt;::has_quiet_NaN == true</code>, then <code>numeric_limits&lt;int&gt;::quiet_NaN()</code> returns such a value.</p>\n<p>Obviously, this is not something you should worry about in your code.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "3972350", "Score": "4", "CreationDate": "2010-10-19T20:15:28.310", "LastActivityDate": "2010-10-19T20:15:28.310"}, "3949471": {"CommentCount": "7", "AcceptedAnswerId": "3972350", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2010-10-16T15:20:18.267", "LastActivityDate": "2010-10-19T20:15:28.310", "LastEditDate": "2010-10-19T19:54:47.777", "ViewCount": "686", "FavoriteCount": "2", "Title": "int a; ...; (a == a) fails?", "Id": "3949471", "Score": "7", "Body": "<p>if we set <em>float</em> and <em>double</em> type to <em>NaN</em> then they are not equal to anything including <strong>themselves</strong>.<br>\ncan such a thing happens for <em>int</em>?</br></p>\n", "Tags": "<c++>", "OwnerUserId": "395573", "AnswerCount": "8"}, "3949476": {"ParentId": "3949471", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>NaN is the only value for <code>a==a</code> return false.</p>\n<p>And <code>int</code> doesn't support a NaN value. So no you can't have this situation with <code>int</code>.</p>\n<p>Another note, to check if a value is NaN you should use <code>isnan()</code> not <code>a==a</code>.</p>\n<hr>\n<h3>On the same topic :</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/3596622/negative-nan-is-not-a-nan\">Negative NaN is not a NaN?</a></li>\n</ul>\n</hr>", "OwnerUserId": "422597", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:44:24.167", "Id": "3949476", "Score": "0", "CreationDate": "2010-10-16T15:22:14.027", "LastActivityDate": "2010-10-16T15:30:27.157"}, "3949536": {"ParentId": "3949471", "CommentCount": "0", "Body": "<p>Would depend on the compiler optimization maybe; look at the disassembly. If it uses binary 'and' it &amp; check the flags after it will fail if a is zero.</p>\n", "OwnerUserId": "15161", "PostTypeId": "2", "Id": "3949536", "Score": "0", "CreationDate": "2010-10-16T15:40:29.380", "LastActivityDate": "2010-10-16T15:40:29.380"}, "3949489": {"ParentId": "3949471", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>Anything can happen if you compare an uninitialized variable to itself. It is after all undefined behavior. For initialized int variables, this can't happen.</p>\n<p>Note that namespace-scope, class-static, and function-static int variables not explicitly initialized are given the value 0. Then they won't compare equal.</p>\n<hr>\n<p>I have just tested with Clang:</p>\n<pre><code>int main() {\n  int x;\n  return (x == x);\n}\n</code></pre>\n<p>When compiled with -O1, this returns 0 because the optimizer is allowed to assume that x has no stable value.</p>\n<p>GCC is more forgiving with the above, returning 1. The following makes GCC return 0 too (obviously not doing the branch is cheaper if you are allowed to choose):</p>\n<pre><code>int main() {\n  int x;\n  if(x == x) {\n    return 1;\n  }\n  return 0;\n}\n</code></pre>\n<p>In the end, the result is not only dependent on the CPU executing the code, but also from anything else in the toolchain.</p>\n</hr>", "OwnerUserId": "34509", "LastEditorDisplayName": "Roger Pate", "LastEditDate": "2010-10-19T08:13:51.157", "Id": "3949489", "Score": "14", "CreationDate": "2010-10-16T15:25:59.603", "LastActivityDate": "2010-10-19T08:13:51.157"}, "3949561": {"ParentId": "3949471", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>This perfectly possible if you compare uninitialized variables.</p>\n<p>In C++ language an uninitialized variable is not guaranteed to hold a stable value. In theory operating with uninitialized values produces undefined behavior. In practice reading the value of the same uninitialized variable multiple times can easily result in different values being read. The most obvious practical reason for this is that the variable was optimized to some CPU register. </p>\n<p>In order to manage the limited amount of CPU registers efficiently, optimizing compilers operate with the notion of <em>value lifetime</em> of a variable. Value lifetime is essentially the period during which the variable holds a specific stable value. Value lifetime begins when the variable is initialized and ends when it is re-initialized to another value (or when its accessed for the very last time). Within the period of \"value lifetime\", the value must be stable, so the CPU register cannot be used for other purposes (or it have to be carefully saved and restored every time it is used for other purposes).</p>\n<p>Outside the period of value lifetime, there's no need to preserve the value of the register, so it can be freely used for other purposes. For this reason, if some variable is represented by a CPU register, but not initialized (i.e. if its value lifetime hasn't begin yet) its observed value can change absolutely unpredictably, producing the new value every time the variable is read, because the contents of the corresponding CPU register changes for some unrelated reasons.</p>\n<p>This might easily result in <code>a == a</code> evaluating to <code>false</code> with uninitialized <code>a</code>. Of course, it is rather surprising to see it happen for two reads that appear to be located so \"close\" together. But it still can happen. This behavior is prefectly standard. The standard does not guarantee the stability of an initialized variable.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2010-10-16T15:53:27.097", "Id": "3949561", "Score": "4", "CreationDate": "2010-10-16T15:46:35.600", "LastActivityDate": "2010-10-16T15:53:27.097"}, "3949512": {"ParentId": "3949471", "CommentCount": "1", "Body": "<p>How about<pre><code>unsigned int a = -1;\nif (a == (unsigned char) a) { //returns false\n(...)\n</code></pre></p>\n", "OwnerUserId": "446252", "PostTypeId": "2", "Id": "3949512", "Score": "0", "CreationDate": "2010-10-16T15:33:45.317", "LastActivityDate": "2010-10-16T15:33:45.317"}, "3949546": {"ParentId": "3949471", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>No. The comparation for floats is defines in such way, that NaN compared to any number will return false. Anyway, for ints there is another formula:</p>\n<pre><code>ZF = !(a ^ b);\n</code></pre>\n<p>That will give true for any possible value of a.</p>\n<p>EDIT: on GCC, with any -O flag, the comparation just dissapears to true.</p>\n", "OwnerUserId": "395626", "LastEditorUserId": "395626", "LastEditDate": "2010-10-16T15:54:06.210", "Id": "3949546", "Score": "0", "CreationDate": "2010-10-16T15:42:16.520", "LastActivityDate": "2010-10-16T15:54:06.210"}, "bq_ids": {"n4140": {"so_3949471_3972350_1": {"section_id": 6756, "quality": 0.8571428571428571, "length": 6}, "so_3949471_3972350_2": {"section_id": 6732, "quality": 1.0, "length": 5}, "so_3949471_3972350_0": {"section_id": 7210, "quality": 0.8888888888888888, "length": 24}, "so_3949471_3972350_3": {"section_id": 6755, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_3949471_3972350_1": {"section_id": 6511, "quality": 0.8571428571428571, "length": 6}, "so_3949471_3972350_2": {"section_id": 6487, "quality": 1.0, "length": 5}, "so_3949471_3972350_0": {"section_id": 6954, "quality": 0.8888888888888888, "length": 24}, "so_3949471_3972350_3": {"section_id": 6510, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_3949471_3972350_1": {"section_id": 8250, "quality": 0.7142857142857143, "length": 5}, "so_3949471_3972350_0": {"section_id": 8719, "quality": 0.7407407407407407, "length": 20}, "so_3949471_3972350_3": {"section_id": 8249, "quality": 0.8333333333333334, "length": 5}}}, "3949498": {"ParentId": "3949471", "CommentCount": "2", "Body": "<p>It cannot happen when you compare plain initialized int variables.</p>\n<p>It can happen for int comparisons when you reference a hardware register, e.g. something like:</p>\n<pre><code>*timeRegister == *timeRegister\n</code></pre>\n<p>It could also happen when you compare a volatile int variable to itself which is modified by a signal-handler during the comparison.</p>\n", "OwnerUserId": "280314", "PostTypeId": "2", "Id": "3949498", "Score": "4", "CreationDate": "2010-10-16T15:29:27.490", "LastActivityDate": "2010-10-16T15:29:27.490"}});