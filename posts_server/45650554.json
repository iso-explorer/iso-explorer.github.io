post_cb({"45650950": {"Id": "45650950", "PostTypeId": "2", "Body": "<p>That's called a nested class, not an inner class.\nThe most frequent use case of nested classes are iterators of standard library. Their templates are declared in related container templates. </p>\n<p>To create an instance of nested class, one should  have access to its declaration. It can be instantiated only from <code>outer</code> class or from a friend of that class.</p>\n<pre><code>class outer{\n   int x;   \n\n   class inner;\npublic:\n   void doThings();\n};\n\n   class outer::inner\n   {\n   public:    \n     void print(class outer *p)\n     {\n       std::cout &lt;&lt; \"x=\" &lt;&lt; p-&gt;x;\n     }\n   };\n\n void outer::doThings()\n {\n    outer::inner a;\n    a. print(this);\n }\n\nint main()\n{\n    outer a;\n\n    a.doThings();\n    return 0;\n}\n</code></pre>\n<p>Methods of <code>outer::inner</code> will have access to <code>private</code> and <code>protected</code> members of <code>outer</code></p>\n<blockquote>\n<p id=\"so_45650554_45650950_0\"><strong>9.7 Nested class declarations [class.nest]</strong></p>\n<p id=\"so_45650554_45650950_1\"><strong>1</strong> A class can be declared within another class. A class declared\n  within another is called a nested class. The name of a nested class is\n  local to its enclosing class. The nested class is in the scope of its\n  enclosing class. [ Note: See 5.1 for restrictions on the use of\n  non-static data members and non-static member functions. \u2014end note ]</p>\n</blockquote>\n<pre><code>int x;\nint y;\nstruct enclose {\n    int x;\n    static int s;\n    struct inner {\n        void f(int i) {\n            int a = sizeof(x); // OK: operand of sizeof is an unevaluated operand\n            x = i; // error: assign to enclose::x\n            s = i; // OK: assign to enclose::s\n            ::x = i; // OK: assign to global x\n            y = i; // OK: assign to global y\n        }\n        void g(enclose* p, int i) {\n            p-&gt;x = i; // OK: assign to enclose::x\n        }\n    };\n};\ninner* p = 0; // error: inner not in scope\n</code></pre>\n<blockquote>\n<p id=\"so_45650554_45650950_2\"><strong>2</strong> Member functions and static data members of a nested class can be\n  defined in a namespace scope enclosing the definition of their class.</p>\n</blockquote>\n<pre><code>struct enclose {\n    struct inner {\n        static int x;\n        void f(int i);\n    };\n};\nint enclose::inner::x = 1;\nvoid enclose::inner::f(int i) { / ... / }\n</code></pre>\n<blockquote>\n<p id=\"so_45650554_45650950_3\"><strong>3</strong> If class X is defined in a namespace scope, a nested class Y may be declared in class X and later defined in the definition of class X\n  or be later defined in a namespace scope enclosing the definition of\n  class X.</p>\n</blockquote>\n<pre><code>class E {\n    class I1; // forward declaration of nested class\n    class I2;\n    class I1 { }; // definition of nested class\n};\nclass E::I2 { }; // definition of nested class\n</code></pre>\n<blockquote>\n<p id=\"so_45650554_45650950_4\"><strong>4</strong> Like a member function, a friend function (11.3) defined within a\n  nested class is in the lexical scope of that class; it obeys the same\n  rules for name binding as a static member function of that class\n  (9.4), but it has no special access rights to members of an enclosing\n  class.</p>\n</blockquote>\n", "LastEditorUserId": "2742717", "LastActivityDate": "2017-08-12T13:52:44.060", "Score": "2", "CreationDate": "2017-08-12T13:39:17.447", "ParentId": "45650554", "CommentCount": "3", "LastEditDate": "2017-08-12T13:52:44.060", "OwnerUserId": "2742717"}, "bq_ids": {"n4140": {"so_45650554_45650950_3": {"length": 20, "quality": 1.0, "section_id": 5927}, "so_45650554_45650950_2": {"length": 15, "quality": 1.0, "section_id": 5926}, "so_45650554_45650950_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 5928}, "so_45650554_45650950_1": {"length": 35, "quality": 0.875, "section_id": 5925}}, "n3337": {"so_45650554_45650950_3": {"length": 20, "quality": 1.0, "section_id": 5699}, "so_45650554_45650950_2": {"length": 15, "quality": 1.0, "section_id": 5698}, "so_45650554_45650950_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 5700}, "so_45650554_45650950_1": {"length": 35, "quality": 0.875, "section_id": 5697}}, "n4659": {"so_45650554_45650950_3": {"length": 20, "quality": 1.0, "section_id": 7401}, "so_45650554_45650950_2": {"length": 15, "quality": 1.0, "section_id": 7400}, "so_45650554_45650950_4": {"length": 28, "quality": 0.9655172413793104, "section_id": 7402}, "so_45650554_45650950_1": {"length": 34, "quality": 0.85, "section_id": 7399}}}, "45650596": {"Id": "45650596", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_45650554_45650596_0\">Is there a way to create only instance of class inner?</p>\n</blockquote>\n<p>Yes, you can let have <code>outer</code> creating as many instance independent instances (e.g. as static members or local variables in <code>static</code> member functions) of <code>inner</code> as you want.</p>\n<blockquote>\n<p id=\"so_45650554_45650596_1\">And if this is possible, will this object have acces to <code>outer::print</code> function ? </p>\n</blockquote>\n<p>No. <code>outer::print()</code> is only available with an instance of <code>outer</code>, so at least a parameter or a local instance of <code>outer</code> will be needed.</p>\n<hr>\n<p>The <code>outer</code> and <code>inner</code> class declarations are completely independent regarding instantiation. It's only about the scope:</p>\n<ul>\n<li>The <code>inner</code> type is only seen at the <code>private</code> <code>outer</code> class scope (can be circumvented using anonymous <code>auto</code> types outside of <code>outer</code> received through functions)</li>\n<li><code>inner</code> has access to any <code>public</code>, <code>protected</code> and <code>private</code> members of <code>outer</code> (special scope priviledges)</li>\n<li><code>outer</code> has access to any <code>public</code> members of <code>inner</code> as usual (no special priviledges)</li>\n</ul>\n</hr>", "LastEditorUserId": "8242698", "LastActivityDate": "2017-08-12T13:47:36.460", "Score": "4", "CreationDate": "2017-08-12T13:02:48.750", "ParentId": "45650554", "CommentCount": "2", "LastEditDate": "2017-08-12T13:47:36.460", "OwnerUserId": "8242698"}, "45650554": {"ViewCount": "506", "Body": "<p>I have code like this:</p>\n<pre><code>class outer{\n   int x;\n   class inner{\n     int y;\n   }\n\n   void print(int t_x){\n     std::cout &lt;&lt; t_x;\n   }\n}\n</code></pre>\n<p>Is there a way to create only instance of class inner? And if this is possible, will this object have acces to outer::print function ? </p>\n", "AcceptedAnswerId": "45650596", "Title": "Creating instance of nested class", "CreationDate": "2017-08-12T12:58:54.263", "LastActivityDate": "2017-08-12T13:52:44.060", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "OwnerDisplayName": "user8454791", "Id": "45650554", "Score": "4", "Tags": "<c++><c++11>", "AnswerCount": "2"}});