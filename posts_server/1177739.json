post_cb({"1177995": {"Id": "1177995", "PostTypeId": "2", "Body": "<p>Based on overload resolution rules (Appendix B of <a href=\"http://rads.stackoverflow.com/amzn/click/0201734842\" rel=\"nofollow noreferrer\">C++ Templates: The Complete Guide</a> has a good overview), string literals (const char []) are closer to T* than T&amp;, because the compiler makes no distinction between char[] and char*, so T* is the closest match (const T* would be an exact match).</p>\n<p>In fact, if you could add:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(const T[] a)\n</code></pre>\n<p>(which you can't), your compiler would tell you that this function is a redefinition of:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(const T* a)\n</code></pre>\n", "LastActivityDate": "2009-07-24T14:18:50.270", "CommentCount": "10", "CreationDate": "2009-07-24T14:18:50.270", "ParentId": "1177739", "Score": "0", "OwnerUserId": "1502059"}, "1177797": {"Id": "1177797", "PostTypeId": "2", "Body": "<p>Cause \" \" is a char*, which fits perfectly to foo(T*) function. When you remove this, the compiler will try to make it work with foo(T&amp;), which requires you to pass reference to char array that contains the string.  </p>\n<p>Compiler can't generate one function that would receive reference to char, as you are passing whole array, so it has to dereference it.</p>\n", "LastActivityDate": "2009-07-24T13:47:47.720", "CommentCount": "2", "CreationDate": "2009-07-24T13:47:47.720", "ParentId": "1177739", "Score": "-1", "OwnerUserId": "140843"}, "1177739": {"ViewCount": "1903", "Body": "<p>Given the code below, why is the <code>foo(T*)</code> function selected ?</p>\n<p>If I remove it (the <code>foo(T*)</code>) the code still compiles and works correctly, but G++ v4.4.0 (and probably other compilers as well) will generate two <code>foo()</code> functions: one for char[4] and one for char[7].  </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt; typename T &gt;\nvoid foo( const T&amp; )\n{\n    cout &lt;&lt; \"foo(const T&amp;)\" &lt;&lt; endl;\n}\n\ntemplate&lt; typename T &gt;\nvoid foo( T* )\n{\n    cout &lt;&lt; \"foo(T*)\" &lt;&lt; endl;\n}\n\nint main()\n{\n    foo( \"bar\" );\n    foo( \"foobar\" );\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "1177988", "Title": "What are the rules for choosing from overloaded template functions?", "CreationDate": "2009-07-24T13:40:35.810", "Id": "1177739", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2009-07-24T15:10:31.730", "Score": "10", "OwnerUserId": "140006", "Tags": "<c++><templates>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_1177739_1177988_1": {"length": 18, "quality": 0.9, "section_id": 603}, "so_1177739_1177988_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_1177739_1177988_1": {"length": 18, "quality": 0.9, "section_id": 593}, "so_1177739_1177988_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_1177739_1177988_1": {"length": 18, "quality": 0.9, "section_id": 629}, "so_1177739_1177988_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}, "1178103": {"Id": "1178103", "PostTypeId": "2", "Body": "<p>The full answer is quite technical.</p>\n<p>First, string literals have <code>char const[N]</code> type.</p>\n<p>Then there is an implicit conversion from <code>char const[N]</code> to <code>char const*</code>.</p>\n<p>So both your template function match, one using reference binding, one using the implicit conversion.  When they are alone, both your template functions are able to handle the calls, but when they are both present, we have to explain why the second foo (instantiated with T=char const[N]) is a better match than the first (instantiated with T=char).  If you look at the overloading rules (as given by litb), the choice between</p>\n<pre><code>void foo(char const (&amp;x)[4));\n</code></pre>\n<p>and</p>\n<pre><code>void foo(char const* x);\n</code></pre>\n<p>is ambigous (the rules are quite complicated but you can check by writing non template functions with such signatures and see that the compiler complains).  In that case, the choice is made to the second one because that one is more specialized (again the rules for this partial ordering are complicated, but in this case it is because you can pass a <code>char const[N]</code> to a <code>char const*</code> but not a <code>char const*</code> to a <code>char const[N]</code> in the same way as <code>void bar(char const*)</code> is more specialized than <code>void bar(char*)</code> because you can pass a <code>char*</code> to a <code>char const*</code> but not vise-versa).</p>\n", "LastEditorUserId": "136208", "LastActivityDate": "2009-07-24T15:10:31.730", "Score": "2", "CreationDate": "2009-07-24T14:35:26.390", "ParentId": "1177739", "CommentCount": "0", "OwnerUserId": "136208", "LastEditDate": "2009-07-24T15:10:31.730"}, "1177988": {"Id": "1177988", "PostTypeId": "2", "Body": "<p>Formally, when comparing conversion sequences, lvalue transformations are ignored. Conversions are grouped into several categories, like <em>qualification adjustment</em> (<code>T*</code> -&gt; <code>T const*</code>), <em>lvalue transformation</em> (<code>int[N]</code> -&gt; <code>int*</code>, <code>void()</code> -&gt; <code>void(*)()</code>), and others. </p>\n<p>The only difference between your two candidates is an lvalue transformation. String literals are arrays that convert to pointers. The first candidate accepts the array by reference, and thus won't need an lvalue transformation. The second candidate requires an lvalue transformation. </p>\n<p>So, if there are two candidates that both function template specializations are equally viable by looking only at the conversions, then the rule is that the more specialized one is chosen by doing partial ordering of the two. </p>\n<p>Let's compare the two by looking at their signature of their function parameter list</p>\n<pre><code>void(T const&amp;);\nvoid(T*);\n</code></pre>\n<p>If we choose some unique type <code>Q</code> for the first parameter list and try to match against the second parameter list, we are matching <code>Q</code> against <code>T*</code>. This will fail, since <code>Q</code> is not a pointer. Thus, the second is at least as specialized as the first. </p>\n<p>If we do the other way around, we match <code>Q*</code> against <code>T const&amp;</code>. The reference is dropped and toplevel qualifiers are ignored, and the remaining <code>T</code> becomes <code>Q*</code>. This is an exact match for the purpose of partial ordering, and thus deduction of the transformed parameter list of the second against the first candidate succeeds. Since the other direction (against the second) didn't succeed, the second candidate is <em>more</em> specialized than the first - and in consequence, overload resolution will prefer the second, if there would otherwise be an ambiguity. </p>\n<p>At <code>13.3.3.2/3</code>:</p>\n<blockquote>\n<p id=\"so_1177739_1177988_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if [...] </p>\n<ul>\n<li>S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form\n  defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is considered to be a subsequence of any non-identity conversion sequence) or, if not that [...]</li>\n</ul>\n</blockquote>\n<p>Then <code>13.3.3/1</code></p>\n<blockquote>\n<ul>\n<li>let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the type of the i-th parameter of viable function F. 13.3.3.1 defines the implicit conversion sequences and 13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</li>\n</ul>\n<p id=\"so_1177739_1177988_1\">Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then [...]</p>\n<ul>\n<li>F1 and F2 are function template specializations, and the function template for F1 is more specialized than the template for F2 according to the partial ordering rules described in 14.5.5.2, or, if not that, [...]</li>\n</ul>\n</blockquote>\n<p>Finally, here is the table of implicit conversions that may participate in an standard conversion sequence at <code>13.3.3.1.1/3</code>. </p>\n<p><a href=\"http://img259.imageshack.us/img259/851/convs.png\">Conversion sequences http://img259.imageshack.us/img259/851/convs.png</a></p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2009-07-24T14:37:10.567", "Score": "6", "CreationDate": "2009-07-24T14:17:48.010", "ParentId": "1177739", "CommentCount": "7", "OwnerUserId": "34509", "LastEditDate": "2009-07-24T14:37:10.567"}});