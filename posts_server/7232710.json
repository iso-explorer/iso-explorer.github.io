post_cb({"7232710": {"ViewCount": "28867", "Body": "<p>I've been looking for a way to convert between the Unicode string types and came across <a href=\"http://members.shaw.ca/akochoi/articles/unicode-processing-c++0x/index.html\" rel=\"noreferrer\">this method</a>. Not only do I not completely understand the method (there are no comments) but also the article implies that in future there will be better methods.</p>\n<p>If this is the best method, could you please point out what makes it work, and if not I would like to hear suggestions for better methods.</p>\n", "AcceptedAnswerId": "7235204", "Title": "Convert between string, u16string & u32string", "CreationDate": "2011-08-29T16:09:17.413", "Id": "7232710", "CommentCount": "2", "FavoriteCount": "40", "PostTypeId": "1", "LastEditDate": "2012-01-27T15:56:25.840", "LastEditorUserId": "500104", "LastActivityDate": "2016-01-16T13:24:52.990", "Score": "39", "OwnerUserId": "918124", "Tags": "<c++><string><unicode><c++11><unicode-string>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_7232710_7235204_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 7214}}, "n3337": {"so_7232710_7235204_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 6958}}, "n4659": {"so_7232710_7235204_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 8723}}}, "7232976": {"Id": "7232976", "PostTypeId": "2", "Body": "<p>As far as I know, C++ provides no standard methods to convert from or to UTF-32. However, for UTF-16 there are the methods <strong>mbstowcs</strong> (Multi-Byte to Wide character string), and the inverse, <strong>wcstombs</strong>.</p>\n<p>If you need UTF-32 too, you need <strong>iconv</strong>, which is in POSIX 2001 but not in standard C, so on Windows you'll need a replacement like <strong>libiconv</strong>.</p>\n<p>Here's an example on how to use <strong>mbstowcs</strong>:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n\nusing namespace std;\n\nwstring widestring(const string &amp;text);\n\nint main()\n{\n  string text;\n  cout &lt;&lt; \"Enter something: \";\n  cin &gt;&gt; text;\n\n  wcout &lt;&lt; L\"You entered \" &lt;&lt; widestring(text) &lt;&lt; \".\\n\";\n  return 0;\n}\n\nwstring widestring(const string &amp;text)\n{\n  wstring result;\n  result.resize(text.length());\n  mbstowcs(&amp;result[0], &amp;text[0], text.length());\n  return result;\n}\n</code></pre>\n<p>The reverse goes like this:</p>\n<pre><code>string mbstring(const wstring &amp;text)\n{\n  string result;\n  result.resize(text.length());\n  wcstombs(&amp;result[0], &amp;text[0], text.length());\n  return result;\n}\n</code></pre>\n<p><strong>Nitpick:</strong> Yes, I know, the size of wchar_t is implementation defined, so it <em>could</em> be 4 Bytes (UTF-32). However, I don't know a compiler which does that.</p>\n", "LastActivityDate": "2011-08-29T16:31:13.720", "CommentCount": "4", "CreationDate": "2011-08-29T16:31:13.720", "ParentId": "7232710", "Score": "-2", "OwnerUserId": "392858"}, "7235204": {"Id": "7235204", "PostTypeId": "2", "Body": "<p><code>mbstowcs()</code> and <code>wcstombs()</code> don't necessarily convert to UTF-16 or UTF-32, they convert to <code>wchar_t</code> and whatever the locale <code>wchar_t</code> encoding is. All Windows locales uses a two byte <code>wchar_t</code> and UTF-16 as the encoding, but the other major platforms use a 4-byte <code>wchar_t</code> with UTF-32 (or even a non-Unicode encoding for some locales). A platform that only supports single-byte encodings could even have a one byte <code>wchar_t</code> and have the encoding differ by locale. So <code>wchar_t</code> seems to me to be a bad choice for portability and Unicode. *</p>\n<p>Some better options have been introduced in C++11; new specializations of std::codecvt, new codecvt classes, and a new template to make using them for conversions very convienent.</p>\n<p>First the new template class for using codecvt is std::wstring_convert. Once you've created an instance of a std::wstring_convert class you can easily convert between strings:</p>\n<pre><code>std::wstring_convert&lt;...&gt; convert; // ... filled in with a codecvt to do UTF-8 &lt;-&gt; UTF-16\nstd::string utf8_string = u8\"This string has UTF-8 content\";\nstd::u16string utf16_string = convert.from_bytes(utf8_string);\nstd::string another_utf8_string = convert.to_bytes(utf16_string);\n</code></pre>\n<p>In order to do different conversion you just need different template parameters, one of which is a codecvt facet. Here are some new facets that are easy to use with wstring_convert:</p>\n<pre><code>std::codecvt_utf8_utf16&lt;char16_t&gt; // converts between UTF-8 &lt;-&gt; UTF-16\nstd::codecvt_utf8&lt;char32_t&gt; // converts between UTF-8 &lt;-&gt; UTF-32\nstd::codecvt_utf8&lt;char16_t&gt; // converts between UTF-8 &lt;-&gt; UCS-2 (warning, not UTF-16! Don't bother using this one)\n</code></pre>\n<p>Examples of using these:</p>\n<pre><code>std::wstring_convert&lt;std::codecvt_utf8_utf16&lt;char16_t&gt;,char16_t&gt; convert;\nstd::string a = convert.to_bytes(u\"This string has UTF-16 content\");\nstd::u16string b = convert.from_bytes(u8\"blah blah blah\");\n</code></pre>\n<p>The new std::codecvt specializations are a bit harder to use because they have a protected destructor. To get around that you can define a subclass that has a destructor, or you can use the std::use_facet template function to get an existing codecvt instance. Also, an issue with these specializations is you can't use them in Visual Studio 2010 because template specialization doesn't work with typedef'd types and that compiler defines char16_t and char32_t as typedefs. Here's an example of defining your own subclass of codecvt:</p>\n<pre><code>template &lt;class internT, class externT, class stateT&gt;\nstruct codecvt : std::codecvt&lt;internT,externT,stateT&gt;\n{ ~codecvt(){} };\n\nstd::wstring_convert&lt;codecvt&lt;char16_t,char,std::mbstate_t&gt;,char16_t&gt; convert16;\nstd::wstring_convert&lt;codecvt&lt;char32_t,char,std::mbstate_t&gt;,char32_t&gt; convert32;\n</code></pre>\n<p>The char16_t specialization converts between UTF-16 and UTF-8. The char32_t specialization, UTF-32 and UTF-8.</p>\n<p>Note that these new conversions provided by C++11 don't include any way to convert directly between UTF-32 and UTF-16. Instead you just have to combine two instances of std::wstring_convert.</p>\n<hr>\n<p>***** I thought I'd add a note on wchar_t and its purpose, to emphasize why it should not generally be used for Unicode or portable internationalized code. The following is a short version of my answer <a href=\"https://stackoverflow.com/a/11107667/365496\">https://stackoverflow.com/a/11107667/365496</a></p>\n<h3>What is wchar_t?</h3>\n<p>wchar_t is defined such that any locale's char encoding can be converted to wchar_t where every wchar_t represents exactly one codepoint:</p>\n<blockquote>\n<p id=\"so_7232710_7235204_0\">Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.3.1). -- <em>[basic.fundamental] 3.9.1/5</em></p>\n</blockquote>\n<p>This <em>does not</em> require that wchar_t be large enough to represent any character from all locales simultaneously. That is, the encoding used for wchar_t may differ between locales. Which means that you cannot necessarily convert a string to wchar_t using one locale and then convert back to char using another locale.</p>\n<p>Since that seems to be the primary use in practice for wchar_t you might wonder what it's good for if not that.</p>\n<p>The original intent and purpose of wchar_t was to make text processing simple by defining it such that it requires a one-to-one mapping from a string's code-units to the text's characters, thus allowing the use of same simple algorithms used with ascii strings to work with other languages.</p>\n<p>Unfortunately the requirements on wchar_t assume a one-to-one mapping between characters and codepoints to achieve this. Unicode breaks that assumption, so you can't safely use wchar_t for simple text algorithms either.</p>\n<p>This means that portable software cannot use wchar_t either as a common representation for text between locales, or to enable the use of simple text algorithms.</p>\n<h3>What use is wchar_t today?</h3>\n<p>Not much, for portable code anyway. If <code>__STDC_ISO_10646__</code> is defined then values of wchar_t directly represent Unicode codepoints with the same values in all locales. That makes it safe to do the inter-locale conversions mentioned earlier. However you can't rely only on it to decide that you can use wchar_t this way because, while most unix platforms define it, Windows does not even though Windows uses the same wchar_t locale in all locales.</p>\n<p>The reason Windows doesn't define <code>__STDC_ISO_10646__</code> I think is because Windows use UTF-16 as its wchar_t encoding, and because UTF-16 uses surrogate pairs to represent codepoints greater than U+FFFF, which means that UTF-16 doesn't satisfy the requirements for <code>__STDC_ISO_10646__</code>.</p>\n<p>For platform specific code wchar_t may be more useful. It's essentially required on Windows (e.g., some files simply cannot be opened without using wchar_t filenames), though Windows is the only platform where this is true as far as I know (so maybe we can think of wchar_t as 'Windows_char_t').</p>\n<p>In hindsight wchar_t is clearly not useful for simplifying text handling, or as storage for locale independent text. Portable code should not attempt to use it for these purposes.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-31T14:35:11.773", "Score": "81", "CreationDate": "2011-08-29T19:58:53.710", "ParentId": "7232710", "CommentCount": "10", "OwnerUserId": "365496", "LastEditDate": "2017-05-23T12:10:41.897"}, "31389037": {"Id": "31389037", "PostTypeId": "2", "Body": "<p>I've written helper functions to convert to/from UTF8 strings (C++11):</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;locale&gt;\n#include &lt;codecvt&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstring toUTF8(const basic_string&lt;T, char_traits&lt;T&gt;, allocator&lt;T&gt;&gt;&amp; source)\n{\n    string result;\n\n    wstring_convert&lt;codecvt_utf8_utf16&lt;T&gt;, T&gt; convertor;\n    result = convertor.to_bytes(source);\n\n    return result;\n}\n\ntemplate &lt;typename T&gt;\nvoid fromUTF8(const string&amp; source, basic_string&lt;T, char_traits&lt;T&gt;, allocator&lt;T&gt;&gt;&amp; result)\n{\n    wstring_convert&lt;codecvt_utf8_utf16&lt;T&gt;, T&gt; convertor;\n    result = convertor.from_bytes(source);\n}\n</code></pre>\n<p>Usage example:</p>\n<pre><code>// Unicode &lt;-&gt; UTF8\n{\n    wstring uStr = L\"Unicode string\";\n    string str = toUTF8(uStr);\n\n    wstring after;\n    fromUTF8(str, after);\n    assert(uStr == after);\n}\n\n// UTF16 &lt;-&gt; UTF8\n{\n    u16string uStr;\n    uStr.push_back('A');\n    string str = toUTF8(uStr);\n\n    u16string after;\n    fromUTF8(str, after);\n    assert(uStr == after);\n}\n</code></pre>\n", "LastEditorUserId": "1792865", "LastActivityDate": "2016-01-16T13:24:52.990", "Score": "11", "CreationDate": "2015-07-13T16:49:34.413", "ParentId": "7232710", "CommentCount": "0", "OwnerUserId": "1792865", "LastEditDate": "2016-01-16T13:24:52.990"}});