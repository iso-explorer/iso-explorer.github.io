post_cb({"48992509": {"ViewCount": "88", "Body": "<p>I am a newbie in C++ and I have encountered a problem that I need to define a new data types (unions concretely) via typedef in my class. The relevant code snippet of .h module of my class is following</p>\n<pre><code>class Manager\n{\n\n  public:\n\n    static const uint8_t NO_BYTES_IN_PACKET;\n    static const uint8_t NO_PYLD_BYTES_IN_CONTROL_PACKET;\n\n    // control packet structure\n    typedef union{\n        struct{\n            uint8_t header[3];                                \n            uint8_t payload[NO_PYLD_BYTES_IN_CONTROL_PACKET];  \n        }pkt_parts_t;\n        uint8_t pkt_array[NO_BYTES_IN_PACKET];\n    }control_pkt_u;\n\n  private:\n\n}\n</code></pre>\n<p>My problem is that the constants</p>\n<pre><code>static const uint8_t NO_BYTES_IN_PACKET;\nstatic const uint8_t NO_PYLD_BYTES_IN_CONTROL_PACKET;\n</code></pre>\n<p>are defined in associated .cpp module</p>\n<pre><code>const uint8_t Manager::NO_BYTES_IN_PACKET = 8;\nconst uint8_t Manager::NO_PYLD_BYTES_IN_CONTROL_PACKET = 5;\n</code></pre>\n<p>Due to that I have been receiving an error message: <strong>error: array bound is not an integer constant before ']' token</strong> during compilation process. My idea was to move the union definition into the .cpp module but I am not sure whether it is correct approach. What are your opinions? Thank you for any ideas. </p>\n", "Title": "C++ new types definition via typedef", "CreationDate": "2018-02-26T16:08:22.797", "LastActivityDate": "2018-02-26T19:28:21.630", "CommentCount": "3", "PostTypeId": "1", "Id": "48992509", "Score": "0", "OwnerUserId": "6006544", "Tags": "<c++><header-files><typedef><unions>", "AnswerCount": "2"}, "48992582": {"Id": "48992582", "PostTypeId": "2", "Body": "<p>The problem is that <code>static const</code> doesn't mean that it's a compile time constant.  As an example where it isn't, it could be the time that the program started.</p>\n<p>What you want is <code>constexpr</code> that tells the compiler that it can be calculated at compiler time, meaning that your array size is well defined and it conveys your intention much more clearly.</p>\n<p>ie</p>\n<pre><code>class Manager{\n    public:\n        constexpr uint8_t NO_BYTES_IN_PACKET = 8;\n        ...\n</code></pre>\n<p>In addition; it will force you to resolve the real problem which is that other compilation units are unable to see the size of the constant as you've not defined it in the header.</p>\n", "LastEditorUserId": "6387170", "LastActivityDate": "2018-02-26T17:31:41.520", "Score": "1", "CreationDate": "2018-02-26T16:12:35.303", "ParentId": "48992509", "CommentCount": "7", "OwnerUserId": "6387170", "LastEditDate": "2018-02-26T17:31:41.520"}, "bq_ids": {"n4140": {"so_48992509_48992575_0": {"length": 58, "quality": 0.90625, "section_id": 5908}}, "n3337": {"so_48992509_48992575_0": {"length": 58, "quality": 0.90625, "section_id": 5680}}}, "48992575": {"Id": "48992575", "PostTypeId": "2", "Body": "<p>If you don't <em>odr-use</em> those <code>static const int</code>, you don't need to define them in .cc file, just put the values in .h file:</p>\n<pre><code>class Manager\n{\n\n  public:\n\n    static const uint8_t NO_BYTES_IN_PACKET = 8;\n    static const uint8_t NO_PYLD_BYTES_IN_CONTROL_PACKET = 5;\n\n/* .... */\n\n};\n</code></pre>\n<p>However, if you odr-use those constants, like taking their addresses, then you need to define them in a .cc file, the class definition in .h file remains the same:</p>\n<pre><code>const uint8_t Manager::NO_BYTES_IN_PACKET;\nconst uint8_t Manager::NO_PYLD_BYTES_IN_CONTROL_PACKET;\n</code></pre>\n<p><strong>EDIT</strong>:\nFor comments or other answers claiming that <code>static const int</code> can't be used as a compile-time constant, their claim is wrong.</p>\n<p>The following is quoted from <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]/3</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48992509_48992575_0\">If a non-volatile const static data member is of integral or enumeration type, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression ([expr.const]). A static data member of literal type can be declared in the class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression. [ Note: <strong>In both these cases, the member may appear in constant expressions.</strong>  \u2014 end note ] <strong>The member shall still be defined in a namespace scope if it is odr-used</strong> ([basic.def.odr]) in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n", "LastEditorUserId": "8605791", "LastActivityDate": "2018-02-26T19:28:21.630", "Score": "1", "CreationDate": "2018-02-26T16:12:17.340", "ParentId": "48992509", "CommentCount": "19", "OwnerUserId": "8605791", "LastEditDate": "2018-02-26T19:28:21.630"}});