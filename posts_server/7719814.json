post_cb({"7719863": {"ParentId": "7719814", "CommentCount": "0", "Body": "<p>You don't.<br>\nThe compiler is basically allowed to do whatever it wants with regards to inlining functions. A function can be inlined in one place and not inlined in another place.</br></p>\n<p>If you're thinking about this, you're probably prematurely optimizing something.</p>\n", "OwnerUserId": "9611", "PostTypeId": "2", "Id": "7719863", "Score": "2", "CreationDate": "2011-10-10T23:37:07.603", "LastActivityDate": "2011-10-10T23:37:07.603"}, "7719884": {"ParentId": "7719814", "CommentCount": "0", "Body": "<p>You can't. According to the C++ standard [basic.def.odr] (D refers to the definition in question):</p>\n<blockquote>\n<p id=\"so_7719814_7719884_0\">... If the definitions of D satisfy all these requirements, then the\n  program shall behave as if there were a single definition of D. If the\n  definitions of D do not satisfy these requirements, then the behavior\n  is undefined.</p>\n</blockquote>\n<p>Taking the address of a function, inline or otherwise, must result in the same behavior as if there were a single definition of that function. For inline functions, it means the address is the same.</p>\n", "OwnerUserId": "6210", "PostTypeId": "2", "Id": "7719884", "Score": "0", "CreationDate": "2011-10-10T23:40:10.317", "LastActivityDate": "2011-10-10T23:40:10.317"}, "7720016": {"ParentId": "7719814", "CommentCount": "0", "Body": "<p>You really can't - even with GCC, function's declared with <code>__attribute__((always_inline))</code> won't be inlined if they don't meet the compiler's criteria for things that would increase the speed of the program.</p>\n<p>Inlining functions can have serious negative effects on performance, and the compiler is almost always the only thing in the right position to know if that's the case.  Inlining functions thwarts CPU architectural features like code cache and branch predictors, and even lower-level features like instruction decode cache (and bandwidth).</p>\n<p>In short, there are some things that any modern CPU will do at tremendous speed, and C/C++ function calls are right up there.  Profiling function call overhead is almost certainly going to give within-error measurements of your profiling overhead.</p>\n", "OwnerUserId": "918764", "PostTypeId": "2", "Id": "7720016", "Score": "0", "CreationDate": "2011-10-11T00:01:54.090", "LastActivityDate": "2011-10-11T00:01:54.090"}, "7719833": {"ParentId": "7719814", "CommentCount": "7", "Body": "<p>What do you mean generically? Do you want to have a function that tells you if another function is declared <code>inline</code>? That can't be done. </p>\n<p>Also note that by taking the address of an inline function, the implementation is forced to actually have an out of line implementation of the function.</p>\n", "OwnerUserId": "927034", "PostTypeId": "2", "Id": "7719833", "Score": "4", "CreationDate": "2011-10-10T23:32:15.447", "LastActivityDate": "2011-10-10T23:32:15.447"}, "7719814": {"CommentCount": "2", "ViewCount": "137", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-10-10T23:29:47.390", "LastActivityDate": "2011-10-11T00:01:54.090", "Title": "How to determine C++ inline functions?", "LastEditDate": "2011-10-10T23:35:04.890", "Id": "7719814", "Score": "3", "Body": "<p>I have the following piece of code.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ninline void inlinefunc() { cout &lt;&lt; \"hello\" &lt;&lt; endl; }\nvoid func() { cout &lt;&lt; \"hello\" &lt;&lt; endl; }\n\nbool isInlineFunc(void (*f)()) { return (f == inlinefunc); }\n\nvoid print(void (*f)()) {\n    cout &lt;&lt; (isInlineFunc(f)?\"inline - \":\"normal -\");\n    f();\n}\n\nint main() {\n    void (*f)();\n\n    f = inlinefunc;\n    print(f);\n\n    f = func;\n    print(f);\n}\n</code></pre>\n<p>How do I <strong>generically</strong> write <code>isInlineFunc</code>?</p>\n", "Tags": "<c++><inline><detection>", "OwnerUserId": "186112", "AnswerCount": "5"}, "7719917": {"ParentId": "7719814", "CommentCount": "0", "Body": "<p>In general, compiler can apply any optimization it chooses, as long as it doesn't change the semantics of your code.</p>\n<p>Inlining is just an optimization strategy. \"Detecting\" whether the function was inlined or not would mean that the semantics depends on the optimization, in direct violation of the above.</p>\n", "OwnerUserId": "533120", "PostTypeId": "2", "Id": "7719917", "Score": "0", "CreationDate": "2011-10-10T23:44:36.437", "LastActivityDate": "2011-10-10T23:44:36.437"}, "bq_ids": {"n4140": {"so_7719814_7719884_0": {"section_id": 7043, "quality": 0.9375, "length": 15}}, "n3337": {"so_7719814_7719884_0": {"section_id": 6788, "quality": 1.0, "length": 16}}, "n4659": {"so_7719814_7719884_0": {"section_id": 8540, "quality": 0.9375, "length": 15}}}});