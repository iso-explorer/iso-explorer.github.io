post_cb({"bq_ids": {"n4140": {"so_8191908_8192219_0": {"length": 27, "quality": 1.0, "section_id": 190}}, "n3337": {"so_8191908_8192219_0": {"length": 27, "quality": 1.0, "section_id": 184}}, "n4659": {"so_8191908_8192219_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 195}}}, "8192632": {"Id": "8192632", "PostTypeId": "2", "Body": "<p>Simple: when instantiating <code>TBase&lt; int, TDerived&lt; int&gt; &gt;</code> template <strong>class definition</strong>, the declaration of <code>Call&lt;&gt;</code> function template is instantiated:</p>\n<pre><code>  template&lt; typename PType &gt;\n  static void Call( PType , void(TDerived_::*pFunction)() = &amp;TSelf_::Foo, TDerived_ pDerived = TDerived_() )\n</code></pre>\n<p>(with <code>TDerived_</code> = <code>TDerived&lt; int&gt;</code>), which is fine as <code>TSelf_::Foo()</code> is declared at this point.</p>\n<p>OTOH, the problem with</p>\n<pre><code>static void Call( PType , void(TDerived_::*pFunction)() = &amp;TDerived_::Foo, TDerived_ pDerived = TDerived_() )\n</code></pre>\n<p>is that <code>TDerived_::Foo()</code> is not declared during <code>TBase&lt; int, TDerived&lt; int&gt; &gt;</code> template class definition instantiation.</p>\n<p>BTW, you don't need to specifiy a parameter list as <code>( void )</code>; <code>()</code> has the same effect and is less verbose.</p>\n", "LastActivityDate": "2011-11-19T07:32:43.843", "CommentCount": "4", "CreationDate": "2011-11-19T07:32:43.843", "ParentId": "8191908", "Score": "1", "OwnerUserId": "963864"}, "8192219": {"Id": "8192219", "PostTypeId": "2", "Body": "<p>The scoping for the <code>TValue_</code> parameter to the type in the typedef for <code>TBase_</code> in <code>TDerived</code> appears to be wrong (!)</p>\n<p>You have:</p>\n<pre><code> private:\n  typedef TBase&lt; TValue_, TDerived &gt; TBase_;\n</code></pre>\n<p>I think you need:</p>\n<pre><code> private:\n  typedef TBase&lt; typename TBase&lt; PValue, TDerived&lt; PValue &gt; &gt;::TValue_, TDerived &gt; TBase_;\n</code></pre>\n<p>Or even just:</p>\n<pre><code> private:\n  typedef TBase&lt; PValue, TDerived &gt; TBase_;\n</code></pre>\n<hr>\n<p><strong>EDIT</strong>: The C++ standard section 14.6.2 para 3 covers this case:</p>\n<blockquote>\n<p id=\"so_8191908_8192219_0\">In the definition of a class or class template, if a base class\n  depends on a template-parameter, the base class scope is not examined\n  during unqualified name lookup either at the point of definition of\n  the class template or member or during an instantiation of the class\n  template or member</p>\n</blockquote>\n</hr>", "LastEditorUserId": "183397", "LastActivityDate": "2011-11-19T07:43:34.603", "Score": "2", "CreationDate": "2011-11-19T05:55:49.923", "ParentId": "8191908", "CommentCount": "11", "OwnerUserId": "183397", "LastEditDate": "2011-11-19T07:43:34.603"}, "8191908": {"ViewCount": "245", "Body": "<p>\nHi there,</p>\n<p>While making a CRTP-based generic wrapper to call arbitrary library functions, I've encountered a problem which I have trouble understanding. Here is a very simplified code to illustrate the problem:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n\ntemplate&lt; typename PValue, typename PDerived &gt;\nclass TBase\n{\n private:\n  typedef TBase TSelf_;\n  typedef PDerived TDerived_;\n\n protected:\n  typedef PValue TValue_;\n\n protected:\n  TBase( void )\n  {\n   std::cout &lt;&lt; \" TBase::TBase() \" &lt;&lt; std::endl;\n  }\n\n public:\n  void Foo( void )\n  {\n   std::cout &lt;&lt; \" TBase::Foo() \" &lt;&lt; std::endl;\n  }\n\n  template&lt; typename PType &gt;\n  static void Call( PType /*pSomething*/, void(TDerived_::*pFunction)( void ) = &amp;TSelf_::Foo, TDerived_ pDerived = TDerived_() )\n  {\n   ( pDerived.*pFunction )();\n   std::cout &lt;&lt; \" static TBase::Call(). \" &lt;&lt; std::endl;\n  }\n};\n\ntemplate&lt; typename PValue &gt;\nclass TDerived : public TBase&lt; PValue, TDerived&lt; PValue &gt; &gt;\n{\n  friend class TBase&lt; PValue, TDerived&lt; PValue &gt; &gt; ;\n private:\n  typedef TBase&lt; PValue, TDerived &gt; TBase_;\n  typedef TDerived TSelf_;\n public:\n  TDerived( void ) :\n   TBase_()\n  {\n   std::cout &lt;&lt; \" TDerived::TDerived() \" &lt;&lt; std::endl;\n  }\n  void Foo( void )\n  {\n   std::cout &lt;&lt; \" TDerived::Foo() \" &lt;&lt; std::endl;\n  }\n  void Bar( void )\n  {\n   std::cout &lt;&lt; \" TDerived::Bar() \" &lt;&lt; std::endl;\n  }\n};\n\nint main( void )\n{\n TDerived&lt; int &gt;::Call( 1 );\n TDerived&lt; int &gt;::Call( 1, &amp;TDerived&lt; int &gt;::Foo );\n TDerived&lt; int &gt;::Call( 1, &amp;TDerived&lt; int &gt;::Bar, TDerived&lt; int &gt; () );\n return ( 0 );\n}\n</code></pre>\n<p>Everything compiles and works as intended. However, if I try to use pointer to <code>TDerived::Foo()</code> as a default argument for the second parameter in <code>TBase::Call(...)</code>:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>static void Call( PType /*pSomething*/, void(TDerived_::*pFunction)( void ) = &amp;TDerived_::Foo, TDerived_ pDerived = TDerived_() )\n</code></pre>\n<p>compilers gives a syntax error... I have a feeling it is related to how compiler parses code and that it cannot figure out pointer to a function of yet to be defined (or instantiated) class. However, it has no problem calling <code>TDerived</code> constructor as a default argument for the third parameter of <code>TBase::Call(...)</code>. Can someone give me a definite answer about what's going on? Why derived class MFP is not accepted, and object of derived class is accepted as default arguments?</p>\n<p>Thanks.</p>\n<p>EDIT: compiler's error (MSVS2010 command line compiler):</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>FMain.cpp(224) : error C2061: syntax error : identifier 'TDerived_'; FMain.cpp(233) : see reference to class template instantiation 'TBase&lt;PValue,PDerived&gt; with [PValue=int,PDerived=TDerived&lt;int&gt;]' being compiled; FMain.cpp(323) : see reference to class template instantiation 'TDerived&lt;PValue&gt; with [PValue=int]' being compiled\n</code></pre>\n<p>It's a syntax error - it does not recognize <code>TDerived_</code> as type in default argument for MFP. There are other errors following this one, they are all syntax errors, since function definition is ill-formed now. That is how I understand it.</p>\n<p>EDIT: Basically, I don't understand why can I use an object of <code>TDerived_</code> as a default argument, but can not use a pointer to a member function as a default argument.</p>\n<p>EDIT: Ok, this is driving me crazy now.\nFirst of all, I changed to <code>typedef TBase&lt; PValue, TDerived &gt; TBase_;</code> as it was pointed out (thank you, guys!). Indeed, it only compiled under MSVC++, since this compiler does not do two-part parsing; i.e., on codepad.org (which uses g++ 4.1.2) it didn't compile.\nSecond, after that, I tried to use <code>static void Call( PType /*pSomething*/, void(TDerived_::*pFunction)( void ) = &amp;TDerived_::Foo, TDerived_ pDerived = TDerived_() )</code> on codepad.org and... it compiled and run correctly! So I'm REALLY confused now: people explained to me why it's not correct (and I couldn't understand \"why\" (see my previous EDIT)) and now it turns out g++ compiles it correctly... Does it mean it just MSVC++ problem and not the code? Or code does have a problem from the Standard point of view (and I cannot see it) and g++ accept it \"by mistake\" (unlikely, I think)?.. Help?!</p>\n", "AcceptedAnswerId": "8192219", "Title": "CRTP-related compiler error on pointer-to-a-member-function default value", "CreationDate": "2011-11-19T04:28:43.190", "Id": "8191908", "CommentCount": "3", "LastEditDate": "2011-11-19T10:29:29.607", "PostTypeId": "1", "LastEditorUserId": "917249", "LastActivityDate": "2011-11-19T10:29:29.607", "Score": "0", "OwnerUserId": "917249", "Tags": "<c++><templates><crtp><pointer-to-member>", "AnswerCount": "2"}});