post_cb({"bq_ids": {"n4140": {"so_31347198_31347486_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 1007}, "so_31347198_31347486_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 1008}}, "n3337": {"so_31347198_31347486_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 992}}, "n4659": {"so_31347198_31347486_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 802}}}, "31347486": {"Id": "31347486", "PostTypeId": "2", "Body": "<p>In C++11, [map.access] reads:</p>\n<blockquote>\n<p id=\"so_31347198_31347486_0\"><code>T&amp; operator[](const key_type&amp; x);</code></p>\n<p id=\"so_31347198_31347486_1\">1 <em>Effects</em>: If there is no key equivalent to <code>x</code> in the map, inserts <code>value_type(x, T())</code> into the map.</p>\n<p id=\"so_31347198_31347486_2\">2 <em>Requires</em>: <code>key_type</code> shall be CopyInsertable and <code>mapped_type</code> shall be DefaultInsertable into\n  *this.</p>\n<p id=\"so_31347198_31347486_3\">3 <em>Returns</em>: A reference to the mapped_type corresponding to x in *this.</p>\n<p id=\"so_31347198_31347486_4\">4 <em>Complexity</em>: Logarithmic.</p>\n</blockquote>\n<p>The only requirement on <code>operator[]</code> on <code>mapped_type</code> is that it is DefaultInsertable (basically, DefaultConstructible). If the library doesn't support a non-copyable <code>mapped_type</code> with <code>operator[]</code>, then it's a bug. </p>\n", "LastActivityDate": "2015-07-10T18:07:21.090", "CommentCount": "5", "CreationDate": "2015-07-10T18:07:21.090", "ParentId": "31347198", "Score": "3", "OwnerUserId": "2069064"}, "31347198": {"ViewCount": "427", "Body": "<p>Consider this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nclass Foo {\n  public:\n  Foo() {}\n  virtual ~Foo() {}\n\n  void DoFoo() { cout &lt;&lt; \"Foo\" &lt;&lt; endl; }\n\n  Foo(const Foo&amp;) = delete;\n  void operator=(const Foo&amp;) = delete;\n};\n\nint main() {\n  map&lt;string, Foo&gt; m;\n  m[\"Foo\"].DoFoo();\n}\n</code></pre>\n<p>Both g++ and clang++ fail compilation when they're using a <code>libstdc++</code> version earlier than 4.8. The exact error message clang++ spits out is:</p>\n<blockquote>\n<p id=\"so_31347198_31347198_0\">In file included from /usr/include/c++/4.6/iostream:39:</p>\n<p id=\"so_31347198_31347198_1\">In file included from /usr/include/c++/4.6/ostream:39:</p>\n<p id=\"so_31347198_31347198_2\">In file included from /usr/include/c++/4.6/ios:40:</p>\n<p id=\"so_31347198_31347198_3\">In file included from /usr/include/c++/4.6/bits/char_traits.h:40:</p>\n<p id=\"so_31347198_31347198_4\">In file included from /usr/include/c++/4.6/bits/stl_algobase.h:65:</p>\n<p id=\"so_31347198_31347198_5\">/usr/include/c++/4.6/bits/stl_pair.h:121:35: error: call to deleted\n  constructor of 'Foo'</p>\n<p id=\"so_31347198_31347198_6\">: first(std::forward&lt;_U1&gt;(__x)), second(__y) { }</p>\n<p id=\"so_31347198_31347198_7\">^ ~~~</p>\n<p id=\"so_31347198_31347198_8\">/usr/include/c++/4.6/bits/stl_pair.h:267:14: note: in instantiation of\n  function template specialization 'std::pair,\n  Foo&gt;::pair, void&gt;' requested here</p>\n<p id=\"so_31347198_31347198_9\">return __pair_type(std::forward&lt;_T1&gt;(__x), std::forward&lt;_T2&gt;(__y));</p>\n<p id=\"so_31347198_31347198_10\">^</p>\n<p id=\"so_31347198_31347198_11\">/usr/include/c++/4.6/bits/stl_map.h:467:29: note: in instantiation of\n  function template specialization\n  'std::make_pair, Foo&gt;' requested here</p>\n<p id=\"so_31347198_31347198_12\">__i = insert(__i, std::make_pair(std::move(__k), mapped_type()));</p>\n<p id=\"so_31347198_31347198_13\">^</p>\n<p id=\"so_31347198_31347198_14\">21 : note: in instantiation of member function 'std::map, Foo,\n  std::less &gt;, std::allocator, Foo&gt; &gt; &gt;::operator[]' requested here</p>\n<p id=\"so_31347198_31347198_15\">m[\"Foo\"].DoFoo();</p>\n</blockquote>\n<p>It seems like <code>std::pair</code>'s constructor is trying to use <code>Foo</code>'s copy-constructor, which I guess is fair enough since <code>Foo</code> doesn't declare a move constructor. As I would expect, providing a (default) move constructor fixes the issue.</p>\n<p>However, compilation succeeds without a move constructor defined when the version of <code>libstdc++</code> used is 4.8 or higher. I'm confident that the compiler is the same in both cases and only the <code>libstdc++</code> version varies. <code>Foo(Foo&amp;&amp;) = delete;</code> also doesn't affect clang's ability to properly compile in this case.</p>\n<p>My question has a few facets:</p>\n<p>Why does the old version of <code>libstdc++</code> require the move constructor to be user-provided in order to use it instead of the copy-constructor?</p>\n<p>What's different in the newer version of the library that allows it to create the new element (as per <code>operator[]</code>'s contract) without any move/copy constructors or <code>operator=</code>?</p>\n<p>Which of the implementation is conforming? What does the standard say about <code>std::map&lt;K, V&gt;::mapped_type</code>, if anything?</p>\n", "AcceptedAnswerId": "31347486", "Title": "What are the restrictions on std::map<K, V>::mapped_type?", "CreationDate": "2015-07-10T17:50:16.670", "Id": "31347198", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2015-07-10T18:07:21.090", "Score": "3", "OwnerUserId": "600591", "Tags": "<c++><c++11><standards><standard-library>", "AnswerCount": "1"}});