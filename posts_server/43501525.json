post_cb({"bq_ids": {"n4140": {"so_43501525_43501589_1": {"section_id": 5559, "quality": 0.9375, "length": 30}, "so_43501525_43501589_0": {"section_id": 5564, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_43501525_43501589_1": {"section_id": 5341, "quality": 0.9375, "length": 30}, "so_43501525_43501589_0": {"section_id": 5346, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_43501525_43501589_1": {"section_id": 7006, "quality": 0.9375, "length": 30}, "so_43501525_43501589_0": {"section_id": 7011, "quality": 0.5714285714285714, "length": 4}}}, "43501577": {"ParentId": "43501525", "CommentCount": "2", "Body": "<p>Formally any iterator pointing to an element on or after the erased element is invalidated. So</p>\n<ol>\n<li><p>Yes this is UB (despite it being a pointer under the hood.)</p></li>\n<li><p>UB again, despite the obvious plausibility.</p></li>\n</ol>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "43501577", "Score": "1", "CreationDate": "2017-04-19T16:46:09.963", "LastActivityDate": "2017-04-19T16:46:09.963"}, "43501525": {"CommentCount": "0", "ViewCount": "86", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-04-19T16:43:17.667", "LastActivityDate": "2017-04-21T03:17:30.187", "Title": "Invalidated iterator in a vector", "LastEditDate": "2017-05-23T12:25:57.213", "Id": "43501525", "Score": "3", "Body": "<p>I'm aware erasing will invalidate iterators at and after the point of the erase. Consider:</p>\n<pre><code>std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\nstd::vector&lt;int&gt;::iterator it = vec.end() - 1; //last element\nvec.erase(vec.begin()); //shift everything one to the left, 'it' should be the new 'end()' ?\nstd::cout &lt;&lt; (it == vec.end()); //not dereferencing 'it', just comparing, UB ?\n</code></pre>\n<p>Is it undefined behavior to compare (not dereference) an invalidated iterator (<code>it</code> in this case)? If not, is <code>it == vec.end()</code> guaranteed to hold true?</p>\n<p><strong>Edit</strong>: from the top answer it looks like this is UB if only <code>it</code> is a <strong>singular value</strong>. But from <a href=\"https://stackoverflow.com/questions/5441893/what-is-singular-and-non-singular-values-in-the-context-of-stl-iterators\">What is singular and non-singular values in the context of STL iterators?</a> it seems like <code>it</code> is (or <em>was</em>) associated with the container hence making <code>it</code> <strong>non-singular</strong>. </p>\n<p>I'd appreciate further analysis on this, thank you.</p>\n", "Tags": "<c++><vector><iterator><language-lawyer><undefined-behavior>", "OwnerUserId": "2288628", "AnswerCount": "2"}, "43501589": {"ParentId": "43501525", "CommentCount": "4", "Body": "<p>Once your iterator has been invalidated, it may be UB to even compare it to something else:</p>\n<blockquote>\n<p id=\"so_43501525_43501589_0\"><code>[C++14: 24.2.1/10]:</code> An <em>invalid</em> iterator is an iterator that may be singular.</p>\n<p id=\"so_43501525_43501589_1\"><code>[C++14: 24.2.1/5]:</code> <em>[..]</em> Results of most expressions are undefined for singular values; the only exceptions are destroying an iterator that holds a singular value, the assignment of a non-singular value to an iterator that holds a singular value, and, for iterators that satisfy the <code>DefaultConstructible</code> requirements, using a value-initialized iterator as the source of a copy or move operation. <em>[..]</em></p>\n</blockquote>\n<p>Note that this means you also can't compare a default-constructed iterator to any <code>.end()</code>.</p>\n<p>Contrary to popular belief that \"pointers are just memory addresses\", these rules are also largely true for pointers. Indeed, the rules for iterators are a generalisation of the rules for pointers.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "43501589", "Score": "5", "CreationDate": "2017-04-19T16:47:00.173", "LastActivityDate": "2017-04-19T16:47:00.173"}});