post_cb({"bq_ids": {"n4140": {"so_28344878_28345846_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 180}, "so_28344878_28345846_4": {"length": 15, "quality": 0.9375, "section_id": 183}, "so_28344878_28345846_6": {"length": 33, "quality": 0.9428571428571428, "section_id": 182}, "so_28344878_28345846_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 179}}, "n3337": {"so_28344878_28345846_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 174}, "so_28344878_28345846_4": {"length": 15, "quality": 0.9375, "section_id": 177}, "so_28344878_28345846_6": {"length": 33, "quality": 0.9428571428571428, "section_id": 176}, "so_28344878_28345846_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 173}}, "n4659": {"so_28344878_28345846_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 185}, "so_28344878_28345846_4": {"length": 15, "quality": 0.9375, "section_id": 188}, "so_28344878_28345846_6": {"length": 33, "quality": 0.9428571428571428, "section_id": 187}, "so_28344878_28345846_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 184}}}, "28345846": {"Id": "28345846", "PostTypeId": "2", "Body": "<p>The standard describes all scenarios in [temp.local]:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_28344878_28345846_0\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-class-name can be used as\n  a <em>template-name</em> or a <em>type-name</em>. When it is used with a\n  <em>template-argument-list</em>, as a <em>template-argument</em> for a <em>template template-parameter</em>, or as the final identifier in the\n  <em>elaborated-type-specifier</em> of a friend class template declaration, it refers to the class template itself. <strong>Otherwise, it is equivalent to\n  the <em>template-name</em> followed by the template-parameters of the class\n  template enclosed in <code>&lt;&gt;</code>.</strong></p></li>\n<li><p id=\"so_28344878_28345846_1\">Within the scope of a class template specialization or partial specialization, when the injected-class-name is used as a <em>type-name</em>,\n  it is equivalent to the template-name followed by the\n  template-arguments of the classtemplate specialization or partial\n  specialization enclosed in <code>&lt;&gt;</code>. </p></li>\n</ol>\n<p id=\"so_28344878_28345846_2\">[ <em>Example:</em></p>\n<pre><code>template&lt;template&lt;class&gt; class T&gt; class A { };\ntemplate&lt;class T&gt; class Y;\ntemplate&lt;&gt; class Y&lt;int&gt; {\n  Y* p;                             // meaning Y&lt;int&gt;\n  Y&lt;char&gt;* q;                       // meaning Y&lt;char&gt;\n  A&lt;Y&gt;* a;                          // meaning A&lt;::Y&gt;\n  class B {\n    template&lt;class&gt; friend class Y; // meaning ::Y\n  };\n};\n</code></pre>\n<p id=\"so_28344878_28345846_3\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>This only works inside the class template (i.e. the scope of the injected-class-name), and only if the name is accessed from a corresponding scope:</p>\n<blockquote>\n<p id=\"so_28344878_28345846_4\">When the normal name of the template (i.e., the name from the\n  enclosing scope, not the injected-class-name) is used, it always\n  refers to the class template itself and not a specialization of the\n  template. [ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; class X {\n  X* p;             // meaning X&lt;T&gt;\n  X&lt;T&gt;* p2;\n  X&lt;int&gt;* p3;\n  ::X* p4;         // error: missing template argument list\n                   // ::X does not refer to the injected-class-name\n};\n</code></pre>\n<p id=\"so_28344878_28345846_5\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>And for base classes, where the base is not dependent:</p>\n<blockquote>\n<p id=\"so_28344878_28345846_6\">A lookup that finds an injected-class-name (10.2) can result in an\n  ambiguity in certain cases (for example, if it is found in more than\n  one base class). If all of the injected-class-names that are found\n  refer to specializations of the same class template, and if the name\n  is used as a <em>template-name</em>, the reference refers to the class\n  template itself and not a specialization thereof, and is not\n  ambiguous.  [ <em>Example:</em></p>\n<pre><code>template &lt;class T&gt; struct Base { };\ntemplate &lt;class T&gt; struct Derived: Base&lt;int&gt;, Base&lt;char&gt; {\n  typename Derived::Base b;             // error: ambiguous\n  typename Derived::Base&lt;double&gt; d;     // OK\n};\n</code></pre>\n<p id=\"so_28344878_28345846_7\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>We can modify the example slightly to show what would be valid:</p>\n<pre><code>template &lt;class T&gt; struct Base { };\ntemplate &lt;class T&gt; struct Derived: Base&lt;char&gt; {\n  typename Derived::Base b;             // Ok: b refers to Base&lt;char&gt;\n};\n</code></pre>\n", "LastActivityDate": "2015-02-05T13:58:23.073", "CommentCount": "0", "CreationDate": "2015-02-05T13:58:23.073", "ParentId": "28344878", "Score": "0", "OwnerUserId": "3647361"}, "28344878": {"ViewCount": "132", "Body": "<p>Considering Template Class\nwhen do we have to refer explicitly to template, and when the compiler \"understands that we meant it\"</p>\n<p>considering the following occurences:</p>\n<p>1) function return value &amp; arguements</p>\n<p>2) variable declaration inside function</p>\n<p>3) namespace <code>SomeClass&lt;T&gt;::</code> vs. <code>SomeClass::</code></p>\n<p>Is there any rule? I saw sometimes the use is of:</p>\n<pre><code>SomeClass\n</code></pre>\n<p>and sometimes: <code>SomeClass&lt;T&gt;</code></p>\n<p>and I didn't get the rule</p>\n", "AcceptedAnswerId": "28345099", "Title": "refering to Templates c++", "CreationDate": "2015-02-05T13:12:06.583", "Id": "28344878", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-05T13:58:23.073", "Score": "5", "OwnerUserId": "324922", "Tags": "<c++><templates>", "AnswerCount": "2"}, "28345099": {"Id": "28345099", "PostTypeId": "2", "Body": "<p>Class template parameters may <em>only</em> be omitted inside the implementation of that class, where they implicitly add the appropriate template specifiers to the class and when referring to a non-dependent base class (non-dependent as in \"does not reuse any template arguments\"). For example:</p>\n<pre><code>template&lt;typename T, typename U&gt;\nclass C { /* here C is the same as C&lt;T, U&gt; */ };\n\ntemplate&lt;typename T&gt;\nclass C&lt;void, T&gt; { /* here C is the same as C&lt;void, T&gt; */ };\n\ntemplate&lt;&gt;\nclass C&lt;void, void&gt; { /* here C is the same as C&lt;void, void&gt; */ };\n\ntemplate&lt;typename&gt; struct Base { };\n\nstruct DerivedA : Base&lt;void&gt;\n{ /* here Base is the same as Base&lt;void&gt; */ };\n\ntemplate&lt;typename T&gt;\nstruct DerivedB : Base&lt;T&gt;\n{ /* here Base is invalid, since Base&lt;T&gt; depends on a template argument */ };\n</code></pre>\n<p>Function templates may have their template parameters omitted, if they can be deduced from their arguments:</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T f);\n\nf(3); // equivalent to f&lt;int&gt;(3) if no other overload exists\n</code></pre>\n<p>Additionally, there are default template arguments, which leads to <a href=\"https://ideone.com/gK11Gq\" rel=\"nofollow\">something really funky</a>:</p>\n<pre><code>template&lt;typename T = void&gt;\nclass D\n{\n    // Here D is D&lt;T&gt;, but D&lt;&gt; is D&lt;void&gt; instead!\n};\n</code></pre>\n", "LastEditorUserId": "65678", "LastActivityDate": "2015-02-05T13:38:13.500", "Score": "3", "CreationDate": "2015-02-05T13:23:31.750", "ParentId": "28344878", "CommentCount": "0", "OwnerUserId": "65678", "LastEditDate": "2015-02-05T13:38:13.500"}});