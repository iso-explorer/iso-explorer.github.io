post_cb({"28917356": {"ParentId": "28916895", "CommentCount": "12", "CreationDate": "2015-03-07T16:50:55.667", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "28917356", "Score": "-1", "Body": "<p>N4140:</p>\n<blockquote>\n<p id=\"so_28916895_28917356_0\"><strong>5.19 Constant expressions [expr.const]</strong></p>\n<p id=\"so_28916895_28917356_1\">2 A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless the evaluation of <code>e</code>, following the rules of the abstract machine (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_28916895_28917356_2\">...</p>\n<p id=\"so_28916895_28917356_3\">(2.9) -- an <em>id-expression</em> that refers to a variable or data member of reference type unless the reference has a preceding initialization and either [...]</p>\n</blockquote>\n<p>Your function is valid, and can potentially give a constant result. However, the function <em>call</em> <code>size(buff)</code> involves the expression <code>buff</code>, which refers to a variable of reference type with no preceding initialization.</p>\n<p>It's exactly what you were worried about, the function argument must be a valid constant expression even if it is unused.</p>\n", "LastActivityDate": "2015-03-07T16:50:55.667"}, "28916895": {"CommentCount": "5", "AcceptedAnswerId": "28917356", "CreationDate": "2015-03-07T16:08:54.993", "LastActivityDate": "2015-03-07T16:50:55.667", "PostTypeId": "1", "ViewCount": "235", "FavoriteCount": "1", "Title": "Use constexpr non-member size function in static_assert", "Id": "28916895", "Score": "0", "Body": "<p>Here is a simplified version of a situation that I encountered</p>\n<pre><code>#include &lt;array&gt;\n\ntemplate &lt;typename T, size_t BufferSize&gt;\nconstexpr \nsize_t size(const std::array&lt;T, BufferSize&gt;&amp;) { return BufferSize; }\ntemplate &lt;typename T, size_t BufferSize&gt;\nconstexpr size_t size(const T (&amp;)[BufferSize]) { return BufferSize; }\n\ntemplate &lt;typename Num, typename Buff&gt;\ninline Num func(const Num&amp; num, Buff&amp; buff)\n{\n    enum \n    { \n        min_size = 6, // Just for test\n    };\n    static_assert(size(buff) &gt;= min_size, \"\");\n    return num;\n}\n\nint main()\n{\n    //std::array&lt;char, 8&gt; buff;\n    char buff[8];\n    return func(7U, buff);   \n}\n</code></pre>\n<p>This code compiles fine with g++ 4.9.2, but clang++ 3.6 produces the following error, for both array types: </p>\n<pre><code>error: static_assert expression is not an integral constant expression\n    static_assert(size(buff) &gt;= min_size, \"\");\n                  ~~~~~^~~~~~~~~~~~~~~~~\n</code></pre>\n<p>I can assume that clang is right because the input parameter of the size function is not constexpr. On the other hand, the parameter itself is not really used.</p>\n<p>So, my question is which of the compilers is right according to the standard?</p>\n", "Tags": "<c++><g++><clang++>", "OwnerUserId": "4644485", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28916895_28917356_3": {"section_id": 6185, "quality": 1.0, "length": 11}, "so_28916895_28917356_1": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_28916895_28917356_3": {"section_id": 5946, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_28916895_28917356_3": {"section_id": 7687, "quality": 1.0, "length": 11}, "so_28916895_28917356_1": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}}}});