post_cb({"19841594": {"ParentId": "19840937", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>MSVC is right while GCC is wrong:</p>\n<p>Standard(3.9/5): </p>\n<blockquote>\n<p id=\"so_19840937_19841594_0\">Incompletely-defined object types and the void types are incomplete types</p>\n</blockquote>\n<p>Standard(20.7.1.1.2/4): </p>\n<blockquote>\n<p id=\"so_19840937_19841594_1\">If T is an incomplete type, the program is ill-formed</p>\n</blockquote>\n", "OwnerUserId": "643393", "LastEditorUserId": "1013719", "LastEditDate": "2016-10-27T22:59:58.413", "Id": "19841594", "Score": "18", "CreationDate": "2013-11-07T16:40:35.730", "LastActivityDate": "2016-10-27T22:59:58.413"}, "36255515": {"ParentId": "19840937", "CommentCount": "0", "Body": "<p>Don't delete variables of <code>void *</code>\u3002</p>\n<p>If you want to work with something like Win32 Handles, please provide a custom deleter.</p>\n<p>For example:</p>\n<pre><code>void HandleDeleter(HANDLE h)\n{\n    if (h) CloseHandle(h);\n}\n\nusing UniHandle = unique_ptr&lt;void, function&lt;void(HANDLE)&gt;&gt;;\n</code></pre>\n<p>Then:</p>\n<pre><code>UniHandle ptr(..., HandleDeleter);\n</code></pre>\n", "OwnerUserId": "5798427", "PostTypeId": "2", "Id": "36255515", "Score": "3", "CreationDate": "2016-03-28T03:27:37.093", "LastActivityDate": "2016-03-28T03:27:37.093"}, "19841374": {"ParentId": "19840937", "CommentCount": "3", "Body": "<p>The question boils down to:</p>\n<pre><code>void* p = new int;\ndelete p;\n</code></pre>\n<p>Looking at n3797 5.3.5 Delete, I believe the <code>delete p</code> is undefined behavior because of mismatched types, so either compiler behavior is acceptable as the code is buggy.</p>\n<p>Note:  this differs from <code>shared_ptr&lt;void&gt;</code>, as that uses type erasure to keep track of the original type of pointer passed in.</p>\n", "OwnerUserId": "1082038", "PostTypeId": "2", "Id": "19841374", "Score": "5", "CreationDate": "2013-11-07T16:31:54.773", "LastActivityDate": "2013-11-07T16:31:54.773"}, "19840937": {"CommentCount": "2", "AcceptedAnswerId": "19841594", "CreationDate": "2013-11-07T16:12:56.943", "LastActivityDate": "2016-10-27T22:59:58.413", "PostTypeId": "1", "ViewCount": "6776", "FavoriteCount": "1", "Title": "Should std::unique_ptr<void> be permitted", "Id": "19840937", "Score": "22", "Body": "<p>This is a very simple question.  Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\ntypedef std::unique_ptr&lt;void&gt; UniqueVoidPtr;\n\nint main() {\n    UniqueVoidPtr p(new int);\n    return 0;\n}\n</code></pre>\n<p>Compiling with cygwin (g++ 4.5.3) with the following command <code>g++ -std=c++0x -o prog file.cpp</code> works just fine.  However, compiling with the microsoft compiler (either VS 2010 or 2013) I get this error:</p>\n<pre><code>C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\INCLUDE\\memory(2067) : error C2070: 'void': illegal sizeof operand\n        C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\INCLUDE\\memory(2066) : while compiling class template member function 'void std::default_delete&lt;_Ty&gt;::operator ()(_Ty *) const'\n        with\n        [\n            _Ty=void\n        ]\n        C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\INCLUDE\\type_traits(650) : see reference to class template instantiation 'std::default_delete&lt;_Ty&gt;' being compiled\n        with\n        [\n            _Ty=void\n        ]\n        C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\VC\\INCLUDE\\memory(2193) : see reference to class template instantiation 'std::tr1::is_empty&lt;_Ty&gt;' being compiled\n        with\n        [\n            _Ty=std::default_delete&lt;void&gt;\n        ]\n        foo1.cpp(7) : see reference to class template instantiation 'std::unique_ptr&lt;_Ty&gt;' being compiled\n        with\n        [\n            _Ty=void\n        ]\n</code></pre>\n<p>Is this expected?  I'm writing a class where I wanted to have a unique pointer in the in the class.  While trying to work out the semantics of a move constructor for the class, I ran into this (I assume because I finally got my move constructor coded correctly: i.e. the other errors were fixed).</p>\n", "Tags": "<c++><visual-studio-2010><gcc><c++11><unique-ptr>", "OwnerUserId": "988207", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_19840937_19841594_0": {"section_id": 7203, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_19840937_19841594_0": {"section_id": 6947, "quality": 1.0, "length": 7}}, "n4659": {"so_19840937_19841594_0": {"section_id": 823, "quality": 0.5714285714285714, "length": 4}}}, "19863509": {"ParentId": "19840937", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>GCC actually has code to prevent it, but it didn't work until recently.</p>\n<p>GCC's <code>unique_ptr</code> has a static assertion in <code>default_deleter::operator()</code> that should reject incomplete types:</p>\n<pre><code>    static_assert(sizeof(_Tp)&gt;0,\n                  \"can't delete pointer to incomplete type\");\n</code></pre>\n<p>However, as an extension GCC supports <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Pointer-Arith.html#Pointer-Arith\"><code>sizeof(void)</code></a>, so the assertion doesn't fail, and because it appears in a system header doesn't even give a warning (unless you use <code>-Wsystem-headers</code>).</p>\n<p>I discovered this problem myself recently so to fix it I added this <a href=\"http://gcc.gnu.org/ml/libstdc++/2013-10/msg00238.html\">10 days ago</a>:</p>\n<pre><code>    static_assert(!is_void&lt;_Tp&gt;::value,\n                  \"can't delete pointer to incomplete type\");\n</code></pre>\n<p>So using the latest code on trunk your example fails to compile, as required by the standard.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2016-01-30T11:50:40.633", "Id": "19863509", "Score": "20", "CreationDate": "2013-11-08T16:07:38.900", "LastActivityDate": "2016-01-30T11:50:40.633"}});