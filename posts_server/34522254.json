post_cb({"34522287": {"ParentId": "34522254", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Speculating about original rationales is mostly futile in such a case, but with this design <a href=\"http://en.cppreference.com/w/cpp/algorithm/copy_n\" rel=\"nofollow\"><code>copy_n</code></a> can be invoked with a negative count of e.g. <code>int</code> or <code>ptrdiff_t</code> type, in which case it simply does nothing, and that must surely have been clear to the standardization committee's members, who are pretty competent folks.</p>\n<hr>\n<p>One additional advantage is that with special iterators, such as input and output iterators, the size might be larger than any possible pointer difference, and hence possibly larger than <code>size_t</code> can represent. E.g. this is so for files larger than 4GB in 32-bit Windows. The definition of <code>copy_n</code> is expressed in terms of apparent pointer/iterator arithmetic, \u201cFor each non-negative integer <code>i &lt; n</code>, performs <code>*(result + i) = *(first + i)</code>\u201d, which would seem to relegate this advantage to very special cases indeed, but the notation accommodates pure input and output iterators as explained in</p>\n\nC++11 \u00a725.1/12:\n\n<blockquote>\n<p id=\"so_34522254_34522287_0\"><strong>\u201d</strong> In the description of the algorithms operators <code>+</code> and <code>-</code> are used for some of the iterator categories for which\n  they do not have to be defined. In these cases the semantics of <code>a+n</code> is the same as that of  </p>\n<pre><code>X tmp = a;\nadvance(tmp, n);\nreturn tmp;\n</code></pre>\n<p id=\"so_34522254_34522287_1\">and that of <code>b-a</code> is the same as of <code>return distance(a, b)</code>;</p>\n</blockquote>\n<hr>\n<p>The genericity of the design has no inherent advantage, rather it's a disadvantage in itself in that it's more verbose and generates less easily understood diagnostics for incorrect usage code. Its advantages include the two ones listed above. Evidently the committee felt that these advantages, and perhaps others (?), outweighed the inherent disadvantages of having <code>Size</code> as a template parameter.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2015-12-30T04:42:37.993", "Id": "34522287", "Score": "6", "CreationDate": "2015-12-30T02:53:27.303", "LastActivityDate": "2015-12-30T04:42:37.993"}, "34522317": {"ParentId": "34522254", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I would guess it is because of <strong>genericity</strong>.<br>\nContainers <code>size_type</code> in C++ are usually <code>size_t</code>. But if you use a custom container, or use custom allocators, that might not be the case hence the template parameter. </br></p>\n<p>For a <a href=\"http://en.cppreference.com/w/cpp/concept/Container\" rel=\"nofollow\">custom container</a>, <code>size_type</code> does not have to be a typedef  to <code>size_t</code> (it has to be <code>an unsigned integer large enough to represent all positive values of difference_type</code>). </p>\n<p>For STL containers, <code>size_type</code> is a typedef to <code>allocator::size_type</code> which is <code>size_t</code> for the <a href=\"http://en.cppreference.com/w/cpp/memory/allocator\" rel=\"nofollow\">default allocator</a>. But the type can be different if you specify a custom allocator. </p>\n", "OwnerUserId": "2352158", "LastEditorUserId": "2352158", "LastEditDate": "2015-12-30T03:05:05.730", "Id": "34522317", "Score": "3", "CreationDate": "2015-12-30T02:58:23.880", "LastActivityDate": "2015-12-30T03:05:05.730"}, "bq_ids": {"n4140": {"so_34522254_34522287_0": {"section_id": 1245, "quality": 1.0, "length": 12}}, "n3337": {"so_34522254_34522287_0": {"section_id": 1243, "quality": 1.0, "length": 12}}, "n4659": {"so_34522254_34522287_0": {"section_id": 1333, "quality": 1.0, "length": 12}}}, "34522254": {"CommentCount": "2", "ViewCount": "268", "CreationDate": "2015-12-30T02:48:48.680", "LastActivityDate": "2015-12-30T07:39:23.103", "Title": "Why does std::copy_n take a template parameter instead of std::size_t?", "AcceptedAnswerId": "34522287", "PostTypeId": "1", "Id": "34522254", "Score": "6", "Body": "<p>So simple question.</p>\n<pre><code>template&lt;class InputIt, class Size, class OutputIt&gt;\nOutputIt copy_n(InputIt first, Size count, OutputIt result);\n</code></pre>\n<p>Why does <code>std::copy_n</code> take a type for the number of elements it's going to copy instead of simply <code>std::size_t</code>? I just can't think of a reason. </p>\n<pre><code>template&lt;class InputIt, class OutputIt&gt;\nOutputIt copy_n(InputIt first, std::size_t count, OutputIt result);\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "5212827", "AnswerCount": "2"}});