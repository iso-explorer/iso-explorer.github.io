post_cb({"17699858": {"CommentCount": "6", "AcceptedAnswerId": "17700214", "PostTypeId": "1", "LastEditorUserId": "414271", "CreationDate": "2013-07-17T12:32:34.823", "LastActivityDate": "2013-07-17T20:15:28.187", "LastEditDate": "2013-07-17T13:03:11.467", "ViewCount": "473", "FavoriteCount": "3", "Title": "g++ Bug with Partial Template Specialization", "Id": "17699858", "Score": "13", "Body": "<p>I am writing some TMP-heavy code for g++ (version 4.8.1_1, Macports) and clang++ (version 3.3, Macports). While g++ rejects the following code listing with <strong>UNBRIDLED FURY</strong>, clang++ compiles it with <em>grace</em> and <em>splendor</em>.</p>\n<ul>\n<li>Which complier is in the right? (I strongly suspect it's g++, but I want to get some reassurance from others before submitting a bug report.)</li>\n<li>Do you have any easy or elegant workarounds to suggest? (I need to use template aliases, so switching over to structs, which causes g++ to accept the code, is not an option.)</li>\n</ul>\n<p>Here is the code listing, made <em>just for you</em>.</p>\n<pre><code>template &lt;class... Ts&gt;\nstruct sequence;\n\ntemplate &lt;int T&gt;\nstruct integer;\n\n// This definition of `extents` causes g++ to issue a compile-time error.\ntemplate &lt;int... Ts&gt;\nusing extents = sequence&lt;integer&lt;Ts&gt;...&gt;;\n\n// However, this definition works without any problems.\n// template &lt;int... Ts&gt;\n// struct extents;\n\ntemplate &lt;int A, int B, class Current&gt;\nstruct foo;\n\ntemplate &lt;int A, int B, int... Ts&gt;\nstruct foo&lt;A, B, extents&lt;Ts...&gt;&gt;\n{\n    using type = int;\n};\n\ntemplate &lt;int B, int... Ts&gt;\nstruct foo&lt;B, B, extents&lt;Ts...&gt;&gt;\n{\n    using type = int;\n};\n\nint main()\n{\n    using t = foo&lt;1, 1, extents&lt;&gt;&gt;::type;\n    return 0;\n}\n</code></pre>\n<p>Here is g++'s output:</p>\n<pre><code>er.cpp: In function 'int main()':\ner.cpp:39:41: error: ambiguous class template instantiation for 'struct foo&lt;1, 1, sequence&lt;&gt; &gt;'\n  using t = typename foo&lt;1, 1, extents&lt;&gt;&gt;::type;\n                                         ^\ner.cpp:26:8: error: candidates are: struct foo&lt;A, B, sequence&lt;integer&lt;Ts&gt;...&gt; &gt;\n struct foo&lt;A, B, extents&lt;Ts...&gt;&gt;\n        ^\ner.cpp:32:8: error:                 struct foo&lt;B, B, sequence&lt;integer&lt;Ts&gt;...&gt; &gt;\n struct foo&lt;B, B, extents&lt;Ts...&gt;&gt;\n        ^\ner.cpp:39:43: error: 'type' in 'struct foo&lt;1, 1, sequence&lt;&gt; &gt;' does not name a type\n  using t = typename foo&lt;1, 1, extents&lt;&gt;&gt;::type;\n                                           ^\n</code></pre>\n<p>Here is clang++'s output:</p>\n<p>Thanks for your help!</p>\n", "Tags": "<c++><templates><c++11><template-specialization><template-aliases>", "OwnerUserId": "414271", "AnswerCount": "3"}, "17708667": {"ParentId": "17699858", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>I believe g++ might be correct. The line</p>\n<pre><code>using t = foo&lt;1, 1, extents&lt;&gt;&gt;::type\n</code></pre>\n<p>is using the template parameters in a non-deduced context, so it can't use the actual values given for the template parameters to resolve the ambiguity, only their types and that isn't sufficient.</p>\n<p>Section 14.8.2.5, para 4 of the C++ standard says:</p>\n<blockquote>\n<p id=\"so_17699858_17708667_0\">In most cases, the types, templates, and non-type values that are used to compose P participate in template argument deduction. That is, they may be used to determine the value of a template argument, and the value so determined must be consistent with the values determined elsewhere. In certain contexts, however, the value does not participate in type deduction, but instead uses the values of template arguments that\n  were either deduced elsewhere or explicitly specified. If a template parameter is used only in non-deduced contexts and is not explicitly specified, template argument deduction fails.</p>\n<p id=\"so_17699858_17708667_1\">The non-deduced contexts are:</p>\n<p id=\"so_17699858_17708667_2\">x The nested-name-specifier of a type that was specified using a qualified-id</p>\n<p id=\"so_17699858_17708667_3\">...</p>\n</blockquote>\n<p>Section 14.8.2.4 para 11 says:</p>\n<blockquote>\n<p id=\"so_17699858_17708667_4\">In most cases, all template parameters must have values in order for deduction to succeed, but for partial ordering purposes a template parameter may remain without a value provided it is not used in the types being used for partial ordering. [ Note: A template parameter used in a non-deduced context is considered used. \u2014end note ]</p>\n</blockquote>\n<p>So we're in a non-deduced context, which means that all template arguments must have values. So if extents&lt;&gt; fails to nail down the type, then the result will be ambiguous according to the standard. Plausible?</p>\n", "OwnerUserId": "810050", "LastEditorUserId": "810050", "LastEditDate": "2013-07-17T20:15:28.187", "Id": "17708667", "Score": "0", "CreationDate": "2013-07-17T19:32:57.450", "LastActivityDate": "2013-07-17T20:15:28.187"}, "17700460": {"ParentId": "17699858", "CommentCount": "0", "Body": "<p>The question boils down if I understood it correctly to determining whether one of the following template specializations is more specialized than the other:</p>\n<pre><code>template &lt;int A, int B, class Current&gt;\nstruct foo;\n\ntemplate &lt;int A, int B, int... Ts&gt;\nstruct foo&lt;A, B, extents&lt;Ts...&gt;&gt;\n{\n    using type = int;\n};\n\ntemplate &lt;int B, int... Ts&gt;\nstruct foo&lt;B, B, extents&lt;Ts...&gt;&gt;\n{\n    using type = int;\n};\n</code></pre>\n<p>And the answer is <em>yes</em>, for any combination of parameters that are allowed in the second specialization the same combination is allowed in the first by making the template arguments <code>A == B</code>. On the other direction, any instantiation of the first template specialization on which <code>A != B</code> cannot be a match for the second specialization, so the second is strictly <em>more specialized</em> than the first.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "17700460", "Score": "3", "CreationDate": "2013-07-17T12:59:41.703", "LastActivityDate": "2013-07-17T12:59:41.703"}, "bq_ids": {"n4140": {"so_17699858_17708667_4": {"section_id": 330, "quality": 0.90625, "length": 29}, "so_17699858_17708667_0": {"section_id": 335, "quality": 0.9818181818181818, "length": 54}, "so_17699858_17708667_2": {"section_id": 336, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_17699858_17708667_4": {"section_id": 320, "quality": 0.90625, "length": 29}, "so_17699858_17708667_0": {"section_id": 325, "quality": 0.9818181818181818, "length": 54}, "so_17699858_17708667_2": {"section_id": 326, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_17699858_17708667_4": {"section_id": 339, "quality": 0.90625, "length": 29}, "so_17699858_17708667_0": {"section_id": 344, "quality": 0.9818181818181818, "length": 54}, "so_17699858_17708667_2": {"section_id": 345, "quality": 0.8571428571428571, "length": 6}}}, "17700214": {"ParentId": "17699858", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This seems like a g++ bug because clearly <code>foo&lt;B, B, extents&gt;</code> is more specialized than <code>foo&lt;A, B, extents&gt;</code> (te latter can match anything that the former matches, but not vice versa), so the compiler should choose that specialization.</p>\n<p>As you noted yourself, changing <code>extents</code> from a template alias to a class template, solves the problem.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2013-07-17T13:06:34.820", "Id": "17700214", "Score": "7", "CreationDate": "2013-07-17T12:49:15.910", "LastActivityDate": "2013-07-17T13:06:34.820"}});