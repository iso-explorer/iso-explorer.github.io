post_cb({"16589011": {"ParentId": "14524278", "CommentCount": "0", "Body": "<p>I can't cite a reference or authoritative source, but it looks to me like g++ and VS are both correct here (for the first time ever they agree?) because it simply doesn't make logical sense that an empty intermediate injected class could change the access control of a parent's protected data.</p>\n<p>As for the rationale, it's almost certainly because the less restrictive you make <code>protected</code> the more like <code>public</code> it becomes (it already has a lot of similarities to public in that you just have to derive a class to gain unrestricted access to the parent innards). If you start allowing child classes that aren't even your same instance to manipulate your state, the chances of violating class invariants increases significantly.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "16589011", "Score": "0", "CreationDate": "2013-05-16T13:38:00.317", "LastActivityDate": "2013-05-16T13:38:00.317"}, "14524693": {"ParentId": "14524278", "CommentCount": "0", "Body": "<p>I would say that GCC and Visual Studio are correct.</p>\n<p>Given the following situation:</p>\n<pre><code>class Base\n{\nprotected:\n  int A;\n};\n\nclass Derived : public Base\n{\nprotected:\n  int B;\n};\n\nclass OtherGrandchild : Derived\n{\n};\n\nclass Grandchild : Derived\n{\n  void access_protected(OtherGrandchild* otherGrandchild);\n};\n\nvoid Grandchild::access_protected(OtherGrandchild* otherGrandchild)\n{\n  otherGrandchild-&gt;A = 1; // Should be illegal\n  otherGrandchild-&gt;B = 1; // Should be illegal\n\n  Derived* derived = static_cast&lt;Derived*&gt;(otherGrandchild);\n\n  derived-&gt;A = 1; // Should still be illegal\n  derived-&gt;B = 1; // Should still be illegal\n}\n</code></pre>\n<p>If you were not restricted you could alter the otherwise private members of <code>OtherGrandchild</code> from <code>Grandchild</code> just by casting to a common base type. That sort of access should only be allowable through friend declarations.</p>\n<p>I'm not sure of any discussions on the topic but that would be my interpretation of it.</p>\n", "OwnerUserId": "1985643", "PostTypeId": "2", "Id": "14524693", "Score": "0", "CreationDate": "2013-01-25T15:13:38.587", "LastActivityDate": "2013-01-25T15:13:38.587"}, "14524278": {"CommentCount": "4", "ViewCount": "1406", "PostTypeId": "1", "LastEditorUserId": "358475", "CreationDate": "2013-01-25T14:53:12.733", "LastActivityDate": "2013-05-16T13:38:00.317", "Title": "Getting to the bottom of C++ protected", "LastEditDate": "2013-01-25T22:01:23.433", "Id": "14524278", "Score": "1", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">2011 C++ Standard states</a> in section 11.4 that</p>\n<blockquote>\n<p id=\"so_14524278_14524278_0\">An additional access check beyond those described earlier in Clause 11\n  is applied when a non-static data member or non-static member function\n  is a protected member of its naming class (\n  11.2 ) 115 As described earlier, access to a protected member is granted because the reference occurs in a friend or member of some\n  class C . If the access is to form a pointer to member (\n  5.3.1 ), the nested-name-specifier shall denote C or a class derived from C . All other accesses involve a (possibly implicit) object\n  expression (\n  5.2.5 ). In this case, the class of the object expression shall be C or a class derived from C .</p>\n</blockquote>\n<p>(In the old standard, similar wording was in section 11.5.)</p>\n<p>This rule restricts the oft-repeated idea that \"protected members of B can be accessed by any B or derived class of B.\" Interpreting the rule, however, is difficult, as evidenced by the fact that different current compilers enforce the rule differently.</p>\n<p>See, for example, this test code. I compiled this code using Apple LLVM Compiler 4.1, GCC 4.7.2, and Visual Studio 2010. There are similarities as well as differences in the errors they report.</p>\n<pre><code>class Base\n{\nprotected:\n    int A;\n};\n\nclass Derived : public Base\n{\nprotected:\n    int B;\n};\n\nclass Grandchild : public Derived\n{\n    void access_protected(Base* b, Derived* d,\n                          Grandchild* g, class GreatGrandchild* gg );\n};\n\nclass GreatGrandchild : public Grandchild {};\n\nvoid Grandchild::access_protected(Base* b, Derived* d,\n                                  Grandchild* g, GreatGrandchild* gg )\n{\n    int* p;\n\n    Base lb;\n    Derived ld;\n    Grandchild lg;\n    GreatGrandchild lgg;\n\n    A = 1;              // Legal...\n    B = 2;\n\n    Base::A = 1;\n    Derived::B = 2;\n\n    b-&gt;A = 1;           // Illegal ALL\n    p = &amp;(b-&gt;A);        // Illegal ALL\n    lb.A = 1;           // Illegal ALL\n    p = &amp;(lb.A);        // Illegal ALL\n\n    d-&gt;A = 1;           // Illegal GCC, VS\n    p = &amp;(d-&gt;A);        // Illegal GCC, VS\n    ld.A = 1;           // Illegal GCC, VS\n    p = &amp;(ld.A);        // Illegal GCC, VS\n    d-&gt;B = 2;           // Illegal ALL\n    p = &amp;(d-&gt;B);        // Illegal ALL\n    ld.B = 2;           // Illegal ALL\n    p = &amp;(ld.B);        // Illegal ALL\n\n    g-&gt;A = 1;           // Legal...\n    g-&gt;B = 2;\n    lg.A = 1;\n    lg.B = 2;\n\n    gg-&gt;A = 1;\n    gg-&gt;B = 2;\n    lgg.A = 1;\n    lgg.B = 2;\n}\n</code></pre>\n<p>From these results I glean that: (1) it's always okay to access protected members of your own class and your derived classes; (2) it's always illegal to access protected members of the base class in which they were declared, except from that class; (3) although the standard takes care to distinguish between pointers to members and \"object expressions\", both the standard and the compilers give them the same restrictions; (4) it's unclear whether it's legal to access a protected member of an \"intermediate\" base class (<code>Derived</code> in the example) for which the member was declared in the intermediate's base.</p>\n<p>The confusion, then, is whether it's okay for me to talk about my grandparent's protected member as owned by my parent. No double entendre intended.</p>\n<p>(I'm ignoring <code>friends</code> for simplicity and sanity's sake.)</p>\n<p>Since <code>protected</code> is such a fundamental part of the language, I am motivated to understand it well. Please:</p>\n<ol>\n<li>Based on your interpretation of the standard, which compiler implements this correctly?</li>\n<li>What is the rationale for the overall restriction? Why <em>can't</em> I access base classes' protected members freely? What concrete error is it designed to avoid? Do you know of an online discussion\u2014ideally as held by the standards committee\u2014that explores this rationale?</li>\n</ol>\n", "Tags": "<c++><protected>", "OwnerUserId": "358475", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_14524278_14524278_0": {"section_id": 6695, "quality": 0.9333333333333333, "length": 56}}, "n3337": {"so_14524278_14524278_0": {"section_id": 6450, "quality": 0.9333333333333333, "length": 56}}, "n4659": {"so_14524278_14524278_0": {"section_id": 8170, "quality": 0.9333333333333333, "length": 56}}}, "14524985": {"ParentId": "14524278", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The reason for this is that a derived object D can only access protected members of the base , using an object expression that is either D or another class Derived from D.</p>\n<p>The Standard does not allow D to access protected members of another object using an object expression of type B</p>\n<p>That's what exactly (OK roughly) what the above quote is trying to say.</p>\n<pre><code>class base\n{\nprotected:\n   int x;\n};\n\nclass derived : public base\n{\npublic:\n   void f(base *p)   \n   {\n      x = 2;     // good\n      p-&gt;x = 3;  // not good. base is not 'derived' nor derived from 'derived'\n   }\n};\n\nint main() { }\n</code></pre>\n<p>Think about it for a moment. Public member of base B are accessible in any derived class D. Private members of B are not accessible in any derived class D. It is only the protected members that require some consideration. And the above quote from the Standard spells out that consideration. Protected non static members of B can be accessed in a derived class D only using an object expression which is of type D or a type derived further from D</p>\n", "OwnerUserId": "418110", "LastEditorUserId": "418110", "LastEditDate": "2013-01-25T15:43:20.797", "Id": "14524985", "Score": "0", "CreationDate": "2013-01-25T15:36:22.993", "LastActivityDate": "2013-01-25T15:43:20.797"}});