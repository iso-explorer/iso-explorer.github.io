post_cb({"41546320": {"Id": "41546320", "PostTypeId": "2", "Body": "<p>In Linux, I have been successful printing out any unicode directly as in THE most naive way:</p>\n<pre><code>std::cout &lt;&lt; \"\u0390 , \u0391, \u0392, \u0393, \u0394, ,\u0398 , \u039b, \u039e, ... \u00b1, ... etc\"\n</code></pre>\n", "LastActivityDate": "2017-01-09T10:51:04.053", "CommentCount": "0", "CreationDate": "2017-01-09T10:51:04.053", "ParentId": "16944750", "Score": "0", "OwnerUserId": "4962474"}, "17129670": {"Id": "17129670", "PostTypeId": "2", "Body": "<p>The program prints an integer because of C++11 \u00a72.14.3/1:</p>\n<blockquote>\n<p id=\"so_16944750_17129670_0\">A multicharacter literal, or an ordinary character literal containing a single c-char not representable in the execution character set, is conditionally-supported, has type int, and has an implementation-defined value.</p>\n</blockquote>\n<p>The execution character set is what <code>char</code> can represent, i.e. ASCII.</p>\n<p>What you got is 14851712, or in hexadecimal e29e80, which is the UTF-8 representation of U+2780. Putting UTF-8, a multibyte encoding, into an <code>int</code> is insane and stupid, but that's what you get from a \"conditionally supported, implementation-defined\" feature.</p>\n<p>To get a UTF-32 value, use <code>U'\\u2780'</code>. The first <code>U</code> specifies the <code>char32_t</code> type and UTF-32 encoding (i.e. up to 31 bits but no surrogate pairs).  The second <code>\\u</code> specifies a universal-character-name containing the code point. To get a value supposedly compatible with <code>wcout</code>, use <code>L'\\u2780'</code>, but that doesn't necessarily use a Unicode runtime value nor get you more than two bytes of storage.</p>\n<p>As for reliably manipulating and printing the Unicode codepoint, as other answers have noted, the C++ standard hasn't quite gotten there yet. Joni's answer is the best way, yet it still assumes that the compiler and the user's environment are using the same locale, which often isn't true.</p>\n<p>You can also specify UTF-8 strings in the source using <code>u8\"\\u2780\"</code> and force the runtime environment to UTF-8 using something like <code>std::locale::global( std::locale( \"en_US.UTF-8\" ) );</code>. But that still has rough edges. Joni suggests using the C interface <code>std::setlocale</code> from <code>&lt;clocale&gt;</code> instead of the C++ interface <code>std::locale::global</code> from <code>&lt;locale&gt;</code>, which is a workaround to the C++ interface being broken in GCC on OS X and perhaps other platforms. The issues are platform-sensitive enough that your Linux distro might well have put a patch into their own GCC package.</p>\n", "LastActivityDate": "2013-06-16T02:35:15.927", "CommentCount": "3", "CreationDate": "2013-06-16T02:35:15.927", "ParentId": "16944750", "Score": "0", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_16944750_17129670_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5343}}, "n3337": {"so_16944750_17129670_0": {"length": 12, "quality": 0.7058823529411765, "section_id": 5140}}, "n4659": {"so_16944750_17129670_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6765}}}, "16944750": {"ViewCount": "10043", "Body": "<p>I need to print some unicode characters on the Linux terminal using <code>iostream</code>. Strange things happen though. When I write:</p>\n<pre><code>cout &lt;&lt; \"\\u2780\";\n</code></pre>\n<p>I get: <code>\u2780</code>, which is almost exactly what I want. However if I write:</p>\n<pre><code>cout &lt;&lt; '\\u2780';\n</code></pre>\n<p>I get: <code>14851712</code>.</p>\n<p>The problem is, I don't know the exact character to be printed at compile-time. Therefore I'd like to do something like:</p>\n<pre><code>int x;\n// some calculations...\ncout &lt;&lt; (char)('\\u2780' + x);\n</code></pre>\n<p>Which prints: <code>\ufffd</code>. Using <code>wcout</code> or <code>wchar_t</code> instead don't work either. How do I get correct printing?</p>\n<p>From what I found around on the Internet it seems important that I use g++ 4.7.2 compiler straight from Debian Wheezy repository.</p>\n", "Title": "C++ unicode characters printing", "CreationDate": "2013-06-05T16:07:36.263", "LastActivityDate": "2017-01-09T10:51:04.053", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "Id": "16944750", "Score": "6", "OwnerUserId": "2254489", "Tags": "<c++><unicode><cout>", "AnswerCount": "4"}, "16970900": {"Id": "16970900", "PostTypeId": "2", "Body": "<p>When you write</p>\n<pre><code>cout &lt;&lt; \"\\u2780\";\n</code></pre>\n<p>The compiler converts \\u2780 into the appropriate encoding of that character in the execution character set. That's probably UTF-8, and so the string ends up having four bytes (three for the character, one for the null terminator).</p>\n<p>If you want to generate the character at run time then you need some way to do at runtime the same conversion to UTF-8 that the compiler is doing at compile time.</p>\n<hr>\n<p>C++11 provides a handy <code>wstring_convert</code> template and codecvt facets that can do this, however libstdc++, the standard library implementation that comes with gcc, has not yet gotten around to implementing them (as of gcc 4.8). The following shows how to use these features, but you'll need to either use a different standard library implementation or wait for libstdc++ to implement them.</p>\n<pre><code>#include &lt;codecvt&gt;\n\nint main() {\n  char32_t base = U'\\u2780';\n\n  std::wstring_convert&lt;std::codecvt_utf8&lt;char32_t&gt;, char32_t&gt; convert;\n  std::cout &lt;&lt; convert.to_bytes(base + 5) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>You can also use any other method of producing UTF-8 you have available. For example, iconv, ICU, and manual use of pre-C++11 codecvt_byname facets would all work. (I don't show examples of these because that code would be more involved than the simple code permitted by <code>wstring_convert</code>.)</p>\n<hr>\n<p>An alternative that would work for a small number of characters would be to create an array of strings using literals.</p>\n<pre><code>char const *special_character[] = { \"\\u2780\", \"\\u2781\", \"\\u2782\",\n  \"\\u2783\", \"\\u2784\", \"\\u2785\", \"\\u2786\", \"\\u2787\", \"\\u2788\", \"\\u2789\" };\n\nstd::cout &lt;&lt; special_character[i] &lt;&lt; '\\n';\n</code></pre>\n</hr></hr>", "LastEditorUserId": "365496", "LastActivityDate": "2013-06-16T01:48:00.053", "Score": "4", "CreationDate": "2013-06-06T19:47:12.427", "ParentId": "16944750", "CommentCount": "0", "OwnerUserId": "365496", "LastEditDate": "2013-06-16T01:48:00.053"}, "16944903": {"Id": "16944903", "PostTypeId": "2", "Body": "<p>The Unicode character <code>\\u2780</code> is outside of the range for the <code>char</code> datatype. You should have received this compiler warning to tell you about it: (at least my g++ 4.7.3 gives it)</p>\n<pre><code>test.cpp:6:13: warning: multi-character character constant [-Wmultichar]\n</code></pre>\n<p>If you want to work with characters like U+2780 as single units you'll have to use the widechar datatype <code>wchar_t</code>, or if you are lucky enough to be able to work with C++11, <code>char32_t</code> or <code>char16_t</code>. Note that one 16-bit unit is not enough to represent the full range of Unicode characters.</p>\n<p>If that's not working for you, it's probably because the default \"C\" locale doesn't have support for non-ASCII output. To fix that problem you can call <code>setlocale</code> in the start of the program; that way you can output the full range of characters supported by the user's locale: (which may or may not have support for all of the characters you use)</p>\n<pre><code>#include &lt;clocale&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    setlocale(LC_ALL, \"\");\n    wcout &lt;&lt; L'\\u2780';\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "318758", "LastActivityDate": "2013-06-05T16:27:55.477", "Score": "6", "CreationDate": "2013-06-05T16:15:44.913", "ParentId": "16944750", "CommentCount": "12", "OwnerUserId": "318758", "LastEditDate": "2013-06-05T16:27:55.477"}});