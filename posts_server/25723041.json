post_cb({"25723283": {"ParentId": "25723041", "CommentCount": "0", "Body": "<p>In the first case, the compiler happens to save you by statically dispatching to <code>A::f()</code>, since it knows the static type of <code>A</code>. But it's quite right that this is horribly undefined behaviour and you shouldn't do it.</p>\n<p>In the second case, the compiler does not statically dispatch to <code>A::f()</code> since the call is not in the constructor so it must dynamically dispatch it. Different ABIs handle pure virtual calls differently, but both MSVC and Itanium have a dedicated pure virtual call handler which is placed in the vtable to catch these events. This is what produces the error message you see.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "25723283", "Score": "1", "CreationDate": "2014-09-08T11:31:29.553", "LastActivityDate": "2014-09-08T11:31:29.553"}, "25723284": {"ParentId": "25723041", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25723041_25723284_0\"><strong>\u00a7 10.4 Abstract classes [class.abstract] / p6</strong></p>\n<p id=\"so_25723041_25723284_1\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to <strong>a pure virtual</strong> function directly or <strong>indirectly</strong> for the object being created (or destroyed) <strong>from</strong> such a <strong>constructor</strong> (or destructor) <strong>is undefined</strong>.</p>\n</blockquote>\n<p>In brief: <em>The effect of making a call to a pure virtual function directly or indirectly for the object being created from constructor is undefined.</em></p>\n<p>A call to pure virtual member functions cannot be used from a constructor or a destructor, no matter if the call is direct or indirect, because then you end up with an <em>undefined behavior</em>.</p>\n<p>The only useful example of providing the implementation of a pure virtual function is when calling it from a derived class:</p>\n<pre><code>struct A\n{\n    virtual void f() = 0;\n};\n\nvoid A::f()\n{\n    cout&lt;&lt;\"A\"&lt;&lt;endl;\n}\n\nstruct B : A\n{\n    void f()\n    {\n        A::f();\n        cout&lt;&lt;\"B\"&lt;&lt;endl;\n    }\n};\n</code></pre>\n", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2015-06-28T15:52:28.690", "Id": "25723284", "Score": "1", "CreationDate": "2014-09-08T11:31:36.087", "LastActivityDate": "2015-06-28T15:52:28.690"}, "25723969": {"ParentId": "25723041", "CommentCount": "0", "Body": "<p><code>Undefined</code> behaviour means that the compiler does not have to handle the situation in any particularly defined manner.</p>\n<p>Here your compiler, that knew the actual type of A in its constructor was able to inline in the pure virtual method rather than call it through the v-table. This is what would happen if the method were normal virtual, not pure virtual, and this would be defined behaviour.</p>\n<p>Whilst it would be the behaviour too even via <code>g()</code>, the compiler did not do this for a pure virtual <code>f()</code> function. It doesn't have to.</p>\n<p>The simple moral is do not invoke undefined behaviour, and if you want to call <code>f()</code> from the constructor do not make it pure virtual.</p>\n<p>If you want to enforce your sub-classes to implement <code>f()</code>, do not call it from the constructor of A but give that function you want to call a different name. Preferably not virtual at all.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "25723969", "Score": "0", "CreationDate": "2014-09-08T12:10:58.673", "LastActivityDate": "2014-09-08T12:10:58.673"}, "25723041": {"CommentCount": "1", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "1221236", "CreationDate": "2014-09-08T11:17:27.900", "LastActivityDate": "2015-06-28T20:18:37.840", "Title": "Pure virtual function call interesting cases", "AcceptedAnswerId": "25723284", "LastEditDate": "2014-09-08T11:33:59.580", "Id": "25723041", "Score": "5", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\n  public:\n   virtual void f() = 0;\n   A(){f();}\n};\n\nvoid A::f() {\n    cout&lt;&lt;\"A\"&lt;&lt;endl;\n}\n\nclass B:public A{\n public:\n    void f(){cout&lt;&lt;\"B\"&lt;&lt;endl;}\n};\nint main()\n{\n B b;\n}\n</code></pre>\n<p>In this case I directly call the virtual function from constructor and get compiler warning which says:<br>\nwarning: abstract virtual 'virtual void A::f()' called from constructor.<br>\n But it executes without termination and prints A.</br></br></p>\n<p>If I wrap the call of the function like this:</p>\n<pre><code>class A\n{\n  public:\n   virtual void f() = 0;\n   A(){g();}\n   void g(){f();}\n};\n\nvoid A::f(){cout&lt;&lt;\"A\"&lt;&lt;endl;}\n\nclass B:public A{\n public:\n    void f(){cout&lt;&lt;\"B\"&lt;&lt;endl;}\n};\nint main()\n{\n B b;\n}\n</code></pre>\n<p>The compiler does not output any warning during compilation but it crushes at runtime with the following message:    </p>\n<pre><code>pure virtual method called   \nterminate called without active exception   \nAbort\n</code></pre>\n<p>Can anybody explain the behavior of both of this cases?  </p>\n", "Tags": "<c++><inheritance><compilation><virtual-functions><pure-virtual>", "OwnerUserId": "1856429", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_25723041_25723284_1": {"section_id": 7023, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_25723041_25723284_1": {"section_id": 6769, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_25723041_25723284_1": {"section_id": 8520, "quality": 0.9615384615384616, "length": 25}}}, "31104344": {"ParentId": "25723041", "CommentCount": "0", "Body": "<p>From a compiler's point of view, if you look at how the function f() is invoked:</p>\n<ul>\n<li>Case-1: A's ctor calls A-ctor =&gt; f() directly. Compiler knows precisely that this is the case and decides to issue a warning.</li>\n<li>Case-2: A's ctor calls A-ctor =&gt; g() =&gt; f(). There are entirely legitimate cases of calling f() from one of the class methods. Compiler can not say that this is illegal. The callgraph could have been from * =&gt; bar() =&gt; g() -&gt; f(), meaning the type of the object is not known. Such paths being possible, makes dynamic dispatching necessary - leading to the runtime error.</li>\n</ul>\n<p>As others pointed out, this is undefined usage and compilers only go so far in detecting and warning.</p>\n", "OwnerUserId": "1340410", "PostTypeId": "2", "Id": "31104344", "Score": "1", "CreationDate": "2015-06-28T20:18:37.840", "LastActivityDate": "2015-06-28T20:18:37.840"}});