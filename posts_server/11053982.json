post_cb({"11053982": {"ViewCount": "169", "Body": "<p>See the following:</p>\n<pre><code>struct A\n{\n    std::string* get() const\n    {\n        //return const_cast&lt;std::string*&gt;(&amp;m_pObj);\n        return &amp;const_cast&lt;A*&gt;(this)-&gt;m_pObj;\n    }\n\n    std::string m_pObj;\n};\n</code></pre>\n<p>Is dereferencing <code>const_cast</code> of <code>this</code> UB? Is there any time dereferencing the result from <code>const_cast</code>ing the constness of a pointer away <em>doesn't</em> invoke UB?</p>\n<p>(I know the above example is bad practice, bad design, and could be solved with mutable - that's not the point)</p>\n", "AcceptedAnswerId": "11054054", "Title": "Does dereferencing a pointer from a const_cast ALWAYS invoke undefined behavior?", "CreationDate": "2012-06-15T15:41:29.217", "Id": "11053982", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-06-15T16:06:49.987", "Score": "3", "OwnerUserId": "369872", "Tags": "<c++>", "AnswerCount": "4"}, "11054068": {"Id": "11054068", "PostTypeId": "2", "Body": "<p>No. To wit:</p>\n<blockquote>\n<p id=\"so_11053982_11054068_0\"><strong>5.2.2 Function call</strong></p>\n<p id=\"so_11053982_11054068_1\">5 [ Note: a function can change the values of its non-const parameters, but these changes cannot affect the\n  values of the arguments except where a parameter is of a reference type (8.3.2); if the reference is to a\n  const-qualified type, const_cast is required to be used to cast away the constness in order to modify\n  the argument\u2019s value. Where a parameter is of const reference type a temporary object is introduced if\n  needed (7.1.6, 2.14, 2.14.5, 8.3.4, 12.2). In addition, it is possible to modify the values of nonconstant objects\n  through pointer parameters. \u2014end note ]</p>\n</blockquote>\n<p>However, </p>\n<blockquote>\n<p id=\"so_11053982_11054068_2\"><strong>5.2.11 Const cast</strong></p>\n<p id=\"so_11053982_11054068_3\">12 [ Note: some conversions which involve only changes in cv-qualification cannot be done using const_cast.\n  For instance, conversions between pointers to functions are not covered because such conversions lead to\n  values whose use causes undefined behavior. For the same reasons, conversions between pointers to member\n  functions, and in particular, the conversion from a pointer to a const member function to a pointer to a\n  non-const member function, are not covered. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2012-06-15T15:46:29.883", "CommentCount": "0", "CreationDate": "2012-06-15T15:46:29.883", "ParentId": "11053982", "Score": "1", "OwnerUserId": "66692"}, "bq_ids": {"n4140": {"so_11053982_11054068_1": {"length": 48, "quality": 0.8421052631578947, "section_id": 5992}, "so_11053982_11054068_3": {"length": 43, "quality": 0.8958333333333334, "section_id": 6062}}, "n3337": {"so_11053982_11054068_1": {"length": 48, "quality": 0.8421052631578947, "section_id": 5760}, "so_11053982_11054068_3": {"length": 43, "quality": 0.8958333333333334, "section_id": 5830}}, "n4659": {"so_11053982_11054068_1": {"length": 48, "quality": 0.8421052631578947, "section_id": 7494}, "so_11053982_11054068_3": {"length": 42, "quality": 0.875, "section_id": 7558}}}, "11054054": {"Id": "11054054", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11053982_11054054_0\">Is dereferencing const_cast of this UB? Is there any time dereferencing the result from const_casting the constness of a pointer away doesn't invoke UB?</p>\n</blockquote>\n<p>Not always, only if the object <strong>is</strong> const (the <code>A</code> instance is <code>const A x;</code>) <strong>and</strong> the dereference is used to <em>modify</em> the data. If it is only used to <em>read</em> it will not be undefined behavior, if the object is not const, (maybe not at all, maybe a const-reference to a non-const object) it won't be UB either.</p>\n", "LastActivityDate": "2012-06-15T15:45:48.370", "CommentCount": "0", "CreationDate": "2012-06-15T15:45:48.370", "ParentId": "11053982", "Score": "9", "OwnerUserId": "36565"}, "11054036": {"Id": "11054036", "PostTypeId": "2", "Body": "<p>No, it is only UB if the referenced object has been declared as <code>const</code> originally <strong>and</strong> you subsequently modify the data obtained by the cast (\u00a75.2.11/7 and \u00a77.1.6.1/4). The following is legal:</p>\n<pre><code>A a;\na.get()-&gt;clear();\n</code></pre>\n<p>while this isn\u2019t (and is consequently UB):</p>\n<pre><code>A const a;\na.get()-&gt;clear();\n</code></pre>\n", "LastEditorUserId": "1968", "LastActivityDate": "2012-06-15T15:50:32.547", "Score": "3", "CreationDate": "2012-06-15T15:44:43.067", "ParentId": "11053982", "CommentCount": "3", "OwnerUserId": "1968", "LastEditDate": "2012-06-15T15:50:32.547"}, "11054242": {"Id": "11054242", "PostTypeId": "2", "Body": "<p>A compiler is free to store a const value in read-only memory, it is free to make assumptions that it will never change when optimising the program.  If you cast away the constness, you are breaking the contract with the compiler so technically <em>anything</em> can happen.</p>\n<p>Realistically, it is pretty rare for a compiler to do something that will be broken by const_cast-ing, but in theory it is possible.</p>\n", "LastEditorUserId": "111432", "LastActivityDate": "2012-06-15T16:06:49.987", "Score": "0", "CreationDate": "2012-06-15T15:57:23.567", "ParentId": "11053982", "CommentCount": "2", "OwnerUserId": "111432", "LastEditDate": "2012-06-15T16:06:49.987"}});