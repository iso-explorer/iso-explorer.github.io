post_cb({"37522549": {"Id": "37522549", "PostTypeId": "2", "Body": "<p>The <code>std::move()</code> function should be understood as a <strong>cast</strong> to the corresponding rvalue type, that <em>enables</em> moving the object instead of copying.</p>\n<hr>\n<p>It might make no difference at all:</p>\n<pre><code>std::cout &lt;&lt; std::move(std::string(\"Hello, world!\")) &lt;&lt; std::endl;\n</code></pre>\n<p>Here, the string was already an rvalue, so <code>std::move()</code> didn't change anything.</p>\n<hr>\n<p>It might enable moving, but may still result in a copy:</p>\n<pre><code>auto a = 42;\nauto b = std::move(a);\n</code></pre>\n<p>There's no more efficient way of creating an integer that simply copying it.</p>\n<hr>\n<p>Where it <em>will</em> cause a move to happen is when the argument</p>\n<ol>\n<li>is an lvalue, or lvalue reference,</li>\n<li>has a <em>move constructor</em> or <em>move assignment</em> operator, and</li>\n<li>is (implicitly or explicitly) the source of a construction or assignment.</li>\n</ol>\n<p>Even in this case, it's not the <code>move()</code> itself that actually <em>moves</em> the data, it's the construction or assignment.  <code>std:move()</code> is simply the cast that allows that to happen, even if you have an lvalue to start with.  And the move can happen without <code>std::move</code> if you start with an rvalue.  I think that's the meaning behind Meyers's statement.</p>\n</hr></hr></hr>", "LastActivityDate": "2016-05-30T09:47:29.150", "Score": "1", "CreationDate": "2016-05-30T09:47:29.150", "ParentId": "36827900", "CommentCount": "0", "OwnerUserId": "4850040"}, "bq_ids": {"n4140": {"so_36827900_37443572_1": {"length": 23, "quality": 0.92, "section_id": 6365}}, "n3337": {"so_36827900_37443572_1": {"length": 23, "quality": 0.92, "section_id": 6122}}, "n4659": {"so_36827900_37443572_1": {"length": 23, "quality": 0.92, "section_id": 7876}}}, "36827900": {"ViewCount": "4632", "Body": "<p>I have heard Scott Meyers say \"<code>std::move()</code> doesn't move anything\" ... but I haven't understood what it means.</p>\n<p>So to specify my question consider the following:</p>\n<pre><code>class Box { /* things... */ };\n\nBox box1 = some_value;\nBox box2 = box1;    // value of box1 is copied to box2 ... ok\n</code></pre>\n<p>What about:</p>\n<pre><code>Box box3 = std::move(box1);\n</code></pre>\n<p>I do understand the rules of lvalue and rvalue but what I don't understand is what is actually happening in the memory? Is it just copying the value in some different way, sharing an address or what? More specifically: what makes moving faster than copying?</p>\n<p>I just feel that understanding this would make everything clear to me. Thanks in advance!</p>\n<p><strong>EDIT:</strong> Please note that I'm not asking about the <code>std::move()</code> implementation or any syntactic stuff.</p>\n", "AcceptedAnswerId": "37443572", "Title": "What makes moving objects faster than copying?", "CreationDate": "2016-04-24T19:31:02.663", "LastActivityDate": "2018-03-08T09:52:41.153", "CommentCount": "5", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2016-05-30T11:03:48.040", "LastEditorUserId": "3919155", "Id": "36827900", "Score": "13", "OwnerUserId": "6189761", "Tags": "<c++><move><rvalue>", "AnswerCount": "3"}, "37443572": {"Id": "37443572", "PostTypeId": "2", "Body": "<p>As <a href=\"https://stackoverflow.com/users/5793987/gudok\">@gudok</a> <a href=\"https://stackoverflow.com/a/36828144/14089\">answered before</a>, everything is in the implementation... Then a bit is in user code.</p>\n<h2>The implementation</h2>\n<p>Let's assume we're talking about the copy-constructor to assign a value to the current class.</p>\n<p>The implementation you'll provide will take into account two cases:</p>\n<ol>\n<li>the parameter is a l-value, so you can't touch it, by definition</li>\n<li>the parameter is a r-value, so, implicitly, the temporary won't live much longer beyond you using it, so, instead of copying its content, you could steal its content</li>\n</ol>\n<p>Both are implemented using an overload:</p>\n<pre><code>Box::Box(const Box &amp; other)\n{\n   // copy the contents of other\n}\n\nBox::Box(Box &amp;&amp; other)\n{\n   // steal the contents of other\n}\n</code></pre>\n<h3>The implementation for light classes</h3>\n<p>Let's say your class contains two integers: You can't <strong>steal</strong> those because they are plain raw values. The only thing that would <strong>seem</strong> like <strong>stealing</strong> would be to copy the values, then set the original to zero, or something like that... Which makes no sense for simple integers. Why do that extra work?</p>\n<p>So for light value classes, actually offering two specific implementations, one for l-value, and one for r-values, makes no sense.</p>\n<p>Offering only the l-value implementation will be more than enough.</p>\n<h3>The implementation for heavier classes</h3>\n<p>But in the case of some heavy classes (i.e. std::string, std::map, etc.), copying implies potentially a cost, usually in allocations. So, ideally, you want to avoid it as much as possible. This is where <strong>stealing</strong> the data from temporaries becomes interesting.</p>\n<p>Assume your Box contains a raw pointer to a <code>HeavyResource</code> that is costly to copy. The code becomes:</p>\n<pre><code>Box::Box(const Box &amp; other)\n{\n   this-&gt;p = new HeavyResource(*(other.p)) ; // costly copying\n}\n\nBox::Box(Box &amp;&amp; other)\n{\n   this-&gt;p = other.p ; // trivial stealing, part 1\n   other.p = nullptr ; // trivial stealing, part 2\n}\n</code></pre>\n<p>It's plain one constructor (the copy-constructor, needing an allocation) is much slower than another (the move-constructor, needing only assignments of raw pointers).</p>\n<h3>When is it safe to \"steal\"?</h3>\n<p>The thing is: By default, the compiler will invoke the \"fast code\" only when the parameter is a temporary (it's a bit more subtle, but bear with me...).</p>\n<p>Why?</p>\n<p>Because the compiler can guarantee you can steal from some object without any problem <strong>only</strong> if that object is a temporary (or will be destroyed soon after anyway). For the other objects, stealing means you suddenly have an object that is valid, but in an unspecified state, which could be still used further down in the code. Possibly leading to crashes or bugs:</p>\n<pre><code>Box box3 = static_cast&lt;Box &amp;&amp;&gt;(box1); // calls the \"stealing\" constructor\nbox1.doSomething();         // Oops! You are using an \"empty\" object!\n</code></pre>\n<p>But sometimes, you want the performance. So, how do you do it?</p>\n<h2>The user code</h2>\n<p>As you wrote:</p>\n<pre><code>Box box1 = some_value;\nBox box2 = box1;            // value of box1 is copied to box2 ... ok\nBox box3 = std::move(box1); // ???\n</code></pre>\n<p>What happens for box2 is that, as box1 is a l-value, the first, \"slow\" copy-constructor is invoked. This is the normal, C++98 code.</p>\n<p>Now, for box3, something funny happens: The std::move does return the same box1, but as a r-value reference, instead of a l-value. So the line:</p>\n<pre><code>Box box3 = ...\n</code></pre>\n<p>... will NOT invoke copy-constructor on box1.</p>\n<p>It will invoke INSTEAD the stealing constructor (officially known as the move-constructor) on box1.</p>\n<p>And as your implementation of the move constructor for Box does \"steal\" the content of box1, at the end of the expression, box1 is in a valid but unspecified state (usually, it will be empty), and box3 contains the (previous) content of box1.</p>\n<h2>What about the valid but unspecified state of a moved-out class?</h2>\n<p>Of course, writing std::move on a l-value means you make a promise you won't use that l-value again. Or you will do it, very, very carefully.</p>\n<p>Quoting the C++17 Standard Draft (C++11 was: 17.6.5.15):</p>\n<blockquote>\n<p id=\"so_36827900_37443572_0\">20.5.5.15 Moved-from state of library types [lib.types.movedfrom]</p>\n<p id=\"so_36827900_37443572_1\">Objects of types defined in the C++ standard library may be moved from (15.8). Move operations may be explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>This was about the types in the standard library, but this is something you should follow for your own code.</p>\n<p>What it means is that the moved-out value could now hold any value, from being empty, zero, or some random value. E.g. for all you know, your string \"Hello\" would become an empty string \"\", or become \"Hell\", or even \"Goodbye\", if the implementer feels it is the right solution. It still must be a valid string, though, with all its invariants respected.</p>\n<p>So, in the end, unless the implementer (of a type) explicitly committed to a specific behavior after a move, you should act as if you know <strong>nothing</strong> about a moved-out value (of that type).</p>\n<h2>Conclusion</h2>\n<p>As said above, the std::move does <em>nothing</em>. It only tells the compiler: \"You see that l-value? please consider it a r-value, just for a second\".</p>\n<p>So, in:</p>\n<pre><code>Box box3 = std::move(box1); // ???\n</code></pre>\n<p>... the user code (i.e. the std::move) tells the compiler the parameter can be considered as a r-value for this expression, and thus, the move constructor will be called.</p>\n<p>For the code author (and the code reviewer), the code actually tells it is ok to steal the content of box1, to move it into box3. The code author will then have to make sure box1 is not used anymore (or used very very carefully). It is their responsibility.</p>\n<p>But in the end, it is the implementation of the move constructor that will make a difference, mostly in performance: If the move constructor actually steals the content of the r-value, then you will see a difference. If it does anything else, then the author lied about it, but this is another problem...</p>\n", "LastEditorUserId": "14089", "LastActivityDate": "2018-03-08T09:52:41.153", "Score": "22", "CreationDate": "2016-05-25T17:06:34.823", "ParentId": "36827900", "CommentCount": "8", "OwnerUserId": "14089", "LastEditDate": "2018-03-08T09:52:41.153"}, "36828144": {"Id": "36828144", "PostTypeId": "2", "Body": "<p>It's all about implementation. Consider simple string class:</p>\n<pre><code>class my_string {\n  char* ptr;\n  size_t capacity;\n  size_t length;\n};\n</code></pre>\n<p>Semantics of <em>copy</em> requires us to make a full copy of string including allocation of another array in dynamic memory and copying <code>*ptr</code> contents there, which is expensive.</p>\n<p>Semantics of <em>move</em> requires us only to transfer the value of pointer itself to new object without duplicating contents of string.</p>\n<p>If, of course, class doesn't use dynamic memory or system resources, then there is no difference between moving and copying in terms of performance.</p>\n", "LastActivityDate": "2016-04-24T19:50:57.923", "Score": "12", "CreationDate": "2016-04-24T19:50:57.923", "ParentId": "36827900", "CommentCount": "5", "OwnerUserId": "5793987"}});