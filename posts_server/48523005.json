post_cb({"48529586": {"Id": "48529586", "PostTypeId": "2", "Body": "<p>The short answer is, because the <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> and <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> standard both say so.</p>\n<hr>\n<p>Others have answered \"because the compiler knows how big pointers are\".  But that really doesn't answer <strong>why</strong>.  There are languages that permit incomplete types inside other types, and they work fine.</p>\n<p>If any of these assumptions are changed, C/C++ would support incomplete structs within structs:</p>\n<ol>\n<li><p>C/C++ actually stores values.  Many languages, when given a composite data type (a class or struct) within another, store a reference or pointer instead of actual values of that composite data type</p></li>\n<li><p>C/C++ wants to know how big complete types are.  It wants to be able to create arrays, calculate their size, calculate the offset between elements.</p></li>\n<li><p>C/C++ wants single-pass compiling.  If the compiler was willing to note that there was an incomplete type there, continue compiling until it finds out <em>later</em> how big it is, then come back and insert the size of the type into the generated code, incomplete types would be fine.</p></li>\n<li><p>C/C++ wants types to be complete after you define them.  You could easily insert a rule stating that <code>abc</code> was only complete once <code>nonexistnow</code>'s definition was visible.  Instead, C++ wants <code>abc</code> to be complete right after the closing <code>}</code>, probably for simplicities sake.</p></li>\n</ol>\n<p>Finally, pointers to structs satisfy all of these requirements because the C++ standard demands that they do.  Which seems like a cop out, but it is true:</p>\n<p>On some platforms, the size of a pointer varies with the features of the thing pointed to (in particular, pointers to single-byte characters on platforms where native pointers address quad words are larger).  C/C++ permits this, but requires that <code>void*</code> be large enough for the largest pointer, and that pointers-to-struct have a fixed size.  This hurts such platforms, but they are willing to do this in order to permit pointers to incomplete structs inside complete structs.</p>\n<p>Quite possibly the compiler would rather than a <code>struct small { char c; }</code> be 1 byte in size, and hence pointers to it be \"wide\"; but because all pointers-to-struct must have the same size, and they don't want to use wide pointers for every struct, instead we have <code>sizeof(small) == 4</code> on such systems.</p>\n<p>It isn't a law of computing that all pointers are the same size, and it isn't a law that structs have to know how big they are.  These are both laws of <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> and <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> that where chosen for reasons.</p>\n<p>But once you have those reasons, you are forced to conclude that members of <code>struct</code>s have to have known size (and alignment), and incomplete structs don't.  Meanwhile, pointers to incomplete structs do.  So one is permitted, and the other not.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2018-01-30T21:17:40.163", "Score": "2", "CreationDate": "2018-01-30T20:01:17.823", "ParentId": "48523005", "CommentCount": "7", "OwnerUserId": "1774667", "LastEditDate": "2018-01-30T21:17:40.163"}, "48523024": {"Id": "48523024", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48523005_48523024_0\">Why does second struct definition doesn't cause any problem?</p>\n</blockquote>\n<p>Because it is a pointer. The size of the pointer is known to the compiler even if the type the pointer is pointing to is incomplete.</p>\n", "LastActivityDate": "2018-01-30T13:48:05.517", "Score": "35", "CreationDate": "2018-01-30T13:48:05.517", "ParentId": "48523005", "CommentCount": "2", "OwnerUserId": "8012646"}, "48523155": {"Id": "48523155", "PostTypeId": "2", "Body": "<p>Compiler needs the size of a struct / class in order to know how much memory has to be allocated when such type is instantiated.</p>\n<p>On a given platform, <code>sizeof(T*)</code> will always return the same value, for any type T that is a struct or class type.</p>\n<p>That is why you can use pointers to forward-declared types with no errors. Of course, to access content of an object pointed to by such pointer or dereference it, definition must be provided. You can, however assign value to such pointer (as long as it is allowed in terms of type compatibility).</p>\n<p>An important fact:</p>\n<p>In C, where you typically use so-called \"C-style cast\", pointer assignment can usually be performed regardless the types (it is your responsibility to ensure the correct behavior and fulfill alignment requirements).</p>\n<p>In C++ however, whether cast between incomplete types is possible depends on the type of the cast. Consider two polymorphic types:</p>\n<pre><code>class A; // forward declaration only\nclass B; // forward declaration only, actually inherits from A\n\nA* aptr;\nB* bptr;\n\nbptr = (B*)(aptr); // ok\nbptr = dynamic_cast&lt;B*&gt;(aptr); // error\n</code></pre>\n<p><code>dynamic_cast&lt;&gt;</code> will fail if compiler does not have access to the definition of types involved in the cast (which is necessary to perform runtime-check). Example: <a href=\"https://ideone.com/66noSz\" rel=\"nofollow noreferrer\">Ideone</a>.</p>\n", "LastEditorUserId": "8422330", "LastActivityDate": "2018-01-31T00:42:30.467", "Score": "8", "CreationDate": "2018-01-30T13:55:31.500", "ParentId": "48523005", "CommentCount": "6", "OwnerUserId": "2812864", "LastEditDate": "2018-01-31T00:42:30.467"}, "bq_ids": {"n4140": {"so_48523005_48530528_1": {"length": 12, "quality": 0.75, "section_id": 7223}}, "n3337": {"so_48523005_48530528_1": {"length": 12, "quality": 0.75, "section_id": 6967}}, "n4659": {"so_48523005_48530528_1": {"length": 12, "quality": 0.75, "section_id": 8732}}}, "48523005": {"ViewCount": "1223", "Body": "<p>Lets say we define two structures in either C or C++ (I get the same result in both C and C++ and I think the rules are the same, tell me if they are not).</p>\n<p>one with a value member of an incomplete type:</p>\n<pre><code>struct abc{\n  int data;\n  struct nonexsitnow next; //error: field \u2018next\u2019 has incomplete type, makes sense since \"struct nonexsitnow\" hasn't been declared or defined.\n};\n</code></pre>\n<p>and one with a pointer member of an incomplete type:</p>\n<pre><code>struct abc{\n  int data;\n  struct nonexsitnow *next; //pass?!\n};\n</code></pre>\n<p>Why doesn't the second definition cause any issue? It uses <code>struct nonexsitnow</code> which hasn't been created!</p>\n<h2><strong>UPDATE:</strong></h2>\n<p>I conclude this sheet from answers and comments below, hoping they're right and helpful for elaborations.</p>\n<p>As @ArneVogel has mentioned, both <code>struct Foo p;</code> and <code>struct Foo *p;</code> is an implicit declaration of <code>Foo</code>, and <code>struct Foo;</code> explicitly does this job(thanks @John Bollinger). This means nearly nothing for <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"show questions tagged 'c'\">c</a> but makes a difference for <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a>, and behaviors:</p>\n<pre><code>                         when struct Foo is:\n_______________________________________________________\n|               | undeclared | declared but | defined |\n|               |            | not defined  |         |\n-------------------------------------------------------\n|               |  C | C++   |  C  |  C++   | C | C++ |\n-------------------------------------------------------\n|struct Foo  p; |  \u00d7 |  \u00d7    |  \u00d7  |   \u00d7    | \u221a |  \u221a  |\n|struct Foo* p; |  \u221a |  \u221a    |  \u221a  |   \u221a    | \u221a |  \u221a  |\n|       Foo  p; |  \u00d7 |  \u00d7    |  \u00d7  |   \u00d7    | \u00d7 |  \u221a  |\n|       Foo* p; |  \u00d7 |  \u00d7    |  \u00d7  |   \u221a    | \u00d7 |  \u221a  |\n</code></pre>\n", "AcceptedAnswerId": "48530528", "Title": "C/C++ structure incomplete member type inconsistency?", "CreationDate": "2018-01-30T13:46:42.900", "LastActivityDate": "2018-02-01T08:09:52.603", "CommentCount": "11", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-02-01T08:09:52.603", "LastEditorUserId": "6919549", "Id": "48523005", "Score": "13", "OwnerUserId": "6919549", "Tags": "<c++><c><pointers><struct>", "AnswerCount": "4"}, "48530528": {"Id": "48530528", "PostTypeId": "2", "Body": "<p>In the first place, you need to understand what it means for a type to be \"incomplete\".  C defines it this way:</p>\n<blockquote>\n<p id=\"so_48523005_48530528_0\">At various points within a translation unit an object type may be\n  incomplete (lacking sufficient information to determine the size of\n  objects of that type) or complete (having sufficient information).</p>\n</blockquote>\n<p>(C2011, <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.2.5p1\" rel=\"noreferrer\">6.2.5/1</a>)</p>\n<p>Note well that type completeness is a function of the scope and visibility of declarations, not an inherent characteristic of types.  A type can be incomplete at one point in a translation unit, and complete at a different point.</p>\n<p>However,</p>\n<blockquote>\n<p id=\"so_48523005_48530528_1\">A pointer type may be derived from a function type or an object type,\n  called the referenced type. [...] <strong>A pointer type is a complete object\n  type</strong>.</p>\n</blockquote>\n<p>(C2011, <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.2.5p20\" rel=\"noreferrer\">6.2.5/20</a>; emphasis added)</p>\n<p>Without qualification, then, all pointer types are complete types, even pointers whose referenced types are not themselves complete.  <em>How</em> a particular implementation makes this work is not addressed by the standard, but ordinarily, all pointer-to-structure types have the same size and representation (which has nothing to do with the representation of their referenced types).</p>\n<p>This turns out to be important, because a structure type is incomplete until the closing brace of its definition, so if pointers to incomplete types were not themselves complete, then a structure could not contain a pointer to another structure of its own type, such as is commonly used to implement linked lists, trees, and other data structures.</p>\n<p>On the other hand,</p>\n<blockquote>\n<p id=\"so_48523005_48530528_2\">A structure or union type of unknown content [...]\n  is an incomplete type. It is completed, for all declarations of that\n  type, by declaring the same structure or union tag with its defining\n  content later in the same scope.</p>\n</blockquote>\n<p>(C2011, <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.2.5p22\" rel=\"noreferrer\">6.2.5/22</a>)</p>\n<p>This stands to reason, since the compiler cannot know how big a structure type is if it does not know what its members are.  It then furthermore makes sense that</p>\n<blockquote>\n<p id=\"so_48523005_48530528_3\">A structure or union shall not contain a member with incomplete or\n  function type (hence, <strong>a structure shall not contain an instance of\n  itself, but may contain a pointer to an instance of itself</strong>), except\n  that the last member of a structure with more than one named member\n  may have incomplete array type [...].</p>\n</blockquote>\n<p>(C2011, <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.7.2.1p3\" rel=\"noreferrer\">6.7.2.1/3</a>; emphasis added)</p>\n<p>The exception describes a C feature called a \"flexible array member\", which comes with several caveats and restrictions.  That's a tangential matter that you can read (or ask) about separately.</p>\n<p>Additionally, all of the foregoing is consistent with the fact that C and C++ permit you to reference a structure type by its tag prior to its members being declared; that is, when it is an incomplete.  This can be done on its own as a forward declaration ...</p>\n<pre><code>struct foo;\n</code></pre>\n<p>... but that doesn't serve any but documentary purposes, because forward declaration of structure types is not required.  You can think again of the linked-list usage, but this characteristic is in no way limited to such contexts.</p>\n<p>Indeed, a relatively common use case is to implement opaque types.  In such a case, a library produces and consumes a data type whose implementation it does not want to disclose, for any of a variety of reasons.  It can nevertheless hand out appropriately-typed pointers to instances of such structures to client code, and expect to receive such pointers back.  If it never provides a definition of the referenced type, then the client code has to treat the referenced objects as opaque blobs.</p>\n", "LastActivityDate": "2018-01-30T21:08:45.667", "Score": "6", "CreationDate": "2018-01-30T21:08:45.667", "ParentId": "48523005", "CommentCount": "4", "OwnerUserId": "2402272"}});