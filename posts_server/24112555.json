post_cb({"24112690": {"Id": "24112690", "PostTypeId": "2", "Body": "<p>No, the program will break if the initialization is failed. You cannot catch the exception and handle it because the global variables(static member data) is initialized before <code>main()</code>.</p>\n<p>It's better to call <code>init_API()</code> and <code>deinit_API()</code> in <code>main()</code>.</p>\n", "LastActivityDate": "2014-06-09T01:45:38.390", "CommentCount": "0", "CreationDate": "2014-06-09T01:45:38.390", "ParentId": "24112555", "Score": "2", "OwnerUserId": "2045884"}, "24112694": {"Id": "24112694", "PostTypeId": "2", "Body": "<p>This is covered by \u00a73.6.2 [basic.start.init]/p4-6 of the standard:</p>\n<blockquote>\n<p id=\"so_24112555_24112694_0\">It is implementation-defined whether the dynamic initialization of a\n  non-local variable with static storage duration is done before the\n  first statement of <code>main</code>. If the initialization is deferred to some\n  point in time after the first statement of main, it shall occur before\n  the first odr-use of any function or variable defined in the same\n  translation unit as the variable to be initialized.<sup>35</sup></p>\n<p id=\"so_24112555_24112694_1\">[...]</p>\n<p id=\"so_24112555_24112694_2\">If the initialization of a non-local variable with static or thread storage duration exits via an exception, <code>std::terminate</code> is called.</p>\n<p id=\"so_24112555_24112694_3\"><sup>35</sup> A non-local variable with static storage duration having initialization with side-effects must be initialized even if it is not odr-used.</p>\n</blockquote>\n<p>As there's no way your static object can be in the same translation unit as a function in the C library you are wrapping, the only way to guarantee initialization would be to define it in the same translation unit as <code>main()</code>, which doesn't strike me as adding any kind of convenience to the end user.</p>\n<p>In any event, it's probably not a good idea to cause <code>std::terminate</code> to be called by throwing an exception if initialization fails. The end user probably want to do better error handling than that.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-03T09:10:03.000", "Score": "1", "CreationDate": "2014-06-09T01:45:59.163", "ParentId": "24112555", "CommentCount": "3", "OwnerUserId": "2756719", "LastEditDate": "2014-08-03T09:10:03.000"}, "bq_ids": {"n4140": {"so_24112555_24112694_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 7153}, "so_24112555_24112694_2": {"length": 12, "quality": 1.0, "section_id": 7155}, "so_24112555_24112694_3": {"length": 12, "quality": 1.0, "section_id": 7153}}, "n3337": {"so_24112555_24112694_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 6897}, "so_24112555_24112694_2": {"length": 12, "quality": 1.0, "section_id": 6899}, "so_24112555_24112694_3": {"length": 12, "quality": 1.0, "section_id": 6897}}, "n4659": {"so_24112555_24112694_0": {"length": 22, "quality": 0.6285714285714286, "section_id": 8657}, "so_24112555_24112694_2": {"length": 12, "quality": 1.0, "section_id": 8660}, "so_24112555_24112694_3": {"length": 10, "quality": 0.8333333333333334, "section_id": 8657}}}, "24117096": {"Id": "24117096", "PostTypeId": "2", "Body": "<p>The answer is: it depends.  If the external API is implemented\nin C (so that it will have no dynamic initialization), and it is\nnot used in any of your static initializers (which should be the\ncase, since there is no way that they can safely do <code>init_API</code>),\nthen the idiom is more or less safe (except that you shouldn't\nallow an exception to escape from a static initializer.  Whether\nit is a good idea or not is another question; if the\ninitialization can fail, you may not want to execute it before\nyou can catch and handle the error, which means that you're in\n<code>main</code>. </p>\n", "LastActivityDate": "2014-06-09T09:14:33.703", "CommentCount": "0", "CreationDate": "2014-06-09T09:14:33.703", "ParentId": "24112555", "Score": "0", "OwnerUserId": "649665"}, "24112555": {"ViewCount": "98", "Body": "<p>Let's say I have a C library that has its own (de)initialization routine, as many of them do.</p>\n<pre><code>init_API();\n\ndeinit_API();\n</code></pre>\n<p>now let's say I want to provide another level of abstraction to the user, and abstract away these calls, using a class that's instantiated statically. The method I was thinking of:</p>\n<pre><code>struct API_initializer{\n    API_initializer(){\n        init_API();\n        if(API_init_failure)\n            throw (APIFailureException); //important\n    }\n\n    ~API_initializer(){\n        deinit_API();\n    }\n};\n\nstruct API_initializer_holder{\n    static API_initializer initializer;\n};\n</code></pre>\n<p>Now, my question is, is this well-defined behavior? I.E., will the static constructor be called at some reasonable point, and will all the (static) variables the C API need be initialized properly? In addition, is it bad practice to throw an exception that the user has no way of catching?</p>\n", "AcceptedAnswerId": "24112694", "Title": "Is This \"Idiom\" Well-Defined?", "CreationDate": "2014-06-09T01:22:03.873", "Id": "24112555", "CommentCount": "6", "LastEditDate": "2014-06-09T01:34:05.660", "PostTypeId": "1", "LastEditorUserId": "701092", "LastActivityDate": "2014-08-03T09:10:03.000", "Score": "1", "OwnerUserId": "1575991", "Tags": "<c++>", "AnswerCount": "4"}, "24112712": {"Id": "24112712", "PostTypeId": "2", "Body": "<p>In my experience it is a bad idea to try and rely on static initialization order. </p>\n<p>A better idea would be to get rid of the holder, and just go:</p>\n<pre><code>int main()\n{\n    API_initializer foo;\n\n    // rest of program\n}\n</code></pre>\n<p>If you really want it to throw on failure then include a try..catch block.</p>\n<p>NB. Make the class non-copyable to prevent accidents.</p>\n", "LastActivityDate": "2014-06-09T01:49:41.687", "CommentCount": "2", "CreationDate": "2014-06-09T01:49:41.687", "ParentId": "24112555", "Score": "3", "OwnerUserId": "1505939"}});