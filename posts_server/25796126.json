post_cb({"bq_ids": {"n4140": {"so_25796126_25796713_0": {"length": 45, "quality": 0.9, "section_id": 5994}}, "n3337": {"so_25796126_25796713_0": {"length": 45, "quality": 0.9, "section_id": 5762}}, "n4659": {"so_25796126_25796713_0": {"length": 42, "quality": 0.84, "section_id": 7496}}}, "25796716": {"Id": "25796716", "PostTypeId": "2", "Body": "<p>Here is a function using expression SFINAE based on <a href=\"https://stackoverflow.com/u/962089\">chris</a> <a href=\"http://coliru.stacked-crooked.com/a/8d5e54bafa436f5f\" rel=\"nofollow noreferrer\">proposal</a> which allows checking whether a type is complete yet.<br>\nMy adoption needs no includes, errors-out when the required argument is missing (hiding the argument was not possible) and is suitable for C++11 onward.</br></p>\n<pre><code>template&lt;typename T&gt;\nconstexpr auto is_complete(int=0) -&gt; decltype(!sizeof(T)) {\n    return true;   \n}\n\ntemplate&lt;typename T&gt;\nconstexpr bool is_complete(...) {return false;}\n</code></pre>\n<p>And a test-suite:</p>\n<pre><code>struct S;\n\nbool xyz() {return is_complete&lt;S&gt;(0);}\n\nstruct S{};\n\n#include &lt;iostream&gt;\nint main() {\n    std::cout &lt;&lt; is_complete&lt;int&gt;(0) &lt;&lt; '\\n';\n    std::cout &lt;&lt; xyz() &lt;&lt; '\\n';\n    std::cout &lt;&lt; is_complete&lt;S&gt;(0);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>1\n0\n1\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/712883d0c7117bdc\" rel=\"nofollow noreferrer\"><kbd>See live on coliru</kbd></a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-11T21:06:15.123", "Score": "4", "CreationDate": "2014-09-11T20:51:03.357", "ParentId": "25796126", "CommentCount": "6", "OwnerUserId": "3204551", "LastEditDate": "2017-05-23T10:26:23.077"}, "25796126": {"ViewCount": "550", "Body": "<p>Is there a way to static_assert that a type T is <strong>Not</strong> complete at that point in a header?  The idea is to have a compile error if someone adds #includes down the road in places they should not be. </p>\n<p>related:  <a href=\"https://stackoverflow.com/questions/1625105/how-to-write-is-complete-template\">How to write `is_complete` template?</a></p>\n<p>Using that link's answer, </p>\n<pre><code>namespace\n{\ntemplate&lt;class T, int discriminator&gt;\nstruct is_complete {\n  static T &amp; getT();\n  static char (&amp; pass(T))[2];\n  static char pass(...);\n  static const bool value = sizeof(pass(getT()))==2;\n};\n}\n#define IS_COMPLETE(X) is_complete&lt;X,__COUNTER__&gt;::value\nclass GType;\nstatic_assert(!IS_COMPLETE(GType),\"no cheating!\");\n</code></pre>\n<p>unfortunately this gives \"invalid use of incomlete type\" error, d'oh. Is there a way to assert on the negation? </p>\n", "Title": "static assert that template typename T is NOT complete?", "CreationDate": "2014-09-11T20:12:57.623", "LastActivityDate": "2014-09-12T10:49:22.157", "CommentCount": "4", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:57:15.963", "LastEditorUserId": "-1", "Id": "25796126", "Score": "9", "OwnerUserId": "221802", "Tags": "<c++><templates><static-assert><incomplete-type>", "AnswerCount": "2"}, "25796713": {"Body": "<p>Passing a reference through <code>...</code> doesn't work. </p>\n<p>5.2.2/7:</p>\n<blockquote>\n<p id=\"so_25796126_25796713_0\">When there is no parameter for a given argument, the argument is passed in such a way that the receiving\n  function can obtain the value of the argument by invoking <code>va_arg</code> (18.10). [note skipped \u2014 n.m.] The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and\n  function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that\n  has (possibly <code>cv</code>-qualified) type <code>std::nullptr_t</code> is converted to type <code>void*</code> (4.10). After these conversions,\n  if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the\n  program is ill-formed.</p>\n</blockquote>\n<p>Here's a kind-of-working solution hastily adapted from @chris's comment:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\nnamespace\n{\n\n    template&lt;typename T, int&gt;\n        constexpr auto is_complete(int) -&gt; decltype(sizeof(T),bool{}) {\n            return true;\n        }\n\n    template&lt;typename T, int&gt;\n        constexpr auto is_complete(...) -&gt; bool {\n            return false;\n        }\n}\n\n\n#define IS_COMPLETE(T) is_complete&lt;T,__LINE__&gt;(0) // or use __COUNTER__ if supported\n\nstruct S;\n\nstatic_assert(IS_COMPLETE(int), \"oops 1!\");\nstatic_assert(!IS_COMPLETE(S), \"oops 2!\");\n\nstruct S {};\n\nstatic_assert(IS_COMPLETE(S), \"oops 3!\");\n</code></pre>\n", "CreationDate": "2014-09-11T20:51:00.530", "ParentId": "25796126", "CommentCount": "3", "LastEditDate": "2014-09-12T10:49:22.157", "Id": "25796713", "PostTypeId": "2", "LastActivityDate": "2014-09-12T10:49:22.157", "LastEditorUserId": "775806", "CommunityOwnedDate": "2014-09-11T20:51:00.530", "Score": "2", "OwnerUserId": "775806"}});