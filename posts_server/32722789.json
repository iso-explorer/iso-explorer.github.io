post_cb({"32722789": {"ViewCount": "432", "Body": "<p>Consider the following three expressions:</p>\n<pre><code>++x;\nx += 1;\nx = x + 1;\n</code></pre>\n<p>As far as I'm aware, they are identical in semantics, ignoring operator overloading in C++.  However, today I read an assertion that they are different, specifically when <code>x</code> is declared <code>volatile</code>.</p>\n<p>To test this assertion, I wrote the following and compiled it for PowerPC, AMD64, ARMv6 and 68k:</p>\n<pre><code>#include &lt;stdint.h&gt;\n\nstatic volatile uint64_t x = 0;\n\nvoid a(void)\n{\n    ++x;\n}\n\nvoid b(void)\n{\n    x += 1;\n}\n\nvoid c(void)\n{\n    x = x + 1;\n}\n</code></pre>\n<p>On all four of these platforms, the three functions produced identical assembler output, whether at -O1 or -O3.  On AMD64, that was just two instructions:</p>\n<pre><code>incq    _x(%rip)\nretq\n</code></pre>\n<p>Therefore, <em>is</em> there any truth behind that assertion?  If so, what is the difference, and how can I expose it?</p>\n<p>NB: I'm perfectly aware that <code>volatile</code> doesn't guarantee atomicity.  That's not what I'm asking about here - unless the atomicity itself is what is different between the three.</p>\n", "AcceptedAnswerId": "32723582", "Title": "Incrementing a volatile variable in C", "CreationDate": "2015-09-22T17:05:58.270", "Id": "32722789", "CommentCount": "19", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-09-22T18:53:55.343", "LastEditorUserId": "1708801", "LastActivityDate": "2015-09-24T18:30:26.037", "Score": "12", "OwnerUserId": "303953", "Tags": "<c++><c><language-lawyer><volatile>", "AnswerCount": "2"}, "32723582": {"Id": "32723582", "PostTypeId": "2", "Body": "<p>From the draft C++ standard section <code>5.3.2</code> <em>[expr.pre.incr]</em> says:</p>\n<blockquote>\n<p id=\"so_32722789_32723582_0\">If x is not of type bool, the expression ++x is equivalent to x+=1</p>\n</blockquote>\n<p>and <code>5.17</code> <em>[expr.ass]</em> says:</p>\n<blockquote>\n<p id=\"so_32722789_32723582_1\">The behavior of an expression of the form E1 op = E2 is equivalent to\n  E1 = E1 op E2 except that E1 is evaluated only once.</p>\n</blockquote>\n<p>So <code>++x</code> and <code>x += 1</code> are equivalent.</p>\n<p>Now the one case where <code>x += 1</code> differs from <code>x = x + 1</code> is that <code>E1</code> is only evaluated once. In this particular case it does not matter but we can come up with a case where it does:</p>\n<pre><code>#include &lt;stdint.h&gt;\n\nvolatile uint64_t x = 0;\nvolatile uint64_t y[2] = {0} ;\n\nvoid c(void)\n{\n   y[x] = y[x] + 1;\n}\n</code></pre>\n<p>in this case the <code>x</code> will be evaluated twice as opposed to this case:</p>\n<pre><code>void b(void)\n{\n   y[x] += 1;\n}\n</code></pre>\n<p>and a <a href=\"http://goo.gl/Z2L6Qw\" rel=\"nofollow\">godbolt session shows</a> for <code>b()</code>:</p>\n<pre><code>b():                                  # @b()\nmovq    x(%rip), %rax\nincq    y(,%rax,8)\nretq\n</code></pre>\n<p>and for <code>c()</code>:</p>\n<pre><code>c():                                  # @c()\nmovq    x(%rip), %rax\nmovq    y(,%rax,8), %rax\nincq    %rax\nmovq    x(%rip), %rcx\nmovq    %rax, y(,%rcx,8)\nretq\n</code></pre>\n<p>As far as I can tell this applies to C11 as well. From C11 section <code>6.5.3.1</code> Prefix increment and decrement operators:</p>\n<blockquote>\n<p id=\"so_32722789_32723582_2\">The expression ++E is equivalent to (E+=1).</p>\n</blockquote>\n<p>and from section <code>6.5.16.2</code> Compound assignment:</p>\n<blockquote>\n<p id=\"so_32722789_32723582_3\">Acompound assignment of the form E1 op= E2 is equivalent to the simple\n  assignment expression E1 = E1 op (E2), except that the lvalue E1 is\n  evaluated only once</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-09-24T18:30:26.037", "Score": "12", "CreationDate": "2015-09-22T17:50:58.407", "ParentId": "32722789", "CommentCount": "8", "LastEditDate": "2015-09-24T18:30:26.037", "OwnerUserId": "1708801"}, "32724909": {"Id": "32724909", "PostTypeId": "2", "Body": "<p>In the abstract semantics, all three of these expressions do exactly the same thing. They <em>access</em> <code>x</code> to retrieve its value, calculate the new value, then store the updated value back in <code>x</code>. There is an access and a store.  (The expressions also yield a value, which is being discarded).</p>\n<p>Although <code>x = x + 1</code> mentions <code>x</code> twice, the left side <code>x</code> isn't evaluated. That is to say, not completely: its <em>value</em> is not computed. It is evaluated only to the extent of determining the location where the assigned value will go.</p>\n<p>So there is possibly a double evaluation of location here: the left side determines the location of <code>x</code> and so does the right side. But determining location doesn't involve accessing the location itself.</p>\n<p>For some kinds of expressions, determining the location does involve accessing values. For example:</p>\n<pre><code>a[i] = a[i] + 1;\n</code></pre>\n<p>This is quite different from</p>\n<pre><code>i = i + 1\n</code></pre>\n<p>because <code>i</code> is only a secondary variable here whose value must be known in order to determine the storage location of <code>a[i]</code> (and <code>i</code> isn't itself even being incremented). If <code>i</code> is <code>volatile</code>, then the two abstract accesses to it in <code>a[i] = a[i] + 1</code> must correspond to two actual accesses.</p>\n", "LastActivityDate": "2015-09-22T19:05:44.733", "Score": "0", "CreationDate": "2015-09-22T19:05:44.733", "ParentId": "32722789", "CommentCount": "0", "OwnerUserId": "1250772"}, "bq_ids": {"n4140": {"so_32722789_32723582_1": {"length": 7, "quality": 0.875, "section_id": 6179}, "so_32722789_32723582_0": {"length": 4, "quality": 1.0, "section_id": 744}}, "n3337": {"so_32722789_32723582_1": {"length": 7, "quality": 0.875, "section_id": 5940}, "so_32722789_32723582_0": {"length": 4, "quality": 1.0, "section_id": 750}}, "n4659": {"so_32722789_32723582_1": {"length": 7, "quality": 0.875, "section_id": 7681}, "so_32722789_32723582_0": {"length": 4, "quality": 1.0, "section_id": 802}}}});