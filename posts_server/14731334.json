post_cb({"14731410": {"ParentId": "14731334", "CommentCount": "0", "Body": "<p>Because that's what the standard says. <code>delete p;</code> is undefined behavior otherwise. </p>\n<h3>5.3.5 Delete [expr.delete]</h3>\n<blockquote>\n<p id=\"so_14731334_14731410_0\">3) In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete\n  array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>The reason it's like that is probably for it to be able to handle calling derived class destructors (like calling virtual functions) without adding overhead to classes that don't require it (i.e. don't make all classes polymorphic by introducing a <code>virtual</code> destructor by default just to handle this particular case).</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "14731410", "Score": "1", "CreationDate": "2013-02-06T14:25:54.370", "LastActivityDate": "2013-02-06T14:25:54.370"}, "14731374": {"ParentId": "14731334", "CommentCount": "0", "Body": "<p>For the same reason that you make other methods virtual.</p>\n<pre><code>Person *p;\n...\n\ndelete p;\n</code></pre>\n<p>wouldn't handle subclasses of <code>Person</code> properly if the destructor wasn't virtual. i.e. it would simply invoke the <code>Person</code> component and not the subclass component (e.g. <code>Employee</code>) </p>\n", "OwnerUserId": "12960", "PostTypeId": "2", "Id": "14731374", "Score": "2", "CreationDate": "2013-02-06T14:23:39.290", "LastActivityDate": "2013-02-06T14:23:39.290"}, "14731334": {"CommentCount": "0", "AcceptedAnswerId": "14731374", "ClosedDate": "2013-02-06T14:26:08.973", "CreationDate": "2013-02-06T14:21:55.873", "LastActivityDate": "2013-02-06T14:25:54.370", "PostTypeId": "1", "ViewCount": "78", "Title": "Non-virtual father class destructor", "Id": "14731334", "Score": "0", "Body": "<pre><code>class Person\n{\npublic:\n    Person(std::string&amp; name,long id) : name_(name), id_(id) {}\n    ~Person() {}\nprivate:\n    std::string&amp; name_;\n    long id_;\n};\n\nclass Student : public Person\n{\npublic:\n    Student(std::string&amp; name, long id) : Person(name,id) {}\n    Student(std::string&amp; name, long id, const std::vector&lt;int*&gt;&amp; courses) : Person(name,id), courses_(courses) {}\n    virtual ~Student() {\n        std::vector&lt;int*&gt;::iterator it;\n        for (it = courses_.begin(); it != courses_.end(); ++it)\n        delete (*it);\n    }\n    const std::vector&lt;int*&gt;&amp; getCourses() const { return courses_; }\nprivate:\n    std::vector&lt;int*&gt; courses_;\n};\n\nint main(){\n    std::string name(\"Rina\");\n    std::vector&lt;int*&gt; courses;\n    courses.push_back(new int(1345));\n    Person* p = new Student(name,37,courses);\n    Student* s = (Student*)p;\n    std::cout &lt;&lt; (*(s-&gt;getCourses().at(0)));\n    delete p;\n}\n</code></pre>\n<p>I understand that the</p>\n<pre><code>delete p;\n</code></pre>\n<p>makes us realize the problem that </p>\n<pre><code>~Person()\n</code></pre>\n<p>is not virtual. \nMy question is: why should </p>\n<pre><code>~Person() \n</code></pre>\n<p>be virtual?</p>\n", "Tags": "<c++>", "OwnerUserId": "1656647", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14731334_14731410_0": {"section_id": 6107, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_14731334_14731410_0": {"section_id": 5873, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_14731334_14731410_0": {"section_id": 7604, "quality": 0.9512195121951219, "length": 39}}}});