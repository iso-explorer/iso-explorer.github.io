post_cb({"27593837": {"ParentId": "27593001", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Each lambda is an unrelated type.  As it happens, they can all be converted to <code>std::function&lt;void()&gt;</code>, but that is because <code>std::function</code> will claim to convert anything, and it will work when they are invokable with <code>void()</code> signature and copyable and destructible.</p>\n<p>In the <code>vector</code> case, there is an <code>std::initializer_list&lt;std::function&lt;void()&gt;&gt;</code> constructor that is considered from its list of constructors.  This matches, is attempted, and compiles.</p>\n<p>Without that argument (the list argument to the vector ctor) to match, the <code>{}</code> syntax instead looks inside at its contents for a common type.  There is no common type, so it fails.</p>\n<p>The language does not search every type and template to find a possible common type between the two (unrelated) lambdas.  It will not read your mind.</p>\n<p>You can do:</p>\n<pre><code> using nullary = std::function&lt;void()&gt;;\n template&lt;class T&gt;\n using il=std::initializer_list&lt;T&gt;;\n for(auto f:il&lt;nullary&gt;{[]{ std::cout&lt;&lt;\"hello\";},[]{std::cout&lt;&lt;\" world\\n\";}}){\n   f();\n }\n</code></pre>\n", "OwnerUserId": "1774667", "LastEditorUserId": "27678", "LastEditDate": "2014-12-21T21:49:11.567", "Id": "27593837", "Score": "0", "CreationDate": "2014-12-21T21:06:52.963", "LastActivityDate": "2014-12-21T21:49:11.567"}, "27593064": {"ParentId": "27593001", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Each lambda has its own unique type. So you may not build std::initializer_list from lambdas of different types.</p>\n<p>According to the C++ Standard (5.1.2 Lambda expressions)</p>\n<blockquote>\n<p id=\"so_27593001_27593064_0\">3 The type of the lambda-expression (which is also <strong>the type of the\n  closure object) is a unique</strong>, unnamed nonunion class type \u2014 called the\n  closure type \u2014 whose properties are described below.</p>\n</blockquote>\n<p>Also</p>\n<blockquote>\n<p id=\"so_27593001_27593064_1\">6 The closure type for a non-generic lambda-expression with no\n  lambda-capture has a public non-virtual nonexplicit const conversion\n  function to pointer to function with C++ language linkage (7.5) having\n  the same parameter and return types as the closure type\u2019s function\n  call operator.</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-12-21T19:49:49.467", "Id": "27593064", "Score": "6", "CreationDate": "2014-12-21T19:42:30.707", "LastActivityDate": "2014-12-21T19:49:49.467"}, "27594299": {"ParentId": "27593001", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>One trick I learned <a href=\"https://stackoverflow.com/a/23597817/4224575\">here</a> is to use a retrospective cast. So with such a tool at hand : </p>\n<pre><code>template&lt;typename T&gt;\nstruct memfun_type \n{\n    using type = void;\n};\n\ntemplate&lt;typename Ret, typename Class, typename... Args&gt;\nstruct memfun_type&lt;Ret(Class::*)(Args...) const&gt;\n{\n    using type = std::function&lt;Ret(Args...)&gt;;\n};\n\ntemplate&lt;typename F&gt;\ntypename memfun_type&lt;decltype(&amp;F::operator())&gt;::type\nFFL(F const &amp;func) \n{ // Function from lambda !\n    return func;\n}\n</code></pre>\n<p>you <a href=\"http://coliru.stacked-crooked.com/a/4f832f8db1fee540\" rel=\"nofollow noreferrer\"><strong>could write</strong></a> something like this</p>\n<pre><code>vector&lt;function&lt;void()&gt;&gt; v = { FFL([]{cout &lt;&lt; \"foo\"; }), FFL([]{cout &lt;&lt; \"bar\"; }) };\n\nfor (auto&amp;&amp; a : v) a();\n</code></pre>\n", "OwnerUserId": "4224575", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:08.380", "Id": "27594299", "Score": "0", "CreationDate": "2014-12-21T22:08:20.667", "LastActivityDate": "2014-12-21T22:08:20.667"}, "27593001": {"CommentCount": "3", "AcceptedAnswerId": "27593064", "CreationDate": "2014-12-21T19:35:38.130", "LastActivityDate": "2014-12-22T00:28:05.573", "PostTypeId": "1", "ViewCount": "360", "FavoriteCount": "1", "Title": "Using an initializer list of lambdas in a range-based loop", "Id": "27593001", "Score": "6", "Body": "<p>With gcc 4.9 -std=c++14, I tried making a vector of lambdas:</p>\n<pre><code>vector&lt;function&lt;void ()&gt;&gt; v = {[]{cout &lt;&lt; \"foo\";}, []{cout &lt;&lt; \"bar\";}};\nfor (auto&amp;&amp; a: v) a();\n</code></pre>\n<p>And it worked pretty well. Then I tried passing the initializer list of lambdas to the range-based for directly:</p>\n<pre><code>for (auto&amp;&amp; a: {[]{cout &lt;&lt; \"foo\";}, []{cout &lt;&lt; \"bar\";}}) a();\n</code></pre>\n<p>And I got:</p>\n<pre><code>error: unable to deduce 'std::initializer_list&lt;auto&gt;&amp;&amp;' from '{&lt;lambda closure object&gt;main()::&lt;lambda()&gt;{}, &lt;lambda closure object&gt;main()::&lt;lambda()&gt;{}}'\n</code></pre>\n<p>Judging by the appearance of the error message, I made a wild guess that it is probably because \"<em>lambda closure object</em>\"s are built-in language terms, and not direct equivalents of std::function (so no real types).</p>\n<p>What is the deeper cause of this? Also, could this be implementation-related, or is such behavior dictated by the specification?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1717282", "AnswerCount": "4"}, "27594471": {"ParentId": "27593001", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Each lamdba has its own type, so compiler cannot deduced the type of the <code>initializer_list</code>.</p>\n<p>You have to tell which type you want:</p>\n<ul>\n<li><p>For each lambda:</p>\n<ul>\n<li><p>As your lambda doesn't capture variables, you may decay them to pointer to function with <code>+</code> as follow:</p>\n<pre><code>for (auto&amp;&amp; a: {+[]{std::cout &lt;&lt; \"foo\";}, +[]{std::cout &lt;&lt; \"bar\";}}) a();\n</code></pre></li>\n<li><p>using <code>function&lt;void()&gt;</code>:</p>\n<pre><code>for (auto&amp;&amp; a: {std::function&lt;void()&gt;([]{std::cout &lt;&lt; \"foo\";}),\n                std::function&lt;void()&gt;([]{std::cout &lt;&lt; \"bar\";})}) a();\n</code></pre></li>\n</ul></li>\n<li><p>For the initializer_list:</p>\n<pre><code>for (auto&amp;&amp; a: std::initializer_list&lt;std::function&lt;void()&gt;&gt;{\n                   []{std::cout &lt;&lt; \"foo\";}, \n                   []{std::cout &lt;&lt; \"bar\";}}) a();\n</code></pre></li>\n</ul>\n", "OwnerUserId": "2684539", "LastEditorUserId": "2684539", "LastEditDate": "2014-12-22T00:28:05.573", "Id": "27594471", "Score": "5", "CreationDate": "2014-12-21T22:32:55.387", "LastActivityDate": "2014-12-22T00:28:05.573"}, "bq_ids": {"n4140": {"so_27593001_27593064_1": {"section_id": 5965, "quality": 0.9615384615384616, "length": 25}, "so_27593001_27593064_0": {"section_id": 5962, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_27593001_27593064_1": {"section_id": 5734, "quality": 0.8461538461538461, "length": 22}, "so_27593001_27593064_0": {"section_id": 5731, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_27593001_27593064_1": {"section_id": 7456, "quality": 0.8076923076923077, "length": 21}, "so_27593001_27593064_0": {"section_id": 7451, "quality": 0.8947368421052632, "length": 17}}}});