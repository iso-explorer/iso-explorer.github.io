post_cb({"22111473": {"ParentId": "22111387", "LastEditDate": "2017-05-23T11:49:45.267", "CommentCount": "2", "CreationDate": "2014-03-01T07:25:00.403", "OwnerUserId": "213489", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "22111473", "Score": "6", "Body": "<p>I can't guarantee this is what is happening in your case, but it is related to something I've seen lately:</p>\n<p>You can't copy unique pointers, but you can move them.</p>\n<p>In C++11 you will get a default move constructor if you don't define a destructor, but if you define one the compiler doesn't have to provide the move constructor, in which case the code fails. (I know that Visual Studio won't do this, but on my Mac with Xcode I've still gotten the move constructor.)</p>\n<p>So, I think this is what is happening in your case. Try provide the destructor and the other constructors/assignment operators to see if it fixes things. (See the discussions on the <a href=\"https://stackoverflow.com/questions/4782757/rule-of-three-becomes-rule-of-five-with-c11\">rule of five</a>.)</p>\n", "LastActivityDate": "2014-03-01T07:25:00.403"}, "22111571": {"ParentId": "22111387", "LastEditDate": "2014-03-02T07:10:54.430", "CommentCount": "3", "CreationDate": "2014-03-01T07:34:14.830", "OwnerUserId": "948318", "LastEditorUserId": "948318", "PostTypeId": "2", "Id": "22111571", "Score": "5", "Body": "<p>According to the standard \"12.8.9 Copying and moving class objects [class.copy]\"</p>\n<blockquote>\n<p id=\"so_22111387_22111571_0\">If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if:</p>\n<ul>\n<li>X does not have a user-declared copy constructor, </li>\n<li>X does not have a user-declared copy assignment operator, </li>\n<li>X does not have a user-declared move assignment operator, </li>\n<li><strong>X does not have a user-declared destructor</strong>, and </li>\n<li>the move constructor would not be implicitly defined as deleted.</li>\n</ul>\n</blockquote>\n<p>So if a class doesn't have user-defined destructor a move-constructor will be declared. And according \"12.8.15\" of the standard, this will call move-constructor for <code>unique_ptr</code> class member:</p>\n<blockquote>\n<p id=\"so_22111387_22111571_1\">The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members.</p>\n</blockquote>\n<p>If a class has user-defined destructor, the move-constructor should be declared explicitly:</p>\n<pre><code>struct Foo {\n         std::unique_ptr &lt;int&gt; bar;\n\n         Foo() = default;\n         Foo(Foo&amp;&amp;) = default;\n\n         ~Foo (void) {} // This Line\n };\n</code></pre>\n", "LastActivityDate": "2014-03-02T07:10:54.430"}, "22111686": {"ParentId": "22111387", "LastEditDate": "2014-03-01T08:01:54.363", "CommentCount": "0", "CreationDate": "2014-03-01T07:47:27.033", "OwnerUserId": "471160", "LastEditorUserId": "471160", "PostTypeId": "2", "Id": "22111686", "Score": "1", "Body": "<p>Explicit destructor makes compiler not generate default move constructor and default assignement move operator, and those two are required by unique_ptr for ownership transfering. So you must implement those if you want to implement destructor:</p>\n<pre><code>Foo(){}\nFoo &amp;operator=(Foo &amp;&amp;o) {\n    if (this != &amp;o)\n        bar = std::move(o.bar);\n    return *this;\n}\nFoo(Foo &amp;&amp;o) : bar(std::move(o.bar)) {}\n</code></pre>\n<p>because <code>Foo</code> should not be copied, only moved I suggest also explicitly deleting copy constructor and assignment operator:</p>\n<pre><code>Foo(Foo const &amp;) = delete;\nFoo &amp;operator=(Foo const &amp;) = delete;  \n</code></pre>\n<p>[edit]</p>\n<p>Actually, it is better explained by <a href=\"http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29\" rel=\"nofollow\">rule of five</a> which can be easily found on google, if you implement any of the :</p>\n<pre><code>destructor\ncopy constructor\nmove constructor\ncopy assignment operator\nmove assignment operator\n</code></pre>\n<p>you should consider implementing all of them (or deleting), and this is especially true when using unique_ptr which makes use of move semantics.</p>\n<p>When you comment out destructor, then you enter <a href=\"http://isocpp.org/blog/2012/11/rule-of-zero\" rel=\"nofollow\">rule of zero</a>.</p>\n", "LastActivityDate": "2014-03-01T08:01:54.363"}, "22111387": {"CommentCount": "5", "ViewCount": "649", "PostTypeId": "1", "LastEditorUserId": "1877851", "CreationDate": "2014-03-01T07:16:13.107", "LastActivityDate": "2014-03-02T07:10:54.430", "Title": "Why does push_back succeed on a struct containing a unique_ptr unless that struct has a custom destructor?", "AcceptedAnswerId": "22111473", "LastEditDate": "2014-03-01T07:50:44.540", "Id": "22111387", "Score": "4", "Body": "<p>The following code compiles if and only if I remove Foo's custom destructor.</p>\n<pre><code>struct Foo {\n    std::unique_ptr &lt;int&gt; bar;\n    ~Foo (void) {} // This Line\n};\nstd::vector &lt;Foo&gt; foos;\nfoos.push_back (Foo ());\n</code></pre>\n<p>Here is what I think I understand about the situation:</p>\n<p>It fails because <code>unique_ptrs</code> cannot be copied, and <code>std::vector::push_back (thing)</code> calls the <code>thing's</code> copy constructor. If I write <code>Foo</code> a custom copy constructor which explicitly moves <code>bar</code>, then everything will be fine.</p>\n<p>However, disabling <code>This Line</code> will cause the code to compile.</p>\n<p>I thought that this should fail to compile even without <code>This Line</code>, because I'm still attempting to <code>push_back</code> a <code>unique_ptr</code>.</p>\n<p>Why does this succeed without the custom destructor, and why does adding the custom destructor cause it to fail?</p>\n<p><em>Edit: using <code>gcc -std=gnu++11</code> on Debian Linux 64-bit</em></p>\n", "Tags": "<c++><c++11><stl>", "OwnerUserId": "1877851", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_22111387_22111571_1": {"section_id": 464, "quality": 0.9166666666666666, "length": 11}, "so_22111387_22111571_0": {"section_id": 458, "quality": 1.0, "length": 12}}, "n3337": {"so_22111387_22111571_1": {"section_id": 455, "quality": 0.9166666666666666, "length": 11}, "so_22111387_22111571_0": {"section_id": 449, "quality": 1.0, "length": 12}}, "n4659": {"so_22111387_22111571_1": {"section_id": 487, "quality": 0.9166666666666666, "length": 11}, "so_22111387_22111571_0": {"section_id": 481, "quality": 1.0, "length": 12}}}});