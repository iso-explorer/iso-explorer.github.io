post_cb({"bq_ids": {"n4140": {"so_26168445_26169292_1": {"length": 13, "quality": 1.0, "section_id": 7124}, "so_26168445_26168445_0": {"length": 7, "quality": 0.875, "section_id": 7055}, "so_26168445_26168445_6": {"length": 42, "quality": 0.8235294117647058, "section_id": 7055}, "so_26168445_26169292_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 7124}, "so_26168445_26168445_3": {"length": 7, "quality": 1.0, "section_id": 7055}}, "n3337": {"so_26168445_26169292_1": {"length": 13, "quality": 1.0, "section_id": 6868}, "so_26168445_26168445_0": {"length": 7, "quality": 0.875, "section_id": 6799}, "so_26168445_26168445_6": {"length": 42, "quality": 0.8235294117647058, "section_id": 6799}, "so_26168445_26169292_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 6868}, "so_26168445_26168445_3": {"length": 7, "quality": 1.0, "section_id": 6799}}, "n4659": {"so_26168445_26169292_1": {"length": 13, "quality": 1.0, "section_id": 8625}, "so_26168445_26168445_0": {"length": 7, "quality": 0.875, "section_id": 8552}, "so_26168445_26168445_6": {"length": 42, "quality": 0.8235294117647058, "section_id": 8552}, "so_26168445_26169292_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 8625}, "so_26168445_26168445_3": {"length": 7, "quality": 1.0, "section_id": 8552}}}, "26168634": {"Id": "26168634", "PostTypeId": "2", "Body": "<p>I would say your interpretation is correct. When you uncomment <code>struct B{};</code>, the <code>struct B* p;</code> line will simply refer to that struct <code>A::B</code>.</p>\n<p>To answer your question why, when you leave <code>struct B {};</code> commented out, the name <code>struct B</code> is inserted into the global scope. I would say that's because the authors didn't want you to (somewhat) silently declare <code>B</code> as a member of <code>A</code> without using a <em>member-specification</em> for the name <code>B</code>.</p>\n", "LastActivityDate": "2014-10-02T19:57:53.483", "CommentCount": "0", "CreationDate": "2014-10-02T19:57:53.483", "ParentId": "26168445", "Score": "0", "OwnerUserId": "1782465"}, "26168445": {"ViewCount": "176", "Body": "<p>In the snippet below I can understand (from \u00a73.3.2/6 second bullet point) that the name <code>B</code> in the declaration <code>struct B* p;</code> is injected into the global namespace as a <em>class-name</em>.</p>\n<pre><code>struct A {\n //   struct B{};\n    int B;\n    struct B* p;\n};\n\nvoid f(B&amp;) {}\n\nint main()\n{\n    A a;\n    f(*a.p);\n}\n</code></pre>\n<p>\u00a73.3.2/6:</p>\n<blockquote>\n<p id=\"so_26168445_26168445_0\">The point of declaration of a class <strong>first</strong> declared in an\n  <em>elaborated-type-specifier</em> is as follows:</p>\n<ul>\n<li><p id=\"so_26168445_26168445_1\">for a declaration of the form</p>\n<p id=\"so_26168445_26168445_2\"><em>class-key</em> <em>attribute-specifier-seq</em> <em>opt</em> <em>identifier</em>;</p>\n<p id=\"so_26168445_26168445_3\">the <em>identifier</em> is declared to be a <em>class-name</em> in the scope that\n  contains the declaration, otherwise</p></li>\n<li><p id=\"so_26168445_26168445_4\">for an <em>elaborated-type-specifier</em> of the form</p>\n<p id=\"so_26168445_26168445_5\"><em>class-key</em> <em>identifier</em></p>\n<p id=\"so_26168445_26168445_6\">if the <em>elaborated-type-specifier</em> is used in the <em>decl-specifier-seq</em> or <em>parameter-declaration-clause</em> of a function defined in namespace scope, the <em>identifier</em> is declared as a\n  <em>class-name</em> in the namespace that contains the declaration; otherwise, except as a <em>friend</em> declaration, the <em>identifier</em> is\n  declared in the smallest namespace or block scope that contains the\n  declaration. [ <em>Note</em>: These rules also apply within templates. \u2014 <em>end\n  note</em> ] [ <em>Note</em>: Other forms of <em>elaborated-type-specifier</em> do not\n  declare a new name, and therefore must refer to an existing type-name.\n  See 3.4.4 and 7.1.6.3. \u2014 <em>end note</em> ]</p></li>\n</ul>\n</blockquote>\n<p>However if I uncomment the definition of <code>struct B{};</code> inside <code>struct A</code>, what I said earlier with regard to the injection of name <code>B</code> into the global namespace, doesn't occur anymore, as the code doesn't compile. I believe this has to do with the word <strong>first</strong> (emphasis mine) above, since now the <em>class-name</em> <code>B</code>, in the declaration <code>struct B* p;</code> is no more its first declaration <strong>in its declarative region</strong>. Am I correct saying this?</p>\n<p>Assuming my interpretation is correct, why is it that the <em>class-name</em> <code>B</code> is not injected in the global namespace in this case? Note that the nested class <code>struct B{};</code> will be hidden inside A in this case, i.e., even if we change the declaration of function <code>f</code> to <code>void f(A::B&amp;)</code> the code won't compile. </p>\n<p>There is still one other point that isn't clear to me: what made the implementers to decide for the class-name injection into the namespace, or block scope, containing the elaborated-type-specifier, in the second bullet point above? That is, why didn't they leave the class-name declaration inside the class scope?</p>\n", "AcceptedAnswerId": "26169292", "Title": "Is my interpretation of the word 'first' in \u00a73.3.2/6 correct?", "CreationDate": "2014-10-02T19:46:02.367", "Id": "26168445", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2014-10-02T20:00:31.267", "LastEditorUserId": "420683", "LastActivityDate": "2014-10-02T20:40:18.427", "Score": "3", "OwnerUserId": "2548699", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}, "26169292": {"Id": "26169292", "PostTypeId": "2", "Body": "<p>You're correct, that <em>first</em> keyword in \u00a73.3.2/6 is also the reason for the following:</p>\n<pre><code>struct A {\n    struct B *p;\n    struct B{};\n    int b;\n};\n\nvoid f(B* arg) {\n    std::cout &lt;&lt; std::is_same&lt;decltype(arg), A::B*&gt;::value; // not the same type\n}\n\nint main()\n{\n    A a;\n    f(a.p);\n}\n</code></pre>\n<blockquote>\n<p id=\"so_26168445_26169292_0\">why is it that the class-name B is not injected in the global namespace in this case?</p>\n</blockquote>\n<p>As dyp pointed out, [basic.lookup.elab]/2 explains that 3.3.2 is only carried out in case <strong>no previous declaration could be found</strong></p>\n<blockquote>\n<p id=\"so_26168445_26169292_1\">If the elaborated-type-specifier is introduced by the class-key and\n  this lookup does not find a previously declared type-name, or if the\n  elaborated-type-specifier appears in a declaration with the form:</p>\n<p id=\"so_26168445_26169292_2\">class-key attribute-specifier-seqopt identifier ; </p>\n<p id=\"so_26168445_26169292_3\">elaborated-type-specifier is a declaration that introduces the\n  class-name as described in 3.3.2.the</p>\n</blockquote>\n<p>Finally I tracked down this behavior to possibly be an inheritance from C99 6.7.2.3/p8</p>\n<blockquote>\n<p id=\"so_26168445_26169292_4\">If a type specifier of the form </p>\n<p id=\"so_26168445_26169292_5\">struct-or-union identifier </p>\n<p id=\"so_26168445_26169292_6\">occurs\n  other than as part of one of the above forms, and no other declaration\n  of the identifier as a tag is visible, then it declares an incomplete\n  structure or union type, and declares the identifier as the tag of\n  that type.113)</p>\n<p id=\"so_26168445_26169292_7\">113) A similar construction with enum does not exist.</p>\n</blockquote>\n", "LastActivityDate": "2014-10-02T20:40:18.427", "CommentCount": "1", "CreationDate": "2014-10-02T20:40:18.427", "ParentId": "26168445", "Score": "2", "OwnerUserId": "1938163"}});