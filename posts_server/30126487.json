post_cb({"30126712": {"ParentId": "30126487", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The first rule means that you can't make an overridden function return a <code>B</code> which has <code>const</code> or <code>volatile</code> if the <code>A</code> version does not:</p>\n<pre><code>struct A\n{\n    virtual A* foo() { return new A{}; }    \n};\n\nstruct B : A\n{\n    B* foo() override {return new B{}; }          //valid\n    const B* foo() override {return new B{}; }    //invalid\n    volatile B* foo() override {return new B{}; } //invalid\n};\n</code></pre>\n<p>This makes sense if the think about the call site:</p>\n<pre><code>A* my_b = new B{};\nA* new_b = my_b-&gt;foo(); //discards the const qualifier if B::foo() returns const B*\n</code></pre>\n<p>The second rule means that you can't have disparate reference or pointer types as covariant return types. Using the same example as above:</p>\n<pre><code>struct A\n{\n    virtual A* foo() { return new A{}; }    \n};\n\nstruct B : A\n{\n    B* foo() override {return new B{}; }   //valid\n    B&amp; foo() override {return new B{}; }   //invalid\n    B&amp;&amp; foo() override {return new B{}; }  //invalid\n};\n</code></pre>\n<p>Again, think about the call site:</p>\n<pre><code>A* my_b = new B{};\nA* new_b = my_b-&gt;foo(); //if B::foo() returns a reference, this line is syntactically ill-formed\n</code></pre>\n<p>Your example satisfies both rules because both return types have the same cv-qualification and are both lvalue references.</p>\n", "OwnerUserId": "496161", "LastEditorUserId": "3777958", "LastEditDate": "2015-05-08T15:43:31.473", "Id": "30126712", "Score": "4", "CreationDate": "2015-05-08T14:49:08.930", "LastActivityDate": "2015-05-08T15:43:31.473"}, "30126487": {"CommentCount": "1", "AcceptedAnswerId": "30126712", "PostTypeId": "1", "LastEditorUserId": "3777958", "CreationDate": "2015-05-08T14:38:33.217", "LastActivityDate": "2015-05-08T15:43:31.473", "LastEditDate": "2015-05-08T14:45:28.903", "ViewCount": "221", "FavoriteCount": "2", "Title": "C++ rules for covariant virtual function", "Id": "30126487", "Score": "1", "Body": "<p>I was reading <a href=\"http://www-01.ibm.com/support/knowledgecenter/SS2LWA_12.1.0/com.ibm.xlcpp121.bg.doc/language_ref/cplr139.html\" rel=\"nofollow\">Covariant virtual function</a>. It says that </p>\n<p>Suppose that B::f overrides the virtual function A::f. The return types of A::f and B::f may differ if all the following conditions are met: </p>\n<blockquote>\n<p id=\"so_30126487_30126487_0\">1) The const or volatile qualification of the pointer or reference\n  returned by B::f has the same or less const or volatile qualification\n  of the pointer or reference returned by A::f.</p>\n<p id=\"so_30126487_30126487_1\">2) A::f returns an lvalue reference if and only if B::f returns an\n  lvalue reference.</p>\n<p id=\"so_30126487_30126487_2\">3) The function B::f returns a pointer or a reference to a class of\n  type T, and A::f returns a pointer or a reference to an unambiguous\n  direct or indirect base class of T.</p>\n<p id=\"so_30126487_30126487_3\">4) The return type of B::f must be complete at the point of declaration of B::f,  or it can be of type B</p>\n</blockquote>\n<p>Will someone explain the above 2 rules by giving suitable example? What exactly these 2 rules mean?Is the second rule is applicable from C++11?\nIs the following example satisfies 1st rule I've said here?</p>\n<pre><code>#include &lt;iostream&gt;\nclass Base {\n    public:\n        virtual const Base&amp; fun() const\n        {\n            std::cout&lt;&lt;\"fun() in Base\\n\";\n            return *this;\n        }\n        virtual ~Base()\n        { }\n    private:\n        int a=3;\n};\nclass Derived : public Base\n{\n        const Derived&amp; fun() const\n        {\n            std::cout&lt;&lt;\"fun() in Derived\\n\";\n            return *this;\n        }\n};\nint main(){\n    Base* p=new Derived();\n    p-&gt;fun();\n    delete p;\n    return 0;\n}\n</code></pre>\n<p>Please correct me If I am wrong somewhere.I am confused in first 2 rules.</p>\n<p>Thanks</p>\n<p>Your help will be highly appreciated.</p>\n", "Tags": "<c++><c++11><virtual-functions>", "OwnerUserId": "3777958", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30126487_30126487_2": {"section_id": 6126, "quality": 0.5333333333333333, "length": 8}, "so_30126487_30126487_3": {"section_id": 7009, "quality": 0.6666666666666666, "length": 6}, "so_30126487_30126487_1": {"section_id": 57, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_30126487_30126487_2": {"section_id": 5890, "quality": 0.5333333333333333, "length": 8}, "so_30126487_30126487_3": {"section_id": 6755, "quality": 0.6666666666666666, "length": 6}, "so_30126487_30126487_1": {"section_id": 52, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_30126487_30126487_1": {"section_id": 59, "quality": 0.6666666666666666, "length": 4}, "so_30126487_30126487_2": {"section_id": 7623, "quality": 0.5333333333333333, "length": 8}, "so_30126487_30126487_3": {"section_id": 8506, "quality": 0.6666666666666666, "length": 6}}}});