post_cb({"46448723": {"ParentId": "46448673", "CommentCount": "8", "Body": "<p>You can use the <code>sizeof</code> operator directly on your <code>std::array</code> instance:</p>\n<pre><code>sizeof(arr)\n</code></pre>\n<p>Example:</p>\n<pre><code>struct foo\n{\n    int a;\n    char b;\n};\n\nint main()\n{\n    std::array&lt;foo, 10&gt; a;\n    static_assert(sizeof(foo) == 8);\n    static_assert(sizeof(a) == 80);\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/WhjbGfKu2LTn42Xn\" rel=\"noreferrer\"><strong>live example on wandbox</strong></a></p>\n<hr>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_46448673_46448723_0\"><code>std::array</code> is a container that encapsulates fixed size arrays.</p>\n<p id=\"so_46448673_46448723_1\">This container is an <em>aggregate type</em> with the same semantics as a <code>struct</code> holding a C-style array <code>T[N]</code> as its only non-static data member. </p>\n</blockquote>\n</hr>", "OwnerUserId": "598696", "PostTypeId": "2", "Id": "46448723", "Score": "5", "CreationDate": "2017-09-27T13:07:00.663", "LastActivityDate": "2017-09-27T13:07:00.663"}, "46488179": {"ParentId": "46448673", "CommentCount": "0", "Body": "<p>Since no one has posted anything better than my first guess in question and <code>sizeof(arr)</code> is most likely <strong>NOT guaranteed to not include</strong> the size of any possible additional <code>std::array's</code> fields I'm choosing this as the accepted answer.</p>\n<pre><code>arr.size() * sizeof(arr.value_type)\n</code></pre>\n<p>Should anyone come up with anything better I'd be happy to accept their answer instead.</p>\n", "OwnerUserId": "1030598", "PostTypeId": "2", "Id": "46488179", "Score": "0", "CreationDate": "2017-09-29T11:48:43.833", "LastActivityDate": "2017-09-29T11:48:43.833"}, "46449710": {"ParentId": "46448673", "CommentCount": "3", "Body": "<p>There's no guarantee that <code>sizeof(std::array&lt;T,N&gt;) == N*sizeof(T)</code>, but it is guaranteed that <code>sizeof(std::array&lt;T,N&gt;) &gt;= N*sizeof(T)</code>. The extra size might be named (but unspecified) members and/or unnamed padding. </p>\n<p>The guarantee follows from the fact that the wrapped <code>T[N]</code> array must be the first member of <code>std::array&lt;T,N&gt;</code>, but other members aren't specified.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "46449710", "Score": "2", "CreationDate": "2017-09-27T13:53:21.753", "LastActivityDate": "2017-09-27T13:53:21.753"}, "46452913": {"ParentId": "46448673", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I have understood that you were asking: what is the size of the memory occupied by the ensemble of the element of an <code>array&lt;value_type,N&gt; arr</code>, that is between <code>arr.begin()</code> and <code>arr.end()</code>?</p>\n<p>The answer is <code>sizeof(value_type)*N</code>, this is stated in the standard, but it needs some processing to get to this conclusion.</p>\n<p>In the C++ standard [dcl.array] (this is about (c-)array not <code>std::array</code>):</p>\n<blockquote>\n<p id=\"so_46448673_46452913_0\">An object of array type contains a contiguously allocated non-empty set of N subobjects of type T.</p>\n</blockquote>\n<p>in [expr.add] (here also term array refers to (c-)array):</p>\n<blockquote>\n<p id=\"so_46448673_46452913_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type\n  of the pointer operand. If the expression P points to element x[i] of an array object x with n elements, 86\n  the expressions P + J and J + P (where J has the value j) point to the (possibly-hypothetical) element\n  x[i + j] if 0 \u2264 i + j \u2264 n; otherwise, the behavior is undefined. Likewise, the expression P - J points to the\n  (possibly-hypothetical) element x[i \u2212 j] if 0 \u2264 i \u2212 j \u2264 n; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>And in [array.data] (here the term array refers to <code>std::array</code>):</p>\n<pre><code>constexpr T* data() noexcept;\nconstexpr const T* data() const noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_46448673_46452913_2\"><em>Returns</em>: A pointer such that data() == addressof(front()), and [data(), data() + size()) is\n  a valid range.</p>\n</blockquote>\n<p>So <code>data()</code> return a valid range to the element of the <code>std::array</code>, this range is iterable using a pointer to the value_type, so it follows pointer arithmetic which follows rule for (c-)array indexing, and elements of a (c-)array are contiguous. Q.E.D.</p>\n", "OwnerUserId": "5632316", "LastEditorUserId": "5632316", "LastEditDate": "2017-09-27T16:51:45.127", "Id": "46452913", "Score": "0", "CreationDate": "2017-09-27T16:29:48.637", "LastActivityDate": "2017-09-27T16:51:45.127"}, "46449819": {"ParentId": "46448673", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Read <a href=\"http://en.cppreference.com/w/cpp/container/array\" rel=\"nofollow noreferrer\">documentation of <code>std::array</code></a>. So yes, it probably is. Or try perhaps</p>\n<pre><code>  (arr.size()-1) * sizeof(arr.value_type) + sizeof(std::array&lt;T,1&gt;)\n</code></pre>\n<p>But I would just use <code>sizeof(arr)</code></p>\n<p>BTW, I am not sure that you have any formal guarantee about that. I guess that the standard would theoretically allow <code>std::array</code> to be the same as <code>std::vector</code>, except that <code>resize()</code> and some other methods would be hidden. But no sane implementation would do that (since <code>std::array</code> has been invented to pack plain  arrays in a container similar to vectors).</p>\n<p>Perhaps an implementation which only allow <code>std::array</code>-s of at most two elements (but throw some exception otherwise) could be conforming to the letter of the standard.</p>\n", "OwnerUserId": "841108", "LastEditorUserId": "841108", "LastEditDate": "2017-09-27T14:05:15.013", "Id": "46449819", "Score": "0", "CreationDate": "2017-09-27T13:58:02.793", "LastActivityDate": "2017-09-27T14:05:15.013"}, "46448673": {"CommentCount": "7", "ViewCount": "182", "PostTypeId": "1", "LastEditorUserId": "1030598", "CreationDate": "2017-09-27T13:04:31.393", "LastActivityDate": "2017-09-29T11:48:43.833", "Title": "Simplest way to get memory size of std::array's underlying array?", "LastEditDate": "2017-09-27T14:45:30.833", "Id": "46448673", "Score": "5", "Body": "<p>Is this the simplest/shortest way to get size in memory of the content of what <code>std::array::data()</code> returns?</p>\n<pre><code>arr.size() * sizeof(arr.value_type)\n</code></pre>\n<p>Edit: My question wasn't precise. By \"size in memory\" I mean size of all elements (themselves) contained in the array so if e.g. they are pointers pointing to structures, I want the size of the pointers alone, not the structures pointed to. I also don't want to include the size of any possible overhead of the <code>std::arr</code> implementation. Just the array elements.</p>\n<p>Some people suggested <code>sizeof(arr)</code>. This: <a href=\"https://stackoverflow.com/questions/25173462/what-is-the-sizeof-stdarraychar-n\">What is the sizeof std::array&lt;char, N&gt;?</a> begs to disagree. And while it seems to work <strong>on my machine</strong> I want to know what the standard guarantees.</p>\n", "Tags": "<c++><sizeof><stdarray>", "OwnerUserId": "1030598", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_46448673_46452913_1": {"section_id": 6142, "quality": 0.7647058823529411, "length": 26}, "so_46448673_46452913_0": {"section_id": 3228, "quality": 1.0, "length": 10}}, "n3337": {"so_46448673_46452913_1": {"section_id": 5906, "quality": 0.7647058823529411, "length": 26}, "so_46448673_46452913_0": {"section_id": 3101, "quality": 1.0, "length": 10}}, "n4659": {"so_46448673_46452913_2": {"section_id": 844, "quality": 0.7, "length": 7}, "so_46448673_46452913_0": {"section_id": 3985, "quality": 1.0, "length": 10}, "so_46448673_46452913_1": {"section_id": 7638, "quality": 1.0, "length": 34}}}});