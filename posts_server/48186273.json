post_cb({"48187250": {"Score": "2", "CreationDate": "2018-01-10T12:12:49.187", "LastEditDate": "2018-01-10T12:18:08.657", "LastActivityDate": "2018-01-10T12:18:08.657", "LastEditorUserId": "9188290", "Body": "<blockquote>\n<p id=\"so_48186273_48187250_0\">accessing is ok, but what can be asserted about the value? And for\n  exemple I make a store through the object name, then a store through\n  the aliasing pointer and then a load through the object name, is there\n  no risk the compiler optimize away the last load and reflect it by an\n  immediate which would equal the first store?</p>\n</blockquote>\n<p>Access is defined in <a href=\"https://timsong-cpp.github.io/cppwp/defns.access#:access\" rel=\"nofollow noreferrer\">[defns.access]</a> to mean:</p>\n<blockquote>\n<p id=\"so_48186273_48187250_1\">read or modify the value of an object</p>\n</blockquote>\n<p>So modifying the value via <code>*alias_to_array_s='Y';</code> is just as acceptable as reading it.</p>\n<p>The compiler is allowed to optimize load/stores via the as-if rule. Your program doesn't have any observable behavior. If the assert passes, the compiler is free to replace <code>g()</code> with an empty body and not call it at all. If you are really worried about the compiler reordering the load/stores, you should be using <code>volatile</code> or look into memory barriers.</p>\n", "Id": "48187250", "PostTypeId": "2", "ParentId": "48186273", "OwnerUserId": "9188290", "CommentCount": "0"}, "bq_ids": {"n4659": {"so_48186273_48187250_1": {"length": 4, "section_id": 7225, "quality": 1.0}}}, "48186273": {"Tags": "<c++><language-lawyer><c++17><strict-aliasing>", "ViewCount": "75", "LastEditDate": "2018-01-10T11:39:20.097", "CreationDate": "2018-01-10T11:18:39.703", "LastEditorUserId": "5632316", "Title": "Object access through an unsigned char alias, what happens on load and on store?", "CommentCount": "10", "AcceptedAnswerId": "48187250", "Score": "2", "AnswerCount": "2", "Id": "48186273", "LastActivityDate": "2018-01-10T12:18:08.657", "Body": "<p>In the following example, the array is not accessed through its first element but by what is conceptually an alias of the array. Nevertheless, accordingly to C++17/<a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.lval#8\" rel=\"nofollow noreferrer\">[basic.lval]/8</a> the stored value of an object can be accessed through an unsigned char. So is it right to think that the following assertion will never fire?</p>\n<pre><code>void g(){\n  unsigned char s[]={'X'};\n  unsigned char (*pointer_to_array_s)[1] = &amp;s;\n  unsigned char *alias_to_array_s = \n      reinterpret_cast&lt;unsigned char*&gt;(pointer_to_array_s);\n  //alias_to_array_s is not a pointer whose value point to c[0] because an array \n  //and its firts element are not pointer interconvertible see [basic.compound]\n  //*alias_to_array_s aliases s;\n  assert(*alias_to_array_s=='X'); //may fire?\n  }\n</code></pre>\n<p>The fact the <code>alias_to_array_s</code> is not a valid pointer to the first element of <code>s</code> is due to a subtlety introduced in C++17, see this <a href=\"https://stackoverflow.com/questions/48062346/is-a-pointer-with-the-right-address-and-type-still-always-a-valid-pointer-since\">Q&amp;A</a>.</p>\n<p>Now let's suppose that I modify the array through the alias, can I retrieve this modification by directly accessing the array?  </p>\n<pre><code>void g(){\n  unsigned char s[]={'X'};\n  unsigned char (*pointer_to_array_s)[1] = &amp;s;\n  unsigned char *alias_to_array_s = \n      reinterpret_cast&lt;unsigned char*&gt;(pointer_to_array_s);\n  *alias_to_array_s='Y'; //UB?\n  assert(s[0]=='Y');//may fire?\n  }\n</code></pre>\n", "PostTypeId": "1", "OwnerUserId": "5632316"}, "48187020": {"Score": "1", "CreationDate": "2018-01-10T12:00:05.290", "Id": "48187020", "LastActivityDate": "2018-01-10T12:00:05.290", "ParentId": "48186273", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/object\" rel=\"nofollow noreferrer\">these</a> criteria, arrays are objects and objects can be inspected through <code>unsigned char</code> pointers and references. Let's break down your code.</p>\n<p>Firstly, we declare an array of <code>unsigned char</code> of size 1.</p>\n<pre><code>unsigned char s[]={'X'};\n</code></pre>\n<p>We create a pointer to <code>unsigned char[1]</code>. This is the same type as <code>s</code> so we're fine.</p>\n<pre><code>unsigned char (*pointer_to_array_s)[1] = &amp;s;\n</code></pre>\n<p>Now this is the tricky part. Your comment implies that the next conversion would make <code>alias_to_array_s</code> point to the first member of <code>s</code>, which is potentially UB. However, <code>s</code> is an object and its pointer can be <code>reinterpret_cast</code> to <code>char</code>, <code>unsigned char</code> or <code>std::byte</code> in order to inspect its representation. Therefore the next line is well defined as creating a pointer to the first byte of <code>s</code>'s representation.</p>\n<pre><code>unsigned char *alias_to_array_s = \n    reinterpret_cast&lt;unsigned char*&gt;(pointer_to_array_s);\n</code></pre>\n<p>Your other example of modifying <code>s</code> through <code>alias_to_array_s</code> should also be fine, because you're modifying the first byte of the object's representation. In the case of <code>unsigned char[]</code> that is the first element. The important point here is that you did not convert a pointer-to-array to a pointer-to-first-element. You cast a pointer-to-array to <code>unsigned char *</code> to inspect its representation.</p>\n", "PostTypeId": "2", "CommentCount": "0", "OwnerUserId": "4341534"}});