post_cb({"4582515": {"Id": "4582515", "PostTypeId": "2", "Body": "<p>C style cast is always better than reinterpret_cast.</p>\n<p>If C style cast work, it is valid platform independently.</p>\n<p>Always avoid reinterpret_cast.</p>\n<p><strong>EDITED</strong></p>\n<p>I mean, with reinterpret_cast you could point wrong memory address, C style cast handle all the platform related issues such as ABI, memory align, pointer size, etc.</p>\n<p><strong>EDITED</strong>\nBy the inspiration of commentators, I've read ISO/IEC 14882:2003 section 5.2.10 \"Reinterpret_cast\".</p>\n<p>Of course my comprehension is limited, but it strikes me to remember why I hated reinterpret_cast in the first place.</p>\n<p>I think, reinterpret_cast is lack of or has very limited awareness of inheritance hierarchy.</p>\n<p>If cast operand is a instance pointer of class which has complicated inheritance hierarchy (such as ATL/COM classes), one reinterpret_cast is enough to kill you process with  incomprehensible errors.</p>\n<p>We can use C style cast with vague knowledge of actual cast operation behind. But we must really know exact detail to use reinterpret_cast safely.</p>\n", "LastEditorUserId": "558502", "LastActivityDate": "2011-01-04T15:25:11.680", "Score": "-1", "CreationDate": "2011-01-03T06:37:26.873", "ParentId": "4582346", "CommentCount": "18", "OwnerUserId": "558502", "LastEditDate": "2011-01-04T15:25:11.680"}, "4582391": {"Id": "4582391", "PostTypeId": "2", "Body": "<p>You should not use reinterpret_cast there. Actually you should not mention usage of reinterpret_cast anywhere where your goal is portability. reinterpret_cast is by definition something that has platform-specific results.</p>\n<p>For casting a pointer to base into pointer of derived class use dynamic_cast, it will return NULL when the object pointed is not of derived class. If you are absolutely sure that the class is correct then you may use static_cast.  </p>\n", "LastActivityDate": "2011-01-03T06:06:12.860", "CommentCount": "6", "CreationDate": "2011-01-03T06:06:12.860", "ParentId": "4582346", "Score": "2", "OwnerUserId": "528720"}, "4582346": {"ViewCount": "883", "Body": "<p>I've been refreshing/updating my knowledge of C++ lately, and learning about strict aliasing has made me a bit wary of casting pointers of one type to another.  I know that this following code sample works in practice on my compiler, but I want to make sure that it conforms to current standards:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass MyBase {\n\n    public:\n    virtual void DoSomething() = 0;\n\n};\n\nclass MyDerived1 : public MyBase {\n\n    public:\n    virtual void DoSomething() {\n        cout &lt;&lt; \"I'm #1\" &lt;&lt; endl;\n    }\n\n};\n\nclass MyDerived2 : public MyBase {\n\n    public:\n    virtual void DoSomething() {\n        cout &lt;&lt; \"I'm #2\" &lt;&lt; endl;\n    }\n\n};\n\ntemplate &lt;typename Base, typename Member1, typename Member2&gt;\nstruct Tuple {\n\n    public:\n    Base* Get(int i) {\n        return &amp;(this-&gt;*(lookupTable[i]));\n    }\n\n    private:\n    Member1 member1;\n    Member2 member2;\n\n    static Base Tuple::* const lookupTable[2];\n\n};\n\ntemplate &lt;typename Base, typename Member1, typename Member2&gt;\nBase Tuple&lt;Base, Member1, Member2&gt;::* const Tuple&lt;Base, Member1, Member2&gt;::lookupTable[2] = {\n    reinterpret_cast&lt;Base Tuple&lt;Base, Member1, Member2&gt;::*&gt;(&amp;Tuple::member1),\n    reinterpret_cast&lt;Base Tuple&lt;Base, Member1, Member2&gt;::*&gt;(&amp;Tuple::member2)\n};\n\nint main() {\n\n    Tuple&lt;MyBase, MyDerived1, MyDerived2&gt; tuple;\n\n    tuple.Get(0)-&gt;DoSomething();\n    tuple.Get(1)-&gt;DoSomething();\n\n    return 0;\n\n}\n</code></pre>\n<p>Essentially, this simple tuple contains a pair of elements, each of which should derive from a common base class.  The Get function returns a <code>Base*</code> to the member that the given index represents.</p>\n<p>The key part that I'm wondering about is the reinterpret_casts.  I know that casting from <code>Derived Struct::*</code> to <code>Base Struct::*</code> is <em>generally</em> a no-no, but in this case I only use the pointers-to-member-variable to get a <em>pointer</em> to the object.  (I don't try to copy a derived object as though it were a base object, nor stuff a base object into a derived object's memory.)  This works as intended on G++, and I just want to be sure that I'm not going to get bitten by any compliant compilers for doing this.</p>\n", "AcceptedAnswerId": "4588386", "Title": "Is it okay to cast a pointer-to-member-variable in this instance?", "CreationDate": "2011-01-03T05:54:43.527", "Id": "4582346", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-01-04T15:25:11.680", "Score": "1", "OwnerUserId": "276606", "Tags": "<c++><pointers><casting><member><strict-aliasing>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_4582346_4582487_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 6049}, "so_4582346_4582487_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 6049}, "so_4582346_4582487_1": {"length": 19, "quality": 0.95, "section_id": 6049}}, "n3337": {"so_4582346_4582487_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 5817}, "so_4582346_4582487_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 5817}, "so_4582346_4582487_1": {"length": 19, "quality": 0.95, "section_id": 5817}}, "n4659": {"so_4582346_4582487_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 7548}, "so_4582346_4582487_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 7548}, "so_4582346_4582487_1": {"length": 19, "quality": 0.95, "section_id": 7548}}}, "4582487": {"Id": "4582487", "PostTypeId": "2", "Body": "<p>EDIT: Reference from standard. If I'm reading it right, as you don't meet either of the exceptions, what you've done is unspecified and so may or may not work on any particular compiler. There aren't any exceptions for the type of the member being related.</p>\n<p>From 5.2.10/9 (reinterpret_cast):</p>\n<blockquote>\n<p id=\"so_4582346_4582487_0\">An rvalue of type \u201cpointer to member\n  of X of type T1\u201d can be explicitly\n  converted to an rvalue of type\n  \u201cpointer to member of Y of type T2\u201d if\n  T1 and T2 are both function types or\n  both object types.66) The null member\n  pointer value (4.11) is converted to\n  the null member pointer value of the\n  destination type. The result of this\n  conversion is unspecified, except in\n  the following cases:</p>\n<p id=\"so_4582346_4582487_1\">\u2014 converting an\n  rvalue of type \u201cpointer to member\n  function\u201d to a different pointer to\n  member function type and back to its\n  original type yields the original\n  pointer to member value.</p>\n<p id=\"so_4582346_4582487_2\">\u2014 converting\n  an rvalue of type \u201cpointer to data\n  member of X of type T1\u201d to the type\n  \u201cpointer to data member of Y of type\n  T2\u201d (where the alignment requirements\n  of T2 are no stricter than those of\n  T1) and back to its original type\n  yields the original pointer to member\n  value.</p>\n</blockquote>\n", "LastEditorUserId": "251738", "LastActivityDate": "2011-01-03T20:34:50.513", "Score": "0", "CreationDate": "2011-01-03T06:28:35.933", "ParentId": "4582346", "CommentCount": "1", "OwnerUserId": "251738", "LastEditDate": "2011-01-03T20:34:50.513"}, "4588386": {"Id": "4588386", "PostTypeId": "2", "Body": "<p>Use of <code>reinterpret_cast</code> is almost never portable.  On top of that, the <em>only</em> valid use of pointer to member casts are the implicit cast from <code>Type Derived::*</code> to <code>Type Base::*</code> and careful uses of the <code>static_cast</code> from <code>Type Base::*</code> to <code>Type Derived::*</code>.  Since you want to change the type of the member, not the type of the object containing members, this is neither of those.</p>\n<p>How about putting tiny functions in that array instead of pointers to members?  The following code is tested and should be entirely portable.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass MyBase {\n\n    public:\n    virtual void DoSomething() = 0;\n\n};\n\nclass MyDerived1 : public MyBase {\n\n    public:\n    virtual void DoSomething() {\n        cout &lt;&lt; \"I'm #1\" &lt;&lt; endl;\n    }\n\n};\n\nclass MyDerived2 : public MyBase {\n\n    public:\n    virtual void DoSomething() {\n        cout &lt;&lt; \"I'm #2\" &lt;&lt; endl;\n    }\n\n};\n\ntemplate &lt;typename Base, typename Member1, typename Member2&gt;\nstruct Tuple {\n\n    public:\n    Base* Get(int i) {\n        return &amp;(this-&gt;*lookupTable[i])();\n    }\n\n    private:\n    Member1 member1;\n    Member2 member2;\n\n    template &lt;typename MemType, MemType Tuple::*member&gt;\n    Base&amp; GetMember() { return this-&gt;*member; }\n\n    typedef Base&amp; (Tuple::*get_member_func)();\n    static const get_member_func lookupTable[2];\n\n};\n\ntemplate &lt;typename Base, typename Member1, typename Member2&gt;\nconst typename Tuple&lt;Base, Member1, Member2&gt;::get_member_func\nTuple&lt;Base, Member1, Member2&gt;::lookupTable[2] = {\n    &amp;Tuple::GetMember&lt;Member1, &amp;Tuple::member1&gt;,\n    &amp;Tuple::GetMember&lt;Member2, &amp;Tuple::member2&gt;\n};\n\nint main() {\n\n    Tuple&lt;MyBase, MyDerived1, MyDerived2&gt; tuple;\n\n    tuple.Get(0)-&gt;DoSomething();\n    tuple.Get(1)-&gt;DoSomething();\n\n    return 0;\n\n}\n</code></pre>\n", "LastActivityDate": "2011-01-03T21:08:34.847", "CommentCount": "1", "CreationDate": "2011-01-03T21:08:34.847", "ParentId": "4582346", "Score": "1", "OwnerUserId": "459640"}});