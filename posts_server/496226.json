post_cb({"496324": {"Id": "496324", "PostTypeId": "2", "Body": "<p><code>char [100]</code> is a complex type of 100 adjacent <code>char</code>'s, whose <code>sizeof</code> equals to 100.</p>\n<p>Being casted to a pointer (<code>(void*) a</code>), this variable yields the address of the first <code>char</code>.</p>\n<p>Reference to the variable of this type (<code>&amp;a</code>) yields address of the whole variable, which, in turn, also happens to be the address of the first <code>char</code></p>\n", "OwnerDisplayName": "Quassnoi", "LastActivityDate": "2009-01-30T17:06:34.473", "Score": "0", "CreationDate": "2009-01-30T17:06:34.473", "ParentId": "496226", "CommentCount": "0", "OwnerUserId": "55159"}, "496287": {"Id": "496287", "PostTypeId": "2", "Body": "<p>Sorry, a tiny bit off topic:</p>\n<p>This reminded me of an article I read about 8 years ago when I was coding C full time.  I can't find the article but I think it was titled \"arrays are not pointers\" or something like that.  Anyway, I did come across this <a href=\"http://www.lysator.liu.se/c/c-faq/c-2.html\" rel=\"nofollow noreferrer\">C arrays and pointers FAQ</a> which is interesting reading.</p>\n", "OwnerDisplayName": "ng5000", "LastActivityDate": "2009-01-30T16:57:20.077", "Score": "4", "CreationDate": "2009-01-30T16:57:20.077", "ParentId": "496226", "CommentCount": "1", "OwnerUserId": "36860"}, "496263": {"Body": "<p>Well, the <code>&amp;a</code> case should be obvious. You take the address of the array, exactly as expected.\n<code>a</code> is a bit more subtle, but the answer is that <code>a</code> <em>is</em> the array. And as any C programmer knows, arrays have a tendency to degenerate into a pointer at the slightest provocation, <em>for example</em> when passing it as a function parameter.</p>\n<p>So <code>scanf(\"%s\", a)</code> expects a pointer, not an array, so the array degenerates into a pointer to the first element of the array.</p>\n<p>Of course <code>scanf(\"%s\", &amp;a)</code> works too, because that's explicitly the address of the array.</p>\n<p><em>Edit:</em> Oops, looks like I totally failed to consider what argument types scanf actually expects. Both cases yield a pointer to the same address, but of different types. (pointer to char, versus pointer to array of chars).</p>\n<p>And I'll gladly admit I don't know enough about the semantics for ellipsis (...), which I've always avoided like the plague, so looks like the conversion to whichever type scanf ends up using may be undefined behavior. Read the comments, and litb's answer. You can usually trust him to get this stuff right. ;)</p>\n", "CreationDate": "2009-01-30T16:52:01.863", "ParentId": "496226", "CommentCount": "6", "LastEditDate": "2009-01-30T20:42:55.470", "PostTypeId": "2", "LastEditorDisplayName": "jalf", "LastActivityDate": "2009-01-30T20:42:55.470", "LastEditorUserId": "33213", "Id": "496263", "OwnerDisplayName": "jalf", "Score": "18", "OwnerUserId": "33213"}, "496312": {"Body": "<p>Well, scanf expects a char* pointer as the next argument when seeing a \"%s\". But what you give it is a pointer to a char[100]. You give it a <code>char(*)[100]</code>. It's not guaranteed to work at all, because the compiler may use a different representation for array pointers of course. If you turn on warnings for gcc, you will see also the proper warning displayed.</p>\n<p>When you provide an argument object that is an argument not having a listed parameter in the function (so, as in the case for scanf when has the vararg style \"...\" arguments after the format string), the array will degenerate to a pointer to its first element. That is, the compiler will create a <code>char*</code> and pass that to printf.</p>\n<p>So, <strong>never do it with <code>&amp;a</code></strong> and pass it to scanf using \"%s\". Good compilers, as comeau, will warn you correctly:</p>\n<blockquote>\n<p id=\"so_496226_496312_0\">warning: argument is incompatible with corresponding format string conversion</p>\n</blockquote>\n<p>Of course, the <code>&amp;a</code> and <code>(char*)a</code> <em>have</em> the same address stored. But that does not mean you can use <code>&amp;a</code> and <code>(char*)a</code> interchangeably.</p>\n<hr>\n<p>Some Standard quotes to especially show how pointer arguments are <em>not</em> converted to <code>void*</code> auto-magically, and how the whole thing is undefined behavior. </p>\n<blockquote>\n<p id=\"so_496226_496312_1\">Except when it is the operand of the sizeof operator or the unary &amp; operator, or is a\n  string literal used to initialize an array, an expression that has type <em>\u2018\u2018array of type\u2019\u2019 is converted</em> to an expression with type <em>\u2018\u2018pointer to type\u2019\u2019</em> that points to the initial element of the array object. (<code>6.3.2.1/3</code>)</p>\n</blockquote>\n<p>So, that is done always - it isn't mentioned below explicitly anymore when listening valid cases when types may differ.</p>\n<blockquote>\n<p id=\"so_496226_496312_2\">The ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default argument promotions are performed on trailing arguments. (<code>6.5.2.2/7</code>)</p>\n</blockquote>\n<p>About how <code>va_arg</code> behaves extracting the arguments passed to printf, which is a vararg function, emphasis added by me (<code>7.15.1.1/2</code>):</p>\n<blockquote>\n<p id=\"so_496226_496312_3\">Each invocation of the va_arg macro modifies ap so that the\n  values of successive arguments are returned in turn. The parameter type shall be a type\n  name specified such that the type of a pointer to an object that has the specified type can be obtained simply by post\ufb01xing a <code>*</code> to type. If there is no actual next argument, or if type is not compatible with the type of the actual next argument (as promoted according to the default argument promotions), the <em>behavior is undefined</em>, except for the following cases:  </p>\n<ul>\n<li>one type is a signed integer type, the other type is the corresponding unsigned integer\n  type, and the value is representable in both types;</li>\n<li>one type is <em>pointer to void</em> and the other is a pointer to a <em>character type</em>.</li>\n</ul>\n</blockquote>\n<p>Well, here is what that <em>default argument promotion</em> is:</p>\n<blockquote>\n<p id=\"so_496226_496312_4\">If the expression that denotes the called function has a type that does not include a\n  prototype, the integer promotions are performed on each argument, and arguments that\n  have type float are promoted to double. These are called the default argument\n  promotions.  (<code>6.5.2.2/6</code>)</p>\n</blockquote>\n</hr>", "CreationDate": "2009-01-30T17:03:29.143", "ParentId": "496226", "CommentCount": "6", "LastEditDate": "2009-01-30T18:09:13.673", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastActivityDate": "2009-01-30T18:09:13.673", "LastEditorUserId": "34509", "Id": "496312", "OwnerDisplayName": "litb", "Score": "11", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_496226_496381_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 7223}}, "n3337": {"so_496226_496381_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6967}}, "n4659": {"so_496226_496381_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 8732}}}, "496381": {"Body": "<p>A C array can be implicitly converted to a pointer to its first element (C99:TC3 6.3.2.1 \u00a73), ie there are a lot of cases where <code>a</code> (which has type <code>char [100]</code>) will behave the same way as <code>&amp;a[0]</code> (which has type <code>char *</code>). This explains why passing <code>a</code> as argument will work.</p>\n<p>But don't start thinking this will always be the case: There are important differences between arrays and pointers, eg regarding assignment, <code>sizeof</code> and whatever else I can't think of right now...</p>\n<p><code>&amp;a</code> is actually one of these pitfalls: This will create a pointer to the array, ie it has type <code>char (*) [100]</code> (and <em>not</em> <code>char **</code>). This means <code>&amp;a</code> and <code>&amp;a[0]</code> will point to the same memory location, but will have different types.</p>\n<p>As far as I know, there is no implicit conversion between these types and they are not guaranteed to have a compatible representation as well. All I could find is C99:TC3 6.2.5 \u00a727, which doesn't says much about pointers to arrays:</p>\n<blockquote>\n<p id=\"so_496226_496381_0\">[...] Pointers to other types need not have the same representation or alignment requirements.</p>\n</blockquote>\n<p>But there's also 6.3.2.3 \u00a77:</p>\n<blockquote>\n<p id=\"so_496226_496381_1\">[...] When a pointer to an object is converted to a pointer to a character type, the result points to the lowest addressed byte of the object. Successive increments of the result, up to the size of the object, yield pointers to the remaining bytes of the object.</p>\n</blockquote>\n<p>So the cast <code>(char *)&amp;a</code> should work as expected. Actually, I'm assuming here that the lowest addressed byte of an array will be the lowest addressed byte of its first element - not sure if this is guaranteed, or if a compiler is free to add arbitrary padding in front of an array, but if so, that would be seriously weird...</p>\n<p>Anyway for this to work, <code>&amp;a</code> still has to be cast to <code>char *</code> (or <code>void *</code> - the standard guarantees that these types have compatible representations). The problem is that there won't be any conversions applied to variable arguments aside from the default argument promotion, ie you have to do the cast explicitly yourself.</p>\n<hr>\n<p><strong>To summarize:</strong></p>\n<p><code>&amp;a</code> is of type <code>char (*) [100]</code>, which might have a different bit-representation than <code>char *</code>. Therefore, an explicit cast must be done by the programmer, because for variable arguments, the compiler can't know to what it should convert the value. This means only the default argument promotion will be done, which, as <em>litb</em> pointed out, does not include a conversion to <code>void *</code>. It follows that:</p>\n<ul>\n<li><code>scanf(\"%s\", a);</code> - good</li>\n<li><code>scanf(\"%s\", &amp;a);</code> - bad</li>\n<li><code>scanf(\"%s\", (char *)&amp;a);</code> - should be ok</li>\n</ul>\n</hr>", "CreationDate": "2009-01-30T17:20:43.833", "ParentId": "496226", "CommentCount": "0", "LastEditDate": "2009-01-30T20:51:41.867", "PostTypeId": "2", "LastEditorDisplayName": "Christoph", "LastActivityDate": "2009-01-30T20:51:41.867", "LastEditorUserId": "48015", "Id": "496381", "OwnerDisplayName": "Christoph", "Score": "5", "OwnerUserId": "48015"}, "496419": {"Body": "<p>It's been a while since I programmed in C but here's my 2c:</p>\n<p><code>char a[100]</code> doesn't allocate a separate variable for the address of the array, so the memory allocation looks like this:</p>\n<pre><code> ---+-----+---\n ...|0..99|...\n ---+-----+---\n    ^\n    a == &amp;a\n</code></pre>\n<p>For comparison, if the array was malloc'd then there is a separate variable for the pointer, and <code>a != &amp;a</code>.</p>\n<pre><code>char *a;\na = malloc(100);\n</code></pre>\n<p>In this case the memory looks like this:</p>\n<pre><code> ---+---+---+-----+---\n ...| a |...|0..99|...\n ---+---+---+-----+---\n    ^       ^\n    &amp;a  !=  a\n</code></pre>\n<p><a href=\"http://en.wikipedia.org/wiki/C_(programming_language)#K.26R_C\" rel=\"nofollow noreferrer\">K&amp;R 2nd Ed.</a> p.99 describes it fairly well:</p>\n<blockquote>\n<p id=\"so_496226_496419_0\">The correspondence between indexing\n  and pointer arithmetic is very close.\n  By definition, the value of a variable\n  or expression of type array is the\n  address of element zero of the array.\n  Thus after the assignment <code>pa=&amp;a[0];</code>\n<code>pa</code> and <code>a</code> have identical values. Since\n  the name of the array is a synonym for\n  the location of the initial element,\n  the assignment <code>pa=&amp;a[0]</code> can also be\n  written as <code>pa=a;</code></p>\n</blockquote>\n", "CreationDate": "2009-01-30T17:30:47.403", "ParentId": "496226", "CommentCount": "2", "LastEditDate": "2009-01-30T18:28:04.557", "PostTypeId": "2", "LastEditorDisplayName": "WileCau", "LastActivityDate": "2009-01-30T18:28:04.557", "LastEditorUserId": "44515", "Id": "496419", "OwnerDisplayName": "WileCau", "Score": "6", "OwnerUserId": "44515"}, "496226": {"ViewCount": "1276", "Body": "<p>I recently embarrassed myself while explaining to a colleague why</p>\n<pre><code>char a[100];\nscanf(\"%s\", &amp;a); // notice a &amp; in front of 'a'\n</code></pre>\n<p>is very bad and that the slightly better way to do it is:</p>\n<pre><code>char a[100];\nscanf(\"%s\", a); // notice no &amp; in front of 'a'  \n</code></pre>\n<p>Ok. For everybody getting ready to tell me why scanf should not be used anyway for security reasons: ease up. This question is actually about the meaning of \"&amp;a\" vs \"a\".</p>\n<p>The thing is, after I explained why it shouldn't work, we tried it (with gcc) and it works =)). I ran a quick</p>\n<pre><code>printf(\"%p %p\", a, &amp;a);\n</code></pre>\n<p>and it prints the same address twice.</p>\n<p>Can anybody explain to me what's going on?</p>\n", "Title": "Semantics of char a[]", "CreationDate": "2009-01-30T16:44:29.853", "LastActivityDate": "2009-01-30T20:51:41.850", "CommentCount": "8", "FavoriteCount": "8", "PostTypeId": "1", "Id": "496226", "Score": "14", "OwnerUserId": "51568", "Tags": "<c++><c><pointers><semantics>", "AnswerCount": "6"}});