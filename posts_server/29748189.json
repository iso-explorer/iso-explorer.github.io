post_cb({"bq_ids": {"n4140": {"so_29748189_29748285_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 6076}}, "n3337": {"so_29748189_29748285_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 5844}}, "n4659": {"so_29748189_29748285_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 7572}}}, "29748287": {"Id": "29748287", "PostTypeId": "2", "Body": "<p>Here what <code>The C++ Programming Language Fourth Edition by Bjarne Stroustrup</code> says about the matter.</p>\n<p>Sizes of C++ objects are expressed in terms of multiples of the size of a <code>char</code>, so by definition the size of a <code>char</code> is 1.</p>\n<pre><code>\u2022 1 \u2261 sizeof(char) \u2264 sizeof(short) \u2264 sizeof(int) \u2264 sizeof(long) \u2264 sizeof(long long)\n\u2022 1 \u2264 sizeof(bool) \u2264 sizeof(long)\n\u2022 sizeof(char) \u2264 sizeof(wchar_t) \u2264 sizeof(long)\n\u2022 sizeof(float) \u2264 sizeof(double) \u2264 sizeof(long double)\n\u2022 sizeof(N) \u2261 sizeof(signed N) \u2261 sizeof(unsigned N)\n</code></pre>\n<p>In that last line, <code>N</code> can be <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, or <code>long long</code>. In addition, it is guaranteed that a <code>char</code> has at least 8 bits, a <code>short</code> at least 16 bits, and a <code>long</code> at least 32 bits</p>\n", "LastEditorUserId": "2328763", "LastActivityDate": "2015-04-20T12:50:44.387", "Score": "2", "CreationDate": "2015-04-20T12:45:18.780", "ParentId": "29748189", "CommentCount": "4", "LastEditDate": "2015-04-20T12:50:44.387", "OwnerUserId": "2328763"}, "29748189": {"ViewCount": "262", "Body": "<p>I have heard from books, presentation about minimal size for integral types in C/C++</p>\n<p>Sizes below are in bytes:</p>\n<ul>\n<li><code>sizeof(char) &gt;= 1</code></li>\n<li><code>sizeof(short) &gt;= 2</code></li>\n<li><code>sizeof(long) &gt;= 4</code></li>\n<li><code>sizeof(long long) &gt;= 8</code></li>\n</ul>\n<p>But I cannot find those guarantees in standards.\nSo are there any guarantees required by compilers to implement defined in standards C++98 / C++2003 / C89 / C99?</p>\n", "AcceptedAnswerId": "29748444", "Title": "C++ sizeof integral types", "CreationDate": "2015-04-20T12:40:34.673", "Id": "29748189", "CommentCount": "5", "LastEditDate": "2015-07-01T17:28:42.427", "PostTypeId": "1", "LastEditorUserId": "1154447", "LastActivityDate": "2015-07-01T17:28:42.427", "Score": "0", "OwnerUserId": "1154447", "Tags": "<c++>", "AnswerCount": "3"}, "29748285": {"Id": "29748285", "PostTypeId": "2", "Body": "<p>That's not correct, your values are multiplied by 8. (Note that a sizeof 1 doesn't necessarily mean 8 bits, the number of bits in a char is <code>CHAR_BIT</code> - most likely 8 though).</p>\n<p>The <code>sizeof(char)</code> is guaranteed to be <code>1</code>. (as well as <code>unsigned char</code> and <code>signed char</code>).</p>\n<p>Other than that, </p>\n<blockquote>\n<p id=\"so_29748189_29748285_0\">The result of sizeof applied to any other fundamental type (3.9.1) is\n  implementation-defined. <strong>(5.3.3 Sizeof)</strong></p>\n</blockquote>\n<p>There are ordering restrictions along the lines of <code>sizeof(char) &lt;= sizeof(int) &lt;= sizeof(long long)</code>.</p>\n", "LastActivityDate": "2015-04-20T12:45:15.703", "Score": "6", "CreationDate": "2015-04-20T12:45:15.703", "ParentId": "29748189", "CommentCount": "1", "OwnerUserId": "673730"}, "29748444": {"Id": "29748444", "PostTypeId": "2", "Body": "<p>Because there are none. Standard defines only some basic guarantees and requirements regarding values. You can find them <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"nofollow\">in this document</a> on page 33:</p>\n<p><strong>5.2.4.2.1 Sizes of integer types .</strong></p>\n<p>You can be sure, that:</p>\n<pre><code>sizeof(char) \u2264 sizeof(short) \u2264 sizeof(int) \u2264 sizeof(long) \u2264 sizeof(long long)\n</code></pre>\n<p>and</p>\n<pre><code>sizeof(float) \u2264 sizeof(double) \u2264 sizeof(long double)\n</code></pre>\n<p>Also:</p>\n<ul>\n<li><code>sizeof(char)</code> is guaranteed to be 1</li>\n<li><code>sizeof(char) == sizeof(signed char) == sizeof(unsigned char)</code></li>\n</ul>\n<p>Also, on most platforms:</p>\n<ul>\n<li><code>sizeof(char) = 1</code></li>\n<li><code>sizeof(short) = 2</code></li>\n<li><code>sizeof(int) = 4</code></li>\n<li><code>sizeof(long) = 4</code></li>\n<li><code>sizeof(long long) = 8</code> <code>(1)</code></li>\n</ul>\n<hr>\n<p>(1) <code>long long</code> is not a standard type. GCC and VC++ have supported it for a long time now, but official support came with C++ 11:</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/types\" rel=\"nofollow\">C++: Fundamental Types</a></p>\n<blockquote>\n<p id=\"so_29748189_29748444_0\"><code>long long</code> - target type will have width of at least 64 bits. <em>(since C++11)</em></p>\n</blockquote>\n<p>Note, that even if <code>sizeof(char)</code> is guaranteed to be <code>1</code>, it doesn't mean, that <code>char</code> is 8 bit long. <code>CHAR_BIT</code> defines number of bits in <code>char</code> type. These days, almost all architectures use 8 bits per byte, but some older architectures used to have 7.</p>\n</hr>", "LastActivityDate": "2015-04-20T12:53:22.470", "Score": "2", "CreationDate": "2015-04-20T12:53:22.470", "ParentId": "29748189", "CommentCount": "6", "OwnerUserId": "2812864"}});