post_cb({"20743681": {"ParentId": "20743582", "CommentCount": "1", "Body": "<p>Yes, it seems that this has always been allowed. A union is a class, and a template is either a function or a class template.</p>\n<p>Relevant parts of the standards:</p>\n<ul>\n<li><p>[temp]</p>\n<blockquote>\n<p id=\"so_20743582_20743681_0\">The <em>declaration</em> in a <em>template-declaration</em> shall</p>\n<p id=\"so_20743582_20743681_1\">\u2014 declare or define a function or a class, [...]</p>\n</blockquote></li>\n<li><p>[class]</p>\n<blockquote>\n<p id=\"so_20743582_20743681_2\">A <em>union</em> is a class defined with the class-key <code>union</code></p>\n</blockquote></li>\n</ul>\n<p>(So one might argue that the new type trait <a href=\"http://en.cppreference.com/w/cpp/types/is_class\"><code>std::is_class</code></a> is a slight misnomer; the traits are supposed to partition the space of types, and so <code>is_union</code> is a separate, mutually exclusive trait.)</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "20743681", "Score": "19", "CreationDate": "2013-12-23T12:33:01.810", "LastActivityDate": "2013-12-23T12:33:01.810"}, "20743706": {"ParentId": "20743582", "CommentCount": "0", "Body": "<p>Yes, I've used constructs like that before:</p>\n<pre><code>template &lt;typename T&gt;\nunion test\n{\n    unsigned char ch[sizeof(T)];\n    T variable;\n};\n</code></pre>\n", "OwnerUserId": "3005167", "PostTypeId": "2", "Id": "20743706", "Score": "9", "CreationDate": "2013-12-23T12:34:35.043", "LastActivityDate": "2013-12-23T12:34:35.043"}, "20743582": {"CommentCount": "5", "AcceptedAnswerId": "20743681", "PostTypeId": "1", "LastEditorUserId": "1147772", "CreationDate": "2013-12-23T12:27:30.060", "LastActivityDate": "2014-07-23T10:16:00.813", "LastEditDate": "2014-07-23T10:16:00.813", "ViewCount": "1724", "FavoriteCount": "1", "Title": "Can union be templated?", "Id": "20743582", "Score": "20", "Body": "<p>It seems unions can be templated in c++11, they are used for example in <a href=\"https://github.com/akrzemi1/Optional/blob/master/optional.hpp\" rel=\"noreferrer\">the reference implementation of std::optional</a>.</p>\n<p>Was that possible before c++11 ?</p>\n", "Tags": "<c++><templates><unions>", "OwnerUserId": "1147772", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_20743582_20743681_2": {"section_id": 5852, "quality": 1.0, "length": 5}, "so_20743582_20743681_1": {"section_id": 48, "quality": 1.0, "length": 4}}, "n3337": {"so_20743582_20743681_2": {"section_id": 5622, "quality": 1.0, "length": 5}, "so_20743582_20743681_1": {"section_id": 43, "quality": 1.0, "length": 4}}, "n4659": {"so_20743582_20743681_2": {"section_id": 7331, "quality": 1.0, "length": 5}, "so_20743582_20743681_1": {"section_id": 49, "quality": 1.0, "length": 4}}}});