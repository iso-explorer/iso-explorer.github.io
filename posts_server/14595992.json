post_cb({"14596065": {"ParentId": "14595992", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-01-30T03:12:52.867", "Score": "10", "LastEditorUserId": "560648", "LastEditDate": "2013-01-30T05:46:28.753", "Id": "14596065", "OwnerUserId": "560648", "Body": "<p>In C++03, template arguments could not have internal linkage:</p>\n<blockquote>\n<p id=\"so_14595992_14596065_0\"><code>[C++03: 14.6.4.2/1]:</code> For a function call that depends on a template parameter, if the function name is an <em>unqualified-id</em> but not a <em>template-id</em>, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2) except that:</p>\n<ul>\n<li><strong>For the part of the lookup using unqualified name lookup</strong> (3.4.1), <strong>only function declarations with external linkage from the template definition context are found</strong>.</li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations with external linkage found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_14595992_14596065_1\"><em>[..]</em></p>\n</blockquote>\n<p>This was changed (issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#561\" rel=\"nofollow\">#561: \"Internal linkage functions in dependent name lookup\"</a>) in C++11:</p>\n<blockquote>\n<p id=\"so_14595992_14596065_2\"><code>[C++11: C.2.6]:</code> 14.6.4.2 <br/>\n<strong>Change</strong>: Allow dependent calls of functions with internal linkage <br/>\n<strong>Rationale:</strong> Overly constrained, simplify overload resolution rules.</p>\n</blockquote>\n<p>resulting in:</p>\n<blockquote>\n<p id=\"so_14595992_14596065_3\"><code>[C++11: 14.6.4.2/1]:</code> For a function call that depends on a template parameter, the candidate functions are found using the usual lookup rules (3.4.1, 3.4.2, 3.4.3) except that:</p>\n<ul>\n<li><strong>For the part of the lookup using unqualified name lookup</strong> (3.4.1) or qualified name lookup (3.4.3), <strong>only function declarations from the template definition context are found.</strong></li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition context or the template instantiation context are found.</li>\n</ul>\n<p id=\"so_14595992_14596065_4\"><em>[..]</em></p>\n</blockquote>\n<p>(Spot the missing <em>\"with external linkage\"</em> qualification.)</p>\n<p>Since your <code>main()::ComparitorInner&amp;</code> has internal linkage, and the instantiation of <code>std::sort</code> requires this type to be a template parameter (albeit deduced), your code is only valid in C++11.</p>\n", "LastActivityDate": "2013-01-30T05:46:28.753"}, "14596047": {"ParentId": "14595992", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-01-30T03:10:57.840", "Score": "3", "LastEditorUserId": "560648", "LastEditDate": "2013-01-30T03:23:39.077", "Id": "14596047", "OwnerUserId": "906773", "Body": "<p>Your code is fine in C++11; there was a restriction about using local types as template arguments in C++03.</p>\n", "LastActivityDate": "2013-01-30T03:23:39.077"}, "14595992": {"CommentCount": "9", "AcceptedAnswerId": "14596065", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2013-01-30T03:04:18.153", "LastActivityDate": "2013-01-30T05:46:28.753", "LastEditDate": "2013-01-30T03:23:31.527", "ViewCount": "769", "FavoriteCount": "2", "Title": "Why std::sort doesn't accept Compare classes declared within a function", "Id": "14595992", "Score": "5", "Body": "<p>I was at work, writing the Comparators in a function (to move later, when I decided where was best), and noticed this peculiarity.  I thought about it for a while, and realized I do not understand exactly why the code will not compile if I use the  inner comparators, but the outer one is fine. </p>\n<p>Any explanations?</p>\n<p>Quick Test harness: </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass CompareMe\n{\n public:\n    CompareMe(int in) : toCompare(in){}\n    int toCompare;\n};\n\nclass Comparators\n{\npublic:\n    bool operator()(CompareMe * first, CompareMe * second)\n    {\n        return first-&gt;toCompare &lt; second-&gt;toCompare;\n    }\n};\n\nclass ComparatorsOuter : public Comparators{};\n\nint main()\n{\n    class ComparatorsInner : public Comparators{};\n\n    std::vector&lt;CompareMe *&gt; compares;\n    compares.push_back(new CompareMe(0));\n    compares.push_back(new CompareMe(1234));\n    compares.push_back(new CompareMe(163));\n    compares.push_back(new CompareMe(6));\n    compares.push_back(new CompareMe(12));\n\n    //This works, and properly sorts the array\n    ComparatorsOuter comparator;\n    std::sort(compares.begin(), compares.end(), comparator);\n\n    //Uncomment out the sort below and it will not compile.\n    ComparatorsInner comparatorInner;\n    //std::sort(compares.begin(), compares.end(), comparatorInner);\n\n    std::vector&lt;CompareMe *&gt;::iterator it;\n    for(it = compares.begin(); it != compares.end(); ++it)\n    {\n        std::cout &lt;&lt; (*it)-&gt;toCompare &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<blockquote>\n<p id=\"so_14595992_14595992_0\">error: no matching function for call to '<code>sort(__gnu_cxx::__normal_iterator&lt;CompareMe**, std::vector&lt;CompareMe*, std::allocator&lt;CompareMe*&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;CompareMe**, std::vector&lt;CompareMe*, std::allocator&lt;CompareMe*&gt; &gt; &gt;, main()::ComparitorInner&amp;)</code>' </p>\n</blockquote>\n", "Tags": "<c++>", "OwnerUserId": "1284568", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14595992_14596065_3": {"section_id": 224, "quality": 0.5263157894736842, "length": 10}}, "n3337": {"so_14595992_14596065_3": {"section_id": 217, "quality": 0.6842105263157895, "length": 13}, "so_14595992_14596065_0": {"section_id": 217, "quality": 0.5652173913043478, "length": 13}}, "n4659": {"so_14595992_14596065_3": {"section_id": 232, "quality": 0.5263157894736842, "length": 10}}}});