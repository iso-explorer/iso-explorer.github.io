post_cb({"1608700": {"CommentCount": "0", "Body": "<p>A \"<a href=\"http://www.boost.org/doc/libs/1_40_0/libs/mpl/doc/refmanual/string.html\" rel=\"nofollow noreferrer\">string</a>\" was recently added to Boost.MPL, allowing one to write:</p>\n<pre><code>typedef mpl::string&lt;'asdf'&gt; asdf;\ntypedef mpl::push_back&lt;asdf, mpl::char_&lt;'!'&gt; &gt;::type asdf_bang;\n\nBOOST_ASSERT(0 == std::strcmp(mpl::c_str&lt;asdf_bang&gt;::value, \"asdf!\"));\n</code></pre>\n<p>Note that the example shown above is a bit contrived, as \"strings\" made of more than 4 characters have to be split. For example:</p>\n<pre><code>typedef mpl::string&lt;'hell','o wo','rld'&gt; hello;\n</code></pre>\n", "CreationDate": "2009-10-22T17:21:36.287", "ParentId": "711779", "Id": "1608700", "LastActivityDate": "2009-10-22T17:21:36.287", "PostTypeId": "2", "Score": "3", "OwnerUserId": "59781"}, "711826": {"CommentCount": "1", "Body": "<p>I am not sure what you want to achieve, but when you pass \"asdf\" to the template it's type is char * and the value is the address of the string. Thus a simple approach like the one outlined will fail. It's hard to recommend anything without knowing what problem you are trying to solve in the first place.</p>\n", "CreationDate": "2009-04-02T22:12:12.457", "OwnerDisplayName": "lothar-tradescape", "ParentId": "711779", "Id": "711826", "LastActivityDate": "2009-04-02T22:12:12.457", "PostTypeId": "2", "Score": "0", "OwnerUserId": "44434"}, "712160": {"CommentCount": "2", "Body": "<p>I solved a problem similar to this.  We needed a different type for each name</p>\n<pre><code>template&lt; const char* the_name &gt;\nclass A\n{\n    public:\n    const char* name( void )\n    {\n        return the_name;\n    }\n};\n\nextern const char g_unique_name[]; // defined elsewhere\ntypedef A&lt;g_unique_name&gt; A_unique;\n</code></pre>\n<p>This will gave you compile time access to the name, and unique instantiation.  It however will not let you access the individual characters at run time.</p>\n<p>If you want individual character access the only way to achieve it is with a user defined literal.  C++0x will be extended to allow the syntax in your main function above but it will still bind the template to a character pointer not to a compile time array of characters.</p>\n", "CreationDate": "2009-04-03T00:37:21.360", "OwnerDisplayName": "Caspin", "ParentId": "711779", "Id": "712160", "LastActivityDate": "2009-04-03T00:37:21.360", "PostTypeId": "2", "Score": "10", "OwnerUserId": "28817"}, "711858": {"CommentCount": "0", "Body": "<p>Quote from new standard draft:</p>\n<blockquote>\n<p id=\"so_711779_711858_0\">14.3.2 Template non-type arguments [temp.arg.nontype]</p>\n<p id=\"so_711779_711858_1\">2 Note: A string literal (2.13.4)\n  does not satisfy the requirements of\n  any of these categories and thus is\n  not an acceptable template-argument. </p>\n</blockquote>\n<p><strong>Example:</strong> </p>\n<pre><code>template&lt;class T, char* p&gt;\nclass X \n{ \nX(); \nX(const char* q) { /... / } \n}; \n\nX&lt;int, \"Studebaker\"&gt; x1; // error: string literal as template-argument char p[] = \"Vivisectionist\";\nX&lt;int,p&gt; x2; // OK\n</code></pre>\n<p>Try this, but I'm not sure, because <a href=\"http://gcc.gnu.org/gcc-4.3/cxx0x_status.html\" rel=\"nofollow noreferrer\">http://gcc.gnu.org/gcc-4.3/cxx0x_status.html</a> doesn't say any about this feature.</p>\n", "CreationDate": "2009-04-02T22:23:23.647", "OwnerDisplayName": "bb", "ParentId": "711779", "Id": "711858", "LastActivityDate": "2009-04-02T22:23:23.647", "PostTypeId": "2", "Score": "0", "OwnerUserId": "72000"}, "711854": {"CommentCount": "3", "Body": "<p>You can't do that.  From 14.3.2 in the standard:</p>\n<p>A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<ul>\n<li>an integral constant-expression of integral or enumeration type; or</li>\n<li>the name of a non-type template-parameter; or</li>\n<li>the address of an object or function with external linkage, including function templates and function template-ids\n    but excluding non-static class members, expressed as &amp; id-expression where the &amp; is optional if the name refers to</li>\n<li>a function or array, or if the corresponding template-parameter is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1.</li>\n<li><strong>[ Note: A string literal (2.13.4) does not satisfy the requirements of any of these categories and thus is not an acceptable template-argument</strong></li>\n</ul>\n", "CreationDate": "2009-04-02T22:21:54.167", "OwnerDisplayName": "CTT", "ParentId": "711779", "Id": "711854", "LastActivityDate": "2009-04-02T22:21:54.167", "PostTypeId": "2", "Score": "0", "OwnerUserId": "40191"}, "712221": {"CommentCount": "2", "Body": "<p>Sadly, you still have to split it into separate characters, eg:</p>\n<pre><code>myTemplate&lt;'s','t','r','i','n','g'&gt;\n</code></pre>\n<p>In my humble opinion, this is a huge oversight in the new standard.  Some other people agreed, and tried to implement the behavior in GCC with pretty good results.  You can find that thread <a href=\"http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/9b0edd169ba2ce3c\" rel=\"noreferrer\">here</a>.</p>\n<p>Edit: Some weird problems with the link, so cut and paste from this:</p>\n<p><a href=\"http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/9b0edd169ba2ce3c\" rel=\"noreferrer\">http://groups.google.com/group/comp.lang.c++.moderated/browse_thread/thread/9b0edd169ba2ce3c</a></p>\n", "CreationDate": "2009-04-03T01:10:59.547", "OwnerDisplayName": "Dan Olson", "ParentId": "711779", "Id": "712221", "LastActivityDate": "2009-04-03T01:10:59.547", "PostTypeId": "2", "Score": "9", "OwnerUserId": "69283"}, "711779": {"CreationDate": "2009-04-02T21:59:19.710", "ViewCount": "12526", "FavoriteCount": "5", "Id": "711779", "AcceptedAnswerId": "712221", "Score": "12", "Title": "Template Meta-programming with Char Arrays as Parameters", "LastEditorUserId": "500104", "CommentCount": "0", "Body": "<p>I'm playing around with TMP in GCC 4.3.2's half-implementation of C++11, and I was wondering if there was a way to somehow do the following:</p>\n<pre><code>template &lt;char x, char... c&gt;\nstruct mystruct {\n...\n};\n\nint main () {\n\n   mystruct&lt;\"asdf\"&gt;::go();\n\n}\n</code></pre>\n<p>It obviously won't let me do it just like that, and I thought I'd get lucky by using user-defined literals to transform the \"asdf\" string during compile-time, but GCC 4.3 doesn't support user-defined literals... </p>\n<p>Any suggestions? I'd prefer to not do 'a','s','d','f', since this severely hampers my plans for this project.</p>\n", "Tags": "<c++><templates><gcc><c++11><metaprogramming>", "OwnerDisplayName": "Daniel Jennings", "LastEditDate": "2012-09-17T00:12:14.593", "LastActivityDate": "2012-11-16T23:07:06.643", "PostTypeId": "1", "AnswerCount": "10", "OwnerUserId": "3641"}, "767691": {"OwnerDisplayName": "Chris", "Body": "<p>Try this:</p>\n<pre><code>extern const char SOMESTRING[] = \"stringhere\"; //extern linkage required!\n\ntemplate&lt;const char * const STR&gt;\nstruct MyStruct\n{\n  static std::string doThis() { return STR; }\n};\n\n\n\nMyStruct&lt;SOMESTRING&gt;   testObj; //ok!\n</code></pre>\n<p>Chris</p>\n", "CreationDate": "2009-04-20T10:27:04.827", "CommunityOwnedDate": "2009-04-20T10:27:04.827", "ParentId": "711779", "Id": "767691", "LastActivityDate": "2009-04-20T10:27:04.827", "PostTypeId": "2", "CommentCount": "1", "Score": "2"}, "12451758": {"LastActivityDate": "2012-09-17T00:14:36.123", "CommentCount": "0", "Body": "<p>In C++11 there is no way to store temporary string anywhere at compile time. So I can suggest you this approach:\n(It is fast-made sketch, but it is well descriptive)</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ntemplate &lt;char...&gt;\nstruct StringTuple;\n\ntemplate &lt;char TargHead&gt;\nstruct StringTuple&lt;TargHead&gt; {\n    static constexpr char kSymbol = TargHead;\n\n    static void print() {\n        printf(kSymbol ? \"%c\\n\" : \"\\n\", kSymbol);\n    }\n};\n\ntemplate &lt;char TargHead, char... TargTail&gt;\nstruct StringTuple&lt;TargHead, TargTail...&gt; {\n    using Next = StringTuple&lt;TargTail...&gt;;\n    static constexpr char kSymbol = TargHead;\n\n    static void print() {\n        if (kSymbol) {\n            printf(\"%c\", kSymbol);\n            Next::print();\n        } else {\n            printf(\"\\n\");\n        }\n    }\n};\n\nconstexpr int length(char *string) {\n    return (string[0] == 0) ? 1 : (length(string + 1) + 1);\n}\n\nconstexpr char get(char *string, int i) {\n    return i &lt; length(string) ? string[i] : 0;\n}\n\n#define ST(string) \\\n    StringTuple&lt; \\\n    get(string, 0), \\\n    get(string, 1), \\\n    get(string, 2), \\\n    get(string, 3), \\\n    get(string, 4), \\\n    get(string, 5), \\\n    get(string, 6), \\\n    get(string, 7), \\\n    get(string, 8), \\\n    get(string, 9), \\\n    get(string, 10), \\\n    get(string, 11), \\\n    get(string, 12), \\\n    get(string, 13), \\\n    get(string, 14), \\\n    get(string, 15), \\\n    get(string, 16), \\\n    get(string, 17), \\\n    get(string, 18), \\\n    get(string, 19), \\\n    get(string, 20), \\\n    get(string, 21), \\\n    get(string, 22), \\\n    get(string, 23), \\\n    get(string, 24), \\\n    get(string, 25), \\\n    get(string, 26), \\\n    get(string, 27), \\\n    get(string, 28), \\\n    get(string, 29), \\\n    get(string, 30), \\\n    get(string, 31), \\\n    get(string, 32), \\\n    get(string, 33), \\\n    get(string, 34), \\\n    get(string, 35), \\\n    get(string, 36), \\\n    get(string, 37), \\\n    get(string, 38), \\\n    get(string, 39), \\\n    get(string, 40), \\\n    get(string, 41), \\\n    get(string, 42) \\\n    &gt;\n\nint main() {\n    ST(\"Hello, compile-time world!\")::print();\n}\n</code></pre>\n<p>Bash code to generate a part of macro:</p>\n<pre><code>for i in `seq 0 42`; do echo \"    get(string, $i), \\\\\"; done\n</code></pre>\n<p>You have to pass large number (1000 or more) to this generator to support all your strings and you have to make static assertion if string exceeds this limit.</p>\n<hr>\n<p>I use such generated macros in my own scientific projects. I know it seems messy, but it works. Example of usage of generated macro:</p>\n<pre><code>#define PRINT(a) print(a);\nFOREACH_MACRO(PRINT, a, b, c) // print(a);print(b);print(c);\n</code></pre>\n<p>I will try find more pretty solution, but at first I will use this.</p>\n</hr>", "CreationDate": "2012-09-17T00:08:11.993", "LastEditDate": "2012-09-17T00:14:36.123", "ParentId": "711779", "Id": "12451758", "LastEditorUserId": "1486168", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1486168"}, "bq_ids": {"n4140": {"so_711779_711858_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 88}}, "n3337": {"so_711779_711858_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 83}}}, "12451642": {"CommentCount": "0", "Body": "<p>Motti is wrong.</p>\n<p>Unfortunately current standard (C++11) not supports variadic template literal operator for string parameters, it is possible only for numbers.</p>\n<pre><code>template &lt;char... Args&gt;\noperator \"\"_op();\n\n...\n\n1212_op; // legal, calls operator \"\"_op&lt;'1','2','1','2'&gt;;\n\"1212\"_op; // illegal\n</code></pre>\n<p>I did not understand purpose of this restriction.</p>\n", "CreationDate": "2012-09-16T23:41:15.983", "ParentId": "711779", "Id": "12451642", "LastActivityDate": "2012-09-16T23:41:15.983", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1486168"}, "13425759": {"CommentCount": "0", "Body": "<p>See the discussion here, apparently it is possible: <a href=\"http://cpp-next.com/archive/2012/10/using-strings-in-c-template-metaprograms/\" rel=\"nofollow\">http://cpp-next.com/archive/2012/10/using-strings-in-c-template-metaprograms/</a></p>\n", "CreationDate": "2012-11-16T23:07:06.643", "ParentId": "711779", "Id": "13425759", "LastActivityDate": "2012-11-16T23:07:06.643", "PostTypeId": "2", "Score": "0", "OwnerUserId": "381739"}});