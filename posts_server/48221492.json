post_cb({"bq_ids": {"n4140": {"so_48221492_48221792_1": {"length": 15, "quality": 1.0, "section_id": 2973}, "so_48221492_48221792_2": {"length": 24, "quality": 0.8888888888888888, "section_id": 2974}}, "n3337": {"so_48221492_48221792_1": {"length": 15, "quality": 1.0, "section_id": 2842}, "so_48221492_48221792_2": {"length": 24, "quality": 0.8888888888888888, "section_id": 2843}}, "n4659": {"so_48221492_48221792_1": {"length": 15, "quality": 1.0, "section_id": 3732}, "so_48221492_48221792_2": {"length": 24, "quality": 0.8888888888888888, "section_id": 3733}}}, "48221492": {"ViewCount": "491", "Body": "<p>Will <code>std::call_once</code> work properly for non-atomic variables? Consider the following code</p>\n<pre><code>std::once_flag once;\nint x;\n\nvoid init() { x = 10; }\n\nvoid f() {\n  std::call_once(once, init);\n  assert(x == 10);\n}\n\nint main() {\n  std::thread t1(f), t2(f);\n  t1.join();\n  t2.join();\n}\n</code></pre>\n<p>Will the side-effect in <code>init</code> be seen to all threads when <code>call_once</code> returns? Documentation on <a href=\"http://en.cppreference.com/w/cpp/thread/call_once\" rel=\"nofollow noreferrer\">cppreference</a> is kind of vague. It only says on all threads <code>std::call_once</code> will return after <code>init</code> is completed, but doesn't mention anything that prevents the x=10 being reordered after <code>init</code> returns.</p>\n<p>Any ideas? Where in the standard that clarifies the behavior?</p>\n", "Title": "std::call_once safe for non atomic variables?", "CreationDate": "2018-01-12T07:27:45.003", "LastActivityDate": "2018-01-24T19:10:37.237", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-24T19:10:37.237", "LastEditorUserId": "875044", "Id": "48221492", "Score": "9", "OwnerUserId": "875044", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "2"}, "48221684": {"Id": "48221684", "PostTypeId": "2", "Body": "<p>The main difference between atomic and non-atomic variables is that access to a non-atomic variable from multiple threads (unless all threads are reading) needs explicit synchronization to prevent the accesses from being potentially concurrent.</p>\n<p>There are various ways to achieve this synchronization. The most common technique involves mutexes. The unlocking of a mutex by one thread synchronizes with the subsequent locking of that mutex by another thread. Thus, if the first thread writes a variable and the second thread reads that variable, an explicit ordering exists between the write and the read. The program then behaves as you expect: the read must see the last value written in that ordering. If mutexes were not used, the accesses to the variable would be potentially concurrent, and undefined behaviour would occur.</p>\n<p>Atomic variables are self-synchronizing: no matter what, two threads attempting to access the same atomic variable will work out some order between them. Besides that, they don't have any special ability, compared to non-atomic variables, to be accessed by multiple threads.</p>\n<p>The use of <code>std::call_once</code> with the same flag by multiple threads sets up an explicit synchronization: <em>each</em> thread only returns from <code>std::call_once</code> once <code>init</code> has completed, so each thread must see the new value of <code>x</code>.</p>\n<p>The compiler is only allowed to reorder writes to the extent that it does not alter the observable behaviour of the program. Race conditions that you rationalize in terms of reordering disappear once you adhere to the standard by not allowing writes to a non-atomic variable to be potentially concurrent with another access to the same variable.</p>\n", "LastActivityDate": "2018-01-12T07:43:37.703", "CommentCount": "1", "CreationDate": "2018-01-12T07:43:37.703", "ParentId": "48221492", "Score": "4", "OwnerUserId": "481267"}, "48221792": {"Id": "48221792", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48221492_48221792_0\">Will the side-effect in init be seen to all threads when call_once returns? </p>\n</blockquote>\n<p>Side effects from <code>init</code> are visible to all threads that have called <code>call_once</code>\nThere is no more than one active execution (calling <code>init</code>) but multiple passive executions are possible.</p>\n<p>\u00a7 30.4.6.2-2 - [thread.once.callonce]  </p>\n<blockquote>\n<p id=\"so_48221492_48221792_1\">An execution of call_once that does not call its func is a passive execution. An execution of call_once that calls its func is an active execution.</p>\n</blockquote>\n<p>\u00a7 30.4.6.2-3 - [thread.once.callonce]  </p>\n<blockquote>\n<p id=\"so_48221492_48221792_2\">Synchronization: For any given once_flag: all active executions occur in a total order; completion of an active execution synchronizes with (6.8.2) the start of the next one in this total order;\n  and the returning execution synchronizes with the return from all passive executions.</p>\n</blockquote>\n<p>So it is exactly as you expected</p>\n", "LastActivityDate": "2018-01-12T07:52:08.583", "CommentCount": "0", "CreationDate": "2018-01-12T07:52:08.583", "ParentId": "48221492", "Score": "8", "OwnerUserId": "6651824"}});