post_cb({"33457935": {"Id": "33457935", "PostTypeId": "2", "Body": "<p><a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1787\" rel=\"nofollow noreferrer\">Defect report 1787</a> lead to the change documented in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3914.html\" rel=\"nofollow noreferrer\">N3914</a> being <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3903.html\" rel=\"nofollow noreferrer\">applied to the draft standard for C++14</a>. Which change [dcl.init] paragraph 12 from:</p>\n<blockquote>\n<p id=\"so_33456141_33457935_0\">If no initializer is specified for an object, the object is\n  default-initialized; if no initialization is performed, an object with\n  automatic or dynamic storage duration has indeterminate value. [ Note:\n  Objects with static or thread storage duration are zero-initialized,\n  see 3.6.2. \u2014 end note ]</p>\n</blockquote>\n<p>to:</p>\n<blockquote>\n<p id=\"so_33456141_33457935_1\">If no initializer is specified for an object, the object is\n  default-initialized. <strong>When storage for an object with automatic or\n  dynamic storage duration is obtained, the object has an indeterminate\n  value, and if no initialization is performed for the object, that\n  object retains an indeterminate value until that value is replaced</strong>\n  (5.17 [expr.ass]). [Note: Objects with static or thread storage\n  duration are zero-initialized, see 3.6.2 [basic.start.init]. \u2014end\n  note] If an indeterminate value is produced by an evaluation, the\n  behavior is undefined except in the following cases:</p>\n<p id=\"so_33456141_33457935_2\">[...]</p>\n</blockquote>\n<p>This make it clear the indeterminate value situation only occurs for objects of automatic or dynamic storage duration. Since this was applied via a defect report it probably also applies to C++11 since the defect report occured before C++14 was accepted but it could apply further back as well. The rules for how far back a defect are supposed to apply were never clear to me.</p>\n<p>Since placement new was brought up in the comments, the same change also modified section <em>[expr.new]</em>, making the indeterminate value portion a comment:</p>\n<blockquote>\n<p id=\"so_33456141_33457935_3\">If the new-initializer is omitted, the object is default-initialized\n  (8.5 [dcl.init]); if. [Note: If no initialization is performed, the\n  object has an indeterminate value. \u2014end note]</p>\n</blockquote>\n<p>The beginning of the section says:</p>\n<blockquote>\n<p id=\"so_33456141_33457935_4\">[...]Entities created by a new-expression have dynamic storage\n  duration (3.7.4).[...]</p>\n</blockquote>\n<p>Which seem sufficient to apply the changes in section <em>[dcl.init]</em>.</p>\n<p>This change was also interesting since prior to this change the term  <a href=\"https://stackoverflow.com/a/23415662/1708801\">indeterminate value was not defined</a> in the C++ standard.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-05T02:54:08.063", "Score": "3", "CreationDate": "2015-11-01T00:08:39.190", "ParentId": "33456141", "CommentCount": "2", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:04:06.037"}, "bq_ids": {"n4140": {"so_33456141_33457935_4": {"length": 7, "quality": 0.875, "section_id": 6082}, "so_33456141_33457935_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 6098}, "so_33456141_33457935_1": {"length": 42, "quality": 0.8571428571428571, "section_id": 3291}, "so_33456141_33457935_0": {"length": 19, "quality": 0.76, "section_id": 3291}}, "n3337": {"so_33456141_33457935_4": {"length": 7, "quality": 0.875, "section_id": 5850}, "so_33456141_33457935_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 5864}, "so_33456141_33457935_0": {"length": 21, "quality": 0.84, "section_id": 3161}}, "n4659": {"so_33456141_33457935_4": {"length": 7, "quality": 0.875, "section_id": 7578}, "so_33456141_33457935_3": {"length": 9, "quality": 0.6923076923076923, "section_id": 7595}, "so_33456141_33457935_1": {"length": 42, "quality": 0.8571428571428571, "section_id": 4053}, "so_33456141_33457935_0": {"length": 19, "quality": 0.76, "section_id": 4053}}}, "33456141": {"ViewCount": "207", "Body": "<p>If a C++ constructor for an object with static-storage duration does not initialize a member, is that required to preserve the prior zero-initialization, or does it leave the member with an indeterminate value?</p>\n<p>My reading of the C++ spec is that it contradicts itself.</p>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo { Foo(); int x; } object;\n\nFoo::Foo() { }\n\nint main() { std::cout &lt;&lt; object.x &lt;&lt; std::endl; }\n</code></pre>\n<p>The Foo() constructor does not explicitly initialize the member object.x, so\naccording to the note in 12.6.2 paragraph 8:</p>\n<blockquote>\n<p id=\"so_33456141_33456141_0\">the member has indeterminate value.</p>\n</blockquote>\n<p>But working through the details of the various initializations, this appears to\nbe incorrect.  The member object.x is zero-initialized as it has static-storage-duration, and then I can't see anything that changes that.</p>\n<p>Regarding the constructor, the text in 12.6.2 that applies is:</p>\n<blockquote>\n<p id=\"so_33456141_33456141_1\">the entity is default-initialized.</p>\n</blockquote>\n<p>In 8.5 paragraph 7, the relevant case of default initialization is:</p>\n<blockquote>\n<p id=\"so_33456141_33456141_2\">... no initialization is performed</p>\n</blockquote>\n<p>which I read to mean that the previous zero-initialization is not changed by the default-initialization.</p>\n<p>Am I missing some other text which resets all members to \"indeterminate value\" at the start of the constructor call?</p>\n<p>I found various other questions on stackoverflow regarding zero-initialization and\ndefault-initialization, but I couldn't see any that\nanalyzed what happens when default-initialization follows\nsome early initialization of the same entity.</p>\n<p>In this case there is probably no practical effect.  But in a more complex constructor, with some members initialized and others not, does the compiler have to track exactly which bytes/bits are initialized?, or can it just initialize the whole object (e.g., simplifying the constructor to a memset() call)?</p>\n", "AcceptedAnswerId": "33457935", "Title": "Does C++ default-initialization preserve prior zero-initialization?", "CreationDate": "2015-10-31T20:17:14.687", "Id": "33456141", "CommentCount": "16", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-01T03:02:28.817", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-05T02:54:08.063", "Score": "8", "OwnerUserId": "1998586", "Tags": "<c++><constructor><language-lawyer><storage-duration>", "AnswerCount": "1"}});