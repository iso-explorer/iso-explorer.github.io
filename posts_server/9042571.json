post_cb({"bq_ids": {"n4140": {"so_9042571_9042626_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 6326}}, "n3337": {"so_9042571_9042626_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 6083}}, "n4659": {"so_9042571_9042626_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 7836}}}, "9042750": {"Id": "9042750", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9042571_9042750_0\">I have multiple threads simultaneously calling push_back() on a shared object of std::vector. Is std::vector thread safe?</p>\n</blockquote>\n<p>This is <strong>unsafe</strong>.</p>\n<blockquote>\n<p id=\"so_9042571_9042750_1\">Or do I need to implement the mechanism myself to make it thread safe?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_9042571_9042750_2\">I want to avoid doing extra \"locking and freeing\" work because I'm a library user rather than a library designer. I hope to look for existing thread-safe solutions for vector.</p>\n</blockquote>\n<p>Well, vector's interface isn't optimal for concurrent use. It is fine if the client has access to a lock, but for for the interface to abstract locking for each operation -- no. In fact, vector's interface cannot guarantee thread safety without an external lock (assuming you need operations which also mutate).</p>\n<blockquote>\n<p id=\"so_9042571_9042750_3\">How about boost::vector, which was newly introduced from boost 1.48.0 onward. Is it thread safe?</p>\n</blockquote>\n<p>Docs state:</p>\n<pre><code>//! boost::container::vector is similar to std::vector but it's compatible\n//! with shared memory and memory mapped files.\n</code></pre>\n", "LastEditorUserId": "191596", "LastActivityDate": "2012-01-29T03:53:34.340", "Score": "23", "CreationDate": "2012-01-28T03:44:24.483", "ParentId": "9042571", "CommentCount": "0", "LastEditDate": "2012-01-29T03:53:34.340", "OwnerUserId": "191596"}, "9042626": {"Id": "9042626", "PostTypeId": "2", "Body": "<p>The C++ standard makes certain threading guarantees for all the classes in the standard C++ library. These guarantees may not be what you'd expect them to be but for all standard C++ library classes certain thread safety guarantees are made. Make sure you read the guarantees made, though, as the threading guarantees of standard C++ containers don't usually align with what you would want them to be. For some classes different, usually stronger, guarantees are made and the answer below specifically applies to the containers. The containers essentially have the following thread-safety guarantees:</p>\n<ol>\n<li>there can be multiple concurrent readers of the same container</li>\n<li>if there is one writer, there shall be no more writers and no readers</li>\n</ol>\n<p>These are typically not what people would want as thread-safety guarantees but are very reasonable given the interface of the standard containers: they are intended to be used efficiently in the absence of multiple accessing threads. Adding any sort of locking for their methods would interfere with this. Beyond this, the interface of the containers isn't really useful for any form of internal locking: generally multiple methods are used and the accesses depend on the outcome of previous accesses. For example, after having checked that a container isn't <code>empty()</code> an element might be accessed. However, with internal locking there is no guarantee that the object is still in the container when it is actually accessed.</p>\n<p>To meet the requirements which give the above guarantees you will probably have to use some form of external locking for concurrently accessed containers. I don't know about the boost containers but if they have an interface similar to that of the standard containers I would suspect that they have exactly the same guarantees.</p>\n<p>The guarantees and requirements are given in 17.6.4.10 [res.on.objects] paragraph 1:</p>\n<blockquote>\n<p id=\"so_9042571_9042626_0\">The behavior of a program is undefined if calls to standard library functions from different threads may introduce a data race. The conditions under which this may occur are specified in 17.6.5.9. [ Note: Modifying an object of a standard library type that is shared between threads risks undefined behavior unless objects of that type are explicitly specified as being sharable without data races or the user supplies a locking mechanism. \u2014endnote]</p>\n</blockquote>\n<p>... and 17.6.5.9 [res.on.data.races]. This section essentially details the more informal description in the not.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2014-05-28T21:01:38.790", "Score": "41", "CreationDate": "2012-01-28T03:11:14.260", "ParentId": "9042571", "CommentCount": "3", "LastEditDate": "2014-05-28T21:01:38.790", "OwnerUserId": "1120273"}, "9049351": {"Id": "9049351", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9042571_9049351_0\">I have multiple threads simultaneously calling push_back() on a shared object of std::vector. ... I hope to look for existing thread-safe solutions for vector.</p>\n</blockquote>\n<p>Take a look at <code>concurrent_vector</code> in <a href=\"http://threadingbuildingblocks.org\">Intel's TBB</a>. Strictly speaking, it's quite different from <code>std::vector</code> internally and is not fully compatible by API, but still might be suitable. You might find some details of its design and functionality <a href=\"http://software.intel.com/en-us/blogs/author/anton-malakhov/\">in the blogs of TBB developers</a>.</p>\n", "LastActivityDate": "2012-01-28T22:57:10.507", "Score": "8", "CreationDate": "2012-01-28T22:57:10.507", "ParentId": "9042571", "CommentCount": "0", "OwnerUserId": "654891"}, "9042571": {"ViewCount": "27224", "Body": "<p>I have multiple threads simultaneously calling <code>push_back()</code> on a shared object of <code>std::vector</code>. Is <code>std::vector</code> thread safe? Or do I need to implement the mechanism myself to make it thread safe?<br>\nI want to avoid doing extra <em>\"locking and freeing\"</em> work because I'm a library user rather than a library designer. I hope to look for existing thread-safe solutions for vector. How about <code>boost::vector</code>, which was newly introduced from boost <em>1.48.0</em> onward. Is it thread safe?</br></p>\n", "Title": "Is std::vector or boost::vector thread safe?", "CreationDate": "2012-01-28T02:59:27.983", "LastActivityDate": "2015-09-20T17:25:04.457", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-11-05T09:29:06.670", "LastEditorUserId": "1035174", "Id": "9042571", "Score": "27", "OwnerUserId": "1039872", "Tags": "<c++><boost><stl><thread-safety><std>", "AnswerCount": "3"}});