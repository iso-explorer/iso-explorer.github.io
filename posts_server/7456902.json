post_cb({"7456920": {"Id": "7456920", "PostTypeId": "2", "Body": "<p>When writing in C or C++, every datatype is architecture and compiler specific. On one system int is 32, but you can find ones where it is 16 or 64; it's not defined, so it's up to compiler.</p>\n<p>As for <code>long</code> and <code>int</code>, it comes from times, where standard integer was 16bit, where <code>long</code> was 32 bit integer - and it indeed <em>was</em> longer than <code>int</code>.</p>\n", "LastEditorUserId": "809387", "LastActivityDate": "2013-04-25T17:09:06.237", "Score": "22", "CreationDate": "2011-09-17T18:26:25.263", "ParentId": "7456902", "CommentCount": "12", "OwnerUserId": "809387", "LastEditDate": "2013-04-25T17:09:06.237"}, "7456928": {"Id": "7456928", "PostTypeId": "2", "Body": "<p>long is not the same length as an int. According to the specification, long is at least as large as int. For example, on Linux x86_64 with GCC, sizeof(long) = 8, and sizeof(int) = 4.</p>\n", "LastActivityDate": "2011-09-17T18:27:17.887", "CommentCount": "1", "CreationDate": "2011-09-17T18:27:17.887", "ParentId": "7456902", "Score": "17", "OwnerUserId": "353253"}, "37476736": {"Id": "37476736", "PostTypeId": "2", "Body": "<p>looking for something completely unrelated and stumbled across this and needed to answer.  Yeah, this is old, so for people who surf on in later...</p>\n<p>Frankly, I think all the answers on here are incomplete.</p>\n<p>The size of a long is the size of the number of bits your processor can operate on at one time.  It's also called a \"word\".  A \"half-word\" is a short.  A \"doubleword\" is a long long and is twice as large as a long (and originally was only implemented by vendors and not standard), and even bigger than a long long is a \"quadword\" which is twice the size of a long long but it had no formal name (and not really standard).</p>\n<p>Now, where does the int come in?  In part registers on your processor, and in part your OS.  Your registers define the native sizes the CPU handles which in turn define the size of things like the short and long.  Processors are also designed with a data size that is the most efficient size for it to operate on.  That should be an int.</p>\n<p>On todays 64bit machines you'd assume, since a long is a word and a word on a 64bit machine is 64bits, that a long would be 64bits and an int whatever the processor is designed to handle, but it might not be.  Why?  Your OS has chosen a data model and defined these data sizes for you (pretty much by how it's built).  Ultimately, if you're on Windows (and using Win64) it's 32bits for both a long and int.  Solaris and Linux use different definitions (the long is 64bits).  These definitions are called things like ILP64, LP64, and LLP64.  Windows uses LLP64 and Solaris and Linux use LP64:</p>\n<pre>\nModel      ILP64   LP64   LLP64\nint        64      32     32\nlong       64      64     32\npointer    64      64     64\nlong long  64      64     64\n</pre>\n<p>Where, e.g., ILP means int-long-pointer, and LLP means long-long-pointer</p>\n<p>To get around this most compilers seem to support setting the size of an integer directly with types like int32 or int64.</p>\n", "LastActivityDate": "2016-05-27T06:55:12.833", "CommentCount": "2", "CreationDate": "2016-05-27T06:55:12.833", "ParentId": "7456902", "Score": "1", "OwnerUserId": "5484910"}, "bq_ids": {"n4140": {"so_7456902_7456932_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 7211}}, "n3337": {"so_7456902_7456932_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 6955}}, "n4659": {"so_7456902_7456932_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 8720}}}, "7459270": {"Id": "7459270", "PostTypeId": "2", "Body": "<p>The specific guarantees are as follows:</p>\n<ul>\n<li><code>char</code> is at least 8 bits (1 byte by definition, however many bits it is)</li>\n<li><code>short</code> is at least 16 bits</li>\n<li><code>int</code> is at least 16 bits</li>\n<li><code>long</code> is at least 32 bits</li>\n<li><code>long long</code> (in versions of the language that support it) is at least 64 bits</li>\n<li>Each type in the above list is <em>at least</em> as wide as the previous type (but may well be the same).</li>\n</ul>\n<p>Thus it makes sense to use <code>long</code> if you need a type that's at least 32 bits, <code>int</code> if you need a type that's reasonably fast and at least 16 bits.</p>\n<p>Actually, at least in C, these lower bounds are expressed in terms of <em>ranges</em>, not sizes.  For example, the language requires that <code>INT_MIN &lt;= -32767</code>, and <code>INT_MAX &gt;= +32767</code>.  The 16-bit requirements follows from this and from the requirement that integers are represented in binary.</p>\n<p>C99 adds <code>&lt;stdint.h&gt;</code> and <code>&lt;inttypes.h&gt;</code>, which define types such as <code>uint32_t</code>, <code>int_least32_t</code>, and <code>int_fast16_t</code>; these are typedefs, usually defined as aliases for the predefined types.</p>\n<p>(There isn't <em>necessarily</em> a direct relationship between size and range.  An implementation could make <code>int</code> 32 bits, but with a range of only, say, <code>-2**23 .. +2^23-1</code>, with the other 8 bits (called <em>padding bits</em>) not contributing to the value.  It's theoretically possible (but practically highly unlikely) that <code>int</code> could be larger than <code>long</code>, as long as <code>long</code> has at least as wide a <em>range</em> as <code>int</code>.  In practice, few modern systems use padding bits, or even representations other than 2's-complement, but the standard still permits such oddities.  You're more likely to encounter exotic features in embedded systems.)</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2013-04-25T18:20:25.440", "Score": "19", "CreationDate": "2011-09-18T03:17:46.570", "ParentId": "7456902", "CommentCount": "0", "OwnerUserId": "827263", "LastEditDate": "2013-04-25T18:20:25.440"}, "7456932": {"Id": "7456932", "PostTypeId": "2", "Body": "<p><code>long</code> is not the same size as <code>int</code>, it is <em>at least</em> the same size as <code>int</code>. To quote the C++03 standard (3.9.1-2):</p>\n<blockquote>\n<p id=\"so_7456902_7456932_0\">There are four signed integer types: \u201csigned char\u201d, \u201cshort int\u201d,\n  \u201cint\u201d, and \u201clong int.\u201d In this list, each type provides at least as\n  much storage as those preceding it in the list. Plain ints have the\n  natural size suggested by the architecture of the execution\n  environment); the other signed integer types are provided to meet special needs.</p>\n</blockquote>\n<p>My interpretation of this is \"just use <code>int</code>, but if for some reason that doesn't fit your needs and you are lucky to find another integral type that's better suited, be our guest and use that one instead\". One way that <code>long</code> might be better is if you 're on an architecture where it is... longer.</p>\n", "LastActivityDate": "2011-09-17T18:28:28.473", "CommentCount": "2", "CreationDate": "2011-09-17T18:28:28.473", "ParentId": "7456902", "Score": "12", "OwnerUserId": "50079"}, "7456902": {"ViewCount": "34098", "Body": "<p>As I've learned recently, a long in C/C++ is the same length as an int.  To put it simply, why?  It seems almost pointless to even include the datatype in the language.  Does it have any uses specific to it that an int doesn't have?  I know we can declare a 64-bit int like so:</p>\n<pre><code>long long x = 0;\n</code></pre>\n<p>But why does the language choose to do it this way, rather than just making a long well...longer than an int?  Other languages such as C# do this, so why not C/C++?</p>\n", "AcceptedAnswerId": "7456920", "Title": "Long Vs. Int C/C++ - What's The Point?", "CreationDate": "2011-09-17T18:23:46.787", "Id": "7456902", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-09-13T14:30:11.147", "Score": "15", "OwnerUserId": "647242", "Tags": "<c++><c><int><long-integer>", "AnswerCount": "5"}});