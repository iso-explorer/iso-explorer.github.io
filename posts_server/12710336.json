post_cb({"42338131": {"Id": "42338131", "PostTypeId": "2", "Body": "<p>C++ accesses by volatile lvalues and C accesses to volatile objects are \"abstractly\" \"observable\"--although <a href=\"https://stackoverflow.com/a/42335543/3404097\">in practice</a> C behaviour is per the C++ standard not the C standard. Informally, the <code>volatile</code> declaration tells <em>every</em> thread the value might change somehow regardless of the text in <em>any</em> thread. Under the Standards with threads, there isn't any notion of a write by another thread causing a change in an object, volatile or not, shared or not, except for a shared variable by the synchronizing function call at the start of a synchronized critical region. <code>volatile</code> is <em>irrelevant</em> to thread shared objects.</p>\n<p>If your code doesn't properly synchronize the thread you are talking about, your one thread reading what an other thread wrote has undefined behaviour. So the compiler can generate any code it wants. If your code is properly synchronized then writes by other threads only happen at thread synchronization calls; you don't need <code>volatile</code> for that.</p>\n<p>PS</p>\n<p>The standards say \"What constitutes an access to an object that\nhas volatile-qualified type is implementation-defined.\" So you can't just assume that there is a read access for every dereferencing of a volatile lvalue or a write acces for every assignment through one.</p>\n<p>Moreover how (\"abstract\") \"observable\" <code>volatile</code> accesses are \"actually\" manifested is implementation defined. So a compiler might not generate code for hardware accesses corresponding to the defined abstract accesses. Eg maybe only objects with static storage duration and external linkage compiled with a certain flag for linking into special hardware locations can ever be changed from outside the program text, so that other objects' <code>volatile</code> is ignored.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-20T10:08:41.557", "Score": "0", "CreationDate": "2017-02-20T06:49:54.287", "ParentId": "12710336", "CommentCount": "0", "OwnerUserId": "3404097", "LastEditDate": "2017-05-23T11:53:18.280"}, "bq_ids": {"n4140": {"so_12710336_12710360_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 5436}}, "n3337": {"so_12710336_12710360_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 5231}}, "n4659": {"so_12710336_12710360_1": {"length": 25, "quality": 0.8928571428571429, "section_id": 6863}}}, "12710360": {"Id": "12710360", "PostTypeId": "2", "Body": "<h3>For C++:</h3>\n<blockquote>\n<p id=\"so_12710336_12710360_0\">From what I know, the compiler never optimizes a variable that is declared as volatile. </p>\n</blockquote>\n<p>Your premise is wrong. <code>volatile</code> is a hint to the compiler and doesn't actually guarantee anything. Compilers can choose to prevent some optimizations on <code>volatile</code> variables, but that's it.</p>\n<p><code>volatile</code> isn't a lock, don't try to use it as such.</p>\n<h3>7.1.5.1</h3>\n<blockquote>\n<p id=\"so_12710336_12710360_1\">7) [ Note: volatile is a hint to the implementation to avoid\n  aggressive optimization involving the object because the value of the\n  object might be changed by means undetectable by an implementation.\n  See 1.9 for detailed semantics. In general, the semantics of volatile\n  are intended to be the same in C++ as they are in C. \u2014end note]</p>\n</blockquote>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-10-03T14:30:02.513", "Score": "2", "CreationDate": "2012-10-03T14:12:25.833", "ParentId": "12710336", "CommentCount": "18", "OwnerUserId": "673730", "LastEditDate": "2012-10-03T14:30:02.513"}, "42322084": {"Id": "42322084", "PostTypeId": "2", "Body": "<p>The semantics of <code>volatile</code> are implementation-defined.  If a compiler knew that interrupts would be disabled while certain piece of code was executed, and knew that on the target platform there would be means other than interrupt handlers via which operations on certain storage would be observable, it could register-cache <code>volatile</code>-qualified variables within such storage just the same as it could cache ordinary variables, provided it documented such behavior.</p>\n<p>Note that what aspects of behavior are counted as \"observable\" may be defined in some measure by the implementation.  If an implementation documents that it is not intended for use on hardware which uses main RAM accesses to trigger required externally-visible actions, then accesses to main RAM would not be \"observable\" on that implementation.  The implementation would be compatible with hardware which was capable of physically observing such accesses, if nothing cared whether any such accesses were actually seen.  If such accesses were required, however, as they would be if the accesses were regarded as \"observable\", however, the compiler would not be claiming compatibility and would thus make no promise about anything.</p>\n", "LastActivityDate": "2017-02-19T00:01:12.787", "CommentCount": "0", "CreationDate": "2017-02-19T00:01:12.787", "ParentId": "12710336", "Score": "0", "OwnerUserId": "363751"}, "12710499": {"Id": "12710499", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12710336_12710499_0\">But compiler in principal should not cache a volatile variable, right?</p>\n</blockquote>\n<p>No, the compiler in principle must read/write the address of the variable each time you read/write the variable.</p>\n<p>[Edit: At least, it must do so up to the point at which the the implementation believes that the value at that address is \"observable\". As Dietmar points out in his answer, an implementation might declare that normal memory \"cannot be observed\". This would come as a surprise to people using debuggers, <code>mprotect</code>, or other stuff outside the scope of the standard, but it could conform in principle.]</p>\n<p>In C++03, which does not consider threads at all, it is up to the implementation to define what \"accessing the address\" means when running in a thread. Details like this are called the \"memory model\". Pthreads, for example, allows per-thread caching of the whole of memory, including volatile variables. IIRC, MSVC provides a guarantee that volatile variables of suitable size are atomic, and it will avoid caching (rather, it will flush as far as a single coherent cache for all cores). The reason it provides that guarantee is because it's <em>reasonably</em> cheap to do so on Intel -- Windows only really cares about Intel-based architectures, whereas Posix concerns itself with more exotic stuff.</p>\n<p>C++11 defines a memory model for threading, and it says that this is a data race (i.e. that <code>volatile</code> <em>does not</em> ensure that a read in one thread is sequenced relative to a write in another thread). Two accesses can be sequenced in a particular order, sequenced in unspecified order (the standard might say \"indeterminate order\", I can't remember), or not sequenced at all. Not sequenced at all is bad -- if either of two unsequenced accesses is a write then behavior is undefined.</p>\n<p>The key here is the implied \"and then\" in \"I modify an element from a thread AND THEN the thread reading it does not notice the change\". You're assuming that the operations are sequenced, but they're not. As far as the reading thread is concerned, unless you use some kind of synchronization the write in the other thread hasn't necessarily happened yet. And actually it's worse than that -- you might think from what I just wrote that it's only the order of operations that is unspecified, but actually the behavior of a program with a data race is undefined.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2012-10-03T15:32:11.910", "Score": "5", "CreationDate": "2012-10-03T14:20:52.637", "ParentId": "12710336", "CommentCount": "11", "OwnerUserId": "13005", "LastEditDate": "2012-10-03T15:32:11.910"}, "12710336": {"ViewCount": "1748", "Body": "<p>From what I know, the compiler never optimizes a variable that is declared as <code>volatile</code>. However, I have an array declared like this.</p>\n<pre><code>volatile long array[8];\n</code></pre>\n<p>And different threads read and write to it. An element of the array is only modified by one of the threads and read by any other thread. However, in certain situations I've noticed that even if I modify an element from a thread, the thread reading it does not notice the change. It keeps on reading the same old value, as if compiler has cached it somewhere. But compiler in principal should not cache a volatile variable, right? So how come this is happening.</p>\n<p><strong>NOTE</strong>: I am not using <code>volatile</code> for thread synchronization, so please stop giving me answers such as use a lock or an atomic variable. I know the difference between volatile, atomic variables and mutexes. Also note that the architecture is x86 which has proactive cache coherence. Also I read the variable for long enough after it is supposedly modified by the other thread. Even after a long time, the reading thread can't see the modified value.</p>\n", "AcceptedAnswerId": "12710499", "Title": "Can compiler sometimes cache variable declared as volatile", "CreationDate": "2012-10-03T14:10:35.367", "Id": "12710336", "CommentCount": "18", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-03T17:10:39.527", "LastEditorUserId": "1018562", "LastActivityDate": "2017-02-20T10:08:41.557", "Score": "7", "OwnerUserId": "1018562", "Tags": "<c++><c><multithreading><compiler-construction><x86>", "AnswerCount": "10"}, "12710521": {"Id": "12710521", "PostTypeId": "2", "Body": "<p><code>Volatile</code> Keyword only guarantees that the compiler will not use register for this variable. Thus every access to this variable will go and read the memory location. Now, I assume that you have cache coherence among the multiple processors in your architecture. So if one processor writes and other reads it, then it should be visible under normal conditions. However, you should consider the corner cases. Suppose the variable is in the pipeline of one processor core and other processor is trying to read it assuming that has been written, then there is a problem. So essentially, the shared variables should be either guarded by locks or should be protected by using barrier mechanism correctly.</p>\n", "LastActivityDate": "2012-10-03T14:22:01.770", "CommentCount": "3", "CreationDate": "2012-10-03T14:22:01.770", "ParentId": "12710336", "Score": "1", "OwnerUserId": "1312871"}, "12710450": {"Id": "12710450", "PostTypeId": "2", "Body": "<p>With <code>volatile</code> you can only impose that a variable is re-read whenever you use its value. It doesn't guarantee that the different values/representations that are present on different levels of your architecture are consistent.</p>\n<p>To have such gurantees you'd need the new utilities from C11 and C++1 concerning atomic access and memory barriers. Many compilers implement these already in terms of extension. E.g the gcc family (clang, icc, etc) have builtins starting with prefix <code>__sync</code> to implement these.</p>\n", "LastActivityDate": "2012-10-03T14:17:48.743", "CommentCount": "3", "CreationDate": "2012-10-03T14:17:48.743", "ParentId": "12710336", "Score": "2", "OwnerUserId": "366377"}, "12710546": {"Id": "12710546", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_12710336_12710546_0\">However, in certain situations I've noticed that even if I modify an\n  element from a thread, the thread reading it does not notice the\n  change. It keeps on reading the same old value, as if compiler has\n  cached it somewhere.</p>\n</blockquote>\n<p>This is not because the compiler cached it somewhere, but because the reading thread reads from its CPU core's cache, which might be different from the writing thread's one. To ensure value change propagation across CPU cores, you need to use proper memory fences, and you neither can nor need to use volatile for that in C++.</p>\n", "LastActivityDate": "2012-10-03T14:23:46.643", "CommentCount": "1", "CreationDate": "2012-10-03T14:23:46.643", "ParentId": "12710336", "Score": "0", "OwnerUserId": "182529"}, "22220996": {"Id": "22220996", "PostTypeId": "2", "Body": "<p>Volatile only affects the variable it is in front of. Here in your example, a pointer. Your code: volatile long array[8], the pointer to the first element of the array is volatile, not it's content. (same for objects of any kind)</p>\n<p>you could adapt it like in\n<a href=\"https://stackoverflow.com/questions/2304729/how-do-i-declare-an-array-created-using-malloc-to-be-volatile-in-c\">How do I declare an array created using malloc to be volatile in c++</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-06T10:12:04.310", "Score": "1", "CreationDate": "2014-03-06T10:02:00.857", "ParentId": "12710336", "CommentCount": "0", "OwnerUserId": "3387542", "LastEditDate": "2017-05-23T12:17:05.720"}, "12710939": {"Id": "12710939", "PostTypeId": "2", "Body": "<p><strong>C</strong></p>\n<p>What volatile does:</p>\n<ul>\n<li>Guarantees an up-to-date value in the variable, if the variable is modified from an external source (a hardware register, an interrupt, a different thread, a callback function etc).</li>\n<li>Blocks all optimizations of read/write access to the variable.</li>\n<li>Prevent dangerous optimization bugs that can happen to variables shared between several threads/interrupts/callback functions, when the compiler does not realize that the thread/interrupt/callback is called by the program. (This is particularly common among various questionable embedded system compilers, and when you get this bug it is very hard to track down.)</li>\n</ul>\n<p>What volatile does not:</p>\n<ul>\n<li>It does not guarantee atomic access or any form of thread-safety. </li>\n<li>It cannot be used instead of a mutex/semaphore/guard/critical section. It cannot be used for thread synchronization.</li>\n</ul>\n<p>What volatile may or may not do:</p>\n<ul>\n<li>It may or may not be implemented by the compiler to provide a memory barrier, to protect against instruction cache/instruction pipe/instruction re-ordering issues in a multi-core environment. You should never assume that volatile does this for you, unless the compiler documentation explicitly states that it does. </li>\n</ul>\n", "LastActivityDate": "2012-10-03T14:44:37.957", "CommentCount": "1", "CreationDate": "2012-10-03T14:44:37.957", "ParentId": "12710336", "Score": "3", "OwnerUserId": "584518"}, "12710589": {"Id": "12710589", "PostTypeId": "2", "Body": "<p>The <code>volatile</code> keyword has <strong>nothing</strong> to do with concurrency in C++ <strong>at all</strong>! It is used to have the compiler prevented from making use of the previous value, i.e., the compiler will generate code accessing a <code>volatile</code> value every time is accessed in the code. The main purpose are things like memory mapped I/O. However, use of <code>volatile</code> has <strong>no</strong> affect on what the CPU does when reading normal memory: If the CPU has no reason to believe that the value changed in memory, e.g., because there is no synchronization directive, it can just use the value from its cache. To communicate between threads you need some synchronization, e.g., an <code>std::atomic&lt;T&gt;</code>, lock a <code>std::mutex</code>, etc.</p>\n", "LastEditorUserId": "258009", "LastActivityDate": "2015-09-08T16:16:30.533", "Score": "2", "CreationDate": "2012-10-03T14:25:52.367", "ParentId": "12710336", "CommentCount": "2", "OwnerUserId": "1120273", "LastEditDate": "2015-09-08T16:16:30.533"}});