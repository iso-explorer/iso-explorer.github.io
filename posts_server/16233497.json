post_cb({"16233667": {"ParentId": "16233497", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2013-04-26T09:57:49.690", "Score": "30", "LastEditorUserId": "27835", "LastEditDate": "2013-04-26T18:12:43.977", "Id": "16233667", "OwnerUserId": "27835", "Body": "<p>GCC has two <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\">attributes</a>, <code>pure</code> and <code>const</code>, that may be used to mark such function.  If the function has no side-effect and its result depends only on its arguments, the function should be declared <code>const</code>, if the results may also depend on some global variable the function should be declared <code>pure</code>.  Recent versions also have a <code>-Wsuggest-attribute</code> <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\">warning option</a> that can point functions which ought to be declared <code>const</code> or <code>pure</code>.</p>\n", "LastActivityDate": "2013-04-26T18:12:43.977"}, "16233497": {"CommentCount": "18", "AcceptedAnswerId": "16233667", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-26T09:48:22.543", "LastActivityDate": "2016-01-16T01:00:24.097", "LastEditDate": "2017-05-23T10:30:08.107", "ViewCount": "1740", "FavoriteCount": "13", "Title": "Do C and C++ optimizers typically know which functions have no side effects?", "Id": "16233497", "Score": "41", "Body": "<p>Say for very common math functions, such as sin, cos, etc... does the compiler realise they have no side effects and have the ability to move them to outer loops?  For example</p>\n<pre><code>// Unoptimized\n\ndouble YSinX(double x,int y)\n{\n   double total = 0.0;\n   for (int i = 0; i &lt; y; i++)\n      total += sin(x);\n   return total;\n}\n\n// Manually optimized\n\ndouble YSinX(double x,int y)\n{\n   double total = 0.0, sinx = sin(x);\n   for (int i = 0; i &lt; y; i++)\n      total += sinx;\n   return total;\n}\n</code></pre>\n<p>If they can, is there a way of declaring a function as having no side effects, and hence being safe to optimize in this way?  Initial profiling of a VS2010 app suggests that the optimization is beneficial.</p>\n<p>See also this <a href=\"https://stackoverflow.com/questions/6623879/c-optimizing-function-with-no-side-effects\">related question</a>, which is close but doesn't quite answer my own.</p>\n<p><strong>Edit:</strong> Some great answers.  The one I accepted was based as much on the comments it provoked as the answer itself, notably the linked article, and the fact that hoisting may not occur in situations where <code>errno</code> is set (i.e. a side effect).  As such, and in the context of what I'm doing, this type of manual optimization still appears to make sense.</p>\n", "Tags": "<c++><c><optimization>", "OwnerUserId": "22564", "AnswerCount": "4"}, "16233861": {"ParentId": "16233497", "CommentCount": "1", "CreationDate": "2013-04-26T10:07:02.227", "OwnerUserId": "1922314", "PostTypeId": "2", "Id": "16233861", "Score": "6", "Body": "<p>I think, yes.\nIf you get compiler disassembly output you can see that, sin is called in another label than the loop label for 'for':\n(compiled with g++ -O1 -O2 -O3)</p>\n<pre><code>Leh_func_begin1:\n        pushq   %rbp\nLtmp0:\n        movq    %rsp, %rbp\nLtmp1:\n        pushq   %rbx\n        subq    $8, %rsp\nLtmp2:\n        testl   %edi, %edi\n        jg      LBB1_2\n        pxor    %xmm1, %xmm1\n        jmp     LBB1_4\nLBB1_2:\n        movl    %edi, %ebx\n        callq   _sin ;sin calculated\n        pxor    %xmm1, %xmm1\n        .align  4, 0x90\nLBB1_3:\n        addsd   %xmm0, %xmm1\n        decl    %ebx\n        jne     LBB1_3 ;loops here till i reaches y\nLBB1_4:\n        movapd  %xmm1, %xmm0\n</code></pre>\n<p>I hope i'm correct.</p>\n", "LastActivityDate": "2013-04-26T10:07:02.227"}, "16243147": {"ParentId": "16233497", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-04-26T18:40:36.433", "Score": "7", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:35.210", "Id": "16243147", "OwnerUserId": "103167", "Body": "<p>What is needed to permit hoisting this subexpression outside the loop is not purity, but <a href=\"https://stackoverflow.com/q/1077412/103167\">idempotence</a>.</p>\n<p>Idempotence means that a function will have the same side-effects and result if it is called once as if it is called many times with the same arguments.  Therefore, the compiler can put the function call outside the loop, protected only by a conditional (would the loop iterate at least once?).  The actual code after the hoisting optimization then would be:</p>\n<pre><code>double YSinX(double x,int y)\n{\n   double total = 0.0;\n   int i = 0;\n   if (i &lt; y) {\n       double sinx = sin(x);  // &lt;- this goes between the loop-initialization\n                              // first test of the condition expression\n                              // and the loop body\n       do {\n          total += sinx;\n          i++;\n       } while (i &lt; y);\n   }\n   return total;\n}\n</code></pre>\n<p>The distinction between <code>__attribute__(pure)</code> and <code>idempotent</code> is important because, as adl notes in his comment, these functions do have a side-effect of setting <code>errno</code>.</p>\n<p>Be careful, though, because idempotence only applies to repeated calls with no intervening instructions.  The compiler will have to perform dataflow analysis to prove that the function and the intervening code don't interact (for example, the intervening code uses only locals whose addresses are never taken), before it can take advantage of idempotence.  This isn't necessary when the function is known to be pure.  But purity is a much stronger condition that doesn't apply to very many functions.</p>\n", "LastActivityDate": "2013-04-26T18:56:45.720"}, "16235467": {"ParentId": "16233497", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-04-26T11:35:18.627", "Score": "13", "LastEditorUserId": "1989425", "LastEditDate": "2016-01-16T01:00:24.097", "Id": "16235467", "OwnerUserId": "1989425", "Body": "<p>As a matter of fact, todays common compilers will perform the kind of <a href=\"https://en.wikipedia.org/wiki/Loop-invariant_code_motion\" rel=\"nofollow\">loop-invariant code motion</a> optimisation you're asking about. For a demonstration of this, see the second exercise within <a href=\"http://ridiculousfish.com/blog/posts/will-it-optimize.html\" rel=\"nofollow\">this article entitled \"Will it Optimize?\"</a>. If your VS2010 compiler doesn't perform this optimisation, not to matter; <a href=\"http://llvm.org/builds/\" rel=\"nofollow\">LLVM/Clang \"integrates with MSVC 2010, 2012, 2013 and 14 CTP\"</a>.</p>\n<p>From a theoretical standing, these two quotes explain the scope or headroom that a compiler has when performing optimisations. They're from the C11 standard. IIRC C++11 has something similar.</p>\n<p><strong>\u00a75.1.2.3p4:</strong></p>\n<blockquote>\n<p id=\"so_16233497_16235467_0\">In the abstract machine, all expressions are evaluated as specified by\n  the semantics. An actual implementation need not evaluate part of an\n  expression if it can deduce that its value is not used and that no\n  needed side effects are produced (including any caused by calling a\n  function or accessing a volatile object).</p>\n</blockquote>\n<p><strong>\u00a75.1.2.3p6:</strong></p>\n<blockquote>\n<p id=\"so_16233497_16235467_1\">The least requirements on a conforming implementation are:</p>\n<p id=\"so_16233497_16235467_2\">\u2014 Accesses to volatile objects are evaluated strictly according to the\n  rules of the abstract machine.</p>\n<p id=\"so_16233497_16235467_3\">\u2014 At program termination, all data written into files shall be\n  identical to the result that execution of the program according to the\n  abstract semantics would have produced.</p>\n<p id=\"so_16233497_16235467_4\">\u2014 The input and output dynamics of interactive devices shall take\n  place as specified in\n  7.21.3. The intent of these requirements is that unbuffered or line-buffered output appear as soon as possible, to ensure that\n  prompting messages actually appear prior to a program waiting for\n  input.</p>\n<p id=\"so_16233497_16235467_5\">This is the observable behavior of the program.</p>\n</blockquote>\n<p>Thus, a compiler might hoist your entire program into compile-time evaluation if it can do so. Consider the following program, for example:</p>\n<pre><code>double YSinX(double x,int y)\n{\n    double total = 0.0;\n    for (int i = 0; i &lt; y; i++)\n        total += sin(x);\n    return total;\n}\n\nint main(void) {\n    printf(\"%lf\\n\", YSinX(PI, 4));\n}\n</code></pre>\n<p>Your compiler might realise that this program prints <code>0.0\\n</code> every single time, and optimise your program into :</p>\n<pre><code>int main(void) { puts(\"0.0\"); }\n</code></pre>\n<p>That is, <em>providing</em> your compiler can prove that neither <code>sin</code> nor <code>YsinX</code> cause any <em>needed</em> side-effects. Note that they may (and probably do) still cause side-effects, but they're not <em>needed</em> to produce the output of this program.</p>\n<p>You've asked a question about \"the compiler\". If you're referring to <em>all C or C++ implementations</em>, there are no guaranteed optimisations and a C implementation need not even be a compiler. You'd need to tell us <em>which particular C or C++ implementation</em>; as I mentioned earlier, LLVM/Clang \"integrates with MSVC 2010, 2012, 2013 and 14 CTP\" so it's possible that you might be using that. If your C or C++ compiler doesn't produce optimal code, get a new compiler (e.g. LLVM/Clang) or produce the optimisation yourself, preferably by modifying your compiler so you can send a patch to the developers and have the optimisation automatically propagated to other projects.</p>\n", "LastActivityDate": "2016-01-16T01:00:24.097"}, "bq_ids": {"n4140": {"so_16233497_16235467_0": {"section_id": 5797, "quality": 0.5357142857142857, "length": 15}, "so_16233497_16235467_2": {"section_id": 5804, "quality": 0.8888888888888888, "length": 8}, "so_16233497_16235467_1": {"section_id": 5804, "quality": 0.8, "length": 4}, "so_16233497_16235467_3": {"section_id": 5804, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_16233497_16235467_0": {"section_id": 5570, "quality": 0.5357142857142857, "length": 15}, "so_16233497_16235467_2": {"section_id": 5577, "quality": 0.8888888888888888, "length": 8}, "so_16233497_16235467_1": {"section_id": 5577, "quality": 0.8, "length": 4}, "so_16233497_16235467_3": {"section_id": 5577, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_16233497_16235467_0": {"section_id": 7256, "quality": 0.5357142857142857, "length": 15}, "so_16233497_16235467_3": {"section_id": 7262, "quality": 0.9333333333333333, "length": 14}, "so_16233497_16235467_1": {"section_id": 7262, "quality": 0.8, "length": 4}, "so_16233497_16235467_2": {"section_id": 7262, "quality": 0.8888888888888888, "length": 8}}}});