post_cb({"10297482": {"ParentId": "10297405", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There's no ambiguity because you call <code>Smile()</code> on pointers to <code>FaceOfFuture</code> and <code>FaceOfPast</code> that only declare one method <code>Smile()</code>. </p>\n<p><strong>Because calling the method on a base class pointer can't result in an ambiguity, let's treat the situations when you call the method directly on the child class pointer</strong>:</p>\n<pre><code>Janus* j = new Janus();\nj-&gt;Smile();\n</code></pre>\n<p>The derived class, besides overriding, also hides the base classes' declaration of <code>Smile()</code>. You'd have an ambiguity only if you wouldn't be overriding the method in your derived class:</p>\n<p>The following compiles:</p>\n<pre><code>struct FaceOfPast\n{\n    virtual void Smile() {printf(\":) \");}\n};\nstruct FaceOfFuture\n{\n    virtual void Smile() {printf(\":) \");}\n};\nstruct Janus : public FaceOfPast, public FaceOfFuture\n{\n   virtual void Smile() {printf(\":) \");}\n};\nint main()\n{\n   Janus* j = new Janus();\n   j-&gt;Smile();\n}\n</code></pre>\n<p>Although you call <code>Smile</code> on a <code>Janus</code>, the base class declarations are hidden.</p>\n<p>The following doesn't:</p>\n<pre><code>struct FaceOfPast\n{\n    virtual void Smile() {printf(\":) \");}\n};\n\nstruct FaceOfFuture\n{\n    virtual void Smile() {printf(\":) \");}\n};\n\nstruct Janus : public FaceOfPast, public FaceOfFuture\n{\n};\n\nint main()\n{\n   Janus* j = new Janus();\n   j-&gt;Smile();\n}\n</code></pre>\n<p>Because of the ambiguity.</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "673730", "LastEditDate": "2012-04-24T12:21:44.833", "Id": "10297482", "Score": "7", "CreationDate": "2012-04-24T12:05:42.220", "LastActivityDate": "2012-04-24T12:21:44.833"}, "10298145": {"ParentId": "10297405", "CommentCount": "0", "Body": "<pre><code>Janus* j = new Janus();\nFaceOfFuture* future = j;\nFaceOfPast* past = j;\n</code></pre>\n<p>This section of code casts down to the to a base class. So when you do the following </p>\n<pre><code>future-&gt;Smile();\npast-&gt;Smile();\n</code></pre>\n<p>This is actual a pointer to a FaceofPast and FaceOfFuture.</p>\n", "OwnerUserId": "1209369", "PostTypeId": "2", "Id": "10298145", "Score": "0", "CreationDate": "2012-04-24T12:48:31.180", "LastActivityDate": "2012-04-24T12:48:31.180"}, "bq_ids": {"n4140": {"so_10297405_10300201_0": {"section_id": 7003, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_10297405_10300201_0": {"section_id": 6749, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_10297405_10300201_0": {"section_id": 8500, "quality": 0.9629629629629629, "length": 26}}}, "10300201": {"ParentId": "10297405", "CommentCount": "0", "Body": "<p>According the C++ standard (10.3.2):</p>\n<blockquote>\n<p id=\"so_10297405_10300201_0\">If a virtual member function vf is declared in a class <strong>Base</strong> and in a class <strong>Derived</strong>, derived directly or indirectly from <strong>Base</strong>, a member function <strong>vf</strong> with the same name, parameter-type-list, cv-qualification, and ref-qualifier (or absence of same) as <strong>Base::vf</strong> is declared, then <strong>Derived::vf</strong> [...] overrides <strong>Base::vf</strong>.</p>\n</blockquote>\n<p>There doesn't seem to be any special treatment for multiple inheritance, so it most probably apply here too: <code>void Janus::Smile()</code> overrides both methods without any ambiguity, just because it has the exact same name and signature as both base class methods.</p>\n", "OwnerUserId": "894321", "PostTypeId": "2", "Id": "10300201", "Score": "1", "CreationDate": "2012-04-24T14:38:41.537", "LastActivityDate": "2012-04-24T14:38:41.537"}, "10297405": {"CommentCount": "0", "AcceptedAnswerId": "10297482", "PostTypeId": "1", "LastEditorUserId": "20984", "CreationDate": "2012-04-24T12:00:10.823", "LastActivityDate": "2012-04-24T14:38:41.537", "LastEditDate": "2012-04-24T12:37:54.920", "ViewCount": "131", "FavoriteCount": "2", "Title": "Multiple inheritance: 2Classes1Method", "Id": "10297405", "Score": "10", "Body": "<p>I've just tried this piece of code:</p>\n<pre><code>struct FaceOfPast\n{\n    virtual void Smile() = 0;\n};\n\nstruct FaceOfFuture\n{\n    virtual void Smile() = 0;\n};\n\nstruct Janus : public FaceOfPast, public FaceOfFuture\n{\n    virtual void Smile() {printf(\":) \");}\n};\n</code></pre>\n<p>...</p>\n<pre><code>void main()\n{\n    Janus* j = new Janus();\n    FaceOfFuture* future = j;\n    FaceOfPast* past = j;\n\n    future-&gt;Smile();\n    past-&gt;Smile();\n\n    delete j;\n}\n</code></pre>\n<p>It works as intended (outputs two smiley faces), but I don't think it should even compile, redeclaration of <code>Smile()</code> in <code>Janus</code> being ambiguous.</p>\n<p>How (and why) does it work?</p>\n", "Tags": "<c++>", "OwnerUserId": "1268928", "AnswerCount": "3"}});