post_cb({"37127988": {"CommentCount": "2", "ViewCount": "61", "CreationDate": "2016-05-10T01:42:41.223", "LastActivityDate": "2016-05-10T02:17:54.227", "Title": "same-length same-signedness integer types in template parameters", "AcceptedAnswerId": "37128054", "PostTypeId": "1", "Id": "37127988", "Score": "2", "Body": "<p>When being used as template parameters, are integer types of the same length and the same signedness considered equal, i.e., do they produce the same template class when being used as a template parameter? Which paragraph of the spec handles this case?</p>\n<p>E.g., consider I am on an architecture on which <code>unsigned</code> and <code>unsigned long</code> are both 32-bit, then will for example a <code>vector&lt;unsigned&gt;</code> be another class as a <code>vector&lt;unsigned long&gt;</code> or will they be treated as the same type? </p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "1408611", "AnswerCount": "2"}, "37128247": {"ParentId": "37127988", "CommentCount": "1", "Body": "<p>If you do a blind type-cast between different integer types then the cast will work sometimes, but necessarily every time.  This is because different types have different minimum and maximum values.  Type casting will be allowed by most compilers but they will use rules that you may not be familiar with resulting in potentially unexpected behaviour.  The best thing to do is to research these types and then ensure that any code you write that converts between them prevents unpredictable results.</p>\n", "OwnerUserId": "6312978", "PostTypeId": "2", "Id": "37128247", "Score": "0", "CreationDate": "2016-05-10T02:17:54.227", "LastActivityDate": "2016-05-10T02:17:54.227"}, "37128054": {"ParentId": "37127988", "CommentCount": "1", "Body": "<p>The types <code>unsigned int</code> and <code>unsigned long</code> are guaranteed to be different types. This is clarified by a note in the standard:</p>\n<blockquote>\n<p id=\"so_37127988_37128054_0\">Even if the implementation defines two or more basic types to have the same value representation,\n  they are nevertheless different types.</p>\n</blockquote>\n<p>([basic.fundamental]/11)</p>\n<p>In general, two types are only the same if one is aliased to the other (<em>i.e.,</em> with <code>typedef</code> or <code>using</code>) or if both are aliased to the same type.</p>\n<p>Given that <code>unsigned int</code> and <code>unsigned long</code> are different types, <code>vector&lt;unsigned int&gt;</code> and <code>vector&lt;unsigned long&gt;</code> are also different types, even if the two classes have identical layouts.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "37128054", "Score": "2", "CreationDate": "2016-05-10T01:52:29.347", "LastActivityDate": "2016-05-10T01:52:29.347"}, "bq_ids": {"n4140": {"so_37127988_37128054_0": {"section_id": 7220, "quality": 1.0, "length": 15}}, "n3337": {"so_37127988_37128054_0": {"section_id": 6964, "quality": 1.0, "length": 15}}, "n4659": {"so_37127988_37128054_0": {"section_id": 8729, "quality": 1.0, "length": 15}}}});