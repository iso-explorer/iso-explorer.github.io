post_cb({"6136130": {"ParentId": "6136010", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2011-05-26T09:07:13.100", "Score": "11", "LastEditorUserId": "165520", "LastEditDate": "2011-05-26T09:18:30.430", "Id": "6136130", "OwnerUserId": "165520", "Body": "<p>Your code is not portable. It might work on some compilers or it might not.</p>\n<p>You are right about the behaviour being undefined when you try to access the inactive member of the union [as it is in the case of the code given]</p>\n<p>$9.5/1</p>\n<blockquote>\n<p id=\"so_6136010_6136130_0\">In a union, <strong>at most one of the data members can be active at any time</strong>, that is, the value of at most one of the data members can be stored in a union at any time.</p>\n</blockquote>\n<p>So <code>foo.c[0] == 1</code> is incorrect because <code>c</code> is not active at that moment. Feel free to correct me if you think I am wrong.</p>\n", "LastActivityDate": "2011-05-26T09:18:30.430"}, "6136328": {"ParentId": "6136010", "CommentCount": "1", "CreationDate": "2011-05-26T09:23:03.530", "OwnerUserId": "636019", "PostTypeId": "2", "Id": "6136328", "Score": "2", "Body": "<p>You're correct that that code doesn't have well-defined behavior. Here's how to do it portably:</p>\n<pre><code>#include &lt;cstring&gt;\n\nbool is_big_endian()\n{\n    static unsigned const i = 1u;\n    char c[sizeof(unsigned)] = { };\n    std::memcpy(c, &amp;i, sizeof(c));\n    return !c[0];\n}\n\n// or, alternatively\n\nbool is_big_endian()\n{\n    static unsigned const i = 1u;\n    return !*static_cast&lt;char const*&gt;(static_cast&lt;void const*&gt;(&amp;i));\n}\n</code></pre>\n", "LastActivityDate": "2011-05-26T09:23:03.530"}, "10351921": {"ParentId": "6136010", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-04-27T13:51:48.073", "Score": "4", "LastEditorUserId": "1025391", "LastEditDate": "2012-09-04T19:27:54.820", "Id": "10351921", "OwnerUserId": "1025391", "Body": "<p>Don't do this, better use something like the following:</p>\n<pre><code>#include &lt;arpa/inet.h&gt;\n//#include &lt;winsock2.h&gt; // &lt;-- for Windows use this instead\n\n#include &lt;stdint.h&gt;\n\nbool is_big_endian() {\n  uint32_t i = 1;\n  return i == htonl(i);\n}\n</code></pre>\n<hr>\n<p>Explanation: </p>\n<blockquote>\n<p id=\"so_6136010_10351921_0\">The htonl function converts a u_long from host to TCP/IP network byte order (which is big-endian).</p>\n</blockquote>\n<hr>\n<p>References:</p>\n<ul>\n<li><a href=\"http://linux.die.net/man/3/htonl\" rel=\"nofollow\">http://linux.die.net/man/3/htonl</a></li>\n<li><a href=\"http://msdn.microsoft.com/de-de/library/ms738556%28v=vs.85%29.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/de-de/library/ms738556%28v=vs.85%29.aspx</a></li>\n</ul>\n</hr></hr>", "LastActivityDate": "2012-09-04T19:27:54.820"}, "6136374": {"ParentId": "6136010", "CommentCount": "1", "CreationDate": "2011-05-26T09:26:09.057", "OwnerUserId": "584518", "PostTypeId": "2", "Id": "6136374", "Score": "1", "Body": "<p>The C standard only says this (6.7.2.1.12):</p>\n<blockquote>\n<p id=\"so_6136010_6136374_0\">Each non-bit-field member of a\n  structure or union object is aligned\n  in an implementation-defined manner\n  appropriate to its type.</p>\n</blockquote>\n<p>Based on this, I would say that the behavior of your particular union is well-defined. Since the compiler is not allowed to add padding bytes at the beginning of a struct/union, the int will be aligned towards the start of the union, as so will the char array. </p>\n<p>The only way for the compiler to implement this particular union in a way that wouldn't be portable, is to use a char type larger than 8 bits.</p>\n", "LastActivityDate": "2011-05-26T09:26:09.057"}, "6136209": {"ParentId": "6136010", "CommentCount": "1", "CreationDate": "2011-05-26T09:13:28.003", "OwnerUserId": "97642", "PostTypeId": "2", "Id": "6136209", "Score": "0", "Body": "<p>The function should be named is_little_endian. I think you can use this union trick. Or also a cast to char.</p>\n", "LastActivityDate": "2011-05-26T09:13:28.003"}, "6136010": {"CommentCount": "6", "AcceptedAnswerId": "6136130", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2011-05-26T08:57:39.267", "LastActivityDate": "2012-09-25T23:27:45.980", "LastEditDate": "2012-09-25T23:27:45.980", "ViewCount": "2052", "FavoriteCount": "2", "Title": "Is using an union in place of a cast well defined?", "Id": "6136010", "Score": "13", "Body": "<p>I had a discussion this morning with a colleague regarding the correctness of a \"coding trick\" to detect endianness.</p>\n<p>The trick was:</p>\n<pre><code>bool is_big_endian()\n{\n  union\n  {\n    int i;\n    char c[sizeof(int)];\n  } foo;\n\n\n  foo.i = 1;\n  return (foo.c[0] == 1);\n}\n</code></pre>\n<p>To me, it seems that this usage of an <code>union</code> is incorrect because setting one member of the union and reading another is <strong>not</strong> well-defined. But I have to admit that this is just a feeling and I lack actual proofs to strengthen my point.</p>\n<p>Is this trick correct ? Who is right here ?</p>\n", "Tags": "<c++><standards><endianness><unions>", "OwnerUserId": "279259", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_6136010_6136130_0": {"section_id": 5913, "quality": 1.0, "length": 17}}, "n3337": {"so_6136010_6136130_0": {"section_id": 5685, "quality": 1.0, "length": 17}}, "n4659": {"so_6136010_6136130_0": {"section_id": 7404, "quality": 1.0, "length": 17}}}, "6137616": {"ParentId": "6136010", "CommentCount": "0", "CreationDate": "2011-05-26T11:16:05.900", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "6137616", "Score": "0", "Body": "<p>The code has undefined behavior, although some (most?) compilers will\ndefine it, at least in limited cases.</p>\n<p>The <i>intent</i> of the standard is that <code>reinterpret_cast</code> be used for\nthis.  This intent isn't well expressed, however, since the standard\ncan't really define the behavior; there is no desire to define it when\nthe hardware won't support it (e.g. because of alignment issues).  And\nit's also clear that you can't just <code>reinterpret_cast</code> between two\narbitrary types and expect it to work.</p>\n<p>From a quality of implementation point of view, I would expect both the\n<code>union</code> trick and <code>reinterpret_cast</code> to work, <em>if</em> the <code>union</code> or the\n<code>reinterpret_cast</code> is in the same functional block; the <code>union</code> should\nwork as long as the compiler can see that the ultimate type is a <code>union</code>\n(although I've used compilers where this wasn't the case).</p>\n", "LastActivityDate": "2011-05-26T11:16:05.900"}});