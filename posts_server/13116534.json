post_cb({"13116534": {"CommentCount": "0", "ViewCount": "230", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-29T05:53:18.457", "LastActivityDate": "2012-10-29T06:33:54.497", "Title": "Can a unique_ptr be used with a negative index without leaking memory?", "AcceptedAnswerId": "13116656", "LastEditDate": "2017-05-23T11:55:56.487", "Id": "13116534", "Score": "1", "Body": "<p>I read <a href=\"https://stackoverflow.com/questions/3473675/negative-array-indexes-in-c\">Are negative array indexes allowed in C?</a> and found it interesting that negative values can be used for the index of an array. I tried it again with the c++11 <code>unique_ptr</code> and it works there as well! Of course the deleter must be replaced with something which can delete the original array. Here is what it looks like:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nint main()\n{\n    const int min = -23; // the smaller valid index\n    const int max = -21; // the highest valid index\n    const auto deleter = [min](char* p)\n    {\n        delete [](p+min);\n    };\n    std::unique_ptr&lt;char[],decltype(deleter)&gt; up(new char[max-min+1] - min, deleter);\n\n    // this works as expected\n    up[-23] = 'h'; up[-22] = 'i'; up[-21] = 0;\n    std::cout &lt;&lt; (up.get()-23) &lt;&lt; '\\n'; // outputs:hi\n}\n</code></pre>\n<p>I'm wondering if there is a very, very small chance that there is a memory leak. The address of the memory created on the heap (<code>new char[max-min+1]</code>) could overflow when adding 23 to it and become a null pointer. Subtracting 23 still yields the array's original address, but the <code>unique_ptr</code> may recognize it as a null pointer. The <code>unique_ptr</code> may not delete it because it's null.</p>\n<p>So, is there a chance that the previous code will leak memory or does the smart pointer behave in a way which makes it safe?</p>\n<p>Note: I wouldn't actually use this in actual code; I'm just interested in how it would behave.</p>\n", "Tags": "<c++><memory-leaks><c++11><smart-pointers>", "OwnerUserId": "1721424", "AnswerCount": "2"}, "13116720": {"ParentId": "13116534", "CommentCount": "7", "Body": "<p><code>new char[max-min+1]</code> doesn't allocate memory on the stack but rather on heap - that's how standard <code>operator new</code> behaves. The expression <code>max-min+1</code> is evaluated by the compiler and results in <code>3</code>, so eventually this expression is equal to allocating 3 bytes on the heap. No problem here.</p>\n<p>However, subtracting <code>min</code> results in pointer which is 23 bytes beyond the beginning of the allocated memory returned by <code>new</code> and since in new you allocated only 3 bytes, this will definitely point to a location not owned by you --&gt; anything following will result in undefined behavior.</p>\n", "OwnerUserId": "1756636", "PostTypeId": "2", "Id": "13116720", "Score": "3", "CreationDate": "2012-10-29T06:16:32.553", "LastActivityDate": "2012-10-29T06:16:32.553"}, "13116656": {"ParentId": "13116534", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><strong>Edit:</strong> <a href=\"https://stackoverflow.com/a/13116720/500104\">icepack</a> brings up an interesting point, namely that there are only two valid pointer values that are allowed in pointer arithmetic:</p>\n<p><code>\u00a75.7 [expr.add] p5</code></p>\n<blockquote>\n<p id=\"so_13116534_13116656_0\">If both the pointer operand <strong>and the result</strong> point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is undefined</strong>.</p>\n</blockquote>\n<p>As such, the <code>new char[N] - min</code> of your code already invokes UB.</p>\n<hr>\n<p>Now, on most implementations, this will not cause problems. The destructor of <code>std::unique_ptr</code>, however, will (pre-edit answer from here on out):</p>\n<p><code>\u00a720.7.1.2.2 [unique.ptr.single.dtor] p2</code></p>\n<blockquote>\n<p id=\"so_13116534_13116656_1\">Effects: If <code>get() == nullptr</code> there are no effects. Otherwise <code>get_deleter()(get())</code>.</p>\n</blockquote>\n<p>So yes, there is a chance that you will leak memory here if it indeed maps to whatever value represents the null pointer value (most likely <code>0</code>,  but not necessarily). And yes, I know this is the one for single objects, but the array one behaves exactly the same:</p>\n<p><code>\u00a720.7.1.3 [unique.ptr.runtime] p2</code></p>\n<blockquote>\n<p id=\"so_13116534_13116656_2\">Descriptions are provided below only for member functions that have behavior different from the primary template.</p>\n</blockquote>\n<p>And there is no description for the destructor.</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:21:18.543", "Id": "13116656", "Score": "4", "CreationDate": "2012-10-29T06:08:31.280", "LastActivityDate": "2012-10-29T06:33:54.497"}, "bq_ids": {"n4140": {"so_13116534_13116656_0": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_13116534_13116656_1": {"section_id": 4319, "quality": 0.8571428571428571, "length": 6}, "so_13116534_13116656_2": {"section_id": 4346, "quality": 1.0, "length": 10}}, "n3337": {"so_13116534_13116656_0": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_13116534_13116656_1": {"section_id": 4160, "quality": 0.8571428571428571, "length": 6}, "so_13116534_13116656_2": {"section_id": 4187, "quality": 1.0, "length": 10}}, "n4659": {"so_13116534_13116656_0": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_13116534_13116656_1": {"section_id": 5576, "quality": 0.8571428571428571, "length": 6}}}});