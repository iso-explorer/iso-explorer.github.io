post_cb({"bq_ids": {"n4140": {"so_16260033_16260033_2": {"length": 4, "quality": 1.0, "section_id": 45}, "so_16260033_16260033_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_16260033_16260033_2": {"length": 4, "quality": 1.0, "section_id": 42}, "so_16260033_16260033_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_16260033_16260033_2": {"length": 4, "quality": 1.0, "section_id": 46}, "so_16260033_16260033_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "16260141": {"Id": "16260141", "PostTypeId": "2", "Body": "<p>If <code>uint8_t</code> exists at all, essentially the only choice is that it's a typedef for <code>unsigned char</code> (or <code>char</code> if it happens to be unsigned). Nothing (but a bitfield) can represent less storage than a <code>char</code>, and the only other type that can be as small as 8 bits is a <code>bool</code>. The next smallest normal integer type is a <code>short</code>, which must be at least 16 bits.</p>\n<p>As such, if <code>uint8_t</code> exists at all, you really only have two possibilities: you're either casting <code>unsigned char</code> to <code>unsigned char</code>, or casting <code>signed char</code> to <code>unsigned char</code>.</p>\n<p>The former is an identity conversion, so obviously safe. The latter falls within the \"special dispensation\" given for accessing any other type as a sequence of char or unsigned char in \u00a73.10/10, so it also gives defined behavior.</p>\n<p>Since that includes both <code>char</code> and <code>unsigned char</code>, a cast to access it as a sequence of char also gives defined behavior.</p>\n<p>Edit: As far as Luc's mention of extended integer types goes, I'm not sure how you'd manage to apply it to get a difference in this case. C++ refers to the C99 standard for the definitions of <code>uint8_t</code> and such, so the quotes throughout the remainder of this come from C99.</p>\n<p>\u00a76.2.6.1/3 specifies that <code>unsigned char</code> shall use a pure binary representation, with no padding bits. Padding bits are only allowed in 6.2.6.2/1, which specifically excludes <code>unsigned char</code>. That section, however, describes a pure binary representation in detail -- literally to the bit. Therefore, <code>unsigned char</code> and <code>uint8_t</code> (if it exists) must be represented identically at the bit level.</p>\n<p>To see a difference between the two, we have to assert that some particular bits when viewed as one would produce results different from when viewed as the other -- despite the fact that the two must have identical representations at the bit level.</p>\n<p>To put it more directly: a difference in result between the two requires that they interpret bits differently -- despite a direct requirement that they interpret bits identically.</p>\n<p>Even on a purely theoretical level, this appears difficult to achieve. On anything approaching a practical level, it's obviously ridiculous.</p>\n", "LastEditorUserId": "1137388", "LastActivityDate": "2013-05-06T21:56:07.240", "Score": "18", "CreationDate": "2013-04-28T06:06:29.057", "ParentId": "16260033", "CommentCount": "11", "OwnerUserId": "179910", "LastEditDate": "2013-05-06T21:56:07.240"}, "16261758": {"Id": "16261758", "PostTypeId": "2", "Body": "<p>Ok, let's get truly pedantic. After reading <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">this</a>, <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow noreferrer\">this</a> and <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html\" rel=\"nofollow noreferrer\">this</a>, I'm pretty confident that I understand the intention behind both Standards.</p>\n<p>So, doing <code>reinterpret_cast</code> from <code>std::uint8_t*</code> to <code>char*</code> and then dereferencing the resulting pointer is <strong>safe</strong> and <strong>portable</strong> and is explicitly permitted by <a href=\"http://eel.is/c++draft/basic.lval#8.8\" rel=\"nofollow noreferrer\">[basic.lval]</a>.</p>\n<p>However, doing <code>reinterpret_cast</code> from <code>char*</code> to <code>std::uint8_t*</code> and then dereferencing the resulting pointer is a violation of <strong>strict aliasing rule</strong> and is <strong>undefined behavior</strong> if <code>std::uint8_t</code> is implemented as <em>extended unsigned integer type</em>.</p>\n<p>However, there is two possible workarounds, first:</p>\n<pre><code>static_assert(std::is_same_v&lt;std::uint8_t, unsigned char&gt; || \\\n\"This library requires std::uint8_t to be implemented as unsigned char.\");\n</code></pre>\n<p>With this assert in place, your code will not compile on platforms on which it would result in undefined behavior otherwise.</p>\n<p>Second:</p>\n<pre><code>std::memcpy(uint8buffer, charbuffer, size);\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/string/byte/memcpy\" rel=\"nofollow noreferrer\">Cppreference</a> says that <code>std::memcpy</code> accesses objects as arrays of <code>unsigned char</code> so it is <strong>safe</strong> and <strong>portable</strong>.</p>\n<p>To reiterate, in order to be able to <code>reinterpret_cast</code> between <code>char*</code> and <code>std::uint8_t*</code> and work with resulting pointers <strong>portably</strong> and <strong>safely</strong> in a 100% standard-conforming way, the following conditions must be true:</p>\n<ul>\n<li><code>CHAR_BIT == 8</code>.</li>\n<li><code>std::uint8_t</code> is defined.</li>\n<li><code>std::uint8_t</code> is implemented as <code>unsigned char</code>.</li>\n</ul>\n<p>On a practical note, the above conditions are true on 99% of platforms and there is likely no platform on which the first 2 conditions are true while the 3rd one is false.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-09T08:11:37.427", "Score": "22", "CreationDate": "2013-04-28T10:06:53.573", "ParentId": "16260033", "CommentCount": "2", "OwnerUserId": "3624760", "LastEditDate": "2017-05-23T11:47:05.107"}, "16260033": {"ViewCount": "8332", "Body": "<p>Now we all sometimes have to work with binary data. In C++ we work with sequences of bytes, and since the beginning <code>char</code> was the our building block. Defined to have <code>sizeof</code> of 1, it is the byte. And all library I/O functions use <code>char</code> by default. All is good but there was always a little concern, a little oddity that bugged some people - the number of bits in a byte is implementation-defined.</p>\n<p>So in C99, it was decided to introduce several typedefs to let the developers easily express themselves, the fixed-width integer types. Optional, of course, since we never want to hurt portability. Among them, <code>uint8_t</code>, migrated into C++11 as <code>std::uint8_t</code>, a fixed width 8-bit unsigned integer type, was the perfect choice for people who really wanted to work with 8 bit bytes.</p>\n<p>And so, developers embraced the new tools and started building libraries that expressively state that they accept 8-bit byte sequences, as <code>std::uint8_t*</code>, <code>std::vector&lt;std::uint8_t&gt;</code> or otherwise.</p>\n<p>But, perhaps with a very deep thought, the standardization committee decided not to require implementation of <code>std::char_traits&lt;std::uint8_t&gt;</code> therefore prohibiting developers from easily and portably instantiating, say, <code>std::basic_fstream&lt;std::uint8_t&gt;</code> and easily reading <code>std::uint8_t</code>s as a binary data. Or maybe, some of us don't care about the number of bits in a byte and are happy with it.</p>\n<p>But unfortunately, two worlds collide and sometimes you have to take a data as <code>char*</code> and pass it to a library that expects <code>std::uint8_t*</code>. But wait, you say, isn't <code>char</code> variable bit and <code>std::uint8_t</code> is fixed to 8? Will it result into a loss of data? </p>\n<p>Well, there is an interesting Standardese on this. The <code>char</code> defined to hold exactly one byte and byte is the lowest addressable chunk of memory, so there can't be a type with bit width lesser than that of <code>char</code>. Next, it is defined to be able to hold UTF-8 code units. This gives us the minimum - 8 bits. So now we have a typedef which is required to be 8 bits wide and a type that is at least 8 bits wide. But are there alternatives? Yes, <code>unsigned char</code>. Remember that signedness of <code>char</code> is implementation-defined. Any other type? Thankfully, no. All other integral types have required ranges which fall outside of 8 bits.</p>\n<p>Finally, <code>std::uint8_t</code> is optional, that means that the library which uses this type will not compile if it's not defined. But what if it compiles? I can say with a great degree of confidence that this means that we are on a platform with 8 bit bytes and <code>CHAR_BIT == 8</code>.</p>\n<p>Once we have this knowledge, that we have 8-bit bytes, that <code>std::uint8_t</code> is implemented as either <code>char</code> or <code>unsigned char</code>, can we assume that we can do <code>reinterpret_cast</code> from <code>char*</code> to <code>std::uint8_t*</code> and vice versa? Is it portable?</p>\n<p>This is where my Standardese reading skills fail me. I read about safely derived pointers (<code>[basic.stc.dynamic.safety]</code>) and, as far as I understand, the following:</p>\n<pre><code>std::uint8_t* buffer = /* ... */ ;\nchar* buffer2 = reinterpret_cast&lt;char*&gt;(buffer);\nstd::uint8_t buffer3 = reinterpret_cast&lt;std::uint8_t*&gt;(buffer2);\n</code></pre>\n<p>is safe if we don't touch <code>buffer2</code>. Correct me if I'm wrong.</p>\n<p>So, given the following preconditions:</p>\n<ul>\n<li><code>CHAR_BIT == 8</code></li>\n<li><code>std::uint8_t</code> is defined.</li>\n</ul>\n<p>Is it portable and safe to cast <code>char*</code> and <code>std::uint8_t*</code> back and forth, assuming that we're working with binary data and the potential lack of sign of <code>char</code> doesn't matter?</p>\n<p>I would appreciate references to the Standard with explanations.</p>\n<p>EDIT: Thanks, Jerry Coffin. I'm going to add the quote from the Standard ([basic.lval], \u00a73.10/10):</p>\n<blockquote>\n<p id=\"so_16260033_16260033_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the\n  following types the behavior is undefined:</p>\n<p id=\"so_16260033_16260033_1\">...</p>\n<p id=\"so_16260033_16260033_2\">\u2014 a char or unsigned char type.</p>\n</blockquote>\n<p>EDIT2: Ok, going deeper. <code>std::uint8_t</code> is not guaranteed to be a typedef of <code>unsigned char</code>. It can be implemented as <em>extended unsigned integer type</em> and extended unsigned integer types are not included in \u00a73.10/10. What now?</p>\n", "AcceptedAnswerId": "16261758", "Title": "reinterpret_cast between char* and std::uint8_t* - safe?", "CreationDate": "2013-04-28T05:46:27.157", "Id": "16260033", "CommentCount": "9", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2017-05-09T08:01:13.253", "LastEditorUserId": "3624760", "LastActivityDate": "2017-05-09T08:11:37.427", "Score": "50", "OwnerUserId": "3624760", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "3"}, "16435175": {"Id": "16435175", "PostTypeId": "2", "Body": "<h3>I <a href=\"https://stackoverflow.com/questions/16138237/when-is-uint8-t-unsigned-char\">asked a question a couple weeks ago</a> that contains the answer to yours.</h3>\n<p>Take a look at <a href=\"https://stackoverflow.com/a/16138470/541686\">R.'s answer</a>, which explains that <code>uint8_t</code> does <strong>not</strong> need to have the same representation as <code>unsigned char</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-08T07:38:23.797", "Score": "1", "CreationDate": "2013-05-08T07:38:23.797", "ParentId": "16260033", "CommentCount": "0", "OwnerUserId": "541686", "LastEditDate": "2017-05-23T12:18:10.873"}});