post_cb({"2299591": {"ParentId": "2299523", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It fails at 2). Member function of templates are instantiated when called.</p>\n<p>More precisely: When a class template is instantiated, the declaration of its member functions are instantiated, but not their definition. The definition is instantiated when the function is used.</p>\n", "OwnerUserId": "59781", "LastEditorUserId": "59781", "LastEditDate": "2010-02-19T21:18:29.477", "Id": "2299591", "Score": "3", "CreationDate": "2010-02-19T21:11:58.867", "LastActivityDate": "2010-02-19T21:18:29.477"}, "2299523": {"CommentCount": "3", "ViewCount": "111", "PostTypeId": "1", "LastEditorUserId": "97786", "CreationDate": "2010-02-19T21:00:20.500", "LastActivityDate": "2010-02-19T21:18:42.600", "Title": "Why does function calls to templatized base classes not work?", "AcceptedAnswerId": "2299591", "LastEditDate": "2010-02-19T21:01:55.413", "Id": "2299523", "Score": "2", "Body": "<p>Consider the following example:</p>\n<pre><code>template &lt;typename T&gt;\nclass A {\n    public:\n        void f() {\n            cout &lt;&lt; \"A::f()\\n\";\n        }\n};\n\ntemplate&lt;&gt;\nclass A&lt;int&gt; {\n};\n\ntemplate&lt;typename T&gt;\nclass B: public A&lt;T&gt; {\n    public:\n        void g() {\n            cout &lt;&lt; \"B::g()\\n\";\n            A&lt;T&gt;::f();\n        }\n};\n\nint main() {\n    B&lt;int&gt; b;     // (1)\n    b.g();        // (2)\n\n    return 0;\n}\n</code></pre>\n<p>Obviously the call to A::f() inside B::g() will fail for int template type. My question is at what point does the call fail? At (1) or (2)? I thought it should be (1) because at that point the compiler creates a new class with the template type int and compiles it. That compilation should fail in f() correct?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "236215", "AnswerCount": "2"}, "2299660": {"ParentId": "2299523", "CommentCount": "1", "Body": "<p>It will fail at (2), and this is guaranteed by the standard. In section 14.7.1/1, it says instantiating a template class does <em>not</em> instantiate it's members definitions. That will only happen once the member is used.</p>\n<p>If you remove (2) from the code, it will compile.</p>\n<blockquote>\n<p id=\"so_2299523_2299660_0\">14.7.1/1 excerpt:<br>\n  The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, <strong>but not of the definitions or default arguments, of the class member functions, member classes, static data members and member templates</strong>; and it causes the implicit instantiation of the definitions of member anonymous unions.</br></p>\n</blockquote>\n<p>Emphasis mine.</p>\n<hr>\n<p>Visual Studio's diagnosis is misleading. It will say <code>see reference to class template instantiation 'B&lt;T&gt;' being compiled</code>. What it means is not \"I'm failing at the instantiation of <code>B&lt;T&gt;</code>\", but \"I'm failing at instantiating a member of the class <code>B&lt;T&gt;</code>\"</p>\n</hr>", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "2299660", "Score": "4", "CreationDate": "2010-02-19T21:18:42.600", "LastActivityDate": "2010-02-19T21:18:42.600"}, "bq_ids": {"n4140": {"so_2299523_2299660_0": {"section_id": 233, "quality": 0.9090909090909091, "length": 30}}, "n3337": {"so_2299523_2299660_0": {"section_id": 226, "quality": 0.9090909090909091, "length": 30}}, "n4659": {"so_2299523_2299660_0": {"section_id": 243, "quality": 0.9090909090909091, "length": 30}}}});