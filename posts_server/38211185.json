post_cb({"38211309": {"ParentId": "38211185", "CommentCount": "0", "Body": "<p>Construction always starts from the base <code>class</code>. If there are multiple base <code>class</code>es then, it starts from the left most base. (<strong>side note</strong>: If there is a <code>virtual</code> inheritance then it's given higher preference). Then it comes the turn for member fields. They are initialized in the order they are declared. At the last the <code>class</code> itself is constructed. </p>\n<p>The order of destructor is exactly reverse</p>\n", "OwnerUserId": "3883931", "PostTypeId": "2", "Id": "38211309", "Score": "1", "CreationDate": "2016-07-05T19:33:28.577", "LastActivityDate": "2016-07-05T19:33:28.577"}, "38211406": {"ParentId": "38211185", "CommentCount": "0", "Body": "<p>N4594 12.6.2/13:</p>\n<blockquote>\n<p id=\"so_38211185_38211406_0\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<ul>\n<li><strong>First</strong>, and only for the constructor of the most derived class (1.8), <strong>virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes</strong>,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list .</li>\n<li>Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list\n  (regardless of the order of the mem-initializers).</li>\n<li>Then, non-static data members are initialized in the order they were declared in the class definition\n  (again regardless of the order of the mem-initializers).</li>\n<li>Finally, the compound-statement of the constructor body is executed.</li>\n</ul>\n<p id=\"so_38211185_38211406_1\">[ Note: The declaration order is mandated to ensure that base and member subobjects are destroyed in the\n  reverse order of initialization. \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "4932834", "PostTypeId": "2", "Id": "38211406", "Score": "2", "CreationDate": "2016-07-05T19:39:12.357", "LastActivityDate": "2016-07-05T19:39:12.357"}, "38211316": {"ParentId": "38211185", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>With virtual inheritance, constructor of the virtual class is called only in the most derived class.</p>\n<p>And order of initialization doesn't depend of order of initialization list, but to the order of declaration inside the class.</p>\n", "OwnerUserId": "2684539", "LastEditorUserId": "2684539", "LastEditDate": "2016-07-05T19:52:35.857", "Id": "38211316", "Score": "0", "CreationDate": "2016-07-05T19:33:40.777", "LastActivityDate": "2016-07-05T19:52:35.857"}, "38211391": {"ParentId": "38211185", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_38211185_38211391_0\">Since B inherits A, A() will be called first, of all. Then B's\n  constructor will be called.</p>\n</blockquote>\n<p>This is not quite true when <code>A</code> is virtually inherited.</p>\n<p>When a class is virtually inherited, it is effectively inherited by the most derived class, for the purpose of invoking constructors and destructors. That's what virtual inheritance between.</p>\n<p>Since <code>D</code> derives from <code>B</code> and <code>C</code>, in that class hierarchy <code>D</code> inherits <code>A</code> when it comes to invoking constructors and destructors, because <code>D</code> is the most-derived class.</p>\n", "OwnerUserId": "3943312", "PostTypeId": "2", "Id": "38211391", "Score": "0", "CreationDate": "2016-07-05T19:38:21.480", "LastActivityDate": "2016-07-05T19:38:21.480"}, "38211185": {"CommentCount": "0", "ViewCount": "132", "CreationDate": "2016-07-05T19:27:19.217", "LastActivityDate": "2016-07-05T19:52:35.857", "Title": "How members of grandparent class are treated in case of virtual inheritance?", "PostTypeId": "1", "Id": "38211185", "Score": "1", "Body": "<p>I read the following piece of code somewhere, as an example to solve the diamond problem in case of multiple inheritance : </p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\nint x;\n\npublic:\n    A() {}\n    A(int i) { x = i; }\n    void print() { cout &lt;&lt; x; }\n};\n\nclass B: virtual public A\n{\npublic:\n    B():A(10) { }\n};\n\nclass C: virtual public A \n{\npublic:\n    C():A(100) { }\n};\n\nint main()\n{\n    D d;\n    d.print();\n    return 0;\n}\n</code></pre>\n<p>Suppose class <code>D</code> is defined as follows : </p>\n<pre><code>class D: public B, public C \n    {\n    public:\n        D():B(),C(){}\n    };\n</code></pre>\n<p>I get some garbage value in the print. And if the class <code>D</code> is defined as follows (parameterized constructor for A is explicitly called) :</p>\n<pre><code>class D: public B, public C \n    {\n    public:\n        D():B(),C(),A(20){}\n    };\n</code></pre>\n<p>I get 20 as output. In the first case, I can understand that the default <code>A()</code> constructor is called, hence the garbage value as x is not set to any value. </p>\n<p>However, in the second case, its not clear. When is the parameterized constructor for <code>A(int)</code> is called? If I understood correctly, call order depends on order of inheritance. Since <code>B</code> is inherited first, <code>B</code>'s constructor call takes precedence over <code>C</code>.Since <code>B</code> inherits <code>A</code>, <code>A()</code> will be called first, of all. Then <code>B</code>'s constructor will be called. Then <code>C</code>'s constructor will be called. At last, <code>A(int)</code> will be called, as <code>A</code>'s constructor is called explicitly in class <code>D</code>. If this is the case, then the output is well justified for the second case. However, this, then contradicts the output for the below piece of code : </p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nclass Person {\npublic:\n    Person(int x) { cout &lt;&lt; \"Person::Person(int ) called\" &lt;&lt; endl; }\n    Person()     { cout &lt;&lt; \"Person::Person() called\" &lt;&lt; endl; }\n};\n\nclass Faculty : virtual public Person {\npublic:\n    Faculty(int x):Person(x) {\n    cout&lt;&lt;\"Faculty::Faculty(int ) called\"&lt;&lt; endl;\n    }\n};\n\nclass Student : virtual public Person {\npublic:\n    Student(int x):Person(x) {\n        cout&lt;&lt;\"Student::Student(int ) called\"&lt;&lt; endl;\n    }\n};\n\nclass TA : public Faculty, public Student {\npublic:\n    TA(int x):Student(x), Faculty(x), Person(x) {\n        cout&lt;&lt;\"TA::TA(int ) called\"&lt;&lt; endl;\n    }\n};\n\nint main() {\n    TA ta1(30);\n}\n</code></pre>\n<p>The output for this program : </p>\n<pre><code>Person::Person(int ) called\nFaculty::Faculty(int ) called\nStudent::Student(int ) called\nTA::TA(int ) called\n</code></pre>\n<p>Why <code>Person(int)</code> called at the beginning in this case, and not at the last?</p>\n", "Tags": "<c++><inheritance><constructor>", "OwnerUserId": "1460665", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_38211185_38211406_1": {"section_id": 438, "quality": 0.7333333333333333, "length": 11}, "so_38211185_38211406_0": {"section_id": 438, "quality": 1.0, "length": 6}}, "n3337": {"so_38211185_38211406_1": {"section_id": 429, "quality": 0.7333333333333333, "length": 11}, "so_38211185_38211406_0": {"section_id": 429, "quality": 1.0, "length": 6}}, "n4659": {"so_38211185_38211406_1": {"section_id": 458, "quality": 0.7333333333333333, "length": 11}, "so_38211185_38211406_0": {"section_id": 458, "quality": 1.0, "length": 6}}}});