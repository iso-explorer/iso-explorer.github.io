post_cb({"9797294": {"ViewCount": "1388", "Body": "<p>sregex_token_iterator works almost perfectly as a tokenizer when the index of the submatch is specified to be -1. But unfortunately it doesn't work well with strings that begin with delimiters e.g:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;regex&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    string s(\"--aa---b-c--d--\");\n    regex r(\"-+\");\n\n    for (sregex_token_iterator it = sregex_token_iterator(s.begin(), s.end(), r, -1); it != sregex_token_iterator(); ++it)\n    {\n        cout &lt;&lt; (string) *it &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>\n<p>prints out:</p>\n<blockquote>\n<p id=\"so_9797294_9797294_0\">\u00a0<br>\n<code>aa</code><br>\n<code>b</code><br>\n<code>c</code><br>\n<code>d</code></br></br></br></br></p>\n</blockquote>\n<p>(Note the leading empty line).</p>\n<p>So note that it actually handles trailing delimeters well (as it doesn't print an extra empty line).</p>\n<p>Reading the standard it seems like there is a clause for specifically handling trailing delimeter to work well i.e:</p>\n<p><code>[re.tokiter] no 4.</code></p>\n<blockquote>\n<p id=\"so_9797294_9797294_1\">If the end of sequence is reached (position is equal to the end of sequence iterator), the iterator becomes equal to the end-of-sequence iterator value, unless the sub-expression being enumerated has index -1, in which case the iterator enumerates one last sub-expression that contains all the characters from the end of the last regular expression match to the end of the input sequence being enumerated, provided that this\n  <strong>would not be an empty sub-expression.</strong></p>\n</blockquote>\n<p>Does anyone know what's the reason for this seemingly asymmetric behaviour being specified?</p>\n<p>And lastly, is there an elegant solution to make this work? (such that we don't have empty entries at all).</p>\n", "Title": "regex as tokenizer - string beginning with delimiter", "CreationDate": "2012-03-21T01:05:45.320", "LastActivityDate": "2012-03-21T03:28:59.197", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-03-21T02:12:21.370", "LastEditorUserId": "636019", "Id": "9797294", "Score": "2", "OwnerUserId": "365079", "Tags": "<c++><regex><string><c++11><tokenize>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_9797294_9797294_1": {"length": 41, "quality": 1.0, "section_id": 5275}}, "n3337": {"so_9797294_9797294_1": {"length": 41, "quality": 1.0, "section_id": 5072}}, "n4659": {"so_9797294_9797294_1": {"length": 41, "quality": 1.0, "section_id": 6698}}}, "9797580": {"Id": "9797580", "PostTypeId": "2", "Body": "<p>Apparently your regex matches empty strings between the - delimiters, a simple (not necessarily elegant solution) will discard all strings with length zero:</p>\n<pre><code>...  \nstring aux = (string) *it;  \nif(aux.size() &gt; 0){  \n    cout &lt;&lt; aux &lt;&lt; endl;  \n}\n...  \n</code></pre>\n", "LastActivityDate": "2012-03-21T01:48:45.660", "Score": "1", "CreationDate": "2012-03-21T01:48:45.660", "ParentId": "9797294", "CommentCount": "2", "OwnerUserId": "1238221"}, "9798229": {"Id": "9798229", "PostTypeId": "2", "Body": "<p>It seems when you pass <code>-1</code> as the third argument you're effectively doing a split, and that's the expected behavior for a split.  The first token is whatever precedes the first delimiter, and the last token is whatever follows the last delimiter.  In this case, both happen to be the empty string, and it's traditional for <code>split()</code> to drop any empty tokens at the end, but to keep the ones at the beginning.</p>\n<p>Just out of curiosity, why don't you match the tokens themselves?  If <code>\"-+\"</code> is the correct regex for the delimiters, this should match the tokens:</p>\n<pre><code>regex r(\"[^-}+\");\n</code></pre>\n", "LastActivityDate": "2012-03-21T03:28:59.197", "Score": "1", "CreationDate": "2012-03-21T03:28:59.197", "ParentId": "9797294", "CommentCount": "1", "OwnerUserId": "20938"}});