post_cb({"bq_ids": {"n4140": {"so_34303507_34303507_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 156}, "so_34303507_34303507_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 156}}, "n3337": {"so_34303507_34303507_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 150}, "so_34303507_34303507_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 150}}, "n4659": {"so_34303507_34303507_6": {"length": 4, "quality": 0.5714285714285714, "section_id": 160}, "so_34303507_34303507_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 160}}}, "34303507": {"ViewCount": "706", "Body": "<p>In a <a href=\"http://spin.atomicobject.com/2013/07/01/lua-coroutines/\">blog post</a> from not too long ago, Scott Vokes describes a technical problem associated to lua's implementation of coroutines using the C functions <code>setjmp</code> and <code>longjmp</code>: </p>\n<blockquote>\n<p id=\"so_34303507_34303507_0\">The main limitation of Lua coroutines is that, since they are implemented with setjmp(3) and longjmp(3), you cannot use them to call from Lua into C code that calls back into Lua that calls back into C, because the nested longjmp will clobber the C function\u2019s stack frames. (This is detected at runtime, rather than failing silently.)</p>\n<p id=\"so_34303507_34303507_1\">I haven\u2019t found this to be a problem in practice, and I\u2019m not aware of any way to fix it without damaging Lua\u2019s portability, one of my favorite things about Lua \u2014 it will run on literally anything with an ANSI C compiler and a modest amount of space. Using Lua means I can travel light. :)</p>\n</blockquote>\n<p>I have used coroutines a fair amount and I thought I understood broadly what was going on and what <code>setjmp</code> and <code>longjmp</code> do, however I read this at some point and realized that I didn't really understand it. To try to figure it out, I tried to make a program that I thought should cause a problem based on the description, and instead it seems to work fine.</p>\n<p>However there are a few other places that I've seen people seem to allege that there are problems:</p>\n<ul>\n<li><a href=\"http://coco.luajit.org/\">http://coco.luajit.org/</a></li>\n<li><a href=\"http://lua-users.org/lists/lua-l/2005-03/msg00179.html\">http://lua-users.org/lists/lua-l/2005-03/msg00179.html</a></li>\n</ul>\n<p>The question is:  </p>\n<ul>\n<li>Under what circumstances do lua coroutines fail to work because of C function stack frames getting clobbered?</li>\n<li>What exactly is the result? Does \"detected at runtime\" mean, lua panic? Or something else?</li>\n<li>Does this still affect the most recent versions of lua (5.3) or is this actually a 5.1 issue or something?</li>\n</ul>\n<p>Here was the code which I produced. In my test, it is linked with lua 5.3.1, compiled as C code, and the test itself is compiled itself as C++ code at C++11 standard.</p>\n<pre><code>extern \"C\" {\n#include &lt;lauxlib.h&gt;\n#include &lt;lua.h&gt;\n}\n\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n#define CODE(C) \\\ncase C: { \\\n  std::cout &lt;&lt; \"When returning to \" &lt;&lt; where &lt;&lt; \" got code '\" #C \"'\" &lt;&lt; std::endl; \\\n  break; \\\n}\n\nvoid handle_resume_code(int code, const char * where) {\n  switch (code) {\n    CODE(LUA_OK)\n    CODE(LUA_YIELD)\n    CODE(LUA_ERRRUN)\n    CODE(LUA_ERRMEM)\n    CODE(LUA_ERRERR)\n    default:\n      std::cout &lt;&lt; \"An unknown error code in \" &lt;&lt; where &lt;&lt; std::endl;\n  }\n}\n\nint trivial(lua_State *, int, lua_KContext) {\n  std::cout &lt;&lt; \"Called continuation function\" &lt;&lt; std::endl;\n  return 0;\n}\n\nint f(lua_State * L) {\n  std::cout &lt;&lt; \"Called function 'f'\" &lt;&lt; std::endl;\n  return 0;\n}\n\nint g(lua_State * L) {\n  std::cout &lt;&lt; \"Called function 'g'\" &lt;&lt; std::endl;\n\n  lua_State * T = lua_newthread(L);\n  lua_getglobal(T, \"f\");\n\n  handle_resume_code(lua_resume(T, L, 0), __func__);\n  return lua_yieldk(L, 0, 0, trivial);\n}\n\nint h(lua_State * L) {\n  std::cout &lt;&lt; \"Called function 'h'\" &lt;&lt; std::endl;\n\n  lua_State * T = lua_newthread(L);\n  lua_getglobal(T, \"g\");\n\n  handle_resume_code(lua_resume(T, L, 0), __func__);\n  return lua_yieldk(L, 0, 0, trivial);\n}\n\nint main () {\n  std::cout &lt;&lt; \"Starting:\" &lt;&lt; std::endl;\n\n  lua_State * L = luaL_newstate();\n\n  // init\n  {\n    lua_pushcfunction(L, f);\n    lua_setglobal(L, \"f\");\n\n    lua_pushcfunction(L, g);\n    lua_setglobal(L, \"g\");\n\n    lua_pushcfunction(L, h);\n    lua_setglobal(L, \"h\");\n  }\n\n  assert(lua_gettop(L) == 0);\n\n  // Some action\n  {\n    lua_State * T = lua_newthread(L);\n    lua_getglobal(T, \"h\");\n\n    handle_resume_code(lua_resume(T, nullptr, 0), __func__);\n  }\n\n  lua_close(L); \n\n  std::cout &lt;&lt; \"Bye! :-)\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output I get is:</p>\n<pre><code>Starting:\nCalled function 'h'\nCalled function 'g'\nCalled function 'f'\nWhen returning to g got code 'LUA_OK'\nWhen returning to h got code 'LUA_YIELD'\nWhen returning to main got code 'LUA_YIELD'\nBye! :-)\n</code></pre>\n<hr>\n<p>Much thanks to @ Nicol Bolas for the very detailed answer!<br>\nAfter reading his answer, reading the official docs, reading some emails and playing around with it some more, I want to refine the question / ask a specific follow-up question, however you want to look at it.</br></p>\n<p>I think this term 'clobbering' is not good for describing this issue and this was part of what confused me -- nothing is being \"clobbered\" in the sense of being written to twice and the first value being lost, the issue is solely, as @Nicol Bolas points out, that <code>longjmp</code> tosses part of the C stack, and if you are hoping to restore the stack later, too bad.</p>\n<p>The issue is actually described very nicely in <a href=\"http://www.lua.org/manual/5.2/manual.html#4.7\">section 4.7 of lua 5.2 manual</a>, in a link provided by @Nicol Bolas.</p>\n<p>Curiously, there is no equivalent section in the lua 5.1 documentation. However, lua 5.2 has <a href=\"http://www.lua.org/manual/5.2/manual.html#lua_yieldk\">this to say</a> about <code>lua_yieldk</code>:</p>\n<blockquote>\n<p id=\"so_34303507_34303507_2\">Yields a coroutine.</p>\n<p id=\"so_34303507_34303507_3\">This function should only be called as the return expression of a C function, as follows:</p>\n<p id=\"so_34303507_34303507_4\"><code>return lua_yieldk (L, n, i, k);</code></p>\n</blockquote>\n<p>Lua 5.1 manual says <a href=\"http://www.lua.org/manual/5.1/manual.html#lua_yield\">something similar</a>, about <code>lua_yield</code> instead:</p>\n<blockquote>\n<p id=\"so_34303507_34303507_5\">Yields a coroutine.</p>\n<p id=\"so_34303507_34303507_6\">This function should only be called as the return expression of a C function, as follows:</p>\n<p id=\"so_34303507_34303507_7\"><code>return lua_yieldk (L, n, i, k);</code></p>\n</blockquote>\n<p>Some natural questions then:  </p>\n<ul>\n<li>Why does it matter if I use <code>return</code> here or not? If <code>lua_yieldk</code> will call <code>longjmp</code> then the <code>lua_yieldk</code> will never return anyways, so it shouldn't matter if I return then? So that cannot be what is happening, right?</li>\n<li>Supposing instead that <code>lua_yieldk</code> just makes a note within the lua state that the current C api call has stated that it wants to yield, and then when it finally does return, lua will figure out what happens next. Then this solves the problem of saving C stack frames, no? Since after we return to lua normally, those stack frames have expired anyways -- so the complications described in @Nicol Bolas picture are skirted around? And second of all, in 5.2 at least the semantics are never that we should restore C stack frames, it seems -- <code>lua_yieldk</code> resumes to a continuation function, not to the <code>lua_yieldk</code> caller, and <code>lua_yield</code> apparently resumes to the caller of the current api call, not to the <code>lua_yield</code> caller itself.</li>\n</ul>\n<p>And, the most important question:</p>\n<blockquote>\n<p id=\"so_34303507_34303507_8\">If I consistently use <code>lua_yieldk</code> in the form <code>return lua_yieldk(...)</code> specified in the docs, returning from a <code>lua_CFunction</code> that was passed to lua, is it still possible to trigger the <code>attempt to yield across a C-call boundary</code> error?</p>\n</blockquote>\n<p>Finally, (but this is less important), I would like to see a concrete example of what it looks like when a naive programmer \"isn't careful\" and triggers the <code>attempt to yield across a C-call boundary</code> error. I get the idea that there could be problem associated to <code>setjmp</code> and <code>longjmp</code> tossing stack frames that we later need, but I want to see some real lua / lua c api code that I can point to and say \"for instance, don't do that\", and this is surprisingly elusive.</p>\n<p>I found <a href=\"http://lua-users.org/lists/lua-l/2013-01/msg00504.html\">this email</a> where someone reported this error with some lua 5.1 code, and I attempted to reproduce it in lua 5.3. However what I found was that, this looks like just poor error reporting from the lua implementation -- the actual bug is being caused because the user is not setting up their coroutine properly. The proper way to load the coroutine is, create the thread, push a function onto the thread stack, and then call <code>lua_resume</code> on the thread state. Instead the user was using <code>dofile</code> on the thread stack, which executes the function there after loading it, rather than resuming it. So it is effectively <code>yield outside of a coroutine</code> iiuc, and when I patch this, his code works fine, using both <code>lua_yield</code> and <code>lua_yieldk</code> in lua 5.3.</p>\n<p>Here is the listing I produced:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;cstdio&gt;\n\nextern \"C\" {\n#include \"lua.h\"\n#include \"lauxlib.h\"\n}\n\n//#define USE_YIELDK\n\nbool running = true;\n\nint lua_print(lua_State * L) {\n  if (lua_gettop(L)) {\n    printf(\"lua: %s\\n\", lua_tostring(L, -1));\n  }\n  return 0;\n}\n\nint lua_finish(lua_State *L) {\n  running = false;\n  printf(\"%s called\\n\", __func__);\n  return 0;\n}\n\nint trivial(lua_State *, int, lua_KContext) {\n  printf(\"%s called\\n\", __func__);\n  return 0;\n}\n\nint lua_sleep(lua_State *L) {\n  printf(\"%s called\\n\", __func__);\n#ifdef USE_YIELDK\n  printf(\"Calling lua_yieldk\\n\");\n  return lua_yieldk(L, 0, 0, trivial);\n#else\n  printf(\"Calling lua_yield\\n\");\n  return lua_yield(L, 0);\n#endif\n}\n\nconst char * loop_lua =\n\"print(\\\"loop.lua\\\")\\n\"\n\"\\n\"\n\"local i = 0\\n\"\n\"while true do\\n\"\n\"  print(\\\"lua_loop iteration\\\")\\n\"\n\"  sleep()\\n\"\n\"\\n\"\n\"  i = i + 1\\n\"\n\"  if i == 4 then\\n\"\n\"    break\\n\"\n\"  end\\n\"\n\"end\\n\"\n\"\\n\"\n\"finish()\\n\";\n\nint main() {\n  lua_State * L = luaL_newstate();\n\n  lua_pushcfunction(L, lua_print);\n  lua_setglobal(L, \"print\");\n\n  lua_pushcfunction(L, lua_sleep);\n  lua_setglobal(L, \"sleep\");\n\n  lua_pushcfunction(L, lua_finish);\n  lua_setglobal(L, \"finish\");\n\n  lua_State* cL = lua_newthread(L);\n  assert(LUA_OK == luaL_loadstring(cL, loop_lua));\n  /*{\n    int result = lua_pcall(cL, 0, 0, 0);\n    if (result != LUA_OK) {\n      printf(\"%s error: %s\\n\", result == LUA_ERRRUN ? \"Runtime\" : \"Unknown\", lua_tostring(cL, -1));\n      return 1;\n    }\n  }*/\n  // ^ This pcall (predictably) causes an error -- if we try to execute the\n  // script, it is going to call things that attempt to yield, but we did not\n  // start the script with lua_resume, we started it with pcall, so it's not\n  // okay to yield.\n  // The reported error is \"attempt to yield across a C-call boundary\", but what\n  // is really happening is just \"yield from outside a coroutine\" I suppose...\n\n  while (running) {\n    int status;\n    printf(\"Waking up coroutine\\n\");\n    status = lua_resume(cL, L, 0);\n    if (status == LUA_YIELD) {\n      printf(\"coroutine yielding\\n\");\n    } else {\n      running = false; // you can't try to resume if it didn't yield\n\n      if (status == LUA_ERRRUN) {\n        printf(\"Runtime error: %s\\n\", lua_isstring(cL, -1) ? lua_tostring(cL, -1) : \"(unknown)\" );\n        lua_pop(cL, -1);\n        break;\n      } else if (status == LUA_OK) {\n        printf(\"coroutine finished\\n\");\n      } else {\n        printf(\"Unknown error\\n\");\n      }\n    }\n  }\n\n  lua_close(L);\n  printf(\"Bye! :-)\\n\");\n  return 0;\n}\n</code></pre>\n<p>Here is the output when <code>USE_YIELDK</code> is commented out:</p>\n<pre><code>Waking up coroutine\nlua: loop.lua\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yield\ncoroutine yielding\nWaking up coroutine\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yield\ncoroutine yielding\nWaking up coroutine\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yield\ncoroutine yielding\nWaking up coroutine\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yield\ncoroutine yielding\nWaking up coroutine\nlua_finish called\ncoroutine finished\nBye! :-)\n</code></pre>\n<p>Here is the output when <code>USE_YIELDK</code> is defined:</p>\n<pre><code>Waking up coroutine\nlua: loop.lua\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yieldk\ncoroutine yielding\nWaking up coroutine\ntrivial called\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yieldk\ncoroutine yielding\nWaking up coroutine\ntrivial called\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yieldk\ncoroutine yielding\nWaking up coroutine\ntrivial called\nlua: lua_loop iteration\nlua_sleep called\nCalling lua_yieldk\ncoroutine yielding\nWaking up coroutine\ntrivial called\nlua_finish called\ncoroutine finished\nBye! :-)\n</code></pre>\n</hr>", "AcceptedAnswerId": "34304244", "Title": "Lua coroutines -- setjmp longjmp clobbering?", "CreationDate": "2015-12-16T03:33:29.330", "Id": "34303507", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-16T21:53:10.093", "LastEditorUserId": "3598119", "LastActivityDate": "2015-12-21T16:48:15.093", "Score": "8", "OwnerUserId": "3598119", "Tags": "<c++><c><lua><coroutine><longjmp>", "AnswerCount": "2"}, "34304244": {"Id": "34304244", "PostTypeId": "2", "Body": "<p>Think about what happens when a coroutine does a <code>yield</code>. It stops executing, and processing returns to whomever it was that called <code>resume</code> on that coroutine, correct?</p>\n<p>Well, let's say you have this code:</p>\n<pre><code>function top()\n    coroutine.yield()\nend\n\nfunction middle()\n    top()\nend\n\nfunction bottom()\n    middle()\nend\n\nlocal co = coroutine.create(bottom);\n\ncoroutine.resume(co);\n</code></pre>\n<p>At the moment of the call to <code>yield</code>, the Lua stack looks like this:</p>\n<pre><code>-- top\n-- middle\n-- bottom\n-- yield point\n</code></pre>\n<p>When you call <code>yield</code>, the Lua call stack that is part of the coroutine is preserved. When you do <code>resume</code>, the preserved call stack is executed again, starting where it left off before.</p>\n<p>OK, now let's say that <code>middle</code> was in fact not a Lua function. Instead, it was a C function, and that C function calls the Lua function <code>top</code>. So conceptually, your stack looks like this:</p>\n<pre><code>-- Lua - top\n-- C   - middle\n-- Lua - bottom\n-- Lua - yield point\n</code></pre>\n<p>Now, please note what I said before: this is what your stack looks like <em>conceptually</em>.</p>\n<p>Because your actual call stack looks <em>nothing like this.</em></p>\n<p>In reality, there are really two stacks. There is Lua's internal stack, defined by a <code>lua_State</code>. And there's C's stack. Lua's internal stack, at the time when <code>yield</code> is about to be called, looks something like this:</p>\n<pre><code>-- top\n-- Some C stuff\n-- bottom\n-- yield point\n</code></pre>\n<p>So what does the stack look like to C? Well, it looks like this:</p>\n<pre><code>-- arbitrary Lua interpreter stuff\n-- middle\n-- arbitrary Lua interpreter stuff\n-- setjmp\n</code></pre>\n<p>And that right there is the problem. See, when Lua does a <code>yield</code>, it's going to call <code>longjmp</code>. That function is based on the behavior of the C stack. Namely, it's going to return to where <code>setjmp</code> was.</p>\n<p>The Lua stack will be preserved because the Lua stack is <em>separate</em> from the C stack. But the C stack? Everything between the <code>longjmp</code> and <code>setjmp</code>?. Gone. Kaput. Lost <em>forever</em>.</p>\n<p>Now you may go, \"wait, doesn't the Lua stack know that it went into C and back into Lua\"? A bit. But the Lua stack is incapable of doing something that C is incapable of. And C is simply not capable of preserving a stack (well, not without special libraries). So while the Lua stack is vaguely aware that some kind of C process happened in the middle of its stack, it has no way to reconstitute what was there.</p>\n<p>So what happens if you resume this <code>yield</code>ed coroutine?</p>\n<p><a href=\"http://www.urbandictionary.com/define.php?term=nasal%20demons\" rel=\"nofollow\">Nasal demons.</a> And nobody likes those. Fortunately, Lua 5.1 and above (at least) will error whenever you attempt to yield across C.</p>\n<p>Note that Lua 5.2+ <a href=\"http://www.lua.org/manual/5.2/manual.html#4.7\" rel=\"nofollow\">does have ways of fixing this</a>. But it's not automatic; it requires explicit coding on your part.</p>\n<p>When Lua code that is in a coroutine calls your C code, and your C code calls Lua code that may yield, you can use <code>lua_callk</code> or <code>lua_pcallk</code> to call the possibly-yielding Lua functions. These calling functions take an extra parameter: a \"continuation\" function.</p>\n<p>If the Lua code you call does yield, then the <code>lua_*callk</code> function won't ever actually return (since your C stack will have been destroyed). Instead, it will call the continuation function you provided in your <code>lua_*callk</code> function. As you can guess by the name, the continuation function's job is to continue where your previous function left off.</p>\n<p>Now, Lua does preserve the stack for your continuation function, so it gets the stack in the same state that your original C function was in. Well, except that the function+arguments that you called (with <code>lua_*callk</code>) are removed, and the return values from that function are pushed onto your stack. Outside of that, the stack is all the same.</p>\n<p>There is also <code>lua_yieldk</code>. This allows your C function to yield back to Lua, such that when the coroutine is resumed, it calls the provided continuation function.</p>\n<p>Note that <a href=\"http://coco.luajit.org/index.html\" rel=\"nofollow\">Coco</a> gives Lua 5.1 the ability to resolve this problem. It is capable (though OS/assembly/etc magic) of <em>preserving</em> the C stack during a yield operation. LuaJIT versions before 2.0 also provided this feature.</p>\n<hr>\n<p>C++ note</p>\n<p>You marked your question with the C++ tag, so I'll assume that's involved here.</p>\n<p>Among the many differences between C and C++ is the fact that C++ is <em>far</em> more dependent on the nature of its callstack than Lua. In C, if you discard a stack, you might lose resources that weren't cleaned up. C++ however is required to call destructors of functions declared on the stack at some point. The standard does not allow you to just throw them away.</p>\n<p>So continuations only work in C++ if there is <strong><em>nothing</em></strong> on the stack which needs to have a destructor call. Or more specifically, only types that are trivially destructible can be sitting on the stack if you call any of the continuation function Lua APIs.</p>\n<p>Of course, Coco handles C++ just fine, since it's actually preserving the C++ stack.</p>\n</hr>", "LastEditorUserId": "734069", "LastActivityDate": "2015-12-17T13:57:43.570", "Score": "9", "CreationDate": "2015-12-16T05:00:30.853", "ParentId": "34303507", "CommentCount": "6", "OwnerUserId": "734069", "LastEditDate": "2015-12-17T13:57:43.570"}, "34350275": {"Id": "34350275", "PostTypeId": "2", "Body": "<p>Posting this as an answer which complements @Nicol Bolas' answer, and so that\nI can have space to write down what it took for me to understand the original\nquestion, and the answers to the secondary questions / a code listing.</p>\n<p>If you read Nicol Bolas' answer but still have questions like I did, here are\nsome additional hints:</p>\n<ul>\n<li>The <em>three</em> layers on the call stack, Lua, C, Lua, are essential to the problem.\nIf you only have two layers, Lua and C, you don't get the problem.</li>\n<li>In imagining how the coroutine call is supposed to work -- the lua stack looks\na certain way, the C stack looks a certain way, the call yields (longjmp) and\nlater is resumed... the problem does not happen <em>immediately</em> when it is\nresumed.<br>\n<em>The problem happens when the resumed function later tries to return, to your\nC function.</em><br>\nBecause, for the coroutine semantics to work out, it is supposed to return\ninto a C function call, but the stack frames for that are gone, and cannot be\nrestored.</br></br></li>\n<li>The workaround for <em>this</em> lack of ability to restore those stack frames is to\nuse <code>lua_callk</code>, <code>lua_pcallk</code>, which allow you to provide a substitute\nfunction which can be called in place of that C function whose frames were\nwiped out.</li>\n<li>The issue about <code>return lua_yieldk(...)</code> appears to have nothing to do with\nany of this. From skimming the implementation of <code>lua_yieldk</code> it appears that\nit does indeed always <code>longjmp</code>, and it may only return in some obscure case\ninvolving lua debugging hooks (?).</li>\n<li>Lua internally (at current version) keeps track of when yield should not be\nallowed, by keeping a counter variable <code>nny</code> (number non-yieldable) associated\nto the lua state, and when you call <code>lua_call</code> or <code>lua_pcall</code> from a C api\nfunction (a <code>lua_CFunction</code> which you earlier pushed to lua), <code>nny</code> is\nincremented, and is only decremented when that call or pcall returns. When\n<code>nny</code> is nonzero, it is not safe to yield, and you get this <code>yield across\nC-api boundary</code> error if you try to yield anyways.</li>\n</ul>\n<p>Here is a simple listing that produces the problem and reports the errors,\nif you are like me and like to have a concrete code examples. It demonstrates\nsome of the difference in using <code>lua_call</code>, <code>lua_pcall</code>, and <code>lua_pcallk</code>\nwithin a function called by a coroutine.</p>\n<pre><code>extern \"C\" {\n#include &lt;lauxlib.h&gt;\n#include &lt;lua.h&gt;\n}\n\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n\n//#define USE_PCALL\n//#define USE_PCALLK\n\n#define CODE(C) \\\ncase C: { \\\n  std::cout &lt;&lt; \"When returning to \" &lt;&lt; where &lt;&lt; \" got code '\" #C \"'\" &lt;&lt; std::endl; \\\n  break; \\\n}\n\n#define ERRCODE(C) \\\ncase C: { \\\n  std::cout &lt;&lt; \"When returning to \" &lt;&lt; where &lt;&lt; \" got code '\" #C \"': \" &lt;&lt; lua_tostring(L, -1) &lt;&lt; std::endl; \\\n  break; \\\n}\n\nint report_resume_code(int code, const char * where, lua_State * L) {\n  switch (code) {\n    CODE(LUA_OK)\n    CODE(LUA_YIELD)\n    ERRCODE(LUA_ERRRUN)\n    ERRCODE(LUA_ERRMEM)\n    ERRCODE(LUA_ERRERR)\n    default:\n      std::cout &lt;&lt; \"An unknown error code in \" &lt;&lt; where &lt;&lt; \": \" &lt;&lt; lua_tostring(L, -1) &lt;&lt; std::endl;\n  }\n  return code;\n}\n\nint report_pcall_code(int code, const char * where, lua_State * L) {\n  switch(code) {\n    CODE(LUA_OK)\n    ERRCODE(LUA_ERRRUN)\n    ERRCODE(LUA_ERRMEM)\n    ERRCODE(LUA_ERRERR)\n    default:\n      std::cout &lt;&lt; \"An unknown error code in \" &lt;&lt; where &lt;&lt; \": \" &lt;&lt; lua_tostring(L, -1) &lt;&lt; std::endl;\n  }\n  return code;\n}\n\nint trivial(lua_State *, int, lua_KContext) {\n  std::cout &lt;&lt; \"Called continuation function\" &lt;&lt; std::endl;\n  return 0;\n}\n\nint f(lua_State * L) {\n  std::cout &lt;&lt; \"Called function 'f', yielding\" &lt;&lt; std::endl;\n  return lua_yield(L, 0);\n}\n\nint g(lua_State * L) {\n  std::cout &lt;&lt; \"Called function 'g'\" &lt;&lt; std::endl;\n\n  lua_getglobal(L, \"f\");\n#ifdef USE_PCALL\n  std::cout  &lt;&lt; \"pcall...\" &lt;&lt; std::endl;\n  report_pcall_code(lua_pcall(L, 0, 0, 0), __func__, L);\n  // ^ yield across pcall!\n  // If we yield, there is no way ever to return normally from this pcall,\n  // so it is an error.\n#elif defined(USE_PCALLK)\n  std::cout  &lt;&lt; \"pcallk...\" &lt;&lt; std::endl;\n  report_pcall_code(lua_pcallk(L, 0, 0, 0, 0, trivial), __func__, L);\n#else\n  std::cout &lt;&lt; \"call...\" &lt;&lt; std::endl;\n  lua_call(L, 0, 0);\n  // ^ yield across call!\n  // This results in an error being reported in lua_resume, rather than at\n  // the pcall\n#endif\n  return 0;\n}\n\nint main () {\n  std::cout &lt;&lt; \"Starting:\" &lt;&lt; std::endl;\n\n  lua_State * L = luaL_newstate();\n\n  // init\n  {\n    lua_pushcfunction(L, f);\n    lua_setglobal(L, \"f\");\n\n    lua_pushcfunction(L, g);\n    lua_setglobal(L, \"g\");\n  }\n\n  assert(lua_gettop(L) == 0);\n\n  // Some action\n  {\n    lua_State * T = lua_newthread(L);\n    lua_getglobal(T, \"g\");\n\n    while (LUA_YIELD == report_resume_code(lua_resume(T, L, 0), __func__, T)) {}\n  }\n\n  lua_close(L); \n\n  std::cout &lt;&lt; \"Bye! :-)\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Example output:</p>\n<p><code>call</code></p>\n<pre><code>Starting:\nCalled function 'g'\ncall...\nCalled function 'f', yielding\nWhen returning to main got code 'LUA_ERRRUN': attempt to yield across a C-call boundary\nBye! :-)\n</code></pre>\n<p><code>pcall</code></p>\n<pre><code>Starting:\nCalled function 'g'\npcall...\nCalled function 'f', yielding\nWhen returning to g got code 'LUA_ERRRUN': attempt to yield across a C-call boundary\nWhen returning to main got code 'LUA_OK'\nBye! :-)\n</code></pre>\n<p><code>pcallk</code></p>\n<pre><code>Starting:\nCalled function 'g'\npcallk...\nCalled function 'f', yielding\nWhen returning to main got code 'LUA_YIELD'\nCalled continuation function\nWhen returning to main got code 'LUA_OK'\nBye! :-)\n</code></pre>\n", "LastEditorUserId": "3598119", "LastActivityDate": "2015-12-21T16:48:15.093", "Score": "1", "CreationDate": "2015-12-18T07:16:25.947", "ParentId": "34303507", "CommentCount": "1", "OwnerUserId": "3598119", "LastEditDate": "2015-12-21T16:48:15.093"}});