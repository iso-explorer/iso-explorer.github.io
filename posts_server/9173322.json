post_cb({"bq_ids": {"n4140": {"so_9173322_9173805_0": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_9173322_9173805_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 3286}, "so_9173322_9173805_3": {"length": 9, "quality": 1.0, "section_id": 3287}, "so_9173322_9173805_4": {"length": 17, "quality": 1.0, "section_id": 3304}, "so_9173322_9173805_2": {"length": 12, "quality": 0.75, "section_id": 3287}, "so_9173322_9173805_5": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_9173322_9173805_0": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_9173322_9173805_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 3157}, "so_9173322_9173805_3": {"length": 9, "quality": 1.0, "section_id": 3157}, "so_9173322_9173805_4": {"length": 17, "quality": 1.0, "section_id": 3174}, "so_9173322_9173805_2": {"length": 16, "quality": 1.0, "section_id": 3157}, "so_9173322_9173805_5": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_9173322_9173805_3": {"length": 9, "quality": 1.0, "section_id": 4049}, "so_9173322_9173805_4": {"length": 15, "quality": 0.8823529411764706, "section_id": 4070}, "so_9173322_9173805_5": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_9173322_9173805_1": {"length": 11, "quality": 0.6470588235294118, "section_id": 4049}, "so_9173322_9173805_2": {"length": 11, "quality": 0.6875, "section_id": 4049}}}, "9173322": {"ViewCount": "105", "Body": "<p>Since C++2003 we have value-initialisation as well as default-initialisation. Meaning that:</p>\n<pre><code>struct Foo {\n    int i;\n    std :: string s;\n};\n\nFoo f1;          // f1.s is default-constructed, f1.i is uninitialised\nFoo f2 = Foo (); // f1.s is default-constructed, f1.i is zero\n</code></pre>\n<p>Right?</p>\n<p>Now suppose I have this class</p>\n<pre><code>class Bar : public Foo {\n    int n;\n    Foo f [SIZE];\npublic:\n    Bar ();\n};\n</code></pre>\n<p>When I write the constructor for <code>Bar</code>, I may want to default- or value-initialise either the parent class or the <code>f[]</code> member. I think the choice for initialising the parent is simply:</p>\n<pre><code>Bar :: Bar () : Foo (), n (-1) {} // Parent is value-initialised (Foo::i is zero)\nBar :: Bar () : n (-1)         {} // Parent is default-initialised (Foo::i is undefined)\n</code></pre>\n<p>But what about the <code>f[]</code> member?</p>\n<ul>\n<li>How do I default-initialise all members?</li>\n<li>How do I value-initialise all members?</li>\n<li>If I use C++11 initializer lists, what happens if the initializer list has a different size than <code>SIZE</code>?</li>\n</ul>\n", "Title": "Can I choose between default-initalisation and value-initialisaion or all or part of an array?", "CreationDate": "2012-02-07T08:50:58.040", "LastActivityDate": "2012-02-07T09:29:36.843", "CommentCount": "5", "PostTypeId": "1", "Id": "9173322", "Score": "3", "OwnerUserId": "458742", "Tags": "<c++><value-initialization>", "AnswerCount": "1"}, "9173805": {"Id": "9173805", "PostTypeId": "2", "Body": "<p>Actually, according to standard value-initialization seems to be the process of calling whatever form of user-defined default constructor there or to zero-initialize objects which don't have a default constructor (see 8.5 [decl.init] paragraph 7:</p>\n<blockquote>\n<p id=\"so_9173322_9173805_0\">To value-initialize an object of type T means:</p>\n<p id=\"so_9173322_9173805_1\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for T is called (and the initialization is ill-formed if T has no accessible default constructor);</p>\n<p id=\"so_9173322_9173805_2\">\u2014 if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.</p>\n<p id=\"so_9173322_9173805_3\">\u2014 if T is an array type, then each element is value-initialized; \u2014 otherwise, the object is zero-initialized.</p>\n</blockquote>\n<p>In this sense you can value initialize your array member since C++1998 using <code>f()</code> in the member initializer list. If you want to use specific values, you need to use C++2011 with an initializer list e.g. <code>f({ 1, 2, 3 })</code>. If there are fewer arguments than there are elements, the remaining elements are value initialized. Actually, the are initialized from an empty initializer list (8.5.1 [dcl.init.aggr] paragraph 7):</p>\n<blockquote>\n<p id=\"so_9173322_9173805_4\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member\n  not explicitly initialized shall be initialized from an empty initializer list.</p>\n</blockquote>\n<p>... and this initialization from an empty initializer list means according to 8.5.4 [dcl.init.list] paragraph 3, bullet 7:</p>\n<blockquote id=\"so_9173322_9173805_5\">\n<ul>\n<li>Otherwise, if the initializer list has no elements, the object is value-initialized.</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2012-02-07T09:29:36.843", "CommentCount": "0", "CreationDate": "2012-02-07T09:29:36.843", "ParentId": "9173322", "Score": "1", "OwnerUserId": "1120273"}});