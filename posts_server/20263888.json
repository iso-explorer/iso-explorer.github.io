post_cb({"bq_ids": {"n4140": {"so_20263888_20264283_0": {"length": 17, "quality": 1.0, "section_id": 6037}, "so_20263888_20264283_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 6037}, "so_20263888_20264213_0": {"length": 48, "quality": 0.9411764705882353, "section_id": 6037}, "so_20263888_20264213_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 6037}}, "n3337": {"so_20263888_20264963_6": {"length": 19, "quality": 1.0, "section_id": 5650}, "so_20263888_20264283_2": {"length": 19, "quality": 1.0, "section_id": 5805}, "so_20263888_20264213_0": {"length": 48, "quality": 0.9411764705882353, "section_id": 5805}, "so_20263888_20264963_3": {"length": 19, "quality": 1.0, "section_id": 5650}, "so_20263888_20264283_0": {"length": 17, "quality": 1.0, "section_id": 5805}, "so_20263888_20264213_1": {"length": 19, "quality": 1.0, "section_id": 5805}}, "n4659": {"so_20263888_20264283_0": {"length": 17, "quality": 1.0, "section_id": 7536}, "so_20263888_20264283_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 7536}, "so_20263888_20264213_0": {"length": 41, "quality": 0.803921568627451, "section_id": 7536}, "so_20263888_20264213_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 7536}}}, "20264213": {"Id": "20264213", "PostTypeId": "2", "Body": "<p>n3376 5.2.9/11\n<blockquote><p id=\"so_20263888_20264213_0\">A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be converted to a prvalue of type \u201cpointer\nto cv2 D,\u201d where D is a class derived (Clause 10) from B if a valid standard conversion from \u201cpointer to D\u201d\nto \u201cpointer to B\u201d exists (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and\nB is neither a virtual base class of D nor a base class of a virtual base class of D. The null pointer value (4.10)\nis converted to the null pointer value of the destination type.</p>\n<p id=\"so_20263888_20264213_1\">If the prvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object\nof type D. <strong>Otherwise, the result of the cast is undefined.</strong></p></blockquote>\nSince <code>&amp;obj</code> is not points to <code>DerivedForInt</code> it's UB.</p>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2013-11-28T11:02:39.720", "Score": "3", "CreationDate": "2013-11-28T10:57:09.007", "ParentId": "20263888", "CommentCount": "0", "OwnerUserId": "1498580", "LastEditDate": "2013-11-28T11:02:39.720"}, "20264963": {"Id": "20264963", "PostTypeId": "2", "Body": "<p>Ok, I'll probably get shred into pieces for this answer...</p>\n<p>Obviously, as the other answers stated this is undefined behaviour, as found in the standard. But if your <code>Base</code> class has <em>standard layout</em> and your <code>DerivedForInt</code> class does not add new data members it will have the same (standard) layout.</p>\n<p>Under these conditions your cast should cause no troubles even it being UB. According to one of the sources, it is at least safe to do a</p>\n<pre><code>DerivedForInt *derived = reinterpret_cast&lt;DerivedForInt*&gt;(&amp;base.a);\n</code></pre>\n<p>Sources:</p>\n<p><a href=\"https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special/7189821#7189821\">What are Aggregates and PODs and how/why are they special?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/8864311/pods-and-inheritance-in-c11-does-the-address-of-the-struct-address-of-the\">PODs and inheritance in C++11. Does the address of the struct == address of the first member?</a></p>\n<p>From the second link:</p>\n<blockquote>\n<p id=\"so_20263888_20264963_0\">Here's the definition, from the standard section 9 [class]:</p>\n<blockquote>\n<p id=\"so_20263888_20264963_5\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n</blockquote>\n<p id=\"so_20263888_20264963_2\">And the property you want is then guaranteed (section 9.2 [class.mem]):</p>\n<blockquote>\n<p id=\"so_20263888_20264963_6\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p id=\"so_20263888_20264963_4\">This is actually better than the old requirement, because the ability to reinterpret_cast isn't lost by adding non-trivial constructors and/or destructor.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-28T12:24:03.053", "Score": "7", "CreationDate": "2013-11-28T11:28:17.793", "ParentId": "20263888", "CommentCount": "14", "OwnerUserId": "1781290", "LastEditDate": "2017-05-23T12:00:32.103"}, "20263888": {"ViewCount": "374", "Body": "<p>In the general case, it is (a very well deserved) Undefined Behavior to dowcast from a (dynamic) <code>Base</code> to one of the deriving classes <code>Derived</code></p>\n<h2>The obvious UB</h2>\n<pre><code>class Base\n{\npublic:\n    virtual void foo()\n    { /* does something */\u00a0}\n\n    int a;\n}\n\nclass Derived : public Base\n{\npublic:\n    virtual void foo()\n    { /* does something different */\u00a0}\n\n    double b;\n}\n\nBase obj;\nDerived derObj = *static_cast&lt;Derived *&gt;(&amp;obj);  // &lt;- here come the demons\n</code></pre>\n<p>In the current implementation approach of compilers, here there would obviously be at least the problems of inconsistent values in the Vtable and b containing garbage values. So it makes sense the standard does not define the behavior of a downcast in those conditions.</p>\n<h2>The not so obvious naive case</h2>\n<p>Yet I was curious to know <strong>if there were some concessions to this rule in specific cases ?</strong>\nFor an example :</p>\n<pre><code>class Base\n{\npublic:\n    void foo()\n    { /* does something */\u00a0}\n\n    int a = 1;\n    double b = 2.;\n}\n\nclass DerivedForInt : public Base\n{\n    int getVal()\n    { return a }\n}\n\nBase obj;\nDerivedForInt derObj = *static_cast&lt;DerivedForInt *&gt;(&amp;obj);  // &lt;- still an UB ?\n</code></pre>\n<p>Here we can easily imagine compiler doing the right thing. <strong>But from the standard perspective, is it still undefined ?</strong></p>\n<p>Edit : <strong>static_cast</strong> is a random choice for illustration purpose, it is also interesting if working with other casts !</p>\n", "AcceptedAnswerId": "20264963", "Title": "Are there cases where downcasting an actual Base to a Derived would be defined?", "CreationDate": "2013-11-28T10:43:23.157", "Id": "20263888", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-11-28T11:10:45.777", "LastEditorUserId": "1027706", "LastActivityDate": "2013-11-28T12:24:03.053", "Score": "9", "OwnerUserId": "1027706", "Tags": "<c++><casting><undefined-behavior>", "AnswerCount": "3"}, "20264283": {"Id": "20264283", "PostTypeId": "2", "Body": "<p>This is still undefined behaviour and I believe it should be.</p>\n<p><strong>Why it is undefined</strong></p>\n<p>As provided by @ForEveR in his answer:</p>\n<p>n3376 5.2.9/11</p>\n<blockquote>\n<p id=\"so_20263888_20264283_0\">A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be converted to a prvalue of type \u201cpointer to cv2 D,\u201d where D is a class derived (Clause 10) from B</p>\n<p id=\"so_20263888_20264283_1\">...</p>\n<p id=\"so_20263888_20264283_2\">If the prvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object of type D. <strong>Otherwise, the result of the cast is undefined</strong>.</p>\n</blockquote>\n<p><strong>Why it should be undefined</strong></p>\n<p>It would only work for POD types, since adding a virtual function to your base is enough for this to hurt you in all compilers I know of. Also, the difference between types may be conceptual, not just in their data layout. Type safety is just as much about providing strong abstractions as it is about preventing issues with data representation.</p>\n<p>If you would like something like this, it seems better to provide it as an ordinary function or to add a constructor in the derived class which takes an instance of the base class.</p>\n", "LastActivityDate": "2013-11-28T11:00:21.633", "CommentCount": "1", "CreationDate": "2013-11-28T11:00:21.633", "ParentId": "20263888", "Score": "2", "OwnerUserId": "980195"}});