post_cb({"bq_ids": {"n4140": {"so_34690128_34690286_1": {"length": 21, "quality": 0.7777777777777778, "section_id": 437}}, "n4659": {"so_34690128_34690286_1": {"length": 21, "quality": 0.7777777777777778, "section_id": 457}}}, "34690128": {"ViewCount": "134", "LastEditDate": "2016-01-09T05:56:38.957", "AcceptedAnswerId": "34690286", "Title": "Does the move constructor in a unique_ptr-based pimpl class require a complete type?", "CreationDate": "2016-01-09T05:42:59.693", "LastActivityDate": "2016-01-09T06:04:48.273", "CommentCount": "0", "Body": "<p>If I use a <code>unique_ptr&lt;T&gt;</code> to build a pimpl class, I understand that compiler-generated functions that invoke <code>T</code>'s destructor require that <code>T</code> be a complete type. But what about the pimpl class's move constructor? The compiler-generated version just calls the <code>unique_ptr</code>'s move constructor. That function doesn't destroy anything. Furthermore, the pimpl class's generated move constructor is implicitly <code>noexcept</code>, so there's no possibility of its body throwing an exception that would cause it to have to back out and destroy the <code>unique_ptr</code> subobject.</p>\n<p>It seems like the following code should compile:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass Widget {                      // has implicit move ctor\n  struct Impl;\n  std::unique_ptr&lt;Impl&gt; pImpl;\n};\n\nint main()\n{\n  Widget *pw1 = nullptr;\n\n  new Widget(std::move(*pw1));      // call move ctor. Rejected by\n}                                   // gcc, clang, and MSVC\n</code></pre>\n<p>As the comment says, this code is rejected by all of gcc, clang, and MSVC. Each complains about an invalid operation on an incomplete type. Is that required by the Standard? If so, what part?</p>\n<p>Note that the issue here is compilation, so the above code's undefined runtime behavior due to dereferencing the null <code>pw1</code> pointer is irrelevant. For the same reason, the memory leak arising from the call to <code>new</code> in the last statement is unimportant.</p>\n", "PostTypeId": "1", "LastEditorUserId": "2756719", "Id": "34690128", "Score": "2", "OwnerUserId": "1426649", "Tags": "<c++><c++11><unique-ptr><move-constructor>", "AnswerCount": "1"}, "34690286": {"Id": "34690286", "PostTypeId": "2", "Body": "<p>So close.</p>\n<blockquote>\n<p id=\"so_34690128_34690286_0\">Furthermore, the pimpl class's generated move constructor is\n  implicitly <code>noexcept</code>, so there's no possibility of its body throwing\n  an exception that would cause it to have to back out and destroy the\n  <code>unique_ptr</code> subobject.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/class.base.init#12\">[class.base.init]/12</a>:</p>\n<blockquote>\n<p id=\"so_34690128_34690286_1\">In a non-delegating constructor, the destructor for each potentially\n  constructed subobject of class type is potentially invoked (12.4). [\n  <em>Note</em>: This provision ensures that destructors can be called for fully-constructed sub-objects in case an exception is thrown (15.2).\n  \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>This is an odr-use (<a href=\"http://eel.is/c++draft/basic.def.odr#3\">[basic.def.odr]/3</a>) and so causes the implicit instantiation of <code>unique_ptr</code>'s destructor, which in turn, eventually, requires a complete type.</p>\n<p>There's no special case for a <code>noexcept</code> constructor.</p>\n", "Score": "5", "LastActivityDate": "2016-01-09T06:04:48.273", "CreationDate": "2016-01-09T06:04:48.273", "ParentId": "34690128", "CommentCount": "3", "OwnerUserId": "2756719"}});