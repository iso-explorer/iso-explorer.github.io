post_cb({"bq_ids": {"n4140": {"so_31206988_31206988_1": {"length": 13, "quality": 1.0, "section_id": 5940}, "so_31206988_33218377_1": {"length": 44, "quality": 0.7857142857142857, "section_id": 5986}, "so_31206988_31206988_4": {"length": 10, "quality": 1.0, "section_id": 5940}, "so_31206988_31206988_6": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_31206988_31206988_2": {"length": 5, "quality": 1.0, "section_id": 5940}, "so_31206988_31206988_3": {"length": 13, "quality": 1.0, "section_id": 5940}, "so_31206988_31206988_5": {"length": 44, "quality": 0.8148148148148148, "section_id": 5986}}, "n3337": {"so_31206988_31206988_1": {"length": 13, "quality": 1.0, "section_id": 5711}, "so_31206988_33218377_1": {"length": 34, "quality": 0.6071428571428571, "section_id": 5754}, "so_31206988_31206988_4": {"length": 10, "quality": 1.0, "section_id": 5711}, "so_31206988_31206988_6": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}, "so_31206988_31206988_2": {"length": 5, "quality": 1.0, "section_id": 5711}, "so_31206988_31206988_3": {"length": 13, "quality": 1.0, "section_id": 5711}, "so_31206988_31206988_5": {"length": 33, "quality": 0.6111111111111112, "section_id": 5754}}, "n4659": {"so_31206988_31206988_1": {"length": 13, "quality": 1.0, "section_id": 7424}, "so_31206988_33218377_1": {"length": 42, "quality": 0.75, "section_id": 7486}, "so_31206988_31206988_4": {"length": 10, "quality": 1.0, "section_id": 7424}, "so_31206988_31206988_6": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_31206988_31206988_2": {"length": 5, "quality": 1.0, "section_id": 7424}, "so_31206988_31206988_3": {"length": 13, "quality": 1.0, "section_id": 7424}, "so_31206988_31206988_5": {"length": 42, "quality": 0.7777777777777778, "section_id": 7486}}}, "31435339": {"Id": "31435339", "PostTypeId": "2", "Body": "<p>I could test in Clang 3.4.1 std=c++11.</p>\n<p>Here are my conclusions :</p>\n<p><code>int i = f().a[0]</code> would be correct : you get a reference to a temporary struct, the lifetime of the temporary is extended for the duration of the reference, you take a <strong>value</strong> : fine.</p>\n<p><code>int *i = &amp;f().a[0]</code> is accepted by the compiler. However, the warning on <code>f</code> saying that you are <em>returning reference to local temporary object</em> makes sense here. The lifetime of the temporary object is extended for the duration of the reference : here the time to copy the address. As soon as you have taken the address of <code>a</code>, the containing object vanishes and you only have a <em>dangling reference</em>.</p>\n<p><code>int *i = f().a</code> is exactly same case as previous one.</p>\n<p>But when you do  <code>&amp;f().a</code>, you are taking <em>the address of an rvalue of type 'int [3]'</em>, and it does not make sense to take such an address : you can only take its value.</p>\n<p>Let's go one step further :</p>\n<p><code>S s = f();</code> is correct. You get a reference to a temporary struct, the lifetime of the temporary is extended for the duration of the reference, you take a <strong>value</strong> : fine.</p>\n<p>Now <code>&amp;s.a[0]</code> is a well defined pointer to <code>int</code>, as is <code>int *ix2 = &amp;static_cast&lt;S&amp;&amp;&gt;(s).a[0];</code></p>\n<p>You can even write : <code>int (*ix3)[3] = &amp;s.a;</code> to take the address of an array to 3 <code>int</code>, but still for same reason, you cannot write <code>&amp;static_cast&lt;S&amp;&amp;&gt;(s).a</code> because you would take <em>the address of an rvalue of type 'int [3]'</em></p>\n<p>TL/DR</p>\n<p>With <code>S s = f();</code> <code>s.a</code> is a well defined rvalue, <code>s.a[0]</code> is a well defined lvalue (you can write <code>s.a[0] = 5;</code>).</p>\n<p><code>f().s</code> is a rvalue, but using it will invoke UB, because it ends in a reference to a temporary object that will be destroyed before you can use it.</p>\n<p><code>f().s[0]</code> can be used as a well defined rvalue. You can use it as a lvalue, but for the same reason as above, it would invoke UB.</p>\n", "LastActivityDate": "2015-07-15T15:55:27.603", "CommentCount": "0", "CreationDate": "2015-07-15T15:55:27.603", "ParentId": "31206988", "Score": "0", "OwnerUserId": "3545273"}, "33218377": {"Id": "33218377", "PostTypeId": "2", "Body": "<p>As far as I can tell you are indeed correct, this looks a <em>\"bug\"</em>, although to be fair this changed recently with <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1213\" rel=\"nofollow\">CWG defect 1213</a> which says:</p>\n<blockquote>\n<p id=\"so_31206988_33218377_0\">Because the subscripting operation is defined as indirection through a pointer value, the result of a subscript operator applied to an xvalue array is an lvalue, not an xvalue. This could be surprising to some.</p>\n</blockquote>\n<p>and this changed section 5.2.1 [expr.sub] as follows:</p>\n<blockquote>\n<p id=\"so_31206988_33218377_1\">A postfix expression followed by an expression in square brackets is a\n  postfix expression. One of the expressions shall have the type\n  <strong>\u201carray of T\u201d or</strong> \u201cpointer to T\u201d and the other shall have unscoped enumeration or integral type. The result is <s>an lvalue</s> of type\n  \u201cT.\u201d The type \u201cT\u201d shall be a completely-defined object type.62 The\n  expression E1[E2] is identical (by definition) to *((E1)+(E2)) [Note:\n  see 5.3 [expr.unary] and 5.7 [expr.add] for details of * and + and\n  8.3.4 [dcl.array] for details of arrays. \u2014end note]<strong>, except that in the case of an array operand, the result is an lvalue if that operand\n  is an lvalue and an xvalue otherwise.</strong></p>\n</blockquote>\n<p>So indeed the result of <code>f().a[0];</code> and <code>static_cast&lt;S&amp;&amp;&gt;(s).a[0]</code> should be xvalues. </p>\n<p>This defect did not have a proposed resolution until December 2012 and <a href=\"http://clang.llvm.org/cxx_dr_status.html\" rel=\"nofollow\">clangs defect report support</a> lists the support of that defect report as unknown so most likely the implementers have not gotten to fixing this defect yet.</p>\n<p><b>Update</b></p>\n<p>Filed a clang <a href=\"https://llvm.org/bugs/show_bug.cgi?id=25357\" rel=\"nofollow\">bug report: Subscript operator applied to an temporary array results in an lvalue</a>.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-16T04:21:28.430", "Score": "1", "CreationDate": "2015-10-19T15:30:56.977", "ParentId": "31206988", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-11-16T04:21:28.430"}, "31206988": {"ViewCount": "603", "Body": "<pre><code>struct S{\n    int a[3] = {1,2,3};\n};\n\nS&amp;&amp; f(){return S();}\n\n&amp;f().a;       //[Error] taking address of xvalue (rvalue reference)\n&amp;f().a[0];    //ok in GCC 5.1.0 and Clang 3.6.0\n\nS s;\n&amp;static_cast&lt;S&amp;&amp;&gt;(s).a;     //[Error] taking address of xvalue (rvalue reference)\n&amp;static_cast&lt;S&amp;&amp;&gt;(s).a[0];  //ok in GCC 5.1.0 and Clang 3.6.0\n</code></pre>\n<blockquote>\n<p id=\"so_31206988_31206988_0\">5.7 An expression is an xvalue if it is:</p>\n<p id=\"so_31206988_31206988_1\"><strong>(7.1) \u2014 the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to object type,</strong></p>\n<p id=\"so_31206988_31206988_2\">(7.2) \u2014 a cast to an rvalue reference to object type,</p>\n<p id=\"so_31206988_31206988_3\"><strong>(7.3) \u2014 a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or</strong></p>\n<p id=\"so_31206988_31206988_4\">(7.4) \u2014 a .* pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</p>\n<p id=\"so_31206988_31206988_5\">5.2.1 Subscripting\n   A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions\n  shall have the type \u201carray of <code>T</code>\u201d or \u201cpointer to <code>T</code>\u201d and the other shall have unscoped enumeration\n  or integral type. The result is of type \u201c<code>T</code>\u201d. The type \u201c<code>T</code>\u201d shall be a completely-defined object type. The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))&lt;&lt;*t</code> [ Note: see 5.3 and 5.7 for details of <code>*</code> and\n  <code>+</code> and 8.3.4 for details of arrays. \u2014end note ], <strong>except that in the case of an array operand, the result is an lvalue if that operand is an lvalue and an xvalue otherwise.</strong></p>\n</blockquote>\n<p>So, is <code>f().a[0]</code> an xvalue? </p>\n<p>I think <code>f().a[0]</code> should be an xvalue.</p>\n<hr>\n<p>[Edit1]</p>\n<p>Ignoring <code>&amp;f().a;</code> and <code>&amp;f().a[0];</code> because  12.2[class.temporary]p5.2</p>\n<blockquote>\n<p id=\"so_31206988_31206988_6\">The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not\n  extended; the temporary is destroyed at the end of the full-expression in the return statement</p>\n</blockquote>\n<p><code>static_cast&lt;S&amp;&amp;&gt;(s).a</code> is an xvalue(7.2 and 7.3). </p>\n<p>\" <em><strong>except that in the case of an array operand, the result is an lvalue if that operand is an lvalue and an xvalue otherwise.</strong></em>\"</p>\n<p>So I think <code>static_cast&lt;S&amp;&amp;&gt;(s).a[0]</code> should be an xvalue, but</p>\n<p><code>&amp;static_cast&lt;S&amp;&amp;&gt;(s).a[0];  //ok in GCC 5.1.0 and Clang 3.6.0</code></p>\n<p>Questing:</p>\n<p>Am I wrong? If I am wrong, show me an example that subscripting an array results an xvalue.</p>\n</hr>", "AcceptedAnswerId": "33218377", "Title": "Is `f().a[0]` an xvalue?", "CreationDate": "2015-07-03T12:32:55.350", "Id": "31206988", "CommentCount": "13", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-07-15T18:02:10.573", "LastEditorUserId": "4958516", "LastActivityDate": "2015-11-16T04:21:28.430", "Score": "15", "OwnerUserId": "4958516", "Tags": "<c++>", "AnswerCount": "2"}});