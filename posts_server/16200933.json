post_cb({"16201242": {"ParentId": "16200933", "CommentCount": "2", "Body": "<p>I'm pretty sure that you are not actually <em>\"calling the constructor\"</em> since they are not directly callable IIRC.  The legalese had to do with constructors not being <em>named functions</em> - I don't have a copy of the Standard handy or I might quote it.  I believe what you are doing with <code>test(_b)</code> is creating <del>an unnamed</del> a temporary which invokes the default constructor again.</p>\n", "OwnerUserId": "41747", "PostTypeId": "2", "Id": "16201242", "Score": "0", "CreationDate": "2013-04-24T20:09:20.717", "LastActivityDate": "2013-04-24T20:09:20.717"}, "16200933": {"CommentCount": "6", "AcceptedAnswerId": "16201230", "PostTypeId": "1", "LastEditorUserId": "501557", "CreationDate": "2013-04-24T19:51:49.737", "LastActivityDate": "2013-04-24T20:23:00.363", "LastEditDate": "2013-04-24T20:09:36.803", "ViewCount": "3452", "FavoriteCount": "16", "Title": "Infinite loop in constructor without for or while", "Id": "16200933", "Score": "60", "Body": "<p>I did a test here, but the output is a loop without ending, I don't know why.</p>\n<p>Actually, I am doing another test, but when I wrote this, I don't understand how the loop occurred. It is output \"ABC\" repeatedly. </p>\n<pre><code>#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nclass test\n{\npublic:\n   std::map &lt;int, int&gt; _b;\n   test();\n   test (std::map&lt;int, int&gt; &amp; im);\n   ~test();\n   };\n\ntest::test()\n{\n  std::cout&lt;&lt;\"abc\";\n  _b.clear();\n  _b[1]=1;\n  test(_b);\n}\n\ntest::test(std::map &lt;int, int&gt;&amp; im)\n{\n   std::cout&lt;&lt;im[1];\n}\n\ntest::~test() {};\n\nint main ()\n{\n   test a;  \n}\n</code></pre>\n", "Tags": "<c++><recursion><constructor><const>", "OwnerUserId": "1685917", "AnswerCount": "4"}, "16201055": {"ParentId": "16200933", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I'm not familiar with the particularities of the standard, but it may be that calling a constructor within a constructor is undefined. As such it could be compiler dependent. In this particular case it causes infinite recursion of your default constructor without ever calling your constructor with the map argument.</p>\n<p>C++ FAQ 10.3 has an example with a constructor that has two parameters. If you add an int parameters to your second constructor such as <code>test(map, int)</code>, it exhibits a somewhat normal behaviour.</p>\n<p>For good form I would simply change <code>test::test(std::map &lt;int, int&gt;&amp; im)</code> for <code>test::testInit(std::map &lt;int, int&gt;&amp; im)</code>, and <code>test(_b)</code> to <code>testInit(_b)</code>.</p>\n", "OwnerUserId": "154088", "LastEditorUserId": "154088", "LastEditDate": "2013-04-24T20:23:00.363", "Id": "16201055", "Score": "0", "CreationDate": "2013-04-24T19:59:05.170", "LastActivityDate": "2013-04-24T20:23:00.363"}, "16201230": {"ParentId": "16200933", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The issue here is that the compiler interprets</p>\n<pre><code>test(_b);\n</code></pre>\n<p>Not as code that creates a temporary object of type <code>test</code> passing in parameter <code>_b</code>, but as a variable declaration for a variable named <code>_b</code> of type <code>test</code>, using the default constructor.  Consequently, what looks like a piece of code that creates a temporary <code>test</code> object using the second constructor is instead recursively creating a new object of type <code>test</code> and invoking the constructor another time.</p>\n<p>To fix this, you can give the variable an explicit name, such as</p>\n<pre><code>test t(_b);\n</code></pre>\n<p>This can only be interpreted as a variable of type <code>test</code> named <code>t</code>, initialized using the second constructor.</p>\n<p>I have <strong>never</strong> seen this before, and I've been programming in C++ for years.  Thanks for showing me <em>yet another</em> corner case of the language!</p>\n<p>For an official explanation: According to the C++03 ISO spec, \u00a76.8:</p>\n<blockquote>\n<p id=\"so_16200933_16201230_0\">There is an ambiguity in the grammar involving expression-statements and declarations: An expression-statement with a function-style explicit type conversion (5.2.3) as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a (. <strong>In those cases the statement is a declaration.</strong></p>\n</blockquote>\n<p>(My emphasis).  In other words, any time C++ could interpret a statement as either an expression (the temporary object cast) or as a declaration (of a variable), it will pick the declaration.  The C++ spec explicitly gives</p>\n<blockquote>\n<p id=\"so_16200933_16201230_1\">T(a);</p>\n</blockquote>\n<p>As an example of a declaration, not a cast of <code>a</code> to something of type <code>T</code>.</p>\n<p>This is C++'s <a href=\"http://en.wikipedia.org/wiki/Most_vexing_parse\" rel=\"noreferrer\">Most Vexing Parse</a> - what looks like an expression is instead getting interpreted as a declaration.  I've seen the MVP before, but I have never seen it in this context.</p>\n<p>Hope this helps!</p>\n", "OwnerUserId": "501557", "LastEditorUserId": "501557", "LastEditDate": "2013-04-24T20:16:02.153", "Id": "16201230", "Score": "94", "CreationDate": "2013-04-24T20:08:42.940", "LastActivityDate": "2013-04-24T20:16:02.153"}, "bq_ids": {"n4140": {"so_16200933_16201230_0": {"section_id": 3921, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_16200933_16201230_0": {"section_id": 3781, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_16200933_16201230_0": {"section_id": 4807, "quality": 0.9615384615384616, "length": 25}}}, "16201053": {"ParentId": "16200933", "CommentCount": "4", "Body": "<p>the problem is from constructor you again calling the contructor test(_b)</p>\n<blockquote>\n<p id=\"so_16200933_16201053_0\">test::test(){std::cout&lt;&lt;\"abc\";_b.clear();_b[1]=1;test(_b);}</p>\n</blockquote>\n<p>here is what happens</p>\n<p>everytime you call test(_b) it first calls  default constructor test::test and it in turns calls the test(_b) and the loop goes on and on untill the stack overflows.</p>\n<p>remove the test(_b) from the default constructor</p>\n", "OwnerUserId": "1855442", "PostTypeId": "2", "Id": "16201053", "Score": "0", "CreationDate": "2013-04-24T19:58:52.563", "LastActivityDate": "2013-04-24T19:58:52.563"}});