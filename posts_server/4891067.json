post_cb({"4891188": {"ParentId": "4891067", "CommentCount": "1", "Body": "<p>If you just want integral values,then you can define <code>enum</code> as well:</p>\n<pre><code>#include &lt;algorithm&gt;\n\nstruct Foo\n{\n    enum integrals { A = 1, B = 2} ;\n};\n\nint main()\n{\n    return std::min(Foo::A, Foo::B);\n}\n</code></pre>\n<p>This is more than enough. No declaration needed outside the class!</p>\n<p>Online Demo : <a href=\"http://www.ideone.com/oE9b5\" rel=\"nofollow\">http://www.ideone.com/oE9b5</a></p>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "4891188", "Score": "3", "CreationDate": "2011-02-03T20:14:39.423", "LastActivityDate": "2011-02-03T20:14:39.423"}, "4893928": {"ParentId": "4891067", "CommentCount": "2", "Body": "<p>Seeing as you're basically using struct as a namespace, why not just use namespace:</p>\n<pre><code>#include &lt;algorithm&gt;\n\nnamespace Foo\n{\n    const int A = 1;\n    const int B = 2;\n};\n\nint main()\n{\n    return std::min(Foo::A, Foo::B);\n}\n</code></pre>\n", "OwnerUserId": "591478", "PostTypeId": "2", "Id": "4893928", "Score": "1", "CreationDate": "2011-02-04T02:18:58.597", "LastActivityDate": "2011-02-04T02:18:58.597"}, "4891067": {"CommentCount": "1", "CreationDate": "2011-02-03T20:03:40.023", "PostTypeId": "1", "AcceptedAnswerId": "4891102", "LastEditorUserId": "16673", "LastActivityDate": "2013-03-12T10:10:38.750", "LastEditDate": "2011-02-03T21:24:03.040", "ViewCount": "8817", "FavoriteCount": "8", "Title": "Weird undefined symbols of static constants inside a struct/class", "Id": "4891067", "Score": "27", "Body": "<p>Either I'm very tired or something weird is happening that I'm not aware of, because the code below is <strong>resulting in undefined symbols for Foo::A and Foo::B when linking</strong>. This is minimized as much as I could from a larger project, but shows the essence of what I'm looking at.</p>\n<pre><code>#include &lt;algorithm&gt;\n\nstruct Foo\n{\n    static const int A = 1;\n    static const int B = 2;\n};\n\nint main()\n{\n    return std::min(Foo::A, Foo::B);\n}\n</code></pre>\n<p><strong>Without the std::min function template it works fine</strong>, i.e. just return Foo::A. Also fine is when defining the static ints outside a class/struct (global in this simple case). However, as soon as they're inside like this, the linker cannot find them.</p>\n<p>Can someone explain what's happening?</p>\n", "Tags": "<c++><initialization><definition><static-members><undefined-symbol>", "OwnerUserId": "534005", "AnswerCount": "5"}, "4891102": {"ParentId": "4891067", "PostTypeId": "2", "CommentCount": "11", "Body": "<h2>Definition needed</h2>\n<p>The code you have provided is non-standard. While you can provide initializers for const static int members directly in the class, you still need to provide separate definitions. It is weird, a kind of unexpected, but you are expected to write it like this:</p>\n<pre><code>#include &lt;algorithm&gt;\n\nstruct Foo\n{\n    static const int A = 1;\n    static const int B = 2;\n};\n\nconst int Foo::A;\nconst int Foo::B;\n\nint main()\n{\n    return std::min(Foo::A, Foo::B);\n}\n</code></pre>\n<p>Quote from standard can be found in a similar question at <a href=\"https://stackoverflow.com/questions/3792412/const-and-static-specifiers-in-c/3792427#3792427\">const and static specifiers in c++</a></p>\n<h2>Why sometimes the code \"works\" without a definition?</h2>\n<p>As for why you can often get around even without providing the definition: if you are using those members only in constant expressions, compiler will always resolve them directly and there will be no access left for linker resolution. It is only when you use it in some way which cannot be handled by compiler directly, and only in such case the linker will detect the symbol is undefined. I guess this is probably a bug in the Visual Studio compiler, but given the nature of the bug I doubt it will be ever fixed.</p>\n<p>Why your source falls into the \"linker\" category is something I do not see, one would need to dissect the std::min to understand that. <em>Note: When I have tried it <a href=\"http://www.ideone.com/ggHZL\" rel=\"noreferrer\">online with GCC</a>, it worked, the error was not detected.</em></p>\n<h2>Alternative: use enum</h2>\n<p>Another alternative is to use enum. This version can also come handy when you hit an old compiler which does not support static const int \"inline\" initializers (such as was Visual Studio 6). Note however that with std::min you are hitting other problems with enums and you need to use an explicit instantiation or casting, or have both A and B in one named enum as in <a href=\"https://stackoverflow.com/questions/4891067/weird-undefined-symbols-of-static-constants-inside-a-struct-class/4891098#4891098\">the answer by Nawaz</a>:</p>\n<pre><code>struct Foo\n{\n    enum {A = 1};\n    enum {B = 2};\n};\n\nint main()\n{\n    return std::min&lt;int&gt;(Foo::A, Foo::B);\n}\n</code></pre>\n<h2>Standards</h2>\n<p>Note: even <a href=\"http://www.stroustrup.com/bs_faq2.html#in-class\" rel=\"noreferrer\">Stroustrup C++ FAQ</a> gets this wrong and does not require the definition as strictly as the standard does:</p>\n<blockquote>\n<p id=\"so_4891067_4891102_0\">You can take the address of a static member if (and only if) it has an out-of-class definition</p>\n</blockquote>\n<p>The definition <strong>is</strong> required by a standard in 9.4.2:</p>\n<p>C++03 wording:</p>\n<blockquote>\n<p id=\"so_4891067_4891102_1\">The member shall still be defined in a name-space scope if it is used in the program and the namespace scope definition shall not contain an initializer</p>\n</blockquote>\n<p>C++11 wording of 9.4.2 is a bit different:</p>\n<blockquote>\n<p id=\"so_4891067_4891102_2\"><em>3</em> The member shall still be de\ufb01ned in a namespace scope if it is odr-used (3.2) in the program</p>\n</blockquote>\n<p>3.2 says following about odr-use:</p>\n<blockquote>\n<p id=\"so_4891067_4891102_3\"><em>3</em> A variable x whose name appears as a potentially-evaluated expression ex is odr-used unless x is an object that satis\ufb01es the requirements for appearing in a constant expression (5.19) and ex is an element of the set of potential results of an expression e, where either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression (Clause 5).</p>\n<p id=\"so_4891067_4891102_4\"><em>4</em> Every program shall contain exactly one de\ufb01nition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>I have to admit I am not sure what the exact implications of C++11 wording are, as I fail to understand the odr-use rules.</p>\n", "OwnerUserId": "16673", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:25.080", "Id": "4891102", "Score": "40", "CreationDate": "2011-02-03T20:07:02.343", "LastActivityDate": "2013-03-12T10:10:38.750"}, "11447339": {"ParentId": "4891067", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are good answers here, but one additional thing to note is that the parameters of <code>std::min()</code> are references, which is what requires the addresses of the passed in variables, and since those variables don't make it to the object file for the compilation unit, the linker cannot resolve their addresses.</p>\n<p>You are probably getting this in an non-optimized build, correct? </p>\n<p>I bet that you won't get this with gcc if you enable optimizations. The call to <code>std::min()</code> will get inlined and the references will go away.</p>\n<p>Also, if you were to assign <code>Foo::A</code> and <code>Foo::B</code> to two local variables right before the call to <code>std::min()</code>, this issue would also go away. </p>\n<p>This isn't ideal, but if you don't own the code that defines the variables that are causing you this issue, then this is something you can consider.</p>\n", "OwnerUserId": "1183991", "LastEditorUserId": "1261007", "LastEditDate": "2012-10-11T01:11:53.377", "Id": "11447339", "Score": "1", "CreationDate": "2012-07-12T07:53:41.833", "LastActivityDate": "2012-10-11T01:11:53.377"}, "bq_ids": {"n4140": {"so_4891067_4891102_2": {"section_id": 5908, "quality": 0.7142857142857143, "length": 5}, "so_4891067_4891102_3": {"section_id": 7040, "quality": 0.7777777777777778, "length": 21}, "so_4891067_4891102_4": {"section_id": 7041, "quality": 0.9166666666666666, "length": 11}, "so_4891067_4891102_1": {"section_id": 5908, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_4891067_4891102_2": {"section_id": 5680, "quality": 0.7142857142857143, "length": 5}, "so_4891067_4891102_4": {"section_id": 6786, "quality": 0.9166666666666666, "length": 11}, "so_4891067_4891102_1": {"section_id": 5680, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_4891067_4891102_2": {"section_id": 7390, "quality": 0.7142857142857143, "length": 5}, "so_4891067_4891102_3": {"section_id": 8537, "quality": 0.7777777777777778, "length": 21}, "so_4891067_4891102_4": {"section_id": 8538, "quality": 0.9166666666666666, "length": 11}, "so_4891067_4891102_1": {"section_id": 7390, "quality": 0.9090909090909091, "length": 10}}}, "4891098": {"ParentId": "4891067", "CommentCount": "2", "Body": "<p>You must define the static constants outside the class definition.</p>\n<pre><code>struct Foo {\n    static const int A;\n    static const int B;\n};\n\nconst int Foo::A = 1;\nconst int Foo::B = 2;\n</code></pre>\n", "OwnerUserId": "456", "PostTypeId": "2", "Id": "4891098", "Score": "2", "CreationDate": "2011-02-03T20:06:34.470", "LastActivityDate": "2011-02-03T20:06:34.470"}});