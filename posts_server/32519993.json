post_cb({"32520133": {"ParentId": "32519993", "CommentCount": "1", "CreationDate": "2015-09-11T09:29:49.260", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "32520133", "Score": "6", "Body": "<p>If object of type <code>Foo</code> is not const object, that you can use something like</p>\n<pre><code>template&lt;size_t N&gt;\nvoid f(const char(&amp;a)[N])\n{\n   std::cout &lt;&lt; \"const char[] version\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;size_t N&gt;\nvoid f(char(&amp;a)[N])\n{\n   std::cout &lt;&lt; \"char[] version\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>But if object is const, than <code>buf</code> and <code>string-literal</code> have equivalent types (diff can be only in symbols count, i.e. <code>N</code>) and you cannot distinguish them.</p>\n<blockquote>\n<p id=\"so_32519993_32520133_0\">A string literal is a sequence of characters (as defined in 2.14.3)\n  surrounded by double quotes</p>\n<p id=\"so_32519993_32520133_1\">Ordinary string literals and UTF-8 string literals are also referred\n  to as narrow string literals. A narrow string literal has type \u201carray\n  of n const char\u201d, where n is the size of the string as defined below,\n  and has static storage duration (3.7).</p>\n</blockquote>\n", "LastActivityDate": "2015-09-11T09:29:49.260"}, "32521110": {"ParentId": "32519993", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-09-11T10:19:34.023", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:03:56.153", "Id": "32521110", "OwnerUserId": "5324741", "Body": "<p>Building on <a href=\"https://stackoverflow.com/a/32520133/5324741\">ForEveR's answer</a>\nIt is also worth discussing why checking for a string rvalue reference(std::is_rvalue_reference) would not work</p>\n<blockquote>\n<p id=\"so_32519993_32521110_0\">I try std::is_rvalue_reference but without success.</p>\n</blockquote>\n<p>This is because string literals are in fact lvalues as stated in 5.1.1.1</p>\n<blockquote>\n<p id=\"so_32519993_32521110_1\">A literal is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other\n  literals are prvalues.</p>\n</blockquote>\n", "LastActivityDate": "2015-09-11T10:19:34.023"}, "bq_ids": {"n4140": {"so_32519993_32521110_1": {"section_id": 5947, "quality": 0.9375, "length": 15}, "so_32519993_32520133_0": {"section_id": 5349, "quality": 0.8888888888888888, "length": 8}, "so_32519993_32520133_1": {"section_id": 5356, "quality": 1.0, "length": 26}}, "n3337": {"so_32519993_32521110_1": {"section_id": 5717, "quality": 0.9375, "length": 15}, "so_32519993_32520133_0": {"section_id": 5146, "quality": 0.8888888888888888, "length": 8}, "so_32519993_32520133_1": {"section_id": 5153, "quality": 1.0, "length": 26}}, "n4659": {"so_32519993_32521110_1": {"section_id": 7433, "quality": 0.9375, "length": 15}, "so_32519993_32520133_0": {"section_id": 6774, "quality": 0.7777777777777778, "length": 7}, "so_32519993_32520133_1": {"section_id": 6781, "quality": 1.0, "length": 26}}}, "32521225": {"ParentId": "32519993", "CommentCount": "0", "CreationDate": "2015-09-11T10:26:15.733", "OwnerUserId": "194635", "PostTypeId": "2", "Id": "32521225", "Score": "0", "Body": "<p>It is not possible, because both <code>foo.buf</code> and <code>\"st\"</code> have the same type: <code>const char[3]</code>.</p>\n<p>But, you can distinguish them if you change <code>buf</code> type. This can be a practical solution.</p>\n<pre><code>struct Foo {\n    std::array&lt;char, 3&gt; buf;\n};\n\ntemplate&lt;size_t N&gt;\nvoid f(const char(&amp;a)[N])\n{\n   std::cout &lt;&lt; \"const char[N] version\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;size_t N&gt;\nvoid f(const std::array&lt;char, N&gt;&amp;)\n{\n   std::cout &lt;&lt; \"const std::array[N] version\" &lt;&lt; std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2015-09-11T10:26:15.733"}, "32519993": {"CommentCount": "9", "ViewCount": "348", "CreationDate": "2015-09-11T09:22:06.833", "LastActivityDate": "2015-09-11T10:26:15.733", "Title": "c++ overload between \"str\" and const char[N]?", "AcceptedAnswerId": "32520133", "PostTypeId": "1", "Id": "32519993", "Score": "3", "Body": "<p>Is it possible to overload such calls?</p>\n<pre><code>f(\"st\");//variant 1\nstruct Foo { char buf[3]; Foo() { strcpy(buf, \"aa\"); } };\nconst Foo foo;\nf(foo.buf);//variant 2\n</code></pre>\n<p>In both cases <code>typeid</code> give the same type,\nis any variant to distinguish between two calls of <code>f</code> above,\nand have two variants of <code>f</code>? I try <code>std::is_rvalue_reference</code> but without success. </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1244932", "AnswerCount": "3"}});