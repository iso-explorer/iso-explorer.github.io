post_cb({"bq_ids": {"n4140": {"so_23191702_23193909_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}}, "n3337": {"so_23191702_23193909_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}}, "n4659": {"so_23191702_23193909_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}}}, "23195067": {"Id": "23195067", "PostTypeId": "2", "Body": "<p>This is valid. In unevaluated operands (decltype, sizeof among others) you can name nonstatic datamembers without an object expression, within arbitrary subexpressions. Note that that this does not apply to nonstatic member functions, but only to data members.</p>\n", "LastActivityDate": "2014-04-21T10:00:55.493", "CommentCount": "0", "CreationDate": "2014-04-21T10:00:55.493", "ParentId": "23191702", "Score": "3", "OwnerUserId": "34509"}, "23193909": {"Id": "23193909", "PostTypeId": "2", "Body": "<p>You can use <strong>decltype</strong> on any valid C++ expression, therefore your 3 statements are correct (it has nothing to do with static or non static modifiers).</p>\n<p>Section 7.1.6.2 of the standard says</p>\n<blockquote>\n<p id=\"so_23191702_23193909_0\">The type denoted by decltype(e) is defined as follows: </p>\n</blockquote>\n<ul>\n<li>if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5),  decltype(e)\nis the type of the entity named by e . If there is no such entity, or if e names a set of overloaded functions, the program is ill-formed;</li>\n<li>otherwise, if e is an xvalue, decltype(e) is T&amp;&amp; , where T is the type of e ; </li>\n<li>otherwise, if e is an lvalue, decltype(e) is T&amp; , where T is the type of e ;</li>\n<li>otherwise, decltype(e) is the type of e.</li>\n</ul>\n<p>For standard references, see <a href=\"http://www.stroustrup.com/C++11FAQ.html#decltype\" rel=\"nofollow\">stroustrup FAQ here</a></p>\n", "LastEditorUserId": "3510483", "LastActivityDate": "2014-04-21T08:53:45.447", "Score": "1", "CreationDate": "2014-04-21T08:43:57.453", "ParentId": "23191702", "CommentCount": "3", "OwnerUserId": "3510483", "LastEditDate": "2014-04-21T08:53:45.447"}, "23191702": {"ViewCount": "146", "Body": "<p>The question is the commented lines' in the code below:</p>\n<pre><code>struct MemberType\n{\n    int test;\n};\n\nstruct MyTag\n{\n    MemberType non_static_m;// Note that it's NOT defined with 'static'.\n};\n\nint main(void)\n{\n    typedef decltype(MyTag::non_static_m) TestType_Good;// Well-formed in C++11.\n    typedef decltype(MyTag::non_static_m.test) TestType_1;// Is it right or wrong?\n    typedef decltype(MyTag::non_static_m.test + 1) TestType_2;// Is it right or wrong?\n\n    return 0;\n}\n</code></pre>\n<p>Note that the member in 'MyTag' is a non-static field.\nI would be grateful if relevant clauses in the ISO standard documents were listed.</p>\n", "AcceptedAnswerId": "23195067", "Title": "Is the expression 'decltype(MyTag::non_static_m.test + 1)' syntactically valid?", "CreationDate": "2014-04-21T05:59:07.583", "Id": "23191702", "CommentCount": "1", "LastEditDate": "2014-04-21T09:47:12.677", "PostTypeId": "1", "LastEditorUserId": "1362568", "LastActivityDate": "2014-04-21T10:00:55.493", "Score": "3", "OwnerUserId": "2848654", "Tags": "<c++><c++11><decltype>", "AnswerCount": "2"}});