post_cb({"bq_ids": {"n4140": {"so_42171550_42171616_1": {"length": 4, "quality": 1.0, "section_id": 3329}}, "n3337": {"so_42171550_42171616_1": {"length": 4, "quality": 1.0, "section_id": 3199}}, "n4659": {"so_42171550_42171616_1": {"length": 4, "quality": 1.0, "section_id": 4095}}}, "42171616": {"Id": "42171616", "PostTypeId": "2", "Body": "<p>Long story short, this works because converting from <code>int</code> to <code>double</code> is <em>not</em> a narrowing conversion. In other words, this works for the same reason why the following code works:</p>\n<pre><code>double x = 1;\n</code></pre>\n<p>The compiler is required to construct <code>std::initializer_list&lt;E&gt;</code> for curly brace initialization. It knows the type of <code>E</code> to be <code>double</code>, because you are initializing a <code>std::vector&lt;double&gt;</code>. This is described in details in section 8.5.4 of the C++11 standard.</p>\n<p>Here is an example from section 8.5.4.3:</p>\n<blockquote id=\"so_42171550_42171616_0\">\n<pre><code>struct S {\n    S(std::initializer_list&lt;double&gt;); // #1\n    S(const std::string&amp;); // #2\n    // ...\n};\nconst S&amp; r1 = { 1, 2, 3.0 }; // OK: invoke #1\n</code></pre>\n</blockquote>\n<p>The same section defines narrowing conversion as follows:</p>\n<blockquote>\n<p id=\"so_42171550_42171616_1\">A narrowing conversion is an implicit conversion</p>\n<ul>\n<li>from a floating-point type to an integer type, or</li>\n<li>from long double to double or float, or from double to float, except where the source is a constant expression and the actual value after conversion is within the range of values that can be represented\n  (even if it cannot be represented exactly), or</li>\n<li>from an integer type or unscoped enumeration type to a floating-point type, except where the source is a constant expression and the actual value after conversion will fit into the target type and will produce the original value when converted back to the original type, or</li>\n<li>from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, except where the source is a constant expression whose value after integral promotions will fit into the target type.</li>\n</ul>\n</blockquote>\n<p>The two examples with <code>ii</code> fall into the third category, i.e. conversion from <code>int</code> to <code>double</code> when the source is <em>not</em> a constant expression.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2017-02-11T03:09:28.243", "Score": "4", "CreationDate": "2017-02-11T02:46:19.787", "ParentId": "42171550", "CommentCount": "5", "OwnerUserId": "335858", "LastEditDate": "2017-02-11T03:09:28.243"}, "42171550": {"ViewCount": "93", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    // case I: uniform initialization\n    //\n    int ii = 100;\n    // Error: cannot be narrowed from type 'int' to 'double' \n    // in initializer list\n    //\n    double dd{ ii };\n\n    // case II: initializer_list\n    //\n    std::vector&lt;double&gt; vecDouble{ 1, 2.2 }; // fine!\n\n    // case III: initializer_list\n    //\n    std::vector&lt;int&gt; vi = { 1, 2.3 }; // error: double to int narrowing\n\n    // case IV: intializer_list\n    // cannot be narrowed from type 'int' to 'double'\n    //\n    std::vector&lt;double&gt; vecD2{ ii, 2.2 }; // Error\n}\n</code></pre>\n<p>Why there is inconsistency here where caseI doesn't accept int to double conversion but caseII allows the conversion.</p>\n", "AcceptedAnswerId": "42171616", "Title": "why vector<double> accepts initializer_list with integer elements?", "CreationDate": "2017-02-11T02:32:45.727", "LastActivityDate": "2017-03-14T17:41:30.783", "CommentCount": "2", "LastEditDate": "2017-03-14T17:41:30.783", "PostTypeId": "1", "LastEditorUserId": "560648", "Id": "42171550", "Score": "4", "OwnerUserId": "391104", "Tags": "<c++><c++11>", "AnswerCount": "1"}});