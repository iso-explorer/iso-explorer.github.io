post_cb({"33011014": {"CommentCount": "6", "ViewCount": "69", "CreationDate": "2015-10-08T08:52:34.213", "LastActivityDate": "2015-10-08T22:36:38.343", "Title": "delete operator with chained dynamic allocation", "AcceptedAnswerId": "33011089", "PostTypeId": "1", "Id": "33011014", "Score": "0", "Body": "<p>Let's assume I have two classes named classA and classB. I create a pointer to classA, and then dynamically allocate a single object using the new operator as follows:</p>\n<p><code>classA *ptrA = new classA</code></p>\n<p>classA has a member of type pointer to classB, and in its default constructor it allocates an array of objects of type classB on the heap as follows:</p>\n<p><code>memberOfA = new classB[10]</code></p>\n<p>and to complicate things further, classB has a member variable of type int*, and in its default constructor it allcoates an array of integer on the heap as follows:</p>\n<p><code>memberOfB = new int[100]</code></p>\n<p>Now, if I call a delete on ptrA using <code>delete ptrA</code>, how will the compiler go about deallocating the memory allocated by <code>memberOfA</code> and <code>memberOfB</code>.</p>\n", "Tags": "<c++><memory-management>", "OwnerUserId": "4694206", "AnswerCount": "3"}, "33011194": {"ParentId": "33011014", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-10-08T09:01:22.970", "Score": "1", "LastEditorUserId": "4345926", "LastEditDate": "2015-10-08T22:36:38.343", "Id": "33011194", "OwnerUserId": "4345926", "Body": "<p>It will not ... you should do that by implementing the destructor! You can do that by using the delete [] operator. </p>\n<pre><code>classA::~classA() {\n   delete [] memberOfA;\n}\n</code></pre>\n<p>and </p>\n<pre><code> classB::~classB() {\n   delete [] memberOfB;\n }\n</code></pre>\n<p>and then you do delete ptrA the order of execution will be:</p>\n<pre><code>call classA::~classA()\ncall classB::~classB() on each of the elements of memberOfA\ndeallocate memory for the array of ints pointed by memberofB\ndeallocate memory for the array of memberofA\ndeallocate memory for classA\n</code></pre>\n<p>Deallocation of memory can actually happen at later stages in some cases.</p>\n<p>Alternatively, if you don't really need to work with pointer use arrays or vectors to hold your elements.</p>\n<pre><code>class classB\n{\n...\nstd::array&lt;int,100&gt; memberOfB;\n...\n};\nclass classA\n{\n...\nstd::array&lt;classB,10&gt; memberOfA;\n...\n};\n\nstd::unique_ptr&lt;A&gt; ptrA(new classA)\n</code></pre>\n", "LastActivityDate": "2015-10-08T22:36:38.343"}, "33011089": {"ParentId": "33011014", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-10-08T08:55:59.483", "Score": "1", "LastEditorUserId": "111143", "LastEditDate": "2015-10-08T09:19:41.527", "Id": "33011089", "OwnerUserId": "111143", "Body": "<p><code>memberOfA</code> and <code>memberOfB</code> is only deallocated if you put a <code>delete[]</code> in the destrutors of <code>classA</code> and <code>classB</code>. So if you had written the destructor of <code>classA</code> so that it freed the memory pointed to by <code>memberOfA</code> like this:</p>\n<pre><code>classA::~classA() {\n    delete [] memberOfA;\n}\n</code></pre>\n<p>In this case the destructor would free the array calling the destructors of the elements pointed by the entries in <code>memberOfA</code>. The same can be said for the destructor of <code>classB</code>:</p>\n<pre><code>classB::~classB() {\n    delete [] memberOfB;\n}\n</code></pre>\n<p>Remember using <code>new</code> must be paired with a subsequent <code>delete</code> at some point, if not you are look at a leak. Perhaps you should consider one of the smart pointer classes: <code>unique_ptr</code>, and <code>shared_ptr</code>.</p>\n<p>If your design allows for <code>classA</code> and <code>classB</code> to use a <code>unique_ptr</code> or <code>shared_ptr</code> to the array, much of the dangers of a leak would have been overcome:</p>\n<pre><code>std::unique_ptr&lt;classB[]&gt; memberOfA(new classB[10]);\n</code></pre>\n<p>If the order of the deletion is of interest to you then, invoking the <code>delete ptrA</code> will result in the destructor of <code>classA</code> being called, and if we assume that it is implemented as hinted above (using <code>delete []</code>) then the <code>delete []</code> operator will call the destructors of all the members in decreasing address order, quote from the Standard, draft N3690, \u00a7 5.3.5 / 6:</p>\n<blockquote>\n<p id=\"so_33011014_33011089_0\">If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion of their constructor; see 12.6.2).</p>\n</blockquote>\n<p>This will of course lead to the destructor of <code>classB</code> being called for each element, which will again utilize the <code>delete [] memberOfB</code> which will release the array pointing to the integers.</p>\n", "LastActivityDate": "2015-10-08T09:19:41.527"}, "bq_ids": {"n4140": {"so_33011014_33011089_0": {"section_id": 6110, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_33011014_33011089_0": {"section_id": 5876, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_33011014_33011089_0": {"section_id": 7607, "quality": 0.9666666666666667, "length": 29}}}, "33011110": {"ParentId": "33011014", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-08T08:57:12.947", "Score": "2", "LastEditorUserId": "3425536", "LastEditDate": "2015-10-08T09:05:55.873", "Id": "33011110", "OwnerUserId": "3425536", "Body": "<blockquote>\n<p id=\"so_33011014_33011110_0\">Now, if I call a delete on ptrA using <code>delete ptrA</code>, how will the compiler go about deallocating the memory allocated by <code>memberOfA</code> and <code>memberOfB</code>.</p>\n</blockquote>\n<p>When you call <code>delete ptrA</code>, the compiler will call the destructor of <code>classA</code>. If that destructor doesn't <code>delete [] memberOfA</code> then you're leaking both <code>memberOfA</code> and consequently <code>memberOfB</code>.</p>\n<p>If instead of manual memory management (<code>new</code> and <code>delete</code>) you used automatic memory management (SBRM/RAII), then you wouldn't have to write any destructors and the resources you allocated would be freed as expected, for example:</p>\n<pre><code>std::unique_ptr&lt;classA&gt; ptrA(new classA);\nstd::unique_ptr&lt;classB[]&gt; memberOfA(new classB[10]);\nstd::unique_ptr&lt;int[]&gt; memberOfB(new int[100]);\n</code></pre>\n<p>This is in fact the modern C++ way to do it. The code becomes simpler to understand as the ownership semantics of the pointers are written in their type and there are no destructors lying around. An even better way would be to use <code>std::make_unique(...)</code> in place of <code>new</code> but I left it out for simplicity.</p>\n", "LastActivityDate": "2015-10-08T09:05:55.873"}});