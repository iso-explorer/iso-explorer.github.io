post_cb({"29453959": {"ParentId": "29453928", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_29453928_29453959_0\">I mean, since the destructor is not virtual, I don't think you can delete a dynamically allocated instance of the derived class type using the pointer of the base class type. What do you think?</p>\n</blockquote>\n<p>You can see <a href=\"https://stackoverflow.com/questions/20573587/why-simple-destructor-does-not-delete-the-derived-object-if-declared-using-base\">here</a> and <a href=\"https://stackoverflow.com/questions/25220229/in-c-inheritance-derived-class-destructor-not-called-when-pointer-object-to-b\">here</a> that this is undefined behavior.</p>\n<blockquote>\n<p id=\"so_29453928_29453959_1\">If the base class has no virtual destructor the behavior of such code is simply undefined.</p>\n</blockquote>\n<p><p></p>\n<blockquote>\n<p id=\"so_29453928_29453959_2\">From the C++ standard:</p>\n<p id=\"so_29453928_29453959_3\">5.3.5 Delete</p>\n<p id=\"so_29453928_29453959_4\">3 In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n</p>", "OwnerUserId": "4505712", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:57:05.923", "Id": "29453959", "Score": "1", "CreationDate": "2015-04-05T04:04:48.613", "LastActivityDate": "2015-04-05T04:07:24.673"}, "29453928": {"CommentCount": "2", "ViewCount": "55", "PostTypeId": "1", "LastEditorUserId": "434551", "CreationDate": "2015-04-05T03:56:46.643", "LastActivityDate": "2015-04-05T08:06:20.813", "Title": "No virtual destructor defined here", "LastEditDate": "2015-04-05T04:05:08.180", "Id": "29453928", "Score": "1", "Body": "<p>This has been provided in my official notes but I spotted an error. Before I take it up to my instructor, I just thought of confirming it here with all my blood brothers- you guys.</p>\n<pre><code>#include &lt;iostream.h&gt;\n\nclass Base {\n   public:\n      virtual void display() { cout &lt;&lt; \"Base class\" &lt;&lt; endl; }\n};\n\nclass Derived: public Base {\n   // Nothing here\n};\n\nvoid main()\n{\n   Base * ptr;\n   // Calls Base::display ( )\n   ptr = new Base ;\n   ptr -&gt;display();\n   delete ptr ;\n   // Calls Base::display ( ) again\n   ptr = new Derived ;\n   ptr -&gt;display();\n   delete ptr ;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>Base class \nBase class\n</code></pre>\n<p><strong>I think the problem is in the very last line of the main function. I mean, since the destructor is not virtual, I don't think you can delete a dynamically allocated instance of the derived class type using the pointer of the base class type. What do you think?</strong></p>\n", "Tags": "<c++>", "OwnerUserId": "4750722", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29453928_29453959_4": {"section_id": 6107, "quality": 0.88, "length": 22}, "so_29453928_29453959_1": {"section_id": 6107, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_29453928_29453959_4": {"section_id": 5873, "quality": 0.88, "length": 22}, "so_29453928_29453959_1": {"section_id": 5873, "quality": 0.6666666666666666, "length": 6}}, "n4659": {"so_29453928_29453959_4": {"section_id": 7604, "quality": 0.88, "length": 22}, "so_29453928_29453959_1": {"section_id": 7604, "quality": 0.6666666666666666, "length": 6}}}, "29455345": {"ParentId": "29453928", "CommentCount": "0", "Body": "<p>When a function is defined as virtual then the compiler will call the function using a pointer to the base using <em>dynamic binding</em>, i.e. the call to the actual function will go through the class vTable to find the relevant implementation of the function. If a function is not defined as virtual then the code generated by the compiler will use <em>static binding</em>, i.e. the compiler will simply call the function it knows. In other words, if you call a non-virtual function on the base class pointer which points to a derived class then the compiler will generate code for calling the base class implementation.</p>\n<p>Now, destructor behavior is just a private case of the general behavior described above. As in the absence of a destructor implementation the compiler will generate a default non-virtual destructor for you, the destruction of an object using a base class pointer will just call the base class destructor. You can reproduce this behavior it easily by explicitly defining the non-virtual destructors for both base and derived classes and use the debugger to see that the base class version is the one being called.</p>\n", "OwnerUserId": "4282370", "PostTypeId": "2", "Id": "29455345", "Score": "0", "CreationDate": "2015-04-05T08:06:20.813", "LastActivityDate": "2015-04-05T08:06:20.813"}});