post_cb({"29754044": {"AcceptedAnswerId": "29754079", "OwnerUserId": "4358182", "LastActivityDate": "2015-04-20T20:38:45.860", "CreationDate": "2015-04-20T17:04:35.303", "Score": "-3", "CommentCount": "8", "Title": "Assign value to uninitialized ptr", "AnswerCount": "3", "PostTypeId": "1", "Tags": "<c++><pointers><gcc>", "Body": "<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    int num = 30;\n    int *ptr;\n    *ptr = num;\n\n    std::cout &lt;&lt; *ptr; // print 30\n    std::cout &lt;&lt; ptr; // memorry address - 0\n}\n</code></pre>\n<p>This code is legal for <a href=\"http://ideone.com/txa2ll\" rel=\"nofollow\">gcc 4.9.2</a>\nWhy error doesn't occur? What sense to store the assigned value in the uninitialized ptr? How it possible to store value in the uninitialized ptr?<br>\nI guess this is undefined behavior because uninitialized ptr contain garbage and therefore he can point to random memmory and compiler think that this is ok until I make <code>int *ptr = NULL;</code>? I can't check this assumption because ptr adrress is always <code>0</code>.</br></p>\n", "Id": "29754044", "ViewCount": "82"}, "29754079": {"PostTypeId": "2", "ParentId": "29754044", "Body": "<p><strong>The code is syntactically correct and always consistently has undefined behaviour.</strong></p>\n<p>An uninitialized variable including pointers do not have any defined value and assigning values to a pointer variable can have varied result, none of which are defined.</p>\n<p><strong>Section 4.1 looks like a candidate (emphasis mine):</strong></p>\n<blockquote>\n<p id=\"so_29754044_29754079_0\">An lvalue (3.10) of a non-function, non-array type T can be converted\n  to an rvalue. If T is an incomplete type, a program that necessitates\n  this conversion is ill-formed. If the object to which the lvalue\n  refers is not an object of type T and is not an object of a type\n  derived from T, or if the object is uninitialized, a program that\n  necessitates this conversion has undefined behavior. If T is a\n  non-class type, the type of the rvalue is the cv-unqualified version\n  of T. Otherwise, the type of the rvalue is T.</p>\n</blockquote>\n", "CreationDate": "2015-04-20T17:06:59.000", "Score": "2", "CommentCount": "0", "Id": "29754079", "OwnerUserId": "977038", "LastActivityDate": "2015-04-20T17:06:59.000"}, "29754252": {"PostTypeId": "2", "ParentId": "29754044", "Body": "<blockquote>\n<p id=\"so_29754044_29754252_0\">This code is legal for gcc 4.9.2</p>\n</blockquote>\n<p>No, it's not.</p>\n<p>Don't mistake \"doesn't produce an error\" for \"is legal\".</p>\n<p>In general compilers cannot diagnose invalid pointer accesses, so they don't. That's your job!</p>\n", "CreationDate": "2015-04-20T17:16:51.600", "Score": "1", "CommentCount": "0", "Id": "29754252", "OwnerUserId": "560648", "LastActivityDate": "2015-04-20T17:16:51.600"}, "29754085": {"PostTypeId": "2", "ParentId": "29754044", "Body": "<p>Your code line <code>int *ptr</code> is a defination, not an initialization, therefore compiler does not assign any resource (register or memory to the value).</p>\n<p>However, directly assign to the memory of an un-init pointer point to is indeed an undefined behavior.</p>\n", "CreationDate": "2015-04-20T17:07:09.370", "Score": "0", "LastEditDate": "2015-04-20T20:38:45.860", "CommentCount": "2", "Id": "29754085", "OwnerUserId": "566459", "LastEditorUserId": "566459", "LastActivityDate": "2015-04-20T20:38:45.860"}, "bq_ids": {"n3337": {"so_29754044_29754079_0": {"quality": 0.8333333333333334, "length": 30, "section_id": 5}}}});