post_cb({"23393808": {"ParentId": "23377647", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_23377647_23393808_0\">Yet 7 and 8 remain as problems</p>\n</blockquote>\n<pre><code>B        cm(std::move(a));  // 7. error: call to constructor of B ambiguous\nB        ct(A{});           // 8. error: call to constructor of B ambiguous\n</code></pre>\n<p>The two cases are the same: direct initialization with rvalue argument of type A.</p>\n<p>The candidate functions for direct initialization are all constructors, and in this case, both copy constructor <code>B::B(const B&amp;)</code> and move constructor <code>B(B&amp;&amp;)</code> are viable, since there is an implicit conversion from rvalue A to both <code>const B&amp;</code> and to <code>B&amp;&amp;</code>. Overload resolution cannot decide between these two constructors because calling either one requires a user-defined conversion directly into the parameter type, and user-defined conversion sequences are only ranked by the <em>second standard conversion</em>:</p>\n<blockquote>\n<p id=\"so_23377647_23393808_1\"><code>13.3.3.2/3[over.ics.rank]</code>: User-defined conversion sequence U1 is a better conversion sequence than another user-defined conversion sequence U2 if they contain the same user-defined conversion function ... and the second standard conversion sequence of U1 is better than the second standard conversion sequence of U2.\"</p>\n</blockquote>\n<p>This is different from calling a member function that has both &amp;&amp; and const &amp;-qualified overloads because in that case, overload resolution is ranking the reference bindings from rvalue argument to implict object parameter accoring to </p>\n<blockquote>\n<p id=\"so_23377647_23393808_2\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence S2 if S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.</p>\n</blockquote>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "23393808", "Score": "3", "CreationDate": "2014-04-30T16:50:23.527", "LastActivityDate": "2014-04-30T16:50:23.527"}, "23377647": {"CommentCount": "18", "AcceptedAnswerId": "23393808", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-04-30T00:29:36.863", "LastActivityDate": "2014-04-30T16:50:23.527", "LastEditDate": "2017-04-13T12:40:36.810", "ViewCount": "325", "FavoriteCount": "2", "Title": "Explicit ref-qualified conversion operator templates in action", "Id": "23377647", "Score": "7", "Body": "<p>Given the following conversion operators</p>\n<pre><code>struct A\n{\n    template&lt;typename T&gt; explicit operator T&amp;&amp;       () &amp;&amp;;\n    template&lt;typename T&gt; explicit operator T&amp;        () &amp;;\n    template&lt;typename T&gt; explicit operator const T&amp;  () const&amp;;\n};\n\nstruct B {};\n</code></pre>\n<p>I would expect the following conversions to be all valid, yet some give compile errors (<a href=\"http://coliru.stacked-crooked.com/a/29424c7bf2976273\" rel=\"nofollow noreferrer\">live example</a>):</p>\n<pre><code>A a;\n\nA&amp;&amp;      ar = std::move(a);\nA&amp;       al = a;\nconst A&amp; ac = a;\n\nB&amp;&amp;      bm(std::move(a));  // 1. OK\nB&amp;&amp;      bt(A{});           // 2. OK\nB&amp;&amp;      br(ar);            // 3. error: no viable conversion from A to B\nB&amp;       bl(al);            // 4. OK\nconst B&amp; bz(al);            // 5. OK\nconst B&amp; bc(ac);            // 6. OK\n\nB        cm(std::move(a));  // 7. error: call to constructor of B ambiguous\nB        ct(A{});           // 8. error: call to constructor of B ambiguous\nB        cr(ar);            // 9. OK\n</code></pre>\n<p>In particular, 1 appears to be identical to 3, and almost identical to 2 (similarly for 7 to 9, 8), yet behave differently.</p>\n<p>Any explanation or workaround?</p>\n<p>My motivation is <a href=\"https://codereview.stackexchange.com/q/48344/39083\">Yet another 'any'</a>, where I eventually had to make all conversion operators <code>explicit</code> to avoid problems with type traits like <code>std::is_constructible</code>, <code>std::is_convertible</code>, then I bumped into new problems.</p>\n<p><strong>EDIT</strong> Sorry, please ignore 3 and 9, my mistake (thanks Kerrek SB). Yet 7 and 8 remain as problems. Also, <code>explicit</code> appears to be irrelevant after all, sorry again.</p>\n<p><strong>EDIT 2</strong> Just noticed that</p>\n<pre><code>B        cm = std::move(a);\nB        ct = A{};\n</code></pre>\n<p>are valid if the conversion operators are not <code>explicit</code>. So that's where <code>explicit</code> comes in: initially my samples used copy-initialization, and when I switched to <code>explicit</code> I had to use direct-initialization. <em>Then</em> this problem came up (cases 7 and 8).</p>\n", "Tags": "<c++><c++11><rvalue-reference><conversion-operator><ref-qualifier>", "OwnerUserId": "2644390", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23377647_23393808_2": {"section_id": 639, "quality": 0.9310344827586207, "length": 27}, "so_23377647_23393808_1": {"section_id": 639, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_23377647_23393808_2": {"section_id": 629, "quality": 0.9310344827586207, "length": 27}, "so_23377647_23393808_1": {"section_id": 629, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_23377647_23393808_2": {"section_id": 667, "quality": 0.9310344827586207, "length": 27}, "so_23377647_23393808_1": {"section_id": 667, "quality": 0.9615384615384616, "length": 25}}}});