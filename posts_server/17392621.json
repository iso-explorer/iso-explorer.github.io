post_cb({"bq_ids": {"n4140": {"so_17392621_17393256_0": {"length": 21, "quality": 0.875, "section_id": 166}}, "n3337": {"so_17392621_17393256_0": {"length": 21, "quality": 0.875, "section_id": 160}}, "n4659": {"so_17392621_17393256_0": {"length": 21, "quality": 0.875, "section_id": 170}}}, "17393256": {"Id": "17393256", "PostTypeId": "2", "Body": "<p>No, it cannot be solved (not without changing the design significantly at least). The problem is that template alias names are not deduced, as mentioned in paragraph 14.5.7/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17392621_17393256_0\">When a template-id refers to the specialization of an alias template, it is equivalent to the associated type\n  obtained by substitution of its template-arguments for the template-parameters in the type-id of the alias\n  template. [ <strong>Note: An alias template name is never deduced.\u2014end note</strong> ] </p>\n</blockquote>\n<p>The paragraph also provides an example:</p>\n<blockquote>\n<p id=\"so_17392621_17393256_1\">[ <em>Example</em>:</p>\n<pre><code>template&lt;class T&gt; struct Alloc { / ... / };\ntemplate&lt;class T&gt; using Vec = vector&lt;T, Alloc&lt;T&gt;&gt;;\nVec&lt;int&gt; v; // same as vector&lt;int, Alloc&lt;int&gt;&gt; v;\n\n...\n\ntemplate&lt;template&lt;class&gt; class TT&gt;\nvoid f(TT&lt;int&gt;);\nf(v); // error: Vec not deduced                          &lt;=== Relevant\n\n...\n</code></pre>\n<p id=\"so_17392621_17393256_2\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>In your concrete case, the problem is that when trying to match the partial specialization, the compiler won't deduce that your type is an instantiation of <code>foo_alt</code> (since <code>foo_alt</code> is the name of an alias template), and the primary template gets picked.</p>\n<p>If you want to use alias templates, you will have to give up a bit of genericity and create a type trait specific for <code>foo</code>:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nstruct foo {};\n\ntemplate&lt;typename T&gt;\nstruct is_instantiation_of_foo : std::false_type { };\n\ntemplate&lt;typename...Ts&gt;\nstruct is_instantiation_of_foo&lt;foo&lt;Ts...&gt;&gt; : std::true_type { };\n</code></pre>\n<p>Which you could then use this way:</p>\n<pre><code>template&lt;typename FooType&gt;\nstruct bar {\n  static_assert(is_instantiation_of_foo&lt;FooType&gt;::value, \"\"); //fail\n};\n</code></pre>\n<p>Now, none of the assertions in the following program will fire:</p>\n<pre><code>template&lt;typename T&gt;\nusing foo_alt = foo&lt;T&gt;;\n\nint main(int,char**) {\n  // None of these fail:\n  bar&lt;foo&lt;int&gt;&gt; b;\n  bar&lt;foo_alt&lt;int&gt;&gt; b2;\n\n  return 0;\n}\n</code></pre>\n<p>Here is a <a href=\"http://coliru.stacked-crooked.com/view?id=8eaa698f73db8c4fdab23a2f86ab3aaf-a63ad9fea3739cb794a74965e5d28fb3\"><strong>live example</strong></a>.</p>\n", "LastActivityDate": "2013-06-30T18:00:16.127", "CommentCount": "5", "CreationDate": "2013-06-30T18:00:16.127", "ParentId": "17392621", "Score": "6", "OwnerUserId": "1932150"}, "17393352": {"Id": "17393352", "PostTypeId": "2", "Body": "<p>If you have an alias template that does <strong>not</strong> alter the template parameters of the referred class (like in your example; it just renames the referred template), then you can use something like (it's not the most elegant way)</p>\n<pre><code>template &lt; template&lt;class...&gt; class TT0, template&lt;class...&gt; class TT1,\n           class... Ts1 &gt;\nstruct is_from_same_template_helper\n{\n    template &lt; class T = TT0&lt;Ts1...&gt;,\n               class = typename std::enable_if&lt;\n                   std::is_same&lt;TT0&lt;Ts1...&gt;, TT1&lt;Ts1...&gt;&gt;::value\n               &gt;::type\n             &gt;\n    static std::true_type test(int);\n\n    template &lt; class T = int &gt;\n    static std::false_type test(...);\n};\n\n\ntemplate&lt;template&lt;class...&gt; class, class&gt;\nstruct is_instantiation_of : public std::false_type { };\n\ntemplate&lt;template&lt;class...&gt; class TT0, template&lt;class...&gt; class TT1,\n         class... Ts1&gt;\nstruct is_instantiation_of&lt;TT0, TT1&lt;Ts1...&gt;&gt;\n    : public decltype( is_from_same_template_helper&lt;TT0, TT1, Ts1...&gt;\n                       ::template test&lt;&gt;(0) )\n{ };\n</code></pre>\n<p>Thanks to <a href=\"https://stackoverflow.com/users/1774667/yakk\">Yakk</a> for pointing out that you need a SFINAE-type of check in order to only let the <code>static_assert</code> fail (previous version failed due to a compiler error before the <code>static_assert</code>).</p>\n<p>As only the specializations of alias templates are equal to specializations of the referred template; the alias template itself is not equal to the referred template.</p>\n<p><strong>If the alias template does alter the template parameters, the implementation above can create false negatives.</strong></p>\n<hr>\n<p>As an xy-Problem, you could change your implementation to:</p>\n<pre><code>#include &lt;type_traits&gt;\n\n\ntemplate &lt; template &lt;typename...&gt; class TT0, template &lt;typename...&gt; class TT1 &gt;\nstruct is_same_template : public std::false_type { };\n\ntemplate &lt; template &lt;typename...&gt; class TT &gt;\nstruct is_same_template &lt; TT, TT &gt; : public std::true_type { };\n\n\ntemplate &lt; typename T0, typename T1 &gt;\nstruct is_from_same_template : public std::false_type { };\n\ntemplate &lt; template &lt;typename...&gt; class TT0, template &lt;typename...&gt; class TT1,\n           typename... Ts0, typename... Ts1 &gt;\nstruct is_from_same_template &lt; TT0&lt;Ts0...&gt;, TT1&lt;Ts1...&gt; &gt;\n    : public is_same_template&lt;TT0, TT1&gt; { };\n\n\ntemplate&lt;typename T&gt;\nstruct foo {};\n\n//Added: alias for foo\ntemplate&lt;typename T&gt;\nusing foo_alt = foo&lt;T&gt;;\n\ntemplate&lt;typename FooType&gt;\nstruct bar {\n  //Changed: want to use foo_alt instead of foo here\n  static_assert(is_from_same_template&lt;foo_alt&lt;int&gt;, FooType&gt;::value, \"\");\n};\n\nint main(int,char**) {\n  //both of these succeed:\n  bar&lt;foo&lt;int&gt;&gt; b;\n  bar&lt;foo_alt&lt;int&gt;&gt; b2;\n\n  return 0;\n}\n</code></pre>\n<p>Of course, you need to have a valid instantiation of <code>foo_alt</code> for this approach.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-15T07:31:32.103", "Score": "1", "CreationDate": "2013-06-30T18:10:06.283", "ParentId": "17392621", "CommentCount": "3", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T11:52:15.550"}, "17392621": {"ViewCount": "569", "Body": "<p>From a previous question:</p>\n<p><a href=\"https://stackoverflow.com/questions/17390605/doing-a-static-assert-that-a-template-type-is-another-template\">Doing a static_assert that a template type is another template</a></p>\n<p>Andy Prowl provided me with this code that allows me to <code>static_assert</code> that a template type is another template type:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class TT, typename... Ts&gt;\nstruct is_instantiation_of : public std::false_type { };\n\ntemplate&lt;template&lt;typename...&gt; class TT, typename... Ts&gt;\nstruct is_instantiation_of&lt;TT, TT&lt;Ts...&gt;&gt; : public std::true_type { };\n\ntemplate&lt;typename T&gt;\nstruct foo {};\n\ntemplate&lt;typename FooType&gt;\nstruct bar {\n  static_assert(is_instantiation_of&lt;foo,FooType&gt;::value, \"\"); //success\n};\n\nint main(int,char**)\n{\n  bar&lt;foo&lt;int&gt;&gt; b; //success\n  return 0;\n}\n</code></pre>\n<p>This works great.</p>\n<p>But if I change the code like this to use an alias of <code>foo</code>, things go bad:</p>\n<pre><code>template&lt;template&lt;typename...&gt; class TT, typename... Ts&gt;\nstruct is_instantiation_of : public std::false_type { };\n\ntemplate&lt;template&lt;typename...&gt; class TT, typename... Ts&gt;\nstruct is_instantiation_of&lt;TT, TT&lt;Ts...&gt;&gt; : public std::true_type { };\n\ntemplate&lt;typename T&gt;\nstruct foo {};\n\n//Added: alias for foo\ntemplate&lt;typename T&gt;\nusing foo_alt = foo&lt;T&gt;;\n\ntemplate&lt;typename FooType&gt;\nstruct bar {\n  //Changed: want to use foo_alt instead of foo here\n  static_assert(is_instantiation_of&lt;foo_alt,FooType&gt;::value, \"\"); //fail\n};\n\nint main(int,char**) {\n  //both of these fail:\n  bar&lt;foo&lt;int&gt;&gt; b;\n  bar&lt;foo_alt&lt;int&gt;&gt; b2;\n\n  return 0;\n}\n</code></pre>\n<p>Can this be solved?</p>\n", "AcceptedAnswerId": "17393256", "Title": "Using a template alias instead of a template within a template", "CreationDate": "2013-06-30T16:46:53.017", "Id": "17392621", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:03:52.263", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-15T07:31:32.103", "Score": "9", "OwnerUserId": "2521520", "Tags": "<c++><templates><c++11>", "AnswerCount": "2"}});