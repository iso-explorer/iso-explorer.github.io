post_cb({"46462083": {"ParentId": "46460508", "LastEditDate": "2017-09-28T06:16:54.877", "CommentCount": "2", "CreationDate": "2017-09-28T06:08:52.053", "Score": "3", "LastEditorUserId": "4987285", "PostTypeId": "2", "Id": "46462083", "OwnerUserId": "4987285", "Body": "<p>In order to deduce the return type, the lambda (better, its call operator) is instantiated and it requires to be fully defined, mainly because return type is deduced from any non discarded return statement. When you use it from within the body, it isn't fully defined yet for obvious reasons and thus the return type is still unknown. Therefore it's impossible to say what's the type of the expression and the program is ill-formed.</p>\n", "LastActivityDate": "2017-09-28T06:16:54.877"}, "46469080": {"ParentId": "46460508", "LastEditDate": "2017-09-29T13:13:45.713", "CommentCount": "7", "CreationDate": "2017-09-28T12:23:14.607", "Score": "2", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "46469080", "OwnerUserId": "2069064", "Body": "<p>The rule in <a href=\"http://eel.is/c++draft/dcl.spec.auto#9\" rel=\"nofollow noreferrer\">[dcl.spec.auto]</a> is:</p>\n<blockquote>\n<p id=\"so_46460508_46469080_0\">If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression, the program is ill-formed. Once a non-discarded return statement has been seen in a function, however, the return type deduced from that statement can be used in the rest of the function, including in other return statements.</p>\n</blockquote>\n<p>If you explicitly specify <code>void</code> as the return type, there's no undeduced placeholder type, so we're fine.</p>\n<p>But if we don't, then when we invoke</p>\n<pre><code>print(print, {1, {{2, {{8}}}, {3, {{5, {{7}}}, {6}}}, {4}}});\n</code></pre>\n<p>In the expression <code>self(self, t)</code>, the type of <code>print</code>'s <code>operator()</code> (an \"entity with an undeduced placeholder type\") is needed to determine the type of the expression, so we run afoul of that first sentence. </p>\n", "LastActivityDate": "2017-09-29T13:13:45.713"}, "bq_ids": {"n4140": {"so_46460508_46469080_0": {"section_id": 5455, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_46460508_46469080_0": {"section_id": 6881, "quality": 1.0, "length": 29}}}, "46460508": {"CommentCount": "0", "ViewCount": "157", "PostTypeId": "1", "LastEditorUserId": "1430927", "CreationDate": "2017-09-28T03:28:32.230", "LastActivityDate": "2017-09-29T13:13:45.713", "LastEditDate": "2017-09-28T03:35:47.973", "AcceptedAnswerId": "46469080", "FavoriteCount": "1", "Title": "Fixed point combinator and explicit result type", "Id": "46460508", "Score": "6", "Body": "<p>To perform some recursive tasks locally I use the following approach to create fixed point combinator in place:</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;list&gt;\n#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    struct tree\n    {\n        int payload;\n        std::list&lt; tree &gt; children = {}; // std::list of incomplete type is allowed\n    };\n    std::size_t indent = 0;\n    // indication of result type here is essential\n    const auto print = [&amp;] (const auto &amp; self, const tree &amp; node) -&gt; void\n    {\n        std::cout &lt;&lt; std::string(indent, ' ') &lt;&lt; node.payload &lt;&lt; '\\n';\n        ++indent;\n        for (const tree &amp; t : node.children) {\n            self(self, t);\n        }\n        --indent;\n    };\n    print(print, {1, {{2, {{8}}}, {3, {{5, {{7}}}, {6}}}, {4}}});\n}\n</code></pre>\n<p>It works fine and prints:</p>\n<pre><code>1\n 2\n  8\n 3\n  5\n   7\n  6\n 4\n</code></pre>\n<p>But if I remove explicitly specified result type <code>-&gt; void</code>, then I get compile error (GCC 8):</p>\n<blockquote>\n<p id=\"so_46460508_46460508_0\">prog.cc: In instantiation of 'main():: [with auto:1 = main()::]':</p>\n<p id=\"so_46460508_46460508_1\">prog.cc:24:64:   required from here</p>\n<p id=\"so_46460508_46460508_2\">prog.cc:20:17: error: use of 'main():: [with auto:1 = main()::]' before deduction of 'auto'</p>\n<pre><code>         self(self, t);\n</code></pre>\n</blockquote>\n<p>(clang 7):</p>\n<blockquote>\n<p id=\"so_46460508_46460508_3\">prog.cc:20:13: error: function 'operator()&lt;(lambda at prog.cc:15:24)&gt;' with deduced return type cannot be used before it is defined</p>\n<pre><code>        self(self, t);\n\n        ^\n</code></pre>\n<p id=\"so_46460508_46460508_4\">prog.cc:24:10: note: in instantiation of function template specialization 'main()::(anonymous class)::operator()&lt;(lambda at prog.cc:15:24)&gt;' requested here</p>\n<pre><code>print(print, {1, {{2, {{8}}}, {3, {{5, {{7}}}, {6}}}, {4}}});\n\n     ^\n</code></pre>\n<p id=\"so_46460508_46460508_5\">prog.cc:15:24: note: 'operator()&lt;(lambda at prog.cc:15:24)&gt;' declared here</p>\n<pre><code>const auto print = [&amp;] (const auto &amp; self, const tree &amp; node)\n\n                   ^\n</code></pre>\n<p id=\"so_46460508_46460508_6\">1 error generated.</p>\n</blockquote>\n<p>What is the cause of the error? I think compiler can deduce result type looking at function body. The result type is not dependent on \"template\" <code>self</code> parameter type.</p>\n", "Tags": "<c++><lambda><c++14><language-lawyer><c++1z>", "OwnerUserId": "1430927", "AnswerCount": "2"}});