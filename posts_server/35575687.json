post_cb({"bq_ids": {"n4140": {"so_35575687_35577045_1": {"section_id": 5698, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_35575687_35577045_1": {"section_id": 5481, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_35575687_35577045_1": {"section_id": 7143, "quality": 0.9090909090909091, "length": 10}}}, "35577045": {"ParentId": "35575687", "CommentCount": "1", "Body": "<p>Constructing more than one iterator <em>may</em> affect the result, as the iterator constructor is allowed to read ahead and buffer the next input.</p>\n<p>The standard says [istream.iterator.cons]:</p>\n<blockquote>\n<p id=\"so_35575687_35577045_0\"><code>istream_iterator(istream_type&amp; s);</code></p>\n<p id=\"so_35575687_35577045_1\">Effects: Initializes <em>in_stream</em> with <code>&amp;s</code>. <em>value</em> may be initialized during construction or the first time it is referenced.</p>\n<p id=\"so_35575687_35577045_2\">Postcondition: <code>in_stream == &amp;s</code>.</p>\n</blockquote>\n<p>Here, <em>in_stream</em> and <em>value</em> are \"exposition only\" member variables, used to show that an implementation might buffer the next input, possibly to optimize <code>operator*</code> or to check for end-of-file.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "35577045", "Score": "2", "CreationDate": "2016-02-23T11:59:27.827", "LastActivityDate": "2016-02-23T11:59:27.827"}, "35575855": {"ParentId": "35575687", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>it should be <code>*iter</code> and not <code>*iterator</code> when you dereference it</p>\n<pre><code>    int main()\n{\n    std::vector&lt;int&gt; v{};\n    std::istream_iterator&lt;int&gt; iter(std::cin), eof;\n\n    while (iter != eof) {\n        v.push_back(*iter);\n        ++iter;\n    }\n\n    for (int i = 0; i &lt; v.size(); ++i)\n        cout &lt;&lt; v[i] &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Always pays to use some meaningful names for variables</p>\n", "OwnerUserId": "5876626", "LastEditorUserId": "5876626", "LastEditDate": "2016-02-23T11:20:32.310", "Id": "35575855", "Score": "1", "CreationDate": "2016-02-23T11:06:37.810", "LastActivityDate": "2016-02-23T11:20:32.310"}, "35575687": {"CommentCount": "9", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "1800274", "CreationDate": "2016-02-23T10:59:43.250", "LastActivityDate": "2016-02-26T06:48:12.713", "Title": "Stream iterator reading std::cin misses 2nd and 3rd numbers", "FavoriteCount": "1", "LastEditDate": "2016-02-26T06:48:12.713", "Id": "35575687", "Score": "1", "Body": "<pre><code>std::vector&lt;int&gt; v{};\nstd::istream_iterator&lt;int&gt; iter(std::cin), eof;\n\nwhile (iter != eof) {\n  v.push_back(*iter);\n  ++iter;\n}\n</code></pre>\n<p>When it executes, this program ignores the second and third integers entered into the standard input. For example, entering <code>1 2 3 4 5 ^Z</code> and hitting enter results in a vector containing <code>1 4 5</code>. The same thing happens when the input is separated by newline characters instead of spaces.</p>\n<p>It's a simple example taken from C++ Primer (5th ed, p403) so I assume the fault lies with me. I've been stuck on this for a few hours so any help would be greatly appreciated.</p>\n<p><strong>EDIT: The code I originally posted was incomplete.</strong> <code>iter2(std::cin)</code> and <code>iter3(std::cin)</code> were also in the program and I thought they were only declarations at this point but it turns out they were responsible for the missing input. Code should have looked like:</p>\n<pre><code>std::vector&lt;int&gt; v{};\nstd::istream_iterator&lt;int&gt; iter(std::cin), iter2(std::cin), iter3(std::cin), eof;\n\nwhile (iter != eof) {\n  v.push_back(*iter);\n  ++iter;\n}\n</code></pre>\n<p>Lesson learned and apologies. Is it customary to delete terrible questions like this?</p>\n", "Tags": "<c++><vector><cin><istream-iterator>", "OwnerUserId": "1800274", "AnswerCount": "2"}});