post_cb({"35895314": {"ParentId": "35894955", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote id=\"so_35894955_35895314_0\">\n<ol>\n<li>Why can't I invoke swap without a using declaration\uff1f</li>\n</ol>\n</blockquote>\n<p>We start in the nearest enclosing scope and work our way outwards until we find something. With this:</p>\n<pre><code>void H::swap(H &amp;rhs)\n{\n    swap(*this, rhs);\n}\n</code></pre>\n<p>Unqualified <code>swap</code> finds <code>H::swap()</code>. Then we do argument-dependent lookup. But the rule there is, from <a href=\"http://eel.is/c++draft/basic.lookup#basic.lookup.argdep-3\" rel=\"nofollow noreferrer\">[basic.lookup.argdep]</a>:</p>\n<blockquote>\n<p id=\"so_35894955_35895314_1\">Let <em>X</em> be the lookup set produced by unqualified lookup (3.4.1) and let <em>Y</em> be the lookup set produced by\n  argument dependent lookup (defined as follows). If <em>X</em> contains<br>\n  \u2014 a declaration of a class member, or<br>\n  \u2014 a block-scope function declaration that is not a <em>using-declaration</em>, or<br>\n  \u2014 a declaration that is neither a function or a function template<br>\n  then <em>Y</em> is empty. Otherwise <em>Y</em> is the set of declarations found in the namespaces associated with the argument types as described below. [...]</br></br></br></br></p>\n</blockquote>\n<p>Since the unqualified lookup set finds a class member, the argument-dependent lookup set is empty (that is, it doesnt find <code>swap(H&amp;, H&amp;)</code>).</p>\n<blockquote id=\"so_35894955_35895314_2\">\n<ol start=\"2\">\n<li>Why will the swap of my definition be invoked instead of the STL swap in the <code>H::swap</code>?</li>\n</ol>\n</blockquote>\n<p>When you add:</p>\n<pre><code>void H::swap(H &amp;rhs)\n{\n    using std::swap;\n    swap(*this, rhs);\n}\n</code></pre>\n<p>now unqualified <code>swap</code> finds <code>std::swap()</code> and <strong>not</strong> <code>H::swap()</code>, since the former is declared in a more inner scope. <code>using std::swap;</code> does not match any of the criteria in the above-stated rule that would lead to <em>Y</em> being empty (it's not a class member, it <em>is</em> a <em>using-declaration</em>, and it is a function template). As a result, the argument-dependent lookup set does include declarations found in associated namespaces - which includes <code>swap(H&amp;, H&amp;)</code> (since <code>H</code> is in the global namespace). We end up with two overload candidates - and yours is preferred since it's the non-template. </p>\n<hr/>\n<p>See <a href=\"https://stackoverflow.com/a/6380882/2069064\">Xeo's answer</a> on the preferred way to add swap to your class. Basically, you want to write:</p>\n<pre><code>struct H {\n    friend void swap(H&amp;, H&amp;) { ... }\n};\n</code></pre>\n<p>This will be found by ADL (and only by ADL). And then whenever anybody <em>calls</em> swap correct:</p>\n<pre><code>using std::swap;\nswap(a, b);\n</code></pre>\n<p>Lookup will find yours where appropriate. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:52.157", "Id": "35895314", "Score": "7", "CreationDate": "2016-03-09T15:09:09.277", "LastActivityDate": "2016-03-10T15:43:16.727"}, "bq_ids": {"n4140": {"so_35894955_35895314_1": {"section_id": 7105, "quality": 0.975609756097561, "length": 40}}, "n3337": {"so_35894955_35895314_1": {"section_id": 6849, "quality": 0.975609756097561, "length": 40}}, "n4659": {"so_35894955_35895314_1": {"section_id": 8606, "quality": 0.975609756097561, "length": 40}}}, "35894955": {"CommentCount": "3", "AcceptedAnswerId": "35895314", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-03-09T14:54:08.053", "LastActivityDate": "2016-03-10T15:43:16.727", "LastEditDate": "2016-03-09T15:31:42.893", "ViewCount": "129", "FavoriteCount": "3", "Title": "Name hiding by using declaration", "Id": "35894955", "Score": "3", "Body": "<pre><code>#include &lt;iostream&gt;\n\nstruct H\n{\n    void swap(H &amp;rhs); \n};    \n\nvoid swap(H &amp;, H &amp;)\n{\n    std::cout &lt;&lt; \"swap(H &amp;t1, H &amp;t2)\" &lt;&lt; std::endl;\n}\n\nvoid H::swap(H &amp;rhs)\n{\n    using std::swap;\n    swap(*this, rhs);\n}\n\n\nint main(void)\n{\n    H a;\n    H b;\n\n    a.swap(b);\n}\n</code></pre>\n<p>And this is the result:</p>\n<pre><code>swap(H &amp;t1, H &amp;t2)\n</code></pre>\n<p>In the code above, I try to define a swap function of <code>H</code>. In the function <code>void H::swap(H &amp;rhs)</code>, I use an using declaration to make the name std::swap visible. If there isn't an using declaration, the code cannot be compiled because there is no usable swap function with two parameters in class <code>H</code>. </p>\n<p>I have a question here. In my opinion, after I used the using declaration -- <code>using std::swap</code>, it just make the std::swap -- the template function in STL visible. So I thought that the swap in STL should be invoked in <code>H::swap()</code>. But the result showed that the <code>void swap(H &amp;t1, H &amp;t2)</code> was invoked instead. </p>\n<p>So here is my question:</p>\n<ol>\n<li>Why can't I invoke swap without a using declaration\uff1f(I guess it is because there is no swap function with two parameters in the class. But I am not sure. )</li>\n<li>Why will the swap of my definition be invoked instead of the STL swap in the <code>H::swap</code>?</li>\n</ol>\n", "Tags": "<c++><swap><using><argument-dependent-lookup><name-lookup>", "OwnerUserId": "4416087", "AnswerCount": "1"}});