post_cb({"18599231": {"Id": "18599231", "PostTypeId": "2", "Body": "<p>This is a problem of dependent name lookup.</p>\n<p>In the expression <code>overloaded(value);</code>, the name <code>overloaded</code> is dependent as per [temp.dep]/1.</p>\n<p>As far as I know, in the expression <code>n::overloaded(value)</code>, the name <code>overloaded</code> (in the <em>id-expression</em> <code>n::overloaded</code>) is <strong>not</strong> dependent.</p>\n<hr>\n<p>Dependent name lookup is very peculiar, [temp.dep.res]/1</p>\n<blockquote>\n<p id=\"so_18598862_18599231_0\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li>Declarations that are visible at the point of definition of the template.</li>\n<li>Declarations from namespaces associated with the types of the function arguments both from the instantiation context and from the definition context.</li>\n</ul>\n</blockquote>\n<p>(There's a point of instantiation for function templates at the end of the file, so all declarations from associated namespaces can be found.)</p>\n<p>For non-dependent names, the normal lookup rules apply (lookup from the definition context).</p>\n<p>Therefore, to find names declared <em>after</em> the definition of the template, they have to be dependent <em>and</em> be found via ADL.</p>\n<hr>\n<p>A simple workaround is to introduce another parameter to the function <code>overloaded</code> or wrap the argument, such that one of the arguments of this function has namespace <code>n</code> associated:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass C {};\n\nnamespace n {\n  struct ADL_helper {};\n  inline void overloaded(int, ADL_helper = {})\n  { std::cout &lt;&lt; \"n::overloaded(int,..)\" &lt;&lt; std::endl; }\n}\n\ntemplate&lt;typename T&gt; void try_it(T value) {\n  overloaded(value, n::ADL_helper{});\n}\n\nnamespace n {\n  inline void overloaded(C, ADL_helper = {})\n  { std::cout &lt;&lt; \"n::overloaded(C,..)\" &lt;&lt; std::endl; }\n}\n\nint main()\n{\n  try_it(1);\n  C c;\n  try_it(c);\n}\n</code></pre>\n<p>alternatively:</p>\n<pre><code>namespace n {\n  template &lt; typename T &gt;\n  struct wrapper { T elem; };\n\n  inline void overloaded(wrapper&lt;int&gt;)\n  { std::cout &lt;&lt; \"n::overloaded(wrapper&lt;int&gt;)\" &lt;&lt; std::endl; }\n}\n\ntemplate&lt;typename T&gt; void try_it(T value) {\n  overloaded(n::wrapper&lt;T&gt;{value});\n}\n\nnamespace n {\n  inline void overloaded(wrapper&lt;C&gt;)\n  { std::cout &lt;&lt; \"n::overloaded(wrapper&lt;C&gt;)\" &lt;&lt; std::endl; }\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-09-03T18:56:04.837", "Score": "3", "CreationDate": "2013-09-03T18:35:33.333", "ParentId": "18598862", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2013-09-03T18:56:04.837"}, "bq_ids": {"n4140": {"so_18598862_18599231_0": {"length": 6, "quality": 1.0, "section_id": 215}, "so_18598862_18598942_1": {"length": 12, "quality": 0.75, "section_id": 224}, "so_18598862_18598942_2": {"length": 16, "quality": 0.8, "section_id": 224}}, "n3337": {"so_18598862_18599231_0": {"length": 6, "quality": 1.0, "section_id": 209}, "so_18598862_18598942_0": {"length": 13, "quality": 0.6190476190476191, "section_id": 217}, "so_18598862_18598942_1": {"length": 12, "quality": 0.75, "section_id": 217}, "so_18598862_18598942_2": {"length": 16, "quality": 0.8, "section_id": 217}}, "n4659": {"so_18598862_18599231_0": {"length": 6, "quality": 1.0, "section_id": 223}, "so_18598862_18598942_1": {"length": 12, "quality": 0.75, "section_id": 232}, "so_18598862_18598942_2": {"length": 16, "quality": 0.8, "section_id": 232}}}, "18598942": {"Id": "18598942", "PostTypeId": "2", "Body": "<p>HUGE EDIT from original version where I mistakenly thought that the call was a non-dependent name.</p>\n<p>OK, let's try to break this down.</p>\n<p>The second example works, because even in the non-template case you'd expect things to work normally with all the overloads declared before the use.</p>\n<p>The first version works because of 14.6.4.2/1:</p>\n<blockquote>\n<p id=\"so_18598862_18598942_0\">For a function call that depends on a template parameter, if the\n  function name is an unqualified-id but not a templateid, the candidate\n  functions are found using the usual lookup rules (3.4.1, 3.4.2) except\n  that:</p>\n<p id=\"so_18598862_18598942_1\">\u2014 For the part of the lookup using unqualified name lookup\n  (3.4.1), only function declarations with external linkage from the\n  template definition context are found.</p>\n<p id=\"so_18598862_18598942_2\">\u2014 For the part of the lookup\n  using associated namespaces (3.4.2), only function declarations with\n  external linkage found in either the template definition context or\n  the template instantiation context are found.</p>\n</blockquote>\n<p>We're interested specifically in the first part <code>if the function name is an unqualified-id</code> and the second bullet <code>found in either the template definition context or the template instantiation context are found.</code> So we learn that if the name is unqualified, names visible at thepoint of instantiation are added to the set of candidates.</p>\n<p>Likewise in the third case, your name is fully-qualified, thus <em>inhibiting</em> the use of candidates visible at the point of instantiation and instead falling back only on candidates at the point of definition.</p>\n<p>If you were to move <code>c</code> into <code>n</code>, add <code>using namespace n;</code> into the <code>try</code> function, and remove the <code>n::</code> from the function call you would find that ADL would once again pick up the overload and all would be happy.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2013-09-03T19:01:43.000", "Score": "1", "CreationDate": "2013-09-03T18:17:34.467", "ParentId": "18598862", "CommentCount": "3", "OwnerUserId": "251738", "LastEditDate": "2013-09-03T19:01:43.000"}, "18598862": {"ViewCount": "340", "Body": "<p>I am attempting to call an overloaded function inside a namespace and am struggling a bit.</p>\n<p><strong>Working Example 1: No namespace</strong></p>\n<pre><code>class C {};\n\ninline void overloaded(int) {}\n\ntemplate&lt;typename T&gt; void try_it(T value) {\n  overloaded(value);\n}\n\ninline void overloaded(C) {}\n\n\nint main()\n{\n  try_it(1);\n  C c;\n  try_it(c);\n  return 0;\n}\n</code></pre>\n<p><strong>Working Example 2: All overloads defined before template</strong></p>\n<pre><code>class C {};\n\nnamespace n {\n  inline void overloaded(int) {}\n  inline void overloaded(C) {}\n}\n\ntemplate&lt;typename T&gt; void try_it(T value) {\n  n::overloaded(value);\n}\n\nint main()\n{\n  try_it(1);\n  C c;\n  try_it(c);\n  return 0;\n}\n</code></pre>\n<p><strong>Broken Example 3: Some overloads after the template</strong></p>\n<pre><code>class C {};\n\nnamespace n {\n  inline void overloaded(int) {}\n}\n\ntemplate&lt;typename T&gt; void try_it(T value) {\n  n::overloaded(value);\n}\n\nnamespace n {\n  inline void overloaded(C) {}\n}\n\nint main()\n{\n  try_it(1);\n  C c;\n  try_it(c); // /tmp/test.cpp: In function \u2018void try_it(T) [with T = C]\u2019:\n             // /tmp/test.cpp:19:15:   instantiated from here\n             // /tmp/test.cpp:8:7: error: cannot convert \u2018C\u2019 to \u2018int\u2019 for argument \u20181\u2019 to \u2018void n::overloaded(int)\u2019\n\n  return 0;\n}\n</code></pre>\n<p>Why is this the case? What do I need to do to be able to declare or define an overload after the template function?</p>\n", "AcceptedAnswerId": "18599231", "Title": "Overload Resolution in a Namespace", "CreationDate": "2013-09-03T18:12:14.250", "Id": "18598862", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-09-03T19:01:43.000", "Score": "5", "OwnerUserId": "2101267", "Tags": "<c++><overload-resolution>", "AnswerCount": "2"}});