post_cb({"1888293": {"ViewCount": "8409", "Body": "<p><code>union</code> members may not have destructors or constructors. So I can't template the following class <code>Foo</code> on my own <code>MyClass</code> if <code>MyClass</code> has a constructor:</p>\n<pre><code>template&lt;class T&gt;\nstruct Foo {\n  T val;\n  Foo(T val_) : val(val_) {}\n  size_t hash() const {\n    union {T f; size_t s;} u = { val };\n    return u.s;\n  }\n};\nstruct MyClass {\n  bool a;\n  double b;\n  MyClass(bool a_, double b_) : a(a_), b(b_) {}\n};\n</code></pre>\n<p>If I do it anyway I get this error:</p>\n<pre><code>member 'MyClass Foo&lt;T&gt;::hash() const \n[with T = MyClass]::&lt;anonymous union&gt;::f' with constructor \nnot allowed in union\n</code></pre>\n<p>To get around it I created <code>MyClass</code> with an awkward construction function, which copies the thing around first:</p>\n<pre><code>struct MyClass {\n  bool a;\n  double b;\n};\nMyClass createMyClass(bool a, double b) {\n  MyClass m;\n  m.a = a;\n  m.b = b;\n  return m;\n}\n</code></pre>\n<p>But I'm wondering if there is a better way than using this <code>createMyClass</code> function. A constructor would be more efficient, and as a critical component <code>MyClass</code> and <code>Foo&lt;MyClass&gt;</code> are constructed millions of times in my code.</p>\n<h2>std::pair</h2>\n<p>I'm also a bit surprised that it <strong>is</strong> possible to use <code>std::pair</code> in the <code>union</code>: </p>\n<pre><code>Foo&lt;std::pair&lt;bool, double&gt; &gt; f2(std::make_pair(true, 3.12));\n</code></pre>\n<p>To my knowledge, <code>std::pair</code> (<a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01020_source.html\" rel=\"nofollow noreferrer\">see code</a>) has a constructor?</p>\n", "AcceptedAnswerId": "1888337", "Title": "union members may not have constructors, but `std::pair` okay?", "CreationDate": "2009-12-11T14:07:41.133", "Id": "1888293", "CommentCount": "1", "LastEditDate": "2012-10-08T16:06:33.377", "PostTypeId": "1", "LastEditorUserId": "718379", "LastActivityDate": "2012-10-08T16:06:33.377", "Score": "5", "OwnerUserId": "60628", "Tags": "<c++><constructor><unions><pod><std-pair>", "AnswerCount": "4"}, "1888452": {"Id": "1888452", "PostTypeId": "2", "Body": "<p>Regarding the use of an <code>std::pair</code> as a union member, I think it should be disallowed. The standard says (\u00a712.1):</p>\n<blockquote>\n<p id=\"so_1888293_1888452_0\">A union member shall not be of a class type (or array thereof) that has a non-trivial constructor.</p>\n</blockquote>\n<p>So any class with a user-defined constructor cannot be used in a union, since the default constructor will no longer be implicitly declared. Now in the specification of <code>std::pair</code> (\u00a720.2.2), it is explicitly stated that pair implementations must provide a parameterized constructor to initialize both values. Consequently, either the pair implementation or union implementation you use does not comply to the standard.</p>\n<p>N.B. : Testing the code you gave on Comeau gives the following error:</p>\n<pre><code>\"ComeauTest.c\", line 8: error: invalid union member -- class\n          \"std::pair&lt;bool, double&gt;\" has a disallowed member function\n      union {T f; size_t s;} u = { val };\n               ^\n          detected during instantiation of \"unsigned int Foo&lt;T&gt;::hash() const\n                    [with T=std::pair&lt;bool, double&gt;]\" at line 22\n</code></pre>\n", "LastActivityDate": "2009-12-11T14:35:20.713", "Score": "2", "CreationDate": "2009-12-11T14:35:20.713", "ParentId": "1888293", "CommentCount": "1", "OwnerUserId": "20984"}, "bq_ids": {"n4140": {"so_1888293_1888337_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 369}, "so_1888293_1888452_0": {"length": 6, "quality": 0.75, "section_id": 369}}, "n3337": {"so_1888293_1888337_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 359}, "so_1888293_1888452_0": {"length": 6, "quality": 0.75, "section_id": 359}}, "n4659": {"so_1888293_1888337_0": {"length": 15, "quality": 0.7142857142857143, "section_id": 381}, "so_1888293_1888452_0": {"length": 7, "quality": 0.875, "section_id": 382}}}, "1888982": {"Id": "1888982", "PostTypeId": "2", "Body": "<p>I have only one question: why using a union ?</p>\n<p>From what I understand, the hash should correspond to the first few bytes of your objects. If you are going to do this, why not:</p>\n<pre><code>size_t hash() const {\n  return reinterpret_cast&lt;size_t&gt;(val);\n}\n</code></pre>\n<p>which should accomplish the same trick (I think) with more efficiency since there is no allocation of an object of size <code>sizeof(T)</code> on the stack.</p>\n", "LastActivityDate": "2009-12-11T15:53:23.970", "Score": "2", "CreationDate": "2009-12-11T15:53:23.970", "ParentId": "1888293", "CommentCount": "0", "OwnerUserId": "147192"}, "1889785": {"Id": "1889785", "PostTypeId": "2", "Body": "<p>I would replace this:</p>\n<pre><code>size_t hash() const {\n    union {T f; size_t s;} u = { val };\n    return u.s;\n}\n</code></pre>\n<p>With this:</p>\n<pre><code>size_t hash() const {\n    size_t s = 0;\n    memcpy(&amp;s, &amp;val, std::min(sizeof(size_t), sizeof(T)));\n    return s;\n}\n</code></pre>\n<p>Copies the smaller of the two sizes rather than the larger, and if memcpy is an intrinsic on your compiler then you're looking good for optimisation. Most importantly, though, it doesn't matter what constructors T has.</p>\n<p>It's not a good hash function, though, if T is a large type. In your example MyClass, you might find that <code>bool</code> and <code>size_t</code> are the same size in your implementation, hence the double doesn't participate in the hash at all so there are only two possible hashed values.</p>\n<p>Still, it could be worse. If T has any virtual functions, you'll probably find that all instances hash to the same value: the address of the vtable...</p>\n", "LastActivityDate": "2009-12-11T17:56:24.000", "Score": "4", "CreationDate": "2009-12-11T17:56:24.000", "ParentId": "1888293", "CommentCount": "1", "OwnerUserId": "13005"}, "1888337": {"Body": "<p><strong>EDIT:</strong>  My original stance on <code>std::pair</code> was wrong, it shouldn't be allowed in a union. For a class to be a valid member of a union it must have a trivial constructor according to standard 9.5.1. The definition of a trivial constructor is this, from paragraph 12.1.5:</p>\n<blockquote>\n<p id=\"so_1888293_1888337_0\">If there is no user-declared\n  constructor for class X, a default\n  constructor is implicitly declared.\n  An <em>implicitly-declared</em> default\n  constructor is an <code>inline public</code> member\n  of its class. A constructor is <em>trivial</em>\n  if it is an implicitly-declared\n  default constructor and if:</p>\n<ul>\n<li>its class has no virtual functions and no virtual base classes, and</li>\n<li>all the direct base classes of its class have trivial constructors, and</li>\n<li>for all the nonstatic data members of its class that are of class type\n  (or array thereof), each such class\n  has a trivial constructor</li>\n</ul>\n</blockquote>\n<p>Paragraph 20.2.2.2 states that the following constructor must be available in a pair:</p>\n<pre><code>pair(const T1&amp; x, const T2&amp; y);\n</code></pre>\n<p>as soon as this constructor is supplied no default constructor will be implicitly declared.</p>\n<p>The funny thing here is that my compiler (Visual Studio 2008) seems to give <code>std::pair</code> special treatment. If I copy the code from the <code>std::pair</code> implementation and place it in my own namespace foo the unions don't work :)</p>\n<pre><code>namespace foo {\n    template&lt;class _Ty1, class _Ty2&gt; struct pair {\n        typedef _Ty1 first_type;\n        typedef _Ty2 second_type;\n        pair() : first(_Ty1()), second(_Ty2()) {\n        }\n    }\n}\n\n//This doesn't work in VC2008\nunion Baz {\n    foo::pair&lt;bool, double&gt; a;\n    int b;\n}\n//This works in VC2008\nunion Buz {\n    std::pair&lt;bool, double&gt; a;\n    int b;\n}\n</code></pre>\n<p>Your solution is a common way of getting around this problem. I usually prepend the class name with a <code>C</code> (short for construct) to partially mimic the ordinary constructor syntax, this would in your case become <code>CMyClass(a, b)</code>.</p>\n<p>As Steve and Matthieu has pointed out you're not using a very good hash function though. Firstly there's no real guarantee (I think, please correct me if I'm wrong) that <code>f</code> and <code>s</code> in the union will even partially occupy the same memory space, and secondly even if they in practice will probably will share the first <code>min(sizeof(s), sizeof(f))</code> bytes this means that for <code>MyClass</code> you're only hashing on part of the value. In this case you will hash on the value of the <code>bool a</code>, in this case there's two options:</p>\n<ol>\n<li>Your compiler uses <code>int</code> as the internal representation for the <code>bool</code> in which case your hash function will only return two values, one for true and one for false.</li>\n<li>Your compiler uses <code>char</code> as the internal representation for the <code>bool</code>. In this case the value will probably be padded to at least <code>sizeof(int)</code>, either with zeroes in which case you have the same situation as 1. or with whatever random data is on the stack when <code>MyClass</code> is allocated which means you get random hash values for the same input.</li>\n</ol>\n<p>If you need to hash by the entire value of <code>T</code> I would copy the data into a temporary buffer like Steve suggests and then use one of the variable-length hash functions discussed <a href=\"http://en.wikipedia.org/wiki/Hash_function\" rel=\"noreferrer\">here</a>.</p>\n", "CreationDate": "2009-12-11T14:15:20.107", "ParentId": "1888293", "CommentCount": "7", "LastEditDate": "2009-12-11T19:58:57.623", "Id": "1888337", "PostTypeId": "2", "LastActivityDate": "2009-12-11T19:58:57.623", "LastEditorUserId": "125672", "CommunityOwnedDate": "2009-12-11T19:58:57.623", "Score": "10", "OwnerUserId": "125672"}});