post_cb({"14830112": {"CommentCount": "2", "ViewCount": "92", "PostTypeId": "1", "LastEditorUserId": "201725", "CreationDate": "2013-02-12T10:15:28.317", "LastActivityDate": "2013-02-12T11:41:47.833", "Title": "std::iterator_traits for integral types in Microsoft standard library", "AcceptedAnswerId": "14830481", "LastEditDate": "2013-02-12T11:41:47.833", "Id": "14830112", "Score": "1", "Body": "<p>I have a template function, that needs to be specialized for iterators. So what I did was along the lines of:</p>\n<pre><code>template &lt;typename T&gt;\nvoid function2(T whatever, typename std::iterator_traits&lt;T&gt;::pointer) // ... iterator\n\ntemplate &lt;typename T&gt;\nvoid function2(T whatever, ...) // ... non-iterator\n\ntemplate &lt;typename T&gt;\nvoid function(T whatever) {\n    function2(whatever, NULL);\n}\n</code></pre>\n<p>And I've hit a wall, because Microsoft standard library specializes <code>std::iterator_traits</code> for all numeric types (<code>bool</code>, <code>char</code>, <code>int</code>, <code>float</code>\u2026). And it does it so that <code>reference</code> and <code>pointer</code> are non-<code>void</code>, despite the fact that neither <code>operator*</code> nor <code>operator-&gt;</code> can be called on those types.</p>\n<p>Ok, I can checki the <code>std::iterator_traits&lt;T&gt;::category</code> derives <code>std::input_iterator</code> (actually I think <code>std::forward_iterator</code> is more appropriate in my case) at the cost of some more complex template machinery.</p>\n<p>I would however be interested in knowing:</p>\n<ul>\n<li>Why do they define <code>iterator_traits</code> for types, that don't conform to the iterator concept (even output iterators need at least unary <code>operator*</code>, none of these types have one.</li>\n<li>Are they violating C++ specification in doing so? Not that Microsoft wouldn't be violating it all over the place, but if they are I would be satisfied with compiler-specific workaround, if they don't obviously not.</li>\n<li>And is it even workable in general anyway? It appears the <code>std::iterator_traits&lt;T&gt;::pointer</code> always exists, but is undefined and that leads to error rather than SFINAE.</li>\n</ul>\n", "Tags": "<c++><visual-c++><specifications>", "OwnerUserId": "201725", "AnswerCount": "1"}, "14830481": {"ParentId": "14830112", "LastEditDate": "2013-02-12T11:37:11.317", "CommentCount": "17", "CreationDate": "2013-02-12T10:35:26.500", "OwnerUserId": "743382", "LastEditorUserId": "743382", "PostTypeId": "2", "Id": "14830481", "Score": "2", "Body": "<blockquote>\n<p id=\"so_14830112_14830481_0\"><strong>Other functions [res.on.functions]</strong></p>\n<p id=\"so_14830112_14830481_1\">[...]</p>\n<p id=\"so_14830112_14830481_2\">2 In particular, the effects are undefined in the following cases:</p>\n<ul>\n<li>for types used as template arguments when instantiating a template component, if the operations on\n  the type do not implement the semantics of the applicable Requirements subclause</li>\n</ul>\n</blockquote>\n<p>In order to use <code>iterator_traits&lt;T&gt;</code>, <code>T</code> must be an iterator. If it isn't, the behaviour is undefined. You cannot detect whether a type <code>T</code> is an iterator at compile time. It is not even theoretically possible, since a type is allowed to support the same operators and typedefs as iterators, so that an implementation's generic <code>iterator_traits&lt;T&gt;</code> can be instantiated without any error or warning message, but with a completely different meaning.</p>\n<p>Thinking about it, since your comment clarifies that a reasonable guess is good enough, I think you're best off using SFINAE and <code>enable_if</code> to detect core operations (unary <code>*</code> and prefix <code>++</code>), using <code>std::iterator_traits&lt;T&gt;::pointer</code> only if those conditions are met.</p>\n", "LastActivityDate": "2013-02-12T11:37:11.317"}, "bq_ids": {"n4140": {"so_14830112_14830481_2": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_14830112_14830481_2": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_14830112_14830481_2": {"section_id": 7834, "quality": 1.0, "length": 5}}}});