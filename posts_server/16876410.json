post_cb({"16876410": {"CommentCount": "5", "AcceptedAnswerId": "16877779", "CreationDate": "2013-06-01T19:25:54.237", "LastActivityDate": "2016-04-19T21:29:27.553", "PostTypeId": "1", "ViewCount": "9310", "FavoriteCount": "4", "Title": "Does std::atomic<std::string> work appropriately?", "Id": "16876410", "Score": "32", "Body": "<p>I am reading through Anthony Williams' \"C++ Concurrency in Action\" and in Chapter 5, which talks about the new multithreading-aware memory model and atomic operations, and he states:</p>\n<blockquote>\n<p id=\"so_16876410_16876410_0\">In order to use <code>std::atomic&lt;UDT&gt;</code> for some  user-defined <code>UDT</code>, this type must have a <em>trivial</em> copy assignment operator.</p>\n</blockquote>\n<p>As I understand it, this means that we can use <code>std::atomic&lt;UDT&gt;</code> if the following returns true:</p>\n<pre><code>std::is_trivially_copyable&lt;UDT&gt;::value\n</code></pre>\n<p>By this logic, we shouldn't be able to use <code>std::string</code> as a template argument for <code>std::atomic</code> and have it work correctly.</p>\n<p>However, the following code compiles and runs with expected output:</p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    std::atomic&lt;std::string&gt; atomicString;\n\n    atomicString.store( \"TestString1\" );\n\n    std::cout &lt;&lt; atomicString.load() &lt;&lt; std::endl;\n\n    atomicString.store( \"TestString2\" );\n\n    std::cout &lt;&lt; atomicString.load() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>Is this a case of undefined behaviour which just happens to behave as expected?</p>\n<p>Thanks in advance!</p>\n", "Tags": "<c++><c++11><atomic><standard-library>", "OwnerUserId": "860566", "AnswerCount": "3"}, "21311124": {"ParentId": "16876410", "CommentCount": "0", "Body": "<p>No, this is undefined behavior. Moreover, since std::string is not trivially copyable, conforming compiler should have issued \"at least one diagnostic message\":</p>\n<blockquote>\n<p id=\"so_16876410_21311124_0\">29.5 Atomic types</p>\n<p id=\"so_16876410_21311124_1\">There is a generic class template atomic. The type of the template argument T shall be trivially copyable (3.9).</p>\n<p id=\"so_16876410_21311124_2\">1.4 Implementation compliance</p>\n<p id=\"so_16876410_21311124_3\">\u2014 If a program contains a violation of any diagnosable rule [...] a conforming\n  implementation shall issue at least one diagnostic message.</p>\n</blockquote>\n", "OwnerUserId": "3228152", "PostTypeId": "2", "Id": "21311124", "Score": "5", "CreationDate": "2014-01-23T14:34:59.033", "LastActivityDate": "2014-01-23T14:34:59.033"}, "16877779": {"ParentId": "16876410", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard does not specify a specialization of <code>std::atomic&lt;std::string&gt;</code>, so the generic <code>template &lt;typename T&gt; std::atomic&lt;T&gt;</code> applies. 29.5 [atomics.types.generic] p1 states:</p>\n<blockquote>\n<p id=\"so_16876410_16877779_0\">There is a generic class template atomic. The type of the template argument T shall be trivially copyable (3.9).</p>\n</blockquote>\n<p>There is no statement that the implementation must diagnose violations of this requirement. So either (a) your use of <code>std::atomic&lt;std::string&gt;</code> invokes undefined behavior, or (b) your implementation provides <code>std::atomic&lt;std::string&gt;</code> as a conforming extension.</p>\n<p>Looking at the MSDN page for <code>std::atomic&lt;T&gt;</code> (<a href=\"http://msdn.microsoft.com/en-us/library/vstudio/hh874651.aspx\" rel=\"noreferrer\">http://msdn.microsoft.com/en-us/library/vstudio/hh874651.aspx</a>), it does explicitly mention the requirement that <code>T</code> be trivially copyable, and it does NOT say anything specific about <code>std::atomic&lt;std::string&gt;</code>. If it is an extension, it's undocumented. My money is on undefined behavior.</p>\n<p>Specifically, 17.6.4.8/1 applies (<a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/YEB0sIgGoHA/PL4NYEq5yykJ\" rel=\"noreferrer\">with thanks to Daniel Kr\u00fcgler for setting me straight</a>):</p>\n<blockquote>\n<p id=\"so_16876410_16877779_1\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ standard library depends on components supplied by a C++ program. If these components do not meet their requirements, the Standard places no requirements on the implementation.</p>\n</blockquote>\n<p><code>std::string</code> certainly does not meet the <code>std::atomic&lt;T&gt;</code> requirement that the template parameter <code>T</code> be trivially copyable, so the standard places no requirements on the implementation. As a quality of implementation issue, note that <code>static_assert(std::is_trivially_copyable&lt;T&gt;::value, \"std::atomic&lt;T&gt; requires T to be trivially copyable\");</code> is an easy diagnostic to catch this violation.</p>\n<hr>\n<p>2016-04-19 Update: I don't know when the change happened, but VS2015 Update 2 does now diagnose <code>std::atomic&lt;std::string&gt;</code>:</p>\n<blockquote id=\"so_16876410_16877779_2\">\n<pre>error C2338: atomic requires T to be trivially copyable.</pre>\n</blockquote>\n</hr>", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2016-04-19T21:29:27.553", "Id": "16877779", "Score": "36", "CreationDate": "2013-06-01T22:10:08.317", "LastActivityDate": "2016-04-19T21:29:27.553"}, "bq_ids": {"n4140": {"so_16876410_16877779_0": {"section_id": 1165, "quality": 0.8181818181818182, "length": 9}, "so_16876410_21311124_3": {"section_id": 5770, "quality": 1.0, "length": 11}, "so_16876410_16877779_1": {"section_id": 6323, "quality": 0.9583333333333334, "length": 23}, "so_16876410_21311124_1": {"section_id": 1165, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_16876410_16877779_0": {"section_id": 1163, "quality": 0.8181818181818182, "length": 9}, "so_16876410_21311124_3": {"section_id": 5543, "quality": 1.0, "length": 11}, "so_16876410_16877779_1": {"section_id": 6080, "quality": 0.9583333333333334, "length": 23}, "so_16876410_21311124_1": {"section_id": 1163, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_16876410_16877779_0": {"section_id": 57, "quality": 0.5454545454545454, "length": 6}, "so_16876410_21311124_3": {"section_id": 7227, "quality": 1.0, "length": 11}, "so_16876410_21311124_1": {"section_id": 57, "quality": 0.5454545454545454, "length": 6}, "so_16876410_16877779_1": {"section_id": 7833, "quality": 0.9583333333333334, "length": 23}}}, "16878391": {"ParentId": "16876410", "CommentCount": "0", "Body": "<p>Why do you think this will work 'correctly' when there are multiple threads trying to read/write the <code>std::atomic&lt;std::string&gt;</code>?</p>\n<p>This is C++, you are definitely allowed to shoot yourself in the foot. If you want to use a type which does not satisfy the requirements you are free to use, the compiler \"may\" (not will!) stop you, but you will start seeing weird/unexplainable behaviour at some point when multiple threads try to read/write the string.</p>\n<p>This requirement is for guaranteeing atomicity of reads and writes, if the object is not trivially copyable then visualize this scene: The string had \"Old Value\" in it. 1 Writer issues .store(\"New Data\"), now there is another thread which issues .load() on the same variable, now without a trivially_copyable property, the reader thread can see \"Nld Value\" or \"New Value\" etc. It can't be updated atomically, hence the weird results.</p>\n<p>Since the example you posted is a sequential code, this does not happen.</p>\n", "OwnerUserId": "312821", "PostTypeId": "2", "Id": "16878391", "Score": "0", "CreationDate": "2013-06-01T23:45:53.123", "LastActivityDate": "2013-06-01T23:45:53.123"}});