post_cb({"22613991": {"CommentCount": "0", "CreationDate": "2014-03-24T15:41:20.633", "PostTypeId": "1", "AcceptedAnswerId": "22614209", "LastEditorUserId": "2591612", "LastActivityDate": "2014-03-24T20:54:16.210", "AnswerCount": "4", "LastEditDate": "2014-03-24T15:45:09.483", "ViewCount": "5243", "FavoriteCount": "3", "Title": "Move constructors and `std::array`", "Id": "22613991", "Score": "23", "Body": "<p>According to N3485 \u00a723.3.2.2:</p>\n<blockquote>\n<p id=\"so_22613991_22613991_0\">(...) the implicit move constructor and move assignment operator for <strong>array</strong> require that T be <strong>MoveConstructible</strong> or <strong>MoveAssignable</strong>, respectively.</p>\n</blockquote>\n<p>So, <code>std::array</code> supports move semantics if the type of its elements does. Great!</p>\n<p>However, what does this really mean? I tend to picture this type as a safer version of an array providing an STL-compliant interface but, if this is true, then how can an <code>std::array</code> move-construct its elements? Can I do the same with an ordinary array?</p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerDisplayName": "user2033018"}, "22614219": {"ParentId": "22613991", "LastEditDate": "2014-03-24T20:54:16.210", "CommentCount": "1", "CreationDate": "2014-03-24T15:50:48.753", "OwnerUserId": "420683", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "22614219", "Score": "6", "Body": "<p>The default move constructor for a (non-union) class performs a member-wise move. Moving a raw array data member means moving each of the array's elements, see [class.copy]/15.</p>\n<p>Therefore, you can move a raw array by putting it inside a class:</p>\n<pre><code>struct wrap\n{\n    std::string arr[25];\n};\n\nauto w = wrap();\nauto m = std::move(w); // moves the 25 `std::string`s\n</code></pre>\n<p>You can also manually invoke the move constructor of the elements, for example:</p>\n<pre><code>std::string a[3] = { /*...*/ };\nstd::string b[3] = {std::move(a[0]), std::move(a[1]), std::move(a[2])};\n</code></pre>\n<p>It is not specified if <code>std::array</code> contains a raw array. However, it does contain data members of the <code>value_type</code>, since it's guaranteed to be an aggregate. Those data members will be moved as described above when invoking the move constructor.</p>\n<p>If the data members of a <code>std::array</code> are not MoveConstructible, instantiating its move constructor will fail.</p>\n", "LastActivityDate": "2014-03-24T20:54:16.210"}, "22614209": {"ParentId": "22613991", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_22613991_22614209_0\">However, what does this really mean?</p>\n</blockquote>\n<p>It means that, if the element type is movable, then so is the array type.</p>\n<pre><code>std::array&lt;movable, 42&gt; move_from = {...};\nstd::array&lt;movable, 42&gt; move_to = std::move(move_from); // moves all the elements\n</code></pre>\n<blockquote>\n<p id=\"so_22613991_22614209_1\">I tend to picture this type as a safer version of an array providing an STL-compliant interface</p>\n</blockquote>\n<p>Not really. It's a wrapper for an array, giving it the same semantics as an aggregate class - including the ability to copy and move it.</p>\n<blockquote>\n<p id=\"so_22613991_22614209_2\">how can an <code>std::array</code> move-construct its elements?</p>\n</blockquote>\n<p>In exactly the same way as any other aggregate. Its implicit move-constructor will move-construct all its members, including the elements of any member arrays.</p>\n<blockquote>\n<p id=\"so_22613991_22614209_3\">Can I do the same with an ordinary array?</p>\n</blockquote>\n<p>Only if you wrap it in a class type, as <code>std::array</code> does.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "22614209", "Score": "24", "CreationDate": "2014-03-24T15:50:29.530", "LastActivityDate": "2014-03-24T15:50:29.530"}, "22614167": {"ParentId": "22613991", "LastEditDate": "2017-05-23T11:54:16.613", "CommentCount": "1", "CreationDate": "2014-03-24T15:48:40.953", "OwnerUserId": "103167", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "22614167", "Score": "0", "Body": "<p>You can do it using \"placement <code>new</code>\".  You'll find plenty of <a href=\"https://stackoverflow.com/questions/tagged/c%2b%2b%20placement-new\">questions on placement new</a> already answered with many further details.</p>\n<p>This one looks like it has a complete example:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/8991874/103167\">Why is this code trying to call the copy constructor?</a></li>\n</ul>\n", "LastActivityDate": "2014-03-24T15:48:40.953"}, "22614214": {"ParentId": "22613991", "CommentCount": "1", "Body": "<p>Moving a <code>std::array</code> is different from moving a <code>std::vector</code>. When moving one <code>std::vector</code> into another, it's (sometimes*) possible to simply re-target the internal pointers and avoid manipulating the elements at all.</p>\n<p>With <code>std::array</code>, this is of course not possible - its elements have automatic storage duration, they are literally contained inside the object. However, each individual one of them can still be moved, and that's what the move operations on <code>std::array</code> do**.</p>\n<p><sup>* Assuming the allocators are compatible and don't prohibit this operation</sup></p>\n<p><sup>** That's also what you get with <code>std::vector</code> when the buffer can't just be re-owned by the destination vector.</sup></p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "22614214", "Score": "19", "CreationDate": "2014-03-24T15:50:41.827", "LastActivityDate": "2014-03-24T15:50:41.827"}, "bq_ids": {"n4140": {"so_22613991_22613991_0": {"section_id": 778, "quality": 1.0, "length": 11}}, "n3337": {"so_22613991_22613991_0": {"section_id": 765, "quality": 1.0, "length": 11}}, "n4659": {"so_22613991_22613991_0": {"section_id": 838, "quality": 1.0, "length": 11}}}});