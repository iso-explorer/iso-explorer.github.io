post_cb({"301023": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>A virtual destructor is needed whenever there is any chance that <code>delete</code> might be called on a pointer to an object of a subclass with the type of your class. This makes sure the correct destructor gets called at run time without the compiler having to know the class of an object on the heap at compile time. For example, assume <code>B</code> is a subclass of <code>A</code>:</p>\n<pre><code>A *x = new B;\ndelete x;     // ~B() called, even though x has type A*\n</code></pre>\n<p>If your code is not performance critical, it would be reasonable to add a virtual destructor to every base class you write, just for safety. </p>\n<p>However, if you found yourself <code>delete</code>ing a lot of objects in a tight loop, the performance overhead of calling a virtual function (even one that's empty) might be noticeable. The compiler cannot usually inline these calls, and the processor might have a difficult time predicting where to go. It is unlikely this would have a significant impact on performance, but it's worth mentioning.</p>\n", "OwnerUserId": "1891", "Id": "301023", "PostTypeId": "2", "OwnerDisplayName": "Jay", "Score": "6", "CreationDate": "2008-11-19T04:54:35.297", "LastActivityDate": "2008-11-19T04:54:35.297"}, "301003": {"ParentId": "300986", "CommentCount": "3", "Body": "<p>I declare a virtual destructor if and only if I have virtual methods. Once I have virtual methods, I don't trust myself to avoid instantiating it on the heap or storing a pointer to the base class. Both of these are extremely common operations and will often leak resources silently if the destructor is not declared virtual.</p>\n", "OwnerUserId": "37992", "Id": "301003", "PostTypeId": "2", "OwnerDisplayName": "Andy", "Score": "23", "CreationDate": "2008-11-19T04:37:54.440", "LastActivityDate": "2008-11-19T04:37:54.440"}, "2626074": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>If you have a very small class with a huge number of instances, the overhead of a vtable pointer can make a difference in your program's memory usage. As long as your class doesn't have any other virtual methods, making the destructor non-virtual will save that overhead.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "2626074", "Score": "3", "CreationDate": "2010-04-12T23:19:29.223", "LastActivityDate": "2010-04-12T23:19:29.223"}, "302169": {"CommentCount": "4", "CreationDate": "2008-11-19T15:09:55.740", "LastEditorUserId": "11698", "LastActivityDate": "2017-06-30T07:57:08.363", "ParentId": "300986", "PostTypeId": "2", "LastEditorDisplayName": "Motti", "LastEditDate": "2017-06-30T07:57:08.363", "Id": "302169", "Score": "57", "Body": "<p>To answer the question explicitly, i.e. when should you <em>not</em> declare a virtual destructor.</p>\n<p><strong>C++ '98/'03</strong></p>\n<p>Adding a virtual destructor might change your class from being <a href=\"https://en.wikipedia.org/wiki/Passive_data_structure\" rel=\"nofollow noreferrer\">POD (plain old data)</a>* or aggregate to non-POD. This can stop your project from compiling if your class type is aggregate initialized somewhere.</p>\n<pre><code>struct A {\n  // virtual ~A ();\n  int i;\n  int j;\n};\nvoid foo () { \n  A a = { 0, 1 };  // Will fail if virtual dtor declared\n}\n</code></pre>\n<p>In an extreme case, such a change can also cause undefined behaviour where the class is being used in a way that requires a POD, e.g. passing it via an ellipsis parameter, or using it with memcpy.</p>\n<pre><code>void bar (...);\nvoid foo (A &amp; a) { \n  bar (a);  // Undefined behavior if virtual dtor declared\n}\n</code></pre>\n<p>[* A POD type is a type that has specific guarantees about its memory layout.  The standard really only says that if you were to copy from an object with POD type into an array of chars (or unsigned chars) and back again, then the result will be the same as the original object.]</p>\n<p><strong>Modern C++</strong></p>\n<p>In recent versions of C++, the concept of POD was split between the class layout and its construction, copying and destruction.</p>\n<p>For the ellipsis case, it is no longer <code>undefined behavior</code> it is now <code>conditionally-supported</code> with <code>implementation-defined semantics</code> (N3937 - ~C++ '14 - 5.2.2/7):</p>\n<blockquote>\n<p id=\"so_300986_302169_0\">...Passing a potentially-evaluated argument of class type (Clause 9) having a non-trivial copy constructor, a non-trivial move constructor, or a on-trivial destructor, with no corresponding parameter, is conditionally-supported with implementation-defined semantics.</p>\n</blockquote>\n<p>Declaring a destructor other than <code>=default</code> will mean it's not trivial (12.4/5)</p>\n<blockquote>\n<p id=\"so_300986_302169_1\">... A destructor is trivial if it is not user-provided ...</p>\n</blockquote>\n<p>Other changes to Modern C++ reduce the impact of the aggregate initialization problem as a constructor can be added:</p>\n<pre><code>struct A {\n  A(int i, int j);\n  virtual ~A ();\n  int i;\n\n  int j;\n};\nvoid foo () { \n  A a = { 0, 1 };  // OK\n}\n</code></pre>\n", "OwnerUserId": "11698", "OwnerDisplayName": "Richard Corden"}, "301545": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>I usually declare the destructor virtual, but if you have performance critical code that is used in an inner loop, you might want to avoid the virtual table lookup. That can be important in some cases, like collision checking. But be careful about how you destroy those objects if you use inheritance, or you will destroy only half of the object.</p>\n<p>Note that the virtual table lookup happens for an object if <em>any</em> method on that object is virtual. So no point in removing the virtual specification on a destructor if you have other virtual methods in the class.</p>\n", "OwnerUserId": "34585", "Id": "301545", "PostTypeId": "2", "OwnerDisplayName": "J&#248;rn Jensen", "Score": "1", "CreationDate": "2008-11-19T10:52:30.847", "LastActivityDate": "2008-11-19T10:52:30.847"}, "300986": {"CommentCount": "0", "AcceptedAnswerId": "300995", "PostTypeId": "1", "LastEditorUserId": "963864", "LastEditorDisplayName": "Airsource Ltd", "CreationDate": "2008-11-19T04:27:50.513", "LastActivityDate": "2017-06-30T07:57:08.363", "AnswerCount": "12", "LastEditDate": "2016-03-09T22:01:37.803", "ViewCount": "21251", "FavoriteCount": "13", "Title": "When should you not use virtual destructors?", "Id": "300986", "Score": "81", "Body": "<p>Is there ever a good reason to <em>not</em> declare a virtual destructor for a class?  When should you specifically avoid writing one?</p>\n", "Tags": "<c++><virtual-functions><virtual-destructor>", "OwnerUserId": "10606", "OwnerDisplayName": "Mag Roader"}, "302267": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>Virtual functions mean every allocated object increases in memory cost by a virtual function table pointer.</p>\n<p>So if your program involves allocating a very large number of some object, it would be worth avoiding all virtual functions in order to save the additional 32 bits per object.</p>\n<p>In all other cases, you will save yourself debug misery to make the dtor virtual.</p>\n", "OwnerUserId": "6444", "Id": "302267", "PostTypeId": "2", "OwnerDisplayName": "mxcl", "Score": "5", "CreationDate": "2008-11-19T15:31:29.597", "LastActivityDate": "2008-11-19T15:31:29.597"}, "300995": {"ParentId": "300986", "CommentCount": "9", "Body": "<p>There is no need to use a virtual destructor when any of the below is true:</p>\n<ul>\n<li>No intention to derive classes from it</li>\n<li>No instantiation on the heap</li>\n<li>No intention to store in a pointer of a superclass </li>\n</ul>\n<p>No specific reason to avoid it unless you are really so pressed for memory.</p>\n", "OwnerUserId": "30333", "Id": "300995", "PostTypeId": "2", "OwnerDisplayName": "sep", "Score": "62", "CreationDate": "2008-11-19T04:33:10.410", "LastActivityDate": "2008-11-19T04:33:10.410"}, "301031": {"ParentId": "300986", "CommentCount": "3", "Body": "<p>The performance answer is the only one I know of which stands a chance of being true.  If you've measured and found that de-virtualizing your destructors really speeds things up, then you've probably got other things in that class that need speeding up too, but at this point there are more important considerations.  Some day someone is going to discover that your code would provide a nice base class for them and save them a week's work.  You'd better make sure they do that week's work, copying and pasting your code, instead of using your code as a base.  You'd better make sure you make some of your important methods private so that no one can ever inherit from you.</p>\n", "OwnerUserId": "23705", "Id": "301031", "PostTypeId": "2", "OwnerDisplayName": "Windows programmer", "Score": "-7", "CreationDate": "2008-11-19T05:04:18.490", "LastActivityDate": "2008-11-19T05:04:18.490"}, "bq_ids": {"n4140": {"so_300986_302169_0": {"section_id": 5994, "quality": 0.9, "length": 18}}, "n3337": {"so_300986_302169_0": {"section_id": 5762, "quality": 0.9, "length": 18}}, "n4659": {"so_300986_302169_0": {"section_id": 7496, "quality": 0.9, "length": 18}}}, "308889": {"ParentId": "300986", "CommentCount": "2", "Body": "<p>Not all C++ classes are suitable for use as a base class with dynamic polymorphism.</p>\n<p>If you want your class to be suitable for dynamic polymorphism, then its destructor must be virtual. In addition, any methods which a subclass could conceivably want to override (which might mean all public methods, plus potentially some protected ones used internally) must be virtual.</p>\n<p>If your class is not suitable for dynamic polymorphism, then the destructor should not be marked virtual, because to do so is misleading. It just encourages people to use your class incorrectly.</p>\n<p>Here's an example of a class which would not be suitable for dynamic polymorphism, even if its destructor were virtual:</p>\n<pre><code>class MutexLock {\n    mutex *mtx_;\npublic:\n    explicit MutexLock(mutex *mtx) : mtx_(mtx) { mtx_-&gt;lock(); }\n    ~MutexLock() { mtx_-&gt;unlock(); }\nprivate:\n    MutexLock(const MutexLock &amp;rhs);\n    MutexLock &amp;operator=(const MutexLock &amp;rhs);\n};\n</code></pre>\n<p>The whole point of this class is to sit on the stack for RAII. If you're passing around pointers to objects of this class, let alone subclasses of it, then you're Doing It Wrong.</p>\n", "OwnerUserId": "13005", "Id": "308889", "PostTypeId": "2", "OwnerDisplayName": "onebyone.livejournal.com", "Score": "5", "CreationDate": "2008-11-21T14:09:30.807", "LastActivityDate": "2008-11-21T14:09:30.807"}, "35450144": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>A good reason for not declaring a destructor as virtual is when this saves your class from having a virtual function table added, and you should avoid that whenever possible.</p>\n<p>I know that many people prefer to just always declare destructors as virtual, just to be on the safe side. But if your class does not have any other virtual functions then there is really, really no point in having a virtual destructor. Even if you give your class to other people who then derive other classes from it then they would have no reason to ever call delete on a pointer that was upcast to your class - and if they do then I would consider this a bug.</p>\n<p>Okay, there is one single exception, namely if your class is (mis-)used to perform polymorphic deletion of derived objects, but then you - or the other guys - hopefully know that this requires a virtual destructor.</p>\n<p>Put another way, if your class has a non-virtual destructor then this is a very clear statement: \"Don't use me for deleting derived objects!\"</p>\n", "OwnerUserId": "5938604", "PostTypeId": "2", "Id": "35450144", "Score": "4", "CreationDate": "2016-02-17T07:12:30.203", "LastActivityDate": "2016-02-17T07:12:30.203"}, "5971370": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>If you absolutely positively must ensure that your class does not have a vtable then you must  not have a virtual destructor as well. </p>\n<p>This is a rare case, but it does happen.</p>\n<p>The most familiar example of a pattern that does this are the DirectX D3DVECTOR and D3DMATRIX classes. These are class methods instead of functions for the syntactic sugar, but the classes intentionally do not have a vtable in order to avoid the function overhead because these classes are specifically used in the inner loop of many high-performance applications.</p>\n", "OwnerUserId": "2574807", "PostTypeId": "2", "Id": "5971370", "Score": "1", "CreationDate": "2011-05-11T22:34:19.523", "LastActivityDate": "2011-05-11T22:34:19.523"}, "4173898": {"ParentId": "300986", "CommentCount": "0", "Body": "<p>On operation that will be performed on the base class, and that should behave virtually, should be virtual. If deletion can be performed polymorphically through the base class interface, then it must behave virtually and be virtual.</p>\n<p>The destructor has no need to be virtual if you don't intend to derive from the class. And even if you do, <strong>a protected non-virtual destructor is just as good if deletion of base class pointers isn't required</strong>.</p>\n", "OwnerUserId": "451980", "PostTypeId": "2", "Id": "4173898", "Score": "0", "CreationDate": "2010-11-13T17:52:49.080", "LastActivityDate": "2010-11-13T17:52:49.080"}});