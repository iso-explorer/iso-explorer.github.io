post_cb({"1661548": {"ParentId": "1661529", "CommentCount": "0", "Body": "<p>The correct answer depends on your compiler. It can decide to <em>make</em> it threadsafe; it's not \"naturallly\" threadsafe.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "1661548", "Score": "6", "CreationDate": "2009-11-02T14:13:27.813", "LastActivityDate": "2009-11-02T14:13:27.813"}, "1663229": {"ParentId": "1661529", "CommentCount": "0", "Body": "<p>Looking at the next standard (section 6.7.4), it explians how static local initialization is thread safe.  So once that section of standard is widely implemented, Meyer's Singleton will be the preferred implementation.</p>\n<p>I disagree with many answers already.  Most compilers already implement static initialization this way.  The one notable exception is Microsoft Visual Studio.</p>\n", "OwnerUserId": "28817", "PostTypeId": "2", "Id": "1663229", "Score": "9", "CreationDate": "2009-11-02T19:38:37.783", "LastActivityDate": "2009-11-02T19:38:37.783"}, "1661529": {"CommentCount": "3", "AcceptedAnswerId": "1661564", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2009-11-02T14:09:28.290", "LastActivityDate": "2017-06-20T13:05:43.170", "LastEditDate": "2017-06-20T13:05:43.170", "ViewCount": "32713", "FavoriteCount": "64", "Title": "Is Meyers' implementation of the Singleton pattern thread safe?", "Id": "1661529", "Score": "99", "Body": "<p>Is the following implementation, using lazy initialization, of <code>Singleton</code> (Meyers' Singleton) thread safe?</p>\n<pre><code>static Singleton&amp; instance()\n{\n     static Singleton s;\n     return s;\n}\n</code></pre>\n<p>If not, why and how to make it thread safe?</p>\n", "Tags": "<c++><multithreading><design-patterns>", "OwnerUserId": "120800", "AnswerCount": "6"}, "1661789": {"ParentId": "1661529", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_1661529_1661789_0\">Is the following implementation [...] thread safe?</p>\n</blockquote>\n<p>On most platforms, this is not thread-safe. (Append the usual disclaimer explaining that the C++ standard doesn't know about threads, so, legally, it doesn't say whether it is or not.) </p>\n<blockquote>\n<p id=\"so_1661529_1661789_1\">If not, why [...]?</p>\n</blockquote>\n<p>The reason it isn't is that nothing prevents more than one thread from simultaneously executing <code>s</code>' constructor. </p>\n<blockquote>\n<p id=\"so_1661529_1661789_2\">how to make it thread safe?</p>\n</blockquote>\n<p><a href=\"http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf\" rel=\"nofollow noreferrer\">\"C++ and the Perils of Double-Checked Locking\"</a> by Scott Meyers and Andrei Alexandrescu is a pretty good treatise on the subject of thread-safe singletons. </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "1661789", "Score": "5", "CreationDate": "2009-11-02T15:00:47.507", "LastActivityDate": "2009-11-02T15:00:47.507"}, "1661787": {"ParentId": "1661529", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>To answer your question about why it's not threadsafe, it's not because the first call to <code>instance()</code> must call the constructor for <code>Singleton s</code>. To be threadsafe this would have to occur in a critical section, and but there's no requirement in the standard that a critical section be taken (the standard to date is completely silent on threads).  Compilers often implement this using a simple check and increment of a static boolean - but not in a critical section.  Something like the following pseudocode:</p>\n<pre><code>static Singleton&amp; instance()\n{\n    static bool initialized = false;\n    static char s[sizeof( Singleton)];\n\n    if (!initialized) {\n        initialized = true;\n\n        new( &amp;s) Singleton(); // call placement new on s to construct it\n    }\n\n    return (*(reinterpret_cast&lt;Singleton*&gt;( &amp;s)));\n}\n</code></pre>\n<p>So here's a simple thread-safe Singleton (for Windows).  It uses a simple class wrapper for the Windows CRITICAL_SECTION object so that we can have the compiler automatically initialize the <code>CRITICAL_SECTION</code> before <code>main()</code> is called.  Ideally a true RAII critical section class would be used that can deal with exceptions that might occur when the critical section is held, but that's beyond the scope of this answer.</p>\n<p>The fundamental operation is that when an instance of <code>Singleton</code> is requested, a lock is taken, the Singleton is created if it needs to be, then the lock is released and the Singleton reference returned.</p>\n<pre><code>#include &lt;windows.h&gt;\n\nclass CritSection : public CRITICAL_SECTION\n{\npublic:\n    CritSection() {\n        InitializeCriticalSection( this);\n    }\n\n    ~CritSection() {\n        DeleteCriticalSection( this);\n    }\n\nprivate:\n    // disable copy and assignment of CritSection\n    CritSection( CritSection const&amp;);\n    CritSection&amp; operator=( CritSection const&amp;);\n};\n\n\nclass Singleton\n{\npublic:\n    static Singleton&amp; instance();\n\nprivate:\n    // don't allow public construct/destruct\n    Singleton();\n    ~Singleton();\n    // disable copy &amp; assignment\n    Singleton( Singleton const&amp;);\n    Singleton&amp; operator=( Singleton const&amp;);\n\n    static CritSection instance_lock;\n};\n\nCritSection Singleton::instance_lock; // definition for Singleton's lock\n                                      //  it's initialized before main() is called\n\n\nSingleton::Singleton()\n{\n}\n\n\nSingleton&amp; Singleton::instance()\n{\n    // check to see if we need to create the Singleton\n    EnterCriticalSection( &amp;instance_lock);\n    static Singleton s;\n    LeaveCriticalSection( &amp;instance_lock);\n\n    return s;\n}\n</code></pre>\n<p>Man - that's a lot of crap to \"make a better global\".</p>\n<p>The main drawbacks to this implemention (if I didn't let some bugs slip through) is:</p>\n<ul>\n<li>if <code>new Singleton()</code> throws, the lock won't be released.  This can be fixed by using a true RAII lock object instead of the simple one I have here. This can also help make things portable if you use something like Boost to provide a platform independent wrapper for the lock.</li>\n<li>this guarantees thread safety when the Singleton instance is requested after <code>main()</code> is called - if you call it before then (like in a static object's initialization) things might not work because the <code>CRITICAL_SECTION</code> might not be initialized.</li>\n<li>a lock must be taken each time an instance is requested.  As I said, this is a simple thread safe implementation.  If you need a better one (or want to know why things like the double-check lock technique is flawed), see the <a href=\"https://stackoverflow.com/questions/1661529/is-meyers-implementation-of-singleton-pattern-thread-safe/1661564#1661564\">papers linked to in Groo's answer</a>.</li>\n</ul>\n", "OwnerUserId": "12711", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:28.910", "Id": "1661787", "Score": "18", "CreationDate": "2009-11-02T15:00:10.723", "LastActivityDate": "2009-11-02T22:44:23.190"}, "1662334": {"ParentId": "1661529", "CommentCount": "0", "Body": "<p>As MSalters said: It depends on the C++ implementation you use. Check the documentation. As for the other question: \"If not, why?\" -- The C++ standard doesn't yet mention anything about threads. But the upcoming C++ version is aware of threads and it explicitly states that the initialization of static locals is thread-safe. If two threads call such a function, one thread will perform an initialization while the other will block &amp; wait for it to finish.</p>\n", "OwnerUserId": "172531", "PostTypeId": "2", "Id": "1662334", "Score": "2", "CreationDate": "2009-11-02T16:37:01.870", "LastActivityDate": "2009-11-02T16:37:01.870"}, "bq_ids": {"n4140": {"so_1661529_1661564_0": {"section_id": 3919, "quality": 1.0, "length": 13}}, "n3337": {"so_1661529_1661564_0": {"section_id": 3779, "quality": 1.0, "length": 13}}, "n4659": {"so_1661529_1661564_0": {"section_id": 4805, "quality": 1.0, "length": 13}}}, "1661564": {"ParentId": "1661529", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In <a href=\"http://en.wikipedia.org/wiki/C++11\" rel=\"noreferrer\">C++11</a>, it is thread safe. According to the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">standard</a>, <code>\u00a76.7 [stmt.dcl] p4</code>:</p>\n<blockquote>\n<p id=\"so_1661529_1661564_0\">If control enters\n  the declaration concurrently while the variable is being initialized, the <strong>concurrent execution shall wait</strong> for completion of the initialization.</p>\n</blockquote>\n<p>GCC and VS support for the feature (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm\" rel=\"noreferrer\">Dynamic Initialization and Destruction with Concurrency</a>, also known as <a href=\"https://msdn.microsoft.com/en-us/library/hh567368.aspx\" rel=\"noreferrer\">Magic Statics on MSDN</a>) is as follows:</p>\n<ul>\n<li>Visual Studio: supported since <a href=\"https://msdn.microsoft.com/en-us/library/hh567368(v=vs.140).aspx\" rel=\"noreferrer\">Visual Studio 2015</a></li>\n<li>GCC: supported since <a href=\"https://gcc.gnu.org/gcc-4.3/changes.html\" rel=\"noreferrer\">GCC 4.3</a></li>\n</ul>\n<p>Thanks to @Mankarse and @olen_gam for their comments.</p>\n<hr/>\n<p>In <a href=\"http://en.wikipedia.org/wiki/C++03\" rel=\"noreferrer\">C++03</a>, this code wasn't thread safe. There is an article by Meyers called <a href=\"http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf\" rel=\"noreferrer\">\"C++ and the Perils of Double-Checked Locking\"</a> which discusses thread safe implementations of the pattern, and the conclusion is, more or less, that (in C++03) full locking around the instantiating method is basically the simplest way to ensure proper concurrency on all platforms, while most forms of double-checked locking pattern variants may suffer from <a href=\"https://stackoverflow.com/a/6623662/69809\">race conditions on certain architectures</a>, unless instructions are interleaved with strategically places memory barriers.</p>\n", "OwnerUserId": "69809", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:59.723", "Id": "1661564", "Score": "120", "CreationDate": "2009-11-02T14:16:54.727", "LastActivityDate": "2016-04-28T11:05:29.213"}});