post_cb({"32550704": {"LastActivityDate": "2015-09-13T18:49:07.307", "CommentCount": "7", "Body": "<p>There is one issue with this expression:</p>\n<pre><code>decltype(Container().begin())\n</code></pre>\n<p>which is that <code>Container()</code> only works if <code>Container</code> happens to be default-constructible. That limits the usability of your class for no reason. (There is a lesser issue which is that this won't work for raw arrays, but that's another exercise).</p>\n<p>Besides that, the code is perfectly valid for class types. From [expr.type.conv]:</p>\n<blockquote>\n<p id=\"so_32544354_32550704_0\">The expression T(), where T is a simple-type-specifier or typename-specifier for a non-array complete object\n  type or the (possibly cv-qualified) void type, creates a prvalue of the specified type [...]</p>\n</blockquote>\n<p>So if <code>Container</code> is <code>const list&lt;int&gt;</code>, then the type of that whole expression should be <code>list&lt;int&gt;::const_iterator</code>. If MSVC gives you something else, that's a  bug. </p>\n<p>That said, we really should address the default-constructibility issue. That's where <a href=\"http://en.cppreference.com/w/cpp/utility/declval\" rel=\"nofollow\"><code>std::declval</code></a> comes in:</p>\n<pre><code>decltype(std::declval&lt;Container&amp;&gt;().begin())\n</code></pre>\n<p>This will not impose any restrictions on <code>Container</code>, and perhaps MSVC will handle this correctly. </p>\n", "CreationDate": "2015-09-13T14:30:45.937", "LastEditDate": "2015-09-13T18:49:07.307", "ParentId": "32544354", "Id": "32550704", "LastEditorUserId": "2069064", "PostTypeId": "2", "Score": "2", "OwnerUserId": "2069064"}, "32544354": {"CreationDate": "2015-09-12T22:24:37.157", "ViewCount": "381", "Id": "32544354", "AcceptedAnswerId": "32550704", "Score": "2", "Title": "template parameter for const iterator instead of iterator", "LastEditorUserId": "869951", "CommentCount": "9", "Body": "<p><strong><em>Note</em></strong>: I have written a \"recipe\" based on the lessons learnt from the exercise and the answers &amp; comments on this page, see <a href=\"http://www.codeproject.com/Tips/1029941/Python-like-enumeration-in-Cplusplus\" rel=\"nofollow\">http://www.codeproject.com/Tips/1029941/Python-like-enumeration-in-Cplusplus</a>. </p>\n<p>I'm playing around with the extensions that C++11 brings to C++03. I want to be able to iterate over a container using the following code:</p>\n<pre><code>int main()\n{\n    std::list&lt;int&gt; list = { 1, 2, 3, 4, 5, 6, 7 };\n    for (auto x : enumerated(list))\n        cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; endl;\n    for (auto x : const_enumerated(list))\n        cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; endl;\n}\n</code></pre>\n<p>The first iteration has x modifiable, vs for the second, attempting to modify x would lead to a compile error. I have something that works for the non-const case: </p>\n<pre><code>template &lt;typename Container&gt;\nclass EnumerationAdaptor\n{\npublic:\n    EnumerationAdaptor(Container&amp; container) : container_(container) {}\n    EnumIter&lt;typename Container::iterator&gt; begin() const { return container_.begin(); }\n    EnumIter&lt;typename Container::iterator&gt; end() const { return container_.end(); }\n\nprivate:\n    Container&amp; container_;\n};\n\ntemplate &lt;typename Container&gt;\nEnumerationAdaptor&lt;Container&gt; enumerated(Container&amp; container) { return container; }\n\ntemplate &lt;typename Container&gt;\nEnumerationAdaptor&lt;const Container&gt; const_enumerated(const Container&amp; container) { return container; }\n</code></pre>\n<p>The non-const case uses <code>EnumIter&lt;std::list&lt;...&gt;::iterator&gt;</code>, as desired, and I'm trying to make the const case use <code>EnumIter&lt;std::list&lt;...&gt;::const_iterator&gt;</code> as return type of <code>begin()</code> and <code>end()</code>. Seems like I need decltype: </p>\n<pre><code>template &lt;typename Container&gt;\nclass EnumerationAdaptor\n{\npublic:\n    EnumerationAdaptor(Container&amp; container) : container_(container) {}\n    EnumIter&lt;decltype(Container().begin())&gt; begin() const { return container_.begin(); }\n    EnumIter&lt;decltype(Container().end())&gt; end() const { return container_.end(); }  // *** compile error (see below)\n\nprivate:\n    Container&amp; container_;\n};\n</code></pre>\n<p>But I get a compilation error in Visual Studio 2015 Express:</p>\n<pre><code>Error   C2440   'return': cannot convert from \n'std::_List_const_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;int&gt;&gt;&gt;' \nto  \n 'EnumIter&lt;std::_List_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;int&gt;&gt;&gt;&gt;'\n[in c:\\users\\...\\enumeratedcpp.cpp line 46, which is line marked ***]\n</code></pre>\n<p>which suggests that I'm doing something wrong with decltype, as the compiler is finding the non-const begin(). Is there a way to fix this? </p>\n<p><strong>EDIT</strong>: even with a simple EnumIter, problem is same: </p>\n<pre><code>template &lt;typename Iter&gt;\nclass EnumIter\n{\npublic:\n    EnumIter(Iter begin) : iter_(begin) {}\n\n    EnumIter&amp; operator++()\n    {\n        return *this;\n    }\n\n    bool operator!=(const EnumIter&amp; rhs)\n    {\n        return iter_ != rhs.iter_; // or self.index_ != rhs.index_;\n    }\n\n    int operator*() const\n    {\n        return index_;\n    }\n\nprivate:\n    Iter iter_;\n    int index_ = 0;\n};\n</code></pre>\n", "Tags": "<c++><templates><c++11><iterator><const>", "LastEditDate": "2015-09-24T02:42:15.230", "LastActivityDate": "2015-09-24T02:42:15.230", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "869951"}, "bq_ids": {"n4140": {"so_32544354_32550704_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6000}}, "n3337": {"so_32544354_32550704_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 5768}}}});