post_cb({"26718829": {"CommentCount": "2", "AcceptedAnswerId": "26718919", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-11-03T16:44:36.790", "LastActivityDate": "2014-11-03T17:55:00.617", "LastEditDate": "2017-05-23T10:30:43.420", "ViewCount": "4970", "FavoriteCount": "1", "Title": "Time Complexity of std::vector::erase", "Id": "26718829", "Score": "2", "Body": "<p>I've found a way to remove an element from an STL vector my its value <a href=\"https://stackoverflow.com/questions/39912/how-do-i-remove-an-item-from-a-stl-vector-with-a-certain-value\">here</a>:</p>\n<pre><code>vec.erase(remove(vec.begin(), vec.end(), value), vec.end());\n</code></pre>\n<p>Now I'd like to know how efficient this method is, meaning its time complexity in Big O notation.</p>\n", "Tags": "<c++><vector><time-complexity>", "OwnerUserId": "2033332", "AnswerCount": "4"}, "26720040": {"ParentId": "26718829", "CommentCount": "0", "CreationDate": "2014-11-03T17:55:00.617", "OwnerUserId": "892256", "PostTypeId": "2", "Id": "26720040", "Score": "0", "Body": "<p>It could be anything as the complexity of the destructures is unknown</p>\n<p>But assuming it is constant then it will be O(n)</p>\n", "LastActivityDate": "2014-11-03T17:55:00.617"}, "bq_ids": {"n4140": {"so_26718829_26719784_0": {"section_id": 989, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_26718829_26719784_0": {"section_id": 974, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_26718829_26719784_0": {"section_id": 1052, "quality": 0.875, "length": 21}}}, "26718901": {"ParentId": "26718829", "CommentCount": "0", "CreationDate": "2014-11-03T16:48:04.013", "OwnerUserId": "3987536", "PostTypeId": "2", "Id": "26718901", "Score": "-1", "Body": "<p>O(N) since you are walking through each element of your vector.</p>\n", "LastActivityDate": "2014-11-03T16:48:04.013"}, "26718919": {"ParentId": "26718829", "CommentCount": "0", "CreationDate": "2014-11-03T16:49:47.583", "OwnerUserId": "4047092", "PostTypeId": "2", "Id": "26718919", "Score": "4", "Body": "<p>vec.erase(remove(vec.begin(), vec.end(), value), vec.end());</p>\n<p>In this case remove compacts the elements that differ from the value to be removed (value) in the beginning of the vector and returns the iterator to the first element after that range. Then erase removes the elements.</p>\n<p>So this makes this operation O(n). </p>\n", "LastActivityDate": "2014-11-03T16:49:47.583"}, "26719784": {"ParentId": "26718829", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-03T17:39:02.693", "Score": "0", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-03T17:45:23.570", "Id": "26719784", "OwnerUserId": "3647361", "Body": "<p>The C++11 standard specifies in [vector.modifiers]/4:</p>\n<blockquote>\n<p id=\"so_26718829_26719784_0\"><em>Complexity</em>: The destructor of <code>T</code> is called the number of times equal to the number of the elements erased, but the move assignment\n  operator of <code>T</code> is called the number of times equal to the number of\n  elements in the vector after the erased elements.</p>\n</blockquote>\n<p>In particular, erasing elements at the end is quite cheap since all that is done is destroying the elements to be erased, so the time complexity of the <code>erase</code>-call should be linear in terms of the number of occurrences of <code>value</code> inside <code>vec</code> - which corresponds to <em>\u0398(n)</em> in Big-Oh-Notation. The complexity of the whole expression is still linear since <code>remove</code> has linear complexity in terms of the length of the range it is applied to. If the size of <code>vec</code> is described by the variable <em>m</em> we have <em>\u0398(n + m)</em> for the complete expression which equals <em>O(m)</em> (since <em>n &lt; m</em> and <em>m + n &lt; 2m</em>, <em>O(2m) = O(m)</em>)</p>\n", "LastActivityDate": "2014-11-03T17:45:23.570"}});