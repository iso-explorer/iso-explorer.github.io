post_cb({"18915868": {"Id": "18915868", "PostTypeId": "2", "Body": "<p>By the current wording of the standard it is a compiler bug, and the program is well-formed.  It is now being considered whether it should be a standard defect, as it would be difficult to implement.</p>\n<p>For a detailed explanation see:</p>\n<p><a href=\"https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/std-discussion/Nv5_2dCHm6M\" rel=\"nofollow\">https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/std-discussion/Nv5_2dCHm6M</a></p>\n<p>Report copied below:</p>\n<blockquote>\n<p id=\"so_18903113_18915868_0\">The current wording of the C++11 official through to N3690 inclusive\n  has the following:</p>\n<blockquote>\n<p id=\"so_18903113_18915868_13\">A conditional-expression e is a core constant expression unless the evaluation of e would evaluate one of the following expressions:</p>\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to</li>\n<li><ul>\n<li>a non-volatile glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization,\n    initialized with a constant expression</li>\n</ul></li>\n</ul>\n</blockquote>\n<p id=\"so_18903113_18915868_2\">The following declaration at global scope:</p>\n<pre><code>const int x[2] = {42, 43};\n</code></pre>\n<p id=\"so_18903113_18915868_3\">defines an array of 2 const int objects, list-initialized with <code>{42,\n  43}</code></p>\n<p id=\"so_18903113_18915868_4\">In 8.5.1 [dcl.init.aggr]/2:</p>\n<blockquote>\n<p id=\"so_18903113_18915868_14\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as\n    initializers for the members of the aggregate, in increasing subscript\n    or member order.</p>\n</blockquote>\n<p id=\"so_18903113_18915868_6\">So the initializer of the first element object is <code>42</code> and the\n  initializer of the second element object is <code>43</code>.</p>\n<p id=\"so_18903113_18915868_7\">The expression <code>*x</code> is an lvalue and a core constant expression.  It\n  entails an array-to-pointer conversion, and an indirection - neither\n  of which disqualify the expression as a core constant expression.  The\n  glvalue expression refers to the first element object of <code>x</code>.  <code>*x</code> is a\n  non-volatile glvalue of integral type (const int) that refers to a\n  non-volatile const object with a preceding initialization, and\n  intialized with the constant expression <code>42</code>.</p>\n<p id=\"so_18903113_18915868_8\">Therefore an lvalue-to-rvalue conversion applied to the glvalue <code>*x</code>\n  is allowed in a constant expression, and so the following is\n  well-formed:</p>\n<pre><code>constexpr int y = *x;\n</code></pre>\n<p id=\"so_18903113_18915868_9\">Neither gcc or clang trunk currently accept this as a constant\n  expression, despite it being well-formed according to the standard.</p>\n<p id=\"so_18903113_18915868_10\">Is this intended?</p>\n<p id=\"so_18903113_18915868_11\">A full demo program:</p>\n<pre><code>const int x[2] = {42, 43};\nconstexpr int y = *x;\nint main() {}\n</code></pre>\n<p id=\"so_18903113_18915868_12\">Implementations similarly fail with the equivalent lvalue <code>x[0]</code> as\n  well.</p>\n</blockquote>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2013-09-20T19:53:14.437", "Score": "3", "CreationDate": "2013-09-20T11:39:06.890", "ParentId": "18903113", "CommentCount": "19", "OwnerUserId": "1131467", "LastEditDate": "2013-09-20T19:53:14.437"}, "bq_ids": {"n4140": {"so_18903113_18915868_1": {"length": 10, "quality": 1.0, "section_id": 6185}, "so_18903113_18915868_6": {"length": 6, "quality": 0.75, "section_id": 3321}, "so_18903113_18915868_14": {"length": 17, "quality": 0.9444444444444444, "section_id": 3299}, "so_18903113_18903747_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 500}, "so_18903113_18915868_8": {"length": 6, "quality": 0.6, "section_id": 6185}, "so_18903113_18915868_5": {"length": 17, "quality": 0.9444444444444444, "section_id": 3299}, "so_18903113_18915868_13": {"length": 10, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_18903113_18915868_1": {"length": 7, "quality": 0.7, "section_id": 5946}, "so_18903113_18915868_6": {"length": 5, "quality": 0.625, "section_id": 3191}, "so_18903113_18915868_13": {"length": 7, "quality": 0.7, "section_id": 5946}, "so_18903113_18903747_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5946}, "so_18903113_18915868_8": {"length": 6, "quality": 0.6, "section_id": 5946}, "so_18903113_18915868_5": {"length": 17, "quality": 0.9444444444444444, "section_id": 3169}, "so_18903113_18915868_14": {"length": 17, "quality": 0.9444444444444444, "section_id": 3169}}, "n4659": {"so_18903113_18915868_1": {"length": 7, "quality": 0.7, "section_id": 7687}, "so_18903113_18915868_6": {"length": 6, "quality": 0.75, "section_id": 4087}, "so_18903113_18915868_14": {"length": 13, "quality": 0.7222222222222222, "section_id": 4065}, "so_18903113_18903747_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 823}, "so_18903113_18915868_8": {"length": 6, "quality": 0.6, "section_id": 7687}, "so_18903113_18903113_0": {"length": 16, "quality": 0.5333333333333333, "section_id": 7687}, "so_18903113_18915868_5": {"length": 13, "quality": 0.7222222222222222, "section_id": 4065}, "so_18903113_18915868_13": {"length": 7, "quality": 0.7, "section_id": 7687}}}, "18903747": {"Id": "18903747", "PostTypeId": "2", "Body": "<p>In 5.19:</p>\n<blockquote>\n<p id=\"so_18903113_18903747_0\">A [...]expression is a constant expression unless it involves one of the following [...]:</p>\n<ul>\n<li><p id=\"so_18903113_18903747_1\">an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression, or</li>\n<li>a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers\n  to a sub-object of such an object, or</li>\n<li>a glvalue of literal type that refers to a non-volatile temporary object initialized with a constant\n  expression</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Putting it plainly, lvalue-to-rvalue conversion can only be done in constant expressions if:</p>\n<ul>\n<li>a constant integral (or enum) declaration initialized with a constant: <code>const int x = 3;</code>.</li>\n<li>a declaration with <code>constexpr</code>: <code>constexpr int x[] = {1,2,3};</code>.</li>\n<li>a temporary object initialized with a constant expression...</li>\n</ul>\n<p>Your example does include lvalue-to-rvalue conversion, but has none of these exceptions, so <code>x</code> is not a constant expression. If, however, you change it to:</p>\n<pre><code>constexpr int x[] = {1,2,3};\n\nstatic_assert(x[0] == 1, \"yay\");\n\nint main() {}\n</code></pre>\n<p>Then all is well.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-09-19T20:05:41.103", "Score": "9", "CreationDate": "2013-09-19T19:53:27.457", "ParentId": "18903113", "CommentCount": "20", "OwnerUserId": "865874", "LastEditDate": "2013-09-19T20:05:41.103"}, "18903113": {"ViewCount": "551", "Body": "<p>Is the following C++11 program ill-formed?</p>\n<pre><code>const int x[] = {1,2,3};\n\nstatic_assert(x[0] == 1, \"yay\");\n\nint main() {}\n</code></pre>\n<p>gcc and clang seem to think so, but why isn't <code>x[0] == 1</code> a constant expression?</p>\n<pre><code>x[0] == 1\nsubscript operator\n*(x+0) == 1\narray-to-pointer conversion (int* p = x)\n*(p+0) == 1\npointer addition\n*p == 1\nindirection (lvalue y = x[0])\ny == 1\nlvalue-to-rvalue conversion:\n</code></pre>\n<blockquote>\n<p id=\"so_18903113_18903113_0\">a non-volatile glvalue (yes, x[0] is a glvalue and non-volatile) of integral (yes it has type const int) or enumeration type that refers to a non-volatile const object (yes it has type const int) with a preceding initialization (yes initialized with 1), initialized with a constant expression (yes 1 is constant expression)</p>\n</blockquote>\n<p>Seems true, the first element of the <code>x</code> array satisfies these conditions.</p>\n<pre><code>1 == 1\n</code></pre>\n<p>?</p>\n<p>Is this a compiler bug, standard defect, or am i missing something?</p>\n<p>What part of 5.19 [expr.const] says this isn't a constant expression?</p>\n", "Title": "`x[0] == 1` constant expression in C++11 when x is const int[]?", "CreationDate": "2013-09-19T19:18:31.417", "LastActivityDate": "2013-09-20T20:50:12.867", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2013-09-20T20:50:12.867", "LastEditorUserId": "103167", "Id": "18903113", "Score": "18", "OwnerUserId": "1131467", "Tags": "<c++><c++11><const><constexpr>", "AnswerCount": "2"}});