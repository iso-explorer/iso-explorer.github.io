post_cb({"38469143": {"ParentId": "38468844", "CommentCount": "1", "Body": "<p>Well, you can always do this:</p>\n<pre><code>std::unordered_map&lt;...&gt; m;\nstd::vector&lt;key_type&gt; needs_removing;\nfor(auto&amp;&amp; pair : m)\n{\n    if (pred(pair))\n        needs_removing.push_back(pair.first);\n}\nfor(auto&amp;&amp; key : needs_removing)\n    m.erase(key);\n</code></pre>\n<p>It's slower, but the complexity is the same.</p>\n", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "38469143", "Score": "1", "CreationDate": "2016-07-19T21:53:10.923", "LastActivityDate": "2016-07-19T21:53:10.923"}, "38468844": {"CommentCount": "4", "ViewCount": "1071", "PostTypeId": "1", "LastEditorUserId": "1466970", "CreationDate": "2016-07-19T21:29:04.993", "LastActivityDate": "2016-07-20T20:17:41.577", "Title": "Erasing elements from unordered_map in a loop", "FavoriteCount": "2", "LastEditDate": "2016-07-20T18:16:22.757", "Id": "38468844", "Score": "13", "Body": "<p>There are several answers on StackOverflow that suggest that the following loop is a fine way to erase elements from a <code>std::unordered_map</code> that satisfy some predicate <code>pred</code>:</p>\n<pre><code>std::unordered_map&lt;...&gt; m;\nauto it = m.begin();\nwhile (it != m.end())\n{\n    if (pred(*it))\n        it = m.erase(it);\n    else\n        ++it;\n}\n</code></pre>\n<p>I'm specifically interested in C++11 (as opposed to C++14), and the following ominous <a href=\"http://en.cppreference.com/w/cpp/container/unordered_map/erase\" rel=\"noreferrer\">note on cppreference.com</a> suggests that the above loop depends on undefined behavior and may not work in C++11 after all:</p>\n<blockquote>\n<p id=\"so_38468844_38468844_0\">The order of the elements that are not erased is preserved (this makes it possible to erase individual elements while iterating through the container) <strong>(since C++14)</strong></p>\n</blockquote>\n<p>See also <a href=\"http://wg21.cmeerw.net/lwg/issue2356\" rel=\"noreferrer\">Title 2356. Stability of erasure in unordered associative containers</a> which contains a requested wording change to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"noreferrer\">Working Draft N3797</a> item 14 on page 754 (the additional phrase beginning \", and preserve the relative order ...\").</p>\n<blockquote>\n<p id=\"so_38468844_38468844_1\">This wording is relative to N3797.</p>\n<p id=\"so_38468844_38468844_2\">Modify [unord.req], p14 as indicated:</p>\n<p id=\"so_38468844_38468844_3\">-14- The insert and emplace members shall not affect the validity of references to container elements, but may invalidate all iterators to\n  the container. The erase members shall invalidate only iterators and\n  references to the erased elements, and preserve the relative order of\n  the elements that are not erased.</p>\n</blockquote>\n<p>If my interpretation of the note from cppreference.com is correct, and the above loop depends on undefined behavior in C++11, what's the most efficient way to solve this problem in C++11?</p>\n", "Tags": "<c++><c++11><unordered-map>", "OwnerUserId": "44738", "AnswerCount": "3"}, "38469800": {"ParentId": "38468844", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>To comply with C++11 you're unfortunately a bit limited in how you can tackle this. Your options basically boil down to:</p>\n<ol>\n<li><p>Iterate over the <code>unordered_map</code> and build a list of keys to delete like so:</p>\n<pre><code>//std::unordered_map&lt;...&gt; mymap;\nstd::vector&lt;decltype(mymap)::key_type&gt; vec;\nfor (auto&amp;&amp; i : mymap)\n    if (/*compare i*/)\n        vec.emplace_back(i.first);\nfor (auto&amp;&amp; key : vec)\n    mymap.erase(key);\n</code></pre></li>\n<li><p>Iterate over the object and reset if we find something to remove - I'd really only recommend this for small datasets. those of you who feel goto is unconditionally bad, well, this option is arguably bad.</p>\n<pre><code>//std::unordered_map&lt;...&gt; mymap;\nreset:\nfor (auto&amp;&amp; i : mymap)\n    if (/*compare i*/) {\n        mymap.erase(i.first);\n        goto reset;\n    }\n</code></pre></li>\n<li><p>As a somewhat <em>out there</em> option, you could also just create a new <code>unordered_map</code> and move the elements that you want to keep. This is arguably a good option when you have more to delete than to keep.</p>\n<pre><code>//std::unordered_map&lt;...&gt; mymap;\ndecltype(mymap) newmap;\nfor (auto&amp;&amp; i : mymap)\n    if (/*i is an element we want*/)\n        newmap.emplace(std::move(i));\nmymap.swap(newmap);\n</code></pre></li>\n</ol>\n", "OwnerUserId": "234946", "LastEditorUserId": "234946", "LastEditDate": "2016-07-20T20:17:41.577", "Id": "38469800", "Score": "8", "CreationDate": "2016-07-19T22:55:08.810", "LastActivityDate": "2016-07-20T20:17:41.577"}, "bq_ids": {"n4140": {"so_38468844_38468844_3": {"section_id": 766, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_38468844_38468844_3": {"section_id": 753, "quality": 0.75, "length": 21}}, "n4659": {"so_38468844_38468844_3": {"section_id": 826, "quality": 0.9285714285714286, "length": 26}}}, "38468882": {"ParentId": "38468844", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Always consult the stl-algorithms first</p>\n<p>This one seems to be the wanted:\n<a href=\"http://www.cplusplus.com/reference/algorithm/remove_if/\" rel=\"nofollow\">http://www.cplusplus.com/reference/algorithm/remove_if/</a></p>\n<p>For an overview:\n<a href=\"http://www.cplusplus.com/reference/algorithm/\" rel=\"nofollow\">http://www.cplusplus.com/reference/algorithm/</a></p>\n<p><strong>EDIT</strong>\ncppreference has an similar example at the bottom of the site.\nIt works with a c++11 compiler.</p>\n", "OwnerUserId": "6605494", "LastEditorUserId": "6605494", "LastEditDate": "2016-07-19T21:37:30.097", "Id": "38468882", "Score": "-3", "CreationDate": "2016-07-19T21:32:36.347", "LastActivityDate": "2016-07-19T21:37:30.097"}});