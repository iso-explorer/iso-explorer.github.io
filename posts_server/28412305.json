post_cb({"28416695": {"ParentId": "28412305", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It seems to me that what you need is not a mechanism to move back and forth a value through a function call, since references do that adequately, but a device to compose functions working that way.</p>\n<pre><code>template &lt;void f(Foo &amp;), void g(Foo &amp;)&gt;\nvoid compose2(Foo &amp;v){\n   f(v);\n   g(v);\n}\n</code></pre>\n<p>Of course, you could make this more generic on the parameter type.</p>\n<pre><code>template &lt;typename T, void f(T&amp;), void (...G)(T&amp;)&gt;\nvoid compose(T &amp;v){\n  f(v);\n  compose2&lt;T,G...&gt;(v);\n}\n\ntemplate &lt;typename T&gt;\nvoid compose(Foo &amp;){\n}\n</code></pre>\n<p>Example:</p>\n<pre><code>#include &lt;iostream&gt;\n\n//... above template definitions for compose elided\n\n\nstruct Foo {\n  int x;\n};\n\nvoid f(Foo &amp;v){\n  v.x++;\n}\n\nvoid g(Foo &amp;v){\n  v.x *= 2;\n}\n\nint main(){\n  Foo v = { 9 };\n\n  compose&lt;Foo, f, g, f, g&gt;(v);\n\n  std::cout &lt;&lt; v.x &lt;&lt; \"\\n\"; // output \"42\"\n}\n</code></pre>\n<p>Note that you could even parameterize the template on the procedure prototype, but at this time on my machine, only clang++ (v3.5) seems to accept it, g++ (4.9.1) doesn't like it.</p>\n", "OwnerUserId": "1769720", "LastEditorUserId": "1769720", "LastEditDate": "2015-02-09T20:44:08.263", "Id": "28416695", "Score": "3", "CreationDate": "2015-02-09T18:25:14.637", "LastActivityDate": "2015-02-09T20:44:08.263"}, "29354733": {"ParentId": "28412305", "CommentCount": "0", "Body": "<p>Per @MooingDuck's suggestion, it's actually possible to return an rref from the functions.  Generally, this would be a really bad idea, but since the memory is allocated outside of the function, it becomes a non-issue.  Then, the number of moves is dramatically reduced.  Unfortunately, if someone tries to assign the result to an rref, this will cause undefined behavior.  All of the code and results are below.</p>\n<p>For the single argument case:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    // Add some data to see if it gets moved correctly\n    int data;\n\n    Foo() : data(0) {\n        std::cout &lt;&lt; \"default constructor\" &lt;&lt; std::endl; \n    } \n    Foo(int const &amp; data_) : data(data_) {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl; \n    } \n    Foo(Foo &amp;&amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n};\n\nFoo &amp;&amp; f(Foo &amp;&amp; foo) {\n    std::cout &lt;&lt; \"Called f: foo.data = \" &lt;&lt; foo.data &lt;&lt; std::endl;\n    return std::move(foo);\n}\n\nFoo &amp;&amp; g(Foo &amp;&amp; foo) {\n    std::cout &lt;&lt; \"Called g: foo.data = \" &lt;&lt; foo.data &lt;&lt; std::endl;\n    return std::move(foo);\n}\n\nint main() {\n    Foo foo(5);\n    foo = f(std::move(foo));\n    std::cout &lt;&lt; \"Finished with f(foo)\" &lt;&lt; std::endl;\n    foo = g(f(std::move(foo)));\n    std::cout &lt;&lt; \"Finished with g(f(foo))\" &lt;&lt; std::endl;\n    Foo foo2 = g(f(std::move(foo)));\n    std::cout &lt;&lt; \"Finished with g(f(foo)) a second time\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"foo2.data = \" &lt;&lt; foo2.data &lt;&lt; std::endl;\n    // Now, break it.\n    Foo &amp;&amp; foo3 = g(f(Foo(4)));  \n    // Notice that the destuctor for Foo(4) occurs before the following line.\n    // That means that foo3 points at destructed memory.\n    std::cout &lt;&lt; \"foo3.data = \" &lt;&lt; foo3.data &lt;&lt; \".  If there's a destructor\"\n        \" before this line that'd mean that this reference is invalid.\"\n        &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This generates</p>\n<pre><code>constructor\nCalled f: foo.data = 5\nmove assignment\nFinished with f(foo)\nCalled f: foo.data = 5\nCalled g: foo.data = 5\nmove assignment\nFinished with g(f(foo))\nCalled f: foo.data = 5\nCalled g: foo.data = 5\nmove\nFinished with g(f(foo)) a second time\nfoo2.data = 5\nconstructor\nCalled f: foo.data = 4\nCalled g: foo.data = 4\ndestructor\nfoo3.data = 4.  If there's a destructor before this line that'd mean that this reference is invalid.\ndestructor\ndestructor\n</code></pre>\n<p>In the multi-argument case</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// This comes from the N3802 proposal for C++\ntemplate &lt;typename F, typename Tuple, size_t... I&gt;\ndecltype(auto) apply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, std::index_sequence&lt;I...&gt;) {\n    return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);\n}\ntemplate &lt;typename F, typename Tuple&gt;\ndecltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) {\n    using Indices = \n        std::make_index_sequence&lt;std::tuple_size&lt;std::decay_t&lt;Tuple&gt;&gt;::value&gt;;\n    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t), Indices{});\n}\n\n// Now, for our example\nstruct Foo {\n    // Add some data to see if it gets moved correctly\n    int data;\n\n    Foo() : data(0) {\n        std::cout &lt;&lt; \"default constructor\" &lt;&lt; std::endl; \n    } \n    Foo(int const &amp; data_) : data(data_) {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl; \n    } \n    Foo(Foo &amp;&amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp; x) {\n        std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n};\n\nstd::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; f(Foo &amp;&amp; x,Foo &amp;&amp; y) {\n    std::cout &lt;&lt; \"Called f: (x.data,y.data) = (\" &lt;&lt; x.data &lt;&lt; ',' &lt;&lt;\n        y.data &lt;&lt; ')' &lt;&lt; std::endl;\n    return std::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; (std::move(x),std::move(y));\n}\n\nstd::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; g(Foo &amp;&amp; x,Foo &amp;&amp; y) {\n    std::cout &lt;&lt; \"Called g: (x.data,y.data) = (\" &lt;&lt; x.data &lt;&lt; ',' &lt;&lt;\n        y.data &lt;&lt; ')' &lt;&lt; std::endl;\n    return std::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; (std::move(x),std::move(y));\n}\n\nint main() {\n    Foo x(5),y(6);\n    std::tie(x,y) = f(std::move(x),std::move(y));\n    std::cout &lt;&lt; \"Finished with f(x,y)\" &lt;&lt; std::endl;\n    std::tie(x,y) = apply(g,f(std::move(x),std::move(y)));\n    std::cout &lt;&lt; \"Finished with g(f(x,y))\" &lt;&lt; std::endl;\n    std::tuple &lt;Foo,Foo&gt; x_y = apply(g,f(std::move(x),std::move(y)));\n    std::cout &lt;&lt; \"Finished with g(f(x,y)) a second time\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(x.data,y.data) = (\" &lt;&lt; std::get &lt;0&gt;(x_y).data &lt;&lt; ',' &lt;&lt;\n        std::get &lt;1&gt; (x_y).data &lt;&lt; ')' &lt;&lt; std::endl;\n    // Now, break it.\n    std::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; x_y2 = apply(g,f(Foo(7),Foo(8)));  \n    // Notice that the destuctors for Foo(7) and Foo(8) occur before the\n    // following line.  That means that x_y2points at destructed memory.\n    std::cout &lt;&lt; \"(x2.data,y2.data) = (\" &lt;&lt; std::get &lt;0&gt;(x_y2).data &lt;&lt; ',' &lt;&lt;\n        std::get &lt;1&gt; (x_y2).data &lt;&lt; ')' &lt;&lt; \".  If there's a destructor\"\n        \" before this line that'd mean that this reference is invalid.\"\n        &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This generates</p>\n<pre><code>constructor\nconstructor\nCalled f: (x.data,y.data) = (5,6)\nmove assignment\nmove assignment\nFinished with f(x,y)\nCalled f: (x.data,y.data) = (5,6)\nCalled g: (x.data,y.data) = (5,6)\nmove assignment\nmove assignment\nFinished with g(f(x,y))\nCalled f: (x.data,y.data) = (5,6)\nCalled g: (x.data,y.data) = (5,6)\nmove\nmove\nFinished with g(f(x,y)) a second time\n(x.data,y.data) = (5,6)\nconstructor\nconstructor\nCalled f: (x.data,y.data) = (7,8)\nCalled g: (x.data,y.data) = (7,8)\ndestructor\ndestructor\n(x2.data,y2.data) = (7,8).  If there's a destructor before this line that'd mean that this reference is invalid.\ndestructor\ndestructor\ndestructor\ndestructor\n</code></pre>\n", "OwnerUserId": "1932452", "PostTypeId": "2", "Id": "29354733", "Score": "0", "CreationDate": "2015-03-30T19:35:54.460", "LastActivityDate": "2015-03-30T19:35:54.460"}, "28412305": {"CommentCount": "7", "AcceptedAnswerId": "29354733", "PostTypeId": "1", "LastEditorUserId": "1932452", "CreationDate": "2015-02-09T14:41:27.500", "LastActivityDate": "2015-03-30T19:35:54.460", "LastEditDate": "2015-02-09T21:05:30.207", "ViewCount": "837", "FavoriteCount": "1", "Title": "Is there a way to prevent a move constructor followed by a move assignment operator when copy elison fails?", "Id": "28412305", "Score": "6", "Body": "<p>I've a situation where I want to call a function with a parameter and return the result into this same argument</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>foo = f(foo);\n</code></pre>\n<p>In addition, I assume that the parameter <code>x</code> is very large, so I don't want to call its copy constructor, but rather its move constructor.  Finally, I don't want to pass the argument by reference because I would like to compose the function <code>f</code> with another function <code>g</code>.  Hence, so that things like</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>foo = g(f(foo));\n</code></pre>\n<p>are possible.  Now, with move semantics, this is all mostly possible as demonstrated by the following program</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    Foo() {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl; \n    } \n    Foo(Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp; x) {\n        std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n};\n\nFoo f(Foo &amp;&amp; foo) {\n    std::cout &lt;&lt; \"Called f\" &lt;&lt; std::endl;\n    return std::move(foo);\n}\n\nFoo g(Foo &amp;&amp; foo) {\n    std::cout &lt;&lt; \"Called g\" &lt;&lt; std::endl;\n    return std::move(foo);\n}\n\nint main() {\n   Foo foo;\n   foo = f(std::move(foo));\n   std::cout &lt;&lt; \"Finished with f(foo)\" &lt;&lt; std::endl;\n   foo = g(f(std::move(foo)));\n   std::cout &lt;&lt; \"Finished with g(f(foo))\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output from this program is:</p>\n<pre><code>constructor\nCalled f\nmove\nmove assignment\ndestructor\nFinished with f(foo)\nCalled f\nmove\nCalled g\nmove\nmove assignment\ndestructor\ndestructor\nFinished with g(f(foo))\ndestructor\n</code></pre>\n<p>which makes sense.  Now, what's bothering me is that when we call <code>f</code> the first time, or the composition, the move constructor is followed by the move assignment operator.  Ideally, I'd like to use copy elison to prevent any of these constructors from being called, but I'm not sure how.  Specifically, the functions <code>f</code> and <code>g</code> call <code>std::move</code> on <code>foo</code> because otherwise the copy, not move, constructor is called.  This is specified in the C++ standard under section 12.8.31 and 12.8.32.  Specifically,</p>\n<blockquote>\n<p id=\"so_28412305_28412305_0\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object, even if the constructor\n  selected for the copy/move operation and/or the destructor for the\n  object have side effects. In such cases, the implementation treats the\n  source and target of the omitted copy/move operation as simply two\n  different ways of referring to the same object, and the destruction of\n  that object occurs at the later of the times when the two objects\n  would have been destroyed without the optimization. This elision of\n  copy/move operations, called copy elision, is permitted in the\n  following circumstances (which may be combined to eliminate multiple\n  copies):</p>\n<p id=\"so_28412305_28412305_1\">\u2014 in a return statement in a function with a class return type, when\n  the expression is the name of a non-volatile automatic object (other\n  than a function or catch-clause parameter) with the same cvunqualified\n  type as the function return type, the copy/move operation can be\n  omitted by constructing the automatic object directly into the\n  function\u2019s return value</p>\n</blockquote>\n<p>Since we return a function argument, we don't get copy elison.  In addition:</p>\n<blockquote>\n<p id=\"so_28412305_28412305_2\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue. If overload resolution\n  fails, or if the type of the first parameter of the selected\n  constructor is not an rvalue reference to the object\u2019s type (possibly\n  cv-qualified), overload resolution is performed again, considering the\n  object as an lvalue. [ Note: This two-stage overload resolution must\n  be performed regardless of whether copy elision will occur. It\n  determines the constructor to be called if elision is not performed,\n  and the selected constructor must be accessible even if the call is\n  elided. \u2014end note ]</p>\n</blockquote>\n<p>Since we return a function argument, we return an l-value, so we're forced to use <code>std::move</code>.  Now, at the end of the day, I just want the memory moved back into the argument and calling both a move constructor and move assignment operator seems like too much.  It feels like there should be a single move or copy elison.  Is there a way to accomplish this?</p>\n<h1>Edit 1</h1>\n<p>In a longer response to @didierc's answer than a comment would allow, technically, yes, that would work for this situation.  At the same time, the greater goal is to allow functions with multiple returns to be composed together in a way where nothing is copied.  I can also do this with move semantics, but it requires a trick from C++14 to work.  It also exacerbates the issue with lots of moves.  However, technically, there's no copies.  Specifically:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// This comes from the N3802 proposal for C++\ntemplate &lt;typename F, typename Tuple, size_t... I&gt;\ndecltype(auto) apply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, std::index_sequence&lt;I...&gt;) {\n    return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);\n}\ntemplate &lt;typename F, typename Tuple&gt;\ndecltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) {\n    using Indices = \n        std::make_index_sequence&lt;std::tuple_size&lt;std::decay_t&lt;Tuple&gt;&gt;::value&gt;;\n    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t), Indices{});\n}\n\n// Now, for our example\nstruct Foo {\n    Foo() {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl; \n    } \n    Foo(Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp; x) {\n        std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n};\n\nstd::tuple &lt;Foo,Foo&gt; f(Foo &amp;&amp; x,Foo &amp;&amp; y) {\n    std::cout &lt;&lt; \"Called f\" &lt;&lt; std::endl;\n    return std::make_tuple &lt;Foo,Foo&gt; (std::move(x),std::move(y));\n}\n\nstd::tuple &lt;Foo,Foo&gt; g(Foo &amp;&amp; x,Foo &amp;&amp; y) {\n    std::cout &lt;&lt; \"Called g\" &lt;&lt; std::endl;\n    return std::make_tuple &lt;Foo,Foo&gt; (std::move(x),std::move(y));\n}\n\nint main() {\n   Foo x,y;\n   std::tie(x,y) = f(std::move(x),std::move(y));\n   std::cout &lt;&lt; \"Finished with f(foo)\" &lt;&lt; std::endl;\n   std::tie(x,y) = apply(g,f(std::move(x),std::move(y)));\n   std::cout &lt;&lt; \"Finished with g(f(foo))\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This generates</p>\n<pre><code>constructor\nconstructor\nCalled f\nmove\nmove\nmove assignment\nmove assignment\ndestructor\ndestructor\nFinished with f(foo)\nCalled f\nmove\nmove\nCalled g\nmove\nmove\nmove assignment\nmove assignment\ndestructor\ndestructor\ndestructor\ndestructor\nFinished with g(f(foo))\ndestructor\ndestructor\n</code></pre>\n<p>Basically, the same issue as above occurs: We get move assignments that would be nice if they disappeared.</p>\n<h1>Edit 2</h1>\n<p>Per @MooingDuck's suggestion, it's actually possible to return an rref from the functions.  Generally, this would be a really bad idea, but since the memory is allocated outside of the function, it becomes a non-issue.  Then, the number of moves is dramatically reduced.  Unfortunately, if someone tries to assign the result to an rref, this will cause undefined behavior.  All of the code and results are below.</p>\n<p>For the single argument case:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    // Add some data to see if it gets moved correctly\n    int data;\n\n    Foo() : data(0) {\n        std::cout &lt;&lt; \"default constructor\" &lt;&lt; std::endl; \n    } \n    Foo(int const &amp; data_) : data(data_) {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl; \n    } \n    Foo(Foo &amp;&amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n};\n\nFoo &amp;&amp; f(Foo &amp;&amp; foo) {\n    std::cout &lt;&lt; \"Called f: foo.data = \" &lt;&lt; foo.data &lt;&lt; std::endl;\n    return std::move(foo);\n}\n\nFoo &amp;&amp; g(Foo &amp;&amp; foo) {\n    std::cout &lt;&lt; \"Called g: foo.data = \" &lt;&lt; foo.data &lt;&lt; std::endl;\n    return std::move(foo);\n}\n\nint main() {\n    Foo foo(5);\n    foo = f(std::move(foo));\n    std::cout &lt;&lt; \"Finished with f(foo)\" &lt;&lt; std::endl;\n    foo = g(f(std::move(foo)));\n    std::cout &lt;&lt; \"Finished with g(f(foo))\" &lt;&lt; std::endl;\n    Foo foo2 = g(f(std::move(foo)));\n    std::cout &lt;&lt; \"Finished with g(f(foo)) a second time\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"foo2.data = \" &lt;&lt; foo2.data &lt;&lt; std::endl;\n    // Now, break it.\n    Foo &amp;&amp; foo3 = g(f(Foo(4)));  \n    // Notice that the destuctor for Foo(4) occurs before the following line.\n    // That means that foo3 points at destructed memory.\n    std::cout &lt;&lt; \"foo3.data = \" &lt;&lt; foo3.data &lt;&lt; \".  If there's a destructor\"\n        \" before this line that'd mean that this reference is invalid.\"\n        &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This generates</p>\n<pre><code>constructor\nCalled f: foo.data = 5\nmove assignment\nFinished with f(foo)\nCalled f: foo.data = 5\nCalled g: foo.data = 5\nmove assignment\nFinished with g(f(foo))\nCalled f: foo.data = 5\nCalled g: foo.data = 5\nmove\nFinished with g(f(foo)) a second time\nfoo2.data = 5\nconstructor\nCalled f: foo.data = 4\nCalled g: foo.data = 4\ndestructor\nfoo3.data = 4.  If there's a destructor before this line that'd mean that this reference is invalid.\ndestructor\ndestructor\n</code></pre>\n<p>In the multi-argument case</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// This comes from the N3802 proposal for C++\ntemplate &lt;typename F, typename Tuple, size_t... I&gt;\ndecltype(auto) apply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, std::index_sequence&lt;I...&gt;) {\n    return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);\n}\ntemplate &lt;typename F, typename Tuple&gt;\ndecltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) {\n    using Indices = \n        std::make_index_sequence&lt;std::tuple_size&lt;std::decay_t&lt;Tuple&gt;&gt;::value&gt;;\n    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t), Indices{});\n}\n\n// Now, for our example\nstruct Foo {\n    // Add some data to see if it gets moved correctly\n    int data;\n\n    Foo() : data(0) {\n        std::cout &lt;&lt; \"default constructor\" &lt;&lt; std::endl; \n    } \n    Foo(int const &amp; data_) : data(data_) {\n        std::cout &lt;&lt; \"constructor\" &lt;&lt; std::endl; \n    } \n    Foo(Foo &amp;&amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"move\" &lt;&lt; std::endl;\n    }\n    Foo(Foo const &amp; x) {\n        data = x.data;\n        std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl;\n    }\n    ~Foo() {\n        std::cout &lt;&lt; \"destructor\" &lt;&lt; std::endl;\n    }\n    Foo &amp; operator = (Foo &amp;&amp; x) {\n        std::cout &lt;&lt; \"move assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n    Foo &amp; operator = (Foo &amp; x) {\n        std::cout &lt;&lt; \"copy assignment\" &lt;&lt; std::endl; \n        return *this;\n    }\n};\n\nstd::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; f(Foo &amp;&amp; x,Foo &amp;&amp; y) {\n    std::cout &lt;&lt; \"Called f: (x.data,y.data) = (\" &lt;&lt; x.data &lt;&lt; ',' &lt;&lt;\n        y.data &lt;&lt; ')' &lt;&lt; std::endl;\n    return std::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; (std::move(x),std::move(y));\n}\n\nstd::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; g(Foo &amp;&amp; x,Foo &amp;&amp; y) {\n    std::cout &lt;&lt; \"Called g: (x.data,y.data) = (\" &lt;&lt; x.data &lt;&lt; ',' &lt;&lt;\n        y.data &lt;&lt; ')' &lt;&lt; std::endl;\n    return std::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; (std::move(x),std::move(y));\n}\n\nint main() {\n    Foo x(5),y(6);\n    std::tie(x,y) = f(std::move(x),std::move(y));\n    std::cout &lt;&lt; \"Finished with f(x,y)\" &lt;&lt; std::endl;\n    std::tie(x,y) = apply(g,f(std::move(x),std::move(y)));\n    std::cout &lt;&lt; \"Finished with g(f(x,y))\" &lt;&lt; std::endl;\n    std::tuple &lt;Foo,Foo&gt; x_y = apply(g,f(std::move(x),std::move(y)));\n    std::cout &lt;&lt; \"Finished with g(f(x,y)) a second time\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"(x.data,y.data) = (\" &lt;&lt; std::get &lt;0&gt;(x_y).data &lt;&lt; ',' &lt;&lt;\n        std::get &lt;1&gt; (x_y).data &lt;&lt; ')' &lt;&lt; std::endl;\n    // Now, break it.\n    std::tuple &lt;Foo&amp;&amp;,Foo&amp;&amp;&gt; x_y2 = apply(g,f(Foo(7),Foo(8)));  \n    // Notice that the destuctors for Foo(7) and Foo(8) occur before the\n    // following line.  That means that x_y2points at destructed memory.\n    std::cout &lt;&lt; \"(x2.data,y2.data) = (\" &lt;&lt; std::get &lt;0&gt;(x_y2).data &lt;&lt; ',' &lt;&lt;\n        std::get &lt;1&gt; (x_y2).data &lt;&lt; ')' &lt;&lt; \".  If there's a destructor\"\n        \" before this line that'd mean that this reference is invalid.\"\n        &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This generates</p>\n<pre><code>constructor\nconstructor\nCalled f: (x.data,y.data) = (5,6)\nmove assignment\nmove assignment\nFinished with f(x,y)\nCalled f: (x.data,y.data) = (5,6)\nCalled g: (x.data,y.data) = (5,6)\nmove assignment\nmove assignment\nFinished with g(f(x,y))\nCalled f: (x.data,y.data) = (5,6)\nCalled g: (x.data,y.data) = (5,6)\nmove\nmove\nFinished with g(f(x,y)) a second time\n(x.data,y.data) = (5,6)\nconstructor\nconstructor\nCalled f: (x.data,y.data) = (7,8)\nCalled g: (x.data,y.data) = (7,8)\ndestructor\ndestructor\n(x2.data,y2.data) = (7,8).  If there's a destructor before this line that'd mean that this reference is invalid.\ndestructor\ndestructor\ndestructor\ndestructor\n</code></pre>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "1932452", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_28412305_28412305_0": {"section_id": 480, "quality": 0.9848484848484849, "length": 65}, "so_28412305_28412305_2": {"section_id": 481, "quality": 0.8311688311688312, "length": 64}, "so_28412305_28412305_1": {"section_id": 480, "quality": 1.0, "length": 35}}, "n3337": {"so_28412305_28412305_0": {"section_id": 471, "quality": 0.9393939393939394, "length": 62}, "so_28412305_28412305_2": {"section_id": 472, "quality": 0.948051948051948, "length": 73}, "so_28412305_28412305_1": {"section_id": 471, "quality": 1.0, "length": 35}}, "n4659": {"so_28412305_28412305_0": {"section_id": 502, "quality": 0.9848484848484849, "length": 65}, "so_28412305_28412305_2": {"section_id": 504, "quality": 0.7792207792207793, "length": 60}, "so_28412305_28412305_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}}}, "28413273": {"ParentId": "28412305", "CommentCount": "3", "Body": "<p>You can do it without move if you use a little bit of indirection and compiler optimizations:</p>\n<pre><code>void do_f(Foo &amp; foo); // The code that used to in in f\n\ninline Foo f(Foo foo)\n{\n    do_f(foo);\n    return foo; // This return will be optimized away due to inlining\n}\n</code></pre>\n", "OwnerUserId": "4538344", "PostTypeId": "2", "Id": "28413273", "Score": "2", "CreationDate": "2015-02-09T15:29:42.683", "LastActivityDate": "2015-02-09T15:29:42.683"}});