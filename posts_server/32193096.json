post_cb({"32193096": {"CommentCount": "2", "ViewCount": "85", "PostTypeId": "1", "LastEditorUserId": "5047246", "CreationDate": "2015-08-24T23:06:03.423", "LastActivityDate": "2015-08-24T23:44:30.603", "Title": "Alternatives or enhancements to std::find() on a native c++ pointer (such as uint16 *)", "LastEditDate": "2015-08-24T23:16:20.923", "Id": "32193096", "Score": "1", "Body": "<p>I am trying to come up with a single line C++ conditional check  to check the presence of a value within a buffer. (like the if 'value' in list: check in python) </p>\n<p><code>std::find</code> seemed to be the right fit here.</p>\n<pre><code>char *buf = \"01020304\";\nint buf_len = 8\nuint16_t *ptr = std::find((uint16_t *) buf, (uint16_t *) buf + 3, (uint16_t)13360);    // 13360 corresponds to 2 bytes in \"04\"\nstd::cout &lt;&lt;\"\\n(ptr-buf):\"&lt;&lt;(ptr-(uint16_t *) buf);//returns 3  for any value, even if 0 is passed instead of 13360 since the last 2 bytes are not searched (buf+6, buf +7))\n</code></pre>\n<p><code>std::find</code> seems to search in the [first, last) range of a buffer. This makes sense for STL types like vector. However, for raw pointers, the only way to make <code>std::find()</code> look at the last element of <code>buf</code> involves passing an offset beyond buf (eg. buf+8). </p>\n<p>Is this a safe thing to do? I am guessing not. Is there a better alternative to using <code>std::find</code> to do a single-line exists check on a <code>char *buffer</code>?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "5047246", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32193096_32193172_0": {"section_id": 6151, "quality": 0.8333333333333334, "length": 5}, "so_32193096_32193172_2": {"section_id": 6151, "quality": 1.0, "length": 19}, "so_32193096_32193172_3": {"section_id": 5559, "quality": 0.8837209302325582, "length": 38}, "so_32193096_32193172_1": {"section_id": 6151, "quality": 1.0, "length": 15}, "so_32193096_32193297_0": {"section_id": 6142, "quality": 0.6060606060606061, "length": 20}}, "n3337": {"so_32193096_32193172_2": {"section_id": 5906, "quality": 0.5789473684210527, "length": 11}, "so_32193096_32193172_3": {"section_id": 5341, "quality": 0.8837209302325582, "length": 38}, "so_32193096_32193172_1": {"section_id": 5913, "quality": 0.8, "length": 12}, "so_32193096_32193297_0": {"section_id": 5906, "quality": 0.6060606060606061, "length": 20}}, "n4659": {"so_32193096_32193172_2": {"section_id": 7638, "quality": 0.5263157894736842, "length": 10}, "so_32193096_32193172_1": {"section_id": 7648, "quality": 1.0, "length": 15}, "so_32193096_32193172_0": {"section_id": 7648, "quality": 0.8333333333333334, "length": 5}, "so_32193096_32193172_3": {"section_id": 7006, "quality": 0.8837209302325582, "length": 38}}}, "32193172": {"ParentId": "32193096", "LastEditDate": "2015-08-24T23:44:30.603", "CommentCount": "5", "CreationDate": "2015-08-24T23:14:21.040", "OwnerUserId": "139091", "LastEditorUserId": "139091", "PostTypeId": "2", "Id": "32193172", "Score": "3", "Body": "<p>When using pointers with STL algorithms, it is valid and correct to use a 'one past the end' pointer as the end iterator for a range. It is not valid to dereference a pointer one past the end of an array but you can test against one and perform certain arithmetic operations with one.</p>\n<p>The standard specifies that it is valid to perform comparisons on a 'one past the end' pointer, section 5.9.3, 'Relational Operators':</p>\n<blockquote>\n<p id=\"so_32193096_32193172_0\">5.9.3 Comparing pointers to objects is defined as follows:</p>\n<p id=\"so_32193096_32193172_1\">(3.1) \u2014 If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher subscript compares greater.</p>\n<p id=\"so_32193096_32193172_2\">(3.2) \u2014 If one pointer points to an element of an array, or to a subobject thereof, and another pointer points one past the last element of the array, the latter pointer compares greater.</p>\n</blockquote>\n<p>It also specifies addition and subtraction on pointers such that 'one past the end' pointers behave correctly in algorithms like <code>std::distance()</code>, <code>std::advance()</code>, etc.</p>\n<p>In addition the standard has this to say regarding STL iterators:</p>\n<blockquote>\n<p id=\"so_32193096_32193172_3\">24.1.6 Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence. These values are called past-the-end values. Values of an iterator i for which the expression *i is defined are called dereferenceable. The library never assumes that past-the-end values are dereferenceable. ...</p>\n</blockquote>\n", "LastActivityDate": "2015-08-24T23:44:30.603"}, "32193297": {"ParentId": "32193096", "CommentCount": "0", "Body": "<p>Past the end pointers are standard C too. E.g. it's safe to produce them with arithmetic: from C11 standard, 6.5.6 (additive operators) paragraph 8:</p>\n<blockquote>\n<p id=\"so_32193096_32193297_0\">... If both the pointer\n  operand and the result point to elements of the same array object, or one past the last\n  element of the array object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined. If the result points one past the last element of the array object, it\n  shall not be used as the operand of a unary <b>*</b> operator that is evaluated.</p>\n</blockquote>\n", "OwnerUserId": "1084944", "PostTypeId": "2", "Id": "32193297", "Score": "0", "CreationDate": "2015-08-24T23:27:32.103", "LastActivityDate": "2015-08-24T23:27:32.103"}});