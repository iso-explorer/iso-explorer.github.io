post_cb({"12608911": {"ParentId": "12605725", "CommentCount": "0", "Body": "<p>The standard says:</p>\n<blockquote>\n<p id=\"so_12605725_12608911_0\">Concurrent access to a synchronized (27.5.3.4) standard iostream object\u2019s formatted and unformatted input (27.7.2.1) and output (27.7.3.1) functions or a standard C stream by multiple threads shall not result in a data race (1.10). [<em>Note: Users must still synchronize concurrent use of these objects and streams by multiple threads if they wish to avoid interleaved characters. \u2014 end note</em>]<br>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<em>\u2014 [iostream.objects.overview] 27.4.1 p4</em></br></p>\n</blockquote>\n<p>Notice that the requirement not to produce a data race applies only to the standard iostream objects (cout, cin, cerr, clog, wcout, wcin, wcerr, and wclog) and only when they are synchronized (which they are by default and which can be disabled using the sync_with_stdio member function).</p>\n<p>Unfortunately I've noticed two phenomena; implementations either provide stricter guarantees than required (e.g., thread synchronization for all stream objects no matter what, giving poor performance) or fewer (e.g., standard stream objects that are sync_with_stdio produce data races). MSVC seems to lean toward the former while libc++ leans toward <a href=\"http://llvm.org/bugs/show_bug.cgi?id=12158\">the latter</a>.</p>\n<p>Anyway, as the note indicates, you have to provide mutual exclusion yourself if you want to avoid interleaved characters. Here's one way to do it:</p>\n<pre><code>std::mutex m;\n\nstruct lockostream {\n    std::lock_guard&lt;std::mutex&gt; l;\n    lockostream() : l(m) {}\n};\n\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, lockostream const &amp;l) {\n    return os;\n}\n\nstd::cout &lt;&lt; lockostream() &lt;&lt; \"Hello, World!\\n\";\n</code></pre>\n<p>This way a lock guard is created and lives for the duration of the expression using std::cout. You can templatized the lockostream object to work for any basic_*stream, and even on the address of the stream so that you have a seperate mutex for each one.</p>\n<p>Of course the standard stream objects are global variables, so you might want to avoid them the same way all global variables should be avoided. They're handy for learning C++ and toy programs, but you might want to arrange something better for real programs.</p>\n", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "12608911", "Score": "6", "CreationDate": "2012-09-26T19:22:20.570", "LastActivityDate": "2012-09-26T19:22:20.570"}, "12605725": {"CommentCount": "9", "ViewCount": "3019", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-09-26T15:55:14.730", "LastActivityDate": "2012-09-26T19:22:20.570", "Title": "Basic thread locking in C++11", "LastEditDate": "2012-09-26T18:55:49.770", "Id": "12605725", "Score": "1", "Body": "<p>How do I lock my thread so that my output isn't something like this: hello...hello...hheelhllelolo.l..o......</p>\n<pre><code>std::size_t const nthreads=5;\nstd::vector&lt;std::thread&gt; my_threads(nthreads);\n\nfor(unsigned i=0;i&lt;nthreads;i++)\n{\n    my_threads[i] = std::thread ([] () {std::cout &lt;&lt; \"hello...\";}); \n}\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><locking>", "OwnerUserId": "1700782", "AnswerCount": "2"}, "12607078": {"ParentId": "12605725", "CommentCount": "0", "Body": "<p>You have to use the normal locking techniques as you would do with any other resource otherwise you are experiencing UB.</p>\n<pre><code>std::mutex m;\nstd::lock_guard&lt;std::mutex&gt; lock(m);\nstd::cout &lt;&lt; \"hello hello\";\n</code></pre>\n<p>or alternativly you can use <code>printf</code> which is threadsafe(on posix):</p>\n<pre><code>printf(\"hello hello\");\n</code></pre>\n", "OwnerUserId": "893693", "PostTypeId": "2", "Id": "12607078", "Score": "2", "CreationDate": "2012-09-26T17:19:28.260", "LastActivityDate": "2012-09-26T17:19:28.260"}, "bq_ids": {"n4140": {"so_12605725_12608911_0": {"section_id": 1922, "quality": 0.775, "length": 31}}, "n3337": {"so_12605725_12608911_0": {"section_id": 1911, "quality": 0.775, "length": 31}}, "n4659": {"so_12605725_12608911_0": {"section_id": 2193, "quality": 0.775, "length": 31}}}});