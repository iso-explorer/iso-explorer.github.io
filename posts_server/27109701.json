post_cb({"27109924": {"ParentId": "27109701", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-24T16:52:28.693", "Score": "1", "LastEditorUserId": "2331592", "LastEditDate": "2014-11-24T16:57:29.267", "Id": "27109924", "OwnerUserId": "2331592", "Body": "<p>It is not defined that happens since the c standard does not exactly define how singed integers should be stored. so you can not rely on the internal representation. Also there does no overflow occur. if you just typecast a pointer nothing other happens then another interpretation of the binary data in the following calculations. </p>\n<p>Edit<br>\nOh, i misread the phrase \"but not equivalent integer types\", but i keep the paragraph for your interest:</br></p>\n<p>Your second question has much more trouble in it. Many machines can only read from correctly aligned addresses there the data has to lie on multiples of the types width. If you read a int32 from a non-by-4-divisable address (because you casted a 2-byte int pointer) your CPU may crash.</p>\n<p>You should not rely on the sizes of types.  If you chose another compiler or platform your <code>long</code> and <code>int</code> may not match anymore.</p>\n<p><strong>Conclusion:</strong><br>\nDo not do this. You wrote highly platform dependent (compiler, target machine, architecture) code that hides its errors behind casts that suppress any warnings.</br></p>\n", "LastActivityDate": "2014-11-24T16:57:29.267"}, "27109701": {"CommentCount": "10", "ViewCount": "279", "CreationDate": "2014-11-24T16:40:05.620", "LastActivityDate": "2014-12-05T03:23:25.047", "Title": "Aliasing of otherwise equivalent signed and unsigned types", "AcceptedAnswerId": "27111067", "PostTypeId": "1", "Id": "27109701", "Score": "3", "Body": "<p>The C and C++ standards both allow signed and unsigned variants of the same integer type to alias each other.  For example, <code>unsigned int*</code> and <code>int*</code> may alias.  But that's not the whole story because they clearly have a different range of representable values.  I have the following assumptions:</p>\n<ul>\n<li>If an <code>unsigned int</code> is read through an <code>int*</code>, the value must be within the range of <code>int</code> or an integer overflow occurs and the behaviour is undefined.  Is this correct?</li>\n<li>If an <code>int</code> is read through an <code>unsigned int*</code>, negative values wrap around as if they were casted to <code>unsigned int</code>.  Is this correct?</li>\n<li>If the value is within the range of both <code>int</code> and <code>unsigned int</code>, accessing it through a pointer of either type is fully defined and gives the same value.  Is this correct?</li>\n</ul>\n<p>Additionally, what about compatible but not equivalent integer types?</p>\n<ul>\n<li>On systems where <code>int</code> and <code>long</code> have the same range, alignment, etc., can <code>int*</code> and <code>long*</code> alias?  (I assume not.)</li>\n<li>Can <code>char16_t*</code> and <code>uint_least16_t*</code> alias?  I suspect this differs between C and C++.  In C, <code>char16_t</code> is a typedef for <code>uint_least16_t</code> (correct?).  In C++, <code>char16_t</code> is its own primitive type, which compatible with <code>uint_least16_t</code>.  Unlike C, C++ seems to have no exception allowing compatible but distinct types to alias.</li>\n</ul>\n", "Tags": "<c++><c><language-lawyer>", "OwnerUserId": "502399", "AnswerCount": "4"}, "27111067": {"ParentId": "27109701", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-11-24T17:51:05.187", "Score": "2", "LastEditorUserId": "1741125", "LastEditDate": "2014-12-05T03:23:25.047", "Id": "27111067", "OwnerUserId": "1741125", "Body": "<blockquote>\n<p id=\"so_27109701_27111067_0\"><em>If an <code>int</code> is read through an <code>unsigned int*</code>, negative values wrap around as if they were casted to <code>unsigned int</code>. Is this correct?</em></p>\n</blockquote>\n<p>For a system using two's complement, type-punning and signed-to-unsigned conversion are equivalent, for example:</p>\n<pre><code>int n = ...;\nunsigned u1 = (unsigned)n;\nunsigned u2 = *(unsigned *)&amp;n;\n</code></pre>\n<p>Here, both <code>u1</code> and <code>u2</code> have the same value. This is by far the most common setup (e.g. Gcc documents this behaviour for all its targets). However, the C standard also addresses machines using ones' complement or sign-magnitude to represent signed integers. In such an implementation (assuming no padding bits and no trap representations), the result of a conversion of an integer value and type-punning can yield different results. As an example, assume sign-magnitude and <code>n</code> being initialized to -1:</p>\n<pre><code>int n = -1;                     /* 10000000 00000001 assuming 16-bit integers*/\nunsigned u1 = (unsigned)n;      /* 11111111 11111111\n        effectively 2's complement, UINT_MAX */\nunsigned u2 = *(unsigned *)&amp;n;  /* 10000000 00000001\n        only reinterpreted, the value is now INT_MAX + 2u */\n</code></pre>\n<p>Conversion to an unsigned type means adding/subtracting one more than the maximum value of that type until the value is in range. Dereferencing a converted pointer simply reinterprets the bit pattern. In other words, the conversion in the initialization of <code>u1</code> is a no-op on 2's complement machines, but requires some calculations on other machines.</p>\n<blockquote>\n<p id=\"so_27109701_27111067_1\"><em>If an <code>unsigned int</code> is read through an <code>int*</code>, the value must be within the range of <code>int</code> or an integer overflow occurs and the behaviour is undefined. Is this correct?</em></p>\n</blockquote>\n<p>Not exactly. The <em>bit pattern</em> must represent a valid value in the new type, it doesn't matter if the old <em>value</em> is representable. From C11 (n1570) [omitted footnotes]:</p>\n<blockquote>\n<p id=\"so_27109701_27111067_2\"><strong>6.2.6.2 Integer types</strong></p>\n<p id=\"so_27109701_27111067_3\">For unsigned integer types other than unsigned char, the bits of the object representation shall be divided into two groups: value bits and padding bits (there need not be any of the latter). If there are <strong>N</strong> value bits, each bit shall represent a different power of <strong>2</strong> between <strong>1</strong> and <strong>2<sup>N-1</sup></strong>, so that objects of that type shall be capable of representing values from <strong>0</strong> to <strong>2<sup>N</sup>-1</strong> using a pure binary representation; this shall be known as the value representation. The values of any padding bits are unspecified.</p>\n<p id=\"so_27109701_27111067_4\">For signed integer types, the bits of the object representation shall be divided into three groups: value bits, padding bits, and the sign bit. There need not be any padding bits; <code>signed char</code> shall not have any padding bits. There shall be exactly one sign bit. Each bit that is a value bit shall have the same value as the same bit in the object representation of the corresponding unsigned type (if there are <strong>M</strong> value bits in the signed type and <strong>N</strong> in the unsigned type, then <strong>M\u2264N</strong>). If the sign bit is zero, it shall not affect the resulting value. If the sign bit is one, the value shall be modified in one of the following ways:</p>\n<ul>\n<li>the corresponding value with sign bit 0 is negated (sign and magnitude);</li>\n<li>the sign bit has the value <strong>-2<sup>M</sup></strong> (two's complement);</li>\n<li>the sign bit has the value <strong>-2<sup>M</sup>-1</strong> (ones' complement).</li>\n</ul>\n<p id=\"so_27109701_27111067_5\">Which of these applies is implementation-defined, as is whether the value with sign bit 1 and all value bits zero (for the first two), or with sign bit and all value bits 1 (for ones' complement), is a trap representation or a normal value. In the case of sign and magnitude and ones' complement, if this representation is a normal value it is called a <em>negative zero</em>.</p>\n</blockquote>\n<p>E.g., an <code>unsigned int</code> could have value bits, where the corresponding signed type (<code>int</code>) has a padding bit, something like <code>unsigned u = ...; int n = *(int *)&amp;u;</code> may result in a trap representation on such a system (reading of which is undefined behaviour), but not the other way round.</p>\n<blockquote>\n<p id=\"so_27109701_27111067_6\"><em>If the value is within the range of both <code>int</code> and <code>unsigned int</code>, accessing it through a pointer of either type is fully defined and gives the same value. Is this correct?</em></p>\n</blockquote>\n<p>I <em>think</em>, the standard would allow for one of the types to have a padding bit, which is always ignored (thus, two different bit patterns can represent the same value and that bit may be set on initialization) but be an always-trap-if-set bit for the other type. This leeway, however, is limited at least by ibid. p5:</p>\n<blockquote>\n<p id=\"so_27109701_27111067_7\">The values of any padding bits are unspecified. A valid (non-trap) object representation of a signed integer type where the sign bit is zero is a valid object representation of the corresponding unsigned type, and shall represent the same value. For any integer type, the object representation where all the bits are zero shall be a representation of the value zero in that type.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_27109701_27111067_8\"><em>On systems where <code>int</code> and <code>long</code> have the same range, alignment, etc., can <code>int*</code> and <code>long*</code> alias? (I assume not.)</em></p>\n</blockquote>\n<p>Sure they can, if you don't use them ;) But no, the following is invalid on such platforms:</p>\n<pre><code>int n = 42;\nlong l = *(long *)&amp;n; // UB\n</code></pre>\n<blockquote>\n<p id=\"so_27109701_27111067_9\"><em>Can <code>char16_t*</code> and <code>uint_least16_t*</code> alias? I suspect this differs between C and C++. In C, <code>char16_t</code> is a typedef for <code>uint_least16_t</code> (correct?). In C++, <code>char16_t</code> is its own primitive type, which compatible with uint_least16_t. Unlike C, C++ seems to have no exception allowing compatible but distinct types to alias.</em></p>\n</blockquote>\n<p>I'm not sure about C++, but at least for C, <code>char16_t</code> is a typedef, but not necessarily for <code>uint_least16_t</code>, it could very well be a typedef of some implementation-specific <code>__char16_t</code>, some type incompatible with <code>uint_least16_t</code> (or any other type).</p>\n</hr>", "LastActivityDate": "2014-12-05T03:23:25.047"}, "27110545": {"ParentId": "27109701", "PostTypeId": "2", "CommentCount": "15", "CreationDate": "2014-11-24T17:24:48.977", "Score": "4", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-24T18:27:26.663", "Id": "27110545", "OwnerUserId": "3647361", "Body": "<blockquote>\n<p id=\"so_27109701_27110545_0\">If an <code>unsigned int</code> is read through an <code>int*</code>, the value must be\n  within the range of <code>int</code> or an integer overflow occurs and the\n  behaviour is undefined. Is this correct?</p>\n</blockquote>\n<p>Why would it be undefined? there is no integer overflow since no conversion or computation is done. We take an object representation of an <code>unsigned int</code> object and see it through an <code>int</code>. In what way the value of the <code>unsigned int</code> object transposes to the value of an <code>int</code> is completely implementation defined.</p>\n<blockquote>\n<p id=\"so_27109701_27110545_1\">If an <code>int</code> is read through an <code>unsigned int*</code>, negative values wrap\n  around as if they were casted to unsigned int. Is this correct?</p>\n</blockquote>\n<p>Depends on the representation. With two's complement and equivalent padding, yes. Not with signed magnitude though - a cast from <code>int</code> to <code>unsigned</code> is always defined through a congruence:</p>\n<blockquote>\n<p id=\"so_27109701_27110545_2\">If the destination type is <code>unsigned</code>, the resulting value is the\n  least unsigned integer congruent to the source integer (modulo\n  <em>2<sup>n</sup></em> where <code>n</code> is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s complement representation, this\n  conversion is conceptual and there is no change in the bit pattern (if\n  there is no truncation). \u2014 end note ]</p>\n</blockquote>\n<p>And now consider</p>\n<pre><code>10000000 00000001  // -1 in signed magnitude for 16-bit int\n</code></pre>\n<p>This would certainly be <em>2<sup>15</sup>+1</em> if interpreted as an <code>unsigned</code>. A cast would yield <em>2<sup>16</sup>-1</em> though.</p>\n<blockquote>\n<p id=\"so_27109701_27110545_3\">If the value is within the range of both int and unsigned int,\n  accessing it through a pointer of either type is fully defined and\n  gives the same value. Is this correct?</p>\n</blockquote>\n<p>Again, with two's complement and equivalent padding, yes. With signed magnitude we might have <code>-0</code>.</p>\n<blockquote>\n<p id=\"so_27109701_27110545_4\">On systems where <code>int</code> and <code>long</code> have the same range, alignment,\n  etc., can <code>int*</code> and <code>long*</code> alias? (I assume not.)</p>\n</blockquote>\n<p>No. They are independent types.</p>\n<blockquote>\n<p id=\"so_27109701_27110545_5\">Can <code>char16_t*</code> and <code>uint_least16_t*</code> alias?</p>\n</blockquote>\n<p>Technically not, but that seems to be an unneccessary restriction of the standard.</p>\n<blockquote>\n<p id=\"so_27109701_27110545_6\">Types <code>char16_t</code> and <code>char32_t</code> denote distinct types with the same\n  size, signedness, and alignment as <code>uint_least16_t</code> and\n  <code>uint_least32_t</code>, respectively, in <code>&lt;cstdint&gt;</code>, called the underlying\n  types.</p>\n</blockquote>\n<p>So it should be practically possible without any risks (since there shouldn't be any padding).</p>\n", "LastActivityDate": "2014-11-24T18:27:26.663"}, "bq_ids": {"n4140": {"so_27109701_27110545_6": {"section_id": 7214, "quality": 1.0, "length": 17}, "so_27109701_27110545_2": {"section_id": 31, "quality": 0.90625, "length": 29}}, "n3337": {"so_27109701_27110545_6": {"section_id": 6958, "quality": 0.9411764705882353, "length": 16}, "so_27109701_27110545_2": {"section_id": 28, "quality": 0.90625, "length": 29}}, "n4659": {"so_27109701_27110545_6": {"section_id": 8723, "quality": 1.0, "length": 17}, "so_27109701_27110545_2": {"section_id": 31, "quality": 0.90625, "length": 29}}}, "27112617": {"ParentId": "27109701", "CommentCount": "0", "CreationDate": "2014-11-24T19:27:01.107", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "27112617", "Score": "0", "Body": "<p>Concerning your questions regarding <code>unsigned int*</code> and <code>int*</code>: if the\nvalue in the actual type doesn't fit in the type you're reading, the\nbehavior is undefined, simply because the standard neglects to define\nany behavior in this case, and any time the standard fails to define\nbehavior, the behavior is undefined.  In practice, you'll almost always\nobtain a value (no signals or anything), but the value <em>will</em> vary\ndepending on the machine: a machine with signed magnitude or 1's\ncomplement, for example, will result in different values (both ways)\nfrom the usual 2's complement.</p>\n<p>For the rest, <code>int</code> and <code>long</code> are different types, regardless of their\nrepresentations, and <code>int*</code> and <code>long*</code> cannot alias.  Similarly, as you\nsay, in C++, <code>char16_t</code> is a distinct type in C++, but a typedef in\nC (so the rules concerning aliasing are different).</p>\n", "LastActivityDate": "2014-11-24T19:27:01.107"}});