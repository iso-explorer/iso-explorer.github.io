post_cb({"bq_ids": {"n4140": {"so_3657494_3657647_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6669}}, "n3337": {"so_3657494_3657647_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6424}}, "n4659": {"so_3657494_3657647_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 8144}}}, "3658352": {"Id": "3658352", "PostTypeId": "2", "Body": "<p>Chubsdad's answer clarifies your question of why there's an error for the template specialization.</p>\n<p>Now the following C++ standard rule</p>\n<p>14.7.2/11 <strong>The usual access checking rules do not apply to names used to specify explicit<br>\ninstantiations</br></strong>. [Note: In particular, the template arguments and names used in the function<br>\ndeclarator (including parameter types, return types and exception specifications) may be<br>\nprivate types or objects which would normally not be accessible and the template may be a<br>\nmember template or member function which would not normally be accessible. \u2014   endnote]</br></br></br></p>\n<p>would explain why the generic template instantiation wouldn't throw an error. It will not throw even if you have private access specifier.</p>\n", "LastActivityDate": "2010-09-07T11:45:57.747", "CommentCount": "0", "CreationDate": "2010-09-07T11:45:57.747", "ParentId": "3657494", "Score": "0", "OwnerUserId": "433874"}, "3657536": {"Id": "3657536", "PostTypeId": "2", "Body": "<p>I don't think this is anything to do with templates.  Your example code can be reduced to this, and it still gives the equivalent error:</p>\n<pre><code>class A\n{\n    protected:\n        typedef void (A::*type)() const;\n        void foo() const {}\n};\n\n\nclass B : public A\n{\n    public:\n        operator type() const\n        {\n            return &amp;A::foo;\n        }\n};\n</code></pre>\n<p><s>I believe the issue is you can't return member-function pointers to protected members in the public interface.</s> (<strong>Edit: not true...</strong>)</p>\n", "LastEditorUserId": "129570", "LastActivityDate": "2010-09-07T10:06:32.790", "Score": "1", "CreationDate": "2010-09-07T09:49:25.677", "ParentId": "3657494", "CommentCount": "5", "OwnerUserId": "129570", "LastEditDate": "2010-09-07T10:06:32.790"}, "3657647": {"Id": "3657647", "PostTypeId": "2", "Body": "<p>This should probably help (reproducible in a non template situation also)</p>\n<pre><code>struct A{\nprotected:\n    void f(){}\n};\n\nstruct B : A{\n    void g(){&amp;A::f;}        // error, due to Standard rule quoted below\n};\n\nint main(){\n}\n</code></pre>\n<blockquote>\n<p id=\"so_3657494_3657647_0\">VS gives \"'A::f' : cannot access\n  protected member declared in class\n  'A'\"</p>\n</blockquote>\n<p>For the same code, Comeau gives</p>\n<blockquote>\n<p id=\"so_3657494_3657647_1\">\"ComeauTest.c\", line 7: error:\n  protected function \"A::f\" (declared at\n  line 3) is\n            not accessible through a \"A\" pointer or object      void g(){&amp;A::f;}\n                 ^</p>\n<p id=\"so_3657494_3657647_2\">\"ComeauTest.c\", line 7: warning:\n  expression has no effect      void\n  g(){&amp;A::f;}</p>\n</blockquote>\n<p>Here is the fixed code which achieves the desired intentions</p>\n<pre><code>struct A{\nprotected:\n    void f(){}\n};\n\nstruct B : A{\n    void g(){&amp;B::f;}        // works now\n};\n\nint main(){\n}\n</code></pre>\n<p>So, why does the first code snippet not work?</p>\n<p>This is because of the following rule in the C++ Standard03</p>\n<blockquote>\n<p id=\"so_3657494_3657647_3\">11.5/1- \"When a friend or a member function of a derived class references\n  a protected nonstatic member function\n  or protected nonstatic data member of\n  a base class, an access check applies\n  in addition to those described earlier\n  in clause 11.102) Except when forming\n  a pointer to member (5.3.1), the\n  access must be through a pointer to,\n  reference to, or object of the\n  derived class itself (or any class\n  derived from that class) (5.2.5). <strong>If\n  the access is to form a pointer to\n  member, the nested-name-specifier\n  shall name the derived class (or any\n  class derived from that class).</strong></p>\n</blockquote>\n<p>So change the return within operator functions as follows</p>\n<pre><code>return (boolean_test() == true) ? &amp;safe_bool&lt;void&gt;::this_type_does_not_support_comparisons : 0; //46 \n\nreturn (static_cast&lt;const T*&gt;(this))-&gt;boolean_test() ? &amp;typename safe_bool&lt;T&gt;::this_type_does_not_support_comparisons : 0; \n</code></pre>\n<p>EDIT 2: Please ignore my explanations. David is right. Here is what it boils down to.</p>\n<pre><code>struct A{\nprotected:\n    int x;\n};\n\nstruct B : A{\n    void f();\n};\n\nstruct C : B{};\n\nstruct D: A{            // not from 'C'\n};\n\nvoid B::f(){\n    x = 2;         // it's own 'A' subobjects 'x'. Well-formed\n\n    B b;\n    b.x = 2;       // access through B, well-formed\n\n    C c;\n    c.x = 2;       // access in 'B' using 'C' which is derived from 'B', well-formed.\n\n    D d;\n    d.x = 2;       // ill-formed. 'B' and 'D' unrelated even though 'A' is a common base\n}\n\nint main(){} \n</code></pre>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-09-07T11:23:36.880", "Score": "9", "CreationDate": "2010-09-07T10:07:08.187", "ParentId": "3657494", "CommentCount": "11", "OwnerUserId": "418110", "LastEditDate": "2010-09-07T11:23:36.880"}, "3657494": {"ViewCount": "905", "Body": "<p>Could someone explain me why this code:</p>\n<pre><code>class safe_bool_base\n{ //13\n    protected:\n\n        typedef void (safe_bool_base::*bool_type)() const;\n\n        void this_type_does_not_support_comparisons() const {} //18\n\n        safe_bool_base() {}\n        safe_bool_base(const safe_bool_base&amp;) {}\n        safe_bool_base&amp; operator=(const safe_bool_base&amp;) { return *this; }\n        ~safe_bool_base() {}\n};\n\ntemplate &lt;typename T=void&gt; class safe_bool : public safe_bool_base\n{\n    public:\n\n        operator bool_type() const\n        {\n            return (static_cast&lt;const T*&gt;(this))-&gt;boolean_test() ? &amp;safe_bool_base::this_type_does_not_support_comparisons : 0;\n        }\n\n    protected:\n\n        ~safe_bool() {}\n};\n\ntemplate &lt;&gt; class safe_bool&lt;void&gt; : public safe_bool_base\n{\n    public:\n\n        operator bool_type() const\n        {\n            return (boolean_test() == true) ? &amp;safe_bool_base::this_type_does_not_support_comparisons : 0; //46\n        }\n\n    protected:\n\n        virtual bool boolean_test() const = 0;\n        virtual ~safe_bool() {}\n};\n</code></pre>\n<p>Produces the following compiler error ?</p>\n<pre><code>c:\\project\\include\\safe_bool.hpp(46) : error C2248: 'safe_bool_base::this_type_does_not_support_comparisons' : cannot access protected member declared in class 'safe_bool_base'\nc:\\project\\include\\safe_bool.hpp(18) : see declaration of 'safe_bool_base::this_type_does_not_support_comparisons'\nc:\\project\\include\\safe_bool.hpp(13) : see declaration of 'safe_bool_base'\n</code></pre>\n<p>Since both <code>safe_bool</code> templates derive from <code>safe_bool_base</code>, I don't understand why one can't access a protected member of the base class.</p>\n<p>Am I missing something ?</p>\n", "AcceptedAnswerId": "3657647", "Title": "Weird compiler error and template inheritance", "CreationDate": "2010-09-07T09:41:25.720", "Id": "3657494", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-09-07T11:36:31.857", "LastEditorUserId": "279259", "LastActivityDate": "2010-09-07T11:45:57.747", "Score": "5", "OwnerUserId": "279259", "Tags": "<c++><templates><protected><derived><safe-bool-idiom>", "AnswerCount": "3"}});