post_cb({"28308012": {"ParentId": "28307887", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-02-03T20:20:30.577", "Score": "1", "LastEditorUserId": "3647361", "LastEditDate": "2015-02-03T20:25:51.457", "Id": "28308012", "OwnerUserId": "3647361", "Body": "<p>[over.match.conv]/(1.1):</p>\n<blockquote>\n<p id=\"so_28307887_28308012_0\">The conversion functions of <code>S</code> and its base classes are considered.\n  Those non-explicit conversion functions that are not hidden within <code>S</code>\n  and yield type <code>T</code> <strong>or a type that can be converted to type <code>T</code> via a\n  standard conversion sequence (13.3.3.1.1)</strong> are candidate functions.</p>\n</blockquote>\n<p>There is no standard conversion sequence from an integral type to <code>void*</code><sup>1</sup>, thus the conversion operator is not a candidate.</p>\n<p>You can try a conversion operator template:</p>\n<pre><code>template &lt;typename T&gt;\noperator T()\n{\n    return T(state);\n}\n</code></pre>\n<hr>\n<p><sup>1</sup> An integer literal with value zero is the exception.</p>\n</hr>", "LastActivityDate": "2015-02-03T20:25:51.457"}, "28308203": {"ParentId": "28307887", "CommentCount": "2", "CreationDate": "2015-02-03T20:32:25.400", "OwnerUserId": "2682312", "PostTypeId": "2", "Id": "28308203", "Score": "1", "Body": "<p>Since <code>(void *)x1</code> effectively gives you the address of <code>x1.state</code> \nyou could simply implement a <code>void *</code> cast operator.</p>\n<p>Like so:</p>\n<pre><code>operator void *()\n{\n    return &amp;state;\n}\n</code></pre>\n<p>The drawback of this is that you can now convert <code>my_wrapper</code> to <code>void *</code> <strong>implicitly</strong> as well.</p>\n<p>Luckily, you can prevent this in <strong>C++11</strong> by using the <code>explicit</code> specifier:</p>\n<pre><code>explicit operator void *()\n{\n    return &amp;state;\n}\n</code></pre>\n", "LastActivityDate": "2015-02-03T20:32:25.400"}, "28307887": {"CommentCount": "3", "ViewCount": "4142", "PostTypeId": "1", "LastEditorUserId": "4505446", "CreationDate": "2015-02-03T20:13:46.477", "LastActivityDate": "2017-08-13T19:36:51.007", "Title": "c++ type cast operator overloading and implicit conversions", "LastEditDate": "2017-08-13T19:36:51.007", "Id": "28307887", "Score": "3", "Body": "<p>if I'm overloading the type cast operator, I'm running into compile errors when an implicit conversion is needed and one can't be found. Consider the simple example where I have a wrapper class that contains a type (in this case a long long):</p>\n<pre><code>class my_wrapper\n{\n    long long state;\n\npublic:\n    my_wrapper(long long _in) : state(_in) {}\n\n    my_wrapper&amp; operator=(const long long rhs)\n    {\n        state = rhs;\n        return *this;\n    }\n\n    operator long long()\n    {\n        return state;\n    }\n};\n</code></pre>\n<p>The question now is that if I want to cast in code to something else (eg a void* ... assume that I'm on 64bit for this) the following does not work without specifying two casts:</p>\n<pre><code>my_wrapper x1 = my_wrapper(5ll);\nvoid* i1 = (void *) x1; // Compile Error: no suitable conversion function exists\nvoid* i1 = (void *) (long long) x1; // Works\n</code></pre>\n<p>vs. if I had written something like:</p>\n<pre><code>long long i1 = 5ll;\nvoid* i2 = (void *) i1; // Works\n</code></pre>\n<p>Not a big deal, but just curious if its possible to specify that the \"operator long long()\" should be used as the default if there is no other conversion.</p>\n", "Tags": "<c++><casting><overloading>", "OwnerUserId": "3799309", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28307887_28308012_0": {"section_id": 595, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_28307887_28308012_0": {"section_id": 585, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_28307887_28308012_0": {"section_id": 618, "quality": 0.9166666666666666, "length": 22}}}});