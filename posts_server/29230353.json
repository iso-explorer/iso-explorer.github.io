post_cb({"29232857": {"ParentId": "29230353", "CommentCount": "4", "Body": "<p>Variable template specializations are static variables as stated by [temp.inst]/12:</p>\n<blockquote>\n<p id=\"so_29230353_29232857_0\">Implicitly instantiated class, function, and variable template specializations are placed in the namespace where the template is defined.</p>\n</blockquote>\n<p>Therefore, usual static initialization rules apply, which means that all specializations are initialized before <code>main()</code> executes.</p>\n", "OwnerUserId": "3959454", "PostTypeId": "2", "Id": "29232857", "Score": "1", "CreationDate": "2015-03-24T12:38:08.197", "LastActivityDate": "2015-03-24T12:38:08.197"}, "29236437": {"ParentId": "29230353", "CommentCount": "2", "Body": "<p>The section of the standard you quote describes <strong>block-scope</strong> variables with static storage duration, e.g:</p>\n<pre><code>int foo() {\n  static int bar = 42;\n  return bar;\n}\n</code></pre>\n<p>of which your program has none. All of your variables with static storage duration are declared at namespace scope, so you need to be looking at [basic.start.init] (3.6.2). Specifically paragraph two which states:</p>\n<blockquote>\n<p id=\"so_29230353_29236437_0\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n<p id=\"so_29230353_29236437_1\">...</p>\n<p id=\"so_29230353_29236437_2\">Dynamic initialization of a non-local variable with static storage duration is <em>unordered</em> if the variable is an implicitly or explicitly instantiated specialization, and otherwise is <em>ordered</em> [ <em>Note:</em> an explicitly specialized\n  static data member or variable template specialization has ordered initialization. \u2014<em>end note</em> ] Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their\n  definitions in the translation unit. If a program starts a thread (30.3), the subsequent initialization of a variable is unsequenced with respect to the initialization of a variable defined in a different translation unit. Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of a variable defined in a different translation unit. If a program starts a thread, the subsequent unordered initialization of a variable is unsequenced with respect to every other dynamic initialization. Otherwise,\n  the unordered initialization of a variable is indeterminately sequenced with respect to every other dynamic initialization.</p>\n</blockquote>\n<p>In the question's program, all the <code>squealer</code> instances with static storage duration must be dynamically initialized since <code>squealer</code> has a member <code>std::string</code> that cannot be constant-initialized. <code>::s</code> has ordered initialization, and all of the instances of <code>test</code> have unordered initialization since each is an \"implicitly or explicitly instantiated specialization\" of the template <code>test</code>. The <code>test</code> instances are guaranteed to be initialized before entering <code>main</code>, but otherwise all bets are off: they may be initialized in any order, possibly before and/or after initialization of <code>::s</code> and more importantly <code>std::cout</code>. Those initializations are notably <em>not</em> thread-safe: \"If a program starts a thread, the subsequent unordered initialization of a variable is unsequenced with respect to every other dynamic initialization.\"</p>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "29236437", "Score": "1", "CreationDate": "2015-03-24T15:20:16.843", "LastActivityDate": "2015-03-24T15:20:16.843"}, "bq_ids": {"n4140": {"so_29230353_29236437_0": {"section_id": 7151, "quality": 0.8666666666666667, "length": 13}, "so_29230353_29232857_0": {"section_id": 244, "quality": 1.0, "length": 12}, "so_29230353_29236437_2": {"section_id": 7151, "quality": 0.8131868131868132, "length": 74}, "so_29230353_29230353_0": {"section_id": 3919, "quality": 0.9861111111111112, "length": 71}}, "n3337": {"so_29230353_29236437_0": {"section_id": 6895, "quality": 0.8666666666666667, "length": 13}, "so_29230353_29232857_0": {"section_id": 236, "quality": 0.8333333333333334, "length": 10}, "so_29230353_29236437_2": {"section_id": 6895, "quality": 0.8131868131868132, "length": 74}, "so_29230353_29230353_0": {"section_id": 3779, "quality": 0.9861111111111112, "length": 71}}, "n4659": {"so_29230353_29236437_0": {"section_id": 4051, "quality": 0.6, "length": 9}, "so_29230353_29230353_0": {"section_id": 4805, "quality": 0.6805555555555556, "length": 49}, "so_29230353_29232857_0": {"section_id": 251, "quality": 1.0, "length": 12}}}, "29230353": {"CommentCount": "3", "AcceptedAnswerId": "29236437", "PostTypeId": "1", "LastEditorUserId": "2680216", "CreationDate": "2015-03-24T10:37:04.620", "LastActivityDate": "2015-12-11T00:32:50.470", "LastEditDate": "2015-12-11T00:32:50.470", "ViewCount": "261", "FavoriteCount": "1", "Title": "Are template variables thread safe? they're placed on data segment?", "Id": "29230353", "Score": "4", "Body": "<p>I'm playing with the new template variables feature from C++14 in order to get used to it (maybe is soon to do this 'cause it seems that some compilers didn't implement it completely).</p>\n<p>Now I'm wondering where lies each instance of a template variable. In the tests I did so far they seem to be initialized before any static data so I'm wondering if they're placed in the <a href=\"http://en.wikipedia.org/wiki/Data_segment\" rel=\"nofollow\">data segment</a> of the program. Let's see what I've tryed so far, I have a class which prints information on construction and destruction:</p>\n<pre><code>struct squealer\n{\n    squealer(std::string a_name) : m_name(a_name) { std::cout &lt;&lt; this &lt;&lt; ' ' &lt;&lt; m_name &lt;&lt; ' ' &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n    ~squealer() { std::cout &lt;&lt; this &lt;&lt; ' ' &lt;&lt; m_name &lt;&lt; ' ' &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n'; }\n    void f() {}\n    const std::string m_name;\n};\n</code></pre>\n<p>And a program which instances some <code>squealer</code>s in local storage, static storage and as template variables, this is the program:</p>\n<pre><code>// static storage squealer\nsquealer s(\"\\\"static\\\"\");\n\n// template variable squealer\ntemplate &lt;int i&gt; squealer test(std::string(i, 'A'));\n\n// function using a template variable squealer\nvoid f() { test&lt;1&gt;.f(); }\n\nint main(int argc, char **argv)\n{\n    // local storage squealer\n    squealer ss(\"local\");\n\n    // using another template variable squealers\n    test&lt;2&gt;.f();\n    switch (argc)\n    {\n        case 1: test&lt;3&gt;.f(); break;\n        case 2: test&lt;4&gt;.f(); break;\n        case 3: test&lt;5&gt;.f(); break;\n        case 4: test&lt;6&gt;.f(); break;\n    }\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://melpon.org/wandbox/permlink/ExfTbYO2PjNAyGG4\" rel=\"nofollow\">Here is the program</a> and this is the output:</p>\n<pre><code>A squealer::squealer(std::string)\nAA squealer::squealer(std::string)\nAAA squealer::squealer(std::string)\nAAAA squealer::squealer(std::string)\nAAAAA squealer::squealer(std::string)\nAAAAAA squealer::squealer(std::string)\n\"static\" squealer::squealer(std::string)\nlocal squealer::squealer(std::string)\nlocal squealer::~squealer()\n\"static\" squealer::~squealer()\nAAAAAA squealer::~squealer()\nAAAAA squealer::~squealer()\nAAAA squealer::~squealer()\nAAA squealer::~squealer()\nAA squealer::~squealer()\nA squealer::~squealer()\n</code></pre>\n<p>As we can see, all the template variables <code>squealer</code> instances are created before the one named <code>\"static\"</code> and at the end (as expected) the one named <code>local</code> is created, the destruction order is the opposite (as expected too), so: the order of creation/initialization of template variables instances is the same of its appearance on the code regardless of the locality of this appearance and regardless of they're used or not (the <code>f()</code> function is never called).</p>\n<p>So the first question is, are this template variables placed on the data segment? I don't know how to test or check it.</p>\n<p>The second question is, are all of this template variables <code>squealer</code> instances thread safe? I've readed on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">n3376 \u00a76.7</a> the following sentence (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29230353_29230353_0\">An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope (3.6.2). <strong>Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization</strong>. If the initialization exits by throwing an exception, the initialization is not complete, so it will be tried again the next time control enters the declaration. <strong>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization</strong>.</p>\n</blockquote>\n<p>From C++11 if all of the template variable <code>squealer</code> instances are in static storage they should be thread safe, isn't it?</p>\n<p>Thanks.</p>\n", "Tags": "<c++11><thread-safety><c++14><data-segment><variable-templates>", "OwnerUserId": "499359", "AnswerCount": "2"}});