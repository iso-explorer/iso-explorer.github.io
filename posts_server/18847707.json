post_cb({"bq_ids": {"n4140": {"so_18847707_18855798_0": {"section_id": 5862, "quality": 0.9722222222222222, "length": 35}}, "n3337": {"so_18847707_18855798_0": {"section_id": 5632, "quality": 0.9722222222222222, "length": 35}}, "n4659": {"so_18847707_18855798_0": {"section_id": 7345, "quality": 0.8333333333333334, "length": 30}}}, "18847707": {"CommentCount": "6", "AcceptedAnswerId": "18855798", "ClosedDate": "2013-09-18T11:18:23.220", "CreationDate": "2013-09-17T10:43:25.210", "LastActivityDate": "2013-09-17T17:06:38.197", "PostTypeId": "1", "ViewCount": "2379", "FavoriteCount": "2", "Title": "constexpr with std::array - \"Non-type template argument is not a constant expression\"", "Id": "18847707", "Score": "8", "Body": "<p>I'm trying to implement the following:</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;cstdint&gt;\n\nclass Class2\n{\n};\n\nclass Class1\n{\npublic:\n    static constexpr uint8_t GetMax() { return 5; }\n    static constexpr uint8_t GetMin() { return 0; }\n    static constexpr uint8_t GetCount() { return GetMax() - GetMin() + 1; }\n\nprivate:\n    std::array&lt;Class2, Class1::GetCount()&gt; m_classes;\n};\n</code></pre>\n<p>But I can't get it to work because of the error:</p>\n<p><strong>Non-type template argument is not a constant expression</strong></p>\n<p>I'm using Xcode 5.0. Any ideas?</p>\n", "Tags": "<c++><templates><c++11><clang><constexpr>", "OwnerUserId": "986", "AnswerCount": "2"}, "18855798": {"ParentId": "18847707", "CommentCount": "1", "Body": "<p>The problem that we have here is indirectly described in 3.3.7 - Class scope:</p>\n<pre><code>typedef int c;\nenum { i = 1 };\n\nclass X {\n    char v[i]; // error: i refers to ::i\n               // but when reevaluated is X::i\n    int f() { return sizeof(c); } // OK: X::c\n    char c;\n    enum { i = 2 };\n};\n</code></pre>\n<p>This paragraph should describe this a little bit more (9.2.2):</p>\n<blockquote>\n<p id=\"so_18847707_18855798_0\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing } of the class-specifier.Within the class member-specification, the class is regarded as complete within function bodies, default arguments, exception-specifications, and brace-or-equal-initializers for non-static data members (including such things in nested classes). <strong>Otherwise it is regarded as incomplete within its own class member-specification.</strong></p>\n</blockquote>\n<p>As <code>std::array&lt;Class2, Class1::GetCount()&gt;</code> is neither of the <em>functions bodies, default arguemnts, exception-specification, brace-or-equal</em> initializers, at that point, class is considered incomplete, so I think it's up to the compiler to decide whenever it will allow this, or not - but not compiling the code is OK by the standard.</p>\n<p>Only solutions that I can think of is the one you suggested, or moving constexprs into another (possible base) class.</p>\n", "OwnerUserId": "133707", "PostTypeId": "2", "Id": "18855798", "Score": "2", "CreationDate": "2013-09-17T17:06:38.197", "LastActivityDate": "2013-09-17T17:06:38.197"}, "18850349": {"ParentId": "18847707", "CommentCount": "0", "Body": "<p>Following Nemanja Boric's answer, I converted the static methods into static members. This isn't the fix I wanted, but it works. I suppose the remaining question is <em>why</em> didn't it work?</p>\n<pre><code>#include &lt;array&gt;\n#include &lt;cstdint&gt;\n\nclass Class2\n{\n};\n\nclass Class1\n{\npublic:\n    static constexpr uint8_t Max = 5;\n    static constexpr uint8_t Min = 0;\n    static constexpr uint8_t Count = Max - Min + 1;\n\nprivate:\n    std::array&lt;Class2, Class1::Count&gt; m_classes;\n};\n</code></pre>\n", "OwnerUserId": "986", "PostTypeId": "2", "Id": "18850349", "Score": "2", "CreationDate": "2013-09-17T12:49:26.607", "LastActivityDate": "2013-09-17T12:49:26.607"}});