post_cb({"5297763": {"CommentCount": "2", "AcceptedAnswerId": "5297898", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2011-03-14T11:09:39.957", "LastActivityDate": "2011-03-14T20:21:28.757", "LastEditDate": "2011-03-14T11:34:37.703", "ViewCount": "1290", "FavoriteCount": "1", "Title": "GCC's two unusual error messages", "Id": "5297763", "Score": "3", "Body": "<p>Today, I came across two error messages which I never seen before. It's completely new to me.</p>\n<p>Here is the code:</p>\n<pre><code>template&lt;typename T&gt;\nstruct adder { adder(const T &amp;item) { } };\n\ntemplate&lt;typename T&gt;\nvoid initializer(const T &amp;item) {  adder&lt;T&gt;(item); }\n\nint main() \n{\n   initializer(\"const string literal\");\n}\n</code></pre>\n<p>On compiling, GCC gives these errors:</p>\n<blockquote>\n<p id=\"so_5297763_5297763_0\">prog.cpp: In function \u2018void initializer(const T&amp;)\u2019:<br>\n<strong>prog.cpp:6: error: declaration of \u2018adder&lt;T&gt; item\u2019 shadows a parameter</strong><br>\n  prog.cpp: In function \u2018void initializer(const T&amp;) [with T = char [21]]\u2019:<br>\n  prog.cpp:10:   instantiated from here<br>\n<strong>prog.cpp:6: error: declaration of \u2018adder&lt;char [21]&gt; item\u2019 shadows a parameter</strong><br>\n<strong>prog.cpp:6: error: no matching function for call to \u2018adder&lt;char [21]&gt;::adder()\u2019</strong><br>\n  prog.cpp:3: note: candidates are: adder&lt;T&gt;::adder(const T&amp;) [with T = char [21]]<br>\n  prog.cpp:3: note:                 adder&lt;char [21]&gt;::adder(const adder&lt;char [21]&gt;&amp;)   </br></br></br></br></br></br></br></p>\n</blockquote>\n<hr>\n<p>See the bold text. One error is shown <strong>twice</strong>, which is this</p>\n<blockquote>\n<p id=\"so_5297763_5297763_1\">error: declaration of \u2018<strong>adder&lt;T&gt; item</strong>\u2019 shadows a parameter<br>\n  error: declaration of <strong>\u2018adder&lt;char [21]&gt; item</strong>\u2019 shadows a parameter</br></p>\n</blockquote>\n<p>What does it mean? Why does it show <em>twice</em> with different template arguments? First one with <code>T</code>, second one with <code>char [21]</code>? </p>\n<p>EDIT: does <code>adder&lt;T&gt;(item)</code> declare variable with name <em>item</em>? But that is not what I intended. I think it should create a temporary object passing <em>item</em> as argument to the constructor. </p>\n<p><strong>I would like to know the section from the Standard which deals with this issue!</strong></p>\n<hr>\n<p>Other interesting error is this:</p>\n<blockquote>\n<p id=\"so_5297763_5297763_2\">error: no matching function for call to \u2018adder&lt;char [21]&gt;::adder()\u2019</p>\n</blockquote>\n<p>Which indicates that the compiler is looking for <strong>default constructor</strong>? But I'm wondering why is the compiler looking for it when in fact my code doesn't use it <strong>at line 6</strong>?</p>\n<hr>\n<p>Code at ideone : <a href=\"http://www.ideone.com/jrdLL\" rel=\"nofollow\">http://www.ideone.com/jrdLL</a></p>\n</hr></hr></hr>", "Tags": "<c++><gcc><diagnostics>", "OwnerUserId": "415784", "AnswerCount": "4"}, "5297843": {"ParentId": "5297763", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_5297763_5297843_0\">Which indicates that the compiler is looking for default constructor? But I'm wondering why is the compiler looking for it when in fact my code doesn't use it at line 6?</p>\n</blockquote>\n<p>Because compiler think that you declare local variable with name item.</p>\n<p><a href=\"http://codepad.org/YBPKCvmm\" rel=\"nofollow\">http://codepad.org/YBPKCvmm</a></p>\n", "OwnerUserId": "622651", "PostTypeId": "2", "Id": "5297843", "Score": "4", "CreationDate": "2011-03-14T11:17:30.463", "LastActivityDate": "2011-03-14T11:17:30.463"}, "5297898": {"ParentId": "5297763", "CommentCount": "4", "Body": "<p>The key to understanding what is happening is to realize that:\n    adder(item);\nis a definition of a local variable named item and having type\nadder; the parentheses are superfluous, but perfectly\npermissable.  If you want to call the constructor, you'll have\nto disambiguate, by writing it in some way that cannot be\ninterpreted as a data definition, say:\n    adder((item));\n(I'm not sure what use this may be.  It constructs a temporary\nobject of adder, then destructs it at the end of the\nexpression.)</p>\n<p>The actual error messages should be clear(er) once the statement\nis understood as a data declaration: function parameters are\ntreated as if they were defined in the top level block of the\nfunction, so adder(item) is a duplicate (and contradictory)\ndefinition, and adder doesn't have a default constructor, so\nyou can't define an instance of it without providing arguments.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "5297898", "Score": "3", "CreationDate": "2011-03-14T11:23:52.933", "LastActivityDate": "2011-03-14T11:23:52.933"}, "5297853": {"ParentId": "5297763", "CommentCount": "3", "Body": "<p>\"shadowing\" means that two objects have the same name, which the language allows at this point, but might not be intended.</p>\n", "OwnerUserId": "613064", "PostTypeId": "2", "Id": "5297853", "Score": "1", "CreationDate": "2011-03-14T11:18:12.193", "LastActivityDate": "2011-03-14T11:18:12.193"}, "bq_ids": {"n4140": {"so_5297763_5300674_1": {"section_id": 3201, "quality": 1.0, "length": 6}, "so_5297763_5300674_0": {"section_id": 3921, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_5297763_5300674_1": {"section_id": 3075, "quality": 1.0, "length": 6}, "so_5297763_5300674_0": {"section_id": 3781, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_5297763_5300674_1": {"section_id": 3962, "quality": 1.0, "length": 6}, "so_5297763_5300674_0": {"section_id": 4807, "quality": 0.9615384615384616, "length": 25}}}, "5300674": {"ParentId": "5297763", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I only have access to the C++0x draft at the moment, so I can't give you the current chapter and verse, but I don't think much has changed.\nIn 0x it's in section 6.8 - Ambiguity Resolution:</p>\n<blockquote>\n<p id=\"so_5297763_5300674_0\">There is an ambiguity in the grammar\n  involving expression-statements and\n  declarations: An expression-statement\n  with a function-style explicit type\n  conversion (5.2.3) as its leftmost\n  subexpression can be indistinguishable\n  from a declaration where the first\n  declarator starts with a (. In those\n  cases the statement is a declaration.</p>\n</blockquote>\n<p>[...]</p>\n<pre><code>T(a); // declaration\n</code></pre>\n<p>That is, a declaration of a variable named \"a\" of type T.  </p>\n<p>If your <code>adder&lt;T&gt;(item)</code> were to define a temporary (un-named) object, it would be an expression-statement, but if something can be parsed as either a declaration-statement or an expression-statement, C++ parses it as a declaration-statement.</p>\n<blockquote>\n<p id=\"so_5297763_5300674_1\">[...] the resolution is to consider any\n  construct that could possibly be a\n  declaration a declaration.\n  (8.2)</p>\n</blockquote>\n<p>In other words, it's a cousin to everyone's dear old friend, the Most Vexing Parse.</p>\n<p><em>Update:</em>\nI looked at ambiguity resolution in C++03, and those passages are identical.</p>\n", "OwnerUserId": "404970", "LastEditorUserId": "404970", "LastEditDate": "2011-03-14T20:21:28.757", "Id": "5300674", "Score": "3", "CreationDate": "2011-03-14T15:24:52.887", "LastActivityDate": "2011-03-14T20:21:28.757"}});