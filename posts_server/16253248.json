post_cb({"bq_ids": {"n4140": {"so_16253248_16253369_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5988}}, "n3337": {"so_16253248_16253369_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5756}}, "n4659": {"so_16253248_16253369_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 7488}}}, "16253248": {"ViewCount": "324", "Body": "<p>I need to call a function from \"declaration\" type on some object from outside the class. I did a small code sample and put as comments the desired behavior as I don't know exactly how to ask this:)</p>\n<pre><code>template&lt;typename T&gt;\nvoid hun(T* obj, class C* c)\n{\n    //do some checking on c\n    if(some conditions from c are true)\n    {\n        //call fun from T ignoring it's virtual\n    }\n}\n\nstruct A\n{\n    virtual void fun(){};\n    virtual void gun(class C* c)\n    {\n        //do something specific to A\n        hun(this, c); //here call fun from A even if real type of this is B\n    };\n}\n\nstruct B : public A\n{\n    void fun(){};\n    void gun(class C* c)\n    {\n        //do something specific to B\n        hun(this, c);//here call fun from B even if real type of this is something derived from B\n    };\n}\n</code></pre>\n<p>Is it possible to achieve this behavior? </p>\n<p>I know I can call <code>fun()</code> from inside the class using <code>A::fun()</code> or <code>B::fun()</code>, but the checking from <code>hun()</code> is common for all classes and I don't want to pollute <code>gun()</code> with this code.</p>\n", "AcceptedAnswerId": "16253369", "Title": "Call Virtual Function for Specific Class on Object in C++", "CreationDate": "2013-04-27T14:29:34.703", "Id": "16253248", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-27T14:51:37.667", "Score": "4", "OwnerUserId": "336578", "Tags": "<c++>", "AnswerCount": "1"}, "16253369": {"Id": "16253369", "PostTypeId": "2", "Body": "<p>(This has probably been already answered somewhere else..)</p>\n<p>You can explicitly call one override of a virtual function using a qualified-id. A qualified-id for a member function is of the form <code>my_class::my_function</code>.</p>\n<p>For reference, see C++ Standard [expr.call]/1:</p>\n<blockquote>\n<p id=\"so_16253248_16253369_0\">If the selected function is non-virtual, or if the id-expression in the class\n  member access expression is a qualified-id, that function is called. Otherwise, its final overrider (10.3) in the\n  dynamic type of the object expression is called.</p>\n</blockquote>\n<p>Example</p>\n<pre><code>template&lt;typename T&gt;\nvoid hun(T* obj, class C* c)\n{\n    //do some checking on c\n    if(some conditions from c are true)\n    {\n        //call fun from T ignoring it's virtual\n        obj-&gt;T::fun(); // T::fun is a qualified-id\n    }\n}\n\nstruct A\n{\n    virtual void fun(){};\n    virtual void gun(class C* c)\n    {\n        //do something specific to A\n        hun(this, c); //here call fun from A even if real type of this is B\n    };\n}; // note: semicolon was missing\n\nstruct B : public A\n{\n    void fun(){};\n    void gun(class C* c)\n    {\n        //do something specific to B\n        hun(this, c);//here call fun from B even if real type of this is something derived from B\n    };\n};\n</code></pre>\n", "LastActivityDate": "2013-04-27T14:40:15.833", "CommentCount": "4", "CreationDate": "2013-04-27T14:40:15.833", "ParentId": "16253248", "Score": "8", "OwnerUserId": "420683"}});