post_cb({"13984169": {"ParentId": "13983984", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>From the C++11 spec:</p>\n<blockquote>\n<p id=\"so_13983984_13984169_0\"><strong>30.3.1.3</strong> thread destructor [thread.thread.destr] ~thread();</p>\n<p id=\"so_13983984_13984169_1\">If joinable(), calls std::terminate(). Otherwise, has no effects.</p>\n<p id=\"so_13983984_13984169_2\">[ Note: Either implicitly detaching or joining a joinable() thread in its destructor could result in difficult to debug correctness (for detach) or performance (for join) bugs encountered only when an exception is raised. Thus the pro grammer must ensure that the destructor is never executed while the thread is still joinable. \u2014 end note ]</p>\n</blockquote>\n<p>So calling a <code>thread destructor</code> without first calling <code>join</code> (to wait for it to finish) or <code>detach</code> is guarenteed to immediately call <code>std::terminate</code> and end the program.</p>\n", "OwnerUserId": "16406", "LastEditorUserId": "2299414", "LastEditDate": "2014-09-11T13:45:38.680", "Id": "13984169", "Score": "11", "CreationDate": "2012-12-21T04:12:50.573", "LastActivityDate": "2014-09-11T13:45:38.680"}, "13984072": {"ParentId": "13983984", "CommentCount": "0", "Body": "<p>You cannot, ever, destroy a resource while something is, or might be, using it. That's really just common sense.</p>\n", "OwnerUserId": "721269", "PostTypeId": "2", "Id": "13984072", "Score": "1", "CreationDate": "2012-12-21T03:59:10.233", "LastActivityDate": "2012-12-21T03:59:10.233"}, "13983984": {"CommentCount": "0", "AcceptedAnswerId": "13984169", "PostTypeId": "1", "LastEditorUserId": "906773", "CreationDate": "2012-12-21T03:45:33.407", "LastActivityDate": "2016-08-19T06:27:12.073", "LastEditDate": "2012-12-21T03:53:57.673", "ViewCount": "7964", "FavoriteCount": "3", "Title": "What happens when calling the destructor of a thread object that has a condition variable waiting?", "Id": "13983984", "Score": "7", "Body": "<p>I am using a <code>SynchronisedQueue</code> to communicate between threads. I found that destroying the thread object when the attaching thread is waiting on a condition variable would cause the program crash. This can be corrected by calling <code>detach()</code> before the thread destruction. But I am wondering what happens exactly when a thread waiting a conditional variable got terminated. Is there another way to use condition variable to avoid this?</p>\n<pre><code>#include &lt;queue&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n\ntemplate &lt;typename Type&gt; class SynchronisedQueue {\n public:\n  void Enqueue(Type const &amp; data) {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    queue_.push(data);\n    condition_.notify_one();\n  }\n  Type Dequeue() {\n    std::unique_lock&lt;std::mutex&gt; lock(mutex_);\n    while (queue_.empty())\n      condition_.wait(lock);\n    Type result = queue_.front();\n    queue_.pop();\n    return result; \n  }\n private:\n  std::queue&lt;Type&gt; queue_;\n  std::mutex mutex_;\n  std::condition_variable condition_; \n};\n\nclass Worker {\npublic:\n  Worker(SynchronisedQueue&lt;int&gt; * queue) : queue_(queue) {}\n  void operator()() {\n    queue_-&gt;Dequeue();    // &lt;-- The thread waits here.\n  }\nprivate:\n  SynchronisedQueue&lt;int&gt; * queue_;\n};\n\nint main() {\n  auto queue = new SynchronisedQueue&lt;int&gt;();\n  Worker worker(queue);\n  std::thread worker_thread(worker);\n  worker_thread.~thread();  // &lt;-- Crashes the program.\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><condition-variable>", "OwnerUserId": "866732", "AnswerCount": "3"}, "13984145": {"ParentId": "13983984", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The destructor for <code>std::thread</code> will call <code>std::terminate</code> if it is run on a thread if you not have called <code>join()</code> (to wait the thread to finish) or <code>detach()</code> (to detach the thread from the object) on it.</p>\n<p>Your code calls the destructor for <code>worker_thread</code> without calling <code>join()</code> or <code>detach()</code> on it, and so <code>std::terminate</code> is called. This is unrelated to the presence of condition variables.</p>\n", "OwnerUserId": "485561", "LastEditorUserId": "3225867", "LastEditDate": "2016-08-19T06:27:12.073", "Id": "13984145", "Score": "1", "CreationDate": "2012-12-21T04:09:50.570", "LastActivityDate": "2016-08-19T06:27:12.073"}, "bq_ids": {"n4140": {"so_13983984_13984169_2": {"section_id": 2717, "quality": 0.8611111111111112, "length": 31}, "so_13983984_13984169_1": {"section_id": 2717, "quality": 1.0, "length": 5}}, "n3337": {"so_13983984_13984169_2": {"section_id": 2678, "quality": 0.8611111111111112, "length": 31}, "so_13983984_13984169_1": {"section_id": 2678, "quality": 1.0, "length": 5}}, "n4659": {"so_13983984_13984169_2": {"section_id": 3457, "quality": 0.8333333333333334, "length": 30}, "so_13983984_13984169_1": {"section_id": 3457, "quality": 0.8, "length": 4}}}});