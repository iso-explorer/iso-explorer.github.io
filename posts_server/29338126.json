post_cb({"29338176": {"ParentId": "29338126", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>A char is defined as being 1 byte. A byte is the smallest addressable unit. This is 8 bits on common systems, but on some systems it is 16 bits, or 32 bits, or anything else (but must be at least 8 for C++).  </p>\n<p>It is somewhat confusing because in popular jargon <em>byte</em> is used for what is technically known as an <em>octet</em> (8 bits).</p>\n<p>So, your second and third quotes are correct. The first quote is, strictly speaking, not correct. </p>\n<p>As defined by [intro.memory]/1 in the C++ Standard, <code>char</code> only needs to be able to hold the <em>basic execution character set</em> which is approximately 100 characters (all of which appear in the 0 - 127 range of ASCII), and the octets that make up UTF-8 encoding.  Perhaps that is what the author meant by <em>machine</em> character set.</p>\n<hr>\n<p>On a system where the hardware is octet addressable but the character set is Unicode, it is likely that <code>char</code> will remain 8-bit.  However there are types <code>char16_t</code> and <code>char32_t</code> (added in C++11) which are designed to be used in your code instead of <code>char</code> for systems that have 16-bit or 32-bit character sets. </p>\n<p>So, if the system goes with <code>char16_t</code> then you would use <code>std::basic_string&lt;char16_t&gt;</code> instead of <code>std::string</code>, and so on.</p>\n<p>Exactly how UTF-16 should be handled will depend on the detail of the implementation chosen by the system. Unicode is a 21-bit character set and UTF-16 is a multibyte encoding of it; so the system could go the Windows-like route and use <code>std::basic_string&lt;char16_t&gt;</code> with UTF-16 encoding for strings; or it could go for <code>std::basic_string&lt;char32_t&gt;</code> with raw Unicode code points as the characters.</p>\n<p>Alf's post goes into more detail on some of the issues that can arise.</p>\n</hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1879192", "LastEditDate": "2015-03-30T11:32:13.237", "Id": "29338176", "Score": "7", "CreationDate": "2015-03-30T03:56:56.703", "LastActivityDate": "2015-03-30T11:32:13.237"}, "29338126": {"CommentCount": "9", "AcceptedAnswerId": "29338173", "PostTypeId": "1", "LastEditorUserId": "14860", "CreationDate": "2015-03-30T03:51:00.987", "LastActivityDate": "2015-08-03T02:52:19.303", "LastEditDate": "2015-08-03T02:52:19.303", "ViewCount": "1485", "FavoriteCount": "4", "Title": "Confusing sizeof(char) by ISO/IEC in different character set encoding like UTF-16", "Id": "29338126", "Score": "37", "Body": "<p>Assuming that a program is running on a system with UTF-16 encoding character set. So according to <em>The C++ Programming Language - 4th</em>, page 150:</p>\n<blockquote>\n<p id=\"so_29338126_29338126_0\">A char can hold a character of the machine\u2019s character set. </p>\n</blockquote>\n<p>\u2192 I think that a char variable will have the size is 2-bytes.</p>\n<p>But according to <em>ISO/IEC 14882:2014</em>:</p>\n<blockquote>\n<p id=\"so_29338126_29338126_1\"><code>sizeof(char)</code>, <code>sizeof(signed char)</code> and <code>sizeof(unsigned char)</code> are 1\".</p>\n</blockquote>\n<p>or <em>The C++ Programming Language - 4th</em>, page 149:</p>\n<blockquote>\n<p id=\"so_29338126_29338126_2\">\"[...], so by definition the size of a char is 1\" </p>\n</blockquote>\n<p>\u2192 It is fixed with size is 1.</p>\n<p><strong>Question:</strong> Is there a conflict between these statements above or\nis the <code>sizeof(char) = 1</code> just a default (definition) value and will be implementation-defined depends on each system?</p>\n", "Tags": "<c++><language-lawyer><sizeof><utf-16>", "OwnerUserId": "4365117", "AnswerCount": "5"}, "29338173": {"ParentId": "29338126", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>The C++ standard (and C, for that matter) effectively define <code>byte</code> as the size of a <code>char</code> type, <em>not</em> as an eight-bit quantity<sup>1</sup>. As per <code>C++11 1.7/1</code> (my bold):</p>\n<blockquote>\n<p id=\"so_29338126_29338173_0\">The fundamental storage unit in the C++ memory model is the byte. A byte is at <strong>least</strong> large enough to contain any member of the basic execution character set and the eight-bit code units of the Unicode UTF-8 encoding form and is composed of a contiguous sequence of bits, <strong>the number of which is implementation defined.</strong></p>\n</blockquote>\n<p>Hence the expression <code>sizeof(char)</code> is <em>always</em> 1, no matter what.</p>\n<p>If you want to see whether you baseline <code>char</code> variable (probably the <code>unsigned</code> variant would be best) can actually hold a 16-bit value, the item you want to look at is <code>CHAR_BIT</code> from <code>&lt;climits&gt;</code>. This holds the number of bits in a <code>char</code> variable.</p>\n<hr>\n<p><sup>1</sup> Many standards, especially ones related to communications protocols, use the more exact term <code>octet</code> for an eight-bit value.</p>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2015-04-17T05:22:13.977", "Id": "29338173", "Score": "35", "CreationDate": "2015-03-30T03:56:51.890", "LastActivityDate": "2015-04-17T05:22:13.977"}, "29339251": {"ParentId": "29338126", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Yes, there are a number of serious conflicts and problems with the C++ conflation of r\u00f4les for <code>char</code>, but also the <em>question</em> conflates a few things. So a simple direct answer would be like answering \u201cyes\u201d, \u201cno\u201d or \u201cdon\u2019t know\u201d to the question \u201chave you stopped beating your wife?\u201d. The only direct answer is <a href=\"http://en.wikipedia.org/wiki/Mu_%28negative%29\" rel=\"nofollow noreferrer\">the buddhist \u201cmu\u201d</a>, unasking the question.</p>\n<p>So let's therefore start with a look at the facts.</p>\n<hr>\n<h2>Facts about the char type.</h2>\n<p>The number of bits per <code>char</code> is given by the implementation defined <strong><code>CHAR_BIT</code></strong> from the <code>&lt;limits.h&gt;</code> header. This number is guaranteed to be 8 or larger. With C++03 and earlier that guarantee came from the specification of that symbol in the C89 standard, which the C++ standard noted (in a non-normative section, but still) as \u201cincorporated\u201d. With C++11 and later the C++ standard explicitly, on its own, gives the \u22658 guarantee. On most platforms <code>CHAR_BIT</code> is 8, but on some probably still extant <a href=\"https://stackoverflow.com/a/2098444/464581\">Texas Instruments digital signal processors</a> it\u2019s 16, and other values have been used.</p>\n<p>Regardless of the value of <code>CHAR_BIT</code> the <code>sizeof(char)</code> is by definition 1, i.e. it's not implementation defined:</p>\n<b>C++11 \u00a75.3.3/1</b> (in [expr.sizeof]):\n\n<blockquote>\n<p id=\"so_29338126_29339251_0\"><strong>\u201d</strong> <code>sizeof(char)</code>, <code>sizeof(signed char)</code> and\n  <code>sizeof(unsigned char)</code> are 1.</p>\n</blockquote>\n<p>That is, <code>char</code> and its variants is the fundamental <em>unit of addressing</em> of memory, which is the primary meaning of <strong>byte</strong>, both in common speech and formally in C++:</p>\n<b>C++11 \u00a71.7/1</b> (in [intro.memory]):\n\n<blockquote>\n<p id=\"so_29338126_29339251_1\"><strong>\u201d</strong> The fundamental storage unit in the C ++ memory model is the <em>byte</em>.</p>\n</blockquote>\n<p>This means that on the aforementioned TI DSPs, there is no C++ way of obtaining pointers to individual <strong>octets</strong> (8-bit parts). And that in turn means that code that needs to deal with endianness, or in other ways needs to treat <code>char</code> values as sequences of octets, in particular for network communications, needs to do things with <code>char</code> values that is not meaningful on a system where <code>CHAR_BIT</code> is 8. It also means that ordinary C++ narrow string literals, if they adhere to the standard, and if the platform's standard software uses an 8-bit character encoding, will waste memory.</p>\n<p>The waste aspect was (or is) directly addressed in the Pascal language, which differentiates between <strong>packed strings</strong> (multiple octets per byte) and <strong>unpacked strings</strong> (one octet per byte), where the former is used for passive text storage, and the latter is used for efficient processing.</p>\n<p>This illustrates the basic conflation of three aspects in the single C++ type <code>char</code>:</p>\n<ul>\n<li><p>unit of memory addressing, a.k.a. byte,</p></li>\n<li><p>smallest basic type (it would be nice with an <code>octet</code> type), and</p></li>\n<li><p>character encoding value unit.</p></li>\n</ul>\n<p>And yes, this is a conflict.</p>\n<hr>\n<h2>Facts about UTF-16 encoding.</h2>\n<p>Unicode is a large set of 21-bit <strong>code points</strong>, most of which constitute characters on their own, but some of which are combined with others to form characters. E.g. a character with accent  like \u201c\u00e9\u201d can be formed by combining code points for \u201ce\u201d and \u201c\u00b4\u201d-as-accent. And since that\u2019s a general mechanism it means that a Unicode character can be an arbitrary number of code points, although it\u2019s usually just 1.</p>\n<p>UTF-16 encoding was originally a compatibility scheme for code based on original Unicode\u2019s 16 bits per code point, when Unicode was extended to 21 bits per code point. The basic scheme is that code points in the defined ranges of original Unicode are represented as themselves, while each new Unicode code point is represented as a <strong>surrogate pair</strong> of 16-bit values. A small range of original Unicode is used for surrogate pair values.</p>\n<p>At the time, examples of software based on 16 bits per code point included 32-bit Windows and the <a href=\"https://softwareengineering.stackexchange.com/a/174950\">Java</a> language.</p>\n<p>On a system with 8-bit byte UTF-16 is an example of a <strong>wide text</strong> encoding, i.e. with an encoding unit wider than the basic addressable unit. Byte oriented text encodings are then known as <strong>narrow text</strong>. On such a system C++ <code>char</code> fits the latter, but not the former.</p>\n<p>In C++03 the only built in type suitable for the wide text encoding unit was <strong><code>wchar_t</code></strong>.</p>\n<p>However, the C++ standard effectively requires <code>wchar_t</code> to be suitable for a <em>code-point</em>, which for modern 21-bits-per-code-point Unicode means that it needs to be 32 bits. Thus there is no C++03 dedicated type that fits the requirements of UTF-16 encoding values, 16 bits per value. Due to historical reasons the most prevalent system based on UTF-16 as wide text encoding, namely Microsoft Windows, defines <code>wchar_t</code> as 16 bits, which after the extension of Unicode has been in flagrant contradiction with the standard, but then, the standard is impractical regarding this issue.  Some platforms define <code>wchar_t</code> as 32 bits.</p>\n<p>C++11 introduced new types <strong><code>char16_t</code></strong> and <strong><code>char32_t</code></strong>, where the former is (designed to be) suitable for UTF-16 encoding values.</p>\n<hr>\n<h2>About the question.</h2>\n<p>Regarding the question\u2019s stated assumption of</p>\n<blockquote>\n<p id=\"so_29338126_29339251_2\">\u201d a system with UTF-16 encoding character set</p>\n</blockquote>\n<p>this can mean one of two things:</p>\n<ul>\n<li>a system with UTF-16 as the standard narrow encoding, or</li>\n<li>a system with UTF-16 as the standard wide encoding.</li>\n</ul>\n<p>With UTF-16 as the standard narrow encoding <code>CHAR_BIT</code> \u2265 16, and (by definition) <code>sizeof(char)</code> = 1. I do not know of any system, i.e. it appears to be hypothetical. Yet it appears to be the meaning tacitly assumed in current other answers.</p>\n<p>With UTF-16 as the standard wide encoding, as in Windows, the situation is more complex, because the C++ standard is not up to the task. But, to use Windows as an example, one practical possibility is that <code>sizeof(wchar_t)</code>= 2. And one should just note that the standard is conflict with existing practice and practical considerations for this issue, when the ideal is that standards instead standardize the existing practice, where there is such.</p>\n<p>Now finally we\u2019re in a position to deal with the question,</p>\n<blockquote>\n<p id=\"so_29338126_29339251_3\"><strong>\u201d</strong>  Is there a conflict between these statements above or is the <code>sizeof(char) = 1</code> just a default (definition) value and will be implementation-defined depends on each system?</p>\n</blockquote>\n<p>This is a false dichotomy. The two possibilities are not opposites. We have</p>\n<ul>\n<li><p>There is indeed a conflict between <code>char</code> as character encoding unit and as a memory addressing unit (byte). As noted, the Pascal language has the keyword <code>packed</code> to deal with one aspect of that conflict, namely storage versus processing requirements. And there is a further conflict between the formal requirements on <code>wchar_t</code>, and its use for UTF-16 encoding in the most widely used system that employs UTF-16 encoding, namely Windows.</p></li>\n<li><p><code>sizeof(char) = 1</code> by definition: it's not system-dependent.</p></li>\n<li><p><code>CHAR_BIT</code> is implementation defined, and is guaranteed \u2265 8.</p></li>\n</ul>\n</hr></hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:32:23.910", "Id": "29339251", "Score": "28", "CreationDate": "2015-03-30T05:54:31.970", "LastActivityDate": "2015-03-30T06:30:24.080"}, "29339900": {"ParentId": "29338126", "CommentCount": "0", "Body": "<p>Without quoting standard it is easily to give simply answer because:</p>\n<p><strong>Definition of byte is not 8 bits</strong>. Byte is any size but smallest addressable unit of memory. Most commonly it is 8 bits, but there is no reason to don't have 16 bits byte. </p>\n<p>C++ standard gives more restrictions because it must be at least 8 bits. </p>\n<p>So there is no problem to sizeof(char) be always 1, no matter what. Sometimes it will be stand as 8 bits, sometimes 16 bits and so on. </p>\n", "OwnerUserId": "2534793", "PostTypeId": "2", "Id": "29339900", "Score": "5", "CreationDate": "2015-03-30T06:45:04.850", "LastActivityDate": "2015-03-30T06:45:04.850"}, "29338162": {"ParentId": "29338126", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>No, there's no conflict. These two statements refer to different definitions of <em>byte</em>.</p>\n<p>UTF-16 implies that <em>byte</em> is the same thing as <em>octet</em> - a group of 8 bits.</p>\n<p>In C++ language <em>byte</em> is the same thing as <code>char</code>. There's no limitation on how many bits a C++-byte can contain. The number of bits in C++-byte is defined by <code>CHAR_BIT</code> macro constant.</p>\n<p>If your C++ implementation decides to use 16 bits to represent each character, then <code>CHAR_BIT</code> will be 16 and each C++-byte will occupy two UTF-16-bytes. <code>sizeof(char)</code> will still be 1 and sizes of all objects will be measured in terms of 16-bit bytes.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2015-03-30T05:42:19.677", "Id": "29338162", "Score": "9", "CreationDate": "2015-03-30T03:55:51.387", "LastActivityDate": "2015-03-30T05:42:19.677"}, "bq_ids": {"n4140": {"so_29338126_29338126_0": {"section_id": 7210, "quality": 0.7142857142857143, "length": 5}, "so_29338126_29338126_1": {"section_id": 6076, "quality": 1.0, "length": 5}, "so_29338126_29338173_0": {"section_id": 5785, "quality": 0.8709677419354839, "length": 27}, "so_29338126_29339251_1": {"section_id": 5785, "quality": 0.8571428571428571, "length": 6}, "so_29338126_29339251_0": {"section_id": 6076, "quality": 1.0, "length": 5}}, "n3337": {"so_29338126_29338126_0": {"section_id": 6954, "quality": 0.7142857142857143, "length": 5}, "so_29338126_29338126_1": {"section_id": 5844, "quality": 1.0, "length": 5}, "so_29338126_29338173_0": {"section_id": 5558, "quality": 0.8709677419354839, "length": 27}, "so_29338126_29339251_1": {"section_id": 5558, "quality": 0.8571428571428571, "length": 6}, "so_29338126_29339251_0": {"section_id": 5844, "quality": 1.0, "length": 5}}, "n4659": {"so_29338126_29339251_2": {"section_id": 2824, "quality": 0.8, "length": 4}, "so_29338126_29338126_1": {"section_id": 7572, "quality": 1.0, "length": 5}, "so_29338126_29338173_0": {"section_id": 7242, "quality": 0.8709677419354839, "length": 27}, "so_29338126_29338126_0": {"section_id": 7709, "quality": 0.7142857142857143, "length": 5}, "so_29338126_29339251_1": {"section_id": 7242, "quality": 0.8571428571428571, "length": 6}, "so_29338126_29339251_0": {"section_id": 7572, "quality": 1.0, "length": 5}}}});