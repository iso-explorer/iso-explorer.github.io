post_cb({"3951807": {"ParentId": "3951732", "CommentCount": "2", "Body": "<p>I've tended to see the 'instance' method of Factory implemented as follows:</p>\n<pre><code>static Factory&amp; instance()\n{\n    static Factory *factory = new Factory();\n    return *factory;\n}\n</code></pre>\n<p>However, the point is that all access to the instance runs through the static instance method. The calls to register the two fruit classes for example use Factory::instance() to obtain the singleton which will guarantee that the initializer for Factory::factory has executed.  In my posted alternative implementation the static initialization only occurs the first time the method is called.</p>\n<p>The possible issues with Apple::registered and Banana::registered depend on where they might be used from. In the posted code they aren't used at all. If used only within apple.cpp and banana.cpp respectively then there is no issue with order of initialization.</p>\n", "OwnerUserId": "2508", "PostTypeId": "2", "Id": "3951807", "Score": "2", "CreationDate": "2010-10-17T02:47:20.703", "LastActivityDate": "2010-10-17T02:47:20.703"}, "3951746": {"ParentId": "3951732", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>All static variables are initialized before the program begins to run. They are set at compile time and baked right into the executable.</p>\n<p>The only issue arises when one static variable depends on another:</p>\n<p>In a.hpp:</p>\n<pre><code>static int a = 1;\n</code></pre>\n<p>in b.hpp:</p>\n<pre><code>extern int a;\nstatic int b = a;\n</code></pre>\n<p>The order in which static variables are initialized is not well defined, so b may or may not be 1 in this example. As long as your variables don't depend on each other, you're fine. Furthermore, is you don't give an initial value, static members are set to zero by default.</p>\n", "OwnerUserId": "454638", "LastEditorUserId": "454638", "LastEditDate": "2010-10-17T02:37:24.833", "Id": "3951746", "Score": "4", "CreationDate": "2010-10-17T02:27:12.223", "LastActivityDate": "2010-10-17T02:37:24.833"}, "3951732": {"CommentCount": "5", "ViewCount": "3284", "PostTypeId": "1", "LastEditorUserId": "731620", "CreationDate": "2010-10-17T02:19:54.143", "LastActivityDate": "2015-10-16T22:52:18.123", "Title": "Is the typical C++ implementation of Factory class flawed?", "AcceptedAnswerId": "3951744", "LastEditDate": "2015-10-16T22:52:18.123", "Id": "3951732", "Score": "4", "Body": "<p>I have the need to implement factory class in C++, but when I was thinking about that, I found one big problem that I couldn't solve, and I found out, that all factory implementation examples around are flawed in the same way. I'm probably the one who is wrong, but please tell me why.</p>\n<p>So here is simple \"typical\" factory implementation, it allows me to register new objects without changing the Factory class.</p>\n<pre><code>//fruit.h\nclass Fruit\n{\nprotected :\n  int count;\npublic :\n  Fruit(int count) : count(count) {}\n  virtual void show() = 0;\n};\n\n// factory.h\n/** singleton factory */\nclass Factory\n{\n  typedef Fruit* (*FruitCreateFunction)(int);\n  static Factory* factory;\n  std::map&lt;std::string, FruitCreateFunction&gt; registeredFruits;\npublic :\n  static Factory&amp; instance()\n  {\n    if (factory == NULL)\n      factory = new Factory();\n    return *factory;\n  }\n  bool registerFruit(const std::string&amp; name, Fruit* (createFunction)(int))\n  {\n    registeredFruits.insert(std::make_pair(name, createFunction));\n    return true;\n  }\n  Fruit* createFruit(const std::string&amp; name, int count)\n  {\n    return registeredFruits[name](count);\n  }\n};\n\n//factory.cpp\nFactory* Factory::factory = NULL;\n\n//apple.h\nclass Apple : public Fruit\n{\n  static Fruit* create(int count) { return new Apple(count); }\n  Apple(int count) : Fruit(count) {}\n  virtual void show() { printf(\"%d nice apples\\n\", count); };  \n  static bool registered;\n};\n\n// apple.cpp\nbool Apple::registered = Factory::instance().registerFruit(\"apple\", Apple::create);\n\n//banana.h\nclass Banana : public Fruit\n{\n  static Fruit* create(int count) { return new Banana(count); }\n  Banana(int count) : Fruit(count) {}\n  virtual void show() { printf(\"%d nice bananas\\n\", count); };  \n  static bool registered;\n};\n\n// banana.cpp\nbool Banana::registered = Factory::instance().registerFruit(\"banana\", Banana::create);\n\n// main.cpp\nint main(void)\n{\n  std::vector&lt;Fruit*&gt; fruits;\n  fruits.push_back(Factory::instance().createFruit(\"apple\", 10));\n  fruits.push_back(Factory::instance().createFruit(\"banana\", 7));\n  fruits.push_back(Factory::instance().createFruit(\"apple\", 6));\n  for (size_t i = 0; i &lt; fruits.size(); i++)\n    {\n      fruits[i]-&gt;show();\n      delete fruits[i];\n    }\n  return 0;\n}\n</code></pre>\n<p>Ok, this code looks fancy and it works, but here comes the but:</p>\n<p>The C++ standard doesn't allow me to define the order in which global (static) variables will be defined.</p>\n<p>I have 3 static variables here</p>\n<pre><code>Apple::registered;\nBanana::registered;\nFactory::factory;\n</code></pre>\n<p>The <code>Factory::factory</code> pointer needs to be defined to NULL <strong><em>before</em></strong> the Apple(or Banana)::registered variable, or the <code>Factory::instance</code> method will work with uninitialized value, and behave unpredictably.</p>\n<p>So, what am I not getting here? Is the code really working only by an accident? If so, how should I solve the issue?</p>\n", "Tags": "<c++><singleton><factory><factory-pattern>", "OwnerUserId": "478271", "AnswerCount": "3"}, "3951744": {"ParentId": "3951732", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>All global POD data is guaranteed to be initialized to a constant value before any initializers run.</p>\n<p>So at the start of your program, before any of the register calls are made and before main is run, the pointer is NULL and all of the bools are false, automatically.  Then the  initializers run, including your register calls.</p>\n<p>Edit: Specifically, from the standard (3.6.2.2: Initialization of non-local objects):</p>\n<blockquote>\n<p id=\"so_3951732_3951744_0\">Together, zero-initialization and\n  constant initialization are called\n  static initialization; all other\n  initialization is dynamic\n  initialization. Static initialization\n  shall be performed before any dynamic\n  initialization takes place.</p>\n</blockquote>\n", "OwnerUserId": "36384", "LastEditorUserId": "36384", "LastEditDate": "2010-10-17T02:30:28.513", "Id": "3951744", "Score": "11", "CreationDate": "2010-10-17T02:24:53.910", "LastActivityDate": "2010-10-17T02:30:28.513"}, "bq_ids": {"n4140": {"so_3951732_3951744_0": {"section_id": 7151, "quality": 0.9, "length": 18}}, "n3337": {"so_3951732_3951744_0": {"section_id": 6895, "quality": 0.9, "length": 18}}, "n4659": {"so_3951732_3951744_0": {"section_id": 8652, "quality": 0.7, "length": 14}}}});