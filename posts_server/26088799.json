post_cb({"bq_ids": {"n4140": {"so_26088799_26088799_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_26088799_26088799_3": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_26088799_26088799_4": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_26088799_26088799_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}}, "n3337": {"so_26088799_26088799_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}, "so_26088799_26088799_3": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_26088799_26088799_4": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_26088799_26088799_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}}, "n4659": {"so_26088799_26088799_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}, "so_26088799_26088799_3": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_26088799_26088799_4": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_26088799_26088799_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}}}, "26090110": {"Id": "26090110", "PostTypeId": "2", "Body": "<p>The standardization effort of <code>decltype</code> was a herculean effort spanning many years.  There were 7 versions of this paper before the committee finally accepted it.  The versions were:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf\" rel=\"noreferrer\">N1478</a>  2003-04-28</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1527.pdf\" rel=\"noreferrer\">N1527</a>  2003-09-21</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1607.pdf\" rel=\"noreferrer\">N1607</a>  2004-02-17</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1705.pdf\" rel=\"noreferrer\">N1705</a>  2004-09-12</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1978.pdf\" rel=\"noreferrer\">N1978</a>  2006-04-24</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2115.pdf\" rel=\"noreferrer\">N2115</a>  2006-11-05</li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf\" rel=\"noreferrer\">N2343</a>  2007-07-18</li>\n</ul>\n<p>Remarkably, the seeds of the behavior which you question are in the very first revision:  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf\" rel=\"noreferrer\">N1478</a>, which introduces the need for \"two types of typeof:  either to preserve or to drop references in types.\"</p>\n<p>This paper goes on to give a rationale for the reference-preserving variant, including this quote:</p>\n<blockquote>\n<p id=\"so_26088799_26090110_0\">On the other hand, the reference-dropping semantics fails to provide a\n  mechanism for exactly expressing the return types of generic\n  functions, as demonstrated by Strous- trup [Str02]. This implies that\n  a reference-dropping typeof would cause problems for writers of\n  generic libraries.</p>\n</blockquote>\n<p>There is no substitute for reading through these papers.  However one might summarize that <code>decltype</code> serves two purposes:</p>\n<ol>\n<li>To report the declared type of an identifier.</li>\n<li>To report the type of an expression.</li>\n</ol>\n<p>For the second use case, recall that expressions are never reference types, but are instead one of lvalues, xvalues, or prvalues.  By convention, when <code>decltype</code> is reporting the type of an lvalue expression, it makes the type an lvalue reference, and when the expression is an xvalue, the reported type becomes an rvalue reference.</p>\n<p>In your example, <code>*ap</code> is an expression, whereas <code>a</code> is an identifier.  So your example makes use of both use cases, as first introduced in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf\" rel=\"noreferrer\">N1478</a>.</p>\n<p>It is also instructive to note that <code>decltype</code> was not designed in isolation.  The rest of the C++ language was evolving during this time period (e.g. rvalue references), and the design of <code>decltype</code> was iterated to keep pace.</p>\n<p>Also note that once the <code>decltype</code> proposal was accepted, it continued (and continues to this day) to evolve.  See this list of issues:</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_index.html\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_index.html</a></p>\n<p>specifically section 7.1.6.2 (which is the section where the bulk of the <code>decltype</code> specification lives).</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2014-09-28T22:11:01.973", "Score": "6", "CreationDate": "2014-09-28T22:02:13.750", "ParentId": "26088799", "CommentCount": "0", "OwnerUserId": "576911", "LastEditDate": "2014-09-28T22:11:01.973"}, "26088799": {"ViewCount": "119", "Body": "<p>From C++ Draft Standard N3337:</p>\n<blockquote>\n<p id=\"so_26088799_26088799_0\"><strong>7.1.6.2 Simple type specifiers</strong></p>\n<p id=\"so_26088799_26088799_1\">4 The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_26088799_26088799_2\">\u2014 if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</p>\n<p id=\"so_26088799_26088799_3\">\u2014 otherwise, if e is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_26088799_26088799_4\">\u2014 otherwise, if e is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n</blockquote>\n<p>If I understand the above correctly,</p>\n<pre><code>int a;\ndecltype(a) b = 10;    // type of b is int\n\nint* ap;\ndecltype(*ap) c = 10;  // Does not work since type of c is int&amp;\n</code></pre>\n<p>Can you explain, or point to some documentation that explains, why <code>decltype(*ap)</code> couldn't have been just <code>int</code>?</p>\n", "AcceptedAnswerId": "26090110", "Title": "Why is the behavior of decltype defined the way it is?", "CreationDate": "2014-09-28T19:32:17.813", "Id": "26088799", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastActivityDate": "2014-09-28T22:11:01.973", "Score": "5", "OwnerUserId": "434551", "Tags": "<c++11><decltype>", "AnswerCount": "1"}});