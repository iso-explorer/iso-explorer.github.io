post_cb({"1099092": {"ParentId": "1098966", "CommentCount": "2", "CreationDate": "2009-07-08T16:17:09.720", "OwnerUserId": "14148", "PostTypeId": "2", "Id": "1099092", "Score": "2", "Body": "<p>Comparing pointers that are not allocated in the same block is undefined, probably because there are memory models that have problems with them (and used to be more common).</p>\n<p>What you need to use is <code>unordered_set&lt;&gt;</code>, which doesn't appear to require a comparison operator.  It's in the next C++ standard, and available <a href=\"http://www.boost.org/doc/libs/1_39_0/doc/html/unordered.html\" rel=\"nofollow noreferrer\">as a Boost header</a> in the meantime.</p>\n", "LastActivityDate": "2009-07-08T16:17:09.720"}, "1099045": {"ParentId": "1098966", "CommentCount": "0", "CreationDate": "2009-07-08T16:07:08.977", "OwnerUserId": "31000", "PostTypeId": "2", "Id": "1099045", "Score": "3", "Body": "<p>Even though you may think that comparing the bits of pointers is harmless (after all, they're just addresses in memory, right?), there are good reasons why the language standard doesn't encourage it. For one, if you have code whose results depend on the relative ordering of pointers (e.g, the order of results depends on iteration order through a set or map of pointers), the results will be unstable: Changing the version of compiler or operating system release can change the results. Reproducibility is valuable enough to make this instability worth avoiding.</p>\n", "LastActivityDate": "2009-07-08T16:07:08.977"}, "1099017": {"ParentId": "1098966", "CommentCount": "4", "CreationDate": "2009-07-08T16:01:37.053", "OwnerUserId": "105668", "PostTypeId": "2", "Id": "1099017", "Score": "1", "Body": "<p>Isn't <code>hash_set</code> what you need? It will be a part of the next standard</p>\n", "LastActivityDate": "2009-07-08T16:01:37.053"}, "1098996": {"ParentId": "1098966", "CommentCount": "4", "Body": "<p>Comparing pointers is a pretty fraught business. It only makes sense to compare pointers if they both point into the same block of memory, otherwise the operation is undefined. A (valid) set of pointers is therefore a pretty specialised thing, and no, the Standard Library doesn't have one.</p>\n", "Id": "1098996", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "2", "CreationDate": "2009-07-08T15:57:54.160", "LastActivityDate": "2009-07-08T15:57:54.160"}, "1099080": {"ParentId": "1098966", "PostTypeId": "2", "CommentCount": "31", "CreationDate": "2009-07-08T16:15:20.567", "Score": "27", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:31:07.057", "Id": "1099080", "OwnerUserId": "34509", "Body": "<p>Two pointers can be compared with using the comparison function objects <code>less</code>,  <code>greater</code> etc. Otherwise, using blanket <code>operator&lt;</code> etc, this is only possible if the pointers point to elements of the same array object or one past the end. Otherwise, results are unspecified. </p>\n<p><code>20.3.3/8</code> in C++03</p>\n<blockquote>\n<p id=\"so_1098966_1099080_0\">For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any\n  pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p>\n</blockquote>\n<p>No need to explicitly specialize and manually casting to <code>size_t</code>: That would lower the portability even, since the mapping of <code>reinterpret_cast</code> from pointers to integers is implementation defined and is not required to yield any order. </p>\n<hr>\n<p><strong>Edit</strong>: For a more detailed answer, see <a href=\"https://stackoverflow.com/questions/1418068/what-are-the-operations-supported-by-raw-pointer-and-function-pointer-in-c-c/1418152#1418152\">this one</a>.</p>\n</hr>", "LastActivityDate": "2009-09-14T16:28:48.083"}, "1098966": {"CommentCount": "1", "AcceptedAnswerId": "1099080", "PostTypeId": "1", "LastEditorUserId": "3458", "CreationDate": "2009-07-08T15:52:53.373", "LastActivityDate": "2009-09-18T20:41:18.753", "LastEditDate": "2009-09-18T20:41:18.753", "ViewCount": "7564", "FavoriteCount": "5", "Title": "Universal less<> for pointers in C++ standard", "Id": "1098966", "Score": "28", "Body": "<p>Many times I needed a set of pointers. Every time that happens, I end up writing a less&lt;&gt; implementation for a pointer type - cast two pointers to size_t and compare the results.</p>\n<p>My question is - is that available in the standard? I could not find anything like that. Seems like common enough case...</p>\n<p>Update: it seems that the upcoming standard fixes all of the problems with less&lt;&gt; provided for pointer types and unordered_set included, too. In a few years this question will be moot.</p>\n<p>In the mean time, the current standard has no \"legal\" solution to this, but size_t cast works.</p>\n<p>Update for update: well, I'll be gobsmacked! Not only </p>\n<pre><code>std::map&lt;void *, int, std::less&lt;void*&gt; &gt; myMap;\n</code></pre>\n<p>works, but even</p>\n<pre><code>std::map&lt;void *, int &gt; myMap;\n</code></pre>\n<p>as well.</p>\n<p>And that's in gcc 3.4.1 . I've been doing all the these casts for nothing, and litb is perfectly right. Even the section number he cites is exactly the same in the current standard. Hurray!</p>\n", "Tags": "<c++>", "OwnerUserId": "3458", "AnswerCount": "6"}, "1099042": {"ParentId": "1098966", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2009-07-08T16:06:35.937", "Score": "3", "LastEditorUserId": "33732", "LastEditDate": "2009-07-08T17:23:36.997", "Id": "1099042", "OwnerUserId": "33732", "Body": "<p><s>No, it's not available.</s> The standard says that pointers are only comparable with the built-in operators when they point to the same array or other memory block. That is, the block needs to have been allocated all at once, as opposed to two separate allocations that might happen to be adjacent to each other.</p>\n<p>This is OK:</p>\n<pre><code>int x[2];\nbool b = &amp;x[0] &lt; &amp;x[1];\n</code></pre>\n<p>This is undefined:</p>\n<pre><code>int x0;\nint x1;\nbool b = &amp;x0 &lt; &amp;x1;\n</code></pre>\n<p>This is OK:</p>\n<pre><code>struct foo {\n  int x0;\n  int x1;\n};\nfoo f;\nbool b = &amp;f.x0 &lt; &amp;f.x1;\n</code></pre>\n<p>Both values are members of the same struct, so they belong to the same block of memory (namely, <code>f</code>'s).</p>\n<p>Practically speaking, though, there's nothing wrong with your custom-defined comparison.</p>\n<p>However, your custom specialization is unnecessary, since the <code>std::less</code> template <em>is</em> defined for pointers, evidently. So this is OK:</p>\n<pre><code>int x0;\nint x1;\nstd::less&lt;int*&gt; compare;\nbool b = compare(&amp;x0, &amp;x1);\n</code></pre>\n<p>There's still no indication of what the result must be, but you're at least promised to have <em>some</em> result, as opposed to undefined behavior. You get a total order, but you don't know <em>what</em> order until you run it.</p>\n", "LastActivityDate": "2009-07-08T17:23:36.997"}, "bq_ids": {"n4140": {"so_1098966_1099080_0": {"section_id": 4605, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_1098966_1099080_0": {"section_id": 4423, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_1098966_1099080_0": {"section_id": 5962, "quality": 0.7333333333333333, "length": 11}}}});