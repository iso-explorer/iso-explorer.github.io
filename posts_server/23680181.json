post_cb({"23680181": {"CommentCount": "3", "ViewCount": "160", "CreationDate": "2014-05-15T13:48:21.693", "LastActivityDate": "2016-09-15T22:05:11.810", "Title": "Is it safe to dereference end()?", "AcceptedAnswerId": "23680294", "PostTypeId": "1", "Id": "23680181", "Score": "2", "Body": "<p>I have a function with the following signature:</p>\n<pre><code>std::string f(const char *first, const char *last) {\n    std::string result;\n    std::for_each(first, last, some_lambda_which_appends_to_result);\n    return result;\n}\n</code></pre>\n<p>and an overload for std::string which calls it:</p>\n<pre><code>std::string f(const std::string s) {\n    return f(&amp;*s.begin(), &amp;*s.end());\n    // The one below would assume that the string is not empty\n    //     f(&amp; s.front(), &amp; s.front() + s.size());\n}\n</code></pre>\n<p>However, this may be unsafe (dereferencing s.end() might be a red card offense in itself).\nIs there a safe way to get a pointer to the beginning of characters and a one-past-the-end pointer (two null pointers would be fine in case of an empty string),\nor do I have to write</p>\n<pre><code>std::string(const std::string&amp; s) {\n    return s.empty() ? std::string() : f(&amp; s.front(), &amp; s.front() + s.size());\n}\n</code></pre>\n", "Tags": "<c++><stl>", "OwnerUserId": "2064196", "AnswerCount": "2"}, "23680294": {"ParentId": "23680181", "CommentCount": "1", "Body": "<p>It's not safe to dereference <code>end()</code>. However, you can use either <code>c_str()</code> or <code>data()</code> to achieve what you need:</p>\n<pre><code>std::string(const std::string&amp; s) {\n    return f(s.data(), s.data() + s.size());\n}\n</code></pre>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "23680294", "Score": "5", "CreationDate": "2014-05-15T13:52:18.913", "LastActivityDate": "2014-05-15T13:52:18.913"}, "39521025": {"ParentId": "23680181", "CommentCount": "0", "Body": "<p>According to the C++14 standard (N4140) it is safe.  From [string.accessors]/1:</p>\n<blockquote>\n<p id=\"so_23680181_39521025_0\"><code>const charT* data() const noexcept;</code></p>\n<p id=\"so_23680181_39521025_1\"><sup>1</sup> <em>Returns:</em> A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<p>This guarantees that, there is contiguous storage for the string, with a null terminator stored after the last character of the string.</p>\n<p>The definition of <code>end()</code> in [string.iterators]/2 says:</p>\n<blockquote>\n<p id=\"so_23680181_39521025_2\"><sup>2</sup> <em>Returns:</em> An iterator which is the past-the-end value.</p>\n</blockquote>\n<p>The definition of \"past-the-end value\" is in [iterator.requirements.general]/5:</p>\n<blockquote>\n<p id=\"so_23680181_39521025_3\">Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value <strong>that points past the last element of a corresponding sequence</strong>. These values are called past-the-end values. Values of an iterator <code>i</code> for which the expression <code>*i</code> is defined are called dereferenceable. The library never assumes that past-the-end values are dereferenceable. Iterators can also have singular values that are not associated with any sequence. [...]</p>\n</blockquote>\n<p>See how this is carefully worded to <strong>not</strong> say that past-the-end iterators are never dereferencable.</p>\n<p>The bolded part says that <code>std::string::end()</code> points past the last element of the string. From the above definition of <code>data()</code>, this guarantees that it points to the null terminator.</p>\n<p>Since there is nothing anywhere to say that this iterator is singular and/or not dereferencable, we must conclude that, just like every other iterator, dereferencing it produces a reference to the character it points to.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "39521025", "Score": "1", "CreationDate": "2016-09-15T22:05:11.810", "LastActivityDate": "2016-09-15T22:05:11.810"}, "bq_ids": {"n4140": {"so_23680181_39521025_3": {"section_id": 5559, "quality": 0.92, "length": 46}}, "n3337": {"so_23680181_39521025_0": {"section_id": 1836, "quality": 0.8, "length": 4}, "so_23680181_39521025_3": {"section_id": 5341, "quality": 0.92, "length": 46}}, "n4659": {"so_23680181_39521025_0": {"section_id": 1984, "quality": 0.8, "length": 4}, "so_23680181_39521025_3": {"section_id": 7006, "quality": 0.92, "length": 46}}}});