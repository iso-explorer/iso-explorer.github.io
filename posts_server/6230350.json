post_cb({"24251570": {"Id": "24251570", "PostTypeId": "2", "Body": "<p>I was indeed being dense. The standard gives us all the tools we need. Specifically, the sequence container requirements 23.2.3/9 say:</p>\n<blockquote>\n<p id=\"so_6230350_24251570_0\">The iterator returned from <code>a.insert(p, i, j)</code> points to the copy of the first element inserted into <code>a</code>, or <code>p</code> if <code>i == j</code>.</p>\n</blockquote>\n<p>Next, the description of <code>list::insert</code> says (23.3.5.4/1):</p>\n<blockquote>\n<p id=\"so_6230350_24251570_1\">Does not affect the validity of iterators and references.</p>\n</blockquote>\n<p>So in fact if <code>pos</code> is my current iterator inside the list which is being consumed, I can say:</p>\n<pre><code>auto it = buf.insert(buf.end(), newdata.begin(), newdata.end());\n\nif (pos == buf.end()) { pos = it; }\n</code></pre>\n<p>The range of new elements in my list is <code>[it, buf.end())</code>, and the range of yet unprocessed elements is <code>[pos, buf.end())</code>. This works because if <code>pos</code> was equal to <code>buf.end()</code> before the insertion, then it still is after the insertion, since insertion does not invalidate <em>any</em> iterators, not even the end.</p>\n", "LastActivityDate": "2014-06-16T20:21:16.880", "CommentCount": "0", "CreationDate": "2014-06-16T20:21:16.880", "ParentId": "6230350", "Score": "0", "OwnerUserId": "596781"}, "6230791": {"Id": "6230791", "PostTypeId": "2", "Body": "<p>From <a href=\"http://www.sgi.com/tech/stl/List.html\" rel=\"nofollow\">http://www.sgi.com/tech/stl/List.html</a></p>\n<p>\"Lists have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed.\"</p>\n<p>Therefore, <code>readpos</code> should still be valid after the insert.</p>\n<p>However...</p>\n<p><code>std::list&lt; char &gt;</code> is a very inefficient way to solve this problem.  Each byte you store in a <code>std::list</code> requires a pointer to keep track of the byte, plus the size of the list node structure, two more pointers usually.  That is at least 12 or 24 bytes (32 or 64-bit) of memory used to keep track of a single byte of data.</p>\n<p><code>std::deque&lt; char&gt;</code> is probably a better container for this.  Like <code>std::vector</code> it provides constant time insertions at the back however it also provides constant time removal at the front.  Finally, like <code>std::vector</code> <code>std::deque</code> is a random-access container so you can use offsets/indexes instead of iterators.  These three features make it an efficient choice.</p>\n", "LastActivityDate": "2011-06-03T17:53:35.690", "CommentCount": "1", "CreationDate": "2011-06-03T17:53:35.690", "ParentId": "6230350", "Score": "4", "OwnerUserId": "732523"}, "bq_ids": {"n4140": {"so_6230350_24251570_0": {"length": 9, "quality": 0.9, "section_id": 727}, "so_6230350_24251570_1": {"length": 5, "quality": 1.0, "section_id": 896}}, "n3337": {"so_6230350_24251570_0": {"length": 9, "quality": 0.9, "section_id": 716}, "so_6230350_24251570_1": {"length": 5, "quality": 1.0, "section_id": 883}}, "n4659": {"so_6230350_24251570_0": {"length": 9, "quality": 0.9, "section_id": 757}, "so_6230350_24251570_1": {"length": 5, "quality": 1.0, "section_id": 956}}}, "6230632": {"Id": "6230632", "PostTypeId": "2", "Body": "<pre><code>if (readpos == buf.begin())\n{\n    buf.insert(buf.end(), newdata.begin(), newdata.end());\n    readpos = buf.begin();\n}\nelse\n{\n    --readpos;\n    buf.insert(buf.end(), newdata.begin(), newdata.end());\n    ++readpos;\n}\n</code></pre>\n<p>Not elegant, but it should work.</p>\n", "LastEditorUserId": "5987", "LastActivityDate": "2011-06-03T17:50:43.087", "Score": "5", "CreationDate": "2011-06-03T17:38:01.560", "ParentId": "6230350", "CommentCount": "5", "OwnerUserId": "5987", "LastEditDate": "2011-06-03T17:50:43.087"}, "6230350": {"ViewCount": "5302", "Body": "<p><em>Note:</em> This is not a question whether I should \"use list or deque\". It's a question about the validity of iterators in the face of <code>insert()</code>.</p>\n<hr>\n<p>This may be a simple question and I'm just too dense to see the right way to do this. I'm implementing (for better or worse) a network traffic buffer as a <code>std::list&lt;char&gt; buf</code>, and I'm maintaining my current read position as an iterator <code>readpos</code>.</p>\n<p>When I add data, I do something like</p>\n<pre><code>buf.insert(buf.end(), newdata.begin(), newdata.end());\n</code></pre>\n<p>My question is now, how do I keep the <code>readpos</code> iterator valid? If it points to the middle of the old <code>buf</code>, then it should be fine (by the iterator guarantees for std::list), but typically I may have read and processed all data and I have <code>readpos == buf.end()</code>. After the insertion, I want <code>readpos</code> <em>always</em> to point to the next unread character, which in case of the insertion should be the first inserted one.</p>\n<p>Any suggestions? (Short of changing the buffer to a <code>std::deque&lt;char&gt;</code>, which appears to be much better suited to the task, as suggested below.)</p>\n<p><strong>Update:</strong> From a quick test with GCC4.4 I observe that deque and list behave differently with respect to <code>readpos = buf.end()</code>: After inserting at the end, readpos is broken in a list, but points to the next element in a deque. <em>Is this a standard guarantee?</em></p>\n<p>(According to <a href=\"http://www.cplusplus.com/reference/stl/deque/insert/\" rel=\"nofollow\">cplusplus</a>, any deque::insert() <em>invalidated</em> all iterators. That's no good. Maybe using a counter is better than an iterator to track a position in a deque?)</p>\n</hr>", "AcceptedAnswerId": "6230632", "Title": "Keeping std::list iterators valid through insertion", "CreationDate": "2011-06-03T17:10:34.037", "Id": "6230350", "CommentCount": "6", "LastEditDate": "2012-10-29T16:34:00.937", "PostTypeId": "1", "LastEditorUserId": "168868", "LastActivityDate": "2014-06-16T20:21:16.880", "Score": "6", "OwnerUserId": "596781", "Tags": "<c++><iterator><stdlist>", "AnswerCount": "4"}, "6230433": {"Id": "6230433", "PostTypeId": "2", "Body": "<p><code>list&lt;char&gt;</code> is a very inefficient way to store a string.  It is probably 10-20 times larger than the string itself, plus you are chasing a pointer for every character...</p>\n<p>Have you considered using <code>std::dequeue&lt;char&gt;</code> instead?</p>\n<p>[edit]</p>\n<p>To answer your actual question, adding and removing elements does not invalidate iterators in a <code>list</code>...  But <code>end()</code> is still going to be <code>end()</code>.  So you would need to check for that as a special case at the point where you insert the new element in order to update your <code>readpos</code> iterator.</p>\n", "LastEditorUserId": "768469", "LastActivityDate": "2011-06-03T17:32:16.810", "Score": "-1", "CreationDate": "2011-06-03T17:17:55.187", "ParentId": "6230350", "CommentCount": "5", "OwnerUserId": "768469", "LastEditDate": "2011-06-03T17:32:16.810"}});