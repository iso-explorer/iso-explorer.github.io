post_cb({"22895526": {"Id": "22895526", "PostTypeId": "2", "Body": "<p>This is a good example of why it is typically best to <strong>make virtual functions private and public functions non-virtual</strong>. Herb Sutter once called this the <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"nofollow\">Non-Virtual Interface Idiom (NVI)</a>.</p>\n<p>Let's apply it to your code. I'll also change the function name \"SHOW\" to \"show\", because all-uppercase in C++ usually denotes a macro. Furthermore, I'll add a virtual destructor, because newbies are reading these questions and they shouldn't see a polymorphic class without one. Note that destructors are an exception to NVI.</p>\n<p>Here we go:</p>\n<pre><code>class Parent\n{\npublic:\n    void show(int x = 5) { doShow(x); }\n    virtual ~Parent() {}\nprivate:\n    virtual void doShow(int x) { cout &lt;&lt; \"PARENT \" &lt;&lt; x &lt;&lt; endl; }\n};\n\nclass Child : public Parent\n{\nprivate:\n    virtual void doShow(int x) { cout &lt;&lt; \"CHILD \" &lt;&lt; x &lt;&lt; endl; }\n};\n</code></pre>\n<p>Default arguments are usually useful for code which uses the objects of a class. That code then uses the public functions.</p>\n<pre><code>Parent *p = new Child;\np-&gt;show(); // here's where a default argument is a useful feature\ndelete p;\n</code></pre>\n<p>Inheriting classes, however, are interested in something completely different, namely in the virtual functions of the base class. It turns out that you rarely feel the need for default arguments when you write the code for a subclass.</p>\n<p>Bottom line:</p>\n<ol>\n<li>Default arguments and virtual functions shouldn't be mixed. There is an item for this in the famous <em>Effective C++</em> book by Scott Meyers: \"Never redefine an inherited default parameter value\". You should read that book.</li>\n<li>Using NVI, you will typically not have this problem anyway, because it turns out default arguments are more of a thing for public functions, and with NVI, public functions aren't virtual.</li>\n</ol>\n", "LastActivityDate": "2014-04-06T14:42:47.320", "CommentCount": "2", "CreationDate": "2014-04-06T14:42:47.320", "ParentId": "22895156", "Score": "1", "OwnerUserId": "3313064"}, "bq_ids": {"n4140": {"so_22895156_22895275_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 3261}}, "n3337": {"so_22895156_22895275_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 3133}}, "n4659": {"so_22895156_22895275_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 4019}}}, "22895275": {"Id": "22895275", "PostTypeId": "2", "Body": "<p>1)\nC++ Standard says</p>\n<blockquote>\n<p id=\"so_22895156_22895275_0\">A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object. An overriding function in a derived class does not acquire default arguments from the function it overrides.</p>\n</blockquote>\n<p>\u00a78.3.6/10</p>\n<p>2)\n<a href=\"https://stackoverflow.com/questions/484592/overriding-public-virtual-functions-with-private-functions-in-c\">Overriding public virtual functions with private functions in C++</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-06T14:20:08.777", "Score": "2", "CreationDate": "2014-04-06T14:20:08.777", "ParentId": "22895156", "CommentCount": "0", "OwnerUserId": "1210060", "LastEditDate": "2017-05-23T12:11:12.660"}, "22895294": {"Id": "22895294", "PostTypeId": "2", "Body": "<p>A virtual function call uses the default arguments in the declaration of the virtual function determined by the static type of the pointer you use to call the function. In your case the static type of P is Parent although the dynamic type resolves to Child. This is according to C++ standard.</p>\n", "LastActivityDate": "2014-04-06T14:21:19.690", "CommentCount": "0", "CreationDate": "2014-04-06T14:21:19.690", "ParentId": "22895156", "Score": "1", "OwnerUserId": "712219"}, "22895156": {"ViewCount": "94", "Body": "<p>I am having two problem about virtual methods.</p>\n<p>First:</p>\n<pre><code>class Parent\n{\npublic:\n    virtual void SHOW(int x = 5) { cout &lt;&lt; \"PARENT \" &lt;&lt; x &lt;&lt; endl; }\n};\n\nclass Child : public Parent\n{\npublic:\n    virtual void SHOW(int y = 10) { cout &lt;&lt; \"CHILD \" &lt;&lt; y &lt;&lt; endl; }\n};\n\nint main()\n{\n    Child Y;\n\n    Parent* P = &amp;Y;\n    P-&gt;SHOW();\n\n    getch();  \n    return 0;     \n}\n</code></pre>\n<p>I think tt should be <strong>CHILD 10</strong> but the result is <strong>CHILD 5</strong></p>\n<p>And another:</p>\n<pre><code>class Parent\n{\npublic:\n    virtual void SHOW() { cout &lt;&lt; \"PARENT\" &lt;&lt; endl; }\n};\n\nclass Child : public Parent\n{\nprivate:\n    virtual void SHOW() { cout &lt;&lt; \"CHILD\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    Child Y;\n    Parent* P = &amp;Y;\n    P-&gt;SHOW();\n\n    getch();  \n    return 0;     \n}\n</code></pre>\n<p>It'll show <strong>CHILD</strong> on the screen. I don't know how a private method which was called from outside?</p>\n<p>Thank you. I'm learning English so.. :)</p>\n", "Title": "C++ Class and virtual method", "CreationDate": "2014-04-06T14:09:06.453", "LastActivityDate": "2014-04-06T14:42:47.320", "CommentCount": "3", "PostTypeId": "1", "Id": "22895156", "Score": "1", "OwnerUserId": "3121995", "Tags": "<c++><class><virtual><private>", "AnswerCount": "3"}});