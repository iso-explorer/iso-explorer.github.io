post_cb({"23323585": {"ParentId": "23323510", "CommentCount": "1", "Body": "<p>If you don't explicitly define the underlying type, then compiler is free to choose an integral type which fits the values. To set the underlying type in C++11 you can use this:</p>\n<pre><code>enum A : char { a = 1, b, c }; \n       ^^^^^^\n</code></pre>\n<p>Your way will not force the compiler to use <code>char</code> instead if <code>int</code>.</p>\n", "OwnerUserId": "952747", "PostTypeId": "2", "Id": "23323585", "Score": "20", "CreationDate": "2014-04-27T12:45:37.337", "LastActivityDate": "2014-04-27T12:45:37.337"}, "23323510": {"CommentCount": "4", "AcceptedAnswerId": "23323585", "PostTypeId": "1", "LastEditorUserId": "2548699", "CreationDate": "2014-04-27T12:38:48.710", "LastActivityDate": "2014-04-27T19:31:51.977", "LastEditDate": "2014-04-27T13:42:07.580", "ViewCount": "1137", "FavoriteCount": "1", "Title": "Shouldn't the code print \" 1 1\" instead of \"4 4\"?", "Id": "23323510", "Score": "13", "Body": "<p>According to \u00a77.2/5 and \u00a77.2/6 shouldn't the <a href=\"http://coliru.stacked-crooked.com/a/4496d16bf4da56c1\" rel=\"noreferrer\">code below</a> print <code>1 1</code> instead of <code>4 4</code>?</p>\n<pre><code>#include &lt;iostream&gt;\nenum A { a = (char)1, b, c };   //  underlying type is not fixed\n\nint main() {\n    std::cout &lt;&lt; sizeof(a) &lt;&lt; ' ' &lt;&lt; sizeof(A) &lt;&lt; '\\n';\n}\n</code></pre>\n<p><strong>Edit</strong></p>\n<blockquote>\n<p id=\"so_23323510_23323510_0\">From \u00a77.2/5:</p>\n<p id=\"so_23323510_23323510_1\">If the underlying type is not fixed, the type of each enumerator is\n  the type of its initializing value:</p>\n<p id=\"so_23323510_23323510_2\">\u2014 If an initializer is specified for an enumerator, the initializing\n  value has the same type as the expression and the constant-expression\n  shall be an integral constant expression (5.19).</p>\n</blockquote>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "2548699", "AnswerCount": "4"}, "23323573": {"ParentId": "23323510", "CommentCount": "2", "Body": "<p>No.  It has been the case ever since ANSI C that conforming compilers often use <code>int</code> to store enums, even when all the values are small.</p>\n<p>Before you say this is insane and it should use the smallest type that works (which by the way GCC will do if you use <code>__attribute__((packed))</code>), think about ABI compatibility.  If you release a library which uses an enum type, you would prefer that the size of that type not change.  If all enums start life with 4 bytes, the likelihood is increased that simply relinking against an updated library will work.</p>\n", "OwnerUserId": "4323", "PostTypeId": "2", "Id": "23323573", "Score": "4", "CreationDate": "2014-04-27T12:44:32.347", "LastActivityDate": "2014-04-27T12:44:32.347"}, "23323548": {"ParentId": "23323510", "CommentCount": "0", "Body": "<p>This is implementation defined: the fact that all values of an <code>enum</code> fit in, say, a <code>uint8_t</code> does not force the compiler to pick a single-byte representation for the enumeration.</p>\n<blockquote>\n<p id=\"so_23323510_23323548_0\">The underlying type of an enumeration is an integral type that can represent all the enumerator values defined in the enumeration. <strong>It is implementation-defined which integral type is used as the underlying type for an enumeration</strong> except that the underlying type shall not be larger than int unless the value of an enumerator cannot fit in an int or <code>unsigned int</code>. (emphasis added)</p>\n</blockquote>\n<p>In your case it appears that the compiler implementers choose an <code>int</code>, which takes four bytes on your platform - a perfectly valid choice.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "23323548", "Score": "5", "CreationDate": "2014-04-27T12:42:25.310", "LastActivityDate": "2014-04-27T12:42:25.310"}, "23323551": {"ParentId": "23323510", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The clause you quote, 7.2/5, describes the types of the <em>enumerators</em>. But the enumerators only form part of the definition of the <em>enumeration</em>. The underlying type of the enumeration is large enough to hold the values all enumerators, subject to 7.2/6:</p>\n<blockquote>\n<p id=\"so_23323510_23323551_0\">It is implementation-defined which integral type is used as the underlying type except that the underlying type shall not be larger than <code>int</code> unless the value of an enumerator cannot fit in an <code>int</code> or <code>unsigned int</code>.</p>\n</blockquote>\n<p>So it is guaranteed that your underlying type is no larger than <code>int</code> (since <code>int</code> can represent 0, 1 and 2). It is true that the type of your first enumerator is <code>char</code> inside the enum definition, but all actual enum values are of type <code>A</code>. To actually control the underlying type, use the <em>enum-base</em> syntax (e.g. <code>enum A : char</code>), and to query it you can use the <code>std::underlying_type</code> trait.</p>\n<p>If you actually would like to see the effect of the enumerator's type in the definition, you can try something like this:</p>\n<pre><code>enum Foo { a = '\\010', b = sizeof(a) };\n\nstd::cout &lt;&lt; typeid(b).name() &lt;&lt; \"\\n\";    // some variant of \"Foo\"\nstd::cout &lt;&lt; b &lt;&lt; \"\\n\";                   // \"1\"\nstd::cout &lt;&lt; sizeof(b) &lt;&lt; \"\\n\";           // implementation-defined, not greater\n                                          // than sizeof(int)\n</code></pre>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2014-04-27T19:31:51.977", "Id": "23323551", "Score": "4", "CreationDate": "2014-04-27T12:42:55.527", "LastActivityDate": "2014-04-27T19:31:51.977"}, "bq_ids": {"n4140": {"so_23323510_23323510_2": {"section_id": 5464, "quality": 0.5384615384615384, "length": 7}, "so_23323510_23323548_0": {"section_id": 5466, "quality": 0.7941176470588235, "length": 27}, "so_23323510_23323510_1": {"section_id": 5464, "quality": 0.9, "length": 9}, "so_23323510_23323551_0": {"section_id": 5466, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_23323510_23323551_0": {"section_id": 5252, "quality": 0.9444444444444444, "length": 17}, "so_23323510_23323548_0": {"section_id": 5252, "quality": 0.8235294117647058, "length": 28}, "so_23323510_23323510_2": {"section_id": 5251, "quality": 0.9230769230769231, "length": 12}, "so_23323510_23323510_1": {"section_id": 5251, "quality": 1.0, "length": 10}}, "n4659": {"so_23323510_23323548_0": {"section_id": 6900, "quality": 0.7941176470588235, "length": 27}, "so_23323510_23323510_2": {"section_id": 6898, "quality": 0.5384615384615384, "length": 7}, "so_23323510_23323510_1": {"section_id": 6898, "quality": 0.9, "length": 9}, "so_23323510_23323551_0": {"section_id": 6900, "quality": 0.9444444444444444, "length": 17}}}});