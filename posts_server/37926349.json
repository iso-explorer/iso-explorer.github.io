post_cb({"37926420": {"Id": "37926420", "PostTypeId": "2", "Body": "<p><code>B</code> <em>will</em> be a complete type by the time someone gets round to using a particular template instance of <code>B</code>.</p>\n<p>Remember that template code is not \"compiled\" until an instance is created.</p>\n", "LastActivityDate": "2016-06-20T15:34:38.190", "Score": "2", "CreationDate": "2016-06-20T15:34:38.190", "ParentId": "37926349", "CommentCount": "0", "OwnerUserId": "3415258"}, "37926439": {"Id": "37926439", "PostTypeId": "2", "Body": "<p>Within an instantiation of a class template <code>X</code>, the name <code>X</code> can be used to refer either to the template or to the current instantiation of the template. </p>\n<p>From <a href=\"http://eel.is/c++draft/temp.local#1\" rel=\"nofollow\"><strong>[temp.local]</strong></a>:</p>\n<blockquote>\n<p id=\"so_37926349_37926439_0\">1 - Like normal (non-template) classes, class templates have an <em>injected-class-name</em> (Clause 9). The <em>injected-class-name</em>\n  can be used as a <em>template-name</em> or a <em>type-name</em>.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-20T15:35:33.923", "Score": "2", "CreationDate": "2016-06-20T15:35:33.923", "ParentId": "37926349", "CommentCount": "2", "OwnerUserId": "567292"}, "bq_ids": {"n4140": {"so_37926349_37926439_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 179}}, "n3337": {"so_37926349_37926439_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 173}}, "n4659": {"so_37926349_37926439_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 184}}}, "37926404": {"Id": "37926404", "PostTypeId": "2", "Body": "<p>Inside the scope of a <code>template</code> declaration, the template's name alone designates a complete type, for every automatically generated specialization, synonymous to that specialization. Consider, e.g.,</p>\n<pre><code>template&lt;class A&gt; struct B {\n    B();\n    B &amp;operator=(B const &amp;);\n    typedef B This;\n};\n</code></pre>\n", "LastEditorUserId": "2749717", "LastActivityDate": "2016-06-20T15:38:35.330", "Score": "3", "CreationDate": "2016-06-20T15:33:36.157", "ParentId": "37926349", "CommentCount": "5", "LastEditDate": "2016-06-20T15:38:35.330", "OwnerUserId": "2749717"}, "37926349": {"ViewCount": "63", "Body": "<p>Consider the following code:</p>\n<pre><code>template &lt;class MyB&gt;\nstruct A {\n    MyB *b_;\n};\n\ntemplate &lt;template &lt;class&gt; class MyA&gt;\nstruct B {\n    MyA&lt;B&gt; *a_; // How come B can be used as a complete type here?\n};\n</code></pre>\n<p>The comment states my question: <code>B</code> is a template, so how come it can be used as a complete type in <code>MyA&lt;B&gt;</code>? </p>\n", "AcceptedAnswerId": "37926404", "Title": "Using a template class as a template argument", "CreationDate": "2016-06-20T15:30:40.227", "Id": "37926349", "CommentCount": "1", "LastEditDate": "2016-06-20T15:35:18.740", "PostTypeId": "1", "LastEditorUserId": "675100", "LastActivityDate": "2016-06-20T15:39:12.793", "Score": "1", "OwnerUserId": "2725810", "Tags": "<c++><template-meta-programming>", "AnswerCount": "4"}, "37926504": {"Id": "37926504", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37926349_37926504_0\">How come B can be used as a complete type here?</p>\n</blockquote>\n<p><code>B</code> does not have to be a complete time for you to declare a pointer of type <code>MyA&lt;B&gt;</code>.</p>\n<p>You can use:</p>\n<pre><code>template &lt;typename T&gt; struct Foo { T* ptr;};\nstruct Bar;\nFoo&lt;Bar&gt;* ptr = nullptr;\n</code></pre>\n<p>You can even use:</p>\n<pre><code>template &lt;typename T&gt; struct Foo { T* ptr;};\nstruct Bar;\nFoo&lt;Bar&gt; obj;\n</code></pre>\n<p>since <code>Foo</code> does not depend on the definition of <code>Bar</code> in its own definition.</p>\n", "LastActivityDate": "2016-06-20T15:39:12.793", "Score": "0", "CreationDate": "2016-06-20T15:39:12.793", "ParentId": "37926349", "CommentCount": "0", "OwnerUserId": "434551"}});