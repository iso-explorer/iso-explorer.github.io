post_cb({"bq_ids": {"n4140": {"so_42048621_42084008_0": {"section_id": 263, "quality": 0.5789473684210527, "length": 11}, "so_42048621_42084008_1": {"section_id": 4706, "quality": 0.5666666666666667, "length": 17}}, "n3337": {"so_42048621_42084008_0": {"section_id": 254, "quality": 0.5789473684210527, "length": 11}, "so_42048621_42084008_1": {"section_id": 4515, "quality": 0.5666666666666667, "length": 17}}, "n4659": {"so_42048621_42084008_0": {"section_id": 4653, "quality": 0.6842105263157895, "length": 13}, "so_42048621_42084008_1": {"section_id": 6103, "quality": 0.5666666666666667, "length": 17}}}, "42048621": {"CommentCount": "0", "ViewCount": "259", "PostTypeId": "1", "LastEditorUserId": "990597", "CreationDate": "2017-02-05T04:43:26.643", "LastActivityDate": "2017-02-08T16:31:02.797", "Title": "Why is a template<typename...> not recognized as instantiatable through template<template<typename> typename>?", "LastEditDate": "2017-02-08T00:43:14.493", "Id": "42048621", "Score": "7", "Body": "<p>I'm trying to arbitrarily \"bind\" template parameters but have run into an elegance problem.</p>\n<p>To cut straight to the underlying problem, gcc 6.2 has a problem with the following but logically I see no issue with it...\n</p>\n<pre><code>template&lt;template&lt;typename, typename&gt; P, typename A, typename B&gt;\nstruct foo {\n    static constexpr bool value = P&lt;A, B&gt;::value;\n};\n\ntemplate&lt;typename...Ts&gt;\nstruct bar {\n    static constexpr bool value = true;\n};\n</code></pre>\n<p>... <code>foo</code> given <code>bar</code> such as <code>foo&lt;bar, void, void&gt;</code> should result in the instantiation of <code>bar&lt;void, void&gt;</code> (which is valid), who's <code>value</code> member is <code>true</code> and therefore <code>foo&lt;bar, void, void&gt;::value</code> is likewise <code>true</code>. <em>Effectively</em>, this <em>should</em> (in my mind) result in instantiated structs conceptually akin to...</p>\n<pre><code>struct bar&lt;void, void&gt; {\n    static constexpr bool value = true;\n};\n\nstruct foo&lt;bar, void, void&gt; {\n    static constexpr bool value = bar&lt;void, void&gt;::value; //which is true\n};\n</code></pre>\n<p>You can see this concept in action (or rather the error) here <a href=\"https://godbolt.org/g/lT9umg\" rel=\"nofollow noreferrer\">https://godbolt.org/g/lT9umg</a>.</p>\n<p>Back to the begining now, first I tried the following...\n</p>\n<pre><code>template&lt;typename...&gt;\nstruct type_list { };\n\ntemplate&lt;template&lt;typename...&gt; typename Tmpl, typename...Ts&gt;\nstruct bind_template {\n    template&lt;typename...Us&gt;\n    using type = Tmpl&lt;Ts..., Us...&gt;;\n};\n\ntemplate&lt;template&lt;typename&gt; typename Predicate, typename...Ts&gt;\nstruct has_matching_type {\n    private:\n        template&lt;template&lt;typename&gt; typename, typename, typename=void&gt;\n        struct helper: std::false_type { };\n        template&lt;template&lt;typename&gt; typename P, typename U, typename...Us&gt;\n        struct helper&lt;P, type_list&lt;U, Us...&gt;, typename std::enable_if&lt;P&lt;U&gt;::value&gt;::type&gt;: std::true_type { };\n        template&lt;template&lt;typename&gt; typename P, typename U, typename...Us&gt;\n        struct helper&lt;P, type_list&lt;U, Us...&gt;, typename std::enable_if&lt;!P&lt;U&gt;::value&gt;::type&gt;: helper&lt;P, type_list&lt;Us...&gt;&gt; { };\n    public:\n        static constexpr bool value = helper&lt;Predicate, type_list&lt;Ts...&gt;&gt;::value;\n};\n\ntemplate&lt;typename T, typename...Ts&gt;\nusing has_type = has_matching_type&lt;bind_template&lt;std::is_same, T&gt;::template type, Ts...&gt;;\n</code></pre>\n<p>Later I might try to instantiate through <code>has_type&lt;T, Ts...&gt;</code> such as...\n</p>\n<pre><code>cout &lt;&lt; has_type&lt;long, int, bool, long, float&gt;::value &lt;&lt; endl;\n</code></pre>\n<p>However, as I pointed out gcc 6.2.0 complains because it doesn't seem to recognize that, once resolution is done, the template instantiation is pragmatically equivalent.</p>\n<p>Simply knowing the number of template parameters and specializing for that exact number solves the problem. If I specialize <code>bound_template</code> keeping <code>std::is_same&lt;LHS, RHS&gt;</code> in mind...\n</p>\n<pre><code>template&lt;template&lt;typename, typename&gt; typename Tmpl, typename T&gt;\nstruct bind_template&lt;Tmpl, T&gt; {\n    template&lt;typename U&gt;\n    using type = Tmpl&lt;T, U&gt;;\n};\n</code></pre>\n<p>... we suddenly compile and evaluate compile-time no problem because gcc sees <code>bind_template&lt;std::is_same, long&gt;::type</code> as taking one type parameter exactly.</p>\n<p>Obviously, abstracting this concept out to allow for any template parameters, such as integral constants and not just types, is a fundamental issue regardless of compiler. Simply focusing on types for a minute though, my question is multiple:</p>\n<ol>\n<li>Am I missing something here conceptually and the compiler is actually doing exactly what should be obvious to me?</li>\n<li>If not, is this in violation of C++11 standards, not directed by standards, or is it a compiler dependency?</li>\n<li>Is there some elegant way I can get around this regardless of the answers to my first two questions?</li>\n</ol>\n<p>Functionally, the real question (particularly if this is an unavoidable issue in C++11) is...</p>\n<h2>Is there some elegant way I can abstractly bind templates without having to specialize for every case (the simplest here being <em>n</em> number of types)?</h2>\n<p>Just being able to get an answer to questions 1 or 3 would be great. Question 3 is the most important because at the end of the day it's what works that matters.</p>\n<p>Obviously, I can specialize (as shown above). A big problem though is that even the following doesn't seem to work (at least according to <a href=\"http://cpp.sh/9lrwd\" rel=\"nofollow noreferrer\">this online compiler</a>)...</p>\n<pre><code>template&lt;template&lt;typename...&gt; class Tmpl, typename... Ts&gt;\nstruct bind_helper {\n    template&lt;typename... Us&gt;\n    struct type: Tmpl&lt;Ts..., Us...&gt; { };\n    template&lt;typename A&gt;\n    struct type&lt;A&gt;: Tmpl&lt;Ts..., A&gt; { };\n    template&lt;typename A, typename B&gt;\n    struct type&lt;A, B&gt;: Tmpl&lt;Ts..., A, B&gt; { };\n    template&lt;typename A, typename B, typename C&gt;\n    struct type&lt;A, B, C&gt;: Tmpl&lt;Ts..., A, B, C&gt; { };\n};\n</code></pre>\n<p>This means that, not only would I have to generate a bunch of parameters, but I'd have to match the outer parameters as well via complete <code>bind_template</code> specialization. This quickly becomes (actually is) a binomial problem.</p>\n<p>Extending this concept further (but still keeping to types), I was planning to next implement \"placeholders\" the same way <code>std::bind</code> uses placeholders (which would have worked rather elegantly because I would have just peeled and rejoined the list at the index). Obviously this is too much of a mess to proceed without a more abstract approach available.</p>\n", "Tags": "<c++><c++11><templates><gcc><variadic-templates>", "OwnerUserId": "990597", "AnswerCount": "2"}, "42084008": {"ParentId": "42048621", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>This is fixed in C++17. Specifically, from <a href=\"http://eel.is/c++draft/temp.arg.template#3\">14.3.3 \"Template template arguments\", paragraph 3:</a></p>\n<blockquote id=\"so_42048621_42084008_0\">\n<pre><code>template&lt;class T&gt; class A { /* ... */ };\ntemplate&lt;class T, class U = T&gt; class B { /* ... */ };\ntemplate&lt;class ... Types&gt; class C { /* ... */ };\ntemplate&lt;auto n&gt; class D { /* ... */ };\ntemplate&lt;template&lt;class&gt; class P&gt; class X { /* ... */ };\ntemplate&lt;template&lt;class ...&gt; class Q&gt; class Y { /* ... */ };\ntemplate&lt;template&lt;int&gt; class R&gt; class Z { /* ... */ };\n\nX&lt;A&gt; xa;            // OK\nX&lt;B&gt; xb;            // OK\nX&lt;C&gt; xc;            // OK\nY&lt;A&gt; ya;            // OK\nY&lt;B&gt; yb;            // OK\nY&lt;C&gt; yc;            // OK\nZ&lt;D&gt; zd;            // OK\n</code></pre>\n</blockquote>\n<p>The relevant example here is <code>X&lt;C&gt;</code>. This works in g++ 7 with the flag <code>-std=c++1z</code>.</p>\n<p>C++14 specifies that the example above is ill-formed:</p>\n<blockquote id=\"so_42048621_42084008_1\">\n<pre><code>template&lt;class T&gt; class A { /\u2217 ... \u2217/ };\ntemplate&lt;class T, class U = T&gt; class B { /\u2217 ... \u2217/ };\ntemplate &lt;class ... Types&gt; class C { /\u2217 ... \u2217/ };\ntemplate&lt;template&lt;class&gt; class P&gt; class X { /\u2217 ... \u2217/ };\ntemplate&lt;template&lt;class ...&gt; class Q&gt; class Y { /\u2217 ... \u2217/ };\nX&lt;A&gt; xa; // OK\nX&lt;B&gt; xb; // ill-formed: default arguments for the parameters of a template argument are ignored\nX&lt;C&gt; xc; // ill-formed: a template parameter pack does not match a template parameter\n</code></pre>\n</blockquote>\n<p>The change came in late 2016 from the paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0522r0.html\">DR: Matching of template template-arguments excludes compatible templates</a>. The change was applied in <a href=\"https://github.com/cplusplus/draft/commit/4422e4105ce477ed325edc9535a6bf2fa9b2ed29\">this commit from November</a>. The issue has been <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4457.html#150\">known by the committee since 1999 or before</a>.</p>\n", "OwnerUserId": "388716", "LastEditorUserId": "388716", "LastEditDate": "2017-02-07T07:34:52.203", "Id": "42084008", "Score": "9", "CreationDate": "2017-02-07T07:22:38.530", "LastActivityDate": "2017-02-07T07:34:52.203"}, "42118594": {"ParentId": "42048621", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Before C++17, this code is ill-formed as-is, due to an unfortunate language defect as mentioned in <a href=\"https://stackoverflow.com/a/42084008/2069064\">jbapple's answer</a>.</p>\n<p>A C++11-conforming solution would be to switch from using metafunctions everywhere to using metafunction classes everywhere. A metafunction class, from Boost.MPL's definition, would be a type that has a template alias named <code>apply</code>. Which we can invoke thusly:</p>\n<pre><code>template &lt;class MFC, class... Ts&gt;\nusing apply_t = typename MFC::template apply&lt;Ts...&gt;;\n</code></pre>\n<p>We can lift a template into a metafunction class via:</p>\n<pre><code>template &lt;template &lt;typename...&gt; class Z&gt;\nstruct quote {\n    template &lt;class... Args&gt;\n    using apply = Z&lt;Args...&gt;;\n};\n</code></pre>\n<p>Then let's rewrite <code>bind_template</code> to take a metafunction class instead of a template:</p>\n<pre><code>template &lt;class MFC, class... Ts&gt;\nstruct bind_template {\n    template &lt;class... Us&gt;\n    using apply = apply_t&lt;MFC, Ts..., Us...&gt;;\n};\n</code></pre>\n<p>And then rewrite <code>has_matching_type</code> to take a metafunction class instead of a template:</p>\n<pre><code>template&lt;class Predicate, class... Ts&gt;\nstruct has_matching_type {\nprivate:\n    template&lt;class&gt;\n    struct helper: std::false_type { };\n\n    template&lt;typename U, typename...Us&gt;\n    struct helper&lt;type_list&lt;U, Us...&gt;&gt;\n        : std::conditional&lt;\n            apply_t&lt;Predicate, U&gt;::value,\n            std::true_type,\n            helper&lt;type_list&lt;Us...&gt;&gt;\n            &gt;::type\n     { };\n\npublic:\n    static constexpr bool value = helper&lt;type_list&lt;Ts...&gt;&gt;::value;\n};\n\ntemplate&lt;class T, class... Ts&gt;\nusing has_type = has_matching_type&lt;bind_template&lt;quote&lt;std::is_same&gt;, T&gt;, Ts...&gt;;\n</code></pre>\n<p>And now your initial <code>has_type&lt;long, int, bool, long, float&gt;::value</code> is <code>true</code>, even in C++11.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:26.887", "Id": "42118594", "Score": "3", "CreationDate": "2017-02-08T16:31:02.797", "LastActivityDate": "2017-02-08T16:31:02.797"}});