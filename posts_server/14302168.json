post_cb({"14302232": {"ParentId": "14302168", "CommentCount": "0", "Body": "<p>C style casting in c++ is not a good idea precisily because you go past the checks that prevent you from removing a const or changing the type arbitrary. If you want to make the code work as is you first need to const_cast and then reinterpret_cast, but <strong>really</strong> try to avoid const casting. To avoid the warning using reinterpret_cast simply declare a as <code>const T*</code>.</p>\n", "OwnerUserId": "812912", "PostTypeId": "2", "Id": "14302232", "Score": "0", "CreationDate": "2013-01-13T09:25:32.397", "LastActivityDate": "2013-01-13T09:25:32.397"}, "14302235": {"ParentId": "14302168", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C-style cast works because it takes many steps in order to make the cast succeed. It uses the first of the following that succeeds:</p>\n<pre><code>const_cast\nstatic_cast\nstatic_cast + const_cast\nreinterpret_cast\nreinterpret_cast + const_cast\n</code></pre>\n<p>In this case, it's doing the most 'powerful' cast, a <code>reinterpret_cast</code> to <code>const int *</code> followed by <code>const_cast</code> to <code>int*</code>.</p>\n<p>The <code>reinterpret_cast</code> alone won't compile, because you're casting away const-ness. The <code>const_cast</code> is required to cast to <code>int*</code>. Doing a <code>reinterpret_cast</code> to <code>const int*</code> would be fine, however.</p>\n<p>As an aside, what you're doing is generally unsafe, unless you're using a compiler extension to ensure that any user-defined type you're deserializing to isn't padded.</p>\n", "OwnerUserId": "214796", "LastEditorUserId": "214796", "LastEditDate": "2013-01-13T09:39:57.443", "Id": "14302235", "Score": "2", "CreationDate": "2013-01-13T09:25:50.913", "LastActivityDate": "2013-01-13T09:39:57.443"}, "14302168": {"CommentCount": "1", "ViewCount": "209", "PostTypeId": "1", "LastEditorUserId": "1248779", "CreationDate": "2013-01-13T09:16:23.400", "LastActivityDate": "2013-01-13T10:23:34.633", "Title": "safety in std::vector memory manipulation", "AcceptedAnswerId": "14302247", "LastEditDate": "2013-01-13T09:19:46.860", "Id": "14302168", "Score": "1", "Body": "<p>I have this following code</p>\n<pre><code>size_t returnSize(const char* s)\n{\n       string string(s);\n       return string.size();\n};\n\nsize_t returnSize(const int&amp; i)\n{\n       return sizeof(i);\n};\n\n\ntemplate&lt;typename T&gt;\nvector&lt;char&gt; Serialize(const T&amp; t)\n{\n    T* pt = new T(t);\n    vector&lt;char&gt; CasttoChar;\n\n    for (int i =0 ;i&lt;returnSize(t);i++)\n    {\n        CasttoChar.push_back(reinterpret_cast&lt;const char*&gt;(pt)[i]);\n    }\n    delete pt;\n    return CasttoChar;\n};\ntemplate&lt;typename T&gt;\nT DeSerialize(const vector&lt;char&gt; cstr)\n{\n    T* a = (T*)(&amp;cstr[0]);\n\n    return *a;\n}\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    int x = 97;\n    vector&lt;char&gt; c = Serialize(x);\n    cout &lt;&lt; DeSerialize&lt;int&gt;(c) &lt;&lt; endl;\n\n    string k = \"blabla\";\n    vector&lt;char&gt; c3 = Serialize(k.c_str());\n    cout &lt;&lt; DeSerialize&lt;const char*&gt;(c3) &lt;&lt; endl;\n\n    system(\"PAUSE\");\n    return EXIT_SUCCESS;\n}\n\n//output is \n//97\n//blabla\n</code></pre>\n<p>Is this line <code>T* a = (T*)(&amp;cstr[0]);</code> safe? </p>\n<p>Also, I tried <code>reinterpret_cast&lt;T*&gt;(&amp;cstr[0]);</code> instead of <code>T* a = (T*)(&amp;cstr[0]);</code> but compiler complained about not being able to convert const char* to int*. so why does the C style cast work?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "1248779", "AnswerCount": "5"}, "14302241": {"ParentId": "14302168", "CommentCount": "0", "Body": "<p>Stick to C++ casts. The reason the <code>reinterpret_cast</code> didn't work is you were casting away constness, which isn't cool; you have to use a <code>const_cast</code> for that and you just shouldn't. C casts ignore this.</p>\n<p>Having said that, what are you trying to achieve here? You have effectively casting to a <code>char</code> array and <code>memcpy</code>ing without the efficiency that would bring.</p>\n", "OwnerUserId": "961353", "PostTypeId": "2", "Id": "14302241", "Score": "0", "CreationDate": "2013-01-13T09:26:29.633", "LastActivityDate": "2013-01-13T09:26:29.633"}, "14302247": {"ParentId": "14302168", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Refer the standard</p>\n<p><b>Why reinterpret_cast fails?</b></p>\n<blockquote>\n<p id=\"so_14302168_14302247_0\">5.2.10 Reinterpret cast [expr.reinterpret.cast]</p>\n<p id=\"so_14302168_14302247_1\">The reinterpret_cast operator shall not cast away constness (5.2.11).\n  An expression of integral, enumeration, pointer, or pointer-to-member\n  type can be explicitly converted to its own type; such a cast yields\n  the value of its operand.</p>\n</blockquote>\n<p><b> Should I use C Cast? </b>\nNo. Using C Cast instead of C++ Cast is always unsafe. You are trying to remove the constness of an Object which is an UB.\nUsing reinterpret_cast, will actually trap this error and advise you of during compile time of the potential pitfall.</p>\n<p>You should actually use <code>const_cast</code> in this situation. Its the only legal way to convert a <code>const</code> object to a non <code>const</code> object</p>\n<p><b>But Why does a C Cast works</b></p>\n<p>Quoting from the accepted answer from the Question <a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterpret-cast-be-used\">When should static_cast, dynamic_cast and reinterpret_cast be used?</a></p>\n<blockquote>\n<p id=\"so_14302168_14302247_2\">A C-style cast is defined as the first of the following which\n  succeeds:</p>\n<pre><code>const_cast\nstatic_cast\nstatic_cast, then const_cast\nreinterpret_cast\nreinterpret_cast, then const_cast\n</code></pre>\n</blockquote>\n<p>So fortunately, it tries the <code>const_cast</code> first.</p>\n", "OwnerUserId": "977038", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:04:34.530", "Id": "14302247", "Score": "3", "CreationDate": "2013-01-13T09:27:15.307", "LastActivityDate": "2013-01-13T09:32:34.770"}, "bq_ids": {"n4140": {"so_14302168_14302247_1": {"section_id": 6041, "quality": 0.92, "length": 23}}, "n3337": {"so_14302168_14302247_1": {"section_id": 5809, "quality": 0.92, "length": 23}}, "n4659": {"so_14302168_14302247_1": {"section_id": 7540, "quality": 0.92, "length": 23}}}, "14302538": {"ParentId": "14302168", "CommentCount": "0", "Body": "<p>Sorry to chime in here, but your code is broken in several ways, and the casting is just one of them. Concerning the casting, as soon as you use the conversion from/to vector on something that is not just a simple int or so but requires a constructor it will fail. In any case, a two-step conversions from <code>char const*</code> to <code>void const*</code> to <code>T const*</code> is unfortunately necessary.</p>\n<p>Now, other problems:</p>\n<ul>\n<li>Try the whole thing with a zero-size string. This should now fully answer your actual question, too: No, it's not safe.</li>\n<li>You are returning a pointer to a char from <code>DeSerialize&lt;char const*&gt;()</code>. This pointer points into memory owned by the given vector, which is passed by value and after returning from that function ceases to exist! It is pure luck that it seems to work.</li>\n<li>Even if you managed to somehow return a <code>char const*</code> from the function, think about who owns that memory now. The point is that this owner must also release the memory. Consider using <code>std::string</code> and making the <code>char const*</code> variant not compile using a specialization of your template.</li>\n<li>In general, if you mean this code earnest, begin adding unit tests. It might slow you down now but avoids errors while you go, thus saving time overall. Search for \"test-driven development\".</li>\n<li>There is nothing that assures that the string is NUL-terminated.</li>\n<li>Don't use new/delete unless you have to, prefer \"plain\" stack variables. If you do, take care of properly releasing the memory in case of exceptions (from push_back()). Use auto_ptr  (C++98) or unique_ptr (C++11) to make sure the memory is released correctly.</li>\n</ul>\n", "OwnerUserId": "1968182", "PostTypeId": "2", "Id": "14302538", "Score": "0", "CreationDate": "2013-01-13T10:23:34.633", "LastActivityDate": "2013-01-13T10:23:34.633"}});