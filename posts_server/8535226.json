post_cb({"8535257": {"ParentId": "8535226", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-12-16T14:00:46.393", "Score": "17", "LastEditorUserId": "1090079", "LastEditDate": "2011-12-16T18:54:48.650", "Id": "8535257", "OwnerUserId": "1090079", "Body": "<p>It cannot return a <em>lvalue</em> since it will have to implicitly promote the type of <code>x</code> to match the type of <code>y</code> (since both sides of <code>:</code> are not of the same type), and with that it has to create a temporary.</p>\n<hr>\n<h2>What does the standard say? (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"noreferrer\">n1905</a>)</h2>\n<p><strong>Expressions   5.17    Assignment and compound assignment operators</strong></p>\n<blockquote>\n<p id=\"so_8535226_8535257_0\"><strong>5.17/3</strong></p>\n<p id=\"so_8535226_8535257_1\">If the second and third operand have different types, and either has (possibly cv-qualified) class type, an attempt is made to convert each of those operands to the type of the other. The process for determining whether an operand expression E1 of type T1 can be converted to match an operand expression E2 of type T2 is defined as follows:</p>\n<p id=\"so_8535226_8535257_2\">\u2014 If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (clause 4) to the type \u201creference to T2\u201d, subject to the constraint that in the conversion the reference must bind directly (8.5.3) to E1.</p>\n<p id=\"so_8535226_8535257_3\">\u2014 If E2 is an rvalue, or if the conversion above cannot be done:</p>\n<p id=\"so_8535226_8535257_4\">\u2014 if E1 and E2 have class type, and the underlying class types are the same or one is a base class of the other: E1 can be converted to match E2 if the class of T2 is the same type as, or a base class of, the class of T1, and the cv-qualification of T2 is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification of T1. If the conversion is applied, E1 is changed to an rvalue of type T2 that still refers to the original source class object (or the appropriate subobject thereof). [<em>Note: that is, no copy is made. \u2014 end note</em>] by copy-initializing a temporary of type T2 from E1 and using that temporary as the converted operand.</p>\n<p id=\"so_8535226_8535257_5\">Otherwise (i.e., if <code>E1</code> or E2 has a non class type, or if they both have class types but the underlying classes are not either the same or one a base class of the other): E1 can be converted to match E2 if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted to an rvalue (or the type it has, if E2 is an rvalue).</p>\n<p id=\"so_8535226_8535257_6\">Using this process, It is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand. If both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed. If neither can be converted, the operands are left unchanged and further checking is performed as described below. If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted operand is used in place of the original operand for the remainder of this section.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_8535226_8535257_7\"><strong>5.17/4</strong></p>\n<p id=\"so_8535226_8535257_8\">If the second and third operands are lvalues and have the same type, the result is of that type and is an lvalue and it is a bit-field if the second or the third operand is a bit-field, or if both are bit-fields.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_8535226_8535257_9\"><strong>5.17/5</strong></p>\n<p id=\"so_8535226_8535257_10\">Otherwise, the result is an rvalue. If the second and third operands do not have the same type, and either has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise, the conversions thus determined are applied, and the converted operands are used in place of the original operands for the remainder of this section.</p>\n</blockquote>\n</hr></hr></hr>", "LastActivityDate": "2011-12-16T18:54:48.650"}, "8535226": {"CommentCount": "3", "AcceptedAnswerId": "8535301", "PostTypeId": "1", "LastEditorUserId": "319931", "CreationDate": "2011-12-16T13:57:39.373", "LastActivityDate": "2016-06-22T10:43:31.333", "LastEditDate": "2012-09-24T21:27:13.843", "ViewCount": "15710", "FavoriteCount": "32", "Title": "Return type of '?:' (ternary conditional operator)", "Id": "8535226", "Score": "196", "Body": "<p>Why does the first return a reference?</p>\n<pre><code>int x = 1;\nint y = 2;\n(x &gt; y ? x : y) = 100;\n</code></pre>\n<p>While the second does not?</p>\n<pre><code>int x = 1;\nlong y = 2;\n(x &gt; y ? x : y) = 100;\n</code></pre>\n<p>Actually, the second did not compile at all - \"not lvalue left of assignment\".</p>\n", "Tags": "<c++><types><reference><conditional-operator><lvalue>", "OwnerUserId": "312896", "AnswerCount": "3"}, "8535244": {"ParentId": "8535226", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2011-12-16T13:59:32.290", "Score": "53", "LastEditorUserId": "76722", "LastEditDate": "2012-05-10T20:59:08.427", "Id": "8535244", "OwnerUserId": "500104", "Body": "<p>The type of the ternary <code>?:</code> expression is the common type of its second and third argument. If both types are the same, you get a reference back. If they are convertable to each other, one gets chosen and the other gets converted (promoted in this case). Since you can't return an lvalue reference to a temporary (the converted / promoted variable), its type is a value type.</p>\n", "LastActivityDate": "2012-05-10T20:59:08.427"}, "bq_ids": {"n4140": {"so_8535226_8535257_10": {"section_id": 6171, "quality": 0.9210526315789473, "length": 35}, "so_8535226_8535257_1": {"section_id": 6169, "quality": 0.9705882352941176, "length": 33}, "so_8535226_8535257_4": {"section_id": 6169, "quality": 0.7169811320754716, "length": 38}, "so_8535226_8535257_5": {"section_id": 6169, "quality": 0.8787878787878788, "length": 29}, "so_8535226_8535257_2": {"section_id": 6169, "quality": 0.8888888888888888, "length": 16}, "so_8535226_8535257_8": {"section_id": 6170, "quality": 0.8823529411764706, "length": 15}, "so_8535226_8535257_3": {"section_id": 3296, "quality": 0.8, "length": 4}, "so_8535226_8535257_6": {"section_id": 6169, "quality": 1.0, "length": 55}}, "n3337": {"so_8535226_8535257_10": {"section_id": 5932, "quality": 0.9210526315789473, "length": 35}, "so_8535226_8535257_1": {"section_id": 5930, "quality": 0.9705882352941176, "length": 33}, "so_8535226_8535257_2": {"section_id": 5930, "quality": 0.8888888888888888, "length": 16}, "so_8535226_8535257_5": {"section_id": 5930, "quality": 0.8787878787878788, "length": 29}, "so_8535226_8535257_4": {"section_id": 5930, "quality": 0.7169811320754716, "length": 38}, "so_8535226_8535257_8": {"section_id": 5931, "quality": 0.8823529411764706, "length": 15}, "so_8535226_8535257_3": {"section_id": 3166, "quality": 0.8, "length": 4}, "so_8535226_8535257_6": {"section_id": 5930, "quality": 1.0, "length": 55}}, "n4659": {"so_8535226_8535257_2": {"section_id": 4087, "quality": 0.5555555555555556, "length": 10}, "so_8535226_8535257_1": {"section_id": 7667, "quality": 0.7352941176470589, "length": 25}, "so_8535226_8535257_10": {"section_id": 7669, "quality": 0.9210526315789473, "length": 35}, "so_8535226_8535257_8": {"section_id": 7668, "quality": 0.8823529411764706, "length": 15}, "so_8535226_8535257_3": {"section_id": 4058, "quality": 0.8, "length": 4}, "so_8535226_8535257_6": {"section_id": 7667, "quality": 0.6909090909090909, "length": 38}}}, "8535301": {"ParentId": "8535226", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2011-12-16T14:05:08.010", "Score": "163", "LastEditorUserId": "1698143", "LastEditDate": "2016-06-22T10:43:31.333", "Id": "8535301", "OwnerUserId": "19563", "Body": "<p>Expressions don't have return types, they have a type and - as it's known in the latest C++ standard - a value category.</p>\n<p>A conditional expression can be an <em>lvalue</em> or an <em>rvalue</em>. This is its value category. (This is somewhat of a simplification, in <code>C++11</code> we have lvalues, xvalues and prvalues.)</p>\n<p>In very broad and simple terms, an <em>lvalue</em> refers to an object in memory and an <em>rvalue</em> is just a value that may not necessarily be attached to an object in memory.</p>\n<p>An assignment expression assigns a value to an object so the thing being assigned to must be an <em>lvalue</em>.</p>\n<p>For a conditional expression (<code>?:</code>) to be an <em>lvalue</em> (again, in broad and simple terms), <strong>the second and third operands must be <em>lvalues</em> of the same type</strong>. This is because the type and value category of a conditional expression is determined at compile time and must be appropriate whether or not the condition is true. If one of the operands must be converted to a different type to match the other then the conditional expression cannot be an <em>lvalue</em> as the result of this conversion would not be an <em>lvalue</em>.</p>\n<blockquote>\n<p id=\"so_8535226_8535301_0\">ISO/IEC 14882:2011 references:</p>\n<p id=\"so_8535226_8535301_1\">3.10 [basic.lval] Lvalues and rvalues (about value categories)</p>\n<p id=\"so_8535226_8535301_2\">5.15 [expr.cond] Conditional operator (rules for what type and value category a conditional expression has)</p>\n<p id=\"so_8535226_8535301_3\">5.17 [expr.ass] Assignment and compound assignment operators (requirement that the l.h.s. of an assignment must be a modifiable lvalue)</p>\n</blockquote>\n", "LastActivityDate": "2016-06-22T10:43:31.333"}});