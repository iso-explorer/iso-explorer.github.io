post_cb({"bq_ids": {"n4140": {"so_19365571_19406528_1": {"section_id": 162, "quality": 0.9655172413793104, "length": 28}, "so_19365571_19406528_2": {"section_id": 321, "quality": 0.8823529411764706, "length": 60}, "so_19365571_19406528_5": {"section_id": 336, "quality": 1.0, "length": 9}, "so_19365571_19406528_0": {"section_id": 161, "quality": 0.9767441860465116, "length": 42}}, "n3337": {"so_19365571_19406528_1": {"section_id": 156, "quality": 0.9655172413793104, "length": 28}, "so_19365571_19406528_2": {"section_id": 311, "quality": 0.8823529411764706, "length": 60}, "so_19365571_19406528_5": {"section_id": 326, "quality": 1.0, "length": 9}, "so_19365571_19406528_0": {"section_id": 155, "quality": 0.9767441860465116, "length": 42}}, "n4659": {"so_19365571_19406528_5": {"section_id": 345, "quality": 1.0, "length": 9}, "so_19365571_19406528_2": {"section_id": 329, "quality": 0.8823529411764706, "length": 60}, "so_19365571_19406528_1": {"section_id": 166, "quality": 0.9655172413793104, "length": 28}, "so_19365571_19406528_0": {"section_id": 165, "quality": 0.9767441860465116, "length": 42}}}, "19365700": {"ParentId": "19365571", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2013-10-14T17:21:27.550", "Score": "6", "LastEditorUserId": "2073257", "LastEditDate": "2013-10-14T17:51:49.937", "Id": "19365700", "OwnerUserId": "2073257", "Body": "<p>In the second overload, the <code>std::tuple_size&lt;Tuple&gt;::value-1</code> part depends on the template parameter <code>Tuple</code> and is hence not a better match or, in C++ speak, \"more specialized\". This is why it is considered equal wrt overloading with the third one which explicitly has <code>N</code>.</p>\n<p>Only your first overload uses a constant value of <code>0</code> which is not dependent on <code>Tuple</code> and is therefore a better match.</p>\n<hr>\n<p>In case you want to solve your problem, you can disable the third overload for when it would match the second one:</p>\n<pre><code>template &lt;typename Tuple, int N&gt;\ntypename std::enable_if&lt; N != std::tuple_size&lt;Tuple&gt;::value-1, double &gt;::type\nresult(const Tuple&amp; t, const A&lt;N, typename std::tuple_element&lt;N, Tuple&gt;::type&gt;&amp; a)\n{\n  return 0.5;\n}\n</code></pre>\n</hr>", "LastActivityDate": "2013-10-14T17:51:49.937"}, "19406528": {"ParentId": "19365571", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-10-16T14:45:29.163", "Score": "6", "LastEditorUserId": "819272", "LastEditDate": "2013-10-16T20:12:08.517", "Id": "19406528", "OwnerUserId": "819272", "Body": "<p><strong>TLDR;</strong> The reason that your program fails to compile is that the second and third overload are equally good matches during overload resolution. In particular, neither is more specialized than the other. Because overload resolution cannot select a best match, the program is ill-formed. The cure is to SFINAE your way out of it.</p>\n<h2>The problem</h2>\n<p><strong>14.5.6.2 Partial ordering of function templates [temp.func.order]</strong></p>\n<blockquote>\n<p id=\"so_19365571_19406528_0\">2 Partial ordering selects which of two function templates is more\n  specialized than the other by transforming each template in turn (see\n  next paragraph) and performing template argument deduction using the\n  function type. The deduction process determines whether one of the\n  templates is more specialized than the other. If so, the more\n  specialized template is the one chosen by the partial ordering\n  process. </p>\n<p id=\"so_19365571_19406528_1\">3 To produce the transformed template, for each type,\n  non-type, or template template parameter (including template parameter\n  packs (14.5.3) thereof) synthesize a unique type, value, or class\n  template respectively and substitute it for each occurrence of that\n  parameter in the function type of the template.</p>\n</blockquote>\n<p>For all three overloads, the first synthesized argument is equal, and since all arguments are considered one by one, we can focus on the second one. </p>\n<p>Your first overload is transformed to the following synthesized 2nd argument</p>\n<pre><code>const A&lt;0, typename std::tuple_element&lt;0, Arg1&gt;::type&gt;&amp;\n</code></pre>\n<p>Your second overload is transformed to the following synthesized 2nd argument</p>\n<pre><code>const A&lt;\n        std::tuple_size&lt;Arg1&gt;::value-1, typename        \n        std::tuple_element&lt;std::tuple_size&lt;Arg1&gt;::value-1, Arg1&gt;::type\n&gt;&amp;\n</code></pre>\n<p>Your third overload is transformed to the following synthesized 2nd argument</p>\n<pre><code>const A&lt;Arg2, typename std::tuple_element&lt;Arg2, Arg1&gt;::type&gt;&amp;    \n</code></pre>\n<p><strong>14.8.2.4 Deducing template arguments during partial ordering [temp.deduct.partial]</strong></p>\n<blockquote>\n<p id=\"so_19365571_19406528_2\">2 Two sets of types are used to determine the partial ordering. For\n  each of the templates involved there is the original function type and\n  the transformed function type. [ Note: The creation of the transformed\n  type is described in 14.5.6.2. \u2014 end note ] The deduction process uses\n  the transformed type as the argument template and the original type of\n  the other template as the parameter template. This process is done\n  twice for each type involved in the partial ordering comparison: once\n  using the transformed template-1 as the argument template and\n  template-2 as the parameter template and again using the transformed\n  template-2 as the argument template and template-1 as the parameter\n  template.</p>\n</blockquote>\n<p>It is clear that the first and second overload have no 2nd template parameter to deduce and so they are at least as specialized as the third overload. The question is whether the third can have it's <code>N</code> parameter deduced from the first and second overloads' synthesized 2nd argument. </p>\n<p>For the first overload, this is true for <code>N=0</code>, and so the first overload is more specialized than the third. This is why your first function call selects the first overload.</p>\n<p>For the third overload, argument deduction does not take place it is a non-deduced context:</p>\n<p><strong>14.8.2.5 Deducing template arguments from a type [temp.deduct.type]</strong></p>\n<blockquote>\n<p id=\"so_19365571_19406528_3\">5 The non-deduced contexts are: </p>\n<p id=\"so_19365571_19406528_4\">\u2014 ... </p>\n<p id=\"so_19365571_19406528_5\">\u2014 <strong>A non-type template argument or an array bound in which a subexpression references a template parameter.</strong></p>\n<p id=\"so_19365571_19406528_6\">\u2014 ... </p>\n</blockquote>\n<p>This means that the third overload is also at least as specialized as the second one. Hence, overload resolution is not able to select one, and the program is ill-formed.</p>\n<h2>The cure</h2>\n<p>Simply make two overloads with a non-overlapping condition inside an <code>enable_if</code> (using SFINAE). This bypasses overload resolution in this case.</p>\n<pre><code>template &lt;typename Tuple, int N&gt;\ntypename std::enable_if&lt;N == std::tuple_size&lt;Tuple&gt;::value-1, double&gt;::type\nresult(const Tuple&amp; t, const A&lt;N, typename std::tuple_element&lt;N, Tuple&gt;::type&gt;&amp; a)\n{\n  return 1;\n}\n\ntemplate &lt;typename Tuple, int N&gt;\ntypename std::enable_if&lt;N != std::tuple_size&lt;Tuple&gt;::value-1, double&gt;::type\nresult(const Tuple&amp; t, const A&lt;N, typename std::tuple_element&lt;N, Tuple&gt;::type&gt;&amp; a)\n{\n  return 0.5;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/52a5b9844d6d1296\" rel=\"nofollow\"><strong>Live Example</strong></a>.</p>\n", "LastActivityDate": "2013-10-16T20:12:08.517"}, "19366031": {"ParentId": "19365571", "CommentCount": "1", "Body": "<p>You should replace your overloads with some tag dispatching.</p>\n<p>Write one function, then check if the second arg <code>A</code> <code>is_same</code> as the first type in the tuple in a static way, calling another function with a type dependent on that.  Repeat for last on the false branch.</p>\n<pre><code> helper( t, a, std::is_same&lt;A, std::tuple_element&lt;0, Tuple&gt;&gt;() );\n</code></pre>\n<p>with maybe some <code>decay</code> or <code>remove_const</code> in there.</p>\n<p>The idea is that <code>std::is_same&lt;X,Y&gt;</code> is <code>true_type</code> if they are the same, and <code>false_type</code> otherwise.  <code>helper</code> overloads the third argument on both true and false type, giving you a compile time branch.  Repeat again for the last type, and you are done. </p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "19366031", "Score": "3", "CreationDate": "2013-10-14T17:46:41.320", "LastActivityDate": "2013-10-14T17:46:41.320"}, "19365571": {"CommentCount": "2", "AcceptedAnswerId": "19406528", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-10-14T17:13:18.933", "LastActivityDate": "2013-10-16T20:12:08.517", "LastEditDate": "2013-10-16T15:04:49.453", "ViewCount": "309", "FavoriteCount": "1", "Title": "Overloading of C++ templated functions", "Id": "19365571", "Score": "5", "Body": "<p>I would think that the following code should be working, but both g++ and clang++ return the exact same error (although Visual C++ 2012 doesn't).</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n\ntemplate &lt;int N, typename T&gt;\nstruct A { };\n\ntemplate &lt;typename Tuple&gt;\ndouble result(const Tuple&amp; t, const A&lt;0, typename std::tuple_element&lt;0, Tuple&gt;::type&gt;&amp; a)\n{\n  return 0;\n}\n\ntemplate &lt;typename Tuple&gt;\ndouble result(const Tuple&amp; t, const A&lt;std::tuple_size&lt;Tuple&gt;::value-1,\n                                      typename std::tuple_element&lt;std::tuple_size&lt;Tuple&gt;::value-1,Tuple&gt;::type&gt;&amp; a)\n{\n  return 1;\n}\n\ntemplate &lt;typename Tuple, int N&gt;\ndouble result(const Tuple&amp; t, const A&lt;N, typename std::tuple_element&lt;N, Tuple&gt;::type&gt;&amp; a)\n{\n  return 0.5;\n}\n\nint main()\n{\n  auto a = std::make_tuple(0, 1, 2., 3., 4);\n  std::cout &lt;&lt; result(a, A&lt;0,int&gt;()) &lt;&lt; std::endl;\n  std::cout &lt;&lt; result(a, A&lt;2,double&gt;()) &lt;&lt; std::endl;\n  std::cout &lt;&lt; result(a, A&lt;4,int&gt;()) &lt;&lt; std::endl; // Fails if uncommented\n  return 0;\n}\n</code></pre>\n<p>The error is due to the last line and the fact that the second and third <code>result</code> functions are considered equivalent. Although I would think the second one is a better fit than the third one (like the first one is).</p>\n<p>I am not sure though. Can anybody tell me if I am wrong or if the compiler is?</p>\n", "Tags": "<c++><templates><c++11><function-overloading><overload-resolution>", "OwnerUserId": "7136", "AnswerCount": "3"}});