post_cb({"6981152": {"Id": "6981152", "PostTypeId": "2", "Body": "<p>You cannot directly call main() (it's forbidden in c++), so there is no point of inlining it.</p>\n", "LastActivityDate": "2011-08-08T11:01:46.490", "CommentCount": "1", "CreationDate": "2011-08-08T11:01:46.490", "ParentId": "6981104", "Score": "17", "OwnerUserId": "650405"}, "6981157": {"Id": "6981157", "PostTypeId": "2", "Body": "<p>The C runtime library needs to find this symbol in order to \"know\" which function to run.</p>\n", "LastActivityDate": "2011-08-08T11:02:16.747", "CommentCount": "3", "CreationDate": "2011-08-08T11:02:16.747", "ParentId": "6981104", "Score": "27", "OwnerUserId": "135811"}, "7445816": {"Id": "7445816", "PostTypeId": "2", "Body": "<p>Inline functions are having static scope by-default. It means if we declare main() as inline, it's scope will be limited to the file where it is defined. Yet, the C start-up library (provided by compiler vendor) needs 'main' to be a global symbol. There are some compilers that allow to modify entry point function (e.g. main) using linker flags.</p>\n", "LastActivityDate": "2011-09-16T13:57:31.493", "CommentCount": "0", "CreationDate": "2011-09-16T13:57:31.493", "ParentId": "6981104", "Score": "1", "OwnerUserId": "751865"}, "6983754": {"Id": "6983754", "PostTypeId": "2", "Body": "<p>Since its the main() function, which starts the execution, when the code gets compiled to binary, everything is in the <code>main()</code> itself. so you can say, it already inlined!</p>\n<p>And yes, its illegal to use inline for your C++ program, that's more about a syntax!</p>\n", "LastActivityDate": "2011-08-08T14:35:31.883", "CommentCount": "0", "CreationDate": "2011-08-08T14:35:31.883", "ParentId": "6981104", "Score": "1", "OwnerUserId": "556087"}, "6981104": {"ViewCount": "4837", "Body": "<p>I was reading the C++ FAQs and I noticed one sentence.</p>\n<blockquote>\n<p id=\"so_6981104_6981104_0\">main() cannot be inline. </p>\n</blockquote>\n<p>Why is this?</p>\n", "Title": "Why main() in C++ cannot be inlined?", "CreationDate": "2011-08-08T10:56:52.413", "LastActivityDate": "2012-11-16T21:22:29.707", "CommentCount": "11", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2011-08-08T15:16:22.317", "LastEditorUserId": "106435", "Id": "6981104", "Score": "62", "OwnerUserId": "883890", "Tags": "<c++><inline><main>", "AnswerCount": "17"}, "7002566": {"Id": "7002566", "PostTypeId": "2", "Body": "<p>I see the standard says so, but the real practical answer would be as simple as stating that the runtime added to every C and C++ program has to call to some point in the executable. That function should have an external symbol (and address when running) so that the linker can find it to be called at the beginning of execution. Hence you cannot declare it as <code>inline</code>, because inlined the compiler wouldn't generate an external symbol for it.</p>\n", "LastActivityDate": "2011-08-09T20:31:22.760", "CommentCount": "2", "CreationDate": "2011-08-09T20:31:22.760", "ParentId": "6981104", "Score": "2", "OwnerUserId": "62365"}, "6981246": {"Id": "6981246", "PostTypeId": "2", "Body": "<p>If you linked statically to the CRT <em>and</em> enabled some link-time compilation-inlining (like MSVC has) it might be possible to inline it.</p>\n<p>But it doesn't really make sense. It will be called <em>once</em> and that function call-overhead is practically naught compared to everything else that is done before the first line in main executes.</p>\n<p>...</p>\n<p>Aaand, it is an easy way to force the symbol to appear only once in your executable. :)</p>\n", "LastActivityDate": "2011-08-08T11:10:31.027", "CommentCount": "0", "CreationDate": "2011-08-08T11:10:31.027", "ParentId": "6981104", "Score": "3", "OwnerUserId": "72312"}, "6985456": {"Id": "6985456", "PostTypeId": "2", "Body": "<p>You can only define <code>main</code> once. So putting <code>inline</code> would not serve any purpose - <code>inline</code> only has a significant purpose on functions you can define multiple times in a program (all definitions will be treated as if there were only one definition and all definitions are required to be the same).</p>\n<p>Because <code>inline</code> functions can be defined multiple times in a program, and <code>inline</code> also serves the purpose of making calls to an <code>inline</code>-marked function as fast as possible, the Standard requires <code>inline</code> functions to be defined in every translation unit in which it is used. So compilers will usually throw away the definition of a function if it is <code>inline</code> and the function wasn't used by the code in the current translation unit. To do that for <code>main</code> would be entirely wrong, which goes to show that <code>inline</code> and the semantics <code>main</code> has is entirely incompatible. </p>\n<p>Note that the question in your title \"Why main() in C++ cannot be inlined?\" and the statement you quote out of the Standard concern different things. You are asking whether the function can be inlined, which commonly is understood to insert the code of a called function completely or partially into the calling function. Just marking a function <code>inline</code> doesn't imply inlining that function at all. It's entirely the compiler's decision, and of course if you never call <code>main</code> (and you cannot do so) then there is nothing to be inlined.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-08-08T16:47:46.030", "Score": "6", "CreationDate": "2011-08-08T16:41:17.093", "ParentId": "6981104", "CommentCount": "3", "OwnerUserId": "34509", "LastEditDate": "2011-08-08T16:47:46.030"}, "bq_ids": {"n4140": {"so_6981104_6982101_0": {"length": 25, "quality": 0.78125, "section_id": 7147}}, "n3337": {"so_6981104_6982101_0": {"length": 25, "quality": 0.78125, "section_id": 6891}}, "n4659": {"so_6981104_6982101_0": {"length": 24, "quality": 0.75, "section_id": 8648}}}, "6982101": {"Id": "6982101", "PostTypeId": "2", "Body": "<p>Because the standard says so:</p>\n<blockquote>\n<p id=\"so_6981104_6982101_0\"><code>[2003: 3.6.1/3]</code>: \n  The function main shall not be used (3.2) within a program. The\n  linkage (3.5) of main is implementation-defined. <strong>A program that\n  declares main to be inline or static is ill-formed.</strong> The name main is\n  not otherwise reserved. [Example: member functions, classes, and\n  enumerations can be called main, as can entities in other namespaces.\n  ]</p>\n</blockquote>\n<p>And why does it say so? Because it's trying to leave as much about the implementation of <code>main</code> to the individual .. well, <em>implementation</em> .. as is possible, and doesn't want to limit implementations by requiring that <code>inline</code> be valid here when it arguably has no practical benefit.</p>\n<hr>\n<p>My friend on the committee confirmed this:</p>\n<blockquote>\n<p id=\"so_6981104_6982101_1\">There's no reason why an <code>inline</code> <code>main()</code> wouldn't work, per se. [..] I could have a C++ interpreter that can invoke inlined <code>main()</code>. [..] [But] <code>inline</code>/<code>static</code> <code>main()</code> are forbidden in order to hopefully avoid confusion. I find it hard to imagine that the rationale would be anything additional to what's already been said in [this Q&amp;A].</p>\n</blockquote>\n<hr>\n<p>BTW, don't confuse the <code>inline</code> hint keyword with actually inlining functions. You can mark a function <code>inline</code> and it may not be physically inlined.</p>\n<p>So, even if it were true that <code>main</code> \"cannot be inlined\" (and strictly speaking it is <em>not</em> true, though inlining <code>main</code> would be rather awkward and pointless as explained in other answers), it could theoretically still support the <code>inline</code> hint keyword just fine.</p>\n<p>It doesn't for the reason stated above, and in litb's answer: it would complicate matters for no real benefit.</p>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2011-08-11T00:15:08.577", "Score": "65", "CreationDate": "2011-08-08T12:27:18.590", "ParentId": "6981104", "CommentCount": "8", "OwnerUserId": "560648", "LastEditDate": "2011-08-11T00:15:08.577"}, "6981204": {"Id": "6981204", "PostTypeId": "2", "Body": "<p>firstly you must understand how work function with inline</p>\n<p>example:</p>\n<pre><code> inline void f() {\n     int a  = 3;\n     a += 3;\n     cout &lt;&lt; a;\n }\n\n int main() {\n      f();\n      return 0;\n }\n</code></pre>\n<p>will look like to the compiler as:</p>\n<pre><code> int main() {\n        int a  = 3;\n        a += 3;\n        cout &lt;&lt; a;\n        return 0;\n }\n</code></pre>\n<p>looking at this example, how do you want to make main inline? This method is inline immediately.</p>\n", "LastEditorUserId": "787828", "LastActivityDate": "2011-08-08T21:57:34.207", "Score": "10", "CreationDate": "2011-08-08T11:06:57.840", "ParentId": "6981104", "CommentCount": "4", "OwnerUserId": "787828", "LastEditDate": "2011-08-08T21:57:34.207"}, "6986267": {"Id": "6986267", "PostTypeId": "2", "Body": "<p>There are a number of basic reasons.  Basically, <code>main</code> is called from\nthe basic initialization routine of the runtime, and only from there.\nThat code was (obviously) compiled without knowing that your <code>main</code> was\ninlined.  Modern compiler technology is capable of inlining across\nmodule boundaries, but it's an advanced feature, not supported by many\nolder compilers.  And of course, the benefits of inlining are only\npresent when a function is called very frequently; by definition, <code>main</code>\nwill be called exactly once, no more, no less. </p>\n", "LastActivityDate": "2011-08-08T17:47:38.090", "CommentCount": "0", "CreationDate": "2011-08-08T17:47:38.090", "ParentId": "6981104", "Score": "2", "OwnerUserId": "649665"}, "6981311": {"Id": "6981311", "PostTypeId": "2", "Body": "<p>operating system loads binary data to memory; looks for entry point (the 'main' symbol in c/c++); makes far jump to the addres of the entry point label. Operating system does not know anything about main function in your code until the program is not loaded.</p>\n", "LastActivityDate": "2011-08-08T11:16:18.227", "CommentCount": "1", "CreationDate": "2011-08-08T11:16:18.227", "ParentId": "6981104", "Score": "-2", "OwnerUserId": "878256"}, "6985328": {"Id": "6985328", "PostTypeId": "2", "Body": "<p>The C++ standard says that the <code>main</code> function cannot be inlined, per @Tomalak Geret'kal's reply.  This response discusses possibility of inlining of the <code>main</code> function, were the restriction in the Standard removed.  </p>\n<p><strong>Definition of Inline</strong><br>\nThe <code>inline</code> keyword is a <em>suggestion</em> to the compiler to paste the contents of the function in-situ.  One intent is to remove the overhead present in calling and returning from a function (subroutine).  </br></p>\n<p>An important situation of inlining is the case where there is a pointer to the function.  In this case, there must be at least one static copy of the function.  In this case, the linker can resolve \"external linkages\" of the inlined function because there is one static version.  </p>\n<p>Important to note that the compiler and linker determine whether or not to paste the contents or calls a single instance of the function.  </p>\n<p>Also of note, functions that are <em>not tagged by the programmer</em> may also be inlined by the compiler.</p>\n<p><strong>Inlining the main function</strong><br>\nSince there is only one invocation of <code>main</code> allowed, <strong>how</strong> it is linked is up to the compiler.  Single instances of inline functions are allowed by the Standard.  The compiler is allowed to convert an <code>inlined</code> function into a function call to a single instance.  So the compiler would <strong>ignore</strong> an inline suggestion for the <code>main</code> function.  </br></p>\n<p>The compiler and linker would have to insure that only one instance of the inlined <code>main</code> function exists.  This where the tricky part comes in, especially with external linkage.  One process for ensuring one instance is to leave information that a translation has a 'main' function whether or not it is inlined.  <em>Note:  When a call to an inline function is made, the compiler is allowed to remove the function from the symbol tables for external linkage, since the idea is that the function won't be called by external functions.</em> </p>\n<p><strong>Summary</strong><br>\n<em>Technically</em>, there is nothing preventing the <code>main</code> function from being inlined.  The <em>machinery</em> already exists for converting inlined functions into single instances and for identifying multiple instances of a function.  When there is a pointer to an inlined function, a single instance of a function is made, so it has an address. This machinery would satisfy the Run-Time Library requirements for <code>main</code> having an address.  In the case of <code>inline</code> for the <code>main</code> function, it would be ignored but there should not be any reason to prevent this syntax (except confusing people).  After all, there are already syntax cases that are redundant, such as declaring a parameter that is passed by value (copy) as <code>const</code>.</br></p>\n<p>\"That's just my opinion, I could be wrong.\" -- Dennis Miller, comedian.</p>\n", "LastActivityDate": "2011-08-08T16:32:51.277", "CommentCount": "1", "CreationDate": "2011-08-08T16:32:51.277", "ParentId": "6981104", "Score": "7", "OwnerUserId": "225074"}, "6981829": {"Id": "6981829", "PostTypeId": "2", "Body": "<p>Others have remarked that an invocation of <code>main</code> can not meaningfully be inlined at the machine code level. That's rubbish. It would require a bit of help from the linker (like global optimization) or else per-application recompilation of a bit of the runtime library, but it's quite doable, no technical problem here.</p>\n<p>However, the <strong>hinting</strong> effect of <code>inline</code>, that calls should preferably be inlined, is irrelevant for a function that is only called once and at the top level of control, as <code>main</code> is.</p>\n<p>The only <strong>guaranteed effect</strong> of <code>inline</code> is to allow an external linkage function to be defined (identically) in two or more translation units, i.e. affecting the One Definition Rule.</p>\n<p>As a practical matter this allows the definition to be placed in a header file, and placing it in a header file is a also practically necessary to guarantee identical definitions.</p>\n<p>That does not make sense for <code>main</code>, so there is no reason for <code>main</code> to be <code>inline</code>.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2012-11-16T21:22:29.707", "Score": "7", "CreationDate": "2011-08-08T12:07:14.817", "ParentId": "6981104", "CommentCount": "8", "OwnerUserId": "464581", "LastEditDate": "2012-11-16T21:22:29.707"}, "7007068": {"Id": "7007068", "PostTypeId": "2", "Body": "<p>inline functions don't usually have an address, so there is no portable way to call main, main() needs an address on which the init code can jump into. Inlined functions are meant to be stuck into the calling function, if main is inlined, it should be inlined into the init code of the program, which is not portable either. </p>\n", "LastActivityDate": "2011-08-10T07:10:24.187", "CommentCount": "1", "CreationDate": "2011-08-10T07:10:24.187", "ParentId": "6981104", "Score": "0", "OwnerUserId": "492634"}, "6981150": {"Id": "6981150", "PostTypeId": "2", "Body": "<p>In C++ it is not legal to call the main function in your code, so there'd be no way it could ever be inlined.</p>\n", "LastActivityDate": "2011-08-08T11:01:38.460", "CommentCount": "18", "CreationDate": "2011-08-08T11:01:38.460", "ParentId": "6981104", "Score": "104", "OwnerUserId": "149392"}, "6981195": {"Id": "6981195", "PostTypeId": "2", "Body": "<p>Usually <code>main()</code> is called from systems <code>init()</code> function. Thus, it is needed that there can be <strong>exactly one definition</strong> for <code>main()</code>.</p>\n<p>Now, if we can <code>inline</code> the <code>main()</code> function and include in a header file then, for every translation unit there will be different definition for <code>main()</code>. Which is not allowed. You can declare <code>main()</code> in a <code>namespace</code> and <code>inline</code> it. But not the global <code>main()</code>.</p>\n", "LastActivityDate": "2011-08-08T11:06:20.013", "CommentCount": "8", "CreationDate": "2011-08-08T11:06:20.013", "ParentId": "6981104", "Score": "14", "OwnerUserId": "514235"}, "6987825": {"Id": "6987825", "PostTypeId": "2", "Body": "<p>For most combinations of compiler/archetecture, the <code>main()</code> function in the source becomes a reasonably normal function in the final binary.  This is only because it's convenient on those archetectures, not because the standard says it must be so. </p>\n<p>On memory constrained archetectures, many compilers, ones which produce a flat binary (like intex hex format) instead of a dynamic linker friendly container (like elf or xcoff), optimize all of the boilerplate away, since it would just be bloat.  Some architectures don't support function calls at all (only a limited subset of C++ is possible on these platforms.)</p>\n<p>In order to support the widest variety of such architectures and build environments, the standard elects keep the semantics of <code>main()</code> as open as possible, so that the compiler can do what's right for the widest variety of platforms.  That means that many features available in the language as a whole cannot apply to the startup and shutdown of the application itself.</p>\n<p>If you need something like an inline <code>main()</code> (or reentrancy, or any fancy feature) you can of course call the main function something else:</p>\n<pre><code>inline int myMain(int argc, char **argv) { /* whatever */ }\nint main(int argc, char **argv) { return myMain(argc, argv); }\n</code></pre>\n", "LastActivityDate": "2011-08-08T19:59:56.160", "CommentCount": "0", "CreationDate": "2011-08-08T19:59:56.160", "ParentId": "6981104", "Score": "1", "OwnerUserId": "65696"}});