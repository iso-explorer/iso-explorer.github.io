post_cb({"36021601": {"ParentId": "36021322", "CommentCount": "2", "CreationDate": "2016-03-15T20:37:13.810", "OwnerUserId": "366377", "PostTypeId": "2", "Id": "36021601", "Score": "4", "Body": "<p>In C, the effective type is only relevant when you access an object. Then in is determined by</p>\n<ul>\n<li>the declaration type, if it has one</li>\n<li>the type of another object of which it is a copy (eg. <code>memcpy</code>)</li>\n<li>the type of the lvalue through which it is accessed, e.g if a <code>void*</code> is converted to another pointer type (e.g <code>int*</code>), which then is dereferenced.</li>\n</ul>\n<p>The latter is usually what happens with <code>malloc</code>ed objects, if you assign the return value of <code>malloc</code> to a pointer type.</p>\n", "LastActivityDate": "2016-03-15T20:37:13.810"}, "36021642": {"ParentId": "36021322", "CommentCount": "1", "CreationDate": "2016-03-15T20:39:19.587", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "36021642", "Score": "7", "Body": "<p>According to the C++ specification:</p>\n<blockquote>\n<p id=\"so_36021322_36021642_0\">Dynamic type:</p>\n<p id=\"so_36021322_36021642_1\">&lt;glvalue&gt; type of the most derived object (1.8) to which the glvalue denoted by a glvalue expression refers</p>\n</blockquote>\n<p>The return value of <code>malloc</code> is a block of uninitialized storage. No object has been constructed within that storage. And therefore it has no dynamic type.</p>\n<p>The <code>void*</code> does not point to an object, and only objects have a dynamic type.</p>\n<p>You can create an object within that storage by beginning its lifetime. But until you do so, it's just storage.</p>\n", "LastActivityDate": "2016-03-15T20:39:19.587"}, "36021621": {"ParentId": "36021322", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-03-15T20:38:20.070", "Score": "0", "LastEditorUserId": "4524862", "LastEditDate": "2016-03-15T20:43:54.677", "Id": "36021621", "OwnerUserId": "4524862", "Body": "<p>As per 1.3.7 in C++11 standard,</p>\n<blockquote>\n<p id=\"so_36021322_36021621_0\"><strong>dynamic type</strong>\n<em>glvalue</em> type of the most derived object (1.8) to which the glvalue denoted by a glvalue expression refers\n  [Example: if a pointer (8.3.1) p whose static type is \u201cpointer to class B\u201d is pointing to an object of class\n  D, derived from B (Clause 10), the dynamic type of the expression *p is \u201cD.\u201d References (8.3.2) are treated\n  similarly. \u2014 end example ]</p>\n</blockquote>\n<p>for an example</p>\n<pre><code>class A {}\nclass B : public A {}\nA *a = new B;\n</code></pre>\n<p>the \"static\" type of <code>a</code> is <code>A *</code> while its dynamic type is <code>B *</code>.</p>\n<p>The idea of referencing not the same type comes to protect from something like</p>\n<pre><code>class A{}\nclass B : public A {int x;}\nclass C : public A {int y;}\nA *a = new B;\nreinterpret_cast&lt;C *&gt;(a)-&gt;x;\n</code></pre>\n<p>which may lead to undefined behavior.</p>\n<p><code>void *</code> does not point to an object, but the distinction between dynamic and declaration type makes sense only for objects.</p>\n", "LastActivityDate": "2016-03-15T20:43:54.677"}, "36021510": {"ParentId": "36021322", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-03-15T20:30:38.777", "Score": "3", "LastEditorUserId": "2692339", "LastEditDate": "2016-03-15T20:52:19.600", "Id": "36021510", "OwnerUserId": "2692339", "Body": "<p>Dynamic type is a formal term to describe essentially polymorphic objects i.e. ones with at least one <code>virtual</code> function. It is thus a C++ term as C has no concept of <code>virtual</code>, for example.</p>\n<blockquote>\n<p id=\"so_36021322_36021510_0\">But how is the dynamic type of the object allocated with malloc\n  determined?</p>\n</blockquote>\n<p>It isn't. <code>malloc</code> allocates <code>N</code> <em>raw</em> bytes of memory and returns it through a <code>void*</code> - it's your job to infer the right type. Moreover, this memory just represents the area where the object is placed, but this object will not be alive till you explicitly call its constructor. (again, from a C++ perspective)</p>\n<blockquote>\n<p id=\"so_36021322_36021510_1\">Will the dynamic type of the object pointed to by pi be int?</p>\n</blockquote>\n<p>No, because the term <em>dynamic type</em> is meaningful when describing object with class types. <code>int</code> is not nor can be.</p>\n<pre><code>class Foo\n{\n   //virtual ~Foo() = default; \n   virtual void f() {}\n};\n\nclass Bar : public Foo\n{\n  virtual void f() {}\n};\n\n// ...\nFoo *ptr = new Bar();\n</code></pre>\n<p>Here <code>Foo</code> is the static type of <code>ptr</code> while <code>Bar</code> is its dynamic type.</p>\n", "LastActivityDate": "2016-03-15T20:52:19.600"}, "36023857": {"ParentId": "36021322", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-03-15T23:00:51.743", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:06.060", "Id": "36023857", "OwnerUserId": "3647361", "Body": "<p>The status quo is that <code>malloc</code> does not create objects. The only constructs that do are <code>new</code> expressions, definitions, casts and assignments to variant members. See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0137r0.html\" rel=\"nofollow noreferrer\">P0137R0</a> for proper wording on this.</p>\n<p>If you wanted to use the storage yielded by <code>malloc</code>, assuming that it is properly aligned (which is the case unless you use extended alignments), employ a call to placement new:</p>\n<pre><code>auto p = malloc(sizeof(int));\nint* i = new (p) int{0};\n// i points to an object of type int, initialized to zero\n</code></pre>\n<p>Hence using malloc in C++ is quite useless, as bog-standard <code>new</code> effectively combines the above steps into one.</p>\n<p>See also <a href=\"https://stackoverflow.com/a/36024383/3647361\">@T.C.'s answer</a> in the related question of the asker.</p>\n", "LastActivityDate": "2016-03-16T00:05:43.920"}, "bq_ids": {"n4140": {"so_36021322_36021621_0": {"section_id": 5768, "quality": 0.7941176470588235, "length": 27}, "so_36021322_36021642_1": {"section_id": 5768, "quality": 1.0, "length": 10}, "so_36021322_36021322_0": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_36021322_36021621_0": {"section_id": 5541, "quality": 0.7941176470588235, "length": 27}, "so_36021322_36021642_1": {"section_id": 5541, "quality": 1.0, "length": 10}, "so_36021322_36021322_0": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_36021322_36021621_0": {"section_id": 7225, "quality": 0.6764705882352942, "length": 23}, "so_36021322_36021642_1": {"section_id": 7520, "quality": 0.7, "length": 7}, "so_36021322_36021322_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}, "36021322": {"CommentCount": "22", "ViewCount": "168", "PostTypeId": "1", "LastEditorUserId": "471164", "CreationDate": "2016-03-15T20:18:28.100", "LastActivityDate": "2016-03-16T00:05:43.920", "Title": "What is the dynamic type of the object allocated by malloc?", "AcceptedAnswerId": "36021642", "LastEditDate": "2016-03-15T23:35:36.210", "Id": "36021322", "Score": "4", "Body": "<p>The C++ standard refers to the term \"dynamic type\" (and the C standard refers to \"effective type\" in the similar context), for example</p>\n<blockquote>\n<p id=\"so_36021322_36021322_0\">If a program attempts to access the stored value of an object through a <em>glvalue</em> of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object,</li>\n</ul>\n</blockquote>\n<p>But how is the dynamic type of the object allocated with <code>malloc</code> determined?</p>\n<p>For example:</p>\n<pre><code>void *p = malloc(sizeof(int));\nint *pi = (int*)p;\n</code></pre>\n<p>Will the dynamic type of the object pointed to by <code>pi</code> be <code>int</code>?</p>\n", "Tags": "<c++><malloc><language-lawyer>", "OwnerUserId": "471164", "AnswerCount": "5"}});